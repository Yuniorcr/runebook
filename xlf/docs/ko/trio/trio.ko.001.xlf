<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="trio">
    <body>
      <group id="trio">
        <trans-unit id="bef2203120014b5ce1e1289eaeb349f7fcdca3b8" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2017 Nathaniel J. Smith</source>
          <target state="translated">&amp;copy; 2017 나다니엘 제이 스미스</target>
        </trans-unit>
        <trans-unit id="ec517f2497a37647b77da539c8fae55191e1180f" translate="yes" xml:space="preserve">
          <source>&amp;hellip;but sometimes things aren&amp;rsquo;t so simple, and this trick comes in handy.</source>
          <target state="translated">&amp;hellip; 때때로 일이 그렇게 간단하지 않은 경우가 많으며이 방법은 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4fb6d2402a1cbcb31359bea4775e8e1f08d418c1" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Closing&amp;rdquo; a &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; will close any pipes to the child and wait for it to exit; if cancelled, the child will be forcibly killed and we will ensure it has finished exiting before allowing the cancellation to propagate.</source>
          <target state="translated">&lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; &amp;ldquo;닫는 중&amp;rdquo; 은 자식에 대한 모든 파이프를 닫고 종료 될 때까지 기다립니다. 취소하면 아동이 강제로 사망하며 취소가 전파되기 전에 종료가 완료되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f0f4adc8aea427469a8601d79f1dcd868ba5e686" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Someone&amp;rdquo; calls &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; on the current task, and &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; returns or raises whatever value or error was passed to &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&amp;ldquo;누군가&amp;rdquo; 는 현재 작업에서 &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; 을 호출 하고 &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; 에 전달 된 값이나 오류를 반환하거나 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="c8604471da1133d9557cdc752ec0bb0e36637876" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Someone&amp;rdquo; calls &lt;a href=&quot;#trio.lowlevel.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; on the current task, and &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; returns or raises whatever value or error was passed to &lt;a href=&quot;#trio.lowlevel.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&quot;누군가&quot; 는 현재 작업에서 &lt;a href=&quot;#trio.lowlevel.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; 을 호출 하고 &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#trio.lowlevel.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; 에 전달 된 값이나 오류를 반환하거나 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="ccf9abfb241d7f438ec2c11e44c2435737b57df1" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">(&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt;)</target>
        </trans-unit>
        <trans-unit id="d8c7444763b78bba23c7dd50562415180fa069af" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">(&lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;)</target>
        </trans-unit>
        <trans-unit id="a32968a94511e7d6534824501898e6c14bc715aa" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;reference-lowlevel#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">(&lt;a href=&quot;reference-lowlevel#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;)</target>
        </trans-unit>
        <trans-unit id="dc873552766061f5d4673957da0d66a6e2e71a06" translate="yes" xml:space="preserve">
          <source>(For async APIs, it&amp;rsquo;s not that simple, but you can use sync APIs to build explicit bridges between the two worlds, e.g. by passing async functions and their results back and forth through queues.)</source>
          <target state="translated">(비동기 API의 경우 그렇게 간단하지는 않지만 동기화 API를 사용하여 두 세계 사이에 명시 적 브리지를 구축 할 수 있습니다. 예를 들어 비동기 함수와 그 결과를 대기열을 통해 앞뒤로 전달하면됩니다.)</target>
        </trans-unit>
        <trans-unit id="d0f014a4da71f7c88640d008d942aaa519cd93be" translate="yes" xml:space="preserve">
          <source>(Remember how in the tutorial we emphasized the importance of the &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/tutorial.html#async-sandwich&quot;&gt;&amp;ldquo;async sandwich&amp;rdquo;&lt;/a&gt;, and the way it means that &lt;code&gt;await&lt;/code&gt; ends up being a marker that shows when you&amp;rsquo;re calling a function that calls a function that &amp;hellip; eventually calls one of Trio&amp;rsquo;s built-in async functions? The transitivity of async-ness is a technical requirement that Python imposes, but since it exactly matches the transitivity of checkpoint-ness, we&amp;rsquo;re able to exploit it to help you keep track of checkpoints. Pretty sneaky, eh?)</source>
          <target state="translated">(튜토리얼에서 우리가 &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/tutorial.html#async-sandwich&quot;&gt;&quot;비동기 샌드위치&quot;&lt;/a&gt; 의 중요성을 강조한 방법을 기억하십시오 . 그리고 &lt;code&gt;await&lt;/code&gt; 방법 은 결국 함수를 호출하는 함수를 호출 할 때 표시되는 마커가됩니다. 비동기 함수의 전이 비동기의 전이는 파이썬이 부과하는 기술적 요구 사항이지만, 검사 점의 전이와 정확히 일치하므로이를 활용하여 검사 점을 추적 할 수 있습니다. ?)</target>
        </trans-unit>
        <trans-unit id="a1d7a67d34c3c28aa0d68e1a6e2fa046980b671e" translate="yes" xml:space="preserve">
          <source>(Remember how in the tutorial we emphasized the importance of the &lt;a href=&quot;https://trio.readthedocs.io/en/v0.18.0/tutorial.html#async-sandwich&quot;&gt;&amp;ldquo;async sandwich&amp;rdquo;&lt;/a&gt;, and the way it means that &lt;code&gt;await&lt;/code&gt; ends up being a marker that shows when you&amp;rsquo;re calling a function that calls a function that &amp;hellip; eventually calls one of Trio&amp;rsquo;s built-in async functions? The transitivity of async-ness is a technical requirement that Python imposes, but since it exactly matches the transitivity of checkpoint-ness, we&amp;rsquo;re able to exploit it to help you keep track of checkpoints. Pretty sneaky, eh?)</source>
          <target state="translated">(튜토리얼에서 &lt;a href=&quot;https://trio.readthedocs.io/en/v0.18.0/tutorial.html#async-sandwich&quot;&gt;&amp;ldquo;비동기 샌드위치&amp;rdquo;&lt;/a&gt; 의 중요성을 어떻게 강조했는지 기억하세요 . 그리고 이것이 의미하는 방식은 &lt;code&gt;await&lt;/code&gt; 가 결국 Trio의 빌드 중 하나를 호출하는 함수를 호출하는 함수를 호출 할 때 표시되는 마커가되는 것을 의미합니다. -in async functions? async-ness의 전이성은 파이썬이 부과하는 기술적 요구 사항이지만 체크 포인트의 전이성과 정확히 일치하기 때문에 우리는 체크 포인트를 추적하는 데 도움을 줄 수 있습니다. ?)</target>
        </trans-unit>
        <trans-unit id="d296b42ed1d09870d027c1410c66d13e95252382" translate="yes" xml:space="preserve">
          <source>(Terminology: in Trio, &amp;ldquo;aborting&amp;rdquo; is the process of attempting to interrupt a blocked task to deliver a cancellation.)</source>
          <target state="translated">(용어 : Trio에서 &quot;중지&quot;는 차단 된 작업을 중단하여 취소를 전달하는 프로세스입니다.)</target>
        </trans-unit>
        <trans-unit id="c2f19c69f6132072ce946fcd569fd7ec82a0d405" translate="yes" xml:space="preserve">
          <source>...but sometimes things aren&amp;rsquo;t so simple, and this trick comes in handy.</source>
          <target state="translated">...하지만 때로는 일이 그렇게 간단하지 않고이 트릭이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="de6b4e9bc8ed194603578653ce489207afc96512" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt; is Trio&amp;rsquo;s &amp;ldquo;hazardous materials&amp;rdquo; layer: it contains APIs useful for introspecting and extending Trio. If you&amp;rsquo;re writing ordinary, everyday code, then you can ignore this module completely. But sometimes you need something a bit lower level. Here are some examples of situations where you should reach for &lt;a href=&quot;#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; &lt;/a&gt; 는 Trio의 &quot;유해 물질&quot;레이어입니다. Trio.introspecting 및 확장에 유용한 API가 포함되어 있습니다. 일상적인 일상 코드를 작성하는 경우이 모듈을 완전히 무시할 수 있습니다. 그러나 때로는 약간 낮은 수준의 무언가가 필요합니다. 다음은&lt;a href=&quot;#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; 에&lt;/a&gt; 도달해야하는 상황의 예입니다.</target>
        </trans-unit>
        <trans-unit id="9ae898959a73cdca45420c7f0680412508f346a7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#module-trio.lowlevel&quot;&gt;&lt;code&gt;trio.lowlevel&lt;/code&gt;&lt;/a&gt; contains low-level APIs for introspecting and extending Trio. If you&amp;rsquo;re writing ordinary, everyday code, then you can ignore this module completely. But sometimes you need something a bit lower level. Here are some examples of situations where you should reach for &lt;a href=&quot;#module-trio.lowlevel&quot;&gt;&lt;code&gt;trio.lowlevel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#module-trio.lowlevel&quot;&gt; &lt;code&gt;trio.lowlevel&lt;/code&gt; &lt;/a&gt; 에는 Trio를 검사하고 확장하기위한 저수준 API가 포함되어 있습니다. 평범하고 일상적인 코드를 작성하는 경우이 모듈을 완전히 무시할 수 있습니다. 그러나 때로는 조금 더 낮은 수준이 필요합니다. 다음은&lt;a href=&quot;#module-trio.lowlevel&quot;&gt; &lt;code&gt;trio.lowlevel&lt;/code&gt; 에&lt;/a&gt; 도달해야하는 상황의 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="16172e29d7c65bbb8fa0ac4bcac9e89dc906f3a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the corresponding call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; completes while &lt;code&gt;afn(*args)&lt;/code&gt; is running, then &lt;code&gt;afn&lt;/code&gt; is likely to raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;trio.Cancelled&lt;/code&gt;&lt;/a&gt;, and this will propagate out into</source>
          <target state="translated">&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; -에 해당 호출하면&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 동안 완료 &lt;code&gt;afn(*args)&lt;/code&gt; 다음 실행 &lt;code&gt;afn&lt;/code&gt; 가능성이 제기하는 것입니다&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;trio.Cancelled&lt;/code&gt; 을&lt;/a&gt; 하고,이에 보내집니다</target>
        </trans-unit>
        <trans-unit id="4522539e2495d37a3558c4aca9b0391fd5659005" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the corresponding call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt; completes while &lt;code&gt;afn(*args)&lt;/code&gt; is running, then &lt;code&gt;afn&lt;/code&gt; is likely to raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;trio.Cancelled&lt;/code&gt;&lt;/a&gt;, and this will propagate out into</source>
          <target state="translated">&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; - 해당 호출하는 경우&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run&lt;/code&gt; &lt;/a&gt; 동안 완료 &lt;code&gt;afn(*args)&lt;/code&gt; 실행을, 다음 &lt;code&gt;afn&lt;/code&gt; 인상 가능성이&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;trio.Cancelled&lt;/code&gt; 을&lt;/a&gt; , 이것은로 보내집니다</target>
        </trans-unit>
        <trans-unit id="82a5777a254e3527db31e1099d99402997315cfe" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you already closed this &lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt;&lt;code&gt;MemoryReceiveChannel&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이&lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt; &lt;code&gt;MemoryReceiveChannel&lt;/code&gt; &lt;/a&gt; 객체를 이미 닫은 경우</target>
        </trans-unit>
        <trans-unit id="5221ef4c341ee662700ec147b45ff87a5fc43280" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you already closed this &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt;&lt;code&gt;MemorySendChannel&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이&lt;a href=&quot;#trio.MemorySendChannel&quot;&gt; &lt;code&gt;MemorySendChannel&lt;/code&gt; &lt;/a&gt; 객체를 이미 닫은 경우</target>
        </trans-unit>
        <trans-unit id="50829a08be317170d9f389e8760f1224e6c7231b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.MemorySendChannel&quot;&gt;&lt;code&gt;MemorySendChannel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt;&lt;code&gt;MemoryReceiveChannel&lt;/code&gt;&lt;/a&gt; also expose several more features beyond the core channel interface:</source>
          <target state="translated">&lt;a href=&quot;#trio.MemorySendChannel&quot;&gt; &lt;code&gt;MemorySendChannel&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt; &lt;code&gt;MemoryReceiveChannel&lt;/code&gt; &lt;/a&gt; 은 코어 채널 인터페이스를 넘어 몇 가지 더 많은 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1191d82fd801b160f1e9a28e8ee8a9d0ce275626" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; implements the &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; interface. In order to make sure your process doesn&amp;rsquo;t end up getting abandoned by mistake or after an exception, you can use &lt;code&gt;async with&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 는&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt; 인터페이스를구현합니다. 실수로 또는 예외 후에 프로세스가 중단되지 않도록하기 위해 다음 &lt;code&gt;async with&lt;/code&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed633d43a7d59387a16164d3a36d3dd27bd2a575" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.RunFinishedError&quot;&gt;&lt;code&gt;RunFinishedError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the corresponding call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; has already completed, or if the run has started its final cleanup phase and can no longer spawn new system tasks.</source>
          <target state="translated">&lt;a href=&quot;#trio.RunFinishedError&quot;&gt; &lt;code&gt;RunFinishedError&lt;/code&gt; &lt;/a&gt; &amp;ndash;&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 대한 해당 호출이 이미 완료되었거나 실행이 최종 정리 단계를 시작하여 더 이상 새 시스템 작업을 생성 할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="766c979a03f106b8bb33b1bc540b87ed5047ca18" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.RunFinishedError&quot;&gt;&lt;code&gt;RunFinishedError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the corresponding call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; has already completed.</source>
          <target state="translated">&lt;a href=&quot;#trio.RunFinishedError&quot;&gt; &lt;code&gt;RunFinishedError&lt;/code&gt; &lt;/a&gt; &amp;ndash;&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 대한 해당 호출이 이미 완료된 경우</target>
        </trans-unit>
        <trans-unit id="d2116e282390c51e8b03416366342a5e08cc1519" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.RunFinishedError&quot;&gt;&lt;code&gt;RunFinishedError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the corresponding call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt; has already completed.</source>
          <target state="translated">&lt;a href=&quot;#trio.RunFinishedError&quot;&gt; &lt;code&gt;RunFinishedError&lt;/code&gt; &lt;/a&gt; -에 해당 호출하면&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run&lt;/code&gt; 은&lt;/a&gt; 이미 완료했다.</target>
        </trans-unit>
        <trans-unit id="e4d06d67b4f7143ccd7e612116d631feb4897116" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.SSLListener&quot;&gt;&lt;code&gt;SSLListener&lt;/code&gt;&lt;/a&gt; wraps around another Listener, and converts all incoming connections to encrypted connections by wrapping them in a &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.SSLListener&quot;&gt; &lt;code&gt;SSLListener&lt;/code&gt; &lt;/a&gt; 는 다른 리스너를 감싸고 들어오는 모든 연결을&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 에 감싸서 암호화 된 연결로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="27eb0e1aa9b6f01d4feddc5e9ef9d83ad48d2eb4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; wraps an arbitrary &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;, and allows you to perform encrypted communication over it using the usual &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; interface. You pass regular data to &lt;a href=&quot;#trio.SSLStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt;, then it encrypts it and sends the encrypted data on the underlying &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;; &lt;a href=&quot;#trio.SSLStream.receive_some&quot;&gt;&lt;code&gt;receive_some()&lt;/code&gt;&lt;/a&gt; takes encrypted data out of the underlying &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; and decrypts it before returning it.</source>
          <target state="translated">&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 은 임의의&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; 을&lt;/a&gt; 감싸고일반적인&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 인터페이스를사용하여 암호화 된 통신을 수행 할 수 있습니다. &lt;a href=&quot;#trio.SSLStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; 일반 데이터를 전달한 다음이를 암호화하고 기본&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 에서 암호화 된 데이터를 전송합니다. &lt;a href=&quot;#trio.SSLStream.receive_some&quot;&gt; &lt;code&gt;receive_some()&lt;/code&gt; &lt;/a&gt; 은 기본&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 에서 암호화 된 데이터를 가져 와서반환하기 전에 해독합니다.</target>
        </trans-unit>
        <trans-unit id="8d9019328b65e5c7fec599529982887ad00ddabc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;trio.SSLStream&lt;/code&gt;&lt;/a&gt; is a &amp;ldquo;stream adapter&amp;rdquo; that can take any object that implements the &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;trio.abc.Stream&lt;/code&gt;&lt;/a&gt; interface, and convert it into an encrypted stream. In Trio the standard way to speak SSL over the network is to wrap an &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; around a &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;trio.SSLStream&lt;/code&gt; &lt;/a&gt; 은&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;trio.abc.Stream&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하는 모든 객체를 가져 와서암호화 된 스트림으로 변환 할수있는 &quot;스트림 어댑터&quot;입니다. 트리오에서 네트워크를 통해 말하다 SSL에 대한 표준 방법은 래핑하는 것입니다&lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 전세계 거의&lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="39dc95c50403cd2d43435da845f9299acf4c54d8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.SSLListener&quot;&gt;&lt;code&gt;SSLListener&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#trio.SSLListener&quot;&gt; &lt;code&gt;SSLListener&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6b9f488f7b849505fd8967b05648e0aff408e168" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f9511dac7a7d7e0421ef833ef7c70c4edf0bb546" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;trio.SocketStream&lt;/code&gt;&lt;/a&gt; wraps a raw socket (like a TCP connection over the network), and converts it to the standard stream interface.</source>
          <target state="translated">&lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;trio.SocketStream&lt;/code&gt; &lt;/a&gt; 은 네트워크를 통한 TCP 연결과 같은 원시 소켓을 래핑하여 표준 스트림 인터페이스로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="ae6277fd3b5f495c7e304f8c1c45ef5f868ae8e7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt; objects implement the methods in the &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;HalfCloseableStream&lt;/code&gt;&lt;/a&gt; interface. They also have two additional public attributes:</source>
          <target state="translated">&lt;a href=&quot;#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt; 객체는&lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;HalfCloseableStream&lt;/code&gt; &lt;/a&gt; 인터페이스에서 메소드를 구현합니다. 또한 두 가지 추가 공용 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c670588016ac1f9cc12493b77b445b2978d80770" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.StapledStream&quot;&gt;trio.StapledStream&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;None&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.StapledStream&quot;&gt;trio.StapledStream&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;없음&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b58648e3befd84ce4fcd29135a2a900554b16eca" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt;&lt;code&gt;StrictFIFOLock&lt;/code&gt;&lt;/a&gt; provides an alternative. We can rewrite our example like:</source>
          <target state="translated">&lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt; &lt;code&gt;StrictFIFOLock&lt;/code&gt; &lt;/a&gt; 은 대안을 제공합니다. 다음과 같이 예제를 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdc2626d3ed97353c2976e470d8167af2d83cc59" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.TASK_STATUS_IGNORED&quot;&gt;&lt;code&gt;trio.TASK_STATUS_IGNORED&lt;/code&gt;&lt;/a&gt; is a special global object with a do-nothing &lt;code&gt;started&lt;/code&gt; method. This way your function supports being called either like &lt;code&gt;await nursery.start(async_fn, arg1,
arg2)&lt;/code&gt; or directly like &lt;code&gt;await async_fn(arg1, arg2)&lt;/code&gt;, and either way it can call &lt;code&gt;task_status.started()&lt;/code&gt; without worrying about which mode it&amp;rsquo;s in. Defining your function like this will make it obvious to readers that it supports being used in both modes.</source>
          <target state="translated">&lt;a href=&quot;#trio.TASK_STATUS_IGNORED&quot;&gt; &lt;code&gt;trio.TASK_STATUS_IGNORED&lt;/code&gt; &lt;/a&gt; 는 아무것도 &lt;code&gt;started&lt;/code&gt; 하지 않은메소드를가진 특별한 전역 객체입니다. 이렇게하면 함수가 &lt;code&gt;await nursery.start(async_fn, arg1, arg2)&lt;/code&gt; 와 같이 또는 &lt;code&gt;await async_fn(arg1, arg2)&lt;/code&gt; 와 같이 호출되는 것을 지원하고 어떤 모드에 있는지 걱정하지 않고 &lt;code&gt;task_status.started()&lt;/code&gt; 를호출 할 수 있습니다. 이와 같이 함수를 정의하면 독자가 두 모드 모두에서 사용할 수 있음을 분명히 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2b2153e4fdf6d653827336465dc85f015afdc90" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.TooSlowError&quot;&gt;&lt;code&gt;TooSlowError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception is raised in this scope and caught by the context manager.</source>
          <target state="translated">&lt;a href=&quot;#trio.TooSlowError&quot;&gt; &lt;code&gt;TooSlowError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이 범위에서&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외가 발생하여 컨텍스트 관리자가 발견 한 경우.</target>
        </trans-unit>
        <trans-unit id="b00c291635e865ead631ad77bb672261484f29e8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.TrioInternalError&quot;&gt;&lt;code&gt;TrioInternalError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if an unexpected error is encountered inside Trio&amp;rsquo;s internal machinery. This is a bug and you should &lt;a href=&quot;https://github.com/python-trio/trio/issues&quot;&gt;let us know&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.TrioInternalError&quot;&gt; &lt;code&gt;TrioInternalError&lt;/code&gt; &lt;/a&gt; &amp;ndash; Trio의 내부 기계에 예기치 않은 오류가 발생한 경우. 이것은 버그이며&lt;a href=&quot;https://github.com/python-trio/trio/issues&quot;&gt; 저희에게 알려주십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="549feaf6540c3715124d879f456890f89951c201" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.WouldBlock&quot;&gt;&lt;code&gt;WouldBlock&lt;/code&gt;&lt;/a&gt; &amp;ndash; if no tokens are available.</source>
          <target state="translated">&lt;a href=&quot;#trio.WouldBlock&quot;&gt; &lt;code&gt;WouldBlock&lt;/code&gt; &lt;/a&gt; &amp;ndash; 사용 가능한 토큰이없는 경우.</target>
        </trans-unit>
        <trans-unit id="3f9ca7941e6449091fb63e720a3c660944189b07" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.WouldBlock&quot;&gt;&lt;code&gt;WouldBlock&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the lock is currently held.</source>
          <target state="translated">&lt;a href=&quot;#trio.WouldBlock&quot;&gt; &lt;code&gt;WouldBlock&lt;/code&gt; &lt;/a&gt; &amp;ndash; 현재 잠금이 유지 된 경우.</target>
        </trans-unit>
        <trans-unit id="dc0a5bb70c6ad1196434a26fc4621b6dd99c673f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.WouldBlock&quot;&gt;&lt;code&gt;WouldBlock&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the lock is held.</source>
          <target state="translated">&lt;a href=&quot;#trio.WouldBlock&quot;&gt; &lt;code&gt;WouldBlock&lt;/code&gt; &lt;/a&gt; &amp;ndash; 잠금이 유지 된 경우.</target>
        </trans-unit>
        <trans-unit id="849c0db0436a026adf0117e8229b6378d06e4c9b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.WouldBlock&quot;&gt;&lt;code&gt;WouldBlock&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the value is zero.</source>
          <target state="translated">&lt;a href=&quot;#trio.WouldBlock&quot;&gt; &lt;code&gt;WouldBlock&lt;/code&gt; &lt;/a&gt; &amp;ndash; 값이 0 인 경우</target>
        </trans-unit>
        <trans-unit id="9d933041f11b3862064d016fb63e7fd87b9bf8e6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; objects guarantee that if their &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; method is cancelled, then they will still close the resource (albeit in a potentially ungraceful fashion). &lt;a href=&quot;#trio.aclose_forcefully&quot;&gt;&lt;code&gt;aclose_forcefully()&lt;/code&gt;&lt;/a&gt; is a convenience function that exploits this behavior to let you force a resource to be closed without blocking: it works by calling &lt;code&gt;await resource.aclose()&lt;/code&gt; and then cancelling it immediately.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt; 객체는&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 메소드가 취소 된 경우에도 리소스를 닫을수 있음을 보증합니다 (잠재적이지 않은 방식으로도). &lt;a href=&quot;#trio.aclose_forcefully&quot;&gt; &lt;code&gt;aclose_forcefully()&lt;/code&gt; &lt;/a&gt; 는이 동작을 이용하여 리소스를 차단하지 않고 강제로 닫을 수 있도록하는 편리한 함수입니다. &lt;code&gt;await resource.aclose()&lt;/code&gt; 를 호출한 다음 즉시 취소하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d1c77ff1d57034f8744ad3c068e6cd1972fa4642" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;code&gt;Listener&lt;/code&gt;&lt;/a&gt; objects also implement the &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; interface, so they can be closed by calling &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; or using an &lt;code&gt;async with&lt;/code&gt; block.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.Listener&quot;&gt; &lt;code&gt;Listener&lt;/code&gt; &lt;/a&gt; 객체는&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt; 인터페이스도 구현하므로&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 를 호출하거나 &lt;code&gt;async with&lt;/code&gt; block을사용하여닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="902354761b623469449754ba405ab35807f70b82" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;ReceiveChannel&lt;/code&gt;&lt;/a&gt; objects also implement the &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; interface, so they can be closed by calling &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose&lt;/code&gt;&lt;/a&gt; or using an &lt;code&gt;async
with&lt;/code&gt; block.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;ReceiveChannel&lt;/code&gt; &lt;/a&gt; 객체는&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt; 인터페이스도 구현하므로&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose&lt;/code&gt; &lt;/a&gt; 를 호출하거나 &lt;code&gt;async with&lt;/code&gt; block을사용하여닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f8bab82170865ea40192808e48763d40474bfdf" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt; objects also implement the &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; interface, so they can be closed by calling &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; or using an &lt;code&gt;async with&lt;/code&gt; block.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; 객체는&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt; 인터페이스도 구현하므로&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 를 호출하거나 &lt;code&gt;async with&lt;/code&gt; block을사용하여닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91e0fccdabd247d7386e1ff9a0f28c9659425e93" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt; objects can be used in &lt;code&gt;async for&lt;/code&gt; loops. Each iteration will produce an arbitrary sized chunk of bytes, like calling &lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt;&lt;code&gt;receive_some&lt;/code&gt;&lt;/a&gt; with no arguments. Every chunk will contain at least one byte, and the loop automatically exits when reaching end-of-file.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; 객체는 &lt;code&gt;async for&lt;/code&gt; 루프에서 사용될 수 있습니다. 각 반복은인수없이&lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt; &lt;code&gt;receive_some&lt;/code&gt; &lt;/a&gt; 를호출하는 것과 같이 임의의 크기의 바이트 청크를 생성합니다. 모든 청크에는 최소한 하나의 바이트가 포함되며 파일 끝에 도달하면 루프가 자동으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="9c08869ed76667edaa59772101eee697d85a3831" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;trio.abc.ReceiveStream&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;None&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;trio.abc.ReceiveStream&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;없음&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14d3253b8802ee45d506acd8a102a38c9d357ad1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.SendChannel&quot;&gt;&lt;code&gt;SendChannel&lt;/code&gt;&lt;/a&gt; objects also implement the &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; interface, so they can be closed by calling &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose&lt;/code&gt;&lt;/a&gt; or using an &lt;code&gt;async
with&lt;/code&gt; block.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.SendChannel&quot;&gt; &lt;code&gt;SendChannel&lt;/code&gt; &lt;/a&gt; 객체는&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt; 인터페이스도 구현하므로&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose&lt;/code&gt; &lt;/a&gt; 를 호출하거나 &lt;code&gt;async with&lt;/code&gt; block을사용하여닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f29f1ba8ee04eadcbae71b426c5b4c069cccaf21" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.SendChannel&quot;&gt;&lt;code&gt;SendChannel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;ReceiveChannel&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.SendChannel&quot;&gt; &lt;code&gt;SendChannel&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;ReceiveChannel&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a035426238cc1a5b76516260e0a92a86d67708e5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt; objects also implement the &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; interface, so they can be closed by calling &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; or using an &lt;code&gt;async with&lt;/code&gt; block.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; 객체는&lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt; 인터페이스도 구현하므로&lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 를 호출하거나 &lt;code&gt;async with&lt;/code&gt; block을사용하여닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d28528d08e13f2a598e7a5c2f5e861d2e65160d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8a0c215248a8073bfb6e7bd36af3aa832920275a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.SendStream&quot;&gt;trio.abc.SendStream&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;None&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.SendStream&quot;&gt;trio.abc.SendStream&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;없음&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="85d41edb56002d937851f7956c119621d70006ba" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d7777fb2718686935e4d26fd0d8f654ba9dc32d3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.hazmat.FdStream&quot;&gt;&lt;code&gt;FdStream&lt;/code&gt;&lt;/a&gt; supports wrapping Unix files (such as a pipe or TTY) as a stream.</source>
          <target state="translated">&lt;a href=&quot;#trio.hazmat.FdStream&quot;&gt; &lt;code&gt;FdStream&lt;/code&gt; &lt;/a&gt; 은 파이프 나 TTY와 같은 Unix 파일을 스트림으로 래핑하는 것을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1651f3be898b718cb8da61e7478aa37060209193" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.hazmat.RunVar&quot;&gt;&lt;code&gt;RunVar&lt;/code&gt;&lt;/a&gt; objects are similar to context variable objects, except that they are shared across a single call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; rather than a single task.</source>
          <target state="translated">&lt;a href=&quot;#trio.hazmat.RunVar&quot;&gt; &lt;code&gt;RunVar&lt;/code&gt; &lt;/a&gt; 객체는단일 작업이 아닌&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 대한 단일 호출에서 공유된다는 점을 제외하고 컨텍스트 변수 객체와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="d7f7442f88825b096e3f5433e82e88e5d8bf3a52" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.lowlevel.FdStream&quot;&gt;&lt;code&gt;FdStream&lt;/code&gt;&lt;/a&gt; supports wrapping Unix files (such as a pipe or TTY) as a stream.</source>
          <target state="translated">&lt;a href=&quot;#trio.lowlevel.FdStream&quot;&gt; &lt;code&gt;FdStream&lt;/code&gt; &lt;/a&gt; 은 Unix 파일 (예 : 파이프 또는 TTY)을 스트림으로 래핑하는 것을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8f15950e9cf4934fc7197169ed3a55b57dfee29c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.lowlevel.RunVar&quot;&gt;&lt;code&gt;RunVar&lt;/code&gt;&lt;/a&gt; objects are similar to context variable objects, except that they are shared across a single call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; rather than a single task.</source>
          <target state="translated">&lt;a href=&quot;#trio.lowlevel.RunVar&quot;&gt; &lt;code&gt;RunVar&lt;/code&gt; &lt;/a&gt; 객체는단일 태스크가 아닌&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 대한 단일 호출에서 공유된다는 점을 제외하면 컨텍스트 변수 객체와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="028c21704b3033e686082fe0983e0e4f6f9f902e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.move_on_after&quot;&gt;&lt;code&gt;move_on_after()&lt;/code&gt;&lt;/a&gt; and all the other cancellation facilities provided by Trio are ultimately implemented in terms of &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">&lt;a href=&quot;#trio.move_on_after&quot;&gt; &lt;code&gt;move_on_after()&lt;/code&gt; &lt;/a&gt; 및 Trio가 제공하는 다른 모든 취소 기능은 궁극적으로&lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; &lt;/a&gt; 객체로구현됩니다.</target>
        </trans-unit>
        <trans-unit id="5faaf57ec2674b73c0641070aa02d4d816051ce1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.open_process&quot;&gt;&lt;code&gt;trio.open_process&lt;/code&gt;&lt;/a&gt; starts a process in the background and returns a &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; object to let you interact with it. Using it requires a bit more code than &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process&lt;/code&gt;&lt;/a&gt;, but exposes additional capabilities: back-and-forth communication, processing output as soon as it is generated, and so forth. It is modelled after the standard library &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt;&lt;code&gt;subprocess.Popen&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.open_process&quot;&gt; &lt;code&gt;trio.open_process&lt;/code&gt; &lt;/a&gt; 는 백그라운드에서 프로세스를 시작하고상호 작용할 수 있도록&lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 객체를반환합니다. 이를 사용하려면&lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process&lt;/code&gt; &lt;/a&gt; 보다 약간 더 많은 코드가 필요하지만, 앞뒤 통신, 생성되는 즉시 출력 처리 등의 추가 기능이 노출됩니다. 표준 라이브러리&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt; &lt;code&gt;subprocess.Popen&lt;/code&gt; &lt;/a&gt; 모델로합니다.</target>
        </trans-unit>
        <trans-unit id="6597caa4903e6c646d0ff25b3284f9e477331f08" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;trio.run_process()&lt;/code&gt;&lt;/a&gt; runs a process from start to finish and returns a &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;CompletedProcess&lt;/code&gt;&lt;/a&gt; object describing its outputs and return value. This is what you should reach for if you want to run a process to completion before continuing, while possibly sending it some input or capturing its output. It is modelled after the standard &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.run&quot;&gt;&lt;code&gt;subprocess.run()&lt;/code&gt;&lt;/a&gt; with some additional features and safer defaults.</source>
          <target state="translated">&lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;trio.run_process()&lt;/code&gt; &lt;/a&gt; 는 프로세스를 처음부터 끝까지 실행하고 출력 및 반환 값을 설명하는&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;CompletedProcess&lt;/code&gt; &lt;/a&gt; 객체를 반환합니다. 이것은 입력을 보내거나 출력을 캡처하는 동안 계속하기 전에 프로세스를 완료하기 위해 실행하려는 경우 도달해야하는 것입니다. 추가 기능과 더 안전한 기본값으로표준&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.run&quot;&gt; &lt;code&gt;subprocess.run()&lt;/code&gt; &lt;/a&gt; 을모델로합니다.</target>
        </trans-unit>
        <trans-unit id="97ef0dba9d3e1bd15283cea463e9501d21dba9ba" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.socket.SocketType&quot;&gt;&lt;code&gt;trio.socket.SocketType&lt;/code&gt;&lt;/a&gt; is an abstract class and cannot be instantiated directly; you get concrete socket objects by calling constructors like &lt;a href=&quot;#trio.socket.socket&quot;&gt;&lt;code&gt;trio.socket.socket()&lt;/code&gt;&lt;/a&gt;. However, you can use it to check if an object is a Trio socket via &lt;code&gt;isinstance(obj, trio.socket.SocketType)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.socket.SocketType&quot;&gt; &lt;code&gt;trio.socket.SocketType&lt;/code&gt; &lt;/a&gt; 은 추상 클래스이며 직접 인스턴스화 할 수 없습니다. &lt;a href=&quot;#trio.socket.socket&quot;&gt; &lt;code&gt;trio.socket.socket()&lt;/code&gt; &lt;/a&gt; 과 같은 생성자를 호출하여 구체적인 소켓 객체를 얻습니다. 그러나 객체를 사용하여 &lt;code&gt;isinstance(obj, trio.socket.SocketType)&lt;/code&gt; 통해 객체가 Trio 소켓인지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce4adfdbfdc2bb800ee793718d23c2370de1bab3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.testing.MockClock&quot;&gt;&lt;code&gt;trio.testing.MockClock&lt;/code&gt;&lt;/a&gt; is a &lt;a href=&quot;reference-core#trio.abc.Clock&quot;&gt;&lt;code&gt;Clock&lt;/code&gt;&lt;/a&gt; with a few tricks up its sleeve to help you efficiently test code involving timeouts:</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.MockClock&quot;&gt; &lt;code&gt;trio.testing.MockClock&lt;/code&gt; &lt;/a&gt; 은타임 아웃과 관련된 코드를 효율적으로 테스트하는 데 도움이되는 몇 가지 트릭을 가진&lt;a href=&quot;reference-core#trio.abc.Clock&quot;&gt; &lt;code&gt;Clock&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e2c801160f7147e234f8426cb9fc28008469bfa4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt;&lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt;, in turn, is implemented using the low-ish level classes &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;code&gt;MemorySendStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;code&gt;MemoryReceiveStream&lt;/code&gt;&lt;/a&gt;. These are implementations of (you guessed it) &lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt;&lt;code&gt;trio.abc.SendStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;trio.abc.ReceiveStream&lt;/code&gt;&lt;/a&gt; that on their own, aren&amp;rsquo;t attached to anything &amp;ndash; &amp;ldquo;sending&amp;rdquo; and &amp;ldquo;receiving&amp;rdquo; just put data into and get data out of a private internal buffer that each object owns. They also have some interesting hooks you can set, that let you customize the behavior of their methods. This is where you can insert the evil, if you want it. &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt;&lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt; takes advantage of these hooks in a relatively boring way: it just sets it up so that when you call &lt;code&gt;send_all&lt;/code&gt;, or when you close the send stream, then it automatically triggers a call to &lt;a href=&quot;#trio.testing.memory_stream_pump&quot;&gt;&lt;code&gt;memory_stream_pump()&lt;/code&gt;&lt;/a&gt;, which is a convenience function that takes data out of a &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;code&gt;MemorySendStream&lt;/code&gt;&lt;/a&gt;&amp;acute;s buffer and puts it into a &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;code&gt;MemoryReceiveStream&lt;/code&gt;&lt;/a&gt;&amp;acute;s buffer. But that&amp;rsquo;s just the default &amp;ndash; you can replace this with whatever arbitrary behavior you want.</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt; &lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; 는 차례로 낮은 수준의 클래스&lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt; &lt;code&gt;MemorySendStream&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt; &lt;code&gt;MemoryReceiveStream&lt;/code&gt; 을&lt;/a&gt; 사용하여 구현됩니다. 이것들은 (당신이 짐작 한)&lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt; &lt;code&gt;trio.abc.SendStream&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;trio.abc.ReceiveStream&lt;/code&gt; 의&lt;/a&gt; 구현으로, 그 자체로는 아무것도 첨부되지 않습니다. &quot;보내기&quot;및 &quot;수신&quot;은 데이터를 개인 정보에 넣고 데이터를 가져옵니다. 각 개체가 소유하는 내부 버퍼. 또한 사용자가 설정할 수있는 몇 가지 흥미로운 후크가있어 해당 메서드의 동작을 사용자 지정할 수 있습니다. 원하는 경우 여기에 악을 삽입 할 수 있습니다.&lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt; &lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; 는 상대적으로 지루한 방식으로 이러한 후크를 활용합니다. &lt;code&gt;send_all&lt;/code&gt; 을 호출 할 때또는 전송 스트림을 닫을 때 자동으로 &lt;a href=&quot;#trio.testing.memory_stream_pump&quot;&gt; &lt;code&gt;memory_stream_pump()&lt;/code&gt; &lt;/a&gt; 호출을 트리거합니다 . 이는 &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt; &lt;code&gt;MemorySendStream&lt;/code&gt; &lt;/a&gt; 의 버퍼에서 데이터를 가져와 &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt; &lt;code&gt;MemoryReceiveStream&lt;/code&gt; &lt;/a&gt; 의 버퍼에 넣는 편리한 함수입니다 . 그러나 이것은 단지 기본값 일뿐입니다. 원하는 임의의 동작으로이를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05e5c6ddb0d8d65635c282460582a76e6cd7126f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt;&lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt;, in turn, is implemented using the low-ish level classes &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;code&gt;MemorySendStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;code&gt;MemoryReceiveStream&lt;/code&gt;&lt;/a&gt;. These are implementations of (you guessed it) &lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt;&lt;code&gt;trio.abc.SendStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;trio.abc.ReceiveStream&lt;/code&gt;&lt;/a&gt; that on their own, aren&amp;rsquo;t attached to anything &amp;ndash; &amp;ldquo;sending&amp;rdquo; and &amp;ldquo;receiving&amp;rdquo; just put data into and get data out of a private internal buffer that each object owns. They also have some interesting hooks you can set, that let you customize the behavior of their methods. This is where you can insert the evil, if you want it. &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt;&lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt; takes advantage of these hooks in a relatively boring way: it just sets it up so that when you call &lt;code&gt;sendall&lt;/code&gt;, or when you close the send stream, then it automatically triggers a call to &lt;a href=&quot;#trio.testing.memory_stream_pump&quot;&gt;&lt;code&gt;memory_stream_pump()&lt;/code&gt;&lt;/a&gt;, which is a convenience function that takes data out of a &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;code&gt;MemorySendStream&lt;/code&gt;&lt;/a&gt;&amp;acute;s buffer and puts it into a &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;code&gt;MemoryReceiveStream&lt;/code&gt;&lt;/a&gt;&amp;acute;s buffer. But that&amp;rsquo;s just the default &amp;ndash; you can replace this with whatever arbitrary behavior you want.</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt; &lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; 는 하위 레벨 클래스&lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt; &lt;code&gt;MemorySendStream&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt; &lt;code&gt;MemoryReceiveStream&lt;/code&gt; 을&lt;/a&gt; 사용하여 구현됩니다. 이것들은&lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt; &lt;code&gt;trio.abc.SendStream&lt;/code&gt; &lt;/a&gt; 과&lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;trio.abc.ReceiveStream&lt;/code&gt; 의&lt;/a&gt; 구현으로, 그 자체로는 아무것도 붙어 있지 않습니다 &amp;ndash;&amp;ldquo;보내기&amp;rdquo;와&amp;ldquo;받기&amp;rdquo;는 단지 데이터를 넣고 개인으로부터 데이터를 가져옵니다 각 객체가 소유 한 내부 버퍼. 또한 메소드의 동작을 사용자 정의 할 수있는 몇 가지 흥미로운 후크가 있습니다. 원하는 경우 악을 삽입 할 수 있습니다.&lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt; &lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; 는 상대적으로 지루한 방식으로 이러한 후크를 활용합니다. &lt;code&gt;sendall&lt;/code&gt; 을 호출 할 때 설정됩니다.또는 전송 스트림을 닫으면 &lt;a href=&quot;#trio.testing.memory_stream_pump&quot;&gt; &lt;code&gt;memory_stream_pump()&lt;/code&gt; &lt;/a&gt; 호출이 자동으로 트리거됩니다. memory_stream_pump () 는 &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt; &lt;code&gt;MemorySendStream&lt;/code&gt; &lt;/a&gt; 버퍼에서 데이터를 가져 와서 &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt; &lt;code&gt;MemoryReceiveStream&lt;/code&gt; &lt;/a&gt; 버퍼에 넣는 편리한 함수입니다 . 그러나 이것은 기본값 일뿐입니다. 원하는 임의의 동작으로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d5e9dba828116b86ced1fe89ee88168dd4d81c5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt;&lt;code&gt;memory_stream_pair()&lt;/code&gt;&lt;/a&gt; gives you a pair of connected, bidirectional streams. It&amp;rsquo;s like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socketpair&quot;&gt;&lt;code&gt;socket.socketpair()&lt;/code&gt;&lt;/a&gt;, but without any involvement from that pesky operating system and its networking stack.</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt; &lt;code&gt;memory_stream_pair()&lt;/code&gt; &lt;/a&gt; 는 한 쌍의 연결된 양방향 스트림을 제공합니다. 그것은처럼&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socketpair&quot;&gt; &lt;code&gt;socket.socketpair()&lt;/code&gt; &lt;/a&gt; 있지만 그 성가신 운영 체제에서 참여와 네트워킹 스택없이.</target>
        </trans-unit>
        <trans-unit id="608590cb52eebdf3161902f8706901acac61ca21" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/enum.html#enum.Enum&quot;&gt;&lt;code&gt;enum.Enum&lt;/code&gt;&lt;/a&gt; used as the return value from abort functions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/enum.html#enum.Enum&quot;&gt; &lt;code&gt;enum.Enum&lt;/code&gt; &lt;/a&gt;중단 함수의 리턴 값으로 사용되는 열거 .</target>
        </trans-unit>
        <trans-unit id="6402fdb9fc1a5631193223a95083a060da7e2668" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if a checkpoint was executed.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 검사 점이 실행 된 경우</target>
        </trans-unit>
        <trans-unit id="f90e2933d92ae8a2459cc2bcf2cd6da6697d864d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if a test fails.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 테스트에 실패한 경우</target>
        </trans-unit>
        <trans-unit id="82d82d3e6eb3abe1e3946fd8f65ce6b023bd7885" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if no checkpoint was executed.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 검사 점이 실행되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="220ac26f9cd9eb78e827fe89be8de614e42a8708" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if no &lt;code&gt;trio_token&lt;/code&gt; was provided, and we can&amp;rsquo;t infer one from context.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; &lt;code&gt;trio_token&lt;/code&gt; 이 제공되지 않아 컨텍스트에서 추론 할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="c4b7b16bc7e58f53144d0aba28de13f544017169" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#Exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt; &amp;ndash; Whatever &lt;code&gt;sync_fn(*args)&lt;/code&gt; raises.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#Exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; &amp;ndash; &lt;code&gt;sync_fn(*args)&lt;/code&gt; 가무엇이든 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="c66cac55224b866c757ccbd926086af93e8dbe90" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the instrument is not currently active. This could occur either because you never added it, or because you added it and then it raised an unhandled exception and was automatically deactivated.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 계측기가 현재 활성화되어 있지 않은 경우 추가하지 않았거나 추가 한 후 처리되지 않은 예외가 발생하여 자동으로 비활성화 되었기 때문에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0789287a862ca78af3db9ec09864f9caee6d9ff8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; protection is &lt;em&gt;enabled&lt;/em&gt; by default; if you want &lt;code&gt;sync_fn&lt;/code&gt; to be interruptible by control-C, then you need to use &lt;a href=&quot;#trio.hazmat.disable_ki_protection&quot;&gt;&lt;code&gt;disable_ki_protection()&lt;/code&gt;&lt;/a&gt; explicitly.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 보호는기본적으로&lt;em&gt; 활성화&lt;/em&gt; 되어 있습니다. 당신이 원하는 경우 &lt;code&gt;sync_fn&lt;/code&gt; 제어-C에 의해 인터럽트로, 당신은 사용할 필요가&lt;a href=&quot;#trio.hazmat.disable_ki_protection&quot;&gt; &lt;code&gt;disable_ki_protection()&lt;/code&gt; &lt;/a&gt; 명시 적으로.</target>
        </trans-unit>
        <trans-unit id="f033973f3e4581300fe418bf5b3704d8c191f6e1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; protection is &lt;em&gt;enabled&lt;/em&gt; by default; if you want &lt;code&gt;sync_fn&lt;/code&gt; to be interruptible by control-C, then you need to use &lt;a href=&quot;#trio.lowlevel.disable_ki_protection&quot;&gt;&lt;code&gt;disable_ki_protection()&lt;/code&gt;&lt;/a&gt; explicitly.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 보호는기본적으로&lt;em&gt; 활성화&lt;/em&gt; 되어 있습니다. 당신이 원하는 경우 &lt;code&gt;sync_fn&lt;/code&gt; 제어-C에 의해 인터럽트로, 당신은 사용할 필요가&lt;a href=&quot;#trio.lowlevel.disable_ki_protection&quot;&gt; &lt;code&gt;disable_ki_protection()&lt;/code&gt; &lt;/a&gt; 명시 적으로.</target>
        </trans-unit>
        <trans-unit id="d338b5dcc6a2ea187ea6e503786905d62394bb9d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; &amp;ndash; If the handle is invalid, e.g. when it is already closed.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 핸들이 유효하지 않은 경우 (예 : 핸들이 이미 닫힌 경우)</target>
        </trans-unit>
        <trans-unit id="1eb12bd422acc39baf4fc829d812f0628bebdc08" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; &amp;ndash; If the socket file could not be connected to.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 소켓 파일을 연결할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="c9321e21ed7e147c3ad7da16f75cebd93a1ea481" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if an error is encountered starting or communicating with the process</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 프로세스 시작 또는 통신과 관련된 오류가 발생한 경우</target>
        </trans-unit>
        <trans-unit id="fe1846f55ded122f0371eb200f705368a43f5442" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the connection fails.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 연결에 실패한 경우</target>
        </trans-unit>
        <trans-unit id="fd16cd8999185f6d888fdea658dd8fa4b7c2a88a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the process spawning fails, for example because the specified command could not be found.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 지정된 명령을 찾을 수 없어서 프로세스 생성이 실패한 경우</target>
        </trans-unit>
        <trans-unit id="fbf301bdc49ec83493d111216f646a567eac9758" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the underlying call to &lt;code&gt;accept&lt;/code&gt; raises an unexpected error.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; &amp;ndash; &lt;code&gt;accept&lt;/code&gt; 을위한기본 호출로예기치 않은 오류가 발생하는 경우</target>
        </trans-unit>
        <trans-unit id="81892ce0edb345342bb81a23b92e24b5a76b2e45" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; If AF_UNIX sockets are not supported.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; AF_UNIX 소켓이 지원되지 않는 경우</target>
        </trans-unit>
        <trans-unit id="820245345a01caefa04db07ba22a6f2b08955270" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; If this nursery is no longer open (i.e. its &lt;code&gt;async with&lt;/code&gt; block has exited).</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이 보육원이 더 이상 열려 있지 않은 경우 (예 :블록 &lt;code&gt;async with&lt;/code&gt; 의 비동기 가 종료 된 경우)</target>
        </trans-unit>
        <trans-unit id="05d203f34970a37d3b8654fc60575144620cd718" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if &lt;code&gt;borrower&lt;/code&gt; already holds one of this sack&amp;rsquo;s tokens.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; &lt;code&gt;borrower&lt;/code&gt; 이미이 자루의 토큰 중 하나를 보유하고있는경우.</target>
        </trans-unit>
        <trans-unit id="9caa41b116381d44b1035bd6583d9b2734e0bd7f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if &lt;code&gt;borrower&lt;/code&gt; task already holds one of this sack&amp;rsquo;s tokens.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; &lt;code&gt;borrower&lt;/code&gt; 태스크에 이미이 자루의 토큰 중 하나가있는경우.</target>
        </trans-unit>
        <trans-unit id="1523a22843113284427f0c91f6126a1a2875b26a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if not inside a call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash;&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 호출에없는 경우.</target>
        </trans-unit>
        <trans-unit id="9229918d00657fe5d5a04b1e6686e28c8ea7f6a4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the calling task does not hold the lock.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 호출 작업이 잠금을 보유하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="7ee4591b74dc354d3a927e5412ee4a989fbf872b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the current task already holds one of this sack&amp;rsquo;s tokens.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 현재 작업에 이미이 자루의 토큰 중 하나가있는 경우.</target>
        </trans-unit>
        <trans-unit id="a28b63ca276986b36ae501abe3cb5e7f8942f1e1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the current task has not acquired one of this sack&amp;rsquo;s tokens.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 현재 작업이이 자루의 토큰 중 하나를 얻지 못한 경우.</target>
        </trans-unit>
        <trans-unit id="a7febb292cf405a27200ef3bde9ebf3b57367acd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the given borrower has not acquired one of this sack&amp;rsquo;s tokens.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 주어진 차용자가이 자루의 토큰 중 하나를 얻지 못한 경우.</target>
        </trans-unit>
        <trans-unit id="85a07d923bf91b8e2edc651f5b71c48321c79d50" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you try calling this from inside the Trio thread, which would otherwise cause a deadlock.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; Trio 스레드 내부에서이를 호출하려고하면 교착 상태가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c49c0535d85c7b0fde828d34a6e9b90598bccef2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you try to use this anywhere except Python&amp;rsquo;s main thread. (This is a Python limitation.)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 파이썬의 메인 스레드를 제외한 다른 곳에서 이것을 사용하려고하면. 이것은 Python 제한 사항입니다.</target>
        </trans-unit>
        <trans-unit id="98cb9337abe47ab8725ac2921cc3f188ea76b712" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if &lt;code&gt;afn&lt;/code&gt; is not an asynchronous function.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; &lt;code&gt;afn&lt;/code&gt; 이 비동기 함수가 아닌경우입니다.</target>
        </trans-unit>
        <trans-unit id="72880ba7aa000f18403cf74e35c47d1f603ae75d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if &lt;code&gt;fn&lt;/code&gt; is an async function.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; &lt;code&gt;fn&lt;/code&gt; 이 비동기 함수 인 경우.</target>
        </trans-unit>
        <trans-unit id="da83362d474942ed0891ee40b74e3b969d32a746" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if any of the passed in objects are not instances of &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BaseException&quot;&gt;&lt;code&gt;BaseException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; - 객체에서 전달 중의 인스턴스가 아닌 경우&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BaseException&quot;&gt; &lt;code&gt;BaseException&lt;/code&gt; 이&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94bce4be6a97eea6fde3971352404c4dd88adcf9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if no signals were provided.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 신호가 제공되지 않은 경우입니다.</target>
        </trans-unit>
        <trans-unit id="e359768ef7fbd567a74c4408d6fd2e1dc9d6267b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#UnicodeError&quot;&gt;&lt;code&gt;UnicodeError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if &lt;code&gt;stdin&lt;/code&gt; is specified as a Unicode string, rather than bytes</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#UnicodeError&quot;&gt; &lt;code&gt;UnicodeError&lt;/code&gt; &lt;/a&gt; &amp;ndash; &lt;code&gt;stdin&lt;/code&gt; 이 바이트가 아닌 유니 코드 문자열로 지정된경우</target>
        </trans-unit>
        <trans-unit id="a88563ac21fdb3a838f11487d501cc35ef5e4a02" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if &lt;em&gt;seconds&lt;/em&gt; is less than zero.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; &amp;ndash;&lt;em&gt; 초가&lt;/em&gt; 0보다 작은 경우</target>
        </trans-unit>
        <trans-unit id="a61df9e89e060351c934beaaef21748cc2170785" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if &lt;em&gt;seconds&lt;/em&gt; is negative.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; &amp;ndash;&lt;em&gt; 초가&lt;/em&gt; 음수 인경우</target>
        </trans-unit>
        <trans-unit id="1b01b5d6e9534f01004484190f2fdfa1fac4b540" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if incrementing the value would cause it to exceed &lt;a href=&quot;#trio.Semaphore.max_value&quot;&gt;&lt;code&gt;max_value&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를이&lt;/a&gt; - 값이 증가하는 원인이 경우는 초과&lt;a href=&quot;#trio.Semaphore.max_value&quot;&gt; &lt;code&gt;max_value&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1fdec5829d0e7488e736c422c9e29e0a932a83e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if multiple redirections are specified for the same stream, e.g., both &lt;code&gt;capture_stdout=True&lt;/code&gt; and &lt;code&gt;stdout=subprocess.DEVNULL&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 같은 스트림에 대해 여러 리디렉션이 지정된 경우 (예 : &lt;code&gt;capture_stdout=True&lt;/code&gt; 및 &lt;code&gt;stdout=subprocess.DEVNULL&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2d46a94b78faa648664980bba903f899cd3b403f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if timeout is less than zero.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 시간 초과가 0보다 작은 경우</target>
        </trans-unit>
        <trans-unit id="ac60b6da0a8198ebedacab39a16e315085e433dc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you try to pass a negative value for &lt;code&gt;seconds&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; &amp;ndash; &lt;code&gt;seconds&lt;/code&gt; 음수 값을 전달하려고하면.</target>
        </trans-unit>
        <trans-unit id="afe3c25042b0b29f15a85aa8688cec2acdbadf92" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getdefaulttimeout&quot;&gt;&lt;code&gt;getdefaulttimeout()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.setdefaulttimeout&quot;&gt;&lt;code&gt;setdefaulttimeout()&lt;/code&gt;&lt;/a&gt;: instead, use Trio&amp;rsquo;s standard support for &lt;a href=&quot;reference-core#cancellation&quot;&gt;Cancellation and timeouts&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getdefaulttimeout&quot;&gt; &lt;code&gt;getdefaulttimeout()&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.setdefaulttimeout&quot;&gt; &lt;code&gt;setdefaulttimeout()&lt;/code&gt; &lt;/a&gt; : 대신,&lt;a href=&quot;reference-core#cancellation&quot;&gt; 취소 및 시간 초과에&lt;/a&gt; 대한 Trio의 표준 지원을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="348e9e4e99c81e1efbcca8c3f74caec5f6b5fad8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getfqdn&quot;&gt;&lt;code&gt;getfqdn()&lt;/code&gt;&lt;/a&gt;: obsolete; use &lt;a href=&quot;#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt;&lt;/a&gt; with the &lt;code&gt;AI_CANONNAME&lt;/code&gt; flag.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getfqdn&quot;&gt; &lt;code&gt;getfqdn()&lt;/code&gt; &lt;/a&gt; : 쓸모없는; 사용&lt;a href=&quot;#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo()&lt;/code&gt; &lt;/a&gt; 와 &lt;code&gt;AI_CANONNAME&lt;/code&gt; 의 플래그.</target>
        </trans-unit>
        <trans-unit id="db0936a9e91afbf5ae1135fd9360542a5d0606c9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.gethostbyname&quot;&gt;&lt;code&gt;gethostbyname()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.gethostbyname_ex&quot;&gt;&lt;code&gt;gethostbyname_ex()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.gethostbyaddr&quot;&gt;&lt;code&gt;gethostbyaddr()&lt;/code&gt;&lt;/a&gt;: obsolete; use &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getnameinfo&quot;&gt;&lt;code&gt;getnameinfo()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.gethostbyname&quot;&gt; &lt;code&gt;gethostbyname()&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.gethostbyname_ex&quot;&gt; &lt;code&gt;gethostbyname_ex()&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.gethostbyaddr&quot;&gt; &lt;code&gt;gethostbyaddr()&lt;/code&gt; &lt;/a&gt; : 폐기 됨; 사용&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo()&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getnameinfo&quot;&gt; &lt;code&gt;getnameinfo()&lt;/code&gt; &lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="17d69c94218d1ebabadf6e649a8c2e3df496a1d5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getservbyname&quot;&gt;&lt;code&gt;getservbyname()&lt;/code&gt;&lt;/a&gt;: obsolete and &lt;a href=&quot;https://bugs.python.org/issue30482&quot;&gt;buggy&lt;/a&gt;; instead, do:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getservbyname&quot;&gt; &lt;code&gt;getservbyname()&lt;/code&gt; &lt;/a&gt; : 더 이상 사용되지 않는&lt;a href=&quot;https://bugs.python.org/issue30482&quot;&gt; 버그&lt;/a&gt; ; 대신 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5eacd97b4458f5aa1b57894879655db6e99850c1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getservbyport&quot;&gt;&lt;code&gt;getservbyport()&lt;/code&gt;&lt;/a&gt;: obsolete and &lt;a href=&quot;https://bugs.python.org/issue30482&quot;&gt;buggy&lt;/a&gt;; instead, do:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getservbyport&quot;&gt; &lt;code&gt;getservbyport()&lt;/code&gt; &lt;/a&gt; : 쓸모없고&lt;a href=&quot;https://bugs.python.org/issue30482&quot;&gt; 버그가있는&lt;/a&gt; ; 대신 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b5eb0f9ecdc2cf9e2ee4edbc8624978be2e45ca0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.makefile&quot;&gt;&lt;code&gt;makefile()&lt;/code&gt;&lt;/a&gt;: Python&amp;rsquo;s file-like API is synchronous, so it can&amp;rsquo;t be implemented on top of an async socket.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.makefile&quot;&gt; &lt;code&gt;makefile()&lt;/code&gt; &lt;/a&gt; : Python의 파일 유사 API는 동기식이므로 비동기 소켓 위에는 구현할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a9fd2568d3df3a54030ed0a7a247ae1b1458a624" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.recvmsg&quot;&gt;&lt;code&gt;recvmsg()&lt;/code&gt;&lt;/a&gt; (if available)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.recvmsg&quot;&gt; &lt;code&gt;recvmsg()&lt;/code&gt; &lt;/a&gt; (사용 가능한 경우)</target>
        </trans-unit>
        <trans-unit id="64a9f06a1eda38f9e0eed41e97838ad4116deb4a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.recvmsg_into&quot;&gt;&lt;code&gt;recvmsg_into()&lt;/code&gt;&lt;/a&gt; (if available)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.recvmsg_into&quot;&gt; &lt;code&gt;recvmsg_into()&lt;/code&gt; &lt;/a&gt; (사용 가능한 경우)</target>
        </trans-unit>
        <trans-unit id="b1886c3f9044cff76ab5db335decfb991adc0b02" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.sendall&quot;&gt;&lt;code&gt;sendall()&lt;/code&gt;&lt;/a&gt;: Could be supported, but you&amp;rsquo;re better off using the higher-level &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt;, and specifically its &lt;a href=&quot;#trio.SocketStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; method, which also does additional error checking.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.sendall&quot;&gt; &lt;code&gt;sendall()&lt;/code&gt; &lt;/a&gt; : 지원 될 수 있지만, 더 높은 수준의&lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; &lt;/a&gt; 과 특히&lt;a href=&quot;#trio.SocketStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b80ffb80eda2ef62aa200fd82d0be12179b5658b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.sendmsg&quot;&gt;&lt;code&gt;sendmsg()&lt;/code&gt;&lt;/a&gt; (if available)</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.sendmsg&quot;&gt; &lt;code&gt;sendmsg()&lt;/code&gt; &lt;/a&gt; (사용 가능한 경우)</target>
        </trans-unit>
        <trans-unit id="bf8f587cd6689ebc86645620fca231f8542839a6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.setblocking&quot;&gt;&lt;code&gt;setblocking()&lt;/code&gt;&lt;/a&gt;: Trio sockets always act like blocking sockets; if you need to read/write from multiple sockets at once, then create multiple tasks.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.setblocking&quot;&gt; &lt;code&gt;setblocking()&lt;/code&gt; &lt;/a&gt; : Trio 소켓은 항상 블로킹 소켓처럼 작동합니다. 여러 소켓에서 한 번에 읽기 / 쓰기가 필요한 경우 여러 작업을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ad8b8dcdfd05706ebbce9d91167f8e26de5f6cc6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.settimeout&quot;&gt;&lt;code&gt;settimeout()&lt;/code&gt;&lt;/a&gt;: see &lt;a href=&quot;reference-core#cancellation&quot;&gt;Cancellation and timeouts&lt;/a&gt; instead.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.settimeout&quot;&gt; &lt;code&gt;settimeout()&lt;/code&gt; &lt;/a&gt; :대신&lt;a href=&quot;reference-core#cancellation&quot;&gt; 취소 및 시간 초과&lt;/a&gt; 를참조하십시오.</target>
        </trans-unit>
        <trans-unit id="63172ffa4cb84d85aa2280ba0d689e49680e3cf7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;bytes&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytearray&quot;&gt;bytearray&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;바이트&lt;/a&gt; 또는 바이트 &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytearray&quot;&gt;배열&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d9a159b020f5a5f92930f5910448af6b6024ec6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;str&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#list&quot;&gt;list&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;str&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#list&quot;&gt;list&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="169c0c7f34d41eeaedba1af87df42a6c0801aba5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError&quot;&gt;&lt;code&gt;subprocess.CalledProcessError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if &lt;code&gt;check=False&lt;/code&gt; is not passed and the process exits with a nonzero exit status</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError&quot;&gt; &lt;code&gt;subprocess.CalledProcessError&lt;/code&gt; &lt;/a&gt; &amp;ndash; &lt;code&gt;check=False&lt;/code&gt; 가 전달되지 않고 프로세스가 0이 아닌 종료 상태로 종료되는 경우</target>
        </trans-unit>
        <trans-unit id="45c49afc36a9666b9a231b13adcca1634eef0223" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate&quot;&gt;&lt;code&gt;communicate()&lt;/code&gt;&lt;/a&gt; is not provided as a method on &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; objects; use &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process()&lt;/code&gt;&lt;/a&gt; instead, or write the loop yourself if you have unusual needs. &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate&quot;&gt;&lt;code&gt;communicate()&lt;/code&gt;&lt;/a&gt; has quite unusual cancellation behavior in the standard library (on some platforms it spawns a background thread which continues to read from the child process even after the timeout has expired) and we wanted to provide an interface with fewer surprises.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate&quot;&gt; &lt;code&gt;communicate()&lt;/code&gt; &lt;/a&gt; 은&lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 객체에서 메소드로 제공되지 않습니다. 사용&lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process()&lt;/code&gt; &lt;/a&gt; 대신하거나, 특별한 요구 사항이있는 경우 루프를 직접 작성합니다. &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate&quot;&gt; &lt;code&gt;communicate()&lt;/code&gt; &lt;/a&gt; 은 표준 라이브러리에서 매우 비정상적인 취소 동작을 갖습니다 (일부 플랫폼에서는 시간 초과가 만료 된 후에도 하위 프로세스에서 계속 읽는 백그라운드 스레드를 생성 함).</target>
        </trans-unit>
        <trans-unit id="2f50b4f2871137e469bff365fb01f51208de17a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt;&lt;code&gt;trio.BrokenResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if something has gone wrong, and the channel is broken.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt; &lt;code&gt;trio.BrokenResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 문제가 발생하여 채널이 손상된 경우</target>
        </trans-unit>
        <trans-unit id="f0979f0e1697acb335032a114b3342bce2855877" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt;&lt;code&gt;trio.BrokenResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if something has gone wrong, and the channel is broken. For example, you may get this if the receiver has already been closed.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt; &lt;code&gt;trio.BrokenResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 문제가 발생하여 채널이 손상된 경우 예를 들어, 수신기가 이미 닫힌 경우이 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e6bb7cd4db6ec2b88972d932c91f5595667a94f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt;&lt;code&gt;trio.BrokenResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if something has gone wrong, and the stream is broken.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt; &lt;code&gt;trio.BrokenResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 문제가 발생하여 스트림이 손상된 경우</target>
        </trans-unit>
        <trans-unit id="b93fe7550e185e7bdcf056cf2aab816e875bc344" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if another task is already executing a &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt;&lt;code&gt;HalfCloseableStream.send_eof()&lt;/code&gt;&lt;/a&gt; on this stream.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 다른 태스크가 이미이&lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; 에서 send_all () ,&lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt; 또는&lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt; &lt;code&gt;HalfCloseableStream.send_eof()&lt;/code&gt; &lt;/a&gt; 를실행중인 경우</target>
        </trans-unit>
        <trans-unit id="c4baab643c3e32e1ea96c8a8b00719b50047605f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if another task is already executing a &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt;&lt;code&gt;send_eof()&lt;/code&gt;&lt;/a&gt; on this stream.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 다른 작업이 이미&lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt; 또는&lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt; &lt;code&gt;send_eof()&lt;/code&gt; &lt;/a&gt; 를이 스트림에서실행중인 경우</target>
        </trans-unit>
        <trans-unit id="a2451843bb01fc131a8d404e2893ebcd1964f7fa" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if another task is already waiting for the given socket to become readable.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 다른 작업이 이미 주어진 소켓을 읽을 수 있도록 대기중인 경우</target>
        </trans-unit>
        <trans-unit id="ca0b61e8669b4d0cbf2a0227e7a1ecd7f2f0eea9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if another task is already waiting for the given socket to become writable.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 다른 작업이 이미 주어진 소켓이 쓰기 가능해지기를 기다리는 경우.</target>
        </trans-unit>
        <trans-unit id="a7e3b99113902fc66735a64cb19e67c7bfc85de4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if two tasks attempt to call &lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/a&gt; on the same listener at the same time.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 두 작업이 같은 리스너에서&lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt; &lt;code&gt;accept()&lt;/code&gt; &lt;/a&gt; 를 동시에호출하려고하는 경우.</target>
        </trans-unit>
        <trans-unit id="7a02bb442196558eb15b2a8fa432cccf8bd2cab8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if two tasks attempt to call &lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt;&lt;code&gt;receive_some()&lt;/code&gt;&lt;/a&gt; on the same stream at the same time.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 두 작업이 같은 스트림에서&lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt; &lt;code&gt;receive_some()&lt;/code&gt; &lt;/a&gt; 를 동시에호출하려고하는 경우.</target>
        </trans-unit>
        <trans-unit id="77d6c6089e93746cb93c8d866005f76290c5d564" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; some channels allow multiple tasks to call &lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt; at the same time, but others don&amp;rsquo;t. If you try to call &lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt; simultaneously from multiple tasks on a channel that doesn&amp;rsquo;t support it, then you can get &lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;BusyResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 일부 채널에서는 여러 작업이 동시에&lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt; 을 호출 할 수 있지만 다른 채널은 그렇지 않습니다. 이를 지원하지 않는 채널의 여러 작업에서 동시에&lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt; 을 호출하려고하면&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;BusyResourceError&lt;/code&gt; &lt;/a&gt; 를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1c202ed75f39c32ad05b7c4535716ce47ebdf27" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;trio.BusyResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; some channels allow multiple tasks to call &lt;a href=&quot;#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; at the same time, but others don&amp;rsquo;t. If you try to call &lt;a href=&quot;#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; simultaneously from multiple tasks on a channel that doesn&amp;rsquo;t support it, then you can get &lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt;&lt;code&gt;BusyResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;trio.BusyResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 일부 채널에서는 여러 작업이 동시에&lt;a href=&quot;#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 을 호출 할 수있지만 다른채널에서는그렇지 않습니다. 지원하지 않는 채널에서 여러 작업에서 동시에&lt;a href=&quot;#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 을 호출하려고하면&lt;a href=&quot;reference-core#trio.BusyResourceError&quot;&gt; &lt;code&gt;BusyResourceError&lt;/code&gt; &lt;/a&gt; 가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e49b6f53c167deed4c6f74f872864d447920b7d3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you already closed the socket.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 이미 소켓을 닫은 경우</target>
        </trans-unit>
        <trans-unit id="33039c1212f13a8f732f7e2da9d59ab6907c8278" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if another task calls &lt;a href=&quot;#trio.hazmat.notify_closing&quot;&gt;&lt;code&gt;notify_closing()&lt;/code&gt;&lt;/a&gt; while this function is still working.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이 함수가 여전히 작동하는 동안다른 태스크가&lt;a href=&quot;#trio.hazmat.notify_closing&quot;&gt; &lt;code&gt;notify_closing()&lt;/code&gt; &lt;/a&gt; 을호출하는 경우.</target>
        </trans-unit>
        <trans-unit id="abebee0dcbedca06c20039a3b5d8fcc07a47de72" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if another task calls &lt;a href=&quot;#trio.lowlevel.notify_closing&quot;&gt;&lt;code&gt;notify_closing()&lt;/code&gt;&lt;/a&gt; while this function is still working.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이 함수가 계속 작동하는 동안다른 태스크가&lt;a href=&quot;#trio.lowlevel.notify_closing&quot;&gt; &lt;code&gt;notify_closing()&lt;/code&gt; &lt;/a&gt; 을호출하는 경우.</target>
        </trans-unit>
        <trans-unit id="739f1b24bdaf701e82803b6e061c7bba5c4ad049" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you previously closed this &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;ReceiveChannel&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이&lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;ReceiveChannel&lt;/code&gt; &lt;/a&gt; 객체를 이전에 닫은 경우</target>
        </trans-unit>
        <trans-unit id="663a046b61214a99317618df73de81f588f099ec" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you previously closed this &lt;a href=&quot;#trio.abc.SendChannel&quot;&gt;&lt;code&gt;SendChannel&lt;/code&gt;&lt;/a&gt; object, or if another task closes it while &lt;a href=&quot;#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; is running.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이&lt;a href=&quot;#trio.abc.SendChannel&quot;&gt; &lt;code&gt;SendChannel&lt;/code&gt; &lt;/a&gt; 객체를 이전에 닫았거나&lt;a href=&quot;#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt; 가 실행되는동안 다른 작업에서 닫은 경우.</target>
        </trans-unit>
        <trans-unit id="bbd2472c216fa77160785a706f4a34fb23febe0f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you previously closed this listener object, or if another task closes this listener object while &lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/a&gt; is running.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash; 이전에이 리스너 객체를 닫았거나&lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt; &lt;code&gt;accept()&lt;/code&gt; &lt;/a&gt; 가 실행되는동안 다른 작업이이 리스너 객체를 닫는 경우</target>
        </trans-unit>
        <trans-unit id="afd68c5665d9d4aea771006164e62b59cd9b5100" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you previously closed this stream object, or if another task closes this stream object while &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt;&lt;code&gt;send_eof()&lt;/code&gt;&lt;/a&gt; is running.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이 스트림 오브젝트를 이전에 닫았거나&lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt; &lt;code&gt;send_eof()&lt;/code&gt; &lt;/a&gt; 가 실행중인동안 다른 태스크가이 스트림 오브젝트를 닫는 경우.</target>
        </trans-unit>
        <trans-unit id="b28dacbe058ec2a8d8214f4169b49933e418573a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you previously closed this stream object, or if another task closes this stream object while &lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt;&lt;code&gt;receive_some()&lt;/code&gt;&lt;/a&gt; is running.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이 스트림 객체를 이전에 닫았거나&lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt; &lt;code&gt;receive_some()&lt;/code&gt; &lt;/a&gt; 이 실행되는동안 다른 작업에서이 스트림 객체를 닫는 경우.</target>
        </trans-unit>
        <trans-unit id="4f700d42049380feaaff1f42e46ee8e755181a04" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you previously closed this stream object, or if another task closes this stream object while &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; is running.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이 스트림 오브젝트를 이전에 닫았거나&lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; 이 실행되는동안 다른 태스크가이 스트림 오브젝트를 닫는 경우.</target>
        </trans-unit>
        <trans-unit id="b8815102cec16d6dd7a950d42fde656e3466c9f4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;trio.ClosedResourceError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if you previously closed this stream object, or if another task closes this stream object while &lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt; is running.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;trio.ClosedResourceError&lt;/code&gt; &lt;/a&gt; &amp;ndash;이 스트림 객체를 이전에 닫았거나&lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt; 이 실행되는동안 다른 작업이이 스트림 객체를 닫은 경우.</target>
        </trans-unit>
        <trans-unit id="49dec4aedbef1954e897290d01837d539edf6748" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.EndOfChannel&quot;&gt;&lt;code&gt;trio.EndOfChannel&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the sender has been closed cleanly, and no more objects are coming. This is not an error condition.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.EndOfChannel&quot;&gt; &lt;code&gt;trio.EndOfChannel&lt;/code&gt; &lt;/a&gt; &amp;ndash; 발신자가 깨끗하게 닫히고 더 이상 개체가없는 경우 이것은 오류 조건이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ebe40cdb42b8ee71ac10e277e89b41a334433b37" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.RunFinishedError&quot;&gt;&lt;code&gt;trio.RunFinishedError&lt;/code&gt;&lt;/a&gt; &amp;ndash; if the associated call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; has already exited. (Any call that &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; raise this error is guaranteed to be fully processed before &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; exits.)</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.RunFinishedError&quot;&gt; &lt;code&gt;trio.RunFinishedError&lt;/code&gt; &lt;/a&gt; &amp;ndash;&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 대한 관련 호출이 이미 종료 된 경우 (이 오류를 발생&lt;em&gt; 시키지 않는&lt;/em&gt; 모든 호출은&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 종료되기 전에 완전히 처리되도록 보장됩니다.)</target>
        </trans-unit>
        <trans-unit id="53b89351a19b01031449bc62fdf5c0206532a0a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;reference-core#trio.WouldBlock&quot;&gt;&lt;code&gt;trio.WouldBlock&lt;/code&gt;&lt;/a&gt; &amp;ndash; if no data is available to retrieve.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.WouldBlock&quot;&gt; &lt;code&gt;trio.WouldBlock&lt;/code&gt; &lt;/a&gt; &amp;ndash; 검색 할 데이터가없는 경우.</target>
        </trans-unit>
        <trans-unit id="ad34061454ddafc79274fd334d162936866c646a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**options&lt;/code&gt; &amp;ndash; &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process()&lt;/code&gt;&lt;/a&gt; also accepts any &lt;a href=&quot;#subprocess-options&quot;&gt;general subprocess options&lt;/a&gt; and passes them on to the &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; constructor. This includes the &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; options, which provide additional redirection possibilities such as &lt;code&gt;stderr=subprocess.STDOUT&lt;/code&gt;, &lt;code&gt;stdout=subprocess.DEVNULL&lt;/code&gt;, or file descriptors.</source>
          <target state="translated">&lt;code&gt;**options&lt;/code&gt; &amp;ndash; &lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#subprocess-options&quot;&gt;일반 하위 프로세스 옵션&lt;/a&gt; 도 허용 하고이를 &lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 생성자 에 전달합니다 . 여기에는 &lt;code&gt;stdout&lt;/code&gt; 및 &lt;code&gt;stderr&lt;/code&gt; 옵션 이 포함되어 있으며 &lt;code&gt;stderr=subprocess.STDOUT&lt;/code&gt; , &lt;code&gt;stdout=subprocess.DEVNULL&lt;/code&gt; 또는 파일 디스크립터 와 같은 추가 경로 재 지정 가능성을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="3764750810169a9d10ba875c5f1a6c7742a2021f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**options&lt;/code&gt; &amp;ndash; Other &lt;a href=&quot;#subprocess-options&quot;&gt;general subprocess options&lt;/a&gt; are also accepted.</source>
          <target state="translated">&lt;code&gt;**options&lt;/code&gt; &amp;ndash; 다른 &lt;a href=&quot;#subprocess-options&quot;&gt;일반 하위 프로세스 옵션&lt;/a&gt; 도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="41febbb3b0834802a6746a8f5643cd9a2661975f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*args&lt;/code&gt; &amp;ndash; Positional arguments to pass to sync_fn. If you need keyword arguments, use &lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.partial&quot;&gt;&lt;code&gt;functools.partial()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;*args&lt;/code&gt; &amp;ndash; sync_fn에 전달할 위치 인수. 키워드 인수가 필요한 경우 &lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.partial&quot;&gt; &lt;code&gt;functools.partial()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6494d56ff44c758f33670f78cf4b315c1ac6a7ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Anything else&lt;/code&gt; &amp;ndash; if &lt;code&gt;async_fn&lt;/code&gt; raises an exception, then &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; propagates it.</source>
          <target state="translated">&lt;code&gt;Anything else&lt;/code&gt; &amp;ndash; &lt;code&gt;async_fn&lt;/code&gt; 에서 예외가 발생하면 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 이이를 전파합니다.</target>
        </trans-unit>
        <trans-unit id="083b984922795569d238527957c899850bfdf049" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EMFILE&lt;/code&gt;: process is out of file descriptors</source>
          <target state="translated">&lt;code&gt;EMFILE&lt;/code&gt; : 프로세스에 파일 설명자가 없습니다</target>
        </trans-unit>
        <trans-unit id="e6185dc2a89485bb87a58b6a4de5be31b3888068" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ENFILE&lt;/code&gt;: system is out of file descriptors</source>
          <target state="translated">&lt;code&gt;ENFILE&lt;/code&gt; : 시스템에 파일 설명자가 없습니다</target>
        </trans-unit>
        <trans-unit id="aa0e28c33bc1490f1c0a230755aa6bd6eeabb6cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ENOBUFS&lt;/code&gt;, &lt;code&gt;ENOMEM&lt;/code&gt;: the kernel hit some sort of memory limitation when trying to create a socket object</source>
          <target state="translated">&lt;code&gt;ENOBUFS&lt;/code&gt; , &lt;code&gt;ENOMEM&lt;/code&gt; : 소켓 객체를 만들려고 할 때 커널이 일종의 메모리 제한에 도달했습니다.</target>
        </trans-unit>
        <trans-unit id="d1ebb1933006763cb904d2510939655ae79810f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__aenter__&lt;/code&gt;, &lt;code&gt;__aexit__&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__aenter__&lt;/code&gt; , &lt;code&gt;__aexit__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53d9542cd2795bd32a4641b28995e15220369c03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__aiter__&lt;/code&gt;, &lt;code&gt;__anext__&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__aiter__&lt;/code&gt; , &lt;code&gt;__anext__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f721b10bca9ebf38d8f9a3b21ed2543d633607e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;abort_func&lt;/code&gt; &amp;ndash; Same as for &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;, except that it must return &lt;a href=&quot;#trio.hazmat.Abort.FAILED&quot;&gt;&lt;code&gt;Abort.FAILED&lt;/code&gt;&lt;/a&gt;. (If it returned &lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt;&lt;code&gt;Abort.SUCCEEDED&lt;/code&gt;&lt;/a&gt;, then Trio would attempt to reschedule the detached task directly without going through &lt;a href=&quot;#trio.hazmat.reattach_detached_coroutine_object&quot;&gt;&lt;code&gt;reattach_detached_coroutine_object()&lt;/code&gt;&lt;/a&gt;, which would be bad.) Your &lt;code&gt;abort_func&lt;/code&gt; should still arrange for whatever the coroutine object is doing to be cancelled, and then reattach to Trio and call the &lt;code&gt;raise_cancel&lt;/code&gt; callback, if possible.</source>
          <target state="translated">&lt;code&gt;abort_func&lt;/code&gt; -에 관해서는 동일 &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; , 그것은 반환해야한다는 점을 제외하고 &lt;a href=&quot;#trio.hazmat.Abort.FAILED&quot;&gt; &lt;code&gt;Abort.FAILED&lt;/code&gt; 을&lt;/a&gt; . (이 반환 된 경우 &lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt; &lt;code&gt;Abort.SUCCEEDED&lt;/code&gt; &lt;/a&gt; , 다음 트리오 직접 통하지 않고 분리 작업을 다시 예약하려고 시도합니다 &lt;a href=&quot;#trio.hazmat.reattach_detached_coroutine_object&quot;&gt; &lt;code&gt;reattach_detached_coroutine_object()&lt;/code&gt; &lt;/a&gt; 나쁜 것이다.) 당신의 &lt;code&gt;abort_func&lt;/code&gt; 를 는 여전히 코 루틴 객체가 취소하려는 작업을 정렬 한 다음 다시 연결해야합니다. 가능한 경우 &lt;code&gt;raise_cancel&lt;/code&gt; 콜백 을 Trio하고 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="037d13bb3af5e8d9bbf3a2b47a5cbb28b2f3d999" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;abort_func&lt;/code&gt; &amp;ndash; Same as for &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;, except that it must return &lt;a href=&quot;#trio.lowlevel.Abort.FAILED&quot;&gt;&lt;code&gt;Abort.FAILED&lt;/code&gt;&lt;/a&gt;. (If it returned &lt;a href=&quot;#trio.lowlevel.Abort.SUCCEEDED&quot;&gt;&lt;code&gt;Abort.SUCCEEDED&lt;/code&gt;&lt;/a&gt;, then Trio would attempt to reschedule the detached task directly without going through &lt;a href=&quot;#trio.lowlevel.reattach_detached_coroutine_object&quot;&gt;&lt;code&gt;reattach_detached_coroutine_object()&lt;/code&gt;&lt;/a&gt;, which would be bad.) Your &lt;code&gt;abort_func&lt;/code&gt; should still arrange for whatever the coroutine object is doing to be cancelled, and then reattach to Trio and call the &lt;code&gt;raise_cancel&lt;/code&gt; callback, if possible.</source>
          <target state="translated">&lt;code&gt;abort_func&lt;/code&gt; -에 관해서는 동일 &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; , 그것은 반환해야한다는 점을 제외하고 &lt;a href=&quot;#trio.lowlevel.Abort.FAILED&quot;&gt; &lt;code&gt;Abort.FAILED&lt;/code&gt; 을&lt;/a&gt; . ( &lt;a href=&quot;#trio.lowlevel.Abort.SUCCEEDED&quot;&gt; &lt;code&gt;Abort.SUCCEEDED&lt;/code&gt; 를&lt;/a&gt; 반환하면 Trio는 &lt;a href=&quot;#trio.lowlevel.reattach_detached_coroutine_object&quot;&gt; &lt;code&gt;reattach_detached_coroutine_object()&lt;/code&gt; &lt;/a&gt; 를 거치지 않고 분리 된 작업을 직접 다시 예약하려고 시도합니다 . 이는 나쁠 것입니다.) &lt;code&gt;abort_func&lt;/code&gt; 는 여전히 코 루틴 객체가 취소하기 위해 수행하는 작업을 정렬 한 다음 다시 연결해야합니다. 가능한 경우 Trio에 전화를 걸어 &lt;code&gt;raise_cancel&lt;/code&gt; 콜백을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="cc87db35f7da4123b104b2897e7467f605432bdc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt; &amp;ndash; Positional arguments for &lt;code&gt;async_fn&lt;/code&gt;. If you want to pass keyword arguments, use &lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.partial&quot;&gt;&lt;code&gt;functools.partial()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; &amp;ndash; &lt;code&gt;async_fn&lt;/code&gt; 의 위치 인수 . 키워드 인수를 전달하려면 &lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.partial&quot;&gt; &lt;code&gt;functools.partial()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f222164120ff2300840b55152e8406e1404dbe95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt; &amp;ndash; Positional arguments to be passed to &lt;em&gt;async_fn&lt;/em&gt;. If you need to pass keyword arguments, then use &lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.partial&quot;&gt;&lt;code&gt;functools.partial()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; &amp;ndash; &lt;em&gt;async_fn에&lt;/em&gt; 전달할 위치 인수 . 키워드 인수를 전달해야하는 경우 &lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.partial&quot;&gt; &lt;code&gt;functools.partial()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23a7b12dd1ab3f6f8a5d8f9fc0a01d9470689cab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async_fn&lt;/code&gt; &amp;ndash; An async callable.</source>
          <target state="translated">&lt;code&gt;async_fn&lt;/code&gt; &amp;ndash; 비동기 호출 가능.</target>
        </trans-unit>
        <trans-unit id="6c052d400da7804ef69953fd35006966364a4f70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async_fn&lt;/code&gt; &amp;ndash; An async function.</source>
          <target state="translated">&lt;code&gt;async_fn&lt;/code&gt; &amp;ndash; 비동기 함수</target>
        </trans-unit>
        <trans-unit id="d16ff931501131ab166e17998e960d09e520902f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autojump_threshold&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the initial &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt;&lt;code&gt;autojump_threshold&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;autojump_threshold&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 초기 &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt; &lt;code&gt;autojump_threshold&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5cad07808ed4a54386ed965aafec76c4909fc661" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;backlog&lt;/code&gt; &amp;ndash; The listen backlog, or None to have a good default picked. Passed to &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;backlog&lt;/code&gt; &amp;ndash; 수신 백 로그 또는 기본값을 적절하게 선택하려면 없음. &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt; 전달 .</target>
        </trans-unit>
        <trans-unit id="eca11bd3398470cc2c5ce63c03786d3b1c4e8b0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;backlog&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; See &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;backlog&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 참조 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="56e98560e55c97f9e9ad3252cd1bd27eec5a7baa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;backlog&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; See &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;backlog&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 자세한 내용은 &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="64c93d1c8e192537d2c9150114742d87244de77a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;backlog&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The listen backlog to use. If you leave this as &lt;code&gt;None&lt;/code&gt; then Trio will pick a good default. (Currently: whatever your system has configured as the maximum backlog.)</source>
          <target state="translated">&lt;code&gt;backlog&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 사용할 청취 백 로그입니다. 이것을 그대로두면 &lt;code&gt;None&lt;/code&gt; 으로 Trio가 좋은 기본값을 선택합니다. (현재 : 시스템이 최대 백 로그로 구성한 모든 내용)</target>
        </trans-unit>
        <trans-unit id="ea4466c20b949ea4de4e437c5d6e61f834979d8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;borrowed_tokens&lt;/code&gt;: The number of tokens currently borrowed from the sack.</source>
          <target state="translated">&lt;code&gt;borrowed_tokens&lt;/code&gt; : 현재 자루에서 빌린 토큰 수.</target>
        </trans-unit>
        <trans-unit id="f6feab6d08fc0dda319bdf0f73f68dcba1e57757" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;borrower&lt;/code&gt; &amp;ndash; A &lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt;&lt;code&gt;trio.hazmat.Task&lt;/code&gt;&lt;/a&gt; or arbitrary opaque object used to record who is borrowing this token. This is used by &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt; to allow threads to &amp;ldquo;hold tokens&amp;rdquo;, with the intention in the future of using it to &lt;a href=&quot;https://github.com/python-trio/trio/issues/182&quot;&gt;allow deadlock detection and other useful things&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;borrower&lt;/code&gt; &amp;ndash; 이 토큰을 차용 한 사람을 기록하는 데 사용되는 &lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt; &lt;code&gt;trio.hazmat.Task&lt;/code&gt; &lt;/a&gt; 또는 임의의 불투명 한 객체입니다. 이것은에 의해 사용되는 &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt; 하는 데 사용하는 미래의 의도로, &quot;보류 토큰&quot;에 실을 수 있도록 &lt;a href=&quot;https://github.com/python-trio/trio/issues/182&quot;&gt;교착 상태 감지 및 기타 유용한 일을 할 수&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63ae0d201a862df2c367dba8dbfef938bd550ac5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;borrower&lt;/code&gt; &amp;ndash; A &lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt;&lt;code&gt;trio.hazmat.Task&lt;/code&gt;&lt;/a&gt; or arbitrary opaque object used to record who is borrowing this token; see &lt;a href=&quot;#trio.CapacityLimiter.acquire_on_behalf_of_nowait&quot;&gt;&lt;code&gt;acquire_on_behalf_of_nowait()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;borrower&lt;/code&gt; &amp;ndash; 이 토큰을 차용 한 사람을 기록하는 데 사용되는 &lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt; &lt;code&gt;trio.hazmat.Task&lt;/code&gt; &lt;/a&gt; 또는 임의의 불투명 한 객체. &lt;a href=&quot;#trio.CapacityLimiter.acquire_on_behalf_of_nowait&quot;&gt; &lt;code&gt;acquire_on_behalf_of_nowait()&lt;/code&gt; &lt;/a&gt; 참조 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="974c1c970d52b70ce3ce5b73337d022f59281c6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;borrower&lt;/code&gt; &amp;ndash; A &lt;a href=&quot;reference-lowlevel#trio.lowlevel.Task&quot;&gt;&lt;code&gt;trio.lowlevel.Task&lt;/code&gt;&lt;/a&gt; or arbitrary opaque object used to record who is borrowing this token. This is used by &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt; to allow threads to &amp;ldquo;hold tokens&amp;rdquo;, with the intention in the future of using it to &lt;a href=&quot;https://github.com/python-trio/trio/issues/182&quot;&gt;allow deadlock detection and other useful things&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;borrower&lt;/code&gt; &amp;ndash; 이 토큰을 빌리는 사람을 기록하는 데 사용되는 &lt;a href=&quot;reference-lowlevel#trio.lowlevel.Task&quot;&gt; &lt;code&gt;trio.lowlevel.Task&lt;/code&gt; &lt;/a&gt; 또는 임의의 불투명 한 개체입니다. 이것은 &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt; 에서 쓰레드가 &quot;토큰을 보유&quot;할 수 있도록 하는 데 사용되며 , 향후 &lt;a href=&quot;https://github.com/python-trio/trio/issues/182&quot;&gt;교착 상태 감지 및 기타 유용한 기능&lt;/a&gt; 을 허용 하기 위해 사용할 예정입니다.</target>
        </trans-unit>
        <trans-unit id="82f908ae26e0f343c9f55e0ec18b54c94fccb127" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;borrower&lt;/code&gt; &amp;ndash; A &lt;a href=&quot;reference-lowlevel#trio.lowlevel.Task&quot;&gt;&lt;code&gt;trio.lowlevel.Task&lt;/code&gt;&lt;/a&gt; or arbitrary opaque object used to record who is borrowing this token; see &lt;a href=&quot;#trio.CapacityLimiter.acquire_on_behalf_of_nowait&quot;&gt;&lt;code&gt;acquire_on_behalf_of_nowait()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;borrower&lt;/code&gt; &amp;ndash; 이 토큰을 빌리는 사람을 기록하는 데 사용되는 &lt;a href=&quot;reference-lowlevel#trio.lowlevel.Task&quot;&gt; &lt;code&gt;trio.lowlevel.Task&lt;/code&gt; &lt;/a&gt; 또는 임의의 불투명 한 개체입니다. 자세한 내용은 &lt;a href=&quot;#trio.CapacityLimiter.acquire_on_behalf_of_nowait&quot;&gt; &lt;code&gt;acquire_on_behalf_of_nowait()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1c743acc9bc3e0874e5e27c3b6b53de4664abf68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;borrowers&lt;/code&gt;: A list of all tasks or other entities that currently hold a token.</source>
          <target state="translated">&lt;code&gt;borrowers&lt;/code&gt; : 현재 토큰을 보유하고있는 모든 업무 또는 기타 실체의 목록.</target>
        </trans-unit>
        <trans-unit id="1ca252a9fc4a071afa1f0757fac085d9e3af70bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;broken1&lt;/code&gt; raises &lt;code&gt;KeyError&lt;/code&gt;. &lt;code&gt;broken2&lt;/code&gt; raises &lt;code&gt;IndexError&lt;/code&gt;. Obviously &lt;code&gt;parent&lt;/code&gt; should raise some error, but what? In some sense, the answer should be &amp;ldquo;both of these at once&amp;rdquo;, but in Python there can only be one exception at a time.</source>
          <target state="translated">&lt;code&gt;broken1&lt;/code&gt; 은 &lt;code&gt;KeyError&lt;/code&gt; 를 발생 시킵니다. &lt;code&gt;broken2&lt;/code&gt; 이 제기 &lt;code&gt;IndexError&lt;/code&gt; 를 . 분명히 &lt;code&gt;parent&lt;/code&gt; 는 약간의 오류를 제기해야하지만 무엇입니까? 어떤 의미에서 대답은 &quot;한 번에 둘 다&quot;여야하지만 Python에서는 한 번에 하나의 예외 만있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6eac22d9cac1a7ccb41256738a04eb6479e905d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cancellable&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; Whether to allow cancellation of this operation. See discussion below.</source>
          <target state="translated">&lt;code&gt;cancellable&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;부울&lt;/em&gt;&lt;/a&gt; ) &amp;ndash;이 작업을 취소 할 수 있는지 여부입니다. 아래 토론을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8460d73c85eb9a74fa84dacb8fc1250ae2e1d5e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;capture_stderr&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; If true, capture the bytes that the subprocess writes to its standard error stream and return them in the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; attribute of the returned &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;CompletedProcess&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;code&gt;capture_stderr&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; true이면 서브 프로세스가 표준 오류 스트림에 쓰는 바이트를 캡처 하여 리턴 된 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;CompletedProcess&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; 속성으로 리턴합니다. 오브젝트 합니다.</target>
        </trans-unit>
        <trans-unit id="f9d55fd3be056b54509b1cd066b363be0eb761cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;capture_stdout&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; If true, capture the bytes that the subprocess writes to its standard output stream and return them in the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; attribute of the returned &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;CompletedProcess&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;code&gt;capture_stdout&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; true이면 서브 프로세스가 표준 출력 스트림에 쓰는 바이트를 캡처 하여 리턴 된 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;CompletedProcess&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 속성으로 리턴합니다. 오브젝트 .</target>
        </trans-unit>
        <trans-unit id="26e5c9c34fe9d980bcf61b99ecb8d833e5c6a87f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;check&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; If false, don&amp;rsquo;t validate that the subprocess exits successfully. You should be sure to check the &lt;code&gt;returncode&lt;/code&gt; attribute of the returned object if you pass &lt;code&gt;check=False&lt;/code&gt;, so that errors don&amp;rsquo;t pass silently.</source>
          <target state="translated">&lt;code&gt;check&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; false 인 경우 서브 프로세스가 성공적으로 종료되는지 검증하지 마십시오. &lt;code&gt;check=False&lt;/code&gt; 를 전달하면 반환 된 객체 의 &lt;code&gt;returncode&lt;/code&gt; 속성 을 확인해야합니다. 하면 오류가 자동으로 전달되지 않도록 .</target>
        </trans-unit>
        <trans-unit id="198b0222758f8b2ab4eae3d94ae5d1370fc0fc2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clock&lt;/code&gt; &amp;ndash; &lt;code&gt;None&lt;/code&gt; to use the default system-specific monotonic clock; otherwise, an object implementing the &lt;a href=&quot;#trio.abc.Clock&quot;&gt;&lt;code&gt;trio.abc.Clock&lt;/code&gt;&lt;/a&gt; interface, like (for example) a &lt;a href=&quot;reference-testing#trio.testing.MockClock&quot;&gt;&lt;code&gt;trio.testing.MockClock&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;code&gt;clock&lt;/code&gt; &amp;ndash; 기본 시스템 별 단조로운 시계를 사용 &lt;code&gt;None&lt;/code&gt; . 그렇지 않으면, 예를 들어 &lt;a href=&quot;reference-testing#trio.testing.MockClock&quot;&gt; &lt;code&gt;trio.testing.MockClock&lt;/code&gt; &lt;/a&gt; 과 같은 &lt;a href=&quot;#trio.abc.Clock&quot;&gt; &lt;code&gt;trio.abc.Clock&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하는 객체 인스턴스 입니다.</target>
        </trans-unit>
        <trans-unit id="860eda59b396acc32f124935a38e145c0d3045f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clogged_stream_maker&lt;/code&gt; &amp;ndash; Either None, or an async function similar to stream_maker, but with the extra property that the returned stream is in a state where &lt;code&gt;send_all&lt;/code&gt; and &lt;code&gt;wait_send_all_might_not_block&lt;/code&gt; will block until &lt;code&gt;receive_some&lt;/code&gt; has been called. This allows for more thorough testing of some edge cases, especially around &lt;code&gt;wait_send_all_might_not_block&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;clogged_stream_maker&lt;/code&gt; &amp;ndash; 없음 또는 stream_maker와 유사한 비동기 함수이지만, &lt;code&gt;receive_some&lt;/code&gt; 이 호출 될 때까지 &lt;code&gt;send_all&lt;/code&gt; 및 &lt;code&gt;wait_send_all_might_not_block&lt;/code&gt; 이 차단 되는 상태에 리턴 된 스트림이 추가되는 추가 특성이 있습니다. 이를 통해 특히 &lt;code&gt;wait_send_all_might_not_block&lt;/code&gt; 주변의 일부 엣지 케이스를보다 철저히 테스트 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="e779fb27fea43c8724925ef19c2fe9fd192b6d5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;close_hook&lt;/code&gt; &amp;ndash; A synchronous function, or None. Called from &lt;a href=&quot;#trio.testing.MemoryReceiveStream.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.MemoryReceiveStream.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt;. Can do whatever you like.</source>
          <target state="translated">&lt;code&gt;close_hook&lt;/code&gt; &amp;ndash; 동기 함수 또는 없음 &lt;a href=&quot;#trio.testing.MemoryReceiveStream.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.testing.MemoryReceiveStream.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 에서 호출. 원하는대로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a2c41d8353693c8e391e1e84e166ceb5376daec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;close_hook&lt;/code&gt; &amp;ndash; A synchronous function, or None. Called from &lt;a href=&quot;#trio.testing.MemorySendStream.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.MemorySendStream.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt;. Can do whatever you like.</source>
          <target state="translated">&lt;code&gt;close_hook&lt;/code&gt; &amp;ndash; 동기 함수 또는 없음 &lt;a href=&quot;#trio.testing.MemorySendStream.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.testing.MemorySendStream.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 에서 호출됩니다 . 원하는대로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c0ec103234df050921b19320c94e21db604369a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;command&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#list&quot;&gt;&lt;em&gt;list&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The command to run. Typically this is a sequence of strings such as &lt;code&gt;['ls', '-l', 'directory with spaces']&lt;/code&gt;, where the first element names the executable to invoke and the other elements specify its arguments. With &lt;code&gt;shell=True&lt;/code&gt; in the &lt;code&gt;**options&lt;/code&gt;, or on Windows, &lt;code&gt;command&lt;/code&gt; may alternatively be a string, which will be parsed following platform-dependent &lt;a href=&quot;#subprocess-quoting&quot;&gt;quoting rules&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;command&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#list&quot;&gt;&lt;em&gt;list&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 실행할 명령입니다. 일반적으로 이것은 &lt;code&gt;['ls', '-l', 'directory with spaces']&lt;/code&gt; 같은 일련의 문자열입니다 . 여기서 첫 번째 요소는 호출 할 실행 파일의 이름을 지정하고 다른 요소는 해당 인수를 지정합니다. &lt;code&gt;**options&lt;/code&gt; 또는 Windows 에서 &lt;code&gt;shell=True&lt;/code&gt; 를 사용하면 &lt;code&gt;command&lt;/code&gt; 은 문자열 일 수 있으며 플랫폼에 따라 달라지는 &lt;a href=&quot;#subprocess-quoting&quot;&gt;인용 규칙에&lt;/a&gt; 따라 구문 분석 됩니다. .</target>
        </trans-unit>
        <trans-unit id="40140e686bf510b2f8293cc2dd5df21d12c89cf6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the number of tasks to move.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 이동할 작업 수입니다.</target>
        </trans-unit>
        <trans-unit id="0379bcb0cf80c0ae9106a2c0e8751a5cad9def29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the number of tasks to unpark.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 해제 할 작업 수입니다.</target>
        </trans-unit>
        <trans-unit id="690dccb2485b6c1efd90c85b494cf8f0b08f1e98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;current_buffer_used&lt;/code&gt;: The number of items currently stored in the channel buffer.</source>
          <target state="translated">&lt;code&gt;current_buffer_used&lt;/code&gt; : 채널 버퍼에 현재 저장된 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="dadcc8231dcf4bb29a9204af389689c14e03ab19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytearray&quot;&gt;&lt;em&gt;bytearray&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#memoryview&quot;&gt;&lt;em&gt;memoryview&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The data to send.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt; , &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytearray&quot;&gt;&lt;em&gt;bytearray&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#memoryview&quot;&gt;&lt;em&gt;memoryview&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 전송할 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="9e0bcc2df98273163a158aa7256e7c594257e9ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deadline&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The absolute time of the next deadline, according to this clock.</source>
          <target state="translated">&lt;code&gt;deadline&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash;이 시계에 따른 다음 마감 시간의 절대 시간.</target>
        </trans-unit>
        <trans-unit id="6fb54f7efa2bdbb464a3fe3aba7d3a68dc645d31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deadline&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The deadline.</source>
          <target state="translated">&lt;code&gt;deadline&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 마감일.</target>
        </trans-unit>
        <trans-unit id="8667fcbc6dd78d180064c9e81498909f565d4887" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deadline&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The time at which we should wake up again. May be in the past, in which case this function executes a checkpoint but does not block.</source>
          <target state="translated">&lt;code&gt;deadline&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 다시 일어날 시간. 과거에있을 수 있습니다.이 경우이 함수는 검사 점을 실행하지만 차단하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="110c740c8e2a91d0d62d994f837008f31e4e0588" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deliver&lt;/code&gt; (&lt;em&gt;sync function&lt;/em&gt;) &amp;ndash; Takes the &lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt;&lt;code&gt;outcome.Outcome&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;fn&lt;/code&gt;, and delivers it. &lt;em&gt;Must not block.&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;deliver&lt;/code&gt; ( &lt;em&gt;동기화 기능&lt;/em&gt; 참조) - 소요 &lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt; &lt;code&gt;outcome.Outcome&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;fn&lt;/code&gt; 하고, 그것을 제공합니다. &lt;em&gt;차단해서는 안됩니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="14c209984b7887065de05510dd04134e96714201" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deliver_cancel&lt;/code&gt; (&lt;em&gt;async function&lt;/em&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash;</source>
          <target state="translated">&lt;code&gt;deliver_cancel&lt;/code&gt; ( &lt;em&gt;비동기 함수 &lt;/em&gt;&lt;em&gt;또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash;</target>
        </trans-unit>
        <trans-unit id="3a4c209857b34f6a3b9eeecc0f7c4d0219245990" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;done_callback&lt;/code&gt; &amp;ndash;</source>
          <target state="translated">&lt;code&gt;done_callback&lt;/code&gt; &amp;ndash;</target>
        </trans-unit>
        <trans-unit id="77800851c9fc95abd8c97c6f9ad88ec4eff08a62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exceptions&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#list&quot;&gt;&lt;em&gt;list&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The exceptions</source>
          <target state="translated">&lt;code&gt;exceptions&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#list&quot;&gt;&lt;em&gt;list&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 예외</target>
        </trans-unit>
        <trans-unit id="d5fa2991cffd7cd3200dc0f2e56873f167c346ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fd&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The fd to be wrapped.</source>
          <target state="translated">&lt;code&gt;fd&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;INT&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 줄 바꿈 할 fd입니다.</target>
        </trans-unit>
        <trans-unit id="6415289b25910c926cfd7391cdb9f60b2e28f3d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file&lt;/code&gt; &amp;ndash; a &lt;a href=&quot;https://docs.python.org/3/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; &amp;ndash; &lt;a href=&quot;https://docs.python.org/3/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f0bf27129b492aab1ef62b22db0bcaa1bf5497cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filename&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The filename to open the connection to.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 연결을 열 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="87836835d2fe68db69d0949466e77097175300f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;final_outcome&lt;/code&gt; (&lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt;&lt;em&gt;outcome.Outcome&lt;/em&gt;&lt;/a&gt;) &amp;ndash; Trio acts as if the current task exited with the given return value or exception.</source>
          <target state="translated">&lt;code&gt;final_outcome&lt;/code&gt; ( &lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt;&lt;em&gt;result.Outcome&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; Trio는 현재 작업이 주어진 반환 값 또는 예외로 종료 된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="62042858b15f09b4c5cc96255acc8462334f5370" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt; (&lt;em&gt;sync function&lt;/em&gt;) &amp;ndash; Performs arbitrary blocking work.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; ( &lt;em&gt;동기화 기능&lt;/em&gt; ) &amp;ndash; 임의 차단 ​​작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="157ed0b8e932f730a0991b1a4ea88e6876050de6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handle&lt;/code&gt; &amp;ndash; A Win32 object handle, as a Python integer.</source>
          <target state="translated">&lt;code&gt;handle&lt;/code&gt; &amp;ndash; Python 정수로서의 Win32 객체 핸들.</target>
        </trans-unit>
        <trans-unit id="e1f256647adeb8c7357b02329e2fb43f4013fc47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler&lt;/code&gt; &amp;ndash; A callable that takes an atomic (non-MultiError) exception as input, and returns either a new exception object or None.</source>
          <target state="translated">&lt;code&gt;handler&lt;/code&gt; &amp;ndash; 원 자성 (MultiError가 아닌) 예외를 입력으로 받아서 새 예외 개체 또는 없음을 반환하는 호출 가능 개체입니다.</target>
        </trans-unit>
        <trans-unit id="e21bd96821ba01f78d8d00051deaba8766ae0ec1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler&lt;/code&gt; &amp;ndash; An async callable, that will be invoked like &lt;code&gt;handler_nursery.start_soon(handler, stream)&lt;/code&gt; for each incoming connection.</source>
          <target state="translated">&lt;code&gt;handler&lt;/code&gt; &amp;ndash; 각각의 들어오는 연결에 대해 &lt;code&gt;handler_nursery.start_soon(handler, stream)&lt;/code&gt; 과 같이 호출되는 비동기 호출 가능 .</target>
        </trans-unit>
        <trans-unit id="a3090b03f0ea95979f385025f5e9b720564d49b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler&lt;/code&gt; &amp;ndash; The handler to start for each incoming connection. Passed to &lt;a href=&quot;#trio.serve_listeners&quot;&gt;&lt;code&gt;serve_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;handler&lt;/code&gt; &amp;ndash; 들어오는 각 연결에 대해 시작할 핸들러입니다. &lt;a href=&quot;#trio.serve_listeners&quot;&gt; &lt;code&gt;serve_listeners()&lt;/code&gt; &lt;/a&gt; 전달 .</target>
        </trans-unit>
        <trans-unit id="fc9c1209bc96d45713b43b4c11b9c22fcd87dff4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler&lt;/code&gt; &amp;ndash; as for &lt;a href=&quot;#trio.MultiError.filter&quot;&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;handler&lt;/code&gt; &amp;ndash; &lt;a href=&quot;#trio.MultiError.filter&quot;&gt; &lt;code&gt;filter()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56eeeda767ac09256570229477d193d581421b60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler_nursery&lt;/code&gt; &amp;ndash; The nursery to start handlers in, or None to use an internal nursery. Passed to &lt;a href=&quot;#trio.serve_listeners&quot;&gt;&lt;code&gt;serve_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;handler_nursery&lt;/code&gt; &amp;ndash; 처리기를 시작하는 종묘장 또는 내부 종묘장을 사용하는 종은 없습니다. &lt;a href=&quot;#trio.serve_listeners&quot;&gt; &lt;code&gt;serve_listeners()&lt;/code&gt; &lt;/a&gt; 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4af545c35c53e61365a8ac2fa1e98f8b1d35398e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handler_nursery&lt;/code&gt; &amp;ndash; The nursery used to start handlers, or any object with a &lt;code&gt;start_soon&lt;/code&gt; method. If &lt;code&gt;None&lt;/code&gt; (the default), then &lt;a href=&quot;#trio.serve_listeners&quot;&gt;&lt;code&gt;serve_listeners()&lt;/code&gt;&lt;/a&gt; will create a new nursery internally and use that.</source>
          <target state="translated">&lt;code&gt;handler_nursery&lt;/code&gt; &amp;ndash; 핸들러 또는 &lt;code&gt;start_soon&lt;/code&gt; 메소드를 사용하는 오브젝트를 시작하는 데 사용되는 보육 입니다. 만약 &lt;code&gt;None&lt;/code&gt; (기본값), 다음 &lt;a href=&quot;#trio.serve_listeners&quot;&gt; &lt;code&gt;serve_listeners()&lt;/code&gt; &lt;/a&gt; 내부적으로 새로운 보육을 작성하지 않고 그것을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4714ad5aa250c4e62ca1bade88a6bdce111e9ed3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;happy_eyeballs_delay&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; How many seconds to wait for each connection attempt to succeed or fail before getting impatient and starting another one in parallel. Set to &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt;&lt;code&gt;math.inf&lt;/code&gt;&lt;/a&gt; if you want to limit to only one connection attempt at a time (like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.create_connection&quot;&gt;&lt;code&gt;socket.create_connection()&lt;/code&gt;&lt;/a&gt;). Default: 0.25 (250 ms).</source>
          <target state="translated">&lt;code&gt;happy_eyeballs_delay&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 참을성이 없어지고 병렬로 다른 연결을 시작하기 전에 각 연결 시도가 성공하거나 실패 할 때까지 기다리는 시간 (초)입니다. 한 번에 하나의 연결 시도 만 제한 하려면 &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt; &lt;code&gt;math.inf&lt;/code&gt; 로&lt;/a&gt; 설정하십시오 (예 : &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.create_connection&quot;&gt; &lt;code&gt;socket.create_connection()&lt;/code&gt; &lt;/a&gt; ). 기본값 : 0.25 (250ms).</target>
        </trans-unit>
        <trans-unit id="bebdc09baf7871b5bce3ae32b267627c6ae9fe02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;happy_eyeballs_delay&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; How many seconds to wait for each connection attempt to succeed or fail before getting impatient and starting another one in parallel. Set to &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt;&lt;code&gt;math.inf&lt;/code&gt;&lt;/a&gt; if you want to limit to only one connection attempt at a time (like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.create_connection&quot;&gt;&lt;code&gt;socket.create_connection()&lt;/code&gt;&lt;/a&gt;). Default: 0.3 (300 ms).</source>
          <target state="translated">&lt;code&gt;happy_eyeballs_delay&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 초조해 다른 연결을 병렬로 시작하기 전에 각 연결의 성공 또는 실패를 기다리는 시간 (초)입니다. &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt; &lt;code&gt;math.inf&lt;/code&gt; 로&lt;/a&gt; 설정&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.create_connection&quot;&gt; &lt;code&gt;socket.create_connection()&lt;/code&gt; &lt;/a&gt; 과 같이 한 번에 한 번의 연결 시도로만 제한 . 기본값 : 0.3 (300ms)</target>
        </trans-unit>
        <trans-unit id="affa03c7e502c2fc86242cb0d11615285683394e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;happy_eyeballs_delay&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; See &lt;a href=&quot;#trio.open_tcp_stream&quot;&gt;&lt;code&gt;open_tcp_stream()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;happy_eyeballs_delay&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 참조&lt;a href=&quot;#trio.open_tcp_stream&quot;&gt; &lt;code&gt;open_tcp_stream()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="dbac9a1a6994581b4b38e452eec92143adbf0523" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The host to connect to. We require the server to have a TLS certificate valid for this hostname.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;바이트&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt; str&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 연결할 호스트입니다. 서버에이 호스트 이름에 유효한 TLS 인증서가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8f31351856ccab3985f0e467499257fe16d6e8cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The host to connect to. Can be an IPv4 address, IPv6 address, or a hostname.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt; bytes&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 연결할 호스트입니다. IPv4 주소, IPv6 주소 또는 호스트 이름 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85169f444121eecc3bcbc7a396753fa7e069ed42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The address to bind to; use &lt;code&gt;None&lt;/code&gt; to bind to the wildcard address. See &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; , &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 바인딩 할 주소입니다. 와일드 카드 주소에 바인드 하려면 &lt;code&gt;None&lt;/code&gt; 을 사용 하십시오. 보다&lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b00dff8ee9e060b0c31fa547f761bf83cd361d67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The address to bind to; use &lt;code&gt;None&lt;/code&gt; to bind to the wildcard address. Ultimately passed to &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; , &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 바인딩 할 주소입니다. 와일드 카드 주소에 바인드 하려면 &lt;code&gt;None&lt;/code&gt; 을 사용 하십시오. 궁극적으로 &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt; 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="bc4d39307a6d0cd1247b70528e7586e71641b59a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The host interface to listen on; use &lt;code&gt;None&lt;/code&gt; to bind to the wildcard address. Passed to &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; , &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;em&gt;bytes&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 청취 할 호스트 인터페이스. 와일드 카드 주소에 바인드 하려면 &lt;code&gt;None&lt;/code&gt; 을 사용 하십시오. &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt; 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3396b6088cb6d8d54f175511526c66926034c4de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, &lt;/em&gt;&lt;em&gt;bytes-like&lt;/em&gt;&lt;em&gt;, or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash;</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; , &lt;/em&gt;&lt;em&gt;bytes-like &lt;/em&gt;&lt;em&gt;또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None)&lt;/em&gt;&lt;/a&gt; ) &amp;ndash;</target>
        </trans-unit>
        <trans-unit id="8c68f9d4f0f10c907e7bbb307d87bf82f7d6be3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host_uses_signal_set_wakeup_fd&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; Pass &lt;a href=&quot;https://docs.python.org/3/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; if your host loop uses &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt;&lt;code&gt;signal.set_wakeup_fd&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://docs.python.org/3/library/constants.html#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt; otherwise. For more details, see &lt;a href=&quot;#guest-run-implementation&quot;&gt;Implementing guest mode for your favorite event loop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;host_uses_signal_set_wakeup_fd&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 호스트 루프가 &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt; &lt;code&gt;signal.set_wakeup_fd&lt;/code&gt; 를&lt;/a&gt; 사용하면 &lt;a href=&quot;https://docs.python.org/3/library/constants.html#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; 를&lt;/a&gt;전달 하고 &lt;a href=&quot;https://docs.python.org/3/library/constants.html#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 않으면 False를 전달 합니다. 자세한 내용은 &lt;a href=&quot;#guest-run-implementation&quot;&gt;즐겨 찾는 이벤트 루프에 게스트 모드 구현을&lt;/a&gt; 참조 하세요 .</target>
        </trans-unit>
        <trans-unit id="074be0b2389e540f899b65e8e67b72f995eaf623" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hostname_resolver&lt;/code&gt; (&lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt;&lt;em&gt;trio.abc.HostnameResolver&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The new custom hostname resolver, or None to restore the default behavior.</source>
          <target state="translated">&lt;code&gt;hostname_resolver&lt;/code&gt; ( &lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt;&lt;em&gt;trio.abc.HostnameResolver&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 새로운 사용자 정의 호스트 이름 확인자 또는 기본 동작을 복원 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0d50447b98e80a0aea797f5d7a937152a4614467" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;https_compatible&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash;</source>
          <target state="translated">&lt;code&gt;https_compatible&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt; ) &amp;ndash;</target>
        </trans-unit>
        <trans-unit id="5babef15cad79840bbc9adbb50fdc59ccaa1cac9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;https_compatible&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; Passed on to &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;https_compatible&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; 으로&lt;/a&gt; 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="27c5784b8bbd8392a7507a351b92d3c67de27f32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;https_compatible&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; See &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;https_compatible&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 자세한 내용은 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="187c968d569e623f5011cfb88a3f14e72456d0d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;https_compatible&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; Set this to True if you want to use &amp;ldquo;HTTPS-style&amp;rdquo; TLS. See &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;https_compatible&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt; ) &amp;ndash;&amp;ldquo;HTTPS 스타일&amp;rdquo;TLS를 사용하려면이를 True로 설정하십시오. 자세한 내용은 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6d55552e0dd68f23f3e02c52abf767ab3de478c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;https_compatible&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; Set this to True if you&amp;rsquo;re connecting to a web server. See &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; for details. Default: False.</source>
          <target state="translated">&lt;code&gt;https_compatible&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 웹 서버에 연결하는 경우이를 True로 설정하십시오. 자세한 내용은 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 을 참조하십시오. 기본값 : False</target>
        </trans-unit>
        <trans-unit id="5707c6a5ce826447ce17e91733c254fe69ab1010" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initial_value&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; A non-negative integer giving semaphore&amp;rsquo;s initial value.</source>
          <target state="translated">&lt;code&gt;initial_value&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 세마포어의 초기 값을 제공하는 음이 아닌 정수입니다.</target>
        </trans-unit>
        <trans-unit id="14019ce35d114be701b9b9da974d5295aa5190b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instrument&lt;/code&gt; (&lt;a href=&quot;#trio.abc.Instrument&quot;&gt;&lt;em&gt;trio.abc.Instrument&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The instrument to activate.</source>
          <target state="translated">&lt;code&gt;instrument&lt;/code&gt; ( &lt;a href=&quot;#trio.abc.Instrument&quot;&gt;&lt;em&gt;trio.abc.Instrument&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 활성화 할 계측기입니다.</target>
        </trans-unit>
        <trans-unit id="55e2a6f69308acbcba045cfc0acd6c283a528e56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instrument&lt;/code&gt; (&lt;a href=&quot;#trio.abc.Instrument&quot;&gt;&lt;em&gt;trio.abc.Instrument&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The instrument to de-activate.</source>
          <target state="translated">&lt;code&gt;instrument&lt;/code&gt; ( &lt;a href=&quot;#trio.abc.Instrument&quot;&gt;&lt;em&gt;trio.abc.Instrument&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 비활성화 할 계측기입니다.</target>
        </trans-unit>
        <trans-unit id="58bb2b928e47ff336aa159dab8cacf8b0830e93d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instruments&lt;/code&gt; (list of &lt;a href=&quot;reference-hazmat#trio.abc.Instrument&quot;&gt;&lt;code&gt;trio.abc.Instrument&lt;/code&gt;&lt;/a&gt; objects) &amp;ndash; Any instrumentation you want to apply to this run. This can also be modified during the run; see &lt;a href=&quot;reference-hazmat#instrumentation&quot;&gt;Instrument API&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;instruments&lt;/code&gt; ( &lt;a href=&quot;reference-hazmat#trio.abc.Instrument&quot;&gt; &lt;code&gt;trio.abc.Instrument&lt;/code&gt; &lt;/a&gt; 객체 목록 ) &amp;ndash;이 런에 적용하려는 모든 계측 실행 중에도 수정할 수 있습니다. &lt;a href=&quot;reference-hazmat#instrumentation&quot;&gt;인스트루먼트 API를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1765f83dc17f3d7069682087f8715174ad6c8971" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instruments&lt;/code&gt; (list of &lt;a href=&quot;reference-lowlevel#trio.abc.Instrument&quot;&gt;&lt;code&gt;trio.abc.Instrument&lt;/code&gt;&lt;/a&gt; objects) &amp;ndash; Any instrumentation you want to apply to this run. This can also be modified during the run; see &lt;a href=&quot;reference-lowlevel#instrumentation&quot;&gt;Instrument API&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;instruments&lt;/code&gt; ( &lt;a href=&quot;reference-lowlevel#trio.abc.Instrument&quot;&gt; &lt;code&gt;trio.abc.Instrument&lt;/code&gt; &lt;/a&gt; 개체 목록 ) &amp;ndash;이 실행에 적용 할 모든 계측입니다. 이것은 또한 실행 중에 수정할 수 있습니다. &lt;a href=&quot;reference-lowlevel#instrumentation&quot;&gt;Instrument API를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ae228be9cdd956ffb549d3563e530e30e9b16eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;io_statistics&lt;/code&gt; (object): Some statistics from Trio&amp;rsquo;s I/O backend. This always has an attribute &lt;code&gt;backend&lt;/code&gt; which is a string naming which operating-system-specific I/O backend is in use; the other attributes vary between backends.</source>
          <target state="translated">&lt;code&gt;io_statistics&lt;/code&gt; (객체) : Trio I / O 백엔드의 일부 통계입니다. 이것은 항상 속성이 있습니다 &lt;code&gt;backend&lt;/code&gt; / O 백엔드를 사용 운영 체제 관련 I 인 문자열의 이름이다; 다른 속성은 백엔드마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="caa0288e42c5ed7aa4d4abe45de8d1a8397f2ac7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;limiter&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;&lt;em&gt;, or &lt;/em&gt;&lt;em&gt;CapacityLimiter-like object&lt;/em&gt;) &amp;ndash;</source>
          <target state="translated">&lt;code&gt;limiter&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;em&gt;CapacityLimiter와 유사한 객체&lt;/em&gt; ) &amp;ndash;</target>
        </trans-unit>
        <trans-unit id="e6b3136ebabc2e2d4a623b203fdbb4407f1a6cf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;listeners&lt;/code&gt; &amp;ndash; A list of &lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;code&gt;Listener&lt;/code&gt;&lt;/a&gt; objects. &lt;a href=&quot;#trio.serve_listeners&quot;&gt;&lt;code&gt;serve_listeners()&lt;/code&gt;&lt;/a&gt; takes responsibility for closing them.</source>
          <target state="translated">&lt;code&gt;listeners&lt;/code&gt; &amp;ndash; &lt;a href=&quot;#trio.abc.Listener&quot;&gt; &lt;code&gt;Listener&lt;/code&gt; &lt;/a&gt; 객체 목록입니다 . &lt;a href=&quot;#trio.serve_listeners&quot;&gt; &lt;code&gt;serve_listeners()&lt;/code&gt; &lt;/a&gt; 는이를 닫는 책임을집니다.</target>
        </trans-unit>
        <trans-unit id="c9462f279462181a36c47f04108d6717661f67b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;local_address&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;) &amp;ndash;</source>
          <target state="translated">&lt;code&gt;local_address&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt; ) &amp;ndash;</target>
        </trans-unit>
        <trans-unit id="603520e5b0c2ec38ba7849c079a95865966b8532" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock&lt;/code&gt; (&lt;a href=&quot;#trio.Lock&quot;&gt;&lt;em&gt;Lock&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the lock object to use. If given, must be a &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;trio.Lock&lt;/code&gt;&lt;/a&gt;. If None, a new &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; will be allocated and used.</source>
          <target state="translated">&lt;code&gt;lock&lt;/code&gt; ( &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;em&gt;Lock&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 사용할 잠금 개체입니다. 주어진 경우, &lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;trio.Lock&lt;/code&gt; &lt;/a&gt; 이어야합니다 . None이면 새로운 &lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 이 할당되어 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4f95ec20797af7c898f2ac2ba1019bff94a70685" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock_statistics&lt;/code&gt;: The result of calling the underlying &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt;s &lt;a href=&quot;#trio.Lock.statistics&quot;&gt;&lt;code&gt;statistics()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;lock_statistics&lt;/code&gt; : 기본 호출의 결과 &lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#trio.Lock.statistics&quot;&gt; &lt;code&gt;statistics()&lt;/code&gt; &lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="618a487482254c3b69d5735a445c55798f94a09f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;locked&lt;/code&gt;: boolean indicating whether the lock is held.</source>
          <target state="translated">&lt;code&gt;locked&lt;/code&gt; : 잠금 유지 여부를 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="f10292d0fadb857c306a0dc5948de94c6800fa10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_buffer_size&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;em&gt;math.inf&lt;/em&gt;) &amp;ndash; The maximum number of items that can be buffered in the channel before &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; blocks. Choosing a sensible value here is important to ensure that backpressure is communicated promptly and avoid unnecessary latency; see &lt;a href=&quot;#channel-buffering&quot;&gt;Buffering in channels&lt;/a&gt; for more details. If in doubt, use 0.</source>
          <target state="translated">&lt;code&gt;max_buffer_size&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;em&gt;math.inf&lt;/em&gt; ) &amp;ndash; &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt; 블록 전에 채널에서 버퍼링 할 수있는 최대 항목 수입니다 . 여기에서 합리적인 값을 선택하는 것은 배압이 신속하게 전달되고 불필요한 대기 시간을 피하기 위해 중요합니다. 참조 &lt;a href=&quot;#channel-buffering&quot;&gt;채널에서 버퍼링&lt;/a&gt; 자세한 내용은. 확실하지 않은 경우 0을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c36c15f6dc63bafb000356c2e369cf94cea73a6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_buffer_size&lt;/code&gt;: The maximum number of items allowed in the buffer, as passed to &lt;a href=&quot;#trio.open_memory_channel&quot;&gt;&lt;code&gt;open_memory_channel()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;max_buffer_size&lt;/code&gt; : &lt;a href=&quot;#trio.open_memory_channel&quot;&gt; &lt;code&gt;open_memory_channel()&lt;/code&gt; &lt;/a&gt; 전달 될 때 버퍼에 허용되는 최대 항목 수입니다 .</target>
        </trans-unit>
        <trans-unit id="fb8421a300b0d79f331765927482a9927d7ef8ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_bytes&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The maximum number of bytes to return. Must be greater than zero. Optional; if omitted, then the stream object is free to pick a reasonable default.</source>
          <target state="translated">&lt;code&gt;max_bytes&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 반환 할 최대 바이트 수입니다. 0보다 커야합니다. 선택 과목; 생략하면, 스트림 객체는 합리적인 기본값을 자유롭게 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64d7e5bd2cb1a725ab3e6f7c27796809e159dfc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_bytes&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The maximum amount of data to retrieve. None (the default) means to retrieve all the data that&amp;rsquo;s present (but still blocks until at least one byte is available).</source>
          <target state="translated">&lt;code&gt;max_bytes&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 검색 할 최대 데이터 양. 없음 (기본값)은 존재하는 모든 데이터를 검색하는 것을 의미합니다 (그러나 1 바이트 이상을 사용할 수있을 때까지 여전히 차단됨).</target>
        </trans-unit>
        <trans-unit id="1c0b9268404ebe0c19a43e52b1e0a3c679151746" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_bytes&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The maximum amount of data to transfer in this call, or None to transfer all available data.</source>
          <target state="translated">&lt;code&gt;max_bytes&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash;이 호출에서 전송할 최대 데이터 양 또는 사용 가능한 모든 데이터를 전송하려면 없음</target>
        </trans-unit>
        <trans-unit id="73ab6bec5c64069d56daa42b165b5ad34cc59b85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_value&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; If given, makes this a &amp;ldquo;bounded&amp;rdquo; semaphore that raises an error if the value is about to exceed the given &lt;code&gt;max_value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;max_value&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 지정된 경우, 값이 지정된 &lt;code&gt;max_value&lt;/code&gt; 를 초과하려고하면 오류를 발생시키는 &quot;바운드&quot;세마포어로 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="a7f5017fe0d3b3ed322b7919d7d0f3d41211f091" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;memory_receive_stream&lt;/code&gt; (&lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;em&gt;MemoryReceiveStream&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The stream to put data into.</source>
          <target state="translated">&lt;code&gt;memory_receive_stream&lt;/code&gt; ( &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;em&gt;MemoryReceiveStream&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 데이터를 넣을 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="654314fb938a88ac66124f8a48ddf7ed1de7b204" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;memory_send_stream&lt;/code&gt; (&lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;em&gt;MemorySendStream&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The stream to get data from.</source>
          <target state="translated">&lt;code&gt;memory_send_stream&lt;/code&gt; ( &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;em&gt;MemorySendStream&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 데이터를 가져올 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="f87ec8fb8d6920675823afbf0256991664011220" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The number of tasks to wake.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 깨우는 작업 수입니다.</target>
        </trans-unit>
        <trans-unit id="706088dfef3e603575862e367adff10e8633b7eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; &amp;ndash; The name for this task. Only used for debugging/introspection (e.g. &lt;code&gt;repr(task_obj)&lt;/code&gt;). If this isn&amp;rsquo;t a string, &lt;a href=&quot;#trio.Nursery.start_soon&quot;&gt;&lt;code&gt;start_soon()&lt;/code&gt;&lt;/a&gt; will try to make it one. A common use case is if you&amp;rsquo;re wrapping a function before spawning a new task, you might pass the original function as the &lt;code&gt;name=&lt;/code&gt; to make debugging easier.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; &amp;ndash;이 작업의 이름입니다. 디버깅 / 검사에만 사용됩니다 (예 : &lt;code&gt;repr(task_obj)&lt;/code&gt; ). 이것이 문자열이 아닌 경우 &lt;a href=&quot;#trio.Nursery.start_soon&quot;&gt; &lt;code&gt;start_soon()&lt;/code&gt; &lt;/a&gt; 은 문자열 을 만들려고 시도합니다. 일반적인 사용 사례는 새 작업을 생성하기 전에 함수를 래핑하는 경우 디버깅을 쉽게하기 위해 원래 함수를 &lt;code&gt;name=&lt;/code&gt; 으로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85f9eda5653f8aa6042815ed9751de5914613b1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; &amp;ndash; The name for this task. Only used for debugging/introspection (e.g. &lt;code&gt;repr(task_obj)&lt;/code&gt;). If this isn&amp;rsquo;t a string, &lt;a href=&quot;#trio.hazmat.spawn_system_task&quot;&gt;&lt;code&gt;spawn_system_task()&lt;/code&gt;&lt;/a&gt; will try to make it one. A common use case is if you&amp;rsquo;re wrapping a function before spawning a new task, you might pass the original function as the &lt;code&gt;name=&lt;/code&gt; to make debugging easier.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; &amp;ndash;이 작업의 이름입니다. 디버깅 / 검사에만 사용됩니다 (예 : &lt;code&gt;repr(task_obj)&lt;/code&gt; ). 이것이 문자열이 아닌 경우 &lt;a href=&quot;#trio.hazmat.spawn_system_task&quot;&gt; &lt;code&gt;spawn_system_task()&lt;/code&gt; &lt;/a&gt; 는 문자열 을 만들려고 시도합니다. 일반적인 사용 사례는 새 작업을 생성하기 전에 함수를 래핑하는 경우 디버깅을 쉽게하기 위해 원래 함수를 &lt;code&gt;name=&lt;/code&gt; 으로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82a728d3ade9f4ba3c43322740a970330e4178e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; &amp;ndash; The name for this task. Only used for debugging/introspection (e.g. &lt;code&gt;repr(task_obj)&lt;/code&gt;). If this isn&amp;rsquo;t a string, &lt;a href=&quot;#trio.lowlevel.spawn_system_task&quot;&gt;&lt;code&gt;spawn_system_task()&lt;/code&gt;&lt;/a&gt; will try to make it one. A common use case is if you&amp;rsquo;re wrapping a function before spawning a new task, you might pass the original function as the &lt;code&gt;name=&lt;/code&gt; to make debugging easier.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; &amp;ndash;이 작업의 이름입니다. 디버깅 / 검사에만 사용됩니다 (예 : &lt;code&gt;repr(task_obj)&lt;/code&gt; ). 이것이 문자열이 아니라면, &lt;a href=&quot;#trio.lowlevel.spawn_system_task&quot;&gt; &lt;code&gt;spawn_system_task()&lt;/code&gt; &lt;/a&gt; 는 문자열 로 만들려고 할 것입니다. 일반적인 사용 사례는 새 작업을 생성하기 전에 함수를 래핑하는 경우 디버깅을 더 쉽게하기 위해 원래 함수를 &lt;code&gt;name=&lt;/code&gt; 으로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39ac8639a60221cedf2bb1578c2d5ec107ccc51d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_lot&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt;&lt;em&gt;ParkingLot&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the parking lot to move tasks to.</source>
          <target state="translated">&lt;code&gt;new_lot&lt;/code&gt; ( &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt;&lt;em&gt;ParkingLot&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 작업을 이동할 주차장입니다.</target>
        </trans-unit>
        <trans-unit id="25c3ba8d82a9eb6bf809fd4129e6b86ac7778819" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_lot&lt;/code&gt; (&lt;a href=&quot;#trio.lowlevel.ParkingLot&quot;&gt;&lt;em&gt;ParkingLot&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the parking lot to move tasks to.</source>
          <target state="translated">&lt;code&gt;new_lot&lt;/code&gt; ( &lt;a href=&quot;#trio.lowlevel.ParkingLot&quot;&gt;&lt;em&gt;ParkingLot&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 작업을 이동할 주차장입니다.</target>
        </trans-unit>
        <trans-unit id="35e6f7353e18ba4378af44a443eab3903e024291" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;next_send&lt;/code&gt; (&lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt;&lt;em&gt;outcome.Outcome&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the value (or error) to return (or raise) from &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;next_send&lt;/code&gt; ( &lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt;&lt;em&gt;outcome.Outcome&lt;/em&gt;&lt;/a&gt; ) - 값 (또는 그 이상)의 리턴 (또는 레이즈) &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d40627c7e742562591e675c4ca11ace6c539b8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;next_send&lt;/code&gt; (&lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt;&lt;em&gt;outcome.Outcome&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the value (or error) to return (or raise) from &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;next_send&lt;/code&gt; ( &lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt;&lt;em&gt;outcome.Outcome&lt;/em&gt;&lt;/a&gt; ) - 값 (또는 그 이상)의 리턴 (또는 레이즈) &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af7731c5998c5de2534323659b85fd3f1e7fa3a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open_receive_channels&lt;/code&gt;: Likewise, but for open &lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt;&lt;code&gt;MemoryReceiveChannel&lt;/code&gt;&lt;/a&gt; endpoints.</source>
          <target state="translated">&lt;code&gt;open_receive_channels&lt;/code&gt; : 마찬가지로 오픈 &lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt; &lt;code&gt;MemoryReceiveChannel&lt;/code&gt; &lt;/a&gt; 엔드 포인트 용.</target>
        </trans-unit>
        <trans-unit id="264c8c4e59d3770d771de5e9cb09326c7244420f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open_send_channels&lt;/code&gt;: The number of open &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt;&lt;code&gt;MemorySendChannel&lt;/code&gt;&lt;/a&gt; endpoints pointing to this channel. Initially 1, but can be increased by &lt;a href=&quot;#trio.MemorySendChannel.clone&quot;&gt;&lt;code&gt;MemorySendChannel.clone()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;open_send_channels&lt;/code&gt; : 이 채널을 가리키는 열린 &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt; &lt;code&gt;MemorySendChannel&lt;/code&gt; &lt;/a&gt; 엔드 포인트 수입니다 . 처음에는 1이지만 &lt;a href=&quot;#trio.MemorySendChannel.clone&quot;&gt; &lt;code&gt;MemorySendChannel.clone()&lt;/code&gt; &lt;/a&gt; 의해 증가 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f687cd0584184d32b7163dd5ec69eb308effa6c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;owner&lt;/code&gt;: the &lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt;&lt;code&gt;trio.hazmat.Task&lt;/code&gt;&lt;/a&gt; currently holding the lock, or None if the lock is not held.</source>
          <target state="translated">&lt;code&gt;owner&lt;/code&gt; : 현재 잠금을 보유하고 있는 &lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt; &lt;code&gt;trio.hazmat.Task&lt;/code&gt; &lt;/a&gt; 또는 잠금이 보류되지 않은 경우 없음.</target>
        </trans-unit>
        <trans-unit id="e2b262e6c1a8516593bac00b40782f1ebdab3b8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;owner&lt;/code&gt;: the &lt;a href=&quot;reference-lowlevel#trio.lowlevel.Task&quot;&gt;&lt;code&gt;trio.lowlevel.Task&lt;/code&gt;&lt;/a&gt; currently holding the lock, or None if the lock is not held.</source>
          <target state="translated">&lt;code&gt;owner&lt;/code&gt; : 현재 잠금을 보유하고 있는 &lt;a href=&quot;reference-lowlevel#trio.lowlevel.Task&quot;&gt; &lt;code&gt;trio.lowlevel.Task&lt;/code&gt; &lt;/a&gt; , 또는 잠금이 보유되지 않은 경우 None.</target>
        </trans-unit>
        <trans-unit id="1201160a78a8e4af5f332f34959d7081ecbb90c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; &amp;ndash; The port to listen on. Use 0 to let the kernel pick an open port. Passed to &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; &amp;ndash; 청취 할 포트입니다. 커널이 열린 포트를 선택하게하려면 0을 사용하십시오. &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt; 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="bbf694beba17ba8adf62f6d69c28af08e967d77c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash;</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt; ) &amp;ndash;</target>
        </trans-unit>
        <trans-unit id="6d4d205a129177b41813c6bde450d0de597a83b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The port to connect to.</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 연결할 포트입니다.</target>
        </trans-unit>
        <trans-unit id="688b71efb4d8d1187d700c0a0a375d12061437c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The port to listen on. See &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 청취 할 포트입니다. &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6309fbbaf79fb15176a3bcd81d0cc6f8c70527f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The port to listen on. Use 0 to let the kernel pick an open port. Ultimately passed to &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#int&quot;&gt;&lt;em&gt;int&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 청취 할 포트입니다. 커널이 열린 포트를 선택하게하려면 0을 사용하십시오. 궁극적으로 &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt; 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="891c4fdd705213cb6ca14177bb92af31c1871a82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rate&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the initial &lt;a href=&quot;#trio.testing.MockClock.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;rate&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 초기 &lt;a href=&quot;#trio.testing.MockClock.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99c33b6b52375c26e1c14f1877e1ed8f50108db9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;receive_some_hook&lt;/code&gt; &amp;ndash; An async function, or None. Called from &lt;a href=&quot;#trio.testing.MemoryReceiveStream.receive_some&quot;&gt;&lt;code&gt;receive_some()&lt;/code&gt;&lt;/a&gt;. Can do whatever you like.</source>
          <target state="translated">&lt;code&gt;receive_some_hook&lt;/code&gt; &amp;ndash; 비동기 함수 또는 없음 &lt;a href=&quot;#trio.testing.MemoryReceiveStream.receive_some&quot;&gt; &lt;code&gt;receive_some()&lt;/code&gt; &lt;/a&gt; 에서 호출되었습니다 . 원하는대로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05cee52381c53f6a92a6ebb9f868a6940a98367b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;receive_stream&lt;/code&gt; (&lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;em&gt;ReceiveStream&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The stream to use for receiving.</source>
          <target state="translated">&lt;code&gt;receive_stream&lt;/code&gt; ( &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;em&gt;ReceiveStream&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 수신에 사용할 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="83019553ed11c5b0a2f12316aebdf4dfe58596ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;restrict_keyboard_interrupt_to_checkpoints&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash;</source>
          <target state="translated">&lt;code&gt;restrict_keyboard_interrupt_to_checkpoints&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt; ) &amp;ndash;</target>
        </trans-unit>
        <trans-unit id="80c4c0dd0899149a98e2267e9e03ce41e17d8e50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;root_exc&lt;/code&gt; &amp;ndash; An exception, often (though not necessarily) a &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;root_exc&lt;/code&gt; - (아니더라도) 종종 예외하는 &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7cf2a6983c58be96125e39cbfdbd96589c61b4e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run_sync_soon_not_threadsafe&lt;/code&gt; &amp;ndash; Like &lt;code&gt;run_sync_soon_threadsafe&lt;/code&gt;, but will only be called from inside the host loop&amp;rsquo;s main thread. Optional, but if your host loop allows you to implement this more efficiently than &lt;code&gt;run_sync_soon_threadsafe&lt;/code&gt; then passing it will make things a bit faster.</source>
          <target state="translated">&lt;code&gt;run_sync_soon_not_threadsafe&lt;/code&gt; &amp;ndash; run_sync_soon_threadsafe 와 &lt;code&gt;run_sync_soon_threadsafe&lt;/code&gt; 하지만 호스트 루프의 메인 스레드 내부에서만 호출됩니다. 선택 사항이지만 호스트 루프에서 &lt;code&gt;run_sync_soon_threadsafe&lt;/code&gt; 보다 더 효율적으로 구현할 수있는 경우 전달하면 작업이 조금 더 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="23ac615251cbc92f776d4eb5dd37246a0f6e203a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run_sync_soon_queue_size&lt;/code&gt; (int): The number of unprocessed callbacks queued via &lt;a href=&quot;#trio.hazmat.TrioToken.run_sync_soon&quot;&gt;&lt;code&gt;trio.hazmat.TrioToken.run_sync_soon()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;run_sync_soon_queue_size&lt;/code&gt; (int) : &lt;a href=&quot;#trio.hazmat.TrioToken.run_sync_soon&quot;&gt; &lt;code&gt;trio.hazmat.TrioToken.run_sync_soon()&lt;/code&gt; &lt;/a&gt; 통해 대기중인 처리되지 않은 콜백 수입니다 .</target>
        </trans-unit>
        <trans-unit id="c342fa0cc16ac9e8caf5453ab1b957814a485f0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run_sync_soon_queue_size&lt;/code&gt; (int): The number of unprocessed callbacks queued via &lt;a href=&quot;#trio.lowlevel.TrioToken.run_sync_soon&quot;&gt;&lt;code&gt;trio.lowlevel.TrioToken.run_sync_soon()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;run_sync_soon_queue_size&lt;/code&gt; (int) : &lt;a href=&quot;#trio.lowlevel.TrioToken.run_sync_soon&quot;&gt; &lt;code&gt;trio.lowlevel.TrioToken.run_sync_soon()&lt;/code&gt; &lt;/a&gt; 통해 대기중인 처리되지 않은 콜백 수 .</target>
        </trans-unit>
        <trans-unit id="f03285fce2367e34315fe9eb001b631389a84b82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run_sync_soon_threadsafe&lt;/code&gt; &amp;ndash;</source>
          <target state="translated">&lt;code&gt;run_sync_soon_threadsafe&lt;/code&gt; &amp;ndash;</target>
        </trans-unit>
        <trans-unit id="0a7302082e39ea79ec9eaeeeac0d9e7da2f2ba73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seconds&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The number of seconds to sleep. May be zero to insert a checkpoint without actually blocking.</source>
          <target state="translated">&lt;code&gt;seconds&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 잠자는 시간 ( 초 )입니다. 실제로 차단하지 않고 검사 점을 삽입하려면 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71ade4f6da2a5244cad20deaa5a3a696936a36b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seconds&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The timeout.</source>
          <target state="translated">&lt;code&gt;seconds&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 시간 초과입니다.</target>
        </trans-unit>
        <trans-unit id="32fe1f6ae1e106de0d3baafe02009b4b950630f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seconds&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the number of seconds to jump the clock forward.</source>
          <target state="translated">&lt;code&gt;seconds&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 시계를 앞으로 이동하는 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="18d4f5b4bc1104d436c602e9f9a08574a1159caf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seconds_to_next_deadline&lt;/code&gt; (float): The time until the next pending cancel scope deadline. May be negative if the deadline has expired but we haven&amp;rsquo;t yet processed cancellations. May be &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt; if there are no pending deadlines.</source>
          <target state="translated">&lt;code&gt;seconds_to_next_deadline&lt;/code&gt; (float) : 다음 보류 보류 취소 범위 마감 시간까지의 시간입니다. 마감 기한이 만료되었지만 취소를 아직 처리하지 않은 경우 음수 일 수 있습니다. 수 있음 &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; 를&lt;/a&gt; 보류중인 기한이없는 경우.</target>
        </trans-unit>
        <trans-unit id="425704c4d337d3cfd23941c9ff81629105fbe7a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;send_all_hook&lt;/code&gt; &amp;ndash; An async function, or None. Called from &lt;a href=&quot;#trio.testing.MemorySendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt;. Can do whatever you like.</source>
          <target state="translated">&lt;code&gt;send_all_hook&lt;/code&gt; &amp;ndash; 비동기 함수 또는 없음 &lt;a href=&quot;#trio.testing.MemorySendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; 에서 호출됩니다 . 원하는대로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c64d4f7072233419756f70e991aa5c980c32bdd0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;send_stream&lt;/code&gt; (&lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;em&gt;SendStream&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The stream to use for sending.</source>
          <target state="translated">&lt;code&gt;send_stream&lt;/code&gt; ( &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;em&gt;SendStream&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 전송에 사용할 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="eaaf6a4ba68b4eabf4bb722fc4dec40bd05dc617" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server_hostname&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The name of the server being connected to. Used for &lt;a href=&quot;https://en.wikipedia.org/wiki/Server_Name_Indication&quot;&gt;SNI&lt;/a&gt; and for validating the server&amp;rsquo;s certificate (if hostname checking is enabled). This is effectively mandatory for clients, and actually mandatory if &lt;code&gt;ssl_context.check_hostname&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;server_hostname&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;&lt;em&gt;str&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 연결중인 서버의 이름입니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Server_Name_Indication&quot;&gt;SNI&lt;/a&gt; 및 서버 인증서 유효성 검증에 사용됩니다 (호스트 이름 확인이 사용 가능한 경우). 이는 클라이언트에게 효과적으로 필수이며 &lt;code&gt;ssl_context.check_hostname&lt;/code&gt; 이 &lt;code&gt;True&lt;/code&gt; 인 경우 실제로 필수 입니다.</target>
        </trans-unit>
        <trans-unit id="5fce58df86f9353ab8c11cd3da5a14acf3b35213" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server_side&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt;) &amp;ndash; Whether this stream is acting as a client or server. Defaults to False, i.e. client mode.</source>
          <target state="translated">&lt;code&gt;server_side&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;em&gt;bool&lt;/em&gt;&lt;/a&gt; ) &amp;ndash;이 스트림이 클라이언트인지 서버인지를 나타냅니다. 기본값은 False, 즉 클라이언트 모드입니다.</target>
        </trans-unit>
        <trans-unit id="fd831c422b81adc17c1c840d7c7aa39b79546dcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signals&lt;/code&gt; &amp;ndash; the signals to listen for.</source>
          <target state="translated">&lt;code&gt;signals&lt;/code&gt; &amp;ndash; 청취 할 신호.</target>
        </trans-unit>
        <trans-unit id="625912886efc60b616144fe727ff83d70132ecbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;socket&lt;/code&gt; &amp;ndash; The Trio socket object to wrap. Must have type &lt;code&gt;SOCK_STREAM&lt;/code&gt;, and be connected.</source>
          <target state="translated">&lt;code&gt;socket&lt;/code&gt; &amp;ndash; 랩할 Trio 소켓 오브젝트. &lt;code&gt;SOCK_STREAM&lt;/code&gt; 유형이어야 하며 연결되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2c1de1f3e683851cbc2557271aa46b50d8af5d8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;socket&lt;/code&gt; &amp;ndash; The Trio socket object to wrap. Must have type &lt;code&gt;SOCK_STREAM&lt;/code&gt;, and be listening.</source>
          <target state="translated">&lt;code&gt;socket&lt;/code&gt; &amp;ndash; 랩할 Trio 소켓 오브젝트. &lt;code&gt;SOCK_STREAM&lt;/code&gt; 유형이어야 하고 듣고 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ce3d562bcdafe947f34d36bf33565287516fe229" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;socket_factory&lt;/code&gt; (&lt;a href=&quot;#trio.abc.SocketFactory&quot;&gt;&lt;em&gt;trio.abc.SocketFactory&lt;/em&gt;&lt;/a&gt;&lt;em&gt; or &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The new custom socket factory, or None to restore the default behavior.</source>
          <target state="translated">&lt;code&gt;socket_factory&lt;/code&gt; ( &lt;a href=&quot;#trio.abc.SocketFactory&quot;&gt;&lt;em&gt;trio.abc.SocketFactory&lt;/em&gt;&lt;/a&gt;&lt;em&gt; 또는 &lt;/em&gt;&lt;a href=&quot;https://docs.python.org/3/library/constants.html#None&quot;&gt;&lt;em&gt;None&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 새로운 사용자 정의 소켓 팩토리 또는 기본 동작을 복원하려면 None.</target>
        </trans-unit>
        <trans-unit id="bd2352b22dc29b6e0af410069d9b9b812fbb387b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;socket_listener&lt;/code&gt; (&lt;a href=&quot;reference-io#trio.SocketListener&quot;&gt;&lt;em&gt;SocketListener&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The &lt;a href=&quot;reference-io#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt; to connect to.</source>
          <target state="translated">&lt;code&gt;socket_listener&lt;/code&gt; ( &lt;a href=&quot;reference-io#trio.SocketListener&quot;&gt;&lt;em&gt;SocketListener&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 연결할 &lt;a href=&quot;reference-io#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7938a9a43d222d0ab03f10ecc37e3195daae0b3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ssl_context&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; or None) &amp;ndash; The SSL context to use. If None (the default), &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt;&lt;code&gt;ssl.create_default_context()&lt;/code&gt;&lt;/a&gt; will be called to create a context.</source>
          <target state="translated">&lt;code&gt;ssl_context&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt; 또는 None) &amp;ndash; 사용할 SSL 컨텍스트. None (기본값)이면 컨텍스트를 만들기 위해 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt; &lt;code&gt;ssl.create_default_context()&lt;/code&gt; &lt;/a&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="aa3044a40c6a954d50347bd2af50ae331d1a87b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ssl_context&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; that will be used for incoming connections.</source>
          <target state="translated">&lt;code&gt;ssl_context&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 들어오는 연결에 사용될 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d2fb8dccd8c914b1156c75e0c98d5855b88fb786" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ssl_context&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; used for this connection. Required. Usually created by calling &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt;&lt;code&gt;ssl.create_default_context()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ssl_context&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 이 연결에 사용 된 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt; 입니다. 필수입니다. 일반적으로 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt; &lt;code&gt;ssl.create_default_context()&lt;/code&gt; &lt;/a&gt; 를 호출하여 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="1ab419f61b2ec42100b332c8c5e546b3e229c548" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ssl_context&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The SSL context to use for all incoming connections.</source>
          <target state="translated">&lt;code&gt;ssl_context&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 들어오는 모든 연결에 사용할 SSL 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="7755b90b4b9fc8ce6579cc8ad4420b411fd8ae29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ssl_context&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The SSL context to use for all incoming connections. Passed to &lt;a href=&quot;#trio.open_ssl_over_tcp_listeners&quot;&gt;&lt;code&gt;open_ssl_over_tcp_listeners()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ssl_context&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;em&gt;SSLContext&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 들어오는 모든 연결에 사용할 SSL 컨텍스트입니다. &lt;a href=&quot;#trio.open_ssl_over_tcp_listeners&quot;&gt; &lt;code&gt;open_ssl_over_tcp_listeners()&lt;/code&gt; &lt;/a&gt; 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="47ae01c666f68b1ba6200b2b9ccda68490f6c9ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stderr&lt;/code&gt; &amp;ndash; Like &lt;code&gt;stdin&lt;/code&gt;, but for the child process&amp;rsquo;s standard error stream. An additional value &lt;code&gt;subprocess.STDOUT&lt;/code&gt; is supported, which causes the child&amp;rsquo;s standard output and standard error messages to be intermixed on a single standard output stream, attached to whatever the &lt;code&gt;stdout&lt;/code&gt; option says to attach it to.</source>
          <target state="translated">&lt;code&gt;stderr&lt;/code&gt; &amp;ndash; &lt;code&gt;stdin&lt;/code&gt; 과 유사 하지만 하위 프로세스의 표준 오류 스트림 추가 값 &lt;code&gt;subprocess.STDOUT&lt;/code&gt; 이 지원되어 표준 표준 출력 스트림에서 하위 표준 출력 및 표준 오류 메시지가 혼합되어 &lt;code&gt;stdout&lt;/code&gt; 옵션에 첨부 된 내용에 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="c233d6ac159ddccb9de47ea18b335506c1a26ee1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stdin&lt;/code&gt; &amp;ndash; Specifies what the child process&amp;rsquo;s standard input stream should connect to: output written by the parent (&lt;code&gt;subprocess.PIPE&lt;/code&gt;), nothing (&lt;code&gt;subprocess.DEVNULL&lt;/code&gt;), or an open file (pass a file descriptor or something whose &lt;code&gt;fileno&lt;/code&gt; method returns one). If &lt;code&gt;stdin&lt;/code&gt; is unspecified, the child process will have the same standard input stream as its parent.</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; &amp;ndash; 하위 프로세스의 표준 입력 스트림에 연결해야하는 대상을 지정합니다. 상위 ( &lt;code&gt;subprocess.PIPE&lt;/code&gt; )에 의해 작성된 출력 , 아무것도 없음 ( &lt;code&gt;subprocess.DEVNULL&lt;/code&gt; ) 또는 열린 파일 (파일 설명자 또는 &lt;code&gt;fileno&lt;/code&gt; 메소드가 1을 리턴 하는 파일 전달 ). &lt;code&gt;stdin&lt;/code&gt; 을 지정하지 않으면 하위 프로세스는 상위 프로세스와 동일한 표준 입력 스트림을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="68f9d2012a908ef5a582d735d8be7fe63553ac43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stdin&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, file descriptor, or None) &amp;ndash; The bytes to provide to the subprocess on its standard input stream, or &lt;code&gt;None&lt;/code&gt; if the subprocess&amp;rsquo;s standard input should come from the same place as the parent Trio process&amp;rsquo;s standard input. As is the case with the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; module, you can also pass a file descriptor or an object with a &lt;code&gt;fileno()&lt;/code&gt; method, in which case the subprocess&amp;rsquo;s standard input will come from that file.</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; , file descriptor 또는 None) &amp;ndash; 표준 입력 스트림에서 서브 프로세스에 제공 할 바이트 또는 서브 프로세스의 표준 입력이 상위 Trio 프로세스의 표준 입력과 같은 위치에서 오는 경우 &lt;code&gt;None&lt;/code&gt; 입니다. &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 모듈 의 경우와 같이 &lt;code&gt;fileno()&lt;/code&gt; 메소드를 사용 하여 파일 디스크립터 또는 오브젝트를 전달할 수도 있습니다 .이 경우 서브 프로세스의 표준 입력은 해당 파일에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e980d52d16fce215767351c556fb552a1d5bffb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stdout&lt;/code&gt; &amp;ndash; Like &lt;code&gt;stdin&lt;/code&gt;, but for the child process&amp;rsquo;s standard output stream.</source>
          <target state="translated">&lt;code&gt;stdout&lt;/code&gt; &amp;ndash; &lt;code&gt;stdin&lt;/code&gt; 과 유사 하지만 하위 프로세스의 표준 출력 스트림 용</target>
        </trans-unit>
        <trans-unit id="5307a9d2c47f82bfe292dd0f7ce82f7c44754b75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stream_maker&lt;/code&gt; &amp;ndash; An async (!) function which returns a connected (&lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;) pair.</source>
          <target state="translated">&lt;code&gt;stream_maker&lt;/code&gt; &amp;ndash; 연결된 ( &lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; ) 쌍 을 반환하는 비동기 (!) 함수</target>
        </trans-unit>
        <trans-unit id="dbaffedf99c9721b690ce581e56db550d6d1ce43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sync_fn&lt;/code&gt; &amp;ndash; An arbitrary synchronous callable.</source>
          <target state="translated">&lt;code&gt;sync_fn&lt;/code&gt; &amp;ndash; 임의의 동기 호출 가능.</target>
        </trans-unit>
        <trans-unit id="0478602722f26cd556aa77b98959d5d47941b3ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The Trio task object that the current coroutine was detached from.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; ( &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;Task&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 현재 코 루틴이 분리 된 Trio 작업 개체입니다.</target>
        </trans-unit>
        <trans-unit id="b8540abdbca36847f75a769a7abd2d0aeb3a94bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The finished task.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; ( &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 완료된 작업.</target>
        </trans-unit>
        <trans-unit id="9fe76481d8eeaa8a4dbfc030b4847cce9b1efec0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The new task.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; ( &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 새로운 작업.</target>
        </trans-unit>
        <trans-unit id="d8ba5f2e7e8869d83cfd9584d7d5035aefd3d68c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The task that became runnable.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; ( &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 실행 가능한 태스크입니다.</target>
        </trans-unit>
        <trans-unit id="e010b6c5f0a9add2aefa00fbb0bedba0ed588d62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The task that is about to run.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; ( &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 실행하려는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="0e0338010b8d26f21da19458356f1578f75bde21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The task that just ran.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; ( &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 방금 실행 한 작업.</target>
        </trans-unit>
        <trans-unit id="7c992fd8856aef4de8e76153f474f4c8723fe894" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the task to be rescheduled. Must be blocked in a call to &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; ( &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;em&gt;trio.hazmat.Task&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 다시 예약 할 작업. &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 에 대한 호출에서 차단되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ab9f0dc40b06c1755bae71e19f62fba5efe69ec5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;em&gt;Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The Trio task object that the current coroutine was detached from.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; ( &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;em&gt;Task&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 현재 코 루틴이 분리 된 Trio 작업 객체입니다.</target>
        </trans-unit>
        <trans-unit id="d2766870b5e6c135f54c4e0fe1836d65f536efdb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;em&gt;trio.lowlevel.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The finished task.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; ( &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;em&gt;trio.lowlevel.Task&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 완료된 작업입니다.</target>
        </trans-unit>
        <trans-unit id="073403ff589ee4f9a48f91eb027a985065f24f15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;em&gt;trio.lowlevel.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The new task.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; ( &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;em&gt;trio.lowlevel.Task&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 새 작업입니다.</target>
        </trans-unit>
        <trans-unit id="5e9f711b23296d103231f860b14eec9c55911f91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;em&gt;trio.lowlevel.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The task that became runnable.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; ( &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;em&gt;trio.lowlevel.Task&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 실행 가능하게 된 작업.</target>
        </trans-unit>
        <trans-unit id="29f37b51afb26b138f587a28cdf1629ac1aa6053" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;em&gt;trio.lowlevel.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The task that is about to run.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; ( &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;em&gt;trio.lowlevel.Task&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; &lt;em&gt;곧&lt;/em&gt; 실행될 작업.</target>
        </trans-unit>
        <trans-unit id="6f7cb49ed7ffa105d8ae7cbafaf0b96ec09538e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;em&gt;trio.lowlevel.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The task that just ran.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; ( &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;em&gt;trio.lowlevel.Task&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 방금 실행 한 작업.</target>
        </trans-unit>
        <trans-unit id="7899615fb1149ca45c5c86bf42d8785e4baf07bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; (&lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;em&gt;trio.lowlevel.Task&lt;/em&gt;&lt;/a&gt;) &amp;ndash; the task to be rescheduled. Must be blocked in a call to &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; ( &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;em&gt;trio.lowlevel.Task&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 다시 예약 할 작업입니다. &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 호출에서 차단되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0ae78f69e427f390674360603ae4a398cb896dc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task_status&lt;/code&gt; &amp;ndash; This function can be used with &lt;code&gt;nursery.start&lt;/code&gt;, which will return &lt;code&gt;listeners&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;task_status&lt;/code&gt; 은 -이 기능을 사용할 수 있습니다 &lt;code&gt;nursery.start&lt;/code&gt; 돌아갑니다, &lt;code&gt;listeners&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03c2e8a6341af61c1b587cccedca6d25b6d39287" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task_status&lt;/code&gt; &amp;ndash; This function can be used with &lt;code&gt;nursery.start&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;task_status&lt;/code&gt; -이 기능을 사용할 수 있습니다 &lt;code&gt;nursery.start&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea5a3fe7122dd4cee3302c7652c5eb464ad1bdb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_living&lt;/code&gt; (int): The number of tasks that have been spawned and not yet exited.</source>
          <target state="translated">&lt;code&gt;tasks_living&lt;/code&gt; (int) : 생성되었지만 아직 종료되지 않은 작업 수입니다.</target>
        </trans-unit>
        <trans-unit id="739001bea8c2726faa18e2b481895d4d53e1551e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_runnable&lt;/code&gt; (int): The number of tasks that are currently queued on the run queue (as opposed to blocked waiting for something to happen).</source>
          <target state="translated">&lt;code&gt;tasks_runnable&lt;/code&gt; (int) : 현재 실행 큐에 대기중인 작업 수입니다 (일이 발생하기를 기다리는 동안 차단됨).</target>
        </trans-unit>
        <trans-unit id="e37bd999a2be9d0cca34acb9d5d7f7c484e06fb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting&lt;/code&gt;: The number of tasks blocked on this &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;#trio.CapacityLimiter.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.CapacityLimiter.acquire_on_behalf_of&quot;&gt;&lt;code&gt;acquire_on_behalf_of()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">&lt;code&gt;tasks_waiting&lt;/code&gt; :이 &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#trio.CapacityLimiter.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#trio.CapacityLimiter.acquire_on_behalf_of&quot;&gt; &lt;code&gt;acquire_on_behalf_of()&lt;/code&gt; &lt;/a&gt; 메소드에서 차단 된 작업 수입니다 .</target>
        </trans-unit>
        <trans-unit id="fda1f91fcfe6da6aebf6c3579f8a0aea2a69bb4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting&lt;/code&gt;: The number of tasks blocked on this condition&amp;rsquo;s &lt;a href=&quot;#trio.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;tasks_waiting&lt;/code&gt; :이 조건의 &lt;a href=&quot;#trio.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 메소드 에서 차단 된 태스크 수입니다 .</target>
        </trans-unit>
        <trans-unit id="1d6625cb145e1100cf7de52ec9dbb0be655857c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting&lt;/code&gt;: The number of tasks blocked on this event&amp;rsquo;s &lt;a href=&quot;#trio.Event.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;tasks_waiting&lt;/code&gt; :이 이벤트의 &lt;a href=&quot;#trio.Event.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 메소드 에서 차단 된 태스크 수입니다 .</target>
        </trans-unit>
        <trans-unit id="e3ad2f4331209803091e2db33eab0ce1205d0f5b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting&lt;/code&gt;: The number of tasks blocked on this lock&amp;rsquo;s &lt;a href=&quot;#trio.Lock.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;tasks_waiting&lt;/code&gt; :이 잠금의 &lt;a href=&quot;#trio.Lock.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 메소드 에서 차단 된 태스크 수 .</target>
        </trans-unit>
        <trans-unit id="88bbbe67dedd42251a847f6ee743ed43450b6469" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting&lt;/code&gt;: The number of tasks blocked on this lot&amp;rsquo;s &lt;a href=&quot;#trio.hazmat.ParkingLot.park&quot;&gt;&lt;code&gt;park()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;tasks_waiting&lt;/code&gt; :이 로트의 &lt;a href=&quot;#trio.hazmat.ParkingLot.park&quot;&gt; &lt;code&gt;park()&lt;/code&gt; &lt;/a&gt; 메소드 에서 차단 된 작업 수 .</target>
        </trans-unit>
        <trans-unit id="45e49a44c3985a8e1ae2f66e0ef811b629ed75c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting&lt;/code&gt;: The number of tasks blocked on this lot&amp;rsquo;s &lt;a href=&quot;#trio.lowlevel.ParkingLot.park&quot;&gt;&lt;code&gt;park()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;tasks_waiting&lt;/code&gt; :이 부지의 &lt;a href=&quot;#trio.lowlevel.ParkingLot.park&quot;&gt; &lt;code&gt;park()&lt;/code&gt; &lt;/a&gt; 메서드 에서 차단 된 작업 수입니다 .</target>
        </trans-unit>
        <trans-unit id="18db8acf9a54103d76ab78ccb127f37723ab2017" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting&lt;/code&gt;: The number of tasks blocked on this semaphore&amp;rsquo;s &lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;tasks_waiting&lt;/code&gt; :이 세마포어의 &lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 메소드 에서 차단 된 작업 수 .</target>
        </trans-unit>
        <trans-unit id="92e56ab1340f6bde5ee56f317abacbf5eef96b0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting_receive&lt;/code&gt;: The number of tasks blocked in &lt;code&gt;receive&lt;/code&gt; on this channel (summing over all clones).</source>
          <target state="translated">&lt;code&gt;tasks_waiting_receive&lt;/code&gt; : 이 채널 에서 &lt;code&gt;receive&lt;/code&gt; 이 차단 된 작업 수 (모든 클론에 대해 합산).</target>
        </trans-unit>
        <trans-unit id="0743f953431a2d7039e1416f4aef32455fe417ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tasks_waiting_send&lt;/code&gt;: The number of tasks blocked in &lt;code&gt;send&lt;/code&gt; on this channel (summing over all clones).</source>
          <target state="translated">&lt;code&gt;tasks_waiting_send&lt;/code&gt; : 이 채널 에서 &lt;code&gt;send&lt;/code&gt; 에서 차단 된 작업 수 (모든 클론에 대해 합산).</target>
        </trans-unit>
        <trans-unit id="b0cd806769a469c3eb7d185d3d55b124c346a956" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The number of seconds we are willing to wait.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 기다릴 시간 ( 초)입니다.</target>
        </trans-unit>
        <trans-unit id="6772102160e6a83ff561040a822f5e931e792a0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The number of seconds we were willing to wait. This much time may or may not have elapsed, depending on whether any I/O was ready.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;em&gt;float&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 기다릴 시간 ( 초)입니다. I / O가 준비되었는지 여부에 따라이 많은 시간이 경과했거나 경과하지 않았을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f8da86bd9fc94c0ef68f668c12ad19f82b44ae2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;total_tokens&lt;/code&gt;: The total number of tokens in the sack. Usually this will be larger than &lt;code&gt;borrowed_tokens&lt;/code&gt;, but it&amp;rsquo;s possibly for it to be smaller if &lt;a href=&quot;#trio.CapacityLimiter.total_tokens&quot;&gt;&lt;code&gt;total_tokens&lt;/code&gt;&lt;/a&gt; was recently decreased.</source>
          <target state="translated">&lt;code&gt;total_tokens&lt;/code&gt; : 자루의 총 토큰 수입니다. 일반적으로이보다 더 큰 것 &lt;code&gt;borrowed_tokens&lt;/code&gt; 하지만 경우가 작게에 대한 가능성의 &lt;a href=&quot;#trio.CapacityLimiter.total_tokens&quot;&gt; &lt;code&gt;total_tokens&lt;/code&gt; 이&lt;/a&gt; 최근 감소 하였다.</target>
        </trans-unit>
        <trans-unit id="721ef0f3e300e7cf8f0edc1509d146331ba8b835" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transport_listener&lt;/code&gt; (&lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;em&gt;Listener&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The listener whose incoming connections will be wrapped in &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;transport_listener&lt;/code&gt; ( &lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;em&gt;리스너&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 수신 연결이 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 으로 랩핑되는 리스너 입니다.</target>
        </trans-unit>
        <trans-unit id="3ed9c34eae37c5affb57d8b6c4c9bf845d60f0ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;transport_stream&lt;/code&gt; (&lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;em&gt;Stream&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The stream used to transport encrypted data. Required.</source>
          <target state="translated">&lt;code&gt;transport_stream&lt;/code&gt; ( &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;em&gt;Stream&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 암호화 된 데이터를 전송하는 데 사용되는 스트림입니다. 필수입니다.</target>
        </trans-unit>
        <trans-unit id="3dd6532c01255f0b97ed0d038d5e4c93bf4f8295" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#object&quot;&gt;&lt;em&gt;object&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The object to send.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#object&quot;&gt;&lt;em&gt;object&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 전송할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="37cab4c9f0aba80ee1245aa0200db8f3d11b2ff6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wait_send_all_might_not_block_hook&lt;/code&gt; &amp;ndash; An async function, or None. Called from &lt;a href=&quot;#trio.testing.MemorySendStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt;. Can do whatever you like.</source>
          <target state="translated">&lt;code&gt;wait_send_all_might_not_block_hook&lt;/code&gt; &amp;ndash; 비동기 함수 또는 없음 &lt;a href=&quot;#trio.testing.MemorySendStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt; 에서 호출됩니다 . 원하는대로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3286b37b0ab654001d8174fc1c05a0b46882511" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield_value&lt;/code&gt; (&lt;a href=&quot;https://docs.python.org/3/library/functions.html#object&quot;&gt;&lt;em&gt;object&lt;/em&gt;&lt;/a&gt;) &amp;ndash; The object to yield to the current coroutine runner.</source>
          <target state="translated">&lt;code&gt;yield_value&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3/library/functions.html#object&quot;&gt;&lt;em&gt;object&lt;/em&gt;&lt;/a&gt; ) &amp;ndash; 현재 코 루틴 러너에게 산출 할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="e5296fdbf5d6b180a8671cf7d7109308b00db56b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Channels&lt;/em&gt; allow you to safely and conveniently send objects between different tasks. They&amp;rsquo;re particularly useful for implementing producer/consumer patterns.</source>
          <target state="translated">&lt;em&gt;채널을&lt;/em&gt; 사용하면 서로 다른 작업간에 개체를 안전하고 편리하게 보낼 수 있습니다. 생산자 / 소비자 패턴을 구현하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="eca91e08a24f38ddbaffe627fc1ea7890d9eef8a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fd&lt;/em&gt; must refer to a file that is open for reading and/or writing and supports non-blocking I/O (pipes and TTYs will work, on-disk files probably not). The returned stream takes ownership of the fd, so closing the stream will close the fd too. As with &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.fdopen&quot;&gt;&lt;code&gt;os.fdopen&lt;/code&gt;&lt;/a&gt;, you should not directly use an fd after you have wrapped it in a stream using this function.</source>
          <target state="translated">&lt;em&gt;fd&lt;/em&gt; 는 읽기 및 / 또는 쓰기를 위해 열려 있고 비 차단 I / O를 지원하는 파일을 참조해야합니다 (파이프 및 TTY는 작동하지만 디스크 파일은 작동하지 않을 수 있음). 리턴 된 스트림은 fd의 소유권을 가지므로 스트림을 닫으면 fd도 닫힙니다. &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.fdopen&quot;&gt; &lt;code&gt;os.fdopen&lt;/code&gt; &lt;/a&gt; 과 마찬가지로이 함수를 사용하여 스트림에 fd를 감싼 후에는 fd를 직접 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="02382303cb8dcce30be9f32d2ad15b0759eb085e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A small optimization:&lt;/strong&gt; Finally, consider a small optimization. Some event loops offer two versions of their &amp;ldquo;call this function soon&amp;rdquo; API: one that can be used from any thread, and one that can only be used from the event loop thread, with the latter being cheaper. For example, asyncio has both &lt;a href=&quot;https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.call_soon_threadsafe&quot;&gt;&lt;code&gt;call_soon_threadsafe&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.call_soon&quot;&gt;&lt;code&gt;call_soon&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;작은 최적화 :&lt;/strong&gt; 마지막으로 &lt;strong&gt;작은 최적화를&lt;/strong&gt; 고려하십시오. 일부 이벤트 루프는 &quot;곧이 함수 호출&quot;API의 두 가지 버전을 제공합니다. 하나는 모든 스레드에서 사용할 수 있고 다른 하나는 이벤트 루프 스레드에서만 사용할 수 있으며 후자는 더 저렴합니다. 예를 들어 asyncio에는 &lt;a href=&quot;https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.call_soon_threadsafe&quot;&gt; &lt;code&gt;call_soon_threadsafe&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.call_soon&quot;&gt; &lt;code&gt;call_soon&lt;/code&gt; &lt;/a&gt; 이 모두 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a449a1116492e7a682dcafdf8f3b0e17dad5450" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cancellation handling&lt;/strong&gt;: Cancellation is a tricky issue here, because neither Python nor the operating systems it runs on provide any general mechanism for cancelling an arbitrary synchronous function running in a thread. This function will always check for cancellation on entry, before starting the thread. But once the thread is running, there are two ways it can handle being cancelled:</source>
          <target state="translated">&lt;strong&gt;취소 처리&lt;/strong&gt; : 파이썬이나 운영 체제가 스레드에서 실행중인 임의의 동기 함수를 취소하는 일반적인 메커니즘을 제공하지 않기 때문에 취소는 까다로운 문제입니다. 이 기능은 스레드를 시작하기 전에 항상 입력 취소를 확인합니다. 그러나 스레드가 실행되면 취소를 처리 할 수있는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4033660c96d382fe67327d68e57a52697f397ff3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Error checking:&lt;/strong&gt; If the subprocess exits with a nonzero status code, indicating failure, &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process()&lt;/code&gt;&lt;/a&gt; raises a &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError&quot;&gt;&lt;code&gt;subprocess.CalledProcessError&lt;/code&gt;&lt;/a&gt; exception rather than returning normally. The captured outputs are still available as the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; attributes of that exception. To disable this behavior, so that &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process()&lt;/code&gt;&lt;/a&gt; returns normally even if the subprocess exits abnormally, pass &lt;code&gt;check=False&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;오류 검사 :&lt;/strong&gt; 하위 프로세스가 실패를 나타내는 0이 아닌 상태 코드로 종료되면 &lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process()&lt;/code&gt; &lt;/a&gt; 는 정상적으로 반환되지 않고 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError&quot;&gt; &lt;code&gt;subprocess.CalledProcessError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다. 캡처 된 출력은 해당 예외 의 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; 속성 으로 계속 사용할 수 있습니다 . 하위 프로세스가 비정상적으로 종료 되더라도 &lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process()&lt;/code&gt; &lt;/a&gt; 가 정상적으로 리턴 되도록이 동작을 사용하지 않으려면 &lt;code&gt;check=False&lt;/code&gt; 를 전달 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7584fad9f91f0543d6e865c520ddc4313945f162" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Getting started:&lt;/strong&gt; The first step is to get something basic working. Here&amp;rsquo;s a minimal example of running Trio on top of asyncio, that you can use as a model:</source>
          <target state="translated">&lt;strong&gt;시작하기 :&lt;/strong&gt; 첫 번째 단계는 기본적인 작업을 수행하는 것입니다. 다음은 모델로 사용할 수있는 asyncio 위에서 Trio를 실행하는 최소한의 예입니다.</target>
        </trans-unit>
        <trans-unit id="289917c607cf1cbd1dadecced88ba530f15b1d0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you&amp;rsquo;re not sure what to do, then we recommend that you use async disk I/O by default,&lt;/strong&gt; because it makes your code more robust when conditions are bad, especially with regards to tail latencies; this improves the chances that what your users see matches what you saw in testing. Blocking the main thread stops &lt;em&gt;all&lt;/em&gt; tasks from running for that time. 10,000 &amp;micro;s is 10 ms, and it doesn&amp;rsquo;t take many 10 ms glitches to start adding up to &lt;a href=&quot;https://google.com/search?q=latency+cost&quot;&gt;real money&lt;/a&gt;; async disk I/O can help prevent those. Just don&amp;rsquo;t expect it to be magic, and be aware of the tradeoffs.</source>
          <target state="translated">&lt;strong&gt;수행 할 작업이 확실하지 않은 경우 기본적으로 비동기 디스크 I / O를 사용하는 것이 좋습니다. 비동기&lt;/strong&gt; 테일 &lt;strong&gt;I / O&lt;/strong&gt; 는 특히 테일 대기 시간과 관련하여 조건이 나쁠 때 코드를 더욱 강력하게하기 때문입니다. 이렇게하면 사용자가 보는 것이 테스트에서 본 것과 일치 할 가능성이 높아집니다. 메인 스레드를 차단하면 해당 시간 동안 &lt;em&gt;모든&lt;/em&gt; 작업이 실행되지 않습니다 . 10,000 &amp;micro;s는 10ms이며 &lt;a href=&quot;https://google.com/search?q=latency+cost&quot;&gt;실제 돈을&lt;/a&gt; 더하기 위해 많은 10ms의 글리치가 필요하지 않습니다 . 비동기 디스크 I / O는이를 방지 할 수 있습니다. 마법이 될 것으로 기대하지 말고 트레이드 오프를 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ec61bac9cf0621f9189209568ab5b25a5e169125" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Input:&lt;/strong&gt; The subprocess&amp;rsquo;s standard input stream is set up to receive the bytes provided as &lt;code&gt;stdin&lt;/code&gt;. Once the given input has been fully delivered, or if none is provided, the subprocess will receive end-of-file when reading from its standard input. Alternatively, if you want the subprocess to read its standard input from the same place as the parent Trio process, you can pass &lt;code&gt;stdin=None&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;입력 :&lt;/strong&gt; 서브 프로세스의 표준 입력 스트림은 &lt;code&gt;stdin&lt;/code&gt; 으로 제공된 바이트를 수신하도록 설정됩니다 . 제공된 입력이 완전히 전달되거나 제공되지 않은 경우 표준 입력에서 읽을 때 서브 프로세스는 파일 끝을 수신합니다. 또는 하위 프로세스가 상위 Trio 프로세스와 동일한 위치에서 표준 입력을 읽도록하려면 &lt;code&gt;stdin=None&lt;/code&gt; 을 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23eb20482732e41e1dcfc558eb1f0c5909afb9bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Locating a Trio Token&lt;/strong&gt;: There are two ways to specify which &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt; loop to reenter:</source>
          <target state="translated">&lt;strong&gt;트리오 토큰 찾기&lt;/strong&gt; : 재 입력 할 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run&lt;/code&gt; &lt;/a&gt; 루프를 지정하는 두 가지 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3002a16ba291a6c347f1b9abc2249f5db2a3b34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Loop lifetimes:&lt;/strong&gt; One of the trickiest things in most event loops is shutting down correctly. And having two event loops makes this even harder!</source>
          <target state="translated">&lt;strong&gt;루프 수명 :&lt;/strong&gt; 대부분의 이벤트 루프에서 가장 까다로운 것 중 하나는 올바르게 종료하는 것입니다. 두 개의 이벤트 루프가 있으면이 작업이 더욱 어려워집니다!</target>
        </trans-unit>
        <trans-unit id="ade3e064f41faa18672b1500d3135b5e95f57be0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output:&lt;/strong&gt; By default, any output produced by the subprocess is passed through to the standard output and error streams of the parent Trio process. If you would like to capture this output and do something with it, you can pass &lt;code&gt;capture_stdout=True&lt;/code&gt; to capture the subprocess&amp;rsquo;s standard output, and/or &lt;code&gt;capture_stderr=True&lt;/code&gt; to capture its standard error. Captured data is provided as the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; attributes of the returned &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;CompletedProcess&lt;/code&gt;&lt;/a&gt; object. The value for any stream that was not captured will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;출력 :&lt;/strong&gt; 기본적으로 하위 프로세스에서 생성 된 모든 출력은 상위 Trio 프로세스의 표준 출력 및 오류 스트림으로 전달됩니다. 이 출력을 캡처하고 무언가를 수행하려면 &lt;code&gt;capture_stdout=True&lt;/code&gt; 를 전달 하여 하위 프로세스의 표준 출력 을 캡처 하거나 &lt;code&gt;capture_stderr=True&lt;/code&gt; 를 사용하여 표준 오류를 캡처 할 수 있습니다. 캡처 된 데이터는 리턴 된 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;CompletedProcess&lt;/code&gt; &lt;/a&gt; 오브젝트 의 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 및 / 또는 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; 속성으로 제공됩니다 . 캡처되지 않은 스트림의 값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2dbf6c5cdaeba1746ec4cdda3a4f2cbca23ddfc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pluggable IO backends:&lt;/strong&gt; this is where you reimplement one of the event loop APIs on top of the other, so you effectively end up with just one event loop. This requires a significant amount of work for each pair of event loops you want to integrate, and different backends inevitably end up with inconsistent behavior, forcing users to program against the least-common-denominator. And if the two event loops expose different feature sets, it may not even be possible to implement one in terms of the other.</source>
          <target state="translated">&lt;strong&gt;플러그 형 IO 백엔드 :&lt;/strong&gt; 여기에서 이벤트 루프 API 중 하나를 다른 것 위에 다시 구현하므로 효과적으로 단 하나의 이벤트 루프로 끝납니다. 이를 위해서는 통합하려는 각 이벤트 루프 쌍에 대해 상당한 양의 작업이 필요하며, 서로 다른 백엔드는 필연적으로 일관성이없는 동작으로 끝나므로 사용자가 최소 공통 분모에 대해 프로그래밍해야합니다. 두 이벤트 루프가 서로 다른 기능 세트를 노출하는 경우 하나를 다른 기능으로 구현하는 것이 불가능할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8ae34f641451ece6f087b9a8f059420d1c5fda0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Polling:&lt;/strong&gt; this is where you use a &lt;a href=&quot;https://en.wikipedia.org/wiki/Busy_waiting&quot;&gt;busy-loop&lt;/a&gt; to manually check for IO on both event loops many times per second. This adds latency, and wastes CPU time and electricity.</source>
          <target state="translated">&lt;strong&gt;폴링 :&lt;/strong&gt; 사용 &lt;a href=&quot;https://en.wikipedia.org/wiki/Busy_waiting&quot;&gt;중인 루프&lt;/a&gt; 를 사용하여 초당 여러 번 두 이벤트 루프에서 IO를 수동으로 확인하는 곳입니다. 이로 인해 대기 시간이 추가되고 CPU 시간과 전기가 낭비됩니다.</target>
        </trans-unit>
        <trans-unit id="02f4eb2afa5e2ff10b7adc63478877bbbab4a506" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Running the two event loops in separate threads:&lt;/strong&gt; This works, but most event loop APIs aren&amp;rsquo;t thread-safe, so in this approach you need to keep careful track of which code runs on which event loop, and remember to use explicit inter-thread messaging whenever you interact with the other loop &amp;ndash; or else risk obscure race conditions and data corruption.</source>
          <target state="translated">&lt;strong&gt;별도의 스레드에서 두 개의 이벤트 루프 실행 :&lt;/strong&gt; 작동하지만 대부분의 이벤트 루프 API는 스레드로부터 안전하지 않습니다. 따라서이 접근 방식에서는 어떤 코드가 어떤 이벤트 루프에서 실행되는지주의 깊게 추적해야하며 명시 적 inter- 다른 루프와 상호 작용할 때마다 스레드 메시징이 발생합니다. 그렇지 않으면 모호한 경쟁 조건과 데이터 손상의 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5524f8fa0eff1660c474fd00a302021ab2e9abad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Signal management:&lt;/strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Signal_(IPC)&quot;&gt;&amp;ldquo;Signals&amp;rdquo;&lt;/a&gt; are a low-level inter-process communication primitive. When you hit control-C to kill a program, that uses a signal. Signal handling in Python has &lt;a href=&quot;https://vorpus.org/blog/control-c-handling-in-python-and-trio/&quot;&gt;a lot of moving parts&lt;/a&gt;. One of those parts is &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt;&lt;code&gt;signal.set_wakeup_fd&lt;/code&gt;&lt;/a&gt;, which event loops use to make sure that they wake up when a signal arrives so they can respond to it. (If you&amp;rsquo;ve ever had an event loop ignore you when you hit control-C, it was probably because they weren&amp;rsquo;t using &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt;&lt;code&gt;signal.set_wakeup_fd&lt;/code&gt;&lt;/a&gt; correctly.)</source>
          <target state="translated">&lt;strong&gt;신호 관리 : &lt;/strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Signal_(IPC)&quot;&gt;&quot;신호&quot;&lt;/a&gt; 는 낮은 수준의 프로세스 간 통신 기본 요소입니다. Ctrl-C를 눌러 프로그램을 죽이면 신호를 사용합니다. 파이썬의 신호 처리 &lt;a href=&quot;https://vorpus.org/blog/control-c-handling-in-python-and-trio/&quot;&gt;에는 많은 부분이&lt;/a&gt; 있습니다. 이러한 부분 중 하나는 &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt; &lt;code&gt;signal.set_wakeup_fd&lt;/code&gt; &lt;/a&gt; 이며, 이벤트 루프는 신호가 도착할 때 깨어나서 응답 할 수 있도록하는 데 사용합니다. (만약 당신이 control-C를 눌렀을 때 이벤트 루프가 당신을 무시한 적이 있다면 아마도 그들이 &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt; &lt;code&gt;signal.set_wakeup_fd&lt;/code&gt; 를&lt;/a&gt; 올바르게 사용하지 않았기 때문일 것입니다.)</target>
        </trans-unit>
        <trans-unit id="cbb197b3ed5b21d6850b4b2a58d709428c2897e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;: you should set &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt;&lt;code&gt;autojump_threshold&lt;/code&gt;&lt;/a&gt; to be at least as large as the largest cushion you plan to pass to &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;요약&lt;/strong&gt; : &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt; &lt;code&gt;autojump_threshold&lt;/code&gt; &lt;/a&gt; 를 &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt; &lt;/a&gt; 에 전달할 가장 큰 쿠션만큼 크게 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4619f53b1f5b998b83c70bbba4b02cfcb156ddb8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;That&amp;rsquo;s it!&lt;/strong&gt; If you&amp;rsquo;ve followed all these steps, you should now have a cleanly-integrated hybrid event loop. Go make some cool GUIs/games/whatever!</source>
          <target state="translated">&lt;strong&gt;그게 다야! &lt;/strong&gt;이 모든 단계를 따랐다면 이제 깔끔하게 통합 된 하이브리드 이벤트 루프가 생겼을 것입니다. 멋진 GUI / 게임 / 무엇이든 만들어보세요!</target>
        </trans-unit>
        <trans-unit id="9a93be6ab8e66c257afb2ac1fd8e3333d8c144f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why do we even support unbounded buffers then?&lt;/strong&gt; Good question! Despite everything we saw above, there are times when you actually do need an unbounded buffer. For example, consider a web crawler that uses a channel to keep track of all the URLs it still wants to crawl. Each crawler runs a loop where it takes a URL from the channel, fetches it, checks the HTML for outgoing links, and then adds the new URLs to the channel. This creates a &lt;em&gt;circular flow&lt;/em&gt;, where each consumer is also a producer. In this case, if your channel buffer gets full, then the crawlers will block when they try to add new URLs to the channel, and if all the crawlers got blocked, then they aren&amp;rsquo;t taking any URLs out of the channel, so they&amp;rsquo;re stuck forever in a deadlock. Using an unbounded channel avoids this, because it means that &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; never blocks.</source>
          <target state="translated">&lt;strong&gt;우리는 왜 언 바운드 버퍼를 지원합니까? &lt;/strong&gt;좋은 질문! 위에서 본 모든 내용에도 불구하고 실제로 무제한 버퍼가 필요한 경우가 있습니다. 예를 들어, 채널을 사용하여 여전히 크롤링하려는 모든 URL을 추적하는 웹 크롤러를 고려하십시오. 각 크롤러는 루프를 실행하여 채널에서 URL을 가져 와서 가져오고 HTML에서 발신 링크를 확인한 다음 새 URL을 채널에 추가합니다. 이것은 &lt;em&gt;순환 흐름을&lt;/em&gt; 만듭니다&lt;em&gt;&lt;/em&gt;각 소비자는 생산자이기도합니다. 이 경우 채널 버퍼가 가득 차면 새 URL을 채널에 추가하려고 할 때 크롤러가 차단되며 모든 크롤러가 차단되면 채널에서 URL을 가져 오지 않으므로 교착 상태에 영원히 붙어 있습니다. 무제한 채널을 사용하면 &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt; 절대로 차단되지 않기 때문에이를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba17e75312d3a3fef4667eba4bf8669e735df78a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You must let the Trio program run to completion.&lt;/strong&gt; Many event loops let you stop the event loop at any point, and any pending callbacks/tasks/etc. just&amp;hellip; don&amp;rsquo;t run. Trio follows a more structured system, where you can cancel things, but the code always runs to completion, so &lt;code&gt;finally&lt;/code&gt; blocks run, resources are cleaned up, etc. If you stop your host loop early, before the &lt;code&gt;done_callback&lt;/code&gt; is invoked, then that cuts off the Trio run in the middle without a chance to clean up. This can leave your code in an inconsistent state, and will definitely leave Trio&amp;rsquo;s internals in an inconsistent state, which will cause errors if you try to use Trio again in that thread.</source>
          <target state="translated">&lt;strong&gt;Trio 프로그램이 완료 될 때까지 실행해야합니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ&lt;/strong&gt; 많은 이벤트 루프를 사용하면 언제든지 이벤트 루프와 보류중인 콜백 / 작업 등을 중지 할 수 있습니다. 그냥 ... 뛰지 마세요. Trio는 작업을 취소 할 수 있지만 코드는 항상 완료 될 때까지 실행되는보다 구조화 된 시스템을 따릅니다. 따라서 &lt;code&gt;finally&lt;/code&gt; 블록이 실행되고 리소스가 정리됩니다. &lt;code&gt;done_callback&lt;/code&gt; 이 호출 되기 전에 호스트 루프를 일찍 중지하면 정리할 기회없이 중간에 트리오를 실행합니다. 이로 인해 코드가 일관되지 않은 상태가 될 수 있으며 Trio의 내부가 일관되지 않은 상태로 남게됩니다.이 경우 해당 스레드에서 Trio를 다시 사용하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="61c1f9736d24eb4a5f410bfc1a0e81ddee3b2303" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; becomes associated with some cancellable work when it is used as a context manager surrounding that work:</source>
          <target state="translated">&lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; 는&lt;/a&gt; 그것이 그 작업을 둘러싸는 콘텍스트 관리자로서 사용되는 일부 취소 할 작업과 연관된다 :</target>
        </trans-unit>
        <trans-unit id="a0510c2529df08b033b6321c0cd65ef6eedc4913" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; object can be used as an async context manager to acquire the underlying lock; it blocks on entry but not on exit.</source>
          <target state="translated">&lt;a href=&quot;#trio.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 객체 기본 잠금을 획득하려고 비동기 콘텍스트 관리자로서 사용될 수있다; 진입시 차단하지만 종료시 차단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1612df0d1097f5f2b176bcdf71abac20673f554" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; object can be used as an async context manager; it blocks on entry but not on exit.</source>
          <target state="translated">&lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 객체는 비동기 컨텍스트 관리자로 사용할 수 있습니다; 진입시 차단하지만 종료시 차단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e7aa4ad7cc8923cf4918bb861708c0d650fa365" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.Semaphore&quot;&gt;&lt;code&gt;Semaphore&lt;/code&gt;&lt;/a&gt; object can be used as an async context manager; it blocks on entry but not on exit.</source>
          <target state="translated">&lt;a href=&quot;#trio.Semaphore&quot;&gt; &lt;code&gt;Semaphore&lt;/code&gt; &lt;/a&gt; 객체는 비동기 콘텍스트 관리자로서 사용될 수있다; 진입시 차단하지만 종료시 차단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2225f74cfd04c73fc7aee7e342aaa8719e9fe2d8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.abc.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is an object that implements both the &lt;a href=&quot;#trio.abc.SendChannel&quot;&gt;&lt;code&gt;SendChannel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;ReceiveChannel&lt;/code&gt;&lt;/a&gt; interfaces, so you can both send and receive objects.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt; 객체입니다 구현 모두 &lt;a href=&quot;#trio.abc.SendChannel&quot;&gt; &lt;code&gt;SendChannel&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;ReceiveChannel&lt;/code&gt; &lt;/a&gt; 인터페이스, 당신이 모두 전송을 할 수와 개체를받을 수 있도록.</target>
        </trans-unit>
        <trans-unit id="d210e54abe986047092d797dd411bd7168065d1c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;code&gt;Listener&lt;/code&gt;&lt;/a&gt; for SSL/TLS-encrypted servers.</source>
          <target state="translated">SSL / TLS 암호화 서버 의 &lt;a href=&quot;#trio.abc.Listener&quot;&gt; &lt;code&gt;Listener&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="625e56299f375edf78936391d427832e256f3e3c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;code&gt;Listener&lt;/code&gt;&lt;/a&gt; that uses a listening socket to accept incoming connections as &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.Listener&quot;&gt; &lt;code&gt;Listener&lt;/code&gt; &lt;/a&gt; 로 들어오는 연결을 허용하도록 청취 소켓을 사용 &lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; 이&lt;/a&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="c7bf989c710ce969c51f1aa9b39c8b49c0a3cd5d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; is an object that implements both the &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt; interfaces.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 객체를 구현하는 양이다 &lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; 인터페이스.</target>
        </trans-unit>
        <trans-unit id="258acf0a9f20fc356fa0b1a9bdbc98d32d8b2654" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object represents a concurrent &amp;ldquo;thread&amp;rdquo; of execution. It has no public constructor; Trio internally creates a &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object for each call to &lt;code&gt;nursery.start(...)&lt;/code&gt; or &lt;code&gt;nursery.start_soon(...)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 객체는 실행의 동시 &quot;스레드&quot;를 나타냅니다. 공개 생성자가 없습니다. Trio 는 &lt;code&gt;nursery.start(...)&lt;/code&gt; 또는 &lt;code&gt;nursery.start_soon(...)&lt;/code&gt; 호출 할 때마다 내부적으로 &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="54c270ae9d300d04504a0bf2a08c0671ef87834b" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object represents a concurrent &amp;ldquo;thread&amp;rdquo; of execution. It has no public constructor; Trio internally creates a &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object for each call to &lt;code&gt;nursery.start(...)&lt;/code&gt; or &lt;code&gt;nursery.start_soon(...)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.lowlevel.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 객체는 실행의 동시 &quot;스레드&quot;를 나타냅니다. 공용 생성자가 없습니다. Trio 는 &lt;code&gt;nursery.start(...)&lt;/code&gt; 또는 &lt;code&gt;nursery.start_soon(...)&lt;/code&gt; 대한 각 호출에 대해 내부적으로 &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 객체를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="ca7636a2d3c1be65ee986f9b4d165ad21f51d1e5" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path&quot;&gt;&lt;code&gt;pathlib.Path&lt;/code&gt;&lt;/a&gt; wrapper that executes blocking methods in &lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt; 에서 블로킹 메소드를 실행 하는 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path&quot;&gt; &lt;code&gt;pathlib.Path&lt;/code&gt; &lt;/a&gt; 래퍼입니다 .</target>
        </trans-unit>
        <trans-unit id="1b73143bafd8aa0311b134e354003b25e9991581" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;subprocess.CompletedProcess&lt;/code&gt;&lt;/a&gt; instance describing the return code and outputs.</source>
          <target state="translated">리턴 코드 및 출력을 설명 하는 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;subprocess.CompletedProcess&lt;/code&gt; &lt;/a&gt; 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="3be56645eaeb3a24943a947fc261ff21539eecaa" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://en.wikipedia.org/wiki/Semaphore_(programming)&quot;&gt;semaphore&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Semaphore_(programming)&quot;&gt;세마포어&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe7ca899d2980900500c0380ec6e876d53eec217" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;cancellation scope&lt;/em&gt;: the link between a unit of cancellable work and Trio&amp;rsquo;s cancellation system.</source>
          <target state="translated">&lt;em&gt;취소 범위&lt;/em&gt; : 취소 해 작업 단위와 트리오의 취소 시스템 사이의 연결.</target>
        </trans-unit>
        <trans-unit id="5032c512330d88fc246829f10b8a02efcc6498a0" translate="yes" xml:space="preserve">
          <source>A brief tour of Trio&amp;rsquo;s internals</source>
          <target state="translated">Trio의 내부 둘러보기</target>
        </trans-unit>
        <trans-unit id="7d074c399cd96f916fd6ae7cb18a4c9e7ecd005a" translate="yes" xml:space="preserve">
          <source>A checkpoint is two things:</source>
          <target state="translated">체크 포인트는 두 가지입니다.</target>
        </trans-unit>
        <trans-unit id="866f38d604fe1cc0aa45f8909eeb748dc3ad3412" translate="yes" xml:space="preserve">
          <source>A child process. Like &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt;&lt;code&gt;subprocess.Popen&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">자식 프로세스. 마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt; &lt;code&gt;subprocess.Popen&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="da50d5e4a3b8f345208749e9b95ed3c3e12c049e" translate="yes" xml:space="preserve">
          <source>A classic &lt;a href=&quot;https://en.wikipedia.org/wiki/Lock_(computer_science)&quot;&gt;mutex&lt;/a&gt;.</source>
          <target state="translated">고전적인 &lt;a href=&quot;https://en.wikipedia.org/wiki/Lock_(computer_science)&quot;&gt;뮤텍스&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9952ba6442045d780e56a579e1a2d3ed0b1e2bd5" translate="yes" xml:space="preserve">
          <source>A classic &lt;a href=&quot;https://en.wikipedia.org/wiki/Monitor_(synchronization)&quot;&gt;condition variable&lt;/a&gt;, similar to &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Condition&quot;&gt;&lt;code&gt;threading.Condition&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Condition&quot;&gt; &lt;code&gt;threading.Condition&lt;/code&gt; &lt;/a&gt; 과 유사한 클래식 &lt;a href=&quot;https://en.wikipedia.org/wiki/Monitor_(synchronization)&quot;&gt;조건 변수&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="67b2307e53f7065cdcc0a477bac65ac935a07e91" translate="yes" xml:space="preserve">
          <source>A common convention for Unix daemons is that they should reload their configuration when they receive a &lt;code&gt;SIGHUP&lt;/code&gt;. Here&amp;rsquo;s a sketch of what that might look like using &lt;a href=&quot;#trio.open_signal_receiver&quot;&gt;&lt;code&gt;open_signal_receiver()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Unix 데몬의 일반적인 규칙은 &lt;code&gt;SIGHUP&lt;/code&gt; 을받을 때 구성을 다시로드해야한다는 것 입니다. 다음은 &lt;a href=&quot;#trio.open_signal_receiver&quot;&gt; &lt;code&gt;open_signal_receiver()&lt;/code&gt; &lt;/a&gt; 사용하는 모습을 보여주는 스케치입니다 .</target>
        </trans-unit>
        <trans-unit id="479b35c63d61c382de8e69c12e513c7d2895b948" translate="yes" xml:space="preserve">
          <source>A context manager for catching signals.</source>
          <target state="translated">신호를 잡기위한 컨텍스트 관리자.</target>
        </trans-unit>
        <trans-unit id="d9a5508851c7e6da4d695e1f4368dbb4ae12c3ad" translate="yes" xml:space="preserve">
          <source>A context which may be used to spawn (or cancel) child tasks.</source>
          <target state="translated">자식 작업을 생성 (또는 취소)하는 데 사용될 수있는 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="6aeeaa351c9c07a00161cba202d64ab2ab24477f" translate="yes" xml:space="preserve">
          <source>A convenience class for forcing code in different tasks to run in an explicit linear order.</source>
          <target state="translated">서로 다른 작업의 코드를 명시 적으로 선형 순서로 실행하기위한 편리한 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="4fd174db16d5e267b3cf62d87b5c941ad8eebc38" translate="yes" xml:space="preserve">
          <source>A custom implementation of &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo()&lt;/code&gt; &lt;/a&gt; 의 사용자 정의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="4d8aae5f3ee79493cbf98ec8a47b0dfd039c01e4" translate="yes" xml:space="preserve">
          <source>A custom implementation of &lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt;&lt;code&gt;getnameinfo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt; &lt;code&gt;getnameinfo()&lt;/code&gt; &lt;/a&gt; 의 사용자 정의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="4c96cb1bc50af7354b9f19f6a1c590cece36bddb" translate="yes" xml:space="preserve">
          <source>A fair wait queue with cancellation and requeueing.</source>
          <target state="translated">취소 및 다시 대기열이있는 공정한 대기 대기열</target>
        </trans-unit>
        <trans-unit id="6549ee3a2faaf405d0715d67d2765d3f4964e0b1" translate="yes" xml:space="preserve">
          <source>A kinder, gentler GIL</source>
          <target state="translated">더 친절하고 부드러운 GIL</target>
        </trans-unit>
        <trans-unit id="fd218172690cec772655bedac675b0ffeb843ce6" translate="yes" xml:space="preserve">
          <source>A new &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새로운 &lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="5580dae5a64338462ab0b4ded8e52746c9e9530a" translate="yes" xml:space="preserve">
          <source>A new &lt;a href=&quot;#trio.hazmat.FdStream&quot;&gt;&lt;code&gt;FdStream&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새로운 &lt;a href=&quot;#trio.hazmat.FdStream&quot;&gt; &lt;code&gt;FdStream&lt;/code&gt; &lt;/a&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="2d62c4a7d9b95ef62f01b748c63549ffce82cd92" translate="yes" xml:space="preserve">
          <source>A new &lt;a href=&quot;#trio.lowlevel.FdStream&quot;&gt;&lt;code&gt;FdStream&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">새로운 &lt;a href=&quot;#trio.lowlevel.FdStream&quot;&gt; &lt;code&gt;FdStream&lt;/code&gt; &lt;/a&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="b7ab10dae01d56e576130b3136cffdd323dcafa7" translate="yes" xml:space="preserve">
          <source>A new exception object in which each component exception &lt;code&gt;exc&lt;/code&gt; has been replaced by the result of running &lt;code&gt;handler(exc)&lt;/code&gt; &amp;ndash; or, if &lt;code&gt;handler&lt;/code&gt; returned None for all the inputs, returns None.</source>
          <target state="translated">&lt;code&gt;handler(exc)&lt;/code&gt; 를 실행 한 결과로 각 구성 요소 예외 &lt;code&gt;exc&lt;/code&gt; 가 대체 된 새 예외 객체 &amp;ndash; 또는 모든 입력에 대해 &lt;code&gt;handler&lt;/code&gt; 가 None을 반환 한 경우 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="089ece0cda1cb42c55a75d324e06b234d0a9acd8" translate="yes" xml:space="preserve">
          <source>A pair &lt;code&gt;(send_channel, receive_channel)&lt;/code&gt;. If you have trouble remembering which order these go in, remember: data flows from left &amp;rarr; right.</source>
          <target state="translated">쌍 &lt;code&gt;(send_channel, receive_channel)&lt;/code&gt; . 어떤 순서로 진행되는지 기억하기 어려운 경우, 데이터가 왼쪽에서 오른쪽으로 흐릅니다.</target>
        </trans-unit>
        <trans-unit id="cd247a767092b84dd5e844b058c845103caf05f4" translate="yes" xml:space="preserve">
          <source>A pair &lt;code&gt;(transport_stream, trailing_bytes)&lt;/code&gt;, where &lt;code&gt;transport_stream&lt;/code&gt; is the underlying transport stream, and &lt;code&gt;trailing_bytes&lt;/code&gt; is a byte string. Since &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t necessarily know where the end of the encrypted data will be, it can happen that it accidentally reads too much from the underlying stream. &lt;code&gt;trailing_bytes&lt;/code&gt; contains this extra data; you should process it as if it was returned from a call to &lt;code&gt;transport_stream.receive_some(...)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(transport_stream, trailing_bytes)&lt;/code&gt; 쌍 . 여기서 &lt;code&gt;transport_stream&lt;/code&gt; 은 기본 전송 스트림이고 &lt;code&gt;trailing_bytes&lt;/code&gt; 는 바이트 문자열입니다. 이후 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; 는&lt;/a&gt; 암호화 된 데이터의 끝이 될 위치를 알 필요하지 않습니다, 실수로 기본이되는 스트림에서 너무 많이 읽 발생할 수 있습니다. &lt;code&gt;trailing_bytes&lt;/code&gt; 는이 추가 데이터를 포함합니다. &lt;code&gt;transport_stream.receive_some(...)&lt;/code&gt; 호출에서 리턴 된 것처럼 처리해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0588df8a0bae45e29e38622a0505c5a7de73534e" translate="yes" xml:space="preserve">
          <source>A pair of &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt; objects that are connected so that data automatically flows from one to the other in both directions.</source>
          <target state="translated">데이터가 양방향으로 자동으로 흐르도록 연결된 &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt; 객체 쌍입니다 .</target>
        </trans-unit>
        <trans-unit id="a6e442a4c39e80b90dffce3b49a6e8bdd58ab33b" translate="yes" xml:space="preserve">
          <source>A pure &lt;a href=&quot;reference-core#checkpoints&quot;&gt;checkpoint&lt;/a&gt;.</source>
          <target state="translated">순수한 &lt;a href=&quot;reference-core#checkpoints&quot;&gt;체크 포인트&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b4cd63d27ef50a64a84701fc8cbaeb490e2d4d44" translate="yes" xml:space="preserve">
          <source>A return statement will not cancel the nursery if it still has tasks running:</source>
          <target state="translated">반환 작업은 여전히 ​​실행중인 작업이있는 경우 보육을 취소하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="031c15f98d537a5e074447bce8e5ff119937e3b5" translate="yes" xml:space="preserve">
          <source>A return value of &lt;code&gt;b&quot;&quot;&lt;/code&gt; (an empty bytestring) indicates that the stream has reached end-of-file. Implementations should be careful that they return &lt;code&gt;b&quot;&quot;&lt;/code&gt; if, and only if, the stream has reached end-of-file!</source>
          <target state="translated">&lt;code&gt;b&quot;&quot;&lt;/code&gt; (빈 바이트 스트링) 의 리턴 값은 스트림이 파일 끝에 도달했음을 나타냅니다. 스트림이 파일 끝에 도달 한 경우에만 &lt;code&gt;b&quot;&quot;&lt;/code&gt; 를 리턴하도록 구현에주의해야 합니다!</target>
        </trans-unit>
        <trans-unit id="8bdf7ef69126ff7409e786016de2f34e5ff450c0" translate="yes" xml:space="preserve">
          <source>A semaphore holds an integer value, which can be incremented by calling &lt;a href=&quot;#trio.Semaphore.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; and decremented by calling &lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; &amp;ndash; but the value is never allowed to drop below zero. If the value is zero, then &lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; will block until someone calls &lt;a href=&quot;#trio.Semaphore.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">세마포어는 &lt;a href=&quot;#trio.Semaphore.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 를 호출하여 증가시킬 수 있고 &lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 감소 시킬 수있는 정수 값을 보유합니다. 그러나 값은 절대 0 미만으로 떨어질 수 없습니다. 값이 0 인 경우, 누군가 &lt;a href=&quot;#trio.Semaphore.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 호출 할 때까지 &lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 가 차단됩니다 .</target>
        </trans-unit>
        <trans-unit id="bce2812b0b52deb7bf2bba57f134e10e9513a206" translate="yes" xml:space="preserve">
          <source>A silly way to make a stream that echoes back whatever you write to it:</source>
          <target state="translated">스트림을 작성하는 어리석은 방법은 스트림에 쓰는 모든 내용을 에코합니다.</target>
        </trans-unit>
        <trans-unit id="5df2f3e939d31936762bec3597f6b2da00f2cb48" translate="yes" xml:space="preserve">
          <source>A simple channel example</source>
          <target state="translated">간단한 채널 예</target>
        </trans-unit>
        <trans-unit id="95282c07f98577f2f962ac30d0752ad31f56c132" translate="yes" xml:space="preserve">
          <source>A simple timeout example</source>
          <target state="translated">간단한 타임 아웃 예제</target>
        </trans-unit>
        <trans-unit id="6e235d2e02ac1d060d2ff3c65495448b073d204e" translate="yes" xml:space="preserve">
          <source>A slightly trickier case is a function like:</source>
          <target state="translated">약간 까다로운 경우는 다음과 같은 함수입니다.</target>
        </trans-unit>
        <trans-unit id="5626a02a8af093a360fe62102133baa49c34f588" translate="yes" xml:space="preserve">
          <source>A standard interface for interacting with bidirectional byte streams.</source>
          <target state="translated">양방향 바이트 스트림과 상호 작용하기위한 표준 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="0a1d52474b9106e18b98b94a4317b363829ea98d" translate="yes" xml:space="preserve">
          <source>A standard interface for interacting with bidirectional channels.</source>
          <target state="translated">양방향 채널과 상호 작용하기위한 표준 인터페이스.</target>
        </trans-unit>
        <trans-unit id="faa046132b99538769350e2cef5d5bc2e1a88a00" translate="yes" xml:space="preserve">
          <source>A standard interface for listening for incoming connections.</source>
          <target state="translated">들어오는 연결을 수신하기위한 표준 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="84688c296d643fb8558b4282dbf67d4d6c682eac" translate="yes" xml:space="preserve">
          <source>A standard interface for receiving Python objects from some sender.</source>
          <target state="translated">일부 발신자로부터 Python 객체를 수신하기위한 표준 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="19bdeadce2bcad6dfc143ef126e57402024bb864" translate="yes" xml:space="preserve">
          <source>A standard interface for receiving data on a byte stream.</source>
          <target state="translated">바이트 스트림에서 데이터를 수신하기위한 표준 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="f9ec745dcf68e43c09d13825380bfc3153b5f42a" translate="yes" xml:space="preserve">
          <source>A standard interface for resources that needs to be cleaned up, and where that cleanup may require blocking operations.</source>
          <target state="translated">정리해야하는 자원과 정리시 차단 작업이 필요한 리소스에 대한 표준 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="246a1fe88a6077a51a4b1ab320703dd1fe24b852" translate="yes" xml:space="preserve">
          <source>A standard interface for sending Python objects to some receiver.</source>
          <target state="translated">파이썬 객체를 일부 수신자에게 보내기위한 표준 인터페이스.</target>
        </trans-unit>
        <trans-unit id="6961f254e4e81df4b566ce4a2dff920fb070922a" translate="yes" xml:space="preserve">
          <source>A standard interface for sending data on a byte stream.</source>
          <target state="translated">바이트 스트림으로 데이터를 보내기위한 표준 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="b4cf06c3ae923d1d511d1dc400d9c860ddef6e9c" translate="yes" xml:space="preserve">
          <source>A stream connected to the child&amp;rsquo;s standard error stream: when the child writes to standard error, the written bytes become available for you to read here. Only available if the &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; was constructed using &lt;code&gt;stderr=PIPE&lt;/code&gt;; otherwise this will be None.</source>
          <target state="translated">자식의 표준 오류 스트림에 연결된 스트림 : 자식이 표준 오류에 쓸 때 여기에서 읽을 수있는 바이트가 작성됩니다. &lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;stderr=PIPE&lt;/code&gt; 를 사용하여 구성된 경우에만 사용 가능합니다 . 그렇지 않으면 이것은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="c6f0c220a8ef83c061ac018592a158c1acea362e" translate="yes" xml:space="preserve">
          <source>A stream connected to the child&amp;rsquo;s standard input stream: when you write bytes here, they become available for the child to read. Only available if the &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; was constructed using &lt;code&gt;stdin=PIPE&lt;/code&gt;; otherwise this will be None.</source>
          <target state="translated">자식의 표준 입력 스트림에 연결된 스트림 : 여기에 바이트를 쓰면 자식이 읽을 수있게됩니다. &lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;stdin=PIPE&lt;/code&gt; 를 사용하여 구성된 경우에만 사용 가능합니다 . 그렇지 않으면 이것은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="84f88943d222d5c08ff49d881c72a9de6313f085" translate="yes" xml:space="preserve">
          <source>A stream connected to the child&amp;rsquo;s standard output stream: when the child writes to standard output, the written bytes become available for you to read here. Only available if the &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; was constructed using &lt;code&gt;stdout=PIPE&lt;/code&gt;; otherwise this will be None.</source>
          <target state="translated">자식의 표준 출력 스트림에 연결된 스트림 : 자식이 표준 출력에 쓸 때 여기에서 읽을 수있는 바이트가 제공됩니다. &lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;stdout=PIPE&lt;/code&gt; 를 사용하여 구성된 경우에만 사용 가능합니다 . 그렇지 않으면 이것은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="954ca7723aafc90b8ae2473f0d14253858c192e4" translate="yes" xml:space="preserve">
          <source>A stream that sends data to the child&amp;rsquo;s standard input and receives from the child&amp;rsquo;s standard output. Only available if both &lt;a href=&quot;#trio.Process.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.Process.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; are available; otherwise this will be None.</source>
          <target state="translated">자식의 표준 입력으로 데이터를 보내고 자식의 표준 출력에서받는 스트림입니다. &lt;a href=&quot;#trio.Process.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;#trio.Process.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; 을&lt;/a&gt; 모두 사용할 수있는 경우에만 사용 가능합니다. 그렇지 않으면 이것은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="4156e909e8dc71d5689a050c51a8b9b787486dce" translate="yes" xml:space="preserve">
          <source>A tuple (&lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;code&gt;MemorySendStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;code&gt;MemoryReceiveStream&lt;/code&gt;&lt;/a&gt;), where the &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;code&gt;MemorySendStream&lt;/code&gt;&lt;/a&gt; has its hooks set up so that it calls &lt;a href=&quot;#trio.testing.memory_stream_pump&quot;&gt;&lt;code&gt;memory_stream_pump()&lt;/code&gt;&lt;/a&gt; from its &lt;a href=&quot;#trio.testing.MemorySendStream.send_all_hook&quot;&gt;&lt;code&gt;send_all_hook&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.MemorySendStream.close_hook&quot;&gt;&lt;code&gt;close_hook&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">튜플 ( &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt; &lt;code&gt;MemorySendStream&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt; &lt;code&gt;MemoryReceiveStream&lt;/code&gt; &lt;/a&gt; ). &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt; &lt;code&gt;MemorySendStream&lt;/code&gt; &lt;/a&gt; 에는 &lt;a href=&quot;#trio.testing.MemorySendStream.send_all_hook&quot;&gt; &lt;code&gt;send_all_hook&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.testing.MemorySendStream.close_hook&quot;&gt; &lt;code&gt;close_hook&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;#trio.testing.memory_stream_pump&quot;&gt; &lt;code&gt;memory_stream_pump()&lt;/code&gt; &lt;/a&gt; 를 호출하도록 후크가 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="efcdeb1e57aeec9fabc1211f5ee625ae661f04ca" translate="yes" xml:space="preserve">
          <source>A tuple (&lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">튜플 ( &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="41812fde4d36fb61daec4837f44446d9e7c30dff" translate="yes" xml:space="preserve">
          <source>A tuple (&lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">튜플 ( &lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="3b58de50a23919a1f3f8642bdd5fcb86f500f20f" translate="yes" xml:space="preserve">
          <source>A user-controllable clock suitable for writing tests.</source>
          <target state="translated">테스트 작성에 적합한 사용자 제어 가능 클록.</target>
        </trans-unit>
        <trans-unit id="d394b71cb15d8736cdfc1fc9fa37b4073ac2c1e7" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; where tasks are guaranteed to acquire the lock in strict first-come-first-served order.</source>
          <target state="translated">작업이 엄격한 선착순으로 잠금을 획득하도록 보장되는 &lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="360867cd6ca0456c8287b5d11df4b1f0bd3a3ed9" translate="yes" xml:space="preserve">
          <source>A waitable boolean value useful for inter-task synchronization, inspired by &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event&quot;&gt;&lt;code&gt;threading.Event&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event&quot;&gt; &lt;code&gt;threading.Event&lt;/code&gt; &lt;/a&gt; 에서 영감을 얻은 작업 간 동기화에 유용한 대기 가능 부울 값 입니다.</target>
        </trans-unit>
        <trans-unit id="888df3bc904f11ac7d98b120089cf5c393ec278c" translate="yes" xml:space="preserve">
          <source>API details</source>
          <target state="translated">API 세부 사항</target>
        </trans-unit>
        <trans-unit id="a135b59a972e5d51e9898c53214e86f0658cc125" translate="yes" xml:space="preserve">
          <source>API overview</source>
          <target state="translated">API 개요</target>
        </trans-unit>
        <trans-unit id="98f04167dd579d54364beef9c72aecdee3543412" translate="yes" xml:space="preserve">
          <source>Abstract base class</source>
          <target state="translated">추상 기본 클래스</target>
        </trans-unit>
        <trans-unit id="d8218637bd5929185efd6cedd428b196f3c683f3" translate="yes" xml:space="preserve">
          <source>Abstract base classes</source>
          <target state="translated">추상 기본 수업</target>
        </trans-unit>
        <trans-unit id="934a206c7fa94c5e3b940f49138774a9bc4b9522" translate="yes" xml:space="preserve">
          <source>Accept an incoming connection.</source>
          <target state="translated">들어오는 연결을 수락하십시오.</target>
        </trans-unit>
        <trans-unit id="f980df6a8d9e94749c222bab10788f1acc9910d2" translate="yes" xml:space="preserve">
          <source>Accept the next connection and wrap it in an &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다음 연결을 승인하고 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; 으로&lt;/a&gt; 랩핑하십시오 .</target>
        </trans-unit>
        <trans-unit id="01859c9721d844b4c97719553bfc101a5661028b" translate="yes" xml:space="preserve">
          <source>Accessing this attribute does not check for termination; use &lt;a href=&quot;#trio.Process.poll&quot;&gt;&lt;code&gt;poll()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.Process.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; for that.</source>
          <target state="translated">이 속성에 액세스해도 종료를 확인하지 않습니다. 사용 &lt;a href=&quot;#trio.Process.poll&quot;&gt; &lt;code&gt;poll()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#trio.Process.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 그것에 대해.</target>
        </trans-unit>
        <trans-unit id="a24b8c73dc58f01619f8b157ef4dbb8d1cabc7f7" translate="yes" xml:space="preserve">
          <source>Acquire the lock, blocking if necessary.</source>
          <target state="translated">잠금을 획득하고 필요한 경우 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="f62f5263a0efafa3ea2f701a6b780bcf9b854b41" translate="yes" xml:space="preserve">
          <source>Acquire the underlying lock, blocking if necessary.</source>
          <target state="translated">기본 잠금을 획득하고 필요한 경우 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="51ec9b3d2f83bb81036ed643e849cf389554eadd" translate="yes" xml:space="preserve">
          <source>Actually close the object.</source>
          <target state="translated">실제로 개체를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="c33c4bb3cd6a08c2b5c643cb02e11bb07b5a62c3" translate="yes" xml:space="preserve">
          <source>Adds an end-of-file marker to the internal buffer.</source>
          <target state="translated">파일 끝 마커를 내부 버퍼에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="84752f69bde810200a7a75068013277cd2c18314" translate="yes" xml:space="preserve">
          <source>Adds these abstract methods&amp;hellip;</source>
          <target state="translated">이 추상적 인 방법을 추가합니다&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="9ffc61eebd04b52ced9a43b69b164c475720e17f" translate="yes" xml:space="preserve">
          <source>After construction, you can interact with the child process by writing data to its &lt;a href=&quot;#trio.Process.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; stream (a &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt;), reading data from its &lt;a href=&quot;#trio.Process.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;#trio.Process.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt; streams (both &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;s), sending it signals using &lt;a href=&quot;#trio.Process.terminate&quot;&gt;&lt;code&gt;terminate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.Process.kill&quot;&gt;&lt;code&gt;kill&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#trio.Process.send_signal&quot;&gt;&lt;code&gt;send_signal&lt;/code&gt;&lt;/a&gt;, and waiting for it to exit using &lt;a href=&quot;#trio.Process.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">건설 후에는 데이터를 작성하여 자식 프로세스와 상호 작용할 수있는 &lt;a href=&quot;#trio.Process.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt; 스트림 (A &lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; 의 데이터 읽기) &lt;a href=&quot;#trio.Process.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 및 / 또는 &lt;a href=&quot;#trio.Process.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; 스트림 (모두 &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; 그것을 통해 신호 전송,들)을 &lt;a href=&quot;#trio.Process.terminate&quot;&gt; &lt;code&gt;terminate&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#trio.Process.kill&quot;&gt; &lt;code&gt;kill&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;#trio.Process.send_signal&quot;&gt; &lt;code&gt;send_signal&lt;/code&gt; 을&lt;/a&gt; 하고, wait를 사용하여 종료 될 &lt;a href=&quot;#trio.Process.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; . 자세한 내용은 &lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fda6461f3015f34ff1df74c1242f7e0c19473185" translate="yes" xml:space="preserve">
          <source>After creating a stream pair, you can send data back and forth, which is enough for simple tests:</source>
          <target state="translated">스트림 쌍을 만든 후에는 데이터를주고받을 수 있으며 간단한 테스트에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="5bdd9f5cfc1e60752e0ba39124a981ddc11ba5c6" translate="yes" xml:space="preserve">
          <source>All calls with &lt;code&gt;idempotent=False&lt;/code&gt; are processed in strict first-in first-out order.</source>
          <target state="translated">&lt;code&gt;idempotent=False&lt;/code&gt; 인 모든 통화 는 엄격한 선입 선출 순서로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="bc1800be0a86bb365c062c632403ff85f295fbb0" translate="yes" xml:space="preserve">
          <source>All channel objects have an asynchronous &lt;a href=&quot;reference-io#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose&lt;/code&gt;&lt;/a&gt; method. Memory channels can also be closed synchronously. This has the same effect on the channel and other tasks using it, but &lt;a href=&quot;#trio.MemoryReceiveChannel.close&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; is not a trio checkpoint. This simplifies cleaning up in cancelled tasks.</source>
          <target state="translated">모든 채널 객체는 비동기가 &lt;a href=&quot;reference-io#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose&lt;/code&gt; &lt;/a&gt; 방법. 메모리 채널도 동시에 닫을 수 있습니다. 이는 채널 및이를 사용하는 다른 작업에 동일한 영향을 미치지 만 &lt;a href=&quot;#trio.MemoryReceiveChannel.close&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 는 트리오 체크 포인트가 아닙니다. 이것은 취소 된 작업의 정리를 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="380190441d34543ba4850366079f21998b5f119d" translate="yes" xml:space="preserve">
          <source>All channel objects have an asynchronous &lt;a href=&quot;reference-io#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose&lt;/code&gt;&lt;/a&gt; method. Memory channels can also be closed synchronously. This has the same effect on the channel and other tasks using it, but &lt;a href=&quot;#trio.MemorySendChannel.close&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; is not a trio checkpoint. This simplifies cleaning up in cancelled tasks.</source>
          <target state="translated">모든 채널 객체는 비동기가 &lt;a href=&quot;reference-io#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose&lt;/code&gt; &lt;/a&gt; 방법. 메모리 채널도 동시에 닫을 수 있습니다. 이는 채널 및이를 사용하는 다른 작업에 동일한 영향을 미치지 만 &lt;a href=&quot;#trio.MemorySendChannel.close&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 는 트리오 체크 포인트가 아닙니다. 이것은 취소 된 작업의 정리를 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="c364f3240a303cebaff74b8113e96934d193acdf" translate="yes" xml:space="preserve">
          <source>All environments provide the following functions:</source>
          <target state="translated">모든 환경은 다음 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="05f2ead08f89de72a95c7b552f13385fec475502" translate="yes" xml:space="preserve">
          <source>All event loops have the same basic structure. They loop through two operations, over and over:</source>
          <target state="translated">모든 이벤트 루프는 동일한 기본 구조를 갖습니다. 두 가지 작업을 반복해서 반복합니다.</target>
        </trans-unit>
        <trans-unit id="516b45d89e54cbc171ce25d82e3ea1e166f44bfe" translate="yes" xml:space="preserve">
          <source>All methods and attributes &lt;em&gt;not&lt;/em&gt; mentioned above are identical to their equivalents in &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt;&lt;code&gt;socket.socket()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">위에서 언급 &lt;em&gt;하지 않은&lt;/em&gt; 모든 메소드와 속성 은 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt; &lt;code&gt;socket.socket()&lt;/code&gt; &lt;/a&gt; 의 해당 메소드와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="9763027b87405de48bf6b0814b614c809653c3a9" translate="yes" xml:space="preserve">
          <source>All of Trio&amp;rsquo;s subprocess APIs accept the numerous keyword arguments used by the standard &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; module to control the environment in which a process starts and the mechanisms used for communicating with it. These may be passed wherever you see &lt;code&gt;**options&lt;/code&gt; in the documentation below. See the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#popen-constructor&quot;&gt;full list&lt;/a&gt; or just the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#frequently-used-arguments&quot;&gt;frequently used ones&lt;/a&gt; in the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; documentation. (You may need to &lt;code&gt;import
subprocess&lt;/code&gt; in order to access constants such as &lt;code&gt;PIPE&lt;/code&gt; or &lt;code&gt;DEVNULL&lt;/code&gt;.)</source>
          <target state="translated">모든 Trio의 서브 프로세스 API는 표준 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 모듈에서 사용하는 수많은 키워드 인수를 수락하여 프로세스가 시작되는 환경과 통신하는 데 사용되는 메커니즘을 제어합니다. 아래 문서의 &lt;code&gt;**options&lt;/code&gt; 있는 곳이면 어디든 전달 될 수 있습니다 . &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 문서 에서 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#popen-constructor&quot;&gt;전체 목록&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#frequently-used-arguments&quot;&gt;자주 사용되는 항목&lt;/a&gt; 을 참조하십시오 . ( &lt;code&gt;PIPE&lt;/code&gt; 또는 &lt;code&gt;DEVNULL&lt;/code&gt; 과 같은 상수에 액세스하려면 &lt;code&gt;import subprocess&lt;/code&gt; 를 가져와야 할 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="2aa180e59f7357f8747d01d26ff0c904e97ad5cf" translate="yes" xml:space="preserve">
          <source>All of these hooks are also exposed as attributes on the object, and you can change them at any time.</source>
          <target state="translated">이러한 후크는 모두 객체의 속성으로 표시되며 언제든지 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1538bc660a990864dbaf1ef24a3d075fd3a9b8f" translate="yes" xml:space="preserve">
          <source>Also, &lt;a href=&quot;#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;trio.socket.getaddrinfo()&lt;/code&gt;&lt;/a&gt; correctly uses IDNA 2008 to process non-ASCII domain names. (&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getaddrinfo&quot;&gt;&lt;code&gt;socket.getaddrinfo()&lt;/code&gt;&lt;/a&gt; uses IDNA 2003, which can give the wrong result in some cases and cause you to connect to a different host than the one you intended; see &lt;a href=&quot;https://bugs.python.org/issue17305&quot;&gt;bpo-17305&lt;/a&gt;.)</source>
          <target state="translated">또한 &lt;a href=&quot;#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;trio.socket.getaddrinfo()&lt;/code&gt; &lt;/a&gt; 는 IDNA 2008을 올바르게 사용하여 비 ASCII 도메인 이름을 처리합니다. ( &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getaddrinfo&quot;&gt; &lt;code&gt;socket.getaddrinfo()&lt;/code&gt; &lt;/a&gt; 는 IDNA 2003을 사용하므로 경우에 따라 잘못된 결과가 발생하여 의도 한 것과 다른 호스트에 연결될 수 있습니다 ( &lt;a href=&quot;https://bugs.python.org/issue17305&quot;&gt;bpo-17305&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="25647558d2960d3b5b0bcd7444b5f154e5eba4f3" translate="yes" xml:space="preserve">
          <source>Alternatively, you can customize this behavior by passing in an arbitrary async function, which will be called with the &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; object as an argument. For example, the default Unix behavior could be implemented like this:</source>
          <target state="translated">또는 &lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 개체를 인수로 사용하여 호출되는 임의의 비동기 함수를 전달하여이 동작을 사용자 지정할 수 있습니다 . 예를 들어 기본 Unix 동작은 다음과 같이 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83cf84f8a5bf0d4f53335a628e0369d2475a03db" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/glossary.html#term-asynchronous-file-object&quot;&gt;asynchronous file object&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/glossary.html#term-asynchronous-file-object&quot;&gt;비동기 파일 객체&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8a3d704b1065f4c2eb639c6f993e214ab9654318" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/glossary.html#term-asynchronous-file-object&quot;&gt;asynchronous file object&lt;/a&gt; that wraps &lt;code&gt;file&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/glossary.html#term-asynchronous-file-object&quot;&gt;비동기 파일 객체&lt;/a&gt; 랩 &lt;code&gt;file&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="416e52543b6e0af623c221f5ac17aff6c01b9600" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://trio.readthedocs.io/en/v0.18.0/glossary.html#term-asynchronous-file-object&quot;&gt;asynchronous file object&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://trio.readthedocs.io/en/v0.18.0/glossary.html#term-asynchronous-file-object&quot;&gt;비동기 파일 객체&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d64b38434eb152f54e902d8a5dac014f9e636e04" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://trio.readthedocs.io/en/v0.18.0/glossary.html#term-asynchronous-file-object&quot;&gt;asynchronous file object&lt;/a&gt; that wraps &lt;code&gt;file&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;https://trio.readthedocs.io/en/v0.18.0/glossary.html#term-asynchronous-file-object&quot;&gt;비동기 파일 객체&lt;/a&gt; 랩 &lt;code&gt;file&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1ea3e221e320e66a01449910662fe22a6e14690" translate="yes" xml:space="preserve">
          <source>An arbitrary callable, which will be passed a function as its sole argument:</source>
          <target state="translated">함수를 유일한 인수로 전달하는 임의의 콜 러블 :</target>
        </trans-unit>
        <trans-unit id="cb7271ce0ed3ef1c74f989e4b27be757d4b57792" translate="yes" xml:space="preserve">
          <source>An arbitrary callable:</source>
          <target state="translated">임의의 호출 가능 :</target>
        </trans-unit>
        <trans-unit id="5c6ad51b16f47f51ef3520b76beb8651a3307021" translate="yes" xml:space="preserve">
          <source>An event loop acts as a central coordinator to manage all the IO happening in your program. Normally, that means that your application has to pick one event loop, and use it for everything. But what if you like Trio, but also need to use a framework like &lt;a href=&quot;https://en.wikipedia.org/wiki/Qt_(software)&quot;&gt;Qt&lt;/a&gt; or &lt;a href=&quot;https://www.pygame.org/&quot;&gt;PyGame&lt;/a&gt; that has its own event loop? Then you need some way to run both event loops at once.</source>
          <target state="translated">이벤트 루프는 프로그램에서 발생하는 모든 IO를 관리하는 중앙 조정자 역할을합니다. 일반적으로 이는 애플리케이션이 하나의 이벤트 루프를 선택하여 모든 것에 사용해야 함을 의미합니다. 그러나 Trio를 좋아하지만 자체 이벤트 루프가있는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Qt_(software)&quot;&gt;Qt&lt;/a&gt; 또는 &lt;a href=&quot;https://www.pygame.org/&quot;&gt;PyGame&lt;/a&gt; 과 같은 프레임 워크를 사용해야하는 경우에는 어떻게해야합니까? 그런 다음 두 이벤트 루프를 동시에 실행할 수있는 방법이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a802ab3679dc10b4fe79e97e5a8ff9d668b3ca83" translate="yes" xml:space="preserve">
          <source>An event object has an internal boolean flag, representing whether the event has happened yet. The flag is initially False, and the &lt;a href=&quot;#trio.Event.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; method waits until the flag is True. If the flag is already True, then &lt;a href=&quot;#trio.Event.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; returns immediately. (If the event has already happened, there&amp;rsquo;s nothing to wait for.) The &lt;a href=&quot;#trio.Event.set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; method sets the flag to True, and wakes up any waiters.</source>
          <target state="translated">이벤트 객체에는 이벤트가 아직 발생했는지 여부를 나타내는 내부 부울 플래그가 있습니다. 플래그는 처음에는 False이며 &lt;a href=&quot;#trio.Event.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 메소드는 플래그가 True가 될 때까지 대기합니다. 플래그가 이미 True이면 &lt;a href=&quot;#trio.Event.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 가 즉시 리턴합니다. 이벤트가 이미 발생한 경우 기다릴 필요가 없습니다. &lt;a href=&quot;#trio.Event.set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt; 메서드는 플래그를 True로 설정하고 웨이터를 깨 웁니다.</target>
        </trans-unit>
        <trans-unit id="4d52ab6eac96066995c3946164709bf9e329f2bc" translate="yes" xml:space="preserve">
          <source>An example of when this is useful is if you&amp;rsquo;re implementing something like &lt;a href=&quot;reference-io#trio.SSLStream&quot;&gt;&lt;code&gt;trio.SSLStream&lt;/code&gt;&lt;/a&gt; or an HTTP/2 server using &lt;a href=&quot;https://hyper-h2.readthedocs.io/&quot;&gt;h2&lt;/a&gt;, where you have multiple concurrent tasks that are interacting with a shared state machine, and at unpredictable moments the state machine requests that a chunk of data be sent over the network. (For example, when using h2 simply reading incoming data can occasionally &lt;a href=&quot;https://http2.github.io/http2-spec/#PING&quot;&gt;create outgoing data to send&lt;/a&gt;.) The challenge is to make sure that these chunks are sent in the correct order, without being garbled.</source>
          <target state="translated">이것이 유용한 경우의 예는 공유 상태 머신과 상호 작용하고 예측할 수없는 순간에 상태 머신이 요청하는 여러 개의 동시 태스크가있는 &lt;a href=&quot;https://hyper-h2.readthedocs.io/&quot;&gt;h2를&lt;/a&gt; 사용하여 &lt;a href=&quot;reference-io#trio.SSLStream&quot;&gt; &lt;code&gt;trio.SSLStream&lt;/code&gt; &lt;/a&gt; 또는 HTTP / 2 서버 와 같은 것을 구현하는 경우 입니다. 데이터 청크가 네트워크를 통해 전송됩니다. (예를 들어, h2를 &lt;a href=&quot;https://http2.github.io/http2-spec/#PING&quot;&gt;사용하는&lt;/a&gt; 경우 수신 데이터를 읽기만 하면 송신 데이터가 전송 될 수 있습니다.) 이러한 청크가 깨지지 않고 올바른 순서로 전송되도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="14aa51805b5668de90eaf69ef2c36108d5a6ef09" translate="yes" xml:space="preserve">
          <source>An example of where you&amp;rsquo;d use this is in implementing something like &lt;a href=&quot;reference-core#trio.from_thread.run&quot;&gt;&lt;code&gt;trio.from_thread.run()&lt;/code&gt;&lt;/a&gt;, which uses &lt;a href=&quot;#trio.hazmat.TrioToken.run_sync_soon&quot;&gt;&lt;code&gt;TrioToken.run_sync_soon()&lt;/code&gt;&lt;/a&gt; to get into the Trio thread. &lt;a href=&quot;#trio.hazmat.TrioToken.run_sync_soon&quot;&gt;&lt;code&gt;run_sync_soon()&lt;/code&gt;&lt;/a&gt; callbacks are run with &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; protection enabled, and &lt;a href=&quot;reference-core#trio.from_thread.run&quot;&gt;&lt;code&gt;trio.from_thread.run()&lt;/code&gt;&lt;/a&gt; takes advantage of this to safely set up the machinery for sending a response back to the original thread, but then uses &lt;a href=&quot;#trio.hazmat.disable_ki_protection&quot;&gt;&lt;code&gt;disable_ki_protection()&lt;/code&gt;&lt;/a&gt; when entering the user-provided function.</source>
          <target state="translated">이것을 사용할 위치의 예 는 &lt;a href=&quot;#trio.hazmat.TrioToken.run_sync_soon&quot;&gt; &lt;code&gt;TrioToken.run_sync_soon()&lt;/code&gt; &lt;/a&gt; 을 사용 하여 Trio 스레드에 들어가는 &lt;a href=&quot;reference-core#trio.from_thread.run&quot;&gt; &lt;code&gt;trio.from_thread.run()&lt;/code&gt; &lt;/a&gt; 과 같은 것을 구현하는 것 입니다. &lt;a href=&quot;#trio.hazmat.TrioToken.run_sync_soon&quot;&gt; &lt;code&gt;run_sync_soon()&lt;/code&gt; &lt;/a&gt; 콜백은 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 보호가 활성화 된 상태에서 실행되며 &lt;a href=&quot;reference-core#trio.from_thread.run&quot;&gt; &lt;code&gt;trio.from_thread.run()&lt;/code&gt; &lt;/a&gt; 은이를 이용하여 응답을 원래 스레드로 다시 전송하기위한 기계를 안전하게 설정하지만 사용자가 들어갈 때 &lt;a href=&quot;#trio.hazmat.disable_ki_protection&quot;&gt; &lt;code&gt;disable_ki_protection()&lt;/code&gt; &lt;/a&gt; 을 사용합니다. 제공된 기능.</target>
        </trans-unit>
        <trans-unit id="842ee58ab80fbca96d94e7bbc52e9e659a4b6031" translate="yes" xml:space="preserve">
          <source>An example of where you&amp;rsquo;d use this is in implementing something like &lt;a href=&quot;reference-core#trio.from_thread.run&quot;&gt;&lt;code&gt;trio.from_thread.run()&lt;/code&gt;&lt;/a&gt;, which uses &lt;a href=&quot;#trio.lowlevel.TrioToken.run_sync_soon&quot;&gt;&lt;code&gt;TrioToken.run_sync_soon()&lt;/code&gt;&lt;/a&gt; to get into the Trio thread. &lt;a href=&quot;#trio.lowlevel.TrioToken.run_sync_soon&quot;&gt;&lt;code&gt;run_sync_soon()&lt;/code&gt;&lt;/a&gt; callbacks are run with &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; protection enabled, and &lt;a href=&quot;reference-core#trio.from_thread.run&quot;&gt;&lt;code&gt;trio.from_thread.run()&lt;/code&gt;&lt;/a&gt; takes advantage of this to safely set up the machinery for sending a response back to the original thread, but then uses &lt;a href=&quot;#trio.lowlevel.disable_ki_protection&quot;&gt;&lt;code&gt;disable_ki_protection()&lt;/code&gt;&lt;/a&gt; when entering the user-provided function.</source>
          <target state="translated">이것을 사용하는 예 는 Trio 스레드에 들어가기 위해 &lt;a href=&quot;#trio.lowlevel.TrioToken.run_sync_soon&quot;&gt; &lt;code&gt;TrioToken.run_sync_soon()&lt;/code&gt; &lt;/a&gt; 을 사용하는 &lt;a href=&quot;reference-core#trio.from_thread.run&quot;&gt; &lt;code&gt;trio.from_thread.run()&lt;/code&gt; &lt;/a&gt; 과 같은 것을 구현하는 것 입니다. &lt;a href=&quot;#trio.lowlevel.TrioToken.run_sync_soon&quot;&gt; &lt;code&gt;run_sync_soon()&lt;/code&gt; &lt;/a&gt; 콜백은 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 보호가 활성화 된 상태에서 실행되며 &lt;a href=&quot;reference-core#trio.from_thread.run&quot;&gt; &lt;code&gt;trio.from_thread.run()&lt;/code&gt; &lt;/a&gt; 은이를 활용하여 원래 스레드로 응답을 다시 보내기위한 기계를 안전하게 설정하지만 사용자 입력시 &lt;a href=&quot;#trio.lowlevel.disable_ki_protection&quot;&gt; &lt;code&gt;disable_ki_protection()&lt;/code&gt; &lt;/a&gt; 을 사용합니다. 제공된 기능.</target>
        </trans-unit>
        <trans-unit id="a1f0bedbb145e5a1e2bbf357cfd642611519001c" translate="yes" xml:space="preserve">
          <source>An example of where you&amp;rsquo;d use this is on the &lt;code&gt;__exit__&lt;/code&gt; implementation for something like a &lt;a href=&quot;reference-core#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt;, where a poorly-timed &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; could leave the lock in an inconsistent state and cause a deadlock.</source>
          <target state="translated">이것을 사용하는 위치의 예는 &lt;a href=&quot;reference-core#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 과 같은 것에 대한 &lt;code&gt;__exit__&lt;/code&gt; 구현에 있으며, 시간이 잘못 된 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 는 잠금을 일관성이없는 상태로두고 교착 상태를 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d53f85c599291f0aa7ad06a498910662abac5c1" translate="yes" xml:space="preserve">
          <source>An exception that contains other exceptions; also known as an &amp;ldquo;inception&amp;rdquo;.</source>
          <target state="translated">다른 예외를 포함하는 예외. &quot;시작&quot;이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="8b5a92674abba02060ea334d3fa2bbc5aa4e8e09" translate="yes" xml:space="preserve">
          <source>An extremely elaborate way to print the numbers 0-5, in order:</source>
          <target state="translated">숫자 0-5를 순서대로 인쇄하는 매우 정교한 방법 :</target>
        </trans-unit>
        <trans-unit id="7aef88f6225e778c97ecaab42341e3b25ab9147f" translate="yes" xml:space="preserve">
          <source>An implementation of the &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;trio.abc.HalfCloseableStream&lt;/code&gt;&lt;/a&gt; interface based on a raw network socket.</source>
          <target state="translated">원시 네트워크 소켓을 기반으로하는 &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;trio.abc.HalfCloseableStream&lt;/code&gt; &lt;/a&gt; 인터페이스 구현 .</target>
        </trans-unit>
        <trans-unit id="695564b638fa254ea364510c5e05e8097f7591d5" translate="yes" xml:space="preserve">
          <source>An in-memory &lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메모리 내 &lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b2a920b465cb25d11c71e2cdaf24856da6d63c8" translate="yes" xml:space="preserve">
          <source>An in-memory &lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메모리 내 &lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f30ba4d9f6910fed9a58bf0bd0f5800556c4cba6" translate="yes" xml:space="preserve">
          <source>An object for controlling access to a resource with limited capacity.</source>
          <target state="translated">용량이 제한된 리소스에 대한 액세스를 제어하기위한 개체입니다.</target>
        </trans-unit>
        <trans-unit id="ba8865459d8776bfdcb6f4f08bb9a46b051e09e7" translate="yes" xml:space="preserve">
          <source>An object representing the incoming connection. In practice this is generally some kind of &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;, but in principle you could also define a &lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;code&gt;Listener&lt;/code&gt;&lt;/a&gt; that returned, say, channel objects.</source>
          <target state="translated">들어오는 연결을 나타내는 개체입니다. 실제로 이것은 일반적으로 일종의 &lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 이지만 원칙적으로 채널 객체를 반환 하는 &lt;a href=&quot;#trio.abc.Listener&quot;&gt; &lt;code&gt;Listener&lt;/code&gt; &lt;/a&gt; 를 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb005736155e148aa00fb56e6e1d90e65b11f9f4" translate="yes" xml:space="preserve">
          <source>An object used to limit the number of simultaneous threads. Most commonly this will be a &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt;, but it could be anything providing compatible &lt;a href=&quot;#trio.CapacityLimiter.acquire_on_behalf_of&quot;&gt;&lt;code&gt;acquire_on_behalf_of()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.CapacityLimiter.release_on_behalf_of&quot;&gt;&lt;code&gt;release_on_behalf_of()&lt;/code&gt;&lt;/a&gt; methods. This function will call &lt;code&gt;acquire_on_behalf_of&lt;/code&gt; before starting the thread, and &lt;code&gt;release_on_behalf_of&lt;/code&gt; after the thread has finished.</source>
          <target state="translated">동시 스레드 수를 제한하는 데 사용되는 객체입니다. 가장 일반적으로 이것은 &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt; 이지만 호환되는 &lt;a href=&quot;#trio.CapacityLimiter.acquire_on_behalf_of&quot;&gt; &lt;code&gt;acquire_on_behalf_of()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.CapacityLimiter.release_on_behalf_of&quot;&gt; &lt;code&gt;release_on_behalf_of()&lt;/code&gt; &lt;/a&gt; 메소드를 제공하는 모든 것이 될 수 있습니다 . 이 함수는 스레드를 시작하기 전에 &lt;code&gt;acquire_on_behalf_of&lt;/code&gt; 를 호출 하고 스레드가 완료된 후 &lt;code&gt;release_on_behalf_of&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="d44602f4de12292ecf6bdcbd9eb7906b8d75b788" translate="yes" xml:space="preserve">
          <source>An opaque object representing a single call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 대한 단일 호출을 나타내는 불투명 한 객체 입니다.</target>
        </trans-unit>
        <trans-unit id="8149f28272227a8e81084653973e770e45c26b37" translate="yes" xml:space="preserve">
          <source>And both of these raise nothing at all:</source>
          <target state="translated">그리고이 두 가지 모두 전혀 아무것도 제기하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="83af1c669b4bec1a968e9180163f131b881c991c" translate="yes" xml:space="preserve">
          <source>And crucially, if you try to borrow a token but the sack is empty, then you have to wait for another task to finish what it&amp;rsquo;s doing and put its token back first before you can take it and continue.</source>
          <target state="translated">그리고 토큰을 빌리려고하지만 자루가 비어있는 경우 다른 작업이 완료 될 때까지 기다렸다가 토큰을 다시 가져 와서 계속 진행해야합니다.</target>
        </trans-unit>
        <trans-unit id="e9441ac9e6468a96d8d53ae170751b3641f022f8" translate="yes" xml:space="preserve">
          <source>And here&amp;rsquo;s a simple test using our modified stream objects:</source>
          <target state="translated">다음은 수정 된 스트림 객체를 사용한 간단한 테스트입니다.</target>
        </trans-unit>
        <trans-unit id="292b64b01e8fc7f9c6c766b1d0e5576718c411ae" translate="yes" xml:space="preserve">
          <source>And here&amp;rsquo;s the interface to implement if you want to build your own &lt;a href=&quot;#trio.abc.Instrument&quot;&gt;&lt;code&gt;Instrument&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">그리고 자신 만의 &lt;a href=&quot;#trio.abc.Instrument&quot;&gt; &lt;code&gt;Instrument&lt;/code&gt; &lt;/a&gt; 를 구축하려는 경우 구현할 인터페이스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e471a70c4adc5a5fbd1f21459bce94d3eae6d3d6" translate="yes" xml:space="preserve">
          <source>And if you combine pipelines with () grouping, you can need even more levels of escaping:</source>
          <target state="translated">파이프 라인을 () 그룹화와 결합하면 더 많은 레벨의 이스케이프가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33a00a0e43b4ec4919fc3243ac05e9ba6405d86a" translate="yes" xml:space="preserve">
          <source>And if you&amp;rsquo;re implementing a server, you can use &lt;a href=&quot;#trio.SSLListener&quot;&gt;&lt;code&gt;SSLListener&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">서버를 구현하는 경우 &lt;a href=&quot;#trio.SSLListener&quot;&gt; &lt;code&gt;SSLListener&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba0a6a620759e481fb4465edb6928ab1b2715ba4" translate="yes" xml:space="preserve">
          <source>And in some very, very unusual circumstances, it even makes sense to transfer a single coroutine object back and forth between different coroutine runners. That&amp;rsquo;s what this section is about. This is an &lt;em&gt;extremely&lt;/em&gt; exotic use case, and assumes a lot of expertise in how Python async/await works internally. For motivating examples, see &lt;a href=&quot;https://github.com/python-trio/trio-asyncio/issues/42&quot;&gt;trio-asyncio issue #42&lt;/a&gt;, and &lt;a href=&quot;https://github.com/python-trio/trio/issues/649&quot;&gt;trio issue #649&lt;/a&gt;. For more details on how coroutines work, we recommend Andr&amp;eacute; Caron&amp;rsquo;s &lt;a href=&quot;https://github.com/AndreLouisCaron/a-tale-of-event-loops&quot;&gt;A tale of event loops&lt;/a&gt;, or going straight to &lt;a href=&quot;https://www.python.org/dev/peps/pep-0492/&quot;&gt;PEP 492&lt;/a&gt; for the full details.</source>
          <target state="translated">그리고 매우, 매우 이례적인 상황에서는 단일 코 루틴 물체를 다른 코 루틴 러너 사이에서 앞뒤로 옮기는 것이 합리적입니다. 이것이이 섹션의 내용입니다. 이것은 &lt;em&gt;매우&lt;/em&gt; 이국적인 유스 케이스이며 Python 비동기 / 대기가 내부적으로 작동하는 방법에 대한 많은 전문 지식을 가정합니다. 동기 부여 예제는 &lt;a href=&quot;https://github.com/python-trio/trio-asyncio/issues/42&quot;&gt;trio-asyncio issue # 42&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/python-trio/trio/issues/649&quot;&gt;trio issue # 649를 참조하십시오&lt;/a&gt; . 코 루틴의 작동 방식에 대한 자세한 내용은 Andr&amp;eacute; Caron의 &lt;a href=&quot;https://github.com/AndreLouisCaron/a-tale-of-event-loops&quot;&gt;이벤트 루프 이야기&lt;/a&gt; 또는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0492/&quot;&gt;PEP 492&lt;/a&gt; 로 직접 이동 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="619d03500f6db41ec6806aedd9a5bd864e1f9ac0" translate="yes" xml:space="preserve">
          <source>And of course these can be mixed and matched at will.</source>
          <target state="translated">물론 이것들은 마음대로 혼합하고 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fe22b10355ca18b089c78c28baddac1ad66a2f8" translate="yes" xml:space="preserve">
          <source>And once you have a reference to a nursery object, you can start children in that nursery:</source>
          <target state="translated">보육원 객체에 대한 참조가 있으면 해당 보육원에서 자녀를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b2e3b297dc48290fb80e82d95bd55ff09a19662" translate="yes" xml:space="preserve">
          <source>And second, it requires two extra keyword arguments: &lt;code&gt;run_sync_soon_threadsafe&lt;/code&gt;, and &lt;code&gt;done_callback&lt;/code&gt;.</source>
          <target state="translated">둘째, &lt;code&gt;run_sync_soon_threadsafe&lt;/code&gt; 및 &lt;code&gt;done_callback&lt;/code&gt; 이라는 두 개의 추가 키워드 인수가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="0c8b7b10833f094016e1717309592388a4e1b78e" translate="yes" xml:space="preserve">
          <source>And second, the cost of a disk operation is incredibly bimodal. Sometimes, the data you need is already cached in RAM, and then accessing it is very, very fast &amp;ndash; calling &lt;a href=&quot;https://docs.python.org/3/library/io.html#io.FileIO&quot;&gt;&lt;code&gt;io.FileIO&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s &lt;code&gt;read&lt;/code&gt; method on a cached file takes on the order of ~1 &amp;micro;s. But when the data isn&amp;rsquo;t cached, then accessing it is much, much slower: the average is ~100 &amp;micro;s for SSDs and ~10,000 &amp;micro;s for spinning disks, and if you look at tail latencies then for both types of storage you&amp;rsquo;ll see cases where occasionally some operation will be 10x or 100x slower than average. And that&amp;rsquo;s assuming your program is the only thing trying to use that disk &amp;ndash; if you&amp;rsquo;re on some oversold cloud VM fighting for I/O with other tenants then who knows what will happen. And some operations can require multiple disk accesses.</source>
          <target state="translated">둘째, 디스크 운영 비용은 엄청나게 양봉입니다. 때로는 필요한 데이터가 이미 RAM에 캐시 된 다음 액세스하는 속도가 매우 빠릅니다 . 캐시 된 파일에서 &lt;a href=&quot;https://docs.python.org/3/library/io.html#io.FileIO&quot;&gt; &lt;code&gt;io.FileIO&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;read&lt;/code&gt; 메서드 호출 은 ~ 1 &amp;micro;s 정도입니다. 그러나 데이터가 캐시되지 않으면 액세스 속도가 훨씬 느려집니다. SSD의 경우 평균은 ~ 100 &amp;micro;s, 회전 디스크의 경우 ~ 10,000 &amp;micro;s이며 꼬리 지연을 보면 두 유형의 스토리지 모두에 대해 때때로 일부 작업이 평균보다 10 배 또는 100 배 느린 경우를 참조하십시오. 그리고 그것은 당신의 프로그램이 그 디스크를 사용하려고하는 유일한 것이라고 가정합니다 &amp;ndash; 만약 당신이 다른 테넌트와 I / O를 위해 과잉 판매 된 클라우드 VM을 사용하고 있다면 어떤 일이 일어날 지 알고 있습니다. 또한 일부 작업에는 여러 디스크 액세스가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e29bc047ae56be469d957dd472bf9803cd55df7" translate="yes" xml:space="preserve">
          <source>And second, the cost of a disk operation is incredibly bimodal. Sometimes, the data you need is already cached in RAM, and then accessing it is very, very fast &amp;ndash; calling &lt;a href=&quot;https://docs.python.org/3/library/io.html#io.FileIO&quot;&gt;&lt;code&gt;io.FileIO&lt;/code&gt;&lt;/a&gt;'s &lt;code&gt;read&lt;/code&gt; method on a cached file takes on the order of ~1 &amp;micro;s. But when the data isn&amp;rsquo;t cached, then accessing it is much, much slower: the average is ~100 &amp;micro;s for SSDs and ~10,000 &amp;micro;s for spinning disks, and if you look at tail latencies then for both types of storage you&amp;rsquo;ll see cases where occasionally some operation will be 10x or 100x slower than average. And that&amp;rsquo;s assuming your program is the only thing trying to use that disk &amp;ndash; if you&amp;rsquo;re on some oversold cloud VM fighting for I/O with other tenants then who knows what will happen. And some operations can require multiple disk accesses.</source>
          <target state="translated">둘째, 디스크 작업 비용은 믿을 수 없을 정도로 이중 모드입니다. 때로는 필요한 데이터가 이미 RAM에 캐시 된 다음 액세스가 매우 빠릅니다 . 캐시 된 파일에서 &lt;a href=&quot;https://docs.python.org/3/library/io.html#io.FileIO&quot;&gt; &lt;code&gt;io.FileIO&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;read&lt;/code&gt; 메서드를 호출 하는 데 약 1&amp;micro;s가 걸립니다. 그러나 데이터가 캐시되지 않으면 액세스 속도가 훨씬 더 느려집니다. 평균은 SSD의 경우 ~ 100&amp;micro;s이고 회전 디스크의 경우 ~ 10,000&amp;micro;s입니다. 테일 지연 시간을 살펴보면 두 유형의 스토리지 모두에 대해 때때로 일부 작업이 평균보다 10 배 또는 100 배 느린 경우를 참조하십시오. 그리고 그것은 당신의 프로그램이 그 디스크를 사용하려는 유일한 것이라고 가정하고 있습니다. 만약 당신이 다른 테넌트들과 I / O를 위해 싸우고있는 과다 판매 된 클라우드 VM을 사용하고 있다면 누가 무슨 일이 일어날 지 알 수 있습니다. 일부 작업에는 여러 디스크 액세스가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="feeca190f93d22f58d615ed4fd1614a4269d6897" translate="yes" xml:space="preserve">
          <source>And then it hangs forever. (Use control-C to quit.)</source>
          <target state="translated">그리고 그것은 영원히 매달려 있습니다. Ctrl-C를 사용하여 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="f681d4ef40605427e77513784560b1bcaa160bb7" translate="yes" xml:space="preserve">
          <source>And then you can encapsulate all this machinery in a utility function that exposes a &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt;-like API, but runs both loops together:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run&lt;/code&gt; &lt;/a&gt; 과 유사한 API 를 노출 하지만 두 루프를 함께 실행 하는 유틸리티 함수에이 모든 기계를 캡슐화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="211d7d50556ec8f345832762c8c8fe21c2c79327" translate="yes" xml:space="preserve">
          <source>And these concrete methods.</source>
          <target state="translated">그리고 이러한 구체적인 방법.</target>
        </trans-unit>
        <trans-unit id="f27d0a8c5e5faf3e87bb41b32a3eb3c34a5ef14f" translate="yes" xml:space="preserve">
          <source>Another approach would be to attempt to connect to all of the addresses at the same time, in parallel, and then use whichever connection succeeds first, abandoning the others. This would be fast, but create a lot of unnecessary load on the network and the remote server.</source>
          <target state="translated">또 다른 방법은 모든 주소에 동시에 병렬로 연결 한 다음 먼저 성공한 연결을 사용하여 다른 연결을 포기하는 것입니다. 이 속도는 빠르지 만 네트워크와 원격 서버에 많은 불필요한로드가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="540e6b0386e96589ef7bf08cc766b92ef3f1c782" translate="yes" xml:space="preserve">
          <source>Another way to think of it: a &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; is like a sofa with a fixed number of seats, and if they&amp;rsquo;re all taken then you have to wait for someone to get up before you can sit down.</source>
          <target state="translated">그것을 생각하는 또 다른 방법 : &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt; 는 고정 된 수의 좌석이있는 소파와 같으며 모두 가져 가면 앉을 수 있기 전에 누군가가 일어나기를 기다려야합니다.</target>
        </trans-unit>
        <trans-unit id="3c598eda8f7e244d58a5c6244a28edd77a41d473" translate="yes" xml:space="preserve">
          <source>Any ordering guarantees apply separately to &lt;code&gt;idempotent=False&lt;/code&gt; and &lt;code&gt;idempotent=True&lt;/code&gt; calls; there&amp;rsquo;s no rule for how calls in the different categories are ordered with respect to each other.</source>
          <target state="translated">모든 주문 보증은 &lt;code&gt;idempotent=False&lt;/code&gt; 및 &lt;code&gt;idempotent=True&lt;/code&gt; 통화에 별도로 적용됩니다 . 서로 다른 범주의 통화가 서로 관련하여 정렬되는 방법에 대한 규칙은 없습니다.</target>
        </trans-unit>
        <trans-unit id="41b988d7261002f6ebec68c073ec1cadb529e763" translate="yes" xml:space="preserve">
          <source>Any required IDNA encoding is handled before calling this function; your implementation can assume that it will never see U-labels like &lt;code&gt;&quot;caf&amp;eacute;.com&quot;&lt;/code&gt;, and only needs to handle A-labels like &lt;code&gt;b&quot;xn--caf-dma.com&quot;&lt;/code&gt;.</source>
          <target state="translated">이 함수를 호출하기 전에 필요한 모든 IDNA 인코딩이 처리됩니다. 구현에서는 &lt;code&gt;&quot;caf&amp;eacute;.com&quot;&lt;/code&gt; 과 같은 U- 라벨을 볼 수 없으며 &lt;code&gt;b&quot;xn--caf-dma.com&quot;&lt;/code&gt; 과 같은 A- 라벨 만 처리 하면된다고 가정 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb6e5d4e2297b46370edf9d7a6dce06b7d28b0e4" translate="yes" xml:space="preserve">
          <source>Any unhandled exceptions are re-raised inside the parent task. If there are multiple exceptions, then they&amp;rsquo;re collected up into a single &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">처리되지 않은 예외는 상위 작업 내에서 다시 발생합니다. 여러 예외가있는 경우 단일 &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; 예외 로 수집됩니다 .</target>
        </trans-unit>
        <trans-unit id="a144cdd6ad89d2a3f0faf4bb094aa9a40f041001" translate="yes" xml:space="preserve">
          <source>Appends the given data to the internal buffer.</source>
          <target state="translated">주어진 데이터를 내부 버퍼에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="41199e1703298a10d2448f0613b291ab0cfa02d6" translate="yes" xml:space="preserve">
          <source>Apply the given &lt;code&gt;handler&lt;/code&gt; to all the exceptions in &lt;code&gt;root_exc&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;handler&lt;/code&gt; 를 &lt;code&gt;root_exc&lt;/code&gt; 의 모든 예외에 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ddb0e258362b5452ce82961901033b9428777b28" translate="yes" xml:space="preserve">
          <source>Arguments and return values are identical to &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getaddrinfo&quot;&gt;&lt;code&gt;socket.getaddrinfo()&lt;/code&gt;&lt;/a&gt;, except that this version is async.</source>
          <target state="translated">인수 및 리턴 값은 이 버전이 비동기라는 점을 제외하고 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getaddrinfo&quot;&gt; &lt;code&gt;socket.getaddrinfo()&lt;/code&gt; &lt;/a&gt; 와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1799c1804f821db693151ce3817c600ec5a0e3f6" translate="yes" xml:space="preserve">
          <source>Arguments and return values are identical to &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getnameinfo&quot;&gt;&lt;code&gt;socket.getnameinfo()&lt;/code&gt;&lt;/a&gt;, except that this version is async.</source>
          <target state="translated">인수와 반환 값은 이 버전이 비동기라는 점을 제외하고 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getnameinfo&quot;&gt; &lt;code&gt;socket.getnameinfo()&lt;/code&gt; &lt;/a&gt; 와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c2c4d14e88fd37145f6bdde6cffa4dfeb02c80f4" translate="yes" xml:space="preserve">
          <source>As a young project, Trio is currently quite aggressive about deprecating and/or removing functionality that we realize was a bad idea. If you use Trio, you should subscribe to &lt;a href=&quot;https://github.com/python-trio/trio/issues/1&quot;&gt;issue #1&lt;/a&gt; to get information about upcoming deprecations and other backwards compatibility breaking changes.</source>
          <target state="translated">어린 프로젝트 인 Trio는 현재 우리가 생각하지 못한 기능을 더 이상 사용하지 않거나 제거하는 데 매우 적극적입니다. Trio를 사용하는 경우, 다가오는 지원 중단 및 기타 이전 버전과의 호환성 변경에 대한 정보를 얻으려면 &lt;a href=&quot;https://github.com/python-trio/trio/issues/1&quot;&gt;문제 # 1&lt;/a&gt; 을 구독해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2d0994996832e530b1ae6097f1cb664a72a0eaff" translate="yes" xml:space="preserve">
          <source>As an example of what this means, here&amp;rsquo;s a small program in which two tasks compete for a lock. Notice that the task which releases the lock always immediately attempts to re-acquire it, before the other task has a chance to run. (And remember that we&amp;rsquo;re doing cooperative multi-tasking here, so it&amp;rsquo;s actually &lt;em&gt;deterministic&lt;/em&gt; that the task releasing the lock will call &lt;a href=&quot;#trio.Lock.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; before the other task wakes up; in Trio releasing a lock is not a checkpoint.) With an unfair lock, this would result in the same task holding the lock forever and the other task being starved out. But if you run this, you&amp;rsquo;ll see that the two tasks politely take turns:</source>
          <target state="translated">이것이 의미하는 바의 예로, 두 가지 작업이 잠금을 위해 경쟁하는 작은 프로그램이 있습니다. 잠금을 해제하는 작업은 다른 작업이 실행되기 전에 항상 즉시 잠금을 다시 획득하려고 시도합니다. (그리고 우리는 여기서 협업 멀티 태스킹을하고 있다는 것을 기억하십시오. 따라서 잠금을 해제하는 작업은 다른 작업이 일어나기 전에 &lt;a href=&quot;#trio.Lock.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 를 호출한다는 것이 &lt;em&gt;결정적&lt;/em&gt; 입니다 . 트리오에서 잠금을 해제하는 것은 체크 포인트가 아닙니다.) 잠금을 유지하면 동일한 작업이 잠금을 영원히 유지하고 다른 작업이 굶주리게됩니다. 그러나 이것을 실행하면 두 가지 작업이 정중하게 번갈아 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="4929afd212841a7b80b8527c2843abff4b732394" translate="yes" xml:space="preserve">
          <source>Async and cancellable variant of &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx&quot;&gt;WaitForSingleObject&lt;/a&gt;. Windows only.</source>
          <target state="translated">&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx&quot;&gt;WaitForSingleObject의&lt;/a&gt; 비동기 및 취소 가능한 변형 . Windows 만 해당</target>
        </trans-unit>
        <trans-unit id="3b88c3f510d5347e19a68032dd5e36b530c8b07c" translate="yes" xml:space="preserve">
          <source>Async cleanup operations &amp;ndash; like &lt;code&gt;__aexit__&lt;/code&gt; methods or async close methods &amp;ndash; are cancellable just like anything else &lt;em&gt;except&lt;/em&gt; that if they are cancelled, they still perform a minimum level of cleanup before raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;__aexit__&lt;/code&gt; 메소드 또는 비동기 닫기 메소드 와 같은 비동기 정리 조작 은 취소 된 경우 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 을 올리기 전에 여전히 최소 정리 레벨을 수행한다는 &lt;em&gt;점&lt;/em&gt; 을 &lt;em&gt;제외하고&lt;/em&gt; 는 다른 것과 마찬가지로 취소 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ce82e511d085dd23f703422ef525137aa3279ed" translate="yes" xml:space="preserve">
          <source>Async file objects can be used as async iterators to iterate over the lines of the file:</source>
          <target state="translated">비동기 파일 객체는 파일의 행을 반복하는 비동기 반복자로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa3c3b6b8715de81fa4c30bebbf1834d4a54fc9d" translate="yes" xml:space="preserve">
          <source>Async file objects implement Trio&amp;rsquo;s &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;AsyncResource&lt;/code&gt;&lt;/a&gt; interface: you close them by calling &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;close&lt;/code&gt; (!!), and they can be used as async context managers. Like all &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; methods, the &lt;code&gt;aclose&lt;/code&gt; method on async file objects is guaranteed to close the file before returning, even if it is cancelled or otherwise raises an error.</source>
          <target state="translated">비동기 파일 개체는 Trio의 &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;AsyncResource&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현합니다 . &lt;code&gt;close&lt;/code&gt; (!!) 대신 &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 닫고 비동기 컨텍스트 관리자로 사용할 수 있습니다. 모든 &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 메소드 와 마찬가지로 , 비동기 파일 객체 의 &lt;code&gt;aclose&lt;/code&gt; 메소드는 파일이 취소되거나 오류가 발생하더라도 리턴하기 전에 파일을 닫도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="5ef2ec7c086db048016785067a80b5c302021dc3" translate="yes" xml:space="preserve">
          <source>Async functions</source>
          <target state="translated">비동기 기능</target>
        </trans-unit>
        <trans-unit id="08b1364a3b00e3d1d3e48fd1bc851545870f5f64" translate="yes" xml:space="preserve">
          <source>Async generators decorated with &lt;code&gt;@asynccontextmanager&lt;/code&gt; to serve as the template for an async context manager are &lt;em&gt;not&lt;/em&gt; subject to this constraint, because &lt;code&gt;@asynccontextmanager&lt;/code&gt; uses them in a limited way that doesn&amp;rsquo;t create problems.</source>
          <target state="translated">장식 비동기 발전기 &lt;code&gt;@asynccontextmanager&lt;/code&gt; 이 있습니다 비동기 컨텍스트 관리자의 템플릿 역할을 &lt;em&gt;하지&lt;/em&gt; 때문에,이 제약에 따라 &lt;code&gt;@asynccontextmanager&lt;/code&gt; 이 문제를 만들지 않습니다 제한된 방식으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ad0ef1eb3a3323f023e10b1311f762ecdd88f1d8" translate="yes" xml:space="preserve">
          <source>Async methods: if any of the following methods are present, then they&amp;rsquo;re re-exported as an async method: &lt;code&gt;flush&lt;/code&gt;, &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;read1&lt;/code&gt;, &lt;code&gt;readall&lt;/code&gt;, &lt;code&gt;readinto&lt;/code&gt;, &lt;code&gt;readline&lt;/code&gt;, &lt;code&gt;readlines&lt;/code&gt;, &lt;code&gt;seek&lt;/code&gt;, &lt;code&gt;tell&lt;/code&gt;, &lt;code&gt;truncate&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;writelines&lt;/code&gt;, &lt;code&gt;readinto1&lt;/code&gt;, &lt;code&gt;peek&lt;/code&gt;, &lt;code&gt;detach&lt;/code&gt;.</source>
          <target state="translated">비동기 메소드 : 다음 메소드 중 하나가 존재하면 비동기 메소드로 다시 내보내집니다. &lt;code&gt;flush&lt;/code&gt; , &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;read1&lt;/code&gt; , &lt;code&gt;readall&lt;/code&gt; , &lt;code&gt;readinto&lt;/code&gt; , &lt;code&gt;readline&lt;/code&gt; , &lt;code&gt;readlines&lt;/code&gt; , &lt;code&gt;seek&lt;/code&gt; , &lt;code&gt;tell&lt;/code&gt; , &lt;code&gt;truncate&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;writelines&lt;/code&gt; , &lt;code&gt;readinto1&lt;/code&gt; , &lt;code&gt;peek&lt;/code&gt; , &lt;code&gt;detach&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df5103c1d76d680bba6764bfa32d48a6b5502e54" translate="yes" xml:space="preserve">
          <source>AsyncResource</source>
          <target state="translated">AsyncResource</target>
        </trans-unit>
        <trans-unit id="334f22a36314907eaa8b814dd48f1292097dd241" translate="yes" xml:space="preserve">
          <source>Asynchronous file interface</source>
          <target state="translated">비동기 파일 인터페이스</target>
        </trans-unit>
        <trans-unit id="56e1586c4db07663ccb34d08c64207ff46c03226" translate="yes" xml:space="preserve">
          <source>Asynchronous file interface.wrapped</source>
          <target state="translated">비동기 파일 인터페이스</target>
        </trans-unit>
        <trans-unit id="0076fe4764abf6551bbbe5999752efce8a89e22f" translate="yes" xml:space="preserve">
          <source>Asynchronous file objects</source>
          <target state="translated">비동기 파일 객체</target>
        </trans-unit>
        <trans-unit id="667673e6e7517b69bb54c30591ebb1af1ea7f64f" translate="yes" xml:space="preserve">
          <source>Asynchronous filesystem I/O</source>
          <target state="translated">비동기 파일 시스템 I / O</target>
        </trans-unit>
        <trans-unit id="1474e40071f7e113106e68f95d2c73a27282f008" translate="yes" xml:space="preserve">
          <source>Asynchronous path objects</source>
          <target state="translated">비동기 경로 객체</target>
        </trans-unit>
        <trans-unit id="546381f9589ee22e6d37c1fe83d5cd5cbd4791b1" translate="yes" xml:space="preserve">
          <source>Asynchronous version of &lt;a href=&quot;https://docs.python.org/3/library/io.html#io.open&quot;&gt;&lt;code&gt;io.open()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비동기 버전 &lt;a href=&quot;https://docs.python.org/3/library/io.html#io.open&quot;&gt; &lt;code&gt;io.open()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64e84334e28bf171e5da15b38a549d66423494e6" translate="yes" xml:space="preserve">
          <source>At that point there are again two possibilities. You can simply ignore the cancellation altogether: wait for the operation to complete and then reschedule and continue as normal. (For example, this is what &lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt; does if cancellation is disabled.) The other possibility is that the &lt;code&gt;abort_func&lt;/code&gt; does succeed in cancelling the operation, but for some reason isn&amp;rsquo;t able to report that right away. (Example: on Windows, it&amp;rsquo;s possible to request that an async (&amp;ldquo;overlapped&amp;rdquo;) I/O operation be cancelled, but this request is &lt;em&gt;also&lt;/em&gt; asynchronous &amp;ndash; you don&amp;rsquo;t find out until later whether the operation was actually cancelled or not.) To report a delayed cancellation, then you should reschedule the task yourself, and call the &lt;code&gt;raise_cancel&lt;/code&gt; callback passed to &lt;code&gt;abort_func&lt;/code&gt; to raise a &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; (or possibly &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt;) exception into this task. Either of the approaches sketched below can work:</source>
          <target state="translated">이 시점에서 다시 두 가지 가능성이 있습니다. 취소를 완전히 무시할 수 있습니다. 작업이 완료 될 때까지 기다렸다가 일정을 조정하고 정상적으로 계속하십시오. (예를 들어, 취소가 비활성화 된 경우 &lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt; 가 수행합니다.) 다른 가능성은 &lt;code&gt;abort_func&lt;/code&gt; 가 작업 취소에 성공했지만 어떤 이유로 든이를 즉시보고 할 수 없다는 것입니다. (예 : Windows에서는 비동기 ( &quot;오버랩&quot;) I / O 작업을 취소하도록 요청할 수 있지만이 요청 &lt;em&gt;도&lt;/em&gt; 비동기 적입니다. 나중에 작업이 실제로 취소되었는지 여부를 알 수 없습니다.) 지연된 취소를보고하려면 직접 작업 일정을 조정하고 &lt;code&gt;raise_cancel&lt;/code&gt; 을 호출해야 합니다.콜백이 &lt;code&gt;abort_func&lt;/code&gt; 에 전달 되어이 작업 에 대해 &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; ) 예외가 발생했습니다. 아래 스케치 된 접근법 중 하나가 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="687169aaa57a138b6171d6746f9a863ca2e934f3" translate="yes" xml:space="preserve">
          <source>At the other extreme, you can make the buffer unbounded by using &lt;code&gt;open_memory_channel(math.inf)&lt;/code&gt;. In this case, &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt;&lt;em&gt;always&lt;/em&gt; returns immediately. Normally, this is a bad idea. To see why, consider a program where the producer runs more quickly than the consumer:</source>
          <target state="translated">다른 극단적 인 경우 &lt;code&gt;open_memory_channel(math.inf)&lt;/code&gt; 사용하여 버퍼를 무제한으로 만들 수 있습니다 . 이 경우 &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 항상&lt;/em&gt; 즉시 반환합니다. 일반적으로 이것은 나쁜 생각입니다. 이유를 알아 보려면 생산자가 소비자보다 더 빨리 실행되는 프로그램을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="1b29268e4999b2744baea8d80b18e3580ca47d69" translate="yes" xml:space="preserve">
          <source>At this stage you should be able to run a simple Trio program inside your host loop. Now we&amp;rsquo;ll turn that prototype into something solid.</source>
          <target state="translated">이 단계에서 호스트 루프 내에서 간단한 Trio 프로그램을 실행할 수 있어야합니다. 이제 우리는 그 프로토 타입을 견고한 것으로 바꿀 것입니다.</target>
        </trans-unit>
        <trans-unit id="b3c94195e485ebf930152b3b8ee9cf75902195a0" translate="yes" xml:space="preserve">
          <source>Attempt to acquire the lock, without blocking.</source>
          <target state="translated">차단하지 않고 잠금을 획득하려고합니다.</target>
        </trans-unit>
        <trans-unit id="222d279c3d693f924ccc7de907d970a895a42260" translate="yes" xml:space="preserve">
          <source>Attempt to acquire the underlying lock, without blocking.</source>
          <target state="translated">차단하지 않고 기본 잠금을 획득하려고합니다.</target>
        </trans-unit>
        <trans-unit id="ef0a1a4841da5c985f3f0b3eae640e79b9971ed9" translate="yes" xml:space="preserve">
          <source>Attempt to decrement the semaphore value, without blocking.</source>
          <target state="translated">차단하지 않고 세마포어 값을 낮추십시오.</target>
        </trans-unit>
        <trans-unit id="ec34329b732495345fe5c3d52450653e57f36518" translate="yes" xml:space="preserve">
          <source>Attempt to receive an incoming object, blocking if necessary.</source>
          <target state="translated">들어오는 객체를 받으려고 시도하고 필요한 경우 차단합니다.</target>
        </trans-unit>
        <trans-unit id="cf506448c157bc98fe2eec29fc3993723c6b3208" translate="yes" xml:space="preserve">
          <source>Attempt to send an object through the channel, blocking if necessary.</source>
          <target state="translated">채널을 통해 객체를 보내려고 시도하고 필요한 경우 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="a4d81396d4ea19197dfceaa774ef776332674285" translate="yes" xml:space="preserve">
          <source>Attribution</source>
          <target state="translated">Attribution</target>
        </trans-unit>
        <trans-unit id="1d5232d8974b6129a9030ab048587c67ca7be343" translate="yes" xml:space="preserve">
          <source>Avoid instantiating &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;code&gt;ssl.SSLContext&lt;/code&gt;&lt;/a&gt; directly. A newly constructed &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; has less secure defaults than one returned by &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt;&lt;code&gt;ssl.create_default_context()&lt;/code&gt;&lt;/a&gt;, dramatically so before Python 3.6.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt; &lt;code&gt;ssl.SSLContext&lt;/code&gt; 를&lt;/a&gt; 직접 인스턴스화하지 마십시오 . 새로 생성 된 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt; &lt;code&gt;ssl.create_default_context()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 것보다 안전하지 않은 기본값을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba279a92ffbafb8cc72dbd38711f804d9d1b907b" translate="yes" xml:space="preserve">
          <source>Avoids implicitly chaining the &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BlockingIOError&quot;&gt;&lt;code&gt;BlockingIOError&lt;/code&gt;&lt;/a&gt; with any errors raised by &lt;code&gt;attempt_operation&lt;/code&gt; or &lt;code&gt;wait_for_operation_to_be_ready&lt;/code&gt;, by keeping the &lt;code&gt;while True:&lt;/code&gt; loop outside of the &lt;code&gt;except BlockingIOError:&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;while True:&lt;/code&gt; &lt;code&gt;except BlockingIOError:&lt;/code&gt; 블록 외부에 while True : 루프 를 유지하여 &lt;code&gt;attempt_operation&lt;/code&gt; 또는 &lt;code&gt;wait_for_operation_to_be_ready&lt;/code&gt; 에 의해 발생한 오류로 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BlockingIOError&quot;&gt; &lt;code&gt;BlockingIOError&lt;/code&gt; &lt;/a&gt; 를 암시 적으로 연결 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8454897360da80a161dfa5cca2e92c24c7087979" translate="yes" xml:space="preserve">
          <source>Awesome Trio Libraries</source>
          <target state="translated">멋진 트리오 라이브러리</target>
        </trans-unit>
        <trans-unit id="31c7739aa209904fd9ba8df9b1d7877f93e87a25" translate="yes" xml:space="preserve">
          <source>Background: Why is async file I/O useful? The answer may surprise you</source>
          <target state="translated">배경 : 비동기 파일 I / O가 유용한 이유는 무엇입니까? 대답은 당신을 놀라게 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="db8c739d137036e869b27d3cd349fef1d54e3fdc" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;trio.abc.AsyncResource&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">베이스 : &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;trio.abc.AsyncResource&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e1388bfa18042159b536ccc6a59591396e82930" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt;&lt;code&gt;trio.abc.AsyncResource&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3/library/typing.html#typing.Generic&quot;&gt;&lt;code&gt;typing.Generic&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">기본 : &lt;a href=&quot;#trio.abc.AsyncResource&quot;&gt; &lt;code&gt;trio.abc.AsyncResource&lt;/code&gt; &lt;/a&gt; , 입력. &lt;a href=&quot;https://docs.python.org/3/library/typing.html#typing.Generic&quot;&gt; &lt;code&gt;typing.Generic&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a07e9c5dc09b0fdf3f845a0fb5af7389bc3e353" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;trio.abc.HalfCloseableStream&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">베이스 : &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;trio.abc.HalfCloseableStream&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d77761b5945e21f05a6d9cadcfc66f09270cc4b" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;code&gt;trio.abc.Listener&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">베이스 : &lt;a href=&quot;#trio.abc.Listener&quot;&gt; &lt;code&gt;trio.abc.Listener&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f328a04e58d3412dae1f568fe492e46d265a0c88" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;#trio.abc.SendChannel&quot;&gt;&lt;code&gt;trio.abc.SendChannel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;trio.abc.ReceiveChannel&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">베이스 : &lt;a href=&quot;#trio.abc.SendChannel&quot;&gt; &lt;code&gt;trio.abc.SendChannel&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;trio.abc.ReceiveChannel&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92038ea6f8a928181a4be9c9cf1e7731b00e53e5" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;trio.abc.SendStream&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;trio.abc.ReceiveStream&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">베이스 : &lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;trio.abc.SendStream&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;trio.abc.ReceiveStream&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8714f32f570efd29c979c0a1881e76c7d8b385e4" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;trio.abc.Stream&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">베이스 : &lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;trio.abc.Stream&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7267bc2117470326945d1c053489fd33d1ef228e" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#FutureWarning&quot;&gt;&lt;code&gt;FutureWarning&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">기지 : &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#FutureWarning&quot;&gt; &lt;code&gt;FutureWarning&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5134303d2391790237c513240fb89f5fad90b2ad" translate="yes" xml:space="preserve">
          <source>Bases: &lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt;&lt;code&gt;trio.abc.Stream&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">베이스 : &lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt; &lt;code&gt;trio.abc.Stream&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="13b5e07d4d8d4268f2b1632299d27a69609c9e40" translate="yes" xml:space="preserve">
          <source>Basically the idea is that if you have code or tests that use sleeps and timeouts, you can use this to make it run much faster, totally automatically. (At least, as long as those sleeps/timeouts are happening inside Trio; if your test involves talking to external service and waiting for it to timeout then obviously we can&amp;rsquo;t help you there.)</source>
          <target state="translated">기본적으로 아이디어는 휴면 및 시간 초과를 사용하는 코드 또는 테스트가있는 경우이를 사용하여 훨씬 더 빠르게 완전히 자동으로 실행할 수 있다는 것입니다. (적어도 해당 휴면 / 시간 초과가 Trio 내부에서 발생하는 한 테스트에 외부 서비스와 대화하고 시간 초과를 기다리는 경우 분명히 도움을 줄 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="4390bc06787e8e996759d199f6a1f87bed1460ad" translate="yes" xml:space="preserve">
          <source>Be very careful to only use this decorator on functions that you know will either exit in bounded time, or else pass through a checkpoint regularly. (Of course all of your functions should have this property, but if you mess it up here then you won&amp;rsquo;t even be able to use control-C to escape!)</source>
          <target state="translated">이 데코레이터는 제한된 시간 안에 종료되거나 정기적으로 체크 포인트를 통과 할 것으로 알려진 함수에만 사용하십시오. (물론 모든 함수에는이 속성이 있어야하지만 여기서 엉망으로 만들면 control-C를 사용하여 벗어날 수도 없습니다!)</target>
        </trans-unit>
        <trans-unit id="06d5f3f1b9945bb166f25991150d1b99d9ed96ec" translate="yes" xml:space="preserve">
          <source>Because worker threads are cached and reused for multiple calls, neither function should mutate thread-level state, like &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.local&quot;&gt;&lt;code&gt;threading.local&lt;/code&gt;&lt;/a&gt; objects &amp;ndash; or if they do, they should be careful to revert their changes before returning.</source>
          <target state="translated">작업자 스레드는 캐시되고 여러 호출에 재사용되기 때문에 어떤 함수도 &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.local&quot;&gt; &lt;code&gt;threading.local&lt;/code&gt; &lt;/a&gt; 객체 와 같은 스레드 수준 상태를 변경해서는 안됩니다. 그렇지 않으면 반환하기 전에 변경 사항을 되돌 리도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="f9a3eaabb5b822719bebd3e8a1b70ac9540e12dc" translate="yes" xml:space="preserve">
          <source>Before the child calls &lt;code&gt;task_status.started()&lt;/code&gt;, it&amp;rsquo;s effectively run underneath the call to &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt;: if it raises an exception then that exception is reported by &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt;, and does &lt;em&gt;not&lt;/em&gt; propagate out of the nursery. If &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; is cancelled, then the child task is also cancelled.</source>
          <target state="translated">자식이 &lt;code&gt;task_status.started()&lt;/code&gt; 호출하기 전에 &lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 호출 아래에서 효과적으로 실행 됩니다. 예외가 발생하면 해당 예외가 &lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 의해보고되고 보육원에서 전파 되지 &lt;em&gt;않습니다&lt;/em&gt; . 경우 &lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 취소 된 후 자식 작업은 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="b4738e9dc47bf1e56e7606833bf5d66a428561b1" translate="yes" xml:space="preserve">
          <source>Before you begin</source>
          <target state="translated">시작하기 전에</target>
        </trans-unit>
        <trans-unit id="6884e4f2d15ab622c9f8cbc3212f45de64615bea" translate="yes" xml:space="preserve">
          <source>Block until it&amp;rsquo;s possible that &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; might not block.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; 이 차단 될 수있을 때까지 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="17ae3ed338c93b1631e5994bf9cacece02cc9e67" translate="yes" xml:space="preserve">
          <source>Block until the internal flag value becomes True.</source>
          <target state="translated">내부 플래그 값이 True가 될 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="315b58797295c4e9ab36672b064ff4cedf0b8cef" translate="yes" xml:space="preserve">
          <source>Block until the kernel reports that the given object is readable.</source>
          <target state="translated">커널이 주어진 객체를 읽을 수 있다고보고 할 때까지 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="c30db991fe44ffdb355948594f4b7365cf09c9d1" translate="yes" xml:space="preserve">
          <source>Block until the kernel reports that the given object is writable.</source>
          <target state="translated">커널이 주어진 객체가 쓰기 가능하다고보고 할 때까지 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="fdf86495cf9c07d20eda78e1274970ceb5c363a7" translate="yes" xml:space="preserve">
          <source>Block until the process exits.</source>
          <target state="translated">프로세스가 종료 될 때까지 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="6ff527ef5176f8e0ddcdc55991a82729810d38d5" translate="yes" xml:space="preserve">
          <source>Block until there are no runnable tasks.</source>
          <target state="translated">실행 가능한 작업이 없을 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="caa9b1343024d62a02aab103e75d10940fa49af7" translate="yes" xml:space="preserve">
          <source>Blocking and non-blocking methods</source>
          <target state="translated">차단 및 비 차단 방법</target>
        </trans-unit>
        <trans-unit id="84ce31b1f7f4ca1f1ba81c9b7ae32f8c48ff831b" translate="yes" xml:space="preserve">
          <source>Borrow a token from the sack on behalf of &lt;code&gt;borrower&lt;/code&gt;, blocking if necessary.</source>
          <target state="translated">&lt;code&gt;borrower&lt;/code&gt; 를 대신하여 자루에서 토큰을 빌려 필요한 경우 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="7b27cb01fa52d37acba5b81c12f4fcd1e8bf0f72" translate="yes" xml:space="preserve">
          <source>Borrow a token from the sack on behalf of &lt;code&gt;borrower&lt;/code&gt;, without blocking.</source>
          <target state="translated">&lt;code&gt;borrower&lt;/code&gt; 를 대신하여 자루에서 토큰을 빌리지 않고 차용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e07ec7dd71dfd4d21fe8bb1251d8339701ccce3" translate="yes" xml:space="preserve">
          <source>Borrow a token from the sack, blocking if necessary.</source>
          <target state="translated">자루에서 토큰을 빌려 필요한 경우 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="d7f7be4a505172b9a7559a09e6a12361762ade09" translate="yes" xml:space="preserve">
          <source>Borrow a token from the sack, without blocking.</source>
          <target state="translated">차단하지 않고 자루에서 토큰을 빌립니다.</target>
        </trans-unit>
        <trans-unit id="f1496c7a3db3e007c3057cc8783649b651817057" translate="yes" xml:space="preserve">
          <source>Both hooks are also exposed as attributes on the object, and you can change them at any time.</source>
          <target state="translated">두 후크 모두 객체의 속성으로 표시되며 언제든지 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dfefbef8c6a0e9381ea95ae6338587f901c36ba" translate="yes" xml:space="preserve">
          <source>Broadcasting an event with &lt;a href=&quot;#trio.Event&quot;&gt;&lt;code&gt;Event&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이벤트로 &lt;a href=&quot;#trio.Event&quot;&gt; &lt;code&gt;Event&lt;/code&gt; &lt;/a&gt; 브로드 캐스팅</target>
        </trans-unit>
        <trans-unit id="352d325bf39240b4196dfbd3a6f4f8e3e54c1c98" translate="yes" xml:space="preserve">
          <source>Buffering in channels</source>
          <target state="translated">채널 버퍼링</target>
        </trans-unit>
        <trans-unit id="5615f1a1d3e7ea5900f404cdff5bd7a1d2d99a9e" translate="yes" xml:space="preserve">
          <source>Bug tracker and source code: &lt;a href=&quot;https://github.com/python-trio/trio&quot;&gt;https://github.com/python-trio/trio&lt;/a&gt;</source>
          <target state="translated">버그 추적기 및 소스 코드 : &lt;a href=&quot;https://github.com/python-trio/trio&quot;&gt;https://github.com/python-trio/trio&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c035fa8490c2afc614e7fdb48a89a8853084e7fa" translate="yes" xml:space="preserve">
          <source>Building Command Line Apps</source>
          <target state="translated">명령 줄 앱 빌드</target>
        </trans-unit>
        <trans-unit id="6c85441cc2270b299d4d728765785da223b4dbba" translate="yes" xml:space="preserve">
          <source>But even more interestingly, you can set &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt;&lt;code&gt;autojump_threshold&lt;/code&gt;&lt;/a&gt; to zero or a small value, and then it will watch the execution of the run loop, and any time things have settled down and everyone&amp;rsquo;s waiting for a timeout, it jumps the clock forward to that timeout. In many cases this allows natural-looking code involving timeouts to be automatically run at near full CPU utilization with no changes. (Thanks to &lt;a href=&quot;https://github.com/majek/fluxcapacitor&quot;&gt;fluxcapacitor&lt;/a&gt; for this awesome idea.)</source>
          <target state="translated">그러나 더 흥미롭게도 &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt; &lt;code&gt;autojump_threshold&lt;/code&gt; &lt;/a&gt; 를 0 또는 작은 값으로 설정할 수 있습니다. 그런 다음 실행 루프의 실행을보고 모든 일이 해결되고 모든 사람이 시간 초과를 기다리는 동안 시계가 해당 시간 초과로 이동합니다. . 대부분의 경우 타임 아웃과 관련된 자연스럽게 보이는 코드를 거의 전체 CPU 사용률로 변경없이 자동으로 실행할 수 있습니다. ( 이 멋진 아이디어에 대한 &lt;a href=&quot;https://github.com/majek/fluxcapacitor&quot;&gt;플럭스 커패시터&lt;/a&gt; 덕분 입니다.)</target>
        </trans-unit>
        <trans-unit id="c336aec89fecde4ca2a292b930cbc2263a0dcb64" translate="yes" xml:space="preserve">
          <source>But here&amp;rsquo;s the problem: for any individual I/O operation, there&amp;rsquo;s no way to know in advance whether it&amp;rsquo;s going to be one of the fast ones or one of the slow ones, so you can&amp;rsquo;t pick and choose. When you switch to async file I/O, it makes all the fast operations slower, and all the slow operations faster. Is that a win? In terms of overall speed, it&amp;rsquo;s hard to say: it depends what kind of disks you&amp;rsquo;re using and your kernel&amp;rsquo;s disk cache hit rate, which in turn depends on your file access patterns, how much spare RAM you have, the load on your service, &amp;hellip; all kinds of things. If the answer is important to you, then there&amp;rsquo;s no substitute for measuring your code&amp;rsquo;s actual behavior in your actual deployment environment. But what we &lt;em&gt;can&lt;/em&gt; say is that async disk I/O makes performance much more predictable across a wider range of runtime conditions.</source>
          <target state="translated">그러나 여기에 문제가 있습니다. 개별 I / O 작업의 경우 빠른 작업 중 하나인지 느린 작업 중 하나인지 미리 알 방법이 없으므로 선택 및 선택할 수 없습니다. 비동기 파일 I / O로 전환하면 모든 빠른 작업이 느려지고 모든 느린 작업이 빨라집니다. 그게 승리입니까? 전체 속도 측면에서 말하기는 어렵습니다. 사용하는 디스크 종류와 커널의 디스크 캐시 적중률에 따라 달라집니다. 이는 파일 액세스 패턴, 사용 가능한 예비 RAM의 양, 부하에 따라 다릅니다. 서비스,&amp;hellip; 모든 종류의 것들. 답이 중요하다면 실제 배포 환경에서 코드의 실제 동작을 측정 할 수있는 방법은 없습니다. 그러나 우리가 &lt;em&gt;할 수있는 것&lt;/em&gt; 비동기 디스크 I / O는 광범위한 런타임 조건에서 성능을 훨씬 더 예측 가능하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="673eaaa36b6ee6e4487e1b49cb9a7a9b9b02d009" translate="yes" xml:space="preserve">
          <source>But if we want to write correct code in practice, then this principle is a little too sloppy and imprecise to be useful. How do we know which functions might block? What if a function blocks sometimes, but not others, depending on the arguments passed / network speed / phase of the moon? How do we figure out where the checkpoints are when we&amp;rsquo;re stressed and sleep deprived but still want to get this code review right, and would prefer to reserve our mental energy for thinking about the actual logic instead of worrying about checkpoints?</source>
          <target state="translated">그러나 실제로 올바른 코드를 작성하려면이 원칙이 너무 부끄럽고 유용하지 않습니다. 어떤 기능이 차단 될 수 있는지 어떻게 알 수 있습니까? 전달 된 인수 / 네트워크 속도 / 달의 인수에 따라 함수가 때때로 차단하지만 다른 것은 차단하지 않으면 어떻게됩니까? 스트레스를 받고 수면이 부족하지만 여전히이 코드 검토를 제대로 받고 싶을 때 체크 포인트의 위치를 ​​어떻게 알 수 있으며 체크 포인트에 대한 걱정 대신 실제 논리에 대해 생각하기 위해 정신적 에너지를 보존하고 싶습니까?</target>
        </trans-unit>
        <trans-unit id="28b63c1792b2c52de75b3ab70de595321eeb55ea" translate="yes" xml:space="preserve">
          <source>But if you read the docs for &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt;&lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt;, you&amp;rsquo;ll see that all the pieces involved in wiring this up are public APIs, so you can adjust to suit the requirements of your tests. For example, here&amp;rsquo;s how to tweak a stream so that data flowing from left to right trickles in one byte at a time (but data flowing from right to left proceeds at full speed):</source>
          <target state="translated">그러나 &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt; &lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; 대한 문서를 읽으면 이 배선에 관련된 모든 부분이 공용 API이므로 테스트 요구 사항에 맞게 조정할 수 있습니다. 예를 들어, 왼쪽에서 오른쪽으로 흐르는 데이터가 한 번에 한 바이트 씩 흐르도록 스트림을 조정하는 방법은 다음과 같습니다 (그러나 오른쪽에서 왼쪽으로 흐르는 데이터는 최대 속도로 진행됨).</target>
        </trans-unit>
        <trans-unit id="f830b9d400aed457d194359f0503b1ff2760384a" translate="yes" xml:space="preserve">
          <source>But of course, Trio isn&amp;rsquo;t the only coroutine runner in Python &amp;ndash; &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html#module-asyncio&quot;&gt;&lt;code&gt;asyncio&lt;/code&gt;&lt;/a&gt; has one, other event loops have them, you can even define your own.</source>
          <target state="translated">물론 Trio는 파이썬에서 유일한 코 루틴 러너가 아닙니다. &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html#module-asyncio&quot;&gt; &lt;code&gt;asyncio&lt;/code&gt; &lt;/a&gt; 에는 하나의 이벤트 루프가 있으며 다른 이벤트 루프에도 자신 만의 것을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fceeabff672914a12928d15cad77ad846e4d22d" translate="yes" xml:space="preserve">
          <source>But this can be problematic. If you&amp;rsquo;re using h2 then &lt;em&gt;usually&lt;/em&gt; reading incoming data doesn&amp;rsquo;t create the need to send any data, so we don&amp;rsquo;t want to force every task that tries to read from the network to sit and wait a potentially long time for &lt;code&gt;sendall&lt;/code&gt; to finish. And in some situations this could even potentially cause a deadlock, if the remote peer is waiting for you to read some data before it accepts the data you&amp;rsquo;re sending.</source>
          <target state="translated">그러나 이것은 문제가 될 수 있습니다. h2를 사용하는 경우 &lt;em&gt;일반적으로&lt;/em&gt; 들어오는 데이터를 읽더라도 데이터를 보낼 필요가 없으므로 네트워크에서 읽으려고 시도하는 모든 작업이 &lt;code&gt;sendall&lt;/code&gt; 을 기다리는 시간이 길고 기다리도록 강요하지 않습니다. 끝. 원격 피어가 전송중인 데이터를 수락하기 전에 일부 데이터 읽기를 기다리는 경우 상황에 따라 교착 상태가 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="412c1b16e781ad814146eddc07e4fd649b546625" translate="yes" xml:space="preserve">
          <source>But this is more error-prone, especially if you use a loop to spawn the producers/consumers.</source>
          <target state="translated">그러나 루프를 사용하여 생산자 / 소비자를 생성하는 경우 특히 오류가 발생하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="3d71f7e1b353d405d0ac11988a391e51c106c8d8" translate="yes" xml:space="preserve">
          <source>But this is not:</source>
          <target state="translated">그러나 이것은 다음이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="530bcde7f320efe9c1c4e3043d433d9a24c64568" translate="yes" xml:space="preserve">
          <source>But, even if that happens, we&amp;rsquo;re not out of the woods yet! After the producers exit, the two consumers race to be the first to notice that the &lt;code&gt;send_channel&lt;/code&gt; has closed. Suppose that X wins the race. It exits its &lt;code&gt;async for&lt;/code&gt; loop, then exits the &lt;code&gt;async with&lt;/code&gt; block&amp;hellip; and closes the &lt;code&gt;receive_channel&lt;/code&gt;, while Y is still using it. Again, this causes a crash.</source>
          <target state="translated">그러나 그렇게 되더라도 우리는 아직 숲에서 벗어난 것이 아닙니다! 생산자가 종료 한 후 두 소비자는 &lt;code&gt;send_channel&lt;/code&gt; 이 닫 혔음 을 가장 먼저 알립니다 . X가 경쟁에서 이긴다고 가정하십시오. 그것은 그것의 종료 &lt;code&gt;async for&lt;/code&gt; 이어서, 루프를 종료 &lt;code&gt;async with&lt;/code&gt; 블록 ... 및 폐쇄 &lt;code&gt;receive_channel&lt;/code&gt; 를 Y를 여전히 사용하는 동안. 다시 말하지만 충돌이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="16f5c9c07cafa159b445098218243944b7cef14f" translate="yes" xml:space="preserve">
          <source>But, of course, the entire point of an async library is to let you do multiple things at once. The one and only way to do that in Trio is through the task spawning interface. So if you want your program to walk &lt;em&gt;and&lt;/em&gt; chew gum, this is the section for you.</source>
          <target state="translated">물론 비동기 라이브러리의 요점은 한 번에 여러 작업을 수행하는 것입니다. Trio에서이를 수행하는 유일한 방법은 작업 생성 인터페이스를 사용하는 것입니다. 그래서 당신은 당신의 프로그램이 걸어하려는 경우 &lt;em&gt;와&lt;/em&gt; 씹는 껌, 이것은 당신을위한 섹션이다.</target>
        </trans-unit>
        <trans-unit id="cee30afa981a26373f31e7b52c0c41245b25ffc3" translate="yes" xml:space="preserve">
          <source>But, only one event loop can use &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt;&lt;code&gt;signal.set_wakeup_fd&lt;/code&gt;&lt;/a&gt; at a time. And in guest mode that can cause problems: Trio and the host loop might start fighting over who&amp;rsquo;s using &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt;&lt;code&gt;signal.set_wakeup_fd&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그러나 한 번에 하나의 이벤트 루프 만 &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt; &lt;code&gt;signal.set_wakeup_fd&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 . 그리고 문제를 일으킬 수있는 게스트 모드에서 : Trio와 호스트 루프가 &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt; &lt;code&gt;signal.set_wakeup_fd&lt;/code&gt; 를&lt;/a&gt; 사용하는 사람을 두고 싸우기 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="14bf733dd8733198e6f96380ba6e416701693b07" translate="yes" xml:space="preserve">
          <source>But, there&amp;rsquo;s a nice optimization we can make: we only &lt;em&gt;need&lt;/em&gt; the thread when our &lt;code&gt;sleep_until_something_happens()&lt;/code&gt; call actually sleeps, that is, when the Trio part of your program is idle and has nothing to do. So before we switch into the worker thread, we double-check whether we&amp;rsquo;re idle, and if not, then we skip the worker thread and jump directly to step 2. This means that your app only pays the extra thread-switching penalty at moments when it would otherwise be sleeping, so it should have minimal effect on your app&amp;rsquo;s overall performance.</source>
          <target state="translated">그러나 우리가 만들 수있는 멋진 최적화가 있습니다. &lt;code&gt;sleep_until_something_happens()&lt;/code&gt; 호출이 실제로 잠자기 , 즉 프로그램의 Trio 부분이 유휴 상태이고 할 일이 없을 때만 스레드 &lt;em&gt;가 필요&lt;/em&gt; 합니다 . 따라서 작업자 스레드로 전환하기 전에 유휴 상태인지 다시 확인하고 그렇지 않은 경우 작업자 스레드를 건너 뛰고 2 단계로 바로 이동합니다. 즉, 앱은 다음 위치에서 추가 스레드 전환 패널티 만 지불합니다. 그렇지 않으면 잠자기 상태 일 때 앱의 전반적인 성능에 최소한의 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="08e147f3bc16786707a8ac015a5f1b0329a64f59" translate="yes" xml:space="preserve">
          <source>By convention, a return code of zero indicates success. On UNIX, negative values indicate termination due to a signal, e.g., -11 if terminated by signal 11 (&lt;code&gt;SIGSEGV&lt;/code&gt;). On Windows, a process that exits due to a call to &lt;a href=&quot;#trio.Process.terminate&quot;&gt;&lt;code&gt;Process.terminate()&lt;/code&gt;&lt;/a&gt; will have an exit status of 1.</source>
          <target state="translated">일반적으로 리턴 코드 0은 성공을 나타냅니다. UNIX에서 음수 값은 신호로 인한 종료를 나타냅니다 (예 : 신호 11 ( &lt;code&gt;SIGSEGV&lt;/code&gt; )로 종료 된 경우 -11 ). Windows에서 &lt;a href=&quot;#trio.Process.terminate&quot;&gt; &lt;code&gt;Process.terminate()&lt;/code&gt; &lt;/a&gt; 호출로 인해 종료되는 프로세스 는 종료 상태가 1입니다.</target>
        </trans-unit>
        <trans-unit id="3a7a80e6ffbfb28cc8f945974fc47d089de603d5" translate="yes" xml:space="preserve">
          <source>By default for TCP sockets, &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt; enables &lt;code&gt;TCP_NODELAY&lt;/code&gt;, and (on platforms where it&amp;rsquo;s supported) enables &lt;code&gt;TCP_NOTSENT_LOWAT&lt;/code&gt; with a reasonable buffer size (currently 16 KiB) &amp;ndash; see &lt;a href=&quot;https://github.com/python-trio/trio/issues/72&quot;&gt;issue #72&lt;/a&gt; for discussion. You can of course override these defaults by calling &lt;a href=&quot;#trio.SocketStream.setsockopt&quot;&gt;&lt;code&gt;setsockopt()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">TCP 소켓의 경우 기본적으로 &lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;TCP_NODELAY&lt;/code&gt; 를 활성화 하고 지원되는 플랫폼에서 &lt;code&gt;TCP_NOTSENT_LOWAT&lt;/code&gt; 를 적당한 버퍼 크기 (현재 16KiB )로 활성화 합니다. 자세한 내용은 &lt;a href=&quot;https://github.com/python-trio/trio/issues/72&quot;&gt;문제 # 72&lt;/a&gt; 를 참조하십시오 . 물론 &lt;a href=&quot;#trio.SocketStream.setsockopt&quot;&gt; &lt;code&gt;setsockopt()&lt;/code&gt; &lt;/a&gt; 를 호출하여 이러한 기본값을 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60f1cefb4d269d53a93fd1da99c35ecbcaa23759" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt; uses a &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; to limit the number of threads running at once; see &lt;a href=&quot;#trio.to_thread.current_default_thread_limiter&quot;&gt;&lt;code&gt;trio.to_thread.current_default_thread_limiter&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt; 를 사용하여 한 번에 실행되는 스레드 수를 제한합니다. 자세한 내용은 &lt;a href=&quot;#trio.to_thread.current_default_thread_limiter&quot;&gt; &lt;code&gt;trio.to_thread.current_default_thread_limiter&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4c3803918afd87af40a3c54ba467ad96a022695e" translate="yes" xml:space="preserve">
          <source>By default, Trio assumes that your host loop doesn&amp;rsquo;t use &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt;&lt;code&gt;signal.set_wakeup_fd&lt;/code&gt;&lt;/a&gt;. It does try to detect when this creates a conflict with the host loop, and print a warning &amp;ndash; but unfortunately, by the time it detects it, the damage has already been done. So if you&amp;rsquo;re getting this warning, then you should disable Trio&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt;&lt;code&gt;signal.set_wakeup_fd&lt;/code&gt;&lt;/a&gt; support by passing &lt;code&gt;host_uses_signal_set_wakeup_fd=True&lt;/code&gt; to &lt;a href=&quot;#trio.lowlevel.start_guest_run&quot;&gt;&lt;code&gt;start_guest_run&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본적으로 Trio는 호스트 루프가 &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt; &lt;code&gt;signal.set_wakeup_fd&lt;/code&gt; 를&lt;/a&gt; 사용하지 않는다고 가정합니다 . 이로 인해 호스트 루프와 충돌이 발생하는시기를 감지하고 경고를 인쇄하려고합니다.하지만 불행히도 감지 할 때까지 이미 손상이 발생한 것입니다. 따라서이 경고가 표시되면 &lt;code&gt;host_uses_signal_set_wakeup_fd=True&lt;/code&gt; 를 &lt;a href=&quot;#trio.lowlevel.start_guest_run&quot;&gt; &lt;code&gt;start_guest_run&lt;/code&gt; &lt;/a&gt; 에 전달하여 Trio의 &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt; &lt;code&gt;signal.set_wakeup_fd&lt;/code&gt; &lt;/a&gt; 지원을 비활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6f9393fd07494846f3c9bd78e82bb2a27abf584b" translate="yes" xml:space="preserve">
          <source>By default, Trio uses an unspecified monotonic clock, but this can be changed by passing a custom clock object to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; (e.g. for testing).</source>
          <target state="translated">기본적으로 Trio는 지정되지 않은 단조로운 시계를 사용하지만 사용자 정의 시계 객체를 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 에 전달하여 (예 : 테스트) 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="479052e549b38b3cf5c8f080e4bba3e93ef2d967" translate="yes" xml:space="preserve">
          <source>By default, Trio&amp;rsquo;s &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt;&lt;code&gt;getnameinfo()&lt;/code&gt;&lt;/a&gt; functions use the standard system resolver functions. This function allows you to customize that behavior. The main intended use case is for testing, but it might also be useful for using third-party resolvers like &lt;a href=&quot;https://c-ares.haxx.se/&quot;&gt;c-ares&lt;/a&gt; (though be warned that these rarely make perfect drop-in replacements for the system resolver). See &lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt;&lt;code&gt;trio.abc.HostnameResolver&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">기본적으로 Trio의 &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt; &lt;code&gt;getnameinfo()&lt;/code&gt; &lt;/a&gt; 함수는 표준 시스템 확인자 함수를 사용합니다. 이 기능을 사용하면 해당 동작을 사용자 정의 할 수 있습니다. 의도 된 주요 사용 사례는 테스트 용이지만 &lt;a href=&quot;https://c-ares.haxx.se/&quot;&gt;c-ares&lt;/a&gt; 와 같은 타사 리졸버를 사용하는 경우에도 유용 할 수 있습니다 (시스템 리졸버를 완벽하게 대체 할 수있는 경우는 거의 없음). 자세한 내용은 &lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt; &lt;code&gt;trio.abc.HostnameResolver&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a5700d3cb14d3369161e0910959cf3905cb1f858" translate="yes" xml:space="preserve">
          <source>By default, it starts at time 0, and clock time only advances when you explicitly call &lt;a href=&quot;#trio.testing.MockClock.jump&quot;&gt;&lt;code&gt;jump()&lt;/code&gt;&lt;/a&gt;. This provides an extremely controllable clock for testing.</source>
          <target state="translated">기본적으로 시간은 0에서 시작하며 명시 적으로 &lt;a href=&quot;#trio.testing.MockClock.jump&quot;&gt; &lt;code&gt;jump()&lt;/code&gt; &lt;/a&gt; 호출 할 때만 클럭 시간이 진행됩니다 . 이것은 테스트를 위해 매우 제어 가능한 클럭을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b58f2f817ed55edb23f17dd398967d3698d94d89" translate="yes" xml:space="preserve">
          <source>By default, system tasks have &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; protection &lt;em&gt;enabled&lt;/em&gt;. If you want your task to be interruptible by control-C, then you need to use &lt;a href=&quot;#trio.hazmat.disable_ki_protection&quot;&gt;&lt;code&gt;disable_ki_protection()&lt;/code&gt;&lt;/a&gt; explicitly (and come up with some plan for what to do with a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt;, given that system tasks aren&amp;rsquo;t allowed to raise exceptions).</source>
          <target state="translated">기본적으로 시스템 작업에는 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; protection이 &lt;em&gt;활성화되어&lt;/em&gt; 있습니다. control-C로 작업을 중단 할 수있게하려면 &lt;a href=&quot;#trio.hazmat.disable_ki_protection&quot;&gt; &lt;code&gt;disable_ki_protection()&lt;/code&gt; &lt;/a&gt; 명시 적으로 사용해야 합니다 (시스템 작업에서 예외를 발생시킬 수없는 경우 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 로 수행 할 작업에 대한 계획 이 필요함 ).</target>
        </trans-unit>
        <trans-unit id="8cc5607fb4c9442aa8d532721f5253f4cd378cf0" translate="yes" xml:space="preserve">
          <source>By default, system tasks have &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; protection &lt;em&gt;enabled&lt;/em&gt;. If you want your task to be interruptible by control-C, then you need to use &lt;a href=&quot;#trio.lowlevel.disable_ki_protection&quot;&gt;&lt;code&gt;disable_ki_protection()&lt;/code&gt;&lt;/a&gt; explicitly (and come up with some plan for what to do with a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt;, given that system tasks aren&amp;rsquo;t allowed to raise exceptions).</source>
          <target state="translated">기본적으로 시스템 작업에는 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 보호가 &lt;em&gt;활성화되어&lt;/em&gt; 있습니다. control-C로 작업을 중단 할 수 있도록하려면 &lt;a href=&quot;#trio.lowlevel.disable_ki_protection&quot;&gt; &lt;code&gt;disable_ki_protection()&lt;/code&gt; &lt;/a&gt; 명시 적으로 사용해야 합니다 (시스템 작업이 예외를 발생시킬 수없는 경우 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 로 수행 할 작업에 대한 계획을 세워야합니다 ).</target>
        </trans-unit>
        <trans-unit id="5c5a4be5f8c5502c9f134af83e0fc52fbf1d81d1" translate="yes" xml:space="preserve">
          <source>By default, this will print &lt;code&gt;b&quot;12345&quot;&lt;/code&gt; and then immediately exit; with our trickle stream it instead sleeps 1 second, then prints &lt;code&gt;b&quot;1&quot;&lt;/code&gt;, then sleeps 1 second, then prints &lt;code&gt;b&quot;2&quot;&lt;/code&gt;, etc.</source>
          <target state="translated">기본적으로 &lt;code&gt;b&quot;12345&quot;&lt;/code&gt; 인쇄 한 다음 즉시 종료합니다. 우리의 물방울 스트림을 사용하면 대신 1 초 동안 잠자기 한 다음 &lt;code&gt;b&quot;1&quot;&lt;/code&gt; 을 인쇄 한 다음 1 초 동안 잠자기 한 다음 &lt;code&gt;b&quot;2&quot;&lt;/code&gt; 등 을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="c64853243edc7e6dec98d5e8fdce8c8c4b741967" translate="yes" xml:space="preserve">
          <source>Call &lt;a href=&quot;#trio.lowlevel.notify_closing&quot;&gt;&lt;code&gt;notify_closing&lt;/code&gt;&lt;/a&gt; to wake up any already-existing users.</source>
          <target state="translated">이미 존재하는 사용자를 깨우려면 &lt;a href=&quot;#trio.lowlevel.notify_closing&quot;&gt; &lt;code&gt;notify_closing&lt;/code&gt; &lt;/a&gt; 을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="dcbd0757b97694fc7ed806724923cf37c414ed40" translate="yes" xml:space="preserve">
          <source>Call this before closing a file descriptor (on Unix) or socket (on Windows). This will cause any &lt;a href=&quot;#trio.lowlevel.wait_readable&quot;&gt;&lt;code&gt;wait_readable&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.lowlevel.wait_writable&quot;&gt;&lt;code&gt;wait_writable&lt;/code&gt;&lt;/a&gt; calls on the given object to immediately wake up and raise &lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;ClosedResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파일 설명자 (Unix에서) 또는 소켓 (Windows에서)을 닫기 전에 이것을 호출하십시오. 이로 인해 주어진 객체에 대한 &lt;a href=&quot;#trio.lowlevel.wait_readable&quot;&gt; &lt;code&gt;wait_readable&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#trio.lowlevel.wait_writable&quot;&gt; &lt;code&gt;wait_writable&lt;/code&gt; &lt;/a&gt; 호출이 즉시 깨어나 &lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;ClosedResourceError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="eadf7b64718fcecec9e169b6cd95cc0cf6518eb8" translate="yes" xml:space="preserve">
          <source>Call this before closing a file descriptor or &lt;code&gt;SOCKET&lt;/code&gt; handle that another task might be waiting on. This will cause any &lt;a href=&quot;#trio.hazmat.wait_readable&quot;&gt;&lt;code&gt;wait_readable&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.hazmat.wait_writable&quot;&gt;&lt;code&gt;wait_writable&lt;/code&gt;&lt;/a&gt; calls to immediately raise &lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;ClosedResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다른 태스크가 대기중인 파일 디스크립터 또는 &lt;code&gt;SOCKET&lt;/code&gt; 핸들을 닫기 전에이를 호출하십시오 . 이로 인해 &lt;a href=&quot;#trio.hazmat.wait_readable&quot;&gt; &lt;code&gt;wait_readable&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#trio.hazmat.wait_writable&quot;&gt; &lt;code&gt;wait_writable&lt;/code&gt; &lt;/a&gt; 호출이 즉시 &lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;ClosedResourceError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8bc1558d2fe1a2c54a2a164cbb59e5c8c644a3a1" translate="yes" xml:space="preserve">
          <source>Called after handling pending I/O.</source>
          <target state="translated">보류중인 I / O를 처리 한 후 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f8bfde0992ada594581390a46c166b77baca3161" translate="yes" xml:space="preserve">
          <source>Called at the beginning of &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 시작 부분에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="1f2793beb004add327f22b3156bfba07b27d6e11" translate="yes" xml:space="preserve">
          <source>Called at the beginning of the run.</source>
          <target state="translated">실행이 시작될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f7acf6acc0d0f3320d572dca39e7a7e07743123e" translate="yes" xml:space="preserve">
          <source>Called before blocking to wait for I/O readiness.</source>
          <target state="translated">I / O 준비를 기다리는 동안 차단하기 전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1f142fccb8ca1dc1831e93b467e4f3395cda028f" translate="yes" xml:space="preserve">
          <source>Called by &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;trio.socket.getaddrinfo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;trio.socket.getaddrinfo()&lt;/code&gt; &lt;/a&gt; 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="29c1d3563dccbfdd83877b549758692595c9c581" translate="yes" xml:space="preserve">
          <source>Called by &lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt;&lt;code&gt;trio.socket.getnameinfo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt; &lt;code&gt;trio.socket.getnameinfo()&lt;/code&gt; &lt;/a&gt; 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="aed9b81d2c1131bfffe4d070ed0619e875566978" translate="yes" xml:space="preserve">
          <source>Called by &lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt;&lt;code&gt;trio.socket.socket()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt; &lt;code&gt;trio.socket.socket()&lt;/code&gt; &lt;/a&gt; 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="8d66f6f8b90776c10ddba63543e685f9f3d93f60" translate="yes" xml:space="preserve">
          <source>Called immediately before we resume running the given task.</source>
          <target state="translated">주어진 작업을 재개하기 직전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="261a5d5178d7387f8183212c0cd69cb1977900da" translate="yes" xml:space="preserve">
          <source>Called just before &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; returns.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 리턴 하기 직전에 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="b884c70436293eb060bb3491a325d480b9671ac9" translate="yes" xml:space="preserve">
          <source>Called when the given task becomes runnable.</source>
          <target state="translated">주어진 작업을 실행할 수있게되면 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="35ab13509c0b0bba5b8df114b0b980a549bd6031" translate="yes" xml:space="preserve">
          <source>Called when the given task exits.</source>
          <target state="translated">주어진 작업이 종료 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="626700fae10a1356415b4972c54ece4515e4c958" translate="yes" xml:space="preserve">
          <source>Called when the given task is created.</source>
          <target state="translated">주어진 작업이 생성 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="233443fcf281f0b8386a0968b812f850857ffd12" translate="yes" xml:space="preserve">
          <source>Called when we return to the main run loop after a task has yielded.</source>
          <target state="translated">작업이 발생한 후 기본 실행 루프로 돌아갈 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a2e360b3ae69814d2bc4f200eb26320d68ccd43c" translate="yes" xml:space="preserve">
          <source>Calling:</source>
          <target state="translated">Calling:</target>
        </trans-unit>
        <trans-unit id="ca6c307d3032f60efa049582739a99b205d7915a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;aclose&lt;/code&gt; on both underlying streams.</source>
          <target state="translated">기본 스트림 모두에서 통화가 &lt;code&gt;aclose&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="08c519dcd2a8fb0112b30c9b37377bc0d2e81245" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;self.receive_stream.receive_some&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self.receive_stream.receive_some&lt;/code&gt; 을 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="8772d34b9efd174bb2bc372d12b3a9aef3fdba3c" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;self.send_stream.send_all&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self.send_stream.send_all&lt;/code&gt; 을 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="689c7ef3178baffe7752a81f89957ee75f40366d" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;self.send_stream.wait_send_all_might_not_block&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self.send_stream.wait_send_all_might_not_block&lt;/code&gt; 을 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="6dcbaa082561c00fc529f363d4aea0631e29f017" translate="yes" xml:space="preserve">
          <source>Calls the &lt;a href=&quot;#trio.testing.MemoryReceiveStream.receive_some_hook&quot;&gt;&lt;code&gt;receive_some_hook&lt;/code&gt;&lt;/a&gt; (if any), and then retrieves data from the internal buffer, blocking if necessary.</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.MemoryReceiveStream.receive_some_hook&quot;&gt; &lt;code&gt;receive_some_hook&lt;/code&gt; &lt;/a&gt; (있는 경우)을 호출 한 다음 내부 버퍼에서 데이터를 검색하여 필요한 경우 차단합니다.</target>
        </trans-unit>
        <trans-unit id="a6e5e384d9f188aacab0c35281723d4e24af136b" translate="yes" xml:space="preserve">
          <source>Calls the &lt;a href=&quot;#trio.testing.MemorySendStream.wait_send_all_might_not_block_hook&quot;&gt;&lt;code&gt;wait_send_all_might_not_block_hook&lt;/code&gt;&lt;/a&gt; (if any), and then returns immediately.</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.MemorySendStream.wait_send_all_might_not_block_hook&quot;&gt; &lt;code&gt;wait_send_all_might_not_block_hook&lt;/code&gt; &lt;/a&gt; (있는 경우)을 호출 한 다음 즉시 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="17f62cccc2b16047914a83d29183a474fa849e92" translate="yes" xml:space="preserve">
          <source>Cancel scopes and nurseries</source>
          <target state="translated">범위 및 보육 취소</target>
        </trans-unit>
        <trans-unit id="f10923fa9e8e643d29ab59bd93446bf992a6d907" translate="yes" xml:space="preserve">
          <source>Cancel scopes are not reusable or reentrant; that is, each cancel scope can be used for at most one &lt;code&gt;with&lt;/code&gt; block. (You&amp;rsquo;ll get a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; if you violate this rule.)</source>
          <target state="translated">취소 범위는 재사용하거나 재진입 할 ​​수 없습니다. 즉, 각각의 범위는 최대 하나에서 사용될 수 취소 &lt;code&gt;with&lt;/code&gt; 블록. (당신은 얻을 것이다 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; 에가&lt;/a&gt; 이 규칙을 위반하는 경우.)</target>
        </trans-unit>
        <trans-unit id="81686d1e66168847e2ace4f30aee9372739e14a4" translate="yes" xml:space="preserve">
          <source>Cancellation API details</source>
          <target state="translated">취소 API 세부 사항</target>
        </trans-unit>
        <trans-unit id="d6d584a8ce62812cd18c2c454f3ca9d1ca893f41" translate="yes" xml:space="preserve">
          <source>Cancellation and primitive operations</source>
          <target state="translated">취소 및 원시 작업</target>
        </trans-unit>
        <trans-unit id="bef7bb5e57e5a92b8be6213bc977ef4ea4184ce0" translate="yes" xml:space="preserve">
          <source>Cancellation and timeouts</source>
          <target state="translated">취소 및 타임 아웃</target>
        </trans-unit>
        <trans-unit id="59b0482bdded1133e8a5fead2d8afd30f974346d" translate="yes" xml:space="preserve">
          <source>Cancellation semantics</source>
          <target state="translated">취소 의미론</target>
        </trans-unit>
        <trans-unit id="94d6332b8909ea75970b6b4fdc80b35ecc20fba7" translate="yes" xml:space="preserve">
          <source>Cancellations in Trio are &amp;ldquo;level triggered&amp;rdquo;, meaning that once a block has been cancelled, &lt;em&gt;all&lt;/em&gt; cancellable operations in that block will keep raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;. This helps avoid some pitfalls around resource clean-up. For example, imagine that we have a function that connects to a remote server and sends some messages, and then cleans up on the way out:</source>
          <target state="translated">Trio의 취소는 &quot;레벨 트리거&quot;로, 일단 블록이 취소되면 해당 블록의 &lt;em&gt;모든&lt;/em&gt; 취소 가능한 작업이 계속 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 냅니다. 이렇게하면 리소스 정리와 관련된 함정을 피할 수 있습니다. 예를 들어, 원격 서버에 연결하고 일부 메시지를 보낸 다음 나가는 도중에 정리하는 기능이 있다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="0d2c360a80f52470e7f8b83eff4301ca10ff10b3" translate="yes" xml:space="preserve">
          <source>Cancels this scope immediately.</source>
          <target state="translated">이 범위를 즉시 취소합니다.</target>
        </trans-unit>
        <trans-unit id="31ceffa7c4fe7185611cc1eb3c159aad57550985" translate="yes" xml:space="preserve">
          <source>Channel objects can be closed by calling &lt;a href=&quot;reference-io#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose&lt;/code&gt;&lt;/a&gt; or using &lt;code&gt;async with&lt;/code&gt;. They are &lt;em&gt;not&lt;/em&gt; automatically closed when garbage collected. Closing memory channels isn&amp;rsquo;t mandatory, but it is generally a good idea, because it helps avoid situations where tasks get stuck waiting on a channel when there&amp;rsquo;s no-one on the other side. See &lt;a href=&quot;#channel-shutdown&quot;&gt;Clean shutdown with channels&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;reference-io#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose&lt;/code&gt; &lt;/a&gt; 를 호출 하거나 &lt;code&gt;async with&lt;/code&gt; 사용하여 채널 객체를 닫을 수 있습니다 . 그들은되어 &lt;em&gt;있지&lt;/em&gt; 쓰레기 수집 할 때 자동으로 닫힙니다. 메모리 채널을 닫는 것은 필수는 아니지만 다른쪽에 아무도 없을 때 작업이 채널에서 대기하는 상황을 피하는 데 도움이되므로 일반적으로 좋은 생각입니다. 자세한 내용 &lt;a href=&quot;#channel-shutdown&quot;&gt;은 채널&lt;/a&gt; 을 사용한 클린 셧다운을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="5beb5dd56408be62815ea722ff005781ac57b3c1" translate="yes" xml:space="preserve">
          <source>Cheat sheet:</source>
          <target state="translated">컨닝 지:</target>
        </trans-unit>
        <trans-unit id="5d0402051b976bb8c461f7092dd83b539f201202" translate="yes" xml:space="preserve">
          <source>Check if the process has exited yet.</source>
          <target state="translated">프로세스가 아직 종료되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="99dce9cfa994376c7012637e31516c6ac05c9b2e" translate="yes" xml:space="preserve">
          <source>Check that &lt;a href=&quot;reference-core#trio.sleep&quot;&gt;&lt;code&gt;trio.sleep()&lt;/code&gt;&lt;/a&gt; is a checkpoint, even if it doesn&amp;rsquo;t block:</source>
          <target state="translated">차단하지 않더라도 &lt;a href=&quot;reference-core#trio.sleep&quot;&gt; &lt;code&gt;trio.sleep()&lt;/code&gt; &lt;/a&gt; 이 체크 포인트 인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="9dd73b1e659a659ad6d4dcaea475a5cc4de5b8c4" translate="yes" xml:space="preserve">
          <source>Check the current value of an option on the underlying socket.</source>
          <target state="translated">기본 소켓에서 옵션의 현재 값을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="20967b01d8903985483d3209955125b8ee51474f" translate="yes" xml:space="preserve">
          <source>Check whether the calling code has &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; protection enabled.</source>
          <target state="translated">호출 코드에 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 보호가 활성화 되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="88e1669ff508c58005f68fe9617b0958a0b4a996" translate="yes" xml:space="preserve">
          <source>Check whether the lock is currently held.</source>
          <target state="translated">잠금이 현재 보유되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5ae0d67fbacc52e0c961355167ed1dcc9fdc273e" translate="yes" xml:space="preserve">
          <source>Check whether the socket is readable or not.</source>
          <target state="translated">소켓을 읽을 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4008592f35f63d2ce5cf53beec32dcc247cc261c" translate="yes" xml:space="preserve">
          <source>Check whether the underlying lock is currently held.</source>
          <target state="translated">기본 잠금이 현재 보유되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a2b3a59adb81ffe32d8631c171b886f3d460360a" translate="yes" xml:space="preserve">
          <source>Checkpoints</source>
          <target state="translated">Checkpoints</target>
        </trans-unit>
        <trans-unit id="aad917cb07530e653ce3782a304aa67132789402" translate="yes" xml:space="preserve">
          <source>Child tasks and cancellation</source>
          <target state="translated">아동 업무 및 취소</target>
        </trans-unit>
        <trans-unit id="01c92ef80410cf8e2458b13dd6e02e97ff4b05f5" translate="yes" xml:space="preserve">
          <source>Clean shutdown with channels</source>
          <target state="translated">채널을 이용한 클린 셧다운</target>
        </trans-unit>
        <trans-unit id="784258aa3e82bf98876fffb3b3acb5f4cbe86b6c" translate="yes" xml:space="preserve">
          <source>Cleanly close down the SSL/TLS encryption layer, allowing the underlying stream to be used for unencrypted communication.</source>
          <target state="translated">SSL / TLS 암호화 계층을 완전히 닫아 암호화되지 않은 통신에 기본 스트림을 사용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="5fa38c822c36efd1393228e6e95fbf224d0de0c2" translate="yes" xml:space="preserve">
          <source>Clone this receive channel object.</source>
          <target state="translated">이 수신 채널 오브젝트를 복제하십시오.</target>
        </trans-unit>
        <trans-unit id="26f9ba049c495ce23a501d2faccd6b6380ec2d77" translate="yes" xml:space="preserve">
          <source>Clone this send channel object.</source>
          <target state="translated">이 송신 채널 오브젝트를 복제하십시오.</target>
        </trans-unit>
        <trans-unit id="53b3076f17b316cb84b6c29640d7e43f09e5ae18" translate="yes" xml:space="preserve">
          <source>Close an async resource or async generator immediately, without blocking to do any graceful cleanup.</source>
          <target state="translated">정상적인 정리 작업을 차단하지 않고 비동기 리소스 또는 비동기 생성기를 즉시 닫습니다.</target>
        </trans-unit>
        <trans-unit id="035296db4c7f1acd83221d71dd8e4179d8a62b32" translate="yes" xml:space="preserve">
          <source>Close any pipes we have to the process (both input and output) and wait for it to exit.</source>
          <target state="translated">프로세스에 필요한 파이프 (입력 및 출력 모두)를 닫고 종료 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="588a267fa1c5900f167e70a9805d55eb4e9fae92" translate="yes" xml:space="preserve">
          <source>Close the transport listener.</source>
          <target state="translated">전송 리스너를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="92a76bf8154c807de0dcad6ffb92786e9a377d3f" translate="yes" xml:space="preserve">
          <source>Close this listener and its underlying socket.</source>
          <target state="translated">이 리스너와 기본 소켓을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="9d7a38d1c0ab9ac085c640d84609f2282e02e4b8" translate="yes" xml:space="preserve">
          <source>Close this receive channel object synchronously.</source>
          <target state="translated">이 수신 채널 개체를 동 기적으로 닫습니다.</target>
        </trans-unit>
        <trans-unit id="a357d054163bbdbd417f533dddc5214d41ff476e" translate="yes" xml:space="preserve">
          <source>Close this resource, possibly blocking.</source>
          <target state="translated">이 리소스를 닫으면 차단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c82d076f97baedc6bbb85564f9143f111010b9ae" translate="yes" xml:space="preserve">
          <source>Close this send channel object synchronously.</source>
          <target state="translated">이 송신 채널 객체를 동 기적으로 닫습니다.</target>
        </trans-unit>
        <trans-unit id="264398069882e7753347718021d0c9c51b7ce8fc" translate="yes" xml:space="preserve">
          <source>Code of Conduct</source>
          <target state="translated">행동 강령</target>
        </trans-unit>
        <trans-unit id="746e8bd7005ece0b3884461868490a2886db15a2" translate="yes" xml:space="preserve">
          <source>Code of conduct: Contributors are requested to follow our &lt;a href=&quot;https://trio.readthedocs.io/en/latest/code-of-conduct.html&quot;&gt;code of conduct&lt;/a&gt; in all project spaces.</source>
          <target state="translated">행동 강령 : 기고자는 모든 프로젝트 공간에서 &lt;a href=&quot;https://trio.readthedocs.io/en/latest/code-of-conduct.html&quot;&gt;행동 강령&lt;/a&gt; 을 따라야 합니다.</target>
        </trans-unit>
        <trans-unit id="d28ccf5a13cb7101b38230ecb28bea934cb4291f" translate="yes" xml:space="preserve">
          <source>Combine this path with one or several arguments, and return a new path representing either a subpath (if all arguments are relative paths) or a totally different path (if one of the arguments is anchored).</source>
          <target state="translated">이 경로를 하나 이상의 인수와 결합하고 하위 경로 (모든 인수가 상대 경로 인 경우) 또는 완전히 다른 경로 (인수 중 하나가 고정 된 경우)를 나타내는 새 경로를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="65245cc21eba1d1c7e7fddcf1b4438e65f650376" translate="yes" xml:space="preserve">
          <source>Compute the real time until the given deadline.</source>
          <target state="translated">주어진 마감일까지 실시간을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="8f7a13ba87678f3b5148bff6487028382a7d01bb" translate="yes" xml:space="preserve">
          <source>Concretely, we unroll Trio&amp;rsquo;s internal event loop into a chain of callbacks, and as each callback finishes, it schedules the next callback onto the host loop or a worker thread as appropriate. So the only thing the host loop has to provide is a way to schedule a callback onto the main thread from a worker thread.</source>
          <target state="translated">구체적으로 Trio의 내부 이벤트 루프를 콜백 체인으로 펼치고 각 콜백이 완료되면 다음 콜백을 호스트 루프 또는 작업자 스레드로 적절하게 예약합니다. 따라서 호스트 루프가 제공해야하는 유일한 것은 작업자 스레드에서 주 스레드로 콜백을 예약하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d188261dfbdc2cfd51eb5fff57de708b9c31454d" translate="yes" xml:space="preserve">
          <source>Connect the socket to a remote address.</source>
          <target state="translated">소켓을 원격 주소에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="800add8197c9d879f3f1a2c8248892a00488ba45" translate="yes" xml:space="preserve">
          <source>Connect to the given &lt;a href=&quot;reference-io#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;reference-io#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; 에&lt;/a&gt; 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="698feffa6fbdf24c6dd24be1554ee55fedb5f42d" translate="yes" xml:space="preserve">
          <source>Connect to the given host and port over TCP.</source>
          <target state="translated">TCP를 통해 지정된 호스트 및 포트에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="dd0929c6d129ec17dfa57ea8a0921e4c15b090b4" translate="yes" xml:space="preserve">
          <source>Connecting to an in-process socket server</source>
          <target state="translated">처리중인 소켓 서버에 연결</target>
        </trans-unit>
        <trans-unit id="3baa61371b169eda0fd610c32ccdc96fdcf84e5a" translate="yes" xml:space="preserve">
          <source>Consistent behavior: guest mode uses the same code as regular Trio: the same scheduler, same IO code, same everything. So you get the full feature set and everything acts the way you expect.</source>
          <target state="translated">일관된 동작 : 게스트 모드는 일반 Trio와 동일한 코드를 사용합니다. 동일한 스케줄러, 동일한 IO 코드, 동일한 모든 것. 따라서 전체 기능 세트를 얻고 모든 것이 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4b801243997b335019aa4cb1a2eda249a55d038e" translate="yes" xml:space="preserve">
          <source>Contains all the child &lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; objects which are still running.</source>
          <target state="translated">여전히 실행중인 모든 하위 &lt;a href=&quot;reference-hazmat#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 개체를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="4b46de99d261e6934569fd47acb7a0b73a8f8b13" translate="yes" xml:space="preserve">
          <source>Contains all the child &lt;a href=&quot;reference-lowlevel#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; objects which are still running.</source>
          <target state="translated">아직 실행중인 모든 자식 &lt;a href=&quot;reference-lowlevel#trio.lowlevel.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 개체를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="3bddea3d2467ed7b12f0ab27cd877bc1cf844289" translate="yes" xml:space="preserve">
          <source>Contributing to Trio and related projects</source>
          <target state="translated">트리오 및 관련 프로젝트에 기여</target>
        </trans-unit>
        <trans-unit id="dd8d019f05b4b5b283596920dd515b31a77df643" translate="yes" xml:space="preserve">
          <source>Contributor guide: &lt;a href=&quot;https://trio.readthedocs.io/en/latest/contributing.html&quot;&gt;https://trio.readthedocs.io/en/latest/contributing.html&lt;/a&gt;</source>
          <target state="translated">기고자 안내서 : &lt;a href=&quot;https://trio.readthedocs.io/en/latest/contributing.html&quot;&gt;https://trio.readthedocs.io/en/latest/contributing.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0e29f2bf28ae181dcc1f858f04d215a291dc038c" translate="yes" xml:space="preserve">
          <source>Convert a blocking operation into an async operation using a thread.</source>
          <target state="translated">스레드를 사용하여 블로킹 작업을 비동기 작업으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="276de9a62bb932e4c343f213f05d286af43a0d3e" translate="yes" xml:space="preserve">
          <source>Convert a standard library &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt;&lt;code&gt;socket.socket()&lt;/code&gt;&lt;/a&gt; object into a Trio socket object.</source>
          <target state="translated">표준 라이브러리 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt; &lt;code&gt;socket.socket()&lt;/code&gt; &lt;/a&gt; 객체를 Trio 소켓 객체로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="502d79d8438f678d3fd2c4abe319c4435929b777" translate="yes" xml:space="preserve">
          <source>Coordinating between Trio and the host loop does add some overhead. The main cost is switching in and out of the background thread, since this requires cross-thread messaging. This is cheap (on the order of a few microseconds, assuming your host loop is implemented efficiently), but it&amp;rsquo;s not free.</source>
          <target state="translated">Trio와 호스트 루프를 조정하면 약간의 오버 헤드가 추가됩니다. 주요 비용은 크로스 스레드 메시징이 필요하기 때문에 백그라운드 스레드를 전환하는 것입니다. 이것은 저렴하지만 (호스트 루프가 효율적으로 구현되었다고 가정하면 몇 마이크로 초 정도), 무료는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c024281ced10e6a1d03ece9c47de83e6ef569254" translate="yes" xml:space="preserve">
          <source>Create &lt;a href=&quot;#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt; objects to listen for TCP connections.</source>
          <target state="translated">TCP 연결을 청취 할 &lt;a href=&quot;#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; &lt;/a&gt; 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="e347faadc22e2b28043f6892d02ba59794212183" translate="yes" xml:space="preserve">
          <source>Create a connected, pure Python, unidirectional stream where data flows in lockstep.</source>
          <target state="translated">데이터가 잠금 단계로 흐르는 연결된 순수 Python, 단방향 스트림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2be9228bbeea61d2f22276d384ece99dd757e610" translate="yes" xml:space="preserve">
          <source>Create a connected, pure-Python, bidirectional stream where data flows in lockstep.</source>
          <target state="translated">데이터가 잠금 단계로 흐르는 연결된 순수 Python 양방향 스트림을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="afd5545b50d0fd9918e03f162eea8fed63bbf9a5" translate="yes" xml:space="preserve">
          <source>Create a connected, pure-Python, bidirectional stream with infinite buffering and flexible configuration options.</source>
          <target state="translated">무한 버퍼링 및 유연한 구성 옵션을 사용하여 연결된 순수 Python 양방향 스트림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="16fd426e055ccfde61ebd50613e240b90a4120de" translate="yes" xml:space="preserve">
          <source>Create a connected, pure-Python, unidirectional stream with infinite buffering and flexible configuration options.</source>
          <target state="translated">무한 버퍼링 및 유연한 구성 옵션으로 연결된 순수 Python 단방향 스트림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4c5674378b77c928b661f2f5d24e4b5af9e0efb8" translate="yes" xml:space="preserve">
          <source>Create a new Trio socket, like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt;&lt;code&gt;socket.socket()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt; &lt;code&gt;socket.socket()&lt;/code&gt; &lt;/a&gt; 과 같은 새 Trio 소켓을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="e6d00615f23bd18743bd5e4f3fbb5bf3051fd73f" translate="yes" xml:space="preserve">
          <source>Create and return a socket object.</source>
          <target state="translated">소켓 객체를 생성하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9cf47fcd675898eff0e3b8e79ec7d8b7bb8c7284" translate="yes" xml:space="preserve">
          <source>Creates a cancel scope with the given deadline, and raises an error if it is actually cancelled.</source>
          <target state="translated">주어진 최종 기한이있는 취소 범위를 작성하고 실제로 취소 된 경우 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="f93b3b45c8ea9164c989693e6fa16a0100351871" translate="yes" xml:space="preserve">
          <source>Creates a cancel scope with the given timeout, and raises an error if it is actually cancelled.</source>
          <target state="translated">지정된 시간 초과로 취소 범위를 만들고 실제로 취소 된 경우 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="c3f897b8e6c02e94ce9b26b00cb7864784b899fb" translate="yes" xml:space="preserve">
          <source>Creates a child task, scheduling &lt;code&gt;await async_fn(*args)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;await async_fn(*args)&lt;/code&gt; 예약하여 하위 작업을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="ee1e2c14a1406cbe854dca9278d7dd0b325b77bc" translate="yes" xml:space="preserve">
          <source>Creates and initalizes a child task.</source>
          <target state="translated">자식 작업을 생성하고 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="b2bec567835477658a29d71119dd0209ee2ddec3" translate="yes" xml:space="preserve">
          <source>Creating a nursery also implicitly creates a cancellation scope, which is exposed as the &lt;a href=&quot;#trio.Nursery.cancel_scope&quot;&gt;&lt;code&gt;cancel_scope&lt;/code&gt;&lt;/a&gt; attribute. This is used internally to implement the logic where if an error occurs then &lt;code&gt;__aexit__&lt;/code&gt; cancels all children, but you can use it for other things, e.g. if you want to explicitly cancel all children in response to some external event.</source>
          <target state="translated">종묘장을 만들면 취소 범위가 암시 적으로 생성되어 &lt;a href=&quot;#trio.Nursery.cancel_scope&quot;&gt; &lt;code&gt;cancel_scope&lt;/code&gt; &lt;/a&gt; 속성으로 노출됩니다 . 이것은 오류가 발생하면 &lt;code&gt;__aexit__&lt;/code&gt; 가 모든 자식을 취소 하는 논리를 구현하기 위해 내부적으로 사용 되지만, 외부 이벤트에 대한 응답으로 모든 자식을 명시 적으로 취소하려는 경우와 같이 다른 용도로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e6dfd567b7a3307a537cbe53c08739b6a191602" translate="yes" xml:space="preserve">
          <source>Currently the following fields are defined:</source>
          <target state="translated">현재 다음 필드가 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="df88d3fb2307ae56cdb9ef5328a1543925e6af8c" translate="yes" xml:space="preserve">
          <source>Currently, &lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt;&lt;code&gt;StrictFIFOLock&lt;/code&gt;&lt;/a&gt; is identical to &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt;, but (a) this may not always be true in the future, especially if Trio ever implements &lt;a href=&quot;https://github.com/python-trio/trio/issues/32&quot;&gt;more sophisticated scheduling policies&lt;/a&gt;, and (b) the above code is relying on a pretty subtle property of its lock. Using a &lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt;&lt;code&gt;StrictFIFOLock&lt;/code&gt;&lt;/a&gt; acts as an executable reminder that you&amp;rsquo;re relying on this property.</source>
          <target state="translated">현재 &lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt; &lt;code&gt;StrictFIFOLock&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 (a) 미래에는 특히 Trio 가보다&lt;a href=&quot;https://github.com/python-trio/trio/issues/32&quot;&gt; 정교한 스케줄링 정책을&lt;/a&gt; 구현 하고 (b) 위의 코드가 잠금의 매우 미묘한 속성에 의존하는 경우 항상 사실이 아닐 수 있습니다 . &lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt; &lt;code&gt;StrictFIFOLock&lt;/code&gt; 을&lt;/a&gt; 사용하면 이 속성에 의존하고 있음을 알리는 실행 가능한 알림 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="b917c15a50ea6342a17c9063be5bcf13e4adf47b" translate="yes" xml:space="preserve">
          <source>Currently, &lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt;&lt;code&gt;StrictFIFOLock&lt;/code&gt;&lt;/a&gt; is simply an alias for &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt;, but (a) this may not always be true in the future, especially if Trio ever implements &lt;a href=&quot;https://github.com/python-trio/trio/issues/32&quot;&gt;more sophisticated scheduling policies&lt;/a&gt;, and (b) the above code is relying on a pretty subtle property of its lock. Using a &lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt;&lt;code&gt;StrictFIFOLock&lt;/code&gt;&lt;/a&gt; acts as an executable reminder that you&amp;rsquo;re relying on this property.</source>
          <target state="translated">현재 &lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt; &lt;code&gt;StrictFIFOLock&lt;/code&gt; 는&lt;/a&gt; 별칭 단순히 &lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 하지만, (a)이 항상 미래에 진실하지 않을 수 있습니다, 특히 경우 트리오 적 구현 &lt;a href=&quot;https://github.com/python-trio/trio/issues/32&quot;&gt;보다 정교한 스케줄링 정책&lt;/a&gt; , 그리고 (b) 위의 코드는 꽤 미묘한 특성에 의존 자사의 자물쇠. &lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt; &lt;code&gt;StrictFIFOLock&lt;/code&gt; 을&lt;/a&gt; 사용하면 이 속성에 의존하고 있음을 알리는 실행 가능한 알림 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="c8852ce839266b1032f3de681f74884aa8adf52b" translate="yes" xml:space="preserve">
          <source>Currently, Trio always uses unbuffered byte streams for communicating with a process, so it does not support the &lt;code&gt;encoding&lt;/code&gt;, &lt;code&gt;errors&lt;/code&gt;, &lt;code&gt;universal_newlines&lt;/code&gt; (alias &lt;code&gt;text&lt;/code&gt; in 3.7+), and &lt;code&gt;bufsize&lt;/code&gt; options.</source>
          <target state="translated">현재 Trio는 프로세스와 통신하기 위해 항상 버퍼링되지 않은 바이트 스트림을 사용하므로 &lt;code&gt;encoding&lt;/code&gt; , &lt;code&gt;errors&lt;/code&gt; , &lt;code&gt;universal_newlines&lt;/code&gt; ( 3.7 이상의 &lt;code&gt;text&lt;/code&gt; ) 및 &lt;code&gt;bufsize&lt;/code&gt; 옵션을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ba051d187626a0ba5debfdec43c3c3f4df1e01f7" translate="yes" xml:space="preserve">
          <source>Custom clocks can be used in guest mode, but they only affect Trio timeouts, not host loop timeouts. And the &lt;a href=&quot;reference-testing#testing-time&quot;&gt;autojump clock&lt;/a&gt; and related &lt;a href=&quot;reference-testing#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;trio.testing.wait_all_tasks_blocked&lt;/code&gt;&lt;/a&gt; can technically be used in guest mode, but they&amp;rsquo;ll only take Trio tasks into account when decided whether to jump the clock or whether all tasks are blocked.</source>
          <target state="translated">사용자 지정 시계는 게스트 모드에서 사용할 수 있지만 호스트 루프 타임 아웃이 아닌 트리오 타임 아웃에만 영향을줍니다. 그리고 &lt;a href=&quot;reference-testing#testing-time&quot;&gt;autojump 시계&lt;/a&gt; 및 관련 &lt;a href=&quot;reference-testing#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;trio.testing.wait_all_tasks_blocked&lt;/code&gt; &lt;/a&gt; 는 기술적으로 게스트 모드에서 사용할 수 있지만 시계 점프 여부 또는 모든 작업 차단 여부를 결정할 때만 Trio 작업을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="a22eac18305a1e1dc5892e7f5be351ae472656bb" translate="yes" xml:space="preserve">
          <source>Custom supervisors</source>
          <target state="translated">맞춤형 감독자</target>
        </trans-unit>
        <trans-unit id="61074f1c958d6cdd32dad889b3d58a2d0704cbe3" translate="yes" xml:space="preserve">
          <source>Database</source>
          <target state="translated">Database</target>
        </trans-unit>
        <trans-unit id="37671df58880918e942ce4bc136b98bb7f52aac2" translate="yes" xml:space="preserve">
          <source>Debugging and instrumentation</source>
          <target state="translated">디버깅 및 계측</target>
        </trans-unit>
        <trans-unit id="ac0a627ff292b052255162959a08edc910141a7f" translate="yes" xml:space="preserve">
          <source>Decorator that marks the given regular function, generator function, async function, or async generator function as protected against &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt;, i.e., the code inside this function &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; be rudely interrupted by &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt;. (Though if it contains any &lt;a href=&quot;reference-core#checkpoints&quot;&gt;checkpoints&lt;/a&gt;, then it can still receive &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; at those. This is considered a polite interruption.)</source>
          <target state="translated">주어진 정규 함수, 생성기 함수, 비동기 함수 또는 비동기 생성기 함수를 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 에 대해 보호 된 것으로 표시하는 데코레이터 . 즉,이 함수 내부의 코드 는 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; 에&lt;/a&gt; 의해 &lt;em&gt;거의&lt;/em&gt; 중단 &lt;em&gt;되지 않습니다&lt;/em&gt; . ( &lt;a href=&quot;reference-core#checkpoints&quot;&gt;체크 포인트&lt;/a&gt; 가 포함되어 있어도 여전히 해당 포인트 에서 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 를 수신 할 수 있습니다 . 이는 정중 한 인터럽트로 간주됩니다.)</target>
        </trans-unit>
        <trans-unit id="f21a3283f7231f03c1af0a06d7cc4980ad8fdace" translate="yes" xml:space="preserve">
          <source>Decorator that marks the given regular function, generator function, async function, or async generator function as unprotected against &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt;, i.e., the code inside this function &lt;em&gt;can&lt;/em&gt; be rudely interrupted by &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; at any moment.</source>
          <target state="translated">주어진 정규 함수, 생성기 함수, 비동기 함수 또는 비동기 생성기 함수를 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 에 대해 보호되지 않은 것으로 표시하는 데코레이터 . 즉,이 함수 내부의 코드 는 언제든지 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 에 의해 거의 중단 될 &lt;em&gt;수&lt;/em&gt; 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e2a5cb3fa4689c389726d66d794778a89c63a2e" translate="yes" xml:space="preserve">
          <source>Decrement the semaphore value, blocking if necessary to avoid letting it drop below zero.</source>
          <target state="translated">세마포어 값을 낮추고 필요한 경우 0 미만으로 떨어지지 않도록 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="39db43b218a6486fec3ada3896d1474afb067886" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;a href=&quot;https://docs.python.org/3/library/constants.html#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, though this can be overridden by the &lt;code&gt;shield=&lt;/code&gt; argument to the &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">기본값은 &lt;a href=&quot;https://docs.python.org/3/library/constants.html#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 이지만, 이것은 &lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; &lt;/a&gt; 생성자 에 대한 &lt;code&gt;shield=&lt;/code&gt; 인수로 재정의 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dcda29f4558d93a7bbbd6d484ebff9ce0dc4358d" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt;&lt;code&gt;math.inf&lt;/code&gt;&lt;/a&gt;, which means &amp;ldquo;no deadline&amp;rdquo;, though this can be overridden by the &lt;code&gt;deadline=&lt;/code&gt; argument to the &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt; &lt;code&gt;math.inf&lt;/code&gt; &lt;/a&gt; 는 &quot;마감일 없음&quot;을 의미하지만, 이는 deadScope &lt;code&gt;deadline=&lt;/code&gt; 인수로 &lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; &lt;/a&gt; 생성자에 의해 재정의 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1d70f0971455d22b791a3109b5b80c647c7c40a" translate="yes" xml:space="preserve">
          <source>Design and internals</source>
          <target state="translated">디자인과 내부</target>
        </trans-unit>
        <trans-unit id="7cca6a5cf867780c8e3f34ab51803e9dfcfd0b0c" translate="yes" xml:space="preserve">
          <source>Despite the name, this class currently inherits from &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#FutureWarning&quot;&gt;&lt;code&gt;FutureWarning&lt;/code&gt;&lt;/a&gt;, not &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#DeprecationWarning&quot;&gt;&lt;code&gt;DeprecationWarning&lt;/code&gt;&lt;/a&gt;, because while we&amp;rsquo;re in young-and-aggressive mode we want these warnings to be visible by default. You can hide them by installing a filter or with the &lt;code&gt;-W&lt;/code&gt; switch: see the &lt;a href=&quot;https://docs.python.org/3/library/warnings.html#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">이름에도 불구하고,이 클래스는 현재 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#DeprecationWarning&quot;&gt; &lt;code&gt;DeprecationWarning&lt;/code&gt; 이&lt;/a&gt; 아니라 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#FutureWarning&quot;&gt; &lt;code&gt;FutureWarning&lt;/code&gt; &lt;/a&gt; 에서 상속받습니다 . 젊고 공격적인 모드에있을 때 이러한 경고가 기본적으로 표시되기를 원하기 때문입니다. 필터를 설치하거나 &lt;code&gt;-W&lt;/code&gt; 스위치를 사용하여 숨길 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://docs.python.org/3/library/warnings.html#module-warnings&quot;&gt; &lt;code&gt;warnings&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d07097459810ff8d556f864eef0251cbd4763961" translate="yes" xml:space="preserve">
          <source>Different environments expose different low-level APIs for performing async I/O. &lt;a href=&quot;#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt; exposes these APIs in a relatively direct way, so as to allow maximum power and flexibility for higher level code. However, this means that the exact API provided may vary depending on what system Trio is running on.</source>
          <target state="translated">환경에 따라 비동기 I / O를 수행하기 위해 서로 다른 저수준 API가 노출됩니다. &lt;a href=&quot;#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; &lt;/a&gt; 는 이러한 API를 비교적 직접적인 방식으로 노출하여 더 높은 수준의 코드를위한 최대의 성능과 유연성을 제공합니다. 그러나 이는 제공되는 정확한 API가 어떤 시스템 Trio가 실행 중인지에 따라 달라질 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="eb95d8cd3ebcdf23c20bd10cb88dc955ccccf297" translate="yes" xml:space="preserve">
          <source>Different environments expose different low-level APIs for performing async I/O. &lt;a href=&quot;#module-trio.lowlevel&quot;&gt;&lt;code&gt;trio.lowlevel&lt;/code&gt;&lt;/a&gt; exposes these APIs in a relatively direct way, so as to allow maximum power and flexibility for higher level code. However, this means that the exact API provided may vary depending on what system Trio is running on.</source>
          <target state="translated">서로 다른 환경은 비동기 I / O를 수행하기 위해 서로 다른 저수준 API를 노출합니다. &lt;a href=&quot;#module-trio.lowlevel&quot;&gt; &lt;code&gt;trio.lowlevel&lt;/code&gt; &lt;/a&gt; 은 상대적으로 직접적인 방식으로 이러한 API를 노출하여 상위 레벨 코드에 최대의 성능과 유연성을 허용합니다. 그러나 이는 제공된 정확한 API가 Trio가 실행중인 시스템에 따라 다를 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d53b85148fd0778fe09804c73cc97015c67517b5" translate="yes" xml:space="preserve">
          <source>Discards any pending data from the internal buffer, and marks this stream as closed.</source>
          <target state="translated">내부 버퍼에서 보류중인 데이터를 버리고이 스트림을 닫힌 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="eb69b4f0d0a5c5bb423cba52d380509e75983c19" translate="yes" xml:space="preserve">
          <source>Discussion forum: &lt;a href=&quot;https://trio.discourse.group&quot;&gt;https://trio.discourse.group&lt;/a&gt;</source>
          <target state="translated">토론 포럼 : &lt;a href=&quot;https://trio.discourse.group&quot;&gt;https://trio.discourse.group&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cc6639be7bef8ebc4645daa5f535d0c081d565f7" translate="yes" xml:space="preserve">
          <source>Do any setup this clock might need.</source>
          <target state="translated">이 시계에 필요한 설정을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="3746016608ec0fb055b71a5ef557a7383f775460" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t confuse this with the &lt;a href=&quot;https://en.wikipedia.org/wiki/Leaky_bucket&quot;&gt;&amp;ldquo;leaky bucket&amp;rdquo;&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Token_bucket&quot;&gt;&amp;ldquo;token bucket&amp;rdquo;&lt;/a&gt; algorithms used to limit bandwidth usage on networks. The basic idea of using tokens to track a resource limit is similar, but this is a very simple sack where tokens aren&amp;rsquo;t automatically created or destroyed over time; they&amp;rsquo;re just borrowed and then put back.</source>
          <target state="translated">네트워크의 대역폭 사용을 제한하는 데 사용되는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Leaky_bucket&quot;&gt;&quot;누설 버킷&quot;&lt;/a&gt; 또는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Token_bucket&quot;&gt;&quot;토큰 버킷&quot;&lt;/a&gt; 알고리즘 과 혼동하지 마십시오 . 자원 제한을 추적하기 위해 토큰을 사용하는 기본 개념은 비슷하지만 시간이지나면서 토큰이 자동으로 생성되거나 파괴되지 않는 매우 간단한 자루입니다. 그들은 방금 빌린 다음 다시 넣습니다.</target>
        </trans-unit>
        <trans-unit id="49e4cf834c2c18317da25833af31c4c049a6fee9" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t worry &amp;ndash; Trio&amp;rsquo;s got your back. Since checkpoints are important and ubiquitous, we make it as simple as possible to keep track of them. Here are the rules:</source>
          <target state="translated">걱정 마세요 &amp;ndash; 트리오가 등을 맞았습니다. 검사 점이 중요하고 어디에나 있기 때문에 가능한 한 간단하게 검사 점을 추적 할 수 있습니다. 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="913f6fc58a1e961561938ad5dac8c30039297367" translate="yes" xml:space="preserve">
          <source>Due to limitations of the underlying operating system APIs, it is not always possible to properly cancel a connection attempt once it has begun. If &lt;a href=&quot;#trio.socket.SocketType.connect&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; is cancelled, and is unable to abort the connection attempt, then it will:</source>
          <target state="translated">기본 운영 체제 API의 한계로 인해 시작된 연결 시도를 항상 올바르게 취소 할 수있는 것은 아닙니다. 경우 &lt;a href=&quot;#trio.socket.SocketType.connect&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt; 해제하고 연결 시도를 중단 할 수없는되어, 그것은 것입니다 :</target>
        </trans-unit>
        <trans-unit id="f3a5eb11d87d8dcf932da28283e1ab1bca1ea3f4" translate="yes" xml:space="preserve">
          <source>Each call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; has exactly one associated &lt;a href=&quot;#trio.hazmat.TrioToken&quot;&gt;&lt;code&gt;TrioToken&lt;/code&gt;&lt;/a&gt; object, so you can use it to identify a particular call.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 각 호출 에는 정확히 하나의 연결된 &lt;a href=&quot;#trio.hazmat.TrioToken&quot;&gt; &lt;code&gt;TrioToken&lt;/code&gt; &lt;/a&gt; 객체가 있으므로이를 사용하여 특정 호출을 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27c36db2bec2308382912fb68ac3e95e4349a718" translate="yes" xml:space="preserve">
          <source>Each call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; has exactly one associated &lt;a href=&quot;#trio.lowlevel.TrioToken&quot;&gt;&lt;code&gt;TrioToken&lt;/code&gt;&lt;/a&gt; object, so you can use it to identify a particular call.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 각 호출 에는 정확히 하나의 연관된 &lt;a href=&quot;#trio.lowlevel.TrioToken&quot;&gt; &lt;code&gt;TrioToken&lt;/code&gt; &lt;/a&gt; 객체가 있으므로이를 사용하여 특정 호출을 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40c2e9ddbb54382357ee3fcd6556d073c6ed4d66" translate="yes" xml:space="preserve">
          <source>Each host loop can only have one &lt;a href=&quot;#trio.lowlevel.start_guest_run&quot;&gt;&lt;code&gt;start_guest_run&lt;/code&gt;&lt;/a&gt; at a time. If you try to start a second one, you&amp;rsquo;ll get an error. If you need to run multiple Trio functions at the same time, then start up a single Trio run, open a nursery, and then start your functions as child tasks in that nursery.</source>
          <target state="translated">각 호스트 루프는 한 번에 하나의 &lt;a href=&quot;#trio.lowlevel.start_guest_run&quot;&gt; &lt;code&gt;start_guest_run&lt;/code&gt; &lt;/a&gt; 만 가질 수 있습니다 . 두 번째를 시작하려고하면 오류가 발생합니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 동시에 여러 Trio 기능을 실행해야하는 경우 단일 Trio 실행을 시작하고 nursery를 연 다음 해당 nursery에서 하위 작업으로 기능을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="21972250e317ce9dc708573892afe55a4f72e103" translate="yes" xml:space="preserve">
          <source>Each host loop can only have one guest run at a time.</source>
          <target state="translated">각 호스트 루프는 한 번에 하나의 게스트 만 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65e85ee667572f1c414cc77a68130d34982ee8c4" translate="yes" xml:space="preserve">
          <source>Each standard stream is only available if you specify that a pipe should be created for it. For example, if you pass &lt;code&gt;stdin=subprocess.PIPE&lt;/code&gt;, you can write to the &lt;a href=&quot;#trio.Process.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; stream, else &lt;a href=&quot;#trio.Process.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">각 표준 스트림은 파이프를 작성하도록 지정한 경우에만 사용 가능합니다. 예를 들어 통과하면 &lt;code&gt;stdin=subprocess.PIPE&lt;/code&gt; 하면 &lt;a href=&quot;#trio.Process.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt; 스트림에 쓸 수 있으며 , 그렇지 않으면 &lt;a href=&quot;#trio.Process.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8157ddc49b9ae3cbc101ffab074f90591c246ff3" translate="yes" xml:space="preserve">
          <source>Efficiency: guest mode is event-driven instead of using a busy-loop, so it has low latency and doesn&amp;rsquo;t waste electricity.</source>
          <target state="translated">효율성 : 게스트 모드는 바쁜 루프를 사용하는 대신 이벤트 기반이므로 대기 시간이 짧고 전기를 낭비하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1a68ba745dd4b45565cc59ceb8fbfb0631b79b4" translate="yes" xml:space="preserve">
          <source>Encrypt some data and then send it on the underlying transport.</source>
          <target state="translated">일부 데이터를 암호화 한 다음 기본 전송으로 전송하십시오.</target>
        </trans-unit>
        <trans-unit id="0b4c62f9905e08096736c80be6b7ec40116ed5ed" translate="yes" xml:space="preserve">
          <source>Encrypted communication using SSL/TLS.</source>
          <target state="translated">SSL / TLS를 사용한 암호화 된 통신</target>
        </trans-unit>
        <trans-unit id="86de1bfa52c3e4766f699ef16765dbd03a3319f9" translate="yes" xml:space="preserve">
          <source>Enforcement Examples</source>
          <target state="translated">시행 예</target>
        </trans-unit>
        <trans-unit id="30ad3a9a2afb2111b7765c691e99a5da39f50d0f" translate="yes" xml:space="preserve">
          <source>Ensure that the initial handshake has completed.</source>
          <target state="translated">초기 핸드 셰이크가 완료되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f2da480b2f64c9d3565292a14c9f547cfaf97f33" translate="yes" xml:space="preserve">
          <source>Entering Trio</source>
          <target state="translated">트리오 입력</target>
        </trans-unit>
        <trans-unit id="9abc3cbe1eb3dbb9c76b4daff2806c46dd7c2398" translate="yes" xml:space="preserve">
          <source>Entering the context manager is synchronous (not a checkpoint); exiting it calls &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt;. The default implementations of &lt;code&gt;__aenter__&lt;/code&gt; and &lt;code&gt;__aexit__&lt;/code&gt; should be adequate for all subclasses.</source>
          <target state="translated">컨텍스트 관리자 입력은 체크 포인트가 아닌 동기식입니다. 종료하면 &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 호출 됩니다. 기본 구현 &lt;code&gt;__aenter__&lt;/code&gt; 및 &lt;code&gt;__aexit__&lt;/code&gt; 모든 하위 클래스에 적합해야합니다.</target>
        </trans-unit>
        <trans-unit id="bd77c7c89aaac60eda264bbe76c2fb3877f1bec7" translate="yes" xml:space="preserve">
          <source>Entering this context manager starts listening for the given signals and returns an async iterator; exiting the context manager stops listening.</source>
          <target state="translated">이 컨텍스트 관리자에 들어가면 주어진 신호를 수신하기 시작하고 비동기 반복기를 반환합니다. 컨텍스트 관리자를 종료하면 청취가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="577a6f5217758f5680c1ac4ab28d646c851b6515" translate="yes" xml:space="preserve">
          <source>Equivalent to (but potentially more efficient than):</source>
          <target state="translated">다음과 동일하지만 잠재적으로 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="ff71f1502a09a0efc6bf6b8df7b2130d8639c933" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;await trio.sleep(0)&lt;/code&gt; (which is implemented by calling &lt;a href=&quot;#trio.hazmat.checkpoint&quot;&gt;&lt;code&gt;checkpoint()&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">상당 &lt;code&gt;await trio.sleep(0)&lt;/code&gt; 호출에 의해 구현된다 (&lt;a href=&quot;#trio.hazmat.checkpoint&quot;&gt; &lt;code&gt;checkpoint()&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="635a279433683f8f7c77c77638b33621d0f16025" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;await trio.sleep(0)&lt;/code&gt; (which is implemented by calling &lt;a href=&quot;#trio.lowlevel.checkpoint&quot;&gt;&lt;code&gt;checkpoint()&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">상당 &lt;code&gt;await trio.sleep(0)&lt;/code&gt; (호출에 의해 구현되는 &lt;a href=&quot;#trio.lowlevel.checkpoint&quot;&gt; &lt;code&gt;checkpoint()&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f382ebfc0131e10b8880c5dcb889ae9616bf535a" translate="yes" xml:space="preserve">
          <source>Equivalent to calling &lt;code&gt;await sleep(math.inf)&lt;/code&gt;.</source>
          <target state="translated">부름에 해당 &lt;code&gt;await sleep(math.inf)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f06260807eabf1e2cdab615aead6b6fb18bc907c" translate="yes" xml:space="preserve">
          <source>Error handling:</source>
          <target state="translated">오류 처리:</target>
        </trans-unit>
        <trans-unit id="5ee23a39f0b9c090f3744086941471cc71f4df96" translate="yes" xml:space="preserve">
          <source>Errors in multiple child tasks</source>
          <target state="translated">여러 하위 작업의 오류</target>
        </trans-unit>
        <trans-unit id="e0ace80de082dc37e3d719147a18d3df854a1b73" translate="yes" xml:space="preserve">
          <source>Essentially, the body of the &lt;code&gt;async with&lt;/code&gt; block acts like an initial task that&amp;rsquo;s running inside the nursery, and then each call to &lt;code&gt;nursery.start_soon&lt;/code&gt; adds another task that runs in parallel. Two crucial things to keep in mind:</source>
          <target state="translated">본질적으로, 본체 &lt;code&gt;async with&lt;/code&gt; 블록은 초기 보육 내부에서 실행중인 작업 및 호출 할 때마다 같은 역할을 &lt;code&gt;nursery.start_soon&lt;/code&gt; 대한 은 병렬로 실행되는 다른 작업을 추가합니다. 명심해야 할 두 가지 중요한 사항 :</target>
        </trans-unit>
        <trans-unit id="94511c8fe5d02860cbae8a93867794aff11407ac" translate="yes" xml:space="preserve">
          <source>Every call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; has an associated clock.</source>
          <target state="translated">&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 에 대한 모든 호출 에는 관련 시계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6da5df3c0217f2dd602bff18b094f6738fa41e40" translate="yes" xml:space="preserve">
          <source>Every successful execution path passes through a checkpoint (assuming that &lt;code&gt;wait_for_operation_to_be_ready&lt;/code&gt; is an unconditional checkpoint)</source>
          <target state="translated">모든 성공적인 실행 경로는 검사 점을 통과합니다 ( &lt;code&gt;wait_for_operation_to_be_ready&lt;/code&gt; 가 무조건 검사 점 이라고 가정 )</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="950f4fc18cdc90c9c93a02882a39bdff0c115ba2" translate="yes" xml:space="preserve">
          <source>Example implementations</source>
          <target state="translated">구현 예</target>
        </trans-unit>
        <trans-unit id="65cee81e771dd281fa49a0152c7e600fa8e0a7ec" translate="yes" xml:space="preserve">
          <source>Example output (yours may differ slightly):</source>
          <target state="translated">출력 예 (약간 다를 수 있음) :</target>
        </trans-unit>
        <trans-unit id="9684bdcdfe4872be868a6df199c0d4c63ad6a6b9" translate="yes" xml:space="preserve">
          <source>Example use case: drawing a visualization of the task tree in a debugger.</source>
          <target state="translated">사용 사례 예 : 디버거에서 작업 트리의 시각화를 그립니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="ccf1573108e16e6d38ba26ddc8eacf022ebd30f9" translate="yes" xml:space="preserve">
          <source>Exceptions and warnings</source>
          <target state="translated">예외 및 경고</target>
        </trans-unit>
        <trans-unit id="a5ef272f6a2530c8104c0aa1dff5bd1ca42d05ac" translate="yes" xml:space="preserve">
          <source>Execute a child program in a new process.</source>
          <target state="translated">새 프로세스에서 하위 프로그램을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="3e1ccb6354b2da97b8d7d99a1462df1a225394ac" translate="yes" xml:space="preserve">
          <source>Explicitly mark the object as closed, so that any new attempts to use it will abort before they start.</source>
          <target state="translated">객체를 닫힘으로 명시 적으로 표시하여 새 사용 시도가 시작되기 전에 중단되도록합니다.</target>
        </trans-unit>
        <trans-unit id="9a507f0e5168c6ed30b03a96ee64617f5b05c7fe" translate="yes" xml:space="preserve">
          <source>Fairness</source>
          <target state="translated">Fairness</target>
        </trans-unit>
        <trans-unit id="4654b2a5f2578ac85eb620c7f87d7844f6e0bb05" translate="yes" xml:space="preserve">
          <source>Finalization</source>
          <target state="translated">Finalization</target>
        </trans-unit>
        <trans-unit id="36ebc08b0a99d629a11b0e8b00f5c5994c6741e9" translate="yes" xml:space="preserve">
          <source>First we do all our interaction with the state machine in a single scheduling quantum (notice there are no &lt;code&gt;await&lt;/code&gt;s in there), so it&amp;rsquo;s automatically atomic with respect to other tasks. And then if and only if we have data to send, we get in line to send it &amp;ndash; and &lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt;&lt;code&gt;StrictFIFOLock&lt;/code&gt;&lt;/a&gt; guarantees that each task will send its data in the same order that the state machine generated it.</source>
          <target state="translated">먼저 단일 스케줄링 퀀텀에서 상태 머신과의 모든 상호 작용을 수행하므로 &lt;code&gt;await&lt;/code&gt; 이 없습니다 . 다른 작업과 관련하여 자동으로 원자 적입니다. 그리고 전송할 데이터가있는 경우에만 전송할 수 있습니다 &amp;ndash; 그리고 &lt;a href=&quot;#trio.StrictFIFOLock&quot;&gt; &lt;code&gt;StrictFIFOLock&lt;/code&gt; &lt;/a&gt; 은 각 작업이 상태 머신이 생성 한 순서와 동일한 순서로 데이터를 전송하도록 보장합니다.</target>
        </trans-unit>
        <trans-unit id="39aad0e951ec2a465a7527afcee9229d642c5338" translate="yes" xml:space="preserve">
          <source>First, Trio provides analogues to all the standard library functions that return socket objects; their interface is identical, except that they&amp;rsquo;re modified to return Trio socket objects instead:</source>
          <target state="translated">첫째, Trio는 소켓 객체를 반환하는 모든 표준 라이브러리 함수에 대한 아날로그를 제공합니다. 인터페이스는 동일하지만 대신 Trio 소켓 객체를 반환하도록 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="87b15f31f9acbf1b346b9723758dae62bdd83b37" translate="yes" xml:space="preserve">
          <source>First, and most obviously, everything is made &amp;ldquo;Trio-style&amp;rdquo;: blocking methods become async methods, and the following attributes are &lt;em&gt;not&lt;/em&gt; supported:</source>
          <target state="translated">먼저 가장 확실한 것은 모든 것이&amp;ldquo;트리오 스타일&amp;rdquo;입니다. 차단 방법은 비동기 방법이되며 다음 속성은 지원 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="33a46082d4c0c205f40bd03118ef081113f4cc26" translate="yes" xml:space="preserve">
          <source>First, instead of blocking until &lt;code&gt;trio_main&lt;/code&gt; has finished, it schedules &lt;code&gt;trio_main&lt;/code&gt; to start running on top of the host loop, and then returns immediately. So &lt;code&gt;trio_main&lt;/code&gt; is running in the background &amp;ndash; that&amp;rsquo;s why we have to sleep and give it time to finish.</source>
          <target state="translated">첫째, 대신 때까지 블록의 &lt;code&gt;trio_main&lt;/code&gt; 이 완료, 그것은 일정 &lt;code&gt;trio_main&lt;/code&gt; 호스트 루프의 상단에 실행을 시작하고, 즉시 반환합니다. 그래서 &lt;code&gt;trio_main&lt;/code&gt; 이 백그라운드에서 실행되고 있습니다. 이것이 우리가 잠을 자고 완료 할 시간을 주어야하는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="3d0602bcf5eefcc21823064ff06ea71c922833a9" translate="yes" xml:space="preserve">
          <source>First, right now no mainstream operating system offers a generic, reliable, native API for async file or filesystem operations, so we have to fake it by using threads (specifically, &lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt;). This is cheap but isn&amp;rsquo;t free: on a typical PC, dispatching to a worker thread adds something like ~100 &amp;micro;s of overhead to each operation. (&amp;ldquo;&amp;micro;s&amp;rdquo; is pronounced &amp;ldquo;microseconds&amp;rdquo;, and there are 1,000,000 &amp;micro;s in a second. Note that all the numbers here are going to be rough orders of magnitude to give you a sense of scale; if you need precise numbers for your environment, measure!)</source>
          <target state="translated">첫째, 현재 어떤 주류 운영 체제도 비동기 파일 또는 파일 시스템 작업을위한 일반적이고 안정적인 기본 API를 제공하지 않으므로 스레드 (특히 &lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt; 사용하여 위조해야합니다. ) 합니다. 이것은 저렴하지만 무료는 아닙니다. 일반적인 PC에서 작업자 스레드로 디스패치하면 각 작업에 ~ 100&amp;micro;s의 오버 헤드가 추가됩니다. ( &quot;&amp;micro;s&quot;는 &quot;마이크로 초&quot;로 표시되며 1 초에 1,000,000&amp;micro;s가 있습니다. 여기에있는 모든 숫자는 대략적인 규모로되어있어 규모를 파악할 수 있습니다. 환경에 정확한 숫자가 필요한 경우, 법안!)</target>
        </trans-unit>
        <trans-unit id="ca5c3533f4947d91091d8c153071aa71047806c7" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;done_callback&lt;/code&gt;, you pass in a function that Trio will automatically invoke when the Trio run finishes, so you know it&amp;rsquo;s done and what happened. For this basic starting version, we just print the result; in the next section we&amp;rsquo;ll discuss better alternatives.</source>
          <target state="translated">들어 &lt;code&gt;done_callback&lt;/code&gt; , 당신은 당신이 알 수 있도록 트리오 실행 완료는, 그것이 수행하고 무슨 일 때 트리오가 자동으로 호출됩니다 함수에 전달합니다. 이 기본 시작 버전의 경우 결과 만 인쇄합니다. 다음 섹션에서는 더 나은 대안에 대해 논의 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="3da31e653656a075dd79a639c9db8f5e0e863038" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;run_sync_soon_threadsafe&lt;/code&gt;, we need a function that takes a synchronous callback, and schedules it to run on your host loop. And this function needs to be &amp;ldquo;threadsafe&amp;rdquo; in the sense that you can safely call it from any thread. So you need to figure out how to write a function that does that using your host loop&amp;rsquo;s API. For asyncio, this is easy because &lt;a href=&quot;https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.call_soon_threadsafe&quot;&gt;&lt;code&gt;call_soon_threadsafe&lt;/code&gt;&lt;/a&gt; does exactly what we need; for your loop, it might be more or less complicated.</source>
          <target state="translated">들어 &lt;code&gt;run_sync_soon_threadsafe&lt;/code&gt; , 우리는 호스트 루프에서 실행하는 동기 콜백 소요 기능, 일정이 필요합니다. 그리고이 함수는 모든 스레드에서 안전하게 호출 할 수 있다는 점에서 &quot;스레드 안전&quot;이어야합니다. 따라서 호스트 루프의 API를 사용하여이를 수행하는 함수를 작성하는 방법을 알아 내야합니다. asyncio의 경우 &lt;a href=&quot;https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.call_soon_threadsafe&quot;&gt; &lt;code&gt;call_soon_threadsafe&lt;/code&gt; &lt;/a&gt; 가 정확히 필요한 작업을 수행 하기 때문에 쉽습니다 . 루프의 경우 다소 복잡 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a05d658dc1c542b05e5284639df77ae27e0c00f0" translate="yes" xml:space="preserve">
          <source>For a clock using wall-time, this should be something like:</source>
          <target state="translated">벽시계를 사용하는 시계의 경우 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="48709ea5cba4eb96bb491cf99f5fd3676afdc21d" translate="yes" xml:space="preserve">
          <source>For example, closing a TLS-wrapped socket normally involves sending a notification to the remote peer, so that they can be cryptographically assured that you really meant to close the socket, and your connection wasn&amp;rsquo;t just broken by a man-in-the-middle attacker. But handling this robustly is a bit tricky. Remember our &lt;a href=&quot;#blocking-cleanup-example&quot;&gt;example&lt;/a&gt; above where the blocking &lt;code&gt;send_goodbye_msg&lt;/code&gt; caused problems? That&amp;rsquo;s exactly how closing a TLS socket works: if the remote peer has disappeared, then our code may never be able to actually send our shutdown notification, and it would be nice if it didn&amp;rsquo;t block forever trying. Therefore, the method for closing a TLS-wrapped socket will &lt;em&gt;try&lt;/em&gt; to send that notification &amp;ndash; and if it gets cancelled, then it will give up on sending the message, but &lt;em&gt;will&lt;/em&gt; still close the underlying socket before raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;, so at least you don&amp;rsquo;t leak that resource.</source>
          <target state="translated">예를 들어, TLS로 감싼 소켓을 닫는 것은 일반적으로 원격 피어에 알림을 보내는 것을 포함하므로 실제로 소켓을 닫으려는 의도가 있음을 암호로 보장 할 수 있으며 연결은 사람에 의해 끊어지지 않았습니다. 중간 공격자. 그러나 이것을 강력하게 처리하는 것은 약간 까다 롭습니다. &lt;code&gt;send_goodbye_msg&lt;/code&gt; 차단 문제가 발생한 위 의 &lt;a href=&quot;#blocking-cleanup-example&quot;&gt;예를&lt;/a&gt; 기억 하십니까? 원격 피어가 사라지면 코드가 실제로 종료 알림을 보낼 수 없으며 영원히 시도하지 못하게하면 좋을 것입니다. 따라서 TLS로 감싼 소켓을 닫는 방법은 해당 알림을 보내며, 취소되면 메시지 전송을 포기하지만&lt;em&gt; 시도&lt;/em&gt;&lt;em&gt;것입니다&lt;/em&gt; 여전히 가까운 올리기 기본 소켓 전에 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; , 그래서 적어도 당신은 자원을 누설하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6f008f9eefbcebe7ebf5b1aab36adf73fbe45fd" translate="yes" xml:space="preserve">
          <source>For example, consider this naive extension of our previous example, now with two producers and two consumers:</source>
          <target state="translated">예를 들어, 앞의 예제에서이 순진한 확장을 생각해 보자. 이제 두 명의 생산자와 두 명의 소비자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c9f550fd71ac17462b4162b1e8a8748f24bd870" translate="yes" xml:space="preserve">
          <source>For example, here&amp;rsquo;s a function that takes a list of functions, runs them all concurrently, and returns the result from the one that finishes first:</source>
          <target state="translated">예를 들어, 다음은 함수 목록을 가져 와서 동시에 실행하며 먼저 완료되는 결과를 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="3e1b83209368f33cb57342986c90a06fb5c4a5ce" translate="yes" xml:space="preserve">
          <source>For example, if two tasks try to send data through the same socket at the same time, Trio will raise &lt;a href=&quot;#trio.BusyResourceError&quot;&gt;&lt;code&gt;BusyResourceError&lt;/code&gt;&lt;/a&gt; instead of letting the data get scrambled.</source>
          <target state="translated">예를 들어, 두 작업이 동시에 같은 소켓을 통해 데이터를 보내려고 하면 데이터가 스크램블되는 대신 Trio는 &lt;a href=&quot;#trio.BusyResourceError&quot;&gt; &lt;code&gt;BusyResourceError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a9203322c4e642fda52a346d7a4dd7f31f89ac48" translate="yes" xml:space="preserve">
          <source>For example, suppose we call &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; on a TLS-encrypted connection. This requires sending a &amp;ldquo;goodbye&amp;rdquo; message; but if the peer has become non-responsive, then our attempt to send this message might block forever, and eventually time out and be cancelled. In this case the &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; will immediately close the underlying transport stream using &lt;a href=&quot;#trio.aclose_forcefully&quot;&gt;&lt;code&gt;trio.aclose_forcefully()&lt;/code&gt;&lt;/a&gt; before raising &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; TLS 암호화 연결에서 를 합니다. 이를 위해서는 &quot;안녕&quot;메시지를 보내야합니다. 그러나 피어가 응답하지 않으면이 메시지를 보내려는 시도가 영원히 차단되어 결국 시간이 초과되어 취소 될 수 있습니다. 이 경우 &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 에있어서 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; 은&lt;/a&gt; 바로 가까이 기본 전송 스트림을 사용한다 &lt;a href=&quot;#trio.aclose_forcefully&quot;&gt; &lt;code&gt;trio.aclose_forcefully()&lt;/code&gt; &lt;/a&gt; 올리기 전에 서버 &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac06852dca276320b16fff1f304ea99d8948264b" translate="yes" xml:space="preserve">
          <source>For example, the following is a roundabout way to print the numbers 0 through 9 with a 1-second delay before each one:</source>
          <target state="translated">예를 들어, 다음은 0부터 9까지의 숫자를 각각 1 초씩 지연하여 인쇄하는 로터리 방법입니다.</target>
        </trans-unit>
        <trans-unit id="0b30a4a3439bea3af8a737486ca4c36858c90d06" translate="yes" xml:space="preserve">
          <source>For example, you might get this if you try to send data on a stream where the remote side has already closed the connection.</source>
          <target state="translated">예를 들어, 원격 측이 이미 연결을 닫은 스트림에서 데이터를 보내려고하면이 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="754808bf0708063b84e277d59f6510cb1a566551" translate="yes" xml:space="preserve">
          <source>For more discussion, see Trio issues &lt;a href=&quot;https://github.com/python-trio/trio/issues/264&quot;&gt;264&lt;/a&gt; (especially &lt;a href=&quot;https://github.com/python-trio/trio/issues/264#issuecomment-418989328&quot;&gt;this comment&lt;/a&gt;) and &lt;a href=&quot;https://github.com/python-trio/trio/issues/638&quot;&gt;638&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 Trio 문제 &lt;a href=&quot;https://github.com/python-trio/trio/issues/264&quot;&gt;264&lt;/a&gt; (특히이 &lt;a href=&quot;https://github.com/python-trio/trio/issues/264#issuecomment-418989328&quot;&gt;설명&lt;/a&gt; ) 및 &lt;a href=&quot;https://github.com/python-trio/trio/issues/638&quot;&gt;638을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f909978159a531021ff533705ba1c50305ee5043" translate="yes" xml:space="preserve">
          <source>For more information, read the &lt;a href=&quot;https://docs.python.org/3.7/library/contextvars.html&quot;&gt;contextvar docs&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;https://docs.python.org/3.7/library/contextvars.html&quot;&gt;contextvar docs를&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="3cbd4cf4a20b121cf25b4d8a86f46de892ed87cc" translate="yes" xml:space="preserve">
          <source>For name lookup, Trio provides the standard functions, but with some changes:</source>
          <target state="translated">이름 조회를 위해 Trio는 표준 기능을 제공하지만 몇 가지 변경 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd4c0d3d9c603b00054846d54595ca9a7a4e9da3" translate="yes" xml:space="preserve">
          <source>For operations that have a non-blocking variant, the blocking and non-blocking variants are different methods with names like &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;X_nowait&lt;/code&gt;, respectively. (This is similar to &lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Queue&quot;&gt;&lt;code&gt;queue.Queue&lt;/code&gt;&lt;/a&gt;, but unlike most of the classes in &lt;a href=&quot;https://docs.python.org/3/library/threading.html#module-threading&quot;&gt;&lt;code&gt;threading&lt;/code&gt;&lt;/a&gt;.) We like this approach because it allows us to make the blocking version async and the non-blocking version sync.</source>
          <target state="translated">비 차단 변형이있는 작업의 경우 차단 및 비 차단 변형은 &lt;code&gt;X&lt;/code&gt; 와 같은 이름을 가진 다른 방법입니다. 각각 및 &lt;code&gt;X_nowait&lt;/code&gt; 와 . (이것은 &lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Queue&quot;&gt; &lt;code&gt;queue.Queue&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 &lt;a href=&quot;https://docs.python.org/3/library/threading.html#module-threading&quot;&gt; &lt;code&gt;threading&lt;/code&gt; &lt;/a&gt; 대부분의 클래스와는 다릅니다 .) 우리는 차단 버전을 비 동기화하고 비 차단 버전을 동기화시킬 수 있기 때문에이 접근법을 좋아합니다.</target>
        </trans-unit>
        <trans-unit id="af7c11a85341c774f7f483b666e5435a2c7dc4ac" translate="yes" xml:space="preserve">
          <source>For reading and writing to files and file-like objects, Trio also provides a mechanism for wrapping any synchronous file-like object into an asynchronous interface. If you have a &lt;a href=&quot;#trio.Path&quot;&gt;&lt;code&gt;trio.Path&lt;/code&gt;&lt;/a&gt; object you can get one of these by calling its &lt;a href=&quot;#trio.Path.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; method; or if you know the file&amp;rsquo;s name you can open it directly with &lt;a href=&quot;#trio.open_file&quot;&gt;&lt;code&gt;trio.open_file()&lt;/code&gt;&lt;/a&gt;. Alternatively, if you already have an open file-like object, you can wrap it with &lt;a href=&quot;#trio.wrap_file&quot;&gt;&lt;code&gt;trio.wrap_file()&lt;/code&gt;&lt;/a&gt; &amp;ndash; one case where this is especially useful is to wrap &lt;a href=&quot;https://docs.python.org/3/library/io.html#io.BytesIO&quot;&gt;&lt;code&gt;io.BytesIO&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/io.html#io.StringIO&quot;&gt;&lt;code&gt;io.StringIO&lt;/code&gt;&lt;/a&gt; when writing tests.</source>
          <target state="translated">파일 및 파일과 유사한 객체를 읽고 쓸 수 있도록 Trio는 동기식 파일과 유사한 객체를 비동기 인터페이스로 래핑하는 메커니즘도 제공합니다. &lt;a href=&quot;#trio.Path&quot;&gt; &lt;code&gt;trio.Path&lt;/code&gt; &lt;/a&gt; 객체 가 있다면 &lt;a href=&quot;#trio.Path.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 메소드를 호출 하여이 중 하나를 얻을 수 있습니다 . 또는 파일 이름을 알고 있으면 &lt;a href=&quot;#trio.open_file&quot;&gt; &lt;code&gt;trio.open_file()&lt;/code&gt; &lt;/a&gt; 직접 열 수 있습니다 . 또는 열려있는 파일과 유사한 객체가 이미있는 경우&lt;a href=&quot;#trio.wrap_file&quot;&gt; &lt;code&gt;trio.wrap_file()&lt;/code&gt; &lt;/a&gt;특히 유용한경우 테스트 작성시&lt;a href=&quot;https://docs.python.org/3/library/io.html#io.BytesIO&quot;&gt; &lt;code&gt;io.BytesIO&lt;/code&gt; &lt;/a&gt; 또는&lt;a href=&quot;https://docs.python.org/3/library/io.html#io.StringIO&quot;&gt; &lt;code&gt;io.StringIO&lt;/code&gt; &lt;/a&gt; 를 래핑하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d4fb4d90d41ab66d702c6015719d8d4dd284bcea" translate="yes" xml:space="preserve">
          <source>For the meaning of other arguments, see &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다른 인수의 의미는 &lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="82ef028042140eef57f0f36ca8b9b254552de55e" translate="yes" xml:space="preserve">
          <source>Fortunately this isn&amp;rsquo;t as bad as it sounds, because the HTTP protocol already includes its own equivalent of &lt;code&gt;close_notify&lt;/code&gt;, so doing this again at the SSL/TLS level is redundant. But not all protocols do! Therefore, by default Trio implements the safer standard-compliant version (&lt;code&gt;https_compatible=False&lt;/code&gt;). But if you&amp;rsquo;re speaking HTTPS or some other protocol where &lt;code&gt;close_notify&lt;/code&gt;s are commonly skipped, then you should set &lt;code&gt;https_compatible=True&lt;/code&gt;; with this setting, Trio will neither expect nor send &lt;code&gt;close_notify&lt;/code&gt; messages.</source>
          <target state="translated">다행스럽게도 HTTP 프로토콜에는 이미 &lt;code&gt;close_notify&lt;/code&gt; 와 동등한 자체가 포함되어 있기 때문에 SSL / TLS 수준에서 다시 수행하는 것이 중복 되기 때문에 이것은 나쁘지 않습니다 . 그러나 모든 프로토콜이 아닙니다! 따라서 기본적으로 Trio는보다 안전한 표준 호환 버전을 구현합니다 ( &lt;code&gt;https_compatible=False&lt;/code&gt; )을 . 그러나 HTTPS 또는 &lt;code&gt;close_notify&lt;/code&gt; 가 일반적으로 건너 뛰는 다른 프로토콜을 말하는 경우 &lt;code&gt;https_compatible=True&lt;/code&gt; 를 설정해야합니다 . 이 설정을 사용하면 Trio는 &lt;code&gt;close_notify&lt;/code&gt; 메시지를 기대하거나 보내지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d15dc5d1075d65dae25982087c3ad3acc292130c" translate="yes" xml:space="preserve">
          <source>From inside the worker thread, you can get back into Trio using the functions in &lt;a href=&quot;#module-trio.from_thread&quot;&gt;&lt;code&gt;trio.from_thread&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업자 스레드 내부에서 &lt;a href=&quot;#module-trio.from_thread&quot;&gt; &lt;code&gt;trio.from_thread&lt;/code&gt; &lt;/a&gt; 의 함수를 사용하여 Trio로 돌아갈 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="096bafb1ad02c5e340fc0cffb7efac1d03c6fdd6" translate="yes" xml:space="preserve">
          <source>Further reading:</source>
          <target state="translated">더 읽을 거리 :</target>
        </trans-unit>
        <trans-unit id="14b4abcfb38d8e2bedf23453f682373a91ca1df3" translate="yes" xml:space="preserve">
          <source>General principles</source>
          <target state="translated">일반 원칙</target>
        </trans-unit>
        <trans-unit id="dddff76e9bcd243042913dcbce280ef09d28641b" translate="yes" xml:space="preserve">
          <source>Generally &lt;code&gt;fn&lt;/code&gt; does some blocking work, and &lt;code&gt;deliver&lt;/code&gt; delivers the result back to whoever is interested.</source>
          <target state="translated">일반적으로 &lt;code&gt;fn&lt;/code&gt; 일부 차단 작업을 수행하고, &lt;code&gt;deliver&lt;/code&gt; 관심 누구든지 결과 등을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1d33591f44b73461a418fdd7300d5ea81ebd01a0" translate="yes" xml:space="preserve">
          <source>Generally the way it works is that before calling this function, you make arrangements for &amp;ldquo;someone&amp;rdquo; to call &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; on the current task at some later point.</source>
          <target state="translated">일반적으로 작동하는 방식은이 함수를 호출하기 전에 &quot;누군가&quot;가 전화를 걸도록 조정하는 것입니다. &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt;나중에 현재 작업에서 reschedule () 조정하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="8fbdc9ff450f877482e407a69ae70ea6af10c52b" translate="yes" xml:space="preserve">
          <source>Generally the way it works is that before calling this function, you make arrangements for &amp;ldquo;someone&amp;rdquo; to call &lt;a href=&quot;#trio.lowlevel.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; on the current task at some later point.</source>
          <target state="translated">일반적으로 작동 방식은이 함수를 호출하기 전에 &quot;누군가&quot;가 나중에 언젠가 현재 작업에 대해 &lt;a href=&quot;#trio.lowlevel.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; 을 호출하도록 준비하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e36516ef81e825f5f1a9afc1d80d86f1816a2bbe" translate="yes" xml:space="preserve">
          <source>Generally you should call this function just once, right at the beginning of your program.</source>
          <target state="translated">일반적으로 프로그램 시작시이 함수를 한 번만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="6dbd080c65cdd758570339c25de579b2dd1b8134" translate="yes" xml:space="preserve">
          <source>Generally, the API exposed by &lt;a href=&quot;#module-trio.socket&quot;&gt;&lt;code&gt;trio.socket&lt;/code&gt;&lt;/a&gt; mirrors that of the standard library &lt;a href=&quot;https://docs.python.org/3/library/socket.html#module-socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; module. Most constants (like &lt;code&gt;SOL_SOCKET&lt;/code&gt;) and simple utilities (like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.inet_aton&quot;&gt;&lt;code&gt;inet_aton()&lt;/code&gt;&lt;/a&gt;) are simply re-exported unchanged. But there are also some differences, which are described here.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#module-trio.socket&quot;&gt; &lt;code&gt;trio.socket&lt;/code&gt; &lt;/a&gt; 에 의해 노출 된 API 는 표준 라이브러리 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#module-socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt; 모듈 의 API를 미러링합니다 . 대부분의 상수 (예 : &lt;code&gt;SOL_SOCKET&lt;/code&gt; ) 및 간단한 유틸리티 (예 :&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.inet_aton&quot;&gt; &lt;code&gt;inet_aton()&lt;/code&gt; &lt;/a&gt; )는 그대로 그대로 다시 내보내집니다. 그러나 여기에 설명 된 차이점도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4853da74f39314ec159dc478cc249c9ba81d23e9" translate="yes" xml:space="preserve">
          <source>Generally, the best way to do this is wrap this in a function that starts the host loop and then immediately starts the guest run, and then shuts down the host when the guest run completes.</source>
          <target state="translated">일반적으로이를 수행하는 가장 좋은 방법은 호스트 루프를 시작한 다음 즉시 게스트 실행을 시작한 다음 게스트 실행이 완료되면 호스트를 종료하는 함수로이를 래핑하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="df6e0ad77a1d03e22e4e78c091cdce9b18814852" translate="yes" xml:space="preserve">
          <source>Generic stream tools</source>
          <target state="translated">일반 스트림 도구</target>
        </trans-unit>
        <trans-unit id="c61ec329c35890384eca7f8141d511f90a23bba7" translate="yes" xml:space="preserve">
          <source>Get the default &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; used by &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용되는 기본 &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; 를 가져&lt;/a&gt; 옵니다.&lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync&lt;/code&gt; 가 가져옵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="424f1939c9512c36dd942c09a91b79a3e7cd2f59" translate="yes" xml:space="preserve">
          <source>Getting back into the Trio thread from another thread</source>
          <target state="translated">다른 스레드에서 Trio 스레드로 돌아 가기</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="ed979c344a025df1e99b8420fa24cb2308bccd80" translate="yes" xml:space="preserve">
          <source>Given these constraints, we think the simplest approach is to always start and stop the two loops together.</source>
          <target state="translated">이러한 제약 조건을 감안할 때 가장 간단한 방법은 항상 두 루프를 함께 시작하고 중지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f1f01defeb8ad40ed473adada63fd85ed9fd2cce" translate="yes" xml:space="preserve">
          <source>Global state: system tasks and run-local variables</source>
          <target state="translated">글로벌 상태 : 시스템 작업 및 로컬 실행 변수</target>
        </trans-unit>
        <trans-unit id="3d2cbcea420fd9b8c76106a48d0b289d21c579de" translate="yes" xml:space="preserve">
          <source>Global statistics</source>
          <target state="translated">글로벌 통계</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="823619e079c311b099f1d0e427a584eafcd6ed06" translate="yes" xml:space="preserve">
          <source>Governance</source>
          <target state="translated">Governance</target>
        </trans-unit>
        <trans-unit id="d134414d4290b4888745f30ed9ef9d0af9f97f62" translate="yes" xml:space="preserve">
          <source>Gracefully shut down this connection, and close the underlying transport.</source>
          <target state="translated">이 연결을 정상적으로 종료하고 기본 전송을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="51de6467e4ce05659d97203c6f4fe5fb2686e910" translate="yes" xml:space="preserve">
          <source>Handing off live coroutine objects between coroutine runners</source>
          <target state="translated">코 루틴 러너 사이에 라이브 코 루틴 객체를 전달</target>
        </trans-unit>
        <trans-unit id="f88d04389b281b3967803afb4eaa851b991783bb" translate="yes" xml:space="preserve">
          <source>Handling cancellation</source>
          <target state="translated">취소 처리</target>
        </trans-unit>
        <trans-unit id="cbf0820fc59d334aedf8e7fb6d8f0d097b139af9" translate="yes" xml:space="preserve">
          <source>Here if one or more of the racing functions raises an unhandled exception then Trio&amp;rsquo;s normal handling kicks in: it cancels the others and then propagates the exception. If you want different behavior, you can get that by adding a &lt;code&gt;try&lt;/code&gt; block to the &lt;code&gt;jockey&lt;/code&gt; function to catch exceptions and handle them however you like.</source>
          <target state="translated">여기서 하나 이상의 레이싱 함수가 처리되지 않은 예외를 발생 시키면 Trio의 일반 처리가 시작됩니다. 다른 동작을 원한다면 &lt;code&gt;jockey&lt;/code&gt; 함수에 &lt;code&gt;try&lt;/code&gt; 블록을 추가하여 예외를 포착하고 원하는대로 처리하여 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a81e9adeb9b0a32b3517c84f273b1dbbc540cd6e" translate="yes" xml:space="preserve">
          <source>Here the function acts as a checkpoint if you call it with &lt;code&gt;should_sleep&lt;/code&gt; set to a true value, but not otherwise. This is why we emphasize that Trio&amp;rsquo;s own async functions are &lt;em&gt;unconditional&lt;/em&gt; checkpoints: they &lt;em&gt;always&lt;/em&gt; check for cancellation and check for scheduling, regardless of what arguments they&amp;rsquo;re passed. If you find an async function in Trio that doesn&amp;rsquo;t follow this rule, then it&amp;rsquo;s a bug and you should &lt;a href=&quot;https://github.com/python-trio/trio/issues&quot;&gt;let us know&lt;/a&gt;.</source>
          <target state="translated">여기서 함수는 &lt;code&gt;should_sleep&lt;/code&gt; 을 true 값으로 설정하고 호출 하지 않으면 검사 점 역할을합니다 . 이것이 Trio의 자체 비동기 함수가 &lt;em&gt;무조건&lt;/em&gt; 체크 포인트 임을 강조하는 이유 입니다. 전달 된 인수에 관계없이 &lt;em&gt;항상&lt;/em&gt; 취소를 확인하고 스케줄링을 확인합니다. Trio에서이 규칙을 따르지 않는 비동기 함수를 찾으면 버그이며 &lt;a href=&quot;https://github.com/python-trio/trio/issues&quot;&gt;알려주십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e1243ad2370c1dcec5bc84d902878d0e26a4267" translate="yes" xml:space="preserve">
          <source>Here we pass clones into the tasks, but never close the original objects. That means we have 3 send channel objects (the original + two clones), but we only close 2 of them, so the consumers will hang around forever waiting for that last one to be closed.</source>
          <target state="translated">여기서 복제본을 작업에 전달하지만 원래 객체를 닫지 마십시오. 즉, 3 개의 송신 채널 객체 (원본 + 2 개의 복제본)가 있지만 그 중 2 개만 닫으므로 소비자는 마지막 객체가 닫힐 때까지 영원히 기다려야합니다.</target>
        </trans-unit>
        <trans-unit id="5b795a1957f433bb2a1910c85c849c3c303650bd" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a new version that fixes this: it produces the same output as the previous version, and then exits cleanly. The only change is the addition of &lt;code&gt;async with&lt;/code&gt; blocks inside the producer and consumer:</source>
          <target state="translated">다음은이 문제를 해결하는 새 버전입니다. 이전 버전과 동일한 출력을 생성 한 다음 완전히 종료됩니다. 유일한 변경 사항은 생산자와 소비자 내부의 블록 과 &lt;code&gt;async with&lt;/code&gt; 추가하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="d543e0e7e6827ddd190eadb52f0c6857ef3a5feb" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a rule of thumb for designing good Trio-style (&amp;ldquo;trionic&amp;rdquo;?) APIs: if you&amp;rsquo;re writing a reusable function, then you shouldn&amp;rsquo;t take a &lt;code&gt;timeout=&lt;/code&gt; parameter, and instead let your caller worry about it. This has several advantages. First, it leaves the caller&amp;rsquo;s options open for deciding how they prefer to handle timeouts &amp;ndash; for example, they might find it easier to work with absolute deadlines instead of relative timeouts. If they&amp;rsquo;re the ones calling into the cancellation machinery, then they get to pick, and you don&amp;rsquo;t have to worry about it. Second, and more importantly, this makes it easier for others to re-use your code. If you write a &lt;code&gt;http_get&lt;/code&gt; function, and then I come along later and write a &lt;code&gt;log_in_to_twitter&lt;/code&gt; function that needs to internally make several &lt;code&gt;http_get&lt;/code&gt; calls, I don&amp;rsquo;t want to have to figure out how to configure the individual timeouts on each of those calls &amp;ndash; and with Trio&amp;rsquo;s timeout system, it&amp;rsquo;s totally unnecessary.</source>
          <target state="translated">재사용 가능한 함수를 작성하는 경우 &lt;code&gt;timeout=&lt;/code&gt; 매개 변수를 사용하지 말고 호출자에게 걱정하지 말아야합니다. 이것은 몇 가지 장점이 있습니다. 첫째, 시간 초과 처리 방법을 결정하기 위해 발신자의 옵션을 열어 둡니다. 예를 들어 상대 시간 초과가 아닌 절대 기한을 사용하는 것이 더 쉬울 수 있습니다. 그들이 취소 기계를 호출하는 사람들이라면, 그들은 선택하게되며, 당신은 그것에 대해 걱정할 필요가 없습니다. 둘째, 더 중요한 것은 다른 사람들이 코드를 쉽게 재사용 할 수있게 해줍니다. &lt;code&gt;http_get&lt;/code&gt; 함수 를 작성한 다음 나중에 와서 내부적으로 여러 개를 만들어야 하는 &lt;code&gt;log_in_to_twitter&lt;/code&gt; 함수를 작성하면 &lt;code&gt;http_get&lt;/code&gt; 을 각 호출에 대해 개별 시간 초과를 구성하는 방법을 알아 내고 싶지 않습니다. Trio의 시간 초과 시스템을 사용하는 것은 완전히 불필요합니다.</target>
        </trans-unit>
        <trans-unit id="601515a8d1630148f164b880c80a648ba993177c" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a simple example of how to use memory channels:</source>
          <target state="translated">메모리 채널을 사용하는 방법에 대한 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f8dd0477dbd6951adf860111366384234489b4a" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a toy example demonstrating how to use &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt;&lt;code&gt;contextvars&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">다음은 &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt; &lt;code&gt;contextvars&lt;/code&gt; &lt;/a&gt; 사용 방법을 보여주는 장난감 예제입니다 .</target>
        </trans-unit>
        <trans-unit id="0f597430db412dbd7530fb06efa92bf6cd1e97b4" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example lock class implemented using &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; directly. This implementation has a number of flaws, including lack of fairness, O(n) cancellation, missing error checking, failure to insert a checkpoint on the non-blocking path, etc. If you really want to implement your own lock, then you should study the implementation of &lt;a href=&quot;reference-core#trio.Lock&quot;&gt;&lt;code&gt;trio.Lock&lt;/code&gt;&lt;/a&gt; and use &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt;&lt;code&gt;ParkingLot&lt;/code&gt;&lt;/a&gt;, which handles some of these issues for you. But this does serve to illustrate the basic structure of the &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; API:</source>
          <target state="translated">다음은 &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 직접 사용하여 구현 된 잠금 클래스의 예 입니다. 이 구현에는 공정성 부족, O (n) 취소, 오류 검사 누락, 비 차단 경로에 체크 포인트 삽입 실패 등 여러 가지 결함이 있습니다. 실제로 자신의 잠금을 구현하려면 다음을 수행해야합니다. 의 구현 연구 &lt;a href=&quot;reference-core#trio.Lock&quot;&gt; &lt;code&gt;trio.Lock&lt;/code&gt; &lt;/a&gt; 사용 &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt; &lt;code&gt;ParkingLot&lt;/code&gt; &lt;/a&gt; 당신을 위해 이러한 문제의 일부를 처리합니다. 그러나 이것은 &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; API 의 기본 구조를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="521e2a543b76aa86240004a912c97fa33d2051e1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example lock class implemented using &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; directly. This implementation has a number of flaws, including lack of fairness, O(n) cancellation, missing error checking, failure to insert a checkpoint on the non-blocking path, etc. If you really want to implement your own lock, then you should study the implementation of &lt;a href=&quot;reference-core#trio.Lock&quot;&gt;&lt;code&gt;trio.Lock&lt;/code&gt;&lt;/a&gt; and use &lt;a href=&quot;#trio.lowlevel.ParkingLot&quot;&gt;&lt;code&gt;ParkingLot&lt;/code&gt;&lt;/a&gt;, which handles some of these issues for you. But this does serve to illustrate the basic structure of the &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; API:</source>
          <target state="translated">다음은 &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 직접 사용하여 구현 된 잠금 클래스의 예 입니다. 이 구현에는 공정성 부족, O (n) 취소, 오류 검사 누락, 비 차단 경로에 체크 포인트 삽입 실패 등 여러 가지 결함이 있습니다. 정말로 자신의 잠금을 구현하려면 다음을 수행해야합니다. 의 구현 연구 &lt;a href=&quot;reference-core#trio.Lock&quot;&gt; &lt;code&gt;trio.Lock&lt;/code&gt; &lt;/a&gt; 사용 &lt;a href=&quot;#trio.lowlevel.ParkingLot&quot;&gt; &lt;code&gt;ParkingLot&lt;/code&gt; &lt;/a&gt; 당신을 위해 이러한 문제의 일부를 처리합니다. 그러나 이것은 &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; API 의 기본 구조를 설명하는 역할을 합니다.</target>
        </trans-unit>
        <trans-unit id="c83ac7bfeff92f8dfada15c124f96bd3c69d8174" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of one way to test that Trio&amp;rsquo;s locks are fair: we take the lock in the parent, start a child, wait for the child to be blocked waiting for the lock (!), and then check that we can&amp;rsquo;t release and immediately re-acquire the lock:</source>
          <target state="translated">다음은 Trio의 잠금이 공정한지 테스트하는 한 가지 방법의 예입니다. 부모의 잠금을 잡고, 자식을 시작하고, 자식이 잠금을 기다리는 동안 차단 될 때까지 기다렸다가 (!) 풀어 놓을 수 없는지 확인하십시오 즉시 잠금 장치를 다시 확보하십시오.</target>
        </trans-unit>
        <trans-unit id="79a379c34c53ce83d07e71356345ea69136a74d1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ff52c45c58bc9a71da09f4ff9026c21c15addc99" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how we&amp;rsquo;d extend our asyncio example to implement this pattern:</source>
          <target state="translated">이 패턴을 구현하기 위해 asyncio 예제를 확장하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2c595ce4e33c82227dd77fbbfecca01edd89f970" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the idea: whenever you call a cancellable function like &lt;code&gt;await
trio.sleep(...)&lt;/code&gt; or &lt;code&gt;await sock.recv(...)&lt;/code&gt; &amp;ndash; see &lt;a href=&quot;#checkpoints&quot;&gt;Checkpoints&lt;/a&gt; &amp;ndash; then the first thing that function does is to check if there&amp;rsquo;s a surrounding cancel scope whose timeout has expired, or otherwise been cancelled. If so, then instead of performing the requested operation, the function fails immediately with a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception. In this example, this probably happens somewhere deep inside the bowels of &lt;code&gt;do_http_get&lt;/code&gt;. The exception then propagates out like any normal exception (you could even catch it if you wanted, but that&amp;rsquo;s generally a bad idea), until it reaches the &lt;code&gt;with move_on_after(...):&lt;/code&gt;. And at this point, the &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception has done its job &amp;ndash; it&amp;rsquo;s successfully unwound the whole cancelled scope &amp;ndash; so &lt;a href=&quot;#trio.move_on_after&quot;&gt;&lt;code&gt;move_on_after()&lt;/code&gt;&lt;/a&gt; catches it, and execution continues as normal after the &lt;code&gt;with&lt;/code&gt; block. And this all works correctly even if you have nested cancel scopes, because every &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; object carries an invisible marker that makes sure that the cancel scope that triggered it is the only one that will catch it.</source>
          <target state="translated">아이디어는 다음과 같습니다. &lt;code&gt;await trio.sleep(...)&lt;/code&gt; 또는 &lt;code&gt;await sock.recv(...)&lt;/code&gt; 와 같은 취소 가능한 함수를 호출 할 때마다 &lt;a href=&quot;#checkpoints&quot;&gt;검사 점&lt;/a&gt; 참조 &amp;ndash; 함수가 수행하는 첫 번째 작업은 주변 취소 범위가 있는지 확인하는 것입니다. 제한 시간이 만료되었거나 취소 된 경우 그렇다면 요청 된 작업을 수행하는 대신 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외 와 함께 함수가 즉시 실패합니다 . 이 예에서, 이것은 아마도 &lt;code&gt;do_http_get&lt;/code&gt; 창자 안쪽 어딘가에서 발생합니다 . 그런 다음 예외는 일반적인 예외와 같이 전파됩니다 (원하는 경우 잡을 수도 있지만 일반적으로 나쁜 생각입니다). &lt;code&gt;with move_on_after(...):&lt;/code&gt; . 그리고이 시점에서&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외가 작업을 완료했습니다. 전체 취소 된 범위를 성공적으로&lt;a href=&quot;#trio.move_on_after&quot;&gt; &lt;code&gt;move_on_after()&lt;/code&gt; &lt;/a&gt; 따라서 move_on_after ()가이를 감지 하고 &lt;code&gt;with&lt;/code&gt; 블록이후에도 정상적으로 실행이 계속됩니다. 취소 된 범위가 중첩 된 경우에도이 모든 것이 올바르게 작동합니다. 모든&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 객체에는 보이지 않는 마커가있어이를 트리거 한 취소 범위가이를 포착 할 수있는 유일한 범위이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2aeb6b45dd0d2ee97bc472ed237a9f484260072d" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the rule: if it&amp;rsquo;s in the &lt;code&gt;trio&lt;/code&gt; namespace, and you use &lt;code&gt;await&lt;/code&gt; to call it, then it&amp;rsquo;s cancellable (see &lt;a href=&quot;#checkpoints&quot;&gt;Checkpoints&lt;/a&gt; above). Cancellable means:</source>
          <target state="translated">규칙은 다음과 같습니다. &lt;code&gt;trio&lt;/code&gt; 네임 스페이스에 있고 &lt;code&gt;await&lt;/code&gt; 를 사용 하여 호출하면 취소 할 수 있습니다 ( 위의 &lt;a href=&quot;#checkpoints&quot;&gt;체크 포인트&lt;/a&gt; 참조). 취소 가능한 수단 :</target>
        </trans-unit>
        <trans-unit id="777ee510025095ed8e8d6f657cb98b0a5e34e261" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s what&amp;rsquo;s happening: suppose that producer A finishes first. It exits, and its &lt;code&gt;async with&lt;/code&gt; block closes the &lt;code&gt;send_channel&lt;/code&gt;. But wait! Producer B was still using that &lt;code&gt;send_channel&lt;/code&gt;&amp;hellip; so the next time B calls &lt;code&gt;send&lt;/code&gt;, it gets a &lt;a href=&quot;#trio.ClosedResourceError&quot;&gt;&lt;code&gt;ClosedResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">진행 상황은 다음과 같습니다. 생산자 A가 먼저 완료한다고 가정합니다. 종료 &lt;code&gt;async with&lt;/code&gt; 블록 과의 비동기 는 &lt;code&gt;send_channel&lt;/code&gt; 을 닫습니다 . 하지만 기다려! 생산자 B 아직도 사용하고 있었다 &lt;code&gt;send_channel&lt;/code&gt; 을 B 호출이 다음 번 ... 그래서 &lt;code&gt;send&lt;/code&gt; , 그것은 도착 &lt;a href=&quot;#trio.ClosedResourceError&quot;&gt; &lt;code&gt;ClosedResourceError&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="21160ad4219648df73489cb933286e7bc3e46257" translate="yes" xml:space="preserve">
          <source>High-level design principles</source>
          <target state="translated">높은 수준의 설계 원칙</target>
        </trans-unit>
        <trans-unit id="69ab5602e01ae3ddb7b5d822e4e060677004c139" translate="yes" xml:space="preserve">
          <source>How does this work? There&amp;rsquo;s no magic here: Trio is built using ordinary Python functionality, so we can&amp;rsquo;t just abandon the code inside the &lt;code&gt;with&lt;/code&gt; block. Instead, we take advantage of Python&amp;rsquo;s standard way of aborting a large and complex piece of code: we raise an exception.</source>
          <target state="translated">어떻게 작동합니까? 여기에는 마술이 없습니다. Trio는 일반적인 Python 기능을 사용하여 빌드되므로 &lt;code&gt;with&lt;/code&gt; 블록 내부의 코드를 버릴 수 없습니다 . 대신, 크고 복잡한 코드를 중단시키는 Python의 표준 방법을 활용합니다. 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="5e1b1c64688e250f0fe5f3bee97484ef0ed62473" translate="yes" xml:space="preserve">
          <source>How many seconds of clock time pass per second of real time. Default is 0.0, i.e. the clock only advances through manuals calls to &lt;a href=&quot;#trio.testing.MockClock.jump&quot;&gt;&lt;code&gt;jump()&lt;/code&gt;&lt;/a&gt; or when the &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt;&lt;code&gt;autojump_threshold&lt;/code&gt;&lt;/a&gt; is triggered. You can assign to this attribute to change it.</source>
          <target state="translated">초당 실시간 클럭 시간 (초)입니다. 기본값은 0.0입니다. 즉, 시계는 &lt;a href=&quot;#trio.testing.MockClock.jump&quot;&gt; &lt;code&gt;jump()&lt;/code&gt; &lt;/a&gt; 대한 &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt; &lt;code&gt;autojump_threshold&lt;/code&gt; &lt;/a&gt; 호출을 통해서만 또는 autojump_threshold 가 트리거 될 때만 진행됩니다 . 이 속성에 할당하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33d8a0f4d3b4758420f6c0a759a3cf2ef4fe9541" translate="yes" xml:space="preserve">
          <source>However, closing one of the objects does not close the other, and receivers don&amp;rsquo;t get &lt;a href=&quot;#trio.EndOfChannel&quot;&gt;&lt;code&gt;EndOfChannel&lt;/code&gt;&lt;/a&gt; until &lt;em&gt;all&lt;/em&gt; clones have been closed.</source>
          <target state="translated">그러나 개체 중 하나를 닫아도 다른 개체는 닫히지 않으며 수신기는 &lt;em&gt;모든&lt;/em&gt; 복제본이 &lt;a href=&quot;#trio.EndOfChannel&quot;&gt; &lt;code&gt;EndOfChannel&lt;/code&gt; &lt;/a&gt; 때까지 EndOfChannel을 얻지 못합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0f56ebfbbd55d6021396bb3e5231e9f349c9e50c" translate="yes" xml:space="preserve">
          <source>However, closing one of the objects does not close the other, and the underlying channel is not closed until all clones are closed. (If you&amp;rsquo;re familiar with &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.dup&quot;&gt;&lt;code&gt;os.dup&lt;/code&gt;&lt;/a&gt;, then this is a similar idea.)</source>
          <target state="translated">그러나 개체 중 하나를 닫아도 다른 개체는 닫히지 않으며 모든 클론이 닫힐 때까지 기본 채널이 닫히지 않습니다. &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.dup&quot;&gt; &lt;code&gt;os.dup&lt;/code&gt; 에&lt;/a&gt; 익숙하다면 비슷한 아이디어입니다.</target>
        </trans-unit>
        <trans-unit id="b8a37d3b1ef08026c956e9210fe57a016a1abeb9" translate="yes" xml:space="preserve">
          <source>However, on most runs, that&amp;rsquo;s not what happens &amp;ndash; the first part of the output is OK, and then when we get to the end the program crashes with &lt;a href=&quot;#trio.ClosedResourceError&quot;&gt;&lt;code&gt;ClosedResourceError&lt;/code&gt;&lt;/a&gt;. If you run the program a few times, you&amp;rsquo;ll see that sometimes the traceback shows &lt;code&gt;send&lt;/code&gt; crashing, and other times it shows &lt;code&gt;receive&lt;/code&gt; crashing, and you might even find that on some runs it doesn&amp;rsquo;t crash at all.</source>
          <target state="translated">그러나 대부분의 실행에서 이는 발생하지 않습니다. 출력의 첫 번째 부분은 정상입니다. 그런 다음 마지막에 도달하면 프로그램은 &lt;a href=&quot;#trio.ClosedResourceError&quot;&gt; &lt;code&gt;ClosedResourceError&lt;/code&gt; &lt;/a&gt; 와 충돌 합니다. 프로그램을 몇 번 실행하면 때때로 트레이스 백 쇼 &lt;code&gt;send&lt;/code&gt; 충돌을 일으키고 다른 시간에 쇼 &lt;code&gt;receive&lt;/code&gt; 충돌하는 것을 볼 수 있으며 일부 실행에서는 전혀 충돌하지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2312758fa0e741bf556c7094e1d6c332983a60b2" translate="yes" xml:space="preserve">
          <source>However, this part of the standard is widely ignored by real-world HTTPS implementations, which means that if you want to interoperate with them, then you NEED to ignore it too.</source>
          <target state="translated">그러나 표준의이 부분은 실제 HTTPS 구현에 의해 널리 무시됩니다. 즉, 상호 운용하려는 경우이를 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="19b03b1b6c37147d5d29f006e500a4ed4c113fb9" translate="yes" xml:space="preserve">
          <source>I get:</source>
          <target state="translated">나는 얻다:</target>
        </trans-unit>
        <trans-unit id="42b70820829e53baf48333e3880927dee7edb161" translate="yes" xml:space="preserve">
          <source>I/O in Trio</source>
          <target state="translated">트리오의 I / O</target>
        </trans-unit>
        <trans-unit id="47c6b8c8f8e1a0dd24d9a8ac6524551b9a4890aa" translate="yes" xml:space="preserve">
          <source>IMPORTANT: This method may block in order to perform a &amp;ldquo;graceful&amp;rdquo; shutdown. But, if this fails, then it still &lt;em&gt;must&lt;/em&gt; close any underlying resources before returning. An error from this method indicates a failure to achieve grace, &lt;em&gt;not&lt;/em&gt; a failure to close the connection.</source>
          <target state="translated">중요 :이 방법은 &quot;정상적인&quot;종료를 수행하기 위해 차단 될 수 있습니다. 그러나,이 실패 할 경우, 그것은 여전히 &lt;em&gt;있어야합니다&lt;/em&gt; 반환하기 전에 기본 자원을 닫습니다. 이 방법의 오류 는 연결을 닫는 데 실패 &lt;em&gt;하지 않고&lt;/em&gt; 유예를 얻지 못했음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="cd23546b23d205dff24ff00f8cab6f8c33e0ff13" translate="yes" xml:space="preserve">
          <source>IOT</source>
          <target state="translated">IOT</target>
        </trans-unit>
        <trans-unit id="cc7e8128711e1da0df8da9d9302d7633663a2956" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process&lt;/code&gt;&lt;/a&gt; is cancelled, then it needs to kill the child process. There are multiple ways to do this, so we let you customize it.</source>
          <target state="translated">경우 &lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process&lt;/code&gt; 가&lt;/a&gt; 취소되고, 그것은 자식 프로세스를 종료 할 필요가있다. 이를 수행하는 방법은 여러 가지가 있으므로 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="659eab4e70caa38a30f16d960317cd3d960b3e36" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cancellable=False&lt;/code&gt;, the function ignores the cancellation and keeps going, just like if we had called &lt;code&gt;sync_fn&lt;/code&gt; synchronously. This is the default behavior.</source>
          <target state="translated">경우 &lt;code&gt;cancellable=False&lt;/code&gt; 함수는 우리가 호출 한 경우처럼, 취소를 무시하고가는 계속 &lt;code&gt;sync_fn&lt;/code&gt; 기적. 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="1965c60e86c5c7cf8307b3f7f4c630c274d05a7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cancellable=True&lt;/code&gt;, then this function immediately raises &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;. In this case &lt;strong&gt;the thread keeps running in background&lt;/strong&gt; &amp;ndash; we just abandon it to do whatever it&amp;rsquo;s going to do, and silently discard any return value or errors that it raises. Only use this if you know that the operation is safe and side-effect free. (For example: &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;trio.socket.getaddrinfo()&lt;/code&gt;&lt;/a&gt; is uses a thread with &lt;code&gt;cancellable=True&lt;/code&gt;, because it doesn&amp;rsquo;t really affect anything if a stray hostname lookup keeps running in the background.)</source>
          <target state="translated">경우 &lt;code&gt;cancellable=True&lt;/code&gt; ,이 함수는 즉시 던질 수 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; . 이 경우 &lt;strong&gt;스레드는 백그라운드에서 계속 실행&lt;/strong&gt; 됩니다. 수행하려는 작업을 수행하기 위해 &lt;strong&gt;스레드를&lt;/strong&gt; 포기하고 발생한 반환 값 또는 오류를 자동으로 버립니다. 작업이 안전하고 부작용이 없음을 알고있는 경우에만 사용하십시오. (예를 들어, &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;trio.socket.getaddrinfo()&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;cancellable=True&lt;/code&gt; 인 스레드를 사용 합니다.이 호스트는 길 잃은 호스트 이름 조회가 백그라운드에서 계속 실행되는 경우 실제로 영향을 미치지 않기 때문입니다.)</target>
        </trans-unit>
        <trans-unit id="5acac8dd7aed206df92f3700bb13f437430a5bfc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cancellable=True&lt;/code&gt;, then this function immediately raises &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;. In this case &lt;strong&gt;the thread keeps running in background&lt;/strong&gt; &amp;ndash; we just abandon it to do whatever it&amp;rsquo;s going to do, and silently discard any return value or errors that it raises. Only use this if you know that the operation is safe and side-effect free. (For example: &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;trio.socket.getaddrinfo()&lt;/code&gt;&lt;/a&gt; uses a thread with &lt;code&gt;cancellable=True&lt;/code&gt;, because it doesn&amp;rsquo;t really affect anything if a stray hostname lookup keeps running in the background.)</source>
          <target state="translated">경우 &lt;code&gt;cancellable=True&lt;/code&gt; ,이 함수는 즉시 던질 수 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; . 이 경우 &lt;strong&gt;스레드는 백그라운드에서 계속 실행&lt;/strong&gt; 됩니다. 수행 할 작업을 수행하기 위해 &lt;strong&gt;스레드를&lt;/strong&gt; 버리고 발생하는 반환 값이나 오류를 조용히 버립니다. 수술이 안전하고 부작용이 없다는 것을 알고있는 경우에만 이것을 사용하십시오. (예 : &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;trio.socket.getaddrinfo()&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;cancellable=True&lt;/code&gt; 를 사용하는 스레드를 사용합니다 . 왜냐하면 스트레이 호스트 이름 조회가 백그라운드에서 계속 실행되는 경우 실제로 아무 영향도 미치지 않기 때문입니다.)</target>
        </trans-unit>
        <trans-unit id="aba6364461f29e62fe17876f0b5c22b5417e80da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;handler&lt;/code&gt; neglects to close the &lt;code&gt;stream&lt;/code&gt;, then it will be closed using &lt;a href=&quot;#trio.aclose_forcefully&quot;&gt;&lt;code&gt;trio.aclose_forcefully()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;handler&lt;/code&gt; 무시가 종료 &lt;code&gt;stream&lt;/code&gt; , 그 때 사용 닫힐 것이다 &lt;a href=&quot;#trio.aclose_forcefully&quot;&gt; &lt;code&gt;trio.aclose_forcefully()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1277a00b059c5d2c5ef7f7646d1c9134594a5431" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;handler&lt;/code&gt; raises an exception, then this function doesn&amp;rsquo;t do anything special to catch it &amp;ndash; so by default the exception will propagate out and crash your server. If you don&amp;rsquo;t want this, then catch exceptions inside your &lt;code&gt;handler&lt;/code&gt;, or use a &lt;code&gt;handler_nursery&lt;/code&gt; object that responds to exceptions in some other way.</source>
          <target state="translated">경우 &lt;code&gt;handler&lt;/code&gt; 예외가 발생,이 함수는 그것을 잡을 아무것도 특별하지 않습니다 - 그래서 기본적으로 예외는 밖으로 전파하고 서버를 충돌합니다. 이것을 원하지 않으면 &lt;code&gt;handler&lt;/code&gt; 내부에서 예외를 포착 하거나 다른 방식으로 예외에 응답 하는 &lt;code&gt;handler_nursery&lt;/code&gt; 객체를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="16a7aaf08e8695ea95415710c3e4758bb8256152" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;host&lt;/code&gt; is given as a numeric IP address, then &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt;&lt;/a&gt; may handle the request itself rather than calling this method.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; 에 숫자 IP 주소가 제공 되면 &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo()&lt;/code&gt; &lt;/a&gt; 는이 메소드를 호출하지 않고 요청 자체를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="a97d3af5b4523fc19e8fe52ab6041ae3db11563e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;https_compatible&lt;/code&gt; is False (the default), then this attempts to first send a &lt;code&gt;close_notify&lt;/code&gt; and then close the underlying stream by calling its &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">경우 &lt;code&gt;https_compatible&lt;/code&gt; 가 false (기본값), 먼저이 시도는 전송 &lt;code&gt;close_notify&lt;/code&gt; 의 호출하여 다음 가까운 기본이되는 스트림을 &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 메소드를.</target>
        </trans-unit>
        <trans-unit id="25ae479bd9da72823057df9f18d1514f989532e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;https_compatible&lt;/code&gt; is set to True, then this simply closes the underlying stream and marks this stream as closed.</source>
          <target state="translated">경우 &lt;code&gt;https_compatible&lt;/code&gt; 가 True로 설정되어 있으면이 단순히 기본 스트림과 마크 폐쇄로이 스트림을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="0f881d1427bb56edf169a6edeb8c1efed87b6b6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;idempotent=True&lt;/code&gt;, then &lt;code&gt;sync_fn&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt; must be hashable, and Trio will make a best-effort attempt to discard any call submission which is equal to an already-pending call. Trio will make an attempt to process these in first-in first-out order, but no guarantees. (Currently processing is FIFO on CPython 3.6 and PyPy, but not CPython 3.5.)</source>
          <target state="translated">경우 &lt;code&gt;idempotent=True&lt;/code&gt; , 다음 &lt;code&gt;sync_fn&lt;/code&gt; 및 &lt;code&gt;args&lt;/code&gt; 해쉬해야하며, 트리오는 이미 출원중인 통화와 동일한 모든 통화 제출을 폐기하는 것이 가장 노력을 시도합니다. Trio는 선입 선출 방식으로 처리하려고 시도하지만 보장 할 수는 없습니다. (현재 처리는 CPython 3.6 및 PyPy에서 FIFO이지만 CPython 3.5에서는 아닙니다.)</target>
        </trans-unit>
        <trans-unit id="da4e41ac568650b6c32c0b3e152ec00eeefa8161" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;idempotent=True&lt;/code&gt;, then &lt;code&gt;sync_fn&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt; must be hashable, and Trio will make a best-effort attempt to discard any call submission which is equal to an already-pending call. Trio will process these in first-in first-out order.</source>
          <target state="translated">경우 &lt;code&gt;idempotent=True&lt;/code&gt; , 다음 &lt;code&gt;sync_fn&lt;/code&gt; 및 &lt;code&gt;args&lt;/code&gt; 해쉬해야하며, 트리오는 이미 출원중인 통화와 동일한 모든 통화 제출을 폐기하는 것이 가장 노력을 시도합니다. Trio는이를 선입 선출 순서로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="6640f3a40179fca8c977825590b8d93ee250b08e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;instrument&lt;/code&gt; is already active, does nothing.</source>
          <target state="translated">&lt;code&gt;instrument&lt;/code&gt; 가 이미 활성화 된 경우 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef01b2d7eadb45a6611959bf01ff860e59edfd28" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(exceptions) == 1&lt;/code&gt;, returns that exception. This means that a call to &lt;code&gt;MultiError(...)&lt;/code&gt; is not guaranteed to return a &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt; object!</source>
          <target state="translated">만약 &lt;code&gt;len(exceptions) == 1&lt;/code&gt; , 반환은 그 예외입니다. 이것은 &lt;code&gt;MultiError(...)&lt;/code&gt; 호출 이 &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; 객체 를 반환한다고 보장하지 않습니다 !</target>
        </trans-unit>
        <trans-unit id="5484f23b9c8687e23e7ba9482accdacff5d91e96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.send_stream.send_eof&lt;/code&gt; exists, then calls it. Otherwise, calls &lt;code&gt;self.send_stream.aclose()&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;self.send_stream.send_eof&lt;/code&gt; 이 존재, 다음을 호출합니다. 그렇지 않으면 &lt;code&gt;self.send_stream.aclose()&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e565b179b461394dd0ee23418e2601771bf98c83" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sync_fn&lt;/code&gt; raises an exception, then it&amp;rsquo;s converted into a &lt;a href=&quot;reference-core#trio.TrioInternalError&quot;&gt;&lt;code&gt;TrioInternalError&lt;/code&gt;&lt;/a&gt; and &lt;em&gt;all&lt;/em&gt; tasks are cancelled. You should be careful that &lt;code&gt;sync_fn&lt;/code&gt; doesn&amp;rsquo;t crash.</source>
          <target state="translated">경우 &lt;code&gt;sync_fn&lt;/code&gt; 는 예외를 발생, 다음은로 변환됩니다 &lt;a href=&quot;reference-core#trio.TrioInternalError&quot;&gt; &lt;code&gt;TrioInternalError&lt;/code&gt; &lt;/a&gt; 및 &lt;em&gt;모든&lt;/em&gt; 작업이 취소됩니다. &lt;code&gt;sync_fn&lt;/code&gt; 이 충돌하지 않도록주의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="990c927a59e2e05acc2c85e7b9eca515a354fef6" translate="yes" xml:space="preserve">
          <source>If None (the default), uses the default &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt;, as returned by &lt;a href=&quot;#trio.to_thread.current_default_thread_limiter&quot;&gt;&lt;code&gt;current_default_thread_limiter()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">None (기본값) 인 경우 &lt;a href=&quot;#trio.to_thread.current_default_thread_limiter&quot;&gt; &lt;code&gt;current_default_thread_limiter()&lt;/code&gt; &lt;/a&gt; 반환 한 기본 &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; 를&lt;/a&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="9d05809aaddc05f620de4ba89c04d5864f1d6c4f" translate="yes" xml:space="preserve">
          <source>If a cancel scope becomes cancelled before entering its &lt;code&gt;with&lt;/code&gt; block, the &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception will be raised at the first checkpoint inside the &lt;code&gt;with&lt;/code&gt; block. This allows a &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; to be created in one &lt;a href=&quot;#tasks&quot;&gt;task&lt;/a&gt; and passed to another, so that the first task can later cancel some work inside the second.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 블록으로 들어가기 전에 취소 범위가 취소되면 취소 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외는 &lt;code&gt;with&lt;/code&gt; 블록 . 이를 통해 한 &lt;a href=&quot;#tasks&quot;&gt;작업&lt;/a&gt; 에서 &lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; &lt;/a&gt; 를 만들고 다른 작업 으로 전달할 수 있으므로 첫 번째 작업은 나중에 두 번째 작업의 일부 작업을 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7850e477ce23ba21e548c212b6826f9c2a312f8" translate="yes" xml:space="preserve">
          <source>If a function doesn&amp;rsquo;t specify otherwise, then it inherits the protection state of its caller.</source>
          <target state="translated">함수가 달리 지정하지 않으면 호출자의 보호 상태를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="b027817cbeed64537f5db91f3d08fdc471481eee" translate="yes" xml:space="preserve">
          <source>If a system task raises an exception, then it&amp;rsquo;s converted into a &lt;a href=&quot;reference-core#trio.TrioInternalError&quot;&gt;&lt;code&gt;TrioInternalError&lt;/code&gt;&lt;/a&gt; and &lt;em&gt;all&lt;/em&gt; tasks are cancelled. If you write a system task, you should be careful to make sure it doesn&amp;rsquo;t crash.</source>
          <target state="translated">시스템 작업에서 예외가 발생하면 시스템 작업이 &lt;a href=&quot;reference-core#trio.TrioInternalError&quot;&gt; &lt;code&gt;TrioInternalError&lt;/code&gt; &lt;/a&gt; 및&lt;em&gt; 모든&lt;/em&gt; 작업이 취소됩니다. 시스템 작업을 작성하는 경우 충돌하지 않도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="4571550f4a15d7bae0009643f675312fe0036d78" translate="yes" xml:space="preserve">
          <source>If an EOF has already been sent, then this method should silently succeed.</source>
          <target state="translated">EOF가 이미 전송 된 경우이 방법은 자동으로 성공합니다.</target>
        </trans-unit>
        <trans-unit id="f197dac98206248928f9e4b5c1d8a2fe4e3c0bd3" translate="yes" xml:space="preserve">
          <source>If an async generator is still alive at the end of the whole call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;, then it will be cleaned up after all tasks have exited and before &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; returns. Since the &amp;ldquo;system nursery&amp;rdquo; has already been closed at this point, Trio isn&amp;rsquo;t able to support any new calls to &lt;a href=&quot;reference-lowlevel#trio.lowlevel.spawn_system_task&quot;&gt;&lt;code&gt;trio.lowlevel.spawn_system_task()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 에 대한 전체 호출이 끝났을 때 비동기 생성기가 여전히 활성 상태이면 모든 작업이 종료 된 후 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 반환 되기 전에 정리 됩니다. 이 시점에서&amp;ldquo;system nursery&amp;rdquo;가 이미 종료되었으므로 Trio는 &lt;a href=&quot;reference-lowlevel#trio.lowlevel.spawn_system_task&quot;&gt; &lt;code&gt;trio.lowlevel.spawn_system_task()&lt;/code&gt; &lt;/a&gt; 대한 새로운 호출을 지원할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="45296ea408223fb4af1c47429fd38b83d611bdcc" translate="yes" xml:space="preserve">
          <source>If any task inside the nursery finishes with an unhandled exception, then the nursery immediately cancels all the tasks inside the nursery.</source>
          <target state="translated">보육원 내부의 작업이 처리되지 않은 예외로 완료되면 보육원은 보육원 내부의 모든 작업을 즉시 취소합니다.</target>
        </trans-unit>
        <trans-unit id="ad7600a810bc11f91c2adfea072e298afde04ee1" translate="yes" xml:space="preserve">
          <source>If called with an &lt;code&gt;nbytes&lt;/code&gt; that&amp;rsquo;s greater than zero, then it will call &lt;code&gt;sock.recv&lt;/code&gt; at least once, and &lt;code&gt;recv&lt;/code&gt; is an async Trio function, and thus an unconditional checkpoint. So in this case, &lt;code&gt;recv_exactly&lt;/code&gt; acts as a checkpoint. But if we do &lt;code&gt;await
recv_exactly(sock, 0)&lt;/code&gt;, then it will immediately return an empty buffer without executing a checkpoint. If this were a function in Trio itself, then this wouldn&amp;rsquo;t be acceptable, but you may decide you don&amp;rsquo;t want to worry about this kind of minor edge case in your own code.</source>
          <target state="translated">호출하면 &lt;code&gt;nbytes&lt;/code&gt; 0보다 큰입니다, 그것은 호출합니다 &lt;code&gt;sock.recv&lt;/code&gt; 한 번 이상, 그리고 &lt;code&gt;recv&lt;/code&gt; 비동기 트리오 기능, 따라서 무조건 체크 포인트이다. 따라서이 경우 &lt;code&gt;recv_exactly&lt;/code&gt; 는 체크 포인트 역할을합니다. 그러나 &lt;code&gt;await recv_exactly(sock, 0)&lt;/code&gt; 검사 점을 실행하지 않고 빈 버퍼를 즉시 반환합니다. 이것이 Trio 자체의 함수라면 허용되지 않지만 자신의 코드에서 이러한 종류의 사소한 경우에 대해 걱정하지 않기로 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02f5a27e4bd7755771be91835c2cda91fa8349fe" translate="yes" xml:space="preserve">
          <source>If cancelled, &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process()&lt;/code&gt;&lt;/a&gt; terminates the subprocess and waits for it to exit before propagating the cancellation, like &lt;a href=&quot;#trio.Process.aclose&quot;&gt;&lt;code&gt;Process.aclose()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">취소하면 &lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process()&lt;/code&gt; &lt;/a&gt; 는 하위 프로세스를 종료하고 취소를 전파하기 전에 하위 프로세스가 종료 될 때까지 기다립니다.&lt;a href=&quot;#trio.Process.aclose&quot;&gt; &lt;code&gt;Process.aclose()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="888cc7e58c3e7e821d20edf2b5cd73ba760154df" translate="yes" xml:space="preserve">
          <source>If cancelled, kills the process and waits for it to finish exiting before propagating the cancellation.</source>
          <target state="translated">취소하면 프로세스를 종료하고 취소를 전파하기 전에 프로세스가 종료 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="cf2c140a05a78875d1f5d24dc874e16f64335dfa" translate="yes" xml:space="preserve">
          <source>If implementing this interface, you should consider whether you can go one step further and implement &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;HalfCloseableStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 인터페이스를 구현하는 경우 한 단계 더 나아가 &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;HalfCloseableStream&lt;/code&gt; 을&lt;/a&gt; 구현할 수 있는지 고려해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0275957337e1463961ce555770ceadbe862e0b84" translate="yes" xml:space="preserve">
          <source>If it blocks, and while it&amp;rsquo;s blocked then one of the scopes around it becomes cancelled, it will return early and raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">차단되면 차단되는 동안 주변 범위 중 하나가 취소되고 일찍 반환되어 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="dd4041956ee7f9741134e0f1a0b8493a10950c30" translate="yes" xml:space="preserve">
          <source>If it&amp;rsquo;s already True, then this method returns immediately.</source>
          <target state="translated">이미 True 인 경우이 메소드는 즉시 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="56f1b3116eaca611475f7b84d97f7ac70972c4ee" translate="yes" xml:space="preserve">
          <source>If the child task passes a value to &lt;code&gt;task_status.started(value)&lt;/code&gt;, then &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; returns this value. Otherwise it returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">자식 작업에 값 통과하면 &lt;code&gt;task_status.started(value)&lt;/code&gt; , 다음 &lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 이 값을 반환합니다. 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 을 반환합니다. .</target>
        </trans-unit>
        <trans-unit id="b38cbfebe28da9d2a5aa20689881e5ca9ad29ed7" translate="yes" xml:space="preserve">
          <source>If the generator raises an exception during cleanup, then it&amp;rsquo;s printed to the &lt;code&gt;trio.async_generator_errors&lt;/code&gt; logger and otherwise ignored.</source>
          <target state="translated">생성기가 정리 중에 예외를 발생 시키면 &lt;code&gt;trio.async_generator_errors&lt;/code&gt; 로거에 인쇄 되고 그렇지 않으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="37629b81efe2e8c145a2a531927b3cf8393e1bc1" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;host&lt;/code&gt; has multiple IP addresses associated with it, then we have a problem: which one do we use?</source>
          <target state="translated">주어진 &lt;code&gt;host&lt;/code&gt; 에 여러 개의 IP 주소가 연결되어 있다면 문제가있는 것입니다 : 어느 것을 사용합니까?</target>
        </trans-unit>
        <trans-unit id="4375ef471535703a9908dadea8805978038773d1" translate="yes" xml:space="preserve">
          <source>If the initial handshake has already completed, this returns immediately without doing anything (except executing a checkpoint).</source>
          <target state="translated">초기 핸드 셰이크가 이미 완료된 경우 검사 점 실행을 제외하고 아무 작업도 수행하지 않고 즉시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="150a98efd2d67aeeb90753e4ff853b2109055a98" translate="yes" xml:space="preserve">
          <source>If the initial handshake is already in progress in another task, this waits for it to complete and then returns.</source>
          <target state="translated">다른 작업에서 초기 핸드 셰이크가 이미 진행 중이면 완료 될 때까지 기다렸다가 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="c19f10e7d00e86fc95aa255c1ac054018dc1a174" translate="yes" xml:space="preserve">
          <source>If the resource is already closed, then this method should silently succeed.</source>
          <target state="translated">리소스가 이미 닫힌 경우이 방법은 자동으로 성공합니다.</target>
        </trans-unit>
        <trans-unit id="9062a923df80e6fab65b8657d9f6a2b9026d5861" translate="yes" xml:space="preserve">
          <source>If there are fewer than &lt;code&gt;count&lt;/code&gt; tasks parked, then reparks as many tasks as are available and then returns successfully.</source>
          <target state="translated">파킹 된 작업 수보다 적은 &lt;code&gt;count&lt;/code&gt; 작업이있는 경우 사용 가능한 작업 수를 재 파킹 한 다음 성공적으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0b36fe75ca2344af777c2c9affab58827ecd89ae" translate="yes" xml:space="preserve">
          <source>If there are multiple tasks blocked in &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt;&lt;/a&gt;, then the one with the shortest &lt;code&gt;cushion&lt;/code&gt; is the one woken (and this task becoming unblocked resets the timers for the remaining tasks). If there are multiple tasks that have exactly the same &lt;code&gt;cushion&lt;/code&gt;, then all are woken.</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt; &lt;/a&gt; 차단 된 작업이 여러 개있는 경우 &lt;code&gt;cushion&lt;/code&gt; 이 가장 짧은 작업이 깨어 난 작업이됩니다 (이 작업이 차단 해제되면 나머지 작업에 대한 타이머가 재설정 됨). &lt;code&gt;cushion&lt;/code&gt; 이 똑같은 작업이 여러 개 있으면 모두 깨어납니다.</target>
        </trans-unit>
        <trans-unit id="377149956a1262f83743260fb07d31b29a188c54" translate="yes" xml:space="preserve">
          <source>If there are multiple tasks blocked in &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt;&lt;/a&gt;, then the one with the shortest &lt;code&gt;cushion&lt;/code&gt; is the one woken (and this task becoming unblocked resets the timers for the remaining tasks). If there are multiple tasks that have exactly the same &lt;code&gt;cushion&lt;/code&gt;, then the one with the lowest &lt;code&gt;tiebreaker&lt;/code&gt; value is woken first. And if there are multiple tasks with the same &lt;code&gt;cushion&lt;/code&gt; and the same &lt;code&gt;tiebreaker&lt;/code&gt;, then all are woken.</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt; &lt;/a&gt; 에서 여러 작업이 차단 된 경우 가장 짧은 &lt;code&gt;cushion&lt;/code&gt; 이있는 작업이 깨어 난 작업입니다 (이 작업이 차단 해제되면 남은 작업에 대한 타이머가 재설정 됨). 정확히 동일한 &lt;code&gt;cushion&lt;/code&gt; 을 가진 여러 작업이있는 경우 순위 &lt;code&gt;tiebreaker&lt;/code&gt; 값이 가장 낮은 작업 이 먼저 깨어납니다. 그리고 동일한 &lt;code&gt;cushion&lt;/code&gt; 과 동일한 &lt;code&gt;tiebreaker&lt;/code&gt; 가진 여러 작업이있는 경우 모두 깨어납니다.</target>
        </trans-unit>
        <trans-unit id="755478d189f177af5d89c78e624e31c6791f6834" translate="yes" xml:space="preserve">
          <source>If this is called in a context where a cancellation is currently active (i.e., a blocking call will immediately raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;), then returned deadline is &lt;code&gt;-inf&lt;/code&gt;. If it is called in a context where no scopes have a deadline set, it returns &lt;code&gt;inf&lt;/code&gt;.</source>
          <target state="translated">취소가 현재 활성화 된 컨텍스트에서 호출되면 (즉, 블로킹 호출은 즉시 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 를 발생 &lt;code&gt;-inf&lt;/code&gt; 반환 된 최종 기한은 -inf 입니다. 범위에 마감 기한이 설정되지 않은 컨텍스트에서 호출되면 &lt;code&gt;inf&lt;/code&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="d92a60f2ce7686f3c19dfb6575e2c818916fdf31" translate="yes" xml:space="preserve">
          <source>If this method is cancelled while the initial handshake or a renegotiation are in progress, then it may leave the &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; in an unusable state. If this happens then any future attempt to use the object will raise &lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt;&lt;code&gt;trio.BrokenResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">초기 핸드 셰이크 또는 재협상이 진행되는 동안이 메소드가 취소되면 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 을 사용할 수없는 상태로 남겨 둘 수 있습니다. 이 경우 나중에 개체를 사용하려고하면 &lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt; &lt;code&gt;trio.BrokenResourceError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8b9129f4324a3c372997bd08724529da9bd32054" translate="yes" xml:space="preserve">
          <source>If this method is cancelled, then it may leave the &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; in an unusable state. If this happens then any attempt to use the object will raise &lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt;&lt;code&gt;trio.BrokenResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드가 취소되면 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 을 사용할 수없는 상태로 둘 수 있습니다. 이 경우 객체를 사용하려고하면 &lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt; &lt;code&gt;trio.BrokenResourceError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c31c3e3ccb4521109d40e0f73cc0c0ff055f6741" translate="yes" xml:space="preserve">
          <source>If this method is cancelled, then it may leave the &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; in an unusable state. If this happens then any future attempt to use the object will raise &lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt;&lt;code&gt;trio.BrokenResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법을 취소하면 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 을 사용할 수없는 상태로수 있습니다. 이 경우 나중에 개체를 사용하려고하면&lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt; &lt;code&gt;trio.BrokenResourceError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="620d8617d908554f99b026fef5e4bce4f30f46da" translate="yes" xml:space="preserve">
          <source>If this stream has been closed, an empty bytearray. Otherwise, the requested data.</source>
          <target state="translated">이 스트림이 닫히면 빈 바이트 배열입니다. 그렇지 않으면 요청 된 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="4edc92d340acba4cf9852a1e81a40f85617d0e52" translate="yes" xml:space="preserve">
          <source>If this task has already called &lt;code&gt;started()&lt;/code&gt;, or if it was not spawned using &lt;a href=&quot;reference-core#trio.Nursery.start&quot;&gt;&lt;code&gt;nursery.start()&lt;/code&gt;&lt;/a&gt;, then its &lt;a href=&quot;#trio.lowlevel.Task.eventual_parent_nursery&quot;&gt;&lt;code&gt;eventual_parent_nursery&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이 작업은 이미 불리는 경우 &lt;code&gt;started()&lt;/code&gt; 이 사용 양산되지 않은 경우, 또는 &lt;a href=&quot;reference-core#trio.Nursery.start&quot;&gt; &lt;code&gt;nursery.start()&lt;/code&gt; &lt;/a&gt; , 다음의 &lt;a href=&quot;#trio.lowlevel.Task.eventual_parent_nursery&quot;&gt; &lt;code&gt;eventual_parent_nursery&lt;/code&gt; 는&lt;/a&gt; 없다 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01544d5318e6f8b44b1d61a7fe422bbe176746e1" translate="yes" xml:space="preserve">
          <source>If we didn&amp;rsquo;t re-acquire the lock before waking up, and &lt;a href=&quot;#trio.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; were cancelled here, then we&amp;rsquo;d crash in &lt;code&gt;condition.__aexit__&lt;/code&gt; when we tried to release the lock we no longer held.</source>
          <target state="translated">깨어나 기 전에 자물쇠를 다시 얻지 못한 경우 &lt;a href=&quot;#trio.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt;여기에서 wait () 가 취소되면 잠금 상태를 해제하려고 할 때 &lt;code&gt;condition.__aexit__&lt;/code&gt; 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="af6afcd13a200dd13720b79d100295cf3abd0840" translate="yes" xml:space="preserve">
          <source>If you abandon a partially-completed async generator, though, such as by &lt;code&gt;break&lt;/code&gt;ing out of the iteration, things aren&amp;rsquo;t so simple. The async generator iterator object is still alive, waiting for you to resume iterating it so it can produce more values. At some point, Python will realize that you&amp;rsquo;ve dropped all references to the iterator, and will call on Trio to throw in a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#GeneratorExit&quot;&gt;&lt;code&gt;GeneratorExit&lt;/code&gt;&lt;/a&gt; exception so that any remaining cleanup code inside the generator has a chance to run: &lt;code&gt;finally&lt;/code&gt; blocks, &lt;code&gt;__aexit__&lt;/code&gt; handlers, and so on.</source>
          <target state="translated">하지만 반복 을 &lt;code&gt;break&lt;/code&gt; 하는 것과 같이 부분적으로 완료된 비동기 생성기 를 버리면 상황이 그렇게 간단하지 않습니다. 비동기 생성기 반복기 객체는 여전히 활성화되어 있으며 더 많은 값을 생성 할 수 있도록 반복을 재개 할 때까지 기다립니다. 어느 시점에서 Python은 반복기에 대한 모든 참조를 삭제했음을 인식하고 Trio를 호출하여 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#GeneratorExit&quot;&gt; &lt;code&gt;GeneratorExit&lt;/code&gt; &lt;/a&gt; 예외를 발생시켜 생성기 내부의 나머지 정리 코드를 실행할 기회를 갖습니다. &lt;code&gt;finally&lt;/code&gt; 블록, &lt;code&gt;__aexit__&lt;/code&gt; 핸들러, 등등.</target>
        </trans-unit>
        <trans-unit id="51cb5ff6a6129f7c44e9d5bee9734ac957b56318" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t seeing any warnings with your initial prototype, you&amp;rsquo;re &lt;em&gt;probably&lt;/em&gt; fine. But the only way to be certain is to check your host loop&amp;rsquo;s source. For example, asyncio may or may not use &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt;&lt;code&gt;signal.set_wakeup_fd&lt;/code&gt;&lt;/a&gt; depending on the Python version and operating system.</source>
          <target state="translated">당신은 당신의 초기 프로토 타입 경고가 표시되지 않는 경우가있어 &lt;em&gt;아마&lt;/em&gt; 잘. 그러나 확실한 방법은 호스트 루프의 소스를 확인하는 것입니다. 예를 들어, asyncio는 Python 버전 및 운영 체제에 따라 &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt; &lt;code&gt;signal.set_wakeup_fd&lt;/code&gt; 를&lt;/a&gt; 사용하거나 사용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="286548126cabde1417f66f615fe9ea5965912a79" translate="yes" xml:space="preserve">
          <source>If you call an async function provided by Trio (&lt;code&gt;await
&amp;lt;something in trio&amp;gt;&lt;/code&gt;), and it doesn&amp;rsquo;t raise an exception, then it &lt;em&gt;always&lt;/em&gt; acts as a checkpoint. (If it does raise an exception, it might act as a checkpoint or might not.)</source>
          <target state="translated">Trio에서 제공 한 비동기 함수를 호출하면 ( &lt;code&gt;await &amp;lt;something in trio&amp;gt;&lt;/code&gt; ) 예외를 발생시키지 않으면 &lt;em&gt;항상&lt;/em&gt; 검사 점 역할을합니다. (예외가 발생하면 검사 점으로 작동하거나 작동하지 않을 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="e8f78fe4175fd971e3aaf1cc8d1f5dba48434010" translate="yes" xml:space="preserve">
          <source>If you can, we recommend following this pattern:</source>
          <target state="translated">가능한 경우 다음 패턴을 따르는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fbdcd39191ff9bf10dd31ff815198d56d63dedd7" translate="yes" xml:space="preserve">
          <source>If you do want to be careful, or if you have some CPU-bound code that doesn&amp;rsquo;t have enough checkpoints in it, then it&amp;rsquo;s useful to know that &lt;code&gt;await trio.sleep(0)&lt;/code&gt; is an idiomatic way to execute a checkpoint without doing anything else, and that &lt;a href=&quot;reference-testing#trio.testing.assert_checkpoints&quot;&gt;&lt;code&gt;trio.testing.assert_checkpoints()&lt;/code&gt;&lt;/a&gt; can be used to test that an arbitrary block of code contains a checkpoint.</source>
          <target state="translated">주의를 기울이고 싶거나 충분한 체크 포인트가없는 CPU 바운드 코드가있는 경우이를 아는 것이 유용합니다 &lt;code&gt;await trio.sleep(0)&lt;/code&gt; 이 체크 포인트를 수행하지 않고 관용적 인 방법 다른 코드와 &lt;a href=&quot;reference-testing#trio.testing.assert_checkpoints&quot;&gt; &lt;code&gt;trio.testing.assert_checkpoints()&lt;/code&gt; &lt;/a&gt; 를 사용하면 임의의 코드 블록에 검사 점이 포함되어 있는지 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0ec74dfa8266f72ef9a2572e3c844429de77054" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t like that ambiguity, and you want to ensure that a generator&amp;rsquo;s &lt;code&gt;finally&lt;/code&gt; blocks and &lt;code&gt;__aexit__&lt;/code&gt; handlers execute as soon as you&amp;rsquo;re done using it, then you&amp;rsquo;ll need to wrap your use of the generator in something like &lt;a href=&quot;https://async-generator.readthedocs.io/en/latest/reference.html#context-managers&quot;&gt;async_generator.aclosing()&lt;/a&gt;:</source>
          <target state="translated">그 모호함이 마음에 들지 않고 생성기의 &lt;code&gt;finally&lt;/code&gt; 블록과 &lt;code&gt;__aexit__&lt;/code&gt; 처리기가 사용이 끝나 자마자 실행되도록하려면 &lt;a href=&quot;https://async-generator.readthedocs.io/en/latest/reference.html#context-managers&quot;&gt;async_generator&lt;/a&gt; 와 같은 것으로 생성기 사용을 래핑해야합니다 . aclosing () :</target>
        </trans-unit>
        <trans-unit id="afe1ff8003ea530b55335c00c2d112291a819532" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t use &lt;code&gt;aclosing()&lt;/code&gt;, then Trio will do its best anyway, but you&amp;rsquo;ll have to contend with the following semantics:</source>
          <target state="translated">&lt;code&gt;aclosing()&lt;/code&gt; 사용하지 않는다면 Trio는 최선을 다할 것입니다.하지만 다음과 같은 의미를 가지고 다투어 야합니다.</target>
        </trans-unit>
        <trans-unit id="2f265254292033b2d3c37d7b404f709ecf9005d4" translate="yes" xml:space="preserve">
          <source>If you get lost or confused&amp;hellip;</source>
          <target state="translated">길을 잃거나 혼란에 빠지면</target>
        </trans-unit>
        <trans-unit id="0d5e059f915ee38aa02ece60adf78aaec1b32ce6" translate="yes" xml:space="preserve">
          <source>If you have a custom hostname resolver, then implementing &lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt;&lt;code&gt;HostnameResolver&lt;/code&gt;&lt;/a&gt; allows you to register this to be used by Trio.</source>
          <target state="translated">사용자 정의 호스트 이름 확인자가 있으면 구현 &lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt; &lt;code&gt;HostnameResolver&lt;/code&gt; &lt;/a&gt;하면이를 Trio에서 사용하도록 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dd0b64a4d20558a4299bef6ebfe5a6acb436034" translate="yes" xml:space="preserve">
          <source>If you have a loop like this, then you can also pass a &lt;code&gt;run_sync_soon_not_threadsafe=...&lt;/code&gt; kwarg to &lt;a href=&quot;#trio.lowlevel.start_guest_run&quot;&gt;&lt;code&gt;start_guest_run&lt;/code&gt;&lt;/a&gt;, and Trio will automatically use it when appropriate.</source>
          <target state="translated">이와 같은 루프가있는 경우 &lt;code&gt;run_sync_soon_not_threadsafe=...&lt;/code&gt; kwarg를 &lt;a href=&quot;#trio.lowlevel.start_guest_run&quot;&gt; &lt;code&gt;start_guest_run&lt;/code&gt; 에&lt;/a&gt; 전달할 수도 있으며 Trio는 적절한 경우 자동으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="36078a151ccd458996ba1aa8099651b56e2af5bc" translate="yes" xml:space="preserve">
          <source>If you have a specific interface you want to bind to, pass its IP address or hostname here. If a hostname resolves to multiple IP addresses, this function will open one listener on each of them.</source>
          <target state="translated">바인딩하려는 특정 인터페이스가있는 경우 여기에 해당 IP 주소 또는 호스트 이름을 전달하십시오. 호스트 이름이 여러 IP 주소로 확인되면이 기능은 각각에 대해 하나의 리스너를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="aa7c7d3fa08a55acc573928d4505f57bfc8e1d8d" translate="yes" xml:space="preserve">
          <source>If you have an async generator that wants to &lt;code&gt;yield&lt;/code&gt; from within a nursery or cancel scope, your best bet is to refactor it to be a separate task that communicates over memory channels. The &lt;code&gt;trio_util&lt;/code&gt; package offers a &lt;a href=&quot;https://trio-util.readthedocs.io/en/latest/#trio_util.trio_async_generator&quot;&gt;decorator that does this for you transparently&lt;/a&gt;.</source>
          <target state="translated">nursery 내 에서 &lt;code&gt;yield&lt;/code&gt; 하거나 범위를 취소 하려는 비동기 생성기가있는 경우 가장 좋은 방법은 메모리 채널을 통해 통신하는 별도의 작업으로 리팩터링하는 것입니다. &lt;code&gt;trio_util&lt;/code&gt; 의 패키지는 제공 &lt;a href=&quot;https://trio-util.readthedocs.io/en/latest/#trio_util.trio_async_generator&quot;&gt;투명하게 당신을 위해이 작업을 수행 장식을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7591ea78cf8028ce1427e112792af18d3864711d" translate="yes" xml:space="preserve">
          <source>If you have code that was written to use &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket&quot;&gt;&lt;code&gt;ssl.SSLSocket&lt;/code&gt;&lt;/a&gt; and now you&amp;rsquo;re porting it to Trio, then it may be useful to know that a difference between &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket&quot;&gt;&lt;code&gt;ssl.SSLSocket&lt;/code&gt;&lt;/a&gt; is that &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt; implements the &lt;code&gt;https_compatible=True&lt;/code&gt; behavior by default.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket&quot;&gt; &lt;code&gt;ssl.SSLSocket&lt;/code&gt; &lt;/a&gt; 을 사용하도록 작성된 코드가 있고 이제이를 Trio로 포팅하는 경우 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket&quot;&gt; &lt;code&gt;ssl.SSLSocket&lt;/code&gt; 의 차이점&lt;/a&gt; 은 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;https_compatible=True&lt;/code&gt; 이 기본적으로 https_compatible = True 동작을 것 입니다.</target>
        </trans-unit>
        <trans-unit id="4abae696645e70fb575d1bdc420f51262668ed04" translate="yes" xml:space="preserve">
          <source>If you have multiple decorators on the same function, then this should be at the bottom of the stack (closest to the actual function).</source>
          <target state="translated">동일한 기능에 여러 데코레이터가있는 경우 스택의 맨 아래에 있어야합니다 (실제 기능에 가장 가깝습니다).</target>
        </trans-unit>
        <trans-unit id="128c75659cdce10482417b79d20ee7014fe95a07" translate="yes" xml:space="preserve">
          <source>If you have two different file descriptors for sending and receiving, and want to bundle them together into a single bidirectional &lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;, then use &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt;&lt;code&gt;trio.StapledStream&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">보내고받는 두 개의 서로 다른 파일 디스크립터가 있고이를 단일 양방향 &lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt; &lt;code&gt;trio.StapledStream&lt;/code&gt; &lt;/a&gt; 려면 trio.StapledStream 을 사용 하십시오. .</target>
        </trans-unit>
        <trans-unit id="fac66d8395b1b17b3fd93c5ceb91487894a57b1f" translate="yes" xml:space="preserve">
          <source>If you iterate over an async generator in its entirety, like the example above does, then the execution of the async generator will occur completely in the context of the code that&amp;rsquo;s iterating over it, and there aren&amp;rsquo;t too many surprises.</source>
          <target state="translated">위의 예제와 같이 비동기 생성기를 전체적으로 반복하면 비동기 생성기의 실행은 반복되는 코드의 컨텍스트에서 완전히 발생하며 놀라움은 그리 많지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01311317ab6fdc5abc001bd1faede4dd410963a9" translate="yes" xml:space="preserve">
          <source>If you only run subprocesses without &lt;code&gt;shell=True&lt;/code&gt; and on UNIX, that&amp;rsquo;s all you need to know about specifying the command. If you use &lt;code&gt;shell=True&lt;/code&gt; or run on Windows, you probably should read the rest of this section to be aware of potential pitfalls.</source>
          <target state="translated">&lt;code&gt;shell=True&lt;/code&gt; 를 사용 하지 않고 UNIX에서 하위 프로세스 만 실행 하는 경우 명령 지정에 대해 알아야합니다. 당신이 사용하는 경우 &lt;code&gt;shell=True&lt;/code&gt; 하거나 Windows에서 실행하는 경우이 섹션의 나머지 부분을 읽고 잠재적 인 함정을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="897364a3149dbec44fea98accb008eec0b871c7a" translate="yes" xml:space="preserve">
          <source>If you pass None (the default), then the behavior depends on the platform:</source>
          <target state="translated">None (기본값)을 전달하면 플랫폼에 따라 동작이 달라집니다.</target>
        </trans-unit>
        <trans-unit id="dbed413933f53fb32a3b809c44e3042b96d0e035" translate="yes" xml:space="preserve">
          <source>If you plan to run your code on PyPy to take advantage of its better performance, you should be aware that PyPy is &lt;em&gt;far more likely&lt;/em&gt; than CPython to perform async generator cleanup at a time well after the last use of the generator. (This is a consequence of the fact that PyPy does not use reference counting to manage memory.) To help catch issues like this, Trio will issue a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ResourceWarning&quot;&gt;&lt;code&gt;ResourceWarning&lt;/code&gt;&lt;/a&gt; (ignored by default, but enabled when running under &lt;code&gt;python -X dev&lt;/code&gt; for example) for each async generator that needs to be handled through the fallback finalization path.</source>
          <target state="translated">더 나은 성능을 활용하기 위해 PyPy에서 코드를 실행하려는 경우 PyPy가 생성기를 마지막으로 사용한 후 한 번에 비동기 생성기 정리를 수행 할 &lt;em&gt;가능성&lt;/em&gt; 이 CPython보다 &lt;em&gt;훨씬 더 높다는&lt;/em&gt; 점에 유의해야합니다 . (이것은 PyPy가 메모리를 관리하기 위해 참조 계산을 사용하지 않는다는 사실의 결과입니다.) 이와 같은 문제를 포착하기 위해 Trio는 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ResourceWarning&quot;&gt; &lt;code&gt;ResourceWarning&lt;/code&gt; &lt;/a&gt; 을 발행합니다 (기본적으로 무시되지만 예를 들어 &lt;code&gt;python -X dev&lt;/code&gt; 에서 실행할 때 활성화 됨 ). 대체 완료 경로를 통해 처리해야하는 각 비동기 생성기.</target>
        </trans-unit>
        <trans-unit id="f7360df706636e337b70ce5ebedc83a7dc602aa0" translate="yes" xml:space="preserve">
          <source>If you run this program, you&amp;rsquo;ll see output like:</source>
          <target state="translated">이 프로그램을 실행하면 다음과 같은 출력이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="11df8229fc6ec0bf8c5039502d2ef765262f6ef2" translate="yes" xml:space="preserve">
          <source>If you run this, it prints:</source>
          <target state="translated">이것을 실행하면 다음과 같이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="29e33e39e5f4c64e7e7902552bf27f16a4cc81b1" translate="yes" xml:space="preserve">
          <source>If you spawn a &lt;a href=&quot;#subprocess&quot;&gt;Spawning subprocesses&lt;/a&gt;, you can get a &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt; that lets you write to its stdin, and a &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt; that lets you read from its stdout. If for some reason you wanted to speak SSL to a subprocess, you could use a &lt;a href=&quot;#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt; to combine its stdin/stdout into a single bidirectional &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;, and then wrap that in an &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">당신이 산란하면 &lt;a href=&quot;#subprocess&quot;&gt;산란 서브 프로세스를&lt;/a&gt; , 당신은 얻을 수 &lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; 당신은 그것의 표준 입력에 기록 할 수 있습니다, 그리고 &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; 당신은 표준 출력에서 읽을 수 있습니다. 어떤 이유로 SSL을 하위 프로세스와 &lt;a href=&quot;#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt; 하려는 경우 StapledStream 을 사용하여 stdin / stdout을 단일 양방향 &lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 에 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 다음 SSLStream으로 래핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a65e08c2f2bfba3c862baaae5a5b94cdaaca3e81" translate="yes" xml:space="preserve">
          <source>If you spawn a &lt;a href=&quot;#subprocess&quot;&gt;subprocess&lt;/a&gt;, you can get a &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt; that lets you write to its stdin, and a &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt; that lets you read from its stdout. If for some reason you wanted to speak SSL to a subprocess, you could use a &lt;a href=&quot;#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt; to combine its stdin/stdout into a single bidirectional &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;, and then wrap that in an &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">당신이 산란하면 &lt;a href=&quot;#subprocess&quot;&gt;하위 프로세스를&lt;/a&gt; , 당신은 얻을 수 &lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; 당신은 그것의 표준 입력에 기록 할 수 있습니다, 그리고 &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; 당신은 표준 출력에서 읽을 수 있습니다. 어떤 이유로 SSL을 하위 프로세스에 말하고 &lt;a href=&quot;#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt; 을 사용하여 stdin / stdout을 단일 양방향 &lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 으로 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 다음 SSLStream으로 래핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab3304f0b7f762b993b24e90fc2ed83703c668e7" translate="yes" xml:space="preserve">
          <source>If you try to call it when inside a cancelled scope, then it will raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">취소 된 범위 내에서 호출하려고하면 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="0cb8ad089db9738a30a52161499bfc8d1fd20710" translate="yes" xml:space="preserve">
          <source>If you use 0 as your port, then the kernel will automatically pick an arbitrary open port. But be careful: if you use this feature when binding to multiple IP addresses, then each IP address will get its own random port, and the returned listeners will probably be listening on different ports. In particular, this will happen if you use &lt;code&gt;host=None&lt;/code&gt; &amp;ndash; which is the default &amp;ndash; because in this case &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt; will bind to both the IPv4 wildcard address (&lt;code&gt;0.0.0.0&lt;/code&gt;) and also the IPv6 wildcard address (&lt;code&gt;::&lt;/code&gt;).</source>
          <target state="translated">포트로 0을 사용하면 커널은 자동으로 임의의 열린 포트를 선택합니다. 그러나 여러 IP 주소에 바인딩 할 때이 기능을 사용하는 경우 각 IP 주소는 고유 한 임의 포트를 가져 오며 리턴 된 리스너는 다른 포트에서 청취 할 수 있습니다. 특히, &lt;code&gt;host=None&lt;/code&gt; ( 기본값 &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt; 하면 open_tcp_listeners () 가 IPv4 와일드 카드 주소 ( &lt;code&gt;0.0.0.0&lt;/code&gt; )와 IPv6 와일드 카드 주소 ( &lt;code&gt;::&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5543c466f9c01af550a6f542ad5031f46ced7c79" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;autojump_threshold&lt;/code&gt; and &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;wait_all_tasks_blocked&lt;/code&gt;&lt;/a&gt; at the same time, then you might wonder how they interact, since they both cause things to happen after the run loop goes idle for some time. The answer is: &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;wait_all_tasks_blocked&lt;/code&gt;&lt;/a&gt; takes priority. If there&amp;rsquo;s a task blocked in &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;wait_all_tasks_blocked&lt;/code&gt;&lt;/a&gt;, then the autojump feature treats that as active task and does &lt;em&gt;not&lt;/em&gt; jump the clock.</source>
          <target state="translated">&lt;code&gt;autojump_threshold&lt;/code&gt; 와 &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;wait_all_tasks_blocked&lt;/code&gt; &lt;/a&gt; 를 동시에 사용하는 경우 , 둘 다 실행 루프가 일정 시간 동안 유휴 상태가 된 후에 일이 발생하기 때문에 어떻게 상호 작용하는지 궁금 할 수 있습니다. 대답은 다음과 같습니다. &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;wait_all_tasks_blocked&lt;/code&gt; &lt;/a&gt; 가 우선합니다. &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;wait_all_tasks_blocked&lt;/code&gt; &lt;/a&gt; 에서 차단 된 작업이있는 경우 자동 점프 기능은 해당 작업을 활성 작업으로 처리 하고 시간을 뛰어 넘지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="88ea13f3432ce0d9874ea1805ddf2510d4d0a998" translate="yes" xml:space="preserve">
          <source>If you use this method, you might also want to read up on &lt;code&gt;TCP_NOTSENT_LOWAT&lt;/code&gt;.</source>
          <target state="translated">이 방법을 사용하면 &lt;code&gt;TCP_NOTSENT_LOWAT&lt;/code&gt; 에서 읽을 수도 있습니다. .</target>
        </trans-unit>
        <trans-unit id="09dbf762feb49b973e46e9fbb006f708d4b2a633" translate="yes" xml:space="preserve">
          <source>If you want a timeout to apply to one task but not another, then you need to put the cancel scope in that individual task&amp;rsquo;s function &amp;ndash; &lt;code&gt;child()&lt;/code&gt;, in this example.</source>
          <target state="translated">타임 아웃을 한 작업에만 적용하고 다른 작업에는 적용하지 않으려면 해당 개별 작업의 함수 &lt;code&gt;child()&lt;/code&gt; 이 예에서는 child ())에 취소 범위를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7f6ced9e55c1c268f602e730722b3278b20ae5e9" translate="yes" xml:space="preserve">
          <source>If you want more control than &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process()&lt;/code&gt;&lt;/a&gt; affords, you can use &lt;a href=&quot;#trio.open_process&quot;&gt;&lt;code&gt;trio.open_process&lt;/code&gt;&lt;/a&gt; to spawn a subprocess, and then interact with it using the &lt;a href=&quot;#trio.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process()&lt;/code&gt; &lt;/a&gt; 보다 더 많은 제어를 원한다면 &lt;a href=&quot;#trio.open_process&quot;&gt; &lt;code&gt;trio.open_process&lt;/code&gt; &lt;/a&gt; 를 사용 하여 하위 프로세스를 생성 한 다음 &lt;a href=&quot;#trio.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; 를&lt;/a&gt; 사용하여 하위 프로세스와 상호 작용할 수 있습니다 인터페이스를 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6f6793bc982be8f22f967ad6a21c35ccf9672fe" translate="yes" xml:space="preserve">
          <source>If you want to bind to the wildcard address on both IPv4 and IPv6, in order to accept connections on all available interfaces, then pass &lt;code&gt;None&lt;/code&gt;. This is the default.</source>
          <target state="translated">사용 가능한 모든 인터페이스에서 연결을 수락하려면 IPv4 및 IPv6 모두에서 와일드 카드 주소에 바인딩하려면 &lt;code&gt;None&lt;/code&gt; 을 전달하십시오. . 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="cc32146617cf84e9f0d7584624d5d7d483182905" translate="yes" xml:space="preserve">
          <source>If you want to capture both stdout and stderr but mixed together in the order they were printed, use: &lt;code&gt;capture_stdout=True, stderr=subprocess.STDOUT&lt;/code&gt;. This directs the child&amp;rsquo;s stderr into its stdout, so the combined output will be available in the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">stdout과 stderr을 모두 캡처하지만 인쇄 된 순서대로 혼합하려면 &lt;code&gt;capture_stdout=True, stderr=subprocess.STDOUT&lt;/code&gt; . 이것은 어린이의 stderr를 stdout으로 보내므로 결합 된 출력을 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 속성 .</target>
        </trans-unit>
        <trans-unit id="af86717e438853496483f21a6a34b9a46aaba18a" translate="yes" xml:space="preserve">
          <source>If you want to capture both stdout and stderr while keeping them separate, pass &lt;code&gt;capture_stdout=True, capture_stderr=True&lt;/code&gt;.</source>
          <target state="translated">stdout과 stderr을 별도로 유지하면서 캡처하려면 &lt;code&gt;capture_stdout=True, capture_stderr=True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a38252b45e1e41c55aef1d759da898cbd8aba075" translate="yes" xml:space="preserve">
          <source>If you want to impose a timeout on a function, and then do some recovery if it timed out:</source>
          <target state="translated">함수에 시간 초과를 적용하고 시간이 초과되면 복구를 수행하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="79b96112188d56b28253e13ce6571d9e8abdac13" translate="yes" xml:space="preserve">
          <source>If you want to impose a timeout on a function, and then if it times out then just give up and raise an error for your caller to deal with:</source>
          <target state="translated">함수에 시간 초과를 적용하려는 경우 시간 초과되면 호출자가 처리 할 수있는 오류를 포기하고 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="3f808a75d4604bc4da76b55cf7478ba608c98efb" translate="yes" xml:space="preserve">
          <source>If you want to impose a timeout on a function, but you don&amp;rsquo;t care whether it timed out or not:</source>
          <target state="translated">함수에 시간 초과를 적용하고 싶지만 시간 초과 여부는 상관하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a1518753dc6c14afc1ab9954c1aa2f9c4537ee9" translate="yes" xml:space="preserve">
          <source>If you want to perform general filesystem operations like creating and listing directories, renaming files, or checking file metadata &amp;ndash; or if you just want a friendly way to work with filesystem paths &amp;ndash; then you want &lt;a href=&quot;#trio.Path&quot;&gt;&lt;code&gt;trio.Path&lt;/code&gt;&lt;/a&gt;. It&amp;rsquo;s an asyncified replacement for the standard library&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path&quot;&gt;&lt;code&gt;pathlib.Path&lt;/code&gt;&lt;/a&gt;, and provides the same comprehensive set of operations.</source>
          <target state="translated">디렉토리 생성 및 나열, 파일 이름 변경 또는 파일 메타 데이터 확인과 같은 일반적인 파일 시스템 작업을 수행하려는 경우 또는 파일 시스템 경로를 사용하는 친숙한 방법을 원한다면 &lt;a href=&quot;#trio.Path&quot;&gt; &lt;code&gt;trio.Path&lt;/code&gt; 가 필요&lt;/a&gt; 합니다. 표준 라이브러리의 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path&quot;&gt; &lt;code&gt;pathlib.Path&lt;/code&gt; &lt;/a&gt; 대체하는 비동기식입니다. 및 운영의 같은 포괄적 인 세트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5c2ff5e1676e07dfee499073adaeae46d1a263de" translate="yes" xml:space="preserve">
          <source>If you want to receive Python objects rather than raw bytes, see &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;ReceiveChannel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">원시 바이트가 아닌 Python 객체를 수신하려면 &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;ReceiveChannel&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d873431abf560f99e75a2d91264bee1f1cb0ab51" translate="yes" xml:space="preserve">
          <source>If you want to receive raw bytes rather than Python objects, see &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Python 객체가 아닌 원시 바이트를 수신하려면 &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="58a3ef3ebf410f4e73e5e916a21fac2377aedcd3" translate="yes" xml:space="preserve">
          <source>If you want to see the effect of the consumer exiting early, try adding a &lt;code&gt;break&lt;/code&gt; statement to the &lt;code&gt;async for&lt;/code&gt; loop &amp;ndash; you should see a &lt;a href=&quot;#trio.BrokenResourceError&quot;&gt;&lt;code&gt;BrokenResourceError&lt;/code&gt;&lt;/a&gt; from the producer.</source>
          <target state="translated">소비자가 조기에 종료되는 효과를 보려면 &lt;code&gt;async for&lt;/code&gt; 루프에 &lt;code&gt;break&lt;/code&gt; 문을 추가 하십시오 . 제작자에서 &lt;a href=&quot;#trio.BrokenResourceError&quot;&gt; &lt;code&gt;BrokenResourceError&lt;/code&gt; &lt;/a&gt; 가 표시되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9d4b21118989033e089c8ae10cb1be03ab62b474" translate="yes" xml:space="preserve">
          <source>If you want to send Python objects rather than raw bytes, see &lt;a href=&quot;#trio.abc.SendChannel&quot;&gt;&lt;code&gt;SendChannel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">원시 바이트가 아닌 Python 객체를 보내려면 &lt;a href=&quot;#trio.abc.SendChannel&quot;&gt; &lt;code&gt;SendChannel&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2bfa949577a81d6ee39c408b0060d9b3a9b1359f" translate="yes" xml:space="preserve">
          <source>If you want to send raw bytes rather than Python objects, see &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Python 객체가 아닌 원시 바이트를 보내려면 &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b649dc4f90278f824cfab5f8caee2dc1ba75bcb5" translate="yes" xml:space="preserve">
          <source>If you want to send raw bytes rather than Python objects, see &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Python 객체가 아닌 원시 바이트를 보내려면 &lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="15078494d6548257baf334a23f5ce3f1047e5763" translate="yes" xml:space="preserve">
          <source>If you want to stress test a protocol implementation, one nice trick is to use the &lt;a href=&quot;https://docs.python.org/3/library/random.html#module-random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; module (preferably with a fixed seed) to move random numbers of bytes at a time, and insert random sleeps in between them. You can also set up a custom &lt;a href=&quot;#trio.testing.MemoryReceiveStream.receive_some_hook&quot;&gt;&lt;code&gt;receive_some_hook&lt;/code&gt;&lt;/a&gt; if you want to manipulate things on the receiving side, and not just the sending side.</source>
          <target state="translated">프로토콜 구현에 대한 스트레스 테스트를 원할 경우 &lt;a href=&quot;https://docs.python.org/3/library/random.html#module-random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt; 모듈 (바람직하게는 고정 된 시드)을 사용하여 한 번에 임의의 바이트 수를 이동하고 그 사이에 임의의 절전 모드를 삽입하는 것이 좋습니다. 송신 측뿐만 아니라 수신 측에서 항목을 조작하려는 경우 사용자 정의 &lt;a href=&quot;#trio.testing.MemoryReceiveStream.receive_some_hook&quot;&gt; &lt;code&gt;receive_some_hook&lt;/code&gt; 을&lt;/a&gt; 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f91fa402eff1105a1adeaf1e1e3e650782929273" translate="yes" xml:space="preserve">
          <source>If you want to use Trio, then the first thing you have to do is call &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Trio를 사용하려면 먼저 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="21c7da565039fca46c6760ffc74fa89fb0eba0cd" translate="yes" xml:space="preserve">
          <source>If you want to use only IPv4, or only IPv6, but want to accept on all interfaces, pass the family-specific wildcard address: &lt;code&gt;&quot;0.0.0.0&quot;&lt;/code&gt; for IPv4-only and &lt;code&gt;&quot;::&quot;&lt;/code&gt; for IPv6-only.</source>
          <target state="translated">IPv4 만 사용하거나 IPv6 만 사용하고 모든 인터페이스에서 허용하려면 IPv4 전용의 경우 &lt;code&gt;&quot;0.0.0.0&quot;&lt;/code&gt; 및 IPv6 전용의 경우 &lt;code&gt;&quot;::&quot;&lt;/code&gt; 과 같은 패밀리 별 와일드 카드 주소를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="409a1ee1102eee81503ac9b40ded20152aafe6b5" translate="yes" xml:space="preserve">
          <source>If you write a custom class implementing the Trio socket interface, then you can use a &lt;a href=&quot;#trio.abc.SocketFactory&quot;&gt;&lt;code&gt;SocketFactory&lt;/code&gt;&lt;/a&gt; to get Trio to use it.</source>
          <target state="translated">Trio 소켓 인터페이스를 구현하는 사용자 정의 클래스를 작성하는 경우 &lt;a href=&quot;#trio.abc.SocketFactory&quot;&gt; &lt;code&gt;SocketFactory&lt;/code&gt; &lt;/a&gt; 를 사용하여 Trio가이를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6034aab77a6f216c1ab5b1d5c3f35931c5c8769" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a mad scientist or otherwise feel the need to take direct control over the PASSAGE OF TIME ITSELF, then you can implement a custom &lt;a href=&quot;#trio.abc.Clock&quot;&gt;&lt;code&gt;Clock&lt;/code&gt;&lt;/a&gt; class:</source>
          <target state="translated">미친 과학자이거나 PASSAGE OF TIME ITSELF를 직접 제어해야 할 필요가 있다고 생각되면 사용자 정의 &lt;a href=&quot;#trio.abc.Clock&quot;&gt; &lt;code&gt;Clock&lt;/code&gt; &lt;/a&gt; 클래스를 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce8031c58c1526815dbf37b52fa1e2d05777dd57" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re familiar with semaphores, then you can think of this as a restricted semaphore that&amp;rsquo;s specialized for one common use case, with additional error checking. For a more traditional semaphore, see &lt;a href=&quot;#trio.Semaphore&quot;&gt;&lt;code&gt;Semaphore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">세마포어에 익숙한 경우이를 추가 오류 검사와 함께 하나의 일반적인 사용 사례에 특화된 제한된 세마포어로 생각할 수 있습니다. 보다 전통적인 세마포어을 참조 &lt;a href=&quot;#trio.Semaphore&quot;&gt; &lt;code&gt;Semaphore&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ee1d508a124c1215a7b5f07506c4f3b67f9cb32" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re looking for a &lt;a href=&quot;#trio.Semaphore&quot;&gt;&lt;code&gt;Semaphore&lt;/code&gt;&lt;/a&gt; to limit the number of tasks that can access some resource simultaneously, then consider using a &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">일부 리소스에 동시에 액세스 할 수있는 작업 수를 제한 하는 &lt;a href=&quot;#trio.Semaphore&quot;&gt; &lt;code&gt;Semaphore&lt;/code&gt; &lt;/a&gt; 를 찾고 있다면 대신 &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; 를&lt;/a&gt; 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="c2ceab8baefc8898008496db6707ffc21bacfe8c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt;&lt;code&gt;autojump_threshold&lt;/code&gt;&lt;/a&gt; together, then you have to be careful. Setting &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt;&lt;code&gt;autojump_threshold&lt;/code&gt;&lt;/a&gt; acts like a background task calling:</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt; &lt;code&gt;autojump_threshold&lt;/code&gt; 를&lt;/a&gt; 함께 사용 하는 경우주의해야합니다. &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt; &lt;code&gt;autojump_threshold&lt;/code&gt; 를&lt;/a&gt; 설정 하면 백그라운드 작업을 호출하는 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="08c549cf9087de57658bffaeb40cba21be44321a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve used other I/O frameworks, you may have encountered the concept of a &amp;ldquo;thread pool&amp;rdquo;, which is most commonly implemented as a fixed size collection of threads that hang around waiting for jobs to be assigned to them. These solve two different problems: First, re-using the same threads over and over is more efficient than starting and stopping a new thread for every job you need done; basically, the pool acts as a kind of cache for idle threads. And second, having a fixed size avoids getting into a situation where 100,000 jobs are submitted simultaneously, and then 100,000 threads are spawned and the system gets overloaded and crashes. Instead, the N threads start executing the first N jobs, while the other (100,000 - N) jobs sit in a queue and wait their turn. Which is generally what you want, and this is how &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt; works by default.</source>
          <target state="translated">다른 I / O 프레임 워크를 사용한 경우 &quot;스레드 풀&quot;이라는 개념이있을 수 있습니다.이 스레드 풀은 작업이 할당 될 때까지 기다리는 고정 된 크기의 스레드 모음으로 가장 일반적으로 구현됩니다. 이들은 두 가지 다른 문제를 해결합니다. 첫째, 동일한 스레드를 반복해서 재사용하는 것이 필요한 모든 작업에 대해 새 스레드를 시작하고 중지하는 것보다 효율적입니다. 기본적으로 풀은 유휴 스레드에 대한 일종의 캐시 역할을합니다. 둘째, 크기가 고정되어 있으면 100,000 개의 작업이 동시에 제출 된 다음 100,000 개의 스레드가 생성되고 시스템이 오버로드되어 충돌하는 상황이 발생하지 않습니다. 대신 N 스레드가 첫 번째 N 작업을 실행하기 시작하고 다른 (100,000-N) 작업은 대기열에 앉아 차례를 기다립니다. 어느 것이 일반적으로 원하는지, 이것이 어떻게&lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt; 는 기본적으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3b707c51adeef615b8afcc1a6c139b7761d771ed" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve used the &lt;a href=&quot;https://docs.python.org/3/library/threading.html#module-threading&quot;&gt;&lt;code&gt;threading&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html#module-asyncio&quot;&gt;&lt;code&gt;asyncio&lt;/code&gt;&lt;/a&gt; modules, you may be familiar with &lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Queue&quot;&gt;&lt;code&gt;queue.Queue&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue&quot;&gt;&lt;code&gt;asyncio.Queue&lt;/code&gt;&lt;/a&gt;. In Trio, &lt;a href=&quot;#trio.open_memory_channel&quot;&gt;&lt;code&gt;open_memory_channel()&lt;/code&gt;&lt;/a&gt; is what you use when you&amp;rsquo;re looking for a queue. The main difference is that Trio splits the classic queue interface up into two objects. The advantage of this is that it makes it possible to put the two ends in different processes without rewriting your code, and that we can close the two sides separately.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/threading.html#module-threading&quot;&gt; &lt;code&gt;threading&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html#module-asyncio&quot;&gt; &lt;code&gt;asyncio&lt;/code&gt; &lt;/a&gt; 모듈을 사용한 경우 &lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Queue&quot;&gt; &lt;code&gt;queue.Queue&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue&quot;&gt; &lt;code&gt;asyncio.Queue&lt;/code&gt; 에&lt;/a&gt; 익숙 할 수 있습니다 . Trio에서 &lt;a href=&quot;#trio.open_memory_channel&quot;&gt; &lt;code&gt;open_memory_channel()&lt;/code&gt; &lt;/a&gt; 은 대기열을 찾을 때 사용하는 것입니다. 가장 큰 차이점은 Trio가 클래식 대기열 인터페이스를 두 개체로 분할한다는 것입니다. 이 방법의 장점은 코드를 다시 작성하지 않고도 두 프로세스를 서로 다른 프로세스에 배치 할 수 있고 두 측면을 개별적으로 닫을 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1b07f876adc2ea078990a31a6d6fd87e7ced229f" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;abort_func&lt;/code&gt; raises an error, or returns any value other than &lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt;&lt;code&gt;Abort.SUCCEEDED&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.hazmat.Abort.FAILED&quot;&gt;&lt;code&gt;Abort.FAILED&lt;/code&gt;&lt;/a&gt;, then Trio will crash violently. Be careful! Similarly, it is entirely possible to deadlock a Trio program by failing to reschedule a blocked task, or cause havoc by calling &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; too many times. Remember what we said up above about how you should use a higher-level API if at all possible?</source>
          <target state="translated">귀하의 경우 &lt;code&gt;abort_func&lt;/code&gt; 이 오류가 발생합니다, 또는 이외의 값 반환 &lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt; &lt;code&gt;Abort.SUCCEEDED&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#trio.hazmat.Abort.FAILED&quot;&gt; &lt;code&gt;Abort.FAILED&lt;/code&gt; 을&lt;/a&gt; 다음 트리오가 격렬하게 충돌합니다. 조심해! 마찬가지로 차단 된 작업을 다시 예약하지 않으면 Trio 프로그램을 교착 상태로 만들거나 &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; 너무 많이 호출하여 혼란을 일으킬 수 있습니다 . 가능한 경우 더 높은 수준의 API를 사용해야하는 방법에 대해 위에서 언급 한 내용을 기억하십니까?</target>
        </trans-unit>
        <trans-unit id="755ddabb597135e122e5fa6d045e3350c6b53178" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;abort_func&lt;/code&gt; raises an error, or returns any value other than &lt;a href=&quot;#trio.lowlevel.Abort.SUCCEEDED&quot;&gt;&lt;code&gt;Abort.SUCCEEDED&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.lowlevel.Abort.FAILED&quot;&gt;&lt;code&gt;Abort.FAILED&lt;/code&gt;&lt;/a&gt;, then Trio will crash violently. Be careful! Similarly, it is entirely possible to deadlock a Trio program by failing to reschedule a blocked task, or cause havoc by calling &lt;a href=&quot;#trio.lowlevel.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; too many times. Remember what we said up above about how you should use a higher-level API if at all possible?</source>
          <target state="translated">귀하의 경우 &lt;code&gt;abort_func&lt;/code&gt; 이 오류가 발생합니다, 또는 이외의 값 반환 &lt;a href=&quot;#trio.lowlevel.Abort.SUCCEEDED&quot;&gt; &lt;code&gt;Abort.SUCCEEDED&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#trio.lowlevel.Abort.FAILED&quot;&gt; &lt;code&gt;Abort.FAILED&lt;/code&gt; 을&lt;/a&gt; 다음 트리오가 격렬하게 충돌합니다. 조심해! 마찬가지로 차단 된 작업을 다시 예약하지 못하여 Trio 프로그램을 교착 상태로 만들거나 &lt;a href=&quot;#trio.lowlevel.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; 너무 많이 호출하여 혼란을 일으킬 수 있습니다 . 가능하다면 더 높은 수준의 API를 사용하는 방법에 대해 위에서 언급 한 내용을 기억하십니까?</target>
        </trans-unit>
        <trans-unit id="b7882fa5e62bad6293455fd986d10a4d6e106506" translate="yes" xml:space="preserve">
          <source>If your loop doesn&amp;rsquo;t have a split like this, then don&amp;rsquo;t worry about it; &lt;code&gt;run_sync_soon_not_threadsafe=&lt;/code&gt; is optional. (If it&amp;rsquo;s not passed, then Trio will just use your threadsafe version in all cases.)</source>
          <target state="translated">루프에 이와 같은 분할이 없으면 걱정하지 마십시오. &lt;code&gt;run_sync_soon_not_threadsafe=&lt;/code&gt; 는 선택 사항입니다. (통과되지 않으면 Trio는 모든 경우에 스레드 세이프 버전을 사용합니다.)</target>
        </trans-unit>
        <trans-unit id="ff86e8a0e44097dd7b83d0d5d32ae083b8e9da0f" translate="yes" xml:space="preserve">
          <source>Immediately call &lt;a href=&quot;#trio.lowlevel.start_guest_run&quot;&gt;&lt;code&gt;start_guest_run&lt;/code&gt;&lt;/a&gt; to start Trio</source>
          <target state="translated">즉시 &lt;a href=&quot;#trio.lowlevel.start_guest_run&quot;&gt; &lt;code&gt;start_guest_run&lt;/code&gt; &lt;/a&gt; 을 호출 하여 Trio를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="1f6649636f5ec26220a403d0be3a3dfad0c81513" translate="yes" xml:space="preserve">
          <source>Immediately terminate the process.</source>
          <target state="translated">프로세스를 즉시 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="f713fbd33a8265bbfd0312d0010fb2e55c75adbc" translate="yes" xml:space="preserve">
          <source>Implementing guest mode for your favorite event loop</source>
          <target state="translated">좋아하는 이벤트 루프를위한 게스트 모드 구현</target>
        </trans-unit>
        <trans-unit id="4f6dbe18b8350bccd3b6cbe5e585a2220801dfd1" translate="yes" xml:space="preserve">
          <source>In Trio, child tasks inherit the parent nursery&amp;rsquo;s cancel scopes. So in this example, both the child tasks will be cancelled when the timeout expires:</source>
          <target state="translated">Trio에서 하위 작업은 상위 보육원의 취소 범위를 상속합니다. 따라서이 예에서 시간 초과가 만료되면 두 하위 작업이 모두 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="adca0c20a8b210b6d717b9f157a4e42c8458511e" translate="yes" xml:space="preserve">
          <source>In Trio, we standardize on the following conventions:</source>
          <target state="translated">Trio에서는 다음 규칙을 표준화합니다.</target>
        </trans-unit>
        <trans-unit id="eba0fbe044bed37d1ee5815afce7800f998f1460" translate="yes" xml:space="preserve">
          <source>In a perfect world, all third-party libraries and low-level APIs would be natively async and integrated into Trio, and all would be happiness and rainbows.</source>
          <target state="translated">완벽한 세상에서 모든 타사 라이브러리와 저수준 API는 기본적으로 비 동기화되어 Trio에 통합되며 모두 행복과 무지개가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="af175d3a175436652574281c086a32ff0684e455" translate="yes" xml:space="preserve">
          <source>In acknowledgment of this reality, Trio provides two useful utilities for working with real, operating-system level, &lt;a href=&quot;https://docs.python.org/3/library/threading.html#module-threading&quot;&gt;&lt;code&gt;threading&lt;/code&gt;&lt;/a&gt;-module-style threads. First, if you&amp;rsquo;re in Trio but need to push some blocking I/O into a thread, there&amp;rsquo;s &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync&lt;/code&gt;&lt;/a&gt;. And if you&amp;rsquo;re in a thread and need to communicate back with Trio, you can use &lt;a href=&quot;#trio.from_thread.run&quot;&gt;&lt;code&gt;trio.from_thread.run()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.from_thread.run_sync&quot;&gt;&lt;code&gt;trio.from_thread.run_sync()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 현실을 인정하기 위해 Trio는 실제 운영 체제 수준의 &lt;a href=&quot;https://docs.python.org/3/library/threading.html#module-threading&quot;&gt; &lt;code&gt;threading&lt;/code&gt; &lt;/a&gt; 모듈 스타일 스레드 작업에 유용한 두 가지 유틸리티를 제공 합니다. 첫째, Trio에 있지만 차단 I / O를 스레드로 푸시 해야하는 경우&lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync&lt;/code&gt; 가&lt;/a&gt; 있습니다. 스레드에 있고 Trio와 다시 통신해야하는 경우&lt;a href=&quot;#trio.from_thread.run&quot;&gt; &lt;code&gt;trio.from_thread.run()&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;#trio.from_thread.run_sync&quot;&gt; &lt;code&gt;trio.from_thread.run_sync()&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afb36f9e82fb37771a8f45c9fa49b6f8200dd4dc" translate="yes" xml:space="preserve">
          <source>In addition to fulfilling the &lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt; interfaces, the return objects also have a synchronous &lt;code&gt;close&lt;/code&gt; method.</source>
          <target state="translated">성취하는 것 외에도 &lt;a href=&quot;reference-io#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;reference-io#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; 인터페이스반환 개체에는 동기 &lt;code&gt;close&lt;/code&gt; 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1f03f50ad28c191c6b6552e298ff38d97315bda" translate="yes" xml:space="preserve">
          <source>In addition to the methods below, you can use &lt;code&gt;len(parking_lot)&lt;/code&gt; to get the number of parked tasks, and &lt;code&gt;if parking_lot: ...&lt;/code&gt; to check whether there are any parked tasks.</source>
          <target state="translated">아래 방법 외에도 &lt;code&gt;len(parking_lot)&lt;/code&gt; 을 사용 하여 주차 된 작업 수 를 확인 하고 &lt;code&gt;if parking_lot: ...&lt;/code&gt; 주차 된 작업 이 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e73f7536eb9efa30a32fd713063b04bc4ef0794" translate="yes" xml:space="preserve">
          <source>In addition to the standard channel methods, all memory channel objects provide a &lt;code&gt;statistics()&lt;/code&gt; method, which returns an object with the following fields:</source>
          <target state="translated">표준 채널 메소드 외에도 모든 메모리 채널 오브젝트 는 다음 필드가있는 오브젝트를 리턴하는 &lt;code&gt;statistics()&lt;/code&gt; 메소드를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="443c7855adca91f5f4c2a290b45f592b6637683c" translate="yes" xml:space="preserve">
          <source>In addition, the following methods are similar to the equivalents in &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt;&lt;code&gt;socket.socket()&lt;/code&gt;&lt;/a&gt;, but have some Trio-specific quirks:</source>
          <target state="translated">또한 다음 메소드는 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt; &lt;code&gt;socket.socket()&lt;/code&gt; &lt;/a&gt; 의 해당 메소드와 유사 하지만 일부 Trio 관련 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="413061e58789aa3ae8c0df61031c67abdb592c3a" translate="yes" xml:space="preserve">
          <source>In addition, there is a new function to directly convert a standard library socket into a Trio socket:</source>
          <target state="translated">또한 표준 라이브러리 소켓을 Trio 소켓으로 직접 변환하는 새로운 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="425030d69a5c17d60c387cfd4bccb05160ac1b64" translate="yes" xml:space="preserve">
          <source>In any case it&amp;rsquo;s guaranteed that we only call the &lt;code&gt;abort_func&lt;/code&gt; at most once per call to &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">어쨌든 우리는 &lt;code&gt;abort_func&lt;/code&gt; 만 호출한다는 것을 보장합니다&lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 호출마다 최대 한 번만 을 .</target>
        </trans-unit>
        <trans-unit id="119943dc4c8549180ccf506a5e35b7195db27e49" translate="yes" xml:space="preserve">
          <source>In any case it&amp;rsquo;s guaranteed that we only call the &lt;code&gt;abort_func&lt;/code&gt; at most once per call to &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 호출 할 때마다 최대 한 번만 &lt;code&gt;abort_func&lt;/code&gt; 를 호출하는 것이 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="2d2487156a527be9a3f6c580074a96050c5705e6" translate="yes" xml:space="preserve">
          <source>In any case, &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process&lt;/code&gt;&lt;/a&gt; will always wait for the child process to exit before raising &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">어떤 경우에는, &lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process&lt;/code&gt; 은&lt;/a&gt; 항상 올리기 전에 서버 종료에 자식 프로세스를 기다립니다 &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3bca2f4be64f149594f70e7d6b45f8705aa5688a" translate="yes" xml:space="preserve">
          <source>In general, almost all Trio features should work in guest mode. The exception is features which rely on Trio having a complete picture of everything that your program is doing, since obviously, it can&amp;rsquo;t control the host loop or see what it&amp;rsquo;s doing.</source>
          <target state="translated">일반적으로 거의 모든 Trio 기능은 게스트 모드에서 작동합니다. 예외는 Trio가 프로그램이 수행하는 모든 작업에 대한 완전한 그림을 가지고있는 기능입니다. 분명히 호스트 루프를 제어하거나 수행하는 작업을 볼 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ef942a0c9203fcfec85a5301b86deb82c4607851" translate="yes" xml:space="preserve">
          <source>In the US it&amp;rsquo;s also common to see this word spelled &amp;ldquo;canceled&amp;rdquo;, with only one &amp;ldquo;l&amp;rdquo;. This is a &lt;a href=&quot;https://books.google.com/ngrams/graph?content=canceled%2Ccancelled&amp;amp;year_start=1800&amp;amp;year_end=2000&amp;amp;corpus=5&amp;amp;smoothing=3&amp;amp;direct_url=t1%3B%2Ccanceled%3B%2Cc0%3B.t1%3B%2Ccancelled%3B%2Cc0&quot;&gt;recent&lt;/a&gt; and &lt;a href=&quot;https://books.google.com/ngrams/graph?content=canceled%2Ccancelled&amp;amp;year_start=1800&amp;amp;year_end=2000&amp;amp;corpus=18&amp;amp;smoothing=3&amp;amp;share=&amp;amp;direct_url=t1%3B%2Ccanceled%3B%2Cc0%3B.t1%3B%2Ccancelled%3B%2Cc0&quot;&gt;US-specific&lt;/a&gt; innovation, and even in the US both forms are still commonly used. So for consistency with the rest of the world and with &amp;ldquo;cancellation&amp;rdquo; (which always has two &amp;ldquo;l&amp;rdquo;s), Trio uses the two &amp;ldquo;l&amp;rdquo; spelling everywhere.</source>
          <target state="translated">미국에서는이 단어의 철자가 &quot;l&quot;인 &quot;취소됨&quot;이 일반적입니다. 이것은&lt;a href=&quot;https://books.google.com/ngrams/graph?content=canceled%2Ccancelled&amp;amp;year_start=1800&amp;amp;year_end=2000&amp;amp;corpus=5&amp;amp;smoothing=3&amp;amp;direct_url=t1%3B%2Ccanceled%3B%2Cc0%3B.t1%3B%2Ccancelled%3B%2Cc0&quot;&gt; 최근의 &lt;/a&gt;&lt;a href=&quot;https://books.google.com/ngrams/graph?content=canceled%2Ccancelled&amp;amp;year_start=1800&amp;amp;year_end=2000&amp;amp;corpus=18&amp;amp;smoothing=3&amp;amp;share=&amp;amp;direct_url=t1%3B%2Ccanceled%3B%2Cc0%3B.t1%3B%2Ccancelled%3B%2Cc0&quot;&gt;미국 고유의&lt;/a&gt; 혁신 이며 미국 에서도 두 가지 형식이 여전히 일반적으로 사용됩니다. 따라서 세계의 다른 지역 및 &quot;취소&quot;(항상 두 개의 &quot;l&quot;)와 일관성을 유지하기 위해 Trio는 어디서나 두 개의 &quot;l&quot;철자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="16efeed4257a18bc9fdc35fc0ddc91451f889cf7" translate="yes" xml:space="preserve">
          <source>In the example above, we set &lt;code&gt;__cause__&lt;/code&gt; as a form of explicit context chaining. &lt;a href=&quot;#trio.MultiError.filter&quot;&gt;&lt;code&gt;MultiError.filter()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.MultiError.catch&quot;&gt;&lt;code&gt;MultiError.catch()&lt;/code&gt;&lt;/a&gt; also perform implicit exception chaining &amp;ndash; if you return a new exception object, then the new object&amp;rsquo;s &lt;code&gt;__context__&lt;/code&gt; attribute will automatically be set to the original exception.</source>
          <target state="translated">위의 예에서 &lt;code&gt;__cause__&lt;/code&gt; 를 명시 적 컨텍스트 체인 형태로 설정 했습니다 . &lt;a href=&quot;#trio.MultiError.filter&quot;&gt; &lt;code&gt;MultiError.filter()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.MultiError.catch&quot;&gt; &lt;code&gt;MultiError.catch()&lt;/code&gt; &lt;/a&gt; 도 암시 적 예외 체인을 수행합니다. 새 예외 개체를 반환하면 새 개체의 &lt;code&gt;__context__&lt;/code&gt; 특성이 자동으로 원래 예외로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d6ba9aa5681eb07f3f85aaca6cead6a6a75b07e2" translate="yes" xml:space="preserve">
          <source>In the previous section you learned how to use virtual in-memory streams to test protocols that are written against Trio&amp;rsquo;s &lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; abstraction. But what if you have more complicated networking code &amp;ndash; the kind of code that makes connections to multiple hosts, or opens a listening socket, or sends UDP packets?</source>
          <target state="translated">이전 섹션에서는 가상 인 메모리 스트림을 사용하여 Trio에 대해 작성된 프로토콜을 테스트하는 방법을 배웠습니다. &lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 추상화. 그러나 더 복잡한 네트워킹 코드가 있다면 여러 호스트에 연결하거나 청취 소켓을 열거 나 UDP 패킷을 보내는 코드와 같은 것입니까?</target>
        </trans-unit>
        <trans-unit id="a0095c623d0110d9746feea443a0e6da70cddc6c" translate="yes" xml:space="preserve">
          <source>In the simplest case, you can apply a timeout to a block of code:</source>
          <target state="translated">가장 간단한 경우 코드 블록에 시간 초과를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eff100c80ba5e97057de30f32a18adbad5a88b36" translate="yes" xml:space="preserve">
          <source>In this code, the outer scope will expire after 5 seconds, causing the &lt;a href=&quot;#trio.sleep&quot;&gt;&lt;code&gt;sleep()&lt;/code&gt;&lt;/a&gt; call to return early with a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception. Then this exception will propagate through the &lt;code&gt;with
move_on_after(10)&lt;/code&gt; line until it&amp;rsquo;s caught by the &lt;code&gt;with
move_on_after(5)&lt;/code&gt; context manager. So this code will print:</source>
          <target state="translated">이 코드에서 외부 범위는 5 초 후에 만료되어 &lt;a href=&quot;#trio.sleep&quot;&gt; &lt;code&gt;sleep()&lt;/code&gt; &lt;/a&gt; 호출이 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외 와 함께 일찍 반환 됩니다. 그런 다음이 예외는 &lt;code&gt;with move_on_after(5)&lt;/code&gt; 컨텍스트 관리자에 의해 포착 될 때까지 &lt;code&gt;with move_on_after(10)&lt;/code&gt; 행을 통해 전파됩니다 . 따라서이 코드는 다음과 같이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="3fd39030cf0f9d49c7b4882dafc1867fcf325030" translate="yes" xml:space="preserve">
          <source>In this log, it&amp;rsquo;s hard to know which lines came from which request. (Did the request that started first also finish first, or not?) One way to solve this is to assign each request a unique identifier, and then include this identifier in each log message:</source>
          <target state="translated">이 로그에서 어떤 라인이 어떤 요청에서 왔는지 알기가 어렵습니다. (먼저 시작된 요청도 먼저 완료 되었습니까, 그렇지 않습니까?)이를 해결하는 한 가지 방법은 각 요청에 고유 한 식별자를 할당 한 다음이 식별자를 각 로그 메시지에 포함시키는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6c5f57d6f1f293c43f3e60c7da9a475c532f3702" translate="yes" xml:space="preserve">
          <source>Increment the semaphore value, possibly waking a task blocked in &lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">세마포어 값을 늘리면 &lt;a href=&quot;#trio.Semaphore.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 에서 차단 된 작업을 깨울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="5e2d7833039dc978e6eb0d1055910e03a86a4609" translate="yes" xml:space="preserve">
          <source>Indices and tables</source>
          <target state="translated">지표와 표</target>
        </trans-unit>
        <trans-unit id="039860d992ee7e77987abc3b4a132dfd8deb034e" translate="yes" xml:space="preserve">
          <source>Inherits from&amp;hellip;</source>
          <target state="translated">...에서 상속</target>
        </trans-unit>
        <trans-unit id="a760a6a6a56453764562801ae1f6e4d17df6981e" translate="yes" xml:space="preserve">
          <source>Inside Trio, we&amp;rsquo;re very picky about this, because Trio is the foundation of the whole system so we think it&amp;rsquo;s worth the extra effort to make things extra predictable. It&amp;rsquo;s up to you how picky you want to be in your code. To give you a more realistic example of what this kind of issue looks like in real life, consider this function:</source>
          <target state="translated">Trio는 전체 시스템의 기초이므로 Trio 내에서 매우 까다 롭습니다. 따라서 일을 더 예측 가능하게 만드는 추가 노력이 필요하다고 생각합니다. 코드에서 얼마나 까다롭기를 원하는지는 당신에게 달려 있습니다. 실생활에서 이런 종류의 문제가 어떻게 생겼는지에 대한보다 현실적인 예를 제공하려면 다음 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="4383f9af14e2a6238f0ca630f4abb63f780fec7f" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;with&lt;/code&gt; block, a cancellation of &lt;code&gt;cancel_scope&lt;/code&gt; (via a call to its &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt;&lt;code&gt;cancel()&lt;/code&gt;&lt;/a&gt; method or via the expiry of its &lt;a href=&quot;#trio.CancelScope.deadline&quot;&gt;&lt;code&gt;deadline&lt;/code&gt;&lt;/a&gt;) will immediately interrupt the &lt;code&gt;long_running_operation()&lt;/code&gt; by raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; at its next &lt;a href=&quot;#checkpoints&quot;&gt;checkpoint&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 블록 내에서 &lt;code&gt;cancel_scope&lt;/code&gt; 를 &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt; &lt;code&gt;cancel()&lt;/code&gt; &lt;/a&gt; 메소드 호출 또는 &lt;a href=&quot;#trio.CancelScope.deadline&quot;&gt; &lt;code&gt;deadline&lt;/code&gt; &lt;/a&gt; 만료를 통해 &lt;code&gt;long_running_operation()&lt;/code&gt; 다음에 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 를 높여 long_running_operation () 을 즉시 중단합니다.&lt;a href=&quot;#checkpoints&quot;&gt; 검사 점&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc578a93a7ae18b3336261ddcddb492f729be12e" translate="yes" xml:space="preserve">
          <source>Install: &lt;code&gt;python3 -m pip install -U trio&lt;/code&gt; (or on Windows, maybe &lt;code&gt;py -3 -m pip install -U trio&lt;/code&gt;). No compiler needed.</source>
          <target state="translated">설치 : &lt;code&gt;python3 -m pip install -U trio&lt;/code&gt; (또는 Windows의 경우 &lt;code&gt;py -3 -m pip install -U trio&lt;/code&gt; ). 컴파일러가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2b8599d5e978753d93f75d58a522579079b5ed94" translate="yes" xml:space="preserve">
          <source>Instances of this class implement a &lt;code&gt;__call__&lt;/code&gt; method which returns an async context manager. The idea is that you pass a sequence number to &lt;code&gt;__call__&lt;/code&gt; to say where this block of code should go in the linear sequence. Block 0 starts immediately, and then block N doesn&amp;rsquo;t start until block N-1 has finished.</source>
          <target state="translated">이 클래스의 인스턴스 는 비동기 컨텍스트 관리자를 반환하는 &lt;code&gt;__call__&lt;/code&gt; 메서드를 구현합니다 . 아이디어는 시퀀스 번호를 &lt;code&gt;__call__&lt;/code&gt; 에 전달하는 것입니다. 에 하여이 코드 블록이 선형 시퀀스에서 어디로 가야하는지 말합니다. 블록 0은 즉시 시작된 다음 블록 N-1이 완료 될 때까지 블록 N이 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ec5b66be254478fa22108fac8f5d2812e01372a" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;ssl.SSLContext.wrap_socket()&lt;/code&gt;&lt;/a&gt;, you create a &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;ssl.SSLContext.wrap_socket()&lt;/code&gt; &lt;/a&gt; 을 사용하는 대신 SSLStream 을 작성하십시오 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="627fcf03843dc8a8605eb47152a8672db7094c61" translate="yes" xml:space="preserve">
          <source>Instrument API</source>
          <target state="translated">기기 API</target>
        </trans-unit>
        <trans-unit id="05dc85f2b3ab4754451d1f9965930cf9da6a45a9" translate="yes" xml:space="preserve">
          <source>Instruments don&amp;rsquo;t have to inherit from this abstract base class, and all of these methods are optional. This class serves mostly as documentation.</source>
          <target state="translated">인스트루먼트는이 추상 기본 클래스에서 상속 할 필요가 없으며 이러한 모든 메소드는 선택 사항입니다. 이 클래스는 주로 문서화 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="eca9838aabbb78d1b5e3acdb2dd4e57649569498" translate="yes" xml:space="preserve">
          <source>Inter-task ordering</source>
          <target state="translated">작업 간 순서</target>
        </trans-unit>
        <trans-unit id="636ae634805f18ba2489e4cf0305b910ad6e1ec2" translate="yes" xml:space="preserve">
          <source>Interacting with a process as it runs</source>
          <target state="translated">프로세스가 실행될 때 상호 작용</target>
        </trans-unit>
        <trans-unit id="8d73f8d3b26a1a856cc0af59962f16a7a7926a99" translate="yes" xml:space="preserve">
          <source>Internally, Python&amp;rsquo;s async/await syntax is built around the idea of &amp;ldquo;coroutine objects&amp;rdquo; and &amp;ldquo;coroutine runners&amp;rdquo;. A coroutine object represents the state of an async callstack. But by itself, this is just a static object that sits there. If you want it to do anything, you need a coroutine runner to push it forward. Every Trio task has an associated coroutine object (see &lt;a href=&quot;#trio.hazmat.Task.coro&quot;&gt;&lt;code&gt;Task.coro&lt;/code&gt;&lt;/a&gt;), and the Trio scheduler acts as their coroutine runner.</source>
          <target state="translated">내부적으로 파이썬의 비동기 / 대기 구문은 &quot;코 루틴 객체&quot;와 &quot;코 루틴 러너&quot;라는 아이디어를 중심으로 구축되었습니다. 코 루틴 객체는 비동기 호출 스택의 상태를 나타냅니다. 그러나 그 자체로, 이것은 단지 정적 객체입니다. 무언가를 원한다면 코 루틴 러너가 필요합니다. 모든 Trio 작업에는 관련 코 루틴 개체가 있습니다 ( &lt;a href=&quot;#trio.hazmat.Task.coro&quot;&gt; &lt;code&gt;Task.coro&lt;/code&gt; &lt;/a&gt; 참조) . ) Trio 스케줄러는 해당 코 루틴 러너 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="7756a3a1796cbde8bc41ba910ea845bb3d881278" translate="yes" xml:space="preserve">
          <source>Internally, Python&amp;rsquo;s async/await syntax is built around the idea of &amp;ldquo;coroutine objects&amp;rdquo; and &amp;ldquo;coroutine runners&amp;rdquo;. A coroutine object represents the state of an async callstack. But by itself, this is just a static object that sits there. If you want it to do anything, you need a coroutine runner to push it forward. Every Trio task has an associated coroutine object (see &lt;a href=&quot;#trio.lowlevel.Task.coro&quot;&gt;&lt;code&gt;Task.coro&lt;/code&gt;&lt;/a&gt;), and the Trio scheduler acts as their coroutine runner.</source>
          <target state="translated">내부적으로 Python의 async / await 구문은 &quot;코 루틴 객체&quot;및 &quot;코 루틴 러너&quot;라는 아이디어를 기반으로 구축되었습니다. 코 루틴 객체는 비동기 콜 스택의 상태를 나타냅니다. 그러나 그 자체로는 거기에있는 정적 객체 일뿐입니다. 무엇이든하고 싶다면 코 루틴 러너가 필요합니다. 모든 Trio 작업에는 관련 코 루틴 객체가 있으며 ( &lt;a href=&quot;#trio.lowlevel.Task.coro&quot;&gt; &lt;code&gt;Task.coro&lt;/code&gt; &lt;/a&gt; 참조 ) Trio 스케줄러는 코 루틴 실행기 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="211f3ecde809054095962b782038f30e2565b4f3" translate="yes" xml:space="preserve">
          <source>Internally, this class is implemented using an instance of &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt;&lt;code&gt;ssl.SSLObject&lt;/code&gt;&lt;/a&gt;, and all of &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s methods and attributes are re-exported as methods and attributes on this class. However, there is one difference: &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt; has several methods that return information about the encrypted connection, like &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket.cipher&quot;&gt;&lt;code&gt;cipher()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket.selected_alpn_protocol&quot;&gt;&lt;code&gt;selected_alpn_protocol()&lt;/code&gt;&lt;/a&gt;. If you call them before the handshake, when they can&amp;rsquo;t possibly return useful data, then &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt;&lt;code&gt;ssl.SSLObject&lt;/code&gt;&lt;/a&gt; returns None, but &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;trio.SSLStream&lt;/code&gt;&lt;/a&gt; raises &lt;a href=&quot;#trio.NeedHandshakeError&quot;&gt;&lt;code&gt;NeedHandshakeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">내부적으로이 클래스는 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt; &lt;code&gt;ssl.SSLObject&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용하여 구현 되며 모든 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; &lt;/a&gt; 의 메소드 및 속성은이 클래스의 메소드 및 속성으로 다시 내보내집니다. 그러나 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; &lt;/a&gt; 에는 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket.cipher&quot;&gt; &lt;code&gt;cipher()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLSocket.selected_alpn_protocol&quot;&gt; &lt;code&gt;selected_alpn_protocol()&lt;/code&gt; &lt;/a&gt; 과 같이 암호화 된 연결에 대한 정보를 리턴하는 몇 가지 메소드가 있습니다. 핸드 셰이크 전에 호출하면 유용한 데이터를 반환 할 수 없을 때 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt; &lt;code&gt;ssl.SSLObject&lt;/code&gt; &lt;/a&gt; 는 None을 반환하지만 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;trio.SSLStream&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#trio.NeedHandshakeError&quot;&gt; &lt;code&gt;NeedHandshakeError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aad10a74de784eb77b7994e8e3df391e71c75b48" translate="yes" xml:space="preserve">
          <source>Introduce a schedule point, but not a cancel point.</source>
          <target state="translated">취소 지점이 아닌 스케줄 지점을 소개하십시오.</target>
        </trans-unit>
        <trans-unit id="3a39def0776ba74eafe8baafe78545be2b62c2bf" translate="yes" xml:space="preserve">
          <source>Introspecting and extending Trio with &lt;code&gt;trio.hazmat&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;trio.hazmat&lt;/code&gt; 로 Trio 검사 및 확장</target>
        </trans-unit>
        <trans-unit id="660fadaff1685ecc9f0cccf792743c18bcd133a1" translate="yes" xml:space="preserve">
          <source>Introspecting and extending Trio with &lt;code&gt;trio.lowlevel&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;trio.lowlevel&lt;/code&gt; 로 Trio를 살펴보고 확장하기</target>
        </trans-unit>
        <trans-unit id="f875ac8ad79c6803f9483ecd07dc8b2c5c1bf08d" translate="yes" xml:space="preserve">
          <source>Introspecting and extending Trio with trio.hazmat</source>
          <target state="translated">trio.hazmat로 Trio 검사 및 확장</target>
        </trans-unit>
        <trans-unit id="623b9528d10b1f23a96b014308777aec4a61481c" translate="yes" xml:space="preserve">
          <source>Is this potential extra thread a major problem? Maybe not, but it&amp;rsquo;s easy enough to avoid, and we figure that if the user is trying to limit how many threads they&amp;rsquo;re using then it&amp;rsquo;s polite to respect that.</source>
          <target state="translated">이 잠재적 인 추가 스레드가 주요 문제입니까? 그렇지 않을 수도 있지만 피하는 것이 충분히 쉬우 며 사용자가 사용중인 스레드 수를 제한하려는 경우이를 존중하는 것이 정중하다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="0b7ac58e93ecd2e82e060a85238c964fc4eccff9" translate="yes" xml:space="preserve">
          <source>Issue a &lt;a href=&quot;reference-core#checkpoints&quot;&gt;checkpoint&lt;/a&gt; if the calling context has been cancelled.</source>
          <target state="translated">호출 컨텍스트가 취소 된 경우 &lt;a href=&quot;reference-core#checkpoints&quot;&gt;체크 포인트를&lt;/a&gt; 발행하십시오 .</target>
        </trans-unit>
        <trans-unit id="887b272faffff6c3a2885420536e51339dbc8a6a" translate="yes" xml:space="preserve">
          <source>It does not block on entry; on exit it blocks until all child tasks have exited.</source>
          <target state="translated">진입시 차단되지 않습니다. 종료시 모든 하위 작업이 종료 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="41ece27b44dd2fb5b5e3df97582a4f71e506eca1" translate="yes" xml:space="preserve">
          <source>It has no public constructor; instead, see &lt;a href=&quot;#trio.hazmat.current_trio_token&quot;&gt;&lt;code&gt;current_trio_token()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">공개 생성자가 없습니다. 대신 &lt;a href=&quot;#trio.hazmat.current_trio_token&quot;&gt; &lt;code&gt;current_trio_token()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cc472179c35fb5022626cb301287d06f859edff" translate="yes" xml:space="preserve">
          <source>It has no public constructor; instead, see &lt;a href=&quot;#trio.lowlevel.current_trio_token&quot;&gt;&lt;code&gt;current_trio_token()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">공용 생성자가 없습니다. 대신 &lt;a href=&quot;#trio.lowlevel.current_trio_token&quot;&gt; &lt;code&gt;current_trio_token()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5602afbbafb1cd7c74f2f4a08755329083f8cde" translate="yes" xml:space="preserve">
          <source>It is possible to combine event loops, but the standard approaches all have significant downsides:</source>
          <target state="translated">이벤트 루프를 결합 할 수 있지만 표준 접근 방식에는 모두 상당한 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f786bca4771efc6df4bc0e216b00e4d45a7ca4d" translate="yes" xml:space="preserve">
          <source>It is safe to call this function simultaneously from multiple threads.</source>
          <target state="translated">여러 스레드에서 동시에이 함수를 호출하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="447673e9dd692338c50de7bb68089f9e3af415fe" translate="yes" xml:space="preserve">
          <source>It lets the kernel pick a random open port, so your test suite doesn&amp;rsquo;t depend on any particular port being open.</source>
          <target state="translated">커널이 임의의 열린 포트를 선택할 수 있으므로 테스트 스위트는 열려있는 특정 포트에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="633fa68ba8c3421538913d615267233a7c6773ae" translate="yes" xml:space="preserve">
          <source>It lets you re-enter the Trio run loop from external threads or signal handlers. This is the low-level primitive that &lt;a href=&quot;reference-core#module-trio.to_thread&quot;&gt;&lt;code&gt;trio.to_thread()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reference-core#module-trio.from_thread&quot;&gt;&lt;code&gt;trio.from_thread&lt;/code&gt;&lt;/a&gt; use to communicate with worker threads, that &lt;a href=&quot;reference-io#trio.open_signal_receiver&quot;&gt;&lt;code&gt;trio.open_signal_receiver&lt;/code&gt;&lt;/a&gt; uses to receive notifications about signals, and so forth.</source>
          <target state="translated">외부 스레드 또는 신호 처리기에서 Trio 실행 루프를 다시 입력 할 수 있습니다. 이것은 &lt;a href=&quot;reference-core#module-trio.to_thread&quot;&gt; &lt;code&gt;trio.to_thread()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;reference-core#module-trio.from_thread&quot;&gt; &lt;code&gt;trio.from_thread&lt;/code&gt; &lt;/a&gt; 가 작업자 스레드와 통신하는 &lt;a href=&quot;reference-io#trio.open_signal_receiver&quot;&gt; &lt;code&gt;trio.open_signal_receiver&lt;/code&gt; &lt;/a&gt; 사용 하고 trio.open_signal_receiver 가 신호 등에 대한 알림을 수신 하는 데 사용 하는 하위 레벨 기본 요소입니다 .</target>
        </trans-unit>
        <trans-unit id="04dd56709d7215046123e0d08943911499806dfe" translate="yes" xml:space="preserve">
          <source>It may still be some time before it actually runs, if there are other runnable tasks ahead of it.</source>
          <target state="translated">실행 가능한 다른 태스크가있는 경우 실제로 실행되기까지 어느 정도 시간이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdf4f355598208394d057b6e9e1b696ccd36f2db" translate="yes" xml:space="preserve">
          <source>It should attempt to clean up any state associated with this call, and in particular, arrange that &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; will &lt;em&gt;not&lt;/em&gt; be called later. If (and only if!) it is successful, then it should return &lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt;&lt;code&gt;Abort.SUCCEEDED&lt;/code&gt;&lt;/a&gt;, in which case the task will automatically be rescheduled with an appropriate &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; error.</source>
          <target state="translated">이 호출과 관련된 상태를 정리하고 특히 &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; 이 나중에 호출 &lt;em&gt;되지 않도록&lt;/em&gt; 정렬해야합니다 . 성공한 경우 (만!) 성공한 경우 &lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt; &lt;code&gt;Abort.SUCCEEDED&lt;/code&gt; &lt;/a&gt; 를 반환해야합니다 .이 경우 작업이 적절한 &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 오류 와 함께 자동으로 다시 예약됩니다 .</target>
        </trans-unit>
        <trans-unit id="89e3c3b45c22fc5d8ced07badd67280a0f9f9f1a" translate="yes" xml:space="preserve">
          <source>It should attempt to clean up any state associated with this call, and in particular, arrange that &lt;a href=&quot;#trio.lowlevel.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; will &lt;em&gt;not&lt;/em&gt; be called later. If (and only if!) it is successful, then it should return &lt;a href=&quot;#trio.lowlevel.Abort.SUCCEEDED&quot;&gt;&lt;code&gt;Abort.SUCCEEDED&lt;/code&gt;&lt;/a&gt;, in which case the task will automatically be rescheduled with an appropriate &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; error.</source>
          <target state="translated">이 호출과 관련된 모든 상태를 정리하려고 시도해야하며 특히 &lt;a href=&quot;#trio.lowlevel.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; 이 나중에 호출 &lt;em&gt;되지 않도록 &lt;/em&gt;조정 해야합니다 . 성공하면 &lt;a href=&quot;#trio.lowlevel.Abort.SUCCEEDED&quot;&gt; &lt;code&gt;Abort.SUCCEEDED&lt;/code&gt; &lt;/a&gt; 를 반환해야합니다 .이 경우 작업은 적절한 &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 오류로 자동으로 다시 예약됩니다 .</target>
        </trans-unit>
        <trans-unit id="84a6d66c512d9418dc7fbafea6c57006dc4ab36a" translate="yes" xml:space="preserve">
          <source>It sometimes happens that you want to connect to an HTTPS server, but you have to go through a web proxy&amp;hellip; and the proxy also uses HTTPS. So you end up having to do &lt;a href=&quot;https://daniel.haxx.se/blog/2016/11/26/https-proxy-with-curl/&quot;&gt;SSL-on-top-of-SSL&lt;/a&gt;. In Trio this is trivial &amp;ndash; just wrap your first &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; in a second &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">때로는 HTTPS 서버에 연결하려고하지만 웹 프록시를 거쳐야하며 프록시도 HTTPS를 사용합니다. 따라서 &lt;a href=&quot;https://daniel.haxx.se/blog/2016/11/26/https-proxy-with-curl/&quot;&gt;SSL에서 SSL&lt;/a&gt; 을 수행해야 합니다 . Trio에서는이 작업이 간단합니다. 첫 번째 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 을 두 번째 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; 으로 감싸면됩니다.&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="15180ba1a972d7f41d05f1bcb1b11159fd06fdaf" translate="yes" xml:space="preserve">
          <source>It uses the Listener object to find out which port was picked, so it can connect to the right place.</source>
          <target state="translated">리스너 객체를 사용하여 어떤 포트를 선택했는지 확인하여 올바른 위치에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f96f61f491e94e6eed579393e73c5c30394e987" translate="yes" xml:space="preserve">
          <source>It waits for the server to be accepting connections on that port before &lt;code&gt;start&lt;/code&gt; returns, so there&amp;rsquo;s no race condition where the incoming connection arrives before the server is ready.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 하기 전에 서버가 해당 포트에서 연결을 수락하기를 기다립니다 . 따라서 서버가 준비되기 전에 들어오는 연결이 도착하는 경쟁 조건이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e4aef67556653c2e10c9ddc35f43ebcf2681e23" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a point where Trio checks for cancellation. For example, if the code that called your function set a timeout, and that timeout has expired, then the next time your function executes a checkpoint Trio will raise a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception. See &lt;a href=&quot;#cancellation&quot;&gt;Cancellation and timeouts&lt;/a&gt; below for more details.</source>
          <target state="translated">Trio가 취소를 확인하는 지점입니다. 예를 들어, 함수를 호출 한 코드가 시간 초과를 설정하고 해당 시간 초과가 만료 된 경우 다음에 함수가 검사 점을 실행할 때 Trio는 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다. 자세한 내용은 아래 &lt;a href=&quot;#cancellation&quot;&gt;취소 및 시간 초과&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="41d67c32934a3fdf70e308bc3ec0237ebb3a5908" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a point where the Trio scheduler checks its scheduling policy to see if it&amp;rsquo;s a good time to switch to another task, and potentially does so. (Currently, this check is very simple: the scheduler always switches at every checkpoint. But &lt;a href=&quot;https://github.com/python-trio/trio/issues/32&quot;&gt;this might change in the future&lt;/a&gt;.)</source>
          <target state="translated">이제는 Trio 스케줄러가 예약 정책을 확인하여 다른 작업으로 전환하기에 적절한시기인지 확인해야합니다. (현재이 검사는 매우 간단합니다. 스케줄러는 항상 모든 검사 점에서 전환됩니다. 그러나 &lt;a href=&quot;https://github.com/python-trio/trio/issues/32&quot;&gt;이것은 향후 변경 될 수 있습니다&lt;/a&gt; . .)</target>
        </trans-unit>
        <trans-unit id="9feb70da8199f87a0468305b1613eb72121082b8" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also important in any long-running code to make sure that you regularly check for cancellation, because otherwise timeouts won&amp;rsquo;t work! This happens implicitly every time you call a cancellable operation; see &lt;a href=&quot;#cancellable-primitives&quot;&gt;below&lt;/a&gt; for details. If you have a task that has to do a lot of work without any I/O, then you can use &lt;code&gt;await sleep(0)&lt;/code&gt; to insert an explicit cancel+schedule point.</source>
          <target state="translated">또한 장기 실행 코드에서는 시간 초과가 작동하지 않기 때문에 정기적으로 취소를 확인하는 것이 중요합니다! 취소 할 수있는 작업을 호출 할 때마다 암시 적으로 발생합니다. 자세한 내용은 &lt;a href=&quot;#cancellable-primitives&quot;&gt;아래&lt;/a&gt; 를 참조하십시오. I / O없이 많은 작업을 수행해야하는 작업이있는 경우 &lt;code&gt;await sleep(0)&lt;/code&gt; 을 사용하여 명시적인 취소 + 일정 지점을 삽입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3158edb2cb07aefc306e4b70006fb6942ffbee20" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible to check what the current effective deadline is, which is sometimes useful:</source>
          <target state="translated">현재 유효 마감일이 무엇인지 확인할 수 있으며 때로는 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f8ec7275fa438859adf89057ae4a7210489a9577" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible to do them in a different order if that&amp;rsquo;s more convenient, &lt;em&gt;but only if&lt;/em&gt; you make sure not to have any checkpoints in between the steps. This way they all happen in a single atomic step, so other tasks won&amp;rsquo;t be able to tell what order they happened in anyway.</source>
          <target state="translated">더 편리한 경우 다른 순서로 수행 할 수도 &lt;em&gt;있지만&lt;/em&gt; 단계 사이에 체크 포인트가 없는지 확인하는 &lt;em&gt;경우에만 가능&lt;/em&gt; 합니다. 이런 식으로 그들은 모두 단일 원자 단계에서 발생하므로 다른 작업은 어쨌든 어떤 순서로 일어 났는지 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="028b2f8f16c5b9e63ae61fb6e6dada307141004f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s even possible for a fixed-size policy to cause unexpected &lt;a href=&quot;https://en.wikipedia.org/wiki/Deadlock&quot;&gt;deadlocks&lt;/a&gt;. Imagine a situation where we have two different types of blocking jobs that you want to run in the thread pool, type A and type B. Type A is pretty simple: it just runs and completes pretty quickly. But type B is more complicated: it has to stop in the middle and wait for some other work to finish, and that other work includes running a type A job. Now, suppose you submit N jobs of type B to the pool. They all start running, and then eventually end up submitting one or more jobs of type A. But since every thread in our pool is already busy, the type A jobs don&amp;rsquo;t actually start running &amp;ndash; they just sit in a queue waiting for the type B jobs to finish. But the type B jobs will never finish, because they&amp;rsquo;re waiting for the type A jobs. Our system has deadlocked. The ideal solution to this problem is to avoid having type B jobs in the first place &amp;ndash; generally it&amp;rsquo;s better to keep complex synchronization logic in the main Trio thread. But if you can&amp;rsquo;t do that, then you need a custom thread allocation policy that tracks separate limits for different types of jobs, and make it impossible for type B jobs to fill up all the slots that type A jobs need to run.</source>
          <target state="translated">고정 크기 정책으로 인해 예기치 않은 결과가 발생할 수도 있습니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Deadlock&quot;&gt; 교착 상태&lt;/a&gt;. 스레드 풀에서 실행하려는 두 가지 유형의 블로킹 작업이 유형 A와 유형 B 인 상황을 상상해보십시오. 유형 A는 매우 간단합니다. 실행하고 아주 빨리 완료됩니다. 그러나 유형 B는 더 복잡합니다. 중간에서 중지하고 다른 작업이 완료 될 때까지 기다려야하며 다른 작업에는 유형 A 작업 실행이 포함됩니다. 이제 B 유형의 N 개 작업을 풀에 제출한다고 가정하십시오. 이들은 모두 실행을 시작한 다음 결국 하나 이상의 유형 A의 작업을 제출하게됩니다. 그러나 풀의 모든 스레드가 이미 사용 중이므로 유형 A 작업은 실제로 실행되지 않습니다. 대기중인 대기열에 대기하기 만합니다. 완료 할 B 유형 작업. 그러나 유형 B 작업은 유형 A 작업을 기다리고 있기 때문에 완료되지 않습니다. 우리 시스템이 교착 상태에 빠졌습니다.이 문제에 대한 이상적인 솔루션은 처음에 유형 B 작업을 피하는 것입니다. 일반적으로 기본 Trio 스레드에서 복잡한 동기화 논리를 유지하는 것이 좋습니다. 그러나이를 수행 할 수없는 경우 여러 유형의 작업에 대한 별도의 한계를 추적하고 유형 B 작업이 유형 A 작업이 실행해야하는 모든 슬롯을 채우는 것을 불가능하게하는 사용자 정의 스레드 할당 정책이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="afebfc9278bc2aa8347dcf570a97d23e86487e4e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s main use is to represent the situation when multiple child tasks all raise errors &amp;ldquo;in parallel&amp;rdquo;.</source>
          <target state="translated">여러 하위 작업이 모두 &quot;병렬&quot;로 오류를 발생시키는 상황을 나타내는 것이 주된 용도입니다.</target>
        </trans-unit>
        <trans-unit id="26f9b89089d0869162c76d5126491f1513bd67d7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to pass a nursery object into another task, which allows that task to start new child tasks in the first task&amp;rsquo;s nursery.</source>
          <target state="translated">보육원 개체를 다른 작업에 전달하면 해당 작업이 첫 번째 작업 보육원에서 새 자식 작업을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfb0a395eef8d10797750c4bc8c7869ddcde8e1a" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s surprisingly easy to think that one&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; protection is enabled when it isn&amp;rsquo;t, or vice-versa. This function tells you what Trio thinks of the matter, which makes it useful for &lt;code&gt;assert&lt;/code&gt;s and unit tests.</source>
          <target state="translated">놀랍게도 사용자의 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 보호가 활성화되어 있지 않은 경우 또는 그 반대로 할 수 있다고 생각하기 쉽습니다 . 이 기능은 Trio가 해당 사안에 대해 어떻게 생각하는지 알려주므로, &lt;code&gt;assert&lt;/code&gt; 및 단위 테스트에 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="0d15b7a76653351f46b83405a4b54f98735b9042" translate="yes" xml:space="preserve">
          <source>Its public members are mostly useful for introspection and debugging:</source>
          <target state="translated">공개 멤버는 주로 검사 및 디버깅에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="545be0d53d794aaf39339209b55c20d210fc586f" translate="yes" xml:space="preserve">
          <source>Joining the team</source>
          <target state="translated">팀에 합류</target>
        </trans-unit>
        <trans-unit id="7673cd582fda3b7f7b13b3b20adaee67d3277fe9" translate="yes" xml:space="preserve">
          <source>Just make sure that you don&amp;rsquo;t write:</source>
          <target state="translated">다음과 같이 쓰지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a5d5b5c6bfe7553575cde5418f08d509d5536896" translate="yes" xml:space="preserve">
          <source>Kqueue-specific API</source>
          <target state="translated">큐에 특정 API</target>
        </trans-unit>
        <trans-unit id="48f4219320b50cd46d4f526790d7d6b4d191605a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s walk through what you need to do to integrate Trio&amp;rsquo;s guest mode with your favorite event loop. Treat this section like a checklist.</source>
          <target state="translated">Trio의 게스트 모드를 좋아하는 이벤트 루프와 통합하기 위해 수행해야하는 작업을 살펴 ​​보도록하겠습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 이 섹션을 체크리스트처럼 취급하십시오.</target>
        </trans-unit>
        <trans-unit id="d9fa2d2f6148e9b5ccb844620248db405f8fae9c" translate="yes" xml:space="preserve">
          <source>License: MIT or Apache 2, your choice</source>
          <target state="translated">라이센스 : MIT 또는 Apache 2, 원하는 선택</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="1c6fb693fc4f098795743e41d419b3149fbcfbfb" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#trio.Nursery.start_soon&quot;&gt;&lt;code&gt;start_soon()&lt;/code&gt;&lt;/a&gt;, but blocks until the new task has finished initializing itself, and optionally returns some information from it.</source>
          <target state="translated">&lt;a href=&quot;#trio.Nursery.start_soon&quot;&gt; &lt;code&gt;start_soon()&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 새 작업이 자체 초기화를 완료 할 때까지 차단하고 선택적으로 일부 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5d6aaff931158c5ba7e26961a9b89a7d40bfe5ba" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.chmod&quot;&gt;&lt;code&gt;chmod()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">같이 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.chmod&quot;&gt; &lt;code&gt;chmod()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="3ba838f0e35e06c2fb726a07ae29793e339bfe10" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.cwd&quot;&gt;&lt;code&gt;cwd()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.cwd&quot;&gt; &lt;code&gt;cwd()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="8c5a9d23abb5f6ad444cc24b04b27fe9e10a9442" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.exists&quot;&gt;&lt;code&gt;exists()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">exist &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.exists&quot;&gt; &lt;code&gt;exists()&lt;/code&gt; &lt;/a&gt; 와 비슷하지만 비동기입니다.</target>
        </trans-unit>
        <trans-unit id="8029effe0016a68af627078e548169d8a3b664b6" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.expanduser&quot;&gt;&lt;code&gt;expanduser()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">같이 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.expanduser&quot;&gt; &lt;code&gt;expanduser()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="b0ea04f9f1e4f38a25764ce18a995446b4f28854" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.glob&quot;&gt;&lt;code&gt;glob()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.glob&quot;&gt; &lt;code&gt;glob()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="6bd3ff84b863acbc6c9cce99ac69c33bd2909786" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.group&quot;&gt;&lt;code&gt;group()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.group&quot;&gt; &lt;code&gt;group()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="3c7cc416a3a8bb593ea6e8e88d3e887928347553" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.home&quot;&gt;&lt;code&gt;home()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.home&quot;&gt; &lt;code&gt;home()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="728cd83a8211f6734ef960185330051b8c20ab07" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_block_device&quot;&gt;&lt;code&gt;is_block_device()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_block_device&quot;&gt; &lt;code&gt;is_block_device()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="8357198911fe8c7b4765505acc1d51e94d363fe8" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_char_device&quot;&gt;&lt;code&gt;is_char_device()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_char_device&quot;&gt; &lt;code&gt;is_char_device()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="ed5693661e601d1afa38f136a0d4a3de1c725a7c" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_dir&quot;&gt;&lt;code&gt;is_dir()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_dir&quot;&gt; &lt;code&gt;is_dir()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="6bf2ce402b5a06571ec3de8e0f0931b96a01a498" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_fifo&quot;&gt;&lt;code&gt;is_fifo()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_fifo&quot;&gt; &lt;code&gt;is_fifo()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="88810a7083f1ac5a369fdea2c965c22ad7623a35" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file&quot;&gt;&lt;code&gt;is_file()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file&quot;&gt; &lt;code&gt;is_file()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="239d027c684e33880e1c67856d3dbd8672010017" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_mount&quot;&gt;&lt;code&gt;is_mount()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_mount&quot;&gt; &lt;code&gt;is_mount()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="61d10cc589f2610067e2e12e0e6fb88489b0ada2" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_socket&quot;&gt;&lt;code&gt;is_socket()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_socket&quot;&gt; &lt;code&gt;is_socket()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="ea98fc1e541c2149ddd3990468d1ad6ebb4ac1b4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_symlink&quot;&gt;&lt;code&gt;is_symlink()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_symlink&quot;&gt; &lt;code&gt;is_symlink()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="8a36e3cfed8e29bbe795e9ccce0d0fbf0b367ad5" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.iterdir&quot;&gt;&lt;code&gt;pathlib.Path.iterdir()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.iterdir&quot;&gt; &lt;code&gt;pathlib.Path.iterdir()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="10fec790c4c6e2567f23d61565f736a38ac6732a" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.lchmod&quot;&gt;&lt;code&gt;lchmod()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.lchmod&quot;&gt; &lt;code&gt;lchmod()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="27baac762d9c7f298a4f06767b1d507901aed386" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.lstat&quot;&gt;&lt;code&gt;lstat()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.lstat&quot;&gt; &lt;code&gt;lstat()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="0bd8091a0b0ceaf877772076df583a166ddd961c" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir&quot;&gt;&lt;code&gt;mkdir()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir&quot;&gt; &lt;code&gt;mkdir()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="81ed714fc7a307ba54353248fdcbfcfa493b3ed0" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.owner&quot;&gt;&lt;code&gt;owner()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.owner&quot;&gt; &lt;code&gt;owner()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="9da40bbd79ff6bce0630d88aeb0d8aa86ff563c9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.read_bytes&quot;&gt;&lt;code&gt;read_bytes()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.read_bytes&quot;&gt; &lt;code&gt;read_bytes()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="05643660a056d15b3298760145d0de764a98bdc4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.read_text&quot;&gt;&lt;code&gt;read_text()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.read_text&quot;&gt; &lt;code&gt;read_text()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="f2ccca9c18dd36f4ae76b849609b73b1f637edf9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.rename&quot;&gt;&lt;code&gt;rename()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.rename&quot;&gt; &lt;code&gt;rename()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="76951f8bac108e58977f3a4e8acfa6286eb8d22d" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.replace&quot;&gt;&lt;code&gt;replace()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.replace&quot;&gt; &lt;code&gt;replace()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="c3055a464134a4216721f8a866ac651e4570f06f" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.resolve&quot;&gt;&lt;code&gt;resolve()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">같이 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.resolve&quot;&gt; &lt;code&gt;resolve()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="582d833e4f101ac47d1717f59890a75fb92e760c" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.rglob&quot;&gt;&lt;code&gt;rglob()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.rglob&quot;&gt; &lt;code&gt;rglob()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="fb2b385994122d22fd4d232559e18a11a60ac4e4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.rmdir&quot;&gt;&lt;code&gt;rmdir()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.rmdir&quot;&gt; &lt;code&gt;rmdir()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="9f63131435769ee3fb708892ef6a3216170a46f9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.samefile&quot;&gt;&lt;code&gt;samefile()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.samefile&quot;&gt; &lt;code&gt;samefile()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="aca6058c180917f2d39ac469babfe5a04db23516" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.stat&quot;&gt;&lt;code&gt;stat()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.stat&quot;&gt; &lt;code&gt;stat()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="7c17e79bf844528efb02f89a4dda1d3db03d70d8" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.symlink_to&quot;&gt;&lt;code&gt;symlink_to()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.symlink_to&quot;&gt; &lt;code&gt;symlink_to()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="f22e90e30bbe4e59bff5e37bbcb40e20951b2f52" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.touch&quot;&gt;&lt;code&gt;touch()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.touch&quot;&gt; &lt;code&gt;touch()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="58c2987df5b3af271a9c8db4100daec2f09bc978" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.unlink&quot;&gt;&lt;code&gt;unlink()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.unlink&quot;&gt; &lt;code&gt;unlink()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="80edc61fe623d63b6acb59ba26df15585ede97f1" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_bytes&quot;&gt;&lt;code&gt;write_bytes()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_bytes&quot;&gt; &lt;code&gt;write_bytes()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="1a4a32aa0a4740a573dfbedc612a5d244880ac5d" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_text&quot;&gt;&lt;code&gt;write_text()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_text&quot;&gt; &lt;code&gt;write_text()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="9d2e0e0cca76297df2e87075fa4119c9402e1264" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.fromfd&quot;&gt;&lt;code&gt;socket.fromfd()&lt;/code&gt;&lt;/a&gt;, but returns a Trio socket object.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.fromfd&quot;&gt; &lt;code&gt;socket.fromfd()&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 Trio 소켓 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="331a6322c874ec83d06c6d08fb611b5f4faa1156" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.fromshare&quot;&gt;&lt;code&gt;socket.fromshare()&lt;/code&gt;&lt;/a&gt;, but returns a Trio socket object.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.fromshare&quot;&gt; &lt;code&gt;socket.fromshare()&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 Trio 소켓 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e2dc4e28850f2e365df27694052bb1e0b1746a9c" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getprotobyname&quot;&gt;&lt;code&gt;socket.getprotobyname()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.getprotobyname&quot;&gt; &lt;code&gt;socket.getprotobyname()&lt;/code&gt; &lt;/a&gt; 하지만, 비동기.</target>
        </trans-unit>
        <trans-unit id="de36e1033225ba39f47cc4b92c54ebfc92f0e4ce" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socketpair&quot;&gt;&lt;code&gt;socket.socketpair()&lt;/code&gt;&lt;/a&gt;, but returns a pair of Trio socket objects.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socketpair&quot;&gt; &lt;code&gt;socket.socketpair()&lt;/code&gt; &lt;/a&gt; 하지만, 반환 트리오 소켓 객체의 쌍.</target>
        </trans-unit>
        <trans-unit id="61c8f4b41ffadae4dad59039c078152bc2597395" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt;, but if there&amp;rsquo;s nothing ready to receive, raises &lt;a href=&quot;#trio.WouldBlock&quot;&gt;&lt;code&gt;WouldBlock&lt;/code&gt;&lt;/a&gt; instead of blocking.</source>
          <target state="translated">등은 &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt; 있지만 수신 할 준비가 아무것도 존재하지 않는 경우는, 제기 &lt;a href=&quot;#trio.WouldBlock&quot;&gt; &lt;code&gt;WouldBlock&lt;/code&gt; 을&lt;/a&gt; 대신 차단.</target>
        </trans-unit>
        <trans-unit id="ec539be4b605bbd35ef9da29c0dc79d1cdf0bd6e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt;, but if the channel&amp;rsquo;s buffer is full, raises &lt;a href=&quot;#trio.WouldBlock&quot;&gt;&lt;code&gt;WouldBlock&lt;/code&gt;&lt;/a&gt; instead of blocking.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 채널의 버퍼가 가득 찬 경우, 그러나, 제기 &lt;a href=&quot;#trio.WouldBlock&quot;&gt; &lt;code&gt;WouldBlock&lt;/code&gt; 을&lt;/a&gt; 차단하는 대신.</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="243773033574d612f4454d84b3c941029d2df11a" translate="yes" xml:space="preserve">
          <source>Listen for incoming TCP connections, and for each one start a task running &lt;code&gt;handler(stream)&lt;/code&gt;.</source>
          <target state="translated">들어오는 TCP 연결을 수신하고 각 연결마다 &lt;code&gt;handler(stream)&lt;/code&gt; 실행 태스크를 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d6bf85b52b590445a244abd378949eb3d59be0a" translate="yes" xml:space="preserve">
          <source>Listen for incoming connections on &lt;code&gt;listeners&lt;/code&gt;, and for each one start a task running &lt;code&gt;handler(stream)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;listeners&lt;/code&gt; 에서 들어오는 연결을 수신 하고 각 연결 마다 &lt;code&gt;handler(stream)&lt;/code&gt; 실행 태스크를 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f93b003cac3bafe43f93f4a3ced9aa90bc77fce" translate="yes" xml:space="preserve">
          <source>Listeners don&amp;rsquo;t generally raise &lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt;&lt;code&gt;BrokenResourceError&lt;/code&gt;&lt;/a&gt;, because for listeners there is no general condition of &amp;ldquo;the network/remote peer broke the connection&amp;rdquo; that can be handled in a generic way, like there is for streams. Other errors &lt;em&gt;can&lt;/em&gt; occur and be raised from &lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/a&gt; &amp;ndash; for example, if you run out of file descriptors then you might get an &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; with its errno set to &lt;code&gt;EMFILE&lt;/code&gt;.</source>
          <target state="translated">리스너의 경우 일반적으로 스트림과 같이 일반적인 방식으로 처리 할 수있는 &quot;네트워크 / 원격 피어가 연결을 끊었습니다&quot;라는 일반적인 조건이 없기 때문에 리스너는 일반적으로 &lt;a href=&quot;reference-core#trio.BrokenResourceError&quot;&gt; &lt;code&gt;BrokenResourceError&lt;/code&gt; 를 발생&lt;/a&gt; 시키지 않습니다 . 다른 오류 &lt;em&gt;가&lt;/em&gt; 발생할 &lt;em&gt;수&lt;/em&gt; 있으며 &lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt; &lt;code&gt;accept()&lt;/code&gt; &lt;/a&gt; 에서 발생할 &lt;em&gt;수&lt;/em&gt; 있습니다. 예를 들어 파일 설명자가 부족하면 errno가 &lt;code&gt;EMFILE&lt;/code&gt; 로 설정된 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="3fbdd9c2573faeae1c0dfd16bc50c0374a0de2ca" translate="yes" xml:space="preserve">
          <source>Logs the error to the standard library logger &lt;code&gt;trio.serve_listeners&lt;/code&gt; (level = ERROR, with exception information included). By default this causes it to be printed to stderr.</source>
          <target state="translated">표준 라이브러리 로거 &lt;code&gt;trio.serve_listeners&lt;/code&gt; 에 오류를 기록합니다. (예외 정보가 포함 된 레벨 = ERROR). 기본적으로 이것은 stderr로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="97f4c6bc248313454e7e7ff078c667720978c27a" translate="yes" xml:space="preserve">
          <source>Look up a name given a numeric address.</source>
          <target state="translated">숫자로 된 이름을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="4abb92fa47a0d5605410443253231d75eb0f04a0" translate="yes" xml:space="preserve">
          <source>Look up a numeric address given a name.</source>
          <target state="translated">이름이 주어진 숫자 주소를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="1259ecea5b81acd627020537220f81aca7783275" translate="yes" xml:space="preserve">
          <source>Look up a protocol number by name. (Rarely used.)</source>
          <target state="translated">이름으로 프로토콜 번호를 찾으십시오. (드물게 사용되는.)</target>
        </trans-unit>
        <trans-unit id="0392a16047d2b6a75f0f5ee3bfcd028004b4120c" translate="yes" xml:space="preserve">
          <source>Looking at this, you might wonder how you can tell whether the inner block timed out &amp;ndash; perhaps you want to do something different, like try a fallback procedure or report a failure to our caller. To make this easier, &lt;a href=&quot;#trio.move_on_after&quot;&gt;&lt;code&gt;move_on_after()&lt;/code&gt;&lt;/a&gt;&amp;acute;s &lt;code&gt;__enter__&lt;/code&gt; function returns an object representing this cancel scope, which we can use to check whether this scope caught a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception:</source>
          <target state="translated">이를 살펴보면 내부 블록의 시간이 초과되었는지 알 수 있습니다. 대체 절차를 시도하거나 발신자에게 실패를보고하는 등 다른 방법을 원할 수도 있습니다. 이것을 더 쉽게하기 위해 &lt;a href=&quot;#trio.move_on_after&quot;&gt; &lt;code&gt;move_on_after()&lt;/code&gt; &lt;/a&gt; s &lt;code&gt;__enter__&lt;/code&gt; 함수는이 취소 범위를 나타내는 객체를 반환하는데,이 범위는이 범위가 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 잡았는지 여부를 확인하는 데 사용할 수 있습니다 예외를 .</target>
        </trans-unit>
        <trans-unit id="6ef282847417f9b8a3de2e592804abf1d9e73760" translate="yes" xml:space="preserve">
          <source>Low-level I/O primitives</source>
          <target state="translated">저수준 I / O 프리미티브</target>
        </trans-unit>
        <trans-unit id="9809ec59234a7fd4fad0458de06fb6ceef59377a" translate="yes" xml:space="preserve">
          <source>Low-level blocking</source>
          <target state="translated">저수준 차단</target>
        </trans-unit>
        <trans-unit id="26b0d3fb85c1a77979b58fc0dcdac52cde7cf583" translate="yes" xml:space="preserve">
          <source>Low-level checkpoint functions</source>
          <target state="translated">저수준 체크 포인트 기능</target>
        </trans-unit>
        <trans-unit id="83e3f9dcd236493cb7f1a761c41a62a9d9243115" translate="yes" xml:space="preserve">
          <source>Low-level networking with &lt;a href=&quot;#module-trio.socket&quot;&gt;&lt;code&gt;trio.socket&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#module-trio.socket&quot;&gt; &lt;code&gt;trio.socket&lt;/code&gt; 을&lt;/a&gt; 통한 저수준 네트워킹</target>
        </trans-unit>
        <trans-unit id="a9c1d4245e788744e95621301756e1256b668cc4" translate="yes" xml:space="preserve">
          <source>Low-level networking with &lt;code&gt;trio.socket&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;trio.socket&lt;/code&gt; 을 통한 저수준 네트워킹</target>
        </trans-unit>
        <trans-unit id="7a7080e23ec2bf698dbac21fef72095025b7bd60" translate="yes" xml:space="preserve">
          <source>Lower-level synchronization primitives</source>
          <target state="translated">하위 레벨 동기화 기본 요소</target>
        </trans-unit>
        <trans-unit id="e530eca5c9f827f73d54874e1186f58b37a1a426" translate="yes" xml:space="preserve">
          <source>Main thread: receives notification that the job finished, and calls &lt;code&gt;start_thread_soon&lt;/code&gt;.</source>
          <target state="translated">메인 스레드 : 작업이 완료되었다는 알림을 받고 &lt;code&gt;start_thread_soon&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="eeebc70f5fcdd7382339fa63db36a9a58a262fb0" translate="yes" xml:space="preserve">
          <source>Main thread: sees that no worker threads are marked idle, so spawns a second worker thread.</source>
          <target state="translated">주 스레드 : 작업자 스레드가 유휴로 표시되지 않았으므로 두 번째 작업자 스레드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="64c3a5b776dfc9fed8c84912a5b25137610b3851" translate="yes" xml:space="preserve">
          <source>Maintainer Enforcement Process</source>
          <target state="translated">관리자 시행 프로세스</target>
        </trans-unit>
        <trans-unit id="32ff137c78a32d8e8b4e8c2e8ca701567f8320ff" translate="yes" xml:space="preserve">
          <source>Make a TLS-encrypted Connection to the given host and port over TCP.</source>
          <target state="translated">TCP를 통해 지정된 호스트 및 포트에 대한 TLS 암호화 연결을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="bf1147c7b88a2cb509553a3ec5f329204bb504a6" translate="yes" xml:space="preserve">
          <source>Make sure that nothing else shuts down your host loop</source>
          <target state="translated">다른 어떤 것도 호스트 루프를 종료하지 않는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6577f5e216517f3a725c9bdbffa4833cc30cdf56" translate="yes" xml:space="preserve">
          <source>Managing issues</source>
          <target state="translated">이슈 관리</target>
        </trans-unit>
        <trans-unit id="874fe6380efcf8567cd3945da6538e701efad61f" translate="yes" xml:space="preserve">
          <source>Managing multiple producers and/or multiple consumers</source>
          <target state="translated">여러 생산자 및 / 또는 여러 소비자 관리</target>
        </trans-unit>
        <trans-unit id="ce4b94ac2fcd6838a8a9dde11f20624bdeb42a0c" translate="yes" xml:space="preserve">
          <source>Manually advance the clock by the given number of seconds.</source>
          <target state="translated">주어진 시간 (초)만큼 시계를 수동으로 진행시킵니다.</target>
        </trans-unit>
        <trans-unit id="dfb151fb6d747d3dc40957af4ba1c7e2b8670f95" translate="yes" xml:space="preserve">
          <source>Many people expect that switching from synchronous file I/O to async file I/O will always make their program faster. This is not true! If we just look at total throughput, then async file I/O might be faster, slower, or about the same, and it depends in a complicated way on things like your exact patterns of disk access, or how much RAM you have. The main motivation for async file I/O is not to improve throughput, but to &lt;strong&gt;reduce the frequency of latency glitches.&lt;/strong&gt;</source>
          <target state="translated">많은 사람들은 동기 파일 I / O에서 비동기 파일 I / O로 전환하면 항상 프로그램 속도가 빨라질 것으로 기대합니다. 이것은 사실이 아닙니다! 총 처리량 만 살펴보면 비동기 파일 I / O가 더 빠르거나 느리거나 거의 동일 할 수 있으며 정확한 디스크 액세스 패턴이나 보유한 RAM 용량과 같은 사항에 따라 복잡한 방식으로 달라집니다. 비동기 파일 I / O의 주된 동기는 처리량을 향상시키는 것이 아니라 &lt;strong&gt;대기 시간 결함의 빈도&lt;/strong&gt; 를 &lt;strong&gt;줄이는 것입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7589bf933d13f8bfdcd3193c9dc3896e3e03bbe5" translate="yes" xml:space="preserve">
          <source>Many people expect that switching to from synchronous file I/O to async file I/O will always make their program faster. This is not true! If we just look at total throughput, then async file I/O might be faster, slower, or about the same, and it depends in a complicated way on things like your exact patterns of disk access, or how much RAM you have. The main motivation for async file I/O is not to improve throughput, but to &lt;strong&gt;reduce the frequency of latency glitches.&lt;/strong&gt;</source>
          <target state="translated">많은 사람들이 동기 파일 I / O에서 비동기 파일 I / O로 전환하면 항상 프로그램 속도가 빨라질 것으로 기대합니다. 이것은 사실이 아닙니다! 전체 처리량 만 살펴보면 비동기 파일 I / O가 더 빠르거나 느리거나 거의 같을 수 있으며 정확한 디스크 액세스 패턴이나 RAM 용량과 같은 방식에 따라 복잡한 방식으로 달라집니다. 비동기 파일 I / O의 주요 동기는 처리량을 개선하는 것이 아니라 &lt;strong&gt;대기 시간 글리치 빈도&lt;/strong&gt; 를 &lt;strong&gt;줄이는 것입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="14b7986ca23831901ae0b3efc4ed19e3339816a9" translate="yes" xml:space="preserve">
          <source>Marks this stream as closed, and then calls the &lt;a href=&quot;#trio.testing.MemorySendStream.close_hook&quot;&gt;&lt;code&gt;close_hook&lt;/code&gt;&lt;/a&gt; (if any).</source>
          <target state="translated">이 스트림을 닫힌 것으로 표시 한 다음 &lt;a href=&quot;#trio.testing.MemorySendStream.close_hook&quot;&gt; &lt;code&gt;close_hook&lt;/code&gt; &lt;/a&gt; (있는 경우) 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e1111eba644f710b357147ecb281a63e4b7accdf" translate="yes" xml:space="preserve">
          <source>Memory channel operations are all atomic with respect to cancellation, either &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt; will successfully return an object, or it will raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; while leaving the channel unchanged.</source>
          <target state="translated">메모리 채널 작업은 취소와 관련하여 모두 원자 적이며 &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt; 은 객체를 성공적으로 반환하거나 채널을 변경하지 않은 채로 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="12cc69819eb175688379de996ddca98b1fee239a" translate="yes" xml:space="preserve">
          <source>Memory channels allow multiple tasks to call &lt;a href=&quot;#trio.MemoryReceiveChannel.receive&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt; at the same time. The first task will get the first item sent, the second task will get the second item sent, and so on.</source>
          <target state="translated">메모리 채널을 통해 여러 작업 이 동시에 &lt;a href=&quot;#trio.MemoryReceiveChannel.receive&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt; 전화를 걸 수 있습니다. 첫 번째 작업은 첫 번째 항목이 전송되고 두 번째 작업은 두 번째 항목이 전송되는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="9381ec63c31149e49413a93c0bb86c8b8276149d" translate="yes" xml:space="preserve">
          <source>Memory channels allow multiple tasks to call &lt;a href=&quot;#trio.MemorySendChannel.send&quot;&gt;&lt;code&gt;send&lt;/code&gt;&lt;/a&gt; at the same time.</source>
          <target state="translated">메모리 채널을 통해 여러 작업에서 전화를 걸 &lt;a href=&quot;#trio.MemorySendChannel.send&quot;&gt; &lt;code&gt;send&lt;/code&gt; &lt;/a&gt; 이 동시에 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
