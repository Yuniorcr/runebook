<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="trio">
    <body>
      <group id="trio">
        <trans-unit id="489409f79750bf468b370ea47ddb451641966d82" translate="yes" xml:space="preserve">
          <source>Safer KeyboardInterrupt handling</source>
          <target state="translated">안전한 키보드 인터럽트 처리</target>
        </trans-unit>
        <trans-unit id="c1463bcfc0ca2f582b52b93c0e116a9d627535ee" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;#trio.testing.MemoryReceiveStream.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.MemoryReceiveStream.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 비동기입니다.</target>
        </trans-unit>
        <trans-unit id="78d9d80923f156d407da12642698cb124013560a" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;#trio.testing.MemorySendStream.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.MemorySendStream.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 비동기입니다.</target>
        </trans-unit>
        <trans-unit id="41dd02db4d1d296325376880af0f9c7686740d69" translate="yes" xml:space="preserve">
          <source>Schedule a call to &lt;code&gt;sync_fn(*args)&lt;/code&gt; to occur in the context of a Trio task.</source>
          <target state="translated">Trio 작업의 컨텍스트에서 &lt;code&gt;sync_fn(*args)&lt;/code&gt; 에 대한 호출이 발생하도록 예약하십시오 .</target>
        </trans-unit>
        <trans-unit id="4651a34e4df9619783ad372f905d6d3b84e9d76d" translate="yes" xml:space="preserve">
          <source>Scope</source>
          <target state="translated">Scope</target>
        </trans-unit>
        <trans-unit id="43ddf283f03fda4643fe2db02659e6fb64a89999" translate="yes" xml:space="preserve">
          <source>Search Page</source>
          <target state="translated">검색 페이지</target>
        </trans-unit>
        <trans-unit id="df039209c5e4aa55542bc5803836ccf099d8bfd1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e621a2c3de8ee6dee87fb0fe1692f8bfdce4856" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt;&lt;code&gt;trio.abc.Listener.accept()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt; &lt;code&gt;trio.abc.Listener.accept()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="73fe6c344e72648d421d8761612fae248f51b59c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt;&lt;code&gt;trio.abc.ReceiveStream.receive_some()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt; &lt;code&gt;trio.abc.ReceiveStream.receive_some()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c5d2965756a1219162c7b103b7912b613c75d332" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;trio.abc.SendStream.send_all()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;trio.abc.SendStream.send_all()&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6dee4e334c48c5ee0fa6e7c0ee8c33b4b0f14005" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;trio.abc.SendStream.wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;trio.abc.SendStream.wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="90cbf068fcbe2871096db617137f8324a4d715a8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.hazmat.ParkingLot.repark&quot;&gt;&lt;code&gt;repark()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#trio.hazmat.ParkingLot.repark&quot;&gt; &lt;code&gt;repark()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d7d9cdee543f24de74e0f6d27ef26632818b0ba4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.hazmat.wait_readable&quot;&gt;&lt;code&gt;wait_readable&lt;/code&gt;&lt;/a&gt; for the definition of &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 정의에 대해서는 &lt;a href=&quot;#trio.hazmat.wait_readable&quot;&gt; &lt;code&gt;wait_readable&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="88cef7e47405de4633e88af131cdd34ba4e03bc8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="651cf48dfdd28ee21722da4947614b8beb329452" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; for the gory details.</source>
          <target state="translated">&lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 세부 사항 은 wait_task_rescheduled () 를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="016a67642a7abe850f2386f09f565400bd916ea3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.socket.set_custom_hostname_resolver&quot;&gt;&lt;code&gt;trio.socket.set_custom_hostname_resolver()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.socket.set_custom_hostname_resolver&quot;&gt; &lt;code&gt;trio.socket.set_custom_hostname_resolver()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fcf3667ecc461134130b73df4a3a1d6ca1ac4046" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.socket.set_custom_socket_factory&quot;&gt;&lt;code&gt;trio.socket.set_custom_socket_factory()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.socket.set_custom_socket_factory&quot;&gt; &lt;code&gt;trio.socket.set_custom_socket_factory()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc3b685f1d1be464dec386dc17d73a54dacf00d6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.testing.MemorySendStream.get_data&quot;&gt;&lt;code&gt;get_data()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#trio.testing.MemorySendStream.get_data&quot;&gt; &lt;code&gt;get_data()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4f274048841d456d97381e6b6644e2472a7ccda0" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.getsockopt&quot;&gt;&lt;code&gt;socket.socket.getsockopt()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.getsockopt&quot;&gt; &lt;code&gt;socket.socket.getsockopt()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f6839040a73e62c001a4d5d6b3a8b294c0e57bdc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.setsockopt&quot;&gt;&lt;code&gt;socket.socket.setsockopt()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.setsockopt&quot;&gt; &lt;code&gt;socket.socket.setsockopt()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2d72e5152dd898769a56b0fe337a4d1a861b2fea" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;ReceiveChannel.receive&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;ReceiveChannel.receive&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="58963e593c50f94f790638ce7556a275bcd204f2" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;SendChannel.send&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;SendChannel.send&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="f42e748c32f2195bd9faf81004af69032f05fc79" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#trio.aclose_forcefully&quot;&gt;&lt;code&gt;trio.aclose_forcefully()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.aclose_forcefully&quot;&gt; &lt;code&gt;trio.aclose_forcefully()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="158e95efe6c006cd04a0b4b2d0f6161646c045e5" translate="yes" xml:space="preserve">
          <source>Send an end-of-file indication on this stream, if possible.</source>
          <target state="translated">가능하면이 스트림에서 파일 끝 표시를 보내십시오.</target>
        </trans-unit>
        <trans-unit id="85da9214bbeac1196611983abddcebb768d2fc49" translate="yes" xml:space="preserve">
          <source>Send signal &lt;code&gt;sig&lt;/code&gt; to the process.</source>
          <target state="translated">신호 &lt;code&gt;sig&lt;/code&gt; 를 프로세스로 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="e634d246bcec48e110a516c9e0d7d7b2041045d0" translate="yes" xml:space="preserve">
          <source>Sends the given data through the stream, blocking if necessary.</source>
          <target state="translated">주어진 데이터를 스트림을 통해 전송하고 필요한 경우 차단합니다.</target>
        </trans-unit>
        <trans-unit id="ee954ecd822c7acfded07c0cc1fd9c091103b687" translate="yes" xml:space="preserve">
          <source>Set a custom hostname resolver.</source>
          <target state="translated">사용자 정의 호스트 이름 확인자를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="62fd9617b6da2daed723cb8babe107460a7aae70" translate="yes" xml:space="preserve">
          <source>Set a custom socket object factory.</source>
          <target state="translated">사용자 정의 소켓 객체 팩토리를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="5f98ea86f41a048ead986b6dc184184bdc19c8ce" translate="yes" xml:space="preserve">
          <source>Set an option on the underlying socket.</source>
          <target state="translated">기본 소켓에서 옵션을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="d7151175b4f06e30011860dd29520ea7ed6e51f2" translate="yes" xml:space="preserve">
          <source>Set the internal flag value to True, and wake any waiting tasks.</source>
          <target state="translated">내부 플래그 값을 True로 설정하고 대기중인 작업을 깨 웁니다.</target>
        </trans-unit>
        <trans-unit id="0ff0e99264a92cdda9a69ac291e7a0266785bdd2" translate="yes" xml:space="preserve">
          <source>Setting a custom hostname resolver affects all future calls to &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt;&lt;code&gt;getnameinfo()&lt;/code&gt;&lt;/a&gt; within the enclosing call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;. All other hostname resolution in Trio is implemented in terms of these functions.</source>
          <target state="translated">사용자 정의 호스트 이름 분석기를 설정하면 이후의 &lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 호출 내 &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt; &lt;code&gt;getnameinfo()&lt;/code&gt; &lt;/a&gt; 에 대한 모든 호출에 영향을줍니다 . Trio의 다른 모든 호스트 이름 확인은 이러한 기능 측면에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="9f5e3bbf7985a9dab01cc08204725bd79c4bf118" translate="yes" xml:space="preserve">
          <source>Setting a custom socket factory affects all future calls to &lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt;&lt;code&gt;socket()&lt;/code&gt;&lt;/a&gt; within the enclosing call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 소켓 팩토리를 설정하면 나중에 &lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 호출 내 &lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt; &lt;code&gt;socket()&lt;/code&gt; &lt;/a&gt; 에 대한 모든 호출에 영향을 미칩니다 .</target>
        </trans-unit>
        <trans-unit id="b5f69ef7d9833414a1ee8b90a0835b9fff2745ad" translate="yes" xml:space="preserve">
          <source>Shuts down the send side of the stream.</source>
          <target state="translated">스트림의 송신 측을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="2346a18ea3002ff04eca3a130c7f40e65c56f0c9" translate="yes" xml:space="preserve">
          <source>Signals</source>
          <target state="translated">Signals</target>
        </trans-unit>
        <trans-unit id="8b3df0abd55afcfcab7033b5dc2c6d404832e669" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.connect&quot;&gt;&lt;code&gt;socket.socket.connect()&lt;/code&gt;&lt;/a&gt;, except async.</source>
          <target state="translated">비동기를 제외하고 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.connect&quot;&gt; &lt;code&gt;socket.socket.connect()&lt;/code&gt; &lt;/a&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="195fcbdedfbd716b2508e3c94ddbf5266f253623" translate="yes" xml:space="preserve">
          <source>Since all of the tasks are running concurrently inside the &lt;code&gt;async
with&lt;/code&gt; block, the block does not exit until &lt;em&gt;all&lt;/em&gt; tasks have completed. If you&amp;rsquo;ve used other concurrency frameworks, then you can think of it as, the de-indentation at the end of the &lt;code&gt;async with&lt;/code&gt; automatically &amp;ldquo;joins&amp;rdquo; (waits for) all of the tasks in the nursery.</source>
          <target state="translated">모든 작업이 내부에서 동시에 실행되기 때문에 &lt;code&gt;async with&lt;/code&gt; 때까지 블록, 블록이 종료되지 않는 &lt;em&gt;모든&lt;/em&gt; 작업이 완료되었습니다. 다른 동시성 프레임 워크를 사용한 경우 &lt;code&gt;async with&lt;/code&gt; 끝에서 비인 덴 테이션 이 보육원의 모든 작업 을 자동으로 &quot;결합&quot;(대기) 하는 것으로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e123adcb2343580f3c45b40dc7e669799bca848" translate="yes" xml:space="preserve">
          <source>Since all tasks are descendents of the initial task, one consequence of this is that &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; can&amp;rsquo;t finish until all tasks have finished.</source>
          <target state="translated">모든 작업은 초기 작업의 후손이므로 모든 작업이 완료 될 때까지 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 을 완료 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ccb2ec4f90e25bdaf10ffc4e52048eb34a6ada6d" translate="yes" xml:space="preserve">
          <source>Since process creation takes a single arguments string, &lt;code&gt;CMD.EXE&lt;/code&gt;&amp;rsquo;s quoting does not influence word splitting, and double quotes are not removed during CMD.EXE&amp;rsquo;s expansion pass. Double quotes are troublesome because CMD.EXE handles them differently from the MSVC runtime rules; in:</source>
          <target state="translated">프로세스 생성에는 단일 인수 문자열이 사용되므로 &lt;code&gt;CMD.EXE&lt;/code&gt; 의 인용은 단어 분리에 영향을 미치지 않으며 CMD.EXE의 확장 단계에서 큰 따옴표는 제거되지 않습니다. 큰 따옴표는 CMD.EXE가 MSVC 런타임 규칙과 다르게 처리하기 때문에 번거 롭습니다. 에:</target>
        </trans-unit>
        <trans-unit id="1e290ea0e39f01d4b842c1a165cd9781b38eb4ba" translate="yes" xml:space="preserve">
          <source>Since this hooks into Trio at a rather low level, you do have to be careful. The callbacks are run synchronously, and in many cases if they error out then there isn&amp;rsquo;t any plausible way to propagate this exception (for instance, we might be deep in the guts of the exception propagation machinery&amp;hellip;). Therefore our &lt;a href=&quot;https://github.com/python-trio/trio/issues/47&quot;&gt;current strategy&lt;/a&gt; for handling exceptions raised by instruments is to (a) log an exception to the &lt;code&gt;&quot;trio.abc.Instrument&quot;&lt;/code&gt; logger, which by default prints a stack trace to standard error and (b) disable the offending instrument.</source>
          <target state="translated">이것은 다소 낮은 수준에서 Trio에 연결되므로주의해야합니다. 콜백은 동기식으로 실행되며, 대부분의 경우 오류가 발생하면이 예외를 전파 할 수있는 적절한 방법이 없습니다 (예를 들어, 예외 전파 메커니즘의 장에서 깊을 수 있습니다). 따라서 계측기에서 발생하는 예외를 처리 &lt;a href=&quot;https://github.com/python-trio/trio/issues/47&quot;&gt;하기&lt;/a&gt; 위한 현재 전략 은 (a) &lt;code&gt;&quot;trio.abc.Instrument&quot;&lt;/code&gt; 로거에 예외를 기록하는 것으로, 기본적으로 스택 추적을 표준 오류에 인쇄하고 (b) 문제가있는 계측기를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="703d59254915506775b33344a3a18adcf8c5850f" translate="yes" xml:space="preserve">
          <source>Sleeping and waking</source>
          <target state="translated">잠자기</target>
        </trans-unit>
        <trans-unit id="177046c4af35e4336df197889f9ee07eb5aa6ce4" translate="yes" xml:space="preserve">
          <source>So long as you&amp;rsquo;re inside a scope with &lt;code&gt;shield = True&lt;/code&gt; set, then you&amp;rsquo;ll be protected from outside cancellations. Note though that this &lt;em&gt;only&lt;/em&gt; applies to &lt;em&gt;outside&lt;/em&gt; cancellations: if &lt;code&gt;CLEANUP_TIMEOUT&lt;/code&gt; expires then &lt;code&gt;await conn.send_goodbye_msg()&lt;/code&gt; will still be cancelled, and if &lt;code&gt;await conn.send_goodbye_msg()&lt;/code&gt; call uses any timeouts internally, then those will continue to work normally as well. This is a pretty advanced feature that most people probably won&amp;rsquo;t use, but it&amp;rsquo;s there for the rare cases where you need it.</source>
          <target state="translated">&lt;code&gt;shield = True&lt;/code&gt; 설정된 범위 안에 있으면 외부 취소로부터 보호됩니다. 그러나 이는 &lt;em&gt;외부&lt;/em&gt; 취소 &lt;em&gt;에만&lt;/em&gt; 적용됩니다 . &lt;code&gt;CLEANUP_TIMEOUT&lt;/code&gt; 이 만료되면 &lt;code&gt;await conn.send_goodbye_msg()&lt;/code&gt; 가 여전히 취소되고 &lt;code&gt;await conn.send_goodbye_msg()&lt;/code&gt; 호출이 내부적으로 시간 초과를 사용하는 경우 계속 정상적으로 작동합니다. 이것은 대부분의 사람들이 사용하지 않을 꽤 고급 기능이지만, 필요한 경우가 거의 없습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eacc0cea5faa2540efcfce1aec9fc9bc5a14d8d1" translate="yes" xml:space="preserve">
          <source>So that&amp;rsquo;s great, but &amp;ndash; how do we know whether we&amp;rsquo;re in one of the sensitive parts of the program or not?</source>
          <target state="translated">우리는 프로그램의 민감한 부분에 있는지 여부를 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="8a08024d671c4e56a036c4b52ad5c32416c73f48" translate="yes" xml:space="preserve">
          <source>So when you&amp;rsquo;re doing code review on a project that uses Trio, one of the things you&amp;rsquo;ll want to think about is whether there are enough checkpoints, and whether each one is handled correctly. Of course this means you need a way to recognize checkpoints. How do you do that? The underlying principle is that any operation that blocks has to be a checkpoint. This makes sense: if an operation blocks, then it might block for a long time, and you&amp;rsquo;ll want to be able to cancel it if a timeout expires; and in any case, while this task is blocked we want another task to be scheduled to run so our code can make full use of the CPU.</source>
          <target state="translated">따라서 Trio를 사용하는 프로젝트에서 코드 검토를 수행 할 때 고려해야 할 사항 중 하나는 충분한 체크 포인트가 있는지 여부와 각각이 올바르게 처리되는지 여부입니다. 물론 이것은 체크 포인트를 인식 할 수있는 방법이 필요하다는 것을 의미합니다. 어떻게합니까? 기본 원칙은 차단하는 모든 작업이 검사 점이어야한다는 것입니다. 작업이 차단되면 장시간 차단 될 수 있으며 시간 초과가 만료되면 취소 할 수 있습니다. 어쨌든이 작업이 차단되는 동안 코드가 CPU를 최대한 활용할 수 있도록 다른 작업이 실행되도록 예약하려고합니다.</target>
        </trans-unit>
        <trans-unit id="94f1cedea7c4796760fe90eed253e295e38abb27" translate="yes" xml:space="preserve">
          <source>So you can see that the producer runs ahead by 3 messages, and then stops to wait: when the consumer reads message 1, it sends message 4, then when the consumer reads message 2, it sends message 5, and so on. Once it reaches the steady state, this version acts just like our previous version where we set the buffer size to 0, except that it uses a bit more memory and each message sits in the buffer for a bit longer before being processed (i.e., the message latency is higher).</source>
          <target state="translated">따라서 생산자가 3 개의 메시지보다 먼저 실행 한 다음 대기를 중지한다는 것을 알 수 있습니다. 소비자가 메시지 1을 읽을 때 메시지 4를 보낸 다음 소비자가 메시지 2를 읽을 때 메시지 5를 보내는 방식 등입니다. 정상 상태에 도달하면이 버전은 이전 버전과 동일하게 작동하여 버퍼 크기를 0으로 설정합니다. 단, 더 많은 메모리를 사용하고 각 메시지는 처리되기 전에 조금 더 오래 버퍼에 있습니다. 메시지 대기 시간이 더 깁니다).</target>
        </trans-unit>
        <trans-unit id="daa57596ade9bdcbd1f251fa5b9ed91ad7cb1852" translate="yes" xml:space="preserve">
          <source>So, we can see that it&amp;rsquo;s important to be able to change the policy controlling the allocation of threads to jobs. But in many frameworks, this requires implementing a new thread pool from scratch, which is highly non-trivial; and if different types of jobs need different policies, then you may have to create multiple pools, which is inefficient because now you effectively have two different thread caches that aren&amp;rsquo;t sharing resources.</source>
          <target state="translated">따라서 스레드 할당을 제어하는 ​​정책을 작업에 변경하는 것이 중요하다는 것을 알 수 있습니다. 그러나 많은 프레임 워크에서 새로운 스레드 풀을 처음부터 구현해야합니다. 다른 유형의 작업에 다른 정책이 필요한 경우 여러 풀을 만들어야 할 수도 있습니다. 이제 리소스를 공유하지 않는 서로 다른 두 개의 스레드 캐시를 효과적으로 사용할 수 있기 때문에 비효율적입니다.</target>
        </trans-unit>
        <trans-unit id="c798110762fd844baf0b5cdc9832d8c71d67602a" translate="yes" xml:space="preserve">
          <source>Socket objects</source>
          <target state="translated">소켓 객체</target>
        </trans-unit>
        <trans-unit id="655fcbd0fdce070ab1dd17b0f4b4d25fd50db073" translate="yes" xml:space="preserve">
          <source>SocketStream</source>
          <target state="translated">SocketStream</target>
        </trans-unit>
        <trans-unit id="33243780198fdd9e060afa427801d7aeb8d32f67" translate="yes" xml:space="preserve">
          <source>Sockets and networking</source>
          <target state="translated">소켓 및 네트워킹</target>
        </trans-unit>
        <trans-unit id="dc23719f0d9233246e570ccf60e98a17c7b26b0b" translate="yes" xml:space="preserve">
          <source>Some &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; methods can&amp;rsquo;t return any meaningful data until after the handshake. If you call them before the handshake, they raise this error.</source>
          <target state="translated">일부 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 메서드는 핸드 셰이크가 완료 될 때까지 의미있는 데이터를 반환 할 수 없습니다. 핸드 셰이크 전에 전화하면이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="763dc9850c40e96a02c0a22e2cbdb9bd606c49a4" translate="yes" xml:space="preserve">
          <source>Some methods on &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; raise &lt;a href=&quot;#trio.NeedHandshakeError&quot;&gt;&lt;code&gt;NeedHandshakeError&lt;/code&gt;&lt;/a&gt; if you call them before the handshake completes:</source>
          <target state="translated">일부 방법 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; 의&lt;/a&gt; 인상 &lt;a href=&quot;#trio.NeedHandshakeError&quot;&gt; &lt;code&gt;NeedHandshakeError&lt;/code&gt; &lt;/a&gt; 는 핸드 쉐이크 완료하기 전에를 호출하는 경우 :</target>
        </trans-unit>
        <trans-unit id="b27189a11dd9d8693c1cfa882d09fc9356dcb1d5" translate="yes" xml:space="preserve">
          <source>Sometimes it doesn&amp;rsquo;t make sense for the task that starts a child to take on responsibility for watching it. For example, a server task may want to start a new task for each connection, but it can&amp;rsquo;t listen for connections and supervise children at the same time.</source>
          <target state="translated">때때로 어린이가 시작한 임무를보고 책임을지는 것은 이해가되지 않습니다. 예를 들어, 서버 작업은 각 연결마다 새 작업을 시작하려고하지만 연결을 수신하고 동시에 하위를 감독 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="2df141e44fbf3ba214d9841f6406f0bfbb78bccb" translate="yes" xml:space="preserve">
          <source>Sometimes you need to put a limit on how many tasks can do something at the same time. For example, you might want to use some threads to run multiple blocking I/O operations in parallel&amp;hellip; but if you use too many threads at once, then your system can become overloaded and it&amp;rsquo;ll actually make things slower. One popular solution is to impose a policy like &amp;ldquo;run up to 40 threads at the same time, but no more&amp;rdquo;. But how do you implement a policy like this?</source>
          <target state="translated">때로는 작업을 동시에 수행 할 수있는 작업 수를 제한해야합니다. 예를 들어, 일부 스레드를 사용하여 여러 블로킹 I / O 작업을 병렬로 실행할 수 있지만 한 번에 너무 많은 스레드를 사용하면 시스템이 오버로드되어 실제로 속도가 느려질 수 있습니다. 널리 사용되는 솔루션 중 하나는 &quot;최대 40 개의 스레드를 동시에 실행하지만 더 이상 실행하지 않는&quot;정책을 적용하는 것입니다. 그러나 이와 같은 정책을 어떻게 구현합니까?</target>
        </trans-unit>
        <trans-unit id="28a2722a8ff69315bc9a5705fed28a992c345e6f" translate="yes" xml:space="preserve">
          <source>Sometimes, it&amp;rsquo;s useful to be able to share some mutable sleep-related data between the sleeping task, the abort function, and the waking task. You can use the sleeping task&amp;rsquo;s &lt;a href=&quot;#trio.hazmat.Task.custom_sleep_data&quot;&gt;&lt;code&gt;custom_sleep_data&lt;/code&gt;&lt;/a&gt; attribute to store this data, and Trio won&amp;rsquo;t touch it, except to make sure that it gets cleared when the task is rescheduled.</source>
          <target state="translated">수면 작업, 중단 기능 및 깨우기 작업간에 변경 가능한 수면 관련 데이터를 공유하는 것이 유용한 경우도 있습니다. 수면 작업의 &lt;a href=&quot;#trio.hazmat.Task.custom_sleep_data&quot;&gt; &lt;code&gt;custom_sleep_data&lt;/code&gt; &lt;/a&gt; 속성을 사용하여이 데이터를 저장할 수 있으며 작업 일정이 재조정 될 때 데이터가 지워지는 것을 제외하고는 Trio가 해당 데이터를 건드리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a64f6b1abe92a7a7b4c6478df9e8e0cd60338357" translate="yes" xml:space="preserve">
          <source>Sometimes, though if we&amp;rsquo;re lucky, the two producers might finish at the same time (or close enough), so they both make their last &lt;code&gt;send&lt;/code&gt; before either of them closes the &lt;code&gt;send_channel&lt;/code&gt;.</source>
          <target state="translated">때로는 운이 좋으면 두 제작자가 동시에 완료하거나 충분히 닫을 수 있으므로 두 사람 이 &lt;code&gt;send_channel&lt;/code&gt; 을 닫기 전에 마지막으로 &lt;code&gt;send&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4062e9fcc29dbf3d4f384d021b8d2f23dae68ca4" translate="yes" xml:space="preserve">
          <source>Spawn a &amp;ldquo;system&amp;rdquo; task.</source>
          <target state="translated">&quot;시스템&quot;작업을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="86787d141e62ea9c6e1d9ef20be7863fc8ae36cd" translate="yes" xml:space="preserve">
          <source>Spawn this thread from &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync&lt;/code&gt;&lt;/a&gt;. Trio will automatically capture the relevant Trio token and use it when you want to re-enter Trio.</source>
          <target state="translated">&lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync&lt;/code&gt; &lt;/a&gt; 에서이 스레드를 생성합니다 . Trio는 관련 Trio 토큰을 자동으로 캡처하여 Trio를 다시 입력하려고 할 때 사용합니다.</target>
        </trans-unit>
        <trans-unit id="62f14e7f69f0c928f3521a52d4471e369748ed2e" translate="yes" xml:space="preserve">
          <source>Spawning subprocesses</source>
          <target state="translated">하위 프로세스 생성</target>
        </trans-unit>
        <trans-unit id="255e359a65128521d6223be6b31e2b8a76a94d43" translate="yes" xml:space="preserve">
          <source>Spawning tasks without becoming a parent</source>
          <target state="translated">부모가되지 않고 산란 작업</target>
        </trans-unit>
        <trans-unit id="b5265bdb21e85f3aad61c94d6d966d5e82bdd52f" translate="yes" xml:space="preserve">
          <source>Special notes:</source>
          <target state="translated">특별 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="59452117c4e17f1600d8cb5a7a64e6200569cd19" translate="yes" xml:space="preserve">
          <source>Specific style guidelines</source>
          <target state="translated">특정 스타일 지침</target>
        </trans-unit>
        <trans-unit id="f7a9b1371562eba7427785ba394b08b92540fb8e" translate="yes" xml:space="preserve">
          <source>Standard-compliant SSL/TLS implementations always send a cryptographically signed &lt;code&gt;close_notify&lt;/code&gt; message before closing the connection. This is important because if the underlying transport were simply closed, then there wouldn&amp;rsquo;t be any way for the other side to know whether the connection was intentionally closed by the peer that they negotiated a cryptographic connection to, or by some &lt;a href=&quot;https://en.wikipedia.org/wiki/Man-in-the-middle_attack&quot;&gt;man-in-the-middle&lt;/a&gt; attacker who can&amp;rsquo;t manipulate the cryptographic stream, but can manipulate the transport layer (a so-called &amp;ldquo;truncation attack&amp;rdquo;).</source>
          <target state="translated">표준 호환 SSL / TLS 구현 은 연결을 닫기 전에 항상 암호화 서명 된 &lt;code&gt;close_notify&lt;/code&gt; 메시지를 보냅니다 . 기본 전송이 단순히 닫히면 상대방이 암호화 연결을 협상 한 피어가 연결을 의도적으로 닫았는지 또는 일부 담당자가 연결을 알 수있는 방법이 없기 때문에 이것은 중요합니다 &lt;a href=&quot;https://en.wikipedia.org/wiki/Man-in-the-middle_attack&quot;&gt;.&lt;/a&gt; 암호화 스트림을 조작 할 수 없지만 전송 계층 (소위 &quot;절단 공격&quot;)을 조작 할 수있는 중간 공격자.</target>
        </trans-unit>
        <trans-unit id="538bad610e4cd63875a6f40262577d01e06f3685" translate="yes" xml:space="preserve">
          <source>Start instrumenting the current run loop with the given instrument.</source>
          <target state="translated">주어진 계측기로 현재 런 루프 계측을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="27ec8cde0c460b3a817bbe9ef5ff3449e512158c" translate="yes" xml:space="preserve">
          <source>Start listening for SSL/TLS-encrypted TCP connections to the given port.</source>
          <target state="translated">주어진 포트에 대한 SSL / TLS 암호화 TCP 연결 수신을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="b2062c61bfd9457e074fe8ebdf948e44b4303be1" translate="yes" xml:space="preserve">
          <source>Stop instrumenting the current run loop with the given instrument.</source>
          <target state="translated">주어진 계측기로 현재 런 루프 계측을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="74985da267c6803b262f117de72af2d02e48029f" translate="yes" xml:space="preserve">
          <source>Streams</source>
          <target state="translated">Streams</target>
        </trans-unit>
        <trans-unit id="ecfa6cc29e1a7d81c918ce86382e082e5b3f9aa7" translate="yes" xml:space="preserve">
          <source>String containing this &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s name. Usually the name of the function this &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; is running, but can be overridden by passing &lt;code&gt;name=&lt;/code&gt; to &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;start_soon&lt;/code&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 이름 이 포함 된 문자열 입니다. 일반적으로이 &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 이 실행중인 함수의 이름 이지만 &lt;code&gt;name=&lt;/code&gt; 을 &lt;code&gt;start&lt;/code&gt; 또는 &lt;code&gt;start_soon&lt;/code&gt; 으로 전달하여 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f4774c0e91d69d04dd6ad14a20a6dcc93957451" translate="yes" xml:space="preserve">
          <source>Supported environments: Linux, macOS, or Windows running some kind of Python 3.5-or-better (either CPython or PyPy3 is fine). *BSD and illumos likely work too, but are untested.</source>
          <target state="translated">지원되는 환경 : 어떤 종류의 Python 3.5 이상을 실행하는 Linux, macOS 또는 Windows (CPython 또는 PyPy3이 좋습니다). * BSD와 illumos도 작동하지만 테스트되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="6e0f9d236419d7ce4dcfde2105032675c5910961" translate="yes" xml:space="preserve">
          <source>Suppose we have a handler function that discards &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;s:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 를 버리는 핸들러 함수가 있다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="9bcc4a70ae1d63b866c95cda6ee3ba65780eedf1" translate="yes" xml:space="preserve">
          <source>Suppose you&amp;rsquo;re writing a server that responds to network requests, and you log some information about each request as you process it. If the server is busy and there are multiple requests being handled at the same time, then you might end up with logs like this:</source>
          <target state="translated">네트워크 요청에 응답하는 서버를 작성하고 처리 할 때 각 요청에 대한 정보를 기록한다고 가정하십시오. 서버가 사용 중이고 동시에 여러 요청이 처리되는 경우 다음과 같은 로그가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19e98a8e67554960e71cb8b97f1c5ac1a004d082" translate="yes" xml:space="preserve">
          <source>Synchronizing and communicating between tasks</source>
          <target state="translated">작업 간 동기화 및 통신</target>
        </trans-unit>
        <trans-unit id="055926a4c90e5c08999c70c13e37e6306b9e8f0b" translate="yes" xml:space="preserve">
          <source>Synchronous attributes/methods: if any of the following attributes or methods are present, then they&amp;rsquo;re re-exported unchanged: &lt;code&gt;closed&lt;/code&gt;, &lt;code&gt;encoding&lt;/code&gt;, &lt;code&gt;errors&lt;/code&gt;, &lt;code&gt;fileno&lt;/code&gt;, &lt;code&gt;isatty&lt;/code&gt;, &lt;code&gt;newlines&lt;/code&gt;, &lt;code&gt;readable&lt;/code&gt;, &lt;code&gt;seekable&lt;/code&gt;, &lt;code&gt;writable&lt;/code&gt;, &lt;code&gt;buffer&lt;/code&gt;, &lt;code&gt;raw&lt;/code&gt;, &lt;code&gt;line_buffering&lt;/code&gt;, &lt;code&gt;closefd&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;mode&lt;/code&gt;, &lt;code&gt;getvalue&lt;/code&gt;, &lt;code&gt;getbuffer&lt;/code&gt;.</source>
          <target state="translated">동기 속성 / 방법이 다음 특성 또는 임의의 방법이 존재하는 경우, 그들은있는 거 재 반출 변경 : &lt;code&gt;closed&lt;/code&gt; , &lt;code&gt;encoding&lt;/code&gt; , &lt;code&gt;errors&lt;/code&gt; , &lt;code&gt;fileno&lt;/code&gt; 는 , &lt;code&gt;isatty&lt;/code&gt; 은 , &lt;code&gt;newlines&lt;/code&gt; , &lt;code&gt;readable&lt;/code&gt; , &lt;code&gt;seekable&lt;/code&gt; , &lt;code&gt;writable&lt;/code&gt; , &lt;code&gt;buffer&lt;/code&gt; , &lt;code&gt;raw&lt;/code&gt; , &lt;code&gt;line_buffering&lt;/code&gt; , &lt;code&gt;closefd&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;mode&lt;/code&gt; , &lt;code&gt;getvalue&lt;/code&gt; , &lt;code&gt;getbuffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26f95fb839ad8c1ff05b0c8fdf998088c518fd27" translate="yes" xml:space="preserve">
          <source>Synchronous code never contains any checkpoints, but we can double-check that:</source>
          <target state="translated">동기 코드에는 체크 포인트가 포함되지 않지만 다음을 다시 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d3242a906ad02bf931de9a3178700e07c2be807" translate="yes" xml:space="preserve">
          <source>System tasks are automatically cancelled when the main task exits.</source>
          <target state="translated">기본 작업이 종료되면 시스템 작업이 자동으로 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="5c204ac92f0958e65d5735c8207842ebd1d94d97" translate="yes" xml:space="preserve">
          <source>System tasks do not inherit context variables from their creator.</source>
          <target state="translated">시스템 작업은 생성자로부터 컨텍스트 변수를 상속하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4f943638fe154a8226e9c578ceb1a32fb677027" translate="yes" xml:space="preserve">
          <source>System tasks have a few differences from regular tasks:</source>
          <target state="translated">시스템 작업은 일반 작업과 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f44fef3579bfe89f6394f4eef4837d80321d9a4a" translate="yes" xml:space="preserve">
          <source>TODO: these are implemented, but are currently more of a sketch than anything real. See &lt;a href=&quot;https://github.com/python-trio/trio/issues/26&quot;&gt;#26&lt;/a&gt; and &lt;a href=&quot;https://github.com/python-trio/trio/issues/52&quot;&gt;#52&lt;/a&gt;.</source>
          <target state="translated">TODO : 이들은 구현되었지만 현재 실제보다 더 많은 스케치입니다. &lt;a href=&quot;https://github.com/python-trio/trio/issues/26&quot;&gt;# 26&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/python-trio/trio/issues/52&quot;&gt;# 52를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34c39842bbae3da361d13d933fa1d76993d2e5e4" translate="yes" xml:space="preserve">
          <source>TODO: these are implemented, but are currently more of a sketch than anything real. See &lt;a href=&quot;https://github.com/python-trio/trio/issues/26&quot;&gt;#26&lt;/a&gt;.</source>
          <target state="translated">TODO : 이들은 구현되었지만 현재 실제보다 더 많은 스케치입니다. &lt;a href=&quot;https://github.com/python-trio/trio/issues/26&quot;&gt;# 26&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="c6d22c008afc423d3836f670a439ca3979a41de4" translate="yes" xml:space="preserve">
          <source>Take data out of the given &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;code&gt;MemorySendStream&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s internal buffer, and put it into the given &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;code&gt;MemoryReceiveStream&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s internal buffer.</source>
          <target state="translated">주어진 &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt; &lt;code&gt;MemorySendStream&lt;/code&gt; &lt;/a&gt; 의 내부 버퍼에서 데이터를 가져와 주어진 &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt; &lt;code&gt;MemoryReceiveStream&lt;/code&gt; &lt;/a&gt; 의 내부 버퍼에 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="7bb0ddf9221c03b806b03c209e8366000124aa15" translate="yes" xml:space="preserve">
          <source>Task</source>
          <target state="translated">Task</target>
        </trans-unit>
        <trans-unit id="d89b8bafaae10233d3c0df964c49dfe20cf2d352" translate="yes" xml:space="preserve">
          <source>Task API</source>
          <target state="translated">작업 API</target>
        </trans-unit>
        <trans-unit id="802a4e17ee1d8e6d0ad7403c8b75383080b8674e" translate="yes" xml:space="preserve">
          <source>Task-local storage</source>
          <target state="translated">작업 로컬 스토리지</target>
        </trans-unit>
        <trans-unit id="f74f87f6903191022bd96d719e761e9623d8f5cb" translate="yes" xml:space="preserve">
          <source>Task-related API details</source>
          <target state="translated">작업 관련 API 세부 사항</target>
        </trans-unit>
        <trans-unit id="ef1c5421122784c77c263be639d67c525ca3c3b4" translate="yes" xml:space="preserve">
          <source>Tasks let you do multiple things at once</source>
          <target state="translated">작업을 통해 한 번에 여러 작업을 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="304baf6bf4961ac71a5da0c98ab5a8d805ceefdf" translate="yes" xml:space="preserve">
          <source>Temporarily detach the current coroutine object from the Trio scheduler.</source>
          <target state="translated">현재 코 루틴 오브젝트를 Trio 스케줄러에서 임시로 분리하십시오.</target>
        </trans-unit>
        <trans-unit id="facd1c6aeacb9718336f3aed70d13ecc4deab47b" translate="yes" xml:space="preserve">
          <source>Terminate the process, politely if possible.</source>
          <target state="translated">가능하면 정중하게 프로세스를 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="5d4008135062fb803b7ec11f07867a7759c2e1da" translate="yes" xml:space="preserve">
          <source>Test harness integration</source>
          <target state="translated">테스트 하네스 통합</target>
        </trans-unit>
        <trans-unit id="6b011e2bb3c834f658d616203f55717f63ba2ae6" translate="yes" xml:space="preserve">
          <source>Testing checkpoints</source>
          <target state="translated">검사 점 테스트</target>
        </trans-unit>
        <trans-unit id="35e0ba25999f3a918e3e2952df381f71ee1accbf" translate="yes" xml:space="preserve">
          <source>Testing custom stream implementations</source>
          <target state="translated">맞춤 스트림 구현 테스트</target>
        </trans-unit>
        <trans-unit id="341c328d3226e6e7cbcef449b2f9d2e0ef49e921" translate="yes" xml:space="preserve">
          <source>Testing made easier with &lt;code&gt;trio.testing&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;trio.testing&lt;/code&gt; 테스트를 통해 테스트가 쉬워 졌습니다.</target>
        </trans-unit>
        <trans-unit id="2987927a1f9194d0407b8259e63f466ffac0a9e8" translate="yes" xml:space="preserve">
          <source>Testing made easier with trio.testing</source>
          <target state="translated">트리오 테스트를 통해 테스트가 쉬워졌습니다.</target>
        </trans-unit>
        <trans-unit id="08c3519cadca868f28bbb253c4e6d9baf20e199f" translate="yes" xml:space="preserve">
          <source>That world, alas, does not (yet) exist. Until it does, you may find yourself needing to interact with non-Trio APIs that do rude things like &amp;ldquo;blocking&amp;rdquo;.</source>
          <target state="translated">아아, 그 세계는 (아직) 존재하지 않습니다. 그 때까지&amp;ldquo;차단&amp;rdquo;과 같은 무례한 작업을 수행하는 비 Trio API와 상호 작용해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ac747b8191150731763661dc9fc7b17a6a27a33" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s what &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; is for. You can think of a &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; object as a sack that starts out holding some fixed number of tokens:</source>
          <target state="translated">그것이 &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; 의&lt;/a&gt; 목적입니다. &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt; 객체는 고정 된 수의 토큰을 보유하기 시작하는 자루로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd78edb290431455f2a37b4855817a9dffd051ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-trio.socket&quot;&gt;&lt;code&gt;trio.socket&lt;/code&gt;&lt;/a&gt; module provides Trio&amp;rsquo;s basic low-level networking API. If you&amp;rsquo;re doing ordinary things with stream-oriented connections over IPv4/IPv6/Unix domain sockets, then you probably want to stick to the high-level API described above. If you want to use UDP, or exotic address families like &lt;code&gt;AF_BLUETOOTH&lt;/code&gt;, or otherwise get direct access to all the quirky bits of your system&amp;rsquo;s networking API, then you&amp;rsquo;re in the right place.</source>
          <target state="translated">&lt;a href=&quot;#module-trio.socket&quot;&gt; &lt;code&gt;trio.socket&lt;/code&gt; 의&lt;/a&gt; 모듈은 트리오의 기본 낮은 수준의 네트워킹 API를 제공한다. IPv4 / IPv6 / Unix 도메인 소켓을 통한 스트림 지향 연결로 평범한 작업을 수행하는 경우 위에서 설명한 고급 API를 고수하고 싶을 것입니다. UDP 또는 &lt;code&gt;AF_BLUETOOTH&lt;/code&gt; 와 같은 이국적인 주소 패밀리를 사용하거나 시스템 네트워킹 API의 모든 기발한 비트에 직접 액세스하려면 올바른 위치에 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8e0d2ab8c98abb5b0b0f5e1d4a574bebf7c6690" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-trio.testing&quot;&gt;&lt;code&gt;trio.testing&lt;/code&gt;&lt;/a&gt; module provides various utilities to make it easier to test Trio code. Unlike the other submodules in the &lt;a href=&quot;reference-core#module-trio&quot;&gt;&lt;code&gt;trio&lt;/code&gt;&lt;/a&gt; namespace, &lt;a href=&quot;#module-trio.testing&quot;&gt;&lt;code&gt;trio.testing&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;not&lt;/em&gt; automatically imported when you do &lt;code&gt;import trio&lt;/code&gt;; you must &lt;code&gt;import trio.testing&lt;/code&gt; explicitly.</source>
          <target state="translated">&lt;a href=&quot;#module-trio.testing&quot;&gt; &lt;code&gt;trio.testing&lt;/code&gt; &lt;/a&gt; 모듈은 쉽게 트리오 코드를 테스트 할 수 있도록 다양한 유틸리티를 제공합니다. 의 다른 서브 모듈과 달리 &lt;a href=&quot;reference-core#module-trio&quot;&gt; &lt;code&gt;trio&lt;/code&gt; &lt;/a&gt; 네임 스페이스, &lt;a href=&quot;#module-trio.testing&quot;&gt; &lt;code&gt;trio.testing&lt;/code&gt; &lt;/a&gt; 되어 &lt;em&gt;있지&lt;/em&gt; 자동으로 수행 할 때 가져 &lt;code&gt;import trio&lt;/code&gt; ; &lt;code&gt;import trio.testing&lt;/code&gt; 명시 적으로 가져와야 합니다 .</target>
        </trans-unit>
        <trans-unit id="996e86c00c33ba5b09fce5a9fc45abb7e9e22650" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; constructor takes initial values for the cancel scope&amp;rsquo;s &lt;a href=&quot;#trio.CancelScope.deadline&quot;&gt;&lt;code&gt;deadline&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.CancelScope.shield&quot;&gt;&lt;code&gt;shield&lt;/code&gt;&lt;/a&gt; attributes; these may be freely modified after construction, whether or not the scope has been entered yet, and changes take immediate effect.</source>
          <target state="translated">&lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; 의&lt;/a&gt; (가) 범위의 취소에 대한 생성자는 초기 값을 사용 &lt;a href=&quot;#trio.CancelScope.deadline&quot;&gt; &lt;code&gt;deadline&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.CancelScope.shield&quot;&gt; &lt;code&gt;shield&lt;/code&gt; &lt;/a&gt; 특성을; 이들은 스코프가 아직 입력되었는지 여부에 관계없이 구성 후에 자유롭게 수정 될 수 있으며 변경 사항은 즉시 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3e93c721d5334efb64815d725431dc0496846ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reference-testing#module-trio.testing&quot;&gt;&lt;code&gt;trio.testing&lt;/code&gt;&lt;/a&gt; module provides a set of &lt;a href=&quot;reference-testing#testing-streams&quot;&gt;flexible in-memory stream object implementations&lt;/a&gt;, so if you have a protocol implementation to test then you can can start two tasks, set up a virtual &amp;ldquo;socket&amp;rdquo; connecting them, and then do things like inject random-but-repeatable delays into the connection.</source>
          <target state="translated">&lt;a href=&quot;reference-testing#module-trio.testing&quot;&gt; &lt;code&gt;trio.testing&lt;/code&gt; &lt;/a&gt; 모듈은 세트 제공 &lt;a href=&quot;reference-testing#testing-streams&quot;&gt;유연한 메모리 스트림 객체 구현을&lt;/a&gt; 당신이 그 (것)들을 연결하는 가상 &quot;소켓&quot;를 설정 한 다음 두 개의 작업을 시작할 수 있습니다 테스트에 대한 프로토콜 구현이 있고, 주입 한 후 같은 일을 할 그렇다면, 임의의 반복 가능한 연결 지연.</target>
        </trans-unit>
        <trans-unit id="09b5d3a08ea757fadb98a4225154f91508d3f13f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async_fn&lt;/code&gt; must accept a &lt;code&gt;task_status&lt;/code&gt; keyword argument, and it must make sure that it (or someone) eventually calls &lt;code&gt;task_status.started()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;async_fn&lt;/code&gt; 는 수용해야 &lt;code&gt;task_status&lt;/code&gt; 키워드 인수를하고 있는지 그 (또는 사람) 결국 호출을 확인해야합니다 &lt;code&gt;task_status.started()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f895f76bf1979f9940415d53c288e42d5e8a898" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cancel_scope&lt;/code&gt; object also allows you to check or adjust this scope&amp;rsquo;s deadline, explicitly trigger a cancellation without waiting for the deadline, check if the scope has already been cancelled, and so forth &amp;ndash; see &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; below for the full details.</source>
          <target state="translated">&lt;code&gt;cancel_scope&lt;/code&gt; 의 참조 - 객체는 확인하거나이 범위의 기한을 조정, 명시 적으로 기한을 기다리지 않고 취소를 트리거, 범위가 이미 취소되어 있는지 확인하고 등을 할 수 있습니다 &lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; 를&lt;/a&gt; 전체 내용은 아래.</target>
        </trans-unit>
        <trans-unit id="69e23230a2bcee3af46d41ce7a31ade877e491f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;command&lt;/code&gt; passed at construction time, specifying the process to execute and its arguments.</source>
          <target state="translated">&lt;code&gt;command&lt;/code&gt; 실행]하는 과정과 인수를 지정하여 건설 한 번에 통과했다.</target>
        </trans-unit>
        <trans-unit id="063f67b92b596d191b8f84a0a83fc8f83c79740b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;detach&lt;/code&gt; method, if present, returns an async file object.</source>
          <target state="translated">&lt;code&gt;detach&lt;/code&gt; 방법은, 존재하는 경우, 비동기 파일 개체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1bfb97a4bbb5e07af262081e3f1c7ef329411374" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;limiter&lt;/code&gt; is only released after the thread has &lt;em&gt;actually&lt;/em&gt; finished &amp;ndash; which in the case of cancellation may be some time after this function has returned. If &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; finishes before the thread does, then the limiter release method will never be called at all.</source>
          <target state="translated">&lt;code&gt;limiter&lt;/code&gt; 스레드가 후에 만 해제 &lt;em&gt;실제로&lt;/em&gt; 이 함수가 리턴 된 후에 취소의 경우에 약간의 시간 일 수있다 - 마쳤다. 경우 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 스레드보다 먼저 완료 한 후 제한 해제 방법은 전혀 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39e88286f1b3b8ffdc9fa1f82e7c0888d475d325" translate="yes" xml:space="preserve">
          <source>The SSH protocol provides the ability to multiplex bidirectional &amp;ldquo;channels&amp;rdquo; on top of a single encrypted connection. A Trio implementation of SSH could expose these channels as &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;HalfCloseableStream&lt;/code&gt;&lt;/a&gt; objects, and calling &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt;&lt;code&gt;send_eof()&lt;/code&gt;&lt;/a&gt; would send an &lt;code&gt;SSH_MSG_CHANNEL_EOF&lt;/code&gt; request (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4254#section-5.3&quot;&gt;RFC 4254 &amp;sect;5.3&lt;/a&gt;).</source>
          <target state="translated">SSH 프로토콜은 단일 암호화 연결 위에서 양방향 &quot;채널&quot;을 다중화하는 기능을 제공합니다. SSH의 Trio 구현은 이러한 채널을 &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;HalfCloseableStream&lt;/code&gt; &lt;/a&gt; 객체 로 노출 할 수 있으며 &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt; &lt;code&gt;send_eof()&lt;/code&gt; &lt;/a&gt; 호출 하면 &lt;code&gt;SSH_MSG_CHANNEL_EOF&lt;/code&gt; 요청 이 전송됩니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc4254#section-5.3&quot;&gt;RFC 4254 &amp;sect;5.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e14f4dc6e5377f931e4c2a51d7d47887a2aa40b7" translate="yes" xml:space="preserve">
          <source>The SSL protocol requires an initial handshake to exchange certificates, select cryptographic keys, and so forth, before any actual data can be sent or received. You don&amp;rsquo;t have to call this method; if you don&amp;rsquo;t, then &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; will automatically peform the handshake as needed, the first time you try to send or receive data. But if you want to trigger it manually &amp;ndash; for example, because you want to look at the peer&amp;rsquo;s certificate before you start talking to them &amp;ndash; then you can call this method.</source>
          <target state="translated">SSL 프로토콜에는 실제 데이터를 보내거나 받기 전에 인증서를 교환하고 암호화 키를 선택하는 등의 초기 핸드 셰이크가 필요합니다. 이 메소드를 호출 할 필요는 없습니다. 그렇지 않으면 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 은 처음으로 데이터를 보내거나받을 때 필요에 따라 자동으로 핸드 셰이크를 수행합니다. 그러나 상대방과 대화하기 전에 피어의 인증서를보고자하는 등 수동으로 트리거하려는 경우이 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24a88fd10b6d826da9e0fd3c37c9c98e67fb3304" translate="yes" xml:space="preserve">
          <source>The Task that opened this nursery.</source>
          <target state="translated">이 보육원을 연 과제.</target>
        </trans-unit>
        <trans-unit id="0037b005605d9473a07d1ff9c8c58a29834eb372" translate="yes" xml:space="preserve">
          <source>The Trio &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; will continue to exist, but will be suspended until you use &lt;a href=&quot;#trio.hazmat.reattach_detached_coroutine_object&quot;&gt;&lt;code&gt;reattach_detached_coroutine_object()&lt;/code&gt;&lt;/a&gt; to resume it. In the mean time, you can use another coroutine runner to schedule the coroutine object. In fact, you have to &amp;ndash; the function doesn&amp;rsquo;t return until the coroutine is advanced from outside.</source>
          <target state="translated">Trio &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 는 계속 존재하지만 &lt;a href=&quot;#trio.hazmat.reattach_detached_coroutine_object&quot;&gt; &lt;code&gt;reattach_detached_coroutine_object()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 다시 시작할 때까지 일시 중지 됩니다. 그 동안 다른 코 루틴 러너를 사용하여 코 루틴 개체를 예약 할 수 있습니다. 실제로, 코 루틴이 외부에서 전진 할 때까지 함수가 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="91b3715a1bc1d0217b9fa263b8eb097fe34e0f6a" translate="yes" xml:space="preserve">
          <source>The Trio project&amp;rsquo;s goal is to produce a production-quality, &lt;a href=&quot;https://github.com/python-trio/trio/blob/master/LICENSE&quot;&gt;permissively licensed&lt;/a&gt;, async/await-native I/O library for Python. Like all async libraries, its main purpose is to help you write programs that do &lt;strong&gt;multiple things at the same time&lt;/strong&gt; with &lt;strong&gt;parallelized I/O&lt;/strong&gt;. A web spider that wants to fetch lots of pages in parallel, a web server that needs to juggle lots of downloads and websocket connections at the same time, a process supervisor monitoring multiple subprocesses&amp;hellip; that sort of thing. Compared to other libraries, Trio attempts to distinguish itself with an obsessive focus on &lt;strong&gt;usability&lt;/strong&gt; and &lt;strong&gt;correctness&lt;/strong&gt;. Concurrency is complicated; we try to make it &lt;em&gt;easy&lt;/em&gt; to get things &lt;em&gt;right&lt;/em&gt;.</source>
          <target state="translated">Trio 프로젝트의 목표는 프로덕션 용으로 &lt;a href=&quot;https://github.com/python-trio/trio/blob/master/LICENSE&quot;&gt;허가 된 허가 된&lt;/a&gt; 비동기 / 대기 네이티브 I / O 라이브러리를 Python 용으로 제작하는 것입니다. 모든 비동기 라이브러리와 마찬가지로, 그 주요 목적은 당신이 프로그램을 쓸 수 있도록하는 것입니다 &lt;strong&gt;동시에 여러 가지&lt;/strong&gt; 로 &lt;strong&gt;병렬 I / O를&lt;/strong&gt; . 많은 페이지를 병렬로 가져 오려는 웹 스파이더, 많은 다운로드 및 웹 소켓 연결을 동시에 저글링해야하는 웹 서버, 여러 하위 프로세스를 모니터링하는 프로세스 관리자&amp;hellip; 다른 라이브러리와 비교하여 Trio는 &lt;strong&gt;사용&lt;/strong&gt; 성과 &lt;strong&gt;정확성&lt;/strong&gt; 에 대한 집착적인 초점으로 자신을 구별하려고 시도 &lt;strong&gt;합니다&lt;/strong&gt; . 동시성은 복잡합니다. 우리 는 물건을 &lt;em&gt;쉽게&lt;/em&gt; 얻을 수 있도록 노력합니다&lt;em&gt;맞아&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="687057d329e69f8ab7df756c5d5e8198fecaf157" translate="yes" xml:space="preserve">
          <source>The Trio socket object that this stream wraps.</source>
          <target state="translated">이 스트림이 랩하는 Trio 소켓 객체입니다.</target>
        </trans-unit>
        <trans-unit id="cba6eddc865e8ef02041cf8e92b113b668fdb1fa" translate="yes" xml:space="preserve">
          <source>The abstract Stream API</source>
          <target state="translated">추상 스트림 API</target>
        </trans-unit>
        <trans-unit id="ed1ab01ce9f6eeb35a966504829dfe0650d97783" translate="yes" xml:space="preserve">
          <source>The amount of capacity that&amp;rsquo;s available to use.</source>
          <target state="translated">사용 가능한 용량입니다.</target>
        </trans-unit>
        <trans-unit id="27aed0b7977904cec1e146409f5e000ca057c3cc" translate="yes" xml:space="preserve">
          <source>The amount of capacity that&amp;rsquo;s currently in use.</source>
          <target state="translated">현재 사용중인 용량입니다.</target>
        </trans-unit>
        <trans-unit id="f05a5bfc3a671c87ae02936d446663b7d98d9b51" translate="yes" xml:space="preserve">
          <source>The async iterator blocks until a signal arrives, and then yields it.</source>
          <target state="translated">비동기 반복기는 신호가 도착할 때까지 차단 한 다음 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ff85645d494e8892b98a41f73ef597d781b10cf2" translate="yes" xml:space="preserve">
          <source>The basic interface for running a subprocess start-to-finish is &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;trio.run_process()&lt;/code&gt;&lt;/a&gt;. It always waits for the subprocess to exit before returning, so there&amp;rsquo;s no need to worry about leaving a process running by mistake after you&amp;rsquo;ve gone on to do other things. &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process()&lt;/code&gt;&lt;/a&gt; is similar to the standard library &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.run&quot;&gt;&lt;code&gt;subprocess.run()&lt;/code&gt;&lt;/a&gt; function, but tries to have safer defaults: with no options, the subprocess&amp;rsquo;s input is empty rather than coming from the user&amp;rsquo;s terminal, and a failure in the subprocess will be propagated as a &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError&quot;&gt;&lt;code&gt;subprocess.CalledProcessError&lt;/code&gt;&lt;/a&gt; exception. Of course, these defaults can be changed where necessary.</source>
          <target state="translated">서브 프로세스 시작-완료를 실행하기위한 기본 인터페이스는 &lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;trio.run_process()&lt;/code&gt; &lt;/a&gt; 입니다. 리턴하기 전에 항상 서브 프로세스가 종료 될 때까지 대기하므로 다른 작업을 수행 한 후에 실수로 프로세스를 실행하는 것에 대해 걱정할 필요가 없습니다. &lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process()&lt;/code&gt; &lt;/a&gt; 는 표준 라이브러리 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.run&quot;&gt; &lt;code&gt;subprocess.run()&lt;/code&gt; &lt;/a&gt; 함수 와 유사 하지만 더 안전한 기본값을 사용하려고 시도합니다. 옵션이 없으면 하위 프로세스의 입력이 사용자의 터미널에서 오는 것이 아니라 비어 있으며 하위 프로세스의 실패가 다음과 같이 전파됩니다. &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError&quot;&gt; &lt;code&gt;subprocess.CalledProcessError&lt;/code&gt; 의&lt;/a&gt; 예외입니다. 물론 이러한 기본값은 필요한 경우 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b090dfb35042436a7ca99fd5410fd44306c03217" translate="yes" xml:space="preserve">
          <source>The call is effectively run as part of a system task (see &lt;a href=&quot;#trio.hazmat.spawn_system_task&quot;&gt;&lt;code&gt;spawn_system_task()&lt;/code&gt;&lt;/a&gt;). In particular this means that:</source>
          <target state="translated">호출은 시스템 작업의 일부로 효과적으로 실행됩니다 ( &lt;a href=&quot;#trio.hazmat.spawn_system_task&quot;&gt; &lt;code&gt;spawn_system_task()&lt;/code&gt; &lt;/a&gt; 참조 ). 특히 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2e085c84fa0bd56c6a1744858621eddc3529f1ab" translate="yes" xml:space="preserve">
          <source>The call will happen &amp;ldquo;soon&amp;rdquo;, but there&amp;rsquo;s no guarantee about exactly when, and no mechanism provided for finding out when it&amp;rsquo;s happened. If you need this, you&amp;rsquo;ll have to build your own.</source>
          <target state="translated">전화는 &quot;곧&quot;일어날 것이지만, 언제 정확한지에 대한 보장은 없으며, 언제 발생했는지를 알기위한 메커니즘도 제공되지 않습니다. 이것이 필요한 경우 자신 만의 것을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="f65883a9e5f4663eec2ec83235e2b12a73452383" translate="yes" xml:space="preserve">
          <source>The call&amp;rsquo;s context transitions to a cancelled state (e.g. due to a timeout expiring). When this happens, the &lt;code&gt;abort_func&lt;/code&gt; is called. Its interface looks like:</source>
          <target state="translated">통화 컨텍스트가 취소 된 상태로 전환됩니다 (예 : 시간 초과 만료로 인해). 이 경우 &lt;code&gt;abort_func&lt;/code&gt; 가 호출됩니다. 인터페이스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5fbb59f871095d18125dac21e3ce5f6c4a428f18" translate="yes" xml:space="preserve">
          <source>The child process runs in the same process group as the parent Trio process, so a Ctrl+C will be delivered simultaneously to both parent and child. If you don&amp;rsquo;t want this behavior, consult your platform&amp;rsquo;s documentation for starting child processes in a different process group.</source>
          <target state="translated">자식 프로세스는 부모 Trio 프로세스와 동일한 프로세스 그룹에서 실행되므로 Ctrl + C는 부모와 자식 모두에게 동시에 전달됩니다. 이 동작을 원하지 않으면 다른 프로세스 그룹에서 하위 프로세스를 시작하기위한 플랫폼 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c976c6c8d5145bd4ff6affacb6c3f1362c034af5" translate="yes" xml:space="preserve">
          <source>The child task inherits its parent nursery&amp;rsquo;s cancel scopes.</source>
          <target state="translated">자식 작업은 부모 보육원의 취소 범위를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="090b8413d6d5997349650354696f3c9148019f8b" translate="yes" xml:space="preserve">
          <source>The clock keeps an eye on the run loop, and if at any point it detects that all tasks have been blocked for this many real seconds (i.e., according to the actual clock, not this clock), then the clock automatically jumps ahead to the run loop&amp;rsquo;s next scheduled timeout. Default is &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt;&lt;code&gt;math.inf&lt;/code&gt;&lt;/a&gt;, i.e., to never autojump. You can assign to this attribute to change it.</source>
          <target state="translated">시계는 런 루프를 주시하고, 어떤 시점에서 모든 실제 작업이이 많은 실제 초 동안 (즉,이 시계가 아닌 실제 시계에 따라) 차단되었음을 감지하면 시계가 자동으로 앞쪽으로 이동합니다. 루프의 다음 예정된 시간 초과를 실행합니다. 기본값은 &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt; &lt;code&gt;math.inf&lt;/code&gt; 입니다&lt;/a&gt; . 즉, 절대 자동 점프하지 않습니다. 이 속성에 할당하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdc3a0eca08ee71b9b3549872b59ce6be02757ec" translate="yes" xml:space="preserve">
          <source>The clones all share the same underlying channel. Whenever a clone &lt;a href=&quot;#trio.MemoryReceiveChannel.receive&quot;&gt;&lt;code&gt;receive()&lt;/code&gt;&lt;/a&gt;s a value, it is removed from the channel and the other clones do &lt;em&gt;not&lt;/em&gt; receive that value. If you want to send multiple copies of the same stream of values to multiple destinations, like &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools.tee&quot;&gt;&lt;code&gt;itertools.tee()&lt;/code&gt;&lt;/a&gt;, then you need to find some other solution; this method does &lt;em&gt;not&lt;/em&gt; do that.</source>
          <target state="translated">클론은 모두 동일한 기본 채널을 공유합니다. 클론 &lt;a href=&quot;#trio.MemoryReceiveChannel.receive&quot;&gt; &lt;code&gt;receive()&lt;/code&gt; &lt;/a&gt; sa 값은 채널에서 제거되고 다른 클론은 해당 값을받지 &lt;em&gt;않습니다&lt;/em&gt; . &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools.tee&quot;&gt; &lt;code&gt;itertools.tee()&lt;/code&gt; &lt;/a&gt; 와 같이 동일한 값 스트림의 여러 사본을 여러 대상으로 보내려면 다른 솔루션을 찾아야합니다. 이 방법은 그렇게 하지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8484bcc0221be6040109ffa7d83b7570997846cf" translate="yes" xml:space="preserve">
          <source>The command to run and its arguments usually must be passed to Trio&amp;rsquo;s subprocess APIs as a sequence of strings, where the first element in the sequence specifies the command to run and the remaining elements specify its arguments, one argument per element. This form is used because it avoids potential quoting pitfalls; for example, you can run &lt;code&gt;[&quot;cp&quot;, &quot;-f&quot;, source_file, dest_file]&lt;/code&gt; without worrying about whether &lt;code&gt;source_file&lt;/code&gt; or &lt;code&gt;dest_file&lt;/code&gt; contains spaces.</source>
          <target state="translated">실행할 명령과 인수는 일반적으로 문자열 시퀀스로 Trio의 하위 프로세스 API에 전달되어야합니다. 여기서 시퀀스의 첫 번째 요소는 실행할 명령을 지정하고 나머지 요소는 해당 인수를 요소 당 하나의 인수로 지정합니다. 이 형식은 잠재적 인 인용 함정을 피하기 때문에 사용됩니다. 예를 들어, &lt;code&gt;source_file&lt;/code&gt; 또는 &lt;code&gt;dest_file&lt;/code&gt; 에 공백이 있는지 걱정하지 않고 &lt;code&gt;[&quot;cp&quot;, &quot;-f&quot;, source_file, dest_file]&lt;/code&gt; 을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4730db3841ecac8c8cf89e3a6be900006068c1f2" translate="yes" xml:space="preserve">
          <source>The context manager &lt;code&gt;__enter__&lt;/code&gt; returns the &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; object itself, so you can also write &lt;code&gt;with trio.CancelScope() as
cancel_scope:&lt;/code&gt;.</source>
          <target state="translated">컨텍스트 관리자 &lt;code&gt;__enter__&lt;/code&gt; 는 &lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; &lt;/a&gt; 객체 자체를 반환 하므로 &lt;code&gt;with trio.CancelScope() as cancel_scope:&lt;/code&gt; 쓸 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc3186b88676ea5d5847e4ef990e5751bbba3807" translate="yes" xml:space="preserve">
          <source>The conventional way to define &lt;code&gt;async_fn&lt;/code&gt; is like:</source>
          <target state="translated">&lt;code&gt;async_fn&lt;/code&gt; 을 정의하는 일반적인 방법 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="285a971ece21b42e0c4e6df991ed9acdbc0ef226" translate="yes" xml:space="preserve">
          <source>The core channel API is defined by the abstract base classes &lt;a href=&quot;reference-io#trio.abc.SendChannel&quot;&gt;&lt;code&gt;trio.abc.SendChannel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;trio.abc.ReceiveChannel&lt;/code&gt;&lt;/a&gt;. You can use these to implement your own custom channels, that do things like pass objects between processes or over the network. But in many cases, you just want to pass objects between different tasks inside a single process, and for that you can use &lt;a href=&quot;#trio.open_memory_channel&quot;&gt;&lt;code&gt;trio.open_memory_channel()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">핵심 채널 API는 추상 기본 클래스 &lt;a href=&quot;reference-io#trio.abc.SendChannel&quot;&gt; &lt;code&gt;trio.abc.SendChannel&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;trio.abc.ReceiveChannel&lt;/code&gt; 에&lt;/a&gt; 의해 정의됩니다 . 이를 사용하여 프로세스간에 또는 네트워크를 통해 객체를 전달하는 것과 같은 고유의 사용자 정의 채널을 구현할 수 있습니다. 그러나 많은 경우 단일 프로세스 내에서 서로 다른 작업간에 객체를 전달하려고하며 &lt;a href=&quot;#trio.open_memory_channel&quot;&gt; &lt;code&gt;trio.open_memory_channel()&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="616f1878bad341382d56b04b9e33c8f93029c10b" translate="yes" xml:space="preserve">
          <source>The current clock</source>
          <target state="translated">현재 시계</target>
        </trans-unit>
        <trans-unit id="4995ded951b2fbe16c164c4c7f4d5f2dc2fffe22" translate="yes" xml:space="preserve">
          <source>The current time.</source>
          <target state="translated">현재 시간</target>
        </trans-unit>
        <trans-unit id="d687bbc14082046996832ddcdec42c12e4cae031" translate="yes" xml:space="preserve">
          <source>The current value of the semaphore.</source>
          <target state="translated">세마포어의 현재 값.</target>
        </trans-unit>
        <trans-unit id="3eb350ac6cebc4b1fa0724100f48143c6b0ab33d" translate="yes" xml:space="preserve">
          <source>The data received.</source>
          <target state="translated">받은 데이터.</target>
        </trans-unit>
        <trans-unit id="9036f43c367d4a503f60d7664967b2259da5ae52" translate="yes" xml:space="preserve">
          <source>The default behavior is nice because it means that even if you accidentally write an infinite loop that never executes any checkpoints, then you can still break out of it using control-C. The alternative behavior is nice if you&amp;rsquo;re paranoid about a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; at just the wrong place leaving your program in an inconsistent state, because it means that you only have to worry about &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; at the exact same places where you already have to worry about &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">체크 포인트를 절대 실행하지 않는 무한 루프를 실수로 작성하더라도 control-C를 사용하여 여전히 벗어날 수 있기 때문에 기본 동작은 좋습니다. 프로그램이 일관성이없는 상태를 유지하는 잘못된 장소에서 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 에 대해 편집증을 앓고 있다면 다른 행동이 좋습니다 . 왜냐하면 이미 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 해야 할 곳과 동일한 곳에서 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 에 대해서만 걱정하면된다는 의미이기 때문입니다. .</target>
        </trans-unit>
        <trans-unit id="0e55b739f210dc55513c361f9fe51be776304fc5" translate="yes" xml:space="preserve">
          <source>The default cleanup logic is often sufficient for simple cases, but what if you want a more sophisticated supervisor? For example, maybe you have &lt;a href=&quot;http://learnyousomeerlang.com/supervisors&quot;&gt;Erlang envy&lt;/a&gt; and want features like automatic restart of crashed tasks. Trio itself doesn&amp;rsquo;t provide these kinds of features, but you can build them on top; Trio&amp;rsquo;s goal is to enforce basic hygiene and then get out of your way. (Specifically: Trio won&amp;rsquo;t let you build a supervisor that exits and leaves orphaned tasks behind, and if you have an unhandled exception due to bugs or laziness then Trio will make sure they propagate.) And then you can wrap your fancy supervisor up in a library and put it on PyPI, because supervisors are tricky and there&amp;rsquo;s no reason everyone should have to write their own.</source>
          <target state="translated">기본 정리 논리는 간단한 경우에 충분하지만보다 정교한 감독자를 원한다면 어떻게해야합니까? 예를 들어, &lt;a href=&quot;http://learnyousomeerlang.com/supervisors&quot;&gt;Erlang 부러워&lt;/a&gt; 하고 충돌 한 작업의 자동 재시작과 같은 기능을 원할 수 있습니다. Trio 자체는 이러한 종류의 기능을 제공하지 않지만 그 위에 기능을 구축 할 수 있습니다. Trio의 목표는 기본 위생을 시행 한 다음 벗어나는 것입니다. (구체적으로 : Trio를 사용하면 고아 작업을 종료하고 떠나는 관리자를 만들 수 없으며 버그 나 게으름으로 인해 처리되지 않은 예외가 발생하면 Trio가 전파되도록해야합니다.) 그러면 멋진 관리자를 감쌀 수 있습니다. 관리자가 까다 롭고 모든 사람이 직접 작성해야 할 이유가 없기 때문에 라이브러리에서 PyPI에 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="5c9ed5e68e8b87af228bafd594375bf1414c72bb" translate="yes" xml:space="preserve">
          <source>The default clock is currently implemented as &lt;a href=&quot;https://docs.python.org/3/library/time.html#time.perf_counter&quot;&gt;&lt;code&gt;time.perf_counter()&lt;/code&gt;&lt;/a&gt; plus a large random offset. The idea here is to catch code that accidentally uses &lt;a href=&quot;https://docs.python.org/3/library/time.html#time.perf_counter&quot;&gt;&lt;code&gt;time.perf_counter()&lt;/code&gt;&lt;/a&gt; early, which should help keep our options open for &lt;a href=&quot;https://github.com/python-trio/trio/issues/33&quot;&gt;changing the clock implementation later&lt;/a&gt;, and (more importantly) make sure you can be confident that custom clocks like &lt;a href=&quot;reference-testing#trio.testing.MockClock&quot;&gt;&lt;code&gt;trio.testing.MockClock&lt;/code&gt;&lt;/a&gt; will work with third-party libraries you don&amp;rsquo;t control.</source>
          <target state="translated">기본 클럭은 현재 &lt;a href=&quot;https://docs.python.org/3/library/time.html#time.perf_counter&quot;&gt; &lt;code&gt;time.perf_counter()&lt;/code&gt; &lt;/a&gt; 및 큰 임의 오프셋으로 구현됩니다 . 여기서 아이디어는 실수로 &lt;a href=&quot;https://docs.python.org/3/library/time.html#time.perf_counter&quot;&gt; &lt;code&gt;time.perf_counter()&lt;/code&gt; &lt;/a&gt; 일찍 사용하는 코드를 포착 &lt;a href=&quot;https://github.com/python-trio/trio/issues/33&quot;&gt;하여 나중에 시계 구현&lt;/a&gt; 을 변경하기 위해 옵션을 열어 두는 것입니다 (더 중요한 것은 &lt;a href=&quot;reference-testing#trio.testing.MockClock&quot;&gt; &lt;code&gt;trio.testing.MockClock&lt;/code&gt; &lt;/a&gt; 과 같은 사용자 정의 시계를 확신 할 수 있음) . MockClock 은 제어하지 않는 타사 라이브러리에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="161d86aa18f9fc36797e67f6ae10b87299de29e3" translate="yes" xml:space="preserve">
          <source>The difference between &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt;&lt;code&gt;send_eof()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; is that &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt;&lt;code&gt;send_eof()&lt;/code&gt;&lt;/a&gt; is a &lt;em&gt;unidirectional&lt;/em&gt; end-of-file indication. After you call this method, you shouldn&amp;rsquo;t try sending any more data on this stream, and your remote peer should receive an end-of-file indication (eventually, after receiving all the data you sent before that). But, they may continue to send data to you, and you can continue to receive it by calling &lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt;&lt;code&gt;receive_some()&lt;/code&gt;&lt;/a&gt;. You can think of it as calling &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; on just the &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt; &amp;ldquo;half&amp;rdquo; of the stream object (and in fact that&amp;rsquo;s literally how &lt;a href=&quot;#trio.StapledStream&quot;&gt;&lt;code&gt;trio.StapledStream&lt;/code&gt;&lt;/a&gt; implements it).</source>
          <target state="translated">차이 &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt; &lt;code&gt;send_eof()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 즉 &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt; &lt;code&gt;send_eof()&lt;/code&gt; &lt;/a&gt; A는 &lt;em&gt;단방향&lt;/em&gt; 파일 끝 표시. 이 메서드를 호출 한 후에는이 스트림에서 더 이상 데이터를 보내려고 시도하지 않아야하며 원격 피어는 파일 끝 표시를 받아야합니다 (결국, 그 전에 보낸 모든 데이터를받은 후). 그러나 계속해서 데이터를 보낼 수 있으며 &lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt; &lt;code&gt;receive_some()&lt;/code&gt; &lt;/a&gt; 을 호출하여 계속해서받을 수 있습니다 . 스트림 객체 의 &lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; &amp;ldquo;반쪽&amp;rdquo; 에서 &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 를 호출하는 것으로 생각할 수 있습니다 (실제로 &lt;a href=&quot;#trio.StapledStream&quot;&gt; &lt;code&gt;trio.StapledStream&lt;/code&gt; 이&lt;/a&gt; 구현하는 방식입니다).</target>
        </trans-unit>
        <trans-unit id="f54f20adf46b020768fc2d9699f83c2a84a5dbee" translate="yes" xml:space="preserve">
          <source>The difference between &lt;a href=&quot;#trio.sleep&quot;&gt;&lt;code&gt;sleep()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.sleep_until&quot;&gt;&lt;code&gt;sleep_until()&lt;/code&gt;&lt;/a&gt; is that the former takes a relative time and the latter takes an absolute time.</source>
          <target state="translated">&lt;a href=&quot;#trio.sleep&quot;&gt; &lt;code&gt;sleep()&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;#trio.sleep_until&quot;&gt; &lt;code&gt;sleep_until()&lt;/code&gt; &lt;/a&gt; 의 차이점 은 전자는 상대적 시간이 걸리고 후자는 절대 시간이 걸린다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="73cc2ba69f4c206ad58a296445de0bca80474d34" translate="yes" xml:space="preserve">
          <source>The downside of this kind of thread pool is that sometimes, you need more sophisticated logic for controlling how many threads are run at once. For example, you might want a policy like &amp;ldquo;at most 20 threads total, but no more than 3 of those can be running jobs associated with the same user account&amp;rdquo;, or you might want a pool whose size is dynamically adjusted over time in response to system conditions.</source>
          <target state="translated">이러한 종류의 스레드 풀의 단점은 때때로 한 번에 실행되는 스레드 수를 제어하기 위해 더 정교한 논리가 필요하다는 것입니다. 예를 들어, &quot;총 20 개의 스레드 만 가능하지만 그 중 3 개 이상이 동일한 사용자 계정과 연관된 작업을 실행할 수 있습니다&quot;와 같은 정책을 원하거나 시간에 따라 크기가 동적으로 조정되는 풀을 원할 수 있습니다. 시스템 조건.</target>
        </trans-unit>
        <trans-unit id="35be47a84f944c2be421f7a4c36aaf2ef2022432" translate="yes" xml:space="preserve">
          <source>The end result is that Trio has successfully cancelled exactly the work that was happening within the scope that was cancelled.</source>
          <target state="translated">결과적으로 Trio는 취소 된 범위 내에서 발생한 작업을 정확하게 취소했습니다.</target>
        </trans-unit>
        <trans-unit id="0a65d9d853aa11c16016bf7c9ce9148c89cc1dcf" translate="yes" xml:space="preserve">
          <source>The end result is that data automatically flows from the &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;code&gt;MemorySendStream&lt;/code&gt;&lt;/a&gt; to the &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;code&gt;MemoryReceiveStream&lt;/code&gt;&lt;/a&gt;. But you&amp;rsquo;re also free to rearrange things however you like. For example, you can temporarily set the &lt;a href=&quot;#trio.testing.MemorySendStream.send_all_hook&quot;&gt;&lt;code&gt;send_all_hook&lt;/code&gt;&lt;/a&gt; to None if you want to simulate a stall in data transmission. Or see &lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt;&lt;code&gt;memory_stream_pair()&lt;/code&gt;&lt;/a&gt; for a more elaborate example.</source>
          <target state="translated">결과적으로 데이터가 &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt; &lt;code&gt;MemorySendStream&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt; &lt;code&gt;MemoryReceiveStream&lt;/code&gt; &lt;/a&gt; 으로 자동으로 흐릅니다 . 그러나 원하는 것을 자유롭게 재 배열 할 수도 있습니다. 예를 들어, 데이터 전송시 스톨을 시뮬레이션하려는 경우 &lt;a href=&quot;#trio.testing.MemorySendStream.send_all_hook&quot;&gt; &lt;code&gt;send_all_hook&lt;/code&gt; &lt;/a&gt; 을 일시적 으로 없음 으로 설정할 수 있습니다 . 더 자세한 예는 &lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt; &lt;code&gt;memory_stream_pair()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c02286292f2ec8e799d942bfe364baa2b77891d9" translate="yes" xml:space="preserve">
          <source>The exit status of the process (an integer), or &lt;code&gt;None&lt;/code&gt; if it is not yet known to have exited.</source>
          <target state="translated">프로세스의 종료 상태 (정수) 또는 아직 종료되지 않은 경우 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="125adfc9dd9147da3a2e6de16b33684508367c26" translate="yes" xml:space="preserve">
          <source>The exit status of the process, or &lt;code&gt;None&lt;/code&gt; if it is still running; see &lt;a href=&quot;#trio.Process.returncode&quot;&gt;&lt;code&gt;returncode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프로세스의 종료 상태이거나 여전히 실행중인 경우 &lt;code&gt;None&lt;/code&gt; . &lt;a href=&quot;#trio.Process.returncode&quot;&gt; &lt;code&gt;returncode&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="56a77a4877253a18474ef745e005246f7f5751e2" translate="yes" xml:space="preserve">
          <source>The exit status of the process; see &lt;a href=&quot;#trio.Process.returncode&quot;&gt;&lt;code&gt;returncode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프로세스의 종료 상태 &lt;a href=&quot;#trio.Process.returncode&quot;&gt; &lt;code&gt;returncode&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="64142ed18435a7e0439ede425fac64c34f741197" translate="yes" xml:space="preserve">
          <source>The following methods are identical to their equivalents in &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt;&lt;code&gt;socket.socket()&lt;/code&gt;&lt;/a&gt;, except async, and the ones that take address arguments require pre-resolved addresses:</source>
          <target state="translated">다음 메소드는 async를 제외하고 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt; &lt;code&gt;socket.socket()&lt;/code&gt; &lt;/a&gt; 의 해당 메소드와 동일하며 주소 인수를 사용하는 메소드 에는 사전 해결 된 주소가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="27a7e32f93c8094ed84ed0c797a3d1d3450a48a0" translate="yes" xml:space="preserve">
          <source>The general idea is that at any given moment, &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; maintains a set of &amp;ldquo;instruments&amp;rdquo;, which are objects that implement the &lt;a href=&quot;#trio.abc.Instrument&quot;&gt;&lt;code&gt;trio.abc.Instrument&lt;/code&gt;&lt;/a&gt; interface. When an interesting event happens, it loops over these instruments and notifies them by calling an appropriate method. The tutorial has &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/tutorial.html#tutorial-instrument-example&quot;&gt;a simple example of using this for tracing&lt;/a&gt;.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#trio.abc.Instrument&quot;&gt; &lt;code&gt;trio.abc.Instrument&lt;/code&gt; &lt;/a&gt; 인터페이스 를 구현하는 객체 인 일련의 &quot;악기&quot;를 유지 관리합니다 . 흥미로운 이벤트가 발생하면 이러한 계측기를 반복하고 적절한 메소드를 호출하여 알려줍니다. 학습서에는 &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/tutorial.html#tutorial-instrument-example&quot;&gt;이를 추적에 사용하는 간단한 예제가&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e502d07802ec7eba2f0fb1852ed0486ee5e9106" translate="yes" xml:space="preserve">
          <source>The high-level network interface is built on top of our stream abstraction.</source>
          <target state="translated">높은 수준의 네트워크 인터페이스는 스트림 추상화 위에 구축됩니다.</target>
        </trans-unit>
        <trans-unit id="7f835797b23a892cd0ec30a65a33991b78d40543" translate="yes" xml:space="preserve">
          <source>The instrument API provides a standard way to add custom instrumentation to the run loop. Want to make a histogram of scheduling latencies, log a stack trace of any task that blocks the run loop for &amp;gt;50 ms, or measure what percentage of your process&amp;rsquo;s running time is spent waiting for I/O? This is the place.</source>
          <target state="translated">인스트루먼트 API는 런 루프에 커스텀 인스 트루먼 테이션을 추가하는 표준 방법을 제공합니다. 지연 시간 예약 히스토그램을 작성하고&amp;gt; 50ms 동안 실행 루프를 차단하는 모든 작업의 ​​스택 추적을 기록하거나 I / O를 기다리는 데 소요되는 프로세스 실행 시간의 백분율을 측정 하시겠습니까? 이곳입니다.</target>
        </trans-unit>
        <trans-unit id="8805f7990c95db20674c8cf0adbf6a62540abaa7" translate="yes" xml:space="preserve">
          <source>The interface for custom run loop clocks.</source>
          <target state="translated">커스텀 런 루프 클럭을위한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="8d2a9967f7c764df943ab1556c1344b5805ebda1" translate="yes" xml:space="preserve">
          <source>The interface for run loop instrumentation.</source>
          <target state="translated">런 루프 계측을위한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="24dad175acbf711fb3b0ec0ffe0f2c174484725f" translate="yes" xml:space="preserve">
          <source>The list of exception objects that this &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt; represents.</source>
          <target state="translated">이 &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; 가&lt;/a&gt; 나타내는 예외 객체의리스트입니다 .</target>
        </trans-unit>
        <trans-unit id="b1672ae196b4e642ba06023f24ab7cc43131e887" translate="yes" xml:space="preserve">
          <source>The local interface to bind to. This is passed to &lt;a href=&quot;#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt;&lt;/a&gt; with the &lt;code&gt;AI_PASSIVE&lt;/code&gt; flag set.</source>
          <target state="translated">바인딩 할 로컬 인터페이스입니다. 이는 전달한다 &lt;a href=&quot;#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo()&lt;/code&gt; &lt;/a&gt; 와 &lt;code&gt;AI_PASSIVE&lt;/code&gt; 플래그가 설정.</target>
        </trans-unit>
        <trans-unit id="14c98d1cac25a3b78cb6648f736ac16134a060c5" translate="yes" xml:space="preserve">
          <source>The maximum allowed value. May be None to indicate no limit.</source>
          <target state="translated">허용되는 최대 값. 제한 없음을 나타내려면 없음 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e07a666dfbfb8644fe55abda725387879d01201f" translate="yes" xml:space="preserve">
          <source>The most common reason to call this would be if you want to modify its &lt;a href=&quot;#trio.CapacityLimiter.total_tokens&quot;&gt;&lt;code&gt;total_tokens&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">이를 호출하는 가장 일반적인 이유는 &lt;a href=&quot;#trio.CapacityLimiter.total_tokens&quot;&gt; &lt;code&gt;total_tokens&lt;/code&gt; &lt;/a&gt; 속성 을 수정하려는 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="7511fb68df6cf2da5466a9d58a8996e5da043bc2" translate="yes" xml:space="preserve">
          <source>The next two functions are used &lt;em&gt;together&lt;/em&gt; to make up a checkpoint:</source>
          <target state="translated">다음 두 기능은 체크 포인트를 구성하기 위해 &lt;em&gt;함께&lt;/em&gt; 사용 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f81d0f7d0980e217423a2ccc40b05846cbdc06e4" translate="yes" xml:space="preserve">
          <source>The number of real seconds to sleep until the given deadline. May be &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt;&lt;code&gt;math.inf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 마감일까지 잠을 자게 될 실제 시간 (초)입니다. &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt; &lt;code&gt;math.inf&lt;/code&gt; &lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37eae6844d9390786325d85229c1ce9b532328ee" translate="yes" xml:space="preserve">
          <source>The nurseries this task contains.</source>
          <target state="translated">이 작업에 포함 된 보육원.</target>
        </trans-unit>
        <trans-unit id="177a7ce78b560282b7d992c4ec3372923f31b6c2" translate="yes" xml:space="preserve">
          <source>The nursery API</source>
          <target state="translated">보육원 API</target>
        </trans-unit>
        <trans-unit id="8d7ae1a4a8aa454bf6b6d79e73ec598b862fddd0" translate="yes" xml:space="preserve">
          <source>The nursery is marked as &amp;ldquo;closed&amp;rdquo;, meaning that no new tasks can be started inside it.</source>
          <target state="translated">보육원은&amp;ldquo;폐쇄&amp;rdquo;로 표시되어있어 새로운 작업을 시작할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e86ba7e9365d0994757a3cc78cdf4d4a2887a4b2" translate="yes" xml:space="preserve">
          <source>The nursery this task is inside (or None if this is the &amp;ldquo;init&amp;rdquo; task).</source>
          <target state="translated">이 작업이 포함 된 보육원 (또는 &quot;초기&quot;작업 인 경우에는 없음).</target>
        </trans-unit>
        <trans-unit id="a61b8d74747e89d4158a137ff8a09c9922960de0" translate="yes" xml:space="preserve">
          <source>The nursery will remain open until all child tasks have completed, or until it is cancelled, at which point it will cancel all its remaining child tasks and close.</source>
          <target state="translated">보육원은 모든 하위 작업이 완료 될 때까지 또는 취소 될 때까지 남아있는 모든 하위 작업을 취소하고 닫을 때까지 계속 열려 있습니다.</target>
        </trans-unit>
        <trans-unit id="e74f79510a42647a66bf3c95ba615073d3c63132" translate="yes" xml:space="preserve">
          <source>The port to listen on.</source>
          <target state="translated">수신 할 포트입니다.</target>
        </trans-unit>
        <trans-unit id="1121984a78f092b4bacac75ab91c9cb4d443a8c8" translate="yes" xml:space="preserve">
          <source>The previous hostname resolver (which may be None).</source>
          <target state="translated">이전 호스트 이름 확인자 (없음 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="47eb3fd202a96ce8b6174dec37d51f1fd66c70e2" translate="yes" xml:space="preserve">
          <source>The previous socket factory (which may be None).</source>
          <target state="translated">이전 소켓 팩토리 (None 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="4e2b927216cbc564308d285000e1f4433a148da5" translate="yes" xml:space="preserve">
          <source>The process ID of the child process managed by this object.</source>
          <target state="translated">이 객체가 관리하는 자식 프로세스의 프로세스 ID.</target>
        </trans-unit>
        <trans-unit id="5b93661739a17b00d39a4b1234f2fd70ed40f36e" translate="yes" xml:space="preserve">
          <source>The really important thing here is the producer&amp;rsquo;s &lt;code&gt;async with&lt;/code&gt; . When the producer exits, this closes the &lt;code&gt;send_channel&lt;/code&gt;, and that tells the consumer that no more messages are coming, so it can cleanly exit its &lt;code&gt;async for&lt;/code&gt; loop. Then the program shuts down because both tasks have exited.</source>
          <target state="translated">여기서 가장 중요한 &lt;code&gt;async with&lt;/code&gt; 제작자의 비동기입니다 . 생산자가 종료하면 &lt;code&gt;send_channel&lt;/code&gt; 이 닫히고 소비자에게 더 이상 메시지가 나오지 않음을 알리 므로 &lt;code&gt;async for&lt;/code&gt; 루프를 완전히 종료 할 수 있습니다 . 그런 다음 두 작업이 모두 종료되어 프로그램이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="0450c5182bceb6cce56fb0729c22a12ca6a38fb0" translate="yes" xml:space="preserve">
          <source>The reason we distinguish between Trio functions and other functions is that we can&amp;rsquo;t make any guarantees about third party code. Checkpoint-ness is a transitive property: if function A acts as a checkpoint, and you write a function that calls function A, then your function also acts as a checkpoint. If you don&amp;rsquo;t, then it isn&amp;rsquo;t. So there&amp;rsquo;s nothing stopping someone from writing a function like:</source>
          <target state="translated">우리가 Trio 기능과 다른 기능을 구별하는 이유는 타사 코드에 대해 보장 할 수 없기 때문입니다. 검사 점은 전이 속성입니다. 함수 A가 검사 점으로 작동하고 함수 A를 호출하는 함수를 작성하면 함수도 검사 점으로 작동합니다. 그렇지 않으면 그렇지 않습니다. 따라서 누군가가 다음과 같은 함수를 작성하는 것을 막을 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="5b79184643fc427f0f5451ad2bcbe471b0aff8ab" translate="yes" xml:space="preserve">
          <source>The run-local variant of a context variable.</source>
          <target state="translated">컨텍스트 변수의 로컬 실행 변형</target>
        </trans-unit>
        <trans-unit id="31631f2ee19f6c9eddba1efb6808eed41e256ce1" translate="yes" xml:space="preserve">
          <source>The solution here is simple once you see it: there&amp;rsquo;s no requirement that a nursery object stay in the task that created it! We can write code like this:</source>
          <target state="translated">여기에서 해결책을 찾으면 간단합니다. 보육원 개체를 만든 작업에 머물 필요가 없습니다! 다음과 같은 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55e76f19fc0627ed9227f3fd3880048d89598e1e" translate="yes" xml:space="preserve">
          <source>The standard library synchronization primitives have a variety of mechanisms for specifying timeouts and blocking behavior, and of signaling whether an operation returned due to success versus a timeout.</source>
          <target state="translated">표준 라이브러리 동기화 프리미티브에는 시간 초과를 지정하고 동작을 차단하고 성공과 시간 초과로 인해 작업이 반환되는지 여부를 시그널링하는 다양한 메커니즘이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dee7da4b40c8ed8470e444bb0b39967c3966f18" translate="yes" xml:space="preserve">
          <source>The total capacity available.</source>
          <target state="translated">사용 가능한 총 용량.</target>
        </trans-unit>
        <trans-unit id="3705e62e17c05ed2a283df571e34d9194fff82e9" translate="yes" xml:space="preserve">
          <source>The tutorial has a &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/tutorial.html#tutorial-instrument-example&quot;&gt;fully-worked example&lt;/a&gt; of defining a custom instrument to log Trio&amp;rsquo;s internal scheduling decisions.</source>
          <target state="translated">이 자습서에는 Trio의 내부 일정 결정을 기록하기 위해 사용자 지정 계측기를 정의 하는 &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/tutorial.html#tutorial-instrument-example&quot;&gt;완전한 예제&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="05291b85407b1a887472f9d782e55440c9965242" translate="yes" xml:space="preserve">
          <source>The two producers, A and B, send 3 messages apiece. These are then randomly distributed between the two consumers, X and Y. So we&amp;rsquo;re hoping to see some output like:</source>
          <target state="translated">두 생산자 A와 B는 각각 3 개의 메시지를 보냅니다. 그런 다음 두 소비자 X와 Y 사이에 무작위로 배포됩니다. 따라서 다음과 같은 결과를 기대합니다.</target>
        </trans-unit>
        <trans-unit id="5aa97c306d0b8d930fea25557eeb4fb3eb359691" translate="yes" xml:space="preserve">
          <source>The underlying &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#trio.StapledStream.receive_some&quot;&gt;&lt;code&gt;receive_some()&lt;/code&gt;&lt;/a&gt; is delegated to this object.</source>
          <target state="translated">기본이 &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#trio.StapledStream.receive_some&quot;&gt; &lt;code&gt;receive_some()&lt;/code&gt; &lt;/a&gt; 이이 객체에 위임되었습니다.</target>
        </trans-unit>
        <trans-unit id="f32b40ca1402eb2f4c81aefb795e70d012cce169" translate="yes" xml:space="preserve">
          <source>The underlying &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#trio.StapledStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.StapledStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt; are delegated to this object.</source>
          <target state="translated">기본 &lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#trio.StapledStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.StapledStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt; 이이 객체에 위임되었습니다.</target>
        </trans-unit>
        <trans-unit id="0ad23b6bb25552ac6357c4e430f7019864780286" translate="yes" xml:space="preserve">
          <source>The underlying listener that was passed to &lt;code&gt;__init__&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__init__&lt;/code&gt; 에 전달 된 기본 리스너입니다 .</target>
        </trans-unit>
        <trans-unit id="f33f2a0c4fd84dacf0327c8790e4bf617b9f380a" translate="yes" xml:space="preserve">
          <source>The underlying stream may be unidirectional, or bidirectional. If it&amp;rsquo;s bidirectional, then you probably want to also implement &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;, which makes your object a &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 스트림은 단방향 또는 양방향 일 수 있습니다. 양방향 인 경우 객체를 &lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; 으로&lt;/a&gt; 만드는 &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; 도 구현 하려고 합니다 .</target>
        </trans-unit>
        <trans-unit id="a6e839a070895f18f3a2d8c7670c54a0bc8fe015" translate="yes" xml:space="preserve">
          <source>The underlying stream may be unidirectional, or bidirectional. If it&amp;rsquo;s bidirectional, then you probably want to also implement &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt;, which makes your object a &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 스트림은 단방향 또는 양방향 일 수 있습니다. 양방향 인 경우 &lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; 을 구현 하여 객체를 &lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; 으로&lt;/a&gt; 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a8e841a341ca779f446431b59a0fdcb153b95e2" translate="yes" xml:space="preserve">
          <source>The underlying synchronous file object.</source>
          <target state="translated">기본 동기 파일 객체.</target>
        </trans-unit>
        <trans-unit id="8b2590649b5fca1121706db98f3737530bf8d4da" translate="yes" xml:space="preserve">
          <source>The underlying transport stream that was passed to &lt;code&gt;__init__&lt;/code&gt;. An example of when this would be useful is if you&amp;rsquo;re using &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; over a &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt; and want to call the &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;#trio.SocketStream.setsockopt&quot;&gt;&lt;code&gt;setsockopt()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">전달 된 기본 전송 스트림 &lt;code&gt;__init__&lt;/code&gt; . 당신이 사용하는 경우이 유용 할 때의 예는 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; 를&lt;/a&gt; 넘는 &lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; &lt;/a&gt; 와 통화 할 &lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#trio.SocketStream.setsockopt&quot;&gt; &lt;code&gt;setsockopt()&lt;/code&gt; &lt;/a&gt; 하는 방법.</target>
        </trans-unit>
        <trans-unit id="f623fc5e00614ae96a118b39b868c4f90851b815" translate="yes" xml:space="preserve">
          <source>The vast majority of Trio&amp;rsquo;s API is &lt;em&gt;not&lt;/em&gt; thread safe: it can only be used from inside a call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;. This manual doesn&amp;rsquo;t bother documenting this on individual calls; unless specifically noted otherwise, you should assume that it isn&amp;rsquo;t safe to call any Trio functions from anywhere except the Trio thread. (But &lt;a href=&quot;#threads&quot;&gt;see below&lt;/a&gt; if you really do need to work with threads.)</source>
          <target state="translated">대부분의 Trio API는 스레드로부터 안전 &lt;em&gt;하지 않습니다&lt;/em&gt; . &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 호출 내부에서만 사용할 수 있습니다 . 이 매뉴얼은 개별 통화에 대해이를 문서화하지 않습니다. 특별히 언급하지 않는 한, Trio 스레드를 제외한 다른 곳에서 Trio 함수를 호출하는 것이 안전하지 않다고 가정해야합니다. (하지만 실제로 스레드 작업이 필요한 경우 &lt;a href=&quot;#threads&quot;&gt;아래를 참조하십시오&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="039522b69359b3e56c31de8d1e26158ab6198376" translate="yes" xml:space="preserve">
          <source>Then tasks can come along and borrow a token out of the sack:</source>
          <target state="translated">그런 다음 작업을 수행하고 자루에서 토큰을 빌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8aed655f54fc986620011433879c1bf88c00c1fa" translate="yes" xml:space="preserve">
          <source>Then these both raise &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">그런 다음이 둘 다 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26f0adbdb0fabb432f18981f6cd29877bc3d70d3" translate="yes" xml:space="preserve">
          <source>Then you call &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;, passing in &lt;code&gt;abort_func&lt;/code&gt;, an &amp;ldquo;abort callback&amp;rdquo;.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 를 호출 하여&amp;ldquo;취소 콜백&amp;rdquo;인 &lt;code&gt;abort_func&lt;/code&gt; 를 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="7ceaee5b77c3b473fc92d1c8284b8ba959ee04c6" translate="yes" xml:space="preserve">
          <source>There are a few idiosyncratic cases where external constraints make it impossible to fully implement these semantics. These are always documented. There is also one systematic exception:</source>
          <target state="translated">외부 제약으로 인해 이러한 의미를 완전히 구현할 수없는 특이한 경우가 몇 가지 있습니다. 이들은 항상 문서화되어 있습니다. 체계적인 예외도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="8ccaa3636c24526c51e3cf2cf4bbb0add69c1e98" translate="yes" xml:space="preserve">
          <source>There are a few pieces here, so here&amp;rsquo;s how they fit together:</source>
          <target state="translated">여기에 몇 가지 조각이 있으므로 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f9b4b72d5e37ba916870f8ebadfd56db51bbd77e" translate="yes" xml:space="preserve">
          <source>There are two possibilities for what happens next:</source>
          <target state="translated">다음에 일어날 일에는 두 가지 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9b90250e8bd2eee9b2b8bf09f29e281e8809b4a" translate="yes" xml:space="preserve">
          <source>There are two versions of SSL/TLS commonly encountered in the wild: the standard version, and the version used for HTTPS (HTTP-over-SSL/TLS).</source>
          <target state="translated">일반적으로 두 가지 버전의 SSL / TLS가 있습니다. 표준 버전과 HTTPS (HTTP-over-SSL / TLS)에 사용되는 버전입니다.</target>
        </trans-unit>
        <trans-unit id="27e6946011051300b2bdacb518dcf327f5b5bd7b" translate="yes" xml:space="preserve">
          <source>There is a subtlety with how this method interacts with cancellation: when cancelled it will block to re-acquire the lock before raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;. This may cause cancellation to be less prompt than expected. The advantage is that it makes code like this work:</source>
          <target state="translated">이 메소드가 취소와 상호 작용하는 방식에는 미묘한 점이 있습니다. 취소하면 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 을 올리기 전에 잠금을 다시 확보하는 것이 차단됩니다 . 이로 인해 취소가 예상보다 덜 프롬프트 될 수 있습니다. 장점은 다음과 같은 코드를 작성한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bffd13f140e202626a214af6e92646e6022be490" translate="yes" xml:space="preserve">
          <source>There must be exactly one call to &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; for every call to &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;. (And when counting, keep in mind that returning &lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt;&lt;code&gt;Abort.SUCCEEDED&lt;/code&gt;&lt;/a&gt; from an abort callback is equivalent to calling &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; once.)</source>
          <target state="translated">&lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 호출 할 때마다 &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; 을 정확히 한 번만 호출해야 합니다. (그리고 계산할 때 중단 콜백에서 &lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt; &lt;code&gt;Abort.SUCCEEDED&lt;/code&gt; &lt;/a&gt; 를 반환 하는 것은 &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; 한 번 호출하는 것과 같습니다 .)</target>
        </trans-unit>
        <trans-unit id="7b29b5490f17425380aad05f050e2ab47d53179e" translate="yes" xml:space="preserve">
          <source>These are commonly used in cases where you have an operation that might-or-might-not block, and you want to implement Trio&amp;rsquo;s standard checkpoint semantics. Example:</source>
          <target state="translated">이들은 일반적으로 차단되거나 차단되지 않는 작업이 있고 Trio의 표준 체크 포인트 의미를 구현하려는 경우에 사용됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="3d0bc413452d0608c3c5668aad8331f5e3c73b1b" translate="yes" xml:space="preserve">
          <source>These classes are all guaranteed to be &amp;ldquo;fair&amp;rdquo;, meaning that when it comes time to choose who will be next to acquire a lock, get an item from a queue, etc., then it always goes to the task which has been waiting longest. It&amp;rsquo;s &lt;a href=&quot;https://github.com/python-trio/trio/issues/54&quot;&gt;not entirely clear&lt;/a&gt; whether this is the best choice, but for now that&amp;rsquo;s how it works.</source>
          <target state="translated">이 클래스는 모두 &quot;공평한&quot;것으로 보장됩니다. 즉, 잠금을 획득 할 다음 사람을 선택하고 대기열에서 항목을 가져 오는 등의 경우 항상 가장 오래 기다린 작업으로 이동합니다. . 이것이 최선의 선택인지는 &lt;a href=&quot;https://github.com/python-trio/trio/issues/54&quot;&gt;확실하지&lt;/a&gt; 않지만 현재로서는 이것이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7d75ee66ff83bf4554d223bde19bf99669265ec3" translate="yes" xml:space="preserve">
          <source>These functions can also be useful in other situations. For example, when &lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt; schedules some work to run in a worker thread, it blocks until the work is finished (so it&amp;rsquo;s a schedule point), but by default it doesn&amp;rsquo;t allow cancellation. So to make sure that the call always acts as a checkpoint, it calls &lt;a href=&quot;#trio.hazmat.checkpoint_if_cancelled&quot;&gt;&lt;code&gt;checkpoint_if_cancelled()&lt;/code&gt;&lt;/a&gt; before starting the thread.</source>
          <target state="translated">이러한 기능은 다른 상황에서도 유용 할 수 있습니다. 예를 들어, &lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt; 가 작업자 스레드에서 실행되도록 일부 작업을 예약하면 작업이 완료 될 때까지 차단되므로 (스케줄 지점이므로) 기본적으로 취소를 허용하지 않습니다. 따라서 호출이 항상 체크 포인트 역할을 하도록 스레드를 시작하기 전에 &lt;a href=&quot;#trio.hazmat.checkpoint_if_cancelled&quot;&gt; &lt;code&gt;checkpoint_if_cancelled()&lt;/code&gt; &lt;/a&gt; 를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="acb414aaadc5ad5c07497ec2df742e42694d9509" translate="yes" xml:space="preserve">
          <source>These transitions are accomplished using two function decorators:</source>
          <target state="translated">이러한 전환은 두 개의 함수 데코레이터를 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="81307d013910a4dd0f0a2b7e14e3fa3a61ebe2f2" translate="yes" xml:space="preserve">
          <source>These two lines are equivalent:</source>
          <target state="translated">이 두 줄은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="86cd05304bf90b12bb103d8aecc0cf9b07939972" translate="yes" xml:space="preserve">
          <source>They don&amp;rsquo;t need an explicit nursery; instead they go into the internal &amp;ldquo;system nursery&amp;rdquo;.</source>
          <target state="translated">그들은 명시적인 보육이 필요하지 않습니다. 대신 그들은 내부&amp;ldquo;시스템 보육원&amp;rdquo;에 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="0c35b3a96ea0ec2dff743f8b5250ebd577b91e90" translate="yes" xml:space="preserve">
          <source>Third-party async functions / iterators / context managers can act as checkpoints; if you see &lt;code&gt;await &amp;lt;something&amp;gt;&lt;/code&gt; or one of its friends, then that &lt;em&gt;might&lt;/em&gt; be a checkpoint. So to be safe, you should prepare for scheduling or cancellation happening there.</source>
          <target state="translated">타사 비동기 함수 / 반복자 / 컨텍스트 관리자는 검사 점으로 작동 할 수 있습니다. &lt;code&gt;await &amp;lt;something&amp;gt;&lt;/code&gt; 또는 해당 친구 중 하나를 기다리는 경우 검사 점이 될 &lt;em&gt;수&lt;/em&gt; 있습니다. 따라서 안전을 위해 예약 또는 취소 준비를해야합니다.</target>
        </trans-unit>
        <trans-unit id="153b8ef41ad99fb02fe77369052399944035c0b2" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; attribute is True if you&amp;rsquo;ve called &lt;code&gt;sock.shutdown(SHUT_WR)&lt;/code&gt; or &lt;code&gt;sock.shutdown(SHUT_RDWR)&lt;/code&gt;, and False otherwise.</source>
          <target state="translated">이 &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; 속성은 &lt;code&gt;sock.shutdown(SHUT_WR)&lt;/code&gt; 또는 &lt;code&gt;sock.shutdown(SHUT_RDWR)&lt;/code&gt; 호출 한 경우 True 이고, 그렇지 않으면 False입니다.</target>
        </trans-unit>
        <trans-unit id="7c6fe9ee538d951d1c429e8c8db0cf9bc028c153" translate="yes" xml:space="preserve">
          <source>This also means that if you register a SNI callback using &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext.sni_callback&quot;&gt;&lt;code&gt;sni_callback&lt;/code&gt;&lt;/a&gt;, then the first argument your callback receives will be a &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt;&lt;code&gt;ssl.SSLObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 또한 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext.sni_callback&quot;&gt; &lt;code&gt;sni_callback&lt;/code&gt; 을&lt;/a&gt; 사용하여 SNI 콜백을 등록하면 콜백이받는 첫 번째 인수는 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt; &lt;code&gt;ssl.SSLObject&lt;/code&gt; &lt;/a&gt; 가 됨을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="741317efb643cb97bdd044fc9a9acfb72ef72725" translate="yes" xml:space="preserve">
          <source>This and &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; are the two fundamental methods for creating concurrent tasks in Trio.</source>
          <target state="translated">이것과 &lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 는 Trio에서 동시 작업을 생성하는 두 가지 기본 방법입니다.</target>
        </trans-unit>
        <trans-unit id="8f2fdd09fd7fe021c78364cf9bb2f534396d77e1" translate="yes" xml:space="preserve">
          <source>This attribute being True does &lt;em&gt;not&lt;/em&gt; necessarily mean that the code within the scope has been, or will be, affected by the cancellation. For example, if &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt;&lt;code&gt;cancel()&lt;/code&gt;&lt;/a&gt; was called after the last checkpoint in the &lt;code&gt;with&lt;/code&gt; block, when it&amp;rsquo;s too late to deliver a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception, then this attribute will still be True.</source>
          <target state="translated">이 속성이 True 라고해서 해당 범위 내의 코드가 취소에 영향을 받았거나 영향을받는 것은 &lt;em&gt;아닙니다&lt;/em&gt; . 예를 들어 &lt;code&gt;with&lt;/code&gt; 블록 의 마지막 검사 점 이후에 &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt; &lt;code&gt;cancel()&lt;/code&gt; &lt;/a&gt; 이 호출 된 경우 취소 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외 를 전달하기에 너무 늦으면 이 속성은 여전히 ​​True입니다.</target>
        </trans-unit>
        <trans-unit id="a48bfa0f12266fba2f040ed028628232b8e6f5e0" translate="yes" xml:space="preserve">
          <source>This attribute is mostly useful for debugging and introspection. If you want to know whether or not a chunk of code was actually cancelled, then &lt;a href=&quot;#trio.CancelScope.cancelled_caught&quot;&gt;&lt;code&gt;cancelled_caught&lt;/code&gt;&lt;/a&gt; is usually more appropriate.</source>
          <target state="translated">이 속성은 주로 디버깅 및 내부 검사에 유용합니다. 코드 덩어리가 실제로 취소되었는지 여부를 알고 싶다면 &lt;a href=&quot;#trio.CancelScope.cancelled_caught&quot;&gt; &lt;code&gt;cancelled_caught&lt;/code&gt; &lt;/a&gt; 가 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="ff12646195b62ccf09f268e0dcd0a93a0a83670e" translate="yes" xml:space="preserve">
          <source>This avoids several common pitfalls:</source>
          <target state="translated">이것은 몇 가지 일반적인 함정을 피합니다.</target>
        </trans-unit>
        <trans-unit id="626f12244e67c7b41b46a58e659379debb57bbb8" translate="yes" xml:space="preserve">
          <source>This behavior is useful because it helps avoid race conditions and lost wakeups: it doesn&amp;rsquo;t matter whether &lt;a href=&quot;#trio.Event.set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; gets called just before or after &lt;a href=&quot;#trio.Event.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;. If you want a lower-level wakeup primitive that doesn&amp;rsquo;t have this protection, consider &lt;a href=&quot;#trio.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;reference-hazmat#trio.hazmat.ParkingLot&quot;&gt;&lt;code&gt;trio.hazmat.ParkingLot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 동작은 경쟁 조건과 깨어 난 웨이크를 피하는 데 도움이되기 때문에 유용합니다. &lt;a href=&quot;#trio.Event.set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt; 이 &lt;a href=&quot;#trio.Event.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 직전 또는 후에 호출 되는지는 중요하지 않습니다 . 이 보호 기능이없는 하위 수준의 웨이크 업 프리미티브를 &lt;a href=&quot;reference-hazmat#trio.hazmat.ParkingLot&quot;&gt; &lt;code&gt;trio.hazmat.ParkingLot&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#trio.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 또는 trio.hazmat.ParkingLot를 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7212591b5e320334b3ae18061636ff4b19af84aa" translate="yes" xml:space="preserve">
          <source>This can be useful for testing flow control mechanisms in an extreme case, or for setting up &amp;ldquo;clogged&amp;rdquo; streams to use with &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt;&lt;code&gt;check_one_way_stream()&lt;/code&gt;&lt;/a&gt; and friends.</source>
          <target state="translated">이는 극단적 인 경우 흐름 제어 메커니즘을 테스트하거나 &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt; &lt;code&gt;check_one_way_stream()&lt;/code&gt; &lt;/a&gt; 및 친구들과 함께 사용할 &quot;막힌&quot;스트림을 설정하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="777508af726dca6e138c62201ae51b11dda89501" translate="yes" xml:space="preserve">
          <source>This checks for cancellation and allows other tasks to be scheduled, without otherwise blocking.</source>
          <target state="translated">이를 통해 취소를 확인하고 달리 차단하지 않고 다른 작업을 예약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7eb8be825f964eeec308b47905ab5876d9c3514c" translate="yes" xml:space="preserve">
          <source>This class &lt;a href=&quot;https://en.wikipedia.org/wiki/Staple_(fastener)&quot;&gt;staples&lt;/a&gt; together two unidirectional streams to make single bidirectional stream.</source>
          <target state="translated">이 클래스 는 단일 양방향 스트림을 만들기 위해 두 개의 단방향 스트림을 &lt;a href=&quot;https://en.wikipedia.org/wiki/Staple_(fastener)&quot;&gt;스테이플 링&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c56797f75d6a67218039122490ded779850a16ba" translate="yes" xml:space="preserve">
          <source>This class distinguishes between &amp;ldquo;graceful&amp;rdquo; closes, which may perform I/O and thus block, and a &amp;ldquo;forceful&amp;rdquo; close, which cannot. For example, cleanly shutting down a TLS-encrypted connection requires sending a &amp;ldquo;goodbye&amp;rdquo; message; but if a peer has become non-responsive, then sending this message might block forever, so we may want to just drop the connection instead. Therefore the &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; method is unusual in that it should always close the connection (or at least make its best attempt) &lt;em&gt;even if it fails&lt;/em&gt;; failure indicates a failure to achieve grace, not a failure to close the connection.</source>
          <target state="translated">이 클래스는 I / O를 수행하여 차단할 수있는 &quot;유예&quot;닫기와 불가능한 &quot;강제&quot;닫기를 구분합니다. 예를 들어, TLS 암호화 연결을 완전히 종료하려면 &quot;안녕&quot;메시지를 보내야합니다. 그러나 피어가 응답하지 않으면이 메시지를 보내는 것이 영원히 차단 될 수 있으므로 대신 연결을 끊고 싶을 수도 있습니다. 따라서 &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 메소드는 연결 &lt;em&gt;이 실패하더라도&lt;/em&gt; 항상 연결을 종료해야합니다 (또는 최소한 최선을 다해야 함) . 실패는 연결을 닫는 데 실패가 아니라 유예에 실패했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="28b26ebbffbe7117ea41ae0633d49c552b9155ec" translate="yes" xml:space="preserve">
          <source>This class encapsulates the tricky parts of implementing a wait queue. It&amp;rsquo;s useful for implementing higher-level synchronization primitives like queues and locks.</source>
          <target state="translated">이 클래스는 대기 큐 구현의 까다로운 부분을 캡슐화합니다. 큐 및 잠금과 같은 상위 레벨 동기화 기본 요소를 구현하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1a47671d4bf70755645824b64fbe8633bf09f6fa" translate="yes" xml:space="preserve">
          <source>This class has no public constructor. To create a child process, use &lt;a href=&quot;#trio.open_process&quot;&gt;&lt;code&gt;open_process&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 클래스에는 공개 생성자가 없습니다. 자식 프로세스를 만들려면 &lt;a href=&quot;#trio.open_process&quot;&gt; &lt;code&gt;open_process&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b99db4b97b98beb51fb24c58219ced2d6f0fd5ff" translate="yes" xml:space="preserve">
          <source>This code will wait 5 seconds (for the child task to finish), and then return.</source>
          <target state="translated">이 코드는 5 초 동안 (자식 작업이 완료 될 때까지) 기다렸다가 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="939dd3d2d8145547e7e234d0c5f0527ad4c5c738" translate="yes" xml:space="preserve">
          <source>This dequeues &lt;code&gt;count&lt;/code&gt; tasks from one lot, and requeues them on another, preserving order. For example:</source>
          <target state="translated">이 작업은 한 로트에서 작업을 &lt;code&gt;count&lt;/code&gt; 하고 순서를 유지하면서 다른 로트에서 작업을 다시 요청합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c3364e26d8c76183c9b91166e249f70c062374ec" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t actually close the object &amp;ndash; you still have to do that yourself afterwards.</source>
          <target state="translated">이것은 실제로 객체를 닫는 것이 아니라 나중에 직접해야합니다.</target>
        </trans-unit>
        <trans-unit id="2bb2af13b8495755c9cccc1579f4a71609bc843d" translate="yes" xml:space="preserve">
          <source>This example demonstrates using the &lt;a href=&quot;#trio.MemorySendChannel.clone&quot;&gt;&lt;code&gt;MemorySendChannel.clone&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.MemoryReceiveChannel.clone&quot;&gt;&lt;code&gt;MemoryReceiveChannel.clone&lt;/code&gt;&lt;/a&gt; methods. What these do is create copies of our endpoints, that act just like the original &amp;ndash; except that they can be closed independently. And the underlying channel is only closed after &lt;em&gt;all&lt;/em&gt; the clones have been closed. So this completely solves our problem with shutdown, and if you run this program, you&amp;rsquo;ll see it print its six lines of output and then exits cleanly.</source>
          <target state="translated">이 예에서는 &lt;a href=&quot;#trio.MemorySendChannel.clone&quot;&gt; &lt;code&gt;MemorySendChannel.clone&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.MemoryReceiveChannel.clone&quot;&gt; &lt;code&gt;MemoryReceiveChannel.clone&lt;/code&gt; &lt;/a&gt; 메서드를 사용하는 방법을 보여줍니다 . 이것이하는 일은 엔드 포인트의 사본을 생성하는 것입니다. 엔드 포인트는 원본과 동일하게 작동하며 독립적으로 닫을 수 있습니다. 그리고 &lt;em&gt;모든&lt;/em&gt; 클론이 닫힌 후에 만 ​​기본 채널이 닫힙니다. 따라서 종료 문제를 완전히 해결하고이 프로그램을 실행하면 6 줄의 출력을 인쇄 한 다음 깨끗하게 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="0831f123255408a3d50729ed611cfa78fde0d9f6" translate="yes" xml:space="preserve">
          <source>This exception&amp;rsquo;s &lt;code&gt;__cause__&lt;/code&gt; attribute will often contain more information about the underlying error.</source>
          <target state="translated">이 예외의 &lt;code&gt;__cause__&lt;/code&gt; 속성은 종종 기본 오류에 대한 자세한 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="4ec4163ea949b45f4f411608a69251c1e624bfb0" translate="yes" xml:space="preserve">
          <source>This function allows you to replace Trio&amp;rsquo;s normal socket class with a custom class. This is very useful for testing, and probably a bad idea in any other circumstance. See &lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt;&lt;code&gt;trio.abc.HostnameResolver&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이 함수를 사용하면 Trio의 일반 소켓 클래스를 사용자 정의 클래스로 바꿀 수 있습니다. 이것은 테스트에 매우 유용하며 다른 상황에서는 좋지 않을 수 있습니다. 자세한 내용은 &lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt; &lt;code&gt;trio.abc.HostnameResolver&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8b80bf44f477a63401ffe0a86ba46937966ca016" translate="yes" xml:space="preserve">
          <source>This function and &lt;a href=&quot;#trio.move_on_after&quot;&gt;&lt;code&gt;move_on_after()&lt;/code&gt;&lt;/a&gt; are similar in that both create a cancel scope with a given timeout, and if the timeout expires then both will cause &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; to be raised within the scope. The difference is that when the &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception reaches &lt;a href=&quot;#trio.move_on_after&quot;&gt;&lt;code&gt;move_on_after()&lt;/code&gt;&lt;/a&gt;, it&amp;rsquo;s caught and discarded. When it reaches &lt;a href=&quot;#trio.fail_after&quot;&gt;&lt;code&gt;fail_after()&lt;/code&gt;&lt;/a&gt;, then it&amp;rsquo;s caught and &lt;a href=&quot;#trio.TooSlowError&quot;&gt;&lt;code&gt;TooSlowError&lt;/code&gt;&lt;/a&gt; is raised in its place.</source>
          <target state="translated">이 함수와 &lt;a href=&quot;#trio.move_on_after&quot;&gt; &lt;code&gt;move_on_after()&lt;/code&gt; &lt;/a&gt; 는 주어진 시간 초과로 취소 범위를 만들고 시간 초과가 만료되면 범위 내에서 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 가 발생한다는 점에서 비슷 합니다. 차이점은 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외가 &lt;a href=&quot;#trio.move_on_after&quot;&gt; &lt;code&gt;move_on_after()&lt;/code&gt; &lt;/a&gt; 도달하면 잡히고 버린다는 것입니다. 이 도달하면 &lt;a href=&quot;#trio.fail_after&quot;&gt; &lt;code&gt;fail_after()&lt;/code&gt; &lt;/a&gt; , 다음은 잡은 것 및 &lt;a href=&quot;#trio.TooSlowError&quot;&gt; &lt;code&gt;TooSlowError&lt;/code&gt; 는&lt;/a&gt; 그 자리에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6472cab9cb21c974030fc674c30dfd25631ba087" translate="yes" xml:space="preserve">
          <source>This function and &lt;a href=&quot;#trio.move_on_at&quot;&gt;&lt;code&gt;move_on_at()&lt;/code&gt;&lt;/a&gt; are similar in that both create a cancel scope with a given absolute deadline, and if the deadline expires then both will cause &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; to be raised within the scope. The difference is that when the &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception reaches &lt;a href=&quot;#trio.move_on_at&quot;&gt;&lt;code&gt;move_on_at()&lt;/code&gt;&lt;/a&gt;, it&amp;rsquo;s caught and discarded. When it reaches &lt;a href=&quot;#trio.fail_at&quot;&gt;&lt;code&gt;fail_at()&lt;/code&gt;&lt;/a&gt;, then it&amp;rsquo;s caught and &lt;a href=&quot;#trio.TooSlowError&quot;&gt;&lt;code&gt;TooSlowError&lt;/code&gt;&lt;/a&gt; is raised in its place.</source>
          <target state="translated">이 함수와 &lt;a href=&quot;#trio.move_on_at&quot;&gt; &lt;code&gt;move_on_at()&lt;/code&gt; &lt;/a&gt; 는 주어진 절대 기한이있는 취소 범위를 작성하고 기한이 만료되면 범위 내에서 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 가 발생한다는 점에서 비슷 합니다. 차이점은 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외가 &lt;a href=&quot;#trio.move_on_at&quot;&gt; &lt;code&gt;move_on_at()&lt;/code&gt; &lt;/a&gt; 도달하면 잡히고 버린다는 것입니다. 이 도달하면 &lt;a href=&quot;#trio.fail_at&quot;&gt; &lt;code&gt;fail_at()&lt;/code&gt; &lt;/a&gt; , 다음은 잡은 것 및 &lt;a href=&quot;#trio.TooSlowError&quot;&gt; &lt;code&gt;TooSlowError&lt;/code&gt; 는&lt;/a&gt; 그 자리에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="beee03279b501d21ddabbf8f6de51961869f2389" translate="yes" xml:space="preserve">
          <source>This function does not perform the TLS handshake; you can do it manually by calling &lt;a href=&quot;#trio.SSLStream.do_handshake&quot;&gt;&lt;code&gt;do_handshake()&lt;/code&gt;&lt;/a&gt;, or else it will be performed automatically the first time you send or receive data.</source>
          <target state="translated">이 기능은 TLS 핸드 셰이크를 수행하지 않습니다. &lt;a href=&quot;#trio.SSLStream.do_handshake&quot;&gt; &lt;code&gt;do_handshake()&lt;/code&gt; &lt;/a&gt; 를 호출하여 수동으로 수행 할 수 있습니다. 그렇지 않으면 데이터를 처음 보내거나받을 때 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8b5f591859ac15e7667f269bbd87655ee356a2a3" translate="yes" xml:space="preserve">
          <source>This function examines all the cancellation scopes that are currently in effect (taking into account shielding), and returns the deadline that will expire first.</source>
          <target state="translated">이 함수는 현재 적용중인 모든 취소 범위 (차폐를 고려함)를 검사하고 먼저 만료되는 최종 기한을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="781b6ba4e14238d28d4905a86d639a4f2fb4d4f6" translate="yes" xml:space="preserve">
          <source>This function never returns unless cancelled.</source>
          <target state="translated">이 함수는 취소하지 않으면 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10fb6ede8900e518012239a45fc9a8e96195f7a8" translate="yes" xml:space="preserve">
          <source>This function only returns when cancelled.</source>
          <target state="translated">이 함수는 취소 된 경우에만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a6ba5420ed39805adc1f6e88511ac0ce00ec14a9" translate="yes" xml:space="preserve">
          <source>This function strikes a balance between these two extremes: it works its way through the available addresses one at a time, like the first approach; but, if &lt;code&gt;happy_eyeballs_delay&lt;/code&gt; seconds have passed and it&amp;rsquo;s still waiting for an attempt to succeed or fail, then it gets impatient and starts the next connection attempt in parallel. As soon as any one connection attempt succeeds, all the other attempts are cancelled. This avoids unnecessary load because most connections will succeed after just one or two attempts, but if one of the addresses is unreachable then it doesn&amp;rsquo;t slow us down too much.</source>
          <target state="translated">이 기능은이 두 극단 사이의 균형을 유지합니다. 첫 번째 접근 방식과 같이 사용 가능한 주소를 통해 한 번에 하나씩 작동합니다. 그러나 &lt;code&gt;happy_eyeballs_delay&lt;/code&gt; 초가 지났는데도 여전히 성공 또는 실패를 기다리는 경우, 참을성이 없어 다음 연결 시도를 병렬로 시작합니다. 하나의 연결 시도가 성공하자마자 다른 모든 시도는 취소됩니다. 이렇게하면 대부분의 연결이 한두 번의 시도 후에 성공하기 때문에 불필요한로드를 피할 수 있지만 주소 중 하나에 도달 할 수없는 경우에도 속도가 너무 느려지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2b428d2d2fedd87ac134d2d677f1ec40b12e6074" translate="yes" xml:space="preserve">
          <source>This function tests a &lt;em&gt;superset&lt;/em&gt; of what &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt;&lt;code&gt;check_one_way_stream()&lt;/code&gt;&lt;/a&gt; checks &amp;ndash; if you call this, then you don&amp;rsquo;t need to also call &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt;&lt;code&gt;check_one_way_stream()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt; &lt;code&gt;check_one_way_stream()&lt;/code&gt; &lt;/a&gt; 확인 하는 &lt;em&gt;상위 집합&lt;/em&gt; 을 테스트합니다.이를 호출하면 &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt; &lt;code&gt;check_one_way_stream()&lt;/code&gt; &lt;/a&gt; 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c237272caa2b06d6e435d70b44aba945c42ded67" translate="yes" xml:space="preserve">
          <source>This function tests a &lt;em&gt;superset&lt;/em&gt; of what &lt;a href=&quot;#trio.testing.check_two_way_stream&quot;&gt;&lt;code&gt;check_two_way_stream()&lt;/code&gt;&lt;/a&gt; checks &amp;ndash; if you call this, then you don&amp;rsquo;t need to also call &lt;a href=&quot;#trio.testing.check_two_way_stream&quot;&gt;&lt;code&gt;check_two_way_stream()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#trio.testing.check_two_way_stream&quot;&gt; &lt;code&gt;check_two_way_stream()&lt;/code&gt; &lt;/a&gt; 확인 하는 &lt;em&gt;상위 집합&lt;/em&gt; 을 테스트합니다.이 함수 를 호출하면 &lt;a href=&quot;#trio.testing.check_two_way_stream&quot;&gt; &lt;code&gt;check_two_way_stream()&lt;/code&gt; &lt;/a&gt; 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3025b1032710d54ab53e19541456e1cb5086dfdb" translate="yes" xml:space="preserve">
          <source>This function&amp;rsquo;s behavior can be customized using &lt;a href=&quot;reference-testing#trio.socket.set_custom_hostname_resolver&quot;&gt;&lt;code&gt;set_custom_hostname_resolver()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수의 동작은 &lt;a href=&quot;reference-testing#trio.socket.set_custom_hostname_resolver&quot;&gt; &lt;code&gt;set_custom_hostname_resolver()&lt;/code&gt; &lt;/a&gt; 사용하여 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a99381ddd18455f137e888e7ce19ef7b02a6d411" translate="yes" xml:space="preserve">
          <source>This function&amp;rsquo;s behavior can be customized using &lt;a href=&quot;reference-testing#trio.socket.set_custom_socket_factory&quot;&gt;&lt;code&gt;set_custom_socket_factory()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수의 동작은 &lt;a href=&quot;reference-testing#trio.socket.set_custom_socket_factory&quot;&gt; &lt;code&gt;set_custom_socket_factory()&lt;/code&gt; &lt;/a&gt; 사용하여 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dfd660c37b7b448e29f5ca35f71daff1e3c7a98e" translate="yes" xml:space="preserve">
          <source>This includes async iterators: If you write &lt;code&gt;async for ... in &amp;lt;a
trio object&amp;gt;&lt;/code&gt;, then there will be at least one checkpoint before each iteration of the loop and one checkpoint after the last iteration.</source>
          <target state="translated">여기에는 비동기 반복기가 포함됩니다. &lt;code&gt;async for ... in &amp;lt;a trio object&amp;gt;&lt;/code&gt; 작성 하는 경우 루프의 각 반복 전에 적어도 하나의 검사 점이 있고 마지막 반복 후에는 하나의 검사 점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="64fdf77f2a6948dcd1d3f395907ba3bd1b417d06" translate="yes" xml:space="preserve">
          <source>This interface extends &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; to also allow closing the send part of the stream without closing the receive part.</source>
          <target state="translated">이 인터페이스 는 수신 부분을 닫지 않고 스트림의 송신 부분을 닫을 수 있도록 &lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 을 확장 합니다.</target>
        </trans-unit>
        <trans-unit id="783f9168f3a0ecf9fcc0bad0241f594953ed1653" translate="yes" xml:space="preserve">
          <source>This is &lt;em&gt;not&lt;/em&gt; a &lt;a href=&quot;reference-core#checkpoints&quot;&gt;checkpoint&lt;/a&gt;, but it is half of a checkpoint, and when combined with &lt;a href=&quot;#trio.hazmat.checkpoint_if_cancelled&quot;&gt;&lt;code&gt;checkpoint_if_cancelled()&lt;/code&gt;&lt;/a&gt; it can make a full checkpoint.</source>
          <target state="translated">입니다 &lt;em&gt;하지 &lt;/em&gt;&lt;a href=&quot;reference-core#checkpoints&quot;&gt;체크 포인트&lt;/a&gt; ,하지만 체크 포인트의 절반이며, 함께 결합 될 때 &lt;a href=&quot;#trio.hazmat.checkpoint_if_cancelled&quot;&gt; &lt;code&gt;checkpoint_if_cancelled()&lt;/code&gt; &lt;/a&gt; 는 전체 검사 점을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bfe1cdd96a28a6a95c12558fd209d1ae8e3ceb2" translate="yes" xml:space="preserve">
          <source>This is Trio&amp;rsquo;s main entry point. Almost every other function in Trio requires that you be inside a call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것이 트리오의 주요 진입 점입니다. Trio의 거의 모든 다른 함수에는 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 호출 안에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a87c3526175efef10c92dec2e7c2b1e115230ab1" translate="yes" xml:space="preserve">
          <source>This is a convenience function that creates two one-way streams using &lt;a href=&quot;#trio.testing.lockstep_stream_one_way_pair&quot;&gt;&lt;code&gt;lockstep_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt;, and then uses &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt; to combine them into a single bidirectional stream.</source>
          <target state="translated">이것은 &lt;a href=&quot;#trio.testing.lockstep_stream_one_way_pair&quot;&gt; &lt;code&gt;lockstep_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; 사용하여 두 개의 단방향 스트림을 만든 다음 &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt; 을 사용 하여 단일 양방향 스트림으로 결합 하는 편리한 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="143d075fb0db14d63e601395486d506d13fd2bb0" translate="yes" xml:space="preserve">
          <source>This is a convenience function that creates two one-way streams using &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt;&lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt;, and then uses &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt; to combine them into a single bidirectional stream.</source>
          <target state="translated">이것은 &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt; &lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; 사용하여 두 개의 단방향 스트림을 만든 다음 &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt; 을 사용 하여 단일 양방향 스트림으로 결합 하는 편리한 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="75e832f6645c15527d0b0ace9c7c9f19af69e7f7" translate="yes" xml:space="preserve">
          <source>This is a convenience wrapper that calls &lt;a href=&quot;#trio.open_tcp_stream&quot;&gt;&lt;code&gt;open_tcp_stream()&lt;/code&gt;&lt;/a&gt; and wraps the result in an &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#trio.open_tcp_stream&quot;&gt; &lt;code&gt;open_tcp_stream()&lt;/code&gt; &lt;/a&gt; 을 호출 하고 결과를 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 에 랩핑 하는 편의 래퍼입니다 .</target>
        </trans-unit>
        <trans-unit id="31ccdd36d0e3b96050da7e039b26a2619a4c6283" translate="yes" xml:space="preserve">
          <source>This is a list, with outer nurseries before inner nurseries.</source>
          <target state="translated">이것은 내부 보육원 앞에 외부 보육원이있는 목록입니다.</target>
        </trans-unit>
        <trans-unit id="dfdb480b2d02dfcb7a4dd0f62ee4c91790556e33" translate="yes" xml:space="preserve">
          <source>This is a non-reentrant, single-owner lock. Unlike &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Lock&quot;&gt;&lt;code&gt;threading.Lock&lt;/code&gt;&lt;/a&gt;, only the owner of the lock is allowed to release it.</source>
          <target state="translated">재진입 할 ​​수없는 단일 소유자 잠금입니다. &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Lock&quot;&gt; &lt;code&gt;threading.Lock&lt;/code&gt; &lt;/a&gt; 과 달리 잠금 소유자 만 잠금을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3439e00fa8a3c024670687cffe82162907494a8" translate="yes" xml:space="preserve">
          <source>This is a thin convenience wrapper around &lt;a href=&quot;#trio.open_ssl_over_tcp_listeners&quot;&gt;&lt;code&gt;open_ssl_over_tcp_listeners()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.serve_listeners&quot;&gt;&lt;code&gt;serve_listeners()&lt;/code&gt;&lt;/a&gt; &amp;ndash; see them for full details.</source>
          <target state="translated">이것은 &lt;a href=&quot;#trio.open_ssl_over_tcp_listeners&quot;&gt; &lt;code&gt;open_ssl_over_tcp_listeners()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.serve_listeners&quot;&gt; &lt;code&gt;serve_listeners()&lt;/code&gt; &lt;/a&gt; 주위의 얇은 편의 래퍼 입니다. 자세한 내용은 해당 패키지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8686484a6ca97f02cdc1ea23ba90f658a805236b" translate="yes" xml:space="preserve">
          <source>This is a thin convenience wrapper around &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.serve_listeners&quot;&gt;&lt;code&gt;serve_listeners()&lt;/code&gt;&lt;/a&gt; &amp;ndash; see them for full details.</source>
          <target state="translated">이것은 &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#trio.serve_listeners&quot;&gt; &lt;code&gt;serve_listeners()&lt;/code&gt; &lt;/a&gt; 주위의 얇은 편리한 래퍼 입니다. 자세한 내용은 그것들을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6a21f0dfe9782d121688f4156eec97c0b785ae6a" translate="yes" xml:space="preserve">
          <source>This is a tricky interface with no guard rails. If you can use &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt;&lt;code&gt;ParkingLot&lt;/code&gt;&lt;/a&gt; or the built-in I/O wait functions instead, then you should.</source>
          <target state="translated">가드 레일이없는 까다로운 인터페이스입니다. &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt; &lt;code&gt;ParkingLot&lt;/code&gt; &lt;/a&gt; 또는 내장 I / O 대기 기능을 대신 사용할 수 있다면 해야합니다.</target>
        </trans-unit>
        <trans-unit id="62916f9abf44ea5131fbba3fd3fa67633fc06333" translate="yes" xml:space="preserve">
          <source>This is an async method that returns a synchronous iterator, so you use it like:</source>
          <target state="translated">이것은 동기 반복자를 반환하는 비동기 메소드이므로 다음과 같이 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5ef14ee7f5ae379eed9b811cf4383e8fbde52f11" translate="yes" xml:space="preserve">
          <source>This is analogous to an &amp;ldquo;end-of-file&amp;rdquo; condition, but for channels.</source>
          <target state="translated">이것은 &quot;파일 끝&quot;조건과 유사하지만 채널에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="eca5f551bc86a3707933e82043f223ee98935da8" translate="yes" xml:space="preserve">
          <source>This is called before we enter a system-specific wait function like &lt;a href=&quot;https://docs.python.org/3/library/select.html#select.select&quot;&gt;&lt;code&gt;select.select()&lt;/code&gt;&lt;/a&gt;, to get the timeout to pass.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/select.html#select.select&quot;&gt; &lt;code&gt;select.select()&lt;/code&gt; &lt;/a&gt; 을 전달하기 위해 select.select () 와 같은 시스템 별 대기 함수를 입력하기 전에 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="c33a989e11aa76213cba8f2726e3fb28d36a356c" translate="yes" xml:space="preserve">
          <source>This is determined on a function-by-function basis. By default, a function is protected if its caller is, and not if its caller isn&amp;rsquo;t; this is helpful because it means you only need to override the defaults at places where you transition from protected code to unprotected code or vice-versa.</source>
          <target state="translated">이것은 기능별로 결정됩니다. 기본적으로 함수는 호출자가있는 경우 보호되며 호출자가 아닌 경우에는 보호되지 않습니다. 이것은 보호 된 코드에서 보호되지 않은 코드로 또는 그 반대로 전환하는 위치의 기본값 만 재정의하면되기 때문에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="59d307411d32a6c006290f810ba88a7b617a32e3" translate="yes" xml:space="preserve">
          <source>This is either a no-op, or else it allow other tasks to be scheduled and then raises &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;trio.Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 작동하지 않거나 다른 작업을 예약 한 다음 &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;trio.Cancelled&lt;/code&gt; 을 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="918fd503d30c70a4012dae526127fcf2c3cdd726" translate="yes" xml:space="preserve">
          <source>This is equivalent to calling &lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive()&lt;/code&gt;&lt;/a&gt; repeatedly. The loop exits without error when &lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt; raises &lt;a href=&quot;reference-core#trio.EndOfChannel&quot;&gt;&lt;code&gt;EndOfChannel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive()&lt;/code&gt; &lt;/a&gt; 반복해서 호출하는 것과 같습니다 . &lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;reference-core#trio.EndOfChannel&quot;&gt; &lt;code&gt;EndOfChannel&lt;/code&gt; 을&lt;/a&gt; 올리면 루프가 오류없이 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5df3299548e7f24b6f4916386efc3494b1e0848" translate="yes" xml:space="preserve">
          <source>This is known as a &amp;ldquo;happy eyeballs&amp;rdquo; algorithm, and our particular variant is modelled after how Chrome connects to webservers; see &lt;a href=&quot;https://tools.ietf.org/html/rfc6555&quot;&gt;RFC 6555&lt;/a&gt; for more details.</source>
          <target state="translated">이를 '행복한 안구'알고리즘이라고하며, Google의 특정 변형은 Chrome이 웹 서버에 연결되는 방식에 따라 모델링됩니다. 자세한 내용 은 &lt;a href=&quot;https://tools.ietf.org/html/rfc6555&quot;&gt;RFC 6555&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4379e3a65b564c2c817949c6184653445cc5dfc6" translate="yes" xml:space="preserve">
          <source>This is like a no-operating-system-involved, Trio-streamsified version of &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socketpair&quot;&gt;&lt;code&gt;socket.socketpair()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 비 운영 체제 관련 Trio 스트림 버전의 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socketpair&quot;&gt; &lt;code&gt;socket.socketpair()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed8cb82fa76f8afdd017893fe6d82e0c370e3598" translate="yes" xml:space="preserve">
          <source>This is particularly useful in tests when you want to let a server pick its own port, and then connect to it:</source>
          <target state="translated">이것은 서버가 자체 포트를 선택한 다음 연결하도록하려는 경우 테스트에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b8d5871cda022acd530d3a2e7015027417917478" translate="yes" xml:space="preserve">
          <source>This is safe to call from the main thread, from other threads, and from signal handlers. This is the fundamental primitive used to re-enter the Trio run loop from outside of it.</source>
          <target state="translated">이것은 메인 스레드, 다른 스레드 및 신호 처리기에서 호출하는 것이 안전합니다. 이것은 외부에서 Trio 실행 루프를 다시 입력하는 데 사용되는 기본 프리미티브입니다.</target>
        </trans-unit>
        <trans-unit id="f1224a9af924c885f91aebaa013636dda44b62ae" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt;&lt;code&gt;check_one_way_stream()&lt;/code&gt;&lt;/a&gt;, except that the maker functions are expected to return objects implementing the &lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">이것은 메이커 함수가 &lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하는 객체를 돌려주는 것을 제외하고는 &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt; &lt;code&gt;check_one_way_stream()&lt;/code&gt; &lt;/a&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="03be5a68c53f7c102fa36f575fc1926e2be7101e" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#trio.testing.check_two_way_stream&quot;&gt;&lt;code&gt;check_two_way_stream()&lt;/code&gt;&lt;/a&gt;, except that the maker functions are expected to return objects that implement the &lt;a href=&quot;reference-io#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;HalfCloseableStream&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">이것은 메이커 함수가 &lt;a href=&quot;reference-io#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;HalfCloseableStream&lt;/code&gt; &lt;/a&gt; 인터페이스 를 구현하는 객체를 돌려주는 것을 제외하고는 &lt;a href=&quot;#trio.testing.check_two_way_stream&quot;&gt; &lt;code&gt;check_two_way_stream()&lt;/code&gt; &lt;/a&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="43eba094a9b0b6fd7d9cb8d6b304c98507fbc7ae" translate="yes" xml:space="preserve">
          <source>This is the lowest-level API for blocking in Trio. Every time a &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; blocks, it does so by calling this function (usually indirectly via some higher-level API).</source>
          <target state="translated">이것은 Trio에서 차단을위한 가장 낮은 수준의 API입니다. &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 차단 될 때마다이 기능을 호출하여 (보통 일부 고급 API를 통해 간접적으로) 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ea4acecf4fbb18913e774bb995c238217d6a1937" translate="yes" xml:space="preserve">
          <source>This is the task that is the ultimate parent of all other tasks.</source>
          <target state="translated">이것은 다른 모든 작업의 ​​최종 부모 인 작업입니다.</target>
        </trans-unit>
        <trans-unit id="a22ac9eb1bb7bf57231034370b737046cb61f388" translate="yes" xml:space="preserve">
          <source>This is used to implement &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt;&lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt;&lt;code&gt;memory_stream_pair()&lt;/code&gt;&lt;/a&gt;; see the latter&amp;rsquo;s docstring for an example of how you might use it yourself.</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt; &lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt; &lt;code&gt;memory_stream_pair()&lt;/code&gt; &lt;/a&gt; 를 구현하는 데 사용됩니다 . 직접 사용하는 방법에 대한 예는 후자의 docstring을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f48dde0527c8494ca2e28a4cd0989758ecebeabd" translate="yes" xml:space="preserve">
          <source>This is used to implement functions like &lt;a href=&quot;#trio.current_time&quot;&gt;&lt;code&gt;trio.current_time()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.move_on_after&quot;&gt;&lt;code&gt;trio.move_on_after()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.current_time&quot;&gt; &lt;code&gt;trio.current_time()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.move_on_after&quot;&gt; &lt;code&gt;trio.move_on_after()&lt;/code&gt; &lt;/a&gt; 와 같은 함수를 구현하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="73a3bbd0c9272d9c41b2c54752f4037caad4bd1e" translate="yes" xml:space="preserve">
          <source>This is useful for communication patterns that involve multiple consumers all receiving objects from the same underlying channel. See &lt;a href=&quot;#channel-mpmc&quot;&gt;Managing multiple producers and/or multiple consumers&lt;/a&gt; for examples.</source>
          <target state="translated">이 기능은 여러 소비자가 동일한 기본 채널에서 객체를받는 모든 통신 패턴에 유용합니다. 예제는 &lt;a href=&quot;#channel-mpmc&quot;&gt;여러 생산자 및 / 또는 여러 소비자 관리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6332c9de89c2de2b861fb164fa12e80e53ca2924" translate="yes" xml:space="preserve">
          <source>This is useful for communication patterns that involve multiple producers all sending objects to the same destination. If you give each producer its own clone of the &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt;&lt;code&gt;MemorySendChannel&lt;/code&gt;&lt;/a&gt;, and then make sure to close each &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt;&lt;code&gt;MemorySendChannel&lt;/code&gt;&lt;/a&gt; when it&amp;rsquo;s finished, receivers will automatically get notified when all producers are finished. See &lt;a href=&quot;#channel-mpmc&quot;&gt;Managing multiple producers and/or multiple consumers&lt;/a&gt; for examples.</source>
          <target state="translated">이는 여러 생산자가 모두 동일한 대상으로 개체를 보내는 통신 패턴에 유용합니다. 각 제작자에게 자체 &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt; &lt;code&gt;MemorySendChannel&lt;/code&gt; &lt;/a&gt; 복제본을 제공 한 다음 완료되면 각 &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt; &lt;code&gt;MemorySendChannel&lt;/code&gt; &lt;/a&gt; 을 닫아야합니다 . 모든 제작자가 완료되면 수신자에게 자동으로 알림이 표시됩니다. 예제는 &lt;a href=&quot;#channel-mpmc&quot;&gt;여러 생산자 및 / 또는 여러 소비자 관리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="14371b9c7cf5540c783770ba7972ab7d26d5fd82" translate="yes" xml:space="preserve">
          <source>This is useful in testing code when you want to give other tasks a chance to &amp;ldquo;settle down&amp;rdquo;. The calling task is blocked, and doesn&amp;rsquo;t wake up until all other tasks are also blocked for at least &lt;code&gt;cushion&lt;/code&gt; seconds. (Setting a non-zero &lt;code&gt;cushion&lt;/code&gt; is intended to handle cases like two tasks talking to each other over a local socket, where we want to ignore the potential brief moment between a send and receive when all tasks are blocked.)</source>
          <target state="translated">이것은 다른 작업에 &quot;정착&quot;할 기회를 주려고 할 때 코드를 테스트하는 데 유용합니다. 호출 작업은 차단되며 다른 모든 작업도 최소 &lt;code&gt;cushion&lt;/code&gt; 초 동안 차단 될 때까지 깨어나지 않습니다 . (제로 가 아닌 &lt;code&gt;cushion&lt;/code&gt; 설정은 로컬 소켓을 통해 서로 대화하는 두 가지 작업과 같은 경우를 처리하기위한 것입니다. 모든 작업이 차단 될 때 보내기와 받기 사이의 짧은 순간을 무시하려고합니다.)</target>
        </trans-unit>
        <trans-unit id="6d9c47c65341615224be021b44bf2fd41e1eacd6" translate="yes" xml:space="preserve">
          <source>This logic is a bit convoluted, but accomplishes all of the following:</source>
          <target state="translated">이 논리는 약간 복잡하지만 다음을 모두 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7ceffadabbbd6b876aa5cf2d79a7eb379cd975bc" translate="yes" xml:space="preserve">
          <source>This means that if you call &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt;&lt;/a&gt; with a cushion &lt;em&gt;larger&lt;/em&gt; than your autojump threshold, then your call to &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt;&lt;/a&gt; will never return, because the autojump task will keep waking up before your task does, and each time it does it&amp;rsquo;ll reset your task&amp;rsquo;s timer. However, if your cushion and the autojump threshold are the &lt;em&gt;same&lt;/em&gt;, then the autojump&amp;rsquo;s tiebreaker will prevent them from interfering (unless you also set your tiebreaker to infinity for some reason. Don&amp;rsquo;t do that). As an important special case: this means that if you set an autojump threshold of zero and use &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt;&lt;/a&gt; with the default zero cushion, then everything will work fine.</source>
          <target state="translated">이 방법은 호출하면 그 &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt; &lt;/a&gt; 쿠션으로 &lt;em&gt;더 큰&lt;/em&gt; 당신의 autojump 임계 값보다 전화 후 &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt; &lt;/a&gt; autojump 작업이 사용자의 작업보다 먼저 깨어 난 계속하기 때문에, 반환하지 않습니다, 그리고 그것을 수행 때마다거야 작업 타이머를 재설정하십시오. 그러나 쿠션과 오토 점프 임계 값이 &lt;em&gt;동일&lt;/em&gt; 하면 오토 점프의 타이 브레이커가 간섭을 방지합니다 (어떤 이유로 타이 브레이커를 무한대로 설정하지 않는 한). 중요한 특수한 경우 : 즉, 자동 점프 임계 값을 0으로 설정 하고 기본 제로 쿠션과 함께 &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt; &lt;/a&gt; 사용하면 모든 것이 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a31ec8fe7387a6f002a01fe33b6841ee026197dd" translate="yes" xml:space="preserve">
          <source>This means that tasks form a tree: when you call &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;, then this creates an initial task, and all your other tasks will be children, grandchildren, etc. of the initial task.</source>
          <target state="translated">이것은 태스크가 트리를 형성한다는 것을 의미합니다. &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 을 호출 하면 초기 태스크가 생성되고 다른 모든 태스크는 초기 태스크의 자식, 손자 등이됩니다.</target>
        </trans-unit>
        <trans-unit id="001dbbe80004bb99fc2bc2a63a98f6d83ad1c4aa" translate="yes" xml:space="preserve">
          <source>This method &lt;strong&gt;must not&lt;/strong&gt; return &lt;em&gt;late&lt;/em&gt;: if it&amp;rsquo;s possible for &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; to complete without blocking, then it must return. When implementing it, err on the side of returning early.</source>
          <target state="translated">이 메소드 &lt;strong&gt;는 &lt;/strong&gt;&lt;em&gt;늦게&lt;/em&gt; 리턴 &lt;strong&gt;되지 않아야합니다&lt;/strong&gt; . &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; 이 블로킹없이 완료 될 수 있으면 리턴해야합니다. 그것을 구현할 때 일찍 돌아 오는 편에서 실수하십시오.</target>
        </trans-unit>
        <trans-unit id="fe0ddaab4931c7368e42811a407720834ac1654f" translate="yes" xml:space="preserve">
          <source>This method handles routine errors like &lt;code&gt;ECONNABORTED&lt;/code&gt;, but passes other errors on to its caller. In particular, it does &lt;em&gt;not&lt;/em&gt; make any special effort to handle resource exhaustion errors like &lt;code&gt;EMFILE&lt;/code&gt;, &lt;code&gt;ENFILE&lt;/code&gt;, &lt;code&gt;ENOBUFS&lt;/code&gt;, &lt;code&gt;ENOMEM&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;ECONNABORTED&lt;/code&gt; 와 같은 일상적인 오류를 처리 하지만 다른 오류는 호출자에게 전달합니다. 특히 &lt;code&gt;EMFILE&lt;/code&gt; , &lt;code&gt;ENFILE&lt;/code&gt; , &lt;code&gt;ENOBUFS&lt;/code&gt; , &lt;code&gt;ENOMEM&lt;/code&gt; 과 같은 리소스 소진 오류를 처리하기 위해 특별한 노력을 기울이지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cc8504b3af8bb3a52e7201c66061ace528b891af" translate="yes" xml:space="preserve">
          <source>This method is idempotent, i.e., if the scope was already cancelled then this method silently does nothing.</source>
          <target state="translated">이 메소드는 dem 등원입니다. 즉, 범위가 이미 취소 된 경우이 메소드는 자동으로 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="327bcec5e9f1d8e5c9b4dfa3978e568947924437" translate="yes" xml:space="preserve">
          <source>This method is intended to aid in implementing protocols that want to delay choosing which data to send until the last moment. E.g., suppose you&amp;rsquo;re working on an implemention of a remote display server like &lt;a href=&quot;https://en.wikipedia.org/wiki/Virtual_Network_Computing&quot;&gt;VNC&lt;/a&gt;, and the network connection is currently backed up so that if you call &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; now then it will sit for 0.5 seconds before actually sending anything. In this case it doesn&amp;rsquo;t make sense to take a screenshot, then wait 0.5 seconds, and then send it, because the screen will keep changing while you wait; it&amp;rsquo;s better to wait 0.5 seconds, then take the screenshot, and then send it, because this way the data you deliver will be more up-to-date. Using &lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt; makes it possible to implement the better strategy.</source>
          <target state="translated">이 방법은 마지막 순간까지 전송할 데이터 선택을 지연시키려는 프로토콜을 구현하는 데 도움이됩니다. 예를 들어 &lt;a href=&quot;https://en.wikipedia.org/wiki/Virtual_Network_Computing&quot;&gt;VNC&lt;/a&gt; 와 같은 원격 디스플레이 서버 구현을 작업 중이고 현재 네트워크 연결이 백업되어 &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; 을 호출하면 실제로 전송하기 전에 0.5 초 동안 대기 합니다. 이 경우 스크린 샷을 찍은 다음 0.5 초간 기다렸다가 전송하는 것이 합리적이지 않습니다. 대기하는 동안 화면이 계속 바뀌기 때문입니다. 0.5 초간 기다린 다음 스크린 샷을 촬영 한 다음 전송하는 것이 좋습니다. 이렇게하면 제공하는 데이터가 더 최신 정보가됩니다. &lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt; 을 사용 하면 더 나은 전략을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11ce31115b0532c0a09e761077c91c38b3555228" translate="yes" xml:space="preserve">
          <source>This method may return early: it&amp;rsquo;s possible that after it returns, &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; will still block. (In the worst case, if no better implementation is available, then it might always return immediately without blocking. It&amp;rsquo;s nice to do better than that when possible, though.)</source>
          <target state="translated">이 메소드는 일찍 리턴 될 수 있습니다. 리턴 후에도 &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; 이 여전히 차단 될 수 있습니다. (최악의 경우 더 나은 구현을 사용할 수 없으면 항상 차단하지 않고 즉시 반환 될 수 있습니다. 가능하면 그보다 더 나은 방법을 사용하는 것이 좋습니다.)</target>
        </trans-unit>
        <trans-unit id="68cd0d3fca1c3e830708ccdf82c78498e770bf02" translate="yes" xml:space="preserve">
          <source>This must be called from inside the coroutine being resumed, and yields whatever value you pass in. (Presumably you&amp;rsquo;ll pass a value that will cause the current coroutine runner to stop scheduling this task.) Then the coroutine is resumed by the Trio scheduler at the next opportunity.</source>
          <target state="translated">이것은 다시 시작되는 코 루틴 내부에서 호출해야하며 전달한 값을 산출합니다. (현재 코 루틴 러너가이 작업을 예약하지 못하게하는 값을 전달합니다.) 그런 다음 코 루틴은 Trio 스케줄러에 의해 다시 시작됩니다. 다음 기회에.</target>
        </trans-unit>
        <trans-unit id="07dd1ff7276a26efb26664ad097a141e5b97de29" translate="yes" xml:space="preserve">
          <source>This object has two uses:</source>
          <target state="translated">이 객체에는 두 가지 용도가 있습니다.</target>
        </trans-unit>
        <trans-unit id="59a2c593d37d67b4ae21874adc6716930415e309" translate="yes" xml:space="preserve">
          <source>This object&amp;rsquo;s interface is similar to, but different from, that of &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Semaphore&quot;&gt;&lt;code&gt;threading.Semaphore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 객체의 인터페이스는 &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Semaphore&quot;&gt; &lt;code&gt;threading.Semaphore&lt;/code&gt; &lt;/a&gt; 와 비슷하지만 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="9a68395d90aeaf758adfebddbd727e34ea765aab" translate="yes" xml:space="preserve">
          <source>This project is young and still somewhat experimental: the overall design is solid and the existing features are fully tested and documented, but you may encounter missing functionality or rough edges. We &lt;em&gt;do&lt;/em&gt; encourage you do use it, but you should &lt;a href=&quot;https://github.com/python-trio/trio/issues/1&quot;&gt;read and subscribe to issue #1&lt;/a&gt; to get warning and a chance to give feedback about any compatibility-breaking changes.</source>
          <target state="translated">이 프로젝트는 아직 젊고 다소 실험적입니다. 전체 디자인이 견고하고 기존 기능이 완전히 테스트 및 문서화되었지만 기능 누락 또는 거친 부분이 발생할 수 있습니다. 우리는 &lt;em&gt;않습니다&lt;/em&gt; 당신이 그것을 사용합니까 격려,하지만 당신은해야 &lt;a href=&quot;https://github.com/python-trio/trio/issues/1&quot;&gt;읽고 # 1을 발행 구독&lt;/a&gt; 경고 및 호환성 깨는 변경 사항에 대한 피드백을 제공 할 수있는 기회를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec32d26f4a4b5dcad7771a9eee995fa9164024e5" translate="yes" xml:space="preserve">
          <source>This returns a new &lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt;&lt;code&gt;MemoryReceiveChannel&lt;/code&gt;&lt;/a&gt; object, which acts as a duplicate of the original: receiving on the new object does exactly the same thing as receiving on the old object.</source>
          <target state="translated">이것은 새로운 &lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt; &lt;code&gt;MemoryReceiveChannel&lt;/code&gt; &lt;/a&gt; 객체를 반환하는데 , 이것은 원본의 복제본으로 작동합니다 : 새로운 객체를받는 것은 이전의 객체를받는 것과 정확히 같은 것입니다.</target>
        </trans-unit>
        <trans-unit id="a121a762df27863607d656fedc77c458d011385f" translate="yes" xml:space="preserve">
          <source>This returns a new &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt;&lt;code&gt;MemorySendChannel&lt;/code&gt;&lt;/a&gt; object, which acts as a duplicate of the original: sending on the new object does exactly the same thing as sending on the old object. (If you&amp;rsquo;re familiar with &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.dup&quot;&gt;&lt;code&gt;os.dup&lt;/code&gt;&lt;/a&gt;, then this is a similar idea.)</source>
          <target state="translated">이것은 새로운 &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt; &lt;code&gt;MemorySendChannel&lt;/code&gt; &lt;/a&gt; 객체를 반환하는데 , 이것은 원본의 복제본 역할을합니다. &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.dup&quot;&gt; &lt;code&gt;os.dup&lt;/code&gt; 에&lt;/a&gt; 익숙하다면 비슷한 아이디어입니다.</target>
        </trans-unit>
        <trans-unit id="e198f11e3abc356f6bac5f79d25c297a458de712" translate="yes" xml:space="preserve">
          <source>This setting has no effect if your program has registered a custom SIGINT handler, or if &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; is called from anywhere but the main thread (this is a Python limitation), or if you use &lt;a href=&quot;reference-io#trio.open_signal_receiver&quot;&gt;&lt;code&gt;open_signal_receiver()&lt;/code&gt;&lt;/a&gt; to catch SIGINT.</source>
          <target state="translated">이 설정은 프로그램이 사용자 정의 SIGINT 처리기를 등록했거나 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 이 주 스레드 이외의 곳에서 호출 된 경우 ( Python 제한) &lt;a href=&quot;reference-io#trio.open_signal_receiver&quot;&gt; &lt;code&gt;open_signal_receiver()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 SIGINT를 잡는 경우에는 효과가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8544c29e984137341c0686f2d63ccb7f84894719" translate="yes" xml:space="preserve">
          <source>This should include all the attributes exposed by classes in &lt;a href=&quot;https://docs.python.org/3/library/io.html#module-io&quot;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;. But if you&amp;rsquo;re wrapping an object that has other attributes that aren&amp;rsquo;t on the list above, then you can access them via the &lt;code&gt;.wrapped&lt;/code&gt; attribute:</source>
          <target state="translated">여기에는 &lt;a href=&quot;https://docs.python.org/3/library/io.html#module-io&quot;&gt; &lt;code&gt;io&lt;/code&gt; 의&lt;/a&gt; 클래스에 의해 노출되는 모든 속성이 포함되어야합니다 . 그러나 위 목록에없는 다른 속성을 가진 객체를 래핑하는 경우 &lt;code&gt;.wrapped&lt;/code&gt; 속성을 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b75455664926a8069eb8f58115417e9cb3001585" translate="yes" xml:space="preserve">
          <source>This should never happen! If you get this error, please file a bug.</source>
          <target state="translated">이런 일은 절대 일어나지 않아야합니다! 이 오류가 발생하면 버그를 신고하십시오.</target>
        </trans-unit>
        <trans-unit id="0778ce6636c49535b569f7546a62446d88b94afe" translate="yes" xml:space="preserve">
          <source>This stream has &lt;em&gt;absolutely no&lt;/em&gt; buffering. Each call to &lt;a href=&quot;reference-io#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; will block until all the given data has been returned by a call to &lt;a href=&quot;reference-io#trio.abc.ReceiveStream.receive_some&quot;&gt;&lt;code&gt;receive_some()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 스트림에는 버퍼링 이 &lt;em&gt;전혀 없습니다&lt;/em&gt; . 각 호출 &lt;a href=&quot;reference-io#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; 모든 데이터가 소정의 호출에 의해 리턴 될 때까지 차단 &lt;a href=&quot;reference-io#trio.abc.ReceiveStream.receive_some&quot;&gt; &lt;code&gt;receive_some()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c6928d21a889dc4f82db9ebb48058b9d6fb885e" translate="yes" xml:space="preserve">
          <source>This task&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#contextvars.Context&quot;&gt;&lt;code&gt;contextvars.Context&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">이 작업의 &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#contextvars.Context&quot;&gt; &lt;code&gt;contextvars.Context&lt;/code&gt; &lt;/a&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="d87a62610b91ba5d469e111e2195effe428736a6" translate="yes" xml:space="preserve">
          <source>This task&amp;rsquo;s coroutine object. Example usage: extracting a stack trace:</source>
          <target state="translated">이 작업의 코 루틴 객체. 사용법 예 : 스택 추적 추출 :</target>
        </trans-unit>
        <trans-unit id="6b3da9f4aca9dba70e3bde25fee8a94969706173" translate="yes" xml:space="preserve">
          <source>This wakes up &lt;code&gt;count&lt;/code&gt; tasks that are blocked in &lt;a href=&quot;#trio.hazmat.ParkingLot.park&quot;&gt;&lt;code&gt;park()&lt;/code&gt;&lt;/a&gt;. If there are fewer than &lt;code&gt;count&lt;/code&gt; tasks parked, then wakes as many tasks are available and then returns successfully.</source>
          <target state="translated">이것은 &lt;a href=&quot;#trio.hazmat.ParkingLot.park&quot;&gt; &lt;code&gt;park()&lt;/code&gt; &lt;/a&gt; 에서 차단 된 &lt;code&gt;count&lt;/code&gt; 작업을 깨 웁니다 . 파킹 된 수보다 적은 &lt;code&gt;count&lt;/code&gt; 작업이있는 경우 사용 가능한 많은 수의 작업을 깨운 다음 ​​성공적으로 돌아옵니다.</target>
        </trans-unit>
        <trans-unit id="aee475931b299c6d841c958af99cba9eabd02399" translate="yes" xml:space="preserve">
          <source>This way we can see that request 1 was slow: it started before request 2 but finished afterwards. (You can also get &lt;a href=&quot;https://opentracing.io/docs/&quot;&gt;much fancier&lt;/a&gt;, but this is enough for an example.)</source>
          <target state="translated">이런 식으로 요청 1이 느리다는 것을 알 수 있습니다. 요청 2는 요청 2 이전에 시작되었지만 나중에 완료되었습니다. (당신은 &lt;a href=&quot;https://opentracing.io/docs/&quot;&gt;훨씬 더 많은&lt;/a&gt; 것을 얻을 수 있지만 이것은 예를 위해 충분합니다.)</target>
        </trans-unit>
        <trans-unit id="a4429c38a1975f5763a238e06f0d62b450c78494" translate="yes" xml:space="preserve">
          <source>This will probably be clearer with an example. Here we demonstrate how to spawn a child thread, and then use a &lt;a href=&quot;#channels&quot;&gt;memory channel&lt;/a&gt; to send messages between the thread and a Trio task:</source>
          <target state="translated">이것은 아마도 예를 들어 더 명확해질 것입니다. 다음은 자식 스레드를 생성 한 다음 &lt;a href=&quot;#channels&quot;&gt;메모리 채널&lt;/a&gt; 을 사용 하여 스레드와 Trio 작업간에 메시지를 보내는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="11d26ec84465ee4cd2879abd7330229b6daec696" translate="yes" xml:space="preserve">
          <source>This works by starting a set of tasks which each try to run their function, and then report back the value it returns. The main task uses &lt;code&gt;receive_channel.receive&lt;/code&gt; to wait for one to finish; as soon as the first task crosses the finish line, it cancels the rest, and then returns the winning value.</source>
          <target state="translated">이것은 각각의 기능을 실행하려고 시도하는 작업 세트를 시작한 다음 반환되는 값을 다시보고하여 작동합니다. 기본 작업은 &lt;code&gt;receive_channel.receive&lt;/code&gt; 를 사용 하여 하나가 완료 될 때까지 기다립니다. 첫 번째 작업이 결승선을 통과하자마자 나머지 작업을 취소 한 다음 승리 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="47930bd9c8e42779dd9eefabccf4759ba973fe91" translate="yes" xml:space="preserve">
          <source>This wraps any file object in a wrapper that provides an asynchronous file object interface.</source>
          <target state="translated">비동기 파일 오브젝트 인터페이스를 제공하는 랩퍼로 파일 오브젝트를 랩핑합니다.</target>
        </trans-unit>
        <trans-unit id="d0cef5deb223649da3c92e68bafacf5c8ccd785e" translate="yes" xml:space="preserve">
          <source>Thread safety</source>
          <target state="translated">스레드 안전</target>
        </trans-unit>
        <trans-unit id="c2ae2cf32d685dc7a1f9f34c4a9d9327ffc68dbc" translate="yes" xml:space="preserve">
          <source>Threads (if you must)</source>
          <target state="translated">스레드 (필요한 경우)</target>
        </trans-unit>
        <trans-unit id="0466f8bc08e10e7b99d662eae8d049fece98b184" translate="yes" xml:space="preserve">
          <source>Time and clocks</source>
          <target state="translated">시간과 시계</target>
        </trans-unit>
        <trans-unit id="c86350a7e132f385d94c48db12ed5fffe7264e2d" translate="yes" xml:space="preserve">
          <source>Time and timeouts</source>
          <target state="translated">시간과 타임 아웃</target>
        </trans-unit>
        <trans-unit id="9672fd790323861a273f8a756b00c40cc5fc7c09" translate="yes" xml:space="preserve">
          <source>To be used as a Trio stream, an open file must be placed in non-blocking mode. Unfortunately, this impacts all I/O that goes through the underlying open file, including I/O that uses a different file descriptor than the one that was passed to Trio. If other threads or processes are using file descriptors that are related through &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.dup&quot;&gt;&lt;code&gt;os.dup&lt;/code&gt;&lt;/a&gt; or inheritance across &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.fork&quot;&gt;&lt;code&gt;os.fork&lt;/code&gt;&lt;/a&gt; to the one that Trio is using, they are unlikely to be prepared to have non-blocking I/O semantics suddenly thrust upon them. For example, you can use &lt;code&gt;FdStream(os.dup(0))&lt;/code&gt; to obtain a stream for reading from standard input, but it is only safe to do so with heavy caveats: your stdin must not be shared by any other processes and you must not make any calls to synchronous methods of &lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.stdin&quot;&gt;&lt;code&gt;sys.stdin&lt;/code&gt;&lt;/a&gt; until the stream returned by &lt;a href=&quot;#trio.hazmat.FdStream&quot;&gt;&lt;code&gt;FdStream&lt;/code&gt;&lt;/a&gt; is closed. See &lt;a href=&quot;https://github.com/python-trio/trio/issues/174&quot;&gt;issue #174&lt;/a&gt; for a discussion of the challenges involved in relaxing this restriction.</source>
          <target state="translated">Trio 스트림으로 사용하려면 열린 파일을 비 차단 모드로 두어야합니다. 불행하게도 이는 Trio에 전달 된 것과 다른 파일 설명자를 사용하는 I / O를 포함하여 기본 열린 파일을 통과하는 모든 I / O에 영향을줍니다. 다른 스레드 또는 프로세스가 &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.dup&quot;&gt; &lt;code&gt;os.dup&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.fork&quot;&gt; &lt;code&gt;os.fork&lt;/code&gt; &lt;/a&gt; 를 통한 Trio가 사용하는 것과의 상속을 통해 관련된 파일 디스크립터를 사용하는 경우 비 블로킹 I / O 시맨틱이 갑자기 스러스트 될 가능성이 없습니다. 예를 들어, &lt;code&gt;FdStream(os.dup(0))&lt;/code&gt; 을 사용하여 표준 입력에서 읽을 스트림을 얻을 수 있지만 큰 경고가있는 경우에만 안전합니다. stdin은 다른 프로세스와 공유하지 않아야하며 동기 메소드를 호출하지 마십시오.&lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.stdin&quot;&gt; &lt;code&gt;sys.stdin&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#trio.hazmat.FdStream&quot;&gt; &lt;code&gt;FdStream&lt;/code&gt; &lt;/a&gt; 에의해 반환 된 스트림이 닫힐때까지 sys.stdin 이 제한 완화와 관련된&lt;a href=&quot;https://github.com/python-trio/trio/issues/174&quot;&gt; 문제&lt;/a&gt; 에 대한 논의는 문제 # 174 를참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b931c6b0d780ed8d96ccd76191352b796bd15ae7" translate="yes" xml:space="preserve">
          <source>To build a bidirectional stream, &lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt;&lt;code&gt;memory_stream_pair()&lt;/code&gt;&lt;/a&gt; uses two unidirectional streams. It gets these by calling &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt;&lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">양방향 스트림을 빌드하기 위해 &lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt; &lt;code&gt;memory_stream_pair()&lt;/code&gt; &lt;/a&gt; 는 두 개의 단방향 스트림을 사용합니다. &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt; &lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; 를 호출하여이를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="05516bbca026f3ec58a38804bdec50fda7847866" translate="yes" xml:space="preserve">
          <source>To solve this problem, Python 3.7 added a new module to the standard library: &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt;&lt;code&gt;contextvars&lt;/code&gt;&lt;/a&gt;. And not only does Trio have built-in support for &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt;&lt;code&gt;contextvars&lt;/code&gt;&lt;/a&gt;, but if you&amp;rsquo;re using an earlier version of Python, then Trio makes sure that a backported version of &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt;&lt;code&gt;contextvars&lt;/code&gt;&lt;/a&gt; is installed. So you can assume &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt;&lt;code&gt;contextvars&lt;/code&gt;&lt;/a&gt; is there and works regardless of what version of Python you&amp;rsquo;re using.</source>
          <target state="translated">이 문제를 해결하기 위해 Python 3.7은 표준 라이브러리에 &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt; &lt;code&gt;contextvars&lt;/code&gt; &lt;/a&gt; 새로운 모듈을 추가했습니다 . 또한 Trio는 &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt; &lt;code&gt;contextvars&lt;/code&gt; &lt;/a&gt; 를 기본적 으로 지원할 뿐만 아니라 이전 버전의 Python을 사용하는 경우 &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt; &lt;code&gt;contextvars&lt;/code&gt; &lt;/a&gt; 버전의 contextvars 가 설치되어 있는지 확인합니다 . 따라서 &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt; &lt;code&gt;contextvars&lt;/code&gt; &lt;/a&gt; 가 있다고 가정 하고 사용중인 Python 버전에 관계없이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e5cd337a0a94a79ca9bf0c7b1bbc3dbf9f0f4355" translate="yes" xml:space="preserve">
          <source>To understand why, you need to know two things.</source>
          <target state="translated">이유를 이해하려면 두 가지를 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="db3006577395a2fbdf588f1767d5cce77ff37b7b" translate="yes" xml:space="preserve">
          <source>Top-level exports</source>
          <target state="translated">최상위 수출</target>
        </trans-unit>
        <trans-unit id="f6b456d043430ca913d9174bb8cfc55ab351d5d3" translate="yes" xml:space="preserve">
          <source>Trio</source>
          <target state="translated">Trio</target>
        </trans-unit>
        <trans-unit id="e10ab5c8f9662b6d401524134931ffbe3ea711b3" translate="yes" xml:space="preserve">
          <source>Trio 0.1.0 (2017-03-10)</source>
          <target state="translated">트리오 0.1.0 (2017-03-10)</target>
        </trans-unit>
        <trans-unit id="74fa2c2fe4c26140ed7ec69a5902a700dc2e2288" translate="yes" xml:space="preserve">
          <source>Trio 0.10.0 (2019-01-07)</source>
          <target state="translated">트리오 0.10.0 (2019-01-07)</target>
        </trans-unit>
        <trans-unit id="69e4642ca3df5dc9d3712b14dba73397b158dcb9" translate="yes" xml:space="preserve">
          <source>Trio 0.11.0 (2019-02-09)</source>
          <target state="translated">트리오 0.11.0 (2019-02-09)</target>
        </trans-unit>
        <trans-unit id="6c74db81639abc94a5e78afb9914315a7d2e61e4" translate="yes" xml:space="preserve">
          <source>Trio 0.12.0 (2019-07-31)</source>
          <target state="translated">트리오 0.12.0 (2019-07-31)</target>
        </trans-unit>
        <trans-unit id="756c5475a93f96aff35a02be8296ff76a5362ef7" translate="yes" xml:space="preserve">
          <source>Trio 0.12.1 (2019-08-01)</source>
          <target state="translated">트리오 0.12.1 (2019-08-01)</target>
        </trans-unit>
        <trans-unit id="b6e5fe42049ac788a8f0350bb9328d46cf841544" translate="yes" xml:space="preserve">
          <source>Trio 0.2.0 (2017-12-06)</source>
          <target state="translated">트리오 0.2.0 (2017-12-06)</target>
        </trans-unit>
        <trans-unit id="b3fb820f535b0b0931f359e1e3feac669d9d79ff" translate="yes" xml:space="preserve">
          <source>Trio 0.3.0 (2017-12-28)</source>
          <target state="translated">트리오 0.3.0 (2017-12-28)</target>
        </trans-unit>
        <trans-unit id="9ec0f7f2eed5ceef8d882523ec63a0688d3dee74" translate="yes" xml:space="preserve">
          <source>Trio 0.4.0 (2018-04-10)</source>
          <target state="translated">트리오 0.4.0 (2018-04-10)</target>
        </trans-unit>
        <trans-unit id="a5e71a7a8c48bb819251fac725eb027372565fc6" translate="yes" xml:space="preserve">
          <source>Trio 0.5.0 (2018-07-20)</source>
          <target state="translated">트리오 0.5.0 (2018-07-20)</target>
        </trans-unit>
        <trans-unit id="3c47332ee2a79b093d8020cb914bb8ee16c6946d" translate="yes" xml:space="preserve">
          <source>Trio 0.6.0 (2018-08-13)</source>
          <target state="translated">트리오 0.6.0 (2018-08-13)</target>
        </trans-unit>
        <trans-unit id="0b496cd9f24b90ed762a98cc2aaf2290bd868eda" translate="yes" xml:space="preserve">
          <source>Trio 0.7.0 (2018-09-03)</source>
          <target state="translated">트리오 0.7.0 (2018-09-03)</target>
        </trans-unit>
        <trans-unit id="9d34c423781f712340e29d42f4ebc34888e6c599" translate="yes" xml:space="preserve">
          <source>Trio 0.8.0 (2018-10-01)</source>
          <target state="translated">트리오 0.8.0 (2018-10-01)</target>
        </trans-unit>
        <trans-unit id="8f6bc445719269e2c3dc52746939c55d83476611" translate="yes" xml:space="preserve">
          <source>Trio 0.9.0 (2018-10-12)</source>
          <target state="translated">트리오 0.9.0 (2018-10-12)</target>
        </trans-unit>
        <trans-unit id="0adbdcfaf558ea55b373e281d4d8e2a52d952289" translate="yes" xml:space="preserve">
          <source>Trio also provides several convenience functions for the common situation of just wanting to impose a timeout on some code:</source>
          <target state="translated">또한 Trio는 일부 코드에 타임 아웃을 적용하려는 일반적인 상황에 대한 여러 편의 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="63f1831f4b1f1da694680c3ac049ae563afd8ec4" translate="yes" xml:space="preserve">
          <source>Trio also provides some functions to help you test your custom stream implementations:</source>
          <target state="translated">또한 Trio는 사용자 지정 스트림 구현을 테스트하는 데 도움이되는 몇 가지 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f764514bda33ba237239ba96fe50aba14b67bee6" translate="yes" xml:space="preserve">
          <source>Trio also provides some specialized functions for testing completely &lt;strong&gt;un&lt;/strong&gt;buffered streams: &lt;a href=&quot;#trio.testing.lockstep_stream_one_way_pair&quot;&gt;&lt;code&gt;lockstep_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.lockstep_stream_pair&quot;&gt;&lt;code&gt;lockstep_stream_pair()&lt;/code&gt;&lt;/a&gt;. These aren&amp;rsquo;t customizable, but they do exhibit an extreme kind of behavior that&amp;rsquo;s good at catching out edge cases in protocol implementations.</source>
          <target state="translated">또한 Trio는 완전히 버퍼링 &lt;strong&gt;되지 않은&lt;/strong&gt; 스트림 을 테스트하기위한 몇 가지 특수 함수 인 &lt;a href=&quot;#trio.testing.lockstep_stream_one_way_pair&quot;&gt; &lt;code&gt;lockstep_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.testing.lockstep_stream_pair&quot;&gt; &lt;code&gt;lockstep_stream_pair()&lt;/code&gt; &lt;/a&gt; 합니다. 이것들은 커스터마이징이 가능하지 않지만 프로토콜 구현에서 우연한 사례를 포착하는 데 좋은 극단적 인 종류의 행동을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d7707add294b6ac0bac54c516a3af471b6c78a17" translate="yes" xml:space="preserve">
          <source>Trio currently provides a generic helper for writing servers that listen for connections using one or more &lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;code&gt;Listener&lt;/code&gt;&lt;/a&gt;s, and a generic utility class for working with streams. And if you want to test code that&amp;rsquo;s written against the streams interface, you should also check out &lt;a href=&quot;reference-testing#testing-streams&quot;&gt;Streams&lt;/a&gt; in &lt;a href=&quot;reference-testing#module-trio.testing&quot;&gt;&lt;code&gt;trio.testing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Trio는 현재 하나 이상의 &lt;a href=&quot;#trio.abc.Listener&quot;&gt; &lt;code&gt;Listener&lt;/code&gt; &lt;/a&gt; 사용하여 연결을 수신하는 서버를 작성하기위한 일반 헬퍼 및 스트림 작업을위한 일반 유틸리티 클래스를 제공합니다. 당신이 스트림 인터페이스에 쓰여 테스트 코드를 원한다면, 당신은 또한 체크 아웃해야 &lt;a href=&quot;reference-testing#testing-streams&quot;&gt;스트림을&lt;/a&gt; 에 &lt;a href=&quot;reference-testing#module-trio.testing&quot;&gt; &lt;code&gt;trio.testing&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1bb137836035175c111f8a48b35d84efdbd8248f" translate="yes" xml:space="preserve">
          <source>Trio doesn&amp;rsquo;t assign this variable any meaning, except that it sets it to &lt;code&gt;None&lt;/code&gt; whenever a task is rescheduled. It can be used to share data between the different tasks involved in putting a task to sleep and then waking it up again. (See &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">Trio는 작업이 다시 예약 될 때마다이 변수를 &lt;code&gt;None&lt;/code&gt; 설정한다는 점을 제외하고이 변수에 어떤 의미도 지정하지 않습니다 . 작업을 휴면 상태로 설정하고 다시 깨우는 데 관련된 여러 작업간에 데이터를 공유하는 데 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3c621c59b80ace2edb624e5e2050d6d2698da42c" translate="yes" xml:space="preserve">
          <source>Trio doesn&amp;rsquo;t itself provide a virtual in-memory network implementation for testing &amp;ndash; but &lt;a href=&quot;reference-io#module-trio.socket&quot;&gt;&lt;code&gt;trio.socket&lt;/code&gt;&lt;/a&gt; module does provide the hooks you need to write your own! And if you&amp;rsquo;re interested in helping implement a reusable virtual network for testing, then &lt;a href=&quot;https://github.com/python-trio/trio/issues/170&quot;&gt;please get in touch&lt;/a&gt;.</source>
          <target state="translated">Trio 자체는 테스트를위한 가상 메모리 내 네트워크 구현을 제공하지는 않지만 &lt;a href=&quot;reference-io#module-trio.socket&quot;&gt; &lt;code&gt;trio.socket&lt;/code&gt; &lt;/a&gt; 모듈은 자체 작성에 필요한 후크를 제공합니다! 테스트를 위해 재사용 가능한 가상 네트워크를 구현하는 데 관심이 &lt;a href=&quot;https://github.com/python-trio/trio/issues/170&quot;&gt;있으시면 연락하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a89d8834bcdebd9f608acfe93a7bb122db53b5f9" translate="yes" xml:space="preserve">
          <source>Trio has a rich, composable system for cancelling work, either explicitly or when a timeout expires.</source>
          <target state="translated">Trio에는 명시 적으로 또는 시간 초과가 만료 될 때 작업을 취소 할 수있는 풍부하고 구성 가능한 시스템이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3224a6971f04b494f9517ecb8aea8b567e1c0a9e" translate="yes" xml:space="preserve">
          <source>Trio intentionally DOES NOT include some obsolete, redundant, or broken features:</source>
          <target state="translated">Trio는 일부 쓸모 없거나 중복되거나 파손 된 기능을 의도적으로 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7fb99857ba430551418d478736812a8a2d129e38" translate="yes" xml:space="preserve">
          <source>Trio provides SSL/TLS support based on the standard library &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#module-ssl&quot;&gt;&lt;code&gt;ssl&lt;/code&gt;&lt;/a&gt; module. Trio&amp;rsquo;s &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.SSLListener&quot;&gt;&lt;code&gt;SSLListener&lt;/code&gt;&lt;/a&gt; take their configuration from a &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;code&gt;ssl.SSLContext&lt;/code&gt;&lt;/a&gt;, which you can create using &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt;&lt;code&gt;ssl.create_default_context()&lt;/code&gt;&lt;/a&gt; and customize using the other constants and functions in the &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#module-ssl&quot;&gt;&lt;code&gt;ssl&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Trio는 표준 라이브러리 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#module-ssl&quot;&gt; &lt;code&gt;ssl&lt;/code&gt; &lt;/a&gt; 모듈을 기반으로 SSL / TLS 지원을 제공합니다 . Trio의 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.SSLListener&quot;&gt; &lt;code&gt;SSLListener&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt; &lt;code&gt;ssl.SSLContext&lt;/code&gt; &lt;/a&gt; 에서 구성을 가져 옵니다 . &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt; &lt;code&gt;ssl.create_default_context()&lt;/code&gt; &lt;/a&gt; 사용하여 작성 하고 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#module-ssl&quot;&gt; &lt;code&gt;ssl&lt;/code&gt; &lt;/a&gt; 모듈 의 다른 상수 및 함수를 사용하여 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d817001a39f23d2d7c8a88010d0511c25864d40c" translate="yes" xml:space="preserve">
          <source>Trio provides a set of abstract base classes that define a standard interface for unidirectional and bidirectional byte streams.</source>
          <target state="translated">Trio는 단방향 및 양방향 바이트 스트림에 대한 표준 인터페이스를 정의하는 추상 기본 클래스 세트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8e040b74b4c87ec08a16ce1813ad188d5335f33d" translate="yes" xml:space="preserve">
          <source>Trio provides a standard set of synchronization and inter-task communication primitives. These objects&amp;rsquo; APIs are generally modelled off of the analogous classes in the standard library, but with some differences.</source>
          <target state="translated">Trio는 표준 동기화 및 작업 간 통신 프리미티브 세트를 제공합니다. 이러한 객체의 API는 일반적으로 표준 라이브러리의 유사한 클래스에서 모델링되지만 약간의 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="74425cde00c0b01b295243623ba0bba1679d9dc5" translate="yes" xml:space="preserve">
          <source>Trio provides built-in facilities for performing asynchronous filesystem operations like reading or renaming a file. Generally, we recommend that you use these instead of Python&amp;rsquo;s normal synchronous file APIs. But the tradeoffs here are somewhat subtle: sometimes people switch to async I/O, and then they&amp;rsquo;re surprised and confused when they find it doesn&amp;rsquo;t speed up their program. The next section explains the theory behind async file I/O, to help you better understand your code&amp;rsquo;s behavior. Or, if you just want to get started, you can &lt;a href=&quot;ref:async-file-io-overview&quot;&gt;jump down to the API overview&lt;/a&gt;.</source>
          <target state="translated">Trio는 파일 읽기 또는 이름 바꾸기와 같은 비동기 파일 시스템 작업을 수행하기위한 내장 기능을 제공합니다. 일반적으로, 파이썬의 일반 동기 파일 API 대신 이들을 사용하는 것이 좋습니다. 그러나 여기서의 절충점은 다소 미묘합니다. 때로는 사람들이 비동기 I / O로 전환 한 다음 프로그램 속도를 높이 지 못한다는 사실에 놀랐습니다. 다음 섹션에서는 코드의 동작을보다 잘 이해할 수 있도록 비동기 파일 I / O의 이론을 설명합니다. 또는 시작하려는 경우 &lt;a href=&quot;ref:async-file-io-overview&quot;&gt;API 개요로 이동할&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d95788f65d0c3c8483b4904e8ba1a027a20a92c4" translate="yes" xml:space="preserve">
          <source>Trio provides support for spawning other programs as subprocesses, communicating with them via pipes, sending them signals, and waiting for them to exit. The interface for doing so consists of two layers:</source>
          <target state="translated">Trio는 다른 프로그램을 하위 프로세스로 생성하고 파이프를 통해 통신하고 신호를 보내고 종료 될 때까지 지원합니다. 이를위한 인터페이스는 두 개의 계층으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="e3e4c4f0590113b206fe27748965cb6ce85a583a" translate="yes" xml:space="preserve">
          <source>Trio socket objects are overall very similar to the &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket-objects&quot;&gt;standard library socket objects&lt;/a&gt;, with a few important differences:</source>
          <target state="translated">Trio 소켓 객체는 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket-objects&quot;&gt;표준 라이브러리 소켓 객체&lt;/a&gt; 와 전반적으로 매우 유사하지만 몇 가지 중요한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bb057fa930f31cd5b5ad52664f8b9bd7e4a82d9" translate="yes" xml:space="preserve">
          <source>Trio tokens</source>
          <target state="translated">트리오 토큰</target>
        </trans-unit>
        <trans-unit id="5d408b00bf8df0f0790a83ccf1901d19c622725e" translate="yes" xml:space="preserve">
          <source>Trio tries hard to provide useful hooks for debugging and instrumentation. Some are documented above (the nursery introspection attributes, &lt;a href=&quot;reference-core#trio.Lock.statistics&quot;&gt;&lt;code&gt;trio.Lock.statistics()&lt;/code&gt;&lt;/a&gt;, etc.). Here are some more.</source>
          <target state="translated">Trio는 디버깅 및 계측에 유용한 후크를 제공하려고 노력합니다. 일부는 위에 설명되어 있습니다 (보육원 내성 속성, &lt;a href=&quot;reference-core#trio.Lock.statistics&quot;&gt; &lt;code&gt;trio.Lock.statistics()&lt;/code&gt; &lt;/a&gt; 등). 몇 가지 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="a095b9420b975351418baa59d47d28cab0b88e9d" translate="yes" xml:space="preserve">
          <source>Trio was built from the ground up to take advantage of the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0492/&quot;&gt;latest Python features&lt;/a&gt;, and draws inspiration from &lt;a href=&quot;https://github.com/python-trio/trio/wiki/Reading-list&quot;&gt;many sources&lt;/a&gt;, in particular Dave Beazley&amp;rsquo;s &lt;a href=&quot;https://curio.readthedocs.io/&quot;&gt;Curio&lt;/a&gt;. The resulting design is radically simpler than older competitors like &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html&quot;&gt;asyncio&lt;/a&gt; and &lt;a href=&quot;https://twistedmatrix.com/&quot;&gt;Twisted&lt;/a&gt;, yet just as capable. Trio is the Python I/O library I always wanted; I find it makes building I/O-oriented programs easier, less error-prone, and just plain more fun. Perhaps you&amp;rsquo;ll find the same.</source>
          <target state="translated">Trio는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0492/&quot;&gt;최신 Python 기능&lt;/a&gt; 을 활용하기 위해 처음부터 구축되었으며, 특히 Dave Beazley의 &lt;a href=&quot;https://curio.readthedocs.io/&quot;&gt;Curio&lt;/a&gt; 와 같은 &lt;a href=&quot;https://github.com/python-trio/trio/wiki/Reading-list&quot;&gt;여러 소스&lt;/a&gt; 에서 영감을 얻습니다 . 결과 디자인은 &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html&quot;&gt;asyncio&lt;/a&gt; 및 &lt;a href=&quot;https://twistedmatrix.com/&quot;&gt;Twisted&lt;/a&gt; 와 같은 구형 경쟁사보다 훨씬 간단 하지만 가능합니다. Trio는 항상 원했던 Python I / O 라이브러리입니다. 필자는 I / O 지향 프로그램을보다 쉽고 오류 발생이 적으며 평범한 재미로 만듭니다. 아마도 당신은 같은 것을 찾을 것입니다.</target>
        </trans-unit>
        <trans-unit id="c846abd10c13fb3992cae8ffb8e6074c68f407e6" translate="yes" xml:space="preserve">
          <source>Trio&amp;rsquo;s answer is that it raises a &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt; object. This is a special exception which encapsulates multiple exception objects &amp;ndash; either regular exceptions or nested &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt;s. To make these easier to work with, Trio installs a custom &lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.excepthook&quot;&gt;&lt;code&gt;sys.excepthook&lt;/code&gt;&lt;/a&gt; that knows how to print nice tracebacks for unhandled &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt;s, and it also provides some helpful utilities like &lt;a href=&quot;#trio.MultiError.catch&quot;&gt;&lt;code&gt;MultiError.catch()&lt;/code&gt;&lt;/a&gt;, which allows you to catch &amp;ldquo;part of&amp;rdquo; a &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Trio의 대답은 &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; 객체를 발생시키는 것입니다. 이것은 일반적인 예외 또는 중첩 된 &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; 와 같은 여러 예외 개체를 캡슐화하는 특수 예외입니다 . 와 작업에이 쉽게하기 위해, 트리오는 사용자 정의 설치 &lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.excepthook&quot;&gt; &lt;code&gt;sys.excepthook&lt;/code&gt; &lt;/a&gt; 처리되지 않은에 대한 좋은 역 추적 인쇄하는 방법을 알고 &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; 들, 또한 같은 몇 가지 유용한 유틸리티를 제공합니다 &lt;a href=&quot;#trio.MultiError.catch&quot;&gt; &lt;code&gt;MultiError.catch()&lt;/code&gt; &lt;/a&gt; 는 &quot;부분을&quot;잡을 수 있습니다, &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d2b9708cc5b4a0aa94a8cbf018536b856ae4ed6" translate="yes" xml:space="preserve">
          <source>Trio&amp;rsquo;s asynchronous file objects have an interface that automatically adapts to the object being wrapped. Intuitively, you can mostly treat them like a regular &lt;a href=&quot;https://docs.python.org/3/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;, except adding an &lt;code&gt;await&lt;/code&gt; in front of any of methods that do I/O. The definition of &lt;a href=&quot;https://docs.python.org/3/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt; is a little vague in Python though, so here are the details:</source>
          <target state="translated">Trio의 비동기 파일 객체에는 줄 바꿈 된 객체에 자동으로 적응하는 인터페이스가 있습니다. 직관적으로, I / O를 수행하는 메소드 앞에 &lt;code&gt;await&lt;/code&gt; 를 추가하는 것을 제외하고 는 대부분 &lt;a href=&quot;https://docs.python.org/3/glossary.html#term-file-object&quot;&gt;파일을&lt;/a&gt; 일반 파일 오브젝트 처럼 취급 할 수 있습니다 . 파이썬 에서는 &lt;a href=&quot;https://docs.python.org/3/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 의 정의가 약간 모호하므로 자세한 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e1395e9cde88f70c434acca97212f29b2fa46091" translate="yes" xml:space="preserve">
          <source>Trio&amp;rsquo;s core functionality</source>
          <target state="translated">트리오의 핵심 기능</target>
        </trans-unit>
        <trans-unit id="f97e2b82c90599d9b44281129e282e3a9dda83cd" translate="yes" xml:space="preserve">
          <source>Trio&amp;rsquo;s handling of control-C is designed to balance usability and safety. On the one hand, there are sensitive regions (like the core scheduling loop) where it&amp;rsquo;s simply impossible to handle arbitrary &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; exceptions while maintaining our core correctness invariants. On the other, if the user accidentally writes an infinite loop, we do want to be able to break out of that. Our solution is to install a default signal handler which checks whether it&amp;rsquo;s safe to raise &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; at the place where the signal is received. If so, then we do; otherwise, we schedule a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; to be delivered to the main task at the next available opportunity (similar to how &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; is delivered).</source>
          <target state="translated">Trio의 control-C 취급은 사용 성과 안전의 균형을 유지하도록 설계되었습니다. 한편으로는 핵심 스케줄링 불변성을 유지하면서 임의의 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 예외 를 처리하는 것이 불가능한 민감한 영역 (예 : 코어 스케줄링 루프)이 있습니다 . 다른 한편으로, 사용자가 실수로 무한 루프를 작성한다면, 우리는 그 루프에서 벗어날 수 있기를 원합니다. 우리의 해결책은 신호가 수신되는 장소에서 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 를 발생시키는 것이 안전한지 확인하는 기본 신호 처리기를 설치하는 것 입니다. 그렇다면 우리는 그렇게합니다. 그렇지 않으면, 다음에 이용 가능한 기회 ( &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 가 전달되는 방법과 유사)에서 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 가 기본 태스크로 전달되도록 스케줄합니다 .</target>
        </trans-unit>
        <trans-unit id="e4de41bd04af3ba5cdbb7231b08e1a1e6c3fe88c" translate="yes" xml:space="preserve">
          <source>Trio&amp;rsquo;s philosophy about managing worker threads</source>
          <target state="translated">작업자 스레드 관리에 대한 Trio의 철학</target>
        </trans-unit>
        <trans-unit id="0a05358999edb18564ef080ed20cf4c015b3b0fb" translate="yes" xml:space="preserve">
          <source>Trio&amp;rsquo;s solution to this problem is to split worker thread management into two layers. The lower layer is responsible for taking blocking I/O jobs and arranging for them to run immediately on some worker thread. It takes care of solving the tricky concurrency problems involved in managing threads and is responsible for optimizations like re-using threads, but has no admission control policy: if you give it 100,000 jobs, it will spawn 100,000 threads. The upper layer is responsible for providing the policy to make sure that this doesn&amp;rsquo;t happen &amp;ndash; but since it &lt;em&gt;only&lt;/em&gt; has to worry about policy, it can be much simpler. In fact, all there is to it is the &lt;code&gt;limiter=&lt;/code&gt; argument passed to &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt;. This defaults to a global &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; object, which gives us the classic fixed-size thread pool behavior. (See &lt;a href=&quot;#trio.to_thread.current_default_thread_limiter&quot;&gt;&lt;code&gt;trio.to_thread.current_default_thread_limiter()&lt;/code&gt;&lt;/a&gt;.) But if you want to use &amp;ldquo;separate pools&amp;rdquo; for type A jobs and type B jobs, then it&amp;rsquo;s just a matter of creating two separate &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; objects and passing them in when running these jobs. Or here&amp;rsquo;s an example of defining a custom policy that respects the global thread limit, while making sure that no individual user can use more than 3 threads at a time:</source>
          <target state="translated">이 문제에 대한 Trio의 솔루션은 작업자 스레드 관리를 두 계층으로 나누는 것입니다. 하위 계층은 I / O 작업을 차단하고 일부 작업자 스레드에서 즉시 실행되도록 구성합니다. 스레드 관리와 관련된 까다로운 동시성 문제를 해결하고 스레드 재사용과 같은 최적화를 담당하지만 승인 제어 정책은 없습니다. 10 만 개의 작업을 제공하면 10 만 개의 스레드가 생성됩니다. 상위 계층은 이러한 상황이 발생하지 않도록 정책을 제공해야하지만 정책에 &lt;em&gt;대해서만&lt;/em&gt; 걱정하면되므로 훨씬 간단 할 수 있습니다. 실제로 &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt; 전달 된 &lt;code&gt;limiter=&lt;/code&gt; 인수 만 있으면 됩니다. 기본적으로 전역 &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt;객체로 고정 된 크기의 스레드 풀 동작을 제공합니다. ( &lt;a href=&quot;#trio.to_thread.current_default_thread_limiter&quot;&gt; &lt;code&gt;trio.to_thread.current_default_thread_limiter()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .) 유형 A 작업 및 유형 B 작업에 &quot;별도 풀&quot;을 사용하려면 두 개의 개별 &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt; 객체 를 생성 하고 이러한 작업을 실행할 때 전달하면됩니다. 또는 다음은 전체 스레드 제한을 준수하는 사용자 지정 정책을 정의하는 예이며 한 번에 개별 사용자가 3 개 이상의 스레드를 사용할 수 없도록합니다.</target>
        </trans-unit>
        <trans-unit id="6bc59e1ec96bc7a2423dbce69311bcfd506df149" translate="yes" xml:space="preserve">
          <source>Trio's friendly, yet comprehensive, manual:</source>
          <target state="translated">Trio의 친절하면서도 포괄적 인 매뉴얼 :</target>
        </trans-unit>
        <trans-unit id="225f97c8e66d76df4b30a947feaf0534521b0ead" translate="yes" xml:space="preserve">
          <source>Trio: a friendly Python library for async concurrency and I/O</source>
          <target state="translated">트리오 : 비동기 동시성 및 I / O를위한 친숙한 Python 라이브러리</target>
        </trans-unit>
        <trans-unit id="6f3b7a2bab0ca1f9fc7290da3cd87c32228ed36b" translate="yes" xml:space="preserve">
          <source>Trio’s core functionality</source>
          <target state="translated">트리오의 핵심 기능</target>
        </trans-unit>
        <trans-unit id="decf96be2aaef9ab02814ffa8c9f5b6de6f3b8d6" translate="yes" xml:space="preserve">
          <source>True if it successfully transferred some data, or False if there was no data to transfer.</source>
          <target state="translated">일부 데이터를 성공적으로 전송 한 경우 True, 전송할 데이터가없는 경우 False입니다.</target>
        </trans-unit>
        <trans-unit id="e1aaa899e304fc2f5d29d6e66a76d55ca76bd39e" translate="yes" xml:space="preserve">
          <source>True if protection is enabled, and False otherwise.</source>
          <target state="translated">보호가 활성화되어 있으면 true이고, 그렇지 않으면 False입니다.</target>
        </trans-unit>
        <trans-unit id="93add99f412693bb50177e85ca6a9d4948b325c9" translate="yes" xml:space="preserve">
          <source>True if successful, False otherwise.</source>
          <target state="translated">성공하면 True, 그렇지 않으면 False</target>
        </trans-unit>
        <trans-unit id="5d3e9a7a494f653bcacd93456806581953a79027" translate="yes" xml:space="preserve">
          <source>True if the lock is held, False otherwise.</source>
          <target state="translated">잠금이 유지되면 true이고, 그렇지 않으면 False입니다.</target>
        </trans-unit>
        <trans-unit id="6abc79262de514fd9235a1f0c1f891c91c282949" translate="yes" xml:space="preserve">
          <source>True if the path is absolute (has both a root and, if applicable, a drive).</source>
          <target state="translated">경로가 절대적이면 참 (루트와 해당되는 경우 드라이브)을 모두 갖습니다.</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="8a1c6f031eca837815e374433e41a167d90dbfd8" translate="yes" xml:space="preserve">
          <source>Tutorial and reference manual: &lt;a href=&quot;https://trio.readthedocs.io&quot;&gt;https://trio.readthedocs.io&lt;/a&gt;</source>
          <target state="translated">튜토리얼 및 참조 매뉴얼 : &lt;a href=&quot;https://trio.readthedocs.io&quot;&gt;https://trio.readthedocs.io&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="77dea2038e0265d1f2267dbda249ea9a80220f2c" translate="yes" xml:space="preserve">
          <source>Typically used together with &lt;a href=&quot;#trio.hazmat.cancel_shielded_checkpoint&quot;&gt;&lt;code&gt;cancel_shielded_checkpoint()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#trio.hazmat.cancel_shielded_checkpoint&quot;&gt; &lt;code&gt;cancel_shielded_checkpoint()&lt;/code&gt; &lt;/a&gt; 와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="fa6eb3e4b993dc224b732f0acd5cb818c8f6aedb" translate="yes" xml:space="preserve">
          <source>Unfortunately, if you get this error it also means that all bets are off &amp;ndash; Trio doesn&amp;rsquo;t know what is going on and its normal invariants may be void. (For example, we might have &amp;ldquo;lost track&amp;rdquo; of a task. Or lost track of all tasks.) Again, though, this shouldn&amp;rsquo;t happen.</source>
          <target state="translated">불행히도,이 오류가 발생하면 모든 베팅이 해제되었음을 의미합니다. Trio는 진행 상황을 알지 못하고 일반적인 불변 값이 무효화 될 수 있습니다. (예를 들어, 우리는 하나의 작업을 잃어 버렸거나 모든 작업을 잃어 버렸을 수도 있습니다.) 그러나 다시는 이런 일이 발생하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="ae8e0648b8830f351c3d504a2a43201c939ebb97" translate="yes" xml:space="preserve">
          <source>Universally available API</source>
          <target state="translated">범용 API</target>
        </trans-unit>
        <trans-unit id="709023972b44e1b7a1cb1b4210e5acf432bebfd7" translate="yes" xml:space="preserve">
          <source>Unix-specific API</source>
          <target state="translated">유닉스 전용 API</target>
        </trans-unit>
        <trans-unit id="bd09f3d61db7509d67bc57b83a3b0437c598cc43" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt;&lt;code&gt;socket.socket()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.socket.socket&quot;&gt;&lt;code&gt;trio.socket.socket()&lt;/code&gt;&lt;/a&gt; is a function, not a class; if you want to check whether an object is a Trio socket, use &lt;code&gt;isinstance(obj, trio.socket.SocketType)&lt;/code&gt;.</source>
          <target state="translated">달리 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt; &lt;code&gt;socket.socket()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#trio.socket.socket&quot;&gt; &lt;code&gt;trio.socket.socket()&lt;/code&gt; &lt;/a&gt; 함수가 아닌 클래스이며; 객체가 Trio 소켓인지 확인하려면 &lt;code&gt;isinstance(obj, trio.socket.SocketType)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f85d0717922d015ead8412878c3437596480edc5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event&quot;&gt;&lt;code&gt;threading.Event&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.Event&quot;&gt;&lt;code&gt;trio.Event&lt;/code&gt;&lt;/a&gt; has no &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; method. In Trio, once an &lt;a href=&quot;#trio.Event&quot;&gt;&lt;code&gt;Event&lt;/code&gt;&lt;/a&gt; has happened, it cannot un-happen. If you need to represent a series of events, consider creating a new &lt;a href=&quot;#trio.Event&quot;&gt;&lt;code&gt;Event&lt;/code&gt;&lt;/a&gt; object for each one (they&amp;rsquo;re cheap!), or other synchronization methods like &lt;a href=&quot;#channels&quot;&gt;channels&lt;/a&gt; or &lt;a href=&quot;reference-hazmat#trio.hazmat.ParkingLot&quot;&gt;&lt;code&gt;trio.hazmat.ParkingLot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">달리 &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event&quot;&gt; &lt;code&gt;threading.Event&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#trio.Event&quot;&gt; &lt;code&gt;trio.Event&lt;/code&gt; 는&lt;/a&gt; 전혀 없다 &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt; 방법. 트리오에서는 &lt;a href=&quot;#trio.Event&quot;&gt; &lt;code&gt;Event&lt;/code&gt; &lt;/a&gt; 가 발생하면 일어날 수 없습니다. 일련의 이벤트를 표현해야하는 경우 각각에 대해 새로운 &lt;a href=&quot;#trio.Event&quot;&gt; &lt;code&gt;Event&lt;/code&gt; &lt;/a&gt; 객체를 생성하거나 (싸다) &lt;a href=&quot;#channels&quot;&gt;채널&lt;/a&gt; 또는 &lt;a href=&quot;reference-hazmat#trio.hazmat.ParkingLot&quot;&gt; &lt;code&gt;trio.hazmat.ParkingLot&lt;/code&gt; &lt;/a&gt; 와 같은 다른 동기화 방법을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="781f24017834bea0e61621255956f2c4b4ca2937" translate="yes" xml:space="preserve">
          <source>Unpark all parked tasks.</source>
          <target state="translated">모든 주차 된 작업을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="88158b6332d62d5ea301e652e89647b83fdbf667" translate="yes" xml:space="preserve">
          <source>Unpark one or more tasks.</source>
          <target state="translated">하나 이상의 작업을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="2556360321b2463e70e36fbd809cecceda61b54b" translate="yes" xml:space="preserve">
          <source>Use as a context manager to check that the code inside the &lt;code&gt;with&lt;/code&gt; block does not execute any &lt;a href=&quot;reference-core#checkpoints&quot;&gt;checkpoints&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 블록 내부의 코드 가 &lt;a href=&quot;reference-core#checkpoints&quot;&gt;검사 점을&lt;/a&gt; 실행하지 않는지 확인하려면 컨텍스트 관리자로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b0d3eb180f053e32850213c6f7a3574f4f4119ea" translate="yes" xml:space="preserve">
          <source>Use as a context manager to check that the code inside the &lt;code&gt;with&lt;/code&gt; block either exits with an exception or executes at least one &lt;a href=&quot;reference-core#checkpoints&quot;&gt;checkpoint&lt;/a&gt;.</source>
          <target state="translated">컨텍스트 관리자로 사용하여 &lt;code&gt;with&lt;/code&gt; 블록 내부의 코드 가 예외와 함께 종료되거나 하나 이상의 &lt;a href=&quot;reference-core#checkpoints&quot;&gt;검사 점을&lt;/a&gt; 실행 하는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="166059dea2ea131ea488e69911b917c400be45fd" translate="yes" xml:space="preserve">
          <source>Use as a context manager to create a cancel scope whose deadline is set to now + &lt;em&gt;seconds&lt;/em&gt;.</source>
          <target state="translated">컨텍스트 관리자로 사용하여 최종 기한이 이제 + &lt;em&gt;초로&lt;/em&gt; 설정된 취소 범위를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b93de5e82243cb860a3e551a41a4080f9d46f3f" translate="yes" xml:space="preserve">
          <source>Use as a context manager to create a cancel scope with the given absolute deadline.</source>
          <target state="translated">주어진 절대 기한이있는 취소 범위를 작성하려면 컨텍스트 관리자로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="608e328e68b84e87a64ebe10cd8d5e7d48c917ff" translate="yes" xml:space="preserve">
          <source>User-level API principles</source>
          <target state="translated">사용자 수준 API 원칙</target>
        </trans-unit>
        <trans-unit id="21c61f26a2c50aee6d1c26b200a21f0e6eaa1d40" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt; isn&amp;rsquo;t really &lt;em&gt;that&lt;/em&gt; hazardous; in fact you&amp;rsquo;re already using it &amp;ndash; it&amp;rsquo;s how most of the functionality described in previous chapters is implemented. The APIs described here have strictly defined and carefully documented semantics, and are perfectly safe &amp;ndash; &lt;em&gt;if&lt;/em&gt; you read carefully and take proper precautions. Some of those strict semantics have &lt;a href=&quot;https://en.wikipedia.org/wiki/Rabbit_of_Caerbannog&quot;&gt;nasty big pointy teeth&lt;/a&gt;. If you make a mistake, Trio may not be able to handle it gracefully; conventions and guarantees that are followed strictly in the rest of Trio do not always apply. Using this module makes it your responsibility to think through and handle the nasty cases to expose a friendly Trio-style API to your users.</source>
          <target state="translated">&lt;a href=&quot;#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; 를&lt;/a&gt; 사용 하는 것이 실제로 &lt;em&gt;그렇게&lt;/em&gt; 위험한 것은 아닙니다 . 실제로 이미 사용 중입니다. 이전 장에서 설명한 대부분의 기능이 구현되는 방식입니다. API는 여기에 설명 엄격하게 정의 조심스럽게 의미를 문서화하고, 완벽하게 안전하다 - &lt;em&gt;경우에&lt;/em&gt; 당신은주의 깊게 읽고 적절한 예방 조치를 취할. 이러한 엄격한 의미론 중 일부는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Rabbit_of_Caerbannog&quot;&gt;뾰족한 큰 이빨을 가지고&lt;/a&gt; 있습니다. 실수를하면 Trio가 실수를 제대로 처리하지 못할 수 있습니다. 나머지 Trio에서 엄격하게 준수하는 규칙 및 보증이 항상 적용되는 것은 아닙니다. 이 모듈을 사용하면 사용자에게 친숙한 Trio 스타일 API를 제공하기 위해 불쾌한 사례를 생각하고 처리해야 할 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b513f360a782387f728539080c7a02c20167250" translate="yes" xml:space="preserve">
          <source>Using channels to pass values between tasks</source>
          <target state="translated">채널을 사용하여 작업 간 값 전달</target>
        </trans-unit>
        <trans-unit id="fa493b12215c35c7f93080081bf1f16fbdb17efc" translate="yes" xml:space="preserve">
          <source>Using the same async file object from multiple tasks simultaneously: because the async methods on async file objects are implemented using threads, it&amp;rsquo;s only safe to call two of them at the same time from different tasks IF the underlying synchronous file object is thread-safe. You should consult the documentation for the object you&amp;rsquo;re wrapping. For objects returned from &lt;a href=&quot;#trio.open_file&quot;&gt;&lt;code&gt;trio.open_file()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.Path.open&quot;&gt;&lt;code&gt;trio.Path.open()&lt;/code&gt;&lt;/a&gt;, it depends on whether you open the file in binary mode or text mode: &lt;a href=&quot;https://docs.python.org/3/library/io.html#multi-threading&quot;&gt;binary mode files are task-safe/thread-safe, text mode files are not&lt;/a&gt;.</source>
          <target state="translated">여러 작업에서 동일한 비동기 파일 개체를 동시에 사용 : 비동기 파일 개체의 비동기 메서드는 스레드를 사용하여 구현되므로 기본 동기 파일 개체가 스레드 안전 인 경우 다른 작업에서 동시에 두 개를 호출하는 것이 안전합니다. 줄 바꿈하려는 객체의 설명서를 참조해야합니다. &lt;a href=&quot;#trio.open_file&quot;&gt; &lt;code&gt;trio.open_file()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#trio.Path.open&quot;&gt; &lt;code&gt;trio.Path.open()&lt;/code&gt; &lt;/a&gt; 에서 반환 된 객체의 경우 파일을 이진 모드 또는 텍스트 모드로 열지 여부에 따라 달라집니다. &lt;a href=&quot;https://docs.python.org/3/library/io.html#multi-threading&quot;&gt;이진 모드 파일은 작업 안전 / 스레드 안전, 텍스트 모드 파일은&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="daef22f12350658306822e18b3055d487a63aa72" translate="yes" xml:space="preserve">
          <source>Virtual networking for testing</source>
          <target state="translated">테스트를위한 가상 네트워킹</target>
        </trans-unit>
        <trans-unit id="3fe725b689c13e430fd18699fb2e95efd7595058" translate="yes" xml:space="preserve">
          <source>Virtual, controllable streams</source>
          <target state="translated">가상의 제어 가능한 스트림</target>
        </trans-unit>
        <trans-unit id="d4a7534fed721d1a3033c28ee4152b82de5aae0b" translate="yes" xml:space="preserve">
          <source>Vital statistics:</source>
          <target state="translated">중요한 통계 :</target>
        </trans-unit>
        <trans-unit id="66bdf7f790161b995fe7eefaa4a5ae688592cf68" translate="yes" xml:space="preserve">
          <source>WWDC 2015: Your App and Next Generation Networks: &lt;a href=&quot;http://devstreaming.apple.com/videos/wwdc/2015/719ui2k57m/719/719_your_app_and_next_generation_networks.pdf?dl=1&quot;&gt;slides&lt;/a&gt;, &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015/719/&quot;&gt;video and transcript&lt;/a&gt;</source>
          <target state="translated">WWDC 2015 : 앱 및 차세대 네트워크 : &lt;a href=&quot;http://devstreaming.apple.com/videos/wwdc/2015/719ui2k57m/719/719_your_app_and_next_generation_networks.pdf?dl=1&quot;&gt;슬라이드&lt;/a&gt; , &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015/719/&quot;&gt;비디오 및 대화 내용&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3436440f994f25ba01fc52315e24e50790c1aca2" translate="yes" xml:space="preserve">
          <source>Wait for another thread to call &lt;a href=&quot;#trio.Condition.notify&quot;&gt;&lt;code&gt;notify()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.Condition.notify_all&quot;&gt;&lt;code&gt;notify_all()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다른 스레드가 &lt;a href=&quot;#trio.Condition.notify&quot;&gt; &lt;code&gt;notify()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#trio.Condition.notify_all&quot;&gt; &lt;code&gt;notify_all()&lt;/code&gt; &lt;/a&gt; 을 호출 할 때까지 기다리십시오 .</target>
        </trans-unit>
        <trans-unit id="3c93347a983a68108b3b1f0acbc56ebba40360c7" translate="yes" xml:space="preserve">
          <source>Wait queue abstraction</source>
          <target state="translated">대기 큐 추상화</target>
        </trans-unit>
        <trans-unit id="41913a4464c21572206e30e9131c0a6aee848a95" translate="yes" xml:space="preserve">
          <source>Wait until an incoming connection arrives, and then return it.</source>
          <target state="translated">들어오는 연결이 도착할 때까지 기다렸다가 다시 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="b315f5b334c892b158d988c89293b0f0e4c16c38" translate="yes" xml:space="preserve">
          <source>Wait until there is data available on this stream, and then return some of it.</source>
          <target state="translated">이 스트림에 사용 가능한 데이터가있을 때까지 기다린 후 일부를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="7de17c3c803ae3d81fa6d8c0519a268cfd929e9e" translate="yes" xml:space="preserve">
          <source>Waits 100 ms before calling &lt;code&gt;accept&lt;/code&gt; again, in hopes that the system will recover.</source>
          <target state="translated">시스템이 복구 될 수 있도록 &lt;code&gt;accept&lt;/code&gt; 를 다시 호출하기 전에 100ms를 기다립니다 .</target>
        </trans-unit>
        <trans-unit id="50ff1ba82f15773a71c03597ce8c1546e55713f2" translate="yes" xml:space="preserve">
          <source>Wake all tasks that are currently blocked in &lt;a href=&quot;#trio.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 &lt;a href=&quot;#trio.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 에서 차단 된 모든 작업을 깨 웁니다 .</target>
        </trans-unit>
        <trans-unit id="3af26aecfc19665d78b1a885ea21cb73c7a2f9d7" translate="yes" xml:space="preserve">
          <source>Wake one or more tasks that are blocked in &lt;a href=&quot;#trio.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 에서 차단 된 하나 이상의 작업을 깨 웁니다 .</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="370071229bb1fc7e23236287f51125978b32419c" translate="yes" xml:space="preserve">
          <source>Warning emitted if you use deprecated Trio functionality.</source>
          <target state="translated">더 이상 사용되지 않는 Trio 기능을 사용하면 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="186f850bb584155f8a72f762be272643970d59bc" translate="yes" xml:space="preserve">
          <source>We also added an &lt;code&gt;async with&lt;/code&gt; to the consumer. This isn&amp;rsquo;t as important, but it can help us catch mistakes or other problems. For example, suppose that the consumer exited early for some reason &amp;ndash; maybe because of a bug. Then the producer would be sending messages into the void, and might get stuck indefinitely. But, if the consumer closes its &lt;code&gt;receive_channel&lt;/code&gt;, then the producer will get a &lt;a href=&quot;#trio.BrokenResourceError&quot;&gt;&lt;code&gt;BrokenResourceError&lt;/code&gt;&lt;/a&gt; to alert it that it should stop sending messages because no-one is listening.</source>
          <target state="translated">또한 소비자에게 &lt;code&gt;async with&lt;/code&gt; 추가했습니다 . 이것은 중요하지 않지만 실수 나 다른 문제를 잡는 데 도움이 될 수 있습니다. 예를 들어 어떤 이유로 소비자가 버그로 인해 일찍 종료했다고 가정합니다. 그런 다음 생산자가 빈 공간으로 메시지를 보내고 무한정 중단 될 수 있습니다. 그러나 소비자가 &lt;code&gt;receive_channel&lt;/code&gt; 을 닫으면 생산자는 아무도 수신하지 않기 때문에 메시지 전송을 중지해야한다는 것을 알리기 위해 &lt;a href=&quot;#trio.BrokenResourceError&quot;&gt; &lt;code&gt;BrokenResourceError&lt;/code&gt; &lt;/a&gt; 를 받습니다 .</target>
        </trans-unit>
        <trans-unit id="9a97d4344ecae4164e40e82372a9515a0366cc17" translate="yes" xml:space="preserve">
          <source>We also keep track of an extra bit of state, because it turns out to be useful for &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;trio.SocketStream&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">또한 &lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;trio.SocketStream&lt;/code&gt; 에&lt;/a&gt; 유용하기 때문에 여분의 비트 상태를 추적합니다 .</target>
        </trans-unit>
        <trans-unit id="3a137af56fff2042ca3e86c2acd1f2c56ae90997" translate="yes" xml:space="preserve">
          <source>We also monkey patch &lt;a href=&quot;https://docs.python.org/3/library/traceback.html#traceback.TracebackException&quot;&gt;&lt;code&gt;traceback.TracebackException&lt;/code&gt;&lt;/a&gt; to be able to handle formatting &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt;s. This means that anything that formats exception messages like &lt;a href=&quot;https://docs.python.org/3/library/logging.html#module-logging&quot;&gt;&lt;code&gt;logging&lt;/code&gt;&lt;/a&gt; will work out of the box:</source>
          <target state="translated">또한 &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; 의 서식을 처리 할 수 ​​있도록 원숭이 패치 &lt;a href=&quot;https://docs.python.org/3/library/traceback.html#traceback.TracebackException&quot;&gt; &lt;code&gt;traceback.TracebackException&lt;/code&gt; &lt;/a&gt; 을 처리 합니다. 이것은 &lt;a href=&quot;https://docs.python.org/3/library/logging.html#module-logging&quot;&gt; &lt;code&gt;logging&lt;/code&gt; &lt;/a&gt; 과 같은 예외 메시지를 포맷하는 모든 것이 즉시 작동 한다는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="343247e5868406916a376486d6adae4b0f900926" translate="yes" xml:space="preserve">
          <source>We could avoid this by using some complicated bookkeeping to make sure that only the &lt;em&gt;last&lt;/em&gt; producer and the &lt;em&gt;last&lt;/em&gt; consumer close their channel endpoints&amp;hellip; but that would be tiresome and fragile. Fortunately, there&amp;rsquo;s a better way! Here&amp;rsquo;s a fixed version of our program above:</source>
          <target state="translated">우리는 복잡한 부기를 사용하여 &lt;em&gt;마지막&lt;/em&gt; 생산자와 &lt;em&gt;마지막&lt;/em&gt; 소비자 만 채널 엔드 포인트를 닫을 수 있도록함으로써 이러한 문제를 피할 수있었습니다 . 다행히도 더 좋은 방법이 있습니다! 위 프로그램의 수정 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6301739491da2a3a7d78787414f0b6feacea46b" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t provide timeout arguments. If you want a timeout, then use a cancel scope.</source>
          <target state="translated">타임 아웃 인수는 제공하지 않습니다. 시간 초과를 원하면 취소 범위를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1a408f02fc2bead2788df0bed4524d5ab6823772" translate="yes" xml:space="preserve">
          <source>We refer to &lt;a href=&quot;#trio.move_on_after&quot;&gt;&lt;code&gt;move_on_after()&lt;/code&gt;&lt;/a&gt; as creating a &amp;ldquo;cancel scope&amp;rdquo;, which contains all the code that runs inside the &lt;code&gt;with&lt;/code&gt; block. If the HTTP request takes more than 30 seconds to run, then it will be cancelled: we&amp;rsquo;ll abort the request and we &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; see &lt;code&gt;result is ...&lt;/code&gt; printed on the console; instead we&amp;rsquo;ll go straight to printing the &lt;code&gt;with block
finished&lt;/code&gt; message.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 블록 내에서 실행되는 모든 코드를 포함하는 &quot;취소 범위&quot;를 만드는 것으로 &lt;a href=&quot;#trio.move_on_after&quot;&gt; &lt;code&gt;move_on_after()&lt;/code&gt; &lt;/a&gt; 를 참조합니다 . HTTP 요청을 실행하는 데 30 초 이상 걸리면 요청이 취소됩니다. 요청이 중단되고 &lt;code&gt;result is ...&lt;/code&gt; 콘솔에 인쇄되는 것을 볼 &lt;em&gt;수 없습니다&lt;/em&gt; . 대신 &lt;code&gt;with block finished&lt;/code&gt; 메시지를 바로 인쇄 해 보겠습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3f558f9a59ef0139a2cd804b31ab3c5404a02658" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve talked a lot about what happens when an operation is cancelled, and how you need to be prepared for this whenever calling a cancellable operation&amp;hellip; but we haven&amp;rsquo;t gone into the details about which operations are cancellable, and how exactly they behave when they&amp;rsquo;re cancelled.</source>
          <target state="translated">작업이 취소 될 때 발생하는 상황과 취소 가능한 작업을 호출 할 때마다이를 준비해야하는 방법에 대해 많이 이야기했지만&amp;hellip; 취소되면</target>
        </trans-unit>
        <trans-unit id="bef9db76111ae54eb0dfb86dd904a54acc62f1fd" translate="yes" xml:space="preserve">
          <source>What happens if the user hits control-C while &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; is running? If this argument is False (the default), then you get the standard Python behavior: a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; exception will immediately interrupt whatever task is running (or if no task is running, then Trio will wake up a task to be interrupted). Alternatively, if you set this argument to True, then &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; delivery will be delayed: it will be &lt;em&gt;only&lt;/em&gt; be raised at &lt;a href=&quot;#checkpoints&quot;&gt;checkpoints&lt;/a&gt;, like a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 이 실행되는 동안 사용자가 control-C를 누르면 어떻게됩니까 ? 이 인수가 False (기본값)이면 표준 Python 동작이 발생 합니다. &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 예외는 실행중인 작업을 즉시 중단합니다 (또는 실행중인 작업이 없으면 Trio가 중단 할 작업을 깨 웁니다). True로이 인수를 설정하는 경우 또는, 다음 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 배송이 지연 될 : 그것은됩니다 &lt;em&gt;만&lt;/em&gt; 에 제기 할 &lt;a href=&quot;#checkpoints&quot;&gt;체크 포인트&lt;/a&gt; 는 A, &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외입니다.</target>
        </trans-unit>
        <trans-unit id="4b238710fedc1b59473f2e5d0f608a1b6a710f67" translate="yes" xml:space="preserve">
          <source>Whatever &lt;code&gt;afn(*args)&lt;/code&gt; returns.</source>
          <target state="translated">&lt;code&gt;afn(*args)&lt;/code&gt; 는 무엇이든 반환합니다.</target>
        </trans-unit>
        <trans-unit id="266ea61e53a70acfd1db0b04d0327c318baacbd6" translate="yes" xml:space="preserve">
          <source>Whatever &lt;code&gt;async_fn&lt;/code&gt; returns.</source>
          <target state="translated">무엇이든은 &lt;code&gt;async_fn&lt;/code&gt; 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="0900e19e99ebea86826634809b1ac337300398cd" translate="yes" xml:space="preserve">
          <source>Whatever &lt;code&gt;fn(*args)&lt;/code&gt; returns.</source>
          <target state="translated">&lt;code&gt;fn(*args)&lt;/code&gt; 는 무엇이든 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7106029302bd01916d53d96d96a609813f99f07f" translate="yes" xml:space="preserve">
          <source>Whatever &lt;code&gt;sync_fn(*args)&lt;/code&gt; returns.</source>
          <target state="translated">&lt;code&gt;sync_fn(*args)&lt;/code&gt; 가 무엇이든 반환합니다.</target>
        </trans-unit>
        <trans-unit id="73c196cbd030978c8ebe9f64bd805b220de1b08c" translate="yes" xml:space="preserve">
          <source>Whatever object was received.</source>
          <target state="translated">받은 물건.</target>
        </trans-unit>
        <trans-unit id="c08d6626b380b7a283be3fe01b713e7771435c33" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#trio.serve_listeners&quot;&gt;&lt;code&gt;serve_listeners()&lt;/code&gt;&lt;/a&gt; gets one of these errors, then it:</source>
          <target state="translated">때 &lt;a href=&quot;#trio.serve_listeners&quot;&gt; &lt;code&gt;serve_listeners()&lt;/code&gt; &lt;/a&gt; 그 다음, 이러한 오류 중 하나가 가져옵니다</target>
        </trans-unit>
        <trans-unit id="70c95cc62edeba47e63c58fc9085be2e8b6351ec" translate="yes" xml:space="preserve">
          <source>When Something Happens</source>
          <target state="translated">무언가가 일어날 때</target>
        </trans-unit>
        <trans-unit id="8fa415e76fd97b945f16a66030c2c91b43138a27" translate="yes" xml:space="preserve">
          <source>When a non-blocking method cannot succeed (the channel is empty, the lock is already held, etc.), then it raises &lt;a href=&quot;#trio.WouldBlock&quot;&gt;&lt;code&gt;trio.WouldBlock&lt;/code&gt;&lt;/a&gt;. There&amp;rsquo;s no equivalent to the &lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Empty&quot;&gt;&lt;code&gt;queue.Empty&lt;/code&gt;&lt;/a&gt; versus &lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Full&quot;&gt;&lt;code&gt;queue.Full&lt;/code&gt;&lt;/a&gt; distinction &amp;ndash; we just have the one exception that we use consistently.</source>
          <target state="translated">비 차단 방법이 성공하지 못하면 (채널이 비어 있거나 잠금이 이미 보유 된 경우 등) &lt;a href=&quot;#trio.WouldBlock&quot;&gt; &lt;code&gt;trio.WouldBlock&lt;/code&gt; 이 발생&lt;/a&gt; 합니다. &lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Empty&quot;&gt; &lt;code&gt;queue.Empty&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Full&quot;&gt; &lt;code&gt;queue.Full&lt;/code&gt; &lt;/a&gt; 구별 과 동등한 것은 없습니다 . 일관성있게 사용하는 한 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a25ccee7807a927ac0e6934a2c0dc83b30b44fd" translate="yes" xml:space="preserve">
          <source>When calling this method, you must hold the lock. It releases the lock while waiting, and then re-acquires it before waking up.</source>
          <target state="translated">이 메소드를 호출 할 때 잠금을 유지해야합니다. 대기하는 동안 잠금을 해제 한 다음 깨어나 기 전에 다시 확보합니다.</target>
        </trans-unit>
        <trans-unit id="492b823ff0bfc64272d1aac26d5141c4bbf0412b" translate="yes" xml:space="preserve">
          <source>When the calling coroutine enters this function it&amp;rsquo;s running under Trio, and when the function returns it&amp;rsquo;s running under the foreign coroutine runner.</source>
          <target state="translated">호출 코 루틴이이 함수에 들어가면 Trio에서 실행되고 함수가 반환되면 외부 코 루틴 러너에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="e7ef1b43a451a8a215f39d5c443f75b4d480e706" translate="yes" xml:space="preserve">
          <source>When the calling coroutine enters this function it&amp;rsquo;s running under the foreign coroutine runner, and when the function returns it&amp;rsquo;s running under Trio.</source>
          <target state="translated">호출 코 루틴이이 함수에 들어가면 외부 코 루틴 러너에서 실행되고 함수가 반환되면 Trio에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c43b2fd212506db181cda97f6f6177df1e6cecc9" translate="yes" xml:space="preserve">
          <source>When the child calls &lt;code&gt;task_status.started()&lt;/code&gt;, it&amp;rsquo;s moved from out from underneath &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; and into the given nursery.</source>
          <target state="translated">자식이 &lt;code&gt;task_status.started()&lt;/code&gt; 호출하면 &lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 아래 에서 지정된 보육으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="1e41b82f148b817f9177e9c64a7e7139363b2ad1" translate="yes" xml:space="preserve">
          <source>When things go wrong: timeouts, cancellation and exceptions in concurrent tasks</source>
          <target state="translated">문제가 발생할 경우 : 동시 작업의 시간 초과, 취소 및 예외</target>
        </trans-unit>
        <trans-unit id="4696d67240a9e110f4a4748327c6309139ff62d8" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;nursery.start&lt;/code&gt; you get back the newly opened listeners. See the documentation for &lt;a href=&quot;#trio.serve_tcp&quot;&gt;&lt;code&gt;serve_tcp()&lt;/code&gt;&lt;/a&gt; for an example where this is useful.</source>
          <target state="translated">&lt;code&gt;nursery.start&lt;/code&gt; 와 함께 사용 하면 새로 열린 리스너를 다시 가져옵니다. 이것이 유용한 예제 는 &lt;a href=&quot;#trio.serve_tcp&quot;&gt; &lt;code&gt;serve_tcp()&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b0f0516af766be435ac7ae9669119313d86c471d" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;nursery.start&lt;/code&gt; you get back the newly opened listeners. So, for example, if you want to start a server in your test suite and then connect to it to check that it&amp;rsquo;s working properly, you can use something like:</source>
          <target state="translated">&lt;code&gt;nursery.start&lt;/code&gt; 와 함께 사용 하면 새로 열린 리스너를 다시 가져옵니다. 예를 들어 테스트 스위트에서 서버를 시작한 다음 서버에 연결하여 제대로 작동하는지 확인하려는 경우 다음과 같은 것을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="050a5caa1b8ee04b9f63b749870c3fe582322618" translate="yes" xml:space="preserve">
          <source>When writing Trio code, you need to keep track of where your checkpoints are. Why? First, because checkpoints require extra scrutiny: whenever you execute a checkpoint, you need to be prepared to handle a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; error, or for another task to run and &lt;a href=&quot;https://glyph.twistedmatrix.com/2014/02/unyielding.html&quot;&gt;rearrange some state out from under you&lt;/a&gt;. And second, because you also need to make sure that you have &lt;em&gt;enough&lt;/em&gt; checkpoints: if your code doesn&amp;rsquo;t pass through a checkpoint on a regular basis, then it will be slow to notice and respond to cancellation and &amp;ndash; much worse &amp;ndash; since Trio is a cooperative multi-tasking system where the &lt;em&gt;only&lt;/em&gt; place the scheduler can switch tasks is at checkpoints, it&amp;rsquo;ll also prevent the scheduler from fairly allocating time between different tasks and adversely effect the response latency of all the other code running in the same process. (Informally we say that a task that does this is &amp;ldquo;hogging the run loop&amp;rdquo;.)</source>
          <target state="translated">Trio 코드를 작성할 때 체크 포인트의 위치를 ​​추적해야합니다. 왜? 첫째, 검사 점에는 추가 검사가 필요하기 때문에 검사 ​​점을 실행할 때마다 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 오류 를 처리 하거나 다른 작업이 실행되고 다른 &lt;a href=&quot;https://glyph.twistedmatrix.com/2014/02/unyielding.html&quot;&gt;상태에서 다시 정렬&lt;/a&gt; 되도록 준비해야 합니다 . 둘째, &lt;em&gt;충분한&lt;/em&gt; 체크 포인트 가 있는지 확인해야하기 때문에 코드가 정기적으로 체크 포인트를 통과하지 않으면 트리오가 감지되기 ​​때문에 취소 및 취소에 대한 응답이 느려질 것입니다. &lt;em&gt;유일한&lt;/em&gt; 멀티 태스킹 시스템&lt;em&gt;&lt;/em&gt;스케줄러가 작업을 전환 할 수있는 위치는 검사 점에 있으며 스케줄러가 다른 작업간에 시간을 상당히 할당하지 못하게하고 동일한 프로세스에서 실행중인 다른 모든 코드의 응답 대기 시간에 부정적인 영향을 미칩니다. (공식적으로 우리는이 작업을 수행하는 것이 &quot;루프 실행&quot;이라고 말합니다.)</target>
        </trans-unit>
        <trans-unit id="2bd47718f69d1078c324105f5b4a8877d159988a" translate="yes" xml:space="preserve">
          <source>When writing code using Trio, it&amp;rsquo;s very important to understand the concept of a &lt;em&gt;checkpoint&lt;/em&gt;. Many of Trio&amp;rsquo;s functions act as checkpoints.</source>
          <target state="translated">Trio를 사용하여 코드를 작성할 때 &lt;em&gt;검사 점&lt;/em&gt; 개념을 이해하는 것이 매우 중요 &lt;em&gt;합니다&lt;/em&gt; . 많은 Trio 기능이 체크 포인트 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="563b04d52caf0b7947b54fd91ab7bb4c9b90eec8" translate="yes" xml:space="preserve">
          <source>When you call &lt;a href=&quot;#trio.open_memory_channel&quot;&gt;&lt;code&gt;open_memory_channel()&lt;/code&gt;&lt;/a&gt;, you have to specify how many values can be buffered internally in the channel. If the buffer is full, then any task that calls &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; will stop and wait for another task to call &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive()&lt;/code&gt;&lt;/a&gt;. This is useful because it produces &lt;em&gt;backpressure&lt;/em&gt;: if the channel producers are running faster than the consumers, then it forces the producers to slow down.</source>
          <target state="translated">&lt;a href=&quot;#trio.open_memory_channel&quot;&gt; &lt;code&gt;open_memory_channel()&lt;/code&gt; &lt;/a&gt; 을 호출 할 때 채널에서 내부적으로 버퍼링 할 수있는 값 수를 지정해야합니다. 버퍼가 가득 차면 &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt; 를 호출하는 모든 작업 이 중지되고 다른 작업이 &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive()&lt;/code&gt; &lt;/a&gt; 를 호출하기를 기다립니다 . 이는 &lt;em&gt;배압&lt;/em&gt; 을 생성하기 때문에 유용 합니다. 채널 생산자가 소비자보다 더 빨리 실행되면 생산자가 속도를 늦 춥니 다.</target>
        </trans-unit>
        <trans-unit id="ebd5ba9c06f944e318c34cc1096bc4b580938e60" translate="yes" xml:space="preserve">
          <source>Why is this useful? Because it lets you write generic protocol implementations that can work over arbitrary transports, and easily create complex transport configurations. Here&amp;rsquo;s some examples:</source>
          <target state="translated">이것이 왜 유용한가요? 임의의 전송을 처리 할 수있는 일반 프로토콜 구현을 작성하고 복잡한 전송 구성을 쉽게 작성할 수 있기 때문입니다. 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1fe6956c2b57c6dcd4ba099709ab46045a14b6bf" translate="yes" xml:space="preserve">
          <source>Will properly log the inner exceptions:</source>
          <target state="translated">내부 예외를 올바르게 기록합니다.</target>
        </trans-unit>
        <trans-unit id="6603e7873d2ee40d69b4759aabb89958cd30da76" translate="yes" xml:space="preserve">
          <source>Windows-specific API</source>
          <target state="translated">Windows 관련 API</target>
        </trans-unit>
        <trans-unit id="ec261e1804785b0b785fb8d4215c0f1f49b8e343" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;shell=True&lt;/code&gt; on UNIX, you must specify the command as a single string, which will be passed to the shell as if you&amp;rsquo;d entered it at an interactive prompt. The advantage of this option is that it lets you use shell features like pipes and redirection without writing code to handle them. For example, you can write &lt;code&gt;Process(&quot;ls | grep
some_string&quot;, shell=True)&lt;/code&gt;. The disadvantage is that you must account for the shell&amp;rsquo;s quoting rules, generally by wrapping in &lt;a href=&quot;https://docs.python.org/3/library/shlex.html#shlex.quote&quot;&gt;&lt;code&gt;shlex.quote()&lt;/code&gt;&lt;/a&gt; any argument that might contain spaces, quotes, or other shell metacharacters. If you don&amp;rsquo;t do that, your safe-looking &lt;code&gt;f&quot;ls | grep {some_string}&quot;&lt;/code&gt; might end in disaster when invoked with &lt;code&gt;some_string = &quot;foo; rm -rf /&quot;&lt;/code&gt;.</source>
          <target state="translated">함께 &lt;code&gt;shell=True&lt;/code&gt; UNIX에, 당신은 당신이 대화 형 프롬프트를 입력했던 것처럼 쉘에 전달됩니다 단일 문자열로 명령을 지정해야합니다. 이 옵션의 장점은 파이프 및 리디렉션과 같은 쉘 기능을 코드를 작성하지 않고 사용하여 처리 할 수 ​​있다는 것입니다. 예를 들어 &lt;code&gt;Process(&quot;ls | grep some_string&quot;, shell=True)&lt;/code&gt; 작성할 수 있습니다 . 단점은 일반적으로 공백, 따옴표 또는 기타 쉘 메타 문자를 포함 할 수있는 인수를 &lt;a href=&quot;https://docs.python.org/3/library/shlex.html#shlex.quote&quot;&gt; &lt;code&gt;shlex.quote()&lt;/code&gt; &lt;/a&gt; 로 줄임 으로써 쉘의 인용 규칙을 고려해야 한다는 것입니다. 그렇게하지 않으면 &lt;code&gt;some_string = &quot;foo; rm -rf /&quot;&lt;/code&gt; 호출하면 안전 해 보이는 &lt;code&gt;f&quot;ls | grep {some_string}&quot;&lt;/code&gt; 이 재앙으로 종료 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e73f6e4aaefa27f475bc4dd6d0f2b7b7c14f78e7" translate="yes" xml:space="preserve">
          <source>Working with &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt;s</source>
          <target state="translated">작업 &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; 의</target>
        </trans-unit>
        <trans-unit id="7a749c2ad89d64cc77c70606aa79cc9a9d760911" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; get this error if &lt;em&gt;you&lt;/em&gt; closed the resource &amp;ndash; in that case you get &lt;a href=&quot;#trio.ClosedResourceError&quot;&gt;&lt;code&gt;ClosedResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">당신이 &lt;em&gt;없는&lt;/em&gt; 경우이 오류가 발생 &lt;em&gt;하면&lt;/em&gt; 자원을 폐쇄 -이 경우 당신이 얻을 &lt;a href=&quot;#trio.ClosedResourceError&quot;&gt; &lt;code&gt;ClosedResourceError&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="009b360c3befaa2658cd8a4c7ce2de66315f1f24" translate="yes" xml:space="preserve">
          <source>You almost certainly don&amp;rsquo;t need this.</source>
          <target state="translated">당신은 거의 이것을 필요로하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9b45820263d7fae15a81523c5569073958dee34" translate="yes" xml:space="preserve">
          <source>You can also have multiple producers, and multiple consumers, all sharing the same channel. However, this makes shutdown a little more complicated.</source>
          <target state="translated">여러 생산자와 여러 소비자가 모두 같은 채널을 공유하도록 할 수도 있습니다. 그러나 이렇게하면 종료가 좀 더 복잡해집니다.</target>
        </trans-unit>
        <trans-unit id="fa7c24bdef2aeca73281561745562136ffeaa884" translate="yes" xml:space="preserve">
          <source>You can also return a new or modified exception, for example:</source>
          <target state="translated">다음과 같이 새 예외 또는 수정 된 예외를 반환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="85a44c662cd47a5543d52a16cd0c311eb28f153a" translate="yes" xml:space="preserve">
          <source>You can catch &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;, but you shouldn&amp;rsquo;t! Or more precisely, if you do catch it, then you should do some cleanup and then re-raise it or otherwise let it continue propagating (unless you encounter an error, in which case it&amp;rsquo;s OK to let that propagate instead). To help remind you of this fact, &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; inherits from &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BaseException&quot;&gt;&lt;code&gt;BaseException&lt;/code&gt;&lt;/a&gt;, like &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#SystemExit&quot;&gt;&lt;code&gt;SystemExit&lt;/code&gt;&lt;/a&gt; do, so that it won&amp;rsquo;t be caught by catch-all &lt;code&gt;except
Exception:&lt;/code&gt; blocks.</source>
          <target state="translated">&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 을 잡을 수 있지만해서는 안됩니다! 또는 더 정확하게 말하면, 잡는 경우 정리를 한 다음 다시 올리거나 계속 전파해야합니다 (오류가 발생하지 않는 한, 대신 전파하는 것이 좋습니다). 이 사실을 상기시키기 위해 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#SystemExit&quot;&gt; &lt;code&gt;SystemExit&lt;/code&gt; &lt;/a&gt; 와 같이 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BaseException&quot;&gt; &lt;code&gt;BaseException&lt;/code&gt; &lt;/a&gt; 에서 상속 하므로 &lt;code&gt;except Exception:&lt;/code&gt; 블록을 제외하고 catch-all에 의해 포착되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8b32cfc5b75f959eb500229037977131b40984b7" translate="yes" xml:space="preserve">
          <source>You can change &lt;a href=&quot;#trio.CapacityLimiter.total_tokens&quot;&gt;&lt;code&gt;total_tokens&lt;/code&gt;&lt;/a&gt; by assigning to this attribute. If you make it larger, then the appropriate number of waiting tasks will be woken immediately to take the new tokens. If you decrease total_tokens below the number of tasks that are currently using the resource, then all current tasks will be allowed to finish as normal, but no new tasks will be allowed in until the total number of tasks drops below the new total_tokens.</source>
          <target state="translated">이 속성에 할당하여 &lt;a href=&quot;#trio.CapacityLimiter.total_tokens&quot;&gt; &lt;code&gt;total_tokens&lt;/code&gt; &lt;/a&gt; 를 변경할 수 있습니다 . 더 크게하면 새 토큰을 가져 오기 위해 적절한 수의 대기 작업이 즉시 깨어납니다. total_tokens를 현재 자원을 사용중인 작업 수 아래로 줄이면 현재 작업이 모두 정상적으로 완료 될 수 있지만 총 작업 수가 새 total_tokens 아래로 떨어질 때까지 새 작업이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11cd6250779c6856022b324d11615a036ef7bd8b" translate="yes" xml:space="preserve">
          <source>You can disable buffering entirely, by doing &lt;code&gt;open_memory_channel(0)&lt;/code&gt;. In that case any task calls &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; will wait until another task calls &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive()&lt;/code&gt;&lt;/a&gt;, and vice versa. This is similar to how channels work in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Channel_(programming)&quot;&gt;classic Communicating Sequential Processes model&lt;/a&gt;, and is a reasonable default if you aren&amp;rsquo;t sure what size buffer to use. (That&amp;rsquo;s why we used it in the examples above.)</source>
          <target state="translated">&lt;code&gt;open_memory_channel(0)&lt;/code&gt; 을 수행하여 버퍼링을 완전히 비활성화 할 수 있습니다 . 이 경우 모든 작업 호출 &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt; 는 다른 작업이 &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive()&lt;/code&gt; &lt;/a&gt; 호출 할 때까지 대기 하고 그 반대도 마찬가지입니다. 이는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Channel_(programming)&quot;&gt;전형적인 커뮤니 케이 팅 순차 프로세스 모델&lt;/a&gt; 에서 채널이 작동하는 방식과 유사하며 어떤 크기의 버퍼를 사용해야하는지 확실하지 않은 경우 적절한 기본값입니다. (따라서 위의 예에서 사용했습니다.)</target>
        </trans-unit>
        <trans-unit id="1e18f18f287b713cf7b776bf6e3148ce23b129d9" translate="yes" xml:space="preserve">
          <source>You can freely nest cancellation blocks, and each &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception &amp;ldquo;knows&amp;rdquo; which block it belongs to. So long as you don&amp;rsquo;t stop it, the exception will keep propagating until it reaches the block that raised it, at which point it will stop automatically.</source>
          <target state="translated">취소 블록을 자유롭게 중첩 할 수 있으며, &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 각 예외는 해당 블록이 속한 블록을 &quot;인식&quot;합니다. 중지하지 않는 한 예외는 예외를 발생시킨 블록에 도달 할 때까지 계속 전파되며이 시점에서 자동으로 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="8f5139697bee7e3f58dfd9f1e3d68a51bb393964" translate="yes" xml:space="preserve">
          <source>You can iterate over a &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;ReceiveChannel&lt;/code&gt;&lt;/a&gt; using an &lt;code&gt;async for&lt;/code&gt; loop:</source>
          <target state="translated">&lt;code&gt;async for&lt;/code&gt; 루프를 사용하여 &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;ReceiveChannel&lt;/code&gt; &lt;/a&gt; 을 반복 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25750c191a2273b2bed66aa7b14de5b9a4a29dc8" translate="yes" xml:space="preserve">
          <source>You can register an initial list of instruments by passing them to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#trio.hazmat.add_instrument&quot;&gt;&lt;code&gt;add_instrument()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.hazmat.remove_instrument&quot;&gt;&lt;code&gt;remove_instrument()&lt;/code&gt;&lt;/a&gt; let you add and remove instruments at runtime.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 에 전달하여 초기 계측기 목록을 등록 할 수 있습니다 . &lt;a href=&quot;#trio.hazmat.add_instrument&quot;&gt; &lt;code&gt;add_instrument()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.hazmat.remove_instrument&quot;&gt; &lt;code&gt;remove_instrument()&lt;/code&gt; &lt;/a&gt; 를 사용하면 런타임시 계측기를 추가 및 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4d41938cec088f1203bbaddf9eb58c835315958" translate="yes" xml:space="preserve">
          <source>You can set &lt;a href=&quot;#trio.testing.MockClock.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; to 1.0 if you want it to start running in real time like a regular clock. You can stop and start the clock within a test. You can set &lt;a href=&quot;#trio.testing.MockClock.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; to 10.0 to make clock time pass at 10x real speed (so e.g. &lt;code&gt;await
trio.sleep(10)&lt;/code&gt; returns after 1 second).</source>
          <target state="translated">일반 시계처럼 실시간으로 실행을 시작하려면 &lt;a href=&quot;#trio.testing.MockClock.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt; 를 1.0으로 설정할 수 있습니다 . 테스트 내에서 시계를 중지하고 시작할 수 있습니다. &lt;a href=&quot;#trio.testing.MockClock.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt; 를 10.0으로 설정 하면 클럭 시간이 10 배 실제 속도로 전달됩니다 (예 : 1 초 후 &lt;code&gt;await trio.sleep(10)&lt;/code&gt; 반환 대기 ).</target>
        </trans-unit>
        <trans-unit id="73b14216af1fb4461a4eebe7cd333ac5fc89728c" translate="yes" xml:space="preserve">
          <source>You can think of this as being a no-operating-system-involved Trio-streamsified version of &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.pipe&quot;&gt;&lt;code&gt;os.pipe()&lt;/code&gt;&lt;/a&gt; (except that &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.pipe&quot;&gt;&lt;code&gt;os.pipe()&lt;/code&gt;&lt;/a&gt; returns the streams in the wrong order &amp;ndash; we follow the superior convention that data flows from left to right).</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.pipe&quot;&gt; &lt;code&gt;os.pipe()&lt;/code&gt; &lt;/a&gt; 의 운영 체제와 무관 한 Trio 스트림 버전으로 생각할 수 있습니다 ( &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.pipe&quot;&gt; &lt;code&gt;os.pipe()&lt;/code&gt; &lt;/a&gt; 가 잘못된 순서로 스트림을 반환하는 것을 제외하고 &amp;ndash; 우리는 데이터가 흐르는 우수한 규칙을 따릅니다. 왼쪽에서 오른쪽으로).</target>
        </trans-unit>
        <trans-unit id="2a193c819e0c34ae44aa174ef625aeb404927f6f" translate="yes" xml:space="preserve">
          <source>You cannot raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; yourself. Attempting to do so will produce a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt;&lt;code&gt;cancel_scope.cancel()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">스스로 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 할 수 없습니다 . 그렇게하려고하면 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . 대신 &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt; &lt;code&gt;cancel_scope.cancel()&lt;/code&gt; &lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f1409455bb648f660eba18668fa46e8d4235d51" translate="yes" xml:space="preserve">
          <source>You must have read/write permission on the specified file to connect.</source>
          <target state="translated">연결하려면 지정된 파일에 대한 읽기 / 쓰기 권한이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9591f43d82177778fbdf8368519e3866ba04c088" translate="yes" xml:space="preserve">
          <source>You need to interoperate with a C library whose API exposes raw file descriptors.</source>
          <target state="translated">API가 원시 파일 디스크립터를 노출하는 C 라이브러리와 상호 운용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3328a7e6a66ef1d404c0daf69759fecee4ace50c" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t want to use this module.</source>
          <target state="translated">이 모듈을 사용하고 싶지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="23c5814eb2e6178242ccbfbb5e6e94456da5ce51" translate="yes" xml:space="preserve">
          <source>You should also consider &lt;a href=&quot;#trio.testing.Sequencer&quot;&gt;&lt;code&gt;trio.testing.Sequencer&lt;/code&gt;&lt;/a&gt;, which provides a more explicit way to control execution ordering within a test, and will often produce more readable tests.</source>
          <target state="translated">또한 &lt;a href=&quot;#trio.testing.Sequencer&quot;&gt; &lt;code&gt;trio.testing.Sequencer&lt;/code&gt; &lt;/a&gt; 를 고려해야 합니다.이 테스트는 테스트 내에서 실행 순서를보다 명확하게 제어 할 수있는 방법을 제공하며 더 읽기 쉬운 테스트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a1e951ca24f73a0b917f6fa4fccd3b6e7ff5ec1d" translate="yes" xml:space="preserve">
          <source>You should let this exception propagate, to be caught by the relevant cancel scope. To remind you of this, it inherits from &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BaseException&quot;&gt;&lt;code&gt;BaseException&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#Exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;, just like &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#SystemExit&quot;&gt;&lt;code&gt;SystemExit&lt;/code&gt;&lt;/a&gt; do. This means that if you write something like:</source>
          <target state="translated">관련 취소 범위에 의해 포착되도록이 예외를 전파해야합니다. 이를 기억하기 위해 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#SystemExit&quot;&gt; &lt;code&gt;SystemExit&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#Exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BaseException&quot;&gt; &lt;code&gt;BaseException&lt;/code&gt; &lt;/a&gt; 에서 상속 합니다. 이것은 당신이 다음과 같은 것을 쓰는 경우를 의미합니다 :</target>
        </trans-unit>
        <trans-unit id="fedfa7c04a142224d4bfaffbb7d5f92b503396fc" translate="yes" xml:space="preserve">
          <source>You should make sure that the coroutine object has released any Trio-specific resources it has acquired (e.g. nurseries).</source>
          <target state="translated">코 루틴 오브젝트가 획득 한 트리오 관련 리소스 (예 : 보육원)를 해제했는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="9de2954124a05d7144aba1d682767a02cd6925d2" translate="yes" xml:space="preserve">
          <source>You should not assume that Trio&amp;rsquo;s internal clock matches any other clock you have access to, including the clocks of simultaneous calls to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; happening in other processes or threads!</source>
          <target state="translated">다른 프로세스 나 스레드에서 발생 하는 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 대한 동시 호출 시계를 포함하여 Trio의 내부 시계가 액세스 할 수있는 다른 시계와 일치한다고 가정해서는 안됩니다 !</target>
        </trans-unit>
        <trans-unit id="646e110f9302c40fddd2b0685842e617a4c59be2" translate="yes" xml:space="preserve">
          <source>You should not use this function to call long-running CPU-bound functions! In addition to the usual GIL-related reasons why using threads for CPU-bound work is not very effective in Python, there is an additional problem: on CPython, &lt;a href=&quot;https://bugs.python.org/issue7946&quot;&gt;CPU-bound threads tend to &amp;ldquo;starve out&amp;rdquo; IO-bound threads&lt;/a&gt;, so using threads for CPU-bound work is likely to adversely affect the main thread running Trio. If you need to do this, you&amp;rsquo;re better off using a worker process, or perhaps PyPy (which still has a GIL, but may do a better job of fairly allocating CPU time between threads).</source>
          <target state="translated">장기 실행 CPU 바운드 함수를 호출하기 위해이 함수를 사용해서는 안됩니다! CPU 바인딩 작업 스레드를 사용하는 이유 일반 GIL 관련 이유 외에도 파이썬에서 매우 효과가 없습니다, 추가 문제가 : CPython과에, &lt;a href=&quot;https://bugs.python.org/issue7946&quot;&gt;CPU 바인딩 스레드 경향 IO-바운드 스레드 &quot;을 굶어&quot;&lt;/a&gt; 그래서 사용 CPU 바운드 작업을위한 스레드는 Trio를 실행하는 기본 스레드에 부정적인 영향을 줄 수 있습니다. 이 작업을 수행 해야하는 경우 작업자 프로세스 또는 PyPy (GIL이 있지만 스레드간에 CPU 시간을 상당히 할당하는 것이 좋습니다)를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="44026b9c6a4042d112ee739a002a97d694712133" translate="yes" xml:space="preserve">
          <source>You should read the standard library&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#module-ssl&quot;&gt;&lt;code&gt;ssl&lt;/code&gt;&lt;/a&gt; documentation carefully before attempting to use this class, and probably other general documentation on SSL/TLS as well. SSL/TLS is subtle and quick to anger. Really. I&amp;rsquo;m not kidding.</source>
          <target state="translated">이 클래스를 사용하기 전에 표준 라이브러리의 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#module-ssl&quot;&gt; &lt;code&gt;ssl&lt;/code&gt; &lt;/a&gt; 문서 및 SSL / TLS에 대한 다른 일반 문서를주의 깊게 읽으십시오 . SSL / TLS는 미묘하고 분노하기 쉽습니다. 정말. 농담이 아냐.</target>
        </trans-unit>
        <trans-unit id="af994b289b9e27ca5767229787d9d523285f5cca" translate="yes" xml:space="preserve">
          <source>You should set this to the smallest value that lets you reliably avoid &amp;ldquo;false alarms&amp;rdquo; where some I/O is in flight (e.g. between two halves of a socketpair) but the threshold gets triggered and time gets advanced anyway. This will depend on the details of your tests and test environment. If you aren&amp;rsquo;t doing any I/O (like in our sleeping example above) then just set it to zero, and the clock will jump whenever all tasks are blocked.</source>
          <target state="translated">일부 I / O가 비행 중일 때 (예 : 소켓 쌍의 두 반쪽 사이) &quot;임계 경보&quot;를 안정적으로 피할 수 있도록 가장 작은 값으로 설정해야하지만 임계 값이 트리거되고 어쨌든 시간이 앞당겨집니다. 테스트 및 테스트 환경의 세부 사항에 따라 다릅니다. I / O를 수행하지 않는 경우 (위의 수면 예제와 같이) 그냥 0으로 설정하면 모든 작업이 차단 될 때마다 시계가 튀어 나옵니다.</target>
        </trans-unit>
        <trans-unit id="04dc405c41c272f00e8f03c5e75c32fa3c6f6a3d" translate="yes" xml:space="preserve">
          <source>You want to add support for a low-level operating system interface that Trio doesn&amp;rsquo;t (yet) expose, like watching a filesystem directory for changes.</source>
          <target state="translated">파일 시스템 디렉토리의 변경 사항을 보는 것과 같이 Trio가 노출하지 않은 저수준 운영 체제 인터페이스에 대한 지원을 추가하려고합니다.</target>
        </trans-unit>
        <trans-unit id="0428a04bb2f7e7b639617203dfc3e59ff2d8203f" translate="yes" xml:space="preserve">
          <source>You want to extract low-level metrics to monitor the health of your application.</source>
          <target state="translated">저수준 메트릭을 추출하여 응용 프로그램의 상태를 모니터링하려고합니다.</target>
        </trans-unit>
        <trans-unit id="05015afc873ec753584995707240d627d836bd52" translate="yes" xml:space="preserve">
          <source>You want to implement a new &lt;a href=&quot;reference-core#synchronization&quot;&gt;synchronization primitive&lt;/a&gt; that Trio doesn&amp;rsquo;t (yet) provide, like a reader-writer lock.</source>
          <target state="translated">리더 라이터 잠금과 같이 Trio가 아직 제공하지 않은 새로운 &lt;a href=&quot;reference-core#synchronization&quot;&gt;동기화 프리미티브&lt;/a&gt; 를 구현하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="07a1ae0ae940498aef5bd14407e02b773ced1132" translate="yes" xml:space="preserve">
          <source>You want to implement an interface for calling between Trio and another event loop within the same process.</source>
          <target state="translated">동일한 프로세스 내에서 Trio와 다른 이벤트 루프간에 호출하기위한 인터페이스를 구현하려고합니다.</target>
        </trans-unit>
        <trans-unit id="1649b9e8a04484aaf903493316e5d3972b6838bd" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re writing a debugger and want to visualize Trio&amp;rsquo;s task tree.</source>
          <target state="translated">디버거를 작성 중이며 Trio의 작업 트리를 시각화하려고합니다.</target>
        </trans-unit>
        <trans-unit id="d49ab22902a8727e54d03ba7e745316cec5707a4" translate="yes" xml:space="preserve">
          <source>Your socket object must inherit from &lt;a href=&quot;reference-io#trio.socket.SocketType&quot;&gt;&lt;code&gt;trio.socket.SocketType&lt;/code&gt;&lt;/a&gt;, which is an empty class whose only purpose is to &amp;ldquo;mark&amp;rdquo; which classes should be considered valid Trio sockets.</source>
          <target state="translated">소켓 객체는 &lt;a href=&quot;reference-io#trio.socket.SocketType&quot;&gt; &lt;code&gt;trio.socket.SocketType&lt;/code&gt; 을&lt;/a&gt; 상속 받아야합니다. 이 클래스는 어떤 클래스를 유효한 Trio 소켓으로 &quot;마킹&quot;하는 것이 유일한 빈 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="f1898341d2daec152994b3c0f65aeb8b9483cc1c" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; connected to the given file.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 주어진 파일에 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6da0b7c2a1148f6e2dd5916c9d16b09301bfe3e2" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; connected to the given server.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 주어진 서버에 연결.</target>
        </trans-unit>
        <trans-unit id="6195af02e6b73eb964ad6c05d1805ab0e1d06b46" translate="yes" xml:space="preserve">
          <source>a stream connected to the given listener.</source>
          <target state="translated">지정된 청취자에 접속 된 스트림</target>
        </trans-unit>
        <trans-unit id="5039d155a71c0a5f7a2b2654ad49cb7ee47a8980" translate="yes" xml:space="preserve">
          <source>bool</source>
          <target state="translated">bool</target>
        </trans-unit>
        <trans-unit id="77cad0de53efabb9d859c964b7508191d55edb0e" translate="yes" xml:space="preserve">
          <source>but of course it may be different if you&amp;rsquo;re implementing some kind of virtual clock.</source>
          <target state="translated">물론 어떤 종류의 가상 시계를 구현하는 경우에는 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a0b61e397ac4fbba6dd82cf6b66dfb129039bb7" translate="yes" xml:space="preserve">
          <source>except that &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; can (and must) be called from a synchronous context.</source>
          <target state="translated">것을 제외하고 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 수 (해야) 동기 컨텍스트에서 호출 할 수.</target>
        </trans-unit>
        <trans-unit id="3154e5a3874003ada68892061573dc875458ace5" translate="yes" xml:space="preserve">
          <source>except that if &lt;code&gt;sync_fn&lt;/code&gt; takes a long time, then the first line will block the Trio loop while it runs, while the second line allows other Trio tasks to continue working while &lt;code&gt;sync_fn&lt;/code&gt; runs. This is accomplished by pushing the call to &lt;code&gt;sync_fn(*args)&lt;/code&gt; off into a worker thread.</source>
          <target state="translated">경우에 것을 제외하고 &lt;code&gt;sync_fn&lt;/code&gt; 은 시간이 오래 걸립니다가 실행되는 동안 두 번째 줄은 기타 트리오 작업 동안 작업을 계속 할 수 있지만, 그 첫 번째 줄, 트리오 루프를 차단합니다 &lt;code&gt;sync_fn&lt;/code&gt; 의 실행됩니다. 이것은 &lt;code&gt;sync_fn(*args)&lt;/code&gt; 호출을 작업자 스레드로 푸시하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="685e80366130387cb75c055248326976d16fdf8d" translate="yes" xml:space="preserve">
          <source>float</source>
          <target state="translated">float</target>
        </trans-unit>
        <trans-unit id="b04aaee65bcdd5af32e5866d6ca849f2f6481299" translate="yes" xml:space="preserve">
          <source>forcibly close the socket to prevent accidental re-use</source>
          <target state="translated">실수로 재사용하지 않도록 소켓을 강제로 닫습니다.</target>
        </trans-unit>
        <trans-unit id="46f8ab7c0cff9df7cd124852e26022a6bf89e315" translate="yes" xml:space="preserve">
          <source>int</source>
          <target state="translated">int</target>
        </trans-unit>
        <trans-unit id="dc7c7a036e7ff86d7041348d3f5c595cf32f848b" translate="yes" xml:space="preserve">
          <source>is the equivalent of:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cdf2a9b9770cca84cff07c07ed209cea58b77040" translate="yes" xml:space="preserve">
          <source>list of &lt;a href=&quot;#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; &lt;/a&gt; 목록</target>
        </trans-unit>
        <trans-unit id="1615307cc4523f183e777df67f168c86908e8007" translate="yes" xml:space="preserve">
          <source>object</source>
          <target state="translated">object</target>
        </trans-unit>
        <trans-unit id="91c7815e33a9c610fffab6b85965803b4c38fe10" translate="yes" xml:space="preserve">
          <source>open_ssl_over_tcp_stream</source>
          <target state="translated">open_ssl_over_tcp_stream</target>
        </trans-unit>
        <trans-unit id="9a2cd608fc634f6422fae3a1601e32e93899153a" translate="yes" xml:space="preserve">
          <source>raise &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인상이 &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9fd50a36be80600cf205943240836997b4dae781" translate="yes" xml:space="preserve">
          <source>that never calls any of Trio&amp;rsquo;s async functions. This is an async function, but it&amp;rsquo;s not a checkpoint. But why make a function async if it never calls any async functions? It&amp;rsquo;s possible, but it&amp;rsquo;s a bad idea. If you have a function that&amp;rsquo;s not calling any async functions, then you should make it synchronous. The people who use your function will thank you, because it makes it obvious that your function is not a checkpoint, and their code reviews will go faster.</source>
          <target state="translated">Trio의 비동기 함수를 호출하지 않습니다. 이것은 비동기 함수이지만 체크 포인트가 아닙니다. 그러나 비동기 함수를 호출하지 않으면 왜 함수를 비 동기화합니까? 가능하지만 나쁜 생각입니다. 비동기 함수를 호출하지 않는 함수가 있으면 동기식으로 만들어야합니다. 귀하의 기능을 사용하는 사람들은 귀하의 기능이 체크 포인트가 아니며 코드 검토가 더 빨라질 것이기 때문에 감사합니다.</target>
        </trans-unit>
        <trans-unit id="c99061349fef0290fe3ca6468379aa7cff199037" translate="yes" xml:space="preserve">
          <source>the &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; that called &lt;a href=&quot;#trio.hazmat.current_task&quot;&gt;&lt;code&gt;current_task()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 이라고 &lt;a href=&quot;#trio.hazmat.current_task&quot;&gt; &lt;code&gt;current_task()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a9e69b5d794e659edb00d20d3ad49a11b127477" translate="yes" xml:space="preserve">
          <source>the effective deadline, as an absolute time.</source>
          <target state="translated">효과적인 마감일, 절대 시간.</target>
        </trans-unit>
        <trans-unit id="7c3a6f266d6247d7cd771e1c325b352794e92c00" translate="yes" xml:space="preserve">
          <source>the encrypted connection to the server.</source>
          <target state="translated">서버에 대한 암호화 된 연결</target>
        </trans-unit>
        <trans-unit id="ae5091f01cda515d1f122297428e0d9d9abb842a" translate="yes" xml:space="preserve">
          <source>the newly spawned task</source>
          <target state="translated">새로 생성 된 작업</target>
        </trans-unit>
        <trans-unit id="8d6554dc96924eb4d77e3e00e5aea6f1bb8ca0a8" translate="yes" xml:space="preserve">
          <source>the program will see one argument &lt;code&gt;foo &quot;bar&quot; baz&lt;/code&gt; but CMD.EXE thinks &lt;code&gt;bar\&lt;/code&gt; is not quoted while &lt;code&gt;foo \&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; are. All of this makes it a formidable task to reliably interpolate anything into a &lt;code&gt;shell=True&lt;/code&gt; command line on Windows, and Trio falls back on the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; behavior: If you pass a sequence with &lt;code&gt;shell=True&lt;/code&gt;, it&amp;rsquo;s quoted in the same way as a sequence with &lt;code&gt;shell=False&lt;/code&gt;, and had better not contain any shell metacharacters you weren&amp;rsquo;t planning on.</source>
          <target state="translated">프로그램은 하나의 인수 &lt;code&gt;foo &quot;bar&quot; baz&lt;/code&gt; 를 보게 되지만 CMD.EXE 는 &lt;code&gt;foo \&lt;/code&gt; 와 &lt;code&gt;baz&lt;/code&gt; 가있는 동안 &lt;code&gt;bar\&lt;/code&gt; 는 인용되지 않는다고 생각 합니다 . 이 모든 것이 Windows의 모든 것을 &lt;code&gt;shell=True&lt;/code&gt; 명령 줄에 안정적으로 보간하는 강력한 작업이 되고 Trio는 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 동작으로 돌아갑니다. &lt;code&gt;shell=True&lt;/code&gt; 로 시퀀스를 전달하면 시퀀스와 동일한 방식으로 인용됩니다 와 &lt;code&gt;shell=False&lt;/code&gt; , 그리고 더 나은 당신이 계획되지 않은 모든 쉘 메타 문자를 포함하지 않았다.</target>
        </trans-unit>
        <trans-unit id="6fa9fa819747544976a8089d6e7dc99a2e72147c" translate="yes" xml:space="preserve">
          <source>then this &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; catch a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">다음이 &lt;em&gt;되지 않습니다&lt;/em&gt; 잡을 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외.</target>
        </trans-unit>
        <trans-unit id="7edd5a38751799f207ce0fb360ac04e15a80c88f" translate="yes" xml:space="preserve">
          <source>tl;dr: if &lt;a href=&quot;#trio.socket.SocketType.connect&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; is cancelled then the socket is left in an unknown state &amp;ndash; possibly open, and possibly closed. The only reasonable thing to do is to close it.</source>
          <target state="translated">tl; dr : &lt;a href=&quot;#trio.socket.SocketType.connect&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt; 가 취소되면 소켓은 알 수없는 상태로 남아 있습니다. 해야 할 유일한 일은 그것을 닫는 것입니다.</target>
        </trans-unit>
        <trans-unit id="87741b233c2cc78262f503491f3a8495f49cdd4b" translate="yes" xml:space="preserve">
          <source>trio.BrokenResourceError</source>
          <target state="translated">trio.BrokenResourceError</target>
        </trans-unit>
        <trans-unit id="4faabd920eda171b110adb99bf1d08894a816fee" translate="yes" xml:space="preserve">
          <source>trio.BusyResourceError</source>
          <target state="translated">trio.BusyResourceError</target>
        </trans-unit>
        <trans-unit id="9b974b873fbbaf04d4cca8052a7b3d2ca60b0e98" translate="yes" xml:space="preserve">
          <source>trio.CancelScope</source>
          <target state="translated">trio.CancelScope</target>
        </trans-unit>
        <trans-unit id="4920baa45b1585116ebf73761dd11b80179ad186" translate="yes" xml:space="preserve">
          <source>trio.CancelScope.cancel</source>
          <target state="translated">trio.CancelScope.cancel</target>
        </trans-unit>
        <trans-unit id="5c083abcb3bde71d99dde3a8c0c771447e63e638" translate="yes" xml:space="preserve">
          <source>trio.CancelScope.cancel_called</source>
          <target state="translated">trio.CancelScope.cancel_called</target>
        </trans-unit>
        <trans-unit id="b65fceeea97c4d057193f169545f18bfb650937e" translate="yes" xml:space="preserve">
          <source>trio.CancelScope.cancelled_caught</source>
          <target state="translated">trio.CancelScope.cancelled_caught</target>
        </trans-unit>
        <trans-unit id="92f92711eaa71a8239922abbd8a7439a50382a9a" translate="yes" xml:space="preserve">
          <source>trio.CancelScope.deadline</source>
          <target state="translated">trio.CancelScope.deadline</target>
        </trans-unit>
        <trans-unit id="aab9bfe917a12fd4d10b5c54ca88ed322b1a43df" translate="yes" xml:space="preserve">
          <source>trio.CancelScope.shield</source>
          <target state="translated">trio.CancelScope.shield</target>
        </trans-unit>
        <trans-unit id="1495dbc0e63e50fb15f424182d80356b99071c0e" translate="yes" xml:space="preserve">
          <source>trio.Cancelled</source>
          <target state="translated">trio.Cancelled</target>
        </trans-unit>
        <trans-unit id="38532a852db8ff465708e6832163917bbddb3987" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter</source>
          <target state="translated">trio.CapacityLimiter</target>
        </trans-unit>
        <trans-unit id="3b4e8e33e050891acdd45f38c55999072d94cb70" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.acquire</source>
          <target state="translated">trio.CapacityLimiter.acquire</target>
        </trans-unit>
        <trans-unit id="3052973e311095a945e302da012f4dd07bceb959" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.acquire_nowait</source>
          <target state="translated">trio.CapacityLimiter.acquire_nowait</target>
        </trans-unit>
        <trans-unit id="b13e58a166c12cacb75150244ed449938669b4a0" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.acquire_on_behalf_of</source>
          <target state="translated">trio.CapacityLimiter.acquire_on_behalf_of</target>
        </trans-unit>
        <trans-unit id="47131bee275ceed0ed6aac36620dfd39cdd4a597" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.acquire_on_behalf_of_nowait</source>
          <target state="translated">trio.CapacityLimiter.acquire_on_behalf_of_nowait</target>
        </trans-unit>
        <trans-unit id="46afc3cef3913298a0c33c7aa35a3bdcd7e72711" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.available_tokens</source>
          <target state="translated">trio.CapacityLimiter.available_tokens</target>
        </trans-unit>
        <trans-unit id="cf684025fd002abbf00d23c9233be969bf8e9f15" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.borrowed_tokens</source>
          <target state="translated">trio.CapacityLimiter.borrowed_tokens</target>
        </trans-unit>
        <trans-unit id="045d1df55f5452fcf6b0b4325c23468efc51d6c4" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.release</source>
          <target state="translated">trio.CapacityLimiter.release</target>
        </trans-unit>
        <trans-unit id="6577f1baeabe124f327be707f159bde14c072a24" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.release_on_behalf_of</source>
          <target state="translated">trio.CapacityLimiter.release_on_behalf_of</target>
        </trans-unit>
        <trans-unit id="c218dc105968173936e5a081bd308b738fad34a6" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.statistics</source>
          <target state="translated">trio.CapacityLimiter.statistics</target>
        </trans-unit>
        <trans-unit id="32428c009582b72108e9b490d9ca48bbe9401c5e" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.total_tokens</source>
          <target state="translated">trio.CapacityLimiter.total_tokens</target>
        </trans-unit>
        <trans-unit id="1b4a65eaae06c22bddd85d22bb1dece1cc6b08fd" translate="yes" xml:space="preserve">
          <source>trio.ClosedResourceError</source>
          <target state="translated">trio.ClosedResourceError</target>
        </trans-unit>
        <trans-unit id="03735eebe4de0fabd8f2c51569ca8eb6150edddf" translate="yes" xml:space="preserve">
          <source>trio.Condition</source>
          <target state="translated">trio.Condition</target>
        </trans-unit>
        <trans-unit id="64e0dacab0e79dfcf0bb3947eea1007bfbac924e" translate="yes" xml:space="preserve">
          <source>trio.Condition.acquire</source>
          <target state="translated">trio.Condition.acquire</target>
        </trans-unit>
        <trans-unit id="945d9cb0754c2dc3750f9d27bdc4dda459a3f6af" translate="yes" xml:space="preserve">
          <source>trio.Condition.acquire_nowait</source>
          <target state="translated">trio.Condition.acquire_nowait</target>
        </trans-unit>
        <trans-unit id="0315af336b1b481ab49b04b5f4582676818b0d83" translate="yes" xml:space="preserve">
          <source>trio.Condition.locked</source>
          <target state="translated">trio.Condition.locked</target>
        </trans-unit>
        <trans-unit id="1e7e83352ee370c2f4ea217a547acfdb1397f607" translate="yes" xml:space="preserve">
          <source>trio.Condition.notify</source>
          <target state="translated">trio.Condition.notify</target>
        </trans-unit>
        <trans-unit id="d848616c8fa2d1ec484c6581fcd878b027371e99" translate="yes" xml:space="preserve">
          <source>trio.Condition.notify_all</source>
          <target state="translated">trio.Condition.notify_all</target>
        </trans-unit>
        <trans-unit id="bcb4444ce5c2d6c94ebad0e952dacfe072eeca3f" translate="yes" xml:space="preserve">
          <source>trio.Condition.release</source>
          <target state="translated">trio.Condition.release</target>
        </trans-unit>
        <trans-unit id="1d036063c7c52b8c5bb70e76b16c752433f7be3e" translate="yes" xml:space="preserve">
          <source>trio.Condition.statistics</source>
          <target state="translated">trio.Condition.statistics</target>
        </trans-unit>
        <trans-unit id="2cab378407bebe21e3de6a5ec95b5425861725f2" translate="yes" xml:space="preserve">
          <source>trio.Condition.wait</source>
          <target state="translated">trio.Condition.wait</target>
        </trans-unit>
        <trans-unit id="01db248fe1d1e0822a01f6e8a8952aad1d62f2e5" translate="yes" xml:space="preserve">
          <source>trio.EndOfChannel</source>
          <target state="translated">trio.EndOfChannel</target>
        </trans-unit>
        <trans-unit id="0d63b4a5179b72b0ba26f9ac3be63b45d96e28a8" translate="yes" xml:space="preserve">
          <source>trio.Event</source>
          <target state="translated">trio.Event</target>
        </trans-unit>
        <trans-unit id="7749517203c365b1910f5484033b59c65640c5d6" translate="yes" xml:space="preserve">
          <source>trio.Event.is_set</source>
          <target state="translated">trio.Event.is_set</target>
        </trans-unit>
        <trans-unit id="e08b82b0c067915092294ab18a099e79642241c8" translate="yes" xml:space="preserve">
          <source>trio.Event.set</source>
          <target state="translated">trio.Event.set</target>
        </trans-unit>
        <trans-unit id="1ba4656fe573e30ec9e885d076bc40c88ab0fe5f" translate="yes" xml:space="preserve">
          <source>trio.Event.statistics</source>
          <target state="translated">trio.Event.statistics</target>
        </trans-unit>
        <trans-unit id="a7457b9c6a0c02333d051793fdf80df853391ca1" translate="yes" xml:space="preserve">
          <source>trio.Event.wait</source>
          <target state="translated">trio.Event.wait</target>
        </trans-unit>
        <trans-unit id="1cf59d5da988771020b3e0e7429ee4b79fa9f979" translate="yes" xml:space="preserve">
          <source>trio.Lock</source>
          <target state="translated">trio.Lock</target>
        </trans-unit>
        <trans-unit id="d633b948aa9f844cdf1b98ab6925e0bec1b2e453" translate="yes" xml:space="preserve">
          <source>trio.Lock.acquire</source>
          <target state="translated">trio.Lock.acquire</target>
        </trans-unit>
        <trans-unit id="7b361a3b5884f18821c59cd390b717c141f3a43f" translate="yes" xml:space="preserve">
          <source>trio.Lock.acquire_nowait</source>
          <target state="translated">trio.Lock.acquire_nowait</target>
        </trans-unit>
        <trans-unit id="f86da8dcc1fa815ba85e422458658e5f22adfaad" translate="yes" xml:space="preserve">
          <source>trio.Lock.locked</source>
          <target state="translated">trio.Lock.locked</target>
        </trans-unit>
        <trans-unit id="d6045a56b39447852827d60307fa7d35de7cec95" translate="yes" xml:space="preserve">
          <source>trio.Lock.release</source>
          <target state="translated">trio.Lock.release</target>
        </trans-unit>
        <trans-unit id="0b7d9e43e0be75f994ef953bcb3f4ffcec01f328" translate="yes" xml:space="preserve">
          <source>trio.Lock.statistics</source>
          <target state="translated">trio.Lock.statistics</target>
        </trans-unit>
        <trans-unit id="78e5f12a4f57d39a487d8ac0772abf229b3c4393" translate="yes" xml:space="preserve">
          <source>trio.MemoryReceiveChannel</source>
          <target state="translated">trio.MemoryReceiveChannel</target>
        </trans-unit>
        <trans-unit id="108d6e10855287c416ef308d84c8a07a06082ede" translate="yes" xml:space="preserve">
          <source>trio.MemoryReceiveChannel.clone</source>
          <target state="translated">trio.MemoryReceiveChannel.clone</target>
        </trans-unit>
        <trans-unit id="be9c3678e2d106615286508fddb65c7df45ce556" translate="yes" xml:space="preserve">
          <source>trio.MemoryReceiveChannel.receive</source>
          <target state="translated">trio.MemoryReceiveChannel.receive</target>
        </trans-unit>
        <trans-unit id="fce5a2406bed66b19c15633653eef1152daf5be5" translate="yes" xml:space="preserve">
          <source>trio.MemoryReceiveChannel.receive_nowait</source>
          <target state="translated">trio.MemoryReceiveChannel.receive_nowait</target>
        </trans-unit>
        <trans-unit id="2eb4b49e21017b91f2f304d22436616defad8fee" translate="yes" xml:space="preserve">
          <source>trio.MemorySendChannel</source>
          <target state="translated">trio.MemorySendChannel</target>
        </trans-unit>
        <trans-unit id="bfb678e05e31677cf1559641988c5b00c0904637" translate="yes" xml:space="preserve">
          <source>trio.MemorySendChannel.clone</source>
          <target state="translated">trio.MemorySendChannel.clone</target>
        </trans-unit>
        <trans-unit id="9d1deb18f57cd2514b5a2304be1926da71a96674" translate="yes" xml:space="preserve">
          <source>trio.MemorySendChannel.send</source>
          <target state="translated">trio.MemorySendChannel.send</target>
        </trans-unit>
        <trans-unit id="c2089f8aa644b3d080241ec8e934d7f188a59616" translate="yes" xml:space="preserve">
          <source>trio.MemorySendChannel.send_nowait</source>
          <target state="translated">trio.MemorySendChannel.send_nowait</target>
        </trans-unit>
        <trans-unit id="10efaedb6cf45fb2b8f43b87d918366df5336129" translate="yes" xml:space="preserve">
          <source>trio.MultiError</source>
          <target state="translated">trio.MultiError</target>
        </trans-unit>
        <trans-unit id="12d2a4e4998ebb25a094937b5055e57d835ebee4" translate="yes" xml:space="preserve">
          <source>trio.MultiError.catch</source>
          <target state="translated">trio.MultiError.catch</target>
        </trans-unit>
        <trans-unit id="26d8d3d3632d98e535d0f9572356901f2e8b3042" translate="yes" xml:space="preserve">
          <source>trio.MultiError.exceptions</source>
          <target state="translated">trio.MultiError.exceptions</target>
        </trans-unit>
        <trans-unit id="77441b639d5f7ad74295e114f74156b855cb3c8f" translate="yes" xml:space="preserve">
          <source>trio.MultiError.filter</source>
          <target state="translated">trio.MultiError.filter</target>
        </trans-unit>
        <trans-unit id="cf189386a700c42d73eee8c3145915ac2c7bc850" translate="yes" xml:space="preserve">
          <source>trio.NeedHandshakeError</source>
          <target state="translated">trio.NeedHandshakeError</target>
        </trans-unit>
        <trans-unit id="8b6fb9ab36e2a18a0e93b43db1cb843c1cd1f2d7" translate="yes" xml:space="preserve">
          <source>trio.Nursery</source>
          <target state="translated">trio.Nursery</target>
        </trans-unit>
        <trans-unit id="f2ccf4921c3ccceaa76ab2b6dfa6d5a4ff78280d" translate="yes" xml:space="preserve">
          <source>trio.Nursery.cancel_scope</source>
          <target state="translated">trio.Nursery.cancel_scope</target>
        </trans-unit>
        <trans-unit id="fef3dc2b89a4992e07e688c552617340e2a706d1" translate="yes" xml:space="preserve">
          <source>trio.Nursery.child_tasks</source>
          <target state="translated">trio.Nursery.child_tasks</target>
        </trans-unit>
        <trans-unit id="c028b5baa182961b20a38444729c66e3dba3550f" translate="yes" xml:space="preserve">
          <source>trio.Nursery.parent_task</source>
          <target state="translated">trio.Nursery.parent_task</target>
        </trans-unit>
        <trans-unit id="f13159076206ab5c13a120097ff142b2d5a80bfc" translate="yes" xml:space="preserve">
          <source>trio.Nursery.start</source>
          <target state="translated">trio.Nursery.start</target>
        </trans-unit>
        <trans-unit id="5c7547330bc7c3ee062a484a255d4bc816b39ca2" translate="yes" xml:space="preserve">
          <source>trio.Nursery.start_soon</source>
          <target state="translated">trio.Nursery.start_soon</target>
        </trans-unit>
        <trans-unit id="463adb0ec3c52ceb3274124651ede96c2f705a31" translate="yes" xml:space="preserve">
          <source>trio.Path</source>
          <target state="translated">trio.Path</target>
        </trans-unit>
        <trans-unit id="41e545b55bc4e503ae90042d0907674b234a820b" translate="yes" xml:space="preserve">
          <source>trio.Path.as_posix</source>
          <target state="translated">trio.Path.as_posix</target>
        </trans-unit>
        <trans-unit id="cecfda6d7930c6c32b4bafe8681bd75eb4b1ad5b" translate="yes" xml:space="preserve">
          <source>trio.Path.as_uri</source>
          <target state="translated">trio.Path.as_uri</target>
        </trans-unit>
        <trans-unit id="6d6a79998bb77febb7b551f992342e9a39ff8c32" translate="yes" xml:space="preserve">
          <source>trio.Path.chmod</source>
          <target state="translated">trio.Path.chmod</target>
        </trans-unit>
        <trans-unit id="6264ec9b15893969518beac5b8b6e1cf388f6b31" translate="yes" xml:space="preserve">
          <source>trio.Path.cwd</source>
          <target state="translated">trio.Path.cwd</target>
        </trans-unit>
        <trans-unit id="d65467140ed7ccbea8b30dd817d0736e31039418" translate="yes" xml:space="preserve">
          <source>trio.Path.exists</source>
          <target state="translated">trio.Path.exists</target>
        </trans-unit>
        <trans-unit id="30d399ac7574c17ad32e316771e23d797e793577" translate="yes" xml:space="preserve">
          <source>trio.Path.expanduser</source>
          <target state="translated">trio.Path.expanduser</target>
        </trans-unit>
        <trans-unit id="a7466bdf1da56d74761eca21b3ef2a6c73d12e4d" translate="yes" xml:space="preserve">
          <source>trio.Path.glob</source>
          <target state="translated">trio.Path.glob</target>
        </trans-unit>
        <trans-unit id="4bb91a142b4daab33d560e2283bdfe6a8d43099c" translate="yes" xml:space="preserve">
          <source>trio.Path.group</source>
          <target state="translated">trio.Path.group</target>
        </trans-unit>
        <trans-unit id="ba365a91df5c8a410ac32c3e4597a11db816203a" translate="yes" xml:space="preserve">
          <source>trio.Path.home</source>
          <target state="translated">trio.Path.home</target>
        </trans-unit>
        <trans-unit id="a23bb252840218cfa53d9491ae0042deb1182452" translate="yes" xml:space="preserve">
          <source>trio.Path.is_absolute</source>
          <target state="translated">trio.Path.is_absolute</target>
        </trans-unit>
        <trans-unit id="ba83d5209b0eb9a363f163ce8632091fa6f398f5" translate="yes" xml:space="preserve">
          <source>trio.Path.is_block_device</source>
          <target state="translated">trio.Path.is_block_device</target>
        </trans-unit>
        <trans-unit id="e8bbb29bda3f94e08ceabf6cb2251ce75c67502b" translate="yes" xml:space="preserve">
          <source>trio.Path.is_char_device</source>
          <target state="translated">trio.Path.is_char_device</target>
        </trans-unit>
        <trans-unit id="a30c97ff9404dfd5c2efac442bbdf5b03bf835f5" translate="yes" xml:space="preserve">
          <source>trio.Path.is_dir</source>
          <target state="translated">trio.Path.is_dir</target>
        </trans-unit>
        <trans-unit id="338b64de8263afc924e091a60925ba9a5cba1d8b" translate="yes" xml:space="preserve">
          <source>trio.Path.is_fifo</source>
          <target state="translated">trio.Path.is_fifo</target>
        </trans-unit>
        <trans-unit id="083283f1193a39af46a1511606528f334858e1c6" translate="yes" xml:space="preserve">
          <source>trio.Path.is_file</source>
          <target state="translated">trio.Path.is_file</target>
        </trans-unit>
        <trans-unit id="b132aa47c930d401ca40bbb05475e3967e345eed" translate="yes" xml:space="preserve">
          <source>trio.Path.is_reserved</source>
          <target state="translated">trio.Path.is_reserved</target>
        </trans-unit>
        <trans-unit id="2465eec20154630e31612cfe7c53c5cae0ccca8a" translate="yes" xml:space="preserve">
          <source>trio.Path.is_socket</source>
          <target state="translated">trio.Path.is_socket</target>
        </trans-unit>
        <trans-unit id="dedd6c61c0c4196e0c47a059c98257c0c014f902" translate="yes" xml:space="preserve">
          <source>trio.Path.is_symlink</source>
          <target state="translated">trio.Path.is_symlink</target>
        </trans-unit>
        <trans-unit id="aeea756d025c6726e8841678bf114ea9d53335c2" translate="yes" xml:space="preserve">
          <source>trio.Path.iterdir</source>
          <target state="translated">trio.Path.iterdir</target>
        </trans-unit>
        <trans-unit id="6c0c0f1510aa03f8fed405b70cde5c65c2d5b33b" translate="yes" xml:space="preserve">
          <source>trio.Path.joinpath</source>
          <target state="translated">trio.Path.joinpath</target>
        </trans-unit>
        <trans-unit id="ba4f894f44e4f0d7e258c49bdcda6493f84c0c68" translate="yes" xml:space="preserve">
          <source>trio.Path.lchmod</source>
          <target state="translated">trio.Path.lchmod</target>
        </trans-unit>
        <trans-unit id="65a04b36da154cf4291a3935b556c9b5bfb90056" translate="yes" xml:space="preserve">
          <source>trio.Path.lstat</source>
          <target state="translated">trio.Path.lstat</target>
        </trans-unit>
        <trans-unit id="e13a8010ede3fdd986f4892ec43fbfc932344413" translate="yes" xml:space="preserve">
          <source>trio.Path.match</source>
          <target state="translated">trio.Path.match</target>
        </trans-unit>
        <trans-unit id="76f7b3ec233072ba5f70bb91485bb5edb7d340b2" translate="yes" xml:space="preserve">
          <source>trio.Path.mkdir</source>
          <target state="translated">trio.Path.mkdir</target>
        </trans-unit>
        <trans-unit id="a2dd4873471dd5a6aa6b020c49300b224af01678" translate="yes" xml:space="preserve">
          <source>trio.Path.open</source>
          <target state="translated">trio.Path.open</target>
        </trans-unit>
        <trans-unit id="c8bc289f4e9cc9b014ae2e1257db083d3203ca15" translate="yes" xml:space="preserve">
          <source>trio.Path.owner</source>
          <target state="translated">trio.Path.owner</target>
        </trans-unit>
        <trans-unit id="ebf09093912c3958365d5ac83d0122d7b07504bd" translate="yes" xml:space="preserve">
          <source>trio.Path.read_bytes</source>
          <target state="translated">trio.Path.read_bytes</target>
        </trans-unit>
        <trans-unit id="cf4fe105374100baba575f8bba8ffd84bec3f78e" translate="yes" xml:space="preserve">
          <source>trio.Path.read_text</source>
          <target state="translated">trio.Path.read_text</target>
        </trans-unit>
        <trans-unit id="1ad287e9d5985a30f6c7df76e14f0197c127a554" translate="yes" xml:space="preserve">
          <source>trio.Path.relative_to</source>
          <target state="translated">trio.Path.relative_to</target>
        </trans-unit>
        <trans-unit id="27ea427591aefc0aa9e2e647c5a31adbb66d5bd6" translate="yes" xml:space="preserve">
          <source>trio.Path.rename</source>
          <target state="translated">trio.Path.rename</target>
        </trans-unit>
        <trans-unit id="67bb2789807e00f644acda7368543604c9281d14" translate="yes" xml:space="preserve">
          <source>trio.Path.replace</source>
          <target state="translated">trio.Path.replace</target>
        </trans-unit>
        <trans-unit id="4f1922abe367a78f3a37f31eac9705e8bc69b7cc" translate="yes" xml:space="preserve">
          <source>trio.Path.resolve</source>
          <target state="translated">trio.Path.resolve</target>
        </trans-unit>
        <trans-unit id="4fb7688f41df71cff26b44ef8e084023ce7339cd" translate="yes" xml:space="preserve">
          <source>trio.Path.rglob</source>
          <target state="translated">trio.Path.rglob</target>
        </trans-unit>
        <trans-unit id="a3d9f8e1ad0ffa9cb2844fd4b0e0e8b0acfe5062" translate="yes" xml:space="preserve">
          <source>trio.Path.rmdir</source>
          <target state="translated">trio.Path.rmdir</target>
        </trans-unit>
        <trans-unit id="06d43545f10c00eedfdd2f81fae56bc281c8cb1a" translate="yes" xml:space="preserve">
          <source>trio.Path.samefile</source>
          <target state="translated">trio.Path.samefile</target>
        </trans-unit>
        <trans-unit id="f4bb6ee0e047f6c279fa93dbe17ee0da353ca874" translate="yes" xml:space="preserve">
          <source>trio.Path.stat</source>
          <target state="translated">trio.Path.stat</target>
        </trans-unit>
        <trans-unit id="4f8149328b50af4c60f03d656293000dbab0a193" translate="yes" xml:space="preserve">
          <source>trio.Path.symlink_to</source>
          <target state="translated">trio.Path.symlink_to</target>
        </trans-unit>
        <trans-unit id="5b03e6f426a315a5a9738bb8c705186a179ad5e0" translate="yes" xml:space="preserve">
          <source>trio.Path.touch</source>
          <target state="translated">trio.Path.touch</target>
        </trans-unit>
        <trans-unit id="ca6540c33dd630ad6acc3cd3506ecea10a639a62" translate="yes" xml:space="preserve">
          <source>trio.Path.unlink</source>
          <target state="translated">trio.Path.unlink</target>
        </trans-unit>
        <trans-unit id="2b386dec09b8cbe1d4e9f4093f02277d57a00dd1" translate="yes" xml:space="preserve">
          <source>trio.Path.with_name</source>
          <target state="translated">trio.Path.with_name</target>
        </trans-unit>
        <trans-unit id="4416574f3d7a991d545312ef1d6b4dabeb1a8e03" translate="yes" xml:space="preserve">
          <source>trio.Path.with_suffix</source>
          <target state="translated">trio.Path.with_suffix</target>
        </trans-unit>
        <trans-unit id="c1c1d6c08945dc6cbdfa9d2aec8c880ce6ded5c4" translate="yes" xml:space="preserve">
          <source>trio.Path.write_bytes</source>
          <target state="translated">trio.Path.write_bytes</target>
        </trans-unit>
        <trans-unit id="92d9d90cef01964b23091f0a761cca59acc47fc7" translate="yes" xml:space="preserve">
          <source>trio.Path.write_text</source>
          <target state="translated">trio.Path.write_text</target>
        </trans-unit>
        <trans-unit id="b95629e12adfc03a5e7d69c785aafff955b36b24" translate="yes" xml:space="preserve">
          <source>trio.Process</source>
          <target state="translated">trio.Process</target>
        </trans-unit>
        <trans-unit id="d2f5180d7c9c7ab8cdfb057bb193fd6f44072ced" translate="yes" xml:space="preserve">
          <source>trio.Process.aclose</source>
          <target state="translated">trio.Process.aclose</target>
        </trans-unit>
        <trans-unit id="e46ef8b25a27e896bc157b8abb02ac109f95e179" translate="yes" xml:space="preserve">
          <source>trio.Process.args</source>
          <target state="translated">trio.Process.args</target>
        </trans-unit>
        <trans-unit id="20ac78b91fc5413a3d21c4fafeb78dfbcc69bee8" translate="yes" xml:space="preserve">
          <source>trio.Process.kill</source>
          <target state="translated">trio.Process.kill</target>
        </trans-unit>
        <trans-unit id="f146b8e74c1f60facca2f7c32f2e84ac347a94da" translate="yes" xml:space="preserve">
          <source>trio.Process.pid</source>
          <target state="translated">trio.Process.pid</target>
        </trans-unit>
        <trans-unit id="ff52c1030198fec8bcc8ee2ff4909a129ca802e1" translate="yes" xml:space="preserve">
          <source>trio.Process.poll</source>
          <target state="translated">trio.Process.poll</target>
        </trans-unit>
        <trans-unit id="bb5e8d251fd94df4b4f85a5862b90f20408f9f75" translate="yes" xml:space="preserve">
          <source>trio.Process.returncode</source>
          <target state="translated">trio.Process.returncode</target>
        </trans-unit>
        <trans-unit id="c354161dab84a8f646bfde68086236e96b786ae6" translate="yes" xml:space="preserve">
          <source>trio.Process.send_signal</source>
          <target state="translated">trio.Process.send_signal</target>
        </trans-unit>
        <trans-unit id="648b9349f3ca09033167dc6562019d96eac78908" translate="yes" xml:space="preserve">
          <source>trio.Process.stderr</source>
          <target state="translated">trio.Process.stderr</target>
        </trans-unit>
        <trans-unit id="d8d2a3dadfc889cd719749b131000d137557e183" translate="yes" xml:space="preserve">
          <source>trio.Process.stdin</source>
          <target state="translated">trio.Process.stdin</target>
        </trans-unit>
        <trans-unit id="c670edca33439e00eb71504aac27e335a8da489e" translate="yes" xml:space="preserve">
          <source>trio.Process.stdio</source>
          <target state="translated">trio.Process.stdio</target>
        </trans-unit>
        <trans-unit id="ac9fce0a07a87d83c7ddb69cdb8e00571eec76ff" translate="yes" xml:space="preserve">
          <source>trio.Process.stdout</source>
          <target state="translated">trio.Process.stdout</target>
        </trans-unit>
        <trans-unit id="b9036113d94a00c7647cc4ac4a41af6f403deffd" translate="yes" xml:space="preserve">
          <source>trio.Process.terminate</source>
          <target state="translated">trio.Process.terminate</target>
        </trans-unit>
        <trans-unit id="d66e22328aa943d8bc5fc842ae3b1def3c9703fa" translate="yes" xml:space="preserve">
          <source>trio.Process.wait</source>
          <target state="translated">trio.Process.wait</target>
        </trans-unit>
        <trans-unit id="b432532132175eedeadbd57ce4ced5ad6c997d18" translate="yes" xml:space="preserve">
          <source>trio.RunFinishedError</source>
          <target state="translated">trio.RunFinishedError</target>
        </trans-unit>
        <trans-unit id="bce53b871c5e108da130854e741bb4032af39c87" translate="yes" xml:space="preserve">
          <source>trio.SSLListener</source>
          <target state="translated">trio.SSLListener</target>
        </trans-unit>
        <trans-unit id="cdb4181469f12ac4791d59127a12109c868b4dfd" translate="yes" xml:space="preserve">
          <source>trio.SSLListener.accept</source>
          <target state="translated">trio.SSLListener.accept</target>
        </trans-unit>
        <trans-unit id="f302e75867185e0832e2c4c73b8eb88d8519658e" translate="yes" xml:space="preserve">
          <source>trio.SSLListener.aclose</source>
          <target state="translated">trio.SSLListener.aclose</target>
        </trans-unit>
        <trans-unit id="95dffd22046f979ad9e369f3b8f1cb10f3cd145e" translate="yes" xml:space="preserve">
          <source>trio.SSLListener.transport_listener</source>
          <target state="translated">trio.SSLListener.transport_listener</target>
        </trans-unit>
        <trans-unit id="79996c48b89942b0400eccfd6f3303a41e33a39d" translate="yes" xml:space="preserve">
          <source>trio.SSLStream</source>
          <target state="translated">trio.SSLStream</target>
        </trans-unit>
        <trans-unit id="645e98a80540d0f5fc979e4f5ab5805dca8e5f8b" translate="yes" xml:space="preserve">
          <source>trio.SSLStream.aclose</source>
          <target state="translated">trio.SSLStream.aclose</target>
        </trans-unit>
        <trans-unit id="b52305dacbf92d9d5dea65b87130c9231a4f9c89" translate="yes" xml:space="preserve">
          <source>trio.SSLStream.do_handshake</source>
          <target state="translated">trio.SSLStream.do_handshake</target>
        </trans-unit>
        <trans-unit id="89c72822574930e17ccd9f4f5f7c3b8a22702664" translate="yes" xml:space="preserve">
          <source>trio.SSLStream.receive_some</source>
          <target state="translated">trio.SSLStream.receive_some</target>
        </trans-unit>
        <trans-unit id="3002921c20ec1649587d2af55021784fbdb390ac" translate="yes" xml:space="preserve">
          <source>trio.SSLStream.send_all</source>
          <target state="translated">trio.SSLStream.send_all</target>
        </trans-unit>
        <trans-unit id="cb30fe2bb451948acff6bf45af2327c61664facb" translate="yes" xml:space="preserve">
          <source>trio.SSLStream.transport_stream</source>
          <target state="translated">trio.SSLStream.transport_stream</target>
        </trans-unit>
        <trans-unit id="9d336db7cf154af476ade7b29be45c39cc20929e" translate="yes" xml:space="preserve">
          <source>trio.SSLStream.unwrap</source>
          <target state="translated">trio.SSLStream.unwrap</target>
        </trans-unit>
        <trans-unit id="a7e6be5e068c0727f227d5863123f884f93ca79d" translate="yes" xml:space="preserve">
          <source>trio.SSLStream.wait_send_all_might_not_block</source>
          <target state="translated">trio.SSLStream.wait_send_all_might_not_block</target>
        </trans-unit>
        <trans-unit id="93fcd7f69d7379f91e3c378270b6a09b7029e021" translate="yes" xml:space="preserve">
          <source>trio.Semaphore</source>
          <target state="translated">trio.Semaphore</target>
        </trans-unit>
        <trans-unit id="446c68562b7734346b004f7ec3b67ca1f362370c" translate="yes" xml:space="preserve">
          <source>trio.Semaphore.acquire</source>
          <target state="translated">trio.Semaphore.acquire</target>
        </trans-unit>
        <trans-unit id="75b075b64d8547d3e44c126a255aa29665b23a25" translate="yes" xml:space="preserve">
          <source>trio.Semaphore.acquire_nowait</source>
          <target state="translated">trio.Semaphore.acquire_nowait</target>
        </trans-unit>
        <trans-unit id="6a53ec5da9ac229aa475f2ece4f15a9d57965fdc" translate="yes" xml:space="preserve">
          <source>trio.Semaphore.max_value</source>
          <target state="translated">trio.Semaphore.max_value</target>
        </trans-unit>
        <trans-unit id="a3288f42af1bb29dba4446fe8443ec9f9eaef81a" translate="yes" xml:space="preserve">
          <source>trio.Semaphore.release</source>
          <target state="translated">trio.Semaphore.release</target>
        </trans-unit>
        <trans-unit id="89e3bfe201338d35663c9d7e9f929dad41f15ed9" translate="yes" xml:space="preserve">
          <source>trio.Semaphore.statistics</source>
          <target state="translated">trio.Semaphore.statistics</target>
        </trans-unit>
        <trans-unit id="abd9e54f657a8cdc87a40ea57223a38d62753bfd" translate="yes" xml:space="preserve">
          <source>trio.Semaphore.value</source>
          <target state="translated">trio.Semaphore.value</target>
        </trans-unit>
        <trans-unit id="6672a59b097e19ef0087b1c3d92a05ad09477767" translate="yes" xml:space="preserve">
          <source>trio.SocketListener</source>
          <target state="translated">trio.SocketListener</target>
        </trans-unit>
        <trans-unit id="573ece5164e06e6877102aa0f01e2739a11c6b8f" translate="yes" xml:space="preserve">
          <source>trio.SocketListener.accept</source>
          <target state="translated">trio.SocketListener.accept</target>
        </trans-unit>
        <trans-unit id="051e34755bee16a84c1a0cecab08ff83338e64c6" translate="yes" xml:space="preserve">
          <source>trio.SocketListener.aclose</source>
          <target state="translated">trio.SocketListener.aclose</target>
        </trans-unit>
        <trans-unit id="d049939b5066435d7b4608aab55adbccac0087e4" translate="yes" xml:space="preserve">
          <source>trio.SocketListener.socket</source>
          <target state="translated">trio.SocketListener.socket</target>
        </trans-unit>
        <trans-unit id="c191148bb18311e87d520b759a81b1b1c927e0e2" translate="yes" xml:space="preserve">
          <source>trio.SocketStream</source>
          <target state="translated">trio.SocketStream</target>
        </trans-unit>
        <trans-unit id="58887391e1f3209066d0ddd1578b6380aef781be" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.aclose</source>
          <target state="translated">trio.SocketStream.aclose</target>
        </trans-unit>
        <trans-unit id="5729999279fd58366c4bfb0b3a8c4c0a356c24fd" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.getsockopt</source>
          <target state="translated">trio.SocketStream.getsockopt</target>
        </trans-unit>
        <trans-unit id="7001de0eaa68ceb88b4d87ec6024b3661d5d1d6e" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.receive_some</source>
          <target state="translated">trio.SocketStream.receive_some</target>
        </trans-unit>
        <trans-unit id="006017fa57dd7c6851aceafd2e6140dfd1d4ecbf" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.send_all</source>
          <target state="translated">trio.SocketStream.send_all</target>
        </trans-unit>
        <trans-unit id="0822c05eedf78bda8aa1f3129c7497ab6cde049e" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.send_eof</source>
          <target state="translated">trio.SocketStream.send_eof</target>
        </trans-unit>
        <trans-unit id="fd5e5376987dcf67c8f1c1799a79178982c54aa6" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.setsockopt</source>
          <target state="translated">trio.SocketStream.setsockopt</target>
        </trans-unit>
        <trans-unit id="2ccfb13b68e4da87e3f3e9169aab7bc2f28b6fb2" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.socket</source>
          <target state="translated">trio.SocketStream.socket</target>
        </trans-unit>
        <trans-unit id="598874eb3242ae514a8fee6455dac8ad34885585" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.wait_send_all_might_not_block</source>
          <target state="translated">trio.SocketStream.wait_send_all_might_not_block</target>
        </trans-unit>
        <trans-unit id="f0b25cbd198f0aff922ce1337411e8c599b8626e" translate="yes" xml:space="preserve">
          <source>trio.StapledStream</source>
          <target state="translated">trio.StapledStream</target>
        </trans-unit>
        <trans-unit id="b1e796a929efe32976ccbbf7f4aaf9a055be860f" translate="yes" xml:space="preserve">
          <source>trio.StapledStream.aclose</source>
          <target state="translated">trio.StapledStream.aclose</target>
        </trans-unit>
        <trans-unit id="aaf3c1d141014c9ea813151e99d94f77261dcec5" translate="yes" xml:space="preserve">
          <source>trio.StapledStream.receive_some</source>
          <target state="translated">trio.StapledStream.receive_some</target>
        </trans-unit>
        <trans-unit id="ae7a98f57b9885892f45544c9031e8005ac5e101" translate="yes" xml:space="preserve">
          <source>trio.StapledStream.receive_stream</source>
          <target state="translated">trio.StapledStream.receive_stream</target>
        </trans-unit>
        <trans-unit id="8809f5b0ad445c8c84d7ed456ee965df79feb472" translate="yes" xml:space="preserve">
          <source>trio.StapledStream.send_all</source>
          <target state="translated">trio.StapledStream.send_all</target>
        </trans-unit>
        <trans-unit id="84451f90926f20560f3cb4d17e3415df29f62100" translate="yes" xml:space="preserve">
          <source>trio.StapledStream.send_eof</source>
          <target state="translated">trio.StapledStream.send_eof</target>
        </trans-unit>
        <trans-unit id="4daeadbd28d194d8af9d83a0ed0679e6f35c1e13" translate="yes" xml:space="preserve">
          <source>trio.StapledStream.send_stream</source>
          <target state="translated">trio.StapledStream.send_stream</target>
        </trans-unit>
        <trans-unit id="58747e02691eaca63ab2cdb5597f924661356ba4" translate="yes" xml:space="preserve">
          <source>trio.StapledStream.wait_send_all_might_not_block</source>
          <target state="translated">trio.StapledStream.wait_send_all_might_not_block</target>
        </trans-unit>
        <trans-unit id="eb243569a6081f57227d8204d5218c1af273d5ac" translate="yes" xml:space="preserve">
          <source>trio.StrictFIFOLock</source>
          <target state="translated">trio.StrictFIFOLock</target>
        </trans-unit>
        <trans-unit id="a7ffc868348e2b1bb549c2955194a01ea4a32544" translate="yes" xml:space="preserve">
          <source>trio.TASK_STATUS_IGNORED</source>
          <target state="translated">trio.TASK_STATUS_IGNORED</target>
        </trans-unit>
        <trans-unit id="97a524a1c2360898f0ed8e30706be6306ef9d6fb" translate="yes" xml:space="preserve">
          <source>trio.TooSlowError</source>
          <target state="translated">trio.TooSlowError</target>
        </trans-unit>
        <trans-unit id="e6967aa9af2be65bbf540dbefc4b412f18386250" translate="yes" xml:space="preserve">
          <source>trio.TrioDeprecationWarning</source>
          <target state="translated">trio.TrioDeprecationWarning</target>
        </trans-unit>
        <trans-unit id="2b859f724e78f2eea92dbe0623732aabd5187178" translate="yes" xml:space="preserve">
          <source>trio.TrioInternalError</source>
          <target state="translated">trio.TrioInternalError</target>
        </trans-unit>
        <trans-unit id="d11cff665946ccb7c4e80132cc152036a8b543e0" translate="yes" xml:space="preserve">
          <source>trio.WouldBlock</source>
          <target state="translated">trio.WouldBlock</target>
        </trans-unit>
        <trans-unit id="fbf8caf47f2c98a730ba658809dab466258dc2a9" translate="yes" xml:space="preserve">
          <source>trio.abc.AsyncResource</source>
          <target state="translated">trio.abc.AsyncResource</target>
        </trans-unit>
        <trans-unit id="07e3ff9f796d690cd8d79f3f7784b479e27a36f0" translate="yes" xml:space="preserve">
          <source>trio.abc.AsyncResource.aclose</source>
          <target state="translated">trio.abc.AsyncResource.aclose</target>
        </trans-unit>
        <trans-unit id="d32cbf56b9c66b5bf5b84cfa7570bc5ee714ed86" translate="yes" xml:space="preserve">
          <source>trio.abc.Channel</source>
          <target state="translated">trio.abc.Channel</target>
        </trans-unit>
        <trans-unit id="cf0b67646f860ba83529d6cfca33cbd0e97dca38" translate="yes" xml:space="preserve">
          <source>trio.abc.Clock</source>
          <target state="translated">trio.abc.Clock</target>
        </trans-unit>
        <trans-unit id="d52f66c93d4495665ab26099ed7b068f6cd203e6" translate="yes" xml:space="preserve">
          <source>trio.abc.Clock.current_time</source>
          <target state="translated">trio.abc.Clock.current_time</target>
        </trans-unit>
        <trans-unit id="f1a7fef84be7807e06b8b7dd84fe96cdfbbd48f9" translate="yes" xml:space="preserve">
          <source>trio.abc.Clock.deadline_to_sleep_time</source>
          <target state="translated">trio.abc.Clock.deadline_to_sleep_time</target>
        </trans-unit>
        <trans-unit id="ff88985411e05fc4d0b682c576478f9112e54adb" translate="yes" xml:space="preserve">
          <source>trio.abc.Clock.start_clock</source>
          <target state="translated">trio.abc.Clock.start_clock</target>
        </trans-unit>
        <trans-unit id="6986a2b982b300d850b2477f83d550cffe3bc8ae" translate="yes" xml:space="preserve">
          <source>trio.abc.HalfCloseableStream</source>
          <target state="translated">trio.abc.HalfCloseableStream</target>
        </trans-unit>
        <trans-unit id="c45633c9dfa79dd633fb54068082b704754ed07b" translate="yes" xml:space="preserve">
          <source>trio.abc.HalfCloseableStream.send_eof</source>
          <target state="translated">trio.abc.HalfCloseableStream.send_eof</target>
        </trans-unit>
        <trans-unit id="630c0829d3b5cfda2a1efaebc01a6f9583ce5e32" translate="yes" xml:space="preserve">
          <source>trio.abc.HostnameResolver</source>
          <target state="translated">trio.abc.HostnameResolver</target>
        </trans-unit>
        <trans-unit id="9c26a30a634f130875e71d3a150545a949fc3cc3" translate="yes" xml:space="preserve">
          <source>trio.abc.HostnameResolver.getaddrinfo</source>
          <target state="translated">trio.abc.HostnameResolver.getaddrinfo</target>
        </trans-unit>
        <trans-unit id="518f335eed6739fe65675a4da68068cf6bdd9179" translate="yes" xml:space="preserve">
          <source>trio.abc.HostnameResolver.getnameinfo</source>
          <target state="translated">trio.abc.HostnameResolver.getnameinfo</target>
        </trans-unit>
        <trans-unit id="ca02f199a706165019ed7e899f41ae04559afcf4" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument</source>
          <target state="translated">trio.abc.Instrument</target>
        </trans-unit>
        <trans-unit id="abbd578ff4be0f40ba1220d1654182bb8dbb8609" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.after_io_wait</source>
          <target state="translated">trio.abc.Instrument.after_io_wait</target>
        </trans-unit>
        <trans-unit id="6b4f0df1942088a8b3fde54ae3e4285cfa335df0" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.after_run</source>
          <target state="translated">trio.abc.Instrument.after_run</target>
        </trans-unit>
        <trans-unit id="9d2a080e54970c6be1816f191d83ff6d04d0e40c" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.after_task_step</source>
          <target state="translated">trio.abc.Instrument.after_task_step</target>
        </trans-unit>
        <trans-unit id="4361f635d71a758a9adde1728397da0822b10a13" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.before_io_wait</source>
          <target state="translated">trio.abc.Instrument.before_io_wait</target>
        </trans-unit>
        <trans-unit id="128c7bd9c708ce137b8843bc3355cd9027f7b0bc" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.before_run</source>
          <target state="translated">trio.abc.Instrument.before_run</target>
        </trans-unit>
        <trans-unit id="85b3a68f0879649aa55a24d2e511b418d6c4a43f" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.before_task_step</source>
          <target state="translated">trio.abc.Instrument.before_task_step</target>
        </trans-unit>
        <trans-unit id="8f7ff4336e933b1b02b2f738ebd4bca20edc230b" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.task_exited</source>
          <target state="translated">trio.abc.Instrument.task_exited</target>
        </trans-unit>
        <trans-unit id="0ace6f37e85d9ec3cee4794ba270896f458c271a" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.task_scheduled</source>
          <target state="translated">trio.abc.Instrument.task_scheduled</target>
        </trans-unit>
        <trans-unit id="948d439cba0c022dd5e4d79c05ee926690872dfd" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.task_spawned</source>
          <target state="translated">trio.abc.Instrument.task_spawned</target>
        </trans-unit>
        <trans-unit id="479b49e402879c8bb9a8813835609fe333eec049" translate="yes" xml:space="preserve">
          <source>trio.abc.Listener</source>
          <target state="translated">trio.abc.Listener</target>
        </trans-unit>
        <trans-unit id="faf59a5191994ddc91a905b69d50a6fdcb2bb91a" translate="yes" xml:space="preserve">
          <source>trio.abc.Listener.accept</source>
          <target state="translated">trio.abc.Listener.accept</target>
        </trans-unit>
        <trans-unit id="11a8ca4b2a10b40b651ee6e3e4a485c8ce5729c6" translate="yes" xml:space="preserve">
          <source>trio.abc.ReceiveChannel</source>
          <target state="translated">trio.abc.ReceiveChannel</target>
        </trans-unit>
        <trans-unit id="8f5272bbf2d6d6ea5aa8d69f5ec576bda366b97a" translate="yes" xml:space="preserve">
          <source>trio.abc.ReceiveChannel.receive</source>
          <target state="translated">trio.abc.ReceiveChannel.receive</target>
        </trans-unit>
        <trans-unit id="8ff4757b11937d63b37e8aa3d5ca5f62956f27dc" translate="yes" xml:space="preserve">
          <source>trio.abc.ReceiveStream</source>
          <target state="translated">trio.abc.ReceiveStream</target>
        </trans-unit>
        <trans-unit id="103f585fa049eb15732cd91de190ce1fb66ad415" translate="yes" xml:space="preserve">
          <source>trio.abc.ReceiveStream.receive_some</source>
          <target state="translated">trio.abc.ReceiveStream.receive_some</target>
        </trans-unit>
        <trans-unit id="ec0bf54c4a17cd287b0b6948ce1407941c029db3" translate="yes" xml:space="preserve">
          <source>trio.abc.SendChannel</source>
          <target state="translated">trio.abc.SendChannel</target>
        </trans-unit>
        <trans-unit id="4bb34e9f5441d0ab60cbc5f81d54df92d996c605" translate="yes" xml:space="preserve">
          <source>trio.abc.SendChannel.send</source>
          <target state="translated">trio.abc.SendChannel.send</target>
        </trans-unit>
        <trans-unit id="812c79fe7c4be2cda1926b1b3c68147871d92d78" translate="yes" xml:space="preserve">
          <source>trio.abc.SendStream</source>
          <target state="translated">trio.abc.SendStream</target>
        </trans-unit>
        <trans-unit id="9ea7cce2e94368540e71097dfd062909f5823556" translate="yes" xml:space="preserve">
          <source>trio.abc.SendStream.send_all</source>
          <target state="translated">trio.abc.SendStream.send_all</target>
        </trans-unit>
        <trans-unit id="74ca6d13717caddcc1355c383047884dfcf4a246" translate="yes" xml:space="preserve">
          <source>trio.abc.SendStream.wait_send_all_might_not_block</source>
          <target state="translated">trio.abc.SendStream.wait_send_all_might_not_block</target>
        </trans-unit>
        <trans-unit id="b3a30fa4477d253d399deb43c2a5cf8562308fe1" translate="yes" xml:space="preserve">
          <source>trio.abc.SocketFactory</source>
          <target state="translated">trio.abc.SocketFactory</target>
        </trans-unit>
        <trans-unit id="7c176ab4103725dd085cf08d565805a2387f9b7c" translate="yes" xml:space="preserve">
          <source>trio.abc.SocketFactory.socket</source>
          <target state="translated">trio.abc.SocketFactory.socket</target>
        </trans-unit>
        <trans-unit id="e17d6e3baeab9874433e202357ba447d3f416bc6" translate="yes" xml:space="preserve">
          <source>trio.abc.Stream</source>
          <target state="translated">trio.abc.Stream</target>
        </trans-unit>
        <trans-unit id="f7fc3bd6afe008621c22586b6a2e7b2f157bfd8b" translate="yes" xml:space="preserve">
          <source>trio.aclose_forcefully</source>
          <target state="translated">trio.aclose_forcefully</target>
        </trans-unit>
        <trans-unit id="1de4150cbe33c076476a2121992ac29e2c3f9b9d" translate="yes" xml:space="preserve">
          <source>trio.current_effective_deadline</source>
          <target state="translated">trio.current_effective_deadline</target>
        </trans-unit>
        <trans-unit id="2eed66b6fa7b295fcdfa9190b7b5631f534b593e" translate="yes" xml:space="preserve">
          <source>trio.current_time</source>
          <target state="translated">trio.current_time</target>
        </trans-unit>
        <trans-unit id="938182158eed707ca8eac00a5679e54d7f6d5b20" translate="yes" xml:space="preserve">
          <source>trio.fail_after</source>
          <target state="translated">trio.fail_after</target>
        </trans-unit>
        <trans-unit id="fc10176acce1e6bef6492d1be9c92700b8319114" translate="yes" xml:space="preserve">
          <source>trio.fail_at</source>
          <target state="translated">trio.fail_at</target>
        </trans-unit>
        <trans-unit id="68e9a720bb3ea9f731b8be00de5b43e71c78928a" translate="yes" xml:space="preserve">
          <source>trio.from_thread.run</source>
          <target state="translated">trio.from_thread.run</target>
        </trans-unit>
        <trans-unit id="582f09672f0c15e6f6f0f6e120aebcf92841eab8" translate="yes" xml:space="preserve">
          <source>trio.from_thread.run_sync</source>
          <target state="translated">trio.from_thread.run_sync</target>
        </trans-unit>
        <trans-unit id="377d7ee8dfeaa1f955cdcc0eecf94dfe241249aa" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Abort</source>
          <target state="translated">trio.hazmat.Abort</target>
        </trans-unit>
        <trans-unit id="fee31b3594e531e910ebde4880eb8e586e8f3cd0" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Abort.FAILED</source>
          <target state="translated">trio.hazmat.Abort.FAILED</target>
        </trans-unit>
        <trans-unit id="efd549a2453ca696b6ead7dc567431072bce92b8" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Abort.SUCCEEDED</source>
          <target state="translated">trio.hazmat.Abort.SUCCEEDED</target>
        </trans-unit>
        <trans-unit id="66f4aa9273b57f40b6dcebdfb61b6cd599528994" translate="yes" xml:space="preserve">
          <source>trio.hazmat.FdStream</source>
          <target state="translated">trio.hazmat.FdStream</target>
        </trans-unit>
        <trans-unit id="55f183b8e8aa301ba8b3a72227da949e9e1e6296" translate="yes" xml:space="preserve">
          <source>trio.hazmat.ParkingLot</source>
          <target state="translated">trio.hazmat.ParkingLot</target>
        </trans-unit>
        <trans-unit id="67eee9dbc5fa3716dd2fad16fdea9e70570de9a2" translate="yes" xml:space="preserve">
          <source>trio.hazmat.ParkingLot.park</source>
          <target state="translated">trio.hazmat.ParkingLot.park</target>
        </trans-unit>
        <trans-unit id="5de001a607de1ce79a0247d9f4b2e617e0cf4e83" translate="yes" xml:space="preserve">
          <source>trio.hazmat.ParkingLot.repark</source>
          <target state="translated">trio.hazmat.ParkingLot.repark</target>
        </trans-unit>
        <trans-unit id="4a72401f77c127ac32bc77daf922333487dce815" translate="yes" xml:space="preserve">
          <source>trio.hazmat.ParkingLot.repark_all</source>
          <target state="translated">trio.hazmat.ParkingLot.repark_all</target>
        </trans-unit>
        <trans-unit id="283dd5ef0d92c78b9e243497d9151f1f44822e85" translate="yes" xml:space="preserve">
          <source>trio.hazmat.ParkingLot.statistics</source>
          <target state="translated">trio.hazmat.ParkingLot.statistics</target>
        </trans-unit>
        <trans-unit id="7fafec417f86a26523d900ff7b228b917db6f4b0" translate="yes" xml:space="preserve">
          <source>trio.hazmat.ParkingLot.unpark</source>
          <target state="translated">trio.hazmat.ParkingLot.unpark</target>
        </trans-unit>
        <trans-unit id="5c10855950b05e29e910ba2b1d95243db34992ee" translate="yes" xml:space="preserve">
          <source>trio.hazmat.ParkingLot.unpark_all</source>
          <target state="translated">trio.hazmat.ParkingLot.unpark_all</target>
        </trans-unit>
        <trans-unit id="958db2dba257a5c4b74b1715a40b00963f64ff73" translate="yes" xml:space="preserve">
          <source>trio.hazmat.RunVar</source>
          <target state="translated">trio.hazmat.RunVar</target>
        </trans-unit>
        <trans-unit id="1f93d61cfb062684edcab4666c7a9094ad92be02" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Task</source>
          <target state="translated">trio.hazmat.Task</target>
        </trans-unit>
        <trans-unit id="56007a256133264ebe4115d7d758619c3a3188d7" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Task.child_nurseries</source>
          <target state="translated">trio.hazmat.Task.child_nurseries</target>
        </trans-unit>
        <trans-unit id="0f2bc5c4aa63929d0a3ad363dc71ca1df17f91d2" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Task.context</source>
          <target state="translated">trio.hazmat.Task.context</target>
        </trans-unit>
        <trans-unit id="959f45a936e9a2d50a91f2e723a17ed6a35c6416" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Task.coro</source>
          <target state="translated">trio.hazmat.Task.coro</target>
        </trans-unit>
        <trans-unit id="313d68ca9b0270eb8d4634469d04d80cb05bd795" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Task.custom_sleep_data</source>
          <target state="translated">trio.hazmat.Task.custom_sleep_data</target>
        </trans-unit>
        <trans-unit id="4cdfd05a664da3de9c44529c01c083d0ca7faa5d" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Task.name</source>
          <target state="translated">trio.hazmat.Task.name</target>
        </trans-unit>
        <trans-unit id="b9e333285fe3a864a13b34b091cc530be8a15966" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Task.parent_nursery</source>
          <target state="translated">trio.hazmat.Task.parent_nursery</target>
        </trans-unit>
        <trans-unit id="b19a9a96b81abb9460c908a51450e66b85e95559" translate="yes" xml:space="preserve">
          <source>trio.hazmat.TrioToken</source>
          <target state="translated">trio.hazmat.TrioToken</target>
        </trans-unit>
        <trans-unit id="37a507b84454a6d2e51a96f14c36d027ca8254c2" translate="yes" xml:space="preserve">
          <source>trio.hazmat.TrioToken.run_sync_soon</source>
          <target state="translated">trio.hazmat.TrioToken.run_sync_soon</target>
        </trans-unit>
        <trans-unit id="0a6d9b1a7e2e0e14ca83f31bf2ecbc93dbe19578" translate="yes" xml:space="preserve">
          <source>trio.hazmat.WaitForSingleObject</source>
          <target state="translated">trio.hazmat.WaitForSingleObject</target>
        </trans-unit>
        <trans-unit id="7e7ad7d21c4f47b50214ccbcc8b698c85d6fbf18" translate="yes" xml:space="preserve">
          <source>trio.hazmat.add_instrument</source>
          <target state="translated">trio.hazmat.add_instrument</target>
        </trans-unit>
        <trans-unit id="5f8c563ff87b2dc8c8567e1809ee11a4bc7a2c64" translate="yes" xml:space="preserve">
          <source>trio.hazmat.cancel_shielded_checkpoint</source>
          <target state="translated">trio.hazmat.cancel_shielded_checkpoint</target>
        </trans-unit>
        <trans-unit id="85633e0b57f589bc43be76f6e91b99ee40c1b5ff" translate="yes" xml:space="preserve">
          <source>trio.hazmat.checkpoint</source>
          <target state="translated">trio.hazmat.checkpoint</target>
        </trans-unit>
        <trans-unit id="cff2493b6d0ffc2dd73a3c90865e7edbdc9d0fd6" translate="yes" xml:space="preserve">
          <source>trio.hazmat.checkpoint_if_cancelled</source>
          <target state="translated">trio.hazmat.checkpoint_if_cancelled</target>
        </trans-unit>
        <trans-unit id="4be8b9e956d11a82d9df0d01738b7e04fbdcbe0f" translate="yes" xml:space="preserve">
          <source>trio.hazmat.current_clock</source>
          <target state="translated">trio.hazmat.current_clock</target>
        </trans-unit>
        <trans-unit id="13992abda4562f03ffaedab3ba0d10e06b9d8d0d" translate="yes" xml:space="preserve">
          <source>trio.hazmat.current_iocp</source>
          <target state="translated">trio.hazmat.current_iocp</target>
        </trans-unit>
        <trans-unit id="112caae5ed90caa79dbadc12c74111a7de07ea48" translate="yes" xml:space="preserve">
          <source>trio.hazmat.current_kqueue</source>
          <target state="translated">trio.hazmat.current_kqueue</target>
        </trans-unit>
        <trans-unit id="335b5e41a591c612c8ddf22ad88c78fd3c5d1ea6" translate="yes" xml:space="preserve">
          <source>trio.hazmat.current_root_task</source>
          <target state="translated">trio.hazmat.current_root_task</target>
        </trans-unit>
        <trans-unit id="af6409a5d25b2b2e0d63989673f5312d8a0f9cb5" translate="yes" xml:space="preserve">
          <source>trio.hazmat.current_statistics</source>
          <target state="translated">trio.hazmat.current_statistics</target>
        </trans-unit>
        <trans-unit id="c67b6b454c3d3c97bb7113fc85b6278d74a0a307" translate="yes" xml:space="preserve">
          <source>trio.hazmat.current_task</source>
          <target state="translated">trio.hazmat.current_task</target>
        </trans-unit>
        <trans-unit id="b484dd3f465efe0b9dee8c719d8199ff988ce36e" translate="yes" xml:space="preserve">
          <source>trio.hazmat.current_trio_token</source>
          <target state="translated">trio.hazmat.current_trio_token</target>
        </trans-unit>
        <trans-unit id="8138820f0643fc08460f2bb8e6511445b9034283" translate="yes" xml:space="preserve">
          <source>trio.hazmat.currently_ki_protected</source>
          <target state="translated">trio.hazmat.currently_ki_protected</target>
        </trans-unit>
        <trans-unit id="8807d9ce19d767ec2d4a0209f2bd1965a7bb6d38" translate="yes" xml:space="preserve">
          <source>trio.hazmat.disable_ki_protection</source>
          <target state="translated">trio.hazmat.disable_ki_protection</target>
        </trans-unit>
        <trans-unit id="35d42be3848d0f524edc56bc03f5ae81cdbd0e48" translate="yes" xml:space="preserve">
          <source>trio.hazmat.enable_ki_protection</source>
          <target state="translated">trio.hazmat.enable_ki_protection</target>
        </trans-unit>
        <trans-unit id="cfdb8ae674ad966b4d6f83b7a671c2961fd4e11e" translate="yes" xml:space="preserve">
          <source>trio.hazmat.monitor_completion_key</source>
          <target state="translated">trio.hazmat.monitor_completion_key</target>
        </trans-unit>
        <trans-unit id="d4385c84878e7961508daf0e399885ff854f078d" translate="yes" xml:space="preserve">
          <source>trio.hazmat.monitor_kevent</source>
          <target state="translated">trio.hazmat.monitor_kevent</target>
        </trans-unit>
        <trans-unit id="4fb524c029651259b6fac24963efdbc39d2d5810" translate="yes" xml:space="preserve">
          <source>trio.hazmat.notify_closing</source>
          <target state="translated">trio.hazmat.notify_closing</target>
        </trans-unit>
        <trans-unit id="58d9922fc01e695e176b3398900c1620474e05c0" translate="yes" xml:space="preserve">
          <source>trio.hazmat.permanently_detach_coroutine_object</source>
          <target state="translated">trio.hazmat.permanently_detach_coroutine_object</target>
        </trans-unit>
        <trans-unit id="8c6ec7a98ae29137ac6d5e2456a2ace284513d5f" translate="yes" xml:space="preserve">
          <source>trio.hazmat.reattach_detached_coroutine_object</source>
          <target state="translated">trio.hazmat.reattach_detached_coroutine_object</target>
        </trans-unit>
        <trans-unit id="c0ba6fb9beaafb11725d65a4d0264cf061506303" translate="yes" xml:space="preserve">
          <source>trio.hazmat.register_with_iocp</source>
          <target state="translated">trio.hazmat.register_with_iocp</target>
        </trans-unit>
        <trans-unit id="039dfbc898635052d0b99cd4c0854c35ced8d62a" translate="yes" xml:space="preserve">
          <source>trio.hazmat.remove_instrument</source>
          <target state="translated">trio.hazmat.remove_instrument</target>
        </trans-unit>
        <trans-unit id="21cb4fca281bd3691ebdd610cf7380b46b8d9c95" translate="yes" xml:space="preserve">
          <source>trio.hazmat.reschedule</source>
          <target state="translated">trio.hazmat.reschedule</target>
        </trans-unit>
        <trans-unit id="31c9a34db2dedb44f9338528684664cc72019f27" translate="yes" xml:space="preserve">
          <source>trio.hazmat.spawn_system_task</source>
          <target state="translated">trio.hazmat.spawn_system_task</target>
        </trans-unit>
        <trans-unit id="2e93cd9997ade187a201b987881484fcdf10252d" translate="yes" xml:space="preserve">
          <source>trio.hazmat.temporarily_detach_coroutine_object</source>
          <target state="translated">trio.hazmat.temporarily_detach_coroutine_object</target>
        </trans-unit>
        <trans-unit id="01e35385fad5b8340d4043e9ea3ab8e8e3501272" translate="yes" xml:space="preserve">
          <source>trio.hazmat.wait_kevent</source>
          <target state="translated">trio.hazmat.wait_kevent</target>
        </trans-unit>
        <trans-unit id="ec1925b3d06a473de1bbb73be3a3249a85084112" translate="yes" xml:space="preserve">
          <source>trio.hazmat.wait_overlapped</source>
          <target state="translated">trio.hazmat.wait_overlapped</target>
        </trans-unit>
        <trans-unit id="5c765a44e4d626e47e9d5612642e37cd06f7ab07" translate="yes" xml:space="preserve">
          <source>trio.hazmat.wait_readable</source>
          <target state="translated">trio.hazmat.wait_readable</target>
        </trans-unit>
        <trans-unit id="74f4e8f2e74570c40c909004495b6b1bc32b9f59" translate="yes" xml:space="preserve">
          <source>trio.hazmat.wait_task_rescheduled</source>
          <target state="translated">trio.hazmat.wait_task_rescheduled</target>
        </trans-unit>
        <trans-unit id="e180f2ed412288cb211c9350ccba8227a3b316f2" translate="yes" xml:space="preserve">
          <source>trio.hazmat.wait_writable</source>
          <target state="translated">trio.hazmat.wait_writable</target>
        </trans-unit>
        <trans-unit id="9f444e9cbb8a420ba7ff593b384dc73e7d19fdef" translate="yes" xml:space="preserve">
          <source>trio.move_on_after</source>
          <target state="translated">trio.move_on_after</target>
        </trans-unit>
        <trans-unit id="a63324b5d22beb567290f5e13959b101ac7e184d" translate="yes" xml:space="preserve">
          <source>trio.move_on_at</source>
          <target state="translated">trio.move_on_at</target>
        </trans-unit>
        <trans-unit id="b597ce79b7ab201268d48e583367c8625ba81ee7" translate="yes" xml:space="preserve">
          <source>trio.open_file</source>
          <target state="translated">trio.open_file</target>
        </trans-unit>
        <trans-unit id="335505d82feadb66202dab64fbaea820c83950a3" translate="yes" xml:space="preserve">
          <source>trio.open_memory_channel</source>
          <target state="translated">trio.open_memory_channel</target>
        </trans-unit>
        <trans-unit id="b9faf3366aee9bbc7f31353bdb31010e43740fca" translate="yes" xml:space="preserve">
          <source>trio.open_nursery</source>
          <target state="translated">trio.open_nursery</target>
        </trans-unit>
        <trans-unit id="0a460f520c00f75deaf64800d39c68ef01086105" translate="yes" xml:space="preserve">
          <source>trio.open_process</source>
          <target state="translated">trio.open_process</target>
        </trans-unit>
        <trans-unit id="c4bc804e2be2a6856707069a85cf464e6b3d824e" translate="yes" xml:space="preserve">
          <source>trio.open_signal_receiver</source>
          <target state="translated">trio.open_signal_receiver</target>
        </trans-unit>
        <trans-unit id="16a1d615d4d1541269f19c90d2ad813ee776f0bd" translate="yes" xml:space="preserve">
          <source>trio.open_ssl_over_tcp_listeners</source>
          <target state="translated">trio.open_ssl_over_tcp_listeners</target>
        </trans-unit>
        <trans-unit id="ec68ef4c5d61e24bbbb8ff67243ea18633fc5bf2" translate="yes" xml:space="preserve">
          <source>trio.open_ssl_over_tcp_stream</source>
          <target state="translated">trio.open_ssl_over_tcp_stream</target>
        </trans-unit>
        <trans-unit id="6e5a816bb61f4a6f700232acce9791b777ccb95f" translate="yes" xml:space="preserve">
          <source>trio.open_tcp_listeners</source>
          <target state="translated">trio.open_tcp_listeners</target>
        </trans-unit>
        <trans-unit id="8d2e9668e58c35130b3ec2cd78438bc04f36d8fd" translate="yes" xml:space="preserve">
          <source>trio.open_tcp_stream</source>
          <target state="translated">trio.open_tcp_stream</target>
        </trans-unit>
        <trans-unit id="320d6ba48d3f0a5a5d4fbe8fb114445d0309cd36" translate="yes" xml:space="preserve">
          <source>trio.open_unix_socket</source>
          <target state="translated">trio.open_unix_socket</target>
        </trans-unit>
        <trans-unit id="be43ea7220d2060a899163f41753c218ae8e27fe" translate="yes" xml:space="preserve">
          <source>trio.run</source>
          <target state="translated">trio.run</target>
        </trans-unit>
        <trans-unit id="fab0a3bf937ef62a03bdd73ec00817b13cafa4ed" translate="yes" xml:space="preserve">
          <source>trio.run_process</source>
          <target state="translated">trio.run_process</target>
        </trans-unit>
        <trans-unit id="b4eaa05b676a77ca6d1bee0a8e8a1e9724c148e4" translate="yes" xml:space="preserve">
          <source>trio.serve_listeners</source>
          <target state="translated">trio.serve_listeners</target>
        </trans-unit>
        <trans-unit id="b7144780f69a73b359899c6ae65a1d40965fe707" translate="yes" xml:space="preserve">
          <source>trio.serve_ssl_over_tcp</source>
          <target state="translated">trio.serve_ssl_over_tcp</target>
        </trans-unit>
        <trans-unit id="60ceea4af84d70abb10fd63c43542281a882796c" translate="yes" xml:space="preserve">
          <source>trio.serve_tcp</source>
          <target state="translated">trio.serve_tcp</target>
        </trans-unit>
        <trans-unit id="e76bf6541805ffa6f5c52368797d63d5b0250d79" translate="yes" xml:space="preserve">
          <source>trio.sleep</source>
          <target state="translated">trio.sleep</target>
        </trans-unit>
        <trans-unit id="0c46ce0d7853c3e748abd0b9cda4b9a0aa8c49aa" translate="yes" xml:space="preserve">
          <source>trio.sleep_forever</source>
          <target state="translated">trio.sleep_forever</target>
        </trans-unit>
        <trans-unit id="9a6237a5224a696eafa78dd5f04277042e1452a4" translate="yes" xml:space="preserve">
          <source>trio.sleep_until</source>
          <target state="translated">trio.sleep_until</target>
        </trans-unit>
        <trans-unit id="b959d4b3a7e03c4a78da88b08fe8b798ea8a73d1" translate="yes" xml:space="preserve">
          <source>trio.socket.SocketType</source>
          <target state="translated">trio.socket.SocketType</target>
        </trans-unit>
        <trans-unit id="14d87f16ac860a4429cdc77bb13ec0085ab37e3a" translate="yes" xml:space="preserve">
          <source>trio.socket.SocketType.connect</source>
          <target state="translated">trio.socket.SocketType.connect</target>
        </trans-unit>
        <trans-unit id="9fa53fb5cee65e8bd816c4aa256e543fe3af65eb" translate="yes" xml:space="preserve">
          <source>trio.socket.SocketType.did_shutdown_SHUT_WR</source>
          <target state="translated">trio.socket.SocketType.did_shutdown_SHUT_WR</target>
        </trans-unit>
        <trans-unit id="1d3673a624d1f85b56e48924c3d25e93cc4425fb" translate="yes" xml:space="preserve">
          <source>trio.socket.SocketType.is_readable</source>
          <target state="translated">trio.socket.SocketType.is_readable</target>
        </trans-unit>
        <trans-unit id="6700d904ec7c1bfa6df5674a2e236c5bfebb0d95" translate="yes" xml:space="preserve">
          <source>trio.socket.SocketType.sendfile</source>
          <target state="translated">trio.socket.SocketType.sendfile</target>
        </trans-unit>
        <trans-unit id="ed7de9ec8ad33f2c3caa53e3a93737d99bfb0be7" translate="yes" xml:space="preserve">
          <source>trio.socket.from_stdlib_socket</source>
          <target state="translated">trio.socket.from_stdlib_socket</target>
        </trans-unit>
        <trans-unit id="67104bac294f5cdc6743b4fca15f65862d1c6377" translate="yes" xml:space="preserve">
          <source>trio.socket.fromfd</source>
          <target state="translated">trio.socket.fromfd</target>
        </trans-unit>
        <trans-unit id="12c88b66ef954f370f397d06e99342069f8bfd19" translate="yes" xml:space="preserve">
          <source>trio.socket.fromshare</source>
          <target state="translated">trio.socket.fromshare</target>
        </trans-unit>
        <trans-unit id="8e04774fb7def62f8464d67d70f0ffe003c37b83" translate="yes" xml:space="preserve">
          <source>trio.socket.getaddrinfo</source>
          <target state="translated">trio.socket.getaddrinfo</target>
        </trans-unit>
        <trans-unit id="8b426e9b1b0fc7dcd252dbbb3ec628ccd3c58377" translate="yes" xml:space="preserve">
          <source>trio.socket.getnameinfo</source>
          <target state="translated">trio.socket.getnameinfo</target>
        </trans-unit>
        <trans-unit id="70cf05824c043361764a09ae4885bfb75fc91a98" translate="yes" xml:space="preserve">
          <source>trio.socket.getprotobyname</source>
          <target state="translated">trio.socket.getprotobyname</target>
        </trans-unit>
        <trans-unit id="0ee1293f749c7aae7ab063bbc10bf251a6b8319f" translate="yes" xml:space="preserve">
          <source>trio.socket.set_custom_hostname_resolver</source>
          <target state="translated">trio.socket.set_custom_hostname_resolver</target>
        </trans-unit>
        <trans-unit id="eaf2fd5eed0d77a124a02f5cedb7817c68c58075" translate="yes" xml:space="preserve">
          <source>trio.socket.set_custom_socket_factory</source>
          <target state="translated">trio.socket.set_custom_socket_factory</target>
        </trans-unit>
        <trans-unit id="8e688f792bc4e844fca7662349316f7b757041da" translate="yes" xml:space="preserve">
          <source>trio.socket.socket</source>
          <target state="translated">trio.socket.socket</target>
        </trans-unit>
        <trans-unit id="e0fb0f5be0081cef75c344c269d20e0974fda11d" translate="yes" xml:space="preserve">
          <source>trio.socket.socketpair</source>
          <target state="translated">trio.socket.socketpair</target>
        </trans-unit>
        <trans-unit id="9718caaa0b82ec915e44c8a267590c6ab6532c0a" translate="yes" xml:space="preserve">
          <source>trio.testing.MemoryReceiveStream</source>
          <target state="translated">trio.testing.MemoryReceiveStream</target>
        </trans-unit>
        <trans-unit id="6890420881da1ee131458513126e9d2608a0767d" translate="yes" xml:space="preserve">
          <source>trio.testing.MemoryReceiveStream.aclose</source>
          <target state="translated">trio.testing.MemoryReceiveStream.aclose</target>
        </trans-unit>
        <trans-unit id="a5bc16e536707559bb0944dd087bfda3c42b33f7" translate="yes" xml:space="preserve">
          <source>trio.testing.MemoryReceiveStream.close</source>
          <target state="translated">trio.testing.MemoryReceiveStream.close</target>
        </trans-unit>
        <trans-unit id="6420fb982989d44965249e397f7b44e37983a91a" translate="yes" xml:space="preserve">
          <source>trio.testing.MemoryReceiveStream.close_hook</source>
          <target state="translated">trio.testing.MemoryReceiveStream.close_hook</target>
        </trans-unit>
        <trans-unit id="7d889e0578a74b4192caa5942c350968a7381dcd" translate="yes" xml:space="preserve">
          <source>trio.testing.MemoryReceiveStream.put_data</source>
          <target state="translated">trio.testing.MemoryReceiveStream.put_data</target>
        </trans-unit>
        <trans-unit id="82ff91e28943b695192ebd0553f6fda888bd7440" translate="yes" xml:space="preserve">
          <source>trio.testing.MemoryReceiveStream.put_eof</source>
          <target state="translated">trio.testing.MemoryReceiveStream.put_eof</target>
        </trans-unit>
        <trans-unit id="a57a0019b8e0290c6548aae7d9554bfe5177368c" translate="yes" xml:space="preserve">
          <source>trio.testing.MemoryReceiveStream.receive_some</source>
          <target state="translated">trio.testing.MemoryReceiveStream.receive_some</target>
        </trans-unit>
        <trans-unit id="5e5b11f1146761728ec6309a746ca9807a3e1888" translate="yes" xml:space="preserve">
          <source>trio.testing.MemoryReceiveStream.receive_some_hook</source>
          <target state="translated">trio.testing.MemoryReceiveStream.receive_some_hook</target>
        </trans-unit>
        <trans-unit id="dfcca2a4007f2eb820b295c03399ed9758820814" translate="yes" xml:space="preserve">
          <source>trio.testing.MemorySendStream</source>
          <target state="translated">trio.testing.MemorySendStream</target>
        </trans-unit>
        <trans-unit id="e5ba9abd3b69d930fb865b05d4e7236e1d0c395f" translate="yes" xml:space="preserve">
          <source>trio.testing.MemorySendStream.aclose</source>
          <target state="translated">trio.testing.MemorySendStream.aclose</target>
        </trans-unit>
        <trans-unit id="64981623c6a7679e6a3d725bc7d6278a3041c80b" translate="yes" xml:space="preserve">
          <source>trio.testing.MemorySendStream.close</source>
          <target state="translated">trio.testing.MemorySendStream.close</target>
        </trans-unit>
        <trans-unit id="16941453fe1f7935c426dea3734fe02896f53006" translate="yes" xml:space="preserve">
          <source>trio.testing.MemorySendStream.close_hook</source>
          <target state="translated">trio.testing.MemorySendStream.close_hook</target>
        </trans-unit>
        <trans-unit id="0c9a32409baa0d018e01fab7b80212fcf2fe533f" translate="yes" xml:space="preserve">
          <source>trio.testing.MemorySendStream.get_data</source>
          <target state="translated">trio.testing.MemorySendStream.get_data</target>
        </trans-unit>
        <trans-unit id="6b4598b9f0bc1f63cd72820c879a15fecf0a448c" translate="yes" xml:space="preserve">
          <source>trio.testing.MemorySendStream.get_data_nowait</source>
          <target state="translated">trio.testing.MemorySendStream.get_data_nowait</target>
        </trans-unit>
        <trans-unit id="bfd5da935cf11196f556a374ca8b25e968a130db" translate="yes" xml:space="preserve">
          <source>trio.testing.MemorySendStream.send_all</source>
          <target state="translated">trio.testing.MemorySendStream.send_all</target>
        </trans-unit>
        <trans-unit id="dde2fcbcfe63ad36ebe33f1af98a92ac45526774" translate="yes" xml:space="preserve">
          <source>trio.testing.MemorySendStream.send_all_hook</source>
          <target state="translated">trio.testing.MemorySendStream.send_all_hook</target>
        </trans-unit>
        <trans-unit id="bcc8225045e7abf47ccafa0991a0ba90632ec158" translate="yes" xml:space="preserve">
          <source>trio.testing.MemorySendStream.wait_send_all_might_not_block</source>
          <target state="translated">trio.testing.MemorySendStream.wait_send_all_might_not_block</target>
        </trans-unit>
        <trans-unit id="0c270fd4f731b2eec330f6aa7dd438eaeb295504" translate="yes" xml:space="preserve">
          <source>trio.testing.MemorySendStream.wait_send_all_might_not_block_hook</source>
          <target state="translated">trio.testing.MemorySendStream.wait_send_all_might_not_block_hook</target>
        </trans-unit>
        <trans-unit id="4c48cba4b11632efda84b69b986bcfa63f8b519d" translate="yes" xml:space="preserve">
          <source>trio.testing.MockClock</source>
          <target state="translated">trio.testing.MockClock</target>
        </trans-unit>
        <trans-unit id="31e50074f3562d7cb02466763b0b863130524662" translate="yes" xml:space="preserve">
          <source>trio.testing.MockClock.autojump_threshold</source>
          <target state="translated">trio.testing.MockClock.autojump_threshold</target>
        </trans-unit>
        <trans-unit id="b255e824c1c36371fcbd031153f21db01e6d161f" translate="yes" xml:space="preserve">
          <source>trio.testing.MockClock.jump</source>
          <target state="translated">trio.testing.MockClock.jump</target>
        </trans-unit>
        <trans-unit id="5f43fe4bfe8157c16e7917c1df0b59a79fe0ebf4" translate="yes" xml:space="preserve">
          <source>trio.testing.MockClock.rate</source>
          <target state="translated">trio.testing.MockClock.rate</target>
        </trans-unit>
        <trans-unit id="2e097528159eae33dfc1f7f05e5ffe0e4cd8c4b3" translate="yes" xml:space="preserve">
          <source>trio.testing.Sequencer</source>
          <target state="translated">trio.testing.Sequencer</target>
        </trans-unit>
        <trans-unit id="d5c107aaff9b32bc93cde6ec430648b621ada31f" translate="yes" xml:space="preserve">
          <source>trio.testing.assert_checkpoints</source>
          <target state="translated">trio.testing.assert_checkpoints</target>
        </trans-unit>
        <trans-unit id="9c718b50763cbe624ce844bcd1fb34055b88978b" translate="yes" xml:space="preserve">
          <source>trio.testing.assert_no_checkpoints</source>
          <target state="translated">trio.testing.assert_no_checkpoints</target>
        </trans-unit>
        <trans-unit id="4adff96a56905a89266266b118444d17dd990660" translate="yes" xml:space="preserve">
          <source>trio.testing.check_half_closeable_stream</source>
          <target state="translated">trio.testing.check_half_closeable_stream</target>
        </trans-unit>
        <trans-unit id="c6ff424fc6609ac14aef16404ba31a794ae50f98" translate="yes" xml:space="preserve">
          <source>trio.testing.check_one_way_stream</source>
          <target state="translated">trio.testing.check_one_way_stream</target>
        </trans-unit>
        <trans-unit id="1ce5db93782fcbbdacd8b1898b6e8f78d05147be" translate="yes" xml:space="preserve">
          <source>trio.testing.check_two_way_stream</source>
          <target state="translated">trio.testing.check_two_way_stream</target>
        </trans-unit>
        <trans-unit id="2ea199b82dc9ed1c55772bcc59395bf0a63a2c90" translate="yes" xml:space="preserve">
          <source>trio.testing.lockstep_stream_one_way_pair</source>
          <target state="translated">trio.testing.lockstep_stream_one_way_pair</target>
        </trans-unit>
        <trans-unit id="4f482e5581843d6fdea49168a33170f74899f248" translate="yes" xml:space="preserve">
          <source>trio.testing.lockstep_stream_pair</source>
          <target state="translated">trio.testing.lockstep_stream_pair</target>
        </trans-unit>
        <trans-unit id="812cb007aec68e83d6798c6a07500344f3ca38b9" translate="yes" xml:space="preserve">
          <source>trio.testing.memory_stream_one_way_pair</source>
          <target state="translated">trio.testing.memory_stream_one_way_pair</target>
        </trans-unit>
        <trans-unit id="16740f30ecc2c1ec4a0f75af7d41105184c7940b" translate="yes" xml:space="preserve">
          <source>trio.testing.memory_stream_pair</source>
          <target state="translated">trio.testing.memory_stream_pair</target>
        </trans-unit>
        <trans-unit id="9077b8c3807aa1d8abd7ecdbe3c9f052ea0a28b8" translate="yes" xml:space="preserve">
          <source>trio.testing.memory_stream_pump</source>
          <target state="translated">trio.testing.memory_stream_pump</target>
        </trans-unit>
        <trans-unit id="8b5679a2c343981092aa9495a7b433975f4716a6" translate="yes" xml:space="preserve">
          <source>trio.testing.open_stream_to_socket_listener</source>
          <target state="translated">trio.testing.open_stream_to_socket_listener</target>
        </trans-unit>
        <trans-unit id="2310f43b2f9445fbdde08df9158d83fa55adaf62" translate="yes" xml:space="preserve">
          <source>trio.testing.trio_test</source>
          <target state="translated">trio.testing.trio_test</target>
        </trans-unit>
        <trans-unit id="259f49a373411ce1821a64964a22c465791ef4e1" translate="yes" xml:space="preserve">
          <source>trio.testing.wait_all_tasks_blocked</source>
          <target state="translated">trio.testing.wait_all_tasks_blocked</target>
        </trans-unit>
        <trans-unit id="ad3b9094ed7412841fe10f276208f7b7bca32ca8" translate="yes" xml:space="preserve">
          <source>trio.to_thread.current_default_thread_limiter</source>
          <target state="translated">trio.to_thread.current_default_thread_limiter</target>
        </trans-unit>
        <trans-unit id="05d38837582c0de3aa4b00ea69efc82e97686c7d" translate="yes" xml:space="preserve">
          <source>trio.to_thread.run_sync</source>
          <target state="translated">trio.to_thread.run_sync</target>
        </trans-unit>
        <trans-unit id="474d04e0727b8bc866bd723c9ceca3df99f4c09a" translate="yes" xml:space="preserve">
          <source>trio.wrap_file</source>
          <target state="translated">trio.wrap_file</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
