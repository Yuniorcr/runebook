<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="trio">
    <body>
      <group id="trio">
        <trans-unit id="3ebacba51b60d5a007ce59beb654e883261ff033" translate="yes" xml:space="preserve">
          <source>Memory channels are lightweight, cheap to allocate, and entirely in-memory. They don&amp;rsquo;t involve any operating-system resources, or any kind of serialization. They just pass Python objects directly between tasks (with a possible stop in an internal buffer along the way).</source>
          <target state="translated">메모리 채널은 가볍고 할당이 저렴하며 완전히 메모리 내입니다. 여기에는 운영 체제 리소스 나 직렬화가 포함되지 않습니다. 그들은 작업 사이에 직접 파이썬 객체를 전달합니다 (내부 버퍼에서 도중에 중단 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="3cb22c5e4eabc0e7d3ccf2b60e66f53421b63149" translate="yes" xml:space="preserve">
          <source>Module Index</source>
          <target state="translated">모듈 색인</target>
        </trans-unit>
        <trans-unit id="8d872704047e831df65df9aed5d46fc4c57e9bb3" translate="yes" xml:space="preserve">
          <source>Most errors coming from &lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/a&gt; are allowed to propagate out (crashing the server in the process). However, some errors &amp;ndash; those which indicate that the server is temporarily overloaded &amp;ndash; are handled specially. These are &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;s with one of the following errnos:</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt; &lt;code&gt;accept()&lt;/code&gt; &lt;/a&gt; 에서 발생하는 대부분의 오류 는 전파 될 수 있습니다 (프로세스에서 서버 충돌). 그러나 서버에 일시적으로 과부하가 걸렸음을 나타내는 일부 오류는 특수하게 처리됩니다. 이들은 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 입니다&lt;/a&gt;다음 오류 중 하나 .</target>
        </trans-unit>
        <trans-unit id="a8cd11a5ccaa1971cc54179d399d4e54a3915836" translate="yes" xml:space="preserve">
          <source>Most libraries for concurrent programming let you start new child tasks (or threads, or whatever) willy-nilly, whenever and where-ever you feel like it. Trio is a bit different: you can&amp;rsquo;t start a child task unless you&amp;rsquo;re prepared to be a responsible parent. The way you demonstrate your responsibility is by creating a nursery:</source>
          <target state="translated">동시 프로그래밍을위한 대부분의 라이브러리를 사용하면 언제 어디서나 새로운 자식 작업 (또는 스레드 등)을 시작할 수 있습니다. Trio는 약간 다릅니다. 책임있는 부모가 될 준비가되어 있지 않으면 하위 작업을 시작할 수 없습니다. 당신의 책임을 보여주는 방법은 보육원을 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="faa7a87e100ccbf148f4d32180dde3f6a74122cc" translate="yes" xml:space="preserve">
          <source>Most low-level operations in Trio provide a guarantee: if they raise &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;trio.Cancelled&lt;/code&gt;&lt;/a&gt;, this means that they had no effect, so the system remains in a known state. This is &lt;strong&gt;not true&lt;/strong&gt; for &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt;. If this operation raises &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;trio.Cancelled&lt;/code&gt;&lt;/a&gt; (or any other exception for that matter), then it may have sent some, all, or none of the requested data, and there is no way to know which.</source>
          <target state="translated">Trio의 대부분의 하위 수준 작업은 보증을 제공합니다. &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;trio.Cancelled&lt;/code&gt; &lt;/a&gt; 를 올리면 아무런 효과가 없으므로 시스템이 알려진 상태로 유지됩니다. 이것은 &lt;strong&gt;사실이 아니다&lt;/strong&gt; 에 대한 &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; . 이 작업에서 &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;trio.Cancelled&lt;/code&gt; &lt;/a&gt; (또는 해당 사안의 다른 예외)가 발생하면 요청 된 데이터 중 일부 또는 전부를 보내거나 보내지 않았을 수 있으며 어떤 방법을 알 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="93b72a6b4349c6293f75d57aad8d0127982f3ec5" translate="yes" xml:space="preserve">
          <source>Most users won&amp;rsquo;t need this, but it may be useful on cleanup paths where you can&amp;rsquo;t afford to block, or if you want to close a resource and don&amp;rsquo;t care about handling it gracefully. For example, if &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; encounters an error and cannot perform its own graceful close, then there&amp;rsquo;s no point in waiting to gracefully shut down the underlying transport either, so it calls &lt;code&gt;await
aclose_forcefully(self.transport_stream)&lt;/code&gt;.</source>
          <target state="translated">대부분의 사용자는 이것을 필요로하지 않지만, 차단할 여유가없는 정리 경로 나 리소스를 닫고 정상적으로 처리하는 데 신경 쓰지 않는 정리 경로에 유용 할 수 있습니다. 예를 들어, &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 에 오류가 발생하여 고유 한 닫기를 수행 할 수없는 경우 기본 전송을 정상적으로 종료하기를 &lt;code&gt;await aclose_forcefully(self.transport_stream)&lt;/code&gt; 호출합니다. .</target>
        </trans-unit>
        <trans-unit id="263333d23c256397b1932a66d3b96bed36f57e27" translate="yes" xml:space="preserve">
          <source>Move all parked tasks from one &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt;&lt;code&gt;ParkingLot&lt;/code&gt;&lt;/a&gt; object to another.</source>
          <target state="translated">하나의 &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt; &lt;code&gt;ParkingLot&lt;/code&gt; &lt;/a&gt; 에서 모든 주차 된 작업 이동 객체에서 다른 객체로 .</target>
        </trans-unit>
        <trans-unit id="619690fbed77efc44030c3504079aab00d9bb921" translate="yes" xml:space="preserve">
          <source>Move all parked tasks from one &lt;a href=&quot;#trio.lowlevel.ParkingLot&quot;&gt;&lt;code&gt;ParkingLot&lt;/code&gt;&lt;/a&gt; object to another.</source>
          <target state="translated">주차 된 모든 작업을 한 &lt;a href=&quot;#trio.lowlevel.ParkingLot&quot;&gt; &lt;code&gt;ParkingLot&lt;/code&gt; &lt;/a&gt; 개체에서 다른 개체로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="d7821f30476ccc057b781233fe6a409ab7b1f821" translate="yes" xml:space="preserve">
          <source>Move parked tasks from one &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt;&lt;code&gt;ParkingLot&lt;/code&gt;&lt;/a&gt; object to another.</source>
          <target state="translated">하나의 &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt; &lt;code&gt;ParkingLot&lt;/code&gt; &lt;/a&gt; 에서 주차 된 작업 이동 객체에서 다른 객체로 .</target>
        </trans-unit>
        <trans-unit id="7fa5abfcacdb7e2dfa0086da84bb92b17fb12649" translate="yes" xml:space="preserve">
          <source>Move parked tasks from one &lt;a href=&quot;#trio.lowlevel.ParkingLot&quot;&gt;&lt;code&gt;ParkingLot&lt;/code&gt;&lt;/a&gt; object to another.</source>
          <target state="translated">주차 된 작업을 한 &lt;a href=&quot;#trio.lowlevel.ParkingLot&quot;&gt; &lt;code&gt;ParkingLot&lt;/code&gt; &lt;/a&gt; 개체에서 다른 개체로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="4e51ee94727e41fe8b7acbe58d00c5e01c684e5b" translate="yes" xml:space="preserve">
          <source>Multi-Core/Multiprocessing</source>
          <target state="translated">Multi-Core/Multiprocessing</target>
        </trans-unit>
        <trans-unit id="8bad03d4f386e821713ff697a351c0c7fddba714" translate="yes" xml:space="preserve">
          <source>Networking with Trio</source>
          <target state="translated">Trio와의 네트워킹</target>
        </trans-unit>
        <trans-unit id="b4930210ef1616963a4cb50a56f5073c0e556155" translate="yes" xml:space="preserve">
          <source>No need to think about threads: your Trio code runs in the same thread as the host event loop, so you can freely call sync Trio APIs from the host, and call sync host APIs from Trio. For example, if you&amp;rsquo;re making a GUI app with Qt as the host loop, then making a &lt;a href=&quot;https://doc.qt.io/qt-5/qpushbutton.html&quot;&gt;cancel button&lt;/a&gt; and connecting it to a &lt;a href=&quot;reference-core#trio.CancelScope&quot;&gt;&lt;code&gt;trio.CancelScope&lt;/code&gt;&lt;/a&gt; is as easy as writing:</source>
          <target state="translated">스레드에 대해 생각할 필요가 없습니다. Trio 코드는 호스트 이벤트 루프와 동일한 스레드에서 실행되므로 호스트에서 동기화 Trio API를 자유롭게 호출하고 Trio에서 동기화 호스트 API를 호출 할 수 있습니다. 예를 들어 Qt를 호스트 루프로 사용하여 GUI 앱을 만드는 경우 &lt;a href=&quot;https://doc.qt.io/qt-5/qpushbutton.html&quot;&gt;취소 버튼&lt;/a&gt; 을 만들어 &lt;a href=&quot;reference-core#trio.CancelScope&quot;&gt; &lt;code&gt;trio.CancelScope&lt;/code&gt; &lt;/a&gt; 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="5ef93032cd6cb3e1deb49d648d00e034030e5fed" translate="yes" xml:space="preserve">
          <source>Normally, a Trio task doesn&amp;rsquo;t exit until its coroutine object exits. When you call this function, Trio acts like the coroutine object just exited and the task terminates with the given outcome. This is useful if you want to permanently switch the coroutine object over to a different coroutine runner.</source>
          <target state="translated">일반적으로 Trio 작업은 코 루틴 개체가 종료 될 때까지 종료되지 않습니다. 이 함수를 호출하면 Trio는 방금 종료 된 코 루틴 객체처럼 작동하고 작업은 주어진 결과로 종료됩니다. 이것은 코 루틴 오브젝트를 다른 코 루틴 러너로 영구적으로 전환하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="498e98b1248914319c5ba185502949174d8f34bb" translate="yes" xml:space="preserve">
          <source>Normally, in Python, only one thing happens at a time, which means that only one thing can wrong at a time. Trio has no such limitation. Consider code like:</source>
          <target state="translated">일반적으로 Python에서는 한 번에 한 가지만 발생하므로 한 번에 한 가지만 잘못 될 수 있습니다. 트리오에는 그러한 제한이 없습니다. 다음과 같은 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="83d1bdb0177297f4b3942b5656e2acef994da375" translate="yes" xml:space="preserve">
          <source>Not constructed directly, use &lt;a href=&quot;#trio.open_nursery&quot;&gt;&lt;code&gt;open_nursery&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">직접 구성하지 않고 대신 &lt;a href=&quot;#trio.open_nursery&quot;&gt; &lt;code&gt;open_nursery&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="eadd2611bf484c2f1c8acb474416269466aa9dc7" translate="yes" xml:space="preserve">
          <source>Not implemented yet!</source>
          <target state="translated">아직 구현되지 않았습니다!</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="c005918e9288af566376fbbfea029bf8b6679638" translate="yes" xml:space="preserve">
          <source>Note that &amp;ldquo;closed&amp;rdquo; here means that &lt;em&gt;your&lt;/em&gt; code closed the resource, generally by calling a method with a name like &lt;code&gt;close&lt;/code&gt; or &lt;code&gt;aclose&lt;/code&gt;, or by exiting a context manager. If a problem arises elsewhere &amp;ndash; for example, because of a network failure, or because a remote peer closed their end of a connection &amp;ndash; then that should be indicated by a different exception class, like &lt;a href=&quot;#trio.BrokenResourceError&quot;&gt;&lt;code&gt;BrokenResourceError&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; subclass.</source>
          <target state="translated">여기서 &quot;닫힘&quot;은 일반적으로 &lt;code&gt;close&lt;/code&gt; 또는 &lt;code&gt;aclose&lt;/code&gt; 와 같은 이름의 메소드를 호출 하거나 컨텍스트 관리자를 종료 &lt;em&gt;하여&lt;/em&gt; 코드가 자원을 닫았다는 것을 의미합니다 . 네트워크 장애로 인해 또는 원격 피어가 연결 종료를 &lt;a href=&quot;#trio.BrokenResourceError&quot;&gt; &lt;code&gt;BrokenResourceError&lt;/code&gt; &lt;/a&gt; 등의 문제가 발생하면 BrokenResourceError 또는 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 하위 클래스와 같은 다른 예외 클래스로 표시되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e4c5fde44cdcbb0229d2ec83868918f591012895" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;cushion&lt;/code&gt; is measured in &lt;em&gt;real&lt;/em&gt; time, not the Trio clock time.</source>
          <target state="translated">주의 &lt;code&gt;cushion&lt;/code&gt; 측정되는 &lt;em&gt;실제&lt;/em&gt; 시간이 아닌 트리오 시계 시간.</target>
        </trans-unit>
        <trans-unit id="c2f474f246c27fafa3dfbf010e4d2f00c8ffe806" translate="yes" xml:space="preserve">
          <source>Note that for efficiency, the core run loop only checks for expired deadlines every once in a while. This means that in certain cases there may be a short delay between when the clock says the deadline should have expired, and when checkpoints start raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;. This is a very obscure corner case that you&amp;rsquo;re unlikely to notice, but we document it for completeness. (If this &lt;em&gt;does&lt;/em&gt; cause problems for you, of course, then &lt;a href=&quot;https://github.com/python-trio/trio/issues&quot;&gt;we want to know!&lt;/a&gt;)</source>
          <target state="translated">효율성을 위해 코어 실행 루프는 만료 된 마감 시간 만 가끔 확인합니다. 이것은 어떤 경우에는 시계가 마감 기한이 만료되었다고 말하는 시점과 체크 포인트가 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 시작하는 시점 사이에 약간의 지연이있을 수 있음을 의미합니다 . 이것은 눈에 잘 띄지 않는 매우 모호한 경우이지만 완전성을 위해 문서화합니다. 이 경우 ( &lt;em&gt;않는&lt;/em&gt; 당신을 위해 문제를 일으킬 물론, 그때 &lt;a href=&quot;https://github.com/python-trio/trio/issues&quot;&gt;우리는 알고 싶다!&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a4da239427acde2c8d842bd9203aa10f330974e5" translate="yes" xml:space="preserve">
          <source>Note that if you leave the &lt;code&gt;with&lt;/code&gt; block while the iterator has unextracted signals still pending inside it, then they will be re-delivered using Python&amp;rsquo;s regular signal handling logic. This avoids a race condition when signals arrives just before we exit the &lt;code&gt;with&lt;/code&gt; block.</source>
          <target state="translated">반복자가 추출되지 않은 신호가 여전히 보류중인 동안 &lt;code&gt;with&lt;/code&gt; 블록을 벗어나면 Python의 정규 신호 처리 로직을 사용하여 다시 전달됩니다. 이렇게하면 신호가 종료되기 직전에 신호가 도착할 때 경쟁 조건을 피할 수 &lt;code&gt;with&lt;/code&gt; 블록을 .</target>
        </trans-unit>
        <trans-unit id="5e8529b79533f0b11f8453e7f61b578bff6ccac8" translate="yes" xml:space="preserve">
          <source>Note that if you pass an IPv4 &lt;code&gt;local_address&lt;/code&gt;, then you won&amp;rsquo;t be able to connect to IPv6 hosts, and vice-versa. If you want to take advantage of this to force the use of IPv4 or IPv6 without specifying an exact source address, you can use the IPv4 wildcard address &lt;code&gt;local_address=&quot;0.0.0.0&quot;&lt;/code&gt;, or the IPv6 wildcard address &lt;code&gt;local_address=&quot;::&quot;&lt;/code&gt;.</source>
          <target state="translated">IPv4 &lt;code&gt;local_address&lt;/code&gt; 를 전달하면 IPv6 호스트에 연결할 수 없으며 그 반대의 경우도 마찬가지입니다. 이를 활용하여 정확한 소스 주소를 지정하지 않고 IPv4 또는 IPv6을 강제로 사용하려면 IPv4 와일드 카드 주소 &lt;code&gt;local_address=&quot;0.0.0.0&quot;&lt;/code&gt; 또는 IPv6 와일드 카드 주소 &lt;code&gt;local_address=&quot;::&quot;&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="712bd61d427cff2f726afa6001462d20b944b4f7" translate="yes" xml:space="preserve">
          <source>Note that it actually loads the whole directory list into memory immediately, during the initial call. (See &lt;a href=&quot;https://github.com/python-trio/trio/issues/501&quot;&gt;issue #501&lt;/a&gt; for discussion.)</source>
          <target state="translated">실제로는 초기 호출 중에 전체 디렉토리 목록을 메모리에 즉시로드합니다. ( 토론 은 &lt;a href=&quot;https://github.com/python-trio/trio/issues/501&quot;&gt;문제 # 501&lt;/a&gt; 을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="9ee1f76d9b8ad0707603fa7bdf72c7513bc021f3" translate="yes" xml:space="preserve">
          <source>Note that on Trio (unlike the standard library &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt;&lt;code&gt;subprocess.Popen&lt;/code&gt;&lt;/a&gt;), &lt;code&gt;process.poll()&lt;/code&gt; and &lt;code&gt;process.returncode&lt;/code&gt; always give the same result. See &lt;a href=&quot;#trio.Process.returncode&quot;&gt;&lt;code&gt;returncode&lt;/code&gt;&lt;/a&gt; for more details. This method is only included to make it easier to port code from &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Trio에서 (표준 라이브러리 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt; &lt;code&gt;subprocess.Popen&lt;/code&gt; &lt;/a&gt; 과 달리 ) &lt;code&gt;process.poll()&lt;/code&gt; 및 &lt;code&gt;process.returncode&lt;/code&gt; 는 항상 동일한 결과를 제공합니다. 자세한 내용은 &lt;a href=&quot;#trio.Process.returncode&quot;&gt; &lt;code&gt;returncode&lt;/code&gt; &lt;/a&gt; 를 참조하십시오. 이 메서드는 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 에서 코드를 쉽게 이식 할 수 있도록하기 위해서만 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="18074fc1649e3851e18407e48fba948b511fbd36" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt; &amp;ldquo;takes ownership&amp;rdquo; of the given socket; closing the &lt;a href=&quot;#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt; will also close the socket.</source>
          <target state="translated">있습니다 &lt;a href=&quot;#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; 가&lt;/a&gt; 주어진 소켓의 &quot;소유권을&quot;; 닫는 &lt;a href=&quot;#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; 은&lt;/a&gt; 또한 소켓을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="2ad4e8916ad84553a99fb9d5ed08077c69f39ffa" translate="yes" xml:space="preserve">
          <source>Note that the scheduler has the option of ignoring this and continuing to run the current task if it decides this is appropriate (e.g. for increased efficiency).</source>
          <target state="translated">스케줄러는이를 무시하고 현재 작업이 적절하다고 판단되면 (예 : 효율성 향상) 현재 작업을 계속 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a870766bee2cab11ad647d758a862b70449e3239" translate="yes" xml:space="preserve">
          <source>Note that these APIs are actually in &lt;a href=&quot;reference-io#module-trio.socket&quot;&gt;&lt;code&gt;trio.socket&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;trio.abc&lt;/code&gt;, but we document them here because they&amp;rsquo;re primarily intended for testing.</source>
          <target state="translated">이 API는 실제로 &lt;a href=&quot;reference-io#module-trio.socket&quot;&gt; &lt;code&gt;trio.socket&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;trio.abc&lt;/code&gt; 에 있지만 주로 테스트 용이므로 여기에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f6717e388dfea4f31cd0847c699c3d8b947978c" translate="yes" xml:space="preserve">
          <source>Note that this function is async, and that it acts as a checkpoint, but unlike most async functions it cannot block indefinitely (at least, assuming the underlying resource object is correctly implemented).</source>
          <target state="translated">이 함수는 비동기식이며 검사 점 역할을하지만 대부분의 비동기식 함수와 달리 무한히 차단할 수는 없습니다 (적어도 기본 리소스 개체가 올바르게 구현되었다고 가정).</target>
        </trans-unit>
        <trans-unit id="60263bbd81e421eab5c9b77a0bb97880024cfdea" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; an async function and you don&amp;rsquo;t use await when calling it. It sets up the new task, but then returns immediately, &lt;em&gt;before&lt;/em&gt; it has a chance to run. The new task won&amp;rsquo;t actually get a chance to do anything until some later point when you execute a checkpoint and the scheduler decides to run it. If you want to run a function and immediately wait for its result, then you don&amp;rsquo;t need a nursery; just use &lt;code&gt;await async_fn(*args)&lt;/code&gt;. If you want to wait for the task to initialize itself before continuing, see &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 것을 참고 &lt;em&gt;하지&lt;/em&gt; 비동기 기능을 호출 할 때 await를 사용하지 마십시오. 새 작업을 설정 한 다음 실행 기회를 갖기 &lt;em&gt;전에&lt;/em&gt; 즉시 반환 합니다. 새 작업은 실제로 검사 점을 실행하고 스케줄러가이를 실행하기로 결정한 시점이 될 때까지 실제로 작업을 수행 할 수 없습니다. 함수를 실행하고 결과를 즉시 기다리려면 보육이 필요하지 않습니다. 단지 사용 &lt;code&gt;await async_fn(*args)&lt;/code&gt; . 계속하기 전에 작업이 초기화 될 때까지 기다리려면 &lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e596896727edc23e1453160d700101f2cccdb2ec" translate="yes" xml:space="preserve">
          <source>Note that this is a single 30 second timeout for the entire body of the &lt;code&gt;with&lt;/code&gt; statement. This is different from what you might have seen with other Python libraries, where timeouts often refer to something &lt;a href=&quot;http://docs.python-requests.org/en/master/user/quickstart/#timeouts&quot;&gt;more complicated&lt;/a&gt;. We think this way is easier to reason about.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 문의 전체 본문에 대한 단일 30 초 시간 초과입니다 . 이것은 다른 파이썬 라이브러리에서 볼 수있는 것과 다릅니다. 시간 초과는 종종 &lt;a href=&quot;http://docs.python-requests.org/en/master/user/quickstart/#timeouts&quot;&gt;더 복잡한&lt;/a&gt; 것을 나타냅니다. . 우리는이 방법이 추론하기 쉽다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="74f2efef07bc9eb1b0dde311d07fb69fa9029a53" translate="yes" xml:space="preserve">
          <source>Note that this is a single 30 second timeout for the entire body of the &lt;code&gt;with&lt;/code&gt; statement. This is different from what you might have seen with other Python libraries, where timeouts often refer to something &lt;a href=&quot;https://requests.kennethreitz.org/en/master/user/quickstart/#timeouts&quot;&gt;more complicated&lt;/a&gt;. We think this way is easier to reason about.</source>
          <target state="translated">이는 &lt;code&gt;with&lt;/code&gt; 문의 전체 본문에 대한 단일 30 초 제한 시간입니다 . 이것은 시간 초과가 종종 &lt;a href=&quot;https://requests.kennethreitz.org/en/master/user/quickstart/#timeouts&quot;&gt;더 복잡한&lt;/a&gt; 것을 참조하는 다른 Python 라이브러리에서 보았던 것과는 다릅니다 . 우리는이 방법이 추론하기 더 쉽다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="d90917fbab7be987474e0660b08f23d296f2c615" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt;&lt;code&gt;trio.socket.socket()&lt;/code&gt;&lt;/a&gt;, this does not take a &lt;code&gt;fileno=&lt;/code&gt; argument. If a &lt;code&gt;fileno=&lt;/code&gt; is specified, then &lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt;&lt;code&gt;trio.socket.socket()&lt;/code&gt;&lt;/a&gt; returns a regular Trio socket object instead of calling this method.</source>
          <target state="translated">&lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt; &lt;code&gt;trio.socket.socket()&lt;/code&gt; &lt;/a&gt; 과 달리 &lt;code&gt;fileno=&lt;/code&gt; 인수를 사용 하지 않습니다 . 경우 &lt;code&gt;fileno=&lt;/code&gt; 지정하면 &lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt; &lt;code&gt;trio.socket.socket()&lt;/code&gt; &lt;/a&gt; 대신이 방법을 호출하는 일반 트리오 소켓 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ee9f1e467c615fa7fe75945105dc0ba02d240448" translate="yes" xml:space="preserve">
          <source>Note that what matters here is the scopes that were active when &lt;a href=&quot;#trio.open_nursery&quot;&gt;&lt;code&gt;open_nursery()&lt;/code&gt;&lt;/a&gt; was called, &lt;em&gt;not&lt;/em&gt; the scopes active when &lt;code&gt;start_soon&lt;/code&gt; is called. So for example, the timeout block below does nothing at all:</source>
          <target state="translated">여기서 중요한 것은 &lt;code&gt;start_soon&lt;/code&gt; 이 호출 될 때 활성화 된 범위가 &lt;em&gt;아니라 &lt;/em&gt;&lt;a href=&quot;#trio.open_nursery&quot;&gt; &lt;code&gt;open_nursery()&lt;/code&gt; &lt;/a&gt; 가 호출 되었을 때 활성화 된 범위 입니다. 예를 들어 아래의 타임 아웃 블록은 아무 것도 수행하지 않습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c0dd16afc9aa65302712b5fe96789de465a014cf" translate="yes" xml:space="preserve">
          <source>Note that you&amp;rsquo;ll need to save the current &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object to later resume; you can retrieve it with &lt;a href=&quot;#trio.hazmat.current_task&quot;&gt;&lt;code&gt;current_task()&lt;/code&gt;&lt;/a&gt;. You can also use this &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object to retrieve the coroutine object &amp;ndash; see &lt;a href=&quot;#trio.hazmat.Task.coro&quot;&gt;&lt;code&gt;Task.coro&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">나중에 다시 시작 하려면 현재 &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 개체를 저장해야합니다 . &lt;a href=&quot;#trio.hazmat.current_task&quot;&gt; &lt;code&gt;current_task()&lt;/code&gt; &lt;/a&gt; 검색 할 수 있습니다 . 이 &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 객체를 사용 하여 코 루틴 객체를 검색 할 수도 있습니다 ( &lt;a href=&quot;#trio.hazmat.Task.coro&quot;&gt; &lt;code&gt;Task.coro&lt;/code&gt; &lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="d6c0b28dbde137e07a8b2672fcb623eb89d90210" translate="yes" xml:space="preserve">
          <source>Note that you&amp;rsquo;ll need to save the current &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object to later resume; you can retrieve it with &lt;a href=&quot;#trio.lowlevel.current_task&quot;&gt;&lt;code&gt;current_task()&lt;/code&gt;&lt;/a&gt;. You can also use this &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object to retrieve the coroutine object &amp;ndash; see &lt;a href=&quot;#trio.lowlevel.Task.coro&quot;&gt;&lt;code&gt;Task.coro&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">나중에 다시 시작 하려면 현재 &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 개체를 저장해야합니다 . &lt;a href=&quot;#trio.lowlevel.current_task&quot;&gt; &lt;code&gt;current_task()&lt;/code&gt; &lt;/a&gt; 검색 할 수 있습니다 . 이 &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 객체를 사용 하여 코 루틴 객체를 검색 할 수도 있습니다 ( &lt;a href=&quot;#trio.lowlevel.Task.coro&quot;&gt; &lt;code&gt;Task.coro&lt;/code&gt; &lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="b11c1cb9fa202d18d7a41126f3004fc8f01b7293" translate="yes" xml:space="preserve">
          <source>Notes on async generators</source>
          <target state="translated">비동기 생성기에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="fd0ce03c8decb818ff508ff8fee1d404e44208e2" translate="yes" xml:space="preserve">
          <source>Notice a small trick we use: the code in &lt;code&gt;main&lt;/code&gt; creates clone objects to pass into all the child tasks, and then closes the original objects using &lt;code&gt;async with&lt;/code&gt;. Another option is to pass clones into all-but-one of the child tasks, and then pass the original object into the last task, like:</source>
          <target state="translated">우리가 사용하는 작은 트릭에 주목하십시오. &lt;code&gt;main&lt;/code&gt; 의 코드는 모든 자식 작업에 전달할 복제 객체를 만든 다음 a &lt;code&gt;async with&lt;/code&gt; 사용하여 원본 객체를 닫습니다 . 또 다른 옵션은 클론을 하위 작업 중 하나에 모두 전달한 다음 다음과 같이 원본 개체를 마지막 작업에 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5d6fc1814d50a5f137f3e0720ddabca9f27c56cd" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;server&lt;/code&gt; opens a nursery and passes it to &lt;code&gt;new_connection_listener&lt;/code&gt;, and then &lt;code&gt;new_connection_listener&lt;/code&gt; is able to start new tasks as &amp;ldquo;siblings&amp;rdquo; of itself. Of course, in this case, we could just as well have written:</source>
          <target state="translated">통지 &lt;code&gt;server&lt;/code&gt; 보육을 열고에 전달 &lt;code&gt;new_connection_listener&lt;/code&gt; 다음과 &lt;code&gt;new_connection_listener&lt;/code&gt; 는 자신의 &quot;형제&quot;로 새로운 작업을 시작할 수 있습니다. 물론이 경우에도 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e37b67492b27cf2315618722132887747e63dd5f" translate="yes" xml:space="preserve">
          <source>Now suppose that the remote server stops responding, so our call to &lt;code&gt;await conn.send_hello_msg()&lt;/code&gt; hangs forever. Fortunately, we were clever enough to put a timeout around this code, so eventually the timeout will expire and &lt;code&gt;send_hello_msg&lt;/code&gt; will raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;. But then, in the &lt;code&gt;finally&lt;/code&gt; block, we make another blocking operation, which will also hang forever! At this point, if we were using &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html#module-asyncio&quot;&gt;&lt;code&gt;asyncio&lt;/code&gt;&lt;/a&gt; or another library with &amp;ldquo;edge-triggered&amp;rdquo; cancellation, we&amp;rsquo;d be in trouble: since our timeout already fired, it wouldn&amp;rsquo;t fire again, and at this point our application would lock up forever. But in Trio, this &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; happen: the &lt;code&gt;await
conn.send_goodbye_msg()&lt;/code&gt; call is still inside the cancelled block, so it will also raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이제 원격 서버가 응답을 &lt;code&gt;await conn.send_hello_msg()&lt;/code&gt; 호출 이 영원히 중단 된다고 가정합니다 . 다행 &lt;code&gt;send_hello_msg&lt;/code&gt; 코드 주위에 시간 초과를 설정하기에 충분히 영리했기 때문에 결국 시간 초과가 만료되고 send_hello_msg 가 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 시킵니다. 그러나 &lt;code&gt;finally&lt;/code&gt; 블록에서 다른 차단 작업을 수행하면 영원히 중단됩니다! 이 시점에서 &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html#module-asyncio&quot;&gt; &lt;code&gt;asyncio&lt;/code&gt; &lt;/a&gt; 또는&amp;ldquo;edge-triggered&amp;rdquo;취소와 함께 다른 라이브러리를 사용하는 경우 문제가 발생합니다. 이미 시간 초과가 발생했기 때문에 다시 시작되지 않으며이 시점에서 응용 프로그램이 영원히 잠기 게됩니다. . 그러나 Trio에서는 이러한 상황 이 발생 &lt;em&gt;하지 않습니다&lt;/em&gt; . &lt;code&gt;await conn.send_goodbye_msg()&lt;/code&gt; call은 여전히 ​​취소 된 블록 안에 있으므로 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="02c8f6d70943a7fac1506484bdd19fd986fc4dea" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;send&lt;/code&gt; calls wait for the &lt;code&gt;receive&lt;/code&gt; calls to finish, which forces the producer to slow down to match the consumer&amp;rsquo;s speed. (It might look strange that some values are reported as &amp;ldquo;Received&amp;rdquo; before they&amp;rsquo;re reported as &amp;ldquo;Sent&amp;rdquo;; this happens because the actual send/receive happen at the same time, so which line gets printed first is random.)</source>
          <target state="translated">이제 &lt;code&gt;send&lt;/code&gt; 통화는 &lt;code&gt;receive&lt;/code&gt; 통화가 완료 될 때까지 기다리 므로 생산자가 소비자의 속도에 맞춰 속도를 늦 춥니 다. (일부 값이 &quot;보냄&quot;으로보고되기 전에 &quot;수신 됨&quot;으로보고되는 것은 이상하게 보일 수 있습니다. 실제 전송 / 수신이 동시에 발생하기 때문에 어떤 행이 먼저 인쇄되는지는 임의적입니다.)</target>
        </trans-unit>
        <trans-unit id="4e56b32190bfb5370d26b04e4a28ca4757d98a90" translate="yes" xml:space="preserve">
          <source>Now try replacing &lt;code&gt;open_memory_channel(math.inf)&lt;/code&gt; with &lt;code&gt;open_memory_channel(0)&lt;/code&gt;, and run it again. We get output like:</source>
          <target state="translated">이제 &lt;code&gt;open_memory_channel(math.inf)&lt;/code&gt; 을 &lt;code&gt;open_memory_channel(0)&lt;/code&gt; 바꾸고 다시 실행하십시오. 우리는 다음과 같은 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="adc4ba48cd9ba8dfc30133e2521b610c7b62038b" translate="yes" xml:space="preserve">
          <source>Now, here&amp;rsquo;s the problem: how does the logging code know what the request identifier is? One approach would be to explicitly pass it around to every function that might want to emit logs&amp;hellip; but that&amp;rsquo;s basically every function, because you never know when you might need to add a &lt;code&gt;log.debug(...)&lt;/code&gt; call to some utility function buried deep in the call stack, and when you&amp;rsquo;re in the middle of a debugging a nasty problem that last thing you want is to have to stop first and refactor everything to pass through the request identifier! Sometimes this is the right solution, but other times it would be much more convenient if we could store the identifier in a global variable, so that the logging function could look it up whenever it needed it. Except&amp;hellip; a global variable can only have one value at a time, so if we have multiple handlers running at once then this isn&amp;rsquo;t going to work. What we need is something that&amp;rsquo;s &lt;em&gt;like&lt;/em&gt; a global variable, but that can have different values depending on which request handler is accessing it.</source>
          <target state="translated">문제는 다음과 같습니다. 로깅 코드는 요청 식별자가 무엇인지 어떻게 알 수 있습니까? 한 가지 접근 방식은 로그를 내보내려는 모든 함수에 명시 적으로 전달하는 것입니다.하지만 기본적으로 모든 함수입니다. &lt;code&gt;log.debug(...)&lt;/code&gt; 호출 스택에 깊이 묻혀있는 유틸리티 함수를 호출하십시오. 디버깅 중일 때 마지막으로 원하는 불쾌한 문제는 먼저 중지하고 요청 식별자를 통과하기 위해 모든 것을 리팩터링해야합니다! 때로는 이것이 올바른 해결책이지만 때로는 전역 변수에 식별자를 저장하여 로깅 기능이 필요할 때마다 찾아 볼 수 있으면 훨씬 편리합니다. 예외적으로 전역 변수는 한 번에 하나의 값만 가질 수 있으므로 한 번에 여러 핸들러가 실행되면 작동하지 않습니다. 우리에게 필요한 것은 무언가이다 &lt;em&gt;처럼&lt;/em&gt; 전역 변수,하지만 요청 처리기가 액세스하는에 따라 다른 값을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18a97ec0e1695e28d7a8fe2a6572b4583a7001e4" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s try setting a small but nonzero buffer size, like &lt;code&gt;open_memory_channel(3)&lt;/code&gt;. what do you think will happen?</source>
          <target state="translated">이제 &lt;code&gt;open_memory_channel(3)&lt;/code&gt; 과 같이 작지만 0이 아닌 버퍼 크기를 설정해 봅시다 . 당신은 어떻게 될 것이라고 생각합니까?</target>
        </trans-unit>
        <trans-unit id="fd5e18f90249b8669806f325c583b198ada3d939" translate="yes" xml:space="preserve">
          <source>Nurseries and spawning</source>
          <target state="translated">보육원 및 산란</target>
        </trans-unit>
        <trans-unit id="16d7703fe16bb0df95242d1426109cc4459c2e07" translate="yes" xml:space="preserve">
          <source>Nurseries ensure the absence of orphaned Tasks, since all running tasks will belong to an open Nursery.</source>
          <target state="translated">보육원은 실행중인 모든 작업이 열린 보육원에 속하기 때문에 고아 작업이 없는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="20dca5710da376ad5a814a1da5182bc19a89b8b0" translate="yes" xml:space="preserve">
          <source>Objects that implement this interface can be used as async context managers, i.e., you can write:</source>
          <target state="translated">이 인터페이스를 구현하는 객체는 비동기 컨텍스트 관리자로 사용될 수 있습니다. 즉, 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b940f5465fbd6a31841a4291aeea0108a4130ad" translate="yes" xml:space="preserve">
          <source>Of course real producers and consumers are usually more complicated than this, and in some situations, a modest amount of buffering might improve throughput. But too much buffering wastes memory and increases latency, so if you want to tune your application you should experiment to see what value works best for you.</source>
          <target state="translated">물론 실제 생산자와 소비자는 일반적으로 이보다 더 복잡하며 경우에 따라 약간의 버퍼링으로 인해 처리량이 향상 될 수 있습니다. 그러나 버퍼링이 너무 많으면 메모리가 낭비되고 대기 시간이 길어 지므로 응용 프로그램을 조정하려면 어떤 값이 가장 적합한 지 실험 해보아야합니다.</target>
        </trans-unit>
        <trans-unit id="e5af8fe33a8522754410781a2a311fe81b69b085" translate="yes" xml:space="preserve">
          <source>Of course we don&amp;rsquo;t generally like it when programs hang. What happened? The problem is that the producer sent 3 messages and then exited, but the consumer has no way to tell that the producer is gone: for all it knows, another message might be coming along any moment. So it hangs forever waiting for the 4th message.</source>
          <target state="translated">물론 우리는 프로그램이 중단 될 때 일반적으로 그것을 좋아하지 않습니다. 어떻게 된 거예요? 문제는 생산자가 3 개의 메시지를 보낸 다음 종료했지만 소비자는 생산자가 사라 졌다는 것을 알 수있는 방법이 없다는 것입니다. 그래서 네 번째 메시지를 영원히 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0326ef61ce31f93eca90a3c1fc454c143eaee8a" translate="yes" xml:space="preserve">
          <source>Of course, if you really want to make another blocking call in your cleanup handler, Trio will let you; it&amp;rsquo;s trying to prevent you from accidentally shooting yourself in the foot. Intentional foot-shooting is no problem (or at least &amp;ndash; it&amp;rsquo;s not Trio&amp;rsquo;s problem). To do this, create a new scope, and set its &lt;a href=&quot;#trio.CancelScope.shield&quot;&gt;&lt;code&gt;shield&lt;/code&gt;&lt;/a&gt; attribute to &lt;a href=&quot;https://docs.python.org/3/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">물론 정리 처리기에서 또 다른 차단 호출을하려면 Trio가 허용합니다. 실수로 발에 총을 쏘는 것을 막으려 고합니다. 의도적으로 발을 쏘는 것은 문제가되지 않습니다 (적어도 트리오의 문제는 아닙니다). 이렇게하려면 새 범위를 만들고 &lt;a href=&quot;#trio.CancelScope.shield&quot;&gt; &lt;code&gt;shield&lt;/code&gt; &lt;/a&gt; 속성을 &lt;a href=&quot;https://docs.python.org/3/library/constants.html#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; 로 설정하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f3053b0a18145d078b6fd276d56918a38b129cb0" translate="yes" xml:space="preserve">
          <source>Of course, this rule doesn&amp;rsquo;t apply to APIs that need to impose internal timeouts. For example, if you write a &lt;code&gt;start_http_server&lt;/code&gt; function, then you probably should give your caller some way to configure timeouts on individual requests.</source>
          <target state="translated">물론이 규칙은 내부 시간 초과를 적용해야하는 API에는 적용되지 않습니다. 예를 들어 &lt;code&gt;start_http_server&lt;/code&gt; 함수 를 작성하면 호출자에게 개별 요청에 대한 시간 종료를 구성 할 수있는 방법을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="62c759159e0d57c77aff616dd1156fb73f75ed37" translate="yes" xml:space="preserve">
          <source>Often there is no need to create &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; object. Trio already includes &lt;a href=&quot;#trio.Nursery.cancel_scope&quot;&gt;&lt;code&gt;cancel_scope&lt;/code&gt;&lt;/a&gt; attribute in a task-related &lt;a href=&quot;#trio.Nursery&quot;&gt;&lt;code&gt;Nursery&lt;/code&gt;&lt;/a&gt; object. We will cover nurseries later in the manual.</source>
          <target state="translated">종종 &lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; &lt;/a&gt; 개체 를 만들 필요가 없습니다 . Trio는 이미 작업 관련 &lt;a href=&quot;#trio.Nursery&quot;&gt; &lt;code&gt;Nursery&lt;/code&gt; &lt;/a&gt; 개체 에 &lt;a href=&quot;#trio.Nursery.cancel_scope&quot;&gt; &lt;code&gt;cancel_scope&lt;/code&gt; &lt;/a&gt; 속성을 포함하고 있습니다 . 매뉴얼의 뒷부분에서 보육원에 대해 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="7fd62c1a5622fc073c28a93c33b57b2cdd713f8e" translate="yes" xml:space="preserve">
          <source>On UNIX, &lt;code&gt;sig&lt;/code&gt; may be any signal defined in the &lt;a href=&quot;https://docs.python.org/3/library/signal.html#module-signal&quot;&gt;&lt;code&gt;signal&lt;/code&gt;&lt;/a&gt; module, such as &lt;code&gt;signal.SIGINT&lt;/code&gt; or &lt;code&gt;signal.SIGTERM&lt;/code&gt;. On Windows, it may be anything accepted by the standard library &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.send_signal&quot;&gt;&lt;code&gt;subprocess.Popen.send_signal()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">UNIX에서 &lt;code&gt;sig&lt;/code&gt; 는 &lt;code&gt;signal.SIGINT&lt;/code&gt; 또는 &lt;code&gt;signal.SIGTERM&lt;/code&gt; 과 같이 &lt;a href=&quot;https://docs.python.org/3/library/signal.html#module-signal&quot;&gt; &lt;code&gt;signal&lt;/code&gt; &lt;/a&gt; 모듈에 정의 된 모든 신호일 수 있습니다 . Windows에서는 표준 라이브러리 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.send_signal&quot;&gt; &lt;code&gt;subprocess.Popen.send_signal()&lt;/code&gt; &lt;/a&gt; 에서 허용하는 것이 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf6f1410af029c2960985ac658c1c9ea77c283a7" translate="yes" xml:space="preserve">
          <source>On UNIX, this is equivalent to &lt;code&gt;send_signal(signal.SIGKILL)&lt;/code&gt;. On Windows, it calls &lt;code&gt;TerminateProcess&lt;/code&gt;. In both cases, the process cannot prevent itself from being killed, but the termination will be delivered asynchronously; use &lt;a href=&quot;#trio.Process.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; if you want to ensure the process is actually dead before proceeding.</source>
          <target state="translated">UNIX에서 이는 &lt;code&gt;send_signal(signal.SIGKILL)&lt;/code&gt; 과 같습니다 . Windows에서는 &lt;code&gt;TerminateProcess&lt;/code&gt; 를 호출합니다 . 두 경우 모두 프로세스가 종료되는 것을 막을 수는 없지만 종료는 비동기 적으로 전달됩니다. 진행하기 전에 프로세스가 실제로 종료되었는지 확인 하려면 &lt;a href=&quot;#trio.Process.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="093bb857c24ad88054bdae99c1ac11b6ac41ad98" translate="yes" xml:space="preserve">
          <source>On UNIX, this is equivalent to &lt;code&gt;send_signal(signal.SIGTERM)&lt;/code&gt;; by convention this requests graceful termination, but a misbehaving or buggy process might ignore it. On Windows, &lt;a href=&quot;#trio.Process.terminate&quot;&gt;&lt;code&gt;terminate()&lt;/code&gt;&lt;/a&gt; forcibly terminates the process in the same manner as &lt;a href=&quot;#trio.Process.kill&quot;&gt;&lt;code&gt;kill()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">UNIX에서 이는 &lt;code&gt;send_signal(signal.SIGTERM)&lt;/code&gt; 과 같습니다 . 일반적으로 이것은 정상적인 종료를 요청하지만 오작동이나 버그가있는 프로세스는이를 무시할 수 있습니다. Windows에서 &lt;a href=&quot;#trio.Process.terminate&quot;&gt; &lt;code&gt;terminate()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#trio.Process.kill&quot;&gt; &lt;code&gt;kill()&lt;/code&gt; &lt;/a&gt; 과 동일한 방식으로 프로세스를 강제 종료합니다 .</target>
        </trans-unit>
        <trans-unit id="63bccc32cfb24ea3be7c492da42e7d6931504b60" translate="yes" xml:space="preserve">
          <source>On Unix systems, &lt;code&gt;obj&lt;/code&gt; must either be an integer file descriptor, or else an object with a &lt;code&gt;.fileno()&lt;/code&gt; method which returns an integer file descriptor. Any kind of file descriptor can be passed, though the exact semantics will depend on your kernel. For example, this probably won&amp;rsquo;t do anything useful for on-disk files.</source>
          <target state="translated">유닉스 시스템에서 &lt;code&gt;obj&lt;/code&gt; 는 정수 파일 디스크립터이거나 정수 파일 디스크립터 를 리턴하는 &lt;code&gt;.fileno()&lt;/code&gt; 메소드를 가진 객체 여야 합니다. 정확한 의미론은 커널에 따라 다르지만 모든 종류의 파일 디스크립터를 전달할 수 있습니다. 예를 들어, 이것은 온 디스크 파일에 유용한 기능을 수행하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="5f778902d9c8c447218f9ad6fe556cf1426e9e88" translate="yes" xml:space="preserve">
          <source>On Unix-likes, the default behavior is to send a &lt;code&gt;SIGTERM&lt;/code&gt;, wait 5 seconds, and send a &lt;code&gt;SIGKILL&lt;/code&gt;.</source>
          <target state="translated">유닉스 계열에서 기본 동작은 &lt;code&gt;SIGTERM&lt;/code&gt; 을 보내고 5 초간 기다린 다음 &lt;code&gt;SIGKILL&lt;/code&gt; 을 보내는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a969b2d9ca8b91fa9abe22200e2f4c6b06299d74" translate="yes" xml:space="preserve">
          <source>On Windows systems, &lt;code&gt;obj&lt;/code&gt; must either be an integer &lt;code&gt;SOCKET&lt;/code&gt; handle, or else an object with a &lt;code&gt;.fileno()&lt;/code&gt; method which returns an integer &lt;code&gt;SOCKET&lt;/code&gt; handle. File descriptors aren&amp;rsquo;t supported, and neither are handles that refer to anything besides a &lt;code&gt;SOCKET&lt;/code&gt;.</source>
          <target state="translated">Windows 시스템의 경우, &lt;code&gt;obj&lt;/code&gt; 하나의 정수이어야 &lt;code&gt;SOCKET&lt;/code&gt; A의 핸들, 또는 다른 물체 &lt;code&gt;.fileno()&lt;/code&gt; 정수 반환 방법 &lt;code&gt;SOCKET&lt;/code&gt; 핸들을. 파일 디스크립터는 지원되지 않으며 &lt;code&gt;SOCKET&lt;/code&gt; 이외의 것을 참조하는 핸들도 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="fc652985d9f1e9dde967ef006b4df5bdb1adee42" translate="yes" xml:space="preserve">
          <source>On Windows with &lt;code&gt;shell=True&lt;/code&gt;, things get even more chaotic. Now there are two separate sets of quoting rules applied, one by the Windows command shell &lt;code&gt;CMD.EXE&lt;/code&gt; and one by the process being spawned, and they&amp;rsquo;re &lt;em&gt;different&lt;/em&gt;. (And there&amp;rsquo;s no &lt;a href=&quot;https://docs.python.org/3/library/shlex.html#shlex.quote&quot;&gt;&lt;code&gt;shlex.quote()&lt;/code&gt;&lt;/a&gt; to save you: it uses UNIX-style quoting rules, even on Windows.) Most special characters interpreted by the shell &lt;code&gt;&amp;amp;&amp;lt;&amp;gt;()^|&lt;/code&gt; are not treated as special if the shell thinks they&amp;rsquo;re inside double quotes, but &lt;code&gt;%FOO%&lt;/code&gt; environment variable substitutions still are, and the shell doesn&amp;rsquo;t provide any way to write a double quote inside a double-quoted string. Outside double quotes, any character (including a double quote) can be escaped using a leading &lt;code&gt;^&lt;/code&gt;. But since a pipeline is processed by running each command in the pipeline in a subshell, multiple layers of escaping can be needed:</source>
          <target state="translated">&lt;code&gt;shell=True&lt;/code&gt; 인 Windows 에서는 상황이 더욱 혼란스러워집니다. 이제 Windows 명령 셸 &lt;code&gt;CMD.EXE&lt;/code&gt; 와 생성되는 프로세스에 &lt;em&gt;따라 서로 다른&lt;/em&gt; 두 가지 인용 규칙 세트가 적용됩니다 . (또한 &lt;a href=&quot;https://docs.python.org/3/library/shlex.html#shlex.quote&quot;&gt; &lt;code&gt;shlex.quote()&lt;/code&gt; &lt;/a&gt; 는 저장 하지 않습니다 . Windows에서도 UNIX 스타일의 인용 규칙을 사용합니다.) 쉘 &lt;code&gt;&amp;amp;&amp;lt;&amp;gt;()^|&lt;/code&gt; 쉘이 큰 따옴표 안에 있다고 생각하면 특수한 것으로 취급되지 않지만 &lt;code&gt;%FOO%&lt;/code&gt; 환경 변수 대체가 여전히 존재하고 쉘은 큰 따옴표로 묶은 문자열 안에 큰 따옴표를 쓸 수있는 방법을 제공하지 않으면 되지 않습니다. 큰 따옴표 외의 경우, 큰 따옴표를 포함하여 모든 문자를 이스케이프 처리 할 수 ​​있습니다 &lt;code&gt;^&lt;/code&gt; . 그러나 파이프 라인에서 각 명령을 서브 쉘로 실행하여 파이프 라인이 처리되므로 여러 계층의 이스케이프가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c24aef8753094fb445e161838d7875f71ea24d80" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;SO_REUSEADDR&lt;/code&gt; is not exported, because it&amp;rsquo;s a trap: the name is the same as Unix &lt;code&gt;SO_REUSEADDR&lt;/code&gt;, but the semantics are &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms740621(v=vs.85).aspx&quot;&gt;different and extremely broken&lt;/a&gt;. In the very rare cases where you actually want &lt;code&gt;SO_REUSEADDR&lt;/code&gt; on Windows, then it can still be accessed from the standard library&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/library/socket.html#module-socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Windows에서는 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 이 트랩이기 때문에 내 보내지 않습니다. 이름은 Unix &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 과 동일 하지만 의미가 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms740621(v=vs.85).aspx&quot;&gt;다르고 크게 손상&lt;/a&gt; 됩니다. Windows에서 실제로 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 을 원하는 매우 드문 경우 에도 표준 라이브러리의 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#module-socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt; 모듈 에서 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="73f86f6e5d3bd603b807b1d07a4c8bf76197ac32" translate="yes" xml:space="preserve">
          <source>On Windows, Trio calls &lt;code&gt;TerminateProcess&lt;/code&gt;, which should kill the process immediately.</source>
          <target state="translated">Windows에서 Trio는 &lt;code&gt;TerminateProcess&lt;/code&gt; 를 호출 하여 프로세스를 즉시 종료 합니다.</target>
        </trans-unit>
        <trans-unit id="1df29ab054edbd8897c505b18471d47700563f66" translate="yes" xml:space="preserve">
          <source>On Windows, the fundamental API for process spawning (the &lt;code&gt;CreateProcess()&lt;/code&gt; system call) takes a string, not a list, and it&amp;rsquo;s actually up to the child process to decide how it wants to split that string into individual arguments. Since the C language specifies that &lt;code&gt;main()&lt;/code&gt; should take a list of arguments, &lt;em&gt;most&lt;/em&gt; programs you encounter will follow the rules used by the Microsoft C/C++ runtime. &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt;&lt;code&gt;subprocess.Popen&lt;/code&gt;&lt;/a&gt;, and thus also Trio, uses these rules when it converts an argument sequence to a string, and they are &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#converting-argument-sequence&quot;&gt;documented&lt;/a&gt; alongside the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; module. There is no documented Python standard library function that can directly perform that conversion, so even on Windows, you almost always want to pass an argument sequence rather than a string. But if the program you&amp;rsquo;re spawning doesn&amp;rsquo;t split its command line back into individual arguments in the standard way, you might need to pass a string to work around this. (Or you might just be out of luck: as far as I can tell, there&amp;rsquo;s simply no way to pass an argument containing a double-quote to a Windows batch file.)</source>
          <target state="translated">Windows에서 프로세스 생성을위한 기본 API ( &lt;code&gt;CreateProcess()&lt;/code&gt; 시스템 호출)는 목록이 아닌 문자열을 사용하며 실제로 해당 문자열을 개별 인수로 분할하려는 방법을 결정하는 것은 자식 프로세스에 달려 있습니다. C 언어는 &lt;code&gt;main()&lt;/code&gt; 이 인수 목록을 가져야한다고 지정하기 때문에 발생하는 &lt;em&gt;대부분의&lt;/em&gt; 프로그램은 Microsoft C / C ++ 런타임에서 사용하는 규칙을 따릅니다. &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen&quot;&gt; &lt;code&gt;subprocess.Popen&lt;/code&gt; &lt;/a&gt; 및 따라서 Trio는 인수 시퀀스를 문자열로 변환 할 때 이러한 규칙을 사용 하며 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 와 함께 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#converting-argument-sequence&quot;&gt;문서화&lt;/a&gt; 됩니다.기준 치수. 해당 변환을 직접 수행 할 수있는 문서화 된 Python 표준 라이브러리 함수가 없으므로 Windows에서도 거의 항상 문자열이 아닌 인수 시퀀스를 전달하려고합니다. 그러나 생성중인 프로그램이 명령 줄을 표준 방식으로 개별 인수로 다시 분할하지 않으면이 문제를 해결하기 위해 문자열을 전달해야 할 수도 있습니다. (또는 당신은 운이 좋지 않을 수도 있습니다 : 내가 말할 수있는 한, 큰 따옴표가 포함 된 인수를 Windows 배치 파일에 전달하는 방법은 없습니다.)</target>
        </trans-unit>
        <trans-unit id="93793d84cc2eab9e78702720d98d47b6401fa3b1" translate="yes" xml:space="preserve">
          <source>On a socket, this corresponds to &lt;code&gt;shutdown(..., SHUT_WR)&lt;/code&gt; (&lt;a href=&quot;https://linux.die.net/man/2/shutdown&quot;&gt;man page&lt;/a&gt;).</source>
          <target state="translated">소켓에서 이는 &lt;code&gt;shutdown(..., SHUT_WR)&lt;/code&gt; ( &lt;a href=&quot;https://linux.die.net/man/2/shutdown&quot;&gt;man page&lt;/a&gt; )에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="4577b2431790155ff289f03b1c114b916f176a26" translate="yes" xml:space="preserve">
          <source>On an SSL/TLS-encrypted connection, the protocol doesn&amp;rsquo;t provide any way to do a unidirectional shutdown without closing the connection entirely, so &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; implements &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;, not &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;HalfCloseableStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">있도록 SSL / TLS 암호화 연결에서 프로토콜은 완전히 연결을 닫지 않고 단방향 종료를 할 수있는 방법을 제공하지 않습니다 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; 이&lt;/a&gt; 구현 &lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 하지 &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;HalfCloseableStream&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abbe0780aa8ff8d2c2f1e406c9e31e6c7a33bfff" translate="yes" xml:space="preserve">
          <source>On average, the producer sends ten messages per second, but the consumer only calls &lt;code&gt;receive&lt;/code&gt; once per second. That means that each second, the channel&amp;rsquo;s internal buffer has to grow to hold an extra nine items. After a minute, the buffer will have ~540 items in it; after an hour, that grows to ~32,400. Eventually, the program will run out of memory. And well before we run out of memory, our latency on handling individual messages will become abysmal. For example, at the one minute mark, the producer is sending message ~600, but the consumer is still processing message ~60. Message 600 will have to sit in the channel for ~9 minutes before the consumer catches up and processes it.</source>
          <target state="translated">평균적으로 생산자는 초당 10 개의 메시지를 보내지 만 소비자 는 초당 한 번만 호출을 &lt;code&gt;receive&lt;/code&gt; . 이는 매초마다 채널의 내부 버퍼가 증가하여 추가 9 개 항목을 보유해야 함을 의미합니다. 1 분 후 버퍼에는 ~ 540 개의 항목이 있습니다. 한 시간 후에는 ~ 32,400으로 증가합니다. 결국 프로그램의 메모리가 부족해집니다. 그리고 메모리가 부족하기 훨씬 전에 개별 메시지 처리에 대한 지연 시간이 심해집니다. 예를 들어 1 분 표시에서 생산자는 ~ 600 개의 메시지를 보내고 있지만 소비자는 여전히 ~ 60 개의 메시지를 처리하고 있습니다. 메시지 600은 소비자가 메시지를 따라 잡고 처리하기 전에 최대 9 분 동안 채널에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d03a8ca5007fa469f6d5b1b6ccd1bc31dfaeda2f" translate="yes" xml:space="preserve">
          <source>On average, the producer sends ten messages per second, but the consumer only calls &lt;code&gt;receive&lt;/code&gt; once per second. That means that each second, the channel&amp;rsquo;s internal buffer has to grow to hold an extra nine items. After a minute, the buffer will have ~540 items in it; after an hour, that grows to ~32,400. Eventually, the program will run out of memory. And well before we run out of memory, our latency on handling individual messages will become abysmal. For example, at the one minute mark, the producer is sending message ~600, but the producer is still processing message ~60. Message 600 will have to sit in the channel for ~9 minutes before the consumer catches up and processes it.</source>
          <target state="translated">평균적으로 생산자는 초당 10 개의 메시지를 보내지 만 소비자 는 초당 한 번만 전화를 &lt;code&gt;receive&lt;/code&gt; . 즉, 채널의 내부 버퍼는 추가로 9 개의 항목을 보유하도록 커져야합니다. 1 분 후 버퍼에 ~ 540 개의 항목이 있습니다. 한 시간 후, ~ 32,400으로 증가합니다. 결국 프로그램의 메모리가 부족합니다. 또한 메모리가 부족하기 전에 개별 메시지를 처리하는 데 걸리는 지연 시간이 심해집니다. 예를 들어, 1 분 표시에서 생산자는 ~ 600 메시지를 보내고 있지만 생산자는 ~ 60 메시지를 처리하고 있습니다. 메시지 600은 소비자가 따라 잡고 처리하기 전에 ~ 9 분 동안 채널에 앉아 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="500856d82467ceb52145a512e9cd103bdc26a294" translate="yes" xml:space="preserve">
          <source>On the other hand, if your host loop doesn&amp;rsquo;t use &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt;&lt;code&gt;signal.set_wakeup_fd&lt;/code&gt;&lt;/a&gt;, then the only way to make everything work correctly is to &lt;em&gt;enable&lt;/em&gt; Trio&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt;&lt;code&gt;signal.set_wakeup_fd&lt;/code&gt;&lt;/a&gt; support.</source>
          <target state="translated">반면에 호스트 루프가 &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt; &lt;code&gt;signal.set_wakeup_fd&lt;/code&gt; 를&lt;/a&gt; 사용하지 않는 경우 모든 것이 올바르게 작동하도록하는 유일한 방법은 Trio의 &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt; &lt;code&gt;signal.set_wakeup_fd&lt;/code&gt; &lt;/a&gt; 지원 을 &lt;em&gt;활성화&lt;/em&gt; 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="99d0a83dc0fc994fcf4f4fc337ee0f9989b01cda" translate="yes" xml:space="preserve">
          <source>On the path where we do end up blocking, we don&amp;rsquo;t pass through any schedule points before that, which avoids some unnecessary work.</source>
          <target state="translated">우리가 블로킹을 끝내는 경로에서는 그 이전의 일정 지점을 통과하지 않으므로 불필요한 작업을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ab0a659811c28a2e762a50d54ab27494f7938a1" translate="yes" xml:space="preserve">
          <source>Once a &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt; object is constructed, it implements the full &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;trio.abc.HalfCloseableStream&lt;/code&gt;&lt;/a&gt; interface. In addition, it provides a few extra features:</source>
          <target state="translated">&lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; &lt;/a&gt; 객체가 생성 되면 전체 &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;trio.abc.HalfCloseableStream&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현합니다 . 또한 몇 가지 추가 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a64c9326dd46aad109181cb7ab1c383a9bdc1d7f" translate="yes" xml:space="preserve">
          <source>Once all the tasks have finished, then:</source>
          <target state="translated">모든 작업이 완료되면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c45afa168e0caa5cc229264e1df9c6831e79c284" translate="yes" xml:space="preserve">
          <source>Once this method completes, any other pending or future operations on this resource should generally raise &lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt;&lt;code&gt;ClosedResourceError&lt;/code&gt;&lt;/a&gt;, unless there&amp;rsquo;s a good reason to do otherwise.</source>
          <target state="translated">이 메소드가 완료되면 (자), 다른 이유가없는 한, 이 자원에 대한 다른 보류 중 또는 향후의 조작은 일반적으로 &lt;a href=&quot;reference-core#trio.ClosedResourceError&quot;&gt; &lt;code&gt;ClosedResourceError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26c7df89ffd2d387f5d5beed48542e820db53c87" translate="yes" xml:space="preserve">
          <source>One approach would be to attempt to connect to the first one, and then if that fails, attempt to connect to the second one &amp;hellip; until we&amp;rsquo;ve tried all of them. But the problem with this is that if the first IP address is unreachable (for example, because it&amp;rsquo;s an IPv6 address and our network discards IPv6 packets), then we might end up waiting tens of seconds for the first connection attempt to timeout before we try the second address.</source>
          <target state="translated">한 가지 방법은 첫 번째 방법으로 연결을 시도한 다음 실패하면 두 번째 방법으로 연결을 시도하는 것입니다. 모든 방법을 시도 할 때까지. 그러나 이것의 문제점은 첫 번째 IP 주소에 도달 할 수없는 경우 (예를 들어, IPv6 주소이고 네트워크가 IPv6 패킷을 버림), 첫 번째 연결 시도가 시간 초과 될 때까지 수십 초 동안 기다릴 수 있다는 것입니다. 두 번째 주소</target>
        </trans-unit>
        <trans-unit id="17218738b7f51d71e3bf8c24ea0d43906f5453a7" translate="yes" xml:space="preserve">
          <source>One example of where this might be is useful is if your code is trying to decide whether to begin an expensive operation like an RPC call, but wants to skip it if it knows that it can&amp;rsquo;t possibly complete in the available time. Another example would be if you&amp;rsquo;re using a protocol like gRPC that &lt;a href=&quot;http://www.grpc.io/docs/guides/concepts.html#deadlines&quot;&gt;propagates timeout information to the remote peer&lt;/a&gt;; this function gives a way to fetch that information so you can send it along.</source>
          <target state="translated">이것이 유용한 곳의 한 가지 예는 코드가 RPC 호출과 같이 값 비싼 작업을 시작할지 여부를 결정하려고하지만 사용 가능한 시간 내에 완료 할 수없는 것으로 알고 있으면 건너 뛰려는 경우입니다. 다른 예는 &lt;a href=&quot;http://www.grpc.io/docs/guides/concepts.html#deadlines&quot;&gt;시간 제한 정보를 원격 피어에 전파하는&lt;/a&gt; gRPC와 같은 프로토콜을 사용하는 경우입니다 . 이 함수는 정보를 가져 와서 보낼 수있는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a0c0d7674af6ab050c1ac2ce111af25d5586750b" translate="yes" xml:space="preserve">
          <source>One of Trio&amp;rsquo;s core design principles is: &lt;em&gt;no implicit concurrency&lt;/em&gt;. Every function executes in a straightforward, top-to-bottom manner, finishing each operation before moving on to the next &amp;ndash; &lt;em&gt;like Guido intended&lt;/em&gt;.</source>
          <target state="translated">Trio의 핵심 설계 원칙 중 하나는 다음과 같습니다 . &lt;em&gt;암시 적 동시성 없음&lt;/em&gt; . 모든 기능은 간단하고 위에서 아래로 실행되며 &lt;em&gt;Guido 의도와 같이&lt;/em&gt; 다음 작업으로 넘어 가기 전에 각 작업을 완료합니다 .</target>
        </trans-unit>
        <trans-unit id="c5258410fd1961814ad646a55d204ab7988e49b2" translate="yes" xml:space="preserve">
          <source>One option would be to use a regular &lt;a href=&quot;#trio.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt;, and wrap it around every interaction with the state machine:</source>
          <target state="translated">한 가지 옵션은 일반 &lt;a href=&quot;#trio.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 을 사용 하고 상태 시스템과의 모든 상호 작용을 감싸는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7e644ae43ba1462c7a0943dedaacaa1f10e95eff" translate="yes" xml:space="preserve">
          <source>One particularly challenging problem when testing network protocols is making sure that your implementation can handle data whose flow gets broken up in weird ways and arrives with weird timings: localhost connections tend to be much better behaved than real networks, so if you only test on localhost then you might get bitten later. To help you out, Trio provides some fully in-memory implementations of the stream interfaces (see &lt;a href=&quot;reference-io#abstract-stream-api&quot;&gt;The abstract Stream API&lt;/a&gt;), that let you write all kinds of interestingly evil tests.</source>
          <target state="translated">네트워크 프로토콜을 테스트 할 때 특히 어려운 문제 중 하나는 구현에서 흐름이 이상한 방식으로 분류되고 이상한 타이밍으로 도착하는 데이터를 처리 할 수 ​​있는지 확인하는 것입니다. 로컬 호스트 연결은 실제 네트워크보다 훨씬 더 나은 경향이 있으므로 로컬 호스트에서만 테스트하는 경우 나중에 물릴 수도 있습니다. 도움을주기 위해 Trio는 스트림 인터페이스의 완전히 메모리 내 구현을 제공합니다 ( &lt;a href=&quot;reference-io#abstract-stream-api&quot;&gt;추상 스트림 API&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="70024abc1516890206e396c0d84ab876e9506524" translate="yes" xml:space="preserve">
          <source>One thing to remember, though: cancel scopes are inherited from the nursery, &lt;strong&gt;not&lt;/strong&gt; from the task that calls &lt;code&gt;start_soon&lt;/code&gt;. So in this example, the timeout does &lt;em&gt;not&lt;/em&gt; apply to &lt;code&gt;child&lt;/code&gt; (or to anything else):</source>
          <target state="translated">그러나 기억해야 할 것은 취소 범위는 &lt;code&gt;start_soon&lt;/code&gt; 을 호출하는 작업이 &lt;strong&gt;아니라&lt;/strong&gt; 보육원에서 상속 한다는 것 입니다. 따라서이 예에서 시간 초과는 &lt;code&gt;child&lt;/code&gt; (또는 다른 것)에 적용 되지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="beaeb02751f65d3130fef8613eaa9d036b7b827d" translate="yes" xml:space="preserve">
          <source>Open a channel for passing objects between tasks within a process.</source>
          <target state="translated">프로세스 내 작업간에 개체를 전달하기위한 채널을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="6c62e1a69d21a32a529448d3d8f35daada8a1b66" translate="yes" xml:space="preserve">
          <source>Open the file pointed by this path and return a file object, as the built-in open() function does.</source>
          <target state="translated">이 경로가 가리키는 파일을 열고 내장 open () 함수와 같이 파일 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f3c5fe1c3751280d80986615a66056be1dd51489" translate="yes" xml:space="preserve">
          <source>Opens a connection to the specified &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_domain_socket&quot;&gt;Unix domain socket&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_domain_socket&quot;&gt;Unix 도메인 소켓에&lt;/a&gt; 대한 연결을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="1901a0e40a967eefcb6e5dd3df1c5f153c15dbb3" translate="yes" xml:space="preserve">
          <source>Options for starting subprocesses</source>
          <target state="translated">서브 프로세스 시작 옵션</target>
        </trans-unit>
        <trans-unit id="07bed1666c9b3ba20e049d70aa47c6dc1b7091b8" translate="yes" xml:space="preserve">
          <source>Original worker thread: marks itself as idle.</source>
          <target state="translated">원래 작업자 스레드 : 자신을 유휴 상태로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="6526a011848344d0bc9ecc95ad418dd89e0a7676" translate="yes" xml:space="preserve">
          <source>Other environments might also work; give it a try and see.</source>
          <target state="translated">다른 환경도 작동 할 수 있습니다. 그것을 시도하고보십시오.</target>
        </trans-unit>
        <trans-unit id="efe8c1c73352ea2ed8175b8de72fc761dd83142c" translate="yes" xml:space="preserve">
          <source>Otherwise, it should return &lt;a href=&quot;#trio.hazmat.Abort.FAILED&quot;&gt;&lt;code&gt;Abort.FAILED&lt;/code&gt;&lt;/a&gt;. This means that the task can&amp;rsquo;t be cancelled at this time, and still has to make sure that &amp;ldquo;someone&amp;rdquo; eventually calls &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그렇지 않으면 &lt;a href=&quot;#trio.hazmat.Abort.FAILED&quot;&gt; &lt;code&gt;Abort.FAILED&lt;/code&gt; &lt;/a&gt; 를 반환해야합니다 . 이것은 현재 작업을 취소 할 수 없으며 &quot;누군가&quot;가 결국 &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; 호출해야한다는 것을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="6edcd77868a87ce793ce78fd085febc4dadbf0ca" translate="yes" xml:space="preserve">
          <source>Otherwise, it should return &lt;a href=&quot;#trio.lowlevel.Abort.FAILED&quot;&gt;&lt;code&gt;Abort.FAILED&lt;/code&gt;&lt;/a&gt;. This means that the task can&amp;rsquo;t be cancelled at this time, and still has to make sure that &amp;ldquo;someone&amp;rdquo; eventually calls &lt;a href=&quot;#trio.lowlevel.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그렇지 않으면 &lt;a href=&quot;#trio.lowlevel.Abort.FAILED&quot;&gt; &lt;code&gt;Abort.FAILED&lt;/code&gt; &lt;/a&gt; 를 반환해야합니다 . 즉, 현재 작업을 취소 할 수 없으며 &quot;누군가&quot;가 결국 &lt;a href=&quot;#trio.lowlevel.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; 호출하는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="456165d8c54895fc6bd4ac3bf65c943f1ea85b80" translate="yes" xml:space="preserve">
          <source>Otherwise, returns a new &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">그렇지 않으면 새로운 &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; 를&lt;/a&gt; 반환합니다 객체를 합니다.</target>
        </trans-unit>
        <trans-unit id="9ee75f95c72ccfd62a03a7e39dba3cd64ff33ea2" translate="yes" xml:space="preserve">
          <source>Our &lt;a href=&quot;reference-core#cancellable-primitives&quot;&gt;cancellation semantics&lt;/a&gt; say that &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; should only be raised if the operation didn&amp;rsquo;t happen. Using &lt;a href=&quot;#trio.hazmat.cancel_shielded_checkpoint&quot;&gt;&lt;code&gt;cancel_shielded_checkpoint()&lt;/code&gt;&lt;/a&gt; on the early-exit branch accomplishes this.</source>
          <target state="translated">우리의 &lt;a href=&quot;reference-core#cancellable-primitives&quot;&gt;취소 의미는&lt;/a&gt; 말 &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 작업이 발생하지 않은 경우에만 제기해야합니다. 조기 종료 지점에서 &lt;a href=&quot;#trio.hazmat.cancel_shielded_checkpoint&quot;&gt; &lt;code&gt;cancel_shielded_checkpoint()&lt;/code&gt; &lt;/a&gt; 를 사용하면 이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bddce36048dc439f09e479b0ca70bcb5f35d0ff" translate="yes" xml:space="preserve">
          <source>Our &lt;a href=&quot;reference-core#cancellable-primitives&quot;&gt;cancellation semantics&lt;/a&gt; say that &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; should only be raised if the operation didn&amp;rsquo;t happen. Using &lt;a href=&quot;#trio.lowlevel.cancel_shielded_checkpoint&quot;&gt;&lt;code&gt;cancel_shielded_checkpoint()&lt;/code&gt;&lt;/a&gt; on the early-exit branch accomplishes this.</source>
          <target state="translated">우리의 &lt;a href=&quot;reference-core#cancellable-primitives&quot;&gt;취소 의미는&lt;/a&gt; 말 &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 작업이 발생하지 않은 경우에만 제기해야합니다. 조기 종료 브랜치에서 &lt;a href=&quot;#trio.lowlevel.cancel_shielded_checkpoint&quot;&gt; &lt;code&gt;cancel_shielded_checkpoint()&lt;/code&gt; &lt;/a&gt; 를 사용하면 이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7db19939314aaad6d5ce1f4bdae93a6396ba0d3a" translate="yes" xml:space="preserve">
          <source>Our Pledge</source>
          <target state="translated">우리의 서약</target>
        </trans-unit>
        <trans-unit id="25e4d03f4e76d2bf2914327a45498edc72df108f" translate="yes" xml:space="preserve">
          <source>Our Standards</source>
          <target state="translated">우리의 기준</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="4f2f5f60cf5ac63db9da317a29551d539455d423" translate="yes" xml:space="preserve">
          <source>Overview: abstract base classes for I/O</source>
          <target state="translated">개요 : I / O에 대한 추상 기본 클래스</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="08f9f24653915627b70d1df0f7d09b16a85dfbbf" translate="yes" xml:space="preserve">
          <source>Park the current task until woken by a call to &lt;a href=&quot;#trio.hazmat.ParkingLot.unpark&quot;&gt;&lt;code&gt;unpark()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.hazmat.ParkingLot.unpark_all&quot;&gt;&lt;code&gt;unpark_all()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.hazmat.ParkingLot.unpark&quot;&gt; &lt;code&gt;unpark()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#trio.hazmat.ParkingLot.unpark_all&quot;&gt; &lt;code&gt;unpark_all()&lt;/code&gt; &lt;/a&gt; 호출로 깨어날 때까지 현재 작업을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c0b44086afe5929d11f031dba9bb4b86e014448" translate="yes" xml:space="preserve">
          <source>Park the current task until woken by a call to &lt;a href=&quot;#trio.lowlevel.ParkingLot.unpark&quot;&gt;&lt;code&gt;unpark()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.lowlevel.ParkingLot.unpark_all&quot;&gt;&lt;code&gt;unpark_all()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.lowlevel.ParkingLot.unpark&quot;&gt; &lt;code&gt;unpark()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#trio.lowlevel.ParkingLot.unpark_all&quot;&gt; &lt;code&gt;unpark_all()&lt;/code&gt; &lt;/a&gt; 호출에 의해 깨어날 때까지 현재 작업을 파킹합니다 .</target>
        </trans-unit>
        <trans-unit id="82d438cd7980583075141b24e8673a9713c1bf85" translate="yes" xml:space="preserve">
          <source>Partial exception for async context managers: Both the entry and exit of an &lt;code&gt;async with&lt;/code&gt; block are defined as async functions; but for a particular type of async context manager, it&amp;rsquo;s often the case that only one of them is able to block, which means only that one will act as a checkpoint. This is documented on a case-by-case basis.</source>
          <target state="translated">비동기 컨텍스트 관리자에 대한 부분 예외 : 블록이 있는 &lt;code&gt;async with&lt;/code&gt; 의 시작과 종료는 모두 비동기 함수로 정의됩니다. 그러나 특정 유형의 비동기 컨텍스트 관리자의 경우 하나만 차단할 수있는 경우가 종종 있습니다. 즉, 하나만 체크 포인트로 작동합니다. 이것은 사례별로 문서화됩니다.</target>
        </trans-unit>
        <trans-unit id="5a267b39a5eff3913f1dc319a58ba6d62432a28c" translate="yes" xml:space="preserve">
          <source>Pass a keyword argument, &lt;code&gt;trio_token&lt;/code&gt; specifiying a specific &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt; loop to re-enter. This is useful in case you have a &amp;ldquo;foreign&amp;rdquo; thread, spawned using some other framework, and still want to enter Trio.</source>
          <target state="translated">키워드 인수에 전달 &lt;code&gt;trio_token&lt;/code&gt; 특정의 specifiying &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run&lt;/code&gt; 의&lt;/a&gt; 에 루프를 재 입력합니다. 이 기능은 다른 프레임 워크를 사용하여 생성 된 &quot;외부&quot;스레드가 있고 여전히 트리오를 입력하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1aa5a7ccff5d4f3757f85c40b5dbca2bf8a5358c" translate="yes" xml:space="preserve">
          <source>Pause execution of the current task for the given number of seconds.</source>
          <target state="translated">주어진 시간 (초) 동안 현재 작업 실행을 일시 중지합니다.</target>
        </trans-unit>
        <trans-unit id="792724ee650d41a2261ab590c3c964ec9b82bf03" translate="yes" xml:space="preserve">
          <source>Pause execution of the current task forever (or until cancelled).</source>
          <target state="translated">현재 작업의 실행을 영원히 일시 중지합니다 (또는 취소 할 때까지).</target>
        </trans-unit>
        <trans-unit id="63447823632f8be015880571aa87f00f9ebeabb5" translate="yes" xml:space="preserve">
          <source>Pause execution of the current task until the given time.</source>
          <target state="translated">주어진 시간까지 현재 작업의 실행을 일시 중지합니다.</target>
        </trans-unit>
        <trans-unit id="b7f07d2b14f04bdac99308eaf26585e7e40b3547" translate="yes" xml:space="preserve">
          <source>Perform a number of generic tests on a custom half-closeable stream implementation.</source>
          <target state="translated">사용자 정의 반 폐쇄 가능 스트림 구현에 대해 여러 일반 테스트를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c295fcaa1b20aada89b1b40cd2fbdfb23ce8e370" translate="yes" xml:space="preserve">
          <source>Perform a number of generic tests on a custom one-way stream implementation.</source>
          <target state="translated">사용자 지정 단방향 스트림 구현에서 여러 가지 일반 테스트를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7a62317ddba72606ceef522c1b86d0d79ca09d82" translate="yes" xml:space="preserve">
          <source>Perform a number of generic tests on a custom two-way stream implementation.</source>
          <target state="translated">사용자 지정 양방향 스트림 구현에 대해 여러 가지 일반적인 테스트를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="42ff50b294fd4232d4b5ff341053088b57eb97c3" translate="yes" xml:space="preserve">
          <source>Permanently detach the current task from the Trio scheduler.</source>
          <target state="translated">현재 작업을 Trio 스케줄러에서 영구적으로 분리하십시오.</target>
        </trans-unit>
        <trans-unit id="f58fe36afb47440251499a789d28dbf3bd14b5c4" translate="yes" xml:space="preserve">
          <source>Personally, I find that events and channels are usually enough to implement most things I care about, and lead to easier to read code than the lower-level primitives discussed in this section. But if you need them, they&amp;rsquo;re here. (If you find yourself reaching for these because you&amp;rsquo;re trying to implement a new higher-level synchronization primitive, then you might also want to check out the facilities in &lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt; for a more direct exposure of Trio&amp;rsquo;s underlying synchronization logic. All of classes discussed in this section are implemented on top of the public APIs in &lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt;; they don&amp;rsquo;t have any special access to Trio&amp;rsquo;s internals.)</source>
          <target state="translated">개인적으로, 이벤트와 채널은 일반적으로 내가 관심을 갖는 대부분의 것을 구현하기에 충분하며이 섹션에서 논의 된 하위 레벨 프리미티브보다 코드를 더 쉽게 읽을 수 있습니다. 그러나 필요한 경우 여기에 있습니다. (새로운 상위 수준의 동기화 프리미티브를 구현하려고하기 때문에 이러한 목표에 도달하면 트리오의 기본 동기화 로직에 대한 직접적인 노출을 위해 &lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; &lt;/a&gt; 의 기능을 확인할 수도 있습니다 . 이 섹션에서 논의되는 클래스는 &lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; &lt;/a&gt; 의 공개 API 위에 구현 되며 Trio의 내부에 대한 특별한 액세스 권한은 없습니다.)</target>
        </trans-unit>
        <trans-unit id="34bfe6cded6c4e328eba04147e1373f27cf558f6" translate="yes" xml:space="preserve">
          <source>Personally, I find that events and channels are usually enough to implement most things I care about, and lead to easier to read code than the lower-level primitives discussed in this section. But if you need them, they&amp;rsquo;re here. (If you find yourself reaching for these because you&amp;rsquo;re trying to implement a new higher-level synchronization primitive, then you might also want to check out the facilities in &lt;a href=&quot;reference-lowlevel#module-trio.lowlevel&quot;&gt;&lt;code&gt;trio.lowlevel&lt;/code&gt;&lt;/a&gt; for a more direct exposure of Trio&amp;rsquo;s underlying synchronization logic. All of classes discussed in this section are implemented on top of the public APIs in &lt;a href=&quot;reference-lowlevel#module-trio.lowlevel&quot;&gt;&lt;code&gt;trio.lowlevel&lt;/code&gt;&lt;/a&gt;; they don&amp;rsquo;t have any special access to Trio&amp;rsquo;s internals.)</source>
          <target state="translated">개인적으로 저는 이벤트와 채널이 제가 관심있는 대부분의 것들을 구현하기에 충분하며이 섹션에서 논의 된 하위 수준의 프리미티브보다 코드를 더 쉽게 읽을 수 있다는 것을 알게되었습니다. 하지만 필요한 경우 여기에 있습니다. (새로운 상위 수준의 동기화 기본 요소를 구현하려고하기 때문에 이러한 작업에 도달 한 경우 Trio의 기본 동기화 논리를보다 직접적으로 노출하기 위해 &lt;a href=&quot;reference-lowlevel#module-trio.lowlevel&quot;&gt; &lt;code&gt;trio.lowlevel&lt;/code&gt; &lt;/a&gt; 의 기능을 확인하는 것이 좋습니다 . 이 섹션에서 설명하는 클래스는 &lt;a href=&quot;reference-lowlevel#module-trio.lowlevel&quot;&gt; &lt;code&gt;trio.lowlevel&lt;/code&gt; &lt;/a&gt; 의 공용 API 위에 구현 되며 Trio의 내부에 대한 특별한 액세스 권한이 없습니다.)</target>
        </trans-unit>
        <trans-unit id="ffdc860af184791cfe1b4e1db983700a5c5843f4" translate="yes" xml:space="preserve">
          <source>Places the given data into the object&amp;rsquo;s internal buffer, and then calls the &lt;a href=&quot;#trio.testing.MemorySendStream.send_all_hook&quot;&gt;&lt;code&gt;send_all_hook&lt;/code&gt;&lt;/a&gt; (if any).</source>
          <target state="translated">지정된 데이터를 객체의 내부 버퍼에 넣은 다음 &lt;a href=&quot;#trio.testing.MemorySendStream.send_all_hook&quot;&gt; &lt;code&gt;send_all_hook&lt;/code&gt; &lt;/a&gt; (있는 경우) 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a8ca1fe734f90a81230ee63ca0ea8ac678831e87" translate="yes" xml:space="preserve">
          <source>Preparing a release</source>
          <target state="translated">릴리즈 준비</target>
        </trans-unit>
        <trans-unit id="5020bb795052d80ec813c6028081ba9c1df6120b" translate="yes" xml:space="preserve">
          <source>Preparing pull requests</source>
          <target state="translated">풀 요청 준비</target>
        </trans-unit>
        <trans-unit id="f302fc4ed754d1fbfb349262f16252b92e3cc560" translate="yes" xml:space="preserve">
          <source>Pretty much any code you write using Trio needs to have some strategy to handle &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exceptions &amp;ndash; even if you didn&amp;rsquo;t set a timeout, then your caller might (and probably will).</source>
          <target state="translated">Trio를 사용하여 작성하는 거의 모든 코드에는 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외 를 처리 할 전략이 있어야 합니다. 시간 초과를 설정하지 않더라도 호출자는 그럴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af578c673cdef9a60b45069a7ffe307c6ff638e0" translate="yes" xml:space="preserve">
          <source>Prioritization Only Works When There&amp;rsquo;s Pending Data to Prioritize</source>
          <target state="translated">우선 순위는 우선 순위를 정하기 위해 보류중인 데이터가있는 경우에만 작동합니다</target>
        </trans-unit>
        <trans-unit id="c58c7b026eae377fda9c29eb4891a26769146297" translate="yes" xml:space="preserve">
          <source>Pro-tip: you can insert sleep calls (like in our example above) to manipulate the flow of data across tasks&amp;hellip; and then use &lt;a href=&quot;#trio.testing.MockClock&quot;&gt;&lt;code&gt;MockClock&lt;/code&gt;&lt;/a&gt; and its &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt;&lt;code&gt;autojump_threshold&lt;/code&gt;&lt;/a&gt; functionality to keep your test suite running quickly.</source>
          <target state="translated">전문가 팁 : 작업 전체에서 데이터 흐름을 조작하기 위해 휴면 호출 (예 : 위의 예)을 삽입 한 다음 &lt;a href=&quot;#trio.testing.MockClock&quot;&gt; &lt;code&gt;MockClock&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.testing.MockClock.autojump_threshold&quot;&gt; &lt;code&gt;autojump_threshold&lt;/code&gt; &lt;/a&gt; 기능을 사용하여 테스트 스위트를 빠르게 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97cd9481f2b9c8a87285e30103998d87e6b076b4" translate="yes" xml:space="preserve">
          <source>Providing support</source>
          <target state="translated">지원 제공</target>
        </trans-unit>
        <trans-unit id="c61469d5112d29c4d7b6879f0a1409fe87006118" translate="yes" xml:space="preserve">
          <source>Put a token back into the sack on behalf of &lt;code&gt;borrower&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;borrower&lt;/code&gt; 를 대신하여 자루에 토큰을 다시 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="e2750887dc705834ea27dfee8c5fa086a70d9316" translate="yes" xml:space="preserve">
          <source>Put a token back into the sack.</source>
          <target state="translated">자루에 토큰을 다시 넣습니다.</target>
        </trans-unit>
        <trans-unit id="a3400133bd460916e5852bc1b4deaf18a2290d3e" translate="yes" xml:space="preserve">
          <source>Put the current task to sleep, with cancellation support.</source>
          <target state="translated">취소 지원을 통해 현재 작업을 잠자기 상태로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ef10b7926486af74ce7f9c3ed42b7e35c433287a" translate="yes" xml:space="preserve">
          <source>Putting blocking I/O into worker threads</source>
          <target state="translated">작업자 스레드에 I / O 차단</target>
        </trans-unit>
        <trans-unit id="0e3da495154b52a5558a5ade984baaf547b2ab19" translate="yes" xml:space="preserve">
          <source>Putting these together: if your data is in RAM then it should be clear that using a thread is a terrible idea &amp;ndash; if you add 100 &amp;micro;s of overhead to a 1 &amp;micro;s operation, then that&amp;rsquo;s a 100x slowdown! On the other hand, if your data&amp;rsquo;s on a spinning disk, then using a thread is &lt;em&gt;great&lt;/em&gt; &amp;ndash; instead of blocking the main thread and all tasks for 10,000 &amp;micro;s, we only block them for 100 &amp;micro;s and can spend the rest of that time running other tasks to get useful work done, which can effectively be a 100x speedup.</source>
          <target state="translated">데이터 정리 : 데이터가 RAM에 있다면 스레드를 사용하는 것이 끔찍한 아이디어라는 것이 분명합니다. 1&amp;micro;s 연산에 100&amp;micro;s의 오버 헤드를 추가하면 100 배 속도가 느려집니다! 반면에 데이터가 회전하는 디스크에있는 경우 스레드를 사용하는 것이 &lt;em&gt;좋습니다&lt;/em&gt; . 기본 스레드와 모든 작업을 10,000 &amp;micro;s 동안 차단하는 대신 100 &amp;micro;s 동안 만 차단하고 나머지 시간을 다른 시간 동안 실행할 수 있습니다. 유용한 작업을 수행 할 수있는 작업으로 사실상 100 배 속도를 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bed300b0f4824cbef5b91a6d3b95c3a8725845b" translate="yes" xml:space="preserve">
          <source>Python 3.6 added support for &lt;em&gt;async generators&lt;/em&gt;, which can use &lt;code&gt;await&lt;/code&gt;, &lt;code&gt;async for&lt;/code&gt;, and &lt;code&gt;async with&lt;/code&gt; in between their &lt;code&gt;yield&lt;/code&gt; statements. As you might expect, you use &lt;code&gt;async for&lt;/code&gt; to iterate over them. &lt;a href=&quot;https://www.python.org/dev/peps/pep-0525&quot;&gt;&lt;strong&gt;PEP 525&lt;/strong&gt;&lt;/a&gt; has many more details if you want them.</source>
          <target state="translated">Python 3.6 은 &lt;code&gt;yield&lt;/code&gt; 문 사이에 &lt;code&gt;await&lt;/code&gt; , &lt;code&gt;async for&lt;/code&gt; 및 &lt;code&gt;async with&lt;/code&gt; 를 사용할 수있는 &lt;em&gt;비동기 생성기에&lt;/em&gt; 대한 지원을 추가 했습니다 . 예상 할 수 있듯이 &lt;code&gt;async for&lt;/code&gt; 사용 하여 반복합니다. &lt;a href=&quot;https://www.python.org/dev/peps/pep-0525&quot;&gt;&lt;strong&gt;PEP 525&lt;/strong&gt;&lt;/a&gt; 에는 원하는 경우 더 많은 세부 정보가 있습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6fae7612ee600857e3056834499b09dfc263d2c4" translate="yes" xml:space="preserve">
          <source>Python: 3.6+ (CPython and PyPy)</source>
          <target state="translated">Python : 3.6 이상 (CPython 및 PyPy)</target>
        </trans-unit>
        <trans-unit id="aa77250d0ce1f733a13fed899dc4e3331be06f66" translate="yes" xml:space="preserve">
          <source>Quoting: more than you wanted to know</source>
          <target state="translated">인용 : 당신이 알고 싶은 것보다 더</target>
        </trans-unit>
        <trans-unit id="c3282cbbcba660116d62c007822229220838a1c6" translate="yes" xml:space="preserve">
          <source>RPC</source>
          <target state="translated">RPC</target>
        </trans-unit>
        <trans-unit id="31385a56c42dea75b0abfee3d065ac3faad4e1e6" translate="yes" xml:space="preserve">
          <source>Raised by &lt;a href=&quot;#trio.fail_after&quot;&gt;&lt;code&gt;fail_after()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.fail_at&quot;&gt;&lt;code&gt;fail_at()&lt;/code&gt;&lt;/a&gt; if the timeout expires.</source>
          <target state="translated">시간 초과가 만료되면 &lt;a href=&quot;#trio.fail_after&quot;&gt; &lt;code&gt;fail_after()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.fail_at&quot;&gt; &lt;code&gt;fail_at()&lt;/code&gt; &lt;/a&gt; 의해 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="ec13ded90b55c99ffb9020ca292f5ffb665682a1" translate="yes" xml:space="preserve">
          <source>Raised by &lt;a href=&quot;#trio.from_thread.run&quot;&gt;&lt;code&gt;trio.from_thread.run&lt;/code&gt;&lt;/a&gt; and similar functions if the corresponding call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; has already finished.</source>
          <target state="translated">&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 대한 해당 호출 이 이미 완료된 경우 &lt;a href=&quot;#trio.from_thread.run&quot;&gt; &lt;code&gt;trio.from_thread.run&lt;/code&gt; &lt;/a&gt; 및 유사한 함수에 의해 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="b9a61e9f5e58cb8abe086249f57467b310df32e1" translate="yes" xml:space="preserve">
          <source>Raised by &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; if we encounter a bug in Trio, or (possibly) a misuse of one of the low-level &lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt; APIs.</source>
          <target state="translated">Trio에서 버그가 발생하거나 저수준 &lt;a href=&quot;reference-hazmat#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; &lt;/a&gt; API 중 하나가 잘못 사용 된 경우 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 의해 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="94fb968522f128e5c0cf1083f713016fb115a4f8" translate="yes" xml:space="preserve">
          <source>Raised by &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; if we encounter a bug in Trio, or (possibly) a misuse of one of the low-level &lt;a href=&quot;reference-lowlevel#module-trio.lowlevel&quot;&gt;&lt;code&gt;trio.lowlevel&lt;/code&gt;&lt;/a&gt; APIs.</source>
          <target state="translated">Trio에서 버그가 발생하거나 (아마도) 낮은 수준의 &lt;a href=&quot;reference-lowlevel#module-trio.lowlevel&quot;&gt; &lt;code&gt;trio.lowlevel&lt;/code&gt; &lt;/a&gt; API 중 하나를 오용하는 경우 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 의해 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="8913ddb4486c40268daf092227991759027600a9" translate="yes" xml:space="preserve">
          <source>Raised by &lt;code&gt;X_nowait&lt;/code&gt; functions if &lt;code&gt;X&lt;/code&gt; would block.</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 가 차단 되면 &lt;code&gt;X_nowait&lt;/code&gt; 함수에 의해 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="f210751ec099645a40a15f671e5b2c8300437cce" translate="yes" xml:space="preserve">
          <source>Raised by blocking calls if the surrounding scope has been cancelled.</source>
          <target state="translated">주변 범위가 취소 된 경우 통화를 차단하여 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8f507b1f0875891aee3cdb80c4efd15c0b85e4cb" translate="yes" xml:space="preserve">
          <source>Raised when a task attempts to use a resource that some other task is already using, and this would lead to bugs and nonsense.</source>
          <target state="translated">작업이 다른 작업에서 이미 사용중인 리소스를 사용하려고하면 발생하며 이로 인해 버그가 발생하고 말이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8678ba88e13f646dadb26c39c02dc28761beb10" translate="yes" xml:space="preserve">
          <source>Raised when an attempt to use a resource fails due to external circumstances.</source>
          <target state="translated">외부 환경으로 인해 리소스 사용 시도가 실패하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="812be58660608d36377923c7fc9cb3158c9268d0" translate="yes" xml:space="preserve">
          <source>Raised when attempting to use a resource after it has been closed.</source>
          <target state="translated">리소스를 닫은 후 리소스를 사용하려고 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e09a1bdfa7a2f8848cd0c16df3025ec969cf49ad" translate="yes" xml:space="preserve">
          <source>Raised when trying to receive from a &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;trio.abc.ReceiveChannel&lt;/code&gt;&lt;/a&gt; that has no more data to receive.</source>
          <target state="translated">더 이상 수신 할 데이터가없는 &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;trio.abc.ReceiveChannel&lt;/code&gt; &lt;/a&gt; 에서 수신하려고 할 때 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="c36d9458e0d1baae7403b5ce642a78b09e4acc7f" translate="yes" xml:space="preserve">
          <source>Raises</source>
          <target state="translated">Raises</target>
        </trans-unit>
        <trans-unit id="f3b46f6055aeafb16858767d1f89c1b6e9dfb653" translate="yes" xml:space="preserve">
          <source>Raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; means that the operation &lt;em&gt;did not happen&lt;/em&gt;. If a Trio socket&amp;rsquo;s &lt;code&gt;send&lt;/code&gt; method raises &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;, then no data was sent. If a Trio socket&amp;rsquo;s &lt;code&gt;recv&lt;/code&gt; method raises &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; then no data was lost &amp;ndash; it&amp;rsquo;s still sitting in the socket receive buffer waiting for you to call &lt;code&gt;recv&lt;/code&gt; again. And so forth.</source>
          <target state="translated">올리기 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 작업이 있음을 의미 &lt;em&gt;일어나지 않았다을&lt;/em&gt; . Trio 소켓의 &lt;code&gt;send&lt;/code&gt; 메소드가 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 데이터가 전송되지 않은 것입니다. Trio 소켓의 &lt;code&gt;recv&lt;/code&gt; 메소드가 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 를 취소 하면 데이터가 손실되지 않습니다. 여전히 &lt;code&gt;recv&lt;/code&gt; 를 다시 호출하기를 기다리는 소켓 수신 버퍼에 있습니다 . 기타 등등.</target>
        </trans-unit>
        <trans-unit id="99957346670542dddfd38b8ffe66adc228aa621a" translate="yes" xml:space="preserve">
          <source>Read some data from the underlying transport, decrypt it, and return it.</source>
          <target state="translated">기본 전송에서 일부 데이터를 읽고 해독 한 후 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="622b17203422ddf9aae4a69b56f076465c09ce46" translate="yes" xml:space="preserve">
          <source>Read-write, &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;, default &lt;a href=&quot;https://docs.python.org/3/library/constants.html#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;. So long as this is set to &lt;a href=&quot;https://docs.python.org/3/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, then the code inside this scope will not receive &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exceptions from scopes that are outside this scope. They can still receive &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exceptions from (1) this scope, or (2) scopes inside this scope. You can modify this attribute:</source>
          <target state="translated">읽기 - 쓰기, &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; , 기본 &lt;a href=&quot;https://docs.python.org/3/library/constants.html#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; . 이것이 &lt;a href=&quot;https://docs.python.org/3/library/constants.html#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 로 설정 되어있는 한이 범위 내의 코드 는이 범위 밖의 범위에서 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외를 받지 않습니다 . (1)이 범위 또는 (2)이 범위 내의 범위에서 여전히 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외를 수신 할 수 있습니다 . 이 속성을 수정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="41af808d2970aab6923b6bc6b45b747b999598be" translate="yes" xml:space="preserve">
          <source>Read-write, &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;. An absolute time on the current run&amp;rsquo;s clock at which this scope will automatically become cancelled. You can adjust the deadline by modifying this attribute, e.g.:</source>
          <target state="translated">읽기 - 쓰기, &lt;a href=&quot;https://docs.python.org/3/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; . 이 스코프가 자동으로 취소되는 현재 런 시계의 절대 시간. 이 속성을 수정하여 최종 기한을 조정할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="458a6d137741ae6f23c3a174667c35e2505c63ff" translate="yes" xml:space="preserve">
          <source>Readonly &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;. Records whether cancellation has been requested for this scope, either by an explicit call to &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt;&lt;code&gt;cancel()&lt;/code&gt;&lt;/a&gt; or by the deadline expiring.</source>
          <target state="translated">읽기 전용 &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt; &lt;code&gt;cancel()&lt;/code&gt; &lt;/a&gt; 에 대한 명시 적 호출 또는 최종 기한 만료에 의해이 범위에 대한 취소가 요청되었는지를 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="988a546c2b4be4f19c6512e225ed82a3331a45e3" translate="yes" xml:space="preserve">
          <source>Readonly &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;. Records whether this scope caught a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception. This requires two things: (1) the &lt;code&gt;with&lt;/code&gt; block exited with a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception, and (2) this scope is the one that was responsible for triggering this &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">읽기 전용 &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; . 이 범위가 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외를 잡았는지 여부를 기록합니다 . 이를 위해서는 (1) &lt;code&gt;with&lt;/code&gt; 블록이 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외로 종료 되고 (2)이 범위가이 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외 를 트리거 한 범위입니다 .</target>
        </trans-unit>
        <trans-unit id="7c5c60d4ed263e6221b1ceafb46f52538e92cf77" translate="yes" xml:space="preserve">
          <source>Real-time chat: &lt;a href=&quot;https://gitter.im/python-trio/general&quot;&gt;https://gitter.im/python-trio/general&lt;/a&gt;</source>
          <target state="translated">실시간 채팅 : &lt;a href=&quot;https://gitter.im/python-trio/general&quot;&gt;https://gitter.im/python-trio/general&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="172861d12b7ad2b9f1e7aa62cc9afb504e8366c2" translate="yes" xml:space="preserve">
          <source>Really? How is that possible?</source>
          <target state="translated">정말? 어떻게 가능합니까?</target>
        </trans-unit>
        <trans-unit id="1b67be12710ea8d6de91ade39424c9d45cc879ca" translate="yes" xml:space="preserve">
          <source>Reattach a coroutine object that was detached using &lt;a href=&quot;#trio.hazmat.temporarily_detach_coroutine_object&quot;&gt;&lt;code&gt;temporarily_detach_coroutine_object()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.hazmat.temporarily_detach_coroutine_object&quot;&gt; &lt;code&gt;temporarily_detach_coroutine_object()&lt;/code&gt; &lt;/a&gt; 사용하여 분리 된 코 루틴 객체를 다시 연결하십시오 .</target>
        </trans-unit>
        <trans-unit id="d82d4c2d1a2b3c4402ec7189cf603fbfe9b6dae2" translate="yes" xml:space="preserve">
          <source>Reattach a coroutine object that was detached using &lt;a href=&quot;#trio.lowlevel.temporarily_detach_coroutine_object&quot;&gt;&lt;code&gt;temporarily_detach_coroutine_object()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.lowlevel.temporarily_detach_coroutine_object&quot;&gt; &lt;code&gt;temporarily_detach_coroutine_object()&lt;/code&gt; &lt;/a&gt; 사용하여 분리 된 코 루틴 객체를 다시 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="6b2f36e5ce6c6da01323540a9b37cff6c1903ffd" translate="yes" xml:space="preserve">
          <source>Regardless of these shenanigans, from &amp;ldquo;inside&amp;rdquo; Trio the passage of time still seems normal so long as you restrict yourself to Trio&amp;rsquo;s time functions (see &lt;a href=&quot;reference-core#time-and-clocks&quot;&gt;Time and clocks&lt;/a&gt;). Below is an example demonstrating two different ways of making time pass quickly. Notice how in both cases, the two tasks keep a consistent view of reality and events happen in the expected order, despite being wildly divorced from real time:</source>
          <target state="translated">이러한 shenanigans에 관계없이&amp;ldquo;내부&amp;rdquo;Trio에서 시간의 흐름은 사용자가 Trio의 시간 함수 ( &lt;a href=&quot;reference-core#time-and-clocks&quot;&gt;시간 및 시계&lt;/a&gt; 참조)로 제한되는 한 여전히 정상적인 것처럼 보입니다 . 아래는 시간이 빨리 지나가는 두 가지 방법을 보여주는 예입니다. 두 경우 모두 두 가지 작업이 어떻게 현실과 일관된 시각을 유지하고 실시간에서 크게 이혼하더라도 이벤트가 예상 순서대로 발생하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="795fd0408cfdff7a235327985444734ec64c8053" translate="yes" xml:space="preserve">
          <source>Regular (synchronous) functions never contain any checkpoints.</source>
          <target state="translated">일반 (동기식) 기능에는 검사 점이 절대 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5044ba0a5cf607ebea4e58623c6417cb87f682bb" translate="yes" xml:space="preserve">
          <source>Release history</source>
          <target state="translated">출시 역사</target>
        </trans-unit>
        <trans-unit id="b5e4913e6b00fb0411556eedb8df5d4e15248e9e" translate="yes" xml:space="preserve">
          <source>Release the lock.</source>
          <target state="translated">잠금을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="dfdddac609bc6525864a46420d173e2db58b56da" translate="yes" xml:space="preserve">
          <source>Release the underlying lock.</source>
          <target state="translated">기본 잠금을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="7416201cbf641c4c1cce64a7552e96979b9781a3" translate="yes" xml:space="preserve">
          <source>Represents a stream given the file descriptor to a pipe, TTY, etc.</source>
          <target state="translated">파이프, TTY 등에 파일 디스크립터가 제공된 스트림을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ffed6ffb11cd49ae283b146510b560db62b29b16" translate="yes" xml:space="preserve">
          <source>Reschedule the given task with the given &lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt;&lt;code&gt;outcome.Outcome&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진으로 주어진 작업 일정 변경 &lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt; &lt;code&gt;outcome.Outcome&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b80f008c17db60050b84c4982691f26b5d7ebd4" translate="yes" xml:space="preserve">
          <source>Resource handling:</source>
          <target state="translated">자원 처리 :</target>
        </trans-unit>
        <trans-unit id="f49ed1f90b5319324c89fc4cdc67d98d1d4982c1" translate="yes" xml:space="preserve">
          <source>Retrieve the &lt;a href=&quot;#trio.hazmat.TrioToken&quot;&gt;&lt;code&gt;TrioToken&lt;/code&gt;&lt;/a&gt; for the current call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 에 대한 현재 호출에 대한 &lt;a href=&quot;#trio.hazmat.TrioToken&quot;&gt; &lt;code&gt;TrioToken&lt;/code&gt; &lt;/a&gt; 을 검색하십시오 .</target>
        </trans-unit>
        <trans-unit id="66792bcbc1473b701de71be6f42b8e92ae36b2b4" translate="yes" xml:space="preserve">
          <source>Retrieve the &lt;a href=&quot;#trio.lowlevel.TrioToken&quot;&gt;&lt;code&gt;TrioToken&lt;/code&gt;&lt;/a&gt; for the current call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 에 대한 현재 호출에 대한 &lt;a href=&quot;#trio.lowlevel.TrioToken&quot;&gt; &lt;code&gt;TrioToken&lt;/code&gt; &lt;/a&gt; 을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="36c54ed6ac80bc981ae8ce5652b7aa7a424a0fb5" translate="yes" xml:space="preserve">
          <source>Retrieves data from the internal buffer, blocking if necessary.</source>
          <target state="translated">내부 버퍼에서 데이터를 검색하여 필요한 경우 차단합니다.</target>
        </trans-unit>
        <trans-unit id="080bc476ce5968af592b5c6db511e128987c5764" translate="yes" xml:space="preserve">
          <source>Retrieves data from the internal buffer, but doesn&amp;rsquo;t block.</source>
          <target state="translated">내부 버퍼에서 데이터를 검색하지만 차단하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e1a7dbd8e538a02d36f4201744cfd7c212b56c8" translate="yes" xml:space="preserve">
          <source>Return True if the path contains one of the special names reserved by the system, if any.</source>
          <target state="translated">경로에 시스템이 예약 한 특수 이름 중 하나가 있으면 경로를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="2b7de1c01e3639d70c1301781596a03564716748" translate="yes" xml:space="preserve">
          <source>Return True if this path matches the given pattern.</source>
          <target state="translated">이 패스가 지정된 패턴과 일치하면 True를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2c683d81b2e6785afd626708cbea723554ad9f98" translate="yes" xml:space="preserve">
          <source>Return a context manager that catches and re-throws exceptions after running &lt;a href=&quot;#trio.MultiError.filter&quot;&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/a&gt; on them.</source>
          <target state="translated">&lt;a href=&quot;#trio.MultiError.filter&quot;&gt; &lt;code&gt;filter()&lt;/code&gt; &lt;/a&gt; 를 실행 한 후 예외를 포착하고 다시 발생시키는 컨텍스트 관리자를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="74511c6068e3de9f3c1e1c2e39a44b3f12a40aef" translate="yes" xml:space="preserve">
          <source>Return a new path with the file name changed.</source>
          <target state="translated">파일 이름이 변경된 새 경로를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="a4759abd8edb019bf0eb31c08f831d77c495f661" translate="yes" xml:space="preserve">
          <source>Return a new path with the file suffix changed (or added, if none).</source>
          <target state="translated">파일 접미사가 변경되었거나없는 경우 추가 된 새 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ac965bd810cca2d151b9c317c0c1f717fdc23a4a" translate="yes" xml:space="preserve">
          <source>Return a new path with the file suffix changed. If the path has no suffix, add given suffix. If the given suffix is an empty string, remove the suffix from the path.</source>
          <target state="translated">파일 접미사가 변경된 새 경로를 반환합니다. 경로에 접미사가 없으면 주어진 접미사를 추가합니다. 주어진 접미사가 빈 문자열이면 경로에서 접미사를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="8ce261ae05a052a4b5be129bb11ccb492e6a1503" translate="yes" xml:space="preserve">
          <source>Return an object containing debugging information.</source>
          <target state="translated">디버깅 정보가 포함 된 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9e2277903dc895b3ac624e58f32470f044f28fb7" translate="yes" xml:space="preserve">
          <source>Return the &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object representing the current task.</source>
          <target state="translated">현재 작업을 나타내는 &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 개체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ffc01c08a6086dd43715f1c09998f077de8e82d4" translate="yes" xml:space="preserve">
          <source>Return the &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object representing the current task.</source>
          <target state="translated">현재 작업을 나타내는 &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 개체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="40cff98535909e183f92699de8527946109d976c" translate="yes" xml:space="preserve">
          <source>Return the current time, according to this clock.</source>
          <target state="translated">이 시계에 따라 현재 시간을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="b9db5a47ba6655c11616c8e26b190ca54f43e5a1" translate="yes" xml:space="preserve">
          <source>Return the current value of the internal flag.</source>
          <target state="translated">내부 플래그의 현재 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6de731f34f98b206fa3aeb0d1060258ec569f0dd" translate="yes" xml:space="preserve">
          <source>Return the path as a &amp;lsquo;file&amp;rsquo; URI.</source>
          <target state="translated">경로를 '파일'URI로 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="b492c123430d5d95ccde60278f71b4c1ea4e2eec" translate="yes" xml:space="preserve">
          <source>Return the relative path to another path identified by the passed arguments. If the operation is not possible (because this is not a subpath of the other path), raise ValueError.</source>
          <target state="translated">전달 된 인수로 식별 된 다른 경로의 상대 경로를 리턴하십시오. 작업이 불가능한 경우 (이 경로는 다른 경로의 하위 경로가 아니기 때문에) ValueError를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="8aff8be4dee4d25bccba9aa66ee0802992b16399" translate="yes" xml:space="preserve">
          <source>Return the string representation of the path with forward (/) slashes.</source>
          <target state="translated">슬래시 (/)를 사용하여 경로의 문자열 표현을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="41b1fb407b7fa442b77381701968fb175362cf78" translate="yes" xml:space="preserve">
          <source>Return type</source>
          <target state="translated">반품 유형</target>
        </trans-unit>
        <trans-unit id="9582a02f141fc4b345b2936eba691cd0654efebc" translate="yes" xml:space="preserve">
          <source>Returns</source>
          <target state="translated">Returns</target>
        </trans-unit>
        <trans-unit id="c96e2a604937c0e7bde09850d1e81c88f183872e" translate="yes" xml:space="preserve">
          <source>Returns an async context manager which must be used to create a new &lt;a href=&quot;#trio.Nursery&quot;&gt;&lt;code&gt;Nursery&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새로운 &lt;a href=&quot;#trio.Nursery&quot;&gt; &lt;code&gt;Nursery&lt;/code&gt; &lt;/a&gt; 를 만드는 데 사용해야하는 비동기 컨텍스트 관리자를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="80c3bba28aba9ac5aa2b9e543b569c7c5f7fea4f" translate="yes" xml:space="preserve">
          <source>Returns an object containing run-loop-level debugging information.</source>
          <target state="translated">실행 루프 수준 디버깅 정보가 포함 된 개체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2cb60cb3bef90903444e5b5db55efe97c53982f7" translate="yes" xml:space="preserve">
          <source>Returns or raises whatever the given function returns or raises. It can also raise exceptions of its own:</source>
          <target state="translated">주어진 함수가 리턴하거나 올린 것을 리턴하거나 올립니다. 또한 자체 예외를 제기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa20168c5bc2ca247ebd21af6add01da22b9fffa" translate="yes" xml:space="preserve">
          <source>Returns or raises whatever value or exception the new coroutine runner uses to resume the coroutine.</source>
          <target state="translated">새로운 코 루틴 러너가 코 루틴을 재개하기 위해 사용하는 모든 값 또는 예외를 반환하거나 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="20294a5b79e17adf4e2aab73007106887f91c20b" translate="yes" xml:space="preserve">
          <source>Returns the current &lt;a href=&quot;reference-core#trio.abc.Clock&quot;&gt;&lt;code&gt;Clock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 &lt;a href=&quot;reference-core#trio.abc.Clock&quot;&gt; &lt;code&gt;Clock&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="679a2125dd0230bf3c09de4ff94a0c29225879ae" translate="yes" xml:space="preserve">
          <source>Returns the current effective deadline for the current task.</source>
          <target state="translated">현재 작업에 대한 현재 유효 마감 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="49f9754b2c2c4e3016fdc4a20e1aa41028fdabce" translate="yes" xml:space="preserve">
          <source>Returns the current root &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 루트 &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f26d907db25ce85ad64fed0bf0492134d89dd298" translate="yes" xml:space="preserve">
          <source>Returns the current root &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 루트 &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; 를&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3612705c9bdde6883ff6d46dc9b98bfbf29c4eae" translate="yes" xml:space="preserve">
          <source>Returns the current time according to Trio&amp;rsquo;s internal clock.</source>
          <target state="translated">Trio의 내부 시계에 따라 현재 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7878f5fff79cb7db6499b67fc37025bc26400d93" translate="yes" xml:space="preserve">
          <source>Returns the exit status of the process (an integer), or &lt;code&gt;None&lt;/code&gt; if it&amp;rsquo;s still running.</source>
          <target state="translated">프로세스의 종료 상태 (정수)를 반환하거나 아직 실행중인 경우 &lt;code&gt;None&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e44dffb19df07ef8414c3c376c6a86a1a10a965c" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;command&lt;/code&gt; in a subprocess, wait for it to complete, and return a &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;subprocess.CompletedProcess&lt;/code&gt;&lt;/a&gt; instance describing the results.</source>
          <target state="translated">서브 프로세스에서 &lt;code&gt;command&lt;/code&gt; 을 실행 하고 완료 될 때까지 기다린 후 결과를 설명 하는 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;subprocess.CompletedProcess&lt;/code&gt; &lt;/a&gt; 인스턴스를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b56c81b5d7d12e057ce71207675707f4d4076b3" translate="yes" xml:space="preserve">
          <source>Run a Trio-flavored async function, and return the result.</source>
          <target state="translated">Trio 풍미가있는 비동기 함수를 실행하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3069c0b08119487d8f7d1632a416d89c4e11b6b0" translate="yes" xml:space="preserve">
          <source>Run all the user tasks that care about whatever happened, then go back to step 1.</source>
          <target state="translated">무슨 일이 있었는지 관심이있는 모든 사용자 작업을 실행 한 다음 1 단계로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="174632bdc2efcc209e6ec485f5e4d89bb42f99f2" translate="yes" xml:space="preserve">
          <source>Run the given async function in the parent Trio thread, blocking until it is complete.</source>
          <target state="translated">부모 트리오 스레드에서 지정된 비동기 기능을 실행하여 완료 될 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="28b11b8b05a27dee7e81c6c4786ce2373923cc39" translate="yes" xml:space="preserve">
          <source>Run the given sync function in the parent Trio thread, blocking until it is complete.</source>
          <target state="translated">주어진 동기화 기능을 상위 Trio 스레드에서 실행하고 완료 될 때까지 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="34ee226c47ee6762c22038b1355ef784957e69c9" translate="yes" xml:space="preserve">
          <source>Running a process and waiting for it to finish</source>
          <target state="translated">프로세스 실행 및 완료 대기</target>
        </trans-unit>
        <trans-unit id="406df0a14f42befaa2bb7b1d46dd4d5add32f410" translate="yes" xml:space="preserve">
          <source>Runs &lt;code&gt;deliver(outcome.capture(fn))&lt;/code&gt; in a worker thread.</source>
          <target state="translated">작업자 스레드에서 &lt;code&gt;deliver(outcome.capture(fn))&lt;/code&gt; 를 실행 합니다 .</target>
        </trans-unit>
        <trans-unit id="28b93c4a93cb10440b0c2043a668f9b2550390d8" translate="yes" xml:space="preserve">
          <source>SSL / TLS support</source>
          <target state="translated">SSL / TLS 지원</target>
        </trans-unit>
        <trans-unit id="489409f79750bf468b370ea47ddb451641966d82" translate="yes" xml:space="preserve">
          <source>Safer KeyboardInterrupt handling</source>
          <target state="translated">안전한 키보드 인터럽트 처리</target>
        </trans-unit>
        <trans-unit id="c1463bcfc0ca2f582b52b93c0e116a9d627535ee" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;#trio.testing.MemoryReceiveStream.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.MemoryReceiveStream.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 비동기입니다.</target>
        </trans-unit>
        <trans-unit id="78d9d80923f156d407da12642698cb124013560a" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;#trio.testing.MemorySendStream.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt;, but async.</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.MemorySendStream.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 비동기입니다.</target>
        </trans-unit>
        <trans-unit id="41dd02db4d1d296325376880af0f9c7686740d69" translate="yes" xml:space="preserve">
          <source>Schedule a call to &lt;code&gt;sync_fn(*args)&lt;/code&gt; to occur in the context of a Trio task.</source>
          <target state="translated">Trio 작업의 컨텍스트에서 &lt;code&gt;sync_fn(*args)&lt;/code&gt; 에 대한 호출이 발생하도록 예약하십시오 .</target>
        </trans-unit>
        <trans-unit id="4651a34e4df9619783ad372f905d6d3b84e9d76d" translate="yes" xml:space="preserve">
          <source>Scope</source>
          <target state="translated">Scope</target>
        </trans-unit>
        <trans-unit id="43ddf283f03fda4643fe2db02659e6fb64a89999" translate="yes" xml:space="preserve">
          <source>Search Page</source>
          <target state="translated">검색 페이지</target>
        </trans-unit>
        <trans-unit id="80b5d0fdd320e64dcfebdd2de89e39320073fa6c" translate="yes" xml:space="preserve">
          <source>Second, it avoids a small race condition that could cause too many threads to be spawned. Consider a program that wants to run several jobs sequentially on a thread, so the main thread submits a job, waits for it to finish, submits another job, etc. In theory, this program should only need one worker thread. But what could happen is:</source>
          <target state="translated">둘째, 너무 많은 스레드가 생성 될 수있는 작은 경합 상태를 방지합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 스레드에서 여러 작업을 순차적으로 실행하려는 프로그램을 생각해보십시오. 따라서 주 스레드는 작업을 제출하고, 완료 될 때까지 대기하고, 다른 작업을 제출하는 등의 작업을 수행합니다. 이론적으로이 프로그램에는 하나의 작업자 스레드 만 필요합니다. 그러나 일어날 수있는 일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="df039209c5e4aa55542bc5803836ccf099d8bfd1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e621a2c3de8ee6dee87fb0fe1692f8bfdce4856" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt;&lt;code&gt;trio.abc.Listener.accept()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#trio.abc.Listener.accept&quot;&gt; &lt;code&gt;trio.abc.Listener.accept()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="73fe6c344e72648d421d8761612fae248f51b59c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt;&lt;code&gt;trio.abc.ReceiveStream.receive_some()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt; &lt;code&gt;trio.abc.ReceiveStream.receive_some()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c5d2965756a1219162c7b103b7912b613c75d332" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;trio.abc.SendStream.send_all()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;trio.abc.SendStream.send_all()&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6dee4e334c48c5ee0fa6e7c0ee8c33b4b0f14005" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;trio.abc.SendStream.wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;trio.abc.SendStream.wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="90cbf068fcbe2871096db617137f8324a4d715a8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.hazmat.ParkingLot.repark&quot;&gt;&lt;code&gt;repark()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#trio.hazmat.ParkingLot.repark&quot;&gt; &lt;code&gt;repark()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d7d9cdee543f24de74e0f6d27ef26632818b0ba4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.hazmat.wait_readable&quot;&gt;&lt;code&gt;wait_readable&lt;/code&gt;&lt;/a&gt; for the definition of &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 정의에 대해서는 &lt;a href=&quot;#trio.hazmat.wait_readable&quot;&gt; &lt;code&gt;wait_readable&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="88cef7e47405de4633e88af131cdd34ba4e03bc8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="651cf48dfdd28ee21722da4947614b8beb329452" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; for the gory details.</source>
          <target state="translated">&lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 세부 사항 은 wait_task_rescheduled () 를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="6338a66d131ec077fd5cf4994f6ac8bc5a3607e5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.lowlevel.ParkingLot.repark&quot;&gt;&lt;code&gt;repark()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#trio.lowlevel.ParkingLot.repark&quot;&gt; &lt;code&gt;repark()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5f062d4e4c9b77a3f837df4dc406fce877af582d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.lowlevel.wait_readable&quot;&gt;&lt;code&gt;wait_readable&lt;/code&gt;&lt;/a&gt; for the definition of &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 정의에 대해서는 &lt;a href=&quot;#trio.lowlevel.wait_readable&quot;&gt; &lt;code&gt;wait_readable&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b1d56927b75db5a5d6b3b5859efab6f226dc4e5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c9cf5378d0030c81aa5834f4e0b4d32c351240ce" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; for the gory details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="016a67642a7abe850f2386f09f565400bd916ea3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.socket.set_custom_hostname_resolver&quot;&gt;&lt;code&gt;trio.socket.set_custom_hostname_resolver()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.socket.set_custom_hostname_resolver&quot;&gt; &lt;code&gt;trio.socket.set_custom_hostname_resolver()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fcf3667ecc461134130b73df4a3a1d6ca1ac4046" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.socket.set_custom_socket_factory&quot;&gt;&lt;code&gt;trio.socket.set_custom_socket_factory()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.socket.set_custom_socket_factory&quot;&gt; &lt;code&gt;trio.socket.set_custom_socket_factory()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc3b685f1d1be464dec386dc17d73a54dacf00d6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#trio.testing.MemorySendStream.get_data&quot;&gt;&lt;code&gt;get_data()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#trio.testing.MemorySendStream.get_data&quot;&gt; &lt;code&gt;get_data()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4f274048841d456d97381e6b6644e2472a7ccda0" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.getsockopt&quot;&gt;&lt;code&gt;socket.socket.getsockopt()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.getsockopt&quot;&gt; &lt;code&gt;socket.socket.getsockopt()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f6839040a73e62c001a4d5d6b3a8b294c0e57bdc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.setsockopt&quot;&gt;&lt;code&gt;socket.socket.setsockopt()&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.setsockopt&quot;&gt; &lt;code&gt;socket.socket.setsockopt()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2d72e5152dd898769a56b0fe337a4d1a861b2fea" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;ReceiveChannel.receive&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;ReceiveChannel.receive&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="58963e593c50f94f790638ce7556a275bcd204f2" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;SendChannel.send&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;SendChannel.send&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="f42e748c32f2195bd9faf81004af69032f05fc79" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#trio.aclose_forcefully&quot;&gt;&lt;code&gt;trio.aclose_forcefully()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.aclose_forcefully&quot;&gt; &lt;code&gt;trio.aclose_forcefully()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="158e95efe6c006cd04a0b4b2d0f6161646c045e5" translate="yes" xml:space="preserve">
          <source>Send an end-of-file indication on this stream, if possible.</source>
          <target state="translated">가능하면이 스트림에서 파일 끝 표시를 보내십시오.</target>
        </trans-unit>
        <trans-unit id="85da9214bbeac1196611983abddcebb768d2fc49" translate="yes" xml:space="preserve">
          <source>Send signal &lt;code&gt;sig&lt;/code&gt; to the process.</source>
          <target state="translated">신호 &lt;code&gt;sig&lt;/code&gt; 를 프로세스로 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="e634d246bcec48e110a516c9e0d7d7b2041045d0" translate="yes" xml:space="preserve">
          <source>Sends the given data through the stream, blocking if necessary.</source>
          <target state="translated">주어진 데이터를 스트림을 통해 전송하고 필요한 경우 차단합니다.</target>
        </trans-unit>
        <trans-unit id="ee954ecd822c7acfded07c0cc1fd9c091103b687" translate="yes" xml:space="preserve">
          <source>Set a custom hostname resolver.</source>
          <target state="translated">사용자 정의 호스트 이름 확인자를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="62fd9617b6da2daed723cb8babe107460a7aae70" translate="yes" xml:space="preserve">
          <source>Set a custom socket object factory.</source>
          <target state="translated">사용자 정의 소켓 객체 팩토리를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="5f98ea86f41a048ead986b6dc184184bdc19c8ce" translate="yes" xml:space="preserve">
          <source>Set an option on the underlying socket.</source>
          <target state="translated">기본 소켓에서 옵션을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="d7151175b4f06e30011860dd29520ea7ed6e51f2" translate="yes" xml:space="preserve">
          <source>Set the internal flag value to True, and wake any waiting tasks.</source>
          <target state="translated">내부 플래그 값을 True로 설정하고 대기중인 작업을 깨 웁니다.</target>
        </trans-unit>
        <trans-unit id="0ff0e99264a92cdda9a69ac291e7a0266785bdd2" translate="yes" xml:space="preserve">
          <source>Setting a custom hostname resolver affects all future calls to &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt;&lt;code&gt;getnameinfo()&lt;/code&gt;&lt;/a&gt; within the enclosing call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;. All other hostname resolution in Trio is implemented in terms of these functions.</source>
          <target state="translated">사용자 정의 호스트 이름 분석기를 설정하면 이후의 &lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 호출 내 &lt;a href=&quot;reference-io#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;reference-io#trio.socket.getnameinfo&quot;&gt; &lt;code&gt;getnameinfo()&lt;/code&gt; &lt;/a&gt; 에 대한 모든 호출에 영향을줍니다 . Trio의 다른 모든 호스트 이름 확인은 이러한 기능 측면에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="9f5e3bbf7985a9dab01cc08204725bd79c4bf118" translate="yes" xml:space="preserve">
          <source>Setting a custom socket factory affects all future calls to &lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt;&lt;code&gt;socket()&lt;/code&gt;&lt;/a&gt; within the enclosing call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 소켓 팩토리를 설정하면 나중에 &lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 호출 내 &lt;a href=&quot;reference-io#trio.socket.socket&quot;&gt; &lt;code&gt;socket()&lt;/code&gt; &lt;/a&gt; 에 대한 모든 호출에 영향을 미칩니다 .</target>
        </trans-unit>
        <trans-unit id="b5f69ef7d9833414a1ee8b90a0835b9fff2745ad" translate="yes" xml:space="preserve">
          <source>Shuts down the send side of the stream.</source>
          <target state="translated">스트림의 송신 측을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="2346a18ea3002ff04eca3a130c7f40e65c56f0c9" translate="yes" xml:space="preserve">
          <source>Signals</source>
          <target state="translated">Signals</target>
        </trans-unit>
        <trans-unit id="8b3df0abd55afcfcab7033b5dc2c6d404832e669" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.connect&quot;&gt;&lt;code&gt;socket.socket.connect()&lt;/code&gt;&lt;/a&gt;, except async.</source>
          <target state="translated">비동기를 제외하고 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket.connect&quot;&gt; &lt;code&gt;socket.socket.connect()&lt;/code&gt; &lt;/a&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="ff3c0775338ca43ecdf1b17d743dad954391ca69" translate="yes" xml:space="preserve">
          <source>Simple integration and broad compatibility: pretty much every event loop offers some threadsafe &amp;ldquo;schedule a callback&amp;rdquo; operation, and that&amp;rsquo;s all you need to use it as a host loop.</source>
          <target state="translated">간단한 통합 및 광범위한 호환성 : 거의 모든 이벤트 루프가 스레드로부터 안전한 &quot;콜백 예약&quot;작업을 제공하며, 이것이 호스트 루프로 사용하는 데 필요한 전부입니다.</target>
        </trans-unit>
        <trans-unit id="195fcbdedfbd716b2508e3c94ddbf5266f253623" translate="yes" xml:space="preserve">
          <source>Since all of the tasks are running concurrently inside the &lt;code&gt;async
with&lt;/code&gt; block, the block does not exit until &lt;em&gt;all&lt;/em&gt; tasks have completed. If you&amp;rsquo;ve used other concurrency frameworks, then you can think of it as, the de-indentation at the end of the &lt;code&gt;async with&lt;/code&gt; automatically &amp;ldquo;joins&amp;rdquo; (waits for) all of the tasks in the nursery.</source>
          <target state="translated">모든 작업이 내부에서 동시에 실행되기 때문에 &lt;code&gt;async with&lt;/code&gt; 때까지 블록, 블록이 종료되지 않는 &lt;em&gt;모든&lt;/em&gt; 작업이 완료되었습니다. 다른 동시성 프레임 워크를 사용한 경우 &lt;code&gt;async with&lt;/code&gt; 끝에서 비인 덴 테이션 이 보육원의 모든 작업 을 자동으로 &quot;결합&quot;(대기) 하는 것으로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e123adcb2343580f3c45b40dc7e669799bca848" translate="yes" xml:space="preserve">
          <source>Since all tasks are descendents of the initial task, one consequence of this is that &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; can&amp;rsquo;t finish until all tasks have finished.</source>
          <target state="translated">모든 작업은 초기 작업의 후손이므로 모든 작업이 완료 될 때까지 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 을 완료 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ccb2ec4f90e25bdaf10ffc4e52048eb34a6ada6d" translate="yes" xml:space="preserve">
          <source>Since process creation takes a single arguments string, &lt;code&gt;CMD.EXE&lt;/code&gt;&amp;rsquo;s quoting does not influence word splitting, and double quotes are not removed during CMD.EXE&amp;rsquo;s expansion pass. Double quotes are troublesome because CMD.EXE handles them differently from the MSVC runtime rules; in:</source>
          <target state="translated">프로세스 생성에는 단일 인수 문자열이 사용되므로 &lt;code&gt;CMD.EXE&lt;/code&gt; 의 인용은 단어 분리에 영향을 미치지 않으며 CMD.EXE의 확장 단계에서 큰 따옴표는 제거되지 않습니다. 큰 따옴표는 CMD.EXE가 MSVC 런타임 규칙과 다르게 처리하기 때문에 번거 롭습니다. 에:</target>
        </trans-unit>
        <trans-unit id="0645778ef10db9cd86497528da43c38ced2e921f" translate="yes" xml:space="preserve">
          <source>Since process creation takes a single arguments string, &lt;code&gt;CMD.EXE&lt;/code&gt;'s quoting does not influence word splitting, and double quotes are not removed during CMD.EXE&amp;rsquo;s expansion pass. Double quotes are troublesome because CMD.EXE handles them differently from the MSVC runtime rules; in:</source>
          <target state="translated">프로세스 생성은 단일 인수 문자열을 사용하므로 &lt;code&gt;CMD.EXE&lt;/code&gt; 의 인용은 단어 분할에 영향을주지 않으며 CMD.EXE의 확장 단계 동안 큰 따옴표가 제거되지 않습니다. 큰 따옴표는 CMD.EXE가 MSVC 런타임 규칙과 다르게 처리하므로 문제가됩니다. 에:</target>
        </trans-unit>
        <trans-unit id="1e290ea0e39f01d4b842c1a165cd9781b38eb4ba" translate="yes" xml:space="preserve">
          <source>Since this hooks into Trio at a rather low level, you do have to be careful. The callbacks are run synchronously, and in many cases if they error out then there isn&amp;rsquo;t any plausible way to propagate this exception (for instance, we might be deep in the guts of the exception propagation machinery&amp;hellip;). Therefore our &lt;a href=&quot;https://github.com/python-trio/trio/issues/47&quot;&gt;current strategy&lt;/a&gt; for handling exceptions raised by instruments is to (a) log an exception to the &lt;code&gt;&quot;trio.abc.Instrument&quot;&lt;/code&gt; logger, which by default prints a stack trace to standard error and (b) disable the offending instrument.</source>
          <target state="translated">이것은 다소 낮은 수준에서 Trio에 연결되므로주의해야합니다. 콜백은 동기식으로 실행되며, 대부분의 경우 오류가 발생하면이 예외를 전파 할 수있는 적절한 방법이 없습니다 (예를 들어, 예외 전파 메커니즘의 장에서 깊을 수 있습니다). 따라서 계측기에서 발생하는 예외를 처리 &lt;a href=&quot;https://github.com/python-trio/trio/issues/47&quot;&gt;하기&lt;/a&gt; 위한 현재 전략 은 (a) &lt;code&gt;&quot;trio.abc.Instrument&quot;&lt;/code&gt; 로거에 예외를 기록하는 것으로, 기본적으로 스택 추적을 표준 오류에 인쇄하고 (b) 문제가있는 계측기를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="703d59254915506775b33344a3a18adcf8c5850f" translate="yes" xml:space="preserve">
          <source>Sleeping and waking</source>
          <target state="translated">잠자기</target>
        </trans-unit>
        <trans-unit id="79b43696209af601ceb794aac489696d99bde999" translate="yes" xml:space="preserve">
          <source>So far, so good. Unfortunately, Python provides no guarantees about &lt;em&gt;when&lt;/em&gt; this happens. It could be as soon as you break out of the &lt;code&gt;async for&lt;/code&gt; loop, or an arbitrary amount of time later. It could even be after the entire Trio run has finished! Just about the only guarantee is that it &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; happen in the task that was using the generator. That task will continue on with whatever else it&amp;rsquo;s doing, and the async generator cleanup will happen &amp;ldquo;sometime later, somewhere else&amp;rdquo;: potentially with different context variables, not subject to timeouts, and/or after any nurseries you&amp;rsquo;re using have been closed.</source>
          <target state="translated">여태까지는 그런대로 잘됐다. 불행히도 파이썬은 이것이 &lt;em&gt;언제&lt;/em&gt; 발생 하는지에 대해 보장하지 않습니다 . &lt;code&gt;async for&lt;/code&gt; 루프에서 벗어나 자마자 또는 나중에 임의의 시간이 될 수 있습니다. 전체 트리오 실행이 완료된 후일 수도 있습니다! 유일한 보장은 생성기를 사용하는 작업에서 발생 &lt;em&gt;하지 않는다는&lt;/em&gt; 것입니다. 이 작업은 다른 작업으로 계속 진행되며 비동기 생성기 정리는 &quot;언젠가 나중에 다른 곳에서&quot;발생합니다. 잠재적으로 다른 컨텍스트 변수를 사용하여 제한 시간이 적용되지 않고 / 또는 사용중인 모든 nursery가 닫힌 후에 발생합니다. .</target>
        </trans-unit>
        <trans-unit id="177046c4af35e4336df197889f9ee07eb5aa6ce4" translate="yes" xml:space="preserve">
          <source>So long as you&amp;rsquo;re inside a scope with &lt;code&gt;shield = True&lt;/code&gt; set, then you&amp;rsquo;ll be protected from outside cancellations. Note though that this &lt;em&gt;only&lt;/em&gt; applies to &lt;em&gt;outside&lt;/em&gt; cancellations: if &lt;code&gt;CLEANUP_TIMEOUT&lt;/code&gt; expires then &lt;code&gt;await conn.send_goodbye_msg()&lt;/code&gt; will still be cancelled, and if &lt;code&gt;await conn.send_goodbye_msg()&lt;/code&gt; call uses any timeouts internally, then those will continue to work normally as well. This is a pretty advanced feature that most people probably won&amp;rsquo;t use, but it&amp;rsquo;s there for the rare cases where you need it.</source>
          <target state="translated">&lt;code&gt;shield = True&lt;/code&gt; 설정된 범위 안에 있으면 외부 취소로부터 보호됩니다. 그러나 이는 &lt;em&gt;외부&lt;/em&gt; 취소 &lt;em&gt;에만&lt;/em&gt; 적용됩니다 . &lt;code&gt;CLEANUP_TIMEOUT&lt;/code&gt; 이 만료되면 &lt;code&gt;await conn.send_goodbye_msg()&lt;/code&gt; 가 여전히 취소되고 &lt;code&gt;await conn.send_goodbye_msg()&lt;/code&gt; 호출이 내부적으로 시간 초과를 사용하는 경우 계속 정상적으로 작동합니다. 이것은 대부분의 사람들이 사용하지 않을 꽤 고급 기능이지만, 필요한 경우가 거의 없습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eacc0cea5faa2540efcfce1aec9fc9bc5a14d8d1" translate="yes" xml:space="preserve">
          <source>So that&amp;rsquo;s great, but &amp;ndash; how do we know whether we&amp;rsquo;re in one of the sensitive parts of the program or not?</source>
          <target state="translated">우리는 프로그램의 민감한 부분에 있는지 여부를 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="8a08024d671c4e56a036c4b52ad5c32416c73f48" translate="yes" xml:space="preserve">
          <source>So when you&amp;rsquo;re doing code review on a project that uses Trio, one of the things you&amp;rsquo;ll want to think about is whether there are enough checkpoints, and whether each one is handled correctly. Of course this means you need a way to recognize checkpoints. How do you do that? The underlying principle is that any operation that blocks has to be a checkpoint. This makes sense: if an operation blocks, then it might block for a long time, and you&amp;rsquo;ll want to be able to cancel it if a timeout expires; and in any case, while this task is blocked we want another task to be scheduled to run so our code can make full use of the CPU.</source>
          <target state="translated">따라서 Trio를 사용하는 프로젝트에서 코드 검토를 수행 할 때 고려해야 할 사항 중 하나는 충분한 체크 포인트가 있는지 여부와 각각이 올바르게 처리되는지 여부입니다. 물론 이것은 체크 포인트를 인식 할 수있는 방법이 필요하다는 것을 의미합니다. 어떻게합니까? 기본 원칙은 차단하는 모든 작업이 검사 점이어야한다는 것입니다. 작업이 차단되면 장시간 차단 될 수 있으며 시간 초과가 만료되면 취소 할 수 있습니다. 어쨌든이 작업이 차단되는 동안 코드가 CPU를 최대한 활용할 수 있도록 다른 작업이 실행되도록 예약하려고합니다.</target>
        </trans-unit>
        <trans-unit id="94f1cedea7c4796760fe90eed253e295e38abb27" translate="yes" xml:space="preserve">
          <source>So you can see that the producer runs ahead by 3 messages, and then stops to wait: when the consumer reads message 1, it sends message 4, then when the consumer reads message 2, it sends message 5, and so on. Once it reaches the steady state, this version acts just like our previous version where we set the buffer size to 0, except that it uses a bit more memory and each message sits in the buffer for a bit longer before being processed (i.e., the message latency is higher).</source>
          <target state="translated">따라서 생산자가 3 개의 메시지보다 먼저 실행 한 다음 대기를 중지한다는 것을 알 수 있습니다. 소비자가 메시지 1을 읽을 때 메시지 4를 보낸 다음 소비자가 메시지 2를 읽을 때 메시지 5를 보내는 방식 등입니다. 정상 상태에 도달하면이 버전은 이전 버전과 동일하게 작동하여 버퍼 크기를 0으로 설정합니다. 단, 더 많은 메모리를 사용하고 각 메시지는 처리되기 전에 조금 더 오래 버퍼에 있습니다. 메시지 대기 시간이 더 깁니다).</target>
        </trans-unit>
        <trans-unit id="daa57596ade9bdcbd1f251fa5b9ed91ad7cb1852" translate="yes" xml:space="preserve">
          <source>So, we can see that it&amp;rsquo;s important to be able to change the policy controlling the allocation of threads to jobs. But in many frameworks, this requires implementing a new thread pool from scratch, which is highly non-trivial; and if different types of jobs need different policies, then you may have to create multiple pools, which is inefficient because now you effectively have two different thread caches that aren&amp;rsquo;t sharing resources.</source>
          <target state="translated">따라서 스레드 할당을 제어하는 ​​정책을 작업에 변경하는 것이 중요하다는 것을 알 수 있습니다. 그러나 많은 프레임 워크에서 새로운 스레드 풀을 처음부터 구현해야합니다. 다른 유형의 작업에 다른 정책이 필요한 경우 여러 풀을 만들어야 할 수도 있습니다. 이제 리소스를 공유하지 않는 서로 다른 두 개의 스레드 캐시를 효과적으로 사용할 수 있기 때문에 비효율적입니다.</target>
        </trans-unit>
        <trans-unit id="c798110762fd844baf0b5cdc9832d8c71d67602a" translate="yes" xml:space="preserve">
          <source>Socket objects</source>
          <target state="translated">소켓 객체</target>
        </trans-unit>
        <trans-unit id="655fcbd0fdce070ab1dd17b0f4b4d25fd50db073" translate="yes" xml:space="preserve">
          <source>SocketStream</source>
          <target state="translated">SocketStream</target>
        </trans-unit>
        <trans-unit id="33243780198fdd9e060afa427801d7aeb8d32f67" translate="yes" xml:space="preserve">
          <source>Sockets and networking</source>
          <target state="translated">소켓 및 네트워킹</target>
        </trans-unit>
        <trans-unit id="dc23719f0d9233246e570ccf60e98a17c7b26b0b" translate="yes" xml:space="preserve">
          <source>Some &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; methods can&amp;rsquo;t return any meaningful data until after the handshake. If you call them before the handshake, they raise this error.</source>
          <target state="translated">일부 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 메서드는 핸드 셰이크가 완료 될 때까지 의미있는 데이터를 반환 할 수 없습니다. 핸드 셰이크 전에 전화하면이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9345ea48a5cb7e21d04b7e45c3a00560b568defe" translate="yes" xml:space="preserve">
          <source>Some event loops, like asyncio, won&amp;rsquo;t work correctly unless they win this fight. Fortunately, Trio is a little less picky: as long as &lt;em&gt;someone&lt;/em&gt; makes sure that the program wakes up when a signal arrives, it should work correctly. So if your host loop wants &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt;&lt;code&gt;signal.set_wakeup_fd&lt;/code&gt;&lt;/a&gt;, then you should disable Trio&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt;&lt;code&gt;signal.set_wakeup_fd&lt;/code&gt;&lt;/a&gt; support, and then both loops will work correctly.</source>
          <target state="translated">asyncio와 같은 일부 이벤트 루프는이 싸움에서 이기지 않으면 제대로 작동하지 않습니다. 다행스럽게도 Trio는 덜 까다 롭습니다. &lt;em&gt;누군가&lt;/em&gt; 신호가 도착했을 때 프로그램이 깨어나는 것을 확인하는 한 올바르게 작동합니다. 따라서 호스트 루프가 &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt; &lt;code&gt;signal.set_wakeup_fd&lt;/code&gt; 를&lt;/a&gt; 원한다면 Trio의 &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd&quot;&gt; &lt;code&gt;signal.set_wakeup_fd&lt;/code&gt; &lt;/a&gt; 지원을 비활성화해야 합니다. 그러면 두 루프가 모두 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="763dc9850c40e96a02c0a22e2cbdb9bd606c49a4" translate="yes" xml:space="preserve">
          <source>Some methods on &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; raise &lt;a href=&quot;#trio.NeedHandshakeError&quot;&gt;&lt;code&gt;NeedHandshakeError&lt;/code&gt;&lt;/a&gt; if you call them before the handshake completes:</source>
          <target state="translated">일부 방법 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; 의&lt;/a&gt; 인상 &lt;a href=&quot;#trio.NeedHandshakeError&quot;&gt; &lt;code&gt;NeedHandshakeError&lt;/code&gt; &lt;/a&gt; 는 핸드 쉐이크 완료하기 전에를 호출하는 경우 :</target>
        </trans-unit>
        <trans-unit id="89d3ecb4bb3fac7ce56b1e0de2d53bc6bb0d92b8" translate="yes" xml:space="preserve">
          <source>Some programs need to be able to quit at any time, for example in response to a GUI window being closed or a user selecting a &amp;ldquo;Quit&amp;rdquo; from a menu. In these cases, we recommend wrapping your whole program in a &lt;a href=&quot;reference-core#trio.CancelScope&quot;&gt;&lt;code&gt;trio.CancelScope&lt;/code&gt;&lt;/a&gt;, and cancelling it when you want to quit.</source>
          <target state="translated">예를 들어 GUI 창이 닫히거나 사용자가 메뉴에서 &quot;종료&quot;를 선택하면 일부 프로그램은 언제든지 종료 할 수 있어야합니다. 이러한 경우 전체 프로그램을 &lt;a href=&quot;reference-core#trio.CancelScope&quot;&gt; &lt;code&gt;trio.CancelScope&lt;/code&gt; 로&lt;/a&gt; 래핑 하고 종료하려는 경우 취소 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="b27189a11dd9d8693c1cfa882d09fc9356dcb1d5" translate="yes" xml:space="preserve">
          <source>Sometimes it doesn&amp;rsquo;t make sense for the task that starts a child to take on responsibility for watching it. For example, a server task may want to start a new task for each connection, but it can&amp;rsquo;t listen for connections and supervise children at the same time.</source>
          <target state="translated">때때로 어린이가 시작한 임무를보고 책임을지는 것은 이해가되지 않습니다. 예를 들어, 서버 작업은 각 연결마다 새 작업을 시작하려고하지만 연결을 수신하고 동시에 하위를 감독 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="2df141e44fbf3ba214d9841f6406f0bfbb78bccb" translate="yes" xml:space="preserve">
          <source>Sometimes you need to put a limit on how many tasks can do something at the same time. For example, you might want to use some threads to run multiple blocking I/O operations in parallel&amp;hellip; but if you use too many threads at once, then your system can become overloaded and it&amp;rsquo;ll actually make things slower. One popular solution is to impose a policy like &amp;ldquo;run up to 40 threads at the same time, but no more&amp;rdquo;. But how do you implement a policy like this?</source>
          <target state="translated">때로는 작업을 동시에 수행 할 수있는 작업 수를 제한해야합니다. 예를 들어, 일부 스레드를 사용하여 여러 블로킹 I / O 작업을 병렬로 실행할 수 있지만 한 번에 너무 많은 스레드를 사용하면 시스템이 오버로드되어 실제로 속도가 느려질 수 있습니다. 널리 사용되는 솔루션 중 하나는 &quot;최대 40 개의 스레드를 동시에 실행하지만 더 이상 실행하지 않는&quot;정책을 적용하는 것입니다. 그러나 이와 같은 정책을 어떻게 구현합니까?</target>
        </trans-unit>
        <trans-unit id="28a2722a8ff69315bc9a5705fed28a992c345e6f" translate="yes" xml:space="preserve">
          <source>Sometimes, it&amp;rsquo;s useful to be able to share some mutable sleep-related data between the sleeping task, the abort function, and the waking task. You can use the sleeping task&amp;rsquo;s &lt;a href=&quot;#trio.hazmat.Task.custom_sleep_data&quot;&gt;&lt;code&gt;custom_sleep_data&lt;/code&gt;&lt;/a&gt; attribute to store this data, and Trio won&amp;rsquo;t touch it, except to make sure that it gets cleared when the task is rescheduled.</source>
          <target state="translated">수면 작업, 중단 기능 및 깨우기 작업간에 변경 가능한 수면 관련 데이터를 공유하는 것이 유용한 경우도 있습니다. 수면 작업의 &lt;a href=&quot;#trio.hazmat.Task.custom_sleep_data&quot;&gt; &lt;code&gt;custom_sleep_data&lt;/code&gt; &lt;/a&gt; 속성을 사용하여이 데이터를 저장할 수 있으며 작업 일정이 재조정 될 때 데이터가 지워지는 것을 제외하고는 Trio가 해당 데이터를 건드리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94edab96da73479b826a1e418978af4b76f24615" translate="yes" xml:space="preserve">
          <source>Sometimes, it&amp;rsquo;s useful to be able to share some mutable sleep-related data between the sleeping task, the abort function, and the waking task. You can use the sleeping task&amp;rsquo;s &lt;a href=&quot;#trio.lowlevel.Task.custom_sleep_data&quot;&gt;&lt;code&gt;custom_sleep_data&lt;/code&gt;&lt;/a&gt; attribute to store this data, and Trio won&amp;rsquo;t touch it, except to make sure that it gets cleared when the task is rescheduled.</source>
          <target state="translated">때로는 수면 작업, 중단 기능 및 깨우기 작업간에 변경 가능한 수면 관련 데이터를 공유 할 수있는 것이 유용합니다. 잠자기 작업의 &lt;a href=&quot;#trio.lowlevel.Task.custom_sleep_data&quot;&gt; &lt;code&gt;custom_sleep_data&lt;/code&gt; &lt;/a&gt; 속성을 사용하여이 데이터를 저장할 수 있으며 Trio는 작업이 다시 예약 될 때 지워지는 것을 확인하는 경우를 제외하고는 데이터를 건드리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a64f6b1abe92a7a7b4c6478df9e8e0cd60338357" translate="yes" xml:space="preserve">
          <source>Sometimes, though if we&amp;rsquo;re lucky, the two producers might finish at the same time (or close enough), so they both make their last &lt;code&gt;send&lt;/code&gt; before either of them closes the &lt;code&gt;send_channel&lt;/code&gt;.</source>
          <target state="translated">때로는 운이 좋으면 두 제작자가 동시에 완료하거나 충분히 닫을 수 있으므로 두 사람 이 &lt;code&gt;send_channel&lt;/code&gt; 을 닫기 전에 마지막으로 &lt;code&gt;send&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4062e9fcc29dbf3d4f384d021b8d2f23dae68ca4" translate="yes" xml:space="preserve">
          <source>Spawn a &amp;ldquo;system&amp;rdquo; task.</source>
          <target state="translated">&quot;시스템&quot;작업을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="86787d141e62ea9c6e1d9ef20be7863fc8ae36cd" translate="yes" xml:space="preserve">
          <source>Spawn this thread from &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync&lt;/code&gt;&lt;/a&gt;. Trio will automatically capture the relevant Trio token and use it when you want to re-enter Trio.</source>
          <target state="translated">&lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync&lt;/code&gt; &lt;/a&gt; 에서이 스레드를 생성합니다 . Trio는 관련 Trio 토큰을 자동으로 캡처하여 Trio를 다시 입력하려고 할 때 사용합니다.</target>
        </trans-unit>
        <trans-unit id="62f14e7f69f0c928f3521a52d4471e369748ed2e" translate="yes" xml:space="preserve">
          <source>Spawning subprocesses</source>
          <target state="translated">하위 프로세스 생성</target>
        </trans-unit>
        <trans-unit id="255e359a65128521d6223be6b31e2b8a76a94d43" translate="yes" xml:space="preserve">
          <source>Spawning tasks without becoming a parent</source>
          <target state="translated">부모가되지 않고 산란 작업</target>
        </trans-unit>
        <trans-unit id="9e64610f310d2efd9936d16cf28d0c33c4d6fbc9" translate="yes" xml:space="preserve">
          <source>Spawning threads</source>
          <target state="translated">스레드 생성</target>
        </trans-unit>
        <trans-unit id="b5265bdb21e85f3aad61c94d6d966d5e82bdd52f" translate="yes" xml:space="preserve">
          <source>Special notes:</source>
          <target state="translated">특별 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="59452117c4e17f1600d8cb5a7a64e6200569cd19" translate="yes" xml:space="preserve">
          <source>Specific style guidelines</source>
          <target state="translated">특정 스타일 지침</target>
        </trans-unit>
        <trans-unit id="f7a9b1371562eba7427785ba394b08b92540fb8e" translate="yes" xml:space="preserve">
          <source>Standard-compliant SSL/TLS implementations always send a cryptographically signed &lt;code&gt;close_notify&lt;/code&gt; message before closing the connection. This is important because if the underlying transport were simply closed, then there wouldn&amp;rsquo;t be any way for the other side to know whether the connection was intentionally closed by the peer that they negotiated a cryptographic connection to, or by some &lt;a href=&quot;https://en.wikipedia.org/wiki/Man-in-the-middle_attack&quot;&gt;man-in-the-middle&lt;/a&gt; attacker who can&amp;rsquo;t manipulate the cryptographic stream, but can manipulate the transport layer (a so-called &amp;ldquo;truncation attack&amp;rdquo;).</source>
          <target state="translated">표준 호환 SSL / TLS 구현 은 연결을 닫기 전에 항상 암호화 서명 된 &lt;code&gt;close_notify&lt;/code&gt; 메시지를 보냅니다 . 기본 전송이 단순히 닫히면 상대방이 암호화 연결을 협상 한 피어가 연결을 의도적으로 닫았는지 또는 일부 담당자가 연결을 알 수있는 방법이 없기 때문에 이것은 중요합니다 &lt;a href=&quot;https://en.wikipedia.org/wiki/Man-in-the-middle_attack&quot;&gt;.&lt;/a&gt; 암호화 스트림을 조작 할 수 없지만 전송 계층 (소위 &quot;절단 공격&quot;)을 조작 할 수있는 중간 공격자.</target>
        </trans-unit>
        <trans-unit id="e962a9dfea2f0e0d8c3fd9ea7656b468b40b11f2" translate="yes" xml:space="preserve">
          <source>Start a &amp;ldquo;guest&amp;rdquo; run of Trio on top of some other &amp;ldquo;host&amp;rdquo; event loop.</source>
          <target state="translated">다른 &quot;호스트&quot;이벤트 루프 위에서 Trio의 &quot;게스트&quot;실행을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="538bad610e4cd63875a6f40262577d01e06f3685" translate="yes" xml:space="preserve">
          <source>Start instrumenting the current run loop with the given instrument.</source>
          <target state="translated">주어진 계측기로 현재 런 루프 계측을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="27ec8cde0c460b3a817bbe9ef5ff3449e512158c" translate="yes" xml:space="preserve">
          <source>Start listening for SSL/TLS-encrypted TCP connections to the given port.</source>
          <target state="translated">주어진 포트에 대한 SSL / TLS 암호화 TCP 연결 수신을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="67c484a632cde0780741fc006f1a8fc9c3676b53" translate="yes" xml:space="preserve">
          <source>Start up your host loop</source>
          <target state="translated">호스트 루프 시작</target>
        </trans-unit>
        <trans-unit id="b2062c61bfd9457e074fe8ebdf948e44b4303be1" translate="yes" xml:space="preserve">
          <source>Stop instrumenting the current run loop with the given instrument.</source>
          <target state="translated">주어진 계측기로 현재 런 루프 계측을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="74985da267c6803b262f117de72af2d02e48029f" translate="yes" xml:space="preserve">
          <source>Streams</source>
          <target state="translated">Streams</target>
        </trans-unit>
        <trans-unit id="ecfa6cc29e1a7d81c918ce86382e082e5b3f9aa7" translate="yes" xml:space="preserve">
          <source>String containing this &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s name. Usually the name of the function this &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; is running, but can be overridden by passing &lt;code&gt;name=&lt;/code&gt; to &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;start_soon&lt;/code&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 이름 이 포함 된 문자열 입니다. 일반적으로이 &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 이 실행중인 함수의 이름 이지만 &lt;code&gt;name=&lt;/code&gt; 을 &lt;code&gt;start&lt;/code&gt; 또는 &lt;code&gt;start_soon&lt;/code&gt; 으로 전달하여 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88dacce5492d183a96487fb4fd272e494398e85f" translate="yes" xml:space="preserve">
          <source>String containing this &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;'s name. Usually the name of the function this &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; is running, but can be overridden by passing &lt;code&gt;name=&lt;/code&gt; to &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;start_soon&lt;/code&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 의 이름을 포함하는 문자열 입니다. 일반적으로이 &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 가 실행중인 함수의 이름 이지만 &lt;code&gt;start&lt;/code&gt; 또는 &lt;code&gt;start_soon&lt;/code&gt; 에 &lt;code&gt;name=&lt;/code&gt; 을 전달하여 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f4774c0e91d69d04dd6ad14a20a6dcc93957451" translate="yes" xml:space="preserve">
          <source>Supported environments: Linux, macOS, or Windows running some kind of Python 3.5-or-better (either CPython or PyPy3 is fine). *BSD and illumos likely work too, but are untested.</source>
          <target state="translated">지원되는 환경 : 어떤 종류의 Python 3.5 이상을 실행하는 Linux, macOS 또는 Windows (CPython 또는 PyPy3이 좋습니다). * BSD와 illumos도 작동하지만 테스트되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ea8914a98b4487b6e07a50764ebb50bdefa03e0c" translate="yes" xml:space="preserve">
          <source>Supported environments: We test on</source>
          <target state="translated">지원되는 환경 : 테스트 대상</target>
        </trans-unit>
        <trans-unit id="6e0f9d236419d7ce4dcfde2105032675c5910961" translate="yes" xml:space="preserve">
          <source>Suppose we have a handler function that discards &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;s:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 를 버리는 핸들러 함수가 있다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="9bcc4a70ae1d63b866c95cda6ee3ba65780eedf1" translate="yes" xml:space="preserve">
          <source>Suppose you&amp;rsquo;re writing a server that responds to network requests, and you log some information about each request as you process it. If the server is busy and there are multiple requests being handled at the same time, then you might end up with logs like this:</source>
          <target state="translated">네트워크 요청에 응답하는 서버를 작성하고 처리 할 때 각 요청에 대한 정보를 기록한다고 가정하십시오. 서버가 사용 중이고 동시에 여러 요청이 처리되는 경우 다음과 같은 로그가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19e98a8e67554960e71cb8b97f1c5ac1a004d082" translate="yes" xml:space="preserve">
          <source>Synchronizing and communicating between tasks</source>
          <target state="translated">작업 간 동기화 및 통신</target>
        </trans-unit>
        <trans-unit id="055926a4c90e5c08999c70c13e37e6306b9e8f0b" translate="yes" xml:space="preserve">
          <source>Synchronous attributes/methods: if any of the following attributes or methods are present, then they&amp;rsquo;re re-exported unchanged: &lt;code&gt;closed&lt;/code&gt;, &lt;code&gt;encoding&lt;/code&gt;, &lt;code&gt;errors&lt;/code&gt;, &lt;code&gt;fileno&lt;/code&gt;, &lt;code&gt;isatty&lt;/code&gt;, &lt;code&gt;newlines&lt;/code&gt;, &lt;code&gt;readable&lt;/code&gt;, &lt;code&gt;seekable&lt;/code&gt;, &lt;code&gt;writable&lt;/code&gt;, &lt;code&gt;buffer&lt;/code&gt;, &lt;code&gt;raw&lt;/code&gt;, &lt;code&gt;line_buffering&lt;/code&gt;, &lt;code&gt;closefd&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;mode&lt;/code&gt;, &lt;code&gt;getvalue&lt;/code&gt;, &lt;code&gt;getbuffer&lt;/code&gt;.</source>
          <target state="translated">동기 속성 / 방법이 다음 특성 또는 임의의 방법이 존재하는 경우, 그들은있는 거 재 반출 변경 : &lt;code&gt;closed&lt;/code&gt; , &lt;code&gt;encoding&lt;/code&gt; , &lt;code&gt;errors&lt;/code&gt; , &lt;code&gt;fileno&lt;/code&gt; 는 , &lt;code&gt;isatty&lt;/code&gt; 은 , &lt;code&gt;newlines&lt;/code&gt; , &lt;code&gt;readable&lt;/code&gt; , &lt;code&gt;seekable&lt;/code&gt; , &lt;code&gt;writable&lt;/code&gt; , &lt;code&gt;buffer&lt;/code&gt; , &lt;code&gt;raw&lt;/code&gt; , &lt;code&gt;line_buffering&lt;/code&gt; , &lt;code&gt;closefd&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;mode&lt;/code&gt; , &lt;code&gt;getvalue&lt;/code&gt; , &lt;code&gt;getbuffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26f95fb839ad8c1ff05b0c8fdf998088c518fd27" translate="yes" xml:space="preserve">
          <source>Synchronous code never contains any checkpoints, but we can double-check that:</source>
          <target state="translated">동기 코드에는 체크 포인트가 포함되지 않지만 다음을 다시 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d3242a906ad02bf931de9a3178700e07c2be807" translate="yes" xml:space="preserve">
          <source>System tasks are automatically cancelled when the main task exits.</source>
          <target state="translated">기본 작업이 종료되면 시스템 작업이 자동으로 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="5c204ac92f0958e65d5735c8207842ebd1d94d97" translate="yes" xml:space="preserve">
          <source>System tasks do not inherit context variables from their creator.</source>
          <target state="translated">시스템 작업은 생성자로부터 컨텍스트 변수를 상속하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4f943638fe154a8226e9c578ceb1a32fb677027" translate="yes" xml:space="preserve">
          <source>System tasks have a few differences from regular tasks:</source>
          <target state="translated">시스템 작업은 일반 작업과 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f44fef3579bfe89f6394f4eef4837d80321d9a4a" translate="yes" xml:space="preserve">
          <source>TODO: these are implemented, but are currently more of a sketch than anything real. See &lt;a href=&quot;https://github.com/python-trio/trio/issues/26&quot;&gt;#26&lt;/a&gt; and &lt;a href=&quot;https://github.com/python-trio/trio/issues/52&quot;&gt;#52&lt;/a&gt;.</source>
          <target state="translated">TODO : 이들은 구현되었지만 현재 실제보다 더 많은 스케치입니다. &lt;a href=&quot;https://github.com/python-trio/trio/issues/26&quot;&gt;# 26&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/python-trio/trio/issues/52&quot;&gt;# 52를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34c39842bbae3da361d13d933fa1d76993d2e5e4" translate="yes" xml:space="preserve">
          <source>TODO: these are implemented, but are currently more of a sketch than anything real. See &lt;a href=&quot;https://github.com/python-trio/trio/issues/26&quot;&gt;#26&lt;/a&gt;.</source>
          <target state="translated">TODO : 이들은 구현되었지만 현재 실제보다 더 많은 스케치입니다. &lt;a href=&quot;https://github.com/python-trio/trio/issues/26&quot;&gt;# 26&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="c6d22c008afc423d3836f670a439ca3979a41de4" translate="yes" xml:space="preserve">
          <source>Take data out of the given &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;code&gt;MemorySendStream&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s internal buffer, and put it into the given &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;code&gt;MemoryReceiveStream&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s internal buffer.</source>
          <target state="translated">주어진 &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt; &lt;code&gt;MemorySendStream&lt;/code&gt; &lt;/a&gt; 의 내부 버퍼에서 데이터를 가져와 주어진 &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt; &lt;code&gt;MemoryReceiveStream&lt;/code&gt; &lt;/a&gt; 의 내부 버퍼에 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="7bb0ddf9221c03b806b03c209e8366000124aa15" translate="yes" xml:space="preserve">
          <source>Task</source>
          <target state="translated">Task</target>
        </trans-unit>
        <trans-unit id="d89b8bafaae10233d3c0df964c49dfe20cf2d352" translate="yes" xml:space="preserve">
          <source>Task API</source>
          <target state="translated">작업 API</target>
        </trans-unit>
        <trans-unit id="802a4e17ee1d8e6d0ad7403c8b75383080b8674e" translate="yes" xml:space="preserve">
          <source>Task-local storage</source>
          <target state="translated">작업 로컬 스토리지</target>
        </trans-unit>
        <trans-unit id="f74f87f6903191022bd96d719e761e9623d8f5cb" translate="yes" xml:space="preserve">
          <source>Task-related API details</source>
          <target state="translated">작업 관련 API 세부 사항</target>
        </trans-unit>
        <trans-unit id="ef1c5421122784c77c263be639d67c525ca3c3b4" translate="yes" xml:space="preserve">
          <source>Tasks let you do multiple things at once</source>
          <target state="translated">작업을 통해 한 번에 여러 작업을 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a9f85d2cdf608d49f77179bec9274df48164ba4e" translate="yes" xml:space="preserve">
          <source>Technically, it is possible to use other patterns. But there are some important limitations you have to respect:</source>
          <target state="translated">기술적으로 다른 패턴을 사용할 수 있습니다. 그러나 존중해야 할 몇 가지 중요한 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="304baf6bf4961ac71a5da0c98ab5a8d805ceefdf" translate="yes" xml:space="preserve">
          <source>Temporarily detach the current coroutine object from the Trio scheduler.</source>
          <target state="translated">현재 코 루틴 오브젝트를 Trio 스케줄러에서 임시로 분리하십시오.</target>
        </trans-unit>
        <trans-unit id="facd1c6aeacb9718336f3aed70d13ecc4deab47b" translate="yes" xml:space="preserve">
          <source>Terminate the process, politely if possible.</source>
          <target state="translated">가능하면 정중하게 프로세스를 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="5d4008135062fb803b7ec11f07867a7759c2e1da" translate="yes" xml:space="preserve">
          <source>Test harness integration</source>
          <target state="translated">테스트 하네스 통합</target>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="6b011e2bb3c834f658d616203f55717f63ba2ae6" translate="yes" xml:space="preserve">
          <source>Testing checkpoints</source>
          <target state="translated">검사 점 테스트</target>
        </trans-unit>
        <trans-unit id="35e0ba25999f3a918e3e2952df381f71ee1accbf" translate="yes" xml:space="preserve">
          <source>Testing custom stream implementations</source>
          <target state="translated">맞춤 스트림 구현 테스트</target>
        </trans-unit>
        <trans-unit id="341c328d3226e6e7cbcef449b2f9d2e0ef49e921" translate="yes" xml:space="preserve">
          <source>Testing made easier with &lt;code&gt;trio.testing&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;trio.testing&lt;/code&gt; 테스트를 통해 테스트가 쉬워 졌습니다.</target>
        </trans-unit>
        <trans-unit id="2987927a1f9194d0407b8259e63f466ffac0a9e8" translate="yes" xml:space="preserve">
          <source>Testing made easier with trio.testing</source>
          <target state="translated">트리오 테스트를 통해 테스트가 쉬워졌습니다.</target>
        </trans-unit>
        <trans-unit id="b8fb0e142b06b7b6146922267b755a35993334c6" translate="yes" xml:space="preserve">
          <source>That is, this is OK:</source>
          <target state="translated">즉, 이것은 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="08c3519cadca868f28bbb253c4e6d9baf20e199f" translate="yes" xml:space="preserve">
          <source>That world, alas, does not (yet) exist. Until it does, you may find yourself needing to interact with non-Trio APIs that do rude things like &amp;ldquo;blocking&amp;rdquo;.</source>
          <target state="translated">아아, 그 세계는 (아직) 존재하지 않습니다. 그 때까지&amp;ldquo;차단&amp;rdquo;과 같은 무례한 작업을 수행하는 비 Trio API와 상호 작용해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ac747b8191150731763661dc9fc7b17a6a27a33" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s what &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; is for. You can think of a &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; object as a sack that starts out holding some fixed number of tokens:</source>
          <target state="translated">그것이 &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; 의&lt;/a&gt; 목적입니다. &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt; 객체는 고정 된 수의 토큰을 보유하기 시작하는 자루로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="278998c9ff3d196df8ce725e0a4247a8f9f881ca" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why Trio offers a fourth option: &lt;strong&gt;guest mode&lt;/strong&gt;. Guest mode lets you execute &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt; on top of some other &amp;ldquo;host&amp;rdquo; event loop, like Qt. Its advantages are:</source>
          <target state="translated">이것이 Trio가 네 번째 옵션 인 &lt;strong&gt;게스트 모드를&lt;/strong&gt; 제공하는 이유 입니다. 게스트 모드를 사용하면 Qt와 같은 다른 &quot;호스트&quot;이벤트 루프 위에서 &lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run&lt;/code&gt; &lt;/a&gt; 을 실행할 수 있습니다 . 장점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa77426cfd32e308124c277026d2320b6fc9f3df" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;polling&amp;rdquo; and &amp;ldquo;pluggable backend&amp;rdquo; strategies solve this by hacking the loops so both step 1s can run at the same time in the same thread. Keeping everything in one thread is great for step 2, but the step 1 hacks create problems.</source>
          <target state="translated">&quot;폴링&quot;및 &quot;플러그 가능한 백엔드&quot;전략은 루프를 해킹하여 두 1 단계가 동일한 스레드에서 동시에 실행될 수 있도록함으로써이 문제를 해결합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 모든 것을 하나의 스레드에 보관하는 것은 2 단계에서는 좋지만 1 단계 해킹은 문제를 일으 킵니다.</target>
        </trans-unit>
        <trans-unit id="f80f2be65b7c1e19f805fdd78f2b5dc2cc59217e" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;separate threads&amp;rdquo; strategy solves this by moving both steps into separate threads. This makes step 1 work, but the downside is that now the user tasks in step 2 are running separate threads as well, so users are forced to deal with inter-thread coordination.</source>
          <target state="translated">&quot;개별 스레드&quot;전략은 두 단계를 별도의 스레드로 이동하여이 문제를 해결합니다. 이로 인해 1 단계가 작동하지만 단점은 이제 2 단계의 사용자 작업도 별도의 스레드를 실행하므로 사용자가 스레드 간 조정을 처리해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fd78edb290431455f2a37b4855817a9dffd051ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-trio.socket&quot;&gt;&lt;code&gt;trio.socket&lt;/code&gt;&lt;/a&gt; module provides Trio&amp;rsquo;s basic low-level networking API. If you&amp;rsquo;re doing ordinary things with stream-oriented connections over IPv4/IPv6/Unix domain sockets, then you probably want to stick to the high-level API described above. If you want to use UDP, or exotic address families like &lt;code&gt;AF_BLUETOOTH&lt;/code&gt;, or otherwise get direct access to all the quirky bits of your system&amp;rsquo;s networking API, then you&amp;rsquo;re in the right place.</source>
          <target state="translated">&lt;a href=&quot;#module-trio.socket&quot;&gt; &lt;code&gt;trio.socket&lt;/code&gt; 의&lt;/a&gt; 모듈은 트리오의 기본 낮은 수준의 네트워킹 API를 제공한다. IPv4 / IPv6 / Unix 도메인 소켓을 통한 스트림 지향 연결로 평범한 작업을 수행하는 경우 위에서 설명한 고급 API를 고수하고 싶을 것입니다. UDP 또는 &lt;code&gt;AF_BLUETOOTH&lt;/code&gt; 와 같은 이국적인 주소 패밀리를 사용하거나 시스템 네트워킹 API의 모든 기발한 비트에 직접 액세스하려면 올바른 위치에 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8e0d2ab8c98abb5b0b0f5e1d4a574bebf7c6690" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-trio.testing&quot;&gt;&lt;code&gt;trio.testing&lt;/code&gt;&lt;/a&gt; module provides various utilities to make it easier to test Trio code. Unlike the other submodules in the &lt;a href=&quot;reference-core#module-trio&quot;&gt;&lt;code&gt;trio&lt;/code&gt;&lt;/a&gt; namespace, &lt;a href=&quot;#module-trio.testing&quot;&gt;&lt;code&gt;trio.testing&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;not&lt;/em&gt; automatically imported when you do &lt;code&gt;import trio&lt;/code&gt;; you must &lt;code&gt;import trio.testing&lt;/code&gt; explicitly.</source>
          <target state="translated">&lt;a href=&quot;#module-trio.testing&quot;&gt; &lt;code&gt;trio.testing&lt;/code&gt; &lt;/a&gt; 모듈은 쉽게 트리오 코드를 테스트 할 수 있도록 다양한 유틸리티를 제공합니다. 의 다른 서브 모듈과 달리 &lt;a href=&quot;reference-core#module-trio&quot;&gt; &lt;code&gt;trio&lt;/code&gt; &lt;/a&gt; 네임 스페이스, &lt;a href=&quot;#module-trio.testing&quot;&gt; &lt;code&gt;trio.testing&lt;/code&gt; &lt;/a&gt; 되어 &lt;em&gt;있지&lt;/em&gt; 자동으로 수행 할 때 가져 &lt;code&gt;import trio&lt;/code&gt; ; &lt;code&gt;import trio.testing&lt;/code&gt; 명시 적으로 가져와야 합니다 .</target>
        </trans-unit>
        <trans-unit id="996e86c00c33ba5b09fce5a9fc45abb7e9e22650" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; constructor takes initial values for the cancel scope&amp;rsquo;s &lt;a href=&quot;#trio.CancelScope.deadline&quot;&gt;&lt;code&gt;deadline&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.CancelScope.shield&quot;&gt;&lt;code&gt;shield&lt;/code&gt;&lt;/a&gt; attributes; these may be freely modified after construction, whether or not the scope has been entered yet, and changes take immediate effect.</source>
          <target state="translated">&lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; 의&lt;/a&gt; (가) 범위의 취소에 대한 생성자는 초기 값을 사용 &lt;a href=&quot;#trio.CancelScope.deadline&quot;&gt; &lt;code&gt;deadline&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.CancelScope.shield&quot;&gt; &lt;code&gt;shield&lt;/code&gt; &lt;/a&gt; 특성을; 이들은 스코프가 아직 입력되었는지 여부에 관계없이 구성 후에 자유롭게 수정 될 수 있으며 변경 사항은 즉시 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3e93c721d5334efb64815d725431dc0496846ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reference-testing#module-trio.testing&quot;&gt;&lt;code&gt;trio.testing&lt;/code&gt;&lt;/a&gt; module provides a set of &lt;a href=&quot;reference-testing#testing-streams&quot;&gt;flexible in-memory stream object implementations&lt;/a&gt;, so if you have a protocol implementation to test then you can can start two tasks, set up a virtual &amp;ldquo;socket&amp;rdquo; connecting them, and then do things like inject random-but-repeatable delays into the connection.</source>
          <target state="translated">&lt;a href=&quot;reference-testing#module-trio.testing&quot;&gt; &lt;code&gt;trio.testing&lt;/code&gt; &lt;/a&gt; 모듈은 세트 제공 &lt;a href=&quot;reference-testing#testing-streams&quot;&gt;유연한 메모리 스트림 객체 구현을&lt;/a&gt; 당신이 그 (것)들을 연결하는 가상 &quot;소켓&quot;를 설정 한 다음 두 개의 작업을 시작할 수 있습니다 테스트에 대한 프로토콜 구현이 있고, 주입 한 후 같은 일을 할 그렇다면, 임의의 반복 가능한 연결 지연.</target>
        </trans-unit>
        <trans-unit id="09b5d3a08ea757fadb98a4225154f91508d3f13f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;async_fn&lt;/code&gt; must accept a &lt;code&gt;task_status&lt;/code&gt; keyword argument, and it must make sure that it (or someone) eventually calls &lt;code&gt;task_status.started()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;async_fn&lt;/code&gt; 는 수용해야 &lt;code&gt;task_status&lt;/code&gt; 키워드 인수를하고 있는지 그 (또는 사람) 결국 호출을 확인해야합니다 &lt;code&gt;task_status.started()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f895f76bf1979f9940415d53c288e42d5e8a898" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cancel_scope&lt;/code&gt; object also allows you to check or adjust this scope&amp;rsquo;s deadline, explicitly trigger a cancellation without waiting for the deadline, check if the scope has already been cancelled, and so forth &amp;ndash; see &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; below for the full details.</source>
          <target state="translated">&lt;code&gt;cancel_scope&lt;/code&gt; 의 참조 - 객체는 확인하거나이 범위의 기한을 조정, 명시 적으로 기한을 기다리지 않고 취소를 트리거, 범위가 이미 취소되어 있는지 확인하고 등을 할 수 있습니다 &lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; 를&lt;/a&gt; 전체 내용은 아래.</target>
        </trans-unit>
        <trans-unit id="69e23230a2bcee3af46d41ce7a31ade877e491f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;command&lt;/code&gt; passed at construction time, specifying the process to execute and its arguments.</source>
          <target state="translated">&lt;code&gt;command&lt;/code&gt; 실행]하는 과정과 인수를 지정하여 건설 한 번에 통과했다.</target>
        </trans-unit>
        <trans-unit id="063f67b92b596d191b8f84a0a83fc8f83c79740b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;detach&lt;/code&gt; method, if present, returns an async file object.</source>
          <target state="translated">&lt;code&gt;detach&lt;/code&gt; 방법은, 존재하는 경우, 비동기 파일 개체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1bfb97a4bbb5e07af262081e3f1c7ef329411374" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;limiter&lt;/code&gt; is only released after the thread has &lt;em&gt;actually&lt;/em&gt; finished &amp;ndash; which in the case of cancellation may be some time after this function has returned. If &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; finishes before the thread does, then the limiter release method will never be called at all.</source>
          <target state="translated">&lt;code&gt;limiter&lt;/code&gt; 스레드가 후에 만 해제 &lt;em&gt;실제로&lt;/em&gt; 이 함수가 리턴 된 후에 취소의 경우에 약간의 시간 일 수있다 - 마쳤다. 경우 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 스레드보다 먼저 완료 한 후 제한 해제 방법은 전혀 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39e88286f1b3b8ffdc9fa1f82e7c0888d475d325" translate="yes" xml:space="preserve">
          <source>The SSH protocol provides the ability to multiplex bidirectional &amp;ldquo;channels&amp;rdquo; on top of a single encrypted connection. A Trio implementation of SSH could expose these channels as &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;HalfCloseableStream&lt;/code&gt;&lt;/a&gt; objects, and calling &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt;&lt;code&gt;send_eof()&lt;/code&gt;&lt;/a&gt; would send an &lt;code&gt;SSH_MSG_CHANNEL_EOF&lt;/code&gt; request (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4254#section-5.3&quot;&gt;RFC 4254 &amp;sect;5.3&lt;/a&gt;).</source>
          <target state="translated">SSH 프로토콜은 단일 암호화 연결 위에서 양방향 &quot;채널&quot;을 다중화하는 기능을 제공합니다. SSH의 Trio 구현은 이러한 채널을 &lt;a href=&quot;#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;HalfCloseableStream&lt;/code&gt; &lt;/a&gt; 객체 로 노출 할 수 있으며 &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt; &lt;code&gt;send_eof()&lt;/code&gt; &lt;/a&gt; 호출 하면 &lt;code&gt;SSH_MSG_CHANNEL_EOF&lt;/code&gt; 요청 이 전송됩니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc4254#section-5.3&quot;&gt;RFC 4254 &amp;sect;5.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e14f4dc6e5377f931e4c2a51d7d47887a2aa40b7" translate="yes" xml:space="preserve">
          <source>The SSL protocol requires an initial handshake to exchange certificates, select cryptographic keys, and so forth, before any actual data can be sent or received. You don&amp;rsquo;t have to call this method; if you don&amp;rsquo;t, then &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; will automatically peform the handshake as needed, the first time you try to send or receive data. But if you want to trigger it manually &amp;ndash; for example, because you want to look at the peer&amp;rsquo;s certificate before you start talking to them &amp;ndash; then you can call this method.</source>
          <target state="translated">SSL 프로토콜에는 실제 데이터를 보내거나 받기 전에 인증서를 교환하고 암호화 키를 선택하는 등의 초기 핸드 셰이크가 필요합니다. 이 메소드를 호출 할 필요는 없습니다. 그렇지 않으면 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 은 처음으로 데이터를 보내거나받을 때 필요에 따라 자동으로 핸드 셰이크를 수행합니다. 그러나 상대방과 대화하기 전에 피어의 인증서를보고자하는 등 수동으로 트리거하려는 경우이 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24a88fd10b6d826da9e0fd3c37c9c98e67fb3304" translate="yes" xml:space="preserve">
          <source>The Task that opened this nursery.</source>
          <target state="translated">이 보육원을 연 과제.</target>
        </trans-unit>
        <trans-unit id="0037b005605d9473a07d1ff9c8c58a29834eb372" translate="yes" xml:space="preserve">
          <source>The Trio &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; will continue to exist, but will be suspended until you use &lt;a href=&quot;#trio.hazmat.reattach_detached_coroutine_object&quot;&gt;&lt;code&gt;reattach_detached_coroutine_object()&lt;/code&gt;&lt;/a&gt; to resume it. In the mean time, you can use another coroutine runner to schedule the coroutine object. In fact, you have to &amp;ndash; the function doesn&amp;rsquo;t return until the coroutine is advanced from outside.</source>
          <target state="translated">Trio &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 는 계속 존재하지만 &lt;a href=&quot;#trio.hazmat.reattach_detached_coroutine_object&quot;&gt; &lt;code&gt;reattach_detached_coroutine_object()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 다시 시작할 때까지 일시 중지 됩니다. 그 동안 다른 코 루틴 러너를 사용하여 코 루틴 개체를 예약 할 수 있습니다. 실제로, 코 루틴이 외부에서 전진 할 때까지 함수가 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee0161a0dcc6aabacc5285c198de3ae7fd3851b2" translate="yes" xml:space="preserve">
          <source>The Trio &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; will continue to exist, but will be suspended until you use &lt;a href=&quot;#trio.lowlevel.reattach_detached_coroutine_object&quot;&gt;&lt;code&gt;reattach_detached_coroutine_object()&lt;/code&gt;&lt;/a&gt; to resume it. In the mean time, you can use another coroutine runner to schedule the coroutine object. In fact, you have to &amp;ndash; the function doesn&amp;rsquo;t return until the coroutine is advanced from outside.</source>
          <target state="translated">Trio &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 는 계속 존재하지만 &lt;a href=&quot;#trio.lowlevel.reattach_detached_coroutine_object&quot;&gt; &lt;code&gt;reattach_detached_coroutine_object()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 재개 할 때까지 일시 중지 됩니다. 그 동안 다른 코 루틴 실행기를 사용하여 코 루틴 객체를 예약 할 수 있습니다. 실제로 코 루틴이 외부에서 진행될 때까지 함수는 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="91b3715a1bc1d0217b9fa263b8eb097fe34e0f6a" translate="yes" xml:space="preserve">
          <source>The Trio project&amp;rsquo;s goal is to produce a production-quality, &lt;a href=&quot;https://github.com/python-trio/trio/blob/master/LICENSE&quot;&gt;permissively licensed&lt;/a&gt;, async/await-native I/O library for Python. Like all async libraries, its main purpose is to help you write programs that do &lt;strong&gt;multiple things at the same time&lt;/strong&gt; with &lt;strong&gt;parallelized I/O&lt;/strong&gt;. A web spider that wants to fetch lots of pages in parallel, a web server that needs to juggle lots of downloads and websocket connections at the same time, a process supervisor monitoring multiple subprocesses&amp;hellip; that sort of thing. Compared to other libraries, Trio attempts to distinguish itself with an obsessive focus on &lt;strong&gt;usability&lt;/strong&gt; and &lt;strong&gt;correctness&lt;/strong&gt;. Concurrency is complicated; we try to make it &lt;em&gt;easy&lt;/em&gt; to get things &lt;em&gt;right&lt;/em&gt;.</source>
          <target state="translated">Trio 프로젝트의 목표는 프로덕션 용으로 &lt;a href=&quot;https://github.com/python-trio/trio/blob/master/LICENSE&quot;&gt;허가 된 허가 된&lt;/a&gt; 비동기 / 대기 네이티브 I / O 라이브러리를 Python 용으로 제작하는 것입니다. 모든 비동기 라이브러리와 마찬가지로, 그 주요 목적은 당신이 프로그램을 쓸 수 있도록하는 것입니다 &lt;strong&gt;동시에 여러 가지&lt;/strong&gt; 로 &lt;strong&gt;병렬 I / O를&lt;/strong&gt; . 많은 페이지를 병렬로 가져 오려는 웹 스파이더, 많은 다운로드 및 웹 소켓 연결을 동시에 저글링해야하는 웹 서버, 여러 하위 프로세스를 모니터링하는 프로세스 관리자&amp;hellip; 다른 라이브러리와 비교하여 Trio는 &lt;strong&gt;사용&lt;/strong&gt; 성과 &lt;strong&gt;정확성&lt;/strong&gt; 에 대한 집착적인 초점으로 자신을 구별하려고 시도 &lt;strong&gt;합니다&lt;/strong&gt; . 동시성은 복잡합니다. 우리 는 물건을 &lt;em&gt;쉽게&lt;/em&gt; 얻을 수 있도록 노력합니다&lt;em&gt;맞아&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="687057d329e69f8ab7df756c5d5e8198fecaf157" translate="yes" xml:space="preserve">
          <source>The Trio socket object that this stream wraps.</source>
          <target state="translated">이 스트림이 랩하는 Trio 소켓 객체입니다.</target>
        </trans-unit>
        <trans-unit id="cba6eddc865e8ef02041cf8e92b113b668fdb1fa" translate="yes" xml:space="preserve">
          <source>The abstract Stream API</source>
          <target state="translated">추상 스트림 API</target>
        </trans-unit>
        <trans-unit id="ed1ab01ce9f6eeb35a966504829dfe0650d97783" translate="yes" xml:space="preserve">
          <source>The amount of capacity that&amp;rsquo;s available to use.</source>
          <target state="translated">사용 가능한 용량입니다.</target>
        </trans-unit>
        <trans-unit id="27aed0b7977904cec1e146409f5e000ca057c3cc" translate="yes" xml:space="preserve">
          <source>The amount of capacity that&amp;rsquo;s currently in use.</source>
          <target state="translated">현재 사용중인 용량입니다.</target>
        </trans-unit>
        <trans-unit id="f05a5bfc3a671c87ae02936d446663b7d98d9b51" translate="yes" xml:space="preserve">
          <source>The async iterator blocks until a signal arrives, and then yields it.</source>
          <target state="translated">비동기 반복기는 신호가 도착할 때까지 차단 한 다음 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ff85645d494e8892b98a41f73ef597d781b10cf2" translate="yes" xml:space="preserve">
          <source>The basic interface for running a subprocess start-to-finish is &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;trio.run_process()&lt;/code&gt;&lt;/a&gt;. It always waits for the subprocess to exit before returning, so there&amp;rsquo;s no need to worry about leaving a process running by mistake after you&amp;rsquo;ve gone on to do other things. &lt;a href=&quot;#trio.run_process&quot;&gt;&lt;code&gt;run_process()&lt;/code&gt;&lt;/a&gt; is similar to the standard library &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.run&quot;&gt;&lt;code&gt;subprocess.run()&lt;/code&gt;&lt;/a&gt; function, but tries to have safer defaults: with no options, the subprocess&amp;rsquo;s input is empty rather than coming from the user&amp;rsquo;s terminal, and a failure in the subprocess will be propagated as a &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError&quot;&gt;&lt;code&gt;subprocess.CalledProcessError&lt;/code&gt;&lt;/a&gt; exception. Of course, these defaults can be changed where necessary.</source>
          <target state="translated">서브 프로세스 시작-완료를 실행하기위한 기본 인터페이스는 &lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;trio.run_process()&lt;/code&gt; &lt;/a&gt; 입니다. 리턴하기 전에 항상 서브 프로세스가 종료 될 때까지 대기하므로 다른 작업을 수행 한 후에 실수로 프로세스를 실행하는 것에 대해 걱정할 필요가 없습니다. &lt;a href=&quot;#trio.run_process&quot;&gt; &lt;code&gt;run_process()&lt;/code&gt; &lt;/a&gt; 는 표준 라이브러리 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.run&quot;&gt; &lt;code&gt;subprocess.run()&lt;/code&gt; &lt;/a&gt; 함수 와 유사 하지만 더 안전한 기본값을 사용하려고 시도합니다. 옵션이 없으면 하위 프로세스의 입력이 사용자의 터미널에서 오는 것이 아니라 비어 있으며 하위 프로세스의 실패가 다음과 같이 전파됩니다. &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError&quot;&gt; &lt;code&gt;subprocess.CalledProcessError&lt;/code&gt; 의&lt;/a&gt; 예외입니다. 물론 이러한 기본값은 필요한 경우 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b090dfb35042436a7ca99fd5410fd44306c03217" translate="yes" xml:space="preserve">
          <source>The call is effectively run as part of a system task (see &lt;a href=&quot;#trio.hazmat.spawn_system_task&quot;&gt;&lt;code&gt;spawn_system_task()&lt;/code&gt;&lt;/a&gt;). In particular this means that:</source>
          <target state="translated">호출은 시스템 작업의 일부로 효과적으로 실행됩니다 ( &lt;a href=&quot;#trio.hazmat.spawn_system_task&quot;&gt; &lt;code&gt;spawn_system_task()&lt;/code&gt; &lt;/a&gt; 참조 ). 특히 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="da0df1635f15fea0d33b44e3dee1a6acb61c81e3" translate="yes" xml:space="preserve">
          <source>The call is effectively run as part of a system task (see &lt;a href=&quot;#trio.lowlevel.spawn_system_task&quot;&gt;&lt;code&gt;spawn_system_task()&lt;/code&gt;&lt;/a&gt;). In particular this means that:</source>
          <target state="translated">호출은 시스템 작업의 일부로 효과적으로 실행됩니다 ( &lt;a href=&quot;#trio.lowlevel.spawn_system_task&quot;&gt; &lt;code&gt;spawn_system_task()&lt;/code&gt; &lt;/a&gt; 참조 ). 특히 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2e085c84fa0bd56c6a1744858621eddc3529f1ab" translate="yes" xml:space="preserve">
          <source>The call will happen &amp;ldquo;soon&amp;rdquo;, but there&amp;rsquo;s no guarantee about exactly when, and no mechanism provided for finding out when it&amp;rsquo;s happened. If you need this, you&amp;rsquo;ll have to build your own.</source>
          <target state="translated">전화는 &quot;곧&quot;일어날 것이지만, 언제 정확한지에 대한 보장은 없으며, 언제 발생했는지를 알기위한 메커니즘도 제공되지 않습니다. 이것이 필요한 경우 자신 만의 것을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="f65883a9e5f4663eec2ec83235e2b12a73452383" translate="yes" xml:space="preserve">
          <source>The call&amp;rsquo;s context transitions to a cancelled state (e.g. due to a timeout expiring). When this happens, the &lt;code&gt;abort_func&lt;/code&gt; is called. Its interface looks like:</source>
          <target state="translated">통화 컨텍스트가 취소 된 상태로 전환됩니다 (예 : 시간 초과 만료로 인해). 이 경우 &lt;code&gt;abort_func&lt;/code&gt; 가 호출됩니다. 인터페이스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5fbb59f871095d18125dac21e3ce5f6c4a428f18" translate="yes" xml:space="preserve">
          <source>The child process runs in the same process group as the parent Trio process, so a Ctrl+C will be delivered simultaneously to both parent and child. If you don&amp;rsquo;t want this behavior, consult your platform&amp;rsquo;s documentation for starting child processes in a different process group.</source>
          <target state="translated">자식 프로세스는 부모 Trio 프로세스와 동일한 프로세스 그룹에서 실행되므로 Ctrl + C는 부모와 자식 모두에게 동시에 전달됩니다. 이 동작을 원하지 않으면 다른 프로세스 그룹에서 하위 프로세스를 시작하기위한 플랫폼 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c976c6c8d5145bd4ff6affacb6c3f1362c034af5" translate="yes" xml:space="preserve">
          <source>The child task inherits its parent nursery&amp;rsquo;s cancel scopes.</source>
          <target state="translated">자식 작업은 부모 보육원의 취소 범위를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="c1ab1cbf820d8f59e91b46c89d08aa0c12ea8f78" translate="yes" xml:space="preserve">
          <source>The cleanup of the generator occurs in a cancelled context, i.e., all blocking calls executed during cleanup will raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;. This is to compensate for the fact that any timeouts surrounding the original use of the generator have been long since forgotten.</source>
          <target state="translated">생성기 정리는 취소 된 컨텍스트에서 발생합니다. 즉, 정리 중에 실행 된 모든 차단 호출은 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 시킵니다. 이것은 생성기의 원래 사용을 둘러싼 시간 초과가 잊혀진 지 오래되었다는 사실을 보상하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="fc1f039bb2a071befdb1d5415e64c53631ab9639" translate="yes" xml:space="preserve">
          <source>The cleanup runs without access to any &lt;a href=&quot;#task-local-storage&quot;&gt;context variables&lt;/a&gt; that may have been present when the generator was originally being used.</source>
          <target state="translated">생성기가 원래 사용 중이었을 때 존재할 수 있는 &lt;a href=&quot;#task-local-storage&quot;&gt;컨텍스트 변수에&lt;/a&gt; 대한 액세스없이 정리가 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="090b8413d6d5997349650354696f3c9148019f8b" translate="yes" xml:space="preserve">
          <source>The clock keeps an eye on the run loop, and if at any point it detects that all tasks have been blocked for this many real seconds (i.e., according to the actual clock, not this clock), then the clock automatically jumps ahead to the run loop&amp;rsquo;s next scheduled timeout. Default is &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt;&lt;code&gt;math.inf&lt;/code&gt;&lt;/a&gt;, i.e., to never autojump. You can assign to this attribute to change it.</source>
          <target state="translated">시계는 런 루프를 주시하고, 어떤 시점에서 모든 실제 작업이이 많은 실제 초 동안 (즉,이 시계가 아닌 실제 시계에 따라) 차단되었음을 감지하면 시계가 자동으로 앞쪽으로 이동합니다. 루프의 다음 예정된 시간 초과를 실행합니다. 기본값은 &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt; &lt;code&gt;math.inf&lt;/code&gt; 입니다&lt;/a&gt; . 즉, 절대 자동 점프하지 않습니다. 이 속성에 할당하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdc3a0eca08ee71b9b3549872b59ce6be02757ec" translate="yes" xml:space="preserve">
          <source>The clones all share the same underlying channel. Whenever a clone &lt;a href=&quot;#trio.MemoryReceiveChannel.receive&quot;&gt;&lt;code&gt;receive()&lt;/code&gt;&lt;/a&gt;s a value, it is removed from the channel and the other clones do &lt;em&gt;not&lt;/em&gt; receive that value. If you want to send multiple copies of the same stream of values to multiple destinations, like &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools.tee&quot;&gt;&lt;code&gt;itertools.tee()&lt;/code&gt;&lt;/a&gt;, then you need to find some other solution; this method does &lt;em&gt;not&lt;/em&gt; do that.</source>
          <target state="translated">클론은 모두 동일한 기본 채널을 공유합니다. 클론 &lt;a href=&quot;#trio.MemoryReceiveChannel.receive&quot;&gt; &lt;code&gt;receive()&lt;/code&gt; &lt;/a&gt; sa 값은 채널에서 제거되고 다른 클론은 해당 값을받지 &lt;em&gt;않습니다&lt;/em&gt; . &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools.tee&quot;&gt; &lt;code&gt;itertools.tee()&lt;/code&gt; &lt;/a&gt; 와 같이 동일한 값 스트림의 여러 사본을 여러 대상으로 보내려면 다른 솔루션을 찾아야합니다. 이 방법은 그렇게 하지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8484bcc0221be6040109ffa7d83b7570997846cf" translate="yes" xml:space="preserve">
          <source>The command to run and its arguments usually must be passed to Trio&amp;rsquo;s subprocess APIs as a sequence of strings, where the first element in the sequence specifies the command to run and the remaining elements specify its arguments, one argument per element. This form is used because it avoids potential quoting pitfalls; for example, you can run &lt;code&gt;[&quot;cp&quot;, &quot;-f&quot;, source_file, dest_file]&lt;/code&gt; without worrying about whether &lt;code&gt;source_file&lt;/code&gt; or &lt;code&gt;dest_file&lt;/code&gt; contains spaces.</source>
          <target state="translated">실행할 명령과 인수는 일반적으로 문자열 시퀀스로 Trio의 하위 프로세스 API에 전달되어야합니다. 여기서 시퀀스의 첫 번째 요소는 실행할 명령을 지정하고 나머지 요소는 해당 인수를 요소 당 하나의 인수로 지정합니다. 이 형식은 잠재적 인 인용 함정을 피하기 때문에 사용됩니다. 예를 들어, &lt;code&gt;source_file&lt;/code&gt; 또는 &lt;code&gt;dest_file&lt;/code&gt; 에 공백이 있는지 걱정하지 않고 &lt;code&gt;[&quot;cp&quot;, &quot;-f&quot;, source_file, dest_file]&lt;/code&gt; 을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4730db3841ecac8c8cf89e3a6be900006068c1f2" translate="yes" xml:space="preserve">
          <source>The context manager &lt;code&gt;__enter__&lt;/code&gt; returns the &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; object itself, so you can also write &lt;code&gt;with trio.CancelScope() as
cancel_scope:&lt;/code&gt;.</source>
          <target state="translated">컨텍스트 관리자 &lt;code&gt;__enter__&lt;/code&gt; 는 &lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; &lt;/a&gt; 객체 자체를 반환 하므로 &lt;code&gt;with trio.CancelScope() as cancel_scope:&lt;/code&gt; 쓸 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc3186b88676ea5d5847e4ef990e5751bbba3807" translate="yes" xml:space="preserve">
          <source>The conventional way to define &lt;code&gt;async_fn&lt;/code&gt; is like:</source>
          <target state="translated">&lt;code&gt;async_fn&lt;/code&gt; 을 정의하는 일반적인 방법 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="285a971ece21b42e0c4e6df991ed9acdbc0ef226" translate="yes" xml:space="preserve">
          <source>The core channel API is defined by the abstract base classes &lt;a href=&quot;reference-io#trio.abc.SendChannel&quot;&gt;&lt;code&gt;trio.abc.SendChannel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;trio.abc.ReceiveChannel&lt;/code&gt;&lt;/a&gt;. You can use these to implement your own custom channels, that do things like pass objects between processes or over the network. But in many cases, you just want to pass objects between different tasks inside a single process, and for that you can use &lt;a href=&quot;#trio.open_memory_channel&quot;&gt;&lt;code&gt;trio.open_memory_channel()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">핵심 채널 API는 추상 기본 클래스 &lt;a href=&quot;reference-io#trio.abc.SendChannel&quot;&gt; &lt;code&gt;trio.abc.SendChannel&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;trio.abc.ReceiveChannel&lt;/code&gt; 에&lt;/a&gt; 의해 정의됩니다 . 이를 사용하여 프로세스간에 또는 네트워크를 통해 객체를 전달하는 것과 같은 고유의 사용자 정의 채널을 구현할 수 있습니다. 그러나 많은 경우 단일 프로세스 내에서 서로 다른 작업간에 객체를 전달하려고하며 &lt;a href=&quot;#trio.open_memory_channel&quot;&gt; &lt;code&gt;trio.open_memory_channel()&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="616f1878bad341382d56b04b9e33c8f93029c10b" translate="yes" xml:space="preserve">
          <source>The current clock</source>
          <target state="translated">현재 시계</target>
        </trans-unit>
        <trans-unit id="4995ded951b2fbe16c164c4c7f4d5f2dc2fffe22" translate="yes" xml:space="preserve">
          <source>The current time.</source>
          <target state="translated">현재 시간</target>
        </trans-unit>
        <trans-unit id="d687bbc14082046996832ddcdec42c12e4cae031" translate="yes" xml:space="preserve">
          <source>The current value of the semaphore.</source>
          <target state="translated">세마포어의 현재 값.</target>
        </trans-unit>
        <trans-unit id="3eb350ac6cebc4b1fa0724100f48143c6b0ab33d" translate="yes" xml:space="preserve">
          <source>The data received.</source>
          <target state="translated">받은 데이터.</target>
        </trans-unit>
        <trans-unit id="9036f43c367d4a503f60d7664967b2259da5ae52" translate="yes" xml:space="preserve">
          <source>The default behavior is nice because it means that even if you accidentally write an infinite loop that never executes any checkpoints, then you can still break out of it using control-C. The alternative behavior is nice if you&amp;rsquo;re paranoid about a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; at just the wrong place leaving your program in an inconsistent state, because it means that you only have to worry about &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; at the exact same places where you already have to worry about &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">체크 포인트를 절대 실행하지 않는 무한 루프를 실수로 작성하더라도 control-C를 사용하여 여전히 벗어날 수 있기 때문에 기본 동작은 좋습니다. 프로그램이 일관성이없는 상태를 유지하는 잘못된 장소에서 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 에 대해 편집증을 앓고 있다면 다른 행동이 좋습니다 . 왜냐하면 이미 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 해야 할 곳과 동일한 곳에서 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 에 대해서만 걱정하면된다는 의미이기 때문입니다. .</target>
        </trans-unit>
        <trans-unit id="0e55b739f210dc55513c361f9fe51be776304fc5" translate="yes" xml:space="preserve">
          <source>The default cleanup logic is often sufficient for simple cases, but what if you want a more sophisticated supervisor? For example, maybe you have &lt;a href=&quot;http://learnyousomeerlang.com/supervisors&quot;&gt;Erlang envy&lt;/a&gt; and want features like automatic restart of crashed tasks. Trio itself doesn&amp;rsquo;t provide these kinds of features, but you can build them on top; Trio&amp;rsquo;s goal is to enforce basic hygiene and then get out of your way. (Specifically: Trio won&amp;rsquo;t let you build a supervisor that exits and leaves orphaned tasks behind, and if you have an unhandled exception due to bugs or laziness then Trio will make sure they propagate.) And then you can wrap your fancy supervisor up in a library and put it on PyPI, because supervisors are tricky and there&amp;rsquo;s no reason everyone should have to write their own.</source>
          <target state="translated">기본 정리 논리는 간단한 경우에 충분하지만보다 정교한 감독자를 원한다면 어떻게해야합니까? 예를 들어, &lt;a href=&quot;http://learnyousomeerlang.com/supervisors&quot;&gt;Erlang 부러워&lt;/a&gt; 하고 충돌 한 작업의 자동 재시작과 같은 기능을 원할 수 있습니다. Trio 자체는 이러한 종류의 기능을 제공하지 않지만 그 위에 기능을 구축 할 수 있습니다. Trio의 목표는 기본 위생을 시행 한 다음 벗어나는 것입니다. (구체적으로 : Trio를 사용하면 고아 작업을 종료하고 떠나는 관리자를 만들 수 없으며 버그 나 게으름으로 인해 처리되지 않은 예외가 발생하면 Trio가 전파되도록해야합니다.) 그러면 멋진 관리자를 감쌀 수 있습니다. 관리자가 까다 롭고 모든 사람이 직접 작성해야 할 이유가 없기 때문에 라이브러리에서 PyPI에 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="5c9ed5e68e8b87af228bafd594375bf1414c72bb" translate="yes" xml:space="preserve">
          <source>The default clock is currently implemented as &lt;a href=&quot;https://docs.python.org/3/library/time.html#time.perf_counter&quot;&gt;&lt;code&gt;time.perf_counter()&lt;/code&gt;&lt;/a&gt; plus a large random offset. The idea here is to catch code that accidentally uses &lt;a href=&quot;https://docs.python.org/3/library/time.html#time.perf_counter&quot;&gt;&lt;code&gt;time.perf_counter()&lt;/code&gt;&lt;/a&gt; early, which should help keep our options open for &lt;a href=&quot;https://github.com/python-trio/trio/issues/33&quot;&gt;changing the clock implementation later&lt;/a&gt;, and (more importantly) make sure you can be confident that custom clocks like &lt;a href=&quot;reference-testing#trio.testing.MockClock&quot;&gt;&lt;code&gt;trio.testing.MockClock&lt;/code&gt;&lt;/a&gt; will work with third-party libraries you don&amp;rsquo;t control.</source>
          <target state="translated">기본 클럭은 현재 &lt;a href=&quot;https://docs.python.org/3/library/time.html#time.perf_counter&quot;&gt; &lt;code&gt;time.perf_counter()&lt;/code&gt; &lt;/a&gt; 및 큰 임의 오프셋으로 구현됩니다 . 여기서 아이디어는 실수로 &lt;a href=&quot;https://docs.python.org/3/library/time.html#time.perf_counter&quot;&gt; &lt;code&gt;time.perf_counter()&lt;/code&gt; &lt;/a&gt; 일찍 사용하는 코드를 포착 &lt;a href=&quot;https://github.com/python-trio/trio/issues/33&quot;&gt;하여 나중에 시계 구현&lt;/a&gt; 을 변경하기 위해 옵션을 열어 두는 것입니다 (더 중요한 것은 &lt;a href=&quot;reference-testing#trio.testing.MockClock&quot;&gt; &lt;code&gt;trio.testing.MockClock&lt;/code&gt; &lt;/a&gt; 과 같은 사용자 정의 시계를 확신 할 수 있음) . MockClock 은 제어하지 않는 타사 라이브러리에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="161d86aa18f9fc36797e67f6ae10b87299de29e3" translate="yes" xml:space="preserve">
          <source>The difference between &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt;&lt;code&gt;send_eof()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; is that &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt;&lt;code&gt;send_eof()&lt;/code&gt;&lt;/a&gt; is a &lt;em&gt;unidirectional&lt;/em&gt; end-of-file indication. After you call this method, you shouldn&amp;rsquo;t try sending any more data on this stream, and your remote peer should receive an end-of-file indication (eventually, after receiving all the data you sent before that). But, they may continue to send data to you, and you can continue to receive it by calling &lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt;&lt;code&gt;receive_some()&lt;/code&gt;&lt;/a&gt;. You can think of it as calling &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; on just the &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt; &amp;ldquo;half&amp;rdquo; of the stream object (and in fact that&amp;rsquo;s literally how &lt;a href=&quot;#trio.StapledStream&quot;&gt;&lt;code&gt;trio.StapledStream&lt;/code&gt;&lt;/a&gt; implements it).</source>
          <target state="translated">차이 &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt; &lt;code&gt;send_eof()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 즉 &lt;a href=&quot;#trio.abc.HalfCloseableStream.send_eof&quot;&gt; &lt;code&gt;send_eof()&lt;/code&gt; &lt;/a&gt; A는 &lt;em&gt;단방향&lt;/em&gt; 파일 끝 표시. 이 메서드를 호출 한 후에는이 스트림에서 더 이상 데이터를 보내려고 시도하지 않아야하며 원격 피어는 파일 끝 표시를 받아야합니다 (결국, 그 전에 보낸 모든 데이터를받은 후). 그러나 계속해서 데이터를 보낼 수 있으며 &lt;a href=&quot;#trio.abc.ReceiveStream.receive_some&quot;&gt; &lt;code&gt;receive_some()&lt;/code&gt; &lt;/a&gt; 을 호출하여 계속해서받을 수 있습니다 . 스트림 객체 의 &lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; &amp;ldquo;반쪽&amp;rdquo; 에서 &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 를 호출하는 것으로 생각할 수 있습니다 (실제로 &lt;a href=&quot;#trio.StapledStream&quot;&gt; &lt;code&gt;trio.StapledStream&lt;/code&gt; 이&lt;/a&gt; 구현하는 방식입니다).</target>
        </trans-unit>
        <trans-unit id="f54f20adf46b020768fc2d9699f83c2a84a5dbee" translate="yes" xml:space="preserve">
          <source>The difference between &lt;a href=&quot;#trio.sleep&quot;&gt;&lt;code&gt;sleep()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.sleep_until&quot;&gt;&lt;code&gt;sleep_until()&lt;/code&gt;&lt;/a&gt; is that the former takes a relative time and the latter takes an absolute time.</source>
          <target state="translated">&lt;a href=&quot;#trio.sleep&quot;&gt; &lt;code&gt;sleep()&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;#trio.sleep_until&quot;&gt; &lt;code&gt;sleep_until()&lt;/code&gt; &lt;/a&gt; 의 차이점 은 전자는 상대적 시간이 걸리고 후자는 절대 시간이 걸린다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="73cc2ba69f4c206ad58a296445de0bca80474d34" translate="yes" xml:space="preserve">
          <source>The downside of this kind of thread pool is that sometimes, you need more sophisticated logic for controlling how many threads are run at once. For example, you might want a policy like &amp;ldquo;at most 20 threads total, but no more than 3 of those can be running jobs associated with the same user account&amp;rdquo;, or you might want a pool whose size is dynamically adjusted over time in response to system conditions.</source>
          <target state="translated">이러한 종류의 스레드 풀의 단점은 때때로 한 번에 실행되는 스레드 수를 제어하기 위해 더 정교한 논리가 필요하다는 것입니다. 예를 들어, &quot;총 20 개의 스레드 만 가능하지만 그 중 3 개 이상이 동일한 사용자 계정과 연관된 작업을 실행할 수 있습니다&quot;와 같은 정책을 원하거나 시간에 따라 크기가 동적으로 조정되는 풀을 원할 수 있습니다. 시스템 조건.</target>
        </trans-unit>
        <trans-unit id="35be47a84f944c2be421f7a4c36aaf2ef2022432" translate="yes" xml:space="preserve">
          <source>The end result is that Trio has successfully cancelled exactly the work that was happening within the scope that was cancelled.</source>
          <target state="translated">결과적으로 Trio는 취소 된 범위 내에서 발생한 작업을 정확하게 취소했습니다.</target>
        </trans-unit>
        <trans-unit id="0a65d9d853aa11c16016bf7c9ce9148c89cc1dcf" translate="yes" xml:space="preserve">
          <source>The end result is that data automatically flows from the &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt;&lt;code&gt;MemorySendStream&lt;/code&gt;&lt;/a&gt; to the &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt;&lt;code&gt;MemoryReceiveStream&lt;/code&gt;&lt;/a&gt;. But you&amp;rsquo;re also free to rearrange things however you like. For example, you can temporarily set the &lt;a href=&quot;#trio.testing.MemorySendStream.send_all_hook&quot;&gt;&lt;code&gt;send_all_hook&lt;/code&gt;&lt;/a&gt; to None if you want to simulate a stall in data transmission. Or see &lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt;&lt;code&gt;memory_stream_pair()&lt;/code&gt;&lt;/a&gt; for a more elaborate example.</source>
          <target state="translated">결과적으로 데이터가 &lt;a href=&quot;#trio.testing.MemorySendStream&quot;&gt; &lt;code&gt;MemorySendStream&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;#trio.testing.MemoryReceiveStream&quot;&gt; &lt;code&gt;MemoryReceiveStream&lt;/code&gt; &lt;/a&gt; 으로 자동으로 흐릅니다 . 그러나 원하는 것을 자유롭게 재 배열 할 수도 있습니다. 예를 들어, 데이터 전송시 스톨을 시뮬레이션하려는 경우 &lt;a href=&quot;#trio.testing.MemorySendStream.send_all_hook&quot;&gt; &lt;code&gt;send_all_hook&lt;/code&gt; &lt;/a&gt; 을 일시적 으로 없음 으로 설정할 수 있습니다 . 더 자세한 예는 &lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt; &lt;code&gt;memory_stream_pair()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c02286292f2ec8e799d942bfe364baa2b77891d9" translate="yes" xml:space="preserve">
          <source>The exit status of the process (an integer), or &lt;code&gt;None&lt;/code&gt; if it is not yet known to have exited.</source>
          <target state="translated">프로세스의 종료 상태 (정수) 또는 아직 종료되지 않은 경우 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="764eaae6504831ac4ae991985061b3fff32743ff" translate="yes" xml:space="preserve">
          <source>The exit status of the process (an integer), or &lt;code&gt;None&lt;/code&gt; if it&amp;rsquo;s still running.</source>
          <target state="translated">프로세스의 종료 상태 (정수) 또는 아직 실행중인 경우 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="125adfc9dd9147da3a2e6de16b33684508367c26" translate="yes" xml:space="preserve">
          <source>The exit status of the process, or &lt;code&gt;None&lt;/code&gt; if it is still running; see &lt;a href=&quot;#trio.Process.returncode&quot;&gt;&lt;code&gt;returncode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프로세스의 종료 상태이거나 여전히 실행중인 경우 &lt;code&gt;None&lt;/code&gt; . &lt;a href=&quot;#trio.Process.returncode&quot;&gt; &lt;code&gt;returncode&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="56a77a4877253a18474ef745e005246f7f5751e2" translate="yes" xml:space="preserve">
          <source>The exit status of the process; see &lt;a href=&quot;#trio.Process.returncode&quot;&gt;&lt;code&gt;returncode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프로세스의 종료 상태 &lt;a href=&quot;#trio.Process.returncode&quot;&gt; &lt;code&gt;returncode&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="64142ed18435a7e0439ede425fac64c34f741197" translate="yes" xml:space="preserve">
          <source>The following methods are identical to their equivalents in &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt;&lt;code&gt;socket.socket()&lt;/code&gt;&lt;/a&gt;, except async, and the ones that take address arguments require pre-resolved addresses:</source>
          <target state="translated">다음 메소드는 async를 제외하고 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt; &lt;code&gt;socket.socket()&lt;/code&gt; &lt;/a&gt; 의 해당 메소드와 동일하며 주소 인수를 사용하는 메소드 에는 사전 해결 된 주소가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="27a7e32f93c8094ed84ed0c797a3d1d3450a48a0" translate="yes" xml:space="preserve">
          <source>The general idea is that at any given moment, &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; maintains a set of &amp;ldquo;instruments&amp;rdquo;, which are objects that implement the &lt;a href=&quot;#trio.abc.Instrument&quot;&gt;&lt;code&gt;trio.abc.Instrument&lt;/code&gt;&lt;/a&gt; interface. When an interesting event happens, it loops over these instruments and notifies them by calling an appropriate method. The tutorial has &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/tutorial.html#tutorial-instrument-example&quot;&gt;a simple example of using this for tracing&lt;/a&gt;.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#trio.abc.Instrument&quot;&gt; &lt;code&gt;trio.abc.Instrument&lt;/code&gt; &lt;/a&gt; 인터페이스 를 구현하는 객체 인 일련의 &quot;악기&quot;를 유지 관리합니다 . 흥미로운 이벤트가 발생하면 이러한 계측기를 반복하고 적절한 메소드를 호출하여 알려줍니다. 학습서에는 &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/tutorial.html#tutorial-instrument-example&quot;&gt;이를 추적에 사용하는 간단한 예제가&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="38f9e958d8079cb7f5d77b4f44e525926879c860" translate="yes" xml:space="preserve">
          <source>The general idea is that at any given moment, &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; maintains a set of &amp;ldquo;instruments&amp;rdquo;, which are objects that implement the &lt;a href=&quot;#trio.abc.Instrument&quot;&gt;&lt;code&gt;trio.abc.Instrument&lt;/code&gt;&lt;/a&gt; interface. When an interesting event happens, it loops over these instruments and notifies them by calling an appropriate method. The tutorial has &lt;a href=&quot;https://trio.readthedocs.io/en/v0.18.0/tutorial.html#tutorial-instrument-example&quot;&gt;a simple example of using this for tracing&lt;/a&gt;.</source>
          <target state="translated">일반적인 아이디어는 주어진 순간에 &lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 이 &lt;a href=&quot;#trio.abc.Instrument&quot;&gt; &lt;code&gt;trio.abc.Instrument&lt;/code&gt; &lt;/a&gt; 인터페이스 를 구현하는 객체 인 &quot;instrument&quot;세트를 유지한다는 것 입니다. 흥미로운 이벤트가 발생하면 이러한 계측기를 반복하고 적절한 메서드를 호출하여 알립니다. 자습서에는 &lt;a href=&quot;https://trio.readthedocs.io/en/v0.18.0/tutorial.html#tutorial-instrument-example&quot;&gt;추적을 위해 이것을 사용하는 간단한 예제가&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e502d07802ec7eba2f0fb1852ed0486ee5e9106" translate="yes" xml:space="preserve">
          <source>The high-level network interface is built on top of our stream abstraction.</source>
          <target state="translated">높은 수준의 네트워크 인터페이스는 스트림 추상화 위에 구축됩니다.</target>
        </trans-unit>
        <trans-unit id="5e3a6a65d42a4a7a54e93e2fdefe2f8b94a1ab58" translate="yes" xml:space="preserve">
          <source>The idea behind guest mode is to combine the best parts of each approach: we move Trio&amp;rsquo;s step 1 into a separate worker thread, while keeping Trio&amp;rsquo;s step 2 in the main host thread. This way, when the application is idle, both event loops do their &lt;code&gt;sleep_until_something_happens()&lt;/code&gt; at the same time in their own threads. But when the app wakes up and your code is actually running, it all happens in a single thread. The threading trickiness is all handled transparently inside Trio.</source>
          <target state="translated">게스트 모드의 기본 아이디어는 각 접근 방식의 가장 좋은 부분을 결합하는 것입니다. Trio의 1 단계를 별도의 작업자 스레드로 이동하고 Trio의 2 단계를 기본 호스트 스레드에 유지합니다. 이렇게하면 애플리케이션이 유휴 상태 일 때 두 이벤트 루프가 자체 스레드에서 동시에 &lt;code&gt;sleep_until_something_happens()&lt;/code&gt; 를 수행 합니다. 그러나 앱이 깨어나고 코드가 실제로 실행되면 모든 것이 단일 스레드에서 발생합니다. 스레딩의 까다로운 점은 모두 Trio 내에서 투명하게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="7f835797b23a892cd0ec30a65a33991b78d40543" translate="yes" xml:space="preserve">
          <source>The instrument API provides a standard way to add custom instrumentation to the run loop. Want to make a histogram of scheduling latencies, log a stack trace of any task that blocks the run loop for &amp;gt;50 ms, or measure what percentage of your process&amp;rsquo;s running time is spent waiting for I/O? This is the place.</source>
          <target state="translated">인스트루먼트 API는 런 루프에 커스텀 인스 트루먼 테이션을 추가하는 표준 방법을 제공합니다. 지연 시간 예약 히스토그램을 작성하고&amp;gt; 50ms 동안 실행 루프를 차단하는 모든 작업의 ​​스택 추적을 기록하거나 I / O를 기다리는 데 소요되는 프로세스 실행 시간의 백분율을 측정 하시겠습니까? 이곳입니다.</target>
        </trans-unit>
        <trans-unit id="8805f7990c95db20674c8cf0adbf6a62540abaa7" translate="yes" xml:space="preserve">
          <source>The interface for custom run loop clocks.</source>
          <target state="translated">커스텀 런 루프 클럭을위한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="8d2a9967f7c764df943ab1556c1344b5805ebda1" translate="yes" xml:space="preserve">
          <source>The interface for run loop instrumentation.</source>
          <target state="translated">런 루프 계측을위한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="24dad175acbf711fb3b0ec0ffe0f2c174484725f" translate="yes" xml:space="preserve">
          <source>The list of exception objects that this &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt; represents.</source>
          <target state="translated">이 &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; 가&lt;/a&gt; 나타내는 예외 객체의리스트입니다 .</target>
        </trans-unit>
        <trans-unit id="d97d917dc061cfa035e2b53cc57e93026318973d" translate="yes" xml:space="preserve">
          <source>The local IP address or hostname to use as the source for outgoing connections. If &lt;code&gt;None&lt;/code&gt;, we let the OS pick the source IP.</source>
          <target state="translated">나가는 연결의 소스로 사용할 로컬 IP 주소 또는 호스트 이름입니다. 경우 &lt;code&gt;None&lt;/code&gt; , 우리는 OS의 소스 IP를 선택하자.</target>
        </trans-unit>
        <trans-unit id="b1672ae196b4e642ba06023f24ab7cc43131e887" translate="yes" xml:space="preserve">
          <source>The local interface to bind to. This is passed to &lt;a href=&quot;#trio.socket.getaddrinfo&quot;&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt;&lt;/a&gt; with the &lt;code&gt;AI_PASSIVE&lt;/code&gt; flag set.</source>
          <target state="translated">바인딩 할 로컬 인터페이스입니다. 이는 전달한다 &lt;a href=&quot;#trio.socket.getaddrinfo&quot;&gt; &lt;code&gt;getaddrinfo()&lt;/code&gt; &lt;/a&gt; 와 &lt;code&gt;AI_PASSIVE&lt;/code&gt; 플래그가 설정.</target>
        </trans-unit>
        <trans-unit id="14c98d1cac25a3b78cb6648f736ac16134a060c5" translate="yes" xml:space="preserve">
          <source>The maximum allowed value. May be None to indicate no limit.</source>
          <target state="translated">허용되는 최대 값. 제한 없음을 나타내려면 없음 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e07a666dfbfb8644fe55abda725387879d01201f" translate="yes" xml:space="preserve">
          <source>The most common reason to call this would be if you want to modify its &lt;a href=&quot;#trio.CapacityLimiter.total_tokens&quot;&gt;&lt;code&gt;total_tokens&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">이를 호출하는 가장 일반적인 이유는 &lt;a href=&quot;#trio.CapacityLimiter.total_tokens&quot;&gt; &lt;code&gt;total_tokens&lt;/code&gt; &lt;/a&gt; 속성 을 수정하려는 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="7511fb68df6cf2da5466a9d58a8996e5da043bc2" translate="yes" xml:space="preserve">
          <source>The next two functions are used &lt;em&gt;together&lt;/em&gt; to make up a checkpoint:</source>
          <target state="translated">다음 두 기능은 체크 포인트를 구성하기 위해 &lt;em&gt;함께&lt;/em&gt; 사용 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f81d0f7d0980e217423a2ccc40b05846cbdc06e4" translate="yes" xml:space="preserve">
          <source>The number of real seconds to sleep until the given deadline. May be &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt;&lt;code&gt;math.inf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 마감일까지 잠을 자게 될 실제 시간 (초)입니다. &lt;a href=&quot;https://docs.python.org/3/library/math.html#math.inf&quot;&gt; &lt;code&gt;math.inf&lt;/code&gt; &lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37eae6844d9390786325d85229c1ce9b532328ee" translate="yes" xml:space="preserve">
          <source>The nurseries this task contains.</source>
          <target state="translated">이 작업에 포함 된 보육원.</target>
        </trans-unit>
        <trans-unit id="177a7ce78b560282b7d992c4ec3372923f31b6c2" translate="yes" xml:space="preserve">
          <source>The nursery API</source>
          <target state="translated">보육원 API</target>
        </trans-unit>
        <trans-unit id="8d7ae1a4a8aa454bf6b6d79e73ec598b862fddd0" translate="yes" xml:space="preserve">
          <source>The nursery is marked as &amp;ldquo;closed&amp;rdquo;, meaning that no new tasks can be started inside it.</source>
          <target state="translated">보육원은&amp;ldquo;폐쇄&amp;rdquo;로 표시되어있어 새로운 작업을 시작할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e86ba7e9365d0994757a3cc78cdf4d4a2887a4b2" translate="yes" xml:space="preserve">
          <source>The nursery this task is inside (or None if this is the &amp;ldquo;init&amp;rdquo; task).</source>
          <target state="translated">이 작업이 포함 된 보육원 (또는 &quot;초기&quot;작업 인 경우에는 없음).</target>
        </trans-unit>
        <trans-unit id="bbbe1db186ffd127db3c1b33bfa29d82594cf817" translate="yes" xml:space="preserve">
          <source>The nursery this task will be inside after it calls &lt;code&gt;task_status.started()&lt;/code&gt;.</source>
          <target state="translated">이 태스크는 &lt;code&gt;task_status.started()&lt;/code&gt; 호출 한 후 내부에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a61b8d74747e89d4158a137ff8a09c9922960de0" translate="yes" xml:space="preserve">
          <source>The nursery will remain open until all child tasks have completed, or until it is cancelled, at which point it will cancel all its remaining child tasks and close.</source>
          <target state="translated">보육원은 모든 하위 작업이 완료 될 때까지 또는 취소 될 때까지 남아있는 모든 하위 작업을 취소하고 닫을 때까지 계속 열려 있습니다.</target>
        </trans-unit>
        <trans-unit id="e74f79510a42647a66bf3c95ba615073d3c63132" translate="yes" xml:space="preserve">
          <source>The port to listen on.</source>
          <target state="translated">수신 할 포트입니다.</target>
        </trans-unit>
        <trans-unit id="1121984a78f092b4bacac75ab91c9cb4d443a8c8" translate="yes" xml:space="preserve">
          <source>The previous hostname resolver (which may be None).</source>
          <target state="translated">이전 호스트 이름 확인자 (없음 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="47eb3fd202a96ce8b6174dec37d51f1fd66c70e2" translate="yes" xml:space="preserve">
          <source>The previous socket factory (which may be None).</source>
          <target state="translated">이전 소켓 팩토리 (None 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="00c7eb37d4f3f8b22dbe29040f3260a6ce77789e" translate="yes" xml:space="preserve">
          <source>The problem here is step 1. Two different event loops on the same thread can take turns running user tasks in step 2, but when they&amp;rsquo;re idle and nothing is happening, they can&amp;rsquo;t both invoke their own &lt;code&gt;sleep_until_something_happens()&lt;/code&gt; function at the same time.</source>
          <target state="translated">문제는 여기에 두 개의 서로 다른 이벤트 루프를 2 단계에서 사용자 작업을 실행 교대로 할 수있는 동일한 스레드에 1 단계이지만, 그들이있는 거 유휴 아무것도 일어나고있는 때, 그들은 자신의 호출을 모두 할 수 없습니다 &lt;code&gt;sleep_until_something_happens()&lt;/code&gt; 상기 기능 동시에.</target>
        </trans-unit>
        <trans-unit id="4e2b927216cbc564308d285000e1f4433a148da5" translate="yes" xml:space="preserve">
          <source>The process ID of the child process managed by this object.</source>
          <target state="translated">이 객체가 관리하는 자식 프로세스의 프로세스 ID.</target>
        </trans-unit>
        <trans-unit id="5b93661739a17b00d39a4b1234f2fd70ed40f36e" translate="yes" xml:space="preserve">
          <source>The really important thing here is the producer&amp;rsquo;s &lt;code&gt;async with&lt;/code&gt; . When the producer exits, this closes the &lt;code&gt;send_channel&lt;/code&gt;, and that tells the consumer that no more messages are coming, so it can cleanly exit its &lt;code&gt;async for&lt;/code&gt; loop. Then the program shuts down because both tasks have exited.</source>
          <target state="translated">여기서 가장 중요한 &lt;code&gt;async with&lt;/code&gt; 제작자의 비동기입니다 . 생산자가 종료하면 &lt;code&gt;send_channel&lt;/code&gt; 이 닫히고 소비자에게 더 이상 메시지가 나오지 않음을 알리 므로 &lt;code&gt;async for&lt;/code&gt; 루프를 완전히 종료 할 수 있습니다 . 그런 다음 두 작업이 모두 종료되어 프로그램이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="28c2cb80c84becdc646dfd3b9efd1c7769ba197d" translate="yes" xml:space="preserve">
          <source>The reason for the restriction on cancel scopes has to do with the difficulty of noticing when a generator gets suspended and resumed. The cancel scopes inside the generator shouldn&amp;rsquo;t affect code running outside the generator, but Trio isn&amp;rsquo;t involved in the process of exiting and reentering the generator, so it would be hard pressed to keep its cancellation plumbing in the correct state. Nurseries use a cancel scope internally, so they have all the problems of cancel scopes plus a number of problems of their own: for example, when the generator is suspended, what should the background tasks do? There&amp;rsquo;s no good way to suspend them, but if they keep running and throw an exception, where can that exception be reraised?</source>
          <target state="translated">취소 범위에 대한 제한의 이유는 생성기가 일시 중지되고 재개되는시기를 알기 어렵 기 때문입니다. 생성기 내부의 취소 범위는 생성기 외부에서 실행되는 코드에 영향을주지 않아야하지만 Trio는 생성기를 종료하고 다시 입력하는 과정에 관여하지 않으므로 취소 배관을 올바른 상태로 유지하기가 어렵습니다. Nurseries는 내부적으로 취소 범위를 사용하므로 취소 범위의 모든 문제와 자체적 인 여러 문제가 있습니다. 예를 들어 생성기가 일시 중지되면 백그라운드 작업은 어떻게해야합니까? 일시 중단하는 좋은 방법은 없지만 계속 실행되고 예외가 발생하면 해당 예외를 어디서 다시 발생시킬 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="0450c5182bceb6cce56fb0729c22a12ca6a38fb0" translate="yes" xml:space="preserve">
          <source>The reason we distinguish between Trio functions and other functions is that we can&amp;rsquo;t make any guarantees about third party code. Checkpoint-ness is a transitive property: if function A acts as a checkpoint, and you write a function that calls function A, then your function also acts as a checkpoint. If you don&amp;rsquo;t, then it isn&amp;rsquo;t. So there&amp;rsquo;s nothing stopping someone from writing a function like:</source>
          <target state="translated">우리가 Trio 기능과 다른 기능을 구별하는 이유는 타사 코드에 대해 보장 할 수 없기 때문입니다. 검사 점은 전이 속성입니다. 함수 A가 검사 점으로 작동하고 함수 A를 호출하는 함수를 작성하면 함수도 검사 점으로 작동합니다. 그렇지 않으면 그렇지 않습니다. 따라서 누군가가 다음과 같은 함수를 작성하는 것을 막을 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="5b79184643fc427f0f5451ad2bcbe471b0aff8ab" translate="yes" xml:space="preserve">
          <source>The run-local variant of a context variable.</source>
          <target state="translated">컨텍스트 변수의 로컬 실행 변형</target>
        </trans-unit>
        <trans-unit id="31631f2ee19f6c9eddba1efb6808eed41e256ce1" translate="yes" xml:space="preserve">
          <source>The solution here is simple once you see it: there&amp;rsquo;s no requirement that a nursery object stay in the task that created it! We can write code like this:</source>
          <target state="translated">여기에서 해결책을 찾으면 간단합니다. 보육원 개체를 만든 작업에 머물 필요가 없습니다! 다음과 같은 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1fd21f3494165761aa268005e2e0795c5723a04" translate="yes" xml:space="preserve">
          <source>The split between &lt;code&gt;fn&lt;/code&gt; and &lt;code&gt;deliver&lt;/code&gt; serves two purposes. First, it&amp;rsquo;s convenient, since most callers need something like this anyway.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; 과 &lt;code&gt;deliver&lt;/code&gt; 의 분할 은 두 가지 용도로 사용됩니다. 첫째, 대부분의 발신자에게는 어쨌든 이와 같은 것이 필요하기 때문에 편리합니다.</target>
        </trans-unit>
        <trans-unit id="55e76f19fc0627ed9227f3fd3880048d89598e1e" translate="yes" xml:space="preserve">
          <source>The standard library synchronization primitives have a variety of mechanisms for specifying timeouts and blocking behavior, and of signaling whether an operation returned due to success versus a timeout.</source>
          <target state="translated">표준 라이브러리 동기화 프리미티브에는 시간 초과를 지정하고 동작을 차단하고 성공과 시간 초과로 인해 작업이 반환되는지 여부를 시그널링하는 다양한 메커니즘이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7effbc2fadcf7d55dbb5dff96899db6a2b1a697d" translate="yes" xml:space="preserve">
          <source>The top-level function in regular user tasks is unprotected.</source>
          <target state="translated">일반 사용자 작업의 최상위 기능은 보호되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf0ab80440f670597aee7f57471c11affe9f36ac" translate="yes" xml:space="preserve">
          <source>The top-level function in system tasks is protected.</source>
          <target state="translated">시스템 작업의 최상위 기능이 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="2dee7da4b40c8ed8470e444bb0b39967c3966f18" translate="yes" xml:space="preserve">
          <source>The total capacity available.</source>
          <target state="translated">사용 가능한 총 용량.</target>
        </trans-unit>
        <trans-unit id="1bb44cb89fd209709ecbf816f6d2cfd1b4bf8ed2" translate="yes" xml:space="preserve">
          <source>The total overhead will depend on your host loop, your platform, your application, etc. But we expect that in most cases, apps running in guest mode should only be 5-10% slower than the same code using &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt;. If you find that&amp;rsquo;s not true for your app, then please let us know and we&amp;rsquo;ll see if we can fix it!</source>
          <target state="translated">총 오버 헤드는 호스트 루프, 플랫폼, 애플리케이션 등에 따라 달라집니다.하지만 대부분의 경우 게스트 모드에서 실행되는 앱은 &lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run&lt;/code&gt; 을&lt;/a&gt; 사용하는 동일한 코드보다 5-10 % 느려 야 합니다. 귀하의 앱에 해당하지 않는 경우 Google에 알려 주시면 문제를 해결할 수 있는지 확인해 드리겠습니다! ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="3705e62e17c05ed2a283df571e34d9194fff82e9" translate="yes" xml:space="preserve">
          <source>The tutorial has a &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/tutorial.html#tutorial-instrument-example&quot;&gt;fully-worked example&lt;/a&gt; of defining a custom instrument to log Trio&amp;rsquo;s internal scheduling decisions.</source>
          <target state="translated">이 자습서에는 Trio의 내부 일정 결정을 기록하기 위해 사용자 지정 계측기를 정의 하는 &lt;a href=&quot;https://trio.readthedocs.io/en/v0.12.1/tutorial.html#tutorial-instrument-example&quot;&gt;완전한 예제&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="91909955fecf8653c03448ca645e97c0ac1c56fe" translate="yes" xml:space="preserve">
          <source>The tutorial has a &lt;a href=&quot;https://trio.readthedocs.io/en/v0.18.0/tutorial.html#tutorial-instrument-example&quot;&gt;fully-worked example&lt;/a&gt; of defining a custom instrument to log Trio&amp;rsquo;s internal scheduling decisions.</source>
          <target state="translated">이 튜토리얼에는 Trio의 내부 일정 결정을 기록하기 위해 사용자 지정 장비를 정의 하는 &lt;a href=&quot;https://trio.readthedocs.io/en/v0.18.0/tutorial.html#tutorial-instrument-example&quot;&gt;완전히 작동 된 예제&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="05291b85407b1a887472f9d782e55440c9965242" translate="yes" xml:space="preserve">
          <source>The two producers, A and B, send 3 messages apiece. These are then randomly distributed between the two consumers, X and Y. So we&amp;rsquo;re hoping to see some output like:</source>
          <target state="translated">두 생산자 A와 B는 각각 3 개의 메시지를 보냅니다. 그런 다음 두 소비자 X와 Y 사이에 무작위로 배포됩니다. 따라서 다음과 같은 결과를 기대합니다.</target>
        </trans-unit>
        <trans-unit id="5aa97c306d0b8d930fea25557eeb4fb3eb359691" translate="yes" xml:space="preserve">
          <source>The underlying &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#trio.StapledStream.receive_some&quot;&gt;&lt;code&gt;receive_some()&lt;/code&gt;&lt;/a&gt; is delegated to this object.</source>
          <target state="translated">기본이 &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#trio.StapledStream.receive_some&quot;&gt; &lt;code&gt;receive_some()&lt;/code&gt; &lt;/a&gt; 이이 객체에 위임되었습니다.</target>
        </trans-unit>
        <trans-unit id="f32b40ca1402eb2f4c81aefb795e70d012cce169" translate="yes" xml:space="preserve">
          <source>The underlying &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#trio.StapledStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.StapledStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt; are delegated to this object.</source>
          <target state="translated">기본 &lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#trio.StapledStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.StapledStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt; 이이 객체에 위임되었습니다.</target>
        </trans-unit>
        <trans-unit id="0ad23b6bb25552ac6357c4e430f7019864780286" translate="yes" xml:space="preserve">
          <source>The underlying listener that was passed to &lt;code&gt;__init__&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__init__&lt;/code&gt; 에 전달 된 기본 리스너입니다 .</target>
        </trans-unit>
        <trans-unit id="f33f2a0c4fd84dacf0327c8790e4bf617b9f380a" translate="yes" xml:space="preserve">
          <source>The underlying stream may be unidirectional, or bidirectional. If it&amp;rsquo;s bidirectional, then you probably want to also implement &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt;&lt;code&gt;ReceiveStream&lt;/code&gt;&lt;/a&gt;, which makes your object a &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 스트림은 단방향 또는 양방향 일 수 있습니다. 양방향 인 경우 객체를 &lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; 으로&lt;/a&gt; 만드는 &lt;a href=&quot;#trio.abc.ReceiveStream&quot;&gt; &lt;code&gt;ReceiveStream&lt;/code&gt; &lt;/a&gt; 도 구현 하려고 합니다 .</target>
        </trans-unit>
        <trans-unit id="a6e839a070895f18f3a2d8c7670c54a0bc8fe015" translate="yes" xml:space="preserve">
          <source>The underlying stream may be unidirectional, or bidirectional. If it&amp;rsquo;s bidirectional, then you probably want to also implement &lt;a href=&quot;#trio.abc.SendStream&quot;&gt;&lt;code&gt;SendStream&lt;/code&gt;&lt;/a&gt;, which makes your object a &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 스트림은 단방향 또는 양방향 일 수 있습니다. 양방향 인 경우 &lt;a href=&quot;#trio.abc.SendStream&quot;&gt; &lt;code&gt;SendStream&lt;/code&gt; &lt;/a&gt; 을 구현 하여 객체를 &lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; 으로&lt;/a&gt; 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a8e841a341ca779f446431b59a0fdcb153b95e2" translate="yes" xml:space="preserve">
          <source>The underlying synchronous file object.</source>
          <target state="translated">기본 동기 파일 객체.</target>
        </trans-unit>
        <trans-unit id="8b2590649b5fca1121706db98f3737530bf8d4da" translate="yes" xml:space="preserve">
          <source>The underlying transport stream that was passed to &lt;code&gt;__init__&lt;/code&gt;. An example of when this would be useful is if you&amp;rsquo;re using &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; over a &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt; and want to call the &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;SocketStream&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;#trio.SocketStream.setsockopt&quot;&gt;&lt;code&gt;setsockopt()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">전달 된 기본 전송 스트림 &lt;code&gt;__init__&lt;/code&gt; . 당신이 사용하는 경우이 유용 할 때의 예는 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; 를&lt;/a&gt; 넘는 &lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; &lt;/a&gt; 와 통화 할 &lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;SocketStream&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#trio.SocketStream.setsockopt&quot;&gt; &lt;code&gt;setsockopt()&lt;/code&gt; &lt;/a&gt; 하는 방법.</target>
        </trans-unit>
        <trans-unit id="f623fc5e00614ae96a118b39b868c4f90851b815" translate="yes" xml:space="preserve">
          <source>The vast majority of Trio&amp;rsquo;s API is &lt;em&gt;not&lt;/em&gt; thread safe: it can only be used from inside a call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;. This manual doesn&amp;rsquo;t bother documenting this on individual calls; unless specifically noted otherwise, you should assume that it isn&amp;rsquo;t safe to call any Trio functions from anywhere except the Trio thread. (But &lt;a href=&quot;#threads&quot;&gt;see below&lt;/a&gt; if you really do need to work with threads.)</source>
          <target state="translated">대부분의 Trio API는 스레드로부터 안전 &lt;em&gt;하지 않습니다&lt;/em&gt; . &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 호출 내부에서만 사용할 수 있습니다 . 이 매뉴얼은 개별 통화에 대해이를 문서화하지 않습니다. 특별히 언급하지 않는 한, Trio 스레드를 제외한 다른 곳에서 Trio 함수를 호출하는 것이 안전하지 않다고 가정해야합니다. (하지만 실제로 스레드 작업이 필요한 경우 &lt;a href=&quot;#threads&quot;&gt;아래를 참조하십시오&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="039522b69359b3e56c31de8d1e26158ab6198376" translate="yes" xml:space="preserve">
          <source>Then tasks can come along and borrow a token out of the sack:</source>
          <target state="translated">그런 다음 작업을 수행하고 자루에서 토큰을 빌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8aed655f54fc986620011433879c1bf88c00c1fa" translate="yes" xml:space="preserve">
          <source>Then these both raise &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">그런 다음이 둘 다 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26f0adbdb0fabb432f18981f6cd29877bc3d70d3" translate="yes" xml:space="preserve">
          <source>Then you call &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;, passing in &lt;code&gt;abort_func&lt;/code&gt;, an &amp;ldquo;abort callback&amp;rdquo;.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 를 호출 하여&amp;ldquo;취소 콜백&amp;rdquo;인 &lt;code&gt;abort_func&lt;/code&gt; 를 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="516276345166a708ba6074c8532f510cdbd74c34" translate="yes" xml:space="preserve">
          <source>Then you call &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;, passing in &lt;code&gt;abort_func&lt;/code&gt;, an &amp;ldquo;abort callback&amp;rdquo;.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 &quot;중단 콜백&quot;인 &lt;code&gt;abort_func&lt;/code&gt; 를 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="7ceaee5b77c3b473fc92d1c8284b8ba959ee04c6" translate="yes" xml:space="preserve">
          <source>There are a few idiosyncratic cases where external constraints make it impossible to fully implement these semantics. These are always documented. There is also one systematic exception:</source>
          <target state="translated">외부 제약으로 인해 이러한 의미를 완전히 구현할 수없는 특이한 경우가 몇 가지 있습니다. 이들은 항상 문서화되어 있습니다. 체계적인 예외도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="8ccaa3636c24526c51e3cf2cf4bbb0add69c1e98" translate="yes" xml:space="preserve">
          <source>There are a few pieces here, so here&amp;rsquo;s how they fit together:</source>
          <target state="translated">여기에 몇 가지 조각이 있으므로 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f9b4b72d5e37ba916870f8ebadfd56db51bbd77e" translate="yes" xml:space="preserve">
          <source>There are two possibilities for what happens next:</source>
          <target state="translated">다음에 일어날 일에는 두 가지 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9b90250e8bd2eee9b2b8bf09f29e281e8809b4a" translate="yes" xml:space="preserve">
          <source>There are two versions of SSL/TLS commonly encountered in the wild: the standard version, and the version used for HTTPS (HTTP-over-SSL/TLS).</source>
          <target state="translated">일반적으로 두 가지 버전의 SSL / TLS가 있습니다. 표준 버전과 HTTPS (HTTP-over-SSL / TLS)에 사용되는 버전입니다.</target>
        </trans-unit>
        <trans-unit id="27e6946011051300b2bdacb518dcf327f5b5bd7b" translate="yes" xml:space="preserve">
          <source>There is a subtlety with how this method interacts with cancellation: when cancelled it will block to re-acquire the lock before raising &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;. This may cause cancellation to be less prompt than expected. The advantage is that it makes code like this work:</source>
          <target state="translated">이 메소드가 취소와 상호 작용하는 방식에는 미묘한 점이 있습니다. 취소하면 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 을 올리기 전에 잠금을 다시 확보하는 것이 차단됩니다 . 이로 인해 취소가 예상보다 덜 프롬프트 될 수 있습니다. 장점은 다음과 같은 코드를 작성한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bffd13f140e202626a214af6e92646e6022be490" translate="yes" xml:space="preserve">
          <source>There must be exactly one call to &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; for every call to &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;. (And when counting, keep in mind that returning &lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt;&lt;code&gt;Abort.SUCCEEDED&lt;/code&gt;&lt;/a&gt; from an abort callback is equivalent to calling &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; once.)</source>
          <target state="translated">&lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 호출 할 때마다 &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; 을 정확히 한 번만 호출해야 합니다. (그리고 계산할 때 중단 콜백에서 &lt;a href=&quot;#trio.hazmat.Abort.SUCCEEDED&quot;&gt; &lt;code&gt;Abort.SUCCEEDED&lt;/code&gt; &lt;/a&gt; 를 반환 하는 것은 &lt;a href=&quot;#trio.hazmat.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; 한 번 호출하는 것과 같습니다 .)</target>
        </trans-unit>
        <trans-unit id="801d34ccb8f29fc40b1813d70b24ba24e4de1c76" translate="yes" xml:space="preserve">
          <source>There must be exactly one call to &lt;a href=&quot;#trio.lowlevel.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; for every call to &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt;. (And when counting, keep in mind that returning &lt;a href=&quot;#trio.lowlevel.Abort.SUCCEEDED&quot;&gt;&lt;code&gt;Abort.SUCCEEDED&lt;/code&gt;&lt;/a&gt; from an abort callback is equivalent to calling &lt;a href=&quot;#trio.lowlevel.reschedule&quot;&gt;&lt;code&gt;reschedule()&lt;/code&gt;&lt;/a&gt; once.)</source>
          <target state="translated">&lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 호출 할 때마다 &lt;a href=&quot;#trio.lowlevel.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; 을 정확히 한 번만 호출해야 합니다. (그리고 계산할 때 중단 콜백에서 &lt;a href=&quot;#trio.lowlevel.Abort.SUCCEEDED&quot;&gt; &lt;code&gt;Abort.SUCCEEDED&lt;/code&gt; &lt;/a&gt; 를 반환 하는 것은 &lt;a href=&quot;#trio.lowlevel.reschedule&quot;&gt; &lt;code&gt;reschedule()&lt;/code&gt; &lt;/a&gt; 한 번 호출하는 것과 같습니다 .)</target>
        </trans-unit>
        <trans-unit id="7b29b5490f17425380aad05f050e2ab47d53179e" translate="yes" xml:space="preserve">
          <source>These are commonly used in cases where you have an operation that might-or-might-not block, and you want to implement Trio&amp;rsquo;s standard checkpoint semantics. Example:</source>
          <target state="translated">이들은 일반적으로 차단되거나 차단되지 않는 작업이 있고 Trio의 표준 체크 포인트 의미를 구현하려는 경우에 사용됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="3d0bc413452d0608c3c5668aad8331f5e3c73b1b" translate="yes" xml:space="preserve">
          <source>These classes are all guaranteed to be &amp;ldquo;fair&amp;rdquo;, meaning that when it comes time to choose who will be next to acquire a lock, get an item from a queue, etc., then it always goes to the task which has been waiting longest. It&amp;rsquo;s &lt;a href=&quot;https://github.com/python-trio/trio/issues/54&quot;&gt;not entirely clear&lt;/a&gt; whether this is the best choice, but for now that&amp;rsquo;s how it works.</source>
          <target state="translated">이 클래스는 모두 &quot;공평한&quot;것으로 보장됩니다. 즉, 잠금을 획득 할 다음 사람을 선택하고 대기열에서 항목을 가져 오는 등의 경우 항상 가장 오래 기다린 작업으로 이동합니다. . 이것이 최선의 선택인지는 &lt;a href=&quot;https://github.com/python-trio/trio/issues/54&quot;&gt;확실하지&lt;/a&gt; 않지만 현재로서는 이것이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7d75ee66ff83bf4554d223bde19bf99669265ec3" translate="yes" xml:space="preserve">
          <source>These functions can also be useful in other situations. For example, when &lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt; schedules some work to run in a worker thread, it blocks until the work is finished (so it&amp;rsquo;s a schedule point), but by default it doesn&amp;rsquo;t allow cancellation. So to make sure that the call always acts as a checkpoint, it calls &lt;a href=&quot;#trio.hazmat.checkpoint_if_cancelled&quot;&gt;&lt;code&gt;checkpoint_if_cancelled()&lt;/code&gt;&lt;/a&gt; before starting the thread.</source>
          <target state="translated">이러한 기능은 다른 상황에서도 유용 할 수 있습니다. 예를 들어, &lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt; 가 작업자 스레드에서 실행되도록 일부 작업을 예약하면 작업이 완료 될 때까지 차단되므로 (스케줄 지점이므로) 기본적으로 취소를 허용하지 않습니다. 따라서 호출이 항상 체크 포인트 역할을 하도록 스레드를 시작하기 전에 &lt;a href=&quot;#trio.hazmat.checkpoint_if_cancelled&quot;&gt; &lt;code&gt;checkpoint_if_cancelled()&lt;/code&gt; &lt;/a&gt; 를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="33c43432e709f0451deb70ea74790ca734f5561a" translate="yes" xml:space="preserve">
          <source>These functions can also be useful in other situations. For example, when &lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt; schedules some work to run in a worker thread, it blocks until the work is finished (so it&amp;rsquo;s a schedule point), but by default it doesn&amp;rsquo;t allow cancellation. So to make sure that the call always acts as a checkpoint, it calls &lt;a href=&quot;#trio.lowlevel.checkpoint_if_cancelled&quot;&gt;&lt;code&gt;checkpoint_if_cancelled()&lt;/code&gt;&lt;/a&gt; before starting the thread.</source>
          <target state="translated">이러한 기능은 다른 상황에서도 유용 할 수 있습니다. 예를 들어 &lt;a href=&quot;reference-core#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt; 가 워커 스레드에서 일부 작업을 실행하도록 예약하면 작업이 완료 될 때까지 차단되지만 (따라서 일정 지점이 됨) 기본적으로 취소를 허용하지 않습니다. 따라서 호출이 항상 체크 포인트로 작동하는지 확인 하기 위해 스레드를 시작하기 전에 &lt;a href=&quot;#trio.lowlevel.checkpoint_if_cancelled&quot;&gt; &lt;code&gt;checkpoint_if_cancelled()&lt;/code&gt; &lt;/a&gt; 를 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="acb414aaadc5ad5c07497ec2df742e42694d9509" translate="yes" xml:space="preserve">
          <source>These transitions are accomplished using two function decorators:</source>
          <target state="translated">이러한 전환은 두 개의 함수 데코레이터를 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="81307d013910a4dd0f0a2b7e14e3fa3a61ebe2f2" translate="yes" xml:space="preserve">
          <source>These two lines are equivalent:</source>
          <target state="translated">이 두 줄은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="86cd05304bf90b12bb103d8aecc0cf9b07939972" translate="yes" xml:space="preserve">
          <source>They don&amp;rsquo;t need an explicit nursery; instead they go into the internal &amp;ldquo;system nursery&amp;rdquo;.</source>
          <target state="translated">그들은 명시적인 보육이 필요하지 않습니다. 대신 그들은 내부&amp;ldquo;시스템 보육원&amp;rdquo;에 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="0c35b3a96ea0ec2dff743f8b5250ebd577b91e90" translate="yes" xml:space="preserve">
          <source>Third-party async functions / iterators / context managers can act as checkpoints; if you see &lt;code&gt;await &amp;lt;something&amp;gt;&lt;/code&gt; or one of its friends, then that &lt;em&gt;might&lt;/em&gt; be a checkpoint. So to be safe, you should prepare for scheduling or cancellation happening there.</source>
          <target state="translated">타사 비동기 함수 / 반복자 / 컨텍스트 관리자는 검사 점으로 작동 할 수 있습니다. &lt;code&gt;await &amp;lt;something&amp;gt;&lt;/code&gt; 또는 해당 친구 중 하나를 기다리는 경우 검사 점이 될 &lt;em&gt;수&lt;/em&gt; 있습니다. 따라서 안전을 위해 예약 또는 취소 준비를해야합니다.</target>
        </trans-unit>
        <trans-unit id="153b8ef41ad99fb02fe77369052399944035c0b2" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; attribute is True if you&amp;rsquo;ve called &lt;code&gt;sock.shutdown(SHUT_WR)&lt;/code&gt; or &lt;code&gt;sock.shutdown(SHUT_RDWR)&lt;/code&gt;, and False otherwise.</source>
          <target state="translated">이 &lt;a href=&quot;https://docs.python.org/3/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; 속성은 &lt;code&gt;sock.shutdown(SHUT_WR)&lt;/code&gt; 또는 &lt;code&gt;sock.shutdown(SHUT_RDWR)&lt;/code&gt; 호출 한 경우 True 이고, 그렇지 않으면 False입니다.</target>
        </trans-unit>
        <trans-unit id="7c6fe9ee538d951d1c429e8c8db0cf9bc028c153" translate="yes" xml:space="preserve">
          <source>This also means that if you register a SNI callback using &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext.sni_callback&quot;&gt;&lt;code&gt;sni_callback&lt;/code&gt;&lt;/a&gt;, then the first argument your callback receives will be a &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt;&lt;code&gt;ssl.SSLObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 또한 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext.sni_callback&quot;&gt; &lt;code&gt;sni_callback&lt;/code&gt; 을&lt;/a&gt; 사용하여 SNI 콜백을 등록하면 콜백이받는 첫 번째 인수는 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLObject&quot;&gt; &lt;code&gt;ssl.SSLObject&lt;/code&gt; &lt;/a&gt; 가 됨을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="741317efb643cb97bdd044fc9a9acfb72ef72725" translate="yes" xml:space="preserve">
          <source>This and &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; are the two fundamental methods for creating concurrent tasks in Trio.</source>
          <target state="translated">이것과 &lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 는 Trio에서 동시 작업을 생성하는 두 가지 기본 방법입니다.</target>
        </trans-unit>
        <trans-unit id="8f2fdd09fd7fe021c78364cf9bb2f534396d77e1" translate="yes" xml:space="preserve">
          <source>This attribute being True does &lt;em&gt;not&lt;/em&gt; necessarily mean that the code within the scope has been, or will be, affected by the cancellation. For example, if &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt;&lt;code&gt;cancel()&lt;/code&gt;&lt;/a&gt; was called after the last checkpoint in the &lt;code&gt;with&lt;/code&gt; block, when it&amp;rsquo;s too late to deliver a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception, then this attribute will still be True.</source>
          <target state="translated">이 속성이 True 라고해서 해당 범위 내의 코드가 취소에 영향을 받았거나 영향을받는 것은 &lt;em&gt;아닙니다&lt;/em&gt; . 예를 들어 &lt;code&gt;with&lt;/code&gt; 블록 의 마지막 검사 점 이후에 &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt; &lt;code&gt;cancel()&lt;/code&gt; &lt;/a&gt; 이 호출 된 경우 취소 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외 를 전달하기에 너무 늦으면 이 속성은 여전히 ​​True입니다.</target>
        </trans-unit>
        <trans-unit id="a48bfa0f12266fba2f040ed028628232b8e6f5e0" translate="yes" xml:space="preserve">
          <source>This attribute is mostly useful for debugging and introspection. If you want to know whether or not a chunk of code was actually cancelled, then &lt;a href=&quot;#trio.CancelScope.cancelled_caught&quot;&gt;&lt;code&gt;cancelled_caught&lt;/code&gt;&lt;/a&gt; is usually more appropriate.</source>
          <target state="translated">이 속성은 주로 디버깅 및 내부 검사에 유용합니다. 코드 덩어리가 실제로 취소되었는지 여부를 알고 싶다면 &lt;a href=&quot;#trio.CancelScope.cancelled_caught&quot;&gt; &lt;code&gt;cancelled_caught&lt;/code&gt; &lt;/a&gt; 가 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="ff12646195b62ccf09f268e0dcd0a93a0a83670e" translate="yes" xml:space="preserve">
          <source>This avoids several common pitfalls:</source>
          <target state="translated">이것은 몇 가지 일반적인 함정을 피합니다.</target>
        </trans-unit>
        <trans-unit id="626f12244e67c7b41b46a58e659379debb57bbb8" translate="yes" xml:space="preserve">
          <source>This behavior is useful because it helps avoid race conditions and lost wakeups: it doesn&amp;rsquo;t matter whether &lt;a href=&quot;#trio.Event.set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; gets called just before or after &lt;a href=&quot;#trio.Event.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;. If you want a lower-level wakeup primitive that doesn&amp;rsquo;t have this protection, consider &lt;a href=&quot;#trio.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;reference-hazmat#trio.hazmat.ParkingLot&quot;&gt;&lt;code&gt;trio.hazmat.ParkingLot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 동작은 경쟁 조건과 깨어 난 웨이크를 피하는 데 도움이되기 때문에 유용합니다. &lt;a href=&quot;#trio.Event.set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt; 이 &lt;a href=&quot;#trio.Event.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 직전 또는 후에 호출 되는지는 중요하지 않습니다 . 이 보호 기능이없는 하위 수준의 웨이크 업 프리미티브를 &lt;a href=&quot;reference-hazmat#trio.hazmat.ParkingLot&quot;&gt; &lt;code&gt;trio.hazmat.ParkingLot&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#trio.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 또는 trio.hazmat.ParkingLot를 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d7f0d149990683a66350e94bbe30fe0eeb1ebcc" translate="yes" xml:space="preserve">
          <source>This behavior is useful because it helps avoid race conditions and lost wakeups: it doesn&amp;rsquo;t matter whether &lt;a href=&quot;#trio.Event.set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; gets called just before or after &lt;a href=&quot;#trio.Event.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;. If you want a lower-level wakeup primitive that doesn&amp;rsquo;t have this protection, consider &lt;a href=&quot;#trio.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;reference-lowlevel#trio.lowlevel.ParkingLot&quot;&gt;&lt;code&gt;trio.lowlevel.ParkingLot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 동작은 경합 상태와 웨이크 업 손실을 방지하는 데 도움이되기 때문에 유용합니다. &lt;a href=&quot;#trio.Event.set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt; 이 &lt;a href=&quot;#trio.Event.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 직전 또는 후에 호출 되는지 여부는 중요하지 않습니다 . 이 보호 기능이없는 하위 수준의 wakeup 프리미티브를 &lt;a href=&quot;reference-lowlevel#trio.lowlevel.ParkingLot&quot;&gt; &lt;code&gt;trio.lowlevel.ParkingLot&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#trio.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt; 또는 trio.lowlevel.ParkingLot를 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="31b0899969e7dc26177e3f97d8a67c806347e3aa" translate="yes" xml:space="preserve">
          <source>This callable should schedule &lt;code&gt;fn()&lt;/code&gt; to be run by the host on its next pass through its loop. &lt;code&gt;Must support being called from arbitrary threads.&lt;/code&gt;</source>
          <target state="translated">이 콜 러블은 호스트가 루프를 통과 할 때 다음 번에 &lt;code&gt;fn()&lt;/code&gt; 을 실행하도록 예약해야 합니다. &lt;code&gt;Must support being called from arbitrary threads.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7212591b5e320334b3ae18061636ff4b19af84aa" translate="yes" xml:space="preserve">
          <source>This can be useful for testing flow control mechanisms in an extreme case, or for setting up &amp;ldquo;clogged&amp;rdquo; streams to use with &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt;&lt;code&gt;check_one_way_stream()&lt;/code&gt;&lt;/a&gt; and friends.</source>
          <target state="translated">이는 극단적 인 경우 흐름 제어 메커니즘을 테스트하거나 &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt; &lt;code&gt;check_one_way_stream()&lt;/code&gt; &lt;/a&gt; 및 친구들과 함께 사용할 &quot;막힌&quot;스트림을 설정하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="777508af726dca6e138c62201ae51b11dda89501" translate="yes" xml:space="preserve">
          <source>This checks for cancellation and allows other tasks to be scheduled, without otherwise blocking.</source>
          <target state="translated">이를 통해 취소를 확인하고 달리 차단하지 않고 다른 작업을 예약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7eb8be825f964eeec308b47905ab5876d9c3514c" translate="yes" xml:space="preserve">
          <source>This class &lt;a href=&quot;https://en.wikipedia.org/wiki/Staple_(fastener)&quot;&gt;staples&lt;/a&gt; together two unidirectional streams to make single bidirectional stream.</source>
          <target state="translated">이 클래스 는 단일 양방향 스트림을 만들기 위해 두 개의 단방향 스트림을 &lt;a href=&quot;https://en.wikipedia.org/wiki/Staple_(fastener)&quot;&gt;스테이플 링&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c56797f75d6a67218039122490ded779850a16ba" translate="yes" xml:space="preserve">
          <source>This class distinguishes between &amp;ldquo;graceful&amp;rdquo; closes, which may perform I/O and thus block, and a &amp;ldquo;forceful&amp;rdquo; close, which cannot. For example, cleanly shutting down a TLS-encrypted connection requires sending a &amp;ldquo;goodbye&amp;rdquo; message; but if a peer has become non-responsive, then sending this message might block forever, so we may want to just drop the connection instead. Therefore the &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; method is unusual in that it should always close the connection (or at least make its best attempt) &lt;em&gt;even if it fails&lt;/em&gt;; failure indicates a failure to achieve grace, not a failure to close the connection.</source>
          <target state="translated">이 클래스는 I / O를 수행하여 차단할 수있는 &quot;유예&quot;닫기와 불가능한 &quot;강제&quot;닫기를 구분합니다. 예를 들어, TLS 암호화 연결을 완전히 종료하려면 &quot;안녕&quot;메시지를 보내야합니다. 그러나 피어가 응답하지 않으면이 메시지를 보내는 것이 영원히 차단 될 수 있으므로 대신 연결을 끊고 싶을 수도 있습니다. 따라서 &lt;a href=&quot;#trio.abc.AsyncResource.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 메소드는 연결 &lt;em&gt;이 실패하더라도&lt;/em&gt; 항상 연결을 종료해야합니다 (또는 최소한 최선을 다해야 함) . 실패는 연결을 닫는 데 실패가 아니라 유예에 실패했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="28b26ebbffbe7117ea41ae0633d49c552b9155ec" translate="yes" xml:space="preserve">
          <source>This class encapsulates the tricky parts of implementing a wait queue. It&amp;rsquo;s useful for implementing higher-level synchronization primitives like queues and locks.</source>
          <target state="translated">이 클래스는 대기 큐 구현의 까다로운 부분을 캡슐화합니다. 큐 및 잠금과 같은 상위 레벨 동기화 기본 요소를 구현하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1a47671d4bf70755645824b64fbe8633bf09f6fa" translate="yes" xml:space="preserve">
          <source>This class has no public constructor. To create a child process, use &lt;a href=&quot;#trio.open_process&quot;&gt;&lt;code&gt;open_process&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 클래스에는 공개 생성자가 없습니다. 자식 프로세스를 만들려면 &lt;a href=&quot;#trio.open_process&quot;&gt; &lt;code&gt;open_process&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b99db4b97b98beb51fb24c58219ced2d6f0fd5ff" translate="yes" xml:space="preserve">
          <source>This code will wait 5 seconds (for the child task to finish), and then return.</source>
          <target state="translated">이 코드는 5 초 동안 (자식 작업이 완료 될 때까지) 기다렸다가 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="939dd3d2d8145547e7e234d0c5f0527ad4c5c738" translate="yes" xml:space="preserve">
          <source>This dequeues &lt;code&gt;count&lt;/code&gt; tasks from one lot, and requeues them on another, preserving order. For example:</source>
          <target state="translated">이 작업은 한 로트에서 작업을 &lt;code&gt;count&lt;/code&gt; 하고 순서를 유지하면서 다른 로트에서 작업을 다시 요청합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c3364e26d8c76183c9b91166e249f70c062374ec" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t actually close the object &amp;ndash; you still have to do that yourself afterwards.</source>
          <target state="translated">이것은 실제로 객체를 닫는 것이 아니라 나중에 직접해야합니다.</target>
        </trans-unit>
        <trans-unit id="c88cc97aad07bb8c29d3828aa64cf1f0210e8c2d" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t actually close the object &amp;ndash; you still have to do that yourself afterwards. Also, you want to be careful to make sure no new tasks start waiting on the object in between when you call this and when it&amp;rsquo;s actually closed. So to close something properly, you usually want to do these steps in order:</source>
          <target state="translated">이것은 실제로 개체를 닫는 것이 아닙니다. 나중에 직접해야합니다. 또한 호출 할 때와 실제로 닫힐 때 사이에 새로운 작업이 개체에서 대기를 시작하지 않도록주의해야합니다. 따라서 제대로 닫으려면 일반적으로 다음 단계를 순서대로 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="2bb2af13b8495755c9cccc1579f4a71609bc843d" translate="yes" xml:space="preserve">
          <source>This example demonstrates using the &lt;a href=&quot;#trio.MemorySendChannel.clone&quot;&gt;&lt;code&gt;MemorySendChannel.clone&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.MemoryReceiveChannel.clone&quot;&gt;&lt;code&gt;MemoryReceiveChannel.clone&lt;/code&gt;&lt;/a&gt; methods. What these do is create copies of our endpoints, that act just like the original &amp;ndash; except that they can be closed independently. And the underlying channel is only closed after &lt;em&gt;all&lt;/em&gt; the clones have been closed. So this completely solves our problem with shutdown, and if you run this program, you&amp;rsquo;ll see it print its six lines of output and then exits cleanly.</source>
          <target state="translated">이 예에서는 &lt;a href=&quot;#trio.MemorySendChannel.clone&quot;&gt; &lt;code&gt;MemorySendChannel.clone&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.MemoryReceiveChannel.clone&quot;&gt; &lt;code&gt;MemoryReceiveChannel.clone&lt;/code&gt; &lt;/a&gt; 메서드를 사용하는 방법을 보여줍니다 . 이것이하는 일은 엔드 포인트의 사본을 생성하는 것입니다. 엔드 포인트는 원본과 동일하게 작동하며 독립적으로 닫을 수 있습니다. 그리고 &lt;em&gt;모든&lt;/em&gt; 클론이 닫힌 후에 만 ​​기본 채널이 닫힙니다. 따라서 종료 문제를 완전히 해결하고이 프로그램을 실행하면 6 줄의 출력을 인쇄 한 다음 깨끗하게 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="0831f123255408a3d50729ed611cfa78fde0d9f6" translate="yes" xml:space="preserve">
          <source>This exception&amp;rsquo;s &lt;code&gt;__cause__&lt;/code&gt; attribute will often contain more information about the underlying error.</source>
          <target state="translated">이 예외의 &lt;code&gt;__cause__&lt;/code&gt; 속성은 종종 기본 오류에 대한 자세한 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="4ec4163ea949b45f4f411608a69251c1e624bfb0" translate="yes" xml:space="preserve">
          <source>This function allows you to replace Trio&amp;rsquo;s normal socket class with a custom class. This is very useful for testing, and probably a bad idea in any other circumstance. See &lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt;&lt;code&gt;trio.abc.HostnameResolver&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이 함수를 사용하면 Trio의 일반 소켓 클래스를 사용자 정의 클래스로 바꿀 수 있습니다. 이것은 테스트에 매우 유용하며 다른 상황에서는 좋지 않을 수 있습니다. 자세한 내용은 &lt;a href=&quot;#trio.abc.HostnameResolver&quot;&gt; &lt;code&gt;trio.abc.HostnameResolver&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8b80bf44f477a63401ffe0a86ba46937966ca016" translate="yes" xml:space="preserve">
          <source>This function and &lt;a href=&quot;#trio.move_on_after&quot;&gt;&lt;code&gt;move_on_after()&lt;/code&gt;&lt;/a&gt; are similar in that both create a cancel scope with a given timeout, and if the timeout expires then both will cause &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; to be raised within the scope. The difference is that when the &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception reaches &lt;a href=&quot;#trio.move_on_after&quot;&gt;&lt;code&gt;move_on_after()&lt;/code&gt;&lt;/a&gt;, it&amp;rsquo;s caught and discarded. When it reaches &lt;a href=&quot;#trio.fail_after&quot;&gt;&lt;code&gt;fail_after()&lt;/code&gt;&lt;/a&gt;, then it&amp;rsquo;s caught and &lt;a href=&quot;#trio.TooSlowError&quot;&gt;&lt;code&gt;TooSlowError&lt;/code&gt;&lt;/a&gt; is raised in its place.</source>
          <target state="translated">이 함수와 &lt;a href=&quot;#trio.move_on_after&quot;&gt; &lt;code&gt;move_on_after()&lt;/code&gt; &lt;/a&gt; 는 주어진 시간 초과로 취소 범위를 만들고 시간 초과가 만료되면 범위 내에서 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 가 발생한다는 점에서 비슷 합니다. 차이점은 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외가 &lt;a href=&quot;#trio.move_on_after&quot;&gt; &lt;code&gt;move_on_after()&lt;/code&gt; &lt;/a&gt; 도달하면 잡히고 버린다는 것입니다. 이 도달하면 &lt;a href=&quot;#trio.fail_after&quot;&gt; &lt;code&gt;fail_after()&lt;/code&gt; &lt;/a&gt; , 다음은 잡은 것 및 &lt;a href=&quot;#trio.TooSlowError&quot;&gt; &lt;code&gt;TooSlowError&lt;/code&gt; 는&lt;/a&gt; 그 자리에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6472cab9cb21c974030fc674c30dfd25631ba087" translate="yes" xml:space="preserve">
          <source>This function and &lt;a href=&quot;#trio.move_on_at&quot;&gt;&lt;code&gt;move_on_at()&lt;/code&gt;&lt;/a&gt; are similar in that both create a cancel scope with a given absolute deadline, and if the deadline expires then both will cause &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; to be raised within the scope. The difference is that when the &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception reaches &lt;a href=&quot;#trio.move_on_at&quot;&gt;&lt;code&gt;move_on_at()&lt;/code&gt;&lt;/a&gt;, it&amp;rsquo;s caught and discarded. When it reaches &lt;a href=&quot;#trio.fail_at&quot;&gt;&lt;code&gt;fail_at()&lt;/code&gt;&lt;/a&gt;, then it&amp;rsquo;s caught and &lt;a href=&quot;#trio.TooSlowError&quot;&gt;&lt;code&gt;TooSlowError&lt;/code&gt;&lt;/a&gt; is raised in its place.</source>
          <target state="translated">이 함수와 &lt;a href=&quot;#trio.move_on_at&quot;&gt; &lt;code&gt;move_on_at()&lt;/code&gt; &lt;/a&gt; 는 주어진 절대 기한이있는 취소 범위를 작성하고 기한이 만료되면 범위 내에서 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 가 발생한다는 점에서 비슷 합니다. 차이점은 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외가 &lt;a href=&quot;#trio.move_on_at&quot;&gt; &lt;code&gt;move_on_at()&lt;/code&gt; &lt;/a&gt; 도달하면 잡히고 버린다는 것입니다. 이 도달하면 &lt;a href=&quot;#trio.fail_at&quot;&gt; &lt;code&gt;fail_at()&lt;/code&gt; &lt;/a&gt; , 다음은 잡은 것 및 &lt;a href=&quot;#trio.TooSlowError&quot;&gt; &lt;code&gt;TooSlowError&lt;/code&gt; 는&lt;/a&gt; 그 자리에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="beee03279b501d21ddabbf8f6de51961869f2389" translate="yes" xml:space="preserve">
          <source>This function does not perform the TLS handshake; you can do it manually by calling &lt;a href=&quot;#trio.SSLStream.do_handshake&quot;&gt;&lt;code&gt;do_handshake()&lt;/code&gt;&lt;/a&gt;, or else it will be performed automatically the first time you send or receive data.</source>
          <target state="translated">이 기능은 TLS 핸드 셰이크를 수행하지 않습니다. &lt;a href=&quot;#trio.SSLStream.do_handshake&quot;&gt; &lt;code&gt;do_handshake()&lt;/code&gt; &lt;/a&gt; 를 호출하여 수동으로 수행 할 수 있습니다. 그렇지 않으면 데이터를 처음 보내거나받을 때 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8b5f591859ac15e7667f269bbd87655ee356a2a3" translate="yes" xml:space="preserve">
          <source>This function examines all the cancellation scopes that are currently in effect (taking into account shielding), and returns the deadline that will expire first.</source>
          <target state="translated">이 함수는 현재 적용중인 모든 취소 범위 (차폐를 고려함)를 검사하고 먼저 만료되는 최종 기한을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="781b6ba4e14238d28d4905a86d639a4f2fb4d4f6" translate="yes" xml:space="preserve">
          <source>This function never returns unless cancelled.</source>
          <target state="translated">이 함수는 취소하지 않으면 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10fb6ede8900e518012239a45fc9a8e96195f7a8" translate="yes" xml:space="preserve">
          <source>This function only returns when cancelled.</source>
          <target state="translated">이 함수는 취소 된 경우에만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a6ba5420ed39805adc1f6e88511ac0ce00ec14a9" translate="yes" xml:space="preserve">
          <source>This function strikes a balance between these two extremes: it works its way through the available addresses one at a time, like the first approach; but, if &lt;code&gt;happy_eyeballs_delay&lt;/code&gt; seconds have passed and it&amp;rsquo;s still waiting for an attempt to succeed or fail, then it gets impatient and starts the next connection attempt in parallel. As soon as any one connection attempt succeeds, all the other attempts are cancelled. This avoids unnecessary load because most connections will succeed after just one or two attempts, but if one of the addresses is unreachable then it doesn&amp;rsquo;t slow us down too much.</source>
          <target state="translated">이 기능은이 두 극단 사이의 균형을 유지합니다. 첫 번째 접근 방식과 같이 사용 가능한 주소를 통해 한 번에 하나씩 작동합니다. 그러나 &lt;code&gt;happy_eyeballs_delay&lt;/code&gt; 초가 지났는데도 여전히 성공 또는 실패를 기다리는 경우, 참을성이 없어 다음 연결 시도를 병렬로 시작합니다. 하나의 연결 시도가 성공하자마자 다른 모든 시도는 취소됩니다. 이렇게하면 대부분의 연결이 한두 번의 시도 후에 성공하기 때문에 불필요한로드를 피할 수 있지만 주소 중 하나에 도달 할 수없는 경우에도 속도가 너무 느려지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2b428d2d2fedd87ac134d2d677f1ec40b12e6074" translate="yes" xml:space="preserve">
          <source>This function tests a &lt;em&gt;superset&lt;/em&gt; of what &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt;&lt;code&gt;check_one_way_stream()&lt;/code&gt;&lt;/a&gt; checks &amp;ndash; if you call this, then you don&amp;rsquo;t need to also call &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt;&lt;code&gt;check_one_way_stream()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt; &lt;code&gt;check_one_way_stream()&lt;/code&gt; &lt;/a&gt; 확인 하는 &lt;em&gt;상위 집합&lt;/em&gt; 을 테스트합니다.이를 호출하면 &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt; &lt;code&gt;check_one_way_stream()&lt;/code&gt; &lt;/a&gt; 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c237272caa2b06d6e435d70b44aba945c42ded67" translate="yes" xml:space="preserve">
          <source>This function tests a &lt;em&gt;superset&lt;/em&gt; of what &lt;a href=&quot;#trio.testing.check_two_way_stream&quot;&gt;&lt;code&gt;check_two_way_stream()&lt;/code&gt;&lt;/a&gt; checks &amp;ndash; if you call this, then you don&amp;rsquo;t need to also call &lt;a href=&quot;#trio.testing.check_two_way_stream&quot;&gt;&lt;code&gt;check_two_way_stream()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#trio.testing.check_two_way_stream&quot;&gt; &lt;code&gt;check_two_way_stream()&lt;/code&gt; &lt;/a&gt; 확인 하는 &lt;em&gt;상위 집합&lt;/em&gt; 을 테스트합니다.이 함수 를 호출하면 &lt;a href=&quot;#trio.testing.check_two_way_stream&quot;&gt; &lt;code&gt;check_two_way_stream()&lt;/code&gt; &lt;/a&gt; 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3025b1032710d54ab53e19541456e1cb5086dfdb" translate="yes" xml:space="preserve">
          <source>This function&amp;rsquo;s behavior can be customized using &lt;a href=&quot;reference-testing#trio.socket.set_custom_hostname_resolver&quot;&gt;&lt;code&gt;set_custom_hostname_resolver()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수의 동작은 &lt;a href=&quot;reference-testing#trio.socket.set_custom_hostname_resolver&quot;&gt; &lt;code&gt;set_custom_hostname_resolver()&lt;/code&gt; &lt;/a&gt; 사용하여 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a99381ddd18455f137e888e7ce19ef7b02a6d411" translate="yes" xml:space="preserve">
          <source>This function&amp;rsquo;s behavior can be customized using &lt;a href=&quot;reference-testing#trio.socket.set_custom_socket_factory&quot;&gt;&lt;code&gt;set_custom_socket_factory()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수의 동작은 &lt;a href=&quot;reference-testing#trio.socket.set_custom_socket_factory&quot;&gt; &lt;code&gt;set_custom_socket_factory()&lt;/code&gt; &lt;/a&gt; 사용하여 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dfd660c37b7b448e29f5ca35f71daff1e3c7a98e" translate="yes" xml:space="preserve">
          <source>This includes async iterators: If you write &lt;code&gt;async for ... in &amp;lt;a
trio object&amp;gt;&lt;/code&gt;, then there will be at least one checkpoint before each iteration of the loop and one checkpoint after the last iteration.</source>
          <target state="translated">여기에는 비동기 반복기가 포함됩니다. &lt;code&gt;async for ... in &amp;lt;a trio object&amp;gt;&lt;/code&gt; 작성 하는 경우 루프의 각 반복 전에 적어도 하나의 검사 점이 있고 마지막 반복 후에는 하나의 검사 점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="64fdf77f2a6948dcd1d3f395907ba3bd1b417d06" translate="yes" xml:space="preserve">
          <source>This interface extends &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; to also allow closing the send part of the stream without closing the receive part.</source>
          <target state="translated">이 인터페이스 는 수신 부분을 닫지 않고 스트림의 송신 부분을 닫을 수 있도록 &lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 을 확장 합니다.</target>
        </trans-unit>
        <trans-unit id="783f9168f3a0ecf9fcc0bad0241f594953ed1653" translate="yes" xml:space="preserve">
          <source>This is &lt;em&gt;not&lt;/em&gt; a &lt;a href=&quot;reference-core#checkpoints&quot;&gt;checkpoint&lt;/a&gt;, but it is half of a checkpoint, and when combined with &lt;a href=&quot;#trio.hazmat.checkpoint_if_cancelled&quot;&gt;&lt;code&gt;checkpoint_if_cancelled()&lt;/code&gt;&lt;/a&gt; it can make a full checkpoint.</source>
          <target state="translated">입니다 &lt;em&gt;하지 &lt;/em&gt;&lt;a href=&quot;reference-core#checkpoints&quot;&gt;체크 포인트&lt;/a&gt; ,하지만 체크 포인트의 절반이며, 함께 결합 될 때 &lt;a href=&quot;#trio.hazmat.checkpoint_if_cancelled&quot;&gt; &lt;code&gt;checkpoint_if_cancelled()&lt;/code&gt; &lt;/a&gt; 는 전체 검사 점을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7b92fb56091be7d8067dff05517fcf3b9f38f41" translate="yes" xml:space="preserve">
          <source>This is &lt;em&gt;not&lt;/em&gt; a &lt;a href=&quot;reference-core#checkpoints&quot;&gt;checkpoint&lt;/a&gt;, but it is half of a checkpoint, and when combined with &lt;a href=&quot;#trio.lowlevel.checkpoint_if_cancelled&quot;&gt;&lt;code&gt;checkpoint_if_cancelled()&lt;/code&gt;&lt;/a&gt; it can make a full checkpoint.</source>
          <target state="translated">입니다 &lt;em&gt;하지 &lt;/em&gt;&lt;a href=&quot;reference-core#checkpoints&quot;&gt;체크 포인트&lt;/a&gt; ,하지만 체크 포인트의 절반이며, 함께 결합 될 때 &lt;a href=&quot;#trio.lowlevel.checkpoint_if_cancelled&quot;&gt; &lt;code&gt;checkpoint_if_cancelled()&lt;/code&gt; &lt;/a&gt; 는 전체 검사 점을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bfe1cdd96a28a6a95c12558fd209d1ae8e3ceb2" translate="yes" xml:space="preserve">
          <source>This is Trio&amp;rsquo;s main entry point. Almost every other function in Trio requires that you be inside a call to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것이 트리오의 주요 진입 점입니다. Trio의 거의 모든 다른 함수에는 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 호출 안에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a87c3526175efef10c92dec2e7c2b1e115230ab1" translate="yes" xml:space="preserve">
          <source>This is a convenience function that creates two one-way streams using &lt;a href=&quot;#trio.testing.lockstep_stream_one_way_pair&quot;&gt;&lt;code&gt;lockstep_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt;, and then uses &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt; to combine them into a single bidirectional stream.</source>
          <target state="translated">이것은 &lt;a href=&quot;#trio.testing.lockstep_stream_one_way_pair&quot;&gt; &lt;code&gt;lockstep_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; 사용하여 두 개의 단방향 스트림을 만든 다음 &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt; 을 사용 하여 단일 양방향 스트림으로 결합 하는 편리한 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="143d075fb0db14d63e601395486d506d13fd2bb0" translate="yes" xml:space="preserve">
          <source>This is a convenience function that creates two one-way streams using &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt;&lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt;, and then uses &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt;&lt;code&gt;StapledStream&lt;/code&gt;&lt;/a&gt; to combine them into a single bidirectional stream.</source>
          <target state="translated">이것은 &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt; &lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; 사용하여 두 개의 단방향 스트림을 만든 다음 &lt;a href=&quot;reference-io#trio.StapledStream&quot;&gt; &lt;code&gt;StapledStream&lt;/code&gt; &lt;/a&gt; 을 사용 하여 단일 양방향 스트림으로 결합 하는 편리한 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="75e832f6645c15527d0b0ace9c7c9f19af69e7f7" translate="yes" xml:space="preserve">
          <source>This is a convenience wrapper that calls &lt;a href=&quot;#trio.open_tcp_stream&quot;&gt;&lt;code&gt;open_tcp_stream()&lt;/code&gt;&lt;/a&gt; and wraps the result in an &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#trio.open_tcp_stream&quot;&gt; &lt;code&gt;open_tcp_stream()&lt;/code&gt; &lt;/a&gt; 을 호출 하고 결과를 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 에 랩핑 하는 편의 래퍼입니다 .</target>
        </trans-unit>
        <trans-unit id="31ccdd36d0e3b96050da7e039b26a2619a4c6283" translate="yes" xml:space="preserve">
          <source>This is a list, with outer nurseries before inner nurseries.</source>
          <target state="translated">이것은 내부 보육원 앞에 외부 보육원이있는 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d572fc6e96f0524557106f4e6d07ef30f53dc792" translate="yes" xml:space="preserve">
          <source>This is a low-level, no-frills interface, very similar to using &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Thread&quot;&gt;&lt;code&gt;threading.Thread&lt;/code&gt;&lt;/a&gt; to spawn a thread directly. The main difference is that this function tries to re-use threads when possible, so it can be a bit faster than &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Thread&quot;&gt;&lt;code&gt;threading.Thread&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 쓰레드를 직접 생성하기 위해 &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Thread&quot;&gt; &lt;code&gt;threading.Thread&lt;/code&gt; &lt;/a&gt; 를 사용하는 것과 매우 유사한 저수준의 노 프릴 인터페이스 입니다. 가장 큰 차이점은이 함수는 가능한 경우 스레드를 재사용하려고 시도하므로 &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Thread&quot;&gt; &lt;code&gt;threading.Thread&lt;/code&gt; &lt;/a&gt; 보다 약간 빠를 수 있다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="dfdb480b2d02dfcb7a4dd0f62ee4c91790556e33" translate="yes" xml:space="preserve">
          <source>This is a non-reentrant, single-owner lock. Unlike &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Lock&quot;&gt;&lt;code&gt;threading.Lock&lt;/code&gt;&lt;/a&gt;, only the owner of the lock is allowed to release it.</source>
          <target state="translated">재진입 할 ​​수없는 단일 소유자 잠금입니다. &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Lock&quot;&gt; &lt;code&gt;threading.Lock&lt;/code&gt; &lt;/a&gt; 과 달리 잠금 소유자 만 잠금을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3439e00fa8a3c024670687cffe82162907494a8" translate="yes" xml:space="preserve">
          <source>This is a thin convenience wrapper around &lt;a href=&quot;#trio.open_ssl_over_tcp_listeners&quot;&gt;&lt;code&gt;open_ssl_over_tcp_listeners()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.serve_listeners&quot;&gt;&lt;code&gt;serve_listeners()&lt;/code&gt;&lt;/a&gt; &amp;ndash; see them for full details.</source>
          <target state="translated">이것은 &lt;a href=&quot;#trio.open_ssl_over_tcp_listeners&quot;&gt; &lt;code&gt;open_ssl_over_tcp_listeners()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.serve_listeners&quot;&gt; &lt;code&gt;serve_listeners()&lt;/code&gt; &lt;/a&gt; 주위의 얇은 편의 래퍼 입니다. 자세한 내용은 해당 패키지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8686484a6ca97f02cdc1ea23ba90f658a805236b" translate="yes" xml:space="preserve">
          <source>This is a thin convenience wrapper around &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt;&lt;code&gt;open_tcp_listeners()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.serve_listeners&quot;&gt;&lt;code&gt;serve_listeners()&lt;/code&gt;&lt;/a&gt; &amp;ndash; see them for full details.</source>
          <target state="translated">이것은 &lt;a href=&quot;#trio.open_tcp_listeners&quot;&gt; &lt;code&gt;open_tcp_listeners()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#trio.serve_listeners&quot;&gt; &lt;code&gt;serve_listeners()&lt;/code&gt; &lt;/a&gt; 주위의 얇은 편리한 래퍼 입니다. 자세한 내용은 그것들을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6a21f0dfe9782d121688f4156eec97c0b785ae6a" translate="yes" xml:space="preserve">
          <source>This is a tricky interface with no guard rails. If you can use &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt;&lt;code&gt;ParkingLot&lt;/code&gt;&lt;/a&gt; or the built-in I/O wait functions instead, then you should.</source>
          <target state="translated">가드 레일이없는 까다로운 인터페이스입니다. &lt;a href=&quot;#trio.hazmat.ParkingLot&quot;&gt; &lt;code&gt;ParkingLot&lt;/code&gt; &lt;/a&gt; 또는 내장 I / O 대기 기능을 대신 사용할 수 있다면 해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed9a8864392dee8dccae92408c25c2bcaab6e1a2" translate="yes" xml:space="preserve">
          <source>This is a tricky interface with no guard rails. If you can use &lt;a href=&quot;#trio.lowlevel.ParkingLot&quot;&gt;&lt;code&gt;ParkingLot&lt;/code&gt;&lt;/a&gt; or the built-in I/O wait functions instead, then you should.</source>
          <target state="translated">이것은 가드 레일이없는 까다로운 인터페이스입니다. &lt;a href=&quot;#trio.lowlevel.ParkingLot&quot;&gt; &lt;code&gt;ParkingLot&lt;/code&gt; &lt;/a&gt; 또는 내장 I / O 대기 기능을 대신 사용할 수 있다면 그렇게 해야합니다.</target>
        </trans-unit>
        <trans-unit id="62916f9abf44ea5131fbba3fd3fa67633fc06333" translate="yes" xml:space="preserve">
          <source>This is an async method that returns a synchronous iterator, so you use it like:</source>
          <target state="translated">이것은 동기 반복자를 반환하는 비동기 메소드이므로 다음과 같이 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5ef14ee7f5ae379eed9b811cf4383e8fbde52f11" translate="yes" xml:space="preserve">
          <source>This is analogous to an &amp;ldquo;end-of-file&amp;rdquo; condition, but for channels.</source>
          <target state="translated">이것은 &quot;파일 끝&quot;조건과 유사하지만 채널에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="eca5f551bc86a3707933e82043f223ee98935da8" translate="yes" xml:space="preserve">
          <source>This is called before we enter a system-specific wait function like &lt;a href=&quot;https://docs.python.org/3/library/select.html#select.select&quot;&gt;&lt;code&gt;select.select()&lt;/code&gt;&lt;/a&gt;, to get the timeout to pass.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/select.html#select.select&quot;&gt; &lt;code&gt;select.select()&lt;/code&gt; &lt;/a&gt; 을 전달하기 위해 select.select () 와 같은 시스템 별 대기 함수를 입력하기 전에 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="b9eb6bfd2cfcdb8186ae558d2b498a13bca7a88f" translate="yes" xml:space="preserve">
          <source>This is cumbersome, but Python unfortunately doesn&amp;rsquo;t provide any other reliable options. If you use &lt;code&gt;aclosing()&lt;/code&gt;, then your generator&amp;rsquo;s cleanup code executes in the same context as the rest of its iterations, so timeouts, exceptions, and context variables work like you&amp;rsquo;d expect.</source>
          <target state="translated">이것은 번거롭지 만 불행히도 Python은 다른 신뢰할 수있는 옵션을 제공하지 않습니다. &lt;code&gt;aclosing()&lt;/code&gt; 을 사용하면 생성기의 정리 코드가 나머지 반복과 동일한 컨텍스트에서 실행되므로 시간 초과, 예외 및 컨텍스트 변수가 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c33a989e11aa76213cba8f2726e3fb28d36a356c" translate="yes" xml:space="preserve">
          <source>This is determined on a function-by-function basis. By default, a function is protected if its caller is, and not if its caller isn&amp;rsquo;t; this is helpful because it means you only need to override the defaults at places where you transition from protected code to unprotected code or vice-versa.</source>
          <target state="translated">이것은 기능별로 결정됩니다. 기본적으로 함수는 호출자가있는 경우 보호되며 호출자가 아닌 경우에는 보호되지 않습니다. 이것은 보호 된 코드에서 보호되지 않은 코드로 또는 그 반대로 전환하는 위치의 기본값 만 재정의하면되기 때문에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c56832a8eb6199cd3a4282e1874615668cbaa576" translate="yes" xml:space="preserve">
          <source>This is determined on a function-by-function basis. By default:</source>
          <target state="translated">이는 기능별로 결정됩니다. 기본적으로:</target>
        </trans-unit>
        <trans-unit id="59d307411d32a6c006290f810ba88a7b617a32e3" translate="yes" xml:space="preserve">
          <source>This is either a no-op, or else it allow other tasks to be scheduled and then raises &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;trio.Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 작동하지 않거나 다른 작업을 예약 한 다음 &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;trio.Cancelled&lt;/code&gt; 을 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="918fd503d30c70a4012dae526127fcf2c3cdd726" translate="yes" xml:space="preserve">
          <source>This is equivalent to calling &lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive()&lt;/code&gt;&lt;/a&gt; repeatedly. The loop exits without error when &lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive&lt;/code&gt;&lt;/a&gt; raises &lt;a href=&quot;reference-core#trio.EndOfChannel&quot;&gt;&lt;code&gt;EndOfChannel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive()&lt;/code&gt; &lt;/a&gt; 반복해서 호출하는 것과 같습니다 . &lt;a href=&quot;#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;reference-core#trio.EndOfChannel&quot;&gt; &lt;code&gt;EndOfChannel&lt;/code&gt; 을&lt;/a&gt; 올리면 루프가 오류없이 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5df3299548e7f24b6f4916386efc3494b1e0848" translate="yes" xml:space="preserve">
          <source>This is known as a &amp;ldquo;happy eyeballs&amp;rdquo; algorithm, and our particular variant is modelled after how Chrome connects to webservers; see &lt;a href=&quot;https://tools.ietf.org/html/rfc6555&quot;&gt;RFC 6555&lt;/a&gt; for more details.</source>
          <target state="translated">이를 '행복한 안구'알고리즘이라고하며, Google의 특정 변형은 Chrome이 웹 서버에 연결되는 방식에 따라 모델링됩니다. 자세한 내용 은 &lt;a href=&quot;https://tools.ietf.org/html/rfc6555&quot;&gt;RFC 6555&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4379e3a65b564c2c817949c6184653445cc5dfc6" translate="yes" xml:space="preserve">
          <source>This is like a no-operating-system-involved, Trio-streamsified version of &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socketpair&quot;&gt;&lt;code&gt;socket.socketpair()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 비 운영 체제 관련 Trio 스트림 버전의 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socketpair&quot;&gt; &lt;code&gt;socket.socketpair()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed8cb82fa76f8afdd017893fe6d82e0c370e3598" translate="yes" xml:space="preserve">
          <source>This is particularly useful in tests when you want to let a server pick its own port, and then connect to it:</source>
          <target state="translated">이것은 서버가 자체 포트를 선택한 다음 연결하도록하려는 경우 테스트에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b8d5871cda022acd530d3a2e7015027417917478" translate="yes" xml:space="preserve">
          <source>This is safe to call from the main thread, from other threads, and from signal handlers. This is the fundamental primitive used to re-enter the Trio run loop from outside of it.</source>
          <target state="translated">이것은 메인 스레드, 다른 스레드 및 신호 처리기에서 호출하는 것이 안전합니다. 이것은 외부에서 Trio 실행 루프를 다시 입력하는 데 사용되는 기본 프리미티브입니다.</target>
        </trans-unit>
        <trans-unit id="f1224a9af924c885f91aebaa013636dda44b62ae" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt;&lt;code&gt;check_one_way_stream()&lt;/code&gt;&lt;/a&gt;, except that the maker functions are expected to return objects implementing the &lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">이것은 메이커 함수가 &lt;a href=&quot;reference-io#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하는 객체를 돌려주는 것을 제외하고는 &lt;a href=&quot;#trio.testing.check_one_way_stream&quot;&gt; &lt;code&gt;check_one_way_stream()&lt;/code&gt; &lt;/a&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="03be5a68c53f7c102fa36f575fc1926e2be7101e" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#trio.testing.check_two_way_stream&quot;&gt;&lt;code&gt;check_two_way_stream()&lt;/code&gt;&lt;/a&gt;, except that the maker functions are expected to return objects that implement the &lt;a href=&quot;reference-io#trio.abc.HalfCloseableStream&quot;&gt;&lt;code&gt;HalfCloseableStream&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">이것은 메이커 함수가 &lt;a href=&quot;reference-io#trio.abc.HalfCloseableStream&quot;&gt; &lt;code&gt;HalfCloseableStream&lt;/code&gt; &lt;/a&gt; 인터페이스 를 구현하는 객체를 돌려주는 것을 제외하고는 &lt;a href=&quot;#trio.testing.check_two_way_stream&quot;&gt; &lt;code&gt;check_two_way_stream()&lt;/code&gt; &lt;/a&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="43eba094a9b0b6fd7d9cb8d6b304c98507fbc7ae" translate="yes" xml:space="preserve">
          <source>This is the lowest-level API for blocking in Trio. Every time a &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; blocks, it does so by calling this function (usually indirectly via some higher-level API).</source>
          <target state="translated">이것은 Trio에서 차단을위한 가장 낮은 수준의 API입니다. &lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 차단 될 때마다이 기능을 호출하여 (보통 일부 고급 API를 통해 간접적으로) 수행합니다.</target>
        </trans-unit>
        <trans-unit id="477341b23362ad59adc031dfb5e5a613e3001da6" translate="yes" xml:space="preserve">
          <source>This is the lowest-level API for blocking in Trio. Every time a &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; blocks, it does so by calling this function (usually indirectly via some higher-level API).</source>
          <target state="translated">이것은 Trio에서 차단하기위한 가장 낮은 수준의 API입니다. &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 차단 될 때마다이 함수를 호출하여 수행합니다 (일반적으로 일부 상위 수준 API를 통해 간접적으로).</target>
        </trans-unit>
        <trans-unit id="ea4acecf4fbb18913e774bb995c238217d6a1937" translate="yes" xml:space="preserve">
          <source>This is the task that is the ultimate parent of all other tasks.</source>
          <target state="translated">이것은 다른 모든 작업의 ​​최종 부모 인 작업입니다.</target>
        </trans-unit>
        <trans-unit id="a22ac9eb1bb7bf57231034370b737046cb61f388" translate="yes" xml:space="preserve">
          <source>This is used to implement &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt;&lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt;&lt;code&gt;memory_stream_pair()&lt;/code&gt;&lt;/a&gt;; see the latter&amp;rsquo;s docstring for an example of how you might use it yourself.</source>
          <target state="translated">&lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt; &lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt; &lt;code&gt;memory_stream_pair()&lt;/code&gt; &lt;/a&gt; 를 구현하는 데 사용됩니다 . 직접 사용하는 방법에 대한 예는 후자의 docstring을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f48dde0527c8494ca2e28a4cd0989758ecebeabd" translate="yes" xml:space="preserve">
          <source>This is used to implement functions like &lt;a href=&quot;#trio.current_time&quot;&gt;&lt;code&gt;trio.current_time()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.move_on_after&quot;&gt;&lt;code&gt;trio.move_on_after()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.current_time&quot;&gt; &lt;code&gt;trio.current_time()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.move_on_after&quot;&gt; &lt;code&gt;trio.move_on_after()&lt;/code&gt; &lt;/a&gt; 와 같은 함수를 구현하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="73a3bbd0c9272d9c41b2c54752f4037caad4bd1e" translate="yes" xml:space="preserve">
          <source>This is useful for communication patterns that involve multiple consumers all receiving objects from the same underlying channel. See &lt;a href=&quot;#channel-mpmc&quot;&gt;Managing multiple producers and/or multiple consumers&lt;/a&gt; for examples.</source>
          <target state="translated">이 기능은 여러 소비자가 동일한 기본 채널에서 객체를받는 모든 통신 패턴에 유용합니다. 예제는 &lt;a href=&quot;#channel-mpmc&quot;&gt;여러 생산자 및 / 또는 여러 소비자 관리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6332c9de89c2de2b861fb164fa12e80e53ca2924" translate="yes" xml:space="preserve">
          <source>This is useful for communication patterns that involve multiple producers all sending objects to the same destination. If you give each producer its own clone of the &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt;&lt;code&gt;MemorySendChannel&lt;/code&gt;&lt;/a&gt;, and then make sure to close each &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt;&lt;code&gt;MemorySendChannel&lt;/code&gt;&lt;/a&gt; when it&amp;rsquo;s finished, receivers will automatically get notified when all producers are finished. See &lt;a href=&quot;#channel-mpmc&quot;&gt;Managing multiple producers and/or multiple consumers&lt;/a&gt; for examples.</source>
          <target state="translated">이는 여러 생산자가 모두 동일한 대상으로 개체를 보내는 통신 패턴에 유용합니다. 각 제작자에게 자체 &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt; &lt;code&gt;MemorySendChannel&lt;/code&gt; &lt;/a&gt; 복제본을 제공 한 다음 완료되면 각 &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt; &lt;code&gt;MemorySendChannel&lt;/code&gt; &lt;/a&gt; 을 닫아야합니다 . 모든 제작자가 완료되면 수신자에게 자동으로 알림이 표시됩니다. 예제는 &lt;a href=&quot;#channel-mpmc&quot;&gt;여러 생산자 및 / 또는 여러 소비자 관리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="656afa48ac21a0f1af58f68661fd2f4f96313976" translate="yes" xml:space="preserve">
          <source>This is useful in some exotic networking configurations where your host has multiple IP addresses, and you want to force the use of a specific one.</source>
          <target state="translated">이것은 호스트에 여러 IP 주소가 있고 특정 주소를 강제로 사용하려는 일부 이국적인 네트워킹 구성에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="14371b9c7cf5540c783770ba7972ab7d26d5fd82" translate="yes" xml:space="preserve">
          <source>This is useful in testing code when you want to give other tasks a chance to &amp;ldquo;settle down&amp;rdquo;. The calling task is blocked, and doesn&amp;rsquo;t wake up until all other tasks are also blocked for at least &lt;code&gt;cushion&lt;/code&gt; seconds. (Setting a non-zero &lt;code&gt;cushion&lt;/code&gt; is intended to handle cases like two tasks talking to each other over a local socket, where we want to ignore the potential brief moment between a send and receive when all tasks are blocked.)</source>
          <target state="translated">이것은 다른 작업에 &quot;정착&quot;할 기회를 주려고 할 때 코드를 테스트하는 데 유용합니다. 호출 작업은 차단되며 다른 모든 작업도 최소 &lt;code&gt;cushion&lt;/code&gt; 초 동안 차단 될 때까지 깨어나지 않습니다 . (제로 가 아닌 &lt;code&gt;cushion&lt;/code&gt; 설정은 로컬 소켓을 통해 서로 대화하는 두 가지 작업과 같은 경우를 처리하기위한 것입니다. 모든 작업이 차단 될 때 보내기와 받기 사이의 짧은 순간을 무시하려고합니다.)</target>
        </trans-unit>
        <trans-unit id="6d9c47c65341615224be021b44bf2fd41e1eacd6" translate="yes" xml:space="preserve">
          <source>This logic is a bit convoluted, but accomplishes all of the following:</source>
          <target state="translated">이 논리는 약간 복잡하지만 다음을 모두 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7ceffadabbbd6b876aa5cf2d79a7eb379cd975bc" translate="yes" xml:space="preserve">
          <source>This means that if you call &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt;&lt;/a&gt; with a cushion &lt;em&gt;larger&lt;/em&gt; than your autojump threshold, then your call to &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt;&lt;/a&gt; will never return, because the autojump task will keep waking up before your task does, and each time it does it&amp;rsquo;ll reset your task&amp;rsquo;s timer. However, if your cushion and the autojump threshold are the &lt;em&gt;same&lt;/em&gt;, then the autojump&amp;rsquo;s tiebreaker will prevent them from interfering (unless you also set your tiebreaker to infinity for some reason. Don&amp;rsquo;t do that). As an important special case: this means that if you set an autojump threshold of zero and use &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt;&lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt;&lt;/a&gt; with the default zero cushion, then everything will work fine.</source>
          <target state="translated">이 방법은 호출하면 그 &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt; &lt;/a&gt; 쿠션으로 &lt;em&gt;더 큰&lt;/em&gt; 당신의 autojump 임계 값보다 전화 후 &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt; &lt;/a&gt; autojump 작업이 사용자의 작업보다 먼저 깨어 난 계속하기 때문에, 반환하지 않습니다, 그리고 그것을 수행 때마다거야 작업 타이머를 재설정하십시오. 그러나 쿠션과 오토 점프 임계 값이 &lt;em&gt;동일&lt;/em&gt; 하면 오토 점프의 타이 브레이커가 간섭을 방지합니다 (어떤 이유로 타이 브레이커를 무한대로 설정하지 않는 한). 중요한 특수한 경우 : 즉, 자동 점프 임계 값을 0으로 설정 하고 기본 제로 쿠션과 함께 &lt;a href=&quot;#trio.testing.wait_all_tasks_blocked&quot;&gt; &lt;code&gt;wait_all_tasks_blocked()&lt;/code&gt; &lt;/a&gt; 사용하면 모든 것이 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a31ec8fe7387a6f002a01fe33b6841ee026197dd" translate="yes" xml:space="preserve">
          <source>This means that tasks form a tree: when you call &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;, then this creates an initial task, and all your other tasks will be children, grandchildren, etc. of the initial task.</source>
          <target state="translated">이것은 태스크가 트리를 형성한다는 것을 의미합니다. &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 을 호출 하면 초기 태스크가 생성되고 다른 모든 태스크는 초기 태스크의 자식, 손자 등이됩니다.</target>
        </trans-unit>
        <trans-unit id="f005299077b827c8391c3a9c98e8547fe4ad4d44" translate="yes" xml:space="preserve">
          <source>This means you only need to override the defaults at places where you transition from protected code to unprotected code or vice-versa.</source>
          <target state="translated">즉, 보호 된 코드에서 보호되지 않은 코드로 또는 그 반대로 전환하는 위치에서만 기본값을 재정의하면됩니다.</target>
        </trans-unit>
        <trans-unit id="001dbbe80004bb99fc2bc2a63a98f6d83ad1c4aa" translate="yes" xml:space="preserve">
          <source>This method &lt;strong&gt;must not&lt;/strong&gt; return &lt;em&gt;late&lt;/em&gt;: if it&amp;rsquo;s possible for &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; to complete without blocking, then it must return. When implementing it, err on the side of returning early.</source>
          <target state="translated">이 메소드 &lt;strong&gt;는 &lt;/strong&gt;&lt;em&gt;늦게&lt;/em&gt; 리턴 &lt;strong&gt;되지 않아야합니다&lt;/strong&gt; . &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; 이 블로킹없이 완료 될 수 있으면 리턴해야합니다. 그것을 구현할 때 일찍 돌아 오는 편에서 실수하십시오.</target>
        </trans-unit>
        <trans-unit id="fe0ddaab4931c7368e42811a407720834ac1654f" translate="yes" xml:space="preserve">
          <source>This method handles routine errors like &lt;code&gt;ECONNABORTED&lt;/code&gt;, but passes other errors on to its caller. In particular, it does &lt;em&gt;not&lt;/em&gt; make any special effort to handle resource exhaustion errors like &lt;code&gt;EMFILE&lt;/code&gt;, &lt;code&gt;ENFILE&lt;/code&gt;, &lt;code&gt;ENOBUFS&lt;/code&gt;, &lt;code&gt;ENOMEM&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;ECONNABORTED&lt;/code&gt; 와 같은 일상적인 오류를 처리 하지만 다른 오류는 호출자에게 전달합니다. 특히 &lt;code&gt;EMFILE&lt;/code&gt; , &lt;code&gt;ENFILE&lt;/code&gt; , &lt;code&gt;ENOBUFS&lt;/code&gt; , &lt;code&gt;ENOMEM&lt;/code&gt; 과 같은 리소스 소진 오류를 처리하기 위해 특별한 노력을 기울이지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cc8504b3af8bb3a52e7201c66061ace528b891af" translate="yes" xml:space="preserve">
          <source>This method is idempotent, i.e., if the scope was already cancelled then this method silently does nothing.</source>
          <target state="translated">이 메소드는 dem 등원입니다. 즉, 범위가 이미 취소 된 경우이 메소드는 자동으로 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="327bcec5e9f1d8e5c9b4dfa3978e568947924437" translate="yes" xml:space="preserve">
          <source>This method is intended to aid in implementing protocols that want to delay choosing which data to send until the last moment. E.g., suppose you&amp;rsquo;re working on an implemention of a remote display server like &lt;a href=&quot;https://en.wikipedia.org/wiki/Virtual_Network_Computing&quot;&gt;VNC&lt;/a&gt;, and the network connection is currently backed up so that if you call &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; now then it will sit for 0.5 seconds before actually sending anything. In this case it doesn&amp;rsquo;t make sense to take a screenshot, then wait 0.5 seconds, and then send it, because the screen will keep changing while you wait; it&amp;rsquo;s better to wait 0.5 seconds, then take the screenshot, and then send it, because this way the data you deliver will be more up-to-date. Using &lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt;&lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt;&lt;/a&gt; makes it possible to implement the better strategy.</source>
          <target state="translated">이 방법은 마지막 순간까지 전송할 데이터 선택을 지연시키려는 프로토콜을 구현하는 데 도움이됩니다. 예를 들어 &lt;a href=&quot;https://en.wikipedia.org/wiki/Virtual_Network_Computing&quot;&gt;VNC&lt;/a&gt; 와 같은 원격 디스플레이 서버 구현을 작업 중이고 현재 네트워크 연결이 백업되어 &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; 을 호출하면 실제로 전송하기 전에 0.5 초 동안 대기 합니다. 이 경우 스크린 샷을 찍은 다음 0.5 초간 기다렸다가 전송하는 것이 합리적이지 않습니다. 대기하는 동안 화면이 계속 바뀌기 때문입니다. 0.5 초간 기다린 다음 스크린 샷을 촬영 한 다음 전송하는 것이 좋습니다. 이렇게하면 제공하는 데이터가 더 최신 정보가됩니다. &lt;a href=&quot;#trio.abc.SendStream.wait_send_all_might_not_block&quot;&gt; &lt;code&gt;wait_send_all_might_not_block()&lt;/code&gt; &lt;/a&gt; 을 사용 하면 더 나은 전략을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11ce31115b0532c0a09e761077c91c38b3555228" translate="yes" xml:space="preserve">
          <source>This method may return early: it&amp;rsquo;s possible that after it returns, &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; will still block. (In the worst case, if no better implementation is available, then it might always return immediately without blocking. It&amp;rsquo;s nice to do better than that when possible, though.)</source>
          <target state="translated">이 메소드는 일찍 리턴 될 수 있습니다. 리턴 후에도 &lt;a href=&quot;#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; 이 여전히 차단 될 수 있습니다. (최악의 경우 더 나은 구현을 사용할 수 없으면 항상 차단하지 않고 즉시 반환 될 수 있습니다. 가능하면 그보다 더 나은 방법을 사용하는 것이 좋습니다.)</target>
        </trans-unit>
        <trans-unit id="68cd0d3fca1c3e830708ccdf82c78498e770bf02" translate="yes" xml:space="preserve">
          <source>This must be called from inside the coroutine being resumed, and yields whatever value you pass in. (Presumably you&amp;rsquo;ll pass a value that will cause the current coroutine runner to stop scheduling this task.) Then the coroutine is resumed by the Trio scheduler at the next opportunity.</source>
          <target state="translated">이것은 다시 시작되는 코 루틴 내부에서 호출해야하며 전달한 값을 산출합니다. (현재 코 루틴 러너가이 작업을 예약하지 못하게하는 값을 전달합니다.) 그런 다음 코 루틴은 Trio 스케줄러에 의해 다시 시작됩니다. 다음 기회에.</target>
        </trans-unit>
        <trans-unit id="07dd1ff7276a26efb26664ad097a141e5b97de29" translate="yes" xml:space="preserve">
          <source>This object has two uses:</source>
          <target state="translated">이 객체에는 두 가지 용도가 있습니다.</target>
        </trans-unit>
        <trans-unit id="59a2c593d37d67b4ae21874adc6716930415e309" translate="yes" xml:space="preserve">
          <source>This object&amp;rsquo;s interface is similar to, but different from, that of &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Semaphore&quot;&gt;&lt;code&gt;threading.Semaphore&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 객체의 인터페이스는 &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Semaphore&quot;&gt; &lt;code&gt;threading.Semaphore&lt;/code&gt; &lt;/a&gt; 와 비슷하지만 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="9a68395d90aeaf758adfebddbd727e34ea765aab" translate="yes" xml:space="preserve">
          <source>This project is young and still somewhat experimental: the overall design is solid and the existing features are fully tested and documented, but you may encounter missing functionality or rough edges. We &lt;em&gt;do&lt;/em&gt; encourage you do use it, but you should &lt;a href=&quot;https://github.com/python-trio/trio/issues/1&quot;&gt;read and subscribe to issue #1&lt;/a&gt; to get warning and a chance to give feedback about any compatibility-breaking changes.</source>
          <target state="translated">이 프로젝트는 아직 젊고 다소 실험적입니다. 전체 디자인이 견고하고 기존 기능이 완전히 테스트 및 문서화되었지만 기능 누락 또는 거친 부분이 발생할 수 있습니다. 우리는 &lt;em&gt;않습니다&lt;/em&gt; 당신이 그것을 사용합니까 격려,하지만 당신은해야 &lt;a href=&quot;https://github.com/python-trio/trio/issues/1&quot;&gt;읽고 # 1을 발행 구독&lt;/a&gt; 경고 및 호환성 깨는 변경 사항에 대한 피드백을 제공 할 수있는 기회를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec32d26f4a4b5dcad7771a9eee995fa9164024e5" translate="yes" xml:space="preserve">
          <source>This returns a new &lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt;&lt;code&gt;MemoryReceiveChannel&lt;/code&gt;&lt;/a&gt; object, which acts as a duplicate of the original: receiving on the new object does exactly the same thing as receiving on the old object.</source>
          <target state="translated">이것은 새로운 &lt;a href=&quot;#trio.MemoryReceiveChannel&quot;&gt; &lt;code&gt;MemoryReceiveChannel&lt;/code&gt; &lt;/a&gt; 객체를 반환하는데 , 이것은 원본의 복제본으로 작동합니다 : 새로운 객체를받는 것은 이전의 객체를받는 것과 정확히 같은 것입니다.</target>
        </trans-unit>
        <trans-unit id="a121a762df27863607d656fedc77c458d011385f" translate="yes" xml:space="preserve">
          <source>This returns a new &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt;&lt;code&gt;MemorySendChannel&lt;/code&gt;&lt;/a&gt; object, which acts as a duplicate of the original: sending on the new object does exactly the same thing as sending on the old object. (If you&amp;rsquo;re familiar with &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.dup&quot;&gt;&lt;code&gt;os.dup&lt;/code&gt;&lt;/a&gt;, then this is a similar idea.)</source>
          <target state="translated">이것은 새로운 &lt;a href=&quot;#trio.MemorySendChannel&quot;&gt; &lt;code&gt;MemorySendChannel&lt;/code&gt; &lt;/a&gt; 객체를 반환하는데 , 이것은 원본의 복제본 역할을합니다. &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.dup&quot;&gt; &lt;code&gt;os.dup&lt;/code&gt; 에&lt;/a&gt; 익숙하다면 비슷한 아이디어입니다.</target>
        </trans-unit>
        <trans-unit id="e198f11e3abc356f6bac5f79d25c297a458de712" translate="yes" xml:space="preserve">
          <source>This setting has no effect if your program has registered a custom SIGINT handler, or if &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; is called from anywhere but the main thread (this is a Python limitation), or if you use &lt;a href=&quot;reference-io#trio.open_signal_receiver&quot;&gt;&lt;code&gt;open_signal_receiver()&lt;/code&gt;&lt;/a&gt; to catch SIGINT.</source>
          <target state="translated">이 설정은 프로그램이 사용자 정의 SIGINT 처리기를 등록했거나 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 이 주 스레드 이외의 곳에서 호출 된 경우 ( Python 제한) &lt;a href=&quot;reference-io#trio.open_signal_receiver&quot;&gt; &lt;code&gt;open_signal_receiver()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 SIGINT를 잡는 경우에는 효과가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8544c29e984137341c0686f2d63ccb7f84894719" translate="yes" xml:space="preserve">
          <source>This should include all the attributes exposed by classes in &lt;a href=&quot;https://docs.python.org/3/library/io.html#module-io&quot;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;. But if you&amp;rsquo;re wrapping an object that has other attributes that aren&amp;rsquo;t on the list above, then you can access them via the &lt;code&gt;.wrapped&lt;/code&gt; attribute:</source>
          <target state="translated">여기에는 &lt;a href=&quot;https://docs.python.org/3/library/io.html#module-io&quot;&gt; &lt;code&gt;io&lt;/code&gt; 의&lt;/a&gt; 클래스에 의해 노출되는 모든 속성이 포함되어야합니다 . 그러나 위 목록에없는 다른 속성을 가진 객체를 래핑하는 경우 &lt;code&gt;.wrapped&lt;/code&gt; 속성을 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b75455664926a8069eb8f58115417e9cb3001585" translate="yes" xml:space="preserve">
          <source>This should never happen! If you get this error, please file a bug.</source>
          <target state="translated">이런 일은 절대 일어나지 않아야합니다! 이 오류가 발생하면 버그를 신고하십시오.</target>
        </trans-unit>
        <trans-unit id="0778ce6636c49535b569f7546a62446d88b94afe" translate="yes" xml:space="preserve">
          <source>This stream has &lt;em&gt;absolutely no&lt;/em&gt; buffering. Each call to &lt;a href=&quot;reference-io#trio.abc.SendStream.send_all&quot;&gt;&lt;code&gt;send_all()&lt;/code&gt;&lt;/a&gt; will block until all the given data has been returned by a call to &lt;a href=&quot;reference-io#trio.abc.ReceiveStream.receive_some&quot;&gt;&lt;code&gt;receive_some()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 스트림에는 버퍼링 이 &lt;em&gt;전혀 없습니다&lt;/em&gt; . 각 호출 &lt;a href=&quot;reference-io#trio.abc.SendStream.send_all&quot;&gt; &lt;code&gt;send_all()&lt;/code&gt; &lt;/a&gt; 모든 데이터가 소정의 호출에 의해 리턴 될 때까지 차단 &lt;a href=&quot;reference-io#trio.abc.ReceiveStream.receive_some&quot;&gt; &lt;code&gt;receive_some()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c6928d21a889dc4f82db9ebb48058b9d6fb885e" translate="yes" xml:space="preserve">
          <source>This task&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#contextvars.Context&quot;&gt;&lt;code&gt;contextvars.Context&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">이 작업의 &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#contextvars.Context&quot;&gt; &lt;code&gt;contextvars.Context&lt;/code&gt; &lt;/a&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="d87a62610b91ba5d469e111e2195effe428736a6" translate="yes" xml:space="preserve">
          <source>This task&amp;rsquo;s coroutine object. Example usage: extracting a stack trace:</source>
          <target state="translated">이 작업의 코 루틴 객체. 사용법 예 : 스택 추적 추출 :</target>
        </trans-unit>
        <trans-unit id="6b3da9f4aca9dba70e3bde25fee8a94969706173" translate="yes" xml:space="preserve">
          <source>This wakes up &lt;code&gt;count&lt;/code&gt; tasks that are blocked in &lt;a href=&quot;#trio.hazmat.ParkingLot.park&quot;&gt;&lt;code&gt;park()&lt;/code&gt;&lt;/a&gt;. If there are fewer than &lt;code&gt;count&lt;/code&gt; tasks parked, then wakes as many tasks are available and then returns successfully.</source>
          <target state="translated">이것은 &lt;a href=&quot;#trio.hazmat.ParkingLot.park&quot;&gt; &lt;code&gt;park()&lt;/code&gt; &lt;/a&gt; 에서 차단 된 &lt;code&gt;count&lt;/code&gt; 작업을 깨 웁니다 . 파킹 된 수보다 적은 &lt;code&gt;count&lt;/code&gt; 작업이있는 경우 사용 가능한 많은 수의 작업을 깨운 다음 ​​성공적으로 돌아옵니다.</target>
        </trans-unit>
        <trans-unit id="0d3750a87ca97b95a41eb6cbd73385051a9b7290" translate="yes" xml:space="preserve">
          <source>This wakes up &lt;code&gt;count&lt;/code&gt; tasks that are blocked in &lt;a href=&quot;#trio.lowlevel.ParkingLot.park&quot;&gt;&lt;code&gt;park()&lt;/code&gt;&lt;/a&gt;. If there are fewer than &lt;code&gt;count&lt;/code&gt; tasks parked, then wakes as many tasks are available and then returns successfully.</source>
          <target state="translated">이것은 &lt;a href=&quot;#trio.lowlevel.ParkingLot.park&quot;&gt; &lt;code&gt;park()&lt;/code&gt; &lt;/a&gt; 에서 차단 된 &lt;code&gt;count&lt;/code&gt; 작업을 깨 웁니다 . 파킹 된 작업 수가 &lt;code&gt;count&lt;/code&gt; 보다 적 으면 사용 가능한 작업 수만큼 깨운 다음 ​​성공적으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="aee475931b299c6d841c958af99cba9eabd02399" translate="yes" xml:space="preserve">
          <source>This way we can see that request 1 was slow: it started before request 2 but finished afterwards. (You can also get &lt;a href=&quot;https://opentracing.io/docs/&quot;&gt;much fancier&lt;/a&gt;, but this is enough for an example.)</source>
          <target state="translated">이런 식으로 요청 1이 느리다는 것을 알 수 있습니다. 요청 2는 요청 2 이전에 시작되었지만 나중에 완료되었습니다. (당신은 &lt;a href=&quot;https://opentracing.io/docs/&quot;&gt;훨씬 더 많은&lt;/a&gt; 것을 얻을 수 있지만 이것은 예를 위해 충분합니다.)</target>
        </trans-unit>
        <trans-unit id="e101192d5d657da7f6a68e046e5e6272e86645d2" translate="yes" xml:space="preserve">
          <source>This way, your two event loops have the same lifetime, and your program automatically exits when your Trio function finishes.</source>
          <target state="translated">이렇게하면 두 이벤트 루프의 수명이 동일하며 Trio 기능이 완료되면 프로그램이 자동으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="a4429c38a1975f5763a238e06f0d62b450c78494" translate="yes" xml:space="preserve">
          <source>This will probably be clearer with an example. Here we demonstrate how to spawn a child thread, and then use a &lt;a href=&quot;#channels&quot;&gt;memory channel&lt;/a&gt; to send messages between the thread and a Trio task:</source>
          <target state="translated">이것은 아마도 예를 들어 더 명확해질 것입니다. 다음은 자식 스레드를 생성 한 다음 &lt;a href=&quot;#channels&quot;&gt;메모리 채널&lt;/a&gt; 을 사용 하여 스레드와 Trio 작업간에 메시지를 보내는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="11d26ec84465ee4cd2879abd7330229b6daec696" translate="yes" xml:space="preserve">
          <source>This works by starting a set of tasks which each try to run their function, and then report back the value it returns. The main task uses &lt;code&gt;receive_channel.receive&lt;/code&gt; to wait for one to finish; as soon as the first task crosses the finish line, it cancels the rest, and then returns the winning value.</source>
          <target state="translated">이것은 각각의 기능을 실행하려고 시도하는 작업 세트를 시작한 다음 반환되는 값을 다시보고하여 작동합니다. 기본 작업은 &lt;code&gt;receive_channel.receive&lt;/code&gt; 를 사용 하여 하나가 완료 될 때까지 기다립니다. 첫 번째 작업이 결승선을 통과하자마자 나머지 작업을 취소 한 다음 승리 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="47930bd9c8e42779dd9eefabccf4759ba973fe91" translate="yes" xml:space="preserve">
          <source>This wraps any file object in a wrapper that provides an asynchronous file object interface.</source>
          <target state="translated">비동기 파일 오브젝트 인터페이스를 제공하는 랩퍼로 파일 오브젝트를 랩핑합니다.</target>
        </trans-unit>
        <trans-unit id="d0cef5deb223649da3c92e68bafacf5c8ccd785e" translate="yes" xml:space="preserve">
          <source>Thread safety</source>
          <target state="translated">스레드 안전</target>
        </trans-unit>
        <trans-unit id="c2ae2cf32d685dc7a1f9f34c4a9d9327ffc68dbc" translate="yes" xml:space="preserve">
          <source>Threads (if you must)</source>
          <target state="translated">스레드 (필요한 경우)</target>
        </trans-unit>
        <trans-unit id="0466f8bc08e10e7b99d662eae8d049fece98b184" translate="yes" xml:space="preserve">
          <source>Time and clocks</source>
          <target state="translated">시간과 시계</target>
        </trans-unit>
        <trans-unit id="c86350a7e132f385d94c48db12ed5fffe7264e2d" translate="yes" xml:space="preserve">
          <source>Time and timeouts</source>
          <target state="translated">시간과 타임 아웃</target>
        </trans-unit>
        <trans-unit id="30a89cebf15d291ad9051f7d277492c668872107" translate="yes" xml:space="preserve">
          <source>To avoid this, threads mark themselves as idle &lt;em&gt;before&lt;/em&gt; calling &lt;code&gt;deliver&lt;/code&gt;.</source>
          <target state="translated">이를 방지하려면, 스레드는 유휴 상태로 자신을 표시 &lt;em&gt;하기 전에&lt;/em&gt; 호출 &lt;code&gt;deliver&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9672fd790323861a273f8a756b00c40cc5fc7c09" translate="yes" xml:space="preserve">
          <source>To be used as a Trio stream, an open file must be placed in non-blocking mode. Unfortunately, this impacts all I/O that goes through the underlying open file, including I/O that uses a different file descriptor than the one that was passed to Trio. If other threads or processes are using file descriptors that are related through &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.dup&quot;&gt;&lt;code&gt;os.dup&lt;/code&gt;&lt;/a&gt; or inheritance across &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.fork&quot;&gt;&lt;code&gt;os.fork&lt;/code&gt;&lt;/a&gt; to the one that Trio is using, they are unlikely to be prepared to have non-blocking I/O semantics suddenly thrust upon them. For example, you can use &lt;code&gt;FdStream(os.dup(0))&lt;/code&gt; to obtain a stream for reading from standard input, but it is only safe to do so with heavy caveats: your stdin must not be shared by any other processes and you must not make any calls to synchronous methods of &lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.stdin&quot;&gt;&lt;code&gt;sys.stdin&lt;/code&gt;&lt;/a&gt; until the stream returned by &lt;a href=&quot;#trio.hazmat.FdStream&quot;&gt;&lt;code&gt;FdStream&lt;/code&gt;&lt;/a&gt; is closed. See &lt;a href=&quot;https://github.com/python-trio/trio/issues/174&quot;&gt;issue #174&lt;/a&gt; for a discussion of the challenges involved in relaxing this restriction.</source>
          <target state="translated">Trio 스트림으로 사용하려면 열린 파일을 비 차단 모드로 두어야합니다. 불행하게도 이는 Trio에 전달 된 것과 다른 파일 설명자를 사용하는 I / O를 포함하여 기본 열린 파일을 통과하는 모든 I / O에 영향을줍니다. 다른 스레드 또는 프로세스가 &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.dup&quot;&gt; &lt;code&gt;os.dup&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.fork&quot;&gt; &lt;code&gt;os.fork&lt;/code&gt; &lt;/a&gt; 를 통한 Trio가 사용하는 것과의 상속을 통해 관련된 파일 디스크립터를 사용하는 경우 비 블로킹 I / O 시맨틱이 갑자기 스러스트 될 가능성이 없습니다. 예를 들어, &lt;code&gt;FdStream(os.dup(0))&lt;/code&gt; 을 사용하여 표준 입력에서 읽을 스트림을 얻을 수 있지만 큰 경고가있는 경우에만 안전합니다. stdin은 다른 프로세스와 공유하지 않아야하며 동기 메소드를 호출하지 마십시오.&lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.stdin&quot;&gt; &lt;code&gt;sys.stdin&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#trio.hazmat.FdStream&quot;&gt; &lt;code&gt;FdStream&lt;/code&gt; &lt;/a&gt; 에의해 반환 된 스트림이 닫힐때까지 sys.stdin 이 제한 완화와 관련된&lt;a href=&quot;https://github.com/python-trio/trio/issues/174&quot;&gt; 문제&lt;/a&gt; 에 대한 논의는 문제 # 174 를참조하십시오.</target>
        </trans-unit>
        <trans-unit id="abcb219546bd354d940210d5cfe8092f011774a4" translate="yes" xml:space="preserve">
          <source>To be used as a Trio stream, an open file must be placed in non-blocking mode. Unfortunately, this impacts all I/O that goes through the underlying open file, including I/O that uses a different file descriptor than the one that was passed to Trio. If other threads or processes are using file descriptors that are related through &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.dup&quot;&gt;&lt;code&gt;os.dup&lt;/code&gt;&lt;/a&gt; or inheritance across &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.fork&quot;&gt;&lt;code&gt;os.fork&lt;/code&gt;&lt;/a&gt; to the one that Trio is using, they are unlikely to be prepared to have non-blocking I/O semantics suddenly thrust upon them. For example, you can use &lt;code&gt;FdStream(os.dup(sys.stdin.fileno()))&lt;/code&gt; to obtain a stream for reading from standard input, but it is only safe to do so with heavy caveats: your stdin must not be shared by any other processes and you must not make any calls to synchronous methods of &lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.stdin&quot;&gt;&lt;code&gt;sys.stdin&lt;/code&gt;&lt;/a&gt; until the stream returned by &lt;a href=&quot;#trio.lowlevel.FdStream&quot;&gt;&lt;code&gt;FdStream&lt;/code&gt;&lt;/a&gt; is closed. See &lt;a href=&quot;https://github.com/python-trio/trio/issues/174&quot;&gt;issue #174&lt;/a&gt; for a discussion of the challenges involved in relaxing this restriction.</source>
          <target state="translated">Trio 스트림으로 사용하려면 열린 파일이 비 차단 모드에 있어야합니다. 불행히도 이것은 Trio에 전달 된 것과 다른 파일 설명자를 사용하는 I / O를 포함하여 기본 열린 파일을 통과하는 모든 I / O에 영향을 미칩니다. 다른 스레드 또는 프로세스가 &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.dup&quot;&gt; &lt;code&gt;os.dup&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.fork&quot;&gt; &lt;code&gt;os.fork&lt;/code&gt; &lt;/a&gt; 를 통한 상속을 통해 Trio가 사용하는 것과 관련된 파일 설명자를 사용하는 경우 갑자기 비 블로킹 I / O 의미를 가질 준비가되지 않을 것입니다. 예를 들어, &lt;code&gt;FdStream(os.dup(sys.stdin.fileno()))&lt;/code&gt; 을 사용하여 표준 입력에서 읽기위한 스트림을 얻을 수 있습니다. 다른 모든 프로세스와 동기 메서드를 호출해서는 안됩니다.&lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.stdin&quot;&gt; &lt;code&gt;sys.stdin&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#trio.lowlevel.FdStream&quot;&gt; &lt;code&gt;FdStream&lt;/code&gt; &lt;/a&gt; 이반환 한 스트림이 닫힐때까지 sys.stdin . 이 제한을 완화하는 데 관련된&lt;a href=&quot;https://github.com/python-trio/trio/issues/174&quot;&gt; 문제&lt;/a&gt; 에 대한 논의는 문제 # 174 를참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b931c6b0d780ed8d96ccd76191352b796bd15ae7" translate="yes" xml:space="preserve">
          <source>To build a bidirectional stream, &lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt;&lt;code&gt;memory_stream_pair()&lt;/code&gt;&lt;/a&gt; uses two unidirectional streams. It gets these by calling &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt;&lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">양방향 스트림을 빌드하기 위해 &lt;a href=&quot;#trio.testing.memory_stream_pair&quot;&gt; &lt;code&gt;memory_stream_pair()&lt;/code&gt; &lt;/a&gt; 는 두 개의 단방향 스트림을 사용합니다. &lt;a href=&quot;#trio.testing.memory_stream_one_way_pair&quot;&gt; &lt;code&gt;memory_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; 를 호출하여이를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="05516bbca026f3ec58a38804bdec50fda7847866" translate="yes" xml:space="preserve">
          <source>To solve this problem, Python 3.7 added a new module to the standard library: &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt;&lt;code&gt;contextvars&lt;/code&gt;&lt;/a&gt;. And not only does Trio have built-in support for &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt;&lt;code&gt;contextvars&lt;/code&gt;&lt;/a&gt;, but if you&amp;rsquo;re using an earlier version of Python, then Trio makes sure that a backported version of &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt;&lt;code&gt;contextvars&lt;/code&gt;&lt;/a&gt; is installed. So you can assume &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt;&lt;code&gt;contextvars&lt;/code&gt;&lt;/a&gt; is there and works regardless of what version of Python you&amp;rsquo;re using.</source>
          <target state="translated">이 문제를 해결하기 위해 Python 3.7은 표준 라이브러리에 &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt; &lt;code&gt;contextvars&lt;/code&gt; &lt;/a&gt; 새로운 모듈을 추가했습니다 . 또한 Trio는 &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt; &lt;code&gt;contextvars&lt;/code&gt; &lt;/a&gt; 를 기본적 으로 지원할 뿐만 아니라 이전 버전의 Python을 사용하는 경우 &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt; &lt;code&gt;contextvars&lt;/code&gt; &lt;/a&gt; 버전의 contextvars 가 설치되어 있는지 확인합니다 . 따라서 &lt;a href=&quot;https://docs.python.org/3/library/contextvars.html#module-contextvars&quot;&gt; &lt;code&gt;contextvars&lt;/code&gt; &lt;/a&gt; 가 있다고 가정 하고 사용중인 Python 버전에 관계없이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e5cd337a0a94a79ca9bf0c7b1bbc3dbf9f0f4355" translate="yes" xml:space="preserve">
          <source>To understand why, you need to know two things.</source>
          <target state="translated">이유를 이해하려면 두 가지를 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="217ae68a57b281448452f9625b7db65c0e37b492" translate="yes" xml:space="preserve">
          <source>Tools and Utilities</source>
          <target state="translated">도구 및 유틸리티</target>
        </trans-unit>
        <trans-unit id="db3006577395a2fbdf588f1767d5cce77ff37b7b" translate="yes" xml:space="preserve">
          <source>Top-level exports</source>
          <target state="translated">최상위 수출</target>
        </trans-unit>
        <trans-unit id="dbd7a0da99ea93e9335a316b4f8d8307c0645cc6" translate="yes" xml:space="preserve">
          <source>Towards the end of a call to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;, after the main task and all system tasks have exited, the system nursery becomes closed. At this point, new calls to &lt;a href=&quot;#trio.lowlevel.spawn_system_task&quot;&gt;&lt;code&gt;spawn_system_task()&lt;/code&gt;&lt;/a&gt; will raise &lt;code&gt;RuntimeError(&quot;Nursery
is closed to new arrivals&quot;)&lt;/code&gt; instead of creating a system task. It&amp;rsquo;s possible to encounter this state either in a &lt;code&gt;finally&lt;/code&gt; block in an async generator, or in a callback passed to &lt;a href=&quot;#trio.lowlevel.TrioToken.run_sync_soon&quot;&gt;&lt;code&gt;TrioToken.run_sync_soon()&lt;/code&gt;&lt;/a&gt; at the right moment.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 에 대한 호출이 끝날 무렵, 기본 작업과 모든 시스템 작업이 종료 된 후 시스템 nursery가 닫힙니다. 이 시점에서 &lt;a href=&quot;#trio.lowlevel.spawn_system_task&quot;&gt; &lt;code&gt;spawn_system_task()&lt;/code&gt; &lt;/a&gt; 대한 새로운 호출 은 시스템 작업을 생성하는 대신 &lt;code&gt;RuntimeError(&quot;Nursery is closed to new arrivals&quot;)&lt;/code&gt; 를 발생시킵니다. 비동기 생성기 의 &lt;code&gt;finally&lt;/code&gt; 블록 또는 적절한 순간 에 &lt;a href=&quot;#trio.lowlevel.TrioToken.run_sync_soon&quot;&gt; &lt;code&gt;TrioToken.run_sync_soon()&lt;/code&gt; &lt;/a&gt; 에 전달 된 콜백 에서이 상태가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6b456d043430ca913d9174bb8cfc55ab351d5d3" translate="yes" xml:space="preserve">
          <source>Trio</source>
          <target state="translated">Trio</target>
        </trans-unit>
        <trans-unit id="e10ab5c8f9662b6d401524134931ffbe3ea711b3" translate="yes" xml:space="preserve">
          <source>Trio 0.1.0 (2017-03-10)</source>
          <target state="translated">트리오 0.1.0 (2017-03-10)</target>
        </trans-unit>
        <trans-unit id="74fa2c2fe4c26140ed7ec69a5902a700dc2e2288" translate="yes" xml:space="preserve">
          <source>Trio 0.10.0 (2019-01-07)</source>
          <target state="translated">트리오 0.10.0 (2019-01-07)</target>
        </trans-unit>
        <trans-unit id="69e4642ca3df5dc9d3712b14dba73397b158dcb9" translate="yes" xml:space="preserve">
          <source>Trio 0.11.0 (2019-02-09)</source>
          <target state="translated">트리오 0.11.0 (2019-02-09)</target>
        </trans-unit>
        <trans-unit id="6c74db81639abc94a5e78afb9914315a7d2e61e4" translate="yes" xml:space="preserve">
          <source>Trio 0.12.0 (2019-07-31)</source>
          <target state="translated">트리오 0.12.0 (2019-07-31)</target>
        </trans-unit>
        <trans-unit id="756c5475a93f96aff35a02be8296ff76a5362ef7" translate="yes" xml:space="preserve">
          <source>Trio 0.12.1 (2019-08-01)</source>
          <target state="translated">트리오 0.12.1 (2019-08-01)</target>
        </trans-unit>
        <trans-unit id="e489cea779a3257497b38f570ae0c2d90697d774" translate="yes" xml:space="preserve">
          <source>Trio 0.13.0 (2019-11-02)</source>
          <target state="translated">Trio 0.13.0 (2019-11-02)</target>
        </trans-unit>
        <trans-unit id="e9249af56a32c9aa8c9fbb6999729e77ac23c536" translate="yes" xml:space="preserve">
          <source>Trio 0.14.0 (2020-04-27)</source>
          <target state="translated">Trio 0.14.0 (2020-04-27)</target>
        </trans-unit>
        <trans-unit id="abbd172ed7b62ab0dcf4703f9adad15f8dd1ec57" translate="yes" xml:space="preserve">
          <source>Trio 0.15.0 (2020-05-19)</source>
          <target state="translated">Trio 0.15.0 (2020-05-19)</target>
        </trans-unit>
        <trans-unit id="81aee605bc36211978f52af6b146f36577e39578" translate="yes" xml:space="preserve">
          <source>Trio 0.15.1 (2020-05-22)</source>
          <target state="translated">Trio 0.15.1 (2020-05-22)</target>
        </trans-unit>
        <trans-unit id="57e4e921b569f538a8aace5a4dee68c30a6c8011" translate="yes" xml:space="preserve">
          <source>Trio 0.16.0 (2020-06-10)</source>
          <target state="translated">Trio 0.16.0 (2020-06-10)</target>
        </trans-unit>
        <trans-unit id="3c28dea641c508e81f985e2898c1d90ce3d4f7c5" translate="yes" xml:space="preserve">
          <source>Trio 0.17.0 (2020-09-15)</source>
          <target state="translated">Trio 0.17.0 (2020-09-15)</target>
        </trans-unit>
        <trans-unit id="e64ab757fc114329e217f19fe148df4c7478412f" translate="yes" xml:space="preserve">
          <source>Trio 0.18.0 (2021-01-11)</source>
          <target state="translated">Trio 0.18.0 (2021-01-11)</target>
        </trans-unit>
        <trans-unit id="b6e5fe42049ac788a8f0350bb9328d46cf841544" translate="yes" xml:space="preserve">
          <source>Trio 0.2.0 (2017-12-06)</source>
          <target state="translated">트리오 0.2.0 (2017-12-06)</target>
        </trans-unit>
        <trans-unit id="b3fb820f535b0b0931f359e1e3feac669d9d79ff" translate="yes" xml:space="preserve">
          <source>Trio 0.3.0 (2017-12-28)</source>
          <target state="translated">트리오 0.3.0 (2017-12-28)</target>
        </trans-unit>
        <trans-unit id="9ec0f7f2eed5ceef8d882523ec63a0688d3dee74" translate="yes" xml:space="preserve">
          <source>Trio 0.4.0 (2018-04-10)</source>
          <target state="translated">트리오 0.4.0 (2018-04-10)</target>
        </trans-unit>
        <trans-unit id="a5e71a7a8c48bb819251fac725eb027372565fc6" translate="yes" xml:space="preserve">
          <source>Trio 0.5.0 (2018-07-20)</source>
          <target state="translated">트리오 0.5.0 (2018-07-20)</target>
        </trans-unit>
        <trans-unit id="3c47332ee2a79b093d8020cb914bb8ee16c6946d" translate="yes" xml:space="preserve">
          <source>Trio 0.6.0 (2018-08-13)</source>
          <target state="translated">트리오 0.6.0 (2018-08-13)</target>
        </trans-unit>
        <trans-unit id="0b496cd9f24b90ed762a98cc2aaf2290bd868eda" translate="yes" xml:space="preserve">
          <source>Trio 0.7.0 (2018-09-03)</source>
          <target state="translated">트리오 0.7.0 (2018-09-03)</target>
        </trans-unit>
        <trans-unit id="9d34c423781f712340e29d42f4ebc34888e6c599" translate="yes" xml:space="preserve">
          <source>Trio 0.8.0 (2018-10-01)</source>
          <target state="translated">트리오 0.8.0 (2018-10-01)</target>
        </trans-unit>
        <trans-unit id="8f6bc445719269e2c3dc52746939c55d83476611" translate="yes" xml:space="preserve">
          <source>Trio 0.9.0 (2018-10-12)</source>
          <target state="translated">트리오 0.9.0 (2018-10-12)</target>
        </trans-unit>
        <trans-unit id="0adbdcfaf558ea55b373e281d4d8e2a52d952289" translate="yes" xml:space="preserve">
          <source>Trio also provides several convenience functions for the common situation of just wanting to impose a timeout on some code:</source>
          <target state="translated">또한 Trio는 일부 코드에 타임 아웃을 적용하려는 일반적인 상황에 대한 여러 편의 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="63f1831f4b1f1da694680c3ac049ae563afd8ec4" translate="yes" xml:space="preserve">
          <source>Trio also provides some functions to help you test your custom stream implementations:</source>
          <target state="translated">또한 Trio는 사용자 지정 스트림 구현을 테스트하는 데 도움이되는 몇 가지 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f764514bda33ba237239ba96fe50aba14b67bee6" translate="yes" xml:space="preserve">
          <source>Trio also provides some specialized functions for testing completely &lt;strong&gt;un&lt;/strong&gt;buffered streams: &lt;a href=&quot;#trio.testing.lockstep_stream_one_way_pair&quot;&gt;&lt;code&gt;lockstep_stream_one_way_pair()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.testing.lockstep_stream_pair&quot;&gt;&lt;code&gt;lockstep_stream_pair()&lt;/code&gt;&lt;/a&gt;. These aren&amp;rsquo;t customizable, but they do exhibit an extreme kind of behavior that&amp;rsquo;s good at catching out edge cases in protocol implementations.</source>
          <target state="translated">또한 Trio는 완전히 버퍼링 &lt;strong&gt;되지 않은&lt;/strong&gt; 스트림 을 테스트하기위한 몇 가지 특수 함수 인 &lt;a href=&quot;#trio.testing.lockstep_stream_one_way_pair&quot;&gt; &lt;code&gt;lockstep_stream_one_way_pair()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.testing.lockstep_stream_pair&quot;&gt; &lt;code&gt;lockstep_stream_pair()&lt;/code&gt; &lt;/a&gt; 합니다. 이것들은 커스터마이징이 가능하지 않지만 프로토콜 구현에서 우연한 사례를 포착하는 데 좋은 극단적 인 종류의 행동을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d7707add294b6ac0bac54c516a3af471b6c78a17" translate="yes" xml:space="preserve">
          <source>Trio currently provides a generic helper for writing servers that listen for connections using one or more &lt;a href=&quot;#trio.abc.Listener&quot;&gt;&lt;code&gt;Listener&lt;/code&gt;&lt;/a&gt;s, and a generic utility class for working with streams. And if you want to test code that&amp;rsquo;s written against the streams interface, you should also check out &lt;a href=&quot;reference-testing#testing-streams&quot;&gt;Streams&lt;/a&gt; in &lt;a href=&quot;reference-testing#module-trio.testing&quot;&gt;&lt;code&gt;trio.testing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Trio는 현재 하나 이상의 &lt;a href=&quot;#trio.abc.Listener&quot;&gt; &lt;code&gt;Listener&lt;/code&gt; &lt;/a&gt; 사용하여 연결을 수신하는 서버를 작성하기위한 일반 헬퍼 및 스트림 작업을위한 일반 유틸리티 클래스를 제공합니다. 당신이 스트림 인터페이스에 쓰여 테스트 코드를 원한다면, 당신은 또한 체크 아웃해야 &lt;a href=&quot;reference-testing#testing-streams&quot;&gt;스트림을&lt;/a&gt; 에 &lt;a href=&quot;reference-testing#module-trio.testing&quot;&gt; &lt;code&gt;trio.testing&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1bb137836035175c111f8a48b35d84efdbd8248f" translate="yes" xml:space="preserve">
          <source>Trio doesn&amp;rsquo;t assign this variable any meaning, except that it sets it to &lt;code&gt;None&lt;/code&gt; whenever a task is rescheduled. It can be used to share data between the different tasks involved in putting a task to sleep and then waking it up again. (See &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">Trio는 작업이 다시 예약 될 때마다이 변수를 &lt;code&gt;None&lt;/code&gt; 설정한다는 점을 제외하고이 변수에 어떤 의미도 지정하지 않습니다 . 작업을 휴면 상태로 설정하고 다시 깨우는 데 관련된 여러 작업간에 데이터를 공유하는 데 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;#trio.hazmat.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5a9cb290f7c7c4779bc09cea32d0d924b703fb42" translate="yes" xml:space="preserve">
          <source>Trio doesn&amp;rsquo;t assign this variable any meaning, except that it sets it to &lt;code&gt;None&lt;/code&gt; whenever a task is rescheduled. It can be used to share data between the different tasks involved in putting a task to sleep and then waking it up again. (See &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt;&lt;code&gt;wait_task_rescheduled()&lt;/code&gt;&lt;/a&gt; for details.)</source>
          <target state="translated">Trio는 작업이 다시 예약 될 때마다 &lt;code&gt;None&lt;/code&gt; 으로 설정한다는 점을 제외하고는이 변수에 어떤 의미도 할당하지 않습니다 . 작업을 절전 모드로 전환 한 다음 다시 깨우는 데 관련된 여러 작업간에 데이터를 공유하는 데 사용할 수 있습니다. (자세한 내용은 &lt;a href=&quot;#trio.lowlevel.wait_task_rescheduled&quot;&gt; &lt;code&gt;wait_task_rescheduled()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="3c621c59b80ace2edb624e5e2050d6d2698da42c" translate="yes" xml:space="preserve">
          <source>Trio doesn&amp;rsquo;t itself provide a virtual in-memory network implementation for testing &amp;ndash; but &lt;a href=&quot;reference-io#module-trio.socket&quot;&gt;&lt;code&gt;trio.socket&lt;/code&gt;&lt;/a&gt; module does provide the hooks you need to write your own! And if you&amp;rsquo;re interested in helping implement a reusable virtual network for testing, then &lt;a href=&quot;https://github.com/python-trio/trio/issues/170&quot;&gt;please get in touch&lt;/a&gt;.</source>
          <target state="translated">Trio 자체는 테스트를위한 가상 메모리 내 네트워크 구현을 제공하지는 않지만 &lt;a href=&quot;reference-io#module-trio.socket&quot;&gt; &lt;code&gt;trio.socket&lt;/code&gt; &lt;/a&gt; 모듈은 자체 작성에 필요한 후크를 제공합니다! 테스트를 위해 재사용 가능한 가상 네트워크를 구현하는 데 관심이 &lt;a href=&quot;https://github.com/python-trio/trio/issues/170&quot;&gt;있으시면 연락하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a89d8834bcdebd9f608acfe93a7bb122db53b5f9" translate="yes" xml:space="preserve">
          <source>Trio has a rich, composable system for cancelling work, either explicitly or when a timeout expires.</source>
          <target state="translated">Trio에는 명시 적으로 또는 시간 초과가 만료 될 때 작업을 취소 할 수있는 풍부하고 구성 가능한 시스템이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3224a6971f04b494f9517ecb8aea8b567e1c0a9e" translate="yes" xml:space="preserve">
          <source>Trio intentionally DOES NOT include some obsolete, redundant, or broken features:</source>
          <target state="translated">Trio는 일부 쓸모 없거나 중복되거나 파손 된 기능을 의도적으로 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7fb99857ba430551418d478736812a8a2d129e38" translate="yes" xml:space="preserve">
          <source>Trio provides SSL/TLS support based on the standard library &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#module-ssl&quot;&gt;&lt;code&gt;ssl&lt;/code&gt;&lt;/a&gt; module. Trio&amp;rsquo;s &lt;a href=&quot;#trio.SSLStream&quot;&gt;&lt;code&gt;SSLStream&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.SSLListener&quot;&gt;&lt;code&gt;SSLListener&lt;/code&gt;&lt;/a&gt; take their configuration from a &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt;&lt;code&gt;ssl.SSLContext&lt;/code&gt;&lt;/a&gt;, which you can create using &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt;&lt;code&gt;ssl.create_default_context()&lt;/code&gt;&lt;/a&gt; and customize using the other constants and functions in the &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#module-ssl&quot;&gt;&lt;code&gt;ssl&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Trio는 표준 라이브러리 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#module-ssl&quot;&gt; &lt;code&gt;ssl&lt;/code&gt; &lt;/a&gt; 모듈을 기반으로 SSL / TLS 지원을 제공합니다 . Trio의 &lt;a href=&quot;#trio.SSLStream&quot;&gt; &lt;code&gt;SSLStream&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.SSLListener&quot;&gt; &lt;code&gt;SSLListener&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.SSLContext&quot;&gt; &lt;code&gt;ssl.SSLContext&lt;/code&gt; &lt;/a&gt; 에서 구성을 가져 옵니다 . &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#ssl.create_default_context&quot;&gt; &lt;code&gt;ssl.create_default_context()&lt;/code&gt; &lt;/a&gt; 사용하여 작성 하고 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#module-ssl&quot;&gt; &lt;code&gt;ssl&lt;/code&gt; &lt;/a&gt; 모듈 의 다른 상수 및 함수를 사용하여 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d817001a39f23d2d7c8a88010d0511c25864d40c" translate="yes" xml:space="preserve">
          <source>Trio provides a set of abstract base classes that define a standard interface for unidirectional and bidirectional byte streams.</source>
          <target state="translated">Trio는 단방향 및 양방향 바이트 스트림에 대한 표준 인터페이스를 정의하는 추상 기본 클래스 세트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8e040b74b4c87ec08a16ce1813ad188d5335f33d" translate="yes" xml:space="preserve">
          <source>Trio provides a standard set of synchronization and inter-task communication primitives. These objects&amp;rsquo; APIs are generally modelled off of the analogous classes in the standard library, but with some differences.</source>
          <target state="translated">Trio는 표준 동기화 및 작업 간 통신 프리미티브 세트를 제공합니다. 이러한 객체의 API는 일반적으로 표준 라이브러리의 유사한 클래스에서 모델링되지만 약간의 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e01d4ed6a91a5aceea04193c03b358b081f49eb7" translate="yes" xml:space="preserve">
          <source>Trio provides built-in facilities for performing asynchronous filesystem operations like reading or renaming a file. Generally, we recommend that you use these instead of Python&amp;rsquo;s normal synchronous file APIs. But the tradeoffs here are somewhat subtle: sometimes people switch to async I/O, and then they&amp;rsquo;re surprised and confused when they find it doesn&amp;rsquo;t speed up their program. The next section explains the theory behind async file I/O, to help you better understand your code&amp;rsquo;s behavior. Or, if you just want to get started, you can &lt;a href=&quot;#async-file-io-overview&quot;&gt;jump down to the API overview&lt;/a&gt;.</source>
          <target state="translated">Trio는 파일 읽기 또는 이름 변경과 같은 비동기 파일 시스템 작업을 수행하기위한 내장 기능을 제공합니다. 일반적으로 Python의 일반 동기 파일 API 대신 이러한 API를 사용하는 것이 좋습니다. 그러나 여기에서 장단점은 다소 미묘합니다. 때때로 사람들은 비동기 I / O로 전환 한 다음 프로그램 속도를 높이 지 못한다는 사실에 놀라고 혼란스러워합니다. 다음 섹션에서는 코드 동작을 더 잘 이해할 수 있도록 비동기 파일 I / O의 이론을 설명합니다. 또는 시작하려는 경우 &lt;a href=&quot;#async-file-io-overview&quot;&gt;API 개요로 이동할&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74425cde00c0b01b295243623ba0bba1679d9dc5" translate="yes" xml:space="preserve">
          <source>Trio provides built-in facilities for performing asynchronous filesystem operations like reading or renaming a file. Generally, we recommend that you use these instead of Python&amp;rsquo;s normal synchronous file APIs. But the tradeoffs here are somewhat subtle: sometimes people switch to async I/O, and then they&amp;rsquo;re surprised and confused when they find it doesn&amp;rsquo;t speed up their program. The next section explains the theory behind async file I/O, to help you better understand your code&amp;rsquo;s behavior. Or, if you just want to get started, you can &lt;a href=&quot;ref:async-file-io-overview&quot;&gt;jump down to the API overview&lt;/a&gt;.</source>
          <target state="translated">Trio는 파일 읽기 또는 이름 바꾸기와 같은 비동기 파일 시스템 작업을 수행하기위한 내장 기능을 제공합니다. 일반적으로, 파이썬의 일반 동기 파일 API 대신 이들을 사용하는 것이 좋습니다. 그러나 여기서의 절충점은 다소 미묘합니다. 때로는 사람들이 비동기 I / O로 전환 한 다음 프로그램 속도를 높이 지 못한다는 사실에 놀랐습니다. 다음 섹션에서는 코드의 동작을보다 잘 이해할 수 있도록 비동기 파일 I / O의 이론을 설명합니다. 또는 시작하려는 경우 &lt;a href=&quot;ref:async-file-io-overview&quot;&gt;API 개요로 이동할&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d95788f65d0c3c8483b4904e8ba1a027a20a92c4" translate="yes" xml:space="preserve">
          <source>Trio provides support for spawning other programs as subprocesses, communicating with them via pipes, sending them signals, and waiting for them to exit. The interface for doing so consists of two layers:</source>
          <target state="translated">Trio는 다른 프로그램을 하위 프로세스로 생성하고 파이프를 통해 통신하고 신호를 보내고 종료 될 때까지 지원합니다. 이를위한 인터페이스는 두 개의 계층으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="e3e4c4f0590113b206fe27748965cb6ce85a583a" translate="yes" xml:space="preserve">
          <source>Trio socket objects are overall very similar to the &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket-objects&quot;&gt;standard library socket objects&lt;/a&gt;, with a few important differences:</source>
          <target state="translated">Trio 소켓 객체는 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket-objects&quot;&gt;표준 라이브러리 소켓 객체&lt;/a&gt; 와 전반적으로 매우 유사하지만 몇 가지 중요한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="84bf9c00f2f5bbffc7ee9b46d763db2cc451107c" translate="yes" xml:space="preserve">
          <source>Trio supports async generators, with some caveats described in this section.</source>
          <target state="translated">Trio는이 섹션에 설명 된 몇 가지주의 사항과 함께 비동기 생성기를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="3bb057fa930f31cd5b5ad52664f8b9bd7e4a82d9" translate="yes" xml:space="preserve">
          <source>Trio tokens</source>
          <target state="translated">트리오 토큰</target>
        </trans-unit>
        <trans-unit id="5d408b00bf8df0f0790a83ccf1901d19c622725e" translate="yes" xml:space="preserve">
          <source>Trio tries hard to provide useful hooks for debugging and instrumentation. Some are documented above (the nursery introspection attributes, &lt;a href=&quot;reference-core#trio.Lock.statistics&quot;&gt;&lt;code&gt;trio.Lock.statistics()&lt;/code&gt;&lt;/a&gt;, etc.). Here are some more.</source>
          <target state="translated">Trio는 디버깅 및 계측에 유용한 후크를 제공하려고 노력합니다. 일부는 위에 설명되어 있습니다 (보육원 내성 속성, &lt;a href=&quot;reference-core#trio.Lock.statistics&quot;&gt; &lt;code&gt;trio.Lock.statistics()&lt;/code&gt; &lt;/a&gt; 등). 몇 가지 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="a095b9420b975351418baa59d47d28cab0b88e9d" translate="yes" xml:space="preserve">
          <source>Trio was built from the ground up to take advantage of the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0492/&quot;&gt;latest Python features&lt;/a&gt;, and draws inspiration from &lt;a href=&quot;https://github.com/python-trio/trio/wiki/Reading-list&quot;&gt;many sources&lt;/a&gt;, in particular Dave Beazley&amp;rsquo;s &lt;a href=&quot;https://curio.readthedocs.io/&quot;&gt;Curio&lt;/a&gt;. The resulting design is radically simpler than older competitors like &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html&quot;&gt;asyncio&lt;/a&gt; and &lt;a href=&quot;https://twistedmatrix.com/&quot;&gt;Twisted&lt;/a&gt;, yet just as capable. Trio is the Python I/O library I always wanted; I find it makes building I/O-oriented programs easier, less error-prone, and just plain more fun. Perhaps you&amp;rsquo;ll find the same.</source>
          <target state="translated">Trio는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0492/&quot;&gt;최신 Python 기능&lt;/a&gt; 을 활용하기 위해 처음부터 구축되었으며, 특히 Dave Beazley의 &lt;a href=&quot;https://curio.readthedocs.io/&quot;&gt;Curio&lt;/a&gt; 와 같은 &lt;a href=&quot;https://github.com/python-trio/trio/wiki/Reading-list&quot;&gt;여러 소스&lt;/a&gt; 에서 영감을 얻습니다 . 결과 디자인은 &lt;a href=&quot;https://docs.python.org/3/library/asyncio.html&quot;&gt;asyncio&lt;/a&gt; 및 &lt;a href=&quot;https://twistedmatrix.com/&quot;&gt;Twisted&lt;/a&gt; 와 같은 구형 경쟁사보다 훨씬 간단 하지만 가능합니다. Trio는 항상 원했던 Python I / O 라이브러리입니다. 필자는 I / O 지향 프로그램을보다 쉽고 오류 발생이 적으며 평범한 재미로 만듭니다. 아마도 당신은 같은 것을 찾을 것입니다.</target>
        </trans-unit>
        <trans-unit id="c846abd10c13fb3992cae8ffb8e6074c68f407e6" translate="yes" xml:space="preserve">
          <source>Trio&amp;rsquo;s answer is that it raises a &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt; object. This is a special exception which encapsulates multiple exception objects &amp;ndash; either regular exceptions or nested &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt;s. To make these easier to work with, Trio installs a custom &lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.excepthook&quot;&gt;&lt;code&gt;sys.excepthook&lt;/code&gt;&lt;/a&gt; that knows how to print nice tracebacks for unhandled &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt;s, and it also provides some helpful utilities like &lt;a href=&quot;#trio.MultiError.catch&quot;&gt;&lt;code&gt;MultiError.catch()&lt;/code&gt;&lt;/a&gt;, which allows you to catch &amp;ldquo;part of&amp;rdquo; a &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Trio의 대답은 &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; 객체를 발생시키는 것입니다. 이것은 일반적인 예외 또는 중첩 된 &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; 와 같은 여러 예외 개체를 캡슐화하는 특수 예외입니다 . 와 작업에이 쉽게하기 위해, 트리오는 사용자 정의 설치 &lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.excepthook&quot;&gt; &lt;code&gt;sys.excepthook&lt;/code&gt; &lt;/a&gt; 처리되지 않은에 대한 좋은 역 추적 인쇄하는 방법을 알고 &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; 들, 또한 같은 몇 가지 유용한 유틸리티를 제공합니다 &lt;a href=&quot;#trio.MultiError.catch&quot;&gt; &lt;code&gt;MultiError.catch()&lt;/code&gt; &lt;/a&gt; 는 &quot;부분을&quot;잡을 수 있습니다, &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d2b9708cc5b4a0aa94a8cbf018536b856ae4ed6" translate="yes" xml:space="preserve">
          <source>Trio&amp;rsquo;s asynchronous file objects have an interface that automatically adapts to the object being wrapped. Intuitively, you can mostly treat them like a regular &lt;a href=&quot;https://docs.python.org/3/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;, except adding an &lt;code&gt;await&lt;/code&gt; in front of any of methods that do I/O. The definition of &lt;a href=&quot;https://docs.python.org/3/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt; is a little vague in Python though, so here are the details:</source>
          <target state="translated">Trio의 비동기 파일 객체에는 줄 바꿈 된 객체에 자동으로 적응하는 인터페이스가 있습니다. 직관적으로, I / O를 수행하는 메소드 앞에 &lt;code&gt;await&lt;/code&gt; 를 추가하는 것을 제외하고 는 대부분 &lt;a href=&quot;https://docs.python.org/3/glossary.html#term-file-object&quot;&gt;파일을&lt;/a&gt; 일반 파일 오브젝트 처럼 취급 할 수 있습니다 . 파이썬 에서는 &lt;a href=&quot;https://docs.python.org/3/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 의 정의가 약간 모호하므로 자세한 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e1395e9cde88f70c434acca97212f29b2fa46091" translate="yes" xml:space="preserve">
          <source>Trio&amp;rsquo;s core functionality</source>
          <target state="translated">트리오의 핵심 기능</target>
        </trans-unit>
        <trans-unit id="f97e2b82c90599d9b44281129e282e3a9dda83cd" translate="yes" xml:space="preserve">
          <source>Trio&amp;rsquo;s handling of control-C is designed to balance usability and safety. On the one hand, there are sensitive regions (like the core scheduling loop) where it&amp;rsquo;s simply impossible to handle arbitrary &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; exceptions while maintaining our core correctness invariants. On the other, if the user accidentally writes an infinite loop, we do want to be able to break out of that. Our solution is to install a default signal handler which checks whether it&amp;rsquo;s safe to raise &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; at the place where the signal is received. If so, then we do; otherwise, we schedule a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; to be delivered to the main task at the next available opportunity (similar to how &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; is delivered).</source>
          <target state="translated">Trio의 control-C 취급은 사용 성과 안전의 균형을 유지하도록 설계되었습니다. 한편으로는 핵심 스케줄링 불변성을 유지하면서 임의의 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 예외 를 처리하는 것이 불가능한 민감한 영역 (예 : 코어 스케줄링 루프)이 있습니다 . 다른 한편으로, 사용자가 실수로 무한 루프를 작성한다면, 우리는 그 루프에서 벗어날 수 있기를 원합니다. 우리의 해결책은 신호가 수신되는 장소에서 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 를 발생시키는 것이 안전한지 확인하는 기본 신호 처리기를 설치하는 것 입니다. 그렇다면 우리는 그렇게합니다. 그렇지 않으면, 다음에 이용 가능한 기회 ( &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 가 전달되는 방법과 유사)에서 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 가 기본 태스크로 전달되도록 스케줄합니다 .</target>
        </trans-unit>
        <trans-unit id="e4de41bd04af3ba5cdbb7231b08e1a1e6c3fe88c" translate="yes" xml:space="preserve">
          <source>Trio&amp;rsquo;s philosophy about managing worker threads</source>
          <target state="translated">작업자 스레드 관리에 대한 Trio의 철학</target>
        </trans-unit>
        <trans-unit id="0a05358999edb18564ef080ed20cf4c015b3b0fb" translate="yes" xml:space="preserve">
          <source>Trio&amp;rsquo;s solution to this problem is to split worker thread management into two layers. The lower layer is responsible for taking blocking I/O jobs and arranging for them to run immediately on some worker thread. It takes care of solving the tricky concurrency problems involved in managing threads and is responsible for optimizations like re-using threads, but has no admission control policy: if you give it 100,000 jobs, it will spawn 100,000 threads. The upper layer is responsible for providing the policy to make sure that this doesn&amp;rsquo;t happen &amp;ndash; but since it &lt;em&gt;only&lt;/em&gt; has to worry about policy, it can be much simpler. In fact, all there is to it is the &lt;code&gt;limiter=&lt;/code&gt; argument passed to &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt;&lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt;&lt;/a&gt;. This defaults to a global &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; object, which gives us the classic fixed-size thread pool behavior. (See &lt;a href=&quot;#trio.to_thread.current_default_thread_limiter&quot;&gt;&lt;code&gt;trio.to_thread.current_default_thread_limiter()&lt;/code&gt;&lt;/a&gt;.) But if you want to use &amp;ldquo;separate pools&amp;rdquo; for type A jobs and type B jobs, then it&amp;rsquo;s just a matter of creating two separate &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt;&lt;code&gt;CapacityLimiter&lt;/code&gt;&lt;/a&gt; objects and passing them in when running these jobs. Or here&amp;rsquo;s an example of defining a custom policy that respects the global thread limit, while making sure that no individual user can use more than 3 threads at a time:</source>
          <target state="translated">이 문제에 대한 Trio의 솔루션은 작업자 스레드 관리를 두 계층으로 나누는 것입니다. 하위 계층은 I / O 작업을 차단하고 일부 작업자 스레드에서 즉시 실행되도록 구성합니다. 스레드 관리와 관련된 까다로운 동시성 문제를 해결하고 스레드 재사용과 같은 최적화를 담당하지만 승인 제어 정책은 없습니다. 10 만 개의 작업을 제공하면 10 만 개의 스레드가 생성됩니다. 상위 계층은 이러한 상황이 발생하지 않도록 정책을 제공해야하지만 정책에 &lt;em&gt;대해서만&lt;/em&gt; 걱정하면되므로 훨씬 간단 할 수 있습니다. 실제로 &lt;a href=&quot;#trio.to_thread.run_sync&quot;&gt; &lt;code&gt;trio.to_thread.run_sync()&lt;/code&gt; &lt;/a&gt; 전달 된 &lt;code&gt;limiter=&lt;/code&gt; 인수 만 있으면 됩니다. 기본적으로 전역 &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt;객체로 고정 된 크기의 스레드 풀 동작을 제공합니다. ( &lt;a href=&quot;#trio.to_thread.current_default_thread_limiter&quot;&gt; &lt;code&gt;trio.to_thread.current_default_thread_limiter()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .) 유형 A 작업 및 유형 B 작업에 &quot;별도 풀&quot;을 사용하려면 두 개의 개별 &lt;a href=&quot;#trio.CapacityLimiter&quot;&gt; &lt;code&gt;CapacityLimiter&lt;/code&gt; &lt;/a&gt; 객체 를 생성 하고 이러한 작업을 실행할 때 전달하면됩니다. 또는 다음은 전체 스레드 제한을 준수하는 사용자 지정 정책을 정의하는 예이며 한 번에 개별 사용자가 3 개 이상의 스레드를 사용할 수 없도록합니다.</target>
        </trans-unit>
        <trans-unit id="6bc59e1ec96bc7a2423dbce69311bcfd506df149" translate="yes" xml:space="preserve">
          <source>Trio's friendly, yet comprehensive, manual:</source>
          <target state="translated">Trio의 친절하면서도 포괄적 인 매뉴얼 :</target>
        </trans-unit>
        <trans-unit id="5c8cee31570dc25a817cf56add6f07570a783115" translate="yes" xml:space="preserve">
          <source>Trio/Asyncio Interoperability</source>
          <target state="translated">Trio / Asyncio 상호 운용성</target>
        </trans-unit>
        <trans-unit id="225f97c8e66d76df4b30a947feaf0534521b0ead" translate="yes" xml:space="preserve">
          <source>Trio: a friendly Python library for async concurrency and I/O</source>
          <target state="translated">트리오 : 비동기 동시성 및 I / O를위한 친숙한 Python 라이브러리</target>
        </trans-unit>
        <trans-unit id="6f3b7a2bab0ca1f9fc7290da3cd87c32228ed36b" translate="yes" xml:space="preserve">
          <source>Trio’s core functionality</source>
          <target state="translated">트리오의 핵심 기능</target>
        </trans-unit>
        <trans-unit id="decf96be2aaef9ab02814ffa8c9f5b6de6f3b8d6" translate="yes" xml:space="preserve">
          <source>True if it successfully transferred some data, or False if there was no data to transfer.</source>
          <target state="translated">일부 데이터를 성공적으로 전송 한 경우 True, 전송할 데이터가없는 경우 False입니다.</target>
        </trans-unit>
        <trans-unit id="e1aaa899e304fc2f5d29d6e66a76d55ca76bd39e" translate="yes" xml:space="preserve">
          <source>True if protection is enabled, and False otherwise.</source>
          <target state="translated">보호가 활성화되어 있으면 true이고, 그렇지 않으면 False입니다.</target>
        </trans-unit>
        <trans-unit id="93add99f412693bb50177e85ca6a9d4948b325c9" translate="yes" xml:space="preserve">
          <source>True if successful, False otherwise.</source>
          <target state="translated">성공하면 True, 그렇지 않으면 False</target>
        </trans-unit>
        <trans-unit id="5d3e9a7a494f653bcacd93456806581953a79027" translate="yes" xml:space="preserve">
          <source>True if the lock is held, False otherwise.</source>
          <target state="translated">잠금이 유지되면 true이고, 그렇지 않으면 False입니다.</target>
        </trans-unit>
        <trans-unit id="6abc79262de514fd9235a1f0c1f891c91c282949" translate="yes" xml:space="preserve">
          <source>True if the path is absolute (has both a root and, if applicable, a drive).</source>
          <target state="translated">경로가 절대적이면 참 (루트와 해당되는 경우 드라이브)을 모두 갖습니다.</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="8a1c6f031eca837815e374433e41a167d90dbfd8" translate="yes" xml:space="preserve">
          <source>Tutorial and reference manual: &lt;a href=&quot;https://trio.readthedocs.io&quot;&gt;https://trio.readthedocs.io&lt;/a&gt;</source>
          <target state="translated">튜토리얼 및 참조 매뉴얼 : &lt;a href=&quot;https://trio.readthedocs.io&quot;&gt;https://trio.readthedocs.io&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="77dea2038e0265d1f2267dbda249ea9a80220f2c" translate="yes" xml:space="preserve">
          <source>Typically used together with &lt;a href=&quot;#trio.hazmat.cancel_shielded_checkpoint&quot;&gt;&lt;code&gt;cancel_shielded_checkpoint()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#trio.hazmat.cancel_shielded_checkpoint&quot;&gt; &lt;code&gt;cancel_shielded_checkpoint()&lt;/code&gt; &lt;/a&gt; 와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c6a8397644a2a504c2f5bfe44f54b8ce6f92561d" translate="yes" xml:space="preserve">
          <source>Typically used together with &lt;a href=&quot;#trio.lowlevel.cancel_shielded_checkpoint&quot;&gt;&lt;code&gt;cancel_shielded_checkpoint()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#trio.lowlevel.cancel_shielded_checkpoint&quot;&gt; &lt;code&gt;cancel_shielded_checkpoint()&lt;/code&gt; &lt;/a&gt; 와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="fa6eb3e4b993dc224b732f0acd5cb818c8f6aedb" translate="yes" xml:space="preserve">
          <source>Unfortunately, if you get this error it also means that all bets are off &amp;ndash; Trio doesn&amp;rsquo;t know what is going on and its normal invariants may be void. (For example, we might have &amp;ldquo;lost track&amp;rdquo; of a task. Or lost track of all tasks.) Again, though, this shouldn&amp;rsquo;t happen.</source>
          <target state="translated">불행히도,이 오류가 발생하면 모든 베팅이 해제되었음을 의미합니다. Trio는 진행 상황을 알지 못하고 일반적인 불변 값이 무효화 될 수 있습니다. (예를 들어, 우리는 하나의 작업을 잃어 버렸거나 모든 작업을 잃어 버렸을 수도 있습니다.) 그러나 다시는 이런 일이 발생하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="ae8e0648b8830f351c3d504a2a43201c939ebb97" translate="yes" xml:space="preserve">
          <source>Universally available API</source>
          <target state="translated">범용 API</target>
        </trans-unit>
        <trans-unit id="709023972b44e1b7a1cb1b4210e5acf432bebfd7" translate="yes" xml:space="preserve">
          <source>Unix-specific API</source>
          <target state="translated">유닉스 전용 API</target>
        </trans-unit>
        <trans-unit id="40df8d956184a9840bf6af7b2386e17feff526a8" translate="yes" xml:space="preserve">
          <source>Unless you or your host loop register a handler for &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.SIGINT&quot;&gt;&lt;code&gt;signal.SIGINT&lt;/code&gt;&lt;/a&gt; before starting Trio (this is not common), then Trio will take over delivery of &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt;s. And since Trio can&amp;rsquo;t tell which host code is safe to interrupt, it will only deliver &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; into the Trio part of your code. This is fine if your program is set up to exit when the Trio part exits, because the &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; will propagate out of Trio and then trigger the shutdown of your host loop, which is just what you want.</source>
          <target state="translated">사용자 또는 호스트 루프가 Trio를 시작하기 전에 &lt;a href=&quot;https://docs.python.org/3/library/signal.html#signal.SIGINT&quot;&gt; &lt;code&gt;signal.SIGINT&lt;/code&gt; 에&lt;/a&gt; 대한 핸들러를 등록하지 않는 한 (일반적이지 않음) Trio가 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 전달을 인수 합니다. 그리고 Trio는 어떤 호스트 코드가 인터럽트해도 안전한지 알 수 없기 때문에 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 를 코드의 Trio 부분 에만 전달 합니다. 프로그램이 Trio 파트가 종료 될 때 종료되도록 설정되어 있으면 문제가 없습니다. &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 가 Trio 밖으로 전파 된 다음 원하는 호스트 루프의 종료를 트리거하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="bd09f3d61db7509d67bc57b83a3b0437c598cc43" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt;&lt;code&gt;socket.socket()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.socket.socket&quot;&gt;&lt;code&gt;trio.socket.socket()&lt;/code&gt;&lt;/a&gt; is a function, not a class; if you want to check whether an object is a Trio socket, use &lt;code&gt;isinstance(obj, trio.socket.SocketType)&lt;/code&gt;.</source>
          <target state="translated">달리 &lt;a href=&quot;https://docs.python.org/3/library/socket.html#socket.socket&quot;&gt; &lt;code&gt;socket.socket()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#trio.socket.socket&quot;&gt; &lt;code&gt;trio.socket.socket()&lt;/code&gt; &lt;/a&gt; 함수가 아닌 클래스이며; 객체가 Trio 소켓인지 확인하려면 &lt;code&gt;isinstance(obj, trio.socket.SocketType)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f85d0717922d015ead8412878c3437596480edc5" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event&quot;&gt;&lt;code&gt;threading.Event&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.Event&quot;&gt;&lt;code&gt;trio.Event&lt;/code&gt;&lt;/a&gt; has no &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; method. In Trio, once an &lt;a href=&quot;#trio.Event&quot;&gt;&lt;code&gt;Event&lt;/code&gt;&lt;/a&gt; has happened, it cannot un-happen. If you need to represent a series of events, consider creating a new &lt;a href=&quot;#trio.Event&quot;&gt;&lt;code&gt;Event&lt;/code&gt;&lt;/a&gt; object for each one (they&amp;rsquo;re cheap!), or other synchronization methods like &lt;a href=&quot;#channels&quot;&gt;channels&lt;/a&gt; or &lt;a href=&quot;reference-hazmat#trio.hazmat.ParkingLot&quot;&gt;&lt;code&gt;trio.hazmat.ParkingLot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">달리 &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event&quot;&gt; &lt;code&gt;threading.Event&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#trio.Event&quot;&gt; &lt;code&gt;trio.Event&lt;/code&gt; 는&lt;/a&gt; 전혀 없다 &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt; 방법. 트리오에서는 &lt;a href=&quot;#trio.Event&quot;&gt; &lt;code&gt;Event&lt;/code&gt; &lt;/a&gt; 가 발생하면 일어날 수 없습니다. 일련의 이벤트를 표현해야하는 경우 각각에 대해 새로운 &lt;a href=&quot;#trio.Event&quot;&gt; &lt;code&gt;Event&lt;/code&gt; &lt;/a&gt; 객체를 생성하거나 (싸다) &lt;a href=&quot;#channels&quot;&gt;채널&lt;/a&gt; 또는 &lt;a href=&quot;reference-hazmat#trio.hazmat.ParkingLot&quot;&gt; &lt;code&gt;trio.hazmat.ParkingLot&lt;/code&gt; &lt;/a&gt; 와 같은 다른 동기화 방법을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="127bfa4878966712bb206326fd8368f4fcdc500a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event&quot;&gt;&lt;code&gt;threading.Event&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#trio.Event&quot;&gt;&lt;code&gt;trio.Event&lt;/code&gt;&lt;/a&gt; has no &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event.clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; method. In Trio, once an &lt;a href=&quot;#trio.Event&quot;&gt;&lt;code&gt;Event&lt;/code&gt;&lt;/a&gt; has happened, it cannot un-happen. If you need to represent a series of events, consider creating a new &lt;a href=&quot;#trio.Event&quot;&gt;&lt;code&gt;Event&lt;/code&gt;&lt;/a&gt; object for each one (they&amp;rsquo;re cheap!), or other synchronization methods like &lt;a href=&quot;#channels&quot;&gt;channels&lt;/a&gt; or &lt;a href=&quot;reference-lowlevel#trio.lowlevel.ParkingLot&quot;&gt;&lt;code&gt;trio.lowlevel.ParkingLot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">달리 &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event&quot;&gt; &lt;code&gt;threading.Event&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#trio.Event&quot;&gt; &lt;code&gt;trio.Event&lt;/code&gt; 는&lt;/a&gt; 전혀 없다 &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Event.clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt; 방법. Trio에서는 &lt;a href=&quot;#trio.Event&quot;&gt; &lt;code&gt;Event&lt;/code&gt; &lt;/a&gt; 가 발생하면 해제 할 수 없습니다. 일련의 이벤트를 나타내야하는 경우 각 &lt;a href=&quot;#trio.Event&quot;&gt; &lt;code&gt;Event&lt;/code&gt; &lt;/a&gt; 에 대해 새 Event 객체를 생성하거나 (저렴합니다!) &lt;a href=&quot;#channels&quot;&gt;channels&lt;/a&gt; 또는 &lt;a href=&quot;reference-lowlevel#trio.lowlevel.ParkingLot&quot;&gt; &lt;code&gt;trio.lowlevel.ParkingLot&lt;/code&gt; &lt;/a&gt; 와 같은 다른 동기화 방법을 생성하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a64c6f580176add0dfe9ddbc8c9e0573a09c05cf" translate="yes" xml:space="preserve">
          <source>Unlike the standard library &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.returncode&quot;&gt;&lt;code&gt;subprocess.Popen.returncode&lt;/code&gt;&lt;/a&gt;, you don&amp;rsquo;t have to call &lt;a href=&quot;#trio.Process.poll&quot;&gt;&lt;code&gt;poll&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.Process.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; to update this attribute; it&amp;rsquo;s automatically updated as needed, and will always give you the latest information.</source>
          <target state="translated">표준 라이브러리 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#subprocess.Popen.returncode&quot;&gt; &lt;code&gt;subprocess.Popen.returncode&lt;/code&gt; &lt;/a&gt; 와 달리이 속성을 업데이트하기 위해 &lt;a href=&quot;#trio.Process.poll&quot;&gt; &lt;code&gt;poll&lt;/code&gt; &lt;/a&gt; 을 호출 하거나 &lt;a href=&quot;#trio.Process.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt; 필요가 없습니다 . 필요에 따라 자동으로 업데이트되며 항상 최신 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="781f24017834bea0e61621255956f2c4b4ca2937" translate="yes" xml:space="preserve">
          <source>Unpark all parked tasks.</source>
          <target state="translated">모든 주차 된 작업을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="88158b6332d62d5ea301e652e89647b83fdbf667" translate="yes" xml:space="preserve">
          <source>Unpark one or more tasks.</source>
          <target state="translated">하나 이상의 작업을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="2556360321b2463e70e36fbd809cecceda61b54b" translate="yes" xml:space="preserve">
          <source>Use as a context manager to check that the code inside the &lt;code&gt;with&lt;/code&gt; block does not execute any &lt;a href=&quot;reference-core#checkpoints&quot;&gt;checkpoints&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 블록 내부의 코드 가 &lt;a href=&quot;reference-core#checkpoints&quot;&gt;검사 점을&lt;/a&gt; 실행하지 않는지 확인하려면 컨텍스트 관리자로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b0d3eb180f053e32850213c6f7a3574f4f4119ea" translate="yes" xml:space="preserve">
          <source>Use as a context manager to check that the code inside the &lt;code&gt;with&lt;/code&gt; block either exits with an exception or executes at least one &lt;a href=&quot;reference-core#checkpoints&quot;&gt;checkpoint&lt;/a&gt;.</source>
          <target state="translated">컨텍스트 관리자로 사용하여 &lt;code&gt;with&lt;/code&gt; 블록 내부의 코드 가 예외와 함께 종료되거나 하나 이상의 &lt;a href=&quot;reference-core#checkpoints&quot;&gt;검사 점을&lt;/a&gt; 실행 하는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="166059dea2ea131ea488e69911b917c400be45fd" translate="yes" xml:space="preserve">
          <source>Use as a context manager to create a cancel scope whose deadline is set to now + &lt;em&gt;seconds&lt;/em&gt;.</source>
          <target state="translated">컨텍스트 관리자로 사용하여 최종 기한이 이제 + &lt;em&gt;초로&lt;/em&gt; 설정된 취소 범위를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b93de5e82243cb860a3e551a41a4080f9d46f3f" translate="yes" xml:space="preserve">
          <source>Use as a context manager to create a cancel scope with the given absolute deadline.</source>
          <target state="translated">주어진 절대 기한이있는 취소 범위를 작성하려면 컨텍스트 관리자로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="608e328e68b84e87a64ebe10cd8d5e7d48c917ff" translate="yes" xml:space="preserve">
          <source>User-level API principles</source>
          <target state="translated">사용자 수준 API 원칙</target>
        </trans-unit>
        <trans-unit id="3704428b315819383f29b5bf2ccb66cdd3c1af2f" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;guest mode&amp;rdquo; to run Trio on top of other event loops</source>
          <target state="translated">&quot;게스트 모드&quot;를 사용하여 다른 이벤트 루프 위에서 Trio 실행</target>
        </trans-unit>
        <trans-unit id="21c61f26a2c50aee6d1c26b200a21f0e6eaa1d40" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#module-trio.hazmat&quot;&gt;&lt;code&gt;trio.hazmat&lt;/code&gt;&lt;/a&gt; isn&amp;rsquo;t really &lt;em&gt;that&lt;/em&gt; hazardous; in fact you&amp;rsquo;re already using it &amp;ndash; it&amp;rsquo;s how most of the functionality described in previous chapters is implemented. The APIs described here have strictly defined and carefully documented semantics, and are perfectly safe &amp;ndash; &lt;em&gt;if&lt;/em&gt; you read carefully and take proper precautions. Some of those strict semantics have &lt;a href=&quot;https://en.wikipedia.org/wiki/Rabbit_of_Caerbannog&quot;&gt;nasty big pointy teeth&lt;/a&gt;. If you make a mistake, Trio may not be able to handle it gracefully; conventions and guarantees that are followed strictly in the rest of Trio do not always apply. Using this module makes it your responsibility to think through and handle the nasty cases to expose a friendly Trio-style API to your users.</source>
          <target state="translated">&lt;a href=&quot;#module-trio.hazmat&quot;&gt; &lt;code&gt;trio.hazmat&lt;/code&gt; 를&lt;/a&gt; 사용 하는 것이 실제로 &lt;em&gt;그렇게&lt;/em&gt; 위험한 것은 아닙니다 . 실제로 이미 사용 중입니다. 이전 장에서 설명한 대부분의 기능이 구현되는 방식입니다. API는 여기에 설명 엄격하게 정의 조심스럽게 의미를 문서화하고, 완벽하게 안전하다 - &lt;em&gt;경우에&lt;/em&gt; 당신은주의 깊게 읽고 적절한 예방 조치를 취할. 이러한 엄격한 의미론 중 일부는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Rabbit_of_Caerbannog&quot;&gt;뾰족한 큰 이빨을 가지고&lt;/a&gt; 있습니다. 실수를하면 Trio가 실수를 제대로 처리하지 못할 수 있습니다. 나머지 Trio에서 엄격하게 준수하는 규칙 및 보증이 항상 적용되는 것은 아닙니다. 이 모듈을 사용하면 사용자에게 친숙한 Trio 스타일 API를 제공하기 위해 불쾌한 사례를 생각하고 처리해야 할 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cdd95a79dc24452bdfe3ab4e7974ec8b5066bb0" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;with receive_channel:&lt;/code&gt; will close the channel object on leaving the with block.</source>
          <target state="translated">&lt;code&gt;with receive_channel:&lt;/code&gt; 사용 하면 with 블록을 떠날 때 채널 개체가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="a3e3eebd6130f775ef0cb1dc84296c616efc3570" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;with send_channel:&lt;/code&gt; will close the channel object on leaving the with block.</source>
          <target state="translated">&lt;code&gt;with send_channel:&lt;/code&gt; 사용 하면 with 블록을 떠날 때 채널 개체가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="1b513f360a782387f728539080c7a02c20167250" translate="yes" xml:space="preserve">
          <source>Using channels to pass values between tasks</source>
          <target state="translated">채널을 사용하여 작업 간 값 전달</target>
        </trans-unit>
        <trans-unit id="fa493b12215c35c7f93080081bf1f16fbdb17efc" translate="yes" xml:space="preserve">
          <source>Using the same async file object from multiple tasks simultaneously: because the async methods on async file objects are implemented using threads, it&amp;rsquo;s only safe to call two of them at the same time from different tasks IF the underlying synchronous file object is thread-safe. You should consult the documentation for the object you&amp;rsquo;re wrapping. For objects returned from &lt;a href=&quot;#trio.open_file&quot;&gt;&lt;code&gt;trio.open_file()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.Path.open&quot;&gt;&lt;code&gt;trio.Path.open()&lt;/code&gt;&lt;/a&gt;, it depends on whether you open the file in binary mode or text mode: &lt;a href=&quot;https://docs.python.org/3/library/io.html#multi-threading&quot;&gt;binary mode files are task-safe/thread-safe, text mode files are not&lt;/a&gt;.</source>
          <target state="translated">여러 작업에서 동일한 비동기 파일 개체를 동시에 사용 : 비동기 파일 개체의 비동기 메서드는 스레드를 사용하여 구현되므로 기본 동기 파일 개체가 스레드 안전 인 경우 다른 작업에서 동시에 두 개를 호출하는 것이 안전합니다. 줄 바꿈하려는 객체의 설명서를 참조해야합니다. &lt;a href=&quot;#trio.open_file&quot;&gt; &lt;code&gt;trio.open_file()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#trio.Path.open&quot;&gt; &lt;code&gt;trio.Path.open()&lt;/code&gt; &lt;/a&gt; 에서 반환 된 객체의 경우 파일을 이진 모드 또는 텍스트 모드로 열지 여부에 따라 달라집니다. &lt;a href=&quot;https://docs.python.org/3/library/io.html#multi-threading&quot;&gt;이진 모드 파일은 작업 안전 / 스레드 안전, 텍스트 모드 파일은&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="242accfa507e3192f6b8cb5222ee8bab6d096fde" translate="yes" xml:space="preserve">
          <source>Violating the rule described in this section will sometimes get you a useful error message, but Trio is not able to detect all such cases, so sometimes you&amp;rsquo;ll get an unhelpful &lt;a href=&quot;#trio.TrioInternalError&quot;&gt;&lt;code&gt;TrioInternalError&lt;/code&gt;&lt;/a&gt;. (And sometimes it will seem to work, which is probably the worst outcome of all, since then you might not notice the issue until you perform some minor refactoring of the generator or the code that&amp;rsquo;s iterating it, or just get unlucky. There is a &lt;a href=&quot;https://discuss.python.org/t/preventing-yield-inside-certain-context-managers/1091&quot;&gt;proposed Python enhancement&lt;/a&gt; that would at least make it fail consistently.)</source>
          <target state="translated">이 섹션에 설명 된 규칙을 위반하면 유용한 오류 메시지가 표시되는 경우가 있지만 Trio는 이러한 경우를 모두 감지 할 수 없으므로 도움이되지 않는 &lt;a href=&quot;#trio.TrioInternalError&quot;&gt; &lt;code&gt;TrioInternalError&lt;/code&gt; &lt;/a&gt; 가 표시되는 경우가 있습니다 . (그리고 때로는 작동하는 것처럼 보일 것입니다. 이는 아마도 모든 것 중 최악의 결과 일 것입니다. 생성기 또는이를 반복하는 코드의 사소한 리팩토링을 수행 할 때까지 문제를 알아 차리지 못하거나 불행해질 수 있기 때문입니다. 적어도 일관되게 실패하게 만드는 &lt;a href=&quot;https://discuss.python.org/t/preventing-yield-inside-certain-context-managers/1091&quot;&gt;Python 개선 사항&lt;/a&gt; 을 제안 했습니다.)</target>
        </trans-unit>
        <trans-unit id="daef22f12350658306822e18b3055d487a63aa72" translate="yes" xml:space="preserve">
          <source>Virtual networking for testing</source>
          <target state="translated">테스트를위한 가상 네트워킹</target>
        </trans-unit>
        <trans-unit id="3fe725b689c13e430fd18699fb2e95efd7595058" translate="yes" xml:space="preserve">
          <source>Virtual, controllable streams</source>
          <target state="translated">가상의 제어 가능한 스트림</target>
        </trans-unit>
        <trans-unit id="d4a7534fed721d1a3033c28ee4152b82de5aae0b" translate="yes" xml:space="preserve">
          <source>Vital statistics:</source>
          <target state="translated">중요한 통계 :</target>
        </trans-unit>
        <trans-unit id="66bdf7f790161b995fe7eefaa4a5ae688592cf68" translate="yes" xml:space="preserve">
          <source>WWDC 2015: Your App and Next Generation Networks: &lt;a href=&quot;http://devstreaming.apple.com/videos/wwdc/2015/719ui2k57m/719/719_your_app_and_next_generation_networks.pdf?dl=1&quot;&gt;slides&lt;/a&gt;, &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015/719/&quot;&gt;video and transcript&lt;/a&gt;</source>
          <target state="translated">WWDC 2015 : 앱 및 차세대 네트워크 : &lt;a href=&quot;http://devstreaming.apple.com/videos/wwdc/2015/719ui2k57m/719/719_your_app_and_next_generation_networks.pdf?dl=1&quot;&gt;슬라이드&lt;/a&gt; , &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2015/719/&quot;&gt;비디오 및 대화 내용&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee575d9368c52e25aad8feb46a457f7983389a7b" translate="yes" xml:space="preserve">
          <source>Wait for another task to call &lt;a href=&quot;#trio.Condition.notify&quot;&gt;&lt;code&gt;notify()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.Condition.notify_all&quot;&gt;&lt;code&gt;notify_all()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다른 태스크가 &lt;a href=&quot;#trio.Condition.notify&quot;&gt; &lt;code&gt;notify()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#trio.Condition.notify_all&quot;&gt; &lt;code&gt;notify_all()&lt;/code&gt; &lt;/a&gt; 을 호출 할 때까지 기다리십시오 .</target>
        </trans-unit>
        <trans-unit id="3436440f994f25ba01fc52315e24e50790c1aca2" translate="yes" xml:space="preserve">
          <source>Wait for another thread to call &lt;a href=&quot;#trio.Condition.notify&quot;&gt;&lt;code&gt;notify()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.Condition.notify_all&quot;&gt;&lt;code&gt;notify_all()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다른 스레드가 &lt;a href=&quot;#trio.Condition.notify&quot;&gt; &lt;code&gt;notify()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#trio.Condition.notify_all&quot;&gt; &lt;code&gt;notify_all()&lt;/code&gt; &lt;/a&gt; 을 호출 할 때까지 기다리십시오 .</target>
        </trans-unit>
        <trans-unit id="5ccb97cb75cf101284abbbabebb91973944b50bd" translate="yes" xml:space="preserve">
          <source>Wait for the operating system to notify them that something interesting has happened, like data arriving on a socket or a timeout passing. They do this by invoking a platform-specific &lt;code&gt;sleep_until_something_happens()&lt;/code&gt; system call &amp;ndash; &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;epoll&lt;/code&gt;, &lt;code&gt;kqueue&lt;/code&gt;, &lt;code&gt;GetQueuedCompletionEvents&lt;/code&gt;, etc.</source>
          <target state="translated">운영 체제가 데이터가 소켓에 도착하거나 시간 초과가 지나가는 등 흥미로운 일이 발생했음을 알리도록 기다립니다. 플랫폼 별 &lt;code&gt;sleep_until_something_happens()&lt;/code&gt; 시스템 호출 ( &lt;code&gt;select&lt;/code&gt; , &lt;code&gt;epoll&lt;/code&gt; , &lt;code&gt;kqueue&lt;/code&gt; , &lt;code&gt;GetQueuedCompletionEvents&lt;/code&gt; 등 ) 을 호출하여이를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="3c93347a983a68108b3b1f0acbc56ebba40360c7" translate="yes" xml:space="preserve">
          <source>Wait queue abstraction</source>
          <target state="translated">대기 큐 추상화</target>
        </trans-unit>
        <trans-unit id="41913a4464c21572206e30e9131c0a6aee848a95" translate="yes" xml:space="preserve">
          <source>Wait until an incoming connection arrives, and then return it.</source>
          <target state="translated">들어오는 연결이 도착할 때까지 기다렸다가 다시 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="b315f5b334c892b158d988c89293b0f0e4c16c38" translate="yes" xml:space="preserve">
          <source>Wait until there is data available on this stream, and then return some of it.</source>
          <target state="translated">이 스트림에 사용 가능한 데이터가있을 때까지 기다린 후 일부를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="7de17c3c803ae3d81fa6d8c0519a268cfd929e9e" translate="yes" xml:space="preserve">
          <source>Waits 100 ms before calling &lt;code&gt;accept&lt;/code&gt; again, in hopes that the system will recover.</source>
          <target state="translated">시스템이 복구 될 수 있도록 &lt;code&gt;accept&lt;/code&gt; 를 다시 호출하기 전에 100ms를 기다립니다 .</target>
        </trans-unit>
        <trans-unit id="50ff1ba82f15773a71c03597ce8c1546e55713f2" translate="yes" xml:space="preserve">
          <source>Wake all tasks that are currently blocked in &lt;a href=&quot;#trio.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 &lt;a href=&quot;#trio.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 에서 차단 된 모든 작업을 깨 웁니다 .</target>
        </trans-unit>
        <trans-unit id="3af26aecfc19665d78b1a885ea21cb73c7a2f9d7" translate="yes" xml:space="preserve">
          <source>Wake one or more tasks that are blocked in &lt;a href=&quot;#trio.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 에서 차단 된 하나 이상의 작업을 깨 웁니다 .</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="370071229bb1fc7e23236287f51125978b32419c" translate="yes" xml:space="preserve">
          <source>Warning emitted if you use deprecated Trio functionality.</source>
          <target state="translated">더 이상 사용되지 않는 Trio 기능을 사용하면 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="186f850bb584155f8a72f762be272643970d59bc" translate="yes" xml:space="preserve">
          <source>We also added an &lt;code&gt;async with&lt;/code&gt; to the consumer. This isn&amp;rsquo;t as important, but it can help us catch mistakes or other problems. For example, suppose that the consumer exited early for some reason &amp;ndash; maybe because of a bug. Then the producer would be sending messages into the void, and might get stuck indefinitely. But, if the consumer closes its &lt;code&gt;receive_channel&lt;/code&gt;, then the producer will get a &lt;a href=&quot;#trio.BrokenResourceError&quot;&gt;&lt;code&gt;BrokenResourceError&lt;/code&gt;&lt;/a&gt; to alert it that it should stop sending messages because no-one is listening.</source>
          <target state="translated">또한 소비자에게 &lt;code&gt;async with&lt;/code&gt; 추가했습니다 . 이것은 중요하지 않지만 실수 나 다른 문제를 잡는 데 도움이 될 수 있습니다. 예를 들어 어떤 이유로 소비자가 버그로 인해 일찍 종료했다고 가정합니다. 그런 다음 생산자가 빈 공간으로 메시지를 보내고 무한정 중단 될 수 있습니다. 그러나 소비자가 &lt;code&gt;receive_channel&lt;/code&gt; 을 닫으면 생산자는 아무도 수신하지 않기 때문에 메시지 전송을 중지해야한다는 것을 알리기 위해 &lt;a href=&quot;#trio.BrokenResourceError&quot;&gt; &lt;code&gt;BrokenResourceError&lt;/code&gt; &lt;/a&gt; 를 받습니다 .</target>
        </trans-unit>
        <trans-unit id="9a97d4344ecae4164e40e82372a9515a0366cc17" translate="yes" xml:space="preserve">
          <source>We also keep track of an extra bit of state, because it turns out to be useful for &lt;a href=&quot;#trio.SocketStream&quot;&gt;&lt;code&gt;trio.SocketStream&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">또한 &lt;a href=&quot;#trio.SocketStream&quot;&gt; &lt;code&gt;trio.SocketStream&lt;/code&gt; 에&lt;/a&gt; 유용하기 때문에 여분의 비트 상태를 추적합니다 .</target>
        </trans-unit>
        <trans-unit id="3a137af56fff2042ca3e86c2acd1f2c56ae90997" translate="yes" xml:space="preserve">
          <source>We also monkey patch &lt;a href=&quot;https://docs.python.org/3/library/traceback.html#traceback.TracebackException&quot;&gt;&lt;code&gt;traceback.TracebackException&lt;/code&gt;&lt;/a&gt; to be able to handle formatting &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt;s. This means that anything that formats exception messages like &lt;a href=&quot;https://docs.python.org/3/library/logging.html#module-logging&quot;&gt;&lt;code&gt;logging&lt;/code&gt;&lt;/a&gt; will work out of the box:</source>
          <target state="translated">또한 &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; 의 서식을 처리 할 수 ​​있도록 원숭이 패치 &lt;a href=&quot;https://docs.python.org/3/library/traceback.html#traceback.TracebackException&quot;&gt; &lt;code&gt;traceback.TracebackException&lt;/code&gt; &lt;/a&gt; 을 처리 합니다. 이것은 &lt;a href=&quot;https://docs.python.org/3/library/logging.html#module-logging&quot;&gt; &lt;code&gt;logging&lt;/code&gt; &lt;/a&gt; 과 같은 예외 메시지를 포맷하는 모든 것이 즉시 작동 한다는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="343247e5868406916a376486d6adae4b0f900926" translate="yes" xml:space="preserve">
          <source>We could avoid this by using some complicated bookkeeping to make sure that only the &lt;em&gt;last&lt;/em&gt; producer and the &lt;em&gt;last&lt;/em&gt; consumer close their channel endpoints&amp;hellip; but that would be tiresome and fragile. Fortunately, there&amp;rsquo;s a better way! Here&amp;rsquo;s a fixed version of our program above:</source>
          <target state="translated">우리는 복잡한 부기를 사용하여 &lt;em&gt;마지막&lt;/em&gt; 생산자와 &lt;em&gt;마지막&lt;/em&gt; 소비자 만 채널 엔드 포인트를 닫을 수 있도록함으로써 이러한 문제를 피할 수있었습니다 . 다행히도 더 좋은 방법이 있습니다! 위 프로그램의 수정 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6301739491da2a3a7d78787414f0b6feacea46b" translate="yes" xml:space="preserve">
          <source>We don&amp;rsquo;t provide timeout arguments. If you want a timeout, then use a cancel scope.</source>
          <target state="translated">타임 아웃 인수는 제공하지 않습니다. 시간 초과를 원하면 취소 범위를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1a408f02fc2bead2788df0bed4524d5ab6823772" translate="yes" xml:space="preserve">
          <source>We refer to &lt;a href=&quot;#trio.move_on_after&quot;&gt;&lt;code&gt;move_on_after()&lt;/code&gt;&lt;/a&gt; as creating a &amp;ldquo;cancel scope&amp;rdquo;, which contains all the code that runs inside the &lt;code&gt;with&lt;/code&gt; block. If the HTTP request takes more than 30 seconds to run, then it will be cancelled: we&amp;rsquo;ll abort the request and we &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; see &lt;code&gt;result is ...&lt;/code&gt; printed on the console; instead we&amp;rsquo;ll go straight to printing the &lt;code&gt;with block
finished&lt;/code&gt; message.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 블록 내에서 실행되는 모든 코드를 포함하는 &quot;취소 범위&quot;를 만드는 것으로 &lt;a href=&quot;#trio.move_on_after&quot;&gt; &lt;code&gt;move_on_after()&lt;/code&gt; &lt;/a&gt; 를 참조합니다 . HTTP 요청을 실행하는 데 30 초 이상 걸리면 요청이 취소됩니다. 요청이 중단되고 &lt;code&gt;result is ...&lt;/code&gt; 콘솔에 인쇄되는 것을 볼 &lt;em&gt;수 없습니다&lt;/em&gt; . 대신 &lt;code&gt;with block finished&lt;/code&gt; 메시지를 바로 인쇄 해 보겠습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3f558f9a59ef0139a2cd804b31ab3c5404a02658" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve talked a lot about what happens when an operation is cancelled, and how you need to be prepared for this whenever calling a cancellable operation&amp;hellip; but we haven&amp;rsquo;t gone into the details about which operations are cancellable, and how exactly they behave when they&amp;rsquo;re cancelled.</source>
          <target state="translated">작업이 취소 될 때 발생하는 상황과 취소 가능한 작업을 호출 할 때마다이를 준비해야하는 방법에 대해 많이 이야기했지만&amp;hellip; 취소되면</target>
        </trans-unit>
        <trans-unit id="991ef6d2da9180f69d7985da97799558bc5635c1" translate="yes" xml:space="preserve">
          <source>Web and HTML</source>
          <target state="translated">웹 및 HTML</target>
        </trans-unit>
        <trans-unit id="bef9db76111ae54eb0dfb86dd904a54acc62f1fd" translate="yes" xml:space="preserve">
          <source>What happens if the user hits control-C while &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; is running? If this argument is False (the default), then you get the standard Python behavior: a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; exception will immediately interrupt whatever task is running (or if no task is running, then Trio will wake up a task to be interrupted). Alternatively, if you set this argument to True, then &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; delivery will be delayed: it will be &lt;em&gt;only&lt;/em&gt; be raised at &lt;a href=&quot;#checkpoints&quot;&gt;checkpoints&lt;/a&gt;, like a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">&lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 이 실행되는 동안 사용자가 control-C를 누르면 어떻게됩니까 ? 이 인수가 False (기본값)이면 표준 Python 동작이 발생 합니다. &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 예외는 실행중인 작업을 즉시 중단합니다 (또는 실행중인 작업이 없으면 Trio가 중단 할 작업을 깨 웁니다). True로이 인수를 설정하는 경우 또는, 다음 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 배송이 지연 될 : 그것은됩니다 &lt;em&gt;만&lt;/em&gt; 에 제기 할 &lt;a href=&quot;#checkpoints&quot;&gt;체크 포인트&lt;/a&gt; 는 A, &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외입니다.</target>
        </trans-unit>
        <trans-unit id="60fac7efcca9c565bad833f50e1477967aff7c88" translate="yes" xml:space="preserve">
          <source>What is &amp;ldquo;guest mode&amp;rdquo;?</source>
          <target state="translated">&quot;게스트 모드&quot;란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="4b238710fedc1b59473f2e5d0f608a1b6a710f67" translate="yes" xml:space="preserve">
          <source>Whatever &lt;code&gt;afn(*args)&lt;/code&gt; returns.</source>
          <target state="translated">&lt;code&gt;afn(*args)&lt;/code&gt; 는 무엇이든 반환합니다.</target>
        </trans-unit>
        <trans-unit id="266ea61e53a70acfd1db0b04d0327c318baacbd6" translate="yes" xml:space="preserve">
          <source>Whatever &lt;code&gt;async_fn&lt;/code&gt; returns.</source>
          <target state="translated">무엇이든은 &lt;code&gt;async_fn&lt;/code&gt; 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="0900e19e99ebea86826634809b1ac337300398cd" translate="yes" xml:space="preserve">
          <source>Whatever &lt;code&gt;fn(*args)&lt;/code&gt; returns.</source>
          <target state="translated">&lt;code&gt;fn(*args)&lt;/code&gt; 는 무엇이든 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7106029302bd01916d53d96d96a609813f99f07f" translate="yes" xml:space="preserve">
          <source>Whatever &lt;code&gt;sync_fn(*args)&lt;/code&gt; returns.</source>
          <target state="translated">&lt;code&gt;sync_fn(*args)&lt;/code&gt; 가 무엇이든 반환합니다.</target>
        </trans-unit>
        <trans-unit id="73c196cbd030978c8ebe9f64bd805b220de1b08c" translate="yes" xml:space="preserve">
          <source>Whatever object was received.</source>
          <target state="translated">받은 물건.</target>
        </trans-unit>
        <trans-unit id="c08d6626b380b7a283be3fe01b713e7771435c33" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#trio.serve_listeners&quot;&gt;&lt;code&gt;serve_listeners()&lt;/code&gt;&lt;/a&gt; gets one of these errors, then it:</source>
          <target state="translated">때 &lt;a href=&quot;#trio.serve_listeners&quot;&gt; &lt;code&gt;serve_listeners()&lt;/code&gt; &lt;/a&gt; 그 다음, 이러한 오류 중 하나가 가져옵니다</target>
        </trans-unit>
        <trans-unit id="70c95cc62edeba47e63c58fc9085be2e8b6351ec" translate="yes" xml:space="preserve">
          <source>When Something Happens</source>
          <target state="translated">무언가가 일어날 때</target>
        </trans-unit>
        <trans-unit id="ba546f26b5517c4f6e089e91b69d48fca957e868" translate="yes" xml:space="preserve">
          <source>When Trio finishes and your &lt;code&gt;done_callback&lt;/code&gt; is invoked, shut down the host loop</source>
          <target state="translated">Trio가 완료되고 &lt;code&gt;done_callback&lt;/code&gt; 이 호출되면 호스트 루프를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="8fa415e76fd97b945f16a66030c2c91b43138a27" translate="yes" xml:space="preserve">
          <source>When a non-blocking method cannot succeed (the channel is empty, the lock is already held, etc.), then it raises &lt;a href=&quot;#trio.WouldBlock&quot;&gt;&lt;code&gt;trio.WouldBlock&lt;/code&gt;&lt;/a&gt;. There&amp;rsquo;s no equivalent to the &lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Empty&quot;&gt;&lt;code&gt;queue.Empty&lt;/code&gt;&lt;/a&gt; versus &lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Full&quot;&gt;&lt;code&gt;queue.Full&lt;/code&gt;&lt;/a&gt; distinction &amp;ndash; we just have the one exception that we use consistently.</source>
          <target state="translated">비 차단 방법이 성공하지 못하면 (채널이 비어 있거나 잠금이 이미 보유 된 경우 등) &lt;a href=&quot;#trio.WouldBlock&quot;&gt; &lt;code&gt;trio.WouldBlock&lt;/code&gt; 이 발생&lt;/a&gt; 합니다. &lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Empty&quot;&gt; &lt;code&gt;queue.Empty&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;https://docs.python.org/3/library/queue.html#queue.Full&quot;&gt; &lt;code&gt;queue.Full&lt;/code&gt; &lt;/a&gt; 구별 과 동등한 것은 없습니다 . 일관성있게 사용하는 한 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a25ccee7807a927ac0e6934a2c0dc83b30b44fd" translate="yes" xml:space="preserve">
          <source>When calling this method, you must hold the lock. It releases the lock while waiting, and then re-acquires it before waking up.</source>
          <target state="translated">이 메소드를 호출 할 때 잠금을 유지해야합니다. 대기하는 동안 잠금을 해제 한 다음 깨어나 기 전에 다시 확보합니다.</target>
        </trans-unit>
        <trans-unit id="753c218c6f37ff70efd4c6551a5ae5088a5768f7" translate="yes" xml:space="preserve">
          <source>When the Trio run has finished, Trio will invoke this callback to let you know. The argument is an &lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt;&lt;code&gt;outcome.Outcome&lt;/code&gt;&lt;/a&gt;, reporting what would have been returned or raised by &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt;. This function can do anything you want, but commonly you&amp;rsquo;ll want it to shut down the host loop, unwrap the outcome, etc.</source>
          <target state="translated">Trio 실행이 완료되면 Trio가이 콜백을 호출하여 알려줍니다. 인수는이다 &lt;a href=&quot;https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome&quot;&gt; &lt;code&gt;outcome.Outcome&lt;/code&gt; &lt;/a&gt; 의 반품에 의해 제기 된 것입니다 무엇을보고, &lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run&lt;/code&gt; &lt;/a&gt; . 이 함수는 원하는 모든 작업을 수행 할 수 있지만 일반적으로 호스트 루프를 종료하고 결과를 풀기 등을 원할 것입니다.</target>
        </trans-unit>
        <trans-unit id="492b823ff0bfc64272d1aac26d5141c4bbf0412b" translate="yes" xml:space="preserve">
          <source>When the calling coroutine enters this function it&amp;rsquo;s running under Trio, and when the function returns it&amp;rsquo;s running under the foreign coroutine runner.</source>
          <target state="translated">호출 코 루틴이이 함수에 들어가면 Trio에서 실행되고 함수가 반환되면 외부 코 루틴 러너에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="e7ef1b43a451a8a215f39d5c443f75b4d480e706" translate="yes" xml:space="preserve">
          <source>When the calling coroutine enters this function it&amp;rsquo;s running under the foreign coroutine runner, and when the function returns it&amp;rsquo;s running under Trio.</source>
          <target state="translated">호출 코 루틴이이 함수에 들어가면 외부 코 루틴 러너에서 실행되고 함수가 반환되면 Trio에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c43b2fd212506db181cda97f6f6177df1e6cecc9" translate="yes" xml:space="preserve">
          <source>When the child calls &lt;code&gt;task_status.started()&lt;/code&gt;, it&amp;rsquo;s moved from out from underneath &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; and into the given nursery.</source>
          <target state="translated">자식이 &lt;code&gt;task_status.started()&lt;/code&gt; 호출하면 &lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 아래 에서 지정된 보육으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="54c0737c4ecd13bf0fa970257c2d732fdc4598ce" translate="yes" xml:space="preserve">
          <source>When the child calls &lt;code&gt;task_status.started()&lt;/code&gt;, it&amp;rsquo;s moved out from underneath &lt;a href=&quot;#trio.Nursery.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; and into the given nursery.</source>
          <target state="translated">자식이 &lt;code&gt;task_status.started()&lt;/code&gt; 호출하면 &lt;a href=&quot;#trio.Nursery.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 아래 에서 지정된 nursery로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="49306f775b665fbf38ace009d3a78979b0faff07" translate="yes" xml:space="preserve">
          <source>When the process actually exits, the &lt;code&gt;deliver_cancel&lt;/code&gt; function will automatically be cancelled &amp;ndash; so if the process exits after &lt;code&gt;SIGTERM&lt;/code&gt;, then we&amp;rsquo;ll never reach the &lt;code&gt;SIGKILL&lt;/code&gt;.</source>
          <target state="translated">프로세스가 실제로 종료되면 &lt;code&gt;deliver_cancel&lt;/code&gt; 함수가 자동으로 취소됩니다. 따라서 프로세스가 &lt;code&gt;SIGTERM&lt;/code&gt; 이후에 종료 되면 &lt;code&gt;SIGKILL&lt;/code&gt; 에 도달하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1e41b82f148b817f9177e9c64a7e7139363b2ad1" translate="yes" xml:space="preserve">
          <source>When things go wrong: timeouts, cancellation and exceptions in concurrent tasks</source>
          <target state="translated">문제가 발생할 경우 : 동시 작업의 시간 초과, 취소 및 예외</target>
        </trans-unit>
        <trans-unit id="4696d67240a9e110f4a4748327c6309139ff62d8" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;nursery.start&lt;/code&gt; you get back the newly opened listeners. See the documentation for &lt;a href=&quot;#trio.serve_tcp&quot;&gt;&lt;code&gt;serve_tcp()&lt;/code&gt;&lt;/a&gt; for an example where this is useful.</source>
          <target state="translated">&lt;code&gt;nursery.start&lt;/code&gt; 와 함께 사용 하면 새로 열린 리스너를 다시 가져옵니다. 이것이 유용한 예제 는 &lt;a href=&quot;#trio.serve_tcp&quot;&gt; &lt;code&gt;serve_tcp()&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b0f0516af766be435ac7ae9669119313d86c471d" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;nursery.start&lt;/code&gt; you get back the newly opened listeners. So, for example, if you want to start a server in your test suite and then connect to it to check that it&amp;rsquo;s working properly, you can use something like:</source>
          <target state="translated">&lt;code&gt;nursery.start&lt;/code&gt; 와 함께 사용 하면 새로 열린 리스너를 다시 가져옵니다. 예를 들어 테스트 스위트에서 서버를 시작한 다음 서버에 연결하여 제대로 작동하는지 확인하려는 경우 다음과 같은 것을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="050a5caa1b8ee04b9f63b749870c3fe582322618" translate="yes" xml:space="preserve">
          <source>When writing Trio code, you need to keep track of where your checkpoints are. Why? First, because checkpoints require extra scrutiny: whenever you execute a checkpoint, you need to be prepared to handle a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; error, or for another task to run and &lt;a href=&quot;https://glyph.twistedmatrix.com/2014/02/unyielding.html&quot;&gt;rearrange some state out from under you&lt;/a&gt;. And second, because you also need to make sure that you have &lt;em&gt;enough&lt;/em&gt; checkpoints: if your code doesn&amp;rsquo;t pass through a checkpoint on a regular basis, then it will be slow to notice and respond to cancellation and &amp;ndash; much worse &amp;ndash; since Trio is a cooperative multi-tasking system where the &lt;em&gt;only&lt;/em&gt; place the scheduler can switch tasks is at checkpoints, it&amp;rsquo;ll also prevent the scheduler from fairly allocating time between different tasks and adversely effect the response latency of all the other code running in the same process. (Informally we say that a task that does this is &amp;ldquo;hogging the run loop&amp;rdquo;.)</source>
          <target state="translated">Trio 코드를 작성할 때 체크 포인트의 위치를 ​​추적해야합니다. 왜? 첫째, 검사 점에는 추가 검사가 필요하기 때문에 검사 ​​점을 실행할 때마다 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 오류 를 처리 하거나 다른 작업이 실행되고 다른 &lt;a href=&quot;https://glyph.twistedmatrix.com/2014/02/unyielding.html&quot;&gt;상태에서 다시 정렬&lt;/a&gt; 되도록 준비해야 합니다 . 둘째, &lt;em&gt;충분한&lt;/em&gt; 체크 포인트 가 있는지 확인해야하기 때문에 코드가 정기적으로 체크 포인트를 통과하지 않으면 트리오가 감지되기 ​​때문에 취소 및 취소에 대한 응답이 느려질 것입니다. &lt;em&gt;유일한&lt;/em&gt; 멀티 태스킹 시스템&lt;em&gt;&lt;/em&gt;스케줄러가 작업을 전환 할 수있는 위치는 검사 점에 있으며 스케줄러가 다른 작업간에 시간을 상당히 할당하지 못하게하고 동일한 프로세스에서 실행중인 다른 모든 코드의 응답 대기 시간에 부정적인 영향을 미칩니다. (공식적으로 우리는이 작업을 수행하는 것이 &quot;루프 실행&quot;이라고 말합니다.)</target>
        </trans-unit>
        <trans-unit id="2bd47718f69d1078c324105f5b4a8877d159988a" translate="yes" xml:space="preserve">
          <source>When writing code using Trio, it&amp;rsquo;s very important to understand the concept of a &lt;em&gt;checkpoint&lt;/em&gt;. Many of Trio&amp;rsquo;s functions act as checkpoints.</source>
          <target state="translated">Trio를 사용하여 코드를 작성할 때 &lt;em&gt;검사 점&lt;/em&gt; 개념을 이해하는 것이 매우 중요 &lt;em&gt;합니다&lt;/em&gt; . 많은 Trio 기능이 체크 포인트 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="563b04d52caf0b7947b54fd91ab7bb4c9b90eec8" translate="yes" xml:space="preserve">
          <source>When you call &lt;a href=&quot;#trio.open_memory_channel&quot;&gt;&lt;code&gt;open_memory_channel()&lt;/code&gt;&lt;/a&gt;, you have to specify how many values can be buffered internally in the channel. If the buffer is full, then any task that calls &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; will stop and wait for another task to call &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive()&lt;/code&gt;&lt;/a&gt;. This is useful because it produces &lt;em&gt;backpressure&lt;/em&gt;: if the channel producers are running faster than the consumers, then it forces the producers to slow down.</source>
          <target state="translated">&lt;a href=&quot;#trio.open_memory_channel&quot;&gt; &lt;code&gt;open_memory_channel()&lt;/code&gt; &lt;/a&gt; 을 호출 할 때 채널에서 내부적으로 버퍼링 할 수있는 값 수를 지정해야합니다. 버퍼가 가득 차면 &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt; 를 호출하는 모든 작업 이 중지되고 다른 작업이 &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive()&lt;/code&gt; &lt;/a&gt; 를 호출하기를 기다립니다 . 이는 &lt;em&gt;배압&lt;/em&gt; 을 생성하기 때문에 유용 합니다. 채널 생산자가 소비자보다 더 빨리 실행되면 생산자가 속도를 늦 춥니 다.</target>
        </trans-unit>
        <trans-unit id="8151ab5838ee480e5fa7b1d05a5c8fc0425cba68" translate="yes" xml:space="preserve">
          <source>Why is this so? Well, &lt;code&gt;start_soon()&lt;/code&gt; returns as soon as it has scheduled the new task to start running. The flow of execution in the parent then continues on to exit the &lt;code&gt;with move_on_after(TIMEOUT):&lt;/code&gt; block, at which point Trio forgets about the timeout entirely. In order for the timeout to apply to the child task, Trio must be able to tell that its associated cancel scope will stay open for at least as long as the child task is executing. And Trio can only know that for sure if the cancel scope block is outside the nursery block.</source>
          <target state="translated">왜 그렇습니까? 글쎄, &lt;code&gt;start_soon()&lt;/code&gt; 은 새 작업이 실행되도록 예약하자마자 반환합니다. 부모의 실행 흐름은 계속해서 &lt;code&gt;with move_on_after(TIMEOUT):&lt;/code&gt; 블록 을 종료합니다 . 이 지점에서 Trio는 타임 아웃을 완전히 잊어 버립니다. 타임 아웃이 자식 작업에 적용 되려면 Trio는 최소한 자식 작업이 실행되는 동안에는 관련 취소 범위가 열려 있음을 알릴 수 있어야합니다. 그리고 Trio는 취소 스코프 블록이 nursery 블록 밖에있는 경우에만 확실히 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebd5ba9c06f944e318c34cc1096bc4b580938e60" translate="yes" xml:space="preserve">
          <source>Why is this useful? Because it lets you write generic protocol implementations that can work over arbitrary transports, and easily create complex transport configurations. Here&amp;rsquo;s some examples:</source>
          <target state="translated">이것이 왜 유용한가요? 임의의 전송을 처리 할 수있는 일반 프로토콜 구현을 작성하고 복잡한 전송 구성을 쉽게 작성할 수 있기 때문입니다. 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1fe6956c2b57c6dcd4ba099709ab46045a14b6bf" translate="yes" xml:space="preserve">
          <source>Will properly log the inner exceptions:</source>
          <target state="translated">내부 예외를 올바르게 기록합니다.</target>
        </trans-unit>
        <trans-unit id="f5b730424dca0983602eb64b9f4309ede1c96c09" translate="yes" xml:space="preserve">
          <source>Windows, macOS, Linux (glibc and musl), FreeBSD</source>
          <target state="translated">Windows, macOS, Linux (glibc 및 musl), FreeBSD</target>
        </trans-unit>
        <trans-unit id="6603e7873d2ee40d69b4759aabb89958cd30da76" translate="yes" xml:space="preserve">
          <source>Windows-specific API</source>
          <target state="translated">Windows 관련 API</target>
        </trans-unit>
        <trans-unit id="ec261e1804785b0b785fb8d4215c0f1f49b8e343" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;shell=True&lt;/code&gt; on UNIX, you must specify the command as a single string, which will be passed to the shell as if you&amp;rsquo;d entered it at an interactive prompt. The advantage of this option is that it lets you use shell features like pipes and redirection without writing code to handle them. For example, you can write &lt;code&gt;Process(&quot;ls | grep
some_string&quot;, shell=True)&lt;/code&gt;. The disadvantage is that you must account for the shell&amp;rsquo;s quoting rules, generally by wrapping in &lt;a href=&quot;https://docs.python.org/3/library/shlex.html#shlex.quote&quot;&gt;&lt;code&gt;shlex.quote()&lt;/code&gt;&lt;/a&gt; any argument that might contain spaces, quotes, or other shell metacharacters. If you don&amp;rsquo;t do that, your safe-looking &lt;code&gt;f&quot;ls | grep {some_string}&quot;&lt;/code&gt; might end in disaster when invoked with &lt;code&gt;some_string = &quot;foo; rm -rf /&quot;&lt;/code&gt;.</source>
          <target state="translated">함께 &lt;code&gt;shell=True&lt;/code&gt; UNIX에, 당신은 당신이 대화 형 프롬프트를 입력했던 것처럼 쉘에 전달됩니다 단일 문자열로 명령을 지정해야합니다. 이 옵션의 장점은 파이프 및 리디렉션과 같은 쉘 기능을 코드를 작성하지 않고 사용하여 처리 할 수 ​​있다는 것입니다. 예를 들어 &lt;code&gt;Process(&quot;ls | grep some_string&quot;, shell=True)&lt;/code&gt; 작성할 수 있습니다 . 단점은 일반적으로 공백, 따옴표 또는 기타 쉘 메타 문자를 포함 할 수있는 인수를 &lt;a href=&quot;https://docs.python.org/3/library/shlex.html#shlex.quote&quot;&gt; &lt;code&gt;shlex.quote()&lt;/code&gt; &lt;/a&gt; 로 줄임 으로써 쉘의 인용 규칙을 고려해야 한다는 것입니다. 그렇게하지 않으면 &lt;code&gt;some_string = &quot;foo; rm -rf /&quot;&lt;/code&gt; 호출하면 안전 해 보이는 &lt;code&gt;f&quot;ls | grep {some_string}&quot;&lt;/code&gt; 이 재앙으로 종료 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1d019f8c58f9fd95bf76d9970e94c7ca4731343" translate="yes" xml:space="preserve">
          <source>Worker thread: First job finishes, and calls &lt;code&gt;deliver&lt;/code&gt;.</source>
          <target state="translated">작업자 스레드 : 첫 번째 작업 완료 및 통화 &lt;code&gt;deliver&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5fe13ef3f5abe58005367efa1a6d4109b0187fdd" translate="yes" xml:space="preserve">
          <source>Worker threads have the &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Thread.daemon&quot;&gt;&lt;code&gt;daemon&lt;/code&gt;&lt;/a&gt; flag set, which means that if your main thread exits, worker threads will automatically be killed. If you want to make sure that your &lt;code&gt;fn&lt;/code&gt; runs to completion, then you should make sure that the main thread remains alive until &lt;code&gt;deliver&lt;/code&gt; is called.</source>
          <target state="translated">작업자 스레드에는 &lt;a href=&quot;https://docs.python.org/3/library/threading.html#threading.Thread.daemon&quot;&gt; &lt;code&gt;daemon&lt;/code&gt; &lt;/a&gt; 플래그가 설정되어 있습니다. 즉, 기본 스레드가 종료되면 작업자 스레드가 자동으로 종료됩니다. 당신은 당신이 있는지 확인하려면 &lt;code&gt;fn&lt;/code&gt; 완료 실행이, 당신은 때까지 메인 쓰레드가 살아 남아 있는지 확인해야합니다 &lt;code&gt;deliver&lt;/code&gt; 이라고합니다.</target>
        </trans-unit>
        <trans-unit id="e73f6e4aaefa27f475bc4dd6d0f2b7b7c14f78e7" translate="yes" xml:space="preserve">
          <source>Working with &lt;a href=&quot;#trio.MultiError&quot;&gt;&lt;code&gt;MultiError&lt;/code&gt;&lt;/a&gt;s</source>
          <target state="translated">작업 &lt;a href=&quot;#trio.MultiError&quot;&gt; &lt;code&gt;MultiError&lt;/code&gt; &lt;/a&gt; 의</target>
        </trans-unit>
        <trans-unit id="7a749c2ad89d64cc77c70606aa79cc9a9d760911" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; get this error if &lt;em&gt;you&lt;/em&gt; closed the resource &amp;ndash; in that case you get &lt;a href=&quot;#trio.ClosedResourceError&quot;&gt;&lt;code&gt;ClosedResourceError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">당신이 &lt;em&gt;없는&lt;/em&gt; 경우이 오류가 발생 &lt;em&gt;하면&lt;/em&gt; 자원을 폐쇄 -이 경우 당신이 얻을 &lt;a href=&quot;#trio.ClosedResourceError&quot;&gt; &lt;code&gt;ClosedResourceError&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="009b360c3befaa2658cd8a4c7ce2de66315f1f24" translate="yes" xml:space="preserve">
          <source>You almost certainly don&amp;rsquo;t need this.</source>
          <target state="translated">당신은 거의 이것을 필요로하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9b45820263d7fae15a81523c5569073958dee34" translate="yes" xml:space="preserve">
          <source>You can also have multiple producers, and multiple consumers, all sharing the same channel. However, this makes shutdown a little more complicated.</source>
          <target state="translated">여러 생산자와 여러 소비자가 모두 같은 채널을 공유하도록 할 수도 있습니다. 그러나 이렇게하면 종료가 좀 더 복잡해집니다.</target>
        </trans-unit>
        <trans-unit id="fa7c24bdef2aeca73281561745562136ffeaa884" translate="yes" xml:space="preserve">
          <source>You can also return a new or modified exception, for example:</source>
          <target state="translated">다음과 같이 새 예외 또는 수정 된 예외를 반환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="85a44c662cd47a5543d52a16cd0c311eb28f153a" translate="yes" xml:space="preserve">
          <source>You can catch &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;, but you shouldn&amp;rsquo;t! Or more precisely, if you do catch it, then you should do some cleanup and then re-raise it or otherwise let it continue propagating (unless you encounter an error, in which case it&amp;rsquo;s OK to let that propagate instead). To help remind you of this fact, &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; inherits from &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BaseException&quot;&gt;&lt;code&gt;BaseException&lt;/code&gt;&lt;/a&gt;, like &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#SystemExit&quot;&gt;&lt;code&gt;SystemExit&lt;/code&gt;&lt;/a&gt; do, so that it won&amp;rsquo;t be caught by catch-all &lt;code&gt;except
Exception:&lt;/code&gt; blocks.</source>
          <target state="translated">&lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 을 잡을 수 있지만해서는 안됩니다! 또는 더 정확하게 말하면, 잡는 경우 정리를 한 다음 다시 올리거나 계속 전파해야합니다 (오류가 발생하지 않는 한, 대신 전파하는 것이 좋습니다). 이 사실을 상기시키기 위해 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#SystemExit&quot;&gt; &lt;code&gt;SystemExit&lt;/code&gt; &lt;/a&gt; 와 같이 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BaseException&quot;&gt; &lt;code&gt;BaseException&lt;/code&gt; &lt;/a&gt; 에서 상속 하므로 &lt;code&gt;except Exception:&lt;/code&gt; 블록을 제외하고 catch-all에 의해 포착되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8b32cfc5b75f959eb500229037977131b40984b7" translate="yes" xml:space="preserve">
          <source>You can change &lt;a href=&quot;#trio.CapacityLimiter.total_tokens&quot;&gt;&lt;code&gt;total_tokens&lt;/code&gt;&lt;/a&gt; by assigning to this attribute. If you make it larger, then the appropriate number of waiting tasks will be woken immediately to take the new tokens. If you decrease total_tokens below the number of tasks that are currently using the resource, then all current tasks will be allowed to finish as normal, but no new tasks will be allowed in until the total number of tasks drops below the new total_tokens.</source>
          <target state="translated">이 속성에 할당하여 &lt;a href=&quot;#trio.CapacityLimiter.total_tokens&quot;&gt; &lt;code&gt;total_tokens&lt;/code&gt; &lt;/a&gt; 를 변경할 수 있습니다 . 더 크게하면 새 토큰을 가져 오기 위해 적절한 수의 대기 작업이 즉시 깨어납니다. total_tokens를 현재 자원을 사용중인 작업 수 아래로 줄이면 현재 작업이 모두 정상적으로 완료 될 수 있지만 총 작업 수가 새 total_tokens 아래로 떨어질 때까지 새 작업이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11cd6250779c6856022b324d11615a036ef7bd8b" translate="yes" xml:space="preserve">
          <source>You can disable buffering entirely, by doing &lt;code&gt;open_memory_channel(0)&lt;/code&gt;. In that case any task calls &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; will wait until another task calls &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive()&lt;/code&gt;&lt;/a&gt;, and vice versa. This is similar to how channels work in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Channel_(programming)&quot;&gt;classic Communicating Sequential Processes model&lt;/a&gt;, and is a reasonable default if you aren&amp;rsquo;t sure what size buffer to use. (That&amp;rsquo;s why we used it in the examples above.)</source>
          <target state="translated">&lt;code&gt;open_memory_channel(0)&lt;/code&gt; 을 수행하여 버퍼링을 완전히 비활성화 할 수 있습니다 . 이 경우 모든 작업 호출 &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt; 는 다른 작업이 &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive()&lt;/code&gt; &lt;/a&gt; 호출 할 때까지 대기 하고 그 반대도 마찬가지입니다. 이는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Channel_(programming)&quot;&gt;전형적인 커뮤니 케이 팅 순차 프로세스 모델&lt;/a&gt; 에서 채널이 작동하는 방식과 유사하며 어떤 크기의 버퍼를 사용해야하는지 확실하지 않은 경우 적절한 기본값입니다. (따라서 위의 예에서 사용했습니다.)</target>
        </trans-unit>
        <trans-unit id="35229fb9115e8ecd014b6b64bf74bdc7940f514a" translate="yes" xml:space="preserve">
          <source>You can disable buffering entirely, by doing &lt;code&gt;open_memory_channel(0)&lt;/code&gt;. In that case any task that calls &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; will wait until another task calls &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt;&lt;code&gt;receive()&lt;/code&gt;&lt;/a&gt;, and vice versa. This is similar to how channels work in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Channel_(programming)&quot;&gt;classic Communicating Sequential Processes model&lt;/a&gt;, and is a reasonable default if you aren&amp;rsquo;t sure what size buffer to use. (That&amp;rsquo;s why we used it in the examples above.)</source>
          <target state="translated">&lt;code&gt;open_memory_channel(0)&lt;/code&gt; 을 수행하여 버퍼링을 완전히 비활성화 할 수 있습니다 . 이 경우 &lt;a href=&quot;reference-io#trio.abc.SendChannel.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt; 를 호출하는 모든 작업은 다른 작업이 &lt;a href=&quot;reference-io#trio.abc.ReceiveChannel.receive&quot;&gt; &lt;code&gt;receive()&lt;/code&gt; &lt;/a&gt; 호출 할 때까지 대기 하며 그 반대의 경우도 마찬가지입니다. 이는 채널이 &lt;a href=&quot;https://en.wikipedia.org/wiki/Channel_(programming)&quot;&gt;기존의 순차 프로세스 통신 모델&lt;/a&gt; 에서 작동하는 방식과 유사 하며 사용할 버퍼 크기가 확실하지 않은 경우 합리적인 기본값입니다. (이것이 위의 예에서 사용한 이유입니다.)</target>
        </trans-unit>
        <trans-unit id="1e18f18f287b713cf7b776bf6e3148ce23b129d9" translate="yes" xml:space="preserve">
          <source>You can freely nest cancellation blocks, and each &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception &amp;ldquo;knows&amp;rdquo; which block it belongs to. So long as you don&amp;rsquo;t stop it, the exception will keep propagating until it reaches the block that raised it, at which point it will stop automatically.</source>
          <target state="translated">취소 블록을 자유롭게 중첩 할 수 있으며, &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 각 예외는 해당 블록이 속한 블록을 &quot;인식&quot;합니다. 중지하지 않는 한 예외는 예외를 발생시킨 블록에 도달 할 때까지 계속 전파되며이 시점에서 자동으로 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="8f5139697bee7e3f58dfd9f1e3d68a51bb393964" translate="yes" xml:space="preserve">
          <source>You can iterate over a &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt;&lt;code&gt;ReceiveChannel&lt;/code&gt;&lt;/a&gt; using an &lt;code&gt;async for&lt;/code&gt; loop:</source>
          <target state="translated">&lt;code&gt;async for&lt;/code&gt; 루프를 사용하여 &lt;a href=&quot;#trio.abc.ReceiveChannel&quot;&gt; &lt;code&gt;ReceiveChannel&lt;/code&gt; &lt;/a&gt; 을 반복 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25750c191a2273b2bed66aa7b14de5b9a4a29dc8" translate="yes" xml:space="preserve">
          <source>You can register an initial list of instruments by passing them to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#trio.hazmat.add_instrument&quot;&gt;&lt;code&gt;add_instrument()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.hazmat.remove_instrument&quot;&gt;&lt;code&gt;remove_instrument()&lt;/code&gt;&lt;/a&gt; let you add and remove instruments at runtime.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 에 전달하여 초기 계측기 목록을 등록 할 수 있습니다 . &lt;a href=&quot;#trio.hazmat.add_instrument&quot;&gt; &lt;code&gt;add_instrument()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.hazmat.remove_instrument&quot;&gt; &lt;code&gt;remove_instrument()&lt;/code&gt; &lt;/a&gt; 를 사용하면 런타임시 계측기를 추가 및 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4a7bdb61256f4d0af56a70b7ef3f33efecb1a8f" translate="yes" xml:space="preserve">
          <source>You can register an initial list of instruments by passing them to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#trio.lowlevel.add_instrument&quot;&gt;&lt;code&gt;add_instrument()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#trio.lowlevel.remove_instrument&quot;&gt;&lt;code&gt;remove_instrument()&lt;/code&gt;&lt;/a&gt; let you add and remove instruments at runtime.</source>
          <target state="translated">&lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 에 전달하여 계측기의 초기 목록을 등록 할 수 있습니다 . &lt;a href=&quot;#trio.lowlevel.add_instrument&quot;&gt; &lt;code&gt;add_instrument()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#trio.lowlevel.remove_instrument&quot;&gt; &lt;code&gt;remove_instrument()&lt;/code&gt; &lt;/a&gt; 를 사용하면 런타임에 계측기를 추가하고 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72febccd38897ee2443a5e471fd47c45c93fc9ad" translate="yes" xml:space="preserve">
          <source>You can see we&amp;rsquo;re using asyncio-specific APIs to start up a loop, and then we call &lt;a href=&quot;#trio.lowlevel.start_guest_run&quot;&gt;&lt;code&gt;trio.lowlevel.start_guest_run&lt;/code&gt;&lt;/a&gt;. This function is very similar to &lt;a href=&quot;reference-core#trio.run&quot;&gt;&lt;code&gt;trio.run&lt;/code&gt;&lt;/a&gt;, and takes all the same arguments. But it has two differences:</source>
          <target state="translated">asyncio 특정 API를 사용하여 루프를 시작한 다음 &lt;a href=&quot;#trio.lowlevel.start_guest_run&quot;&gt; &lt;code&gt;trio.lowlevel.start_guest_run&lt;/code&gt; &lt;/a&gt; 을 호출하는 것을 볼 수 있습니다. 이 함수는 &lt;a href=&quot;reference-core#trio.run&quot;&gt; &lt;code&gt;trio.run&lt;/code&gt; &lt;/a&gt; 과 매우 유사하며 모두 동일한 인수를 사용합니다. 그러나 두 가지 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4d41938cec088f1203bbaddf9eb58c835315958" translate="yes" xml:space="preserve">
          <source>You can set &lt;a href=&quot;#trio.testing.MockClock.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; to 1.0 if you want it to start running in real time like a regular clock. You can stop and start the clock within a test. You can set &lt;a href=&quot;#trio.testing.MockClock.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; to 10.0 to make clock time pass at 10x real speed (so e.g. &lt;code&gt;await
trio.sleep(10)&lt;/code&gt; returns after 1 second).</source>
          <target state="translated">일반 시계처럼 실시간으로 실행을 시작하려면 &lt;a href=&quot;#trio.testing.MockClock.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt; 를 1.0으로 설정할 수 있습니다 . 테스트 내에서 시계를 중지하고 시작할 수 있습니다. &lt;a href=&quot;#trio.testing.MockClock.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt; 를 10.0으로 설정 하면 클럭 시간이 10 배 실제 속도로 전달됩니다 (예 : 1 초 후 &lt;code&gt;await trio.sleep(10)&lt;/code&gt; 반환 대기 ).</target>
        </trans-unit>
        <trans-unit id="73b14216af1fb4461a4eebe7cd333ac5fc89728c" translate="yes" xml:space="preserve">
          <source>You can think of this as being a no-operating-system-involved Trio-streamsified version of &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.pipe&quot;&gt;&lt;code&gt;os.pipe()&lt;/code&gt;&lt;/a&gt; (except that &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.pipe&quot;&gt;&lt;code&gt;os.pipe()&lt;/code&gt;&lt;/a&gt; returns the streams in the wrong order &amp;ndash; we follow the superior convention that data flows from left to right).</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/library/os.html#os.pipe&quot;&gt; &lt;code&gt;os.pipe()&lt;/code&gt; &lt;/a&gt; 의 운영 체제와 무관 한 Trio 스트림 버전으로 생각할 수 있습니다 ( &lt;a href=&quot;https://docs.python.org/3/library/os.html#os.pipe&quot;&gt; &lt;code&gt;os.pipe()&lt;/code&gt; &lt;/a&gt; 가 잘못된 순서로 스트림을 반환하는 것을 제외하고 &amp;ndash; 우리는 데이터가 흐르는 우수한 규칙을 따릅니다. 왼쪽에서 오른쪽으로).</target>
        </trans-unit>
        <trans-unit id="69f1b7fea9b89d2906468a78814a5a12c77ad0dd" translate="yes" xml:space="preserve">
          <source>You can use guest mode without reading this section. It&amp;rsquo;s included for those who enjoy understanding how things work.</source>
          <target state="translated">이 섹션을 읽지 않고도 게스트 모드를 사용할 수 있습니다. 작동 방식을 이해하는 것을 즐기는 사람들을 위해 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a193c819e0c34ae44aa174ef625aeb404927f6f" translate="yes" xml:space="preserve">
          <source>You cannot raise &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; yourself. Attempting to do so will produce a &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt;&lt;code&gt;cancel_scope.cancel()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">스스로 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 할 수 없습니다 . 그렇게하려고하면 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . 대신 &lt;a href=&quot;#trio.CancelScope.cancel&quot;&gt; &lt;code&gt;cancel_scope.cancel()&lt;/code&gt; &lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5bce218254ad16d35879a867fed587c02c4cd3c0" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to be scared of &lt;a href=&quot;#module-trio.lowlevel&quot;&gt;&lt;code&gt;trio.lowlevel&lt;/code&gt;&lt;/a&gt;, as long as you take proper precautions. These are real public APIs, with strictly defined and carefully documented semantics. They&amp;rsquo;re the same tools we use to implement all the nice high-level APIs in the &lt;a href=&quot;reference-core#module-trio&quot;&gt;&lt;code&gt;trio&lt;/code&gt;&lt;/a&gt; namespace. But, be careful. Some of those strict semantics have &lt;a href=&quot;https://en.wikipedia.org/wiki/Rabbit_of_Caerbannog&quot;&gt;nasty big pointy teeth&lt;/a&gt;. If you make a mistake, Trio may not be able to handle it gracefully; conventions and guarantees that are followed strictly in the rest of Trio do not always apply. When you use this module, it&amp;rsquo;s your job to think about how you&amp;rsquo;re going to handle the tricky cases so you can expose a friendly Trio-style API to your users.</source>
          <target state="translated">적절한 예방 조치를 취하는 한 &lt;a href=&quot;#module-trio.lowlevel&quot;&gt; &lt;code&gt;trio.lowlevel&lt;/code&gt; 을&lt;/a&gt; 두려워 할 필요가 없습니다 . 이는 엄격하게 정의되고 신중하게 문서화 된 의미를 가진 실제 공용 API입니다. &lt;a href=&quot;reference-core#module-trio&quot;&gt; &lt;code&gt;trio&lt;/code&gt; &lt;/a&gt; 네임 스페이스 에서 모든 멋진 고급 API를 구현하는 데 사용하는 것과 동일한 도구 입니다. 하지만 조심하세요. 이러한 엄격한 의미 중 일부는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Rabbit_of_Caerbannog&quot;&gt;끔찍하고 뾰족한 이빨을 가지고&lt;/a&gt; 있습니다. 실수를한다면 Trio는 그것을 우아하게 처리하지 못할 수도 있습니다. Trio의 나머지 부분에서 엄격하게 따르는 규칙과 보증이 항상 적용되는 것은 아닙니다. 이 모듈을 사용할 때 사용자에게 친숙한 Trio 스타일 API를 노출 할 수 있도록 까다로운 경우를 어떻게 처리할지 생각하는 것이 귀하의 임무입니다.</target>
        </trans-unit>
        <trans-unit id="543df5888a6f3ed554d9063bbb7beaa13887bd6f" translate="yes" xml:space="preserve">
          <source>You may not write a &lt;code&gt;yield&lt;/code&gt; statement that suspends an async generator inside a &lt;a href=&quot;#trio.CancelScope&quot;&gt;&lt;code&gt;CancelScope&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#trio.Nursery&quot;&gt;&lt;code&gt;Nursery&lt;/code&gt;&lt;/a&gt; that was entered within the generator.</source>
          <target state="translated">생성기 내에 입력 된 &lt;a href=&quot;#trio.CancelScope&quot;&gt; &lt;code&gt;CancelScope&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#trio.Nursery&quot;&gt; &lt;code&gt;Nursery&lt;/code&gt; &lt;/a&gt; 내에서 비동기 생성기를 일시 중단하는 &lt;code&gt;yield&lt;/code&gt; 문을 작성할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5562812ed84763ace42f034dbb4b06c937f902cb" translate="yes" xml:space="preserve">
          <source>You might wonder why Trio can&amp;rsquo;t just remember &amp;ldquo;this task should be cancelled in &lt;code&gt;TIMEOUT&lt;/code&gt; seconds&amp;rdquo;, even after the &lt;code&gt;with move_on_after(TIMEOUT):&lt;/code&gt; block is gone. The reason has to do with &lt;a href=&quot;#cancellation&quot;&gt;how cancellation is implemented&lt;/a&gt;. Recall that cancellation is represented by a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception, which eventually needs to be caught by the cancel scope that caused it. (Otherwise, the exception would take down your whole program!) In order to be able to cancel the child tasks, the cancel scope has to be able to &amp;ldquo;see&amp;rdquo; the &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exceptions that they raise &amp;ndash; and those exceptions come out of the &lt;code&gt;async with open_nursery()&lt;/code&gt; block, not out of the call to &lt;code&gt;start_soon()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;with move_on_after(TIMEOUT):&lt;/code&gt; 블록이 사라진 후에도 Trio가 &quot;이 작업은 &lt;code&gt;TIMEOUT&lt;/code&gt; 초 안에 취소되어야합니다&quot;를 기억하지 못하는 이유가 궁금 할 것 입니다. 그 이유는 &lt;a href=&quot;#cancellation&quot;&gt;취소가 구현&lt;/a&gt; 되는 방법 과 관련 이 있습니다 . 취소는 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외로 표시되며 결국이를 유발 한 취소 범위에 의해 포착되어야합니다. (그렇지 않으면 예외로 인해 전체 프로그램이 중단됩니다!) 자식 작업을 취소 할 수 있으려면 취소 범위에서 발생하는 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외 를 &quot;볼&quot;수 있어야 하며 이러한 예외는 &lt;code&gt;async with open_nursery()&lt;/code&gt; 나옵니다. open_nursery ()와 블록 아닌 호출 중 &lt;code&gt;start_soon()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f1409455bb648f660eba18668fa46e8d4235d51" translate="yes" xml:space="preserve">
          <source>You must have read/write permission on the specified file to connect.</source>
          <target state="translated">연결하려면 지정된 파일에 대한 읽기 / 쓰기 권한이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9591f43d82177778fbdf8368519e3866ba04c088" translate="yes" xml:space="preserve">
          <source>You need to interoperate with a C library whose API exposes raw file descriptors.</source>
          <target state="translated">API가 원시 파일 디스크립터를 노출하는 C 라이브러리와 상호 운용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3328a7e6a66ef1d404c0daf69759fecee4ace50c" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t want to use this module.</source>
          <target state="translated">이 모듈을 사용하고 싶지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="23c5814eb2e6178242ccbfbb5e6e94456da5ce51" translate="yes" xml:space="preserve">
          <source>You should also consider &lt;a href=&quot;#trio.testing.Sequencer&quot;&gt;&lt;code&gt;trio.testing.Sequencer&lt;/code&gt;&lt;/a&gt;, which provides a more explicit way to control execution ordering within a test, and will often produce more readable tests.</source>
          <target state="translated">또한 &lt;a href=&quot;#trio.testing.Sequencer&quot;&gt; &lt;code&gt;trio.testing.Sequencer&lt;/code&gt; &lt;/a&gt; 를 고려해야 합니다.이 테스트는 테스트 내에서 실행 순서를보다 명확하게 제어 할 수있는 방법을 제공하며 더 읽기 쉬운 테스트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="204fe71dc183d56082312fe6769f541d68f0c62d" translate="yes" xml:space="preserve">
          <source>You should always let the Trio run finish before stopping the host loop; if not, it may leave Trio&amp;rsquo;s internal data structures in an inconsistent state. You might be able to get away with it if you immediately exit the program, but it&amp;rsquo;s safest not to go there in the first place.</source>
          <target state="translated">호스트 루프를 중지하기 전에 항상 Trio 실행이 완료되도록해야합니다. 그렇지 않으면 Trio의 내부 데이터 구조가 일관되지 않은 상태로 남을 수 있습니다. 프로그램을 즉시 종료하면 빠져 나갈 수 있지만 처음에는 거기에 가지 않는 것이 가장 안전합니다.</target>
        </trans-unit>
        <trans-unit id="a1e951ca24f73a0b917f6fa4fccd3b6e7ff5ec1d" translate="yes" xml:space="preserve">
          <source>You should let this exception propagate, to be caught by the relevant cancel scope. To remind you of this, it inherits from &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BaseException&quot;&gt;&lt;code&gt;BaseException&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#Exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;, just like &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#SystemExit&quot;&gt;&lt;code&gt;SystemExit&lt;/code&gt;&lt;/a&gt; do. This means that if you write something like:</source>
          <target state="translated">관련 취소 범위에 의해 포착되도록이 예외를 전파해야합니다. 이를 기억하기 위해 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#SystemExit&quot;&gt; &lt;code&gt;SystemExit&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#Exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;https://docs.python.org/3/library/exceptions.html#BaseException&quot;&gt; &lt;code&gt;BaseException&lt;/code&gt; &lt;/a&gt; 에서 상속 합니다. 이것은 당신이 다음과 같은 것을 쓰는 경우를 의미합니다 :</target>
        </trans-unit>
        <trans-unit id="fedfa7c04a142224d4bfaffbb7d5f92b503396fc" translate="yes" xml:space="preserve">
          <source>You should make sure that the coroutine object has released any Trio-specific resources it has acquired (e.g. nurseries).</source>
          <target state="translated">코 루틴 오브젝트가 획득 한 트리오 관련 리소스 (예 : 보육원)를 해제했는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="9de2954124a05d7144aba1d682767a02cd6925d2" translate="yes" xml:space="preserve">
          <source>You should not assume that Trio&amp;rsquo;s internal clock matches any other clock you have access to, including the clocks of simultaneous calls to &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;trio.run()&lt;/code&gt;&lt;/a&gt; happening in other processes or threads!</source>
          <target state="translated">다른 프로세스 나 스레드에서 발생 하는 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;trio.run()&lt;/code&gt; &lt;/a&gt; 대한 동시 호출 시계를 포함하여 Trio의 내부 시계가 액세스 할 수있는 다른 시계와 일치한다고 가정해서는 안됩니다 !</target>
        </trans-unit>
        <trans-unit id="646e110f9302c40fddd2b0685842e617a4c59be2" translate="yes" xml:space="preserve">
          <source>You should not use this function to call long-running CPU-bound functions! In addition to the usual GIL-related reasons why using threads for CPU-bound work is not very effective in Python, there is an additional problem: on CPython, &lt;a href=&quot;https://bugs.python.org/issue7946&quot;&gt;CPU-bound threads tend to &amp;ldquo;starve out&amp;rdquo; IO-bound threads&lt;/a&gt;, so using threads for CPU-bound work is likely to adversely affect the main thread running Trio. If you need to do this, you&amp;rsquo;re better off using a worker process, or perhaps PyPy (which still has a GIL, but may do a better job of fairly allocating CPU time between threads).</source>
          <target state="translated">장기 실행 CPU 바운드 함수를 호출하기 위해이 함수를 사용해서는 안됩니다! CPU 바인딩 작업 스레드를 사용하는 이유 일반 GIL 관련 이유 외에도 파이썬에서 매우 효과가 없습니다, 추가 문제가 : CPython과에, &lt;a href=&quot;https://bugs.python.org/issue7946&quot;&gt;CPU 바인딩 스레드 경향 IO-바운드 스레드 &quot;을 굶어&quot;&lt;/a&gt; 그래서 사용 CPU 바운드 작업을위한 스레드는 Trio를 실행하는 기본 스레드에 부정적인 영향을 줄 수 있습니다. 이 작업을 수행 해야하는 경우 작업자 프로세스 또는 PyPy (GIL이 있지만 스레드간에 CPU 시간을 상당히 할당하는 것이 좋습니다)를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="44026b9c6a4042d112ee739a002a97d694712133" translate="yes" xml:space="preserve">
          <source>You should read the standard library&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#module-ssl&quot;&gt;&lt;code&gt;ssl&lt;/code&gt;&lt;/a&gt; documentation carefully before attempting to use this class, and probably other general documentation on SSL/TLS as well. SSL/TLS is subtle and quick to anger. Really. I&amp;rsquo;m not kidding.</source>
          <target state="translated">이 클래스를 사용하기 전에 표준 라이브러리의 &lt;a href=&quot;https://docs.python.org/3/library/ssl.html#module-ssl&quot;&gt; &lt;code&gt;ssl&lt;/code&gt; &lt;/a&gt; 문서 및 SSL / TLS에 대한 다른 일반 문서를주의 깊게 읽으십시오 . SSL / TLS는 미묘하고 분노하기 쉽습니다. 정말. 농담이 아냐.</target>
        </trans-unit>
        <trans-unit id="af994b289b9e27ca5767229787d9d523285f5cca" translate="yes" xml:space="preserve">
          <source>You should set this to the smallest value that lets you reliably avoid &amp;ldquo;false alarms&amp;rdquo; where some I/O is in flight (e.g. between two halves of a socketpair) but the threshold gets triggered and time gets advanced anyway. This will depend on the details of your tests and test environment. If you aren&amp;rsquo;t doing any I/O (like in our sleeping example above) then just set it to zero, and the clock will jump whenever all tasks are blocked.</source>
          <target state="translated">일부 I / O가 비행 중일 때 (예 : 소켓 쌍의 두 반쪽 사이) &quot;임계 경보&quot;를 안정적으로 피할 수 있도록 가장 작은 값으로 설정해야하지만 임계 값이 트리거되고 어쨌든 시간이 앞당겨집니다. 테스트 및 테스트 환경의 세부 사항에 따라 다릅니다. I / O를 수행하지 않는 경우 (위의 수면 예제와 같이) 그냥 0으로 설정하면 모든 작업이 차단 될 때마다 시계가 튀어 나옵니다.</target>
        </trans-unit>
        <trans-unit id="04dc405c41c272f00e8f03c5e75c32fa3c6f6a3d" translate="yes" xml:space="preserve">
          <source>You want to add support for a low-level operating system interface that Trio doesn&amp;rsquo;t (yet) expose, like watching a filesystem directory for changes.</source>
          <target state="translated">파일 시스템 디렉토리의 변경 사항을 보는 것과 같이 Trio가 노출하지 않은 저수준 운영 체제 인터페이스에 대한 지원을 추가하려고합니다.</target>
        </trans-unit>
        <trans-unit id="0428a04bb2f7e7b639617203dfc3e59ff2d8203f" translate="yes" xml:space="preserve">
          <source>You want to extract low-level metrics to monitor the health of your application.</source>
          <target state="translated">저수준 메트릭을 추출하여 응용 프로그램의 상태를 모니터링하려고합니다.</target>
        </trans-unit>
        <trans-unit id="05015afc873ec753584995707240d627d836bd52" translate="yes" xml:space="preserve">
          <source>You want to implement a new &lt;a href=&quot;reference-core#synchronization&quot;&gt;synchronization primitive&lt;/a&gt; that Trio doesn&amp;rsquo;t (yet) provide, like a reader-writer lock.</source>
          <target state="translated">리더 라이터 잠금과 같이 Trio가 아직 제공하지 않은 새로운 &lt;a href=&quot;reference-core#synchronization&quot;&gt;동기화 프리미티브&lt;/a&gt; 를 구현하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="07a1ae0ae940498aef5bd14407e02b773ced1132" translate="yes" xml:space="preserve">
          <source>You want to implement an interface for calling between Trio and another event loop within the same process.</source>
          <target state="translated">동일한 프로세스 내에서 Trio와 다른 이벤트 루프간에 호출하기위한 인터페이스를 구현하려고합니다.</target>
        </trans-unit>
        <trans-unit id="31b2c75a30f9f7e761cebe1120ad37fa763d46c1" translate="yes" xml:space="preserve">
          <source>You want to use a low-level operating system interface that Trio doesn&amp;rsquo;t (yet) provide its own wrappers for, like watching a filesystem directory for changes.</source>
          <target state="translated">파일 시스템 디렉토리에서 변경 사항을 확인하는 것과 같이 Trio가 (아직) 자체 래퍼를 제공하지 않는 저수준 운영 체제 인터페이스를 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="1649b9e8a04484aaf903493316e5d3972b6838bd" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re writing a debugger and want to visualize Trio&amp;rsquo;s task tree.</source>
          <target state="translated">디버거를 작성 중이며 Trio의 작업 트리를 시각화하려고합니다.</target>
        </trans-unit>
        <trans-unit id="d49ab22902a8727e54d03ba7e745316cec5707a4" translate="yes" xml:space="preserve">
          <source>Your socket object must inherit from &lt;a href=&quot;reference-io#trio.socket.SocketType&quot;&gt;&lt;code&gt;trio.socket.SocketType&lt;/code&gt;&lt;/a&gt;, which is an empty class whose only purpose is to &amp;ldquo;mark&amp;rdquo; which classes should be considered valid Trio sockets.</source>
          <target state="translated">소켓 객체는 &lt;a href=&quot;reference-io#trio.socket.SocketType&quot;&gt; &lt;code&gt;trio.socket.SocketType&lt;/code&gt; 을&lt;/a&gt; 상속 받아야합니다. 이 클래스는 어떤 클래스를 유효한 Trio 소켓으로 &quot;마킹&quot;하는 것이 유일한 빈 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="f1898341d2daec152994b3c0f65aeb8b9483cc1c" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; connected to the given file.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 주어진 파일에 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6da0b7c2a1148f6e2dd5916c9d16b09301bfe3e2" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;#trio.abc.Stream&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; connected to the given server.</source>
          <target state="translated">&lt;a href=&quot;#trio.abc.Stream&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 주어진 서버에 연결.</target>
        </trans-unit>
        <trans-unit id="6195af02e6b73eb964ad6c05d1805ab0e1d06b46" translate="yes" xml:space="preserve">
          <source>a stream connected to the given listener.</source>
          <target state="translated">지정된 청취자에 접속 된 스트림</target>
        </trans-unit>
        <trans-unit id="5039d155a71c0a5f7a2b2654ad49cb7ee47a8980" translate="yes" xml:space="preserve">
          <source>bool</source>
          <target state="translated">bool</target>
        </trans-unit>
        <trans-unit id="77cad0de53efabb9d859c964b7508191d55edb0e" translate="yes" xml:space="preserve">
          <source>but of course it may be different if you&amp;rsquo;re implementing some kind of virtual clock.</source>
          <target state="translated">물론 어떤 종류의 가상 시계를 구현하는 경우에는 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a0b61e397ac4fbba6dd82cf6b66dfb129039bb7" translate="yes" xml:space="preserve">
          <source>except that &lt;a href=&quot;#trio.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; can (and must) be called from a synchronous context.</source>
          <target state="translated">것을 제외하고 &lt;a href=&quot;#trio.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 수 (해야) 동기 컨텍스트에서 호출 할 수.</target>
        </trans-unit>
        <trans-unit id="3154e5a3874003ada68892061573dc875458ace5" translate="yes" xml:space="preserve">
          <source>except that if &lt;code&gt;sync_fn&lt;/code&gt; takes a long time, then the first line will block the Trio loop while it runs, while the second line allows other Trio tasks to continue working while &lt;code&gt;sync_fn&lt;/code&gt; runs. This is accomplished by pushing the call to &lt;code&gt;sync_fn(*args)&lt;/code&gt; off into a worker thread.</source>
          <target state="translated">경우에 것을 제외하고 &lt;code&gt;sync_fn&lt;/code&gt; 은 시간이 오래 걸립니다가 실행되는 동안 두 번째 줄은 기타 트리오 작업 동안 작업을 계속 할 수 있지만, 그 첫 번째 줄, 트리오 루프를 차단합니다 &lt;code&gt;sync_fn&lt;/code&gt; 의 실행됩니다. 이것은 &lt;code&gt;sync_fn(*args)&lt;/code&gt; 호출을 작업자 스레드로 푸시하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="685e80366130387cb75c055248326976d16fdf8d" translate="yes" xml:space="preserve">
          <source>float</source>
          <target state="translated">float</target>
        </trans-unit>
        <trans-unit id="b04aaee65bcdd5af32e5866d6ca849f2f6481299" translate="yes" xml:space="preserve">
          <source>forcibly close the socket to prevent accidental re-use</source>
          <target state="translated">실수로 재사용하지 않도록 소켓을 강제로 닫습니다.</target>
        </trans-unit>
        <trans-unit id="46f8ab7c0cff9df7cd124852e26022a6bf89e315" translate="yes" xml:space="preserve">
          <source>int</source>
          <target state="translated">int</target>
        </trans-unit>
        <trans-unit id="dc7c7a036e7ff86d7041348d3f5c595cf32f848b" translate="yes" xml:space="preserve">
          <source>is the equivalent of:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cdf2a9b9770cca84cff07c07ed209cea58b77040" translate="yes" xml:space="preserve">
          <source>list of &lt;a href=&quot;#trio.SocketListener&quot;&gt;&lt;code&gt;SocketListener&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#trio.SocketListener&quot;&gt; &lt;code&gt;SocketListener&lt;/code&gt; &lt;/a&gt; 목록</target>
        </trans-unit>
        <trans-unit id="1615307cc4523f183e777df67f168c86908e8007" translate="yes" xml:space="preserve">
          <source>object</source>
          <target state="translated">object</target>
        </trans-unit>
        <trans-unit id="91c7815e33a9c610fffab6b85965803b4c38fe10" translate="yes" xml:space="preserve">
          <source>open_ssl_over_tcp_stream</source>
          <target state="translated">open_ssl_over_tcp_stream</target>
        </trans-unit>
        <trans-unit id="9a2cd608fc634f6422fae3a1601e32e93899153a" translate="yes" xml:space="preserve">
          <source>raise &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인상이 &lt;a href=&quot;reference-core#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9fd50a36be80600cf205943240836997b4dae781" translate="yes" xml:space="preserve">
          <source>that never calls any of Trio&amp;rsquo;s async functions. This is an async function, but it&amp;rsquo;s not a checkpoint. But why make a function async if it never calls any async functions? It&amp;rsquo;s possible, but it&amp;rsquo;s a bad idea. If you have a function that&amp;rsquo;s not calling any async functions, then you should make it synchronous. The people who use your function will thank you, because it makes it obvious that your function is not a checkpoint, and their code reviews will go faster.</source>
          <target state="translated">Trio의 비동기 함수를 호출하지 않습니다. 이것은 비동기 함수이지만 체크 포인트가 아닙니다. 그러나 비동기 함수를 호출하지 않으면 왜 함수를 비 동기화합니까? 가능하지만 나쁜 생각입니다. 비동기 함수를 호출하지 않는 함수가 있으면 동기식으로 만들어야합니다. 귀하의 기능을 사용하는 사람들은 귀하의 기능이 체크 포인트가 아니며 코드 검토가 더 빨라질 것이기 때문에 감사합니다.</target>
        </trans-unit>
        <trans-unit id="c99061349fef0290fe3ca6468379aa7cff199037" translate="yes" xml:space="preserve">
          <source>the &lt;a href=&quot;#trio.hazmat.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; that called &lt;a href=&quot;#trio.hazmat.current_task&quot;&gt;&lt;code&gt;current_task()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.hazmat.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 이라고 &lt;a href=&quot;#trio.hazmat.current_task&quot;&gt; &lt;code&gt;current_task()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc61f17b652e05559394881b3db364b7f6311d91" translate="yes" xml:space="preserve">
          <source>the &lt;a href=&quot;#trio.lowlevel.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; that called &lt;a href=&quot;#trio.lowlevel.current_task&quot;&gt;&lt;code&gt;current_task()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#trio.lowlevel.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 이라고 &lt;a href=&quot;#trio.lowlevel.current_task&quot;&gt; &lt;code&gt;current_task()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a9e69b5d794e659edb00d20d3ad49a11b127477" translate="yes" xml:space="preserve">
          <source>the effective deadline, as an absolute time.</source>
          <target state="translated">효과적인 마감일, 절대 시간.</target>
        </trans-unit>
        <trans-unit id="7c3a6f266d6247d7cd771e1c325b352794e92c00" translate="yes" xml:space="preserve">
          <source>the encrypted connection to the server.</source>
          <target state="translated">서버에 대한 암호화 된 연결</target>
        </trans-unit>
        <trans-unit id="ae5091f01cda515d1f122297428e0d9d9abb842a" translate="yes" xml:space="preserve">
          <source>the newly spawned task</source>
          <target state="translated">새로 생성 된 작업</target>
        </trans-unit>
        <trans-unit id="8d6554dc96924eb4d77e3e00e5aea6f1bb8ca0a8" translate="yes" xml:space="preserve">
          <source>the program will see one argument &lt;code&gt;foo &quot;bar&quot; baz&lt;/code&gt; but CMD.EXE thinks &lt;code&gt;bar\&lt;/code&gt; is not quoted while &lt;code&gt;foo \&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; are. All of this makes it a formidable task to reliably interpolate anything into a &lt;code&gt;shell=True&lt;/code&gt; command line on Windows, and Trio falls back on the &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; behavior: If you pass a sequence with &lt;code&gt;shell=True&lt;/code&gt;, it&amp;rsquo;s quoted in the same way as a sequence with &lt;code&gt;shell=False&lt;/code&gt;, and had better not contain any shell metacharacters you weren&amp;rsquo;t planning on.</source>
          <target state="translated">프로그램은 하나의 인수 &lt;code&gt;foo &quot;bar&quot; baz&lt;/code&gt; 를 보게 되지만 CMD.EXE 는 &lt;code&gt;foo \&lt;/code&gt; 와 &lt;code&gt;baz&lt;/code&gt; 가있는 동안 &lt;code&gt;bar\&lt;/code&gt; 는 인용되지 않는다고 생각 합니다 . 이 모든 것이 Windows의 모든 것을 &lt;code&gt;shell=True&lt;/code&gt; 명령 줄에 안정적으로 보간하는 강력한 작업이 되고 Trio는 &lt;a href=&quot;https://docs.python.org/3/library/subprocess.html#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 동작으로 돌아갑니다. &lt;code&gt;shell=True&lt;/code&gt; 로 시퀀스를 전달하면 시퀀스와 동일한 방식으로 인용됩니다 와 &lt;code&gt;shell=False&lt;/code&gt; , 그리고 더 나은 당신이 계획되지 않은 모든 쉘 메타 문자를 포함하지 않았다.</target>
        </trans-unit>
        <trans-unit id="6fa9fa819747544976a8089d6e7dc99a2e72147c" translate="yes" xml:space="preserve">
          <source>then this &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; catch a &lt;a href=&quot;#trio.Cancelled&quot;&gt;&lt;code&gt;Cancelled&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">다음이 &lt;em&gt;되지 않습니다&lt;/em&gt; 잡을 &lt;a href=&quot;#trio.Cancelled&quot;&gt; &lt;code&gt;Cancelled&lt;/code&gt; &lt;/a&gt; 예외.</target>
        </trans-unit>
        <trans-unit id="7edd5a38751799f207ce0fb360ac04e15a80c88f" translate="yes" xml:space="preserve">
          <source>tl;dr: if &lt;a href=&quot;#trio.socket.SocketType.connect&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; is cancelled then the socket is left in an unknown state &amp;ndash; possibly open, and possibly closed. The only reasonable thing to do is to close it.</source>
          <target state="translated">tl; dr : &lt;a href=&quot;#trio.socket.SocketType.connect&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt; 가 취소되면 소켓은 알 수없는 상태로 남아 있습니다. 해야 할 유일한 일은 그것을 닫는 것입니다.</target>
        </trans-unit>
        <trans-unit id="87741b233c2cc78262f503491f3a8495f49cdd4b" translate="yes" xml:space="preserve">
          <source>trio.BrokenResourceError</source>
          <target state="translated">trio.BrokenResourceError</target>
        </trans-unit>
        <trans-unit id="4faabd920eda171b110adb99bf1d08894a816fee" translate="yes" xml:space="preserve">
          <source>trio.BusyResourceError</source>
          <target state="translated">trio.BusyResourceError</target>
        </trans-unit>
        <trans-unit id="9b974b873fbbaf04d4cca8052a7b3d2ca60b0e98" translate="yes" xml:space="preserve">
          <source>trio.CancelScope</source>
          <target state="translated">trio.CancelScope</target>
        </trans-unit>
        <trans-unit id="4920baa45b1585116ebf73761dd11b80179ad186" translate="yes" xml:space="preserve">
          <source>trio.CancelScope.cancel</source>
          <target state="translated">trio.CancelScope.cancel</target>
        </trans-unit>
        <trans-unit id="5c083abcb3bde71d99dde3a8c0c771447e63e638" translate="yes" xml:space="preserve">
          <source>trio.CancelScope.cancel_called</source>
          <target state="translated">trio.CancelScope.cancel_called</target>
        </trans-unit>
        <trans-unit id="b65fceeea97c4d057193f169545f18bfb650937e" translate="yes" xml:space="preserve">
          <source>trio.CancelScope.cancelled_caught</source>
          <target state="translated">trio.CancelScope.cancelled_caught</target>
        </trans-unit>
        <trans-unit id="92f92711eaa71a8239922abbd8a7439a50382a9a" translate="yes" xml:space="preserve">
          <source>trio.CancelScope.deadline</source>
          <target state="translated">trio.CancelScope.deadline</target>
        </trans-unit>
        <trans-unit id="aab9bfe917a12fd4d10b5c54ca88ed322b1a43df" translate="yes" xml:space="preserve">
          <source>trio.CancelScope.shield</source>
          <target state="translated">trio.CancelScope.shield</target>
        </trans-unit>
        <trans-unit id="1495dbc0e63e50fb15f424182d80356b99071c0e" translate="yes" xml:space="preserve">
          <source>trio.Cancelled</source>
          <target state="translated">trio.Cancelled</target>
        </trans-unit>
        <trans-unit id="38532a852db8ff465708e6832163917bbddb3987" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter</source>
          <target state="translated">trio.CapacityLimiter</target>
        </trans-unit>
        <trans-unit id="3b4e8e33e050891acdd45f38c55999072d94cb70" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.acquire</source>
          <target state="translated">trio.CapacityLimiter.acquire</target>
        </trans-unit>
        <trans-unit id="3052973e311095a945e302da012f4dd07bceb959" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.acquire_nowait</source>
          <target state="translated">trio.CapacityLimiter.acquire_nowait</target>
        </trans-unit>
        <trans-unit id="b13e58a166c12cacb75150244ed449938669b4a0" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.acquire_on_behalf_of</source>
          <target state="translated">trio.CapacityLimiter.acquire_on_behalf_of</target>
        </trans-unit>
        <trans-unit id="47131bee275ceed0ed6aac36620dfd39cdd4a597" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.acquire_on_behalf_of_nowait</source>
          <target state="translated">trio.CapacityLimiter.acquire_on_behalf_of_nowait</target>
        </trans-unit>
        <trans-unit id="46afc3cef3913298a0c33c7aa35a3bdcd7e72711" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.available_tokens</source>
          <target state="translated">trio.CapacityLimiter.available_tokens</target>
        </trans-unit>
        <trans-unit id="cf684025fd002abbf00d23c9233be969bf8e9f15" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.borrowed_tokens</source>
          <target state="translated">trio.CapacityLimiter.borrowed_tokens</target>
        </trans-unit>
        <trans-unit id="045d1df55f5452fcf6b0b4325c23468efc51d6c4" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.release</source>
          <target state="translated">trio.CapacityLimiter.release</target>
        </trans-unit>
        <trans-unit id="6577f1baeabe124f327be707f159bde14c072a24" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.release_on_behalf_of</source>
          <target state="translated">trio.CapacityLimiter.release_on_behalf_of</target>
        </trans-unit>
        <trans-unit id="c218dc105968173936e5a081bd308b738fad34a6" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.statistics</source>
          <target state="translated">trio.CapacityLimiter.statistics</target>
        </trans-unit>
        <trans-unit id="32428c009582b72108e9b490d9ca48bbe9401c5e" translate="yes" xml:space="preserve">
          <source>trio.CapacityLimiter.total_tokens</source>
          <target state="translated">trio.CapacityLimiter.total_tokens</target>
        </trans-unit>
        <trans-unit id="1b4a65eaae06c22bddd85d22bb1dece1cc6b08fd" translate="yes" xml:space="preserve">
          <source>trio.ClosedResourceError</source>
          <target state="translated">trio.ClosedResourceError</target>
        </trans-unit>
        <trans-unit id="03735eebe4de0fabd8f2c51569ca8eb6150edddf" translate="yes" xml:space="preserve">
          <source>trio.Condition</source>
          <target state="translated">trio.Condition</target>
        </trans-unit>
        <trans-unit id="64e0dacab0e79dfcf0bb3947eea1007bfbac924e" translate="yes" xml:space="preserve">
          <source>trio.Condition.acquire</source>
          <target state="translated">trio.Condition.acquire</target>
        </trans-unit>
        <trans-unit id="945d9cb0754c2dc3750f9d27bdc4dda459a3f6af" translate="yes" xml:space="preserve">
          <source>trio.Condition.acquire_nowait</source>
          <target state="translated">trio.Condition.acquire_nowait</target>
        </trans-unit>
        <trans-unit id="0315af336b1b481ab49b04b5f4582676818b0d83" translate="yes" xml:space="preserve">
          <source>trio.Condition.locked</source>
          <target state="translated">trio.Condition.locked</target>
        </trans-unit>
        <trans-unit id="1e7e83352ee370c2f4ea217a547acfdb1397f607" translate="yes" xml:space="preserve">
          <source>trio.Condition.notify</source>
          <target state="translated">trio.Condition.notify</target>
        </trans-unit>
        <trans-unit id="d848616c8fa2d1ec484c6581fcd878b027371e99" translate="yes" xml:space="preserve">
          <source>trio.Condition.notify_all</source>
          <target state="translated">trio.Condition.notify_all</target>
        </trans-unit>
        <trans-unit id="bcb4444ce5c2d6c94ebad0e952dacfe072eeca3f" translate="yes" xml:space="preserve">
          <source>trio.Condition.release</source>
          <target state="translated">trio.Condition.release</target>
        </trans-unit>
        <trans-unit id="1d036063c7c52b8c5bb70e76b16c752433f7be3e" translate="yes" xml:space="preserve">
          <source>trio.Condition.statistics</source>
          <target state="translated">trio.Condition.statistics</target>
        </trans-unit>
        <trans-unit id="2cab378407bebe21e3de6a5ec95b5425861725f2" translate="yes" xml:space="preserve">
          <source>trio.Condition.wait</source>
          <target state="translated">trio.Condition.wait</target>
        </trans-unit>
        <trans-unit id="01db248fe1d1e0822a01f6e8a8952aad1d62f2e5" translate="yes" xml:space="preserve">
          <source>trio.EndOfChannel</source>
          <target state="translated">trio.EndOfChannel</target>
        </trans-unit>
        <trans-unit id="0d63b4a5179b72b0ba26f9ac3be63b45d96e28a8" translate="yes" xml:space="preserve">
          <source>trio.Event</source>
          <target state="translated">trio.Event</target>
        </trans-unit>
        <trans-unit id="7749517203c365b1910f5484033b59c65640c5d6" translate="yes" xml:space="preserve">
          <source>trio.Event.is_set</source>
          <target state="translated">trio.Event.is_set</target>
        </trans-unit>
        <trans-unit id="e08b82b0c067915092294ab18a099e79642241c8" translate="yes" xml:space="preserve">
          <source>trio.Event.set</source>
          <target state="translated">trio.Event.set</target>
        </trans-unit>
        <trans-unit id="1ba4656fe573e30ec9e885d076bc40c88ab0fe5f" translate="yes" xml:space="preserve">
          <source>trio.Event.statistics</source>
          <target state="translated">trio.Event.statistics</target>
        </trans-unit>
        <trans-unit id="a7457b9c6a0c02333d051793fdf80df853391ca1" translate="yes" xml:space="preserve">
          <source>trio.Event.wait</source>
          <target state="translated">trio.Event.wait</target>
        </trans-unit>
        <trans-unit id="1cf59d5da988771020b3e0e7429ee4b79fa9f979" translate="yes" xml:space="preserve">
          <source>trio.Lock</source>
          <target state="translated">trio.Lock</target>
        </trans-unit>
        <trans-unit id="d633b948aa9f844cdf1b98ab6925e0bec1b2e453" translate="yes" xml:space="preserve">
          <source>trio.Lock.acquire</source>
          <target state="translated">trio.Lock.acquire</target>
        </trans-unit>
        <trans-unit id="7b361a3b5884f18821c59cd390b717c141f3a43f" translate="yes" xml:space="preserve">
          <source>trio.Lock.acquire_nowait</source>
          <target state="translated">trio.Lock.acquire_nowait</target>
        </trans-unit>
        <trans-unit id="f86da8dcc1fa815ba85e422458658e5f22adfaad" translate="yes" xml:space="preserve">
          <source>trio.Lock.locked</source>
          <target state="translated">trio.Lock.locked</target>
        </trans-unit>
        <trans-unit id="d6045a56b39447852827d60307fa7d35de7cec95" translate="yes" xml:space="preserve">
          <source>trio.Lock.release</source>
          <target state="translated">trio.Lock.release</target>
        </trans-unit>
        <trans-unit id="0b7d9e43e0be75f994ef953bcb3f4ffcec01f328" translate="yes" xml:space="preserve">
          <source>trio.Lock.statistics</source>
          <target state="translated">trio.Lock.statistics</target>
        </trans-unit>
        <trans-unit id="78e5f12a4f57d39a487d8ac0772abf229b3c4393" translate="yes" xml:space="preserve">
          <source>trio.MemoryReceiveChannel</source>
          <target state="translated">trio.MemoryReceiveChannel</target>
        </trans-unit>
        <trans-unit id="108d6e10855287c416ef308d84c8a07a06082ede" translate="yes" xml:space="preserve">
          <source>trio.MemoryReceiveChannel.clone</source>
          <target state="translated">trio.MemoryReceiveChannel.clone</target>
        </trans-unit>
        <trans-unit id="be9c3678e2d106615286508fddb65c7df45ce556" translate="yes" xml:space="preserve">
          <source>trio.MemoryReceiveChannel.receive</source>
          <target state="translated">trio.MemoryReceiveChannel.receive</target>
        </trans-unit>
        <trans-unit id="fce5a2406bed66b19c15633653eef1152daf5be5" translate="yes" xml:space="preserve">
          <source>trio.MemoryReceiveChannel.receive_nowait</source>
          <target state="translated">trio.MemoryReceiveChannel.receive_nowait</target>
        </trans-unit>
        <trans-unit id="2eb4b49e21017b91f2f304d22436616defad8fee" translate="yes" xml:space="preserve">
          <source>trio.MemorySendChannel</source>
          <target state="translated">trio.MemorySendChannel</target>
        </trans-unit>
        <trans-unit id="bfb678e05e31677cf1559641988c5b00c0904637" translate="yes" xml:space="preserve">
          <source>trio.MemorySendChannel.clone</source>
          <target state="translated">trio.MemorySendChannel.clone</target>
        </trans-unit>
        <trans-unit id="9d1deb18f57cd2514b5a2304be1926da71a96674" translate="yes" xml:space="preserve">
          <source>trio.MemorySendChannel.send</source>
          <target state="translated">trio.MemorySendChannel.send</target>
        </trans-unit>
        <trans-unit id="c2089f8aa644b3d080241ec8e934d7f188a59616" translate="yes" xml:space="preserve">
          <source>trio.MemorySendChannel.send_nowait</source>
          <target state="translated">trio.MemorySendChannel.send_nowait</target>
        </trans-unit>
        <trans-unit id="10efaedb6cf45fb2b8f43b87d918366df5336129" translate="yes" xml:space="preserve">
          <source>trio.MultiError</source>
          <target state="translated">trio.MultiError</target>
        </trans-unit>
        <trans-unit id="12d2a4e4998ebb25a094937b5055e57d835ebee4" translate="yes" xml:space="preserve">
          <source>trio.MultiError.catch</source>
          <target state="translated">trio.MultiError.catch</target>
        </trans-unit>
        <trans-unit id="26d8d3d3632d98e535d0f9572356901f2e8b3042" translate="yes" xml:space="preserve">
          <source>trio.MultiError.exceptions</source>
          <target state="translated">trio.MultiError.exceptions</target>
        </trans-unit>
        <trans-unit id="77441b639d5f7ad74295e114f74156b855cb3c8f" translate="yes" xml:space="preserve">
          <source>trio.MultiError.filter</source>
          <target state="translated">trio.MultiError.filter</target>
        </trans-unit>
        <trans-unit id="cf189386a700c42d73eee8c3145915ac2c7bc850" translate="yes" xml:space="preserve">
          <source>trio.NeedHandshakeError</source>
          <target state="translated">trio.NeedHandshakeError</target>
        </trans-unit>
        <trans-unit id="8b6fb9ab36e2a18a0e93b43db1cb843c1cd1f2d7" translate="yes" xml:space="preserve">
          <source>trio.Nursery</source>
          <target state="translated">trio.Nursery</target>
        </trans-unit>
        <trans-unit id="f2ccf4921c3ccceaa76ab2b6dfa6d5a4ff78280d" translate="yes" xml:space="preserve">
          <source>trio.Nursery.cancel_scope</source>
          <target state="translated">trio.Nursery.cancel_scope</target>
        </trans-unit>
        <trans-unit id="fef3dc2b89a4992e07e688c552617340e2a706d1" translate="yes" xml:space="preserve">
          <source>trio.Nursery.child_tasks</source>
          <target state="translated">trio.Nursery.child_tasks</target>
        </trans-unit>
        <trans-unit id="c028b5baa182961b20a38444729c66e3dba3550f" translate="yes" xml:space="preserve">
          <source>trio.Nursery.parent_task</source>
          <target state="translated">trio.Nursery.parent_task</target>
        </trans-unit>
        <trans-unit id="f13159076206ab5c13a120097ff142b2d5a80bfc" translate="yes" xml:space="preserve">
          <source>trio.Nursery.start</source>
          <target state="translated">trio.Nursery.start</target>
        </trans-unit>
        <trans-unit id="5c7547330bc7c3ee062a484a255d4bc816b39ca2" translate="yes" xml:space="preserve">
          <source>trio.Nursery.start_soon</source>
          <target state="translated">trio.Nursery.start_soon</target>
        </trans-unit>
        <trans-unit id="463adb0ec3c52ceb3274124651ede96c2f705a31" translate="yes" xml:space="preserve">
          <source>trio.Path</source>
          <target state="translated">trio.Path</target>
        </trans-unit>
        <trans-unit id="41e545b55bc4e503ae90042d0907674b234a820b" translate="yes" xml:space="preserve">
          <source>trio.Path.as_posix</source>
          <target state="translated">trio.Path.as_posix</target>
        </trans-unit>
        <trans-unit id="cecfda6d7930c6c32b4bafe8681bd75eb4b1ad5b" translate="yes" xml:space="preserve">
          <source>trio.Path.as_uri</source>
          <target state="translated">trio.Path.as_uri</target>
        </trans-unit>
        <trans-unit id="6d6a79998bb77febb7b551f992342e9a39ff8c32" translate="yes" xml:space="preserve">
          <source>trio.Path.chmod</source>
          <target state="translated">trio.Path.chmod</target>
        </trans-unit>
        <trans-unit id="6264ec9b15893969518beac5b8b6e1cf388f6b31" translate="yes" xml:space="preserve">
          <source>trio.Path.cwd</source>
          <target state="translated">trio.Path.cwd</target>
        </trans-unit>
        <trans-unit id="d65467140ed7ccbea8b30dd817d0736e31039418" translate="yes" xml:space="preserve">
          <source>trio.Path.exists</source>
          <target state="translated">trio.Path.exists</target>
        </trans-unit>
        <trans-unit id="30d399ac7574c17ad32e316771e23d797e793577" translate="yes" xml:space="preserve">
          <source>trio.Path.expanduser</source>
          <target state="translated">trio.Path.expanduser</target>
        </trans-unit>
        <trans-unit id="a7466bdf1da56d74761eca21b3ef2a6c73d12e4d" translate="yes" xml:space="preserve">
          <source>trio.Path.glob</source>
          <target state="translated">trio.Path.glob</target>
        </trans-unit>
        <trans-unit id="4bb91a142b4daab33d560e2283bdfe6a8d43099c" translate="yes" xml:space="preserve">
          <source>trio.Path.group</source>
          <target state="translated">trio.Path.group</target>
        </trans-unit>
        <trans-unit id="ba365a91df5c8a410ac32c3e4597a11db816203a" translate="yes" xml:space="preserve">
          <source>trio.Path.home</source>
          <target state="translated">trio.Path.home</target>
        </trans-unit>
        <trans-unit id="a23bb252840218cfa53d9491ae0042deb1182452" translate="yes" xml:space="preserve">
          <source>trio.Path.is_absolute</source>
          <target state="translated">trio.Path.is_absolute</target>
        </trans-unit>
        <trans-unit id="ba83d5209b0eb9a363f163ce8632091fa6f398f5" translate="yes" xml:space="preserve">
          <source>trio.Path.is_block_device</source>
          <target state="translated">trio.Path.is_block_device</target>
        </trans-unit>
        <trans-unit id="e8bbb29bda3f94e08ceabf6cb2251ce75c67502b" translate="yes" xml:space="preserve">
          <source>trio.Path.is_char_device</source>
          <target state="translated">trio.Path.is_char_device</target>
        </trans-unit>
        <trans-unit id="a30c97ff9404dfd5c2efac442bbdf5b03bf835f5" translate="yes" xml:space="preserve">
          <source>trio.Path.is_dir</source>
          <target state="translated">trio.Path.is_dir</target>
        </trans-unit>
        <trans-unit id="338b64de8263afc924e091a60925ba9a5cba1d8b" translate="yes" xml:space="preserve">
          <source>trio.Path.is_fifo</source>
          <target state="translated">trio.Path.is_fifo</target>
        </trans-unit>
        <trans-unit id="083283f1193a39af46a1511606528f334858e1c6" translate="yes" xml:space="preserve">
          <source>trio.Path.is_file</source>
          <target state="translated">trio.Path.is_file</target>
        </trans-unit>
        <trans-unit id="b132aa47c930d401ca40bbb05475e3967e345eed" translate="yes" xml:space="preserve">
          <source>trio.Path.is_reserved</source>
          <target state="translated">trio.Path.is_reserved</target>
        </trans-unit>
        <trans-unit id="2465eec20154630e31612cfe7c53c5cae0ccca8a" translate="yes" xml:space="preserve">
          <source>trio.Path.is_socket</source>
          <target state="translated">trio.Path.is_socket</target>
        </trans-unit>
        <trans-unit id="dedd6c61c0c4196e0c47a059c98257c0c014f902" translate="yes" xml:space="preserve">
          <source>trio.Path.is_symlink</source>
          <target state="translated">trio.Path.is_symlink</target>
        </trans-unit>
        <trans-unit id="aeea756d025c6726e8841678bf114ea9d53335c2" translate="yes" xml:space="preserve">
          <source>trio.Path.iterdir</source>
          <target state="translated">trio.Path.iterdir</target>
        </trans-unit>
        <trans-unit id="6c0c0f1510aa03f8fed405b70cde5c65c2d5b33b" translate="yes" xml:space="preserve">
          <source>trio.Path.joinpath</source>
          <target state="translated">trio.Path.joinpath</target>
        </trans-unit>
        <trans-unit id="ba4f894f44e4f0d7e258c49bdcda6493f84c0c68" translate="yes" xml:space="preserve">
          <source>trio.Path.lchmod</source>
          <target state="translated">trio.Path.lchmod</target>
        </trans-unit>
        <trans-unit id="65a04b36da154cf4291a3935b556c9b5bfb90056" translate="yes" xml:space="preserve">
          <source>trio.Path.lstat</source>
          <target state="translated">trio.Path.lstat</target>
        </trans-unit>
        <trans-unit id="e13a8010ede3fdd986f4892ec43fbfc932344413" translate="yes" xml:space="preserve">
          <source>trio.Path.match</source>
          <target state="translated">trio.Path.match</target>
        </trans-unit>
        <trans-unit id="76f7b3ec233072ba5f70bb91485bb5edb7d340b2" translate="yes" xml:space="preserve">
          <source>trio.Path.mkdir</source>
          <target state="translated">trio.Path.mkdir</target>
        </trans-unit>
        <trans-unit id="a2dd4873471dd5a6aa6b020c49300b224af01678" translate="yes" xml:space="preserve">
          <source>trio.Path.open</source>
          <target state="translated">trio.Path.open</target>
        </trans-unit>
        <trans-unit id="c8bc289f4e9cc9b014ae2e1257db083d3203ca15" translate="yes" xml:space="preserve">
          <source>trio.Path.owner</source>
          <target state="translated">trio.Path.owner</target>
        </trans-unit>
        <trans-unit id="ebf09093912c3958365d5ac83d0122d7b07504bd" translate="yes" xml:space="preserve">
          <source>trio.Path.read_bytes</source>
          <target state="translated">trio.Path.read_bytes</target>
        </trans-unit>
        <trans-unit id="cf4fe105374100baba575f8bba8ffd84bec3f78e" translate="yes" xml:space="preserve">
          <source>trio.Path.read_text</source>
          <target state="translated">trio.Path.read_text</target>
        </trans-unit>
        <trans-unit id="1ad287e9d5985a30f6c7df76e14f0197c127a554" translate="yes" xml:space="preserve">
          <source>trio.Path.relative_to</source>
          <target state="translated">trio.Path.relative_to</target>
        </trans-unit>
        <trans-unit id="27ea427591aefc0aa9e2e647c5a31adbb66d5bd6" translate="yes" xml:space="preserve">
          <source>trio.Path.rename</source>
          <target state="translated">trio.Path.rename</target>
        </trans-unit>
        <trans-unit id="67bb2789807e00f644acda7368543604c9281d14" translate="yes" xml:space="preserve">
          <source>trio.Path.replace</source>
          <target state="translated">trio.Path.replace</target>
        </trans-unit>
        <trans-unit id="4f1922abe367a78f3a37f31eac9705e8bc69b7cc" translate="yes" xml:space="preserve">
          <source>trio.Path.resolve</source>
          <target state="translated">trio.Path.resolve</target>
        </trans-unit>
        <trans-unit id="4fb7688f41df71cff26b44ef8e084023ce7339cd" translate="yes" xml:space="preserve">
          <source>trio.Path.rglob</source>
          <target state="translated">trio.Path.rglob</target>
        </trans-unit>
        <trans-unit id="a3d9f8e1ad0ffa9cb2844fd4b0e0e8b0acfe5062" translate="yes" xml:space="preserve">
          <source>trio.Path.rmdir</source>
          <target state="translated">trio.Path.rmdir</target>
        </trans-unit>
        <trans-unit id="06d43545f10c00eedfdd2f81fae56bc281c8cb1a" translate="yes" xml:space="preserve">
          <source>trio.Path.samefile</source>
          <target state="translated">trio.Path.samefile</target>
        </trans-unit>
        <trans-unit id="f4bb6ee0e047f6c279fa93dbe17ee0da353ca874" translate="yes" xml:space="preserve">
          <source>trio.Path.stat</source>
          <target state="translated">trio.Path.stat</target>
        </trans-unit>
        <trans-unit id="4f8149328b50af4c60f03d656293000dbab0a193" translate="yes" xml:space="preserve">
          <source>trio.Path.symlink_to</source>
          <target state="translated">trio.Path.symlink_to</target>
        </trans-unit>
        <trans-unit id="5b03e6f426a315a5a9738bb8c705186a179ad5e0" translate="yes" xml:space="preserve">
          <source>trio.Path.touch</source>
          <target state="translated">trio.Path.touch</target>
        </trans-unit>
        <trans-unit id="ca6540c33dd630ad6acc3cd3506ecea10a639a62" translate="yes" xml:space="preserve">
          <source>trio.Path.unlink</source>
          <target state="translated">trio.Path.unlink</target>
        </trans-unit>
        <trans-unit id="2b386dec09b8cbe1d4e9f4093f02277d57a00dd1" translate="yes" xml:space="preserve">
          <source>trio.Path.with_name</source>
          <target state="translated">trio.Path.with_name</target>
        </trans-unit>
        <trans-unit id="4416574f3d7a991d545312ef1d6b4dabeb1a8e03" translate="yes" xml:space="preserve">
          <source>trio.Path.with_suffix</source>
          <target state="translated">trio.Path.with_suffix</target>
        </trans-unit>
        <trans-unit id="c1c1d6c08945dc6cbdfa9d2aec8c880ce6ded5c4" translate="yes" xml:space="preserve">
          <source>trio.Path.write_bytes</source>
          <target state="translated">trio.Path.write_bytes</target>
        </trans-unit>
        <trans-unit id="92d9d90cef01964b23091f0a761cca59acc47fc7" translate="yes" xml:space="preserve">
          <source>trio.Path.write_text</source>
          <target state="translated">trio.Path.write_text</target>
        </trans-unit>
        <trans-unit id="b95629e12adfc03a5e7d69c785aafff955b36b24" translate="yes" xml:space="preserve">
          <source>trio.Process</source>
          <target state="translated">trio.Process</target>
        </trans-unit>
        <trans-unit id="d2f5180d7c9c7ab8cdfb057bb193fd6f44072ced" translate="yes" xml:space="preserve">
          <source>trio.Process.aclose</source>
          <target state="translated">trio.Process.aclose</target>
        </trans-unit>
        <trans-unit id="e46ef8b25a27e896bc157b8abb02ac109f95e179" translate="yes" xml:space="preserve">
          <source>trio.Process.args</source>
          <target state="translated">trio.Process.args</target>
        </trans-unit>
        <trans-unit id="20ac78b91fc5413a3d21c4fafeb78dfbcc69bee8" translate="yes" xml:space="preserve">
          <source>trio.Process.kill</source>
          <target state="translated">trio.Process.kill</target>
        </trans-unit>
        <trans-unit id="f146b8e74c1f60facca2f7c32f2e84ac347a94da" translate="yes" xml:space="preserve">
          <source>trio.Process.pid</source>
          <target state="translated">trio.Process.pid</target>
        </trans-unit>
        <trans-unit id="ff52c1030198fec8bcc8ee2ff4909a129ca802e1" translate="yes" xml:space="preserve">
          <source>trio.Process.poll</source>
          <target state="translated">trio.Process.poll</target>
        </trans-unit>
        <trans-unit id="bb5e8d251fd94df4b4f85a5862b90f20408f9f75" translate="yes" xml:space="preserve">
          <source>trio.Process.returncode</source>
          <target state="translated">trio.Process.returncode</target>
        </trans-unit>
        <trans-unit id="c354161dab84a8f646bfde68086236e96b786ae6" translate="yes" xml:space="preserve">
          <source>trio.Process.send_signal</source>
          <target state="translated">trio.Process.send_signal</target>
        </trans-unit>
        <trans-unit id="648b9349f3ca09033167dc6562019d96eac78908" translate="yes" xml:space="preserve">
          <source>trio.Process.stderr</source>
          <target state="translated">trio.Process.stderr</target>
        </trans-unit>
        <trans-unit id="d8d2a3dadfc889cd719749b131000d137557e183" translate="yes" xml:space="preserve">
          <source>trio.Process.stdin</source>
          <target state="translated">trio.Process.stdin</target>
        </trans-unit>
        <trans-unit id="c670edca33439e00eb71504aac27e335a8da489e" translate="yes" xml:space="preserve">
          <source>trio.Process.stdio</source>
          <target state="translated">trio.Process.stdio</target>
        </trans-unit>
        <trans-unit id="ac9fce0a07a87d83c7ddb69cdb8e00571eec76ff" translate="yes" xml:space="preserve">
          <source>trio.Process.stdout</source>
          <target state="translated">trio.Process.stdout</target>
        </trans-unit>
        <trans-unit id="b9036113d94a00c7647cc4ac4a41af6f403deffd" translate="yes" xml:space="preserve">
          <source>trio.Process.terminate</source>
          <target state="translated">trio.Process.terminate</target>
        </trans-unit>
        <trans-unit id="d66e22328aa943d8bc5fc842ae3b1def3c9703fa" translate="yes" xml:space="preserve">
          <source>trio.Process.wait</source>
          <target state="translated">trio.Process.wait</target>
        </trans-unit>
        <trans-unit id="b432532132175eedeadbd57ce4ced5ad6c997d18" translate="yes" xml:space="preserve">
          <source>trio.RunFinishedError</source>
          <target state="translated">trio.RunFinishedError</target>
        </trans-unit>
        <trans-unit id="bce53b871c5e108da130854e741bb4032af39c87" translate="yes" xml:space="preserve">
          <source>trio.SSLListener</source>
          <target state="translated">trio.SSLListener</target>
        </trans-unit>
        <trans-unit id="cdb4181469f12ac4791d59127a12109c868b4dfd" translate="yes" xml:space="preserve">
          <source>trio.SSLListener.accept</source>
          <target state="translated">trio.SSLListener.accept</target>
        </trans-unit>
        <trans-unit id="f302e75867185e0832e2c4c73b8eb88d8519658e" translate="yes" xml:space="preserve">
          <source>trio.SSLListener.aclose</source>
          <target state="translated">trio.SSLListener.aclose</target>
        </trans-unit>
        <trans-unit id="95dffd22046f979ad9e369f3b8f1cb10f3cd145e" translate="yes" xml:space="preserve">
          <source>trio.SSLListener.transport_listener</source>
          <target state="translated">trio.SSLListener.transport_listener</target>
        </trans-unit>
        <trans-unit id="79996c48b89942b0400eccfd6f3303a41e33a39d" translate="yes" xml:space="preserve">
          <source>trio.SSLStream</source>
          <target state="translated">trio.SSLStream</target>
        </trans-unit>
        <trans-unit id="645e98a80540d0f5fc979e4f5ab5805dca8e5f8b" translate="yes" xml:space="preserve">
          <source>trio.SSLStream.aclose</source>
          <target state="translated">trio.SSLStream.aclose</target>
        </trans-unit>
        <trans-unit id="b52305dacbf92d9d5dea65b87130c9231a4f9c89" translate="yes" xml:space="preserve">
          <source>trio.SSLStream.do_handshake</source>
          <target state="translated">trio.SSLStream.do_handshake</target>
        </trans-unit>
        <trans-unit id="89c72822574930e17ccd9f4f5f7c3b8a22702664" translate="yes" xml:space="preserve">
          <source>trio.SSLStream.receive_some</source>
          <target state="translated">trio.SSLStream.receive_some</target>
        </trans-unit>
        <trans-unit id="3002921c20ec1649587d2af55021784fbdb390ac" translate="yes" xml:space="preserve">
          <source>trio.SSLStream.send_all</source>
          <target state="translated">trio.SSLStream.send_all</target>
        </trans-unit>
        <trans-unit id="cb30fe2bb451948acff6bf45af2327c61664facb" translate="yes" xml:space="preserve">
          <source>trio.SSLStream.transport_stream</source>
          <target state="translated">trio.SSLStream.transport_stream</target>
        </trans-unit>
        <trans-unit id="9d336db7cf154af476ade7b29be45c39cc20929e" translate="yes" xml:space="preserve">
          <source>trio.SSLStream.unwrap</source>
          <target state="translated">trio.SSLStream.unwrap</target>
        </trans-unit>
        <trans-unit id="a7e6be5e068c0727f227d5863123f884f93ca79d" translate="yes" xml:space="preserve">
          <source>trio.SSLStream.wait_send_all_might_not_block</source>
          <target state="translated">trio.SSLStream.wait_send_all_might_not_block</target>
        </trans-unit>
        <trans-unit id="93fcd7f69d7379f91e3c378270b6a09b7029e021" translate="yes" xml:space="preserve">
          <source>trio.Semaphore</source>
          <target state="translated">trio.Semaphore</target>
        </trans-unit>
        <trans-unit id="446c68562b7734346b004f7ec3b67ca1f362370c" translate="yes" xml:space="preserve">
          <source>trio.Semaphore.acquire</source>
          <target state="translated">trio.Semaphore.acquire</target>
        </trans-unit>
        <trans-unit id="75b075b64d8547d3e44c126a255aa29665b23a25" translate="yes" xml:space="preserve">
          <source>trio.Semaphore.acquire_nowait</source>
          <target state="translated">trio.Semaphore.acquire_nowait</target>
        </trans-unit>
        <trans-unit id="6a53ec5da9ac229aa475f2ece4f15a9d57965fdc" translate="yes" xml:space="preserve">
          <source>trio.Semaphore.max_value</source>
          <target state="translated">trio.Semaphore.max_value</target>
        </trans-unit>
        <trans-unit id="a3288f42af1bb29dba4446fe8443ec9f9eaef81a" translate="yes" xml:space="preserve">
          <source>trio.Semaphore.release</source>
          <target state="translated">trio.Semaphore.release</target>
        </trans-unit>
        <trans-unit id="89e3bfe201338d35663c9d7e9f929dad41f15ed9" translate="yes" xml:space="preserve">
          <source>trio.Semaphore.statistics</source>
          <target state="translated">trio.Semaphore.statistics</target>
        </trans-unit>
        <trans-unit id="abd9e54f657a8cdc87a40ea57223a38d62753bfd" translate="yes" xml:space="preserve">
          <source>trio.Semaphore.value</source>
          <target state="translated">trio.Semaphore.value</target>
        </trans-unit>
        <trans-unit id="6672a59b097e19ef0087b1c3d92a05ad09477767" translate="yes" xml:space="preserve">
          <source>trio.SocketListener</source>
          <target state="translated">trio.SocketListener</target>
        </trans-unit>
        <trans-unit id="573ece5164e06e6877102aa0f01e2739a11c6b8f" translate="yes" xml:space="preserve">
          <source>trio.SocketListener.accept</source>
          <target state="translated">trio.SocketListener.accept</target>
        </trans-unit>
        <trans-unit id="051e34755bee16a84c1a0cecab08ff83338e64c6" translate="yes" xml:space="preserve">
          <source>trio.SocketListener.aclose</source>
          <target state="translated">trio.SocketListener.aclose</target>
        </trans-unit>
        <trans-unit id="d049939b5066435d7b4608aab55adbccac0087e4" translate="yes" xml:space="preserve">
          <source>trio.SocketListener.socket</source>
          <target state="translated">trio.SocketListener.socket</target>
        </trans-unit>
        <trans-unit id="c191148bb18311e87d520b759a81b1b1c927e0e2" translate="yes" xml:space="preserve">
          <source>trio.SocketStream</source>
          <target state="translated">trio.SocketStream</target>
        </trans-unit>
        <trans-unit id="58887391e1f3209066d0ddd1578b6380aef781be" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.aclose</source>
          <target state="translated">trio.SocketStream.aclose</target>
        </trans-unit>
        <trans-unit id="5729999279fd58366c4bfb0b3a8c4c0a356c24fd" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.getsockopt</source>
          <target state="translated">trio.SocketStream.getsockopt</target>
        </trans-unit>
        <trans-unit id="7001de0eaa68ceb88b4d87ec6024b3661d5d1d6e" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.receive_some</source>
          <target state="translated">trio.SocketStream.receive_some</target>
        </trans-unit>
        <trans-unit id="006017fa57dd7c6851aceafd2e6140dfd1d4ecbf" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.send_all</source>
          <target state="translated">trio.SocketStream.send_all</target>
        </trans-unit>
        <trans-unit id="0822c05eedf78bda8aa1f3129c7497ab6cde049e" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.send_eof</source>
          <target state="translated">trio.SocketStream.send_eof</target>
        </trans-unit>
        <trans-unit id="fd5e5376987dcf67c8f1c1799a79178982c54aa6" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.setsockopt</source>
          <target state="translated">trio.SocketStream.setsockopt</target>
        </trans-unit>
        <trans-unit id="2ccfb13b68e4da87e3f3e9169aab7bc2f28b6fb2" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.socket</source>
          <target state="translated">trio.SocketStream.socket</target>
        </trans-unit>
        <trans-unit id="598874eb3242ae514a8fee6455dac8ad34885585" translate="yes" xml:space="preserve">
          <source>trio.SocketStream.wait_send_all_might_not_block</source>
          <target state="translated">trio.SocketStream.wait_send_all_might_not_block</target>
        </trans-unit>
        <trans-unit id="f0b25cbd198f0aff922ce1337411e8c599b8626e" translate="yes" xml:space="preserve">
          <source>trio.StapledStream</source>
          <target state="translated">trio.StapledStream</target>
        </trans-unit>
        <trans-unit id="b1e796a929efe32976ccbbf7f4aaf9a055be860f" translate="yes" xml:space="preserve">
          <source>trio.StapledStream.aclose</source>
          <target state="translated">trio.StapledStream.aclose</target>
        </trans-unit>
        <trans-unit id="aaf3c1d141014c9ea813151e99d94f77261dcec5" translate="yes" xml:space="preserve">
          <source>trio.StapledStream.receive_some</source>
          <target state="translated">trio.StapledStream.receive_some</target>
        </trans-unit>
        <trans-unit id="ae7a98f57b9885892f45544c9031e8005ac5e101" translate="yes" xml:space="preserve">
          <source>trio.StapledStream.receive_stream</source>
          <target state="translated">trio.StapledStream.receive_stream</target>
        </trans-unit>
        <trans-unit id="8809f5b0ad445c8c84d7ed456ee965df79feb472" translate="yes" xml:space="preserve">
          <source>trio.StapledStream.send_all</source>
          <target state="translated">trio.StapledStream.send_all</target>
        </trans-unit>
        <trans-unit id="84451f90926f20560f3cb4d17e3415df29f62100" translate="yes" xml:space="preserve">
          <source>trio.StapledStream.send_eof</source>
          <target state="translated">trio.StapledStream.send_eof</target>
        </trans-unit>
        <trans-unit id="4daeadbd28d194d8af9d83a0ed0679e6f35c1e13" translate="yes" xml:space="preserve">
          <source>trio.StapledStream.send_stream</source>
          <target state="translated">trio.StapledStream.send_stream</target>
        </trans-unit>
        <trans-unit id="58747e02691eaca63ab2cdb5597f924661356ba4" translate="yes" xml:space="preserve">
          <source>trio.StapledStream.wait_send_all_might_not_block</source>
          <target state="translated">trio.StapledStream.wait_send_all_might_not_block</target>
        </trans-unit>
        <trans-unit id="eb243569a6081f57227d8204d5218c1af273d5ac" translate="yes" xml:space="preserve">
          <source>trio.StrictFIFOLock</source>
          <target state="translated">trio.StrictFIFOLock</target>
        </trans-unit>
        <trans-unit id="a7ffc868348e2b1bb549c2955194a01ea4a32544" translate="yes" xml:space="preserve">
          <source>trio.TASK_STATUS_IGNORED</source>
          <target state="translated">trio.TASK_STATUS_IGNORED</target>
        </trans-unit>
        <trans-unit id="97a524a1c2360898f0ed8e30706be6306ef9d6fb" translate="yes" xml:space="preserve">
          <source>trio.TooSlowError</source>
          <target state="translated">trio.TooSlowError</target>
        </trans-unit>
        <trans-unit id="e6967aa9af2be65bbf540dbefc4b412f18386250" translate="yes" xml:space="preserve">
          <source>trio.TrioDeprecationWarning</source>
          <target state="translated">trio.TrioDeprecationWarning</target>
        </trans-unit>
        <trans-unit id="2b859f724e78f2eea92dbe0623732aabd5187178" translate="yes" xml:space="preserve">
          <source>trio.TrioInternalError</source>
          <target state="translated">trio.TrioInternalError</target>
        </trans-unit>
        <trans-unit id="d11cff665946ccb7c4e80132cc152036a8b543e0" translate="yes" xml:space="preserve">
          <source>trio.WouldBlock</source>
          <target state="translated">trio.WouldBlock</target>
        </trans-unit>
        <trans-unit id="fbf8caf47f2c98a730ba658809dab466258dc2a9" translate="yes" xml:space="preserve">
          <source>trio.abc.AsyncResource</source>
          <target state="translated">trio.abc.AsyncResource</target>
        </trans-unit>
        <trans-unit id="07e3ff9f796d690cd8d79f3f7784b479e27a36f0" translate="yes" xml:space="preserve">
          <source>trio.abc.AsyncResource.aclose</source>
          <target state="translated">trio.abc.AsyncResource.aclose</target>
        </trans-unit>
        <trans-unit id="d32cbf56b9c66b5bf5b84cfa7570bc5ee714ed86" translate="yes" xml:space="preserve">
          <source>trio.abc.Channel</source>
          <target state="translated">trio.abc.Channel</target>
        </trans-unit>
        <trans-unit id="cf0b67646f860ba83529d6cfca33cbd0e97dca38" translate="yes" xml:space="preserve">
          <source>trio.abc.Clock</source>
          <target state="translated">trio.abc.Clock</target>
        </trans-unit>
        <trans-unit id="d52f66c93d4495665ab26099ed7b068f6cd203e6" translate="yes" xml:space="preserve">
          <source>trio.abc.Clock.current_time</source>
          <target state="translated">trio.abc.Clock.current_time</target>
        </trans-unit>
        <trans-unit id="f1a7fef84be7807e06b8b7dd84fe96cdfbbd48f9" translate="yes" xml:space="preserve">
          <source>trio.abc.Clock.deadline_to_sleep_time</source>
          <target state="translated">trio.abc.Clock.deadline_to_sleep_time</target>
        </trans-unit>
        <trans-unit id="ff88985411e05fc4d0b682c576478f9112e54adb" translate="yes" xml:space="preserve">
          <source>trio.abc.Clock.start_clock</source>
          <target state="translated">trio.abc.Clock.start_clock</target>
        </trans-unit>
        <trans-unit id="6986a2b982b300d850b2477f83d550cffe3bc8ae" translate="yes" xml:space="preserve">
          <source>trio.abc.HalfCloseableStream</source>
          <target state="translated">trio.abc.HalfCloseableStream</target>
        </trans-unit>
        <trans-unit id="c45633c9dfa79dd633fb54068082b704754ed07b" translate="yes" xml:space="preserve">
          <source>trio.abc.HalfCloseableStream.send_eof</source>
          <target state="translated">trio.abc.HalfCloseableStream.send_eof</target>
        </trans-unit>
        <trans-unit id="630c0829d3b5cfda2a1efaebc01a6f9583ce5e32" translate="yes" xml:space="preserve">
          <source>trio.abc.HostnameResolver</source>
          <target state="translated">trio.abc.HostnameResolver</target>
        </trans-unit>
        <trans-unit id="9c26a30a634f130875e71d3a150545a949fc3cc3" translate="yes" xml:space="preserve">
          <source>trio.abc.HostnameResolver.getaddrinfo</source>
          <target state="translated">trio.abc.HostnameResolver.getaddrinfo</target>
        </trans-unit>
        <trans-unit id="518f335eed6739fe65675a4da68068cf6bdd9179" translate="yes" xml:space="preserve">
          <source>trio.abc.HostnameResolver.getnameinfo</source>
          <target state="translated">trio.abc.HostnameResolver.getnameinfo</target>
        </trans-unit>
        <trans-unit id="ca02f199a706165019ed7e899f41ae04559afcf4" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument</source>
          <target state="translated">trio.abc.Instrument</target>
        </trans-unit>
        <trans-unit id="abbd578ff4be0f40ba1220d1654182bb8dbb8609" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.after_io_wait</source>
          <target state="translated">trio.abc.Instrument.after_io_wait</target>
        </trans-unit>
        <trans-unit id="6b4f0df1942088a8b3fde54ae3e4285cfa335df0" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.after_run</source>
          <target state="translated">trio.abc.Instrument.after_run</target>
        </trans-unit>
        <trans-unit id="9d2a080e54970c6be1816f191d83ff6d04d0e40c" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.after_task_step</source>
          <target state="translated">trio.abc.Instrument.after_task_step</target>
        </trans-unit>
        <trans-unit id="4361f635d71a758a9adde1728397da0822b10a13" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.before_io_wait</source>
          <target state="translated">trio.abc.Instrument.before_io_wait</target>
        </trans-unit>
        <trans-unit id="128c7bd9c708ce137b8843bc3355cd9027f7b0bc" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.before_run</source>
          <target state="translated">trio.abc.Instrument.before_run</target>
        </trans-unit>
        <trans-unit id="85b3a68f0879649aa55a24d2e511b418d6c4a43f" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.before_task_step</source>
          <target state="translated">trio.abc.Instrument.before_task_step</target>
        </trans-unit>
        <trans-unit id="8f7ff4336e933b1b02b2f738ebd4bca20edc230b" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.task_exited</source>
          <target state="translated">trio.abc.Instrument.task_exited</target>
        </trans-unit>
        <trans-unit id="0ace6f37e85d9ec3cee4794ba270896f458c271a" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.task_scheduled</source>
          <target state="translated">trio.abc.Instrument.task_scheduled</target>
        </trans-unit>
        <trans-unit id="948d439cba0c022dd5e4d79c05ee926690872dfd" translate="yes" xml:space="preserve">
          <source>trio.abc.Instrument.task_spawned</source>
          <target state="translated">trio.abc.Instrument.task_spawned</target>
        </trans-unit>
        <trans-unit id="479b49e402879c8bb9a8813835609fe333eec049" translate="yes" xml:space="preserve">
          <source>trio.abc.Listener</source>
          <target state="translated">trio.abc.Listener</target>
        </trans-unit>
        <trans-unit id="faf59a5191994ddc91a905b69d50a6fdcb2bb91a" translate="yes" xml:space="preserve">
          <source>trio.abc.Listener.accept</source>
          <target state="translated">trio.abc.Listener.accept</target>
        </trans-unit>
        <trans-unit id="11a8ca4b2a10b40b651ee6e3e4a485c8ce5729c6" translate="yes" xml:space="preserve">
          <source>trio.abc.ReceiveChannel</source>
          <target state="translated">trio.abc.ReceiveChannel</target>
        </trans-unit>
        <trans-unit id="8f5272bbf2d6d6ea5aa8d69f5ec576bda366b97a" translate="yes" xml:space="preserve">
          <source>trio.abc.ReceiveChannel.receive</source>
          <target state="translated">trio.abc.ReceiveChannel.receive</target>
        </trans-unit>
        <trans-unit id="8ff4757b11937d63b37e8aa3d5ca5f62956f27dc" translate="yes" xml:space="preserve">
          <source>trio.abc.ReceiveStream</source>
          <target state="translated">trio.abc.ReceiveStream</target>
        </trans-unit>
        <trans-unit id="103f585fa049eb15732cd91de190ce1fb66ad415" translate="yes" xml:space="preserve">
          <source>trio.abc.ReceiveStream.receive_some</source>
          <target state="translated">trio.abc.ReceiveStream.receive_some</target>
        </trans-unit>
        <trans-unit id="ec0bf54c4a17cd287b0b6948ce1407941c029db3" translate="yes" xml:space="preserve">
          <source>trio.abc.SendChannel</source>
          <target state="translated">trio.abc.SendChannel</target>
        </trans-unit>
        <trans-unit id="4bb34e9f5441d0ab60cbc5f81d54df92d996c605" translate="yes" xml:space="preserve">
          <source>trio.abc.SendChannel.send</source>
          <target state="translated">trio.abc.SendChannel.send</target>
        </trans-unit>
        <trans-unit id="812c79fe7c4be2cda1926b1b3c68147871d92d78" translate="yes" xml:space="preserve">
          <source>trio.abc.SendStream</source>
          <target state="translated">trio.abc.SendStream</target>
        </trans-unit>
        <trans-unit id="9ea7cce2e94368540e71097dfd062909f5823556" translate="yes" xml:space="preserve">
          <source>trio.abc.SendStream.send_all</source>
          <target state="translated">trio.abc.SendStream.send_all</target>
        </trans-unit>
        <trans-unit id="74ca6d13717caddcc1355c383047884dfcf4a246" translate="yes" xml:space="preserve">
          <source>trio.abc.SendStream.wait_send_all_might_not_block</source>
          <target state="translated">trio.abc.SendStream.wait_send_all_might_not_block</target>
        </trans-unit>
        <trans-unit id="b3a30fa4477d253d399deb43c2a5cf8562308fe1" translate="yes" xml:space="preserve">
          <source>trio.abc.SocketFactory</source>
          <target state="translated">trio.abc.SocketFactory</target>
        </trans-unit>
        <trans-unit id="7c176ab4103725dd085cf08d565805a2387f9b7c" translate="yes" xml:space="preserve">
          <source>trio.abc.SocketFactory.socket</source>
          <target state="translated">trio.abc.SocketFactory.socket</target>
        </trans-unit>
        <trans-unit id="e17d6e3baeab9874433e202357ba447d3f416bc6" translate="yes" xml:space="preserve">
          <source>trio.abc.Stream</source>
          <target state="translated">trio.abc.Stream</target>
        </trans-unit>
        <trans-unit id="f7fc3bd6afe008621c22586b6a2e7b2f157bfd8b" translate="yes" xml:space="preserve">
          <source>trio.aclose_forcefully</source>
          <target state="translated">trio.aclose_forcefully</target>
        </trans-unit>
        <trans-unit id="1de4150cbe33c076476a2121992ac29e2c3f9b9d" translate="yes" xml:space="preserve">
          <source>trio.current_effective_deadline</source>
          <target state="translated">trio.current_effective_deadline</target>
        </trans-unit>
        <trans-unit id="2eed66b6fa7b295fcdfa9190b7b5631f534b593e" translate="yes" xml:space="preserve">
          <source>trio.current_time</source>
          <target state="translated">trio.current_time</target>
        </trans-unit>
        <trans-unit id="938182158eed707ca8eac00a5679e54d7f6d5b20" translate="yes" xml:space="preserve">
          <source>trio.fail_after</source>
          <target state="translated">trio.fail_after</target>
        </trans-unit>
        <trans-unit id="fc10176acce1e6bef6492d1be9c92700b8319114" translate="yes" xml:space="preserve">
          <source>trio.fail_at</source>
          <target state="translated">trio.fail_at</target>
        </trans-unit>
        <trans-unit id="68e9a720bb3ea9f731b8be00de5b43e71c78928a" translate="yes" xml:space="preserve">
          <source>trio.from_thread.run</source>
          <target state="translated">trio.from_thread.run</target>
        </trans-unit>
        <trans-unit id="582f09672f0c15e6f6f0f6e120aebcf92841eab8" translate="yes" xml:space="preserve">
          <source>trio.from_thread.run_sync</source>
          <target state="translated">trio.from_thread.run_sync</target>
        </trans-unit>
        <trans-unit id="377d7ee8dfeaa1f955cdcc0eecf94dfe241249aa" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Abort</source>
          <target state="translated">trio.hazmat.Abort</target>
        </trans-unit>
        <trans-unit id="fee31b3594e531e910ebde4880eb8e586e8f3cd0" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Abort.FAILED</source>
          <target state="translated">trio.hazmat.Abort.FAILED</target>
        </trans-unit>
        <trans-unit id="efd549a2453ca696b6ead7dc567431072bce92b8" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Abort.SUCCEEDED</source>
          <target state="translated">trio.hazmat.Abort.SUCCEEDED</target>
        </trans-unit>
        <trans-unit id="66f4aa9273b57f40b6dcebdfb61b6cd599528994" translate="yes" xml:space="preserve">
          <source>trio.hazmat.FdStream</source>
          <target state="translated">trio.hazmat.FdStream</target>
        </trans-unit>
        <trans-unit id="55f183b8e8aa301ba8b3a72227da949e9e1e6296" translate="yes" xml:space="preserve">
          <source>trio.hazmat.ParkingLot</source>
          <target state="translated">trio.hazmat.ParkingLot</target>
        </trans-unit>
        <trans-unit id="67eee9dbc5fa3716dd2fad16fdea9e70570de9a2" translate="yes" xml:space="preserve">
          <source>trio.hazmat.ParkingLot.park</source>
          <target state="translated">trio.hazmat.ParkingLot.park</target>
        </trans-unit>
        <trans-unit id="5de001a607de1ce79a0247d9f4b2e617e0cf4e83" translate="yes" xml:space="preserve">
          <source>trio.hazmat.ParkingLot.repark</source>
          <target state="translated">trio.hazmat.ParkingLot.repark</target>
        </trans-unit>
        <trans-unit id="4a72401f77c127ac32bc77daf922333487dce815" translate="yes" xml:space="preserve">
          <source>trio.hazmat.ParkingLot.repark_all</source>
          <target state="translated">trio.hazmat.ParkingLot.repark_all</target>
        </trans-unit>
        <trans-unit id="283dd5ef0d92c78b9e243497d9151f1f44822e85" translate="yes" xml:space="preserve">
          <source>trio.hazmat.ParkingLot.statistics</source>
          <target state="translated">trio.hazmat.ParkingLot.statistics</target>
        </trans-unit>
        <trans-unit id="7fafec417f86a26523d900ff7b228b917db6f4b0" translate="yes" xml:space="preserve">
          <source>trio.hazmat.ParkingLot.unpark</source>
          <target state="translated">trio.hazmat.ParkingLot.unpark</target>
        </trans-unit>
        <trans-unit id="5c10855950b05e29e910ba2b1d95243db34992ee" translate="yes" xml:space="preserve">
          <source>trio.hazmat.ParkingLot.unpark_all</source>
          <target state="translated">trio.hazmat.ParkingLot.unpark_all</target>
        </trans-unit>
        <trans-unit id="958db2dba257a5c4b74b1715a40b00963f64ff73" translate="yes" xml:space="preserve">
          <source>trio.hazmat.RunVar</source>
          <target state="translated">trio.hazmat.RunVar</target>
        </trans-unit>
        <trans-unit id="1f93d61cfb062684edcab4666c7a9094ad92be02" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Task</source>
          <target state="translated">trio.hazmat.Task</target>
        </trans-unit>
        <trans-unit id="56007a256133264ebe4115d7d758619c3a3188d7" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Task.child_nurseries</source>
          <target state="translated">trio.hazmat.Task.child_nurseries</target>
        </trans-unit>
        <trans-unit id="0f2bc5c4aa63929d0a3ad363dc71ca1df17f91d2" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Task.context</source>
          <target state="translated">trio.hazmat.Task.context</target>
        </trans-unit>
        <trans-unit id="959f45a936e9a2d50a91f2e723a17ed6a35c6416" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Task.coro</source>
          <target state="translated">trio.hazmat.Task.coro</target>
        </trans-unit>
        <trans-unit id="313d68ca9b0270eb8d4634469d04d80cb05bd795" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Task.custom_sleep_data</source>
          <target state="translated">trio.hazmat.Task.custom_sleep_data</target>
        </trans-unit>
        <trans-unit id="4cdfd05a664da3de9c44529c01c083d0ca7faa5d" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Task.name</source>
          <target state="translated">trio.hazmat.Task.name</target>
        </trans-unit>
        <trans-unit id="b9e333285fe3a864a13b34b091cc530be8a15966" translate="yes" xml:space="preserve">
          <source>trio.hazmat.Task.parent_nursery</source>
          <target state="translated">trio.hazmat.Task.parent_nursery</target>
        </trans-unit>
        <trans-unit id="b19a9a96b81abb9460c908a51450e66b85e95559" translate="yes" xml:space="preserve">
          <source>trio.hazmat.TrioToken</source>
          <target state="translated">trio.hazmat.TrioToken</target>
        </trans-unit>
        <trans-unit id="37a507b84454a6d2e51a96f14c36d027ca8254c2" translate="yes" xml:space="preserve">
          <source>trio.hazmat.TrioToken.run_sync_soon</source>
          <target state="translated">trio.hazmat.TrioToken.run_sync_soon</target>
        </trans-unit>
        <trans-unit id="0a6d9b1a7e2e0e14ca83f31bf2ecbc93dbe19578" translate="yes" xml:space="preserve">
          <source>trio.hazmat.WaitForSingleObject</source>
          <target state="translated">trio.hazmat.WaitForSingleObject</target>
        </trans-unit>
        <trans-unit id="7e7ad7d21c4f47b50214ccbcc8b698c85d6fbf18" translate="yes" xml:space="preserve">
          <source>trio.hazmat.add_instrument</source>
          <target state="translated">trio.hazmat.add_instrument</target>
        </trans-unit>
        <trans-unit id="5f8c563ff87b2dc8c8567e1809ee11a4bc7a2c64" translate="yes" xml:space="preserve">
          <source>trio.hazmat.cancel_shielded_checkpoint</source>
          <target state="translated">trio.hazmat.cancel_shielded_checkpoint</target>
        </trans-unit>
        <trans-unit id="85633e0b57f589bc43be76f6e91b99ee40c1b5ff" translate="yes" xml:space="preserve">
          <source>trio.hazmat.checkpoint</source>
          <target state="translated">trio.hazmat.checkpoint</target>
        </trans-unit>
        <trans-unit id="cff2493b6d0ffc2dd73a3c90865e7edbdc9d0fd6" translate="yes" xml:space="preserve">
          <source>trio.hazmat.checkpoint_if_cancelled</source>
          <target state="translated">trio.hazmat.checkpoint_if_cancelled</target>
        </trans-unit>
        <trans-unit id="4be8b9e956d11a82d9df0d01738b7e04fbdcbe0f" translate="yes" xml:space="preserve">
          <source>trio.hazmat.current_clock</source>
          <target state="translated">trio.hazmat.current_clock</target>
        </trans-unit>
        <trans-unit id="13992abda4562f03ffaedab3ba0d10e06b9d8d0d" translate="yes" xml:space="preserve">
          <source>trio.hazmat.current_iocp</source>
          <target state="translated">trio.hazmat.current_iocp</target>
        </trans-unit>
        <trans-unit id="112caae5ed90caa79dbadc12c74111a7de07ea48" translate="yes" xml:space="preserve">
          <source>trio.hazmat.current_kqueue</source>
          <target state="translated">trio.hazmat.current_kqueue</target>
        </trans-unit>
        <trans-unit id="335b5e41a591c612c8ddf22ad88c78fd3c5d1ea6" translate="yes" xml:space="preserve">
          <source>trio.hazmat.current_root_task</source>
          <target state="translated">trio.hazmat.current_root_task</target>
        </trans-unit>
        <trans-unit id="af6409a5d25b2b2e0d63989673f5312d8a0f9cb5" translate="yes" xml:space="preserve">
          <source>trio.hazmat.current_statistics</source>
          <target state="translated">trio.hazmat.current_statistics</target>
        </trans-unit>
        <trans-unit id="c67b6b454c3d3c97bb7113fc85b6278d74a0a307" translate="yes" xml:space="preserve">
          <source>trio.hazmat.current_task</source>
          <target state="translated">trio.hazmat.current_task</target>
        </trans-unit>
        <trans-unit id="b484dd3f465efe0b9dee8c719d8199ff988ce36e" translate="yes" xml:space="preserve">
          <source>trio.hazmat.current_trio_token</source>
          <target state="translated">trio.hazmat.current_trio_token</target>
        </trans-unit>
        <trans-unit id="8138820f0643fc08460f2bb8e6511445b9034283" translate="yes" xml:space="preserve">
          <source>trio.hazmat.currently_ki_protected</source>
          <target state="translated">trio.hazmat.currently_ki_protected</target>
        </trans-unit>
        <trans-unit id="8807d9ce19d767ec2d4a0209f2bd1965a7bb6d38" translate="yes" xml:space="preserve">
          <source>trio.hazmat.disable_ki_protection</source>
          <target state="translated">trio.hazmat.disable_ki_protection</target>
        </trans-unit>
        <trans-unit id="35d42be3848d0f524edc56bc03f5ae81cdbd0e48" translate="yes" xml:space="preserve">
          <source>trio.hazmat.enable_ki_protection</source>
          <target state="translated">trio.hazmat.enable_ki_protection</target>
        </trans-unit>
        <trans-unit id="cfdb8ae674ad966b4d6f83b7a671c2961fd4e11e" translate="yes" xml:space="preserve">
          <source>trio.hazmat.monitor_completion_key</source>
          <target state="translated">trio.hazmat.monitor_completion_key</target>
        </trans-unit>
        <trans-unit id="d4385c84878e7961508daf0e399885ff854f078d" translate="yes" xml:space="preserve">
          <source>trio.hazmat.monitor_kevent</source>
          <target state="translated">trio.hazmat.monitor_kevent</target>
        </trans-unit>
        <trans-unit id="4fb524c029651259b6fac24963efdbc39d2d5810" translate="yes" xml:space="preserve">
          <source>trio.hazmat.notify_closing</source>
          <target state="translated">trio.hazmat.notify_closing</target>
        </trans-unit>
        <trans-unit id="58d9922fc01e695e176b3398900c1620474e05c0" translate="yes" xml:space="preserve">
          <source>trio.hazmat.permanently_detach_coroutine_object</source>
          <target state="translated">trio.hazmat.permanently_detach_coroutine_object</target>
        </trans-unit>
        <trans-unit id="8c6ec7a98ae29137ac6d5e2456a2ace284513d5f" translate="yes" xml:space="preserve">
          <source>trio.hazmat.reattach_detached_coroutine_object</source>
          <target state="translated">trio.hazmat.reattach_detached_coroutine_object</target>
        </trans-unit>
        <trans-unit id="c0ba6fb9beaafb11725d65a4d0264cf061506303" translate="yes" xml:space="preserve">
          <source>trio.hazmat.register_with_iocp</source>
          <target state="translated">trio.hazmat.register_with_iocp</target>
        </trans-unit>
        <trans-unit id="039dfbc898635052d0b99cd4c0854c35ced8d62a" translate="yes" xml:space="preserve">
          <source>trio.hazmat.remove_instrument</source>
          <target state="translated">trio.hazmat.remove_instrument</target>
        </trans-unit>
        <trans-unit id="21cb4fca281bd3691ebdd610cf7380b46b8d9c95" translate="yes" xml:space="preserve">
          <source>trio.hazmat.reschedule</source>
          <target state="translated">trio.hazmat.reschedule</target>
        </trans-unit>
        <trans-unit id="31c9a34db2dedb44f9338528684664cc72019f27" translate="yes" xml:space="preserve">
          <source>trio.hazmat.spawn_system_task</source>
          <target state="translated">trio.hazmat.spawn_system_task</target>
        </trans-unit>
        <trans-unit id="2e93cd9997ade187a201b987881484fcdf10252d" translate="yes" xml:space="preserve">
          <source>trio.hazmat.temporarily_detach_coroutine_object</source>
          <target state="translated">trio.hazmat.temporarily_detach_coroutine_object</target>
        </trans-unit>
        <trans-unit id="01e35385fad5b8340d4043e9ea3ab8e8e3501272" translate="yes" xml:space="preserve">
          <source>trio.hazmat.wait_kevent</source>
          <target state="translated">trio.hazmat.wait_kevent</target>
        </trans-unit>
        <trans-unit id="ec1925b3d06a473de1bbb73be3a3249a85084112" translate="yes" xml:space="preserve">
          <source>trio.hazmat.wait_overlapped</source>
          <target state="translated">trio.hazmat.wait_overlapped</target>
        </trans-unit>
        <trans-unit id="5c765a44e4d626e47e9d5612642e37cd06f7ab07" translate="yes" xml:space="preserve">
          <source>trio.hazmat.wait_readable</source>
          <target state="translated">trio.hazmat.wait_readable</target>
        </trans-unit>
        <trans-unit id="74f4e8f2e74570c40c909004495b6b1bc32b9f59" translate="yes" xml:space="preserve">
          <source>trio.hazmat.wait_task_rescheduled</source>
          <target state="translated">trio.hazmat.wait_task_rescheduled</target>
        </trans-unit>
        <trans-unit id="e180f2ed412288cb211c9350ccba8227a3b316f2" translate="yes" xml:space="preserve">
          <source>trio.hazmat.wait_writable</source>
          <target state="translated">trio.hazmat.wait_writable</target>
        </trans-unit>
        <trans-unit id="9f444e9cbb8a420ba7ff593b384dc73e7d19fdef" translate="yes" xml:space="preserve">
          <source>trio.move_on_after</source>
          <target state="translated">trio.move_on_after</target>
        </trans-unit>
        <trans-unit id="a63324b5d22beb567290f5e13959b101ac7e184d" translate="yes" xml:space="preserve">
          <source>trio.move_on_at</source>
          <target state="translated">trio.move_on_at</target>
        </trans-unit>
        <trans-unit id="b597ce79b7ab201268d48e583367c8625ba81ee7" translate="yes" xml:space="preserve">
          <source>trio.open_file</source>
          <target state="translated">trio.open_file</target>
        </trans-unit>
        <trans-unit id="335505d82feadb66202dab64fbaea820c83950a3" translate="yes" xml:space="preserve">
          <source>trio.open_memory_channel</source>
          <target state="translated">trio.open_memory_channel</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
