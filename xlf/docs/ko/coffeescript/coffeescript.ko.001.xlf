<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="coffeescript">
    <body>
      <group id="coffeescript">
        <trans-unit id="e11557a88106e7fe5bb613921c6f637bccd31989" translate="yes" xml:space="preserve">
          <source>%%</source>
          <target state="translated">%%</target>
        </trans-unit>
        <trans-unit id="7ccf396b1e0174237c52a3c6bc495b340169bd3c" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2009&amp;ndash;2018 Jeremy Ashkenas</source>
          <target state="translated">&amp;copy; 2009&amp;ndash;2018 제레미 애쉬 케 나스</target>
        </trans-unit>
        <trans-unit id="959d8557a2e201cd876ef4c8e1965cfdffff28c6" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2009&amp;ndash;2020 Jeremy Ashkenas</source>
          <target state="translated">&amp;copy; 2009&amp;ndash;2020 Jeremy Ashkenas</target>
        </trans-unit>
        <trans-unit id="e00eab0c44161a5c6e125f234cee4992a6fcd8e4" translate="yes" xml:space="preserve">
          <source>&amp;hellip;and object properties.</source>
          <target state="translated">&amp;hellip; 및 객체 속성.</target>
        </trans-unit>
        <trans-unit id="73dd43829ef8eae899eaf52c55d9ad5b84c8821f" translate="yes" xml:space="preserve">
          <source>&amp;quot;text/coffeescript&amp;quot; Script Tags</source>
          <target state="translated">&quot;텍스트 / 커피 스크립트&quot;스크립트 설명</target>
        </trans-unit>
        <trans-unit id="bc2f74c22f98f7b6ffbc2f67453dbfa99bce9a32" translate="yes" xml:space="preserve">
          <source>**</source>
          <target state="translated">**</target>
        </trans-unit>
        <trans-unit id="ebbffb7d7ea5362a22bfa1bab0bfdeb1617cd610" translate="yes" xml:space="preserve">
          <source>//</source>
          <target state="translated">//</target>
        </trans-unit>
        <trans-unit id="53f56e39c6568e87ed693f2d221db24632d7aa00" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#modules&quot;&gt;Modules&lt;/a&gt; and &lt;a href=&quot;#jsx&quot;&gt;JSX&lt;/a&gt; always require transpilation.</source>
          <target state="translated">&lt;a href=&quot;#modules&quot;&gt;모듈&lt;/a&gt; 과 &lt;a href=&quot;#jsx&quot;&gt;JSX는&lt;/a&gt; 항상 변환이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2b5a9a675a7d370676eff4f216883a2020ccc476" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://coffeescript.org/#splats&quot;&gt;Splats, a.k.a. object rest/spread syntax, for objects&lt;/a&gt; are supported by Node 8.6+.</source>
          <target state="translated">&lt;a href=&quot;https://coffeescript.org/#splats&quot;&gt;오브젝트에 대한 스&lt;/a&gt; 플랫 ( 일명 오브젝트 레스트 / 스프레드 구문)은 노드 8.6 이상에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7f2498c383e4e6502a04279ccad6e370f86b3e20" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports&quot;&gt;Dynamic import&lt;/a&gt; is also supported, with mandatory parentheses:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Dynamic_Imports&quot;&gt;&lt;/a&gt;필수 괄호와 함께 동적 가져 오기도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f82ee4d52cb6f66ab432c78025692d4f93c8400d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/react/docs/introducing-jsx.html&quot;&gt;JSX&lt;/a&gt; is JavaScript containing interspersed XML elements. While conceived for &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;, it is not specific to any particular library or framework.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/react/docs/introducing-jsx.html&quot;&gt;JSX&lt;/a&gt; 는 산재 된 XML 요소를 포함하는 JavaScript입니다. &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; 용으로 고안되었지만 특정 라이브러리 또는 프레임 워크에만 국한되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ab0d5c504f451bb7b8744a031b2895facf00809" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;Async generator functions&lt;/a&gt; are supported by Node 10+.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tc39/proposal-async-iteration&quot;&gt;비동기 생성기 기능&lt;/a&gt; 은 노드 10 이상에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="3eea75d33a4b7141282062785cc396fb0821bbd2" translate="yes" xml:space="preserve">
          <source>&lt;code id=&quot;this&quot;&gt;@&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">&lt;code id=&quot;this&quot;&gt;@&lt;/code&gt; , &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6bddde52d2ce96695935a88af3457fe562602600" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;text/coffeescript&quot;&lt;/code&gt; Script Tags</source>
          <target state="translated">&lt;code&gt;&quot;text/coffeescript&quot;&lt;/code&gt; 스크립트 &quot; 스크립트 설명</target>
        </trans-unit>
        <trans-unit id="4f3b179798446cf0398649b8ad3d668bf9055a6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--bare&lt;/code&gt; and &lt;code&gt;--no-header&lt;/code&gt; are important because Flow requires the first line of the file to be the comment &lt;code&gt;// @flow&lt;/code&gt;. If you configure your build chain to compile CoffeeScript and pass the result to Flow in-memory, you can get better performance than this example; and a proper build tool should be able to watch your CoffeeScript files and recompile and type-check them for you on save.</source>
          <target state="translated">&lt;code&gt;--bare&lt;/code&gt; Flow는 파일의 첫 번째 줄이 &lt;code&gt;// @flow&lt;/code&gt; 주석이어야하므로 --bare 및 &lt;code&gt;--no-header&lt;/code&gt; 가 중요합니다 . CoffeeScript를 컴파일하고 결과를 Flow in-memory로 전달하도록 빌드 체인을 구성하면이 예제보다 더 나은 성능을 얻을 수 있습니다. 적절한 빌드 도구를 사용하면 CoffeeScript 파일을보고 다시 컴파일하고 저장시 유형을 확인할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4d635daf3b49933b2580d4b7f115dbf3f7192ece" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a?(b, c)&lt;/code&gt; or &lt;code&gt;a? b, c&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a?(b, c)&lt;/code&gt; 또는 &lt;code&gt;a? b, c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b195b055ae12191320d58268dcf96e63ba61e34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a?.b&lt;/code&gt; or &lt;code&gt;a?['b']&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a?.b&lt;/code&gt; 또는 &lt;code&gt;a?['b']&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f26a6ff56f6f4d1453881906a2fedcfdf70a4192" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;console.log sys.inspect object&lt;/code&gt; &amp;rarr; &lt;code&gt;console.log(sys.inspect(object));&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;console.log sys.inspect object&lt;/code&gt; &amp;rarr; &lt;code&gt;console.log(sys.inspect(object));&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="671572b1210bb1454fe66f9c4630dc77eb820b08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt;, &lt;code&gt;no&lt;/code&gt;, &lt;code&gt;off&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; , &lt;code&gt;no&lt;/code&gt; , &lt;code&gt;off&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08092e8ae424c160938c270677dd88a77a69c59c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; keyword shorthand syntax</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 키워드 축약 구문 가져 오기 및 &lt;code&gt;set&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6797ae36e87fa19e1efa9483eaa78cd02c6979d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;, as keywords preceding functions or class methods, are intentionally unimplemented in CoffeeScript.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 함수 또는 클래스 메소드 앞에있는 키워드 인 get 및 &lt;code&gt;set&lt;/code&gt; 은 CoffeeScript에서 의도적으로 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b4e24c06746537f3bcc316c7b684e6a1288745a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; statements can be written without the use of parentheses and curly brackets. As with functions and other block expressions, multi-line conditionals are delimited by indentation. There&amp;rsquo;s also a handy postfix form, with the &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;unless&lt;/code&gt; at the end.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; 문은 괄호와 중괄호를 사용하지 않고 작성할 수 있습니다. 함수 및 기타 블록 표현식과 마찬가지로 여러 줄 조건문은 들여 쓰기로 구분됩니다. 편리한 후위 형태는 함께도 있습니다 &lt;code&gt;if&lt;/code&gt; 또는 &lt;code&gt;unless&lt;/code&gt; 끝.</target>
        </trans-unit>
        <trans-unit id="c898449ed9c27c9ce84efe5f7a1f6fed9d1a6120" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; add a useful ability to JavaScript in that you can use them to declare variables within a &lt;em&gt;block&lt;/em&gt; scope, for example within an &lt;code&gt;if&lt;/code&gt; statement body or a &lt;code&gt;for&lt;/code&gt; loop body, whereas &lt;code&gt;var&lt;/code&gt; always declares variables in the scope of an entire function. When CoffeeScript 2 was designed, there was much discussion of whether this functionality was useful enough to outweigh the simplicity offered by never needing to consider variable declaration in CoffeeScript. In the end, it was decided that the simplicity was more valued. In CoffeeScript there remains only one type of variable.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt; 당신이 내에서 변수를 선언하는 데 사용할 수 있다는 점에서 자바 스크립트에 유용한 기능을 추가 &lt;em&gt;블록&lt;/em&gt; 내에서, 예를 들어, 범위 &lt;code&gt;if&lt;/code&gt; 문 본체 나 &lt;code&gt;for&lt;/code&gt; 반면, 루프 몸 &lt;code&gt;var&lt;/code&gt; 에 항상 전체 함수의 범위에서 변수를 선언합니다. CoffeeScript 2를 디자인 할 때이 기능이 CoffeeScript에서 변수 선언을 고려할 필요가없는 단순성을 능가하는 데 유용한 지 여부에 대해 많은 논의가있었습니다. 결국, 단순성이 더 가치 있다고 결정되었습니다. CoffeeScript에는 변수 유형이 하나만 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d755861b046842e4e015fd91408805286afea66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;: block-scoped and reassignment-protected variables</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; : 블록 범위 및 재 할당 방지 변수</target>
        </trans-unit>
        <trans-unit id="024f6866b7e8235b2a23e7de0819061f8e8113b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options.ast&lt;/code&gt;, boolean: if true, return an abstract syntax tree of the input CoffeeScript source code.</source>
          <target state="translated">&lt;code&gt;options.ast&lt;/code&gt; , boolean : true이면 입력 CoffeeScript 소스 코드의 추상 구문 트리를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="69bdd67b5f2fb2b4bc55bed7c7cf382b91714c45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options.bare&lt;/code&gt;, boolean: if true, output without the &lt;a href=&quot;#lexical-scope&quot;&gt;top-level function safety wrapper&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;options.bare&lt;/code&gt; , boolean : true 인 경우 &lt;a href=&quot;#lexical-scope&quot;&gt;최상위 함수 안전 래퍼&lt;/a&gt; 없이 출력됩니다 .</target>
        </trans-unit>
        <trans-unit id="7e88224b1d5d85954af2e05694587845ce15ef6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options.filename&lt;/code&gt;, string: the filename to use for the source map. It can include a path (relative or absolute).</source>
          <target state="translated">&lt;code&gt;options.filename&lt;/code&gt; , string : 소스 맵에 사용할 파일 이름입니다. 경로 (상대 또는 절대)를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0668f9660893b6c173226ef928d6f8c135d49c5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options.header&lt;/code&gt;, boolean: if true, output the &lt;code&gt;Generated by CoffeeScript&lt;/code&gt; header.</source>
          <target state="translated">&lt;code&gt;options.header&lt;/code&gt; , boolean : true 인 경우 &lt;code&gt;Generated by CoffeeScript&lt;/code&gt; 헤더를 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="5d11ef802af0f76e518643ed277b582fea058806" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options.inlineMap&lt;/code&gt;, boolean: if true, output the source map as a base64-encoded string in a comment at the bottom.</source>
          <target state="translated">&lt;code&gt;options.inlineMap&lt;/code&gt; , boolean : true 인 경우 소스 맵을 하단의 주석에 base64로 인코딩 된 문자열로 출력합니다.</target>
        </trans-unit>
        <trans-unit id="0e70b1c0b6768b86125fef4bd20eb872934d31f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options.sourceMap&lt;/code&gt;, boolean: if true, a source map will be generated; and instead of returning a string, &lt;code&gt;compile&lt;/code&gt; will return an object of the form &lt;code&gt;{js, v3SourceMap, sourceMap}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;options.sourceMap&lt;/code&gt; , boolean : true 인 경우 소스 맵이 생성됩니다. 그리고 문자열을 반환하는 대신 &lt;code&gt;compile&lt;/code&gt; 은 &lt;code&gt;{js, v3SourceMap, sourceMap}&lt;/code&gt; 형식의 객체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bd359cce40eaca31c9f0f745fb688f4ff5606e6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options.transpile&lt;/code&gt;, &lt;strong&gt;object&lt;/strong&gt;: if set, this must be an object with the &lt;a href=&quot;https://babeljs.io/docs/usage/api/#options&quot;&gt;options to pass to Babel&lt;/a&gt;. See &lt;a href=&quot;#transpilation&quot;&gt;Transpilation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;options.transpile&lt;/code&gt; , &lt;strong&gt;object&lt;/strong&gt; : 설정되면 &lt;a href=&quot;https://babeljs.io/docs/usage/api/#options&quot;&gt;Babel에 전달할 옵션&lt;/a&gt; 이있는 객체 여야합니다 . &lt;a href=&quot;#transpilation&quot;&gt;Transpilation을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="42ddf3bee0d00b958b57a4f0c778746594dce840" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;require()&lt;/code&gt; the given module before starting the REPL or evaluating the code given with the &lt;code&gt;--eval&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;require()&lt;/code&gt; REPL을 시작하거나 &lt;code&gt;--eval&lt;/code&gt; 플래그로 지정된 코드를 평가하기 전에 지정된 모듈을 요구 하십시오 .</target>
        </trans-unit>
        <trans-unit id="da337d04d46816ce3f960cc13a8c58049d709032" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;super&lt;/code&gt; and &lt;code&gt;extends&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;super&lt;/code&gt; 와 &lt;code&gt;extends&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f91468df92b13b248660811a65d1664a64a85a87" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;super&lt;/code&gt; and &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;super&lt;/code&gt; 와 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="febc77da193c1450f3079a54b815c08cfb84cae7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switch&lt;/code&gt; statements can also be used without a control expression, turning them in to a cleaner alternative to &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; chains.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 문은 제어 표현식 없이도 사용할 수 있으므로 &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; 체인 에 대한 명확한 대안으로 전환합니다 .</target>
        </trans-unit>
        <trans-unit id="f14836fb2c4f448ff7f89a8d54a114f65adceb8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switch&lt;/code&gt; statements in JavaScript are a bit awkward. You need to remember to &lt;code&gt;break&lt;/code&gt; at the end of every &lt;code&gt;case&lt;/code&gt; statement to avoid accidentally falling through to the default case. CoffeeScript prevents accidental fall-through, and can convert the &lt;code&gt;switch&lt;/code&gt; into a returnable, assignable expression. The format is: &lt;code&gt;switch&lt;/code&gt; condition, &lt;code&gt;when&lt;/code&gt; clauses, &lt;code&gt;else&lt;/code&gt; the default case.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; JavaScript의 switch 문은 약간 어색합니다. 당신은 기억 할 필요가 &lt;code&gt;break&lt;/code&gt; 때마다 말 &lt;code&gt;case&lt;/code&gt; 기본 케이스를 통해 떨어지는 실수 피하기 위해 문. CoffeeScript는 실수로 넘어지지 않도록하며 &lt;code&gt;switch&lt;/code&gt; 를 반환 가능한 할당 가능한 식으로 변환 할 수 있습니다 . 형식은 &lt;code&gt;switch&lt;/code&gt; 조건, &lt;code&gt;when&lt;/code&gt; 절, &lt;code&gt;else&lt;/code&gt; 기본 경우입니다.</target>
        </trans-unit>
        <trans-unit id="beb8408aed5d5e0b2e7958d3840c0f622534b644" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;yes&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; , &lt;code&gt;yes&lt;/code&gt; , &lt;code&gt;on&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4cfd4f6560eea48a3bbb6452c625b3643616abf4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;try&lt;/code&gt; expressions have the same semantics as &lt;code&gt;try&lt;/code&gt; statements in JavaScript, though in CoffeeScript, you may omit &lt;em&gt;both&lt;/em&gt; the catch and finally parts. The catch part may also omit the error parameter if it is not needed.</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 표현식은 JavaScript의 &lt;code&gt;try&lt;/code&gt; 문과 동일한 의미를 갖지만 CoffeeScript에서는 catch 부분과 finally 부분을 &lt;em&gt;모두&lt;/em&gt; 생략 할 수 있습니다. 캐치 파트는 필요하지 않은 경우 오류 매개 변수를 생략 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4068635871de89a0425d7ae15c3ee28c166fda6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unless&lt;/code&gt; can be used as the inverse of &lt;code&gt;if&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;unless&lt;/code&gt; 의 역수로 사용될 수 &lt;code&gt;if&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="146594e8060979ead0f6d28256eb4ef1779d3dcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield*&lt;/code&gt; is called &lt;code&gt;yield from&lt;/code&gt;, and &lt;code&gt;yield return&lt;/code&gt; may be used if you need to force a generator that doesn&amp;rsquo;t yield.</source>
          <target state="translated">&lt;code&gt;yield*&lt;/code&gt; 는 &lt;code&gt;yield from&lt;/code&gt; 이라고 하며 , &lt;code&gt;yield return&lt;/code&gt; 하지 않는 제너레이터를 강제해야하는 경우 항복 수익률 이 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eea76de22707204f2de04392630e2b08c9b49475" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;CoffeeScript on the topleft, compiled JavaScript output on the bottomright. The CoffeeScript is editable!&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;왼쪽 상단에 CoffeeScript가 있고 오른쪽 하단에 컴파일 된 JavaScript 출력입니다. CoffeeScript는 편집 가능합니다!&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7315b2762c97737d5039c4b20d8a25a1b9ad4687" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Many of the examples can be run (where it makes sense) by pressing the&lt;/em&gt;&lt;small&gt;▶&lt;/small&gt;&lt;em&gt;button on the right. The CoffeeScript on the left is editable, and the JavaScript will update as you edit.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;&lt;em&gt;오른쪽에있는 &lt;/em&gt;&lt;small&gt;▶ &lt;/small&gt;&lt;em&gt;버튼을 &lt;/em&gt;&lt;em&gt;누르면 많은 예제를 실행할 수 있습니다 &lt;/em&gt;&lt;em&gt;. 왼쪽의 CoffeeScript는 편집 가능하며, 편집 할 때 JavaScript가 업데이트됩니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c277fcd54562e2635bc26a8132a87027a7d6a56f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This reference is structured so that it can be read from top to bottom, if you like. Later sections use ideas and syntax previously introduced. Familiarity with JavaScript is assumed. In all of the following examples, the source CoffeeScript is provided on the left, and the direct compilation into JavaScript is on the right.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;이 참조는 원하는 경우 위에서 아래로 읽을 수 있도록 구성되어 있습니다. 이후 섹션에서는 이전에 소개 된 아이디어와 구문을 사용합니다. JavaScript에 익숙하다고 가정합니다. 다음의 모든 예에서 소스 CoffeeScript는 왼쪽에 제공되며 JavaScript로 직접 컴파일하는 것은 오른쪽에 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a3e61d6a409d40b1cc7e66218d36a04024655912" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CoffeeScript is a little language that compiles into JavaScript.&lt;/strong&gt; Underneath that awkward Java-esque patina, JavaScript has always had a gorgeous heart. CoffeeScript is an attempt to expose the good parts of JavaScript in a simple way.</source>
          <target state="translated">&lt;strong&gt;CoffeeScript는 JavaScript로 컴파일되는 작은 언어입니다. &lt;/strong&gt;그 어색한 자바 풍 파티 나 아래, JavaScript는 항상 화려한 마음을 가졌습니다. CoffeeScript는 JavaScript의 좋은 부분을 간단한 방법으로 노출시키려는 시도입니다.</target>
        </trans-unit>
        <trans-unit id="3a49dc083df4f29ffc84eceec33918bc2ac078a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Latest Version:&lt;/strong&gt;&lt;a href=&quot;https://github.com/jashkenas/coffeescript/tarball/2.4.1&quot;&gt;2.4.1&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;최신 버전 : &lt;/strong&gt;&lt;a href=&quot;https://github.com/jashkenas/coffeescript/tarball/2.4.1&quot;&gt;2.4.1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f5f3c90a7e6596edc44c5d04e245bb687eccf3e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Latest Version:&lt;/strong&gt;&lt;a href=&quot;https://github.com/jashkenas/coffeescript/tarball/2.5.1&quot;&gt;2.5.1&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;최신 버전 : &lt;/strong&gt;&lt;a href=&quot;https://github.com/jashkenas/coffeescript/tarball/2.5.1&quot;&gt;2.5.1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9a78211436f6d425ec38f5c4e02270801f3524f8" translate="yes" xml:space="preserve">
          <source>@</source>
          <target state="translated">@</target>
        </trans-unit>
        <trans-unit id="749387032ae04dba9bbbf8a243b19977245cf1a6" translate="yes" xml:space="preserve">
          <source>A few caveats:</source>
          <target state="translated">몇 가지주의 사항 :</target>
        </trans-unit>
        <trans-unit id="2992ef6e06f5285c1589f15bbd6cdefabccc9e93" translate="yes" xml:space="preserve">
          <source>All together now, watch and recompile an entire project as you work on it:</source>
          <target state="translated">이제 모두 함께 작업하면서 전체 프로젝트를보고 다시 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="ef9a81eb41028081130a2daf5219d439c4552d2b" translate="yes" xml:space="preserve">
          <source>All together now:</source>
          <target state="translated">이제 모두 함께 :</target>
        </trans-unit>
        <trans-unit id="de911cf89f46bf4aab8399057a0b6f4d24430428" translate="yes" xml:space="preserve">
          <source>Along those lines, code blocks within list items or blockquotes are not treated as executable code. Since list items and blockquotes imply their own indentation, it would be ambiguous how to treat indentation between successive code blocks when some are within these other blocks and some are not.</source>
          <target state="translated">이러한 행과 함께 목록 항목 또는 블록 인용 부호 내의 코드 블록은 실행 코드로 취급되지 않습니다. 목록 항목과 블록 인용 부호는 고유 한 들여 쓰기를 의미하기 때문에 일부는 이러한 다른 블록 내에 있고 일부는 그렇지 않은 경우 연속 코드 블록 사이에서 들여 쓰기를 처리하는 방법이 모호합니다.</target>
        </trans-unit>
        <trans-unit id="f205799358de5de3653ec6932d7fc9cc5631d19a" translate="yes" xml:space="preserve">
          <source>Also note that any file with an &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; statement will be output without a &lt;a href=&quot;#lexical-scope&quot;&gt;top-level function safety wrapper&lt;/a&gt;; in other words, importing or exporting modules will automatically trigger &lt;a href=&quot;#usage&quot;&gt;bare&lt;/a&gt; mode for that file. This is because per the ES2015 spec, &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; statements must occur at the topmost scope.</source>
          <target state="translated">또한 &lt;code&gt;import&lt;/code&gt; 또는 &lt;code&gt;export&lt;/code&gt; 문이 있는 파일은 &lt;a href=&quot;#lexical-scope&quot;&gt;최상위 함수 안전 래퍼&lt;/a&gt; 없이 출력됩니다 . 즉, 모듈을 가져 오거나 내 보내면 해당 파일에 대한 &lt;a href=&quot;#usage&quot;&gt;베어&lt;/a&gt; 모드 가 자동으로 트리거 됩니다. ES2015 사양에 따라 &lt;code&gt;import&lt;/code&gt; 또는 &lt;code&gt;export&lt;/code&gt; 문이 최상위 범위에서 발생해야 하기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="8d8c347317a31c9b96b2eb66a2e233fab6fd3515" translate="yes" xml:space="preserve">
          <source>Although suppressed within this documentation for clarity, all CoffeeScript output (except in files with &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; statements) is wrapped in an anonymous function: &lt;code&gt;(function(){ &amp;hellip; })();&lt;/code&gt;. This safety wrapper, combined with the automatic generation of the &lt;code&gt;var&lt;/code&gt; keyword, make it exceedingly difficult to pollute the global namespace by accident. (The safety wrapper can be disabled with the &lt;a href=&quot;#usage&quot;&gt;&lt;code&gt;bare&lt;/code&gt; option&lt;/a&gt;, and is unnecessary and automatically disabled when using modules.)</source>
          <target state="translated">이 설명서에서는 명확성을 위해 표시되지 않았지만 모든 CoffeeScript 출력 ( &lt;code&gt;import&lt;/code&gt; 또는 &lt;code&gt;export&lt;/code&gt; 문이 있는 파일 제외 )은 익명 함수로 래핑됩니다. &lt;code&gt;(function(){ &amp;hellip; })();&lt;/code&gt; . &lt;code&gt;var&lt;/code&gt; 키워드 의 자동 생성과 결합 된이 안전 래퍼 는 우연히 전역 네임 스페이스를 오염시키는 것을 매우 어렵게 만듭니다. 안전 래퍼는 &lt;a href=&quot;#usage&quot;&gt; &lt;code&gt;bare&lt;/code&gt; 옵션&lt;/a&gt; 으로 비활성화 할 수 있으며 , 모듈을 사용할 때는 필요하지 않으며 자동으로 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="d1862e82363559b6fb9a22118afd3352933e73f2" translate="yes" xml:space="preserve">
          <source>Argument parsing and shebang (&lt;code&gt;#!&lt;/code&gt;) lines</source>
          <target state="translated">인수 구문 분석 및 shebang ( &lt;code&gt;#!&lt;/code&gt; ) 행</target>
        </trans-unit>
        <trans-unit id="65f9c0eea18b31eb35e30364b4d18f13f72f3e80" translate="yes" xml:space="preserve">
          <source>Arguments can be forwarded explicitly using splats:</source>
          <target state="translated">스 플랫을 사용하여 인수를 명시 적으로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc8d4bce0a86d2f62284d889ea176cb257eb81cf" translate="yes" xml:space="preserve">
          <source>Array Slicing and Splicing with Ranges</source>
          <target state="translated">범위와 배열 슬라이싱 및 스 플라이 싱</target>
        </trans-unit>
        <trans-unit id="9ba9135f5143cdbcf8f067d358d2f101a0291868" translate="yes" xml:space="preserve">
          <source>As a shortcut for &lt;code&gt;this.property&lt;/code&gt;, you can use &lt;code&gt;@property&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this.property&lt;/code&gt; 의 바로 가기로 &lt;code&gt;@property&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d5ff33811e35eec43fb0c6d044ee1aebaa01617" translate="yes" xml:space="preserve">
          <source>As in &lt;a href=&quot;http://yaml.org/&quot;&gt;YAML&lt;/a&gt;, &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;yes&lt;/code&gt; are the same as boolean &lt;code&gt;true&lt;/code&gt;, while &lt;code&gt;off&lt;/code&gt; and &lt;code&gt;no&lt;/code&gt; are boolean &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;http://yaml.org/&quot;&gt;YAML&lt;/a&gt; , &lt;code&gt;on&lt;/code&gt; 와 &lt;code&gt;yes&lt;/code&gt; 부울과 동일 &lt;code&gt;true&lt;/code&gt; 동안, &lt;code&gt;off&lt;/code&gt; 와 &lt;code&gt;no&lt;/code&gt; 부울없는 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c940962594d626d789e7139cf6327778f46a3c66" translate="yes" xml:space="preserve">
          <source>As in Ruby, &lt;code&gt;switch&lt;/code&gt; statements in CoffeeScript can take multiple values for each &lt;code&gt;when&lt;/code&gt; clause. If any of the values match, the clause runs.</source>
          <target state="translated">Ruby에서와 같이 CoffeeScript의 &lt;code&gt;switch&lt;/code&gt; 문은 각 &lt;code&gt;when&lt;/code&gt; 절 에 대해 여러 값을 가질 수 있습니다 . 값이 일치하면 절이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="785872c21d2152c8e487aa14ed3c436575fb2e25" translate="yes" xml:space="preserve">
          <source>As well as silly things, like passing a &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; statement directly into a function call:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 문을 함수 호출에 직접 전달하는 것과 같은 바보 같은 것들 :</target>
        </trans-unit>
        <trans-unit id="e17003d05d795ba33cb9b8fb93fce1a1e17abcdc" translate="yes" xml:space="preserve">
          <source>Async Functions</source>
          <target state="translated">비동기 함수</target>
        </trans-unit>
        <trans-unit id="baaf2143528768ba7feea8a142baf40647bed225" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;==&lt;/code&gt; operator frequently causes undesirable coercion, is intransitive, and has a different meaning than in other languages, CoffeeScript compiles &lt;code&gt;==&lt;/code&gt; into &lt;code&gt;===&lt;/code&gt;, and &lt;code&gt;!=&lt;/code&gt; into &lt;code&gt;!==&lt;/code&gt;. In addition, &lt;code&gt;is&lt;/code&gt; compiles into &lt;code&gt;===&lt;/code&gt;, and &lt;code&gt;isnt&lt;/code&gt; into &lt;code&gt;!==&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 연산자는 바람직하지 않은 강제 변환을 유발하고, 전 이적이지 않으며 다른 언어와 다른 의미를 갖기 때문에 CoffeeScript는 &lt;code&gt;==&lt;/code&gt; 를 &lt;code&gt;===&lt;/code&gt; 로 , &lt;code&gt;!=&lt;/code&gt; 를 &lt;code&gt;!==&lt;/code&gt; 로 컴파일합니다 . 또한, &lt;code&gt;is&lt;/code&gt; 로 컴파일 &lt;code&gt;===&lt;/code&gt; 하고, &lt;code&gt;isnt&lt;/code&gt; 에 &lt;code&gt;!==&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48eae9d012f5bd3812c09f9e579487b2ac854c74" translate="yes" xml:space="preserve">
          <source>Because variable declarations occur at the top of scope, assignment can be used within expressions, even for variables that haven&amp;rsquo;t been seen before:</source>
          <target state="translated">변수 선언은 범위 맨 위에서 발생하기 때문에 이전에는 보지 못한 변수에 대해서도 표현식 내에서 대입을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a73ea1c2b90501e9d317af3a06faec56721a224" translate="yes" xml:space="preserve">
          <source>Because you don&amp;rsquo;t have direct access to the &lt;code&gt;var&lt;/code&gt; keyword, it&amp;rsquo;s impossible to shadow an outer variable on purpose, you may only refer to it. So be careful that you&amp;rsquo;re not reusing the name of an external variable accidentally, if you&amp;rsquo;re writing a deeply nested function.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 키워드에 직접 액세스 할 수 없으므로 외부 변수를 의도적으로 음영 처리 할 수 ​​없으며 참조 만 할 수 있습니다. 따라서 깊이 중첩 된 함수를 작성하는 경우 실수로 외부 변수의 이름을 재사용하지 않도록주의하십시오.</target>
        </trans-unit>
        <trans-unit id="500d6e30307a158cda828a2b4b51aff3d203b972" translate="yes" xml:space="preserve">
          <source>Besides being used as an ordinary programming language, CoffeeScript may also be written in &amp;ldquo;literate&amp;rdquo; mode. If you name your file with a &lt;code&gt;.litcoffee&lt;/code&gt; extension, you can write it as a Markdown document &amp;mdash; a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown&amp;rsquo;s way of indicating source code) as executable code, and ignore the rest as comments. Code blocks must also be separated from comments by at least one blank line.</source>
          <target state="translated">CoffeeScript는 일반적인 프로그래밍 언어로 사용되는 것 외에도 &quot;literate&quot;모드로 작성 될 수 있습니다. &lt;code&gt;.litcoffee&lt;/code&gt; 확장자를 사용 하여 파일 이름을 지정하면 파일을 마크 다운 문서로 작성할 수 있습니다.이 문서는 실행 가능한 CoffeeScript 코드이기도합니다. 컴파일러는 들여 쓰기 된 블록 (Markdown의 소스 코드를 나타내는 방식)을 실행 가능한 코드로 취급하고 나머지는 주석으로 무시합니다. 코드 블록은 하나 이상의 빈 줄로 주석과 분리해야합니다.</target>
        </trans-unit>
        <trans-unit id="52c6757f76d4c59aa1a2f5c458ff43e37ce42012" translate="yes" xml:space="preserve">
          <source>Block Regular Expressions</source>
          <target state="translated">정규식 차단</target>
        </trans-unit>
        <trans-unit id="88e6d3a6135787b6b130ff7bc9cdd589be5f2a49" translate="yes" xml:space="preserve">
          <source>Block strings, delimited by &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; or &lt;code&gt;'''&lt;/code&gt;, can be used to hold formatted or indentation-sensitive text (or, if you just don&amp;rsquo;t feel like escaping quotes and apostrophes). The indentation level that begins the block is maintained throughout, so you can keep it all aligned with the body of your code.</source>
          <target state="translated">&lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 또는 &lt;code&gt;'''&lt;/code&gt; 구분 된 블록 문자열을 사용하여 서식이 있거나 들여 쓰기에 민감한 텍스트를 보유 할 수 있습니다 (또는 따옴표와 아포스트로피를 이탈하고 싶지 않은 경우). 블록을 시작하는 들여 쓰기 수준이 유지됩니다. 코드 본문에 맞춰 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0860d71a0ec2e658f3d9a3738433ca07ec8f0787" translate="yes" xml:space="preserve">
          <source>Bound (Fat Arrow) Functions</source>
          <target state="translated">바운드 (Fat Arrow) 기능</target>
        </trans-unit>
        <trans-unit id="c0919393bb78439cc6bdad954e816bfa9e7b5395" translate="yes" xml:space="preserve">
          <source>Bound (fat arrow) functions</source>
          <target state="translated">바운드 (뚱뚱한 화살표) 기능</target>
        </trans-unit>
        <trans-unit id="3146c3bce8a6f3c5954cf4d17548170dd8fa9a5d" translate="yes" xml:space="preserve">
          <source>Bound generator functions</source>
          <target state="translated">바운드 제너레이터 기능</target>
        </trans-unit>
        <trans-unit id="66a99a10fccdc00a933b3a257862c3f84baadadd" translate="yes" xml:space="preserve">
          <source>Bound generator functions, a.k.a. generator arrow functions, &lt;a href=&quot;https://stackoverflow.com/questions/27661306/can-i-use-es6s-arrow-function-syntax-with-generators-arrow-notation&quot;&gt;aren&amp;rsquo;t allowed in ECMAScript&lt;/a&gt;. You can write &lt;code&gt;function*&lt;/code&gt; or &lt;code&gt;=&amp;gt;&lt;/code&gt;, but not both. Therefore, CoffeeScript code like this:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/27661306/can-i-use-es6s-arrow-function-syntax-with-generators-arrow-notation&quot;&gt;ECMAScript&lt;/a&gt; 에서는 일명 생성기 화살표 기능인 바운드 생성기 기능을 사용할 수 없습니다 . &lt;code&gt;function*&lt;/code&gt; 또는 &lt;code&gt;=&amp;gt;&lt;/code&gt; 을 쓸 수 있지만 둘 다 쓸 수는 없습니다. 따라서 CoffeeScript 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3f1d6f17ca16b010bf909bd90956813c62360340" translate="yes" xml:space="preserve">
          <source>Breaking Changes From 1.x</source>
          <target state="translated">1.x의 주요 변경 사항</target>
        </trans-unit>
        <trans-unit id="3501da7b50f11f0bed95d1651f5526076186c9d5" translate="yes" xml:space="preserve">
          <source>Breaking Changes From CoffeeScript 1.x to 2</source>
          <target state="translated">CoffeeScript 1.x에서 2 로의 주요 변경 사항</target>
        </trans-unit>
        <trans-unit id="476e56d0eff6f65aab9d09fede93409b5105aa4b" translate="yes" xml:space="preserve">
          <source>But it&amp;rsquo;s also helpful for dealing with functions that return multiple values.</source>
          <target state="translated">그러나 여러 값을 반환하는 함수를 처리하는데도 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="eed3eed03e17d439596291023c0881f19f4179f4" translate="yes" xml:space="preserve">
          <source>By default, Babel doesn&amp;rsquo;t do anything&amp;mdash;it doesn&amp;rsquo;t make assumptions about what you want to transpile to. You need to provide it with a configuration so that it knows what to do. One way to do this is by creating a &lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt;&lt;code&gt;.babelrc&lt;/code&gt; file&lt;/a&gt; in the folder containing the files you&amp;rsquo;re compiling, or in any parent folder up the path above those files. (Babel supports &lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt;other ways&lt;/a&gt;, too.) A minimal &lt;code&gt;.babelrc&lt;/code&gt; file would be just &lt;code&gt;{ &quot;presets&quot;: [&quot;@babel/env&quot;] }&lt;/code&gt;. This implies that you have installed &lt;a href=&quot;https://babeljs.io/docs/plugins/preset-env/&quot;&gt;&lt;code&gt;@babel/preset-env&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">기본적으로 Babel은 어떤 작업도 수행하지 않으며 변환하려는 대상에 대해 가정하지 않습니다. 수행 할 작업을 알 수 있도록 구성을 제공해야합니다. 이 작업을 수행하는 한 가지 방법 은 컴파일중인 파일이 들어있는 폴더 또는 해당 파일 위의 경로에있는 상위 폴더에 &lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt; &lt;code&gt;.babelrc&lt;/code&gt; 파일&lt;/a&gt; 을 만드는 것 입니다. (Babel은 &lt;a href=&quot;https://babeljs.io/docs/usage/babelrc/&quot;&gt;다른 방법&lt;/a&gt; 도 지원합니다 .) 최소한의 &lt;code&gt;.babelrc&lt;/code&gt; 파일은 &lt;code&gt;{ &quot;presets&quot;: [&quot;@babel/env&quot;] }&lt;/code&gt; 입니다. 이것은 &lt;a href=&quot;https://babeljs.io/docs/plugins/preset-env/&quot;&gt; &lt;code&gt;@babel/preset-env&lt;/code&gt; &lt;/a&gt; 설치했음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="49f1d818998e74de59695f157376f3a90606565f" translate="yes" xml:space="preserve">
          <source>Cake, and Cakefiles</source>
          <target state="translated">케이크 및 케이크 파일</target>
        </trans-unit>
        <trans-unit id="0088170b2bb2e7f289a6285cc617ed958ec50055" translate="yes" xml:space="preserve">
          <source>Chained Comparisons</source>
          <target state="translated">연쇄 비교</target>
        </trans-unit>
        <trans-unit id="0ccff6f387e0efef20c206a781d53627c48f2db7" translate="yes" xml:space="preserve">
          <source>Chaining Function Calls</source>
          <target state="translated">체이닝 함수 호출</target>
        </trans-unit>
        <trans-unit id="0671ba2a2caa16a2ef58982abbdd6ace7b22a6a2" translate="yes" xml:space="preserve">
          <source>Class constructors can&amp;rsquo;t be invoked without &lt;code&gt;new&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 없이는 클래스 생성자를 호출 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c53d0a7efe848343f2bc3b9f8c6dabb21e16c959" translate="yes" xml:space="preserve">
          <source>Class methods can&amp;rsquo;t be used with &lt;code&gt;new&lt;/code&gt; (uncommon):</source>
          <target state="translated">클래스 메소드는 &lt;code&gt;new&lt;/code&gt; (흔하지 않은) 클래스와 함께 사용할 수 없습니다 :</target>
        </trans-unit>
        <trans-unit id="ed1846afee3be21521286932b99e2aeae9e6414a" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">Classes</target>
        </trans-unit>
        <trans-unit id="76ac356fa19e9b009cd862e7b800bf5b501caee5" translate="yes" xml:space="preserve">
          <source>Classes are compiled to ES2015 classes</source>
          <target state="translated">수업은 ES2015 수업으로 컴파일됩니다</target>
        </trans-unit>
        <trans-unit id="ed3b73338063d6639e5a81aae81f93fb2d0aed3e" translate="yes" xml:space="preserve">
          <source>Code blocks need to maintain consistent indentation relative to each other. When the compiler parses your Literate CoffeeScript file, it first discards all the non-code block lines and then parses the remainder as a regular CoffeeScript file. Therefore the code blocks need to be written as if the comment lines don&amp;rsquo;t exist, with consistent indentation (including whether they are indented with tabs or spaces).</source>
          <target state="translated">코드 블록은 서로에 대해 일관된 들여 쓰기를 유지해야합니다. 컴파일러는 Literate CoffeeScript 파일을 구문 분석 할 때 먼저 비 코드 블록 블록을 모두 버린 다음 나머지를 일반 CoffeeScript 파일로 구문 분석합니다. 따라서 주석 블록이 존재하지 않는 것처럼 코드 블록을 작성해야합니다 (일관된 들여 쓰기 (탭 또는 공백 들여 쓰기 포함) 포함).</target>
        </trans-unit>
        <trans-unit id="5fe0a62d44f69e6416546051403b163d3b065fd0" translate="yes" xml:space="preserve">
          <source>Code blocks should also now maintain a consistent indentation level&amp;mdash;so an indentation of one tab (or whatever you consider to be a tab stop, like 2 spaces or 4 spaces) should be treated as your code&amp;rsquo;s &amp;ldquo;left margin,&amp;rdquo; with all code in the file relative to that column.</source>
          <target state="translated">또한 코드 블록은 일관된 들여 쓰기 수준을 유지해야합니다. 따라서 하나의 탭 (또는 2 개의 공백 또는 4 개의 공백과 같이 탭 정지로 간주되는 항목)의 들여 쓰기는 코드의 &quot;왼쪽 여백&quot;으로 간주해야합니다. 해당 열에 상대적인 파일</target>
        </trans-unit>
        <trans-unit id="d51fafef78efa145bafb428481015a68d05f79b1" translate="yes" xml:space="preserve">
          <source>Code blocks that you want to be part of the commentary, and not executed, must have at least one line (ideally the first line of the block) completely unindented.</source>
          <target state="translated">주석의 일부가되고 실행되지 않는 코드 블록은 적어도 한 줄 (이상적으로는 블록의 첫 번째 줄)이 완전히 들여 쓰기되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="082a42c3704ee38739d3dd41511c5b78ea5ca8f3" translate="yes" xml:space="preserve">
          <source>CoffeeScript</source>
          <target state="translated">CoffeeScript</target>
        </trans-unit>
        <trans-unit id="555ad83e1b73fa461de685e684efafbb06947391" translate="yes" xml:space="preserve">
          <source>CoffeeScript 1 provided the &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;extends&lt;/code&gt; keywords as syntactic sugar for working with prototypal functions. With ES2015, JavaScript has adopted those keywords; so CoffeeScript 2 compiles its &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;extends&lt;/code&gt; keywords to ES2015 classes.</source>
          <target state="translated">커피 스크립트 (1) 제공된 &lt;code&gt;class&lt;/code&gt; 및 &lt;code&gt;extends&lt;/code&gt; 프로토 타입 기능 작업을위한 문법 설탕 등의 키워드를. ES2015에서는 JavaScript가 해당 키워드를 채택했습니다. 커피 스크립트 2 그래서 그 컴파일 &lt;code&gt;class&lt;/code&gt; 및 &lt;code&gt;extends&lt;/code&gt; ES2015 클래스에 키워드를.</target>
        </trans-unit>
        <trans-unit id="f07be14301b91058d1c6c7135618a2b966428618" translate="yes" xml:space="preserve">
          <source>CoffeeScript 1.x allowed the &lt;code&gt;extends&lt;/code&gt; keyword to set up prototypal inheritance between functions, and &lt;code&gt;super&lt;/code&gt; could be used manually prototype-assigned functions:</source>
          <target state="translated">CoffeeScript 1.x는 &lt;code&gt;extends&lt;/code&gt; 키워드가 함수 간 프로토 타입 상속을 설정 하도록 허용했으며 , &lt;code&gt;super&lt;/code&gt; 는 수동으로 프로토 타입 할당 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e05d2fb1ef65aeec22154353f09cc33a5cf2c6c" translate="yes" xml:space="preserve">
          <source>CoffeeScript 2</source>
          <target state="translated">CoffeeScript 2</target>
        </trans-unit>
        <trans-unit id="e14399e2ffb6a507f01ea44f0297fe153054114d" translate="yes" xml:space="preserve">
          <source>CoffeeScript 2 aims to output as much idiomatic ES2015+ syntax as possible with as few breaking changes from CoffeeScript 1.x as possible. Some breaking changes, unfortunately, were unavoidable.</source>
          <target state="translated">CoffeeScript 2는 가능한 한 CoffeeScript 1.x의 주요 변경 사항을 최소화하면서 가능한 많은 관용적 ES2015 + 구문을 출력하는 것을 목표로합니다. 불행히도 일부 주요 변경 사항은 피할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="a88022140a2d5d855a42ac84ed596e5d08bb28cc" translate="yes" xml:space="preserve">
          <source>CoffeeScript 2 generates JavaScript that uses the latest, modern syntax. The runtime or browsers where you want your code to run &lt;a href=&quot;#compatibility&quot;&gt;might not support all of that syntax&lt;/a&gt;. In that case, we want to convert modern JavaScript into older JavaScript that will run in older versions of Node or older browsers; for example, &lt;code&gt;{ a } = obj&lt;/code&gt; into &lt;code&gt;a = obj.a&lt;/code&gt;. This is done via transpilers like &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;, &lt;a href=&quot;https://buble.surge.sh/&quot;&gt;Bubl&amp;eacute;&lt;/a&gt; or &lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;Traceur Compiler&lt;/a&gt;.</source>
          <target state="translated">CoffeeScript 2는 최신의 최신 구문을 사용하는 JavaScript를 생성합니다. 코드를 실행하려는 런타임 브라우저 &lt;a href=&quot;#compatibility&quot;&gt;는 해당 구문을 모두 지원하지 않을 수 있습니다&lt;/a&gt; . 이 경우 최신 JavaScript를 이전 버전의 Node 또는 이전 브라우저에서 실행되는 이전 JavaScript로 변환하려고합니다. 예를 들어 &lt;code&gt;{ a } = obj&lt;/code&gt; into &lt;code&gt;a = obj.a&lt;/code&gt; 입니다. 이것은 &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; , &lt;a href=&quot;https://buble.surge.sh/&quot;&gt;Bubl&amp;eacute;&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/google/traceur-compiler&quot;&gt;Traceur Compiler&lt;/a&gt; 와 같은 변환기를 통해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="ca8a8ef142b86f16c228064c3ea4de5a99994a0a" translate="yes" xml:space="preserve">
          <source>CoffeeScript 2&amp;rsquo;s parsing of Literate CoffeeScript has been refactored to now be more careful about not treating indented lists as code blocks; but this means that all code blocks (unless they are to be interpreted as comments) must be separated by at least one blank line from lists.</source>
          <target state="translated">CoffeeScript 2의 Literate CoffeeScript 구문 분석은 들여 쓰기 된 목록을 코드 블록으로 처리하지 않도록보다 신중하게 리팩토링되었습니다. 그러나 이것은 모든 코드 블록 (코멘트로 해석되지 않는 한)이 목록에서 하나 이상의 빈 줄로 분리되어야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0b2ffccac37a106e2b15a0c8a15a92e2320522bc" translate="yes" xml:space="preserve">
          <source>CoffeeScript borrows &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#not-in&quot;&gt;chained comparisons&lt;/a&gt; from Python &amp;mdash; making it easy to test if a value falls within a certain range.</source>
          <target state="translated">CoffeeScript 는 Python에서 &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#not-in&quot;&gt;체인 비교&lt;/a&gt; 를 차용 하여 값이 특정 범위 내에 있는지 쉽게 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="897a6b8fdb2cee9e51b9a916b9a26978c1b5ce7a" translate="yes" xml:space="preserve">
          <source>CoffeeScript can compile &lt;code&gt;if&lt;/code&gt; statements into JavaScript expressions, using the ternary operator when possible, and closure wrapping otherwise. There is no explicit ternary statement in CoffeeScript &amp;mdash; you simply use a regular &lt;code&gt;if&lt;/code&gt; statement on a single line.</source>
          <target state="translated">CoffeeScript는 가능한 경우 삼항 연산자를 사용하여 &lt;code&gt;if&lt;/code&gt; 문을 JavaScript 표현식으로 컴파일 하고 그렇지 않으면 클로저 랩핑 할 수 있습니다. CoffeeScript에는 명시적인 삼항 문장이 없습니다 . 한 줄에 정규 &lt;code&gt;if&lt;/code&gt; 문만 사용하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="ed27d5551e9a44acadffac9bd86e6ee4d3d53ca3" translate="yes" xml:space="preserve">
          <source>CoffeeScript does not do any type checking itself; the JavaScript output you see above needs to get passed to Flow for it to validate your code. We expect most people will use a &lt;a href=&quot;#es2015plus-output&quot;&gt;build tool&lt;/a&gt; for this, but here&amp;rsquo;s how to do it the simplest way possible using the &lt;a href=&quot;#cli&quot;&gt;CoffeeScript&lt;/a&gt; and &lt;a href=&quot;https://flow.org/en/docs/usage/&quot;&gt;Flow&lt;/a&gt; command-line tools, assuming you&amp;rsquo;ve already &lt;a href=&quot;https://flow.org/en/docs/install/&quot;&gt;installed Flow&lt;/a&gt; and the &lt;a href=&quot;#installation&quot;&gt;latest CoffeeScript&lt;/a&gt; in your project folder:</source>
          <target state="translated">CoffeeScript는 자체 형식 검사를 수행하지 않습니다. 코드를 확인하려면 위에서 본 자바 스크립트 출력을 Flow로 전달해야합니다. 대부분의 사람들이이를 &lt;a href=&quot;#es2015plus-output&quot;&gt;위해 빌드 도구&lt;/a&gt; 를 사용할 것으로 예상 하지만 , 프로젝트 폴더에 &lt;a href=&quot;https://flow.org/en/docs/install/&quot;&gt;Flow&lt;/a&gt; 와 &lt;a href=&quot;#installation&quot;&gt;최신 CoffeeScript&lt;/a&gt; 가 이미 설치되어 있다고 가정하면 &lt;a href=&quot;#cli&quot;&gt;CoffeeScript&lt;/a&gt; 및 &lt;a href=&quot;https://flow.org/en/docs/usage/&quot;&gt;Flow&lt;/a&gt; 명령 줄 도구를 사용하여 가장 간단한 방법을 사용하는 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06ec89ba18aa176efa0f4a92848e200506fd34ed" translate="yes" xml:space="preserve">
          <source>CoffeeScript has a shortcut for creating objects when you want the key to be set with a variable of the same name. Note that the &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; are required for this shorthand.</source>
          <target state="translated">CoffeeScript에는 동일한 이름의 변수로 키를 설정하려는 경우 객체를 생성하는 바로 가기가 있습니다. 이 속기 에는 &lt;code&gt;{&lt;/code&gt; 및 &lt;code&gt;}&lt;/code&gt; 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="39400b54ccebc49551a1b624ebd5fccd176ecf9a" translate="yes" xml:space="preserve">
          <source>CoffeeScript includes a (very) simple build system similar to &lt;a href=&quot;https://www.gnu.org/software/make/&quot;&gt;Make&lt;/a&gt; and &lt;a href=&quot;http://rake.rubyforge.org/&quot;&gt;Rake&lt;/a&gt;. Naturally, it&amp;rsquo;s called Cake, and is used for the tasks that build and test the CoffeeScript language itself. Tasks are defined in a file named &lt;code&gt;Cakefile&lt;/code&gt;, and can be invoked by running &lt;code&gt;cake [task]&lt;/code&gt; from within the directory. To print a list of all the tasks and options, just type &lt;code&gt;cake&lt;/code&gt;.</source>
          <target state="translated">CoffeeScript에는 &lt;a href=&quot;https://www.gnu.org/software/make/&quot;&gt;Make&lt;/a&gt; and &lt;a href=&quot;http://rake.rubyforge.org/&quot;&gt;Rake&lt;/a&gt; 와 비슷한 (매우) 간단한 빌드 시스템이 포함되어 있습니다 . 당연히 Cake라고하며 CoffeeScript 언어 자체를 빌드하고 테스트하는 작업에 사용됩니다. 작업은 &lt;code&gt;Cakefile&lt;/code&gt; 이라는 파일에 정의되어 있으며 디렉토리 내에서 &lt;code&gt;cake [task]&lt;/code&gt; 를 실행하여 호출 할 수 있습니다 . 모든 작업 및 옵션 목록을 인쇄하려면 &lt;code&gt;cake&lt;/code&gt; 를 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb466ef914e340bd4cbaa0c07a1d399d449cd21c" translate="yes" xml:space="preserve">
          <source>CoffeeScript includes support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated. Browsers that support it can automatically use source maps to show your original source code in the debugger. To generate source maps alongside your JavaScript files, pass the &lt;code&gt;--map&lt;/code&gt; or &lt;code&gt;-m&lt;/code&gt; flag to the compiler.</source>
          <target state="translated">CoffeeScript에는 JavaScript 엔진에 CoffeeScript 프로그램의 어떤 부분이 평가중인 코드와 일치하는지 알려주는 소스 맵 생성 지원이 포함되어 있습니다. 이를 지원하는 브라우저는 소스 맵을 자동으로 사용하여 원래 소스 코드를 디버거에 표시 할 수 있습니다. JavaScript 파일과 함께 소스 맵을 생성하려면 &lt;code&gt;--map&lt;/code&gt; 또는 &lt;code&gt;-m&lt;/code&gt; 플래그를 컴파일러에 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="3db6d625e027881b87b075cf48db7c76a9bdaa5a" translate="yes" xml:space="preserve">
          <source>CoffeeScript supports &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals&quot;&gt;ES2015 tagged template literals&lt;/a&gt;, which enable customized string interpolation. If you immediately prefix a string with a function name (no space between the two), CoffeeScript will output this &amp;ldquo;function plus string&amp;rdquo; combination as an ES2015 tagged template literal, which will &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals&quot;&gt;behave accordingly&lt;/a&gt;: the function is called, with the parameters being the input text and expression parts that make up the interpolated string. The function can then assemble these parts into an output string, providing custom string interpolation.</source>
          <target state="translated">CoffeeScript는 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals&quot;&gt;ES2015 태그 템플릿 리터럴을&lt;/a&gt; 지원 하여 사용자 정의 문자열 보간을 가능하게합니다. 함수 이름으로 문자열 앞에 접두사를 붙이면 (두 개 사이에 공백이 없음) CoffeeScript는이 &quot;함수 + 문자열&quot;조합을 ES2015 태그가 지정된 템플릿 리터럴로 출력합니다 .이 함수는 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals&quot;&gt;그에 따라 작동&lt;/a&gt; 합니다. 보간 된 문자열을 구성하는 입력 텍스트 및 표현식 부분. 그런 다음 함수는 이러한 부분을 출력 문자열로 어셈블하여 사용자 지정 문자열 보간을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6062d895dad2882c3d733740c8180cb30cd93245" translate="yes" xml:space="preserve">
          <source>CoffeeScript supports ES2015 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;generator functions&lt;/a&gt; through the &lt;code&gt;yield&lt;/code&gt; keyword. There&amp;rsquo;s no &lt;code&gt;function*(){}&lt;/code&gt; nonsense &amp;mdash; a generator in CoffeeScript is simply a function that yields.</source>
          <target state="translated">CoffeeScript는 &lt;code&gt;yield&lt;/code&gt; 키워드를 통해 ES2015 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;생성기 기능&lt;/a&gt; 을 지원 합니다. 센스 가없는 &lt;code&gt;function*(){}&lt;/code&gt; 가 없습니다 . CoffeeScript의 생성기는 단순히 생성하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="a64e782a7ca1ed608a5e5d8b58e56c5b34418abf" translate="yes" xml:space="preserve">
          <source>CoffeeScript supports interspersed XML elements, without the need for separate plugins or special settings. The XML elements will be compiled as such, outputting JSX that could be parsed like any normal JSX file, for example by &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-react-jsx/&quot;&gt;Babel with the React JSX transform&lt;/a&gt;. CoffeeScript does &lt;em&gt;not&lt;/em&gt; output &lt;code&gt;React.createElement&lt;/code&gt; calls or any code specific to React or any other framework. It is up to you to attach another step in your build chain to convert this JSX to whatever function calls you wish the XML elements to compile to.</source>
          <target state="translated">CoffeeScript는 별도의 플러그인이나 특수 설정없이 산재 된 XML 요소를 지원합니다. XML 요소는 그대로 컴파일되어 JSX를 출력합니다. 예를 들어 &lt;a href=&quot;https://babeljs.io/docs/plugins/transform-react-jsx/&quot;&gt;Babel에서 React JSX 변환을 사용하여&lt;/a&gt; 일반 JSX 파일처럼 구문 분석 할 수 있습니다 . CoffeeScript는 &lt;code&gt;React.createElement&lt;/code&gt; 호출이나 React 또는 다른 프레임 워크에 특정한 코드를 출력 하지 &lt;em&gt;않습니다&lt;/em&gt; . 이 JSX를 XML 요소를 컴파일하려는 함수 호출로 변환하려면 빌드 체인에 다른 단계를 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="59b0754344014d9d6347724f39bcacbaf47c2e7d" translate="yes" xml:space="preserve">
          <source>Command Line</source>
          <target state="translated">커맨드 라인</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes" xml:space="preserve">
          <source>Compatibility</source>
          <target state="translated">Compatibility</target>
        </trans-unit>
        <trans-unit id="4300e2d5a6e06edd248521ea98c722082a8b228a" translate="yes" xml:space="preserve">
          <source>Compile a &lt;code&gt;.coffee&lt;/code&gt; script into a &lt;code&gt;.js&lt;/code&gt; JavaScript file of the same name.</source>
          <target state="translated">&lt;code&gt;.coffee&lt;/code&gt; 스크립트를 동일한 이름의 &lt;code&gt;.js&lt;/code&gt; JavaScript 파일 로 컴파일하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6a3565f7ffca2f5f11e68c1b128efdad5b5cdd7" translate="yes" xml:space="preserve">
          <source>Compile a directory tree of &lt;code&gt;.coffee&lt;/code&gt; files in &lt;code&gt;src&lt;/code&gt; into a parallel tree of &lt;code&gt;.js&lt;/code&gt; files in &lt;code&gt;lib&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 에있는 &lt;code&gt;.coffee&lt;/code&gt; 파일 의 디렉토리 트리를 &lt;code&gt;lib&lt;/code&gt; 에있는 &lt;code&gt;.js&lt;/code&gt; 파일 의 병렬 트리로 컴파일하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a3b0300d1b064869ff33a3d2ebe6e0e6baae51a" translate="yes" xml:space="preserve">
          <source>Compile and print a little snippet of CoffeeScript directly from the command line. For example:</source>
          <target state="translated">커맨드 라인에서 직접 CoffeeScript의 작은 조각을 컴파일하고 인쇄하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c79230adcfcd792fe3990fd8abbc8770972c8c7" translate="yes" xml:space="preserve">
          <source>Compile the JavaScript without the &lt;a href=&quot;#lexical-scope&quot;&gt;top-level function safety wrapper&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#lexical-scope&quot;&gt;최상위 함수 안전 래퍼&lt;/a&gt; 없이 JavaScript를 컴파일하십시오 .</target>
        </trans-unit>
        <trans-unit id="cfc3a5e15482fb7edb84902d1ef3f824dafd8030" translate="yes" xml:space="preserve">
          <source>Comprehensions can also be used to iterate over the keys and values in an object. Use &lt;code&gt;of&lt;/code&gt; to signal comprehension over the properties of an object instead of the values in an array.</source>
          <target state="translated">이해를 사용하여 객체의 키와 값을 반복 할 수도 있습니다. 사용 &lt;code&gt;of&lt;/code&gt; 배열 대신에있는 값의 객체의 속성 신호를 이해한다.</target>
        </trans-unit>
        <trans-unit id="23c37ee042c74f1f491788e4316571902ea348c4" translate="yes" xml:space="preserve">
          <source>Comprehensions should be able to handle most places where you otherwise would use a loop, &lt;code&gt;each&lt;/code&gt;/&lt;code&gt;forEach&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, or &lt;code&gt;select&lt;/code&gt;/&lt;code&gt;filter&lt;/code&gt;, for example:</source>
          <target state="translated">이해력은 루프, &lt;code&gt;each&lt;/code&gt; / &lt;code&gt;forEach&lt;/code&gt; , &lt;code&gt;map&lt;/code&gt; 또는 &lt;code&gt;select&lt;/code&gt; / &lt;code&gt;filter&lt;/code&gt; 를 사용하는 대부분의 장소를 처리 할 수 ​​있어야합니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="f4408c72041f1642066f98a95c77bb7d47148a6c" translate="yes" xml:space="preserve">
          <source>Concatenate a list of files into a single script:</source>
          <target state="translated">파일 목록을 단일 스크립트로 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="ec59c7801544b7219c543bca6994038a564b01b6" translate="yes" xml:space="preserve">
          <source>Default values for function parameters and destructured elements</source>
          <target state="translated">함수 매개 변수 및 비 구조화 된 요소의 기본값</target>
        </trans-unit>
        <trans-unit id="bf1be2b7ad07bae2fe92475d10173eb638774def" translate="yes" xml:space="preserve">
          <source>Definition</source>
          <target state="translated">Definition</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="3971221e4434ee7c22e0cd88456435a7a35e2f99" translate="yes" xml:space="preserve">
          <source>Destructuring Assignment</source>
          <target state="translated">할당 해체</target>
        </trans-unit>
        <trans-unit id="693d95d6190509bd73966d59486aedaea1f2f65e" translate="yes" xml:space="preserve">
          <source>Destructuring assignment can be used with any depth of array and object nesting, to help pull out deeply nested properties.</source>
          <target state="translated">깊이있는 배열 속성을 끌어내는 데 도움이되도록 배열 및 개체 중첩 깊이와 함께 구조 지정 할당을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="084d80478954c0fd6df8a1f5371f23b6b7d2b0bb" translate="yes" xml:space="preserve">
          <source>Destructuring assignment can even be combined with splats.</source>
          <target state="translated">구조 지정 할당은 표시와 결합 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="03c2ead8f6c7800e07ddee30aab9ffe372df05ad" translate="yes" xml:space="preserve">
          <source>Destructuring assignment is also useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor.</source>
          <target state="translated">할당 해제는 클래스 생성자와 결합하여 생성자에 전달 된 옵션 객체에서 인스턴스에 속성을 할당 할 때도 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ee64309bcad68d432618adc16618ac8cd4342081" translate="yes" xml:space="preserve">
          <source>Double-quoted block strings, like other double-quoted strings, allow interpolation.</source>
          <target state="translated">다른 큰 따옴표로 묶인 문자열과 같이 큰 따옴표로 묶인 블록 문자열은 보간을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="76c71025ffe95216c3f2960d37aa6448ff56912e" translate="yes" xml:space="preserve">
          <source>Due to a syntax clash with &lt;code&gt;super&lt;/code&gt; with accessors, &amp;ldquo;bare&amp;rdquo; &lt;code&gt;super&lt;/code&gt; (the keyword &lt;code&gt;super&lt;/code&gt; without parentheses) no longer compiles to a super call forwarding all arguments.</source>
          <target state="translated">접근 자 와의 &lt;code&gt;super&lt;/code&gt; 와의 구문 충돌로 인해 &quot;bare&quot; &lt;code&gt;super&lt;/code&gt; ( 괄호없는 키워드 &lt;code&gt;super&lt;/code&gt; )가 더 이상 모든 인수를 전달하는 수퍼 콜로 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd6c049a857c66bb824182c8c447a61a862212dd" translate="yes" xml:space="preserve">
          <source>Due to the hoisting required to compile to ES2015 classes, dynamic keys in class methods can&amp;rsquo;t use values from the executable class body unless the methods are assigned in prototype style.</source>
          <target state="translated">ES2015 클래스로 컴파일하는 데 필요한 호이 스팅으로 인해, 메소드가 프로토 타입 스타일로 지정되지 않으면 클래스 메소드의 동적 키는 실행 가능 클래스 본문의 값을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="abd4833636e3bf75c96fa84f99c79c1dfd504f8f" translate="yes" xml:space="preserve">
          <source>Due to the switch to ES2015 &lt;code&gt;extends&lt;/code&gt; and &lt;code&gt;super&lt;/code&gt;, using these keywords for prototypal functions are no longer supported. The above case could be refactored to:</source>
          <target state="translated">ES2015 &lt;code&gt;extends&lt;/code&gt; 및 &lt;code&gt;super&lt;/code&gt; 로의 전환으로 인해 프로토 타입 기능에이 키워드를 사용하는 것은 더 이상 지원되지 않습니다. 위의 경우는 다음과 같이 리팩토링 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68f15e98bbba94444d4a5758a91c0b8c7f4919c0" translate="yes" xml:space="preserve">
          <source>ES2015 classes and their methods have some restrictions beyond those on regular functions.</source>
          <target state="translated">ES2015 클래스와 그 방법에는 정규 기능에 대한 것 이상의 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="686eb8e68104e706ebea5afdbc1c1082e68d1d72" translate="yes" xml:space="preserve">
          <source>ES2015 classes don&amp;rsquo;t allow bound (fat arrow) methods. The CoffeeScript compiler goes through some contortions to preserve support for them, but one thing that can&amp;rsquo;t be accommodated is calling a bound method before it is bound:</source>
          <target state="translated">ES2015 클래스는 바인딩 된 (뚱뚱한 화살표) 메서드를 허용하지 않습니다. CoffeeScript 컴파일러는 지원을 유지하기 위해 약간의 왜곡을 겪지 만 수용 할 수없는 한 가지는 바인딩 된 메서드를 바인딩하기 전에 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ee88a511a3dd54469352e7cc993bdb9390253e24" translate="yes" xml:space="preserve">
          <source>ES2015 modules are supported in CoffeeScript, with very similar &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; syntax:</source>
          <target state="translated">ES2015 모듈은 CoffeeScript에서 매우 유사한 &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;export&lt;/code&gt; 구문 과 함께 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="a673b896c1665557ccd0cee7c0afccf5405fc642" translate="yes" xml:space="preserve">
          <source>ES2017&amp;rsquo;s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;async functions&lt;/a&gt; are supported through the &lt;code&gt;await&lt;/code&gt; keyword. Like with generators, there&amp;rsquo;s no need for an &lt;code&gt;async&lt;/code&gt; keyword; an async function in CoffeeScript is simply a function that awaits.</source>
          <target state="translated">ES2017의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;비동기 기능&lt;/a&gt; 은 &lt;code&gt;await&lt;/code&gt; 키워드를 통해 지원됩니다 . 생성기와 마찬가지로 &lt;code&gt;async&lt;/code&gt; 키워드 가 필요하지 않습니다 . CoffeeScript의 비동기 함수는 단순히 기다리는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="bfc783ddd79a9914d8fbf1e5c70ddebce72e3d6a" translate="yes" xml:space="preserve">
          <source>Embedded JavaScript</source>
          <target state="translated">임베디드 JavaScript</target>
        </trans-unit>
        <trans-unit id="8d66e6697e4c4d59becd333355a57aeac2ef2cf1" translate="yes" xml:space="preserve">
          <source>Escape backslashes before backticks with more backslashes: &lt;code&gt; \\\`​&lt;/code&gt; becomes &lt;code&gt; \`​&lt;/code&gt;.</source>
          <target state="translated">더 백 슬래시와 역 따옴표 앞에 백 슬래시 탈출 : &lt;code&gt; \\\`​&lt;/code&gt; 이된다 &lt;code&gt; \`​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a71f86015fbc5b12f95827124758fcdcd748d4e5" translate="yes" xml:space="preserve">
          <source>Escape backslashes before backticks with more backslashes: &lt;code&gt;\\\`​&lt;/code&gt; becomes &lt;code&gt;\`​&lt;/code&gt;.</source>
          <target state="translated">더 백 슬래시와 역 따옴표 앞에 백 슬래시 탈출 : &lt;code&gt;\\\`​&lt;/code&gt; 이된다 &lt;code&gt;\`​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="793787c40f1cf7d655d3a05e62d7be445f6bf321" translate="yes" xml:space="preserve">
          <source>Escape backticks with backslashes: &lt;code&gt; \`​&lt;/code&gt; becomes &lt;code&gt; `​&lt;/code&gt;.</source>
          <target state="translated">백 슬래시와 역 따옴표를 탈출 : &lt;code&gt; \`​&lt;/code&gt; 된다 &lt;code&gt; `​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec5f2d9c1baacad5c9a2a2c7ebd37ab7e094639c" translate="yes" xml:space="preserve">
          <source>Escape backticks with backslashes: &lt;code&gt;\`​&lt;/code&gt; becomes &lt;code&gt;`​&lt;/code&gt;.</source>
          <target state="translated">백 슬래시와 역 따옴표를 탈출 : &lt;code&gt;\`​&lt;/code&gt; 된다 &lt;code&gt;`​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca324f5a8ab7f029b85119d0ccec4498c155b7a5" translate="yes" xml:space="preserve">
          <source>Even though functions will always return their final value, it&amp;rsquo;s both possible and encouraged to return early from a function body writing out the explicit return (&lt;code&gt;return value&lt;/code&gt;), when you know that you&amp;rsquo;re done.</source>
          <target state="translated">함수가 항상 최종 값을 반환하더라도 함수 본문에서 명시적인 반환 ( &lt;code&gt;return value&lt;/code&gt; )을 작성하여 일찍 반환하는 것이 가능하고 권장 됩니다.</target>
        </trans-unit>
        <trans-unit id="7fde14a080208598ce35fabd5b0ea5f2affbf555" translate="yes" xml:space="preserve">
          <source>Everything is an Expression</source>
          <target state="translated">모든 것이 표현이다</target>
        </trans-unit>
        <trans-unit id="7af36896f436a2940c2c5a2723b3bc0c8c329291" translate="yes" xml:space="preserve">
          <source>Everything is an Expression (at least, as much as possible)</source>
          <target state="translated">모든 것이 표현입니다 (적어도 가능한 한 많이)</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="e2a4095571338493938d9208d1a8bdc53cd52da1" translate="yes" xml:space="preserve">
          <source>Existential Operator</source>
          <target state="translated">기존 연산자</target>
        </trans-unit>
        <trans-unit id="340b3c1e6a8d3673bdad04f30b83addc47a3c77e" translate="yes" xml:space="preserve">
          <source>Expansion can be used to retrieve elements from the end of an array without having to assign the rest of its values. It works in function parameter lists as well.</source>
          <target state="translated">확장은 나머지 값을 할당하지 않고 배열의 끝에서 요소를 검색하는 데 사용할 수 있습니다. 함수 매개 변수 목록에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="9435e660888a944ea96d68e322b87de298b0b35d" translate="yes" xml:space="preserve">
          <source>Finally, class definitions are blocks of executable code, which make for interesting metaprogramming possibilities. In the context of a class definition, &lt;code&gt;this&lt;/code&gt; is the class object itself; therefore, you can assign static properties by using &lt;code&gt;@property: value&lt;/code&gt;.</source>
          <target state="translated">마지막으로 클래스 정의는 실행 가능한 코드 블록으로, 흥미로운 메타 프로그래밍 가능성을 제공합니다. 클래스 정의의 맥락에서 &lt;code&gt;this&lt;/code&gt; 클래스 객체 자체입니다. 따라서 &lt;code&gt;@property: value&lt;/code&gt; 를 사용하여 정적 속성을 할당 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa7d66d6f53b9efb770a67714bce600a748ba8a3" translate="yes" xml:space="preserve">
          <source>First, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don&amp;rsquo;t need to use semicolons &lt;code&gt;;&lt;/code&gt; to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line). Instead of using curly braces &lt;code&gt;{ }&lt;/code&gt; to surround blocks of code in &lt;a href=&quot;#literals&quot;&gt;functions&lt;/a&gt;, &lt;a href=&quot;#conditionals&quot;&gt;if-statements&lt;/a&gt;, &lt;a href=&quot;#switch&quot;&gt;switch&lt;/a&gt;, and &lt;a href=&quot;#try&quot;&gt;try/catch&lt;/a&gt;, use indentation.</source>
          <target state="translated">먼저, 기본 사항 : CoffeeScript는 큰 공백을 사용하여 코드 블록을 구분합니다. 세미콜론을 사용할 필요는 없습니다 &lt;code&gt;;&lt;/code&gt; 세미콜론을 사용하여 한 줄에 여러 식을 넣을 수는 있지만 식을 끝내려면 줄을 끝내는 것도 마찬가지입니다. &lt;a href=&quot;#literals&quot;&gt;함수&lt;/a&gt; , &lt;a href=&quot;#conditionals&quot;&gt;if-statements&lt;/a&gt; , &lt;a href=&quot;#switch&quot;&gt;switch&lt;/a&gt; 및 &lt;a href=&quot;#try&quot;&gt;try / catch&lt;/a&gt; 에서 코드 블록을 둘러싸 기 위해 중괄호 ( &lt;code&gt;{ }&lt;/code&gt; 를 사용하는 대신 들여 쓰기를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ee19e7cadbb13d1440abec3b34a17cd12b6c5c48" translate="yes" xml:space="preserve">
          <source>For a full introduction to source maps, how they work, and how to hook them up in your browser, read the &lt;a href=&quot;https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&quot;&gt;HTML5 Tutorial&lt;/a&gt;.</source>
          <target state="translated">소스 맵에 대한 전체 소개, 작동 방식 및 브라우저에서 연결하는 방법을 보려면 &lt;a href=&quot;https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/&quot;&gt;HTML5 튜토리얼을&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="e01b86e80df0b25b6f0247ef3986bce39d12f358" translate="yes" xml:space="preserve">
          <source>For completeness:</source>
          <target state="translated">완전성을 위해 :</target>
        </trans-unit>
        <trans-unit id="8a4f6d4faf8398cfa0cd411363607d10de4be976" translate="yes" xml:space="preserve">
          <source>For logic, &lt;code&gt;and&lt;/code&gt; compiles to &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, and &lt;code&gt;or&lt;/code&gt; into &lt;code&gt;||&lt;/code&gt;.</source>
          <target state="translated">논리를 들어, &lt;code&gt;and&lt;/code&gt; 컴파일에 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , 그리고 &lt;code&gt;or&lt;/code&gt; 에 &lt;code&gt;||&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1fa703ef8acae65b0063e84a587fc7eda00827c3" translate="yes" xml:space="preserve">
          <source>For readability, the &lt;code&gt;until&lt;/code&gt; keyword is equivalent to &lt;code&gt;while not&lt;/code&gt;, and the &lt;code&gt;loop&lt;/code&gt; keyword is equivalent to &lt;code&gt;while true&lt;/code&gt;.</source>
          <target state="translated">가독성를 들어, &lt;code&gt;until&lt;/code&gt; 키워드에 해당 &lt;code&gt;while not&lt;/code&gt; , 그리고 &lt;code&gt;loop&lt;/code&gt; 키워드에 해당 &lt;code&gt;while true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8898a99d18cf365fdf183321827b4e34c0860021" translate="yes" xml:space="preserve">
          <source>From the root of your project:</source>
          <target state="translated">프로젝트의 루트에서 :</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="2f64931a65a6e89a9512c49457d675893ed09df0" translate="yes" xml:space="preserve">
          <source>Functions are defined by an optional list of parameters in parentheses, an arrow, and the function body. The empty function looks like this: &lt;code&gt;-&amp;gt;&lt;/code&gt;</source>
          <target state="translated">함수는 괄호, 화살표 및 함수 본문의 선택적 매개 변수 목록으로 정의됩니다. 빈 함수는 다음과 같습니다 : &lt;code&gt;-&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98cb6e01b2ef1f74900d474df5478cc6c3f8d839" translate="yes" xml:space="preserve">
          <source>Functions may also have default values for arguments, which will be used if the incoming argument is missing (&lt;code&gt;undefined&lt;/code&gt;).</source>
          <target state="translated">함수는 또한 인수에 대한 기본값을 가질 수 있으며, 들어오는 인수가 누락 된 경우 ( &lt;code&gt;undefined&lt;/code&gt; ) 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="91daad92fe0111679b312c13903a169bf2881f3a" translate="yes" xml:space="preserve">
          <source>Generate an abstract syntax tree of nodes of the CoffeeScript. Used for integrating with JavaScript build tools.</source>
          <target state="translated">CoffeeScript 노드의 추상 구문 트리를 생성합니다. JavaScript 빌드 도구와 통합하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3c74a2f5bbae6a65aa71e01f3ca337b3eb0139aa" translate="yes" xml:space="preserve">
          <source>Generate source maps alongside the compiled JavaScript files. Adds &lt;code&gt;sourceMappingURL&lt;/code&gt; directives to the JavaScript as well.</source>
          <target state="translated">컴파일 된 JavaScript 파일과 함께 소스 맵을 생성하십시오. JavaScript에 &lt;code&gt;sourceMappingURL&lt;/code&gt; 지시문도 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="532aff027e5f3d32201aa60d2efb5271e9bd4744" translate="yes" xml:space="preserve">
          <source>Generator Functions</source>
          <target state="translated">발전기 기능</target>
        </trans-unit>
        <trans-unit id="e76ffcd1f650481542d7dda729cb91d61d3111a0" translate="yes" xml:space="preserve">
          <source>Hopefully, you&amp;rsquo;ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.</source>
          <target state="translated">바라건대, 당신이 그것을 사용할 필요는 없지만 CoffeeScript 내에서 JavaScript 스 니펫을 산재 해야하는 경우 백틱을 사용하여 바로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abe858446febb39efadf27fc1b2fba8c7df3ab4e" translate="yes" xml:space="preserve">
          <source>If a variable might be undeclared, the compiler does a thorough check. This is what JavaScript coders &lt;em&gt;should&lt;/em&gt; be typing when they want to check if a mystery variable exists.</source>
          <target state="translated">변수가 선언되지 않은 경우 컴파일러는 철저한 검사를 수행합니다. 이것은 미스터리 변수가 있는지 확인하려는 JavaScript 코더 &lt;em&gt;가&lt;/em&gt; 입력 &lt;em&gt;해야하는&lt;/em&gt; 것입니다.</target>
        </trans-unit>
        <trans-unit id="0cfbe04d5e5abb311561c2a3f5993f9e83c1d7a6" translate="yes" xml:space="preserve">
          <source>If this were saved as &lt;code&gt;executable.coffee&lt;/code&gt;, it could be made executable and run:</source>
          <target state="translated">이것이 &lt;code&gt;executable.coffee&lt;/code&gt; 로 저장되면 실행 가능 하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42eb1c2c93bbc5c5388c60ca8defece372ea8114" translate="yes" xml:space="preserve">
          <source>If we had used &lt;code&gt;-&amp;gt;&lt;/code&gt; in the callback above, &lt;code&gt;@customer&lt;/code&gt; would have referred to the undefined &amp;ldquo;customer&amp;rdquo; property of the DOM element, and trying to call &lt;code&gt;purchase()&lt;/code&gt; on it would have raised an exception.</source>
          <target state="translated">위의 콜백에서 &lt;code&gt;-&amp;gt;&lt;/code&gt; 를 사용했다면 &lt;code&gt;@customer&lt;/code&gt; 는 DOM 요소의 정의되지 않은 &quot;customer&quot;속성을 참조 했을 것이고 , 그에 대해 &lt;code&gt;purchase()&lt;/code&gt; 를 호출하려고 하면 예외가 발생했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="7e3d568c0c336ebae7d8c3b53ecc75b8f5da93b6" translate="yes" xml:space="preserve">
          <source>If you are using CoffeeScript in a project, you should install it locally for that project so that the version of CoffeeScript is tracked as one of your project&amp;rsquo;s dependencies. Within that project&amp;rsquo;s folder:</source>
          <target state="translated">프로젝트에서 CoffeeScript를 사용하는 경우 해당 프로젝트에 대해 CoffeeScript를 로컬로 설치해야 CoffeeScript 버전이 프로젝트의 종속성 중 하나로 추적됩니다. 해당 프로젝트 폴더 내 :</target>
        </trans-unit>
        <trans-unit id="9dbf6cbf52cbf3a1c6022d16008907342c32a283" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t need the current iteration value you may omit it: &lt;code&gt;browser.closeCurrentTab() for [0...count]&lt;/code&gt;</source>
          <target state="translated">현재 반복 값이 필요하지 않으면 &lt;code&gt;browser.closeCurrentTab() for [0...count]&lt;/code&gt; 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53c4a51d299b5a23747c3c2aa3bbf171cdb568d0" translate="yes" xml:space="preserve">
          <source>If you know of another way to achieve static type checking with CoffeeScript, please &lt;a href=&quot;https://github.com/jashkenas/coffeescript/issues/new&quot;&gt;create an issue&lt;/a&gt; and let us know.</source>
          <target state="translated">CoffeeScript로 정적 유형 검사를 수행하는 다른 방법을 알고 있다면 &lt;a href=&quot;https://github.com/jashkenas/coffeescript/issues/new&quot;&gt;문제&lt;/a&gt; 를 작성하여 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="e4cb8e7ac3be882b151de631a19cf2ab37f9bb1b" translate="yes" xml:space="preserve">
          <source>If you know the start and end of your loop, or would like to step through in fixed-size increments, you can use a range to specify the start and end of your comprehension.</source>
          <target state="translated">루프의 시작과 끝을 알고 있거나 고정 크기 단위로 단계별로 진행하려면 범위를 사용하여 이해의 시작과 끝을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="690eeea1dea81c1df3ff122ee050e1d70f25607b" translate="yes" xml:space="preserve">
          <source>If you need to invoke one task before another &amp;mdash; for example, running &lt;code&gt;build&lt;/code&gt; before &lt;code&gt;test&lt;/code&gt;, you can use the &lt;code&gt;invoke&lt;/code&gt; function: &lt;code&gt;invoke 'build'&lt;/code&gt;. Cake tasks are a minimal way to expose your CoffeeScript functions to the command line, so &lt;a href=&quot;https://coffeescript.org/v2/annotated-source/cake.html&quot;&gt;don&amp;rsquo;t expect any fanciness built-in&lt;/a&gt;. If you need dependencies, or async callbacks, it&amp;rsquo;s best to put them in your code itself &amp;mdash; not the cake task.</source>
          <target state="translated">예를 들어, &lt;code&gt;build&lt;/code&gt; before &lt;code&gt;test&lt;/code&gt; 실행과 같이 한 작업을 다른 작업보다 먼저 호출해야하는 경우 &lt;code&gt;invoke 'build'&lt;/code&gt; 와 같은 &lt;code&gt;invoke&lt;/code&gt; 함수를 사용할 수 있습니다 . 케이크 작업은 CoffeeScript 기능을 명령 줄에 노출시키는 최소한의 방법이므로, &lt;a href=&quot;https://coffeescript.org/v2/annotated-source/cake.html&quot;&gt;기발한 내장 기능을 기대하지 마십시오&lt;/a&gt; . 의존성 또는 비동기 콜백이 필요한 경우 케이크 작업이 아닌 코드 자체에 배치하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6183792822af0844154cbd94b88cbdf4d74c526f" translate="yes" xml:space="preserve">
          <source>If you plan to use the &lt;code&gt;--transpile&lt;/code&gt; option (see &lt;a href=&quot;#transpilation&quot;&gt;Transpilation&lt;/a&gt;) you will need to also install &lt;code&gt;@babel/core&lt;/code&gt; either globally or locally, depending on whether you are running a globally or locally installed version of CoffeeScript.</source>
          <target state="translated">당신이 사용하려는 경우 &lt;code&gt;--transpile&lt;/code&gt; 옵션을 (참조 &lt;a href=&quot;#transpilation&quot;&gt;Transpilation을&lt;/a&gt; 당신은 또한 설치해야합니다) &lt;code&gt;@babel/core&lt;/code&gt; 당신이 커피 스크립트의 전역 또는 로컬에 설치된 버전을 실행하는지에 따라, 전 세계적으로 또는 로컬로.</target>
        </trans-unit>
        <trans-unit id="16a1eb24f6b65a8ec749d8523bc57eb23ee0101f" translate="yes" xml:space="preserve">
          <source>If you want to use the compiler&amp;rsquo;s API, for example to make an app that compiles strings of CoffeeScript on the fly, you can &lt;code&gt;require&lt;/code&gt; the full module:</source>
          <target state="translated">예를 들어 CoffeeScript 문자열을 즉시 컴파일하는 앱을 만드는 등 컴파일러의 API를 사용 하려면 전체 모듈이 &lt;code&gt;require&lt;/code&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2028691c6ca114b3e56e788fbd92f28d5fc0156" translate="yes" xml:space="preserve">
          <source>If you would like to iterate over just the keys that are defined on the object itself, by adding a &lt;code&gt;hasOwnProperty&lt;/code&gt; check to avoid properties that may be inherited from the prototype, use &lt;code&gt;for own key, value of object&lt;/code&gt;.</source>
          <target state="translated">프로토 타입에서 상속 될 수있는 특성을 피하기 위해 &lt;code&gt;hasOwnProperty&lt;/code&gt; 검사를 추가하여 오브젝트 자체에 정의 된 키만 반복 하려면 &lt;code&gt;for own key, value of object&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="592b59788a4d3ef118683778c8b805c5c84cd8ca" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to create top-level variables for other scripts to use, attach them as properties on &lt;code&gt;window&lt;/code&gt;; attach them as properties on the &lt;code&gt;exports&lt;/code&gt; object in CommonJS; or use an &lt;a href=&quot;#modules&quot;&gt;&lt;code&gt;export&lt;/code&gt; statement&lt;/a&gt;. If you&amp;rsquo;re targeting both CommonJS and the browser, the &lt;a href=&quot;#existential-operator&quot;&gt;existential operator&lt;/a&gt; (covered below), gives you a reliable way to figure out where to add them: &lt;code&gt;exports ? this&lt;/code&gt;.</source>
          <target state="translated">다른 스크립트에서 사용할 최상위 변수를 만들려면 &lt;code&gt;window&lt;/code&gt; 속성으로 첨부하십시오 . CommonJS 에서 &lt;code&gt;exports&lt;/code&gt; 오브젝트의 특성으로이를 첨부하십시오 . 또는 &lt;a href=&quot;#modules&quot;&gt; &lt;code&gt;export&lt;/code&gt; 명세서를&lt;/a&gt; 사용하십시오 . CommonJS와 브라우저를 모두 대상으로하는 경우 &lt;a href=&quot;#existential-operator&quot;&gt;기존 연산자&lt;/a&gt; (아래에서 설명)는 추가 할 위치를 파악할 수있는 안정적인 방법을 제공합니다. &lt;code&gt;exports ? this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="146aec742e33fd45508faaf1fd9479d63b8d9e3b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to use Node.js&amp;rsquo; CommonJS to &lt;code&gt;require&lt;/code&gt; CoffeeScript files, e.g. &lt;code&gt;require './app.coffee'&lt;/code&gt;, you must first &amp;ldquo;register&amp;rdquo; CoffeeScript as an extension:</source>
          <target state="translated">당신은 '할 CommonJS Node.js를를 사용하려는 경우 &lt;code&gt;require&lt;/code&gt; , 커피 스크립트 파일을 예를 &lt;code&gt;require './app.coffee'&lt;/code&gt; 먼저 확장으로 커피 스크립트를 &quot;등록&quot;해야합니다</target>
        </trans-unit>
        <trans-unit id="46e33650ad57bc5c400b19005fe7df0765a3fb90" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using CoffeeScript via the &lt;a href=&quot;https://coffeescript.org/nodejs_usage&quot;&gt;Node API&lt;/a&gt;, where you call &lt;code&gt;CoffeeScript.compile&lt;/code&gt; with a string to be compiled and an &lt;code&gt;options&lt;/code&gt; object, the &lt;code&gt;transpile&lt;/code&gt; key of the &lt;code&gt;options&lt;/code&gt; object should be the Babel options:</source>
          <target state="translated">당신은을 통해 커피 스크립트를 사용하는 경우 &lt;a href=&quot;https://coffeescript.org/nodejs_usage&quot;&gt;노드 API&lt;/a&gt; 는 전화 &lt;code&gt;CoffeeScript.compile&lt;/code&gt; 를 컴파일하는 문자열과 &lt;code&gt;options&lt;/code&gt; 객체의 &lt;code&gt;transpile&lt;/code&gt; 의 의 키 &lt;code&gt;options&lt;/code&gt; 객체는 바벨 옵션이어야합니다 :</target>
        </trans-unit>
        <trans-unit id="016766665df92106ffce5000526613553ce1231c" translate="yes" xml:space="preserve">
          <source>If, Else, Unless, and Conditional Assignment</source>
          <target state="translated">만약, 그렇지 않으면, 조건부 할당</target>
        </trans-unit>
        <trans-unit id="1e1733da0a2b3323346e10e76e4e0da637c155fe" translate="yes" xml:space="preserve">
          <source>In CoffeeScript 1.x, &lt;code&gt;--&lt;/code&gt; was required after the path and filename of the script to be run, but before any arguments passed to that script. This convention is now deprecated. So instead of:</source>
          <target state="translated">CoffeeScript 1.x에서 &lt;code&gt;--&lt;/code&gt; 는 스크립트의 경로와 파일 이름을 실행 한 후 인수가 해당 스크립트에 전달되기 전에 필요했습니다. 이 규칙은 더 이상 사용되지 않습니다. 따라서 대신 :</target>
        </trans-unit>
        <trans-unit id="7064346047d308376ffa12374eb5bf9c93709bc8" translate="yes" xml:space="preserve">
          <source>In CoffeeScript 1.x, &lt;code&gt;=&amp;gt;&lt;/code&gt; compiled to a regular &lt;code&gt;function&lt;/code&gt; but with references to &lt;code&gt;this&lt;/code&gt;/&lt;code&gt;@&lt;/code&gt; rewritten to use the outer scope&amp;rsquo;s &lt;code&gt;this&lt;/code&gt;, or with the inner function bound to the outer scope via &lt;code&gt;.bind&lt;/code&gt; (hence the name &amp;ldquo;bound function&amp;rdquo;). In CoffeeScript 2, &lt;code&gt;=&amp;gt;&lt;/code&gt; compiles to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;ES2015&amp;rsquo;s &lt;code&gt;=&amp;gt;&lt;/code&gt;&lt;/a&gt;, which behaves slightly differently. The largest difference is that in ES2015, &lt;code&gt;=&amp;gt;&lt;/code&gt; functions lack an &lt;code&gt;arguments&lt;/code&gt; object:</source>
          <target state="translated">커피 스크립트 1.x에서에서, &lt;code&gt;=&amp;gt;&lt;/code&gt; 일반 컴파일 &lt;code&gt;function&lt;/code&gt; 로 참조되지만 함께 &lt;code&gt;this&lt;/code&gt; / &lt;code&gt;@&lt;/code&gt; 외측 범위의 사용 다시 &lt;code&gt;this&lt;/code&gt; 통해 또는 외부 영역에 결합 된 내부 기능 &lt;code&gt;.bind&lt;/code&gt; (따라서 이름 &quot;경계 기능&quot;) . CoffeeScript 2에서 &lt;code&gt;=&amp;gt;&lt;/code&gt; 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;ES2015의 &lt;code&gt;=&amp;gt;&lt;/code&gt; 로&lt;/a&gt; 컴파일되며 약간 다르게 동작합니다. 가장 큰 차이점은 ES2015에서 &lt;code&gt;=&amp;gt;&lt;/code&gt; 함수에는 &lt;code&gt;arguments&lt;/code&gt; 객체가 없다는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="04b792bc52fa41c8f5a917a0ddd4654b6dc5918b" translate="yes" xml:space="preserve">
          <source>In CoffeeScript 1.x, this used to fail when trying to pass arguments to the script. Some users on OS X worked around the problem by using &lt;code&gt;#!/usr/bin/env coffee --&lt;/code&gt; as the first line of the file. That didn&amp;rsquo;t work on Linux, however, which cannot parse shebang lines with more than a single argument. While such scripts will still run on OS X, CoffeeScript will now display a warning before compiling or evaluating files that begin with a too-long shebang line. Now that CoffeeScript 2 supports passing arguments without needing &lt;code&gt;--&lt;/code&gt;, we recommend simply changing the shebang lines in such scripts to just &lt;code&gt;#!/usr/bin/env coffee&lt;/code&gt;.</source>
          <target state="translated">CoffeeScript 1.x에서는 인수를 스크립트에 전달하려고 할 때 실패했습니다. OS X의 일부 사용자 는 파일의 첫 줄로 &lt;code&gt;#!/usr/bin/env coffee --&lt;/code&gt; 문제를 해결했습니다 . 그러나 Linux에서는 작동하지 않았으므로 하나 이상의 인수로 shebang 행을 구문 분석 할 수 없습니다. 이러한 스크립트는 여전히 OS X에서 실행되지만 CoffeeScript는 너무 긴 shebang 행으로 시작하는 파일을 컴파일하거나 평가하기 전에 경고를 표시합니다. 이제 커피 스크립트 2 지원이 필요없이 인수를 전달하는 것이 &lt;code&gt;--&lt;/code&gt; 우리는 단순히 그러한 스크립트의 오두막 라인을 변경하는 것이 좋습니다 &lt;code&gt;#!/usr/bin/env coffee&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="788287c76d023cee7c5e146f9e2387cfe9252f53" translate="yes" xml:space="preserve">
          <source>In CoffeeScript, comments are denoted by the &lt;code&gt;#&lt;/code&gt; character to the end of a line, or from &lt;code&gt;###&lt;/code&gt; to the next appearance of &lt;code&gt;###&lt;/code&gt;. Comments are ignored by the compiler, though the compiler makes its best effort at reinserting your comments into the output JavaScript after compilation.</source>
          <target state="translated">CoffeeScript에서 주석은 &lt;code&gt;#&lt;/code&gt; 문자로 줄 끝까지 또는 &lt;code&gt;###&lt;/code&gt; 에서 다음 &lt;code&gt;###&lt;/code&gt; 모양으로 표시 됩니다. 컴파일러는 주석을 무시하지만 컴파일 후 주석을 출력 JavaScript에 주석을 다시 삽입하는 데 최선을 다합니다.</target>
        </trans-unit>
        <trans-unit id="9ffbb2a04cb76868837eab857f3bd0071b209bde" translate="yes" xml:space="preserve">
          <source>In ECMAScript this is called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;spread syntax&lt;/a&gt;, and has been supported for arrays since ES2015 and objects since ES2018.</source>
          <target state="translated">ECMAScript에서는이를 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;확산 구문&lt;/a&gt; 이라고하며 ES2015 이후 배열 및 ES2018 이후 객체에 지원되었습니다.</target>
        </trans-unit>
        <trans-unit id="d2f7a2b157c518d92490aade9f7bd6b939d63730" translate="yes" xml:space="preserve">
          <source>In JavaScript, the &lt;code&gt;this&lt;/code&gt; keyword is dynamically scoped to mean the object that the current function is attached to. If you pass a function as a callback or attach it to a different object, the original value of &lt;code&gt;this&lt;/code&gt; will be lost. If you&amp;rsquo;re not familiar with this behavior, &lt;a href=&quot;https://web.archive.org/web/20150316122013/http://www.digital-web.com/articles/scope_in_javascript&quot;&gt;this Digital Web article&lt;/a&gt; gives a good overview of the quirks.</source>
          <target state="translated">JavaScript에서 &lt;code&gt;this&lt;/code&gt; 키워드는 현재 함수가 첨부 된 객체를 의미하도록 동적으로 범위가 지정됩니다. 함수를 콜백으로 전달하거나 다른 객체에 연결하면 원래 값 &lt;code&gt;this&lt;/code&gt; 손실됩니다. 이 동작에 익숙하지 않은 &lt;a href=&quot;https://web.archive.org/web/20150316122013/http://www.digital-web.com/articles/scope_in_javascript&quot;&gt;경우이 디지털 웹 기사&lt;/a&gt; 는 단점에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="58ccf15493189686fa8384205d1ffa6634f16256" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;for&lt;/code&gt; loop, &lt;code&gt;from&lt;/code&gt; compiles to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;ES2015 &lt;code&gt;of&lt;/code&gt;&lt;/a&gt;. (Yes, it&amp;rsquo;s unfortunate; the CoffeeScript &lt;code&gt;of&lt;/code&gt; predates the ES2015 &lt;code&gt;of&lt;/code&gt;.)</source>
          <target state="translated">A의 &lt;code&gt;for&lt;/code&gt; 루프 &lt;code&gt;from&lt;/code&gt; 받는 컴파일 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;ES2015 &lt;code&gt;of&lt;/code&gt; &lt;/a&gt; . (예, 그것은 불행한하며 커피 스크립트 &lt;code&gt;of&lt;/code&gt; 선행 ES2015 &lt;code&gt;of&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="a40e241967ca5277adef3eea005b6b4be0ffdb99" translate="yes" xml:space="preserve">
          <source>In addition to supporting ES2015 classes, CoffeeScript provides a shortcut for working with prototypes. The &lt;code&gt;::&lt;/code&gt; operator gives you quick access to an object&amp;rsquo;s prototype:</source>
          <target state="translated">ES2015 클래스 지원 외에도 CoffeeScript는 프로토 타입 작업을위한 바로 가기를 제공합니다. &lt;code&gt;::&lt;/code&gt; 연산자는 당신에게 객체의 프로토 타입에 빠르게 액세스 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="451347f5385b9e51f536746d2dbc2451299a59b5" translate="yes" xml:space="preserve">
          <source>In the constructor of a derived class (a class that &lt;code&gt;extends&lt;/code&gt; another class), &lt;code&gt;this&lt;/code&gt; cannot be used before calling &lt;code&gt;super&lt;/code&gt;:</source>
          <target state="translated">파생 클래스 (클래스의 생성자에서 &lt;code&gt;extends&lt;/code&gt; 다른 클래스) &lt;code&gt;this&lt;/code&gt; 호출하기 전에 사용될 수 없다 &lt;code&gt;super&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ba1d2a3ac8a3cfec3370e8237d30cfd830778b27" translate="yes" xml:space="preserve">
          <source>Inline &lt;code&gt;###&lt;/code&gt; comments make &lt;a href=&quot;#type-annotations&quot;&gt;type annotations&lt;/a&gt; possible.</source>
          <target state="translated">인라인 &lt;code&gt;###&lt;/code&gt; 주석은 &lt;a href=&quot;#type-annotations&quot;&gt;타입 주석을&lt;/a&gt; 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="6cb9cbd3b08c7fd8fb0c40e013ef550f116fcf3b" translate="yes" xml:space="preserve">
          <source>Instead of a newline or semicolon, &lt;code&gt;then&lt;/code&gt; can be used to separate conditions from expressions, in &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;, and &lt;code&gt;switch&lt;/code&gt;/&lt;code&gt;when&lt;/code&gt; statements.</source>
          <target state="translated">대신 개행 또는 세미콜론, &lt;code&gt;then&lt;/code&gt; 에, 표현에서 별도의 조건에 사용할 수있는 &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; 과 &lt;code&gt;switch&lt;/code&gt; / &lt;code&gt;when&lt;/code&gt; 문.</target>
        </trans-unit>
        <trans-unit id="288bf7e5a0f1cc7c60023fb37b337bf4edaa3530" translate="yes" xml:space="preserve">
          <source>Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler.</source>
          <target state="translated">CoffeeScript를 컴파일하는 대신 간단히 lex하고 구문 분석하고 구문 분석 트리를 인쇄하십시오. 컴파일러 디버깅에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3ca0e2b8ad0603647ea093f1fbd32497da2b06a4" translate="yes" xml:space="preserve">
          <source>Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler.</source>
          <target state="translated">CoffeeScript를 파싱하는 대신 간단히 lex하고 토큰 스트림을 인쇄하십시오. 컴파일러 디버깅에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1448cab4186e9f54c8b08d7cd2d0636b94d3ac93" translate="yes" xml:space="preserve">
          <source>Instead of writing out the JavaScript as a file, print it directly to &lt;strong&gt;stdout&lt;/strong&gt;.</source>
          <target state="translated">JavaScript를 파일로 작성하는 대신 &lt;strong&gt;stdout에&lt;/strong&gt; 직접 인쇄하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b3c2dba907edd3594545f099a0344f3f1d12c7b" translate="yes" xml:space="preserve">
          <source>It can also be used for safer conditional assignment than the JavaScript pattern &lt;code&gt;a = a || value&lt;/code&gt; provides, for cases where you may be handling numbers or strings.</source>
          <target state="translated">JavaScript 패턴보다 안전한 조건부 할당에도 사용할 수 있습니다. &lt;code&gt;a = a || value&lt;/code&gt; 숫자 나 문자열을 처리 할 수있는 경우 값이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4656fa0b7f789159a4076da2dd99866678c8fbb1" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a little difficult to check for the existence of a variable in JavaScript. &lt;code&gt;if (variable) &amp;hellip;&lt;/code&gt; comes close, but fails for zero, the empty string, and false (to name just the most common cases). CoffeeScript&amp;rsquo;s existential operator &lt;code&gt;?&lt;/code&gt; returns true unless a variable is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; or undeclared, which makes it analogous to Ruby&amp;rsquo;s &lt;code&gt;nil?&lt;/code&gt;.</source>
          <target state="translated">JavaScript에 변수가 있는지 확인하는 것은 약간 어렵습니다. &lt;code&gt;if (variable) &amp;hellip;&lt;/code&gt; 가 가깝지만 0, 빈 문자열 및 false (가장 일반적인 경우의 이름)에 실패합니다. CoffeeScript의 실존 연산자 &lt;code&gt;?&lt;/code&gt; 변수가 &lt;code&gt;null&lt;/code&gt; 이거나 &lt;code&gt;undefined&lt;/code&gt; 거나 선언되지 않은 경우 true를 반환 하여 Ruby의 &lt;code&gt;nil?&lt;/code&gt; 과 유사 합니까? .</target>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="c5be221a82247da9792ee8a3ab8649882bae0a0f" translate="yes" xml:space="preserve">
          <source>JSX and the &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; operators</source>
          <target state="translated">JSX와 &lt;code&gt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="fb109f3d3ac46e3151be505c1e1c1768023b31d1" translate="yes" xml:space="preserve">
          <source>Just for kicks, a little bit of the compiler is currently implemented in this fashion: See it &lt;a href=&quot;https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df&quot;&gt;as a document&lt;/a&gt;, &lt;a href=&quot;https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee&quot;&gt;raw&lt;/a&gt;, and &lt;a href=&quot;https://cl.ly/LxEu&quot;&gt;properly highlighted in a text editor&lt;/a&gt;.</source>
          <target state="translated">를 참조하십시오 : 그냥 차기를 들어, 컴파일러의 약간은 현재이 방식으로 구현되는 &lt;a href=&quot;https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df&quot;&gt;문서로&lt;/a&gt; , &lt;a href=&quot;https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee&quot;&gt;원시&lt;/a&gt; , 그리고 &lt;a href=&quot;https://cl.ly/LxEu&quot;&gt;제대로 텍스트 편집기에서 강조&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e7d0e20d61ed8a7062ca711313b21c2b761a366" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;--map&lt;/code&gt;, but include the source map directly in the compiled JavaScript files, rather than in a separate file.</source>
          <target state="translated">&lt;code&gt;--map&lt;/code&gt; 과 마찬가지로 소스 파일을 별도의 파일이 아닌 컴파일 된 JavaScript 파일에 직접 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="ea7ef5627d33e5626e9aefb01f2fd84df3980789" translate="yes" xml:space="preserve">
          <source>Just like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left. In the simplest case, it can be used for parallel assignment:</source>
          <target state="translated">ES2015 이후 JavaScript와 마찬가지로 CoffeeScript에는 구조 지정 구문이 구조화되어 있습니다. 배열 또는 객체 리터럴을 값에 할당하면 CoffeeScript가 분리되어 양쪽을 서로 일치시켜 오른쪽의 값을 왼쪽의 변수에 할당합니다. 가장 간단한 경우 병렬 할당에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c6043a5a849b28412ad4dbe8490852a177ab12e" translate="yes" xml:space="preserve">
          <source>Just like in JSX and HTML, denote XML tags using &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;. You can interpolate CoffeeScript code inside a tag using &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;. To avoid compiler errors, when using &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; to mean &amp;ldquo;less than&amp;rdquo; or &amp;ldquo;greater than,&amp;rdquo; you should wrap the operators in spaces to distinguish them from XML tags. So &lt;code&gt;i &amp;lt; len&lt;/code&gt;, not &lt;code&gt;i&amp;lt;len&lt;/code&gt;. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the &amp;ldquo;less than&amp;rdquo; and &amp;ldquo;greater than&amp;rdquo; operators will remove ambiguity.</source>
          <target state="translated">JSX 및 HTML에서와 마찬가지로 &lt;code&gt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; 를 사용하여 XML 태그를 표시하십시오 . &lt;code&gt;{&lt;/code&gt; 및 &lt;code&gt;}&lt;/code&gt; 를 사용하여 태그 내에서 CoffeeScript 코드를 보간 할 수 있습니다 . 컴파일러 오류를 피하려면 &lt;code&gt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; 를 사용하여 &quot;보다 작음&quot;또는 &quot;보다 큼&quot;을 의미하는 경우 XML 태그와 구분하기 위해 연산자를 공백으로 묶어야합니다. 그래서 &lt;code&gt;i &amp;lt; len&lt;/code&gt; 이 아니라 &lt;code&gt;i&amp;lt;len&lt;/code&gt; 입니다. 컴파일러는 의도 한 것을 확신 할 수 있으면 용서하려고하지만 항상 &quot;보다 작음&quot;및 &quot;보다 큼&quot;연산자 주위에 공백을두면 모호성이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="ee197e1e03ed057d123cd58113296e983974f7c3" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;const&lt;/code&gt; only protects you from &lt;em&gt;reassigning&lt;/em&gt; a variable; it doesn&amp;rsquo;t prevent the variable&amp;rsquo;s value from changing, the way constants usually do in other languages:</source>
          <target state="translated">있다는 사실을 숙지 &lt;code&gt;const&lt;/code&gt; 단지에서 당신을 보호 &lt;em&gt;재 할당&lt;/em&gt; 변수를; 상수가 다른 언어에서 일반적으로 수행되는 방식으로 변수 값이 변경되는 것을 막지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="b52e6ec9fa3d5c13a402c0dc8beb63c9192cad04" translate="yes" xml:space="preserve">
          <source>Language Reference</source>
          <target state="translated">언어 참조</target>
        </trans-unit>
        <trans-unit id="b49dc37eaf51e72990aba7aaaf76623a346cbd37" translate="yes" xml:space="preserve">
          <source>Launch an interactive CoffeeScript session to try short snippets. Identical to calling &lt;code&gt;coffee&lt;/code&gt; with no arguments.</source>
          <target state="translated">대화식 CoffeeScript 세션을 시작하여 짧은 스 니펫을 시도하십시오. 논쟁없이 &lt;code&gt;coffee&lt;/code&gt; 를 부르는 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="a3e90043205a881c2853c2eca6f3e45fcbc541f7" translate="yes" xml:space="preserve">
          <source>Leading &lt;code&gt;.&lt;/code&gt; closes all open calls, allowing for simpler chaining syntax.</source>
          <target state="translated">선도 &lt;code&gt;.&lt;/code&gt; 모든 열린 통화를 닫아 더 간단한 연결 구문을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="9f985d44bdfbd0484f99e8d147e15d78e5abb70b" translate="yes" xml:space="preserve">
          <source>Lexical Scoping and Variable Safety</source>
          <target state="translated">어휘 범위 및 가변 안전</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="807e50c12f9e6b05f56a04dd9b9ff076073a65d0" translate="yes" xml:space="preserve">
          <source>Like JavaScript and many other languages, CoffeeScript supports strings as delimited by the &lt;code&gt;&quot;&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt; characters. CoffeeScript also supports string interpolation within &lt;code&gt;&quot;&lt;/code&gt;-quoted strings, using &lt;code&gt;#{ &amp;hellip; }&lt;/code&gt;. Single-quoted strings are literal. You may even use interpolation in object keys.</source>
          <target state="translated">JavaScript 및 기타 여러 언어와 마찬가지로 CoffeeScript는 &lt;code&gt;&quot;&lt;/code&gt; 또는 &lt;code&gt;'&lt;/code&gt; 문자 로 구분 된 문자열을 지원합니다 . CoffeeScript는 &lt;code&gt;#{ &amp;hellip; }&lt;/code&gt; 사용하여 &lt;code&gt;&quot;&lt;/code&gt; 인용 문자열 내에서 문자열 보간도 지원합니다 . 작은 따옴표로 묶인 문자열은 리터럴입니다. 객체 키에 보간을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f3952077d0c37b4982e8e71fecd691cae455a81" translate="yes" xml:space="preserve">
          <source>List items can be at most only one paragraph long. The second paragraph of a list item would be indented after a blank line, and therefore indistinguishable from a code block.</source>
          <target state="translated">목록 항목은 최대 한 단락 길이 일 수 있습니다. 목록 항목의 두 번째 단락은 빈 줄 뒤에 들여 쓰기되므로 코드 블록과 구분할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f9958a2677c3ef0351f8de1b9c79ba7331f155a4" translate="yes" xml:space="preserve">
          <source>Literate CoffeeScript</source>
          <target state="translated">Literate CoffeeScript</target>
        </trans-unit>
        <trans-unit id="e0923ed716463b8c9d5b244e2f6ba2d222d500d9" translate="yes" xml:space="preserve">
          <source>Literate CoffeeScript parsing</source>
          <target state="translated">Literate CoffeeScript 구문 분석</target>
        </trans-unit>
        <trans-unit id="e83f1c0d81e570990421db9c6c5103dd52bab5e9" translate="yes" xml:space="preserve">
          <source>Loops and Comprehensions</source>
          <target state="translated">루프와 이해</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="d0b44f3bb54288ce6ecf8af194238e14f5bd47a8" translate="yes" xml:space="preserve">
          <source>Most modern JavaScript features that CoffeeScript supports can run natively in Node 7.6+, meaning that Node can run CoffeeScript&amp;rsquo;s output without any further processing required. Here are some notable exceptions:</source>
          <target state="translated">CoffeeScript가 지원하는 대부분의 최신 JavaScript 기능은 기본적으로 Node 7.6 이상에서 실행될 수 있습니다. 즉, 노드는 추가 처리없이 CoffeeScript의 출력을 실행할 수 있습니다. 다음은 몇 가지 주목할만한 예외입니다.</target>
        </trans-unit>
        <trans-unit id="5987894415f15faa1342fc04b8e4f45d10eb5711" translate="yes" xml:space="preserve">
          <source>Most of the loops you&amp;rsquo;ll write in CoffeeScript will be &lt;strong&gt;comprehensions&lt;/strong&gt; over arrays, objects, and ranges. Comprehensions replace (and compile into) &lt;code&gt;for&lt;/code&gt; loops, with optional guard clauses and the value of the current array index. Unlike for loops, array comprehensions are expressions, and can be returned and assigned.</source>
          <target state="translated">당신이 커피 스크립트에서 쓸 것이다 루프의 대부분은 될 것입니다 &lt;strong&gt;지능형&lt;/strong&gt; 배열, 객체, 범위에서. 함축 교체 (과에 컴파일) &lt;code&gt;for&lt;/code&gt; 옵션 가드 조항과 현재의 배열 인덱스의 값으로, 루프. for 루프와 달리 배열 이해는 표현식이며 반환 및 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e980a53fb5f690679ff0ebade16b508f890902d3" translate="yes" xml:space="preserve">
          <source>Multiline strings are allowed in CoffeeScript. Lines are joined by a single space unless they end with a backslash. Indentation is ignored.</source>
          <target state="translated">CoffeeScript에서는 여러 줄 문자열이 허용됩니다. 백 슬래시로 끝나지 않는 한 행은 단일 공백으로 결합됩니다. 들여 쓰기는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9c21b9713784f3e4cfd595b3aa43dab514b15d2c" translate="yes" xml:space="preserve">
          <source>Named functions and function declarations</source>
          <target state="translated">명명 된 함수 및 함수 선언</target>
        </trans-unit>
        <trans-unit id="685d8185cabac29e4bc33d85c18962f2c64b8915" translate="yes" xml:space="preserve">
          <source>Needs to be rewritten the old-fashioned way:</source>
          <target state="translated">구식 방식으로 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="9367a041098127356c25562e1a256085d58951ce" translate="yes" xml:space="preserve">
          <source>Newcomers to CoffeeScript often wonder how to generate the JavaScript &lt;code&gt;function foo() {}&lt;/code&gt;, as opposed to the &lt;code&gt;foo = function() {}&lt;/code&gt; that CoffeeScript produces. The first form is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;function declaration&lt;/a&gt;, and the second is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function&quot;&gt;function expression&lt;/a&gt;. As stated above, in CoffeeScript &lt;a href=&quot;#expressions&quot;&gt;everything is an expression&lt;/a&gt;, so naturally we favor the expression form. Supporting only one variant helps avoid confusing bugs that can arise from the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting&quot;&gt;subtle differences between the two forms&lt;/a&gt;.</source>
          <target state="translated">CoffeeScript를 처음 사용하는 경우에는 CoffeeScript에서 생성 하는 &lt;code&gt;foo = function() {}&lt;/code&gt; 과는 반대로 JavaScript &lt;code&gt;function foo() {}&lt;/code&gt; 를 생성하는 방법이 궁금합니다 . 첫 번째 형식은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function&quot;&gt;함수 선언&lt;/a&gt; 이고 두 번째 형식은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function&quot;&gt;함수 식&lt;/a&gt; 입니다. 위에서 언급했듯이 CoffeeScript에서는 &lt;a href=&quot;#expressions&quot;&gt;모든 것이 표현&lt;/a&gt; 이므로 자연스럽게 표현 양식을 선호합니다. 하나의 변형 만 지원 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function#Function_declaration_hoisting&quot;&gt;하면 두 형식&lt;/a&gt; 의 미묘한 차이로 인해 발생할 수있는 혼란스러운 버그를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10b3493287f831e81a438811a1ffba01f8cec4b7" translate="yes" xml:space="preserve">
          <source>Node.js</source>
          <target state="translated">Node.js</target>
        </trans-unit>
        <trans-unit id="a17d639e61da9d0653ca53ca643f92af7655ebe3" translate="yes" xml:space="preserve">
          <source>Note how because we are assigning the value of the comprehensions to a variable in the example above, CoffeeScript is collecting the result of each iteration into an array. Sometimes functions end with loops that are intended to run only for their side-effects. Be careful that you&amp;rsquo;re not accidentally returning the results of the comprehension in these cases, by adding a meaningful return value &amp;mdash; like &lt;code&gt;true&lt;/code&gt; &amp;mdash; or &lt;code&gt;null&lt;/code&gt;, to the bottom of your function.</source>
          <target state="translated">위의 예제에서 이해의 값을 변수에 할당하기 때문에 CoffeeScript는 각 반복의 결과를 배열로 수집합니다. 때로는 함수가 부작용으로 만 실행되는 루프로 끝납니다. 이 경우 함수 하단에 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;null&lt;/code&gt; 과 같은 의미있는 반환 값을 추가하여 실수로 이해 결과를 반환하지 않도록주의하십시오 .</target>
        </trans-unit>
        <trans-unit id="7878aae2bc5e1df5f94aa51acb2a5c0788234496" translate="yes" xml:space="preserve">
          <source>Note that JavaScript strings are immutable, and can&amp;rsquo;t be spliced.</source>
          <target state="translated">JavaScript 문자열은 변경할 수 없으며 스 플라이 싱 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d3179b6c8afd9cdc3bb1ec6e1c16cc445004943e" translate="yes" xml:space="preserve">
          <source>Note that if the compiler knows that &lt;code&gt;a&lt;/code&gt; is in scope and therefore declared, &lt;code&gt;a?&lt;/code&gt; compiles to &lt;code&gt;a != null&lt;/code&gt;, &lt;em&gt;not&lt;/em&gt;&lt;code&gt;a !== null&lt;/code&gt;. The &lt;code&gt;!=&lt;/code&gt; makes a loose comparison to &lt;code&gt;null&lt;/code&gt;, which does double duty also comparing against &lt;code&gt;undefined&lt;/code&gt;. The reverse also holds for &lt;code&gt;not a?&lt;/code&gt; or &lt;code&gt;unless a?&lt;/code&gt;.</source>
          <target state="translated">컴파일러가 &lt;code&gt;a&lt;/code&gt; 가 범위 내에 있고 선언되어 있음을 알고 있다면 &lt;code&gt;a?&lt;/code&gt; 로 컴파일 &lt;code&gt;a != null&lt;/code&gt; , &lt;em&gt;하지 &lt;/em&gt; &lt;code&gt;a !== null&lt;/code&gt; . 는 &lt;code&gt;!=&lt;/code&gt; 로 느슨한 비교한다 &lt;code&gt;null&lt;/code&gt; 의 도에 대해 비교하는 이중 임무 수행, &lt;code&gt;undefined&lt;/code&gt; . 그 반대도 &lt;code&gt;not a?&lt;/code&gt; 아니면 &lt;code&gt;unless a?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c346bd383bcb5c9fab50c836103159e19fa051e2" translate="yes" xml:space="preserve">
          <source>Note that the CoffeeScript compiler &lt;strong&gt;does not resolve modules&lt;/strong&gt;; writing an &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; statement in CoffeeScript will produce an &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; statement in the resulting output. It is your responsibility to &lt;a href=&quot;#transpilation&quot;&gt;transpile&lt;/a&gt; this ES2015 syntax into code that will work in your target runtimes.</source>
          <target state="translated">CoffeeScript 컴파일러 &lt;strong&gt;는 모듈을 해석하지 않습니다&lt;/strong&gt; . 쓰기 &lt;code&gt;import&lt;/code&gt; 또는 &lt;code&gt;export&lt;/code&gt; 커피 스크립트에 문 것은 생산합니다 &lt;code&gt;import&lt;/code&gt; 또는 &lt;code&gt;export&lt;/code&gt; 결과 출력에 문을. 당신의 책임입니다 &lt;a href=&quot;#transpilation&quot;&gt;transpile&lt;/a&gt; 대상 런타임에서 작동 코드로이 ES2015 구문을.</target>
        </trans-unit>
        <trans-unit id="3da55fdb5cea2e3963662a9bb50c1c4e14f19b69" translate="yes" xml:space="preserve">
          <source>Note that transpiling doesn&amp;rsquo;t automatically supply &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Polyfill&quot;&gt;polyfills&lt;/a&gt; for your code. CoffeeScript itself will output &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf&quot;&gt;&lt;code&gt;Array.indexOf&lt;/code&gt;&lt;/a&gt; if you use the &lt;code&gt;in&lt;/code&gt; operator, or destructuring or spread/rest syntax; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;&lt;code&gt;Function.bind&lt;/code&gt;&lt;/a&gt; if you use a bound (&lt;code&gt;=&amp;gt;&lt;/code&gt;) method in a class. Both are supported in Internet Explorer 9+ and all more recent browsers, but you will need to supply polyfills if you need to support Internet Explorer 8 or below and are using features that would cause these methods to be output. You&amp;rsquo;ll also need to supply polyfills if your own code uses these methods or another method added in recent versions of JavaScript. One polyfill option is &lt;a href=&quot;https://babeljs.io/docs/en/babel-polyfill/&quot;&gt;&lt;code&gt;@babel/polyfill&lt;/code&gt;&lt;/a&gt;, though there are many &lt;a href=&quot;https://hackernoon.com/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423&quot;&gt;other&lt;/a&gt;&lt;a href=&quot;https://philipwalton.com/articles/loading-polyfills-only-when-needed/&quot;&gt;strategies&lt;/a&gt;.</source>
          <target state="translated">코드 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Polyfill&quot;&gt;변환&lt;/a&gt; 은 코드에 대한 폴리 필 을 자동으로 제공하지 않습니다 . &lt;code&gt;in&lt;/code&gt; 연산자 를 사용하거나 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf&quot;&gt; &lt;code&gt;Array.indexOf&lt;/code&gt; &lt;/a&gt; 또는 분산 / rest 구문 을 사용하면 CoffeeScript 자체가 Array.indexOf 를 출력 합니다. 그리고 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt; &lt;code&gt;Function.bind&lt;/code&gt; 는&lt;/a&gt; 당신은 바인딩 (사용하는 경우 &lt;code&gt;=&amp;gt;&lt;/code&gt; 클래스에서) 방법을. 둘 다 Internet Explorer 9 이상 및 모든 최신 브라우저에서 지원되지만 Internet Explorer 8 이하를 지원해야하고 이러한 메소드가 출력되도록하는 기능을 사용하는 경우 폴리 필을 제공해야합니다. 자체 코드에서 이러한 방법을 사용하거나 최신 버전의 JavaScript에 추가 된 다른 방법을 사용하는 경우 폴리 필을 제공해야합니다. 하나의 polyfill 옵션은 &lt;a href=&quot;https://babeljs.io/docs/en/babel-polyfill/&quot;&gt; &lt;code&gt;@babel/polyfill&lt;/code&gt; &lt;/a&gt; .&lt;a href=&quot;https://hackernoon.com/polyfills-everything-you-ever-wanted-to-know-or-maybe-a-bit-less-7c8de164e423&quot;&gt;다른 &lt;/a&gt;&lt;a href=&quot;https://philipwalton.com/articles/loading-polyfills-only-when-needed/&quot;&gt;전략&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b0e75b1cc5940f3dfdf0f98f2537757533933df2" translate="yes" xml:space="preserve">
          <source>Notice how all of the variable declarations have been pushed up to the top of the closest scope, the first time they appear. &lt;code&gt;outer&lt;/code&gt; is not redeclared within the inner function, because it&amp;rsquo;s already in scope; &lt;code&gt;inner&lt;/code&gt; within the function, on the other hand, should not be able to change the value of the external variable of the same name, and therefore has a declaration of its own.</source>
          <target state="translated">모든 변수 선언이 처음 표시 될 때 가장 가까운 범위의 상단으로 어떻게 올라 갔는지 확인하십시오. &lt;code&gt;outer&lt;/code&gt; 는 이미 범위 내에 있으므로 inner 함수 내에서 다시 선언되지 않습니다. 반면 함수 내에서 &lt;code&gt;inner&lt;/code&gt; 는 동일한 이름의 외부 변수 값을 변경할 수 없어서 자체 선언이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca1abda92d5b54711ee766219d8e2c4693c6ca7a" translate="yes" xml:space="preserve">
          <source>Now you would just type:</source>
          <target state="translated">이제 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="566c9ccf76b4698b00a6f761b3c71b9f0e05eb29" translate="yes" xml:space="preserve">
          <source>Objects and Arrays</source>
          <target state="translated">객체와 배열</target>
        </trans-unit>
        <trans-unit id="5fc811955d55e0ff5b82d1a49c11e277df049033" translate="yes" xml:space="preserve">
          <source>Older plugins or forks of CoffeeScript supported JSX syntax and referred to it as CSX or CJSX. They also often used a &lt;code&gt;.cjsx&lt;/code&gt; file extension, but this is no longer necessary; regular &lt;code&gt;.coffee&lt;/code&gt; will do.</source>
          <target state="translated">CoffeeScript의 이전 플러그인 또는 포크는 JSX 구문을 지원했으며이를 CSX 또는 CJSX라고합니다. 또한 종종 &lt;code&gt;.cjsx&lt;/code&gt; 파일 확장자를 사용했지만 더 이상 필요하지 않습니다. 일반 &lt;code&gt;.coffee&lt;/code&gt; 가 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="47445da7574ef1c2b9f9dbbf29f9a3e160cc9748" translate="yes" xml:space="preserve">
          <source>On non-Windows platforms, a &lt;code&gt;.coffee&lt;/code&gt; file can be made executable by adding a shebang (&lt;code&gt;#!&lt;/code&gt;) line at the top of the file and marking the file as executable. For example:</source>
          <target state="translated">Windows 이외의 플랫폼에서는 파일 맨 위에 shebang ( &lt;code&gt;#!&lt;/code&gt; ) 행을 추가 하고 파일을 실행 파일로 표시하여 &lt;code&gt;.coffee&lt;/code&gt; 파일을 실행 가능하게 만들 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="88e58b2db811a67c2866ad03f41850be69476b09" translate="yes" xml:space="preserve">
          <source>Once installed, you should have access to the &lt;code&gt;coffee&lt;/code&gt; command, which can execute scripts, compile &lt;code&gt;.coffee&lt;/code&gt; files into &lt;code&gt;.js&lt;/code&gt;, and provide an interactive REPL. The &lt;code&gt;coffee&lt;/code&gt; command takes the following options:</source>
          <target state="translated">설치 한 후에는 스크립트를 실행하고 &lt;code&gt;.coffee&lt;/code&gt; 파일을 &lt;code&gt;.js&lt;/code&gt; 로 컴파일 하고 대화식 REPL을 제공 할 수 있는 &lt;code&gt;coffee&lt;/code&gt; 명령에 액세스 할 수 있어야합니다 . &lt;code&gt;coffee&lt;/code&gt; 명령은 다음 옵션을 취합니다</target>
        </trans-unit>
        <trans-unit id="968e4a68ad115837ed26068f6b0ed2cb269d66ce" translate="yes" xml:space="preserve">
          <source>Once you have &lt;code&gt;@babel/core&lt;/code&gt; and &lt;code&gt;@babel/preset-env&lt;/code&gt; (or other presets or plugins) installed, and a &lt;code&gt;.babelrc&lt;/code&gt; file (or other equivalent) in place, you can use &lt;code&gt;coffee --transpile&lt;/code&gt; to pipe CoffeeScript&amp;rsquo;s output through Babel using the options you&amp;rsquo;ve saved.</source>
          <target state="translated">당신은 일단 &lt;code&gt;@babel/core&lt;/code&gt; 및 &lt;code&gt;@babel/preset-env&lt;/code&gt; (또는 다른 프리셋 또는 플러그인) 설치 및 &lt;code&gt;.babelrc&lt;/code&gt; 의 장소에 파일 (또는 이와 동등)은, 당신이 사용할 수있는 &lt;code&gt;coffee --transpile&lt;/code&gt; 사용하여 바벨을 통해 파이프 커피 스크립트의 출력 저장 한 옵션.</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="1863519535480ab59ac39566f63c3643c8a7c46d" translate="yes" xml:space="preserve">
          <source>Operators and Aliases</source>
          <target state="translated">연산자 및 별칭</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="70d58de47bef0c1dc805b8a5582bf3bb4065cd12" translate="yes" xml:space="preserve">
          <source>Or if you know that the parent function doesn&amp;rsquo;t require arguments, just call &lt;code&gt;super()&lt;/code&gt;:</source>
          <target state="translated">또는 부모 함수에 인수가 필요하지 않다는 것을 알고 있다면 &lt;code&gt;super()&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="4abfdc58ca2958fb7f19e78ea1f0eafecc095c1b" translate="yes" xml:space="preserve">
          <source>Or if you&amp;rsquo;re running the &lt;code&gt;coffee&lt;/code&gt; command outside of a project folder, using a globally-installed &lt;code&gt;coffeescript&lt;/code&gt; module, &lt;code&gt;@babel/core&lt;/code&gt; needs to be installed globally:</source>
          <target state="translated">또는 글로벌로 설치된 &lt;code&gt;coffeescript&lt;/code&gt; 모듈을 사용하여 프로젝트 폴더 외부 에서 &lt;code&gt;coffee&lt;/code&gt; 명령을 실행하는 경우 &lt;code&gt;@babel/core&lt;/code&gt; 를 글로벌로 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="3582229790b1aa109582562e652fba246dfb989e" translate="yes" xml:space="preserve">
          <source>Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over &lt;strong&gt;stdio&lt;/strong&gt;, or using some sort of extension-less file name.</source>
          <target state="translated">코드를 Literate CoffeeScript로 구문 분석합니다. &lt;strong&gt;stdio를&lt;/strong&gt; 통해 직접 코드를 전달 하거나 확장자가없는 파일 이름 을 사용하는 경우에만이를 지정하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f1dcee64c9b040dea753f1d5184978e4fd28e2b" translate="yes" xml:space="preserve">
          <source>Per the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters&quot;&gt;ES2015 spec regarding function default parameters&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values&quot;&gt;destructuring default values&lt;/a&gt;, default values are only applied when a value is missing or &lt;code&gt;undefined&lt;/code&gt;. In CoffeeScript 1.x, the default value would be applied in those cases but also if the value was &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">당 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters&quot;&gt;ES2015 사양에 관한 기본 함수 파라미터&lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Default_values&quot;&gt;destructuring 디폴트 값&lt;/a&gt; , 디폴트 값은 값이 없거나 때 적용 &lt;code&gt;undefined&lt;/code&gt; . CoffeeScript 1.x에서는 이러한 경우 기본값이 적용되지만 값이 &lt;code&gt;null&lt;/code&gt; 인 경우에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="dd72d92f93bcbc4707fdbf29cee5a48b123c133c" translate="yes" xml:space="preserve">
          <source>Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example:</source>
          <target state="translated">CoffeeScript를 STDIN으로 파이프하고 STDOUT을 통해 JavaScript를 다시 가져옵니다. 다른 언어로 작성된 프로세스에 사용하기에 좋습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="bb867dd7a9b38a2aedeac5fcb2379aed6eed2d63" translate="yes" xml:space="preserve">
          <source>Pipe the CoffeeScript compiler&amp;rsquo;s output through Babel before saving or running the generated JavaScript. Requires &lt;code&gt;@babel/core&lt;/code&gt; to be installed, and options to pass to Babel in a &lt;code&gt;.babelrc&lt;/code&gt; file or a &lt;code&gt;package.json&lt;/code&gt; with a &lt;code&gt;babel&lt;/code&gt; key in the path of the file or folder to be compiled. See &lt;a href=&quot;#transpilation&quot;&gt;Transpilation&lt;/a&gt;.</source>
          <target state="translated">생성 된 JavaScript를 저장하거나 실행하기 전에 Babel을 통해 CoffeeScript 컴파일러의 출력을 파이프하십시오. 필요 &lt;code&gt;@babel/core&lt;/code&gt; A의 바벨에 전달할 설치하고, 옵션 &lt;code&gt;.babelrc&lt;/code&gt; 의 파일 또는 &lt;code&gt;package.json&lt;/code&gt; A를 &lt;code&gt;babel&lt;/code&gt; 파일 또는 폴더의 경로에 키 컴파일 할 수 있습니다. &lt;a href=&quot;#transpilation&quot;&gt;Transpilation을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c65de7239130b2221dc156af1c9b5fa8125b9bf3" translate="yes" xml:space="preserve">
          <source>Polyfills</source>
          <target state="translated">Polyfills</target>
        </trans-unit>
        <trans-unit id="32f6d152131c542beafde761060b9c5187fa0fd9" translate="yes" xml:space="preserve">
          <source>Print out the compiled JS from a one-liner:</source>
          <target state="translated">하나의 라이너에서 컴파일 된 JS를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="a4e2d5650ff557033b751f41cc52650a02e0ddc8" translate="yes" xml:space="preserve">
          <source>Prototypal Inheritance</source>
          <target state="translated">프로토 타입 상속</target>
        </trans-unit>
        <trans-unit id="d07133c8504b6a0e98371a1b9afe2ca2855a7270" translate="yes" xml:space="preserve">
          <source>Quickstart</source>
          <target state="translated">Quickstart</target>
        </trans-unit>
        <trans-unit id="0d5fda95e3940bc09dc1ccc22666813c0b54f73d" translate="yes" xml:space="preserve">
          <source>Ranges</source>
          <target state="translated">Ranges</target>
        </trans-unit>
        <trans-unit id="24aaf8084dd55feaa39e1aafbe6c650fc362ceae" translate="yes" xml:space="preserve">
          <source>Ranges can also be used to extract slices of arrays. With two dots (&lt;code&gt;3..6&lt;/code&gt;), the range is inclusive (&lt;code&gt;3, 4, 5, 6&lt;/code&gt;); with three dots (&lt;code&gt;3...6&lt;/code&gt;), the range excludes the end (&lt;code&gt;3, 4, 5&lt;/code&gt;). Slices indices have useful defaults. An omitted first index defaults to zero and an omitted second index defaults to the size of the array.</source>
          <target state="translated">배열 조각을 추출하는 데 범위를 사용할 수도 있습니다. 두 개의 점 ( &lt;code&gt;3..6&lt;/code&gt; )으로 범위는 &lt;code&gt;3, 4, 5, 6&lt;/code&gt; 입니다. 3 개의 점 ( &lt;code&gt;3...6&lt;/code&gt; )으로 범위는 끝 ( &lt;code&gt;3, 4, 5&lt;/code&gt; )을 제외합니다 . 슬라이스 인덱스에는 유용한 기본값이 있습니다. 생략 된 첫 번째 색인의 기본값은 0이고 생략 된 두 번째 색인의 기본값은 배열의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="87df60de337fb58864343e396696d74611e0d403" translate="yes" xml:space="preserve">
          <source>Resources</source>
          <target state="translated">Resources</target>
        </trans-unit>
        <trans-unit id="28bada3d37bb0a3a9f2a34311d7e6164ba0dc426" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://babeljs.io/docs/plugins/&quot;&gt;Babel&amp;rsquo;s website to learn about presets and plugins&lt;/a&gt; and the multitude of options you have. Another preset you might need is &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/&quot;&gt;&lt;code&gt;@babel/plugin-transform-react-jsx&lt;/code&gt;&lt;/a&gt; if you&amp;rsquo;re using JSX with React (JSX can also be used with other frameworks).</source>
          <target state="translated">&lt;a href=&quot;https://babeljs.io/docs/plugins/&quot;&gt;사전 설정 및 플러그인&lt;/a&gt; 및 다양한 옵션 에 대한 자세한 내용은 Babel 웹 사이트를 참조하십시오 . 당신이해야 할 또 다른 사전 설정 값은 &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-react-jsx/&quot;&gt; &lt;code&gt;@babel/plugin-transform-react-jsx&lt;/code&gt; &lt;/a&gt; 당신이 (JSX 또한 다른 프레임 워크와 함께 사용할 수 있습니다) 반작용으로 JSX를 사용하는 경우.</target>
        </trans-unit>
        <trans-unit id="74aa7d3d7d4395b004fa0da48ff50e997cf268b3" translate="yes" xml:space="preserve">
          <source>Similar to block strings and comments, CoffeeScript supports block regexes &amp;mdash; extended regular expressions that ignore internal whitespace and can contain comments and interpolation. Modeled after Perl&amp;rsquo;s &lt;code&gt;/x&lt;/code&gt; modifier, CoffeeScript&amp;rsquo;s block regexes are delimited by &lt;code&gt;///&lt;/code&gt; and go a long way towards making complex regular expressions readable. To quote from the CoffeeScript source:</source>
          <target state="translated">블록 문자열 및 주석과 마찬가지로 CoffeeScript는 내부 공백을 무시하고 주석 및 보간을 포함 할 수있는 확장 정규식 인 블록 정규식을 지원합니다. Perl의 &lt;code&gt;/x&lt;/code&gt; 수정자를 모델로 한 CoffeeScript의 블록 정규 표현식 은 &lt;code&gt;///&lt;/code&gt; 로 구분되며 복잡한 정규 표현식을 읽을 수 있도록 먼 길을갑니다. CoffeeScript 소스에서 인용하려면 :</target>
        </trans-unit>
        <trans-unit id="8159f92ff6c06035d06cbb7eb3033fede5940b02" translate="yes" xml:space="preserve">
          <source>Similar to how &lt;code&gt;yield return&lt;/code&gt; forces a generator, &lt;code&gt;await return&lt;/code&gt; may be used to force a function to be async.</source>
          <target state="translated">&lt;code&gt;yield return&lt;/code&gt; 이 생성기를 강제하는 방법과 유사하게 &lt;code&gt;await return&lt;/code&gt; 을 사용하여 함수를 비동기로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4a58561dd9ce9ebf0ef891fdc51fcf365c7dc7e" translate="yes" xml:space="preserve">
          <source>Since CoffeeScript takes care of all variable declaration, it is not possible to declare variables with ES2015&amp;rsquo;s &lt;code&gt;let&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt;. &lt;a href=&quot;#unsupported-let-const&quot;&gt;This is intentional&lt;/a&gt;; we feel that the simplicity gained by not having to think about variable declaration outweighs the benefit of having three separate ways to declare variables.</source>
          <target state="translated">CoffeeScript는 모든 변수 선언을 처리하므로 ES2015의 &lt;code&gt;let&lt;/code&gt; 또는 &lt;code&gt;const&lt;/code&gt; 로 변수를 선언 할 수 없습니다 . &lt;a href=&quot;#unsupported-let-const&quot;&gt;이것은 의도적입니다&lt;/a&gt; . 변수 선언에 대해 생각할 필요가없는 단순성은 변수를 선언하는 세 가지 별도의 방법이 있다는 이점보다 중요하다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="5774da7b802f7af9150c4273aaf57f7387c8eb1d" translate="yes" xml:space="preserve">
          <source>Source Maps</source>
          <target state="translated">소스 맵</target>
        </trans-unit>
        <trans-unit id="da68b1026804cc80434fc637d86d0eb96635cb24" translate="yes" xml:space="preserve">
          <source>Splats also let us elide array elements&amp;hellip;</source>
          <target state="translated">스 플랫은 또한 배열 요소를 제거 할 수있게 해줍니다&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="424dbd400ae6e38a2f49aadeb924ee108357cfdb" translate="yes" xml:space="preserve">
          <source>Splats, or Rest Parameters/Spread Syntax</source>
          <target state="translated">스 플랫 또는 레스트 파라미터 / 스프레드 구문</target>
        </trans-unit>
        <trans-unit id="326a96ab3ee59b29761fe875d4032ef3fd1dcd75" translate="yes" xml:space="preserve">
          <source>Start the CoffeeScript REPL (&lt;code&gt;Ctrl-D&lt;/code&gt; to exit, &lt;code&gt;Ctrl-V&lt;/code&gt;for multi-line):</source>
          <target state="translated">CoffeeScript REPL을 시작합니다 ( &lt;code&gt;Ctrl-D&lt;/code&gt; 를 종료 하고 여러 줄을 입력 &lt;code&gt;Ctrl-V&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5653cebc057d4791ce07031ad9286e729de6d691" translate="yes" xml:space="preserve">
          <source>Statements</source>
          <target state="translated">Statements</target>
        </trans-unit>
        <trans-unit id="fd9b9a809e9699ee433dd5e37059d01714f797c7" translate="yes" xml:space="preserve">
          <source>Static methods can be defined using &lt;code&gt;@&lt;/code&gt; before the method name:</source>
          <target state="translated">메소드 이름 앞에 &lt;code&gt;@&lt;/code&gt; 를 사용하여 정적 메소드를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb5eff5196ac991028b63b54dacf4e8686fd3692" translate="yes" xml:space="preserve">
          <source>Static type checking can be achieved in CoffeeScript by using &lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;Comment Types syntax&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/&quot;&gt;Flow&lt;/a&gt; 의 &lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;주석 유형 구문&lt;/a&gt; 을 사용하여 CoffeeScript에서 정적 유형 검사를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="84130039777ac54831b333570728881088c16ed5" translate="yes" xml:space="preserve">
          <source>Suppress the &amp;ldquo;Generated by CoffeeScript&amp;rdquo; header.</source>
          <target state="translated">&quot;Generated by CoffeeScript&quot;헤더를 억제하십시오.</target>
        </trans-unit>
        <trans-unit id="292abefb8a7c036089ac917fd0757a7bb6e3111c" translate="yes" xml:space="preserve">
          <source>Switch/When/Else</source>
          <target state="translated">Switch/When/Else</target>
        </trans-unit>
        <trans-unit id="5fd53f2212dd11ad266f50696cd5a9ca1ea708d6" translate="yes" xml:space="preserve">
          <source>Tagged Template Literals</source>
          <target state="translated">태그가 지정된 템플릿 리터럴</target>
        </trans-unit>
        <trans-unit id="468657e1c13e92e3564728da3cdadc47c49817c6" translate="yes" xml:space="preserve">
          <source>Task definitions are written in CoffeeScript, so you can put arbitrary code in your Cakefile. Define a task with a name, a long description, and the function to invoke when the task is run. If your task takes a command-line option, you can define the option with short and long flags, and it will be made available in the &lt;code&gt;options&lt;/code&gt; object. Here&amp;rsquo;s a task that uses the Node.js API to rebuild CoffeeScript&amp;rsquo;s parser:</source>
          <target state="translated">작업 정의는 CoffeeScript로 작성되므로 Cakefile에 임의의 코드를 넣을 수 있습니다. 이름, 자세한 설명 및 작업 실행시 호출 할 기능을 사용하여 작업을 정의하십시오. 작업에 명령 줄 옵션이 있으면 short 및 long 플래그를 사용하여 옵션을 정의 할 수 있으며 &lt;code&gt;options&lt;/code&gt; 개체 에서 사용할 수 있습니다 . Node.js API를 사용하여 CoffeeScript 파서를 다시 작성하는 작업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1bc65a5d778ee3969a41b1e46397162f821ca5f0" translate="yes" xml:space="preserve">
          <source>Technically, &lt;code&gt;foo = function() {}&lt;/code&gt; is creating an anonymous function that gets assigned to a variable named &lt;code&gt;foo&lt;/code&gt;. Some very early versions of CoffeeScript named this function, e.g. &lt;code&gt;foo = function foo() {}&lt;/code&gt;, but this was dropped because of compatibility issues with Internet Explorer. For a while this annoyed people, as these functions would be unnamed in stack traces; but modern JavaScript runtimes &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name&quot;&gt;infer the names of such anonymous functions&lt;/a&gt; from the names of the variables to which they&amp;rsquo;re assigned. Given that this is the case, it&amp;rsquo;s simplest to just preserve the current behavior.</source>
          <target state="translated">기술적으로 &lt;code&gt;foo = function() {}&lt;/code&gt; 은 &lt;code&gt;foo&lt;/code&gt; 라는 변수에 할당되는 익명 함수를 작성합니다 . 초기 버전의 CoffeeScript에서는이 함수의 이름을 &lt;code&gt;foo = function foo() {}&lt;/code&gt; 로 지정했지만 Internet Explorer와의 호환성 문제로 인해 삭제되었습니다. 이 기능은 스택 트레이스에서 이름이 지정되지 않았기 때문에 한동안이 짜증나는 사람들입니다. 그러나 최신 JavaScript 런타임 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name&quot;&gt;은 이러한 익명 함수&lt;/a&gt; 의 이름이 지정된 변수의 이름에서 유추합니다 . 이 경우를 고려하면 현재 동작을 유지하는 것이 가장 간단합니다.</target>
        </trans-unit>
        <trans-unit id="7572c0330f0713d1c5e756a7afc16d79cdfd440e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/tc39/proposal-regexp-dotall-flag&quot;&gt;regular expression &lt;code&gt;s&lt;/code&gt; (dotall) flag&lt;/a&gt; is supported by Node 9+.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tc39/proposal-regexp-dotall-flag&quot;&gt;정규 표현식 &lt;code&gt;s&lt;/code&gt; (DOTALL) 플래그는&lt;/a&gt; 노드 9+ 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c056ef78212ae02220f393b10157bf5612f52880" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;coffee&lt;/code&gt; and &lt;code&gt;cake&lt;/code&gt; commands will first look in the current folder to see if CoffeeScript is installed locally, and use that version if so. This allows different versions of CoffeeScript to be installed globally and locally.</source>
          <target state="translated">&lt;code&gt;coffee&lt;/code&gt; 와 &lt;code&gt;cake&lt;/code&gt; 명령은 첫 번째 커피 스크립트가 로컬로 설치되어 있는지, 그렇다면 그 버전을 사용하는 현재 폴더에서 찾을 것입니다. 이를 통해 다양한 버전의 CoffeeScript를 전 세계 및 로컬로 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba748e704aff73a187b5b4d11e627d8c846dc17c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compile&lt;/code&gt; method has the signature &lt;code&gt;compile(code, options)&lt;/code&gt; where &lt;code&gt;code&lt;/code&gt; is a string of CoffeeScript code, and the optional &lt;code&gt;options&lt;/code&gt; is an object with some or all of the following properties:</source>
          <target state="translated">&lt;code&gt;compile&lt;/code&gt; 방법은 서명이 &lt;code&gt;compile(code, options)&lt;/code&gt; &lt;code&gt;code&lt;/code&gt; 커피 스크립트 코드의 문자열을, 그리고 선택 &lt;code&gt;options&lt;/code&gt; 다음과 같은 속성의 일부 또는 전부를 가진 객체입니다</target>
        </trans-unit>
        <trans-unit id="655422e26379c46e7d5bcfbd8d6d8f7315e989f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;node&lt;/code&gt; executable has some useful options you can set, such as &lt;code&gt;--debug&lt;/code&gt;, &lt;code&gt;--debug-brk&lt;/code&gt;, &lt;code&gt;--max-stack-size&lt;/code&gt;, and &lt;code&gt;--expose-gc&lt;/code&gt;. Use this flag to forward options directly to Node.js. To pass multiple flags, use &lt;code&gt;--nodejs&lt;/code&gt; multiple times.</source>
          <target state="translated">&lt;code&gt;node&lt;/code&gt; 실행과 같은 사용자가 설정할 수있는 몇 가지 유용한 옵션이 &lt;code&gt;--debug&lt;/code&gt; , &lt;code&gt;--debug-brk&lt;/code&gt; , &lt;code&gt;--max-stack-size&lt;/code&gt; 및 &lt;code&gt;--expose-gc&lt;/code&gt; . 이 플래그를 사용하여 옵션을 Node.js로 직접 전달하십시오. 여러 플래그를 전달하려면 &lt;code&gt;--nodejs&lt;/code&gt; 를 여러 번 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d06fa582277c824a5eedd0cdf8c8c43e8fd4e37" translate="yes" xml:space="preserve">
          <source>The CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope &amp;mdash; you never need to write &lt;code&gt;var&lt;/code&gt; yourself.</source>
          <target state="translated">CoffeeScript 컴파일러는 모든 변수가 어휘 범위 내에서 올바르게 선언되도록주의를 기울 입니다. &lt;code&gt;var&lt;/code&gt; 를 직접 작성할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c6f6a454b2aadf8379fc2d7a711646b0c0889b8e" translate="yes" xml:space="preserve">
          <source>The CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional. Objects may be created using indentation instead of explicit braces, similar to &lt;a href=&quot;http://yaml.org&quot;&gt;YAML&lt;/a&gt;.</source>
          <target state="translated">객체와 배열의 CoffeeScript 리터럴은 JavaScript 사촌과 매우 유사합니다. 각 속성이 자체 줄에 나열되면 쉼표는 선택 사항입니다. &lt;a href=&quot;http://yaml.org&quot;&gt;YAML&lt;/a&gt; 과 유사한 명시 적 괄호 대신 들여 쓰기를 사용하여 객체를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="632671d8e925198953b170ddd065e3816277d5e2" translate="yes" xml:space="preserve">
          <source>The Existential Operator</source>
          <target state="translated">존재 연산자</target>
        </trans-unit>
        <trans-unit id="c299679511c002544394508b8a38855769b0948a" translate="yes" xml:space="preserve">
          <source>The JavaScript &lt;code&gt;arguments&lt;/code&gt; object is a useful way to work with functions that accept variable numbers of arguments. CoffeeScript provides splats &lt;code&gt;...&lt;/code&gt;, both for function definition as well as invocation, making variable numbers of arguments a little bit more palatable. ES2015 adopted this feature as their &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters&quot;&gt;rest parameters&lt;/a&gt;.</source>
          <target state="translated">JavaScript &lt;code&gt;arguments&lt;/code&gt; 객체는 가변 개수의 인수를 허용하는 함수로 작업하는 데 유용한 방법입니다. CoffeeScript는 함수 정의와 호출 모두에 대해 splats &lt;code&gt;...&lt;/code&gt; 을 제공 하여 가변 개수의 인수를 조금 더 맛있게 만듭니다. ES2015는이 기능을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters&quot;&gt;나머지 매개 변수&lt;/a&gt; 로 채택했습니다 .</target>
        </trans-unit>
        <trans-unit id="cde9be47142db0d427c3f2b4c90516cab84ab990" translate="yes" xml:space="preserve">
          <source>The above example also demonstrates that if properties are missing in the destructured object or array, you can, just like in JavaScript, provide defaults. Note though that unlike with the existential operator, the default is only applied with the value is missing or &lt;code&gt;undefined&lt;/code&gt;&amp;mdash;&lt;a href=&quot;#breaking-changes-default-values&quot;&gt;passing &lt;code&gt;null&lt;/code&gt; will set a value of &lt;code&gt;null&lt;/code&gt;&lt;/a&gt;, not the default.</source>
          <target state="translated">위의 예제는 또한 구조화되지 않은 객체 또는 배열에 속성이없는 경우 JavaScript와 마찬가지로 기본값을 제공 할 수 있음을 보여줍니다. 실존 연산자와 달리 기본 만 값이 없거나인가되어 있지만 주 &lt;code&gt;undefined&lt;/code&gt; - &lt;a href=&quot;#breaking-changes-default-values&quot;&gt;통과 &lt;code&gt;null&lt;/code&gt; 값으로 설정한다 &lt;code&gt;null&lt;/code&gt; &lt;/a&gt; 아닌 기본.</target>
        </trans-unit>
        <trans-unit id="e95f0f8970d570907faaeca191b0a67113a7c21d" translate="yes" xml:space="preserve">
          <source>The accessor variant of the existential operator &lt;code&gt;?.&lt;/code&gt; can be used to soak up null references in a chain of properties. Use it instead of the dot accessor &lt;code&gt;.&lt;/code&gt; in cases where the base value may be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. If all of the properties exist then you&amp;rsquo;ll get the expected result, if the chain is broken, &lt;code&gt;undefined&lt;/code&gt; is returned instead of the &lt;code&gt;TypeError&lt;/code&gt; that would be raised otherwise.</source>
          <target state="translated">실존 연산자 &lt;code&gt;?.&lt;/code&gt; 의 접근 자 변형 일련의 속성에서 null 참조를 흡수하는 데 사용할 수 있습니다. 도트 접근 자 대신 사용하십시오 &lt;code&gt;.&lt;/code&gt; 경우에 따라서는 기준 값이 될 수 여기서 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; . 모든 속성이 존재하면 예상 결과를 얻습니다. 체인이 끊어 지면 &lt;code&gt;TypeError&lt;/code&gt; 대신 &lt;code&gt;undefined&lt;/code&gt; 가 반환 되고 그렇지 않으면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="39b4b99d9e71ee2e70bef418e0e782a2d14d8671" translate="yes" xml:space="preserve">
          <source>The biggest change in CoffeeScript 2 is that now the CoffeeScript compiler produces modern JavaScript syntax (ES6, or ES2015 and later). A CoffeeScript &lt;code&gt;=&amp;gt;&lt;/code&gt; becomes a JS &lt;code&gt;=&amp;gt;&lt;/code&gt;, a CoffeeScript &lt;code&gt;class&lt;/code&gt; becomes a JS &lt;code&gt;class&lt;/code&gt; and so on. Major new features in CoffeeScript 2 include &lt;a href=&quot;#async-functions&quot;&gt;async functions&lt;/a&gt; and &lt;a href=&quot;#jsx&quot;&gt;JSX&lt;/a&gt;. You can read more in the &lt;a href=&quot;https://coffeescript.org/announcing-coffeescript-2/&quot;&gt;announcement&lt;/a&gt;.</source>
          <target state="translated">CoffeeScript 2의 가장 큰 변화는 이제 CoffeeScript 컴파일러가 최신 JavaScript 구문 (ES6 또는 ES2015 이상)을 생성한다는 것입니다. CoffeeScript &lt;code&gt;=&amp;gt;&lt;/code&gt; 는 JS &lt;code&gt;=&amp;gt;&lt;/code&gt; 가되고 CoffeeScript &lt;code&gt;class&lt;/code&gt; 는 JS &lt;code&gt;class&lt;/code&gt; 가됩니다. CoffeeScript 2의 새로운 주요 기능으로는 &lt;a href=&quot;#async-functions&quot;&gt;비동기 기능&lt;/a&gt; 과 &lt;a href=&quot;#jsx&quot;&gt;JSX가&lt;/a&gt; 있습니다. &lt;a href=&quot;https://coffeescript.org/announcing-coffeescript-2/&quot;&gt;공지 사항&lt;/a&gt; 에서 더 많은 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2497321a935f3118d62328f3ee12bcb5c1b7482" translate="yes" xml:space="preserve">
          <source>The command-line version of &lt;code&gt;coffee&lt;/code&gt; is available as a &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; utility, requiring Node 6 or later. The &lt;a href=&quot;https://coffeescript.org/v2/browser-compiler-modern/coffeescript.js&quot;&gt;core compiler&lt;/a&gt; however, does not depend on Node, and can be run in any JavaScript environment, or in the browser (see &lt;a href=&quot;#try&quot;&gt;Try CoffeeScript&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;coffee&lt;/code&gt; 의 명령 행 버전은 Node 6 이상이 필요한 &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; 유틸리티 로 사용 가능 합니다. 그러나 &lt;a href=&quot;https://coffeescript.org/v2/browser-compiler-modern/coffeescript.js&quot;&gt;핵심 컴파일러&lt;/a&gt; 는 노드에 의존하지 않으며 모든 JavaScript 환경 또는 브라우저에서 실행할 수 있습니다 ( &lt;a href=&quot;#try&quot;&gt;CrypScript 시도&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="31dc4964bd6db99efc6d651e6a7fe7980e835c06" translate="yes" xml:space="preserve">
          <source>The deprecated version will still work, but it will print a warning before running the script.</source>
          <target state="translated">더 이상 사용되지 않는 버전은 계속 작동하지만 스크립트를 실행하기 전에 경고를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="917837c752afebbd8afb9fd1d5377edebb699af5" translate="yes" xml:space="preserve">
          <source>The fat arrow &lt;code&gt;=&amp;gt;&lt;/code&gt; can be used to both define a function, and to bind it to the current value of &lt;code&gt;this&lt;/code&gt;, right on the spot. This is helpful when using callback-based libraries like Prototype or jQuery, for creating iterator functions to pass to &lt;code&gt;each&lt;/code&gt;, or event-handler functions to use with &lt;code&gt;on&lt;/code&gt;. Functions created with the fat arrow are able to access properties of the &lt;code&gt;this&lt;/code&gt; where they&amp;rsquo;re defined.</source>
          <target state="translated">굵은 화살표 &lt;code&gt;=&amp;gt;&lt;/code&gt; 은 모두 함수를 정의하고, 현재 값을 결합하는 데 사용될 수있다 &lt;code&gt;this&lt;/code&gt; 오른쪽 자리에서. 이는 Prototype 또는 jQuery와 같은 콜백 기반 라이브러리를 사용하여 &lt;code&gt;each&lt;/code&gt; 에 전달할 반복자 함수 또는 &lt;code&gt;on&lt;/code&gt; 에 사용할 이벤트 핸들러 함수를 작성할 때 유용 합니다 . 지방 화살표로 만든 기능의 속성에 액세스 할 수있는 &lt;code&gt;this&lt;/code&gt; 그들이 정의하는 곳.</target>
        </trans-unit>
        <trans-unit id="29b0a191e077542f4d37bce4ac1081f2f9f11272" translate="yes" xml:space="preserve">
          <source>The fat arrow was one of the most popular features of CoffeeScript, and ES2015 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;adopted it&lt;/a&gt;; so CoffeeScript 2 compiles &lt;code&gt;=&amp;gt;&lt;/code&gt; to ES &lt;code&gt;=&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">팻 화살표는 CoffeeScript의 가장 인기있는 기능 중 하나였으며 ES2015 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;는이를 채택했습니다&lt;/a&gt; . 따라서 CoffeeScript 2는 &lt;code&gt;=&amp;gt;&lt;/code&gt; 를 ES &lt;code&gt;=&amp;gt;&lt;/code&gt; 로 컴파일합니다 .</target>
        </trans-unit>
        <trans-unit id="881be262b3282151a82d808d99bc918261a00f29" translate="yes" xml:space="preserve">
          <source>The golden rule of CoffeeScript is: &lt;em&gt;&amp;ldquo;It&amp;rsquo;s just JavaScript.&amp;rdquo;&lt;/em&gt; The code compiles one-to-one into the equivalent JS, and there is no interpretation at runtime. You can use any existing JavaScript library seamlessly from CoffeeScript (and vice-versa). The compiled output is readable, pretty-printed, and tends to run as fast or faster than the equivalent handwritten JavaScript.</source>
          <target state="translated">CoffeeScript의 기본 규칙은 &lt;em&gt;&quot;단지 JavaScript&quot;입니다. &lt;/em&gt;이 코드는 일대일로 동등한 JS로 컴파일되며 런타임에는 해석이 없습니다. CoffeeScript에서 기존 JavaScript 라이브러리를 완벽하게 사용할 수 있으며 그 반대도 가능합니다. 컴파일 된 출력은 읽기 쉽고 인쇄가 가능하며 필기 자바 스크립트보다 빠르거나 빠르게 실행되는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="57f6f3bb66cdefe66d61e33b194bae86dc442bf7" translate="yes" xml:space="preserve">
          <source>The only low-level loop that CoffeeScript provides is the &lt;code&gt;while&lt;/code&gt; loop. The main difference from JavaScript is that the &lt;code&gt;while&lt;/code&gt; loop can be used as an expression, returning an array containing the result of each iteration through the loop.</source>
          <target state="translated">CoffeeScript가 제공하는 유일한 저수준 루프는 &lt;code&gt;while&lt;/code&gt; 루프입니다. JavaScript와의 주요 차이점은 &lt;code&gt;while&lt;/code&gt; 루프를 표현식으로 사용하여 루프를 통한 각 반복 결과를 포함하는 배열을 반환 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dd6c377bf16ffa88eb3fd655b8bf77b2715b54a5" translate="yes" xml:space="preserve">
          <source>The same syntax can be used with assignment to replace a segment of an array with new values, splicing it.</source>
          <target state="translated">배열과 동일한 구문을 사용하여 배열의 세그먼트를 새 값으로 바꾸어 접합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d00bce92adf2e76e903d27d857e2684b1a2fb26a" translate="yes" xml:space="preserve">
          <source>The usual caveats about CoffeeScript apply &amp;mdash; your inline scripts will run within a closure wrapper, so if you want to expose global variables or functions, attach them to the &lt;code&gt;window&lt;/code&gt; object.</source>
          <target state="translated">CoffeeScript에 대한 일반적인주의 사항이 적용됩니다. 인라인 스크립트는 클로저 래퍼 내에서 실행되므로 전역 변수 나 함수를 노출하려면이를 &lt;code&gt;window&lt;/code&gt; 개체에 연결하십시오 .</target>
        </trans-unit>
        <trans-unit id="0407053f9f37c54f4e22762737710b115655c046" translate="yes" xml:space="preserve">
          <source>There are a few ECMAScript features that CoffeeScript intentionally doesn&amp;rsquo;t support.</source>
          <target state="translated">CoffeeScript가 의도적으로 지원하지 않는 몇 가지 ECMAScript 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd46d0c19fd2206d2a20dcf63dd1ac447d8ef9a0" translate="yes" xml:space="preserve">
          <source>There are a handful of statements in JavaScript that can&amp;rsquo;t be meaningfully converted into expressions, namely &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;, and &lt;code&gt;return&lt;/code&gt;. If you make use of them within a block of code, CoffeeScript won&amp;rsquo;t try to perform the conversion.</source>
          <target state="translated">JavaScript에는 의미있는 표현식 (예 : &lt;code&gt;break&lt;/code&gt; , &lt;code&gt;continue&lt;/code&gt; 및 &lt;code&gt;return&lt;/code&gt; ) 으로 변환 할 수없는 소수의 명령문이 있습니다 . 코드 블록 내에서 코드를 사용하면 CoffeeScript는 변환을 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ead996d7aeda765800718ece4a37b9a3d073db9" translate="yes" xml:space="preserve">
          <source>There are very few &lt;a href=&quot;#breaking-changes&quot;&gt;breaking changes from CoffeeScript 1.x to 2&lt;/a&gt;; we hope the upgrade process is smooth for most projects.</source>
          <target state="translated">&lt;a href=&quot;#breaking-changes&quot;&gt;CoffeeScript 1.x에서 2 로의 주요 변경 사항&lt;/a&gt; 은 거의 없습니다 . 대부분의 프로젝트에서 업그레이드 프로세스가 원활 해지기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="7625eae784aaf6c02294c43cdfe6aba3b3340de1" translate="yes" xml:space="preserve">
          <source>Things that would otherwise be statements in JavaScript, when used as part of an expression in CoffeeScript, are converted into expressions by wrapping them in a closure. This lets you do useful things, like assign the result of a comprehension to a variable:</source>
          <target state="translated">CoffeeScript에서 표현식의 일부로 사용될 때 JavaScript의 명령문 인 경우는 클로저로 묶어 표현식으로 변환됩니다. 이렇게하면 이해 결과를 변수에 할당하는 등 유용한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b17290b6006c13901c34d75f37b8174f2cf35d0" translate="yes" xml:space="preserve">
          <source>This also means you cannot pass a reference to &lt;code&gt;this&lt;/code&gt; as an argument to &lt;code&gt;super&lt;/code&gt; in the constructor of a derived class:</source>
          <target state="translated">이것은 또한 파생 클래스의 생성자에서 &lt;code&gt;super&lt;/code&gt; 에 대한 인수로 &lt;code&gt;this&lt;/code&gt; 대한 참조를 전달할 수 없음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="212e8a3822b15e29b023624fc8e0a3036b265be8" translate="yes" xml:space="preserve">
          <source>This is a limitation of ES2015 classes. As a workaround, assign to &lt;code&gt;this&lt;/code&gt; after the &lt;code&gt;super&lt;/code&gt; call:</source>
          <target state="translated">이것은 ES2015 클래스의 제한 사항입니다. 이 문제를 해결 하려면 &lt;code&gt;super&lt;/code&gt; 콜 후에 &lt;code&gt;this&lt;/code&gt; 지정 하십시오.</target>
        </trans-unit>
        <trans-unit id="ebe0a630e1017ea59b90b6804799a28e26c85ded" translate="yes" xml:space="preserve">
          <source>This is to avoid grammatical ambiguity, since in CoffeeScript such a construct looks identical to a function call (e.g. &lt;code&gt;get(function foo() {})&lt;/code&gt;); and because there is an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt;alternate syntax&lt;/a&gt; that is slightly more verbose but just as effective:</source>
          <target state="translated">CoffeeScript에서 이러한 구성은 함수 호출과 동일하게 보이기 때문에 문법적으로 모호성을 피하기위한 것입니다 (예 : &lt;code&gt;get(function foo() {})&lt;/code&gt; ); 약간 더 장황하지만 효과적인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty&quot;&gt;대체 구문&lt;/a&gt; 이 있기 때문에 :</target>
        </trans-unit>
        <trans-unit id="e35a04b81c2c241c9e49ed37e23da66a8ec2f106" translate="yes" xml:space="preserve">
          <source>This list may be incomplete, and excludes versions of Node that support newer features behind flags; please refer to &lt;a href=&quot;http://node.green/&quot;&gt;node.green&lt;/a&gt; for full details. You can &lt;a href=&quot;https://coffeescript.org/test.html&quot;&gt;run the tests in your browser&lt;/a&gt; to see what your browser supports. It is your responsibility to ensure that your runtime supports the modern features you use; or that you &lt;a href=&quot;#transpilation&quot;&gt;transpile&lt;/a&gt; your code. When in doubt, transpile.</source>
          <target state="translated">이 목록은 불완전 할 수 있으며 플래그 뒤의 새로운 기능을 지원하는 노드 버전은 제외합니다. 자세한 내용은 &lt;a href=&quot;http://node.green/&quot;&gt;node.green&lt;/a&gt; 을 참조 하십시오. 당신은 할 수 있습니다 &lt;a href=&quot;https://coffeescript.org/test.html&quot;&gt;브라우저에서 테스트를 실행&lt;/a&gt; 어떤 브라우저 지원을 참조하십시오. 런타임이 사용하는 최신 기능을 지원하도록하는 것은 귀하의 책임입니다. 또는 코드 를 &lt;a href=&quot;#transpilation&quot;&gt;번역했습니다&lt;/a&gt; . 의심 스러우면 번역하십시오.</target>
        </trans-unit>
        <trans-unit id="df2efdc78bbbd411a239e3ac6067de5bfdc8c098" translate="yes" xml:space="preserve">
          <source>This will make the &lt;code&gt;coffee&lt;/code&gt; and &lt;code&gt;cake&lt;/code&gt; commands available globally.</source>
          <target state="translated">이렇게하면 &lt;code&gt;coffee&lt;/code&gt; 및 &lt;code&gt;cake&lt;/code&gt; 명령을 전 세계적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60e4dcb12e7b736abe3c6d872654f5052718c59b" translate="yes" xml:space="preserve">
          <source>To install, first make sure you have a working copy of the latest stable version of &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt;. You can then install CoffeeScript globally with &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;:</source>
          <target state="translated">설치하려면 먼저 최신 안정 버전의 &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; 의 작업 사본이 있는지 확인하십시오 . 그런 다음 &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; 을 사용하여 CoffeeScript를 전역 적으로 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d491acd5ee23c8cde5200452bec031026aa7e84" translate="yes" xml:space="preserve">
          <source>To iterate a generator function, use &lt;code&gt;from&lt;/code&gt;. See &lt;a href=&quot;#generator-iteration&quot;&gt;Generator Functions&lt;/a&gt;.</source>
          <target state="translated">생성기 함수를 반복하려면 &lt;code&gt;from&lt;/code&gt; 을 사용하십시오 . &lt;a href=&quot;#generator-iteration&quot;&gt;생성기 기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4879760675e96a4c59a258d8b135d6981fed61f9" translate="yes" xml:space="preserve">
          <source>To make things easy, CoffeeScript has built-in support for the popular &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; transpiler. You can use it via the &lt;code&gt;--transpile&lt;/code&gt; command-line option or the &lt;code&gt;transpile&lt;/code&gt; Node API option. To use either, &lt;code&gt;@babel/core&lt;/code&gt; must be installed in your project:</source>
          <target state="translated">쉬운 작업을 위해 CoffeeScript는 널리 사용되는 &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; 변환기 를 지원합니다 . &lt;code&gt;--transpile&lt;/code&gt; 명령 행 옵션 또는 &lt;code&gt;transpile&lt;/code&gt; Node API 옵션을 통해 사용할 수 있습니다 . 둘 중 하나를 사용하려면 프로젝트에 &lt;code&gt;@babel/core&lt;/code&gt; 가 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="32b8a5b68368acbc341573ad1e61a0edd20250e7" translate="yes" xml:space="preserve">
          <source>To simplify math expressions, &lt;code&gt;**&lt;/code&gt; can be used for exponentiation and &lt;code&gt;//&lt;/code&gt; performs floor division. &lt;code&gt;%&lt;/code&gt; works just like in JavaScript, while &lt;code&gt;%%&lt;/code&gt; provides &lt;a href=&quot;https://en.wikipedia.org/wiki/Modulo_operation&quot;&gt;&amp;ldquo;dividend dependent modulo&amp;rdquo;&lt;/a&gt;:</source>
          <target state="translated">수학 표현식을 단순화하기 위해 &lt;code&gt;**&lt;/code&gt; 를 지수화에 사용하고 &lt;code&gt;//&lt;/code&gt; 바닥 나누기를 수행 할 수 있습니다 . &lt;code&gt;%&lt;/code&gt; 는 JavaScript 에서처럼 작동하지만 &lt;code&gt;%%&lt;/code&gt; 는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Modulo_operation&quot;&gt;&quot;배당 종속 모듈로&quot;를&lt;/a&gt; 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="760008ba15d1db1590d7becaabcd77417431770e" translate="yes" xml:space="preserve">
          <source>To step through a range comprehension in fixed-size chunks, use &lt;code&gt;by&lt;/code&gt;, for example: &lt;code&gt;evens = (x for x in [0..10] by 2)&lt;/code&gt;</source>
          <target state="translated">고정 크기의 청크 사용 범위의 이해를 단계별로 &lt;code&gt;by&lt;/code&gt; , 예를 들어 &lt;code&gt;evens = (x for x in [0..10] by 2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ae484c4ea234c74c821257172381d6f5a5706c0" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;--transpile&lt;/code&gt;, see &lt;a href=&quot;#transpilation&quot;&gt;Transpilation&lt;/a&gt;.</source>
          <target state="translated">사용하려면 &lt;code&gt;--transpile&lt;/code&gt; 참조 &lt;a href=&quot;#transpilation&quot;&gt;Transpilation을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="134608c329dd197fae36575214763a11330c0d6a" translate="yes" xml:space="preserve">
          <source>Transpilation</source>
          <target state="translated">Transpilation</target>
        </trans-unit>
        <trans-unit id="441544b175e1ff168280f364e13483ad37fdc025" translate="yes" xml:space="preserve">
          <source>Transpiling with the CoffeeScript compiler</source>
          <target state="translated">CoffeeScript 컴파일러로 트랜스 파일링</target>
        </trans-unit>
        <trans-unit id="2996879f5c4aef02081b95d839c49eeb3e309880" translate="yes" xml:space="preserve">
          <source>Try/Catch/Finally</source>
          <target state="translated">Try/Catch/Finally</target>
        </trans-unit>
        <trans-unit id="22d158ab75d63715d420bc5e58daab5d8357398c" translate="yes" xml:space="preserve">
          <source>Type Annotations</source>
          <target state="translated">타입 주석</target>
        </trans-unit>
        <trans-unit id="01692a80e99068bf423c4ff03463fa9389fe6247" translate="yes" xml:space="preserve">
          <source>Unsupported ECMAScript Features</source>
          <target state="translated">지원되지 않는 ECMAScript 기능</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="ec90f891d39b4bc9b7913655e4904c205deb12d7" translate="yes" xml:space="preserve">
          <source>Watch a file for changes, and recompile it every time the file is saved:</source>
          <target state="translated">파일이 변경되었는지 확인하고 파일을 저장할 때마다 다시 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="a208b4d5c38d76b0c844e7782318c919be835059" translate="yes" xml:space="preserve">
          <source>Watch files for changes, rerunning the specified command when any file is updated.</source>
          <target state="translated">파일이 업데이트 될 때 지정된 명령을 다시 실행하여 변경 사항을 감시하십시오.</target>
        </trans-unit>
        <trans-unit id="6f5de3a310cd5e9cdc833ca57fe2aff4bc3ad811" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s New In CoffeeScript 2?</source>
          <target state="translated">CoffeeScript 2의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="f83e4a5d898f47de1ab2a712714b5389d4018960" translate="yes" xml:space="preserve">
          <source>When CoffeeScript was designed, &lt;code&gt;var&lt;/code&gt; was &lt;a href=&quot;https://github.com/jashkenas/coffeescript/issues/238#issuecomment-153502&quot;&gt;intentionally omitted&lt;/a&gt;. This was to spare developers the mental housekeeping of needing to worry about variable &lt;em&gt;declaration&lt;/em&gt; (&lt;code&gt;var foo&lt;/code&gt;) as opposed to variable &lt;em&gt;assignment&lt;/em&gt; (&lt;code&gt;foo = 1&lt;/code&gt;). The CoffeeScript compiler automatically takes care of declaration for you, by generating &lt;code&gt;var&lt;/code&gt; statements at the top of every function scope. This makes it impossible to accidentally declare a global variable.</source>
          <target state="translated">CoffeeScript가 디자인되었을 때 &lt;code&gt;var&lt;/code&gt; 는 &lt;a href=&quot;https://github.com/jashkenas/coffeescript/issues/238#issuecomment-153502&quot;&gt;의도적으로 생략되었습니다&lt;/a&gt; . 이는 개발자 에게 변수 &lt;em&gt;할당&lt;/em&gt; ( &lt;code&gt;foo = 1&lt;/code&gt; ) 과 달리 변수 &lt;em&gt;선언&lt;/em&gt; ( &lt;code&gt;var foo&lt;/code&gt; ) 에 대해 걱정할 필요가없는 정신적 인 관리를 제공하기위한 것 입니다. CoffeeScript 컴파일러 는 모든 함수 범위의 최상위에 &lt;code&gt;var&lt;/code&gt; 문을 생성하여 자동으로 선언을 처리합니다 . 이로 인해 실수로 전역 변수를 선언 할 수 없습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5d84cf7d7535701ca31c3e2199811dcec3bed09b" translate="yes" xml:space="preserve">
          <source>When using a JavaScript loop to generate functions, it&amp;rsquo;s common to insert a closure wrapper in order to ensure that loop variables are closed over, and all the generated functions don&amp;rsquo;t just share the final values. CoffeeScript provides the &lt;code&gt;do&lt;/code&gt; keyword, which immediately invokes a passed function, forwarding any arguments.</source>
          <target state="translated">JavaScript 루프를 사용하여 함수를 생성 할 때 루프 변수가 닫히고 생성 된 모든 함수가 최종 값을 공유하지 않도록하기 위해 클로저 래퍼를 삽입하는 것이 일반적입니다. CoffeeScript는 전달 된 함수를 즉시 호출하여 인수를 전달 하는 &lt;code&gt;do&lt;/code&gt; 키워드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="ce527aeb1c14343036af5875ab0bc15b7dedfc43" translate="yes" xml:space="preserve">
          <source>While it&amp;rsquo;s not recommended for serious use, CoffeeScripts may be included directly within the browser using &lt;code&gt;&amp;lt;script type=&quot;text/coffeescript&quot;&amp;gt;&lt;/code&gt; tags. The source includes a compressed and minified version of the compiler (&lt;a href=&quot;https://coffeescript.org/v2/browser-compiler-legacy/coffeescript.js&quot;&gt;Download current version here, 77k when gzipped&lt;/a&gt;) as &lt;code&gt;docs/v2/browser-compiler-legacy/coffeescript.js&lt;/code&gt;. Include this file on a page with inline CoffeeScript tags, and it will compile and evaluate them in order.</source>
          <target state="translated">심각하게 사용하는 것은 좋지 않지만 &lt;code&gt;&amp;lt;script type=&quot;text/coffeescript&quot;&amp;gt;&lt;/code&gt; 태그를 사용하여 CoffeeScripts가 브라우저에 직접 포함될 수 있습니다 . 소스에는 &lt;code&gt;docs/v2/browser-compiler-legacy/coffeescript.js&lt;/code&gt; 로 압축 및 축소 된 버전의 컴파일러 ( &lt;a href=&quot;https://coffeescript.org/v2/browser-compiler-legacy/coffeescript.js&quot;&gt;현재 버전 다운로드, 압축시 77k&lt;/a&gt; )가 포함되어 있습니다. 이 파일을 인라인 CoffeeScript 태그가있는 페이지에 포함하면 순서대로 컴파일 및 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="7d27f693c7d9cd75cdbdffcd127b5355d5fa8843" translate="yes" xml:space="preserve">
          <source>With the addition of &lt;a href=&quot;#jsx&quot;&gt;JSX&lt;/a&gt;, the &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; characters serve as both the &amp;ldquo;less than&amp;rdquo; and &amp;ldquo;greater than&amp;rdquo; operators and as the delimiters for XML tags, like &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;. For best results, in general you should always wrap the operators in spaces to distinguish them from XML tags: &lt;code&gt;i &amp;lt; len&lt;/code&gt;, not &lt;code&gt;i&amp;lt;len&lt;/code&gt;. The compiler tries to be forgiving when it can be sure what you intend, but always putting spaces around the &amp;ldquo;less than&amp;rdquo; and &amp;ldquo;greater than&amp;rdquo; operators will remove ambiguity.</source>
          <target state="translated">&lt;a href=&quot;#jsx&quot;&gt;JSX를&lt;/a&gt; 추가 하면 &lt;code&gt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; 문자는 &quot;보다 작음&quot;및 &quot;보다 큼&quot;연산자 및 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 와 같은 XML 태그의 구분자로 사용 됩니다. 최상의 결과를 얻으려면 일반적으로 연산자를 공백으로 묶어 XML 태그와 구별해야합니다. &lt;code&gt;i &amp;lt; len&lt;/code&gt; 이 아니라 &lt;code&gt;i&amp;lt;len&lt;/code&gt; 입니다. 컴파일러는 의도 한 것을 확신 할 수 있으면 용서하려고하지만 항상 &quot;보다 작음&quot;및 &quot;보다 큼&quot;연산자 주위에 공백을두면 모호성이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="91b3860286d34d188fac6fd2475f0b7c570b45ae" translate="yes" xml:space="preserve">
          <source>Write out all compiled JavaScript files into the specified directory. Use in conjunction with &lt;code&gt;--compile&lt;/code&gt; or &lt;code&gt;--watch&lt;/code&gt;.</source>
          <target state="translated">컴파일 된 모든 JavaScript 파일을 지정된 디렉토리에 작성하십시오. &lt;code&gt;--compile&lt;/code&gt; 또는 &lt;code&gt;--watch&lt;/code&gt; 와 함께 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7fa8e041a9d1bd281a4b489df18b79561d4193cb" translate="yes" xml:space="preserve">
          <source>You can also embed blocks of JavaScript using triple backticks. That&amp;rsquo;s easier than escaping backticks, if you need them inside your JavaScript block.</source>
          <target state="translated">트리플 백틱을 사용하여 JavaScript 블록을 포함 할 수도 있습니다. JavaScript 블록 내에서 필요한 경우 백틱을 이스케이프 처리하는 것보다 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="895151cddefabe084525e0448e8f3c00c754930a" translate="yes" xml:space="preserve">
          <source>You can also transpile CoffeeScript&amp;rsquo;s output without using the &lt;code&gt;transpile&lt;/code&gt; option, for example as part of a build chain. This lets you use transpilers other than Babel, and it gives you greater control over the process. There are many great task runners for setting up JavaScript build chains, such as &lt;a href=&quot;http://gulpjs.com/&quot;&gt;Gulp&lt;/a&gt;, &lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt;, &lt;a href=&quot;https://gruntjs.com/&quot;&gt;Grunt&lt;/a&gt; and &lt;a href=&quot;http://broccolijs.com/&quot;&gt;Broccoli&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;transpile&lt;/code&gt; 옵션 을 사용하지 않고 ( 예 : 빌드 체인의 일부로) CoffeeScript 출력을 변환 할 수도 있습니다 . 이를 통해 Babel 이외의 변환기를 사용할 수 있으며 프로세스를보다 강력하게 제어 할 수 있습니다. &lt;a href=&quot;http://gulpjs.com/&quot;&gt;Gulp&lt;/a&gt; , &lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt; , &lt;a href=&quot;https://gruntjs.com/&quot;&gt;Grunt&lt;/a&gt; 및 &lt;a href=&quot;http://broccolijs.com/&quot;&gt;Broccoli&lt;/a&gt; 와 같은 JavaScript 빌드 체인을 설정하기위한 많은 훌륭한 작업 수행자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea09dd580c1117ec826c105827011d4991d422fb" translate="yes" xml:space="preserve">
          <source>You can iterate over a generator function using &lt;code&gt;for&amp;hellip;from&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;for&amp;hellip;from&lt;/code&gt; 사용하여 생성기 함수를 반복 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="627a15b97853de570b928cbe1078ef7b23d9800d" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;in&lt;/code&gt; to test for array presence, and &lt;code&gt;of&lt;/code&gt; to test for JavaScript object-key presence.</source>
          <target state="translated">당신이 사용할 수 &lt;code&gt;in&lt;/code&gt; 배열의 존재에 대한 테스트 및 &lt;code&gt;of&lt;/code&gt; 자바 스크립트 객체 키 존재 여부를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="f5d72942f9c85a2499d5ad0b4ecca991c6daa18a" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;not&lt;/code&gt; as an alias for &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">별명으로 사용할 수 &lt;code&gt;not&lt;/code&gt; &lt;code&gt;!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cc987de3ea0a3222086b75436a669c943d85b76" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to use parentheses to invoke a function if you&amp;rsquo;re passing arguments. The implicit call wraps forward to the end of the line or block expression.</source>
          <target state="translated">인수를 전달하는 경우 함수를 호출하기 위해 괄호를 사용할 필요가 없습니다. 암시 적 호출은 행 또는 블록 표현식의 끝으로 랩핑됩니다.</target>
        </trans-unit>
        <trans-unit id="b83957bfb0e2f86c484bdb23a3ecc8d6b4ba1ba9" translate="yes" xml:space="preserve">
          <source>You might have noticed how even though we don&amp;rsquo;t add return statements to CoffeeScript functions, they nonetheless return their final value. The CoffeeScript compiler tries to make sure that all statements in the language can be used as expressions. Watch how the &lt;code&gt;return&lt;/code&gt; gets pushed down into each possible branch of execution in the function below.</source>
          <target state="translated">CoffeeScript 함수에 return 문을 추가하지 않더라도 최종 값을 반환하는 방법을 알 수 있습니다. CoffeeScript 컴파일러는 언어의 모든 문장을 표현식으로 사용할 수 있도록 노력합니다. 아래 함수에서 &lt;code&gt;return&lt;/code&gt; 이 실행 가능한 각 분기로 어떻게 내려가는 지 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="94695e0be1a132fc3c8773528fdeaed22b0e2166" translate="yes" xml:space="preserve">
          <source>assigns the value of &lt;code&gt;b&lt;/code&gt; to &lt;code&gt;a&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is not in scope or if &lt;code&gt;a == null&lt;/code&gt;; produces the new value of &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">양수인의 값 &lt;code&gt;b&lt;/code&gt; 에 경우 &lt;code&gt;a&lt;/code&gt; 범위 경우 또는없는 &lt;code&gt;a == null&lt;/code&gt; ; 의 새로운 가치 생산 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30118aa1aa8a06fa5365743b3a5db69fc62b9760" translate="yes" xml:space="preserve">
          <source>await</source>
          <target state="translated">await</target>
        </trans-unit>
        <trans-unit id="7a6e8d704c7decefa5e5d4fa00c771cd1a13ce51" translate="yes" xml:space="preserve">
          <source>coffee command</source>
          <target state="translated">커피 명령</target>
        </trans-unit>
        <trans-unit id="bcf9c16f425ba1f8ea1288d2892a8012be3730df" translate="yes" xml:space="preserve">
          <source>for...from</source>
          <target state="translated">for...from</target>
        </trans-unit>
        <trans-unit id="af10ef20dd9060bbeead0afbc55381a66af442ef" translate="yes" xml:space="preserve">
          <source>in</source>
          <target state="translated">in</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">is</target>
        </trans-unit>
        <trans-unit id="d5a3e9a0d2ce4a1cae8033c54a253510da7f756a" translate="yes" xml:space="preserve">
          <source>isnt</source>
          <target state="translated">isnt</target>
        </trans-unit>
        <trans-unit id="557f255516719ea16f8f4a0aae1166054e2c9b43" translate="yes" xml:space="preserve">
          <source>not</source>
          <target state="translated">not</target>
        </trans-unit>
        <trans-unit id="de04fa0e29f9b35e24905d2e512bedc9bb6e09e4" translate="yes" xml:space="preserve">
          <source>of</source>
          <target state="translated">of</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="1f1590943b001194a7e6d7ed8992d476ad4e8a6a" translate="yes" xml:space="preserve">
          <source>returns &lt;code&gt;a.b&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is in scope and &lt;code&gt;a != null&lt;/code&gt;; otherwise, &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 범위 내에 있고 &lt;code&gt;a != null&lt;/code&gt; 경우 &lt;code&gt;a.b&lt;/code&gt; 반환합니다 . 그렇지 않으면 &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf26d3117231e5075d4fd6c1bf28375ff8a7a8d2" translate="yes" xml:space="preserve">
          <source>returns &lt;code&gt;a&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is in scope and &lt;code&gt;a != null&lt;/code&gt;; otherwise, &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 범위 내에 있고 &lt;code&gt;a != null&lt;/code&gt; 경우 a를 반환 &lt;code&gt;a&lt;/code&gt; . 그렇지 않으면 &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="effdab22f101bb837e277a0db2e80288c615f7e6" translate="yes" xml:space="preserve">
          <source>returns the result of calling &lt;code&gt;a&lt;/code&gt; (with arguments &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;) if &lt;code&gt;a&lt;/code&gt; is in scope and callable; otherwise, &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 범위 내에 있고 호출 가능한 경우 &lt;code&gt;b&lt;/code&gt; (인수 b 및 &lt;code&gt;c&lt;/code&gt; ) 를 호출 &lt;code&gt;a&lt;/code&gt; 결과를 리턴합니다 . 그렇지 않으면 &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8451ba8a14d79753d34cb33b51ba46b4b025eb81" translate="yes" xml:space="preserve">
          <source>super</source>
          <target state="translated">super</target>
        </trans-unit>
        <trans-unit id="e7c2a4c990184f8b6e86a548b889c307e41a3860" translate="yes" xml:space="preserve">
          <source>switch...when...else</source>
          <target state="translated">switch...when...else</target>
        </trans-unit>
        <trans-unit id="46aa5a11884223ec3dcfa5773b33d0a26fc9d06c" translate="yes" xml:space="preserve">
          <source>tests that &lt;code&gt;a&lt;/code&gt; is in scope and &lt;code&gt;a != null&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 범위 내에 있고 &lt;code&gt;a != null&lt;/code&gt; 인지 테스트</target>
        </trans-unit>
        <trans-unit id="f52d36be262c616a8c25a3ba007e4c58c101d1eb" translate="yes" xml:space="preserve">
          <source>try...catch...finally</source>
          <target state="translated">try...catch...finally</target>
        </trans-unit>
        <trans-unit id="42e184930956d048c819e40f18f94f0094d47bc6" translate="yes" xml:space="preserve">
          <source>unless</source>
          <target state="translated">unless</target>
        </trans-unit>
        <trans-unit id="6517f89c46c3f0d6db9cb009b8c7d1f98c371fa0" translate="yes" xml:space="preserve">
          <source>while</source>
          <target state="translated">while</target>
        </trans-unit>
        <trans-unit id="f12e1e8f455f823f59cc0134f1795184b98fe5ac" translate="yes" xml:space="preserve">
          <source>yield</source>
          <target state="translated">yield</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
