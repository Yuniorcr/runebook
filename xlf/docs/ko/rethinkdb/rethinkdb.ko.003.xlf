<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rethinkdb">
    <body>
      <group id="rethinkdb">
        <trans-unit id="a46bc328f467283ecd22518500c2976a70cc4b79" translate="yes" xml:space="preserve">
          <source>How does the atomicity model work?</source>
          <target state="translated">원 자성 모델은 어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="af951d8e3819cb840390880fdb37b87df5a0958e" translate="yes" xml:space="preserve">
          <source>How is cluster configuration propagated?</source>
          <target state="translated">클러스터 구성은 어떻게 전파됩니까?</target>
        </trans-unit>
        <trans-unit id="4c81c881ea45d72abebac10fe2d8328a713ebfad" translate="yes" xml:space="preserve">
          <source>How is data stored on disk?</source>
          <target state="translated">디스크에 데이터가 어떻게 저장됩니까?</target>
        </trans-unit>
        <trans-unit id="3f5542bbcb5f2574afad2e3107d6f83ea128ae54" translate="yes" xml:space="preserve">
          <source>How much memory it has</source>
          <target state="translated">메모리 용량</target>
        </trans-unit>
        <trans-unit id="a5666083879cda19541342c834b60e45280910b9" translate="yes" xml:space="preserve">
          <source>How the library is implemented</source>
          <target state="translated">라이브러리 구현 방법</target>
        </trans-unit>
        <trans-unit id="cb65cc4955150500049d751964b89925511c01ba" translate="yes" xml:space="preserve">
          <source>How to submit a bug report</source>
          <target state="translated">버그 보고서를 제출하는 방법</target>
        </trans-unit>
        <trans-unit id="bdb93ab2ccf5f87fe1eb8544b5133c4fc441ae7f" translate="yes" xml:space="preserve">
          <source>How well does RethinkDB scale?</source>
          <target state="translated">RethinkDB는 얼마나 잘 확장됩니까?</target>
        </trans-unit>
        <trans-unit id="80369d7456c92b2363b49ca4f9bd24c13fd34679" translate="yes" xml:space="preserve">
          <source>However, RethinkDB does come with some restrictions regarding which operations can be performed atomically. Operations that cannot be proven deterministic cannot update the document in an atomic way. Currently, values obtained by executing JavaScript code, random values, and values obtained as a result of a subquery (e.g. incrementing the value of an attribute by the value of an attribute in a different document) cannot be performed atomically. If an update or replace query cannot be executed atomically, by default RethinkDB will throw an error. The user can choose to set the flag on the update operation in the client driver to execute the query in a non-atomic way. Note that non-atomic operations can only be detected when they involve functions (including &lt;code&gt;row()&lt;/code&gt;) being passed to &lt;code&gt;update&lt;/code&gt; or &lt;code&gt;replace&lt;/code&gt;; a non-atomic &lt;code&gt;insert&lt;/code&gt; operation will not throw an error.</source>
          <target state="translated">그러나 RethinkDB에는 어떤 작업을 원자 적으로 수행 할 수 있는지에 대한 몇 가지 제한이 있습니다. 결정적인 것으로 입증 될 수없는 작업은 원자적인 방식으로 문서를 업데이트 할 수 없습니다. 현재 JavaScript 코드를 실행하여 얻은 값, 임의의 값 및 하위 쿼리의 결과로 얻은 값 (예 : 다른 문서의 속성 값으로 속성 값을 증가)은 원자 적으로 수행 할 수 없습니다. 업데이트 또는 바꾸기 쿼리를 원자 적으로 실행할 수없는 경우 기본적으로 RethinkDB는 오류를 발생시킵니다. 사용자는 비원 자적 방식으로 쿼리를 실행하기 위해 클라이언트 드라이버에서 업데이트 작업에 플래그를 설정하도록 선택할 수 있습니다. 원자가 아닌 작업은 &lt;code&gt;update&lt;/code&gt; 위해 전달되는 함수 ( &lt;code&gt;row()&lt;/code&gt; )가 포함 된 경우에만 감지 할 수 있습니다.또는 &lt;code&gt;replace&lt;/code&gt; ; 비 원자 &lt;code&gt;insert&lt;/code&gt; 작업에서는 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3faa40890508b3aedb1fa775f4e3c1c7b7c50083" translate="yes" xml:space="preserve">
          <source>However, an &lt;a href=&quot;../../api/javascript/order_by/index&quot;&gt;orderBy&lt;/a&gt; query will be executed differently.</source>
          <target state="translated">그러나 &lt;a href=&quot;../../api/javascript/order_by/index&quot;&gt;orderBy&lt;/a&gt; 조회는 다르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="40db98da898bb7295f138bdfd36eef49c309e873" translate="yes" xml:space="preserve">
          <source>However, if any document in the &lt;code&gt;posts&lt;/code&gt; table above lacks a &lt;code&gt;category&lt;/code&gt; field, it won&amp;rsquo;t be included in the result set even if it has a &lt;code&gt;genre&lt;/code&gt; field whose value is &lt;code&gt;'mystery'&lt;/code&gt;. The problem isn&amp;rsquo;t the &lt;code&gt;or&lt;/code&gt; command; it&amp;rsquo;s that the invocation of &lt;code&gt;r.row('category')&lt;/code&gt; on a document without that field returns an error, and the rest of the filter predicate isn&amp;rsquo;t evaluated.</source>
          <target state="translated">그러나 위 의 &lt;code&gt;posts&lt;/code&gt; 테이블에 문서에 &lt;code&gt;category&lt;/code&gt; 필드가없는 경우 값이 &lt;code&gt;'mystery'&lt;/code&gt; 인 &lt;code&gt;genre&lt;/code&gt; 필드 가 있어도 결과 세트에 포함되지 않습니다 . 문제는 &lt;code&gt;or&lt;/code&gt; 명령 이 아닙니다 . 해당 필드가없는 문서에서 &lt;code&gt;r.row('category')&lt;/code&gt; 를 호출 하면 오류가 반환되고 나머지 필터 조건자는 평가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ab68a405a573ec72447284d7730942d09144c5b" translate="yes" xml:space="preserve">
          <source>However, that won&amp;rsquo;t work! The reason is that the query object doesn&amp;rsquo;t store state. Each of the commands after the first one is simply running on the &lt;em&gt;original&lt;/em&gt; value of &lt;code&gt;query&lt;/code&gt; (in this case, the &lt;code&gt;posts&lt;/code&gt; table). You can solve this by explicitly assigning the output of each new command to the &lt;code&gt;query&lt;/code&gt; variable:</source>
          <target state="translated">그러나 그것은 작동하지 않습니다! 그 이유는 쿼리 개체가 상태를 저장하지 않기 때문입니다. 첫 번째 명령 이후의 각 명령은 단순히 &lt;em&gt;원래 &lt;/em&gt; &lt;code&gt;query&lt;/code&gt; 값 (이 경우 &lt;code&gt;posts&lt;/code&gt; 테이블)에서 실행됩니다. 각 새 명령의 출력을 &lt;code&gt;query&lt;/code&gt; 변수 에 명시 적으로 지정하여이를 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e05c0bf3bf2f972577d556b1734e3c65fb13e2a" translate="yes" xml:space="preserve">
          <source>However, the first form (passing the index as an argument to &lt;code&gt;distinct&lt;/code&gt;) is faster, and won&amp;rsquo;t run into array limit issues since it&amp;rsquo;s returning a stream.</source>
          <target state="translated">그러나 첫 번째 형식 (인덱스를 &lt;code&gt;distinct&lt;/code&gt; 의 인수로 전달 )이 더 빠르며 스트림을 반환하므로 배열 제한 문제가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af69c31fd2ccb351c32df056cd24759e925cdadb" translate="yes" xml:space="preserve">
          <source>I get a &amp;ldquo;ReqlResourceLimitError: Array over size limit 100000&amp;rdquo; when trying to order a table</source>
          <target state="translated">테이블을 주문하려고 할 때&amp;ldquo;ReqlResourceLimitError : Array over size limit 100000&amp;rdquo;이 표시됩니다</target>
        </trans-unit>
        <trans-unit id="9433ac50f85f3397600f69393461f23a57de0a9b" translate="yes" xml:space="preserve">
          <source>I get back a connection in my callback with the Node driver</source>
          <target state="translated">노드 드라이버와의 콜백에서 연결을 다시 얻습니다.</target>
        </trans-unit>
        <trans-unit id="8a7ade210bab251eef67b6b310337a7a911f67f2" translate="yes" xml:space="preserve">
          <source>I get incorrect results when I pass functions with if/for statements to ReQL</source>
          <target state="translated">if / for 문이있는 함수를 ReQL에 전달하면 잘못된 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="c20ea07e32d25c072a65368c234d6f5a88f4521a" translate="yes" xml:space="preserve">
          <source>INSERT</source>
          <target state="translated">INSERT</target>
        </trans-unit>
        <trans-unit id="58ee37c4c15383ecc1c4a02446d911520642fcf8" translate="yes" xml:space="preserve">
          <source>ISO8601</source>
          <target state="translated">ISO8601</target>
        </trans-unit>
        <trans-unit id="a38f684f0bd8e40a0a38584d5636df0f1ce3d901" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;default&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt; (the default), documents with missing fields will be skipped.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; 이 &lt;code&gt;false&lt;/code&gt; (기본값) 로 설정 되면 누락 된 필드가있는 문서는 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="2000e8612ae4736ab4bd4478f0043d6b2d5b2a47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;default&lt;/code&gt; is set to &lt;code&gt;r.error()&lt;/code&gt;, an &lt;code&gt;ReqlRuntimeError&lt;/code&gt; will be thrown when a document with a missing field is tested.</source>
          <target state="translated">경우 &lt;code&gt;default&lt;/code&gt; 설정되어 &lt;code&gt;r.error()&lt;/code&gt; , &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 이 누락 된 필드 문서를 테스트 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3289e209f880af4ffc396ac28a2cb56909bbe4d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;default&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, documents with missing fields will be returned rather than skipped.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 필드가 누락 된 문서는 건너 뛰지 않고 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cbad5bbddabc4696c7b0fe7ac59bbdd74a689d0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;endOffset&lt;/code&gt; is past the end of the sequence, all elements from &lt;code&gt;startOffset&lt;/code&gt; to the end of the sequence will be returned. If &lt;code&gt;startOffset&lt;/code&gt; is past the end of the sequence or &lt;code&gt;endOffset&lt;/code&gt; is less than &lt;code&gt;startOffset&lt;/code&gt;, a zero-element sequence will be returned.</source>
          <target state="translated">경우 &lt;code&gt;endOffset&lt;/code&gt; 의이 순서의 끝을지나이며, 모든 요소 &lt;code&gt;startOffset&lt;/code&gt; 시퀀스의 끝이 반환됩니다. 경우 &lt;code&gt;startOffset&lt;/code&gt; 이 순서의 끝을지나거나 &lt;code&gt;endOffset&lt;/code&gt; 의이 보다 작은 &lt;code&gt;startOffset&lt;/code&gt; , 제로 요소의 순서가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="541d7adb5503b9e9cc1678d403ded0fcc502208e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;endOffset&lt;/code&gt; is specified, it must not be less than &lt;code&gt;offset&lt;/code&gt;. Both &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;endOffset&lt;/code&gt; must be within the array&amp;rsquo;s bounds (i.e., if the array has 10 elements, an &lt;code&gt;offset&lt;/code&gt; or &lt;code&gt;endOffset&lt;/code&gt; of 10 or higher is invalid).</source>
          <target state="translated">경우 &lt;code&gt;endOffset&lt;/code&gt; 의가 지정되어, 이상이어야한다 &lt;code&gt;offset&lt;/code&gt; . &lt;code&gt;offset&lt;/code&gt; 과 &lt;code&gt;endOffset&lt;/code&gt; 은 모두 배열의 범위 내에 있어야합니다 (즉, 배열에 10 개의 요소가있는 경우 &lt;code&gt;offset&lt;/code&gt; 또는 &lt;code&gt;endOffset&lt;/code&gt; 이 10 이상이면 유효하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="70e3400a53d9912811460dc3089f66e4bd36e1eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_val&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then &lt;code&gt;old_val&lt;/code&gt; contains the document that was deleted.</source>
          <target state="translated">경우 &lt;code&gt;new_val&lt;/code&gt; 이 있다 &lt;code&gt;null&lt;/code&gt; , 다음 &lt;code&gt;old_val&lt;/code&gt; 삭제 된 문서가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="de0f3c985cff6f8f6df3f791728158af7a1d7010" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;old_val&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then &lt;code&gt;new_val&lt;/code&gt; contains the newly created document.</source>
          <target state="translated">경우 &lt;code&gt;old_val&lt;/code&gt; 이 있다 &lt;code&gt;null&lt;/code&gt; , 다음 &lt;code&gt;new_val&lt;/code&gt; 는 새로 만든 문서가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e0dfba5c9ea511ec048c70efd9aa834fdfe8263" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reconfigure&lt;/code&gt; is called on a database, all the tables in the database will have their configurations affected. The return value will be an array of the objects described above, one per table.</source>
          <target state="translated">경우 &lt;code&gt;reconfigure&lt;/code&gt; 데이터베이스에서 호출, 데이터베이스의 모든 테이블은 구성이 영향을해야합니다. 리턴 값은 위에서 설명한 오브젝트의 배열이며 테이블 당 하나씩입니다.</target>
        </trans-unit>
        <trans-unit id="04dafed2e68464eb0c2df7065604fff9f98185a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;replicas&lt;/code&gt; is an integer, it specifies the number of replicas per shard. Specifying more replicas than there are servers will return an error.</source>
          <target state="translated">경우 &lt;code&gt;replicas&lt;/code&gt; 정수, 그것은 파편 당 복제본의 수를 지정합니다. 서버보다 많은 복제본을 지정하면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b48d338ec4b0cd8007b610f5216dc2440ba915b2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;replicas&lt;/code&gt; is an object, it specifies key-value pairs of server tags and the number of replicas to assign to those servers: &lt;code&gt;{tag1: 2, tag2: 4, tag3: 2, ...}&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;replicas&lt;/code&gt; 대상이며, 그것은 키 - 값 서버 태그의 쌍과 해당 서버에 할당 할 복제본의 수를 지정합니다 : &lt;code&gt;{tag1: 2, tag2: 4, tag3: 2, ...}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb2fb50f691e2304ef3477ac0d2d56d8f7c02254" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;replicas&lt;/code&gt; is an object, it specifies key-value pairs of server tags and the number of replicas to assign to those servers: &lt;code&gt;{tag1: 2, tag2: 4, tag3: 2, ...}&lt;/code&gt;. For more information about server tags, read &lt;a href=&quot;../../../docs/administration-tools/index&quot;&gt;Administration tools&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;replicas&lt;/code&gt; 대상이며, 그것은 키 - 값 서버 태그의 쌍과 해당 서버에 할당 할 복제본의 수를 지정합니다 : &lt;code&gt;{tag1: 2, tag2: 4, tag3: 2, ...}&lt;/code&gt; . 서버 태그에 대한 자세한 내용은 &lt;a href=&quot;../../../docs/administration-tools/index&quot;&gt;관리 도구를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3c635da42642bd2920f3672ac40f4da5ab950fc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;replicas&lt;/code&gt; is an object, it specifies key-value pairs of server tags and the number of replicas to assign to those servers: &lt;code&gt;{tag1:2,tag2:4,tag3:2,...}&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;replicas&lt;/code&gt; 대상이며, 그것은 키 - 값 서버 태그의 쌍과 해당 서버에 할당 할 복제본의 수를 지정합니다 : &lt;code&gt;{tag1:2,tag2:4,tag3:2,...}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14f31dd824a6c11f58e8cb24afb979b65f78e9ea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;replicas&lt;/code&gt; is an object, it specifies key-value pairs of server tags and the number of replicas to assign to those servers: &lt;code&gt;{tag1:2,tag2:4,tag3:2,...}&lt;/code&gt;. For more information about server tags, read &lt;a href=&quot;../../../docs/administration-tools/index&quot;&gt;Administration tools&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;replicas&lt;/code&gt; 대상이며, 그것은 키 - 값 서버 태그의 쌍과 해당 서버에 할당 할 복제본의 수를 지정합니다 : &lt;code&gt;{tag1:2,tag2:4,tag3:2,...}&lt;/code&gt; . 서버 태그에 대한 자세한 정보는 &lt;a href=&quot;../../../docs/administration-tools/index&quot;&gt;관리 도구를&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="a60664966184e4fe4a694c068740f17f6a53ba57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;returnChanges&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;&quot;always&quot;&lt;/code&gt;, the &lt;code&gt;changes&lt;/code&gt; array will follow the same order as the inserted documents. Documents in &lt;code&gt;changes&lt;/code&gt; for which an error occurs (such as a key conflict) will have a third field, &lt;code&gt;error&lt;/code&gt;, with an explanation of the error.</source>
          <target state="translated">경우 &lt;code&gt;returnChanges&lt;/code&gt; 가 설정되어 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;&quot;always&quot;&lt;/code&gt; 의 &lt;code&gt;changes&lt;/code&gt; 배열이 삽입 된 문서와 같은 순서를 따릅니다. 키 충돌과 같은 오류가 발생한 &lt;code&gt;changes&lt;/code&gt; 문서 에는 오류 에 대한 설명과 함께 세 번째 필드 인 &lt;code&gt;error&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dadb3aacb6423eb027f3fe197b6216164febbc7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;slice&lt;/code&gt; is used with a &lt;a href=&quot;../binary/index&quot;&gt;binary&lt;/a&gt; object, the indexes refer to byte positions within the object. That is, the range &lt;code&gt;(10,20)&lt;/code&gt; will refer to the 10th byte through the 19th byte.</source>
          <target state="translated">&lt;code&gt;slice&lt;/code&gt; 가 &lt;a href=&quot;../binary/index&quot;&gt;이진&lt;/a&gt; 객체 와 함께 사용되는 경우 인덱스는 객체 내의 바이트 위치를 나타냅니다. 즉, 범위 &lt;code&gt;(10,20)&lt;/code&gt; 는 10 번째 바이트부터 19 번째 바이트까지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2cd3ead652ee8e80ce01547b661f7b2f2a06b0d6" translate="yes" xml:space="preserve">
          <source>If a database with the same name already exists, the command throws &lt;code&gt;ReqlRuntimeError&lt;/code&gt;.</source>
          <target state="translated">동일한 이름의 데이터베이스가 이미 존재하면 명령은 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="f512423d2484874d4ef81262f263f73e18785542" translate="yes" xml:space="preserve">
          <source>If a server has timed out, the returned document will contain no statistics, but &lt;em&gt;will&lt;/em&gt; contain an error field.</source>
          <target state="translated">서버가 시간 초과 된 경우 반환 된 문서에는 통계가 없지만 오류 필드 &lt;em&gt;가&lt;/em&gt; 포함 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d67164fdd5b2432d26eb520edd2ceaec9fff9d09" translate="yes" xml:space="preserve">
          <source>If a table is unavailable for reads and/or writes but all its servers are still available, no issue will be shown.</source>
          <target state="translated">읽기 및 / 또는 쓰기에 테이블을 사용할 수 없지만 모든 서버를 계속 사용할 수있는 경우 문제가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec828d6df90fe81b82d20f519d2c700677a81bbc" translate="yes" xml:space="preserve">
          <source>If a table with the same name already exists, the command throws &lt;code&gt;ReqlOpFailedError&lt;/code&gt;.</source>
          <target state="translated">이름이 같은 테이블이 이미 있으면 명령은 &lt;code&gt;ReqlOpFailedError&lt;/code&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="762cbf1b1c5f6e0a0ced0867b8bfd90d270b76fb" translate="yes" xml:space="preserve">
          <source>If an error occurs during an asynchronous operation, the &lt;code&gt;yield&lt;/code&gt; statement will throw an exception as normal. This may happen immediately (for example, you might reference a table that doesn&amp;rsquo;t exist), but your application might receive large amounts of data before the error (for example, your network might be disrupted after the connection is established).</source>
          <target state="translated">비동기 작업 중에 오류가 발생하면 &lt;code&gt;yield&lt;/code&gt; 문은 정상적으로 예외를 throw합니다. 이 문제는 즉시 발생할 수 있지만 (예 : 존재하지 않는 테이블을 참조 할 수 있지만) 오류가 발생하기 전에 응용 프로그램이 많은 양의 데이터를 수신 할 수 있습니다 (예 : 연결이 설정된 후 네트워크가 중단 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="bd199cccfdd4faed1362982f6070c2db7adb71fd" translate="yes" xml:space="preserve">
          <source>If an initial result for a document has been sent and a change is made to that document that would move it to the unsent part of the result set (for instance, a changefeed monitors the top 100 posters, the first 50 have been sent, and poster 48 has become poster 52), an &amp;ldquo;uninitial&amp;rdquo; notification will be sent, with an &lt;code&gt;old_val&lt;/code&gt; field but no &lt;code&gt;new_val&lt;/code&gt; field. This is distinct from a delete change event, which would have a &lt;code&gt;new_val&lt;/code&gt; of &lt;code&gt;null&lt;/code&gt;. (In the top 100 posters example, that could indicate the poster has been deleted, or has dropped out of the top 100.)</source>
          <target state="translated">문서에 대한 초기 결과가 전송되고 해당 문서가 변경되어 결과 세트의 전송되지 않은 부분으로 이동하는 경우 (예 : 변경 피드가 상위 100 개의 포스터를 모니터링하고 처음 50 개가 전송 된 경우) 포스터 48은 포스터 52가 됨), &lt;code&gt;old_val&lt;/code&gt; 필드는 있지만 new_val 필드는없는 &quot; &lt;code&gt;new_val&lt;/code&gt; &quot;알림이 전송됩니다 . 이것은 &lt;code&gt;new_val&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 인 삭제 변경 이벤트와 다릅니다 . (100 개의 포스터 예에서 포스터가 삭제되었거나 100 개에서 제거되었음을 나타낼 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="26d654a2235b72cf5ee8cfc9300d6051e8b4403b" translate="yes" xml:space="preserve">
          <source>If half or more of the voting replicas for a shard are lost (including the case of a two-server cluster losing one server), the cluster will need to be repaired manually using the &lt;a href=&quot;../../api/javascript/reconfigure/index#emergency-repair-mode&quot;&gt;emergency repair&lt;/a&gt; option of &lt;code&gt;reconfigure&lt;/code&gt;.</source>
          <target state="translated">샤드에 대한 투표 복제본 중 절반 이상이 유실 된 경우 (두 서버 클러스터에서 서버 한 대가 손실 된 경우 포함) &lt;a href=&quot;../../api/javascript/reconfigure/index#emergency-repair-mode&quot;&gt;긴급 복구&lt;/a&gt; 옵션 인 &lt;code&gt;reconfigure&lt;/code&gt; 를 사용하여 클러스터를 수동으로 복구해야합니다 .</target>
        </trans-unit>
        <trans-unit id="77bbf8bb3d1284cc20e43e13466c1d3fbf32cb64" translate="yes" xml:space="preserve">
          <source>If half or more of the voting replicas of a shard are lost and cannot be reconnected, an &lt;em&gt;emergency repair&lt;/em&gt; will need to be performed. For more information on the emergency repair option, read the documentation for &lt;a href=&quot;../../api/javascript/reconfigure/index&quot;&gt;reconfigure&lt;/a&gt;.</source>
          <target state="translated">샤드의 투표 복제본 중 절반 이상이 손실되어 다시 연결할 수없는 경우 &lt;em&gt;응급 복구&lt;/em&gt; 를 수행해야합니다. 응급 복구 옵션에 대한 자세한 내용은 &lt;a href=&quot;../../api/javascript/reconfigure/index&quot;&gt;재구성&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="061df7e7c49aee434f1204c027cba934cda6af25" translate="yes" xml:space="preserve">
          <source>If half or more of the voting replicas of a shard are lost, the only way to recover availability is to run &lt;a href=&quot;../../api/javascript/reconfigure/index&quot;&gt;reconfigure&lt;/a&gt; with the &lt;code&gt;emergency_repair&lt;/code&gt; option. Consult the documentation for &lt;code&gt;reconfigure&lt;/code&gt; for more details.</source>
          <target state="translated">샤드의 투표 복제본 중 절반 이상이 손실 된 경우 가용성을 복구하는 유일한 방법 은 &lt;code&gt;emergency_repair&lt;/code&gt; 옵션으로 &lt;a href=&quot;../../api/javascript/reconfigure/index&quot;&gt;재구성&lt;/a&gt; 을 실행 하는 것입니다. 자세한 내용 은 &lt;code&gt;reconfigure&lt;/code&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="efde73ef7877a20ecc7739f334f47a742fb86558" translate="yes" xml:space="preserve">
          <source>If it doesn&amp;rsquo;t appear to be a memory issue and the log provides no clue, you can try asking for support on our official IRC channel, &lt;a href=&quot;http://webchat.freenode.net/?channels=#rethinkdb&quot;&gt;#rethinkdb on freenode&lt;/a&gt; or our &lt;a href=&quot;http://groups.google.com/group/rethinkdb&quot;&gt;Google Group&lt;/a&gt;. If your problem is a crash that we&amp;rsquo;ve seen before&amp;mdash;or our users have&amp;mdash;this may get you a quick answer.</source>
          <target state="translated">메모리 문제가 아닌 것으로 보이며 로그에 실마리가없는 경우 공식 IRC 채널 인 &lt;a href=&quot;http://webchat.freenode.net/?channels=#rethinkdb&quot;&gt;#rethinkdb on freenode&lt;/a&gt; 또는 &lt;a href=&quot;http://groups.google.com/group/rethinkdb&quot;&gt;Google Group&lt;/a&gt; 에 대한 지원을 요청할 수 있습니다 . 문제가 이전에 보았거나 사용자가 경험 한 충돌 인 경우 빠른 답변을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d31a410767f1b496fa91c893eba00137addcbe4" translate="yes" xml:space="preserve">
          <source>If it were a CSV file, you would use:</source>
          <target state="translated">CSV 파일 인 경우 다음을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="273525957d7122e79508032144daf98b9a7bfb02" translate="yes" xml:space="preserve">
          <source>If no callback is provided, a promise will be returned.</source>
          <target state="translated">콜백이 제공되지 않으면 약속이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3f18c7407787ae4cadbbed6cf6901d014fa5ee70" translate="yes" xml:space="preserve">
          <source>If no document exists with that primary key, &lt;code&gt;get&lt;/code&gt; will return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">해당 기본 키가있는 문서가 없으면 &lt;code&gt;get&lt;/code&gt; 은 &lt;code&gt;null&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="2c34094ff9acb919418ed68f9a89587ff4b66f77" translate="yes" xml:space="preserve">
          <source>If no match is found, returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">일치하는 것이 없으면 &lt;code&gt;null&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d365045e1c5dd0e5c7738c8f718e4c906a519cf2" translate="yes" xml:space="preserve">
          <source>If no tags are specified on startup, the server will be started with one tag, &lt;code&gt;default&lt;/code&gt;. Changing the sharding/replica information from the web UI or from ReQL commands that do not specify server tags will affect all servers with the &lt;code&gt;default&lt;/code&gt; tag.</source>
          <target state="translated">시작시 태그를 지정하지 않으면 서버는 하나의 태그 ( &lt;code&gt;default&lt;/code&gt; ) 로 시작됩니다 . 웹 UI 또는 서버 태그를 지정하지 않은 ReQL 명령에서 샤딩 / 복제 정보를 변경하면 &lt;code&gt;default&lt;/code&gt; 태그 가있는 모든 서버에 영향을 미칩니다 .</target>
        </trans-unit>
        <trans-unit id="0aee98830b826882bbc15a192271ab7048ad30ff" translate="yes" xml:space="preserve">
          <source>If one of the objects is a polygon or a line, the point will be projected onto the line or polygon assuming a perfect sphere model before the distance is computed (using the model specified with &lt;code&gt;geoSystem&lt;/code&gt;). As a consequence, if the polygon or line is extremely large compared to Earth&amp;rsquo;s radius and the distance is being computed with the default WGS84 model, the results of &lt;code&gt;distance&lt;/code&gt; should be considered approximate due to the deviation between the ellipsoid and spherical models.</source>
          <target state="translated">객체 중 하나가 다각형 또는 선인 경우 거리가 계산되기 전에 ( &lt;code&gt;geoSystem&lt;/code&gt; 으로 지정된 모델을 사용하여) 완벽한 구 모델을 가정하여 점이 선 또는 다각형에 투영됩니다 . 결과적으로 다각형 또는 선이 지구의 반지름에 비해 극히 크며 기본 WGS84 모델로 거리를 계산하는 경우 타원체 모델과 구형 모델의 편차로 인해 &lt;code&gt;distance&lt;/code&gt; 결과가 근사로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="547988c7baa3a8e7481b284ce93792e14a5f411c" translate="yes" xml:space="preserve">
          <source>If only &lt;code&gt;offset&lt;/code&gt; is specified, &lt;code&gt;deleteAt&lt;/code&gt; removes the element at that index. If both &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;endOffset&lt;/code&gt; are specified, &lt;code&gt;deleteAt&lt;/code&gt; removes the range of elements between &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;endOffset&lt;/code&gt;, inclusive of &lt;code&gt;offset&lt;/code&gt; but not inclusive of &lt;code&gt;endOffset&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 만 지정된 경우 &lt;code&gt;deleteAt&lt;/code&gt; 는 해당 인덱스에서 요소를 제거합니다. 양쪽 경우 &lt;code&gt;offset&lt;/code&gt; 및 &lt;code&gt;endOffset&lt;/code&gt; 의이 지정되어, &lt;code&gt;deleteAt&lt;/code&gt; 는 사이 요소 범위 제거 &lt;code&gt;offset&lt;/code&gt; 및 &lt;code&gt;endOffset&lt;/code&gt; 의 , 포함한 &lt;code&gt;offset&lt;/code&gt; 의 포함하지만 &lt;code&gt;endOffset&lt;/code&gt; 의 .</target>
        </trans-unit>
        <trans-unit id="93cdeb256a2ad46f4019d2d854dd0948d1443b40" translate="yes" xml:space="preserve">
          <source>If provided, the emitting function must return a list.</source>
          <target state="translated">제공되는 경우 방출 함수는 목록을 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="85371ec3fada1de618df9a12eeb103a9281a5594" translate="yes" xml:space="preserve">
          <source>If successful, &lt;code&gt;createIndex&lt;/code&gt; will return an object of the form &lt;code&gt;{&quot;created&quot;: 1}&lt;/code&gt;. If an index by that name already exists on the table, a &lt;code&gt;ReqlRuntimeError&lt;/code&gt; will be thrown.</source>
          <target state="translated">성공하면 &lt;code&gt;createIndex&lt;/code&gt; 는 &lt;code&gt;{&quot;created&quot;: 1}&lt;/code&gt; 형식의 객체를 반환합니다 . 해당 이름의 인덱스가 이미 테이블에 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="08bbef08552a1acfb0ef92a1b563805617586812" translate="yes" xml:space="preserve">
          <source>If successful, &lt;code&gt;createIndex&lt;/code&gt; will return an object of the form &lt;code&gt;{&quot;created&quot;:1}&lt;/code&gt;. If an index by that name already exists on the table, a &lt;code&gt;ReqlRuntimeError&lt;/code&gt; will be thrown.</source>
          <target state="translated">성공하면 &lt;code&gt;createIndex&lt;/code&gt; 는 &lt;code&gt;{&quot;created&quot;:1}&lt;/code&gt; 형식의 객체를 반환합니다 . 해당 이름의 인덱스가 이미 테이블에 존재하면 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e63b0f260be9dfbe19de4fd67d55ad17d37f0ceb" translate="yes" xml:space="preserve">
          <source>If successful, &lt;code&gt;setWriteHook&lt;/code&gt; returns an object of the following form:</source>
          <target state="translated">성공하면 &lt;code&gt;setWriteHook&lt;/code&gt; 은 다음 형식의 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e4e76ff0946a766ef5a743092083b843ce45d352" translate="yes" xml:space="preserve">
          <source>If successful, the command returns an object with two fields:</source>
          <target state="translated">성공하면 명령은 두 개의 필드가있는 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cb6692ae099a8a1eddf760e79c9cc4b51391cd12" translate="yes" xml:space="preserve">
          <source>If successful, the operation returns an object: &lt;code&gt;{synced: 1}&lt;/code&gt;.</source>
          <target state="translated">성공하면 작업은 &lt;code&gt;{synced: 1}&lt;/code&gt; 객체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3f099ce09be84c0c1d227ab9e128e80491015c35" translate="yes" xml:space="preserve">
          <source>If successful, the operation returns an object: &lt;code&gt;{synced:1}&lt;/code&gt;.</source>
          <target state="translated">성공하면 조작이 &lt;code&gt;{synced:1}&lt;/code&gt; 오브젝트를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2923d4d1e36d8e9e18eb7c10ec7984419a44d118" translate="yes" xml:space="preserve">
          <source>If tags aren&amp;rsquo;t specified when a server starts, the server is automatically assigned the &lt;code&gt;default&lt;/code&gt; tag. Documents cannot be inserted into &lt;code&gt;server_config&lt;/code&gt;. A new document gets created when a server connects to the cluster.</source>
          <target state="translated">서버를 시작할 때 태그를 지정하지 않으면 서버에 자동으로 &lt;code&gt;default&lt;/code&gt; 태그가 할당됩니다 . &lt;code&gt;server_config&lt;/code&gt; 에 문서를 삽입 할 수 없습니다 . 서버가 클러스터에 연결되면 새 문서가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="13169b77be457524ff32a677bc03d95492a45d9e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;db&lt;/code&gt; option is passed to the &lt;code&gt;run&lt;/code&gt; command, its value must be a &lt;code&gt;DB&lt;/code&gt; term. The query:</source>
          <target state="translated">경우 &lt;code&gt;db&lt;/code&gt; 옵션이 전달됩니다 &lt;code&gt;run&lt;/code&gt; 명령, 값은해야 &lt;code&gt;DB&lt;/code&gt; 의 용어. 쿼리 :</target>
        </trans-unit>
        <trans-unit id="8edba50ace18abb1314bf60cd6f3d0fcda04c32c" translate="yes" xml:space="preserve">
          <source>If the argument is a ReQL term (not including a datum), serialize it using the standard term:</source>
          <target state="translated">인수가 ReQL 용어 (데이텀 제외) 인 경우 표준 용어를 사용하여 직렬화하십시오.</target>
        </trans-unit>
        <trans-unit id="de24125bbc0cf5f33af7e2d8106c74639325e769" translate="yes" xml:space="preserve">
          <source>If the cluster requires authorization, you can prompt for the &lt;code&gt;admin&lt;/code&gt; user account password with &lt;code&gt;-p&lt;/code&gt;, or supply a &lt;code&gt;--password-file&lt;/code&gt; to read the password from. (The password file is just a plain text file, with the password on the first and only line.)</source>
          <target state="translated">클러스터에 권한이 필요한 경우 &lt;code&gt;-p&lt;/code&gt; 를 사용 하여 &lt;code&gt;admin&lt;/code&gt; 계정 암호를 묻 거나 &lt;code&gt;--password-file&lt;/code&gt; 을 제공하여 암호를 읽을 수 있습니다. 비밀번호 파일은 일반 텍스트 파일이며 비밀번호는 첫 번째 행과 유일한 행에 있습니다.</target>
        </trans-unit>
        <trans-unit id="0acb66e1a94ce282af96b933ae7b825c35ee4474" translate="yes" xml:space="preserve">
          <source>If the connection cannot be established, a &lt;code&gt;ReqlDriverError&lt;/code&gt; will be passed to the callback instead of a connection.</source>
          <target state="translated">연결을 설정할 수 없으면 &lt;code&gt;ReqlDriverError&lt;/code&gt; 가 연결 대신 콜백으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="07a6f801dd9460154f182a8f8dd0817d6309de72" translate="yes" xml:space="preserve">
          <source>If the documents in the table &lt;code&gt;marvel&lt;/code&gt; are:</source>
          <target state="translated">표에 &lt;code&gt;marvel&lt;/code&gt; 이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="f30a5dfdb2b1fdb4d94c80ce16b870e4ca1e325d" translate="yes" xml:space="preserve">
          <source>If the function passed to &lt;code&gt;indexCreate&lt;/code&gt; returns an error for a given document, that document will not be indexed. No error will be returned for those documents.</source>
          <target state="translated">&lt;code&gt;indexCreate&lt;/code&gt; 에 전달 된 함수 가 주어진 문서에 대해 오류를 리턴하면 해당 문서는 색인화되지 않습니다. 해당 문서에는 오류가 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ebcff7ab038fb5d86072a62ba35507e5a212753" translate="yes" xml:space="preserve">
          <source>If the given database does not exist, the command throws &lt;code&gt;ReqlRuntimeError&lt;/code&gt;.</source>
          <target state="translated">주어진 데이터베이스가 존재하지 않으면 명령은 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="83f8c355202cee0cf037193fa6419e0d1579befc" translate="yes" xml:space="preserve">
          <source>If the given table does not exist in the database, the command throws &lt;code&gt;ReqlRuntimeError&lt;/code&gt;.</source>
          <target state="translated">주어진 테이블이 데이터베이스에 존재하지 않으면 명령은 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="d33e35064ceaac7c92d0b921dbc25bb696a28689" translate="yes" xml:space="preserve">
          <source>If the language&amp;rsquo;s native binary format is used, use the pseudotype serialization described above.</source>
          <target state="translated">언어의 고유 이진 형식을 사용하는 경우 위에서 설명한 의사 유형 직렬화를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="794172004aead88e65b683a952a6720840320737" translate="yes" xml:space="preserve">
          <source>If the last point does not specify the same coordinates as the first point, &lt;code&gt;polygon&lt;/code&gt; will close the polygon by connecting them. You cannot directly construct a polygon with holes in it using &lt;code&gt;polygon&lt;/code&gt;, but you can use &lt;a href=&quot;../polygon_sub/index&quot;&gt;polygonSub&lt;/a&gt; to use a second polygon within the interior of the first to define a hole.</source>
          <target state="translated">마지막 점이 첫 번째 점과 동일한 좌표를 지정하지 않으면 &lt;code&gt;polygon&lt;/code&gt; 은 다각형을 연결하여 다각형을 닫습니다. 직접 사용하여 구멍을 가진 다각형 구성 할 수 &lt;code&gt;polygon&lt;/code&gt; ,하지만 당신은 사용할 수 있습니다 &lt;a href=&quot;../polygon_sub/index&quot;&gt;polygonSub을&lt;/a&gt; 구멍을 정의하는 최초의 내부에 두 번째 다각형을 사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="279227353c7ecc61dd5168899f51f27994a2cf67" translate="yes" xml:space="preserve">
          <source>If the native object is a Node.js &lt;code&gt;Buffer&lt;/code&gt;, then &lt;code&gt;expr&lt;/code&gt; will return a binary object. See &lt;a href=&quot;../binary/index&quot;&gt;binary&lt;/a&gt; for more information.</source>
          <target state="translated">기본 객체가 Node.js &lt;code&gt;Buffer&lt;/code&gt; 인 경우 &lt;code&gt;expr&lt;/code&gt; 은 이진 객체를 반환합니다. 자세한 내용은 &lt;a href=&quot;../binary/index&quot;&gt;이진&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6cd91c4ca8d0c94417414eca59c8a4a0745ad9b0" translate="yes" xml:space="preserve">
          <source>If the post has more than 100 views, set the &lt;code&gt;type&lt;/code&gt; of a post to &lt;code&gt;hot&lt;/code&gt;, else set it to &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">게시물의 조회수가 100 회를 초과하면 게시물 &lt;code&gt;type&lt;/code&gt; 을 &lt;code&gt;hot&lt;/code&gt; 으로 설정하고, 그렇지 않으면 &lt;code&gt;normal&lt;/code&gt; 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a8b3ab6af7c7c7f01aa89ce524e930adc4773f6" translate="yes" xml:space="preserve">
          <source>If the primary replica for a table fails, as long as more than half of the table&amp;rsquo;s voting replicas and more than half of the voting replicas for each shard remain available, one of the voting replicas will become the new primary replica.</source>
          <target state="translated">테이블의 투표 복제본의 절반 이상과 각 샤드에 대한 투표 복제본의 절반 이상을 사용할 수있는 한 테이블의 기본 복제본이 실패하면 투표 복제본 중 하나가 새로운 기본 복제본이됩니다.</target>
        </trans-unit>
        <trans-unit id="5992fd4ae70294816f6f1035fd88f48be1057692" translate="yes" xml:space="preserve">
          <source>If the primary replica for a table fails, as long as more than half of the table&amp;rsquo;s voting replicas and more than half of the voting replicas for each shard remain available, one of those voting replicas will be arbitrarily selected as the new primary. There will be a brief period of unavailability, but no data will be lost. If the primary replica specified in a table&amp;rsquo;s configuration comes back online after a failure, it will return to being the primary.</source>
          <target state="translated">테이블의 투표 복제본의 절반 이상과 각 샤드에 대한 투표 복제본의 절반 이상을 사용할 수있는 한 테이블의 기본 복제본에 오류가 발생하면 해당 투표 복제본 중 하나가 새로운 기본 복제본으로 임의로 선택됩니다. 사용할 수없는 기간은 짧지 만 데이터는 손실되지 않습니다. 장애 발생 후 테이블 구성에 지정된 기본 복제본이 온라인으로 돌아 오면 기본 복제본으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="18ddd2727a3246ed2f57a5fc71e675c7a4286058" translate="yes" xml:space="preserve">
          <source>If the primary replica is lost but more than half of the voting replicas are still available, an arbitrary voting replica will be elected as primary. The new primary will appear in &lt;code&gt;table_status&lt;/code&gt;, but the &lt;code&gt;primary_replica&lt;/code&gt; field of &lt;code&gt;table_config&lt;/code&gt; will not change. If the old primary ever becomes available again, the system will switch back. When the primary changes there will be a brief period of unavailability.</source>
          <target state="translated">기본 복제본이 손실되었지만 투표 복제본의 절반 이상을 계속 사용할 수있는 경우 임의의 투표 복제본이 기본으로 선택됩니다. 새 기본이 나타납니다 &lt;code&gt;table_status&lt;/code&gt; 하지만 &lt;code&gt;primary_replica&lt;/code&gt; 의 분야 &lt;code&gt;table_config&lt;/code&gt; 은 변경되지 않습니다. 이전 기본을 다시 사용할 수있게되면 시스템이 다시 전환됩니다. 주요 변경 사항이 있으면 사용할 수없는 기간이 짧습니다.</target>
        </trans-unit>
        <trans-unit id="6eb19c9d9de161ce9deb372c1a852deaaa59b9d1" translate="yes" xml:space="preserve">
          <source>If the programmer marks a read query to be ok with out-of-date data, RethinkDB will route the query to the closest available replica instead of routing it to the primary. In this case the client will see the data as long as there are replicas of the data on its side of the netsplit. However, in this case the data has the risk of being out of date. This is usually ok for reports, analytics, cached data, or any scenario in general where having the absolute latest information isn&amp;rsquo;t imperative.</source>
          <target state="translated">프로그래머가 오래된 데이터를 사용하여 읽기 쿼리에 문제가없는 것으로 표시하면 RethinkDB는 쿼리를 기본으로 라우팅하는 대신 사용 가능한 가장 가까운 복제본으로 라우팅합니다. 이 경우 클라이언트는 netsplit 측면에 데이터 복제본이있는 한 데이터를 볼 수 있습니다. 그러나이 경우 데이터가 오래 될 위험이 있습니다. 보고서, 분석, 캐시 된 데이터 또는 최신 정보가 반드시 필요한 것이 아닌 시나리오에는 일반적으로 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e03767ac627ef652aaabb8ba7ea00ea8e5ff0c57" translate="yes" xml:space="preserve">
          <source>If the sequence has less than the requested number of elements (i.e., calling &lt;code&gt;sample(10)&lt;/code&gt; on a sequence with only five elements), &lt;code&gt;sample&lt;/code&gt; will return the entire sequence in a random order.</source>
          <target state="translated">시퀀스에 요청 된 수보다 적은 수의 요소가있는 경우 (예 : 5 개의 요소 만있는 시퀀스에서 &lt;code&gt;sample(10)&lt;/code&gt; 호출 ) &lt;code&gt;sample&lt;/code&gt; 은 전체 시퀀스를 임의의 순서로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e80daa38162b2a8e635d7344846e528706031e35" translate="yes" xml:space="preserve">
          <source>If the sequence has only one element, the first element will be returned.</source>
          <target state="translated">시퀀스에 요소가 하나만 있으면 첫 번째 요소가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e31c2b8b5674abdc6e8ae2e43f28019783df7d9f" translate="yes" xml:space="preserve">
          <source>If the sequence is empty, the server will produce a &lt;code&gt;ReqlRuntimeError&lt;/code&gt; that can be caught with &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">시퀀스가 비어 있으면 서버는 &lt;code&gt;default&lt;/code&gt; 로 잡을 수 있는 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="297486ecfa823e3925af80b1b2a0da86d1f441bb" translate="yes" xml:space="preserve">
          <source>If the table becomes unavailable, the changefeed will be disconnected, and a runtime exception will be thrown by the driver.</source>
          <target state="translated">테이블을 사용할 수 없게되면 변경 피드의 연결이 끊어지고 드라이버에서 런타임 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e78393bd57dfdd0854c325d0ada127c46c54fc3c" translate="yes" xml:space="preserve">
          <source>If the user is local, the &lt;code&gt;&amp;lt;domain&amp;gt;&lt;/code&gt; is the name of the server; otherwise, it&amp;rsquo;s the name of the Windows Domain or Active Directory the user record is located in.</source>
          <target state="translated">사용자가 로컬 인 경우 &lt;code&gt;&amp;lt;domain&amp;gt;&lt;/code&gt; 은 서버의 이름입니다. 그렇지 않으면 사용자 레코드가있는 Windows 도메인 또는 Active Directory의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b38d841f1274380a6fad3c11a39dc0bd3d4f5892" translate="yes" xml:space="preserve">
          <source>If this is the case, you may be able to avoid crashes by changing RethinkDB&amp;rsquo;s cache size. For information on in-memory caches, how to check their current size, and how to change them, read &lt;a href=&quot;../memory-usage/index&quot;&gt;Understanding RethinkDB memory requirements&lt;/a&gt;.</source>
          <target state="translated">이 경우 RethinkDB의 캐시 크기를 변경하여 충돌을 피할 수 있습니다. 메모리 내 캐시, 현재 크기 확인 방법 및 변경 방법에 대한 자세한 내용은 &lt;a href=&quot;../memory-usage/index&quot;&gt;RethinkDB 메모리 요구 사항 이해를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e26451b295f2c64f69e48115cef996c58d0e87bf" translate="yes" xml:space="preserve">
          <source>If we go back into the &lt;code&gt;Article&lt;/code&gt; model and add the &lt;code&gt;has_many&lt;/code&gt; side of the association, it&amp;rsquo;s important to note that &lt;code&gt;has_many&lt;/code&gt; associations in NoBrainer are read-only. The server doesn&amp;rsquo;t support transactions, so saving the members of the association is up to the developer.</source>
          <target state="translated">&lt;code&gt;Article&lt;/code&gt; 모델 로 돌아가 연관 의 &lt;code&gt;has_many&lt;/code&gt; 측을 추가하는 경우 NoBrainer의 &lt;code&gt;has_many&lt;/code&gt; 연관은 읽기 전용입니다. 서버는 트랜잭션을 지원하지 않으므로 연결 멤버를 저장하는 것은 개발자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="562a74a46cba2abb9d672c91f3be189ffbff89c6" translate="yes" xml:space="preserve">
          <source>If we want to retrieve all users on the Galactica and Pegasus, we can write:</source>
          <target state="translated">Galactica와 Pegasus의 모든 사용자를 검색하려면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3091eed1fda89cc9704666214f1d9fddcd96cc63" translate="yes" xml:space="preserve">
          <source>If we want to retrieve all users that have the email address &lt;code&gt;user@email.com&lt;/code&gt;, we can write:</source>
          <target state="translated">이메일 주소가 &lt;code&gt;user@email.com&lt;/code&gt; 인 모든 사용자를 검색 하려면 다음 과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7540c0f9849aa5c72866ece490cc2ace24df9655" translate="yes" xml:space="preserve">
          <source>If you &lt;code&gt;delete&lt;/code&gt; a row from &lt;code&gt;table_config&lt;/code&gt; the table will be deleted. If you &lt;code&gt;insert&lt;/code&gt; a row, the &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;db&lt;/code&gt; fields are required; the other fields are optional, and will be automatically generated or set to their default if they are not specified. Do not include the &lt;code&gt;id&lt;/code&gt; field. The system will auto-generate a UUID.</source>
          <target state="translated">&lt;code&gt;table_config&lt;/code&gt; 에서 행 을 &lt;code&gt;delete&lt;/code&gt; 하면 테이블이 삭제됩니다. 행 을 &lt;code&gt;insert&lt;/code&gt; 하면 &lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;db&lt;/code&gt; 필드가 필요합니다. 다른 필드는 선택 사항이며, 지정되지 않은 경우 자동으로 생성되거나 기본값으로 설정됩니다. &lt;code&gt;id&lt;/code&gt; 필드를 포함하지 마십시오 . 시스템이 UUID를 자동 생성합니다.</target>
        </trans-unit>
        <trans-unit id="22ef0a100b781bbe86d9c3b56b60862049f3cd72" translate="yes" xml:space="preserve">
          <source>If you &lt;code&gt;replace&lt;/code&gt; a row in &lt;code&gt;table_config&lt;/code&gt;, you must include all the fields. It&amp;rsquo;s usually easier to &lt;code&gt;update&lt;/code&gt; specific fields.</source>
          <target state="translated">당신이 경우 &lt;code&gt;replace&lt;/code&gt; 의 행을 &lt;code&gt;table_config&lt;/code&gt; , 당신은 모든 필드를 포함해야합니다. 일반적으로 특정 필드 를 &lt;code&gt;update&lt;/code&gt; 것이 더 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="bc00aecc5294d2dc3548435f91ed3d2f89d0baeb" translate="yes" xml:space="preserve">
          <source>If you accept the &lt;code&gt;rowFinished&lt;/code&gt; callback, it &lt;em&gt;must&lt;/em&gt; be called at the end of each row. If you call &lt;code&gt;rowFinished&lt;/code&gt; with any value, iteration will stop, and the value will be wrapped in &lt;code&gt;error.message&lt;/code&gt; for the error handler.</source>
          <target state="translated">&lt;code&gt;rowFinished&lt;/code&gt; 콜백 을 수락하면 각 행의 끝에서 호출 &lt;em&gt;되어야합니다&lt;/em&gt; . 임의의 값으로 &lt;code&gt;rowFinished&lt;/code&gt; 를 호출하면 반복이 중지 되고 오류 처리기 의 값이 &lt;code&gt;error.message&lt;/code&gt; 에 래핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f9276b4d2b3fcbd52dda6edde3718ac5d70084a" translate="yes" xml:space="preserve">
          <source>If you are using configuration files to configure RethinkDB (e.g. &lt;code&gt;/etc/rethinkdb/instances.d/...&lt;/code&gt;), add &lt;code&gt;cache-size=&amp;lt;limit in MB&amp;gt;&lt;/code&gt; to the configuration file to set the size limit manually.</source>
          <target state="translated">구성 파일을 사용하여 RethinkDB를 구성하는 경우 (예 : &lt;code&gt;/etc/rethinkdb/instances.d/...&lt;/code&gt; ) 구성 파일에 &lt;code&gt;cache-size=&amp;lt;limit in MB&amp;gt;&lt;/code&gt; 를 추가 하여 크기 제한을 수동으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="cdcc580c70eb68dd90fba166fa8fe3d003208dd8" translate="yes" xml:space="preserve">
          <source>If you ask for a nested field that doesn&amp;rsquo;t exist, you will get an empty object or array (this is &lt;em&gt;not&lt;/em&gt; the same as a &lt;code&gt;null&lt;/code&gt; value):</source>
          <target state="translated">존재하지 않는 중첩 필드를 요청하면 빈 객체 또는 배열을 얻습니다 (이것은 &lt;code&gt;null&lt;/code&gt; 값 과 같지 &lt;em&gt;않습니다&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="771d3ba57f317fd5733896e2943507e103014c06" translate="yes" xml:space="preserve">
          <source>If you call the &lt;code&gt;stop&lt;/code&gt; method on a &lt;code&gt;Handler&lt;/code&gt;, it will stop processing changes and open streams using that handler will be closed. Queries registered with that handler instance will not be interrupted if they are currently processing (e.g., a batch write), but will close rather than executing after the handler has been stopped.</source>
          <target state="translated">&lt;code&gt;Handler&lt;/code&gt; 에서 &lt;code&gt;stop&lt;/code&gt; 메소드 를 호출하면 변경 처리가 중지되고 해당 핸들러를 사용하는 열린 스트림이 닫힙니다. 해당 처리기 인스턴스에 등록 된 쿼리는 현재 처리중인 경우 중단되지 않지만 (예 : 일괄 쓰기) 처리기가 중지 된 후 실행되지 않고 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="53db7cb1ddeb0a3b73fa5adb4f52c02474678ca5" translate="yes" xml:space="preserve">
          <source>If you change options in the configuration file, the service will be need to be restarted to pick up the changes.</source>
          <target state="translated">구성 파일에서 옵션을 변경하는 경우 변경 사항을 적용하려면 서비스를 다시 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="2816abb70037d2cb8f468a1edfbf5eabe5da4f44" translate="yes" xml:space="preserve">
          <source>If you compiled from source, get the &lt;code&gt;init.d&lt;/code&gt; script from &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/packaging/assets/init/rethinkdb&quot;&gt;here&lt;/a&gt;. Get the sample &lt;code&gt;.conf&lt;/code&gt; file &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/packaging/assets/config/default.conf.sample&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">소스에서 컴파일 한 경우 &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/packaging/assets/init/rethinkdb&quot;&gt;여기&lt;/a&gt; 에서 &lt;code&gt;init.d&lt;/code&gt; 스크립트를 가져 오십시오 . 샘플 취득 &lt;code&gt;.conf&lt;/code&gt; 파일을 &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/packaging/assets/config/default.conf.sample&quot;&gt;여기에&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83708fec6ffb6df17569d9d454fa458ff10ae070" translate="yes" xml:space="preserve">
          <source>If you didn&amp;rsquo;t install using Homebrew, you&amp;rsquo;ll need to create a launchd configuration file, and decide where you want to store your data files. These instructions assume the following locations:</source>
          <target state="translated">Homebrew를 사용하여 설치하지 않은 경우 시작된 구성 파일을 작성하고 데이터 파일을 저장할 위치를 결정해야합니다. 이 지침에서는 다음 위치를 가정합니다.</target>
        </trans-unit>
        <trans-unit id="eadc4d652313b1fe2d6ed6344fdf54172fc82742" translate="yes" xml:space="preserve">
          <source>If you do &lt;em&gt;not&lt;/em&gt; use &lt;code&gt;rowFinished&lt;/code&gt;, the &lt;code&gt;rowProcess&lt;/code&gt; callback can end iteration early by returning any value &lt;em&gt;other&lt;/em&gt; than a Promise. If it returns a non-Promise value (other than &lt;code&gt;undefined&lt;/code&gt;), then &lt;code&gt;final&lt;/code&gt; will receive an error object. If it returns a Promise, the Promise will be resolved before iteration continues; if the resolved Promise returns a value, iteration will be stopped and an error object will be passed to &lt;code&gt;final&lt;/code&gt;.</source>
          <target state="translated">당신이 경우에 &lt;em&gt;없는&lt;/em&gt; 사용 &lt;code&gt;rowFinished&lt;/code&gt; 을 의 &lt;code&gt;rowProcess&lt;/code&gt; 의 콜백 초기 값 반환하여 반복을 종료 할 수 있습니다 &lt;em&gt;다른&lt;/em&gt; 약속보다 더합니다. 이 (이외의 비 - 약속 값 반환하면 &lt;code&gt;undefined&lt;/code&gt; ) 다음 &lt;code&gt;final&lt;/code&gt; 오류 객체를 받게됩니다. Promise를 반환하면 반복이 계속되기 전에 Promise가 해결됩니다. 해결 된 Promise가 값을 반환하면 반복이 중지되고 오류 객체가 &lt;code&gt;final&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="dfd2e5e2bd99765946497d8434bb3926deedd62f" translate="yes" xml:space="preserve">
          <source>If you do not find one, treat the argument normally.</source>
          <target state="translated">하나를 찾지 못하면 인수를 정상적으로 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="e45384aab5ceacddb4ba809043d5294d1d019636" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have the Python driver installed, you can install a previous version using &lt;code&gt;pip install rethinkdb==&amp;lt;version&amp;gt;&lt;/code&gt;. (You can use the &lt;a href=&quot;https://pypi.python.org/pypi/rethinkdb&quot;&gt;Python Package Index&lt;/a&gt; to check on current and older versions.)</source>
          <target state="translated">Python 드라이버가 설치되어 있지 않은 경우 &lt;code&gt;pip install rethinkdb==&amp;lt;version&amp;gt;&lt;/code&gt; 사용하여 이전 버전을 설치할 수 있습니다 . ( &lt;a href=&quot;https://pypi.python.org/pypi/rethinkdb&quot;&gt;Python Package Index&lt;/a&gt; 를 사용하여 현재 및 이전 버전을 확인할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="b9550f01fd6cb5bf84e8788a9564ba6ce7305a18" translate="yes" xml:space="preserve">
          <source>If you forget the admin password, it can be changed from the Data Explorer using &lt;code&gt;update&lt;/code&gt; as described above.</source>
          <target state="translated">관리자 비밀번호를 잊어 버린 경우 위에서 설명한대로 &lt;code&gt;update&lt;/code&gt; 를 사용하여 데이터 탐색기에서 비밀번호를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ef723651e3c827e99014952458339056d2c209e" translate="yes" xml:space="preserve">
          <source>If you forget to specify the &lt;code&gt;nonAtomic&lt;/code&gt; flag, you will get a &lt;code&gt;ReqlRuntimeError&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;nonAtomic&lt;/code&gt; 플래그 를 지정하지 않으면 ReqlRuntimeError 가 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5646d27eb019a3807161da40de3568dc2f4e4197" translate="yes" xml:space="preserve">
          <source>If you have a secondary index built on the field &lt;code&gt;age&lt;/code&gt;, you can run a more efficient query:</source>
          <target state="translated">field &lt;code&gt;age&lt;/code&gt; 에 보조 인덱스가 구축되어 있으면보다 효율적인 쿼리를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c572ebf586ce8e501c48a35b2c6aaa65c043299" translate="yes" xml:space="preserve">
          <source>If you have a secondary index built on the field &lt;code&gt;name&lt;/code&gt;, you can run a more efficient query:</source>
          <target state="translated">field &lt;code&gt;name&lt;/code&gt; 필드에 보조 인덱스가 구축되어 있으면보다 효율적인 쿼리를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1235d59d708558b9571a719afc8da5ddd845970f" translate="yes" xml:space="preserve">
          <source>If you have a secondary index, you can use the &lt;a href=&quot;../../../api/javascript/between/index&quot;&gt;between&lt;/a&gt; command in conjunction with &lt;a href=&quot;../../../api/javascript/order_by/index&quot;&gt;orderBy&lt;/a&gt; and &lt;code&gt;limit&lt;/code&gt;. This is the most efficient way to paginate, but requires looking up values in the secondary index field to find the first record of each page.</source>
          <target state="translated">보조 인덱스가있는 경우 &lt;a href=&quot;../../../api/javascript/order_by/index&quot;&gt;orderBy&lt;/a&gt; 및 &lt;code&gt;limit&lt;/code&gt; 과 함께 &lt;a href=&quot;../../../api/javascript/between/index&quot;&gt;between&lt;/a&gt; 명령을 사용할 수 있습니다 . 페이지 매김을 수행하는 가장 효율적인 방법이지만 각 페이지의 첫 번째 레코드를 찾으려면 보조 인덱스 필드에서 값을 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="76ce08c2e0f3f14f3e931d8e20da63959f60afbe" translate="yes" xml:space="preserve">
          <source>If you have a time, you can retrieve a particular portion (like the month, or the hours) relative to the current time zone. (See the full list at the &lt;a href=&quot;https://rethinkdb.com/api&quot;&gt;API reference&lt;/a&gt;.)</source>
          <target state="translated">시간이 있으면 현재 시간대를 기준으로 특정 부분 (예 : 월 또는 시간)을 검색 할 수 있습니다. ( &lt;a href=&quot;https://rethinkdb.com/api&quot;&gt;API 참조&lt;/a&gt; 의 전체 목록을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="bfe387ee6476daedd31f1f133dde57638c19abdf" translate="yes" xml:space="preserve">
          <source>If you have an index (primary key or secondary index) built on the field of the right table, you can perform a more efficient join with &lt;a href=&quot;../../../api/javascript/eq_join/index&quot;&gt;eqJoin&lt;/a&gt;.</source>
          <target state="translated">오른쪽 테이블의 필드에 인덱스 (기본 키 또는 보조 인덱스)가 구축되어 &lt;a href=&quot;../../../api/javascript/eq_join/index&quot;&gt;있으면 eqJoin을&lt;/a&gt; 사용하여보다 효율적인 조인을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82e4fe23b378dc14cd8cfd0877cfbc4782c6460c" translate="yes" xml:space="preserve">
          <source>If you have changed the intracluster port from 29015, use the new number. For more guidance, see RethinkDB&amp;rsquo;s &lt;a href=&quot;../cluster-on-startup/index&quot;&gt;cluster setup instructions&lt;/a&gt; and Amazon&amp;rsquo;s documentation on &lt;a href=&quot;http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_SecurityGroups.html&quot;&gt;Security Groups for your VPC&lt;/a&gt;.</source>
          <target state="translated">클러스터 내 포트를 29015에서 변경 한 경우 새 번호를 사용하십시오. 자세한 지침은 RethinkDB의 &lt;a href=&quot;../cluster-on-startup/index&quot;&gt;클러스터 설정 지침&lt;/a&gt; 및 &lt;a href=&quot;http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_SecurityGroups.html&quot;&gt;VPC의 보안 그룹에 대한&lt;/a&gt; Amazon 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="05a4aedf88c6ef11885acadb36c80628a3555466" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t already added billing information to your Compose account, you&amp;rsquo;ll be prompted to do so before deployment.</source>
          <target state="translated">결제 정보를 작성 계정에 아직 추가하지 않은 경우 배포 전에 추가하라는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3e16ddb9cd8af200dcaf09b797a43f7f78d9b2f8" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t read the &lt;a href=&quot;../../changefeeds/javascript/index&quot;&gt;article on changefeeds&lt;/a&gt; yet, start there! You can subscribe to notifications on tables and queries with changefeeds alone, without using publish-subscribe. If you&amp;rsquo;d like to see how to implement a message queue with topics using changefeeds, read on!</source>
          <target state="translated">변경 &lt;a href=&quot;../../changefeeds/javascript/index&quot;&gt;피드에&lt;/a&gt; 대한 기사를 아직 읽지 않았다면 시작하십시오! publish-subscribe를 사용하지 않고 변경 피드만으로 테이블 및 쿼리에 대한 알림을 구독 할 수 있습니다. 변경 피드를 사용하여 주제가 포함 된 메시지 대기열을 구현하는 방법을 보려면 계속 읽으십시오!</target>
        </trans-unit>
        <trans-unit id="288b2d3310d3674f40603201b027dd0c6eb8f2a2" translate="yes" xml:space="preserve">
          <source>If you install RethinkDB using &lt;a href=&quot;http://brew.sh&quot;&gt;Homebrew&lt;/a&gt;, a &lt;code&gt;launchd&lt;/code&gt; configuration file will be installed for you in &lt;code&gt;~/Library/LaunchAgents/&lt;/code&gt;, although that file may need to be modified.</source>
          <target state="translated">사용 RethinkDB를 설치하는 경우 &lt;a href=&quot;http://brew.sh&quot;&gt;브루을&lt;/a&gt; 하는 &lt;code&gt;launchd&lt;/code&gt; 에의 구성 파일이 당신을 위해 설치됩니다에서 &lt;code&gt;~/Library/LaunchAgents/&lt;/code&gt; 그 파일을 수정해야 할 수도있다.</target>
        </trans-unit>
        <trans-unit id="a5552500ec8d4feb23c54bc6392958bb200d8875" translate="yes" xml:space="preserve">
          <source>If you installed RethinkDB through a package manager on a system that does &lt;em&gt;not&lt;/em&gt; use &lt;code&gt;systemd&lt;/code&gt;, then you may have to check where it&amp;rsquo;s configured to log. It&amp;rsquo;s very likely this will be in the &lt;code&gt;/var/log/&lt;/code&gt; directory (i.e., &lt;code&gt;/var/log/rethinkdb&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;systemd&lt;/code&gt; 를 사용 하지 &lt;em&gt;않는&lt;/em&gt; 시스템에서 패키지 관리자를 통해 RethinkDB를 설치 한 경우 로그 구성 위치를 확인해야 할 수 있습니다. 이것이 &lt;code&gt;/var/log/&lt;/code&gt; 디렉토리 (예 : &lt;code&gt;/var/log/rethinkdb&lt;/code&gt; )에 있을 가능성이 큽니다 .</target>
        </trans-unit>
        <trans-unit id="647301df2f1301b87e8dd79c6025e36d6587ac71" translate="yes" xml:space="preserve">
          <source>If you need to do this, you can try passing the &lt;code&gt;--no-secondary-indexes&lt;/code&gt; flag to &lt;code&gt;restore&lt;/code&gt; as a workaround. This will usually allow restores to work on older versions, although this is not guaranteed.</source>
          <target state="translated">이 작업을 수행해야하는 경우 &lt;code&gt;--no-secondary-indexes&lt;/code&gt; 플래그를 전달하여 해결 방법 으로 &lt;code&gt;restore&lt;/code&gt; 할 수 있습니다 . 보장되지는 않지만 일반적으로 이전 버전에서 복원을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddf5f2f153ce1b030eca220c0f0c9358b895c3a9" translate="yes" xml:space="preserve">
          <source>If you need to keep both fields, you can rename them with &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;without&lt;/code&gt; before using the &lt;code&gt;zip&lt;/code&gt; command.</source>
          <target state="translated">당신이 두 필드를 유지해야하는 경우로 이름을 바꿀 수 있습니다 &lt;code&gt;map&lt;/code&gt; 및 &lt;code&gt;without&lt;/code&gt; 사용하기 전에 &lt;code&gt;zip&lt;/code&gt; 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0c512f640834e077c4381c35c4c5f5238c4d755c" translate="yes" xml:space="preserve">
          <source>If you need to retrieve only a few specific fields from your documents, you can use the &lt;code&gt;pluck&lt;/code&gt; command. For example, here is how you&amp;rsquo;d return only the fields &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt; from each row in table &lt;code&gt;users&lt;/code&gt;:</source>
          <target state="translated">문서에서 몇 가지 특정 필드 만 검색해야하는 경우 &lt;code&gt;pluck&lt;/code&gt; 명령을 사용할 수 있습니다 . 예를 들어 다음은 테이블 &lt;code&gt;users&lt;/code&gt; 각 행에서 필드 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;age&lt;/code&gt; 만 반환하는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="b75a375a87a4428fc1234e32ea18a55d70c1347d" translate="yes" xml:space="preserve">
          <source>If you pass an ISO 8601 string without a time zone, you must specify the time zone with the &lt;code&gt;defaultTimezone&lt;/code&gt; argument.</source>
          <target state="translated">시간대없이 ISO 8601 문자열을 전달하는 경우 &lt;code&gt;defaultTimezone&lt;/code&gt; 인수로 시간대를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f596ed1d102ee48cfe38f90920a8a73907a2fff7" translate="yes" xml:space="preserve">
          <source>If you provide a &lt;code&gt;final&lt;/code&gt; callback, it will always be executed when row processing is completed (the end of the sequence is hit, iteration is stopped prematurely, or an error occurs). The &lt;code&gt;final&lt;/code&gt; callback will receive an &lt;code&gt;error&lt;/code&gt; object if an error is thrown or &lt;code&gt;rowProcess&lt;/code&gt; returns any value (other than a Promise). If &lt;code&gt;final&lt;/code&gt; returns any value it will be ignored.</source>
          <target state="translated">&lt;code&gt;final&lt;/code&gt; 콜백 을 제공 하면 행 처리가 완료 될 때 항상 실행됩니다 (시퀀스의 끝에 도달했거나 반복이 조기에 중지되거나 오류가 발생 함). &lt;code&gt;final&lt;/code&gt; 콜백은받을 것이다 &lt;code&gt;error&lt;/code&gt; 오류가 발생하거나 경우 객체를 &lt;code&gt;rowProcess&lt;/code&gt; 이 (약속 제외) 값을 반환합니다. 경우 &lt;code&gt;final&lt;/code&gt; 반환 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e6396deb74891150f578d1c5de136d0b47288655" translate="yes" xml:space="preserve">
          <source>If you read this document back, you&amp;rsquo;ll get this:</source>
          <target state="translated">이 문서를 다시 읽으면 다음과 같은 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f68dcdc1d24865c3b47fc643cd2e0f50d3fbb0a" translate="yes" xml:space="preserve">
          <source>If you remove &lt;em&gt;all&lt;/em&gt; of a server&amp;rsquo;s tags and then reconfigure all the cluster&amp;rsquo;s tables, that server will be taken out of service.</source>
          <target state="translated">당신이 제거하면 &lt;em&gt;모든&lt;/em&gt; 서버의 태그를 다음 모든 클러스터의 테이블을 재구성, 해당 서버는 서비스의 밖으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="c6a74de84425f66a0b769b6d4648c4cc1b05afde" translate="yes" xml:space="preserve">
          <source>If you run a query that returns a grouped stream, it will be automatically converted to grouped data before being sent back to you (there is currently no efficient way to stream groups from RethinkDB). This grouped data is subject to the array size limit, by default 100,000 elements (see &lt;a href=&quot;../run/index&quot;&gt;run&lt;/a&gt; for details on how to use the &lt;code&gt;arrayLimit&lt;/code&gt; option to change this).</source>
          <target state="translated">그룹화 된 스트림을 반환하는 쿼리를 실행하면 사용자에게 다시 보내기 전에 자동으로 그룹화 된 데이터로 변환됩니다 (현재 RethinkDB에서 그룹을 스트리밍하는 효율적인 방법은 없습니다). 이 그룹화 된 데이터에는 기본적으로 100,000 개의 요소가 배열 크기 제한의 적용을받습니다 ( &lt;code&gt;arrayLimit&lt;/code&gt; 옵션을 사용하여 이를 변경 하는 방법에 대한 자세한 내용 은 &lt;a href=&quot;../run/index&quot;&gt;실행&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="86f33fd9951e9ede0d1ce3032f36a0859998d02f" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;true&lt;/code&gt; for both &lt;code&gt;includeStates&lt;/code&gt; and &lt;code&gt;includeInitial&lt;/code&gt;, the changefeed stream will start with a &lt;code&gt;{state: 'initializing'}&lt;/code&gt; status document, followed by initial values. A &lt;code&gt;{state: 'ready'}&lt;/code&gt; status document will be sent when all the initial values have been sent.</source>
          <target state="translated">&lt;code&gt;includeStates&lt;/code&gt; 및 &lt;code&gt;includeInitial&lt;/code&gt; 모두에 대해 &lt;code&gt;true&lt;/code&gt; 를 지정 하면 changefeed 스트림은 &lt;code&gt;{state: 'initializing'}&lt;/code&gt; 상태 문서로 시작하고 그 뒤에 초기 값이 이어집니다. &lt;code&gt;{state: 'ready'}&lt;/code&gt; 모든 초기 값이 전송되었습니다 때 상태 문서가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="e70f8245f1c68cb85f247cf67565bb8eec8be33c" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;true&lt;/code&gt; for both &lt;code&gt;includeStates&lt;/code&gt; and &lt;code&gt;includeInitial&lt;/code&gt;, the changefeed stream will start with a &lt;code&gt;{state:'initializing'}&lt;/code&gt; status document, followed by initial values. A &lt;code&gt;{state:'ready'}&lt;/code&gt; status document will be sent when all the initial values have been sent.</source>
          <target state="translated">&lt;code&gt;includeStates&lt;/code&gt; 및 &lt;code&gt;includeInitial&lt;/code&gt; 모두에 대해 &lt;code&gt;true&lt;/code&gt; 를 지정 하면 변경 피드 스트림이 &lt;code&gt;{state:'initializing'}&lt;/code&gt; 상태 문서로 시작하고 그 뒤에 초기 값 이옵니다 . &lt;code&gt;{state:'ready'}&lt;/code&gt; 모든 초기 값이 전송되었습니다 때 상태 문서가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="2cbddffcc9f00819db397afa4df1b08e38d12bf2" translate="yes" xml:space="preserve">
          <source>If you started &lt;code&gt;rethinkdb&lt;/code&gt; on a terminal rather than from a startup script, it will log to the &lt;code&gt;rethinkdb_data&lt;/code&gt; directory. By default it will write to &lt;code&gt;log_file&lt;/code&gt; but this may be overridden with the &lt;code&gt;--log-file&lt;/code&gt; startup option.</source>
          <target state="translated">시작 스크립트가 아닌 터미널에서 &lt;code&gt;rethinkdb&lt;/code&gt; 를 시작한 경우 &lt;code&gt;rethinkdb_data&lt;/code&gt; 디렉토리에 기록됩니다 . 기본적으로 &lt;code&gt;log_file&lt;/code&gt; 에 쓰지만 &lt;code&gt;--log-file&lt;/code&gt; startup 옵션 으로 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82ace7a41170ad2855ed92f890913f90ce2fe88d" translate="yes" xml:space="preserve">
          <source>If you subtract two times, you get a duration:</source>
          <target state="translated">두 번 빼면 지속 시간이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="4ed2b0735a26aa75e5a52e94d19026c65a460278" translate="yes" xml:space="preserve">
          <source>If you support &lt;code&gt;IMPLICIT_VAR&lt;/code&gt; in your driver, then every time you parse the argument of a function you should check if the method can take a function. If it can, you should look for an &lt;code&gt;IMPLICIT_VAR&lt;/code&gt; term (i.e., &lt;code&gt;row&lt;/code&gt;). If you find one, wrap the argument in a function that takes one parameter:</source>
          <target state="translated">드라이버에서 &lt;code&gt;IMPLICIT_VAR&lt;/code&gt; 을 지원하는 경우 함수의 인수를 구문 분석 할 때마다 메소드가 함수를 사용할 수 있는지 확인해야합니다. 가능하면 &lt;code&gt;IMPLICIT_VAR&lt;/code&gt; 용어 (예 : &lt;code&gt;row&lt;/code&gt; )를 찾아야합니다 . 하나를 찾으면 하나의 매개 변수를 사용하는 함수에서 인수를 래핑하십시오.</target>
        </trans-unit>
        <trans-unit id="7e555f9a01208c3228041f9a60ea0708846725a6" translate="yes" xml:space="preserve">
          <source>If you try to serialize a document containing a ReQL time zone object using Python&amp;rsquo;s &lt;code&gt;json&lt;/code&gt; library, you may receive this error. Solve this by passing the &lt;code&gt;time_format=&quot;raw&quot;&lt;/code&gt; option to &lt;code&gt;run&lt;/code&gt;:</source>
          <target state="translated">Python의 &lt;code&gt;json&lt;/code&gt; 라이브러리를 사용하여 ReQL 표준 시간대 객체가 포함 된 문서를 직렬화하려고하면 이 오류가 발생할 수 있습니다. 통과하여이 문제를 해결 &lt;code&gt;time_format=&quot;raw&quot;&lt;/code&gt; 옵션을 사용하는 &lt;code&gt;run&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a69fd118d720c0b3ef04383826f0c9000327522b" translate="yes" xml:space="preserve">
          <source>If you use arrays as indexes (compound indexes), they will be sorted using &lt;a href=&quot;https://en.wikipedia.org/wiki/Lexicographical_order&quot;&gt;lexicographical order&lt;/a&gt;. Take the following range as an example:</source>
          <target state="translated">배열을 인덱스 (복합 인덱스)로 사용하는 경우 &lt;a href=&quot;https://en.wikipedia.org/wiki/Lexicographical_order&quot;&gt;사전 식 순서를&lt;/a&gt; 사용하여 정렬됩니다 . 다음 범위를 예로 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="137368e26abb11bd3729cf72ed538f86d0b76bb7" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;zip&lt;/code&gt; command after &lt;code&gt;join&lt;/code&gt;, the document from the right table will be merged into the left one.</source>
          <target state="translated">&lt;code&gt;join&lt;/code&gt; 후 &lt;code&gt;zip&lt;/code&gt; 명령 을 사용하면 오른쪽 테이블의 문서가 왼쪽 문서로 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="faa0c1937c2c1e18853e93e9c38fa77f7753e71f" translate="yes" xml:space="preserve">
          <source>If you use this option on the server, the client must use a secure connection as well. Pass the certificate information in the &lt;code&gt;ssl&lt;/code&gt; option to the &lt;code&gt;connect&lt;/code&gt; ReQL command; read the API documentation for &lt;a href=&quot;../../api/javascript/connect/index&quot;&gt;connect&lt;/a&gt; for details on your language&amp;rsquo;s specific syntax.</source>
          <target state="translated">서버에서이 옵션을 사용하는 경우 클라이언트도 보안 연결을 사용해야합니다. &lt;code&gt;ssl&lt;/code&gt; 옵션 의 인증서 정보를 &lt;code&gt;connect&lt;/code&gt; ReQL 명령에 전달하십시오. 언어 별 구문에 대한 자세한 내용 은 &lt;a href=&quot;../../api/javascript/connect/index&quot;&gt;connect&lt;/a&gt; API 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8933a5a5bc42ce744657eae9a0d136b21cd536e8" translate="yes" xml:space="preserve">
          <source>If you want an exact match for a field that is an object, you will have to use &lt;code&gt;r.literal&lt;/code&gt;.</source>
          <target state="translated">객체 인 필드와 정확히 일치하려면 &lt;code&gt;r.literal&lt;/code&gt; 을 사용해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="42f06f6a06529fafebf5726831ab492c1731013d" translate="yes" xml:space="preserve">
          <source>If you want to operate on all the groups rather than operating on each group (e.g. if you want to order the groups by their reduction), you can use &lt;a href=&quot;../ungroup/index&quot;&gt;ungroup&lt;/a&gt; to turn a grouped stream or grouped data into an array of objects representing the groups.</source>
          <target state="translated">각 그룹에서 작업하지 않고 모든 그룹에서 작업하려는 경우 (예 : 그룹을 축소 순서로 정렬하려는 경우) &lt;a href=&quot;../ungroup/index&quot;&gt;그룹 해제&lt;/a&gt; 를 사용 하여 그룹화 된 스트림 또는 그룹화 된 데이터를 그룹을 나타내는 개체 배열로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e46c1955c2c8d4036f94c039e2a8a144057b763" translate="yes" xml:space="preserve">
          <source>If you want to perform a query that returns aggregations on different fields together, this is a canonical use case for &lt;a href=&quot;../../map-reduce/index&quot;&gt;map-reduce&lt;/a&gt;.</source>
          <target state="translated">다른 필드에 대한 집계를 함께 리턴하는 쿼리를 수행하려는 경우 이는 &lt;a href=&quot;../../map-reduce/index&quot;&gt;map-reduce&lt;/a&gt; 의 표준 사용 사례입니다 .</target>
        </trans-unit>
        <trans-unit id="ffc292f977df5974c81cb7f1681982162644cd6e" translate="yes" xml:space="preserve">
          <source>If you want to retrieve all the posts with the primary keys &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, or &lt;code&gt;3&lt;/code&gt; you can use the &lt;code&gt;getAll&lt;/code&gt; command:</source>
          <target state="translated">기본 키 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; 또는 &lt;code&gt;3&lt;/code&gt; 으로 모든 게시물을 검색 하려면 &lt;code&gt;getAll&lt;/code&gt; 명령을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dbbd54db4f2738a27bb5bf620810ae9c295fee97" translate="yes" xml:space="preserve">
          <source>If you want to retrieve all users whose last name contains &amp;ldquo;ll&amp;rdquo;, you can use &lt;code&gt;r.match&lt;/code&gt; this way:</source>
          <target state="translated">&lt;code&gt;r.match&lt;/code&gt; &amp;ldquo;ll&amp;rdquo;이 포함 된 모든 사용자를 검색하려면 다음과 같이 r.match 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="57d32ed6842f8937bfbfb6135067bdf013914ba5" translate="yes" xml:space="preserve">
          <source>If you want to retrieve all users whose last name ends with an &amp;ldquo;s&amp;rdquo;, you can use &lt;code&gt;r.match&lt;/code&gt; this way:</source>
          <target state="translated">성이 &quot;s&quot;로 끝나는 모든 사용자를 검색하려면 다음과 같이 &lt;code&gt;r.match&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5955d5b29355702e414b30489a1bf41c4ff4157d" translate="yes" xml:space="preserve">
          <source>If you want to retrieve all users whose last name starts with &amp;ldquo;Ma&amp;rdquo;, you can use &lt;code&gt;r.match&lt;/code&gt; this way:</source>
          <target state="translated">성이 &quot;Ma&quot;로 시작하는 모든 사용자를 검색하려면 &lt;code&gt;r.match&lt;/code&gt; 같이 r.match 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33be99218ff191c90e1b3baa8c8578229b913813" translate="yes" xml:space="preserve">
          <source>If you want to uninstall the RethinkDB service:</source>
          <target state="translated">RethinkDB 서비스를 제거하려면 :</target>
        </trans-unit>
        <trans-unit id="c0bc2c2dcf06bfff997e2c4a74f6f884030f7aba" translate="yes" xml:space="preserve">
          <source>If you want to use a prefix notation, you just need to implement all the commands on a module. If you want to use an infix notation, you should implement all the functions on a class &amp;ldquo;term&amp;rdquo; and some prefix commands on the module.</source>
          <target state="translated">접두사 표기법을 사용하려면 모듈에서 모든 명령을 구현하면됩니다. 접두사 표기법을 사용하려면 클래스&amp;ldquo;term&amp;rdquo;의 모든 기능과 모듈의 일부 접두사 명령을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="9be25802011254b9d2a1331968b140867a7a3dff" translate="yes" xml:space="preserve">
          <source>If you wanted to receive &lt;em&gt;all&lt;/em&gt; the changes, including the interim states, you could do so by passing &lt;code&gt;squash: false&lt;/code&gt;. The server will buffer up to 100,000 changes. (This number can be changed with the &lt;code&gt;changefeedQueueSize&lt;/code&gt; optional argument.)</source>
          <target state="translated">임시 상태를 포함하여 &lt;em&gt;모든&lt;/em&gt; 변경 사항 을 수신 하려면 &lt;code&gt;squash: false&lt;/code&gt; 를 전달하면됩니다 . 서버는 최대 100,000 개의 변경 사항을 버퍼링합니다. 이 숫자는 &lt;code&gt;changefeedQueueSize&lt;/code&gt; 선택적 인수를 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0bfcf6ae6bbb104a8f2d9363a057e7ab252bf34a" translate="yes" xml:space="preserve">
          <source>If you wish other locations, change the text in the file appropriately.</source>
          <target state="translated">다른 위치를 원하면 파일의 텍스트를 적절하게 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="683e445d7ef31ffd6276aee46241b7bc6d8c2d1d" translate="yes" xml:space="preserve">
          <source>If you wish to find all points within a certain radius of another point, it&amp;rsquo;s often faster to use &lt;a href=&quot;../get_intersecting/index&quot;&gt;getIntersecting&lt;/a&gt; with &lt;a href=&quot;../circle/index&quot;&gt;circle&lt;/a&gt;, as long as the approximation of a circle that &lt;code&gt;circle&lt;/code&gt; generates is sufficient.</source>
          <target state="translated">다른 지점의 특정 반경 내에있는 모든 점을 발견 할 경우, 사용하는 빠른 자주의 &lt;a href=&quot;../get_intersecting/index&quot;&gt;getIntersecting를&lt;/a&gt; 함께 &lt;a href=&quot;../circle/index&quot;&gt;원&lt;/a&gt; 하는 원의 근사 한, &lt;code&gt;circle&lt;/code&gt; 충분하다 생성한다.</target>
        </trans-unit>
        <trans-unit id="7524784d2e4a2810021fbd5dcbfcfdac73a9720d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re doing ad-hoc analysis and know your table won&amp;rsquo;t have more then 100,000 elements (or you&amp;rsquo;ve changed the setting of the &lt;code&gt;array_limit&lt;/code&gt; option for &lt;a href=&quot;../run/index&quot;&gt;run&lt;/a&gt;) you can run &lt;code&gt;orderBy&lt;/code&gt; without an index:</source>
          <target state="translated">임시 분석을 수행하고 있고 테이블에 100,000 개 이상의 요소가없는 경우 (또는 &lt;a href=&quot;../run/index&quot;&gt;run&lt;/a&gt; 의 &lt;code&gt;array_limit&lt;/code&gt; 옵션 설정을 변경 한 경우 ) 인덱스없이 &lt;code&gt;orderBy&lt;/code&gt; 를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e6a5888fe6d36406b5d6e9972fc8df495ab5b94" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re running RethinkDB on Linux and see a &amp;ldquo;Data from a process on this server has been placed into swap memory&amp;rdquo; warning in the &lt;a href=&quot;../system-issues/index#memory-availability-issues&quot;&gt;System issues table&lt;/a&gt; even though your server has RAM available, it&amp;rsquo;s possible you need to adjust the &lt;code&gt;swappiness&lt;/code&gt; kernel parameter. A swappiness setting of 0 prevents swap space from being used unless the server is completely out of physical memory; a setting of 100 uses swap space all the time. To check the swappiness of your kernel:</source>
          <target state="translated">Linux에서 RethinkDB를 실행 중이고 서버에 사용 가능한 RAM이 있어도 &lt;a href=&quot;../system-issues/index#memory-availability-issues&quot;&gt;시스템 문제 테이블&lt;/a&gt; 에 &quot;이 서버의 프로세스의 데이터가 스왑 메모리에 배치되었습니다.&quot;경고가 표시되는 경우 &lt;code&gt;swappiness&lt;/code&gt; 커널 매개 변수 를 조정해야 할 수 있습니다. . swappiness 설정이 0이면 서버에 물리적 메모리가 완전히 부족하지 않는 한 스왑 공간이 사용되지 않습니다. 100으로 설정하면 항상 스왑 공간을 사용합니다. 커널의 교체를 확인하려면 :</target>
        </trans-unit>
        <trans-unit id="6ff79c17332249a5d857f8a257aa944f0b925e14" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re setting up a cluster in a secure environment (for instance, the whole cluster is on a local network behind a firewall), you can simply start the servers in the cluster without an admin password, then update the &lt;code&gt;admin&lt;/code&gt; record in the &lt;code&gt;users&lt;/code&gt; table with a new password. However, if you&amp;rsquo;re joining a new server to a cluster that&amp;rsquo;s already password-protected, the best way to do it is to specify the &lt;code&gt;--initial-password auto&lt;/code&gt; option.</source>
          <target state="translated">당신이 안전한 환경에서 클러스터를 설정하는 경우, 당신은 단순히 다음 업데이트, 관리자 암호없이 클러스터의 서버를 시작할 수 있습니다 (예를 들어, 전체 클러스터는 방화벽 뒤의 로컬 네트워크에있는) &lt;code&gt;admin&lt;/code&gt; 의 기록을 새로운 비밀번호를 가진 &lt;code&gt;users&lt;/code&gt; 테이블. 그러나 이미 비밀번호로 보호 된 클러스터에 새 서버를 가입시키는 경우 가장 좋은 방법은 &lt;code&gt;--initial-password auto&lt;/code&gt; 옵션 을 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="456807bd4deabd7fb0d4e595a0e89ba5793a3a63" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re trying to run the RethinkDB JavaScript driver on an older version of Node.js, you might get an error similar to this one:</source>
          <target state="translated">Node.js의 이전 버전에서 RethinkDB JavaScript 드라이버를 실행하려고하면 다음과 유사한 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a0ba4242f24cd3660d34b716dd663972fe09358" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;a href=&quot;../changefeeds/index&quot;&gt;changefeeds&lt;/a&gt;, the proxy will de-duplicate changefeed messages sent from other cluster nodes, further reducing traffic.</source>
          <target state="translated">&lt;a href=&quot;../changefeeds/index&quot;&gt;changefeeds를&lt;/a&gt; 사용하는 경우 프록시는 다른 클러스터 노드에서 보낸 변경 피드 메시지의 중복을 제거하여 트래픽을 더욱 줄입니다.</target>
        </trans-unit>
        <trans-unit id="3b39a010075ff223dcb6231c15f5807cd083e75c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;a href=&quot;../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt;, the proxy will de-duplicate changefeed messages sent from other cluster nodes, further reducing traffic.</source>
          <target state="translated">&lt;a href=&quot;../changefeeds/javascript/index&quot;&gt;changefeeds를&lt;/a&gt; 사용하는 경우 프록시는 다른 클러스터 노드에서 전송 된 changefeed 메시지를 중복 제거하여 트래픽을 더욱 줄입니다.</target>
        </trans-unit>
        <trans-unit id="f62e60bf0cc80777903c60849396bf97f6d61d7f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using a command that returns a stream and want to retrieve all of its results at once in an array rather than iterating through them with the cursor object, you can coerce it to an array using the &lt;a href=&quot;../../../api/javascript/to_array/index&quot;&gt;toArray&lt;/a&gt; command.</source>
          <target state="translated">스트림을 리턴하는 명령을 사용하고 커서 오브젝트로 반복하지 않고 배열에서 모든 결과를 한 번에 검색하려는 경우 &lt;a href=&quot;../../../api/javascript/to_array/index&quot;&gt;toArray&lt;/a&gt; 명령을 사용하여 배열로 강제 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bacb25a3674084c03c251e600233179fe60bd947" translate="yes" xml:space="preserve">
          <source>If your Linux system uses &lt;code&gt;systemd&lt;/code&gt;, use &lt;code&gt;journalctl&lt;/code&gt; to view the log:</source>
          <target state="translated">Linux 시스템이 &lt;code&gt;systemd&lt;/code&gt; 를 사용하는 경우 &lt;code&gt;journalctl&lt;/code&gt; 을 사용 하여 로그를보십시오.</target>
        </trans-unit>
        <trans-unit id="da2db0981a7397bff51112a1fc945fe4ca7b2b8f" translate="yes" xml:space="preserve">
          <source>If your cluster has at least three servers, then in most cases RethinkDB will be able to perform automatic failover and maintain table availability.</source>
          <target state="translated">클러스터에 서버가 3 대 이상인 경우 대부분의 경우 RethinkDB는 자동 장애 조치를 수행하고 테이블 가용성을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b49541bdff3c285637a61fef077a63e1f69a37fc" translate="yes" xml:space="preserve">
          <source>If your driver uses infix notation, you must make sure that the &lt;code&gt;VAR&lt;/code&gt; term implements all the ReQL methods.</source>
          <target state="translated">드라이버가 접두사 표기법을 사용하는 경우 &lt;code&gt;VAR&lt;/code&gt; 용어가 모든 ReQL 메소드를 구현 하는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="350e9574e2ae89a26fa9dc3cc454a0ede0acc59d" translate="yes" xml:space="preserve">
          <source>If your network is open to the internet, you should take additional precautions. See the &lt;a href=&quot;../security/index&quot;&gt;security page&lt;/a&gt; for more details.</source>
          <target state="translated">네트워크가 인터넷에 연결되어 있으면 추가 예방 조치를 취해야합니다. 자세한 내용은 &lt;a href=&quot;../security/index&quot;&gt;보안 페이지&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="366849b7e0bac319320d290f73d9827bd3539c9b" translate="yes" xml:space="preserve">
          <source>If your platform isn&amp;rsquo;t listed here, you may still be able to build from source. You should be able to build RethinkDB on most Linux-based systems&amp;mdash;check out the generic &lt;a href=&quot;https://rethinkdb.com/docs/build&quot;&gt;build instructions&lt;/a&gt;. If you get RethinkDB running on your platform, please &lt;a href=&quot;https://rethinkdb.com/community&quot;&gt;contribute&lt;/a&gt; a package!</source>
          <target state="translated">귀하의 플랫폼이 여기에 나열되지 않은 경우 여전히 소스에서 빌드 할 수 있습니다. 대부분의 Linux 기반 시스템에서 RethinkDB를 빌드 할 수 있어야합니다 . 일반 &lt;a href=&quot;https://rethinkdb.com/docs/build&quot;&gt;빌드 지침을&lt;/a&gt; 확인하십시오 . 당신이 RethinkDB이 당신의 플랫폼에서 실행 얻을, 제발 &lt;a href=&quot;https://rethinkdb.com/community&quot;&gt;기여&lt;/a&gt; 패키지를!</target>
        </trans-unit>
        <trans-unit id="23b1ba702365541b74287007a736458d67c4eaea" translate="yes" xml:space="preserve">
          <source>If your program frequently executes a &lt;a href=&quot;../../../api/javascript/get_all/index&quot;&gt;getAll&lt;/a&gt; followed by a &lt;a href=&quot;../../../api/javascript/contains/index&quot;&gt;contains&lt;/a&gt;, that operation can be made more efficient by creating a compound multi index using a mapping function on the field that contains the list.</source>
          <target state="translated">프로그램이 &lt;a href=&quot;../../../api/javascript/get_all/index&quot;&gt;getAll&lt;/a&gt; 다음에 &lt;a href=&quot;../../../api/javascript/contains/index&quot;&gt;contains를&lt;/a&gt; 자주 실행하는 경우 목록이 포함 된 필드에서 맵핑 기능을 사용하여 복합 다중 색인을 작성하면 해당 조작을보다 효율적으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0f7491313b584ad1d089f9d22913b45b26e6b14" translate="yes" xml:space="preserve">
          <source>If your timestamps are stored with time zones, this query will work even if you have sales from different offices in different countries (assuming they all work 9-5 local time).</source>
          <target state="translated">타임 스탬프가 표준 시간대와 함께 저장되어있는 경우이 쿼리는 다른 국가의 다른 사무실에서 판매 한 경우에도 작동합니다 (모두 9-5 현지 시간으로 작동한다고 가정).</target>
        </trans-unit>
        <trans-unit id="6768eab9c379c5663aede0e10ef2910ddbacc359" translate="yes" xml:space="preserve">
          <source>Ignored host: (remove everything)</source>
          <target state="translated">무시 된 호스트 : (모두 제거)</target>
        </trans-unit>
        <trans-unit id="00b783520a8a2fbc5645a580ba36a3a286254053" translate="yes" xml:space="preserve">
          <source>Implementation Details</source>
          <target state="translated">구현 세부 사항</target>
        </trans-unit>
        <trans-unit id="7830d9e83bdb571cca1e50f542e8516184aeb2bf" translate="yes" xml:space="preserve">
          <source>Implementation considerations</source>
          <target state="translated">구현 고려 사항</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">구현 세부 사항</target>
        </trans-unit>
        <trans-unit id="48c76de824c667c812b20e68b2adc022b6cc3927" translate="yes" xml:space="preserve">
          <source>Implementing pagination</source>
          <target state="translated">페이지 매김 구현</target>
        </trans-unit>
        <trans-unit id="4b9473d2b75bfa42436746f65c8c33b98460fd54" translate="yes" xml:space="preserve">
          <source>Import the data into the new version of RethinkDB</source>
          <target state="translated">새로운 버전의 RethinkDB로 데이터 가져 오기</target>
        </trans-unit>
        <trans-unit id="238711b7dea1818e5597c84c0a73743721ecdeb7" translate="yes" xml:space="preserve">
          <source>Import the driver</source>
          <target state="translated">드라이버 가져 오기</target>
        </trans-unit>
        <trans-unit id="017c247df6b2b83d4d9a69a49f09f95bae03a6a1" translate="yes" xml:space="preserve">
          <source>Importing data</source>
          <target state="translated">데이터 가져 오기</target>
        </trans-unit>
        <trans-unit id="e2edf793f8ceb332bdd4099e91b0d561315566da" translate="yes" xml:space="preserve">
          <source>Importing from a directory is only supported for directories created by the &lt;code&gt;rethinkdb export&lt;/code&gt; command.</source>
          <target state="translated">디렉토리에서 가져 오기는 &lt;code&gt;rethinkdb export&lt;/code&gt; 명령으로 작성된 디렉토리에 대해서만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f1cdd2fcf75bc422b05e6de9e62859e98a52259" translate="yes" xml:space="preserve">
          <source>Importing your data</source>
          <target state="translated">데이터 가져 오기</target>
        </trans-unit>
        <trans-unit id="b2365d482c0ea18f41ce8c42a7403d51a41e4cae" translate="yes" xml:space="preserve">
          <source>Improve this doc</source>
          <target state="translated">이 문서 개선</target>
        </trans-unit>
        <trans-unit id="a2b4972775d63230221d59d42b6e919bd9b4dc33" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;saveFile&lt;/code&gt;, we pass a path to the uploaded file (which may be in a temporary storage directory, even with a temporary name depending on the uploading library we&amp;rsquo;ve used), the name to save the file with, and the id of the user who&amp;rsquo;s uploaded the file. The &lt;a href=&quot;../../../api/javascript/binary/index&quot;&gt;binary&lt;/a&gt; ReQL command is used to store the file&amp;rsquo;s contents as a binary object in the &lt;code&gt;file&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;saveFile&lt;/code&gt; 에서는 업로드 한 파일의 경로 (사용한 업로드 라이브러리에 따라 임시 이름이 있더라도 임시 저장 디렉토리에있을 수 있음), 파일을 저장할 이름 및 ID 파일을 업로드 한 사용자 &lt;a href=&quot;../../../api/javascript/binary/index&quot;&gt;진&lt;/a&gt; ReQL 명령은의 이진 개체로 파일의 내용을 저장하는 데 사용되는 &lt;code&gt;file&lt;/code&gt; 필드.</target>
        </trans-unit>
        <trans-unit id="ab75b66b21721ea02b5f1190366112cfa1b49ce9" translate="yes" xml:space="preserve">
          <source>In JavaScript you can use the operator &lt;code&gt;()&lt;/code&gt; to get the value of a field. This operator can be chained to retrieve values from nested fields.</source>
          <target state="translated">JavaScript에서는 연산자 &lt;code&gt;()&lt;/code&gt; 를 사용하여 필드 값을 얻을 수 있습니다. 이 연산자는 연결되어 중첩 된 필드에서 값을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b8d71b1ae4e957e1c701dd6a29e28ae62e6fa5a" translate="yes" xml:space="preserve">
          <source>In ReQL, you can chain commands at the end of other commands using the &lt;code&gt;.&lt;/code&gt; operator:</source>
          <target state="translated">ReQL에서는을 사용하여 다른 명령 끝에 명령을 연결할 수 있습니다 &lt;code&gt;.&lt;/code&gt; 운영자:</target>
        </trans-unit>
        <trans-unit id="d7e11373b98a35ae62612e925d7efc50e57e385c" translate="yes" xml:space="preserve">
          <source>In RethinkDB, if there is a network partition, the behavior of the system from any given client&amp;rsquo;s perspective depends on which side of the netsplit that client is on. If the client is on the same side of the netsplit as the majority of voting replicas for the shard the client is trying to reach, it will continue operating without any problems. If the client is on the side of the netsplit with half or fewer of the voting replicas for the shard the client is trying to reach, the client&amp;rsquo;s up-to-date queries and write queries will encounter a failure of availability. For example, if the client is running an up-to-date range query that spans multiple shards, the primaries for all shards must be on the same side of the netsplit as the client, or the client will encounter a failure of availability.</source>
          <target state="translated">RethinkDB에서 네트워크 파티션이있는 경우, 주어진 클라이언트 관점에서 시스템의 동작은 클라이언트가있는 netsplit의 측면에 따라 다릅니다. 클라이언트가 도달하려는 샤드에 대한 대부분의 투표 복제본과 클라이언트가 netsplit의 같은쪽에 있으면 아무런 문제없이 계속 작동합니다. 클라이언트가 도달하려는 샤드에 대한 투표 복제본의 절반 이하로 Netsplit의 측면에있는 경우 클라이언트의 최신 쿼리 및 쓰기 쿼리에 가용성 오류가 발생합니다. 예를 들어, 클라이언트가 여러 샤드에 걸쳐있는 최신 범위 쿼리를 실행중인 경우 모든 샤드의 기본 서버는 클라이언트와 동일한 넷 분할 측에 있어야합니다. 그렇지 않으면 클라이언트에 가용성 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="53975b0e82ce0d86ca8d9057bdbb663e9bcafe56" translate="yes" xml:space="preserve">
          <source>In RethinkDB, map-reduce queries operate on sequences and are composed of two or three parts:</source>
          <target state="translated">RethinkDB에서 map-reduce 쿼리는 시퀀스에서 작동하며 두 부분 또는 세 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="e547e43d492374793f980136c4cf014cfc49388d" translate="yes" xml:space="preserve">
          <source>In Ruby, you would use a block:</source>
          <target state="translated">루비에서는 다음과 같은 블록을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1f616f120c6b02696c4b0366e3aece768d2e56d2" translate="yes" xml:space="preserve">
          <source>In a many to many relation, we can use multiple &lt;code&gt;eq_join&lt;/code&gt; commands to join the data from all three tables:</source>
          <target state="translated">다 대다 관계에서 여러 &lt;code&gt;eq_join&lt;/code&gt; 명령을 사용하여 세 테이블 모두의 데이터를 조인 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8a1f7a4ae7bafa4f994ca4dcbba5e5033b936cc" translate="yes" xml:space="preserve">
          <source>In a relational database, we&amp;rsquo;d use a &lt;code&gt;JOIN&lt;/code&gt; here; in RethinkDB, we use the &lt;code&gt;eq_join&lt;/code&gt; command. To get all posts along with the author information for William Adama:</source>
          <target state="translated">관계형 데이터베이스에서는 여기 에 &lt;code&gt;JOIN&lt;/code&gt; 을 사용합니다 . RethinkDB에서는 &lt;code&gt;eq_join&lt;/code&gt; 명령 을 사용합니다 . William Adama의 저자 정보와 함께 모든 게시물을 가져 오려면 :</target>
        </trans-unit>
        <trans-unit id="0017c83cf17c2e2c74f552cbefb9d78035ec322b" translate="yes" xml:space="preserve">
          <source>In addition to commands described here, ReQL supports a number of sophisticated commands that are composable similarly to the commands described here. See the following documentation for more details:</source>
          <target state="translated">여기에 설명 된 명령 외에도 ReQL은 여기에 설명 된 명령과 유사하게 구성 할 수있는 여러 가지 정교한 명령을 지원합니다. 자세한 내용은 다음 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="69b56eab4e915ecae6acc17c1b920e1f95e8dda6" translate="yes" xml:space="preserve">
          <source>In addition to the simple &lt;code&gt;on_val&lt;/code&gt; method, you can provide methods that specifically apply to arrays, streams and atoms.</source>
          <target state="translated">간단한 &lt;code&gt;on_val&lt;/code&gt; 메소드 외에도 배열, 스트림 및 원자에 특별히 적용되는 메소드를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e832c720b5396283b4982d091435fc8a17a57bae" translate="yes" xml:space="preserve">
          <source>In addition, RethinkDB&amp;rsquo;s cursors and feeds implement an &lt;a href=&quot;../../api/javascript/ee-cursor/index&quot;&gt;EventEmitter interface&lt;/a&gt; compatible with Node&amp;rsquo;s. This allows your application to set up listeners to receive data from queries as the data becomes available.</source>
          <target state="translated">또한 RethinkDB의 커서 및 피드 는 노드와 호환 되는 &lt;a href=&quot;../../api/javascript/ee-cursor/index&quot;&gt;EventEmitter 인터페이스&lt;/a&gt; 를 구현합니다 . 이를 통해 애플리케이션은 데이터가 사용 가능 해지면 쿼리에서 데이터를 수신하도록 리스너를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac43c6179eddd9e0aa83a1d0f3a033887a74a4d9" translate="yes" xml:space="preserve">
          <source>In addition, like most NoSQL systems, RethinkDB does not support updating multiple documents atomically.</source>
          <target state="translated">또한 대부분의 NoSQL 시스템과 마찬가지로 RethinkDB는 여러 문서를 원자 적으로 업데이트하는 것을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="482ca37f4f75fe52405c7f2363070d3ac96941cf" translate="yes" xml:space="preserve">
          <source>In addition, the following two fields are set as circumstances dictate:</source>
          <target state="translated">또한 상황에 따라 다음 두 필드가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="dfeb6cb29bcc9b1be788874544634d9e422e0566" translate="yes" xml:space="preserve">
          <source>In addition, there are changefeed-specific methods that may be defined.</source>
          <target state="translated">또한 정의 할 수있는 변경 피드 별 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e9c26359d4eb826c3e725e35c3b93e27549d853" translate="yes" xml:space="preserve">
          <source>In addition, there&amp;rsquo;s a &amp;ldquo;pseudotype&amp;rdquo; called &lt;strong&gt;geometry&lt;/strong&gt; which appears in documentation, to indicate that any of the geometric objects can be used with those commands.</source>
          <target state="translated">또한, &lt;strong&gt;지오메트리&lt;/strong&gt; 라는 &quot;의사 유형&quot;이 있는데,이 명령에는 기하학적 객체를 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1d97d60a0bcfdd4c2631d5518ed2ed0252cb8e11" translate="yes" xml:space="preserve">
          <source>In an arithmetic shift (also referred to as signed shift), like a logical shift, the bits that slide off the end disappear (except for the last, which goes into the carry flag). But in an arithmetic shift, the spaces are filled in such a way to preserve the sign of the number being slid. For this reason, arithmetic shifts are better suited for signed numbers in two&amp;rsquo;s complement format.</source>
          <target state="translated">논리 시프트와 같이 산술 시프트 (부호 시프트라고도 함)에서 끝에서 미끄러지는 비트는 사라집니다 (마지막 캐리 플래그로 이동하는 마지막 비트 제외). 그러나 산술 시프트에서 공백은 미끄러지는 숫자의 부호를 보존하는 방식으로 채워집니다. 이러한 이유로 산술 시프트는 2의 보수 형식의 부호있는 숫자에 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="323e806a49b60c04ba3804b1c03762d7b82fb862" translate="yes" xml:space="preserve">
          <source>In both cases, each documents is a JSON object, bracketed with &lt;code&gt;{ }&lt;/code&gt; characters. Only the first format is itself a valid JSON document, but RethinkDB will import documents properly either way.</source>
          <target state="translated">두 경우 모두 각 문서는 &lt;code&gt;{ }&lt;/code&gt; 문자 로 묶인 JSON 객체 입니다. 첫 번째 형식 만이 유효한 JSON 문서이지만 RethinkDB는 어느 쪽이든 문서를 올바르게 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="98129ae214b9438711e0e318ef2278075825e480" translate="yes" xml:space="preserve">
          <source>In both cases, each documents is a JSON object, bracketed with &lt;code&gt;{}&lt;/code&gt; characters. Only the first format is itself a valid JSON document, but RethinkDB will import documents properly either way.</source>
          <target state="translated">두 경우 모두 각 문서는 &lt;code&gt;{}&lt;/code&gt; 문자 로 묶인 JSON 객체 입니다. 첫 번째 형식 만 유효한 JSON 문서이지만 RethinkDB는 문서를 올바르게 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="22394df195b3edd891870077561851c540a2351b" translate="yes" xml:space="preserve">
          <source>In case you found a vulnerability</source>
          <target state="translated">취약점을 발견 한 경우</target>
        </trans-unit>
        <trans-unit id="3aacc2c5441ad29368ece646c1428ab06b82d543" translate="yes" xml:space="preserve">
          <source>In case you found vulnerability or security issue in one of the drivers or the database, please do not publish it, instead, contact us via e-mail at &lt;a href=&quot;mailto:security@rethinkdb.com&quot;&gt;security@rethinkdb.com&lt;/a&gt;. We will take the necessary steps to fix the issue. We are handling the vulnerabilities privately to keep our users&amp;rsquo; data as safe as we can.</source>
          <target state="translated">드라이버 또는 데이터베이스 중 하나에서 취약점이나 보안 문제를 발견 한 경우 게시하지 말고 &lt;a href=&quot;mailto:security@rethinkdb.com&quot;&gt;security@rethinkdb.com&lt;/a&gt; 으로 이메일을 통해 당사에 문의하십시오 . 문제를 해결하기 위해 필요한 조치를 취하겠습니다. 우리는 사용자 데이터를 가능한 한 안전하게 유지하기 위해 취약점을 비공개로 처리하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="773635fe0eb58ef5487b10a80b4676b6c55ed2df" translate="yes" xml:space="preserve">
          <source>In case you have any further questions regarding vulnerability reporting, feel free to open an &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/new&quot;&gt;issue&lt;/a&gt; on GitHub.</source>
          <target state="translated">취약성보고와 관련하여 추가 질문이있는 경우 GitHub 에서 &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/new&quot;&gt;문제&lt;/a&gt; 를 열어 주시기 바랍니다 .</target>
        </trans-unit>
        <trans-unit id="b0a086d5882f5f0f06698c6203f1af04758586d8" translate="yes" xml:space="preserve">
          <source>In cases where it matters, the system should give administrators fine-tuned control, such as pinning specific primary and secondary replicas to specific servers in the cluster.</source>
          <target state="translated">중요한 경우 시스템은 관리자에게 특정 기본 및 보조 복제본을 클러스터의 특정 서버에 고정하는 등의 미세 조정 된 제어 기능을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="5b00ccdfaea40371a01b81bb7dc1bad4ad740441" translate="yes" xml:space="preserve">
          <source>In each configuration file, set a different data directory, and include the &lt;code&gt;join&lt;/code&gt; configuration option for each node with the IP address and port of another node in the cluster. If the instances are not running on the same machine, specify &lt;code&gt;bind=all&lt;/code&gt; in the configuration file (or &lt;code&gt;--bind all&lt;/code&gt; on the command line). Take care that each instance on the same machine specifies different values for &lt;code&gt;driver-port&lt;/code&gt;, &lt;code&gt;cluster-port&lt;/code&gt; and &lt;code&gt;http-port&lt;/code&gt;.</source>
          <target state="translated">각 구성 파일에서 다른 데이터 디렉토리를 설정 하고 클러스터에있는 다른 노드의 IP 주소 및 포트를 사용하여 각 노드에 대한 &lt;code&gt;join&lt;/code&gt; 구성 옵션을 포함하십시오 . 인스턴스가 동일한 시스템에서 실행되지 않는 경우 구성 파일에서 &lt;code&gt;bind=all&lt;/code&gt; 을 지정 하십시오 (또는 명령 행에서 &lt;code&gt;--bind all&lt;/code&gt; ). 동일한 시스템의 각 인스턴스가 &lt;code&gt;driver-port&lt;/code&gt; , &lt;code&gt;cluster-port&lt;/code&gt; 및 &lt;code&gt;http-port&lt;/code&gt; 에 다른 값을 지정하도록주의하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab3aa8875b25a2ffc4aedb33806133ea9bef7d9c" translate="yes" xml:space="preserve">
          <source>In general, operations on grouped streams will be efficiently distributed, and operations on grouped data won&amp;rsquo;t be. You can figure out what you&amp;rsquo;re working with by putting &lt;code&gt;typeOf&lt;/code&gt; on the end of your query. Below are efficient and inefficient examples.</source>
          <target state="translated">일반적으로 그룹화 된 스트림에 대한 작업은 효율적으로 분산되며 그룹화 된 데이터에 대한 작업은 분산되지 않습니다. 쿼리 끝에 &lt;code&gt;typeOf&lt;/code&gt; 를 넣어서 작업 내용을 파악할 수 있습니다. 아래는 효율적이고 비효율적 인 예입니다.</target>
        </trans-unit>
        <trans-unit id="f054beb39982d96498daad23e2a815f6da2c843d" translate="yes" xml:space="preserve">
          <source>In general, you&amp;rsquo;ll have to follow these steps:</source>
          <target state="translated">일반적으로 다음 단계를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="de3c73ba8ae404d459a86a8fedcb02be56388736" translate="yes" xml:space="preserve">
          <source>In its first form, &lt;code&gt;fold&lt;/code&gt; operates like &lt;a href=&quot;../reduce/index&quot;&gt;reduce&lt;/a&gt;, returning a value by applying a combining function to each element in a sequence. The combining function takes two parameters: the previous reduction result (the accumulator) and the current element. However, &lt;code&gt;fold&lt;/code&gt; has the following differences from &lt;code&gt;reduce&lt;/code&gt;:</source>
          <target state="translated">첫 번째 형태에서 &lt;code&gt;fold&lt;/code&gt; 는 &lt;a href=&quot;../reduce/index&quot;&gt;reduce&lt;/a&gt; 와 같이 작동 하여 시퀀스의 각 요소에 결합 함수를 적용하여 값을 반환합니다. 결합 기능은 이전 감소 결과 (누산기)와 현재 요소의 두 가지 매개 변수를 사용합니다. 그러나 &lt;code&gt;fold&lt;/code&gt; 에는 축소 와 다음과 같은 차이점이 &lt;code&gt;reduce&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3984a5dbbfd384237df25b964a2fe7964065b882" translate="yes" xml:space="preserve">
          <source>In its second form, &lt;code&gt;fold&lt;/code&gt; operates like &lt;a href=&quot;../concat_map/index&quot;&gt;concatMap&lt;/a&gt;, returning a new sequence rather than a single value. When an &lt;code&gt;emit&lt;/code&gt; function is provided, &lt;code&gt;fold&lt;/code&gt; will:</source>
          <target state="translated">두 번째 형식에서 &lt;code&gt;fold&lt;/code&gt; 는 &lt;a href=&quot;../concat_map/index&quot;&gt;concatMap&lt;/a&gt; 과 같이 작동 하여 단일 값이 아닌 새로운 시퀀스를 반환합니다. 때 &lt;code&gt;emit&lt;/code&gt; 기능이 제공되고, &lt;code&gt;fold&lt;/code&gt; 의지 :</target>
        </trans-unit>
        <trans-unit id="f1803506720787d5029fd735e7823ff69080cca3" translate="yes" xml:space="preserve">
          <source>In most circumstances, automatic failover can be performed as long as a majority of voting replicas are available. However, one circumstance in which it may not be performed is a non-transitive connectivity failure. Imagine a cluster with three servers: A, B, and C. Under normal network operations, all of the servers can connect to one another. If a network failure occurs such that A can connect to B and B can connect to C, but A cannot connect to C, the network failure is non-transitive. For a more in-depth description, as well as progress on a long-term solution, read &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/4357&quot;&gt;Github issue #4357&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 대부분의 투표 복제본을 사용할 수있는 한 자동 장애 조치를 수행 할 수 있습니다. 그러나 수행되지 않을 수있는 한 가지 상황은 비 일시적 연결 실패입니다. 세 개의 서버 A, B 및 C가있는 클러스터를 상상해보십시오. 정상적인 네트워크 작동 상태에서 모든 서버는 서로 연결할 수 있습니다. A가 B에 연결할 수 있고 B가 C에 연결할 수있는 네트워크 장애가 발생하는 경우 A가 C에 연결할 수없는 경우 네트워크 장애는 전이되지 않습니다. 보다 자세한 설명과 장기 솔루션의 진행 상황에 대해서는 &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/4357&quot;&gt;Github Issue # 4357을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd2d7923eb0bc8efca1cb651f85d4797323b30ae" translate="yes" xml:space="preserve">
          <source>In normal operation, &lt;code&gt;single&lt;/code&gt; read mode produces the same results as &lt;code&gt;majority&lt;/code&gt; read mode, but it might return outdated results in the event of a network failure or crash. It&amp;rsquo;s also possible that a read run in &lt;code&gt;single&lt;/code&gt; mode could return results from an incomplete write that is later rolled back.</source>
          <target state="translated">정상 작동에서 &lt;code&gt;single&lt;/code&gt; 읽기 모드는 &lt;code&gt;majority&lt;/code&gt; 읽기 모드 와 동일한 결과를 생성 하지만 네트워크 장애 나 충돌시 오래된 결과를 반환 할 수 있습니다. &lt;code&gt;single&lt;/code&gt; 모드 에서 읽기 실행을 수행 하면 나중에 롤백 된 불완전한 쓰기의 결과가 반환 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae45c6d0609936a00a819d3d51967b8a8050e205" translate="yes" xml:space="preserve">
          <source>In order to model this data we&amp;rsquo;d create three tables&amp;mdash;&lt;code&gt;authors&lt;/code&gt;, &lt;code&gt;posts&lt;/code&gt; and &lt;code&gt;authors_posts&lt;/code&gt;, similarly to how we&amp;rsquo;d do it in a relational system. Here is example data for the &lt;code&gt;authors&lt;/code&gt; table:</source>
          <target state="translated">이 데이터를 모델링하기 위해 관계형 시스템에서 수행하는 방식과 유사하게 &lt;code&gt;authors&lt;/code&gt; , &lt;code&gt;posts&lt;/code&gt; 및 &lt;code&gt;authors_posts&lt;/code&gt; 의 세 가지 테이블을 만듭니다 . 다음은 &lt;code&gt;authors&lt;/code&gt; 테이블의 데이터 예입니다 .</target>
        </trans-unit>
        <trans-unit id="97a88b12b94723a393b40b35de02068c1acae898" translate="yes" xml:space="preserve">
          <source>In other words, ReQL queries that involve multiple shards will be processed on those shards whenever possible.</source>
          <target state="translated">즉, 여러 샤드가 포함 된 ReQL 쿼리는 가능할 때마다 해당 샤드에서 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="afd135582e47c109847489d0def7f5b6eefbf292" translate="yes" xml:space="preserve">
          <source>In production, you&amp;rsquo;d likely want to specify options via configuration files rather than command line options; read the &lt;a href=&quot;../config-file/index&quot;&gt;configuration file&lt;/a&gt; documentation for details on the format and available options. Also, you&amp;rsquo;d want your RethinkDB instances to come online at system startup. See &lt;a href=&quot;../start-on-startup/index&quot;&gt;Start RethinkDB at system startup&lt;/a&gt; to learn how to set up RethinkDB with &lt;code&gt;init.d&lt;/code&gt; or &lt;code&gt;systemd&lt;/code&gt;.</source>
          <target state="translated">프로덕션 환경에서는 명령 줄 옵션이 아닌 구성 파일을 통해 옵션을 지정하려고합니다. 형식 및 사용 가능한 옵션에 대한 자세한 내용 은 &lt;a href=&quot;../config-file/index&quot;&gt;구성 파일&lt;/a&gt; 설명서를 읽으십시오 . 또한 시스템 시작시 RethinkDB 인스턴스가 온라인 상태가되기를 원합니다. &lt;code&gt;init.d&lt;/code&gt; 또는 &lt;code&gt;systemd&lt;/code&gt; 로 RethinkDB를 설정하는 방법을 배우려면 &lt;a href=&quot;../start-on-startup/index&quot;&gt;시스템 시작시 RethinkDB 시작을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0dc7c6b334bc6af46a97821423466554f645dd8" translate="yes" xml:space="preserve">
          <source>In soft durability mode RethinkDB will acknowledge the write immediately after receiving it, but before the write has been committed to disk.</source>
          <target state="translated">소프트 내구성 모드에서 RethinkDB는 쓰기를받은 직후, 쓰기가 디스크에 커밋되기 전에 쓰기를 승인합니다.</target>
        </trans-unit>
        <trans-unit id="5e7d59ad6bb744097a2528372b93cd92bdc3e075" translate="yes" xml:space="preserve">
          <source>In terms of hardware, we used the &lt;a href=&quot;https://www.rackspace.com/en-us/cloud/servers/onmetal&quot;&gt;OnMetal offerings from Rackspace&lt;/a&gt; to run both RethinkDB server and RethinkDB client nodes. We used different hardware configurations for the server and client nodes as shown below:</source>
          <target state="translated">하드웨어 측면 &lt;a href=&quot;https://www.rackspace.com/en-us/cloud/servers/onmetal&quot;&gt;에서 Rackspace&lt;/a&gt; 의 OnMetal 제품을 사용하여 RethinkDB 서버와 RethinkDB 클라이언트 노드를 모두 실행했습니다. 아래와 같이 서버 및 클라이언트 노드에 서로 다른 하드웨어 구성을 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="cb384544524d3d59795f35c682141659070ffc05" translate="yes" xml:space="preserve">
          <source>In terms of latency, we found that in a 16-node cluster and forbidding stale reads, the 95th percentile for latency is 3ms. When doing a heavy read workload, a large majority of reads fell between 0ms and 1ms which can be seen in the graph below.</source>
          <target state="translated">대기 시간 측면에서, 16 ​​노드 클러스터 및 오래된 읽기 금지에서 대기 시간의 95 번째 백분위 수는 3ms입니다. 많은 양의 읽기 작업을 수행 할 때 대부분의 읽기는 0ms에서 1ms 사이로 떨어졌으며 아래 그래프에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2a92dff43ec5bf76e7d231b5b621039bca24c72" translate="yes" xml:space="preserve">
          <source>In that example, when you&amp;rsquo;re trying to get at just one value, the JSON style doesn&amp;rsquo;t offer much advantage. But you can use it to retrieve &lt;em&gt;multiple&lt;/em&gt; values at the same nesting level. For instance, you can get just Bob&amp;rsquo;s work and cell numbers, but not home:</source>
          <target state="translated">이 예에서 단 하나의 값을 얻으려고 할 때 JSON 스타일은 큰 이점을 제공하지 않습니다. 그러나이를 사용 하여 동일한 중첩 수준에서 &lt;em&gt;여러&lt;/em&gt; 값 을 검색 할 수 있습니다 . 예를 들어, Bob의 직장과 휴대 전화 번호 만 얻을 수 있지만 집은 얻을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="aa606add1a5523e36aa8ef8f2ae241c827c85963" translate="yes" xml:space="preserve">
          <source>In the &amp;ldquo;asynchronous&amp;rdquo; test, reads use the &lt;code&gt;{readMode: &amp;rdquo;outdated&amp;rdquo;}&lt;/code&gt; setting</source>
          <target state="translated">&quot;비동기&quot;테스트에서 읽기는 &lt;code&gt;{readMode: &amp;rdquo;outdated&amp;rdquo;}&lt;/code&gt; 설정을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bf0b85b37e8a9ef902d18f0effb8b8b0a5e0b487" translate="yes" xml:space="preserve">
          <source>In the &amp;ldquo;asynchronous&amp;rdquo; test, reads use the &lt;code&gt;{readMode:&amp;rdquo;outdated&amp;rdquo;}&lt;/code&gt; setting</source>
          <target state="translated">&quot;비동기&quot;테스트에서 읽기는 &lt;code&gt;{readMode:&amp;rdquo;outdated&amp;rdquo;}&lt;/code&gt; 설정을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d386ba1cc200d80b7866a894432946f810b0b236" translate="yes" xml:space="preserve">
          <source>In the &amp;ldquo;synchronous&amp;rdquo; test, we use the default &lt;code&gt;{readMode: &amp;rdquo;single&amp;rdquo;}&lt;/code&gt; setting</source>
          <target state="translated">&quot;동기&quot;테스트에서는 기본 &lt;code&gt;{readMode: &amp;rdquo;single&amp;rdquo;}&lt;/code&gt; 설정을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="224e33b3ae99c46077d788fc2cbcfc0ec642f4c2" translate="yes" xml:space="preserve">
          <source>In the &amp;ldquo;synchronous&amp;rdquo; test, we use the default &lt;code&gt;{readMode:&amp;rdquo;single&amp;rdquo;}&lt;/code&gt; setting</source>
          <target state="translated">&quot;동기&quot;테스트에서는 기본 &lt;code&gt;{readMode:&amp;rdquo;single&amp;rdquo;}&lt;/code&gt; 설정을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d0c0068240942eeaad5904125996b7f2b3d6ea1f" translate="yes" xml:space="preserve">
          <source>In the Data Explorer, the following command will output the contents of all the configuration/status tables and the most recent 50 lines of the &lt;code&gt;logs&lt;/code&gt; table:</source>
          <target state="translated">데이터 탐색기에서 다음 명령은 모든 구성 / 상태 테이블의 내용과 &lt;code&gt;logs&lt;/code&gt; 테이블 의 최신 50 행을 출력 합니다.</target>
        </trans-unit>
        <trans-unit id="0f2e3061797f8ffc035d338c6ee005215f806609" translate="yes" xml:space="preserve">
          <source>In the ReQL API documentation and some error messages, you&amp;rsquo;ll come across terms for &amp;ldquo;data types&amp;rdquo; that are actually &lt;em&gt;classes&lt;/em&gt; of other data types.</source>
          <target state="translated">ReQL API 설명서 및 일부 오류 메시지에는 실제로 다른 데이터 유형의 &lt;em&gt;클래스&lt;/em&gt; 인 &quot;데이터 유형&quot;에 대한 용어가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8918357e3571d7f57170387ccdf371596278a850" translate="yes" xml:space="preserve">
          <source>In the ReQL API documentation you&amp;rsquo;ll also see a &amp;ldquo;pseudotype&amp;rdquo; called &lt;strong&gt;Geometry,&lt;/strong&gt; which is a collective for all of the geometry data types. Those commands will work with points, lines and polygons.</source>
          <target state="translated">ReQL API 설명서에는 &lt;strong&gt;Geometry&lt;/strong&gt; 라고하는&amp;ldquo;의사 유형&amp;rdquo;도 있습니다. 이는 모든 기하학 데이터 유형에 대한 집합입니다. 이러한 명령은 점, 선 및 다각형에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="50f6c67f7c1dbf2748240f51a04ec169aff9a6b9" translate="yes" xml:space="preserve">
          <source>In the case of nested functions, the &lt;code&gt;IMPLICIT_VAR&lt;/code&gt; term is ambiguous, and should not be used. Your driver should either throw an error or let the server return an error.</source>
          <target state="translated">중첩 함수의 경우 &lt;code&gt;IMPLICIT_VAR&lt;/code&gt; 용어는 모호하므로 사용해서는 안됩니다. 드라이버가 오류를 발생 시키거나 서버가 오류를 반환하도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="84e483a5ecf212378a48f1669d098b93f94aaf23" translate="yes" xml:space="preserve">
          <source>In the case of the first source, every database process uses memory to store intermediate results and to maintain internal state. The memory used varies significantly depending on the type of queries run and the size of documents stored in the database. As a rough estimate, expect each query and background process to use 1&amp;ndash;20 MB of memory.</source>
          <target state="translated">첫 번째 소스의 경우 모든 데이터베이스 프로세스는 메모리를 사용하여 중간 결과를 저장하고 내부 상태를 유지합니다. 사용되는 메모리는 실행되는 쿼리 유형과 데이터베이스에 저장된 문서 크기에 따라 크게 다릅니다. 대략적인 추정으로 각 쿼리 및 백그라운드 프로세스는 1-20MB의 메모리를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bcb70dff2e48b1f52037256b865f5a9417b2b37" translate="yes" xml:space="preserve">
          <source>In the form above&amp;mdash;with a block that accepts a single argument&amp;mdash;RethinkDB&amp;rsquo;s EventMachine adapter will throw errors back up to your application for you to handle in the same fashion as you would using RethinkDB without EventMachine. If the table &lt;code&gt;test&lt;/code&gt; did not exist in the database above, you would receive the standard &lt;code&gt;ReqlRunTimeError&lt;/code&gt;:</source>
          <target state="translated">RethinkDB의 EventMachine 어댑터는 위의 형식 (단일 인수를 허용하는 블록)으로 EventMachine없이 RethinkDB를 사용하는 것과 같은 방식으로 처리 할 수 ​​있도록 응용 프로그램에 오류를 다시 발생시킵니다. 위의 데이터베이스에 테이블 &lt;code&gt;test&lt;/code&gt; 가 없으면 표준 &lt;code&gt;ReqlRunTimeError&lt;/code&gt; 가 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="9ec0b06d735bfc391094860e46de01fa59f75cec" translate="yes" xml:space="preserve">
          <source>In the results, we&amp;rsquo;ll see how RethinkDB scales to perform 1.3 million individual reads per second. We will also demonstrate how RethinkDB performs well above 100 thousand operations per second in a mixed 50:50 read/write workload - while at the full level of durability and data integrity guarantees. We performed all benchmarks across a range of cluster sizes, scaling up from one to 16 nodes.</source>
          <target state="translated">결과에서 RethinkDB가 초당 130 만 개인 읽기를 수행하도록 확장되는 방법을 볼 수 있습니다. 또한 50:50 혼합 읽기 / 쓰기 워크로드에서 RethinkDB가 초당 10 만 번 이상의 작업을 수행하는 동시에 전체 수준의 내구성과 데이터 무결성을 보장하는 방법을 보여줍니다. 우리는 1 ~ 16 개의 노드로 확장하여 다양한 클러스터 크기에서 모든 벤치 마크를 수행했습니다.</target>
        </trans-unit>
        <trans-unit id="effef7fb5159ccc0efbb8a008e85c758abcdaa0d" translate="yes" xml:space="preserve">
          <source>In the second example, the two replicas in the &lt;code&gt;us&lt;/code&gt; group may be on any of the four servers in the United States.</source>
          <target state="translated">두 번째 예에서 &lt;code&gt;us&lt;/code&gt; 그룹 의 두 복제본 은 미국의 네 서버 중 하나에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd1292a9ca18510e97840764bd37257fdac0d158" translate="yes" xml:space="preserve">
          <source>In the subscribing application we need to create a queue to receive and buffer messages. The queue takes a ReQL filtering function as an argument. This is similar to what you would pass to &lt;a href=&quot;../../../api/javascript/filter/index&quot;&gt;filter&lt;/a&gt;. Here we&amp;rsquo;ll subscribe to all messages about superhero fights:</source>
          <target state="translated">구독 애플리케이션에서 메시지를 수신하고 버퍼링 할 큐를 작성해야합니다. 대기열은 ReQL 필터링 기능을 인수로 사용합니다. 이것은 &lt;a href=&quot;../../../api/javascript/filter/index&quot;&gt;필터에&lt;/a&gt; 전달할 것과 유사합니다 . 다음은 슈퍼 히어로 싸움에 대한 모든 메시지를 구독합니다.</target>
        </trans-unit>
        <trans-unit id="79b11bb5d26c6627628246b9b4da08bc855ecd84" translate="yes" xml:space="preserve">
          <source>In this case, the predicate &lt;code&gt;r.row(&quot;age&quot;).eq(30)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if the field &lt;code&gt;age&lt;/code&gt; is equal to 30. You can write this predicate as an anonymous function instead:</source>
          <target state="translated">이 경우, 술어 &lt;code&gt;r.row(&quot;age&quot;).eq(30)&lt;/code&gt; 은 필드 &lt;code&gt;age&lt;/code&gt; 가 30 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 대신이 술어를 익명 함수로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25d73c774a9ee763c700413c07c0009819356017" translate="yes" xml:space="preserve">
          <source>In this case, we would only receive notifications of fights involving a superhero. Fights between supervillains would be ignored.</source>
          <target state="translated">이 경우, 슈퍼 히어로와의 싸움에 대한 알림 만받습니다. 슈퍼 빌런들 간의 싸움은 무시 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="895f4bd40e5222929c7fb08157cbd280981cabbc" translate="yes" xml:space="preserve">
          <source>In this case, we&amp;rsquo;re using a predicate that returns &lt;code&gt;true&lt;/code&gt; only if the length of the array in the field &lt;code&gt;posts&lt;/code&gt; is greater than two. This predicate contains two commands we haven&amp;rsquo;t seen before:</source>
          <target state="translated">이 경우 필드 &lt;code&gt;posts&lt;/code&gt; 의 배열 길이 가 2보다 큰 경우에만 &lt;code&gt;true&lt;/code&gt; 를 반환하는 조건자를 사용합니다 . 이 술어에는 이전에 보지 못한 두 가지 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b372f7d94072c06cbc703d33f6f2f5eb322d59ab" translate="yes" xml:space="preserve">
          <source>In this case, you can do a pivot operation with the &lt;code&gt;group&lt;/code&gt; and &lt;code&gt;coerceTo&lt;/code&gt; commands.</source>
          <target state="translated">이 경우 &lt;code&gt;group&lt;/code&gt; 및 &lt;code&gt;coerceTo&lt;/code&gt; 명령 으로 피벗 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="932455af624242d4d4e2291c9afaaa19c3951b01" translate="yes" xml:space="preserve">
          <source>In this example, we count the number of sentences over the whole data set of 25 million documents based on one of the fields. We use the following exact query which utilizes the map and sum (reduce) functions of ReQL:</source>
          <target state="translated">이 예에서는 필드 중 하나를 기준으로 2,500 만 개의 문서 전체 데이터 세트에 대한 문장 수를 계산합니다. ReQL의 맵 및 합계 (축소) 기능을 활용하는 다음과 같은 정확한 쿼리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5a837ef70a876172728ac7037ebd677f98962f1e" translate="yes" xml:space="preserve">
          <source>In this form, the block will receive &lt;code&gt;nil&lt;/code&gt; as the first argument if there is no error. In the case of an error, the second argument will be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">이 형식에서 오류가 없으면 블록은 첫 번째 인수로 &lt;code&gt;nil&lt;/code&gt; 을 받습니다 . 오류가 발생한 경우 두 번째 인수는 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="558ef6c0550627ce8d41470ac5b93bdfb82caa5b" translate="yes" xml:space="preserve">
          <source>In this guide we look at what RethinkDB uses memory for, how we can estimate the amount needed, and how to configure the size of RethinkDB&amp;rsquo;s page cache.</source>
          <target state="translated">이 안내서에서는 RethinkDB가 메모리를 사용하는 용도, 필요한 양을 추정하는 방법 및 RethinkDB의 페이지 캐시 크기를 구성하는 방법을 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="26ea7c60ff32fa4b3e8fefeb9a9dc71af8af950d" translate="yes" xml:space="preserve">
          <source>In-depth description of the RabbitMQ model</source>
          <target state="translated">RabbitMQ 모델에 대한 자세한 설명</target>
        </trans-unit>
        <trans-unit id="e07cfb5357625f4bbae1c6809f007bdeed5bbd4c" translate="yes" xml:space="preserve">
          <source>Include OWASP link, CVE references or links to other public advisories and standards</source>
          <target state="translated">OWASP 링크, CVE 참조 또는 기타 공개 권고 및 표준에 대한 링크 포함</target>
        </trans-unit>
        <trans-unit id="6c1c63beb34300ba0d002edb636ab37ff5010363" translate="yes" xml:space="preserve">
          <source>Includes scripts for building an image for Docker with RethinkDB (and other things).</source>
          <target state="translated">RethinkDB 및 기타 사항을 사용하여 Docker의 이미지를 작성하는 스크립트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5714de2ace97726c8558fc98cd998b375aeaa197" translate="yes" xml:space="preserve">
          <source>Including initial values</source>
          <target state="translated">초기 값 포함</target>
        </trans-unit>
        <trans-unit id="0e1b750635a22beeae4a57fea2a9554b63dc760b" translate="yes" xml:space="preserve">
          <source>Including result types</source>
          <target state="translated">결과 유형 포함</target>
        </trans-unit>
        <trans-unit id="a4dfbecd4fe9a9b9f9a34ada5173cbb0a60fca4a" translate="yes" xml:space="preserve">
          <source>Including state changes</source>
          <target state="translated">상태 변경 포함</target>
        </trans-unit>
        <trans-unit id="0777c09113ddc3b67cd50cd499a4890c5b231cf0" translate="yes" xml:space="preserve">
          <source>Including the &lt;code&gt;type&lt;/code&gt; field can simplify code that handles different cases for changefeed results.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 필드를 포함하면 변경 피드 결과에 대한 다양한 사례를 처리하는 코드를 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4527e9704b753e001f3be370d293684ea1fc9ebc" translate="yes" xml:space="preserve">
          <source>Increasing the number of shards on an empty table, then using non-UUID primary keys in that table</source>
          <target state="translated">빈 테이블에서 샤드 수 늘리기 및 해당 테이블에서 UUID 이외의 기본 키 사용</target>
        </trans-unit>
        <trans-unit id="ea06f91098e8943020ff7f86773b8606b3f3f7a0" translate="yes" xml:space="preserve">
          <source>Incrementing a field value</source>
          <target state="translated">필드 값 증가</target>
        </trans-unit>
        <trans-unit id="c95a80f91577f1b4f75e07f8b821d9e8943fe898" translate="yes" xml:space="preserve">
          <source>Indexes (both secondary and primary) are guaranteed to be updated by successful write operations. If an &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt; or &lt;code&gt;delete&lt;/code&gt; operation is successful, the change will be correctly reflected in the index. (Read about RethinkDB &lt;a href=&quot;../../consistency/index&quot;&gt;Consistency guarantees&lt;/a&gt; for write operations.)</source>
          <target state="translated">쓰기 작업이 성공적으로 수행되면 인덱스 (보조 및 주)가 모두 업데이트됩니다. 는 IF &lt;code&gt;insert&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; 또는 &lt;code&gt;delete&lt;/code&gt; 작업이 성공, 변경 사항이 제대로 인덱스에 반영됩니다. ( 쓰기 작업 에 대한 RethinkDB &lt;a href=&quot;../../consistency/index&quot;&gt;일관성 보장&lt;/a&gt; 에 대해 읽으십시오 .)</target>
        </trans-unit>
        <trans-unit id="0391e1ecda549a694d60dcf43663ae1c4ada2850" translate="yes" xml:space="preserve">
          <source>Indexes based on &lt;em&gt;arbitrary expressions&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;임의의 표현&lt;/em&gt; 에 기반한 인덱스 .</target>
        </trans-unit>
        <trans-unit id="5758991da81d866c69900c0ad779d0d61274c0f9" translate="yes" xml:space="preserve">
          <source>Indexes based on &lt;strong&gt;arbitrary expressions&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;임의의 표현&lt;/strong&gt; 에 기반한 인덱스 .</target>
        </trans-unit>
        <trans-unit id="cfa5fc5368d198722219726949e2bbad91dda010" translate="yes" xml:space="preserve">
          <source>Indexes built with an older version of RethinkDB need to be rebuilt due to changes in the way ReQL handles indexing. See &amp;ldquo;&lt;a href=&quot;../troubleshooting/index#my-secondary-index-is-outdated&quot;&gt;My secondary index is outdated&lt;/a&gt;&amp;rdquo; for details on how to rebuild indexes.</source>
          <target state="translated">ReQL에서 색인 처리를 처리하는 방식이 변경되어 이전 버전의 RethinkDB로 작성된 색인을 다시 작성해야합니다. &lt;a href=&quot;../troubleshooting/index#my-secondary-index-is-outdated&quot;&gt;인덱스&lt;/a&gt; 를 다시 작성하는 방법에 대한 자세한 내용 은 &amp;ldquo; 보조 인덱스가 오래되었습니다 &amp;rdquo;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a1609b5c345fc2347a59a738ac67f1b56e06b94a" translate="yes" xml:space="preserve">
          <source>Indexes on arbitrary ReQL expressions</source>
          <target state="translated">임의의 ReQL 표현식에 대한 색인</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="043018f3a2dce17d498788f43e79b4e219d2416a" translate="yes" xml:space="preserve">
          <source>Information about the cluster and all operations on the cluster should be programmatically accessible.</source>
          <target state="translated">클러스터 및 클러스터의 모든 작업에 대한 정보는 프로그래밍 방식으로 액세스 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5abeab7792567877161cdefc7357d62712b8d656" translate="yes" xml:space="preserve">
          <source>Information about the server:</source>
          <target state="translated">서버에 대한 정보 :</target>
        </trans-unit>
        <trans-unit id="f9ec4176c4501a5a0d6dc615f46d39b3af2491e2" translate="yes" xml:space="preserve">
          <source>Initial state (&lt;code&gt;old_val&lt;/code&gt;)</source>
          <target state="translated">초기 상태 ( &lt;code&gt;old_val&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2eea430756a8711c4e7806f52c9877e92ac65847" translate="yes" xml:space="preserve">
          <source>Initial steps</source>
          <target state="translated">초기 단계</target>
        </trans-unit>
        <trans-unit id="80505361d6e27b7e0ae3d35e93853b22f2675393" translate="yes" xml:space="preserve">
          <source>Insert a value in to an array at a given index. Returns the modified array.</source>
          <target state="translated">주어진 인덱스에서 배열에 값을 삽입하십시오. 수정 된 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8eba2c9cbef2976d5ebdfcd90efdd1990cc6029" translate="yes" xml:space="preserve">
          <source>Insert data</source>
          <target state="translated">데이터 삽입</target>
        </trans-unit>
        <trans-unit id="8a47f8d72661f904ca4e211f6a9e1f8c9c152b3a" translate="yes" xml:space="preserve">
          <source>Insert documents into a table. Accepts a single document or an array of documents.</source>
          <target state="translated">문서를 테이블에 삽입하십시오. 단일 문서 또는 문서 배열을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="ac0b22d784ef13cc442529b0995c912c4dcd2b31" translate="yes" xml:space="preserve">
          <source>Insert returns an object that contains the following attributes:</source>
          <target state="translated">Insert는 다음 속성이 포함 된 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="65a6ea576f847d46029b82648e01c9ba3de063ca" translate="yes" xml:space="preserve">
          <source>Insert several values in to an array at a given index. Returns the modified array.</source>
          <target state="translated">주어진 인덱스의 배열에 여러 값을 삽입하십시오. 수정 된 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e2d0c213ca368674692f81a4b603c53678e69fc3" translate="yes" xml:space="preserve">
          <source>Inserting documents</source>
          <target state="translated">문서 삽입</target>
        </trans-unit>
        <trans-unit id="29b8d93e8ca73ad1184f047cbc37d36c670720a4" translate="yes" xml:space="preserve">
          <source>Inserting times</source>
          <target state="translated">삽입 시간</target>
        </trans-unit>
        <trans-unit id="ec5593e73134544c0d12300a4f2f2bdea2b1ab11" translate="yes" xml:space="preserve">
          <source>Instagram PubSubHubbub</source>
          <target state="translated">Instagram PubSubHubbub</target>
        </trans-unit>
        <trans-unit id="3cc343c3aa41172c7a302bc5bb30b454ee61655b" translate="yes" xml:space="preserve">
          <source>Install &lt;a href=&quot;http://rubyonrails.org/download/&quot;&gt;Ruby on Rails&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://rubyonrails.org/download/&quot;&gt;Ruby on Rails&lt;/a&gt; 설치</target>
        </trans-unit>
        <trans-unit id="eea9f12452b1397d31321dc6aae0063da202053c" translate="yes" xml:space="preserve">
          <source>Install &lt;a href=&quot;http://www.squaremobius.net/amqp.node/&quot;&gt;amqplib&lt;/a&gt;, a RabbitMQ library for NodeJS</source>
          <target state="translated">&lt;a href=&quot;http://www.squaremobius.net/amqp.node/&quot;&gt;NodeJS&lt;/a&gt; 용 RabbitMQ 라이브러리 amqplib 설치</target>
        </trans-unit>
        <trans-unit id="0e26578d0a3c30b7cc1f3e97e04029b42bb08700" translate="yes" xml:space="preserve">
          <source>Install RethinkDB</source>
          <target state="translated">RethinkDB 설치</target>
        </trans-unit>
        <trans-unit id="b6d9894293f7a4227b3086a28d9c0d307a5e6bd9" translate="yes" xml:space="preserve">
          <source>Install RethinkDB as a service for your operating system. (This document describes how to do that for both &lt;code&gt;init.d&lt;/code&gt; and &lt;code&gt;systemd&lt;/code&gt;-based Linux distributions, as well as OS X using &lt;code&gt;launchd&lt;/code&gt; and Windows services. Depending on how you&amp;rsquo;ve installed RethinkDB, this may already be done for you.)</source>
          <target state="translated">운영 체제에 대한 서비스로 RethinkDB를 설치하십시오. (이 문서는 &lt;code&gt;init.d&lt;/code&gt; 및 &lt;code&gt;systemd&lt;/code&gt; 기반 Linux 배포판 과 &lt;code&gt;launchd&lt;/code&gt; 및 Windows 서비스를 사용 하는 OS X 모두에 대해이를 수행하는 방법을 설명합니다 . RethinkDB를 설치 한 방법에 따라이 작업이 이미 수행되었을 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="32dacb2f0cddc3948aa2de26d4c1fa81e213e4a7" translate="yes" xml:space="preserve">
          <source>Install RethinkDB as a service for your operating system. (This document describes how to do that for both &lt;code&gt;init.d&lt;/code&gt; and &lt;code&gt;systemd&lt;/code&gt;-based Linux distributions, as well as OS X using &lt;code&gt;launchd&lt;/code&gt;. Depending on how you&amp;rsquo;ve installed RethinkDB, this may already be done for you.)</source>
          <target state="translated">운영 체제에 대한 서비스로 RethinkDB를 설치하십시오. (이 문서는 &lt;code&gt;init.d&lt;/code&gt; 및 &lt;code&gt;systemd&lt;/code&gt; 기반 Linux 배포판과 &lt;code&gt;launchd&lt;/code&gt; 를 사용하여 OS X 모두에서 수행하는 방법을 설명합니다 . RethinkDB 설치 방법에 따라 이미 완료되었을 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="2df8530df735797a29fd92fab10ddfe7b16aedf6" translate="yes" xml:space="preserve">
          <source>Install client drivers</source>
          <target state="translated">클라이언트 드라이버 설치</target>
        </trans-unit>
        <trans-unit id="01fd635cf310ad64f3e1b1f64648e6ae28c17133" translate="yes" xml:space="preserve">
          <source>Install the server</source>
          <target state="translated">서버 설치</target>
        </trans-unit>
        <trans-unit id="828b11b9132aed05b6b796b08db5481e6d19dd3e" translate="yes" xml:space="preserve">
          <source>Installing RethinkDB</source>
          <target state="translated">RethinkDB 설치</target>
        </trans-unit>
        <trans-unit id="f0813a11b71d8a038d4b80014edfc9b3a6adf95c" translate="yes" xml:space="preserve">
          <source>Installing RethinkDB client drivers</source>
          <target state="translated">RethinkDB 클라이언트 드라이버 설치</target>
        </trans-unit>
        <trans-unit id="25698238529e36c36bbff9a1cf8864afeb7e862b" translate="yes" xml:space="preserve">
          <source>Installing from source</source>
          <target state="translated">소스에서 설치</target>
        </trans-unit>
        <trans-unit id="66166bdf5a5269039901f352cb2db046575a54fa" translate="yes" xml:space="preserve">
          <source>Installing on other platforms</source>
          <target state="translated">다른 플랫폼에 설치</target>
        </trans-unit>
        <trans-unit id="333df51781cc357460f2c635fe316602326864a3" translate="yes" xml:space="preserve">
          <source>Instance administration</source>
          <target state="translated">인스턴스 관리</target>
        </trans-unit>
        <trans-unit id="4319f262417314ad390a0bffe2a7838f08952aea" translate="yes" xml:space="preserve">
          <source>Instead of using the &lt;code&gt;default&lt;/code&gt; optional argument to &lt;code&gt;filter&lt;/code&gt;, we have to use default values on the fields within the &lt;code&gt;or&lt;/code&gt; clause. Why? If the field on the left side of the &lt;code&gt;or&lt;/code&gt; clause is missing from a document&amp;mdash;in this case, if the user doesn&amp;rsquo;t have a &lt;code&gt;role&lt;/code&gt; field&amp;mdash;the predicate will generate an error, and will return &lt;code&gt;false&lt;/code&gt; (or the value the &lt;code&gt;default&lt;/code&gt; argument is set to) without evaluating the right side of the &lt;code&gt;or&lt;/code&gt;. By using &lt;code&gt;.default(false)&lt;/code&gt; on the fields, each side of the &lt;code&gt;or&lt;/code&gt; will evaluate to either the field&amp;rsquo;s value or &lt;code&gt;false&lt;/code&gt; if the field doesn&amp;rsquo;t exist.</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; 을 위해 &lt;code&gt;default&lt;/code&gt; 선택적 인수를 사용하는 대신 &lt;code&gt;or&lt;/code&gt; 절의 필드에서 기본값을 사용해야합니다 . 왜? &lt;code&gt;or&lt;/code&gt; 절의 왼쪽에있는 필드 가 문서에서 누락 된 경우 (이 경우 사용자에게 &lt;code&gt;role&lt;/code&gt; 필드 가없는 경우) 술어는 오류를 생성하고 &lt;code&gt;false&lt;/code&gt; (또는 &lt;code&gt;default&lt;/code&gt; 인수 값)를 리턴 합니다. &lt;code&gt;or&lt;/code&gt; 의 오른쪽을 평가하지 않고로 설정됩니다 . 필드에서 &lt;code&gt;.default(false)&lt;/code&gt; 를 사용 하면 &lt;code&gt;or&lt;/code&gt; 각면이 필드 값으로 평가되거나 필드가 존재하지 않으면 &lt;code&gt;false&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="edcb8acb99853d0a5ef2bb5e68e942595143f90e" translate="yes" xml:space="preserve">
          <source>Integrating Elasticsearch</source>
          <target state="translated">Elasticsearch 통합</target>
        </trans-unit>
        <trans-unit id="8dbfed65b5b9df99b02a2d3fc9690365cea617b8" translate="yes" xml:space="preserve">
          <source>Integrating RabbitMQ</source>
          <target state="translated">RabbitMQ 통합</target>
        </trans-unit>
        <trans-unit id="081430b73c2092922b1df2dd3a411dc9f24c47e1" translate="yes" xml:space="preserve">
          <source>Integrating RethinkDB with RabbitMQ</source>
          <target state="translated">RabbitMQ와 RethinkDB 통합</target>
        </trans-unit>
        <trans-unit id="a7881cac6e64abca5eafd172df6eb31fe0b84c88" translate="yes" xml:space="preserve">
          <source>Integrations</source>
          <target state="translated">Integrations</target>
        </trans-unit>
        <trans-unit id="796755669082ff5596709d22781a79a1f59e5527" translate="yes" xml:space="preserve">
          <source>Intel Xeon E5-2680 v2 CPU 2.8 GHz (10 cores)</source>
          <target state="translated">Intel Xeon E5-2680 v2 CPU 2.8GHz (10 코어)</target>
        </trans-unit>
        <trans-unit id="873fde3ef086eae1a20c3748b3a65e16d5a254b8" translate="yes" xml:space="preserve">
          <source>Internal metadata</source>
          <target state="translated">내부 메타 데이터</target>
        </trans-unit>
        <trans-unit id="cc2de5d3fe42b60664127c2656b7a7a0b43b73c3" translate="yes" xml:space="preserve">
          <source>Internally this approach is more difficult to implement than the more commonly used consistent hashing, but it has significant advantages because it allows for an efficient implementation of range queries.</source>
          <target state="translated">내부적으로이 방법은 일반적으로 사용되는 일관된 해시보다 구현하기가 어렵지만 범위 쿼리를 효율적으로 구현할 수 있기 때문에 큰 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="110fc7f6ed7d04de80c4765c8e43e4f598bb28eb" translate="yes" xml:space="preserve">
          <source>Internally, compound indexes and simple indexes are the same type of index in RethinkDB; compound indexes are simply a special case of regular index that returns an array rather than a single value.</source>
          <target state="translated">내부적으로 복합 인덱스와 단순 인덱스는 RethinkDB에서 동일한 유형의 인덱스입니다. 복합 인덱스는 단순히 단일 값이 아닌 배열을 반환하는 일반 인덱스의 특수한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="56880de82bcea48ab8325b91afa2386b2d395979" translate="yes" xml:space="preserve">
          <source>Internally, compound indexes and simple indexes are the same type of index in RethinkDB; compound indexes are simply a special case of regular index that returns an array rather than a single value. Note that this affects sorting: compound index values are sorted lexicographically, with the first (leftmost) elements of the compound value being more significant than the last (rightmost) ones. Therefore, using the &lt;code&gt;full_name&lt;/code&gt; index, the above example &amp;ldquo;all users whose last name is Smith&amp;rdquo; only works for the &lt;code&gt;last_name&lt;/code&gt; field. Searching by &lt;code&gt;first_name&lt;/code&gt; with a query like &lt;code&gt;between([r.minval, &quot;John&quot;], [r.maxval, &quot;John&quot;], {index: &quot;full_name&quot;})&lt;/code&gt; would effectively select &lt;em&gt;every&lt;/em&gt; user in the table, except (theoretically) users that have &lt;code&gt;r.minval&lt;/code&gt; as last name and a first name lexicographically smaller than &amp;ldquo;John&amp;rdquo; (or the reverse for &lt;code&gt;r.maxval&lt;/code&gt;).</source>
          <target state="translated">내부적으로 복합 인덱스와 단순 인덱스는 RethinkDB에서 동일한 유형의 인덱스입니다. 복합 인덱스는 단일 값이 아닌 배열을 반환하는 일반 인덱스의 특별한 경우입니다. 이는 정렬에 영향을줍니다. 복합 인덱스 값은 사전 순으로 정렬되며 복합 값의 첫 번째 (가장 왼쪽) 요소가 마지막 (가장 오른쪽) 요소보다 더 중요합니다. 따라서 &lt;code&gt;full_name&lt;/code&gt; 인덱스를 사용하면 위의 &quot;성이 Smith 인 모든 사용자&quot;예제는 &lt;code&gt;last_name&lt;/code&gt; 필드 에서만 작동 합니다. 에 의해 검색 &lt;code&gt;first_name&lt;/code&gt; 같은 쿼리와 &lt;code&gt;between([r.minval, &quot;John&quot;], [r.maxval, &quot;John&quot;], {index: &quot;full_name&quot;})&lt;/code&gt; 효율적으로 선택 할 &lt;em&gt;때마다를&lt;/em&gt;사용자는 (이론적으로) &lt;code&gt;r.minval&lt;/code&gt; 이 성이고 사 전적으로 &quot;John&quot;보다 작은 이름 (또는 &lt;code&gt;r.maxval&lt;/code&gt; 의 반대)을 가진 사용자를 제외합니다.</target>
        </trans-unit>
        <trans-unit id="016355aa2cdbc678752876dfc6bd8a8f0e33fcf6" translate="yes" xml:space="preserve">
          <source>Internally, queries are represented as trees. A query of:</source>
          <target state="translated">내부적으로 쿼리는 트리로 표시됩니다. 다음에 대한 쿼리 :</target>
        </trans-unit>
        <trans-unit id="3c0f8a211170bbe9fd74bfe3fb9d32dca2499482" translate="yes" xml:space="preserve">
          <source>Intersect two arrays returning values that occur in both of them as a set (an array with distinct values).</source>
          <target state="translated">두 배열 모두에서 발생하는 값을 집합 (고유 한 값을 가진 배열)으로 반환하는 두 배열을 교차시킵니다.</target>
        </trans-unit>
        <trans-unit id="1df374766527b0942d46def76ff145106af94c20" translate="yes" xml:space="preserve">
          <source>Introduction to Joins</source>
          <target state="translated">조인 소개</target>
        </trans-unit>
        <trans-unit id="886e399859534e91e45eb866e28bb27d1c8ebef9" translate="yes" xml:space="preserve">
          <source>Introduction to ReQL</source>
          <target state="translated">ReQL 소개</target>
        </trans-unit>
        <trans-unit id="c861239c228b921387ace53d3216eff7ae8989a1" translate="yes" xml:space="preserve">
          <source>Introduction to map-reduce</source>
          <target state="translated">지도 축소 소개</target>
        </trans-unit>
        <trans-unit id="abbf10e2c10be16cbb5de69a08a9647bc4b8886f" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;tableCreate&lt;/code&gt; without specifying a database using &lt;a href=&quot;../db/index&quot;&gt;db&lt;/a&gt; creates a table in the database specified in &lt;a href=&quot;../connect/index&quot;&gt;connect&lt;/a&gt;, or &lt;code&gt;test&lt;/code&gt; if no database was specified.</source>
          <target state="translated">호출 &lt;code&gt;tableCreate&lt;/code&gt; 을 사용하여 데이터베이스 지정하지 않고 &lt;a href=&quot;../db/index&quot;&gt;DB하기&lt;/a&gt; 에 지정된 데이터베이스에서 테이블을 만들어 &lt;a href=&quot;../connect/index&quot;&gt;연결&lt;/a&gt; 하거나 &lt;code&gt;test&lt;/code&gt; 에는 데이터베이스가 지정되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="2e984013c5e5d72e6ebe438bef7ce2e2e4fb1ca3" translate="yes" xml:space="preserve">
          <source>Invoking this functionality automatically without the user&amp;rsquo;s request is the next layer in this hierarchy. Currently the user can control the system via the web UI, manually via the command line, or by writing scripts to call the command line tools to perform server automation.</source>
          <target state="translated">사용자의 요청없이이 기능을 자동으로 호출하는 것이이 계층의 다음 계층입니다. 현재 사용자는 웹 UI를 통해, 명령 줄을 통해 수동으로 또는 스크립트를 작성하여 명령 줄 도구를 호출하여 서버 자동화를 수행하여 시스템을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3648c9e586da9da329d881f9456ad5f94947161e" translate="yes" xml:space="preserve">
          <source>Is RethinkDB immediately or eventually consistent?</source>
          <target state="translated">RethinkDB가 즉시 또는 결국 일관성이 있습니까?</target>
        </trans-unit>
        <trans-unit id="4345620dde11a944cdd9bd27934184533e094c4e" translate="yes" xml:space="preserve">
          <source>Is preferable to this query:</source>
          <target state="translated">이 쿼리보다 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="2425127c8709646f155c07fc3ff2d5c6988816eb" translate="yes" xml:space="preserve">
          <source>Is the crash reproducible, and if so, under what conditions?</source>
          <target state="translated">충돌은 어떤 상황에서 재현 가능합니까?</target>
        </trans-unit>
        <trans-unit id="6e1cb81d9e26a4f9b860dc2a2fd2ba2b29daee20" translate="yes" xml:space="preserve">
          <source>Issue types</source>
          <target state="translated">문제 유형</target>
        </trans-unit>
        <trans-unit id="f03aac29f543ef0de44fcdf77a29c785765deb8a" translate="yes" xml:space="preserve">
          <source>Issues added to the table follow the same structure.</source>
          <target state="translated">표에 추가 된 문제는 동일한 구조를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="b48c8924e7f87f4c696bb70c6d06139c134e96ed" translate="yes" xml:space="preserve">
          <source>It also returns results ordered from most relevant to least, not worrying about small differences. Say you want to ask the question: &amp;ldquo;What documents best match the phrase &amp;lsquo;Holy guacamole, Batman&amp;rsquo;?&amp;rdquo; If the hoped-for guacamole reference isn&amp;rsquo;t found, a full-text search should reply with documents containing good matches like &amp;ldquo;Holy smokes, Batman!&amp;rdquo; and &amp;ldquo;Holy armadillo, Batman!&amp;rdquo; In short, you should be using a full-text search database like Elasticsearch if you find yourself writing convoluted regular expressions to grep through big text fields.</source>
          <target state="translated">또한 작은 차이에 대해 걱정하지 않고 가장 관련성이 높은 순서대로 결과를 반환합니다. &quot;어떤 문서가 '신성한 아보카도 몰리, 배트맨'이라는 문구와 가장 잘 어울 립니까?&quot; 원하는 아보카도 소스 참조를 찾을 수없는 경우 전체 텍스트 검색은 &quot;Holy smokes, Batman!&quot;과 같은 일치 항목이 포함 된 문서로 회신해야합니다. 그리고 &quot;거룩한 아르마딜로, 배트맨!&quot; 즉, 큰 텍스트 필드를 통해 grep하기 위해 복잡한 정규식을 작성하는 경우 Elasticsearch와 같은 전체 텍스트 검색 데이터베이스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7f292e66c309fe4cd3fbb49b33a11a9a27f61fc" translate="yes" xml:space="preserve">
          <source>It relies on the underlying storage system to ensure data consistency. RethinkDB does not perform additional checksums on stored data. It is, however, compatible with file systems which do guarantee data integrity, such as ZFS.</source>
          <target state="translated">데이터 일관성을 보장하기 위해 기본 스토리지 시스템에 의존합니다. RethinkDB는 저장된 데이터에 대해 추가 체크섬을 수행하지 않습니다. 그러나 ZFS와 같이 데이터 무결성을 보장하는 파일 시스템과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="0308bae19734e53e8eeb8fc72417975f82b4d057" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a common pattern in some query interfaces to &amp;ldquo;build&amp;rdquo; queries programmatically by instantiating a query object, calling it several times in succession to add query commands, then calling the execution command. This lets you dynamically change the query based on conditions at runtime. You might expect to do this in ReQL like so:</source>
          <target state="translated">쿼리 개체를 인스턴스화하고 쿼리 명령을 추가하기 위해 여러 번 호출 한 다음 실행 명령을 호출하여 프로그래밍 방식으로 쿼리를 &quot;빌드&quot;하는 것이 일부 쿼리 인터페이스에서 일반적인 패턴입니다. 이를 통해 런타임시 조건에 따라 쿼리를 동적으로 변경할 수 있습니다. ReQL에서 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43d263475c984dca5d502747655b9f006256096e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a common task for web applications to accept file uploads from users; with RethinkDB you can store these files directly in the database.</source>
          <target state="translated">웹 응용 프로그램이 사용자의 파일 업로드를 허용하는 일반적인 작업입니다. RethinkDB를 사용하면 이러한 파일을 데이터베이스에 직접 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4df14c095e2e2a042484762e7fae65618dd20e3e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a natural and convenient way to express queries.</source>
          <target state="translated">자연스럽고 편리한 쿼리 표현 방법입니다.</target>
        </trans-unit>
        <trans-unit id="cd366d6aeb93bc8ec97f59c94513521c61f160c9" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible for this error to be caused by a circular reference, where a document inadvertently contains itself:</source>
          <target state="translated">문서에 실수로 포함 된 순환 참조로 인해이 오류가 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e119ec402d3bfe01c9d4e90058826653b70f9ef" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to use RethinkDB with Ruby on Rails. This guide assumes some familiarity with Rails and ActiveRecord. We&amp;rsquo;ll be using &lt;a href=&quot;http://nobrainer.io&quot;&gt;NoBrainer&lt;/a&gt;&amp;mdash;a RethinkDB ORM, which is an almost drop-in replacement for ActiveRecord.</source>
          <target state="translated">Ruby on Rails와 함께 RethinkDB를 사용하는 것은 쉽습니다. 이 가이드는 Rails와 ActiveRecord에 어느 정도 익숙하다고 가정합니다. 우리는 &lt;a href=&quot;http://nobrainer.io&quot;&gt;NoBrainer를&lt;/a&gt; 사용할 것입니다 &amp;ndash; RethinkDB ORM은 ActiveRecord를 거의 대체하는 대체품입니다.</target>
        </trans-unit>
        <trans-unit id="30747a6d28762ec1343765ae06483c010e675643" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to increment a field value in a document&amp;mdash;for example, a counter&amp;mdash;in one step on the server.</source>
          <target state="translated">서버의 한 단계에서 문서 (예 : 카운터)의 필드 값을 증가시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1c38f29865ef6022444784351ea37ca314feb8c" translate="yes" xml:space="preserve">
          <source>JOINS</source>
          <target state="translated">JOINS</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="be4521311d0f547ae040a777490a7694a57f7b10" translate="yes" xml:space="preserve">
          <source>JSON files are preferred to CSV files, as JSON can represent RethinkDB documents fully. If you&amp;rsquo;re importing from a CSV file, you should include a header row with the field names, or use the &lt;code&gt;--no-header&lt;/code&gt; option with the &lt;code&gt;--custom-header&lt;/code&gt; option to specify the names.</source>
          <target state="translated">JSON은 RethinkDB 문서를 완전히 나타낼 수 있으므로 JSON 파일은 CSV 파일보다 선호됩니다. CSV 파일에서 가져 오는 경우 필드 이름과 함께 헤더 행을 포함하거나 &lt;code&gt;--custom-header&lt;/code&gt; 옵션 과 함께 &lt;code&gt;--no-header&lt;/code&gt; -header 옵션을 사용하여 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e027e57610f85225767aafbbf23fed7457e55828" translate="yes" xml:space="preserve">
          <source>Java</source>
          <target state="translated">Java</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="2150136b161bb7f3850c20f55af98f5e50de8133" translate="yes" xml:space="preserve">
          <source>JavaScript ORM for RethinkDB.</source>
          <target state="translated">RethinkDB 용 JavaScript ORM</target>
        </trans-unit>
        <trans-unit id="2a15a5b5017d006df320fa6b8ac5c83f39e3e070" translate="yes" xml:space="preserve">
          <source>JavaScript ReQL command reference</source>
          <target state="translated">JavaScript ReQL 명령 참조</target>
        </trans-unit>
        <trans-unit id="12bfad731fd2da7fcf4e3ba16201bc4b30c542f9" translate="yes" xml:space="preserve">
          <source>JavaScript driver with Node.js</source>
          <target state="translated">Node.js가 포함 된 JavaScript 드라이버</target>
        </trans-unit>
        <trans-unit id="c5b67826a8b2b2a28d0ea2896c58630359061683" translate="yes" xml:space="preserve">
          <source>JavaScript has no native iterator, but ReQL implements an &lt;a href=&quot;../../api/javascript/each/index&quot;&gt;each&lt;/a&gt; command similar to &lt;a href=&quot;http://api.jquery.com/each/&quot;&gt;jQuery&lt;/a&gt;&amp;rsquo;s.</source>
          <target state="translated">JavaScript에는 기본 반복자가 없지만 ReQL 은 &lt;a href=&quot;http://api.jquery.com/each/&quot;&gt;jQuery&lt;/a&gt; 와 유사한 &lt;a href=&quot;../../api/javascript/each/index&quot;&gt;각&lt;/a&gt; 명령을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="437736fdb5bb707abdc048483193c86b9a99983e" translate="yes" xml:space="preserve">
          <source>Jobs</source>
          <target state="translated">Jobs</target>
        </trans-unit>
        <trans-unit id="7bb6a0357b0f1772fd50b7f8539ec577ed6f6748" translate="yes" xml:space="preserve">
          <source>Join tables using a field or function on the left-hand sequence matching primary keys or secondary indexes on the right-hand table. &lt;code&gt;eqJoin&lt;/code&gt; is more efficient than other ReQL join types, and operates much faster. Documents in the result set consist of pairs of left-hand and right-hand documents, matched when the field on the left-hand side exists and is non-null and an entry with that field&amp;rsquo;s value exists in the specified index on the right-hand side.</source>
          <target state="translated">오른쪽 테이블의 기본 키 또는 보조 인덱스와 일치하는 왼쪽 시퀀스의 필드 또는 함수를 사용하여 테이블을 조인하십시오. &lt;code&gt;eqJoin&lt;/code&gt; 은 다른 ReQL 조인 유형보다 효율적이며 훨씬 빠르게 작동합니다. 결과 집합의 문서는 왼쪽 및 오른쪽 문서 쌍으로 구성되며, 왼쪽 필드가 존재하고 널이 아니며 해당 필드 값을 가진 항목이 오른쪽의 지정된 색인에 존재할 때 일치합니다. 손 쪽.</target>
        </trans-unit>
        <trans-unit id="442e9473c8c4abf9dfcae036af694232b5434ef9" translate="yes" xml:space="preserve">
          <source>Join these tables using &lt;code&gt;gameId&lt;/code&gt; on the player table and &lt;code&gt;id&lt;/code&gt; on the games table:</source>
          <target state="translated">player 테이블에서 &lt;code&gt;gameId&lt;/code&gt; 를 사용 하고 games 테이블에서 &lt;code&gt;id&lt;/code&gt; 를 사용하여 다음 테이블을 조인 하십시오.</target>
        </trans-unit>
        <trans-unit id="3b2597a987d6f7990bcc2736d74772e6aaab9771" translate="yes" xml:space="preserve">
          <source>Joining multiple changefeeds into one</source>
          <target state="translated">여러 개의 변경 피드를 하나로 결합</target>
        </trans-unit>
        <trans-unit id="36cb6826dbbbacc9f0915d9e44ccb82925b04c72" translate="yes" xml:space="preserve">
          <source>Joins</source>
          <target state="translated">Joins</target>
        </trans-unit>
        <trans-unit id="614248f657c4cd869544f362220155e71e70a6d3" translate="yes" xml:space="preserve">
          <source>Jump into the &lt;a href=&quot;../../cookbook/javascript/index&quot;&gt;cookbook&lt;/a&gt; and browse through dozens of examples of common RethinkDB queries.</source>
          <target state="translated">로 이동 &lt;a href=&quot;../../cookbook/javascript/index&quot;&gt;요리 책&lt;/a&gt; 및 일반 RethinkDB 쿼리의 예를 수십을 찾아.</target>
        </trans-unit>
        <trans-unit id="cadea68a130fb4da345a2bd00c5bc5ec1fdab118" translate="yes" xml:space="preserve">
          <source>Jump into the &lt;a href=&quot;../cookbook/javascript/index&quot;&gt;cookbook&lt;/a&gt; and see dozens of examples of common RethinkDB queries.</source>
          <target state="translated">로 이동 &lt;a href=&quot;../cookbook/javascript/index&quot;&gt;요리 책&lt;/a&gt; 및 일반 RethinkDB 쿼리의 예를 수십를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="815740848353ae01fefc9bf1699f34710f065f60" translate="yes" xml:space="preserve">
          <source>Just in case you needed another calculator, ReQL can do that too!</source>
          <target state="translated">다른 계산기가 필요한 경우 ReQL도 그렇게 할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="df1556914f9d65ff6bb135e1e34b460926c8b594" translate="yes" xml:space="preserve">
          <source>Just like other ReQL indexes, you can create an index using an anonymous function rather than a simple field name, as well as create multi indexes by using the &lt;code&gt;multi&lt;/code&gt; flag with &lt;code&gt;geo&lt;/code&gt;. Read the &lt;a href=&quot;../../../api/javascript/index_create/index&quot;&gt;indexCreate&lt;/a&gt; API documentation for more details.</source>
          <target state="translated">다른 ReQL 색인과 마찬가지로 간단한 필드 이름이 아닌 익명 함수를 사용하여 색인을 작성 하고 &lt;code&gt;geo&lt;/code&gt; 와 함께 &lt;code&gt;multi&lt;/code&gt; 플래그를 사용하여 다중 색인을 작성할 수 있습니다 . 자세한 내용 은 &lt;a href=&quot;../../../api/javascript/index_create/index&quot;&gt;indexCreate&lt;/a&gt; API 설명서를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="2d5bfabcb6bca6d271e3af0b81998719a3d8e256" translate="yes" xml:space="preserve">
          <source>Koa</source>
          <target state="translated">Koa</target>
        </trans-unit>
        <trans-unit id="0cd80e0b1a0d9ca537de8880c046d1db4c5bba77" translate="yes" xml:space="preserve">
          <source>Koa middleware that automatically manages connections via a connection pool.</source>
          <target state="translated">연결 풀을 통해 연결을 자동으로 관리하는 Koa 미들웨어.</target>
        </trans-unit>
        <trans-unit id="26fad106569fcec275e401a5f8f426bcdc4c1a5d" translate="yes" xml:space="preserve">
          <source>Lambda functions in RethinkDB</source>
          <target state="translated">RethinkDB의 Lambda 함수</target>
        </trans-unit>
        <trans-unit id="b3efedc3036d62c6e9695305d32c2033a97f6fed" translate="yes" xml:space="preserve">
          <source>Larger documents of more than 250 bytes are stored in blocks of their own. Documents up to 4 KB use a single block; larger documents are split across multiple blocks as needed.</source>
          <target state="translated">250 바이트가 넘는 큰 문서는 자체 블록에 저장됩니다. 최대 4KB의 문서는 단일 블록을 사용합니다. 더 큰 문서는 필요에 따라 여러 블록으로 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="5d9c8282669843d174d46b5ef2c7b930b7ff91c0" translate="yes" xml:space="preserve">
          <source>Lastly, we call &lt;code&gt;run(connection, callback)&lt;/code&gt; in order to send the query to the server.</source>
          <target state="translated">마지막으로 서버에 쿼리를 보내기 위해 &lt;code&gt;run(connection, callback)&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="b593864b68f106789807303bd0cf74356e8e4ff9" translate="yes" xml:space="preserve">
          <source>Latency is also an important metric to measure when testing performance. We found that in a 16-node cluster, the 95th percentile for Workload A query latencies is 26ms.</source>
          <target state="translated">지연 시간은 성능 테스트시 측정 할 중요한 지표입니다. 16 노드 클러스터에서 Workload A 쿼리 대기 시간의 95 번째 백분위 수는 26ms입니다.</target>
        </trans-unit>
        <trans-unit id="ec18da38841bcc22e0215d72fe5f8195fe0cb024" translate="yes" xml:space="preserve">
          <source>Launching an instance</source>
          <target state="translated">인스턴스 시작</target>
        </trans-unit>
        <trans-unit id="cde4c57577148cb7290eeb61254becb94294e003" translate="yes" xml:space="preserve">
          <source>Lazily iterate over a cursor, array, or feed one element at a time. &lt;code&gt;eachAsync&lt;/code&gt; always returns a promise that will be resolved once all rows are returned.</source>
          <target state="translated">한 번에 한 요소 씩 커서, 배열 또는 피드를 느리게 반복합니다. &lt;code&gt;eachAsync&lt;/code&gt; 는 항상 모든 행이 반환되면 해결 될 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7580d3d26925e442143c501474aa5ee2f4ba2239" translate="yes" xml:space="preserve">
          <source>Lazily iterate over the result set one element at a time. The second callback is optional and is called when the iteration stops (when there are no more rows or when the callback returns &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">한 번에 한 요소 씩 결과 집합을 느리게 반복합니다. 두 번째 콜백은 선택 사항이며 반복이 중지되면 (더 이상 행이 없거나 콜백이 &lt;code&gt;false&lt;/code&gt; 를 반환 할 때 ) 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="882d7824546e260d7aecb582ca23a9e9525d35d8" translate="yes" xml:space="preserve">
          <source>Laziness</source>
          <target state="translated">Laziness</target>
        </trans-unit>
        <trans-unit id="119a27138fe3d276ec8a407746eb7af54a9639ef" translate="yes" xml:space="preserve">
          <source>Leap-seconds aren&amp;rsquo;t well-supported right now: &lt;code&gt;2012-06-30T23:59:60&lt;/code&gt; and &lt;code&gt;2012-07-01T00:00:00&lt;/code&gt; parse to the same time.</source>
          <target state="translated">윤초는 현재 잘 지원되지 않습니다 : &lt;code&gt;2012-06-30T23:59:60&lt;/code&gt; 및 &lt;code&gt;2012-07-01T00:00:00&lt;/code&gt; 동시에 구문 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="7352c39338b0f7491547ec046eb62e590d5666fa" translate="yes" xml:space="preserve">
          <source>Learn about changefeeds, RethinkDB's realtime push technology, and how it can be used to build and scale realtime apps.</source>
          <target state="translated">변경 사항, RethinkDB의 실시간 푸시 기술 및 실시간 앱 구축 및 확장에 어떻게 사용될 수 있는지에 대해 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="053b8690ab05d3886d2e0a4df01379bf8f5f5878" translate="yes" xml:space="preserve">
          <source>Learn how to deploy RethinkDB on cloud services like Compose.io, AWS, and others.</source>
          <target state="translated">Compose.io, AWS 등의 클라우드 서비스에 RethinkDB를 배포하는 방법에 대해 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="4008d50d045acf61774875510316c96f31310945" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;a href=&quot;../../map-reduce/index&quot;&gt;map-reduce&lt;/a&gt; in RethinkDB.</source>
          <target state="translated">RethinkDB에서 &lt;a href=&quot;../../map-reduce/index&quot;&gt;map-reduce&lt;/a&gt; 를 사용하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="e7a12b247f8e4dd853fb7027039428b2379a21df" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;a href=&quot;../../table-joins/index&quot;&gt;table joins&lt;/a&gt; in RethinkDB.</source>
          <target state="translated">RethinkDB에서 &lt;a href=&quot;../../table-joins/index&quot;&gt;테이블 조인&lt;/a&gt; 을 사용하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="38439358cead9a9ddb8011466b2b2f821423863f" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;a href=&quot;../map-reduce/index&quot;&gt;map-reduce&lt;/a&gt; in RethinkDB.</source>
          <target state="translated">RethinkDB에서 &lt;a href=&quot;../map-reduce/index&quot;&gt;map-reduce&lt;/a&gt; 를 사용하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="9211e3e0cf73e7b17435ad61921079b0ccf56943" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;a href=&quot;../secondary-indexes/javascript/index&quot;&gt;primary and secondary indexes&lt;/a&gt; in RethinkDB.</source>
          <target state="translated">RethinkDB에서 &lt;a href=&quot;../secondary-indexes/javascript/index&quot;&gt;기본 및 보조 인덱스&lt;/a&gt; 를 사용하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="46618e390b1b640a19b5fe7e820ff17c339e0144" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;a href=&quot;../table-joins/index&quot;&gt;table joins&lt;/a&gt; in RethinkDB.</source>
          <target state="translated">RethinkDB에서 &lt;a href=&quot;../table-joins/index&quot;&gt;테이블 조인&lt;/a&gt; 을 사용하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="f065a72b19aac97d11c858d3ee474f834c0ea4e9" translate="yes" xml:space="preserve">
          <source>Learn how to use GeoJSON features to build location-aware apps in RethinkDB.</source>
          <target state="translated">GeoJSON 기능을 사용하여 RethinkDB에서 위치 인식 앱을 구축하는 방법에 대해 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="824d76b124e6289f372e2ff6bcba91e8939343bd" translate="yes" xml:space="preserve">
          <source>Learn more</source>
          <target state="translated">더 알아보기</target>
        </trans-unit>
        <trans-unit id="7a058f790976caa297b4022af937873c407c3337" translate="yes" xml:space="preserve">
          <source>Learn more about how RethinkDB can efficiently retrieve documents with &lt;a href=&quot;../../secondary-indexes/javascript/index&quot;&gt;secondary indexes&lt;/a&gt;.</source>
          <target state="translated">RethinkDB가 &lt;a href=&quot;../../secondary-indexes/javascript/index&quot;&gt;보조 인덱스를 사용&lt;/a&gt; 하여 문서를 효율적으로 검색하는 방법에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="89b463fdfab8c2b3e899da5b283265547e388a16" translate="yes" xml:space="preserve">
          <source>Learning the language is no different from learning any other library.</source>
          <target state="translated">언어를 배우는 것은 다른 도서관을 배우는 것과 다르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b20a7997c63ce3054fd7d30d35de4678173fe84" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s explore the advantages and disadvantages of each approach. We&amp;rsquo;ll use a simple blog database that stores information about authors and their posts to demonstrate them.</source>
          <target state="translated">각 접근 방식의 장단점을 살펴 보겠습니다. 저자 및 게시물에 대한 정보를 저장하는 간단한 블로그 데이터베이스를 사용하여 시연합니다.</target>
        </trans-unit>
        <trans-unit id="0a3374d1d23dd959122583511673592b311245c8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s filter based on the nested field &lt;code&gt;email&lt;/code&gt;:</source>
          <target state="translated">중첩 된 필드 &lt;code&gt;email&lt;/code&gt; 기준으로 필터링하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="cb7b4f56da03ec0ec2ef157f49777af0230bdeb9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s find the most influential GitHub users who showed interest in RethinkDB. First, let&amp;rsquo;s grab the list of RethinkDB stargazers:</source>
          <target state="translated">RethinkDB에 관심을 보인 가장 영향력있는 GitHub 사용자를 찾으십시오. 먼저 RethinkDB stargazer 목록을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="7c2b1f805ab05c4e6512aa8198d873b9d8e69683" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s follow the processing of a simple query. (This example uses JavaScript, but the commands are virtually identical in other languages.)</source>
          <target state="translated">간단한 쿼리 처리를 따르십시오. (이 예제는 JavaScript를 사용하지만 다른 언어에서는 명령이 거의 동일합니다.)</target>
        </trans-unit>
        <trans-unit id="e6b2a5e6f45fc67a9ecc8d1de778247a2bb0f236" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s insert three new documents into the &lt;code&gt;authors&lt;/code&gt; table:</source>
          <target state="translated">&lt;code&gt;authors&lt;/code&gt; 테이블에 세 개의 새 문서를 삽입 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="b741c7ad37ec13a7b2f8b15575a0343bd5b1de26" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at these concepts in more detail.</source>
          <target state="translated">이러한 개념을보다 자세히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ef26fdd5241f22380a2542ba5b766049445eb40d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we have another table &lt;code&gt;authors&lt;/code&gt;, and we&amp;rsquo;d like to get a list of authors whose last names are also in the &lt;code&gt;users&lt;/code&gt; table we&amp;rsquo;ve seen before. We can do it by combining two queries:</source>
          <target state="translated">다른 테이블 &lt;code&gt;authors&lt;/code&gt; 가 있고 이전에 본 &lt;code&gt;users&lt;/code&gt; 테이블 에도 성이있는 저자 목록을 원한다고 가정 하겠습니다. 두 가지 쿼리를 결합하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7ff567a62fcc49849955f0084cafdf6e60d5359" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we want to publish the teaming up between Batman, Superman and the Joker:</source>
          <target state="translated">배트맨, 슈퍼맨, 조커 사이에 팀 구성을 게시한다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="4c97142a03d1740d9845e909927ca5b45579f24c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how we can use joins in RethinkDB to query data based on &lt;strong&gt;one to many&lt;/strong&gt;, and &lt;strong&gt;many to many&lt;/strong&gt; relations.</source>
          <target state="translated">RethinkDB에서 조인을 사용 &lt;strong&gt;하여 일대 다&lt;/strong&gt; 및 &lt;strong&gt;다 대다&lt;/strong&gt; 관계 &lt;strong&gt;를&lt;/strong&gt; 기반으로 데이터를 쿼리하는 방법을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="b9a6c351ade4cff6a3547f0d48de14100d80140b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with a simple example. RethinkDB supports server-side JavaScript evaluation using the embedded V8 engine (sandboxed within outside processes, of course):</source>
          <target state="translated">간단한 예부터 시작하겠습니다. RethinkDB는 임베디드 V8 엔진 (물론 외부 프로세스 내에서 샌드 박스 처리)을 사용하여 서버 측 JavaScript 평가를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="49a17718af97d847a464ec714b54c94d0f64ebbe" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s suppose we&amp;rsquo;ve created two tables: &lt;code&gt;employees&lt;/code&gt; and &lt;code&gt;companies&lt;/code&gt;. We&amp;rsquo;ll use these tables to model the notion of people working for organizations (each organization has multiple people working for it, but any given person works at a single organization). Here&amp;rsquo;s an example document in the &lt;code&gt;employees&lt;/code&gt; table:</source>
          <target state="translated">&lt;code&gt;employees&lt;/code&gt; 과 &lt;code&gt;companies&lt;/code&gt; 라는 두 개의 테이블을 만들었다 고 가정 해 봅시다 . 이 표를 사용하여 조직에서 일하는 사람들의 개념을 모델링 할 것입니다 (각 조직에는 여러 사람이 일하고 있지만 주어진 사람은 단일 조직에서 일합니다). &lt;code&gt;employees&lt;/code&gt; 테이블 의 예제 문서는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b79e2ec29148ce71c9f97e43dc0f1bb9de49bd76" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try something very simple &amp;mdash; accessing a website. Type the following command in the Data Explorer and hit &amp;lsquo;Run&amp;rsquo; (alternatively, you can run it from a RethinkDB driver):</source>
          <target state="translated">웹 사이트에 액세스하는 매우 간단한 방법을 시도해 봅시다. 데이터 탐색기에 다음 명령을 입력하고 '실행'을 누르십시오 (또는 RethinkDB 드라이버에서 실행할 수도 있음).</target>
        </trans-unit>
        <trans-unit id="d523c71f4437b42b411bb4d2f3290905dc21ba48" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try to retrieve the document where the &lt;code&gt;name&lt;/code&gt; attribute is set to &lt;code&gt;William Adama&lt;/code&gt;. We can use a condition to filter the documents by chaining a &lt;code&gt;filter&lt;/code&gt; command to the end of the query:</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 속성이 &lt;code&gt;William Adama&lt;/code&gt; 로 설정된 문서를 검색해 봅시다 . &lt;code&gt;filter&lt;/code&gt; 명령을 쿼리 끝에 연결하여 조건을 사용하여 문서를 필터링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74167a956b2c180d4d5a4db633dfab9b54f1b3ee" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s update all documents in the &lt;code&gt;authors&lt;/code&gt; table and add a &lt;code&gt;type&lt;/code&gt; field to note that every author so far is fictional:</source>
          <target state="translated">&lt;code&gt;authors&lt;/code&gt; 테이블의 모든 문서를 업데이트 하고 &lt;code&gt;type&lt;/code&gt; 필드를 추가하여 지금까지의 모든 저자가 허구임을 확인 합시다 .</target>
        </trans-unit>
        <trans-unit id="e46cc597dcd23c00f763aa1f360f40229ca58a86" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s update our stargazer data with this additional information:</source>
          <target state="translated">이 추가 정보로 stargazer 데이터를 업데이트하겠습니다 :</target>
        </trans-unit>
        <trans-unit id="5cc9d86c4961df923fc41b3ea88b4072aa84010d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s use &lt;code&gt;filter&lt;/code&gt; again to retrieve all authors who have more than two posts:</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; 다시 사용 하여 두 개 이상의 게시물이있는 모든 저자를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="0bbb0ddb2e3183cfe93ee6ec919cd561d521a487" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write a script that listens for changes in the RethinkDB server and pushes them to RabbitMQ.</source>
          <target state="translated">RethinkDB 서버의 변경 사항을 수신하고 RabbitMQ로 푸시하는 스크립트를 작성해 봅시다.</target>
        </trans-unit>
        <trans-unit id="332e9d887845f15f8edb7f47a27c9feaa5e64473" translate="yes" xml:space="preserve">
          <source>Lets you install RethinkDB using Vagrant.</source>
          <target state="translated">Vagrant를 사용하여 RethinkDB를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="faa75a36abc1bfd1fe97a7d7bec24659e766b29c" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported License.</source>
          <target state="translated">Creative Commons Attribution-ShareAlike 3.0 Unported License에 따라 라이센스가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="e3891b7e1579150dc791a1037b6ef7ffc603c47a" translate="yes" xml:space="preserve">
          <source>Like any ReQL command, &lt;code&gt;changes&lt;/code&gt; integrates with the rest of the query language. You can call &lt;code&gt;changes&lt;/code&gt; after most commands that transform or select data:</source>
          <target state="translated">다른 ReQL 명령과 마찬가지로 &lt;code&gt;changes&lt;/code&gt; 은 나머지 쿼리 언어와 통합됩니다. 데이터를 변환하거나 선택하는 대부분의 명령 후에 &lt;code&gt;changes&lt;/code&gt; 을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50c623d37beca2feae774d169fbe6b85ee0be7e7" translate="yes" xml:space="preserve">
          <source>Like many traditional database systems, RethinkDB supports &lt;code&gt;JOIN&lt;/code&gt; commands to combine data from multiple tables. In RethinkDB joins are automatically distributed&amp;mdash;a join command is automatically sent to the appropriate nodes across the cluster, the relevant data is combined, and the final result is presented to the user.</source>
          <target state="translated">많은 기존 데이터베이스 시스템과 마찬가지로 RethinkDB는 &lt;code&gt;JOIN&lt;/code&gt; 명령을 지원 하여 여러 테이블의 데이터를 결합합니다. RethinkDB 조인은 자동으로 배포됩니다. 조인 명령이 클러스터의 해당 노드로 자동 전송되고 관련 데이터가 결합되어 최종 결과가 사용자에게 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b81e349422612226eccc114d5f889ba875ee59c6" translate="yes" xml:space="preserve">
          <source>Like most database systems, ReQL supports primary and secondary indexes to allow efficient data access. You can also create compound indexes and indexes based on arbitrary ReQL expressions to speed up complex queries.</source>
          <target state="translated">대부분의 데이터베이스 시스템과 마찬가지로 ReQL은 기본 및 보조 인덱스를 지원하여 효율적인 데이터 액세스를 허용합니다. 임의의 ReQL 표현식을 기반으로 복합 인덱스 및 인덱스를 작성하여 복잡한 쿼리 속도를 높일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbcbaaf781c0838f0b358c0dddcca12bc10e4339" translate="yes" xml:space="preserve">
          <source>Limitations of automatic failover</source>
          <target state="translated">자동 장애 조치의 한계</target>
        </trans-unit>
        <trans-unit id="8f13609bf219f6ca237069b790c4c9a2ad381552" translate="yes" xml:space="preserve">
          <source>Limiting the number of returned documents</source>
          <target state="translated">반품 된 문서 수 제한</target>
        </trans-unit>
        <trans-unit id="46453bf012aa531ac54613a0f5623dcf3c269fca" translate="yes" xml:space="preserve">
          <source>Linearizability and atomicity guarantees</source>
          <target state="translated">선형성 및 원 자성 보장</target>
        </trans-unit>
        <trans-unit id="8079cd01630a2b6f154b2abd4aca58bf065d2bf7" translate="yes" xml:space="preserve">
          <source>Lines and distances</source>
          <target state="translated">선과 거리</target>
        </trans-unit>
        <trans-unit id="f8a8b40332141131251cba0338928c84cbc899bd" translate="yes" xml:space="preserve">
          <source>Lines and polygons can be specified using either point objects or sequences of two-number arrays:</source>
          <target state="translated">점 개체 또는 두 개의 숫자 배열 시퀀스를 사용하여 선과 다각형을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2e17174307bd30c9651cd5cd7f2b98cd08f8a35" translate="yes" xml:space="preserve">
          <source>Linking documents in multiple tables</source>
          <target state="translated">여러 테이블에서 문서 연결</target>
        </trans-unit>
        <trans-unit id="6ed36fa1183214845ee195f26eeda3f8866b655a" translate="yes" xml:space="preserve">
          <source>Linux Mint</source>
          <target state="translated">리눅스 민트</target>
        </trans-unit>
        <trans-unit id="d51bed5d4234a9759d6a8aab8a001767fd630b60" translate="yes" xml:space="preserve">
          <source>Linux and OS X</source>
          <target state="translated">리눅스와 OS X</target>
        </trans-unit>
        <trans-unit id="a6b55add3271bf52f9229b1f55c71bf39192ee0c" translate="yes" xml:space="preserve">
          <source>List all database names in the system. The result is a list of strings.</source>
          <target state="translated">시스템의 모든 데이터베이스 이름을 나열하십시오. 결과는 문자열 목록입니다.</target>
        </trans-unit>
        <trans-unit id="993b1d68164e0a0c046c84b9ca43c4e5830eec98" translate="yes" xml:space="preserve">
          <source>List all table names in a database. The result is a list of strings.</source>
          <target state="translated">데이터베이스의 모든 테이블 이름을 나열하십시오. 결과는 문자열 목록입니다.</target>
        </trans-unit>
        <trans-unit id="3bb65a3a68d5a8ad114346be2ad7ccd0b325bc12" translate="yes" xml:space="preserve">
          <source>List all the secondary indexes of this table.</source>
          <target state="translated">이 테이블의 모든 보조 인덱스를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="cca8cd4e2bc2f275251b8f0b5ed8434b92cf0173" translate="yes" xml:space="preserve">
          <source>Listen for changes in a RethinkDB table over RabbitMQ.</source>
          <target state="translated">RabbitMQ를 통해 RethinkDB 테이블의 변경 사항을 청취하십시오.</target>
        </trans-unit>
        <trans-unit id="eb6fc719e4222cb0e021bed23a373eb005d0e88d" translate="yes" xml:space="preserve">
          <source>Listening to RabbitMQ messages</source>
          <target state="translated">RabbitMQ 메시지 듣기</target>
        </trans-unit>
        <trans-unit id="5ec7392e4c45dc057d7ab6c781c38d95f4d3346a" translate="yes" xml:space="preserve">
          <source>Load &lt;code&gt;python&lt;/code&gt; (or &lt;a href=&quot;http://ipython.org&quot;&gt;ipython&lt;/a&gt;) and set up a connection to your database:</source>
          <target state="translated">&lt;code&gt;python&lt;/code&gt; (또는 &lt;a href=&quot;http://ipython.org&quot;&gt;ipython&lt;/a&gt; )을 로드 하고 데이터베이스에 대한 연결을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="37819416fc67fd2f5cd366c850cf56b4ff2d213c" translate="yes" xml:space="preserve">
          <source>Log in using the username &lt;code&gt;rethinkdb&lt;/code&gt; and the password you chose in step 7.</source>
          <target state="translated">&lt;code&gt;rethinkdb&lt;/code&gt; 사용자 이름 과 7 단계에서 선택한 비밀번호를 사용하여 로그인하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2e3210b91ade80c488bbcfd4ac6f12798b16237" translate="yes" xml:space="preserve">
          <source>Log options</source>
          <target state="translated">로그 옵션</target>
        </trans-unit>
        <trans-unit id="aa42cc5f49c6d291cfc5d71f7d47803ff3f9de31" translate="yes" xml:space="preserve">
          <source>Log write issues</source>
          <target state="translated">로그 쓰기 문제</target>
        </trans-unit>
        <trans-unit id="00d45cf43ab6900d309ef4eaaa39f6e115347863" translate="yes" xml:space="preserve">
          <source>Logging tools</source>
          <target state="translated">로깅 도구</target>
        </trans-unit>
        <trans-unit id="77579f2f6e9a0b7bf5302dfdb7b5e31eec34bd09" translate="yes" xml:space="preserve">
          <source>Longitude (&amp;minus;180 to 180) and latitude (&amp;minus;90 to 90) of vertices are plotted on a perfect sphere. See &lt;a href=&quot;../../../docs/geo-support/javascript/index&quot;&gt;Geospatial support&lt;/a&gt; for more information on ReQL&amp;rsquo;s coordinate system.</source>
          <target state="translated">정점의 경도 (-180-180) 및 위도 (-90-90)는 완벽한 구에 표시됩니다. ReQL 좌표계에 대한 자세한 정보는 &lt;a href=&quot;../../../docs/geo-support/javascript/index&quot;&gt;지리 공간 지원&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7f41960132584f9d7bd0c067c3f4dfa28d057b2" translate="yes" xml:space="preserve">
          <source>Look at how many arguments the function takes (&lt;code&gt;num_args&lt;/code&gt;)</source>
          <target state="translated">함수가 몇 개의 인수를 받는지보십시오 ( &lt;code&gt;num_args&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c92246116a0060ce1970018249864b4c7a3348ef" translate="yes" xml:space="preserve">
          <source>Loop over a sequence, evaluating the given write query for each element.</source>
          <target state="translated">시퀀스를 반복하여 각 요소에 대해 주어진 쓰기 쿼리를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="c6ceab055f64bcd972209f1ed242740ed0fe108b" translate="yes" xml:space="preserve">
          <source>Lowercases a string.</source>
          <target state="translated">문자열을 소문자로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b0832074630eb731d7fbe8074de48a90cd9bb220" translate="yes" xml:space="preserve">
          <source>Lua</source>
          <target state="translated">Lua</target>
        </trans-unit>
        <trans-unit id="853db5db5e9449857a125fdaf64c49523fbe605b" translate="yes" xml:space="preserve">
          <source>Make also sure you&amp;rsquo;ve &lt;a href=&quot;https://rethinkdb.com/docs/install-drivers/javascript/&quot;&gt;installed the JavaScript driver&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;a href=&quot;https://rethinkdb.com/docs/install-drivers/javascript/&quot;&gt;JavaScript 드라이버를 설치&lt;/a&gt; 했는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae4a8e3bb1c5ba5084979d58dccde30ec4b6619e" translate="yes" xml:space="preserve">
          <source>Make sure you&amp;rsquo;ve &lt;a href=&quot;https://rethinkdb.com/install&quot;&gt;installed RethinkDB&lt;/a&gt;&amp;mdash;it should only take a minute!</source>
          <target state="translated">&lt;a href=&quot;https://rethinkdb.com/install&quot;&gt;RethinkDB를 설치&lt;/a&gt; 했는지 확인하십시오. 단 1 분 밖에 걸리지 않습니다!</target>
        </trans-unit>
        <trans-unit id="ec8db219e768dbf927afc537cce0ed0ac5d426cf" translate="yes" xml:space="preserve">
          <source>Manipulating Databases</source>
          <target state="translated">데이터베이스 조작</target>
        </trans-unit>
        <trans-unit id="cd5274de84779cf7e26c8aeb43ee293a6d239ace" translate="yes" xml:space="preserve">
          <source>Manipulating Tables</source>
          <target state="translated">테이블 조작</target>
        </trans-unit>
        <trans-unit id="0315f3bc6857038096e10b57a0d97ca1a21082ee" translate="yes" xml:space="preserve">
          <source>Manipulating databases</source>
          <target state="translated">데이터베이스 조작</target>
        </trans-unit>
        <trans-unit id="85cd44aae68cc1b84cb48c7c2fe761b7d6e991c5" translate="yes" xml:space="preserve">
          <source>Manipulating documents</source>
          <target state="translated">문서 조작</target>
        </trans-unit>
        <trans-unit id="379776eeb89cc816e18680ac4dff7a7359381323" translate="yes" xml:space="preserve">
          <source>Manipulating indexes with the web UI</source>
          <target state="translated">웹 UI를 사용하여 인덱스 조작</target>
        </trans-unit>
        <trans-unit id="ae4c8c8c4f2c5ea1dc21a8c397caa583dd053f78" translate="yes" xml:space="preserve">
          <source>Manipulating indexes: &lt;a href=&quot;../../../api/javascript/index_create/index&quot;&gt;indexCreate&lt;/a&gt;, &lt;a href=&quot;../../../api/javascript/index_drop/index&quot;&gt;indexDrop&lt;/a&gt; and &lt;a href=&quot;../../../api/javascript/index_list/index&quot;&gt;indexList&lt;/a&gt;</source>
          <target state="translated">인덱스 조작 : &lt;a href=&quot;../../../api/javascript/index_create/index&quot;&gt;indexCreate&lt;/a&gt; , &lt;a href=&quot;../../../api/javascript/index_drop/index&quot;&gt;indexDrop&lt;/a&gt; 및 &lt;a href=&quot;../../../api/javascript/index_list/index&quot;&gt;indexList&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e391b105e9585f961562e7064cb0aa9414e73a72" translate="yes" xml:space="preserve">
          <source>Manipulating tables</source>
          <target state="translated">테이블 조작</target>
        </trans-unit>
        <trans-unit id="f17e3cdc08f968d3b1b8c2ec9eb1ceefef64f7ee" translate="yes" xml:space="preserve">
          <source>Manually merge the left and right fields</source>
          <target state="translated">왼쪽 및 오른쪽 필드를 수동으로 병합</target>
        </trans-unit>
        <trans-unit id="b9a082aaaec9d03b12fca89934928f413350caae" translate="yes" xml:space="preserve">
          <source>Many people have been reporting that they get back a connection object when they run a query, the object being:</source>
          <target state="translated">많은 사람들이 쿼리를 실행할 때 연결 개체를 다시 얻는다고보고했습니다. 개체는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf4d9a2e9aca1ebab3357daa2f4482b382a28a79" translate="yes" xml:space="preserve">
          <source>Many to many relations</source>
          <target state="translated">다 대다 관계</target>
        </trans-unit>
        <trans-unit id="d103bd0ce354a22ec2d971d2a818261309039c72" translate="yes" xml:space="preserve">
          <source>Map-reduce in RethinkDB</source>
          <target state="translated">RethinkDB의 맵 축소</target>
        </trans-unit>
        <trans-unit id="ec8bb2749b0912c81ba2d5e51014afb3a3980c0f" translate="yes" xml:space="preserve">
          <source>Matches against a regular expression. If there is a match, returns an object with the fields:</source>
          <target state="translated">정규식과 일치합니다. 일치하는 항목이 있으면 필드가있는 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aded3de93027fd725e41f6ca4105d385535009bf" translate="yes" xml:space="preserve">
          <source>Math and Logic</source>
          <target state="translated">수학과 논리</target>
        </trans-unit>
        <trans-unit id="e76587c25d66762a167abd2d402654b3cc867d80" translate="yes" xml:space="preserve">
          <source>Math and logic</source>
          <target state="translated">수학과 논리</target>
        </trans-unit>
        <trans-unit id="6888270cc5b2dfaf0916f2237e02a11e56088cf7" translate="yes" xml:space="preserve">
          <source>Memory availability issues</source>
          <target state="translated">메모리 가용성 문제</target>
        </trans-unit>
        <trans-unit id="110c6707f36ae400d4ca884b4a45ac2166550586" translate="yes" xml:space="preserve">
          <source>Memory requirements</source>
          <target state="translated">메모리 요구 사항</target>
        </trans-unit>
        <trans-unit id="5dd7c30db3f640d34b64d0e2719a800c2ccfb0d5" translate="yes" xml:space="preserve">
          <source>Merge two or more objects together to construct a new object with properties from all. When there is a conflict between field names, preference is given to fields in the rightmost object in the argument list. &lt;code&gt;merge&lt;/code&gt; also accepts a subquery function that returns an object, which will be used similarly to a &lt;a href=&quot;../map/index&quot;&gt;map&lt;/a&gt; function.</source>
          <target state="translated">둘 이상의 객체를 병합하여 모든 속성을 가진 새 객체를 구성합니다. 필드 이름간에 충돌이 발생하면 인수 목록에서 가장 오른쪽에있는 개체의 필드가 기본 설정으로 제공됩니다. 또한 &lt;code&gt;merge&lt;/code&gt; 는 객체를 반환하는 하위 쿼리 함수를 허용하며,이 함수 는 &lt;a href=&quot;../map/index&quot;&gt;맵&lt;/a&gt; 함수 와 유사하게 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="04d73701de8502ed6708d400a96b65af03f13dbb" translate="yes" xml:space="preserve">
          <source>Merge two or more objects together to construct a new object with properties from all. When there is a conflict between field names, preference is given to fields in the rightmost object in the argument list. &lt;code&gt;merge&lt;/code&gt; also accepts a subquery function that returns an object, which will be used similarly to a &lt;a href=&quot;map/index&quot;&gt;map&lt;/a&gt; function.</source>
          <target state="translated">둘 이상의 객체를 병합하여 모든 속성을 가진 새 객체를 구성합니다. 필드 이름간에 충돌이 발생하면 인수 목록에서 가장 오른쪽에있는 개체의 필드가 기본 설정으로 제공됩니다. 또한 &lt;code&gt;merge&lt;/code&gt; 는 객체를 반환하는 하위 쿼리 함수를 허용하며,이 함수 는 &lt;a href=&quot;map/index&quot;&gt;맵&lt;/a&gt; 함수 와 유사하게 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="98f6cf8510e0439f12bcf7a86ba1ceba63386fc2" translate="yes" xml:space="preserve">
          <source>Merge two or more sequences.</source>
          <target state="translated">둘 이상의 시퀀스를 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="1f0a513d0abdd16d2f84502191d76b98a52fb8f7" translate="yes" xml:space="preserve">
          <source>Migrating data from previous versions of RethinkDB</source>
          <target state="translated">이전 버전의 RethinkDB에서 데이터 마이그레이션</target>
        </trans-unit>
        <trans-unit id="aa6d9b542df934b1fb7cababc57d99f0c762b82c" translate="yes" xml:space="preserve">
          <source>Migrating old data</source>
          <target state="translated">이전 데이터 마이그레이션</target>
        </trans-unit>
        <trans-unit id="ce5743bd4325e12d91947a3f4a1b808fb776fbbb" translate="yes" xml:space="preserve">
          <source>Migration consists of three simple steps:</source>
          <target state="translated">마이그레이션은 세 가지 간단한 단계로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="7fe0b02845ac7e31f8355515cfa9358814ea98d9" translate="yes" xml:space="preserve">
          <source>Mimics the behavior of Python&amp;rsquo;s &lt;code&gt;string.split&lt;/code&gt; in edge cases, except for splitting on the empty string, which instead produces an array of single-character strings.</source>
          <target state="translated">빈 문자열을 분할하는 대신 (단일 문자 문자열 배열을 생성하는 경우를 제외하고) 가장자리의 경우 Python의 &lt;code&gt;string.split&lt;/code&gt; 동작을 모방합니다 .</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="1a0e2290409950c22eeaa9cec60aef1b7a34fe19" translate="yes" xml:space="preserve">
          <source>Mixed sequences of data sort in the following order:</source>
          <target state="translated">혼합 순서의 데이터는 다음 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="050aa84d9f3547048f944db27736fa71c21601f8" translate="yes" xml:space="preserve">
          <source>Modeling relationships</source>
          <target state="translated">모델링 관계</target>
        </trans-unit>
        <trans-unit id="4d7ad1ad621c826e63ea432ff5d8acd0e7e9dbc1" translate="yes" xml:space="preserve">
          <source>Models in depth</source>
          <target state="translated">깊이있는 모델</target>
        </trans-unit>
        <trans-unit id="0e0c2052c8a28cb53004104670a5f3189e0ff126" translate="yes" xml:space="preserve">
          <source>Modifying times</source>
          <target state="translated">시간 수정</target>
        </trans-unit>
        <trans-unit id="38ed8d7a13fc2d35939d911335ecac667570c279" translate="yes" xml:space="preserve">
          <source>Molly.js</source>
          <target state="translated">Molly.js</target>
        </trans-unit>
        <trans-unit id="4bab2d8fe13fa6ab57f80098b414f0f734c5dd25" translate="yes" xml:space="preserve">
          <source>More</source>
          <target state="translated">More</target>
        </trans-unit>
        <trans-unit id="65607507695dbb68853f7200e33956e39fd6a15d" translate="yes" xml:space="preserve">
          <source>More Examples</source>
          <target state="translated">더 많은 예</target>
        </trans-unit>
        <trans-unit id="41775da315d57d76ff81ed9611116e4ea3dfd26d" translate="yes" xml:space="preserve">
          <source>More complex predicates</source>
          <target state="translated">더 복잡한 술어</target>
        </trans-unit>
        <trans-unit id="7180389997e0b1e0af0e7dc001fd021b621caff0" translate="yes" xml:space="preserve">
          <source>Most APIs support some form of authentication and rate limiting. The &lt;code&gt;r.http&lt;/code&gt; command supports common forms of authentication (see the &lt;a href=&quot;../../api/javascript/http/index&quot;&gt;reference&lt;/a&gt; for more details). For example, here is how you can use GitHub tokens with basic auth:</source>
          <target state="translated">대부분의 API는 특정 형식의 인증 및 속도 제한을 지원합니다. &lt;code&gt;r.http&lt;/code&gt; 의 명령은 인증의 일반적인 형태 (투시 지원 &lt;a href=&quot;../../api/javascript/http/index&quot;&gt;참조&lt;/a&gt; 자세한 내용 참조). 예를 들어 기본 인증과 함께 GitHub 토큰을 사용하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fa60d0629e116eb043cbf63a410f5ce6c0b76c72" translate="yes" xml:space="preserve">
          <source>Most date operations are only defined on years in the range &lt;code&gt;[1400, 10000]&lt;/code&gt; (but note that times in the year &lt;code&gt;10000&lt;/code&gt; cannot be printed as ISO 8601 dates).</source>
          <target state="translated">대부분의 날짜 작업은 &lt;code&gt;[1400, 10000]&lt;/code&gt; 범위의 연도에만 정의됩니다 (그러나 &lt;code&gt;10000&lt;/code&gt; 연도의 시간은 ISO 8601 날짜로 인쇄 할 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="0641f9094acfde9b6cf6cc3b9d52a297e0e65bd8" translate="yes" xml:space="preserve">
          <source>Multi indexes</source>
          <target state="translated">다중 인덱스</target>
        </trans-unit>
        <trans-unit id="98a7e7d6cc4d0854490ddbd7601741fd83b90023" translate="yes" xml:space="preserve">
          <source>Multi-datacenter setup</source>
          <target state="translated">다중 데이터 센터 설정</target>
        </trans-unit>
        <trans-unit id="86753c0740ef8a696a347475bf1ea038b52b180e" translate="yes" xml:space="preserve">
          <source>Multipart responses</source>
          <target state="translated">멀티 파트 응답</target>
        </trans-unit>
        <trans-unit id="021a631169c4a417b486aab49a973289a6614f87" translate="yes" xml:space="preserve">
          <source>Multiple RethinkDB instances on a single machine</source>
          <target state="translated">단일 시스템에서 여러 RethinkDB 인스턴스</target>
        </trans-unit>
        <trans-unit id="09ad7baebfde68a2882bc6128e8473c249838c72" translate="yes" xml:space="preserve">
          <source>Multiple instances</source>
          <target state="translated">여러 인스턴스</target>
        </trans-unit>
        <trans-unit id="cc1d53d7c78cd147a3d1ec6d9077c46bc8013328" translate="yes" xml:space="preserve">
          <source>Multiple servers, databases, or tables in the same database have been assigned the same name. The &lt;code&gt;name&lt;/code&gt; field shows the conflicting name; &lt;code&gt;ids&lt;/code&gt; are the UUIDs of the entities that have that name. In the case of &lt;code&gt;table_name_collision&lt;/code&gt;, &lt;code&gt;db&lt;/code&gt; will be the database that the tables are in. Rename the conflicting entities.</source>
          <target state="translated">동일한 데이터베이스의 여러 서버, 데이터베이스 또는 테이블에 동일한 이름이 지정되었습니다. &lt;code&gt;name&lt;/code&gt; 필드는 충돌 이름을 보여줍니다; &lt;code&gt;ids&lt;/code&gt; 는 해당 이름을 가진 엔티티의 UUID입니다. 의 경우 &lt;code&gt;table_name_collision&lt;/code&gt; , &lt;code&gt;db&lt;/code&gt; 테이블이있는 것을 데이터베이스 될 것입니다. 충돌하는 엔티티의 이름을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="8ee266f49fc4bb636b4d04389645377477ea4f26" translate="yes" xml:space="preserve">
          <source>Multiply two numbers, or make a periodic array.</source>
          <target state="translated">두 숫자를 곱하거나 주기적으로 배열하십시오.</target>
        </trans-unit>
        <trans-unit id="1f211804aeeccd93ce4380676a5c34cd70670249" translate="yes" xml:space="preserve">
          <source>My insert queries are slow. How can I speed them up?</source>
          <target state="translated">삽입 쿼리 속도가 느립니다. 속도를 높이려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="4d572e4dbba9de4ec7b823d0ec15cdc5e5e700f7" translate="yes" xml:space="preserve">
          <source>My secondary index is outdated</source>
          <target state="translated">보조 인덱스가 오래되었습니다</target>
        </trans-unit>
        <trans-unit id="e7942af5c84b130986b851206ecc6f9a347c6d81" translate="yes" xml:space="preserve">
          <source>Name collision issues</source>
          <target state="translated">이름 충돌 문제</target>
        </trans-unit>
        <trans-unit id="57d2c00ce45ae19ada8881fa5212e7afd2ff2b8c" translate="yes" xml:space="preserve">
          <source>Native ReQL commands like &lt;code&gt;reconfigure&lt;/code&gt; also control sharding and replication, and if you&amp;rsquo;re not using server tags you can change sharding/replication settings in the web UI. Read &lt;a href=&quot;../sharding-and-replication/index&quot;&gt;Sharding and replication&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;reconfigure&lt;/code&gt; 과 같은 기본 ReQL 명령은 샤딩 및 복제도 제어하며 서버 태그를 사용하지 않는 경우 웹 UI에서 샤딩 / 복제 설정을 변경할 수 있습니다. 자세한 내용은 &lt;a href=&quot;../sharding-and-replication/index&quot;&gt;샤딩 및 복제&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="b732272c643f080018849521bf6a04412a4035e5" translate="yes" xml:space="preserve">
          <source>Native language&amp;rsquo;s operations that have side effects or control blocks cannot be used within a &lt;code&gt;lambda&lt;/code&gt;. Learn more about &lt;a href=&quot;https://rethinkdb.com/blog/lambda-functions/&quot;&gt;how this design is implemented&lt;/a&gt; for details.</source>
          <target state="translated">부작용 또는 제어 블록이있는 모국어 작업은 &lt;code&gt;lambda&lt;/code&gt; 내에서 사용할 수 없습니다 . 세부 사항을 &lt;a href=&quot;https://rethinkdb.com/blog/lambda-functions/&quot;&gt;위해이 디자인이 구현&lt;/a&gt; 되는 방법에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="87c96561f54572b1d2129d04e9b42119a72d9901" translate="yes" xml:space="preserve">
          <source>Near to the release of this performance report, we are excited to release RethinkDB 2.3 with plenty of new features. Rigorous performance testing, and properly publishing results is a very time-consuming process, but one we will conduct for future releases on an ongoing basis. We plan to publish our next set of metrics during the lifetime of the RethinkDB 2.3 release. We also would like to test RethinkDB performance when scaled to beyond a 16 node cluster during our next testing cycle. Going forward, we will include a summary of previous reports at the end of each report for comparison.</source>
          <target state="translated">이 성능 보고서의 출시가 가까워지면서 많은 새로운 기능을 갖춘 RethinkDB 2.3을 출시하게되어 기쁩니다. 엄격한 성능 테스트 및 결과 게시는 매우 시간이 걸리는 프로세스이지만 향후 릴리스를 위해 지속적으로 수행 할 것입니다. RethinkDB 2.3 릴리스 기간 동안 다음 측정 항목을 게시 할 계획입니다. 또한 다음 테스트주기 동안 16 노드 클러스터 이상으로 확장 될 때 RethinkDB 성능을 테스트하려고합니다. 앞으로는 각 보고서 끝에 이전 보고서 요약을 포함시켜 비교할 것입니다.</target>
        </trans-unit>
        <trans-unit id="2f6fba18324193c1ccc35dd945f1c291c471bf6d" translate="yes" xml:space="preserve">
          <source>Negative &lt;code&gt;startOffset&lt;/code&gt; and &lt;code&gt;endOffset&lt;/code&gt; values are allowed with arrays; in that case, the returned range counts back from the array&amp;rsquo;s end. That is, the range &lt;code&gt;(-2)&lt;/code&gt; returns the last two elements, and the range of &lt;code&gt;(2,-1)&lt;/code&gt; returns the second element through the next-to-last element of the range. An error will be raised on a negative &lt;code&gt;startOffset&lt;/code&gt; or &lt;code&gt;endOffset&lt;/code&gt; with non-arrays. (An &lt;code&gt;endOffset&lt;/code&gt; of &amp;minus;1 &lt;em&gt;is&lt;/em&gt; allowed with a stream if &lt;code&gt;rightBound&lt;/code&gt; is closed; this behaves as if no &lt;code&gt;endOffset&lt;/code&gt; was specified.)</source>
          <target state="translated">음수 &lt;code&gt;startOffset&lt;/code&gt; 및 &lt;code&gt;endOffset&lt;/code&gt; 값은 배열에 허용됩니다. 이 경우 반환 된 범위는 배열의 끝부터 계산됩니다. 즉, 범위 &lt;code&gt;(-2)&lt;/code&gt; 는 마지막 두 요소를 반환하고 &lt;code&gt;(2,-1)&lt;/code&gt; 의 범위는 범위의 다음에서 마지막 요소까지 두 번째 요소를 반환합니다. 음수 가 아닌 &lt;code&gt;startOffset&lt;/code&gt; 또는 &lt;code&gt;endOffset&lt;/code&gt; 에서 배열이 아닌 경우 오류가 발생 합니다. &lt;code&gt;rightBound&lt;/code&gt; 가 닫히면 스트림 에 -1 의 &lt;code&gt;endOffset&lt;/code&gt; &lt;em&gt;이&lt;/em&gt; 허용되며 &lt;code&gt;endOffset&lt;/code&gt; 이 지정 되지 않은 것처럼 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="55d06d5784fa220b321b58feb4840aab256fc83a" translate="yes" xml:space="preserve">
          <source>Nested resources in views</source>
          <target state="translated">뷰에서 중첩 된 리소스</target>
        </trans-unit>
        <trans-unit id="6ddf66c9236295cf80e623178cd3a86d93d90f71" translate="yes" xml:space="preserve">
          <source>Network options</source>
          <target state="translated">네트워크 옵션</target>
        </trans-unit>
        <trans-unit id="11fc14203dd0f4441645a9c34d5dd022905f56e4" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="translated">다음 단계</target>
        </trans-unit>
        <trans-unit id="24f947aa7d57d693ce1d98cdba36427bb9ce7386" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll connect to the RabbitMQ server using amqplib:</source>
          <target state="translated">다음으로 amqplib를 사용하여 RabbitMQ 서버에 연결합니다 :</target>
        </trans-unit>
        <trans-unit id="8bcd0a2c52378cf0d5699266d7e259ed99978f8c" translate="yes" xml:space="preserve">
          <source>Nim</source>
          <target state="translated">Nim</target>
        </trans-unit>
        <trans-unit id="16acb6d551b744fda3354c17a22ed53ee3c2a38e" translate="yes" xml:space="preserve">
          <source>No proxy for: (remove everything)</source>
          <target state="translated">프록시 없음 : (모든 항목 제거)</target>
        </trans-unit>
        <trans-unit id="d4388553ac2433a2d8de402d1a33e87d261b34cb" translate="yes" xml:space="preserve">
          <source>No special procedures or commands are necessary to execute RethinkDB queries asynchronously in JavaScript. Read about using callbacks and promises with RethinkDB in the documentation for the &lt;a href=&quot;../../api/javascript/run/index&quot;&gt;run&lt;/a&gt; command.</source>
          <target state="translated">JavaScript에서 RethinkDB 쿼리를 비동기식으로 실행하는 데 특별한 절차 나 명령이 필요하지 않습니다. &lt;a href=&quot;../../api/javascript/run/index&quot;&gt;run&lt;/a&gt; 명령 설명서에서 RethinkDB와의 콜백 및 약속 사용에 대해 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="7695d8b90da619c62d4210a919c12878e58d47a6" translate="yes" xml:space="preserve">
          <source>No. However, you can export to GeoJSON and process that with other tools.</source>
          <target state="translated">그러나 GeoJSON으로 내보내고 다른 도구를 사용하여 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="7fc6dfab40c56076b4529c151dc339fe0e28415a" translate="yes" xml:space="preserve">
          <source>NoBrainer adds a light wrapper around ReQL queries. Here are some examples:</source>
          <target state="translated">NoBrainer는 ReQL 쿼리 주위에 가벼운 래퍼를 추가합니다. 여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="2334597b85868c5bda45705d9c6dadcdc53b3feb" translate="yes" xml:space="preserve">
          <source>NoBrainer runs the validations only when saving, but not when retrieving a document. This means you can always retrieve your data, but an invalid model won&amp;rsquo;t be saved to the database.</source>
          <target state="translated">NoBrainer는 저장할 때만 유효성 검사를 실행하지만 문서를 검색 할 때는 유효성 검사를 실행하지 않습니다. 즉, 항상 데이터를 검색 할 수 있지만 잘못된 모델은 데이터베이스에 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff74a5e83610f74cfb3d040f4dd2a594d12dd9d2" translate="yes" xml:space="preserve">
          <source>Node and Socket.io</source>
          <target state="translated">노드와 Socket.io</target>
        </trans-unit>
        <trans-unit id="10b3493287f831e81a438811a1ffba01f8cec4b7" translate="yes" xml:space="preserve">
          <source>Node.js</source>
          <target state="translated">Node.js</target>
        </trans-unit>
        <trans-unit id="aa72935495ba47f9868598eb0972bab220cb0b79" translate="yes" xml:space="preserve">
          <source>Node.js Todo list</source>
          <target state="translated">Node.js 할 일 목록</target>
        </trans-unit>
        <trans-unit id="4839715bc122d856e205f2a6e684ab4b4c9e9787" translate="yes" xml:space="preserve">
          <source>Node.js libraries</source>
          <target state="translated">Node.js 라이브러리</target>
        </trans-unit>
        <trans-unit id="9e325452c6548fc2449564842660d75ef3b1eb73" translate="yes" xml:space="preserve">
          <source>Nodes</source>
          <target state="translated">Nodes</target>
        </trans-unit>
        <trans-unit id="60e056d9960d2aa21ce42b1232734ba6d3cb45ff" translate="yes" xml:space="preserve">
          <source>Not passing the &lt;code&gt;group_format&lt;/code&gt; flag would return:</source>
          <target state="translated">&lt;code&gt;group_format&lt;/code&gt; 플래그를 전달하지 않으면 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a33a695a3e0e45a968fb7f12f79cb0174916eeb2" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt; will ignore the &lt;code&gt;read_mode&lt;/code&gt; flag, and will always behave as if it is set to &lt;code&gt;single&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;../changefeeds/javascript/index&quot;&gt;changefeeds이&lt;/a&gt; 무시됩니다 &lt;code&gt;read_mode&lt;/code&gt; 의 플래그를하고로 설정되어있는 것처럼 항상 작동합니다 &lt;code&gt;single&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23aa91cdc70b0f0c42f4dc080acc2e18f209da6b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;branch&lt;/code&gt;, the ReQL conditional command, must be used instead of &lt;code&gt;if&lt;/code&gt;. See the &lt;code&gt;branch&lt;/code&gt;&lt;a href=&quot;../branch/index&quot;&gt;documentation&lt;/a&gt; for more.</source>
          <target state="translated">그 주 &lt;code&gt;branch&lt;/code&gt; 는 ReQL 조건 명령이 대신 사용되어야 &lt;code&gt;if&lt;/code&gt; . 자세한 내용은 &lt;code&gt;branch&lt;/code&gt; &lt;a href=&quot;../branch/index&quot;&gt;설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="046b36ef7075cbe7dba601071ec0d34de7ee628d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;getAll&lt;/code&gt; and similar operations do &lt;em&gt;not&lt;/em&gt; execute in an atomic fashion with &lt;code&gt;update&lt;/code&gt;. Read &lt;a href=&quot;../../../docs/consistency/index&quot;&gt;Consistency guarantees&lt;/a&gt; for more details. Also, see the example for conditional updates below for a solution using &lt;code&gt;branch&lt;/code&gt; in an &lt;code&gt;update&lt;/code&gt; clause.</source>
          <target state="translated">참고 &lt;code&gt;filter&lt;/code&gt; , &lt;code&gt;getAll&lt;/code&gt; 메 와 유사한 작업을 할 &lt;em&gt;수 없습니다&lt;/em&gt; 와 원자 방식으로 실행 &lt;code&gt;update&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;../../../docs/consistency/index&quot;&gt;일관성 보증&lt;/a&gt; 을 읽으십시오 . 또한 &lt;code&gt;update&lt;/code&gt; 절 에서 &lt;code&gt;branch&lt;/code&gt; 를 사용하는 솔루션에 대해서는 아래 조건부 업데이트 예를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3cce3c5063c9b4680ce2db7489bc86d18a9613e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;innerJoin&lt;/code&gt; is slower and much less efficient than using &lt;a href=&quot;../eq_join/index&quot;&gt;eqJoin&lt;/a&gt; or &lt;a href=&quot;../concat_map/index&quot;&gt;concatMap&lt;/a&gt; with &lt;a href=&quot;../get_all/index&quot;&gt;getAll&lt;/a&gt;. You should avoid using &lt;code&gt;innerJoin&lt;/code&gt; in commands when possible.</source>
          <target state="translated">참고 것을 &lt;code&gt;innerJoin&lt;/code&gt; 가 느린 사용하는 것보다 훨씬 효율적이다 &lt;a href=&quot;../eq_join/index&quot;&gt;eqJoin&lt;/a&gt; 또는 &lt;a href=&quot;../concat_map/index&quot;&gt;concatMap을&lt;/a&gt; 함께 &lt;a href=&quot;../get_all/index&quot;&gt;를 getAll&lt;/a&gt; . 가능하면 명령에 &lt;code&gt;innerJoin&lt;/code&gt; 을 사용하지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="fb9c353d911b32d303fae6ec6ffcae4f1a653918" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;map&lt;/code&gt; can only be applied to sequences, not single values. If you wish to apply a function to a single value/selection (including an array), use the &lt;a href=&quot;../do/index&quot;&gt;do&lt;/a&gt; command.</source>
          <target state="translated">참고 것을 &lt;code&gt;map&lt;/code&gt; 에만 시퀀스가 아닌 단일 값에 적용 할 수 있습니다. 단일 값 / 선택 (배열 포함)에 함수를 적용하려면 &lt;a href=&quot;../do/index&quot;&gt;do&lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="52edb1931a7678b06f40d0f67216ea63d608c768" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;outerJoin&lt;/code&gt; is slower and much less efficient than using &lt;a href=&quot;../concat_map/index&quot;&gt;concatMap&lt;/a&gt; with &lt;a href=&quot;../get_all/index&quot;&gt;getAll&lt;/a&gt;. You should avoid using &lt;code&gt;outerJoin&lt;/code&gt; in commands when possible.</source>
          <target state="translated">참고 것을 &lt;code&gt;outerJoin&lt;/code&gt; 느린 사용하는 것보다 훨씬 효율적이다 &lt;a href=&quot;../concat_map/index&quot;&gt;concatMap을&lt;/a&gt; 함께 &lt;a href=&quot;../get_all/index&quot;&gt;를 getAll&lt;/a&gt; . 가능하면 명령에 &lt;code&gt;outerJoin&lt;/code&gt; 을 사용하지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="bd4b1c6ffc31ec1f99a87680dc2b303487664897" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;row&lt;/code&gt; does not work within subqueries to access nested documents; you should use anonymous functions to access those documents instead. (See the last example.)</source>
          <target state="translated">참고 &lt;code&gt;row&lt;/code&gt; 액세스 중첩 된 문서에 서브 쿼리 내에서 작동하지 않는다; 대신 익명 함수를 사용하여 해당 문서에 액세스해야합니다. (마지막 예 참조)</target>
        </trans-unit>
        <trans-unit id="d752e9b9c354ac26c00d43811dff01c2a8679e7b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;true&lt;/code&gt; in the example above is testing for the existence of &lt;code&gt;championships&lt;/code&gt; as a field, not testing to see if the value of the &lt;code&gt;championships&lt;/code&gt; field is set to &lt;code&gt;true&lt;/code&gt;. There&amp;rsquo;s a more convenient shorthand form available. (See &lt;a href=&quot;../pluck/index&quot;&gt;pluck&lt;/a&gt; for more details on this.)</source>
          <target state="translated">참고 &lt;code&gt;true&lt;/code&gt; 위의 예는 존재에 대해 테스트하는 &lt;code&gt;championships&lt;/code&gt; 아닌 값 있는지 테스트 필드로 &lt;code&gt;championships&lt;/code&gt; 필드로 설정 &lt;code&gt;true&lt;/code&gt; . 보다 편리한 속기 형식이 있습니다. (자세한 내용은 &lt;a href=&quot;../pluck/index&quot;&gt;pluck&lt;/a&gt; 을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="b95d53711950543d65d38ace0235593f05e863af" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;write_acks&lt;/code&gt; and &lt;code&gt;durability&lt;/code&gt; don&amp;rsquo;t actually affect how the write is performed; they only affect when the acknowledgement is sent back to the client.</source>
          <target state="translated">하는 것으로 &lt;code&gt;write_acks&lt;/code&gt; 및 &lt;code&gt;durability&lt;/code&gt; 실제로 쓰기가 수행되는 방식에 영향을주지 않습니다; 승인이 클라이언트로 다시 전송 될 때만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="7020586ba6fb68f8b3332682998d8be66b7d38f3" translate="yes" xml:space="preserve">
          <source>Note that a line between the north pole and south pole (from latitude &amp;minus;90 to latitude 90) cannot be calculated, as &lt;em&gt;all&lt;/em&gt; possible paths between them are the &amp;ldquo;shortest&amp;rdquo;; this may trigger an error in ReQL or it may choose an arbitrary (but technically correct) path.</source>
          <target state="translated">북극과 남극 (위도 -90에서 위도 90) 사이의 선은 계산할 수 없습니다. 이들 사이의 &lt;em&gt;모든&lt;/em&gt; 가능한 경로는 &quot;가장 짧습니다&quot;. 이로 인해 ReQL에서 오류가 발생하거나 임의의 (기술적으로 올바른) 경로를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="869310050eda36904b9b1684e375eea8a27df6a7" translate="yes" xml:space="preserve">
          <source>Note that an index may not be immediately available after creation. If your application needs to use indexes immediately after creation, use the &lt;a href=&quot;../index_wait/index&quot;&gt;indexWait&lt;/a&gt; command to ensure the indexes are ready before use.</source>
          <target state="translated">작성 후 색인을 즉시 사용하지 못할 수 있습니다. 응용 프로그램에서 생성 직후 인덱스를 사용해야하는 경우 &lt;a href=&quot;../index_wait/index&quot;&gt;indexWait&lt;/a&gt; 명령을 사용하여 인덱스를 사용하기 전에 준비하십시오.</target>
        </trans-unit>
        <trans-unit id="5633901ed522442fae34a2aee51f02c0e3f374cf" translate="yes" xml:space="preserve">
          <source>Note that both the official JavaScript driver and neumino&amp;rsquo;s &amp;ldquo;rethinkdbdash&amp;rdquo; driver are designed to work with Node.js.</source>
          <target state="translated">공식 JavaScript 드라이버와 neumino의 &quot;rethinkdbdash&quot;드라이버는 모두 Node.js와 함께 작동하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="cc7bb93e73f8b5f0f5aac10c43c2d4956feb9dc0" translate="yes" xml:space="preserve">
          <source>Note that by default, RethinkDB only opens connections bound to &lt;code&gt;localhost&lt;/code&gt; in order to prevent unauthorized clients on the network from connecting to the server. The &lt;code&gt;--bind all&lt;/code&gt; option allows connections from anywhere on the network. It works well if the network is protected.</source>
          <target state="translated">기본적으로 RethinkDB 는 네트워크의 인증되지 않은 클라이언트가 서버에 연결하지 못하도록 &lt;code&gt;localhost&lt;/code&gt; 에 바인딩 된 연결 만 엽니 다 . 는 &lt;code&gt;--bind all&lt;/code&gt; 옵션은 네트워크의 어느 곳에서나 연결을 할 수 있습니다. 네트워크가 보호되어 있으면 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="07fbecac98fcf0f3caf272d28683d05c9f00b5fe" translate="yes" xml:space="preserve">
          <source>Note that if you call &lt;a href=&quot;../../api/javascript/table/index&quot;&gt;table&lt;/a&gt; with &lt;code&gt;identifier_format&lt;/code&gt; set to &lt;code&gt;uuid&lt;/code&gt;, then references to servers, tables and databases in the &lt;code&gt;info&lt;/code&gt; subdocument will be UUIDs rather than names.</source>
          <target state="translated">전화 할 경우주의 &lt;a href=&quot;../../api/javascript/table/index&quot;&gt;테이블을&lt;/a&gt; 함께 &lt;code&gt;identifier_format&lt;/code&gt; 의 로 설정 &lt;code&gt;uuid&lt;/code&gt; , 다음의 서버, 테이블 및 데이터베이스에 대한 참조 &lt;code&gt;info&lt;/code&gt; 하위 문서가 UUID를 이름이 아닌 것이다.</target>
        </trans-unit>
        <trans-unit id="6ae89b9920878619801ec2ca89056fee59578b79" translate="yes" xml:space="preserve">
          <source>Note that if you didn&amp;rsquo;t call &lt;code&gt;ungroup&lt;/code&gt;, you would instead select one random game from each player:</source>
          <target state="translated">&lt;code&gt;ungroup&lt;/code&gt; 으로 전화하지 않았다면 대신 각 플레이어에서 하나의 무작위 게임을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="794a796e7f7b74c249460ac6df405541e4ffc7df" translate="yes" xml:space="preserve">
          <source>Note that in the last case, you&amp;rsquo;re required to provide a CA certificate as well. This is a certificate used to sign other certificates. In this case, we&amp;rsquo;re using the same certificate for both, but we could sign our &lt;code&gt;cert.pem&lt;/code&gt; with a different CA certificate and specify both of them. Servers can only connect to the cluster if the certificates specified by their &lt;code&gt;cluster-tls-cert&lt;/code&gt; value are signed by the CA certificate specified by &lt;code&gt;cluster-tls-ca&lt;/code&gt;.</source>
          <target state="translated">마지막 경우에는 CA 인증서도 제공해야합니다. 다른 인증서에 서명하는 데 사용되는 인증서입니다. 이 경우 두 인증서에 모두 동일한 인증서를 사용하지만 다른 CA 인증서로 &lt;code&gt;cert.pem&lt;/code&gt; 에 서명하고 두 인증서를 모두 지정할 수 있습니다. &lt;code&gt;cluster-tls-cert&lt;/code&gt; 값으로 지정된 인증서가 &lt;code&gt;cluster-tls-ca&lt;/code&gt; 로 지정된 CA 인증서로 서명 된 경우에만 서버가 클러스터에 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="69a530ba90750d307c78bffe12c73f7bc690c170" translate="yes" xml:space="preserve">
          <source>Note that in this case, &lt;a href=&quot;../row/index&quot;&gt;row&lt;/a&gt; may be used as an alternative to writing an anonymous function, as it returns the same value as the function parameter receives:</source>
          <target state="translated">이 경우 함수 매개 변수가받는 것과 동일한 값을 반환하므로 &lt;a href=&quot;../row/index&quot;&gt;행&lt;/a&gt; 은 익명 함수를 작성하는 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4d62e0a372be981e1086845747762fa68efdd64" translate="yes" xml:space="preserve">
          <source>Note that looping over a cursor must be done with &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;fetch_next&lt;/code&gt;, rather than using a &lt;code&gt;for x in cursor&lt;/code&gt; loop.</source>
          <target state="translated">&lt;code&gt;for x in cursor&lt;/code&gt; 루프 에서 for x를 사용하는 대신 &lt;code&gt;while&lt;/code&gt; 및 &lt;code&gt;fetch_next&lt;/code&gt; 로 커서를 반복해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f9631e710ce7fec5bb59199fdbb7bd3ffaa2b587" translate="yes" xml:space="preserve">
          <source>Note that passwords will be sent in plaintext unless you are using TLS encryption. Instead of (or in addition to) TLS, you can bind the driver port and use SSH tunneling, as described below.</source>
          <target state="translated">TLS 암호화를 사용하지 않는 한 비밀번호는 일반 텍스트로 전송됩니다. TLS 대신 (또는 그에 추가하여) 아래 설명 된대로 드라이버 포트를 바인딩하고 SSH 터널링을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="caab8be7c7ee8a44aad19ce23e3ceec991876422" translate="yes" xml:space="preserve">
          <source>Note that queries with &lt;code&gt;getAll&lt;/code&gt; or &lt;code&gt;between&lt;/code&gt; may return the same document multiple times unless you use the &lt;a href=&quot;../../../api/javascript/distinct/index&quot;&gt;distinct&lt;/a&gt; command.</source>
          <target state="translated">&lt;code&gt;getAll&lt;/code&gt; 을 사용 하거나 &lt;code&gt;between&lt;/code&gt; 있는 쿼리 는 &lt;a href=&quot;../../../api/javascript/distinct/index&quot;&gt;distinct&lt;/a&gt; 명령 을 사용하지 않으면 동일한 문서를 여러 번 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7c21b67930f527774bfd43705840df0f2b95c65" translate="yes" xml:space="preserve">
          <source>Note that rebuilding indexes is &lt;em&gt;not&lt;/em&gt; required if you&amp;rsquo;re upgrading between minor releases (i.e., 2.2.0 to 2.2.1).</source>
          <target state="translated">부 릴리스 (예 : 2.2.0에서 2.2.1)로 업그레이드하는 경우 인덱스를 다시 작성할 필요 가 &lt;em&gt;없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6f72e66b293b77e8428e776de4027ca58fa284cb" translate="yes" xml:space="preserve">
          <source>Note that server tags cannot be configured through RethinkDB&amp;rsquo;s web administration dashboard. They may be created and assigned through ReQL commands and scripts.</source>
          <target state="translated">서버 태그는 RethinkDB의 웹 관리 대시 보드를 통해 구성 할 수 없습니다. 그것들은 ReQL 명령과 스크립트를 통해 생성되고 할당 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82182344e60cfb2c08352c68670095dcbc4419cc" translate="yes" xml:space="preserve">
          <source>Note that tables are configured on creation and when the &lt;code&gt;reconfigure&lt;/code&gt; command is called, but the configurations are &lt;em&gt;not&lt;/em&gt; stored by the server otherwise. To reconfigure tables consistently&amp;mdash;especially if your configuration uses server tags&amp;mdash;you should save the configuration in a script. Read more about this in &lt;a href=&quot;../administration-tools/index&quot;&gt;Administration tools&lt;/a&gt;.</source>
          <target state="translated">테이블은 작성시와 &lt;code&gt;reconfigure&lt;/code&gt; 명령이 호출 될 때 구성되지만 구성은 서버에 의해 저장 &lt;em&gt;되지 않습니다&lt;/em&gt; . 특히 구성에서 서버 태그를 사용하는 경우 테이블을 일관되게 재구성하려면 구성을 스크립트에 저장해야합니다. 이에 대한 자세한 내용은 &lt;a href=&quot;../administration-tools/index&quot;&gt;관리 도구를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a9aa756264e1ece12b1221ef8bdfe0cf69fa30d7" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../now/index&quot;&gt;now&lt;/a&gt; command always returns UTC time, so the comparison may fail if &lt;code&gt;user(&quot;birthdate&quot;)&lt;/code&gt; isn&amp;rsquo;t also in UTC. You can use the &lt;a href=&quot;../in_timezone/index&quot;&gt;inTimezone&lt;/a&gt; command to adjust for this:</source>
          <target state="translated">(가) 있습니다 &lt;a href=&quot;../now/index&quot;&gt;지금&lt;/a&gt; 경우 비교가 실패 할 수 있도록 항상 명령은 UTC 시간을 반환하는 &lt;code&gt;user(&quot;birthdate&quot;)&lt;/code&gt; UTC도 없습니다. &lt;a href=&quot;../in_timezone/index&quot;&gt;inTimezone&lt;/a&gt; 명령을 사용하여 이를 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a7ac990a54eac51a8c5b0af1f5b7cf5ce6153d2" translate="yes" xml:space="preserve">
          <source>Note that the JavaScript driver strips time zone information due to limitations with the &lt;code&gt;Date&lt;/code&gt; object, although you can retrieve time zone data via the raw ReQL time object. (See below.)</source>
          <target state="translated">원시 ReQL 시간 개체를 통해 표준 시간대 데이터를 검색 할 수 있지만 JavaScript 드라이버는 &lt;code&gt;Date&lt;/code&gt; 개체의 제한으로 인해 표준 시간대 정보를 제거 합니다. (아래 참조)</target>
        </trans-unit>
        <trans-unit id="cf5a0befe8f4a2d2c04f639c1bc0ee0b7b9f3d58" translate="yes" xml:space="preserve">
          <source>Note that the left bound (including the implied left bound of 0 in the 0- and 1-argument form) is always closed and the right bound is always open: the start value will always be included in the returned range and the end value will &lt;em&gt;not&lt;/em&gt; be included in the returned range.</source>
          <target state="translated">왼쪽 경계 (0 및 1 인수 형식의 암시 적 왼쪽 경계 0 포함)는 항상 닫히고 오른쪽 경계는 항상 열려 있습니다. 시작 값은 항상 반환 된 범위에 포함되며 끝 값은 반환 된 범위에 포함 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8c2fd8bb823ff27914611ee376d7f11e792c0216" translate="yes" xml:space="preserve">
          <source>Note that the sequence being merged&amp;mdash;in this example, the comments&amp;mdash;must be coerced from a selection to an array. Without &lt;code&gt;coerceTo&lt;/code&gt; the operation will throw an error (&amp;ldquo;Expected type DATUM but found SELECTION&amp;rdquo;).</source>
          <target state="translated">이 예에서 주석과 병합되는 시퀀스는 선택에서 배열로 강제 변환되어야합니다. &lt;code&gt;coerceTo&lt;/code&gt; 가 없으면 작업에 오류가 발생합니다 ( &quot;예상 유형 DATUM이지만 발견됨&quot;).</target>
        </trans-unit>
        <trans-unit id="e98abad9a62e2bab40d6be837e719bce034e43c6" translate="yes" xml:space="preserve">
          <source>Note that the values for &lt;code&gt;author_id&lt;/code&gt; correspond to the &lt;code&gt;id&lt;/code&gt; field of the author, which allows us to link the documents.</source>
          <target state="translated">&lt;code&gt;author_id&lt;/code&gt; 의 값 은 저자 의 &lt;code&gt;id&lt;/code&gt; 필드에 해당하므로 문서를 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8ca43a4f1a4253668972ac4f388573e961d6210" translate="yes" xml:space="preserve">
          <source>Note that we first selected every author in the table, and then chained the &lt;code&gt;update&lt;/code&gt; command to the end of the query. We could also update a subset of documents by filtering the table first. Let&amp;rsquo;s update William Adama&amp;rsquo;s record to note that he has the rank of Admiral:</source>
          <target state="translated">먼저 테이블의 모든 작성자를 선택한 다음 &lt;code&gt;update&lt;/code&gt; 명령을 쿼리 끝에 연결했습니다 . 먼저 테이블을 필터링하여 문서의 하위 집합을 업데이트 할 수도 있습니다. 윌리엄 아다마 (William Adama)의 기록을 업데이트하여 제독 (Admiral) 계급을 보유하고 있음을 알아 봅시다.</target>
        </trans-unit>
        <trans-unit id="92ed5dd039e24ac49d654376ac966bb44a6b7f52" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;r.do()&lt;/code&gt; takes the function as its &lt;em&gt;last&lt;/em&gt; argument, &lt;code&gt;FUNCALL&lt;/code&gt; serializes the function as its &lt;em&gt;first&lt;/em&gt; argument.</source>
          <target state="translated">반면 참고 &lt;code&gt;r.do()&lt;/code&gt; 의 함수로서 얻어 &lt;em&gt;마지막&lt;/em&gt; 인자를 &lt;code&gt;FUNCALL&lt;/code&gt; 은 그와 같은 기능 직렬화 &lt;em&gt;제&lt;/em&gt; 인자.</target>
        </trans-unit>
        <trans-unit id="961048dc5c12584ceafa08e33e5c7ca4211def59" translate="yes" xml:space="preserve">
          <source>Note that you can omit the &lt;code&gt;db&lt;/code&gt; command if you&amp;rsquo;re creating a table in the default database on your connection (set to &lt;code&gt;test&lt;/code&gt; unless specified in &lt;code&gt;connect&lt;/code&gt;).</source>
          <target state="translated">연결시 기본 데이터베이스에 테이블을 작성하는 경우 ( &lt;code&gt;connect&lt;/code&gt; 에 지정되지 않은 경우 &lt;code&gt;test&lt;/code&gt; 하도록 설정) &lt;code&gt;db&lt;/code&gt; 명령을 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="02badbdd66f3ecc05d33efbafafd420cfaa47135" translate="yes" xml:space="preserve">
          <source>Note that you will not be able to read the &lt;code&gt;iterations&lt;/code&gt; value for an account; as it&amp;rsquo;s stored in the password field, it remains read-only.</source>
          <target state="translated">계정 의 &lt;code&gt;iterations&lt;/code&gt; 값 을 읽을 수는 없습니다 . 비밀번호 필드에 저장되므로 읽기 전용으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="5dbcb1737995d27923331529248e2e3554797023" translate="yes" xml:space="preserve">
          <source>Note that, due to the index being sorted lexicographically (and the fact that &lt;code&gt;between&lt;/code&gt; returns a single contiguous interval of rows), it would be possible to search for posts about &lt;code&gt;&quot;fun&quot;&lt;/code&gt; by any author but then it would not be possible to limit the time range (not without building a different index, of course).</source>
          <target state="translated">색인이 사전 순으로 정렬되기 때문에 (그리고 &lt;code&gt;between&lt;/code&gt; 은 연속 된 단일 행 간격을 반환 한다는 사실 ), 모든 작성자 가 &lt;code&gt;&quot;fun&quot;&lt;/code&gt; 에 대한 게시물을 검색 할 수는 있지만 제한 할 수는 없습니다. 시간 범위 (물론 다른 인덱스를 구축하지 않고서는 안 됨).</target>
        </trans-unit>
        <trans-unit id="8cb089f10f83d1ccdecb1a60a861bab8d0ee2602" translate="yes" xml:space="preserve">
          <source>Note the command line parameters we used to start the second node:</source>
          <target state="translated">두 번째 노드를 시작하는 데 사용한 명령 줄 매개 변수에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="44da02227d007949366a19f44ea67a15d04cf1dc" translate="yes" xml:space="preserve">
          <source>Note the id of the security group. It will start with &lt;code&gt;sg-&lt;/code&gt;.</source>
          <target state="translated">보안 그룹의 ID를 기록하십시오. &lt;code&gt;sg-&lt;/code&gt; 로 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="4be3a7d8983105ceac2d9d6226a9207c4e4a7f87" translate="yes" xml:space="preserve">
          <source>Note the port numbers you can use to access RethinkDB:</source>
          <target state="translated">RethinkDB에 액세스하는 데 사용할 수있는 포트 번호를 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="520bd0b12df7f31816c20ea08f041b38cd1efc9c" translate="yes" xml:space="preserve">
          <source>Note: Only alphanumeric characters and underscores are valid for the database name.</source>
          <target state="translated">참고 : 데이터베이스 이름에는 영숫자와 밑줄 만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="e4f1dfb495411f7c79397bcc72d7fc74a5c0836b" translate="yes" xml:space="preserve">
          <source>Note: The last argument given will always be the &amp;lsquo;open&amp;rsquo; side of the range, but when generating a floating-point number, the &amp;lsquo;open&amp;rsquo; side may be less than the &amp;lsquo;closed&amp;rsquo; side.</source>
          <target state="translated">참고 : 마지막으로 주어진 인수는 항상 범위의 '개방형'측이지만 부동 소수점 숫자를 생성 할 때 '개방형'측은 '폐쇄'측보다 적을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="ceb637042a0d9428c0df8add2990697098a05c47" translate="yes" xml:space="preserve">
          <source>Notes on connections</source>
          <target state="translated">연결에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="b4d5a0b9e73af6cd9b264bcafa717aeda3b8bd40" translate="yes" xml:space="preserve">
          <source>Now consider a larger example:</source>
          <target state="translated">이제 더 큰 예를 생각해보십시오.</target>
        </trans-unit>
        <trans-unit id="3a1aea1028da8d2cfbf3ca018738fc4dca263dc7" translate="yes" xml:space="preserve">
          <source>Now create an SSH tunnel on the server that needs to access the remote RethinkDB driver port:</source>
          <target state="translated">이제 원격 RethinkDB 드라이버 포트에 액세스해야하는 SSH 터널을 서버에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="36c86a37d15270331c5ca41f45f937ef93547855" translate="yes" xml:space="preserve">
          <source>Now for something more complicated: calculating the total and average quantities sold per item. For this, we&amp;rsquo;ll use the &lt;a href=&quot;https://rethinkdb.com/api/python/concat_map&quot;&gt;concat_map&lt;/a&gt; function, which combines mapping and concatenation together. In this case, we want to produce a sequence of all the items sold throughout all the orders with their item IDs and quantities. We&amp;rsquo;ll also add a &amp;ldquo;count&amp;rdquo; field set to &lt;code&gt;1&lt;/code&gt;; we&amp;rsquo;ll use this the same way we used the mapping of each post in the blog example.</source>
          <target state="translated">이제 더 복잡한 것은 아이템 당 판매 된 총 수량과 평균 수량을 계산하는 것입니다. 이를 위해 매핑과 연결을 결합한 &lt;a href=&quot;https://rethinkdb.com/api/python/concat_map&quot;&gt;concat_map&lt;/a&gt; 함수를 사용합니다 . 이 경우 모든 주문에서 판매 된 모든 품목을 품목 ID와 수량으로 순서대로 생성하려고합니다. 또한 &quot;count&quot;필드를 &lt;code&gt;1&lt;/code&gt; 로 설정합니다 . 블로그 예제에서 각 게시물의 매핑을 사용하는 것과 같은 방식으로이를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="83b7df19c7a7fab5f6f86d5d49556fd86a1c4ed9" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s access a real JSON API. In this example we&amp;rsquo;re going to use GitHub &amp;mdash; a collaborative development platform that hosts thousands of open-source projects. Users on GitHub can indicate interest by starring projects and following other users. GitHub calls users who starred other projects &amp;ldquo;stargazers&amp;rdquo;.</source>
          <target state="translated">이제 실제 JSON API에 액세스하십시오. 이 예에서는 수천 개의 오픈 소스 프로젝트를 호스팅하는 공동 개발 플랫폼 인 GitHub를 사용합니다. GitHub의 사용자는 프로젝트에 별표를 표시하고 다른 사용자를 팔로우하여 관심을 나타낼 수 있습니다. GitHub는 다른 프로젝트에 별표를 표시 한 사용자를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7e792f8e7d51655e21b3f588eca27d6ee4ec76c2" translate="yes" xml:space="preserve">
          <source>Now start the second RethinkDB instance on the same machine:</source>
          <target state="translated">이제 동일한 머신에서 두 번째 RethinkDB 인스턴스를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="c29ee53738e56f268012e978255da2e21fb2123f" translate="yes" xml:space="preserve">
          <source>Now switch back to your first terminal. We&amp;rsquo;ll be updating and deleting some documents in the next two sections. As we run these commands, the feed will push notifications to your program. The code above will print the following messages in the second terminal:</source>
          <target state="translated">이제 첫 번째 터미널로 다시 전환하십시오. 다음 두 섹션에서 일부 문서를 업데이트하고 삭제합니다. 이 명령을 실행하면 피드가 프로그램에 알림을 푸시합니다. 위의 코드는 두 번째 터미널에 다음 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="a233b26c262807902c4cc9fc0e713ee2a3c939fb" translate="yes" xml:space="preserve">
          <source>Now that we inserted some data, let&amp;rsquo;s see how we can query the database!</source>
          <target state="translated">이제 몇 가지 데이터를 삽입 했으므로 데이터베이스를 쿼리하는 방법을 알아 보겠습니다!</target>
        </trans-unit>
        <trans-unit id="8efdd3a96ed18374cd2b44f39375f891439bba62" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve installed the plugin, the next step is to actually configure it to connect to our RethinkDB instance. We can do that by talking to Elasticsearch&amp;rsquo;s REST API. There are three concepts we need to deal with in the API: indexes, types, and documents. A document is the actual data being stored itself and is just JSON. A type contains documents and is similar to a table in RethinkDB. An index contains types and is similar to a database in RethinkDB.</source>
          <target state="translated">이제 플러그인을 설치 했으므로 다음 단계는 실제로 RethinkDB 인스턴스에 연결하도록 플러그인을 구성하는 것입니다. Elasticsearch의 REST API와 대화하면 가능합니다. API에서 다루어야 할 개념은 인덱스, 유형 및 문서의 세 가지입니다. 문서는 실제로 저장되는 실제 데이터이며 JSON입니다. 유형은 문서를 포함하며 RethinkDB의 테이블과 유사합니다. 색인은 유형을 포함하며 RethinkDB의 데이터베이스와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="e816e64d8ebb842e4b0118841e17ba4aab267ea3" translate="yes" xml:space="preserve">
          <source>Now the coroutine will run in the background, printing out changes. When we alter the table, the changes will be noticed.</source>
          <target state="translated">이제 코 루틴이 백그라운드에서 실행되어 변경 사항을 인쇄합니다. 테이블을 변경하면 변경 사항이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="88579e11bba37adb2b24fcaf9dceaf04746ffa0d" translate="yes" xml:space="preserve">
          <source>Now the task will run in the background, printing out changes. When we alter the table, the changes will be noticed.</source>
          <target state="translated">이제 작업이 백그라운드에서 실행되어 변경 사항이 인쇄됩니다. 테이블을 변경하면 변경 사항이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="96aaeca03bd2a83f83cdc2012364ba4295826827" translate="yes" xml:space="preserve">
          <source>Now we can plug our changes directly into Rabbit:</source>
          <target state="translated">이제 변경 사항을 Rabbit에 직접 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cca3688c70abd6d885cd1f6703f8f921526df1a" translate="yes" xml:space="preserve">
          <source>Now we can publish any arbitrary JSON document to the topic:</source>
          <target state="translated">이제 임의의 JSON 문서를 주제에 게시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2399a2288ab147cdf7e8afafb71d676fc702e4fb" translate="yes" xml:space="preserve">
          <source>Now we need to &amp;ldquo;bind&amp;rdquo; the queue to the topics we&amp;rsquo;re interested in. Other listeners can subscribe to the same topic, and Rabbit will copy the message for every queue. Here, we&amp;rsquo;ll just keep it simple and bind to all events from &amp;ldquo;mytable&amp;rdquo;:</source>
          <target state="translated">이제 관심있는 주제에 대기열을&amp;ldquo;바인드&amp;rdquo;해야합니다. 다른 리스너는 동일한 주제에 가입 할 수 있으며 Rabbit은 모든 대기열에 대해 메시지를 복사합니다. 여기서는 간단하게 유지하고&amp;ldquo;mytable&amp;rdquo;의 모든 이벤트에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="0c8880d6597c3169973e8e1627a2c6d6907027cb" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;d like to sort RethinkDB stargazers by influence. When you request stargazers from GitHub, the GitHub API doesn&amp;rsquo;t include the number of followers for each stargazer, but it does include a field &lt;code&gt;url&lt;/code&gt; specific to each stargazer. If you follow this URL, the GitHub API will return additional information for the user, including the number of their followers.</source>
          <target state="translated">이제 RethinkDB stargazer를 영향별로 정렬하려고합니다. GitHub에서 stargazer를 요청하면 GitHub API에는 각 stargazer의 팔로어 수가 포함되지 않지만 각 stargazer에 고유 한 필드 &lt;code&gt;url&lt;/code&gt; 은 포함됩니다 . 이 URL을 따르면 GitHub API는 팔로어 수를 포함하여 사용자에 대한 추가 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1ceb299c25786316a08bb16460c9243fa1eec175" translate="yes" xml:space="preserve">
          <source>Now with a &amp;ldquo;clean&amp;rdquo; data set we can run simple reports right in the Data Explorer. (You might want to switch to Table View for some of these, and you can also add &lt;code&gt;.without('id')&lt;/code&gt; in the command chain to &amp;ldquo;prettify&amp;rdquo; the table display if you wish.)</source>
          <target state="translated">이제 &quot;깨끗한&quot;데이터 세트를 사용하여 데이터 탐색기에서 간단한 보고서를 바로 실행할 수 있습니다. (일부 테이블 뷰로 전환하고 싶을 때 명령 체인에 &lt;code&gt;.without('id')&lt;/code&gt; 를 추가하여 원하는 경우 테이블 디스플레이를 &quot;예비&quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9caa73cdf116b57684d6c1c8b8b9f44f4d600fcd" translate="yes" xml:space="preserve">
          <source>Now, consider a larger example.</source>
          <target state="translated">이제 더 큰 예를 생각해보십시오.</target>
        </trans-unit>
        <trans-unit id="afea3b1aecf0d259448b1b35c58dad9976a271d3" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s get those back:</source>
          <target state="translated">이제 다시 돌려 드리겠습니다 :</target>
        </trans-unit>
        <trans-unit id="e6ed379404867578a5a6db513257215a7d553130" translate="yes" xml:space="preserve">
          <source>Now, use one of the following two methods to enable secure access.</source>
          <target state="translated">이제 다음 두 가지 방법 중 하나를 사용하여 보안 액세스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fba0bbb4e77831e38e81b55c86757fe6c887f2ef" translate="yes" xml:space="preserve">
          <source>Now, we&amp;rsquo;ll &lt;code&gt;group&lt;/code&gt; by the &lt;code&gt;item_id&lt;/code&gt; field and use a custom &lt;code&gt;reduce&lt;/code&gt; function to sum the quantities and counts.</source>
          <target state="translated">이제, 우리는거야 &lt;code&gt;group&lt;/code&gt; 에 의해 &lt;code&gt;item_id&lt;/code&gt; 필드와 사용자 정의를 사용 &lt;code&gt;reduce&lt;/code&gt; 수량과 횟수를 요약하는 기능.</target>
        </trans-unit>
        <trans-unit id="c4dffe1e129e38cabba8445af4a117e656e614bc" translate="yes" xml:space="preserve">
          <source>Now, when any heroes are added, modified or deleted from either table, a change notification will be sent out.</source>
          <target state="translated">이제 영웅이 테이블에서 추가, 수정 또는 삭제되면 변경 알림이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="2c148f3b7dd44ba4e2ab9591ded50bd106dde2f1" translate="yes" xml:space="preserve">
          <source>Now, you can use ReQL commands to query system tables and perform reconfiguration commands. To return the server status, you can query the &lt;code&gt;server_status&lt;/code&gt; system table in the special &lt;code&gt;rethinkdb&lt;/code&gt; database.</source>
          <target state="translated">이제 ReQL 명령을 사용하여 시스템 테이블을 쿼리하고 재구성 명령을 수행 할 수 있습니다. 서버 상태를 리턴하기 위해 특수 &lt;code&gt;rethinkdb&lt;/code&gt; 데이터베이스 에서 &lt;code&gt;server_status&lt;/code&gt; 시스템 테이블을 조회 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85120bce76a23e361fb938c44bc73facc906afcd" translate="yes" xml:space="preserve">
          <source>ORMs</source>
          <target state="translated">ORMs</target>
        </trans-unit>
        <trans-unit id="9954b5cb646af3e1d62f8936ee802e399e164efe" translate="yes" xml:space="preserve">
          <source>OS X</source>
          <target state="translated">OS X</target>
        </trans-unit>
        <trans-unit id="9cf4af30df052d80876381f9ec0e05811ecd3d08" translate="yes" xml:space="preserve">
          <source>Objective-C</source>
          <target state="translated">Objective-C</target>
        </trans-unit>
        <trans-unit id="3868dbba6ab95babefa387180cf6de66e170f8ea" translate="yes" xml:space="preserve">
          <source>Official RethinkDB client drivers for Python, JavaScript, Java, and Ruby</source>
          <target state="translated">Python, JavaScript, Java 및 Ruby 용 공식 RethinkDB 클라이언트 드라이버</target>
        </trans-unit>
        <trans-unit id="74cdd5cbbd592f9b99c0f8d5979f1463f350d5ff" translate="yes" xml:space="preserve">
          <source>Official drivers</source>
          <target state="translated">공식 드라이버</target>
        </trans-unit>
        <trans-unit id="ebd6ec34f67b785d250d426fa00edef1acad05a5" translate="yes" xml:space="preserve">
          <source>Official packages</source>
          <target state="translated">공식 패키지</target>
        </trans-unit>
        <trans-unit id="831937a5ef9ec548ca483436b44fdfe4b969dfca" translate="yes" xml:space="preserve">
          <source>Older versions</source>
          <target state="translated">이전 버전</target>
        </trans-unit>
        <trans-unit id="d65b6345aa5b8fc44215a53289fccbbb539c6d88" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;false&lt;/code&gt;, the server will send an error and error code as above.</source>
          <target state="translated">에 &lt;code&gt;false&lt;/code&gt; , 서버는 위와 같이 오류 및 오류 코드를 보내드립니다.</target>
        </trans-unit>
        <trans-unit id="c1cebe4c7f1c61569d9257cc40cc35bbf81ae6de" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;false&lt;/code&gt;, the server will send an error and error code.</source>
          <target state="translated">에 &lt;code&gt;false&lt;/code&gt; , 서버는 오류 및 오류 코드를 보내드립니다.</target>
        </trans-unit>
        <trans-unit id="4412954aef37a85b9b6c203be268bc8e49fc7bc0" translate="yes" xml:space="preserve">
          <source>On &lt;strong&gt;failure,&lt;/strong&gt; the server sends a null-terminated error string (&lt;em&gt;not&lt;/em&gt; JSON).</source>
          <target state="translated">에 &lt;strong&gt;실패,&lt;/strong&gt; 서버는 널 종료 오류 문자열 (전송 &lt;em&gt;하지&lt;/em&gt; JSON을).</target>
        </trans-unit>
        <trans-unit id="f51347c7500404083d9d35f76646a95435173ff5" translate="yes" xml:space="preserve">
          <source>On &lt;strong&gt;success,&lt;/strong&gt; the server sends a null-terminated JSON response, indicating success, minimum and maximum protocol versions, and the server version.</source>
          <target state="translated">에 &lt;strong&gt;성공,&lt;/strong&gt; 서버는 성공, 최소 및 최대 프로토콜 버전 및 서버 버전을 나타내는 널 종료 JSON 응답을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="bb940d279b36ee1325e1f1b7715aa2df3888293b" translate="yes" xml:space="preserve">
          <source>On the &lt;a href=&quot;https://aws.amazon.com/marketplace/pp/B013R60Q8Y&quot;&gt;RethinkDB marketplace page&lt;/a&gt;, click the &lt;strong&gt;Continue&lt;/strong&gt; button.</source>
          <target state="translated">온 &lt;a href=&quot;https://aws.amazon.com/marketplace/pp/B013R60Q8Y&quot;&gt;RethinkDB 시장 페이지&lt;/a&gt; 의 클릭 &lt;strong&gt;계속&lt;/strong&gt; 버튼을 클릭합니다.</target>
        </trans-unit>
        <trans-unit id="b81c1cb3f1e6975a3ac220d8d48062c1f8158f69" translate="yes" xml:space="preserve">
          <source>Once RethinkDB is running, you can connect to it at &lt;a href=&quot;http://localhost:8080&quot;&gt;http://localhost:8080&lt;/a&gt;, assuming you&amp;rsquo;ve kept the default port (8080) and it&amp;rsquo;s running on your local machine.</source>
          <target state="translated">RethinkDB가 실행되면 기본 포트 (8080)를 유지하고 로컬 컴퓨터에서 실행 중이라고 가정 하고 &lt;a href=&quot;http://localhost:8080&quot;&gt;http : // localhost : 8080&lt;/a&gt; 에서 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ee24599fbbe748a6207ac5abb75b2f0ce146744" translate="yes" xml:space="preserve">
          <source>Once a server has been given a tag, the tags may be used to assign table replicas to servers with the same tags using the &lt;code&gt;reconfigure&lt;/code&gt; command. Read the section of this document on &lt;a href=&quot;#server-tags&quot;&gt;Server tags&lt;/a&gt; for more details.</source>
          <target state="translated">서버에 태그가 제공되면 태그를 사용하여 &lt;code&gt;reconfigure&lt;/code&gt; 명령을 사용하여 동일한 태그를 가진 서버에 테이블 복제본을 할당 할 수 있습니다 . 자세한 내용 은 &lt;a href=&quot;#server-tags&quot;&gt;서버 태그&lt;/a&gt; 에서이 문서의 섹션을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="e5540408974abb67910a41cc619a4fa95a13d057" translate="yes" xml:space="preserve">
          <source>Once the &lt;a href=&quot;https://rethinkdb.com/api/python/run&quot;&gt;run&lt;/a&gt; command is processed, the serialized query needs to be wrapped in the message sent to the server. The complete message takes the form:</source>
          <target state="translated">&lt;a href=&quot;https://rethinkdb.com/api/python/run&quot;&gt;실행&lt;/a&gt; 명령이 처리 되면 서버로 전송 된 메시지에서 직렬화 된 쿼리를 랩핑해야합니다. 완전한 메시지는 다음과 같은 형식을 취합니다.</target>
        </trans-unit>
        <trans-unit id="53bf8635a8710aec13732e6e69e7bc521527324f" translate="yes" xml:space="preserve">
          <source>Once the query is sent, you can read the response object back from the server. The response object takes the following form:</source>
          <target state="translated">조회가 전송되면 서버에서 응답 오브젝트를 다시 읽을 수 있습니다. 응답 오브젝트는 다음 형식을 취합니다.</target>
        </trans-unit>
        <trans-unit id="3581112a511227ecab2edb84928b539f7af5864d" translate="yes" xml:space="preserve">
          <source>Once you block the web interface port in the step above, the easiest way to access it is to use ssh to set up a SOCKS proxy. Run the following command on your local server (not the one running RethinkDB):</source>
          <target state="translated">위 단계에서 웹 인터페이스 포트를 차단하면 가장 쉬운 액세스 방법은 ssh를 사용하여 SOCKS 프록시를 설정하는 것입니다. 로컬 서버에서 다음 명령을 실행하십시오 (RethinkDB를 실행하는 명령 아님).</target>
        </trans-unit>
        <trans-unit id="d54a699f360387d75f05e3a07ed4952abe9ff92f" translate="yes" xml:space="preserve">
          <source>Once you have several machines in a RethinkDB cluster, you can improve your cluster&amp;rsquo;s efficiency by running a &lt;em&gt;proxy node&lt;/em&gt; on each application server and having the client application connect to the proxy on &lt;code&gt;localhost&lt;/code&gt;.</source>
          <target state="translated">RethinkDB 클러스터에 여러 머신이 있으면 각 애플리케이션 서버에서 &lt;em&gt;프록시 노드&lt;/em&gt; 를 실행 하고 클라이언트 애플리케이션을 &lt;code&gt;localhost&lt;/code&gt; 의 프록시에 연결 하여 클러스터의 효율성을 향상시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0dbb1fe10358fc30c28cd5763913addfac15ea73" translate="yes" xml:space="preserve">
          <source>Once you start using the &lt;code&gt;EventEmitter&lt;/code&gt; interface, the other RethinkDB cursor commands like &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;toArray&lt;/code&gt;, and &lt;code&gt;each&lt;/code&gt; will not be available anymore.</source>
          <target state="translated">당신이 사용하기 시작하면 &lt;code&gt;EventEmitter&lt;/code&gt; 의 인터페이스를 다른 RethinkDB 커서 명령 좋아 &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;toArray&lt;/code&gt; 를 , 그리고 &lt;code&gt;each&lt;/code&gt; 더 이상 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5e0cf5a9798cd7d0b4bee1fb0bc70175a34b8763" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve got the data in your Elasticsearch server, you&amp;rsquo;re ready to go. Here&amp;rsquo;s an example of a simple query using the Elasticsearch REST API:</source>
          <target state="translated">Elasticsearch 서버에 데이터가 있으면 준비가 된 것입니다. 다음은 Elasticsearch REST API를 사용하는 간단한 쿼리의 예입니다.</target>
        </trans-unit>
        <trans-unit id="91405022f24ea795a6deb7e4bd6123de31f00a95" translate="yes" xml:space="preserve">
          <source>One document exists in &lt;code&gt;db_config&lt;/code&gt; for each database in the cluster, with only two fields in the document.</source>
          <target state="translated">클러스터의 각 데이터베이스에 대해 하나의 문서가 &lt;code&gt;db_config&lt;/code&gt; 에 있으며 문서에는 두 개의 필드 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="1aefbe1f3a3edcbf196b9064f46c2b010b75a91e" translate="yes" xml:space="preserve">
          <source>One error in particular is notable. If you have a coroutine set to consume a changefeed indefinitely, and the connection closes, the coroutine will experience a &lt;code&gt;ReqlRuntimeError&lt;/code&gt;.</source>
          <target state="translated">특히 하나의 오류가 눈에.니다. 변경 피드를 무기한 소비하도록 설정된 코 루틴이 있고 연결이 닫히면 코 루틴에 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="f970864af19d41ebb8dfcca5915e187b5747d24e" translate="yes" xml:space="preserve">
          <source>One error in particular is notable. If you have a task that consumes a changefeed indefinitely, and the connection closes, the task will experience a &lt;code&gt;ReqlRuntimeError&lt;/code&gt;.</source>
          <target state="translated">특히 하나의 오류가 눈에.니다. 변경 피드를 무기한 소비하는 작업이 있고 연결이 닫히면 작업에 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="16aa2d8ea363974f203646459194020c667345ca" translate="yes" xml:space="preserve">
          <source>One more way to write the previous query is to set the age to be &lt;code&gt;-1&lt;/code&gt; when the field is missing.</source>
          <target state="translated">이전 쿼리를 작성하는 또 다른 방법 은 필드가 없을 때 &lt;code&gt;-1&lt;/code&gt; 로 설정하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c3e019a9ff633c6020fe2ace6839ac83a61316c9" translate="yes" xml:space="preserve">
          <source>One to many relations</source>
          <target state="translated">일대 다 관계</target>
        </trans-unit>
        <trans-unit id="99333c2702163735323c381df7d8fefff652b99b" translate="yes" xml:space="preserve">
          <source>One way to build the index would be:</source>
          <target state="translated">색인을 작성하는 한 가지 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2e0254c28e2b06c621fe3e5af23ceeb7e03e64e7" translate="yes" xml:space="preserve">
          <source>Ongoing</source>
          <target state="translated">Ongoing</target>
        </trans-unit>
        <trans-unit id="066193625de0ad53074bd617e05acb13fb7e193d" translate="yes" xml:space="preserve">
          <source>Only a limited subset of ReQL commands may be chained after &lt;code&gt;binary&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;binary&lt;/code&gt; 후에는 제한된 ReQL 명령의 하위 집합 만 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bddea468cb2adb77cc258c3b88f6e01f0752c0bc" translate="yes" xml:space="preserve">
          <source>Only longitude/latitude coordinates are supported. GeoJSON objects that use Cartesian coordinates, specify an altitude, or specify their own coordinate reference system will be rejected.</source>
          <target state="translated">경도 / 위도 좌표 만 지원됩니다. 직교 좌표를 사용하거나 고도를 지정하거나 자체 좌표 참조 시스템을 지정하는 GeoJSON 객체는 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="262b6559e88c687d15b623deba02fac703403295" translate="yes" xml:space="preserve">
          <source>Open a TCP connection to the server on the driver port. The default port is &lt;code&gt;28015&lt;/code&gt;.</source>
          <target state="translated">드라이버 포트에서 서버에 대한 TCP 연결을 엽니 다. 기본 포트는 &lt;code&gt;28015&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1c232e4ef552d94c7bc322934608dfd9c1f3678b" translate="yes" xml:space="preserve">
          <source>Open a connection</source>
          <target state="translated">연결을 엽니 다</target>
        </trans-unit>
        <trans-unit id="65160f68c4c399c8650355e13e625aa1a85b20f6" translate="yes" xml:space="preserve">
          <source>Open the &lt;strong&gt;Security Groups&lt;/strong&gt; section of the administration console.</source>
          <target state="translated">관리 콘솔 의 &lt;strong&gt;보안 그룹&lt;/strong&gt; 섹션을여십시오.</target>
        </trans-unit>
        <trans-unit id="3098205123cfb916f292fb3965082298a4ab6621" translate="yes" xml:space="preserve">
          <source>Open the RethinkDB Data Explorer in the web UI and execute the following command:</source>
          <target state="translated">웹 UI에서 RethinkDB Data Explorer를 열고 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="26e94e9d577c801c827b900c0b793db4e3600d97" translate="yes" xml:space="preserve">
          <source>OpenSSL will ask you to enter information for the certificate. While some of these questions can be left at their default, the &amp;ldquo;Common Name&amp;rdquo; must match the domain name of your server. For local testing purposes you can use &lt;code&gt;localhost&lt;/code&gt;, but not in production.</source>
          <target state="translated">OpenSSL은 인증서 정보를 입력하도록 요청합니다. 이러한 질문 중 일부는 기본값으로 남겨 둘 수 있지만 &quot;공통 이름&quot;은 서버의 도메인 이름과 일치해야합니다. 로컬 테스트 목적으로 &lt;code&gt;localhost&lt;/code&gt; 를 사용할 수 있지만 프로덕션에서는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="005f473987f60d5de30a1511d957a61d11d7b074" translate="yes" xml:space="preserve">
          <source>Opera 1.62 or higher</source>
          <target state="translated">오페라 1.62 이상</target>
        </trans-unit>
        <trans-unit id="800944565827543e19a120253438c1772df26425" translate="yes" xml:space="preserve">
          <source>Operations on authors and posts don&amp;rsquo;t require loading the data for every post for a given author into memory.</source>
          <target state="translated">작성자 및 게시물에 대한 작업은 지정된 작성자의 모든 게시물에 대한 데이터를 메모리에로드 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="67910125278b444143eb3baa7f7a144f98b62c28" translate="yes" xml:space="preserve">
          <source>Optimizing query performance</source>
          <target state="translated">쿼리 성능 최적화</target>
        </trans-unit>
        <trans-unit id="3c7b449b88c10330229439fe19c9db3e4b06af90" translate="yes" xml:space="preserve">
          <source>Optional arguments available with &lt;code&gt;circle&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;circle&lt;/code&gt; 과 함께 사용할 수있는 선택적 인수 는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e91d767910b702fe59c28c74e7779fc7e01b53ac" translate="yes" xml:space="preserve">
          <source>Optional arguments available with &lt;code&gt;distance&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;distance&lt;/code&gt; 와 함께 사용할 수있는 선택적 인수 는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="655dae8fdf9f43c66dc061c5ade6f0a366837031" translate="yes" xml:space="preserve">
          <source>Options for imports include:</source>
          <target state="translated">가져 오기 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52b7d82bd544399dc5fb544375b8f490d76aeee0" translate="yes" xml:space="preserve">
          <source>Options to &lt;code&gt;dump&lt;/code&gt; let you specify cluster information and limit the archive to specific databases or tables.</source>
          <target state="translated">&lt;code&gt;dump&lt;/code&gt; 옵션을 사용하면 클러스터 정보를 지정하고 아카이브를 특정 데이터베이스 또는 테이블로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c82e2b89585dcea4afe8d1cf12f407a6d9a9afae" translate="yes" xml:space="preserve">
          <source>Or create a secondary index on them:</source>
          <target state="translated">또는 보조 인덱스를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="76ee0a831a4163c3b30755e038356362dcf59b70" translate="yes" xml:space="preserve">
          <source>Or, Bob&amp;rsquo;s work phone and Skype handle:</source>
          <target state="translated">또는 Bob의 업무용 전화 및 Skype는 다음을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="dea3c588ab8bfc482b4550169db7672275347564" translate="yes" xml:space="preserve">
          <source>Or, let&amp;rsquo;s pluck out usernames and IDs, and sort the array in ascending order by user IDs:</source>
          <target state="translated">또는 사용자 이름과 ID를 뽑아 배열을 오름차순으로 사용자 ID별로 정렬 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="a8617c20d3ebc00ea8af63ceb4ece5ae885ba2bb" translate="yes" xml:space="preserve">
          <source>Or, let&amp;rsquo;s try to delete a single user:</source>
          <target state="translated">또는 단일 사용자를 삭제 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="517d47ffe448c40f8d65907d0e9bbb885347087a" translate="yes" xml:space="preserve">
          <source>Oracle Java 1.8.0 on the client nodes</source>
          <target state="translated">클라이언트 노드의 Oracle Java 1.8.0</target>
        </trans-unit>
        <trans-unit id="a67de582176ad1685ed737600c40cb806a9dc02a" translate="yes" xml:space="preserve">
          <source>Order by date and title.</source>
          <target state="translated">날짜와 제목으로 주문하십시오.</target>
        </trans-unit>
        <trans-unit id="1d3437a75ca6256f37c2450c0c776fb565f1c788" translate="yes" xml:space="preserve">
          <source>Ordering without an index requires the server to load the whole sequence in an array, which is limited by default to 100,000 documents. You can use the &lt;code&gt;arrayLimit&lt;/code&gt; option to &lt;a href=&quot;../../api/javascript/run/index&quot;&gt;run&lt;/a&gt; to temporarily raise this limit. However, a more efficient option is to use an index. See the documentation for &lt;a href=&quot;../../api/javascript/order_by/index&quot;&gt;orderBy&lt;/a&gt; for more information.</source>
          <target state="translated">색인없이 주문하려면 서버가 전체 시퀀스를 배열로로드해야하며, 기본적으로 100,000 개의 문서로 제한됩니다. &lt;code&gt;arrayLimit&lt;/code&gt; 옵션을 사용 하여이 한계를 일시적으로 높이기 위해 &lt;a href=&quot;../../api/javascript/run/index&quot;&gt;실행할&lt;/a&gt; 수 있습니다 . 그러나보다 효율적인 옵션은 인덱스를 사용하는 것입니다. 자세한 내용은 &lt;a href=&quot;../../api/javascript/order_by/index&quot;&gt;orderBy&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0635fe7d51a8df49e7a657f79a8f6473abb466ab" translate="yes" xml:space="preserve">
          <source>Organizing by value with &lt;strong&gt;multi&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;멀티&lt;/strong&gt; 를 이용한 가치 구성&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="02920c862ccbff6d9ea90f0249e6739c73f53be8" translate="yes" xml:space="preserve">
          <source>Other architectures</source>
          <target state="translated">다른 아키텍처</target>
        </trans-unit>
        <trans-unit id="bc1c9b417f89fe542bb1934f83a9192b283b0bb0" translate="yes" xml:space="preserve">
          <source>Other tables</source>
          <target state="translated">다른 테이블</target>
        </trans-unit>
        <trans-unit id="2650dbe4bcd4f307dc4c1b316b876d711322bfab" translate="yes" xml:space="preserve">
          <source>Other things that might be helpful to us, if you have them:</source>
          <target state="translated">도움이 될만한 다른 것들이 있다면 :</target>
        </trans-unit>
        <trans-unit id="866131f1f2375ca571ce12c268e0c656ecbc12e4" translate="yes" xml:space="preserve">
          <source>Other unusual configuration details</source>
          <target state="translated">다른 특이한 구성 세부 사항</target>
        </trans-unit>
        <trans-unit id="3f6f6d94cdfb57598370b4d3559b5ea5baf371fc" translate="yes" xml:space="preserve">
          <source>Otherwise, a document was updated from &lt;code&gt;new_val&lt;/code&gt; to &lt;code&gt;old_val&lt;/code&gt;</source>
          <target state="translated">그렇지 않으면, 문서에서 업데이트 된 &lt;code&gt;new_val&lt;/code&gt; 에 &lt;code&gt;old_val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="635983c30fa94cc702bf5a3063575de06b27f6c0" translate="yes" xml:space="preserve">
          <source>Our first workload from YCSB is workload A. It performs an equal number of get and update operations.</source>
          <target state="translated">YCSB의 첫 번째 워크로드는 워크로드 A입니다. 동일한 수의 가져 오기 및 업데이트 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c3102dfdc420ea7f4b95502211100be74c8d001e" translate="yes" xml:space="preserve">
          <source>Our long-term goal is to port RethinkDB to every widely-used platform. &lt;a href=&quot;https://rethinkdb.com/community/&quot;&gt;Get involved&lt;/a&gt; in the development effort and help port RethinkDB to more platforms.</source>
          <target state="translated">우리의 장기적인 목표는 RethinkDB를 널리 사용되는 모든 플랫폼으로 이식하는 것입니다. 개발 노력에 &lt;a href=&quot;https://rethinkdb.com/community/&quot;&gt;참여&lt;/a&gt; 하고 RethinkDB를 더 많은 플랫폼으로 이식하십시오.</target>
        </trans-unit>
        <trans-unit id="9d27e01bc1f16af9ab5b684bbca08e77d04c7441" translate="yes" xml:space="preserve">
          <source>Outdated index issues</source>
          <target state="translated">오래된 인덱스 문제</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="7daf403c7589f4927632ed3b6af762a992f09b78" translate="yes" xml:space="preserve">
          <source>PHP</source>
          <target state="translated">PHP</target>
        </trans-unit>
        <trans-unit id="100325b8d6de92dc6ff09cd2c078133755bf274f" translate="yes" xml:space="preserve">
          <source>Pagination</source>
          <target state="translated">Pagination</target>
        </trans-unit>
        <trans-unit id="1ad9f67d0f855f646efb3775c7a4778a3cc5a138" translate="yes" xml:space="preserve">
          <source>Parallelism</source>
          <target state="translated">Parallelism</target>
        </trans-unit>
        <trans-unit id="a3f2f9b464ffd6a075b16b138e68eee36eb4fad2" translate="yes" xml:space="preserve">
          <source>Parse a JSON string on the server.</source>
          <target state="translated">서버에서 JSON 문자열을 구문 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="a02cd3149b8489d7554699018bd6802639a0fb15" translate="yes" xml:space="preserve">
          <source>Parsing RethinkDB&amp;rsquo;s response to a write query</source>
          <target state="translated">쓰기 쿼리에 대한 RethinkDB의 응답 구문 분석</target>
        </trans-unit>
        <trans-unit id="d5ed1ca0e30841762087801ad0ea2356bf068bd4" translate="yes" xml:space="preserve">
          <source>Passport</source>
          <target state="translated">Passport</target>
        </trans-unit>
        <trans-unit id="a6ef67119795d1dec2733382dde8851959466fd2" translate="yes" xml:space="preserve">
          <source>Password hashing iterations</source>
          <target state="translated">비밀번호 해시 반복</target>
        </trans-unit>
        <trans-unit id="602f708ddfd2f5c04ef6214f07b92793c6440c57" translate="yes" xml:space="preserve">
          <source>Pastie app</source>
          <target state="translated">페이스트리 앱</target>
        </trans-unit>
        <trans-unit id="9ee3e3fb749ad0b1c61fd33d63af73925ef460d8" translate="yes" xml:space="preserve">
          <source>Perform a branching conditional equivalent to &lt;code&gt;if-then-else&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;if-then-else&lt;/code&gt; 와 동등한 분기 조건을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="efb5dcdc44fc2c6fa0229180b4ba0e6617436df4" translate="yes" xml:space="preserve">
          <source>Perform a handshake</source>
          <target state="translated">악수를 수행</target>
        </trans-unit>
        <trans-unit id="31d145708b03b1271ba67061462d8bf7d2aa9ca6" translate="yes" xml:space="preserve">
          <source>Performance Details</source>
          <target state="translated">성능 세부 사항</target>
        </trans-unit>
        <trans-unit id="d8de1447c9bf3acce93c7e508a1c29a20555687a" translate="yes" xml:space="preserve">
          <source>Performance report</source>
          <target state="translated">성과 보고서</target>
        </trans-unit>
        <trans-unit id="1a7039a0fe11cfbcaf911a9186d34c5c3a09eeb8" translate="yes" xml:space="preserve">
          <source>Performing a conditional insert or replace</source>
          <target state="translated">조건부 삽입 또는 교체 수행</target>
        </trans-unit>
        <trans-unit id="933b62ca112baccc2befe203fa03de8a89c72068" translate="yes" xml:space="preserve">
          <source>Performing a pivot operation</source>
          <target state="translated">피벗 작업 수행</target>
        </trans-unit>
        <trans-unit id="a9d4d7d7d35c4a76ac97d509252cf3e581c5e1dc" translate="yes" xml:space="preserve">
          <source>Performing an unpivot operation</source>
          <target state="translated">피벗 해제 작업 수행</target>
        </trans-unit>
        <trans-unit id="c0bc0b17b999bff2f1cc8b8c30efeb6034e0c0a9" translate="yes" xml:space="preserve">
          <source>Performing multiple aggregations simultaneously</source>
          <target state="translated">여러 집계를 동시에 수행</target>
        </trans-unit>
        <trans-unit id="a03eb97735ec7717f1d64f293267ac389abb2754" translate="yes" xml:space="preserve">
          <source>Performs 200 million operations in total</source>
          <target state="translated">총 2 억 건의 작업 수행</target>
        </trans-unit>
        <trans-unit id="1f85efe74af8d3b3506a24e9543f0465c2109af2" translate="yes" xml:space="preserve">
          <source>Performs 50 million operations in total</source>
          <target state="translated">총 5 천만 건의 작업 수행</target>
        </trans-unit>
        <trans-unit id="f111d810e7ca920bda8f128569fc002610c45314" translate="yes" xml:space="preserve">
          <source>Perl</source>
          <target state="translated">Perl</target>
        </trans-unit>
        <trans-unit id="d06d55570938d12f87db3bf2b48caa9de22d9c67" translate="yes" xml:space="preserve">
          <source>Permissions</source>
          <target state="translated">Permissions</target>
        </trans-unit>
        <trans-unit id="627aed65a0d9d2626caf51bb839dcee691e75d17" translate="yes" xml:space="preserve">
          <source>Permissions and user accounts</source>
          <target state="translated">권한 및 사용자 계정</target>
        </trans-unit>
        <trans-unit id="0ac88ea84587ef82d96b641061e89b7e0e66ff2c" translate="yes" xml:space="preserve">
          <source>Permissions are stored in the &lt;code&gt;permissions&lt;/code&gt; system table. While you can change permissions by modifying documents within that table, it&amp;rsquo;s far more convenient to use the &lt;a href=&quot;#the-grant-command&quot;&gt;grant&lt;/a&gt; command; see below.</source>
          <target state="translated">권한은 &lt;code&gt;permissions&lt;/code&gt; 시스템 테이블에 저장됩니다 . 해당 테이블 내에서 문서를 수정하여 권한을 변경할 수 있지만 &lt;a href=&quot;#the-grant-command&quot;&gt;grant&lt;/a&gt; 명령 을 사용하는 것이 훨씬 편리합니다 . 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bf871a8778973cc849027508cdc967888db0dc66" translate="yes" xml:space="preserve">
          <source>Permissions may be granted on a global scope, or granted for a specific table or database. The scope is defined by calling &lt;code&gt;grant&lt;/code&gt; on its own (e.g., &lt;code&gt;r.grant()&lt;/code&gt;, on a table (&lt;code&gt;r.table().grant()&lt;/code&gt;), or on a database (&lt;code&gt;r.db().grant()&lt;/code&gt;).</source>
          <target state="translated">전역 범위에서 권한을 부여하거나 특정 테이블 또는 데이터베이스에 대해 권한을 부여 할 수 있습니다. 범위는 그 자체로 &lt;code&gt;grant&lt;/code&gt; (예 : &lt;code&gt;r.grant()&lt;/code&gt; , 테이블 ( &lt;code&gt;r.table().grant()&lt;/code&gt; ) 또는 데이터베이스 ( &lt;code&gt;r.db().grant()&lt;/code&gt; ) )를 호출 하여 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="eb767066d9789af7d92101acfb56fb7687bff20c" translate="yes" xml:space="preserve">
          <source>Permissions specified at a lower level will override permissions set at a higher level: a user could be granted read and write access to the &lt;code&gt;field_notes&lt;/code&gt; database, but denied the ability to write to the &lt;code&gt;calendar&lt;/code&gt; table and to either read or write to the &lt;code&gt;supervisor_only&lt;/code&gt; table.</source>
          <target state="translated">하위 수준에서 지정된 권한은 상위 수준에서 설정된 권한보다 우선합니다. 사용자에게는 &lt;code&gt;field_notes&lt;/code&gt; 데이터베이스에 대한 읽기 및 쓰기 권한이 부여 될 수 있지만 &lt;code&gt;calendar&lt;/code&gt; 테이블에 쓰고 &lt;code&gt;supervisor_only&lt;/code&gt; 테이블 에 대한 쓰기 또는 쓰기 기능은 거부 됩니다.</target>
        </trans-unit>
        <trans-unit id="d15069fb8e15cad486a5d82a9690982408a75b0e" translate="yes" xml:space="preserve">
          <source>Permissions that are not defined on a local scope will be inherited from the next largest scope. For example, a write operation on a table will first check if &lt;code&gt;write&lt;/code&gt; permissions are explicitly set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; for that table and account combination; if they are not, the &lt;code&gt;write&lt;/code&gt; permissions for the database will be used if those are explicitly set; and if neither table nor database permissions are set for that account, the global &lt;code&gt;write&lt;/code&gt; permissions for that account will be used.</source>
          <target state="translated">로컬 범위에 정의되지 않은 권한은 다음으로 큰 범위에서 상속됩니다. 예를 들어, 테이블에 대한 쓰기 작업은 먼저 해당 테이블과 계정 조합에 대해 &lt;code&gt;write&lt;/code&gt; 권한이 명시 적으로 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 로 설정되어 있는지 확인합니다 . 그렇지 않은 경우 데이터베이스에 대한 &lt;code&gt;write&lt;/code&gt; 권한이 명시 적으로 설정된 경우 사용됩니다. 해당 계정에 대해 테이블 ​​및 데이터베이스 권한이 설정되지 않은 경우 해당 계정에 대한 전역 &lt;code&gt;write&lt;/code&gt; 권한이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b965dd6fc2b3bcbc619861e8015982b2b31bc638" translate="yes" xml:space="preserve">
          <source>Please take into consideration when you generating version 5 UUIDs can&amp;rsquo;t be considered guaranteed unique if they&amp;rsquo;re computing based on user data because they use SHA-1 algorithm.</source>
          <target state="translated">버전 5 UUID를 생성 할 때 SHA-1 알고리즘을 사용하기 때문에 사용자 데이터를 기반으로 계산하는 경우 고유 한 것으로 간주 될 수 없다는 점을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="7b2206d37e61c7b1012ffbefa3c983e86a032077" translate="yes" xml:space="preserve">
          <source>Plucks one or more attributes from a sequence of objects, filtering out any objects in the sequence that do not have the specified fields. Functionally, this is identical to &lt;a href=&quot;../has_fields/index&quot;&gt;hasFields&lt;/a&gt; followed by &lt;a href=&quot;../pluck/index&quot;&gt;pluck&lt;/a&gt; on a sequence.</source>
          <target state="translated">지정된 필드가없는 시퀀스의 객체를 필터링하여 일련의 객체에서 하나 이상의 속성을 가져옵니다. 기능적으로, 이는 동일 &lt;a href=&quot;../has_fields/index&quot;&gt;hasFields는&lt;/a&gt; 다음 &lt;a href=&quot;../pluck/index&quot;&gt;뽑는다&lt;/a&gt; 시퀀스에.</target>
        </trans-unit>
        <trans-unit id="a7461725c3e122f101426f35a2e66d9ba3287681" translate="yes" xml:space="preserve">
          <source>Plucks one or more attributes from a sequence of objects, filtering out any objects in the sequence that do not have the specified fields. Functionally, this is identical to &lt;a href=&quot;has_fields/index&quot;&gt;hasFields&lt;/a&gt; followed by &lt;a href=&quot;pluck/index&quot;&gt;pluck&lt;/a&gt; on a sequence.</source>
          <target state="translated">지정된 필드가없는 시퀀스의 객체를 필터링하여 일련의 객체에서 하나 이상의 속성을 가져옵니다. 기능적으로, 이는 동일 &lt;a href=&quot;has_fields/index&quot;&gt;hasFields는&lt;/a&gt; 다음 &lt;a href=&quot;pluck/index&quot;&gt;뽑는다&lt;/a&gt; 시퀀스에.</target>
        </trans-unit>
        <trans-unit id="4550e37a008aa8641c291ddb18c860428af08805" translate="yes" xml:space="preserve">
          <source>Plucks out one or more attributes from either an object or a sequence of objects (projection).</source>
          <target state="translated">객체 또는 일련의 객체 (투영)에서 하나 이상의 속성을 뽑습니다.</target>
        </trans-unit>
        <trans-unit id="59a24e502e21080856136622628d2c36a365ff13" translate="yes" xml:space="preserve">
          <source>Point (single document) changefeeds</source>
          <target state="translated">포인트 (단일 문서) 변경 피드</target>
        </trans-unit>
        <trans-unit id="d82fa8e3ba9ed2db42802966c34a79c79ec35e10" translate="yes" xml:space="preserve">
          <source>Point your browser to &lt;code&gt;localhost:8080&lt;/code&gt;. You&amp;rsquo;ll see an administrative UI where you can control the cluster (which so far consists of one server), and play with the query language.</source>
          <target state="translated">브라우저를 &lt;code&gt;localhost:8080&lt;/code&gt; 으로 지정하십시오 . 서버를 구성하는 클러스터를 제어하고 쿼리 언어로 재생할 수있는 관리 UI가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d6fedcfcdb0a32752d9ea03a839178f433515d36" translate="yes" xml:space="preserve">
          <source>Point your browser to the HTTP connections port (&lt;code&gt;8080&lt;/code&gt; by default) to access the web interface.</source>
          <target state="translated">웹 인터페이스에 액세스하려면 브라우저를 HTTP 연결 포트 ( 기본적으로 &lt;code&gt;8080&lt;/code&gt; )로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="a4a871ea0a8e57174881c9b4bf86e9bb052c9f69" translate="yes" xml:space="preserve">
          <source>Polygons can also have holes in them, created when a polygon entirely enclosed by another one is &amp;ldquo;punched out&amp;rdquo; of the larger one using the &lt;code&gt;polygonSub&lt;/code&gt; command. (This is the only way to create a polygon with a hole in it.)</source>
          <target state="translated">또한 다각형에는 다른 다각형으로 완전히 둘러싸인 다각형이 &lt;code&gt;polygonSub&lt;/code&gt; 명령을 사용하여 더 큰 다각형에서 &quot;펀칭&quot;될 때 생성되는 구멍이있을 수 있습니다 . 구멍이있는 다각형을 만드는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="606d1d5e59fa1b7b6ee0fae6e5cdc98754db92b8" translate="yes" xml:space="preserve">
          <source>Port 22 is for SSH. The server uses public key authentication.</source>
          <target state="translated">포트 22는 SSH 용입니다. 서버는 공개 키 인증을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="167dacf7578e199e55dd6313fc9876a5b1867b79" translate="yes" xml:space="preserve">
          <source>Port 28015 is for client driver access. The only form of authentication is a key that is sent in plain text over the network.</source>
          <target state="translated">포트 28015는 클라이언트 드라이버 액세스를위한 것입니다. 인증의 유일한 형식은 네트워크를 통해 일반 텍스트로 전송되는 키입니다.</target>
        </trans-unit>
        <trans-unit id="6122f7270d7d535ad95a3aec4e825c2e02f9c751" translate="yes" xml:space="preserve">
          <source>Port 443 is for HTTPS. An Nginx server sits between RethinkDB and the world and provides basic HTTP authentication and secure HTTPS connections for the web UI.</source>
          <target state="translated">포트 443은 HTTPS 용입니다. Nginx 서버는 RethinkDB와 전세계에 위치하며 웹 UI를위한 기본 HTTP 인증 및 보안 HTTPS 연결을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f5c666906c3424aaf3e0422d4c7fc73f92951d6e" translate="yes" xml:space="preserve">
          <source>Port 80 is for HTTP. It is used during the setup process but otherwise redirects to HTTPS.</source>
          <target state="translated">포트 80은 HTTP 용입니다. 설정 과정에서 사용되지만 HTTPS로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="687986e409c97687863566c17cb109678af9b482" translate="yes" xml:space="preserve">
          <source>Port: &lt;code&gt;3000&lt;/code&gt;</source>
          <target state="translated">포트 : &lt;code&gt;3000&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5333d3c84dc8377268cd686f0cc959419711b637" translate="yes" xml:space="preserve">
          <source>Predicates to &lt;code&gt;filter&lt;/code&gt; are evaluated on the server, and must use ReQL expressions. You cannot use standard JavaScript comparison operators such as &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;/&lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;/&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; 할 술어 는 서버에서 평가되며 ReQL 표현식을 사용해야합니다. &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; / &lt;code&gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 와 같은 표준 JavaScript 비교 연산자를 사용할 수 없습니다 / &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d574e84514abeecdd6ac66fa898f6addb4221b4" translate="yes" xml:space="preserve">
          <source>Prepend a value to an array.</source>
          <target state="translated">배열 앞에 값을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="7f22ba753489d7e920e259cf09c81b2c3d9c5597" translate="yes" xml:space="preserve">
          <source>Produce a single value from a sequence through repeated application of a reduction function.</source>
          <target state="translated">축소 함수를 반복적으로 적용하여 시퀀스에서 단일 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d9f525bfecb73d82d2f90a76e5e52925c8bfb8b8" translate="yes" xml:space="preserve">
          <source>Produces a non-existence error when called on an empty sequence. You can handle this case with &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">빈 시퀀스에서 호출 될 때 존재하지 않는 오류를 생성합니다. 이 경우는 &lt;code&gt;default&lt;/code&gt; 로 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="9015371a0d33ee422afb2ea58ff543ac4c16f19b" translate="yes" xml:space="preserve">
          <source>Provide a default value in case of non-existence errors. The &lt;code&gt;default&lt;/code&gt; command evaluates its first argument (the value it&amp;rsquo;s chained to). If that argument returns &lt;code&gt;null&lt;/code&gt; or a non-existence error is thrown in evaluation, then &lt;code&gt;default&lt;/code&gt; returns its second argument. The second argument is usually a default value, but it can be a function that returns a value.</source>
          <target state="translated">존재하지 않는 오류의 경우 기본값을 제공하십시오. &lt;code&gt;default&lt;/code&gt; 명령은 첫 번째 인수 (이 묶여있어 값)을 평가한다. 해당 인수가 &lt;code&gt;null&lt;/code&gt; 하거나 존재하지 않는 오류가 평가에서 발생하면 &lt;code&gt;default&lt;/code&gt; 으로 두 번째 인수를 리턴합니다. 두 번째 인수는 일반적으로 기본값이지만 값을 반환하는 함수일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a2793cd5e2cebdd699874e60337368ad4c7f0e4" translate="yes" xml:space="preserve">
          <source>Proxy nodes</source>
          <target state="translated">프록시 노드</target>
        </trans-unit>
        <trans-unit id="35cd7f9cdee7e3c5423c4f68b7a5a738e7ee908a" translate="yes" xml:space="preserve">
          <source>Publish-Subscribe</source>
          <target state="translated">Publish-Subscribe</target>
        </trans-unit>
        <trans-unit id="d74d06bbc20ee3a59b09c01526b467c887af9167" translate="yes" xml:space="preserve">
          <source>Publish-Subscribe with RethinkDB</source>
          <target state="translated">RethinkDB를 사용한 게시-구독</target>
        </trans-unit>
        <trans-unit id="08ab1df032a5bfbbddcde416cd9683a3da9a8034" translate="yes" xml:space="preserve">
          <source>Publish-subscribe</source>
          <target state="translated">Publish-subscribe</target>
        </trans-unit>
        <trans-unit id="9c416ee884bbd4d8e89a95d4c023e9b2eff57f5f" translate="yes" xml:space="preserve">
          <source>Pushing changes to RabbitMQ</source>
          <target state="translated">RabbitMQ로 변경 사항 푸시</target>
        </trans-unit>
        <trans-unit id="c148aded3d47eba6bad059e92b2038d207b0a750" translate="yes" xml:space="preserve">
          <source>Putting it all together</source>
          <target state="translated">함께 모아서</target>
        </trans-unit>
        <trans-unit id="6e3604888c4b4ec08e2837913d012fe2834ffa83" translate="yes" xml:space="preserve">
          <source>Python</source>
          <target state="translated">Python</target>
        </trans-unit>
        <trans-unit id="49cfc0fae0169e4b63343a3e789527ea52375294" translate="yes" xml:space="preserve">
          <source>Python driver</source>
          <target state="translated">파이썬 드라이버</target>
        </trans-unit>
        <trans-unit id="d82cabe971317809828edbfbe4a5e9612ec586ff" translate="yes" xml:space="preserve">
          <source>Python libraries</source>
          <target state="translated">파이썬 라이브러리</target>
        </trans-unit>
        <trans-unit id="c56ac30b14c8764fec5b5b70036659f9b693a5b5" translate="yes" xml:space="preserve">
          <source>Python with Tornado or Twisted</source>
          <target state="translated">토네이도 또는 꼬인 파이썬</target>
        </trans-unit>
        <trans-unit id="bacc89e7a944a342361ad407e50c1bdc4adbb60e" translate="yes" xml:space="preserve">
          <source>Queries for accessing authors and posts tend to be simpler.</source>
          <target state="translated">저자와 게시물에 액세스하는 쿼리는 더 간단한 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a23e1f2ab29b58922510028cdd1e93bcff6daa1" translate="yes" xml:space="preserve">
          <source>Queries in detail</source>
          <target state="translated">상세하게 쿼리</target>
        </trans-unit>
        <trans-unit id="6ed8d030024e173cbdfaacb35d2c5b9fe1de254d" translate="yes" xml:space="preserve">
          <source>Query (read and/or update) the configurations for individual tables or databases.</source>
          <target state="translated">개별 테이블 또는 데이터베이스의 구성을 쿼리 (읽기 및 / 또는 업데이트)합니다.</target>
        </trans-unit>
        <trans-unit id="2dd43bff670fb4443641b638e91c3a1e2666b727" translate="yes" xml:space="preserve">
          <source>Query Runtime (seconds)</source>
          <target state="translated">쿼리 런타임 (초)</target>
        </trans-unit>
        <trans-unit id="90479d900b8bfaebff69bef7c1e6f5e4acf525cc" translate="yes" xml:space="preserve">
          <source>Query execution</source>
          <target state="translated">쿼리 실행</target>
        </trans-unit>
        <trans-unit id="89912ace151473384dc0a610242cf6f97eff4e6b" translate="yes" xml:space="preserve">
          <source>Query optimization</source>
          <target state="translated">쿼리 최적화</target>
        </trans-unit>
        <trans-unit id="c40c0a7ff9b0eb9e3f2b0a13a19b9c280e41d151" translate="yes" xml:space="preserve">
          <source>Query types: 50% single-document read ops, 50% single-document update ops</source>
          <target state="translated">쿼리 유형 : 단일 문서 읽기 작업 50 %, 단일 문서 업데이트 작업 50 %</target>
        </trans-unit>
        <trans-unit id="aaa9e9974cdedcdc0d68a460b12895753d966e0f" translate="yes" xml:space="preserve">
          <source>Query types: Count the total number of sentences over a single field: table.map(r.row(&amp;ldquo;field0&amp;rdquo;).split(&amp;ldquo;.&amp;rdquo;).count()).sum()</source>
          <target state="translated">쿼리 유형 : 단일 필드의 총 문장 수를 계산합니다. table.map (r.row (&amp;ldquo;field0&amp;rdquo;). split (&amp;ldquo;.&amp;rdquo;). count ()). sum ()</target>
        </trans-unit>
        <trans-unit id="30a91f4f78c1ba3a4e0863c44ed3e1c0761b3e1b" translate="yes" xml:space="preserve">
          <source>Query types: Single-document gets</source>
          <target state="translated">쿼리 유형 : 단일 문서 가져 오기</target>
        </trans-unit>
        <trans-unit id="cc6835ce045ca407e1aa42cf034a40b2dc968c7d" translate="yes" xml:space="preserve">
          <source>Querying</source>
          <target state="translated">Querying</target>
        </trans-unit>
        <trans-unit id="2311ef772fd9667ad480d784efeb91fd87562cee" translate="yes" xml:space="preserve">
          <source>Querying the jobs table</source>
          <target state="translated">작업 테이블 쿼리</target>
        </trans-unit>
        <trans-unit id="cfd1d967b9233f2a022120ac5fc5e2af2bff64b0" translate="yes" xml:space="preserve">
          <source>Querying the stats table</source>
          <target state="translated">통계 테이블 쿼리</target>
        </trans-unit>
        <trans-unit id="b4e9d799b4c484b951d3a7526f99384d51e97175" translate="yes" xml:space="preserve">
          <source>Querying this table with no filters produces a list of all current issues within the cluster.</source>
          <target state="translated">필터없이이 테이블을 쿼리하면 클러스터 내의 모든 현재 문제 목록이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="24cc2440fd1b49aaf1c5a8958c6de61e1529c18a" translate="yes" xml:space="preserve">
          <source>Quick setup</source>
          <target state="translated">빠른 설치</target>
        </trans-unit>
        <trans-unit id="d07133c8504b6a0e98371a1b9afe2ca2855a7270" translate="yes" xml:space="preserve">
          <source>Quickstart</source>
          <target state="translated">Quickstart</target>
        </trans-unit>
        <trans-unit id="06576556d1ad802f247cad11ae748be47b70cd9c" translate="yes" xml:space="preserve">
          <source>R</source>
          <target state="translated">R</target>
        </trans-unit>
        <trans-unit id="bfc29699c72375bf47c9436811bc275479e815df" translate="yes" xml:space="preserve">
          <source>RECV</source>
          <target state="translated">RECV</target>
        </trans-unit>
        <trans-unit id="9e7d6316420463a965783442095454fff2759c0a" translate="yes" xml:space="preserve">
          <source>RabbitMQ is a natural choice for distributing notifications of change events. It&amp;rsquo;s designed to efficiently route messages to many listeners, and there are client libraries for most popular languages. In this tutorial we take advantage of RabbitMQ&amp;rsquo;s &lt;a href=&quot;https://www.rabbitmq.com/tutorials/amqp-concepts.html#topic-exchange&quot;&gt;topic exchanges&lt;/a&gt;. Topic exchanges allow clients to subscribe to the messages they&amp;rsquo;re interested in, and ignore the rest.</source>
          <target state="translated">RabbitMQ는 변경 이벤트 알림을 배포하기위한 자연스러운 선택입니다. 메시지를 여러 리스너로 효율적으로 라우팅하도록 설계되었으며 가장 널리 사용되는 언어를위한 클라이언트 라이브러리가 있습니다. 이 학습서에서는 RabbitMQ의 &lt;a href=&quot;https://www.rabbitmq.com/tutorials/amqp-concepts.html#topic-exchange&quot;&gt;주제 교환을 활용&lt;/a&gt; 합니다. 토픽 교환을 통해 클라이언트는 관심있는 메시지를 구독하고 나머지는 무시합니다.</target>
        </trans-unit>
        <trans-unit id="5dd8e5ee1c3e6446669db2bc1a5feb0e30e90272" translate="yes" xml:space="preserve">
          <source>Rackspace OnMetal Compute</source>
          <target state="translated">Rackspace OnMetal 컴퓨팅</target>
        </trans-unit>
        <trans-unit id="26231667af7cc1c479da94498b920bd20cc4204e" translate="yes" xml:space="preserve">
          <source>Rackspace OnMetal I/O</source>
          <target state="translated">Rackspace OnMetal I / O</target>
        </trans-unit>
        <trans-unit id="56f04e78d5af9bc3df5498e192f568246521ebe8" translate="yes" xml:space="preserve">
          <source>Raspbian</source>
          <target state="translated">Raspbian</target>
        </trans-unit>
        <trans-unit id="cc2546f8cc7b851025e82d9ad64be8681c1defc8" translate="yes" xml:space="preserve">
          <source>ReQL</source>
          <target state="translated">ReQL</target>
        </trans-unit>
        <trans-unit id="4ac00efdbe1ef213d5db65a44a2317ffb880734f" translate="yes" xml:space="preserve">
          <source>ReQL administration commands</source>
          <target state="translated">ReQL 관리 명령</target>
        </trans-unit>
        <trans-unit id="ed867a0a1051c1e47be81b1dc6bcf49d2a9a6a50" translate="yes" xml:space="preserve">
          <source>ReQL command: () (bracket)</source>
          <target state="translated">ReQL 명령 : () (브래킷)</target>
        </trans-unit>
        <trans-unit id="9c77279ce7eb456fb9242d6b0d4944fc101cd9ac" translate="yes" xml:space="preserve">
          <source>ReQL command: EventEmitter (connection)</source>
          <target state="translated">ReQL 명령 : EventEmitter (연결)</target>
        </trans-unit>
        <trans-unit id="33ff2c1a1ec8fbe986458a9f2936ae04f4bdfb80" translate="yes" xml:space="preserve">
          <source>ReQL command: EventEmitter (cursor)</source>
          <target state="translated">ReQL 명령 : EventEmitter (커서)</target>
        </trans-unit>
        <trans-unit id="ecfe4f46eb5536b7c3b6865e0253407db4987f76" translate="yes" xml:space="preserve">
          <source>ReQL command: ISO8601</source>
          <target state="translated">ReQL 명령 : ISO8601</target>
        </trans-unit>
        <trans-unit id="d77f4ff715692913a39d0f155d76e544abc4994a" translate="yes" xml:space="preserve">
          <source>ReQL command: add</source>
          <target state="translated">ReQL 명령 : 추가</target>
        </trans-unit>
        <trans-unit id="bd75b6bf5a43cdc3fbcc301becfc8a5b38968d20" translate="yes" xml:space="preserve">
          <source>ReQL command: and</source>
          <target state="translated">ReQL 명령 : 및</target>
        </trans-unit>
        <trans-unit id="f2605569a04a0afde3a9470a0eff3c6a2b21a661" translate="yes" xml:space="preserve">
          <source>ReQL command: append</source>
          <target state="translated">ReQL 명령 : 추가</target>
        </trans-unit>
        <trans-unit id="c2634cf1d36dacdd152e506ed1c1009b68f6146a" translate="yes" xml:space="preserve">
          <source>ReQL command: args</source>
          <target state="translated">ReQL 명령 : 인수</target>
        </trans-unit>
        <trans-unit id="06786aca8c46cb6acbf99bb208c4f2ecc10b5911" translate="yes" xml:space="preserve">
          <source>ReQL command: avg</source>
          <target state="translated">ReQL 명령 : 평균</target>
        </trans-unit>
        <trans-unit id="11520f025e9654a1117903ab39195c25867c3da1" translate="yes" xml:space="preserve">
          <source>ReQL command: between</source>
          <target state="translated">ReQL 명령 : 사이</target>
        </trans-unit>
        <trans-unit id="3655b193f6608706a983a08861b50d6b5e185a06" translate="yes" xml:space="preserve">
          <source>ReQL command: binary</source>
          <target state="translated">ReQL 명령 : 이진</target>
        </trans-unit>
        <trans-unit id="571dc7d8f2d64865f6200147ca4b9d8cd8606b53" translate="yes" xml:space="preserve">
          <source>ReQL command: bitAnd</source>
          <target state="translated">ReQL 명령 : bitAnd</target>
        </trans-unit>
        <trans-unit id="9eb7b32c24ff6334c93138e0cee13addf996c896" translate="yes" xml:space="preserve">
          <source>ReQL command: bitNot</source>
          <target state="translated">ReQL 명령 : bitNot</target>
        </trans-unit>
        <trans-unit id="2e98931c028999e90b8f13abdaf953947e1a45a9" translate="yes" xml:space="preserve">
          <source>ReQL command: bitOr</source>
          <target state="translated">ReQL 명령 : bitOr</target>
        </trans-unit>
        <trans-unit id="2a8dd27993a3456720a8e10e4af832cddb66be56" translate="yes" xml:space="preserve">
          <source>ReQL command: bitSal</source>
          <target state="translated">ReQL 명령 : bitSal</target>
        </trans-unit>
        <trans-unit id="3880c7496ccfb622259572fe35ea04fd28ae8c5b" translate="yes" xml:space="preserve">
          <source>ReQL command: bitSar</source>
          <target state="translated">ReQL 명령 : bitSar</target>
        </trans-unit>
        <trans-unit id="0d527a62dcc74ad7c16de243448a28ff9bb775dd" translate="yes" xml:space="preserve">
          <source>ReQL command: bitXor</source>
          <target state="translated">ReQL 명령 : bitXor</target>
        </trans-unit>
        <trans-unit id="cc7b8e77c49a6f5233051f7e6eb87cbaa04267df" translate="yes" xml:space="preserve">
          <source>ReQL command: branch</source>
          <target state="translated">ReQL 명령 : 지점</target>
        </trans-unit>
        <trans-unit id="a542671e41bd856caf41efc6940bae16c1a4696d" translate="yes" xml:space="preserve">
          <source>ReQL command: ceil</source>
          <target state="translated">ReQL 명령 : ceil</target>
        </trans-unit>
        <trans-unit id="527929389823a7da454b535fc44ab98c9b397b0d" translate="yes" xml:space="preserve">
          <source>ReQL command: changeAt</source>
          <target state="translated">ReQL 명령 : changeAt</target>
        </trans-unit>
        <trans-unit id="25d7b0a2ca00d4a73406eff48faa4fefee9b927e" translate="yes" xml:space="preserve">
          <source>ReQL command: changes</source>
          <target state="translated">ReQL 명령 : 변경</target>
        </trans-unit>
        <trans-unit id="b439af789b774f651c0736c700338a2616f990b1" translate="yes" xml:space="preserve">
          <source>ReQL command: circle</source>
          <target state="translated">ReQL 명령 : 서클</target>
        </trans-unit>
        <trans-unit id="6b2fd8a84da14971568a45b72ab9313d35cade87" translate="yes" xml:space="preserve">
          <source>ReQL command: close</source>
          <target state="translated">ReQL 명령 : 닫기</target>
        </trans-unit>
        <trans-unit id="417eab2fa9f97567083539e8c74527f21ccacd8c" translate="yes" xml:space="preserve">
          <source>ReQL command: coerceTo</source>
          <target state="translated">ReQL 명령 : coerceTo</target>
        </trans-unit>
        <trans-unit id="4184adbeb4e69b759b643238c0d1b15d72ffc48e" translate="yes" xml:space="preserve">
          <source>ReQL command: concatMap</source>
          <target state="translated">ReQL 명령 : concatMap</target>
        </trans-unit>
        <trans-unit id="2cba949c803d2634ab6f639cf3a79f395d198c8e" translate="yes" xml:space="preserve">
          <source>ReQL command: config</source>
          <target state="translated">ReQL 명령 : config</target>
        </trans-unit>
        <trans-unit id="44e902bd9764f683711d0c83dd116fd1ae54a328" translate="yes" xml:space="preserve">
          <source>ReQL command: connect</source>
          <target state="translated">ReQL 명령 : connect</target>
        </trans-unit>
        <trans-unit id="79ec01842c910c009d437f0b1ec418b2cd2e55ff" translate="yes" xml:space="preserve">
          <source>ReQL command: contains</source>
          <target state="translated">ReQL 명령 : 포함</target>
        </trans-unit>
        <trans-unit id="63144a966ab3eea31f6d0e990c630286409bb445" translate="yes" xml:space="preserve">
          <source>ReQL command: count</source>
          <target state="translated">ReQL 명령 : 개수</target>
        </trans-unit>
        <trans-unit id="ed85af4ffe2d7e416e7f09211f7fde5e62c12bd2" translate="yes" xml:space="preserve">
          <source>ReQL command: date</source>
          <target state="translated">ReQL 명령 : 날짜</target>
        </trans-unit>
        <trans-unit id="fe45f01059e3f5e250f4fe61f283fa0b3e071514" translate="yes" xml:space="preserve">
          <source>ReQL command: day</source>
          <target state="translated">ReQL 명령 : 일</target>
        </trans-unit>
        <trans-unit id="1bf352324c27548c918fa1efea8de5b8bd8c7ab1" translate="yes" xml:space="preserve">
          <source>ReQL command: dayOfWeek</source>
          <target state="translated">ReQL 명령 : dayOfWeek</target>
        </trans-unit>
        <trans-unit id="059e7de04bc86952404125b943c999aa79d78ed3" translate="yes" xml:space="preserve">
          <source>ReQL command: dayOfYear</source>
          <target state="translated">ReQL 명령 : dayOfYear</target>
        </trans-unit>
        <trans-unit id="8b5d959614c2e1eff9a4980760f966439d124e61" translate="yes" xml:space="preserve">
          <source>ReQL command: db</source>
          <target state="translated">ReQL 명령 : db</target>
        </trans-unit>
        <trans-unit id="d76075daac756324d6d0ec0a0928aa961d586a1d" translate="yes" xml:space="preserve">
          <source>ReQL command: dbCreate</source>
          <target state="translated">ReQL 명령 : dbCreate</target>
        </trans-unit>
        <trans-unit id="8e87a1bc1f3bf2ec8d32b7c2cc40f36556358729" translate="yes" xml:space="preserve">
          <source>ReQL command: dbDrop</source>
          <target state="translated">ReQL 명령 : dbDrop</target>
        </trans-unit>
        <trans-unit id="f2a8b36dca132fdcc0c2871c7a5fbe6092c9db74" translate="yes" xml:space="preserve">
          <source>ReQL command: dbList</source>
          <target state="translated">ReQL 명령 : dbList</target>
        </trans-unit>
        <trans-unit id="5f2d6e5cf850ea9208748619684b22798f566d95" translate="yes" xml:space="preserve">
          <source>ReQL command: default</source>
          <target state="translated">ReQL 명령 : 기본값</target>
        </trans-unit>
        <trans-unit id="152ab9d0af0267e9629d3302fda86cb29bd1679c" translate="yes" xml:space="preserve">
          <source>ReQL command: delete</source>
          <target state="translated">ReQL 명령 : 삭제</target>
        </trans-unit>
        <trans-unit id="5793c7294123817b3c67b2446d9ed0fc24099e64" translate="yes" xml:space="preserve">
          <source>ReQL command: deleteAt</source>
          <target state="translated">ReQL 명령 : deleteAt</target>
        </trans-unit>
        <trans-unit id="ea37eedb2d752c766abd0663d17fa8283bafc07a" translate="yes" xml:space="preserve">
          <source>ReQL command: difference</source>
          <target state="translated">ReQL 명령 : 차이점</target>
        </trans-unit>
        <trans-unit id="4a5e04f27c1cb25c8d2eae66f69a116238196fdf" translate="yes" xml:space="preserve">
          <source>ReQL command: distance</source>
          <target state="translated">ReQL 명령 : 거리</target>
        </trans-unit>
        <trans-unit id="f3ba8164cc670369a39c3cd89a607b234d43f1c0" translate="yes" xml:space="preserve">
          <source>ReQL command: distinct</source>
          <target state="translated">ReQL 명령 : 구별</target>
        </trans-unit>
        <trans-unit id="5476b8fa7162e4450c92f418aa9aa3e48fd06aef" translate="yes" xml:space="preserve">
          <source>ReQL command: div</source>
          <target state="translated">ReQL 명령 : div</target>
        </trans-unit>
        <trans-unit id="561b5fa4e590d6f2ad1196573954cfb43c646dd8" translate="yes" xml:space="preserve">
          <source>ReQL command: do</source>
          <target state="translated">ReQL 명령 : do</target>
        </trans-unit>
        <trans-unit id="9aec0c0d4c81051146d47accc16dda35f7a5a0b3" translate="yes" xml:space="preserve">
          <source>ReQL command: downcase</source>
          <target state="translated">ReQL 명령 : 소문자</target>
        </trans-unit>
        <trans-unit id="f28b2c93a01839f916ec02c4cfcc9a13721eb722" translate="yes" xml:space="preserve">
          <source>ReQL command: during</source>
          <target state="translated">ReQL 명령 : 중</target>
        </trans-unit>
        <trans-unit id="3d326b5fb9ed975ecff66601d036627598003399" translate="yes" xml:space="preserve">
          <source>ReQL command: each</source>
          <target state="translated">ReQL 명령 : 각각</target>
        </trans-unit>
        <trans-unit id="aabe73e97a51d3c59d01989d6242a260e6d74509" translate="yes" xml:space="preserve">
          <source>ReQL command: eachAsync</source>
          <target state="translated">ReQL 명령 : eachAsync</target>
        </trans-unit>
        <trans-unit id="425ea449a1d70e01c64dbe6b5b29d2b23e87a858" translate="yes" xml:space="preserve">
          <source>ReQL command: epochTime</source>
          <target state="translated">ReQL 명령 : epochTime</target>
        </trans-unit>
        <trans-unit id="98c30486e513c1a061f79323971a52b0a723618f" translate="yes" xml:space="preserve">
          <source>ReQL command: eq</source>
          <target state="translated">ReQL 명령 : eq</target>
        </trans-unit>
        <trans-unit id="3e7a5fb0e8e29eec05542a30ba6b8c444ee3105a" translate="yes" xml:space="preserve">
          <source>ReQL command: eqJoin</source>
          <target state="translated">ReQL 명령 : eqJoin</target>
        </trans-unit>
        <trans-unit id="6b42cae3456f66df523de497a56b8436bdc4f933" translate="yes" xml:space="preserve">
          <source>ReQL command: error</source>
          <target state="translated">ReQL 명령 : 오류</target>
        </trans-unit>
        <trans-unit id="804a86083314037dd13602582c6f8bbc82d8f39b" translate="yes" xml:space="preserve">
          <source>ReQL command: expr</source>
          <target state="translated">ReQL 명령 : expr</target>
        </trans-unit>
        <trans-unit id="611e77c0661fdb3292aea37d8df3679b35c7df12" translate="yes" xml:space="preserve">
          <source>ReQL command: fill</source>
          <target state="translated">ReQL 명령 : 채우기</target>
        </trans-unit>
        <trans-unit id="9dccb4ccbba48c519594c5157e513ba0d5701de8" translate="yes" xml:space="preserve">
          <source>ReQL command: filter</source>
          <target state="translated">ReQL 명령 : 필터</target>
        </trans-unit>
        <trans-unit id="9cffb149505c56762d298753a09eb0d2d8a6560b" translate="yes" xml:space="preserve">
          <source>ReQL command: floor</source>
          <target state="translated">ReQL 명령 : 바닥</target>
        </trans-unit>
        <trans-unit id="94cbd2adf0a235aac8c2088b4ca0140be21b53f8" translate="yes" xml:space="preserve">
          <source>ReQL command: fold</source>
          <target state="translated">ReQL 명령 : 접기</target>
        </trans-unit>
        <trans-unit id="897d9459594bc60b50cde84578f8afb019abc97e" translate="yes" xml:space="preserve">
          <source>ReQL command: forEach</source>
          <target state="translated">ReQL 명령 : forEach</target>
        </trans-unit>
        <trans-unit id="bab464954d3bc8833ad8340a54c35662a312b11d" translate="yes" xml:space="preserve">
          <source>ReQL command: ge</source>
          <target state="translated">ReQL 명령 : ge</target>
        </trans-unit>
        <trans-unit id="d741c68ddfa631d21e6871f1b46d42614e18a83a" translate="yes" xml:space="preserve">
          <source>ReQL command: geojson</source>
          <target state="translated">ReQL 명령 : geojson</target>
        </trans-unit>
        <trans-unit id="82ed05550360dd83aa891c363cbc524b4a2f8f7a" translate="yes" xml:space="preserve">
          <source>ReQL command: get</source>
          <target state="translated">ReQL 명령 : get</target>
        </trans-unit>
        <trans-unit id="a1f385f0efe0b25f9afac8babc9ac59aefa669e0" translate="yes" xml:space="preserve">
          <source>ReQL command: getAll</source>
          <target state="translated">ReQL 명령 : getAll</target>
        </trans-unit>
        <trans-unit id="d0a8e46aaab6c31944afe326cfc398bb973a4686" translate="yes" xml:space="preserve">
          <source>ReQL command: getField</source>
          <target state="translated">ReQL 명령 : getField</target>
        </trans-unit>
        <trans-unit id="db529b687aac749a71e749e57613644679a50870" translate="yes" xml:space="preserve">
          <source>ReQL command: getIntersecting</source>
          <target state="translated">ReQL 명령 : getIntersecting</target>
        </trans-unit>
        <trans-unit id="2496d8ab318dd96eb24cd47e28fe55900147c8db" translate="yes" xml:space="preserve">
          <source>ReQL command: getNearest</source>
          <target state="translated">ReQL 명령 : getNearest</target>
        </trans-unit>
        <trans-unit id="fe1ca76d944081b6b32cc89a9d095e2680c9b43d" translate="yes" xml:space="preserve">
          <source>ReQL command: getWriteHook</source>
          <target state="translated">ReQL 명령 : getWriteHook</target>
        </trans-unit>
        <trans-unit id="aabf73eab95fa6104bd97b42749ee58b48fd0292" translate="yes" xml:space="preserve">
          <source>ReQL command: grant</source>
          <target state="translated">ReQL 명령 : 부여</target>
        </trans-unit>
        <trans-unit id="7b03dc68f7aad27c5aaa10cd5ee0aad622ce5f31" translate="yes" xml:space="preserve">
          <source>ReQL command: group</source>
          <target state="translated">ReQL 명령 : 그룹</target>
        </trans-unit>
        <trans-unit id="e86480de71bd273e6658917ba3f61bc7e6824443" translate="yes" xml:space="preserve">
          <source>ReQL command: gt</source>
          <target state="translated">ReQL 명령 : gt</target>
        </trans-unit>
        <trans-unit id="c24bee4561071d0d871cdd0200719bc29b97ebc8" translate="yes" xml:space="preserve">
          <source>ReQL command: hasFields</source>
          <target state="translated">ReQL 명령 : hasFields</target>
        </trans-unit>
        <trans-unit id="7bd359800f881c05722a02a6b5695da760181882" translate="yes" xml:space="preserve">
          <source>ReQL command: hours</source>
          <target state="translated">ReQL 명령 : 시간</target>
        </trans-unit>
        <trans-unit id="bcc9bf4de764097e98526fcd54cc961135eb7962" translate="yes" xml:space="preserve">
          <source>ReQL command: http</source>
          <target state="translated">ReQL 명령 : http</target>
        </trans-unit>
        <trans-unit id="7431d9aa2cada8de64c18a070081d24a5b9fbb09" translate="yes" xml:space="preserve">
          <source>ReQL command: inTimezone</source>
          <target state="translated">ReQL 명령 : inTimezone</target>
        </trans-unit>
        <trans-unit id="cd1c77e55dc7e874dfb9a9c9be6aaccb645f6b7d" translate="yes" xml:space="preserve">
          <source>ReQL command: includes</source>
          <target state="translated">ReQL 명령 : 포함</target>
        </trans-unit>
        <trans-unit id="d6711e810c115ceff2ece5c128308dbb42b5a2cf" translate="yes" xml:space="preserve">
          <source>ReQL command: indexCreate</source>
          <target state="translated">ReQL 명령 : indexCreate</target>
        </trans-unit>
        <trans-unit id="bfd351f65f12fb8a7fe92627deee9214f561ab3e" translate="yes" xml:space="preserve">
          <source>ReQL command: indexDrop</source>
          <target state="translated">ReQL 명령 : indexDrop</target>
        </trans-unit>
        <trans-unit id="3652ad2442800cc05c6e2985c0264e2e0382ca27" translate="yes" xml:space="preserve">
          <source>ReQL command: indexList</source>
          <target state="translated">ReQL 명령 : indexList</target>
        </trans-unit>
        <trans-unit id="f1e54de063dd1435fd13b88690dd9922aa7eeb29" translate="yes" xml:space="preserve">
          <source>ReQL command: indexRename</source>
          <target state="translated">ReQL 명령 : indexRename</target>
        </trans-unit>
        <trans-unit id="8b48bce424975b58f5a6277f94555aa3e884e76e" translate="yes" xml:space="preserve">
          <source>ReQL command: indexStatus</source>
          <target state="translated">ReQL 명령 : indexStatus</target>
        </trans-unit>
        <trans-unit id="f625bf613db8f884e43c623097656ac6805cb4d5" translate="yes" xml:space="preserve">
          <source>ReQL command: indexWait</source>
          <target state="translated">ReQL 명령 : indexWait</target>
        </trans-unit>
        <trans-unit id="daf81e983eb792f0c3e3c85e87f063644fd228a7" translate="yes" xml:space="preserve">
          <source>ReQL command: info</source>
          <target state="translated">ReQL 명령 : 정보</target>
        </trans-unit>
        <trans-unit id="f2865b2fe07ec14465b473e3e2191c86471ebc88" translate="yes" xml:space="preserve">
          <source>ReQL command: innerJoin</source>
          <target state="translated">ReQL 명령 : innerJoin</target>
        </trans-unit>
        <trans-unit id="42c5914444ddf911b418ac8a07bbdfe87434a490" translate="yes" xml:space="preserve">
          <source>ReQL command: insert</source>
          <target state="translated">ReQL 명령 : 삽입</target>
        </trans-unit>
        <trans-unit id="5e67c8f25f616daa8641527206d66dbca593343b" translate="yes" xml:space="preserve">
          <source>ReQL command: insertAt</source>
          <target state="translated">ReQL 명령 : insertAt</target>
        </trans-unit>
        <trans-unit id="e7827d7ac574cac26fe38a431bf6d13d20d79386" translate="yes" xml:space="preserve">
          <source>ReQL command: intersects</source>
          <target state="translated">ReQL 명령 : 교차</target>
        </trans-unit>
        <trans-unit id="2fc4b91b71a6f3ca54688e50d5dfb5007f51a3a6" translate="yes" xml:space="preserve">
          <source>ReQL command: isEmpty</source>
          <target state="translated">ReQL 명령 : isEmpty</target>
        </trans-unit>
        <trans-unit id="cc63c3831bbe8fcf8cc6bb4a0bf3937a70c83637" translate="yes" xml:space="preserve">
          <source>ReQL command: js</source>
          <target state="translated">ReQL 명령 : js</target>
        </trans-unit>
        <trans-unit id="704734e522301a470558a5131f2c6e3b6ef85eb1" translate="yes" xml:space="preserve">
          <source>ReQL command: json</source>
          <target state="translated">ReQL 명령 : json</target>
        </trans-unit>
        <trans-unit id="ee963dc4f4a09e977f54e79c552d271a5efe1ab5" translate="yes" xml:space="preserve">
          <source>ReQL command: keys</source>
          <target state="translated">ReQL 명령 : 키</target>
        </trans-unit>
        <trans-unit id="464e94774d901f92cc30536abe6dc20f1abb20d5" translate="yes" xml:space="preserve">
          <source>ReQL command: le</source>
          <target state="translated">ReQL 명령 : le</target>
        </trans-unit>
        <trans-unit id="04153a56a203e790ab924f8607428b4b8d9eb847" translate="yes" xml:space="preserve">
          <source>ReQL command: limit</source>
          <target state="translated">ReQL 명령 : 한계</target>
        </trans-unit>
        <trans-unit id="9f2597983292d8bf2c21e31bbb1694b0f4e60b71" translate="yes" xml:space="preserve">
          <source>ReQL command: line</source>
          <target state="translated">ReQL 명령 : 라인</target>
        </trans-unit>
        <trans-unit id="04e551b6caa8c5819ee49593aa863ab30753852a" translate="yes" xml:space="preserve">
          <source>ReQL command: literal</source>
          <target state="translated">ReQL 명령 : 리터럴</target>
        </trans-unit>
        <trans-unit id="dd52f5f092b7e6f28627bef15e94ecf8131e3ef6" translate="yes" xml:space="preserve">
          <source>ReQL command: lt</source>
          <target state="translated">ReQL 명령 : lt</target>
        </trans-unit>
        <trans-unit id="8cd6432c7520ab24d1a185bc4ab261febc0ac9f9" translate="yes" xml:space="preserve">
          <source>ReQL command: map</source>
          <target state="translated">ReQL 명령 : 맵</target>
        </trans-unit>
        <trans-unit id="f29d7e822149fb3bdb52bb327684c64fed039865" translate="yes" xml:space="preserve">
          <source>ReQL command: match</source>
          <target state="translated">ReQL 명령 : 일치</target>
        </trans-unit>
        <trans-unit id="c75671801e688e758173dd6841f05e272b833433" translate="yes" xml:space="preserve">
          <source>ReQL command: max</source>
          <target state="translated">ReQL 명령 : 최대</target>
        </trans-unit>
        <trans-unit id="99b4fb1fe845d533e11f41a152cc7193a70f0a3c" translate="yes" xml:space="preserve">
          <source>ReQL command: merge</source>
          <target state="translated">ReQL 명령 : 병합</target>
        </trans-unit>
        <trans-unit id="f32d131081cad08c01e30eada59cfa338cb1b409" translate="yes" xml:space="preserve">
          <source>ReQL command: min</source>
          <target state="translated">ReQL 명령 : min</target>
        </trans-unit>
        <trans-unit id="8c3b86a9d0f6ac29f03bfbb3265cd75620f9d3e0" translate="yes" xml:space="preserve">
          <source>ReQL command: minutes</source>
          <target state="translated">ReQL 명령 : 분</target>
        </trans-unit>
        <trans-unit id="5cb8dacfbfe621b76bb3f63fdb19e0e6e6dd08d6" translate="yes" xml:space="preserve">
          <source>ReQL command: mod</source>
          <target state="translated">ReQL 명령 : mod</target>
        </trans-unit>
        <trans-unit id="759964af86c65918dbeb70bab369aed0f281b7ac" translate="yes" xml:space="preserve">
          <source>ReQL command: month</source>
          <target state="translated">ReQL 명령 : 월</target>
        </trans-unit>
        <trans-unit id="f88a626fbd64a50878cbe7d76d55f2a5c63f80ce" translate="yes" xml:space="preserve">
          <source>ReQL command: mul</source>
          <target state="translated">ReQL 명령 : mul</target>
        </trans-unit>
        <trans-unit id="de874b4d0dc4ed2dbc0d6880b5cb21a27c76bc32" translate="yes" xml:space="preserve">
          <source>ReQL command: ne</source>
          <target state="translated">ReQL 명령 : ne</target>
        </trans-unit>
        <trans-unit id="6c6619dceafd328a67bddca06d99d66fe8e0c745" translate="yes" xml:space="preserve">
          <source>ReQL command: next</source>
          <target state="translated">ReQL 명령 : 다음</target>
        </trans-unit>
        <trans-unit id="2fe619f0be2dfaac8395f90e027e18f66dfb5cde" translate="yes" xml:space="preserve">
          <source>ReQL command: noreplyWait</source>
          <target state="translated">ReQL 명령 : noreplyWait</target>
        </trans-unit>
        <trans-unit id="b786c5ec3389b7fffd91940e9df8dcfc1bed6413" translate="yes" xml:space="preserve">
          <source>ReQL command: not</source>
          <target state="translated">ReQL 명령 : 아닙니다</target>
        </trans-unit>
        <trans-unit id="51bf93483726e0ed581b769efc939be0c439b3f0" translate="yes" xml:space="preserve">
          <source>ReQL command: now</source>
          <target state="translated">ReQL 명령 : 지금</target>
        </trans-unit>
        <trans-unit id="142c81f0e7aad4d403a5e9717af093c3fa309da0" translate="yes" xml:space="preserve">
          <source>ReQL command: nth</source>
          <target state="translated">ReQL 명령 : nth</target>
        </trans-unit>
        <trans-unit id="7a52ef447aef8fb68ab5bf4ab1b1be3cb0a8e6fa" translate="yes" xml:space="preserve">
          <source>ReQL command: object</source>
          <target state="translated">ReQL 명령 : 객체</target>
        </trans-unit>
        <trans-unit id="0285d42b6439c5758658f23558fb2a316aa232a9" translate="yes" xml:space="preserve">
          <source>ReQL command: offsetsOf</source>
          <target state="translated">ReQL 명령 : offsetsOf</target>
        </trans-unit>
        <trans-unit id="37141a239a711e7b56007bb0ff0bef4bc3a55f32" translate="yes" xml:space="preserve">
          <source>ReQL command: or</source>
          <target state="translated">ReQL 명령 : 또는</target>
        </trans-unit>
        <trans-unit id="469eeab7689f5192386b409764992410551e27f1" translate="yes" xml:space="preserve">
          <source>ReQL command: orderBy</source>
          <target state="translated">ReQL 명령 : orderBy</target>
        </trans-unit>
        <trans-unit id="c49f00d76ad001bdc3166004292a3c0a27e75d43" translate="yes" xml:space="preserve">
          <source>ReQL command: outerJoin</source>
          <target state="translated">ReQL 명령 : outerJoin</target>
        </trans-unit>
        <trans-unit id="cd3e4940e21cee61fccac24d189f22bbfab1ba9f" translate="yes" xml:space="preserve">
          <source>ReQL command: pluck</source>
          <target state="translated">ReQL 명령 : pluck</target>
        </trans-unit>
        <trans-unit id="0914f786606ccc5c9796e887a77cd485af776083" translate="yes" xml:space="preserve">
          <source>ReQL command: point</source>
          <target state="translated">ReQL 명령 : 포인트</target>
        </trans-unit>
        <trans-unit id="dce548026c69300e92a29bc23af287b80ded5dd0" translate="yes" xml:space="preserve">
          <source>ReQL command: polygon</source>
          <target state="translated">ReQL 명령 : 다각형</target>
        </trans-unit>
        <trans-unit id="ec7f5406bd2ba258cc0960fe19f501b84159cbf3" translate="yes" xml:space="preserve">
          <source>ReQL command: polygonSub</source>
          <target state="translated">ReQL 명령 : polygonSub</target>
        </trans-unit>
        <trans-unit id="25d262b79633d6a23b112ff0642a2bbd27b058de" translate="yes" xml:space="preserve">
          <source>ReQL command: prepend</source>
          <target state="translated">ReQL 명령 : prepend</target>
        </trans-unit>
        <trans-unit id="32df6b377a42b81280feba4abd45d6fb776b7c5b" translate="yes" xml:space="preserve">
          <source>ReQL command: r</source>
          <target state="translated">ReQL 명령 : r</target>
        </trans-unit>
        <trans-unit id="163b8f2d543ca883e5f457526db714e8507bc273" translate="yes" xml:space="preserve">
          <source>ReQL command: random</source>
          <target state="translated">ReQL 명령 : 랜덤</target>
        </trans-unit>
        <trans-unit id="abd0f1d41d793cf5d1fd1be44dad48ed9f52dcb0" translate="yes" xml:space="preserve">
          <source>ReQL command: range</source>
          <target state="translated">ReQL 명령 : 범위</target>
        </trans-unit>
        <trans-unit id="abcfac2a068eb352bf7b1585227c21dd99a9dad2" translate="yes" xml:space="preserve">
          <source>ReQL command: rebalance</source>
          <target state="translated">ReQL 명령 : 재조정</target>
        </trans-unit>
        <trans-unit id="ed78391e00455b6f7508ebf957eb0c3519b8cda6" translate="yes" xml:space="preserve">
          <source>ReQL command: reconfigure</source>
          <target state="translated">ReQL 명령 : 재구성</target>
        </trans-unit>
        <trans-unit id="bb603637d01d111818e3e54d87f6fbe2f0948e04" translate="yes" xml:space="preserve">
          <source>ReQL command: reconnect</source>
          <target state="translated">ReQL 명령 : 다시 연결</target>
        </trans-unit>
        <trans-unit id="ca15dd0e4b3cb78958bbc04ff2ebdfc6237c1480" translate="yes" xml:space="preserve">
          <source>ReQL command: reduce</source>
          <target state="translated">ReQL 명령 : 감소</target>
        </trans-unit>
        <trans-unit id="1b669d035898f8b7832c9d6b122df85452bb3621" translate="yes" xml:space="preserve">
          <source>ReQL command: replace</source>
          <target state="translated">ReQL 명령 : 바꾸기</target>
        </trans-unit>
        <trans-unit id="462aad92203d25425961d17c822cf9c057229d02" translate="yes" xml:space="preserve">
          <source>ReQL command: round</source>
          <target state="translated">ReQL 명령 : 라운드</target>
        </trans-unit>
        <trans-unit id="021b12c6ad75724f11b7b4db3ef364873869fc62" translate="yes" xml:space="preserve">
          <source>ReQL command: row</source>
          <target state="translated">ReQL 명령 : 행</target>
        </trans-unit>
        <trans-unit id="30f7a7cfdc10d2f8f0979e09db335392564ee022" translate="yes" xml:space="preserve">
          <source>ReQL command: run</source>
          <target state="translated">ReQL 명령 : 실행</target>
        </trans-unit>
        <trans-unit id="35baf0bd20ef826e0e6f2d92d0b5ececfd90953e" translate="yes" xml:space="preserve">
          <source>ReQL command: sample</source>
          <target state="translated">ReQL 명령 : 샘플</target>
        </trans-unit>
        <trans-unit id="0be3d60445795016ac04b5c046a0a131b0ae6079" translate="yes" xml:space="preserve">
          <source>ReQL command: seconds</source>
          <target state="translated">ReQL 명령 : 초</target>
        </trans-unit>
        <trans-unit id="f1bb2be8ae02baa7d054dd238fb17ff6adc0e5fc" translate="yes" xml:space="preserve">
          <source>ReQL command: server</source>
          <target state="translated">ReQL 명령 : 서버</target>
        </trans-unit>
        <trans-unit id="bd21c33c7d7e4a661ae24315ff5adaf657b0d101" translate="yes" xml:space="preserve">
          <source>ReQL command: setDifference</source>
          <target state="translated">ReQL 명령 : setDifference</target>
        </trans-unit>
        <trans-unit id="ee8b9454ec4e6e9f1927b8de9dc70609dcdeafae" translate="yes" xml:space="preserve">
          <source>ReQL command: setInsert</source>
          <target state="translated">ReQL 명령 : setInsert</target>
        </trans-unit>
        <trans-unit id="c9a0eb231439f96cafbfefb58f50b26a3a819a2d" translate="yes" xml:space="preserve">
          <source>ReQL command: setIntersection</source>
          <target state="translated">ReQL 명령 : setIntersection</target>
        </trans-unit>
        <trans-unit id="04f4bae437d2c848c78c8d28f84714b52d7f6c3f" translate="yes" xml:space="preserve">
          <source>ReQL command: setUnion</source>
          <target state="translated">ReQL 명령 : setUnion</target>
        </trans-unit>
        <trans-unit id="98a6520cbec0f57832621c081c07b22454e679e2" translate="yes" xml:space="preserve">
          <source>ReQL command: setWriteHook</source>
          <target state="translated">ReQL 명령 : setWriteHook</target>
        </trans-unit>
        <trans-unit id="19311ff5522c6db5f5f3d20e812d39f1a5fc5892" translate="yes" xml:space="preserve">
          <source>ReQL command: skip</source>
          <target state="translated">ReQL 명령 : 건너 뛰기</target>
        </trans-unit>
        <trans-unit id="76501a2b3ef6222fd67dd4c4fd5d7848613ac2b2" translate="yes" xml:space="preserve">
          <source>ReQL command: slice</source>
          <target state="translated">ReQL 명령 : 슬라이스</target>
        </trans-unit>
        <trans-unit id="5dfe709e1e34e3632317f2600c09e5128cb9ae93" translate="yes" xml:space="preserve">
          <source>ReQL command: spliceAt</source>
          <target state="translated">ReQL 명령 : spliceAt</target>
        </trans-unit>
        <trans-unit id="c8464e0de44dd2800e23b2097a3059deee41b021" translate="yes" xml:space="preserve">
          <source>ReQL command: split</source>
          <target state="translated">ReQL 명령 : 분할</target>
        </trans-unit>
        <trans-unit id="570b17954ae1d507f16d974d184fbad67acf5855" translate="yes" xml:space="preserve">
          <source>ReQL command: status</source>
          <target state="translated">ReQL 명령 : 상태</target>
        </trans-unit>
        <trans-unit id="13e59b90332b50ab084f0e4a384ba3686605cd3f" translate="yes" xml:space="preserve">
          <source>ReQL command: sub</source>
          <target state="translated">ReQL 명령 : sub</target>
        </trans-unit>
        <trans-unit id="10e1b3442af15fbd32119e6a98b64febea339584" translate="yes" xml:space="preserve">
          <source>ReQL command: sum</source>
          <target state="translated">ReQL 명령 : 합계</target>
        </trans-unit>
        <trans-unit id="da0339a917c31dc275e5131893031fc7f6acce4c" translate="yes" xml:space="preserve">
          <source>ReQL command: sync</source>
          <target state="translated">ReQL 명령 : sync</target>
        </trans-unit>
        <trans-unit id="8d21f3686cbc79062796b79f01a307a2daa74707" translate="yes" xml:space="preserve">
          <source>ReQL command: table</source>
          <target state="translated">ReQL 명령 : 테이블</target>
        </trans-unit>
        <trans-unit id="5a75ff2420141b13ad812407726590d8e11bf491" translate="yes" xml:space="preserve">
          <source>ReQL command: tableCreate</source>
          <target state="translated">ReQL 명령 : tableCreate</target>
        </trans-unit>
        <trans-unit id="6edc96e8bb975009898532d7c3ac0d5c9c3e1171" translate="yes" xml:space="preserve">
          <source>ReQL command: tableDrop</source>
          <target state="translated">ReQL 명령 : tableDrop</target>
        </trans-unit>
        <trans-unit id="321385e05615dc1e097447354a11170214318796" translate="yes" xml:space="preserve">
          <source>ReQL command: tableList</source>
          <target state="translated">ReQL 명령 : tableList</target>
        </trans-unit>
        <trans-unit id="0659bee81d319deb7e130473db0dc2263f4622f3" translate="yes" xml:space="preserve">
          <source>ReQL command: time</source>
          <target state="translated">ReQL 명령 : 시간</target>
        </trans-unit>
        <trans-unit id="37216ac18e28d2fe512c09beeb963db758364a4b" translate="yes" xml:space="preserve">
          <source>ReQL command: timeOfDay</source>
          <target state="translated">ReQL 명령 : timeOfDay</target>
        </trans-unit>
        <trans-unit id="1de03f1799a9257b1e0cb0c6a0e68b6a2125ca72" translate="yes" xml:space="preserve">
          <source>ReQL command: timezone</source>
          <target state="translated">ReQL 명령 : 시간대</target>
        </trans-unit>
        <trans-unit id="2af08e633e375c04686b6dd4e002092239a1eed9" translate="yes" xml:space="preserve">
          <source>ReQL command: toArray</source>
          <target state="translated">ReQL 명령 : toArray</target>
        </trans-unit>
        <trans-unit id="513f46f55a4b510e789657e077cfdb94101a2398" translate="yes" xml:space="preserve">
          <source>ReQL command: toEpochTime</source>
          <target state="translated">ReQL 명령 : toEpochTime</target>
        </trans-unit>
        <trans-unit id="627570fef15c7acc0c2663e684f59cb33b2b1459" translate="yes" xml:space="preserve">
          <source>ReQL command: toGeojson</source>
          <target state="translated">ReQL 명령 : toGeojson</target>
        </trans-unit>
        <trans-unit id="56852d9c1a1873fd61c17972ef99801ac2c87ecf" translate="yes" xml:space="preserve">
          <source>ReQL command: toISO8601</source>
          <target state="translated">ReQL 명령 : toISO8601</target>
        </trans-unit>
        <trans-unit id="f6f174b5765bf64194d9ca622d10e16cd8a46617" translate="yes" xml:space="preserve">
          <source>ReQL command: toJsonString, toJSON</source>
          <target state="translated">ReQL 명령 : toJsonString, toJSON</target>
        </trans-unit>
        <trans-unit id="19cdf1a2a2fefcc0935b25802524c2a58527dbbb" translate="yes" xml:space="preserve">
          <source>ReQL command: typeOf</source>
          <target state="translated">ReQL 명령 : typeOf</target>
        </trans-unit>
        <trans-unit id="8022749a3da3c400ea76655d26b31790850a20bf" translate="yes" xml:space="preserve">
          <source>ReQL command: ungroup</source>
          <target state="translated">ReQL 명령 : 그룹 해제</target>
        </trans-unit>
        <trans-unit id="fe481736ff3cb3a807c23188aaf45a55b2d99dc4" translate="yes" xml:space="preserve">
          <source>ReQL command: union</source>
          <target state="translated">ReQL 명령 : 공용체</target>
        </trans-unit>
        <trans-unit id="6dbff263f97562be4ce701c91fec033e04feaf07" translate="yes" xml:space="preserve">
          <source>ReQL command: upcase</source>
          <target state="translated">ReQL 명령 : 대문자</target>
        </trans-unit>
        <trans-unit id="455ab20ffc94cace160b696dfbeaa15326dd0cf2" translate="yes" xml:space="preserve">
          <source>ReQL command: update</source>
          <target state="translated">ReQL 명령 : 업데이트</target>
        </trans-unit>
        <trans-unit id="e0651ec1f9bbf8339e03befeb514c75a1ab27c73" translate="yes" xml:space="preserve">
          <source>ReQL command: use</source>
          <target state="translated">ReQL 명령 : 사용</target>
        </trans-unit>
        <trans-unit id="4e9d4a579dc4455f2e6db7cb499db7af40804ded" translate="yes" xml:space="preserve">
          <source>ReQL command: uuid</source>
          <target state="translated">ReQL 명령 : uuid</target>
        </trans-unit>
        <trans-unit id="325ff960145ced96b81cf4fd70fa7b1153d74132" translate="yes" xml:space="preserve">
          <source>ReQL command: values</source>
          <target state="translated">ReQL 명령 : 값</target>
        </trans-unit>
        <trans-unit id="997a6bf76bb87f3bcdf7d12f2d88b575cc41fefa" translate="yes" xml:space="preserve">
          <source>ReQL command: wait</source>
          <target state="translated">ReQL 명령 : 대기</target>
        </trans-unit>
        <trans-unit id="85a62250b115e6cd99762def1db4a11a411a71e6" translate="yes" xml:space="preserve">
          <source>ReQL command: withFields</source>
          <target state="translated">ReQL 명령 : withFields</target>
        </trans-unit>
        <trans-unit id="369250ffd90be27fd1fa8cfe5c8ea1f06e5ca8ed" translate="yes" xml:space="preserve">
          <source>ReQL command: without</source>
          <target state="translated">ReQL 명령 : 미포함</target>
        </trans-unit>
        <trans-unit id="274b2016fa95fda2a3b60df052ec709fc131c8b3" translate="yes" xml:space="preserve">
          <source>ReQL command: year</source>
          <target state="translated">ReQL 명령 : 연도</target>
        </trans-unit>
        <trans-unit id="395a7dc9265d0f496258ee4292950abf3e16e123" translate="yes" xml:space="preserve">
          <source>ReQL command: zip</source>
          <target state="translated">ReQL 명령 : zip</target>
        </trans-unit>
        <trans-unit id="0745f2086f93ccd2a331d7072137817d3cb55afa" translate="yes" xml:space="preserve">
          <source>ReQL commands</source>
          <target state="translated">ReQL 명령</target>
        </trans-unit>
        <trans-unit id="59807be887cb81af9dbfaac16f14ad42e6245fa9" translate="yes" xml:space="preserve">
          <source>ReQL commands are represented as a list of two or three elements.</source>
          <target state="translated">ReQL 명령은 2 ~ 3 개의 요소 목록으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="94f7952690489bb7dd3edb6940dbc296908f9252" translate="yes" xml:space="preserve">
          <source>ReQL data</source>
          <target state="translated">ReQL 데이터</target>
        </trans-unit>
        <trans-unit id="09010231d56a5d2fda3a74b70c661c1e81cadefe" translate="yes" xml:space="preserve">
          <source>ReQL data types</source>
          <target state="translated">ReQL 데이터 유형</target>
        </trans-unit>
        <trans-unit id="191a7a574620481e86f08d38eca70528f9f36e03" translate="yes" xml:space="preserve">
          <source>ReQL embeds into your programming language</source>
          <target state="translated">프로그래밍 언어에 ReQL 내장</target>
        </trans-unit>
        <trans-unit id="125f3b5c55d48af1835dac4b751c29ca63213adc" translate="yes" xml:space="preserve">
          <source>ReQL error types</source>
          <target state="translated">ReQL 오류 유형</target>
        </trans-unit>
        <trans-unit id="cece285d53709eacd625cbfa5e27ed559a1d29d6" translate="yes" xml:space="preserve">
          <source>ReQL geometry objects are not &lt;a href=&quot;http://geojson.org&quot;&gt;GeoJSON&lt;/a&gt; objects, but you can convert back and forth between them with the &lt;a href=&quot;../../../api/javascript/geojson/index&quot;&gt;geojson&lt;/a&gt; and &lt;a href=&quot;../../../api/javascript/to_geojson/index&quot;&gt;toGeojson&lt;/a&gt; commands.</source>
          <target state="translated">ReQL 지오메트리 객체는 &lt;a href=&quot;http://geojson.org&quot;&gt;GeoJSON&lt;/a&gt; 객체가 아니지만 &lt;a href=&quot;../../../api/javascript/geojson/index&quot;&gt;geojson&lt;/a&gt; 및 &lt;a href=&quot;../../../api/javascript/to_geojson/index&quot;&gt;toGeojson&lt;/a&gt; 명령을 사용하여 객체 간에 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="35a42830df2a6efe0b040fe441dccc75dde4e460" translate="yes" xml:space="preserve">
          <source>ReQL has commands for extracting parts of &lt;a href=&quot;../../dates-and-times/javascript/index&quot;&gt;dates and times&lt;/a&gt;, including &lt;a href=&quot;../../../api/javascript/year/index&quot;&gt;year&lt;/a&gt;, &lt;a href=&quot;../../../api/javascript/month/index&quot;&gt;month&lt;/a&gt;, &lt;a href=&quot;../../../api/javascript/day/index&quot;&gt;day&lt;/a&gt;, &lt;a href=&quot;../../../api/javascript/day_of_week/index&quot;&gt;dayOfWeek&lt;/a&gt; and more. You can use these with &lt;a href=&quot;../../../api/javascript/group/index&quot;&gt;group&lt;/a&gt; to group by various intervals. Suppose you had a table of invoices and wanted to retrieve them in groups ordered by year and month:</source>
          <target state="translated">ReQL에는 &lt;a href=&quot;../../../api/javascript/year/index&quot;&gt;year&lt;/a&gt; , &lt;a href=&quot;../../../api/javascript/month/index&quot;&gt;month&lt;/a&gt; , &lt;a href=&quot;../../../api/javascript/day/index&quot;&gt;day&lt;/a&gt; , &lt;a href=&quot;../../../api/javascript/day_of_week/index&quot;&gt;dayOfWeek&lt;/a&gt; 등을 포함하여 &lt;a href=&quot;../../dates-and-times/javascript/index&quot;&gt;날짜 및 시간의&lt;/a&gt; 일부를 추출하는 명령이 있습니다. 다양한 간격 으로 &lt;a href=&quot;../../../api/javascript/group/index&quot;&gt;그룹화&lt;/a&gt; 하기 위해 그룹 과 함께 사용할 수 있습니다 . 송장 테이블이 있고 연도 및 월별로 순서대로 그룹으로 검색하려고한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="da86166d7e392999c718f777993e73c609f2fbc7" translate="yes" xml:space="preserve">
          <source>ReQL is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;domain specific language&lt;/a&gt; expressed in the host language. The three official drivers follow a very similar syntax; you should stick to that model as closely as your chosen language allows. Typically you are free to use either a prefix or infix notation, or mix the two.</source>
          <target state="translated">ReQL은 호스트 언어 &lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;로&lt;/a&gt; 표현 된 도메인 별 언어입니다. 세 가지 공식 드라이버는 매우 유사한 구문을 따릅니다. 선택한 언어가 허용하는 한 그 모델을 고수해야합니다. 일반적으로 접두사 또는 접두사 표기법을 자유롭게 사용하거나 두 가지를 혼합하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03b7a017a84f9b3da4de0039647a3013516208eb" translate="yes" xml:space="preserve">
          <source>ReQL is different from other NoSQL query languages. It&amp;rsquo;s built on three key principles:</source>
          <target state="translated">ReQL은 다른 NoSQL 쿼리 언어와 다릅니다. 세 가지 주요 원칙을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="dab0c7b28a7500cbaccffec7e5e887241992d2da" translate="yes" xml:space="preserve">
          <source>ReQL is efficient</source>
          <target state="translated">ReQL은 효율적입니다</target>
        </trans-unit>
        <trans-unit id="6c8ae750e37a742a762efbb4d4a707a2f88e21d9" translate="yes" xml:space="preserve">
          <source>ReQL is the RethinkDB query language. It offers a very powerful and convenient way to manipulate JSON documents. This document is a gentle introduction to ReQL concepts. You don&amp;rsquo;t have to read it to be productive with RethinkDB, but it helps to understand some basics.</source>
          <target state="translated">ReQL은 RethinkDB 쿼리 언어입니다. JSON 문서를 조작하는 매우 강력하고 편리한 방법을 제공합니다. 이 문서는 ReQL 개념에 대한 간단한 소개입니다. RethinkDB로 생산성을 높이기 위해 읽을 필요는 없지만 몇 가지 기본 사항을 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="62b7b785aa09ec970184f5e88cf1e8539b883367" translate="yes" xml:space="preserve">
          <source>ReQL pseudo types</source>
          <target state="translated">ReQL 의사 유형</target>
        </trans-unit>
        <trans-unit id="8b783f5ac5ce21c42bde10cc36b31b26d3e95f39" translate="yes" xml:space="preserve">
          <source>ReQL queries are composable</source>
          <target state="translated">ReQL 쿼리는 작성 가능</target>
        </trans-unit>
        <trans-unit id="0d649019dd97255601cf647335065eb587632177" translate="yes" xml:space="preserve">
          <source>ReQL queries are executed lazily:</source>
          <target state="translated">ReQL 쿼리는 느리게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="46cc7a8d6eff2c8a22f5442d9d90d27387cddcaa" translate="yes" xml:space="preserve">
          <source>ReQL queries are functional</source>
          <target state="translated">ReQL 쿼리는 작동합니다</target>
        </trans-unit>
        <trans-unit id="baf0a6b4a49af458581fecb524a2b910b9bc313c" translate="yes" xml:space="preserve">
          <source>ReQL types and commands are defined in the &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/src/rdb_protocol/ql2.proto&quot;&gt;ql2.proto&lt;/a&gt; file.</source>
          <target state="translated">ReQL 유형 및 명령은 &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/src/rdb_protocol/ql2.proto&quot;&gt;ql2.proto&lt;/a&gt; 파일에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2093e96b1a65a9a688a5cc8dffba6429e5a47515" translate="yes" xml:space="preserve">
          <source>ReQL&amp;rsquo;s nesting depth is limited to 20 levels. This can be changed with the undocumented &lt;code&gt;nestingDepth&lt;/code&gt; (or &lt;code&gt;nesting_depth&lt;/code&gt;) option to &lt;code&gt;r.expr()&lt;/code&gt;, but before using that, consider whether the document can be reorganized to avoid the error.</source>
          <target state="translated">ReQL의 중첩 깊이는 20 레벨로 제한됩니다. 이것은 문서화되지 않은 &lt;code&gt;nestingDepth&lt;/code&gt; (또는 &lt;code&gt;nesting_depth&lt;/code&gt; ) 옵션을 사용하여 &lt;code&gt;r.expr()&lt;/code&gt; 로 변경할 수 있지만, 사용하기 전에 오류를 피하기 위해 문서를 재구성 할 수 있는지 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="6f2b9560013f6f1bce5d0df1f754255ff37ad07d" translate="yes" xml:space="preserve">
          <source>React.js</source>
          <target state="translated">React.js</target>
        </trans-unit>
        <trans-unit id="48fa53a29856312c157be48d24a169a0a913953d" translate="yes" xml:space="preserve">
          <source>Read &lt;a href=&quot;../../../docs/sharding-and-replication/index&quot;&gt;Sharding and replication&lt;/a&gt; for a complete discussion of the subject, including advanced topics.</source>
          <target state="translated">고급 주제를 포함하여 주제에 대한 전체 토론을 보려면 &lt;a href=&quot;../../../docs/sharding-and-replication/index&quot;&gt;샤딩 및 복제&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="b4eef36f30bb0fd18c9978dad0fad8450b46a35e" translate="yes" xml:space="preserve">
          <source>Read Compose&amp;rsquo;s &lt;a href=&quot;https://docs.compose.io/getting-started/rethinkdb-deployments.html&quot;&gt;overview&lt;/a&gt; of RethinkDB support and their &lt;a href=&quot;https://help.compose.io/docs/connecting-to-rethinkdb&quot;&gt;Connecting to RethinkDB&lt;/a&gt; documentation for more information.</source>
          <target state="translated">자세한 내용은 Compose의 RethinkDB 지원 &lt;a href=&quot;https://docs.compose.io/getting-started/rethinkdb-deployments.html&quot;&gt;개요&lt;/a&gt; 및 RethinkDB에 &lt;a href=&quot;https://help.compose.io/docs/connecting-to-rethinkdb&quot;&gt;연결&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="646061e2f38829c59bbd2bebc1acc8f7f33e1c4e" translate="yes" xml:space="preserve">
          <source>Read More</source>
          <target state="translated">더 읽어보기</target>
        </trans-unit>
        <trans-unit id="26899b3ad08bf6f09ed1824ded31e41b43aadfd5" translate="yes" xml:space="preserve">
          <source>Read about &lt;a href=&quot;../../secondary-indexes/javascript/index&quot;&gt;creating secondary indexes in RethinkDB&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../secondary-indexes/javascript/index&quot;&gt;RethinkDB에서 보조 인덱스 작성&lt;/a&gt; 에 대해 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="b6445979be97a3e933b6bb240cff09a6407b2918" translate="yes" xml:space="preserve">
          <source>Read about &lt;a href=&quot;http://nobrainer.io/docs/validations/&quot;&gt;validation in NoBrainer&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;http://nobrainer.io/docs/validations/&quot;&gt;은 NoBrainer의 유효성 검사에&lt;/a&gt; 대해 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="f88dbb0d2a98507a39fce321163277b3a73a9734" translate="yes" xml:space="preserve">
          <source>Read about &lt;a href=&quot;https://rethinkdb.com/blog/lambda-functions/&quot;&gt;how this technology is implemented&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://rethinkdb.com/blog/lambda-functions/&quot;&gt;은이 기술이 어떻게 구현되는지&lt;/a&gt; 읽어보십시오 .</target>
        </trans-unit>
        <trans-unit id="ad086cf55b834c375e209972840f1342401d8c41" translate="yes" xml:space="preserve">
          <source>Read more</source>
          <target state="translated">더 읽어보기</target>
        </trans-unit>
        <trans-unit id="a2453263034e6e359ea2f543b4881317b239da0a" translate="yes" xml:space="preserve">
          <source>Read more about this command &amp;rarr;</source>
          <target state="translated">이 명령에 대해 자세히 알아보십시오 &amp;rarr;</target>
        </trans-unit>
        <trans-unit id="02f254122240b0223890c627f9fb1fededf11d25" translate="yes" xml:space="preserve">
          <source>Read more details about RethinkDB&amp;rsquo;s binary object support: &lt;a href=&quot;../../../docs/storing-binary/javascript/index&quot;&gt;Storing binary objects&lt;/a&gt;.</source>
          <target state="translated">RethinkDB의 이진 객체 지원에 대한 자세한 내용을 읽어보십시오 : &lt;a href=&quot;../../../docs/storing-binary/javascript/index&quot;&gt;이진 객체 저장&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90468c1697f8bededde1b19c579430c9cba85e5a" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;../../introduction-to-reql/index&quot;&gt;introduction to RQL&lt;/a&gt; to learn about the ReQL concepts in more depth.</source>
          <target state="translated">ReQL 개념에 대해 자세히 알아 보려면 &lt;a href=&quot;../../introduction-to-reql/index&quot;&gt;RQL 소개를&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="b7305dc3ce2b74ab8470a10b76b25826ab716813" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;../../quickstart/index&quot;&gt;thirty-second quickstart&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../quickstart/index&quot;&gt;서른 초 빠른 시작&lt;/a&gt; 읽기</target>
        </trans-unit>
        <trans-unit id="bd50ab4e04e65b18c59e790e54937f033d4e636d" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;../../quickstart/index&quot;&gt;thirty-second quickstart&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../quickstart/index&quot;&gt;서른 초 빠른 시작을&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="b3f7216d53c7652972070c1613c1e9033b24a010" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;../guide/javascript/index&quot;&gt;ten-minute guide&lt;/a&gt; to get started with using RethinkDB.</source>
          <target state="translated">RethinkDB 사용을 시작 하려면 &lt;a href=&quot;../guide/javascript/index&quot;&gt;10 분 가이드&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="2d09665db0a53946b8e9d31dc64ad079edc1aaff" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;../quickstart/index&quot;&gt;thirty-second quickstart&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../quickstart/index&quot;&gt;서른 초 빠른 시작&lt;/a&gt; 읽기</target>
        </trans-unit>
        <trans-unit id="a87c2bcd4362cf6fb041820c08ec2389cdff1f01" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/tree/v2.3.x/drivers&quot;&gt;source code for existing drivers&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/tree/v2.3.x/drivers&quot;&gt;기존 드라이버&lt;/a&gt; 의 소스 코드를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="b3140532e83a846933dd1c5054c5e9b1d505bc64" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/tree/v2.4.x/drivers&quot;&gt;source code for existing drivers&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/tree/v2.4.x/drivers&quot;&gt;기존 드라이버&lt;/a&gt; 의 소스 코드를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="ecd34094f7e876256eb1edd303a58f87ed2f40f7" translate="yes" xml:space="preserve">
          <source>Read the article on &lt;a href=&quot;../../../docs/data-types/index&quot;&gt;ReQL data types&lt;/a&gt; for a more detailed discussion. Note that some possible return values from &lt;code&gt;typeOf&lt;/code&gt; are internal values, such as &lt;code&gt;MAXVAL&lt;/code&gt;, and unlikely to be returned from queries in standard practice.</source>
          <target state="translated">더 자세한 논의는 &lt;a href=&quot;../../../docs/data-types/index&quot;&gt;ReQL 데이터 유형&lt;/a&gt; 에 관한 기사를 읽으십시오 . 일부 가능한 반환 값 있습니다 &lt;code&gt;typeOf&lt;/code&gt; 내부와 같은 값이다 &lt;code&gt;MAXVAL&lt;/code&gt; 및 가능성은 표준 실제로 쿼리에서 반환합니다.</target>
        </trans-unit>
        <trans-unit id="69a94a798fe63c51a0462527c27fb6ae3d9aa98a" translate="yes" xml:space="preserve">
          <source>Read the article on &lt;a href=&quot;../writing-drivers/index&quot;&gt;writing RethinkDB drivers&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../writing-drivers/index&quot;&gt;RethinkDB 드라이버 작성에&lt;/a&gt; 관한 기사를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="6ae455b050e5bf042c051a0264064730a12241af" translate="yes" xml:space="preserve">
          <source>Reads and writes are performed by eight client servers, with 128 concurrent connections per database server. This means we have 128 connections with just a single RethinkDB server, and 2048 concurrent connections with a 16-node cluster. We used a replication factor of two per table, meaning each document was replicated to two separate servers.</source>
          <target state="translated">데이터베이스 서버 당 128 개의 동시 연결로 8 개의 클라이언트 서버가 읽기 및 쓰기를 수행합니다. 즉, 단일 RethinkDB 서버로 128 개의 연결이 있고 16 노드 클러스터와 2048 개의 동시 연결이 있습니다. 테이블 당 2의 복제 팩터를 사용했습니다. 즉, 각 문서가 두 개의 별도 서버로 복제되었습니다.</target>
        </trans-unit>
        <trans-unit id="ee4d904478e46dd47f209480eb0a07339d3b0d44" translate="yes" xml:space="preserve">
          <source>Reads run in &lt;code&gt;&quot;outdated&quot;&lt;/code&gt; mode will return outdated data even during normal operation, but the data will typically be less than a second out of date. In the event of a network or server failure, the data may be much more out of date. The advantage of running reads in &lt;code&gt;&quot;outdated&quot;&lt;/code&gt; mode is that the latency and throughput are often better than in &lt;code&gt;&quot;single&quot;&lt;/code&gt; mode, in addition to the availability differences described in the previous section.</source>
          <target state="translated">&lt;code&gt;&quot;outdated&quot;&lt;/code&gt; 모드 에서 실행 하면 정상 작동 중에도 오래된 데이터가 반환되지만 데이터는 일반적으로 1 초 미만입니다. 네트워크 또는 서버 장애가 발생하면 데이터가 훨씬 오래되었을 수 있습니다. &lt;code&gt;&quot;outdated&quot;&lt;/code&gt; 모드 에서 읽기를 실행 하면 이전 섹션에서 설명한 가용성 차이 외에도 대기 시간 및 처리량이 &lt;code&gt;&quot;single&quot;&lt;/code&gt; 모드 보다 우수하다는 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f4e1fdf56fccb0716e779b51b4fd1b78316b38b" translate="yes" xml:space="preserve">
          <source>Reads run in &lt;code&gt;single&lt;/code&gt; mode may succeed even if the table is not available, but this is not guaranteed. Reads run in &lt;code&gt;outdated&lt;/code&gt; mode will succeed as long as at least one replica for each of the relevant shards is available.</source>
          <target state="translated">테이블을 사용할 수없는 경우에도 &lt;code&gt;single&lt;/code&gt; 모드 에서 읽기 실행 이 성공할 수 있지만 이것이 보장되지는 않습니다. 각 관련 샤드에 대해 하나 이상의 복제본을 사용할 수 있는 한 &lt;code&gt;outdated&lt;/code&gt; 모드 에서 읽기 가 성공합니다.</target>
        </trans-unit>
        <trans-unit id="1d0349ac58ea3d38ff5f50980a915c92316eb132" translate="yes" xml:space="preserve">
          <source>Realtime feeds</source>
          <target state="translated">실시간 피드</target>
        </trans-unit>
        <trans-unit id="6858c6a7228cbd560d4cfe81ead5db5f9e52f0b8" translate="yes" xml:space="preserve">
          <source>Rebalances the shards of a table. When called on a database, all the tables in that database will be rebalanced.</source>
          <target state="translated">테이블의 샤드를 재조정합니다. 데이터베이스에서 호출되면 해당 데이터베이스의 모든 테이블이 재조정됩니다.</target>
        </trans-unit>
        <trans-unit id="0fe299ad13ae6716e4c9dd8be790a6a70d91b0f3" translate="yes" xml:space="preserve">
          <source>Rebuild indexes</source>
          <target state="translated">인덱스 재 구축</target>
        </trans-unit>
        <trans-unit id="36141d622dd1843fafbde3ba5b63d5704d3eaca5" translate="yes" xml:space="preserve">
          <source>Receive responses</source>
          <target state="translated">응답 받기</target>
        </trans-unit>
        <trans-unit id="f40f931807d3e751f75ae8f61f51b88d3c55f63e" translate="yes" xml:space="preserve">
          <source>Recently, the team behind BigchainDB &amp;ndash; a scalable blockchain database built on top of RethinkDB &amp;ndash; has benchmarked RethinkDB on a 32-server cluster running on Amazon&amp;rsquo;s EC2. They measured throughput of more than a million writes per second. Their conclusion: &amp;ldquo;There is linear scaling in write performance with the number of nodes.&amp;rdquo; The full report is available at &lt;a href=&quot;https://www.bigchaindb.com/whitepaper/&quot;&gt;https://www.bigchaindb.com/whitepaper/&lt;/a&gt;</source>
          <target state="translated">최근에 RethinkDB 위에 구축 된 확장 가능한 블록 체인 데이터베이스 인 BigchainDB 팀은 Amazon EC2에서 실행되는 32 서버 클러스터에서 RethinkDB를 벤치마킹했습니다. 그들은 초당 백만 번 이상의 쓰기 처리량을 측정했습니다. 그들의 결론 :&amp;ldquo;노드 수에 따라 쓰기 성능에 선형 스케일링이 있습니다.&amp;rdquo; 전체 보고서는 &lt;a href=&quot;https://www.bigchaindb.com/whitepaper/&quot;&gt;https://www.bigchaindb.com/whitepaper/&lt;/a&gt; 에서 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ed843dc519783f62617c1358f81fae926ee0818" translate="yes" xml:space="preserve">
          <source>Reconfigure a table&amp;rsquo;s sharding and replication.</source>
          <target state="translated">테이블의 샤딩 및 복제를 재구성하십시오.</target>
        </trans-unit>
        <trans-unit id="2ce1c56b1ad89cc7c3d7f1c846b92e4404ee94e6" translate="yes" xml:space="preserve">
          <source>Reconfiguring a table (changing the number of shards, rebalancing, etc.) causes brief losses of availability at various points during the reconfiguration.</source>
          <target state="translated">테이블 재구성 (샤드 수 변경, 재조정 등)은 재구성 중에 다양한 지점에서 일시적으로 가용성이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="1a5dd83d686967dbee491e598c66e203e42c8bea" translate="yes" xml:space="preserve">
          <source>Redux</source>
          <target state="translated">Redux</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="d883c0d0e6af1f4f5d9bae45cb31865272b7621e" translate="yes" xml:space="preserve">
          <source>Reference a database.</source>
          <target state="translated">데이터베이스를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f97b0faeb0aa223b01f7944075457b4fdb5c0b17" translate="yes" xml:space="preserve">
          <source>Related commands</source>
          <target state="translated">관련 명령</target>
        </trans-unit>
        <trans-unit id="6fd9fce94e1798f55b5904f5f4b1afc9b73462f0" translate="yes" xml:space="preserve">
          <source>Remove one or more elements from an array at a given index. Returns the modified array. (Note: &lt;code&gt;deleteAt&lt;/code&gt; operates on arrays, not documents; to delete documents, see the &lt;a href=&quot;../delete/index&quot;&gt;delete&lt;/a&gt; command.)</source>
          <target state="translated">주어진 인덱스의 배열에서 하나 이상의 요소를 제거합니다. 수정 된 배열을 반환합니다. (참고 : &lt;code&gt;deleteAt&lt;/code&gt; 는 문서가 아닌 배열에서 작동합니다. 문서를 삭제 &lt;a href=&quot;../delete/index&quot;&gt;하려면 delete&lt;/a&gt; 명령을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="28b83b24b89e420600d6b0c7028a8d2290ddf0d9" translate="yes" xml:space="preserve">
          <source>Remove one or more elements from an array at a given index. Returns the modified array. (Note: &lt;code&gt;deleteAt&lt;/code&gt; operates on arrays, not documents; to delete documents, see the &lt;a href=&quot;delete/index&quot;&gt;delete&lt;/a&gt; command.)</source>
          <target state="translated">주어진 인덱스의 배열에서 하나 이상의 요소를 제거합니다. 수정 된 배열을 반환합니다. (참고 : &lt;code&gt;deleteAt&lt;/code&gt; 는 문서가 아닌 배열에서 작동합니다. 문서를 삭제 &lt;a href=&quot;delete/index&quot;&gt;하려면 delete&lt;/a&gt; 명령을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="a87b37bc5f692c148c02fe605a7458c77b15a50d" translate="yes" xml:space="preserve">
          <source>Remove the elements of one array from another and return them as a set (an array with distinct values).</source>
          <target state="translated">한 배열의 요소를 다른 배열에서 제거하고 세트 (고유 한 값을 가진 배열)로 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="afa632a95dc9c80b866a354f23735d7bcd1157a2" translate="yes" xml:space="preserve">
          <source>Remove the elements of one array from another array.</source>
          <target state="translated">한 배열의 요소를 다른 배열에서 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="0697a27ec337b72d0e4d72523605d451a59444a0" translate="yes" xml:space="preserve">
          <source>Removes duplicates from elements in a sequence.</source>
          <target state="translated">순서대로 요소에서 중복을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="79a53851e290035c55b906df35b29aaa6f920cf9" translate="yes" xml:space="preserve">
          <source>Removing a field from a document</source>
          <target state="translated">문서에서 필드 제거</target>
        </trans-unit>
        <trans-unit id="67e44982c2b6ecb129404da6bb7b5c7d570feae7" translate="yes" xml:space="preserve">
          <source>Removing duplicate documents</source>
          <target state="translated">중복 문서 제거</target>
        </trans-unit>
        <trans-unit id="fd82550f7bdd5147fa9b38ad056203473cb75426" translate="yes" xml:space="preserve">
          <source>Removing the conflicting fields</source>
          <target state="translated">충돌하는 필드 제거</target>
        </trans-unit>
        <trans-unit id="b5140bff21a36c4d10e5e19f157b727b262facdd" translate="yes" xml:space="preserve">
          <source>Rename an existing secondary index on a table. If the optional argument &lt;code&gt;overwrite&lt;/code&gt; is specified as &lt;code&gt;true&lt;/code&gt;, a previously existing index with the new name will be deleted and the index will be renamed. If &lt;code&gt;overwrite&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default) an error will be raised if the new index name already exists.</source>
          <target state="translated">테이블에서 기존 보조 인덱스의 이름을 바꿉니다. 선택적 인수 &lt;code&gt;overwrite&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 지정 되면 새 이름을 가진 기존 색인이 삭제되고 색인 이름이 변경됩니다. 경우 &lt;code&gt;overwrite&lt;/code&gt; 인 &lt;code&gt;false&lt;/code&gt; 새 인덱스 이름이 이미 존재하는 경우 (기본값) 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3b77fd7d07db52ea2672fd8ede11ae8823105710" translate="yes" xml:space="preserve">
          <source>Rename the new index to the old index&amp;rsquo;s name with &lt;a href=&quot;https://rethinkdb.com/api/python/index_rename&quot;&gt;index_rename&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://rethinkdb.com/api/python/index_rename&quot;&gt;index_rename&lt;/a&gt; 을 사용하여 새 인덱스의 이름을 이전 인덱스의 이름으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="40c174bdf445078528f8a2f96d1df5c325ca2288" translate="yes" xml:space="preserve">
          <source>Renaming a database</source>
          <target state="translated">데이터베이스 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="284f910642e6a0defb4586578a3c2a7bd1161d13" translate="yes" xml:space="preserve">
          <source>Renaming a field when retrieving documents</source>
          <target state="translated">문서를 검색 할 때 필드 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="c85b059a75da0fd1dc38ae1c0c348e9320390608" translate="yes" xml:space="preserve">
          <source>Renaming the fields</source>
          <target state="translated">필드 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="6aca56afb789aecc38fe4230dec10a4632e60865" translate="yes" xml:space="preserve">
          <source>Replace an object in a field instead of merging it with an existing object in a &lt;code&gt;merge&lt;/code&gt; or &lt;code&gt;update&lt;/code&gt; operation. Using &lt;code&gt;literal&lt;/code&gt; with no arguments in a &lt;code&gt;merge&lt;/code&gt; or &lt;code&gt;update&lt;/code&gt; operation will remove the corresponding field.</source>
          <target state="translated">필드를 &lt;code&gt;merge&lt;/code&gt; 또는 &lt;code&gt;update&lt;/code&gt; 작업 에서 기존 개체와 병합하는 대신 필드의 개체를 바꾸십시오 . &lt;code&gt;merge&lt;/code&gt; 또는 &lt;code&gt;update&lt;/code&gt; 작업 에서 인수없이 &lt;code&gt;literal&lt;/code&gt; 을 사용 하면 해당 필드가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9ab64c46bc6706994c25c2b0a6ee60d324ab8b2d" translate="yes" xml:space="preserve">
          <source>Replace documents in a table. Accepts a JSON document or a ReQL expression, and replaces the original document with the new one. The new document must have the same primary key as the original document.</source>
          <target state="translated">테이블에서 문서를 교체하십시오. JSON 문서 또는 ReQL 표현식을 승인하고 원본 문서를 새 문서로 바꿉니다. 새 문서에는 원본 문서와 동일한 기본 키가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b6a9ea19f10bfe83981d4540dee88a3df008ec57" translate="yes" xml:space="preserve">
          <source>Replace returns an object that contains the following attributes:</source>
          <target state="translated">바꾸기는 다음 속성이 포함 된 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2c5d061d62323778048566a495b1df0b38ea2db7" translate="yes" xml:space="preserve">
          <source>Replaces cursors with streams.</source>
          <target state="translated">커서를 스트림으로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="722a8bb542ea393f48ca936e084109b805daa87a" translate="yes" xml:space="preserve">
          <source>Replication</source>
          <target state="translated">Replication</target>
        </trans-unit>
        <trans-unit id="bfc37608c32958ce7ebb03befffc73e782976778" translate="yes" xml:space="preserve">
          <source>Reporting vulnerabilities</source>
          <target state="translated">취약점보고</target>
        </trans-unit>
        <trans-unit id="8c34185af915f1e0949bfddb344b5dea859540d4" translate="yes" xml:space="preserve">
          <source>Repubsub implements a simple abstraction on top of RethinkDB to enable publish-subscribe. It uses ReQL as the filtering mechanism, so the full power of the language is at your disposal. This gives a lot more flexibility than traditional message queues.</source>
          <target state="translated">Repubsub는 RethinkDB 위에 간단한 추상화를 구현하여 publish-subscribe를 활성화합니다. 필터링 메커니즘으로 ReQL을 사용하므로 언어의 모든 기능을 사용할 수 있습니다. 이는 기존 메시지 대기열보다 훨씬 많은 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="552a6a287997255111938f1213d6239a6eb625b9" translate="yes" xml:space="preserve">
          <source>Request Options</source>
          <target state="translated">요청 옵션</target>
        </trans-unit>
        <trans-unit id="cf028cb289e92d72ecac0c14797660b76e05fb6f" translate="yes" xml:space="preserve">
          <source>Resolving field name conflicts</source>
          <target state="translated">필드 이름 충돌 해결</target>
        </trans-unit>
        <trans-unit id="5488d03c527f32b4acc287af95407883ab8f73b2" translate="yes" xml:space="preserve">
          <source>Response notes</source>
          <target state="translated">응답 메모</target>
        </trans-unit>
        <trans-unit id="edbff191035089d6d00fc87982482ed99855f37e" translate="yes" xml:space="preserve">
          <source>Response types</source>
          <target state="translated">응답 유형</target>
        </trans-unit>
        <trans-unit id="ab860e83a8bba4577ed1f5d169b6ff9b4a71a996" translate="yes" xml:space="preserve">
          <source>Responses from the server take the following form:</source>
          <target state="translated">서버의 응답은 다음 형식을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="3cbe6d6b9a8d1596bb5bca12e14d81c9e108a1a3" translate="yes" xml:space="preserve">
          <source>Restore</source>
          <target state="translated">Restore</target>
        </trans-unit>
        <trans-unit id="fa8c448a3304c7e3bba81325d21434fc4e1ab989" translate="yes" xml:space="preserve">
          <source>Restore &lt;code&gt;backup.tar.gz&lt;/code&gt; to the cluster running on &lt;code&gt;fortress&lt;/code&gt; at port &lt;code&gt;39500&lt;/code&gt;.</source>
          <target state="translated">포트 &lt;code&gt;39500&lt;/code&gt; 의 &lt;code&gt;fortress&lt;/code&gt; 에서 실행중인 클러스터로 &lt;code&gt;backup.tar.gz&lt;/code&gt; 를 복원 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c5aff5b034a17ad5b0aa80d1b5867fcaeafd472" translate="yes" xml:space="preserve">
          <source>Restore to the default cluster (&lt;code&gt;localhost:28015&lt;/code&gt;).</source>
          <target state="translated">기본 클러스터 ( &lt;code&gt;localhost:28015&lt;/code&gt; )로 복원하십시오 .</target>
        </trans-unit>
        <trans-unit id="cfb3d23e010f68e0af656c3a161f08787d49d8df" translate="yes" xml:space="preserve">
          <source>Restore to the default cluster, only importing the table &lt;code&gt;users&lt;/code&gt; to the database &lt;code&gt;league&lt;/code&gt; from the archive &lt;code&gt;backup.tar.gz&lt;/code&gt;. Read the &lt;code&gt;admin&lt;/code&gt; user password from the file &lt;code&gt;pw.txt&lt;/code&gt;. (This should be a plain text file with the password on the first and only line.)</source>
          <target state="translated">아카이브 &lt;code&gt;backup.tar.gz&lt;/code&gt; 에서 테이블 &lt;code&gt;users&lt;/code&gt; 를 데이터베이스 &lt;code&gt;league&lt;/code&gt; 로 가져 오기만 기본 클러스터로 복원하십시오 . &lt;code&gt;pw.txt&lt;/code&gt; 파일에서 &lt;code&gt;admin&lt;/code&gt; 비밀번호를 읽으십시오 . (첫 번째 및 유일한 행에 비밀번호가있는 일반 텍스트 파일이어야합니다.)</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="89ddb5cfb70d8bad46dda602a6ccbd88515a58d8" translate="yes" xml:space="preserve">
          <source>RethinkDB</source>
          <target state="translated">RethinkDB</target>
        </trans-unit>
        <trans-unit id="735933ae21af969b090b07b609e7695fc978b7ac" translate="yes" xml:space="preserve">
          <source>RethinkDB 2.1.5 performance &amp;amp; scaling report</source>
          <target state="translated">RethinkDB 2.1.5 성능 및 스케일링 보고서</target>
        </trans-unit>
        <trans-unit id="cb467484ded44adadf6f26ec92b1553d399b7b13" translate="yes" xml:space="preserve">
          <source>RethinkDB Documentation</source>
          <target state="translated">RethinkDB 문서</target>
        </trans-unit>
        <trans-unit id="e4d8c0ff3051c40b7a7d2280bdd1fcf8d66cf738" translate="yes" xml:space="preserve">
          <source>RethinkDB achieves a throughput of 14.6K QPS with two servers, and scales near-linearly as servers are added to the cluster.</source>
          <target state="translated">RethinkDB는 2 대의 서버로 14.6K QPS의 처리량을 달성하며 서버가 클러스터에 추가 될 때 거의 선형으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="e345c3b07e0fd9d1adeaa8ca81dd01baad355475" translate="yes" xml:space="preserve">
          <source>RethinkDB allows you to shard and replicate your cluster on a per-table basis. Settings can be controlled easily from the web administration console. In addition, ReQL commands for table configuration allow both scripting capability and more fine-grained control over replication, distributing replicas for individual tables across user-defined groups of servers using server tags.</source>
          <target state="translated">RethinkDB를 사용하면 테이블별로 클러스터를 분할하고 복제 할 수 있습니다. 웹 관리 콘솔에서 설정을 쉽게 제어 할 수 있습니다. 또한 테이블 구성을위한 ReQL 명령을 사용하면 스크립팅 기능과 복제를보다 세밀하게 제어 할 수 있으므로 서버 태그를 사용하여 사용자 정의 서버 그룹에 개별 테이블의 복제본을 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eda9071dab24f5356340e451144a72dcc92d3fce" translate="yes" xml:space="preserve">
          <source>RethinkDB and Rails</source>
          <target state="translated">DB 및 레일 재검토</target>
        </trans-unit>
        <trans-unit id="26e492bb4ea400bd0d23919baddf67941c58a444" translate="yes" xml:space="preserve">
          <source>RethinkDB automatically rebalances tables when the number of shards are increased, and as long as your documents have evenly distributed primary keys&amp;mdash;such as the default UUIDs&amp;mdash;it is rarely necessary to call &lt;code&gt;rebalance&lt;/code&gt; manually. Cases where &lt;code&gt;rebalance&lt;/code&gt; may need to be called include:</source>
          <target state="translated">샤드 수가 증가하고 문서에 기본 UUID와 같은 기본 키가 균등하게 분산되어있는 한 RethinkDB는 자동으로 테이블의 &lt;code&gt;rebalance&lt;/code&gt; 합니다. 케이스 &lt;code&gt;rebalance&lt;/code&gt; 호출 할 필요가 있습니다은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="ad70484f409d6361985bb8c8f93c7743544624d3" translate="yes" xml:space="preserve">
          <source>RethinkDB binary installed by the official package in &lt;code&gt;/usr/local/bin/rethinkdb&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;/usr/local/bin/rethinkdb&lt;/code&gt; 의 공식 패키지로 설치된 RethinkDB 바이너리</target>
        </trans-unit>
        <trans-unit id="b9fdbdd31616d7b419cfafad99fc5ceb4c45dd50" translate="yes" xml:space="preserve">
          <source>RethinkDB cache size set to 64,000 MB per server, otherwise default parameters</source>
          <target state="translated">서버 당 64,000MB로 설정된 RethinkDB 캐시 크기, 그렇지 않으면 기본 매개 변수</target>
        </trans-unit>
        <trans-unit id="6492843a1285914ee9da37e99939a00ce233450b" translate="yes" xml:space="preserve">
          <source>RethinkDB can be easily deployed on &lt;a href=&quot;http://compose.io/&quot;&gt;Compose&lt;/a&gt; and &lt;a href=&quot;http://aws.amazon.com/&quot;&gt;Amazon Web Services&lt;/a&gt;.</source>
          <target state="translated">RethinkDB는 &lt;a href=&quot;http://compose.io/&quot;&gt;Compose&lt;/a&gt; 및 &lt;a href=&quot;http://aws.amazon.com/&quot;&gt;Amazon Web Services&lt;/a&gt; 에 쉽게 배포 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="779613e061fcbb3ecdf1b3f674a77401d73451f7" translate="yes" xml:space="preserve">
          <source>RethinkDB can handle databases much larger than the amount of main memory available on a server. However, some internal metadata is always kept in memory to guarantee fast access times. Every table has an overhead of 8 MB per server.</source>
          <target state="translated">RethinkDB는 서버에서 사용 가능한 주 메모리 용량보다 훨씬 큰 데이터베이스를 처리 할 수 ​​있습니다. 그러나 일부 내부 메타 데이터는 빠른 액세스 시간을 보장하기 위해 항상 메모리에 보관됩니다. 모든 테이블의 오버 헤드는 서버 당 8MB입니다.</target>
        </trans-unit>
        <trans-unit id="a7a4715c972f6634315cdf77dceadee9d8dd2408" translate="yes" xml:space="preserve">
          <source>RethinkDB changefeeds</source>
          <target state="translated">DB 변경 피드 재검토</target>
        </trans-unit>
        <trans-unit id="72830b7dc8ac5c8f7d4784d89a3b380858da88d5" translate="yes" xml:space="preserve">
          <source>RethinkDB changefeeds synced with &lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt; app state</source>
          <target state="translated">&lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt; 앱 상태 와 동기화 된 RethinkDB 변경 피드</target>
        </trans-unit>
        <trans-unit id="1982a12bd3c3cd7086173906e98b7aa6c17ed25d" translate="yes" xml:space="preserve">
          <source>RethinkDB client drivers are responsible for serializing queries, sending them to the server using the ReQL wire protocol, and receiving responses from the server and returning them to the calling application. This process takes the following steps:</source>
          <target state="translated">RethinkDB 클라이언트 드라이버는 쿼리를 직렬화하고, ReQL 유선 프로토콜을 사용하여 서버로 쿼리를 보내고, 서버에서 응답을 수신하여 호출 애플리케이션으로 리턴합니다. 이 프로세스는 다음 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="29742e53bf514545423e131a5089ae63314110fd" translate="yes" xml:space="preserve">
          <source>RethinkDB clustering with CoreOS, etcd2 and Docker, by &lt;a href=&quot;https://github.com/pires&quot;&gt;@pires&lt;/a&gt;.</source>
          <target state="translated">@pires에 의해 &lt;a href=&quot;https://github.com/pires&quot;&gt;CoreOS&lt;/a&gt; , etcd2 및 Docker를 사용한 DB 클러스터링을 다시 생각하십시오 .</target>
        </trans-unit>
        <trans-unit id="546b0d2304c21245d3bc9748794a02297ae69be4" translate="yes" xml:space="preserve">
          <source>RethinkDB command line options</source>
          <target state="translated">RethinkDB 명령 행 옵션</target>
        </trans-unit>
        <trans-unit id="757b43f479974355f39e37a9afd966d958b550a0" translate="yes" xml:space="preserve">
          <source>RethinkDB controls access to clusters through a system based around &lt;strong&gt;users, permissions,&lt;/strong&gt; and &lt;strong&gt;scopes.&lt;/strong&gt; Together, these allow you to specify fine grained control for reading, writing and administrative access down to a per-table level.</source>
          <target state="translated">RethinkDB는 &lt;strong&gt;사용자, 권한&lt;/strong&gt; 및 &lt;strong&gt;범위를&lt;/strong&gt; 기반으로하는 시스템을 통해 클러스터에 대한 액세스를 제어합니다 &lt;strong&gt;. &lt;/strong&gt;이 둘을 함께 사용하면 테이블 수준까지 읽기, 쓰기 및 관리 액세스를위한 세밀한 제어를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5823fa08eb48445af67a4037ecc0701a77215e5" translate="yes" xml:space="preserve">
          <source>RethinkDB data directory will be &lt;code&gt;/Library/RethinkDB/data&lt;/code&gt;</source>
          <target state="translated">RethinkDB 데이터 디렉토리는 &lt;code&gt;/Library/RethinkDB/data&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="612315f0d5f8087ec3f0b4e7fce019c06049b1a8" translate="yes" xml:space="preserve">
          <source>RethinkDB demonstrates extremely high scalability in this configuration, reaching throughputs of well over a million queries per second. The slightly sub-linear scalability when going from 12 to 16 database servers is caused by the client servers&amp;rsquo; CPUs getting saturated at these throughputs.</source>
          <target state="translated">RethinkDB는이 구성에서 매우 높은 확장 성을 보여 초당 백만 건 이상의 쿼리 처리량에 도달합니다. 12 개에서 16 개의 데이터베이스 서버로 이동할 때 약간의 하위 선형 확장 성은 클라이언트 서버의 CPU가 이러한 처리량에서 포화 상태로 인해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8672db1bf1765198165013defafd20d8db24f975" translate="yes" xml:space="preserve">
          <source>RethinkDB does not currently have an optimizer. As an example, the following query will not automatically use an index:</source>
          <target state="translated">RethinkDB에는 현재 최적화 프로그램이 없습니다. 예를 들어 다음 쿼리는 인덱스를 자동으로 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="672811adc0003c264d287d9d90dddfe5392790ce" translate="yes" xml:space="preserve">
          <source>RethinkDB does not have fully automatic failover (yet), but if a server in a cluster crashes it can be manually removed from the cluster. In most cases, RethinkDB will recover from such a situation automatically. For information on this process, read &lt;a href=&quot;../failover/index&quot;&gt;Failover&lt;/a&gt;.</source>
          <target state="translated">RethinkDB에는 완전 자동 장애 조치 (아직)가 없지만 클러스터의 서버가 충돌하는 경우 클러스터에서 수동으로 제거 할 수 있습니다. 대부분의 경우 RethinkDB는 이러한 상황에서 자동으로 복구됩니다. 이 프로세스에 대한 자세한 내용은 &lt;a href=&quot;../failover/index&quot;&gt;장애 조치를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29225a505de5e9d97ccc052ef35e3e9e191310f6" translate="yes" xml:space="preserve">
          <source>RethinkDB does not support unique secondary indexes even for non-sharded tables.</source>
          <target state="translated">RethinkDB는 샤딩되지 않은 테이블에서도 고유 한 보조 인덱스를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a1e6552e69e48ce4c7f868763ae1040ab304a06" translate="yes" xml:space="preserve">
          <source>RethinkDB does take exclusive block-level locks in case multiple writes are performed on documents that are close together in the B-Tree. If the contested block is cached in memory, these locks are extremely short-lived. If the blocks need to be loaded from disk, these locks take longer. Typically this does not present performance problems because the top levels of the B-Tree are all cached along with the frequently used blocks, so in most cases writes can be performed essentially lock-free.</source>
          <target state="translated">RethinkDB는 B-Tree에서 서로 가까운 문서에서 여러 번 쓰기가 수행되는 경우 독점적 인 블록 수준 잠금을 수행합니다. 컨테스트 된 블록이 메모리에 캐시 된 경우 이러한 잠금은 수명이 매우 짧습니다. 디스크에서 블록을로드해야하는 경우 이러한 잠금이 더 오래 걸립니다. 일반적으로 B-Tree의 최상위 레벨이 자주 사용되는 블록과 함께 캐시되므로 대부분의 경우 쓰기가 기본적으로 잠금없이 수행 될 수 있으므로 성능 문제가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40f0f98da3c17608b70462f0c36e09dd4a185e21" translate="yes" xml:space="preserve">
          <source>RethinkDB has access to the query structure, which allows for optimization techniques similar to those available in SQL. This feature will be added to RethinkDB in the future.</source>
          <target state="translated">RethinkDB는 쿼리 구조에 액세스 할 수있어 SQL에서 사용 가능한 것과 유사한 최적화 기법을 사용할 수 있습니다. 이 기능은 향후 RethinkDB에 추가 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="cf29f8f9f21bf8fba6ea63ced9d6fae553e0b5eb" translate="yes" xml:space="preserve">
          <source>RethinkDB has failed to write to its log file (or to &lt;code&gt;stdout/stderr&lt;/code&gt;). The &lt;code&gt;message&lt;/code&gt; string will be the error that RethinkDB received from the operating system on the failed write; &lt;code&gt;servers&lt;/code&gt; will be a list of servers affected.</source>
          <target state="translated">RethinkDB가 로그 파일 (또는 &lt;code&gt;stdout/stderr&lt;/code&gt; ) 에 쓰지 못했습니다 . &lt;code&gt;message&lt;/code&gt; 문자열 RethinkDB 실패한 쓰기에 운영 체제에서 수신 한 오류가 될 것입니다; &lt;code&gt;servers&lt;/code&gt; 는 영향을받는 서버 목록이됩니다.</target>
        </trans-unit>
        <trans-unit id="2bc2af13435e602b512f4af7f70dee3bcd170db5" translate="yes" xml:space="preserve">
          <source>RethinkDB has native support for millisecond-precision times with time zones. Some highlights:</source>
          <target state="translated">RethinkDB는 표준 시간대로 밀리 초 단위의 정확한 시간을 지원합니다. 일부 주요 특징 :</target>
        </trans-unit>
        <trans-unit id="0fae139b6eb1367767e96d5c430169b70f3ebb30" translate="yes" xml:space="preserve">
          <source>RethinkDB has powerful Hadoop-style map-reduce tools, that integrate cleanly into the query language. Learn how they work, and play with a few examples.</source>
          <target state="translated">RethinkDB에는 강력한 Hadoop 스타일 맵 감소 도구가있어 쿼리 언어에 깔끔하게 통합됩니다. 그들이 어떻게 작동하는지 배우고 몇 가지 예를 들어보십시오.</target>
        </trans-unit>
        <trans-unit id="7b596f5ffcda7c2fb3cfedba5e4d1051b8fe7dbe" translate="yes" xml:space="preserve">
          <source>RethinkDB has shortcuts for five common aggregation operations: &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;avg&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, and &lt;code&gt;max&lt;/code&gt;. In practice, you&amp;rsquo;ll often be able to use these with &lt;code&gt;group&lt;/code&gt; in place of writing your own &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;reduce&lt;/code&gt; functions.</source>
          <target state="translated">RethinkDB에는 &lt;code&gt;count&lt;/code&gt; , &lt;code&gt;sum&lt;/code&gt; , &lt;code&gt;avg&lt;/code&gt; , &lt;code&gt;min&lt;/code&gt; 및 &lt;code&gt;max&lt;/code&gt; 의 다섯 가지 일반적인 집계 작업에 대한 바로 가기가 있습니다. 실제로는 &lt;code&gt;map&lt;/code&gt; 를 작성 하고 함수를 &lt;code&gt;reduce&lt;/code&gt; 대신 &lt;code&gt;group&lt;/code&gt; 과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bba8fb71c9832349f00a9f837897d44f12388f1" translate="yes" xml:space="preserve">
          <source>RethinkDB has shortcuts for five common aggregation operations: &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;avg&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, and &lt;code&gt;max&lt;/code&gt;. In practice, you&amp;rsquo;ll often be able to use these with &lt;code&gt;group&lt;/code&gt; these rather than writing your own &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;reduce&lt;/code&gt; functions.</source>
          <target state="translated">RethinkDB에는 &lt;code&gt;count&lt;/code&gt; , &lt;code&gt;sum&lt;/code&gt; , &lt;code&gt;avg&lt;/code&gt; , &lt;code&gt;min&lt;/code&gt; 및 &lt;code&gt;max&lt;/code&gt; 의 5 가지 일반적인 집계 작업에 대한 바로 가기가 있습니다. 실제로, 당신은 종종 자신의 &lt;code&gt;map&lt;/code&gt; 작성 하고 기능을 &lt;code&gt;reduce&lt;/code&gt; 대신 이들을 &lt;code&gt;group&lt;/code&gt; 과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a07a2f1e204ccef9ce95abeb8228ca595f3024c2" translate="yes" xml:space="preserve">
          <source>RethinkDB has three classes of errors: driver (&lt;code&gt;ReqlDriverError&lt;/code&gt;), query compilation (&lt;code&gt;ReqlCompileError&lt;/code&gt;) and runtime (errors subclassed from &lt;code&gt;ReqlRuntimeError&lt;/code&gt;).</source>
          <target state="translated">RethinkDB에는 드라이버 ( &lt;code&gt;ReqlDriverError&lt;/code&gt; ), 쿼리 컴파일 ( &lt;code&gt;ReqlCompileError&lt;/code&gt; ) 및 런타임 ( &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 에서 서브 클래 싱 된 오류) 의 세 가지 오류 클래스가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7024546f8577c97b82e4aeda6e9841941adc8703" translate="yes" xml:space="preserve">
          <source>RethinkDB in two minutes</source>
          <target state="translated">2 분 만에 DB 재검토</target>
        </trans-unit>
        <trans-unit id="4eeea1cb9e84ccba67aa59483a4f622f2c06144f" translate="yes" xml:space="preserve">
          <source>RethinkDB inverts the traditional database architecture by exposing an exciting new access model &amp;ndash; instead of polling for changes, the developer can tell RethinkDB to continuously push updated query results to applications in realtime.</source>
          <target state="translated">RethinkDB는 변경에 대한 폴링 대신 흥미로운 새로운 액세스 모델을 제공함으로써 기존 데이터베이스 아키텍처를 뒤집습니다. 개발자는 RethinkDB에 업데이트 된 쿼리 결과를 실시간으로 애플리케이션에 지속적으로 푸시하도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f15b38cf885439fce391405265382c8fb3a5eddc" translate="yes" xml:space="preserve">
          <source>RethinkDB is running out of memory</source>
          <target state="translated">RethinkDB에 메모리가 부족합니다</target>
        </trans-unit>
        <trans-unit id="025c104640a27fcf19c9484f3ab6cf659bfa56be" translate="yes" xml:space="preserve">
          <source>RethinkDB keeps an internal directory tracking the current state of the cluster: how many servers are accessible, what data is currently stored on each server, etc. The data structures that keep track of the directory are automatically updated when the cluster changes. For example, if a server dies due to power failure, the directory is updated to represent this change.</source>
          <target state="translated">RethinkDB는 클러스터의 현재 상태를 추적하는 내부 디렉토리를 유지합니다. 액세스 가능한 서버 수, 각 서버에 현재 저장되어있는 데이터 등. 디렉토리를 추적하는 데이터 구조는 클러스터가 변경 될 때 자동으로 업데이트됩니다. 예를 들어, 정전으로 인해 서버가 사망하면이 변경 사항을 나타내도록 디렉토리가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="cf9d083edb8c21c54d52f3036376df035b56b907" translate="yes" xml:space="preserve">
          <source>RethinkDB log will be &lt;code&gt;/var/log/rethinkdb.log&lt;/code&gt;</source>
          <target state="translated">RethinkDB 로그는 &lt;code&gt;/var/log/rethinkdb.log&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="12e7e6962d9b0bc38ee3bb81801ab1841743fac0" translate="yes" xml:space="preserve">
          <source>RethinkDB maintains availability if the user increases or decreases the number of replicas in the cluster. In most cases, the replication process should not have a strong performance impact on the real-time system.</source>
          <target state="translated">사용자가 클러스터의 복제본 수를 늘리거나 줄이면 RethinkDB는 가용성을 유지합니다. 대부분의 경우 복제 프로세스가 실시간 시스템에 큰 성능 영향을 미치지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="623536e8efae22fe8dbe6bff869831b8cb6a7ba8" translate="yes" xml:space="preserve">
          <source>RethinkDB makes building and scaling realtime apps dramatically easier. Get started by installing the server, and jump into our getting started guide to start building your first app in minutes.</source>
          <target state="translated">RethinkDB를 사용하면 실시간 앱을 쉽게 구축하고 확장 할 수 있습니다. 서버를 설치하여 시작하고 시작 안내서로 이동하여 몇 분 안에 첫 번째 앱 구축을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="2e85a94c44575620e7b9601eb22bb2499c37e1fb" translate="yes" xml:space="preserve">
          <source>RethinkDB may or may not maintain availability if the user modifies the number of shards. In many cases availability will be maintained, but currently it cannot be guaranteed. We&amp;rsquo;re exploring different solutions to remove this limitation.</source>
          <target state="translated">사용자가 샤드 수를 수정하면 RethinkDB가 가용성을 유지하거나 유지하지 않을 수 있습니다. 대부분의 경우 가용성은 유지되지만 현재 보장 할 수는 없습니다. 우리는이 한계를 없애기 위해 다양한 솔루션을 모색하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d55b0820382b90b873c36c3282a6665c40558fe" translate="yes" xml:space="preserve">
          <source>RethinkDB only allows conversion of GeoJSON objects which have ReQL equivalents: Point, LineString, and Polygon. MultiPoint, MultiLineString, and MultiPolygon are not supported. (You could, however, store multiple points, lines and polygons in an array and use a geospatial multi index with them.)</source>
          <target state="translated">RethinkDB는 ReQL에 해당하는 GeoJSON 객체 (Point, LineString 및 Polygon) 만 변환 할 수 있습니다. MultiPoint, MultiLineString 및 MultiPolygon은 지원되지 않습니다. 그러나 여러 점, 선 및 다각형을 배열에 저장하고 지리 공간 다중 인덱스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05eba76c1e3bf668992e43cbb82de3b220dab3cc" translate="yes" xml:space="preserve">
          <source>RethinkDB only allows conversion of GeoJSON objects which have ReQL equivalents: Point, LineString, and Polygon; MultiPoint, MultiLineString, and MultiPolygon are not supported. (You could, however, store multiple points, lines and polygons in an array and use a geospatial multi index with them.)</source>
          <target state="translated">RethinkDB는 ReQL에 해당하는 GeoJSON 객체 (Point, LineString 및 Polygon) 만 변환 할 수 있습니다. MultiPoint, MultiLineString 및 MultiPolygon은 지원되지 않습니다. 그러나 여러 점, 선 및 다각형을 배열에 저장하고 지리 공간 다중 인덱스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae8f4e6bd74894f0a648d341946431e0292b55f6" translate="yes" xml:space="preserve">
          <source>RethinkDB operates at peak performance when the batch size is around two hundred documents.</source>
          <target state="translated">배치 크기가 약 200 개의 문서 인 경우 RethinkDB는 최고의 성능으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="08ab91ee1258986387b10e654d9e4c5d42985b98" translate="yes" xml:space="preserve">
          <source>RethinkDB operations are never atomic across multiple keys. For this reason, RethinkDB cannot be considered an ACID database.</source>
          <target state="translated">RethinkDB 작업은 여러 키에 걸쳐 원자 적이 지 않습니다. 이러한 이유로 RethinkDB는 ACID 데이터베이스로 간주 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8741a43490c434407d3eb5b4660dc5f8849570f6" translate="yes" xml:space="preserve">
          <source>RethinkDB organizes data into blocks. Blocks in RethinkDB are sized in steps of 512 bytes up to a maximum of 4 KB. While the content of a block itself can be cleared from main memory to free space, metadata of approximately 10&amp;ndash;26 bytes per block is always kept in memory. Thus, this memory overhead is directly proportional to the number of blocks that a given data set requires. (This is in addition to the 8 MB overhead mentioned above.)</source>
          <target state="translated">RethinkDB는 데이터를 블록으로 구성합니다. RethinkDB의 블록 크기는 512 바이트 단위로 최대 4KB까지입니다. 블록 자체의 내용은 기본 메모리에서 여유 공간으로 지울 수 있지만 블록 당 약 10-26 바이트의 메타 데이터는 항상 메모리에 유지됩니다. 따라서이 메모리 오버 헤드는 주어진 데이터 세트에 필요한 블록 수에 정비례합니다. (이는 위에서 언급 한 8MB 오버 헤드에 추가됩니다.)</target>
        </trans-unit>
        <trans-unit id="b9269f54553fd9442463297c700ee2b8e73e7de2" translate="yes" xml:space="preserve">
          <source>RethinkDB packages automatically install an init script at &lt;code&gt;/etc/init.d/rethinkdb&lt;/code&gt; and add default run-level entries. For RethinkDB to automatically run on system startup, you&amp;rsquo;ll need to add a config file to &lt;code&gt;/etc/rethinkdb/instances.d/&lt;/code&gt;.</source>
          <target state="translated">RethinkDB 패키지는 &lt;code&gt;/etc/init.d/rethinkdb&lt;/code&gt; 에 init 스크립트를 자동으로 설치하고 기본 실행 레벨 항목을 추가합니다. 시스템 시작시 RethinkDB를 자동으로 실행하려면 &lt;code&gt;/etc/rethinkdb/instances.d/&lt;/code&gt; 에 구성 파일을 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c7f008700c05c1865d12295437922484ecae3c18" translate="yes" xml:space="preserve">
          <source>RethinkDB provides a web interface which lets you manage your entire server cluster, from controlling sharding and replication to running ReQL queries (in JavaScript), with editing and history support. In addition, you can perform administration tasks using scriptable ReQL commands.</source>
          <target state="translated">RethinkDB는 편집 및 히스토리 지원을 통해 샤딩 및 복제 제어에서 JavaScript로 실행중인 ReQL 쿼리에 이르기까지 전체 서버 클러스터를 관리 할 수있는 웹 인터페이스를 제공합니다. 또한 스크립트 가능한 ReQL 명령을 사용하여 관리 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f7f159d2a79c214cc2f935797ab4190a4a3c1ee" translate="yes" xml:space="preserve">
          <source>RethinkDB provides an &lt;a href=&quot;../../api/javascript/http/index&quot;&gt;r.http&lt;/a&gt; command for accessing external APIs directly from the database. Since many APIs accept and return JSON, RethinkDB is a convenient platform for manipulating and analyzing API data, both interactively and in running applications.</source>
          <target state="translated">RethinkDB는 데이터베이스에서 직접 외부 API에 액세스하기 위한 &lt;a href=&quot;../../api/javascript/http/index&quot;&gt;r.http&lt;/a&gt; 명령을 제공 합니다. 많은 API가 JSON을 수락하고 반환하므로 RethinkDB는 대화식으로 또는 실행중인 응용 프로그램에서 API 데이터를 조작하고 분석하는 편리한 플랫폼입니다.</target>
        </trans-unit>
        <trans-unit id="b8d1105c1ecf2daa0d8a73d978e1f6486a4435a7" translate="yes" xml:space="preserve">
          <source>RethinkDB provides an &lt;a href=&quot;../../api/javascript/http/index&quot;&gt;r.http&lt;/a&gt; command for accessing external APIs directly from the database. Since many APIs accept and return JSON, RethinkDB is a convenient platform for manipulating and analyzing API data, both interactively and in running applications. Make sure that you &lt;strong&gt;never&lt;/strong&gt; use this command for &lt;strong&gt;user provided&lt;/strong&gt; URLs.</source>
          <target state="translated">RethinkDB는 데이터베이스에서 직접 외부 API에 액세스하기 위한 &lt;a href=&quot;../../api/javascript/http/index&quot;&gt;r.http&lt;/a&gt; 명령을 제공 합니다. 많은 API가 JSON을 수락하고 반환하기 때문에 RethinkDB는 대화식으로 그리고 실행중인 애플리케이션에서 API 데이터를 조작하고 분석하기위한 편리한 플랫폼입니다. 당신이 확인 &lt;strong&gt;결코&lt;/strong&gt; 이 명령을 사용하지 않는 &lt;strong&gt;사용자가 제공&lt;/strong&gt; 하는 URL.</target>
        </trans-unit>
        <trans-unit id="7f522c8137b2011dbb2715593ecd36021f7cbfe7" translate="yes" xml:space="preserve">
          <source>RethinkDB server</source>
          <target state="translated">RethinkDB 서버</target>
        </trans-unit>
        <trans-unit id="b74edfe769c267c7428c9983eb180ae400916f47" translate="yes" xml:space="preserve">
          <source>RethinkDB ships with simple tools to perform a hot backup of a running cluster. See the &lt;a href=&quot;../backup/index&quot;&gt;backup instructions&lt;/a&gt; for more details.</source>
          <target state="translated">RethinkDB는 실행중인 클러스터의 핫 백업을 수행하는 간단한 도구와 함께 제공됩니다. 자세한 내용은 &lt;a href=&quot;../backup/index&quot;&gt;백업 지침&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca3a98b62a215786642692f61a3dcc4decf1ecb3" translate="yes" xml:space="preserve">
          <source>RethinkDB supports &lt;a href=&quot;../../changefeeds/index&quot;&gt;changefeeds&lt;/a&gt;, which allow you to subscribe to changes on a table. The database pushes these changes to you as they happen.</source>
          <target state="translated">RethinkDB 지원 &lt;a href=&quot;../../changefeeds/index&quot;&gt;changefeeds&lt;/a&gt; 당신이 테이블에 변화를 구독 할 수 있습니다. 데이터베이스는 이러한 변경 사항이 발생하면이를 사용자에게 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="84dcf0975c77e90cf88fc77f75f9af0d1107ebf5" translate="yes" xml:space="preserve">
          <source>RethinkDB supports &lt;a href=&quot;../../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt;, which allow you to subscribe to changes on a table. The database pushes these changes to you as they happen.</source>
          <target state="translated">RethinkDB 지원 &lt;a href=&quot;../../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt; 당신이 테이블에 변화를 구독 할 수 있습니다. 데이터베이스는 이러한 변경 사항이 발생할 때이를 사용자에게 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="f539d29ec109400beb33e87944c1bc419991ee37" translate="yes" xml:space="preserve">
          <source>RethinkDB supports a native binary object type, letting you use ReQL to store binary objects directly in the database. The ReQL driver will transparently translate between the ReQL type and Node.js &lt;a href=&quot;http://nodejs.org/api/buffer.html&quot;&gt;Buffers&lt;/a&gt;.</source>
          <target state="translated">RethinkDB는 기본 이진 객체 유형을 지원하므로 ReQL을 사용하여 이진 객체를 데이터베이스에 직접 저장할 수 있습니다. ReQL 드라이버는 ReQL 유형과 Node.js &lt;a href=&quot;http://nodejs.org/api/buffer.html&quot;&gt;버퍼&lt;/a&gt; 사이를 투명하게 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="b79de0235d3d7e49d6270396cae554871735eba3" translate="yes" xml:space="preserve">
          <source>RethinkDB supports automatic failover when more than half of the voting replicas for each shard of a table are still available (see the &lt;a href=&quot;../../../docs/failover/index&quot;&gt;Failover&lt;/a&gt; documentation for more details). However, if half or more of the voting replicas for a shard are lost, failover will not happen automatically, leaving two options:</source>
          <target state="translated">RethinkDB는 테이블의 각 샤드에 대해 투표 복제본의 절반 이상을 계속 사용할 수있는 경우 자동 장애 조치를 지원합니다 (자세한 내용은 &lt;a href=&quot;../../../docs/failover/index&quot;&gt;장애 조치&lt;/a&gt; 설명서 참조). 그러나 샤드에 대한 투표 복제본 중 절반 이상이 손실되면 장애 조치가 자동으로 수행되지 않으므로 다음 두 가지 옵션이 남습니다.</target>
        </trans-unit>
        <trans-unit id="f6ad0355b7469785a915bd6fcb267d42c7a9623f" translate="yes" xml:space="preserve">
          <source>RethinkDB supports both secondary and compound indexes, as well as indexes that compute arbitrary expressions. You can see examples of how to use the secondary index API &lt;a href=&quot;../secondary-indexes/index&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">RethinkDB는 보조 및 복합 인덱스와 임의의 표현식을 계산하는 인덱스를 모두 지원합니다. &lt;a href=&quot;../secondary-indexes/index&quot;&gt;여기&lt;/a&gt; 에서 보조 색인 API를 사용하는 방법의 예를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc0a64248d0d6d9b7730531fe524793090fdf2c0" translate="yes" xml:space="preserve">
          <source>RethinkDB supports both secondary and compound indexes, as well as indexes that compute arbitrary expressions. You can see examples of how to use the secondary index API &lt;a href=&quot;../secondary-indexes/javascript/index&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">RethinkDB는 2 차 및 복합 색인뿐만 아니라 임의의 표현식을 계산하는 색인을 모두 지원합니다. 보조 인덱스 API를 사용하는 방법의 예는 &lt;a href=&quot;../secondary-indexes/javascript/index&quot;&gt;여기&lt;/a&gt; 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="71d8b68931056a0d66d312a06ccb2e2e6cb5d9a2" translate="yes" xml:space="preserve">
          <source>RethinkDB supports both up-to-date and out-of-date reads. By default, all read queries are executed up-to-date, which means that every read operation for a given shard is routed to the primary replica for that shard and executed in order with other operations on the shard. In this default mode, the client always sees the latest, consistent, artifact-free view of the data.</source>
          <target state="translated">RethinkDB는 최신 및 최신 읽기를 모두 지원합니다. 기본적으로 모든 읽기 쿼리는 최신 상태로 실행되므로 지정된 샤드의 모든 읽기 작업이 해당 샤드의 기본 복제본으로 라우팅되고 샤드의 다른 작업과 순서대로 실행됩니다. 이 기본 모드에서 클라이언트는 항상 최신의 일관된 아티팩트없는 데이터보기를 봅니다.</target>
        </trans-unit>
        <trans-unit id="f11243238b91ef1b89680e4c273314a374928ae0" translate="yes" xml:space="preserve">
          <source>RethinkDB supports different types of secondary indexes:</source>
          <target state="translated">RethinkDB는 다양한 유형의 보조 인덱스를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="56794295c6dd1026fd6f7ec8b02775e58186eb63" translate="yes" xml:space="preserve">
          <source>RethinkDB supports most commonly used file systems. It optionally supports direct disk I/O for greater efficiency, but this is not enabled by default.</source>
          <target state="translated">RethinkDB는 가장 일반적으로 사용되는 파일 시스템을 지원합니다. 효율성을 높이기 위해 직접 디스크 I / O를 선택적으로 지원하지만 기본적으로 활성화되어 있지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="10e2f3eb29f4d8af581f7118e24c03dfdcd9a5d9" translate="yes" xml:space="preserve">
          <source>RethinkDB supports replication of data: every table in a database can be replicated as many times as you have servers in a cluster. Setting up replication is a simple operation with the web interface or the command line tool. For details, read &lt;a href=&quot;../sharding-and-replication/index&quot;&gt;Sharding and replication&lt;/a&gt;.</source>
          <target state="translated">RethinkDB는 데이터 복제를 지원합니다. 데이터베이스에있는 모든 테이블은 클러스터에 서버가있는 횟수만큼 복제 할 수 있습니다. 웹 인터페이스 또는 명령 줄 도구를 사용하여 복제를 간단하게 설정할 수 있습니다. 자세한 내용은 &lt;a href=&quot;../sharding-and-replication/index&quot;&gt;샤딩 및 복제&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2cb54ac86a86c52460e890916d58c1288376ab8b" translate="yes" xml:space="preserve">
          <source>RethinkDB supports spatial and geographic queries through geometry object support.</source>
          <target state="translated">RethinkDB는 지오메트리 객체 지원을 통해 공간 및 지리적 쿼리를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d32fa6ee6031165bb84247418c80028e7ab18532" translate="yes" xml:space="preserve">
          <source>RethinkDB supports the WGS84 World Geodetic System&amp;rsquo;s reference ellipsoid and geographic coordinate system (GCS). It does not directly support any projected coordinate system (PCS), but there are many tools available for performing such projections.</source>
          <target state="translated">RethinkDB는 WGS84 World Geodetic System의 참조 타원체 및 지리 좌표계 (GCS)를 지원합니다. PCS (Projected Coordinate System)를 직접 지원하지는 않지만 이러한 투영을 수행하는 데 사용할 수있는 많은 도구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9c7488acfc62299ace979066c1e3f08638dfc5c" translate="yes" xml:space="preserve">
          <source>RethinkDB uses a range sharding algorithm parameterized on the table&amp;rsquo;s primary key to partition the data. When the user states they want a given table to use a certain number of shards, the system examines the statistics for the table and finds the optimal set of split points to break up the table evenly. All sharding is currently done based on the table&amp;rsquo;s primary key, and cannot be done based on any other attribute (in RethinkDB the primary key and the shard key are effectively the same thing).</source>
          <target state="translated">RethinkDB는 테이블의 기본 키에 매개 변수화 된 범위 샤딩 알고리즘을 사용하여 데이터를 분할합니다. 사용자가 특정 테이블에서 특정 개수의 샤드를 사용하도록하려면 시스템이 테이블에 대한 통계를 검사하고 테이블을 균등하게 분할 할 최적의 분할 지점을 찾습니다. 모든 샤딩은 현재 테이블의 기본 키를 기반으로 수행되며 다른 속성을 기반으로 수행 할 수 없습니다 (RethinkDB에서는 기본 키와 샤드 키가 사실상 동일 함).</target>
        </trans-unit>
        <trans-unit id="5f2b0afa489f326033447882c4ce512558bc7c6f" translate="yes" xml:space="preserve">
          <source>RethinkDB uses a safe default configuration for write acknowledgement. Each write is committed to disk before the server acknowledges it to the client. If you&amp;rsquo;re running a single thread that inserts documents into RethinkDB in a loop, each insert must wait for the server acknowledgement before proceeding to the next one. This can significantly slow down the overall throughput.</source>
          <target state="translated">RethinkDB는 쓰기 승인을 위해 안전한 기본 구성을 사용합니다. 서버가 클라이언트에 승인하기 전에 각 쓰기는 디스크에 커밋됩니다. 루프에서 RethinkDB에 문서를 삽입하는 단일 스레드를 실행하는 경우 각 삽입은 다음 승인을 진행하기 전에 서버 승인을 기다려야합니다. 이로 인해 전체 처리량이 크게 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87d7ed56e064cdc2be5c3c306b0a024e244f7da3" translate="yes" xml:space="preserve">
          <source>RethinkDB uses byte-wise ordering for &lt;code&gt;between&lt;/code&gt; and does not support Unicode collations; non-ASCII characters will be sorted by UTF-8 codepoint.</source>
          <target state="translated">RethinkDB는 &lt;code&gt;between&lt;/code&gt; 바이트 단위 순서를 사용하며 유니 코드 데이터 정렬을 지원하지 않습니다. 비 ASCII 문자는 UTF-8 코드 포인트로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="a2b7492bd98ab8c96ed190967271aac8f2b9a308" translate="yes" xml:space="preserve">
          <source>RethinkDB uses the &lt;a href=&quot;https://en.wikipedia.org/wiki/Raft_(computer_science)&quot;&gt;Raft algorithm&lt;/a&gt; to store and propagate cluster configuration in most cases, although there are some situations it uses semilattices, versioned with internal timestamps. This architecture turns out to have sufficient mathematical properties to address all the issues mentioned above (this result has been known in distributed systems research for quite a while).</source>
          <target state="translated">RethinkDB는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Raft_(computer_science)&quot;&gt;Raft 알고리즘&lt;/a&gt; 을 사용하여 대부분의 경우 클러스터 구성을 저장 및 전파하지만 내부 타임 스탬프 버전의 반격 자를 사용하는 경우도 있습니다. 이 아키텍처는 위에서 언급 한 모든 문제를 해결하기에 충분한 수학적 특성을 갖는 것으로 판명되었습니다 (이 결과는 분산 시스템 연구에서 꽤 오랫동안 알려졌습니다).</target>
        </trans-unit>
        <trans-unit id="ad9e86f0c36323e6c20f0c976359840d640f76c9" translate="yes" xml:space="preserve">
          <source>RethinkDB uses the same protocol for communication within a datacenter as it does across datacenters. Because the architecture is immediately consistent and does not require quorums on individual document reads and writes, the latency issues commonly associated with cross-datacenter quorums on Dynamo-style systems do not arise in RethinkDB.</source>
          <target state="translated">RethinkDB는 데이터 센터 내에서와 동일한 데이터 프로토콜 내 통신에 동일한 프로토콜을 사용합니다. 아키텍처는 즉시 일관성이 있으며 개별 문서 읽기 및 쓰기에서 쿼럼이 필요하지 않기 때문에 RethinkDB에서는 Dynamo 스타일 시스템의 교차 데이터 센터 쿼럼과 일반적으로 관련된 대기 시간 문제가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e113a38cea5f70d16b5f974ca8331179248d2d4" translate="yes" xml:space="preserve">
          <source>RethinkDB uses three ports to operate&amp;mdash;the HTTP web UI port, the client drivers port, and the intracluster traffic port. You can connect the browser to the web UI port to administer the cluster right from your browser, and connect the client drivers to the client driver port to run queries from your application. If you&amp;rsquo;re running a cluster, different RethinkDB nodes communicate with each other via the intracluster traffic port.</source>
          <target state="translated">RethinkDB는 HTTP 웹 UI 포트, 클라이언트 드라이버 포트 및 클러스터 내 트래픽 포트의 세 가지 포트를 사용하여 작동합니다. 브라우저를 웹 UI 포트에 연결하여 브라우저에서 바로 클러스터를 관리하고 클라이언트 드라이버를 클라이언트 드라이버 포트에 연결하여 응용 프로그램에서 쿼리를 실행할 수 있습니다. 클러스터를 실행중인 경우 다른 RethinkDB 노드는 클러스터 내 트래픽 포트를 통해 서로 통신합니다.</target>
        </trans-unit>
        <trans-unit id="82c73af11c06078443ac96c46a3ff491a24f303f" translate="yes" xml:space="preserve">
          <source>RethinkDB version 2.1.5</source>
          <target state="translated">RethinkDB 버전 2.1.5</target>
        </trans-unit>
        <trans-unit id="64be170039b96e0579e9278dd905f8db6230488d" translate="yes" xml:space="preserve">
          <source>RethinkDB will accept two formats for JSON files:</source>
          <target state="translated">RethinkDB는 JSON 파일에 대해 두 가지 형식을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="1b3f223b9bb1750bce96d8634333989e0ebc07d7" translate="yes" xml:space="preserve">
          <source>RethinkDB will automatically load on startup. To disable this behavior, change the &lt;code&gt;RunAtLoad&lt;/code&gt; key to &lt;code&gt;&amp;lt;false/&amp;gt;&lt;/code&gt; in the &lt;code&gt;plist&lt;/code&gt; file.</source>
          <target state="translated">RethinkDB는 시작시 자동으로로드됩니다. 이 동작을 비활성화하려면 &lt;code&gt;plist&lt;/code&gt; 파일 에서 &lt;code&gt;RunAtLoad&lt;/code&gt; 키를 &lt;code&gt;&amp;lt;false/&amp;gt;&lt;/code&gt; 로 변경 하십시오.</target>
        </trans-unit>
        <trans-unit id="188b67359aa222e3ea9d29fed4e862f6d351f160" translate="yes" xml:space="preserve">
          <source>RethinkDB will generate a primary key and return it in &lt;code&gt;generated_keys&lt;/code&gt;.</source>
          <target state="translated">RethinkDB는 기본 키를 생성하고 그것에서 돌아 &lt;code&gt;generated_keys&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="431dcb2d29ab61bb877a049c1843bebcddf81fc6" translate="yes" xml:space="preserve">
          <source>RethinkDB will notify your program of all changes in the &lt;code&gt;authors&lt;/code&gt; table and will include the old value and the new value of each modified document. See the &lt;a href=&quot;../../changefeeds/index&quot;&gt;changefeeds&lt;/a&gt; documentation entry for more details on how to use realtime feeds in RethinkDB.</source>
          <target state="translated">RethinkDB는 &lt;code&gt;authors&lt;/code&gt; 테이블 의 모든 변경 사항을 프로그램에 알리고 수정 된 각 문서의 이전 값과 새 값을 포함합니다. &lt;a href=&quot;../../changefeeds/index&quot;&gt;RethinkDB&lt;/a&gt; 에서 실시간 피드를 사용하는 방법에 대한 자세한 내용 은 changefeeds 문서 항목을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="ac7af94097e441aba69be3324247352a59b9643a" translate="yes" xml:space="preserve">
          <source>RethinkDB will notify your program of all changes in the &lt;code&gt;authors&lt;/code&gt; table and will include the old value and the new value of each modified document. See the &lt;a href=&quot;../../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt; documentation entry for more details on how to use realtime feeds in RethinkDB.</source>
          <target state="translated">RethinkDB는 &lt;code&gt;authors&lt;/code&gt; 테이블 의 모든 변경 사항을 프로그램에 알리고 수정 된 각 문서의 이전 값과 새 값을 포함합니다. &lt;a href=&quot;../../changefeeds/javascript/index&quot;&gt;RethinkDB&lt;/a&gt; 에서 실시간 피드를 사용하는 방법에 대한 자세한 내용 은 changefeeds 문서 항목을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f968cad894d6556a053a28efbaa35e8a48e757e7" translate="yes" xml:space="preserve">
          <source>RethinkDB will process this query with the following steps:</source>
          <target state="translated">RethinkDB는 다음 단계로이 쿼리를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="64b9b5257d87ef3a851f521694a7f625e0295a7e" translate="yes" xml:space="preserve">
          <source>RethinkDB will seamlessly evaluate the &lt;code&gt;js&lt;/code&gt; command by calling into the V8 engine during the evaluation of the &lt;code&gt;filter&lt;/code&gt; query. You can combine most queries this way into progressively more complex ones.</source>
          <target state="translated">RethinkDB는 &lt;code&gt;filter&lt;/code&gt; 쿼리를 평가하는 동안 V8 엔진을 호출 하여 &lt;code&gt;js&lt;/code&gt; 명령을 원활하게 평가합니다 . 이 방법으로 대부분의 쿼리를 점진적으로 더 복잡한 쿼리로 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aaa0bfa56109a4dcf6840553fb0b62be795519d3" translate="yes" xml:space="preserve">
          <source>RethinkDB write operations will only throw exceptions if errors occur before any writes. Other errors will be listed in &lt;code&gt;first_error&lt;/code&gt;, and &lt;code&gt;errors&lt;/code&gt; will be set to a non-zero count. To properly handle errors with this term, code must both handle exceptions and check the &lt;code&gt;errors&lt;/code&gt; return value!</source>
          <target state="translated">RethinkDB 쓰기 작업은 쓰기 전에 오류가 발생한 경우에만 예외를 발생시킵니다. 다른 오류는 &lt;code&gt;first_error&lt;/code&gt; 에 나열 되고 &lt;code&gt;errors&lt;/code&gt; 는 0이 아닌 수로 설정됩니다. 이 용어로 오류를 올바르게 처리하려면 코드에서 예외를 처리하고 &lt;code&gt;errors&lt;/code&gt; 반환 값을 확인해야합니다 !</target>
        </trans-unit>
        <trans-unit id="34e087373ce7adace20d25fd88b9372fbefa4968" translate="yes" xml:space="preserve">
          <source>RethinkDB&amp;rsquo;s GMR queries are distributed and parallelized across shards and CPU cores whenever possible. While this allows them to execute efficiently, it&amp;rsquo;s important to keep in mind that the &lt;code&gt;reduce&lt;/code&gt; function is &lt;em&gt;not&lt;/em&gt; called on the elements of its input stream from left to right. It&amp;rsquo;s called on either the elements of the stream &lt;em&gt;in any order&lt;/em&gt; or on the output of previous calls to the function.</source>
          <target state="translated">RethinkDB의 GMR 쿼리는 가능할 때마다 샤드 및 CPU 코어에 분산되고 병렬화됩니다. 이렇게하면 효율적으로 실행할 수 있지만 입력 스트림의 요소에서 왼쪽에서 오른쪽으로 &lt;code&gt;reduce&lt;/code&gt; 기능이 호출 &lt;em&gt;되지 않는다는&lt;/em&gt; 점을 명심해야합니다 . 스트림의 요소 &lt;em&gt;에서 순서에 관계없이&lt;/em&gt; 호출되거나 함수에 대한 이전 호출의 출력에서 ​​호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b133a4402124e33904942b046a7e475fcf7c87c8" translate="yes" xml:space="preserve">
          <source>RethinkDB&amp;rsquo;s UUIDs are standards-compliant. Without the optional argument, a version 4 random UUID will be generated; with that argument, a version 5 UUID will be generated, using a fixed namespace UUID of &lt;code&gt;91461c99-f89d-49d2-af96-d8e2e14e9b58&lt;/code&gt;. For more information, read &lt;a href=&quot;https://en.wikipedia.org/wiki/Universally_unique_identifier&quot;&gt;Wikipedia&amp;rsquo;s UUID article&lt;/a&gt;.</source>
          <target state="translated">RethinkDB의 UUID는 표준을 준수합니다. 선택적 인수가 없으면 버전 4 임의 UUID가 생성됩니다. 이 인수를 사용하면 고정 네임 스페이스 UUID &lt;code&gt;91461c99-f89d-49d2-af96-d8e2e14e9b58&lt;/code&gt; 을 사용하여 버전 5 UUID가 생성됩니다 . 자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Universally_unique_identifier&quot;&gt;Wikipedia의 UUID 기사를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0da7bfd7ba58030ff21673f3096c2d4399c90c10" translate="yes" xml:space="preserve">
          <source>RethinkDB&amp;rsquo;s automatic failover has limitations in cases of non-transitive connectivity failure, i.e., server A can contact B and B can contact C, but A cannot contact C. Read the &lt;a href=&quot;../failover/index&quot;&gt;Failover&lt;/a&gt; documentation for more details.</source>
          <target state="translated">RethinkDB의 자동 장애 조치 (failover)에는 전이가 아닌 연결 실패의 경우 제한이 있습니다. 즉, 서버 A는 B에 연결할 수 있고 B는 C에 연결할 수 있지만 A는 C에 연결할 수 없습니다 . 자세한 내용 은 &lt;a href=&quot;../failover/index&quot;&gt;장애 조치&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f1fe8ed60518c4cc231f66de64be6b6b14e157f1" translate="yes" xml:space="preserve">
          <source>RethinkDB&amp;rsquo;s basic data types include numbers, strings, boolean values, objects, arrays, and the &lt;code&gt;null&lt;/code&gt; value. In addition, it stores RethinkDB-specific data types including tables, streams, selections, binary objects, time objects, geometry data types, and grouped data.</source>
          <target state="translated">RethinkDB의 기본 데이터 유형에는 숫자, 문자열, 부울 값, 객체, 배열 및 &lt;code&gt;null&lt;/code&gt; 값이 포함됩니다. 또한 테이블, 스트림, 선택, 이진 객체, 시간 객체, 지오메트리 데이터 유형 및 그룹화 된 데이터를 포함한 RethinkDB 관련 데이터 유형을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="0ca7a8d234327a4022cad363f1285f21bac0f144" translate="yes" xml:space="preserve">
          <source>RethinkDB&amp;rsquo;s default settings prioritize safety over performance, except in one case: &lt;code&gt;read_mode&lt;/code&gt; defaults to &lt;code&gt;single&lt;/code&gt; rather than &lt;code&gt;majority&lt;/code&gt;. The &lt;code&gt;majority&lt;/code&gt; read mode requires sending a query to all of the replicas and waiting for a majority to reply, which significantly degrades performance.</source>
          <target state="translated">RethinkDB의 기본 설정은 한 가지 경우를 제외하고 성능보다 안전을 우선시합니다. &lt;code&gt;read_mode&lt;/code&gt; 의 기본값 은 &lt;code&gt;majority&lt;/code&gt; 아닌 &lt;code&gt;single&lt;/code&gt; 입니다. &lt;code&gt;majority&lt;/code&gt; 읽기 모드는 모든 복제본에 쿼리를 전송하고 대부분의 성능이 크게 저하하는 회신을 기다리고 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bb2f37e7edacabf1482154290f8348ef4776073d" translate="yes" xml:space="preserve">
          <source>RethinkDB&amp;rsquo;s defaults tend to prioritize safety over performance. One of those defaults is that queries will be sent to the primary replicas for shards, which will always have current data (although that data may be returned to a query before it&amp;rsquo;s been committed to disk).</source>
          <target state="translated">RethinkDB의 기본값은 성능보다 안전을 우선시하는 경향이 있습니다. 이러한 기본값 중 하나는 쿼리가 샤드의 기본 복제본으로 전송되며 항상 최신 데이터를 갖습니다 (데이터는 디스크에 커밋되기 전에 쿼리로 반환 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="db4c9426f43aa7a8535f8d64ebcc1ea7e3791bc5" translate="yes" xml:space="preserve">
          <source>RethinkDB&amp;rsquo;s page cache keeps recently used data in memory to minimize disk access. By default, RethinkDB automatically configures the cache size limit according to the formula &lt;code&gt;(available_mem - 1024 MB) / 2&lt;/code&gt;. &lt;code&gt;available_mem&lt;/code&gt; is the amount of available memory at the time RethinkDB starts, including memory that can be freed up by the operating system if needed (such as the operating system&amp;rsquo;s disk cache). If there is less than 1224 MB of memory available on the system, a minimum cache size limit of 100 MB is used. You can find the actual size limit used by an instance of RethinkDB in its log.</source>
          <target state="translated">RethinkDB의 페이지 캐시는 최근에 사용한 데이터를 메모리에 보관하여 디스크 액세스를 최소화합니다. 기본적으로 RethinkDB는 공식 &lt;code&gt;(available_mem - 1024 MB) / 2&lt;/code&gt; 에 따라 캐시 크기 제한을 자동으로 구성합니다 . &lt;code&gt;available_mem&lt;/code&gt; 은 필요한 경우 운영 체제의 디스크 캐시와 같이 운영 체제에서 사용 가능한 메모리를 포함하여 RethinkDB가 시작될 때 사용 가능한 메모리의 양입니다. 시스템에 사용 가능한 1224MB 미만의 메모리가 있으면 최소 캐시 크기 제한 100MB가 사용됩니다. 로그에서 RethinkDB 인스턴스가 사용하는 실제 크기 제한을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="653b9779dde232052144d040476ebeef4a8dcaaa" translate="yes" xml:space="preserve">
          <source>RethinkDB-specific data types</source>
          <target state="translated">DB 별 데이터 유형 재검토</target>
        </trans-unit>
        <trans-unit id="57354ca1c1a9aab463d86135427b774bc928dbcc" translate="yes" xml:space="preserve">
          <source>Retrieve all results and pass them as an array to the given callback.</source>
          <target state="translated">모든 결과를 검색하여 주어진 콜백에 배열로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="a0800d22e7dc2655702fc5c45eb8eba5b2a4d42c" translate="yes" xml:space="preserve">
          <source>Retrieve all users named &amp;ldquo;William Adama&amp;rdquo; (first name &amp;ldquo;William&amp;rdquo;, last name &amp;ldquo;Adama&amp;rdquo;), and who do not have a middle name.</source>
          <target state="translated">이름이 &quot;William Adama&quot;(이름은 &quot;William&quot;, 성은 &quot;Adama&quot;)이고 중간 이름이없는 모든 사용자를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="cec1adbb3f9ef3982a4b34f750d9645287ab990d" translate="yes" xml:space="preserve">
          <source>Retrieve all users named &amp;ldquo;William Adama&amp;rdquo; (first name &amp;ldquo;William&amp;rdquo;, last name &amp;ldquo;Adama&amp;rdquo;), with any middle name.</source>
          <target state="translated">이름이&amp;ldquo;William Adama&amp;rdquo;(이름은&amp;ldquo;William&amp;rdquo;, 성은&amp;ldquo;Adama&amp;rdquo;) 인 모든 사용자를 중간 이름으로 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="237e5c73e5953045fa795163933e9ed9332088b6" translate="yes" xml:space="preserve">
          <source>Retrieve all users whose field &lt;code&gt;placesVisited&lt;/code&gt; contains &lt;code&gt;France&lt;/code&gt;.</source>
          <target state="translated">필드 &lt;code&gt;placesVisited&lt;/code&gt; 에 &lt;code&gt;France&lt;/code&gt; 가 포함 된 모든 사용자를 검색하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d4b04dce1b7df968174efc9d7f0fa1e97e4f76c" translate="yes" xml:space="preserve">
          <source>Retrieve all users whose name is &amp;ldquo;William&amp;rdquo; (case insensitive).</source>
          <target state="translated">이름이 &quot;William&quot;(대소 문자를 구분하지 않음) 인 모든 사용자를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="144e062a80d5bfa018aedb28a373c2819db9d43b" translate="yes" xml:space="preserve">
          <source>Retrieve data from the specified URL over HTTP. The return type depends on the &lt;code&gt;resultFormat&lt;/code&gt; option, which checks the &lt;code&gt;Content-Type&lt;/code&gt; of the response by default.</source>
          <target state="translated">HTTP를 통해 지정된 URL에서 데이터를 검색하십시오. 리턴 유형은 기본적으로 응답 의 &lt;code&gt;Content-Type&lt;/code&gt; 을 확인 하는 &lt;code&gt;resultFormat&lt;/code&gt; 옵션 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="ef23d83eeee761c46e6f3b6b9d1adb2481be6f6b" translate="yes" xml:space="preserve">
          <source>Retrieve data from the specified URL over HTTP. The return type depends on the &lt;code&gt;resultFormat&lt;/code&gt; option, which checks the &lt;code&gt;Content-Type&lt;/code&gt; of the response by default. Make sure that you &lt;strong&gt;never&lt;/strong&gt; use this command for &lt;strong&gt;user provided&lt;/strong&gt; URLs.</source>
          <target state="translated">HTTP를 통해 지정된 URL에서 데이터를 검색합니다. 반환 유형은 기본적으로 응답 의 &lt;code&gt;Content-Type&lt;/code&gt; 을 확인 하는 &lt;code&gt;resultFormat&lt;/code&gt; 옵션 에 따라 다릅니다 . 당신이 확인 &lt;strong&gt;결코&lt;/strong&gt; 이 명령을 사용하지 않는 &lt;strong&gt;사용자가 제공&lt;/strong&gt; 하는 URL.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="211aca45f30753de118f273f7b269e7e4499fd62" translate="yes" xml:space="preserve">
          <source>Retrieve documents</source>
          <target state="translated">문서 검색</target>
        </trans-unit>
        <trans-unit id="3b22bfa4b5202554454b9ce9093ae3ce1ea8220d" translate="yes" xml:space="preserve">
          <source>Retrieve documents by primary key</source>
          <target state="translated">기본 키로 문서 검색</target>
        </trans-unit>
        <trans-unit id="7544efd784c58b3cc6b94510160698abf4204cdf" translate="yes" xml:space="preserve">
          <source>Retrieve the document you just inserted with:</source>
          <target state="translated">방금 삽입 한 문서를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="0e7383fa3693e7f98d7e2271113002f8270dbf24" translate="yes" xml:space="preserve">
          <source>Retrieving all the objects in a stream (cursor) as an array</source>
          <target state="translated">스트림 (커서)의 모든 객체를 배열로 검색</target>
        </trans-unit>
        <trans-unit id="d3381e3b339f22ad2879bc207700fcde0bfd99cc" translate="yes" xml:space="preserve">
          <source>Retrieving documents</source>
          <target state="translated">문서 검색</target>
        </trans-unit>
        <trans-unit id="96da5941680a83531c9d9d6e650a067fcf591587" translate="yes" xml:space="preserve">
          <source>Retrieving portions of times</source>
          <target state="translated">시간의 일부를 검색</target>
        </trans-unit>
        <trans-unit id="095d7a5343b62a81ee9712b14cf269156fe7c534" translate="yes" xml:space="preserve">
          <source>Retrieving times</source>
          <target state="translated">시간 검색</target>
        </trans-unit>
        <trans-unit id="1ac0fc4ed2e5cad9e59397ea987188f54b8218a4" translate="yes" xml:space="preserve">
          <source>Return a UUID (universally unique identifier), a string that can be used as a unique ID. If a string is passed to &lt;code&gt;uuid&lt;/code&gt; as an argument, the UUID will be deterministic, derived from the string&amp;rsquo;s SHA-1 hash.</source>
          <target state="translated">고유 한 ID로 사용할 수있는 문자열 인 UUID (일반적으로 고유 한 식별자)를 반환합니다. 문자열이 인수 로 &lt;code&gt;uuid&lt;/code&gt; 에 전달 되면 UUID는 문자열의 SHA-1 해시에서 파생 된 결정적입니다.</target>
        </trans-unit>
        <trans-unit id="ffd17e2071ddb0546ffd90d50675a3881fba96ef" translate="yes" xml:space="preserve">
          <source>Return a list of documents closest to a specified point based on a geospatial index, sorted in order of increasing distance.</source>
          <target state="translated">거리가 증가하는 순서로 정렬 된 지리 공간 인덱스를 기반으로 지정된 지점에 가장 가까운 문서 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7f63b091983357380f1a69b1dfe84c2c468192c7" translate="yes" xml:space="preserve">
          <source>Return a new time object only based on the day, month and year (ie. the same day at 00:00).</source>
          <target state="translated">일, 월 및 연도를 기준으로 만 새 시간 개체를 반환합니다 (예 : 같은 날 00:00).</target>
        </trans-unit>
        <trans-unit id="015c5dd378cc34e946f70fe5920eef6871ab879c" translate="yes" xml:space="preserve">
          <source>Return a new time object with a different timezone. While the time stays the same, the results returned by methods such as hours() will change since they take the timezone into account. The timezone argument has to be of the ISO 8601 format.</source>
          <target state="translated">시간대가 다른 새 시간 객체를 반환합니다. 시간은 동일하게 유지되지만 hours ()와 같은 메소드가 리턴 한 결과는 시간대를 고려하므로 변경됩니다. 시간대 인수는 ISO 8601 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3c41bbd84134669b7c1a4ef8c089acb5a464d383" translate="yes" xml:space="preserve">
          <source>Return a time object representing the current time in UTC. The command now() is computed once when the server receives the query, so multiple instances of r.now() will always return the same time inside a query.</source>
          <target state="translated">현재 시간을 나타내는 시간 객체를 UTC로 반환합니다. now () 명령은 서버가 쿼리를받을 때 한 번 계산되므로 r.now ()의 여러 인스턴스는 항상 쿼리 내에서 같은 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0bf7e4e063eddc8455a8c8c1c7dcbd9e564f26eb" translate="yes" xml:space="preserve">
          <source>Return all documents in a table. Other commands may be chained after &lt;code&gt;table&lt;/code&gt; to return a subset of documents (such as &lt;a href=&quot;../get/index&quot;&gt;get&lt;/a&gt; and &lt;a href=&quot;../filter/index&quot;&gt;filter&lt;/a&gt;) or perform further processing.</source>
          <target state="translated">테이블에있는 모든 문서를 반환하십시오. 다른 명령은 &lt;code&gt;table&lt;/code&gt; 뒤에 연결 되어 문서의 서브 세트 (예 : &lt;a href=&quot;../get/index&quot;&gt;get&lt;/a&gt; 및 &lt;a href=&quot;../filter/index&quot;&gt;filter&lt;/a&gt; ) 를 리턴 하거나 추가 처리를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cb807193ee6de63e427d7ed0d8324b9c3c3b591" translate="yes" xml:space="preserve">
          <source>Return all documents in a table. Other commands may be chained after &lt;code&gt;table&lt;/code&gt; to return a subset of documents (such as &lt;a href=&quot;get/index&quot;&gt;get&lt;/a&gt; and &lt;a href=&quot;filter/index&quot;&gt;filter&lt;/a&gt;) or perform further processing.</source>
          <target state="translated">테이블에있는 모든 문서를 반환하십시오. 다른 명령은 &lt;code&gt;table&lt;/code&gt; 뒤에 연결 되어 문서의 서브 세트 (예 : &lt;a href=&quot;get/index&quot;&gt;get&lt;/a&gt; 및 &lt;a href=&quot;filter/index&quot;&gt;filter&lt;/a&gt; ) 를 리턴 하거나 추가 처리를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="478ae85b5976cf44bf341f6ea047a3fc9cec6987" translate="yes" xml:space="preserve">
          <source>Return all the elements in a sequence for which the given predicate is true. The return value of &lt;code&gt;filter&lt;/code&gt; will be the same as the input (sequence, stream, or array). Documents can be filtered in a variety of ways&amp;mdash;ranges, nested values, boolean conditions, and the results of anonymous functions.</source>
          <target state="translated">주어진 술어가 참인 순서로 모든 요소를 ​​리턴합니다. &lt;code&gt;filter&lt;/code&gt; 의 반환 값은 입력 (시퀀스, 스트림 또는 배열)과 같습니다. 범위, 중첩 값, 부울 조건 및 익명 함수의 결과와 같은 다양한 방법으로 문서를 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44f61e9b869f88502f4aea0e59d05d2b3e56538f" translate="yes" xml:space="preserve">
          <source>Return an array containing all of an object&amp;rsquo;s keys. Note that the keys will be sorted as described in &lt;a href=&quot;../../../docs/data-types/index#sorting-order&quot;&gt;ReQL data types&lt;/a&gt; (for strings, lexicographically).</source>
          <target state="translated">객체의 모든 키를 포함하는 배열을 반환합니다. 키는 &lt;a href=&quot;../../../docs/data-types/index#sorting-order&quot;&gt;ReQL 데이터 유형&lt;/a&gt; (문자열의 경우 사전 식)에 설명 된대로 정렬됩니다 .</target>
        </trans-unit>
        <trans-unit id="e70c431aef04b9c7b45e841c2755e0962bdd3716" translate="yes" xml:space="preserve">
          <source>Return an array containing all of an object&amp;rsquo;s keys. Note that the keys will be sorted as described in &lt;a href=&quot;../../docs/data-types/index#sorting-order&quot;&gt;ReQL data types&lt;/a&gt; (for strings, lexicographically).</source>
          <target state="translated">객체의 모든 키를 포함하는 배열을 반환합니다. 키는 &lt;a href=&quot;../../docs/data-types/index#sorting-order&quot;&gt;ReQL 데이터 유형&lt;/a&gt; (문자열의 경우 사전 식)에 설명 된대로 정렬됩니다 .</target>
        </trans-unit>
        <trans-unit id="f3730aaaa8f1bbcef6b27cf753e5ef734ef1890e" translate="yes" xml:space="preserve">
          <source>Return an array containing all of an object&amp;rsquo;s values. &lt;code&gt;values()&lt;/code&gt; guarantees the values will come out in the same order as &lt;a href=&quot;../keys/index&quot;&gt;keys&lt;/a&gt;.</source>
          <target state="translated">객체의 모든 값을 포함하는 배열을 반환합니다. &lt;code&gt;values()&lt;/code&gt; 는 값이 &lt;a href=&quot;../keys/index&quot;&gt;keys&lt;/a&gt; 와 동일한 순서로 나오도록 보장합니다 .</target>
        </trans-unit>
        <trans-unit id="971118c553d2907361131e3449a1a6ec52645842" translate="yes" xml:space="preserve">
          <source>Return an array containing all of an object&amp;rsquo;s values. &lt;code&gt;values()&lt;/code&gt; guarantees the values will come out in the same order as &lt;a href=&quot;keys/index&quot;&gt;keys&lt;/a&gt;.</source>
          <target state="translated">객체의 모든 값을 포함하는 배열을 반환합니다. &lt;code&gt;values()&lt;/code&gt; 는 값이 &lt;a href=&quot;keys/index&quot;&gt;keys&lt;/a&gt; 와 동일한 순서로 나오도록 보장합니다 .</target>
        </trans-unit>
        <trans-unit id="56bffb13073f7f91d3bc50303093a5720e9d1b1e" translate="yes" xml:space="preserve">
          <source>Return information about the server being used by a connection.</source>
          <target state="translated">연결에 사용중인 서버에 대한 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a1b11d0437587617248352faf5ad14320b9e0e72" translate="yes" xml:space="preserve">
          <source>Return players who have the &amp;ldquo;championships&amp;rdquo; field.</source>
          <target state="translated">&quot;챔피언 쉽&quot;필드를 가진 플레이어를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="9572f90ef4a18b691f067965a76e794f55e11c57" translate="yes" xml:space="preserve">
          <source>Return the day of a time object as a number between 1 and 31.</source>
          <target state="translated">시간 개체의 요일을 1에서 31 사이의 숫자로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="439ddcb82ceaaca4c171019c2f4cb98b13d31d24" translate="yes" xml:space="preserve">
          <source>Return the day of the year of a time object as a number between 1 and 366 (following ISO 8601 standard).</source>
          <target state="translated">시간 개체의 일을 1과 366 사이의 숫자로 반환합니다 (ISO 8601 표준에 따름).</target>
        </trans-unit>
        <trans-unit id="519ae8ae909a6a02ab7b4e9a29c2f7526e688760" translate="yes" xml:space="preserve">
          <source>Return the day of week of a time object as a number between 1 and 7 (following ISO 8601 standard). For your convenience, the terms r.monday, r.tuesday etc. are defined and map to the appropriate integer.</source>
          <target state="translated">시간 객체의 요일을 1과 7 사이의 숫자로 반환합니다 (ISO 8601 표준에 따름). 편의상 r.monday, r.tuesday 등의 용어가 정의되어 적절한 정수로 매핑됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
