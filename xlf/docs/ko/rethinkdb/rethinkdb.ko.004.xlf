<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rethinkdb">
    <body>
      <group id="rethinkdb">
        <trans-unit id="b64fe618441e29b37149058f1a7d34872564ed83" translate="yes" xml:space="preserve">
          <source>Starting with RethinkDB 1.16, the earlier concept of &amp;ldquo;data centers&amp;rdquo; has been replaced by server tags, described above. Servers in a given data center could all be given a tag such as &lt;code&gt;us_east&lt;/code&gt; or &lt;code&gt;us_west&lt;/code&gt;, and a table can be configured to have replicas associated with specific server tags (e.g., 2 replicas on servers tagged with &lt;code&gt;us_east&lt;/code&gt; and 3 on servers tagged with &lt;code&gt;us_west&lt;/code&gt;).</source>
          <target state="translated">RethinkDB 1.16부터는 앞서 설명한 &quot;데이터 센터&quot;개념이 서버 태그로 대체되었습니다. 지정된 데이터 센터의 서버에는 모두 &lt;code&gt;us_east&lt;/code&gt; 또는 &lt;code&gt;us_west&lt;/code&gt; 와 같은 태그가 제공 될 수 있으며 특정 서버 태그와 연관된 복제본을 갖도록 테이블을 구성 할 수 있습니다 (예 : &lt;code&gt;us_east&lt;/code&gt; 로 태그가 지정된 서버의 복제본 2 개, us_west로 태그가 지정된 서버의 경우 3 &lt;code&gt;us_west&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="2942d3a5f8afc6539a606fe55996f2f85ba8fb2d" translate="yes" xml:space="preserve">
          <source>Starting with RethinkDB 2.0 (&lt;code&gt;V0_4&lt;/code&gt;), the server will process multiple queries in parallel rather than sequentially, and there is no guarantee that a read following a write on the same connection will &amp;ldquo;see&amp;rdquo; the results of the write as long as it&amp;rsquo;s successful. (Previous versions of the server would process multiple queries on the same connection sequentially.)</source>
          <target state="translated">RethinkDB 2.0 ( &lt;code&gt;V0_4&lt;/code&gt; ) 부터 서버는 여러 쿼리를 순차적으로 처리하지 않고 병렬로 처리하며, 동일한 연결에서 쓰기 후 읽은 쓰기가 성공하는 한 쓰기 결과를 &quot;볼&quot;것을 보장하지 않습니다. (이전 버전의 서버는 동일한 연결에서 여러 쿼리를 순차적으로 처리합니다.)</target>
        </trans-unit>
        <trans-unit id="c961f51ddf6e3a1960d4006dbd241d5e425cac28" translate="yes" xml:space="preserve">
          <source>Starting with RethinkDB 2.2, state documents will &lt;em&gt;only&lt;/em&gt; be sent if the &lt;code&gt;includeStates&lt;/code&gt; option is &lt;code&gt;true&lt;/code&gt;, even on point changefeeds. Initial values will only be sent if &lt;code&gt;includeInitial&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;includeStates&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;includeInitial&lt;/code&gt; is false, the first document on the feed will be &lt;code&gt;{state:'ready'}&lt;/code&gt;.</source>
          <target state="translated">RethinkDB 2.2부터는 상태 변경 문서가 있더라도 &lt;code&gt;includeStates&lt;/code&gt; 옵션이 &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;em&gt;에만&lt;/em&gt; 상태 문서가 전송됩니다 . &lt;code&gt;includeInitial&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우에만 초기 값이 전송됩니다 . 경우 &lt;code&gt;includeStates&lt;/code&gt; 가 있다 &lt;code&gt;true&lt;/code&gt; 과 &lt;code&gt;includeInitial&lt;/code&gt; 은 거짓, 공급의 첫 번째 문서는 것 &lt;code&gt;{state:'ready'}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1aa3213c8e5b544991124ed5c55d376f49994e0a" translate="yes" xml:space="preserve">
          <source>Starting with version 1.16, RethinkDB maintains special &lt;em&gt;system tables&lt;/em&gt; that contain configuration and status information about servers, databases, individual tables, and issues with the cluster. Querying system tables returns information about the status of the cluster and current objects (such as servers and tables) within the cluster. By inserting or deleting records and updating fields in these tables, the configuration of the objects they represent can be modified.</source>
          <target state="translated">버전 1.16부터 RethinkDB 는 서버, 데이터베이스, 개별 테이블 및 클러스터 문제에 대한 구성 및 상태 정보가 포함 된 특수 &lt;em&gt;시스템 테이블&lt;/em&gt; 을 유지 관리 합니다. 시스템 테이블을 조회하면 클러스터 상태 및 클러스터 내의 현재 오브젝트 (예 : 서버 및 테이블)에 대한 정보가 리턴됩니다. 이러한 테이블에서 레코드를 삽입 또는 삭제하고 필드를 업데이트하면 해당 테이블에서 나타내는 개체의 구성을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="081c1e1e4da3f29bf8bb20597a5735c3791932d3" translate="yes" xml:space="preserve">
          <source>Starting with version 2.3, RethinkDB offers the ability to secure connections between servers, between servers and clients, and to the web UI using &lt;a href=&quot;https://en.wikipedia.org/wiki/Transport_Layer_Security&quot;&gt;TLS&lt;/a&gt; encryption (the successor to SSL). Securing RethinkDB in this fashion is similar to securing a web site with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Self-signed_certificate&quot;&gt;self-signed SSL certificate&lt;/a&gt;: create a private key and a certificate, then tell the server to use them.</source>
          <target state="translated">버전 2.3부터 RethinkDB는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Transport_Layer_Security&quot;&gt;TLS&lt;/a&gt; 암호화 (SSL의 후속)를 사용하여 서버 간, 서버와 클라이언트 간 및 웹 UI에 대한 연결을 보호하는 기능을 제공합니다 . 이러한 방식으로 RethinkDB를 보안하는 것은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Self-signed_certificate&quot;&gt;자체 서명 된 SSL 인증서&lt;/a&gt; 로 웹 사이트를 보호하는 것과 유사합니다 . 개인 키와 인증서를 작성한 다음 서버가이를 사용하도록 지시하십시오.</target>
        </trans-unit>
        <trans-unit id="a14ca71f5de11ac16b741f2895038968e30fa95f" translate="yes" xml:space="preserve">
          <source>Startup with init.d</source>
          <target state="translated">init.d로 시작</target>
        </trans-unit>
        <trans-unit id="ea9b605703b9aa1d999b8932d0180fd06fb42587" translate="yes" xml:space="preserve">
          <source>Startup with launchd (OS X)</source>
          <target state="translated">런칭 된 시작 (OS X)</target>
        </trans-unit>
        <trans-unit id="f4e43708be29e49c1ec1aa4189305be5e1934e28" translate="yes" xml:space="preserve">
          <source>Startup with systemd</source>
          <target state="translated">systemd로 시작</target>
        </trans-unit>
        <trans-unit id="2086b21f8f49274138c38d476bee317a84a8aecc" translate="yes" xml:space="preserve">
          <source>Statistics</source>
          <target state="translated">Statistics</target>
        </trans-unit>
        <trans-unit id="f1b89f18db10edb807e2bb4dbf71b7f25ac69016" translate="yes" xml:space="preserve">
          <source>Status tables</source>
          <target state="translated">상태 테이블</target>
        </trans-unit>
        <trans-unit id="dc416e1088e4bf094dfc9abe0210e0288f5a169e" translate="yes" xml:space="preserve">
          <source>Step</source>
          <target state="translated">Step</target>
        </trans-unit>
        <trans-unit id="15679a4a26f9a6ba3a691493d6beeae10a421041" translate="yes" xml:space="preserve">
          <source>Stopping a Handler</source>
          <target state="translated">핸들러 중지</target>
        </trans-unit>
        <trans-unit id="cbffd52d681c0a57ba768a7b13d045efc1626e9c" translate="yes" xml:space="preserve">
          <source>Stores queries and their results, and displays them from a web interface.</source>
          <target state="translated">쿼리와 결과를 저장하고 웹 인터페이스에서 표시합니다.</target>
        </trans-unit>
        <trans-unit id="051adf2dce81e4edeb3804a2a2cc5362ddbcbd3a" translate="yes" xml:space="preserve">
          <source>Storing and enriching API data</source>
          <target state="translated">API 데이터 저장 및 보강</target>
        </trans-unit>
        <trans-unit id="0c202e6f4f3c0ecb61addbe0a44f03640e49acaf" translate="yes" xml:space="preserve">
          <source>Storing binary objects</source>
          <target state="translated">이진 객체 저장</target>
        </trans-unit>
        <trans-unit id="f99d2614f3e61769cb31cbb3d64230a0bf9792bd" translate="yes" xml:space="preserve">
          <source>Storing timestamps and JSON date strings as Time data types</source>
          <target state="translated">타임 스탬프 및 JSON 날짜 문자열을 시간 데이터 유형으로 저장</target>
        </trans-unit>
        <trans-unit id="421ed75a3333e9d8c5cea75e785430b7939cdab5" translate="yes" xml:space="preserve">
          <source>Storing uploaded files in the database</source>
          <target state="translated">업로드 된 파일을 데이터베이스에 저장</target>
        </trans-unit>
        <trans-unit id="36dda565904ac283e012045f6d9e7daf872d0a13" translate="yes" xml:space="preserve">
          <source>Storing user avatars</source>
          <target state="translated">사용자 아바타 저장</target>
        </trans-unit>
        <trans-unit id="37fcd98b3c8b91061836eba59a7019ed4b18d372" translate="yes" xml:space="preserve">
          <source>Streams and feeds are lazily-computed sequences, and return a &lt;code&gt;ResponseType&lt;/code&gt; of &lt;code&gt;SUCCESS_PARTIAL&lt;/code&gt; (&lt;code&gt;3&lt;/code&gt;), with currently available data in the &lt;code&gt;r&lt;/code&gt; array. When the driver receives a feed or stream, it should return a cursor (or an object with a cursor-like interface). &lt;em&gt;N.B.:&lt;/em&gt;&lt;code&gt;SUCCESS_SEQUENCE&lt;/code&gt; and &lt;code&gt;SUCCESS_PARTIAL&lt;/code&gt; responses should be both be represented as cursors. Depending on the size of the query results and the time it takes to return them, you may receive either one &lt;code&gt;SUCCESS_SEQUENCE&lt;/code&gt; result, or one or more &lt;code&gt;SUCCESS_PARTIAL&lt;/code&gt; results followed by a final &lt;code&gt;SUCCESS_SEQUENCE&lt;/code&gt; result.</source>
          <target state="translated">스트림과 피드는 느리게 계산 된 시퀀스이며 &lt;code&gt;r&lt;/code&gt; 배열 에서 현재 사용 가능한 데이터와 함께 &lt;code&gt;SUCCESS_PARTIAL&lt;/code&gt; ( &lt;code&gt;3&lt;/code&gt; ) 의 &lt;code&gt;ResponseType&lt;/code&gt; 을 반환합니다 . 드라이버가 피드 또는 스트림을 받으면 커서 (또는 커서와 같은 인터페이스가있는 객체)를 반환해야합니다. &lt;em&gt;주의 : &lt;/em&gt; &lt;code&gt;SUCCESS_SEQUENCE&lt;/code&gt; 및 &lt;code&gt;SUCCESS_PARTIAL&lt;/code&gt; 응답은 모두 커서로 표시되어야합니다. 쿼리 결과의 크기와 결과를 반환하는 데 걸리는 시간에 따라 하나의 &lt;code&gt;SUCCESS_SEQUENCE&lt;/code&gt; 결과 또는 하나 이상의 &lt;code&gt;SUCCESS_PARTIAL&lt;/code&gt; 결과와 최종 &lt;code&gt;SUCCESS_SEQUENCE&lt;/code&gt; 결과가 나타날 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb6c4efeac903a0003cef92ddf354bd1374cf2f1" translate="yes" xml:space="preserve">
          <source>Streams use &amp;ldquo;lazy loading,&amp;rdquo; a concept you may have run across in other database interfaces. Instead of returning an entire result set from a query, streams return an &lt;a href=&quot;http://en.wikipedia.org/wiki/Iterator&quot;&gt;iterator&lt;/a&gt; referred to as a &amp;ldquo;cursor,&amp;rdquo; a pointer into the data set.</source>
          <target state="translated">스트림은 다른 데이터베이스 인터페이스에서 실행할 수있는 개념 인 &quot;지연 로딩&quot;을 사용합니다. 쿼리에서 전체 결과 집합을 반환하는 대신 스트림 은 &quot;커서&quot;라고 하는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Iterator&quot;&gt;반복자&lt;/a&gt; 를 데이터 집합에 대한 포인터로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bdd49f40eb94b20bc3d437ca36ad5830377fda8e" translate="yes" xml:space="preserve">
          <source>String Manipulation</source>
          <target state="translated">문자열 조작</target>
        </trans-unit>
        <trans-unit id="411f94c6ca34e4478bca225615707da562686a1d" translate="yes" xml:space="preserve">
          <source>String manipulation</source>
          <target state="translated">문자열 조작</target>
        </trans-unit>
        <trans-unit id="7c8cf84261f17414d41a19324152deb0638ecb13" translate="yes" xml:space="preserve">
          <source>Subcommands</source>
          <target state="translated">Subcommands</target>
        </trans-unit>
        <trans-unit id="bbd17ca7716d1959474368eb0c63e1ad9ad957be" translate="yes" xml:space="preserve">
          <source>Subqueries</source>
          <target state="translated">Subqueries</target>
        </trans-unit>
        <trans-unit id="98e916c3bddbbc175b04c5eaa8de99d155cbe03c" translate="yes" xml:space="preserve">
          <source>Subqueries can be abstracted in variables, which allows for modular programming in the same way as done by most other modern programming languages.</source>
          <target state="translated">서브 쿼리는 변수로 추상화 할 수 있으므로 대부분의 다른 현대 프로그래밍 언어와 동일한 방식으로 모듈 식 프로그래밍이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="e97aae2f87eb9b6796d483ee8974c03c1e5ba9e2" translate="yes" xml:space="preserve">
          <source>Subscribe to a feed by calling &lt;a href=&quot;../../../api/javascript/changes/index&quot;&gt;changes&lt;/a&gt; on a table:</source>
          <target state="translated">테이블에서 &lt;a href=&quot;../../../api/javascript/changes/index&quot;&gt;변경 사항&lt;/a&gt; 을 호출하여 피드를 구독 하십시오.</target>
        </trans-unit>
        <trans-unit id="cf8a466677b83f4e1f4df6f8b69bf7ba43beb2b7" translate="yes" xml:space="preserve">
          <source>Subscribe to the &lt;a href=&quot;https://groups.google.com/forum/?fromgroups=#!forum/rethinkdb-dev&quot;&gt;RethinkDB driver developers group&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://groups.google.com/forum/?fromgroups=#!forum/rethinkdb-dev&quot;&gt;RethinkDB 드라이버 개발자 그룹에&lt;/a&gt; 가입하십시오 .</target>
        </trans-unit>
        <trans-unit id="395d7a75e1ae0564bdd8d6d6363f8537be3bc1c5" translate="yes" xml:space="preserve">
          <source>Subscribers create a changefeed on the &lt;code&gt;Exchange&lt;/code&gt;&amp;rsquo;s table, filtering for changes that mention documents matching their topic queries.</source>
          <target state="translated">가입자는 &lt;code&gt;Exchange&lt;/code&gt; 테이블에서 변경 피드를 작성하여 주제 쿼리와 일치하는 문서를 언급하는 변경 사항을 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="7b2a790bdd19b116e81ba00ed519edb942e324e3" translate="yes" xml:space="preserve">
          <source>Subscribing to changefeeds</source>
          <target state="translated">피드 피드 구독</target>
        </trans-unit>
        <trans-unit id="6a4dd28a2000f4de189f22a02e6a44d6093e120e" translate="yes" xml:space="preserve">
          <source>Subscribing to hierarchical topics</source>
          <target state="translated">계층 적 주제 구독</target>
        </trans-unit>
        <trans-unit id="a6e859ee0a008ef4fd60b3c46f2e406a1c004727" translate="yes" xml:space="preserve">
          <source>Subscribing to topics using regex</source>
          <target state="translated">정규식을 사용하여 주제 구독</target>
        </trans-unit>
        <trans-unit id="0128e284e80f24203df15083d6d063f8f03c858d" translate="yes" xml:space="preserve">
          <source>Subscribing to topics using tags</source>
          <target state="translated">태그를 사용하여 주제 구독</target>
        </trans-unit>
        <trans-unit id="9dd600d816401a97bb7171cf8a4a1a7bf7c906c0" translate="yes" xml:space="preserve">
          <source>Subtract two numbers.</source>
          <target state="translated">두 숫자를 뺍니다.</target>
        </trans-unit>
        <trans-unit id="4efe5ba11913e60899922a574c9310ce44547cf0" translate="yes" xml:space="preserve">
          <source>Sum two or more numbers, or concatenate two or more strings or arrays.</source>
          <target state="translated">둘 이상의 숫자를 합하거나 둘 이상의 문자열 또는 배열을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="3c265c2ec47c266f4eddd985a602248cf1492e23" translate="yes" xml:space="preserve">
          <source>Sums all the elements of a sequence. If called with a field name, sums all the values of that field in the sequence, skipping elements of the sequence that lack that field. If called with a function, calls that function on every element of the sequence and sums the results, skipping elements of the sequence where that function returns &lt;code&gt;null&lt;/code&gt; or a non-existence error.</source>
          <target state="translated">시퀀스의 모든 요소를 ​​합산합니다. 필드 이름으로 호출하면 해당 필드가없는 시퀀스의 요소를 건너 뛰고 시퀀스에서 해당 필드의 모든 값을 합합니다. 함수와 함께 호출하면 시퀀스의 모든 요소에서 해당 함수를 호출하고 결과를 합산하여 해당 함수가 &lt;code&gt;null&lt;/code&gt; 또는 존재하지 않는 오류를 반환하는 시퀀스의 요소를 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="d8b6182e4e1fbdaf3ea143a384f18f88f4f511f0" translate="yes" xml:space="preserve">
          <source>Superheroes tutorial</source>
          <target state="translated">슈퍼 히어로 튜토리얼</target>
        </trans-unit>
        <trans-unit id="89bc1824e398cf96683dfbc223ebb34785115277" translate="yes" xml:space="preserve">
          <source>Supported options</source>
          <target state="translated">지원되는 옵션</target>
        </trans-unit>
        <trans-unit id="0e292d899e02633c2e04b35d5deb85171e7578e3" translate="yes" xml:space="preserve">
          <source>Suppose a data set that lists top movies, ranked by user vote. You&amp;rsquo;d like to get the total votes and the average age of the top 25 movies: the &lt;code&gt;avg()&lt;/code&gt; of the &lt;code&gt;year&lt;/code&gt; column and the &lt;code&gt;sum()&lt;/code&gt; of the &lt;code&gt;votes&lt;/code&gt; column, ordered by the &lt;code&gt;rank&lt;/code&gt; column to get the range 1&amp;ndash;25.</source>
          <target state="translated">사용자 투표로 순위가 매겨진 인기 영화를 나열하는 데이터 세트를 가정하십시오. 당신은 총 투표 수와 상위 25 개 영화의 평균 연령을 좀하고 싶습니다 다음 &lt;code&gt;avg()&lt;/code&gt; 의 &lt;code&gt;year&lt;/code&gt; 칼럼과 &lt;code&gt;sum()&lt;/code&gt; 의 &lt;code&gt;votes&lt;/code&gt; 의해 정렬 된 열, &lt;code&gt;rank&lt;/code&gt; 범위 1-25를 얻기 위해 열을.</target>
        </trans-unit>
        <trans-unit id="8b899c315ce40799000302d06bdb519d66498dd3" translate="yes" xml:space="preserve">
          <source>Suppose each post has a field &lt;code&gt;tags&lt;/code&gt; that maps to an array of tags. The schema of the table &lt;code&gt;posts&lt;/code&gt; would be something like:</source>
          <target state="translated">각 게시물 에 태그 배열에 매핑 되는 필드 &lt;code&gt;tags&lt;/code&gt; 가 있다고 가정 합니다. 테이블 &lt;code&gt;posts&lt;/code&gt; 의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="482306a03a24119b4b1e772995e3616816ebe2c3" translate="yes" xml:space="preserve">
          <source>Suppose its output is as follows:</source>
          <target state="translated">출력이 다음과 같다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="305076c03efbc539dfa0aa5fe524a8ad5027bba7" translate="yes" xml:space="preserve">
          <source>Suppose on the blog in the last example, you&amp;rsquo;d like to retrieve the number of posts &lt;em&gt;per category.&lt;/em&gt; A map-reduce query to perform this operation would consist of the following steps:</source>
          <target state="translated">마지막 예의 블로그에서 &lt;em&gt;카테고리 당&lt;/em&gt; 게시물 수를 검색하려고한다고 가정하십시오 &lt;em&gt;. &lt;/em&gt;이 작업을 수행하기위한 맵 감소 쿼리는 다음 단계로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="9fc193e9aee3048beb3caf5658d764b058365ee8" translate="yes" xml:space="preserve">
          <source>Suppose that our data model for the employees stores a company name instead of a company id:</source>
          <target state="translated">직원에 대한 데이터 모델이 회사 ID 대신 회사 이름을 저장한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="ba7f91272a3804d75a6598e1f3bad96058fabbf5" translate="yes" xml:space="preserve">
          <source>Suppose that the table &lt;code&gt;games2&lt;/code&gt; has the following data:</source>
          <target state="translated">테이블 &lt;code&gt;games2&lt;/code&gt; 에 다음 데이터가 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="d618567de8457f4e1f435d12d614a8fa312d9700" translate="yes" xml:space="preserve">
          <source>Suppose that the table &lt;code&gt;games&lt;/code&gt; has the following data:</source>
          <target state="translated">테이블 &lt;code&gt;games&lt;/code&gt; 에 다음 데이터가 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="06104ac359e508ccef4ef32dfaf2a4fdca0b82b0" translate="yes" xml:space="preserve">
          <source>Suppose that you want to keep the &lt;code&gt;id&lt;/code&gt; field of the employee, but not the one of the company. You can do it by removing the field &lt;code&gt;right.id&lt;/code&gt;, then calling the &lt;code&gt;zip&lt;/code&gt; command.</source>
          <target state="translated">직원 의 &lt;code&gt;id&lt;/code&gt; 필드는 유지 하지만 회사 의 id 필드는 유지 하지 않는다고 가정하십시오. &lt;code&gt;right.id&lt;/code&gt; 필드를 제거한 다음 &lt;code&gt;zip&lt;/code&gt; 명령 을 호출하여 이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27c97e208254d412ff656573ce4566923a071cae" translate="yes" xml:space="preserve">
          <source>Suppose the players table contains these documents:</source>
          <target state="translated">players 테이블에 다음 문서가 포함되어 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="55d631d358f622eb48a20000ddcdf5a71d5d16d0" translate="yes" xml:space="preserve">
          <source>Suppose the table &lt;code&gt;marks&lt;/code&gt; stores the marks of every students per course:</source>
          <target state="translated">테이블 &lt;code&gt;marks&lt;/code&gt; 코스 당 모든 학생의 마크를 저장 한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="863abd28999d7a33805cde5f619af1857cb2ffb2" translate="yes" xml:space="preserve">
          <source>Suppose we have a table &lt;code&gt;posts&lt;/code&gt; that links posts to authors via an &lt;code&gt;author_id&lt;/code&gt; field. If we&amp;rsquo;ve created a secondary index on &lt;code&gt;author_id&lt;/code&gt; and want to retrieve all the posts where &lt;code&gt;author_id&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, or &lt;code&gt;3&lt;/code&gt;, we can use the &lt;code&gt;getAll&lt;/code&gt; command to do it as follows:</source>
          <target state="translated">&lt;code&gt;author_id&lt;/code&gt; 필드 를 통해 게시물을 작성자와 연결 하는 테이블 &lt;code&gt;posts&lt;/code&gt; 이 있다고 가정 합니다. &lt;code&gt;author_id&lt;/code&gt; 에 보조 인덱스를 만들고 &lt;code&gt;author_id&lt;/code&gt; 가 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; 또는 &lt;code&gt;3&lt;/code&gt; 인 모든 게시물을 검색하려는 경우 &lt;code&gt;getAll&lt;/code&gt; 명령을 사용하여 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd69d64d9d90f1021ac7cab49f4dced356698803" translate="yes" xml:space="preserve">
          <source>Suppose we have a table &lt;code&gt;users&lt;/code&gt; with documents of the following form:</source>
          <target state="translated">다음과 같은 형식의 문서를 가진 테이블 &lt;code&gt;users&lt;/code&gt; 가 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="b1f14a9832b9f642f0b36d37ee55787766eea3b7" translate="yes" xml:space="preserve">
          <source>Suppose we have ten documents in a single category in a sharded table. Four of the documents are on shard 1; six are on shard 2. When the incorrect query is executed, this is its path:</source>
          <target state="translated">샤딩 된 테이블에 단일 범주에 10 개의 문서가 있다고 가정합니다. 문서 중 4 개는 샤드 1에 있습니다. 6은 샤드 2에 있습니다. 잘못된 쿼리가 실행될 때 경로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ecab01432f8dcfd29db07faed3306d03f5f21cc7" translate="yes" xml:space="preserve">
          <source>Suppose we want to rename the field &lt;code&gt;id&lt;/code&gt; to &lt;code&gt;idUser&lt;/code&gt; when retrieving documents from the table &lt;code&gt;users&lt;/code&gt;. In the subquery, we can use &lt;code&gt;merge&lt;/code&gt; to add a new field with the existing field&amp;rsquo;s value, then &lt;code&gt;without&lt;/code&gt; to delete the old field:</source>
          <target state="translated">테이블 &lt;code&gt;users&lt;/code&gt; 에서 문서를 검색 할 때 필드 &lt;code&gt;id&lt;/code&gt; 를 &lt;code&gt;idUser&lt;/code&gt; 로 바꾸려고한다고 가정하십시오 . 하위 쿼리에서 &lt;code&gt;merge&lt;/code&gt; 를 사용 하여 기존 필드 값으로 새 필드를 추가 한 다음 이전 필드를 삭제 &lt;code&gt;without&lt;/code&gt; 다음과 같이 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd8284b9c5ecd12c0da7cb055be040ad759da9ca" translate="yes" xml:space="preserve">
          <source>Suppose we&amp;rsquo;d like to to retrieve all the posts in the table &lt;code&gt;post&lt;/code&gt; and also return an additional field, &lt;code&gt;comments&lt;/code&gt;, which is an array of all the comments for the relevant post retrieved from the &lt;code&gt;comments&lt;/code&gt; table. We could do this using a subquery:</source>
          <target state="translated">테이블 &lt;code&gt;post&lt;/code&gt; 의 모든 게시물을 검색 하고 추가 필드 인 &lt;code&gt;comments&lt;/code&gt; 반환 한다고 가정 합니다 ( &lt;code&gt;comments&lt;/code&gt; 테이블 에서 검색된 관련 게시물에 대한 모든 주석 배열) . 하위 쿼리를 사용하여이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efa9d5fab76e05214df4eea4580738c57dea1f05" translate="yes" xml:space="preserve">
          <source>Suppose we&amp;rsquo;d like to trim down our database and delete every document with less than three posts (sorry Laura and Jean-Luc):</source>
          <target state="translated">데이터베이스를 정리하고 게시물이 3 개 미만인 모든 문서를 삭제한다고 가정합니다 (죄송합니다 Laura 및 Jean-Luc).</target>
        </trans-unit>
        <trans-unit id="d9835b16eff20fd64f058bf8e513bffb08e5156e" translate="yes" xml:space="preserve">
          <source>Suppose you are running a blog and would like to retrieve the number of posts. A map-reduce query to perform this operation would consist of the following steps:</source>
          <target state="translated">블로그를 실행 중이고 게시물 수를 검색하려고한다고 가정하십시오. 이 작업을 수행하기위한 맵 감소 쿼리는 다음 단계로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="6cc205fe6a19e66a7e73ca9c5922fd6934973caf" translate="yes" xml:space="preserve">
          <source>Suppose you have a chat application with multiple clients posting messages to different chat rooms. You can create feeds that subscribe to messages posted to a specific room:</source>
          <target state="translated">여러 클라이언트가 다른 대화방에 메시지를 게시하는 대화 응용 프로그램이 있다고 가정하십시오. 특정 회의실에 게시 된 메시지를 구독하는 피드를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4768ff13957450b6b322ffdb25a724ae46b0c89e" translate="yes" xml:space="preserve">
          <source>Suppose you want to retrieve all the posts whose date field is between January 1st, 2012 (included) and January 1st, 2013 (excluded). You could do:</source>
          <target state="translated">날짜 필드가 2012 년 1 월 1 일 (포함)과 2013 년 1 월 1 일 (제외) 사이의 모든 게시물을 검색하려고한다고 가정하십시오. 당신은 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="9216a7cff4538f532284ba814135bf0e53d98d0a" translate="yes" xml:space="preserve">
          <source>Suppose you wanted to paginate through a set of users, 25 at a time. You could get the first 25 records efficiently just with &lt;code&gt;limit&lt;/code&gt;.</source>
          <target state="translated">한 번에 25 명의 사용자를 통해 페이지 매김을 원한다고 가정하십시오. &lt;code&gt;limit&lt;/code&gt; 만으로 처음 25 개의 레코드를 효율적으로 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95b01a971703b06e82b48250dccd360ac1fa7f30" translate="yes" xml:space="preserve">
          <source>Suppose you&amp;rsquo;d like to select all posts where the author&amp;rsquo;s name is &amp;ldquo;Michel&amp;rdquo; and the category is &amp;ldquo;Geek&amp;rdquo;. You can do it as follows:</source>
          <target state="translated">저자 이름이 &quot;Michel&quot;이고 카테고리가 &quot;Geek&quot;인 모든 게시물을 선택한다고 가정합니다. 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="112ab020698e5fc0f4baecd7821a512d8c419a69" translate="yes" xml:space="preserve">
          <source>Swift</source>
          <target state="translated">Swift</target>
        </trans-unit>
        <trans-unit id="c7754a0126d0aaf46fbebc210b5eb50440b996eb" translate="yes" xml:space="preserve">
          <source>System current issues table</source>
          <target state="translated">시스템 현재 문제 테이블</target>
        </trans-unit>
        <trans-unit id="a79086ea99038c78fcb10e82dc0b55ccbabff535" translate="yes" xml:space="preserve">
          <source>System jobs table</source>
          <target state="translated">시스템 작업 테이블</target>
        </trans-unit>
        <trans-unit id="53fde7d284da785ea8c756a4755a1cf1a647fc31" translate="yes" xml:space="preserve">
          <source>System statistics table</source>
          <target state="translated">시스템 통계표</target>
        </trans-unit>
        <trans-unit id="a79611699266ef0b5f43b2792f98671886bdc4f7" translate="yes" xml:space="preserve">
          <source>System tables</source>
          <target state="translated">시스템 테이블</target>
        </trans-unit>
        <trans-unit id="4722f1e7452b133171f8fe49038f80cb4d543dc4" translate="yes" xml:space="preserve">
          <source>TABLE and DATABASE manipulation</source>
          <target state="translated">테이블 및 데이터베이스 조작</target>
        </trans-unit>
        <trans-unit id="a8de37891fde68bb5a0ec54a33871e33ff0b04f7" translate="yes" xml:space="preserve">
          <source>TLS options</source>
          <target state="translated">TLS 옵션</target>
        </trans-unit>
        <trans-unit id="ffc959723a236b0cc6de0f357ad16f5a6da878a5" translate="yes" xml:space="preserve">
          <source>Table availability issues</source>
          <target state="translated">테이블 가용성 문제</target>
        </trans-unit>
        <trans-unit id="d6bb93a216207f4b9e299da1815f37b802ab7b33" translate="yes" xml:space="preserve">
          <source>Table joins in RethinkDB</source>
          <target state="translated">RethinkDB의 테이블 조인</target>
        </trans-unit>
        <trans-unit id="49276d64118baef926d34027bbab4e81079248fe" translate="yes" xml:space="preserve">
          <source>Tables will be available for writing when the command returns.</source>
          <target state="translated">명령이 리턴되면 테이블을 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d7222b89a2e8be0d6d59f735ee4900bd39725c7" translate="yes" xml:space="preserve">
          <source>Tables with unevenly distributed primary keys, such as incrementing integers</source>
          <target state="translated">증분 정수와 같이 고르지 않게 분산 된 기본 키가있는 테이블</target>
        </trans-unit>
        <trans-unit id="3daa2b71e58a54876d28ede052b3a2e246f8ecd2" translate="yes" xml:space="preserve">
          <source>Take the &lt;code&gt;do&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; 명령을 수행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="38f1d76bf20f6fcdc6d187bbc76cd6436670d3f9" translate="yes" xml:space="preserve">
          <source>Take the function:</source>
          <target state="translated">기능을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="cea65d922ed277d1704ab2878b724b53c61de751" translate="yes" xml:space="preserve">
          <source>Takes a grouped stream or grouped data and turns it into an array of objects representing the groups. Any commands chained after &lt;code&gt;ungroup&lt;/code&gt; will operate on this array, rather than operating on each group individually. This is useful if you want to e.g. order the groups by the value of their reduction.</source>
          <target state="translated">그룹화 된 스트림 또는 그룹화 된 데이터를 가져 와서 그룹을 나타내는 객체 배열로 바꿉니다. &lt;code&gt;ungroup&lt;/code&gt; 후 연결된 모든 명령 은 각 그룹에서 개별적으로 작동하지 않고이 어레이에서 작동합니다. 예를 들어 그룹을 축소 값으로 정렬하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5d5c093f525fdc79a9ecef536f2adf23e1bcd059" translate="yes" xml:space="preserve">
          <source>Takes a stream and partitions it into multiple groups based on the fields or functions provided.</source>
          <target state="translated">제공된 필드 또는 기능에 따라 스트림을 가져와 여러 그룹으로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="4be37be90bfccb09eab627d2a5d3f9b1c85287e5" translate="yes" xml:space="preserve">
          <source>Technical details</source>
          <target state="translated">기술적 세부 사항</target>
        </trans-unit>
        <trans-unit id="b3009d114dbbdc48b07c50727c55f8923baa1735" translate="yes" xml:space="preserve">
          <source>Telling RethinkDB to use your certificate</source>
          <target state="translated">인증서를 사용하도록 RethinkDB에 지시</target>
        </trans-unit>
        <trans-unit id="e86033a1c268fcd57c5544ec342f884426872fe2" translate="yes" xml:space="preserve">
          <source>Ten-minute guide</source>
          <target state="translated">10 분 가이드</target>
        </trans-unit>
        <trans-unit id="62bdf5b0f1b1c7afa76df4a0ec827e816d32887c" translate="yes" xml:space="preserve">
          <source>Ten-minute guide with RethinkDB and JavaScript</source>
          <target state="translated">RethinkDB 및 JavaScript를 사용한 10 분 가이드</target>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="580faa9f93143659082ee75418784f7ed233bc25" translate="yes" xml:space="preserve">
          <source>Test if a sequence is empty.</source>
          <target state="translated">시퀀스가 비어 있는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="2b712c0d5fab5555a5ee001f73a9eae6fd7e22ee" translate="yes" xml:space="preserve">
          <source>Test if an object has one or more fields. An object has a field if it has that key and the key has a non-null value. For instance, the object &lt;code&gt;{'a':1,'b':2,'c':null}&lt;/code&gt; has the fields &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">개체에 하나 이상의 필드가 있는지 테스트하십시오. 객체에 해당 키가 있고 키에 null이 아닌 값이있는 경우 필드가 있습니다. 예를 들어, &lt;code&gt;{'a':1,'b':2,'c':null}&lt;/code&gt; 객체 에는 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 필드 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4c77a6841ba72ffccbbcea87b18fbf2a42ef680" translate="yes" xml:space="preserve">
          <source>Test if two or more values are equal.</source>
          <target state="translated">둘 이상의 값이 같은지 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="e87a117ac7aa25ab290c4818f470f3ebbcce0e19" translate="yes" xml:space="preserve">
          <source>Test if two or more values are not equal.</source>
          <target state="translated">둘 이상의 값이 다른지 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="a5a0b0052fc126b71716d72a6f07f95c3595919b" translate="yes" xml:space="preserve">
          <source>Tests the response time for analytic MapReduce queries involving string operations</source>
          <target state="translated">문자열 작업과 관련된 분석 MapReduce 쿼리에 대한 응답 시간을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="bcb4d0c346b77ce8d2b0806c1febeba5bff03f3d" translate="yes" xml:space="preserve">
          <source>Tests whether a geometry object is completely contained within another. When applied to a sequence of geometry objects, &lt;code&gt;includes&lt;/code&gt; acts as a &lt;a href=&quot;../filter/index&quot;&gt;filter&lt;/a&gt;, returning a sequence of objects from the sequence that include the argument.</source>
          <target state="translated">지오메트리 객체가 다른 객체 내에 완전히 포함되어 있는지 테스트합니다. 일련의 지오메트리 객체에 적용되면 &lt;code&gt;includes&lt;/code&gt; 은 &lt;a href=&quot;../filter/index&quot;&gt;필터&lt;/a&gt; 역할을 하여 인수를 포함하는 시퀀스에서 객체 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="32ad66b24a210fe5fb7c74854564c5c2404f940b" translate="yes" xml:space="preserve">
          <source>Tests whether a geometry object is completely contained within another. When applied to a sequence of geometry objects, &lt;code&gt;includes&lt;/code&gt; acts as a &lt;a href=&quot;filter/index&quot;&gt;filter&lt;/a&gt;, returning a sequence of objects from the sequence that include the argument.</source>
          <target state="translated">지오메트리 객체가 다른 객체 내에 완전히 포함되어 있는지 테스트합니다. 일련의 지오메트리 객체에 적용되면 &lt;code&gt;includes&lt;/code&gt; 은 &lt;a href=&quot;filter/index&quot;&gt;필터&lt;/a&gt; 역할을 하여 인수를 포함하는 시퀀스에서 객체 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="76bc89a4bdfcbe6b5eb162678644e978de9e8662" translate="yes" xml:space="preserve">
          <source>Tests whether two geometry objects intersect with one another. When applied to a sequence of geometry objects, &lt;code&gt;intersects&lt;/code&gt; acts as a &lt;a href=&quot;../filter/index&quot;&gt;filter&lt;/a&gt;, returning a sequence of objects from the sequence that intersect with the argument.</source>
          <target state="translated">두 개의 지오메트리 객체가 서로 교차하는지 테스트합니다. 일련의 지오메트리 객체에 적용되면 &lt;code&gt;intersects&lt;/code&gt; 는 &lt;a href=&quot;../filter/index&quot;&gt;필터&lt;/a&gt; 역할 을하여 인수와 교차하는 시퀀스에서 객체 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4f96ec5473cb3c525e604de3ef69ef3872d90917" translate="yes" xml:space="preserve">
          <source>Tests whether two geometry objects intersect with one another. When applied to a sequence of geometry objects, &lt;code&gt;intersects&lt;/code&gt; acts as a &lt;a href=&quot;filter/index&quot;&gt;filter&lt;/a&gt;, returning a sequence of objects from the sequence that intersect with the argument.</source>
          <target state="translated">두 개의 지오메트리 객체가 서로 교차하는지 테스트합니다. 일련의 지오메트리 객체에 적용되면 &lt;code&gt;intersects&lt;/code&gt; 는 &lt;a href=&quot;filter/index&quot;&gt;필터&lt;/a&gt; 역할 을하여 인수와 교차하는 시퀀스에서 객체 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8bf2f9529e3017d5406fa32ca8a2854fd68af8da" translate="yes" xml:space="preserve">
          <source>That will preserve &lt;code&gt;city&lt;/code&gt; and other existing fields. But to replace the entire &lt;code&gt;data&lt;/code&gt; document with a new object, use &lt;code&gt;literal&lt;/code&gt;.</source>
          <target state="translated">그것은 &lt;code&gt;city&lt;/code&gt; 와 다른 기존 분야를 보존 할 것 입니다. 그러나 전체 &lt;code&gt;data&lt;/code&gt; 문서를 새 객체 로 바꾸려면 &lt;code&gt;literal&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="21ae0e5519ad676ec6cffc66040385b181bd25f7" translate="yes" xml:space="preserve">
          <source>The 8-byte unique query token</source>
          <target state="translated">8 바이트 고유 쿼리 토큰</target>
        </trans-unit>
        <trans-unit id="d60bee9b6432ef97dc1ad43b46670489d6ce7524" translate="yes" xml:space="preserve">
          <source>The 8-byte unique query token the response corresponds to</source>
          <target state="translated">응답이 해당하는 8 바이트 고유 쿼리 토큰</target>
        </trans-unit>
        <trans-unit id="14e7b9dd7173a6825a4fbe67852ce2c6c8b61b25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../../api/javascript/changes/index&quot;&gt;changes&lt;/a&gt; command API reference</source>
          <target state="translated">는 &lt;a href=&quot;../../../api/javascript/changes/index&quot;&gt;변경&lt;/a&gt; 명령 API 참조</target>
        </trans-unit>
        <trans-unit id="b689a67f47be5478bbcb1a5da019f30befb69c45" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../../api/javascript/slice/index&quot;&gt;slice&lt;/a&gt; command returns a range from a given start value through but not including a given end value. This makes it easy to use as a &lt;code&gt;skip&lt;/code&gt;/&lt;code&gt;limit&lt;/code&gt; replacement: the start value is the first item to retrieve, and the end value is the first item plus the limit. To retrieve posts 11-20 from the database using &lt;code&gt;slice&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../../../api/javascript/slice/index&quot;&gt;슬라이스&lt;/a&gt; 명령은 주어진 시작 값에서를 통해 만 주어진 끝 값을 포함하지 않는 범위를 반환합니다. 이를 통해 &lt;code&gt;skip&lt;/code&gt; / &lt;code&gt;limit&lt;/code&gt; 교체 로 쉽게 사용할 수 있습니다 . 시작 값은 검색 할 첫 번째 항목이고 끝 값은 첫 번째 항목에 한도를 더한 값입니다. 사용하여 게시물을 데이터베이스에서 11-20 검색하려면 &lt;code&gt;slice&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3fa14532ba532bad5e0a0fe4d1aafde94747bcac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../../docs/administration-tools/index&quot;&gt;web UI&lt;/a&gt; (and the &lt;a href=&quot;../info/index&quot;&gt;info&lt;/a&gt; command) can be used to tell you when a table&amp;rsquo;s shards need to be rebalanced.</source>
          <target state="translated">&lt;a href=&quot;../../../docs/administration-tools/index&quot;&gt;웹 UI&lt;/a&gt; (와 &lt;a href=&quot;../info/index&quot;&gt;정보&lt;/a&gt; 테이블의 파편이 재조정해야 할 때 명령은) 당신에게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b88a496bd9a54b173bbc02e5f424502c1760079" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../../docs/data-types/index&quot;&gt;data type&lt;/a&gt; of a primary key is usually a string (like a UUID) or a number, but it can also be a time, binary object, boolean or an array. Data types can be mixed in the primary key field, but all values must be unique. Using an array as a primary key causes the primary key to behave like a compound index; read the documentation on &lt;a href=&quot;../../../docs/secondary-indexes/javascript/index#compound-indexes&quot;&gt;compound secondary indexes&lt;/a&gt; for more information, as it applies to primary keys as well. (Note that the primary index still only covers a single field, while compound secondary indexes can cover multiple fields in a single index.) Primary keys cannot be objects.</source>
          <target state="translated">기본 키 의 &lt;a href=&quot;../../../docs/data-types/index&quot;&gt;데이터 유형&lt;/a&gt; 은 일반적으로 문자열 (UUID와 같은) 또는 숫자이지만 시간, 이진 객체, 부울 또는 배열 일 수도 있습니다. 기본 키 필드에서 데이터 유형을 혼합 할 수 있지만 모든 값은 고유해야합니다. 배열을 기본 키로 사용하면 기본 키가 복합 인덱스처럼 작동합니다. 기본 키에도 적용되는 자세한 내용 은 &lt;a href=&quot;../../../docs/secondary-indexes/javascript/index#compound-indexes&quot;&gt;복합 보조 인덱스&lt;/a&gt; 설명서 를 참조하십시오. 기본 인덱스는 여전히 단일 필드 만 포함하고 복합 보조 인덱스는 단일 인덱스의 여러 필드를 포함 할 수 있습니다. 기본 키는 개체가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="eea447ec8762465807261e23874776e14f996671" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../api/javascript/filter/index&quot;&gt;filter&lt;/a&gt; operation is performed in parallel on each shard of the &lt;code&gt;users&lt;/code&gt; table.</source>
          <target state="translated">&lt;a href=&quot;../../api/javascript/filter/index&quot;&gt;필터&lt;/a&gt; 동작은, 각각의 파편에 병렬로 수행되고 &lt;code&gt;users&lt;/code&gt; 테이블.</target>
        </trans-unit>
        <trans-unit id="175363b1926f54cd38dc31893d76c1b6b52b1f68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../cookbook/javascript/index&quot;&gt;cookbook section&lt;/a&gt; for common queries and example snippets.</source>
          <target state="translated">&lt;a href=&quot;../cookbook/javascript/index&quot;&gt;요리 책 섹션&lt;/a&gt; 일반적인 쿼리 예를 조각합니다.</target>
        </trans-unit>
        <trans-unit id="f2c42c7b4a58d5425ef38d8bc03d53c63ea6af30" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://en.wikipedia.org/wiki/Publish-subscribe&quot;&gt;publish-subscribe pattern&lt;/a&gt; is a powerful way to decouple applications that need to communicate. RethinkDB &lt;a href=&quot;../../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt; allow us to implement publish-subscribe with the database acting as a message exchange. We&amp;rsquo;ve built a small example library called &lt;a href=&quot;https://github.com/rethinkdb/example-pubsub/tree/master/javascript&quot;&gt;repubsub&lt;/a&gt; implementing the pattern for use in JavaScript applications.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Publish-subscribe&quot;&gt;발행 - 구독 패턴은&lt;/a&gt; 필요가 통신 할 수 있음을 분리 애플리케이션에 강력한 방법입니다. RethinkDB 변경 &lt;a href=&quot;../../changefeeds/javascript/index&quot;&gt;피드를&lt;/a&gt; 사용하면 메시지 교환 역할을하는 데이터베이스로 발행-구독을 구현할 수 있습니다. JavaScript 애플리케이션에서 사용하기위한 패턴을 구현하는 &lt;a href=&quot;https://github.com/rethinkdb/example-pubsub/tree/master/javascript&quot;&gt;repubsub&lt;/a&gt; 라는 작은 예제 라이브러리를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="d91058933c549ee7f1fa7e049d7f4cf89934dd2a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://nobrainer.io/&quot;&gt;NoBrainer documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://nobrainer.io/&quot;&gt;NoBrainer 문서&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7d392cdc77f861f51667a3ca36284f5b8708f0a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/mfenniak/rethinkdb-net/graphs/contributors&quot;&gt;rethinkdb-net team&lt;/a&gt; (C#/.NET): &lt;a href=&quot;https://github.com/mfenniak/rethinkdb-net&quot;&gt;https://github.com/mfenniak/rethinkdb-net&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/mfenniak/rethinkdb-net/graphs/contributors&quot;&gt;rethinkdb - 순 팀&lt;/a&gt; (C # / NET.) : &lt;a href=&quot;https://github.com/mfenniak/rethinkdb-net&quot;&gt;https://github.com/mfenniak/rethinkdb-net&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="444bed1a060381b627b7444756e334ab88f212cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/rethinkdb/YCSB/tree/a15e249d6b10147e615ddfaf03672bad35e85e7f&quot;&gt;RethinkDB port of YCSB&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/rethinkdb/YCSB/tree/a15e249d6b10147e615ddfaf03672bad35e85e7f&quot;&gt;YCSB&lt;/a&gt; 의 RethinkDB 포트</target>
        </trans-unit>
        <trans-unit id="a819fbe9a1937b1797d9c6a1ec035e0b9abad4d6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb-example-sinatra-pastie&quot;&gt;Sinatra example application&lt;/a&gt; for a different style of a Ruby web app using RethinkDB.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/rethinkdb/rethinkdb-example-sinatra-pastie&quot;&gt;시나 예제 응용 프로그램&lt;/a&gt; RethinkDB을 사용하여 루비 웹 응용 프로그램의 다른 스타일.</target>
        </trans-unit>
        <trans-unit id="551d89155ea50718c64be4d84e790dfe4aa6d142" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://rethinkdb.com/api/python/rebalance&quot;&gt;rebalance&lt;/a&gt; command will rebalance table shards.</source>
          <target state="translated">&lt;a href=&quot;https://rethinkdb.com/api/python/rebalance&quot;&gt;재조정&lt;/a&gt; 명령은 테이블 파편을 재조정됩니다.</target>
        </trans-unit>
        <trans-unit id="ebcc07dce1d9d2212f7f4ffb39f9574068495311" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://rethinkdb.com/api/python/reconfigure&quot;&gt;reconfigure&lt;/a&gt; command can change the values for &lt;code&gt;shards&lt;/code&gt; and &lt;code&gt;replicas&lt;/code&gt; for an existing table.</source>
          <target state="translated">&lt;a href=&quot;https://rethinkdb.com/api/python/reconfigure&quot;&gt;재구성&lt;/a&gt; 명령에 대한 값을 변경할 수 있습니다 &lt;code&gt;shards&lt;/code&gt; 과 &lt;code&gt;replicas&lt;/code&gt; 기존 테이블.</target>
        </trans-unit>
        <trans-unit id="9ce883ec8777da2140767df9008bd415119ca86b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://rethinkdb.com/api/python/table_create&quot;&gt;table_create&lt;/a&gt; (or &lt;a href=&quot;../../api/javascript/table_create/index&quot;&gt;tableCreate&lt;/a&gt;) command can specify initial values for &lt;code&gt;shards&lt;/code&gt; and &lt;code&gt;replicas&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://rethinkdb.com/api/python/table_create&quot;&gt;table_create&lt;/a&gt; (또는 &lt;a href=&quot;../../api/javascript/table_create/index&quot;&gt;tableCreate&lt;/a&gt; ) 명령의 초기 값을 지정할 수 있습니다 &lt;code&gt;shards&lt;/code&gt; 과 &lt;code&gt;replicas&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6803c1ac084369b6f0438e238c22cc29c63583d9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://rethinkdb.com/api/ruby&quot;&gt;ReQL API docs&lt;/a&gt; for information on RethinkDB commands.</source>
          <target state="translated">RethinkDB 명령에 대한 정보 는 &lt;a href=&quot;https://rethinkdb.com/api/ruby&quot;&gt;ReQL API 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1bec986688114356ebaf7e0856bb503f1a7aaed2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;()&lt;/code&gt; command also accepts integer arguments as array offsets, like the &lt;a href=&quot;../nth/index&quot;&gt;nth&lt;/a&gt; command.</source>
          <target state="translated">&lt;code&gt;()&lt;/code&gt; 명령은 또한 같은 배열 오프셋으로 정수 인수를 받아 &lt;a href=&quot;../nth/index&quot;&gt;제 n&lt;/a&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="0035a462582333656fdc80527201e302fa8b879a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--bind&lt;/code&gt; option controls the default behavior for all RethinkDB ports. If it&amp;rsquo;s specified, the &lt;code&gt;--bind-http&lt;/code&gt;, &lt;code&gt;--bind-cluster&lt;/code&gt; and &lt;code&gt;--bind-driver&lt;/code&gt; options will override that behavior for a specific port. So:</source>
          <target state="translated">&lt;code&gt;--bind&lt;/code&gt; 옵션은 모든 RethinkDB 포트의 기본 동작을 제어합니다. 지정된 경우 &lt;code&gt;--bind-http&lt;/code&gt; , &lt;code&gt;--bind-cluster&lt;/code&gt; 및 &lt;code&gt;--bind-driver&lt;/code&gt; 옵션은 특정 포트에 대한 해당 동작을 재정의합니다. 그래서:</target>
        </trans-unit>
        <trans-unit id="f34a64af8039dab4ccf4ac61fc48463c1783f86e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-r&lt;/code&gt; options are similar to other &lt;code&gt;rethinkdb&lt;/code&gt; options, specifying the cluster host and port (defaulting to &lt;code&gt;localhost:28015&lt;/code&gt;) and either a database or a table to rebuild. The &lt;code&gt;-n&lt;/code&gt; option specifies the number of rebuilds that will be performed concurrently (defaulting to 1).</source>
          <target state="translated">&lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;-r&lt;/code&gt; 옵션은 다른 유사하다 &lt;code&gt;rethinkdb&lt;/code&gt; 의 클러스터 호스트 및 포트를 지정하는 옵션 (을 디폴트 &lt;code&gt;localhost:28015&lt;/code&gt; 및 데이터베이스 또는 테이블 중 하나는 다시). &lt;code&gt;-n&lt;/code&gt; 옵션 지정 동시에 수행 될 재생성의 수 (1 디폴트).</target>
        </trans-unit>
        <trans-unit id="1fbb463da8944345c9e3056ecf777aa6bf848ac4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.conf&lt;/code&gt; file includes a number of options exclusively for the init script. The rest of the options are exactly the same as the ones that go on the command line to the RethinkDB server. For more details about these options run &lt;code&gt;rethinkdb help&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.conf&lt;/code&gt; 파일을 독점적으로 init 스크립트에 대한 옵션을 포함합니다. 나머지 옵션은 명령 행에서 RethinkDB 서버로가는 옵션과 동일합니다. 이러한 옵션에 대한 자세한 내용을 보려면 &lt;code&gt;rethinkdb help&lt;/code&gt; 를 실행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a6abd3a5fbe78c6d61d78af2204c22ef572c884" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IMPLICIT_VAR&lt;/code&gt; term is equivalent to the &lt;a href=&quot;https://rethinkdb.com/api/python/row&quot;&gt;row&lt;/a&gt; command in the official JavaScript and Python drivers. It&amp;rsquo;s useful for languages where anonymous functions are too verbose.</source>
          <target state="translated">&lt;code&gt;IMPLICIT_VAR&lt;/code&gt; 의 기간은 동일하다 &lt;a href=&quot;https://rethinkdb.com/api/python/row&quot;&gt;행&lt;/a&gt; 공식 자바 스크립트와 파이썬 드라이버의 명령. 익명 함수가 너무 장황한 언어에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a39d2fb859670be092655eed63f6837d95943b3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Response&lt;/code&gt; object will have the following fields:</source>
          <target state="translated">&lt;code&gt;Response&lt;/code&gt; 객체에는 다음과 같은 필드가있을 것이다 :</target>
        </trans-unit>
        <trans-unit id="7bc2e812e0c496d5d932fcb76cd7cce4a59cbee5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add&lt;/code&gt; command can be called in either prefix or infix form; both forms are equivalent. Note that ReQL will not perform type coercion. You cannot, for example, &lt;code&gt;add&lt;/code&gt; a string and a number together.</source>
          <target state="translated">&lt;code&gt;add&lt;/code&gt; 명령 중 하나를 접두사 또는 중위 형태로 호출 할 수 있습니다; 두 형태 모두 동일합니다. ReQL은 유형 강제 변환을 수행하지 않습니다. 예를 들어 문자열과 숫자를 함께 &lt;code&gt;add&lt;/code&gt; 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e770bd3be8c4d7f1305a9eb98af4ed57229b1ce6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;and&lt;/code&gt; command can be used as an infix operator after its first argument (&lt;code&gt;r.expr(true).and(false)&lt;/code&gt;) or given all of its arguments as parameters (&lt;code&gt;r.and(true,false)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;and&lt;/code&gt; 명령의 첫 번째 인수 (이후 중위 연산자로서 사용될 수있다 &lt;code&gt;r.expr(true).and(false)&lt;/code&gt; ) 또는 파라미터 (인자로 모두 주어진다 &lt;code&gt;r.and(true,false)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ef981f82d6968bc5dd9c7afb548228c07b5c7260" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;authors&lt;/code&gt; table contains a document for each author. Each document contains information about the relevant author and a field &lt;code&gt;posts&lt;/code&gt; with an array of posts for that author. In this case the query to retrieve all authors with their posts is simple:</source>
          <target state="translated">&lt;code&gt;authors&lt;/code&gt; 표는 각 작가에 대한 문서가 포함되어 있습니다. 각 문서에는 관련 저자에 대한 정보와 해당 저자에 대한 &lt;code&gt;posts&lt;/code&gt; 이 있는 필드 게시물 이 있습니다. 이 경우 게시물로 모든 저자를 검색하는 쿼리는 간단합니다.</target>
        </trans-unit>
        <trans-unit id="91ad3b24d7068e67089ba95cdcdfb53d11c31611" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;between&lt;/code&gt; command works with secondary indexes on date fields, but will not work with unindexed date fields. To test whether a date value is between two other dates, use the &lt;a href=&quot;../during/index&quot;&gt;during&lt;/a&gt; command, not &lt;code&gt;between&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;between&lt;/code&gt; 명령은 날짜 필드에 보조 인덱스와 함께 작동하지만 인덱싱되지 않은 날짜 필드 작동하지 않습니다. 날짜 값이 다른 두 날짜 사이에 있는지 여부를 테스트하려면를 사용 &lt;a href=&quot;../during/index&quot;&gt;하는 동안&lt;/a&gt; , 명령하지 &lt;code&gt;between&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6ed8d702f0da3117561443df7630dac12b3151f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind=all&lt;/code&gt; option is a security risk if your machine is open to the internet, and you should take steps to prevent unauthorized access. See the &lt;a href=&quot;../security/index&quot;&gt;security page&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;bind=all&lt;/code&gt; 컴퓨터가 인터넷에 열려있는 경우 옵션은 보안 위험, 당신은 무단 액세스를 방지하기위한 조치를 취해야한다. 자세한 내용은 &lt;a href=&quot;../security/index&quot;&gt;보안 페이지&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4e4783dc55f18018622aa7131000c8b4f0bf95e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;branch&lt;/code&gt; command takes 2n+1 arguments: pairs of conditional expressions and commands to be executed if the conditionals return any value but &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; (i.e., &amp;ldquo;truthy&amp;rdquo; values), with a final &amp;ldquo;else&amp;rdquo; command to be evaluated if all of the conditionals are &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;branch&lt;/code&gt; 명령은 2N + 1 인수를 취합니다 조건문이 값 만 반환하면 조건식과 명령의 쌍 실행되는 &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;null&lt;/code&gt; (즉, &quot;truthy&quot;값), 최종 &quot;다른&quot;명령을 사용하여 모든 경우에 평가 될 조건은 &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="27792a7b391552685c9bade24559d7d53432ae8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;calendar&lt;/code&gt; table inherits &lt;code&gt;read: true&lt;/code&gt; from the database level, but specifies &lt;code&gt;write: false&lt;/code&gt; to make the table ready-only for &lt;code&gt;notesapp&lt;/code&gt;. The &lt;code&gt;supervisor_only&lt;/code&gt; table overrides both read and write access. The &lt;code&gt;notesapp&lt;/code&gt; account has read and write access to all other tables in the &lt;code&gt;field_notes&lt;/code&gt; database, but no ability to create and drop indexes or change any table&amp;rsquo;s cluster configuration.</source>
          <target state="translated">&lt;code&gt;calendar&lt;/code&gt; 테이블 상속는 &lt;code&gt;read: true&lt;/code&gt; 데이터베이스 레벨에서,하지만 지정은 &lt;code&gt;write: false&lt;/code&gt; 의 테이블 만 준비 만들 &lt;code&gt;notesapp&lt;/code&gt; . &lt;code&gt;supervisor_only&lt;/code&gt; 표는 모두 읽기 및 쓰기 액세스를 무시합니다. &lt;code&gt;notesapp&lt;/code&gt; 의 계정을 읽을과 다른 모든 테이블에 대한 쓰기 권한이있다 &lt;code&gt;field_notes&lt;/code&gt; 의 데이터베이스, 그러나 어떤 테이블의 클러스터 구성을 생성하고 인덱스를 삭제하거나 변경할 수있는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="0e991e5c86a7f1c8aeeaa978efd7dd967c0ddf10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ceil&lt;/code&gt; command can also be chained after an expression.</source>
          <target state="translated">&lt;code&gt;ceil&lt;/code&gt; 명령은 식 후 체인 될 수있다.</target>
        </trans-unit>
        <trans-unit id="a18180e46d884ec86288be9f1179b764c0543cf4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;changes&lt;/code&gt; command returns a cursor (like the &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;filter&lt;/code&gt; commands do). You can iterate through its contents using ReQL. Unlike other cursors, the output of &lt;code&gt;changes&lt;/code&gt; is infinite: the cursor will block until more elements are available. Every time you make a change to the table or document the &lt;code&gt;changes&lt;/code&gt; feed is monitoring, a new object will be returned to the cursor. For example, if you insert a user &lt;code&gt;{id:1,name:Slava,age:31}&lt;/code&gt; into the &lt;code&gt;users&lt;/code&gt; table, RethinkDB will post this document to changefeeds subscribed to &lt;code&gt;users&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;changes&lt;/code&gt; (등 커서 반환 명령을 &lt;code&gt;table&lt;/code&gt; 또는 &lt;code&gt;filter&lt;/code&gt; 할 명령). ReQL을 사용하여 내용을 반복 할 수 있습니다. 다른 커서와 달리 &lt;code&gt;changes&lt;/code&gt; 는 무한합니다. 더 많은 요소를 사용할 수있을 때까지 커서가 차단됩니다. 테이블을 변경하거나 &lt;code&gt;changes&lt;/code&gt; 피드가 모니터링중인 문서를 작성할 때마다 새 오브젝트가 커서로 리턴됩니다. 예를 들어, 사용자 테이블에 &lt;code&gt;{id:1,name:Slava,age:31}&lt;/code&gt; &lt;code&gt;users&lt;/code&gt; 삽입하면 RethinkDB가이 문서를 게시하여 &lt;code&gt;users&lt;/code&gt; 가입 된 피드를 변경 합니다 .</target>
        </trans-unit>
        <trans-unit id="c71ebc6710e993abe3e242cc002398d0e04115b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chmod&lt;/code&gt; for the two files should be 644 (&lt;code&gt;chmod 644 &amp;lt;file&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">두 파일 의 &lt;code&gt;chmod&lt;/code&gt; 는 644 ( &lt;code&gt;chmod 644 &amp;lt;file&amp;gt;&lt;/code&gt; ) 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="b1746e0f4ec2b3cbd9ee6e45b008169437cd2080" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;close&lt;/code&gt; command can optionally take a callback, which will receive an error if one occurs, or return a promise which will be resolved when the connection is closed.</source>
          <target state="translated">&lt;code&gt;close&lt;/code&gt; 명령은 선택적으로 하나가 발생하면 오류가 발생합니다 콜백을 취하거나 연결이 닫힐 때 해결 될 것입니다 약속을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8de72741c99cbbd0f718cde70c80b9b736a0601d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cluster_config&lt;/code&gt; table contains only one row. Documents cannot be inserted into or deleted from this table.</source>
          <target state="translated">&lt;code&gt;cluster_config&lt;/code&gt; 의 테이블은 하나의 행이 포함되어 있습니다. 이 테이블에 문서를 삽입하거나 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="97a00f39b10088ac3fc7162f96d2aed96ec5e4cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;config&lt;/code&gt; command is a shorthand way to access the &lt;code&gt;table_config&lt;/code&gt; or &lt;code&gt;db_config&lt;/code&gt;&lt;a href=&quot;../../../docs/system-tables/index#configuration-tables&quot;&gt;System tables&lt;/a&gt;. It will return the single row from the system that corresponds to the database or table configuration, as if &lt;a href=&quot;../get/index&quot;&gt;get&lt;/a&gt; had been called on the system table with the UUID of the database or table in question.</source>
          <target state="translated">&lt;code&gt;config&lt;/code&gt; 명령은 액세스 할 수있는 속기 방법입니다 &lt;code&gt;table_config&lt;/code&gt; 또는 &lt;code&gt;db_config&lt;/code&gt; &lt;a href=&quot;../../../docs/system-tables/index#configuration-tables&quot;&gt;시스템 테이블을&lt;/a&gt; . 마치 데이터베이스 또는 테이블의 UUID를 사용하여 시스템 테이블에서 &lt;a href=&quot;../get/index&quot;&gt;get&lt;/a&gt; 이 호출 된 것처럼 데이터베이스 또는 테이블 구성에 해당하는 시스템에서 단일 행을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="f8da9493de79adac421fcb25c1f5650dc9b6547f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; command returns the size of the array.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 명령은 배열의 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d848d8e92a343bd1e1ee7712c5160da92d5ac9ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; field is a Base64-encoded string of the binary object.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 필드는 바이너리 객체의 64 비트로 인코딩 된 문자열이다.</target>
        </trans-unit>
        <trans-unit id="ea8d1ca1b2a77edf32c2a4590df21ed431ecff04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;db&lt;/code&gt; command is optional. If it is not present in a query, the query will run against the default database for the connection, specified in the &lt;code&gt;db&lt;/code&gt; argument to &lt;a href=&quot;../connect/index&quot;&gt;connect&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;db&lt;/code&gt; 명령은 선택 사항입니다. 쿼리에 없으면 연결에 대한 &lt;code&gt;db&lt;/code&gt; 인수에 지정된 연결의 기본 데이터베이스에 대해 쿼리가 실행 &lt;a href=&quot;../connect/index&quot;&gt;됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ad37eacb273de6461d7f78364b2740a5284a171" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;distinct&lt;/code&gt; command can be called on any sequence or table with an index.</source>
          <target state="translated">&lt;code&gt;distinct&lt;/code&gt; 명령은 인덱스 어떤 순서 또는 테이블에 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdbdf15e337cc4a8b690ca59921a9c3a8e7640aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;durability&lt;/code&gt; argument on writes is ignored for system tables.</source>
          <target state="translated">시스템 테이블에서는 쓰기 의 &lt;code&gt;durability&lt;/code&gt; 인수가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ea7c8b836aba9d6c0c4b7b00901b656aa824e964" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;durability&lt;/code&gt; setting for a table controls when writes are committed. In &lt;code&gt;hard&lt;/code&gt; durability mode, writes are committed to disk before acknowledgements are sent; in &lt;code&gt;soft&lt;/code&gt; mode, writes are acknowledged immediately upon receipt. The &lt;code&gt;soft&lt;/code&gt; mode is faster but slightly less resilient to failure.</source>
          <target state="translated">테이블 의 &lt;code&gt;durability&lt;/code&gt; 설정은 쓰기가 커밋되는시기를 제어합니다. 에서 &lt;code&gt;hard&lt;/code&gt; 승인이 전송되기 전에 내구성 모드, 쓰기는 디스크에 최선을 다하고 있습니다; 에서 &lt;code&gt;soft&lt;/code&gt; 모드, 쓰기는 접수 즉시 인정된다. &lt;code&gt;soft&lt;/code&gt; 모드는 빠르지 만 실패 약간 덜 탄력적이다.</target>
        </trans-unit>
        <trans-unit id="e3a148d5481c3b62ef42c8cb3568f88ca4842c72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;em_run&lt;/code&gt; command returns a &lt;code&gt;QueryHandle&lt;/code&gt; instance. The &lt;code&gt;QueryHandle&lt;/code&gt; will be closed when all results have been received, or when EventMachine stops running. You can explicitly close it with the &lt;code&gt;close&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;em_run&lt;/code&gt; 의 명령은 반환 &lt;code&gt;QueryHandle&lt;/code&gt; 의 인스턴스를. &lt;code&gt;QueryHandle&lt;/code&gt; 는 모든 결과가 수신되었을 때 종료되거나, EventMachine 실행이 중단 될 때. &lt;code&gt;close&lt;/code&gt; 메소드를 사용하여 명시 적으로 닫을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8854e7d74db852ed391856ffbb13339def8f064" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;emergencyRepair&lt;/code&gt; argument is effectively a different command; when it is specified, no other arguments to &lt;code&gt;reconfigure&lt;/code&gt; are allowed except for &lt;code&gt;dryRun&lt;/code&gt;. When it&amp;rsquo;s executed, each shard of the table is examined and classified into one of three categories:</source>
          <target state="translated">&lt;code&gt;emergencyRepair&lt;/code&gt; 의 인수는 효과적으로 다른 명령입니다; 지정된 경우, &lt;code&gt;dryRun&lt;/code&gt; 을 제외하고 &lt;code&gt;reconfigure&lt;/code&gt; 할 다른 인수 는 허용되지 않습니다 . 실행되면 테이블의 각 샤드가 검사되고 다음 세 가지 범주 중 하나로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="ce8009e94a95dd349ffe642ad6a2659550bbd18c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;epoch_time&lt;/code&gt; field is a Unix timestamp, the number of seconds since January 1st, 1970, with millisecond precision. The &lt;code&gt;timezone&lt;/code&gt; field is a string in the format &lt;code&gt;[+-]HH:MM&lt;/code&gt;, indicating the offset from UTC. UTC is &lt;code&gt;+00:00&lt;/code&gt;; PST is &lt;code&gt;-08:00&lt;/code&gt;; and so on.</source>
          <target state="translated">&lt;code&gt;epoch_time&lt;/code&gt; 필드는 밀리 초 정밀도로 유닉스 타임 스탬프 월 제 1 회, 1970 년 이후 (초)입니다. &lt;code&gt;timezone&lt;/code&gt; 필드 형식 문자열이다 &lt;code&gt;[+-]HH:MM&lt;/code&gt; 은 상기 UTC 오프셋을 나타낸다. UTC는 &lt;code&gt;+00:00&lt;/code&gt; 입니다 . PST는 &lt;code&gt;-08:00&lt;/code&gt; 입니다 . 등등.</target>
        </trans-unit>
        <trans-unit id="dd58d2675dc0248d66b49c9c9903627922ec7a35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eq&lt;/code&gt; command returns &lt;code&gt;true&lt;/code&gt; if two values are equal (in this case, the field &lt;code&gt;name&lt;/code&gt; and the string &lt;code&gt;William Adama&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;eq&lt;/code&gt; 명령이 리턴 &lt;code&gt;true&lt;/code&gt; 두 값의 경우는 동일하다 (이 경우, 필드 &lt;code&gt;name&lt;/code&gt; 과 문자열 &lt;code&gt;William Adama&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5aca7815d3874f89ac128aa8778fdf468fd56814" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;floor&lt;/code&gt; command can also be chained after an expression.</source>
          <target state="translated">&lt;code&gt;floor&lt;/code&gt; 명령은 식 후 체인 될 수있다.</target>
        </trans-unit>
        <trans-unit id="c2c1feeb5fb90500506597611ab61b06ab509f62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;function&lt;/code&gt; field is a binary object containing an opaque representation of the secondary index (including the &lt;code&gt;multi&lt;/code&gt; argument if specified). It can be passed as the second argument to &lt;a href=&quot;../index_create/index&quot;&gt;indexCreate&lt;/a&gt; to create a new index with the same function; see &lt;code&gt;indexCreate&lt;/code&gt; for more information.</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; 필드합니다 (포함한 보조 인덱스 불투명 표현 함유 이진 목적은 &lt;code&gt;multi&lt;/code&gt; 지정된 경우 인수). 동일한 함수로 새 색인을 작성 하기 위해 &lt;a href=&quot;../index_create/index&quot;&gt;indexCreate&lt;/a&gt; 에 두 번째 인수로 전달 될 수 있습니다 . 자세한 내용 은 &lt;code&gt;indexCreate&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4946559a625e3e8a1a801b2936ef820db204b2d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;grant&lt;/code&gt; command returns an object of the following form:</source>
          <target state="translated">&lt;code&gt;grant&lt;/code&gt; 명령은 다음과 같은 형식의 개체를 반환 :</target>
        </trans-unit>
        <trans-unit id="0dc08e6a902a4c96c1bd71bf6dc00101fd253b31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;granted&lt;/code&gt; field will always be &lt;code&gt;1&lt;/code&gt;, and the &lt;code&gt;permissions_changes&lt;/code&gt; list will have one object, describing the new permissions values and the old values they were changed from (which may be &lt;code&gt;null&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;granted&lt;/code&gt; 필드는 항상있을 것 &lt;code&gt;1&lt;/code&gt; , 그리고 &lt;code&gt;permissions_changes&lt;/code&gt; 의 목록은 새로운 권한 값과 그들이에서 변경된 이전 값을 (이있을 수 있습니다 설명, 하나의 객체가됩니다 &lt;code&gt;null&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="80d81ca6649abafda23e1ea30713e22d76b2657a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gt&lt;/code&gt; command returns &lt;code&gt;true&lt;/code&gt; if a value is greater than the specified value (in this case, if the number of posts is greater than two).</source>
          <target state="translated">&lt;code&gt;gt&lt;/code&gt; 명령이 반환 &lt;code&gt;true&lt;/code&gt; 값이 규정 값보다 큰 경우 (이 경우, 포스트들의 수가 2보다 큰 경우).</target>
        </trans-unit>
        <trans-unit id="f3b0ff93f0028dedb7d088ecb0bfabd1b04c1ae2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; field will be a parsed version of the header with fields lowercased, like so:</source>
          <target state="translated">&lt;code&gt;header&lt;/code&gt; 필드과 같이, 소문자 필드 헤더의 구문 분석 된 버전이 될 것입니다 :</target>
        </trans-unit>
        <trans-unit id="33748724c059e842b140ab3cebc0157906f31f2c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;htpasswd&lt;/code&gt; tool will prompt for your new password.</source>
          <target state="translated">&lt;code&gt;htpasswd&lt;/code&gt; 도구는 새 암호를 입력하라는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9ab9c4300a5d1a171fddf197c761d335fc5e9a5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;includeStates&lt;/code&gt; optional argument to &lt;code&gt;changes&lt;/code&gt; allows you to receive extra &amp;ldquo;status&amp;rdquo; documents in changefeed streams. These can allow your application to distinguish between initial values returned at the start of a stream and subsequent changes. Read the &lt;a href=&quot;../../../api/javascript/changes/index&quot;&gt;changes&lt;/a&gt; API documentation for a full explanation and example.</source>
          <target state="translated">&lt;code&gt;changes&lt;/code&gt; 대한 &lt;code&gt;includeStates&lt;/code&gt; 선택적 인수를 사용하면 변경 피드 스트림에서 추가 &quot;상태&quot;문서를 수신 할 수 있습니다. 이를 통해 애플리케이션은 스트림 시작시 리턴 된 초기 값과 후속 변경 사항을 구별 할 수 있습니다. 자세한 설명과 예제 는 &lt;a href=&quot;../../../api/javascript/changes/index&quot;&gt;변경&lt;/a&gt; API 설명서를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="868052f78a577f27a08e87e2dc0bb1b9048f59fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;includeTypes&lt;/code&gt; optional argument adds a third field, &lt;code&gt;type&lt;/code&gt;, to each result sent. The string values for &lt;code&gt;type&lt;/code&gt; are largely self-explanatory:</source>
          <target state="translated">&lt;code&gt;includeTypes&lt;/code&gt; 선택적 인수는 세 번째 필드, 추가 &lt;code&gt;type&lt;/code&gt; 각 결과 보냈. &lt;code&gt;type&lt;/code&gt; 의 문자열 값은 설명이 필요 없습니다.</target>
        </trans-unit>
        <trans-unit id="8d6a2fe819501f70843ca93b461a8f2fab096d7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;includes&lt;/code&gt; command cannot take advantage of a geospatial &lt;a href=&quot;../../../docs/secondary-indexes/javascript/index&quot;&gt;secondary index&lt;/a&gt;. If you&amp;rsquo;re working with large data sets, consider using an index and &lt;a href=&quot;../get_intersecting/index&quot;&gt;getIntersecting&lt;/a&gt; before &lt;code&gt;includes&lt;/code&gt; to narrow down the initial result set.</source>
          <target state="translated">는 &lt;code&gt;includes&lt;/code&gt; 명령은 지리 공간을 활용할 수 없습니다 &lt;a href=&quot;../../../docs/secondary-indexes/javascript/index&quot;&gt;보조 인덱스&lt;/a&gt; . 용량이 큰 데이터 세트로 작업하는 경우, 인덱스를 사용하여 고려 &lt;a href=&quot;../get_intersecting/index&quot;&gt;getIntersecting는&lt;/a&gt; 전에 &lt;code&gt;includes&lt;/code&gt; 초기 결과 집합의 범위를 좁힐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b3a7d962ba66d9269511623889e1a2dd7b32c96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index&lt;/code&gt; argument is mandatory. Optional arguments are:</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 인수는 필수입니다. 선택적 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ad770288c26a5de2145131cdaacd5a9d83f4d136" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index&lt;/code&gt; argument is mandatory. This command returns the same results as &lt;code&gt;table.filter(r.row('index').intersects(geometry))&lt;/code&gt;. The total number of results is limited to the array size limit which defaults to 100,000, but can be changed with the &lt;code&gt;arrayLimit&lt;/code&gt; option to &lt;a href=&quot;../run/index&quot;&gt;run&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 인수는 필수입니다. 이 명령은 &lt;code&gt;table.filter(r.row('index').intersects(geometry))&lt;/code&gt; 와 동일한 결과를 반환합니다 . 총 결과 수는 배열 크기 제한 (기본적으로 100,000)으로 제한되지만 &lt;code&gt;arrayLimit&lt;/code&gt; 옵션을 사용하여 &lt;a href=&quot;../run/index&quot;&gt;run&lt;/a&gt; 으로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd743e36733d09c9da01000c0b88c5292d0cc3d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;indexFunction&lt;/code&gt; can be an anonymous function or a binary representation obtained from the &lt;code&gt;function&lt;/code&gt; field of &lt;a href=&quot;../index_status/index&quot;&gt;indexStatus&lt;/a&gt;. The function must be deterministic, and so cannot use a subquery or the &lt;code&gt;r.js&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;indexFunction&lt;/code&gt; 은 익명 함수 나로부터 얻어지는 바이너리 표현 될 수있는 &lt;code&gt;function&lt;/code&gt; 필드 &lt;a href=&quot;../index_status/index&quot;&gt;indexStatus&lt;/a&gt; . 함수는 결정적이어야하므로 하위 쿼리 나 &lt;code&gt;r.js&lt;/code&gt; 명령을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b43ceb3b85c6c373b0ae4ee4be93296ef3fea882" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;insert&lt;/code&gt; command accepts a single document or an array of documents if you want to batch inserts. We use an array in this query instead of running three separate &lt;code&gt;insert&lt;/code&gt; commands for each document.</source>
          <target state="translated">&lt;code&gt;insert&lt;/code&gt; 일괄 삽입하려는 경우 명령은 하나의 문서 또는 문서의 배열을 받아들입니다. 각 문서마다 세 개의 개별 &lt;code&gt;insert&lt;/code&gt; 명령을 실행하는 대신이 쿼리에 배열을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d6621021a52f95d192cf8605e58bf7280b4c773c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intersects&lt;/code&gt; command cannot take advantage of a geospatial &lt;a href=&quot;../../../docs/secondary-indexes/javascript/index&quot;&gt;secondary index&lt;/a&gt;. If you&amp;rsquo;re working with large data sets, you should consider using an index and the &lt;a href=&quot;../get_intersecting/index&quot;&gt;getIntersecting&lt;/a&gt; command instead of &lt;code&gt;intersects&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;intersects&lt;/code&gt; 명령은 지리 공간을 활용할 수 없습니다 &lt;a href=&quot;../../../docs/secondary-indexes/javascript/index&quot;&gt;보조 인덱스&lt;/a&gt; . 큰 데이터 세트로 작업하는 경우 &lt;code&gt;intersects&lt;/code&gt; 대신 인덱스와 &lt;a href=&quot;../get_intersecting/index&quot;&gt;getIntersecting&lt;/a&gt; 명령 을 사용해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="c4139db0f544e285139cf6c660044e153973d181" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jobs&lt;/code&gt; table provides information about tasks running within the RethinkDB cluster, including queries, disk compaction, and index construction, and allows you to kill query jobs by deleting them from the table. For details, read the &lt;a href=&quot;../system-jobs/index&quot;&gt;System jobs table&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;code&gt;jobs&lt;/code&gt; 테이블은 쿼리, 디스크 압축 및 인덱스 구성을 포함하여 RethinkDB 클러스터 내에서 실행 된 작업에 대한 정보를 제공하고 테이블에서 삭제하여 쿼리 작업을 중단 할 수 있도록 허용합니다. 자세한 내용은 &lt;a href=&quot;../system-jobs/index&quot;&gt;시스템 작업 표&lt;/a&gt; 설명서를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="02ce76979f5d4e08895a24ed209616d935ad93fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lambda&lt;/code&gt; expression is executed only once on the client. Internally, the driver passes a special object to the &lt;code&gt;lambda&lt;/code&gt; function which allows constructing a representation of the query. This representation is then sent to the server over the network and evaluated on the cluster.</source>
          <target state="translated">&lt;code&gt;lambda&lt;/code&gt; 표현식은 클라이언트에서 한 번만 실행됩니다. 내부적으로 드라이버는 쿼리의 표현을 구성 할 수 있는 &lt;code&gt;lambda&lt;/code&gt; 함수에 특수 객체를 전달 합니다. 그런 다음이 표현은 네트워크를 통해 서버로 전송되고 클러스터에서 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="8db687d26d281f53ab2937b362050f18086c0100" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;logs&lt;/code&gt; table supports changefeeds. Only messages being &lt;em&gt;written to the logs table&lt;/em&gt; will generate changefeed events.</source>
          <target state="translated">는 &lt;code&gt;logs&lt;/code&gt; 테이블 지원의 changefeeds을. &lt;em&gt;logs 테이블&lt;/em&gt; 에 &lt;em&gt;기록&lt;/em&gt; 되는 메시지 만 변경 피드 이벤트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="747a7670afb696b207114aaef7ea26c0638477d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;match&lt;/code&gt; command does not support backreferences.</source>
          <target state="translated">&lt;code&gt;match&lt;/code&gt; 명령은 역 참조를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7fecdd1e7503897b3b0389a10c6271bc84fd03f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;max&lt;/code&gt; command can be called with:</source>
          <target state="translated">&lt;code&gt;max&lt;/code&gt; 명령으로 호출 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a61970042a7f09b4c61acb3dfc28139c2a94bdaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;min&lt;/code&gt; command can be called with:</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; 명령으로 호출 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="b21b8958d38631f71f563c6d778bb5c3c1ffc323" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multi&lt;/code&gt; field will be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; depending on whether this index was created as a multi index; the &lt;code&gt;geo&lt;/code&gt; field will be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; depending on whether this index was created as a geospatial index. See &lt;a href=&quot;../index_create/index&quot;&gt;indexCreate&lt;/a&gt; for details. The &lt;code&gt;outdated&lt;/code&gt; field will be true if the index is outdated in the current version of RethinkDB and needs to be rebuilt. The &lt;code&gt;progress&lt;/code&gt; field is a float between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;, indicating how far along the server is in constructing indexes after the most recent change to the table that would affect them. (&lt;code&gt;0&lt;/code&gt; indicates no such indexes have been constructed; &lt;code&gt;1&lt;/code&gt; indicates all of them have.)</source>
          <target state="translated">&lt;code&gt;multi&lt;/code&gt; 필드는 것 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 이 인덱스는 다중 지표로 작성된 여부에 따라; &lt;code&gt;geo&lt;/code&gt; 필드는 것 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 이 인덱스는 지리 공간 인덱스로 만들어 졌는지 여부에 따라 달라집니다. 자세한 내용은 &lt;a href=&quot;../index_create/index&quot;&gt;indexCreate&lt;/a&gt; 를 참조하십시오. &lt;code&gt;outdated&lt;/code&gt; 인덱스가 RethinkDB의 현재 버전에서 오래된 재건해야 할 경우 필드는 true가됩니다. &lt;code&gt;progress&lt;/code&gt; 필드 사이의 부동입니다 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; 얼마나 멀리 서버를 따라 그들에게 영향을 테이블에 가장 최근의 변경 후 인덱스를 구성에 나타냅니다. ( &lt;code&gt;0&lt;/code&gt; 그러한 색인이 구성되지 않았 음을 나타냅니다. &lt;code&gt;1&lt;/code&gt; 은 모두 가지고 있음을 나타냅니다.)</target>
        </trans-unit>
        <trans-unit id="5593aa4baf9fd61785d48ac139c9d79b76a0b29f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n&lt;/code&gt; field, if present, will be an array of one or more &lt;code&gt;ResponseNote&lt;/code&gt; values, giving further information about the kind of the stream being returned. These will be numeric values, corresponding to the notes in &lt;code&gt;ql2.proto&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 필드가 존재한다면, 하나 개 이상의 배열 될 것이다 &lt;code&gt;ResponseNote&lt;/code&gt; 의 반환 스트림의 종류에 관한 정보를주는 값. 이는 &lt;code&gt;ql2.proto&lt;/code&gt; 의 메모에 해당하는 숫자 값 입니다.</target>
        </trans-unit>
        <trans-unit id="233fb265ce401f5e6ef81eb6bf82b04d5b9bd910" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;or&lt;/code&gt; command can be used as an infix operator after its first argument (&lt;code&gt;r.expr(true).or(false)&lt;/code&gt;) or given all of its arguments as parameters (&lt;code&gt;r.or(true,false)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;or&lt;/code&gt; 명령은 첫 번째 인수 (이후 중위 연산자로서 사용될 수있다 &lt;code&gt;r.expr(true).or(false)&lt;/code&gt; ) 또는 파라미터 (인자로 모두 주어진다 &lt;code&gt;r.or(true,false)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="86115daaac62e6d67b2f25326871b6408003fe0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;orderBy&lt;/code&gt; operation is performed on the query server.</source>
          <target state="translated">&lt;code&gt;orderBy&lt;/code&gt; 작업은 쿼리 서버에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="0f69c272f5a8902ee9b15471e9f21b729c73065c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;page&lt;/code&gt; argument takes the type of pagination mechanism used by the API. In this case GitHub uses the standard link header mechanism &lt;code&gt;link-next&lt;/code&gt;, but you can also specify custom pagination schemes for unusual APIs. The &lt;code&gt;page-limit&lt;/code&gt; argument specifies the number of pages you&amp;rsquo;d like to get. See the &lt;a href=&quot;../../api/javascript/http/index&quot;&gt;API reference&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;page&lt;/code&gt; 인수는 API가 사용하는 페이지 매김 메커니즘의 유형을합니다. 이 경우 GitHub는 표준 링크 헤더 메커니즘 &lt;code&gt;link-next&lt;/code&gt; 를 사용하지만 비정상적인 API에 대해 사용자 지정 페이지 매김 구성표를 지정할 수도 있습니다. &lt;code&gt;page-limit&lt;/code&gt; 인수는 좀하고 싶습니다 페이지의 수를 지정합니다. 자세한 내용은 &lt;a href=&quot;../../api/javascript/http/index&quot;&gt;API 참조&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="95bcd53724b946ca9ed7f295c7ce42629507b3c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;page&lt;/code&gt; function may return a string corresponding to the next URL to request, &lt;code&gt;null&lt;/code&gt; indicating that there is no more to get, or an object of the format:</source>
          <target state="translated">&lt;code&gt;page&lt;/code&gt; 기능은 요청에 다음 URL에 해당하는 문자열을 반환 할 수 있습니다 &lt;code&gt;null&lt;/code&gt; 거기에 더 이상, 또는 형식의 개체를 나타내는 없습니다 :</target>
        </trans-unit>
        <trans-unit id="8eac2c2eafcc25e69c439c981a9a43c9505640b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;password&lt;/code&gt; field is simply a boolean indicating whether a password is set or not. There is no way to read a password from the database.</source>
          <target state="translated">&lt;code&gt;password&lt;/code&gt; 필드는 단순히 암호가 설정 여부를 나타내는 부울입니다. 데이터베이스에서 비밀번호를 읽을 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9eb572facbb41488fe72b8fa9f65c8b6e60f804a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pluck&lt;/code&gt; command also supports selecting nested fields in a document. For example, suppose we&amp;rsquo;d like to select the fields &lt;code&gt;phone&lt;/code&gt; and &lt;code&gt;email&lt;/code&gt; from the following document:</source>
          <target state="translated">&lt;code&gt;pluck&lt;/code&gt; 명령은 문서에 중첩 된 필드를 선택 지원합니다. 예를 들어 다음 문서에서 &lt;code&gt;phone&lt;/code&gt; 및 &lt;code&gt;email&lt;/code&gt; 필드를 선택한다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="ded41df3cb008f7a94136d4d3d523c133ad429cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ql2.proto&lt;/code&gt; file is well-commented, showing arguments and output for each command.</source>
          <target state="translated">&lt;code&gt;ql2.proto&lt;/code&gt; 의 파일은 각 명령에 대한 인수 및 출력을 보여 잘 주석.</target>
        </trans-unit>
        <trans-unit id="1cde22a6f27e7d9521847d08386006eb67987ad7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r.do()&lt;/code&gt; command is serialized with the &lt;code&gt;FUNCALL&lt;/code&gt; term.</source>
          <target state="translated">&lt;code&gt;r.do()&lt;/code&gt; 명령은 직렬화되어 &lt;code&gt;FUNCALL&lt;/code&gt; 의 용어.</target>
        </trans-unit>
        <trans-unit id="2df58bc197cc0396ab3dc29565ebeae49124d81c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r.http&lt;/code&gt; command will issue a request to &lt;code&gt;www.google.com&lt;/code&gt; directly from the database and return a string with the source of Google&amp;rsquo;s homepage.</source>
          <target state="translated">&lt;code&gt;r.http&lt;/code&gt; 의 명령에 요청 발급 &lt;code&gt;www.google.com&lt;/code&gt; 을 데이터베이스에서 직접 구글의 홈페이지의 소스 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="36decc9f51cb514925634d8bff79ad911b6257f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;config&lt;/code&gt; permissions can be specified on three scopes, from most granular to least:</source>
          <target state="translated">&lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; 및 &lt;code&gt;config&lt;/code&gt; 권한은 가장 세부에서 세 가지 범위에서 이상에 지정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="49b42e69bb9c54f130efd1a3ec27a3df710af6ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rebalance&lt;/code&gt; command operates by measuring the distribution of primary keys within a table and picking split points that will give each shard approximately the same number of documents. It won&amp;rsquo;t change the number of shards within a table, or change any other configuration aspect for the table or the database.</source>
          <target state="translated">&lt;code&gt;rebalance&lt;/code&gt; 명령은 테이블에서 기본 키의 분포를 측정하고 각각의 파편에게 문서의 거의 같은 수를 줄 것이다 분할 지점을 선택하여 운영하고 있습니다. 테이블 내의 샤드 수를 변경하거나 테이블 또는 데이터베이스의 다른 구성 측면을 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="554d2dc3c9db959ecfadca51c84bf63b31fddb75" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;replace&lt;/code&gt; command can be used to both insert and delete documents. If the &amp;ldquo;replaced&amp;rdquo; document has a primary key that doesn&amp;rsquo;t exist in the table, the document will be inserted; if an existing document is replaced with &lt;code&gt;null&lt;/code&gt;, the document will be deleted. Since &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;replace&lt;/code&gt; operations are performed atomically, this allows atomic inserts and deletes as well.</source>
          <target state="translated">&lt;code&gt;replace&lt;/code&gt; 명령은 삽입과 삭제 문서 모두에 사용할 수 있습니다. &quot;대체 된&quot;문서에 테이블에 존재하지 않는 기본 키가있는 경우 문서가 삽입됩니다. 기존 문서가 &lt;code&gt;null&lt;/code&gt; 로 바뀌면 문서가 삭제됩니다. 이후 &lt;code&gt;update&lt;/code&gt; 및 &lt;code&gt;replace&lt;/code&gt; 작업이 원자 적으로 수행,이 원자 삽입과 삭제도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69061fb9a85edfcdb4797cccceab5987fcbbd1bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;restore&lt;/code&gt; subcommand has most of the the same options and defaults as the &lt;code&gt;dump&lt;/code&gt; command, although there are a few extra commands for controlling how data is imported.</source>
          <target state="translated">&lt;code&gt;restore&lt;/code&gt; 부속 명령은과 같은 옵션 및 기본값의 대부분이 &lt;code&gt;dump&lt;/code&gt; 몇 가지 추가 명령은 데이터를 가져 오는 방법을 제어하기 위해이 있지만, 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3732c751628619f7fe5223ea3a55cd9b025f5625" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;restore&lt;/code&gt; subcommand will reload a backup an archive into your cluster.</source>
          <target state="translated">&lt;code&gt;restore&lt;/code&gt; 부속 명령은 클러스터에 백업을 아카이브를 다시로드합니다.</target>
        </trans-unit>
        <trans-unit id="5290e332ab7fca15808af2f086fca3b9fe419cf1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rethinkdb&lt;/code&gt; utility includes an &lt;code&gt;import&lt;/code&gt; command to load existing data into RethinkDB databases. It can read JSON files, organized in one of two formats described below, or comma-separated value (CSV) files (including ones with other delimiters such as tab characters). The utility runs under the &lt;code&gt;admin&lt;/code&gt; user account (see &lt;a href=&quot;../permissions-and-accounts/index&quot;&gt;Permissions and user accounts&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;rethinkdb&lt;/code&gt; 의 유틸리티는 포함 &lt;code&gt;import&lt;/code&gt; RethinkDB 데이터베이스에 기존 데이터를로드하는 명령을 사용합니다. 아래 설명 된 두 가지 형식 중 하나로 구성된 JSON 파일 또는 쉼표로 구분 된 값 (CSV) 파일 (탭 문자와 같은 다른 구분 기호가있는 파일 포함)을 읽을 수 있습니다. 이 유틸리티는 &lt;code&gt;admin&lt;/code&gt; 계정으로 실행 됩니다 ( &lt;a href=&quot;../permissions-and-accounts/index&quot;&gt;권한 및 사용자 계정&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="23ff9bbe25c8004989f8850322279724e1a217cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;round&lt;/code&gt; command can also be chained after an expression.</source>
          <target state="translated">&lt;code&gt;round&lt;/code&gt; 명령어는 식 후에 연쇄 될 수있다.</target>
        </trans-unit>
        <trans-unit id="be5dd85bcc132fcce01c6a0bdf9d6ad96e28c77c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rowProcess&lt;/code&gt; callback receives the row as its first argument; it may also take an optional second argument, which is a callback function to be executed after each row has been processed.</source>
          <target state="translated">&lt;code&gt;rowProcess&lt;/code&gt; 의 콜백은 첫 번째 인수로 열을 수신하고; 또한 선택적인 두 번째 인수가 필요할 수 있습니다.이 인수는 각 행이 처리 된 후 실행될 콜백 함수입니다.</target>
        </trans-unit>
        <trans-unit id="ab1dfcd0ac2e8005e1671ad7646473bea948e6f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;server&lt;/code&gt; command returns either two or three fields:</source>
          <target state="translated">&lt;code&gt;server&lt;/code&gt; 명령이 리턴 중 두 개 또는 세 개의 필드 :</target>
        </trans-unit>
        <trans-unit id="02c5611afbdf2371b84ac8989750ab9372b63d9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stats&lt;/code&gt; table provides statistics about server read/write throughput, client connections, and memory usage. For details, read the &lt;a href=&quot;../system-stats/index&quot;&gt;System stats table&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;code&gt;stats&lt;/code&gt; 테이블은 서버 읽기 / 쓰기 처리량, 클라이언트 연결 및 메모리 사용에 대한 통계를 제공합니다. 자세한 내용은 &lt;a href=&quot;../system-stats/index&quot;&gt;시스템 통계 테이블&lt;/a&gt; 설명서 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dcbcbb3b476cec86770a7e8508c7d7f14fd0f096" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;table&lt;/code&gt; command returns a cursor; use the &lt;a href=&quot;../../../api/javascript/next/index&quot;&gt;next&lt;/a&gt; or &lt;a href=&quot;../../../api/javascript/each/index&quot;&gt;each&lt;/a&gt; command to iterate through the result set, or &lt;a href=&quot;../../../api/javascript/to_array/index&quot;&gt;toArray&lt;/a&gt; to retrieve the set as an array.</source>
          <target state="translated">&lt;code&gt;table&lt;/code&gt; 명령은 커서를 반환 사용 &lt;a href=&quot;../../../api/javascript/next/index&quot;&gt;옆&lt;/a&gt; 또는 &lt;a href=&quot;../../../api/javascript/each/index&quot;&gt;각&lt;/a&gt; 결과 집합을 반복하는 명령, 또는 &lt;a href=&quot;../../../api/javascript/to_array/index&quot;&gt;toArray는&lt;/a&gt; 배열로 집합을 검색.</target>
        </trans-unit>
        <trans-unit id="8555ee1c59461069384b1231faf6ed2e10256a2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeOf&lt;/code&gt; command can be appended to any ReQL command to display what data type that command will returns. For instance (in JavaScript):</source>
          <target state="translated">&lt;code&gt;typeOf&lt;/code&gt; 명령은 데이터가 해당 명령 것입니다 반환을 입력 한 내용을 디스플레이에 대한 ReQL 명령에 추가 할 수 있습니다. 예를 들어 (JavaScript에서) :</target>
        </trans-unit>
        <trans-unit id="e2c3fbf52c0a0225e096a3e3f50430c6f20043c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;update&lt;/code&gt; command allows changing existing fields in the document, as well as values inside of arrays. Let&amp;rsquo;s suppose Star Trek archaeologists unearthed a new speech by Jean-Luc Picard that we&amp;rsquo;d like to add to his posts:</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 명령은 배열의 내부에 존재하는 문서의 필드뿐만 아니라 값을 변경 허용한다. Star Trek 고고학자들이 Jean-Luc Picard가 그의 게시물에 추가하고 싶은 새로운 연설을 발굴했다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="f5c71b707545ed0fdcaeabb3a5aac3886c06f220" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;update&lt;/code&gt; command lets you to overwrite fields, but not delete them. If you want to delete a field, use the &lt;code&gt;replace&lt;/code&gt; command. The &lt;code&gt;replace&lt;/code&gt; command replaces your entire document with the new document you pass as an argument. For example, if you want to delete the field &lt;code&gt;author&lt;/code&gt; of the blog post with the id &lt;code&gt;1&lt;/code&gt;, you would use:</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 명령은 덮어 쓰기 필드를 수 있지만이를 삭제하지. 필드를 삭제하려면 &lt;code&gt;replace&lt;/code&gt; 명령을 사용하십시오 . &lt;code&gt;replace&lt;/code&gt; 명령은 인수로 전달하는 새 문서로 전체 문서를 대체합니다. 예를 들어, ID가 &lt;code&gt;1&lt;/code&gt; 인 블로그 게시물 의 필드 &lt;code&gt;author&lt;/code&gt; 를 삭제하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="25a4c3fb12182407ba2e67e16e8bc153a3fc6a94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;update&lt;/code&gt; command supports RethinkDB&amp;rsquo;s &lt;a href=&quot;../../../docs/nested-fields/javascript/index&quot;&gt;nested field&lt;/a&gt; syntax to update subdocuments. Consider a user table with contact information in this format:</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 명령은 RethinkDB의 지원 &lt;a href=&quot;../../../docs/nested-fields/javascript/index&quot;&gt;중첩 된 필드&lt;/a&gt; 업데이트 하위 문서에 구문을. 이 형식의 연락처 정보가있는 사용자 테이블을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="9709ed7ac5a3ccdb5608327426c040efa46a575b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;users&lt;/code&gt; table contains one document for each user in the system, each with two key/value pairs: a unique &lt;code&gt;id&lt;/code&gt; and a &lt;code&gt;password&lt;/code&gt; field. The &lt;code&gt;id&lt;/code&gt; is the account name. The &lt;code&gt;password&lt;/code&gt; field behaves differently on writes than on reads; you can change an account&amp;rsquo;s password by writing a value to this field (or remove the password by writing &lt;code&gt;false&lt;/code&gt;), but the password cannot be read. Instead, on a read operation &lt;code&gt;password&lt;/code&gt; will be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, indicating whether the account has a password or not.</source>
          <target state="translated">&lt;code&gt;users&lt;/code&gt; 고유 : 테이블은 시스템의 각 사용자에 대해 하나 개의 문서, 두 개의 키 / 값 쌍으로 각각 포함 &lt;code&gt;id&lt;/code&gt; 와 &lt;code&gt;password&lt;/code&gt; 필드. &lt;code&gt;id&lt;/code&gt; 계정 이름입니다. &lt;code&gt;password&lt;/code&gt; 필드는 읽기보다는 쓰기에 다르게 작동; 이 필드에 값을 작성하여 계정의 비밀번호를 변경하거나 ( &lt;code&gt;false&lt;/code&gt; 를 작성하여 비밀번호를 제거 ) 비밀번호를 읽을 수는 없습니다. 대신 읽기 작업 &lt;code&gt;password&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 이며 계정에 암호가 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="01c8bf644a4f9030d7ad2577d422c0cd9a38c6cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wait&lt;/code&gt; command takes two optional arguments:</source>
          <target state="translated">&lt;code&gt;wait&lt;/code&gt; 명령은 두 개의 선택적 인수를 :</target>
        </trans-unit>
        <trans-unit id="e2eaaabe02ee4500dead731d18d5ec0e845f4d2e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;map&lt;/strong&gt; step from above.</source>
          <target state="translated">&lt;strong&gt;맵&lt;/strong&gt; 위의 단계.</target>
        </trans-unit>
        <trans-unit id="2889c83235362d653b025be4c1c424ba1ce7d91e" translate="yes" xml:space="preserve">
          <source>The CSV delimiter defaults to the comma, but this can be overridden with the &lt;code&gt;--delimiter&lt;/code&gt; option. Use &lt;code&gt;--delimiter '\t'&lt;/code&gt; for a tab-delimited file.</source>
          <target state="translated">CSV 구분 기호의 기본값은 쉼표이지만 &lt;code&gt;--delimiter&lt;/code&gt; 옵션 으로 재정의 할 수 있습니다 . 탭으로 구분 된 파일에는 &lt;code&gt;--delimiter '\t'&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c6c8ae6aa468752854d01d185af510f328007df" translate="yes" xml:space="preserve">
          <source>The Data Explorer in the web administration UI is itself a JavaScript REPL, with syntax highlighting and history. (The article on &lt;a href=&quot;../reql-data-exploration/index&quot;&gt;ReQL data exploration&lt;/a&gt; goes into some detail on how to use the Data Explorer.) The advantage of scripting languages with ReQL comes into play when writing administration scripts.</source>
          <target state="translated">웹 관리 UI의 데이터 탐색기는 구문 강조 및 히스토리가있는 JavaScript REPL입니다. ( &lt;a href=&quot;../reql-data-exploration/index&quot;&gt;ReQL 데이터 탐색&lt;/a&gt; 에 대한 기사 는 데이터 탐색기 사용 방법에 대해 자세히 설명합니다.) 관리 스크립트를 작성할 때 ReQL과 함께 스크립팅 언어의 장점이 작용합니다.</target>
        </trans-unit>
        <trans-unit id="2921a82497eb6c2b10a8bb44faddbdf034525af2" translate="yes" xml:space="preserve">
          <source>The Data Explorer will return information about the inserted rows.</source>
          <target state="translated">데이터 탐색기는 삽입 된 행에 대한 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="17f8232887e712c610ded4c3b1ca09822b2f7852" translate="yes" xml:space="preserve">
          <source>The JSON-encoded &lt;code&gt;Response&lt;/code&gt; object</source>
          <target state="translated">JSON 인코딩 된 &lt;code&gt;Response&lt;/code&gt; 객체</target>
        </trans-unit>
        <trans-unit id="ae581c711fdded915ec6331d2e6201dc801ce45f" translate="yes" xml:space="preserve">
          <source>The JSON-encoded response</source>
          <target state="translated">JSON 인코딩 응답</target>
        </trans-unit>
        <trans-unit id="401226b470a193230b4f51fd65ea09e28b5975e5" translate="yes" xml:space="preserve">
          <source>The JavaScript and Python drivers support a convenience command, &lt;code&gt;row()&lt;/code&gt;, which simply returns the currently selected document for use with other ReQL functions in the query. However, &lt;code&gt;row&lt;/code&gt; won&amp;rsquo;t work within nested queries. The solution to this error is to rewrite the &lt;code&gt;row&lt;/code&gt; clause as an anonymous function. So the following:</source>
          <target state="translated">JavaScript 및 Python 드라이버는 편리한 명령 인 &lt;code&gt;row()&lt;/code&gt; 지원합니다.이 명령 은 쿼리에서 다른 ReQL 함수와 함께 사용하기 위해 현재 선택된 문서를 반환합니다. 그러나 중첩 된 쿼리 에서는 &lt;code&gt;row&lt;/code&gt; 이 작동하지 않습니다. 이 오류의 해결책은 &lt;code&gt;row&lt;/code&gt; 절을 익명 함수로 다시 작성하는 것입니다. 그래서 다음과 같이 :</target>
        </trans-unit>
        <trans-unit id="d93cb88766b967f3d6c02e56c626c06eefa41694" translate="yes" xml:space="preserve">
          <source>The JavaScript driver currently works with Node.js versions 0.10.0 and above. You can check your node version as follows:</source>
          <target state="translated">JavaScript 드라이버는 현재 Node.js 버전 0.10.0 이상에서 작동합니다. 다음과 같이 노드 버전을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e74f35f90936d1e818634cc6a9b8cc53ac18e27c" translate="yes" xml:space="preserve">
          <source>The NoBrainer generator automatically includes the &lt;a href=&quot;http://nobrainer.io/docs/timestamps&quot;&gt;TimeStamps&lt;/a&gt; mixin that adds the fields &lt;code&gt;created_on&lt;/code&gt; and &lt;code&gt;updated_on&lt;/code&gt;. You&amp;rsquo;ll also notice this created a simple secondary index on the &lt;code&gt;name&lt;/code&gt; field. In order to add the index to the database, you can use the Rake task:</source>
          <target state="translated">NoBrainer 생성기에는 &lt;code&gt;created_on&lt;/code&gt; 및 &lt;code&gt;updated_on&lt;/code&gt; 필드를 추가하는 &lt;a href=&quot;http://nobrainer.io/docs/timestamps&quot;&gt;TimeStamps&lt;/a&gt; 믹스 인이 자동으로 포함됩니다 . 또한 &lt;code&gt;name&lt;/code&gt; 필드 에 간단한 보조 인덱스가 생성되었음을 알 수 있습니다 . 데이터베이스에 색인을 추가하기 위해 Rake 태스크를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f78507d39aba2403ee6f13a4ffbdf2b02ac49261" translate="yes" xml:space="preserve">
          <source>The ReQL &lt;a href=&quot;../../api/javascript/grant/index&quot;&gt;grant&lt;/a&gt; command is used to grant and revoke permissions for users. The scope is selected by chaining &lt;code&gt;grant&lt;/code&gt; after &lt;code&gt;db&lt;/code&gt; (for database scope), &lt;code&gt;table&lt;/code&gt; (for table scope), or calling it directly (for global scope).</source>
          <target state="translated">ReQL &lt;a href=&quot;../../api/javascript/grant/index&quot;&gt;grant&lt;/a&gt; 명령은 사용자에게 권한을 부여하고 취소하는 데 사용됩니다. 범위는 &lt;code&gt;db&lt;/code&gt; (데이터베이스 범위의 경우), &lt;code&gt;table&lt;/code&gt; (테이블 범위의 경우) 또는 직접 호출 (글로벌 범위의 경우) 후에 &lt;code&gt;grant&lt;/code&gt; 를 연결하여 선택됩니다 .</target>
        </trans-unit>
        <trans-unit id="3deef836c1824d07b0b55b81f06b31f6cc374b4d" translate="yes" xml:space="preserve">
          <source>The RethinkDB AMI is preconfigured with the following options:</source>
          <target state="translated">RethinkDB AMI는 다음 옵션으로 사전 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f68f0cac323d8bd865cffdbd7126de4c860b2528" translate="yes" xml:space="preserve">
          <source>The RethinkDB Python driver integrates with both the &lt;a href=&quot;http://www.tornadoweb.org/&quot;&gt;Tornado web framework&lt;/a&gt; and the &lt;a href=&quot;http://twistedmatrix.com/&quot;&gt;Twisted networking engine&lt;/a&gt;. By using the &lt;a href=&quot;https://rethinkdb.com/api/python/set_loop_type&quot;&gt;set_loop_type&lt;/a&gt; command, you can select either the &lt;code&gt;'tornado'&lt;/code&gt; or &lt;code&gt;'twisted'&lt;/code&gt; event loop model, returning Tornado &lt;code&gt;Future&lt;/code&gt; objects or Twisted &lt;code&gt;Deferred&lt;/code&gt; objects respectively.</source>
          <target state="translated">RethinkDB Python 드라이버는 &lt;a href=&quot;http://www.tornadoweb.org/&quot;&gt;Tornado 웹 프레임 워크&lt;/a&gt; 및 &lt;a href=&quot;http://twistedmatrix.com/&quot;&gt;Twisted 네트워킹 엔진&lt;/a&gt; 과 통합됩니다 . &lt;a href=&quot;https://rethinkdb.com/api/python/set_loop_type&quot;&gt;set_loop_type&lt;/a&gt; 명령 을 사용하면 &lt;code&gt;'tornado'&lt;/code&gt; 또는 &lt;code&gt;'twisted'&lt;/code&gt; 이벤트 루프 모델을 선택하여 각각 Tornado &lt;code&gt;Future&lt;/code&gt; 객체 또는 Twisted &lt;code&gt;Deferred&lt;/code&gt; 객체를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1887d58aefbe9cd201c7569b6def6f9b46a2192" translate="yes" xml:space="preserve">
          <source>The RethinkDB Ruby driver adds a new ReQL command, &lt;a href=&quot;https://rethinkdb.com/api/ruby/em_run&quot;&gt;em_run&lt;/a&gt;, designed to work with &lt;a href=&quot;http://rubyeventmachine.com&quot;&gt;EventMachine&lt;/a&gt;. In addition, it provides a superclass, &lt;code&gt;RethinkDB::Handler&lt;/code&gt;, with event-specific methods (e.g., &lt;code&gt;on_open&lt;/code&gt;, &lt;code&gt;on_close&lt;/code&gt;) that may be overridden by a class your application defines and passes to &lt;code&gt;em_run&lt;/code&gt;.</source>
          <target state="translated">RethinkDB 루비 드라이버는 새로운 ReQL 명령, 추가 &lt;a href=&quot;https://rethinkdb.com/api/ruby/em_run&quot;&gt;em_run&lt;/a&gt; 와 함께 작동하도록 설계, &lt;a href=&quot;http://rubyeventmachine.com&quot;&gt;EventMachine을&lt;/a&gt; . 또한 응용 프로그램이 정의하고 &lt;code&gt;em_run&lt;/code&gt; 으로 전달하는 클래스에 의해 재정의 될 수있는 이벤트 별 메서드 (예 : &lt;code&gt;on_open&lt;/code&gt; , &lt;code&gt;on_close&lt;/code&gt; ) 와 함께 수퍼 클래스 &lt;code&gt;RethinkDB::Handler&lt;/code&gt; 를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="cb928e983992a16cf85ee7c757c4a76ce7b98a95" translate="yes" xml:space="preserve">
          <source>The RethinkDB command line utility allows you to easily take hot backups on a live cluster with the &lt;code&gt;dump&lt;/code&gt; and &lt;code&gt;restore&lt;/code&gt; subcommands. The utility runs under the &lt;code&gt;admin&lt;/code&gt; user account (see &lt;a href=&quot;../permissions-and-accounts/index&quot;&gt;Permissions and user accounts&lt;/a&gt;).</source>
          <target state="translated">RethinkDB 명령 줄 유틸리티를 사용하면 &lt;code&gt;dump&lt;/code&gt; 및 &lt;code&gt;restore&lt;/code&gt; 하위 명령 을 사용하여 활성 클러스터에서 핫 백업을 쉽게 수행 할 수 있습니다 . 이 유틸리티는 &lt;code&gt;admin&lt;/code&gt; 계정으로 실행 됩니다 ( &lt;a href=&quot;../permissions-and-accounts/index&quot;&gt;권한 및 사용자 계정&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="56cccb51dd81c41e2a73448104ab42e75c1bf07f" translate="yes" xml:space="preserve">
          <source>The Tables</source>
          <target state="translated">테이블</target>
        </trans-unit>
        <trans-unit id="b73116bcd937f8234ed2fae850b17a96ef62cc32" translate="yes" xml:space="preserve">
          <source>The above structure is functionally identical to:</source>
          <target state="translated">위의 구조는 기능적으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7be08bdb688785dbc0b51a07a4d14e27d4297a6f" translate="yes" xml:space="preserve">
          <source>The admin account</source>
          <target state="translated">관리자 계정</target>
        </trans-unit>
        <trans-unit id="bd4b50bb6475112f6456711fd2e86904fd04ed69" translate="yes" xml:space="preserve">
          <source>The admin user</source>
          <target state="translated">관리자</target>
        </trans-unit>
        <trans-unit id="c49266cd9dfe06ccf934b0d6a03045039f4b9596" translate="yes" xml:space="preserve">
          <source>The asynchronous database API allows you to handle multiple changefeeds simultaneously by running multiple background tasks. As an example, consider this changefeed handler:</source>
          <target state="translated">비동기 데이터베이스 API를 사용하면 여러 백그라운드 작업을 실행하여 여러 변경 피드를 동시에 처리 할 수 ​​있습니다. 예를 들어, 다음 변경 피드 핸들러를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="74d2dd939eb0d6439399f983d97cb288040a44ea" translate="yes" xml:space="preserve">
          <source>The asynchronous database API allows you to handle multiple changefeeds simultaneously by scheduling background coroutines. As an example, consider this changefeed handler:</source>
          <target state="translated">비동기 데이터베이스 API를 사용하면 백그라운드 코 루틴을 예약하여 여러 변경 피드를 동시에 처리 할 수 ​​있습니다. 예를 들어, 다음 변경 피드 핸들러를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="519ebcd651eb55bc4130940c4263b3c1d13577fa" translate="yes" xml:space="preserve">
          <source>The automatically chosen cache size ensures a reliable operation in most scenarios, but the cache size can be tuned manually to accommodate increased memory usage by other processes or to maximize query performance. A larger cache improves the database&amp;rsquo;s performance, but you must consider other sources of memory consumption to avoid out of memory conditions.</source>
          <target state="translated">자동으로 선택된 캐시 크기는 대부분의 시나리오에서 안정적인 작동을 보장하지만 다른 프로세스의 메모리 사용량 증가를 수용하거나 쿼리 성능을 최대화하기 위해 캐시 크기를 수동으로 조정할 수 있습니다. 캐시가 클수록 데이터베이스 성능이 향상되지만 메모리 부족 상태를 피하려면 다른 메모리 소비 소스를 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="01e374f6277f44b97e1222377bc67dde6a9c6976" translate="yes" xml:space="preserve">
          <source>The backtrace from the crash, if it&amp;rsquo;s available in the logs.</source>
          <target state="translated">로그에서 사용 가능한 경우 충돌의 역 추적.</target>
        </trans-unit>
        <trans-unit id="713ad2f29426066c8fb98399dc92a553f0434ed4" translate="yes" xml:space="preserve">
          <source>The basic rule is:</source>
          <target state="translated">기본 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a4675c5be848d511ac96d9c2063be8e951d3254f" translate="yes" xml:space="preserve">
          <source>The basic setup is complete&amp;mdash;&lt;strong&gt;you&amp;rsquo;ve now got a working server!&lt;/strong&gt;</source>
          <target state="translated">기본 설정이 완료되었습니다. &lt;strong&gt;이제 서버가 작동합니다!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aa6fd40233d0f51b4739f7f3b630ae6b5e237c7d" translate="yes" xml:space="preserve">
          <source>The best way to secure a RethinkDB cluster is to run it on a protected network that doesn&amp;rsquo;t allow access from the outside world. However, this may not always be feasible. For example, cloud deployments often require access from wide area networks.</source>
          <target state="translated">RethinkDB 클러스터를 보호하는 가장 좋은 방법은 외부 세계에서 액세스 할 수없는 보호 된 네트워크에서 클러스터를 실행하는 것입니다. 그러나 이것이 항상 실현 가능한 것은 아닙니다. 예를 들어 클라우드 배포에는 종종 광역 네트워크의 액세스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8a6a0b311a15c9d3de4c39c35a42e039d165be26" translate="yes" xml:space="preserve">
          <source>The body of every &lt;a href=&quot;../filter/index&quot;&gt;filter&lt;/a&gt; is wrapped in an implicit &lt;code&gt;.default(false)&lt;/code&gt;. You can overwrite the value &lt;code&gt;false&lt;/code&gt; with the &lt;code&gt;default&lt;/code&gt; option.</source>
          <target state="translated">모든 &lt;a href=&quot;../filter/index&quot;&gt;필터&lt;/a&gt; 의 본문은 암시 적 &lt;code&gt;.default(false)&lt;/code&gt; 싸여 있습니다. 당신은 값을 덮어 쓸 수 있습니다 &lt;code&gt;false&lt;/code&gt; 와 &lt;code&gt;default&lt;/code&gt; 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="fe5a7c4ac68bb0098f4c7acbfa8d3521ed65b4f3" translate="yes" xml:space="preserve">
          <source>The calls above only return a few dozen stargazers while RethinkDB has thousands. Most APIs paginate large result sets and GitHub is no exception. The &lt;code&gt;r.http&lt;/code&gt; command has built-in support for pagination via the &lt;code&gt;page&lt;/code&gt; and &lt;code&gt;pageLimit&lt;/code&gt; arguments. Let&amp;rsquo;s get ten pages of stargazers from GitHub instead of one:</source>
          <target state="translated">RethinkDB에는 수천 개의 스타 게이저가 있지만 위의 호출은 수십 개의 별개 만 반환합니다. 대부분의 API는 큰 결과 집합을 페이지 매김하고 GitHub도 예외는 아닙니다. &lt;code&gt;r.http&lt;/code&gt; 의 명령을 내장 한을 통해 매김 지원 &lt;code&gt;page&lt;/code&gt; 및 &lt;code&gt;pageLimit&lt;/code&gt; 의 인수. GitHub에서 1 페이지 대신 10 페이지의 스타 게이저를 가져 오겠습니다.</target>
        </trans-unit>
        <trans-unit id="c66da8d1fa6ce80f3799528d078f5270ec96090d" translate="yes" xml:space="preserve">
          <source>The center may be specified either by two floating point numbers, the latitude (&amp;minus;90 to 90) and longitude (&amp;minus;180 to 180) of the point on a perfect sphere (see &lt;a href=&quot;../../../docs/geo-support/javascript/index&quot;&gt;Geospatial support&lt;/a&gt; for more information on ReQL&amp;rsquo;s coordinate system), or by a point object. The radius is a floating point number whose units are meters by default, although that may be changed with the &lt;code&gt;unit&lt;/code&gt; argument.</source>
          <target state="translated">중심은 완벽한 구에서 점의 위도 (&amp;minus;90 ~ 90)와 경도 (&amp;minus;180 ~ 180)의 두 부동 소수점 숫자로 지정하거나 ( ReQL 좌표계에 대한 자세한 내용 은 &lt;a href=&quot;../../../docs/geo-support/javascript/index&quot;&gt;지리 공간 지원&lt;/a&gt; 참조 ) 포인트 객체. 반지름은 기본적으로 미터 단위의 부동 소수점 숫자이지만 &lt;code&gt;unit&lt;/code&gt; 인수 로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e51cfd64d4a242d067b7d8103f85064dab48e6f1" translate="yes" xml:space="preserve">
          <source>The classic chat with Node.js.</source>
          <target state="translated">Node.js와의 클래식 채팅.</target>
        </trans-unit>
        <trans-unit id="4a08ba537a6bb6b6e0207beb1bd8c225b336d162" translate="yes" xml:space="preserve">
          <source>The client drivers do a lot of work to inspect the code and convert it to an efficient ReQL query that will be executed on the server:</source>
          <target state="translated">클라이언트 드라이버는 코드를 검사하고 서버에서 실행될 효율적인 ReQL 쿼리로 변환하기 위해 많은 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="fd0e48d480584e226bdbfe1b39b400ad644d5c44" translate="yes" xml:space="preserve">
          <source>The client sends the &amp;ldquo;magic number&amp;rdquo; (&lt;code&gt;0x34c2bdc3&lt;/code&gt;) for the protocol version, as a 32-bit little-endian integer (4 bytes).</source>
          <target state="translated">클라이언트는 프로토콜 버전에 대한 &quot;마법 번호&quot;( &lt;code&gt;0x34c2bdc3&lt;/code&gt; )를 32 비트 리틀 엔디안 정수 (4 바이트)로 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="a0cfe67e46bd1330804a94bb469638f0249ededc" translate="yes" xml:space="preserve">
          <source>The client sends the null-terminated JSON &amp;ldquo;client-final-message&amp;rdquo; with the same nonce and the ClientProof computed as specified by the RFC.</source>
          <target state="translated">클라이언트는 널 (null)로 끝나는 JSON &quot;client-final-message&quot;를 동일한 nonce와 함께 보내고 RFC에서 지정한대로 ClientProof를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="02a49fdc9855f3f674aee23d74d2e1ea07fdd5ec" translate="yes" xml:space="preserve">
          <source>The client sends the protocol version, authentication method, and authentication as a null-terminated JSON response. RethinkDB currently supports only one authentication method, &lt;code&gt;SCRAM-SHA-256&lt;/code&gt;, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc7677&quot;&gt;IETF RFC 7677&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc5802&quot;&gt;RFC 5802&lt;/a&gt;. The RFC is followed with the exception of error handling (RethinkDB uses its own higher level error reporting rather than the &lt;code&gt;e=&lt;/code&gt; field). RethinkDB does not support channel binding and clients should not request this. The value of &lt;code&gt;&quot;authentication&quot;&lt;/code&gt; is the &amp;ldquo;client-first-message&amp;rdquo; specified in RFC 5802 (the channel binding flag, optional SASL authorization identity, username (&lt;code&gt;n=&lt;/code&gt;), and random nonce (&lt;code&gt;r=&lt;/code&gt;).</source>
          <target state="translated">클라이언트는 프로토콜 버전, 인증 방법 및 인증을 null로 끝나는 JSON 응답으로 보냅니다. RethinkDB는 현재 &lt;a href=&quot;https://tools.ietf.org/html/rfc7677&quot;&gt;IETF RFC 7677&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc5802&quot;&gt;RFC 5802에&lt;/a&gt; 지정된 하나의 인증 방법 인 &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; 만 지원합니다 . RFC는 오류 처리를 제외하고 따릅니다 (RethinkDB는 &lt;code&gt;e=&lt;/code&gt; 필드가 아닌 고유 한 상위 오류보고를 사용 합니다). RethinkDB는 채널 바인딩을 지원하지 않으므로 클라이언트는이를 요청해서는 안됩니다. &lt;code&gt;&quot;authentication&quot;&lt;/code&gt; 의 값은 RFC 5802 (채널 바인딩 플래그, 선택적 SASL 인증 ID, 사용자 이름 ( &lt;code&gt;n=&lt;/code&gt; ) 및 임의 nonce ( &lt;code&gt;r=&lt;/code&gt; )에 지정된 &quot;클라이언트 우선 메시지&quot; 입니다.</target>
        </trans-unit>
        <trans-unit id="0a84a6d65e8a3295aa13f3589f630b727d114e51" translate="yes" xml:space="preserve">
          <source>The cluster configuration is &lt;em&gt;not&lt;/em&gt; exported in backup. After a full restore, it will need to be manually reconfigured.</source>
          <target state="translated">클러스터 구성은 백업으로 내보내 &lt;em&gt;지지 않습니다&lt;/em&gt; . 전체 복원 후에는 수동으로 재구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="3780ae988b6b36953e49487d4455ef2b6bdb38c3" translate="yes" xml:space="preserve">
          <source>The cluster must have three or more servers</source>
          <target state="translated">클러스터에는 세 개 이상의 서버가 있어야합니다</target>
        </trans-unit>
        <trans-unit id="632b0a977c5ac1169440868320737c67d0be367c" translate="yes" xml:space="preserve">
          <source>The configuration file&amp;rsquo;s location depends on the startup system your distribution uses. A configuration file may also be specified on the command line with the &lt;code&gt;--config-file&lt;/code&gt; option.</source>
          <target state="translated">구성 파일의 위치는 배포에서 사용하는 시작 시스템에 따라 다릅니다. 명령 줄에서 &lt;code&gt;--config-file&lt;/code&gt; 옵션을 사용하여 구성 파일을 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d57968bb10f1a8ee059f9f4fabbd5506039b2ce" translate="yes" xml:space="preserve">
          <source>The conflicting field is &lt;code&gt;id&lt;/code&gt;. If you directly use the &lt;code&gt;zip&lt;/code&gt; command, the &lt;code&gt;id&lt;/code&gt; field of the result will be the one from the company. There are three ways to resolve potential field conflicts.</source>
          <target state="translated">충돌하는 필드는 &lt;code&gt;id&lt;/code&gt; 입니다. &lt;code&gt;zip&lt;/code&gt; 명령 을 직접 사용하는 경우 결과 의 &lt;code&gt;id&lt;/code&gt; 필드는 회사 의 id 필드입니다. 잠재적 인 필드 충돌을 해결하는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="41a66fdd8d9de0bac5ea2260645056298020b2b8" translate="yes" xml:space="preserve">
          <source>The contact information is &lt;em&gt;nested,&lt;/em&gt; like paths in a file system.</source>
          <target state="translated">연락처 정보는 파일 시스템의 경로와 같이 &lt;em&gt;중첩&lt;/em&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="46e1e4bcb0e4603cd6cff58253ffb59a537fc94c" translate="yes" xml:space="preserve">
          <source>The core file, if it was dumped on crash</source>
          <target state="translated">충돌시 덤프 된 코어 파일</target>
        </trans-unit>
        <trans-unit id="ba97166dc1556a5cdbc1fb0a9720d0a77462db53" translate="yes" xml:space="preserve">
          <source>The current issues table is one of the &lt;a href=&quot;../system-tables/index&quot;&gt;system tables&lt;/a&gt; added in version 1.16 of RethinkDB. Querying it returns problems detected within the cluster; in normal, error-free operation, it will remain empty. The table is read-only.</source>
          <target state="translated">현재 이슈 테이블은 RethinkDB 버전 1.16에 추가 된 &lt;a href=&quot;../system-tables/index&quot;&gt;시스템 테이블&lt;/a&gt; 중 하나입니다 . 쿼리하면 클러스터 내에서 감지 된 문제가 반환됩니다. 정상적인 오류없는 작동에서는 비어 있습니다. 테이블이 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="9e81558969cd0f2524d236b46d01319070689378" translate="yes" xml:space="preserve">
          <source>The data files if RethinkDB cannot restart&amp;sup1;</source>
          <target state="translated">RethinkDB를 재시작 할 수없는 경우 데이터 파일 &amp;sup1;</target>
        </trans-unit>
        <trans-unit id="25aadde4cb61338d8bafe72ae41695aff82a3946" translate="yes" xml:space="preserve">
          <source>The data is often colocated on disk. If you have a dataset that doesn&amp;rsquo;t fit into RAM, data is loaded from disk faster.</source>
          <target state="translated">데이터는 종종 디스크에 배치됩니다. RAM에 맞지 않는 데이터 세트가있는 경우 디스크에서 데이터가 더 빨리로드됩니다.</target>
        </trans-unit>
        <trans-unit id="432d68834696a4171c465fcdf29cc3b60b18ac02" translate="yes" xml:space="preserve">
          <source>The data is organized into B-Trees, and stored on disk using a log-structured storage engine built specifically for RethinkDB and inspired by the architecture of BTRFS. The storage engine has a number of benefits over other available options, including an incremental, fully concurrent garbage compactor, low CPU overhead and very efficient multicore operation, a number of SSD optimizations, instantaneous recovery after power failure, full data consistency in case of failures, and support for multiversion concurrency control.</source>
          <target state="translated">데이터는 B-Tree로 구성되며 RethinkDB를 위해 특별히 제작되고 BTRFS의 아키텍처에서 영감을 얻은 로그 구조의 스토리지 엔진을 사용하여 디스크에 저장됩니다. 스토리지 엔진은 증분 완전 동시 가비지 컴팩 터, 낮은 CPU 오버 헤드 및 매우 효율적인 멀티 코어 운영, 다수의 SSD 최적화, 정전 후 즉각적인 복구, 장애 발생시 전체 데이터 일관성 등 다른 사용 가능한 옵션에 비해 많은 이점을 제공합니다. 다중 버전 동시성 제어를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ca3fd25b569c562f5c89d32cc20220b1580eb52d" translate="yes" xml:space="preserve">
          <source>The data set generated by YCSB consists of 25 million documents, sized at 1 KB each. All data fits into the server cache in this scenario.</source>
          <target state="translated">YCSB가 생성 한 데이터 세트는 각각 1KB 크기의 2500 만 개의 문서로 구성됩니다. 이 시나리오에서는 모든 데이터가 서버 캐시에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="d6f5c132a6c8fcdd7afd1c8bae8bfba8ab30a7d1" translate="yes" xml:space="preserve">
          <source>The default security group opens 4 ports:</source>
          <target state="translated">기본 보안 그룹은 4 개의 포트를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="f19e6a7695718d0586846f66bc593da2a988d29b" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is with the &lt;code&gt;openssl&lt;/code&gt; command line tool. (Under Linux and OS X, this is already installed; for Windows, you may be able to find &lt;a href=&quot;https://wiki.openssl.org/index.php/Binaries&quot;&gt;precompiled binaries&lt;/a&gt; from the list on the OpenSSL wiki.)</source>
          <target state="translated">가장 쉬운 방법은 &lt;code&gt;openssl&lt;/code&gt; 명령 줄 도구를 사용하는 것입니다. (Linux 및 OS X에서는 이미 설치되어 있습니다. Windows의 경우 OpenSSL 위키의 목록에서 &lt;a href=&quot;https://wiki.openssl.org/index.php/Binaries&quot;&gt;사전 컴파일 된 바이너리&lt;/a&gt; 를 찾을 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="f6f1812991e1cc3c581617dbd4daebc446ccc185" translate="yes" xml:space="preserve">
          <source>The easiest way to rename a database is to use the &lt;a href=&quot;../../../api/javascript/config/index&quot;&gt;config&lt;/a&gt; command to access the &lt;code&gt;db_config&lt;/code&gt;&lt;a href=&quot;../../system-tables/index&quot;&gt;system table&lt;/a&gt;, and then simply use the &lt;code&gt;update&lt;/code&gt; command.</source>
          <target state="translated">데이터베이스 이름을 바꾸는 가장 쉬운 방법은 &lt;a href=&quot;../../../api/javascript/config/index&quot;&gt;config&lt;/a&gt; 명령을 사용하여 &lt;code&gt;db_config&lt;/code&gt; &lt;a href=&quot;../../system-tables/index&quot;&gt;시스템 테이블&lt;/a&gt; 에 액세스 한 다음 &lt;code&gt;update&lt;/code&gt; 명령을 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="89bd55fcff5767ef7274bfe1e8ce0c5c79f0d4ff" translate="yes" xml:space="preserve">
          <source>The easiest way to use RethinkDB with EventMachine is simply by passing a block to &lt;code&gt;em_run&lt;/code&gt;. If RethinkDB returns a sequence (including a stream), the block will be called once with each element of the sequence. Otherwise, the block will be called just once with the returned value.</source>
          <target state="translated">EventMachine에서 RethinkDB를 사용하는 가장 쉬운 방법은 em_run에 블록을 전달하는 &lt;code&gt;em_run&lt;/code&gt; 입니다. RethinkDB가 시퀀스 (스트림 포함)를 반환하면 시퀀스의 각 요소와 함께 블록이 한 번 호출됩니다. 그렇지 않으면 반환 된 값으로 블록이 한 번만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e8f5bff35a4c9660e74c3c9c467c02d19d234371" translate="yes" xml:space="preserve">
          <source>The entire query on the exchange is:</source>
          <target state="translated">교환에 대한 전체 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7872f9fb3324da93dd0fa2f2d9cad699581f3968" translate="yes" xml:space="preserve">
          <source>The equivalent query with the &lt;code&gt;each&lt;/code&gt; command would be:</source>
          <target state="translated">&lt;code&gt;each&lt;/code&gt; 명령에 해당하는 쿼리는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="97251998b6e48bd65cb3a5f03d2385e3f4ad6124" translate="yes" xml:space="preserve">
          <source>The essential tradeoff exposed by the CAP theorem is this: in case of network partitioning, does the system maintain availability or data consistency? (Jumping ahead, RethinkDB chooses to maintain data consistency).</source>
          <target state="translated">CAP 정리에 의해 드러난 필수 트레이드 오프는 다음과 같습니다. 네트워크 파티셔닝의 경우 시스템이 가용성 또는 데이터 일관성을 유지합니까? (앞으로 RethinkDB는 데이터 일관성을 유지하기로 결정했습니다).</target>
        </trans-unit>
        <trans-unit id="ffdbbb7e20b2915b198b1869df59132f308dec83" translate="yes" xml:space="preserve">
          <source>The example documentation includes a &lt;a href=&quot;https://github.com/rethinkdb/example-pubsub/blob/master/javascript/demo.js'&quot;&gt;demo script&lt;/a&gt; that shows off the three topic patterns described above. The script implements both a publisher and a subscriber with each pattern type. You can use this script to try out multiple publishers and multiple subscribers to test out how it works.</source>
          <target state="translated">예제 문서에는 위에서 설명한 세 가지 주제 패턴을 보여주는 &lt;a href=&quot;https://github.com/rethinkdb/example-pubsub/blob/master/javascript/demo.js'&quot;&gt;데모 스크립트&lt;/a&gt; 가 포함되어 있습니다. 이 스크립트는 각 패턴 유형으로 게시자와 가입자를 모두 구현합니다. 이 스크립트를 사용하여 여러 게시자와 여러 구독자를 사용해보고 작동 방식을 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9edfaf70b3165d1edeb4b2ca333e0e5c7f12d86f" translate="yes" xml:space="preserve">
          <source>The field &lt;code&gt;left&lt;/code&gt; contains the information from the left table in the query (in this case, the employee)</source>
          <target state="translated">&lt;code&gt;left&lt;/code&gt; 필드 에는 쿼리에서 왼쪽 테이블의 정보 (이 경우 직원)가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9c8dc7c54d50cbb27b2e5e50ed222c7c1bcabb6f" translate="yes" xml:space="preserve">
          <source>The field &lt;code&gt;right&lt;/code&gt; contains the information from the right table in the query (in this case, the company)</source>
          <target state="translated">&lt;code&gt;right&lt;/code&gt; 필드 에는 쿼리의 오른쪽 테이블 (이 경우 회사)의 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5ca20f66475f57f24716ce5a447518106f391982" translate="yes" xml:space="preserve">
          <source>The field name can be determined entirely on the server, too. For instance, to update a field whose name is drawn from the value of another field:</source>
          <target state="translated">필드 이름은 서버에서도 완전히 결정할 수 있습니다. 예를 들어, 다른 필드의 값에서 이름이 그려진 필드를 업데이트하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="58a69ccf3b964eb9485bcdd26e8c05306cda5c74" translate="yes" xml:space="preserve">
          <source>The file system it&amp;rsquo;s using</source>
          <target state="translated">사용중인 파일 시스템</target>
        </trans-unit>
        <trans-unit id="26add78546ea5b911c7f22338e8d01f8bc519e6c" translate="yes" xml:space="preserve">
          <source>The file uses a simple format of &lt;code&gt;key=value&lt;/code&gt;, with one key specified per line. A simple configuration file that uses the default ports, assigns a server to a virtual group using server tags and joins an existing cluster might be:</source>
          <target state="translated">파일은 한 줄에 하나의 키가 지정된 간단한 형식의 &lt;code&gt;key=value&lt;/code&gt; 를 사용합니다. 기본 포트를 사용하고 서버 태그를 사용하여 가상 그룹에 서버를 할당하고 기존 클러스터에 참여하는 간단한 구성 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="967d896d236ec1fb0a5af483a32f7ac64a4a217d" translate="yes" xml:space="preserve">
          <source>The final reduction step is executed to combine the values of the two shards. Instead of computing &lt;code&gt;4 + 6&lt;/code&gt;, the query executes &lt;code&gt;4 + 1&lt;/code&gt;.</source>
          <target state="translated">최종 감소 단계는 두 샤드의 값을 결합하기 위해 실행됩니다. 쿼리는 &lt;code&gt;4 + 6&lt;/code&gt; 을 계산하는 대신 &lt;code&gt;4 + 1&lt;/code&gt; 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="21c10050daac2ef80e360f5105e9b0c7210bb045" translate="yes" xml:space="preserve">
          <source>The first function increments the accumulator each time it&amp;rsquo;s called, starting at &lt;code&gt;0&lt;/code&gt;; the second function, the emitting function, alternates between returning a single-item list containing the current row or an empty list. The &lt;code&gt;fold&lt;/code&gt; command will return a concatenated list of each emitted value.</source>
          <target state="translated">첫 번째 함수는 &lt;code&gt;0&lt;/code&gt; 에서 시작하여 호출 될 때마다 누산기를 증가시킵니다 . 두 번째 함수 인 발광 함수는 현재 행을 포함하는 단일 항목 목록을 리턴하거나 빈 목록을 번갈아 가며 번갈아 표시합니다. &lt;code&gt;fold&lt;/code&gt; 명령은 각 출사 가치 연결된 목록을 반환한다.</target>
        </trans-unit>
        <trans-unit id="c8fd60f1adeaf3727bc4bf3fdd3883868eaa6238" translate="yes" xml:space="preserve">
          <source>The first layer implements the distributed infrastructure, placing copies of data on specific servers, routing queries, etc.</source>
          <target state="translated">첫 번째 계층은 분산 인프라를 구현하여 특정 서버에 데이터 사본을 배치하고 쿼리를 라우팅합니다.</target>
        </trans-unit>
        <trans-unit id="11ba98d6b6cd3aa5da8ea438eaebfebb10f6c61a" translate="yes" xml:space="preserve">
          <source>The first time you call an &lt;code&gt;EventEmitter&lt;/code&gt; method, the cursor or feed will emit data just after the I/O events callbacks and before &lt;code&gt;setTimeout&lt;/code&gt; and &lt;code&gt;setInterval&lt;/code&gt; callbacks.</source>
          <target state="translated">&lt;code&gt;EventEmitter&lt;/code&gt; 메소드를 처음 호출 할 때 커서 또는 피드는 I / O 이벤트 콜백 직후 및 &lt;code&gt;setTimeout&lt;/code&gt; 및 &lt;code&gt;setInterval&lt;/code&gt; 콜백 전에 데이터를 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="9d3e834a06be3d4a966b74e6eddbe6ce25aed60f" translate="yes" xml:space="preserve">
          <source>The first, required function passed to &lt;code&gt;eachAsync&lt;/code&gt; takes either one or two functions as arguments. The first is a callback to process each row as it is emitted; the second is an optional callback which will be executed when all row processing is completed.</source>
          <target state="translated">&lt;code&gt;eachAsync&lt;/code&gt; 에 전달 된 첫 번째 필수 함수는 하나 또는 두 개의 함수를 인수로 사용합니다. 첫 번째는 각 행이 방출 될 때 처리하는 콜백입니다. 두 번째는 모든 행 처리가 완료 될 때 실행될 선택적 콜백입니다.</target>
        </trans-unit>
        <trans-unit id="f77e0ba8b65283ab2e514276f940a158831a2d01" translate="yes" xml:space="preserve">
          <source>The following browsers are supported and known to work with the web UI:</source>
          <target state="translated">다음 브라우저가 지원되며 웹 UI에서 작동하는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="3df000274781b42d95e5cd8f246c23c4e2ddf8e2" translate="yes" xml:space="preserve">
          <source>The following command will output the contents of &lt;em&gt;all&lt;/em&gt; the configuration/status tables as well as the most recent 50 lines of the &lt;code&gt;logs&lt;/code&gt; table:</source>
          <target state="translated">다음 명령은 &lt;em&gt;모든&lt;/em&gt; 구성 / 상태 테이블 의 내용과 &lt;code&gt;logs&lt;/code&gt; 테이블 의 최신 50 행을 출력 합니다.</target>
        </trans-unit>
        <trans-unit id="e980e576b3cf9e71a983706b28a74a69507c5ca2" translate="yes" xml:space="preserve">
          <source>The following commands can be distributed across shards:</source>
          <target state="translated">다음 명령을 샤드에 분산시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23607390bcdf5106a17d091ec59afc6366ef93aa" translate="yes" xml:space="preserve">
          <source>The following fields are always present in this object:</source>
          <target state="translated">이 필드에는 항상 다음 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fa7d560043390f25c44226fb5ceef0d02b7d4e2" translate="yes" xml:space="preserve">
          <source>The format of the array returned by &lt;code&gt;ungroup&lt;/code&gt; is the same as the default native format of grouped data in the javascript driver and data explorer.</source>
          <target state="translated">&lt;code&gt;ungroup&lt;/code&gt; 에 의해 반환 된 배열의 형식은 자바 스크립트 드라이버 및 데이터 탐색기에서 그룹화 된 데이터의 기본 고유 형식과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6ea8b9bda562c3a2c267fd13344c22561590ebae" translate="yes" xml:space="preserve">
          <source>The full list of &lt;code&gt;QueryType&lt;/code&gt; values is as follows:</source>
          <target state="translated">&lt;code&gt;QueryType&lt;/code&gt; 값 의 전체 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="475b97f4658238ce4d91f9f9f592b520513498e2" translate="yes" xml:space="preserve">
          <source>The full output from &lt;code&gt;rethinkdb --version&lt;/code&gt;, something like:</source>
          <target state="translated">&lt;code&gt;rethinkdb --version&lt;/code&gt; 의 전체 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14769e9184ffc530cac63e2fae1484534e1ee52b" translate="yes" xml:space="preserve">
          <source>The full output from &lt;code&gt;uname -a&lt;/code&gt;, something like:</source>
          <target state="translated">&lt;code&gt;uname -a&lt;/code&gt; 의 전체 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="69129d2da31b2f07b7562ea61774addc8ca3fc5c" translate="yes" xml:space="preserve">
          <source>The full query execution process is fairly complex and nuanced. For example, some operations cannot be parallelized, some queries cannot be executed lazily (which has implications on runtime and RAM usage), and implementations of some operations could be significantly improved. We will be adding tools to help visualize and understand query execution in a user-friendly way, but at the moment the best way to learn more about it is to ask us or to look at the code.</source>
          <target state="translated">전체 쿼리 실행 프로세스는 상당히 복잡하고 미묘합니다. 예를 들어 일부 작업을 병렬화 할 수없고 일부 쿼리를 느리게 실행할 수 없으며 (런타임 및 RAM 사용에 영향을 미침) 일부 작업의 구현을 크게 개선 할 수 있습니다. 쿼리 실행을 사용자에게 친숙한 방식으로 시각화하고 이해하는 데 도움이되는 도구를 추가 할 것입니다. 그러나 현재 이에 대해 자세히 알아 보는 가장 좋은 방법은 문의하거나 코드를 보는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c162ed1ca38301acb854f2294b911ec17da79f31" translate="yes" xml:space="preserve">
          <source>The full syntax for the &lt;code&gt;import&lt;/code&gt; command is as follows:</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 명령 의 전체 구문 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="deca2cf2857457188d6ef69f7a463144da27b999" translate="yes" xml:space="preserve">
          <source>The function would be serialized as:</source>
          <target state="translated">함수는 다음과 같이 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="5f7cae79892fe7f333ad65e3b8f50bdbc5bee557" translate="yes" xml:space="preserve">
          <source>The function you give to &lt;code&gt;indexCreate&lt;/code&gt; must be deterministic. In practice this means that that you cannot use a function that contains a sub-query or the &lt;code&gt;r.js&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;indexCreate&lt;/code&gt; 에 제공하는 함수는 결정적 이어야합니다. 실제로 이는 하위 쿼리 또는 &lt;code&gt;r.js&lt;/code&gt; 명령 이 포함 된 함수를 사용할 수 없음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="21bb40f02c679aca148c3514604ac102d9df5cab" translate="yes" xml:space="preserve">
          <source>The games table contains these documents:</source>
          <target state="translated">게임 테이블에는 다음 문서가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9fda65faa054c03a06f17658d0df4a9e5f090ac" translate="yes" xml:space="preserve">
          <source>The geospatial functions are implemented through a set of new geometric object data types:</source>
          <target state="translated">지리 공간 함수는 일련의 새로운 기하학적 객체 데이터 유형을 통해 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="66bf76a1e568737c42ee060cb4a10d8649ca86a7" translate="yes" xml:space="preserve">
          <source>The grant command</source>
          <target state="translated">부여 명령</target>
        </trans-unit>
        <trans-unit id="c5cc776f379421f9e0176920e32ec32956ce0ba2" translate="yes" xml:space="preserve">
          <source>The index must either be the primary key or have been previously created with &lt;a href=&quot;../index_create/index&quot;&gt;indexCreate&lt;/a&gt;.</source>
          <target state="translated">인덱스는 기본 키이거나 &lt;a href=&quot;../index_create/index&quot;&gt;indexCreate&lt;/a&gt; 로 이전에 작성되어 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="2495353fe68162175193be062922febe81792444" translate="yes" xml:space="preserve">
          <source>The index must have been previously created with &lt;a href=&quot;../index_create/index&quot;&gt;indexCreate&lt;/a&gt;.</source>
          <target state="translated">인덱스는 &lt;a href=&quot;../index_create/index&quot;&gt;indexCreate&lt;/a&gt; 로 이전에 작성되어 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="ca41c024d3d03398ad932fa456e6f47678274ff4" translate="yes" xml:space="preserve">
          <source>The init.d script supports starting multiple instances on the same server via multiple &lt;code&gt;.conf&lt;/code&gt; files in &lt;code&gt;/etc/rethinkdb/instances.d&lt;/code&gt;. This may be desirable for isolating databases for separate applications running on the same server, or for testing purposes. (There is no performance gain from running multiple nodes of the same cluster on the same physical machine.)</source>
          <target state="translated">init.d 스크립트는 &lt;code&gt;/etc/rethinkdb/instances.d&lt;/code&gt; 의 여러 &lt;code&gt;.conf&lt;/code&gt; 파일을 통해 동일한 서버에서 여러 인스턴스 시작을 지원합니다 . 동일한 서버에서 실행되는 별도의 응용 프로그램이나 테스트 목적으로 데이터베이스를 격리하는 데 바람직 할 수 있습니다. 동일한 물리적 시스템에서 동일한 클러스터의 여러 노드를 실행해도 성능이 향상되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ebf19d589643ec5b145f9f4331ef50a76004e07" translate="yes" xml:space="preserve">
          <source>The inner &lt;code&gt;map&lt;/code&gt; function is just being used to iterate through the items in each order. At this point, our query will return a list of objects, each object with three fields: &lt;code&gt;item_id&lt;/code&gt;, &lt;code&gt;quantity&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">내부 &lt;code&gt;map&lt;/code&gt; 기능은 각 주문에서 항목을 반복하는 데 사용됩니다. 이 시점에서 쿼리는 객체 목록을 반환합니다. 각 객체에는 &lt;code&gt;item_id&lt;/code&gt; , &lt;code&gt;quantity&lt;/code&gt; 및 &lt;code&gt;count&lt;/code&gt; 필드가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d932f3d62c38556feefc878504c15decd242c35" translate="yes" xml:space="preserve">
          <source>The inner &lt;code&gt;sum&lt;/code&gt; adds the scores by match within each document; the outer &lt;code&gt;sum&lt;/code&gt; adds those results together for a total across all the documents.</source>
          <target state="translated">내부 &lt;code&gt;sum&lt;/code&gt; 는 각 문서 내에서 점수를 일치시켜 추가합니다. 외부 &lt;code&gt;sum&lt;/code&gt; 는 이러한 결과를 모든 문서에 대한 합계로 더합니다.</target>
        </trans-unit>
        <trans-unit id="a30db86d4cd4223f11f528b78e8eaa37d415543e" translate="yes" xml:space="preserve">
          <source>The intracluster port will be accessible from within the local network where you run RethinkDB nodes, but will not be accessible from the outside world.</source>
          <target state="translated">클러스터 내 포트는 RethinkDB 노드를 실행하는 로컬 네트워크 내에서 액세스 할 수 있지만 외부에서는 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c6e6220488f98ca8b4a9e1814cfe64c223d59c09" translate="yes" xml:space="preserve">
          <source>The jobs table is one of the &lt;a href=&quot;../system-tables/index&quot;&gt;system tables&lt;/a&gt; added in version 1.16 of RethinkDB. It provides information about tasks running within the RethinkDB cluster, including queries, disk compaction, and index construction, and allows you to kill query jobs by deleting them from the table.</source>
          <target state="translated">작업 테이블은 RethinkDB 버전 1.16에 추가 된 &lt;a href=&quot;../system-tables/index&quot;&gt;시스템 테이블&lt;/a&gt; 중 하나입니다 . 쿼리, 디스크 압축 및 인덱스 구성을 포함하여 RethinkDB 클러스터 내에서 실행되는 작업에 대한 정보를 제공하며 테이블에서 쿼리 작업을 삭제하여 쿼리 작업을 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41b9718b6370d6926103658ff4576ee577670375" translate="yes" xml:space="preserve">
          <source>The keys in a multi index can be single values, compound values or even arbitrary expressions. (See the section below for more detail on indexes using functions.)</source>
          <target state="translated">다중 인덱스의 키는 단일 값, 복합 값 또는 임의의 표현식 일 수 있습니다. 함수를 사용한 인덱스에 대한 자세한 내용은 아래 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="82f9d489b67d40b5391cfe80f91d791cb7c19663" translate="yes" xml:space="preserve">
          <source>The language is easy to learn, read, and modify.</source>
          <target state="translated">언어는 배우고 읽고 수정하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="9d43b4d8b1ab557e528e7e44276c5ff362b9edeb" translate="yes" xml:space="preserve">
          <source>The last argument to &lt;code&gt;do&lt;/code&gt; (or, in some forms, the only argument) is an expression or an anonymous function which receives values from either the previous arguments or from prefixed commands chained before &lt;code&gt;do&lt;/code&gt;. The &lt;code&gt;do&lt;/code&gt; command is essentially a single-element &lt;a href=&quot;../map/index&quot;&gt;map&lt;/a&gt;, letting you map a function over just one document. This allows you to bind a query result to a local variable within the scope of &lt;code&gt;do&lt;/code&gt;, letting you compute the result just once and reuse it in a complex expression or in a series of ReQL commands.</source>
          <target state="translated">마지막으로 &lt;code&gt;do&lt;/code&gt; 인수 (또는 일부 형식에서 유일한 인수)는 이전 인수 또는 &lt;code&gt;do&lt;/code&gt; 앞에 연결된 접두사 명령에서 값을받는 표현식 또는 익명 함수입니다 . &lt;code&gt;do&lt;/code&gt; 명령은 기본적으로 단일 요소이다 &lt;a href=&quot;../map/index&quot;&gt;지도&lt;/a&gt; 당신이 기능을 통해 하나의 문서를 매핑시키는. 이를 통해 쿼리 결과를 &lt;code&gt;do&lt;/code&gt; 범위 내의 로컬 변수에 바인딩하여 결과를 한 번만 계산하여 복잡한 표현식이나 일련의 ReQL 명령에서 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1b83f2f20d6e27211b3484dd80a4271132f9fba" translate="yes" xml:space="preserve">
          <source>The length of the response, as a 4-byte little-endian integer</source>
          <target state="translated">응답 길이 (4 바이트 리틀 엔디안 정수)</target>
        </trans-unit>
        <trans-unit id="9d6f0d5641c4868545fe88e3f18cccf39a6677f5" translate="yes" xml:space="preserve">
          <source>The linearizability guarantee is for &lt;em&gt;atomic operations,&lt;/em&gt; not for &lt;em&gt;queries.&lt;/em&gt; A single RethinkDB query will not necessarily execute as a single atomic operation. It&amp;rsquo;s possible that the query:</source>
          <target state="translated">선형성 보장은 &lt;em&gt;쿼리가&lt;/em&gt; 아닌 &lt;em&gt;원 자성 작업&lt;/em&gt; 에 &lt;em&gt;대한 것입니다. &lt;/em&gt;단일 RethinkDB 쿼리가 반드시 단일 원자 작업으로 실행되는 것은 아닙니다. 다음과 같은 쿼리가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="be6c7b03ecee10bbdd3ecd94feb9326cf807aea0" translate="yes" xml:space="preserve">
          <source>The listener is the other side of the interaction: it connects to RabbitMQ, signs up to be notified of messages it&amp;rsquo;s interested in, and does something when it receives a message.</source>
          <target state="translated">리스너는 상호 작용의 다른 측면입니다. RabbitMQ에 연결하고 관심있는 메시지를 통지하도록 서명하며 메시지를받을 때 무언가를합니다.</target>
        </trans-unit>
        <trans-unit id="915fce30152336842eeda671dad0b27dec31599e" translate="yes" xml:space="preserve">
          <source>The log file&amp;rsquo;s location is dependent on your system configuration and how you started RethinkDB.</source>
          <target state="translated">로그 파일의 위치는 시스템 구성 및 RethinkDB 시작 방법에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2e78ae1df38b4c0eccc0c5010b454cb2411fca09" translate="yes" xml:space="preserve">
          <source>The log may give you information as to what caused the crash.</source>
          <target state="translated">로그는 충돌의 원인에 대한 정보를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4917584586a9ba5841c6d9996a82f13e2383ec57" translate="yes" xml:space="preserve">
          <source>The message &lt;code&gt;received invalid clustering header&lt;/code&gt; means there is a port mismatch, and something is connecting to the wrong port. For example, it&amp;rsquo;s common to get this message if you accidentally point the browser or connect the client drivers to the intracluster traffic port.</source>
          <target state="translated">메시지에 &lt;code&gt;received invalid clustering header&lt;/code&gt; 가 수신 되었다는 것은 포트가 일치하지 않아서 잘못된 포트에 연결 중임을 의미합니다. 예를 들어, 실수로 브라우저를 가리 키거나 클라이언트 드라이버를 클러스터 내 트래픽 포트에 연결하는 경우이 메시지가 표시되는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="e9b96017ac9340db22343a25f56da2ed0e933cf4" translate="yes" xml:space="preserve">
          <source>The metadata in the system tables applies to the RethinkDB cluster as a whole. Each server in a cluster maintains its own copy of the system tables. Whenever a system table on a server changes, the changes are synced across all the servers.</source>
          <target state="translated">시스템 테이블의 메타 데이터는 RethinkDB 클러스터에 전체적으로 적용됩니다. 클러스터의 각 서버는 자체 시스템 테이블 사본을 유지 보수합니다. 서버의 시스템 테이블이 변경 될 때마다 모든 서버에서 변경 사항이 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="34aae6139df043314fa6079b6b69c72abcd122fb" translate="yes" xml:space="preserve">
          <source>The most important field of this object is &lt;code&gt;errors&lt;/code&gt;. Generally speaking, if no exceptions are thrown and &lt;code&gt;errors&lt;/code&gt; is 0 then the write did what it was supposed to. (RethinkDB throws an exception when it isn&amp;rsquo;t even able to access the table; it sets the &lt;code&gt;errors&lt;/code&gt; field if it can access the table but an error occurs during the write. This convention exists so that batched writes don&amp;rsquo;t abort halfway through when they encounter an error.)</source>
          <target state="translated">이 개체의 가장 중요한 필드는 &lt;code&gt;errors&lt;/code&gt; 입니다. 일반적으로 예외가 발생하지 않고 &lt;code&gt;errors&lt;/code&gt; 가 0이면 쓰기가 예상대로 수행됩니다. (RethinkDB는 테이블에 액세스 할 수 없을 때 예외를 throw합니다. 테이블에 액세스 할 수 있으면 &lt;code&gt;errors&lt;/code&gt; 필드를 설정 하지만 쓰기 중에 오류가 발생합니다.이 규칙은 배치 된 쓰기가 중간에 중단되지 않도록하기 위해 존재합니다. 오류가 발생했습니다.)</target>
        </trans-unit>
        <trans-unit id="52054d4689c88c2dd563c71fc3d4622fe9e37e26" translate="yes" xml:space="preserve">
          <source>The most important things for you to provide for us are:</source>
          <target state="translated">귀하가 당사에 제공해야 할 가장 중요한 것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d9fb82f35843a166df27094da516f937f5cd76f" translate="yes" xml:space="preserve">
          <source>The next section will explain how to build complex queries. For now, we will just send the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt; (&lt;code&gt;r.expr(&quot;foo&quot;)&lt;/code&gt;) to the server.</source>
          <target state="translated">다음 섹션에서는 복잡한 쿼리를 작성하는 방법에 대해 설명합니다. 지금은 문자열 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; ( &lt;code&gt;r.expr(&quot;foo&quot;)&lt;/code&gt; )를 서버로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="850ad84f52970e1d319ea7e6979fbb8fb61b332c" translate="yes" xml:space="preserve">
          <source>The next section will go into more detail, but in our example the &lt;code&gt;QueryType&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt; (or &lt;code&gt;START&lt;/code&gt;, as we&amp;rsquo;ll see later), the &lt;code&gt;query&lt;/code&gt; is simply the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt; and there are no options.</source>
          <target state="translated">다음 섹션에서 더 자세히 설명하지만이 예에서는 &lt;code&gt;QueryType&lt;/code&gt; 이 &lt;code&gt;1&lt;/code&gt; (또는 나중에 볼 수 있듯이 &lt;code&gt;START&lt;/code&gt; )이며 &lt;code&gt;query&lt;/code&gt; 는 단순히 문자열 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 이며 옵션은 없습니다.</target>
        </trans-unit>
        <trans-unit id="1ae3c52cd36f26bb22cf875ccd87448c4be30f8e" translate="yes" xml:space="preserve">
          <source>The number of documents on shard 1 is computed. The query returns the value &lt;code&gt;4&lt;/code&gt; for the shard.</source>
          <target state="translated">샤드 1의 문서 수를 계산합니다. 쿼리는 샤드 의 값 &lt;code&gt;4&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b27530ba359fc44b511a6ec9376acbc82fc3b7d1" translate="yes" xml:space="preserve">
          <source>The number of documents on shard 2 is computed. The query returns the value &lt;code&gt;6&lt;/code&gt; for the shard.</source>
          <target state="translated">샤드 2의 문서 수를 계산합니다. 쿼리는 샤드 의 값 &lt;code&gt;6&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="17ded22e16e26949d0a41162bebffb07408ae4b0" translate="yes" xml:space="preserve">
          <source>The opposite of pluck; takes an object or a sequence of objects, and returns them with the specified paths removed.</source>
          <target state="translated">따로의 반대; 객체 또는 일련의 객체를 가져와 지정된 경로를 제거한 상태로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="efdd31a108ade64161256b161e030637f32003ab" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;interleave&lt;/code&gt; argument controls how the sequences will be merged:</source>
          <target state="translated">선택적 &lt;code&gt;interleave&lt;/code&gt; 인수는 시퀀스 병합 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="3e541b9a29bd1d84a6fc76c8fea0e5e43910a115" translate="yes" xml:space="preserve">
          <source>The optional arguments are:</source>
          <target state="translated">선택적 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7639f7478ac816294a9ebad71d1188e73a7903a1" translate="yes" xml:space="preserve">
          <source>The options can be:</source>
          <target state="translated">옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9c6dbe2e2ebb18556376a0edc038dbb53b9d23d" translate="yes" xml:space="preserve">
          <source>The order in which callbacks are called in the &lt;code&gt;EventMachine.run&lt;/code&gt; block is not guaranteed; in the sample output above, &lt;code&gt;[:array, [1, 2, 3]]&lt;/code&gt; might have printed first.</source>
          <target state="translated">&lt;code&gt;EventMachine.run&lt;/code&gt; 블록 에서 콜백이 호출되는 순서는 보장되지 않습니다. 위의 샘플 출력에서 &lt;code&gt;[:array, [1, 2, 3]]&lt;/code&gt; 이 먼저 인쇄되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a80bb124c4d721554e30b34eefc7bc2457ea017a" translate="yes" xml:space="preserve">
          <source>The order in which you chain ReQL commands can affect performance. For an example, imagine combining the previous two queries to return an ordered list of names of admin users. The &lt;code&gt;filter&lt;/code&gt; operation can be distributed across shards, but the &lt;code&gt;orderBy&lt;/code&gt; operation cannot. So this query:</source>
          <target state="translated">ReQL 명령을 연결하는 순서는 성능에 영향을 줄 수 있습니다. 예를 들어, 앞의 두 쿼리를 결합하여 정렬 된 관리자 이름 목록을 리턴한다고 가정하십시오. &lt;code&gt;filter&lt;/code&gt; 작업이 파편에 걸쳐 분산 될 수 있지만, &lt;code&gt;orderBy&lt;/code&gt; 작업을 할 수 없습니다. 따라서이 쿼리 :</target>
        </trans-unit>
        <trans-unit id="e126ffbf5f64034b05b6cc9873b4d6e9ac47fdda" translate="yes" xml:space="preserve">
          <source>The output format of a point changefeed is identical to a table changefeed.</source>
          <target state="translated">포인트 변경 피드의 출력 형식은 테이블 변경 피드와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="52544879000b4070f7c1ec53be285dedc81e74e4" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;rethinkdb&lt;/code&gt; on startup</source>
          <target state="translated">시작시 &lt;code&gt;rethinkdb&lt;/code&gt; 의 출력</target>
        </trans-unit>
        <trans-unit id="db1df362b12f7161c6f9dfe2a13f7a5f148cea5f" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;changes&lt;/code&gt; query adheres to the following protocol:</source>
          <target state="translated">&lt;code&gt;changes&lt;/code&gt; 쿼리 의 출력은 다음 프로토콜을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="9adcae7e13d1ddedbed6b9d9a4afd7aa5562ddd7" translate="yes" xml:space="preserve">
          <source>The output will be in this format:</source>
          <target state="translated">출력은 다음 형식으로됩니다 :</target>
        </trans-unit>
        <trans-unit id="4edfaeb420dd2cad843364eade6bfcc6103ac8f2" translate="yes" xml:space="preserve">
          <source>The parameters are represented as values &lt;code&gt;&amp;lt;p1&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;p2&amp;gt;&lt;/code&gt;, etc.; the values are arbitrary, but must be unique per query to avoid collisions. Within the function body the values are referred to with the query term &lt;code&gt;VAR&lt;/code&gt;, defined as &lt;code&gt;10&lt;/code&gt; in &lt;code&gt;ql2.proto&lt;/code&gt;. So the value of parameter &lt;code&gt;1&lt;/code&gt; is retrieved with &lt;code&gt;[10, [1]]&lt;/code&gt;.</source>
          <target state="translated">매개 변수는 &lt;code&gt;&amp;lt;p1&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;p2&amp;gt;&lt;/code&gt; 등으로 표시됩니다. 값은 임의적이지만 충돌을 피하려면 쿼리마다 고유해야합니다. 함수 본문 내에서 값은 &lt;code&gt;ql2.proto&lt;/code&gt; 에서 &lt;code&gt;10&lt;/code&gt; 으로 정의 된 &lt;code&gt;VAR&lt;/code&gt; 쿼리 용어로 참조됩니다 . 따라서 매개 변수 &lt;code&gt;1&lt;/code&gt; 의 값은 &lt;code&gt;[10, [1]]&lt;/code&gt; 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="709d9935fbae98edda7024d5c1ad7e0e1365088d" translate="yes" xml:space="preserve">
          <source>The part of a secondary index key that&amp;rsquo;s used for fast lookups depends on the length of the primary key (which must be 127 bytes or less). The length of this part is 238&amp;minus;&lt;em&gt;PK&lt;/em&gt;, where &lt;em&gt;PK&lt;/em&gt; is the primary key length; if the primary key length is a 36-character GUID, for instance, this means that 202 characters in the secondary index will be significant. If a table has multiple entries where the first 238&amp;minus;&lt;em&gt;PK&lt;/em&gt; characters are identical, lookup performance will be sharply degraded, as RethinkDB will have to perform a linear search to find the correct entries.</source>
          <target state="translated">빠른 조회에 사용되는 보조 인덱스 키 부분은 기본 키의 길이 (127 바이트 이하 여야 함)에 따라 다릅니다. 이 부분의 길이는 238- &lt;em&gt;PK&lt;/em&gt; 이며 여기서 &lt;em&gt;PK&lt;/em&gt; 는 기본 키 길이입니다. 예를 들어 기본 키 길이가 36 자 GUID 인 경우 보조 인덱스의 202자가 중요합니다. 테이블에 처음 238- &lt;em&gt;PK&lt;/em&gt; 문자가 동일한 여러 항목이있는 경우 RethinkDB가 올바른 항목을 찾기 위해 선형 검색을 수행해야하므로 조회 성능이 크게 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="a85fd7e773e98525a057dee410b910ff3a9a2c35" translate="yes" xml:space="preserve">
          <source>The predicate &lt;code&gt;{age:30}&lt;/code&gt; selects documents in the &lt;code&gt;users&lt;/code&gt; table with an &lt;code&gt;age&lt;/code&gt; field whose value is &lt;code&gt;30&lt;/code&gt;. Documents with an &lt;code&gt;age&lt;/code&gt; field set to any other value &lt;em&gt;or&lt;/em&gt; with no &lt;code&gt;age&lt;/code&gt; field present are skipped.</source>
          <target state="translated">술어 &lt;code&gt;{age:30}&lt;/code&gt; 은 &lt;code&gt;users&lt;/code&gt; 테이블에서 &lt;code&gt;age&lt;/code&gt; 필드의 값이 &lt;code&gt;30&lt;/code&gt; 인 문서를 선택합니다 . 와 문서 &lt;code&gt;age&lt;/code&gt; 다른 값으로 필드 세트 &lt;em&gt;또는&lt;/em&gt; 아니오 &lt;code&gt;age&lt;/code&gt; 필드의 존재는 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="ab592fecf2d641277abe2dc185bc11bf61ae10da" translate="yes" xml:space="preserve">
          <source>The primary index of a table can be used in any ReQL command that uses a secondary index.</source>
          <target state="translated">테이블의 기본 인덱스는 보조 인덱스를 사용하는 ReQL 명령에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="169a155070f84ee6fa928b40cd22b933ed483d0c" translate="yes" xml:space="preserve">
          <source>The primary key of each document is used by RethinkDB to place the document into an appropriate shard, and index it within that shard using a B-Tree data structure. Querying documents by primary key is extremely efficient, because the query can immediately be routed to the right shard and the document can be looked up in the B-Tree.</source>
          <target state="translated">RethinkDB는 각 문서의 기본 키를 사용하여 문서를 적절한 샤드에 넣고 B-Tree 데이터 구조를 사용하여 샤드 내에서 색인을 생성합니다. 기본 키로 문서를 쿼리하면 쿼리가 즉시 올바른 샤드로 라우팅되고 B- 트리에서 문서를 조회 할 수 있으므로 매우 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="8b50e856dfd19b785cfb1ae6817c08f87c06cd84" translate="yes" xml:space="preserve">
          <source>The primary way to administer a RethinkDB AMI is through the web UI. Advanced tasks can be performed with ReQL administration commands, using the Data Explorer interactively or scripting through any RethinkDB driver. Read &lt;a href=&quot;../administration-tools/index&quot;&gt;Administration tools&lt;/a&gt; for more details about scripting administration tasks.</source>
          <target state="translated">RethinkDB AMI를 관리하는 기본 방법은 웹 UI를 사용하는 것입니다. 대화식으로 데이터 탐색기를 사용하거나 RethinkDB 드라이버를 통해 스크립팅하여 ReQL 관리 명령으로 고급 작업을 수행 할 수 있습니다. 스크립팅 관리 작업에 대한 자세한 내용은 &lt;a href=&quot;../administration-tools/index&quot;&gt;관리 도구&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="56486ac3e6a0cff408514c32848848251b792543" translate="yes" xml:space="preserve">
          <source>The programmer can also mark a read query to be ok with out-of-date data. In this mode, the query isn&amp;rsquo;t necessarily routed to the shard&amp;rsquo;s primary, but is likely to be routed to its closest replica. Out-of-date queries are likely to have lower latency and have stronger availability guarantees, but don&amp;rsquo;t necessarily return the latest version of the data to the client.</source>
          <target state="translated">또한 프로그래머는 오래된 데이터를 사용하여 읽기 쿼리에 문제가없는 것으로 표시 할 수 있습니다. 이 모드에서 쿼리는 반드시 샤드의 기본 서버로 라우팅 될 필요는 없지만 가장 가까운 복제본으로 라우팅 될 수 있습니다. 오래된 쿼리는 대기 시간이 짧고 가용성이 더 높을 수 있지만 반드시 최신 버전의 데이터를 클라이언트에 반환 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="43f06ecd9db4c427f5c01e559845b1558afef7ab" translate="yes" xml:space="preserve">
          <source>The proxy node can do some query processing itself, reducing CPU load on database servers.</source>
          <target state="translated">프록시 노드는 일부 쿼리 처리 자체를 수행하여 데이터베이스 서버의 CPU로드를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="03aeb45cfefab1e6845737436e42c4ae921ad3f3" translate="yes" xml:space="preserve">
          <source>The proxy will send queries directly to the correct machines, reducing intracluster traffic.</source>
          <target state="translated">프록시는 올바른 시스템으로 직접 쿼리를 전송하여 클러스터 내 트래픽을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="36fbbe7526681119c7192d6053c30c4b1b91f8d9" translate="yes" xml:space="preserve">
          <source>The queries are efficiently transported to the server (via protocol buffers), and evaluated in the cluster.</source>
          <target state="translated">쿼리는 프로토콜 버퍼를 통해 서버로 효율적으로 전송되고 클러스터에서 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="03c9e234b8601cd8cefabab2a66ae0491cf2637c" translate="yes" xml:space="preserve">
          <source>The queries linking the data between the authors and their posts tend to be more complicated.</source>
          <target state="translated">저자와 게시물 사이의 데이터를 연결하는 쿼리는 더 복잡한 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f2e5494893b9508bc4d620ee6c352443bb70976" translate="yes" xml:space="preserve">
          <source>The query is sent to a server for execution.</source>
          <target state="translated">쿼리는 실행을 위해 서버로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="d418228ef09faaa1d551875cd4899ad068afb495" translate="yes" xml:space="preserve">
          <source>The query types are defined in &lt;code&gt;ql2.proto&lt;/code&gt;. When a query is first sent to the server, it will be sent with a &lt;code&gt;QueryType&lt;/code&gt; of &lt;code&gt;START&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt;). The options (sometimes referred to as &amp;ldquo;global optargs&amp;rdquo;) are options passed to the &lt;code&gt;run&lt;/code&gt; command itself; see the &lt;a href=&quot;https://rethinkdb.com/api/python/run&quot;&gt;run documentation&lt;/a&gt; for a complete list. (Commands sent to the server are snake_case, not camelCase.)</source>
          <target state="translated">쿼리 유형은 &lt;code&gt;ql2.proto&lt;/code&gt; 에 정의되어 있습니다 . 쿼리가 서버로 처음 전송되면 &lt;code&gt;QueryType&lt;/code&gt; 이 &lt;code&gt;START&lt;/code&gt; ( &lt;code&gt;1&lt;/code&gt; ) 인 상태 로 전송됩니다 . 옵션 (&amp;ldquo;글로벌 optargs&amp;rdquo;라고도 함)은 &lt;code&gt;run&lt;/code&gt; 명령 자체에 전달되는 옵션 입니다. 전체 목록 은 &lt;a href=&quot;https://rethinkdb.com/api/python/run&quot;&gt;실행 설명서&lt;/a&gt; 를 참조하십시오 . (서버로 전송 된 명령은 camelCase가 아니라 snake_case입니다.)</target>
        </trans-unit>
        <trans-unit id="c3ed5416cb9cfab926b34e7082c8a35489e21a3b" translate="yes" xml:space="preserve">
          <source>The query would look like this:</source>
          <target state="translated">쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="49093f36439602ded586cf0ea033178761fb4a63" translate="yes" xml:space="preserve">
          <source>The reduction function can be called on the results of two previous reductions because the &lt;code&gt;reduce&lt;/code&gt; command is distributed and parallelized across shards and CPU cores. A common mistaken when using the &lt;code&gt;reduce&lt;/code&gt; command is to suppose that the reduction is executed from left to right. Read the &lt;a href=&quot;../../../docs/map-reduce/index&quot;&gt;map-reduce in RethinkDB&lt;/a&gt; article to see an example.</source>
          <target state="translated">&lt;code&gt;reduce&lt;/code&gt; 명령은 샤드 및 CPU 코어에 분산되어 병렬화 되므로 이전의 두 가지 축소 결과에 대해 축소 기능을 호출 할 수 있습니다 . &lt;code&gt;reduce&lt;/code&gt; 명령을 사용할 때 일반적으로 실수 는 왼쪽에서 오른쪽으로 축소가 실행된다고 가정하는 것입니다. 예를 보려면 &lt;a href=&quot;../../../docs/map-reduce/index&quot;&gt;RethinkDB&lt;/a&gt; 기사 의 map-reduce 기사를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="2eaef544cfa01e61b0600b7381d8e28d53266a21" translate="yes" xml:space="preserve">
          <source>The reduction function can be called on:</source>
          <target state="translated">축소 기능은 다음에서 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="118a3751802c0d2d297d092376f59ad08a2671d1" translate="yes" xml:space="preserve">
          <source>The repubsub library has three classes:</source>
          <target state="translated">repubsub 라이브러리에는 세 가지 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c34de0c47665e2093b16d6e8c6cc2dafe60ac91" translate="yes" xml:space="preserve">
          <source>The result is an array containing one object for each table index:</source>
          <target state="translated">결과는 각 테이블 인덱스에 대해 하나의 객체를 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="05697956ca1c2b261267f1b15b9b31d091e913b4" translate="yes" xml:space="preserve">
          <source>The result is an array of the three previously inserted documents, along with the generated &lt;code&gt;id&lt;/code&gt; values.</source>
          <target state="translated">결과는 생성 된 &lt;code&gt;id&lt;/code&gt; 값 과 함께 이전에 삽입 된 3 개의 문서 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="96b9393100a8f012abd44d66848a45d8492c36be" translate="yes" xml:space="preserve">
          <source>The result is an array where for each index, there will be an object like this one:</source>
          <target state="translated">결과는 각 인덱스마다 다음과 같은 객체가있는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="348e1c53bcf414975d4e88512994c35382165db3" translate="yes" xml:space="preserve">
          <source>The result is returned to the client.</source>
          <target state="translated">결과는 클라이언트에게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a4f25bd6541b97b8d992950d6d5f5fc101f8780b" translate="yes" xml:space="preserve">
          <source>The result look like:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f460bc9b91b03b6b76aa3c9f4052058e662787ad" translate="yes" xml:space="preserve">
          <source>The result of the &lt;code&gt;filter&lt;/code&gt; is sent from the shards to the query server and combined.</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; 결과는 샤드에서 쿼리 서버로 전송되어 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="26ef6ad9412c9be209139ccf22acdf6ab7306819" translate="yes" xml:space="preserve">
          <source>The result of this query is a stream of documents that includes every post written by every author in our database:</source>
          <target state="translated">이 쿼리의 결과는 데이터베이스의 모든 작성자가 작성한 모든 게시물을 포함하는 문서 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="4166859a2337b060599ebba8ff3782b1a2dac997" translate="yes" xml:space="preserve">
          <source>The result set of &lt;code&gt;eqJoin&lt;/code&gt; is a stream or array of objects. Each object in the returned set will be an object of the form &lt;code&gt;{left:&amp;lt;left-document&amp;gt;,right:&amp;lt;right-document&amp;gt;}&lt;/code&gt;, where the values of &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; will be the joined documents. Use the &lt;code&gt;&lt;a href=&quot;../zip/index&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; command to merge the &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; fields together.</source>
          <target state="translated">&lt;code&gt;eqJoin&lt;/code&gt; 의 결과 집합 은 객체의 스트림 또는 배열입니다. 리턴 된 세트의 각 오브젝트는 &lt;code&gt;{left:&amp;lt;left-document&amp;gt;,right:&amp;lt;right-document&amp;gt;}&lt;/code&gt; 형식의 오브젝트가되며 , 여기서 &lt;code&gt;left&lt;/code&gt; 및 &lt;code&gt;right&lt;/code&gt; 값은 결합 된 문서입니다. &lt;code&gt;&lt;a href=&quot;../zip/index&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 명령을 사용하여 &lt;code&gt;left&lt;/code&gt; 및 &lt;code&gt;right&lt;/code&gt; 필드 를 병합하십시오 .</target>
        </trans-unit>
        <trans-unit id="bcacb4ffc1428a1e7537a1b530d77ec1be49f08c" translate="yes" xml:space="preserve">
          <source>The result will be</source>
          <target state="translated">결과는</target>
        </trans-unit>
        <trans-unit id="4e00afb986323ba904efea3a982c45371e5a241e" translate="yes" xml:space="preserve">
          <source>The result will be:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ee33cf492c99cfb381b58051e0acd3d936534d2" translate="yes" xml:space="preserve">
          <source>The result will have two fields &lt;code&gt;old_val&lt;/code&gt; and &lt;code&gt;new_val&lt;/code&gt;.</source>
          <target state="translated">결과에는 &lt;code&gt;old_val&lt;/code&gt; 과 &lt;code&gt;new_val&lt;/code&gt; 의 두 필드가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2762176fdb80307d4542fb97295cbd05e50ef387" translate="yes" xml:space="preserve">
          <source>The result will now include a &lt;code&gt;changes&lt;/code&gt; field:</source>
          <target state="translated">결과는 이제 &lt;code&gt;changes&lt;/code&gt; 필드를 포함 합니다 :</target>
        </trans-unit>
        <trans-unit id="580d6c3b8e7791206b60fdc3fbc9d93f7725d9aa" translate="yes" xml:space="preserve">
          <source>The results from &lt;code&gt;eqJoin&lt;/code&gt; are, by default, not ordered. The optional &lt;code&gt;ordered: true&lt;/code&gt; parameter will cause &lt;code&gt;eqJoin&lt;/code&gt; to order the output based on the left side input stream. (If there are multiple matches on the right side for a document on the left side, their order is not guaranteed even if &lt;code&gt;ordered&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.) Requiring ordered results can significantly slow down &lt;code&gt;eqJoin&lt;/code&gt;, and in many circumstances this ordering will not be required. (See the first example, in which ordered results are obtained by using &lt;code&gt;orderBy&lt;/code&gt; after &lt;code&gt;eqJoin&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;eqJoin&lt;/code&gt; 의 결과는 기본적으로 순서가 없습니다. 선택적 &lt;code&gt;ordered: true&lt;/code&gt; 매개 변수는 &lt;code&gt;eqJoin&lt;/code&gt; 이 왼쪽 입력 스트림을 기반으로 출력을 정렬하게합니다. (왼쪽에있는 문서에 대해 오른쪽에 여러 개의 일치 항목이있는 경우, &lt;code&gt;ordered&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 인 경우에도 순서가 보장되지 않습니다 .) 순서 가 지정된 결과를 요구하면 &lt;code&gt;eqJoin&lt;/code&gt; 이 상당히 느려질 수 있으며, 많은 경우이 순서는 필요하지 않습니다. ( &lt;code&gt;eqJoin&lt;/code&gt; 다음에 &lt;code&gt;orderBy&lt;/code&gt; 를 사용하여 정렬 된 결과를 얻는 첫 번째 예를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="d9451368182bf51f88eb6d06ba8ad24bd4eea60c" translate="yes" xml:space="preserve">
          <source>The results of which might look something like:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0fb83e527b8a750c6dbf5105d1252ab390a7c46c" translate="yes" xml:space="preserve">
          <source>The results will be:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f8c631d950204e251a618f771c764d482aaa3e66" translate="yes" xml:space="preserve">
          <source>The return value is an object consisting of a single field, &lt;code&gt;ready&lt;/code&gt;. The value is an integer indicating the number of tables waited for. It will always be &lt;code&gt;1&lt;/code&gt; when &lt;code&gt;wait&lt;/code&gt; is called on a table, and the total number of tables when called on a database.</source>
          <target state="translated">반환 값은 &lt;code&gt;ready&lt;/code&gt; 단일 필드로 구성된 객체 입니다. 값은 대기 한 테이블 수를 나타내는 정수입니다. &lt;code&gt;wait&lt;/code&gt; 는 테이블에서 호출 될 때 항상 &lt;code&gt;1&lt;/code&gt; 이고 데이터베이스에서 호출 될 때 총 테이블 수입니다.</target>
        </trans-unit>
        <trans-unit id="36faca8c0d371071eae4e811f7ff0155ed872784" translate="yes" xml:space="preserve">
          <source>The return value is an object providing information about the table&amp;rsquo;s shards, replicas and replica readiness states. For a more complete discussion of the object fields, read about the &lt;code&gt;table_status&lt;/code&gt; table in &lt;a href=&quot;../../../docs/system-tables/index#status-tables&quot;&gt;System tables&lt;/a&gt;.</source>
          <target state="translated">리턴 값은 테이블의 샤드, 복제본 및 복제본 준비 상태에 대한 정보를 제공하는 오브젝트입니다. 오브젝트 필드에 대한 자세한 내용은 &lt;a href=&quot;../../../docs/system-tables/index#status-tables&quot;&gt;시스템 테이블&lt;/a&gt; 에서 &lt;code&gt;table_status&lt;/code&gt; 테이블에 대해 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="8664182ddca74a0afbba7d649d8e66f1228d49e5" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;rebalance&lt;/code&gt; is an object with two fields:</source>
          <target state="translated">&lt;code&gt;rebalance&lt;/code&gt; 의 반환 값은 두 개의 필드가있는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="c84ffcb32dd5cb8354ded3859b763e4a6e87665d" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;reconfigure&lt;/code&gt; in emergency repair mode is the same as before. Examine the &lt;code&gt;config_changes&lt;/code&gt; field to see the old and new configuration settings for the table. As in the normal mode, if you specify &lt;code&gt;emergencyRepair&lt;/code&gt; with &lt;code&gt;dryRun: true&lt;/code&gt;, the table will not actually be reconfigured.</source>
          <target state="translated">응급 복구 모드에서 &lt;code&gt;reconfigure&lt;/code&gt; 의 반환 값은 이전과 동일합니다. &lt;code&gt;config_changes&lt;/code&gt; 필드를 검사하여 테이블의 이전 및 새 구성 설정을보십시오. 일반 모드에서와 같이, &lt;code&gt;emergencyRepair&lt;/code&gt; with &lt;code&gt;dryRun: true&lt;/code&gt; 를 지정하면 실제로 테이블이 재구성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e02204eda362a94ed3590b8243708f0a55205484" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;reconfigure&lt;/code&gt; is an object with three fields:</source>
          <target state="translated">&lt;code&gt;reconfigure&lt;/code&gt; 의 반환 값은 세 개의 필드가있는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="4a42d23931413086f7413742cda1659b0e61d53c" translate="yes" xml:space="preserve">
          <source>The return value on success will be an object of the format &lt;code&gt;{renamed:1}&lt;/code&gt;, or &lt;code&gt;{renamed:0}&lt;/code&gt; if the old and new names are the same.</source>
          <target state="translated">성공시의 반환 값은 &lt;code&gt;{renamed:1}&lt;/code&gt; 형식의 객체 이거나 이전 이름과 새 이름이 동일한 경우 &lt;code&gt;{renamed:0}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a37da5d84e981e0bb315cf13e3a7994a4aa1e0e0" translate="yes" xml:space="preserve">
          <source>The return value will be an array of two-item objects with the keys &lt;code&gt;dist&lt;/code&gt; and &lt;code&gt;doc&lt;/code&gt;, set to the distance between the specified point and the document (in the units specified with &lt;code&gt;unit&lt;/code&gt;, defaulting to meters) and the document itself, respectively. The array will be sorted by the values of &lt;code&gt;dist&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;dist&lt;/code&gt; 및 &lt;code&gt;doc&lt;/code&gt; 키가있는 두 항목 오브젝트의 배열이며 , 지정된 점과 문서 사이의 거리 (unit로 지정된 &lt;code&gt;unit&lt;/code&gt; , 기본값은 미터)와 문서 자체입니다. 배열은 &lt;code&gt;dist&lt;/code&gt; 값으로 정렬됩니다 .</target>
        </trans-unit>
        <trans-unit id="e759e1229ecea9bbd7516da914692287ca680f57" translate="yes" xml:space="preserve">
          <source>The return value, array or stream, will be the same type as the input.</source>
          <target state="translated">반환 값, 배열 또는 스트림은 입력과 동일한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="4fec44479d0d10c75421c13f42fbeec52349083e" translate="yes" xml:space="preserve">
          <source>The returned sequence represents an intersection of the left-hand sequence and the right-hand sequence: each row of the left-hand sequence will be compared with each row of the right-hand sequence to find all pairs of rows which satisfy the predicate. Each matched pair of rows of both sequences are combined into a result row. In most cases, you will want to follow the join with &lt;a href=&quot;../zip/index&quot;&gt;zip&lt;/a&gt; to combine the left and right results.</source>
          <target state="translated">리턴 된 순서는 왼쪽 순서와 오른쪽 순서의 교집합을 나타냅니다. 왼쪽 순서의 각 행은 오른쪽 순서의 각 행과 비교되어 술어를 만족시키는 모든 행 쌍을 찾습니다. 두 시퀀스의 각 일치하는 행 쌍이 결과 행으로 결합됩니다. 대부분의 경우 왼쪽 및 오른쪽 결과를 결합하기 위해 &lt;a href=&quot;../zip/index&quot;&gt;zip&lt;/a&gt; 을 사용하여 조인을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="ac5cc5666ad8aa8ef95292cf77a92d9802649f93" translate="yes" xml:space="preserve">
          <source>The same is true for &lt;code&gt;single&lt;/code&gt; write mode and &lt;code&gt;soft&lt;/code&gt; durability mode. In normal operation these produce the same results as &lt;code&gt;majority&lt;/code&gt; and &lt;code&gt;hard&lt;/code&gt;, but in the event of a network or server failure, recent write operations that were run using these modes might be lost.</source>
          <target state="translated">&lt;code&gt;single&lt;/code&gt; 쓰기 모드와 &lt;code&gt;soft&lt;/code&gt; 내구성 모드 에서도 마찬가지입니다 . 일반 작업에서는 이것과 &lt;code&gt;majority&lt;/code&gt; 및 &lt;code&gt;hard&lt;/code&gt; 와 동일한 결과를 생성 하지만 네트워크 또는 서버 오류가 발생하면 이러한 모드를 사용하여 실행 된 최근 쓰기 작업이 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4c323e945ed7f27785d054b5f8f97e0e237757c" translate="yes" xml:space="preserve">
          <source>The second comment can be deleted by using &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;deleteAt&lt;/code&gt; together.</source>
          <target state="translated">두 번째 주석은 &lt;code&gt;update&lt;/code&gt; 와 &lt;code&gt;deleteAt&lt;/code&gt; 를 함께 사용하여 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="202097410423eb99aa6ecf467119bc01a4f749f3" translate="yes" xml:space="preserve">
          <source>The second layer builds on the first and implements various automation mechanisms (e.g. automatically determining how to split shards, where to place copies of the data, automatically picking optimal primary replicas, etc.) This is the layer that compiles goals specified by the user into blueprints.</source>
          <target state="translated">두 번째 계층은 첫 번째 계층을 구축하고 다양한 자동화 메커니즘을 구현합니다 (예 : 샤드 분할 방법, 데이터 사본을 배치 할 위치, 최적의 기본 복제본 자동 선택 등). 사용자가 지정한 목표를 다음과 같이 컴파일하는 계층입니다. 청사진.</target>
        </trans-unit>
        <trans-unit id="114be4a5ece50c916bc47741e3a7d572735f0817" translate="yes" xml:space="preserve">
          <source>The server sends a null-terminated JSON response with a &lt;code&gt;&quot;success&quot;&lt;/code&gt; value of either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. On &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;&quot;authentication&quot;&lt;/code&gt; will contain the &amp;ldquo;server-final-message&amp;rdquo; with the ServerSignature value. The client should compute a ServerSignature as specified in the RFC and verify the values are identical.</source>
          <target state="translated">서버는 &lt;code&gt;&quot;success&quot;&lt;/code&gt; 값이 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 인 null 종료 JSON 응답을 보냅니다 . 에 &lt;code&gt;true&lt;/code&gt; 후 &lt;code&gt;&quot;authentication&quot;&lt;/code&gt; ServerSignature 값으로 &quot;서버 마지막 메시지&quot;를 포함합니다. 클라이언트는 RFC에 지정된대로 ServerSignature를 계산하고 값이 동일한 지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="edb1a2704ae24a6e1303f7d8a6f62db3e8042205" translate="yes" xml:space="preserve">
          <source>The server sends a null-terminated JSON response with a &lt;code&gt;&quot;success&quot;&lt;/code&gt; value of either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. On &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;&quot;authentication&quot;&lt;/code&gt; will contain the &amp;ldquo;server-first-message&amp;rdquo; containing the iteration count (&lt;code&gt;i=&lt;/code&gt;), salt (&lt;code&gt;s=&lt;/code&gt;) and a concatenation of the client nonce with its own nonce.</source>
          <target state="translated">서버는 &lt;code&gt;&quot;success&quot;&lt;/code&gt; 값이 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 인 null 종료 JSON 응답을 보냅니다 . 에서 &lt;code&gt;true&lt;/code&gt; 하고 &lt;code&gt;&quot;authentication&quot;&lt;/code&gt; 반복 횟수 (포함하는 「서버 제 메시지 &quot;포함 &lt;code&gt;i=&lt;/code&gt; ), 염 ( &lt;code&gt;s=&lt;/code&gt; ) 및 자신의 논스 인 클라이언트 넌스를 연결한다.</target>
        </trans-unit>
        <trans-unit id="f585ded5cf8cfbbeb9c1f07d18ba8a91cefb4bcd" translate="yes" xml:space="preserve">
          <source>The server should return an object with zero errors and three inserted documents. We didn&amp;rsquo;t specify any primary keys (by default, each table uses the &lt;code&gt;id&lt;/code&gt; attribute for primary keys), so RethinkDB generated them for us. The generated keys are returned via the &lt;code&gt;generated_keys&lt;/code&gt; attribute.</source>
          <target state="translated">서버는 오류가 0이고 삽입 된 문서가 3 개인 개체를 반환해야합니다. 기본 키를 지정하지 않았으며 (기본적으로 각 테이블은 기본 키에 &lt;code&gt;id&lt;/code&gt; 속성을 사용함) RethinkDB가이를 생성했습니다. 생성 된 키는 &lt;code&gt;generated_keys&lt;/code&gt; 속성을 통해 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="98b6dd8a48a32954f5cb12942416a3c37cb847e5" translate="yes" xml:space="preserve">
          <source>The server will buffer up to &lt;code&gt;changefeedQueueSize&lt;/code&gt; elements (default 100,000). If the buffer limit is hit, early changes will be discarded, and the client will receive an object of the form &lt;code&gt;{error:&quot;Changefeed cache over array size limit, skipped X elements.&quot;}&lt;/code&gt; where &lt;code&gt;X&lt;/code&gt; is the number of elements skipped.</source>
          <target state="translated">서버는 &lt;code&gt;changefeedQueueSize&lt;/code&gt; 요소 를 변경 하기 위해 버퍼링 합니다 (기본값 100,000). 버퍼 한계에 도달하면 초기 변경 사항이 삭제되고 클라이언트는 &lt;code&gt;{error:&quot;Changefeed cache over array size limit, skipped X elements.&quot;}&lt;/code&gt; 형식의 오브젝트를 수신합니다 . 여기서 &lt;code&gt;X&lt;/code&gt; 는 건너 뛴 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="8ecf2cc5495ccd280e597b73766b3eb352486850" translate="yes" xml:space="preserve">
          <source>The server will respond with a &lt;code&gt;null&lt;/code&gt;-terminated ASCII string describing the result of the handshake. If the string is &lt;code&gt;&quot;SUCCESS&quot;&lt;/code&gt;, the client may proceed to stage 2 and begin sending queries. Any other string indicates an error. The server will close the connection, and the driver should report this error to the user.</source>
          <target state="translated">서버는 핸드 쉐이크 결과를 설명 하는 &lt;code&gt;null&lt;/code&gt; ASCII 문자열로 응답 합니다. 문자열이 &lt;code&gt;&quot;SUCCESS&quot;&lt;/code&gt; 인 경우 클라이언트는 2 단계로 진행하여 쿼리 전송을 시작할 수 있습니다. 다른 문자열은 오류를 나타냅니다. 서버가 연결을 닫고 드라이버가이 오류를 사용자에게보고해야합니다.</target>
        </trans-unit>
        <trans-unit id="01511cc2b5cf35c2db85f41272ca8094df7742c9" translate="yes" xml:space="preserve">
          <source>The short answer is no. The longer answer is that the clustering system is designed with three main principles in mind:</source>
          <target state="translated">짧은 대답은 '아니요'입니다. 더 긴 대답은 클러스터링 시스템이 세 가지 주요 원칙을 염두에두고 설계되었다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="122b514199aca38b1e64f978120a76550d5f8df4" translate="yes" xml:space="preserve">
          <source>The short answer: you can&amp;rsquo;t. Use &lt;code&gt;Time&lt;/code&gt; objects instead.</source>
          <target state="translated">짧은 대답 : 당신은 할 수 없습니다. 대신 &lt;code&gt;Time&lt;/code&gt; 객체를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b9453d9082351eda5683faedd71864622103978" translate="yes" xml:space="preserve">
          <source>The simplest case is publishing a message with a string for a topic. This lends itself to using regexes for filtering.</source>
          <target state="translated">가장 간단한 경우는 주제에 대한 문자열이 포함 된 메시지를 게시하는 것입니다. 이것은 필터링을 위해 정규 표현식을 사용하는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="bb3e9cfc183b68887a93814d02362733592ff536" translate="yes" xml:space="preserve">
          <source>The size of the JSON-encoded response, as a 4-byte little-endian integer</source>
          <target state="translated">4 바이트 리틀 엔디안 정수인 JSON 인코딩 응답의 크기</target>
        </trans-unit>
        <trans-unit id="74b63d6fbff9efcdad47927189bdc3fb30c297b0" translate="yes" xml:space="preserve">
          <source>The size of the JSON-serialized, UTF8-encoded query, as a 4-byte little-endian integer</source>
          <target state="translated">JSON 직렬화, UTF8 인코딩 쿼리의 크기 (4 바이트 리틀 엔디안 정수)</target>
        </trans-unit>
        <trans-unit id="57d388ed7a0a12386d59b691694b54aade3412a2" translate="yes" xml:space="preserve">
          <source>The size of the JSON-serialized, UTF8-encoded wrapped query, as a 4-byte little-endian integer</source>
          <target state="translated">JSON 직렬화, UTF8 인코딩 랩핑 된 쿼리의 크기 (4 바이트 리틀 엔디안 정수)</target>
        </trans-unit>
        <trans-unit id="9317ef5264324276eb78c8a1c900602db1085bdc" translate="yes" xml:space="preserve">
          <source>The slightly longer answer: there&amp;rsquo;s only one native &lt;code&gt;time&lt;/code&gt; data type in RethinkDB. When a language supports more than one kind of date/time object, we think it&amp;rsquo;s better to explicitly support one and only one of them in the client driver to avoid confusion. Otherwise, you might insert a &lt;code&gt;DateTime&lt;/code&gt; object and get a &lt;code&gt;Time&lt;/code&gt; object back.</source>
          <target state="translated">조금 더 긴 대답 : RethinkDB에는 기본 &lt;code&gt;time&lt;/code&gt; 데이터 유형이 하나 뿐입니다. 언어가 여러 종류의 날짜 / 시간 개체를 지원할 때 혼동을 피하기 위해 클라이언트 드라이버에서 하나만 명시 적으로 지원하는 것이 좋습니다. 그렇지 않으면 &lt;code&gt;DateTime&lt;/code&gt; 객체를 삽입 하고 &lt;code&gt;Time&lt;/code&gt; 객체를 다시 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7c32a92c25b9cee33b2f71bfb7a043ec405b0db" translate="yes" xml:space="preserve">
          <source>The smallest recommended instance type is &lt;code&gt;t2.small&lt;/code&gt;. However, &lt;code&gt;t2.micro&lt;/code&gt; works for simple tests. Follow these instructions to set up an AMI:</source>
          <target state="translated">가장 권장되는 인스턴스 유형은 &lt;code&gt;t2.small&lt;/code&gt; 입니다. 그러나 &lt;code&gt;t2.micro&lt;/code&gt; 는 간단한 테스트를 위해 작동합니다. 다음 지침에 따라 AMI를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="fe9f9991bad143f14ee5c65aadc6ca48be3371b7" translate="yes" xml:space="preserve">
          <source>The solution is to add a &lt;code&gt;default&lt;/code&gt; to the &lt;code&gt;row&lt;/code&gt; command that always evaluates to something other than what you&amp;rsquo;re testing for, so it will return &lt;code&gt;false&lt;/code&gt; if the field doesn&amp;rsquo;t exist:</source>
          <target state="translated">해결책은 항상 테스트하는 것 이외의 것으로 평가 하는 &lt;code&gt;row&lt;/code&gt; 명령에 &lt;code&gt;default&lt;/code&gt; 을 추가하는 것이므로 필드가 존재하지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="5b36db4e47fc826603ad3fcc1fa591fc90ce4a59" translate="yes" xml:space="preserve">
          <source>The stats table is one of the &lt;a href=&quot;../system-tables/index&quot;&gt;system tables&lt;/a&gt; added in version 1.16 of RethinkDB. It provides statistics about server read/write throughput, client connections, and memory usage.</source>
          <target state="translated">stats 테이블은 RethinkDB 버전 1.16에 추가 된 &lt;a href=&quot;../system-tables/index&quot;&gt;시스템 테이블&lt;/a&gt; 중 하나입니다 . 서버 읽기 / 쓰기 처리량, 클라이언트 연결 및 메모리 사용량에 대한 통계를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="84f5d2d101fc423bc118fd0bc79f68807e1dd7f3" translate="yes" xml:space="preserve">
          <source>The steps necessary for migrating data to current RethinkDB versions from previous ones depend on which version you&amp;rsquo;re migrating from.</source>
          <target state="translated">이전 버전에서 현재 RethinkDB 버전으로 데이터를 마이그레이션하는 데 필요한 단계는 마이그레이션중인 버전에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ac277ab708b96fe6dc91bf3cd9a94437f7706c40" translate="yes" xml:space="preserve">
          <source>The storage engine is used in conjunction with a custom, B-Tree-aware caching engine which allows file sizes many orders of magnitude greater than the amount of available memory. RethinkDB can operate on a terabyte of data with about ten gigabytes of free RAM.</source>
          <target state="translated">스토리지 엔진은 사용자 정의 B- 트리 인식 캐싱 엔진과 함께 사용되어 사용 가능한 메모리 양보다 파일 크기를 훨씬 더 크게 허용합니다. RethinkDB는 약 10 기가 바이트의 사용 가능한 RAM이있는 테라 바이트 급 데이터에서 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8396b8f23f4763e864595f49d22dca2ab9cdfe5" translate="yes" xml:space="preserve">
          <source>The table created has six fields: an automatically generated primary key (&lt;code&gt;id&lt;/code&gt;), &lt;code&gt;rank&lt;/code&gt; (the IMDb rank, 1&amp;ndash;250), &lt;code&gt;rating&lt;/code&gt; (on a 1&amp;ndash;10 scale), &lt;code&gt;title&lt;/code&gt;, &lt;code&gt;votes&lt;/code&gt;, and &lt;code&gt;year&lt;/code&gt;.</source>
          <target state="translated">작성된 테이블에는 자동으로 생성 된 기본 키 ( &lt;code&gt;id&lt;/code&gt; ), &lt;code&gt;rank&lt;/code&gt; (IMDb 순위, 1&amp;ndash;250), &lt;code&gt;rating&lt;/code&gt; (1-10 스케일), &lt;code&gt;title&lt;/code&gt; , &lt;code&gt;votes&lt;/code&gt; 및 &lt;code&gt;year&lt;/code&gt; 6 개의 필드가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3bee24f1a9444db1641572680398af8a1e9f5a02" translate="yes" xml:space="preserve">
          <source>The table must be configured to have three or more replicas</source>
          <target state="translated">테이블은 3 개 이상의 복제본을 갖도록 구성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4be6c448f38373c6d6cf5f4315ebc31efcf470d8" translate="yes" xml:space="preserve">
          <source>The table stores a maximum of 1000 messages per server. The changefeed will not deliver events for log entries when they are removed.</source>
          <target state="translated">이 테이블은 서버 당 최대 1000 개의 메시지를 저장합니다. 변경 피드는 로그 항목이 제거 될 때 이벤트를 전달하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67c77aec7a677d740204db26286743a08de27d11" translate="yes" xml:space="preserve">
          <source>The table&amp;rsquo;s primary key is the &lt;code&gt;id&lt;/code&gt; field, and the keys are always arrays. The first element in the array is always a string indicating the object type being queried (i.e., &lt;code&gt;&quot;table&quot;&lt;/code&gt;, &lt;code&gt;&quot;server&quot;&lt;/code&gt;, etc.); for all objects but the cluster (which has only one document in the &lt;code&gt;stats&lt;/code&gt; table), the second element is the UUID of the object being queried.</source>
          <target state="translated">테이블의 기본 키는 &lt;code&gt;id&lt;/code&gt; 필드이고 키는 항상 배열입니다. 배열의 첫 번째 요소는 항상 쿼리중인 개체 유형을 나타내는 문자열입니다 (예 : &lt;code&gt;&quot;table&quot;&lt;/code&gt; , &lt;code&gt;&quot;server&quot;&lt;/code&gt; 등). &lt;code&gt;stats&lt;/code&gt; 테이블 에 하나의 문서 만있는 클러스터를 제외한 모든 오브젝트의 경우 두 번째 요소는 조회중인 오브젝트의 UUID입니다.</target>
        </trans-unit>
        <trans-unit id="4af84b2b5658b67fb03036b287f81c0ea4dc3b25" translate="yes" xml:space="preserve">
          <source>The table&amp;rsquo;s primary key is the &lt;code&gt;id&lt;/code&gt; field, and the keys are always arrays. The first element in the array is always a string indicating the type of job (e.g., &lt;code&gt;&quot;query&quot;&lt;/code&gt;, &lt;code&gt;&quot;disk_compaction&quot;&lt;/code&gt;, etc.); the second element is the UUID of the job. The type of job is also given in the &lt;code&gt;type&lt;/code&gt; field.</source>
          <target state="translated">테이블의 기본 키는 &lt;code&gt;id&lt;/code&gt; 필드이고 키는 항상 배열입니다. 배열의 첫 번째 요소는 항상 작업 유형을 나타내는 문자열입니다 (예 : &lt;code&gt;&quot;query&quot;&lt;/code&gt; , &lt;code&gt;&quot;disk_compaction&quot;&lt;/code&gt; 등). 두 번째 요소는 작업의 UUID입니다. 작업 유형은 &lt;code&gt;type&lt;/code&gt; 필드 에도 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="45cd12e06348bca2dd80568fa923b95cdcd2c00d" translate="yes" xml:space="preserve">
          <source>The third layers builds on the previous two and provides the user with command line and web-based tools to control the cluster.</source>
          <target state="translated">세 번째 계층은 이전 두 계층을 기반으로하며 사용자에게 클러스터를 제어하는 ​​명령 줄 및 웹 기반 도구를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f6d1631967f3c75d8b045a65b29120cdf51ee7e5" translate="yes" xml:space="preserve">
          <source>The token is a unique integer per connection. Keeping a counter per connection is a simple way to implement it.</source>
          <target state="translated">토큰은 연결 당 고유 한 정수입니다. 연결 당 카운터를 유지하는 것이 간단한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="466d055f41cbd22991febcdb9bc74645f65ffa5e" translate="yes" xml:space="preserve">
          <source>The top-level ReQL namespace.</source>
          <target state="translated">최상위 ReQL 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="b41045caf64cf3a3c5b73e63bfcd20c490c63cbe" translate="yes" xml:space="preserve">
          <source>The two most important aspects of the execution engine is that every query is completely parallelized across the cluster, and that queries are evaluated lazily. For instance, if the client requests only one document, RethinkDB will try to do just enough work to return this document, and will not process every shard in its entirety. This allows for large, complicated queries to execute in a very efficient way.</source>
          <target state="translated">실행 엔진의 가장 중요한 두 가지 측면은 모든 쿼리가 클러스터에서 완전히 병렬화되고 쿼리가 느리게 평가된다는 것입니다. 예를 들어, 클라이언트가 하나의 문서 만 요청하는 경우 RethinkDB는이 문서를 반환하기 위해 충분한 작업 만 수행하려고하지만 모든 샤드를 전체적으로 처리하지는 않습니다. 이를 통해 크고 복잡한 쿼리를 매우 효율적으로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf5d5fdab91cb54e7ea1d05ea3a02e8164908734" translate="yes" xml:space="preserve">
          <source>The type of data &lt;code&gt;binary&lt;/code&gt; accepts depends on the client language. In JavaScript, it expects a &lt;a href=&quot;http://nodejs.org&quot;&gt;Node.js&lt;/a&gt;&lt;code&gt;Buffer&lt;/code&gt;. Using a &lt;code&gt;Buffer&lt;/code&gt; object within a query implies the use of &lt;code&gt;binary&lt;/code&gt; and the ReQL driver will automatically perform the coercion.</source>
          <target state="translated">&lt;code&gt;binary&lt;/code&gt; 데이터 형식은 클라이언트 언어에 따라 다릅니다. JavaScript에서는 &lt;a href=&quot;http://nodejs.org&quot;&gt;Node.js &lt;/a&gt; &lt;code&gt;Buffer&lt;/code&gt; 합니다. 쿼리 내 에서 &lt;code&gt;Buffer&lt;/code&gt; 개체를 사용하면 &lt;code&gt;binary&lt;/code&gt; 사용 되며 ReQL 드라이버는 자동으로 강제 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7cf930814fe3eaac8532459ad55f2f6375a3b9e8" translate="yes" xml:space="preserve">
          <source>The type will be returned as a string:</source>
          <target state="translated">형식은 문자열로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5bbbb2de3860c2f10b7d816ad7baeb36022c1e11" translate="yes" xml:space="preserve">
          <source>The update command will go through every row and issue an API request to the GitHub URL for the given user, grab the relevant data, and update the user information with that data!</source>
          <target state="translated">update 명령은 모든 행을 거치며 주어진 사용자에 대한 GitHub URL에 API 요청을 발행하고 관련 데이터를 가져와 해당 데이터로 사용자 정보를 업데이트합니다!</target>
        </trans-unit>
        <trans-unit id="d6834cea4439bc5555fa593bfe010a1c4b3e8728" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;iterations&lt;/code&gt; is a tradeoff between performance and security against brute force attacks. If connections are slow, consider lowering the number of iterations. Raising the number of iterations will make it harder to use a brute force attack, but will increase the CPU usage on clients while establishing a connection.</source>
          <target state="translated">&lt;code&gt;iterations&lt;/code&gt; 의 가치 는 무차별 대입 공격에 대한 성능과 보안의 균형입니다. 연결이 느리면 반복 횟수를 줄이십시오. 반복 횟수를 늘리면 무차별 대입 공격을 사용하기가 더 어려워 지지만 연결을 설정하는 동안 클라이언트의 CPU 사용량이 증가합니다.</target>
        </trans-unit>
        <trans-unit id="c8f4326f44c3a4e70aa078a4d1ef6136197b6c59" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;connection&lt;/code&gt; is now initialized and we can run queries.</source>
          <target state="translated">변수 &lt;code&gt;connection&lt;/code&gt; 이 초기화되었으며 쿼리를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae352b30a0ea50d1839336defec725fd2135db8a" translate="yes" xml:space="preserve">
          <source>The various &lt;code&gt;on_*&lt;/code&gt; methods provide fallbacks for one another:</source>
          <target state="translated">다양한 &lt;code&gt;on_*&lt;/code&gt; 메소드는 서로 폴백을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8a205ac1eb38bfbb096a68973349763844c85250" translate="yes" xml:space="preserve">
          <source>The web UI only affects servers with the &lt;code&gt;default&lt;/code&gt; tag. If you remove the &lt;code&gt;default&lt;/code&gt; tag from a server or start it without that tag, it will not be used for tables configured through the web UI.</source>
          <target state="translated">웹 UI는 &lt;code&gt;default&lt;/code&gt; 태그 가있는 서버에만 영향을줍니다 . 서버에서 &lt;code&gt;default&lt;/code&gt; 태그 를 제거 하거나 해당 태그없이 시작하면 웹 UI를 통해 구성된 테이블에 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46633f21ecb5a76f2aebb7bf842e88c3bda5f0fe" translate="yes" xml:space="preserve">
          <source>The web UI requires &lt;code&gt;DataView&lt;/code&gt; and &lt;code&gt;Uint8Array&lt;/code&gt; JavaScript features to be supported by your browser.</source>
          <target state="translated">웹 UI를 사용하려면 브라우저에서 &lt;code&gt;DataView&lt;/code&gt; 및 &lt;code&gt;Uint8Array&lt;/code&gt; JavaScript 기능을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="19c6c96199f3171355430a94a64a0f33d4759d04" translate="yes" xml:space="preserve">
          <source>The web UI supports creation and deletion of simple secondary indexes. In the table list, click on the table &lt;code&gt;users&lt;/code&gt;. You can manipulate indexes through the secondary index panel in the table view.</source>
          <target state="translated">웹 UI는 간단한 보조 인덱스 생성 및 삭제를 지원합니다. 테이블 목록에서 테이블 &lt;code&gt;users&lt;/code&gt; 클릭하십시오 . 테이블보기의 보조 인덱스 패널을 통해 인덱스를 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="835e5ac2124d7adb55a81eefe9733c24756faad2" translate="yes" xml:space="preserve">
          <source>The web administration UI always connects as if it were the &lt;code&gt;admin&lt;/code&gt; user, and skips the authentication process (i.e., the password is not used for this connection). While the web UI cannot be password-protected, you can limit the addresses it will accept connections on using the &lt;code&gt;--bind-http&lt;/code&gt; command line option. For more details on this, review &lt;a href=&quot;../security/index#securing-the-web-interface&quot;&gt;Secure your cluster&lt;/a&gt;.</source>
          <target state="translated">웹 관리 UI는 항상이 인 것처럼 연결 &lt;code&gt;admin&lt;/code&gt; 사용자 및 인증 프로세스 (즉, 암호가이 연결에 사용되지 않는)를 건너 뜁니다. 웹 UI는 비밀번호로 보호 할 수 없지만 &lt;code&gt;--bind-http&lt;/code&gt; 명령 줄 옵션 을 사용하여 연결을 수락 할 주소를 제한 할 수 있습니다 . 이에 대한 자세한 내용은 &lt;a href=&quot;../security/index#securing-the-web-interface&quot;&gt;클러스터 보안을&lt;/a&gt; 검토 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c23b44b5fa92781014237ab0b6407a8b0dec1e43" translate="yes" xml:space="preserve">
          <source>The web interface</source>
          <target state="translated">웹 인터페이스</target>
        </trans-unit>
        <trans-unit id="e76bb2e6186f4296fdc2ce7806daa233e0129060" translate="yes" xml:space="preserve">
          <source>The wrapped query message (QueryType, serialized query and options)</source>
          <target state="translated">랩핑 된 쿼리 메시지 (QueryType, 직렬화 된 쿼리 및 옵션)</target>
        </trans-unit>
        <trans-unit id="5a9dd02e0e3fec7b03eb0481b5b9083049419d70" translate="yes" xml:space="preserve">
          <source>The wrapped query message sent to the server is an array of three elements:</source>
          <target state="translated">서버로 전송 된 랩핑 된 쿼리 메시지는 다음 세 가지 요소로 구성된 배열입니다.</target>
        </trans-unit>
        <trans-unit id="11526202a4159cbc549e507781f630a99b427910" translate="yes" xml:space="preserve">
          <source>The write acknowledgement setting for a table controls when the cluster acknowledges a write request as fulfilled. There are two possible settings:</source>
          <target state="translated">테이블에 대한 쓰기 승인 설정은 클러스터가 쓰기 요청이 이행 된 것으로 승인하는시기를 제어합니다. 가능한 두 가지 설정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="47a108c7b7e30ffc4e3685e98ee4b64f37fa6b38" translate="yes" xml:space="preserve">
          <source>Then as before, we map each post to the number &lt;code&gt;1&lt;/code&gt;. Commands after the &lt;code&gt;group&lt;/code&gt; command will be applied to each grouped set.</source>
          <target state="translated">그런 다음 이전과 같이 각 게시물을 숫자 &lt;code&gt;1&lt;/code&gt; 에 매핑합니다 . &lt;code&gt;group&lt;/code&gt; 명령 이후의 명령은 각 그룹화 된 세트에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="373f73812762c7dc46fcca04a15315b885d341a8" translate="yes" xml:space="preserve">
          <source>Then make sure to move or delete the old RethinkDB data directory (&lt;code&gt;rethinkdb_data&lt;/code&gt; by default), since the new version will not be able to read the old file.</source>
          <target state="translated">새 버전에서는 이전 파일을 읽을 수 없으므로 이전 RethinkDB 데이터 디렉토리 ( 기본적으로 &lt;code&gt;rethinkdb_data&lt;/code&gt; ) 를 이동하거나 삭제 하십시오.</target>
        </trans-unit>
        <trans-unit id="85735e42e3c49d21bec18736a350e53f8ef64177" translate="yes" xml:space="preserve">
          <source>Then open your browser:</source>
          <target state="translated">그런 다음 브라우저를여십시오.</target>
        </trans-unit>
        <trans-unit id="20dc328e896c46407854b85c49918fd88856739d" translate="yes" xml:space="preserve">
          <source>Then start RethinkDB on the second machine:</source>
          <target state="translated">그런 다음 두 번째 컴퓨터에서 RethinkDB를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="cf05db71c2c2b82022a19f45d7550290ae72ac9b" translate="yes" xml:space="preserve">
          <source>Then you can use that index in the &lt;code&gt;group&lt;/code&gt; function. This query would return the highest-value invoice for each day.</source>
          <target state="translated">그런 다음 &lt;code&gt;group&lt;/code&gt; 기능 에서 해당 색인을 사용할 수 있습니다 . 이 쿼리는 매일 가장 높은 가치의 송장을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="777999d7676c59ebd630e109f25af12b28bcb677" translate="yes" xml:space="preserve">
          <source>Then you&amp;rsquo;ll need to create the RethinkDB data directory.</source>
          <target state="translated">그런 다음 RethinkDB 데이터 디렉토리를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="61bfdd81f4b7a5981123dcfefee521c9149dc1b8" translate="yes" xml:space="preserve">
          <source>Then, copy the sample configuration file and use the &lt;a href=&quot;../config-file/index&quot;&gt;configuration file&lt;/a&gt; documentation as a guide to customize it. (If you don&amp;rsquo;t have the sample &lt;code&gt;.conf&lt;/code&gt; file, you can download it &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/packaging/assets/config/default.conf.sample&quot;&gt;here&lt;/a&gt;.)</source>
          <target state="translated">그런 다음 샘플 구성 파일을 복사하고 &lt;a href=&quot;../config-file/index&quot;&gt;구성 파일&lt;/a&gt; 문서를 안내서로 사용하여 사용자 정의하십시오. (샘플 &lt;code&gt;.conf&lt;/code&gt; 파일 이없는 경우 &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/packaging/assets/config/default.conf.sample&quot;&gt;여기에서&lt;/a&gt; 다운로드 할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="a3fb4e7ad8aef52a7890cc49ca8ea407afa881ff" translate="yes" xml:space="preserve">
          <source>Then, enable the service:</source>
          <target state="translated">그런 다음 서비스를 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="11bdef9943474cec9139375264eb2ce91de1c8ea" translate="yes" xml:space="preserve">
          <source>Then, generate a certificate, &lt;code&gt;cert.pem&lt;/code&gt;, from that key:</source>
          <target state="translated">그런 다음 해당 키에서 인증서 &lt;code&gt;cert.pem&lt;/code&gt; 을 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5ea72c2d37c2b1c37bd8b7ebe6736cad9811c2e" translate="yes" xml:space="preserve">
          <source>Then, import the RethinkDB driver:</source>
          <target state="translated">그런 다음 RethinkDB 드라이버를 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="ee598540a861f6fcc6ac7ae1337575b517fbede7" translate="yes" xml:space="preserve">
          <source>Then, restart the service:</source>
          <target state="translated">그런 다음 서비스를 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="e11ea22ba5fd48e949819f8d6852dd06f4fcead4" translate="yes" xml:space="preserve">
          <source>Then, start RethinkDB with its default options.</source>
          <target state="translated">그런 다음 기본 옵션으로 RethinkDB를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="0dc97a274d3921d7624f9e93eda6738f45944317" translate="yes" xml:space="preserve">
          <source>Then, subscribers could listen for messages with any combination of tags:</source>
          <target state="translated">그런 다음 가입자는 태그 조합을 사용하여 메시지를들을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0ff0e7a5afdd6b7af8306c4a3ef8b9cdf8beb45" translate="yes" xml:space="preserve">
          <source>Then, there are two functions for retrieving files: one to retrieve a directory of a user&amp;rsquo;s uploaded files (&lt;code&gt;getUserFileIDs&lt;/code&gt;) and one to retrieve the actual file itself (&lt;code&gt;getFile&lt;/code&gt;). We don&amp;rsquo;t have to use &lt;code&gt;binary&lt;/code&gt; again here; the ReQL driver will return the proper data type for the &lt;code&gt;file&lt;/code&gt; field in our object.</source>
          <target state="translated">그런 다음 파일을 검색하는 두 가지 기능이 있습니다. 하나는 사용자가 업로드 한 파일의 디렉토리를 검색하는 것 ( &lt;code&gt;getUserFileIDs&lt;/code&gt; )과 하나는 실제 파일 자체를 가져 오는 것입니다 ( &lt;code&gt;getFile&lt;/code&gt; ). 여기서 &lt;code&gt;binary&lt;/code&gt; 다시 사용할 필요는 없습니다 . ReQL 드라이버는 객체 의 &lt;code&gt;file&lt;/code&gt; 필드에 적절한 데이터 유형을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="3296464e11028ef43904be0c240bf019c7b106a0" translate="yes" xml:space="preserve">
          <source>Then, to listen to messages, just provide a callback to the &lt;code&gt;.subscribe()&lt;/code&gt; method on the queue:</source>
          <target state="translated">그런 다음 메시지를 들으려면 대기열 의 &lt;code&gt;.subscribe()&lt;/code&gt; 메소드에 콜백을 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="c41f2ba74cf07c786c81edddddb4f3b2805474be" translate="yes" xml:space="preserve">
          <source>Then, we add the &lt;code&gt;tableCreate&lt;/code&gt; command to create the actual table.</source>
          <target state="translated">그런 다음 &lt;code&gt;tableCreate&lt;/code&gt; 명령을 추가 하여 실제 테이블을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="fb8c1b60653312846c75686a1276635b4ed825ca" translate="yes" xml:space="preserve">
          <source>There are a couple of things to note about this query:</source>
          <target state="translated">이 쿼리에 대해 유의해야 할 사항이 몇 가지 있습니다.</target>
        </trans-unit>
        <trans-unit id="a23dd3c8cb9731a3fd1112c01afc115df9338b76" translate="yes" xml:space="preserve">
          <source>There are currently two states:</source>
          <target state="translated">현재 두 가지 상태가 있습니다.</target>
        </trans-unit>
        <trans-unit id="50ea354dfdde1a79f1cc524cc5796f0426d4d12f" translate="yes" xml:space="preserve">
          <source>There are different publish-subscribe variations, so here we&amp;rsquo;ll describe the type using a central topic exchange. In this model, publishers connect to the central exchange and broadcast a message with a given topic. When subscribers connect, they notify the exchange about what kinds of messages they&amp;rsquo;re interested in. The exchange is then responsible for filtering messages.</source>
          <target state="translated">다양한 발행-구독 변형이 있으므로 여기서는 중앙 토픽 교환을 사용하여 유형을 설명합니다. 이 모델에서 게시자는 중앙 교환기에 연결하여 주어진 주제로 메시지를 브로드 캐스트합니다. 가입자는 연결하면 관심있는 메시지 종류를 교환에 알립니다. 교환은 메시지 필터링을 담당합니다.</target>
        </trans-unit>
        <trans-unit id="5e6a261f4a90188d0d21308eb4518c242c3ee55a" translate="yes" xml:space="preserve">
          <source>There are four different permissions that can be granted to a user:</source>
          <target state="translated">사용자에게 부여 할 수있는 네 가지 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="32c898affbf2b04845b19d3ef8037b56ffc7b0d6" translate="yes" xml:space="preserve">
          <source>There are four different permissions that can be granted to an account:</source>
          <target state="translated">계정에 부여 할 수있는 네 가지 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="52482533c49305cf3ba538f7607584d817448f16" translate="yes" xml:space="preserve">
          <source>There are four kinds of jobs. The document schema is consistent between them, with job-specific data appearing in the &lt;code&gt;info&lt;/code&gt; field.</source>
          <target state="translated">4 가지 종류의 직업이 있습니다. 문서 스키마는 &lt;code&gt;info&lt;/code&gt; 필드 에 작업 별 데이터가 표시되는 상태에서 일관 됩니다.</target>
        </trans-unit>
        <trans-unit id="886bf75dd348fa061a7ef813ce2b2a8d5e1d33e4" translate="yes" xml:space="preserve">
          <source>There are more options than what we&amp;rsquo;ve covered here. Run &lt;code&gt;rethinkdb help import&lt;/code&gt; for a full list of parameters and examples.</source>
          <target state="translated">여기서 다룬 것보다 더 많은 옵션이 있습니다. 매개 변수 및 예제의 전체 목록을 보려면 &lt;code&gt;rethinkdb help import&lt;/code&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb609b83989bc8962ca574f2727ce880206e9583" translate="yes" xml:space="preserve">
          <source>There are multiple subscriptions we could have set up that would receive this news:</source>
          <target state="translated">이 뉴스를 받기 위해 설정할 수있는 여러 구독이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c38856d11ec968183c07a941fbd374de03ae8440" translate="yes" xml:space="preserve">
          <source>There are multiple ways to paginate results in RethinkDB. The most straightforward way is using &lt;code&gt;skip&lt;/code&gt; and &lt;code&gt;limit&lt;/code&gt; (similar to the way SQL&amp;rsquo;s &lt;code&gt;OFFSET&lt;/code&gt; and &lt;code&gt;LIMIT&lt;/code&gt; work), but that&amp;rsquo;s also the least efficient. It&amp;rsquo;s more efficient to use &lt;code&gt;slice&lt;/code&gt;, and even more efficient to use &lt;code&gt;between&lt;/code&gt; with a secondary index.</source>
          <target state="translated">RethinkDB에는 여러 가지 방법으로 결과 페이지를 매길 수 있습니다. 가장 간단한 방법은 &lt;code&gt;skip&lt;/code&gt; 및 &lt;code&gt;limit&lt;/code&gt; (SQL의 &lt;code&gt;OFFSET&lt;/code&gt; 및 &lt;code&gt;LIMIT&lt;/code&gt; 작동 방식과 유사)을 사용하는 것이지만 가장 효율적입니다. 그것은 사용에 더 효율적 &lt;code&gt;slice&lt;/code&gt; , 사용하기 더욱 효율적 &lt;code&gt;between&lt;/code&gt; 보조 인덱스.</target>
        </trans-unit>
        <trans-unit id="e3d0701e5c4ffb4f00017a0efde2655267d62238" translate="yes" xml:space="preserve">
          <source>There are only three useful things you can do with a time: modify it, compare it to another time, or retrieve a portion of it.</source>
          <target state="translated">한 번에 할 수있는 유용한 작업은 세 가지뿐입니다. 수정, 다른 시간과 비교 또는 일부를 검색하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="20d0f3c1694126ef828f7b9c9046e4cd07be046f" translate="yes" xml:space="preserve">
          <source>There are six optional arguments to &lt;code&gt;changes&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;changes&lt;/code&gt; 에는 6 가지 선택적 인수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dbdf1c4e79d2810c4de37e0b75ee18a93c58c48" translate="yes" xml:space="preserve">
          <source>There are some limitations and caveats on chaining with changefeeds.</source>
          <target state="translated">체인지 피드와 체인을 연결하는 데는 몇 가지 제한 사항과주의 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e894103cc8b90a96e8dfc7a000aa22e6638f5e5" translate="yes" xml:space="preserve">
          <source>There are three major sources of memory use in RethinkDB:</source>
          <target state="translated">RethinkDB에는 세 가지 주요 메모리 소스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6109eedf0d15d10946505da2e66b0a1f37da67ab" translate="yes" xml:space="preserve">
          <source>There are three primary commands for changing sharding and replication in ReQL. In addition, there are lower-level values that can be changed by manipulating &lt;a href=&quot;../system-tables/index&quot;&gt;system tables&lt;/a&gt;.</source>
          <target state="translated">ReQL에는 샤딩 및 복제를 변경하기위한 세 가지 기본 명령이 있습니다. 또한 &lt;a href=&quot;../system-tables/index&quot;&gt;시스템 테이블&lt;/a&gt; 을 조작하여 변경할 수있는 하위 레벨 값이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75c7501f6c75b26a129e17d9ac77b7c99d5158a9" translate="yes" xml:space="preserve">
          <source>There are two main methods RethinkDB provides for securing the cluster: TLS encryption for connections, and binding the ports the server uses to specific IP addresses to limit outside connections.</source>
          <target state="translated">RethinkDB가 클러스터 보안을 위해 제공하는 두 가지 주요 방법이 있습니다 : 연결을위한 TLS 암호화 및 서버가 사용하는 포트를 특정 IP 주소에 바인딩하여 외부 연결을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="f665401e538bf2bfb28ca2c473bf66cdb74afaf6" translate="yes" xml:space="preserve">
          <source>There are two optional arguments.</source>
          <target state="translated">두 가지 선택적 인수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b88a8c857155f74745bbba8371ea96ca0e6acb6" translate="yes" xml:space="preserve">
          <source>There are two ways a write operation can fail. If a write fails &lt;strong&gt;definitively,&lt;/strong&gt; no read will ever see it, even in the weaker read modes. If it fails &lt;strong&gt;indeterminately,&lt;/strong&gt; reads run in &lt;code&gt;single&lt;/code&gt; or &lt;code&gt;outdated&lt;/code&gt; modes might see it, but when the network failure or crash that caused the problem is resolved the write might or might not be rolled back. In general, writes will fail indeterminately if they were running at the exact moment when the network or server issue first happened. Both of these failures will generate errors, and you can examine the error message to see whether the failure was definitive or indeterminate.</source>
          <target state="translated">쓰기 작업이 실패 할 수있는 두 가지 방법이 있습니다. 쓰기가 &lt;strong&gt;확실하게&lt;/strong&gt; 실패 하면 더 약한 읽기 모드에서도 읽기가 표시되지 않습니다. &lt;strong&gt;불확실&lt;/strong&gt; 하게 실패하면 &lt;code&gt;single&lt;/code&gt; 또는 &lt;code&gt;outdated&lt;/code&gt; 모드로 실행 된 읽기에서 이를 읽을 수 있지만 문제를 일으킨 네트워크 장애 또는 충돌이 해결되면 쓰기가 롤백되거나 롤백되지 않을 수 있습니다. 일반적으로 네트워크 나 서버 문제가 처음 발생한 정확한 순간에 쓰기가 실행되면 결정이 실패합니다. 이러한 두 가지 오류 모두 오류를 생성하며 오류 메시지를 검사하여 오류가 결정적인지 또는 불확실한 지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="500288a5784a07d1f133215bca8ff9857c28adf3" translate="yes" xml:space="preserve">
          <source>There are two ways to model relationships between documents in RethinkDB:</source>
          <target state="translated">RethinkDB에서 문서 간 관계를 모델링하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d694c51ef35209adcd08ccf24e3a25d1dad7f109" translate="yes" xml:space="preserve">
          <source>There is little to no chance of security issues that arise from string injection attacks.</source>
          <target state="translated">문자열 주입 공격으로 인해 발생하는 보안 문제는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="40f84b9a87e9e02fe596b7aede64a1239440fef1" translate="yes" xml:space="preserve">
          <source>There is no limitation on the number of posts, so this approach is more suitable for large amounts of data.</source>
          <target state="translated">게시물 수에는 제한이 없으므로이 방법은 대량의 데이터에 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="95ebbd6e44279cc8790e0813ade721a8b8cfd992" translate="yes" xml:space="preserve">
          <source>There is no new syntax or new commands for complex queries. Once you understand the composition principle you can write new queries without learning anything else.</source>
          <target state="translated">복잡한 쿼리에 대한 새로운 구문이나 명령이 없습니다. 작성 원칙을 이해하면 다른 것을 배우지 않고도 새로운 쿼리를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="539a61fd005fdf182e291c26a8ea7bd3dde87263" translate="yes" xml:space="preserve">
          <source>There is very comprehensive documentation of &lt;a href=&quot;http://nobrainer.io/docs/querying/&quot;&gt;NoBrainer&amp;rsquo;s query language&lt;/a&gt;, and its capabilities. NoBrainer&amp;rsquo;s language is built on top of ReQL, so if you know how to do something in ReQL, it should be straightforward to translate it.</source>
          <target state="translated">&lt;a href=&quot;http://nobrainer.io/docs/querying/&quot;&gt;NoBrainer의 쿼리 언어&lt;/a&gt; 및 해당 기능에 대한 매우 포괄적 인 문서가 있습니다. NoBrainer의 언어는 ReQL을 기반으로하므로 ReQL에서 무언가를 수행하는 방법을 알고 있다면 번역하는 것이 간단해야합니다.</target>
        </trans-unit>
        <trans-unit id="df2ddd5eb9c85f2c5d0c2cdef8e0ff78782ff6a5" translate="yes" xml:space="preserve">
          <source>There will be one issue per name in conflict.</source>
          <target state="translated">충돌하는 이름마다 하나의 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="65f37cec946cc13932c02805b52c0981c77aac29" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a separate article, &lt;a href=&quot;../table-joins/index&quot;&gt;Table joins in RethinkDB&lt;/a&gt;, with much more information about the multiple-table approach, including how to do the ReQL equivalents of inner, outer and cross joins. If you aren&amp;rsquo;t sure which schema to use, ask us on &lt;a href=&quot;http://stackoverflow.com/questions/ask&quot;&gt;Stack Overflow&lt;/a&gt; or join the &lt;code&gt;#rethinkdb&lt;/code&gt; IRC channel on &lt;a href=&quot;http://www.freenode.org/&quot;&gt;Freenode&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../table-joins/index&quot;&gt;RethinkDB&lt;/a&gt; 에는 Table joins 라는 별도의 기사 가 있으며 내부, 외부 및 교차 조인의 ReQL에 해당하는 방법을 포함하여 다중 테이블 접근법에 대한 훨씬 자세한 정보가 있습니다. 어떤 스키마를 사용해야할지 확실하지 않은 경우 &lt;a href=&quot;http://stackoverflow.com/questions/ask&quot;&gt;Stack Overflow&lt;/a&gt; 에 문의 하거나 &lt;a href=&quot;http://www.freenode.org/&quot;&gt;Freenode&lt;/a&gt; 의 &lt;code&gt;#rethinkdb&lt;/code&gt; IRC 채널에 참여하십시오 .</target>
        </trans-unit>
        <trans-unit id="255b3e7dcb8b478414bde749509dfb707e256261" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s also the &lt;a href=&quot;../../../api/javascript/during/index&quot;&gt;during&lt;/a&gt; command, which can check whether a time is in a particular range of times.</source>
          <target state="translated">또한 &lt;a href=&quot;../../../api/javascript/during/index&quot;&gt;시간&lt;/a&gt; 명령이 특정 시간 범위에 있는지 여부를 확인할 수 있는 while 명령 도 있습니다.</target>
        </trans-unit>
        <trans-unit id="309e4b22505e880972a173dadd6710f8768bb239" translate="yes" xml:space="preserve">
          <source>These can be executed in the Data Explorer to try out RethinkDB&amp;rsquo;s geospatial support.</source>
          <target state="translated">이들은 데이터 탐색기에서 실행되어 RethinkDB의 지리 공간 지원을 시험해 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8c3ca286bcb01488ff4b1b7840f17718d02289a" translate="yes" xml:space="preserve">
          <source>These drivers have been updated to use the JSON driver protocol and at least RethinkDB 2.0 ReQL.</source>
          <target state="translated">이 드라이버는 JSON 드라이버 프로토콜과 최소한 RethinkDB 2.0 ReQL을 사용하도록 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="7390fee221f918304e3f706816a48b3e50189077" translate="yes" xml:space="preserve">
          <source>These drivers may not support all of RethinkDB 2.0's ReQL. However, if you wish to work with one of these languages, they may provide a good starting point.</source>
          <target state="translated">이러한 드라이버는 모든 RethinkDB 2.0 ReQL을 지원하지 않을 수 있습니다. 그러나 이러한 언어 중 하나를 사용하려면 좋은 시작점이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8830b150e94f8e0e7316103afc9f8c34e10bcc8" translate="yes" xml:space="preserve">
          <source>These entries represent queries issued by a specific client.</source>
          <target state="translated">이 항목은 특정 클라이언트가 발행 한 쿼리를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="27d43bcbccbfa2aa21ba9dc356bde61777eca619" translate="yes" xml:space="preserve">
          <source>These evaluate to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이것들은 &lt;code&gt;false&lt;/code&gt; 로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="7dd8a76f2353c0d03a4bba453817d515bf5b73aa" translate="yes" xml:space="preserve">
          <source>These examples use Python, but there&amp;rsquo;s equivalent functionality in Ruby, and any other scripting language with a RethinkDB driver updated for version 1.16 or later. Read the API documentation for more information on specific commands along with descriptions of their return values.</source>
          <target state="translated">이 예제는 Python을 사용하지만 Ruby에는 동등한 기능이 있으며 버전 1.16 이상으로 업데이트 된 RethinkDB 드라이버가있는 다른 스크립팅 언어가 있습니다. 리턴 값에 대한 설명과 함께 특정 명령에 대한 자세한 정보는 API 문서를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="bb99d9acc915cf6020285f96009c8736af483471" translate="yes" xml:space="preserve">
          <source>These may be specified as startup options to &lt;code&gt;rethinkdb&lt;/code&gt; or in the configuration file.</source>
          <target state="translated">이는 &lt;code&gt;rethinkdb&lt;/code&gt; 또는 구성 파일에서 시작 옵션으로 지정 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd1553d3431a9387915caf2bdf00cc7d8566a157" translate="yes" xml:space="preserve">
          <source>These options can be passed to the &lt;code&gt;rethinkdb&lt;/code&gt; server on the command line on startup. Many of these options can also be set in the configuration file; read &lt;a href=&quot;../config-file/index&quot;&gt;Configuration file options&lt;/a&gt; for a detailed list.</source>
          <target state="translated">이러한 옵션은 시작시 명령 행에서 &lt;code&gt;rethinkdb&lt;/code&gt; 서버 로 전달 될 수 있습니다 . 이러한 옵션 중 다수는 구성 파일에서 설정할 수도 있습니다. 자세한 목록은 &lt;a href=&quot;../config-file/index&quot;&gt;구성 파일 옵션&lt;/a&gt; 을 읽으 십시오 .</target>
        </trans-unit>
        <trans-unit id="defbae41e4dfdca69a6819f0816da9b76a0d3ef9" translate="yes" xml:space="preserve">
          <source>These tasks cannot be performed through the web interface.</source>
          <target state="translated">이러한 작업은 웹 인터페이스를 통해 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="98980261bf21bdc07626834d6ab2bd419f725534" translate="yes" xml:space="preserve">
          <source>These tasks construct secondary indexes in the background. The &lt;code&gt;progress&lt;/code&gt; field is a number between 0 and 1 indicating how far along the index construction task is.</source>
          <target state="translated">이러한 작업은 백그라운드에서 보조 인덱스를 구성합니다. &lt;code&gt;progress&lt;/code&gt; 필드는 얼마나 멀리 인덱스 건설 작업이 함께 나타내는 0과 1 사이의 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="fa32730d8deba25793d975fc9ca7bd1549b1e9a2" translate="yes" xml:space="preserve">
          <source>These will be numeric values, corresponding to the types in &lt;code&gt;ql2.proto&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ql2.proto&lt;/code&gt; 의 유형에 해당하는 숫자 값 입니다.</target>
        </trans-unit>
        <trans-unit id="86ea5ad3004c53aee816959f875903b54616b1e0" translate="yes" xml:space="preserve">
          <source>They allow clients to receive changes on a table, a single document, or even the results from a specific query as they happen. Nearly any ReQL query can be turned into a changefeed.</source>
          <target state="translated">클라이언트는 테이블, 단일 문서 또는 특정 쿼리의 결과에 대한 변경 사항을 수신 할 수 있습니다. 거의 모든 ReQL 쿼리를 변경 피드로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a73949fe5d7b6f10bad43de1b54b4ab3f1ca5501" translate="yes" xml:space="preserve">
          <source>Third-party admin tools</source>
          <target state="translated">타사 관리 도구</target>
        </trans-unit>
        <trans-unit id="b72113e83e7d2971aadeb613ad353fd5b1504f55" translate="yes" xml:space="preserve">
          <source>Third-party administration tools</source>
          <target state="translated">타사 관리 도구</target>
        </trans-unit>
        <trans-unit id="48032cfdd12c4e4801fb63f5130f887114e864cd" translate="yes" xml:space="preserve">
          <source>Third-party deployment tools</source>
          <target state="translated">타사 배포 도구</target>
        </trans-unit>
        <trans-unit id="cd38f46529ac3ba0f37dc5014c00e6b8d7818624" translate="yes" xml:space="preserve">
          <source>Third-party libraries</source>
          <target state="translated">타사 라이브러리</target>
        </trans-unit>
        <trans-unit id="9fe57a3efac3522bd52f774f6fbbf29694109b1a" translate="yes" xml:space="preserve">
          <source>Thirty-second quickstart</source>
          <target state="translated">32 초 빠른 시작</target>
        </trans-unit>
        <trans-unit id="6904ea0735b3e37923321c865579d4c8314dc798" translate="yes" xml:space="preserve">
          <source>Thirty-second quickstart with RethinkDB</source>
          <target state="translated">RethinkDB를 통한 32 초 빠른 시작</target>
        </trans-unit>
        <trans-unit id="1a3e4a37762f6f18b5db37b31335d439c9579506" translate="yes" xml:space="preserve">
          <source>This allows the &lt;code&gt;user_data&lt;/code&gt; field to contain any legal JSON value, while &lt;code&gt;name&lt;/code&gt; must still be a valid string.</source>
          <target state="translated">이를 통해 &lt;code&gt;user_data&lt;/code&gt; 필드는 유효한 JSON 값을 포함 할 수 있지만 &lt;code&gt;name&lt;/code&gt; 은 여전히 ​​유효한 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f21998ea5369dd7c67fc23e4127c7487fa1fb7d8" translate="yes" xml:space="preserve">
          <source>This article will explain how to use repubsub, as well as describe how it&amp;rsquo;s implemented on top of changefeeds. If your application needs asynchronous broadcast notifications, this may be a good fit.</source>
          <target state="translated">이 기사에서는 repubsub를 사용하는 방법과 변경 피드를 통해 repubsub를 구현하는 방법을 설명합니다. 응용 프로그램에 비동기 브로드 캐스트 알림이 필요한 경우이 방법이 적합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ab295b90534ae1ba62c82bb793079aab7adfbee" translate="yes" xml:space="preserve">
          <source>This asserts that a topic exchange named &amp;ldquo;rethinkdb&amp;rdquo; exists, and that it&amp;rsquo;s set to be non-durable. If the exchange doesn&amp;rsquo;t exist, it&amp;rsquo;ll be created. If it does exist and has different properties, an exception will occur. Being non-durable means it won&amp;rsquo;t persist across RabbitMQ restarts (this is the default).</source>
          <target state="translated">이는&amp;ldquo;rethinkdb&amp;rdquo;라는 토픽 교환이 존재하고 지속 불가능하도록 설정되어 있다고 주장합니다. 교환이 존재하지 않으면 교환이 작성됩니다. 존재하고 속성이 다른 경우 예외가 발생합니다. 내구성이 없다는 것은 RabbitMQ를 다시 시작해도 지속되지 않음을 의미합니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="b512cd11bbaeb824c3cf95df0ce1530e7c842ef2" translate="yes" xml:space="preserve">
          <source>This behavior is similar to any other safe database system. Below is a number of steps you can take to speed up insert performance in RethinkDB. Most of these guidelines will also apply to other database systems.</source>
          <target state="translated">이 동작은 다른 안전한 데이터베이스 시스템과 유사합니다. 다음은 RethinkDB에서 인서트 성능을 높이기 위해 수행 할 수있는 여러 단계입니다. 이 지침의 대부분은 다른 데이터베이스 시스템에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="82fcad98e3ebc81b03b92fbcbc2a0eb46d0e10a1" translate="yes" xml:space="preserve">
          <source>This behavior may change in the future. See &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/3992&quot;&gt;Github issue #3992&lt;/a&gt; to track the discussion.</source>
          <target state="translated">이 동작은 나중에 변경 될 수 있습니다. 토론을 추적하려면 &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/3992&quot;&gt;Github 이슈 # 3992&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d333bc0db0fbff976dd318e4e97606ee1df8cf3" translate="yes" xml:space="preserve">
          <source>This can also be used to implement a check-and-set register. The following query will atomically check whether the &lt;code&gt;check&lt;/code&gt; field is equal to &lt;code&gt;old_value&lt;/code&gt; and change it to &lt;code&gt;new_value&lt;/code&gt; if so:</source>
          <target state="translated">이것은 또한 확인 및 설정 레지스터를 구현하는 데 사용될 수 있습니다. 다음 쿼리는 원자 적 여부를 확인합니다 &lt;code&gt;check&lt;/code&gt; 필드가 동일 &lt;code&gt;old_value&lt;/code&gt; 과로 변경 &lt;code&gt;new_value&lt;/code&gt; 그렇다면 :</target>
        </trans-unit>
        <trans-unit id="136a95a3ef0f44b9424d790086bf559ff51f2e02" translate="yes" xml:space="preserve">
          <source>This can be accomplished with &lt;a href=&quot;../has_fields/index&quot;&gt;hasFields&lt;/a&gt; rather than &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">이것은으로 수행 할 수 있습니다 &lt;a href=&quot;../has_fields/index&quot;&gt;hasFields&lt;/a&gt; 보다는 &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b17f23ecff1b552fca7bbe53044ccbc70aab57b" translate="yes" xml:space="preserve">
          <source>This can be useful for diagnostic purposes, as well as for filing bug reports. The easiest way to do this is with ReQL administration commands. Any individual table can be examined with &lt;code&gt;r.db('rethinkdb').table(&amp;lt;tablename&amp;gt;)&lt;/code&gt;.</source>
          <target state="translated">이것은 버그 보고서를 제출할뿐만 아니라 진단 목적으로도 유용 할 수 있습니다. 가장 쉬운 방법은 ReQL 관리 명령을 사용하는 것입니다. &lt;code&gt;r.db('rethinkdb').table(&amp;lt;tablename&amp;gt;)&lt;/code&gt; 하여 모든 개별 테이블을 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25b50bdea1677bf9f3cc6cf1c8fe6526f3ee4558" translate="yes" xml:space="preserve">
          <source>This command will export all your data to a &lt;code&gt;tar.gz&lt;/code&gt; file named &lt;code&gt;rethinkdb_dump_&amp;lt;timestamp&amp;gt;.tar.gz&lt;/code&gt; (this may vary depending on your platform).</source>
          <target state="translated">이 명령은 모든 데이터를 &lt;code&gt;rethinkdb_dump_&amp;lt;timestamp&amp;gt;.tar.gz&lt;/code&gt; 라는 &lt;code&gt;tar.gz&lt;/code&gt; 파일 로 내 보냅니다 (플랫폼에 따라 다를 수 있음).</target>
        </trans-unit>
        <trans-unit id="de554f35b082125ac3ff33b85f9132341445f97f" translate="yes" xml:space="preserve">
          <source>This document describes how to start RethinkDB from the command line in several configurations, from a single instance on one machine to multiple instances on multiple machines.</source>
          <target state="translated">이 문서는 한 시스템의 단일 인스턴스에서 여러 시스템의 여러 인스턴스에 이르기까지 여러 구성의 명령 줄에서 RethinkDB를 시작하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="884a0999d1995cf78ebbbf8b08f0bb1e21cc671c" translate="yes" xml:space="preserve">
          <source>This document explains how to set up RethinkDB to run as a system service on supported operating systems, automatically launching on boot. For general instructions on starting RethinkDB, see &lt;a href=&quot;../start-a-server/index&quot;&gt;Start a RethinkDB server&lt;/a&gt;.</source>
          <target state="translated">이 문서는 지원되는 운영 체제에서 시스템 서비스로 실행되도록 RethinkDB를 설정하여 부팅시 자동으로 시작하는 방법을 설명합니다. RethinkDB 시작에 대한 일반적인 지시 사항 &lt;a href=&quot;../start-a-server/index&quot;&gt;은 RethinkDB 서버 시작을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5e112ab270acffb2e520b045d4086e0a4758065b" translate="yes" xml:space="preserve">
          <source>This example in the Data Explorer demonstrates sorting mixed types:</source>
          <target state="translated">데이터 탐색기의이 예제는 혼합 유형 정렬을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f60ec41c0244bc4bf79f1ba740c162008674fd3a" translate="yes" xml:space="preserve">
          <source>This example renames the field &lt;code&gt;id&lt;/code&gt; to &lt;code&gt;userId&lt;/code&gt; when retrieving documents from the table &lt;code&gt;users&lt;/code&gt;.</source>
          <target state="translated">이 예 에서는 테이블 &lt;code&gt;users&lt;/code&gt; 에서 문서를 검색 할 때 필드 &lt;code&gt;id&lt;/code&gt; 이름 을 &lt;code&gt;userId&lt;/code&gt; 로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="05d221d0dc27530f067ff5358c8a277dc571c798" translate="yes" xml:space="preserve">
          <source>This grant can only be given on a global level.</source>
          <target state="translated">이 보조금은 글로벌 수준에서만 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="badcd4b2105b2f046863005ef03daa5e931fc0ec" translate="yes" xml:space="preserve">
          <source>This is &lt;em&gt;required&lt;/em&gt; if you&amp;rsquo;re upgrading from versions before 1.16; in those cases, you&amp;rsquo;ll need to upgrade to version 2.0.5 first. (You can download 2.0.5 and other older versions at RethinkDB&amp;rsquo;s &lt;a href=&quot;http://download.rethinkdb.com&quot;&gt;download archive&lt;/a&gt;). If you&amp;rsquo;re upgrading from RethinkDB version 1.16 or later, you can move to 2.2 or higher directly.</source>
          <target state="translated">이다 &lt;em&gt;필요한&lt;/em&gt; 당신이 1.16 이전 버전의 업그레이드 인 경우; 이 경우 먼저 버전 2.0.5로 업그레이드해야합니다. RethinkDB의 &lt;a href=&quot;http://download.rethinkdb.com&quot;&gt;다운로드 아카이브&lt;/a&gt; 에서 2.0.5 및 기타 이전 버전을 다운로드 할 수 있습니다 . RethinkDB 버전 1.16 이상에서 업그레이드하는 경우 2.2 이상으로 직접 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7690a03a80d488dfd784992d260be51267e9cf4b" translate="yes" xml:space="preserve">
          <source>This is a list of commands for updating data in the database.</source>
          <target state="translated">데이터베이스에서 데이터를 업데이트하기위한 명령 목록입니다.</target>
        </trans-unit>
        <trans-unit id="4094879dcd891fd3d505701f441b8c1edcdeb065" translate="yes" xml:space="preserve">
          <source>This is a list of queries for creating and dropping tables and databases.</source>
          <target state="translated">테이블 및 데이터베이스를 작성 및 삭제하기위한 쿼리 목록입니다.</target>
        </trans-unit>
        <trans-unit id="66b57e4c31062f253f74d06daaee496d81b79de2" translate="yes" xml:space="preserve">
          <source>This is a list of queries for deleting data from the database.</source>
          <target state="translated">데이터베이스에서 데이터를 삭제하기위한 쿼리 목록입니다.</target>
        </trans-unit>
        <trans-unit id="9db9a6dffeb553d1c76935d872aff66778ce1499" translate="yes" xml:space="preserve">
          <source>This is a list of queries for inserting data into a database.</source>
          <target state="translated">데이터베이스에 데이터를 삽입하기위한 쿼리 목록입니다.</target>
        </trans-unit>
        <trans-unit id="24cb2d221d2ccf3805e7df7390075b15277b1ff8" translate="yes" xml:space="preserve">
          <source>This is a list of queries for performing data aggregation.</source>
          <target state="translated">데이터 집계를 수행하기위한 쿼리 목록입니다.</target>
        </trans-unit>
        <trans-unit id="57255ff40e07d35053520b96ede5ad2090e4b64c" translate="yes" xml:space="preserve">
          <source>This is a list of queries for performing joins between multiple tables.</source>
          <target state="translated">여러 테이블간에 조인을 수행하기위한 쿼리 목록입니다.</target>
        </trans-unit>
        <trans-unit id="61a4e6ed605b06ae73e9999bd507404c4f0f7b89" translate="yes" xml:space="preserve">
          <source>This is a list of queries for selecting data out of a database.</source>
          <target state="translated">데이터베이스에서 데이터를 선택하기위한 쿼리 목록입니다.</target>
        </trans-unit>
        <trans-unit id="c950bfcba327ffdf5a9d2f1ecf0f9730e6174c18" translate="yes" xml:space="preserve">
          <source>This is a typical document schema for a server connected to the host server&amp;mdash;that is, the server the client&amp;rsquo;s connecting to when they query the &lt;code&gt;server_status&lt;/code&gt; table.</source>
          <target state="translated">이것은 호스트 서버에 연결된 서버, 즉 &lt;code&gt;server_status&lt;/code&gt; 테이블 을 쿼리 할 때 클라이언트가 연결하는 서버에 대한 일반적인 문서 스키마입니다 .</target>
        </trans-unit>
        <trans-unit id="495c13e74882e8a9b4dbc7d70144d347e8f36bb0" translate="yes" xml:space="preserve">
          <source>This is an ongoing task on each server, compacting RethinkDB&amp;rsquo;s storage space in the background. The &lt;code&gt;duration_sec&lt;/code&gt; field will always be &lt;code&gt;null&lt;/code&gt;, and there is no extra information metadata.</source>
          <target state="translated">이는 각 서버에서 진행중인 작업으로 백그라운드에서 RethinkDB의 저장 공간을 압축합니다. &lt;code&gt;duration_sec&lt;/code&gt; 필드는 항상있을 것 &lt;code&gt;null&lt;/code&gt; , 어떠한 추가 정보 메타 데이터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="744bd55da05671572fd0681cdeaea849a2d47d17" translate="yes" xml:space="preserve">
          <source>This is an overview of the system. For more details, consult the API documentation for individual geospatial commands.</source>
          <target state="translated">시스템 개요입니다. 자세한 내용은 개별 지리 공간 명령에 대한 API 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9df7168c66a6de94c891ac3113c4fa363d86ea95" translate="yes" xml:space="preserve">
          <source>This is analogous to using &lt;strong&gt;apply&lt;/strong&gt; in JavaScript. (However, note that &lt;code&gt;args&lt;/code&gt; evaluates all its arguments before passing them into the parent term, even if the parent term otherwise allows lazy evaluation.)</source>
          <target state="translated">이것은 JavaScript에서 &lt;strong&gt;apply&lt;/strong&gt; 를 사용하는 것과 유사합니다 . 그러나 인수가 게으른 평가를 허용하는 경우에도 &lt;code&gt;args&lt;/code&gt; 는 모든 인수를 상위 용어로 전달하기 전에 평가합니다.</target>
        </trans-unit>
        <trans-unit id="e6bc537c2149375b9bb8ea0948f4cb1e620a73ea" translate="yes" xml:space="preserve">
          <source>This is based on an example from &lt;a href=&quot;http://docs.mongodb.org/manual/tutorial/map-reduce-examples/&quot;&gt;MongoDB&lt;/a&gt;. Imagine a table of orders, with each document in the table structured like this:</source>
          <target state="translated">이것은 &lt;a href=&quot;http://docs.mongodb.org/manual/tutorial/map-reduce-examples/&quot;&gt;MongoDB&lt;/a&gt; 의 예제를 기반으로합니다 . 테이블의 각 문서가 다음과 같이 구성되어있는 주문 테이블을 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="55687884bd6d8ee24ca5745c354a05190fdf9d33" translate="yes" xml:space="preserve">
          <source>This is equivalent to calling &lt;code&gt;SELECT name, age FROM users&lt;/code&gt; in SQL.</source>
          <target state="translated">이는 SQL에서 &lt;code&gt;SELECT name, age FROM users&lt;/code&gt; 을 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7fda8e7fa70fba551ec9a5ec7d7a2bfb32969507" translate="yes" xml:space="preserve">
          <source>This is equivalent to using the &lt;code&gt;db&lt;/code&gt; command to specify the database:</source>
          <target state="translated">&lt;code&gt;db&lt;/code&gt; 명령을 사용하여 데이터베이스를 지정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d3bb2a306948c13f0ac184c0266661dd1de824fb" translate="yes" xml:space="preserve">
          <source>This is the alphabetical order of their type name as returned by the &lt;code&gt;typeOf()&lt;/code&gt; command. (Binary objects, geometry objects and times are &amp;ldquo;pseudotypes,&amp;rdquo; and return &lt;code&gt;PTYPE&amp;lt;BINARY&amp;gt;&lt;/code&gt;, &lt;code&gt;PTYPE&amp;lt;GEOMETRY&amp;gt;&lt;/code&gt; and &lt;code&gt;PTYPE&amp;lt;TIME&amp;gt;&lt;/code&gt;, respectively.)</source>
          <target state="translated">&lt;code&gt;typeOf()&lt;/code&gt; 명령에 의해 반환되는 유형 이름의 알파벳 순서입니다 . 이진 객체, 기하 객체 및 시간은 &quot;의사 유형&quot;이며 각각 &lt;code&gt;PTYPE&amp;lt;BINARY&amp;gt;&lt;/code&gt; , &lt;code&gt;PTYPE&amp;lt;GEOMETRY&amp;gt;&lt;/code&gt; 및 &lt;code&gt;PTYPE&amp;lt;TIME&amp;gt;&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e85848e3ad69e8a64cb4101d0c2be64cba8259e9" translate="yes" xml:space="preserve">
          <source>This is the equivalent of the following:</source>
          <target state="translated">이것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3c3b90ecc4bbe7e0c4ecc1bb9f83e2950a385f51" translate="yes" xml:space="preserve">
          <source>This issue will appear at most once for each server.</source>
          <target state="translated">이 문제는 각 서버마다 최대 한 번 나타납니다.</target>
        </trans-unit>
        <trans-unit id="77ccacb7783df82d612f51e347348c7a7db7d8ce" translate="yes" xml:space="preserve">
          <source>This issue will appear at most once for each table.</source>
          <target state="translated">이 문제는 각 테이블마다 최대 한 번 나타납니다.</target>
        </trans-unit>
        <trans-unit id="747341dedcda6a869995253b4dbc7ba5a4018242" translate="yes" xml:space="preserve">
          <source>This issue will only appear in the &lt;code&gt;current_issues&lt;/code&gt; table once&amp;mdash;check the &lt;code&gt;info&lt;/code&gt; field for the tables and indexes it affects.</source>
          <target state="translated">이 문제는 &lt;code&gt;current_issues&lt;/code&gt; 테이블 에만 한 번만 나타납니다 . 영향을받는 테이블 및 인덱스 의 &lt;code&gt;info&lt;/code&gt; 필드를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ebc8aa4d2f21780ed5017f2917975404a143a19" translate="yes" xml:space="preserve">
          <source>This just creates a new &lt;code&gt;Comment&lt;/code&gt; and associates it with the current &lt;code&gt;Article&lt;/code&gt;, rather than using the &lt;code&gt;build&lt;/code&gt; method.</source>
          <target state="translated">이것은 단지 새로운 &lt;code&gt;Comment&lt;/code&gt; 를 작성 하고 &lt;code&gt;build&lt;/code&gt; 메소드를 사용하지 않고 현재 &lt;code&gt;Article&lt;/code&gt; 과 연관시킵니다 .</target>
        </trans-unit>
        <trans-unit id="0461d690717cd0e6df210318899cac20104d6444" translate="yes" xml:space="preserve">
          <source>This may also be specified in the &lt;a href=&quot;http://rethinkdb.com/docs/cluster-on-startup/&quot;&gt;config file&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;http://rethinkdb.com/docs/cluster-on-startup/&quot;&gt;구성 파일&lt;/a&gt; 에서 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2227c47b8b5a4f6a718999ee7cef861b0123236c" translate="yes" xml:space="preserve">
          <source>This may show you messages similar to this:</source>
          <target state="translated">다음과 유사한 메시지가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26ab6e368431d7927f2a04b793ec9f220536744c" translate="yes" xml:space="preserve">
          <source>This means that every read will see every previous successful write, and no read will ever see a definitively failed write. (See note about definitively failed vs. indeterminate writes below.)</source>
          <target state="translated">즉, 모든 읽기는 이전의 모든 성공적인 쓰기를 볼 수 있으며, 읽기가 확실히 실패한 쓰기를 볼 수는 없습니다. (아래의 결정적 실패와 불확실한 쓰기에 대한 참고 사항을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="6116a33e3ee4eebf769e234ae37a3a28895b7e1c" translate="yes" xml:space="preserve">
          <source>This message indicates there are currently servers that cannot see every server in the cluster. This may cause table availability issues. It can be resolved by restoring full connectivity.</source>
          <target state="translated">이 메시지는 현재 클러스터의 모든 서버를 볼 수없는 서버가 있음을 나타냅니다. 테이블 가용성 문제가 발생할 수 있습니다. 전체 연결을 복원하여 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6c5c2546366708a269614bdd6393853b3b25fd1" translate="yes" xml:space="preserve">
          <source>This message is a warning that a &lt;a href=&quot;https://en.wikipedia.org/wiki/Paging&quot;&gt;page fault&lt;/a&gt; has occurred on a RethinkDB server and swap space is being used. Under Linux, this message will only appear if a RethinkDB process has started paging memory; under OS X, it will appear when &lt;em&gt;any&lt;/em&gt; process is paging. The Windows version of RethinkDB cannot detect when paging occurs.</source>
          <target state="translated">이 메시지는 RethinkDB 서버에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Paging&quot;&gt;페이지 오류&lt;/a&gt; 가 발생하여 스왑 공간이 사용되고 있다는 경고입니다 . Linux에서이 메시지는 RethinkDB 프로세스가 메모리 페이징을 시작한 경우에만 나타납니다. 때 OS X에서, 그것은 나타납니다 &lt;em&gt;어떤&lt;/em&gt; 프로세스가 페이징입니다. 페이징이 발생하면 Windows 버전의 RethinkDB가 감지 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5d4bf8bcc88e1e23ef0b9f22469b4f4fd3e521e9" translate="yes" xml:space="preserve">
          <source>This mode is &lt;strong&gt;not as safe&lt;/strong&gt; as the default hard durability mode. If you&amp;rsquo;re writing using soft durability, a few seconds worth of data might be lost in case of power failure.</source>
          <target state="translated">이 모드는 기본 하드 내구성 모드 &lt;strong&gt;만큼 안전하지 않습니다&lt;/strong&gt; . 부드러운 내구성을 사용하여 쓰는 경우 정전시 몇 초 분량의 데이터가 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03bae79890f9931111f7596cfde45eef26137817" translate="yes" xml:space="preserve">
          <source>This object is not a connection, but a cursor. To retrieve the results, you can call &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;each&lt;/code&gt; or &lt;code&gt;toArray&lt;/code&gt; on this object.</source>
          <target state="translated">이 개체는 연결이 아니라 커서입니다. 결과를 검색하려면 이 객체에서 &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;each&lt;/code&gt; 또는 &lt;code&gt;toArray&lt;/code&gt; 를 호출하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="3c94199271f50662dc6a036ee949c151bf137f34" translate="yes" xml:space="preserve">
          <source>This opens up the possibility of notifying client applications immediately when a change occurs in a table. For real-time applications, this push behavior is essential.</source>
          <target state="translated">테이블에서 변경이 발생하면 즉시 클라이언트 응용 프로그램에 알릴 가능성이 있습니다. 실시간 애플리케이션의 경우이 푸시 동작이 필수적입니다.</target>
        </trans-unit>
        <trans-unit id="003d171c060f2713ec6326d898756333da62b72f" translate="yes" xml:space="preserve">
          <source>This option creates a random password for that server&amp;rsquo;s &lt;code&gt;admin&lt;/code&gt; account. Once that server is synchronized with the cluster, the random password will be overwritten by the &lt;code&gt;admin&lt;/code&gt; password, preventing the exploit described above.</source>
          <target state="translated">이 옵션은 해당 서버의 &lt;code&gt;admin&lt;/code&gt; 계정에 대한 임의의 비밀번호를 만듭니다 . 해당 서버가 클러스터와 동기화되면 &lt;code&gt;admin&lt;/code&gt; 암호로 임의의 암호를 덮어 쓰므로 위에서 설명한 악용을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35f047d23d5560efaf4283d83fa25adfdafd890c" translate="yes" xml:space="preserve">
          <source>This particular example simply returns the error message, so it isn&amp;rsquo;t very useful. But it would be possible to change the default value based on the specific error message thrown.</source>
          <target state="translated">이 특정 예제는 단순히 오류 메시지를 반환하므로 그다지 유용하지 않습니다. 그러나 발생 된 특정 오류 메시지에 따라 기본값을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="713c8d0837ca1d19105b3bc382212f39c5333371" translate="yes" xml:space="preserve">
          <source>This query can be rewritten with the &lt;code&gt;each&lt;/code&gt; command:</source>
          <target state="translated">이 쿼리는 &lt;code&gt;each&lt;/code&gt; 명령 으로 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd2d49b6729659af5432ba9236e6221e72845b7c" translate="yes" xml:space="preserve">
          <source>This query joins the &lt;code&gt;company_id&lt;/code&gt; of the employee table with the primary key of the company table. It returns a sequence of documents where each document contains two fields&amp;mdash;the employee information and the company information:</source>
          <target state="translated">이 쿼리는 직원 테이블 의 &lt;code&gt;company_id&lt;/code&gt; 를 회사 테이블의 기본 키와 조인 합니다. 각 문서에 직원 정보와 회사 정보라는 두 가지 필드가 포함 된 일련의 문서를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="612f4e9545d8bc014df5735c54ea0dbe678cc103" translate="yes" xml:space="preserve">
          <source>This query looks just like any other Python code you would normally write. Note that RethinkDB will execute this query on the server, and it doesn&amp;rsquo;t execute native Python code.</source>
          <target state="translated">이 쿼리는 일반적으로 작성하는 다른 파이썬 코드와 비슷합니다. RethinkDB는 서버에서이 쿼리를 실행하며 기본 Python 코드는 실행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd03b43a9a0662e67f4621af412284eaccf6bc7d" translate="yes" xml:space="preserve">
          <source>This query makes a call to GitHub and returns an array of JSON documents. RethinkDB natively operates on JSON, and what&amp;rsquo;s really convenient about &lt;code&gt;r.http&lt;/code&gt; is that its output is no different from any other query. You can use ReQL commands to perform operations on the output of &lt;code&gt;r.http&lt;/code&gt;, just like on a standard RethinkDB table!</source>
          <target state="translated">이 쿼리는 GitHub를 호출하고 JSON 문서 배열을 반환합니다. RethinkDB는 기본적으로 JSON에서 작동하며 r.http에서 가장 편리한 것은 출력이 다른 쿼리와 다르지 &lt;code&gt;r.http&lt;/code&gt; 것입니다. 당신의 출력에 작업을 수행 할 수 ReQL 명령을 사용할 수 있습니다 &lt;code&gt;r.http&lt;/code&gt; 단지 표준 RethinkDB 테이블처럼!</target>
        </trans-unit>
        <trans-unit id="c1ed5db3f58d8d8a4a7b6fd0156d19d27037316d" translate="yes" xml:space="preserve">
          <source>This query pulls out &lt;code&gt;new_val&lt;/code&gt; from the changefeed, and passes just the topic field from the new value down to the subscriber&amp;rsquo;s function.</source>
          <target state="translated">이 쿼리는 변경 &lt;code&gt;new_val&lt;/code&gt; 에서 new_val 을 가져 와서 주제 필드 만 새 값에서 구독자 함수로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="0504572bb7932c5f61e74e74594395b17470a17e" translate="yes" xml:space="preserve">
          <source>This query returns a cursor with one document&amp;mdash;the record for William Adama. The &lt;code&gt;filter&lt;/code&gt; command evaluates the provided condition for every row in the table, and returns only the relevant rows. Here&amp;rsquo;s the new commands we used to construct the condition above:</source>
          <target state="translated">이 쿼리는 하나의 문서 (William Adama에 대한 레코드)가있는 커서를 리턴합니다. &lt;code&gt;filter&lt;/code&gt; 명령은 테이블의 모든 행에 대해 제공된 상태를 평가하고 만 관련 행을 반환합니다. 위의 조건을 구성하는 데 사용한 새로운 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d6039c10afb25b25847b1d9787b22376a9ca0b91" translate="yes" xml:space="preserve">
          <source>This range includes all compound keys:</source>
          <target state="translated">이 범위에는 모든 복합 키가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7b1dd23beb1a551a08393d66db64399a66756207" translate="yes" xml:space="preserve">
          <source>This report describes a recent effort that the RethinkDB team took to measure our database product, RethinkDB, under different workloads and in different clustering configurations. We seek to provide a general overview of RethinkDB&amp;rsquo;s performance metrics for a variety of workloads and potential use cases. In this report some of the questions we&amp;rsquo;ll address include:</source>
          <target state="translated">이 보고서는 RethinkDB 팀이 다양한 워크로드 및 클러스터링 구성에서 데이터베이스 제품 RethinkDB를 측정하기 위해 최근에 수행 한 노력에 대해 설명합니다. 다양한 워크로드 및 잠재적 사용 사례에 대한 RethinkDB의 성능 지표에 대한 일반적인 개요를 제공하고자합니다. 이 보고서에는 다음과 같은 몇 가지 질문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbf7d676994679d10fb326236fe98c7d7b06ae4d" translate="yes" xml:space="preserve">
          <source>This table returns information about the status and availability of servers within a RethinkDB cluster. A single document is created for each server that connects to the cluster. If a server loses its connection to the cluster, it will be removed from the &lt;code&gt;server_status&lt;/code&gt; table.</source>
          <target state="translated">이 테이블은 RethinkDB 클러스터 내 서버의 상태 및 가용성에 대한 정보를 리턴합니다. 클러스터에 연결된 각 서버마다 단일 문서가 작성됩니다. 서버와 클러스터의 연결이 끊어지면 &lt;code&gt;server_status&lt;/code&gt; 테이블 에서 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b1ac2a2ea0485ae1d2247b1c116a2c2f4acddb6" translate="yes" xml:space="preserve">
          <source>This table shows problems that have been detected within the RethinkDB cluster. For details, read the &lt;a href=&quot;../system-issues/index&quot;&gt;System current issues table&lt;/a&gt; documentation.</source>
          <target state="translated">이 테이블은 RethinkDB 클러스터에서 발견 된 문제점을 보여줍니다. 자세한 내용은 &lt;a href=&quot;../system-issues/index&quot;&gt;시스템 현재 문제 테이블&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9a58322ca86137de68e645fd6b69456345f7a1c8" translate="yes" xml:space="preserve">
          <source>This table stores information about table availability. There is one document per table (not counting system tables).</source>
          <target state="translated">이 테이블은 테이블 가용성에 대한 정보를 저장합니다. 테이블 당 하나의 문서가 있습니다 (시스템 테이블을 세지 않음).</target>
        </trans-unit>
        <trans-unit id="700035ba5743d362d312992febe3cdb4c2d32eca" translate="yes" xml:space="preserve">
          <source>This table stores the log files of the cluster. One row is added to the table for each log message generated by &lt;em&gt;each&lt;/em&gt; server that&amp;rsquo;s connected to the cluster. A maximum of 1000 entries will be stored for each server.</source>
          <target state="translated">이 테이블은 클러스터의 로그 파일을 저장합니다. 클러스터에 연결된 &lt;em&gt;각&lt;/em&gt; 서버에서 생성 된 &lt;em&gt;각&lt;/em&gt; 로그 메시지에 대해 하나의 행이 테이블에 추가됩니다 . 각 서버 당 최대 1000 개의 항목이 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="7d26d8d3a47febb845fda047336c8a95a95ed440" translate="yes" xml:space="preserve">
          <source>This table stores the names of servers along with their &lt;em&gt;tags.&lt;/em&gt; Server tags organize servers into logical groups: servers could be tagged by usage (database, application, etc.), or by data center location (&amp;ldquo;us_west,&amp;rdquo; &amp;ldquo;us_east,&amp;rdquo; &amp;ldquo;london,&amp;rdquo; and so on). For more about server tags, read &lt;a href=&quot;../sharding-and-replication/index&quot;&gt;Sharding and replication&lt;/a&gt;.</source>
          <target state="translated">이 테이블은 서버 이름과 해당 &lt;em&gt;태그를&lt;/em&gt; 저장합니다 &lt;em&gt;. &lt;/em&gt;서버 태그는 서버를 논리 그룹으로 구성합니다. 서버는 사용량 (데이터베이스, 응용 프로그램 등) 또는 데이터 센터 위치 (&amp;ldquo;us_west&amp;rdquo;,&amp;ldquo;us_east,&amp;rdquo;&amp;ldquo;london 등&amp;rdquo;)에 따라 태그를 지정할 수 있습니다. 서버 태그에 대한 자세한 내용은 &lt;a href=&quot;../sharding-and-replication/index&quot;&gt;샤딩 및 복제를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b24cf5174181e90b5c8aafe2f4e0730440af51a1" translate="yes" xml:space="preserve">
          <source>This technology has limitations. While most operations allow you to write familiar code, you can&amp;rsquo;t use native language&amp;rsquo;s operations that have side effects (such as &lt;code&gt;print&lt;/code&gt;) or control blocks (such as &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;for&lt;/code&gt;). Instead, you have to use alternative ReQL commands:</source>
          <target state="translated">이 기술에는 한계가 있습니다. 대부분의 작업은 당신이 잘 알고 코드를 작성할 수 있지만, 당신은 측면 (예 : 효과가 모국어의 작업에 사용할 수 없습니다 &lt;code&gt;print&lt;/code&gt; ) 또는 제어 블록 (예 : &lt;code&gt;if&lt;/code&gt; 와 &lt;code&gt;for&lt;/code&gt; ). 대신 다른 ReQL 명령을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="645d6109bf848329c6f455ed5bcf791cd5d05962" translate="yes" xml:space="preserve">
          <source>This will bind the HTTP and driver ports on all available interfaces, while the cluster port will only be bound on the loopback interface and &lt;code&gt;192.168.0.1&lt;/code&gt;.</source>
          <target state="translated">클러스터 포트는 루프백 인터페이스와 &lt;code&gt;192.168.0.1&lt;/code&gt; 에서만 바인드되는 반면 사용 가능한 모든 인터페이스에서 HTTP 및 드라이버 포트를 바인드합니다 .</target>
        </trans-unit>
        <trans-unit id="7be68a47df33c85c24d05535e067d92117013277" translate="yes" xml:space="preserve">
          <source>This will create the following model for comments:</source>
          <target state="translated">주석에 대한 다음 모델이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="bd972f0112cecc4dacfc67ccb7c54818c2630b9e" translate="yes" xml:space="preserve">
          <source>This will deserialize the change message, and pretty print it, along with a short description of what kind of change it is.</source>
          <target state="translated">이것은 변경 메시지를 역 직렬화하고 어떤 종류의 변경에 대한 간단한 설명과 함께 예쁜 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="2da799672b875bde58a2e844c9e9c6c18c1febf6" translate="yes" xml:space="preserve">
          <source>This will fail if the &lt;code&gt;notes&lt;/code&gt; field does not exist in the document. To perform this as an &amp;ldquo;upsert&amp;rdquo; (update or insert), use the &lt;a href=&quot;../default/index&quot;&gt;default&lt;/a&gt; command to ensure the field is initialized as an empty list.</source>
          <target state="translated">&lt;code&gt;notes&lt;/code&gt; 필드가 문서에 없으면 실패합니다 . 이를 &quot;업 서트&quot;(업데이트 또는 삽입)로 수행하려면 &lt;a href=&quot;../default/index&quot;&gt;기본&lt;/a&gt; 명령을 사용하여 필드가 빈 목록으로 초기화되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="d6dd0bebb08581cc718c11f050b164f60dd94ee5" translate="yes" xml:space="preserve">
          <source>This will override the &lt;code&gt;write: true&lt;/code&gt; permissions granted in the first example, but for this table only. Other tables in the &lt;code&gt;users&lt;/code&gt; database will inherit from the database permissions.</source>
          <target state="translated">첫 번째 예제에서 부여 된 &lt;code&gt;write: true&lt;/code&gt; 권한 을 무시 하지만이 테이블에만 적용됩니다. &lt;code&gt;users&lt;/code&gt; 데이터베이스의 다른 테이블 은 데이터베이스 권한에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="7a527a2cb141bcf68e0849631dd72491cfe72328" translate="yes" xml:space="preserve">
          <source>This will return a result set such as the following:</source>
          <target state="translated">다음과 같은 결과 집합이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7974561d2e44ebf7a89c5cbd490575ef1cd12a6b" translate="yes" xml:space="preserve">
          <source>This will return a result similar to:</source>
          <target state="translated">결과는 다음과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="7b09d7bf2c5573de92a708dc2698ffe91aec72af" translate="yes" xml:space="preserve">
          <source>This workload exclusively performs read operations to retrieve individual documents from the database (YCSB workload C). In this workload, we use the same setup and data set as workload A above. Reads are also performed identically using 8 client servers with 128 concurrent connections per database server in the cluster.</source>
          <target state="translated">이 워크로드는 독점적으로 읽기 작업을 수행하여 데이터베이스에서 개별 문서를 검색합니다 (YCSB 워크로드 C). 이 워크로드에서는 위의 워크로드 A와 동일한 설정 및 데이터 세트를 사용합니다. 또한 클러스터의 데이터베이스 서버 당 128 개의 동시 연결이있는 8 개의 클라이언트 서버를 사용하여 읽기가 동일하게 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="15a00ec912a3416fb1d64828fe342fae918688b8" translate="yes" xml:space="preserve">
          <source>This would be serialized as:</source>
          <target state="translated">이것은 다음과 같이 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="c0a2cb70deba71b04f648c048262a358d25fe6fc" translate="yes" xml:space="preserve">
          <source>This yields the following model in &lt;code&gt;app/models/article.rb&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;app/models/article.rb&lt;/code&gt; 에 다음 모델이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="743fc98678fa343fac71fe0aeddfa10f7343ab41" translate="yes" xml:space="preserve">
          <source>Three or more &lt;a href=&quot;../point/index&quot;&gt;Point&lt;/a&gt; objects specifying the polygon&amp;rsquo;s vertices.</source>
          <target state="translated">다각형의 정점을 지정하는 3 개 이상의 &lt;a href=&quot;../point/index&quot;&gt;Point&lt;/a&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="8060e8f9e58e7d9250d13fd0e26c17e27cbffa62" translate="yes" xml:space="preserve">
          <source>Three or more &lt;a href=&quot;point/index&quot;&gt;Point&lt;/a&gt; objects specifying the polygon&amp;rsquo;s vertices.</source>
          <target state="translated">다각형의 정점을 지정하는 3 개 이상의 &lt;a href=&quot;point/index&quot;&gt;Point&lt;/a&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="c6910e95d75d06c9f63a498f4fb6811b580000e6" translate="yes" xml:space="preserve">
          <source>Three or more two-item arrays, specifying latitude and longitude numbers of the polygon&amp;rsquo;s vertices;</source>
          <target state="translated">다각형 정점의 위도 및 경도 수를 지정하는 3 개 이상의 2 개 항목 배열.</target>
        </trans-unit>
        <trans-unit id="16a9f47918b7ae16f0a1bea2bdc77c1f72578e59" translate="yes" xml:space="preserve">
          <source>Three settings control consistency and durability in RethinkDB: write acknowledgements and durability per table, and the query read mode.</source>
          <target state="translated">RethinkDB의 세 가지 설정은 일관성 및 내구성을 제어합니다. 테이블 당 쓰기 승인 및 내구성 및 쿼리 읽기 모드입니다.</target>
        </trans-unit>
        <trans-unit id="9c56bf83063cedaf9e42b20360c4e018d13f5da0" translate="yes" xml:space="preserve">
          <source>Throw a runtime error. If called with no arguments inside the second argument to &lt;code&gt;default&lt;/code&gt;, re-throw the current error.</source>
          <target state="translated">런타임 오류가 발생합니다. &lt;code&gt;default&lt;/code&gt; 에 대한 두 번째 인수 안에 인수없이 호출 된 경우 현재 오류를 다시 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="7f35dd2cbf5aff9146859bee96606edf5a8c2413" translate="yes" xml:space="preserve">
          <source>Thus, &lt;code&gt;on_val&lt;/code&gt; acts a &amp;ldquo;catch-all&amp;rdquo; for any data that is not handled by a more specific method.</source>
          <target state="translated">따라서 &lt;code&gt;on_val&lt;/code&gt; 은보다 구체적인 방법으로 처리되지 않은 모든 데이터에 대해&amp;ldquo;캐치 올 (catch-all)&amp;rdquo;역할을합니다.</target>
        </trans-unit>
        <trans-unit id="5f35a7ab78049f5c0c80564c4ff28263d078b176" translate="yes" xml:space="preserve">
          <source>Thus, this is how our previous query is represented:</source>
          <target state="translated">따라서 이전 쿼리가 표시되는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="51ba744d18b1aed2282b3fb904045b5795d7ea41" translate="yes" xml:space="preserve">
          <source>Times are considered equal when their epoch (UTC) time values are equal, &lt;strong&gt;regardless of what time zone they&amp;rsquo;re in&lt;/strong&gt;. This is true for both comparisons and indexed operations. Times are compared in floating point with millisecond precision.</source>
          <target state="translated">&lt;strong&gt;시간대에 관계없이&lt;/strong&gt; 에포크 (UTC) 시간 값이 같으면 시간이 동일한 것으로 간주 &lt;strong&gt;됩니다&lt;/strong&gt; . 이는 비교 작업과 인덱스 작업 모두에 해당됩니다. 시간은 밀리 초 정밀도로 부동 소수점으로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="b52eb4d78ab2e73e97cd1b17559ff603ae360f2a" translate="yes" xml:space="preserve">
          <source>Times are only compared with millisecond precision:</source>
          <target state="translated">시간은 밀리 초 정밀도와 만 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="63dd97c999febb3940f6b2aba7d4800126874dbd" translate="yes" xml:space="preserve">
          <source>Times are stored on the server as seconds since epoch (UTC) with millisecond precision plus a time zone. Currently the only available time zones are minute-precision time offsets from UTC, but we may add support for DST-aware time zones in the future. Time zones are strings as specified by ISO 8601. Note that the JavaScript driver strips time zone information due to limitations with the &lt;code&gt;Date&lt;/code&gt; object, although you can retrieve time zone data via the raw ReQL time object. (See below.)</source>
          <target state="translated">시간은 밀리 초 정밀도와 시간대를 더한 에포크 (UTC) 이후 서버에 초 단위로 저장됩니다. 현재 유일하게 사용 가능한 시간대는 UTC의 분 정밀도 시간 오프셋이지만 향후 DST 인식 시간대에 대한 지원을 추가 할 수 있습니다. 표준 시간대는 ISO 8601에 지정된 문자열입니다. JavaScript 드라이버 는 원시 ReQL 표준 시간대 개체를 통해 표준 시간대 데이터를 검색 할 수 있지만 &lt;code&gt;Date&lt;/code&gt; 개체의 제한으로 인해 표준 시간대 정보를 제거 합니다. (아래 참조)</target>
        </trans-unit>
        <trans-unit id="15603cced6ce07ab8236ca3d48ec34b3d1fb78d0" translate="yes" xml:space="preserve">
          <source>Times may be used as the primary key for a table. Two times are considered equal if they have the same number of milliseconds since epoch (UTC), regardless of time zone.</source>
          <target state="translated">시간은 테이블의 기본 키로 사용될 수 있습니다. 시간대에 관계없이 에포크 (UTC) 이후 동일한 밀리 초 수를 가진 경우 두 번 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="9b9188703b28defc378651fb275e83b6e977aec9" translate="yes" xml:space="preserve">
          <source>To add or overwrite a field, you can use the &lt;code&gt;update&lt;/code&gt; command. For instance, if you would like to add the field &lt;code&gt;author&lt;/code&gt; with the value &amp;ldquo;Michel&amp;rdquo; for all of the documents in the table &lt;code&gt;posts&lt;/code&gt;, you would use:</source>
          <target state="translated">필드를 추가하거나 덮어 쓰기 위해 &lt;code&gt;update&lt;/code&gt; 명령을 사용할 수 있습니다 . 예를 들어, 테이블 &lt;code&gt;posts&lt;/code&gt; 에있는 모든 문서에 대해 &quot;Michel&quot;값으로 필드 &lt;code&gt;author&lt;/code&gt; 를 추가하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f483b4eeb3105dade2c40cdd94f2d80f3d322ddf" translate="yes" xml:space="preserve">
          <source>To buffer messages that the subscriber hasn&amp;rsquo;t consumed yet (this buffering is actually done in the database server)</source>
          <target state="translated">구독자가 아직 소비하지 않은 메시지를 버퍼링하려면 (이 버퍼링은 실제로 데이터베이스 서버에서 수행됨)</target>
        </trans-unit>
        <trans-unit id="cb12f935e01637a6bb4fce40c83665d86ec98cc9" translate="yes" xml:space="preserve">
          <source>To change the password used to access the web UI, log in over SSH and run the following command:</source>
          <target state="translated">웹 UI에 액세스하는 데 사용되는 비밀번호를 변경하려면 SSH를 통해 로그인하고 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="feb7113ba6e90ec2431b889d30d86a37bc3c8f95" translate="yes" xml:space="preserve">
          <source>To change these settings for a table:</source>
          <target state="translated">테이블에 대한 이러한 설정을 변경하려면</target>
        </trans-unit>
        <trans-unit id="b482256206d6e96941c63a16517331684e1bb28d" translate="yes" xml:space="preserve">
          <source>To close a cursor and stop receiving data from the stream or feed, send a query with a &lt;code&gt;QueryType&lt;/code&gt; of &lt;code&gt;STOP&lt;/code&gt; on the same connection with the same token.</source>
          <target state="translated">커서를 닫고 스트림 또는 피드에서 데이터 수신 을 &lt;code&gt;STOP&lt;/code&gt; 하려면 동일한 토큰으로 동일한 연결에서 &lt;code&gt;QueryType&lt;/code&gt; 이 STOP 인 쿼리를 보내십시오 .</target>
        </trans-unit>
        <trans-unit id="54f3a65cc4d17eb7acb7f0b3fbfc5ccdee0afcbf" translate="yes" xml:space="preserve">
          <source>To configure our river, we need to create a type called &lt;code&gt;rethinkdb&lt;/code&gt; in the &lt;code&gt;_river&lt;/code&gt; index. Then we need to insert a document with the id &lt;code&gt;_meta&lt;/code&gt; into that type. Elasticsearch lets us create the document and the type in one go with a &lt;code&gt;PUT&lt;/code&gt; request:</source>
          <target state="translated">우리의 강을 구성하기 위해, 우리는라는 유형 만들 필요가 &lt;code&gt;rethinkdb&lt;/code&gt; 에서 &lt;code&gt;_river&lt;/code&gt; 의 인덱스를. 그런 다음 ID가 &lt;code&gt;_meta&lt;/code&gt; 인 문서 를 해당 유형에 삽입해야합니다. Elasticsearch를 사용하면 &lt;code&gt;PUT&lt;/code&gt; 요청으로 문서와 유형을 한 번에 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d4e23954b31922795c6068d267ad1ca0a01598c" translate="yes" xml:space="preserve">
          <source>To connect to your instance over SSH, log in as the user &lt;code&gt;ubuntu&lt;/code&gt;. Use the private key you chose during the installation process and the public hostname of the instance. For example:</source>
          <target state="translated">SSH를 통해 인스턴스에 연결하려면 사용자 &lt;code&gt;ubuntu&lt;/code&gt; 로 로그인하십시오 . 설치 과정에서 선택한 프라이빗 키와 인스턴스의 퍼블릭 호스트 이름을 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e84477f8fc3e9974738da45f0d2b5d08603632e" translate="yes" xml:space="preserve">
          <source>To create indexes on fields containing geometry objects, you simply use the standard &lt;a href=&quot;../../../api/javascript/index_create/index&quot;&gt;indexCreate&lt;/a&gt; command, setting the &lt;code&gt;geo&lt;/code&gt; optional argument to &lt;code&gt;true&lt;/code&gt;. In JavaScript, this would be:</source>
          <target state="translated">지오메트리 객체가 포함 된 필드에 색인을 만들려면 단순히 &lt;code&gt;geo&lt;/code&gt; 옵션 인수를 &lt;code&gt;true&lt;/code&gt; 로 설정하여 표준 &lt;a href=&quot;../../../api/javascript/index_create/index&quot;&gt;indexCreate&lt;/a&gt; 명령을 사용하면 됩니다. JavaScript에서 이것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e383099f5bc1d4fa7940f0d449f15522b3fe3f50" translate="yes" xml:space="preserve">
          <source>To delete documents, select the documents you&amp;rsquo;d like to delete and use the &lt;code&gt;delete&lt;/code&gt; command. For example, let&amp;rsquo;s delete all posts with the author &amp;ldquo;Michel&amp;rdquo;:</source>
          <target state="translated">문서를 삭제하려면 삭제하려는 문서를 선택하고 &lt;code&gt;delete&lt;/code&gt; 명령을 사용하십시오 . 예를 들어 저자가 &quot;Michel&quot;인 게시물을 모두 삭제하겠습니다.</target>
        </trans-unit>
        <trans-unit id="950e075f5afb40521c4507c103d6c51dff9e0c44" translate="yes" xml:space="preserve">
          <source>To efficiently perform concurrent query execution RethinkDB implements block-level multiversion concurrency control (MVCC). Whenever a write operation occurs while there is an ongoing read, RethinkDB takes a snapshot of the B-Tree for each relevant shard and temporarily maintains different versions of the blocks in order to execute read and write operations concurrently. From the perspective of the applications written on top of RethinkDB, the system is essentially lock-free&amp;mdash; you can run an hour-long analytics query on a live system without blocking any real-time reads or writes.</source>
          <target state="translated">동시 쿼리 실행을 효율적으로 수행하기 RethinkDB는 MVCC (block-level multiversion concurrency control)를 구현합니다. 읽기가 진행 중일 때 쓰기 작업이 수행 될 때마다 RethinkDB는 각 관련 샤드에 대해 B-Tree의 스냅 샷을 생성하고 읽기 및 쓰기 작업을 동시에 실행하기 위해 다른 버전의 블록을 임시로 유지 관리합니다. RethinkDB 위에 작성된 응용 프로그램의 관점에서 볼 때 시스템은 본질적으로 잠금이 없습니다. 실시간 읽기 또는 쓰기를 차단하지 않고 라이브 시스템에서 한 시간 동안 분석 쿼리를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5e4b8665d86162d6ee0499ed85653c5815afb9a" translate="yes" xml:space="preserve">
          <source>To export your data, use &lt;code&gt;rethinkdb dump&lt;/code&gt;:</source>
          <target state="translated">데이터를 내보내려면 &lt;code&gt;rethinkdb dump&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5cfc170270329b9655e380eece96e7561697147" translate="yes" xml:space="preserve">
          <source>To filter messages from the &lt;code&gt;Exchange&lt;/code&gt; by their &lt;code&gt;Topic&lt;/code&gt; (again, the server does this filtering)</source>
          <target state="translated">로부터 메시지 필터에 &lt;code&gt;Exchange&lt;/code&gt; 자신에 의해 &lt;code&gt;Topic&lt;/code&gt; (다시, 서버가이 필터링을 수행)</target>
        </trans-unit>
        <trans-unit id="b9e67fa6a41c04fe151b7928d066cb31b3fea779" translate="yes" xml:space="preserve">
          <source>To gain more precise control, write a class that inherits from &lt;code&gt;RethinkDB::Handler&lt;/code&gt; and override the event handling methods, then pass an instance of that class to &lt;code&gt;em_run&lt;/code&gt;.</source>
          <target state="translated">보다 정확한 제어를 위해 &lt;code&gt;RethinkDB::Handler&lt;/code&gt; 에서 상속되는 클래스를 작성 하고 이벤트 처리 메소드를 대체 한 다음 해당 클래스의 인스턴스를 &lt;code&gt;em_run&lt;/code&gt; 으로 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="ecb986ccee4f137068ef2d566f7031789cf5f9b2" translate="yes" xml:space="preserve">
          <source>To get a specific document by ID, use &lt;code&gt;get&lt;/code&gt;:</source>
          <target state="translated">ID로 특정 문서를 &lt;code&gt;get&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="32c34afe39f590eccd4f302451652c9d5db80b83" translate="yes" xml:space="preserve">
          <source>To get all documents in a table, simply use the &lt;code&gt;table&lt;/code&gt; command:</source>
          <target state="translated">테이블의 모든 문서를 가져 오려면 &lt;code&gt;table&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="de40767187d55c844372554d913cfb17c30ac121" translate="yes" xml:space="preserve">
          <source>To get the list without duplicates, we can simply leave off &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">중복없이 목록을 얻으려면 단순히 &lt;code&gt;count&lt;/code&gt; 를 남겨 두십시오 .</target>
        </trans-unit>
        <trans-unit id="88d921b59c0f75df156b7448a630f25ee63f52bf" translate="yes" xml:space="preserve">
          <source>To group servers together in data centers, RethinkDB uses &lt;a href=&quot;#server-tags&quot;&gt;Server tags&lt;/a&gt;. Servers can be &amp;ldquo;tagged&amp;rdquo; with one or more group names on startup:</source>
          <target state="translated">데이터 센터에서 서버를 함께 그룹화하기 위해 RethinkDB는 &lt;a href=&quot;#server-tags&quot;&gt;서버 태그를&lt;/a&gt; 사용 합니다 . 서버는 시작할 때 하나 이상의 그룹 이름으로 &quot;태그&quot;될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c8c09feafb751ddc9987a1f0769b5852c6515f6" translate="yes" xml:space="preserve">
          <source>To import repubsub and create a connection to an exchange:</source>
          <target state="translated">repubsub를 가져오고 교환에 대한 연결을 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c1f91e358f2a76534d12cdf146988fdd67d454fb" translate="yes" xml:space="preserve">
          <source>To import the file &lt;code&gt;users.json&lt;/code&gt; into the table &lt;code&gt;test.users&lt;/code&gt;, you would use:</source>
          <target state="translated">파일 가져 &lt;code&gt;users.json&lt;/code&gt; 테이블에 &lt;code&gt;test.users&lt;/code&gt; 을 , 당신은 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="366e39a918bb090b9526809d87179174180378d0" translate="yes" xml:space="preserve">
          <source>To import your data, use &lt;code&gt;rethinkdb restore&lt;/code&gt;:</source>
          <target state="translated">데이터를 가져 오려면 &lt;code&gt;rethinkdb restore&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="86d61c074af286c312f7bf0ff03e2e2f22db6204" translate="yes" xml:space="preserve">
          <source>To install the river, we&amp;rsquo;ll use the &lt;code&gt;plugin&lt;/code&gt; program that comes with Elasticsearch. On most platforms the program is named &lt;code&gt;plugin&lt;/code&gt;, but it&amp;rsquo;s sometimes called &lt;code&gt;elasticsearch-plugin&lt;/code&gt;:</source>
          <target state="translated">강을 설치하기 위해 Elasticsearch와 함께 제공 되는 &lt;code&gt;plugin&lt;/code&gt; 프로그램을 사용합니다 . 대부분의 플랫폼에서 프로그램의 이름은 &lt;code&gt;plugin&lt;/code&gt; 이지만 &lt;code&gt;elasticsearch-plugin&lt;/code&gt; 이라고도합니다 .</target>
        </trans-unit>
        <trans-unit id="07ccf555ea9bbb6b48936787543c2086779b895e" translate="yes" xml:space="preserve">
          <source>To learn more, read about &lt;a href=&quot;../data-modeling/index&quot;&gt;data modeling in RethinkDB&lt;/a&gt;. For detailed information, take a look at the API documentation for the join commands:</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;../data-modeling/index&quot;&gt;은 RethinkDB의 데이터 모델링에&lt;/a&gt; 대해 읽으 십시오 . 자세한 정보는 join 명령에 대한 API 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6400029759c584c7be4cecaa7c0efc09877f5ffb" translate="yes" xml:space="preserve">
          <source>To perform automatic failover for a table, the following requirements must be met:</source>
          <target state="translated">테이블에 대한 자동 장애 조치를 수행하려면 다음 요구 사항이 충족되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d9ec4446461d0874e4e3707aaa37881f8f5364dd" translate="yes" xml:space="preserve">
          <source>To perform this, &lt;a href=&quot;../../../api/javascript/map/index&quot;&gt;map&lt;/a&gt; the first 25 movies into a new result set, adding a &lt;code&gt;count&lt;/code&gt; column, then &lt;a href=&quot;../../../api/javascript/reduce/index&quot;&gt;reduce&lt;/a&gt; each row of the mapped result set into a total for each field (&lt;code&gt;votes&lt;/code&gt;, &lt;code&gt;year&lt;/code&gt; and &lt;code&gt;column&lt;/code&gt;). Then use &lt;a href=&quot;../../../api/javascript/do/index&quot;&gt;do&lt;/a&gt; to return a result set with the total votes and the average year, computed by dividing the sum of the years by their count.</source>
          <target state="translated">이를 수행하기 위해, &lt;a href=&quot;../../../api/javascript/map/index&quot;&gt;매핑&lt;/a&gt; 추가 새로운 결과 세트에 제 25 영화를 &lt;code&gt;count&lt;/code&gt; 한 후, 열을 &lt;a href=&quot;../../../api/javascript/reduce/index&quot;&gt;줄이기&lt;/a&gt; 각 필드 (대 전체에 매핑 결과 집합의 각 행을 &lt;code&gt;votes&lt;/code&gt; , &lt;code&gt;year&lt;/code&gt; 및 &lt;code&gt;column&lt;/code&gt; ). 그런 다음 &lt;a href=&quot;../../../api/javascript/do/index&quot;&gt;do&lt;/a&gt; 를 사용 하여 총 합과 평균 연도로 결과 집합을 반환합니다. 연도의 합계를 카운트로 나눈 값입니다.</target>
        </trans-unit>
        <trans-unit id="a0ff8e79026cbc6c21f05b4a17f993ecb68823c4" translate="yes" xml:space="preserve">
          <source>To publish a message to the exchange, create a topic:</source>
          <target state="translated">교환에 메시지를 게시하려면 주제를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b02d7fe7e4c8253f0f26c381301a861cc87b02c6" translate="yes" xml:space="preserve">
          <source>To put these into a new table, wrap that query with &lt;code&gt;insert&lt;/code&gt;. We&amp;rsquo;ll get new IDs generated automatically. This is also an example of using subqueries with ReQL: it&amp;rsquo;s easy to pass the results of one query into another. (One of ReQL&amp;rsquo;s other nice properties, which we&amp;rsquo;ve already seen, is command chaining: the input of one command is often the output of the command before it, similar to Unix piping.)</source>
          <target state="translated">이것을 새 테이블에 넣으려면 &lt;code&gt;insert&lt;/code&gt; 로 해당 쿼리를 래핑하십시오 . 새로운 ID가 자동으로 생성됩니다. 이것은 또한 ReQL과 함께 하위 쿼리를 사용하는 예입니다. 한 쿼리 결과를 다른 쿼리로 쉽게 전달할 수 있습니다. (우리가 이미 보았던 ReQL의 다른 좋은 속성 중 하나는 명령 체인입니다. 한 명령의 입력은 종종 Unix 파이핑과 비슷한 명령의 명령 출력입니다.)</target>
        </trans-unit>
        <trans-unit id="aeaa752cf337e6eca87d3929b1caf4bdac7d936a" translate="yes" xml:space="preserve">
          <source>To recap, sending a query to the server takes the following steps:</source>
          <target state="translated">요약하면 서버로 쿼리를 보내는 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85f19992e8bf6c08c0bc6c8efb74c60dd624f683" translate="yes" xml:space="preserve">
          <source>To retrieve all documents from the table &lt;code&gt;authors&lt;/code&gt;, we can simply run the query &lt;code&gt;r.table('authors')&lt;/code&gt;:</source>
          <target state="translated">테이블 &lt;code&gt;authors&lt;/code&gt; 에서 모든 문서를 검색하려면 &lt;code&gt;r.table('authors')&lt;/code&gt; 쿼리를 실행하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="3a5f4a8eb4db8e8ab545aa8109b844e626df95c5" translate="yes" xml:space="preserve">
          <source>To retrieve documents by the value of a specific &lt;a href=&quot;../../secondary-indexes/javascript/index&quot;&gt;index&lt;/a&gt;, use &lt;code&gt;getAll&lt;/code&gt;:</source>
          <target state="translated">특정 &lt;a href=&quot;../../secondary-indexes/javascript/index&quot;&gt;인덱스&lt;/a&gt; 값으로 문서를 검색하려면 &lt;code&gt;getAll&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fbb0258d07691baeefb2b68816f6b95a63456b10" translate="yes" xml:space="preserve">
          <source>To retrieve documents by the value of a specific field, use &lt;code&gt;filter&lt;/code&gt;:</source>
          <target state="translated">특정 필드의 값으로 문서를 검색하려면 &lt;code&gt;filter&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed3be06592db0d57713ac35e99b8a2f3ebf7ea85" translate="yes" xml:space="preserve">
          <source>To retrieve more data for the cursor, the driver should send a query with a &lt;code&gt;QueryType&lt;/code&gt; of &lt;code&gt;CONTINUE&lt;/code&gt;&lt;em&gt;on the same connection with the same token.&lt;/em&gt; As with other queries, this must be sent with the query token, the size of the query, and the query itself, simply &lt;code&gt;[2]&lt;/code&gt;.</source>
          <target state="translated">커서에 대한 추가 데이터를 검색하려면 드라이버는 &lt;em&gt;동일한 토큰을 사용하는 동일한 연결&lt;/em&gt; 에서 &lt;code&gt;CONTINUE&lt;/code&gt; 인 &lt;code&gt;QueryType&lt;/code&gt; 을 사용 하여 쿼리를 보내야합니다 &lt;em&gt;. &lt;/em&gt;다른 쿼리와 마찬가지로 쿼리 토큰, 쿼리 크기 및 쿼리 자체와 함께 전송해야합니다 &lt;code&gt;[2]&lt;/code&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="594e344aa121fcd72ce614816e06800232731f0c" translate="yes" xml:space="preserve">
          <source>To return the status on a specific table, you can use the &lt;a href=&quot;https://rethinkdb.com/api/python/status&quot;&gt;status&lt;/a&gt; command.</source>
          <target state="translated">특정 테이블에서 상태를 반환하려면 &lt;a href=&quot;https://rethinkdb.com/api/python/status&quot;&gt;status&lt;/a&gt; 명령을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f2544d8217895f115ddbfac5ce0427076385ac7" translate="yes" xml:space="preserve">
          <source>To run a proxy node, simply use the &lt;code&gt;proxy&lt;/code&gt; command line option on startup.</source>
          <target state="translated">프록시 노드를 실행하려면 시작시 &lt;code&gt;proxy&lt;/code&gt; 명령 행 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ad487668453bf9cfe5420133fd62d266a6f19fb" translate="yes" xml:space="preserve">
          <source>To secure the cluster port, bind it to a specific IP address using the &lt;code&gt;--bind-cluster&lt;/code&gt;&lt;a href=&quot;../cli-options/index&quot;&gt;command line option&lt;/a&gt; or the corresponding &lt;a href=&quot;../config-file/index&quot;&gt;configuration file option&lt;/a&gt;. Bind it to an IP address that is only accessible from within your local network.</source>
          <target state="translated">클러스터 포트를 보호하려면 &lt;code&gt;--bind-cluster&lt;/code&gt; &lt;a href=&quot;../cli-options/index&quot;&gt;명령 줄 옵션&lt;/a&gt; 또는 해당 &lt;a href=&quot;../config-file/index&quot;&gt;구성 파일 옵션을&lt;/a&gt; 사용하여 클러스터 포트를 특정 IP 주소에 바인딩하십시오 . 로컬 네트워크 내에서만 액세스 할 수있는 IP 주소에 바인딩하십시오.</target>
        </trans-unit>
        <trans-unit id="63abc14b3a39ce86c3ddac5a6216b4527d3e45bd" translate="yes" xml:space="preserve">
          <source>To secure your instance more tightly, we recommend that you perform the following steps:</source>
          <target state="translated">인스턴스를보다 단단히 보호하려면 다음 단계를 수행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ad6055491136bc9a98781e119b4821f59b1ddbf8" translate="yes" xml:space="preserve">
          <source>To solve this, specify the canonical address explicitly by using the &lt;code&gt;--canonical-address&lt;/code&gt; argument.</source>
          <target state="translated">이를 해결하려면 &lt;code&gt;--canonical-address&lt;/code&gt; 인수를 사용하여 정식 주소를 명시 적으로 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="d72bc2454fca47c2c0ab0269659e7cf093c4a3e6" translate="yes" xml:space="preserve">
          <source>To specify the permissions described above for Bob, you would execute the following ReQL commands:</source>
          <target state="translated">Bob에 대해 위에서 설명한 권한을 지정하려면 다음 ReQL 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="1cb6d614ff621abfe0d6a335ad8d264a853e0544" translate="yes" xml:space="preserve">
          <source>To start RethinkDB, use &lt;code&gt;launchctl&lt;/code&gt;:</source>
          <target state="translated">RethinkDB를 시작하려면 &lt;code&gt;launchctl&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2dad878292712b7f558426d349ed880e4af7a108" translate="yes" xml:space="preserve">
          <source>To start a feed, open a new terminal and open a new RethinkDB connection. Then, run the following query:</source>
          <target state="translated">피드를 시작하려면 새 터미널을 열고 새 RethinkDB 연결을여십시오. 그런 다음 다음 쿼리를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="9c11c7d34e1946579e4adcbac994f885acb15b11" translate="yes" xml:space="preserve">
          <source>To start the first RethinkDB instance, run this command in your terminal:</source>
          <target state="translated">첫 번째 RethinkDB 인스턴스를 시작하려면 터미널에서 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="c3e5329f2856e1b30fd4b56a003d3db2b1ded724" translate="yes" xml:space="preserve">
          <source>To summarize all of the above in code:</source>
          <target state="translated">위의 코드를 모두 요약하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3abbd29486099a34e7f40b5a4cddbe4b9cf10916" translate="yes" xml:space="preserve">
          <source>To understand the number of blocks used by a given data set, we must first distinguish two different modes of how a document can be stored.</source>
          <target state="translated">주어진 데이터 세트가 사용하는 블록 수를 이해하려면 먼저 문서 저장 방법에 대한 두 가지 다른 모드를 구별해야합니다.</target>
        </trans-unit>
        <trans-unit id="f0f9dad2d6cdcc7eacf224d626d3f9f091cf0c85" translate="yes" xml:space="preserve">
          <source>To use TLS connections between servers in the cluster:</source>
          <target state="translated">클러스터의 서버간에 TLS 연결을 사용하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b133e48e0d2e81b55fd18918ab28e9f2c17723e7" translate="yes" xml:space="preserve">
          <source>To use TLS connections with client drivers, specify:</source>
          <target state="translated">클라이언트 드라이버와 함께 TLS 연결을 사용하려면 다음을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="bb0309d21645559c49035d639aedb79fa72fcc44" translate="yes" xml:space="preserve">
          <source>Todo list 1</source>
          <target state="translated">할일 목록 1</target>
        </trans-unit>
        <trans-unit id="c0d571fb15bd5004e86b86da5d5fd2117fc978b4" translate="yes" xml:space="preserve">
          <source>Todo list 2</source>
          <target state="translated">할일 목록 2</target>
        </trans-unit>
        <trans-unit id="8ec3b42250ed256519f611273d212bc6a9381982" translate="yes" xml:space="preserve">
          <source>Todo list in Backbone</source>
          <target state="translated">백본의 할일 목록</target>
        </trans-unit>
        <trans-unit id="9b709f53299c781ad6cfe792699295be55f8b558" translate="yes" xml:space="preserve">
          <source>Todo list in Ember.js</source>
          <target state="translated">Ember.js의 할일 목록</target>
        </trans-unit>
        <trans-unit id="132a9e5e92ca13cc63a8881214eed35704933a05" translate="yes" xml:space="preserve">
          <source>Todo list with Angular and Express</source>
          <target state="translated">Angular 및 Express가 포함 된 할일 목록</target>
        </trans-unit>
        <trans-unit id="bea627f8ee28519a09b024254b900d47c7456046" translate="yes" xml:space="preserve">
          <source>Tornado</source>
          <target state="translated">Tornado</target>
        </trans-unit>
        <trans-unit id="bd22935ae208296740b8d45826f737f20bba80b9" translate="yes" xml:space="preserve">
          <source>Transform each element of one or more sequences by applying a mapping function to them. If &lt;code&gt;map&lt;/code&gt; is run with two or more sequences, it will iterate for as many items as there are in the shortest sequence.</source>
          <target state="translated">매핑 기능을 적용하여 하나 이상의 시퀀스의 각 요소를 변환합니다. 경우 &lt;code&gt;map&lt;/code&gt; 두 개 이상의 시퀀스로 실행되는 짧은 순서에 있기 때문에, 많은 항목으로 위해 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="d685ad7c59aeb1945ef867b52857539b62c1b81c" translate="yes" xml:space="preserve">
          <source>Transformations</source>
          <target state="translated">Transformations</target>
        </trans-unit>
        <trans-unit id="e2bc0fa55c343cd8ae1a2849f02567a3cbc8198c" translate="yes" xml:space="preserve">
          <source>Transformations are applied before changes are calculated.</source>
          <target state="translated">변경 사항이 계산되기 전에 변환이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="636b384f08584381fd6ed01329683547509c1d32" translate="yes" xml:space="preserve">
          <source>Transmitted</source>
          <target state="translated">Transmitted</target>
        </trans-unit>
        <trans-unit id="10756c57fa929e54d2fbfddbd05bebea58ee3730" translate="yes" xml:space="preserve">
          <source>Transmitted bytes</source>
          <target state="translated">전송 된 바이트</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="a366c709db27bd15c4dfe9c2cf45f4723cc61549" translate="yes" xml:space="preserve">
          <source>Troubleshooting FAQ</source>
          <target state="translated">문제 해결 FAQ</target>
        </trans-unit>
        <trans-unit id="37980a44c517087463e129eca0240643f5c25de3" translate="yes" xml:space="preserve">
          <source>Troubleshooting common RethinkDB problems</source>
          <target state="translated">일반적인 RethinkDB 문제 해결</target>
        </trans-unit>
        <trans-unit id="9beec1d3517a419360a6ad6fb2b7d53d1d3521a5" translate="yes" xml:space="preserve">
          <source>Trusted Docker build and instructions for deploying a RethinkDB cluster.</source>
          <target state="translated">RethinkDB 클러스터 배포를위한 신뢰할 수있는 Docker 빌드 및 지침</target>
        </trans-unit>
        <trans-unit id="cbe5413cca0e1a50a658098a3df98dcd9a0f8b94" translate="yes" xml:space="preserve">
          <source>Try out the repubsub demo</source>
          <target state="translated">repubsub 데모를 사용해보십시오</target>
        </trans-unit>
        <trans-unit id="e3ca01cb076f183ec2cf707e0ea65c9829a4435d" translate="yes" xml:space="preserve">
          <source>Trying to access &lt;code&gt;user1&lt;/code&gt; in ReQL will cause a nesting depth error.</source>
          <target state="translated">ReQL에서 &lt;code&gt;user1&lt;/code&gt; 에 액세스하려고 하면 중첩 깊이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="53664f1e2f0e6eb2b0c4bce0be6d2549297e9871" translate="yes" xml:space="preserve">
          <source>Turn a query into a changefeed, an infinite stream of objects representing changes to the query&amp;rsquo;s results as they occur. A changefeed may return changes to a table or an individual document (a &amp;ldquo;point&amp;rdquo; changefeed). Commands such as &lt;code&gt;filter&lt;/code&gt; or &lt;code&gt;map&lt;/code&gt; may be used before the &lt;code&gt;changes&lt;/code&gt; command to transform or filter the output, and many commands that operate on sequences can be chained after &lt;code&gt;changes&lt;/code&gt;.</source>
          <target state="translated">쿼리를 쿼리 결과에 대한 변경 사항을 나타내는 무한한 개체 스트림 인 변경 피드로 변환하십시오. 변경 피드는 테이블 또는 개별 문서 ( &quot;포인트&quot;변경 피드)에 변경 사항을 반환 할 수 있습니다. &lt;code&gt;filter&lt;/code&gt; 또는 &lt;code&gt;map&lt;/code&gt; 과 같은 명령 은 &lt;code&gt;changes&lt;/code&gt; 명령을 사용 하여 출력을 변환하거나 필터링 하기 위해 사용될 수 있으며 , 시퀀스에서 작동하는 많은 명령은 &lt;code&gt;changes&lt;/code&gt; 후에 연결될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b79156b13c38a60392112dbdf81a9d0a27fcf63" translate="yes" xml:space="preserve">
          <source>Twisted</source>
          <target state="translated">Twisted</target>
        </trans-unit>
        <trans-unit id="6446b1c8d77fa2cd9100709887d91f9bbff92d94" translate="yes" xml:space="preserve">
          <source>Two (latitude and longitude). Elevation is not supported.</source>
          <target state="translated">두 (위도와 경도). 고도는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1fa1c3c9ce84fdece536b61347999037fad2354c" translate="yes" xml:space="preserve">
          <source>Two events can be emitted, &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 와 &lt;code&gt;error&lt;/code&gt; 의 두 가지 이벤트가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6b5482647136d8564d88c44675609c8ed6bdba4" translate="yes" xml:space="preserve">
          <source>Two or more &lt;a href=&quot;../point/index&quot;&gt;Point&lt;/a&gt; objects specifying the line&amp;rsquo;s vertices.</source>
          <target state="translated">선의 꼭짓점을 지정하는 둘 이상의 &lt;a href=&quot;../point/index&quot;&gt;Point&lt;/a&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="1b1a580c0ac47b78a0704236a77398259abc1c6b" translate="yes" xml:space="preserve">
          <source>Two or more &lt;a href=&quot;point/index&quot;&gt;Point&lt;/a&gt; objects specifying the line&amp;rsquo;s vertices.</source>
          <target state="translated">선의 꼭짓점을 지정하는 둘 이상의 &lt;a href=&quot;point/index&quot;&gt;Point&lt;/a&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="bbdcc944716c5615a236baa9e2fc33d539a9105d" translate="yes" xml:space="preserve">
          <source>Two or more two-item arrays, specifying latitude and longitude numbers of the line&amp;rsquo;s vertices;</source>
          <target state="translated">선 정점의 위도 및 경도 수를 지정하는 둘 이상의 두 항목 배열.</target>
        </trans-unit>
        <trans-unit id="4ba1815eb2917359deeac9d397d5812c0b4b098a" translate="yes" xml:space="preserve">
          <source>Two settings for tables, write acknowledgements and write durability, cannot be set through either the web interface or the &lt;code&gt;reconfigure&lt;/code&gt; command. They must be set by modifying the &lt;code&gt;table_config&lt;/code&gt; table for individual tables.</source>
          <target state="translated">웹 인터페이스 또는 &lt;code&gt;reconfigure&lt;/code&gt; 명령을 통해 테이블 ​​승인, 쓰기 내구성 및 쓰기 내구성의 두 가지 설정을 설정할 수 없습니다 . 개별 테이블 의 &lt;code&gt;table_config&lt;/code&gt; 테이블을 수정하여 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6c7e8c4768d6d89677c79690c60c193c74ddcb13" translate="yes" xml:space="preserve">
          <source>Typically, this indicates that a JSON object with subdocuments is too deeply nested:</source>
          <target state="translated">일반적으로 하위 문서가 포함 된 JSON 객체가 너무 깊게 중첩되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="52c6c1812015585dc1092393a1f244f60d68c60a" translate="yes" xml:space="preserve">
          <source>UPDATE</source>
          <target state="translated">UPDATE</target>
        </trans-unit>
        <trans-unit id="364270ef7d2c546a581298054e0fe3b7afbbe2ac" translate="yes" xml:space="preserve">
          <source>US election analysis</source>
          <target state="translated">미국 선거 분석</target>
        </trans-unit>
        <trans-unit id="a1c366cacdc2e4f2ca5e9f514afccf66ad1dfa3e" translate="yes" xml:space="preserve">
          <source>Ubuntu</source>
          <target state="translated">Ubuntu</target>
        </trans-unit>
        <trans-unit id="a6812ddf0974dcae6abd3a14c32af9a9161c78a9" translate="yes" xml:space="preserve">
          <source>Ubuntu 14.04</source>
          <target state="translated">우분투 14.04</target>
        </trans-unit>
        <trans-unit id="9fa17002e5897edadc0072042bcef127cb475076" translate="yes" xml:space="preserve">
          <source>Ubuntu Server 12.04 LTS</source>
          <target state="translated">우분투 서버 12.04 LTS</target>
        </trans-unit>
        <trans-unit id="2fcd95479f339b189b1b91af8268bb81bf5e8c84" translate="yes" xml:space="preserve">
          <source>Under OS X, the system versions of Python and Ruby link to old versions of OpenSSL which do not support RethinkDB&amp;rsquo;s defaults for TLS. To use those drivers under OS X, the server must specify:</source>
          <target state="translated">OS X에서 Python 및 Ruby의 시스템 버전은 TLS에 대한 RethinkDB의 기본값을 지원하지 않는 이전 버전의 OpenSSL에 연결됩니다. OS X에서 이러한 드라이버를 사용하려면 서버가 다음을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c637e03237e3de5320d47b31840684831855946" translate="yes" xml:space="preserve">
          <source>Under most circumstances, it is easier to manipulate the &lt;code&gt;permissions&lt;/code&gt; table by using the &lt;a href=&quot;../../api/javascript/grant/index&quot;&gt;grant&lt;/a&gt; command.</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;../../api/javascript/grant/index&quot;&gt;grant&lt;/a&gt; 명령 을 사용하여 &lt;code&gt;permissions&lt;/code&gt; 테이블 을 조작하는 것이 더 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="0d4479e111cf225a452266879c7640ba144cf369" translate="yes" xml:space="preserve">
          <source>Under normal circumstances the system will prevent name collisions, but a collision could occur due to a race condition&amp;mdash;for instance, two clients trying to create tables with the same name on different servers simultaneously. This is a critical error, as a name collision on a table or database makes it impossible to read or write from that table or from tables in that database.</source>
          <target state="translated">정상적인 상황에서는 시스템이 이름 충돌을 방지하지만 경쟁 조건으로 인해 충돌이 발생할 수 있습니다 (예 : 두 명의 클라이언트가 서로 다른 서버에서 동시에 동일한 이름의 테이블을 작성하려고 함). 테이블이나 데이터베이스의 이름 충돌로 인해 해당 테이블이나 해당 데이터베이스의 테이블에서 읽거나 쓸 수 없으므로 이는 심각한 오류입니다.</target>
        </trans-unit>
        <trans-unit id="44b2aafb6bac3c1c7dac049c5af91f953afa5c68" translate="yes" xml:space="preserve">
          <source>Understanding RethinkDB memory requirements</source>
          <target state="translated">RethinkDB 메모리 요구 사항 이해</target>
        </trans-unit>
        <trans-unit id="e843f3bbb1a4125dd9a299d4d68c73b5d88c19db" translate="yes" xml:space="preserve">
          <source>Understanding how RethinkDB parallelizes queries can improve the performance of your applications&amp;mdash;sometimes significantly.</source>
          <target state="translated">RethinkDB가 쿼리를 병렬화하는 방법을 이해하면 응용 프로그램의 성능을 크게 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce00816d4a4fa8b4c822b510eb10cc24e4557eab" translate="yes" xml:space="preserve">
          <source>Ungrouping</source>
          <target state="translated">Ungrouping</target>
        </trans-unit>
        <trans-unit id="f6eabc3d4ce5084fa933d9e3e40b1a62a4408c35" translate="yes" xml:space="preserve">
          <source>Ungrouping is useful e.g. for ordering grouped data, or for inserting grouped data into a table.</source>
          <target state="translated">그룹 해제는 예를 들어 그룹화 된 데이터를 정렬하거나 그룹화 된 데이터를 테이블에 삽입 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f217805f771e930edb43d7bf7bca94dcb4d337f2" translate="yes" xml:space="preserve">
          <source>Unlike a relational database, RethinkDB doesn&amp;rsquo;t enforce types, so NoBrainer&amp;rsquo;s type annotations on the field are validators that are run just before a document is saved to the database. If you don&amp;rsquo;t want to specify the type for a field, you can use the dummy type &lt;code&gt;object&lt;/code&gt;:</source>
          <target state="translated">관계형 데이터베이스와 달리 RethinkDB는 유형을 적용하지 않으므로 필드에서 NoBrainer의 유형 주석은 문서가 데이터베이스에 저장되기 직전에 실행되는 유효성 검사기입니다. 필드의 유형을 지정하지 않으려면 더미 유형 &lt;code&gt;object&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac7e8952b13e5acdc4da0cec2cf13463f8f61d32" translate="yes" xml:space="preserve">
          <source>Unlike most NoSQL languages, you can use ReQL to build queries of arbitrary complexity.</source>
          <target state="translated">대부분의 NoSQL 언어와 달리 ReQL을 사용하여 임의의 복잡한 쿼리를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c16226abce85df018665b20883ae7e6e4b1e5e95" translate="yes" xml:space="preserve">
          <source>Unlike the script that pushes data into Rabbit, to listen we need to create a &lt;em&gt;queue&lt;/em&gt;. Queues are basically mailboxes. You go to an exchange and sign up a queue for different topics from that exchange:</source>
          <target state="translated">데이터를 Rabbit으로 푸시하는 스크립트와 달리, 들어 보려면 &lt;em&gt;대기열&lt;/em&gt; 을 만들어야합니다 . 큐는 기본적으로 사서함입니다. 교환에 가서 해당 교환과 다른 주제에 대한 대기열을 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="fdeb266883f342263bdad04080658322848b0916" translate="yes" xml:space="preserve">
          <source>Update JSON documents in a table. Accepts a JSON document, a ReQL expression, or a combination of the two.</source>
          <target state="translated">테이블에서 JSON 문서를 업데이트하십시오. JSON 문서, ReQL 표현식 또는이 둘의 조합을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="886df39f252cb5160cd6c67abc34816e8e74dfa5" translate="yes" xml:space="preserve">
          <source>Update documents</source>
          <target state="translated">문서 업데이트</target>
        </trans-unit>
        <trans-unit id="889a7dd9a4b654d699b56a7a2065ecff1fbc5e44" translate="yes" xml:space="preserve">
          <source>Update returns an object that contains the following attributes:</source>
          <target state="translated">업데이트는 다음 속성이 포함 된 개체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="78a05a6a04989744e749ac1bebf7d5f706cbd978" translate="yes" xml:space="preserve">
          <source>Updating nested fields</source>
          <target state="translated">중첩 필드 업데이트</target>
        </trans-unit>
        <trans-unit id="46d2ffec68a2c34115384d62c30e25333d59d0dc" translate="yes" xml:space="preserve">
          <source>Updating the state of a cluster is a surprisingly difficult problem in distributed systems. At any given point different (and potentially) conflicting configurations can be selected on different sides of a netsplit, different configurations can reach different nodes in the cluster at unpredictable times, etc.</source>
          <target state="translated">분산 시스템에서 클러스터의 상태를 업데이트하는 것은 놀랍게도 어려운 문제입니다. 주어진 시점에서 netsplit의 다른 측면에서 서로 다른 충돌 가능성이있는 구성을 선택할 수 있으며, 다른 구성은 예측할 수없는 시간 등에 클러스터의 다른 노드에 도달 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80fd74f545706363781bafd9b9b926b0120f411a" translate="yes" xml:space="preserve">
          <source>Upgrade RethinkDB to a new version</source>
          <target state="translated">RethinkDB를 새 버전으로 업그레이드</target>
        </trans-unit>
        <trans-unit id="ebbd9e0c3ed2ca872f91fb9e343b590ec4bc9217" translate="yes" xml:space="preserve">
          <source>Upgrading RethinkDB</source>
          <target state="translated">RethinkDB 업그레이드</target>
        </trans-unit>
        <trans-unit id="449ffb29ddf3b7b7d07cbf671ea03550c293da3a" translate="yes" xml:space="preserve">
          <source>Upgrading from RethinkDB versions 1.6 or earlier has &lt;em&gt;not&lt;/em&gt; been tested with RethinkDB 2.1 and higher. However, you should be able to use the deprecated &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/tree/02b4f29e1e7f15b3edffcb68bf015578ec5783ab/scripts/migration&quot;&gt;migration script&lt;/a&gt;.</source>
          <target state="translated">RethinkDB 버전 1.6 이하에서 업그레이드하는 것은 RethinkDB 2.1 이상에서 테스트 &lt;em&gt;되지&lt;/em&gt; 않았습니다. 그러나 더 이상 사용되지 않는 &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/tree/02b4f29e1e7f15b3edffcb68bf015578ec5783ab/scripts/migration&quot;&gt;마이그레이션 스크립트&lt;/a&gt; 를 사용할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="23ae55bbf764d16d108fec022f1450aafee2eec8" translate="yes" xml:space="preserve">
          <source>Uppercases a string.</source>
          <target state="translated">문자열을 대문자로합니다.</target>
        </trans-unit>
        <trans-unit id="659680921b67aa2e7a75e1c65027d91f2d9c5555" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://rethinkdb.com/api/python/index_status/&quot;&gt;index_status&lt;/a&gt; to retrieve a binary representation of the existing secondary index (whether it is simple, compound, multi, or based on an expression)</source>
          <target state="translated">&lt;a href=&quot;https://rethinkdb.com/api/python/index_status/&quot;&gt;index_status&lt;/a&gt; 를 사용 하여 기존 보조 인덱스의 이진 표현을 검색합니다 (단순, 복합, 다중 또는 표현식 기반).</target>
        </trans-unit>
        <trans-unit id="0a6475c00b0900ae4e541e3bb4fa60e368eea9b9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;default&lt;/code&gt; to ensure that if the &lt;code&gt;count&lt;/code&gt; field doesn&amp;rsquo;t already exist in the document, it&amp;rsquo;s added correctly, rather than letting &lt;code&gt;add&lt;/code&gt; throw an error.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 필드가 문서에 존재하지 않는 경우 &lt;code&gt;add&lt;/code&gt; 에서 오류를 발생 시키지 않고 올바르게 추가 되도록 하려면 &lt;code&gt;default&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="95f978d6b1722fef203b1e9a1db06789e0fa0612" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;polygon2&lt;/code&gt; to &amp;ldquo;punch out&amp;rdquo; a hole in &lt;code&gt;polygon1&lt;/code&gt;. &lt;code&gt;polygon2&lt;/code&gt; must be completely contained within &lt;code&gt;polygon1&lt;/code&gt; and must have no holes itself (it must not be the output of &lt;code&gt;polygonSub&lt;/code&gt; itself).</source>
          <target state="translated">사용 &lt;code&gt;polygon2&lt;/code&gt; 에 구멍 &quot;펀치 아웃&quot;에 &lt;code&gt;polygon1&lt;/code&gt; 을 . &lt;code&gt;polygon2&lt;/code&gt; 는 완전히 포함되어야 &lt;code&gt;polygon1&lt;/code&gt; 하고 (그것은 출력 안됩니다에는 구멍 자체가 없어야 &lt;code&gt;polygonSub&lt;/code&gt; 자체).</target>
        </trans-unit>
        <trans-unit id="828e6b81f935582a6801e7c26c4473219515b699" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;rethinkdb help &amp;lt;command&amp;gt;&lt;/code&gt; for a list of options. For more details, see &lt;a href=&quot;../backup/index&quot;&gt;Backing up your data&lt;/a&gt;.</source>
          <target state="translated">옵션 목록을 보려면 &lt;code&gt;rethinkdb help &amp;lt;command&amp;gt;&lt;/code&gt; 를 사용하십시오 . 자세한 내용은 &lt;a href=&quot;../backup/index&quot;&gt;데이터 백업을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3315d5d9a9dfeca99bc7ea7f478442bf8813cad" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;rethinkdb restore --help&lt;/code&gt; to see the complete list of options for importing your data. Again, for more details, see &lt;a href=&quot;../backup/index&quot;&gt;Backing up your data&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;rethinkdb restore --help&lt;/code&gt; 를 사용 하여 데이터를 가져 오기위한 전체 옵션 목록을보십시오. 자세한 내용은 &lt;a href=&quot;../backup/index&quot;&gt;데이터 백업을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="409daa75fdb8287421baffc1e21a8ba0992f8262" translate="yes" xml:space="preserve">
          <source>Use RethinkDB as session store with Express 4.x framework. Adapted from connect-rethinkdb.</source>
          <target state="translated">Express 4.x 프레임 워크에서 RethinkDB를 세션 저장소로 사용하십시오. connect-rethinkdb에서 채택되었습니다.</target>
        </trans-unit>
        <trans-unit id="f97f9ac1ace574e46eab8167a8178383052e916d" translate="yes" xml:space="preserve">
          <source>Use a multi index and a mapping function to speed getAll/contains</source>
          <target state="translated">다중 인덱스 및 매핑 기능을 사용하여 getAll / contains 속도 향상</target>
        </trans-unit>
        <trans-unit id="1a5e2238f6aaa1ef54f93db2748355c0cdf7ae64" translate="yes" xml:space="preserve">
          <source>Use emergency repair mode to reconfigure the table</source>
          <target state="translated">응급 복구 모드를 사용하여 테이블을 재구성하십시오.</target>
        </trans-unit>
        <trans-unit id="fa6c78a4797a701376427269a923c2b9c592d55a" translate="yes" xml:space="preserve">
          <source>Use simple indexes to efficiently retrieve and order documents by the value of a single field.</source>
          <target state="translated">단일 필드 값으로 문서를 효율적으로 검색하고 주문하려면 간단한 색인을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="03df0bd73e277e326500f2baf39c368061042c3e" translate="yes" xml:space="preserve">
          <source>Use the &amp;ldquo;Run&amp;rdquo; button or Shift+Enter to run the query. Now, let&amp;rsquo;s insert some JSON documents into the table:</source>
          <target state="translated">&quot;Run&quot;버튼 또는 Shift + Enter를 사용하여 쿼리를 실행하십시오. 이제 JSON 문서를 테이블에 삽입 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="2876eba68994921e941ce6ae6a34c2ef904b9ec2" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;dump&lt;/code&gt; subcommand from the command line to create an archive of data from the cluster. This creates a &lt;strong&gt;tar.gz&lt;/strong&gt; file consisting of JSON documents and additional table metadata.</source>
          <target state="translated">명령 행에서 &lt;code&gt;dump&lt;/code&gt; 부속 명령을 사용하여 클러스터에서 데이터 아카이브를 작성하십시오. JSON 문서와 추가 테이블 메타 데이터로 구성된 &lt;strong&gt;tar.gz&lt;/strong&gt; 파일 이 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="eb50f3d35b929185e801b877f1b0751aa34d4633" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;dump&lt;/code&gt; subcommand to create an archive of data from the cluster. This creates a &lt;strong&gt;tar.gz&lt;/strong&gt; file consisting of JSON documents and additional table metadata.</source>
          <target state="translated">&lt;code&gt;dump&lt;/code&gt; 부속 명령을 사용하여 클러스터에서 데이터 아카이브를 작성 하십시오 . JSON 문서와 추가 테이블 메타 데이터로 구성된 &lt;strong&gt;tar.gz&lt;/strong&gt; 파일 이 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="8bbfd294af31d640ef3ad7e899852587e4a1d8cb" translate="yes" xml:space="preserve">
          <source>Use the commands &lt;code&gt;toEpochTime&lt;/code&gt; and &lt;code&gt;toISO8601&lt;/code&gt; to convert back.</source>
          <target state="translated">&lt;code&gt;toEpochTime&lt;/code&gt; 및 &lt;code&gt;toISO8601&lt;/code&gt; 명령을 사용하여 다시 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="25c8ead3ef495e865b02517c55d36f6c25cd0800" translate="yes" xml:space="preserve">
          <source>Use the intracluster port (&lt;code&gt;29015&lt;/code&gt; by default) to connect other nodes in the cluster to this node.</source>
          <target state="translated">클러스터 내 다른 노드를이 노드에 연결 하려면 클러스터 내 포트 ( 기본적으로 &lt;code&gt;29015&lt;/code&gt; )를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="868d9b6e254a3d9e47e5e1742d8635d9345c6ee1" translate="yes" xml:space="preserve">
          <source>Used to &amp;lsquo;zip&amp;rsquo; up the result of a join by merging the &amp;lsquo;right&amp;rsquo; fields into &amp;lsquo;left&amp;rsquo; fields of each member of the sequence.</source>
          <target state="translated">'오른쪽'필드를 시퀀스의 각 멤버의 '왼쪽'필드에 병합하여 조인 결과를 'zip'으로 묶는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="272780d74a89aee8464a61459eba3e0fe818429a" translate="yes" xml:space="preserve">
          <source>Useful RethinkDB commands for exploring data</source>
          <target state="translated">데이터 탐색에 유용한 RethinkDB 명령</target>
        </trans-unit>
        <trans-unit id="cc9b2237413a1771afb24378d67abbf13359869d" translate="yes" xml:space="preserve">
          <source>User account tables</source>
          <target state="translated">사용자 계정 테이블</target>
        </trans-unit>
        <trans-unit id="57f2b181d0a5e79a147ea1cdf41457f58dbbb3c9" translate="yes" xml:space="preserve">
          <source>Users</source>
          <target state="translated">Users</target>
        </trans-unit>
        <trans-unit id="fe239a4bde23258d27dc84379a4d908f81c05df7" translate="yes" xml:space="preserve">
          <source>Users are created by &lt;a href=&quot;../../api/javascript/insert/index&quot;&gt;inserting&lt;/a&gt; documents into the &lt;code&gt;users&lt;/code&gt;&lt;a href=&quot;../system-tables/index&quot;&gt;system table&lt;/a&gt;. Every user has an account name in the &lt;code&gt;id&lt;/code&gt; field, and an optional password.</source>
          <target state="translated">사용자는 &lt;code&gt;users&lt;/code&gt; &lt;a href=&quot;../system-tables/index&quot;&gt;시스템 테이블에&lt;/a&gt; 문서를 &lt;a href=&quot;../../api/javascript/insert/index&quot;&gt;삽입&lt;/a&gt; 하여 작성됩니다 . 모든 사용자는 &lt;code&gt;id&lt;/code&gt; 필드 에 계정 이름 과 선택적 암호를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="b0856eda2a019e0b5196369667b10a81678fe41e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;update&lt;/code&gt; to modify the &lt;code&gt;data&lt;/code&gt; field will normally merge the nested documents:</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 를 사용 하여 &lt;code&gt;data&lt;/code&gt; 필드 를 수정 하면 일반적으로 중첩 된 문서가 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="cb923ef24fa89505954667a416ebf08a8cef2954" translate="yes" xml:space="preserve">
          <source>Using GeoJSON</source>
          <target state="translated">GeoJSON 사용</target>
        </trans-unit>
        <trans-unit id="2ee0b45d99570088519a4ae6ac622316e2428e8c" translate="yes" xml:space="preserve">
          <source>Using JSON data:</source>
          <target state="translated">JSON 데이터 사용 :</target>
        </trans-unit>
        <trans-unit id="5193e9d892132533665ae3d20fb4b221c445f6b7" translate="yes" xml:space="preserve">
          <source>Using RethinkDB with Ruby on Rails</source>
          <target state="translated">Ruby on Rails와 함께 RethinkDB 사용</target>
        </trans-unit>
        <trans-unit id="809b510f6074ebbf8930f56b4cd49a32dc1aa406" translate="yes" xml:space="preserve">
          <source>Using RethinkDB::Handler</source>
          <target state="translated">RethinkDB :: Handler 사용</target>
        </trans-unit>
        <trans-unit id="c87acab6bd223d4993d03d1b63847d6484fd3d19" translate="yes" xml:space="preserve">
          <source>Using SSH tunneling</source>
          <target state="translated">SSH 터널링 사용</target>
        </trans-unit>
        <trans-unit id="f2ecfece0838a81fdbbc9c35122066e4be35b348" translate="yes" xml:space="preserve">
          <source>Using SSL with RethinkDB requires proxy software on the server, such as &lt;a href=&quot;http://nginx.org/&quot;&gt;Nginx&lt;/a&gt;, &lt;a href=&quot;http://www.haproxy.org/&quot;&gt;HAProxy&lt;/a&gt; or an SSL tunnel. RethinkDB will encrypt traffic and verify the CA certification to prevent &lt;a href=&quot;http://en.wikipedia.org/wiki/Man-in-the-middle_attack&quot;&gt;man-in-the-middle&lt;/a&gt; attacks. Consult your proxy&amp;rsquo;s documentation for more details.</source>
          <target state="translated">RethinkDB와 함께 SSL을 사용하려면 서버에 &lt;a href=&quot;http://nginx.org/&quot;&gt;Nginx&lt;/a&gt; , &lt;a href=&quot;http://www.haproxy.org/&quot;&gt;HAProxy&lt;/a&gt; 또는 SSL 터널 과 같은 프록시 소프트웨어가 필요합니다 . RethinkDB는 MITM ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Man-in-the-middle_attack&quot;&gt;Man-in-the-Middle)&lt;/a&gt; 공격 을 방지하기 위해 트래픽을 암호화하고 CA 인증을 확인합니다 . 자세한 내용은 프록시 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="686d16463ab8470f47e9807e2c221cf7aa81ac78" translate="yes" xml:space="preserve">
          <source>Using TLS</source>
          <target state="translated">TLS 사용</target>
        </trans-unit>
        <trans-unit id="1a44d475de27bf8ecc5a4143d17cb29cc4787e26" translate="yes" xml:space="preserve">
          <source>Using a REPL</source>
          <target state="translated">REPL 사용</target>
        </trans-unit>
        <trans-unit id="2d512428ae050cca4f30e03acaad3f9aabd9be07" translate="yes" xml:space="preserve">
          <source>Using a RethinkDB configuration file</source>
          <target state="translated">RethinkDB 구성 파일 사용</target>
        </trans-unit>
        <trans-unit id="d81aacd9868a292e3578d159e7ed1f613ef3b61d" translate="yes" xml:space="preserve">
          <source>Using a function, you can also group by date on a ReQL &lt;a href=&quot;../../../docs/dates-and-times/javascript/index&quot;&gt;date field&lt;/a&gt;.</source>
          <target state="translated">기능을 사용하여 ReQL &lt;a href=&quot;../../../docs/dates-and-times/javascript/index&quot;&gt;날짜 필드&lt;/a&gt; 에서 날짜별로 그룹화 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b9ec5caa02a4c07b8f2e3c0442f8ca0f1179a72" translate="yes" xml:space="preserve">
          <source>Using a similar technique to the last recipe, we can use &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;replace&lt;/code&gt; to maintain a document&amp;rsquo;s &lt;code&gt;updated_at&lt;/code&gt; and &lt;code&gt;created_at&lt;/code&gt; fields by either inserting a new document or updating one depending on whether a document with a specified ID exists.</source>
          <target state="translated">마지막 레시피와 유사한 기술을 사용하여 &lt;code&gt;branch&lt;/code&gt; 및 &lt;code&gt;replace&lt;/code&gt; 를 사용하여 지정된 ID를 가진 문서가 존재하는지 여부에 따라 새 문서를 삽입하거나 문서를 업데이트 하여 문서의 &lt;code&gt;updated_at&lt;/code&gt; 및 &lt;code&gt;created_at&lt;/code&gt; 필드 를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6faf0ceb9a6f33df301c462b697d88b9951a190c" translate="yes" xml:space="preserve">
          <source>Using dynamic keys in ReQL commands</source>
          <target state="translated">ReQL 명령에서 동적 키 사용</target>
        </trans-unit>
        <trans-unit id="237f42b300a70240761ddbdf32a86cce7ecb363c" translate="yes" xml:space="preserve">
          <source>Using embedded arrays</source>
          <target state="translated">임베디드 어레이 사용</target>
        </trans-unit>
        <trans-unit id="97a6a1a45f47d0216453781940f9099c52dec943" translate="yes" xml:space="preserve">
          <source>Using form-encoded data:</source>
          <target state="translated">양식 인코딩 데이터 사용 :</target>
        </trans-unit>
        <trans-unit id="67bce4759a1cb93217026e515d5d3cc2b3774b9a" translate="yes" xml:space="preserve">
          <source>Using indexes: &lt;a href=&quot;../../../api/javascript/get_all/index&quot;&gt;getAll&lt;/a&gt;, &lt;a href=&quot;../../../api/javascript/between/index&quot;&gt;between&lt;/a&gt;, &lt;a href=&quot;../../../api/javascript/eq_join/index&quot;&gt;eqJoin&lt;/a&gt; and &lt;a href=&quot;../../../api/javascript/order_by/index&quot;&gt;orderBy&lt;/a&gt;</source>
          <target state="translated">인덱스를 사용하여 : &lt;a href=&quot;../../../api/javascript/get_all/index&quot;&gt;getAll 메&lt;/a&gt; , &lt;a href=&quot;../../../api/javascript/between/index&quot;&gt;사이&lt;/a&gt; , &lt;a href=&quot;../../../api/javascript/eq_join/index&quot;&gt;eqJoin&lt;/a&gt; 및 &lt;a href=&quot;../../../api/javascript/order_by/index&quot;&gt;해 orderBy을&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a8c903deddf1788950d2da6460df95c1c59112ce" translate="yes" xml:space="preserve">
          <source>Using multi indexes and arbitrary expressions together</source>
          <target state="translated">다중 인덱스와 임의의 표현식을 함께 사용</target>
        </trans-unit>
        <trans-unit id="3d5fe0f0b3e1de4f6909c894b998f50d44a3a243" translate="yes" xml:space="preserve">
          <source>Using one Handler with multiple queries</source>
          <target state="translated">여러 쿼리와 함께 하나의 핸들러 사용</target>
        </trans-unit>
        <trans-unit id="e4d9b622d71e22f8696e9db216e36591b73d21e4" translate="yes" xml:space="preserve">
          <source>Using primary keys</source>
          <target state="translated">기본 키 사용</target>
        </trans-unit>
        <trans-unit id="6b170d9f14648ef984442f6e5e63898213d065c9" translate="yes" xml:space="preserve">
          <source>Using repubsub</source>
          <target state="translated">repubsub 사용</target>
        </trans-unit>
        <trans-unit id="1cec89010b614aeb7357b2820307b3ae5393bd2f" translate="yes" xml:space="preserve">
          <source>Using secondary indexes</source>
          <target state="translated">보조 인덱스 사용</target>
        </trans-unit>
        <trans-unit id="5eca378782b329a4026fe26cdc21aac26acd3ebe" translate="yes" xml:space="preserve">
          <source>Using secondary indexes in RethinkDB</source>
          <target state="translated">RethinkDB에서 보조 인덱스 사용</target>
        </trans-unit>
        <trans-unit id="84d838889946a0fac40a5de13ea1a2f43bfbcbdc" translate="yes" xml:space="preserve">
          <source>Using subqueries</source>
          <target state="translated">서브 쿼리 사용</target>
        </trans-unit>
        <trans-unit id="729c7823bfb90d234bb84656173de344c20bea56" translate="yes" xml:space="preserve">
          <source>Using subqueries to return additional fields</source>
          <target state="translated">하위 쿼리를 사용하여 추가 필드 반환</target>
        </trans-unit>
        <trans-unit id="43a6ea12e91af64b785f205dfed680f0218707a4" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;emergency_repair&lt;/code&gt; option on a table will invalidate all the guarantees.</source>
          <target state="translated">테이블 에서 &lt;code&gt;emergency_repair&lt;/code&gt; 옵션을 사용하면 모든 보증이 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="5722bcd22448ac79f109bb697058f2d47ce09231" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;multi&lt;/code&gt; option we can group data by match A, B or C.</source>
          <target state="translated">&lt;code&gt;multi&lt;/code&gt; 옵션을 사용하면 데이터를 일치 A, B 또는 C로 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="705d0b4e12cf0053e511acba4552bde444eb041e" translate="yes" xml:space="preserve">
          <source>Using the RethinkDB authentication system</source>
          <target state="translated">RethinkDB 인증 시스템 사용</target>
        </trans-unit>
        <trans-unit id="dd74d182c641e4c78502d863b44d0aeff1575e54" translate="yes" xml:space="preserve">
          <source>Validation</source>
          <target state="translated">Validation</target>
        </trans-unit>
        <trans-unit id="7b90cb504c43b2a2a9b990be53f6df122a25af9b" translate="yes" xml:space="preserve">
          <source>Values and predicates may be mixed freely in the argument list.</source>
          <target state="translated">값과 술어는 인수 목록에서 자유롭게 혼합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="926d89b38c0fd681c3af2ba8930446b8e5f7318c" translate="yes" xml:space="preserve">
          <source>Values in CSV imports will always be imported as strings. If you want to convert those fields after import to the &lt;code&gt;number&lt;/code&gt; data type, run an &lt;code&gt;update&lt;/code&gt; query that does the conversion. An example runnable in the Data Explorer:</source>
          <target state="translated">CSV 가져 오기의 값은 항상 문자열로 가져옵니다. 가져온 후 해당 필드를 &lt;code&gt;number&lt;/code&gt; 데이터 유형으로 변환하려면 변환을 수행하는 &lt;code&gt;update&lt;/code&gt; 조회를 실행 하십시오. 데이터 탐색기에서 실행할 수있는 예 :</target>
        </trans-unit>
        <trans-unit id="15016d3c7c10ecd1c9597a5f34d435ed31333cb0" translate="yes" xml:space="preserve">
          <source>Venturing into the river</source>
          <target state="translated">강으로 벤딩</target>
        </trans-unit>
        <trans-unit id="f0bcbe1a75a85e68f5324b0bd200d85161e476dd" translate="yes" xml:space="preserve">
          <source>Version V1_0</source>
          <target state="translated">버전 V1_0</target>
        </trans-unit>
        <trans-unit id="cfc78243db15552d9f29c3a8e82edc038370e606" translate="yes" xml:space="preserve">
          <source>Version migration</source>
          <target state="translated">버전 마이그레이션</target>
        </trans-unit>
        <trans-unit id="8dccbe2184e054027478456d942eb37b74c436b7" translate="yes" xml:space="preserve">
          <source>Versions V0_3 and V0_4</source>
          <target state="translated">버전 V0_3 및 V0_4</target>
        </trans-unit>
        <trans-unit id="0ee85caf439b8d9ca0edb97fdd328b72c5f720aa" translate="yes" xml:space="preserve">
          <source>Versions of RethinkDB prior to 2.3 allowed &lt;code&gt;wait&lt;/code&gt; to be called without a table or database specified. This is no longer valid; &lt;code&gt;wait&lt;/code&gt; requires explicit selection of a database or table.</source>
          <target state="translated">2.3 이전의 RethinkDB 버전은 테이블이나 데이터베이스를 지정하지 않고 호출 &lt;code&gt;wait&lt;/code&gt; 를 허용했습니다 . 더 이상 유효하지 않습니다. &lt;code&gt;wait&lt;/code&gt; 는 데이터베이스 또는 테이블을 명시 적으로 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="8348559cdda119c179112149d26acad5abced44c" translate="yes" xml:space="preserve">
          <source>Via a SOCKS proxy</source>
          <target state="translated">SOCKS 프록시를 통해</target>
        </trans-unit>
        <trans-unit id="3869ea92f6e4c30ec5a50a43581bcd31fb6f5b45" translate="yes" xml:space="preserve">
          <source>Via a reverse proxy</source>
          <target state="translated">리버스 프록시를 통해</target>
        </trans-unit>
        <trans-unit id="975a1001ef5a5de638f5bda5e81a0529a895c359" translate="yes" xml:space="preserve">
          <source>Wait for a table or all the tables in a database to be ready. A table may be temporarily unavailable after creation, rebalancing or reconfiguring. The &lt;code&gt;wait&lt;/code&gt; command blocks until the given table (or database) is fully up to date.</source>
          <target state="translated">데이터베이스의 테이블 또는 모든 테이블이 준비 될 때까지 기다리십시오. 작성, 재조정 또는 재구성 후에 테이블을 일시적으로 사용하지 못할 수 있습니다. &lt;code&gt;wait&lt;/code&gt; 주어진 테이블 (또는 데이터베이스)까지 명령 블록은 완전히 최신입니다.</target>
        </trans-unit>
        <trans-unit id="261d399f3036a71cf61c5c84dd87512ac2888ee9" translate="yes" xml:space="preserve">
          <source>Wait for the instance to initialize.</source>
          <target state="translated">인스턴스가 초기화 될 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="d0c1959b0ecb2f56be0b9936d450f3112ec53c98" translate="yes" xml:space="preserve">
          <source>Wait for the specified indexes on this table to be ready, or for all indexes on this table to be ready if no indexes are specified.</source>
          <target state="translated">이 테이블의 지정된 인덱스가 준비 될 때까지 기다리거나 인덱스가 지정되지 않은 경우이 테이블의 모든 인덱스가 준비 될 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="72ca0cead14e5f62674072d67d6d08760af08beb" translate="yes" xml:space="preserve">
          <source>We also let you slice the time into the date and the current time of day (a time and a duration, respectively):</source>
          <target state="translated">또한 시간을 날짜와 현재 시간 (각각 시간과 기간)으로 분할 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7776b91d96b28a68efde88ac27af064591f79f60" translate="yes" xml:space="preserve">
          <source>We also recently contracted Kyle Kingsbury, known to the Internet as &lt;a href=&quot;https://twitter.com/aphyr&quot;&gt;@aphyr&lt;/a&gt;, as an independent researcher to evaluate RethinkDB. He wrote &lt;a href=&quot;https://aphyr.com/tags/RethinkDB&quot;&gt;a pair of blog posts&lt;/a&gt; on how he tested and confirmed RethinkDB clustering and consistency guarantees.</source>
          <target state="translated">또한 최근에 인터넷에 &lt;a href=&quot;https://twitter.com/aphyr&quot;&gt;@aphyr&lt;/a&gt; 이라고 알려진 Kyle Kingsbury와 RethinkDB 를 평가하는 독립적 인 연구원으로 계약했습니다. 그는 RethinkDB 클러스터링 및 일관성 보장을 테스트하고 확인하는 방법에 대한 &lt;a href=&quot;https://aphyr.com/tags/RethinkDB&quot;&gt;블로그 게시물&lt;/a&gt; 을 작성 했습니다.</target>
        </trans-unit>
        <trans-unit id="6d342d6dbf43f23b7c55cc56df79901ba303f19e" translate="yes" xml:space="preserve">
          <source>We always welcome suggestions on how to improve our documentation, or specific ReQL questions.</source>
          <target state="translated">우리는 항상 문서 개선 방법이나 특정 ReQL 질문에 대한 제안을 환영합니다.</target>
        </trans-unit>
        <trans-unit id="9f7018091e8774b88423f84671a497d40e60360f" translate="yes" xml:space="preserve">
          <source>We can also efficiently retrieve documents by their primary key using the &lt;code&gt;get&lt;/code&gt; command. We can use one of the ids generated in the previous example:</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 명령을 사용하여 기본 키로 문서를 효율적으로 검색 할 수도 있습니다 . 이전 예에서 생성 된 ID 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64de53529b50a2fdc1bd84d07e544b9a92f93299" translate="yes" xml:space="preserve">
          <source>We can also specify more in-depth validation on fields. We can modify the &lt;code&gt;Article&lt;/code&gt; model in a few ways to ensure the data has the properties we expect:</source>
          <target state="translated">필드에 대해보다 심층적 인 유효성 검사를 지정할 수도 있습니다. 데이터가 예상 한 속성을 갖도록 몇 가지 방법으로 &lt;code&gt;Article&lt;/code&gt; 모델을 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c63294a56bafc0eef492fd77b1e4ed5da84b133b" translate="yes" xml:space="preserve">
          <source>We can chain the &lt;code&gt;zip&lt;/code&gt; command at the end of the query to merge the two fields into a single document. For example, the following query:</source>
          <target state="translated">쿼리 끝에 &lt;code&gt;zip&lt;/code&gt; 명령을 연결하여 두 필드를 단일 문서로 병합 할 수 있습니다. 예를 들어, 다음 쿼리는</target>
        </trans-unit>
        <trans-unit id="13f934be941448b5e9e200ea54513a21677bf61d" translate="yes" xml:space="preserve">
          <source>We can create a secondary index on the &lt;code&gt;company&lt;/code&gt; field of the &lt;code&gt;companies&lt;/code&gt; table, and perform our query by taking advantage of the secondary index:</source>
          <target state="translated">&lt;code&gt;companies&lt;/code&gt; 테이블 의 &lt;code&gt;company&lt;/code&gt; 필드 에 보조 인덱스를 생성하고 보조 인덱스 를 활용하여 쿼리를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="421ccb395f490935893503fb8285f8416b351dd1" translate="yes" xml:space="preserve">
          <source>We can join the two tables as follows:</source>
          <target state="translated">다음과 같이 두 테이블을 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="238cbcbb68c7b2e609fdf95cbb4c9da849d12481" translate="yes" xml:space="preserve">
          <source>We can model the relationship between authors and posts by using embedded arrays as follows. Consider this example document in the table &lt;code&gt;authors&lt;/code&gt;:</source>
          <target state="translated">임베디드 배열을 사용하여 다음과 같이 저자와 게시물 간의 관계를 모델링 할 수 있습니다. 테이블 &lt;code&gt;authors&lt;/code&gt; 의이 예제 문서를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="64689a843a25c01b96b2b56aefbb1e9ab53997e6" translate="yes" xml:space="preserve">
          <source>We can now filter based on these times:</source>
          <target state="translated">이제 다음 시간을 기준으로 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8b638b442b219f731f46422f2827d1aa6301062" translate="yes" xml:space="preserve">
          <source>We can now sort the stargazers by the number of their followers!</source>
          <target state="translated">이제 팔로워 수에 따라 몽상가를 정렬 할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="c67d818e11b259fa9a1add1ae55aba6b19cb3598" translate="yes" xml:space="preserve">
          <source>We can rewrite the previous query with &lt;code&gt;r.branch&lt;/code&gt; too.</source>
          <target state="translated">&lt;code&gt;r.branch&lt;/code&gt; 를 사용 하여 이전 쿼리를 다시 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d13a4948443772b564d9f81fd28607546884e82" translate="yes" xml:space="preserve">
          <source>We can schedule it on the Tornado IO loop with this code:</source>
          <target state="translated">이 코드를 사용하여 Tornado IO 루프에서 예약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44a3bc4b8cc860b147fafd28edacfcceffded305" translate="yes" xml:space="preserve">
          <source>We can schedule it on the Twisted &lt;code&gt;reactor&lt;/code&gt; with this code:</source>
          <target state="translated">이 코드로 Twisted &lt;code&gt;reactor&lt;/code&gt; 에서 예약 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="937a9712d9866bbe0eeb7d1ad3b0b2515f02e6ff" translate="yes" xml:space="preserve">
          <source>We can use the following syntax:</source>
          <target state="translated">다음과 같은 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="749984b3d67df427b6d7089de846645a0b19255b" translate="yes" xml:space="preserve">
          <source>We compose the query on the client and call &lt;code&gt;run&lt;/code&gt; only once. Remember to call &lt;code&gt;run&lt;/code&gt; only once on the complex query when you&amp;rsquo;re ready for it to be executed.</source>
          <target state="translated">클라이언트에서 쿼리를 작성하고 한 번만 호출을 호출 &lt;code&gt;run&lt;/code&gt; . 복잡한 쿼리를 실행할 준비가되면 복잡한 쿼리에서 한 번만 &lt;code&gt;run&lt;/code&gt; 을 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7fc2949011d5056e98a8b39f265e81ae5fa84b31" translate="yes" xml:space="preserve">
          <source>We define &lt;code&gt;r.monday...r.sunday&lt;/code&gt; and &lt;code&gt;r.january...r.december&lt;/code&gt; for convenience:</source>
          <target state="translated">편의를 위해 &lt;code&gt;r.monday...r.sunday&lt;/code&gt; 및 &lt;code&gt;r.january...r.december&lt;/code&gt; 을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="745b28655c36626ee40e3202ef17f3821beb6747" translate="yes" xml:space="preserve">
          <source>We felt that performing automatic maintenance operations on the cluster (such as adding shards) is a higher-level component, and that it&amp;rsquo;s crucial to have a really good implementation of the lower-level components done first. As a result, the clustering system is organized into three layers:</source>
          <target state="translated">클러스터에서 자동 유지 관리 작업 (예 : 샤드 추가)을 수행하는 것이 더 높은 수준의 구성 요소이며 가장 먼저 낮은 수준의 구성 요소를 제대로 구현하는 것이 중요하다고 생각했습니다. 결과적으로 클러스터링 시스템은 3 개의 계층으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="05c0c11e81d4866e9926eff039590fc5082fe2af" translate="yes" xml:space="preserve">
          <source>We first tested this workload in the &lt;a href=&quot;https://www.rethinkdb.com/api/javascript/run/&quot;&gt;default configuration for RethinkDB which forbids stale reads&lt;/a&gt;. In this configuration, RethinkDB is able to perform 134.7K QPS on a single server. While the overhead of network communication between the servers becomes visible when increasing the cluster size from one to two servers, adding further servers to the cluster demonstrates the near-linear scalability of RethinkDB, up to over 500K QPS on 16 servers.</source>
          <target state="translated">우리는 먼저 &lt;a href=&quot;https://www.rethinkdb.com/api/javascript/run/&quot;&gt;오래된 읽기를 금지하는 RethinkDB&lt;/a&gt; 의 기본 구성 에서이 워크로드를 테스트했습니다 . 이 구성에서 RethinkDB는 단일 서버에서 134.7K QPS를 수행 할 수 있습니다. 하나의 서버에서 두 개의 서버로 클러스터 크기를 늘릴 때 서버 간의 네트워크 통신 오버 헤드가 가시화되지만 클러스터에 서버를 추가하면 16 개의 서버에서 최대 500K QPS까지 RethinkDB의 거의 선형적인 확장 성을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b3bfcc94969b31f058be9abcc163977af2f5f363" translate="yes" xml:space="preserve">
          <source>We found that in a mixed read/write workload, RethinkDB with two servers was able to perform nearly 16K queries per second (QPS) and scaled to almost 120K QPS while in a 16-node cluster. Under a read only workload and synchronous read settings, RethinkDB was able to scale from about 150K QPS on a single node up to over 550K QPS on 16 nodes. Under the same workload, in an asynchronous &amp;ldquo;outdated read&amp;rdquo; setting, RethinkDB went from 150K QPS on one server to 1.3M in a 16-node cluster.</source>
          <target state="translated">혼합 읽기 / 쓰기 워크로드에서 두 개의 서버가있는 RethinkDB는 16 노드 초당 QPS (Quick Per Query)를 수행하고 16 노드 클러스터에서 거의 120K QPS로 확장 할 수 있음을 발견했습니다. 읽기 전용 워크로드 및 동기식 읽기 설정에서 RethinkDB는 단일 노드에서 약 150K QPS에서 16 개 노드에서 최대 550K QPS까지 확장 할 수있었습니다. 동일한 워크로드 하에서 비동기 &quot;구독 된 읽기&quot;설정에서 RethinkDB는 한 서버의 150K QPS에서 16 노드 클러스터의 1.3M으로 이동했습니다.</target>
        </trans-unit>
        <trans-unit id="dbff981f6fd069bd5c8d8cf7eb708cfb69dba1bf" translate="yes" xml:space="preserve">
          <source>We pass the &lt;code&gt;lastName&lt;/code&gt; saved from the previous set to &lt;code&gt;between&lt;/code&gt; as the start index. For the end index, we pass &lt;code&gt;null&lt;/code&gt; to return documents from the start index to the table&amp;rsquo;s end. The &lt;code&gt;leftBound&lt;/code&gt; parameter tells &lt;code&gt;between&lt;/code&gt; not to include the first record, since it was already returned as part of the previous page.</source>
          <target state="translated">우리는 합격 &lt;code&gt;lastName&lt;/code&gt; 로 이전 세트에서 저장 &lt;code&gt;between&lt;/code&gt; 개시 인덱스로. 종료 인덱스의 경우 시작 인덱스에서 테이블 끝으로 문서를 반환하기 위해 &lt;code&gt;null&lt;/code&gt; 을 전달 합니다. &lt;code&gt;leftBound&lt;/code&gt; 의 매개 변수는 이야기 &lt;code&gt;between&lt;/code&gt; 이미 이전 페이지의 일부로 반환 된 이후, 첫 번째 레코드를 포함하지.</target>
        </trans-unit>
        <trans-unit id="5e4ab3e8535ad86d1930d6966ac3b697d68d7c2d" translate="yes" xml:space="preserve">
          <source>We run one query at a time. Results show the average over five runs.</source>
          <target state="translated">한 번에 하나의 쿼리를 실행합니다. 결과는 5 회 이상 평균을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0cfdf1121b09e1f9602550a8e25484415b81e4d7" translate="yes" xml:space="preserve">
          <source>We run this query five times for every cluster size and then calculate the average runtime. The results table below shows these averages.</source>
          <target state="translated">모든 클러스터 크기에 대해이 쿼리를 5 회 실행 한 다음 평균 런타임을 계산합니다. 아래 결과 표는 이러한 평균을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2f9e5f655eaf28e2126ba52b421344bdf3a5d0a2" translate="yes" xml:space="preserve">
          <source>We should get back an object that looks like this:</source>
          <target state="translated">다음과 같은 객체를 다시 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="196493c218ffa561ad6e0835430dcfa5bcdcb59b" translate="yes" xml:space="preserve">
          <source>We use Github for issue tracking: &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues&quot;&gt;https://github.com/rethinkdb/rethinkdb/issues&lt;/a&gt;. If you want to report a suspected bug in RethinkDB, open an issue there.</source>
          <target state="translated">우리는 문제 추적에 Github에서를 사용 &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues&quot;&gt;https://github.com/rethinkdb/rethinkdb/issues를&lt;/a&gt; . RethinkDB에서 의심되는 버그를보고하려면 여기에서 문제를여십시오.</target>
        </trans-unit>
        <trans-unit id="2572dfb8bb2188aed94b74fdd625ca4d557e9b76" translate="yes" xml:space="preserve">
          <source>We use the ISO 8601 definition of a week, which starts with Monday, represented as &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">우리는 월요일로 시작하여 &lt;code&gt;1&lt;/code&gt; 로 표시되는 일주일의 ISO 8601 정의를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="665c5f87426678ac0c4134325d4f37ee25bde4ef" translate="yes" xml:space="preserve">
          <source>We used a port of YCSB based on our official Java driver and intend to submit a pull request for it in the near future. &lt;a href=&quot;https://github.com/rethinkdb/ycsb&quot;&gt;Our fork is available for review here&lt;/a&gt;.</source>
          <target state="translated">공식 Java 드라이버를 기반으로 YCSB 포트를 사용했으며 가까운 시일 내에 풀 요청을 제출하려고합니다. &lt;a href=&quot;https://github.com/rethinkdb/ycsb&quot;&gt;우리의 포크는 여기에서 검토 할 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18dd2c5b2e52082a2c22b308916628b31080863f" translate="yes" xml:space="preserve">
          <source>We wanted to provide a reasonably comprehensive RethinkDB test that covers a variety of different workloads. We chose to use the YCSB testing framework as a reliable and community-approved means of conducting rigorous testing on our database. We saw that all of the tests resulted in near-linear scalability as we moved from a single RethinkDB instance to a 16 node cluster. Although most of the tests resulted in performance metrics that suggest horizontal scalability, we know that there are plenty of improvements to make as the database evolves.</source>
          <target state="translated">우리는 다양한 워크로드를 포괄하는 합리적으로 포괄적 인 RethinkDB 테스트를 제공하고자했습니다. 우리는 YCSB 테스트 프레임 워크를 데이터베이스에서 엄격한 테스트를 수행하는 신뢰할 수 있고 커뮤니티에서 승인 한 수단으로 사용하기로 결정했습니다. 단일 RethinkDB 인스턴스에서 16 노드 클러스터로 이동함에 따라 모든 테스트에서 거의 선형으로 확장 할 수있는 것으로 나타났습니다. 대부분의 테스트에서 수평 적 확장 성을 암시하는 성능 메트릭이 생성되었지만 데이터베이스가 발전함에 따라 많은 개선이 이루어지고 있음을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="f96b69538b15b08a373ab863833264fbb5d412fa" translate="yes" xml:space="preserve">
          <source>We were fortunate enough to receive free credits from Rackspace to perform the majority of these tests and are very grateful for their contributions to open source software. All of &lt;a href=&quot;https://www.rackspace.com/cloud/servers/onmetal&quot;&gt;Rackspace&amp;rsquo;s OnMetal offerings can be found here&lt;/a&gt;.</source>
          <target state="translated">우리는 이러한 테스트의 대부분을 수행하기 위해 Rackspace로부터 무료 크레딧을받을 수있을만큼 운이 좋았으며 오픈 소스 소프트웨어에 대한 기여에 매우 감사했습니다. &lt;a href=&quot;https://www.rackspace.com/cloud/servers/onmetal&quot;&gt;Rackspace의&lt;/a&gt; 모든 OnMetal 제품은 여기에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="164561a49c5ec1d8b8043aa717cadb49a0004f16" translate="yes" xml:space="preserve">
          <source>We won&amp;rsquo;t need a &lt;strong&gt;group&lt;/strong&gt; step for this example.</source>
          <target state="translated">이 예제 에서는 &lt;strong&gt;그룹&lt;/strong&gt; 단계 가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5adda084a6c0ad257b70d2264a1e0d1c00f337fa" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;d love to answer any questions you have about these tests. Come join us at &lt;a href=&quot;http://slack.rethinkdb.com&quot;&gt;http://slack.rethinkdb.com&lt;/a&gt; and feel free to ask more specific questions we don&amp;rsquo;t answer here by pinging @danielmewes or @dalanmiller.</source>
          <target state="translated">이 테스트에 대한 질문에 답하고 싶습니다. &lt;a href=&quot;http://slack.rethinkdb.com&quot;&gt;http://slack.rethinkdb.com&lt;/a&gt; 에서 우리와 함께 하고 @danielmewes 또는 @dalanmiller를 ping하여 여기에 대답하지 않은 더 구체적인 질문을 자유롭게하십시오.</target>
        </trans-unit>
        <trans-unit id="60cf0d58afd9a9633a947183c3b149f711f93f0f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll attempt to answer these questions by using workloads from the YCSB benchmark suite. You can &lt;a href=&quot;https://labs.yahoo.com/news/yahoo-cloud-serving-benchmark&quot;&gt;learn more about YCSB here&lt;/a&gt;, and &lt;a href=&quot;https://github.com/rethinkdb/ycsb&quot;&gt;review the source code here&lt;/a&gt;. Expanding beyond the YCSB workloads we selected, we created an additional test which investigates scalability for analytic workloads.</source>
          <target state="translated">YCSB 벤치 마크 제품군의 워크로드를 사용하여 이러한 질문에 대답하려고합니다. 당신은 할 수 있습니다 &lt;a href=&quot;https://labs.yahoo.com/news/yahoo-cloud-serving-benchmark&quot;&gt;여기에 YCSB에 대한 자세한 내용은&lt;/a&gt; , 그리고 &lt;a href=&quot;https://github.com/rethinkdb/ycsb&quot;&gt;여기에 소스 코드를 검토&lt;/a&gt; . 우리가 선택한 YCSB 워크로드를 넘어서서, 우리는 분석 워크로드의 확장 성을 조사하는 추가 테스트를 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="353d7cec36aac636b04e7dd7fdc90d2f15428252" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll go over the other two sources in more detail.</source>
          <target state="translated">다른 두 가지 소스를 자세히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="85193fc8eeecb00e53dca414ff426e4d326bd9f6" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll sign an NDA if necessary, and can set up an FTP server for you to transfer the file to if it&amp;rsquo;s large.</source>
          <target state="translated">필요한 경우 NDA에 서명하고 파일이 큰 경우 FTP 서버를 설정하여 파일을 전송할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66df9144e5385962d5f6afd0a4d7f84e1cf0c9a6" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re exploring best practices to determine whether it&amp;rsquo;s possible to build a really good general purpose automation layer that controls the cluster by automatically enforcing user-specified rules (such as resharding the system when the shard balance drops below a certain threshold).</source>
          <target state="translated">우리는 사용자 지정 규칙 (예 : 샤드 밸런스가 특정 임계 값 아래로 떨어질 때 시스템의 리 샤딩)을 자동으로 적용하여 클러스터를 제어하는 ​​훌륭한 범용 자동화 계층을 구축 할 수 있는지 확인하기위한 모범 사례를 모색하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a538ffd70620351939ce46ac034c5da4165359af" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re working on an easier syntax for performing multiple aggregations after &lt;code&gt;group&lt;/code&gt; commands. Follow &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/1725&quot;&gt;issue 1725&lt;/a&gt; to track progress on this.</source>
          <target state="translated">&lt;code&gt;group&lt;/code&gt; 명령 후에 여러 집계를 수행하기위한 더 쉬운 구문을 개발 중 입니다. &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/1725&quot;&gt;1725 호에&lt;/a&gt; 따라 진행 상황을 추적하십시오.</target>
        </trans-unit>
        <trans-unit id="bf8c4b29bb88f8bd8bcd0cf73f362e495df9a83a" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve just inserted two rows into the &lt;code&gt;tv_shows&lt;/code&gt; table. Let&amp;rsquo;s verify the number of rows inserted:</source>
          <target state="translated">&lt;code&gt;tv_shows&lt;/code&gt; 테이블에 두 개의 행을 삽입했습니다 . 삽입 된 행 수를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0701e0f428cf7608aac0acb0258957e688e4a72b" translate="yes" xml:space="preserve">
          <source>Web frontend written in PHP to create/rename/update/delete RethinkDB databases/tables/docs and run ReQL queries in PHP.</source>
          <target state="translated">PHP로 작성된 웹 프론트 엔드는 RethinkDB 데이터베이스 / 테이블 / 문서를 작성 / 이름 바꾸기 / 업데이트 / 삭제하고 PHP에서 ReQL 쿼리를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="7a6ea1d18d178d755c66b826316925c783a2b7a2" translate="yes" xml:space="preserve">
          <source>Web options</source>
          <target state="translated">웹 옵션</target>
        </trans-unit>
        <trans-unit id="bc84915ab33bd5e1a1327bf7c2b3bb4fd9f8f422" translate="yes" xml:space="preserve">
          <source>WebGL</source>
          <target state="translated">WebGL</target>
        </trans-unit>
        <trans-unit id="38dbec004299870c0658d95152cb99afac826447" translate="yes" xml:space="preserve">
          <source>Wercker box for RethinkDB, by &lt;a href=&quot;https://github.com/mies&quot;&gt;@mies&lt;/a&gt;.</source>
          <target state="translated">Wercker에 의해, RethinkDB에 대한 상자 &lt;a href=&quot;https://github.com/mies&quot;&gt;@mies&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04042d6ae7f7ec89f3280cedaa0c0eacdb0730a2" translate="yes" xml:space="preserve">
          <source>What CAP theorem tradeoffs are made in RethinkDB?</source>
          <target state="translated">RethinkDB에서 어떤 CAP 정리 트레이드 오프가 이루어 집니까?</target>
        </trans-unit>
        <trans-unit id="3ef0a4b65de6f3a94060b4fcb91fcc42ad42201d" translate="yes" xml:space="preserve">
          <source>What Elasticsearch does</source>
          <target state="translated">Elasticsearch의 기능</target>
        </trans-unit>
        <trans-unit id="c9d3e613df197c31b8cbb198ef82019567e7ac08" translate="yes" xml:space="preserve">
          <source>What are availability and performance impacts of sharding and replication?</source>
          <target state="translated">샤딩 및 복제의 가용성 및 성능 영향은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="64c26d1ad1ec301943108eaa27899279ef7ac1fd" translate="yes" xml:space="preserve">
          <source>What does &amp;lsquo;received invalid clustering header&amp;rsquo; mean?</source>
          <target state="translated">'유효하지 않은 클러스터링 헤더 수신'이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2a9c3f058de7e47106c818dfd4d4338f9cdd8f8d" translate="yes" xml:space="preserve">
          <source>What does it mean to be inefficient here? When operating on grouped data rather than a grouped stream, &lt;em&gt;all&lt;/em&gt; of the data has to be available on the node processing the query. This means that the operation will only use one server&amp;rsquo;s resources, and will require memory proportional to the size of the grouped data it&amp;rsquo;s operating on. (In the case of the &lt;a href=&quot;../order_by/index&quot;&gt;orderBy&lt;/a&gt; in the inefficient example, that means memory proportional &lt;strong&gt;to the size of the table&lt;/strong&gt;.) The array limit is also enforced for grouped data, so the &lt;code&gt;orderBy&lt;/code&gt; example would fail for tables with more than 100,000 rows without changing the &lt;code&gt;arrayLimit&lt;/code&gt; option to &lt;code&gt;run&lt;/code&gt;.</source>
          <target state="translated">여기서 비효율적이라는 것은 무엇을 의미합니까? 그룹화 된 스트림이 아닌 그룹화 된 데이터를 조작 할 때는 &lt;em&gt;모든&lt;/em&gt; 데이터를 쿼리를 처리하는 노드에서 사용할 수 있어야합니다. 즉, 작업은 하나의 서버 리소스 만 사용하며 작업중인 그룹화 된 데이터의 크기에 비례하는 메모리가 필요합니다. ( 비효율적 인 예에서 &lt;a href=&quot;../order_by/index&quot;&gt;orderBy&lt;/a&gt; 의 경우 &lt;strong&gt;이는 테이블 크기에&lt;/strong&gt; 비례하는 메모리를 의미 &lt;strong&gt;합니다&lt;/strong&gt; .) 그룹화 된 데이터에 대해서도 배열 제한이 적용되므로 &lt;code&gt;orderBy&lt;/code&gt; 예는 &lt;code&gt;arrayLimit&lt;/code&gt; 옵션을 &lt;code&gt;run&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="04e01954d9f8d8e77895e864b870472fafc1d2fc" translate="yes" xml:space="preserve">
          <source>What governs the location of shards and replicas in the cluster?</source>
          <target state="translated">클러스터에서 샤드 및 복제본의 위치를 ​​결정하는 것은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="aeecbe039cd869cf6b58de21cfda895bec05bbb8" translate="yes" xml:space="preserve">
          <source>What happens when a server becomes unreachable?</source>
          <target state="translated">서버에 접근 할 수 없게되면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="84f1d71d28f72c7bce86041433bf5e9d8269c36b" translate="yes" xml:space="preserve">
          <source>What is RethinkDB?</source>
          <target state="translated">RethinkDB 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="792fc2e237565f7453ac727b16937607f543048d" translate="yes" xml:space="preserve">
          <source>What sort of performance can I expect from a RethinkDB cluster?</source>
          <target state="translated">RethinkDB 클러스터에서 어떤 종류의 성능을 기대할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="c273c7432071ee60c46a1ad37f5833a8812489f7" translate="yes" xml:space="preserve">
          <source>What to do after a crash</source>
          <target state="translated">충돌 후해야 할 일</target>
        </trans-unit>
        <trans-unit id="e860c67987579ed63e69cb49c8bae21cee8ab0f2" translate="yes" xml:space="preserve">
          <source>What you likely want is the result of using &lt;code&gt;zip&lt;/code&gt; with that. For clarity, we&amp;rsquo;ll use &lt;code&gt;without&lt;/code&gt; to drop the &lt;code&gt;id&lt;/code&gt; field from the games table (it conflicts with the &lt;code&gt;id&lt;/code&gt; field for the players and it&amp;rsquo;s redundant anyway), and we&amp;rsquo;ll order it by the games.</source>
          <target state="translated">원하는 것은 &lt;code&gt;zip&lt;/code&gt; 을 사용하여 얻은 결과입니다 . 명확성 을 위해 게임 테이블에서 &lt;code&gt;id&lt;/code&gt; 필드 를 삭제 &lt;code&gt;without&lt;/code&gt; 사용 합니다 ( 플레이어 의 &lt;code&gt;id&lt;/code&gt; 필드 와 충돌 하므로 중복됩니다). 게임별로 주문합니다.</target>
        </trans-unit>
        <trans-unit id="b2412f7ca4f8b6170188b11c9ed6cd4be9e075b0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;count&lt;/code&gt; is called on a sequence with a predicate value or function, it returns the number of elements in the sequence equal to that value or where the function returns &lt;code&gt;true&lt;/code&gt;. On a &lt;a href=&quot;../binary/index&quot;&gt;binary&lt;/a&gt; object, &lt;code&gt;count&lt;/code&gt; returns the size of the object in bytes; on strings, &lt;code&gt;count&lt;/code&gt; returns the string&amp;rsquo;s length. This is determined by counting the number of Unicode codepoints in the string, counting combining codepoints separately.</source>
          <target state="translated">되면 &lt;code&gt;count&lt;/code&gt; 술어 값 또는 함수 호출 시퀀스, 그것은 일련의 요소 수는 그 값 또는 여기서 함수 반환 동일 반환 &lt;code&gt;true&lt;/code&gt; . A의 &lt;a href=&quot;../binary/index&quot;&gt;이진&lt;/a&gt; 개체 &lt;code&gt;count&lt;/code&gt; 바이트 단위로 개체의 크기를 반환; 문자열에서 &lt;code&gt;count&lt;/code&gt; 는 문자열의 길이를 반환합니다. 이는 문자열에서 유니 코드 코드 포인트 수를 계산하고 코드 포인트를 개별적으로 결합하여 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4a943aaea897090869701fc63a61450e4a044356" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;includeTypes&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, there will be three fields:</source>
          <target state="translated">때 &lt;code&gt;includeTypes&lt;/code&gt; 이 있다 &lt;code&gt;true&lt;/code&gt; , 세 개의 필드가있을 것입니다 :</target>
        </trans-unit>
        <trans-unit id="db59537e91adcaeb56b2666cc25c2ed2d6fefa3a" translate="yes" xml:space="preserve">
          <source>When a RethinkDB node starts, it will broadcast its &amp;ldquo;canonical&amp;rdquo; IP address, the address other nodes should use to connect to it. By default, the canonical address is the server&amp;rsquo;s primary IP address. However, if this address is an internal IP address that isn&amp;rsquo;t reachable by other nodes (for example, the nodes are on different networks), the nodes will not be able to reach one another. You may receive an error message such as:</source>
          <target state="translated">RethinkDB 노드가 시작되면 &quot;정식&quot;IP 주소를 브로드 캐스트하고 다른 노드가 해당 노드에 연결하는 데 사용해야하는 주소를 브로드 캐스트합니다. 기본적으로 표준 주소는 서버의 기본 IP 주소입니다. 그러나이 주소가 다른 노드에서 도달 할 수없는 내부 IP 주소 인 경우 (예 : 노드가 다른 네트워크에있는 경우) 노드가 서로 연결할 수 없습니다. 다음과 같은 오류 메시지가 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbdb94ecb03dbf42358c1312dbd7d67d5be3564f" translate="yes" xml:space="preserve">
          <source>When a document is deleted, &lt;code&gt;new_val&lt;/code&gt; will be &lt;code&gt;null&lt;/code&gt;; when a document is inserted, &lt;code&gt;old_val&lt;/code&gt; will be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">문서가 삭제되면 &lt;code&gt;new_val&lt;/code&gt; 은 &lt;code&gt;null&lt;/code&gt; 이됩니다 . 문서가 삽입되면 &lt;code&gt;old_val&lt;/code&gt; 은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="703065bb49bf10d98540e55348b4199e4bf90f6b" translate="yes" xml:space="preserve">
          <source>When a node in the cluster receives a query from the client, it evaluates the query in the following way.</source>
          <target state="translated">클러스터의 노드가 클라이언트로부터 쿼리를 받으면 다음과 같은 방법으로 쿼리를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="7895cfeb7489d6ebc6349cdf88d440ab9cae0b6b" translate="yes" xml:space="preserve">
          <source>When a server connects or disconnects, its log entries will be added to or removed from the &lt;code&gt;logs&lt;/code&gt; table. The action of connecting or disconnecting will not generate changefeed events for those log entries.</source>
          <target state="translated">서버가 연결되거나 연결이 끊어지면 해당 로그 항목이 &lt;code&gt;logs&lt;/code&gt; 테이블에 추가되거나 로그 테이블 에서 제거됩니다 . 연결 또는 연결 해제 조치는 해당 로그 항목에 대한 변경 피드 이벤트를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="734fd0f99a381fd084bb9daae0c46a98286a6f99" translate="yes" xml:space="preserve">
          <source>When a server fails, it may be because of a network availability issue or something more serious, such as system failure. In a multi-server configuration, where tables have multiple replicas distributed among multiple physical machines, RethinkDB will be able to maintain availability automatically in many cases.</source>
          <target state="translated">서버가 실패하면 네트워크 가용성 문제 또는 시스템 오류와 같은 더 심각한 문제 때문일 수 있습니다. 테이블에 여러 개의 실제 머신에 여러 개의 복제본이 분산되어있는 다중 서버 구성에서 RethinkDB는 많은 경우 자동으로 가용성을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff4dc39866df867c372286f6ac82dbbab1db65cb" translate="yes" xml:space="preserve">
          <source>When applied to a single object, &lt;code&gt;hasFields&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if the object has the fields and &lt;code&gt;false&lt;/code&gt; if it does not. When applied to a sequence, it will return a new sequence (an array or stream) containing the elements that have the specified fields.</source>
          <target state="translated">단일 객체에 적용될 때 &lt;code&gt;hasFields&lt;/code&gt; 는 객체에 필드가 있으면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다. 시퀀스에 적용되면 지정된 필드가있는 요소가 포함 된 새 시퀀스 (배열 또는 스트림)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b45a355356ae32e6ce951e83aa32fd7dafeeac3c" translate="yes" xml:space="preserve">
          <source>When called with values, returns &lt;code&gt;true&lt;/code&gt; if a sequence contains all the specified values. When called with predicate functions, returns &lt;code&gt;true&lt;/code&gt; if for each predicate there exists at least one element of the stream where that predicate returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">값과 함께 호출되면 시퀀스에 지정된 모든 값이 포함되어 있으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 술어 함수를 호출하는 경우, 반환 &lt;code&gt;true&lt;/code&gt; 각 술어 곳 술어 반환 스트림의 적어도 하나 개의 요소가 존재하는 경우 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f48292c69cb277e3b22337ed22c98c2ced2902a" translate="yes" xml:space="preserve">
          <source>When creating a table you can specify the following options:</source>
          <target state="translated">테이블을 만들 때 다음 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95ca91852d7312c3e3e0989f96be0729d530f742" translate="yes" xml:space="preserve">
          <source>When grouped data are returned to the client, they are transformed into a client-specific native type. (Something similar is done with &lt;a href=&quot;../../../docs/dates-and-times/javascript/index&quot;&gt;times&lt;/a&gt;.) In JavaScript, grouped data are transformed into an &lt;code&gt;Array&lt;/code&gt;. If you instead want to receive the raw pseudotype from the server, you can specify &lt;code&gt;groupFormat: 'raw'&lt;/code&gt; as an optional argument to &lt;code&gt;run&lt;/code&gt;:</source>
          <target state="translated">그룹화 된 데이터가 클라이언트로 리턴되면 클라이언트 특정 기본 유형으로 변환됩니다. (함께 수행 비슷한 &lt;a href=&quot;../../../docs/dates-and-times/javascript/index&quot;&gt;시간&lt;/a&gt; .) 자바 스크립트는, 그룹화 된 데이터는로 변환되는 &lt;code&gt;Array&lt;/code&gt; . 대신 서버에서 원시 의사 유형을 수신하려는 경우 &lt;code&gt;run&lt;/code&gt; 선택적 인수로 &lt;code&gt;groupFormat: 'raw'&lt;/code&gt; 를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="733c238b3057fb40dff28896edf33c02a6ec4626" translate="yes" xml:space="preserve">
          <source>When new servers (including proxies) join an existing cluster, it will synchronize with all the user account information, including passwords, from that cluster. This includes the &lt;code&gt;admin&lt;/code&gt; account. However, a server with no admin password set cannot join an existing cluster that &lt;em&gt;does&lt;/em&gt; have a password set. Otherwise, it would technically be possible for an attacker to connect to that server as an admin and run arbitrary queries in the time between that server starting and the accounts synchronizing from the rest of the cluster.</source>
          <target state="translated">새 서버 (프록시 포함)가 기존 클러스터에 참여하면 해당 클러스터의 비밀번호를 포함한 모든 사용자 계정 정보와 동기화됩니다. 여기에는 &lt;code&gt;admin&lt;/code&gt; 계정 이 포함 됩니다. 그러나, 관리자 암호가 설정된 서버는 기존 클러스터에 참가할 수 없습니다 &lt;em&gt;않는&lt;/em&gt; 암호가 설정되어 있습니다. 그렇지 않으면 기술적으로 공격자가 해당 서버에 관리자로 연결하여 해당 서버 시작과 나머지 클러스터에서 동기화되는 계정 사이의 시간 내에 임의의 쿼리를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39499a0cd2439f58a90448079631a689bc240bd5" translate="yes" xml:space="preserve">
          <source>When paging occurs on RethinkDB&amp;rsquo;s process, performance will be adversely affected, and the more paging occurs the worse performance will be. You may be able to address it by ensuring other applications are not using physical memory on the server, tuning the paging cache, or adding more RAM to the server.</source>
          <target state="translated">RethinkDB 프로세스에서 페이징이 발생하면 성능에 부정적인 영향을 미치며 페이징이 많을수록 성능이 저하됩니다. 다른 응용 프로그램이 서버에서 실제 메모리를 사용하지 않도록하거나 페이징 캐시를 조정하거나 서버에 RAM을 추가하여이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0ee88af11d3830bf42ab1d4973a89c0606e33c7" translate="yes" xml:space="preserve">
          <source>When posting a message to a topic, first repubsub attempts to overwrite a document with the exact same topic. If the exact topic isn&amp;rsquo;t found, it creates a new document with the topic.</source>
          <target state="translated">주제에 메시지를 게시 할 때 먼저 repubsub는 정확히 동일한 주제로 문서를 덮어 씁니다. 정확한 주제를 찾을 수 없으면 주제가 포함 된 새 문서를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="39c16909e8c88df0ea5a422f64978472b8724466" translate="yes" xml:space="preserve">
          <source>When servers are tagged, you can use the tags in the &lt;a href=&quot;https://rethinkdb.com/api/python/reconfigure&quot;&gt;reconfigure&lt;/a&gt; command. To assign 3 replicas of the &lt;code&gt;users&lt;/code&gt; table to &lt;code&gt;us_west&lt;/code&gt; and 2 to &lt;code&gt;us_east&lt;/code&gt;:</source>
          <target state="translated">서버에 태그가 지정되면 &lt;a href=&quot;https://rethinkdb.com/api/python/reconfigure&quot;&gt;reconfigure&lt;/a&gt; 명령 에서 태그를 사용할 수 있습니다 . &lt;code&gt;users&lt;/code&gt; 테이블 의 3 개 복제본 을 &lt;code&gt;us_west&lt;/code&gt; 에 , 2를 &lt;code&gt;us_east&lt;/code&gt; 에 할당하려면 다음 을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="786f7d315c87c4bca4d9c2b6ce53eda3ca9303b5" translate="yes" xml:space="preserve">
          <source>When starting RethinkDB from the command line, the cache size limit is set through the &lt;code&gt;--cache-size &amp;lt;limit in MB&amp;gt;&lt;/code&gt; argument:</source>
          <target state="translated">명령 행에서 RethinkDB를 시작할 때 캐시 크기 제한은 &lt;code&gt;--cache-size &amp;lt;limit in MB&amp;gt;&lt;/code&gt; 인수를 통해 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="79c7ae19c81131fd14f6580c4d04a2dee10e9f6b" translate="yes" xml:space="preserve">
          <source>When the RethinkDB instance is ready, click on its &lt;strong&gt;Access Software&lt;/strong&gt; link.</source>
          <target state="translated">RethinkDB 인스턴스가 준비되면 &lt;strong&gt;액세스 소프트웨어&lt;/strong&gt; 링크를 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="01a54f9b1d8b2e5e569294b706e164e9b5699c16" translate="yes" xml:space="preserve">
          <source>When the driver finds an anonymous function, it returns a query object like this one:</source>
          <target state="translated">드라이버가 익명 함수를 찾으면 다음과 같은 쿼리 개체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="46d0359667f7a0c929b209d338b0f9a3993f1d7d" translate="yes" xml:space="preserve">
          <source>When the option is available, you should choose the JSON file format. If you&amp;rsquo;re exporting from a SQL database this might not be possible, but you might be able to write a separate script to transform CSV output into JSON, or use the &lt;code&gt;mysql2json&lt;/code&gt; script available as part of &lt;a href=&quot;https://github.com/seamusabshere/mysql2xxxx&quot;&gt;mysql2xxxx&lt;/a&gt;.</source>
          <target state="translated">옵션이 사용 가능하면 JSON 파일 형식을 선택해야합니다. 당신은 SQL 데이터베이스에서 내보내는 경우,이 힘은 가능하지,하지만 당신은 JSON으로 CSV 출력을 변환하거나 사용하기 위해 별도의 스크립트를 작성할 수있을 &lt;code&gt;mysql2json&lt;/code&gt; 의 의 일부로 사용할 스크립트를 &lt;a href=&quot;https://github.com/seamusabshere/mysql2xxxx&quot;&gt;mysql2xxxx&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5717a00ca57bc298ae32605ce5314580ad4d3f3" translate="yes" xml:space="preserve">
          <source>When the user creates a table, they have the option of specifying the attribute that will serve as the primary key (if the primary key attribute isn&amp;rsquo;t specified, it defaults to &amp;lsquo;id&amp;rsquo;). When the user inserts a document into the table, if the document contains the primary key attribute, its value is used to index the document. Otherwise, a random unique ID is generated for the index automatically.</source>
          <target state="translated">사용자가 테이블을 작성할 때 기본 키 역할을하는 속성을 지정하는 옵션이 있습니다 (기본 키 속성이 지정되지 않은 경우 기본값은 'id'). 사용자가 문서를 테이블에 삽입 할 때 문서에 기본 키 속성이 포함 된 경우 해당 값은 문서를 색인화하는 데 사용됩니다. 그렇지 않으면 인덱스에 대해 임의의 고유 ID가 자동으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f13c50073789e73f7832addb638ad24cfe0cc700" translate="yes" xml:space="preserve">
          <source>When using the web UI, simply specify the number of shards you want, and based on the data available RethinkDB will determine the best split points to maintain balanced shards. To shard your data:</source>
          <target state="translated">웹 UI를 사용하는 경우 원하는 샤드 수를 지정하면 사용 가능한 데이터를 기반으로 RethinkDB가 균형 잡힌 샤드를 유지하기위한 최상의 분리 점을 결정합니다. 데이터를 샤딩하려면 :</target>
        </trans-unit>
        <trans-unit id="085a0570038dfb7cf2cfd3cbed19548b2d1f7c9c" translate="yes" xml:space="preserve">
          <source>When you first start RethinkDB, the server opens a port for the client drivers (&lt;code&gt;28015&lt;/code&gt; by default). Let&amp;rsquo;s open a connection:</source>
          <target state="translated">RethinkDB를 처음 시작하면 서버가 클라이언트 드라이버 용 포트를 엽니 다 ( 기본적으로 &lt;code&gt;28015&lt;/code&gt; ). 연결을 열어 봅시다 :</target>
        </trans-unit>
        <trans-unit id="35057656e095ebe83647859420615be9709172fb" translate="yes" xml:space="preserve">
          <source>When you issue a write query (&lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, or &lt;code&gt;replace&lt;/code&gt;), RethinkDB returns a summary object that looks like this:</source>
          <target state="translated">쓰기 쿼리 ( &lt;code&gt;insert&lt;/code&gt; , &lt;code&gt;delete&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; 또는 &lt;code&gt;replace&lt;/code&gt; )를 실행하면 RethinkDB는 다음과 같은 요약 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9adc3f762a66ce024127380f3784d16c509e1f05" translate="yes" xml:space="preserve">
          <source>When you parse the response string as JSON, you get the object:</source>
          <target state="translated">응답 문자열을 JSON으로 구문 분석하면 객체가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="715d798b7e9cd5985d005f0aed4eba85867d2b96" translate="yes" xml:space="preserve">
          <source>When you pass functions to ReQL, your language&amp;rsquo;s driver serializes those functions into ReQL lambda functions that are run on the server, not in your client language. (See &lt;a href=&quot;https://rethinkdb.com/blog/lambda-functions/&quot;&gt;All about lambda functions in RethinkDB queries&lt;/a&gt; for more details.) A consequence of this is that native language constructs like &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;for&lt;/code&gt; will not produce the expected result when their conditions involve ReQL commands. While they may not cause errors, they will be executed on the client side before the function is compiled for ReQL, and thus give an incorrect result. Instead, you must use equivalent ReQL control functions such as &lt;a href=&quot;../../api/javascript/branch/index&quot;&gt;branch&lt;/a&gt; and &lt;a href=&quot;../../api/javascript/for_each/index&quot;&gt;forEach&lt;/a&gt;. Here&amp;rsquo;s an example in Python from the &lt;a href=&quot;../introduction-to-reql/index&quot;&gt;Introduction to ReQL&lt;/a&gt; document:</source>
          <target state="translated">함수를 ReQL에 전달하면 언어 드라이버가 해당 함수를 클라이언트 언어가 아닌 서버에서 실행되는 ReQL 람다 함수로 직렬화합니다. 자세한 내용 &lt;a href=&quot;https://rethinkdb.com/blog/lambda-functions/&quot;&gt;은 RethinkDB 쿼리의 람다 함수에 대한 모든 내용&lt;/a&gt; 을 참조하십시오. 그 결과 조건에 ReQL 명령이 포함 된 &lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;for&lt;/code&gt; 와 같은 모국어 는 예상 결과를 생성하지 않습니다. 오류가 발생하지는 않지만, 함수가 ReQL 용으로 컴파일되기 전에 클라이언트 측에서 실행되어 잘못된 결과를 제공합니다. 대신 &lt;a href=&quot;../../api/javascript/branch/index&quot;&gt;branch&lt;/a&gt; 및 &lt;a href=&quot;../../api/javascript/for_each/index&quot;&gt;forEach&lt;/a&gt; 와 같은 동등한 ReQL 제어 기능을 사용해야합니다 . 다음은 파이썬에서 &lt;a href=&quot;../introduction-to-reql/index&quot;&gt;Introduction to ReQL&lt;/a&gt; 에 대한 예제입니다 문서:</target>
        </trans-unit>
        <trans-unit id="3b0d34296f9afa1b34c187838548381f1a1a9da2" translate="yes" xml:space="preserve">
          <source>When you turn on pagination in &lt;code&gt;r.http&lt;/code&gt;, instead of returning an array of documents, RethinkDB returns a stream which you can access in the driver via the usual cursor API. This is significant because pagination happens lazily &amp;mdash; RethinkDB will request new pages as you iterate through the cursor to minimize the number of API calls.</source>
          <target state="translated">&lt;code&gt;r.http&lt;/code&gt; 에서 페이지 매김을 설정 하면 문서 배열을 반환하지 않고 RethinkDB가 일반적인 커서 API를 통해 드라이버에서 액세스 할 수있는 스트림을 반환합니다. 페이지 매김이 느리게 발생하기 때문에 이는 중요합니다. RethinkDB는 커서를 반복 할 때 API 호출 수를 최소화하기 위해 새 페이지를 요청합니다.</target>
        </trans-unit>
        <trans-unit id="910523961609d1635340d9fd8646a5044eb8223b" translate="yes" xml:space="preserve">
          <source>When you upgrade a major release (i.e., 2.1 to 2.2), you should rebuild outdated secondary indexes manually. This can be done easily from the command line:</source>
          <target state="translated">주 릴리스 (예 : 2.1에서 2.2)를 업그레이드 할 때는 오래된 보조 인덱스를 수동으로 다시 작성해야합니다. 이것은 명령 행에서 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e01352645abcc16780dde4407c35c5e8f103dc1c" translate="yes" xml:space="preserve">
          <source>Whenever possible, the client drivers use operator overloading to support expressions such as &lt;code&gt;user['age'] &amp;gt; 30&lt;/code&gt;.</source>
          <target state="translated">가능할 때마다 클라이언트 드라이버는 연산자 오버로드를 사용하여 &lt;code&gt;user['age'] &amp;gt; 30&lt;/code&gt; 과 같은 표현식을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="d9a1774318fd30b2eb43097c891e57357be23711" translate="yes" xml:space="preserve">
          <source>Whenever possible, you should use native ReQL commands rather than &lt;code&gt;r.js&lt;/code&gt; for better performance.</source>
          <target state="translated">가능하면 성능을 향상 &lt;code&gt;r.js&lt;/code&gt; 대신 기본 ReQL 명령을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d1a090ba50026546708baf541642a566aa524853" translate="yes" xml:space="preserve">
          <source>Where &amp;ldquo;newpass&amp;rdquo; is the new password you want to use.</source>
          <target state="translated">여기서 &quot;newpass&quot;는 사용하려는 새 비밀번호입니다.</target>
        </trans-unit>
        <trans-unit id="ecf978f6caa66726e06b1ef68ccd9f19f9ba5466" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;eq_join&lt;/code&gt; produces a table-like result (the rough equivalent of SQL&amp;rsquo;s &lt;code&gt;SELECT * FROM companies, employees WHERE companies.id = employees.company_id&lt;/code&gt;), using a subquery produces a nested document, where the employee objects are returned in a list in the &lt;code&gt;employees&lt;/code&gt; field.</source>
          <target state="translated">어디 &lt;code&gt;eq_join&lt;/code&gt; 는 테이블과 같은 결과 (SQL의의 거친 동등 생산 &lt;code&gt;SELECT * FROM companies, employees WHERE companies.id = employees.company_id&lt;/code&gt; , 하위 쿼리를 사용하여 중첩 된 문서를 생산), 직원 객체가의 목록에 반환되는 &lt;code&gt;employees&lt;/code&gt; 들.</target>
        </trans-unit>
        <trans-unit id="963cb49ae920f88d504d16b3b7083da4270506f8" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;t:1&lt;/code&gt; means that the response is a value, and &lt;code&gt;r: [&quot;foo&quot;]&lt;/code&gt; the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;t:1&lt;/code&gt; 은 응답이 값임을 의미하고 &lt;code&gt;r: [&quot;foo&quot;]&lt;/code&gt; 문자열 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ffd6f0444e5d149aef2022bdf6d34990e15630b1" translate="yes" xml:space="preserve">
          <source>Where&amp;rsquo;s &lt;code&gt;r.binary&lt;/code&gt;? You don&amp;rsquo;t need it in this case, because &lt;code&gt;r.http&lt;/code&gt; will return a binary object with the &lt;code&gt;{resultFormat:'binary'}&lt;/code&gt; option. (If the MIME type on the sending server is set correctly, you can even leave that off, and &lt;code&gt;r.http&lt;/code&gt; will figure out the correct type.)</source>
          <target state="translated">&lt;code&gt;r.binary&lt;/code&gt; 는 어디에 있습니까 ? &lt;code&gt;r.http&lt;/code&gt; 는 &lt;code&gt;{resultFormat:'binary'}&lt;/code&gt; 옵션을 사용 하여 이진 객체를 반환 하므로이 경우에는 필요하지 않습니다 . (전송 서버의 MIME 유형이 올바르게 설정되어 있으면이를 그대로 둘 수 있으며 &lt;code&gt;r.http&lt;/code&gt; 가 올바른 유형을 찾습니다 .)</target>
        </trans-unit>
        <trans-unit id="85ff01499d11ce21062a9b96027ab58ee226aad3" translate="yes" xml:space="preserve">
          <source>Where,</source>
          <target state="translated">Where,</target>
        </trans-unit>
        <trans-unit id="74ef3c384631337c470ed9830ea2e775e4e4fa26" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;concatMap&lt;/code&gt; with the same mapping function would merge those sequences into one:</source>
          <target state="translated">반면 &lt;code&gt;concatMap&lt;/code&gt; 하나에 그 시퀀스를 병합하는 것과 같은 매핑 기능 :</target>
        </trans-unit>
        <trans-unit id="7c3802c9a75c102c56d33838d3085aeced2d4be5" translate="yes" xml:space="preserve">
          <source>Which file systems are supported?</source>
          <target state="translated">어떤 파일 시스템이 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="c2d903bd400a10130121c28b48937e8649984629" translate="yes" xml:space="preserve">
          <source>Which versions of Node.js are supported?</source>
          <target state="translated">어떤 버전의 Node.js가 지원됩니까?</target>
        </trans-unit>
        <trans-unit id="75c7b24c0d75f53a78e5d965405062d03b3aa767" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;distinct&lt;/code&gt; can be called on a table without an index, the only effect will be to convert the table into a stream; the content of the stream will not be affected.</source>
          <target state="translated">인덱스없이 테이블에서 &lt;code&gt;distinct&lt;/code&gt; 를 호출 할 수 있지만 테이블을 스트림으로 변환하는 것이 유일한 효과입니다. 스트림의 내용은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eda1f1902e0534da8b4f0914078aa6c1b6b382f8" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;import&lt;/code&gt; has the ability to import a directory full of files, those files are expected to be in the format and directory structure created by the &lt;code&gt;export&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 에는 파일로 가득 찬 디렉토리를 가져 오는 기능이 있지만 해당 파일은 &lt;code&gt;export&lt;/code&gt; 명령으로 작성된 형식 및 디렉토리 구조에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e15bffa8e190edcd775e600e8f345fc990c8b319" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;outdated&lt;/code&gt; reads are faster, they are the least consistent. For more information on this option, read &amp;ldquo;Balancing safety and performance&amp;rdquo; in the &lt;a href=&quot;../consistency/index#balancing-safety-and-performance&quot;&gt;Consistency guarantees&lt;/a&gt; documentation.</source>
          <target state="translated">하지만 &lt;code&gt;outdated&lt;/code&gt; 되어 빠른 읽기, 그들은 적어도 일치한다. 이 옵션에 대한 자세한 내용은 &lt;a href=&quot;../consistency/index#balancing-safety-and-performance&quot;&gt;일관성 보증&lt;/a&gt; 설명서의 &quot;안전 및 성능 균형 조정&quot;을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cbe5b9c83c28270a91a6119308ebb3167601ae92" translate="yes" xml:space="preserve">
          <source>While RethinkDB doesn&amp;rsquo;t currently have a fully-featured query optimizer, ReQL is designed with one in mind. For example, the server has enough information to reorder the chain for efficiency, or to use alternative implementation plans to improve performance. This feature will be introduced into future versions of RethinkDB.</source>
          <target state="translated">RethinkDB에는 현재 완전한 기능을 갖춘 쿼리 최적화 프로그램이 없지만 ReQL은 하나를 염두에두고 설계되었습니다. 예를 들어, 서버에는 효율성을 위해 체인을 재정렬하거나 성능을 향상시키기 위해 대체 구현 계획을 사용할 수있는 충분한 정보가 있습니다. 이 기능은 향후 RethinkDB 버전에 도입 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="e87f1d7f7e013b05d15b906401df3c72981e5795" translate="yes" xml:space="preserve">
          <source>While it&amp;rsquo;s not strictly necessary to back up your data before upgrading, it&amp;rsquo;s always a good idea. You should make a backup by using the &lt;code&gt;dump&lt;/code&gt; command &lt;em&gt;before&lt;/em&gt; updating RethinkDB to its new version! Databases that have been automatically upgraded are not backward-compatible (that is, a database from version 1.14 cannot be used with version 1.13).</source>
          <target state="translated">업그레이드하기 전에 데이터를 반드시 백업 할 필요는 없지만 항상 좋은 방법입니다. RethinkDB를 새 버전으로 업데이트 &lt;em&gt;하기 전에 &lt;/em&gt; &lt;code&gt;dump&lt;/code&gt; 명령 을 사용하여 백업해야합니다 ! 자동으로 업그레이드 된 데이터베이스는 이전 버전과 호환되지 않습니다 (즉, 버전 1.14의 데이터베이스는 버전 1.13과 함께 사용할 수 없음).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c508518c472ea549e545c7cc3c1828474cbd1b66" translate="yes" xml:space="preserve">
          <source>While queries are built up on the client, they&amp;rsquo;re only sent to the server once you call the &lt;code&gt;run&lt;/code&gt; command. All processing happens on the server&amp;mdash;the queries don&amp;rsquo;t run on the client, and don&amp;rsquo;t require intermediary network round trips between the client and the server. For example, you can store queries in variables, and send them to the server later:</source>
          <target state="translated">쿼리는 클라이언트에 구축되지만 &lt;code&gt;run&lt;/code&gt; 명령 을 호출 한 후에 만 ​​서버로 전송됩니다 . 모든 처리는 서버에서 이루어집니다. 쿼리는 클라이언트에서 실행되지 않으며 클라이언트와 서버 간의 중간 네트워크 왕복이 필요하지 않습니다. 예를 들어, 쿼리를 변수에 저장하고 나중에 서버로 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c5b09514d00b6ab4c988fd2046f1b881599653b" translate="yes" xml:space="preserve">
          <source>While running, a server&amp;rsquo;s configuration can be changed by writing to the &lt;code&gt;rethinkdb.server_config&lt;/code&gt;&lt;a href=&quot;../system-tables/index&quot;&gt;system table&lt;/a&gt;.</source>
          <target state="translated">실행하는 동안 &lt;code&gt;rethinkdb.server_config&lt;/code&gt; &lt;a href=&quot;../system-tables/index&quot;&gt;시스템 테이블&lt;/a&gt; 에 기록하여 서버 구성을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="196bc69045bb039c922d7d34e6348aba06827f91" translate="yes" xml:space="preserve">
          <source>While system tables support changefeeds, they do not support all of the chaining that real tables do. For instance, aggregation (&lt;code&gt;max&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt;) and &lt;code&gt;limit&lt;/code&gt; commands will not work with system tables.</source>
          <target state="translated">시스템 테이블은 변경 피드를 지원하지만 실제 테이블이 수행하는 모든 체인을 지원하지는 않습니다. 예를 들어, 집계 ( &lt;code&gt;max&lt;/code&gt; 및 &lt;code&gt;min&lt;/code&gt; ) 및 &lt;code&gt;limit&lt;/code&gt; 명령은 시스템 테이블에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e1db1780061897d624e2492fa72c8d8a9c49dd8" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;{field:value}&lt;/code&gt; style of predicate is useful for exact matches, a more general way to write a predicate is to use the &lt;a href=&quot;../row/index&quot;&gt;row&lt;/a&gt; command with a comparison operator such as &lt;a href=&quot;../eq/index&quot;&gt;eq&lt;/a&gt; or &lt;a href=&quot;../gt/index&quot;&gt;gt&lt;/a&gt;, or to use an anonymous function that returns &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">그동안 &lt;code&gt;{field:value}&lt;/code&gt; 술어의 스타일이 정확히 일치에 유용, 술어를 작성하는 일반적인 방법은 사용하는 것입니다 &lt;a href=&quot;../row/index&quot;&gt;행&lt;/a&gt; 과 같은 비교 연산자와 명령을 &lt;a href=&quot;../eq/index&quot;&gt;EQ&lt;/a&gt; 나 &lt;a href=&quot;../gt/index&quot;&gt;있다&lt;/a&gt; , 또는 익명 함수를 사용하여 그 반환 &lt;code&gt;true&lt;/code&gt; 이나 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb232e8e16f07d7f64a5545b6cc6855a0b706386" translate="yes" xml:space="preserve">
          <source>While there &lt;em&gt;is&lt;/em&gt; a [circle] command, it approximates a circle by defining either a line or a polygon. There is no true circular data type.</source>
          <target state="translated">[circle] 명령 &lt;em&gt;이&lt;/em&gt; 있는 동안 선이나 다각형을 정의하여 원을 근사화합니다. 실제 순환 데이터 유형이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8880d3ba6f9209b576363cabe9ca016a317fd7a2" translate="yes" xml:space="preserve">
          <source>While we strive to give you perfect uptime, like other complex applications RethinkDB is not immune to crashing. Here are some tips on how to recover from a crash, how to submit a bug report, and how to maximize availability.</source>
          <target state="translated">다른 복잡한 응용 프로그램과 마찬가지로 완벽한 가동 시간을 제공하기 위해 노력하지만 RethinkDB는 충돌에 영향을받지 않습니다. 다음은 충돌로부터 복구하는 방법, 버그 보고서를 제출하는 방법 및 가용성을 최대화하는 방법에 대한 팁입니다.</target>
        </trans-unit>
        <trans-unit id="a9c9f8d79908203bf616bc5ec24c72cd56e7ec7f" translate="yes" xml:space="preserve">
          <source>While you may be able to leave many options at their defaults, you&amp;rsquo;ll definitely need to change the &lt;code&gt;directory=&lt;/code&gt; line in the configuration file to point to your RethinkDB data directory.</source>
          <target state="translated">많은 옵션을 기본값으로 남겨 둘 수 있지만 RethinkDB 데이터 디렉토리를 가리 키도록 구성 파일에서 &lt;code&gt;directory=&lt;/code&gt; 행 을 변경해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d70b857aa26bf55f4755a8a354b5a0cf782812e2" translate="yes" xml:space="preserve">
          <source>Whitespace-separated JSON rows.</source>
          <target state="translated">공백으로 구분 된 JSON 행</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="d110c7983aa12b9b68c9e762bd72396013153dbb" translate="yes" xml:space="preserve">
          <source>With &lt;strong&gt;one&lt;/strong&gt; argument &lt;em&gt;x,&lt;/em&gt; the result will be in the range &lt;code&gt;[0,x)&lt;/code&gt;, and will be integer unless &lt;code&gt;{float:true}&lt;/code&gt; is given as an option. Specifying a floating point number without the &lt;code&gt;float&lt;/code&gt; option will raise an error.</source>
          <target state="translated">으로 &lt;strong&gt;한&lt;/strong&gt; 인자 &lt;em&gt;X,&lt;/em&gt; 결과는 범위에있을 것이다 &lt;code&gt;[0,x)&lt;/code&gt; 및 정수 않는 것 &lt;code&gt;{float:true}&lt;/code&gt; 옵션으로 주어진다. &lt;code&gt;float&lt;/code&gt; 옵션 없이 부동 소수점 숫자를 지정 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b7043f8490538934638889f8014fabd627f4ae9b" translate="yes" xml:space="preserve">
          <source>With &lt;strong&gt;two&lt;/strong&gt; arguments &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y,&lt;/em&gt; the result will be in the range &lt;code&gt;[x,y)&lt;/code&gt;, and will be integer unless &lt;code&gt;{float:true}&lt;/code&gt; is given as an option. If &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; are equal an error will occur, unless the floating-point option has been specified, in which case &lt;em&gt;x&lt;/em&gt; will be returned. Specifying a floating point number without the &lt;code&gt;float&lt;/code&gt; option will raise an error.</source>
          <target state="translated">함께 &lt;strong&gt;두&lt;/strong&gt; 인자 &lt;em&gt;X&lt;/em&gt; 와 &lt;em&gt;Y,&lt;/em&gt; 결과는 범위에있을 것이다 &lt;code&gt;[x,y)&lt;/code&gt; 및 정수 않는 것 &lt;code&gt;{float:true}&lt;/code&gt; 옵션으로 주어진다. 경우 &lt;em&gt;X&lt;/em&gt; 및 &lt;em&gt;Y가&lt;/em&gt; 되는 부동 소수점 옵션이있는 경우, 지정되어 있지 않은 경우 에러가 발생 동일 &lt;em&gt;X가&lt;/em&gt; 반환된다. &lt;code&gt;float&lt;/code&gt; 옵션 없이 부동 소수점 숫자를 지정 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ed3cfa588bab7867e4924f429e5db144b0535192" translate="yes" xml:space="preserve">
          <source>With &lt;strong&gt;zero&lt;/strong&gt; arguments, the result will be a floating-point number in the range &lt;code&gt;[0,1)&lt;/code&gt; (from 0 up to but not including 1).</source>
          <target state="translated">함께 &lt;strong&gt;제로&lt;/strong&gt; 인수 결과는 부동 소수점 범위 여야한다 &lt;code&gt;[0,1)&lt;/code&gt; 0 내지 최대 (단 1)를 포함하지 않음.</target>
        </trans-unit>
        <trans-unit id="3e699cf78c6c70afc59571e065ee6662df7ae4ed" translate="yes" xml:space="preserve">
          <source>With a single server, our query takes 59 seconds to complete. The automatic query parallelization in RethinkDB results in practically linear scalability, as the same query is executed in just above 4 seconds on 16 servers. The graph, shown in the results overview section, demonstrates the inverse execution time (queries per second) of the query.</source>
          <target state="translated">단일 서버의 경우 쿼리를 완료하는 데 59 초가 걸립니다. RethinkDB의 자동 쿼리 병렬화는 동일한 쿼리가 16 개의 서버에서 4 초 이상 실행되므로 실질적으로 선형적인 확장 성을 제공합니다. 결과 개요 섹션에 표시된 그래프는 쿼리의 역 실행 시간 (초당 쿼리)을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d8a5b7f3faeb9e33f62bb627c2b2a563e64920b5" translate="yes" xml:space="preserve">
          <source>With a string, &lt;code&gt;slice&lt;/code&gt; behaves similarly, with the indexes referring to Unicode codepoints. String indexes start at &lt;code&gt;0&lt;/code&gt;. (Note that &lt;a href=&quot;https://en.wikipedia.org/wiki/Combining_character&quot;&gt;combining codepoints&lt;/a&gt; are counted separately.)</source>
          <target state="translated">문자열을 사용하면 &lt;code&gt;slice&lt;/code&gt; 가 비슷하게 작동하며 인덱스는 유니 코드 코드 포인트를 나타냅니다. 문자열 인덱스는 &lt;code&gt;0&lt;/code&gt; 에서 시작 합니다. ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Combining_character&quot;&gt;코드 포인트 결합&lt;/a&gt; 은 별도로 계산됩니다.)</target>
        </trans-unit>
        <trans-unit id="f4fd536709cd6838a47751145de8bc8d075d4ebd" translate="yes" xml:space="preserve">
          <source>With most commands that take a field name string or the &lt;code&gt;() &lt;/code&gt; syntax above, you can also use a JSON-style nested syntax:</source>
          <target state="translated">필드 이름 문자열 또는 위 의 &lt;code&gt;() &lt;/code&gt; 구문을 사용하는 대부분의 명령 에서 JSON 스타일 중첩 구문을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f765a154bf9b7d7db33d2b68b71884f46493323f" translate="yes" xml:space="preserve">
          <source>With no arguments, &lt;code&gt;range&lt;/code&gt; returns an &amp;ldquo;infinite&amp;rdquo; stream from 0 up to and including the maximum integer value;</source>
          <target state="translated">인수가 없으면 &lt;code&gt;range&lt;/code&gt; 는 0에서 최대 정수 값을 포함하여 &quot;무한&quot;스트림을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1be6d08d4038949893064ebde481b01100a94fa1" translate="yes" xml:space="preserve">
          <source>With one argument, &lt;code&gt;range&lt;/code&gt; returns a stream from 0 up to but not including the end value;</source>
          <target state="translated">인수가 하나 인 경우 &lt;code&gt;range&lt;/code&gt; 는 0에서 끝 값을 포함하지 않는 스트림을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e28fd958eebbcb33351a1302bb1eea36388fb720" translate="yes" xml:space="preserve">
          <source>With simple and compound indexes, a document will be indexed using at most one index key: a single value for a simple index and a set of values for a compound index. Multiple documents may have the same index key. With a &lt;em&gt;multi index&lt;/em&gt;, a document can be indexed using more than one key in the same index. For instance, a blog post might have multiple tags, and each tag might refer to multiple blog posts.</source>
          <target state="translated">단순 인덱스와 복합 인덱스를 사용하면 단순 인덱스의 단일 값과 복합 인덱스의 값 집합 중 하나 이상을 사용하여 문서가 인덱스됩니다. 여러 문서가 동일한 색인 키를 가질 수 있습니다. A의 &lt;em&gt;멀티 인덱스&lt;/em&gt; , 문서는 동일한 인덱스의 하나 이상의 키를 이용하여 색인화 될 수있다. 예를 들어 블로그 게시물에는 여러 개의 태그가있을 수 있으며 각 태그는 여러 블로그 게시물을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="561955fb8ca5f5782474961bc600ce7a0b051525" translate="yes" xml:space="preserve">
          <source>With system tables only, the &lt;code&gt;table&lt;/code&gt; command takes a new argument, &lt;code&gt;identifier_format&lt;/code&gt;. Legal values are &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;uuid&lt;/code&gt;. When it&amp;rsquo;s set to &lt;code&gt;uuid&lt;/code&gt;, references in system tables to databases or other tables will be UUIDs rather than database/table names. This is useful for writing scripts and administration tasks, as UUIDs remain consistent even if object names change. The default is &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">시스템 테이블에서만 &lt;code&gt;table&lt;/code&gt; 명령은 &lt;code&gt;identifier_format&lt;/code&gt; 이라는 새 인수를 사용 합니다 . 유효한 값은 &lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;uuid&lt;/code&gt; 입니다. &lt;code&gt;uuid&lt;/code&gt; 로 설정되면 시스템 테이블에서 데이터베이스 또는 다른 테이블에 대한 참조는 데이터베이스 / 테이블 이름이 아닌 UUID입니다. 개체 이름이 변경 되더라도 UUID가 일관되게 유지되므로 스크립트 및 관리 작업을 작성하는 데 유용합니다. 기본값은 &lt;code&gt;name&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8ecebde599b9bd6e7b61ea5841eb82f0b8ce413a" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;multi&lt;/code&gt; flag single documents can be assigned to multiple groups, similar to the behavior of &lt;a href=&quot;../../../docs/secondary-indexes/javascript/index&quot;&gt;multi-indexes&lt;/a&gt;. When &lt;code&gt;multi&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and the grouping value is an array, documents will be placed in each group that corresponds to the elements of the array. If the array is empty the row will be ignored.</source>
          <target state="translated">&lt;code&gt;multi&lt;/code&gt; 플래그를 사용하면 다중 &lt;a href=&quot;../../../docs/secondary-indexes/javascript/index&quot;&gt;색인&lt;/a&gt; 의 동작과 유사한 단일 문서를 여러 그룹에 지정할 수 있습니다 . 경우 &lt;code&gt;multi&lt;/code&gt; 인 &lt;code&gt;true&lt;/code&gt; 과 그룹핑 값이 배열이며, 각 문서 그룹에 배치되도록, 배열의 요소에 대응한다. 배열이 비어 있으면 행이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c1c2a4ec9b5fe6dd2c2a1f09763272a5046fc80b" translate="yes" xml:space="preserve">
          <source>With the appropriate &lt;a href=&quot;../install-drivers/index&quot;&gt;client driver&lt;/a&gt; installed you can use a supported language to perform all administration tasks, either from the language&amp;rsquo;s REPL or as a script. There are ReQL commands for &lt;a href=&quot;https://rethinkdb.com/api/python/reconfigure&quot;&gt;configuring sharding and replication&lt;/a&gt;, &lt;a href=&quot;https://rethinkdb.com/api/python/rebalance&quot;&gt;rebalancing shards&lt;/a&gt; and more. In addition, you can query &lt;a href=&quot;../system-tables/index&quot;&gt;system tables&lt;/a&gt; to get information about your cluster and to change many of its operational characteristics.</source>
          <target state="translated">적절한 &lt;a href=&quot;../install-drivers/index&quot;&gt;클라이언트 드라이버가&lt;/a&gt; 설치되어 있으면 지원되는 언어를 사용하여 언어의 REPL 또는 스크립트로 모든 관리 작업을 수행 할 수 있습니다. &lt;a href=&quot;https://rethinkdb.com/api/python/reconfigure&quot;&gt;샤딩 및 복제 구성&lt;/a&gt; , &lt;a href=&quot;https://rethinkdb.com/api/python/rebalance&quot;&gt;샤드 재조정 &lt;/a&gt;등을 위한 ReQL 명령이 있습니다 . 또한 &lt;a href=&quot;../system-tables/index&quot;&gt;시스템 테이블&lt;/a&gt; 을 쿼리 하여 클러스터에 대한 정보를 얻고 많은 운영 특성을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88ce626689bbb3d87a8121372f5b3f4b42db58eb" translate="yes" xml:space="preserve">
          <source>With the following settings, RethinkDB guarantees linearizability of individual atomic operations on individual documents:</source>
          <target state="translated">다음 설정을 통해 RethinkDB는 개별 문서에서 개별 원자 작업의 선형성을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="f2d4c9e7aabba038136ff518e49156fb80b1960b" translate="yes" xml:space="preserve">
          <source>With this approach you cannot atomically update both the author data and and the posts data.</source>
          <target state="translated">이 방법을 사용하면 작성자 데이터와 게시물 데이터를 모두 원자 적으로 업데이트 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c9c5da5a74f1e53423101b6b6a642e055eee3483" translate="yes" xml:space="preserve">
          <source>With two arguments, &lt;code&gt;range&lt;/code&gt; returns a stream from the start value up to but not including the end value.</source>
          <target state="translated">두 개의 인수를 사용하면 &lt;code&gt;range&lt;/code&gt; 는 시작 값에서 종료 값을 포함하지 않는 스트림을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="706a9fb9c60fd738be99224175848f1837d058a5" translate="yes" xml:space="preserve">
          <source>With version &lt;code&gt;V1_0&lt;/code&gt; of the protocol, the handshake protocol has changed from previous versions.</source>
          <target state="translated">프로토콜 버전 &lt;code&gt;V1_0&lt;/code&gt; 에서는 핸드 셰이크 프로토콜이 이전 버전에서 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="03c726aadd8ac092e0447f9f7e0fbd7bbf6e227c" translate="yes" xml:space="preserve">
          <source>Working with streams</source>
          <target state="translated">스트림 작업</target>
        </trans-unit>
        <trans-unit id="c081f805ae12217f57b46b44e966da71b81ef959" translate="yes" xml:space="preserve">
          <source>Working with times</source>
          <target state="translated">시간 작업</target>
        </trans-unit>
        <trans-unit id="369a3cda46aff60d2423048907eef67959000caa" translate="yes" xml:space="preserve">
          <source>Workload A</source>
          <target state="translated">작업량 A</target>
        </trans-unit>
        <trans-unit id="3ff249cc11740bb6ad8b6e01ed11cfa8c3c78f8f" translate="yes" xml:space="preserve">
          <source>Workload C</source>
          <target state="translated">작업량 C</target>
        </trans-unit>
        <trans-unit id="f39dd82bdd5c2b2b0591a73c0a966f99123a4a07" translate="yes" xml:space="preserve">
          <source>Would be sent to the server as</source>
          <target state="translated">서버로 전송됩니다</target>
        </trans-unit>
        <trans-unit id="89dc61bcc6d6ce0ce9d24febb8af7ea389f5b539" translate="yes" xml:space="preserve">
          <source>Wrapping queries</source>
          <target state="translated">줄 바꿈 쿼리</target>
        </trans-unit>
        <trans-unit id="659ca7d443e63ce2949dec486536ee88fa72c4d0" translate="yes" xml:space="preserve">
          <source>Wrapping the DB query option</source>
          <target state="translated">DB 쿼리 옵션 래핑</target>
        </trans-unit>
        <trans-unit id="dbedb4dc90f07d001648d9502697a610b881d451" translate="yes" xml:space="preserve">
          <source>Write acks and durability</source>
          <target state="translated">쓰기 acks와 내구성</target>
        </trans-unit>
        <trans-unit id="5e6eaa2c1185928e8b28fb617129c097ed9398c9" translate="yes" xml:space="preserve">
          <source>Write atomicity is supported on a per-document basis &amp;ndash; updates to a single JSON document are guaranteed to be atomic. RethinkDB is different from other NoSQL systems in that atomic document updates aren&amp;rsquo;t limited to a small subset of possible operations &amp;ndash; any combination of operations that can be performed on a single document is guaranteed to update the document atomically. For example, the user may wish to update the value of attribute A to a sum of the values of attributes B and C, increment the value of attribute D by a fixed number, and append an element to an array in attribute E. All of these operations can be applied to the document atomically in a single update operation.</source>
          <target state="translated">쓰기 원자 성은 문서별로 지원됩니다. 단일 JSON 문서에 대한 업데이트는 원 자성입니다. RethinkDB는 원자 문서 업데이트가 가능한 작은 작업 하위 집합으로 제한되지 않는다는 점에서 다른 NoSQL 시스템과 다릅니다. 단일 문서에서 수행 할 수있는 모든 작업 조합은 문서를 원자 적으로 업데이트합니다. 예를 들어, 사용자는 속성 A의 값을 속성 B 및 C의 값의 합으로 업데이트하고, 속성 D의 값을 고정 된 수만큼 증가시키고, 속성 E의 배열에 요소를 추가하고자 할 수있다. 이러한 작업은 단일 업데이트 작업으로 문서에 원자 적으로 적용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f62115f9f3535c8b07d79df0f9f18ccafd554421" translate="yes" xml:space="preserve">
          <source>Write operations on system tables are non-atomic. Avoid writing to the same system table row from more than one client at the same time.</source>
          <target state="translated">시스템 테이블에 대한 쓰기 작업은 비원 자적입니다. 동시에 둘 이상의 클라이언트에서 동일한 시스템 테이블 행에 쓰지 마십시오.</target>
        </trans-unit>
        <trans-unit id="778b0b2b0319607e4822502fbb728b660dd8744d" translate="yes" xml:space="preserve">
          <source>Writes are performed with &amp;ldquo;hard&amp;rdquo; durability (wait for data to be on disk on both replicas)</source>
          <target state="translated">쓰기는 &quot;하드&quot;내구성으로 수행됩니다 (데이터가 두 복제본의 디스크에있을 때까지 기다리십시오)</target>
        </trans-unit>
        <trans-unit id="9e632869f49afb8aba3986c578bc41023c0edd69" translate="yes" xml:space="preserve">
          <source>Writing Data</source>
          <target state="translated">데이터 쓰기</target>
        </trans-unit>
        <trans-unit id="8a414f19d977be639835849a95f5232ef94bac3b" translate="yes" xml:space="preserve">
          <source>Writing RethinkDB drivers</source>
          <target state="translated">RethinkDB 드라이버 작성</target>
        </trans-unit>
        <trans-unit id="3f85d90f8a8e1dd726894cac4b4961c2ef2bc396" translate="yes" xml:space="preserve">
          <source>Writing data</source>
          <target state="translated">데이터 쓰기</target>
        </trans-unit>
        <trans-unit id="0592df9e765a33e009a61a0f043994284838f69d" translate="yes" xml:space="preserve">
          <source>Writing drivers</source>
          <target state="translated">드라이버 작성</target>
        </trans-unit>
        <trans-unit id="c61bb79a2505d2a4aa2a95f6ce80e265d54461a3" translate="yes" xml:space="preserve">
          <source>YCSB comes with a variety of default workloads, but for the purposes of our testing we chose two of them to run against RethinkDB. Out of the YCSB workload options, we chose to run workload A which comprises 50% reads and 50% update operations, and workload C which performs strictly read operations. All documents stored by the YCSB tests contain 10 fields with randomized 100 byte strings as values, with each document totaling about 1 KB in size.</source>
          <target state="translated">YCSB에는 다양한 기본 워크로드가 제공되지만 테스트를 위해 RethinkDB에 대해 실행할 두 가지를 선택했습니다. YCSB 워크로드 옵션 중에서 50 % 읽기 및 50 % 업데이트 작업으로 구성된 워크로드 A와 엄격하게 읽기 작업을 수행하는 워크로드 C를 실행하기로 선택했습니다. YCSB 테스트에 의해 저장된 모든 문서에는 100 바이트의 무작위 문자열이 값으로 10 개의 필드가 있으며 각 문서의 크기는 약 1KB입니다.</target>
        </trans-unit>
        <trans-unit id="3eb210c778a79793e9d78d22c3f1ede24830d9f8" translate="yes" xml:space="preserve">
          <source>Yes. Distance calculations are done on a geodesic (either WGS84&amp;rsquo;s reference ellipsoid or a unit sphere).</source>
          <target state="translated">예. 거리 계산은 측지선 (WGS84의 기준 타원체 또는 단위 구)에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7c3e24fef8be8e5708c75420ec10f7858a6a4a38" translate="yes" xml:space="preserve">
          <source>You can &lt;a href=&quot;../../api/javascript/update/index&quot;&gt;update&lt;/a&gt; the password to a new value, or remove it by setting it to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">비밀번호를 새 값으로 &lt;a href=&quot;../../api/javascript/update/index&quot;&gt;업데이트&lt;/a&gt; 하거나 &lt;code&gt;false&lt;/code&gt; 로 설정하여 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="948b7ad33f6106e0c518960b93f129c834918f85" translate="yes" xml:space="preserve">
          <source>You can accomplish this with &lt;code&gt;object&lt;/code&gt; and a pivot.</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 와 피벗 으로이 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="925356081da49bb85c51c3cfc060b861749e8f91" translate="yes" xml:space="preserve">
          <source>You can add or subtract a duration (in seconds):</source>
          <target state="translated">지속 시간 (초)을 더하거나 뺄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4533fcb6c96cfc2d8d905dbd40d93091a926daf0" translate="yes" xml:space="preserve">
          <source>You can also chain &lt;code&gt;changes&lt;/code&gt; before any command that operates on a sequence of documents, as long as that command doesn&amp;rsquo;t consume the entire sequence. (For instance, &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;orderBy&lt;/code&gt; cannot come after the &lt;code&gt;changes&lt;/code&gt; command.)</source>
          <target state="translated">해당 명령이 전체 시퀀스를 사용하지 않는 한 일련의 문서에서 작동하는 명령 전에 &lt;code&gt;changes&lt;/code&gt; 연결할 수도 있습니다 . 예를 들어, &lt;code&gt;count&lt;/code&gt; 및 &lt;code&gt;orderBy&lt;/code&gt; 는 &lt;code&gt;changes&lt;/code&gt; 명령 뒤에 올 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="aa193e7db24ef17527767c2a2fb1bc7e212cf120" translate="yes" xml:space="preserve">
          <source>You can also choose to receive errors in the block by accepting two arguments.</source>
          <target state="translated">두 개의 인수를 허용하여 블록에서 오류를 수신하도록 선택할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7521a0e1d0a48d0648af79a67343e53203f19dc3" translate="yes" xml:space="preserve">
          <source>You can also combine soft durability and &lt;code&gt;noreply&lt;/code&gt; for the highest performance:</source>
          <target state="translated">최고 성능을 위해 부드러운 내구성과 &lt;code&gt;noreply&lt;/code&gt; 을 결합 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7bee9dd40ed9b84d531cd93a05bc744d1be6b9b" translate="yes" xml:space="preserve">
          <source>You can also filter messages by tags. We could put the tags into a string and build a regex to match messages with the tags we want, but luckily we have the full power of ReQL at our disposal. Instead, we can make the topic an actual JSON array, and use ReQL&amp;rsquo;s &lt;a href=&quot;../../../api/javascript/contains/index&quot;&gt;contains&lt;/a&gt; method to do the filtering.</source>
          <target state="translated">태그별로 메시지를 필터링 할 수도 있습니다. 태그를 문자열에 넣고 원하는 태그와 메시지를 일치시키는 정규식을 작성할 수 있지만 다행히도 ReQL의 모든 기능을 사용할 수 있습니다. 대신, 주제를 실제 JSON 배열로 만들고 ReQL의 &lt;a href=&quot;../../../api/javascript/contains/index&quot;&gt;contains&lt;/a&gt; 메소드를 사용 하여 필터링을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55f7bbe803221ed2cce75841fcc9fc9bd55f8f78" translate="yes" xml:space="preserve">
          <source>You can also group by a function.</source>
          <target state="translated">기능별로 그룹화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f7329e3cb33fdb6c2fd3c98bf353c3c9bcd0191" translate="yes" xml:space="preserve">
          <source>You can also group by more than one field.</source>
          <target state="translated">둘 이상의 필드를 기준으로 그룹화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a60b122be5d58582613cfb6b6776eff696b1b764" translate="yes" xml:space="preserve">
          <source>You can also group on an index (primary key or secondary).</source>
          <target state="translated">인덱스 (기본 키 또는 보조)로 그룹화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6654958bc49bc05258fa3acec5130cab590a8a51" translate="yes" xml:space="preserve">
          <source>You can also manually compare dates:</source>
          <target state="translated">날짜를 수동으로 비교할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ec8c02dd35711b36397abb1da1ac1fa12d559ed" translate="yes" xml:space="preserve">
          <source>You can also perform this query using the &lt;a href=&quot;https://rethinkdb.com/api/python/inner_join/&quot;&gt;inner_join&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;https://rethinkdb.com/api/python/inner_join/&quot;&gt;inner_join&lt;/a&gt; 명령을 사용하여이 쿼리를 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a74279a58953a26e9ef411c14ba12ac3c17b2d47" translate="yes" xml:space="preserve">
          <source>You can also point the client drivers to &lt;code&gt;localhost:28015&lt;/code&gt; or &lt;code&gt;localhost:28016&lt;/code&gt; to start running queries (it doesn&amp;rsquo;t matter which node you use&amp;mdash;the cluster will automatically route all commands to appropriate nodes).</source>
          <target state="translated">또한 클라이언트 드라이버가 &lt;code&gt;localhost:28015&lt;/code&gt; 또는 &lt;code&gt;localhost:28016&lt;/code&gt; 을 가리 키도록하여 쿼리 실행을 시작할 수 있습니다 (어떤 노드를 사용하든 상관 없습니다. 클러스터는 모든 명령을 적절한 노드로 자동 라우팅합니다).</target>
        </trans-unit>
        <trans-unit id="e44ac32db1d54d18e34eb6ab558c9e482d15daa2" translate="yes" xml:space="preserve">
          <source>You can also select a descending ordering:</source>
          <target state="translated">내림차순을 선택할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8fc5957165ff64f88a05853da874a06bd5d3701" translate="yes" xml:space="preserve">
          <source>You can also specify explicitly which index and type you want synced documents to go to:</source>
          <target state="translated">동기화 된 문서로 이동할 인덱스 및 유형을 명시 적으로 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="80eac1c2d72fc26d947819c83575a858603c9378" translate="yes" xml:space="preserve">
          <source>You can also transform a time object on the server using either &lt;code&gt;toEpochTime&lt;/code&gt; or &lt;code&gt;toISO8601&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;toEpochTime&lt;/code&gt; 또는 &lt;code&gt;toISO8601&lt;/code&gt; 을 사용하여 서버에서 시간 객체를 변환 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cac8d8320c3579227fb8c5d1475782eef117e2c2" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;r.now&lt;/code&gt; (which the server interprets as the time the query was received in UTC), or construct a time using &lt;code&gt;r.time&lt;/code&gt;, &lt;code&gt;r.epochTime&lt;/code&gt;, or &lt;code&gt;r.ISO8601&lt;/code&gt;.</source>
          <target state="translated">당신은 또한 사용할 수 있습니다 &lt;code&gt;r.now&lt;/code&gt; (이 쿼리가 UTC에서 수신 된 시간으로 서버 해석)를 사용하여 시간, 구성 &lt;code&gt;r.time&lt;/code&gt; , &lt;code&gt;r.epochTime&lt;/code&gt; , 또는 &lt;code&gt;r.ISO8601&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="cb2bd319a45cdc6fba892eaab1939a5068f518fa" translate="yes" xml:space="preserve">
          <source>You can also use RethinkDB to query many to many relations. Let&amp;rsquo;s suppose we have a collaborative blogging platform where authors collaborate to create posts (multiple authors can work on any given post, and publish multiple posts).</source>
          <target state="translated">RethinkDB를 사용하여 다 대다 관계를 쿼리 할 수도 있습니다. 작성자가 공동 작업하여 게시물을 작성하는 협업 블로그 플랫폼이 있다고 가정합니다 (여러 작성자가 특정 게시물에 대해 작업하고 여러 게시물을 게시 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="260bde3e879639056344b2578c9acb496c3e9dfd" translate="yes" xml:space="preserve">
          <source>You can also use more complicated expressions. Let&amp;rsquo;s say you have a table &lt;code&gt;scores&lt;/code&gt; that contains the latest game score for every user of your game. You can create a feed of all games where a user beats their previous score, and get only the new value:</source>
          <target state="translated">더 복잡한 표현을 사용할 수도 있습니다. 게임의 모든 사용자에 대한 최신 게임 &lt;code&gt;scores&lt;/code&gt; 가 포함 된 테이블 점수 가 있다고 가정 합니다. 사용자가 이전 점수를이기는 모든 게임의 피드를 생성하고 새로운 값만 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d752132db71ae1e37214a4686c56d81c5eaeefd" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;../limit/index&quot;&gt;limit&lt;/a&gt; command with the no-argument variant to achieve the same result in this case:</source>
          <target state="translated">인수가없는 변형과 함께 &lt;a href=&quot;../limit/index&quot;&gt;limit&lt;/a&gt; 명령을 사용 하여이 경우에도 동일한 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68b26d9038bb64d58ff064aaaf43b40e2b7dd37d" translate="yes" xml:space="preserve">
          <source>You can also use the prefix notation (passing all arguments to &lt;code&gt;r.and&lt;/code&gt;), if that&amp;rsquo;s what you prefer:</source>
          <target state="translated">원하는 경우 접두사 표기법 (모든 인수를 &lt;code&gt;r.and&lt;/code&gt; 로 전달)을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98524810990f6ce3791d22ab50b4d44cc51b4729" translate="yes" xml:space="preserve">
          <source>You can also use this approach with a &lt;a href=&quot;../../secondary-indexes/javascript/index&quot;&gt;compound index&lt;/a&gt; on the intervals you want to group:</source>
          <target state="translated">그룹화하려는 간격에 대한 &lt;a href=&quot;../../secondary-indexes/javascript/index&quot;&gt;복합 인덱스&lt;/a&gt; 와 함께이 방법을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e210d90ddec99211d2b1d62f90c31cc57cbc7fa" translate="yes" xml:space="preserve">
          <source>You can ask questions and get notes on changes introduced in new versions of RethinkDB on the &lt;a href=&quot;https://groups.google.com/forum/?fromgroups#!forum/rethinkdb-dev&quot;&gt;RethinkDB-Dev Google Group&lt;/a&gt;. You can also visit the &lt;a href=&quot;irc://irc.freenode.org/rethinkdb&quot;&gt;RethinkDB IRC Channel&lt;/a&gt;, where core developers and other driver developers frequently hang out. Also, you can ask questions on &lt;a href=&quot;http://stackoverflow.com/&quot;&gt;Stack Overflow&lt;/a&gt; using the tag &amp;ldquo;&lt;a href=&quot;http://stackoverflow.com/questions/tagged/rethinkdb&quot;&gt;rethinkdb&lt;/a&gt;.&amp;rdquo;</source>
          <target state="translated">&lt;a href=&quot;https://groups.google.com/forum/?fromgroups#!forum/rethinkdb-dev&quot;&gt;RethinkDB-Dev Google 그룹&lt;/a&gt; 에서 새 버전의 RethinkDB에 도입 된 변경 사항에 대한 질문을하고 메모를받을 수 있습니다 . 핵심 개발자 및 기타 드라이버 개발자가 자주 &lt;a href=&quot;irc://irc.freenode.org/rethinkdb&quot;&gt;만나는 RethinkDB IRC 채널을&lt;/a&gt; 방문 할 수도 있습니다 . 또한 &quot; &lt;a href=&quot;http://stackoverflow.com/questions/tagged/rethinkdb&quot;&gt;rethinkdb&lt;/a&gt; &quot; 태그를 사용하여 &lt;a href=&quot;http://stackoverflow.com/&quot;&gt;Stack Overflow에&lt;/a&gt; 대한 질문을 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab33dc48c02612349a04e9a9040eefd1db934e27" translate="yes" xml:space="preserve">
          <source>You can chain as many ReQL commands as necessary to perform data manipulation tasks. Since ReQL is explicitly designed for JSON querying and modification, it&amp;rsquo;s also an excellent language for operating on web services!</source>
          <target state="translated">데이터 조작 태스크를 수행하는 데 필요한만큼 ReQL 명령을 연결할 수 있습니다. ReQL은 JSON 쿼리 및 수정을 위해 명시 적으로 설계되었으므로 웹 서비스 운영을위한 훌륭한 언어이기도합니다!</target>
        </trans-unit>
        <trans-unit id="1d30f31519b2594ea55d30183732bc6402bd588e" translate="yes" xml:space="preserve">
          <source>You can combine multiple ReQL queries to build more complex ones.</source>
          <target state="translated">여러 ReQL 쿼리를 결합하여 더 복잡한 쿼리를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cec52bedaeaa6b1b669dabc56c482be17d6581c" translate="yes" xml:space="preserve">
          <source>You can compute the average value of a field with the &lt;code&gt;avg&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;avg&lt;/code&gt; 명령 을 사용하여 필드의 평균값을 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70626bab7a8c982a8c2b47eb0111e64d0d9ee6a0" translate="yes" xml:space="preserve">
          <source>You can connect to your hosted cluster on Compose in one of two ways: via SSL or via SSH tunneling. With SSL, you can get a direct Admin URL and driver connection URL to your RethinkDB instance. SSL driver connections are only supported with the official RethinkDB drivers and the community-supported Go driver. For more details, read Compose&amp;rsquo;s &lt;a href=&quot;https://www.compose.io/articles/rethinkdb-and-ssl-think-secure/&quot;&gt;RethinkDB and SSL&lt;/a&gt; blog post.</source>
          <target state="translated">SSL 또는 SSH 터널링을 통해 Compose에서 호스트 클러스터에 연결할 수 있습니다. SSL을 사용하면 RethinkDB 인스턴스에 대한 직접 관리 URL 및 드라이버 연결 URL을 얻을 수 있습니다. SSL 드라이버 연결은 공식 RethinkDB 드라이버 및 커뮤니티 지원 Go 드라이버에서만 지원됩니다. 자세한 내용은 Compose의 &lt;a href=&quot;https://www.compose.io/articles/rethinkdb-and-ssl-think-secure/&quot;&gt;RethinkDB 및 SSL&lt;/a&gt; 블로그 게시물을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="07b08edef601b139269d80f58b49bf6d38d77cbe" translate="yes" xml:space="preserve">
          <source>You can construct queries incrementally by chaining transformations and examining intermediary results.</source>
          <target state="translated">변환을 연결하고 중간 결과를 검사하여 점진적으로 쿼리를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0d2d2ae12e1b289f792fb7810556ffc10df36f3" translate="yes" xml:space="preserve">
          <source>You can count the number of documents with a &lt;code&gt;count&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 명령을 사용하여 문서 수를 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c82b7f4625b4de3a4454fdede8889e7985323d5" translate="yes" xml:space="preserve">
          <source>You can create a multi index on an arbitrary expression in similar fashion, by passing the multi option as the last parameter to &lt;code&gt;indexCreate&lt;/code&gt;.</source>
          <target state="translated">마지막 옵션으로 multi 옵션을 &lt;code&gt;indexCreate&lt;/code&gt; 에 전달하여 유사한 방식으로 임의의 표현식에서 다중 색인을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ff9726784d6a1aff26ac13770f9e52387b5cba0" translate="yes" xml:space="preserve">
          <source>You can create an index on an arbitrary expression by passing an anonymous function to &lt;code&gt;indexCreate&lt;/code&gt;.</source>
          <target state="translated">익명 함수를 &lt;code&gt;indexCreate&lt;/code&gt; 에 전달하여 임의의 표현식에서 색인을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c85924dc6701675bf65f65e91338b361c7719c7" translate="yes" xml:space="preserve">
          <source>You can find unofficial community-supported Docker images on our &lt;a href=&quot;../frameworks-and-libraries/index&quot;&gt;Frameworks and Libraries&lt;/a&gt; list under &amp;ldquo;Docker images.&amp;rdquo;</source>
          <target state="translated">비공식 커뮤니티 지원 Docker 이미지 는 &quot;Docker images&quot;아래 의 &lt;a href=&quot;../frameworks-and-libraries/index&quot;&gt;Frameworks and Libraries&lt;/a&gt; 목록에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7128754a7ec44d094fd8436c4f0024fffbe80772" translate="yes" xml:space="preserve">
          <source>You can get the value of a specific field by using the &lt;code&gt;()&lt;/code&gt; operator successively to &amp;ldquo;drill down&amp;rdquo; in the document nesting:</source>
          <target state="translated">&lt;code&gt;()&lt;/code&gt; 연산자 를 사용 하여 문서 중첩에서 &quot;드릴 다운&quot; 하여 특정 필드의 값을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3fab9bb039306b94d3dcceac9307f7438d69a0d8" translate="yes" xml:space="preserve">
          <source>You can give the queue a name if you want, but since we passed an empty string to &lt;code&gt;assertQueue&lt;/code&gt; it&amp;rsquo;ll create a randomly generated name for us.</source>
          <target state="translated">원하는 경우 대기열 이름을 지정할 수 있지만 빈 문자열을 &lt;code&gt;assertQueue&lt;/code&gt; 에 전달 했기 때문에 임의로 생성 된 이름이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="95a4afcf8eb4b7e86bde39ff9cd1eee507b21edb" translate="yes" xml:space="preserve">
          <source>You can increase the performance of a query by using the &lt;code&gt;outdated&lt;/code&gt; read mode, which allows the cluster to return values from memory on arbitrarily-selected replicas.</source>
          <target state="translated">&lt;code&gt;outdated&lt;/code&gt; 읽기 모드를 사용하여 클러스터가 임의로 선택된 복제본의 메모리에서 값을 반환 할 수 있도록 하여 쿼리 성능을 향상시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="144b33ca938be37a7db68bea3a8e00681f057745" translate="yes" xml:space="preserve">
          <source>You can insert data in soft durability mode as follows:</source>
          <target state="translated">다음과 같이 부드러운 내구성 모드에서 데이터를 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19aa0f58079aaa5fdb28aefcf4d031b7fca0523d" translate="yes" xml:space="preserve">
          <source>You can insert documents by calling the &lt;code&gt;insert&lt;/code&gt; command on the appropriate table:</source>
          <target state="translated">해당 테이블 에서 &lt;code&gt;insert&lt;/code&gt; 명령을 호출하여 문서를 삽입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="522166a599dd048fb9f36a688c8769900fab5110" translate="yes" xml:space="preserve">
          <source>You can insert multiple documents at once by passing an array of documents to &lt;code&gt;insert&lt;/code&gt; as follows:</source>
          <target state="translated">다음과 같이 &lt;code&gt;insert&lt;/code&gt; 문서 배열을 전달하여 여러 문서를 한 번에 삽입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc5fd63ec4ce45a7100edbaad666967334a1bcbb" translate="yes" xml:space="preserve">
          <source>You can insert times by simply passing a native &lt;code&gt;Date&lt;/code&gt; object.</source>
          <target state="translated">기본 &lt;code&gt;Date&lt;/code&gt; 객체 를 전달하여 시간을 삽입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="751f056e4fe6679c065eb7194734fc44fd1a7b13" translate="yes" xml:space="preserve">
          <source>You can limit the number of documents returned by your queries with the &lt;code&gt;limit&lt;/code&gt; command. Let&amp;rsquo;s retrieve just the first 10 blog posts:</source>
          <target state="translated">&lt;code&gt;limit&lt;/code&gt; 명령 을 사용하여 쿼리에서 반환 한 문서 수를 제한 할 수 있습니다 . 처음 10 개의 블로그 게시물 만 검색해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="76b17d6c854c4f6dab9445bfb353fd30b3552e94" translate="yes" xml:space="preserve">
          <source>You can manually merge the &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; fields without using the &lt;code&gt;zip&lt;/code&gt; command. Suppose you want to keep the name of the employee and the name of his company. You can do:</source>
          <target state="translated">&lt;code&gt;zip&lt;/code&gt; 명령 을 사용하지 않고 &lt;code&gt;left&lt;/code&gt; 및 &lt;code&gt;right&lt;/code&gt; 필드를 수동으로 병합 할 수 있습니다 . 직원 이름과 회사 이름을 유지하려고한다고 가정하십시오. 넌 할 수있어:</target>
        </trans-unit>
        <trans-unit id="ef36e76fd44a04fb2dd47cac5bdfd94615eb0032" translate="yes" xml:space="preserve">
          <source>You can now access RethinkDB commands through the &lt;code&gt;r&lt;/code&gt; module.</source>
          <target state="translated">이제 &lt;code&gt;r&lt;/code&gt; 모듈을 통해 RethinkDB 명령에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79a60802ebbd73788c71aa231b342a11949864ed" translate="yes" xml:space="preserve">
          <source>You can now access the web interface using the following URL: &lt;code&gt;http://HOST/rethinkdb_admin&lt;/code&gt;.</source>
          <target state="translated">: 이제 다음 URL을 사용하여 웹 인터페이스에 액세스 할 수 있습니다 &lt;code&gt;http://HOST/rethinkdb_admin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32d827dd1b8146523ca253b1fbd010534352b7e6" translate="yes" xml:space="preserve">
          <source>You can now connect to your RethinkDB instance by connecting to the host &lt;code&gt;localhost&lt;/code&gt; and port &lt;code&gt;local_port&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;localhost&lt;/code&gt; 호스트 와 &lt;code&gt;local_port&lt;/code&gt; 포트 에 연결하여 RethinkDB 인스턴스에 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="544a44f70a2d29fc913b28c805d563bd24f59665" translate="yes" xml:space="preserve">
          <source>You can now generate models individually or use the scaffolding mechanism. For example, here&amp;rsquo;s a scaffold for an Article resource:</source>
          <target state="translated">이제 모델을 개별적으로 생성하거나 스캐 폴딩 메커니즘을 사용할 수 있습니다. 예를 들어 다음은 기사 리소스에 대한 스캐 폴드입니다.</target>
        </trans-unit>
        <trans-unit id="1babd33de8299282e70321fd6e6921550e6a311f" translate="yes" xml:space="preserve">
          <source>You can now visit &lt;code&gt;localhost:8080&lt;/code&gt; to see the RethinkDB web admin.</source>
          <target state="translated">이제 &lt;code&gt;localhost:8080&lt;/code&gt; 을 방문 하여 RethinkDB 웹 관리자를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2136ac157f038f4f09ae39e08df0720968297d60" translate="yes" xml:space="preserve">
          <source>You can only check arity of the methods to a certain extent. If an &lt;code&gt;ARGS&lt;/code&gt; term is one of the argument, only the server can effectively verify that enough arguments are provided (or not too many). The arity errors reported by the server suppose a prefix notation. Things may change if the solution in &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/2463#issuecomment-44584491&quot;&gt;#2463&lt;/a&gt; is implemented.</source>
          <target state="translated">당신은 어느 정도 방법의 arity를 ​​확인할 수 있습니다. 는 IF &lt;code&gt;ARGS&lt;/code&gt; 의 용어는 인수 중 하나입니다 만 서버가 효과적으로 충분한 인수가 제공 (또는 너무 많은되지 않음)되는 것을 확인할 수 있습니다. 서버가보고 한 arity 오류는 접두사 표기법을 가정합니다. &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/2463#issuecomment-44584491&quot;&gt;# 2463&lt;/a&gt; 의 솔루션 이 구현 되면 상황이 바뀔 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c9c17135e144b5ea5748af8b5b13a317d020c5cc" translate="yes" xml:space="preserve">
          <source>You can query for specific kinds of issues by filtering on the &lt;code&gt;type&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 필드 에서 필터링하여 특정 종류의 문제를 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a42ac8551b89b20f2c10b30974b7c931c71637d" translate="yes" xml:space="preserve">
          <source>You can read more about ReQL in the &lt;a href=&quot;../introduction-to-reql/index&quot;&gt;Introduction to ReQL&lt;/a&gt; article, or go into greater depth with the &lt;a href=&quot;../../api/javascript/index&quot;&gt;API documentation&lt;/a&gt;.</source>
          <target state="translated">ReQL &lt;a href=&quot;../introduction-to-reql/index&quot;&gt;소개&lt;/a&gt; 문서 에서 ReQL에 대한 자세한 내용을 읽 거나 &lt;a href=&quot;../../api/javascript/index&quot;&gt;API 설명서 &lt;/a&gt;를 자세히 살펴볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be9ee9a22a35c38e47001b9b9f655322e519c2c4" translate="yes" xml:space="preserve">
          <source>You can register multiple queries with the same &lt;code&gt;Handler&lt;/code&gt; instance. If you define &lt;code&gt;Handler&lt;/code&gt; methods with an additional argument (two arguments instead of one, or one argument instead of zero), that argument will receive the appropriate &lt;code&gt;QueryHandle&lt;/code&gt; instance.</source>
          <target state="translated">동일한 &lt;code&gt;Handler&lt;/code&gt; 인스턴스로 여러 쿼리를 등록 할 수 있습니다 . 추가 인수 (하나가 아닌 두 개의 인수 또는 0이 아닌 하나의 인수)를 사용하여 &lt;code&gt;Handler&lt;/code&gt; 메소드 를 정의하면 해당 인수는 적절한 &lt;code&gt;QueryHandle&lt;/code&gt; 인스턴스를 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="1933909364676c58638278c6dab0bcfb57c730da" translate="yes" xml:space="preserve">
          <source>You can run the &lt;code&gt;tags&lt;/code&gt; and &lt;code&gt;hierarchy&lt;/code&gt; demos the same way.</source>
          <target state="translated">&lt;code&gt;tags&lt;/code&gt; 와 &lt;code&gt;hierarchy&lt;/code&gt; 데모를 같은 방식으로 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b3967663785629ac46bd8c818c4a0c7fb7bb0b7" translate="yes" xml:space="preserve">
          <source>You can select the database where you&amp;rsquo;d like to create the table with the &lt;code&gt;db&lt;/code&gt; command and use the &lt;code&gt;tableCreate&lt;/code&gt; command as follows:</source>
          <target state="translated">&lt;code&gt;db&lt;/code&gt; 명령으로 테이블을 생성 할 데이터베이스를 선택하고 다음과 같이 &lt;code&gt;tableCreate&lt;/code&gt; 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3445238753b67722f154d32ffb435fb68a7c2ce7" translate="yes" xml:space="preserve">
          <source>You can specify associations between models in the generator:</source>
          <target state="translated">생성기에서 모델 간의 연관을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4655d414014487455834f6df43050a9e8837e922" translate="yes" xml:space="preserve">
          <source>You can then retrieve only the domain with the &lt;a href=&quot;../get_field/index&quot;&gt;()&lt;/a&gt; selector and &lt;a href=&quot;../nth/index&quot;&gt;nth&lt;/a&gt;.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;../get_field/index&quot;&gt;()&lt;/a&gt; selector 및 &lt;a href=&quot;../nth/index&quot;&gt;nth를 사용&lt;/a&gt; 하여 도메인 만 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc57e6e3fb5364b78e07f1d7b90170685584269a" translate="yes" xml:space="preserve">
          <source>You can upgrade your version of Node.js via &lt;code&gt;npm&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;npm&lt;/code&gt; 을 통해 Node.js 버전을 업그레이드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a96610657bbf110f72a345d4ecbc8d9e3ab92272" translate="yes" xml:space="preserve">
          <source>You can use Ruby&amp;rsquo;s &lt;code&gt;DateTime.to_time&lt;/code&gt; and &lt;code&gt;Time.to_datetime&lt;/code&gt; methods to easily convert between one and the other.</source>
          <target state="translated">Ruby의 &lt;code&gt;DateTime.to_time&lt;/code&gt; 및 &lt;code&gt;Time.to_datetime&lt;/code&gt; 메소드를 사용하여 서로간에 쉽게 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4696c1747cc9a947e3f0c3d082249e222fd734da" translate="yes" xml:space="preserve">
          <source>You can use a relational data modeling technique and create two tables to store your data. A typical document in the &lt;code&gt;authors&lt;/code&gt; table would look like this:</source>
          <target state="translated">관계형 데이터 모델링 기술을 사용하고 두 개의 테이블을 만들어 데이터를 저장할 수 있습니다. &lt;code&gt;authors&lt;/code&gt; 테이블 의 일반적인 문서 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="65f77048ddce4bc4a4e2b66b3f488074fd0873c3" translate="yes" xml:space="preserve">
          <source>You can use a reverse HTTP proxy to allow access to the web interface from other servers. Most web servers (such as Apache or Nginx) support this feature. In the following example we&amp;rsquo;ll use Apache to set up a reverse proxy.</source>
          <target state="translated">리버스 HTTP 프록시를 사용하여 다른 서버에서 웹 인터페이스에 액세스 할 수 있습니다. 대부분의 웹 서버 (예 : Apache 또는 Nginx)는이 기능을 지원합니다. 다음 예제에서는 Apache를 사용하여 리버스 프록시를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="34248ba9eb41ee870921e136f9b749265031e98c" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;../args/index&quot;&gt;args&lt;/a&gt; command to pass an array of Point objects (or latitude-longitude pairs) to &lt;code&gt;line&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../args/index&quot;&gt;args&lt;/a&gt; 명령을 사용하여 Point 객체의 배열 (또는 위도-경도 쌍)을 &lt;code&gt;line&lt;/code&gt; 에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e81a753574cef91d728da364d2a3db98c3d900d4" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;../args/index&quot;&gt;args&lt;/a&gt; command to pass an array of Point objects (or latitude-longitude pairs) to &lt;code&gt;polygon&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../args/index&quot;&gt;args&lt;/a&gt; 명령을 사용하여 Point 객체의 배열 (또는 위도-경도 쌍)을 &lt;code&gt;polygon&lt;/code&gt; 에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1883a6a496342b873c98c19cfd071b52992f989" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;dbCreate&lt;/code&gt; command as follows:</source>
          <target state="translated">다음과 같이 &lt;code&gt;dbCreate&lt;/code&gt; 명령을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b1a8bb3cc77f7c36ca0ad2e7223d33bcbb516f2c" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;epochTime&lt;/code&gt; and &lt;code&gt;ISO8601&lt;/code&gt; commands to convert Unix timestamps (in seconds) and JSON date-time strings (which are in ISO 8601 format) to the ReQL time type. The ReQL driver will also convert JavaScript Date objects into ReQL time.</source>
          <target state="translated">&lt;code&gt;epochTime&lt;/code&gt; 및 &lt;code&gt;ISO8601&lt;/code&gt; 명령을 사용하여 Unix 타임 스탬프 (초) 및 JSON 날짜-시간 문자열 (ISO 8601 형식)을 ReQL 시간 유형으로 변환 할 수 있습니다. ReQL 드라이버는 JavaScript Date 객체도 ReQL 시간으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="f1af73a9bb486d64ee96e9f24cb09d18d079d423" translate="yes" xml:space="preserve">
          <source>You can use the same programming environment and tools you&amp;rsquo;re already used to.</source>
          <target state="translated">이미 사용했던 것과 동일한 프로그래밍 환경과 도구를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1ca27ed70bc37c74353361fb557af790a5f1898" translate="yes" xml:space="preserve">
          <source>You cannot apply a &lt;code&gt;filter&lt;/code&gt; after &lt;code&gt;orderBy.limit&lt;/code&gt; in a changefeed.</source>
          <target state="translated">&lt;code&gt;orderBy.limit&lt;/code&gt; 에서 orderBy.limit 이후 에는 &lt;code&gt;filter&lt;/code&gt; 적용 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0e488f04e53bcbc97716fbfbf8849bce6efacd19" translate="yes" xml:space="preserve">
          <source>You cannot chain multiple &lt;code&gt;getAll&lt;/code&gt; commands. Use a compound index to efficiently retrieve documents by multiple fields.</source>
          <target state="translated">여러 &lt;code&gt;getAll&lt;/code&gt; 명령을 연결할 수 없습니다 . 복합 색인을 사용하여 여러 필드로 문서를 효율적으로 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="f812c4695332d39c66ee05c0e065ad6439a12fcd" translate="yes" xml:space="preserve">
          <source>You cannot change a username once it&amp;rsquo;s been created. You can, however, &lt;a href=&quot;../../api/javascript/delete/index&quot;&gt;delete&lt;/a&gt; users from the table.</source>
          <target state="translated">사용자 이름을 만든 후에는 변경할 수 없습니다. 그러나 테이블에서 사용자를 &lt;a href=&quot;../../api/javascript/delete/index&quot;&gt;삭제할&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f6e9f3b175f70884052e2fe6138e9def53f0107" translate="yes" xml:space="preserve">
          <source>You cannot use changefeeds after &lt;a href=&quot;../../../api/javascript/concat_map/index&quot;&gt;concatMap&lt;/a&gt; or other transformations whose results cannot be pushed to the shards.</source>
          <target state="translated">&lt;a href=&quot;../../../api/javascript/concat_map/index&quot;&gt;concatMap&lt;/a&gt; 또는 샤드로 결과를 푸시 할 수없는 다른 변환 후에는 변경 피드를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d5ab7b5179be60b7819ad174aebb47f94c0041ef" translate="yes" xml:space="preserve">
          <source>You have to explicitly use the &lt;code&gt;getAll&lt;/code&gt; command to take advantage of secondary indexes.</source>
          <target state="translated">보조 인덱스를 이용하려면 &lt;code&gt;getAll&lt;/code&gt; 명령 을 명시 적으로 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3ccc70d6fea9d281cc273dec1dd133e29a74e62f" translate="yes" xml:space="preserve">
          <source>You may also insert a time by inserting a literal pseudotype object. This is useful if, for instance, you exported a row using &lt;code&gt;{timeFormat:'raw'}&lt;/code&gt; (see &lt;strong&gt;Retrieving Times&lt;/strong&gt; below).</source>
          <target state="translated">리터럴 의사 유형 객체를 삽입하여 시간을 삽입 할 수도 있습니다. 예를 들어 &lt;code&gt;{timeFormat:'raw'}&lt;/code&gt; 를 사용하여 행을 내 보낸 경우에 유용합니다 ( 아래의 &lt;strong&gt;시간 검색&lt;/strong&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="d5c78d1f1e9d17eec8fcc2f3043e460ea50d9a31" translate="yes" xml:space="preserve">
          <source>You may also rebuild indexes manually in ReQL:</source>
          <target state="translated">ReQL에서 인덱스를 수동으로 다시 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b801a804a689f7ce7c3a900f04b102e00c4a77e" translate="yes" xml:space="preserve">
          <source>You may also see &lt;strong&gt;Any&lt;/strong&gt; used for commands that work with any data type.</source>
          <target state="translated">모든 데이터 유형에서 작동하는 명령에 사용 된 &lt;strong&gt;모든 항목&lt;/strong&gt; 을 볼 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="216cd29d79b5e764f267b1fbf7cd40f5945222e2" translate="yes" xml:space="preserve">
          <source>You may also use the special constants &lt;code&gt;r.minval&lt;/code&gt; and &lt;code&gt;r.maxval&lt;/code&gt; for boundaries, which represent &amp;ldquo;less than any index key&amp;rdquo; and &amp;ldquo;more than any index key&amp;rdquo; respectively. For instance, if you use &lt;code&gt;r.minval&lt;/code&gt; as the lower key, then &lt;code&gt;between&lt;/code&gt; will return all documents whose primary keys (or indexes) are less than the specified upper key.</source>
          <target state="translated">경계에 특수 상수 &lt;code&gt;r.minval&lt;/code&gt; 및 &lt;code&gt;r.maxval&lt;/code&gt; 을 사용할 수도 있습니다. 경계는 각각&amp;ldquo;모든 색인 키보다 작음&amp;rdquo;및&amp;ldquo;모든 색인 키보다 큼&amp;rdquo;을 나타냅니다. 당신이 사용하는 경우 예를 들어, &lt;code&gt;r.minval&lt;/code&gt; 낮은 키로하고 &lt;code&gt;between&lt;/code&gt; 누구의 기본 키 (또는 인덱스) 이하 지정된 상위 키보다 모든 문서를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7fd36a0d0214d1375b3acce6557fd40919d911a8" translate="yes" xml:space="preserve">
          <source>You may be able to check if the kernel&amp;rsquo;s out-of-memory killer is responsible for the crash by checking the system message buffer:</source>
          <target state="translated">시스템 메시지 버퍼를 확인하여 커널의 메모리 부족 킬러가 충돌을 담당하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4ab6a173ae1d00c9f2de8cdd6f47316610bceee" translate="yes" xml:space="preserve">
          <source>You may be interested in retrieving the results in this format:</source>
          <target state="translated">다음 형식으로 결과를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ca4e5872728b2af78f129fbcb8862f39ba1561e" translate="yes" xml:space="preserve">
          <source>You may call &lt;code&gt;branch&lt;/code&gt; infix style on the first test. (See the second example for an illustration.)</source>
          <target state="translated">첫 번째 테스트에서 &lt;code&gt;branch&lt;/code&gt; 삽입 스타일을 호출 할 수 있습니다 . (그림은 두 번째 예를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="88fbc6d30374c1685dcaa3058d32036e9d22c0e4" translate="yes" xml:space="preserve">
          <source>You may need to adjust RethinkDB&amp;rsquo;s page cache size, using the &lt;code&gt;--cache-size&lt;/code&gt; argument or configuration file option. Read &amp;ldquo;&lt;a href=&quot;../memory-usage/index&quot;&gt;Understanding RethinkDB memory requirements&lt;/a&gt;&amp;rdquo; for a more detailed explanation of how RethinkDB uses memory and how to tune its performance.</source>
          <target state="translated">&lt;code&gt;--cache-size&lt;/code&gt; 인수 또는 구성 파일 옵션을 사용하여 RethinkDB의 페이지 캐시 크기를 조정해야 할 수도 있습니다. RethinkDB가 메모리를 사용하는 방법 및 성능 조정 방법에 대한 자세한 설명은&amp;ldquo; &lt;a href=&quot;../memory-usage/index&quot;&gt;RethinkDB 메모리 요구 사항 이해&lt;/a&gt; &amp;rdquo;를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="035b683c2eb870d8c3a4314f01b4185d55a4eaf3" translate="yes" xml:space="preserve">
          <source>You may rebuild indexes with the &lt;code&gt;rethinkdb&lt;/code&gt; command line utility:</source>
          <target state="translated">&lt;code&gt;rethinkdb&lt;/code&gt; 명령 행 유틸리티를 사용하여 색인을 재 빌드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d45fcbef747c80cc440d1e1381aa9a9df031a71" translate="yes" xml:space="preserve">
          <source>You may receive a warning message about secondary indexes on startup being &amp;ldquo;outdated&amp;rdquo; when you upgrade RethinkDB versions.</source>
          <target state="translated">RethinkDB 버전을 업그레이드 할 때 시작시 2 차 색인이&amp;ldquo;구식 화&amp;rdquo;되었다는 경고 메시지가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2609f36c24cc34f3e43480b11002dab3d0ca9d7" translate="yes" xml:space="preserve">
          <source>You may rewrite these with anonymous functions.</source>
          <target state="translated">익명 함수로 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca1d5f446a7c535a121af4af891a4d8add811e03" translate="yes" xml:space="preserve">
          <source>You might also want to use the &lt;a href=&quot;../ungroup/index&quot;&gt;ungroup&lt;/a&gt; command (see above), which will turn the grouped data into an array of objects on the server.</source>
          <target state="translated">&lt;a href=&quot;../ungroup/index&quot;&gt;ungroup&lt;/a&gt; 명령 (위 참조) 을 사용하여 그룹화 된 데이터를 서버의 객체 배열로 변환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d436e93d9a8764b9f606ec167d5f673b80bd6458" translate="yes" xml:space="preserve">
          <source>You might have caught that there were 253 documents inserted, not 250. Either we have the top 253 movies, or there are a few duplicate records lurking in there. We can use &lt;code&gt;distinct&lt;/code&gt; to get a count of unique rows, but we need to remove the &lt;code&gt;id&lt;/code&gt; column from the query, since all ID values are unique.</source>
          <target state="translated">250 개가 아닌 253 개의 문서가 삽입 된 것을 발견했을 수 있습니다. 최상위 253 개의 영화가 있거나 거기에 숨겨져있는 몇 개의 복제 레코드가 있습니다. &lt;code&gt;distinct&lt;/code&gt; 를 사용 하여 고유 한 행 수를 얻을 수 있지만 모든 ID 값이 고유하므로 쿼리에서 &lt;code&gt;id&lt;/code&gt; 열 을 제거해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c327a4b6eb6a8adef5a599c8b2953dcb153c415f" translate="yes" xml:space="preserve">
          <source>You might want to &amp;ldquo;tag&amp;rdquo; the tables to make it clear which changes belong to which table.</source>
          <target state="translated">어떤 변경 사항이 어떤 테이블에 속하는지 명확히하기 위해 테이블에 &quot;태그&quot;를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c08b665617a6aa1f2e950387a4615085af0f8a22" translate="yes" xml:space="preserve">
          <source>You might want to produce a &amp;ldquo;union&amp;rdquo; changefeed to watch multiple tables or queries on just one feed. Since the &lt;code&gt;union&lt;/code&gt; command works with &lt;code&gt;changes&lt;/code&gt;, ReQL makes this fairly straightforward. To monitor two tables at once:</source>
          <target state="translated">하나의 피드에서 여러 테이블 또는 쿼리를 볼 수 있도록 &quot;연합&quot;변경 피드를 생성 할 수 있습니다. &lt;code&gt;union&lt;/code&gt; 명령은 &lt;code&gt;changes&lt;/code&gt; 와 함께 작동 하므로 ReQL은이를 매우 간단하게 만듭니다. 두 테이블을 한 번에 모니터하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="f40e2c91ca208432ed398a66468fc4cf49d642a7" translate="yes" xml:space="preserve">
          <source>You might want to use &lt;code&gt;filter&lt;/code&gt; to return documents that have one of two (or more) optional fields set, such as the following:</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; 를 사용 하여 다음과 같은 두 개 이상의 선택적 필드 중 하나가 설정된 문서를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d42e3e3b1bf529384b192a0b26f47fb0a3069032" translate="yes" xml:space="preserve">
          <source>You must export your data &lt;strong&gt;before&lt;/strong&gt; you&amp;rsquo;ve upgraded RethinkDB to a new version! If you&amp;rsquo;ve already updated, you can find binaries for previous versions in the &lt;a href=&quot;http://download.rethinkdb.com&quot;&gt;download archive&lt;/a&gt;.</source>
          <target state="translated">RethinkDB를 새 버전으로 업그레이드 &lt;strong&gt;하기 전에&lt;/strong&gt; 데이터 &lt;strong&gt;를&lt;/strong&gt; 내 보내야합니다! 이미 업데이트 한 경우 &lt;a href=&quot;http://download.rethinkdb.com&quot;&gt;다운로드 아카이브&lt;/a&gt; 에서 이전 버전의 바이너리를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="565592f422a57bd14395f0aa5e9f7a0c35a0c8de" translate="yes" xml:space="preserve">
          <source>You should not release a connection in the pool as soon as you receive a response. Only release the connection when you receive a response of a type other than &lt;code&gt;SUCCESS_PARTIAL&lt;/code&gt;.</source>
          <target state="translated">응답을받는 즉시 풀에서 연결을 해제해서는 안됩니다. &lt;code&gt;SUCCESS_PARTIAL&lt;/code&gt; 이외의 유형의 응답을 수신 한 경우에만 연결을 해제하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2a72e6345a75043e81786646c9dbb79a9081cfe" translate="yes" xml:space="preserve">
          <source>You should see a &amp;ldquo;Setting up a RethinkDB AMI&amp;rdquo; web page. Click on the &lt;strong&gt;Continue&lt;/strong&gt; button to proceed.</source>
          <target state="translated">&amp;ldquo;RethinkDB AMI 설정&amp;rdquo;웹 페이지가 표시되어야합니다. &lt;strong&gt;계속&lt;/strong&gt; 버튼을 클릭하여 &lt;strong&gt;계속&lt;/strong&gt; 진행하십시오.</target>
        </trans-unit>
        <trans-unit id="eaf96a569106f7f50b78dc40ac65e2bc7dc0d21b" translate="yes" xml:space="preserve">
          <source>You start using ReQL in your program similarly to how you&amp;rsquo;d use other databases:</source>
          <target state="translated">다른 데이터베이스를 사용하는 방법과 유사하게 프로그램에서 ReQL을 사용하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="404788204c896695d91565b254d02b6bcaa381e7" translate="yes" xml:space="preserve">
          <source>You will need to create new copies of the &lt;code&gt;com.rethinkdb.server.plist&lt;/code&gt; file with different names (e.g., &lt;code&gt;com.rethinkdb.server2.plist&lt;/code&gt;), making the following changes:</source>
          <target state="translated">다른 이름 (예 : &lt;code&gt;com.rethinkdb.server2.plist&lt;/code&gt; )으로 &lt;code&gt;com.rethinkdb.server.plist&lt;/code&gt; 파일 의 새 사본을 작성 하여 다음을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="47868cbefdabe5748bbbe9252f2e32d2707b331b" translate="yes" xml:space="preserve">
          <source>You will receive another response of either type &lt;code&gt;SUCCESS_PARTIAL&lt;/code&gt;, indicating there is still more data available, or &lt;code&gt;SUCCESS_SEQUENCE&lt;/code&gt; if you have reached the end of the stream. (This will never be returned for a feed.) Note that these &lt;code&gt;ResponseType&lt;/code&gt;s can be returned without data (an empty array as the &lt;code&gt;r&lt;/code&gt; value). A driver can send &lt;code&gt;CONTINUE&lt;/code&gt; to fetch the next batch of a sequence as soon as the response is received.</source>
          <target state="translated">사용 가능한 더 많은 데이터가 있음을 나타내는 &lt;code&gt;SUCCESS_PARTIAL&lt;/code&gt; 유형 또는 스트림 끝에 도달 한 경우 &lt;code&gt;SUCCESS_SEQUENCE&lt;/code&gt; 유형의 다른 응답이 수신됩니다 . 피드에 대해서는 반환되지 않습니다. 이러한 &lt;code&gt;ResponseType&lt;/code&gt; 은 데이터없이 반환 될 수 있습니다 (공백 배열은 &lt;code&gt;r&lt;/code&gt; 값). 드라이버는 응답을 수신하자마자 &lt;code&gt;CONTINUE&lt;/code&gt; 를 보내 시퀀스의 다음 배치를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="86c4cbeddd9897a41e6259d4e6a3d2093444c21d" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll need the following modules installed for Apache:</source>
          <target state="translated">Apache 용으로 다음 모듈이 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="82c41a6c59099a5955fcbee15e65b236d0cbb940" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll notice that both times we inserted are returned as native JavaScript &lt;code&gt;Date&lt;/code&gt; objects. (&lt;code&gt;Date&lt;/code&gt; objects don&amp;rsquo;t store time zone information, so both times are UTC, regardless of your server&amp;rsquo;s local time zone.)</source>
          <target state="translated">삽입 한 두 번 모두 기본 JavaScript &lt;code&gt;Date&lt;/code&gt; 객체 로 반환됩니다 . ( &lt;code&gt;Date&lt;/code&gt; 모두 시간에 관계없이 서버의 로컬 시간대, UTC 그래서 개체는 시간대 정보를 저장하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="e157eeb5d7999ee35c81400e6f62bfd4665acb70" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re now up and running with RethinkDB and Rails!</source>
          <target state="translated">이제 RethinkDB 및 Rails를 시작했습니다!</target>
        </trans-unit>
        <trans-unit id="060231f2ff139d1387dcc212f509aea6e53a8086" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re on your way with Ruby on Rails and RethinkDB! Be sure to check out additional resources for more information.</source>
          <target state="translated">Ruby on Rails 및 RethinkDB를 사용하고 있습니다! 자세한 내용은 추가 리소스를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c0f2169a05838f460f5e9de4b3001208843d3087" translate="yes" xml:space="preserve">
          <source>Your application would by default receive the object as it existed in the database after the &lt;em&gt;most recent&lt;/em&gt; change. The previous two updates would be &amp;ldquo;squashed&amp;rdquo; into the third.</source>
          <target state="translated">기본적으로 응용 프로그램은 &lt;em&gt;가장 최근에&lt;/em&gt; 변경 한 후 데이터베이스에있는 그대로 개체를받습니다 . 이전 두 업데이트는 세 번째로 &quot;중단&quot;되었습니다.</target>
        </trans-unit>
        <trans-unit id="d66cc44d6602b7bd31c89d7a1be1215e97a7adc8" translate="yes" xml:space="preserve">
          <source>Your cluster configuration (number of servers, basic network topology, etc.)</source>
          <target state="translated">클러스터 구성 (서버 수, 기본 네트워크 토폴로지 등)</target>
        </trans-unit>
        <trans-unit id="3375d9e34870f4082b05af85d0b6b6b292554300" translate="yes" xml:space="preserve">
          <source>Your driver should assign each query a unique 8-byte token per connection. (The official RethinkDB drivers implement this as an unsigned 8-byte little-endian counter per connection.) The server will send responses to queries using this token as an identifier so the response can be matched to its query. The token can also be used to request more data for the query if all the results were not returned in the first response.</source>
          <target state="translated">드라이버는 각 쿼리마다 연결 당 고유 한 8 바이트 토큰을 할당해야합니다. (공식 RethinkDB 드라이버는이를 연결 당 서명되지 않은 8 바이트 리틀 엔디안 카운터로 구현합니다.) 서버는이 토큰을 식별자로 사용하여 쿼리에 응답을 보내 응답을 해당 쿼리와 일치시킬 수 있습니다. 첫 번째 응답에서 모든 결과가 반환되지 않은 경우 토큰을 사용하여 쿼리에 대한 추가 데이터를 요청할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5078ae8174ee0ebcf94480eb09d460024b113428" translate="yes" xml:space="preserve">
          <source>Zipfian key access distribution</source>
          <target state="translated">Zipfian 키 액세스 배포</target>
        </trans-unit>
        <trans-unit id="a8a0673c8ed7b6be0dbd6e89da9b275e36e95a98" translate="yes" xml:space="preserve">
          <source>a &lt;strong&gt;field name&lt;/strong&gt;, to return the element of the sequence with the largest value in that field;</source>
          <target state="translated">해당 &lt;strong&gt;필드&lt;/strong&gt; 에서 가장 큰 값을 갖는 시퀀스의 요소를 리턴 하는 &lt;strong&gt;필드 이름&lt;/strong&gt; ;</target>
        </trans-unit>
        <trans-unit id="03960db85c68eefbc47d4547b8d35cf0176392b6" translate="yes" xml:space="preserve">
          <source>a &lt;strong&gt;field name&lt;/strong&gt;, to return the element of the sequence with the smallest value in that field;</source>
          <target state="translated">그 &lt;strong&gt;필드 내&lt;/strong&gt; 에서 가장 작은 값을 가지는 순서의 요소를 돌려 주는 &lt;strong&gt;필드 명&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e6a2eac36c508310920d67198d9c07d0ac4346cb" translate="yes" xml:space="preserve">
          <source>a &lt;strong&gt;function&lt;/strong&gt;, to apply the function to every element within the sequence and return the element which returns the largest value from the function, ignoring any elements where the function produces a non-existence error.</source>
          <target state="translated">&lt;strong&gt;함수는&lt;/strong&gt; , 시퀀스 내의 모든 요소에 함수를 적용하는 기능이 존재하지 않는 오류 발생의 요소가 무시 함수에서 최대 값을 반환하는 요소를 반환한다.</target>
        </trans-unit>
        <trans-unit id="51161408b253db2bc8cd04ca036d0be54cc2469d" translate="yes" xml:space="preserve">
          <source>a &lt;strong&gt;function&lt;/strong&gt;, to apply the function to every element within the sequence and return the element which returns the smallest value from the function, ignoring any elements where the function produces a non-existence error.</source>
          <target state="translated">&lt;strong&gt;함수는&lt;/strong&gt; , 시퀀스 내의 모든 요소에 함수를 적용하는 기능이 존재하지 않는 오류 발생의 요소가 무시 함수에서 최소값을 리턴하는 요소를 반환한다.</target>
        </trans-unit>
        <trans-unit id="cd9872fbde97c7cf8b282e7afff9d51a63f70f22" translate="yes" xml:space="preserve">
          <source>a binary object can be coerced to a string and vice-versa</source>
          <target state="translated">이진 객체는 문자열로 강제 변환 할 수 있으며 그 반대의 경우도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="45abe18bbf8e0052b4064b1b9c9bd0cfa96182da" translate="yes" xml:space="preserve">
          <source>a sequence, selection or an array of key-value pairs can be coerced to an object</source>
          <target state="translated">키-값 쌍의 시퀀스, 선택 또는 배열을 객체로 강제 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab027b3a4f17d2c5fbc84639e3d462c468056de8" translate="yes" xml:space="preserve">
          <source>a sequence, selection or object can be coerced to an array</source>
          <target state="translated">시퀀스, 선택 또는 객체를 배열로 강제 변환 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e325e7bf81dae8d35aeef7c7a58e7bf8c0a14465" translate="yes" xml:space="preserve">
          <source>a stream will be handled by &lt;code&gt;on_stream_val&lt;/code&gt; if defined; otherwise it will be handled by &lt;code&gt;on_val&lt;/code&gt;.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;on_stream_val&lt;/code&gt; 에 의해 스트림이 처리됩니다 . 그렇지 않으면 &lt;code&gt;on_val&lt;/code&gt; 에 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="59462ed31f22981dcea909b3a58fd3f7fee5aeea" translate="yes" xml:space="preserve">
          <source>a string can be coerced to a number</source>
          <target state="translated">문자열을 숫자로 강제 변환 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="58d1bbce297de3c304a9fefc3b483181872a5c6b" translate="yes" xml:space="preserve">
          <source>add</source>
          <target state="translated">add</target>
        </trans-unit>
        <trans-unit id="c63d48ab6a49abed2ff11f28593398d7920e1365" translate="yes" xml:space="preserve">
          <source>an &lt;strong&gt;index&lt;/strong&gt; (the primary key or a secondary index), to return the element of the sequence with the largest value in that index;</source>
          <target state="translated">해당 &lt;strong&gt;인덱스&lt;/strong&gt; 에서 가장 큰 값을 가진 시퀀스 요소를 리턴 하는 &lt;strong&gt;인덱스&lt;/strong&gt; (기본 키 또는 보조 인덱스);</target>
        </trans-unit>
        <trans-unit id="b22fd606be8e50662952de0616e76de5f757397d" translate="yes" xml:space="preserve">
          <source>an &lt;strong&gt;index&lt;/strong&gt; (the primary key or a secondary index), to return the element of the sequence with the smallest value in that index;</source>
          <target state="translated">해당 &lt;strong&gt;인덱스&lt;/strong&gt; 에서 가장 작은 값을 가진 시퀀스 요소를 리턴 하는 &lt;strong&gt;인덱스&lt;/strong&gt; (기본 키 또는 보조 인덱스);</target>
        </trans-unit>
        <trans-unit id="2f61c5a7a1dd022dd82cf2297401f9e62417803b" translate="yes" xml:space="preserve">
          <source>an array will be handled by &lt;code&gt;on_array&lt;/code&gt; if defined; otherwise it will be handled by &lt;code&gt;on_atom&lt;/code&gt;. If neither of those are defined, the &lt;em&gt;individual elements&lt;/em&gt; of the array will be handled by &lt;code&gt;on_stream_val&lt;/code&gt; or, if that is not defined, &lt;code&gt;on_val&lt;/code&gt;.</source>
          <target state="translated">배열은 정의 된 경우 &lt;code&gt;on_array&lt;/code&gt; 에 의해 처리됩니다 . 그렇지 않으면 &lt;code&gt;on_atom&lt;/code&gt; 에 의해 처리됩니다 . 이들의 어느 쪽이 정의되면, &lt;em&gt;개별 요소&lt;/em&gt; 어레이에 의해 처리 될 &lt;code&gt;on_stream_val&lt;/code&gt; 이 정의되어 있지 않은 경우, 또는 &lt;code&gt;on_val&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="d09ece47e5e6eac4f0488488b4d27d82317b9e3a" translate="yes" xml:space="preserve">
          <source>and in another window run:</source>
          <target state="translated">다른 창에서 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="2c6be7e76811f8a5e128fffbca0db1459bf763b3" translate="yes" xml:space="preserve">
          <source>any datum (single value) can be coerced to to a string</source>
          <target state="translated">모든 데이텀 (단일 값)을 문자열로 강제 변환 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a58020f282bf4efacbf5d09a443a72fc9c66bcab" translate="yes" xml:space="preserve">
          <source>anything else: as &lt;code&gt;text&lt;/code&gt;</source>
          <target state="translated">다른 것 : &lt;code&gt;text&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db43bff34c78044870bc6b1ae2aa16902bb1bb8a" translate="yes" xml:space="preserve">
          <source>append</source>
          <target state="translated">append</target>
        </trans-unit>
        <trans-unit id="3030e728f154bf51419109efb93b6b8aeec9a976" translate="yes" xml:space="preserve">
          <source>args</source>
          <target state="translated">args</target>
        </trans-unit>
        <trans-unit id="fcc9016d1aa6a646348df69e14d31e955d51da60" translate="yes" xml:space="preserve">
          <source>arrays</source>
          <target state="translated">arrays</target>
        </trans-unit>
        <trans-unit id="dfc520a023c642ce8f2688447d7245de35aae993" translate="yes" xml:space="preserve">
          <source>auth key</source>
          <target state="translated">인증 키</target>
        </trans-unit>
        <trans-unit id="97e77871b5fcc4941bebceb4338c97c1fd149f8c" translate="yes" xml:space="preserve">
          <source>avg</source>
          <target state="translated">avg</target>
        </trans-unit>
        <trans-unit id="89f7376411836c9118d833584b7127b976b30eca" translate="yes" xml:space="preserve">
          <source>backfill</source>
          <target state="translated">backfill</target>
        </trans-unit>
        <trans-unit id="709634051471385aada32356842983beeff4b065" translate="yes" xml:space="preserve">
          <source>between</source>
          <target state="translated">between</target>
        </trans-unit>
        <trans-unit id="7e57cfe843145135aee1f4d0d63ceb7842093712" translate="yes" xml:space="preserve">
          <source>binary</source>
          <target state="translated">binary</target>
        </trans-unit>
        <trans-unit id="0cf36e054d06cf3e24262b9c117b8c36a2f910c2" translate="yes" xml:space="preserve">
          <source>binary objects</source>
          <target state="translated">이진 객체</target>
        </trans-unit>
        <trans-unit id="80a25bf9e5d787c109376c0b79d204a87d3b2159" translate="yes" xml:space="preserve">
          <source>booleans</source>
          <target state="translated">booleans</target>
        </trans-unit>
        <trans-unit id="8b7003a3cbdca58c13fadc160b3cb2a18890ccd4" translate="yes" xml:space="preserve">
          <source>box-rethinkdb</source>
          <target state="translated">box-rethinkdb</target>
        </trans-unit>
        <trans-unit id="10d735e581f1e2505cd69675691925490e447c44" translate="yes" xml:space="preserve">
          <source>branch</source>
          <target state="translated">branch</target>
        </trans-unit>
        <trans-unit id="613af80c25dfbc9ef75ce605280571b9a518d632" translate="yes" xml:space="preserve">
          <source>ceil</source>
          <target state="translated">ceil</target>
        </trans-unit>
        <trans-unit id="5b21c21f1b4d308af711792b548fc67cbdb3501b" translate="yes" xml:space="preserve">
          <source>changeAt</source>
          <target state="translated">changeAt</target>
        </trans-unit>
        <trans-unit id="49a04ba4469678c38e0f6a327f8702ea61d9e8a4" translate="yes" xml:space="preserve">
          <source>changes</source>
          <target state="translated">changes</target>
        </trans-unit>
        <trans-unit id="00b7b8118efde44c546b69243ec15b21cd64c9d9" translate="yes" xml:space="preserve">
          <source>circle</source>
          <target state="translated">circle</target>
        </trans-unit>
        <trans-unit id="da38860cb875cb64092e402d80d9fe29c4865b18" translate="yes" xml:space="preserve">
          <source>close</source>
          <target state="translated">close</target>
        </trans-unit>
        <trans-unit id="3f058d4502d8d3821d428b7868b825d469c09dfc" translate="yes" xml:space="preserve">
          <source>close (cursor)</source>
          <target state="translated">닫기 (커서)</target>
        </trans-unit>
        <trans-unit id="da68bf3a55223d19ffeabebe48b0af570d763307" translate="yes" xml:space="preserve">
          <source>cluster</source>
          <target state="translated">cluster</target>
        </trans-unit>
        <trans-unit id="b8359ca5f77b2d89fbef0ec0be2b08810eb6036f" translate="yes" xml:space="preserve">
          <source>cluster_config</source>
          <target state="translated">cluster_config</target>
        </trans-unit>
        <trans-unit id="09c2d2c08b69155cee87c21f7ba3f9df41b4ccbc" translate="yes" xml:space="preserve">
          <source>coerceTo</source>
          <target state="translated">coerceTo</target>
        </trans-unit>
        <trans-unit id="aa60230ab00282b5a1f3f1993b2d1c503e7d15a5" translate="yes" xml:space="preserve">
          <source>column</source>
          <target state="translated">column</target>
        </trans-unit>
        <trans-unit id="f4c35a76ac7be23c2bdef7981de2a3ccdf4c6dbd" translate="yes" xml:space="preserve">
          <source>concatMap</source>
          <target state="translated">concatMap</target>
        </trans-unit>
        <trans-unit id="aadcc2dbb054cb813f3bcabf9f333951aecd357d" translate="yes" xml:space="preserve">
          <source>concat_map</source>
          <target state="translated">concat_map</target>
        </trans-unit>
        <trans-unit id="dfba7aade0868074c2861c98e2a9a92f3178a51b" translate="yes" xml:space="preserve">
          <source>config</source>
          <target state="translated">config</target>
        </trans-unit>
        <trans-unit id="f11a107f38328604e9320754224b60375758bca1" translate="yes" xml:space="preserve">
          <source>connect</source>
          <target state="translated">connect</target>
        </trans-unit>
        <trans-unit id="348eb028ae2fba9221b11f8c2e3cdea9cb2bf40c" translate="yes" xml:space="preserve">
          <source>contact &amp;rarr; phone &amp;rarr; work &amp;rarr; 408-555-1212</source>
          <target state="translated">연락처 &amp;rarr; 전화 &amp;rarr; 직장 &amp;rarr; 408-555-1212</target>
        </trans-unit>
        <trans-unit id="caeb909ae4ff4ee25a0ff0d476946ed256f2aee1" translate="yes" xml:space="preserve">
          <source>contains</source>
          <target state="translated">contains</target>
        </trans-unit>
        <trans-unit id="be25171a40f5008c51632a20d39171138456c900" translate="yes" xml:space="preserve">
          <source>could return &lt;code&gt;false&lt;/code&gt;! Each individual &lt;a href=&quot;../../api/javascript/get/index&quot;&gt;get&lt;/a&gt; operation is atomic, but the query as a whole is not. To read and modify a document in a single atomic operation, use the &lt;a href=&quot;../../api/javascript/update/index&quot;&gt;update&lt;/a&gt; or &lt;a href=&quot;../../api/javascript/replace/index&quot;&gt;replace&lt;/a&gt; commands.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 반환 할 수 있습니다 ! 각 개별 &lt;a href=&quot;../../api/javascript/get/index&quot;&gt;가져 오기&lt;/a&gt; 작업은 원 자성이지만 쿼리 전체는 그렇지 않습니다. 단일 원자 작업으로 문서를 읽고 수정하려면 &lt;a href=&quot;../../api/javascript/update/index&quot;&gt;update&lt;/a&gt; 또는 &lt;a href=&quot;../../api/javascript/replace/index&quot;&gt;replace&lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee9f38e186ba06f57b7b74d7e626b94e13ce2556" translate="yes" xml:space="preserve">
          <source>count</source>
          <target state="translated">count</target>
        </trans-unit>
        <trans-unit id="825b192e87a09e48fa7650bc8b5c00660b37183c" translate="yes" xml:space="preserve">
          <source>current_issues</source>
          <target state="translated">current_issues</target>
        </trans-unit>
        <trans-unit id="233e3ce74af9b1e2688f1f811ea11b8770173d6e" translate="yes" xml:space="preserve">
          <source>data that is &lt;em&gt;not&lt;/em&gt; a stream will be handled by &lt;code&gt;on_atom&lt;/code&gt; if defined; otherwise it will be handled by &lt;code&gt;on_val&lt;/code&gt;.</source>
          <target state="translated">스트림 이 &lt;em&gt;아닌&lt;/em&gt; 데이터는 정의 된 경우 &lt;code&gt;on_atom&lt;/code&gt; 에 의해 처리됩니다 . 그렇지 않으면 &lt;code&gt;on_val&lt;/code&gt; 에 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="6d613a1ee01eec4c0f8ca66df0db71dca0c6e1cf" translate="yes" xml:space="preserve">
          <source>database</source>
          <target state="translated">database</target>
        </trans-unit>
        <trans-unit id="03b1cc5f2e973088b9bb7dc062fee46bd8f432e7" translate="yes" xml:space="preserve">
          <source>database (affecting a database and the tables within)</source>
          <target state="translated">데이터베이스 (데이터베이스 및 테이블 내의 영향)</target>
        </trans-unit>
        <trans-unit id="e927d0677c77241b707442314346326278051dd6" translate="yes" xml:space="preserve">
          <source>date</source>
          <target state="translated">date</target>
        </trans-unit>
        <trans-unit id="a2620cbc10f5198dd03e3f5a1569eb5dcf9a6a87" translate="yes" xml:space="preserve">
          <source>day</source>
          <target state="translated">day</target>
        </trans-unit>
        <trans-unit id="d096c011585d07ea34d552634cab76998611ecd3" translate="yes" xml:space="preserve">
          <source>dayOfWeek</source>
          <target state="translated">dayOfWeek</target>
        </trans-unit>
        <trans-unit id="7d0afeccbd861b481e5513e7daf9473833eacec3" translate="yes" xml:space="preserve">
          <source>dayOfYear</source>
          <target state="translated">dayOfYear</target>
        </trans-unit>
        <trans-unit id="0352a8acc949c7df21fec16e566ba9a74e797a97" translate="yes" xml:space="preserve">
          <source>db</source>
          <target state="translated">db</target>
        </trans-unit>
        <trans-unit id="c6b86d9568cd42b1afb45d6533e1f5b6cc2dbfe9" translate="yes" xml:space="preserve">
          <source>dbCreate</source>
          <target state="translated">dbCreate</target>
        </trans-unit>
        <trans-unit id="3632550442fe7f7fb5788d44a3c05e77e638473d" translate="yes" xml:space="preserve">
          <source>dbDrop</source>
          <target state="translated">dbDrop</target>
        </trans-unit>
        <trans-unit id="8f9451107ae4c39ed8e37bcc9cfc7ffc3c891664" translate="yes" xml:space="preserve">
          <source>dbList</source>
          <target state="translated">dbList</target>
        </trans-unit>
        <trans-unit id="b7ff13c07403be6a24a21282f1e7367c3f378d23" translate="yes" xml:space="preserve">
          <source>db_config</source>
          <target state="translated">db_config</target>
        </trans-unit>
        <trans-unit id="7505d64a54e061b7acd54ccd58b49dc43500b635" translate="yes" xml:space="preserve">
          <source>default</source>
          <target state="translated">default</target>
        </trans-unit>
        <trans-unit id="9485989ff514b5106b7738850fd73c23e8c1e3f7" translate="yes" xml:space="preserve">
          <source>delete</source>
          <target state="translated">delete</target>
        </trans-unit>
        <trans-unit id="5a5ecfe6db57773e77aaacb83bd9dda4c230a08f" translate="yes" xml:space="preserve">
          <source>deleteAt</source>
          <target state="translated">deleteAt</target>
        </trans-unit>
        <trans-unit id="48d53c6e22192bbaaff43be3456d5f6f5d82da6f" translate="yes" xml:space="preserve">
          <source>difference</source>
          <target state="translated">difference</target>
        </trans-unit>
        <trans-unit id="8ae18ed496a7c0132f6bdd4064c9122781c753c0" translate="yes" xml:space="preserve">
          <source>disk_compaction</source>
          <target state="translated">disk_compaction</target>
        </trans-unit>
        <trans-unit id="104082c0efcf62ca0e142ebdffe15221e79de79d" translate="yes" xml:space="preserve">
          <source>distance</source>
          <target state="translated">distance</target>
        </trans-unit>
        <trans-unit id="21a08d6787a0d64238e8d57c9b087a45f1a70665" translate="yes" xml:space="preserve">
          <source>distinct</source>
          <target state="translated">distinct</target>
        </trans-unit>
        <trans-unit id="26021f1f4700496d68e21ef6d4a1b6945da4c8eb" translate="yes" xml:space="preserve">
          <source>div</source>
          <target state="translated">div</target>
        </trans-unit>
        <trans-unit id="eadcd9bd2a09c75aef04954e6799e50278ee124a" translate="yes" xml:space="preserve">
          <source>do</source>
          <target state="translated">do</target>
        </trans-unit>
        <trans-unit id="4f8278c89ad16da05fec4fdfc61fe44798b92720" translate="yes" xml:space="preserve">
          <source>document</source>
          <target state="translated">document</target>
        </trans-unit>
        <trans-unit id="e4370fb0ea59e2aeb0cf8fec4afadb0dd1b956c6" translate="yes" xml:space="preserve">
          <source>downcase</source>
          <target state="translated">downcase</target>
        </trans-unit>
        <trans-unit id="ffed391ca2a6c8bb0b20f95bace87ef78d0c9f59" translate="yes" xml:space="preserve">
          <source>during</source>
          <target state="translated">during</target>
        </trans-unit>
        <trans-unit id="b32f279e548b6fceef4343170778273bfe60658c" translate="yes" xml:space="preserve">
          <source>each</source>
          <target state="translated">each</target>
        </trans-unit>
        <trans-unit id="b1dbc1e1373091420361bccbec082ea83c366e5c" translate="yes" xml:space="preserve">
          <source>eachAsync</source>
          <target state="translated">eachAsync</target>
        </trans-unit>
        <trans-unit id="b07623c2ca4a8d4da83b94812562e891cb5c7139" translate="yes" xml:space="preserve">
          <source>epochTime</source>
          <target state="translated">epochTime</target>
        </trans-unit>
        <trans-unit id="a9c619705e8fcaa770885cac1837ae950f5c8ba5" translate="yes" xml:space="preserve">
          <source>eq</source>
          <target state="translated">eq</target>
        </trans-unit>
        <trans-unit id="e6fd069581a9f3fdcf06a7b624e63f0074e8b36f" translate="yes" xml:space="preserve">
          <source>eqJoin</source>
          <target state="translated">eqJoin</target>
        </trans-unit>
        <trans-unit id="f4ee2443ea84bd630ec142e6d14d7252fe5b111a" translate="yes" xml:space="preserve">
          <source>eq_join</source>
          <target state="translated">eq_join</target>
        </trans-unit>
        <trans-unit id="11f9578d05e6f7bb58a3cdd00107e9f4e3882671" translate="yes" xml:space="preserve">
          <source>error</source>
          <target state="translated">error</target>
        </trans-unit>
        <trans-unit id="0fd1860204d6cee43392972817e66792ee702b89" translate="yes" xml:space="preserve">
          <source>expr</source>
          <target state="translated">expr</target>
        </trans-unit>
        <trans-unit id="2da0b68df8841752bb747a76780679bcd87c6215" translate="yes" xml:space="preserve">
          <source>field</source>
          <target state="translated">field</target>
        </trans-unit>
        <trans-unit id="7aec9744ba1554e4d38febae4278e74a5e764414" translate="yes" xml:space="preserve">
          <source>fill</source>
          <target state="translated">fill</target>
        </trans-unit>
        <trans-unit id="4bb4ca75941b7bbc5bc6a12be44b22fc9c8d234e" translate="yes" xml:space="preserve">
          <source>filter</source>
          <target state="translated">filter</target>
        </trans-unit>
        <trans-unit id="3684c9d3c05e7bee19e2728c6a5b2bbccf0cd9c7" translate="yes" xml:space="preserve">
          <source>floor</source>
          <target state="translated">floor</target>
        </trans-unit>
        <trans-unit id="43402b235d9049b59f92a603a9cf29e68b57c71c" translate="yes" xml:space="preserve">
          <source>fluent-plugin-rethinkdb</source>
          <target state="translated">fluent-plugin-rethinkdb</target>
        </trans-unit>
        <trans-unit id="c5b2b01d33b40a69b0f829fd1827cb8201538518" translate="yes" xml:space="preserve">
          <source>fold</source>
          <target state="translated">fold</target>
        </trans-unit>
        <trans-unit id="7baf67ac9de40c6fc6e4dfd610bab1343f7292a2" translate="yes" xml:space="preserve">
          <source>for each element in the sequence, call both the combining function and a separate emitting function. The emitting function takes three parameters: the previous reduction result (the accumulator), the current element, and the output from the combining function (the new value of the accumulator).</source>
          <target state="translated">시퀀스의 각 요소에 대해 결합 기능과 개별 방출 기능을 모두 호출하십시오. 방출 기능은 이전 감소 결과 (누산기), 전류 요소 및 결합 기능의 출력 (누산기의 새로운 값)의 세 가지 매개 변수를 취합니다.</target>
        </trans-unit>
        <trans-unit id="edc5ee22beb2b82f4da41914d8d41cca9c53020f" translate="yes" xml:space="preserve">
          <source>forEach</source>
          <target state="translated">forEach</target>
        </trans-unit>
        <trans-unit id="96acf00f78ac6bb5cac1dec9c262de290a22dbb2" translate="yes" xml:space="preserve">
          <source>function: the &lt;code&gt;interleave&lt;/code&gt; argument can take a function whose argument is the current row, and whose return value is a string to take as a field name, as with the &lt;code&gt;&quot;field_name&quot;&lt;/code&gt; setting described above.</source>
          <target state="translated">function : &lt;code&gt;interleave&lt;/code&gt; 인수는 위에서 설명한 &lt;code&gt;&quot;field_name&quot;&lt;/code&gt; 설정과 같이 인수가 현재 행이고 반환 값이 필드 이름으로 사용할 문자열 인 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9060bd5525711459bfd3fbd9a5d9658cfa6338a" translate="yes" xml:space="preserve">
          <source>ge</source>
          <target state="translated">ge</target>
        </trans-unit>
        <trans-unit id="b582f58d189d192b7d2998328bbf22a0ed59b60d" translate="yes" xml:space="preserve">
          <source>geojson</source>
          <target state="translated">geojson</target>
        </trans-unit>
        <trans-unit id="65e4e3da890302538dd75ff31b491e3c7fef5d76" translate="yes" xml:space="preserve">
          <source>geometry objects</source>
          <target state="translated">지오메트리 객체</target>
        </trans-unit>
        <trans-unit id="783923e57ba5e8f1044632c31fd806ee24814bb5" translate="yes" xml:space="preserve">
          <source>get</source>
          <target state="translated">get</target>
        </trans-unit>
        <trans-unit id="159ecaec32b351286f1d86013ef0ed8ee1ad6934" translate="yes" xml:space="preserve">
          <source>getAll</source>
          <target state="translated">getAll</target>
        </trans-unit>
        <trans-unit id="a1f20c8f5186bb9d998515a2d95409450015f95f" translate="yes" xml:space="preserve">
          <source>getField</source>
          <target state="translated">getField</target>
        </trans-unit>
        <trans-unit id="9296baea6e69026f29ae352a59cfa8236933d146" translate="yes" xml:space="preserve">
          <source>getIntersecting</source>
          <target state="translated">getIntersecting</target>
        </trans-unit>
        <trans-unit id="84020c79c2c513336c8ad5755f06c427fc2a4fba" translate="yes" xml:space="preserve">
          <source>getNearest</source>
          <target state="translated">getNearest</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
