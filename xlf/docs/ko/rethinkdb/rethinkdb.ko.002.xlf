<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rethinkdb">
    <body>
      <group id="rethinkdb">
        <trans-unit id="f7ca38bb0bf493c1752c3f9b10124037cdd8e7b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return all the changes to the top 10 games. This assumes the presence of a &lt;code&gt;score&lt;/code&gt; secondary index on the &lt;code&gt;games&lt;/code&gt; table.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 모든 변경 사항을 상위 10 개 게임으로 되돌립니다. &lt;code&gt;games&lt;/code&gt; 테이블 에 &lt;code&gt;score&lt;/code&gt; 2 차 색인 이 있다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="da47743845247b03cb7b62369e7ea588ca8fe16a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return all the inserts on a table.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 테이블의 모든 삽입물을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="95c800293ee11b4c28cb47aa00e5605df6a7faaf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return all the posts submitted after midnight and before 4am.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 자정 이후와 오전 4시 이전에 제출 된 모든 게시물을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c2eb1b13670c5fd06052ca96c92e19fbbf7029e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return all the posts submitted during the first 10 minutes of every hour.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 매시간 처음 10 분 동안 제출 된 모든 게시물을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="281a9e792080d04d5b11ea2bb4bf1646c4d6f0e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return all the users in the &amp;ldquo;-07:00&amp;rdquo; timezone.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; &amp;ldquo;-07 : 00&amp;rdquo;시간대의 모든 사용자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0ad31dc5c0a4e63b4cb486106b11f68f42f0d1c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return all the users that do not have a &amp;ldquo;flag&amp;rdquo; field.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; &quot;플래그&quot;필드가없는 모든 사용자를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="138f95b16743f5c6b3fd7c600a4316d5320c05d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return every other row in a table.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 테이블의 다른 모든 행을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e447ef92e69139af64b9b1ed6f07673fec4ebc6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return holders of tickets &lt;code&gt;X&lt;/code&gt; through &lt;code&gt;Y&lt;/code&gt;, assuming tickets are numbered sequentially. We want to include ticket &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 티켓이 순차적으로 번호가 매겨 졌다고 가정 할 때 &lt;code&gt;X&lt;/code&gt; 부터 &lt;code&gt;Y&lt;/code&gt; 까지 의 티켓 소지자 . 티켓 &lt;code&gt;Y&lt;/code&gt; 를 포함하고 싶습니다 .</target>
        </trans-unit>
        <trans-unit id="4175445a554f28658daba13047aefd62814f1da1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return server information.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 서버 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="48c6a6d5e0e7e1a8c1bbffaf6adfe0d66e6958d4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the best scoring player in a two-player golf match.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 2 인 골프 경기에서 최고 득점 선수를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="60f99acb227e65127dd3387c9cd4ec2724dd1592" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the ceiling of -12.345.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; -12.345의 천장을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fc4a04e0bdf1e837c7395ea7ab38ad77e7faf1bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the ceiling of 12.345.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 12.345의 천장을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="105a6beb774e4c1bcd2a7047adfff6f1ef11d317" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the current ISO 8601 time.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 현재 ISO 8601 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="94ba9e6027f4009489d2ccee677e317b62f45cec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the current time in seconds since the Unix Epoch with millisecond-precision.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; Unix Epoch 이후 밀리 초 단위로 현재 시간을 초 단위로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6c75cb514e6cc027b56668e481bc8618f912a787" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the elements of an array from the second through two from the end (that is, not including the last two).</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 마지막부터 두 번째부터 두 번째까지 (즉, 마지막 두 개는 포함하지 않음) 배열의 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2261f0fd4a819426231b85dc70c2a8cac7c71c0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the first five squares.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 처음 다섯 사각형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6523e3ae9491319d244b75256cc6dee474801f06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the floor of -12.345.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; -12.345의 바닥을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4c90174b0406b33422dc83d8f8f8be2b62694156" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the floor of 12.345.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 12.345 층을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="21c60fe72b560b13e86d17920fa303c608d0f137" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the fourth, fifth and sixth youngest players. (The youngest player is at index 0, so those are elements 3&amp;ndash;5.)</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 네 번째, 다섯 번째 및 여섯 번째 막내 플레이어를 반환합니다. (가장 어린 플레이어는 인덱스 0에 있으므로 요소 3-5입니다.)</target>
        </trans-unit>
        <trans-unit id="4d791bacf8cb116089d7c78e0080c861a09ddc1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the highest number of points any user has ever scored. This returns the value of that &lt;code&gt;points&lt;/code&gt; field, not a document.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 사용자가 득점 한 최고 점수를 반환합니다. 문서가 아닌 해당 &lt;code&gt;points&lt;/code&gt; 필드 의 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="58fa45a0595a729289e6713c9664b9263d3dc14f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the length of a Unicode string.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 유니 코드 문자열의 길이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a283b2da374dfd1773e5dd0daa9d176beb1c49c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the length of an array.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 배열의 길이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="259593b48d37ffa9a0a7be1415445fc60298c64c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the maximum value in the list &lt;code&gt;[3, 5, 7]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;예 : &lt;/strong&gt; &lt;code&gt;[3, 5, 7]&lt;/code&gt; 목록에서 최대 값을 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="44c5cc3c1463ff6e538666926d596220ab03bbe9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the minimum value in the list &lt;code&gt;[3, 5, 7]&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;예 : &lt;/strong&gt; &lt;code&gt;[3, 5, 7]&lt;/code&gt; 목록에서 최소값을 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="867eead12eaf9797e2ca5f5293270dcd0faf12da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the number of documents in the table &lt;code&gt;posts&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 테이블 &lt;code&gt;posts&lt;/code&gt; 에있는 문서 수를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="009eb7bf79da186a517b4453c16c880674784f85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the players who have &lt;em&gt;not&lt;/em&gt; won games. To do this, use &lt;code&gt;hasFields&lt;/code&gt; with &lt;a href=&quot;../not/index&quot;&gt;not&lt;/a&gt;, wrapped with &lt;a href=&quot;../filter/index&quot;&gt;filter&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 게임에서 이기지 &lt;em&gt;않은&lt;/em&gt; 플레이어를 반환합니다 . 이렇게하려면 &lt;code&gt;hasFields&lt;/code&gt; 를 &lt;a href=&quot;../not/index&quot;&gt;not으로&lt;/a&gt; 사용 하고 &lt;a href=&quot;../filter/index&quot;&gt;filter로&lt;/a&gt; 감싸십시오 .</target>
        </trans-unit>
        <trans-unit id="8ffdae6bac174d28f081903d1674ceaa321fd592" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the players who have won games.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 게임에서이긴 플레이어를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="760e7b2c9af1e54fa24400226260b2079ede2cb4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the post submitted during the first 30 seconds of every minute.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 매분의 처음 30 초 동안 제출 된 게시물을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="72b942be6df8089dac354c5efafcf08d85690d15" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the smallest number of points any user has ever scored. This returns the value of that &lt;code&gt;points&lt;/code&gt; field, not a document.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 사용자가 득점 한 가장 적은 점수를 반환합니다. 문서가 아닌 해당 &lt;code&gt;points&lt;/code&gt; 필드 의 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7dc55a1e22bd7554a6e506b2ee0f20c3e22e3153" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the third through fifth characters of a string.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 문자열의 3 ~ 5자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="421170e20f7357508f6b09dd0e025576d0df2607" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the user who has scored the fewest points, adding in bonus points from a separate field using a function.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 함수를 사용하여 별도의 필드에서 보너스 포인트를 추가하여 가장 적은 점수를 얻은 사용자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="caf1cbe4851374244369da456f032cafadc6fe97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the user who has scored the fewest points, but add a default &lt;code&gt;null&lt;/code&gt; return value to prevent an error if no user has ever scored points.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 가장 적은 점수를 얻은 사용자를 반환하지만 점수를 얻은 사용자가없는 경우 오류를 방지하기 위해 기본 &lt;code&gt;null&lt;/code&gt; 반환 값을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9a352ca57f03751ce897ff17cf00a5c6bcfa80b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the user who has scored the fewest points.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 가장 적은 점수를 얻은 사용자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ca59390b8d2d26239efb9115dd36ec274093789a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the user who has scored the most points, adding in bonus points from a separate field using a function.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 함수를 사용하여 별도의 필드에서 보너스 포인트를 추가하여 가장 많은 점수를 얻은 사용자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="80d41bf116d7b00d1c253e51321dc0973c2484ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the user who has scored the most points, but add a default &lt;code&gt;null&lt;/code&gt; return value to prevent an error if no user has ever scored points.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 가장 많은 점수를 얻은 사용자를 반환하지만 점수를 얻은 사용자가없는 경우 오류를 방지하기 위해 기본 &lt;code&gt;null&lt;/code&gt; 반환 값을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="9757d2e6e49446a074d75ed6eebff33e052b6b3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the user who has scored the most points.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 가장 많은 점수를 얻은 사용자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e2e126373c1001aee4ccdc44229e0f3791fa09b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return the users born on the 24th of any month.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 매월 24 일에 태어난 사용자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5e87d7b09c36ce966755b302531318ea8208f94f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return today&amp;rsquo;s day of week.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 오늘 요일을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="18d521127d8e5ef3cc7ff9e753c6a3778f619536" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return whether all of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; evaluate to true.</source>
          <target state="translated">&lt;strong&gt;예 : &lt;/strong&gt; &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 모두 가 true로 평가 되는지 여부를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="10febe6c34ec38e1aff3ba9ec1eab6e04fdcb094" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return whether any of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; or &lt;code&gt;z&lt;/code&gt; evaluate to true.</source>
          <target state="translated">&lt;strong&gt;예 : &lt;/strong&gt; &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 또는 &lt;code&gt;z&lt;/code&gt; 가 true로 평가 되는지 여부를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ed4d0c322773cac73f4d144cc763f17308f3e37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return whether both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; evaluate to true.</source>
          <target state="translated">&lt;strong&gt;예 : &lt;/strong&gt; &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 모두 true 인지 평가합니다.</target>
        </trans-unit>
        <trans-unit id="e6ff14e5505f17d4eb8c5feb8d082ce0dfd68a6f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Return whether either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; evaluate to true.</source>
          <target state="translated">&lt;strong&gt;예 : &lt;/strong&gt; &lt;code&gt;a&lt;/code&gt; 또는 &lt;code&gt;b&lt;/code&gt; 가 true 인지 평가합니다.</target>
        </trans-unit>
        <trans-unit id="8dfe946f9993347138992ec45dffa31f2a91ab0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Rewrite the previous example with &lt;code&gt;getIntersecting&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;예 : &lt;/strong&gt; &lt;code&gt;getIntersecting&lt;/code&gt; 으로 이전 예를 다시 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="82dac3d61f4d464c79b7e34dd64955136009d8f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Round -12.345 to the nearest integer.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; -12.345를 가장 가까운 정수로 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="91ce5ae25de70118ef993895de7ab84458bd3369" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Round 12.345 to the nearest integer.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 12.345를 가장 가까운 정수로 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="41a4d4584a8b19bb9cd585aa96340e7511dd91cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Run a query on the connection &lt;code&gt;conn&lt;/code&gt; and log each row in the result to the console.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 연결 &lt;code&gt;conn&lt;/code&gt; 에서 쿼리를 실행 하고 결과의 각 행을 콘솔에 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="72d64a5af05c893657e37a2b8bbea51498568248" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Run a query on the connection &lt;code&gt;conn&lt;/code&gt; and retrieve all the rows in an array.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 실행 연결에 대한 쿼리 &lt;code&gt;conn&lt;/code&gt; 모두에게 배열의 행을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b95201d75aa3a85fbab1f90281c582628b6ce73" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Save an avatar image to a existing user record.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 아바타 이미지를 기존 사용자 레코드에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="dbe5976c3ce6158153abc094a62c6dcc0b1b2e8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Save the binary representation of the index:</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 인덱스의 이진 표현을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="dfdce19b25dbd19391f8151d039fb21b0f1bfc39" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Secondary index keys are not guaranteed to be unique so we cannot query via &lt;a href=&quot;../get/index&quot;&gt;get&lt;/a&gt; when using a secondary index.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 보조 인덱스 키는 고유하지 않으므로 보조 인덱스를 사용할 때는 &lt;a href=&quot;../get/index&quot;&gt;get을&lt;/a&gt; 통해 쿼리 할 수 ​​없습니다 .</target>
        </trans-unit>
        <trans-unit id="11895d6c0fb39e67f3ca602f1204b880ef83d4bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Secondary index keys are not guaranteed to be unique so we cannot query via &lt;a href=&quot;get/index&quot;&gt;get&lt;/a&gt; when using a secondary index.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 보조 인덱스 키는 고유하지 않으므로 보조 인덱스를 사용할 때는 &lt;a href=&quot;get/index&quot;&gt;get을&lt;/a&gt; 통해 쿼리 할 수 ​​없습니다 .</target>
        </trans-unit>
        <trans-unit id="38650ffc9b846ff5bfddce1ee1f1483d924799a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; See if a user&amp;rsquo;s &lt;code&gt;role&lt;/code&gt; field is not set to &lt;code&gt;administrator&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 사용자 &lt;code&gt;role&lt;/code&gt; 필드가 &lt;code&gt;administrator&lt;/code&gt; 로 설정되어 있지 않은지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="3251a70c9971e6e8cb5f26f5bee7e07c45b58c68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; See if a user&amp;rsquo;s &lt;code&gt;role&lt;/code&gt; field is set to &lt;code&gt;administrator&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 사용자의 &lt;code&gt;role&lt;/code&gt; 필드가 &lt;code&gt;administrator&lt;/code&gt; 로 설정되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="11d1055d3b75d9e8d04163337db75bc126cc2551" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; See if three variables contain equal values.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 세 개의 변수에 동일한 값이 포함되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2e129c48a29a87e203f0ab7ab63a3b978abc8eb2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; See if three variables do not contain equal values.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 세 개의 변수에 동일한 값이 포함되어 있지 않은지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="89e10181a3354243eb22f60df94e1ae712a4a261" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Select 3 random heroes.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 무작위 영웅 3 명을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="8ac7f07750bf035cd4d094183239ea021b2a9a2b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Select all documents where the &amp;lsquo;magazines&amp;rsquo; field is greater than 5 by running JavaScript on the server.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 서버에서 JavaScript를 실행하여 '잡지'필드가 5보다 큰 모든 문서를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="2ef751acd71b6de8b9a5913bfff0b75517e9c34a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Select and stratify 3 random heroes by belovedness.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 3 명의 무작위 영웅을 사랑으로 선택하고 계층화합니다.</target>
        </trans-unit>
        <trans-unit id="1cdc0007474651cf7a93f608e375a9beaa4908b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Select one random player and all their games.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 하나의 무작위 플레이어와 모든 게임을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="cba7f0bf4ebaa23a9f442901e96d6470ec3bfd7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Select the bronze medalist from the competitors.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 경쟁사에서 동메달을 선정하십시오.</target>
        </trans-unit>
        <trans-unit id="b29310dbc87586d30d1bbc7f78db602fa8d2774d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Select the last place competitor.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 마지막 장소 경쟁자를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="195a526bc178a35def2630e8146b587f2a3da6ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Select the second element in the array.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 배열에서 두 번째 요소를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="e699d6f86e8c1ca64af9c6426d09dfc766ba1793" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Send a note to every user with an ICQ number.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; ICQ 번호가있는 모든 사용자에게 메모를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="640f47a33f5ac87f924bff799452f784b061674e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Send an array to the server.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 서버로 어레이를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="10debf1928a6c384a2beacf3f2e20431fc67e9a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Set up your top-level namespace.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 최상위 네임 스페이스를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="d804d175c8ed5dc8317325ef0256be10da468d83" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Simple use</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 간단한 사용</target>
        </trans-unit>
        <trans-unit id="ce410fcc8e54638f1dba4931491401618c3b5b58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Simulate an &lt;a href=&quot;../eq_join/index&quot;&gt;eqJoin&lt;/a&gt; using &lt;code&gt;concatMap&lt;/code&gt;. (This is how ReQL joins are implemented internally.)</source>
          <target state="translated">&lt;strong&gt;예 : &lt;/strong&gt;&lt;a href=&quot;../eq_join/index&quot;&gt;concatMap을&lt;/a&gt; 사용하여 &lt;code&gt;concatMap&lt;/code&gt; 시뮬레이션 하십시오 . (ReQL 조인이 내부적으로 구현되는 방식입니다.)</target>
        </trans-unit>
        <trans-unit id="a4af3f8e5b07893e51544c6e90ade5f56f984aea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Since we don&amp;rsquo;t need it for this computation we&amp;rsquo;ll save bandwidth and leave out the list of IronMan&amp;rsquo;s romantic conquests.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 이 계산에 필요하지 않으므로 대역폭을 절약하고 IronMan의 낭만적 인 정복 목록을 생략합니다.</target>
        </trans-unit>
        <trans-unit id="420aaa9aad34417d15be481dcfd2cce3bfad254d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Specify the database to use for the query.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 조회에 사용할 데이터베이스를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="06746e0d33f893a9cf8fee465d4e107ecb0d911a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Split a string into characters.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 문자열을 문자로 나누십시오.</target>
        </trans-unit>
        <trans-unit id="9cd7a71036f6cc9c055f6cca84ea6ad2752fe9af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Split on whitespace at most once (i.e. get the first word).</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 공백을 최대 한 번만 분할합니다 ( &lt;strong&gt;예 :&lt;/strong&gt; 첫 단어를 얻음).</target>
        </trans-unit>
        <trans-unit id="9da6e654d9fb01fb3f1bceca1fe4c627955aad61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Split on whitespace.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 공백으로 분할</target>
        </trans-unit>
        <trans-unit id="d88947fbdc47899bff4020d11e34c7b03aedd845" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Split the entries in a CSV file, but only at most 3 times.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 항목을 CSV 파일로 분할하지만 최대 3 번만 분할합니다.</target>
        </trans-unit>
        <trans-unit id="218cc7fa0883d539013927dec037fe5a5cece7de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Split the entries in a CSV file.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 항목을 CSV 파일로 분할하십시오.</target>
        </trans-unit>
        <trans-unit id="1f8804fac24de266b0833d582f0de10fd34005a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Subscribe to a &lt;a href=&quot;../../../docs/changefeeds/javascript/index&quot;&gt;changefeed&lt;/a&gt; of teams ranked in the top 10.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 상위 10 개 팀 의 &lt;a href=&quot;../../../docs/changefeeds/javascript/index&quot;&gt;변경&lt;/a&gt; 피드를 구독 하십시오.</target>
        </trans-unit>
        <trans-unit id="a2daa7192126e2491b5d27da261468e286793fd3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Subscribe to the changes on a table.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 테이블의 변경 사항을 구독하십시오.</target>
        </trans-unit>
        <trans-unit id="9f5cd25bba94b3c82a1cfe5024e40709316249c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Sum the elements of three sequences.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 세 시퀀스의 요소를 합산하십시오.</target>
        </trans-unit>
        <trans-unit id="8169867db70df07a66f809e36d279b3cf816a95e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Suppose that each &lt;code&gt;post&lt;/code&gt; has a field &lt;code&gt;comments&lt;/code&gt; that is an array of comments.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 각 &lt;code&gt;post&lt;/code&gt; 에 주석 배열 인 필드 &lt;code&gt;comments&lt;/code&gt; 이 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="ffd33b0ace48ca18801a67415d01189b03729284" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Take different actions based on the result of a ReQL &lt;a href=&quot;../insert/index&quot;&gt;insert&lt;/a&gt; command.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; ReQL &lt;a href=&quot;../insert/index&quot;&gt;삽입&lt;/a&gt; 명령 의 결과에 따라 다른 조치를 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="1331c4c50e12499667a4cdbd70565b20bc0ab67a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Test if a player has scored 10 points or less.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 플레이어의 점수가 10 점 이하인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="f51818dcdf4f368c223908d0227b7c99aaef6933" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Test if a player has scored 10 points or more.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 플레이어가 10 점 이상을 득점했는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="20d338ca147db8bc301f37b24d2b68a9d9481f92" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Test if a player has scored less than 10 points.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 플레이어의 점수가 10 점 미만인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="b47cfc587ce4b73495c663a968322a38db3673ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Test if a player has scored more than 10 points.</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt; Test if a player has scored more than 10 points.</target>
        </trans-unit>
        <trans-unit id="b6faab4facd667a0ca45362d5e9ed50ab4292557" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Test if a specific player has won any games.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 특정 플레이어가 게임에서 이겼는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="25b295996b2a8bc49c2f435a8ce610f6f0561fd7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Test if variables are ordered from highest to lowest, with no values being equal to one another.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 변수가 서로 같은 값을 가지지 않고 가장 높은 순서에서 가장 낮은 순서로 정렬되는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="1715ee19387211b4fa08b8d07d4a02c36b8887c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Test if variables are ordered from highest to lowest.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 변수가 가장 높은 순서대로 정렬되어 있는지 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="efe14ffa71b768c70b24bdcb9aa8b4ded96468df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Test if variables are ordered from lowest to highest, with no values being equal to one another.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 변수가 같은 값을 가지지 않고 가장 낮은 순서에서 높은 순서로 정렬되었는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="b012b6a6b5ab60ec6b3e9d9ae7f3df676e8bf306" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Test if variables are ordered from lowest to highest.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 변수가 가장 낮은 순서에서 높은 순서로 정렬되어 있는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="44e2309d2ba18f5f27f8230ef54ff6e8ae9398e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Test the value of x.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; x의 값을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="0d47acaf83e71e8ab41fb3d6cf49405e0abfdf7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; The &lt;code&gt;default&lt;/code&gt; command can also be used to filter documents. Retrieve all our users who are not grown-ups or whose age is unknown (i.e., the field &lt;code&gt;age&lt;/code&gt; is missing or equals &lt;code&gt;null&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;예 : &lt;/strong&gt; &lt;code&gt;default&lt;/code&gt; 명령은 또한 필터 문서에 사용할 수 있습니다. 어른이 아니거나 나이를 알 수없는 모든 사용자를 검색합니다 (예 : 필드 &lt;code&gt;age&lt;/code&gt; 가 없거나 &lt;code&gt;null&lt;/code&gt; 과 같음 ).</target>
        </trans-unit>
        <trans-unit id="8e71d3b3935a410521806f24ebae64994cfaccaa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; The function form of &lt;code&gt;default&lt;/code&gt; receives the error message as its argument.</source>
          <target state="translated">&lt;strong&gt;예 : &lt;/strong&gt; &lt;code&gt;default&lt;/code&gt; 의 함수 형식은 오류 메시지를 인수로받습니다.</target>
        </trans-unit>
        <trans-unit id="dbcdf7dc6851e1a4dcde29d55ec6f3dd67355daa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; The nested syntax can quickly become overly verbose so there&amp;rsquo;s a shorthand for it.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 중첩 된 구문이 지나치게 장황하게 표현 될 수 있으므로 그 약어가 있습니다.</target>
        </trans-unit>
        <trans-unit id="718b9bdef9de93be8ee54b6b95f92d0f454a3031" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; The same as above, but using a secondary index on the &lt;code&gt;points&lt;/code&gt; field.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 위와 동일하지만 &lt;code&gt;points&lt;/code&gt; 필드 에 보조 인덱스를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="0a284e232a3a81c033f9cd8e1fc4eeaf8a59b018" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; To replace a nested object with another object you can use the literal keyword.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 중첩 된 객체를 다른 객체로 바꾸려면 리터럴 키워드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf6d4d7aba398752103b9197ce9633155c3c891a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Topics in a table of messages have a secondary index on them, and more than one message can have the same topic. What are the unique topics in the table?</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 메시지 테이블의 주제에는 보조 색인이 있으며 둘 이상의 메시지가 동일한 주제를 가질 수 있습니다. 표에서 고유 한 주제는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="37691ba2084cf7ed5121d3154fd01c19317d2912" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Types!</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 유형!</target>
        </trans-unit>
        <trans-unit id="6b8199a256d48977d4d0fd99a40b3c0039fb0ebf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Ungrouping grouped data.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 그룹화 된 데이터 그룹 해제</target>
        </trans-unit>
        <trans-unit id="a6ade042bf43a1ef4df87257f4fb875e29eb14ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Update Bob Smith&amp;rsquo;s cell phone number.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; Bob Smith의 휴대폰 번호를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="64524c007da5b7bbceec0f0137ae8d713d530acb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Update the birthdate of the user &amp;ldquo;John&amp;rdquo; to November 3rd, 1986 UTC.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 사용자 &quot;John&quot;의 생년월일을 1986 년 11 월 3 일 UTC로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="b2d167cdc02b7b2a6a194b4c5d303c3d2ca094fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Update the birthdate of the user &amp;ldquo;John&amp;rdquo; to November 3rd, 1986.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 사용자 &quot;John&quot;의 생년월일을 1986 년 11 월 3 일로 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="a4da5d2e7bf018e82b0db58e01d0b954535a0f46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Update the field &lt;code&gt;numComments&lt;/code&gt; with a random value between 0 and 100. This update cannot be proven deterministic because of &lt;code&gt;r.js&lt;/code&gt; (and in fact is not), so you must pass the &lt;code&gt;nonAtomic&lt;/code&gt; flag.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 0에서 100 사이의 임의의 값으로 &lt;code&gt;numComments&lt;/code&gt; 필드를 업데이트하십시오 .이 업데이트는 &lt;code&gt;r.js&lt;/code&gt; 로 인해 결정 론적으로 입증 될 수 없으며 실제로는 아닙니다 . &lt;code&gt;nonAtomic&lt;/code&gt; 플래그를 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3370023be2e9476cffd22b7ed74a8c011d40ad4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Update the field &lt;code&gt;numComments&lt;/code&gt; with the result of a sub-query. Because this update is not atomic, you must pass the &lt;code&gt;nonAtomic&lt;/code&gt; flag.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 하위 쿼리 결과로 &lt;code&gt;numComments&lt;/code&gt; 필드를 업데이트하십시오 . 이 업데이트는 원자 &lt;code&gt;nonAtomic&lt;/code&gt; 플래그를 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="67192cf5d68cb9d07ae913cb02de1c9cb942678a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Update the status of all posts to &lt;code&gt;published&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;예 : &lt;/strong&gt; &lt;code&gt;published&lt;/code&gt; 모든 게시물의 상태를 업데이트하십시오 .</target>
        </trans-unit>
        <trans-unit id="d99ffac823713982f6f2112232fc204039d89040" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Update the status of all the posts written by William.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; William이 작성한 모든 게시물의 상태를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="9c293ef26eb3ab3d6e8f05a08771ebec1db3858c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Update the status of the post with &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;published&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 업데이트와 이후의 상태 &lt;code&gt;id&lt;/code&gt; 의 &lt;code&gt;1&lt;/code&gt; 에 &lt;code&gt;published&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ead1e4ebff7ef086d570d1e86cb6fb4d3410fe61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Update the status of the post with &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;1&lt;/code&gt; using soft durability.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 부드러운 내구성을 사용하여 &lt;code&gt;id&lt;/code&gt; 가 &lt;code&gt;1&lt;/code&gt; 인 게시물의 상태를 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="63c7f4363d8a9b9bea7da2ede31fbd10df33782e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Update the time of John&amp;rsquo;s birth.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 요한의 출생 시간을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="8aae47a949f7985ec4286761724480241a0980f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Use &lt;a href=&quot;../../../docs/cookbook/javascript/index#filtering-based-on-nested-fields&quot;&gt;nested field&lt;/a&gt; syntax to sort on fields from subdocuments. (You can also create indexes on nested fields using this syntax with &lt;code&gt;indexCreate&lt;/code&gt;.)</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 하위 필드에서 필드를 정렬 하려면 &lt;a href=&quot;../../../docs/cookbook/javascript/index#filtering-based-on-nested-fields&quot;&gt;중첩 필드&lt;/a&gt; 구문을 사용하십시오 . &lt;code&gt;indexCreate&lt;/code&gt; 와 함께이 구문을 사용하여 중첩 필드에 색인을 작성할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e0004ada7525e6b6f1bfa0f075093f3a989ad36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Use &lt;a href=&quot;../args/index&quot;&gt;args&lt;/a&gt; with &lt;code&gt;add&lt;/code&gt; to sum multiple values.</source>
          <target state="translated">&lt;strong&gt;예 : &lt;/strong&gt; &lt;code&gt;add&lt;/code&gt; 와 함께 &lt;a href=&quot;../args/index&quot;&gt;args&lt;/a&gt; 를 사용 하여 여러 값을 합산 하십시오 .</target>
        </trans-unit>
        <trans-unit id="02680aee31b508322ae162a6928259e49d858402" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Use &lt;a href=&quot;../map/index&quot;&gt;map&lt;/a&gt; and &lt;a href=&quot;../sum/index&quot;&gt;sum&lt;/a&gt; to get the total points scored for each match.</source>
          <target state="translated">&lt;strong&gt;예 : &lt;/strong&gt;&lt;a href=&quot;../map/index&quot;&gt;map&lt;/a&gt; 과 &lt;a href=&quot;../sum/index&quot;&gt;sum&lt;/a&gt; 을 사용 하여 각 경기에 대해 총점을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="cee14ccacbc24f8cf2336500d50b39815820e14a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Use &lt;code&gt;contains&lt;/code&gt; with a predicate function to simulate an &lt;code&gt;or&lt;/code&gt;. Return the Marvel superheroes who live in Detroit, Chicago or Hoboken.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 사용은 &lt;code&gt;contains&lt;/code&gt; 시뮬레이션 술어 기능 &lt;code&gt;or&lt;/code&gt; . 디트로이트, 시카고 또는 호보 켄에 사는 마블 슈퍼 히어로를 다시 만나십시오.</target>
        </trans-unit>
        <trans-unit id="9f9c067a82f6756796155bf68284f694457df7c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Use &lt;code&gt;literal&lt;/code&gt; to remove a field from a document.</source>
          <target state="translated">&lt;strong&gt;예 : &lt;/strong&gt; &lt;code&gt;literal&lt;/code&gt; 을 사용 하여 문서에서 필드를 제거 하십시오 .</target>
        </trans-unit>
        <trans-unit id="faa11442c7ff04bd4adf15402fb6cc3943811894" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Use &lt;code&gt;merge&lt;/code&gt; to join each blog post with its comments.</source>
          <target state="translated">&lt;strong&gt;예 : &lt;/strong&gt; &lt;code&gt;merge&lt;/code&gt; 을 사용 하여 각 블로그 게시물을 의견과 결합 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c523efa749a8ec36defddfc3f0a11b48132a401c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Use a function instead of a field to join on a more complicated expression. Suppose the players have lists of favorite games ranked in order in a field such as &lt;code&gt;favorites: [3, 2, 1]&lt;/code&gt;. Get a list of players and their top favorite:</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 필드 대신 함수를 사용하여보다 복잡한 표현식에 조인하십시오. 플레이어가 즐겨 찾기와 같은 필드에서 순서대로 순위가 매겨진 즐겨 찾기 게임 목록이 있다고 가정합니다 &lt;code&gt;favorites: [3, 2, 1]&lt;/code&gt; . 플레이어 및 가장 좋아하는 선수 목록을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="5284ff693016d6aaf2fc5a38372ff675711c76ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Use a nested key as the join field. Suppose the documents in the players table were structured like this:</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 조인 필드로 중첩 키를 사용하십시오. players 테이블의 문서가 다음과 같이 구성되었다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="0b3958e422754d7fdf0c13928ca3f3bfd44e9743" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Use a secondary index on the right table rather than the primary key. If players have a secondary index on their cities, we can get a list of arenas with players in the same area.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 기본 키 대신 오른쪽 테이블에서 보조 인덱스를 사용하십시오. 플레이어가 도시에 보조 인덱스를 가지고 있다면 같은 지역에있는 플레이어와 함께 경기장 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c65ae19787c7981313601d512d6599a9685462bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Use the &lt;a href=&quot;../../../docs/nested-fields/javascript/index&quot;&gt;nested field syntax&lt;/a&gt; to get a list of users with cell phone numbers in their contacts.</source>
          <target state="translated">&lt;strong&gt;예 : &lt;/strong&gt;&lt;a href=&quot;../../../docs/nested-fields/javascript/index&quot;&gt;중첩 필드 구문&lt;/a&gt; 을 사용하여 연락처에 휴대폰 번호가있는 사용자 목록을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="63c2cc8fb2a49b7168572eb51fee24aea55a7a94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Using a cursor</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 커서 사용</target>
        </trans-unit>
        <trans-unit id="f08cb20308a0500b23256ad2b7c63b29d2b4f7a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Wait for all indexes on the table &lt;code&gt;test&lt;/code&gt; to be ready:</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 테이블 &lt;code&gt;test&lt;/code&gt; 모든 인덱스 가 준비 될 때까지 기다리십시오 .</target>
        </trans-unit>
        <trans-unit id="4bc3a39d9eb13fd43624cd1e19dfbd25437d7196" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Wait for the index &lt;code&gt;timestamp&lt;/code&gt; to be ready:</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 인덱스 &lt;code&gt;timestamp&lt;/code&gt; 가 준비 될 때까지 기다 립니다.</target>
        </trans-unit>
        <trans-unit id="3e070aedb3426156fc84d324d356ee2f27d21ffd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Wait on a table to be ready.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 테이블이 준비 될 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="ff9f926b0b901d0626582954a0e3f6190cf04529" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; We have previously run queries with the &lt;code&gt;noreply&lt;/code&gt; argument set to &lt;code&gt;true&lt;/code&gt;. Now wait until the server has processed them.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 이전에는 &lt;code&gt;noreply&lt;/code&gt; 인수가 &lt;code&gt;true&lt;/code&gt; 로 설정된 쿼리를 실행했습니다 . 이제 서버가 처리 할 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="b23ab4a2e75afedbe50e2feca3d56193afaea16a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; We just need information about IronMan&amp;rsquo;s reactor and not the rest of the document.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 나머지 문서가 아닌 IronMan 원자로에 대한 정보 만 있으면됩니다.</target>
        </trans-unit>
        <trans-unit id="14693ac3681a4db7639771fbb88c68159cf63b59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; What is each player&amp;rsquo;s best game?</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 각 플레이어의 최고의 게임은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="b3b5572fec19628b767a7fc66b7065ecc2018a30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; What is each player&amp;rsquo;s highest even and odd score?</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 각 플레이어의 최고 짝수 및 홀수 점수는 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="e9d8c7bf62886cbc609c79144dfd30cbc128ccb7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; What is the maximum number of points scored by each player for each game type?</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 각 게임 유형별로 각 플레이어가 득점 한 최대 점수는 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="bba67aaaf70b6b7c70041648927cb7a75984da16" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; What is the maximum number of points scored by each player in free games?</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 무료 게임에서 각 플레이어의 최대 점수는 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="2ad5e9aa9e1a60f26bb74526650715ec4ccc2fd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; What is the maximum number of points scored by each player, with the highest scorers first?</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 각 플레이어가 득점 한 최대 점수는 몇 점입니까?</target>
        </trans-unit>
        <trans-unit id="f76e7c8748287621b899297111fffa532fcee254" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; What is the maximum number of points scored by each player?</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 각 플레이어의 최대 점수는 몇 점입니까?</target>
        </trans-unit>
        <trans-unit id="da9d7ad491267fe991c3a0f49929545c0a221806" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; What is the maximum number of points scored by game type?</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 게임 유형별 최대 점수는 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="4cf30cefa069e8bcbfccc3c653ce93fd6fdc0023" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; What was Iron Man&amp;rsquo;s first appearance in a comic?</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 만화에서 Iron Man의 첫 등장은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="da5698d921800a6a43d46d276df76dcd4b9af2bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; What&amp;rsquo;s 3 + 5 + 7?</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 3 + 5 + 7이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="a9113891512f385f058c701ca24aa5b167e2d456" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; What&amp;rsquo;s the average number of points scored in a game, counting bonus points?</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 보너스 점수를 계산하여 게임에서 득점 한 평균 점수는 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="4342caa4df0c67c6cbbc105dd20437f6fa527ebd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; What&amp;rsquo;s the average number of points scored in a game?</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 게임에서 득점 한 평균 점수는 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="4ab1381e62c47111891102c67c66e3eed5dde2f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; What&amp;rsquo;s the average number of points scored in a game? (But return &lt;code&gt;null&lt;/code&gt; instead of raising an error if there are no games where points have been scored.)</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 게임에서 득점 한 평균 점수는 얼마입니까? (하지만 점수를 얻은 게임이 없으면 오류를 발생시키는 대신 &lt;code&gt;null&lt;/code&gt; 을 반환 합니다.)</target>
        </trans-unit>
        <trans-unit id="47105b54e3678d2403a237aa448a9d9e17ce94e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; What&amp;rsquo;s the average of 3, 5, and 7?</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 평균 3, 5 및 7은 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="0e1cf68609089dfd0da5af1bb38bbd4117b0b2bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Which of the locations in a list of parks include &lt;code&gt;circle1&lt;/code&gt;?</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 공원 목록에서 &lt;code&gt;circle1&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="3155e7f7fcdfc84b19cdd98c07e69e0eaae69930" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Which of the locations in a list of parks intersect &lt;code&gt;circle1&lt;/code&gt;?</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 공원 목록의 어느 위치가 &lt;code&gt;circle1&lt;/code&gt; 과 교차 합니까?</target>
        </trans-unit>
        <trans-unit id="319224d9721f40c33bb5ca04cdf537f9f765ebdc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Which unique villains have been vanquished by Marvel heroes?</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; Marvel의 영웅들은 어떤 독특한 악당을 정복 했습니까?</target>
        </trans-unit>
        <trans-unit id="6dda779780e18c4c58f4feb486d08ac44290a3c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; With &lt;code&gt;next&lt;/code&gt;, not all results have to be retrieved from a cursor &amp;ndash; to stop retrieving results, break out of the recursive function. For example, this recursive function will stop retrieving results when the &lt;code&gt;checkRow&lt;/code&gt; function returns true:</source>
          <target state="translated">&lt;strong&gt;예 : &lt;/strong&gt; &lt;code&gt;next&lt;/code&gt; 를 사용하면 커서에서 모든 결과를 검색 할 필요는 없습니다. 결과 검색을 중지하려면 재귀 함수를 해제하십시오. 예를 들어,이 재귀 함수는 &lt;code&gt;checkRow&lt;/code&gt; 함수가 true를 반환 할 때 결과 검색을 중지 합니다.</target>
        </trans-unit>
        <trans-unit id="37ec041edb9e5e31e3f5708d6c8ba625a531cf3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Without an index argument, we default to the primary index. While &lt;code&gt;get&lt;/code&gt; will either return the document or &lt;code&gt;null&lt;/code&gt; when no document with such a primary key value exists, this will return either a one or zero length stream.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 인덱스 인수가 없으면 기본 인덱스가 기본값입니다. &lt;code&gt;get&lt;/code&gt; 은 문서를 반환하거나 기본 키 값이있는 문서가 없으면 &lt;code&gt;null&lt;/code&gt; 을 반환 하지만 길이가 1 또는 0 인 스트림을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="37bd07f7b464d50fae88fd871f06c53f271d7a2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; Without their prized weapons, our enemies will quickly be vanquished.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 소중한 무기가 없으면 적들이 빠르게 정복됩니다.</target>
        </trans-unit>
        <trans-unit id="8b07b6214e906fb92f5e3efd4077bd1bcb4b95ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; You can efficiently order data on arbitrary expressions using indexes.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 인덱스를 사용하여 임의의 표현식에서 데이터를 효율적으로 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86fda1cd202d3a4ab248129dbe004c214d7ab4a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; You can efficiently order using multiple fields by using a &lt;a href=&quot;http://www.rethinkdb.com/docs/secondary-indexes/javascript/&quot;&gt;compound index&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;예 : &lt;/strong&gt;&lt;a href=&quot;http://www.rethinkdb.com/docs/secondary-indexes/javascript/&quot;&gt;복합 색인&lt;/a&gt; 을 사용하여 여러 필드를 사용하여 효율적으로 주문할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09bd072bba555522842d19349b8c660695a33e7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; You can get multiple documents in a single call to &lt;code&gt;getAll&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;예 : &lt;/strong&gt; &lt;code&gt;getAll&lt;/code&gt; 에 대한 단일 호출로 여러 문서를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4731728c17b61246f1703408173bfd3f3d342b6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; You can get multiple documents in a single call to &lt;code&gt;get_all&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;예 : &lt;/strong&gt; &lt;code&gt;get_all&lt;/code&gt; 에 대한 단일 호출로 여러 문서를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6141919a5508731f58f54550166f1a2cc61cd096" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; You can retrieve all the elements of a cursor with the &lt;code&gt;next&lt;/code&gt; command using recursion and promises.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 재귀와 약속을 사용하여 &lt;code&gt;next&lt;/code&gt; 명령 으로 커서의 모든 요소를 ​​검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ae4c0feadf1db97584879e001c84d91a9b2ca93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; You can retrieve all the elements of a cursor with the &lt;code&gt;next&lt;/code&gt; command using recursion.</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 재귀를 사용하여 &lt;code&gt;next&lt;/code&gt; 명령 으로 커서의 모든 요소를 ​​검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="69371b9d42ac69205db482caf0a43438b0f4eac6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; You can use &lt;a href=&quot;../args/index&quot;&gt;args&lt;/a&gt; with &lt;code&gt;getAll&lt;/code&gt; to retrieve multiple documents whose keys are in a list. This uses &lt;code&gt;getAll&lt;/code&gt; to get a list of female superheroes, coerces that to an array, and then gets a list of villains who have those superheroes as enemies.</source>
          <target state="translated">&lt;strong&gt;예 : &lt;/strong&gt; &lt;code&gt;getAll&lt;/code&gt; 과 함께 &lt;a href=&quot;../args/index&quot;&gt;args&lt;/a&gt; 를 사용 하여 키가 목록에있는 여러 문서를 검색 할 수 있습니다 . &lt;code&gt;getAll&lt;/code&gt; 을 사용 하여 여성 슈퍼 히어로 목록을 가져 와서 배열로 강제 변환 한 다음 해당 슈퍼 히어로를 적으로 가진 악당 목록을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4812a471ab0beaaba739a269a6594a79ac9c69e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt; You may also specify a timeout in seconds (defaults to 5).</source>
          <target state="translated">&lt;strong&gt;예 :&lt;/strong&gt; 시간 초과를 초 단위로 지정할 수도 있습니다 (기본값은 5).</target>
        </trans-unit>
        <trans-unit id="582e89736b5a0d3d31ffabd436d58516b5b9c086" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Follow&lt;/strong&gt;&lt;a href=&quot;http://twitter.com/rethinkdb&quot;&gt;@rethinkdb&lt;/a&gt; on Twitter</source>
          <target state="translated">&lt;strong&gt;따라 &lt;/strong&gt;&lt;a href=&quot;http://twitter.com/rethinkdb&quot;&gt;@rethinkdb&lt;/a&gt; 트위터에</target>
        </trans-unit>
        <trans-unit id="9277acb0da1a5aed7b906359011231d8f29464ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Functions&lt;/strong&gt; can be passed as parameters to certain ReQL commands.</source>
          <target state="translated">&lt;strong&gt;함수&lt;/strong&gt; 는 특정 ReQL 명령에 매개 변수로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1882eaaaca15e8001a5ceb52a50715af2421db98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Geometry data types&lt;/strong&gt; for geospatial support, including points, lines, and polygons. (See below for more detail.)</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;점, 선 및 다각형을 포함한 지형 공간 지원을위한 &lt;strong&gt;형상 데이터 유형&lt;/strong&gt; . (자세한 내용은 아래를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="75a68daa64bf5ae6912fd5581a48b366f4a15916" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Grouped data&lt;/strong&gt; is created by the &lt;code&gt;group&lt;/code&gt; command, which partitions a stream into multiple groups based on specified fields or functions. ReQL commands called on &lt;code&gt;GROUPED_DATA&lt;/code&gt; operate on each group individually. For more details, read the &lt;a href=&quot;../../api/javascript/group/index&quot;&gt;group&lt;/a&gt; documentation. Depending on the input to &lt;code&gt;group&lt;/code&gt;, grouped data may have the type of &lt;code&gt;GROUPED_STREAM&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;그룹화 된 데이터&lt;/strong&gt; 는 지정된 필드 또는 기능을 기반으로 스트림을 여러 그룹으로 분할하는 &lt;code&gt;group&lt;/code&gt; 명령으로 작성됩니다 . 호출 ReQL 명령 &lt;code&gt;GROUPED_DATA&lt;/code&gt; 는 개별적으로 각 그룹에서 작동합니다. 자세한 내용은 &lt;a href=&quot;../../api/javascript/group/index&quot;&gt;그룹&lt;/a&gt; 설명서를 읽으십시오 . &lt;code&gt;group&lt;/code&gt; 에 대한 입력에 따라 그룹화 된 데이터의 유형은 &lt;code&gt;GROUPED_STREAM&lt;/code&gt; 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76e85e408bd4fc987cfab204a895eabde5cf87a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Haven&amp;rsquo;t installed the server yet?&lt;/strong&gt;&lt;a href=&quot;https://rethinkdb.com/install&quot;&gt;Go do that&lt;/a&gt; first!</source>
          <target state="translated">&lt;strong&gt;서버를 아직 설치하지 않았습니까? &lt;/strong&gt;&lt;a href=&quot;https://rethinkdb.com/install&quot;&gt;이동은 할&lt;/a&gt; 첫 번째!</target>
        </trans-unit>
        <trans-unit id="89b1eb2283554043dd4b75edce9059b23708f204" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Having trouble accessing the web interface?&lt;/strong&gt; Try restarting both of your RethinkDB instances with an additional &lt;code&gt;--bind all&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;strong&gt;웹 인터페이스에 액세스하는 데 문제가 있습니까? &lt;/strong&gt;추가 &lt;code&gt;--bind all&lt;/code&gt; 매개 변수를 사용하여 두 RethinkDB 인스턴스를 다시 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="850231f73eda7760f21e97809f4c63101493a0e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Healthy:&lt;/strong&gt; more than half of the shard&amp;rsquo;s voting replicas are still available.</source>
          <target state="translated">&lt;strong&gt;건강 :&lt;/strong&gt; 샤드 투표 복제본의 절반 이상이 여전히 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="eaab2b71046d35912ecd620e5145070608473a4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Help us&lt;/strong&gt; improve the docs &lt;a href=&quot;https://github.com/rethinkdb/docs/blob/master/api/javascript/index.md&quot;&gt;by editing&lt;/a&gt; this document</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;이 문서 &lt;a href=&quot;https://github.com/rethinkdb/docs/blob/master/api/javascript/index.md&quot;&gt;를 편집&lt;/a&gt; 하여 문서 개선에 &lt;strong&gt;도움&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c998ba2aac43caa50189333a1e52b627ac4afa7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How many dimensions are supported?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;몇 개의 차원이 지원됩니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="313138c1d19dde722c53d37f637f59dcd26ea678" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you are using Firefox&lt;/strong&gt;, go to &lt;em&gt;Edit &amp;gt; Preferences&lt;/em&gt;. Then click on &lt;em&gt;Advanced &amp;gt; Network &amp;gt; Settings&lt;/em&gt; and create a manual proxy configuration with these settings:</source>
          <target state="translated">&lt;strong&gt;Firefox를 사용하는 경우 &lt;/strong&gt;&lt;em&gt;편집&amp;gt; 기본 설정으로&lt;/em&gt; 이동 &lt;em&gt;하십시오&lt;/em&gt; . 그런 다음 &lt;em&gt;고급&amp;gt; 네트워크&amp;gt; 설정을&lt;/em&gt; 클릭하고 다음 &lt;em&gt;설정&lt;/em&gt; 으로 수동 프록시 구성을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="e98297d6e50d39647518b9b0a3af6009fb0bd70e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you&amp;rsquo;re using Chrome&lt;/strong&gt;, go to &lt;em&gt;Settings &amp;gt; Advanced settings &amp;gt; Network &amp;gt; Change proxy settings&lt;/em&gt;, and set the &lt;em&gt;Network proxy&lt;/em&gt; option to manual mode with the following settings:</source>
          <target state="translated">&lt;strong&gt;당신이 크롬을 사용하는 경우&lt;/strong&gt; , 이동 &lt;em&gt;설정&amp;gt; 고급 설정&amp;gt; 네트워크&amp;gt; 변경 프록시 설정&lt;/em&gt; 하고, 설정 한 &lt;em&gt;네트워크 프록시&lt;/em&gt; 다음 설정을 수동 모드 옵션 :</target>
        </trans-unit>
        <trans-unit id="9d441a1e1de41126f40bb234631a032fee068e5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important!&lt;/strong&gt; In case you found vulnerability or security issue in one of the drivers or the database, please contact us via e-mail at &lt;a href=&quot;mailto:security@rethinkdb.com&quot;&gt;security@rethinkdb.com&lt;/a&gt;. Please do &lt;strong&gt;not&lt;/strong&gt; use this channel for support.</source>
          <target state="translated">&lt;strong&gt;중대한! &lt;/strong&gt;경우 당신은 드라이버 나 데이터베이스 중 하나의 취약점이나 보안 문제를 발견에서 우리를 통해 전자 메일에 문의하시기 바랍니다 &lt;a href=&quot;mailto:security@rethinkdb.com&quot;&gt;security@rethinkdb.com&lt;/a&gt; . 지원을 위해이 채널을 사용 하지 &lt;strong&gt;마십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="84d9e69077e1858f2b55a431d2d0d49c4d17f3b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important!&lt;/strong&gt; Not using a proxy can lead to exploits. Make sure you set up proxy before start using RethinkDB in production. Use one of the following two methods to enable secure access.</source>
          <target state="translated">&lt;strong&gt;중대한! &lt;/strong&gt;프록시를 사용하지 않으면 악용 될 수 있습니다. 프로덕션에서 RethinkDB를 사용하기 전에 프록시를 설정했는지 확인하세요. 다음 두 가지 방법 중 하나를 사용하여 보안 액세스를 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="755e003c47b0e8d2815aca2f4d2c129a7e6ba79d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Increase concurrency.&lt;/strong&gt; Instead of having a single thread inserting data in a loop, create multiple threads with multiple connections. This will allow parallelization of insert queries without spending most of the time waiting on disk acknowledgement.</source>
          <target state="translated">&lt;strong&gt;동시성을 높입니다. &lt;/strong&gt;단일 스레드가 데이터를 루프에 삽입하는 대신 여러 연결로 여러 스레드를 작성하십시오. 이를 통해 디스크 확인을 기다리는 데 대부분의 시간을 소비하지 않고 삽입 쿼리를 병렬화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4335550f0d70230d87e2323f639beb09179787c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Keep in mind&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;명심하십시오&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="f03670d209f2229a3e62fa246f117916dd8bc789" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lines:&lt;/strong&gt; A sequence of two or more coordinate pairs</source>
          <target state="translated">&lt;strong&gt;라인 :&lt;/strong&gt; 둘 이상의 좌표 쌍의 시퀀스</target>
        </trans-unit>
        <trans-unit id="ac908ab106c200de13e52442805331feafe41a54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lines&lt;/strong&gt; are a sequence of two or more points, denoted by either point objects or coordinate pairs.</source>
          <target state="translated">&lt;strong&gt;선&lt;/strong&gt; 은 점 개체 또는 좌표 쌍으로 표시되는 두 개 이상의 점의 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="dd0d0643572ce6720c6f6e50ce31fe60c1f9abc0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Looking for another stack?&lt;/strong&gt; We will try to add as many examples as we can. If you have written a cool app and want us to showcase it, &lt;a href=&quot;https://rethinkdb.com/community&quot;&gt;let us know&lt;/a&gt;!</source>
          <target state="translated">&lt;strong&gt;다른 스택을 찾고 계십니까? &lt;/strong&gt;우리는 가능한 많은 예제를 추가하려고 노력할 것입니다. 멋진 앱을 작성하고 우리가 그것을 보여주고 싶다면 &lt;a href=&quot;https://rethinkdb.com/community&quot;&gt;알려주세요&lt;/a&gt; !</target>
        </trans-unit>
        <trans-unit id="3667905c4375aca6d7dbdd5cbb39c26f4056d32b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Looking for documentation for a community driver?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;커뮤니티 드라이버에 대한 설명서를 찾고 있습니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bffedcc0434ccf563854ab85205c9e18c5f9e859" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Minval&lt;/strong&gt; and &lt;strong&gt;maxval&lt;/strong&gt; are used with some commands such as &lt;code&gt;between&lt;/code&gt; to specify absolute lower and upper bounds (e.g., &lt;code&gt;between(r.minval, 1000)&lt;/code&gt; would return all documents in a table whose primary key is less than 1000).</source>
          <target state="translated">&lt;strong&gt;Minval&lt;/strong&gt; 과 &lt;strong&gt;maxval&lt;/strong&gt; 은 절대 하한과 상한을 지정하기 위해 &lt;code&gt;between&lt;/code&gt; (예 : &lt;code&gt;between(r.minval, 1000)&lt;/code&gt; 가 기본 키가 1000보다 작은 테이블의 모든 문서를 반환 함 ) 와 같은 일부 명령과 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0e1e5e583afb688dfd6d1b1d8e5a47ef29a61e7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Multi indexes&lt;/strong&gt; based on arrays of values.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;값 배열을 기반으로하는 &lt;strong&gt;다중 인덱스&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1583305dd110c8c2317b13eb038b04de8e77866b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nested Fields&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;중첩 된 필드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="244bade3400aff85996f44135b1ccfe2d228b1d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; As of version 2.3, only the &lt;code&gt;admin&lt;/code&gt; user can access system tables. Read &lt;a href=&quot;../permissions-and-accounts/index&quot;&gt;Permissions and user accounts&lt;/a&gt; for more details on user accounts and permissions.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 버전 2.3부터는 &lt;code&gt;admin&lt;/code&gt; 만 시스템 테이블에 액세스 할 수 있습니다. 사용자 계정 및 권한에 대한 자세한 내용은 &lt;a href=&quot;../permissions-and-accounts/index&quot;&gt;권한 및 사용자 계정&lt;/a&gt; 을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="569b17e36ed719f7abbfbea4745a1968a78ad29c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Avoid using keys matching the regular expression &lt;code&gt;^\$reql_.+\$$&lt;/code&gt; in your objects. RethinkDB considers those to be reserved keywords.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 개체에서 정규식 &lt;code&gt;^\$reql_.+\$$&lt;/code&gt; 와 일치하는 키를 사용하지 마십시오 . RethinkDB는 이러한 키워드를 예약 키워드로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="4f6754a401d9f9264dd03e6f8ba153854c485219" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Changefeeds ignore the &lt;code&gt;read_mode&lt;/code&gt; flag to &lt;code&gt;run&lt;/code&gt;, and always behave as if it is set to &lt;code&gt;single&lt;/code&gt; (i.e., the values they return are in memory on the primary replica, but have not necessarily been written to disk yet). For more details read &lt;a href=&quot;../../../docs/consistency/index&quot;&gt;Consistency guarantees&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; Changefeeds는 무시 &lt;code&gt;read_mode&lt;/code&gt; 의 에 플래그를 &lt;code&gt;run&lt;/code&gt; 하고, 항상로 설정 한 것처럼 작동 &lt;code&gt;single&lt;/code&gt; (즉, 그들은 반환 값이 주 복제본에 메모리에 있지만 반드시 아직 디스크에 기록되지 않은). 자세한 내용은 &lt;a href=&quot;../../../docs/consistency/index&quot;&gt;일관성 보증을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1320d8ab058485166cf05adf65c5eeb13dd6e96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Changefeeds ignore the &lt;code&gt;read_mode&lt;/code&gt; flag to &lt;code&gt;run&lt;/code&gt;, and always behave as if it is set to &lt;code&gt;single&lt;/code&gt; (i.e., the values they return are in memory on the primary replica, but have not necessarily been written to disk yet). For more details read &lt;a href=&quot;../../consistency/index&quot;&gt;Consistency guarantees&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; Changefeeds는 무시 &lt;code&gt;read_mode&lt;/code&gt; 의 에 플래그를 &lt;code&gt;run&lt;/code&gt; 하고, 항상로 설정 한 것처럼 작동 &lt;code&gt;single&lt;/code&gt; (즉, 그들은 반환 값이 주 복제본에 메모리에 있지만 반드시 아직 디스크에 기록되지 않은). 자세한 내용은 &lt;a href=&quot;../../consistency/index&quot;&gt;일관성 보증을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b88fe8dfc2a278cebcaa8eacf3be37012f58756" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For all accounts other than the special, system-defined &lt;code&gt;admin&lt;/code&gt; account, permissions that are not explicitly set in any scope will effectively be &lt;code&gt;false&lt;/code&gt;. When you create a new user account by inserting a record into the &lt;a href=&quot;../../../docs/system-tables/index#users&quot;&gt;system table&lt;/a&gt;, that account will have &lt;em&gt;no&lt;/em&gt; permissions until they are explicitly granted.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 특별한 시스템 정의 &lt;code&gt;admin&lt;/code&gt; 계정 이외의 모든 계정의 경우 어떤 범위에서도 명시 적으로 설정되지 않은 권한은 사실상 &lt;code&gt;false&lt;/code&gt; 입니다. &lt;a href=&quot;../../../docs/system-tables/index#users&quot;&gt;시스템 테이블에&lt;/a&gt; 레코드를 삽입하여 새 사용자 계정을 작성하면 해당 계정 은 명시 적으로 부여 될 때까지 권한 이 &lt;em&gt;없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="29e4d961e6a25ff9dbe4a9ffcf925dd16829dbe9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; It is possible to optimize the handshake by sending message #3 immediately after #1 without waiting for the server response, and read messages #2 and #4 afterward, handling them as appropriate.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 서버 응답을 기다리지 않고 # 1 직후에 메시지 # 3을 보내 핸드 셰이크를 최적화하고 나중에 메시지 # 2와 # 4를 읽고 적절하게 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="8f1fb502ea561a6db94ecf4369bfad33e255f0bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Only alphanumeric characters and underscores are valid for the table name.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 테이블 이름에는 영숫자와 밑줄 만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="1899eaea8de5492bea668ebfb53635d9a61a5286" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; RethinkDB uses byte-wise ordering for &lt;code&gt;orderBy&lt;/code&gt; and does not support Unicode collations; non-ASCII characters will be sorted by UTF-8 codepoint. For more information on RethinkDB&amp;rsquo;s sorting order, read the section in &lt;a href=&quot;../../../docs/data-types/index#sorting-order&quot;&gt;ReQL data types&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; RethinkDB는 &lt;code&gt;orderBy&lt;/code&gt; 에 바이트 단위 순서를 사용하며 유니 코드 데이터 정렬을 지원하지 않습니다. 비 ASCII 문자는 UTF-8 코드 포인트로 정렬됩니다. RethinkDB의 정렬 순서에 대한 자세한 정보는 &lt;a href=&quot;../../../docs/data-types/index#sorting-order&quot;&gt;ReQL 데이터 유형&lt;/a&gt; 섹션을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="25360c3b3a946bc784f19c1a206e9013bf5d69b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; SHL and SAL are the same, and differentiation only happens because SAR and SHR (right shifting) has differences in their implementation.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; SHL과 SAL은 동일하며 SAR과 SHR (오른쪽 이동)의 구현에 차이가 있기 때문에 차이가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="99248b40602a8453ef40be4b7c16d57eea666649" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The &lt;code&gt;dump&lt;/code&gt; and &lt;code&gt;restore&lt;/code&gt; commands require the &lt;a href=&quot;https://rethinkdb.com/docs/install-drivers/python/&quot;&gt;Python driver&lt;/a&gt; to be installed. Don&amp;rsquo;t upgrade the Python driver until &lt;em&gt;after&lt;/em&gt; you&amp;rsquo;ve dumped the data!</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;dump&lt;/code&gt; 및 &lt;code&gt;restore&lt;/code&gt; 명령은 필요 &lt;a href=&quot;https://rethinkdb.com/docs/install-drivers/python/&quot;&gt;파이썬 드라이버를&lt;/a&gt; 설치해야합니다. 때까지 파이썬 드라이버를 업그레이드하지 마십시오 &lt;em&gt;후&lt;/em&gt; 이 데이터를 덤프했습니다!</target>
        </trans-unit>
        <trans-unit id="f3418c9912d71cc04e979ee036a23d1e24b9c64d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The &lt;code&gt;dump&lt;/code&gt; command saves database and table contents and metadata, but does &lt;strong&gt;not&lt;/strong&gt; save cluster configuration data.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;dump&lt;/code&gt; 명령은 데이터베이스와 테이블 내용과 메타 데이터를 저장하지만 수행 &lt;strong&gt;하지&lt;/strong&gt; 클러스터 구성 데이터를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="5f57398017c203dceb6642f54fec0d0233b50066" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The &lt;code&gt;table&lt;/code&gt; and &lt;code&gt;database&lt;/code&gt; fields will be automatically filled in when inserting into &lt;code&gt;permissions&lt;/code&gt;, based on how many items are in the &lt;code&gt;id&lt;/code&gt; list.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;table&lt;/code&gt; 과 &lt;code&gt;database&lt;/code&gt; 필드가 자동으로 삽입 할 때에 채워집니다 &lt;code&gt;permissions&lt;/code&gt; 에 얼마나 많은 항목에 따라, &lt;code&gt;id&lt;/code&gt; 목록입니다.</target>
        </trans-unit>
        <trans-unit id="8d749834123aff747f5e70979ac14a076f6ced68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The binary object type is meant for data that cannot be reliably stored as UTF-8 strings, such as uploaded files. If you&amp;rsquo;re working with data that &lt;em&gt;can&lt;/em&gt; be stored as strings, it&amp;rsquo;s usually easier to stick to the string data type.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이진 개체 유형은 업로드 된 파일과 같이 UTF-8 문자열로 안정적으로 저장할 수없는 데이터를위한 것입니다. 문자열로 저장할 &lt;em&gt;수&lt;/em&gt; 있는 데이터로 작업하는 경우 일반적으로 문자열 데이터 유형을 고수하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="3825e4818391770a89530ac09cbf8da7e85117c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The canonical way to retrieve all the results is to use &lt;a href=&quot;../each/index&quot;&gt;each&lt;/a&gt; or &lt;a href=&quot;../to_array/index&quot;&gt;toArray&lt;/a&gt;. The &lt;code&gt;next&lt;/code&gt; command should be used only when you may not retrieve all the elements of a cursor or want to delay some operations.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 모든 결과를 검색하는 정식 방법은 &lt;a href=&quot;../each/index&quot;&gt;each&lt;/a&gt; 또는 &lt;a href=&quot;../to_array/index&quot;&gt;toArray&lt;/a&gt; 를 사용 하는 것 입니다. &lt;code&gt;next&lt;/code&gt; 은 커서의 모든 요소를 검색하거나 일부 작업을 지연 할 수 없습니다 경우에만 명령을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="62d7860d237948063d6a6adacb3dee7d2e2a84ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; To coerce a list of key-value pairs like &lt;code&gt;['name', 'Ironman', 'victories', 2000]&lt;/code&gt; to an object, use the &lt;a href=&quot;../object/index&quot;&gt;object&lt;/a&gt; command.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;['name', 'Ironman', 'victories', 2000]&lt;/code&gt; 과 같은 키-값 쌍 목록을 오브젝트로 강제 변환하려면 &lt;a href=&quot;../object/index&quot;&gt;object&lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8949966a7c66e20490587a32f2e554a8dbd9cc5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; When &lt;code&gt;between&lt;/code&gt; is chained after &lt;a href=&quot;../order_by/index&quot;&gt;orderBy&lt;/a&gt;, both commands must use the same index; &lt;code&gt;between&lt;/code&gt; will default to the index &lt;code&gt;orderBy&lt;/code&gt; is using, so in this example &lt;code&gt;&quot;rank&quot;&lt;/code&gt; is automatically being used by &lt;code&gt;between&lt;/code&gt;. Trying to specify another index will result in a &lt;code&gt;ReqlRuntimeError&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 시 &lt;code&gt;between&lt;/code&gt; 후 연결됩니다 &lt;a href=&quot;../order_by/index&quot;&gt;해 orderBy&lt;/a&gt; , 두 명령은 동일한 인덱스를 사용해야합니다; &lt;code&gt;between&lt;/code&gt; 는 기본적으로 &lt;code&gt;orderBy&lt;/code&gt; 가 사용 하는 인덱스를 기준으로 하므로이 예에서는 &lt;code&gt;&quot;rank&quot;&lt;/code&gt; 가 &lt;code&gt;between&lt;/code&gt; 에 의해 자동으로 사용됩니다 . 다른 인덱스를 지정하려고하면 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="f19687b68255cefde98992549bb0512f83e051f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; When using &lt;code&gt;or&lt;/code&gt; inside a &lt;code&gt;filter&lt;/code&gt; predicate to test the values of fields that may not exist on the documents being tested, you should use the &lt;code&gt;default&lt;/code&gt; command with those fields so they explicitly return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;filter&lt;/code&gt; 술어를 사용 &lt;code&gt;or&lt;/code&gt; 내부 에서 테스트 할 문서에 없을 수있는 필드 값을 테스트 할 때 해당 필드에 &lt;code&gt;default&lt;/code&gt; 명령을 사용하여 명시 적으로 &lt;code&gt;false&lt;/code&gt; 를 리턴해야 합니다.</target>
        </trans-unit>
        <trans-unit id="dd39e666a62c22d687fb2730309f756fb32d3b95" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; When using &lt;code&gt;r.args&lt;/code&gt; with a command that takes optional arguments, you must not include the optional arguments inside the &lt;code&gt;args&lt;/code&gt; array.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 사용하는 경우 &lt;code&gt;r.args&lt;/code&gt; 를 선택적 인수를 취하는 명령을 사용하여, 당신은 내부의 선택적 인수 포함 할 수 없습니다 &lt;code&gt;args&lt;/code&gt; 배열을.</target>
        </trans-unit>
        <trans-unit id="0c6c81ba7902c5b53acc1ebcc25f0c95ed4ade0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Whenever you call &lt;code&gt;reconfigure&lt;/code&gt;, the write durability will be set to &lt;code&gt;hard&lt;/code&gt; and the write acknowledgments will be set to &lt;code&gt;majority&lt;/code&gt;; these can be changed by using the &lt;code&gt;config&lt;/code&gt; command on the table.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;reconfigure&lt;/code&gt; 를 호출 할 때마다 쓰기 내구성이 &lt;code&gt;hard&lt;/code&gt; 로 설정되고 쓰기 승인이 &lt;code&gt;majority&lt;/code&gt; 로 설정됩니다 . 이들은 테이블 에서 &lt;code&gt;config&lt;/code&gt; 명령을 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91084a4179cba9e5470c814792719c6f7624656e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You need to manually close the cursor if you prematurely stop the iteration.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 반복을 조기에 중지 한 경우 커서를 수동으로 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="c47922a35471606741687b2e80fd1987806a6692" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; all three &lt;code&gt;--cluster-tls-*&lt;/code&gt; options must be used together.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 세 개의 &lt;code&gt;--cluster-tls-*&lt;/code&gt; 옵션을 모두 함께 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="36c003c8b5e4480c4a1bd139949a9bf0751b5da9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; as with other system tables, the current_issues table can only be accessed by the &lt;code&gt;admin&lt;/code&gt; user account.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 다른 시스템 테이블과 마찬가지로 current_issues 테이블은 &lt;code&gt;admin&lt;/code&gt; 계정으로 만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3d641261315030ed211f1807c1f77cd3a308f6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; as with other system tables, the jobs table can only be accessed by the &lt;code&gt;admin&lt;/code&gt; user account.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 다른 시스템 테이블과 마찬가지로 작업 테이블은 &lt;code&gt;admin&lt;/code&gt; 계정으로 만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb0098abc5f32d11c61540c08317a87af39be442" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; the following examples use the JavaScript driver. See the &lt;a href=&quot;../../api/javascript/http/index&quot;&gt;r.http&lt;/a&gt; command reference for documentation for other languages.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 다음 예제는 JavaScript 드라이버를 사용합니다. 다른 언어에 대한 설명서 는 &lt;a href=&quot;../../api/javascript/http/index&quot;&gt;r.http&lt;/a&gt; 명령 참조를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9558d9557a4637128baa441c7dd14475dab7680" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; the following examples use the Python driver, but most of them also apply to RethinkDB drivers for other languages.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 다음 예제는 Python 드라이버를 사용하지만 대부분 다른 언어의 RethinkDB 드라이버에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8d9e22872ceb650b3a0ee7ae97f58294a5c63099" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; while some data may be lost in case of power failure in soft durability mode, the RethinkDB database will not get corrupted.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 소프트 내구성 모드에서 정전이 발생하면 일부 데이터가 손실 될 수 있지만 RethinkDB 데이터베이스는 손상되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f9de9f0a860baf02f2dc11b29bcb0e5c191852c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;--driver-tls-key&lt;/code&gt; and &lt;code&gt;--driver-tls-cert&lt;/code&gt; must be used together; &lt;code&gt;--driver-tls-ca&lt;/code&gt; is optional.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;--driver-tls-key&lt;/code&gt; 와 &lt;code&gt;--driver-tls-cert&lt;/code&gt; 는 함께 사용해야합니다. &lt;code&gt;--driver-tls-ca&lt;/code&gt; 는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="c0b23e7324d267ebfe0c74a6a0cc531c9fe917b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;--http-tls-key&lt;/code&gt; and &lt;code&gt;--http-tls-cert&lt;/code&gt; must be used together.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;--http-tls-key&lt;/code&gt; 와 &lt;code&gt;--http-tls-cert&lt;/code&gt; 를 함께 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4409b56c133546b45d3ac4f9a2db1edab23fb58f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;emergencyRepair&lt;/code&gt; may only be used on individual tables, not on databases. It cannot be used after the &lt;code&gt;db&lt;/code&gt; command.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;emergencyRepair&lt;/code&gt; 는 데이터베이스가 아닌 개별 테이블에서만 사용할 수 있습니다. &lt;code&gt;db&lt;/code&gt; 명령 후에는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="11f0c6d558fec02ec1c3475caefeeaf2478c3f96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;filter&lt;/code&gt; does not use secondary indexes. For retrieving documents via secondary indexes, consider &lt;a href=&quot;../get_all/index&quot;&gt;getAll&lt;/a&gt;, &lt;a href=&quot;../between/index&quot;&gt;between&lt;/a&gt; and &lt;a href=&quot;../eq_join/index&quot;&gt;eqJoin&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;filter&lt;/code&gt; 는 보조 인덱스를 사용하지 않습니다. 보조 인덱스를 통해 문서를 검색하려면 &lt;a href=&quot;../get_all/index&quot;&gt;getAll&lt;/a&gt; , &lt;a href=&quot;../between/index&quot;&gt;between&lt;/a&gt; 및 &lt;a href=&quot;../eq_join/index&quot;&gt;eqJoin을&lt;/a&gt; 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="82292f1b2fd2332e85304570980eb55cb239d539" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;getAll&lt;/code&gt; does not perform any de-duplication. If you pass the same key more than once, the same document will be returned multiple times.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;getAll&lt;/code&gt; 은 중복 제거를 수행하지 않습니다. 동일한 키를 두 번 이상 전달하면 동일한 문서가 여러 번 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f09577e4be3e49739c51708b109b91b85412fa61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;rethinkdb restore&lt;/code&gt; may not work for restoring backups made with later versions of RethinkDB to servers running &lt;em&gt;earlier&lt;/em&gt; versions. For example, you cannot restore a backup made on RethinkDB 2.2 to a server running RethinkDB 2.1.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;rethinkdb restore&lt;/code&gt; 은 이후 버전의 RethinkDB로 작성된 백업을 &lt;em&gt;이전&lt;/em&gt; 버전을 실행하는 서버로 복원하는 데 작동하지 않을 수 있습니다. 예를 들어 RethinkDB 2.2에서 작성된 백업을 RethinkDB 2.1을 실행하는 서버로 복원 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e673af6ab7169b990a08aa4e9ea475bf687c997" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;code&gt;upcase&lt;/code&gt; and &lt;code&gt;downcase&lt;/code&gt; only affect ASCII characters.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;upcase&lt;/code&gt; 와 &lt;code&gt;downcase&lt;/code&gt; ASCII 문자 만 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="de7dedf278d97ac92af0e06649a956fbefae7de5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Currently, RethinkDB implements range shards, but will eventually be switching to hash shards. Follow &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/364&quot;&gt;Github issue #364&lt;/a&gt; to track progress.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 현재 RethinkDB는 범위 샤드를 구현하지만 결국 해시 샤드로 전환합니다. 팔로우 &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/364&quot;&gt;Github에서의 문제점 # 364는&lt;/a&gt; 진행 상황을 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="055dd8626d3edc621d17f38564d066147c8ecdb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: RethinkDB uses a self-signed certificate to encrypt your password. You&amp;rsquo;ll have to accept the self-signed certificate in your browser to access the instance.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : RethinkDB는 자체 서명 인증서를 사용하여 비밀번호를 암호화합니다. 인스턴스에 액세스하려면 브라우저에서 자체 서명 된 인증서를 수락해야합니다.</target>
        </trans-unit>
        <trans-unit id="7ae447cd91701030266e2698f9a1d0b3b1a19772" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: The authentication system affects &lt;em&gt;client drivers,&lt;/em&gt; not the web interface. Follow the directions above to secure the web UI.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 인증 시스템은 웹 인터페이스가 아닌 &lt;em&gt;클라이언트 드라이버에&lt;/em&gt; 영향을줍니다 . 위의 지침에 따라 웹 UI를 보호하십시오.</target>
        </trans-unit>
        <trans-unit id="391d678659ff2edfa66d27978dbae06c2c03a722" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This performance report is based on RethinkDB version 2.1.5. It takes a large amount of effort to create a quality performance report that covers multiple use cases. In the future, we plan to update this report for subsequent releases of RethinkDB.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 성능 보고서는 RethinkDB 버전 2.1.5를 기반으로합니다. 여러 사용 사례를 다루는 품질 성과 보고서를 작성하려면 많은 노력이 필요합니다. 향후 RethinkDB의 후속 릴리스에 대해이 보고서를 업데이트 할 계획입니다.</target>
        </trans-unit>
        <trans-unit id="ac91f80cdb019a96079f01389dfc4f8715fba35e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: it is possible to attach more specialized EBS volumes and have RethinkDB store your data on them, but this option is not yet available out of the box. If you manually attach an EBS volume, you can SSH into the instance and edit the configuration file to point RethinkDB to the custom volume. See the &lt;a href=&quot;../cluster-on-startup/index&quot;&gt;cluster setup instructions&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :보다 전문화 된 EBS 볼륨을 연결하고 RethinkDB에서 데이터를 저장할 수 있지만이 옵션을 아직 사용할 수는 없습니다. EBS 볼륨을 수동으로 연결하는 경우 SSH를 인스턴스에 넣고 구성 파일을 편집하여 RethinkDB가 사용자 지정 볼륨을 가리 키도록 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;../cluster-on-startup/index&quot;&gt;클러스터 설정 지침&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e7eed048c3a4266440dc28bf30498616c19764e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: you can also join tables on arbitrary fields without creating an index using the &lt;a href=&quot;https://rethinkdb.com/api/python/inner_join/&quot;&gt;inner_join&lt;/a&gt; command. However, arbitrary inner joins are less efficient then equijoins.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;a href=&quot;https://rethinkdb.com/api/python/inner_join/&quot;&gt;inner_join&lt;/a&gt; 명령을 사용하여 색인을 만들지 않고 임의의 필드에서 테이블을 조인 할 수도 있습니다 . 그러나 임의의 내부 결합은 동등하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75f9b901b8b0ba4768fbe2d292f47e726d332f22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Null&lt;/strong&gt; is a value distinct from the number zero, an empty set, or a zero-length string. Natively this might be &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt;, depending on the language. it is often used to explicitly denote the absence of any other value. The root node of a tree structure might have a parent of &lt;code&gt;null&lt;/code&gt;, or a required but as yet non-initialized key might be given a value of &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Null&lt;/strong&gt; 은 숫자 0, 빈 세트 또는 길이가 0 인 문자열과 다른 값입니다. 기본적으로 언어에 따라 &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;nil&lt;/code&gt; 또는 &lt;code&gt;None&lt;/code&gt; 일 수 있습니다. 종종 다른 값이 없음을 명시 적으로 나타내는 데 사용됩니다. 트리 구조의 루트 노드는 부모가 &lt;code&gt;null&lt;/code&gt; 이거나 필수이지만 아직 초기화되지 않은 키에 &lt;code&gt;null&lt;/code&gt; 값이 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="954d3521277cb7751626aaf0bf4996052c047cf2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Numbers&lt;/strong&gt; are any real number: &lt;code&gt;5&lt;/code&gt;, &lt;code&gt;3.14159&lt;/code&gt;, &lt;code&gt;-42&lt;/code&gt;. RethinkDB uses double precision (64-bit) floating point numbers internally. (Neither infinity nor &lt;a href=&quot;http://en.wikipedia.org/wiki/NaN&quot;&gt;NaN&lt;/a&gt; are allowed.)</source>
          <target state="translated">&lt;strong&gt;숫자&lt;/strong&gt; 는 실수입니다 : &lt;code&gt;5&lt;/code&gt; , &lt;code&gt;3.14159&lt;/code&gt; , &lt;code&gt;-42&lt;/code&gt; . RethinkDB는 내부에서 배정도 (64 비트) 부동 소수점 숫자를 사용합니다. (무한대 나 &lt;a href=&quot;http://en.wikipedia.org/wiki/NaN&quot;&gt;NaN&lt;/a&gt; 은 허용되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="42272f2482546642d71be65a4bf0e2d7e4f7b821" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Objects&lt;/strong&gt; are JSON data objects, standard key-value pairs.</source>
          <target state="translated">&lt;strong&gt;객체&lt;/strong&gt; 는 표준 키-값 쌍인 JSON 데이터 객체입니다.</target>
        </trans-unit>
        <trans-unit id="8175493929f817ebdc71a294b10029326aa5db7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Ping&lt;/strong&gt;&lt;a href=&quot;https://twitter.com/rethinkdb&quot;&gt;@rethinkdb&lt;/a&gt; on Twitter</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;트위터에 &lt;strong&gt;핑 &lt;/strong&gt;&lt;a href=&quot;https://twitter.com/rethinkdb&quot;&gt;@ rethinkdb&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e3e48df73ec12a9bd712247c600f0a4ab09c38e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Points:&lt;/strong&gt; a single coordinate pair</source>
          <target state="translated">&lt;strong&gt;포인트 :&lt;/strong&gt; 단일 좌표 쌍</target>
        </trans-unit>
        <trans-unit id="f1b9ddb4546b95158915692401b6845ada91a69e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Points&lt;/strong&gt; are denoted by a single coordinate pair, two floating point numbers indicating longitude (&amp;minus;180 through 180) and latitude (&amp;minus;90 through 90).</source>
          <target state="translated">&lt;strong&gt;점&lt;/strong&gt; 은 경도 (-180-180) 및 위도 (-90-90)를 나타내는 두 개의 부동 소수점 숫자로 단일 좌표 쌍으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9597c8150e0f780930e4309fec2a772a0ed671c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Polygons:&lt;/strong&gt; A multipoint line (at least three coordinate pairs) which does not intersect with itself and whose first and last coordinate pairs are equal. The interior of the polygon is considered filled, that is, part of the polygon. Polygons with &amp;ldquo;holes&amp;rdquo; in them, where a hole is another polygon contained by the first, can be created with the [polygonSub][] command.</source>
          <target state="translated">&lt;strong&gt;다각형 :&lt;/strong&gt; 자신과 교차하지 않고 첫 번째와 마지막 좌표 쌍이 같은 다 지점 선 (최소 3 개의 좌표 쌍). 다각형의 내부는 채워진 것으로, 즉 다각형의 일부로 간주됩니다. 구멍이 첫 번째에 포함 된 다른 다각형 인 &quot;구멍&quot;이있는 다각형은 [polygonSub] [] 명령으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43e4d5d2c45c509aaee61213043ffa37cc518dec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Polygons&lt;/strong&gt; are multipoint lines denoted by a sequence of three or more points, denoted by either point objects or coordinate pairs, which do not intersect with themselves. The first and last coordinate pairs of a polygon are equal.</source>
          <target state="translated">&lt;strong&gt;다각형&lt;/strong&gt; 은 점 개체 또는 좌표 쌍으로 표시되는 3 개 이상의 점 시퀀스로 표시되는 다중 점 선으로, 서로 교차하지 않습니다. 다각형의 첫 번째 좌표 쌍과 마지막 좌표 쌍은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="2e07e9a05546e4319882669bc9712dc4ccf31063" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Post an issue&lt;/strong&gt; on our &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues&quot;&gt;issue tracker&lt;/a&gt; on GitHub</source>
          <target state="translated">&lt;strong&gt;문제를 게시&lt;/strong&gt; 우리에 &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues&quot;&gt;이슈 트래커&lt;/a&gt; GitHub의에</target>
        </trans-unit>
        <trans-unit id="33a77013c569a15e7e2bf3a1992ac56e56b3b016" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Post an issue&lt;/strong&gt; on the &lt;a href=&quot;https://github.com/rethinkdb/docs/issues&quot;&gt;documentation issue tracker&lt;/a&gt; on GitHub</source>
          <target state="translated">&lt;strong&gt;문제를 게시&lt;/strong&gt; 온 &lt;a href=&quot;https://github.com/rethinkdb/docs/issues&quot;&gt;문서 이슈 트래커&lt;/a&gt; GitHub의에</target>
        </trans-unit>
        <trans-unit id="42335a2c1df7ed71b48071a2503896505db6d209" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Post an issue&lt;/strong&gt; on the docs &lt;a href=&quot;https://github.com/rethinkdb/docs/issues&quot;&gt;issue tracker&lt;/a&gt; on GitHub</source>
          <target state="translated">&lt;strong&gt;문제를 게시&lt;/strong&gt; 워드 프로세서의에 &lt;a href=&quot;https://github.com/rethinkdb/docs/issues&quot;&gt;이슈 트래커&lt;/a&gt; GitHub의에</target>
        </trans-unit>
        <trans-unit id="12882ba83567cb07834b7c929caf91c2a37d62f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Processing happens where the data is until an operation needs to combine it.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;작업이 데이터를 결합해야 할 때까지 데이터가 처리됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d902b373120e946f67ccafe33ceb570b4948b884" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pseudotypes&lt;/strong&gt; cover several kinds of other ReQL-specific data types which are generally composites or special cases of other types:</source>
          <target state="translated">&lt;strong&gt;Pseudotypes은&lt;/strong&gt; 일반적으로 복합 또는 다른 종류의 특별한 경우 다른 ReQL 특정 데이터 유형의 여러 가지를 포함합니다 :</target>
        </trans-unit>
        <trans-unit id="37ece2fb3fb304a0baf20a172d9e8628d37a462a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Q&lt;/strong&gt;: What&amp;rsquo;s the best way to perform &lt;a href=&quot;http://en.wikipedia.org/wiki/Full_text_search&quot;&gt;full-text searches&lt;/a&gt; with RethinkDB?</source>
          <target state="translated">&lt;strong&gt;Q&lt;/strong&gt; : RethinkDB로 &lt;a href=&quot;http://en.wikipedia.org/wiki/Full_text_search&quot;&gt;전체 텍스트 검색&lt;/a&gt; 을 수행하는 가장 좋은 방법은 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="f5b263e6535a839063246d6ed1d667d9e5e05e99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Queries are timezone-aware&lt;/strong&gt;, so you can ask questions like &amp;ldquo;Did this event happen on a Monday in the time zone where it was recorded?&amp;rdquo;</source>
          <target state="translated">&lt;strong&gt;검색어는 시간대를 인식&lt;/strong&gt; 하므로 &quot;이 이벤트가 월요일에 녹화 된 시간대에 있었습니까?&quot;와 같은 질문을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e35d1efa548c6d1dddc1e1fcc7fe7239f2793a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ReQL embeds into your programming language.&lt;/strong&gt; Queries are constructed by making function calls in the programming language you already know. You don&amp;rsquo;t have to concatenate strings or construct specialized JSON objects to query the database.</source>
          <target state="translated">&lt;strong&gt;ReQL은 프로그래밍 언어에 포함됩니다. &lt;/strong&gt;쿼리는 이미 알고있는 프로그래밍 언어로 함수를 호출하여 구성됩니다. 데이터베이스를 쿼리하기 위해 문자열을 연결하거나 특수한 JSON 객체를 구성 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="67197f7ba403334566c79cd3161603e0af6d6c85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Read mode&lt;/strong&gt; is set per query via an optional argument, &lt;code&gt;read_mode&lt;/code&gt; (or &lt;code&gt;readMode&lt;/code&gt;), to &lt;a href=&quot;../../api/javascript/table/index&quot;&gt;table&lt;/a&gt;. It has three possible values:</source>
          <target state="translated">&lt;strong&gt;읽기 모드&lt;/strong&gt; 는 선택적 인수 인 &lt;code&gt;read_mode&lt;/code&gt; (또는 &lt;code&gt;readMode&lt;/code&gt; ) 를 통해 쿼리마다 &lt;a href=&quot;../../api/javascript/table/index&quot;&gt;테이블로 설정&lt;/a&gt; 됩니다. 세 가지 가능한 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0deb70322adc3d51ae3a4a03b83d595e706f63cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Ready to install the client drivers?&lt;/strong&gt; Take a look at &lt;a href=&quot;../install-drivers/index&quot;&gt;the drivers install page&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;클라이언트 드라이버를 설치할 준비가 되셨습니까? &lt;/strong&gt;&lt;a href=&quot;../install-drivers/index&quot;&gt;드라이버 설치 페이지를&lt;/a&gt; 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="2342dfd64a87b31ce9abe494c35572be249a138a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reliability&lt;/strong&gt; &amp;mdash; A mobile connection might be made through GPRS, which can lead to subtle disconnections and data losses, and lots of undefined behaviour and inconsistent data states.</source>
          <target state="translated">&lt;strong&gt;신뢰성&lt;/strong&gt; &amp;mdash; GPRS를 통해 모바일 연결이 이루어질 수 있으며, 이로 인해 미묘한 연결 끊김 및 데이터 손실, 많은 정의되지 않은 동작 및 일관되지 않은 데이터 상태가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c529a5a36bed80b1170b82d0a7683aaaeec97cae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Repairable:&lt;/strong&gt; the shard is not healthy, but has at least one replica, whether voting or non-voting, available.</source>
          <target state="translated">&lt;strong&gt;수리 가능 :&lt;/strong&gt; 샤드는 건강하지 않지만 투표 또는 비 투표에 관계없이 하나 이상의 복제본이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4c27efd49bd4b54d53658d59a45b127a4c6e135" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Restrict access to port 28015&lt;/strong&gt; to allow only IP addresses or security groups that should have driver access.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;드라이버 액세스 권한이 있어야하는 IP 주소 또는 보안 그룹 만 허용하도록 &lt;strong&gt;포트 28015&lt;/strong&gt; 에 &lt;strong&gt;대한 액세스를 제한하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5f4ee4c0c472d3efbe4bc88398ffef5449ee7b75" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Running Ubuntu?&lt;/strong&gt; Use the &lt;a href=&quot;#startup-with-initd&quot;&gt;Startup with init.d&lt;/a&gt; instructions above, not the &lt;code&gt;systemd&lt;/code&gt; instructions.</source>
          <target state="translated">&lt;strong&gt;우분투를 실행? &lt;/strong&gt;사용 &lt;a href=&quot;#startup-with-initd&quot;&gt;된 init.d로 시작을&lt;/a&gt; 위의 지침이 아닌 &lt;code&gt;systemd&lt;/code&gt; 지침.</target>
        </trans-unit>
        <trans-unit id="486e8782236cac6194ec587ceab134734a3b24a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Seeing a &amp;lsquo;received invalid clustering header&amp;rsquo; message?&lt;/strong&gt; RethinkDB uses three ports to operate&amp;mdash;the HTTP web UI port, the client drivers port, and the intracluster traffic port. You can connect the browser to the web UI port to administer the cluster right from your browser, and connect the client drivers to the client driver port to run queries from your application. If you&amp;rsquo;re running a cluster, different RethinkDB nodes communicate with each other via the intracluster traffic port.</source>
          <target state="translated">&lt;strong&gt;'수신 된 유효하지 않은 클러스터링 헤더'메시지가 보입니까?&lt;/strong&gt; RethinkDB는 HTTP 웹 UI 포트, 클라이언트 드라이버 포트 및 클러스터 내 트래픽 포트의 세 가지 포트를 사용하여 작동합니다. 브라우저를 웹 UI 포트에 연결하여 브라우저에서 바로 클러스터를 관리하고 클라이언트 드라이버를 클라이언트 드라이버 포트에 연결하여 응용 프로그램에서 쿼리를 실행할 수 있습니다. 클러스터를 실행중인 경우 다른 RethinkDB 노드는 클러스터 내 트래픽 포트를 통해 서로 통신합니다.</target>
        </trans-unit>
        <trans-unit id="799d0e4ffa6d58434454e97c7477149cd53ca7c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Selections&lt;/strong&gt; represent subsets of tables, for example, the return values of &lt;code&gt;filter&lt;/code&gt; or &lt;code&gt;get&lt;/code&gt;. There are three kinds of selections: &lt;strong&gt;Selection&amp;lt;Object&amp;gt;&lt;/strong&gt;, &lt;strong&gt;Selection&amp;lt;Array&amp;gt;&lt;/strong&gt; and &lt;strong&gt;Selection&amp;lt;Stream&amp;gt;&lt;/strong&gt;. The difference between selections and their non-selection counterparts is that selections are writable&amp;mdash;their return values can be passed as inputs to ReQL commands that modify the database. For instance, the &lt;code&gt;get&lt;/code&gt; command will return a Selection&amp;lt;Object&amp;gt; that could then be passed to an &lt;code&gt;update&lt;/code&gt; or &lt;code&gt;delete&lt;/code&gt; command. (&lt;em&gt;Note:&lt;/em&gt;&lt;strong&gt;singleSelection&lt;/strong&gt; is an older term for Selection&amp;lt;Object&amp;gt;; they mean the same thing.)</source>
          <target state="translated">&lt;strong&gt;선택&lt;/strong&gt; 은 예를 들어 &lt;code&gt;filter&lt;/code&gt; 또는 &lt;code&gt;get&lt;/code&gt; 의 반환 값과 같은 테이블의 하위 집합을 나타냅니다 . &lt;strong&gt;Selection &amp;lt;Object&amp;gt;&lt;/strong&gt; , &lt;strong&gt;Selection &amp;lt;Array&amp;gt;&lt;/strong&gt; 및 &lt;strong&gt;Selection &amp;lt;Stream&amp;gt;의&lt;/strong&gt; 세 가지 선택 유형이 있습니다 . 선택과 선택되지 않은 상대의 차이점은 선택을 쓸 수 있다는 것입니다. 반환 값은 데이터베이스를 수정하는 ReQL 명령에 대한 입력으로 전달 될 수 있습니다. 예를 들어, &lt;code&gt;get&lt;/code&gt; 명령은 Selection &amp;lt;Object&amp;gt;를 반환 한 다음 &lt;code&gt;update&lt;/code&gt; 또는 &lt;code&gt;delete&lt;/code&gt; 명령 으로 전달할 수 있습니다 . ( &lt;em&gt;참고 : &lt;/em&gt;&lt;strong&gt;singleSelection&lt;/strong&gt; 은 Selection &amp;lt;Object&amp;gt;의 오래된 용어이며 동일한 의미입니다.)</target>
        </trans-unit>
        <trans-unit id="49a626508c2bf8d315da7f470980e146b8ca66c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simple indexes&lt;/strong&gt; based on the value of a single field.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;단일 필드의 값을 기반으로 한 &lt;strong&gt;간단한 색인&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b9cb23d72e3d623df37615317e2745955353a842" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Speed and caching&lt;/strong&gt; &amp;mdash; If your app frequently queries your server, with large responses, it&amp;rsquo;ll make RethinkDB need to process a lot of data, sometimes not on RAM, continuously. With a simple webserver, you can throttle querying and cache results.</source>
          <target state="translated">&lt;strong&gt;속도 및 캐싱&lt;/strong&gt; &amp;mdash; 앱이 응답이 많은 서버를 자주 쿼리하는 경우 RethinkDB가 많은 데이터를 처리해야하며 때로는 RAM이 아닌 데이터를 지속적으로 처리해야합니다. 간단한 웹 서버를 사용하여 쿼리를 제한하고 결과를 캐시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f570ac1b88af679df89ba77571bd4bc066ff6676" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Streams&lt;/strong&gt; are lists like arrays, but they&amp;rsquo;re loaded in a lazy fashion. Operations that return streams return a &lt;em&gt;cursor.&lt;/em&gt; A cursor is a pointer into the result set. Instead of reading the results all at once like an array, you loop over the results, retrieving the next member of the set with each iteration. This makes it possible to efficiently work with large result sets. (See &amp;ldquo;Working with Streams,&amp;rdquo; below, for some tips.) Streams are read-only; you can&amp;rsquo;t pass one as an input to an ReQL command meant to modify its input like &lt;code&gt;update&lt;/code&gt; or &lt;code&gt;delete&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;스트림&lt;/strong&gt; 은 배열과 같은 목록이지만 느리게로드됩니다. 스트림을 반환하는 작업은 &lt;em&gt;커서를&lt;/em&gt; 반환합니다 &lt;em&gt;. &lt;/em&gt;커서는 결과 집합에 대한 포인터입니다. 배열처럼 한 번에 결과를 읽는 대신 결과를 반복하여 각 반복마다 세트의 다음 멤버를 검색합니다. 이를 통해 큰 결과 집합으로 효율적으로 작업 할 수 있습니다. 몇 가지 팁은 아래의&amp;ldquo;스트림 작업&amp;rdquo;을 참조하십시오. 스트림은 읽기 전용입니다. &lt;code&gt;update&lt;/code&gt; 또는 &lt;code&gt;delete&lt;/code&gt; 와 같이 입력을 수정하는 ReQL 명령에 입력으로 하나를 전달할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5bf60a0b812a19d56ba91ad443eefb5b23c23aff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Strings&lt;/strong&gt; are any valid UTF-8 string: &lt;code&gt;&quot;superhero&quot;&lt;/code&gt;, &lt;code&gt;&quot;&amp;uuml;nn&amp;euml;c&amp;euml;ss&amp;auml;r&amp;yuml; &amp;uuml;ml&amp;auml;&amp;uuml;ts&quot;&lt;/code&gt;. Strings may include the null code point (U+0000).</source>
          <target state="translated">&lt;strong&gt;문자열&lt;/strong&gt; 은 유효한 UTF-8 문자열입니다 : &lt;code&gt;&quot;superhero&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;uuml;nn&amp;euml;c&amp;euml;ss&amp;auml;r&amp;yuml; &amp;uuml;ml&amp;auml;&amp;uuml;ts&quot;&lt;/code&gt; . 문자열은 널 코드 포인트 (U + 0000)를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3afb7ccbef23c399992f4d11fe38909967afffb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tables&lt;/strong&gt; are RethinkDB database tables. They behave like selections&amp;mdash;they&amp;rsquo;re writable, as you can insert and delete documents in them. ReQL methods that use an &lt;a href=&quot;../secondary-indexes/index&quot;&gt;index&lt;/a&gt;, like &lt;code&gt;getAll&lt;/code&gt;, are only available on tables.</source>
          <target state="translated">&lt;strong&gt;테이블&lt;/strong&gt; 은 RethinkDB 데이터베이스 테이블입니다. 선택 항목처럼 작동합니다. 문서를 삽입하고 삭제할 수 있으므로 쓰기가 가능합니다. &lt;code&gt;getAll&lt;/code&gt; 과 같은 &lt;a href=&quot;../secondary-indexes/index&quot;&gt;인덱스&lt;/a&gt; 를 사용하는 ReQL 메서드는 테이블에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8db6c184c5ac01f5ce4005e909d106f1dbf45cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tables&lt;/strong&gt; are RethinkDB database tables. They behave like selections&amp;mdash;they&amp;rsquo;re writable, as you can insert and delete documents in them. ReQL methods that use an &lt;a href=&quot;../secondary-indexes/javascript/index&quot;&gt;index&lt;/a&gt;, like &lt;code&gt;getAll&lt;/code&gt;, are only available on tables.</source>
          <target state="translated">&lt;strong&gt;테이블&lt;/strong&gt; 은 RethinkDB 데이터베이스 테이블입니다. 그것들은 문서처럼 삽입하고 삭제할 수 있기 때문에 선택 가능한 것처럼 동작합니다. &lt;code&gt;getAll&lt;/code&gt; 과 같이 &lt;a href=&quot;../secondary-indexes/javascript/index&quot;&gt;인덱스&lt;/a&gt; 를 사용하는 ReQL 메소드는 테이블에서만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="6f77ceba2cd260e3b44909c763584535803d185e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Talk to the team on IRC&lt;/strong&gt; on &lt;a href=&quot;irc://freenode.net/#rethinkdb&quot;&gt;#rethinkdb@freenode.net&lt;/a&gt; &amp;mdash; via &lt;a href=&quot;http://webchat.freenode.net/?channels=#rethinkdb&quot;&gt;Webchat&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;IRC에 팀 토크&lt;/strong&gt; 에 &lt;a href=&quot;irc://freenode.net/#rethinkdb&quot;&gt;#rethinkdb@freenode.net&lt;/a&gt; -를 통해 &lt;a href=&quot;http://webchat.freenode.net/?channels=#rethinkdb&quot;&gt;웹 채팅&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="241f675f29e298739c20e6fe842d8b714d268ef6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Talk to the team&lt;/strong&gt; on &lt;a href=&quot;irc://freenode.net/#rethinkdb&quot;&gt;#rethinkdb@freenode.net&lt;/a&gt; &amp;mdash; via &lt;a href=&quot;http://webchat.freenode.net/?channels=#rethinkdb&quot;&gt;Webchat&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;&lt;a href=&quot;http://webchat.freenode.net/?channels=#rethinkdb&quot;&gt;Webchat을&lt;/a&gt; 통해 &lt;a href=&quot;irc://freenode.net/#rethinkdb&quot;&gt;#rethinkdb@freenode.net &lt;/a&gt;&lt;strong&gt;에서 팀&lt;/strong&gt; 과 &lt;strong&gt;대화하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cba252a8a7dad1f3f788cee82e2bd0fb37f9debf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Technologies:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Technologies:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a0e0f35150cd2ebc8b4e22bc881db2d8c834afd6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Thanks to all our amazing driver contributors!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;모든 놀라운 드라이버 기고자에게 감사합니다!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b3a0a050d6074e901f878100598ba959ebc05bda" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Elasticsearch River plugin is not compatible with RethinkDB 2.2 and higher.&lt;/strong&gt; We&amp;rsquo;ll be revisiting this article to update it with the new official Java driver and the &lt;a href=&quot;https://github.com/rethinkdb/logstash-input-rethinkdb&quot;&gt;RethinkDB Logstash input plugin&lt;/a&gt; soon.</source>
          <target state="translated">&lt;strong&gt;Elasticsearch River 플러그인은 RethinkDB 2.2 이상과 호환되지 않습니다. &lt;/strong&gt;새로운 공식 Java 드라이버 및 &lt;a href=&quot;https://github.com/rethinkdb/logstash-input-rethinkdb&quot;&gt;RethinkDB Logstash 입력 플러그인으로&lt;/a&gt; 곧 업데이트하기 위해이 기사를 다시 방문 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d00680d3cf701111ba5a9f173ac5c81948f23f4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The emergency repair mode is extremely dangerous.&lt;/strong&gt; It bypasses normal safeguards that prevent data loss and invalidates the &lt;a href=&quot;../../../docs/consistency/index&quot;&gt;consistency guarantees&lt;/a&gt; that RethinkDB normally provides, and can easily lose data in either mode&amp;mdash;in &lt;code&gt;unsafe_rollback_or_erase&lt;/code&gt; mode it could lose &lt;em&gt;all&lt;/em&gt; of a shard&amp;rsquo;s data.</source>
          <target state="translated">&lt;strong&gt;응급 복구 모드는 매우 위험합니다. &lt;/strong&gt;데이터 손실을 방지 하고 RethinkDB가 일반적으로 제공 하는 &lt;a href=&quot;../../../docs/consistency/index&quot;&gt;일관성 보장&lt;/a&gt; 을 무효화하고 어느 모드에서든 쉽게 데이터를 잃을 수있는 일반적인 보호 기능을 우회합니다 . &lt;code&gt;unsafe_rollback_or_erase&lt;/code&gt; 모드에서는 샤드의 &lt;em&gt;모든&lt;/em&gt; 데이터 가 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9094d3699eb84b00dd908ef62838c379f7ea395f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This design has the following advantages:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이 디자인에는 다음과 같은 장점이 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="763cfe3f57a5e4d13fb261d3996143710a604c20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This technology has the following limitation:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이 기술에는 다음과 같은 제한이 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5abdd8608cfa5be9088b13101b71ba66e9e70735" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time operations are pure ReQL&lt;/strong&gt;, which means that even complicated date-time queries can be distributed efficiently across the cluster.</source>
          <target state="translated">&lt;strong&gt;시간 작업은 순수한 ReQL&lt;/strong&gt; 이므로 복잡한 날짜-시간 쿼리조차도 클러스터 전체에 효율적으로 분산 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ca5cd814baa9c15ef35d906f6a49bc834967333" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Times are integrated with the official drivers&lt;/strong&gt;, which will automatically convert to and from your language&amp;rsquo;s native time type.</source>
          <target state="translated">&lt;strong&gt;시간은 공식 드라이버와 통합되며,&lt;/strong&gt; 언어의 기본 시간 유형과 자동으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="e8f826206bebda797813cec26b6ff6fb7d038c71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Times work as indexes&lt;/strong&gt;, so you can efficiently retrieve events based on when they occurred.</source>
          <target state="translated">&lt;strong&gt;시간은 인덱스로 작동&lt;/strong&gt; 하므로 발생한 시간을 기준으로 이벤트를 효율적으로 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b8b8497151001614bd4e0670bb0951bee3ba261" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Times&lt;/strong&gt; are RethinkDB&amp;rsquo;s native date/time type, stored with millisecond precision. You can use native date/time types in supported languages, as the conversion will be done by the driver. See &lt;a href=&quot;../dates-and-times/javascript/index&quot;&gt;Dates and times in RethinkDB&lt;/a&gt; for details.</source>
          <target state="translated">&lt;strong&gt;시간&lt;/strong&gt; 은 RethinkDB의 기본 날짜 / 시간 유형이며 밀리 초 단위로 저장됩니다. 드라이버가 변환을 수행하므로 지원되는 언어로 기본 날짜 / 시간 유형을 사용할 수 있습니다. 자세한 내용 &lt;a href=&quot;../dates-and-times/javascript/index&quot;&gt;은 RethinkDB의 날짜 및 시간&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8417b4a9d458266c49da852e5ac822c015a96236" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Voting and non-voting?&lt;/strong&gt; All replicas are &amp;ldquo;voting&amp;rdquo; replicas by default, which simply means that they&amp;rsquo;re counted in any operation that requires a majority of replicas to be available. However, the speed at which replicas &amp;ldquo;vote&amp;rdquo; is affected by network latency; if you have a faraway data center with higher latency, you might want to set its replicas to be non-voting to improve performance, at the cost of guaranteed availability in that data center. You can set a replica to be &amp;ldquo;non-voting&amp;rdquo; by changing its table configuration with &lt;code&gt;reconfigure&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;투표와 비 투표? &lt;/strong&gt;모든 복제본은 기본적으로 &quot;투표&quot;복제본으로, 대부분의 복제본을 사용할 수 있어야하는 작업에서 계산됩니다. 그러나 복제본이 &quot;투표&quot;하는 속도는 네트워크 대기 시간의 영향을받습니다. 대기 시간이 긴 원거리 데이터 센터가있는 경우 해당 데이터 센터의 가용성을 보장하면서 성능을 향상시키기 위해 복제본을 투표 용으로 설정하지 않을 수 있습니다. &lt;code&gt;reconfigure&lt;/code&gt; 를 사용 하여 테이블 구성을 변경하여 복제본을 &quot;투표하지 않음&quot;으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ddbdba909e5392a43bd771ddb1314f3bb974167d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Want to connect a third node?&lt;/strong&gt; You can join it with either of the two existing nodes in the cluster.</source>
          <target state="translated">&lt;strong&gt;세 번째 노드를 연결하고 싶습니까? &lt;/strong&gt;클러스터에있는 두 개의 기존 노드 중 하나와 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e53d1a7998151852edb64409057578fbebba1d94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Want to keep learning?&lt;/strong&gt; Dive into the documentation:</source>
          <target state="translated">&lt;strong&gt;계속 배우고 싶습니까? &lt;/strong&gt;설명서에 들어가십시오 :</target>
        </trans-unit>
        <trans-unit id="5a35015d5412f28e13ee4e0223d1c9a03d410d45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Want to learn more about indexes?&lt;/strong&gt;: Read about &lt;a href=&quot;../secondary-indexes/javascript/index&quot;&gt;using secondary indexes in RethinkDB&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;인덱스에 대해 더 알고 싶으십니까? &lt;/strong&gt;: &lt;a href=&quot;../secondary-indexes/javascript/index&quot;&gt;RethinkDB에서 보조 인덱스 사용&lt;/a&gt; 에 대해 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="01c549c9750191d008af2a73cb2ad83d40898ec2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Want to learn more about joins in RethinkDB?&lt;/strong&gt; See &lt;a href=&quot;../../table-joins/index&quot;&gt;how to use joins&lt;/a&gt; to query &lt;em&gt;one to many&lt;/em&gt; and &lt;em&gt;many to many&lt;/em&gt; relations.</source>
          <target state="translated">&lt;strong&gt;RethinkDB의 조인에 대해 자세히 알고 싶으십니까? &lt;/strong&gt;&lt;a href=&quot;../../table-joins/index&quot;&gt;조인을 사용 &lt;/a&gt;&lt;em&gt;하여 일대 다&lt;/em&gt; 및 &lt;em&gt;다 대다&lt;/em&gt; 관계 를 쿼리 하는 방법을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6229ffa4cf49896ea3123e2f40d6c3923b220d2b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Want to learn more about the basics?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;기본 사항에 대해 더 알고 싶으십니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="414dbfcda6ccf03073222e7922b5b9bfc80cd803" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Want to start instances of RethinkDB on system startup?&lt;/strong&gt; See &lt;a href=&quot;../start-on-startup/index&quot;&gt;Start RethinkDB at system startup&lt;/a&gt; to learn how to set up RethinkDB with &lt;code&gt;init.d&lt;/code&gt; or &lt;code&gt;systemd&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;시스템 시작시 RethinkDB 인스턴스를 시작 하시겠습니까? &lt;/strong&gt; &lt;code&gt;init.d&lt;/code&gt; 또는 &lt;code&gt;systemd&lt;/code&gt; 로 RethinkDB를 설정하는 방법을 배우려면 &lt;a href=&quot;../start-on-startup/index&quot;&gt;시스템 시작시 RethinkDB 시작을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="31c9b4476e404baf1ee134c0a5877b383a2e0dcc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Want to write useful queries right away?&lt;/strong&gt; Check out the &lt;a href=&quot;../guide/javascript/index&quot;&gt;ten-minute guide&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;유용한 쿼리를 바로 작성하고 싶습니까? &lt;/strong&gt;&lt;a href=&quot;../guide/javascript/index&quot;&gt;10 분 가이드를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d556cbc94357222a0d84c564d0db94534587aa7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning!&lt;/strong&gt; If the RethinkDB river plugin loses connection with the RethinkDB server it&amp;rsquo;s pulling data from, there&amp;rsquo;s no way to guarantee no documents will be lost. This should change in the future with improvements to changefeeds, but currently the only way to be sure is to backfill every time, which will still miss deleted documents.</source>
          <target state="translated">&lt;strong&gt;경고! &lt;/strong&gt;RethinkDB 리버 플러그인이 데이터를 가져 오는 RethinkDB 서버와의 연결이 끊어지면 문서 손실을 보장 할 방법이 없습니다. 향후 피드 변경 기능이 개선되어 변경 될 예정이지만 현재 확인해야 할 유일한 방법은 매번 백업 광고를 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="82bee43aaf2bf881fa72aeb9566728d0e938de71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What projections are supported?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;어떤 프로젝션이 지원됩니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4578283ff402020750ff54fb973b598a40988ab5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Wondering how to model your data?&lt;/strong&gt; Read about &lt;a href=&quot;../data-modeling/index&quot;&gt;data modeling in RethinkDB&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;데이터 모델링 방법이 궁금하십니까? &lt;/strong&gt;&lt;a href=&quot;../data-modeling/index&quot;&gt;RethinkDB의 데이터 모델링에&lt;/a&gt; 대해 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="689268146d99e247378fbf455f261a7c1dd6863f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Write acknowledgements&lt;/strong&gt; are set per table with the &lt;code&gt;write_acks&lt;/code&gt; setting, either using the &lt;a href=&quot;../../api/javascript/config/index&quot;&gt;config&lt;/a&gt; command or by writing to the &lt;code&gt;table_config&lt;/code&gt;&lt;a href=&quot;../system-tables/index&quot;&gt;system table&lt;/a&gt;. The default is &lt;code&gt;majority&lt;/code&gt;, meaning writes will be acknowledged when a majority of (voting) replicas have confirmed their writes. The other possible option is &lt;code&gt;single&lt;/code&gt;, meaning writes will be acknowledged when a single replica acknowledges it.</source>
          <target state="translated">&lt;strong&gt;쓰기 승인&lt;/strong&gt; 은 &lt;a href=&quot;../../api/javascript/config/index&quot;&gt;config&lt;/a&gt; 명령을 사용하거나 &lt;code&gt;table_config&lt;/code&gt; &lt;a href=&quot;../system-tables/index&quot;&gt;시스템 테이블&lt;/a&gt; 에 쓰면 &lt;code&gt;write_acks&lt;/code&gt; 설정으로 테이블별로 설정됩니다 . 기본값은 &lt;code&gt;majority&lt;/code&gt; . 즉, 다수의 (투표) 복제본이 쓰기를 확인하면 쓰기가 승인됩니다. 다른 가능한 옵션은 &lt;code&gt;single&lt;/code&gt; 입니다 . 즉, 단일 복제본이이를 승인하면 쓰기가 승인됩니다.</target>
        </trans-unit>
        <trans-unit id="bffa3ead50f5e7fef625c1cc9053496624c82f75" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You now have a RethinkDB cluster!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이제 RethinkDB 클러스터가 있습니다!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="deb6f5515c303cc9a48f0866adbbd0be0306988a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You now have a RethinkDB cluster!&lt;/strong&gt; Try pointing your browser to &lt;code&gt;localhost:8080&lt;/code&gt; or &lt;code&gt;localhost:8081&lt;/code&gt; to access the web interface. If you click on the &amp;ldquo;Servers&amp;rdquo; tab at the top, you should see both servers in the cluster.</source>
          <target state="translated">&lt;strong&gt;이제 RethinkDB 클러스터가 있습니다! &lt;/strong&gt;웹 인터페이스에 액세스하려면 브라우저를 &lt;code&gt;localhost:8080&lt;/code&gt; 또는 &lt;code&gt;localhost:8081&lt;/code&gt; 로 지정하십시오. 상단의 &quot;서버&quot;탭을 클릭하면 클러스터에 두 서버가 모두 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="dda34b0819c48a91d483548266ee6a92d0f5d330" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You&amp;rsquo;ve now got a working server!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이제 작동하는 서버가 있습니다!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6c11735169a26215864c45335105e4a17b6bbc4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;_Example:&lt;/strong&gt; Subscribe to a document&amp;rsquo;s &lt;a href=&quot;../../../docs/changefeeds/javascript/index&quot;&gt;changefeed&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;_ 예 :&lt;/strong&gt; 문서의 &lt;a href=&quot;../../../docs/changefeeds/javascript/index&quot;&gt;변경&lt;/a&gt; 피드를 구독 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3442b063282f657ef82b0da809b51a7209d6422d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;database&lt;/strong&gt; scope allows the ability to create and drop tables, in addition to the above.</source>
          <target state="translated">&lt;strong&gt;데이터베이스&lt;/strong&gt; 범위는 위의 것 외에도 테이블을 작성하고 삭제하는 기능을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="9153a25e06ec61fa8b4769148563ca81d9a755c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;global&lt;/strong&gt; scope allows the ability to create and drop databases, in addition to the above. (However, a user must have &lt;code&gt;config&lt;/code&gt; permissions for the tables within a database to drop them, which might not be the case if their &lt;code&gt;config&lt;/code&gt; permissions are overridden at a table level; see &lt;a href=&quot;#scopes&quot;&gt;Scopes&lt;/a&gt; below.)</source>
          <target state="translated">&lt;strong&gt;글로벌&lt;/strong&gt; 범위는 위의 것 외에도 데이터베이스를 작성하고 삭제하는 기능을 허용합니다. 그러나 사용자는 데이터베이스 내의 테이블에 대해 테이블을 삭제하기위한 &lt;code&gt;config&lt;/code&gt; 권한이 있어야합니다. &lt;code&gt;config&lt;/code&gt; 권한이 테이블 수준에서 재정 의 된 경우에는 해당되지 않을 수 있습니다. 아래 &lt;a href=&quot;#scopes&quot;&gt;범위를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ba7c89c2ea6ac861cab74ba9bd9fd2a58d18206" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;table&lt;/strong&gt; scope allows creating and dropping &lt;a href=&quot;../secondary-indexes/javascript/index&quot;&gt;secondary indexes&lt;/a&gt; on a table, as well as changing the table&amp;rsquo;s cluster configuration (commands such as &lt;code&gt;reconfigure&lt;/code&gt; and &lt;code&gt;rebalance&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;테이블&lt;/strong&gt; 범위를 사용하면 &lt;strong&gt;테이블의 &lt;/strong&gt;&lt;a href=&quot;../secondary-indexes/javascript/index&quot;&gt;2 차 인덱스&lt;/a&gt; 를 작성 및 삭제 하고 테이블의 클러스터 구성 ( &lt;code&gt;reconfigure&lt;/code&gt; 및 &lt;code&gt;rebalance&lt;/code&gt; 과 같은 명령)을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f745e72e8c0d361a38a4045c079cc2ddfafe0cc4" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;point&amp;rdquo; changefeed returns changes to a single document within a table rather than the table as a whole.</source>
          <target state="translated">&quot;포인트&quot;변경 피드는 테이블 전체가 아닌 테이블 내의 단일 문서에 대한 변경 사항을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b67b65c9338df852c22eacc241db703cc42cab37" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://www.rethinkdb.com/blog/lambda-functions/&quot;&gt;good article&lt;/a&gt; by &lt;a href=&quot;https://github.com/wmrowan&quot;&gt;Bill Rowan&lt;/a&gt; explains anonymous functions (or lambda functions) in the drivers. The article covers why anonymous functions are useful and how they work. Here, we&amp;rsquo;ll just focus on how to serialize anonymous functions.</source>
          <target state="translated">&lt;a href=&quot;http://www.rethinkdb.com/blog/lambda-functions/&quot;&gt;좋은 기사&lt;/a&gt; 로 &lt;a href=&quot;https://github.com/wmrowan&quot;&gt;빌 로완은&lt;/a&gt; 드라이버에서 익명 함수 (또는 람다 함수)을 설명합니다. 이 기사에서는 익명 함수가 유용한 이유와 작동 방식에 대해 설명합니다. 여기서는 익명 함수를 직렬화하는 방법에 중점을 둘 것입니다.</target>
        </trans-unit>
        <trans-unit id="6b1e33de5288da2a7312d7d7516ba04c03818c54" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/packaging/assets/config/default.conf.sample&quot;&gt;sample &lt;code&gt;.conf&lt;/code&gt; file&lt;/a&gt; is available with full comments. (It may already be installed on your distribution as &lt;code&gt;default.conf.sample&lt;/code&gt;.)</source>
          <target state="translated">전체 주석이 포함 된 &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/packaging/assets/config/default.conf.sample&quot;&gt;샘플 &lt;code&gt;.conf&lt;/code&gt; 파일&lt;/a&gt; 이 제공됩니다. 배포판에 이미 &lt;code&gt;default.conf.sample&lt;/code&gt; 로 설치되었을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2959c9e1be85087a56cec94ff8fd43258e0d5e1e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Queue&lt;/code&gt; is used by consumers. It has two purposes:</source>
          <target state="translated">&lt;code&gt;Queue&lt;/code&gt; 소비자가 사용됩니다. 두 가지 목적이 있습니다.</target>
        </trans-unit>
        <trans-unit id="000f4ff9b35e747a30f095413ac32de4f1b39873" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ReqlAuthError&lt;/code&gt; should be thrown if the error code is between 10 and 20 (inclusive).</source>
          <target state="translated">&lt;code&gt;ReqlAuthError&lt;/code&gt; 는 에러 코드가 (10, 20) (포함) 사이 인 경우 발생한다.</target>
        </trans-unit>
        <trans-unit id="3ad9e1e80bcf4c7c0611aa36e1447643ca95a72b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Topic&lt;/code&gt; is used by publishers. It contains some key that contains meta-data about the messages.</source>
          <target state="translated">&lt;code&gt;Topic&lt;/code&gt; 출판사에 의해 사용된다. 메시지에 대한 메타 데이터가 포함 된 키가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="36c4466bba71a83f521cde659de60e580f36611c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;finalEmit&lt;/code&gt; function may also be provided, which will be called at the end of the sequence. It takes a single parameter: the result of the last reduction through the iteration (the accumulator), or the original base value if the input sequence was empty. This function must return a list, which will be appended to &lt;code&gt;fold&lt;/code&gt;&amp;rsquo;s output stream.</source>
          <target state="translated">&lt;code&gt;finalEmit&lt;/code&gt; 의 기능은 시퀀스의 끝에서 호출 될 제공 될 수있다. 반복을 통한 마지막 감소 결과 (누산기) 또는 입력 시퀀스가 ​​비어있는 경우 원래 기본 값이 단일 매개 변수로 사용됩니다. 이 함수는 목록을 반환해야합니다.이 목록은 &lt;code&gt;fold&lt;/code&gt; 의 출력 스트림에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="01bf381896ef5c09c0aa8dfa1843c2d7cd5eb428" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;datum&lt;/em&gt; (the singular of data) is any value that can be represented in JSON: booleans, numbers, strings, objects, arrays and &lt;code&gt;null&lt;/code&gt;. They are sent to the server in JSON form.</source>
          <target state="translated">&lt;em&gt;데이텀&lt;/em&gt; 부울, 숫자, 캐릭터, 오브젝트, 및 배열 (데이터의 단수)가 어떤 JSON 표현할 수 값이 &lt;code&gt;null&lt;/code&gt; . JSON 형식으로 서버에 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="f9641c26b7d295935a36da0e1654720d5abd8c52" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;user&lt;/em&gt; in RethinkDB is similar to users in most other database systems; a database administrator may have a user account, and client applications may be given user accounts. These are unrelated to user accounts that may be implemented within the application.</source>
          <target state="translated">&lt;em&gt;사용자&lt;/em&gt; RethinkDB에서 대부분의 다른 데이터베이스 시스템의 사용자와 유사하다; 데이터베이스 관리자에게는 사용자 계정이있을 수 있으며 클라이언트 응용 프로그램에는 사용자 계정이 제공 될 수 있습니다. 이들은 응용 프로그램 내에서 구현 될 수있는 사용자 계정과 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="83760ed22ea9acee4a1cacb46e00feb25126fb6a" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;Sequence&lt;/strong&gt; is any list data type: arrays, streams, selections, and tables.</source>
          <target state="translated">&lt;strong&gt;순서가&lt;/strong&gt; 있는 목록 데이터 유형 : 배열, 스트림, 선택, 그리고 테이블.</target>
        </trans-unit>
        <trans-unit id="8fab7559009575b91fd187e572f7e7b54a62ce28" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;datum&lt;/strong&gt; is a catch-all term for most non-stream data types, including all basic data types, pseudotypes, objects, and non-stream selections. Datum types do &lt;em&gt;not&lt;/em&gt; include streams (including Selection&amp;lt;Stream&amp;gt;), databases, tables and table slices, and functions.</source>
          <target state="translated">&lt;strong&gt;자료는&lt;/strong&gt; 모든 기본 데이터 타입, pseudotypes, 개체 및 비 스트림 선택을 포함하여 대부분의 비 스트림 데이터 유형에 대한 포괄 용어입니다. 데이텀 유형 에는 스트림 (Selection &amp;lt;Stream&amp;gt; 포함), 데이터베이스, 테이블 및 테이블 슬라이스 및 함수가 포함 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="21f36e926581f5a8e14c0871c43d866f0e20ccf3" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;group&lt;/strong&gt; step that groups the posts based on their category.</source>
          <target state="translated">카테고리를 기준으로 게시물을 그룹화 하는 &lt;strong&gt;그룹&lt;/strong&gt; 단계입니다.</target>
        </trans-unit>
        <trans-unit id="37fed783150ea6e2e78487a8a6cb5ffb3ccaa046" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;map&lt;/strong&gt; operation which filters and/or transforms the elements in the sequence (or each group) into a new sequence (or grouped sequences).</source>
          <target state="translated">시퀀스 (또는 각 그룹)의 요소를 새로운 시퀀스 (또는 그룹화 된 시퀀스)로 필터링 및 / 또는 변환 하는 &lt;strong&gt;맵&lt;/strong&gt; 연산.</target>
        </trans-unit>
        <trans-unit id="3e301139ebfc8b10f8fbee3198b338c0be3b74d1" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;map&lt;/strong&gt; step that transforms each post into the number &lt;code&gt;1&lt;/code&gt; (since we&amp;rsquo;re counting each post once).</source>
          <target state="translated">각 게시물을 한 번 계산하기 때문에 각 게시물을 숫자 &lt;code&gt;1&lt;/code&gt; 로 변환 하는 &lt;strong&gt;지도&lt;/strong&gt; 단계입니다 .</target>
        </trans-unit>
        <trans-unit id="1be7331b0bbfa48f5bd27f537083ad57261877b6" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;reduce&lt;/strong&gt; operation which aggregates the values produced by &lt;strong&gt;map&lt;/strong&gt; into a single value (or a single value for each group).</source>
          <target state="translated">&lt;strong&gt;맵에서&lt;/strong&gt; 생성 된 값을 단일 값 (또는 각 그룹의 단일 값)으로 집계 하는 &lt;strong&gt;축소&lt;/strong&gt; 연산입니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="41815661adc55f1d9970a5053bde6809314f47ea" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;reduce&lt;/strong&gt; step that sums the number of posts for each group.</source>
          <target state="translated">A는 &lt;strong&gt;감소&lt;/strong&gt; 각 그룹 게시물의 수를 요약 단계.</target>
        </trans-unit>
        <trans-unit id="73bf5c35c762156461bace398f27e62e88c1489e" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;reduce&lt;/strong&gt; step that sums the number of posts.</source>
          <target state="translated">A는 &lt;strong&gt;감소&lt;/strong&gt; 게시물의 수를 요약 단계.</target>
        </trans-unit>
        <trans-unit id="c9673ac9a354e3fa5da8acf8e51dfd5e22610c69" translate="yes" xml:space="preserve">
          <source>A Flask extension that adds RethinkDB support (also see the &lt;a href=&quot;https://pypi.python.org/pypi/Flask-RethinkDB/&quot;&gt;pip package&lt;/a&gt;).</source>
          <target state="translated">RethinkDB 지원을 추가하는 Flask 확장 ( &lt;a href=&quot;https://pypi.python.org/pypi/Flask-RethinkDB/&quot;&gt;pip 패키지&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="fd2cb79f36065ba626eadbcee5f46305e13f4ba0" translate="yes" xml:space="preserve">
          <source>A MySQL to RethinkDB migration script.</source>
          <target state="translated">MySQL에서 RethinkDB 로의 마이그레이션 스크립트.</target>
        </trans-unit>
        <trans-unit id="39d7d5600c04b78f133c0bbe7833df579f2b84df" translate="yes" xml:space="preserve">
          <source>A Node.js REPL for RethinkDB.</source>
          <target state="translated">RethinkDB를위한 Node.js REPL.</target>
        </trans-unit>
        <trans-unit id="ff5c54cbb2a5d9c9d840d252c6ee7e6a3af734ab" translate="yes" xml:space="preserve">
          <source>A Node.js module that will execute a nightly backup and push it to S3.</source>
          <target state="translated">야간 백업을 실행하고 S3으로 푸시하는 Node.js 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="f169d3946fa70e2c77062ea57087f03d807e2080" translate="yes" xml:space="preserve">
          <source>A Puppet module for RethinkDB.</source>
          <target state="translated">RethinkDB 용 퍼펫 모듈.</target>
        </trans-unit>
        <trans-unit id="5707ab080e2932c76243aaca326b2ffd594bc92c" translate="yes" xml:space="preserve">
          <source>A Python ORM for RethinkDB.</source>
          <target state="translated">RethinkDB를위한 Python ORM.</target>
        </trans-unit>
        <trans-unit id="3b00fb35a0e66f3f3c5f2910f8e1b3716bb6b432" translate="yes" xml:space="preserve">
          <source>A Python object mapper in the style of &lt;a href=&quot;https://cloud.google.com/appengine/docs/python/ndb/&quot;&gt;App Engine NDB&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://cloud.google.com/appengine/docs/python/ndb/&quot;&gt;App Engine NDB&lt;/a&gt; 스타일의 Python 객체 매퍼 .</target>
        </trans-unit>
        <trans-unit id="481da918ab2b3b2ea60b5b0fe3a1884028dc9ecf" translate="yes" xml:space="preserve">
          <source>A ReQL document is a JSON object: a set of key-value pairs, in which each value might be a single value, a list of values, or &lt;em&gt;another&lt;/em&gt; set of key-value pairs. When the value of a field contains more fields, we describe these as &lt;em&gt;nested fields.&lt;/em&gt;</source>
          <target state="translated">ReQL 문서는 JSON 객체입니다. 키-값 쌍 세트. 각 값은 단일 값, 값 목록 또는 &lt;em&gt;다른&lt;/em&gt; 키-값 쌍 세트 일 수 있습니다. 필드 값에 더 많은 필드가 포함 된 경우이를 &lt;em&gt;중첩 필드&lt;/em&gt; 로 설명 &lt;em&gt;합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dc545da09ef5cc39b89d289701b7bb6dbd9781dd" translate="yes" xml:space="preserve">
          <source>A RethinkDB adapter for &lt;a href=&quot;https://github.com/1602/jugglingdb&quot;&gt;JugglingDB&lt;/a&gt;, a multi-database ORM for Node.js.</source>
          <target state="translated">Node.js의 다중 데이터베이스 ORM 인 &lt;a href=&quot;https://github.com/1602/jugglingdb&quot;&gt;JugglingDB&lt;/a&gt; 용 RethinkDB 어댑터</target>
        </trans-unit>
        <trans-unit id="6ff030262b5fdf35d8dca1c2e35ba5200e071245" translate="yes" xml:space="preserve">
          <source>A RethinkDB adapter for &lt;a href=&quot;https://github.com/js-data/js-data&quot;&gt;js-data&lt;/a&gt;, a database-agnostic ORM for Node.js and the browser.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/js-data/js-data&quot;&gt;js-data&lt;/a&gt; 용 RethinkDB 어댑터 , Node.js 용 데이터베이스 인식 ORM 및 브라우저.</target>
        </trans-unit>
        <trans-unit id="7db74b2e7fd5d6a2c384fed93b03b660fe9170e3" translate="yes" xml:space="preserve">
          <source>A RethinkDB adapter for &lt;a href=&quot;https://github.com/lotus/model&quot;&gt;Lotus::Model&lt;/a&gt;, a persistence framework for Ruby.</source>
          <target state="translated">Ruby의 지속성 프레임 워크 인 &lt;a href=&quot;https://github.com/lotus/model&quot;&gt;Lotus :: Model&lt;/a&gt; 용 RethinkDB 어댑터 .</target>
        </trans-unit>
        <trans-unit id="ab791ca4787f9652adfa567ee368d43651a9639a" translate="yes" xml:space="preserve">
          <source>A RethinkDB cluster using multiple machines</source>
          <target state="translated">여러 머신을 사용하는 RethinkDB 클러스터</target>
        </trans-unit>
        <trans-unit id="cc2df0f5e4d2f4f57a02e9695dd2170a529f9be4" translate="yes" xml:space="preserve">
          <source>A RethinkDB cookbook for Chef deployment.</source>
          <target state="translated">Chef 배포를위한 RethinkDB 쿡북.</target>
        </trans-unit>
        <trans-unit id="3a5e6301e7c0dfca1b6114ef0e226d3670948483" translate="yes" xml:space="preserve">
          <source>A RethinkDB session store for Connect, similar to connect-redis.</source>
          <target state="translated">connect-redis와 비슷한 Connect 용 RethinkDB 세션 저장소입니다.</target>
        </trans-unit>
        <trans-unit id="7269f6b4ee80d5e5e14e4d7040722fcaeb2bdded" translate="yes" xml:space="preserve">
          <source>A Ruby ORM designed for RethinkDB. (Read our &lt;a href=&quot;../rails/index&quot;&gt;quickstart tutorial&lt;/a&gt;.)</source>
          <target state="translated">RethinkDB를 위해 설계된 루비 ORM. ( &lt;a href=&quot;../rails/index&quot;&gt;빠른 시작 자습서를&lt;/a&gt; 읽으십시오 .)</target>
        </trans-unit>
        <trans-unit id="e97ac3aacc40bf362db1386a09db5e6d08d643c8" translate="yes" xml:space="preserve">
          <source>A WebGL molecule viewer (by &lt;a href=&quot;https://github.com/psb&quot;&gt;@psb&lt;/a&gt;).</source>
          <target state="translated">WebGL 분자 뷰어 ( &lt;a href=&quot;https://github.com/psb&quot;&gt;@psb 기준&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="481a6822241ae3895515147ff9224f9ea2ae3680" translate="yes" xml:space="preserve">
          <source>A bitwise AND is a binary operation that takes two equal-length binary representations and performs the logical AND operation on each pair of the corresponding bits, which is equivalent to multiplying them. Thus, if both bits in the compared position are 1, the bit in the resulting binary representation is 1 (1 &amp;times; 1 = 1); otherwise, the result is 0 (1 &amp;times; 0 = 0 and 0 &amp;times; 0 = 0).</source>
          <target state="translated">비트 AND는 두 개의 동일한 길이 이진 표현을 사용하고 해당 비트의 각 쌍에 대해 논리 AND 연산을 수행하는 이진 연산으로, 곱하는 것과 같습니다. 따라서 비교 위치의 두 비트가 모두 1이면 결과 이진 표현의 비트는 1 (1 &amp;times; 1 = 1)입니다. 그렇지 않으면 결과는 0입니다 (1 &amp;times; 0 = 0 및 0 &amp;times; 0 = 0).</target>
        </trans-unit>
        <trans-unit id="90aba26a9a1435f6d0b401ccb567fe119ba901b0" translate="yes" xml:space="preserve">
          <source>A bitwise NOT, or complement, is a unary operation that performs logical negation on each bit, forming the ones&amp;rsquo; complement of the given binary value. Bits that are 0 become 1, and those that are 1 become 0.</source>
          <target state="translated">비트 NOT 또는 보수는 각 비트에 대해 논리적 부정을 수행하여 주어진 이진 값의 1의 보수를 형성하는 단항 연산입니다. 0 인 비트는 1이되고 1 인 비트는 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="4038983ab75e15cd055fe77e33686aeb4ebe7323" translate="yes" xml:space="preserve">
          <source>A bitwise OR is a binary operation that takes two bit patterns of equal length and performs the logical inclusive OR operation on each pair of corresponding bits. The result in each position is 0 if both bits are 0, while otherwise the result is 1.</source>
          <target state="translated">비트 OR은 동일한 길이의 두 비트 패턴을 사용하고 해당 비트의 각 쌍에 대해 논리적 포함 OR 연산을 수행하는 이진 연산입니다. 두 비트가 모두 0이면 각 위치의 결과는 0이고 그렇지 않으면 결과는 1입니다.</target>
        </trans-unit>
        <trans-unit id="7834b5a949982d94d5e67a015d0614b26f95af2e" translate="yes" xml:space="preserve">
          <source>A bitwise XOR is a binary operation that takes two bit patterns of equal length and performs the logical exclusive OR operation on each pair of corresponding bits. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1. In this we perform the comparison of two bits, being 1 if the two bits are different, and 0 if they are the same.</source>
          <target state="translated">비트 XOR은 동일한 길이의 두 비트 패턴을 사용하고 해당 비트의 각 쌍에 대해 논리적 배타적 OR 연산을 수행하는 이진 연산입니다. 첫 번째 비트 만 1이거나 두 번째 비트 만 1이면 각 위치의 결과는 1이지만 둘 다 0이거나 둘 다 1이면 0이됩니다. 여기서 우리는 두 비트의 비교를 수행합니다. 비트는 다르며 같으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="3c3cc7ba733f3913cfec1642d6d7bbed00a28609" translate="yes" xml:space="preserve">
          <source>A changefeed is handled like any other stream; when you pass a block to &lt;code&gt;em_run&lt;/code&gt;, the block is called with each document received on the feed. If you pass a &lt;code&gt;Handler&lt;/code&gt; that defines &lt;code&gt;on_stream_val&lt;/code&gt; (or &lt;code&gt;on_val&lt;/code&gt;), those methods will be called with each document.</source>
          <target state="translated">변경 피드는 다른 스트림과 같이 처리됩니다. &lt;code&gt;em_run&lt;/code&gt; 에 블록을 전달 하면 피드에서 수신 된 각 문서와 함께 블록이 호출됩니다. &lt;code&gt;on_stream_val&lt;/code&gt; (또는 &lt;code&gt;on_val&lt;/code&gt; ) 을 정의 하는 &lt;code&gt;Handler&lt;/code&gt; 를 전달하면 해당 메소드가 각 문서와 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4b2edcbc9e5fe042e98c84bd42c18c93f9404dcf" translate="yes" xml:space="preserve">
          <source>A collection of Dockerfiles and configurations to build images for RethinkDB.</source>
          <target state="translated">RethinkDB 용 이미지를 빌드하기위한 Dockerfile 및 구성 모음입니다.</target>
        </trans-unit>
        <trans-unit id="b52a026f38087af13243d6dad62e0a456a03f403" translate="yes" xml:space="preserve">
          <source>A common data access task is retrieving one document with associated &amp;ldquo;child&amp;rdquo; documents. (This would often be in a one-to-many relationship as shown here, but could be a many-to-many or one-to-one relationship.) In our example data set, we might want to retrieve information about a company and all its employees. We can do this in one ReQL command using &lt;code&gt;merge&lt;/code&gt; and a subquery in its lambda function.</source>
          <target state="translated">일반적인 데이터 액세스 작업은 &quot;자식&quot;문서와 연관된 하나의 문서를 검색하는 것입니다. (이것은 종종 여기에 표시된 것처럼 일대 다 관계 일 수 있지만 다 대다 또는 일대일 관계 일 수 있습니다.) 예제 데이터 세트에서 회사에 대한 정보를 검색 할 수 있습니다. 그리고 모든 직원. 우리는 하나의 ReQL 명령 으로 람다 함수에서 &lt;code&gt;merge&lt;/code&gt; 와 하위 쿼리를 사용하여이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10101ea2e2c34c0c5cb07db9caf58df86a642d40" translate="yes" xml:space="preserve">
          <source>A data browser/editor for RethinkDB. Available as a native application for Mac, Win and Linux.</source>
          <target state="translated">RethinkDB 용 데이터 브라우저 / 편집기. Mac, Win 및 Linux 용 기본 애플리케이션으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62cab2fec4306d3caa696473d6835476add0efd0" translate="yes" xml:space="preserve">
          <source>A dump of the &lt;a href=&quot;../system-tables/index&quot;&gt;system tables&lt;/a&gt; (see below)</source>
          <target state="translated">&lt;a href=&quot;../system-tables/index&quot;&gt;시스템 테이블&lt;/a&gt; 덤프 (아래 참조)</target>
        </trans-unit>
        <trans-unit id="219839ffd078f193ddaa48103c123e1488b902a7" translate="yes" xml:space="preserve">
          <source>A dump of the &lt;code&gt;rethinkdb._debug_table_status&lt;/code&gt; table (a &amp;ldquo;hidden&amp;rdquo; table in the &lt;code&gt;rethinkdb&lt;/code&gt; system database)</source>
          <target state="translated">&lt;code&gt;rethinkdb._debug_table_status&lt;/code&gt; 테이블 의 덤프 ( &lt;code&gt;rethinkdb&lt;/code&gt; 시스템 데이터베이스 의 &quot;숨겨진&quot;테이블 )</target>
        </trans-unit>
        <trans-unit id="a793fff24ff78b05d4b3abc967d7d91a4497fd32" translate="yes" xml:space="preserve">
          <source>A few restrictions exist on the arguments:</source>
          <target state="translated">인수에는 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="11eea1ce2b203ac661abdcce8d3bd0b4b4bfdf3a" translate="yes" xml:space="preserve">
          <source>A fork of &lt;a href=&quot;https://github.com/neumino/thinky&quot;&gt;Thinky&lt;/a&gt; with first-class support for &lt;a href=&quot;http://json-schema.org&quot;&gt;JSON Schema&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://json-schema.org&quot;&gt;JSON Schema에&lt;/a&gt; 대한 일류 지원을 제공 하는 &lt;a href=&quot;https://github.com/neumino/thinky&quot;&gt;Thinky&lt;/a&gt; of 포크 .</target>
        </trans-unit>
        <trans-unit id="c21ee3df26f594e64acf65348b4fae18d1cbde20" translate="yes" xml:space="preserve">
          <source>A general-purpose model loader for the &lt;a href=&quot;https://github.com/neumino/thinky&quot;&gt;Thinky&lt;/a&gt; ORM. (Supersedes sails-hook-thinky.)</source>
          <target state="translated">&lt;a href=&quot;https://github.com/neumino/thinky&quot;&gt;Thinky&lt;/a&gt; ORM을 위한 범용 모델 로더 . 돛을 얇게 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="aadbfb87038c81fce3c26d9a6007eb0bfad32432" translate="yes" xml:space="preserve">
          <source>A geospatial index field should contain only geometry objects. It will work with geometry ReQL terms (&lt;a href=&quot;../get_intersecting/index&quot;&gt;getIntersecting&lt;/a&gt; and &lt;a href=&quot;../get_nearest/index&quot;&gt;getNearest&lt;/a&gt;) as well as index-specific terms (&lt;a href=&quot;../index_status/index&quot;&gt;indexStatus&lt;/a&gt;, &lt;a href=&quot;../index_wait/index&quot;&gt;indexWait&lt;/a&gt;, &lt;a href=&quot;../index_drop/index&quot;&gt;indexDrop&lt;/a&gt; and &lt;a href=&quot;../index_list/index&quot;&gt;indexList&lt;/a&gt;). Using terms that rely on non-geometric ordering such as &lt;a href=&quot;../get_all/index&quot;&gt;getAll&lt;/a&gt;, &lt;a href=&quot;../order_by/index&quot;&gt;orderBy&lt;/a&gt; and &lt;a href=&quot;../between/index&quot;&gt;between&lt;/a&gt; will result in an error.</source>
          <target state="translated">지리 공간 인덱스 필드는 지오메트리 객체 만 포함해야합니다. 인덱스 특정 용어 ( &lt;a href=&quot;../index_status/index&quot;&gt;indexStatus&lt;/a&gt; , &lt;a href=&quot;../index_wait/index&quot;&gt;indexWait&lt;/a&gt; , &lt;a href=&quot;../index_drop/index&quot;&gt;indexDrop&lt;/a&gt; 및 &lt;a href=&quot;../index_list/index&quot;&gt;indexList&lt;/a&gt; ) 뿐만 아니라 기하학 ReQL 용어 ( &lt;a href=&quot;../get_intersecting/index&quot;&gt;getIntersecting&lt;/a&gt; 및 &lt;a href=&quot;../get_nearest/index&quot;&gt;getNearest&lt;/a&gt; )와 함께 작동 합니다. &lt;a href=&quot;../get_all/index&quot;&gt;getAll&lt;/a&gt; , &lt;a href=&quot;../order_by/index&quot;&gt;orderBy&lt;/a&gt; 및 &lt;a href=&quot;../between/index&quot;&gt;between&lt;/a&gt; 와 같은 비 기하학적 순서에 의존하는 용어를 사용 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8048a90dd5efc9f2d16380ccfdc5ae8a0c59d518" translate="yes" xml:space="preserve">
          <source>A key point to notice is that we don&amp;rsquo;t actually care about the document being stored in the table. We only create and update documents because that forces RethinkDB to create a change notification. These change notifications are the messages we want to send to subscribers. Ultimately, the table ends up with lots of documents that have whatever the last message happened to be inside them. But at no point do we read those documents directly as a subscriber. This is also why we update the &lt;code&gt;updated_on&lt;/code&gt; field, so that even if the document&amp;rsquo;s payload hasn&amp;rsquo;t changed, the document as a whole will change and a notification will be generated.</source>
          <target state="translated">주목할 점은 실제로 테이블에 저장된 문서에 관심이 없다는 것입니다. RethinkDB는 변경 알림을 작성해야하므로 문서 만 작성하고 업데이트합니다. 이러한 변경 알림은 가입자에게 보내려는 메시지입니다. 결국 테이블에는 마지막 메시지가 들어간 문서가 많이 있습니다. 그러나 우리는 그 문서를 가입자로서 직접 읽지 않습니다. 따라서 우리는 &lt;code&gt;updated_on&lt;/code&gt; 필드를 업데이트하여 문서의 페이로드가 변경되지 않은 경우에도 문서 전체가 변경되고 알림이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="cd005c5fa838f674cba1488867221cf3dc7e49f2" translate="yes" xml:space="preserve">
          <source>A light abstraction layer over RethinkDB adding methods you &amp;ldquo;wished you had.&amp;rdquo;</source>
          <target state="translated">RethinkDB에 대한 가벼운 추상화 계층으로,&amp;ldquo;귀하가 원하는 것&amp;rdquo;을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="cf199661827ddb2c1d48018782ba0280f240a043" translate="yes" xml:space="preserve">
          <source>A light persistence framework for RethinkDB.</source>
          <target state="translated">RethinkDB를위한 가벼운 지속성 프레임 워크.</target>
        </trans-unit>
        <trans-unit id="e5c458838167072d1411ee0107bf79b9afc5c0b7" translate="yes" xml:space="preserve">
          <source>A majority (greater than half) of replicas for the table must be available</source>
          <target state="translated">테이블의 대다수 (반 이상) 복제본을 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8c534ebb5db5df1cac602a6e41637d1d1a18249a" translate="yes" xml:space="preserve">
          <source>A more complex example</source>
          <target state="translated">더 복잡한 예</target>
        </trans-unit>
        <trans-unit id="919c4ccf1b6e0902b903294a07f260c83dedb90a" translate="yes" xml:space="preserve">
          <source>A new RethinkDB cluster always has one user named &lt;code&gt;admin&lt;/code&gt;; this user always has all permissions at a global scope, and the user cannot be deleted. By default, the &lt;code&gt;admin&lt;/code&gt; user has no password. You can change this by updating the &lt;code&gt;admin&lt;/code&gt; user document, or by specifying the &lt;code&gt;--initial-password&lt;/code&gt;&lt;a href=&quot;../cli-options/index&quot;&gt;command line option&lt;/a&gt; on startup.</source>
          <target state="translated">새로운 RethinkDB 클러스터에는 항상 &lt;code&gt;admin&lt;/code&gt; 이라는 하나의 사용자가 있습니다 . 이 사용자는 항상 전역 범위에서 모든 권한을 가지며 사용자를 삭제할 수 없습니다. 기본적으로 &lt;code&gt;admin&lt;/code&gt; 에게는 비밀번호가 없습니다. &lt;code&gt;admin&lt;/code&gt; 문서 를 업데이트 하거나 시작시 &lt;code&gt;--initial-password&lt;/code&gt; &lt;a href=&quot;../cli-options/index&quot;&gt;명령 행 옵션&lt;/a&gt; 을 지정하여 이를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc8bd6d5f49c401c405ffc7ba82519b2d080d2c8" translate="yes" xml:space="preserve">
          <source>A noreply query is executed by passing the &lt;code&gt;noreply&lt;/code&gt; option to the &lt;a href=&quot;../run/index&quot;&gt;run&lt;/a&gt; command, indicating that &lt;code&gt;run()&lt;/code&gt; should not wait for the query to complete before returning. You may also explicitly wait for a noreply query to complete by using the &lt;a href=&quot;../noreply_wait/index&quot;&gt;noreplyWait&lt;/a&gt; command.</source>
          <target state="translated">&lt;code&gt;noreply&lt;/code&gt; 옵션은 &lt;a href=&quot;../run/index&quot;&gt;run&lt;/a&gt; 명령에 noreply 옵션을 전달하여 실행되며 쿼리를 반환하기 전에 &lt;code&gt;run()&lt;/code&gt; 이 완료 될 때까지 기다리지 않아야 함을 나타냅니다 . &lt;a href=&quot;../noreply_wait/index&quot;&gt;noreplyWait&lt;/a&gt; 명령 을 사용하여 noreply 조회가 완료 될 때까지 명시 적으로 기다릴 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ae22814e11fd8f1e6e99873f2b0e64ec9792251" translate="yes" xml:space="preserve">
          <source>A primary key other than &lt;code&gt;id&lt;/code&gt; can be specified with &lt;code&gt;--pkey&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;--pkey&lt;/code&gt; 로 &lt;code&gt;id&lt;/code&gt; 이외의 기본 키를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="71e60156b75dfc034bc24e840fcec336b3298eca" translate="yes" xml:space="preserve">
          <source>A proxy node doesn&amp;rsquo;t store any data; instead it acts as a query router. This offers some performance advantages:</source>
          <target state="translated">프록시 노드는 데이터를 저장하지 않습니다. 대신 쿼리 라우터 역할을합니다. 이것은 몇 가지 성능 이점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bed635cf34a1d0e7299ed072f8cd1ed54746a231" translate="yes" xml:space="preserve">
          <source>A quick example</source>
          <target state="translated">간단한 예</target>
        </trans-unit>
        <trans-unit id="6b57b5bb56ed01fed3a26f0dc9816a82a6ad1755" translate="yes" xml:space="preserve">
          <source>A quick overview of the results</source>
          <target state="translated">결과에 대한 빠른 개요</target>
        </trans-unit>
        <trans-unit id="d254a0f71d1d47c55c65d73ab435f2d3a69c306b" translate="yes" xml:space="preserve">
          <source>A server can be given tags with the &lt;code&gt;--server-tag&lt;/code&gt; option on startup:</source>
          <target state="translated">시작시 &lt;code&gt;--server-tag&lt;/code&gt; 옵션을 사용하여 서버에 태그를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7ff3680ca10fa5d597fe2435422b1c63141d496" translate="yes" xml:space="preserve">
          <source>A setting of 60 (the default for Ubuntu) means that your system will start using swap when RAM usage is at about 40%. If you&amp;rsquo;d like this to be closer to 90%, set the swappiness to 10. You can do that by editing the &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; file (as root) and change the setting there:</source>
          <target state="translated">60 (Ubuntu의 기본값) 설정은 RAM 사용량이 약 40 % 일 때 시스템이 스왑을 사용하기 시작 함을 의미합니다. 90 %에 가깝게하려면 swappiness를 10으로 설정하십시오. &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 파일 을 편집하여 (루트 권한 으로) 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef9a0fd067a069f8a981525ac99700b421453ab1" translate="yes" xml:space="preserve">
          <source>A shorter way to execute this query is to use &lt;a href=&quot;../count/index&quot;&gt;count&lt;/a&gt;.</source>
          <target state="translated">이 쿼리를 실행하는 더 짧은 방법은 &lt;a href=&quot;../count/index&quot;&gt;count&lt;/a&gt; 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="25825cb5a0c2d79aac7708fe474071bc681ff2f4" translate="yes" xml:space="preserve">
          <source>A shorter way to execute this query is to use &lt;a href=&quot;../max/index&quot;&gt;max&lt;/a&gt;.</source>
          <target state="translated">이 쿼리를 실행하는 더 짧은 방법은 &lt;a href=&quot;../max/index&quot;&gt;max&lt;/a&gt; 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="640037bbc9451505457405eded56d8b133c22082" translate="yes" xml:space="preserve">
          <source>A shorter way to execute this query is to use &lt;a href=&quot;count/index&quot;&gt;count&lt;/a&gt;.</source>
          <target state="translated">이 쿼리를 실행하는 더 짧은 방법은 &lt;a href=&quot;count/index&quot;&gt;count&lt;/a&gt; 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="4839f2fd3dd94a2ce4821a5c1a177070b572695c" translate="yes" xml:space="preserve">
          <source>A simple Docker image for RethinkDB.</source>
          <target state="translated">RethinkDB를위한 간단한 Docker 이미지.</target>
        </trans-unit>
        <trans-unit id="70621a0f48951eebc4ae5652938bda7d1dff4f7b" translate="yes" xml:space="preserve">
          <source>A simple Pastie app.</source>
          <target state="translated">간단한 Pastie 앱.</target>
        </trans-unit>
        <trans-unit id="ac67d735bb65921339e0e601e694eac628d913d0" translate="yes" xml:space="preserve">
          <source>A simple but powerful and extensible Object Document Mapper for RethinkDB. (Also see the &lt;a href=&quot;https://pypi.python.org/pypi/Remodel&quot;&gt;pip package&lt;/a&gt;.)</source>
          <target state="translated">RethinkDB를위한 간단하면서도 강력하고 확장 가능한 Object Document Mapper. ( &lt;a href=&quot;https://pypi.python.org/pypi/Remodel&quot;&gt;pip 패키지&lt;/a&gt; 도 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="40cf8919ea34c404a49fa4a02115691af647ed4f" translate="yes" xml:space="preserve">
          <source>A simple example</source>
          <target state="translated">간단한 예</target>
        </trans-unit>
        <trans-unit id="937288f0e816329a979c9a266fb1923c2536d457" translate="yes" xml:space="preserve">
          <source>A simple example in Python:</source>
          <target state="translated">파이썬의 간단한 예 :</target>
        </trans-unit>
        <trans-unit id="bc152dfc80604b5e6478523e986591a6f3951c56" translate="yes" xml:space="preserve">
          <source>A store-agnostic object data mapper for Node.js with support for RethinkDB.</source>
          <target state="translated">RethinkDB를 지원하는 Node.js 용 스토어 독립적 인 오브젝트 데이터 맵퍼.</target>
        </trans-unit>
        <trans-unit id="0a510e62bdd6df6bac6db01f36adc46498e210a2" translate="yes" xml:space="preserve">
          <source>A table may have up to 64 shards.</source>
          <target state="translated">테이블에는 최대 64 개의 샤드가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f48895a8543044fc22fa3f47676b3693884b39a3" translate="yes" xml:space="preserve">
          <source>A table on the cluster is missing at least one replica. The &lt;code&gt;description&lt;/code&gt; string will depend on the roles the missing server(s) played in the table. If the table is not available for reads and/or writes, &lt;code&gt;critical&lt;/code&gt; will be &lt;code&gt;true&lt;/code&gt;; if the table can be both read from and written to, it will be &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">클러스터의 테이블에 하나 이상의 복제본이 없습니다. &lt;code&gt;description&lt;/code&gt; 문자열은 테이블에서하는 역할 누락 된 서버 (들)에 따라 달라집니다. 테이블을 읽기 및 / 또는 쓰기에 사용할 수없는 경우 &lt;code&gt;critical&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 입니다 . 테이블을 읽고 쓸 수 있으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="849803a4d7a410bc181c945dd4cb827375b42768" translate="yes" xml:space="preserve">
          <source>A table will lose availability temporarily after &lt;code&gt;rebalance&lt;/code&gt; is called; use the &lt;a href=&quot;../wait/index&quot;&gt;wait&lt;/a&gt; command to wait for the table to become available again, or &lt;a href=&quot;../status/index&quot;&gt;status&lt;/a&gt; to check if the table is available for writing.</source>
          <target state="translated">&lt;code&gt;rebalance&lt;/code&gt; 이 호출 된 후 테이블은 일시적으로 가용성을 상실합니다 . &lt;a href=&quot;../wait/index&quot;&gt;wait&lt;/a&gt; 명령을 사용하여 테이블을 다시 사용할 수있게 될 때까지 기다리거나 테이블을 쓸 수 있는지 확인하는 &lt;a href=&quot;../status/index&quot;&gt;상태&lt;/a&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ab89d35a983a1cf9755d204a27b5332d28fc9286" translate="yes" xml:space="preserve">
          <source>A table will lose availability temporarily after &lt;code&gt;reconfigure&lt;/code&gt; is called; use the &lt;a href=&quot;../wait/index&quot;&gt;wait&lt;/a&gt; command to wait for the table to become available again, or &lt;a href=&quot;../status/index&quot;&gt;status&lt;/a&gt; to check if the table is available for writing.</source>
          <target state="translated">&lt;code&gt;reconfigure&lt;/code&gt; 이 호출 된 후 테이블은 일시적으로 가용성을 상실합니다 . &lt;a href=&quot;../wait/index&quot;&gt;wait&lt;/a&gt; 명령을 사용하여 테이블을 다시 사용할 수있게 될 때까지 기다리거나 테이블을 쓸 수 있는지 확인하는 &lt;a href=&quot;../status/index&quot;&gt;상태&lt;/a&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="387273326f74c4c543073f73a99f41bd9c3e066d" translate="yes" xml:space="preserve">
          <source>A third option is to specify how many seconds to wait between squashes. Passing &lt;code&gt;squash: 5&lt;/code&gt; to the &lt;code&gt;changes&lt;/code&gt; command tells RethinkDB to squash changes together every five seconds. Depending on your application&amp;rsquo;s use case, this might reduce the load on the server. A number passed to &lt;code&gt;squash&lt;/code&gt; may be a float. Note that the requested interval is not guaranteed, but is rather a best effort.</source>
          <target state="translated">세 번째 옵션은 스쿼시 간 대기 시간 (초)을 지정하는 것입니다. &lt;code&gt;squash: 5&lt;/code&gt; 를 &lt;code&gt;changes&lt;/code&gt; 명령으로 전달하면 RethinkDB가 5 초마다 변경 사항을 함께 스쿼시하도록 지시합니다. 응용 프로그램의 사용 사례에 따라 서버의로드가 줄어들 수 있습니다. &lt;code&gt;squash&lt;/code&gt; 전달 된 숫자는 부 동일 수 있습니다. 요청 된 간격이 보장되는 것은 아니지만 최선의 노력입니다.</target>
        </trans-unit>
        <trans-unit id="df8abcb0fdb97dd60ce85d3221c8a8a46f00b11d" translate="yes" xml:space="preserve">
          <source>A typical document in the &lt;code&gt;posts&lt;/code&gt; table would look like this:</source>
          <target state="translated">&lt;code&gt;posts&lt;/code&gt; 테이블 의 일반적인 문서 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea11b582e396938b2a9993f2d047d8e549136a08" translate="yes" xml:space="preserve">
          <source>A web.py blog application.</source>
          <target state="translated">web.py 블로그 애플리케이션.</target>
        </trans-unit>
        <trans-unit id="6ffe2fd5b73977736945ee09cd1dff287892c2d9" translate="yes" xml:space="preserve">
          <source>AGGREGATIONS</source>
          <target state="translated">AGGREGATIONS</target>
        </trans-unit>
        <trans-unit id="f2ad758ac7c17209f48acde3f5e4f71a90cfea21" translate="yes" xml:space="preserve">
          <source>AMI configuration</source>
          <target state="translated">AMI 구성</target>
        </trans-unit>
        <trans-unit id="b276f94cd8d0e74a21de6e5939b8c10ca9a975d6" translate="yes" xml:space="preserve">
          <source>API Reference</source>
          <target state="translated">API 참조</target>
        </trans-unit>
        <trans-unit id="d6236f068d543e713c7020d809575c0443a95d2f" translate="yes" xml:space="preserve">
          <source>API documentation for &lt;code&gt;grant&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;grant&lt;/code&gt; 대한 API 문서 :</target>
        </trans-unit>
        <trans-unit id="89c25a6e98b7d12432623429744aea6cf501424a" translate="yes" xml:space="preserve">
          <source>API reference</source>
          <target state="translated">API 참조</target>
        </trans-unit>
        <trans-unit id="5e9721fc8e371de49ea6e0eaf26f96866618f352" translate="yes" xml:space="preserve">
          <source>Abstract data types</source>
          <target state="translated">추상 데이터 유형</target>
        </trans-unit>
        <trans-unit id="d1c027cbc40dd6184144940a65ae09fa8b5fe8c6" translate="yes" xml:space="preserve">
          <source>Accept the self-signed SSL certificate. (How to do this is browser-dependent.)</source>
          <target state="translated">자체 서명 된 SSL 인증서를 승인하십시오. (이 작업을 수행하는 방법은 브라우저에 따라 다릅니다.)</target>
        </trans-unit>
        <trans-unit id="3a9f8039f037bd16e10d637f8263f7299e86df11" translate="yes" xml:space="preserve">
          <source>Accepts &lt;a href=&quot;https://github.com/google/re2/wiki/Syntax&quot;&gt;RE2 syntax&lt;/a&gt;. You can enable case-insensitive matching by prefixing the regular expression with &lt;code&gt;(?i)&lt;/code&gt;. See the linked RE2 documentation for more flags.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/google/re2/wiki/Syntax&quot;&gt;RE2 구문을&lt;/a&gt; 허용 합니다 . 정규식 앞에 &lt;code&gt;(?i)&lt;/code&gt; 접두사를 사용하여 대소 문자를 구분하지 않는 일치를 사용할 수 있습니다 . 자세한 플래그는 링크 된 RE2 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="633956adef4571a0b46746baee765485a33151a0" translate="yes" xml:space="preserve">
          <source>Access the system tables through the &lt;code&gt;rethinkdb&lt;/code&gt; database. These tables aren&amp;rsquo;t real RethinkDB document stores the way user-created tables are, but rather &amp;ldquo;table-like&amp;rdquo; interfaces to the system allowing most ReQL commands to be used for control. System tables cannot be created, dropped, reconfigured, or renamed.</source>
          <target state="translated">&lt;code&gt;rethinkdb&lt;/code&gt; 데이터베이스를 통해 시스템 테이블에 액세스하십시오 . 이 테이블은 실제 RethinkDB 문서가 아니라 사용자가 만든 테이블의 방식을 저장하는 것이 아니라 대부분의 ReQL 명령을 제어하는 ​​데 사용할 수있는 시스템의 &quot;테이블과 유사한&quot;인터페이스입니다. 시스템 테이블을 작성, 삭제, 재구성 또는 이름을 바꿀 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="48f7ed988db55729ffd994b303676286b2d69dc6" translate="yes" xml:space="preserve">
          <source>Accessing HTTP APIs</source>
          <target state="translated">HTTP API에 액세스</target>
        </trans-unit>
        <trans-unit id="b67bc8c167efc1fcf5e717140dd60d3a665c74e4" translate="yes" xml:space="preserve">
          <source>Accessing JSON APIs</source>
          <target state="translated">JSON API에 액세스</target>
        </trans-unit>
        <trans-unit id="b61d35fdc1e88b15df7e740307ca5cffb53cca0d" translate="yes" xml:space="preserve">
          <source>Accessing ReQL</source>
          <target state="translated">ReQL에 액세스</target>
        </trans-unit>
        <trans-unit id="807659a6b78e7f6d6958d0799efa81e598489d25" translate="yes" xml:space="preserve">
          <source>Accessing nested fields</source>
          <target state="translated">중첩 된 필드에 액세스</target>
        </trans-unit>
        <trans-unit id="f5b1d235c682e6d1c27aa20f2c97ea4c74e2e4fc" translate="yes" xml:space="preserve">
          <source>Add a couple points:</source>
          <target state="translated">몇 가지 포인트를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="4e0c0548918f535c4b61054cda98105ede8054ca" translate="yes" xml:space="preserve">
          <source>Add a geospatial index on the table (required for certain operations like &lt;code&gt;getNearest&lt;/code&gt;):</source>
          <target state="translated">테이블에 지리 공간 인덱스를 추가하십시오 ( &lt;code&gt;getNearest&lt;/code&gt; 와 같은 특정 조작에 필요함 ).</target>
        </trans-unit>
        <trans-unit id="acc14fcd0e24d8767d3bfaf409eef3a79f14e2fe" translate="yes" xml:space="preserve">
          <source>Add a several values to an array and return it as a set (an array with distinct values).</source>
          <target state="translated">배열에 여러 값을 추가하고이를 세트 (고유 한 값을 가진 배열)로 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="2cf56f40352635b7a4d1144a814c41a7edcee0f2" translate="yes" xml:space="preserve">
          <source>Add a value to an array and return it as a set (an array with distinct values).</source>
          <target state="translated">배열에 값을 추가하고이를 집합 (고유 한 값을 가진 배열)으로 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="404947395acc52a2a5daf343c7642cff8135bc35" translate="yes" xml:space="preserve">
          <source>Add steps on how to reproduce the issue</source>
          <target state="translated">문제를 재현하는 방법에 대한 단계 추가</target>
        </trans-unit>
        <trans-unit id="23234ec229a2c87a0d72f26fed60bb81479461a3" translate="yes" xml:space="preserve">
          <source>Adding a node to a RethinkDB cluster is as easy as starting a new RethinkDB process and pointing it to an existing node in the cluster. Everything else is handled by the system without any additional effort required from the user.</source>
          <target state="translated">RethinkDB 클러스터에 노드를 추가하는 것은 새로운 RethinkDB 프로세스를 시작하고 클러스터의 기존 노드를 가리키는 것만 큼 쉽습니다. 그 밖의 모든 것은 사용자의 추가 노력없이 시스템에서 처리합니다.</target>
        </trans-unit>
        <trans-unit id="0e702c722b85fd500d1639455bf36d02cc7936bc" translate="yes" xml:space="preserve">
          <source>Adding/overwriting a field in a document</source>
          <target state="translated">문서에서 필드 추가 / 덮어 쓰기</target>
        </trans-unit>
        <trans-unit id="7910456908243df1424fd048180312b577679903" translate="yes" xml:space="preserve">
          <source>Additional blocks are allocated to store index trees for secondary indexes as well as for the primary index of each table. Roughly one block is used per 30 documents for each index; the exact number depends on the sizes of the index keys.</source>
          <target state="translated">2 차 인덱스와 각 테이블의 1 차 인덱스에 대한 인덱스 트리를 저장하기 위해 추가 블록이 할당됩니다. 각 색인에 대해 30 개의 문서 당 대략 하나의 블록이 사용됩니다. 정확한 숫자는 인덱스 키의 크기에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b8be3d1264310c3b8c848d4b90d5206179a40cc4" translate="yes" xml:space="preserve">
          <source>Administration</source>
          <target state="translated">Administration</target>
        </trans-unit>
        <trans-unit id="41c9c93ed7b1b40d1c03451865a4eab4fc6721fe" translate="yes" xml:space="preserve">
          <source>Administration tools</source>
          <target state="translated">관리 도구</target>
        </trans-unit>
        <trans-unit id="1fe17e82169153d3e2e96a63046f50d17af41411" translate="yes" xml:space="preserve">
          <source>Administrative operations</source>
          <target state="translated">행정 운영</target>
        </trans-unit>
        <trans-unit id="f7d73e5d6f0b5c68b5528964b60905cb1e539834" translate="yes" xml:space="preserve">
          <source>Advanced configuration</source>
          <target state="translated">고급 구성</target>
        </trans-unit>
        <trans-unit id="2d84ce061ed301bbfc4fb2ccdba36c8cd1b8024a" translate="yes" xml:space="preserve">
          <source>After executing &lt;code&gt;set_loop_type&lt;/code&gt;, &lt;code&gt;r.connect&lt;/code&gt; will return a Tornado &lt;code&gt;Future&lt;/code&gt;, as will &lt;code&gt;r.run&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;set_loop_type&lt;/code&gt; 을 실행 하면 &lt;code&gt;r.connect&lt;/code&gt; 는 &lt;code&gt;r.run&lt;/code&gt; 과 마찬가지로 Tornado &lt;code&gt;Future&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f3589af61e6742c3e1276fd3c33f0d1bc5345bc0" translate="yes" xml:space="preserve">
          <source>After executing &lt;code&gt;set_loop_type&lt;/code&gt;, &lt;code&gt;r.connect&lt;/code&gt; will return a Twisted &lt;code&gt;Deferred&lt;/code&gt;, as will &lt;code&gt;r.run&lt;/code&gt;.</source>
          <target state="translated">실행 한 후 &lt;code&gt;set_loop_type&lt;/code&gt; 을 , &lt;code&gt;r.connect&lt;/code&gt; 는 트위스트가 반환됩니다 &lt;code&gt;Deferred&lt;/code&gt; 의지로, &lt;code&gt;r.run&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2393857d3afee8355b8c269c19b08fb257cc4213" translate="yes" xml:space="preserve">
          <source>After importing your data, you&amp;rsquo;ll need to rebuild your secondary indexes.</source>
          <target state="translated">데이터를 가져온 후 보조 인덱스를 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="9173bb141d8b86f28dff851a43e2639eb1348818" translate="yes" xml:space="preserve">
          <source>After processing this query, RethinkDB will add an additional post to Jean-Luc Picard&amp;rsquo;s document.</source>
          <target state="translated">이 쿼리를 처리 한 후 RethinkDB는 Jean-Luc Picard의 문서에 추가 게시물을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="64ad2d6ea8349aeff55634efee1b6c15335bb761" translate="yes" xml:space="preserve">
          <source>After the rule has been applied, connect to your instances over SSH and change the RethinkDB configuration file (&lt;code&gt;/etc/rethinkdb/interfaces.d/default.conf&lt;/code&gt;) to join them.</source>
          <target state="translated">규칙이 적용된 후 SSH를 통해 인스턴스에 연결하고 RethinkDB 구성 파일 ( &lt;code&gt;/etc/rethinkdb/interfaces.d/default.conf&lt;/code&gt; )을 변경하여 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="67e9dfc3345ed5049c9c9a58ab5a8cdac6049665" translate="yes" xml:space="preserve">
          <source>Again, anything valid in a JSON array is valid in RethinkDB: the elements may be any of the basic values, objects, or other arrays. Arrays in RethinkDB are loaded fully into memory before they&amp;rsquo;re returned to the user, so they&amp;rsquo;re inefficient at large sizes. RethinkDB defaults to supporting arrays of up to 100,000 elements; this may be set to a different value at runtime for reading by using the &lt;code&gt;array_limit&lt;/code&gt; option to &lt;a href=&quot;../../api/javascript/run/index&quot;&gt;run&lt;/a&gt;.</source>
          <target state="translated">다시, JSON 배열에서 유효한 것은 RethinkDB에서 유효합니다. 요소는 기본 값, 객체 또는 기타 배열 일 수 있습니다. RethinkDB의 배열은 사용자에게 반환되기 전에 메모리에 완전히로드되므로 큰 크기에서는 비효율적입니다. RethinkDB는 기본적으로 최대 100,000 개의 요소 배열을 지원합니다. 이은을 사용하여 읽기에 대한 런타임에서 다른 값으로 설정 될 수 &lt;code&gt;array_limit&lt;/code&gt; 의 하는 옵션을 &lt;a href=&quot;../../api/javascript/run/index&quot;&gt;실행합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9ba037c0e4c06d192c83e08070b15787f07daaa" translate="yes" xml:space="preserve">
          <source>Aggregation</source>
          <target state="translated">Aggregation</target>
        </trans-unit>
        <trans-unit id="4a8b1808633c6dd8082fd60b1ddbc836f642461f" translate="yes" xml:space="preserve">
          <source>Akshay Chougule, a biologist working with large data sets, wrote a blog post about &lt;a href=&quot;http://datavu.blogspot.com/2014/08/useful-unix-commands-for-exploring-data.html&quot;&gt;Useful Unix commands for exploring data&lt;/a&gt;, showing ways to &amp;ldquo;query&amp;rdquo; comma-delimited plain text data sets with common shell commands. We thought it&amp;rsquo;d be interesting to do a similar article using ReQL in the Data Explorer, showing how it can be used for ad hoc queries.</source>
          <target state="translated">대규모 데이터 세트를 다루는 생물학자인 Akshay Chougule은 데이터 &lt;a href=&quot;http://datavu.blogspot.com/2014/08/useful-unix-commands-for-exploring-data.html&quot;&gt;탐색을위한 유용한 유닉스 명령에 대한&lt;/a&gt; 블로그 게시물을 작성하여 공통 쉘 명령으로 쉼표로 구분 된 일반 텍스트 데이터 세트를 &quot;쿼리&quot;하는 방법을 보여줍니다. 데이터 탐색기에서 ReQL을 사용하여 유사한 기사를 작성하여 임시 쿼리에 사용하는 방법을 보여주는 것이 흥미로 웠습니다.</target>
        </trans-unit>
        <trans-unit id="613d7e2b25e4ca38ce134bdeb3d6c80d4fad7428" translate="yes" xml:space="preserve">
          <source>Akshay created a fictitious data set of movies; we&amp;rsquo;ll use &lt;a href=&quot;http://www.imdb.com/interfaces&quot;&gt;data&lt;/a&gt; from the &lt;a href=&quot;http://www.imdb.com/chart/top&quot;&gt;IMDb Top 250&lt;/a&gt;. (Note that we captured this on August 26, 2014, so the data will likely be different if you check it now.) The plain-text data from IMDb isn&amp;rsquo;t in &lt;em&gt;any&lt;/em&gt; format, but we&amp;rsquo;ve turned it into a JSON file available at &lt;a href=&quot;http://rethinkdb.com/sample/top-250-ratings.json&quot;&gt;http://rethinkdb.com/sample/top-250-ratings.json&lt;/a&gt;. (For the record, we converted it to a tab-delimited file first, used &lt;code&gt;rethinkdb import&lt;/code&gt; to get it into a database, fixed the column types and re-exported it. See &lt;a href=&quot;http://rethinkdb.com/docs/importing/&quot;&gt;Importing your data&lt;/a&gt; for details.)</source>
          <target state="translated">Akshay는 가상의 영화 데이터 세트를 만들었습니다. 우리는 &lt;a href=&quot;http://www.imdb.com/chart/top&quot;&gt;IMDb Top 250의 &lt;/a&gt;&lt;a href=&quot;http://www.imdb.com/interfaces&quot;&gt;데이터&lt;/a&gt; 를 사용할 것 입니다. (우리 8 월 (26), 2014 년이 캡처하는 것으로, 당신은 지금을 선택하면 데이터가 가능성이 다를 수 있으므로.) IMDB에서 일반 텍스트 데이터에없는 &lt;em&gt;어떤&lt;/em&gt; 형식, 그러나 우리는 JSON 파일로를 설정했습니다 &lt;a href=&quot;http://rethinkdb.com/sample/top-250-ratings.json&quot;&gt;http://rethinkdb.com/sample/top-250-ratings.json&lt;/a&gt; 에서 사용 가능합니다 . 레코드의 경우 먼저 탭으로 구분 된 파일로 변환 한 후 &lt;code&gt;rethinkdb import&lt;/code&gt; 를 사용 하여 데이터베이스로 가져 와서 열 유형을 수정하고 다시 내보냈습니다. 자세한 내용 &lt;a href=&quot;http://rethinkdb.com/docs/importing/&quot;&gt;은 데이터 가져 오기&lt;/a&gt; 를 참조하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6114ec7e6a620bfa471e4f330cc2ba47f4f9518e" translate="yes" xml:space="preserve">
          <source>All ReQL queries are automatically parallelized on the RethinkDB server as much as possible. Whenever possible, query execution is split across CPU cores, servers in the cluster, and even multiple datacenters. If you have large, complicated queries that require multiple stages of processing, RethinkDB will automatically break them up into stages, execute each stage in parallel, and combine data to return a complete result.</source>
          <target state="translated">모든 ReQL 쿼리는 가능한 한 RethinkDB 서버에서 자동으로 병렬화됩니다. 가능할 때마다 쿼리 실행은 CPU 코어, 클러스터의 서버 및 여러 데이터 센터로 분할됩니다. 여러 단계의 처리가 필요한 크고 복잡한 쿼리가있는 경우 RethinkDB는 자동으로 쿼리를 여러 단계로 나누고 각 단계를 병렬로 실행하며 데이터를 결합하여 완전한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3303f74030734031b05f40df6edd8a2564c1efa7" translate="yes" xml:space="preserve">
          <source>All ReQL queries are chainable</source>
          <target state="translated">모든 ReQL 쿼리는 체인 가능</target>
        </trans-unit>
        <trans-unit id="ac506d7d6f3bcdf4afd8d72f6e480f29fa52f202" translate="yes" xml:space="preserve">
          <source>All ReQL queries follow this general structure. Now that we&amp;rsquo;ve created a table, let&amp;rsquo;s insert some data!</source>
          <target state="translated">모든 ReQL 쿼리는이 일반적인 구조를 따릅니다. 이제 테이블을 만들었으므로 데이터를 삽입 해 봅시다!</target>
        </trans-unit>
        <trans-unit id="c06ac6b50803435531636814a0ce63642dc9fe6e" translate="yes" xml:space="preserve">
          <source>All RethinkDB servers have an &lt;code&gt;admin&lt;/code&gt; account with full access to the cluster, and by default this account has no password. (For full details on this topic, read &lt;a href=&quot;../permissions-and-accounts/index&quot;&gt;Permissions and user accounts&lt;/a&gt;.) One of the first things you should do to secure a cluster is to assign a password to &lt;code&gt;admin&lt;/code&gt;. You can do this when the first server starts up by using the &lt;code&gt;--initial-password&lt;/code&gt;&lt;a href=&quot;../cli-options/index&quot;&gt;command line option&lt;/a&gt;, or by updating the &lt;code&gt;admin&lt;/code&gt; record with a new password in the user &lt;a href=&quot;../system-tables/index#users&quot;&gt;system table&lt;/a&gt;.</source>
          <target state="translated">모든 RethinkDB 서버에는 클러스터에 대한 전체 액세스 권한 이있는 &lt;code&gt;admin&lt;/code&gt; 계정이 있으며 기본적으로이 계정에는 비밀번호가 없습니다. 이 주제에 대한 자세한 내용은 &lt;a href=&quot;../permissions-and-accounts/index&quot;&gt;권한 및 사용자 계정을 참조하십시오&lt;/a&gt; . 클러스터를 보호하기 위해 가장 먼저 수행해야 할 작업 중 하나는 &lt;code&gt;admin&lt;/code&gt; 에 암호를 지정하는 것 입니다. &lt;code&gt;--initial-password&lt;/code&gt; &lt;a href=&quot;../cli-options/index&quot;&gt;명령 행 옵션&lt;/a&gt; 을 사용하거나 사용자 &lt;a href=&quot;../system-tables/index#users&quot;&gt;시스템 테이블&lt;/a&gt; 에서 새 비밀번호로 &lt;code&gt;admin&lt;/code&gt; 레코드를 업데이트 하여 첫 번째 서버를 시작할 때이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e1b92dc3695815b8f1d9c5eaa5ebb44219e5539" translate="yes" xml:space="preserve">
          <source>All documents in a table</source>
          <target state="translated">테이블의 모든 문서</target>
        </trans-unit>
        <trans-unit id="b00102b9715479699488acea6b36a16d535853d9" translate="yes" xml:space="preserve">
          <source>All errors are subclassed from the &lt;code&gt;ReqlError&lt;/code&gt; class.</source>
          <target state="translated">모든 오류는 &lt;code&gt;ReqlError&lt;/code&gt; 클래스 에서 서브 클래 싱됩니다 .</target>
        </trans-unit>
        <trans-unit id="ced1c1be6c6bf08b6ae9d9d15fba1f1c7f24a33d" translate="yes" xml:space="preserve">
          <source>All modifications made via the &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;replace&lt;/code&gt; commands are always atomic with respect to a single document. For example, let&amp;rsquo;s say we&amp;rsquo;d like to atomically update a view count for a page if the field &lt;code&gt;countable&lt;/code&gt; is set to true, and get back the old and new results in a single query. We can perform this operation as follows:</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 및 &lt;code&gt;replace&lt;/code&gt; 명령을 통해 수행 된 모든 수정 사항 은 항상 단일 문서와 관련하여 원 자성입니다. 예를 들어, &lt;code&gt;countable&lt;/code&gt; 필드 가 true로 설정된 경우 페이지의 조회수를 원자 적으로 업데이트 하고 이전 쿼리와 새로운 결과를 단일 쿼리로 다시 가져오고 싶다고 가정 해 보겠습니다 . 다음과 같이이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82b113abbbfa83c5d71511bdc69e144c867d369c" translate="yes" xml:space="preserve">
          <source>All of the normal comparison operators are defined on times:</source>
          <target state="translated">모든 일반 비교 연산자는 다음 시간에 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="236972bdf96d2c41e0a830e3a1b9ffbfd74365da" translate="yes" xml:space="preserve">
          <source>All of the response notes involve changefeeds; read &lt;a href=&quot;../changefeeds/javascript/index&quot;&gt;Changefeeds in RethinkDB&lt;/a&gt; for more detailed information.</source>
          <target state="translated">모든 답변 참고 사항에는 변경 사항이 포함됩니다. 읽기 &lt;a href=&quot;../changefeeds/javascript/index&quot;&gt;RethinkDB에 Changefeeds을&lt;/a&gt; 더 자세한 정보는.</target>
        </trans-unit>
        <trans-unit id="1a84df50466eae7be9c4eacc891053eafa5dc4f1" translate="yes" xml:space="preserve">
          <source>All of the servers in a RethinkDB cluster may be given zero or more &lt;em&gt;tags&lt;/em&gt; that can be used in table configurations to map replicas to servers specified by tag.</source>
          <target state="translated">RethinkDB 클러스터의 모든 서버에는 &lt;em&gt;태그로&lt;/em&gt; 지정된 서버에 복제본을 매핑하기 위해 테이블 ​​구성에 사용할 수있는 0 개 이상의 &lt;em&gt;태그&lt;/em&gt; 가 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93ec90d5c9376f582d353b4f68afca705ec1d311" translate="yes" xml:space="preserve">
          <source>All the status tables are read-only. Some of the information in status tables is also returned in config tables (such as object names and UUIDs).</source>
          <target state="translated">모든 상태 테이블은 읽기 전용입니다. 상태 테이블의 일부 정보는 구성 테이블 (예 : 객체 이름 및 UUID)에도 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="eef86b948e6e5ac6d867ce0f3186825517686c83" translate="yes" xml:space="preserve">
          <source>Allows using ECMAScript 6 generators with RethinkDB callbacks.</source>
          <target state="translated">RethinkDB 콜백과 함께 ECMAScript 6 생성기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35d79e2a383aa9deb4a9db48ea01d2fef0d59218" translate="yes" xml:space="preserve">
          <source>Almost all ReQL operations are chainable. You can think of the &lt;code&gt;.&lt;/code&gt; operator similarly to how you&amp;rsquo;d think of a Unix pipe. You select the data from the table and pipe it into a command that transforms it. You can continue chaining transformers until your query is done. In ReQL, data flows from left to right.</source>
          <target state="translated">거의 모든 ReQL 작업은 연결 가능합니다. 당신은 생각할 수 있습니다 &lt;code&gt;.&lt;/code&gt; 유닉스 파이프에 대한 생각과 비슷합니다. 테이블에서 데이터를 선택하고이를 변환하는 명령으로 파이프합니다. 쿼리가 완료 될 때까지 변압기 연결을 계속할 수 있습니다. ReQL에서 데이터는 왼쪽에서 오른쪽으로 흐릅니다.</target>
        </trans-unit>
        <trans-unit id="7b38be2572c821b34c15e177333a20c29d2bec37" translate="yes" xml:space="preserve">
          <source>Almost done. All we have to do now is create a file &lt;code&gt;group.file&lt;/code&gt; with this the following content:</source>
          <target state="translated">거의 다됐다. 이제 다음과 같은 내용 으로 파일 &lt;code&gt;group.file&lt;/code&gt; . 파일을 작성하기 만하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="c130f58939020d82520c528a5032d22eac52c506" translate="yes" xml:space="preserve">
          <source>Also, another caveat: the nested field syntax doesn&amp;rsquo;t guarantee identical schemas between documents that it returns. It&amp;rsquo;s possible to describe a path that matches objects that have different schema, as seen in this simple example.</source>
          <target state="translated">또한 또 하나의주의 사항 : 중첩 필드 구문은 반환되는 문서간에 동일한 스키마를 보장하지 않습니다. 이 간단한 예에서 볼 수 있듯이 스키마가 다른 객체와 일치하는 경로를 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42f80ea4911ab3976038a6acc8617cd9ac8f2a6d" translate="yes" xml:space="preserve">
          <source>Also, predicates must evaluate document fields. They cannot evaluate &lt;a href=&quot;../../../docs/secondary-indexes/javascript/index&quot;&gt;secondary indexes&lt;/a&gt;.</source>
          <target state="translated">또한 술어는 문서 필드를 평가해야합니다. &lt;a href=&quot;../../../docs/secondary-indexes/javascript/index&quot;&gt;보조 인덱스를&lt;/a&gt; 평가할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fd754a1db1ea7867f35f03db29d1ca78cd96bcb6" translate="yes" xml:space="preserve">
          <source>Also, read about:</source>
          <target state="translated">또한 다음에 대해 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="d94949dfadb50efef9aa2d6eb7a4ede95be9c815" translate="yes" xml:space="preserve">
          <source>Also, you can use &lt;code&gt;changes&lt;/code&gt; with each query rather than after the whole.</source>
          <target state="translated">또한 전체가 아닌 각 쿼리마다 &lt;code&gt;changes&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7863aa00847de790dbc3a48ed8da77557bce86d3" translate="yes" xml:space="preserve">
          <source>Alternatively, you can build a predicate with the &lt;code&gt;and&lt;/code&gt; command, and pass it to &lt;code&gt;filter&lt;/code&gt;:</source>
          <target state="translated">또는 &lt;code&gt;and&lt;/code&gt; 명령을 사용하여 조건 자를 작성하고이를 &lt;code&gt;filter&lt;/code&gt; 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60ea456d4bf78cf96ff34279e0b39250b2e59c49" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use promises.</source>
          <target state="translated">또는 약속을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f03c8410144732f9d9b8ccd9f1dd43aef9acdd9c" translate="yes" xml:space="preserve">
          <source>Alternatively, you may use RethinkDB&amp;rsquo;s built-in &lt;a href=&quot;../../../docs/security/index&quot;&gt;TLS support&lt;/a&gt;.</source>
          <target state="translated">또는 RethinkDB의 내장 &lt;a href=&quot;../../../docs/security/index&quot;&gt;TLS 지원을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="62b6ab4147d7754cf561513cea8f8bf9c71994da" translate="yes" xml:space="preserve">
          <source>Although connecting to a RethinkDB through mobile devices (currently, it can be done on Android SDK 26 or greater with the Java driver, for example), it doesn&amp;rsquo;t mean that you should do it.</source>
          <target state="translated">모바일 장치를 통해 RethinkDB에 연결하더라도 (현재는 Java 드라이버를 사용하여 Android SDK 26 이상에서 수행 할 수 있습니다.) 반드시 수행해야한다는 의미는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="878e75024b2679b43fe2a1793c04c566fb67bc5c" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;Exchange&lt;/code&gt; is created by both publishers and subscribers. Publishers put messages into the exchange, and subscribers listen to messages on the exchange.</source>
          <target state="translated">&lt;code&gt;Exchange&lt;/code&gt; 출판사와 가입자 모두에 의해 생성됩니다. 게시자는 메시지를 교환에 넣고 가입자는 교환에서 메시지를 듣습니다.</target>
        </trans-unit>
        <trans-unit id="687a20ac3798878f7cc75ef20a474f5258b70902" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;orderBy&lt;/code&gt; command that uses a secondary index cannot be chained after &lt;code&gt;getAll&lt;/code&gt;. You can only chain it after a &lt;code&gt;table&lt;/code&gt; command. However, you can chain &lt;code&gt;orderBy&lt;/code&gt; after a &lt;code&gt;between&lt;/code&gt; command provided it uses the same index.</source>
          <target state="translated">보조 인덱스를 사용 하는 &lt;code&gt;orderBy&lt;/code&gt; 명령은 &lt;code&gt;getAll&lt;/code&gt; 후에 체인 될 수 없습니다 . &lt;code&gt;table&lt;/code&gt; 명령 후에 만 연결할 수 있습니다 . 그러나, 당신은 체인 수 &lt;code&gt;orderBy&lt;/code&gt; 후 &lt;code&gt;between&lt;/code&gt; 명령은 같은 인덱스를 사용하여 제공.</target>
        </trans-unit>
        <trans-unit id="089a23c2fa3df18b9282cbff60af4550ecc3a8a5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;orderBy&lt;/code&gt; operation (without an index) can&amp;rsquo;t be distributed across the shards for parallel execution&amp;mdash;it needs all the data in the table to perform a sort.</source>
          <target state="translated">&lt;code&gt;orderBy&lt;/code&gt; (인덱스)없이 동작을 위해 병렬 파편 분산 할 수없는 실행 - 이는 정렬을 수행하는 테이블의 모든 데이터를 필요로한다.</target>
        </trans-unit>
        <trans-unit id="96ce4d1796cf45024f180134db21f4f69e0a38bc" translate="yes" xml:space="preserve">
          <source>An ORM designed to emulate the most common usages of Django&amp;rsquo;s database abstraction.</source>
          <target state="translated">Django 데이터베이스 추상화의 가장 일반적인 사용법을 모방하도록 설계된 ORM.</target>
        </trans-unit>
        <trans-unit id="ccdfc9d43d7aeef827539feeecd2be90fb3c0be2" translate="yes" xml:space="preserve">
          <source>An administrative interface for your data (like phpMyAdmin for RethinkDB).</source>
          <target state="translated">데이터 관리 인터페이스 (예 : phpMyAdmin for RethinkDB)</target>
        </trans-unit>
        <trans-unit id="c248c1c02d1c17f1e639aef1539808e0eca161d5" translate="yes" xml:space="preserve">
          <source>An alternative Node.js driver with a connection pool.</source>
          <target state="translated">연결 풀이있는 대체 Node.js 드라이버.</target>
        </trans-unit>
        <trans-unit id="5af7ff2c917a6871370b7806f695c9da3ed44665" translate="yes" xml:space="preserve">
          <source>An alternative Node.js driver with native promises and a connection pool.</source>
          <target state="translated">기본 약속 및 연결 풀이있는 대체 Node.js 드라이버</target>
        </trans-unit>
        <trans-unit id="548e0b21c5c86f4ac6b486712fe486dacf22afcb" translate="yes" xml:space="preserve">
          <source>An array of JSON documents.</source>
          <target state="translated">JSON 문서의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="da8ef814ce8bb1f9f869566ec60c715a870e13f8" translate="yes" xml:space="preserve">
          <source>An equivalent query using promises.</source>
          <target state="translated">약속을 사용하는 동등한 쿼리입니다.</target>
        </trans-unit>
        <trans-unit id="d8d2f79a0e2838e82b7a953c350518317e098f3b" translate="yes" xml:space="preserve">
          <source>An error will be raised if the old index name does not exist, if the new index name is already in use and &lt;code&gt;overwrite&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, or if either the old or new index name are the same as the primary key field name.</source>
          <target state="translated">이전 색인 이름이 존재하지 않거나 새 색인 이름이 이미 사용 &lt;code&gt;overwrite&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 이거나 이전 또는 새 색인 이름이 기본 키 필드 이름과 동일한 경우 오류 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1e35c96ab9e359b10c3fe12321188504c5386af0" translate="yes" xml:space="preserve">
          <source>An example with group</source>
          <target state="translated">그룹의 예</target>
        </trans-unit>
        <trans-unit id="9ddd5f8367304f323865108502252ff58433bf58" translate="yes" xml:space="preserve">
          <source>An optional &lt;strong&gt;group&lt;/strong&gt; operation which partitions the elements of the sequence into multiple groups.</source>
          <target state="translated">시퀀스의 요소를 여러 그룹으로 분할 하는 선택적 &lt;strong&gt;그룹&lt;/strong&gt; 작업입니다.</target>
        </trans-unit>
        <trans-unit id="2ccfaa4dff351d07369bdecdbd3e84e0f1e7d23c" translate="yes" xml:space="preserve">
          <source>Analysis of the 2012 US presidential elections.</source>
          <target state="translated">2012 년 미국 대통령 선거 분석.</target>
        </trans-unit>
        <trans-unit id="0a823cad44209a53553a86aa90f704e3f99a280a" translate="yes" xml:space="preserve">
          <source>Analytic queries</source>
          <target state="translated">분석 쿼리</target>
        </trans-unit>
        <trans-unit id="a9251ae19e0900a00bc07560cfc6a327067ae00b" translate="yes" xml:space="preserve">
          <source>And again, we sum the posts with &lt;code&gt;reduce&lt;/code&gt;, which produces totals for each group this time:</source>
          <target state="translated">그리고 다시 우리는 게시물을 &lt;code&gt;reduce&lt;/code&gt; 로 합칩니다. 그러면 이번에 는 각 그룹에 대한 총계가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="27daf8e5270ff986917e2e236adfeff9fc67c3f7" translate="yes" xml:space="preserve">
          <source>And an equivalent example in JavaScript:</source>
          <target state="translated">JavaScript의 동등한 예 :</target>
        </trans-unit>
        <trans-unit id="41a1ead72298228ca3a3a3b3638d6a586805849f" translate="yes" xml:space="preserve">
          <source>And create the service file, &lt;code&gt;/usr/lib/systemd/system/rethinkdb@.service&lt;/code&gt;:</source>
          <target state="translated">서비스 파일 &lt;code&gt;/usr/lib/systemd/system/rethinkdb@.service&lt;/code&gt; 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="e81e837476066da20baeefef0507a8a3cccda6fe" translate="yes" xml:space="preserve">
          <source>And here is example data for the &lt;code&gt;authors_posts&lt;/code&gt; table:</source>
          <target state="translated">다음은 &lt;code&gt;authors_posts&lt;/code&gt; 테이블의 데이터 예입니다 .</target>
        </trans-unit>
        <trans-unit id="1c59a1c380337d66c6721d5614b635adc3651250" translate="yes" xml:space="preserve">
          <source>And here&amp;rsquo;s an example document in the &lt;code&gt;companies&lt;/code&gt; table:</source>
          <target state="translated">그리고 &lt;code&gt;companies&lt;/code&gt; 테이블 에 예제 문서가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="4b57305f4e5d34c77dd63e6ca79a8c4b50284565" translate="yes" xml:space="preserve">
          <source>And just for kicks, ReQL can do math!</source>
          <target state="translated">그리고 차기 위해 ReQL은 수학을 할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="f3035079b78f1cb4565f32ede6f8b8bc6d93f41b" translate="yes" xml:space="preserve">
          <source>And reconfiguring a table can be done the &lt;a href=&quot;https://rethinkdb.com/api/python/reconfigure&quot;&gt;reconfigure&lt;/a&gt; command.</source>
          <target state="translated">그리고 테이블 재구성은 &lt;a href=&quot;https://rethinkdb.com/api/python/reconfigure&quot;&gt;reconfigure&lt;/a&gt; 명령 으로 수행 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a9f680669497d4401b019edf4c565085e91a1b3" translate="yes" xml:space="preserve">
          <source>And sum the posts with &lt;code&gt;reduce&lt;/code&gt;:</source>
          <target state="translated">그리고 &lt;code&gt;reduce&lt;/code&gt; 로 게시물을 합산하십시오 .</target>
        </trans-unit>
        <trans-unit id="5cbd765369f5cc942fa92205f9750698ef893c99" translate="yes" xml:space="preserve">
          <source>And that&amp;rsquo;s it!</source>
          <target state="translated">그리고 그게 다야!</target>
        </trans-unit>
        <trans-unit id="bf3d18b8dbcb32a3e46b514b44f58b86077ce12c" translate="yes" xml:space="preserve">
          <source>And there&amp;rsquo;s more! You can filter on fields of objects inside a list. Suppose you wanted just the dates and senders of notes to Bob:</source>
          <target state="translated">그리고 더 있습니다! 목록 내의 객체 필드를 필터링 할 수 있습니다. Bob에게 메모 날짜와 발신자를 원한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="81ccd56b51d9e85cbece1c5ee4babc1e7f0416f4" translate="yes" xml:space="preserve">
          <source>And you will get back:</source>
          <target state="translated">그리고 당신은 돌아올 것입니다 :</target>
        </trans-unit>
        <trans-unit id="6f0d1ee33dbf214d046dfc783742f183623eae1f" translate="yes" xml:space="preserve">
          <source>And, of course, we can use &lt;code&gt;count&lt;/code&gt; to shorten that. We can actually shorten it even more: ReQL will let you provide &lt;code&gt;group&lt;/code&gt; with the name of the field rather than a lambda function. So the simplified function is:</source>
          <target state="translated">물론 &lt;code&gt;count&lt;/code&gt; 를 사용 하여 단축 시킬 수 있습니다 . ReQL을 사용하면 &lt;code&gt;group&lt;/code&gt; 에 람다 함수가 아닌 필드 이름 을 제공 할 수 있습니다 . 따라서 단순화 된 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7be54da4aeef061feb2dd88f21e1e293d3e62c45" translate="yes" xml:space="preserve">
          <source>Angular.js</source>
          <target state="translated">Angular.js</target>
        </trans-unit>
        <trans-unit id="462519e135281467088215ccc649f512ae9b84ce" translate="yes" xml:space="preserve">
          <source>Anonymous functions</source>
          <target state="translated">익명 함수</target>
        </trans-unit>
        <trans-unit id="82147d0e81cec9fe7f99273cbe85b60105b27f26" translate="yes" xml:space="preserve">
          <source>Another way to create a database is through the web UI. You can reach the web UI at &lt;code&gt;http://HOST:8080&lt;/code&gt;. Click on the &lt;em&gt;Tables&lt;/em&gt; tab at the top and then use the &lt;em&gt;Add Database&lt;/em&gt; button.</source>
          <target state="translated">데이터베이스를 작성하는 다른 방법은 웹 UI를 사용하는 것입니다. &lt;code&gt;http://HOST:8080&lt;/code&gt; 에서 웹 UI에 연결할 수 있습니다 . 상단 의 &lt;em&gt;테이블&lt;/em&gt; 탭을 클릭 한 다음 &lt;em&gt;데이터베이스 추가&lt;/em&gt; 버튼 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4558c4835bf7d9cfced76738fef68a662acf93c3" translate="yes" xml:space="preserve">
          <source>Another way to create a new table is to use the web UI. You can reach the web UI at &lt;code&gt;http://HOST:8080&lt;/code&gt;. Click on the &lt;em&gt;Tables&lt;/em&gt; tab at the top of the page and then use the &lt;em&gt;Add Table&lt;/em&gt; button.</source>
          <target state="translated">새 테이블을 만드는 또 다른 방법은 웹 UI를 사용하는 것입니다. &lt;code&gt;http://HOST:8080&lt;/code&gt; 에서 웹 UI에 연결할 수 있습니다 . 페이지 상단의 &lt;em&gt;테이블&lt;/em&gt; 탭을 클릭 한 다음 &lt;em&gt;테이블 &lt;/em&gt;&lt;em&gt;추가&lt;/em&gt; 버튼 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ae413eb61ef3cbb095919a994b128a8cad4546d" translate="yes" xml:space="preserve">
          <source>Any command that requires the results from the shards to be combined on the server executing the query will finish executing on that server rather than being distributed. Optimize your queries by putting commands that can execute in parallel &lt;em&gt;before&lt;/em&gt; commands that combine the result set whenever possible.</source>
          <target state="translated">쿼리를 실행하는 서버에서 샤드의 결과를 결합해야하는 모든 명령은 배포되지 않고 해당 서버에서 실행이 완료됩니다. 가능한 경우 결과 세트를 결합하는 명령 &lt;em&gt;앞에&lt;/em&gt; 병렬로 실행할 수있는 명령을 넣어 쿼리를 최적화하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c46b476ed368e50a936c21b028299e3455a947c" translate="yes" xml:space="preserve">
          <source>Any query, nested or otherwise, can be written with an anonymous function instead of &lt;code&gt;row&lt;/code&gt;. (The official Ruby and Java drivers don&amp;rsquo;t include &lt;code&gt;row&lt;/code&gt; at all.)</source>
          <target state="translated">중첩 또는 다른 쿼리는 &lt;code&gt;row&lt;/code&gt; 대신 익명 함수로 작성할 수 있습니다 . 공식 Ruby 및 Java 드라이버에는 &lt;code&gt;row&lt;/code&gt; 이 전혀 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bba299eace8d53c539e4aeba1813ec5e451f2436" translate="yes" xml:space="preserve">
          <source>Any specified arguments must be integers, or a &lt;code&gt;ReqlRuntimeError&lt;/code&gt; will be thrown. If the start value is equal or to higher than the end value, no error will be thrown but a zero-element stream will be returned.</source>
          <target state="translated">지정된 인수는 정수 여야합니다 . &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 가 발생합니다. 시작 값이 종료 값보다 크거나 같으면 오류가 발생하지 않지만 요소가없는 스트림이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="32339d592a273a95a82e728b6667f2b078b3afdf" translate="yes" xml:space="preserve">
          <source>Any update to the authors document atomically updates both the author data and the posts data.</source>
          <target state="translated">작성자 문서에 대한 모든 업데이트는 작성자 데이터와 게시물 데이터를 원자 적으로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="91b3d268b855ee1e8768093595d82ef7320e495d" translate="yes" xml:space="preserve">
          <source>Any valid JSON object is a valid RethinkDB object, so values can be any of the basic values, arrays, or other objects. Documents in a RethinkDB database are objects. Like JSON, key names must be strings, not integers.</source>
          <target state="translated">유효한 JSON 개체는 유효한 RethinkDB 개체이므로 값은 기본 값, 배열 또는 기타 개체가 될 수 있습니다. RethinkDB 데이터베이스의 문서는 객체입니다. JSON과 마찬가지로 키 이름은 정수가 아닌 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="2d1d17d8fc951d972f691336747457d4d1aff96b" translate="yes" xml:space="preserve">
          <source>Append a value to an array.</source>
          <target state="translated">배열에 값을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f42e09360e8b6714364cd59a7c5899d2dcb4c16a" translate="yes" xml:space="preserve">
          <source>Apply a function to a sequence in order, maintaining state via an accumulator. The &lt;code&gt;fold&lt;/code&gt; command returns either a single value or a new sequence.</source>
          <target state="translated">누산기를 통해 상태를 유지하면서 순서대로 함수를 적용합니다. &lt;code&gt;fold&lt;/code&gt; 명령이 리턴 한 값 또는 새로운 시퀀스 중 하나.</target>
        </trans-unit>
        <trans-unit id="0a89342e9fcb31a038f4068e38847b411ea691af" translate="yes" xml:space="preserve">
          <source>Arch Linux</source>
          <target state="translated">아치 리눅스</target>
        </trans-unit>
        <trans-unit id="5cb3007b9e532397f031625a39530433bb4bc818" translate="yes" xml:space="preserve">
          <source>Architecture FAQ</source>
          <target state="translated">아키텍처 FAQ</target>
        </trans-unit>
        <trans-unit id="bd17e18cb5c6173bb8e6f5df6b2de0b0cac00d3a" translate="yes" xml:space="preserve">
          <source>Architecture details</source>
          <target state="translated">아키텍처 세부 사항</target>
        </trans-unit>
        <trans-unit id="07a722f4e9e6599e31b9313cc6fbeccbe1da9f82" translate="yes" xml:space="preserve">
          <source>Are you running RethinkDB in a VM?</source>
          <target state="translated">VM에서 RethinkDB를 실행하고 있습니까?</target>
        </trans-unit>
        <trans-unit id="a082966ed5ac44f21ff5e1a6b9712060f760fa15" translate="yes" xml:space="preserve">
          <source>Arguments passed to the &lt;code&gt;do&lt;/code&gt; function must be basic data types, and cannot be streams or selections. (Read about &lt;a href=&quot;../../../docs/data-types/index&quot;&gt;ReQL data types&lt;/a&gt;.) While the arguments will all be evaluated before the function is executed, they may be evaluated in any order, so their values should not be dependent on one another. The type of &lt;code&gt;do&lt;/code&gt;&amp;rsquo;s result is the type of the value returned from the function or last expression.</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; 함수에 전달 된 인수는 기본 데이터 유형이어야하며 스트림 또는 선택이 될 수 없습니다. ( &lt;a href=&quot;../../../docs/data-types/index&quot;&gt;ReQL 데이터 유형&lt;/a&gt; 에 대해 읽으십시오 .) 함수가 실행되기 전에 인수가 모두 평가되지만 순서에 관계없이 평가 될 수 있으므로 값이 서로 종속되어서는 안됩니다. 의 유형 &lt;code&gt;do&lt;/code&gt; 결과의 기능 또는 마지막 표현에서 반환 된 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="56e6c9587d60cd4331f09b7c485593aa93ed1af3" translate="yes" xml:space="preserve">
          <source>Arrays (and strings) sort lexicographically. Objects are coerced to arrays before sorting. Strings are sorted by UTF-8 codepoint and do not support Unicode collations.</source>
          <target state="translated">배열 (및 문자열)은 사전 식으로 정렬됩니다. 정렬하기 전에 객체가 배열로 강제 변환됩니다. 문자열은 UTF-8 코드 포인트로 정렬되며 유니 코드 데이터 정렬을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c1288bb8e44092d20dadd301618b133eaff59c4" translate="yes" xml:space="preserve">
          <source>Arrays, however, are a special case: since ReQL commands (as described above) are sent as arrays, you must send data arrays as arguments to the &lt;code&gt;MAKE_ARRAY&lt;/code&gt; command. So the array</source>
          <target state="translated">그러나 배열은 특별한 경우입니다. 위에서 설명한 ReQL 명령이 배열로 전송되므로 데이터 배열을 인수로 &lt;code&gt;MAKE_ARRAY&lt;/code&gt; 명령 에 보내야 합니다. 그래서 배열</target>
        </trans-unit>
        <trans-unit id="67485eed7b4382a0f7a03046053240c0672e09d2" translate="yes" xml:space="preserve">
          <source>As a final example, we&amp;rsquo;ll use an object as the topic. Using an object as the topic allows us a richer hierarchical structure, rather than keeping them in a flat structure like an array. This provides us with maximum flexibility in message routing.</source>
          <target state="translated">마지막 예제로, 주제로 객체를 사용합니다. 객체를 주제로 사용하면 배열과 같은 평평한 구조로 유지하는 대신보다 풍부한 계층 구조를 얻을 수 있습니다. 이것은 메시지 라우팅에있어 최대의 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8d70b89c953907792ea9149b4948ea90d22179c1" translate="yes" xml:space="preserve">
          <source>As a function, &lt;code&gt;page&lt;/code&gt; takes one parameter, an object of the format:</source>
          <target state="translated">함수로서 &lt;code&gt;page&lt;/code&gt; 는 하나의 매개 변수 인 형식의 오브젝트를 취합니다.</target>
        </trans-unit>
        <trans-unit id="f37a969afa06e6673f7a489559988379137182d8" translate="yes" xml:space="preserve">
          <source>As a result, we of course get the best science fiction show in existence.</source>
          <target state="translated">결과적으로, 우리는 물론 최고의 공상 과학 쇼를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="905be4a3f15d2da012f4655ffcc91a0f8b0334ee" translate="yes" xml:space="preserve">
          <source>As a variation of this workload, we also tested scalability in the outdated read mode. In this mode, we make the compromise of a higher chance of slightly outdated read results for additional performance, as read operations can be handled directly by secondary replicas. A typical application that exemplifies this kind of access pattern would be an asynchronous cache.</source>
          <target state="translated">이 워크로드의 변형으로, 오래된 읽기 모드에서 확장 성을 테스트했습니다. 이 모드에서는 보조 복제본에서 읽기 작업을 직접 처리 할 수 ​​있으므로 성능이 약간 더 오래된 읽기 결과가 약간 오래 될 가능성이 높아집니다. 이러한 종류의 액세스 패턴을 나타내는 일반적인 응용 프로그램은 비동기 캐시입니다.</target>
        </trans-unit>
        <trans-unit id="f4fea1bdb0d3a79476e8492fcca2ec82cb28234f" translate="yes" xml:space="preserve">
          <source>As before, we need to create a RabbitMQ connection and channel, and we&amp;rsquo;ll need to assert that the exchange exists:</source>
          <target state="translated">이전과 같이 RabbitMQ 연결 및 채널을 생성해야하며 교환이 존재하는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="15c305d42f2daa5657d601338a038ccc009fce9e" translate="yes" xml:space="preserve">
          <source>As is the case when creating secondary index functions using &lt;a href=&quot;../index_create/index&quot;&gt;indexCreate&lt;/a&gt;, &lt;code&gt;r.now()&lt;/code&gt; is considered non-deterministic and is thus not allowed in the context of write hooks. If you need to reference the current timestamp, &lt;code&gt;context('timestamp')&lt;/code&gt; should be used instead.</source>
          <target state="translated">&lt;a href=&quot;../index_create/index&quot;&gt;indexCreate를&lt;/a&gt; 사용하여 보조 인덱스 함수를 생성 할 때 와 &lt;code&gt;r.now()&lt;/code&gt; 는 비 결정적인 것으로 간주되므로 쓰기 후크 컨텍스트에서 허용되지 않습니다. 현재 타임 스탬프를 참조해야하는 경우 대신 &lt;code&gt;context('timestamp')&lt;/code&gt; 를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cae8a09407711552e9aabe90ccbfdbaa90e10731" translate="yes" xml:space="preserve">
          <source>As mentioned above, the repubsub library is built using RethinkDB changefeeds. Briefly, here&amp;rsquo;s how it works:</source>
          <target state="translated">위에서 언급 한 것처럼 repubsub 라이브러리는 RethinkDB 변경 피드를 사용하여 빌드됩니다. 간단히, 작동 방식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bbd18cda89737e16e06561e56a5efd5132b27c40" translate="yes" xml:space="preserve">
          <source>As systemd supports multiple instances on the same server, you simply need to create multiple &lt;code&gt;.conf&lt;/code&gt; files in &lt;code&gt;/etc/rethinkdb/instances.d&lt;/code&gt;. This may be desirable for isolating databases for separate applications running on the same server, or for testing purposes. (There is no performance gain from running multiple nodes of the same cluster on the same physical machine.)</source>
          <target state="translated">systemd가 동일한 서버에서 여러 인스턴스를 지원하므로 &lt;code&gt;/etc/rethinkdb/instances.d&lt;/code&gt; 에 여러 &lt;code&gt;.conf&lt;/code&gt; 파일을 만들면 됩니다. 동일한 서버에서 실행되는 별도의 응용 프로그램이나 테스트 목적으로 데이터베이스를 격리하는 데 바람직 할 수 있습니다. 동일한 물리적 시스템에서 동일한 클러스터의 여러 노드를 실행해도 성능이 향상되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79f40bb2b8fd158e6951c9b085aa2537141a8754" translate="yes" xml:space="preserve">
          <source>As the &lt;strong&gt;Source&lt;/strong&gt;, enter the id of the security group (see step 3).</source>
          <target state="translated">애즈 &lt;strong&gt;원본&lt;/strong&gt; , 보안 그룹의 ID를 입력한다 (단계 3 참조).</target>
        </trans-unit>
        <trans-unit id="cb54fe608cc71f0b89dbbc16bec961965d11f646" translate="yes" xml:space="preserve">
          <source>As the client attempts to stream data from the server, these stacks are transported to every relevant server in the cluster, and each server begins evaluating the topmost node in the stack, in parallel with other servers. On each server, the topmost node in the stack grabs the first chunk of the data from the node below it, and applies its share of transformations to it. This process proceeds recursively until enough data is collected to send the first chunk to the client. The data from each server is combined into a single resultset, and forwarded to the client. This process continues as the client requests more data from the server.</source>
          <target state="translated">클라이언트가 서버에서 데이터 스트리밍을 시도하면 이러한 스택은 클러스터의 모든 관련 서버로 전송되고 각 서버는 다른 서버와 병렬로 스택의 최상위 노드를 평가하기 시작합니다. 각 서버에서 스택의 최상위 노드는 그 아래 노드에서 데이터의 첫 번째 청크를 가져 와서 해당 변형을 해당 서버에 적용합니다. 이 프로세스는 첫 번째 청크를 클라이언트에 보내기에 충분한 데이터가 수집 될 때까지 재귀 적으로 진행됩니다. 각 서버의 데이터는 단일 결과 집합으로 결합되어 클라이언트로 전달됩니다. 클라이언트가 서버에서 더 많은 데이터를 요청함에 따라이 프로세스는 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="8375959cbc6aae5cdc4d44db82c3ced5c88b3388" translate="yes" xml:space="preserve">
          <source>As these queries are performed in a second client, the first client would receive and print the following objects:</source>
          <target state="translated">이러한 쿼리가 두 번째 클라이언트에서 수행 될 때 첫 번째 클라이언트는 다음 개체를 받아서 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="134d6b41e63f8d58f043111b94e89dcdbcc5edb8" translate="yes" xml:space="preserve">
          <source>Associations</source>
          <target state="translated">Associations</target>
        </trans-unit>
        <trans-unit id="efa658746570de82945ef92629fd6a654065fe9a" translate="yes" xml:space="preserve">
          <source>Assume your users table has this structure:</source>
          <target state="translated">users 테이블이 다음 구조를 가지고 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="66f2025d043bc07bbb9c9a80833978ac638b8c20" translate="yes" xml:space="preserve">
          <source>Asynchronous chat</source>
          <target state="translated">비동기 채팅</target>
        </trans-unit>
        <trans-unit id="83173f0e9771155512d0a30d870f207080f8597e" translate="yes" xml:space="preserve">
          <source>Asynchronous connections</source>
          <target state="translated">비동기 연결</target>
        </trans-unit>
        <trans-unit id="2d41dafc5ecfd8ed4ffbf4e55ae5dec6eb2433b6" translate="yes" xml:space="preserve">
          <source>At the moment, the only built-in strategy is &lt;code&gt;'link-next'&lt;/code&gt;, which is equivalent to &lt;code&gt;function(info) { return info('header')('link')('rel=&quot;next&quot;').default(null); }&lt;/code&gt;.</source>
          <target state="translated">현재 유일한 내장 전략은 &lt;code&gt;'link-next'&lt;/code&gt; 이며 &lt;code&gt;function(info) { return info('header')('link')('rel=&quot;next&quot;').default(null); }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bd52431fd18952855b2631c34fd210e778b78dc" translate="yes" xml:space="preserve">
          <source>At the time of the test, we used RethinkDB 2.1.5 which was compiled from source on Ubuntu 14.04 LTS. During the performance test we used the RethinkDB Java driver with Oracle Java 1.8.0. A full list of configuration settings follows below:</source>
          <target state="translated">테스트 시점에 우분투 14.04 LTS의 소스에서 컴파일 된 RethinkDB 2.1.5를 사용했습니다. 성능 테스트 중에 Oracle Java 1.8.0과 함께 RethinkDB Java 드라이버를 사용했습니다. 구성 설정의 전체 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b1a5cc8a968b19b739e00db262add145412fdb42" translate="yes" xml:space="preserve">
          <source>Atomically updating a document based on a condition</source>
          <target state="translated">조건에 따라 문서를 원자 적으로 업데이트</target>
        </trans-unit>
        <trans-unit id="caa018a0954d979d799993be82ddcbd4f501d817" translate="yes" xml:space="preserve">
          <source>Attach screenshots if applicable</source>
          <target state="translated">해당되는 경우 스크린 샷 첨부</target>
        </trans-unit>
        <trans-unit id="ee1acfa55eb1476c86c5c4a68f256a67b25289ab" translate="yes" xml:space="preserve">
          <source>Authentication</source>
          <target state="translated">Authentication</target>
        </trans-unit>
        <trans-unit id="bf1c120c3d66f07e614453065d0e29e1ef6c4d79" translate="yes" xml:space="preserve">
          <source>Authoritative systems such as RethinkDB and MongoDB choose to maintain data consistency. Building applications on top of authoritative primary systems is much simpler because all of the issues associated with data inconsistency do not arise. In exchange, these applications will occasionally experience availability issues.</source>
          <target state="translated">RethinkDB 및 MongoDB와 같은 권위있는 시스템은 데이터 일관성을 유지하도록 선택합니다. 데이터 불일치와 관련된 모든 문제가 발생하지 않기 때문에 권위있는 기본 시스템 위에 응용 프로그램을 구축하는 것이 훨씬 간단합니다. 대신 이러한 응용 프로그램은 때때로 가용성 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c49bab85e042fd9da10e63698f1ff275408ef3a9" translate="yes" xml:space="preserve">
          <source>Availability and failover</source>
          <target state="translated">가용성 및 장애 조치</target>
        </trans-unit>
        <trans-unit id="f5f9a7d2d6b738a4c53e633f7f8e9031c3e74132" translate="yes" xml:space="preserve">
          <source>Availability guarantees</source>
          <target state="translated">가용성 보장</target>
        </trans-unit>
        <trans-unit id="e51e208b743ed89cfa52a9f1320040272eea2387" translate="yes" xml:space="preserve">
          <source>Averages all the elements of a sequence. If called with a field name, averages all the values of that field in the sequence, skipping elements of the sequence that lack that field. If called with a function, calls that function on every element of the sequence and averages the results, skipping elements of the sequence where that function returns &lt;code&gt;null&lt;/code&gt; or a non-existence error.</source>
          <target state="translated">시퀀스의 모든 요소를 ​​평균화합니다. 필드 이름으로 호출하면 해당 필드가없는 시퀀스의 요소를 건너 뛰고 시퀀스에서 해당 필드의 모든 값을 평균합니다. 함수와 함께 호출하면 시퀀스의 모든 요소에서 해당 함수를 호출하고 결과를 평균화하여 해당 함수가 &lt;code&gt;null&lt;/code&gt; 또는 존재하지 않는 오류를 반환하는 시퀀스의 요소를 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="1f1dd59bc5fd618ecdeed2b80d65f30febc08b2c" translate="yes" xml:space="preserve">
          <source>Back up your data</source>
          <target state="translated">데이터 백업</target>
        </trans-unit>
        <trans-unit id="a9fefc1708b009551dfe5243e39f9eaa73a80f29" translate="yes" xml:space="preserve">
          <source>Backbone.js</source>
          <target state="translated">Backbone.js</target>
        </trans-unit>
        <trans-unit id="766ccc69e7342f121250a3f6c176a77082715aff" translate="yes" xml:space="preserve">
          <source>Backbone.js Todo List based on &lt;a href=&quot;http://todomvc.com/&quot;&gt;TodoMVC&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://todomvc.com/&quot;&gt;TodoMVC&lt;/a&gt; 기반의 Backbone.js Todo 목록 .</target>
        </trans-unit>
        <trans-unit id="7b839bcf3e0e54d2163cfed412c8acb1043d6305" translate="yes" xml:space="preserve">
          <source>Backfill tasks bring out of date shards up to date by transferring data between servers. As above, the &lt;code&gt;progress&lt;/code&gt; field is a number between 0 and 1 indicating how far along the backfill task is.</source>
          <target state="translated">백업 광고 작업은 서버간에 데이터를 전송하여 최신 샤드를 최신 상태로 만듭니다. 위와 같이 &lt;code&gt;progress&lt;/code&gt; 필드는 0에서 1 사이의 숫자이며 백필 작업의 거리를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="95104c2a2bc8f58ce726778b69eb26446e5df2d4" translate="yes" xml:space="preserve">
          <source>Backing up your data</source>
          <target state="translated">데이터 백업</target>
        </trans-unit>
        <trans-unit id="dd96994d01e723dd6f9b0bdb6119722dbeb9faf0" translate="yes" xml:space="preserve">
          <source>Backup</source>
          <target state="translated">Backup</target>
        </trans-unit>
        <trans-unit id="7bf880b869af7aa60c45e307a2c84eb91d64affc" translate="yes" xml:space="preserve">
          <source>Balancing safety and performance</source>
          <target state="translated">안전 및 성능 균형</target>
        </trans-unit>
        <trans-unit id="9a8b97c61b4280a70b1df3508a113cbd5bb941c8" translate="yes" xml:space="preserve">
          <source>Basic CRUD mapping between &lt;a href=&quot;http://hapijs.com&quot;&gt;hapi&lt;/a&gt; and RethinkDB.</source>
          <target state="translated">사이의 기본 CRUD 매핑 &lt;a href=&quot;http://hapijs.com&quot;&gt;게요!&lt;/a&gt; 및 RethinkDB.</target>
        </trans-unit>
        <trans-unit id="b20cbc384159fd820ed034fd3615298ec09f5902" translate="yes" xml:space="preserve">
          <source>Basic Usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="34c0b14ba7e8cc0db81053dac89049007e918a20" translate="yes" xml:space="preserve">
          <source>Basic commands</source>
          <target state="translated">기본 명령</target>
        </trans-unit>
        <trans-unit id="a7e69e7791ed667a403de47b04497c349887deca" translate="yes" xml:space="preserve">
          <source>Basic data types</source>
          <target state="translated">기본 데이터 유형</target>
        </trans-unit>
        <trans-unit id="1b85c1671a31184c1c917d7603e08e14eeb40765" translate="yes" xml:space="preserve">
          <source>Basic predicates</source>
          <target state="translated">기본 술어</target>
        </trans-unit>
        <trans-unit id="9e39c1bf6d19a6e317c669d8bc9466868e62fad8" translate="yes" xml:space="preserve">
          <source>Basic setup</source>
          <target state="translated">기본 설정</target>
        </trans-unit>
        <trans-unit id="2bb51f39857d33551d1c5809b0f809afddc222ff" translate="yes" xml:space="preserve">
          <source>Basic updates and filtering</source>
          <target state="translated">기본 업데이트 및 필터링</target>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes" xml:space="preserve">
          <source>Basic usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="fc099f5538c99f8e0d9e8a6ddec714e383b70d97" translate="yes" xml:space="preserve">
          <source>Be aware this behavior holds true when retrieving data from lists, too. If you extracted &lt;code&gt;subject&lt;/code&gt; from &lt;code&gt;notes&lt;/code&gt; above and Bob had 10 notes, 3 of which contained no &lt;code&gt;subject&lt;/code&gt; field, you would still get a list of 10 objects: 7 of them would be &lt;code&gt;{subject: &amp;lt;text&amp;gt;}&lt;/code&gt; and 3 of them would be empty, i.e., &lt;code&gt;{ }&lt;/code&gt;.</source>
          <target state="translated">이 동작은 목록에서 데이터를 검색 할 때도 적용됩니다. 위의 &lt;code&gt;notes&lt;/code&gt; 에서 &lt;code&gt;subject&lt;/code&gt; 를 추출 하고 Bob이 10 개의 메모를 가지고 있고 그 중 3 개에는 &lt;code&gt;subject&lt;/code&gt; 필드가 없는 경우 에도 10 개의 개체 목록이 표시됩니다. 그 중 7 개는 &lt;code&gt;{subject: &amp;lt;text&amp;gt;}&lt;/code&gt; 이고 3 개는 비어 있습니다. , 즉 &lt;code&gt;{ }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc36a14dfa722feb3d24f81f51c103200d4039f7" translate="yes" xml:space="preserve">
          <source>Be aware this behavior holds true when retrieving data from lists, too. If you extracted &lt;code&gt;subject&lt;/code&gt; from &lt;code&gt;notes&lt;/code&gt; above and Bob had 10 notes, 7 of which contained no &lt;code&gt;subject&lt;/code&gt; field, you would still get a list of 10 objects: 7 of them would be &lt;code&gt;{subject:&amp;lt;text&amp;gt;}&lt;/code&gt; and 3 of them would be empty, i.e., &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">목록에서 데이터를 검색 할 때도이 동작이 적용됩니다. 위의 &lt;code&gt;notes&lt;/code&gt; 에서 &lt;code&gt;subject&lt;/code&gt; 을 추출 했는데 Bob에 10 개의 메모가 있는데 그 중 7 개에 &lt;code&gt;subject&lt;/code&gt; 필드 가 포함되어 있지 않은 경우 에도 10 개의 개체 목록이 표시됩니다. 그 중 7 개는 &lt;code&gt;{subject:&amp;lt;text&amp;gt;}&lt;/code&gt; 이고 3 개는 비어 있습니다. 즉, &lt;code&gt;{}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6f1be2fc6c8c377e2229fddff776fd7afd543fc9" translate="yes" xml:space="preserve">
          <source>Because ReQL is composable you can combine the &lt;code&gt;r.js&lt;/code&gt; command with any other query. For example, let&amp;rsquo;s use it as an alternative to get all users older than 30:</source>
          <target state="translated">ReQL은 작성 가능하므로 &lt;code&gt;r.js&lt;/code&gt; 명령을 다른 쿼리와 결합 할 수 있습니다. 예를 들어, 30 세 이상의 모든 사용자를 확보하기위한 대안으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dd795ddf4fc56f4799629398c1ff8a470d0eca00" translate="yes" xml:space="preserve">
          <source>Because of the previous limitation, it&amp;rsquo;s best to keep the size of the &lt;code&gt;posts&lt;/code&gt; array to no more than a few hundred documents.</source>
          <target state="translated">이전 제한으로 인해 &lt;code&gt;posts&lt;/code&gt; 배열 의 크기를 수백 문서 이하 로 유지하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="8819ba9a92b421c91deca2acda530d627b2e5037" translate="yes" xml:space="preserve">
          <source>Because of this decoupled interaction, publishers are free to disconnect whenever they want. There may even be more than one publisher. Likewise, if no subscribers are currently listening for messages with a certain topic, the exchange is free to simply delete them.</source>
          <target state="translated">이러한 분리 된 상호 작용으로 인해 게시자는 언제든지 원할 때 연결을 끊을 수 있습니다. 게시자가 둘 이상있을 수도 있습니다. 마찬가지로, 가입자가 현재 특정 주제의 메시지를 수신하고 있지 않은 경우 교환기는 자유롭게 메시지를 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5db49c7409f67a659c8846ca03f9eb0dc319e7b8" translate="yes" xml:space="preserve">
          <source>Because you can keep chaining commands (or calling them in prefix notation), you need a command to signify the end of the chain and send the query to the server. This command is &lt;code&gt;run&lt;/code&gt; in the official drivers.</source>
          <target state="translated">연결 명령을 유지 (또는 접두사 표기법으로 호출) 할 수 있으므로 연결 끝을 표시하고 쿼리를 서버로 보내는 명령이 필요합니다. 이 명령은 공식 드라이버에서 &lt;code&gt;run&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="8d1ab2b0b130f977fcff4caada6279739b1f0474" translate="yes" xml:space="preserve">
          <source>Before &lt;code&gt;connect&lt;/code&gt;, use the &lt;code&gt;set_loop_type(&quot;tornado&quot;)&lt;/code&gt; command to set RethinkDB to use asynchronous event loops compatible with Tornado.</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; 하기 전에 &lt;code&gt;set_loop_type(&quot;tornado&quot;)&lt;/code&gt; 명령을 사용하여 RethinkDB 가 Tornado와 호환되는 비동기 이벤트 루프를 사용하도록 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="7a9afbe06b4bebf1dc839c50f86b39dbc9432434" translate="yes" xml:space="preserve">
          <source>Before &lt;code&gt;connect&lt;/code&gt;, use the &lt;code&gt;set_loop_type(&quot;twisted&quot;)&lt;/code&gt; command to set RethinkDB to use asynchronous event loops compatible with the Twisted reactor.</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; 하기 전에 &lt;code&gt;set_loop_type(&quot;twisted&quot;)&lt;/code&gt; 명령을 사용하여 RethinkDB 가 Twisted Reactor와 호환되는 비동기 이벤트 루프를 사용하도록 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="8bceeab99ffaf928dc95774463c455944442d343" translate="yes" xml:space="preserve">
          <source>Binaries for previous versions of RethinkDB are available in the &lt;a href=&quot;https://download.rethinkdb.com&quot;&gt;download archive&lt;/a&gt;.</source>
          <target state="translated">RethinkDB 이전 버전의 바이너리는 &lt;a href=&quot;https://download.rethinkdb.com&quot;&gt;다운로드 아카이브&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1826aba6b2579cdea38a7aacc93c5dcd98625788" translate="yes" xml:space="preserve">
          <source>Binary objects</source>
          <target state="translated">이진 객체</target>
        </trans-unit>
        <trans-unit id="41e98502bbe985a1e03f759e6eeeb6edf60db089" translate="yes" xml:space="preserve">
          <source>Binary objects created with &lt;code&gt;r.binary&lt;/code&gt; can be serialized in two different ways.</source>
          <target state="translated">&lt;code&gt;r.binary&lt;/code&gt; 로 만든 이진 개체 는 두 가지 방법으로 직렬화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c611df9e68f6d83bdebc449a3768663dc3ae158" translate="yes" xml:space="preserve">
          <source>Binary objects returned to the client in JavaScript will also be Node.js &lt;code&gt;Buffer&lt;/code&gt; objects. This can be changed with the &lt;code&gt;binaryFormat&lt;/code&gt; option provided to &lt;a href=&quot;../run/index&quot;&gt;run&lt;/a&gt; to return &amp;ldquo;raw&amp;rdquo; objects.</source>
          <target state="translated">JavaScript로 클라이언트에 반환 된 이진 객체는 Node.js &lt;code&gt;Buffer&lt;/code&gt; 객체 이기도 합니다. &quot;raw&quot;객체를 반환 하기 위해 &lt;a href=&quot;../run/index&quot;&gt;실행&lt;/a&gt; 되는 &lt;code&gt;binaryFormat&lt;/code&gt; 옵션을 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44caa5766e2652de63f72f1ff60fc8d670c119de" translate="yes" xml:space="preserve">
          <source>Binding the intracluster port</source>
          <target state="translated">클러스터 내 포트 바인딩</target>
        </trans-unit>
        <trans-unit id="cbadf36748bb8d13893031ddd4810db0de6054c6" translate="yes" xml:space="preserve">
          <source>Binding the web interface port</source>
          <target state="translated">웹 인터페이스 포트 바인딩</target>
        </trans-unit>
        <trans-unit id="cbc02f4dce5274189921972a9a722d0e8126a075" translate="yes" xml:space="preserve">
          <source>Binding the web interface port can prevent it from being accessed directly from a remote machine. You can bind it to a specific IP address using the &lt;code&gt;--bind-http&lt;/code&gt;&lt;a href=&quot;../cli-options/index&quot;&gt;command line option&lt;/a&gt;; the most secure method is to bind it to the local machine (&lt;code&gt;localhost&lt;/code&gt;) and then connect via a proxy.</source>
          <target state="translated">웹 인터페이스 포트를 바인딩하면 원격 시스템에서 직접 포트에 액세스하지 못할 수 있습니다. &lt;code&gt;--bind-http&lt;/code&gt; &lt;a href=&quot;../cli-options/index&quot;&gt;명령 줄 옵션을&lt;/a&gt; 사용하여 특정 IP 주소에 바인딩 할 수 있습니다 . 가장 안전한 방법은 로컬 컴퓨터 ( &lt;code&gt;localhost&lt;/code&gt; ) 에 바인딩 한 다음 프록시를 통해 연결하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="76cbf022f997b44575465d8104ed40ca7aed9623" translate="yes" xml:space="preserve">
          <source>Blog example app</source>
          <target state="translated">블로그 예제 앱</target>
        </trans-unit>
        <trans-unit id="e944760046d73aa2075fd3b50221e57d7c638e26" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;install-service&lt;/code&gt; and &lt;code&gt;remove-service&lt;/code&gt; also accept an &lt;code&gt;--instance-name &amp;lt;name&amp;gt;&lt;/code&gt; option to give the RethinkDB instance a specific name that will appear in the service manager. This will let you run multiple instances of RethinkDB on the same server.</source>
          <target state="translated">모두 &lt;code&gt;install-service&lt;/code&gt; 및 &lt;code&gt;remove-service&lt;/code&gt; 또한 동의 &lt;code&gt;--instance-name &amp;lt;name&amp;gt;&lt;/code&gt; RethinkDB 인스턴스에게 서비스 관리자에 나타납니다 특정 이름을 지정하는 옵션을 선택합니다. 이렇게하면 동일한 서버에서 RethinkDB의 여러 인스턴스를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ef46452d6c2124d0a11fbb28f184e2473580a80" translate="yes" xml:space="preserve">
          <source>Both of those define the same square. If &lt;code&gt;polygon&lt;/code&gt; had been specified instead of &lt;code&gt;line&lt;/code&gt; they would define a filled square.</source>
          <target state="translated">둘 다 같은 사각형을 정의합니다. &lt;code&gt;line&lt;/code&gt; 대신 &lt;code&gt;polygon&lt;/code&gt; 을 지정한 경우 채워진 사각형을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="a166bba04717131296047407a3dc3da1dde1e5b0" translate="yes" xml:space="preserve">
          <source>Both options are required. In the configuration file, you would specify the key and certificate like so:</source>
          <target state="translated">두 가지 옵션이 모두 필요합니다. 구성 파일에서 다음과 같이 키와 인증서를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="3b8ac6c75a9274bd6c7b12be1395b5c22b3a06be" translate="yes" xml:space="preserve">
          <source>Bottle</source>
          <target state="translated">Bottle</target>
        </trans-unit>
        <trans-unit id="d6e09178bd16cfd18d84e3855ebc0416e92f34f3" translate="yes" xml:space="preserve">
          <source>Bring enough of the missing servers back online to allow automatic failover</source>
          <target state="translated">자동 장애 조치를 수행 할 수 있도록 누락 된 서버를 다시 온라인 상태로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="657ed8cbf67990f3057d93fe46479659c2ee67b2" translate="yes" xml:space="preserve">
          <source>Browse the &lt;a href=&quot;../../../api/javascript/index&quot;&gt;API reference&lt;/a&gt; for many more array operations available in RethinkDB.</source>
          <target state="translated">RethinkDB에서 사용할 수있는 더 많은 배열 작업에 대한 &lt;a href=&quot;../../../api/javascript/index&quot;&gt;API 참조&lt;/a&gt; 를 찾아 보십시오.</target>
        </trans-unit>
        <trans-unit id="48177cef0838afa926f1348e32e28ece5613b72d" translate="yes" xml:space="preserve">
          <source>Browse the &lt;a href=&quot;https://rethinkdb.com/api&quot;&gt;API reference&lt;/a&gt; for more commands.</source>
          <target state="translated">더 많은 명령을 보려면 &lt;a href=&quot;https://rethinkdb.com/api&quot;&gt;API 참조&lt;/a&gt; 를 찾아보십시오 .</target>
        </trans-unit>
        <trans-unit id="ac22af4c83f91b13f1824d666afaf5f459e7a321" translate="yes" xml:space="preserve">
          <source>Browse the API reference to learn more about secondary index commands:</source>
          <target state="translated">보조 인덱스 명령에 대한 자세한 내용은 API 참조를 찾아보십시오.</target>
        </trans-unit>
        <trans-unit id="d516a298eabdbd2e727e54083cecadb863f1dac7" translate="yes" xml:space="preserve">
          <source>Browse the following resources to learn more about ReQL and &lt;code&gt;r.http&lt;/code&gt;:</source>
          <target state="translated">다음 리소스를 찾아 ReQL 및 &lt;code&gt;r.http&lt;/code&gt; 에 대해 자세히 알아 보십시오 .</target>
        </trans-unit>
        <trans-unit id="669311ba783ef7ba53692006d1c9a89ccd031fa2" translate="yes" xml:space="preserve">
          <source>Browse the following resources to learn more about ReQL:</source>
          <target state="translated">ReQL에 대한 자세한 내용을 보려면 다음 리소스를 찾아보십시오.</target>
        </trans-unit>
        <trans-unit id="0f3cfb4d346653cac59dcb7ea0fe5d7077ec9db4" translate="yes" xml:space="preserve">
          <source>Building ReQL queries on multiple lines</source>
          <target state="translated">여러 줄에서 ReQL 쿼리 작성</target>
        </trans-unit>
        <trans-unit id="8cd56ee99256f6026c82a35e18d75551094d8936" translate="yes" xml:space="preserve">
          <source>Building from source</source>
          <target state="translated">소스에서 빌드</target>
        </trans-unit>
        <trans-unit id="b4947f6019d0b7281804735090dfda20647f0fdc" translate="yes" xml:space="preserve">
          <source>But this is where the similarity ends. Instead of constructing strings and passing them to the database server, you access ReQL by using methods from the &lt;code&gt;rethinkdb&lt;/code&gt; package:</source>
          <target state="translated">그러나 이것이 유사성이 끝나는 곳입니다. 문자열을 구성하여 데이터베이스 서버에 전달하는 대신 &lt;code&gt;rethinkdb&lt;/code&gt; 패키지의 메소드를 사용하여 ReQL에 액세스 합니다.</target>
        </trans-unit>
        <trans-unit id="84d0730e896a161bf1371a6a4e38fe9f429f980b" translate="yes" xml:space="preserve">
          <source>But you&amp;rsquo;d like to get a document more like a &amp;ldquo;report card&amp;rdquo;:</source>
          <target state="translated">그러나&amp;ldquo;보고서 카드&amp;rdquo;와 같은 문서를 얻고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="4d4a8ec91fe8ec37a4658b5381536170ca09ec41" translate="yes" xml:space="preserve">
          <source>By combining these operations, you can write surprisingly useful queries in pure ReQL. For example, let&amp;rsquo;s say you have a table of sales your company has made, and you want to figure out how much of the gross comes from people who were working overtime:</source>
          <target state="translated">이러한 작업을 결합하면 순수한 ReQL로 놀랍도록 유용한 쿼리를 작성할 수 있습니다. 예를 들어, 회사가 판매 한 판매 테이블이 있고 초과 근무를하는 사람들의 총 매출이 얼마인지 파악하려고한다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="36883b7adedf10b16636c2d2efb24a193484273d" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;filter&lt;/code&gt; will silently skip documents with missing fields: if the predicate tries to access a field that doesn&amp;rsquo;t exist (for instance, the predicate &lt;code&gt;{age: 30}&lt;/code&gt; applied to a document with no &lt;code&gt;age&lt;/code&gt; field), that document will not be returned in the result set, and no error will be generated. This behavior can be changed with the &lt;code&gt;default&lt;/code&gt; optional argument.</source>
          <target state="translated">기본적으로 &lt;code&gt;filter&lt;/code&gt; 는 누락 된 필드가있는 문서를 자동으로 건너 뜁니다. 조건자가 존재하지 않는 필드 (예 &lt;code&gt;{age: 30}&lt;/code&gt; &lt;code&gt;age&lt;/code&gt; 필드 가없는 문서에 적용된 조건 자 {age : 30}) 에 액세스하려고하면 해당 문서는 그렇지 않습니다. 결과 집합에 반환되고 오류가 생성되지 않습니다. 이 동작은 &lt;code&gt;default&lt;/code&gt; 선택적 인수 로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3a3852ff7da9835c90fb6a26046e9f187e1f55b" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;filter&lt;/code&gt; will silently skip documents with missing fields: if the predicate tries to access a field that doesn&amp;rsquo;t exist (for instance, the predicate &lt;code&gt;{age:30}&lt;/code&gt; applied to a document with no &lt;code&gt;age&lt;/code&gt; field), that document will not be returned in the result set, and no error will be generated. This behavior can be changed with the &lt;code&gt;default&lt;/code&gt; optional argument.</source>
          <target state="translated">기본적으로 &lt;code&gt;filter&lt;/code&gt; 는 누락 된 필드가있는 문서를 자동으로 건너 뜁니다. 조건자가 존재하지 않는 필드 (예 &lt;code&gt;{age:30}&lt;/code&gt; &lt;code&gt;age&lt;/code&gt; 필드 가없는 문서에 적용된 {age : 30}) 에 액세스하려고하면 해당 문서는 그렇지 않습니다. 결과 집합에 반환되고 오류가 생성되지 않습니다. 이 동작은 &lt;code&gt;default&lt;/code&gt; 선택적 인수를 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1344ef8aca42ad3c1757ece48e1e19bd62fba9e3" translate="yes" xml:space="preserve">
          <source>By default, RethinkDB binds the web interface to &lt;code&gt;localhost&lt;/code&gt; for security reasons. If you need to be able to access it from another server, use the &lt;code&gt;--bind all&lt;/code&gt; parameter when starting RethinkDB. Read how to &lt;a href=&quot;../start-a-server/index&quot;&gt;Start a RethinkDB server&lt;/a&gt; and &lt;a href=&quot;../start-on-startup/index&quot;&gt;Start RethinkDB at system startup&lt;/a&gt;.</source>
          <target state="translated">기본적으로 RethinkDB 는 보안상의 이유로 웹 인터페이스를 &lt;code&gt;localhost&lt;/code&gt; 에 바인딩합니다 . 다른 서버에서 액세스 할 수 있어야하는 경우 RethinkDB를 시작할 때 &lt;code&gt;--bind all&lt;/code&gt; 매개 변수를 사용하십시오 . &lt;a href=&quot;../start-on-startup/index&quot;&gt;시스템 시작시 &lt;/a&gt;&lt;a href=&quot;../start-a-server/index&quot;&gt;RethinkDB 서버 &lt;/a&gt;시작 및 RethinkDB 시작 방법을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="44bfff8b590002af7fac25a5a3e6fd68f342de94" translate="yes" xml:space="preserve">
          <source>By default, RethinkDB creates a database &lt;code&gt;test&lt;/code&gt;. Let&amp;rsquo;s create a table &lt;code&gt;authors&lt;/code&gt; within this database:</source>
          <target state="translated">기본적으로 RethinkDB는 데이터베이스 &lt;code&gt;test&lt;/code&gt; 생성합니다 . 이 데이터베이스 내 에서 테이블 &lt;code&gt;authors&lt;/code&gt; 만들어 봅시다 :</target>
        </trans-unit>
        <trans-unit id="a52c9cac3e647a2ed09d7ae35c2fdd8083362667" translate="yes" xml:space="preserve">
          <source>By default, RethinkDB will use 4096 iterations for hashing passwords during the connection handshake between client drivers and the server. There is an option to set iterations on a per-account basis by setting passwords to an object of the form &lt;code&gt;{password: &quot;password&quot;, iterations: 4096}&lt;/code&gt;. If you wished to use only 1024 iterations, you could set a password like so:</source>
          <target state="translated">기본적으로 RethinkDB는 클라이언트 드라이버와 서버 간의 연결 핸드 셰이크 동안 암호를 해싱하기 위해 4096 번의 반복을 사용합니다. 비밀번호를 &lt;code&gt;{password: &quot;password&quot;, iterations: 4096}&lt;/code&gt; 형식의 객체로 설정하여 계정별로 반복을 설정하는 옵션이 있습니다 . 1024 회만 사용하려면 다음과 같이 암호를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fc3614b3247f4342b43f7396eea9d49d658e914" translate="yes" xml:space="preserve">
          <source>By default, RethinkDB will use 4096 iterations for hashing passwords during the connection handshake between client drivers and the server. There is an option to set iterations on a per-account basis by setting passwords to an object of the form &lt;code&gt;{password:&quot;password&quot;,iterations:4096}&lt;/code&gt;. If you wished to use only 1024 iterations, you could set a password like so:</source>
          <target state="translated">기본적으로 RethinkDB는 클라이언트 드라이버와 서버 간의 연결 핸드 셰이크 중에 비밀번호 해싱에 4096 회 반복을 사용합니다. 비밀번호를 &lt;code&gt;{password:&quot;password&quot;,iterations:4096}&lt;/code&gt; 형식의 오브젝트로 설정하여 계정별로 반복을 설정하는 옵션이 있습니다 . 1024 반복 만 사용하려는 경우 다음과 같이 비밀번호를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a0415e1af67de0c24b38ab39f791c72bb31933f" translate="yes" xml:space="preserve">
          <source>By default, documents missing fields tested by the &lt;code&gt;filter&lt;/code&gt; predicate are skipped. In the previous examples, users without an &lt;code&gt;age&lt;/code&gt; field are not returned. By passing the optional &lt;code&gt;default&lt;/code&gt; argument to &lt;code&gt;filter&lt;/code&gt;, you can change this behavior.</source>
          <target state="translated">기본적으로 &lt;code&gt;filter&lt;/code&gt; 술어에 의해 테스트 된 누락 필드 는 생략됩니다. 이전 예에서 &lt;code&gt;age&lt;/code&gt; 필드가없는 사용자 는 반환되지 않습니다. 선택적 &lt;code&gt;default&lt;/code&gt; 인수를 &lt;code&gt;filter&lt;/code&gt; 에 전달하면 이 동작을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25206ceb929fd95956131698bdfaf0a77c7ecf0d" translate="yes" xml:space="preserve">
          <source>By default, if more than one change occurs between invocations of &lt;code&gt;changes&lt;/code&gt;, your application will receive a single change object whose &lt;code&gt;new_val&lt;/code&gt; will incorporate &lt;em&gt;all&lt;/em&gt; the changes to the data. Suppose three updates occurred to a monitored document between &lt;code&gt;change&lt;/code&gt; reads:</source>
          <target state="translated">하나 명 이상의 변경의 호출 사이에 발생하는 경우 기본적으로 &lt;code&gt;changes&lt;/code&gt; , 응용 프로그램은 그 하나의 변화 오브젝트 받게됩니다 &lt;code&gt;new_val&lt;/code&gt; 통합 할 &lt;em&gt;모든&lt;/em&gt; 데이터에 대한 변경 사항을. &lt;code&gt;change&lt;/code&gt; 읽기 사이에 모니터링되는 문서에 세 가지 업데이트가 발생했다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e2210c1bbcff9d7543a9786455afa1b40e879d4" translate="yes" xml:space="preserve">
          <source>By default, neither Homebrew nor the example configuration file above will read options from a &lt;a href=&quot;../config-file/index&quot;&gt;configuration file&lt;/a&gt;. If you wish to use one, you&amp;rsquo;ll need to do the following:</source>
          <target state="translated">기본적으로, 브루 나 예제 구성 파일도는 위의 옵션을 읽어 &lt;a href=&quot;../config-file/index&quot;&gt;구성 파일을&lt;/a&gt; . 하나를 사용하려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="91673feeb82a0cac46ab5ec3cd58c839bd274934" translate="yes" xml:space="preserve">
          <source>By default, the import command will connect to &lt;code&gt;localhost&lt;/code&gt; port &lt;code&gt;28015&lt;/code&gt;. You can use the &lt;code&gt;-c&lt;/code&gt; option to specify a server and client port to connect to. (Note this is the driver port clients connect to, not the cluster port.)</source>
          <target state="translated">기본적으로 import 명령은 &lt;code&gt;localhost&lt;/code&gt; 포트 &lt;code&gt;28015&lt;/code&gt; 에 연결됩니다 . &lt;code&gt;-c&lt;/code&gt; 옵션을 사용하여 연결할 서버 및 클라이언트 포트를 지정할 수 있습니다 . (클러스터 포트가 아닌 클라이언트가 연결하는 드라이버 포트입니다.)</target>
        </trans-unit>
        <trans-unit id="e6ede27b0802ec1b1a113f78048174adac1904c6" translate="yes" xml:space="preserve">
          <source>By default, the service will execute with System user privileges. If you&amp;rsquo;d like to install the service with a different user account, you can use the &lt;code&gt;--runuser&lt;/code&gt; and &lt;code&gt;--runuser-password&lt;/code&gt; options:</source>
          <target state="translated">기본적으로 서비스는 시스템 사용자 권한으로 실행됩니다. 다른 사용자 계정으로 서비스를 설치하려면 &lt;code&gt;--runuser&lt;/code&gt; 및 &lt;code&gt;--runuser-password&lt;/code&gt; 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a555ba74cc0e0d42cbbdf6be76239cab792c5fd9" translate="yes" xml:space="preserve">
          <source>By default, this is inclusive of the start time and exclusive of the end time. Set &lt;code&gt;leftBound&lt;/code&gt; and &lt;code&gt;rightBound&lt;/code&gt; to explicitly include (&lt;code&gt;closed&lt;/code&gt;) or exclude (&lt;code&gt;open&lt;/code&gt;) that endpoint of the range.</source>
          <target state="translated">기본적으로 시작 시간과 종료 시간을 포함합니다. 범위의 해당 엔드 포인트 를 명시 적으로 포함 ( &lt;code&gt;closed&lt;/code&gt; ) 또는 제외 ( &lt;code&gt;open&lt;/code&gt; )하도록 &lt;code&gt;leftBound&lt;/code&gt; 및 &lt;code&gt;rightBound&lt;/code&gt; 를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="96068a611a40418f0835d40a3d5a76ec572d2a38" translate="yes" xml:space="preserve">
          <source>By default, times are converted into native time objects when they are retrieved from the server. This may be overridden by passing the optarg &lt;code&gt;timeFormat&lt;/code&gt; to &lt;code&gt;run&lt;/code&gt;. The only options right now are &lt;code&gt;native&lt;/code&gt;, the default, and &lt;code&gt;raw&lt;/code&gt;. See the &lt;a href=&quot;https://rethinkdb.com/api&quot;&gt;API reference&lt;/a&gt; if you are uncertain how to pass an optional argument in JavaScript.</source>
          <target state="translated">기본적으로 시간은 서버에서 검색 될 때 기본 시간 객체로 변환됩니다. 이것은 OPTARG에 전달하여 재정의 할 수 &lt;code&gt;timeFormat&lt;/code&gt; 하는 &lt;code&gt;run&lt;/code&gt; . 현재 유일한 옵션은 &lt;code&gt;native&lt;/code&gt; , default 및 &lt;code&gt;raw&lt;/code&gt; 입니다. JavaScript에서 선택적 인수를 전달하는 방법을 모르는 경우 &lt;a href=&quot;https://rethinkdb.com/api&quot;&gt;API 참조를 참조&lt;/a&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4722c50e51b8d5e97e0c0d930bb81b920ccc94ac" translate="yes" xml:space="preserve">
          <source>By linking documents stored in &lt;strong&gt;multiple tables&lt;/strong&gt; (similar to traditional relational database systems).</source>
          <target state="translated">&lt;strong&gt;여러 테이블에&lt;/strong&gt; 저장된 문서를 링크함으로써 (전통적인 관계형 데이터베이스 시스템과 유사).</target>
        </trans-unit>
        <trans-unit id="6fb9186d2d9cbcfe93210eb48a2fb2a21232019c" translate="yes" xml:space="preserve">
          <source>By specifying &lt;code&gt;null&lt;/code&gt;, the table scope &lt;code&gt;write&lt;/code&gt; permission is removed, and will again inherit from the next highest scope (database or global).</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 을 지정 하면 테이블 범위 &lt;code&gt;write&lt;/code&gt; 권한이 제거되고 다음으로 가장 높은 범위 (데이터베이스 또는 전역)에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="8e65b7098833d1102386eee212f4ad27cda75aaa" translate="yes" xml:space="preserve">
          <source>By specifying &lt;code&gt;true&lt;/code&gt; to the &lt;code&gt;includeInitial&lt;/code&gt; optional argument, the changefeed stream will start with the current contents of the table or selection being monitored. The initial results will have &lt;code&gt;new_val&lt;/code&gt; fields, but no &lt;code&gt;old_val&lt;/code&gt; fields, so it&amp;rsquo;s easy to distinguish them from change events.</source>
          <target state="translated">&lt;code&gt;includeInitial&lt;/code&gt; 선택적 인수에 &lt;code&gt;true&lt;/code&gt; 를 지정 하면 변경 피드 스트림이 모니터중인 테이블 또는 선택의 현재 내용으로 시작합니다. 초기 결과에는 &lt;code&gt;new_val&lt;/code&gt; 필드가 있지만 &lt;code&gt;old_val&lt;/code&gt; 필드는 없으므로 변경 이벤트와 쉽게 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf27a1ec841476e3904d4d6e74fd318d34e20009" translate="yes" xml:space="preserve">
          <source>By using &lt;strong&gt;embedded arrays&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;내장형 배열&lt;/strong&gt; 을 사용 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="0dce97da25b4264e1073d3bdb60cb75591d8a8cd" translate="yes" xml:space="preserve">
          <source>By using ReQL with a language like Python, it becomes easy to script administrative and configuration tasks with RethinkDB. If you have complex table configurations that might need to be repeated for new tables or tweaked for the whole database, you can store them in a script.</source>
          <target state="translated">Python과 같은 언어로 ReQL을 사용하면 RethinkDB로 관리 및 구성 작업을 쉽게 스크립팅 할 수 있습니다. 새 테이블에 대해 반복하거나 전체 데이터베이스에 대해 조정해야 할 복잡한 테이블 구성이있는 경우이를 스크립트에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e0799c133e428f555d77438ba4a1556387e8f3a" translate="yes" xml:space="preserve">
          <source>By using a negative &lt;code&gt;offset&lt;/code&gt; you can delete from the end of the array. &lt;code&gt;-1&lt;/code&gt; is the last element in the array, &lt;code&gt;-2&lt;/code&gt; is the second-to-last element, and so on. You may specify a negative &lt;code&gt;endOffset&lt;/code&gt;, although just as with a positive value, this will not be inclusive. The range &lt;code&gt;(2,-1)&lt;/code&gt; specifies the third element through the next-to-last element.</source>
          <target state="translated">음수 &lt;code&gt;offset&lt;/code&gt; 을 사용 하면 배열 끝에서 삭제할 수 있습니다. &lt;code&gt;-1&lt;/code&gt; 은 배열의 마지막 요소이고 &lt;code&gt;-2&lt;/code&gt; 는 두 번째부터 마지막 ​​요소입니다. 양수 값과 마찬가지로 음수 &lt;code&gt;endOffset&lt;/code&gt; 을 지정할 수 있습니다 . 범위 &lt;code&gt;(2,-1)&lt;/code&gt; 은 다음 요소부터 마지막 ​​요소까지 세 번째 요소를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="8e5fdab92dece79d7629d6d901687613ddc6ab5a" translate="yes" xml:space="preserve">
          <source>Bytes</source>
          <target state="translated">Bytes</target>
        </trans-unit>
        <trans-unit id="feef1c2cd6dd83347001a228e97b748c2a10570f" translate="yes" xml:space="preserve">
          <source>Bytes on wire</source>
          <target state="translated">와이어 바이트</target>
        </trans-unit>
        <trans-unit id="387ce5685c4f6cadeb19f077c809c397e1cd1990" translate="yes" xml:space="preserve">
          <source>C# bchavez</source>
          <target state="translated">C # bchavez</target>
        </trans-unit>
        <trans-unit id="8c0cf5e371cd7e1b86598707bf61ff3cb94a2dcf" translate="yes" xml:space="preserve">
          <source>C# mfenniak</source>
          <target state="translated">C # mfenniak</target>
        </trans-unit>
        <trans-unit id="fc2b4216164cfb01ac45112054b3fedda8b56c86" translate="yes" xml:space="preserve">
          <source>C++</source>
          <target state="translated">C++</target>
        </trans-unit>
        <trans-unit id="422f183f8cda22e30062df39dacc2bce59af9cd3" translate="yes" xml:space="preserve">
          <source>CAP theorem</source>
          <target state="translated">CAP 정리</target>
        </trans-unit>
        <trans-unit id="5d8d66ea407316bbd1b3369335137a98f8f6a4a0" translate="yes" xml:space="preserve">
          <source>CLI to run ReQL queries in JavaScript.</source>
          <target state="translated">JavaScript에서 ReQL 쿼리를 실행하는 CLI</target>
        </trans-unit>
        <trans-unit id="098c8a89adf6614a20e450a16709e2c86a38e815" translate="yes" xml:space="preserve">
          <source>CLI to run ReQL queries in Ruby.</source>
          <target state="translated">Ruby에서 ReQL 쿼리를 실행하는 CLI</target>
        </trans-unit>
        <trans-unit id="ba1b370e026909cc98a10ff3c5b0c239c13c74ac" translate="yes" xml:space="preserve">
          <source>CPU options</source>
          <target state="translated">CPU 옵션</target>
        </trans-unit>
        <trans-unit id="24a8f7b1bf8b2f150319572c55ec5f6a4bc99510" translate="yes" xml:space="preserve">
          <source>Cache size</source>
          <target state="translated">캐시 크기</target>
        </trans-unit>
        <trans-unit id="365a37def929897716872484ac8bf7f0fc6ceb2a" translate="yes" xml:space="preserve">
          <source>Call an anonymous function using return values from other ReQL commands or queries as arguments.</source>
          <target state="translated">다른 ReQL 명령 또는 쿼리의 반환 값을 인수로 사용하여 익명 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="a8e6bbd49b002cfe98d87402c10df0fd8d823cde" translate="yes" xml:space="preserve">
          <source>Call the function with those terms</source>
          <target state="translated">해당 용어로 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="16b4e8832fa0c6526ffa8efb14f8f0b718e9c61a" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;and&lt;/code&gt; with zero arguments will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">호출 &lt;code&gt;and&lt;/code&gt; 제로 인수를 반환합니다 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="803b84ea84c786de09c3354336db740dc963d127" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;getAll&lt;/code&gt; with zero arguments&amp;mdash;which could happen in this example if the &lt;code&gt;heroines&lt;/code&gt; list had no elements&amp;mdash;will return nothing, i.e., a zero length stream.</source>
          <target state="translated">&lt;code&gt;heroines&lt;/code&gt; 목록에 요소가없는 경우이 예제에서 발생할 수있는 인수가없는 &lt;code&gt;getAll&lt;/code&gt; 을 호출 하면 길이가 0 인 스트림이 아무것도 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8155b1df4d5cc12fc7c2c7fa91b359b53d72c728" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;max&lt;/code&gt; on an empty sequence will throw a non-existence error; this can be handled using the &lt;a href=&quot;../default/index&quot;&gt;default&lt;/a&gt; command.</source>
          <target state="translated">빈 시퀀스에서 &lt;code&gt;max&lt;/code&gt; 를 호출 하면 존재하지 않는 오류가 발생합니다. 이것은 &lt;a href=&quot;../default/index&quot;&gt;기본&lt;/a&gt; 명령을 사용하여 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="b4f4e3809e70523157258aa0104a068ac60d6aa8" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;min&lt;/code&gt; on an empty sequence will throw a non-existence error; this can be handled using the &lt;a href=&quot;../default/index&quot;&gt;default&lt;/a&gt; command.</source>
          <target state="translated">빈 시퀀스에서 &lt;code&gt;min&lt;/code&gt; 을 호출 하면 존재하지 않는 오류가 발생합니다. 이것은 &lt;a href=&quot;../default/index&quot;&gt;기본&lt;/a&gt; 명령을 사용하여 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b1787e0c53a29d985f0fb4128bc38f30679abe5" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;next&lt;/code&gt; the first time on a cursor provides the first element of the cursor. If the data set is exhausted (e.g., you have retrieved all the documents in a table), a &lt;code&gt;ReqlDriverError&lt;/code&gt; error will be passed to the callback when &lt;code&gt;next&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; 에 커서를 처음 호출 하면 커서의 첫 번째 요소가 제공됩니다. 데이터 세트가 소진 된 경우 (예 : 테이블의 모든 문서를 검색 한 경우) &lt;code&gt;next&lt;/code&gt; 호출 할 때 &lt;code&gt;ReqlDriverError&lt;/code&gt; 오류가 콜백에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="9327e8ee2404f2492c382e671d17ef91ec040f9b" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;or&lt;/code&gt; with zero arguments will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">호출 &lt;code&gt;or&lt;/code&gt; 제로 인수를 반환합니다 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="335fa9da2bbd4c247cc30817ce42cb87bcf4565d" translate="yes" xml:space="preserve">
          <source>Can I trade consistency for performance?</source>
          <target state="translated">일관성을 위해 성과를 거래 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="6e5840c83e1efcd71687af3c532fe5fbab34d198" translate="yes" xml:space="preserve">
          <source>Can be rewritten with this function instead:</source>
          <target state="translated">대신이 함수를 사용하여 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0163f235110949da9e601e31cefa74790dd6b2a6" translate="yes" xml:space="preserve">
          <source>Case insensitive filter</source>
          <target state="translated">대소 문자 구분 필터</target>
        </trans-unit>
        <trans-unit id="bb6b8e691a68ba0b2bae6924467f11ad22a02c5c" translate="yes" xml:space="preserve">
          <source>CatThink</source>
          <target state="translated">CatThink</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="51ad199d6352d3bb64db022bd0fbb0fcdea024f8" translate="yes" xml:space="preserve">
          <source>CentOS</source>
          <target state="translated">CentOS</target>
        </trans-unit>
        <trans-unit id="2e368e6fea9239f4e7ed009de6871ea2ed5dd31a" translate="yes" xml:space="preserve">
          <source>Certain RethinkDB drivers support asynchronous connections by integrating with popular async libraries. This is particularly useful with &lt;a href=&quot;../changefeeds/index&quot;&gt;changefeeds&lt;/a&gt; and other real-time applications.</source>
          <target state="translated">특정 RethinkDB 드라이버는 인기있는 비동기 라이브러리와 통합하여 비동기 연결을 지원합니다. 이는 변경 &lt;a href=&quot;../changefeeds/index&quot;&gt;피드&lt;/a&gt; 및 기타 실시간 응용 프로그램에서 특히 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="53fdbfe93cc93230bf3c3d4f728de4f799e768c5" translate="yes" xml:space="preserve">
          <source>Certain RethinkDB drivers support asynchronous connections by integrating with popular async libraries. This is particularly useful with &lt;a href=&quot;../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt; and other real-time applications.</source>
          <target state="translated">특정 RethinkDB 드라이버는 널리 사용되는 비동기 라이브러리와 통합하여 비동기 연결을 지원합니다. 변경 &lt;a href=&quot;../changefeeds/javascript/index&quot;&gt;피드&lt;/a&gt; 및 기타 실시간 응용 프로그램에 특히 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="83b3de7b443af60d30b4c86f7310d9f81cb41440" translate="yes" xml:space="preserve">
          <source>Certain document transformation commands can be chained before changefeeds. For more information, read the &lt;a href=&quot;../../../docs/changefeeds/javascript/index&quot;&gt;discussion of changefeeds&lt;/a&gt; in the &amp;ldquo;Query language&amp;rdquo; documentation.</source>
          <target state="translated">변경 급지 전에 특정 문서 변환 명령을 체인으로 연결할 수 있습니다. 자세한 내용 은 &quot;쿼리 언어&quot;설명서에서 변경 &lt;a href=&quot;../../../docs/changefeeds/javascript/index&quot;&gt;피드&lt;/a&gt; 에 대한 설명을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="b6800db5938c446a73c51460875152477518277a" translate="yes" xml:space="preserve">
          <source>Certificates and keys may be specified with either &lt;a href=&quot;../cli-options/index&quot;&gt;command line options&lt;/a&gt; or as keys in a &lt;a href=&quot;../config-file/index&quot;&gt;configuration file&lt;/a&gt;. To start RethinkDB and tell it to secure the web administration UI, you can start the server with the following options:</source>
          <target state="translated">인증서와 키는 &lt;a href=&quot;../cli-options/index&quot;&gt;명령 줄 옵션&lt;/a&gt; 이나 &lt;a href=&quot;../config-file/index&quot;&gt;구성 파일의&lt;/a&gt; 키로 지정할 수 있습니다 . RethinkDB를 시작하고 웹 관리 UI를 보호하도록 지시하려면 다음 옵션을 사용하여 서버를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64fbd995d3b6b156ee26ae3c03e6516434c34c12" translate="yes" xml:space="preserve">
          <source>Change</source>
          <target state="translated">Change</target>
        </trans-unit>
        <trans-unit id="8c5f763a334b50e54f44e54efef21947da085709" translate="yes" xml:space="preserve">
          <source>Change a value in an array at a given index. Returns the modified array.</source>
          <target state="translated">주어진 인덱스에서 배열의 값을 변경하십시오. 수정 된 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="51332a45f02c777545b37ca7f2a2188cb92d500f" translate="yes" xml:space="preserve">
          <source>Change the default database on this connection.</source>
          <target state="translated">이 연결에서 기본 데이터베이스를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="e107154c99e8c610e45c6e29e9e7058cf41ac06e" translate="yes" xml:space="preserve">
          <source>Changefeed notifications take the form of a two-field object:</source>
          <target state="translated">변경 피드 알림은 다음과 같은 2 필드 객체 형식입니다.</target>
        </trans-unit>
        <trans-unit id="f16b9561940cdffe16531705a4d95a3d577a5ff3" translate="yes" xml:space="preserve">
          <source>Changefeeds</source>
          <target state="translated">Changefeeds</target>
        </trans-unit>
        <trans-unit id="ce556a491ced95908a7a6c39b48d9b09e471112a" translate="yes" xml:space="preserve">
          <source>Changefeeds in RethinkDB</source>
          <target state="translated">RethinkDB의 피드 변경</target>
        </trans-unit>
        <trans-unit id="83047e5cfdb0dcb2f77af45422edd14b6869a792" translate="yes" xml:space="preserve">
          <source>Changefeeds perform well as they scale, although they create extra intracluster messages in proportion to the number of servers with open feed connections on each write. This can be mitigated by running a RethinkDB proxy server (the &lt;code&gt;rethinkdb proxy&lt;/code&gt; startup option); read &lt;a href=&quot;../../sharding-and-replication/index#running-a-proxy-node&quot;&gt;Running a proxy node&lt;/a&gt; for details.</source>
          <target state="translated">변경 피드는 각 쓰기에서 열린 피드 연결이있는 서버 수에 비례하여 클러스터 내 메시지를 추가로 생성하지만 확장시 성능이 우수합니다. 이는 RethinkDB 프록시 서버 ( &lt;code&gt;rethinkdb proxy&lt;/code&gt; 시작 옵션) 를 실행하여 완화 할 수 있습니다 . 읽기 &lt;a href=&quot;../../sharding-and-replication/index#running-a-proxy-node&quot;&gt;프록시 노드 실행&lt;/a&gt; 세부 사항을.</target>
        </trans-unit>
        <trans-unit id="8aa6bce79098087f28ac4e20f72cc2f1a6d8f0b6" translate="yes" xml:space="preserve">
          <source>Changefeeds with filtering and aggregation queries</source>
          <target state="translated">필터링 및 집계 쿼리를 통한 변경 피드</target>
        </trans-unit>
        <trans-unit id="1109c426cb18409bd531e862e44fb833bc26bcfe" translate="yes" xml:space="preserve">
          <source>Changing a table&amp;rsquo;s primary key type</source>
          <target state="translated">테이블의 기본 키 유형 변경</target>
        </trans-unit>
        <trans-unit id="4bb3102ea489ad152248787bbc4c0b2d6dabd6c4" translate="yes" xml:space="preserve">
          <source>Changing the web UI password</source>
          <target state="translated">웹 UI 비밀번호 변경</target>
        </trans-unit>
        <trans-unit id="23a80ca01bcc3d4adc8acf64cfeb1295a9085727" translate="yes" xml:space="preserve">
          <source>Channels multiplex a single TCP connection. All RabbitMQ operations are performed on the channel, rather than directly on a connection. Next, we&amp;rsquo;ll declare the topic exchange so we have somewhere to send our change notifications:</source>
          <target state="translated">채널은 단일 TCP 연결을 다중화합니다. 모든 RabbitMQ 작업은 연결이 아닌 채널에서 수행됩니다. 다음으로, 우리는 변경 알림을 보낼 수 있도록 주제 교환을 선언합니다 :</target>
        </trans-unit>
        <trans-unit id="8d76b841450292d7454c5067a8aed356d29fb4d6" translate="yes" xml:space="preserve">
          <source>Check if you ran out of memory</source>
          <target state="translated">메모리 부족 여부 확인</target>
        </trans-unit>
        <trans-unit id="ff6e9eabb67a59731c2a16e9ce5fc2c636e3d4b5" translate="yes" xml:space="preserve">
          <source>Check socks v5</source>
          <target state="translated">양말 v5 확인</target>
        </trans-unit>
        <trans-unit id="06605619ef52291f92f58c83edf0267a57055e85" translate="yes" xml:space="preserve">
          <source>Check the log</source>
          <target state="translated">로그 확인</target>
        </trans-unit>
        <trans-unit id="b983a8257297706e0953fa3b4171875e05600dd4" translate="yes" xml:space="preserve">
          <source>Choose an AMI password.</source>
          <target state="translated">AMI 비밀번호를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="1be80b707dabbe0a135e904409b854db24612ac5" translate="yes" xml:space="preserve">
          <source>Chrome 9 or higher</source>
          <target state="translated">크롬 9 이상</target>
        </trans-unit>
        <trans-unit id="a89141a1040181c06bdbd4349e235d3d3a992ae7" translate="yes" xml:space="preserve">
          <source>Click on &lt;strong&gt;Add Rule&lt;/strong&gt;, and &lt;strong&gt;Apply rule changes&lt;/strong&gt;.</source>
          <target state="translated">를 클릭 &lt;strong&gt;추가 규칙&lt;/strong&gt; 및 &lt;strong&gt;규칙 변경 사항을 적용합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="615106c3285269c51d26e439c7c7b80cf6e2c432" translate="yes" xml:space="preserve">
          <source>Click on the &lt;em&gt;Apply Configuration&lt;/em&gt; button.</source>
          <target state="translated">&lt;em&gt;Apply Configuration&lt;/em&gt; 버튼을 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec90cdce6f708fcfeb949d4f604d6332096c1bb7" translate="yes" xml:space="preserve">
          <source>Click on the &lt;em&gt;Data Explorer&lt;/em&gt; tab in the browser. You can manipulate data using JavaScript straight from your browser. By default, RethinkDB creates a database named &lt;code&gt;test&lt;/code&gt;. Let&amp;rsquo;s create a table:</source>
          <target state="translated">브라우저에서 &lt;em&gt;데이터 탐색기&lt;/em&gt; 탭을 클릭하십시오 . 브라우저에서 바로 JavaScript를 사용하여 데이터를 조작 할 수 있습니다. 기본적으로 RethinkDB는 &lt;code&gt;test&lt;/code&gt; 라는 데이터베이스를 만듭니다 . 테이블을 만들어 봅시다 :</target>
        </trans-unit>
        <trans-unit id="be5437b02a5d8fa47cab50d539b46f320d9d569e" translate="yes" xml:space="preserve">
          <source>Click on the &lt;em&gt;Reconfigure&lt;/em&gt; button.</source>
          <target state="translated">&lt;em&gt;재구성&lt;/em&gt; 버튼을 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ed4898c442ebe6b95d3356b5c77c6750f73810b" translate="yes" xml:space="preserve">
          <source>Click on the link &lt;strong&gt;&lt;a href=&quot;https://aws.amazon.com/marketplace/library&quot;&gt;Your Software&lt;/a&gt;&lt;/strong&gt; in the upper right. RethinkDB should appear as one of your software subscriptions.</source>
          <target state="translated">오른쪽 상단 &lt;strong&gt;&lt;a href=&quot;https://aws.amazon.com/marketplace/library&quot;&gt;의 소프트웨어&lt;/a&gt;&lt;/strong&gt; 링크를 클릭하십시오 . RethinkDB는 소프트웨어 구독 중 하나로 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="60f86b3c1e117ba4de2f7b4ea24bcb157a1e493b" translate="yes" xml:space="preserve">
          <source>Click the &amp;ldquo;Add Deployment&amp;rdquo; button in the Compose administration panel.</source>
          <target state="translated">작성 관리 패널에서 &quot;배치 추가&quot;단추를 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="532a6530c3c1863698a255ddab78fd5d478fa911" translate="yes" xml:space="preserve">
          <source>Clients may specify &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; values in the &lt;a href=&quot;../../api/javascript/connect/index&quot;&gt;connect&lt;/a&gt; command. For more information about creating and managing user accounts and permissions, read &lt;a href=&quot;../permissions-and-accounts/index&quot;&gt;Permissions and user accounts&lt;/a&gt;.</source>
          <target state="translated">클라이언트는 &lt;a href=&quot;../../api/javascript/connect/index&quot;&gt;connect&lt;/a&gt; 명령 에서 &lt;code&gt;user&lt;/code&gt; 및 &lt;code&gt;password&lt;/code&gt; 값을 지정할 수 있습니다 . 사용자 계정 및 권한 작성 및 관리에 대한 자세한 정보는 &lt;a href=&quot;../permissions-and-accounts/index&quot;&gt;권한 및 사용자 계정을&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="e1d4034c95591a611c30849b57d9ad91baa6f6b8" translate="yes" xml:space="preserve">
          <source>Clojure</source>
          <target state="translated">Clojure</target>
        </trans-unit>
        <trans-unit id="cd5d28232a2a9d0e1e775d321001a08386a88905" translate="yes" xml:space="preserve">
          <source>Close a cursor. Closing a cursor cancels the corresponding query and frees the memory associated with the open request.</source>
          <target state="translated">커서를 닫습니다. 커서를 닫으면 해당 쿼리가 취소되고 열기 요청과 관련된 메모리가 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="425b7f5e5b79bae31dedd70be414d8b15176cbde" translate="yes" xml:space="preserve">
          <source>Close an open connection. If no callback is provided, a promise will be returned.</source>
          <target state="translated">열린 연결을 닫습니다. 콜백이 제공되지 않으면 약속이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6665e849372cf8ab89263fcba8969d9f80ad1e26" translate="yes" xml:space="preserve">
          <source>Close and reopen a connection. If no callback is provided, a promise will be returned.</source>
          <target state="translated">연결을 닫았다가 다시여십시오. 콜백이 제공되지 않으면 약속이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a0df904475eb4c2d01e6e8d48fee5a425571d011" translate="yes" xml:space="preserve">
          <source>Closing a connection normally waits until all outstanding requests have finished and then frees any open resources associated with the connection. By passing &lt;code&gt;false&lt;/code&gt; to the &lt;code&gt;noreply_wait&lt;/code&gt; optional argument, the connection will be closed immediately, possibly aborting any outstanding noreply writes.</source>
          <target state="translated">연결을 닫으면 일반적으로 모든 미해결 요청이 완료 될 때까지 기다린 다음 연결과 관련된 열린 리소스를 모두 해제합니다. &lt;code&gt;noreply_wait&lt;/code&gt; 선택적 인수에 &lt;code&gt;false&lt;/code&gt; 를 전달 하면 연결이 즉시 닫히고 처리되지 않은 noreply 쓰기가 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02260940ccbe5e799268b13799fb479d59d46db3" translate="yes" xml:space="preserve">
          <source>Combine them into a single query:</source>
          <target state="translated">그것들을 하나의 쿼리로 결합하십시오 :</target>
        </trans-unit>
        <trans-unit id="f2300ab17d00aa275b53062bd5370e24c1fe840f" translate="yes" xml:space="preserve">
          <source>Command and output:</source>
          <target state="translated">명령 및 출력 :</target>
        </trans-unit>
        <trans-unit id="6e3d3bf1961b8057b125fc05310e2099de8793b0" translate="yes" xml:space="preserve">
          <source>Command line options</source>
          <target state="translated">명령 줄 옵션</target>
        </trans-unit>
        <trans-unit id="daad2afc533cd0e550046cb11f14733b1b39dc43" translate="yes" xml:space="preserve">
          <source>Command syntax</source>
          <target state="translated">명령 구문</target>
        </trans-unit>
        <trans-unit id="be26df5cdd5fdd3aeb21e737a36aec43aa9993d6" translate="yes" xml:space="preserve">
          <source>Commands chained after &lt;code&gt;group&lt;/code&gt; operate on each group separately. If you want to operate on all the groups at once (e.g. to order them), you need to call &lt;a href=&quot;https://rethinkdb.com/api/python/ungroup/&quot;&gt;&lt;strong&gt;ungroup&lt;/strong&gt;&lt;/a&gt; before doing so.</source>
          <target state="translated">&lt;code&gt;group&lt;/code&gt; 이후에 연결된 명령 은 각 그룹에서 개별적으로 작동합니다. 한 번에 모든 그룹에서 작업하려면 (예 : 주문) &lt;a href=&quot;https://rethinkdb.com/api/python/ungroup/&quot;&gt;&lt;strong&gt;그룹을 해제&lt;/strong&gt;&lt;/a&gt; 하기 전에 &lt;strong&gt;그룹 해제&lt;/strong&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b1c0f43db47d343152582ce98dd9b9c36f78684b" translate="yes" xml:space="preserve">
          <source>Commands chained after &lt;code&gt;group&lt;/code&gt; will be called on each of these grouped sub-streams, producing grouped data.</source>
          <target state="translated">&lt;code&gt;group&lt;/code&gt; 이후에 연결된 명령 은 그룹화 된 데이터를 생성하는 각 그룹화 된 하위 스트림에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="97dd52ee8df84cc2460b7bb17c1f06e4df4b684f" translate="yes" xml:space="preserve">
          <source>Commands chained onto grouped data will operate on each grouped datum, producing more grouped data.</source>
          <target state="translated">그룹화 된 데이터에 연결된 명령은 각 그룹화 된 데이텀에서 작동하여 더 많은 그룹화 된 데이터를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b06b66dfcdb2aa6fd46fbb67d549b62f59b7ddac" translate="yes" xml:space="preserve">
          <source>Commands that operate on streams (such as &lt;a href=&quot;../filter/index&quot;&gt;filter&lt;/a&gt; or &lt;a href=&quot;../map/index&quot;&gt;map&lt;/a&gt;) can usually be chained after &lt;code&gt;changes&lt;/code&gt;. However, since the stream produced by &lt;code&gt;changes&lt;/code&gt; has no ending, commands that need to consume the entire stream before returning (such as &lt;a href=&quot;../reduce/index&quot;&gt;reduce&lt;/a&gt; or &lt;a href=&quot;../count/index&quot;&gt;count&lt;/a&gt;) cannot.</source>
          <target state="translated">스트림 (예 : &lt;a href=&quot;../filter/index&quot;&gt;필터&lt;/a&gt; 또는 &lt;a href=&quot;../map/index&quot;&gt;맵&lt;/a&gt; ) 에서 작동하는 명령 은 일반적으로 &lt;code&gt;changes&lt;/code&gt; 후 연결될 수 있습니다 . 그러나 &lt;code&gt;changes&lt;/code&gt; 생성 된 스트림 에는 끝이 없으므로 리턴하기 전에 전체 스트림을 사용해야하는 명령 (예 : &lt;a href=&quot;../reduce/index&quot;&gt;reduce&lt;/a&gt; 또는 &lt;a href=&quot;../count/index&quot;&gt;count&lt;/a&gt; )은 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9420c5b6b64cb46409b5ff675ca0bd0aef82e7cd" translate="yes" xml:space="preserve">
          <source>Commands that stop subsequent commands from being parallelized include:</source>
          <target state="translated">후속 명령의 병렬화를 중지하는 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="92c16762b88f8df8579abe15c36515ac11209886" translate="yes" xml:space="preserve">
          <source>Common Lisp</source>
          <target state="translated">공통 리스프</target>
        </trans-unit>
        <trans-unit id="6716b5e80c5a7a4a1a9ac6b7780bbba5290a6d87" translate="yes" xml:space="preserve">
          <source>Common operations such as scaling up and down, rebalancing shards, and increasing/decreasing replication count should easily be performed in a click of a button.</source>
          <target state="translated">버튼 클릭 한 번으로 스케일 업 및 다운, 샤드 재조정, 복제 횟수 증가 / 감소와 같은 일반적인 작업을 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ff484b1571088890a609e5075a56ceac4c71bf4" translate="yes" xml:space="preserve">
          <source>Community support</source>
          <target state="translated">커뮤니티 지원</target>
        </trans-unit>
        <trans-unit id="adf62d677ff08c0773b6bf8016d1c5d62fe7e3e6" translate="yes" xml:space="preserve">
          <source>Community supported packages</source>
          <target state="translated">커뮤니티 지원 패키지</target>
        </trans-unit>
        <trans-unit id="13d6089cf6c38e5531d093155b82745c67c6422c" translate="yes" xml:space="preserve">
          <source>Compare values, testing if the left-hand value is greater than or equal to the right-hand.</source>
          <target state="translated">왼쪽 값이 오른쪽 값보다 크거나 같은지 테스트하여 값을 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="59084f9f33c9372c82cdc88825f185f2940f36d1" translate="yes" xml:space="preserve">
          <source>Compare values, testing if the left-hand value is greater than the right-hand.</source>
          <target state="translated">왼쪽 값이 오른쪽 값보다 큰지 테스트하여 값을 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="d649a4b84fbed163da58e43f7af9bac406e226f9" translate="yes" xml:space="preserve">
          <source>Compare values, testing if the left-hand value is less than or equal to the right-hand.</source>
          <target state="translated">왼쪽 값이 오른쪽 값보다 작거나 같은지 테스트하여 값을 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="a8e61dc0d3cb83f724942759ac08090ca4383150" translate="yes" xml:space="preserve">
          <source>Compare values, testing if the left-hand value is less than the right-hand.</source>
          <target state="translated">왼쪽 값이 오른쪽 값보다 작은 지 테스트하여 값을 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="72158d6e3482e00cedae532226bd81727e66a164" translate="yes" xml:space="preserve">
          <source>Comparing times</source>
          <target state="translated">시간 비교</target>
        </trans-unit>
        <trans-unit id="2be6c60dc28a5a4b4af7a4cfdb4d5bb4e105a111" translate="yes" xml:space="preserve">
          <source>Composing queries isn&amp;rsquo;t limited to simple commands and inner queries. You can also use expressions to perform complex operations. For example, suppose we&amp;rsquo;d like to find all users whose salary and bonus don&amp;rsquo;t exceed $90,000, and increase their salary by 10%:</source>
          <target state="translated">쿼리 작성은 간단한 명령과 내부 쿼리로 제한되지 않습니다. 식을 사용하여 복잡한 작업을 수행 할 수도 있습니다. 예를 들어, 급여와 보너스가 $ 90,000를 초과하지 않는 모든 사용자를 찾아 급여를 10 % 늘리고 싶다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="0729e81470dc1e98cbd409361551ecdeba848d28" translate="yes" xml:space="preserve">
          <source>Composing simple commands</source>
          <target state="translated">간단한 명령 작성</target>
        </trans-unit>
        <trans-unit id="d5b0b39be8f5ddf352e10f034572a1fb4a9d796f" translate="yes" xml:space="preserve">
          <source>Compound indexes</source>
          <target state="translated">복합 인덱스</target>
        </trans-unit>
        <trans-unit id="cb06d0216db3cc19e02489c7c95e8fd8bc56f4d2" translate="yes" xml:space="preserve">
          <source>Compound indexes use arrays to efficiently retrieve documents by multiple fields.</source>
          <target state="translated">복합 색인은 배열을 사용하여 여러 필드로 문서를 효율적으로 검색합니다.</target>
        </trans-unit>
        <trans-unit id="b95aceb53aab6c9a5d99350b7462a4984957770d" translate="yes" xml:space="preserve">
          <source>Compute the arithmetic &amp;ldquo;and&amp;rdquo; of one or more values. &lt;code&gt;bitAnd&lt;/code&gt; takes one or more arguments.</source>
          <target state="translated">하나 이상의 값의 산술 &quot;and&quot;를 계산합니다. &lt;code&gt;bitAnd&lt;/code&gt; 는 하나 이상의 인수를받습니다.</target>
        </trans-unit>
        <trans-unit id="cf7837691f3733755bdd75fdeac2e5b1075d4056" translate="yes" xml:space="preserve">
          <source>Compute the arithmetic &amp;ldquo;and&amp;rdquo; of one or more values. &lt;code&gt;bitXor&lt;/code&gt; takes one or more arguments.</source>
          <target state="translated">하나 이상의 값의 산술 &quot;and&quot;를 계산합니다. &lt;code&gt;bitXor&lt;/code&gt; 는 하나 이상의 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fe3d60e7f967348b2b68f236926ca5bee83a7836" translate="yes" xml:space="preserve">
          <source>Compute the arithmetic &amp;ldquo;or&amp;rdquo; of one or more values. &lt;code&gt;bitOr&lt;/code&gt; takes one or more arguments.</source>
          <target state="translated">하나 이상의 값의 산술 &quot;또는&quot;을 계산합니다. &lt;code&gt;bitOr&lt;/code&gt; 는 하나 이상의 인수를받습니다.</target>
        </trans-unit>
        <trans-unit id="b74d832d5e55f003f0bfd2f80820d77c4962af89" translate="yes" xml:space="preserve">
          <source>Compute the arithmetic inverse (not) of an expression. &lt;code&gt;bitNot&lt;/code&gt; takes no arguments.</source>
          <target state="translated">식의 산술 역 (아님)을 계산합니다. &lt;code&gt;bitNot&lt;/code&gt; 은 인수를받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f4e0921a6941e50e149069eb9f0f60a8e9be0969" translate="yes" xml:space="preserve">
          <source>Compute the distance between a point and another geometry object. At least one of the geometry objects specified must be a point.</source>
          <target state="translated">점과 다른 지오메트리 객체 사이의 거리를 계산합니다. 지정된 형상 객체 중 하나 이상이 점이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b03a3d83e1839da2c3969c40ee411b985a8d3365" translate="yes" xml:space="preserve">
          <source>Compute the left arithmetic shift (left logical shift) of one or more values. &lt;code&gt;bitSal&lt;/code&gt; takes one or more arguments.</source>
          <target state="translated">하나 이상의 값에 대한 왼쪽 산술 시프트 (왼쪽 논리 시프트)를 계산합니다. &lt;code&gt;bitSal&lt;/code&gt; 은 하나 이상의 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fb1bff4039e68d2f120d05eb07897fb16add4133" translate="yes" xml:space="preserve">
          <source>Compute the logical &amp;ldquo;and&amp;rdquo; of one or more values.</source>
          <target state="translated">하나 이상의 값의 논리 &quot;및&quot;을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="16d08899d02d77d5636cfe66a843fc990bf04888" translate="yes" xml:space="preserve">
          <source>Compute the logical &amp;ldquo;or&amp;rdquo; of one or more values.</source>
          <target state="translated">하나 이상의 값의 논리 &quot;또는&quot;을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="72ba2515171440cbad57c6a578705b7dcd3bf051" translate="yes" xml:space="preserve">
          <source>Compute the logical inverse (not) of an expression.</source>
          <target state="translated">식의 논리 역수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="6648d9a80e4e02e50a2306a041df59343b5364ac" translate="yes" xml:space="preserve">
          <source>Compute the right arithmetic shift of one or more values. &lt;code&gt;bitSar&lt;/code&gt; takes one or more arguments.</source>
          <target state="translated">하나 이상의 값의 오른쪽 산술 시프트를 계산합니다. &lt;code&gt;bitSar&lt;/code&gt; 는 하나 이상의 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9645d9cf5653c1eb09aaa709f2f90fc517896bd5" translate="yes" xml:space="preserve">
          <source>Computing the average value of a field</source>
          <target state="translated">필드의 평균값 계산</target>
        </trans-unit>
        <trans-unit id="4a091e6878de4be6867eb509e2ca123c396f2d38" translate="yes" xml:space="preserve">
          <source>Concatenate one or more elements into a single sequence using a mapping function.</source>
          <target state="translated">매핑 기능을 사용하여 하나 이상의 요소를 단일 시퀀스로 연결합니다.</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="754164850f38c1ecdaf6b8ed894cb192bc36c5f4" translate="yes" xml:space="preserve">
          <source>Configuration</source>
          <target state="translated">Configuration</target>
        </trans-unit>
        <trans-unit id="7972d786701ebfffae096c85c80b27b9730a2c01" translate="yes" xml:space="preserve">
          <source>Configuration file options</source>
          <target state="translated">구성 파일 옵션</target>
        </trans-unit>
        <trans-unit id="23780f67b9c5d802e162f80cd175fc9ca05fb6c0" translate="yes" xml:space="preserve">
          <source>Configuration file settings</source>
          <target state="translated">구성 파일 설정</target>
        </trans-unit>
        <trans-unit id="a97f56eb2d8f1800ef216d96472eee2c20278153" translate="yes" xml:space="preserve">
          <source>Configuration tables</source>
          <target state="translated">구성 테이블</target>
        </trans-unit>
        <trans-unit id="3ec3060e02f6f681bf499f63fb144de277a8c8c2" translate="yes" xml:space="preserve">
          <source>Congrats, you&amp;rsquo;re on your way to database bliss! Now move on to the &lt;a href=&quot;../guide/javascript/index&quot;&gt;ten-minute guide&lt;/a&gt; and learn how to use the client drivers, get more in-depth information on basic commands, and start writing real applications with RethinkDB.</source>
          <target state="translated">축하합니다, 당신은 데이터베이스 행복으로가는 길에 있습니다! 이제 &lt;a href=&quot;../guide/javascript/index&quot;&gt;10 분 가이드&lt;/a&gt; 로 이동 하여 클라이언트 드라이버 사용 방법을 배우고 기본 명령에 대한 자세한 정보를 얻고 RethinkDB를 사용하여 실제 응용 프로그램을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="be147818fb7dcedfad35b84f7650997eaa4ece3c" translate="yes" xml:space="preserve">
          <source>Connect to the cluster at host &lt;code&gt;fortress&lt;/code&gt; with a client port at &lt;code&gt;39500&lt;/code&gt;, saving to the default archive name.</source>
          <target state="translated">클라이언트 포트가 &lt;code&gt;39500&lt;/code&gt; 인 호스트 &lt;code&gt;fortress&lt;/code&gt; 의 클러스터에 연결 하여 기본 아카이브 이름으로 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="4ac344592a1f24be4a08d0dab407474e8de8c32e" translate="yes" xml:space="preserve">
          <source>Connect to the default cluster (&lt;code&gt;localhost:28015&lt;/code&gt;) and archive the &lt;code&gt;users&lt;/code&gt; table from the &lt;code&gt;league&lt;/code&gt; database in &lt;code&gt;backup.tar.gz&lt;/code&gt;. Read the &lt;code&gt;admin&lt;/code&gt; user password from the file &lt;code&gt;pw.txt&lt;/code&gt;.</source>
          <target state="translated">기본 클러스터 ( &lt;code&gt;localhost:28015&lt;/code&gt; )에 연결하고 &lt;code&gt;backup.tar.gz&lt;/code&gt; 의 &lt;code&gt;league&lt;/code&gt; 데이터베이스에서 &lt;code&gt;users&lt;/code&gt; 테이블을 아카이브하십시오 . &lt;code&gt;pw.txt&lt;/code&gt; 파일에서 &lt;code&gt;admin&lt;/code&gt; 비밀번호를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="81c159c760c656688b2c30205693dc90ccf3e5b2" translate="yes" xml:space="preserve">
          <source>Connection pool for RethinkDB connections.</source>
          <target state="translated">RethinkDB 연결을위한 연결 풀.</target>
        </trans-unit>
        <trans-unit id="a4d3e7f712b03ffaed2887e138c6fd09a592d0f1" translate="yes" xml:space="preserve">
          <source>Connections from mobile devices</source>
          <target state="translated">모바일 장치에서 연결</target>
        </trans-unit>
        <trans-unit id="b22d7f9889593d87977fab58a4efd0cd2be437a1" translate="yes" xml:space="preserve">
          <source>Connections implement the same interface as Node&amp;rsquo;s &lt;a href=&quot;http://nodejs.org/api/events.html#events_class_events_eventemitter&quot;&gt;EventEmitter&lt;/a&gt;. This allows you to listen for changes in connection state.</source>
          <target state="translated">연결은 Node의 &lt;a href=&quot;http://nodejs.org/api/events.html#events_class_events_eventemitter&quot;&gt;EventEmitter&lt;/a&gt; 와 동일한 인터페이스를 구현합니다 . 연결 상태의 변화를들을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="324822c2e356211721e9205cd22171564a475de6" translate="yes" xml:space="preserve">
          <source>Connections implement the same interface as Node&amp;rsquo;s [EventEmitter][ee]. This allows you to listen for changes in connection state.</source>
          <target state="translated">연결은 노드의 [EventEmitter] [ee]와 동일한 인터페이스를 구현합니다. 연결 상태의 변화를들을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="434e89a6f01cf4fadcd2961b05fe337dcbc0e6d0" translate="yes" xml:space="preserve">
          <source>Connectivity issues</source>
          <target state="translated">연결 문제</target>
        </trans-unit>
        <trans-unit id="bcb25364dacde36011fe92d609c796f90b4f7cc0" translate="yes" xml:space="preserve">
          <source>Consider a user table with contact information and a list of notes for each user in this format:</source>
          <target state="translated">다음 형식의 연락처 정보와 각 사용자의 메모 목록이있는 사용자 테이블을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="1e6f64ab75678829dd084a6595e2b0ae29ecddec" translate="yes" xml:space="preserve">
          <source>Consider the following query:</source>
          <target state="translated">다음 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="df6db8b51cf93b005324de4cfaea48119c51962e" translate="yes" xml:space="preserve">
          <source>Consistency guarantees</source>
          <target state="translated">일관성 보장</target>
        </trans-unit>
        <trans-unit id="6d7b91115433e94222d24884624760ab0c0a085b" translate="yes" xml:space="preserve">
          <source>Construct a ReQL JSON object from a native object.</source>
          <target state="translated">기본 오브젝트에서 ReQL JSON 오브젝트를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="44c0cefdc4712a425f6ac14e08cf734075ab4cdf" translate="yes" xml:space="preserve">
          <source>Construct a circular line or polygon. A circle in RethinkDB is a polygon or line &lt;em&gt;approximating&lt;/em&gt; a circle of a given radius around a given center, consisting of a specified number of vertices (default 32).</source>
          <target state="translated">원형 선 또는 다각형을 만듭니다. RethinkDB 의 원은 지정된 중심 주위에 지정된 반지름의 원을 &lt;em&gt;근사&lt;/em&gt; 하는 다각형 또는 선 으로, 지정된 수의 정점으로 구성됩니다 (기본값 32).</target>
        </trans-unit>
        <trans-unit id="a1fa5fe5d2f9482eae4f882a43397a8b53f582b0" translate="yes" xml:space="preserve">
          <source>Construct a geometry object of type Line. The line can be specified in one of two ways:</source>
          <target state="translated">Line 유형의 지오메트리 객체를 구성합니다. 라인은 다음 두 가지 방법 중 하나로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02f055ba8551742fcaf10b6808303ca03909f646" translate="yes" xml:space="preserve">
          <source>Construct a geometry object of type Point. The point is specified by two floating point numbers, the longitude (&amp;minus;180 to 180) and latitude (&amp;minus;90 to 90) of the point on a perfect sphere. See &lt;a href=&quot;../../../docs/geo-support/javascript/index&quot;&gt;Geospatial support&lt;/a&gt; for more information on ReQL&amp;rsquo;s coordinate system.</source>
          <target state="translated">Point 유형의 지오메트리 객체를 구성합니다. 점은 완벽한 구에서 점의 경도 (-180-180)와 위도 (-90-90)의 두 가지 부동 소수점 숫자로 지정됩니다. ReQL 좌표계에 대한 자세한 정보는 &lt;a href=&quot;../../../docs/geo-support/javascript/index&quot;&gt;지리 공간 지원&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f3265740e5336bfac9bf045cceb4d6265f0f9be" translate="yes" xml:space="preserve">
          <source>Construct a geometry object of type Point. The point is specified by two floating point numbers, the longitude (&amp;minus;180 to 180) and latitude (&amp;minus;90 to 90) of the point on a perfect sphere. See &lt;a href=&quot;../../docs/geo-support/javascript/index&quot;&gt;Geospatial support&lt;/a&gt; for more information on ReQL&amp;rsquo;s coordinate system.</source>
          <target state="translated">Point 유형의 지오메트리 객체를 구성합니다. 점은 완벽한 구에서 점의 경도 (-180-180)와 위도 (-90-90)의 두 가지 부동 소수점 숫자로 지정됩니다. ReQL 좌표계에 대한 자세한 정보는 &lt;a href=&quot;../../docs/geo-support/javascript/index&quot;&gt;지리 공간 지원&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02ca61e3fe454b1b333ec828802d038ea0ab154a" translate="yes" xml:space="preserve">
          <source>Construct a geometry object of type Polygon. The Polygon can be specified in one of two ways:</source>
          <target state="translated">Polygon 유형의 지오메트리 객체를 구성합니다. 다각형은 다음 두 가지 방법 중 하나로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f74ad5006a6b5413b68634f7db50fc09504232d" translate="yes" xml:space="preserve">
          <source>Contribute a driver</source>
          <target state="translated">드라이버 기부</target>
        </trans-unit>
        <trans-unit id="49551177d73377982310b6a218929215d8146939" translate="yes" xml:space="preserve">
          <source>Control Structures</source>
          <target state="translated">제어 구조</target>
        </trans-unit>
        <trans-unit id="e9a6cd2c027cdd8e9cffcd80a142066e34cb43d1" translate="yes" xml:space="preserve">
          <source>Control structures</source>
          <target state="translated">제어 구조</target>
        </trans-unit>
        <trans-unit id="e9fd657a44842d39578b1631d445afc29a19895b" translate="yes" xml:space="preserve">
          <source>Convert a &lt;a href=&quot;http://geojson.org&quot;&gt;GeoJSON&lt;/a&gt; object to a ReQL geometry object.</source>
          <target state="translated">&lt;a href=&quot;http://geojson.org&quot;&gt;GeoJSON&lt;/a&gt; 객체를 ReQL 지오메트리 객체로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="7a5bc8515669837fb41d2a7d5a86376e75bc72fd" translate="yes" xml:space="preserve">
          <source>Convert a Line object into a Polygon object. If the last point does not specify the same coordinates as the first point, &lt;code&gt;polygon&lt;/code&gt; will close the polygon by connecting them.</source>
          <target state="translated">Line 객체를 Polygon 객체로 변환합니다. 마지막 점이 첫 번째 점과 동일한 좌표를 지정하지 않으면 &lt;code&gt;polygon&lt;/code&gt; 은 다각형을 연결하여 다각형을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="a5d2274b1a7341d67fceb07fa84a094d6935c52a" translate="yes" xml:space="preserve">
          <source>Convert a ReQL geometry object to a &lt;a href=&quot;http://geojson.org&quot;&gt;GeoJSON&lt;/a&gt; object.</source>
          <target state="translated">ReQL 지오메트리 객체를 &lt;a href=&quot;http://geojson.org&quot;&gt;GeoJSON&lt;/a&gt; 객체 로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="f77d484459537765d11d104c255735be81e4f21f" translate="yes" xml:space="preserve">
          <source>Convert a ReQL value or object to a JSON string. You may use either &lt;code&gt;toJsonString&lt;/code&gt; or &lt;code&gt;toJSON&lt;/code&gt;.</source>
          <target state="translated">ReQL 값 또는 오브젝트를 JSON 문자열로 변환하십시오. &lt;code&gt;toJsonString&lt;/code&gt; 또는 &lt;code&gt;toJSON&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f422be1d3135214f13f66aa59f8289d86b845bb5" translate="yes" xml:space="preserve">
          <source>Convert a time object to a string in ISO 8601 format.</source>
          <target state="translated">시간 객체를 ISO 8601 형식의 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="611794a8b0346b081c0bde7f2d9e76b191ec250c" translate="yes" xml:space="preserve">
          <source>Convert a time object to its epoch time.</source>
          <target state="translated">시간 객체를 에포크 시간으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2f92780f9a3cd70e7b66d5965dc8d4e66b6c4add" translate="yes" xml:space="preserve">
          <source>Convert a value of one type into another.</source>
          <target state="translated">한 유형의 값을 다른 유형으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="ae28e153fd42b3087fa9d3d89c76a5aaf5e4b04c" translate="yes" xml:space="preserve">
          <source>Cookbook</source>
          <target state="translated">Cookbook</target>
        </trans-unit>
        <trans-unit id="0ae70d9d2c2989bbcbf4991bb2de539613db27dd" translate="yes" xml:space="preserve">
          <source>Cookbook for JavaScript</source>
          <target state="translated">JavaScript 요리 책</target>
        </trans-unit>
        <trans-unit id="8330b94c9770af7c9d2bcc391d6d8c51c2abb9e2" translate="yes" xml:space="preserve">
          <source>Coordinate system</source>
          <target state="translated">좌표계</target>
        </trans-unit>
        <trans-unit id="7dcedaf8a37599ae4419f16070143fa71cdc50f9" translate="yes" xml:space="preserve">
          <source>Coordinates of points on the sphere&amp;rsquo;s surface are addressed by a pair of floating point numbers that denote longitude and latitude. The range of longitude is &amp;minus;180 through 180, which wraps around the whole of the sphere: &amp;minus;180 and 180 denote the same line. The range of latitude is &amp;minus;90 (the south pole) through 90 (the north pole).</source>
          <target state="translated">구 표면의 점 좌표에는 경도와 위도를 나타내는 한 쌍의 부동 소수점 숫자가 표시됩니다. 경도의 범위는 -180에서 180까지이며 구 전체를 감싸고 있습니다. -180과 180은 같은 선을 나타냅니다. 위도의 범위는 -90 (남극)에서 90 (북극)까지입니다.</target>
        </trans-unit>
        <trans-unit id="98a2c0bedbf391bc1c5026f0b8dee7952e7dcaa7" translate="yes" xml:space="preserve">
          <source>Copy the sample configuration file and use the &lt;a href=&quot;../config-file/index&quot;&gt;configuration file&lt;/a&gt; documentation as a guide to customize it. (If you don&amp;rsquo;t have the sample &lt;code&gt;.conf&lt;/code&gt; file, you can download it &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/packaging/assets/config/default.conf.sample&quot;&gt;here&lt;/a&gt;.)</source>
          <target state="translated">샘플 구성 파일을 복사하고 &lt;a href=&quot;../config-file/index&quot;&gt;구성 파일&lt;/a&gt; 문서를 안내서로 사용하여이를 사용자 정의하십시오. (샘플 &lt;code&gt;.conf&lt;/code&gt; 파일 이없는 경우 &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/packaging/assets/config/default.conf.sample&quot;&gt;여기에서&lt;/a&gt; 다운로드 할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="7c53e46cfafd02d02e2a1ed4e38c3b84c04ce8e1" translate="yes" xml:space="preserve">
          <source>Couldn't find what you were looking for?</source>
          <target state="translated">찾고있는 것을 찾을 수 없습니까?</target>
        </trans-unit>
        <trans-unit id="1f7dc5fdf24764ccb629dac7815dd074e76aa8dd" translate="yes" xml:space="preserve">
          <source>Counting the number of documents in a table</source>
          <target state="translated">테이블의 문서 수 계산</target>
        </trans-unit>
        <trans-unit id="d09ddb95cb87ac429fd23b39f1b5db85729319f5" translate="yes" xml:space="preserve">
          <source>Counts the number of elements in a sequence or key/value pairs in an object, or returns the size of a string or binary object.</source>
          <target state="translated">객체의 시퀀스 또는 키 / 값 쌍의 요소 수를 계산하거나 문자열 또는 이진 객체의 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9e299fd9eb3f8e602590dd8b398e04ff6f970993" translate="yes" xml:space="preserve">
          <source>Crash recovery</source>
          <target state="translated">충돌 복구</target>
        </trans-unit>
        <trans-unit id="9538577265ea3ebeb795945713801b501bc50683" translate="yes" xml:space="preserve">
          <source>Create &lt;code&gt;/Library/LaunchDaemons/com.rethinkdb.server.plist&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;/Library/LaunchDaemons/com.rethinkdb.server.plist&lt;/code&gt; 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="d19724d0befdfd70ba3a4bc2f5a4f05c0bce9fcb" translate="yes" xml:space="preserve">
          <source>Create a RethinkDB configuration file for each RethinkDB instance running on this physical server.</source>
          <target state="translated">이 물리적 서버에서 실행중인 각 RethinkDB 인스턴스에 대해 RethinkDB 구성 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="502b801b4c28b6e3be56551a89c95ec2da8e977a" translate="yes" xml:space="preserve">
          <source>Create a database. A RethinkDB database is a collection of tables, similar to relational databases.</source>
          <target state="translated">데이터베이스를 작성하십시오. RethinkDB 데이터베이스는 관계형 데이터베이스와 유사한 테이블 모음입니다.</target>
        </trans-unit>
        <trans-unit id="08eba5855df793eb38016add3ba1fa8a98e3fbed" translate="yes" xml:space="preserve">
          <source>Create a javascript expression.</source>
          <target state="translated">자바 스크립트 표현식을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9420257ab72fa800a703dbf86c68ac974126a10e" translate="yes" xml:space="preserve">
          <source>Create a new connection to the database server. Accepts the following options:</source>
          <target state="translated">데이터베이스 서버에 대한 새 연결을 작성하십시오. 다음 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="71ec632c2d1407f17212a3f8d0d0e7d0f84ce29a" translate="yes" xml:space="preserve">
          <source>Create a new index using &lt;a href=&quot;https://rethinkdb.com/api/python/index_create/&quot;&gt;index_create&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://rethinkdb.com/api/python/index_create/&quot;&gt;index_create를&lt;/a&gt; 사용하여 새 인덱스 생성</target>
        </trans-unit>
        <trans-unit id="e0e6156cc67ad310b7e1a83b6305258ba221d2aa" translate="yes" xml:space="preserve">
          <source>Create a new rule to allow instances to connect to one another:</source>
          <target state="translated">인스턴스를 서로 연결할 수 있도록 새 규칙을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="da36962abedbf9b093586e0aeed655bde4c0b153" translate="yes" xml:space="preserve">
          <source>Create a new secondary index on a table. Secondary indexes improve the speed of many read queries at the slight cost of increased storage space and decreased write performance. For more information about secondary indexes, read the article &amp;ldquo;&lt;a href=&quot;../../../docs/secondary-indexes/javascript/index&quot;&gt;Using secondary indexes in RethinkDB&lt;/a&gt;.&amp;rdquo;</source>
          <target state="translated">테이블에 새로운 보조 인덱스를 만듭니다. 보조 인덱스는 약간의 스토리지 공간 증가와 쓰기 성능 저하로 많은 읽기 쿼리 속도를 향상시킵니다. 보조 인덱스에 대한 자세한 내용은 &quot; &lt;a href=&quot;../../../docs/secondary-indexes/javascript/index&quot;&gt;RethinkDB에서 보조 인덱스 사용&lt;/a&gt; &quot;기사를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="b5f18404147e2a5de5fad40209bdc7fa82f2dbe3" translate="yes" xml:space="preserve">
          <source>Create a new secondary index on a table. Secondary indexes improve the speed of many read queries at the slight cost of increased storage space and decreased write performance. For more information about secondary indexes, read the article &amp;ldquo;&lt;a href=&quot;../../docs/secondary-indexes/javascript/index&quot;&gt;Using secondary indexes in RethinkDB&lt;/a&gt;.&amp;rdquo;</source>
          <target state="translated">테이블에 새로운 보조 인덱스를 만듭니다. 보조 인덱스는 약간의 스토리지 공간 증가와 쓰기 성능 저하로 많은 읽기 쿼리 속도를 향상시킵니다. 보조 인덱스에 대한 자세한 내용은 &quot; &lt;a href=&quot;../../docs/secondary-indexes/javascript/index&quot;&gt;RethinkDB에서 보조 인덱스 사용&lt;/a&gt; &quot;기사를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="d38bef034ce9520dce9daf3eb1fe55c4fc2c0b75" translate="yes" xml:space="preserve">
          <source>Create a new table</source>
          <target state="translated">새 테이블 만들기</target>
        </trans-unit>
        <trans-unit id="562447536f04e553c015de275f15ba8c88b83a79" translate="yes" xml:space="preserve">
          <source>Create a new table:</source>
          <target state="translated">새 테이블을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bf2ead1ee0213398e79eb2b65b4b64df9a27c2c7" translate="yes" xml:space="preserve">
          <source>Create a new virtual host:</source>
          <target state="translated">새 가상 호스트를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c38573933d5307f0ab54377a5b135414e24d9970" translate="yes" xml:space="preserve">
          <source>Create a table. A RethinkDB table is a collection of JSON documents.</source>
          <target state="translated">테이블을 만듭니다. RethinkDB 테이블은 JSON 문서의 모음입니다.</target>
        </trans-unit>
        <trans-unit id="4b7fa9a576c238c272d025c1fd6ab885719f714e" translate="yes" xml:space="preserve">
          <source>Create a time object based on an ISO 8601 date-time string (e.g. &amp;lsquo;2013-01-01T01:01:01+00:00&amp;rsquo;). RethinkDB supports all valid ISO 8601 formats except for week dates. Read more about the ISO 8601 format at &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601&quot;&gt;Wikipedia&lt;/a&gt;.</source>
          <target state="translated">ISO 8601 날짜-시간 문자열 (예 : '2013-01-01T01 : 01 : 01 + 00 : 00')을 기반으로 시간 개체를 만듭니다. RethinkDB는 주 날짜를 제외한 모든 유효한 ISO 8601 형식을 지원합니다. &lt;a href=&quot;http://en.wikipedia.org/wiki/ISO_8601&quot;&gt;Wikipedia&lt;/a&gt; 에서 ISO 8601 형식에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="0bcefcdc9ca2075884357aab377b3bc2daf5b65b" translate="yes" xml:space="preserve">
          <source>Create a time object based on seconds since epoch. The first argument is a double and will be rounded to three decimal places (millisecond-precision).</source>
          <target state="translated">신기원 이후의 초를 기준으로 시간 객체를 만듭니다. 첫 번째 인수는 두 배이며 소수점 이하 세 자리 (밀리 초 정밀도)로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="2fa75ba70bd63e7df1c494846e3fc2c1f29b4dd3" translate="yes" xml:space="preserve">
          <source>Create a time object for a specific time.</source>
          <target state="translated">특정 시간에 대한 시간 개체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8b9def7954fd6f3d1222e9061614fc0235a03c15" translate="yes" xml:space="preserve">
          <source>Create that many &lt;code&gt;VAR&lt;/code&gt; terms</source>
          <target state="translated">많은 &lt;code&gt;VAR&lt;/code&gt; 용어를 만듭니다</target>
        </trans-unit>
        <trans-unit id="ece78eb6c3ee0c25b0c4b9866a64977a72405a9f" translate="yes" xml:space="preserve">
          <source>Create the file &lt;code&gt;/usr/lib/tmpfiles.d/rethinkdb.conf&lt;/code&gt; with the content:</source>
          <target state="translated">컨텐츠로 &lt;code&gt;/usr/lib/tmpfiles.d/rethinkdb.conf&lt;/code&gt; 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="737d6c404b4709c6d7c610d33546b535713d42c4" translate="yes" xml:space="preserve">
          <source>Create the password file in &lt;code&gt;/etc/apache2/&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;/etc/apache2/&lt;/code&gt; 에 비밀번호 파일을 만듭니다 :</target>
        </trans-unit>
        <trans-unit id="6266dd56b076cb8365ea9fb492d800ab32dac4e5" translate="yes" xml:space="preserve">
          <source>Creates an object from a list of key-value pairs, where the keys must be strings. &lt;code&gt;r.object(A, B, C, D)&lt;/code&gt; is equivalent to &lt;code&gt;r.expr([[A, B], [C, D]]).coerceTo('OBJECT')&lt;/code&gt;.</source>
          <target state="translated">키가 문자열이어야하는 키-값 쌍 목록에서 객체를 만듭니다. &lt;code&gt;r.object(A, B, C, D)&lt;/code&gt; 는 &lt;code&gt;r.expr([[A, B], [C, D]]).coerceTo('OBJECT')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d81e9a0585aef20976adb68f4cb8df4643d8f7c" translate="yes" xml:space="preserve">
          <source>Creating a database</source>
          <target state="translated">데이터베이스 생성</target>
        </trans-unit>
        <trans-unit id="caa32e4e8e79e2c3c02dca0de8e30c735ffb9e02" translate="yes" xml:space="preserve">
          <source>Creating a table</source>
          <target state="translated">테이블 만들기</target>
        </trans-unit>
        <trans-unit id="e13e0554f557ba882751e261b5a60777b337bea6" translate="yes" xml:space="preserve">
          <source>Creation</source>
          <target state="translated">Creation</target>
        </trans-unit>
        <trans-unit id="d870f1655c65fb4062abe0817dd94f6c9deebd30" translate="yes" xml:space="preserve">
          <source>Current community-supported drivers</source>
          <target state="translated">현재 커뮤니티 지원 드라이버</target>
        </trans-unit>
        <trans-unit id="c25df3d9d3acc816673351236097c818e193ee3c" translate="yes" xml:space="preserve">
          <source>Current issues</source>
          <target state="translated">현재 문제</target>
        </trans-unit>
        <trans-unit id="87f9a4795729c7b599efecbb2d79e41c1ba3f896" translate="yes" xml:space="preserve">
          <source>Currently the RethinkDB server only supports x86 and x86_64 architectures on Unix-based platforms, and has experimental ARM support (thanks to the effort of &lt;a href=&quot;http://github.com/davidthomas426&quot;&gt;@davidthomas426&lt;/a&gt;).</source>
          <target state="translated">현재 RethinkDB 서버는 Unix 기반 플랫폼에서 x86 및 x86_64 아키텍처 만 지원하며 실험적인 ARM 지원을 제공합니다 ( &lt;a href=&quot;http://github.com/davidthomas426&quot;&gt;@ davidthomas426&lt;/a&gt; 의 노력 덕분에 ).</target>
        </trans-unit>
        <trans-unit id="eb6df1909b1d7498dff50326b6fb756d935e64da" translate="yes" xml:space="preserve">
          <source>Currently, &lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;get_all&lt;/code&gt; and similar operations execute as separate operations from &lt;code&gt;update&lt;/code&gt; and other mutation operations. Therefore, the following is &lt;em&gt;not&lt;/em&gt; a correct implementation of a check-and-set register, since &lt;code&gt;filter&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; will not execute in one atomic operation:</source>
          <target state="translated">현재 &lt;code&gt;filter&lt;/code&gt; , &lt;code&gt;get_all&lt;/code&gt; 및 유사한 작업은 &lt;code&gt;update&lt;/code&gt; 및 기타 변이 작업과 별도의 작업으로 실행됩니다 . 따라서 &lt;code&gt;filter&lt;/code&gt; 및 &lt;code&gt;update&lt;/code&gt; 가 한 번의 원자 조작으로 실행 &lt;em&gt;되지 않으므로&lt;/em&gt; 다음은 점검 및 설정 레지스터의 올바른 구현 이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d2477a50f7e655cb613fc15b137f3f43b6b7da75" translate="yes" xml:space="preserve">
          <source>Currently, ReQL has a default limit of 100,000 elements in an array, and the implementation of &lt;code&gt;group&lt;/code&gt; requires the total number of documents grouped to fit within that boundary, so you are limited to 100,000 invoices. This can be changed, however, by passing the &lt;code&gt;arrayLimit&lt;/code&gt; option to &lt;a href=&quot;../../../api/javascript/run/index&quot;&gt;run&lt;/a&gt;. (Also note that &lt;code&gt;ungroup&lt;/code&gt; always returns an array, although this may change in a future version. Follow issue &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/2719&quot;&gt;#2719&lt;/a&gt; for progress on this.)</source>
          <target state="translated">현재 ReQL의 기본 제한은 한 배열에 10 만 요소이며, &lt;code&gt;group&lt;/code&gt; 구현 하려면 해당 경계 내에 맞게 그룹화 된 총 문서 수가 필요하므로 10 만 송장으로 제한됩니다. 그러나 &lt;code&gt;arrayLimit&lt;/code&gt; 옵션을 전달하여 &lt;a href=&quot;../../../api/javascript/run/index&quot;&gt;실행&lt;/a&gt; 하여 변경할 수 있습니다 . ( &lt;code&gt;ungroup&lt;/code&gt; 은 항상 배열을 반환하지만, 이후 버전에서는 변경 될 수 있습니다. 문제에 대해서는 &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/2719&quot;&gt;2727&lt;/a&gt; 호를 따르십시오 .)</target>
        </trans-unit>
        <trans-unit id="f4d2f91040c93130ddcca14955ef2593c9e0caed" translate="yes" xml:space="preserve">
          <source>Cursors</source>
          <target state="translated">Cursors</target>
        </trans-unit>
        <trans-unit id="7731209d29ac0a4599f13b5c157df9f80320a12e" translate="yes" xml:space="preserve">
          <source>Cursors and feeds implement the same interface as Node&amp;rsquo;s &lt;a href=&quot;http://nodejs.org/api/events.html#events_class_events_eventemitter&quot;&gt;EventEmitter&lt;/a&gt;.</source>
          <target state="translated">커서와 피드는 Node의 &lt;a href=&quot;http://nodejs.org/api/events.html#events_class_events_eventemitter&quot;&gt;EventEmitter&lt;/a&gt; 와 동일한 인터페이스를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="d6f5636098cd458ce9d22939f8e3e8deab0e9bd0" translate="yes" xml:space="preserve">
          <source>DELETE</source>
          <target state="translated">DELETE</target>
        </trans-unit>
        <trans-unit id="854d235e232e068ef083bf90af82bc89c9fe562d" translate="yes" xml:space="preserve">
          <source>Dart</source>
          <target state="translated">Dart</target>
        </trans-unit>
        <trans-unit id="e5e429bcc9c2e4a41a3c7a4d96203be6cb273b11" translate="yes" xml:space="preserve">
          <source>Data</source>
          <target state="translated">Data</target>
        </trans-unit>
        <trans-unit id="8b9caf893c3cf91b7f2aa71e4497cbf2f851b68d" translate="yes" xml:space="preserve">
          <source>Data Explorer</source>
          <target state="translated">데이터 탐색기</target>
        </trans-unit>
        <trans-unit id="d365007e9285e56a82a0d4a50d4ce02c38ea2bd6" translate="yes" xml:space="preserve">
          <source>Data exploration</source>
          <target state="translated">데이터 탐색</target>
        </trans-unit>
        <trans-unit id="e647ab0384d969c13ba46e00acc1dbeab81ebb18" translate="yes" xml:space="preserve">
          <source>Data is replicated and sharded across all available servers</source>
          <target state="translated">사용 가능한 모든 서버에서 데이터가 복제 및 샤딩</target>
        </trans-unit>
        <trans-unit id="db6540bb03f22b23247d342c2b1b2966867d2200" translate="yes" xml:space="preserve">
          <source>Data is replicated to two servers, and sharded across all available servers</source>
          <target state="translated">데이터는 두 서버로 복제되고 사용 가능한 모든 서버에서 샤딩됩니다.</target>
        </trans-unit>
        <trans-unit id="d618d6d58df4367a11cfef92a4e0459977e3b2cd" translate="yes" xml:space="preserve">
          <source>Data is sent from the shards to the query server and combined.</source>
          <target state="translated">샤드에서 쿼리 서버로 데이터가 전송되고 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="e130f9403cd7619355e4457ebdab02dfaa509a98" translate="yes" xml:space="preserve">
          <source>Data modeling in RethinkDB</source>
          <target state="translated">RethinkDB의 데이터 모델링</target>
        </trans-unit>
        <trans-unit id="943c775b39fa28fba2a9c7b8631fbd9577ac838d" translate="yes" xml:space="preserve">
          <source>Data storage</source>
          <target state="translated">데이터 저장고</target>
        </trans-unit>
        <trans-unit id="b6be514c02654c4ded06230fc9559da237b0aa77" translate="yes" xml:space="preserve">
          <source>Data types</source>
          <target state="translated">자료형</target>
        </trans-unit>
        <trans-unit id="0bec5093fae4de651755330a0d2e85f3ba21c4d2" translate="yes" xml:space="preserve">
          <source>Dates and Times</source>
          <target state="translated">날짜와 시간</target>
        </trans-unit>
        <trans-unit id="4fae1a3c22c69a38da3102b05f957492235e0b3a" translate="yes" xml:space="preserve">
          <source>Dates and times</source>
          <target state="translated">날짜와 시간</target>
        </trans-unit>
        <trans-unit id="f19a185740f7c93f91d8d499c02a3d9189637966" translate="yes" xml:space="preserve">
          <source>Dates and times in RethinkDB</source>
          <target state="translated">RethinkDB의 날짜 및 시간</target>
        </trans-unit>
        <trans-unit id="f775329a5b94da0d8b124d7e0ac6a8c3f9336607" translate="yes" xml:space="preserve">
          <source>Debian</source>
          <target state="translated">Debian</target>
        </trans-unit>
        <trans-unit id="9528e2e3ab6af8459d12161c313a88e31b5823fe" translate="yes" xml:space="preserve">
          <source>Delete a previously created secondary index of this table.</source>
          <target state="translated">이 테이블의 이전에 작성된 보조 인덱스를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="e05abdc50588bf68eb6bc6f44e4be48a418f7b0a" translate="yes" xml:space="preserve">
          <source>Delete documents</source>
          <target state="translated">문서 삭제</target>
        </trans-unit>
        <trans-unit id="07ce472a068f0cc18a9be86eb69bceae3b91bfec" translate="yes" xml:space="preserve">
          <source>Delete one or more documents from a table.</source>
          <target state="translated">테이블에서 하나 이상의 문서를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="a833a498a36f4aff3d78936eddd16d106320aa52" translate="yes" xml:space="preserve">
          <source>Delete returns an object that contains the following attributes:</source>
          <target state="translated">Delete는 다음 속성이 포함 된 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1745161c87e406772ee2df2d87684d5a4e2089ce" translate="yes" xml:space="preserve">
          <source>Deleting documents</source>
          <target state="translated">문서 삭제</target>
        </trans-unit>
        <trans-unit id="d6a07e3c5f985b6ebd26237332a8a3e26ca113a0" translate="yes" xml:space="preserve">
          <source>Deleting, adding or updating a post requires loading the entire &lt;code&gt;posts&lt;/code&gt; array, modifying it, and writing the entire document back to disk.</source>
          <target state="translated">게시물을 삭제, 추가 또는 업데이트하려면 전체 &lt;code&gt;posts&lt;/code&gt; 배열을 로드하고 수정 한 다음 전체 문서를 디스크에 다시 써야합니다.</target>
        </trans-unit>
        <trans-unit id="3ff625daa7b77b086fdbd69b0b1b1f1c4ce32b4b" translate="yes" xml:space="preserve">
          <source>Delphi</source>
          <target state="translated">Delphi</target>
        </trans-unit>
        <trans-unit id="effcb2931e5e0d725f1a5daa33a0739f5138aaae" translate="yes" xml:space="preserve">
          <source>Depending on how fast your application makes changes to monitored data and how fast it processes change notifications, it&amp;rsquo;s possible that more than one change will happen between calls to the &lt;code&gt;changes&lt;/code&gt; command. You can control what happens in that case with the &lt;code&gt;squash&lt;/code&gt; optional argument.</source>
          <target state="translated">응용 프로그램이 모니터링되는 데이터를 얼마나 빨리 변경하고 변경 알림을 처리하는 속도에 따라 &lt;code&gt;changes&lt;/code&gt; 명령 호출간에 두 가지 이상의 변경이 발생할 수 있습니다. 이 경우 &lt;code&gt;squash&lt;/code&gt; 옵션 인수를 사용하여 발생하는 작업을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df8c99c35f803d94036fc0049e6d061050f1d1cd" translate="yes" xml:space="preserve">
          <source>Depending on how you start the RethinkDB server process, there are two ways to set the cache size.</source>
          <target state="translated">RethinkDB 서버 프로세스를 시작하는 방법에 따라 캐시 크기를 설정하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d12578d950ce7df9635024755adbe3e89422ecb6" translate="yes" xml:space="preserve">
          <source>Depending on how you&amp;rsquo;ve installed Elasticsearch, you may need to become the elasticsearch user or root to run this command.</source>
          <target state="translated">Elasticsearch를 설치 한 방법에 따라이 명령을 실행하려면 elasticsearch 사용자 또는 루트가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="33e1f1d5a5b77e669798e1400d615354aa90151c" translate="yes" xml:space="preserve">
          <source>Depending on the driver, this error may also appear as &amp;ldquo;Maximum expression depth exceeded.&amp;rdquo;</source>
          <target state="translated">드라이버에 따라이 오류는 &quot;최대 표현 깊이 초과&quot;로 나타날 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab80f58b2bc900fd52cc75f390dbeea13a146ffd" translate="yes" xml:space="preserve">
          <source>Depending on your OS, you may need to install a library such as &lt;code&gt;libapache2-mod-proxy-html&lt;/code&gt;.</source>
          <target state="translated">OS에 따라 &lt;code&gt;libapache2-mod-proxy-html&lt;/code&gt; 과 같은 라이브러리를 설치해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1c93da7d096d628d4f1e05e5d4cb5a7601d76fe" translate="yes" xml:space="preserve">
          <source>Deploying on AWS</source>
          <target state="translated">AWS에 배포</target>
        </trans-unit>
        <trans-unit id="6f934d359e2161c5c447a97c847b049c2453f1ed" translate="yes" xml:space="preserve">
          <source>Deploying on Compose</source>
          <target state="translated">작성시 배포</target>
        </trans-unit>
        <trans-unit id="5b23f1c4cf72fb9ca2d541b5fef18fcce6ab95d4" translate="yes" xml:space="preserve">
          <source>Deploying with PaaS</source>
          <target state="translated">PaaS로 배포</target>
        </trans-unit>
        <trans-unit id="ec9f02b05ec165ff64ba7bdb5303a4e9b3e3bdb2" translate="yes" xml:space="preserve">
          <source>Deploying with a PaaS</source>
          <target state="translated">PaaS와 함께 배포</target>
        </trans-unit>
        <trans-unit id="1c79a01c2ceb5ed61a5c531918e7a81ec32c0890" translate="yes" xml:space="preserve">
          <source>Deployment Tools</source>
          <target state="translated">배포 도구</target>
        </trans-unit>
        <trans-unit id="ed0f20dd3148c1143a36b70a1313bce02cb80424" translate="yes" xml:space="preserve">
          <source>Deployment tools</source>
          <target state="translated">배포 도구</target>
        </trans-unit>
        <trans-unit id="89cc06c86751edabc6c90df0509d55c9e99a9317" translate="yes" xml:space="preserve">
          <source>Deprecated versions</source>
          <target state="translated">더 이상 사용되지 않는 버전</target>
        </trans-unit>
        <trans-unit id="6f66b82cc3959400c54a999fcda03979f8f0607e" translate="yes" xml:space="preserve">
          <source>Derived terms: &lt;code&gt;pluck&lt;/code&gt;, &lt;code&gt;with_field&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;eq_join&lt;/code&gt;</source>
          <target state="translated">파생 조건 : &lt;code&gt;pluck&lt;/code&gt; , &lt;code&gt;with_field&lt;/code&gt; , &lt;code&gt;count&lt;/code&gt; , &lt;code&gt;eq_join&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="23919e02e51fd535b192fd7ffe5da8552197fb33" translate="yes" xml:space="preserve">
          <source>Describe your environment</source>
          <target state="translated">환경 설명</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="f66cba6f2178921ae061ace5374666db48758a3a" translate="yes" xml:space="preserve">
          <source>Detailed results</source>
          <target state="translated">자세한 결과</target>
        </trans-unit>
        <trans-unit id="650e4825d787dfc5aa53b95e0be31c8aaea57499" translate="yes" xml:space="preserve">
          <source>Different languages support iterators in different ways, but the fundamental concept is always the same: the result set is traversed in a loop that returns one result set at a time. In Python, you might loop through a stream this way:</source>
          <target state="translated">언어마다 다른 방식으로 반복자를 지원하지만 기본 개념은 항상 동일합니다. 결과 집합은 한 번에 하나의 결과 집합을 반환하는 루프로 이동합니다. 파이썬에서는 다음과 같이 스트림을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd8e45bac7d354790ec0a82d8a61341bf8acd055" translate="yes" xml:space="preserve">
          <source>Direction</source>
          <target state="translated">Direction</target>
        </trans-unit>
        <trans-unit id="cc93d53b6beace191a6f445c5a57258d17c49b9d" translate="yes" xml:space="preserve">
          <source>Display the top 10 movies&amp;hellip;</source>
          <target state="translated">상위 10 개 영화를 표시하십시오&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="45d493a8c9d0ea055cc322309346130d4e45729e" translate="yes" xml:space="preserve">
          <source>Distances in ReQL are (by default) calculated assuming not a perfect sphere but an ellipsoid, using a precise and relatively fast algorithm developed by &lt;a href=&quot;http://link.springer.com/article/10.1007%2Fs00190-012-0578-z&quot;&gt;Charles Karney&lt;/a&gt;. The reference ellipsoid used is &lt;a href=&quot;http://en.wikipedia.org/wiki/World_Geodetic_System&quot;&gt;WGS84&lt;/a&gt;, the standard used for GPS. By default distances are specified in meters, but you can pass an optional argument to distance functions to specify kilometers, miles, nautical miles, and feet.</source>
          <target state="translated">ReQL의 거리는 &lt;a href=&quot;http://link.springer.com/article/10.1007%2Fs00190-012-0578-z&quot;&gt;Charles Karney가&lt;/a&gt; 개발 한 정확하고 비교적 빠른 알고리즘을 사용하여 완벽한 구가 아니라 타원체를 가정하여 기본적으로 계산됩니다 . 사용 된 기준 타원체는 GPS에 사용되는 표준 인 &lt;a href=&quot;http://en.wikipedia.org/wiki/World_Geodetic_System&quot;&gt;WGS84&lt;/a&gt; 입니다. 기본적으로 거리는 미터 단위로 지정되지만 거리 함수에 선택적 인수를 전달하여 킬로미터, 마일, 해리 및 피트를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de1f8cd3e607f28818c75125e0d7ded683d13fc1" translate="yes" xml:space="preserve">
          <source>Distinguishing between data types</source>
          <target state="translated">데이터 유형 구분</target>
        </trans-unit>
        <trans-unit id="e62465ada9d89a46cc8c5c2dc70da727fcad33e2" translate="yes" xml:space="preserve">
          <source>Divide two numbers.</source>
          <target state="translated">두 숫자를 나누십시오.</target>
        </trans-unit>
        <trans-unit id="9f1141549f7c054b71516937d3febc77d991d59b" translate="yes" xml:space="preserve">
          <source>Docker</source>
          <target state="translated">Docker</target>
        </trans-unit>
        <trans-unit id="6b39f4df8e4dc03149e4ba286d380689a8fb7970" translate="yes" xml:space="preserve">
          <source>Docker images</source>
          <target state="translated">도커 이미지</target>
        </trans-unit>
        <trans-unit id="fa5b6b6b8330688c9b91298710f39ce32d51f016" translate="yes" xml:space="preserve">
          <source>Docker provides an &lt;a href=&quot;https://registry.hub.docker.com/_/rethinkdb/&quot;&gt;official RethinkDB repository&lt;/a&gt; on the Docker Hub. (Read &lt;a href=&quot;../install/index&quot;&gt;Installing RethinkDB&lt;/a&gt; for more details.) This list highlights community-provided Docker images and tools.</source>
          <target state="translated">Docker는 Docker Hub에서 &lt;a href=&quot;https://registry.hub.docker.com/_/rethinkdb/&quot;&gt;공식 RethinkDB 저장소&lt;/a&gt; 를 제공합니다 . ( 자세한 내용은 &lt;a href=&quot;../install/index&quot;&gt;RethinkDB 설치&lt;/a&gt; 를 참조하십시오.)이 목록은 커뮤니티 제공 Docker 이미지 및 도구를 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="32aa99a0683d07f754b24707cd866a8fe7496c82" translate="yes" xml:space="preserve">
          <source>Docker provides an &lt;a href=&quot;https://registry.hub.docker.com/_/rethinkdb/&quot;&gt;official RethinkDB repository&lt;/a&gt; on the Docker Hub. To deploy RethinkDB on Docker, run the following command:</source>
          <target state="translated">Docker는 Docker Hub에서 &lt;a href=&quot;https://registry.hub.docker.com/_/rethinkdb/&quot;&gt;공식 RethinkDB 저장소&lt;/a&gt; 를 제공합니다 . Docker에 RethinkDB를 배포하려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="75b31b4fef30460e3db1b62f8dc07903324331ba" translate="yes" xml:space="preserve">
          <source>Document Manipulation</source>
          <target state="translated">문서 조작</target>
        </trans-unit>
        <trans-unit id="a938da5f7f37d695c28d5a234aa22482b071efe1" translate="yes" xml:space="preserve">
          <source>Document manipulation</source>
          <target state="translated">문서 조작</target>
        </trans-unit>
        <trans-unit id="1c63157e8f0d28f7ff577f7e1ab7d1c3a00f8dab" translate="yes" xml:space="preserve">
          <source>Document schema</source>
          <target state="translated">문서 스키마</target>
        </trans-unit>
        <trans-unit id="7dbc40801b3a48b66d3662d20e3a304cebd58104" translate="yes" xml:space="preserve">
          <source>Documents can be inserted into &lt;code&gt;users&lt;/code&gt; to create new users and deleted to remove them. You cannot change the &lt;code&gt;id&lt;/code&gt; value of an existing document, only change or remove passwords via &lt;code&gt;update&lt;/code&gt;.</source>
          <target state="translated">문서를 &lt;code&gt;users&lt;/code&gt; 에게 삽입 하여 새 사용자를 작성하고 삭제하여 삭제할 수 있습니다. 기존 문서 의 &lt;code&gt;id&lt;/code&gt; 값을 변경할 수 없으며 &lt;code&gt;update&lt;/code&gt; 를 통해서만 비밀번호를 변경하거나 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="77b108aa347d7d6da2641ef2bbeaff49dd15b4a4" translate="yes" xml:space="preserve">
          <source>Documents can be inserted to create new databases, deleted to remove databases, and modified to rename databases. (Renaming databases is the only task that requires querying the &lt;code&gt;db_config&lt;/code&gt; table; the other two tasks have native ReQL commands, &lt;a href=&quot;../../api/javascript/db_create/index&quot;&gt;dbCreate&lt;/a&gt; and &lt;a href=&quot;../../api/javascript/db_drop/index&quot;&gt;dbDrop&lt;/a&gt;.) As with tables, if you &lt;code&gt;insert&lt;/code&gt; a database, don&amp;rsquo;t include the &lt;code&gt;id&lt;/code&gt; field: the system will auto-generate the UUID.</source>
          <target state="translated">새 데이터베이스를 작성하기 위해 문서를 삽입하고, 데이터베이스를 제거하기 위해 삭제하고, 데이터베이스 이름을 변경하도록 수정할 수 있습니다. (데이터베이스 이름 바꾸기는 &lt;code&gt;db_config&lt;/code&gt; 테이블을 쿼리해야하는 유일한 작업입니다 . 다른 두 작업에는 기본 ReQL 명령 인 &lt;a href=&quot;../../api/javascript/db_create/index&quot;&gt;dbCreate&lt;/a&gt; 및 &lt;a href=&quot;../../api/javascript/db_drop/index&quot;&gt;dbDrop이&lt;/a&gt; 있습니다.) 테이블과 마찬가지로 데이터베이스 를 &lt;code&gt;insert&lt;/code&gt; 경우 &lt;code&gt;id&lt;/code&gt; 필드를 포함하지 마십시오 . UUID를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="cd76c8f791c0cc396c4e3c262fafe0981d82c181" translate="yes" xml:space="preserve">
          <source>Documents cannot be deleted from this table. When a server loses its connection to the cluster, its corresponding document will be automatically deleted.</source>
          <target state="translated">이 테이블에서 문서를 삭제할 수 없습니다. 서버와 클러스터의 연결이 끊어지면 해당 문서가 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="2fbb62833064347b1e86da4eb252aac882b424fb" translate="yes" xml:space="preserve">
          <source>Documents in the permissions table have two to four key/value pairs.</source>
          <target state="translated">권한 테이블의 문서에는 2-4 개의 키 / 값 쌍이 있습니다.</target>
        </trans-unit>
        <trans-unit id="58cc920fdd6b780706a49274986194fa8e63b6c8" translate="yes" xml:space="preserve">
          <source>Does RethinkDB automatically reshard the database without the user&amp;rsquo;s request?</source>
          <target state="translated">RethinkDB는 사용자의 요청없이 데이터베이스를 자동으로 리 샤딩합니까?</target>
        </trans-unit>
        <trans-unit id="2cb3d80fdfcc25abece5b9ea35b0a58a6d8d6483" translate="yes" xml:space="preserve">
          <source>Does RethinkDB support secondary and compound indexes?</source>
          <target state="translated">RethinkDB는 보조 및 복합 인덱스를 지원합니까?</target>
        </trans-unit>
        <trans-unit id="c54abbee94084a1da90689b4bc1bd9997a3f20c8" translate="yes" xml:space="preserve">
          <source>Does the web UI support my browser?</source>
          <target state="translated">웹 UI가 브라우저를 지원합니까?</target>
        </trans-unit>
        <trans-unit id="a11f6f795d0b0ad6a6b5164abe13eee98c4a6a17" translate="yes" xml:space="preserve">
          <source>Doing an unpivot operation to &amp;ldquo;cancel&amp;rdquo; a pivot one can be done with the &lt;code&gt;concatMap&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;keys&lt;/code&gt; commands:</source>
          <target state="translated">피벗 피벗을 &quot;취소&quot;하기 위해 피벗 해제 작업을 수행하려면 &lt;code&gt;concatMap&lt;/code&gt; , &lt;code&gt;map&lt;/code&gt; 및 &lt;code&gt;keys&lt;/code&gt; 명령을 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b62a365d458d7fc495e82bb5feffe6da3aadcf0" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t upgrade the Python driver until &lt;em&gt;after&lt;/em&gt; you&amp;rsquo;ve dumped the data.</source>
          <target state="translated">때까지 파이썬 드라이버를 업그레이드하지 마십시오 &lt;em&gt;후&lt;/em&gt; 이 데이터를 덤프했습니다.</target>
        </trans-unit>
        <trans-unit id="b9b20397c8b4511d2977f6637e72fed5b6036fed" translate="yes" xml:space="preserve">
          <source>Download the &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/packaging/assets/config/default.conf.sample&quot;&gt;sample configuration file&lt;/a&gt; and copy it to a new location.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/packaging/assets/config/default.conf.sample&quot;&gt;샘플 구성 파일을&lt;/a&gt; 다운로드하여 새 위치에 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="b0beb6e9b2782c89528b908ead973a20cfdfe161" translate="yes" xml:space="preserve">
          <source>Drivers and extensions</source>
          <target state="translated">드라이버 및 확장</target>
        </trans-unit>
        <trans-unit id="fbc709596abc5be072df806dc4e1dbe8b5533299" translate="yes" xml:space="preserve">
          <source>Drivers with limited features</source>
          <target state="translated">기능이 제한된 드라이버</target>
        </trans-unit>
        <trans-unit id="18a8b5347ecd64b14b11492736aa49444fac1b10" translate="yes" xml:space="preserve">
          <source>Drop a database. The database, all its tables, and corresponding data will be deleted.</source>
          <target state="translated">데이터베이스를 삭제하십시오. 데이터베이스, 모든 테이블 및 해당 데이터가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="cb4a2f30c3c295a227032a99e5a4efc8550b4ecb" translate="yes" xml:space="preserve">
          <source>Drop a table from a database. The table and all its data will be deleted.</source>
          <target state="translated">데이터베이스에서 테이블을 삭제하십시오. 테이블과 모든 데이터가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="77234eb34260471a6c14dc884c48b8e9d2d71451" translate="yes" xml:space="preserve">
          <source>Due to its event-driven nature, JavaScript can easily execute RethinkDB queries in an asynchronous fashion. The official RethinkDB drivers currently support integration with EventMachine for Ruby, and Tornado and Twisted for Python.</source>
          <target state="translated">JavaScript는 이벤트 중심 특성으로 인해 RethinkDB 쿼리를 비동기 방식으로 쉽게 실행할 수 있습니다. 공식 RethinkDB 드라이버는 현재 EventMachine for Ruby, Tornado 및 Twisted for Python과의 통합을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d055e33954e62aeccb66d357adf149b3205d3a2b" translate="yes" xml:space="preserve">
          <source>Dumping the system tables</source>
          <target state="translated">시스템 테이블 덤프</target>
        </trans-unit>
        <trans-unit id="0a7e6c99bf8926a19096e8badb44937bd7a22e17" translate="yes" xml:space="preserve">
          <source>Dynamo-based systems such as Cassandra and Riak choose to maintain stronger availability. In these systems if there is a network partition, the clients can write to the same row on both sides of the netsplit. In exchange for the write availability, applications built on top of these systems must deal with various complexities such as clock skew, conflict resolution code, conflict repair operations, performance issues for highly contested keys, and latency issues associated with quorums.</source>
          <target state="translated">Cassandra 및 Riak와 같은 Dynamo 기반 시스템은 더 강력한 가용성을 유지하도록 선택합니다. 이러한 시스템에서 네트워크 파티션이있는 경우 클라이언트는 netsplit의 양쪽에서 동일한 행에 쓸 수 있습니다. 쓰기 가용성과 교환하여 이러한 시스템 위에 구축 된 응용 프로그램은 클럭 스큐, 충돌 해결 코드, 충돌 복구 작업, 경쟁이 치열한 키의 성능 문제 및 쿼럼과 관련된 대기 시간 문제와 같은 다양한 복잡성을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="bc4c2235b8ffe6c816e63179a9847830daefd446" translate="yes" xml:space="preserve">
          <source>Each connection sets a default database to use during its lifetime (if you don&amp;rsquo;t specify one in &lt;code&gt;connect&lt;/code&gt;, the default database is set to &lt;code&gt;test&lt;/code&gt;). This way we can omit the &lt;code&gt;db('test')&lt;/code&gt; command in our query. We won&amp;rsquo;t specify the database explicitly from now on, but if you want to prepend your queries with the &lt;code&gt;db&lt;/code&gt; command, it won&amp;rsquo;t hurt.</source>
          <target state="translated">각 연결은 수명 동안 사용할 기본 데이터베이스를 설정합니다 ( &lt;code&gt;connect&lt;/code&gt; 에 지정하지 않으면 기본 데이터베이스는 &lt;code&gt;test&lt;/code&gt; 로 설정 됨 ). 이런 식으로 쿼리에서 &lt;code&gt;db('test')&lt;/code&gt; 명령을 생략 할 수 있습니다. 지금부터 데이터베이스를 명시 적으로 지정하지는 않지만 &lt;code&gt;db&lt;/code&gt; 명령으로 쿼리를 앞에 추가해도 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2bda4691fb673fc7859d20932c178454925c23a8" translate="yes" xml:space="preserve">
          <source>Each deployment provided by Compose is configured as a high-availability cluster with full redundancy. To create a hosted RethinkDB instance:</source>
          <target state="translated">Compose가 제공하는 각 배포는 전체 중복성을 갖춘 고 가용성 클러스터로 구성됩니다. 호스팅 된 RethinkDB 인스턴스를 생성하려면</target>
        </trans-unit>
        <trans-unit id="6991553b0f0a174312a302b3d91e2b42ac9a80f8" translate="yes" xml:space="preserve">
          <source>Each document in the table has 4 keys: &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;topic&lt;/code&gt;, &lt;code&gt;payload&lt;/code&gt;, and &lt;code&gt;updated_on&lt;/code&gt;.</source>
          <target state="translated">테이블의 각 문서에는 &lt;code&gt;id&lt;/code&gt; , &lt;code&gt;topic&lt;/code&gt; , &lt;code&gt;payload&lt;/code&gt; 및 &lt;code&gt;updated_on&lt;/code&gt; 의 4 개의 키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d16736b0f41b927b0e80d0c1604e84dbfb6dfc9f" translate="yes" xml:space="preserve">
          <source>Each exchange is a single RethinkDB table</source>
          <target state="translated">각 교환은 단일 RethinkDB 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="7272eff9575d2e5dcd51b8fa56f4684e60ec40d8" translate="yes" xml:space="preserve">
          <source>Each node in the stack has a number of methods defined on it. The three most important methods define how to execute a subset of the query on each server in the cluster, how to combine the data from multiple servers into a unified resultset, and how to stream data to the nodes further up in small chunks.</source>
          <target state="translated">스택의 각 노드에는 여러 가지 메소드가 정의되어 있습니다. 가장 중요한 세 가지 방법은 클러스터의 각 서버에서 쿼리의 하위 집합을 실행하는 방법, 여러 서버의 데이터를 통합 된 결과 집합으로 결합하는 방법 및 데이터를 노드로 더 작은 단위로 스트리밍하는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="bfbf4483e1bde08c75691f32887e599012a54f2a" translate="yes" xml:space="preserve">
          <source>Each object has its own document schema. The field names are, for the most part, self-explanatory. The fields &lt;code&gt;server&lt;/code&gt;, &lt;code&gt;db&lt;/code&gt; and &lt;code&gt;table&lt;/code&gt; will be either UUIDs or strings depending on the value of the &lt;code&gt;identifier_format&lt;/code&gt; optional argument to &lt;code&gt;table&lt;/code&gt;.</source>
          <target state="translated">각 객체에는 고유 한 문서 스키마가 있습니다. 필드 이름은 대부분 설명이 필요하지 않습니다. &lt;code&gt;server&lt;/code&gt; , &lt;code&gt;db&lt;/code&gt; 및 &lt;code&gt;table&lt;/code&gt; 필드 는 &lt;code&gt;identifier_format&lt;/code&gt; 선택적 인수의 &lt;code&gt;table&lt;/code&gt; 값에 따라 UUID 또는 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="ad9d8589f53751a8b3126b0096d187054fd7d071" translate="yes" xml:space="preserve">
          <source>Easily load fixtures into RethinkDB for testing purposes.</source>
          <target state="translated">테스트 목적으로 픽스쳐를 RethinkDB에 쉽게로드합니다.</target>
        </trans-unit>
        <trans-unit id="e32a6018f677d153baed9e23a9d00eea2b1a226e" translate="yes" xml:space="preserve">
          <source>Edit &lt;code&gt;/Library/LaunchDaemons/com.rethinkdb.server.plist&lt;/code&gt; to change the &lt;code&gt;ProgramArguments&lt;/code&gt; key so RethinkDB will use your configuration file.</source>
          <target state="translated">편집 &lt;code&gt;/Library/LaunchDaemons/com.rethinkdb.server.plist&lt;/code&gt; 는 변화에 &lt;code&gt;ProgramArguments&lt;/code&gt; 의 RethinkDB가 구성 파일을 사용할 수 있도록 키를 누릅니다.</target>
        </trans-unit>
        <trans-unit id="d3e5fe656bcf9ca1d416f76153e551f5a62b139f" translate="yes" xml:space="preserve">
          <source>Edit the configuration file in your favorite editor. While you may be able to leave many options at their defaults, you&amp;rsquo;ll definitely need to change the &lt;code&gt;directory=&lt;/code&gt; line in the file to point to your data directory.</source>
          <target state="translated">선호하는 편집기에서 구성 파일을 편집하십시오. 많은 옵션을 기본값으로 남겨 둘 수는 있지만 데이터 디렉토리를 가리 키도록 파일 의 &lt;code&gt;directory=&lt;/code&gt; 행 을 변경해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4507364d9ff843e33e9dfd959072b53a9b706627" translate="yes" xml:space="preserve">
          <source>Efficiently generating monotonically increasing IDs in a distributed system is a surprisingly difficult problem. If an inserted document is missing a primary key, RethinkDB currently generates a random UUID. We will be supporting additional autogeneration schemes in the future (see &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/117&quot;&gt;https://github.com/rethinkdb/rethinkdb/issues/117&lt;/a&gt;), but in the meantime, you can use one of the available open-source libraries for distributed id generation (e.g. &lt;a href=&quot;https://github.com/twitter/snowflake&quot;&gt;twitter snowflake&lt;/a&gt;).</source>
          <target state="translated">분산 시스템에서 단조 증가하는 ID를 효율적으로 생성하는 것은 놀랍게도 어려운 문제입니다. 삽입 된 문서에 기본 키가 없으면 RethinkDB는 현재 임의의 UUID를 생성합니다. 향후 추가 자동 생성 체계를 지원할 예정 이지만 ( &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/117&quot;&gt;https://github.com/rethinkdb/rethinkdb/issues/117 참조&lt;/a&gt; ), 그 동안 분산 형 ID 생성을 위해 사용 가능한 오픈 소스 라이브러리 중 하나를 사용할 수 있습니다 ( 예를 들어 &lt;a href=&quot;https://github.com/twitter/snowflake&quot;&gt;트위터 눈송이&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="55c3ec54949c74e47fc42b6a97ebe9eaac04e579" translate="yes" xml:space="preserve">
          <source>Efficiently retrieving multiple documents by primary key</source>
          <target state="translated">기본 키로 여러 문서를 효율적으로 검색</target>
        </trans-unit>
        <trans-unit id="31c7109c183332e4271eaa092839ec690cb7473c" translate="yes" xml:space="preserve">
          <source>Efficiently retrieving multiple documents by secondary index</source>
          <target state="translated">보조 인덱스로 여러 문서를 효율적으로 검색</target>
        </trans-unit>
        <trans-unit id="49fa9fd831096c82ab950bc7aa0a0a7ef8a10998" translate="yes" xml:space="preserve">
          <source>Element</source>
          <target state="translated">Element</target>
        </trans-unit>
        <trans-unit id="c0c7bf14304705b88f3bf9ecdfcf919293c76e53" translate="yes" xml:space="preserve">
          <source>Elixir</source>
          <target state="translated">Elixir</target>
        </trans-unit>
        <trans-unit id="16ecb5f9431de8b0cec5717985eb281e13fa564f" translate="yes" xml:space="preserve">
          <source>Ember.js</source>
          <target state="translated">Ember.js</target>
        </trans-unit>
        <trans-unit id="458e24469151660fde7d84afba0b01bacced24d3" translate="yes" xml:space="preserve">
          <source>Ember.js Todo List in the spirit of &lt;a href=&quot;http://todomvc.com/&quot;&gt;TodoMVC&lt;/a&gt;.</source>
          <target state="translated">의 정신 Ember.js 할 일 목록 &lt;a href=&quot;http://todomvc.com/&quot;&gt;TodoMVC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4326def9b0d2a88275d51ab55b6090e5dcc267f" translate="yes" xml:space="preserve">
          <source>Emergency Repair mode</source>
          <target state="translated">응급 복구 모드</target>
        </trans-unit>
        <trans-unit id="6a3bf7c36dac32c9fd690a01446afb3c63dce903" translate="yes" xml:space="preserve">
          <source>Encapsulate binary data within a query.</source>
          <target state="translated">쿼리 내에서 이진 데이터를 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="221c7ec5b48be1b9c45eee5c3086aa9f31aaeabf" translate="yes" xml:space="preserve">
          <source>End the sequence after the given number of elements.</source>
          <target state="translated">주어진 수의 요소 뒤에 순서를 끝내십시오.</target>
        </trans-unit>
        <trans-unit id="0df15f0bc25e5c3cc56af8f7cd91284eacfd6f56" translate="yes" xml:space="preserve">
          <source>Ensure you have &lt;a href=&quot;../../install/index&quot;&gt;RethinkDB installed&lt;/a&gt; for your platform</source>
          <target state="translated">플랫폼에 &lt;a href=&quot;../../install/index&quot;&gt;RethinkDB가 설치되어&lt;/a&gt; 있는지 확인하십시오</target>
        </trans-unit>
        <trans-unit id="e65cbb827f74ca21dd794dac16142d8c51d82030" translate="yes" xml:space="preserve">
          <source>Ensure you have &lt;a href=&quot;../install/index&quot;&gt;RethinkDB installed&lt;/a&gt; for your platform.</source>
          <target state="translated">플랫폼에 &lt;a href=&quot;../install/index&quot;&gt;RethinkDB가 설치되어&lt;/a&gt; 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="684d0de7cbf294a85fcbfcf11a5690384bb77c18" translate="yes" xml:space="preserve">
          <source>Enter &amp;ldquo;29015&amp;rdquo; as the port range.</source>
          <target state="translated">포트 범위로 &quot;29015&quot;를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="64c494d3e04ef93491bd5c9b7b9476e163d4ea57" translate="yes" xml:space="preserve">
          <source>Enter a name for the deployment.</source>
          <target state="translated">배치 이름을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="73005778a4f4d967ddcff2ebbccae0f463990331" translate="yes" xml:space="preserve">
          <source>Erlang</source>
          <target state="translated">Erlang</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="791a69f19a69a95d78745770545e8504ba8e369a" translate="yes" xml:space="preserve">
          <source>Error types</source>
          <target state="translated">오류 유형</target>
        </trans-unit>
        <trans-unit id="9893c883c41be4565bdda5358a42e0fd8977e8d3" translate="yes" xml:space="preserve">
          <source>Even if the primary keys contain unevenly distributed data (such as human last names, where some keys are likely to occur much more frequently than others), the system will still pick a correct split point to ensure that each shard has a roughly similar number of documents (there are many more Smiths in the phone book than Akhmechets).</source>
          <target state="translated">기본 키에 불균일하게 분산 된 데이터 (예 : 사람의 성, 일부 키가 다른 키보다 훨씬 더 자주 발생할 가능성이있는 데이터)가 포함되어 있어도 시스템은 여전히 ​​정확한 분할 점을 선택하여 각 샤드의 개수가 대략적으로 비슷합니다. 문서 (Akhmechets보다 전화 번호부에 Smiths가 더 많습니다).</target>
        </trans-unit>
        <trans-unit id="ee7229cc0c11c76bb5a58938403dcb7679db6155" translate="yes" xml:space="preserve">
          <source>Even if you have a cluster of RethinkDB nodes, you can send your queries to any node and the cluster will create and execute distributed programs that get the data from relevant nodes, perform the necessary computations, and present you with final results without you ever worrying about it.</source>
          <target state="translated">RethinkDB 노드 클러스터가 있더라도 쿼리를 모든 노드로 보낼 수 있으며 클러스터는 관련 노드에서 데이터를 가져오고 필요한 계산을 수행하며 걱정하지 않고 최종 결과를 제공하는 분산 프로그램을 작성 및 실행합니다. 그것에 대해.</target>
        </trans-unit>
        <trans-unit id="e8186b7a747164ffe7fc470fc9dfd07e508dd436" translate="yes" xml:space="preserve">
          <source>EventEmitter (connection)</source>
          <target state="translated">EventEmitter (연결)</target>
        </trans-unit>
        <trans-unit id="bcf0bce813d172f15366d452a13113661b93a921" translate="yes" xml:space="preserve">
          <source>EventEmitter (cursor)</source>
          <target state="translated">EventEmitter (커서)</target>
        </trans-unit>
        <trans-unit id="e997035a957390f625a59a7348af8b534ca9f9a7" translate="yes" xml:space="preserve">
          <source>Every ReQL query, from filters, to updates, to table joins is done by calling appropriate methods.</source>
          <target state="translated">필터에서 업데이트, 테이블 조인에 이르는 모든 ReQL 쿼리는 적절한 메서드를 호출하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4934e9c40e5cc4251d0ee5a19046b039698ba0c7" translate="yes" xml:space="preserve">
          <source>Every post contains an &lt;code&gt;author_id&lt;/code&gt; field that links each post to its author. We can retrieve all posts for a given author as follows:</source>
          <target state="translated">모든 게시물에는 각 게시물을 작성자와 연결 하는 &lt;code&gt;author_id&lt;/code&gt; 필드가 있습니다. 주어진 저자에 대한 모든 게시물을 다음과 같이 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df5fcccb14f2a7dcbaa752d5c45e28a725a1a5ca" translate="yes" xml:space="preserve">
          <source>Every server that has ever been part of the cluster and has not been permanently removed will have a row in this table in the following format.</source>
          <target state="translated">클러스터의 일부이며 영구적으로 제거되지 않은 모든 서버는이 테이블에 다음 형식의 행을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="bfc2c0d73225f81a276d37dd019c55d163987b1d" translate="yes" xml:space="preserve">
          <source>Every shard in RethinkDB is assigned to a single authoritative primary replica. All reads and writes to any key in a given shard always get routed to its respective primary, where they&amp;rsquo;re ordered and evaluated. Data always remains immediately consistent and conflict-free, and a read that follows an acknowledged write is always guaranteed to see the write. However, neither reads nor writes are guaranteed to succeed if the primary replica is unavailable.</source>
          <target state="translated">RethinkDB의 모든 샤드는 하나의 신뢰할 수있는 기본 복제본에 할당됩니다. 주어진 샤드의 모든 키에 대한 모든 읽기 및 쓰기는 항상 주문 및 평가되는 해당 기본 키로 라우팅됩니다. 데이터는 항상 일관되고 충돌이없는 상태로 유지되며 승인 된 쓰기 뒤에 오는 읽기는 항상 쓰기를 보장합니다. 그러나 기본 복제본을 사용할 수없는 경우 읽기 나 쓰기가 성공하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e35c5d4273e10ed0a55b2c445fe2e46bf98c9665" translate="yes" xml:space="preserve">
          <source>Every time a change occurs, &lt;code&gt;changeCursor.each&lt;/code&gt; will push the message into the exchange. The &lt;code&gt;routingKey&lt;/code&gt; is the topic we&amp;rsquo;ll be sending it on. For this example, we have three different topics: &lt;code&gt;mytable.create&lt;/code&gt;, &lt;code&gt;mytable.update&lt;/code&gt;, and &lt;code&gt;mytable.delete&lt;/code&gt;. Each topic contains only changes of the corresponding type. The function &lt;code&gt;typeOfChange&lt;/code&gt; does this mapping using the protocol described above.</source>
          <target state="translated">변경이 발생할 때마다 &lt;code&gt;changeCursor.each&lt;/code&gt; 는 메시지를 교환으로 푸시합니다. &lt;code&gt;routingKey&lt;/code&gt; 는 우리가 그것을 전송됩니다 주제입니다. 이 예에서는 &lt;code&gt;mytable.create&lt;/code&gt; , &lt;code&gt;mytable.update&lt;/code&gt; 및 &lt;code&gt;mytable.delete&lt;/code&gt; 의 세 가지 주제가 있습니다 . 각 주제는 해당 유형의 변경 사항 만 포함합니다. &lt;code&gt;typeOfChange&lt;/code&gt; 함수 는 위에서 설명한 프로토콜을 사용하여이 매핑을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a811992abb7ef148772f3b9c5c56152d161a926f" translate="yes" xml:space="preserve">
          <source>Example 1: No auth key</source>
          <target state="translated">예 1 : 인증 키 없음</target>
        </trans-unit>
        <trans-unit id="a5d292470fae05aa6d7048619686195ac62f92f4" translate="yes" xml:space="preserve">
          <source>Example 2: Auth key</source>
          <target state="translated">예 2 : 인증 키</target>
        </trans-unit>
        <trans-unit id="cc604bfa71e82620908be6522acdac0ccf013433" translate="yes" xml:space="preserve">
          <source>Example projects</source>
          <target state="translated">프로젝트 예</target>
        </trans-unit>
        <trans-unit id="3794ebad772830eca733e9966ea24955a9ddc9f3" translate="yes" xml:space="preserve">
          <source>Example return:</source>
          <target state="translated">반환 예 :</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="48de4726cf54009b460401c3363adcbb0eb3dba2" translate="yes" xml:space="preserve">
          <source>Except for brief periods, a table will remain fully available as long as more than half of the voting replicas for each shard and for the table overall are available. If half or more of the voting replicas for a shard are lost, then read or write operations on that shard will fail.</source>
          <target state="translated">짧은 기간을 제외하고 각 샤드 및 전체 테이블에 대해 투표 복제본의 절반 이상이 사용 가능한 한 테이블은 계속 사용 가능한 상태로 유지됩니다. 샤드에 대한 투표 복제본 중 절반 이상이 손실되면 해당 샤드에 대한 읽기 또는 쓰기 작업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="b768387bbe4cb9d8e7a343a0759a79ea61b10e24" translate="yes" xml:space="preserve">
          <source>Existing table structure:</source>
          <target state="translated">기존 테이블 구조 :</target>
        </trans-unit>
        <trans-unit id="af29b2b47889fc78a1ab192fe0dff01cc3ab0eb4" translate="yes" xml:space="preserve">
          <source>Explicitly closing a query</source>
          <target state="translated">명시 적으로 쿼리 닫기</target>
        </trans-unit>
        <trans-unit id="40ec07205cb64084dce637e132963989fbff84cb" translate="yes" xml:space="preserve">
          <source>Export your data from the existing version of RethinkDB</source>
          <target state="translated">기존 버전의 RethinkDB에서 데이터 내보내기</target>
        </trans-unit>
        <trans-unit id="9169942c048ce97de46464ad1b4d520fe7600219" translate="yes" xml:space="preserve">
          <source>Exporting your data</source>
          <target state="translated">데이터 내보내기</target>
        </trans-unit>
        <trans-unit id="8b652040961793dd0ebfc35016e694eff7d88f91" translate="yes" xml:space="preserve">
          <source>Express</source>
          <target state="translated">Express</target>
        </trans-unit>
        <trans-unit id="094d3530231e5ca3d987c037cbb823e63804c875" translate="yes" xml:space="preserve">
          <source>Express 4.0</source>
          <target state="translated">익스프레스 4.0</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="53f6dcd6161f513e923433a491e5f54eaf4dd51c" translate="yes" xml:space="preserve">
          <source>External API access</source>
          <target state="translated">외부 API 액세스</target>
        </trans-unit>
        <trans-unit id="03688ba6aa340b87549088aa5739944cb6b1dc73" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="translated">FAQ</target>
        </trans-unit>
        <trans-unit id="6d272f803d08e8669caa084ab669e54ff905af2c" translate="yes" xml:space="preserve">
          <source>Failover</source>
          <target state="translated">Failover</target>
        </trans-unit>
        <trans-unit id="1e094a40fa4f339157a419a03f2d26c83e268e5e" translate="yes" xml:space="preserve">
          <source>Featured articles</source>
          <target state="translated">특집 기사</target>
        </trans-unit>
        <trans-unit id="bc5fc74a0c921be17dde1b381a9a43609da45dab" translate="yes" xml:space="preserve">
          <source>Fedora</source>
          <target state="translated">Fedora</target>
        </trans-unit>
        <trans-unit id="91374dd61d5fb52c72288440c99c7a71e6e1c396" translate="yes" xml:space="preserve">
          <source>Feel free to skip this section if you don&amp;rsquo;t want to learn about realtime feeds yet. You can always go back and start a feed later.</source>
          <target state="translated">실시간 피드에 대해 아직 배우고 싶지 않다면이 섹션을 건너 뛰십시오. 언제든지 돌아가서 나중에 피드를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5fb46d22a2eee9eb377c00b943444683f1c8d72" translate="yes" xml:space="preserve">
          <source>File path options</source>
          <target state="translated">파일 경로 옵션</target>
        </trans-unit>
        <trans-unit id="4c6ac57b7b2f95e8e3cc573dcd9555b79add3e53" translate="yes" xml:space="preserve">
          <source>Filter documents based on a condition</source>
          <target state="translated">조건에 따라 문서 필터링</target>
        </trans-unit>
        <trans-unit id="9075edca21736af901d2add18e4d9491f2452b4d" translate="yes" xml:space="preserve">
          <source>Filtering</source>
          <target state="translated">Filtering</target>
        </trans-unit>
        <trans-unit id="dabdc190e7d6d2a2992b2debc16e730a618235dc" translate="yes" xml:space="preserve">
          <source>Filtering based on a date range</source>
          <target state="translated">날짜 범위를 기준으로 필터링</target>
        </trans-unit>
        <trans-unit id="af40e126c53eb88044d3587384e4011154e5a4fd" translate="yes" xml:space="preserve">
          <source>Filtering based on arrays</source>
          <target state="translated">배열을 기준으로 필터링</target>
        </trans-unit>
        <trans-unit id="0b2f0d7e22b6f03b5f567605417abec343bcc4b8" translate="yes" xml:space="preserve">
          <source>Filtering based on multiple fields</source>
          <target state="translated">여러 필드를 기반으로 필터링</target>
        </trans-unit>
        <trans-unit id="8e2d44be20b1b0d731e62015e059016b0e47760e" translate="yes" xml:space="preserve">
          <source>Filtering based on nested fields</source>
          <target state="translated">중첩 필드를 기준으로 필터링</target>
        </trans-unit>
        <trans-unit id="2a953fd3faedac0d8e2ec397ba08d4bffbdc0082" translate="yes" xml:space="preserve">
          <source>Filtering based on the presence of a value in an array</source>
          <target state="translated">배열에 값이 있는지에 따라 필터링</target>
        </trans-unit>
        <trans-unit id="3266bec2d0caf5614ceb47d6ff723ac894da5e82" translate="yes" xml:space="preserve">
          <source>Filtering with Regex</source>
          <target state="translated">정규식으로 필터링</target>
        </trans-unit>
        <trans-unit id="b78e29b73a553d55622345da3b7fc0348685e859" translate="yes" xml:space="preserve">
          <source>Filters with &lt;code&gt;or&lt;/code&gt; return incorrect/unexpected results</source>
          <target state="translated">부정확 한 / 예기치 않은 결과를 가진 필터 &lt;code&gt;or&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="40b520f169ce16f80a18ab7b0483957867958583" translate="yes" xml:space="preserve">
          <source>Finally, let&amp;rsquo;s do a slightly more sophisticated query. Let&amp;rsquo;s find all shows with more than 100 episodes.</source>
          <target state="translated">마지막으로 조금 더 복잡한 쿼리를하겠습니다. 100 개가 넘는 에피소드가있는 모든 쇼를 찾아 보자.</target>
        </trans-unit>
        <trans-unit id="b40254fe7c26f58da4f30564ad791e6bb3c30e88" translate="yes" xml:space="preserve">
          <source>Finally, to listen to the queue, we use the &lt;code&gt;channel.consume&lt;/code&gt; generator. Similar to the changefeed cursor from RethinkDB, &lt;code&gt;consume&lt;/code&gt; will will invoke its callback whenever a message arrives in the queue.</source>
          <target state="translated">마지막으로 대기열을 듣기 위해 &lt;code&gt;channel.consume&lt;/code&gt; 생성기를 사용합니다 . RethinkDB의 변경 피드 커서와 유사하게 메시지가 큐에 도착할 때마다 &lt;code&gt;consume&lt;/code&gt; 가 콜백을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="8e5e989f2533ec8d732d8c8a750c53fbcb1d2055" translate="yes" xml:space="preserve">
          <source>Finally, we demonstrate RethinkDB&amp;rsquo;s automatic query parallelization. Analytic queries are transparently distributed over servers in the cluster in a MapReduce-style pattern.</source>
          <target state="translated">마지막으로 RethinkDB의 자동 쿼리 병렬화를 보여줍니다. 분석 쿼리는 MapReduce 스타일 패턴으로 클러스터의 서버에 투명하게 분산됩니다.</target>
        </trans-unit>
        <trans-unit id="36054e295d2fb95b73d4ac60acfca3347f2a7e1c" translate="yes" xml:space="preserve">
          <source>Finally, we used a MapReduce query to compute word counts across the whole data set. This test evaluates RethinkDB&amp;rsquo;s scalability for analytic workloads in a simplistic but very common fashion. These types of workloads involve doing information processing on the server itself versus typical single or ranged reads and writes of information processed at the application level.</source>
          <target state="translated">마지막으로 MapReduce 쿼리를 사용하여 전체 데이터 세트에서 단어 수를 계산했습니다. 이 테스트는 단순하지만 매우 일반적인 방식으로 분석 워크로드에 대한 RethinkDB의 확장 성을 평가합니다. 이러한 유형의 작업에는 서버 자체에서 정보를 처리하는 것과 응용 프로그램 수준에서 처리되는 일반적인 단일 또는 범위의 정보를 읽고 쓰는 것이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="daec87f5c6f6d393e03930bf137cc37a2652d62b" translate="yes" xml:space="preserve">
          <source>Finally, we&amp;rsquo;ll use &lt;a href=&quot;https://rethinkdb.com/api/python/ungroup/&quot;&gt;ungroup&lt;/a&gt; to turn this grouped data into an array of objects with &lt;code&gt;group&lt;/code&gt; and &lt;code&gt;reduction&lt;/code&gt; keys. The &lt;code&gt;group&lt;/code&gt; field will be the item ID for each group; the &lt;code&gt;reduction&lt;/code&gt; field will have all the items from the &lt;code&gt;concat_map&lt;/code&gt; function that belong to each group. Then we&amp;rsquo;ll use &lt;code&gt;map&lt;/code&gt; once more to iterate through that array, computing the average on this pass.</source>
          <target state="translated">마지막으로 &lt;a href=&quot;https://rethinkdb.com/api/python/ungroup/&quot;&gt;ungroup&lt;/a&gt; 을 사용 하여이 그룹화 된 데이터를 &lt;code&gt;group&lt;/code&gt; 및 &lt;code&gt;reduction&lt;/code&gt; 키 가있는 객체 배열로 변환 합니다. &lt;code&gt;group&lt;/code&gt; 필드는 각 그룹의 항목 ID 것; &lt;code&gt;reduction&lt;/code&gt; 필드에서 모든 항목 것이다 &lt;code&gt;concat_map&lt;/code&gt; 의 각 그룹에 속하는 기능. 그런 다음 &lt;code&gt;map&lt;/code&gt; 을 한 번 더 사용하여 해당 배열을 반복하여이 패스의 평균을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="007312c4c09f1856bfc29458a5dc202fddf4f4b4" translate="yes" xml:space="preserve">
          <source>Find and solve the problem preventing the server from writing to the logs (for example, freeing up disk space if the disk is full). There will only be one issue per unique error message received&amp;mdash;if multiple servers encounter the same error, only one issue will appear in the table.</source>
          <target state="translated">서버가 로그에 쓰지 못하게하는 문제를 찾아서 해결하십시오 (예 : 디스크가 가득 찬 경우 디스크 공간 확보). 수신 된 고유 한 오류 메시지 당 하나의 문제 만 있습니다. 여러 서버에서 동일한 오류가 발생하면 표에 하나의 문제 만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="c9d5cb44d3b0f58cedb8f48c955a7dce17a34fe8" translate="yes" xml:space="preserve">
          <source>Find the average number of votes for the top 25 movies</source>
          <target state="translated">상위 25 개 영화에 대한 평균 투표 수 찾기</target>
        </trans-unit>
        <trans-unit id="648ec5e5588b356c52dc1a03e0a0592b3c775435" translate="yes" xml:space="preserve">
          <source>Find the highest-ranked movie with under 100,000 votes</source>
          <target state="translated">10 만 표 이하로 가장 높은 순위의 영화 찾기</target>
        </trans-unit>
        <trans-unit id="4cc4adc30c496397d001156fd354133396026b1e" translate="yes" xml:space="preserve">
          <source>Find the most recent movie in the top 25</source>
          <target state="translated">상위 25 개 영화에서 가장 최근 영화를 찾으십시오</target>
        </trans-unit>
        <trans-unit id="a8dfcf18b0e3f6e1d60d7f31fa83be360af31827" translate="yes" xml:space="preserve">
          <source>Find the remainder when dividing two numbers.</source>
          <target state="translated">두 숫자를 나눌 때 나머지를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="42590d3f1df61cac741a6c77260a881922b2d5a1" translate="yes" xml:space="preserve">
          <source>Finds the maximum element of a sequence.</source>
          <target state="translated">시퀀스의 최대 요소를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="0fec55efc128d98cc292fb88883ac25b1680be38" translate="yes" xml:space="preserve">
          <source>Finds the minimum element of a sequence.</source>
          <target state="translated">시퀀스의 최소 요소를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="3d517c10e7012f46547c69bad63936489c2ddf91" translate="yes" xml:space="preserve">
          <source>Firefox 15 or higher</source>
          <target state="translated">Firefox 15 이상</target>
        </trans-unit>
        <trans-unit id="0102c3d8669578171735575a4840181f111c0d2f" translate="yes" xml:space="preserve">
          <source>First we&amp;rsquo;ll need to set up the connection to the RethinkDB server:</source>
          <target state="translated">먼저 RethinkDB 서버에 대한 연결을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="f0ce73e1bd3c4e021122e8bb1b9d7f61f413146e" translate="yes" xml:space="preserve">
          <source>First, create the RethinkDB data directory with the following command and set the ownership to the &lt;code&gt;rethinkdb&lt;/code&gt; user:</source>
          <target state="translated">먼저 다음 명령으로 RethinkDB 데이터 디렉토리를 작성하고 소유권을 &lt;code&gt;rethinkdb&lt;/code&gt; 사용자 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ea168b0f18b8eecb6f4610da8a8522f1ac5fc87" translate="yes" xml:space="preserve">
          <source>First, generate a 2048-bit key and save it to &lt;code&gt;key.pem&lt;/code&gt;:</source>
          <target state="translated">먼저 2048 비트 키를 생성하여 &lt;code&gt;key.pem&lt;/code&gt; 에 저장하십시오 .</target>
        </trans-unit>
        <trans-unit id="d46927480ce458a42bf3ede52b3713f2840db878" translate="yes" xml:space="preserve">
          <source>First, generate a new Rails application using NoBrainer:</source>
          <target state="translated">먼저 NoBrainer를 사용하여 새로운 Rails 애플리케이션을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="482649db685fddf30031d286f6adb954f913056f" translate="yes" xml:space="preserve">
          <source>First, let&amp;rsquo;s create a table and insert some events. We&amp;rsquo;ll insert the first event using a native Date object, and the second with the &lt;code&gt;epochTime&lt;/code&gt; constructor:</source>
          <target state="translated">먼저 테이블을 만들고 이벤트를 삽입 해 봅시다. 첫 번째 이벤트는 기본 Date 객체를 사용하고 두 번째 이벤트는 &lt;code&gt;epochTime&lt;/code&gt; 생성자를 사용하여 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="bed137906e7b113d766de24c1dbdae554b8ba4e8" translate="yes" xml:space="preserve">
          <source>First, let&amp;rsquo;s return the total price per customer. Since this is pre-computed per order in the &lt;code&gt;total&lt;/code&gt; field, this is easily done with one of RethinkDB&amp;rsquo;s aggregation functions.</source>
          <target state="translated">먼저 고객 당 총 가격을 반환합니다. 이는 &lt;code&gt;total&lt;/code&gt; 필드 에서 주문 당 사전 계산 되므로 RethinkDB의 집계 함수 중 하나를 사용하여 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebfeb613e439d6875b54587467e3236afcdfd2c0" translate="yes" xml:space="preserve">
          <source>First, protect the driver port so that it cannot be accessed from the outside world. Use the &lt;code&gt;--bind-driver&lt;/code&gt;&lt;a href=&quot;../cli-options/index&quot;&gt;command line option&lt;/a&gt; or the corresponding &lt;a href=&quot;../config-file/index&quot;&gt;configuration file option&lt;/a&gt; to bind it to &lt;code&gt;localhost&lt;/code&gt;.</source>
          <target state="translated">먼저 외부에서 접근 할 수 없도록 드라이버 포트를 보호하십시오. 사용 &lt;code&gt;--bind-driver&lt;/code&gt; &lt;a href=&quot;../cli-options/index&quot;&gt;명령 줄 옵션&lt;/a&gt; 또는 해당 &lt;a href=&quot;../config-file/index&quot;&gt;구성 파일 옵션&lt;/a&gt; 에 바인딩하는 &lt;code&gt;localhost&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd220063fd740a74a07bc036d4fc353b1e57cd3d" translate="yes" xml:space="preserve">
          <source>First, start Node.js:</source>
          <target state="translated">먼저 Node.js를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="6c63e5e20a614355612c28b38cdaeee9fe035604" translate="yes" xml:space="preserve">
          <source>First, start RethinkDB on the first machine:</source>
          <target state="translated">먼저 첫 번째 머신에서 RethinkDB를 시작하십시오 :</target>
        </trans-unit>
        <trans-unit id="dd182139ee0d88544678198a152a032ef7a33e44" translate="yes" xml:space="preserve">
          <source>First, start the RethinkDB server. Under OS X or Linux, do this from a terminal window.</source>
          <target state="translated">먼저 RethinkDB 서버를 시작하십시오. OS X 또는 Linux의 경우 터미널 창에서이를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d795fc8fda273af7dc2b5e8c1b6ccc59628dd2ed" translate="yes" xml:space="preserve">
          <source>First, the query is transformed into an execution plan that consists of a stack of internal logical operations. The operation stack fully describes the query in a data structure useful for efficient execution. The bottom-most node of the stack usually deals with data access&amp;mdash; it can be a lookup of a single document, a short range scan bounded by an index, or even a full table scan. Nodes closer to the top usually perform transformations on the data &amp;ndash; mapping the values, running reductions, grouping, etc. Nodes can be as simple as projections (i.e. returning a subset of the document), or as complex as entire stacks of stacks in case of subqueries.</source>
          <target state="translated">먼저 쿼리는 내부 논리 연산 스택으로 구성된 실행 계획으로 변환됩니다. 작업 스택은 효율적인 실행에 유용한 데이터 구조로 쿼리를 완전히 설명합니다. 스택의 맨 아래 노드는 일반적으로 데이터 액세스를 처리합니다. 단일 문서의 조회, 색인으로 묶인 단거리 스캔 또는 전체 테이블 스캔 일 수 있습니다. 최상위에 가까운 노드는 일반적으로 데이터에 대한 변환을 수행합니다 (값 매핑, 축소, 그룹화 등). 노드는 프로젝션 (예 : 문서의 하위 집합 반환)처럼 간단하거나 스택의 전체 스택처럼 복잡 할 수 있습니다. 하위 쿼리</target>
        </trans-unit>
        <trans-unit id="a013f15e6511fbb3b9f8788e0de1810c77e398a2" translate="yes" xml:space="preserve">
          <source>First, upgrade the RethinkDB server and drivers to the latest version:</source>
          <target state="translated">먼저 RethinkDB 서버 및 드라이버를 최신 버전으로 업그레이드하십시오.</target>
        </trans-unit>
        <trans-unit id="df3da99ea86affd32c6ce2c8179a2ef7ef0b2c1c" translate="yes" xml:space="preserve">
          <source>First, we select the database &lt;code&gt;test&lt;/code&gt; with the &lt;code&gt;db&lt;/code&gt; command.</source>
          <target state="translated">먼저 &lt;code&gt;db&lt;/code&gt; 명령으로 데이터베이스 &lt;code&gt;test&lt;/code&gt; 를 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="b539bd7631b9214a2867d39673c171bdf4566658" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll &lt;code&gt;group&lt;/code&gt; the posts:</source>
          <target state="translated">먼저 게시물을 &lt;code&gt;group&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="389d476d55e324c891c424c087bb86dfe6a7c88d" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll map each post to the number &lt;code&gt;1&lt;/code&gt;:</source>
          <target state="translated">먼저 각 게시물을 숫자 &lt;code&gt;1&lt;/code&gt; 에 매핑합니다 .</target>
        </trans-unit>
        <trans-unit id="4cc91d7809d2e3bf3c8f309b0f3d8a2c7aec3bfc" translate="yes" xml:space="preserve">
          <source>First, you&amp;rsquo;ll need to create a configuration file. You can download the &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/packaging/assets/config/default.conf.sample&quot;&gt;sample file&lt;/a&gt; and customize it using the &lt;a href=&quot;../config-file/index&quot;&gt;configuration file&lt;/a&gt; documentation as a guide. The most important line to change is &lt;code&gt;directory&lt;/code&gt;: this points to the RethinkDB data directory. By default, RethinkDB will use &lt;code&gt;c:\Windows\System32\rethinkdb_data&lt;/code&gt;.</source>
          <target state="translated">먼저 구성 파일을 만들어야합니다. &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/packaging/assets/config/default.conf.sample&quot;&gt;샘플 파일을&lt;/a&gt; 다운로드하고 &lt;a href=&quot;../config-file/index&quot;&gt;구성 파일&lt;/a&gt; 설명서를 가이드로 사용하여 사용자 정의 할 수 있습니다 . 변경해야 할 가장 중요한 라인은 &lt;code&gt;directory&lt;/code&gt; . 이것은 RethinkDB 데이터 디렉토리를 가리 킵니다. 기본적으로 RethinkDB는 &lt;code&gt;c:\Windows\System32\rethinkdb_data&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f749d85face6d985a84c2dd0bb2da0a1fcb65288" translate="yes" xml:space="preserve">
          <source>Flask</source>
          <target state="translated">Flask</target>
        </trans-unit>
        <trans-unit id="586977a72bd4010962bceb8eaa932a66c269cc9c" translate="yes" xml:space="preserve">
          <source>Follow the directions in the README file to perform the migration.</source>
          <target state="translated">README 파일의 지시 사항에 따라 마이그레이션을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="86d9a678e2151df849e8217ca7b153ff09f26843" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;config_changes&lt;/code&gt; and &lt;code&gt;status_changes&lt;/code&gt;, see the &lt;a href=&quot;../config/index&quot;&gt;config&lt;/a&gt; and &lt;a href=&quot;../status/index&quot;&gt;status&lt;/a&gt; commands for an explanation of the objects returned in the &lt;code&gt;old_val&lt;/code&gt; and &lt;code&gt;new_val&lt;/code&gt; fields.</source>
          <target state="translated">들어 &lt;code&gt;config_changes&lt;/code&gt; 및 &lt;code&gt;status_changes&lt;/code&gt; 의 참조 &lt;a href=&quot;../config/index&quot;&gt;설정&lt;/a&gt; 및 &lt;a href=&quot;../status/index&quot;&gt;상태&lt;/a&gt; 에 반환 된 객체에 대한 설명은 명령을 &lt;code&gt;old_val&lt;/code&gt; 및 &lt;code&gt;new_val&lt;/code&gt; 필드.</target>
        </trans-unit>
        <trans-unit id="db4922f3b8921fb32ec6caa0a025b585a5d4ec46" translate="yes" xml:space="preserve">
          <source>For a JavaScript version of the file, run &lt;code&gt;make js-driver&lt;/code&gt; in the &lt;code&gt;rethinkdb&lt;/code&gt; repo, and retrieve the JSON version of the file in &lt;code&gt;build/packages/js/proto-def.js&lt;/code&gt;. Alternatively you may grab the equivalent file from &lt;a href=&quot;https://github.com/neumino/rethinkdbdash/blob/master/lib/protodef.js&quot;&gt;rethinkdbdash&lt;/a&gt;.</source>
          <target state="translated">파일의 JavaScript 버전의 경우 &lt;code&gt;rethinkdb&lt;/code&gt; 저장소 에서 &lt;code&gt;make js-driver&lt;/code&gt; 를 실행 하고 &lt;code&gt;build/packages/js/proto-def.js&lt;/code&gt; 에서 파일의 JSON 버전을 검색하십시오 . 또는 &lt;a href=&quot;https://github.com/neumino/rethinkdbdash/blob/master/lib/protodef.js&quot;&gt;rethinkdbdash&lt;/a&gt; 에서 동등한 파일을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e74a820722b2e12680e4c0867b16e2efc6451ca1" translate="yes" xml:space="preserve">
          <source>For a complete list of options that can be passed to RethinkDB on the command line, read &lt;a href=&quot;../cli-options/index&quot;&gt;RethinkDB command line options&lt;/a&gt; or type &lt;code&gt;rethinkdb --help&lt;/code&gt; at the terminal prompt.</source>
          <target state="translated">명령 행에서 RethinkDB에 전달할 수있는 전체 옵션 목록을 보려면 &lt;a href=&quot;../cli-options/index&quot;&gt;RethinkDB 명령 행 옵션을&lt;/a&gt; 읽 거나 터미널 프롬프트에서 &lt;code&gt;rethinkdb --help&lt;/code&gt; 를 입력 하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb003cc59a68ab738ca5cfafe87aa97c3e5f97de" translate="yes" xml:space="preserve">
          <source>For a complete list of options that can be passed to RethinkDB on the command line, read &lt;a href=&quot;../cli-options/index&quot;&gt;RethinkDB command line options&lt;/a&gt;, or type &lt;code&gt;rethinkdb --help&lt;/code&gt; at the terminal prompt.</source>
          <target state="translated">명령 행에서 RethinkDB에 전달할 수있는 전체 옵션 목록을 보려면 &lt;a href=&quot;../cli-options/index&quot;&gt;RethinkDB 명령 행 옵션을&lt;/a&gt; 읽 거나 터미널 프롬프트에서 &lt;code&gt;rethinkdb --help&lt;/code&gt; 를 입력 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c895ece154822393de182e84f5f3e401d9dcc9aa" translate="yes" xml:space="preserve">
          <source>For a full description of permissions, read &lt;a href=&quot;../../../docs/permissions-and-accounts/index&quot;&gt;Permissions and user accounts&lt;/a&gt;.</source>
          <target state="translated">권한에 대한 자세한 설명은 &lt;a href=&quot;../../../docs/permissions-and-accounts/index&quot;&gt;권한 및 사용자 계정을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f41fd0af4d69c01a0aa33730cdd58d9234eb2c04" translate="yes" xml:space="preserve">
          <source>For a more detailed explanation of this, consult the Wikipedia article on the &lt;a href=&quot;http://en.wikipedia.org/wiki/Geographic_coordinate_system&quot;&gt;geographic coordinate system&lt;/a&gt;.</source>
          <target state="translated">이에 대한 자세한 설명은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Geographic_coordinate_system&quot;&gt;지리 좌표계&lt;/a&gt; 에 관한 Wikipedia 기사를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a8292eb683367bd99a42007eb2cba576499d906" translate="yes" xml:space="preserve">
          <source>For a more detailed look, make sure to read the &lt;a href=&quot;../../quickstart/index&quot;&gt;quickstart&lt;/a&gt;.</source>
          <target state="translated">보다 자세한 내용을 보려면 &lt;a href=&quot;../../quickstart/index&quot;&gt;빠른 시작&lt;/a&gt; 을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="145ae9f70b2b61b630eb41c0bfb84657bd6cfbc7" translate="yes" xml:space="preserve">
          <source>For a more fine-grained mechanism, replicas can be associated with servers using &lt;em&gt;server tags.&lt;/em&gt; Every server may be assigned one or more tags, and every table may have a specified number of replicas assigned to a server tag. For instance, if you have six servers, you might assign two the tag &lt;code&gt;us_west&lt;/code&gt;, two the tag &lt;code&gt;us_east&lt;/code&gt;, and two the tag &lt;code&gt;london&lt;/code&gt;, and further assign all four servers in the United States the tag &lt;code&gt;us&lt;/code&gt;. Then tables might have their configuration set with &lt;code&gt;reconfigure&lt;/code&gt; to group replicas in specific ways:</source>
          <target state="translated">보다 세밀한 메커니즘을 위해 &lt;em&gt;서버 태그를&lt;/em&gt; 사용하여 복제본을 서버와 연결할 수 있습니다 &lt;em&gt;. &lt;/em&gt;모든 서버에는 하나 이상의 태그가 할당 될 수 있으며 모든 테이블에는 서버 태그에 지정된 수의 복제본이 할당 될 수 있습니다. 예를 들어, 6 대의 서버가있는 경우 &lt;code&gt;us_west&lt;/code&gt; 태그 2 개, &lt;code&gt;us_east&lt;/code&gt; 태그 2 개, &lt;code&gt;london&lt;/code&gt; 태그 2 개를 지정하고 미국의 4 개 서버 모두 &lt;code&gt;us&lt;/code&gt; 태그를 지정할 수 있습니다. 그런 다음 테이블은 특정 방식으로 복제본을 그룹화하기 위해 &lt;code&gt;reconfigure&lt;/code&gt; 으로 구성된 구성을 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="757efff80df760ee332b0870744cd52386fa33d5" translate="yes" xml:space="preserve">
          <source>For a practical example, imagine a data set like the one from the &lt;a href=&quot;http://www.rethinkdb.com/docs/cookbook/javascript/#performing-a-pivot-operation&quot;&gt;pivot example&lt;/a&gt;, where each document represents a student&amp;rsquo;s course record.</source>
          <target state="translated">실제 예를 들어, 각 문서가 학생의 코스 레코드를 나타내는 &lt;a href=&quot;http://www.rethinkdb.com/docs/cookbook/javascript/#performing-a-pivot-operation&quot;&gt;피벗 예의&lt;/a&gt; 데이터 세트와 같은 데이터 세트를 상상하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a37e16516ded8b1574568dc1bd66f3233a12d6a" translate="yes" xml:space="preserve">
          <source>For added security, you can isolate a multi-node RethinkDB cluster on AWS using a Virtual Private Cloud security group. The default security group settings for RethinkDB allow anyone to connect to the database&amp;rsquo;s driver port, but exclude the intracluster port. Follow the steps below to set up your security groups.</source>
          <target state="translated">보안을 강화하기 위해 Virtual Private Cloud 보안 그룹을 사용하여 AWS에서 다중 노드 RethinkDB 클러스터를 분리 할 수 ​​있습니다. RethinkDB의 기본 보안 그룹 설정은 누구나 데이터베이스의 드라이버 포트에 연결할 수 있지만 클러스터 내 포트는 제외합니다. 아래 단계에 따라 보안 그룹을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="128f9950186e5f44193af03d5eb6402c706c83f3" translate="yes" xml:space="preserve">
          <source>For details about these options, read &lt;a href=&quot;../security/index&quot;&gt;Securing your cluster&lt;/a&gt;.</source>
          <target state="translated">이러한 옵션에 대한 자세한 내용은 &lt;a href=&quot;../security/index&quot;&gt;클러스터 보안을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ae1bd064cc3090066c912dc96eee04a7203c7486" translate="yes" xml:space="preserve">
          <source>For details about this, read &lt;a href=&quot;../permissions-and-accounts/index&quot;&gt;Permissions and user accounts&lt;/a&gt;.</source>
          <target state="translated">이에 대한 자세한 내용은 &lt;a href=&quot;../permissions-and-accounts/index&quot;&gt;권한 및 사용자 계정을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="906aef5ae34b8978ecfda0e18d0dd601f637e54b" translate="yes" xml:space="preserve">
          <source>For details on these two tables, read &lt;a href=&quot;../permissions-and-accounts/index&quot;&gt;Permissions and user accounts&lt;/a&gt;.</source>
          <target state="translated">이 두 테이블에 대한 자세한 내용은 &lt;a href=&quot;../permissions-and-accounts/index&quot;&gt;권한 및 사용자 계정을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b3f05778721c0a64e546685066275b80001f00af" translate="yes" xml:space="preserve">
          <source>For each repairable shard, &lt;code&gt;emergencyRepair&lt;/code&gt; will convert all unavailable voting replicas into non-voting replicas. If all the voting replicas were removed, an arbitrarily-chosen available non-voting replica will be converted into a voting replica. After this operation, all of the shard&amp;rsquo;s available replicas will be voting replicas.</source>
          <target state="translated">수리 가능한 각 샤드에 대해 &lt;code&gt;emergencyRepair&lt;/code&gt; 는 사용할 수없는 모든 투표 복제본을 투표권이없는 복제본으로 변환합니다. 모든 투표 복제본이 제거 된 경우 임의로 선택 가능한 비 투표 복제본이 투표 복제본으로 변환됩니다. 이 작업 후에는 사용 가능한 모든 샤드 복제본이 투표 복제본이됩니다.</target>
        </trans-unit>
        <trans-unit id="636abf48decb6d1ef8774dd055cb231e4a760dff" translate="yes" xml:space="preserve">
          <source>For each successive page, start with the last name in the previous page.</source>
          <target state="translated">연속되는 각 페이지에 대해 이전 페이지의 성으로 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="111db113ae6102f4071b40d3343eaffef0fdd713" translate="yes" xml:space="preserve">
          <source>For every message sent, repubsub sets the &lt;code&gt;updated_on&lt;/code&gt; key with &lt;code&gt;r.now&lt;/code&gt; to get the current time</source>
          <target state="translated">모든 메시지하여 전송의 경우, repubsub는 설정 &lt;code&gt;updated_on&lt;/code&gt; 의 와 키 &lt;code&gt;r.now&lt;/code&gt; 현재 시간을 얻을 수를</target>
        </trans-unit>
        <trans-unit id="72bcc28374128d88583c30eb27fc0c731563706d" translate="yes" xml:space="preserve">
          <source>For example you can retrieve all the results and put them in an array with &lt;code&gt;toArray&lt;/code&gt;:</source>
          <target state="translated">예를 들어 모든 결과를 검색하고 &lt;code&gt;toArray&lt;/code&gt; 를 사용하여 배열에 넣을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db9a51c2075a6ee318c4bf1fb37b1f85ae712139" translate="yes" xml:space="preserve">
          <source>For example, if a given table contains a thousand JSON documents whose primary keys are uniformly distributed, alphabetical, upper-case strings and the user states they want two shards, RethinkDB will likely pick split point &amp;lsquo;M&amp;rsquo; to partition the table. Every document with a primary key less than or equal to &amp;lsquo;M&amp;rsquo; will go into the first shard, and every document with a primary key greater than &amp;lsquo;M&amp;rsquo; will go into the second shard. The split point will be picked such that each shard contains close to five hundred keys, and the shards will automatically be distributed across the cluster.</source>
          <target state="translated">예를 들어, 주어진 테이블에 기본 키가 균등하게 분포 된 알파벳 대문자의 문자열 인 수천 개의 JSON 문서가 있고 사용자가 두 개의 샤드를 원한다고하면 RethinkDB는 분할 지점 'M'을 선택하여 테이블을 분할 할 가능성이 높습니다. 기본 키가 'M'이하인 모든 문서는 첫 번째 샤드에 들어가고 기본 키가 'M'보다 큰 모든 문서는 두 번째 샤드에 들어갑니다. 분할 지점은 각 샤드에 약 500 개의 키가 포함되도록 선택되며 샤드는 자동으로 클러스터에 분산됩니다.</target>
        </trans-unit>
        <trans-unit id="4a923e642f82305f7adc526fde23641ea1a171df" translate="yes" xml:space="preserve">
          <source>For example, if you attempt to delete a batch of documents, and another concurrent query deletes some of those documents first, they will be counted as skipped.</source>
          <target state="translated">예를 들어, 일괄 문서를 삭제하려고 시도하고 다른 동시 쿼리가 해당 문서 중 일부를 먼저 삭제하면 건너 뛴 것으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="d8491fad66155bf0a709fc2e5190368aa775d482" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s count the number of results returned by the API:</source>
          <target state="translated">예를 들어 API가 반환 한 결과 수를 계산해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="6c5b8346754e8ebb53d69689f9aa0b3d2497d576" translate="yes" xml:space="preserve">
          <source>For example, values of 1.0 up to but not including 1.5 will return 1.0, similar to &lt;a href=&quot;../floor/index&quot;&gt;floor&lt;/a&gt;; values of 1.5 up to 2.0 will return 2.0, similar to &lt;a href=&quot;../ceil/index&quot;&gt;ceil&lt;/a&gt;.</source>
          <target state="translated">예를 들어, 1.0에서 1.5까지는 포함하지 않는 값은 &lt;a href=&quot;../floor/index&quot;&gt;floor&lt;/a&gt; 와 비슷하게 1.0을 반환합니다 . 1.5에서 2.0까지의 값은 &lt;a href=&quot;../ceil/index&quot;&gt;ceil&lt;/a&gt; 과 비슷한 2.0을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="babbcf567857bd9afd274b0da48a4f64ca1e1bc5" translate="yes" xml:space="preserve">
          <source>For information about running RethinkDB as a proxy server, read &lt;a href=&quot;../sharding-and-replication/index#running-a-proxy-node&quot;&gt;Running a proxy node&lt;/a&gt; in &amp;ldquo;Scaling, sharding and replication.&amp;rdquo;</source>
          <target state="translated">프록시 서버로 RethinkDB를 실행하는 방법에 대한 자세한 내용은 &amp;ldquo;스케일링, 샤딩 및 복제&amp;rdquo;에서 &lt;a href=&quot;../sharding-and-replication/index#running-a-proxy-node&quot;&gt;프록시 노드 실행을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a9df702af4cc4ee70d2e081cf5218fdbf4eccfa" translate="yes" xml:space="preserve">
          <source>For many ReQL commands, you can also use a JSON-style nested syntax that allows considerably more flexibility. Read &amp;ldquo;&lt;a href=&quot;../../nested-fields/index&quot;&gt;Accessing nested fields&lt;/a&gt;&amp;rdquo; for more information.</source>
          <target state="translated">많은 ReQL 명령의 경우 훨씬 더 많은 유연성을 허용하는 JSON 스타일 중첩 구문을 사용할 수도 있습니다. &quot;읽기 &lt;a href=&quot;../../nested-fields/index&quot;&gt;액세스 중첩 된 필드&lt;/a&gt; 자세한 내용을&quot;.</target>
        </trans-unit>
        <trans-unit id="17b2979df453ed333e90d0702dbc0a408986c657" translate="yes" xml:space="preserve">
          <source>For many ReQL commands, you can also use a JSON-style nested syntax that allows considerably more flexibility. Read &amp;ldquo;&lt;a href=&quot;../../nested-fields/javascript/index&quot;&gt;Accessing nested fields&lt;/a&gt;&amp;rdquo; for more information.</source>
          <target state="translated">많은 ReQL 명령의 경우 훨씬 더 융통성이있는 JSON 스타일 중첩 구문을 사용할 수도 있습니다. 자세한 내용은&amp;ldquo; &lt;a href=&quot;../../nested-fields/javascript/index&quot;&gt;중첩 필드 액세스&lt;/a&gt; &amp;rdquo;를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="5a6095ad6762a5a53adfced30859b3cba54d15f5" translate="yes" xml:space="preserve">
          <source>For many cases where a GMR query might be used, ReQL provides even simpler aggregation functions. This example is really more easily written using &lt;a href=&quot;https://rethinkdb.com/api/python/count&quot;&gt;count&lt;/a&gt;:</source>
          <target state="translated">GMR 쿼리를 사용할 수있는 많은 경우에 ReQL은 더 간단한 집계 기능을 제공합니다. 이 예제는 &lt;a href=&quot;https://rethinkdb.com/api/python/count&quot;&gt;count를&lt;/a&gt; 사용하여 더 쉽게 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="67ffe58b1137fa1176b805e4f89dac57006679f3" translate="yes" xml:space="preserve">
          <source>For more details, read about &lt;a href=&quot;../failover/index&quot;&gt;Failover&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../failover/index&quot;&gt;장애 조치&lt;/a&gt; 에 대해 읽어보십시오 .</target>
        </trans-unit>
        <trans-unit id="82e0be443f5b0509dea3fc312466c2ca45414cc1" translate="yes" xml:space="preserve">
          <source>For more information</source>
          <target state="translated">자세한 내용은</target>
        </trans-unit>
        <trans-unit id="1ab2fc0444947da4e0cf046b9f13d639f4e34e9c" translate="yes" xml:space="preserve">
          <source>For more information about administration via ReQL, consult the API documentation for the individual commands as well as the &lt;a href=&quot;../administration-tools/index&quot;&gt;Administration tools&lt;/a&gt; documentation.</source>
          <target state="translated">ReQL을 통한 관리에 대한 자세한 정보는 개별 명령 및 &lt;a href=&quot;../administration-tools/index&quot;&gt;관리 도구&lt;/a&gt; 문서에 대한 API 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3363b65c290578fe0e7fbc6c255fdb15b651d44f" translate="yes" xml:space="preserve">
          <source>For more information about map-reduce in general, read the &lt;a href=&quot;http://en.wikipedia.org/wiki/MapReduce&quot;&gt;Wikipedia article&lt;/a&gt;. For more information about RethinkDB&amp;rsquo;s implementation, browse our API documentation.</source>
          <target state="translated">일반적인 맵 축소에 대한 자세한 내용은 &lt;a href=&quot;http://en.wikipedia.org/wiki/MapReduce&quot;&gt;Wikipedia article을 참조하십시오&lt;/a&gt; . RethinkDB의 구현에 대한 자세한 내용은 API 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="913d7090273fa6a7e3ca2c42e186d05752295e1d" translate="yes" xml:space="preserve">
          <source>For more information about proxy nodes, read &amp;ldquo;Running a proxy node&amp;rdquo; under &lt;a href=&quot;../sharding-and-replication/index#running-a-proxy-node&quot;&gt;Scaling, sharding and replication&lt;/a&gt;.</source>
          <target state="translated">프록시 노드에 대한 자세한 내용은 &lt;a href=&quot;../sharding-and-replication/index#running-a-proxy-node&quot;&gt;스케일링, 샤딩 및 복제&lt;/a&gt; 에서&amp;ldquo;프록시 노드 실행&amp;rdquo;을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e81d59b0196632caf451c3fe56968f18cc7bf03c" translate="yes" xml:space="preserve">
          <source>For more information about subcommands, type &lt;code&gt;rethinkdb help [subcommand]&lt;/code&gt; at the command line.</source>
          <target state="translated">부속 명령에 대한 자세한 정보를 보려면 명령 행에 &lt;code&gt;rethinkdb help [subcommand]&lt;/code&gt; 를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="3e61b79923defbe5d9aa5576d4fda8cd1497a169" translate="yes" xml:space="preserve">
          <source>For more information on RethinkDB&amp;rsquo;s sorting order, read the section in &lt;a href=&quot;../../../docs/data-types/index#sorting-order&quot;&gt;ReQL data types&lt;/a&gt;.</source>
          <target state="translated">RethinkDB의 정렬 순서에 대한 자세한 정보는 &lt;a href=&quot;../../../docs/data-types/index#sorting-order&quot;&gt;ReQL 데이터 유형&lt;/a&gt; 섹션을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="95fb36df58d9bf04bd49dcfc5f46353bfe68d941" translate="yes" xml:space="preserve">
          <source>For more information on these data types, read about RethinkDB&amp;rsquo;s &lt;a href=&quot;../geo-support/javascript/index&quot;&gt;geospatial support&lt;/a&gt;.</source>
          <target state="translated">이러한 데이터 유형에 대한 자세한 정보는 RethinkDB의 &lt;a href=&quot;../geo-support/javascript/index&quot;&gt;지리 공간 지원&lt;/a&gt; 에 대해 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="5c630ec0a8718355b7e66ad48ab229b7eb835658" translate="yes" xml:space="preserve">
          <source>For more information read the &lt;a href=&quot;../../../docs/nested-fields/javascript/index&quot;&gt;nested field documentation&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../../../docs/nested-fields/javascript/index&quot;&gt;중첩 된 필드 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4825a63757592afbe14794197cb9e895429042af" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;../../../docs/table-joins/index&quot;&gt;Table joins in RethinkDB&lt;/a&gt;.</source>
          <target state="translated">자세한 정보 &lt;a href=&quot;../../../docs/table-joins/index&quot;&gt;는 RethinkDB의 테이블 조인을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d6d1c976feeab37307a38791a3d6672c1144d68" translate="yes" xml:space="preserve">
          <source>For most queries, you can write familiar, easy to learn code without learning special commands.</source>
          <target state="translated">대부분의 쿼리에서 특수 명령을 배우지 않고도 친숙하고 배우기 쉬운 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d81b71396183b0b5ebe1e6c9ea87ab607958b55b" translate="yes" xml:space="preserve">
          <source>For now, the plugin works best when backfilling or replicating into Elasticsearch is an option, and when it&amp;rsquo;s all right to risk having some outdated data in the index.</source>
          <target state="translated">현재 플러그인은 백업 광고를 백업하거나 Elasticsearch로 복제하는 것이 옵션 일 때와 인덱스에 오래된 데이터가있을 위험이있는 경우 가장 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ff724558c1ec1d60fe1ba600d7c0dc76ee9653d5" translate="yes" xml:space="preserve">
          <source>For our blog, we have a table &lt;code&gt;posts&lt;/code&gt; that contains blog posts. Here&amp;rsquo;s an example document from the table. (We&amp;rsquo;ll use Python for this example, but other ReQL drivers are very similar.)</source>
          <target state="translated">블로그 에는 블로그 게시물이 포함 된 테이블 &lt;code&gt;posts&lt;/code&gt; 이 있습니다. 다음은 테이블의 예제 문서입니다. (이 예제에서는 Python을 사용하지만 다른 ReQL 드라이버는 매우 유사합니다.)</target>
        </trans-unit>
        <trans-unit id="6dbc69921f0743552d9bbfda11532388684d5a72" translate="yes" xml:space="preserve">
          <source>For simplicity, the write hook function is allowed to return &lt;code&gt;null&lt;/code&gt; exactly if and only if &lt;code&gt;newVal&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;. This is just a safeguard to ensure you don&amp;rsquo;t accidentally turn an insert/update into a deletion, or a deletion into an update.</source>
          <target state="translated">간단하게 쓰기 후크 함수는 &lt;code&gt;newVal&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 인 경우에만 정확하게 &lt;code&gt;null&lt;/code&gt; 을 반환 할 수 있습니다. 이는 실수로 삽입 / 업데이트를 삭제로 바꾸거나 삭제를 업데이트로 바꾸지 않도록하기위한 보호 수단 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="7f356686484e654b0caaf0f62dfeec910f189b3a" translate="yes" xml:space="preserve">
          <source>For some options below, the default value depends on &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;, the name of the config file without the &lt;code&gt;.conf&lt;/code&gt; extension.</source>
          <target state="translated">아래의 일부 옵션의 경우 기본값 은 &lt;code&gt;.conf&lt;/code&gt; 확장자가 없는 구성 파일 이름 인 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="f7a5e49b95cccfe244020720ab25136a8d80ee0c" translate="yes" xml:space="preserve">
          <source>For testing or logging purposes, you might want to capture a created ReQL query as a string. (You can see an example of this in ReQL error messages.) While there is no ReQL command to do this, you can simply use the &lt;code&gt;toString()&lt;/code&gt; method at the end of a query chain, rather than &lt;code&gt;run()&lt;/code&gt;:</source>
          <target state="translated">테스트 또는 로깅 목적으로 작성된 ReQL 조회를 문자열로 캡처 할 수 있습니다. (ReQL 오류 메시지에서 이에 대한 예를 볼 수 있습니다.)이를 수행하기위한 ReQL 명령이 없지만 &lt;code&gt;run()&lt;/code&gt; 대신 쿼리 체인 끝에 &lt;code&gt;toString()&lt;/code&gt; 메소드를 사용하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="3fbc1e78f3a7953ea2885ea05b23ea063ea8ce85" translate="yes" xml:space="preserve">
          <source>For the full details on querying, you&amp;rsquo;ll want to read up on &lt;a href=&quot;http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-search.html&quot;&gt;how to query Elasticsearch&lt;/a&gt;.</source>
          <target state="translated">쿼리에 대한 자세한 내용은 &lt;a href=&quot;http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-search.html&quot;&gt;Elasticsearch 쿼리 방법을&lt;/a&gt; 읽어보십시오 .</target>
        </trans-unit>
        <trans-unit id="c215605ef59c73436d943d43e83dc0b1398c2edc" translate="yes" xml:space="preserve">
          <source>For the same reason, using this index to look for posts by &lt;code&gt;&quot;John&quot;&lt;/code&gt; with any tag would not be possible.</source>
          <target state="translated">같은 이유로이 색인을 사용하여 태그가있는 &lt;code&gt;&quot;John&quot;&lt;/code&gt; 의 게시물을 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ca94911f14ae2b2a0b0c562af4e9f93c2fbe8db3" translate="yes" xml:space="preserve">
          <source>For these examples, we&amp;rsquo;ll assume that the RethinkDB connection is available as &lt;code&gt;conn&lt;/code&gt;.</source>
          <target state="translated">이 예제에서는 RethinkDB 연결을 &lt;code&gt;conn&lt;/code&gt; 으로 사용할 수 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="6c29bb8b0b0e89fcfad83c842d5274ea07663f3a" translate="yes" xml:space="preserve">
          <source>For this query RethinkDB will perform enough work to get the five documents, and stop when the query is satisfied. Even if you don&amp;rsquo;t have a limit on the number of queries but use a cursor, RethinkDB will do just enough work to allow you to read the data you request. This allows queries to execute quickly without wasting CPU cycles, network bandwidth, and disk IO.</source>
          <target state="translated">이 쿼리의 경우 RethinkDB는 5 개의 문서를 가져 오기 위해 충분한 작업을 수행하고 쿼리가 충족되면 중지합니다. 쿼리 수에 제한이 없지만 커서를 사용하더라도 RethinkDB는 요청한 데이터를 읽을 수 있도록 충분한 작업을 수행합니다. 따라서 CPU주기, 네트워크 대역폭 및 디스크 IO를 낭비하지 않고 쿼리를 빠르게 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce94201a1a822d650ca6441f4fe424f778b40373" translate="yes" xml:space="preserve">
          <source>For this tutorial, we&amp;rsquo;ll assume the RethinkDB server has a database named &amp;ldquo;change_example&amp;rdquo; and a table named &amp;ldquo;mytable.&amp;rdquo; Here&amp;rsquo;s the query that watches for changes:</source>
          <target state="translated">이 자습서에서는 RethinkDB 서버에 &quot;change_example&quot;이라는 데이터베이스와 &quot;mytable&quot;이라는 테이블이 있다고 가정합니다. 변경 사항을 확인하는 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b92785b441a8f092a8ab315821f69be49499f0f5" translate="yes" xml:space="preserve">
          <source>For those applications that need full-text search, we&amp;rsquo;ve written a &lt;a href=&quot;https://github.com/rethinkdb/elasticsearch-river-rethinkdb&quot;&gt;plugin for Elasticsearch&lt;/a&gt; (called a river) that keeps RethinkDB synced up with Elasticsearch&amp;rsquo;s indexes. It uses &lt;a href=&quot;../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt; to push new, updated and deleted documents to Elasticsearch in real-time. In addition, it loads existing documents from your RethinkDB tables, so you can get going right away.</source>
          <target state="translated">전체 텍스트 검색이 필요한 애플리케이션을 &lt;a href=&quot;https://github.com/rethinkdb/elasticsearch-river-rethinkdb&quot;&gt;위해&lt;/a&gt; RethinkDB를 Elasticsearch의 인덱스와 동기화하는 Elasticsearch 용 플러그인 (강이라고 함)을 작성했습니다. 변경 &lt;a href=&quot;../changefeeds/javascript/index&quot;&gt;피드&lt;/a&gt; 를 사용 하여 새로운 업데이트 및 삭제 된 문서를 Elasticsearch에 실시간으로 푸시합니다. 또한 RethinkDB 테이블에서 기존 문서를로드하므로 즉시 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="daf28cf370e2bb3e4f6540fd76c8980d9e982b51" translate="yes" xml:space="preserve">
          <source>For updates on protocol and behavior changes in new versions of RethinkDB and general assistance with writing drivers, join the &lt;a href=&quot;https://groups.google.com/forum/?fromgroups#!forum/rethinkdb-dev&quot;&gt;RethinkDB-Dev Google Group&lt;/a&gt;.</source>
          <target state="translated">새 버전의 RethinkDB에서 프로토콜 및 동작 변경에 대한 업데이트와 드라이버 작성에 대한 일반적인 지원을 받으려면 &lt;a href=&quot;https://groups.google.com/forum/?fromgroups#!forum/rethinkdb-dev&quot;&gt;RethinkDB-Dev Google 그룹에&lt;/a&gt; 가입하십시오 .</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="4a50006894600468131ccf67060b9390acf52e6d" translate="yes" xml:space="preserve">
          <source>Four events are emitted: &lt;code&gt;connect&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt;, &lt;code&gt;timeout&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; , &lt;code&gt;close&lt;/code&gt; , &lt;code&gt;timeout&lt;/code&gt; 및 &lt;code&gt;error&lt;/code&gt; 의 네 가지 이벤트가 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="cf18287b27acdbd9228dccf840743c611fd61dcb" translate="yes" xml:space="preserve">
          <source>From Windows, do this from a command prompt window. Use the &lt;code&gt;cd&lt;/code&gt; command to go to the directory that you unpacked &lt;code&gt;rethinkdb.exe&lt;/code&gt; in.</source>
          <target state="translated">Windows의 경우 명령 프롬프트 창에서이를 수행하십시오. &lt;code&gt;cd&lt;/code&gt; 명령을 사용하여 &lt;code&gt;rethinkdb.exe&lt;/code&gt; 의 압축을 푼 디렉토리로 이동 하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd9b4901b4a339413df04141599df4f30cc3d1db" translate="yes" xml:space="preserve">
          <source>Full source code for this tutorial</source>
          <target state="translated">이 튜토리얼의 전체 소스 코드</target>
        </trans-unit>
        <trans-unit id="ac47c41031ca6ea538a6bad07d585b26e5c04d09" translate="yes" xml:space="preserve">
          <source>Full support for systemd is planned&amp;mdash;you can track progress on &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/2014&quot;&gt;issue 2014&lt;/a&gt;. For now, you&amp;rsquo;ll have to create a couple configuration files manually.</source>
          <target state="translated">systemd에 대한 완벽한 지원이 계획되어 있습니다 . &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/2014&quot;&gt;2014 년 문제&lt;/a&gt; 진행 상황을 추적 할 수 있습니다 . 지금은 몇 개의 구성 파일을 수동으로 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="56610704a5d0885138ce85548873319247c751f1" translate="yes" xml:space="preserve">
          <source>Full-text search with Elasticsearch</source>
          <target state="translated">Elasticsearch를 사용한 전체 텍스트 검색</target>
        </trans-unit>
        <trans-unit id="0e44c8b638baa470dbb5f127964c092cc77ea465" translate="yes" xml:space="preserve">
          <source>Further reading</source>
          <target state="translated">추가 자료</target>
        </trans-unit>
        <trans-unit id="1a03d4d661b1bb1e757eb01e8f1ba0020af72411" translate="yes" xml:space="preserve">
          <source>Further, because it&amp;rsquo;s ReQL, the query&amp;rsquo;s individual pieces are easily composable. If you decide you want those numbers on a per-month basis, you can just throw a &lt;code&gt;group&lt;/code&gt; in there:</source>
          <target state="translated">또한 ReQL이기 때문에 쿼리의 개별 조각을 쉽게 구성 할 수 있습니다. 매월 그 숫자를 원한다면 거기에 &lt;code&gt;group&lt;/code&gt; 을 던질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba5b2231ebb51b96ad83f42c8232a3a30504b098" translate="yes" xml:space="preserve">
          <source>General Options</source>
          <target state="translated">일반 옵션</target>
        </trans-unit>
        <trans-unit id="11e83edf877cd5f0fdc4c3ee3bab8b9824de2894" translate="yes" xml:space="preserve">
          <source>Generate a key and matching certificate</source>
          <target state="translated">키와 일치하는 인증서 생성</target>
        </trans-unit>
        <trans-unit id="2febf04cd0c394cf310d6a665094d1c56bf9ec9c" translate="yes" xml:space="preserve">
          <source>Generate a random number between given (or implied) bounds. &lt;code&gt;random&lt;/code&gt; takes zero, one or two arguments.</source>
          <target state="translated">주어진 (또는 묵시적인) 범위 사이의 난수를 생성합니다. &lt;code&gt;random&lt;/code&gt; 은 0, 1 또는 2 개의 인수를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="13dce5180e446b48b05830d6be0f1b3a23a98354" translate="yes" xml:space="preserve">
          <source>Generate a stream of sequential integers in a specified range.</source>
          <target state="translated">지정된 범위에서 순차 정수 스트림을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="9617b6a68f7766e69c8838059f52cb1c0c1c2149" translate="yes" xml:space="preserve">
          <source>Generating monotonically increasing primary key values</source>
          <target state="translated">단조 증가 기본 키 값 생성</target>
        </trans-unit>
        <trans-unit id="3a124f292c1ce8300aafc72cc3dfa4e1a24be018" translate="yes" xml:space="preserve">
          <source>Geometry data types</source>
          <target state="translated">형상 데이터 유형</target>
        </trans-unit>
        <trans-unit id="2ca60ffc89b1e3c2df47848341e9eb9a70e247b5" translate="yes" xml:space="preserve">
          <source>Geometry objects are implemented through a geographic coordinate system, with points and shapes plotted on the surface of a sphere in three-dimensional space. In addition, ReQL geometry objects can be converted to and from GeoJSON, with some limitations.</source>
          <target state="translated">지오메트리 객체는 지리 좌표계를 통해 구현되며, 3 차원 공간에서 구의 표면에 점과 모양이 그려져 있습니다. 또한 ReQL 지오메트리 객체는 몇 가지 제한 사항이 있지만 GeoJSON으로 또는 GeoJSON에서 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c93777485a28faf469750ff3c5485cc5f3da24a6" translate="yes" xml:space="preserve">
          <source>Geospatial</source>
          <target state="translated">Geospatial</target>
        </trans-unit>
        <trans-unit id="af69676aa273c682cc3abbe0810a037decd6a660" translate="yes" xml:space="preserve">
          <source>Geospatial commands</source>
          <target state="translated">지리 공간 명령</target>
        </trans-unit>
        <trans-unit id="777f8dbeaeb6679675f275bda3359539ce574d27" translate="yes" xml:space="preserve">
          <source>Geospatial indexes</source>
          <target state="translated">지리 공간 인덱스</target>
        </trans-unit>
        <trans-unit id="b8bc53cea5284d3e82018ae67ef678eefbb2d3ea" translate="yes" xml:space="preserve">
          <source>Geospatial queries</source>
          <target state="translated">지리 공간 쿼리</target>
        </trans-unit>
        <trans-unit id="a469d1dc3817e092e0628853d5fbb08d1088a44b" translate="yes" xml:space="preserve">
          <source>Get a document by primary key.</source>
          <target state="translated">기본 키로 문서를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8046295e3a41b0b62c302c6f12580dabc88b588c" translate="yes" xml:space="preserve">
          <source>Get a single field from an object. If called on a sequence, gets that field from every object in the sequence, skipping objects that lack it.</source>
          <target state="translated">객체에서 단일 필드를 가져옵니다. 시퀀스에서 호출되면 시퀀스의 모든 개체에서 해당 필드를 가져 와서 해당 필드가없는 개체는 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="1b8b0a98b85373c4a40b7d034bdb73d026ebba2b" translate="yes" xml:space="preserve">
          <source>Get all documents between two keys. Accepts three optional arguments: &lt;code&gt;index&lt;/code&gt;, &lt;code&gt;leftBound&lt;/code&gt;, and &lt;code&gt;rightBound&lt;/code&gt;. If &lt;code&gt;index&lt;/code&gt; is set to the name of a secondary index, &lt;code&gt;between&lt;/code&gt; will return all documents where that index&amp;rsquo;s value is in the specified range (it uses the primary key by default). &lt;code&gt;leftBound&lt;/code&gt; or &lt;code&gt;rightBound&lt;/code&gt; may be set to &lt;code&gt;open&lt;/code&gt; or &lt;code&gt;closed&lt;/code&gt; to indicate whether or not to include that endpoint of the range (by default, &lt;code&gt;leftBound&lt;/code&gt; is closed and &lt;code&gt;rightBound&lt;/code&gt; is open).</source>
          <target state="translated">두 키 사이의 모든 문서를 가져옵니다. &lt;code&gt;index&lt;/code&gt; , &lt;code&gt;leftBound&lt;/code&gt; 및 &lt;code&gt;rightBound&lt;/code&gt; 의 세 가지 선택적 인수를 허용 합니다. &lt;code&gt;index&lt;/code&gt; 가 secondary index의 이름으로 설정된 경우 &lt;code&gt;between&lt;/code&gt; 는 해당 인덱스 값이 지정된 범위에있는 모든 문서를 반환합니다 (기본적으로 기본 키를 사용함). &lt;code&gt;leftBound&lt;/code&gt; 또는 &lt;code&gt;rightBound&lt;/code&gt; 는 범위의 해당 끝점을 포함할지 여부를 나타 내기 위해 &lt;code&gt;open&lt;/code&gt; 또는 &lt;code&gt;closed&lt;/code&gt; 로 설정할 수 있습니다 (기본적으로 &lt;code&gt;leftBound&lt;/code&gt; 는 닫히고 &lt;code&gt;rightBound&lt;/code&gt; 는 열려 있습니다).</target>
        </trans-unit>
        <trans-unit id="a0bf967877c232647d6db850640a15fca5c24218" translate="yes" xml:space="preserve">
          <source>Get all documents where the given geometry object intersects the geometry object of the requested geospatial index.</source>
          <target state="translated">주어진 지오메트리 객체가 요청 된 지리 공간 인덱스의 지오메트리 객체와 교차하는 모든 문서를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7479d6cc186a49ad4ce6e91495a9e6970136d844" translate="yes" xml:space="preserve">
          <source>Get all documents where the given value matches the value of the requested index.</source>
          <target state="translated">주어진 값이 요청 된 인덱스의 값과 일치하는 모든 문서를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d7b6631e788bca1e1744de121e75e5cf1fcd38d7" translate="yes" xml:space="preserve">
          <source>Get help</source>
          <target state="translated">도움 받기</target>
        </trans-unit>
        <trans-unit id="a7cc83cb9af9883ac7521e7a66e2705b5cca0c4b" translate="yes" xml:space="preserve">
          <source>Get information about a ReQL value.</source>
          <target state="translated">ReQL 값에 대한 정보를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="26fe09a893cba6ed06a35a42c25f4995d402196d" translate="yes" xml:space="preserve">
          <source>Get more help</source>
          <target state="translated">더 많은 도움 받기</target>
        </trans-unit>
        <trans-unit id="0ce4a4bb65ba8d454be8ba1ee6c95caa54691501" translate="yes" xml:space="preserve">
          <source>Get the 1st, 2nd ,6th and last records</source>
          <target state="translated">첫 번째, 두 번째, 여섯 번째 및 마지막 레코드 가져 오기</target>
        </trans-unit>
        <trans-unit id="6c457d7d73b4b36ce06dbc6742031fc0bddfad8d" translate="yes" xml:space="preserve">
          <source>Get the &lt;em&gt;nth&lt;/em&gt; element of a sequence, counting from zero. If the argument is negative, count from the last element.</source>
          <target state="translated">0부터 세어 시퀀스 의 &lt;em&gt;n 번째&lt;/em&gt; 요소를 가져옵니다. 인수가 음수이면 마지막 요소부터 계산합니다.</target>
        </trans-unit>
        <trans-unit id="6d1b2fe3d2f939a4e9b1e0a146aeb731afdfc60b" translate="yes" xml:space="preserve">
          <source>Get the distance between the two points in San Francisco and San Diego:</source>
          <target state="translated">샌프란시스코와 샌디에고의 두 지점 사이의 거리를 확보하십시오.</target>
        </trans-unit>
        <trans-unit id="cf99e82596f190363cb420cdc30c2eb71f623838" translate="yes" xml:space="preserve">
          <source>Get the indexes of an element in a sequence. If the argument is a predicate, get the indexes of all elements matching it.</source>
          <target state="translated">시퀀스에서 요소의 인덱스를 가져옵니다. 인수가 술어이면, 일치하는 모든 요소의 색인을 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="8afbe85bd6c7d5a794b6657818c034464828eef1" translate="yes" xml:space="preserve">
          <source>Get the nearest point in the table to a specified one based on the index:</source>
          <target state="translated">인덱스를 기반으로 테이블에서 가장 가까운 점을 지정된 점으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="71000a23c5dc68e4588731c2c666c0f68b89288b" translate="yes" xml:space="preserve">
          <source>Get the next element in the cursor.</source>
          <target state="translated">커서에서 다음 요소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c3ad9978650d4d0d5d8aba0901c0c824ccf5841d" translate="yes" xml:space="preserve">
          <source>Get the status of the specified indexes on this table, or the status of all indexes on this table if no indexes are specified.</source>
          <target state="translated">이 테이블에서 지정된 인덱스의 상태 또는 인덱스가 지정되지 않은 경우이 테이블의 모든 인덱스의 상태를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0a83966d5ecabf6055969063a2777e7f5e6da246" translate="yes" xml:space="preserve">
          <source>Get the top movie</source>
          <target state="translated">최고의 영화를 얻으십시오</target>
        </trans-unit>
        <trans-unit id="f285429d75df0c2fa84c179119a7d61724ccc3ec" translate="yes" xml:space="preserve">
          <source>Gets the type of a ReQL query&amp;rsquo;s return value.</source>
          <target state="translated">ReQL 쿼리의 반환 값 유형을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c688cf8dd55524c0ad59ec47557ca5cfa1ff798c" translate="yes" xml:space="preserve">
          <source>Gets the write hook of this table. If a write hook exists, the result is an object of the following form:</source>
          <target state="translated">이 테이블의 쓰기 후크를 가져옵니다. 쓰기 후크가있는 경우 결과는 다음 형식의 객체입니다.</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="b9f7773042bd33f28708a372b51f0c3eef5689e6" translate="yes" xml:space="preserve">
          <source>Given a post document such as:</source>
          <target state="translated">다음과 같은 게시물 문서가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="fdb3b8fb4e7a4390243f5048c5a48c64b714762c" translate="yes" xml:space="preserve">
          <source>Given the ease of scaling RethinkDB clusters across multiple instances, we deemed it necessary to observe performance when moving from a single RethinkDB instance to a larger cluster. We tested all of our workloads on a single instance of RethinkDB up to a 16-node cluster in varying increments of cluster size.</source>
          <target state="translated">여러 인스턴스에서 RethinkDB 클러스터를 쉽게 확장 할 수 있으므로 단일 RethinkDB 인스턴스에서 더 큰 클러스터로 이동할 때 성능을 관찰해야한다고 생각했습니다. RethinkDB의 단일 인스턴스에서 최대 16 노드 클러스터까지 모든 클러스터 작업량을 다양한 클러스터 크기로 테스트했습니다.</target>
        </trans-unit>
        <trans-unit id="923ec6a7a758f5bdb1cfd42a0cf8dffd444bd4e3" translate="yes" xml:space="preserve">
          <source>Given this schema for the &lt;code&gt;users&lt;/code&gt; table:</source>
          <target state="translated">&lt;code&gt;users&lt;/code&gt; 테이블 에이 스키마가 주어지면 :</target>
        </trans-unit>
        <trans-unit id="38e7ffe2b1a89d869ba9347bc27c6b83402b3850" translate="yes" xml:space="preserve">
          <source>Given two endpoints, a line in ReQL is the shortest path between those endpoints on the surface of the sphere, known as a &lt;a href=&quot;http://en.wikipedia.org/wiki/Geodesic&quot;&gt;geodesic&lt;/a&gt;. Lines can be defined with multiple points, in which case each segment of the line will be a geodesic; likewise, sides of a polygon will be geodesics. Geodesics are calculated assuming a perfect sphere.</source>
          <target state="translated">두 끝점 주어 ReQL의 라인은 알려진 구체의 표면에 이러한 엔드 포인트 사이의 최단 경로 &lt;a href=&quot;http://en.wikipedia.org/wiki/Geodesic&quot;&gt;측지선&lt;/a&gt; . 선은 여러 점으로 정의 할 수 있으며,이 경우 선의 각 세그먼트는 측지선이됩니다. 마찬가지로 다각형의 측면은 측지선이됩니다. 측지학은 완벽한 구를 가정하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="2e0b45f2a456e8db55f08d7b65e87593a3e9a140" translate="yes" xml:space="preserve">
          <source>Go</source>
          <target state="translated">Go</target>
        </trans-unit>
        <trans-unit id="a4bc6c235b7290404c9d456b31835ca9b361707b" translate="yes" xml:space="preserve">
          <source>Go to the &lt;a href=&quot;https://github.com/ddaaggeett/webstarter-with-database&quot;&gt;github repository&lt;/a&gt; &amp;raquo;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/ddaaggeett/webstarter-with-database&quot;&gt;github 저장소로&lt;/a&gt; 이동 &amp;raquo;</target>
        </trans-unit>
        <trans-unit id="4366de1d1c5ac1a5c18d332152d25ab659a085b9" translate="yes" xml:space="preserve">
          <source>Go to the &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb-example-nodejs/tree/master/todo-angular-express&quot;&gt;callbacks&lt;/a&gt; or &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb-example-nodejs/tree/master/todo-angular-express-promise&quot;&gt;promises&lt;/a&gt; tutorial &amp;raquo;</source>
          <target state="translated">받는 이동 &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb-example-nodejs/tree/master/todo-angular-express&quot;&gt;콜백&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb-example-nodejs/tree/master/todo-angular-express-promise&quot;&gt;약속&lt;/a&gt; 자습서&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="cc81cc29963c98e940770d7d42882b9c1189f39b" translate="yes" xml:space="preserve">
          <source>Go to the table view (&lt;em&gt;Tables&lt;/em&gt; &amp;rarr; &lt;em&gt;table name&lt;/em&gt;).</source>
          <target state="translated">테이블보기로 이동하십시오 ( &lt;em&gt;테이블&lt;/em&gt; &amp;rarr; &lt;em&gt;테이블 이름&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="dfe7d6ef881045fd7fcd737ef34355f66829510a" translate="yes" xml:space="preserve">
          <source>Go to the tutorial &amp;raquo;</source>
          <target state="translated">튜토리얼로 이동&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="97108d7575a01e5fd3b1ded981344199e9dd1c7f" translate="yes" xml:space="preserve">
          <source>Grant or deny access permissions for a user account, globally or on a per-database or per-table basis.</source>
          <target state="translated">전 세계 또는 데이터베이스 또는 테이블별로 사용자 계정에 대한 액세스 권한을 부여하거나 거부합니다.</target>
        </trans-unit>
        <trans-unit id="b5d7e1824ea0632eeba0efd5c783e7e688f7c9de" translate="yes" xml:space="preserve">
          <source>Grouping query results by date/time periods</source>
          <target state="translated">날짜 / 시간별로 쿼리 결과 그룹화</target>
        </trans-unit>
        <trans-unit id="c13b0b8c060bee8bcc06484d032e252f70bc055d" translate="yes" xml:space="preserve">
          <source>Guides: Administration</source>
          <target state="translated">안내서 : 관리</target>
        </trans-unit>
        <trans-unit id="3109a56edc20f62714d6950a84c358b731d9b634" translate="yes" xml:space="preserve">
          <source>Guides: Deployment</source>
          <target state="translated">가이드 : 배포</target>
        </trans-unit>
        <trans-unit id="2be88847381adaa6133c7e8549630bc7ddd3850e" translate="yes" xml:space="preserve">
          <source>Guides: Getting started</source>
          <target state="translated">안내서 : 시작하기</target>
        </trans-unit>
        <trans-unit id="06c9af880fc09e5fefcf6235ae9c6baddffc3fd0" translate="yes" xml:space="preserve">
          <source>Guides: Integration</source>
          <target state="translated">안내서 : 통합</target>
        </trans-unit>
        <trans-unit id="cf2c448fed2b1a6ff9d934258e3b8a7f9b66839a" translate="yes" xml:space="preserve">
          <source>Guides: ReQL in practice</source>
          <target state="translated">가이드 : 실제로 ReQL</target>
        </trans-unit>
        <trans-unit id="c6214bbbfcc0f794a5f662306a9af18ba5e587bd" translate="yes" xml:space="preserve">
          <source>Guides: RethinkDB architecture</source>
          <target state="translated">안내서 : RethinkDB 아키텍처</target>
        </trans-unit>
        <trans-unit id="81f356ddf8e901e1eb7afd6cd2ee0b5ad2850ab3" translate="yes" xml:space="preserve">
          <source>Guides: The ReQL query language</source>
          <target state="translated">안내서 : ReQL 쿼리 언어</target>
        </trans-unit>
        <trans-unit id="ea1eb6cdfcd7ea55bee473a2fd30c7ba8dc06e16" translate="yes" xml:space="preserve">
          <source>Guides: The RethinkDB data model</source>
          <target state="translated">안내서 : RethinkDB 데이터 모델</target>
        </trans-unit>
        <trans-unit id="080a094530cb8dd7331d2cf5a69b1af948202cd5" translate="yes" xml:space="preserve">
          <source>Guides: Troubleshooting</source>
          <target state="translated">안내서 : 문제 해결</target>
        </trans-unit>
        <trans-unit id="0ff95a68349ac5719cbe822be8e2a9ba9e81d9c0" translate="yes" xml:space="preserve">
          <source>Handling errors</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="337f87637f1b663181af9818a8cb298a4bc97c42" translate="yes" xml:space="preserve">
          <source>Handling latency</source>
          <target state="translated">대기 시간 처리</target>
        </trans-unit>
        <trans-unit id="3b2e40ef007fb3a160eb954bd84907b9489d24b5" translate="yes" xml:space="preserve">
          <source>Handling missing fields</source>
          <target state="translated">누락 된 필드 처리</target>
        </trans-unit>
        <trans-unit id="b76ab65957a69ff57e8c72352794d437fd34c788" translate="yes" xml:space="preserve">
          <source>Hardware</source>
          <target state="translated">Hardware</target>
        </trans-unit>
        <trans-unit id="c0c271c8f62efa33d3ac8edbe0fea6e52fc84150" translate="yes" xml:space="preserve">
          <source>Haskell</source>
          <target state="translated">Haskell</target>
        </trans-unit>
        <trans-unit id="13259b7866e907af9ee5f32cebb48c1da0a4e7be" translate="yes" xml:space="preserve">
          <source>Have &lt;a href=&quot;http://www.elasticsearch.org/overview/elkdownloads/&quot;&gt;Elasticsearch 1.3&lt;/a&gt; installed, running on &lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/index.html&quot;&gt;Java 8&lt;/a&gt;.</source>
          <target state="translated">유무 &lt;a href=&quot;http://www.elasticsearch.org/overview/elkdownloads/&quot;&gt;Elasticsearch 1.3&lt;/a&gt; 에서 실행 설치 &lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/index.html&quot;&gt;자바 8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5893dd74080b5d98bb6f8d0ca5e8ca203a6a826c" translate="yes" xml:space="preserve">
          <source>Have a short, clear, and direct description including the details</source>
          <target state="translated">세부 사항을 포함하여 짧고 명확하며 직접적인 설명이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="374a3bad4e315a2bd8ca794f90a4366ee04ff2c9" translate="yes" xml:space="preserve">
          <source>Help make RethinkDB available on more platforms&amp;mdash;contribute a driver for another language, or join one of the existing projects. To get started with driver development:</source>
          <target state="translated">더 많은 플랫폼에서 RethinkDB를 사용할 수있게하십시오. 다른 언어의 드라이버를 제공하거나 기존 프로젝트 중 하나에 참여하십시오. 드라이버 개발을 시작하려면 :</target>
        </trans-unit>
        <trans-unit id="85b35d8415f09c9b4993d68a5ecf587912bc7e9d" translate="yes" xml:space="preserve">
          <source>Help options</source>
          <target state="translated">도움말 옵션</target>
        </trans-unit>
        <trans-unit id="280a7ae25fe9d1b878397aaa285e6f8fe9cf5eee" translate="yes" xml:space="preserve">
          <source>Help us improve this document.</source>
          <target state="translated">이 문서를 개선하도록 도와주세요.</target>
        </trans-unit>
        <trans-unit id="b11bbfd10920a648679b62cc16974873d3f9f2cf" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;old_val&lt;/code&gt; is the old version of the document, and &lt;code&gt;new_val&lt;/code&gt; is a new version of the document. On an &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;old_val&lt;/code&gt; will be &lt;code&gt;null&lt;/code&gt;; on a &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;new_val&lt;/code&gt; will be &lt;code&gt;null&lt;/code&gt;. On an &lt;code&gt;update&lt;/code&gt;, both &lt;code&gt;old_val&lt;/code&gt; and &lt;code&gt;new_val&lt;/code&gt; are present.</source>
          <target state="translated">여기에서 &lt;code&gt;old_val&lt;/code&gt; 은 이전 버전의 문서이고 &lt;code&gt;new_val&lt;/code&gt; 은 새로운 버전의 문서입니다. 온 &lt;code&gt;insert&lt;/code&gt; , &lt;code&gt;old_val&lt;/code&gt; 이 될 것입니다 &lt;code&gt;null&lt;/code&gt; ; A의 &lt;code&gt;delete&lt;/code&gt; , &lt;code&gt;new_val&lt;/code&gt; 이 될 것 &lt;code&gt;null&lt;/code&gt; . 온 &lt;code&gt;update&lt;/code&gt; , 모두 &lt;code&gt;old_val&lt;/code&gt; 및 &lt;code&gt;new_val&lt;/code&gt; 이 존재한다.</target>
        </trans-unit>
        <trans-unit id="8ecc96119e8edd47805a0e89190189cd02ecf1f1" translate="yes" xml:space="preserve">
          <source>Here is an example of an &lt;strong&gt;incorrect&lt;/strong&gt; way to write the previous grouped map-reduce query, simply incrementing the first value passed to the reduction function:</source>
          <target state="translated">다음은 이전에 그룹화 된 map-reduce 쿼리를 작성 하는 &lt;strong&gt;잘못된&lt;/strong&gt; 방법 의 예입니다. 간단히 축소 함수에 전달 된 첫 번째 값을 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="30cc23fe9eebe4e35d1386f15397f430ca395f5f" translate="yes" xml:space="preserve">
          <source>Here is example data for the &lt;code&gt;posts&lt;/code&gt; table:</source>
          <target state="translated">다음은 &lt;code&gt;posts&lt;/code&gt; 테이블에 대한 예제 데이터입니다 .</target>
        </trans-unit>
        <trans-unit id="0db125f41ac677370c65d1ff336c8967617e8c56" translate="yes" xml:space="preserve">
          <source>Here is how we&amp;rsquo;d delete all documents in a table:</source>
          <target state="translated">다음은 테이블에서 모든 문서를 삭제하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="8c181cff70c9b30163c281e99e0c3fbff9ddc3eb" translate="yes" xml:space="preserve">
          <source>Here we we show how RethinkDB scales up to 16-nodes with these various workloads:</source>
          <target state="translated">다음은 이러한 다양한 워크로드로 RethinkDB가 최대 16 노드까지 어떻게 확장되는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="99390579ff3daa48faeab2ac93996d68119e186c" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;ve told the river to watch two tables in the &lt;code&gt;blog&lt;/code&gt; database: &lt;code&gt;posts&lt;/code&gt; and &lt;code&gt;comments&lt;/code&gt;. The river should also pull in all existing documents from those tables before it starts watching for updates to the tables. By default, the river inserts documents into a type named after its table, and into an index named after its database. So, in the example above, we&amp;rsquo;d get a new index named &amp;ldquo;blog&amp;rdquo; with two types: &amp;ldquo;posts&amp;rdquo; and &amp;ldquo;comments.&amp;rdquo;</source>
          <target state="translated">다음은 강이 &lt;code&gt;blog&lt;/code&gt; 데이터베이스 에서 두 개의 테이블 ( &lt;code&gt;posts&lt;/code&gt; and &lt;code&gt;comments&lt;/code&gt; ) 을 보도록 지시했습니다 . 강은 또한 테이블 업데이트를 관찰하기 전에 해당 테이블에서 기존의 모든 문서를 가져와야합니다. 리버는 기본적으로 문서를 테이블 이름을 가진 유형과 데이터베이스 이름을 가진 색인에 삽입합니다. 따라서 위의 예에서는 '게시물'과 '댓글'이라는 두 가지 유형의 'blog'라는 새 색인을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="3e7bca2668150cf7af8f28ff5d8fe33087f8aa11" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s another, more fun example: adding &lt;a href=&quot;https://en.gravatar.com/site/implement/images/&quot;&gt;Gravatar&lt;/a&gt; avatars to user accounts. We can use &lt;a href=&quot;../../../api/javascript/http/index&quot;&gt;http&lt;/a&gt; to retrieve them.</source>
          <target state="translated">&lt;a href=&quot;https://en.gravatar.com/site/implement/images/&quot;&gt;Gravatar&lt;/a&gt; 아바타를 사용자 계정에 추가하는 또 다른 재미있는 예가 있습니다. &lt;a href=&quot;../../../api/javascript/http/index&quot;&gt;http&lt;/a&gt; 를 사용 하여 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aabb856537a5cb29782d8f22decbbabaf04fe163" translate="yes" xml:space="preserve">
          <source>Here, we listen for changes on multiple tables at once. We simultaneously write into the tables, and observe our writes appear in the changefeeds. We then cancel the changefeeds after we&amp;rsquo;ve written 10 items into each of the tables.</source>
          <target state="translated">여기서는 여러 테이블의 변경 사항을 한 번에 수신합니다. 우리는 동시에 테이블에 쓰고, 우리의 쓰기가 변경 피드에 나타나는 것을 관찰합니다. 그런 다음 각 테이블에 10 개의 항목을 쓴 후 변경 피드를 취소합니다.</target>
        </trans-unit>
        <trans-unit id="4f01b808b9218e45dc7c69f3aef704c9a0d36876" translate="yes" xml:space="preserve">
          <source>Here, we use the &lt;code&gt;r.table('users').pluck('last_name')&lt;/code&gt; query as the inner query in &lt;code&gt;filter&lt;/code&gt;, combining the two queries to build a more sophisticated one. Even if you have a cluster of servers and both the &lt;code&gt;authors&lt;/code&gt; table and the &lt;code&gt;users&lt;/code&gt; table are sharded, RethinkDB will do the right thing and evaluate relevant parts of the query above on the appropriate shards, combine bits of data as necessary, and return the complete result.</source>
          <target state="translated">여기서 &lt;code&gt;r.table('users').pluck('last_name')&lt;/code&gt; 쿼리를 &lt;code&gt;filter&lt;/code&gt; 의 내부 쿼리로 사용 하여 두 쿼리를 결합하여보다 정교한 쿼리를 만듭니다. 서버 클러스터가 있고 &lt;code&gt;authors&lt;/code&gt; 테이블과 &lt;code&gt;users&lt;/code&gt; 테이블이 모두 샤딩 ​​된 경우에도 RethinkDB는 올바른 샤드에 대해 올바른 작업을 수행하고 위 쿼리의 관련 부분을 평가하고 필요에 따라 데이터 비트를 결합하여 전체를 반환합니다. 결과.</target>
        </trans-unit>
        <trans-unit id="bda1b9ddd2a172cd6fc2bdd66737451d25b6f867" translate="yes" xml:space="preserve">
          <source>Hierarchy</source>
          <target state="translated">Hierarchy</target>
        </trans-unit>
        <trans-unit id="d432b424148d95b2cce165cd6d0f0d72d5ced443" translate="yes" xml:space="preserve">
          <source>Host: &lt;code&gt;localhost&lt;/code&gt;</source>
          <target state="translated">호스트 : &lt;code&gt;localhost&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c68edbcf7ed862ae84ad731d2c9e92a481b3221d" translate="yes" xml:space="preserve">
          <source>How GMR queries are executed</source>
          <target state="translated">GMR 쿼리 실행 방법</target>
        </trans-unit>
        <trans-unit id="d0436939cd770cb85fe38b78e1ea8d601df6d4a1" translate="yes" xml:space="preserve">
          <source>How are concurrent queries handled?</source>
          <target state="translated">동시 쿼리는 어떻게 처리됩니까?</target>
        </trans-unit>
        <trans-unit id="05958a9e0373acd35417171d14b2cb37c3c7ad19" translate="yes" xml:space="preserve">
          <source>How can I get a dump of the RethinkDB system tables?</source>
          <target state="translated">RethinkDB 시스템 테이블 덤프를 어떻게 얻을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="4f38e71eadb2253b980e162dfd32f94db825a64c" translate="yes" xml:space="preserve">
          <source>How can I order the output of &lt;code&gt;group&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;group&lt;/code&gt; 의 출력을 어떻게 주문할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="ff95c867208c070d7e0b98dd60887a84ad884d3d" translate="yes" xml:space="preserve">
          <source>How can I perform a backup of my cluster?</source>
          <target state="translated">클러스터 백업을 어떻게 수행 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="6f4c44d7a176db22669cfb91c2ecc685d03533ba" translate="yes" xml:space="preserve">
          <source>How do I specify an external canonical IP address of a RethinkDB node?</source>
          <target state="translated">RethinkDB 노드의 외부 표준 IP 주소를 어떻게 지정합니까?</target>
        </trans-unit>
        <trans-unit id="7584a8c902d164f0d9b0ee384de49f4974a71781" translate="yes" xml:space="preserve">
          <source>How do I store a Ruby DateTime object in RethinkDB?</source>
          <target state="translated">RethinkDB에 Ruby DateTime 객체를 어떻게 저장합니까?</target>
        </trans-unit>
        <trans-unit id="84f27fb4447eb1718681a879231d9bf58780f9cf" translate="yes" xml:space="preserve">
          <source>How does RethinkDB execute queries?</source>
          <target state="translated">RethinkDB는 어떻게 쿼리를 실행합니까?</target>
        </trans-unit>
        <trans-unit id="bcc03b75e66a9846786026fdc4f24e9980175519" translate="yes" xml:space="preserve">
          <source>How does RethinkDB handle data corruption?</source>
          <target state="translated">RethinkDB는 데이터 손상을 어떻게 처리합니까?</target>
        </trans-unit>
        <trans-unit id="554f5b2f1b62f14b6b314e954a24c929e5a7ecb2" translate="yes" xml:space="preserve">
          <source>How does RethinkDB index data?</source>
          <target state="translated">RethinkDB는 어떻게 데이터를 색인합니까?</target>
        </trans-unit>
        <trans-unit id="f9960fac43b439c45d353e943db31612a90a46d8" translate="yes" xml:space="preserve">
          <source>How does RethinkDB partition data into shards?</source>
          <target state="translated">RethinkDB는 어떻게 데이터를 샤드로 분할합니까?</target>
        </trans-unit>
        <trans-unit id="988f89c80cee59aa20b3943aea8c7d5a89cae618" translate="yes" xml:space="preserve">
          <source>How does multi-datacenter support work?</source>
          <target state="translated">다중 데이터 센터 지원은 어떻게 작동합니까?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
