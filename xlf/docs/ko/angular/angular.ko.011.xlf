<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="angular">
    <body>
      <group id="angular">
        <trans-unit id="a34ec2701427b839868d091b0127d333ab500e56" translate="yes" xml:space="preserve">
          <source>Local references to directives and pipes have the correct type (except for any generic parameters, which will be &lt;code&gt;any&lt;/code&gt;).</source>
          <target state="translated">지침 및 파이프에 대한 지역 참조 (것 어떤 일반적인 매개 변수를 제외하고 올바른 유형이 &lt;code&gt;any&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="573faf18825a085ecfb3336ef224bcc2ae1d82cf" translate="yes" xml:space="preserve">
          <source>Local variables</source>
          <target state="translated">지역 변수</target>
        </trans-unit>
        <trans-unit id="d31c7b05d73b6d38864171b72e10fb611bc41b4c" translate="yes" xml:space="preserve">
          <source>Locale data arrays are now read-only. See &lt;a href=&quot;https://github.com/angular/angular/pull/30397&quot;&gt;PR 30397&lt;/a&gt;.</source>
          <target state="translated">로케일 데이터 배열은 이제 읽기 전용입니다. &lt;a href=&quot;https://github.com/angular/angular/pull/30397&quot;&gt;PR 30397을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8977ec427aee669e8db2f2a6f2719f0e9344e0a7" translate="yes" xml:space="preserve">
          <source>Locale name</source>
          <target state="translated">로캘 이름</target>
        </trans-unit>
        <trans-unit id="8b83ba74d8df3106c3c54f05d4661bf3e32767a6" translate="yes" xml:space="preserve">
          <source>Locale to use for i18n.</source>
          <target state="translated">i18n에 사용할 로케일.</target>
        </trans-unit>
        <trans-unit id="aab6c1cd353dbc659954981fd2fe92f5f79b7102" translate="yes" xml:space="preserve">
          <source>Locales may not support some pluralization categories</source>
          <target state="translated">로케일은 일부 복수 범주를 지원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="354166c531bb7a8f9498e76a66696bd9d4b42223" translate="yes" xml:space="preserve">
          <source>Localization and internationalization are &lt;a href=&quot;https://en.wikipedia.org/wiki/Internationalization_and_localization&quot;&gt;different but closely related terms&lt;/a&gt;.</source>
          <target state="translated">현지화와 국제화는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Internationalization_and_localization&quot;&gt;다르지만 밀접한 관련 용어&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cb41a49f532685cd459c440d61ae41a3d0bf8ccc" translate="yes" xml:space="preserve">
          <source>Localization file to use for i18n.</source>
          <target state="translated">i18n에 사용할 현지화 파일</target>
        </trans-unit>
        <trans-unit id="bffe5fc3590d9b0569a08d52d9211106d7ac08c3" translate="yes" xml:space="preserve">
          <source>Localizing your app</source>
          <target state="translated">앱 현지화</target>
        </trans-unit>
        <trans-unit id="55a6907830e4b0ee4cc620928622573b464ba74b" translate="yes" xml:space="preserve">
          <source>Locate</source>
          <target state="translated">Locate</target>
        </trans-unit>
        <trans-unit id="27d4694eb33f8ba8393049799ab0584fffc7e805" translate="yes" xml:space="preserve">
          <source>Locate the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; section.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; 섹션을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="beae6a707a70d58af871d7b7c34fc2505de8b629" translate="yes" xml:space="preserve">
          <source>Locating and analyzing debugging information</source>
          <target state="translated">디버깅 정보 찾기 및 분석</target>
        </trans-unit>
        <trans-unit id="d219c68101f532de10add2cf42fb9dbeca73d3be" translate="yes" xml:space="preserve">
          <source>Location</source>
          <target state="translated">Location</target>
        </trans-unit>
        <trans-unit id="bdd4994b6697d0aa097eab26d31f3838942d67b4" translate="yes" xml:space="preserve">
          <source>Location history state.</source>
          <target state="translated">위치 기록 상태.</target>
        </trans-unit>
        <trans-unit id="8f3c802319cfd4eba7320765609b70dee412ded4" translate="yes" xml:space="preserve">
          <source>Location service that provides a drop-in replacement for the $location service provided in AngularJS.</source>
          <target state="translated">AngularJS에서 제공하는 $ location 서비스를 대체 할 수있는 위치 서비스.</target>
        </trans-unit>
        <trans-unit id="726072084383a83b26e48d4650f089998878f0ca" translate="yes" xml:space="preserve">
          <source>LocationChangeEvent</source>
          <target state="translated">LocationChangeEvent</target>
        </trans-unit>
        <trans-unit id="8b9281f9908f40c4d27eb7d1e85b4cccb5dd2bf6" translate="yes" xml:space="preserve">
          <source>LocationChangeListener</source>
          <target state="translated">LocationChangeListener</target>
        </trans-unit>
        <trans-unit id="a012c9b8aaf5d38c4e605cb39c20f4ff962ac9fb" translate="yes" xml:space="preserve">
          <source>LocationStrategy</source>
          <target state="translated">LocationStrategy</target>
        </trans-unit>
        <trans-unit id="4cf30fb3e21b0273cda4f98b17849340a63a22be" translate="yes" xml:space="preserve">
          <source>LocationUpgradeConfig</source>
          <target state="translated">LocationUpgradeConfig</target>
        </trans-unit>
        <trans-unit id="37fcd2b866223e07ab6791c9aee1bc11bf5e206d" translate="yes" xml:space="preserve">
          <source>LocationUpgradeModule</source>
          <target state="translated">LocationUpgradeModule</target>
        </trans-unit>
        <trans-unit id="25a12fa100f9c3b006680be57a68cce4fc236ef3" translate="yes" xml:space="preserve">
          <source>Log into StackBlitz so you can save and resume your work. If you have a GitHub account, you can log into StackBlitz with that account. In order to save your progress, first fork the project using the Fork button at the top left, then you'll be able to save your work to your own StackBlitz account by clicking the Save button.</source>
          <target state="translated">작업을 저장하고 재개 할 수 있도록 StackBlitz에 로그인하십시오. GitHub 계정이있는 경우 해당 계정으로 StackBlitz에 로그인 할 수 있습니다. 진행 상황을 저장하려면 먼저 왼쪽 상단에있는 포크 버튼을 사용하여 프로젝트를 포크 한 다음 저장 버튼을 클릭하여 자신의 StackBlitz 계정에 작업을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1633e1308cd0841718001dabd16fe2971d97a19b" translate="yes" xml:space="preserve">
          <source>Log progress to the console while building.</source>
          <target state="translated">빌드하는 동안 콘솔에 진행 상황을 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="e5dc85882f60930c7689bfdce39e058c4b570104" translate="yes" xml:space="preserve">
          <source>Log progress to the console.</source>
          <target state="translated">콘솔에 진행 상황을 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="2f54e7dd245f0dfc3ab6abcfff6728499d5442e8" translate="yes" xml:space="preserve">
          <source>Logical structure of the template</source>
          <target state="translated">템플릿의 논리적 구조</target>
        </trans-unit>
        <trans-unit id="00273607a40c79049711519bee4ee7b98bd10173" translate="yes" xml:space="preserve">
          <source>Long Form</source>
          <target state="translated">긴 형태</target>
        </trans-unit>
        <trans-unit id="f33e1356b1160b6efaf79cb2f446e08314df86ae" translate="yes" xml:space="preserve">
          <source>Long localized GMT format</source>
          <target state="translated">긴 현지화 된 GMT 형식</target>
        </trans-unit>
        <trans-unit id="2e144bfc620070f5f43ec82098e80ddab02b2467" translate="yes" xml:space="preserve">
          <source>Long specific non location format (fallback to OOOO)</source>
          <target state="translated">긴 특정 비 위치 형식 (OVO로 대체)</target>
        </trans-unit>
        <trans-unit id="8bdf3c794b8c3fcb2af032ce49e3385b59500b8b" translate="yes" xml:space="preserve">
          <source>Look again at the TypeScript &lt;code&gt;MinimalLogger&lt;/code&gt; class to confirm that it has no implementation.</source>
          <target state="translated">TypeScript &lt;code&gt;MinimalLogger&lt;/code&gt; 클래스를 다시 확인하여 구현이 없는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9714afb7b3fd3c001ce388a1c74ebc12d1268e5e" translate="yes" xml:space="preserve">
          <source>Look at the &lt;code&gt;AppModule&lt;/code&gt;&lt;em&gt;imports&lt;/em&gt; to see how it is configured.</source>
          <target state="translated">상기 봐 &lt;code&gt;AppModule&lt;/code&gt; 의&lt;em&gt;수입&lt;/em&gt; 이 어떻게 구성되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f9a88c4a7ada1a640ab5a9292b8d931bf31bf8c7" translate="yes" xml:space="preserve">
          <source>Look at the browser address bar.</source>
          <target state="translated">브라우저 주소 표시 줄을보십시오.</target>
        </trans-unit>
        <trans-unit id="08e6f48af7c260496751a944791b4e0d4b6e0ce4" translate="yes" xml:space="preserve">
          <source>Look at the browser's address bar. The URL ends in &lt;code&gt;/&lt;/code&gt;. The route path to &lt;code&gt;HeroesComponent&lt;/code&gt; is &lt;code&gt;/heroes&lt;/code&gt;.</source>
          <target state="translated">브라우저의 주소 표시 줄을보십시오. URL은 &lt;code&gt;/&lt;/code&gt; 로 끝납니다 . &lt;code&gt;HeroesComponent&lt;/code&gt; 의 경로 는 &lt;code&gt;/heroes&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7b3028885271626cb1cadf70b2967535e1621603" translate="yes" xml:space="preserve">
          <source>Look at the marble observable definition.</source>
          <target state="translated">대리석의 관찰 가능한 정의를보십시오.</target>
        </trans-unit>
        <trans-unit id="42f94faa84ed8b3a523dc0c01368d8c0d7a3ee41" translate="yes" xml:space="preserve">
          <source>Look at the module &lt;code&gt;imports&lt;/code&gt; array. Notice that the &lt;code&gt;AppRoutingModule&lt;/code&gt; is &lt;em&gt;last&lt;/em&gt;. Most importantly, it comes &lt;em&gt;after&lt;/em&gt; the &lt;code&gt;HeroesModule&lt;/code&gt;.</source>
          <target state="translated">모듈 &lt;code&gt;imports&lt;/code&gt; 배열을보십시오. 공지는 것을 &lt;code&gt;AppRoutingModule&lt;/code&gt; 는 것입니다 &lt;em&gt;마지막으로&lt;/em&gt; . 가장 중요한 것은 온다 &lt;em&gt;후 &lt;/em&gt; &lt;code&gt;HeroesModule&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0ba44f45b5a3040d1447d878bc55088ad4236e4" translate="yes" xml:space="preserve">
          <source>Look at the phone list component first. Right now it contains a TypeScript controller class and a component definition object. You can morph this into an Angular component by just renaming the controller class and turning the AngularJS component definition object into an Angular &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; decorator. You can then also remove the static &lt;code&gt;$inject&lt;/code&gt; property from the class:</source>
          <target state="translated">전화 번호부 구성 요소를 먼저보십시오. 현재 TypeScript 컨트롤러 클래스와 구성 요소 정의 개체가 포함되어 있습니다. 컨트롤러 클래스의 이름을 바꾸고 AngularJS 컴포넌트 정의 오브젝트를 Angular &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; 데코레이터 로 바꾸면 이것을 Angular 컴포넌트로 변형시킬 수 있습니다 . 그런 다음 클래스에서 정적 &lt;code&gt;$inject&lt;/code&gt; 속성을 제거 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de3ec20646b812d6cbc48dad5466aa227cf65d80" translate="yes" xml:space="preserve">
          <source>Look but don't touch.</source>
          <target state="translated">보지만 만지지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5ddf7201ef3546b82f4a6c2e78de5f37db302282" translate="yes" xml:space="preserve">
          <source>Look but don't touch. The classes indicate that it is untouched, pristine, and valid.</source>
          <target state="translated">보지만 만지지 마십시오. 클래스는 그것이 손대지 않았고 깨끗하며 유효하다는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="513e030d1a3f083d725c0b56b56d11109f9c24a0" translate="yes" xml:space="preserve">
          <source>Look for the &lt;code&gt;SideNav&lt;/code&gt; node in &lt;code&gt;navigation.json&lt;/code&gt;. The &lt;code&gt;SideNav&lt;/code&gt; node is an array of navigation nodes. Each node is either an &lt;em&gt;item&lt;/em&gt; node for a single document or a &lt;em&gt;header&lt;/em&gt; node with child nodes.</source>
          <target state="translated">&lt;code&gt;navigation.json&lt;/code&gt; 에서 &lt;code&gt;SideNav&lt;/code&gt; 노드를 찾으십시오 . &lt;code&gt;SideNav&lt;/code&gt; 의 노드는 탐색 노드의 배열이다. 각 노드는 단일 문서 의 &lt;em&gt;항목&lt;/em&gt; 노드이거나 하위 노드가 있는 &lt;em&gt;헤더&lt;/em&gt; 노드입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="103449f798cc7f7fa5c9cee4dae5684dc090c344" translate="yes" xml:space="preserve">
          <source>Look for these expressions in relation to other translation units that you recognize from elsewhere in the source template. In this example, you know the translation unit for the &lt;code&gt;select&lt;/code&gt; must be just below the translation unit for the logo.</source>
          <target state="translated">소스 템플릿의 다른 곳에서 인식하는 다른 번역 단위와 관련하여 이러한 표현식을 찾으십시오. 이 예에서는 &lt;code&gt;select&lt;/code&gt; 의 번역 단위가 로고의 번역 단위 바로 아래에 있어야한다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa1d393ea706ab3e4d6bcd4474df721780901eb8" translate="yes" xml:space="preserve">
          <source>Look inside the &lt;code&gt;src/app&lt;/code&gt; folder.</source>
          <target state="translated">&lt;code&gt;src/app&lt;/code&gt; 폴더를 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="9c5b5378a4ca447832cf5c9b2acce56f7d340ba0" translate="yes" xml:space="preserve">
          <source>Look up the ID for the language-locale combination in &lt;a href=&quot;https://github.com/angular/angular/tree/master/packages/common/locales&quot;&gt;the Angular repository&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/angular/angular/tree/master/packages/common/locales&quot;&gt;Angular 저장소&lt;/a&gt; 에서 언어-로케일 조합의 ID를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="9085df2384321f47fc8246309224f721b2f71c29" translate="yes" xml:space="preserve">
          <source>Looking at the child route under the &lt;code&gt;AdminComponent&lt;/code&gt;, there is a &lt;code&gt;path&lt;/code&gt; and a &lt;code&gt;children&lt;/code&gt; property but it's not using a &lt;code&gt;component&lt;/code&gt;. You haven't made a mistake in the configuration. You've defined a &lt;em&gt;component-less&lt;/em&gt; route.</source>
          <target state="translated">세 이하 아동 경로를 살펴보면 &lt;code&gt;AdminComponent&lt;/code&gt; , 거기입니다 &lt;code&gt;path&lt;/code&gt; 와 &lt;code&gt;children&lt;/code&gt; 특성 만은 사용하지 않을 것 &lt;code&gt;component&lt;/code&gt; . 구성에서 실수하지 않았습니다. &lt;em&gt;구성 요소가없는&lt;/em&gt; 경로를 정의했습니다 .</target>
        </trans-unit>
        <trans-unit id="25e2b281c0bde83d9b580461ea4f7163cd645894" translate="yes" xml:space="preserve">
          <source>Looking back at the &lt;code&gt;CrisisDetailComponent&lt;/code&gt;, it implements the confirmation workflow for unsaved changes.</source>
          <target state="translated">&lt;code&gt;CrisisDetailComponent&lt;/code&gt; 를 되돌아 보면 저장되지 않은 변경 사항에 대한 확인 워크 플로우를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e7e25634e0afadbcb29eb57b05883d36a23ed4f1" translate="yes" xml:space="preserve">
          <source>Looking for an opinionated guide to Angular syntax, conventions, and application structure? Step right in! This style guide presents preferred conventions and, as importantly, explains why.</source>
          <target state="translated">Angular 구문, 규칙 및 응용 프로그램 구조에 대한 의견이있는 가이드를 찾고 계십니까? 들어 오세요! 이 스타일 가이드는 선호되는 규칙과 중요한 이유를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="cea1f4fc1f99cff7cd3c9ac9dc8e20194ab6afc7" translate="yes" xml:space="preserve">
          <source>Looking for components that implement an interface would be better. That's not possible because TypeScript interfaces disappear from the transpiled JavaScript, which doesn't support interfaces. There's no artifact to look for.</source>
          <target state="translated">인터페이스를 구현하는 구성 요소를 찾는 것이 좋습니다. 인터페이스를 지원하지 않는 변환 된 JavaScript에서 TypeScript 인터페이스가 사라지기 때문에 불가능합니다. 찾을 인공물이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4f21b57f74ce75f538e4af1a807f5cf8f7bc2542" translate="yes" xml:space="preserve">
          <source>Loosely structured search criteria; for example, &lt;code&gt;name='wind*'&lt;/code&gt;.</source>
          <target state="translated">느슨하게 구조화 된 검색 기준 예 : &lt;code&gt;name='wind*'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a56f8926a0c06c33dc5d181d345f1e5c45043a2c" translate="yes" xml:space="preserve">
          <source>Low-level API access</source>
          <target state="translated">저수준 API 액세스</target>
        </trans-unit>
        <trans-unit id="6134b7debe4a654fda2ef09a7052103053d9efbb" translate="yes" xml:space="preserve">
          <source>Low-level service for running the angular compiler during runtime to create &lt;a href=&quot;componentfactory&quot;&gt;&lt;code&gt;ComponentFactory&lt;/code&gt;&lt;/a&gt;s, which can later be used to create and render a Component instance.</source>
          <target state="translated">런타임 동안 앵귤러 컴파일러를 실행하여 &lt;a href=&quot;componentfactory&quot;&gt; &lt;code&gt;ComponentFactory&lt;/code&gt; &lt;/a&gt; 를 작성하기위한 저수준 서비스로 , 나중에 Component 인스턴스를 작성하고 렌더링하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6d7137dc931a7743ccff5998f59ac936c950bc8" translate="yes" xml:space="preserve">
          <source>Low-level service for running the angular compiler during runtime to create &lt;a href=&quot;core/componentfactory&quot;&gt;&lt;code&gt;ComponentFactory&lt;/code&gt;&lt;/a&gt;s, which can later be used to create and render a Component instance.</source>
          <target state="translated">런타임 동안 앵귤러 컴파일러를 실행하여 &lt;a href=&quot;core/componentfactory&quot;&gt; &lt;code&gt;ComponentFactory&lt;/code&gt; &lt;/a&gt; 를 작성하기위한 저수준 서비스로 , 나중에 Component 인스턴스를 작성하고 렌더링하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1057a596dddf35f2f660fc4cbd5bf0d9525d2095" translate="yes" xml:space="preserve">
          <source>LowerCasePipe</source>
          <target state="translated">LowerCasePipe</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="4815b07a77d69483937a1efbabc0f2f11cd5708c" translate="yes" xml:space="preserve">
          <source>M (9)</source>
          <target state="translated">M (9)</target>
        </trans-unit>
        <trans-unit id="e094468306e799895a06b2c3b14bbd9f0decc9fb" translate="yes" xml:space="preserve">
          <source>MDC Web is a library created by Google's Material Design team that provides reusable primitives for building Material Design components. The Angular team is incorporating these primitives into Angular Material. Using MDC Web will align Angular Material more closely with the Material Design specification, expand accessibility, improve component quality, and improve our team's velocity.</source>
          <target state="translated">MDC Web은 Google의 Material Design 팀에서 만든 라이브러리로, Material Design 구성 요소를 만들기위한 재사용 가능한 기본 요소를 제공합니다. Angular 팀은 이러한 프리미티브를 Angular Material에 통합하고 있습니다. MDC Web을 사용하면 Angular Material을 Material Design 사양에 더 가깝게 정렬하고 접근성을 확장하고 구성 요소 품질을 개선하며 팀의 속도를 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84b40dd1c9a616e32893709f0160985f45c855c7" translate="yes" xml:space="preserve">
          <source>MDN: Notifications API</source>
          <target state="translated">MDN : 알림 API</target>
        </trans-unit>
        <trans-unit id="bbd453084841140039d2f5d166f91ed00ae70846" translate="yes" xml:space="preserve">
          <source>MDN: Push API</source>
          <target state="translated">MDN : 푸시 API</target>
        </trans-unit>
        <trans-unit id="50f14e525d2e81af2e9a6d53e92146c19aee8e89" translate="yes" xml:space="preserve">
          <source>MDN: Web Push API Notifications best practices</source>
          <target state="translated">MDN : 웹 푸시 API 알림 모범 사례</target>
        </trans-unit>
        <trans-unit id="89690ac571dcf4c9c40c842efed3f11171d07b29" translate="yes" xml:space="preserve">
          <source>MIT</source>
          <target state="translated">MIT</target>
        </trans-unit>
        <trans-unit id="59d84edaf3fd8789deebb4c69c1c96d9dc17b86a" translate="yes" xml:space="preserve">
          <source>MIT / Unicode license</source>
          <target state="translated">MIT / 유니 코드 라이센스</target>
        </trans-unit>
        <trans-unit id="4a3a8927b85daa16f0fe11b6bbb759eee3095858" translate="yes" xml:space="preserve">
          <source>MM</source>
          <target state="translated">MM</target>
        </trans-unit>
        <trans-unit id="5321cdcacbce17ad49f28abfe2ba9da25f850a0f" translate="yes" xml:space="preserve">
          <source>MM (09)</source>
          <target state="translated">MM (09)</target>
        </trans-unit>
        <trans-unit id="251f18d4e6b31f7e8ee5bbc62db713101e85a8c9" translate="yes" xml:space="preserve">
          <source>MMM</source>
          <target state="translated">MMM</target>
        </trans-unit>
        <trans-unit id="385520ba3684b055880262b6a0aae7b122c04a80" translate="yes" xml:space="preserve">
          <source>MMM (Sep)</source>
          <target state="translated">MMM (9 월)</target>
        </trans-unit>
        <trans-unit id="2f5005d0e6ce2fb551cb5f2bdb9740a5ca7c28db" translate="yes" xml:space="preserve">
          <source>MMMM</source>
          <target state="translated">MMMM</target>
        </trans-unit>
        <trans-unit id="dd3f54f92da35573fec642344b62ba3477ccfe7f" translate="yes" xml:space="preserve">
          <source>MMMM (September)</source>
          <target state="translated">MMMM (9 월)</target>
        </trans-unit>
        <trans-unit id="51e8087c726748d21d04753b342826154c269d69" translate="yes" xml:space="preserve">
          <source>MMMMM</source>
          <target state="translated">MMMMM</target>
        </trans-unit>
        <trans-unit id="6ab4970e733a04d47792cab91920b26eb963b14c" translate="yes" xml:space="preserve">
          <source>MOCK_PLATFORM_LOCATION_CONFIG</source>
          <target state="translated">MOCK_PLATFORM_LOCATION_CONFIG</target>
        </trans-unit>
        <trans-unit id="f4dddebe31786c87e0fe408e0085675712af65cc" translate="yes" xml:space="preserve">
          <source>Main section heading</source>
          <target state="translated">주요 섹션 제목</target>
        </trans-unit>
        <trans-unit id="69aca2cdabad30532813ce0f2a3ad8de0760281a" translate="yes" xml:space="preserve">
          <source>Main source file for the builder definition.</source>
          <target state="translated">빌더 정의의 기본 소스 파일</target>
        </trans-unit>
        <trans-unit id="3d0b64ee3c6084e6873a3c70b232a30e725474f6" translate="yes" xml:space="preserve">
          <source>Maintaining library compatibility</source>
          <target state="translated">라이브러리 호환성 유지</target>
        </trans-unit>
        <trans-unit id="1c4bebfe2cfb2181a63c5fee91496eebaf3ef9c5" translate="yes" xml:space="preserve">
          <source>Major versions of Angular CLI follow the supported major version of Angular, but minor versions can be released separately.</source>
          <target state="translated">주요 버전의 Angular CLI는 지원되는 주요 버전의 Angular를 따르지만 부 버전은 별도로 릴리스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf3de5f325d286866e21c85cda474a999cdba14c" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; available everywhere in the app in two steps. First, add it to the root &lt;code&gt;AppModule&lt;/code&gt; by importing it:</source>
          <target state="translated">확인 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 를 두 단계로 응용 프로그램 어디에서나 사용할 수 있습니다. 먼저 가져 와서 루트 &lt;code&gt;AppModule&lt;/code&gt; 에 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="c5a1910e73e7eb6e55c46ff521bb368fe41f7a94" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;compileComponents()&lt;/code&gt; the last step before calling &lt;code&gt;TestBed.createComponent()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TestBed.createComponent()&lt;/code&gt; 를 호출하기 전에 &lt;code&gt;compileComponents()&lt;/code&gt; 를 마지막 단계로 만드십시오 .</target>
        </trans-unit>
        <trans-unit id="d99c5b9ba65adcd58b693254337c6f67be8e03ad" translate="yes" xml:space="preserve">
          <source>Make a copy of the &lt;code&gt;messages.xlf&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;messages.xlf&lt;/code&gt; 파일을 복사 하십시오.</target>
        </trans-unit>
        <trans-unit id="adfb7189b62ee403779a9aec31ce64727ac440c3" translate="yes" xml:space="preserve">
          <source>Make a copy of the &lt;code&gt;messages.xlf&lt;/code&gt; source language file.</source>
          <target state="translated">&lt;code&gt;messages.xlf&lt;/code&gt; 소스 언어 파일 의 사본을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="3c42c44c10f27b50f2e2739c06fd06701cea6f28" translate="yes" xml:space="preserve">
          <source>Make a copy of this file for each language, and send these &lt;em&gt;translation files&lt;/em&gt; to a translator or service.</source>
          <target state="translated">각 언어에 대해이 파일의 사본을 만들고이 &lt;em&gt;번역 파일&lt;/em&gt; 을 번역 가나 서비스에 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="5b7e9db413f403c6893a8e2c2084495d75789b0b" translate="yes" xml:space="preserve">
          <source>Make a dependency &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;&lt;/code&gt; and limit search with &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;&lt;/code&gt; 으로 종속성을 만들고 &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/host&quot;&gt;호스트로&lt;/a&gt; 검색 제한</target>
        </trans-unit>
        <trans-unit id="c4ba3fed3b0a7f9f32cbba560db2e2f5bbc7c37b" translate="yes" xml:space="preserve">
          <source>Make a pipe impure by setting its &lt;code&gt;pure&lt;/code&gt; flag to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;pure&lt;/code&gt; 플래그를 &lt;code&gt;false&lt;/code&gt; 로 설정하여 파이프를 불순하게 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6ceac23c3a3ac47d021f8a0419032c00c50efc3a" translate="yes" xml:space="preserve">
          <source>Make changes to the application</source>
          <target state="translated">응용 프로그램을 변경하십시오</target>
        </trans-unit>
        <trans-unit id="316044472ad8c060a30912cca4487cb3af4f2256" translate="yes" xml:space="preserve">
          <source>Make changes to the application.</source>
          <target state="translated">응용 프로그램을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="a745bd76a30ff56f7cd10a8193c462f31e1fee46" translate="yes" xml:space="preserve">
          <source>Make in-template type requirements more specific with template guards</source>
          <target state="translated">템플릿 가드를 사용하여 템플릿 내 유형 요구 사항을보다 구체적으로 지정</target>
        </trans-unit>
        <trans-unit id="7fc254619bb9f8413958ab0f757b97527731df62" translate="yes" xml:space="preserve">
          <source>Make it look like this:</source>
          <target state="translated">다음과 같이 보이게하십시오 :</target>
        </trans-unit>
        <trans-unit id="1abc7386e3bc39d2084675bbeeedd2ef35237fb7" translate="yes" xml:space="preserve">
          <source>Make sure you do &lt;strong&gt;not&lt;/strong&gt; prefix the &lt;code&gt;highlight&lt;/code&gt; directive name with &lt;strong&gt;&lt;code&gt;ng&lt;/code&gt;&lt;/strong&gt; because that prefix is reserved for Angular and using it could cause bugs that are difficult to diagnose.</source>
          <target state="translated">&lt;code&gt;highlight&lt;/code&gt; 지시문 이름 앞에 &lt;strong&gt; &lt;code&gt;ng&lt;/code&gt; &lt;/strong&gt; 를 붙이지 &lt;strong&gt;마십시오.&lt;/strong&gt; 접두사는 Angular 용으로 예약되어 있으므로 진단하기 어려운 버그가 발생할 수 있습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="712b8ca64e1f48176d6c762ee018e17f602405ff" translate="yes" xml:space="preserve">
          <source>Make that consistent and easy by encapsulating the &lt;em&gt;click-triggering&lt;/em&gt; process in a helper such as the &lt;code&gt;click()&lt;/code&gt; function below:</source>
          <target state="translated">아래 의 &lt;code&gt;click()&lt;/code&gt; 함수 와 같은 도우미에서 &lt;em&gt;클릭 트리거링&lt;/em&gt; 프로세스를 캡슐화하여 일관성 있고 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e9a223fa588ccd851f1c1b0cb30f1273de71037" translate="yes" xml:space="preserve">
          <source>Make the &lt;code&gt;AuthGuard&lt;/code&gt; at least pretend to authenticate.</source>
          <target state="translated">만들기 기능 &lt;code&gt;AuthGuard&lt;/code&gt; 인증하는 척 적어도합니다.</target>
        </trans-unit>
        <trans-unit id="dfaed036a3d30d15684aeb96627e326e309f4f52" translate="yes" xml:space="preserve">
          <source>Make the &lt;code&gt;AuthGuard&lt;/code&gt; mimic authentication.</source>
          <target state="translated">만들기 기능 &lt;code&gt;AuthGuard&lt;/code&gt; 모방 인증을.</target>
        </trans-unit>
        <trans-unit id="eb19f1f382051a6d85c4333391125d5ede5a7d90" translate="yes" xml:space="preserve">
          <source>Make the &lt;code&gt;HeroDetailComponent&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;HeroDetailComponent&lt;/code&gt; 만들기</target>
        </trans-unit>
        <trans-unit id="463dda4da4220019aeeebd42f257d172fd01b63a" translate="yes" xml:space="preserve">
          <source>Make the animation definition available in your application by adding the reusable animation (&lt;code&gt;slideInAnimation&lt;/code&gt;) to the &lt;code&gt;animations&lt;/code&gt; metadata of the &lt;code&gt;AppComponent&lt;/code&gt;.</source>
          <target state="translated">재사용 가능한 애니메이션 (추가하여 응용 프로그램에서 애니메이션 정의를 사용할 수 있도록 &lt;code&gt;slideInAnimation&lt;/code&gt; 받는 사람) &lt;code&gt;animations&lt;/code&gt; 의 메타 데이터 &lt;code&gt;AppComponent&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="74751227eae7954f97375b0126f0b17886fb4edd" translate="yes" xml:space="preserve">
          <source>Make this and future navigation links look better by adding private CSS styles to &lt;code&gt;app.component.css&lt;/code&gt; as listed in the &lt;a href=&quot;toh-pt5#appcomponent&quot;&gt;final code review&lt;/a&gt; below.</source>
          <target state="translated">아래 의 &lt;a href=&quot;toh-pt5#appcomponent&quot;&gt;최종 코드 검토에&lt;/a&gt; 나열된 것처럼 개인 CSS 스타일을 &lt;code&gt;app.component.css&lt;/code&gt; 에 추가하여이 탐색 및 향후 탐색 링크를 더보기 좋게 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="dda44cf2cb718e16905dfed467c1eda66196d813" translate="yes" xml:space="preserve">
          <source>Makes some of those components, directives, and pipes public so that other module's component templates can use them.</source>
          <target state="translated">이러한 구성 요소, 지시문 및 파이프 중 일부를 공개하여 다른 모듈의 구성 요소 템플리트에서 사용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="b5410952d702720b0d3986ba9bebbbd760f482c3" translate="yes" xml:space="preserve">
          <source>Making Angular Dependencies Injectable to AngularJS</source>
          <target state="translated">AngularJS에 Angular 의존성을 주입 할 수있게 만들기</target>
        </trans-unit>
        <trans-unit id="31c9b48df89528d530e4f8037c6726b1d77e4601" translate="yes" xml:space="preserve">
          <source>Making AngularJS Dependencies Injectable to Angular</source>
          <target state="translated">AngularJS 의존성을 Angular에 주입 가능하게 만들기</target>
        </trans-unit>
        <trans-unit id="53df0636f24a76fd425c9228f1963fbda618ba6a" translate="yes" xml:space="preserve">
          <source>Making a DELETE request</source>
          <target state="translated">삭제 요청하기</target>
        </trans-unit>
        <trans-unit id="3c975508e5dfdc90bc9e5763fc3c9cde303a94a6" translate="yes" xml:space="preserve">
          <source>Making a JSONP request</source>
          <target state="translated">JSONP 요청하기</target>
        </trans-unit>
        <trans-unit id="682a5e632852e8d274f560b7523b9f8d6c204027" translate="yes" xml:space="preserve">
          <source>Making a POST request</source>
          <target state="translated">POST 요청하기</target>
        </trans-unit>
        <trans-unit id="6a339adf05c8177aed46ff499123318bda51215e" translate="yes" xml:space="preserve">
          <source>Making a PUT request</source>
          <target state="translated">PUT 요청하기</target>
        </trans-unit>
        <trans-unit id="43e432fa0ad68e86b6c27d1e0ada2b9ae88e7e75" translate="yes" xml:space="preserve">
          <source>Making changes to your application</source>
          <target state="translated">응용 프로그램 변경</target>
        </trans-unit>
        <trans-unit id="e5d93d893b4d8a2a4fbf92ae586b0c73b00beed0" translate="yes" xml:space="preserve">
          <source>Manage marked text with custom IDs</source>
          <target state="translated">사용자 지정 ID로 표시된 텍스트 관리</target>
        </trans-unit>
        <trans-unit id="5759e22986abbd59e9864d410a1f83086069d2df" translate="yes" xml:space="preserve">
          <source>Manages the value and validity state of a group of &lt;code&gt;&lt;a href=&quot;../api/forms/abstractcontrol&quot;&gt;AbstractControl&lt;/a&gt;&lt;/code&gt; instances. The group's properties include its child controls. The top-level form in your component is &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/forms/abstractcontrol&quot;&gt;AbstractControl&lt;/a&gt;&lt;/code&gt; 인스턴스 그룹의 값과 유효성 상태를 관리합니다 . 그룹의 속성에는 자식 컨트롤이 포함됩니다. 컴포넌트의 최상위 양식은 &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0fd426fb9002208c4566e9fae5a1f6f8e2b68b5f" translate="yes" xml:space="preserve">
          <source>Manages the value and validity state of a numerically indexed array of &lt;code&gt;&lt;a href=&quot;../api/forms/abstractcontrol&quot;&gt;AbstractControl&lt;/a&gt;&lt;/code&gt; instances.</source>
          <target state="translated">숫자로 색인화 된 &lt;code&gt;&lt;a href=&quot;../api/forms/abstractcontrol&quot;&gt;AbstractControl&lt;/a&gt;&lt;/code&gt; 인스턴스 배열의 값과 유효성 상태를 관리합니다 .</target>
        </trans-unit>
        <trans-unit id="e404dc463feb533622563f65f551014165fdd976" translate="yes" xml:space="preserve">
          <source>Manages the value and validity status of an individual form control. It corresponds to an HTML form control such as &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">개별 양식 컨트롤의 값과 유효성 상태를 관리합니다. &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 와 같은 HTML 양식 컨트롤에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="a06d5782e6b2e4d5130fa84dff2103e2c6bc93d0" translate="yes" xml:space="preserve">
          <source>Managing Data</source>
          <target state="translated">데이터 관리</target>
        </trans-unit>
        <trans-unit id="426511ddcafff26d74b6bbca96b1de93ad6b43e1" translate="yes" xml:space="preserve">
          <source>Managing assets in a library</source>
          <target state="translated">라이브러리에서 자산 관리</target>
        </trans-unit>
        <trans-unit id="be888fa4e434addfba15bf7c780695443961d736" translate="yes" xml:space="preserve">
          <source>Managing control values</source>
          <target state="translated">제어 값 관리</target>
        </trans-unit>
        <trans-unit id="9db1f3238218ba7ed5dc75cfc817d6b2ff8ee541" translate="yes" xml:space="preserve">
          <source>Managing data</source>
          <target state="translated">데이터 관리</target>
        </trans-unit>
        <trans-unit id="2a9e8c74b17baa18fe51ec87aab50e6907bebe12" translate="yes" xml:space="preserve">
          <source>Managing state transitions is one of the hardest parts of building applications. This is especially true on the web, where you also need to ensure that the state is reflected in the URL. In addition, we often want to split applications into multiple bundles and load them on demand. Doing this transparently is not trivial.</source>
          <target state="translated">상태 전환 관리는 애플리케이션 구축에서 가장 어려운 부분 중 하나입니다. 이것은 웹에서 특히 그렇습니다. 웹에서도 상태가 URL에 반영되도록해야합니다. 또한 애플리케이션을 여러 번들로 분할하여 필요할 때로드하는 경우가 종종 있습니다. 이것을 투명하게하는 것은 사소한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0ee43e052d4a23f21892c2695989404df43ace84" translate="yes" xml:space="preserve">
          <source>Mandatory polyfills</source>
          <target state="translated">필수 폴리 필</target>
        </trans-unit>
        <trans-unit id="cbd89d1007525e4ca47bee6f8f673387a6733049" translate="yes" xml:space="preserve">
          <source>Manipulating the code in an application has the potential to be both very powerful and correspondingly dangerous. For example, creating a file that already exists would be an error, and if it was applied immediately, it would discard all the other changes applied so far. The Angular Schematics tooling guards against side effects and errors by creating a virtual file system. A schematic describes a pipeline of transformations that can be applied to the virtual file system. When a schematic runs, the transformations are recorded in memory, and only applied in the real file system once they're confirmed to be valid.</source>
          <target state="translated">응용 프로그램에서 코드를 조작하면 매우 강력하고 위험 할 수 있습니다. 예를 들어, 이미 존재하는 파일을 작성하면 오류가 발생하고 즉시 적용한 경우 지금까지 적용된 다른 모든 변경 사항은 삭제됩니다. Angular Schematics 툴링은 가상 파일 시스템을 만들어 부작용과 오류를 방지합니다. 회로도는 가상 파일 시스템에 적용 할 수있는 변환 파이프 라인을 설명합니다. 회로도가 실행될 때 변환은 메모리에 기록되며 유효한 것으로 확인되면 실제 파일 시스템에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="db4511ba7c974dbee1de67c07e877aa499f1b010" translate="yes" xml:space="preserve">
          <source>Manually set the errors for a control</source>
          <target state="translated">컨트롤 오류 수동 설정</target>
        </trans-unit>
        <trans-unit id="9a073277d8726e5adb59f517b0f701f6d2b7d2f5" translate="yes" xml:space="preserve">
          <source>Many Angular APIs return &lt;a href=&quot;glossary#observable&quot;&gt;&lt;em&gt;observables&lt;/em&gt;&lt;/a&gt;. RxJS is an implementation of the proposed &lt;a href=&quot;https://github.com/tc39/proposal-observable&quot;&gt;Observables specification&lt;/a&gt; currently before the &lt;a href=&quot;https://www.ecma-international.org/memento/tc39-m.htm&quot;&gt;TC39&lt;/a&gt; committee, which determines standards for the JavaScript language.</source>
          <target state="translated">많은 Angular API는 &lt;a href=&quot;glossary#observable&quot;&gt;&lt;em&gt;Observable을&lt;/em&gt;&lt;/a&gt; 반환 합니다. RxJS는 현재 &lt;a href=&quot;https://www.ecma-international.org/memento/tc39-m.htm&quot;&gt;TC39&lt;/a&gt; 위원회 이전에 제안 된 &lt;a href=&quot;https://github.com/tc39/proposal-observable&quot;&gt;Observables 사양을&lt;/a&gt; 구현 한 것으로 JavaScript 언어의 표준을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="841a4a336a9bf0b0530b121166afbe26ecbf0dba" translate="yes" xml:space="preserve">
          <source>Many Angular APIs return &lt;a href=&quot;glossary#observable&quot;&gt;&lt;em&gt;observables&lt;/em&gt;&lt;/a&gt;. RxJS is an implementation of the proposed &lt;a href=&quot;https://github.com/tc39/proposal-observable&quot;&gt;Observables specification&lt;/a&gt; currently before the &lt;a href=&quot;https://www.ecma-international.org/memento/tc39.htm&quot;&gt;TC39&lt;/a&gt; committee, which determines standards for the JavaScript language.</source>
          <target state="translated">많은 Angular API는 &lt;a href=&quot;glossary#observable&quot;&gt;&lt;em&gt;관찰 가능 항목을&lt;/em&gt;&lt;/a&gt; 반환 합니다. RxJS는 JavaScript 언어에 대한 표준을 결정 하는 &lt;a href=&quot;https://www.ecma-international.org/memento/tc39.htm&quot;&gt;TC39&lt;/a&gt; 위원회 이전에 제안 된 &lt;a href=&quot;https://github.com/tc39/proposal-observable&quot;&gt;Observables 사양을&lt;/a&gt; 구현 한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="bb3077fb1299e0d4c5be4bed68c3efe959b2a279" translate="yes" xml:space="preserve">
          <source>Many JavaScript libraries, such as jQuery, the Jasmine testing library, and Angular, extend the JavaScript environment with features and syntax that the TypeScript compiler doesn't recognize natively. When the compiler doesn't recognize something, it throws an error.</source>
          <target state="translated">jQuery, Jasmine 테스트 라이브러리 및 Angular와 같은 많은 JavaScript 라이브러리는 TypeScript 컴파일러가 기본적으로 인식하지 못하는 기능과 구문으로 JavaScript 환경을 확장합니다. 컴파일러가 무언가를 인식하지 못하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="79a5cc6e3569f968faded9077d4da5c809fd4a34" translate="yes" xml:space="preserve">
          <source>Many NgModules such as the &lt;a href=&quot;router&quot;&gt;&lt;code&gt;RouterModule&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;forms&quot;&gt;&lt;code&gt;FormsModule&lt;/code&gt;&lt;/a&gt; define their own attribute directives. The most common attribute directives are as follows:</source>
          <target state="translated">예를 들면 같은 많은 NgModules &lt;a href=&quot;router&quot;&gt; &lt;code&gt;RouterModule&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;forms&quot;&gt; &lt;code&gt;FormsModule&lt;/code&gt; 는&lt;/a&gt; 자신의 속성 지침을 정의합니다. 가장 일반적인 속성 지시문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="00f3acc423ed6a2d31b34e70beebcddb6eebbe59" translate="yes" xml:space="preserve">
          <source>Many applications allow users to work on several open tasks at the same time. For example, in a tax preparation application, the preparer could be working on several tax returns, switching from one to the other throughout the day.</source>
          <target state="translated">많은 응용 프로그램을 통해 사용자는 여러 개의 열린 작업을 동시에 수행 할 수 있습니다. 예를 들어, 세금 준비 응용 프로그램에서 준비자는 하루 종일 여러 가지 세금 환급 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e60910eccbea916931290f9e1a1edb67389dec1" translate="yes" xml:space="preserve">
          <source>Many applications need to solve the same general problems, such as presenting a unified user interface, presenting data, and allowing data entry. Developers can create general solutions for particular domains that can be adapted for re-use in different apps. Such a solution can be built as Angular &lt;em&gt;libraries&lt;/em&gt; and these libraries can be published and shared as &lt;em&gt;npm packages&lt;/em&gt;.</source>
          <target state="translated">많은 응용 프로그램에서 통합 사용자 인터페이스 표시, 데이터 표시 및 데이터 입력 허용과 같은 동일한 일반적인 문제를 해결해야합니다. 개발자는 다른 앱에서 재사용 할 수있는 특정 도메인에 대한 일반적인 솔루션을 만들 수 있습니다. 이러한 솔루션은 Angular &lt;em&gt;라이브러리&lt;/em&gt; 로 구축 할 수 있으며 이러한 라이브러리는 &lt;em&gt;npm 패키지&lt;/em&gt; 로 게시 및 공유 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2f6e590417b1e950f21e2fe4525ecf836ea048a" translate="yes" xml:space="preserve">
          <source>Many browsers lack native support for some features in the latest HTML standards, features that Angular requires. &lt;a href=&quot;https://en.wikipedia.org/wiki/Polyfill_(programming)&quot;&gt;&lt;em&gt;Polyfills&lt;/em&gt;&lt;/a&gt; can emulate the missing features. The &lt;a href=&quot;browser-support&quot;&gt;Browser Support&lt;/a&gt; guide explains which browsers need polyfills and how you can add them.</source>
          <target state="translated">많은 브라우저는 최신 HTML 표준의 일부 기능인 Angular에 필요한 기능을 기본적으로 지원하지 않습니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Polyfill_(programming)&quot;&gt;&lt;em&gt;폴리 필&lt;/em&gt;&lt;/a&gt; 은 누락 된 피처를 에뮬레이션 할 수 있습니다. &lt;a href=&quot;browser-support&quot;&gt;브라우저 지원&lt;/a&gt; 가이드 브라우저 polyfills이 필요한 당신이 그들을 추가 할 수있는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fdde828ec52442b4eedb4346b2654c7a1e75d261" translate="yes" xml:space="preserve">
          <source>Many code snippets illustrate the points and concepts, all of them available in the .</source>
          <target state="translated">많은 코드 스 니펫은 요점과 개념을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a5769571f8826f258e20b10faf5d97c4b29d84c5" translate="yes" xml:space="preserve">
          <source>Many components specify &lt;em&gt;external templates&lt;/em&gt; and &lt;em&gt;external css&lt;/em&gt; with the &lt;code&gt;@&lt;a href=&quot;../api/core/component#templateUrl&quot;&gt;Component.templateUrl&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;@&lt;a href=&quot;../api/core/component#styleUrls&quot;&gt;Component.styleUrls&lt;/a&gt;&lt;/code&gt; properties respectively, as the following variant of &lt;code&gt;BannerComponent&lt;/code&gt; does.</source>
          <target state="translated">대부분의 구성 요소 는 다음 &lt;code&gt;BannerComponent&lt;/code&gt; 변형 과 같이 &lt;code&gt;@&lt;a href=&quot;../api/core/component#templateUrl&quot;&gt;Component.templateUrl&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/component#templateUrl&quot;&gt;Component.templateUrl&lt;/a&gt; 및 &lt;code&gt;@&lt;a href=&quot;../api/core/component#styleUrls&quot;&gt;Component.styleUrls&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/component#styleUrls&quot;&gt;Component.styleUrls&lt;/a&gt; 속성을 사용하여 &lt;em&gt;외부 템플릿&lt;/em&gt; 과 &lt;em&gt;외부 CSS&lt;/em&gt; 를 각각 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="d74beeb4e407d44341eb572c501e351f4033521c" translate="yes" xml:space="preserve">
          <source>Many countries, such as France and Canada, use the same language (French, identified as &lt;code&gt;fr&lt;/code&gt;) but differ in grammar, punctuation, and formats for currency, decimal numbers, and dates. Use a more specific locale ID, such as French for Canada (&lt;code&gt;fr-CA&lt;/code&gt;), when localizing your app.</source>
          <target state="translated">프랑스와 캐나다와 같은 많은 국가에서는 동일한 언어 (프랑스어, &lt;code&gt;fr&lt;/code&gt; 로 식별 됨 )를 사용하지만 문법, 구두점 및 통화, 십진수 및 날짜 형식이 다릅니다. 앱을 현지화 할 때 캐나다 용 프랑스어 ( &lt;code&gt;fr-CA&lt;/code&gt; ) 와 같은보다 구체적인 로케일 ID를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="acc85a759063bfaad44d4c09b73aac23c0466b71" translate="yes" xml:space="preserve">
          <source>Many dependency values are provided by classes, but not all. The expanded &lt;em&gt;provide&lt;/em&gt; object lets you associate different kinds of providers with a DI token.</source>
          <target state="translated">클래스가 많은 종속성 값을 제공하지만 전부는 아닙니다. 확장 된 &lt;em&gt;제공&lt;/em&gt; 개체를 사용하면 다양한 종류의 공급자를 DI 토큰과 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6bc57d6d1877b71ad49a4a9eab6aeaf31d96e3b" translate="yes" xml:space="preserve">
          <source>Many developers feel this approach is cleaner and more explicit than the traditional &lt;code&gt;beforeEach()&lt;/code&gt; style.</source>
          <target state="translated">많은 개발자들은이 방법이 기존의 &lt;code&gt;beforeEach()&lt;/code&gt; 스타일 보다 깨끗하고 명확하다고 생각합니다 .</target>
        </trans-unit>
        <trans-unit id="c964d1c587a16600688084c23f6ab48e7efca0b1" translate="yes" xml:space="preserve">
          <source>Many developers prefer to declare the factory provider in a separate &lt;code&gt;ajs-upgraded-providers.ts&lt;/code&gt; file so that they are all together, making it easier to reference them, create new ones and delete them once the upgrade is over.</source>
          <target state="translated">많은 개발자가 별도의 &lt;code&gt;ajs-upgraded-providers.ts&lt;/code&gt; 파일로 팩토리 제공자를 선언하여 업그레이드가 완료된 후 이를 쉽게 참조하고 새로 작성하고 삭제할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="3b4d240f94587f486e748968376e891c49e6d4ca" translate="yes" xml:space="preserve">
          <source>Many forms, such as questionaires, can be very similar to one another in format and intent. To make it faster and easier to generate different versions of such a form, you can create a &lt;em&gt;dynamic form template&lt;/em&gt; based on metadata that describes the business object model. You can then use the template to generate new forms automatically, according to changes in the data model.</source>
          <target state="translated">설문지와 같은 많은 양식은 형식과 의도가 서로 매우 유사 할 수 있습니다. 이러한 양식의 다른 버전을 더 빠르고 쉽게 생성하기 위해 비즈니스 개체 모델을 설명하는 메타 데이터를 기반으로 &lt;em&gt;동적 양식 템플릿을&lt;/em&gt; 만들 수 있습니다 . 그런 다음 템플릿을 사용하여 데이터 모델의 변경 사항에 따라 새 양식을 자동으로 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ab5deb39f9c7a1a879f01f3a89332be8ff505de" translate="yes" xml:space="preserve">
          <source>Many guides tell a story. In that story, the app evolves incrementally, often with simplistic or incomplete code along the way.</source>
          <target state="translated">많은 가이드가 이야기를합니다. 이 이야기에서 앱은 종종 단순하거나 불완전한 코드로 점진적으로 진화합니다.</target>
        </trans-unit>
        <trans-unit id="3dc83b718f084abe53b5d87cf0666ccf6e382300" translate="yes" xml:space="preserve">
          <source>Many interceptors are only concerned with the outgoing request and return the event stream from &lt;code&gt;next.handle()&lt;/code&gt; without modifying it. Some interceptors, however, need to examine and modify the response from &lt;code&gt;next.handle()&lt;/code&gt;; these operations can see all of these events in the stream.</source>
          <target state="translated">많은 인터셉터는 나가는 요청에만 관심이 있으며 수정하지 않고 &lt;code&gt;next.handle()&lt;/code&gt; 에서 이벤트 스트림을 반환 합니다. 그러나 일부 인터셉터는 &lt;code&gt;next.handle()&lt;/code&gt; 의 응답을 조사하고 수정해야합니다 . 이러한 작업은 스트림에서 이러한 모든 이벤트를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="087124921eb33f7e338ea00e25240b971be1f766" translate="yes" xml:space="preserve">
          <source>Many interceptors are only concerned with the outgoing request and simply return the event stream from &lt;code&gt;next.handle()&lt;/code&gt; without modifying it.</source>
          <target state="translated">많은 인터셉터는 나가는 요청에만 관심이 있으며 수정하지 않고 &lt;code&gt;next.handle()&lt;/code&gt; 에서 이벤트 스트림을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0d466227c3ceaced415c72a362876ff6eef8934e" translate="yes" xml:space="preserve">
          <source>Many libraries include definition files in their npm packages where both the TypeScript compiler and editors can find them. Angular is one such library. The &lt;code&gt;node_modules/@angular/core/&lt;/code&gt; folder of any Angular application contains several &lt;code&gt;d.ts&lt;/code&gt; files that describe parts of Angular.</source>
          <target state="translated">많은 라이브러리는 TypeScript 컴파일러와 편집기가 모두 찾을 수있는 정의 파일을 npm 패키지에 포함합니다. Angular는 그러한 라이브러리 중 하나입니다. Angular 응용 프로그램 의 &lt;code&gt;node_modules/@angular/core/&lt;/code&gt; 폴더에는 Angular의 일부를 설명하는 여러 &lt;code&gt;d.ts&lt;/code&gt; 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a5e32c0e28524dc6612566940bcead3465d22d7" translate="yes" xml:space="preserve">
          <source>Many libraries&amp;mdash;jQuery, Jasmine, and Lodash among them&amp;mdash;do &lt;em&gt;not&lt;/em&gt; include &lt;code&gt;d.ts&lt;/code&gt; files in their npm packages. Fortunately, either their authors or community contributors have created separate &lt;code&gt;d.ts&lt;/code&gt; files for these libraries and published them in well-known locations.</source>
          <target state="translated">jQuery, Jasmine 및 Lodash와 같은 많은 라이브러리 는 npm 패키지에 &lt;code&gt;d.ts&lt;/code&gt; 파일을 포함 하지 &lt;em&gt;않습니다&lt;/em&gt; . 다행히도 저자 또는 커뮤니티 기고자 &lt;code&gt;d.ts&lt;/code&gt; 라이브러리에 대해 별도의 d.ts 파일을 만들어 잘 알려진 위치에 게시했습니다.</target>
        </trans-unit>
        <trans-unit id="0fe16d5a33623825dfcf063927a243cf38d8f465" translate="yes" xml:space="preserve">
          <source>Many locales don't support some of the pluralization categories. For example, the default locale (&lt;code&gt;en-US&lt;/code&gt;) and other locales (such as &lt;code&gt;es&lt;/code&gt;) have very simple &lt;code&gt;plural()&lt;/code&gt; functions that don't support the &lt;code&gt;few&lt;/code&gt; category. The following shows the &lt;a href=&quot;https://github.com/angular/angular/blob/ecffc3557fe1bff9718c01277498e877ca44588d/packages/core/src/i18n/locale_en.ts#L15-L18&quot;&gt;en-US&lt;/a&gt;&lt;code&gt;plural()&lt;/code&gt; function:</source>
          <target state="translated">많은 로케일은 일부 복수화 범주를 지원하지 않습니다. 예를 들어 기본 로케일 ( &lt;code&gt;en-US&lt;/code&gt; ) 및 기타 로케일 (예 : &lt;code&gt;es&lt;/code&gt; )에는 &lt;code&gt;few&lt;/code&gt; 범주를 지원하지 않는 매우 간단한 &lt;code&gt;plural()&lt;/code&gt; 함수가 있습니다. 다음은 &lt;a href=&quot;https://github.com/angular/angular/blob/ecffc3557fe1bff9718c01277498e877ca44588d/packages/core/src/i18n/locale_en.ts#L15-L18&quot;&gt;en-US &lt;/a&gt; &lt;code&gt;plural()&lt;/code&gt; 함수를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="046ec844bebb9efb2d96c41d15cd45da244e448e" translate="yes" xml:space="preserve">
          <source>Many servers require extra headers for save operations. For example, a server might require an authorization token, or &quot;Content-Type&quot; header to explicitly declare the MIME type of the request body.</source>
          <target state="translated">많은 서버에서 저장 작업을 위해 추가 헤더가 필요합니다. 예를 들어 서버는 요청 본문의 MIME 유형을 명시 적으로 선언하기 위해 인증 토큰 또는 &quot;Content-Type&quot;헤더가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff9a14500d4b27838588c153e0ce6118bde4d3dc" translate="yes" xml:space="preserve">
          <source>Many servers require extra headers for save operations. For example, they may require a &quot;Content-Type&quot; header to explicitly declare the MIME type of the request body; or the server may require an authorization token.</source>
          <target state="translated">많은 서버에는 저장 작업을 위해 추가 헤더가 필요합니다. 예를 들어, 요청 본문의 MIME 유형을 명시 적으로 선언하려면 &quot;Content-Type&quot;헤더가 필요할 수 있습니다. 또는 서버에 인증 토큰이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="def2eba59562958fa4a005f8070d692ef8502312" translate="yes" xml:space="preserve">
          <source>Mapping</source>
          <target state="translated">Mapping</target>
        </trans-unit>
        <trans-unit id="5bf26159333bb0d591492f96ca2581ad9f4c90e3" translate="yes" xml:space="preserve">
          <source>Mapping values to different types</source>
          <target state="translated">다른 유형으로 값 매핑</target>
        </trans-unit>
        <trans-unit id="b0227d5b874883ace3269140fb46b470e3787118" translate="yes" xml:space="preserve">
          <source>Maps a value to a string that pluralizes the value according to locale rules.</source>
          <target state="translated">로캘 규칙에 따라 값을 복수화하는 문자열에 값을 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="b7ef7ab0b381d0f8a5fb0d490f85aca22d85119c" translate="yes" xml:space="preserve">
          <source>Maps class properties to host element bindings for properties, attributes, and events, using a set of key-value pairs.</source>
          <target state="translated">키-값 쌍 세트를 사용하여 클래스 특성을 특성, 속성 및 이벤트에 대한 요소 바인딩을 호스트하도록 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="57cafd2d2e26c1f59483ef5f063c9e987cbdfa9c" translate="yes" xml:space="preserve">
          <source>Maps gesture event names to a set of configuration options that specify overrides to the default values for specific properties.</source>
          <target state="translated">제스처 이벤트 이름을 특정 특성의 기본값으로 대체하도록 지정하는 구성 옵션 세트에 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="1c7e24fff6616d8c4782b59d907d55d2247857e6" translate="yes" xml:space="preserve">
          <source>Marble error testing</source>
          <target state="translated">대리석 오류 테스트</target>
        </trans-unit>
        <trans-unit id="e562d7610fc93c95e63bd0db325143eb510fa729" translate="yes" xml:space="preserve">
          <source>Mark alternate text for translation.</source>
          <target state="translated">번역 할 대체 텍스트를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="81d3d001db5590e8c15314370938a60c7237302b" translate="yes" xml:space="preserve">
          <source>Mark alternates and nested expressions</source>
          <target state="translated">대체 및 중첩 표현식 표시</target>
        </trans-unit>
        <trans-unit id="da881c8d91de1bc52f72125536a11d49cd919667" translate="yes" xml:space="preserve">
          <source>Mark element attributes for translations</source>
          <target state="translated">번역을위한 요소 속성 표시</target>
        </trans-unit>
        <trans-unit id="77977937317522a208e66701274fc635ce05f7a4" translate="yes" xml:space="preserve">
          <source>Mark plural forms of expressions for translation.</source>
          <target state="translated">번역 할 표현의 복수형을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="31605ea7c401c912ded6f71f0d30c42b16077283" translate="yes" xml:space="preserve">
          <source>Mark plurals</source>
          <target state="translated">복수형 표시</target>
        </trans-unit>
        <trans-unit id="443165aaf4de712fa8c701e381d24edeafa0602f" translate="yes" xml:space="preserve">
          <source>Mark plurals and alternates for translation</source>
          <target state="translated">번역을 위해 복수형 및 대체 형 표시</target>
        </trans-unit>
        <trans-unit id="d80fdfe3e44fb2d131f4020c8562cfb36d7d1d87" translate="yes" xml:space="preserve">
          <source>Mark static text messages in your component templates for translation.</source>
          <target state="translated">구성 요소 템플릿에서 정적 텍스트 메시지를 표시하여 번역하십시오.</target>
        </trans-unit>
        <trans-unit id="453c8cbe5bf736d4dfb44391431d69031ce3cbfd" translate="yes" xml:space="preserve">
          <source>Mark text for translations</source>
          <target state="translated">번역 할 텍스트 표시</target>
        </trans-unit>
        <trans-unit id="8a393f1ea26ec9ee519bcdc713dbd9fd705c0ef0" translate="yes" xml:space="preserve">
          <source>Mark text in component templates for translation.</source>
          <target state="translated">번역 할 구성 요소 템플릿의 텍스트를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="633286acdeeb25d4557c214aacb8517fd371099a" translate="yes" xml:space="preserve">
          <source>Mark text with the i18n attribute</source>
          <target state="translated">i18n 속성으로 텍스트 표시</target>
        </trans-unit>
        <trans-unit id="c6c84768f276a98932c12aa0ab514727ec8eecd6" translate="yes" xml:space="preserve">
          <source>Mark the static text messages in your component templates for translation using the &lt;code&gt;i18n&lt;/code&gt; attribute. Place it on every element tag with fixed text to be translated.</source>
          <target state="translated">&lt;code&gt;i18n&lt;/code&gt; 속성을 사용하여 번역 할 구성 요소 템플릿의 정적 텍스트 메시지를 표시 합니다. 번역 할 고정 텍스트가있는 모든 요소 태그에 배치합니다.</target>
        </trans-unit>
        <trans-unit id="a5f9500a0b279f38bcdf05b09a7ba44c7259acbd" translate="yes" xml:space="preserve">
          <source>Markdown and HTML</source>
          <target state="translated">마크 다운 및 HTML</target>
        </trans-unit>
        <trans-unit id="a926e63e15068ff8778fa46fbc6837498e696ece" translate="yes" xml:space="preserve">
          <source>Markdown is easier to read and to edit than HTML. Many editors (including Visual Studio Code) can render markdown as you type it.</source>
          <target state="translated">마크 다운은 HTML보다 읽고 편집하기가 더 쉽습니다. 많은 편집기 (Visual Studio Code 포함)는 입력 할 때 마크 다운을 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f0d79ae62e9049fa1e61d4f8b8e8288b7d10547" translate="yes" xml:space="preserve">
          <source>Marker interface for a value that's safe to use as HTML.</source>
          <target state="translated">HTML로 안전하게 사용할 수있는 마커 인터페이스.</target>
        </trans-unit>
        <trans-unit id="44077f17738066476a04b77cb7234d0debe282d2" translate="yes" xml:space="preserve">
          <source>Marker interface for a value that's safe to use as JavaScript.</source>
          <target state="translated">JavaScript로 사용하기에 안전한 값에 대한 마커 인터페이스.</target>
        </trans-unit>
        <trans-unit id="be2b798ee79aee95e8ba7f58d4db583d7d3cc18f" translate="yes" xml:space="preserve">
          <source>Marker interface for a value that's safe to use as a URL linking to a document.</source>
          <target state="translated">문서에 대한 URL 링크로 사용하기에 안전한 값에 대한 마커 인터페이스.</target>
        </trans-unit>
        <trans-unit id="32be8ca4a80edc7adb498046a934af4df142acf7" translate="yes" xml:space="preserve">
          <source>Marker interface for a value that's safe to use as a URL to load executable code from.</source>
          <target state="translated">실행 코드를로드하기위한 URL로 사용하기에 안전한 값에 대한 마커 인터페이스.</target>
        </trans-unit>
        <trans-unit id="190d929880596b3b2b1cb9976fcf09cbb71177c2" translate="yes" xml:space="preserve">
          <source>Marker interface for a value that's safe to use as style (CSS).</source>
          <target state="translated">스타일 (CSS)로 사용하기에 안전한 값에 대한 마커 인터페이스.</target>
        </trans-unit>
        <trans-unit id="00fae9ebcd6da81c3826a15ac752fd939ce5eb00" translate="yes" xml:space="preserve">
          <source>Marker interface for a value that's safe to use in a particular context.</source>
          <target state="translated">특정 상황에서 안전하게 사용할 수있는 마커 인터페이스.</target>
        </trans-unit>
        <trans-unit id="6a05dc2a519c44472e752aa78b302e55c00ce787" translate="yes" xml:space="preserve">
          <source>Marking a class as a pipe</source>
          <target state="translated">클래스를 파이프로 표시</target>
        </trans-unit>
        <trans-unit id="7047a10aa10b4d12f4e613cf4dfce9686986f075" translate="yes" xml:space="preserve">
          <source>Marking a class with &lt;code&gt;@&lt;a href=&quot;injectable&quot;&gt;Injectable&lt;/a&gt;&lt;/code&gt; ensures that the compiler will generate the necessary metadata to create the class's dependencies when the class is injected.</source>
          <target state="translated">클래스를 &lt;code&gt;@&lt;a href=&quot;injectable&quot;&gt;Injectable&lt;/a&gt;&lt;/code&gt; 표시하면 클래스를 삽입 할 때 컴파일러가 클래스의 종속성을 생성하는 데 필요한 메타 데이터를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a51bf3c267b34206e81fa68deca3d45075eeee05" translate="yes" xml:space="preserve">
          <source>Marks &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; as dynamic, so Angular can be notified when options change.</source>
          <target state="translated">마크 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 각도이 때 옵션 변경을 통지 할 수 있도록 동적으로.</target>
        </trans-unit>
        <trans-unit id="2fe6e8ea72c51d996b881fe03b42ca3c8b2e44fc" translate="yes" xml:space="preserve">
          <source>Marks a component for check (in case of OnPush components) and synchronously performs change detection on the application this component belongs to.</source>
          <target state="translated">검사 할 구성 요소를 표시하고 (OnPush 구성 요소의 경우)이 구성 요소가 속한 응용 프로그램에서 변경 감지를 동 기적으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="3dc949f2a0597e37dc5b503716ae5f0e2f4b5974" translate="yes" xml:space="preserve">
          <source>Marks a percent format. The % symbol may change position, but must be retained.</source>
          <target state="translated">퍼센트 형식을 표시합니다. % 기호는 위치를 변경할 수 있지만 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ffc0d3065eb521574c575da104ec2bcd56a74fb" translate="yes" xml:space="preserve">
          <source>Marks a scientific format. The E symbol may change position, but must be retained.</source>
          <target state="translated">과학적인 형식을 표시합니다. E 기호는 위치를 변경할 수 있지만 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d02022cd7fdf010c85cd457ac4036958d4745ee" translate="yes" xml:space="preserve">
          <source>Marks a style as important.</source>
          <target state="translated">스타일을 중요한 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="b2b2ab983e8070eed76188fa87beffd689c5582e" translate="yes" xml:space="preserve">
          <source>Marks a style as using dash case naming (this-is-dash-case).</source>
          <target state="translated">대시 케이스 이름 지정 (this-is-dash-case)을 사용하여 스타일을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="90c3dbaa648c20c8ae2b5d0ba25e4a55271d3fe3" translate="yes" xml:space="preserve">
          <source>Marks the control and all its descendant controls as &lt;code&gt;touched&lt;/code&gt;.</source>
          <target state="translated">컨트롤과 모든 하위 컨트롤을 &lt;code&gt;touched&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8f1de67b463040e84913b0550b5655cbe8552c2c" translate="yes" xml:space="preserve">
          <source>Marks the control as &lt;code&gt;dirty&lt;/code&gt;. A control becomes dirty when the control's value is changed through the UI; compare &lt;code&gt;markAsTouched&lt;/code&gt;.</source>
          <target state="translated">컨트롤을 &lt;code&gt;dirty&lt;/code&gt; 로 표시합니다 . 컨트롤 값이 UI를 통해 변경되면 컨트롤이 더러워집니다. &lt;code&gt;markAsTouched&lt;/code&gt; 를 비교 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d03d77a3f8d7fddaddf5702243ae9f9ddd1ef1a5" translate="yes" xml:space="preserve">
          <source>Marks the control as &lt;code&gt;pending&lt;/code&gt;.</source>
          <target state="translated">컨트롤을 &lt;code&gt;pending&lt;/code&gt; 중으로 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="b79edb0843b4f3787d92ef573b73fc0dd74f0a69" translate="yes" xml:space="preserve">
          <source>Marks the control as &lt;code&gt;pristine&lt;/code&gt;.</source>
          <target state="translated">컨트롤을 &lt;code&gt;pristine&lt;/code&gt; 으로 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="552c55c7009312a2c5dbdf86a2db78335f5bd874" translate="yes" xml:space="preserve">
          <source>Marks the control as &lt;code&gt;touched&lt;/code&gt;. A control is touched by focus and blur events that do not change the value.</source>
          <target state="translated">컨트롤을 &lt;code&gt;touched&lt;/code&gt; 것으로 표시합니다 . 값을 변경하지 않는 초점 및 흐림 이벤트로 컨트롤을 터치합니다.</target>
        </trans-unit>
        <trans-unit id="5524b15df7708a4abd2f3007a9d0154920e67189" translate="yes" xml:space="preserve">
          <source>Marks the control as &lt;code&gt;untouched&lt;/code&gt;.</source>
          <target state="translated">컨트롤을 &lt;code&gt;untouched&lt;/code&gt; 것으로 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="6fcdec153eea4e2ac1e84b45e481c3d80f5b6baf" translate="yes" xml:space="preserve">
          <source>Marks the location to load the component of the active route.</source>
          <target state="translated">활성 경로의 구성 요소를로드 할 위치를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a41c002f76c3ddbf33397cf9ff9ed88bed7302f6" translate="yes" xml:space="preserve">
          <source>Master/Detail</source>
          <target state="translated">Master/Detail</target>
        </trans-unit>
        <trans-unit id="304698ef1300bc95aac9c2ab2903870bbadeafe7" translate="yes" xml:space="preserve">
          <source>Master/Detail Components</source>
          <target state="translated">마스터 / 세부 구성 요소</target>
        </trans-unit>
        <trans-unit id="33b81af9fbc2d9c1087f3875a223180927975556" translate="yes" xml:space="preserve">
          <source>Match all nodes.</source>
          <target state="translated">모든 노드를 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="862bd048c883526c17675c397beda22c96b40900" translate="yes" xml:space="preserve">
          <source>Match elements by the given CSS selector.</source>
          <target state="translated">주어진 CSS 선택기로 요소를 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="de7cd1fb52ce1262b94846eb2616193d9955bd7d" translate="yes" xml:space="preserve">
          <source>Match nodes that have the given directive present.</source>
          <target state="translated">주어진 지시어가있는 노드를 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="13373cb22c6ad40bbf34a683cdf6768383178147" translate="yes" xml:space="preserve">
          <source>Matching Strategy</source>
          <target state="translated">매칭 전략</target>
        </trans-unit>
        <trans-unit id="2165a9c034ed5b6a48ce499a7a677bec7360624c" translate="yes" xml:space="preserve">
          <source>Matching navigation request URLs</source>
          <target state="translated">일치하는 탐색 요청 URL</target>
        </trans-unit>
        <trans-unit id="dbb284068a8e79111daf2b152754d63af5c2bdfc" translate="yes" xml:space="preserve">
          <source>Material Design - Accessibility</source>
          <target state="translated">머티리얼 디자인-접근성</target>
        </trans-unit>
        <trans-unit id="b5365c874d26dca075a365f0f759a05ea283867f" translate="yes" xml:space="preserve">
          <source>Matrix URL notation is an idea first introduced in a &lt;a href=&quot;http://www.w3.org/DesignIssues/MatrixURIs.html&quot;&gt;1996 proposal&lt;/a&gt; by the founder of the web, Tim Berners-Lee.</source>
          <target state="translated">매트릭스 URL 표기법은 &lt;a href=&quot;http://www.w3.org/DesignIssues/MatrixURIs.html&quot;&gt;1996 년&lt;/a&gt; 웹 창시자 인 Tim Berners-Lee가 제안한 아이디어 입니다.</target>
        </trans-unit>
        <trans-unit id="eebcfe68b13f2eef1c168ebd6457a7409a797cfb" translate="yes" xml:space="preserve">
          <source>Matrix URL notation is an idea first introduced in a &lt;a href=&quot;https://www.w3.org/DesignIssues/MatrixURIs.html&quot;&gt;1996 proposal&lt;/a&gt; by the founder of the web, Tim Berners-Lee.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df12f07bc0e225d9c61b2b656a300cdd45f507df" translate="yes" xml:space="preserve">
          <source>MaxLengthValidator</source>
          <target state="translated">MaxLengthValidator</target>
        </trans-unit>
        <trans-unit id="473e3e4d9bb69399b43203fb2abd81e292e9e263" translate="yes" xml:space="preserve">
          <source>May 2020</source>
          <target state="translated">2020 년 5 월</target>
        </trans-unit>
        <trans-unit id="45162abb05f5b85bc23b63651e7596aec882297e" translate="yes" xml:space="preserve">
          <source>May 28, 2019</source>
          <target state="translated">2019 년 5 월 28 일</target>
        </trans-unit>
        <trans-unit id="075977785e25f435a3132423b18227a4f5235ed3" translate="yes" xml:space="preserve">
          <source>May 3, 2018</source>
          <target state="translated">2018 년 5 월 3 일</target>
        </trans-unit>
        <trans-unit id="36961ecd57a84b27841f0a2a11c493049b963beb" translate="yes" xml:space="preserve">
          <source>May be removed in</source>
          <target state="translated">에서 제거 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="56ffd7dc3d16ef45b28d718b5c2cfa58db3cb7c9" translate="yes" xml:space="preserve">
          <source>Maybe the user must login (&lt;em&gt;authenticate&lt;/em&gt;) first.</source>
          <target state="translated">사용자가 먼저 로그인 ( &lt;em&gt;authentication&lt;/em&gt; ) 해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5c559c0346182a324a6362c749c4b9869c4418c" translate="yes" xml:space="preserve">
          <source>Maybe the user must login (authenticate) first.</source>
          <target state="translated">사용자는 먼저 로그인 (인증)해야합니다.</target>
        </trans-unit>
        <trans-unit id="4d735c27534318526d192c543b4e9405990246b9" translate="yes" xml:space="preserve">
          <source>Maybe you should fetch some data before you display the target component.</source>
          <target state="translated">대상 구성 요소를 표시하기 전에 일부 데이터를 가져와야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="ecba223c35670a6e86840d57758c584dece4e5bd" translate="yes" xml:space="preserve">
          <source>Meanwhile, the &lt;code&gt;ng test&lt;/code&gt; command is watching for changes.</source>
          <target state="translated">한편 &lt;code&gt;ng test&lt;/code&gt; 명령은 변경 사항을 감시하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a97e11deff98f07fcbcf99a459c11a3c3e7b23bd" translate="yes" xml:space="preserve">
          <source>Measure performance</source>
          <target state="translated">성능 측정</target>
        </trans-unit>
        <trans-unit id="6853c98a6f4358bbfed1b3b9c81d308649299b0f" translate="yes" xml:space="preserve">
          <source>Member</source>
          <target state="translated">Member</target>
        </trans-unit>
        <trans-unit id="562b14416156af926fbe5520e33d1259d2d35346" translate="yes" xml:space="preserve">
          <source>Member sequence</source>
          <target state="translated">멤버 순서</target>
        </trans-unit>
        <trans-unit id="1cb449c1126609b4b41e1d87f65f0d7cd19b49b9" translate="yes" xml:space="preserve">
          <source>Members</source>
          <target state="translated">Members</target>
        </trans-unit>
        <trans-unit id="9b3d1dc4ad715fe4de1ae0b9194d4370157ddaf0" translate="yes" xml:space="preserve">
          <source>Mental Model</source>
          <target state="translated">정신 모델</target>
        </trans-unit>
        <trans-unit id="10da0871d51e1e7527c73418f0b5e05f8c658d03" translate="yes" xml:space="preserve">
          <source>Merge the completed translation file into the app</source>
          <target state="translated">완성 된 번역 파일을 앱에 병합</target>
        </trans-unit>
        <trans-unit id="2a609a2760470dc00f6136d3cd668b933ca52d9c" translate="yes" xml:space="preserve">
          <source>Merge the completed translation file into the app. To do this, use the Angular CLI &lt;code&gt;build&lt;/code&gt; command to compile the app, choosing a &lt;a href=&quot;i18n#merge-aot&quot;&gt;locale-specific configuration&lt;/a&gt;, or specifying the following command options.</source>
          <target state="translated">완성 된 번역 파일을 앱에 병합하십시오. 이렇게하려면 Angular CLI &lt;code&gt;build&lt;/code&gt; 명령을 사용하여 앱을 컴파일 하거나 &lt;a href=&quot;i18n#merge-aot&quot;&gt;로캘 별 구성을&lt;/a&gt; 선택 하거나 다음 명령 옵션을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="129ddbedd83424c874d63227a8273ce0ffab60af" translate="yes" xml:space="preserve">
          <source>Merge translations into the app</source>
          <target state="translated">번역을 앱에 병합</target>
        </trans-unit>
        <trans-unit id="07aad0adaeb1b9587492cfc8d874f6329f6f3303" translate="yes" xml:space="preserve">
          <source>Merge with the AOT compiler</source>
          <target state="translated">AOT 컴파일러와 병합</target>
        </trans-unit>
        <trans-unit id="c7298c2c9e49a103b04a2845d24a7349008b9ace" translate="yes" xml:space="preserve">
          <source>Merge with the JIT compiler</source>
          <target state="translated">JIT 컴파일러와 병합</target>
        </trans-unit>
        <trans-unit id="14b78ed779ba1eb639111b5d329607a36c3d898a" translate="yes" xml:space="preserve">
          <source>Merges the URL fragment with the rest of the URL.</source>
          <target state="translated">URL 조각을 나머지 URL과 병합합니다.</target>
        </trans-unit>
        <trans-unit id="78fe5ba55408c7f7dd7e147b86f12ef53c069049" translate="yes" xml:space="preserve">
          <source>Message Bus is a low level API used to communicate between the UI and the background. Communication is based on a channel abstraction. Messages published in a given channel to one MessageBusSink are received on the same channel by the corresponding MessageBusSource.</source>
          <target state="translated">Message Bus는 UI와 백그라운드 간 통신에 사용되는 저수준 API입니다. 통신은 채널 추상화를 기반으로합니다. 특정 채널에서 하나의 MessageBusSink에 게시 된 메시지는 해당 MessageBusSource에 의해 동일한 채널에서 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="2dab758b8876c8b70aca537b47bed380873c05c0" translate="yes" xml:space="preserve">
          <source>MessageBus</source>
          <target state="translated">MessageBus</target>
        </trans-unit>
        <trans-unit id="377ba52cb68adfe51dfa40983b46202e3d247f62" translate="yes" xml:space="preserve">
          <source>MessageBusSink</source>
          <target state="translated">MessageBusSink</target>
        </trans-unit>
        <trans-unit id="7b95de765223d1ee58a9bfdab4c83e74e091ea77" translate="yes" xml:space="preserve">
          <source>MessageBusSource</source>
          <target state="translated">MessageBusSource</target>
        </trans-unit>
        <trans-unit id="8d546a6dea9ff90d517b51c25b35319931ae4e04" translate="yes" xml:space="preserve">
          <source>Meta</source>
          <target state="translated">Meta</target>
        </trans-unit>
        <trans-unit id="f2c1a4c9748a88a08eaf983137499ccf3d4c7989" translate="yes" xml:space="preserve">
          <source>MetaDefinition</source>
          <target state="translated">MetaDefinition</target>
        </trans-unit>
        <trans-unit id="6ccc5b519461c9c2782b08d2d5a7e8da0ba54fee" translate="yes" xml:space="preserve">
          <source>Metadata referenced a class that wasn't exported.</source>
          <target state="translated">메타 데이터가 내 보내지 않은 클래스를 참조했습니다.</target>
        </trans-unit>
        <trans-unit id="8cad26c08ab5ecd7a9c21bb39395f684cfb8ecb3" translate="yes" xml:space="preserve">
          <source>Metadata restrictions</source>
          <target state="translated">메타 데이터 제한</target>
        </trans-unit>
        <trans-unit id="ab3b4516f2c1a87d9dfae0c84ef113acfc85f0cf" translate="yes" xml:space="preserve">
          <source>Metadata rewriting</source>
          <target state="translated">메타 데이터 재 작성</target>
        </trans-unit>
        <trans-unit id="2547750cd9950647e35dcc7fa8dcb5fb52010b6b" translate="yes" xml:space="preserve">
          <source>MetadataOverride</source>
          <target state="translated">MetadataOverride</target>
        </trans-unit>
        <trans-unit id="480e00bb1250ab6146f449570c842c7c7cab2c7a" translate="yes" xml:space="preserve">
          <source>Method called when the &quot;reset&quot; event is triggered on the form.</source>
          <target state="translated">&quot;재설정&quot;이벤트가 양식에서 트리거 될 때 호출되는 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="132133a9bf0ca23e222be0882410cbfec7ff46ae" translate="yes" xml:space="preserve">
          <source>Method called when the &quot;submit&quot; event is triggered on the form. Triggers the &lt;code&gt;ngSubmit&lt;/code&gt; emitter to emit the &quot;submit&quot; event as its payload.</source>
          <target state="translated">&quot;제출&quot;이벤트가 양식에서 트리거 될 때 호출되는 메소드입니다. &lt;code&gt;ngSubmit&lt;/code&gt; 이미 터를 트리거하여 &quot;submit&quot;이벤트를 페이로드로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="77eedcf2b5cf5aca17dce41ae4f2edaf94a576d1" translate="yes" xml:space="preserve">
          <source>Method called with the &quot;submit&quot; event is triggered on the form. Triggers the &lt;code&gt;ngSubmit&lt;/code&gt; emitter to emit the &quot;submit&quot; event as its payload.</source>
          <target state="translated">&quot;submit&quot;이벤트와 함께 호출 된 메소드가 양식에서 트리거됩니다. &lt;code&gt;ngSubmit&lt;/code&gt; 이미 터를 트리거하여 &quot;submit&quot;이벤트를 페이로드로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="92616c3b3e965ff16f8bd06a8dfb39101a4fc463" translate="yes" xml:space="preserve">
          <source>Method that performs async validation against the provided control.</source>
          <target state="translated">제공된 컨트롤에 대해 비동기 유효성 검사를 수행하는 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="c19dc7e253af2ee1407e8d9064b68d932b344563" translate="yes" xml:space="preserve">
          <source>Method that performs synchronous validation against the provided control.</source>
          <target state="translated">제공된 제어에 대해 동기 유효성 검증을 수행하는 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="90b5e6212c0847c1da847315da7a0359b0afb290" translate="yes" xml:space="preserve">
          <source>Method that sets up the control directive in this group, re-calculates its value and validity, and adds the instance to the internal list of directives.</source>
          <target state="translated">이 그룹에서 제어 지시문을 설정하고 해당 값과 유효성을 다시 계산하고 인스턴스를 내부 지시문 목록에 추가하는 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="098addd3604051290701c4c812f2f17a5ed71cb0" translate="yes" xml:space="preserve">
          <source>Method that validates whether an email address is valid. Returns the validation result if enabled, otherwise null.</source>
          <target state="translated">이메일 주소가 유효한지 확인하는 방법입니다. 활성화 된 경우 유효성 검사 결과를 반환하고, 그렇지 않으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="c85869ac84887bcd71ff90a6fb9ca514cb7dcdaa" translate="yes" xml:space="preserve">
          <source>Method that validates whether or not the checkbox has been checked. Returns the validation result if enabled, otherwise null.</source>
          <target state="translated">확인란이 선택되어 있는지 확인하는 방법입니다. 활성화 된 경우 유효성 검사 결과를 반환하고, 그렇지 않으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="48f36a75a0315ffb51df39974f381e0a30e8148a" translate="yes" xml:space="preserve">
          <source>Method that validates whether the control is empty. Returns the validation result if enabled, otherwise null.</source>
          <target state="translated">컨트롤이 비어 있는지 확인하는 메서드입니다. 활성화 된 경우 유효성 검사 결과를 반환하고, 그렇지 않으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="e96a9ab385eda11dceec9653619ee92018e6cfe4" translate="yes" xml:space="preserve">
          <source>Method that validates whether the value exceeds the maximum length requirement.</source>
          <target state="translated">값이 최대 길이 요구 사항을 초과하는지 검증하는 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="864cb6a938903c3d56892f757005022941bcbaeb" translate="yes" xml:space="preserve">
          <source>Method that validates whether the value matches the the pattern requirement.</source>
          <target state="translated">값이 패턴 요구 사항과 일치하는지 검증하는 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="ea2d5bd9900eebf7f3fa6babe94a92b45aa3c20f" translate="yes" xml:space="preserve">
          <source>Method that validates whether the value meets a minimum length requirement. Returns the validation result if enabled, otherwise null.</source>
          <target state="translated">값이 최소 길이 요구 사항을 충족하는지 확인하는 방법입니다. 활성화 된 경우 유효성 검사 결과를 반환하고, 그렇지 않으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="524524cbb5b4b2229234a47887f5e9c638264059" translate="yes" xml:space="preserve">
          <source>Microsyntax</source>
          <target state="translated">Microsyntax</target>
        </trans-unit>
        <trans-unit id="84f2b1f0407883abc0db1634152996a1cb6aa51a" translate="yes" xml:space="preserve">
          <source>Microsyntax examples</source>
          <target state="translated">마이크로 구문 예</target>
        </trans-unit>
        <trans-unit id="2f237d0f44a4dbb3f810838d2ac6ea080d483864" translate="yes" xml:space="preserve">
          <source>Microsyntax must meet the following requirements:</source>
          <target state="translated">마이크로 구문은 다음 요구 사항을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce722bab1d29b667c5659a8d93babb0ee7cd6bf0" translate="yes" xml:space="preserve">
          <source>Migrating URLs with Redirects</source>
          <target state="translated">리디렉션을 사용하여 URL 마이그레이션</target>
        </trans-unit>
        <trans-unit id="aeb45a16f12ec2c52f38015aa44aadc63e9bc613" translate="yes" xml:space="preserve">
          <source>Migrating URLs with redirects</source>
          <target state="translated">리디렉션을 사용하여 URL 마이그레이션</target>
        </trans-unit>
        <trans-unit id="8b1f7baec0a8d71c3b7eb7e093d50dc32a658e5e" translate="yes" xml:space="preserve">
          <source>Migrating from deprecated ngForm selector</source>
          <target state="translated">더 이상 사용되지 않는 ngForm 선택기에서 마이그레이션</target>
        </trans-unit>
        <trans-unit id="2cf1ac4c5fad3f46f8cde9c888e9614c3f4b4d74" translate="yes" xml:space="preserve">
          <source>Migrating to TypeScript</source>
          <target state="translated">TypeScript로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="ddfc337decc856bf371a7d236708d6e95816f0b7" translate="yes" xml:space="preserve">
          <source>Milestone 1 has covered how to do the following:</source>
          <target state="translated">마일스톤 1은 다음을 수행하는 방법을 다루었습니다.</target>
        </trans-unit>
        <trans-unit id="88bcc4bc41e55700cf470829a5d9a4e6a4c6346c" translate="yes" xml:space="preserve">
          <source>Milestone 1 wrap up</source>
          <target state="translated">마일스톤 1 마무리</target>
        </trans-unit>
        <trans-unit id="84d1190e29283bf0f4ad613b2113c7efd5959343" translate="yes" xml:space="preserve">
          <source>Milestone 1: Getting started</source>
          <target state="translated">이정표 1 : 시작하기</target>
        </trans-unit>
        <trans-unit id="1fe4150b974da173f97716c525126ab3b909f127" translate="yes" xml:space="preserve">
          <source>Milestone 2: &lt;code&gt;Routing module&lt;/code&gt;</source>
          <target state="translated">이정표 2 : &lt;code&gt;Routing module&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2c337c88510afb27e2a36ed64161e29051dcc17e" translate="yes" xml:space="preserve">
          <source>Milestone 3 wrap up</source>
          <target state="translated">이정표 3 마무리</target>
        </trans-unit>
        <trans-unit id="9e7f5537b3a1147a578fd90233e37be8a9162e9e" translate="yes" xml:space="preserve">
          <source>Milestone 3: Heroes feature</source>
          <target state="translated">이정표 3 : 영웅 기능</target>
        </trans-unit>
        <trans-unit id="a8ed87e79aacfd84ef3a400ffedede75156338d8" translate="yes" xml:space="preserve">
          <source>Milestone 4: Crisis center feature</source>
          <target state="translated">이정표 4 : 위기 센터 기능</target>
        </trans-unit>
        <trans-unit id="a5c25699c061c8160f7fc2ce1003ec7d13aa30f9" translate="yes" xml:space="preserve">
          <source>Milestone 5: Route guards</source>
          <target state="translated">이정표 5 : 루트 가드</target>
        </trans-unit>
        <trans-unit id="0f50f36dae7e1d4742bb457f84c0fef8eba58343" translate="yes" xml:space="preserve">
          <source>Milestone 6: Asynchronous routing</source>
          <target state="translated">이정표 6 : 비동기 라우팅</target>
        </trans-unit>
        <trans-unit id="f751d8d1afda5d9262251ac57eecbfcb1f899a51" translate="yes" xml:space="preserve">
          <source>MinLengthValidator</source>
          <target state="translated">MinLengthValidator</target>
        </trans-unit>
        <trans-unit id="fb46992893d351666c27b0a415b676a77c7ee574" translate="yes" xml:space="preserve">
          <source>Minification: removes excess whitespace, comments, and optional tokens.</source>
          <target state="translated">축소 : 과도한 공백, 주석 및 선택적 토큰을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="c1335d3e7a03c5a9cce93a720fba00fd5265fb99" translate="yes" xml:space="preserve">
          <source>Minute</source>
          <target state="translated">Minute</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="16fa591982d3b4278712ac09b90a4922db040308" translate="yes" xml:space="preserve">
          <source>Misko Hevery, Angular team lead, &lt;a href=&quot;http://misko.hevery.com/code-reviewers-guide/flaw-constructor-does-real-work/&quot;&gt;explains why&lt;/a&gt; you should avoid complex constructor logic.</source>
          <target state="translated">Angular 팀 리더 인 Misko Hevery 는 복잡한 생성자 논리를 피해야하는 &lt;a href=&quot;http://misko.hevery.com/code-reviewers-guide/flaw-constructor-does-real-work/&quot;&gt;이유&lt;/a&gt; 를 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="703b52e4c78301393192ea76eb4bc94c5b907bc0" translate="yes" xml:space="preserve">
          <source>MissingTranslationStrategy</source>
          <target state="translated">MissingTranslationStrategy</target>
        </trans-unit>
        <trans-unit id="de77f58be307fbadb3d77dd95b849dc214ccfab0" translate="yes" xml:space="preserve">
          <source>Mock implementation of URL state.</source>
          <target state="translated">URL 상태의 모의 구현.</target>
        </trans-unit>
        <trans-unit id="07d5c4c262b2b0b021359260309ee66c01a76480" translate="yes" xml:space="preserve">
          <source>Mock platform location config</source>
          <target state="translated">모의 플랫폼 위치 구성</target>
        </trans-unit>
        <trans-unit id="eb83e91107904331a02f5abe4036d95facce7db3" translate="yes" xml:space="preserve">
          <source>MockAnimationDriver</source>
          <target state="translated">MockAnimationDriver</target>
        </trans-unit>
        <trans-unit id="335ab995be87b2b6bd940e1d03e2b34a7e3eeaa4" translate="yes" xml:space="preserve">
          <source>MockAnimationPlayer</source>
          <target state="translated">MockAnimationPlayer</target>
        </trans-unit>
        <trans-unit id="f7a2983b9bb4694e0f876db78913b39727db220a" translate="yes" xml:space="preserve">
          <source>MockLocationStrategy</source>
          <target state="translated">MockLocationStrategy</target>
        </trans-unit>
        <trans-unit id="0b9824686806e7bfae181b4737b528bde308f05f" translate="yes" xml:space="preserve">
          <source>MockPlatformLocation</source>
          <target state="translated">MockPlatformLocation</target>
        </trans-unit>
        <trans-unit id="4cbc2d522fcb43d224fa5c6b76ce39ee982868b4" translate="yes" xml:space="preserve">
          <source>MockPlatformLocationConfig</source>
          <target state="translated">MockPlatformLocationConfig</target>
        </trans-unit>
        <trans-unit id="ebd0f455b81fff65b45f1c47d58ddc0faf0798f3" translate="yes" xml:space="preserve">
          <source>Mocking the &lt;code&gt;HeroService&lt;/code&gt; with a spy is a &lt;a href=&quot;testing#component-with-async-service&quot;&gt;familiar story&lt;/a&gt;. But the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; has a complicated API and is entwined with other services and application preconditions. Might it be difficult to mock?</source>
          <target state="translated">스파이로 &lt;code&gt;HeroService&lt;/code&gt; 를 조롱하는 것은 &lt;a href=&quot;testing#component-with-async-service&quot;&gt;친숙한 이야기&lt;/a&gt; 입니다. 그러나 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 에는 복잡한 API가 있으며 다른 서비스 및 응용 프로그램 전제 조건과 짝을 이룹니다. 조롱하기 어려울 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="b6b43d9ab5307d7768026ad28d924057ec419a59" translate="yes" xml:space="preserve">
          <source>Mocking the &lt;code&gt;HeroService&lt;/code&gt; with a spy is a &lt;a href=&quot;testing-components-scenarios#component-with-async-service&quot;&gt;familiar story&lt;/a&gt;. But the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; has a complicated API and is entwined with other services and application preconditions. Might it be difficult to mock?</source>
          <target state="translated">스파이로 &lt;code&gt;HeroService&lt;/code&gt; 를 조롱하는 것은 &lt;a href=&quot;testing-components-scenarios#component-with-async-service&quot;&gt;익숙한 이야기&lt;/a&gt; 입니다. 그러나 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 에는 복잡한 API가 있으며 다른 서비스 및 응용 프로그램 전제 조건과 얽혀 있습니다. 조롱하기 어려울까요?</target>
        </trans-unit>
        <trans-unit id="23bbdbe479db228f7aba0b175aac34547f4314d3" translate="yes" xml:space="preserve">
          <source>Modern HTML5 browsers support &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries&quot;&gt;history.pushState&lt;/a&gt;, a technique that changes a browser's location and history without triggering a server page request. The router can compose a &quot;natural&quot; URL that is indistinguishable from one that would otherwise require a page load.</source>
          <target state="translated">최신 HTML5 브라우저 는 서버 페이지 요청을 트리거하지 않고 브라우저의 위치와 기록을 변경하는 기술인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries&quot;&gt;history.pushState를&lt;/a&gt; 지원 합니다. 라우터는 페이지로드가 필요한 URL과 구별 할 수없는 &quot;자연&quot;URL을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58be99d59597df4a8a4a0fb43095939149b83985" translate="yes" xml:space="preserve">
          <source>Modern HTML5 browsers were the first to support &lt;code&gt;pushState&lt;/code&gt; which is why many people refer to these URLs as &quot;HTML5 style&quot; URLs.</source>
          <target state="translated">최신 HTML5 브라우저는 &lt;code&gt;pushState&lt;/code&gt; 를 지원하는 최초의 제품 이므로 많은 사람들이이 URL을 &quot;HTML5 스타일&quot;URL이라고합니다.</target>
        </trans-unit>
        <trans-unit id="62a79cf9eb3526462da701324a57835b820a4001" translate="yes" xml:space="preserve">
          <source>Modifies an existing &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; tag element in the current HTML document.</source>
          <target state="translated">현재 HTML 문서에서 기존 &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; 태그 요소를 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="80a9b9104684e0b295509cc06f13b718760c5caf" translate="yes" xml:space="preserve">
          <source>Modifies how Angular-specific annotations are emitted to improve tree-shaking. Non-Angular annotations are not affected. One of &lt;code&gt;&lt;a href=&quot;../api/upgrade/static&quot;&gt;static&lt;/a&gt; fields&lt;/code&gt; (the default) or &lt;code&gt;decorators&lt;/code&gt;.</source>
          <target state="translated">트리 쉐이킹을 개선하기 위해 각도 별 주석이 생성되는 방식을 수정합니다. 비 앵글 주석은 영향을받지 않습니다. &lt;code&gt;&lt;a href=&quot;../api/upgrade/static&quot;&gt;static&lt;/a&gt; fields&lt;/code&gt; (기본값) 또는 &lt;code&gt;decorators&lt;/code&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="cc7ff7ee06a62fc36531c86475e22a93d4a1e0a6" translate="yes" xml:space="preserve">
          <source>Modify the &lt;code&gt;AppComponent&lt;/code&gt; template to display the generated &lt;code&gt;MessagesComponent&lt;/code&gt;.</source>
          <target state="translated">생성 된 &lt;code&gt;MessagesComponent&lt;/code&gt; 를 표시 하도록 &lt;code&gt;AppComponent&lt;/code&gt; 템플리트를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="0ef4a7efa3f16c8f795941775e6a66532831c3a3" translate="yes" xml:space="preserve">
          <source>Modify the &lt;code&gt;getHeroes()&lt;/code&gt; method to send a message when the heroes are fetched.</source>
          <target state="translated">영웅을 가져올 때 메시지를 보내도록 &lt;code&gt;getHeroes()&lt;/code&gt; 메소드를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="10c13dcc0265e5906cfc4a542b66b25f6d62212e" translate="yes" xml:space="preserve">
          <source>Modify the &lt;code&gt;hero.name&lt;/code&gt; binding like this.</source>
          <target state="translated">다음 과 같이 &lt;code&gt;hero.name&lt;/code&gt; 바인딩을 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="5eeba3514c27591094b26ccc5837d1b62e194be9" translate="yes" xml:space="preserve">
          <source>Modify the birthday template to give the date pipe a format parameter. After formatting the hero's April 15th birthday, it renders as &lt;strong&gt;&lt;samp&gt;04/15/88&lt;/samp&gt;&lt;/strong&gt;:</source>
          <target state="translated">날짜 파이프에 형식 매개 변수를 제공하도록 생일 템플리트를 수정하십시오. 영웅의 4 월 15 일 생일을 형식화하면 다음과 같이 렌더링됩니다.&lt;strong&gt;&lt;samp&gt;04/15/88&lt;/samp&gt;&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="e3a6a2ab557de6edc89b72b34323f3607bac9938" translate="yes" xml:space="preserve">
          <source>Modify the constructor with a parameter that declares a &lt;strong&gt;public&lt;/strong&gt;&lt;code&gt;messageService&lt;/code&gt; property. Angular will inject the singleton &lt;code&gt;MessageService&lt;/code&gt; into that property when it creates the &lt;code&gt;MessagesComponent&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;공용 &lt;/strong&gt; &lt;code&gt;messageService&lt;/code&gt; 특성 을 선언하는 매개 변수로 생성자를 수정하십시오 . Angular는 &lt;code&gt;MessagesComponent&lt;/code&gt; 를 만들 때 싱글 톤 &lt;code&gt;MessageService&lt;/code&gt; 를 해당 속성에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="8db4b324dab2ee65b6c8b4f66ee5197f73664826" translate="yes" xml:space="preserve">
          <source>Modify the constructor with a parameter that declares a private &lt;code&gt;messageService&lt;/code&gt; property. Angular will inject the singleton &lt;code&gt;MessageService&lt;/code&gt; into that property when it creates the &lt;code&gt;HeroService&lt;/code&gt;.</source>
          <target state="translated">개인 &lt;code&gt;messageService&lt;/code&gt; 특성 을 선언하는 매개 변수로 생성자를 수정하십시오 . Angular는 &lt;code&gt;HeroService&lt;/code&gt; 를 만들 때 싱글 톤 &lt;code&gt;MessageService&lt;/code&gt; 를 해당 속성에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="46335c03984eaea4bfc49a97cc9e4e862ba5c9c5" translate="yes" xml:space="preserve">
          <source>Modify the product list template to display a list of product names.</source>
          <target state="translated">제품 목록 템플리트를 수정하여 제품 이름 목록을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="9ccdcb96da8448b66bbb23944ef85480f6a81c18" translate="yes" xml:space="preserve">
          <source>Modify the product name anchor to include a &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;routerLink&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;routerLink&lt;/a&gt;&lt;/code&gt; 를 포함하도록 제품 이름 앵커를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="29d676092fd3b82fea0f5f61d949f483413f1596" translate="yes" xml:space="preserve">
          <source>Modify the provider search with &lt;code&gt;@&lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf를&lt;/a&gt; 사용하여 공급자 검색 수정</target>
        </trans-unit>
        <trans-unit id="19ec6ac1f2fe1db0f7776f97f8f25f623c03a54f" translate="yes" xml:space="preserve">
          <source>Modify the shipping component so it uses the cart service to retrieve shipping data via HTTP from the &lt;code&gt;shipping.json&lt;/code&gt; file.</source>
          <target state="translated">운송 서비스 구성 요소가 cart 서비스를 사용하여 &lt;code&gt;shipping.json&lt;/code&gt; 파일 에서 HTTP를 통해 운송 데이터를 검색하도록 수정 하십시오.</target>
        </trans-unit>
        <trans-unit id="1a9a542e558249f145f039b1c6d62f43cfadbc0e" translate="yes" xml:space="preserve">
          <source>Modify the shipping component so that it uses the cart service to retrieve shipping data via HTTP from the &lt;code&gt;shipping.json&lt;/code&gt; file.</source>
          <target state="translated">배송 구성 요소를 수정하여 장바구니 서비스를 사용하여 &lt;code&gt;shipping.json&lt;/code&gt; 파일 에서 HTTP를 통해 배송 데이터를 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="18d054e88b5fc310215348f9f10982b2326fca85" translate="yes" xml:space="preserve">
          <source>Modifying a request body</source>
          <target state="translated">요청 본문 수정</target>
        </trans-unit>
        <trans-unit id="a71e3ca8556ba87e0586d38955b00229cd03b500" translate="yes" xml:space="preserve">
          <source>Modifying service visibility</source>
          <target state="translated">서비스 가시성 수정</target>
        </trans-unit>
        <trans-unit id="ea0138705c92deb3917ddd4c3cff8c92e2fb6233" translate="yes" xml:space="preserve">
          <source>Module classes.</source>
          <target state="translated">모듈 클래스.</target>
        </trans-unit>
        <trans-unit id="90b4684e6dc0668dfecfd0ab1e31ad16716bbeec" translate="yes" xml:space="preserve">
          <source>Module import order</source>
          <target state="translated">모듈 가져 오기 순서</target>
        </trans-unit>
        <trans-unit id="cda57df2a3d077bfd5559abcb122e7349f720de0" translate="yes" xml:space="preserve">
          <source>Module import order matters</source>
          <target state="translated">모듈 수입 주문 문제</target>
        </trans-unit>
        <trans-unit id="5dc38d6fa3dcc4cf39b8db1c475e686f12efe193" translate="yes" xml:space="preserve">
          <source>ModuleA can import ModuleB and also export it, making exports from ModuleB available to an NgModule that imports ModuleA.</source>
          <target state="translated">ModuleA는 ModuleB를 반입하고 반출 할 수 있으므로 ModuleB에서 반출을 수행하여 ModuleA를 반입하는 NgModule로 반출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2945d77f42e28cfe14ba3f93a865d1c129b38216" translate="yes" xml:space="preserve">
          <source>ModuleWithComponentFactories</source>
          <target state="translated">ModuleWithComponentFactories</target>
        </trans-unit>
        <trans-unit id="a2cad372306851e8187272e8705eb7fbae776699" translate="yes" xml:space="preserve">
          <source>ModuleWithProviders</source>
          <target state="translated">ModuleWithProviders</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="cbb52651bba4b11cbbaf37425680365863c9322e" translate="yes" xml:space="preserve">
          <source>Modules are a great way to organize an application and extend it with capabilities from external libraries.</source>
          <target state="translated">모듈은 응용 프로그램을 구성하고 외부 라이브러리의 기능으로 확장 할 수있는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="fe4301f4b2f595077bcee66f968585f08404b7f7" translate="yes" xml:space="preserve">
          <source>Modules can also add services to the application. Such services might be internally developed, like something you'd develop yourself or come from outside sources, such as the Angular router and HTTP client.</source>
          <target state="translated">모듈은 응용 프로그램에 서비스를 추가 할 수도 있습니다. 이러한 서비스는 직접 개발하거나 Angular 라우터 및 HTTP 클라이언트와 같은 외부 소스에서 제공하는 것과 같이 내부적으로 개발 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58965a390855c470aaa4a09ccac9ba69ee7a054e" translate="yes" xml:space="preserve">
          <source>Modules can be loaded eagerly when the application starts or lazy loaded asynchronously by the router.</source>
          <target state="translated">응용 프로그램이 시작되거나 라우터에 의해 비동기식으로로드 될 때 모듈을 열심히로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6947924932f73d216fba7ab79c4b72fea13e156c" translate="yes" xml:space="preserve">
          <source>Modules, components and services are classes that use &lt;em&gt;decorators&lt;/em&gt;. These decorators mark their type and provide metadata that tells Angular how to use them.</source>
          <target state="translated">모듈, 구성 요소 및 서비스는 &lt;em&gt;데코레이터&lt;/em&gt; 를 사용하는 클래스입니다 . 이러한 데코레이터는 유형을 표시하고 Angular에 사용 방법을 알려주는 메타 데이터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f50194953d2e7e6bdd59a4d3ee2aaae0bbda2598" translate="yes" xml:space="preserve">
          <source>Modules/controllers/components</source>
          <target state="translated">Modules/controllers/components</target>
        </trans-unit>
        <trans-unit id="082bc378cd60e17a38d99898b21955299c5b60c8" translate="yes" xml:space="preserve">
          <source>Month</source>
          <target state="translated">Month</target>
        </trans-unit>
        <trans-unit id="a45fef53594d1fcc4e0101683c5b8c0bbfd29322" translate="yes" xml:space="preserve">
          <source>Month standalone</source>
          <target state="translated">독립형 월</target>
        </trans-unit>
        <trans-unit id="285cbfd86d2712f997a553edc043839f80e15a86" translate="yes" xml:space="preserve">
          <source>More about Angular Modules</source>
          <target state="translated">각도 모듈에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="034d5415dd930b4522a1a546a37325fc07716881" translate="yes" xml:space="preserve">
          <source>More async tests</source>
          <target state="translated">더 많은 비동기 테스트</target>
        </trans-unit>
        <trans-unit id="107edeaffa793d17ea2a11dd81321be774d5550e" translate="yes" xml:space="preserve">
          <source>More explicit, created in component class</source>
          <target state="translated">보다 명시적이고 컴포넌트 클래스에서 생성</target>
        </trans-unit>
        <trans-unit id="5dcfdc862ee7250234afbe800300e3bf7c0e983b" translate="yes" xml:space="preserve">
          <source>More generally, &lt;a href=&quot;ngmodule-faq#q-component-or-module&quot;&gt;prefer registering providers in NgModules&lt;/a&gt; to registering in components.</source>
          <target state="translated">보다 일반적으로, 컴포넌트에 등록 &lt;a href=&quot;ngmodule-faq#q-component-or-module&quot;&gt;하는 것&lt;/a&gt; 보다 NgModules 에 제공자 를 등록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="90761839140dd40f1e73ba92c7a7d7f6c3c29ecb" translate="yes" xml:space="preserve">
          <source>More generally, the text between the braces is a &lt;strong&gt;template expression&lt;/strong&gt; that Angular first &lt;strong&gt;evaluates&lt;/strong&gt; and then &lt;strong&gt;converts to a string&lt;/strong&gt;. The following interpolation illustrates the point by adding two numbers:</source>
          <target state="translated">보다 일반적으로 중괄호 사이의 텍스트는 Angular가 먼저 &lt;strong&gt;평가&lt;/strong&gt; 한 다음 &lt;strong&gt;문자열로 변환&lt;/strong&gt; 하는 &lt;strong&gt;템플릿 표현식&lt;/strong&gt; 입니다 . 다음 보간은 두 개의 숫자를 추가하여 요점을 보여줍니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0dc96c8ef021f4088328940e9ac8c5b95f7f898d" translate="yes" xml:space="preserve">
          <source>More info on testing</source>
          <target state="translated">테스트에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="f925f9bea399a4c9a234cd8ef31a89c2955d37e0" translate="yes" xml:space="preserve">
          <source>More information</source>
          <target state="translated">추가 정보</target>
        </trans-unit>
        <trans-unit id="18b69b015ce1bb08b1d7f945b8f4827eea44c52b" translate="yes" xml:space="preserve">
          <source>More often, you don't know when the data has changed, especially in applications that mutate data in many ways, perhaps in application locations far away. A component in such an application usually can't know about those changes. Moreover, it's unwise to distort the component design to accommodate a pipe. Strive to keep the component class independent of the HTML. The component should be unaware of pipes.</source>
          <target state="translated">데이터가 언제 변경되었는지, 특히 멀리 떨어진 응용 프로그램 위치에서 여러 가지 방식으로 데이터를 변경하는 응용 프로그램에서 더 자주 알 수 없습니다. 이러한 응용 프로그램의 구성 요소는 일반적으로 이러한 변경 사항을 알 수 없습니다. 또한 파이프를 수용하기 위해 구성 요소 설계를 왜곡하는 것은 현명하지 않습니다. 컴포넌트 클래스를 HTML과 독립적으로 유지하도록 노력하십시오. 구성 요소는 파이프를 인식하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d928892e47e7260978557dc968c874ed2cfe145a" translate="yes" xml:space="preserve">
          <source>More on Angular animations</source>
          <target state="translated">각도 애니메이션에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="45236483e1db8ccbe6b2bb2a6df4fb11ea1eea26" translate="yes" xml:space="preserve">
          <source>More on Angular modules</source>
          <target state="translated">각도 모듈에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="30355a8434d77ad96fabc7dee39b2cc652238bd9" translate="yes" xml:space="preserve">
          <source>More on Angular service workers</source>
          <target state="translated">앵귤러 서비스 근로자에 ​​대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="81c82a995a55ad69e8128fc7312d961606e7f5f3" translate="yes" xml:space="preserve">
          <source>More on NgModules</source>
          <target state="translated">NgModules에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="449b3f717be4de68542ad59a9f59fd4c409e15e2" translate="yes" xml:space="preserve">
          <source>More on NgModules and routing</source>
          <target state="translated">NgModules 및 라우팅에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="38770c6d961b928928d4e9cb1e204b09def009dc" translate="yes" xml:space="preserve">
          <source>More on accessibility</source>
          <target state="translated">접근성에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="b513ad5d9f2910284480f5def84c8bfd15e9429f" translate="yes" xml:space="preserve">
          <source>More on dependency injection</source>
          <target state="translated">의존성 주입에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="5e4d521276da0becf17bb87ebdac7cb822347ca2" translate="yes" xml:space="preserve">
          <source>More on template syntax</source>
          <target state="translated">템플릿 구문에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="e287def2e221998b4df76590b35a8fcb3a3d5c6f" translate="yes" xml:space="preserve">
          <source>More overrides</source>
          <target state="translated">더 많은 재정의</target>
        </trans-unit>
        <trans-unit id="07a448ec5491d4e27e09f682b963835667c1081a" translate="yes" xml:space="preserve">
          <source>More precisely, the redisplay occurs after some kind of asynchronous event related to the view, such as a keystroke, a timer completion, or a response to an HTTP request.</source>
          <target state="translated">보다 정확하게는, 키 표시, 타이머 완료 또는 HTTP 요청에 대한 응답과 같이보기와 관련된 일종의 비동기 이벤트 후에 재 표시가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aec5f46f01ea145b2890502695f0be4ed736f483" translate="yes" xml:space="preserve">
          <source>More rarely, an interceptor may handle the request entirely, and compose a new event stream instead of invoking &lt;code&gt;next.handle()&lt;/code&gt;. This is an acceptable behavior, but keep in mind that further interceptors will be skipped entirely.</source>
          <target state="translated">더 드물게 인터셉터가 요청을 완전히 처리하고 &lt;code&gt;next.handle()&lt;/code&gt; 을 호출하는 대신 새 이벤트 스트림을 작성할 수 있습니다 . 이는 허용되는 동작이지만 추가 인터셉터는 완전히 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="9773bd6daaf69947cac6ad3df92c6b1ce39a7a26" translate="yes" xml:space="preserve">
          <source>Most &lt;code&gt;.js&lt;/code&gt; files are &lt;em&gt;git&lt;/em&gt;-ignored. If you want to include an ignored code file in your project and display it in a guide you must &lt;em&gt;un-ignore&lt;/em&gt; it.</source>
          <target state="translated">대부분의 &lt;code&gt;.js&lt;/code&gt; 파일은 &lt;em&gt;자식&lt;/em&gt; 무시됩니다. 무시 된 코드 파일을 프로젝트에 포함시키고 안내서에 표시하려면 &lt;em&gt;무시&lt;/em&gt; 해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bd5890495ec24c946c059ac09698db1571dd568" translate="yes" xml:space="preserve">
          <source>Most &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; methods return observables of &lt;code&gt;&lt;a href=&quot;../api/common/http/httpresponse&quot;&gt;HttpResponse&lt;/a&gt;&amp;lt;any&amp;gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../api/common/http/httpresponse&quot;&gt;HttpResponse&lt;/a&gt;&lt;/code&gt; class itself is actually an event, whose type is &lt;code&gt;&lt;a href=&quot;../api/common/http/httpeventtype#Response&quot;&gt;HttpEventType.Response&lt;/a&gt;&lt;/code&gt;. A single HTTP request can, however, generate multiple events of other types, including upload and download progress events. The methods &lt;code&gt;HttpInterceptor.intercept()&lt;/code&gt; and &lt;code&gt;HttpHandler.handle()&lt;/code&gt; return observables of &lt;code&gt;&lt;a href=&quot;../api/common/http/httpevent&quot;&gt;HttpEvent&lt;/a&gt;&amp;lt;any&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 메서드는 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpresponse&quot;&gt;HttpResponse&lt;/a&gt;&amp;lt;any&amp;gt;&lt;/code&gt; 관찰 가능 항목을 반환 합니다 . &lt;code&gt;&lt;a href=&quot;../api/common/http/httpresponse&quot;&gt;HttpResponse&lt;/a&gt;&lt;/code&gt; 클래스 자체는 실제로 유형이있는 이벤트입니다 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpeventtype#Response&quot;&gt;HttpEventType.Response&lt;/a&gt;&lt;/code&gt; 을 . 그러나 단일 HTTP 요청은 업로드 및 다운로드 진행 이벤트를 포함하여 다른 유형의 여러 이벤트를 생성 할 수 있습니다. &lt;code&gt;HttpInterceptor.intercept()&lt;/code&gt; 및 &lt;code&gt;HttpHandler.handle()&lt;/code&gt; 메서드 는 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpevent&quot;&gt;HttpEvent&lt;/a&gt;&amp;lt;any&amp;gt;&lt;/code&gt; 관찰 가능 항목을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="0d51e03cc5530b81cb20e9ecd7e7ab908caaccc1" translate="yes" xml:space="preserve">
          <source>Most Visual Studio developers like to press the F5 key and see the IIS server come up. To use the IIS server with the Getting Started app, you must make the following three changes.</source>
          <target state="translated">대부분의 Visual Studio 개발자는 F5 키를 누르고 IIS 서버가 나타나는 것을 좋아합니다. 시작하기 앱에서 IIS 서버를 사용하려면 다음 세 가지를 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="24e64566ad7a8ccb4a3e9b304e753550d0942726" translate="yes" xml:space="preserve">
          <source>Most application developers won't need to add components to the &lt;code&gt;entryComponents&lt;/code&gt;.</source>
          <target state="translated">대부분의 애플리케이션 개발자는 &lt;code&gt;entryComponents&lt;/code&gt; 에 컴포넌트를 추가 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e11e7f319de45fe5979a6e095d54297622091f9b" translate="yes" xml:space="preserve">
          <source>Most apps are translated into more than one other language. For this reason, it is standard practice for the project structure to reflect the entire internationalization effort.</source>
          <target state="translated">대부분의 앱은 둘 이상의 다른 언어로 번역됩니다. 이러한 이유로 프로젝트 구조가 국제화 노력 전체를 반영하는 것이 표준 관행입니다.</target>
        </trans-unit>
        <trans-unit id="f5f0c9a994789bb5a9d1f86543d043bf68da3637" translate="yes" xml:space="preserve">
          <source>Most apps should implement a routing module for consistency. It keeps the code clean when configuration becomes complex. It makes testing the feature module easier. Its existence calls attention to the fact that a module is routed. It is where developers expect to find and expand routing configuration.</source>
          <target state="translated">대부분의 앱은 일관성을 위해 라우팅 모듈을 구현해야합니다. 구성이 복잡해지면 코드를 깔끔하게 유지합니다. 기능 모듈을 더 쉽게 테스트 할 수 있습니다. 그것의 존재는 모듈이 라우팅된다는 사실에주의를 환기시킵니다. 개발자가 라우팅 구성을 찾고 확장하기를 기대하는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="d19f74cc4bdf32f4c998305d04803fe40cd8d21f" translate="yes" xml:space="preserve">
          <source>Most apps strive for a consistent look across the application. The CLI generated an empty &lt;code&gt;styles.css&lt;/code&gt; for this purpose. Put your application-wide styles there.</source>
          <target state="translated">대부분의 앱은 애플리케이션 전체에서 일관된 모양을 유지하려고 노력합니다. CLI는 이를 위해 빈 &lt;code&gt;styles.css&lt;/code&gt; 를 생성했습니다 . 응용 프로그램 전체 스타일을 거기에 두십시오.</target>
        </trans-unit>
        <trans-unit id="8853a6f7c581a58d06a62a20b221bab8653cf6b7" translate="yes" xml:space="preserve">
          <source>Most commands, and some options, have aliases. Aliases are shown in the syntax statement for each command.</source>
          <target state="translated">대부분의 명령과 일부 옵션에는 별칭이 있습니다. 별명은 각 명령의 구문 명령문에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="55e283fb52cf31d8715e41cd5807d100e35c86b0" translate="yes" xml:space="preserve">
          <source>Most components are not quite this simple, of course. Many of them have &lt;em&gt;inputs and outputs&lt;/em&gt; that connect them to the outside world. An Angular hero detail component with inputs and outputs might look like this:</source>
          <target state="translated">물론 대부분의 구성 요소는 이처럼 단순하지 않습니다. 그들 중 많은 사람들이 외부 세계에 연결하는 &lt;em&gt;입력 및 출력&lt;/em&gt; 을 가지고 있습니다. 입력과 출력이있는 Angular hero detail 구성 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a4cf09953c1681276d4b3e72e5a109325790f25" translate="yes" xml:space="preserve">
          <source>Most developers should always implement a Routing Module for the sake of consistency. It keeps the code clean when configuration becomes complex. It makes testing the feature module easier. Its existence calls attention to the fact that a module is routed. It is where developers expect to find and expand routing configuration.</source>
          <target state="translated">대부분의 개발자는 일관성을 유지하기 위해 항상 라우팅 모듈을 구현해야합니다. 구성이 복잡해지면 코드를 깨끗하게 유지합니다. 기능 모듈을 쉽게 테스트 할 수 있습니다. 그것의 존재는 모듈이 라우팅된다는 사실에주의를 기울입니다. 개발자가 라우팅 구성을 찾아 확장 할 것으로 예상되는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="c4f333a6b53d02b01658733f28ee1218f17a41f6" translate="yes" xml:space="preserve">
          <source>Most front-end applications communicate with backend services over the HTTP protocol. Modern browsers support two different APIs for making HTTP requests: the &lt;code&gt;XMLHttpRequest&lt;/code&gt; interface and the &lt;code&gt;fetch()&lt;/code&gt; API.</source>
          <target state="translated">대부분의 프런트 엔드 응용 프로그램은 HTTP 프로토콜을 통해 백엔드 서비스와 통신합니다. 최신 브라우저는 HTTP 요청을 만들기 위해 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 인터페이스와 &lt;code&gt;fetch()&lt;/code&gt; API의 두 가지 API를 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="fea041336d25b846418302b45bb2a45debd301ee" translate="yes" xml:space="preserve">
          <source>Most front-end applications need to communicate with a server over the HTTP protocol, in order to download or upload data and access other back-end services. Angular provides a simplified client HTTP API for Angular applications, the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; service class in &lt;code&gt;@angular/common/&lt;a href=&quot;../api/common/http&quot;&gt;http&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">대부분의 프런트 엔드 애플리케이션은 데이터를 다운로드 또는 업로드하고 다른 백 엔드 서비스에 액세스하기 위해 HTTP 프로토콜을 통해 서버와 통신해야합니다. Angular는 &lt;code&gt;@angular/common/&lt;a href=&quot;../api/common/http&quot;&gt;http&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/common/http&quot;&gt;http&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 서비스 클래스 인 Angular 애플리케이션을위한 단순화 된 클라이언트 HTTP API를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="719527a89875cadc610efdc78a5bced86462ab1b" translate="yes" xml:space="preserve">
          <source>Most interceptors call &lt;code&gt;next.handle()&lt;/code&gt; so that the request flows through to the next interceptor and, eventually, the backend handler. An interceptor &lt;em&gt;could&lt;/em&gt; skip calling &lt;code&gt;next.handle()&lt;/code&gt;, short-circuit the chain, and &lt;a href=&quot;http#caching&quot;&gt;return its own &lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt; with an artificial server response.</source>
          <target state="translated">대부분의 인터셉터는 &lt;code&gt;next.handle()&lt;/code&gt; 호출 하여 요청이 다음 인터셉터 및 백엔드 핸들러로 전달되도록합니다. 인터셉터 &lt;em&gt;는 &lt;/em&gt; &lt;code&gt;next.handle()&lt;/code&gt; 호출을 건너 뛰고 체인을 단락 시키고 인공 서버 응답으로 &lt;a href=&quot;http#caching&quot;&gt;자체 &lt;code&gt;Observable&lt;/code&gt; &lt;/a&gt; 을 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca1e26016b81b69914d27a86f57ab285fe288001" translate="yes" xml:space="preserve">
          <source>Most interceptors inspect the request on the way in and forward the (perhaps altered) request to the &lt;code&gt;handle()&lt;/code&gt; method of the &lt;code&gt;next&lt;/code&gt; object which implements the &lt;a href=&quot;../api/common/http/httphandler&quot;&gt;&lt;code&gt;HttpHandler&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">대부분의 인터셉터 는 &lt;a href=&quot;../api/common/http/httphandler&quot;&gt; &lt;code&gt;HttpHandler&lt;/code&gt; &lt;/a&gt; 인터페이스 를 구현하는 &lt;code&gt;next&lt;/code&gt; 오브젝트 의 &lt;code&gt;handle()&lt;/code&gt; 메소드에 요청을 검사하고 전달합니다 (아마 변경) .</target>
        </trans-unit>
        <trans-unit id="808548a8b44fb0eb4077020c87c8c6fe9736695c" translate="yes" xml:space="preserve">
          <source>Most interceptors transform the outgoing request before passing it to the next interceptor in the chain, by calling &lt;code&gt;next.handle(transformedReq)&lt;/code&gt;. An interceptor may transform the response event stream as well, by applying additional RxJS operators on the stream returned by &lt;code&gt;next.handle()&lt;/code&gt;.</source>
          <target state="translated">대부분의 인터셉터는 다음 요청을 체인의 다음 인터셉터로 전달하기 전에 &lt;code&gt;next.handle(transformedReq)&lt;/code&gt; 호출하여 발신 요청을 변환합니다 . 인터셉터는 &lt;code&gt;next.handle()&lt;/code&gt; 리턴 한 스트림에 추가 RxJS 연산자를 적용하여 응답 이벤트 스트림도 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="770f94ef5f83cf3e03b4b61b713bbbdd83a35d94" translate="yes" xml:space="preserve">
          <source>Most of the Template Syntax guides have dedicated working example apps that demonstrate the individual topic of each guide. To see all of them working together in one app, see the comprehensive .</source>
          <target state="translated">대부분의 템플릿 구문 가이드에는 각 가이드의 개별 주제를 보여주는 전용 예제 앱이 있습니다. 모두 하나의 앱에서 함께 작동하는 것을 보려면 포괄적 인.</target>
        </trans-unit>
        <trans-unit id="fd61c99374f34bfc3a631f8a23fdbca310a9c019" translate="yes" xml:space="preserve">
          <source>Most of the ad banner implementation is in &lt;code&gt;ad-banner.component.ts&lt;/code&gt;. To keep things simple in this example, the HTML is in the &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; decorator's &lt;code&gt;template&lt;/code&gt; property as a template string.</source>
          <target state="translated">광고 배너 구현의 대부분은 &lt;code&gt;ad-banner.component.ts&lt;/code&gt; 에 있습니다. 이 예제에서 간단하게하기 위해 HTML은 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; 데코레이터의 &lt;code&gt;template&lt;/code&gt; 속성에 템플릿 문자열로 있습니다.</target>
        </trans-unit>
        <trans-unit id="98a3406be782b14b8c49458075095ba291e8b0e6" translate="yes" xml:space="preserve">
          <source>Most of these initial checks are triggered by Angular's first rendering of &lt;em&gt;unrelated data elsewhere on the page&lt;/em&gt;. Just moving the cursor into another &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; triggers a call. Relatively few calls reveal actual changes to pertinent data. If you use this hook, your implementation must be extremely lightweight or the user experience suffers.</source>
          <target state="translated">이러한 초기 검사의 대부분은 Angular가 &lt;em&gt;페이지의 다른 곳에서 관련없는 데이터를&lt;/em&gt; 처음으로 렌더링함으로써 트리거됩니다 . 커서를 다른 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 으로 이동하면 호출이 트리거됩니다. 상대적으로 적은 수의 호출이 관련 데이터에 대한 실제 변경 사항을 보여줍니다. 이 후크를 사용하는 경우 구현이 매우 가벼워 야하며 그렇지 않으면 사용자 경험이 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="8dfb823a50df03ab9a32b94b5a3e90b2fe18890c" translate="yes" xml:space="preserve">
          <source>Most of these initial checks are triggered by Angular's first rendering of &lt;em&gt;unrelated data elsewhere on the page&lt;/em&gt;. Mere mousing into another &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; triggers a call. Relatively few calls reveal actual changes to pertinent data. Clearly our implementation must be very lightweight or the user experience suffers.</source>
          <target state="translated">이러한 초기 확인의 대부분은 Angular의 &lt;em&gt;관련없는 데이터를 페이지의 다른 곳에서&lt;/em&gt; 처음 렌더링함으로써 시작됩니다 . 다른 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 으로 마우스를 가져 가면 통화가 시작됩니다. 상대적으로 적은 통화 만 관련 데이터에 대한 실제 변경을 보여줍니다. 분명히 우리의 구현은 매우 가벼워 야하거나 사용자 경험이 어려움을 겪어야합니다.</target>
        </trans-unit>
        <trans-unit id="271a4fd1d564b640eb5094017d2dded69641207f" translate="yes" xml:space="preserve">
          <source>Most pages display a table of contents (TOC). The TOC appears in the right panel when the viewport is wide. When narrow, the TOC appears in an expandable/collapsible region near the top of the page.</source>
          <target state="translated">대부분의 페이지는 목차 (TOC)를 표시합니다. 뷰포트가 넓 으면 오른쪽 패널에 TOC가 나타납니다. 좁 으면 TOC가 페이지 상단 근처의 확장 가능 / 축소 가능 영역에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="72b1b590f111f607313721f1526c34d7c9d57c9d" translate="yes" xml:space="preserve">
          <source>Most people find this browser output easier to read than the console log. You can click on a test row to re-run just that test or click on a description to re-run the tests in the selected test group (&quot;test suite&quot;).</source>
          <target state="translated">대부분의 사람들은 콘솔 로그보다이 브라우저 출력을 읽기 쉽다는 것을 알고 있습니다. 테스트 행을 클릭하여 해당 테스트 만 다시 실행하거나 설명을 클릭하여 선택한 테스트 그룹 ( &quot;테스트 스위트&quot;)에서 테스트를 다시 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de981406b5235d22ec1a551a7d57ba6fdbb6fdb9" translate="yes" xml:space="preserve">
          <source>Most routing applications should add a &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; element to the &lt;code&gt;index.html&lt;/code&gt; as the first child in the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; tag to tell the router how to compose navigation URLs.</source>
          <target state="translated">대부분의 라우팅 응용 프로그램은 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 태그 의 첫 번째 자식으로 &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; 요소를 &lt;code&gt;index.html&lt;/code&gt; 에 추가 하여 라우터에 탐색 URL을 구성하는 방법을 알려야합니다.</target>
        </trans-unit>
        <trans-unit id="a1ce49a28c994105e2b80e086138ea97fc5a2102" translate="yes" xml:space="preserve">
          <source>Most test suites in this guide call &lt;code&gt;beforeEach()&lt;/code&gt; to set the preconditions for each &lt;code&gt;it()&lt;/code&gt; test and rely on the &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; to create classes and inject services.</source>
          <target state="translated">이 안내서의 대부분의 테스트 스위트는 &lt;code&gt;beforeEach()&lt;/code&gt; 를 호출 하여 각 &lt;code&gt;it()&lt;/code&gt; 테스트에 대한 사전 조건을 설정하고 클래스를 작성하고 서비스를 주입하기 위해 &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; 에 의존 합니다.</target>
        </trans-unit>
        <trans-unit id="e9435e64807b34b81e3b5c20def5bfc7dd89cb82" translate="yes" xml:space="preserve">
          <source>Most updates to the Angular service worker are transparent to the app&amp;mdash;the old caches are still valid and content is still served normally. However, occasionally a bugfix or feature in the Angular service worker requires the invalidation of old caches. In this case, the app will be refreshed transparently from the network.</source>
          <target state="translated">Angular 서비스 워커에 대한 대부분의 업데이트는 앱에 투명합니다. 이전 캐시는 여전히 유효하며 콘텐츠는 여전히 정상적으로 제공됩니다. 그러나 때때로 Angular 서비스 워커의 버그 수정이나 기능을 사용하려면 이전 캐시를 무효화해야합니다. 이 경우 네트워크에서 앱이 투명하게 새로 고쳐집니다.</target>
        </trans-unit>
        <trans-unit id="a80b931f6f0bc3139ea3c812478b2f81351f0b0e" translate="yes" xml:space="preserve">
          <source>Most web APIs support a &lt;em&gt;get by id&lt;/em&gt; request in the form &lt;code&gt;:baseURL/:id&lt;/code&gt;.</source>
          <target state="translated">대부분의 웹 API는 &lt;code&gt;:baseURL/:id&lt;/code&gt; 형식 으로 &lt;em&gt;get by id&lt;/em&gt; 요청을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="20da40e26940fbe216c818a6961898cc6adaf59c" translate="yes" xml:space="preserve">
          <source>Motion greatly enhances the user experience, so animations give users a chance to detect the application's response to their actions.</source>
          <target state="translated">모션은 사용자 경험을 크게 향상 시키므로 애니메이션을 통해 사용자는 작업에 대한 응용 프로그램의 응답을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="088f61a80f05141c5fbb3d893761e6ecfb686430" translate="yes" xml:space="preserve">
          <source>Move the &lt;code&gt;app/index.html&lt;/code&gt; file to the project root directory. Then change the development server root path in &lt;code&gt;package.json&lt;/code&gt; to also point to the project root instead of &lt;code&gt;app&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;app/index.html&lt;/code&gt; 파일을 프로젝트 루트 디렉토리로 이동하십시오 . 그런 다음 &lt;code&gt;package.json&lt;/code&gt; 에서 개발 서버 루트 경로를 변경하여 &lt;code&gt;app&lt;/code&gt; 대신 프로젝트 루트를 가리 키십시오 .</target>
        </trans-unit>
        <trans-unit id="39f6edeec674fcbbaf73d38f42c8de451492dbbb" translate="yes" xml:space="preserve">
          <source>Move the placeholder &lt;code&gt;hero-list&lt;/code&gt; folder that's in the &lt;code&gt;app&lt;/code&gt; folder into the &lt;code&gt;heroes&lt;/code&gt; folder.</source>
          <target state="translated">&lt;code&gt;app&lt;/code&gt; 폴더에 있는 자리 표시 자 &lt;code&gt;hero-list&lt;/code&gt; 폴더를 &lt;code&gt;heroes&lt;/code&gt; 폴더로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="72dfef3298f9e4d3621d27b7823ec1135e13b975" translate="yes" xml:space="preserve">
          <source>Move the placeholder &lt;code&gt;hero-list&lt;/code&gt; folder that's in the &lt;code&gt;app&lt;/code&gt; into the &lt;code&gt;heroes&lt;/code&gt; folder.</source>
          <target state="translated">&lt;code&gt;app&lt;/code&gt; 에 있는 자리 표시 자 &lt;code&gt;hero-list&lt;/code&gt; 폴더를 &lt;code&gt;heroes&lt;/code&gt; 폴더로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="b6f5b2d899fe92b6ea8951798cdc4fa361c2b6f9" translate="yes" xml:space="preserve">
          <source>Move the relevant parts of the crisis retrieval logic in &lt;code&gt;CrisisDetailComponent.ngOnInit()&lt;/code&gt; into the &lt;code&gt;CrisisDetailResolverService&lt;/code&gt;. Import the &lt;code&gt;Crisis&lt;/code&gt; model, &lt;code&gt;CrisisService&lt;/code&gt;, and the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; so you can navigate elsewhere if you can't fetch the crisis.</source>
          <target state="translated">의 위기 검색 로직의 관련 부분으로 이동 &lt;code&gt;CrisisDetailComponent.ngOnInit()&lt;/code&gt; 에 &lt;code&gt;CrisisDetailResolverService&lt;/code&gt; . 가져 오기 &lt;code&gt;Crisis&lt;/code&gt; 모델, &lt;code&gt;CrisisService&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 는 위기를 가져올 수없는 경우 다른 곳으로 이동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1647670a82c1749f387c5f2944002192fcd91b5" translate="yes" xml:space="preserve">
          <source>Moves a view to a new location in this container.</source>
          <target state="translated">이 컨테이너의 새 위치로보기를 이동합니다.</target>
        </trans-unit>
        <trans-unit id="c09f1c0051ecc467d6b93dba92c0113872a98043" translate="yes" xml:space="preserve">
          <source>Multi-class binding</source>
          <target state="translated">다중 클래스 바인딩</target>
        </trans-unit>
        <trans-unit id="41d53bcda082f4976ef79aea4c9eae973cb70e04" translate="yes" xml:space="preserve">
          <source>Multi-style binding</source>
          <target state="translated">다중 스타일 바인딩</target>
        </trans-unit>
        <trans-unit id="44759830117daa31d1321a9d8804af42279988cb" translate="yes" xml:space="preserve">
          <source>Multi-value example</source>
          <target state="translated">다중 값 예</target>
        </trans-unit>
        <trans-unit id="85768b6bf1094b92415a9e43d68a4719e2932d41" translate="yes" xml:space="preserve">
          <source>Multicasting</source>
          <target state="translated">Multicasting</target>
        </trans-unit>
        <trans-unit id="ccd10a4daff631270a3f7ab6ab0a36a86a3adfe1" translate="yes" xml:space="preserve">
          <source>Multicasting observables take a bit more setup, but they can be useful for certain applications. Later we will look at tools that simplify the process of multicasting, allowing you to take any observable and make it multicasting.</source>
          <target state="translated">멀티 캐스팅 옵저버 블은 약간 더 설정이 필요하지만 특정 응용 프로그램에 유용 할 수 있습니다. 나중에 멀티 캐스팅 프로세스를 단순화하여 관찰 가능한 멀티 캐스팅을 수행 할 수있는 도구를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="23ff52e403edc6ed596c8767589449944d382d73" translate="yes" xml:space="preserve">
          <source>Multiple Outlets</source>
          <target state="translated">여러 콘센트</target>
        </trans-unit>
        <trans-unit id="71e10f5d94b0738202ebc0ae107e33ad89e21fa6" translate="yes" xml:space="preserve">
          <source>Multiple animation triggers</source>
          <target state="translated">여러 애니메이션 트리거</target>
        </trans-unit>
        <trans-unit id="eb88b2b9a32b6fa3fc28d8f3c4800b3eabd0b72e" translate="yes" xml:space="preserve">
          <source>Multiple components can leverage the same service. Later in this tutorial, the shipping component uses the cart service to retrieve shipping data via HTTP from the &lt;code&gt;shipping.json&lt;/code&gt; file. First, define a &lt;code&gt;get()&lt;/code&gt; method.</source>
          <target state="translated">여러 구성 요소가 동일한 서비스를 활용할 수 있습니다. 이 자습서의 뒷부분에서 배송 구성 요소는 장바구니 서비스를 사용하여 &lt;code&gt;shipping.json&lt;/code&gt; 파일 에서 HTTP를 통해 배송 데이터를 검색 합니다. 먼저 &lt;code&gt;get()&lt;/code&gt; 메서드를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="403737f5a0e994d747fc5829da9da44f4098d631" translate="yes" xml:space="preserve">
          <source>Multiple project file structure</source>
          <target state="translated">다중 프로젝트 파일 구조</target>
        </trans-unit>
        <trans-unit id="4c38246227539ea95edb3bb120c7f680c9dae722" translate="yes" xml:space="preserve">
          <source>Multiple projects</source>
          <target state="translated">여러 프로젝트</target>
        </trans-unit>
        <trans-unit id="1f8642040031aeb5f8e1c1b6956da9c26f01da5c" translate="yes" xml:space="preserve">
          <source>Multiple providers can be associated with a single token in other areas as well. For example, you can register a custom form validator using the built-in &lt;a href=&quot;../api/forms/ng_validators&quot;&gt;NG_VALIDATORS&lt;/a&gt; token, and provide multiple instances of a given validator provider by using the &lt;code&gt;multi: true&lt;/code&gt; property in the provider object. Angular adds your custom validators to the existing collection.</source>
          <target state="translated">다른 지역에서도 여러 공급자를 단일 토큰과 연결할 수 있습니다. 예를 들어, 내장 &lt;a href=&quot;../api/forms/ng_validators&quot;&gt;NG_VALIDATORS&lt;/a&gt; 토큰을 사용하여 사용자 정의 양식 유효성 검증기를 등록하고 제공자 오브젝트 의 &lt;code&gt;multi: true&lt;/code&gt; 특성 을 사용하여 지정된 유효성 검증기 제공자의 여러 인스턴스를 제공 할 수 있습니다. Angular는 사용자 정의 유효성 검사기를 기존 컬렉션에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="baa333de91b3ba325c66257efd5cac4be7a52608" translate="yes" xml:space="preserve">
          <source>Multiple service instances (sandboxing)</source>
          <target state="translated">여러 서비스 인스턴스 (샌드 박스)</target>
        </trans-unit>
        <trans-unit id="d4a98ed21d0eb6791f1cbe537aad455031c8c19f" translate="yes" xml:space="preserve">
          <source>Multiple static segments can be merged into one (e.g., &lt;code&gt;['/team/11/user', userName, {details: true}]&lt;/code&gt;).</source>
          <target state="translated">여러 정적 세그먼트를 하나로 병합 할 수 있습니다 (예 : &lt;code&gt;['/team/11/user', userName, {details: true}]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="134f02de1a68fb7a0c3b3cd56fe8cd70a0523c65" translate="yes" xml:space="preserve">
          <source>Multiple static segments can be merged into one term and combined with dynamic segements. For example, &lt;code&gt;['/team/11/user', userName, {details: true}]&lt;/code&gt;</source>
          <target state="translated">여러 정적 세그먼트를 하나의 용어로 병합하고 동적 세그먼트와 결합 할 수 있습니다. 예 : &lt;code&gt;['/team/11/user', userName, {details: true}]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="479b0a69757fbef14e6ecb57e00858bd5dab1beb" translate="yes" xml:space="preserve">
          <source>Multiple values; for example, &lt;code&gt;after='12/31/2015' &amp;amp; before='1/1/2017'&lt;/code&gt;&amp;mdash;in no particular order&amp;mdash;&lt;code&gt;before='1/1/2017' &amp;amp; after='12/31/2015'&lt;/code&gt;&amp;mdash; in a variety of formats&amp;mdash;&lt;code&gt;during='currentYear'&lt;/code&gt;.</source>
          <target state="translated">여러 값; 예를 들어, &lt;code&gt;after='12/31/2015' &amp;amp; before='1/1/2017'&lt;/code&gt; -에서 특정한 순서 - 없음 &lt;code&gt;before='1/1/2017' &amp;amp; after='12/31/2015'&lt;/code&gt; - A의 다양한 &lt;code&gt;during='currentYear'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d3de9de8b139d37d7c691156addb32d1f622228" translate="yes" xml:space="preserve">
          <source>Must be executed from within a workspace directory. When a project name is not supplied, it will execute for all projects.</source>
          <target state="translated">작업 공간 디렉토리 내에서 실행해야합니다. 프로젝트 이름이 제공되지 않으면 모든 프로젝트에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="88c3578f358497ee57de0669c6df27b6d72fc10c" translate="yes" xml:space="preserve">
          <source>Must be used in the context of a factory function such as one defined for an &lt;code&gt;&lt;a href=&quot;injectiontoken&quot;&gt;InjectionToken&lt;/a&gt;&lt;/code&gt;. Throws an error if not called from such a context.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;injectiontoken&quot;&gt;InjectionToken&lt;/a&gt;&lt;/code&gt; 에 대해 정의 된 것과 같은 팩토리 함수의 컨텍스트에서 사용해야합니다 . 이러한 컨텍스트에서 호출되지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0b79f8e4890c8608e67c29a1e344d765772f2753" translate="yes" xml:space="preserve">
          <source>Mutability</source>
          <target state="translated">Mutability</target>
        </trans-unit>
        <trans-unit id="cea8e259b44a93b7b0509cd22ed570ea8235896d" translate="yes" xml:space="preserve">
          <source>Mutability of the data model</source>
          <target state="translated">데이터 모델의 가변성</target>
        </trans-unit>
        <trans-unit id="07ca44c83d180ec16ed67d72f6f53a30504adb70" translate="yes" xml:space="preserve">
          <source>Mutable</source>
          <target state="translated">Mutable</target>
        </trans-unit>
        <trans-unit id="e579a1d025aaf38d74ab8d2625e6b8a4f3a2f7a5" translate="yes" xml:space="preserve">
          <source>NG_ASYNC_VALIDATORS</source>
          <target state="translated">NG_ASYNC_VALIDATORS</target>
        </trans-unit>
        <trans-unit id="effab8d59fa7c123d4b29984483832e4f491e319" translate="yes" xml:space="preserve">
          <source>NG_VALIDATORS</source>
          <target state="translated">NG_VALIDATORS</target>
        </trans-unit>
        <trans-unit id="c7807450dc4b5e96ac6d57d5f6877820a3ba310a" translate="yes" xml:space="preserve">
          <source>NG_VALUE_ACCESSOR</source>
          <target state="translated">NG_VALUE_ACCESSOR</target>
        </trans-unit>
        <trans-unit id="8c6abbe86b9a3dd54d847c73d2fcb02c7646f939" translate="yes" xml:space="preserve">
          <source>NOTE:</source>
          <target state="translated">NOTE:</target>
        </trans-unit>
        <trans-unit id="52577a8f79e784bd49f26a4184f5c685b9352790" translate="yes" xml:space="preserve">
          <source>NOTE: In the future this class will implement an &lt;code&gt;Observable&lt;/code&gt; interface.</source>
          <target state="translated">참고 : &lt;code&gt;Observable&lt;/code&gt; 클래스는 Observable 인터페이스를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="c01fd67259def4959927758ba28403ac03397d2b" translate="yes" xml:space="preserve">
          <source>NOTE: The basic behavior described below is handled automatically when using the NgUniversal Express schematic. This is helpful when trying to understand the underlying behavior or replicate it without using the schematic.</source>
          <target state="translated">참고 : 아래에 설명 된 기본 동작은 NgUniversal Express 회로도를 사용할 때 자동으로 처리됩니다. 이는 기본 동작을 이해하거나 회로도를 사용하지 않고 복제하려고 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a0698704ab187d839adc3f2a3ee28d874c2bb329" translate="yes" xml:space="preserve">
          <source>NOTE: These are not necessarily the actual operations which were applied to the original &lt;code&gt;Iterable&lt;/code&gt;, rather these are a set of computed operations which may not be the same as the ones applied.</source>
          <target state="translated">참고 : 이들은 반드시 원래 &lt;code&gt;Iterable&lt;/code&gt; 에 적용된 실제 작업 일 필요는 없으며, 적용된 작업과 동일하지 않을 수도있는 계산 된 작업 집합입니다.</target>
        </trans-unit>
        <trans-unit id="6812b1bc0c0646ebecf1e212f6b701a4c00f9e0e" translate="yes" xml:space="preserve">
          <source>NOTE: the basic behavior described below is handled automatically when using the NgUniversal Express schematic, this is helpful when trying to understand the underlying behavior or replicate it without using the schematic.</source>
          <target state="translated">참고 : NgUniversal Express 회로도를 사용하면 아래에 설명 된 기본 동작이 자동으로 처리되므로 회로도를 사용하지 않고 기본 동작을 이해하거나 복제하려고 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7d67ee9446bfc0dbf4127f0fae8b6858be3024db" translate="yes" xml:space="preserve">
          <source>NO_ERRORS_SCHEMA</source>
          <target state="translated">NO_ERRORS_SCHEMA</target>
        </trans-unit>
        <trans-unit id="7d94ebbf07f5417771d7c7fd06f208703494bf50" translate="yes" xml:space="preserve">
          <source>NPM</source>
          <target state="translated">NPM</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="9186e712d39a5c297348aee49687c55909aa797a" translate="yes" xml:space="preserve">
          <source>Name controls to make them accessible to &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 에 액세스 할 수 있도록 컨트롤 이름을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="ac0bd3f0f21026a506ecdfde4d06d7cf1b932ed6" translate="yes" xml:space="preserve">
          <source>Name expected</source>
          <target state="translated">예상되는 이름</target>
        </trans-unit>
        <trans-unit id="1c87abf672363192eb82a7c84d215c41d1df8f0a" translate="yes" xml:space="preserve">
          <source>Name of a &lt;code&gt;&lt;a href=&quot;routeroutlet&quot;&gt;RouterOutlet&lt;/a&gt;&lt;/code&gt; object where the component can be placed when the path matches.</source>
          <target state="translated">경로가 일치 할 때 구성 요소를 배치 할 수 있는 &lt;code&gt;&lt;a href=&quot;routeroutlet&quot;&gt;RouterOutlet&lt;/a&gt;&lt;/code&gt; 오브젝트의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="f63873b158ebb46bfe3985fc24290d54033cb54f" translate="yes" xml:space="preserve">
          <source>Name of the event listener.</source>
          <target state="translated">이벤트 리스너의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="efaff6470fe74eff20a22d907e5996c60bcd343d" translate="yes" xml:space="preserve">
          <source>Name of the file to output.</source>
          <target state="translated">출력 할 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="edb8b69d52b5234d914940a2c7dab34536d5b737" translate="yes" xml:space="preserve">
          <source>Named &lt;em&gt;#docregions&lt;/em&gt;</source>
          <target state="translated">명명 된 &lt;em&gt;#docregions&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="565f8abd08ab76aca7ede4a593565f082212bd51" translate="yes" xml:space="preserve">
          <source>Named outlets are the targets of &lt;em&gt;secondary routes&lt;/em&gt;.</source>
          <target state="translated">명명 된 아울렛은 &lt;em&gt;2 차 경로&lt;/em&gt; 의 대상입니다 .</target>
        </trans-unit>
        <trans-unit id="119b5245a8e6a765d9aed0284081a389d53d48ca" translate="yes" xml:space="preserve">
          <source>Named outlets can be the targets of secondary routes. The &lt;code&gt;&lt;a href=&quot;route&quot;&gt;Route&lt;/a&gt;&lt;/code&gt; object for a secondary route has an &lt;code&gt;outlet&lt;/code&gt; property to identify the target outlet:</source>
          <target state="translated">명명 된 콘센트는 보조 경로의 대상이 될 수 있습니다. &lt;code&gt;&lt;a href=&quot;route&quot;&gt;Route&lt;/a&gt;&lt;/code&gt; 보조 경로에 대한 객체는이 &lt;code&gt;outlet&lt;/code&gt; 대상 콘센트를 식별하는 속성을 :</target>
        </trans-unit>
        <trans-unit id="19c58cf746e1fa01bb3ddb3e978299e1e6439626" translate="yes" xml:space="preserve">
          <source>Named schematics</source>
          <target state="translated">명명 된 회로도</target>
        </trans-unit>
        <trans-unit id="a46171efa120e3814dee92fef224b89628e2e912" translate="yes" xml:space="preserve">
          <source>Names of the parameters in the map.</source>
          <target state="translated">맵의 매개 변수 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8b4617b659a51d0b5756991a46730570511eef04" translate="yes" xml:space="preserve">
          <source>Naming</source>
          <target state="translated">Naming</target>
        </trans-unit>
        <trans-unit id="9345aa984ae2d440c135aa46c84413fabb4b2045" translate="yes" xml:space="preserve">
          <source>Naming control elements</source>
          <target state="translated">제어 요소 이름 지정</target>
        </trans-unit>
        <trans-unit id="b421e345572cd6dda9871ac0f2b12a8589699460" translate="yes" xml:space="preserve">
          <source>Naming conventions are hugely important to maintainability and readability. This guide recommends naming conventions for the file name and the symbol name.</source>
          <target state="translated">이름 지정 규칙은 유지 관리 성과 가독성에 매우 중요합니다. 이 안내서는 파일 이름과 기호 이름에 대한 명명 규칙을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="8098b332f1cda7a125158650b5bd36b36600d729" translate="yes" xml:space="preserve">
          <source>Naming conventions for observables</source>
          <target state="translated">관찰 가능 항목의 명명 규칙</target>
        </trans-unit>
        <trans-unit id="0dd4757821f76adef6aa4fb71118d5ba8fc3f9ab" translate="yes" xml:space="preserve">
          <source>Naming your lightweight injection token</source>
          <target state="translated">경량 주입 토큰 이름 지정</target>
        </trans-unit>
        <trans-unit id="697edbe4acd10b9466b672837ee81bd016c23b79" translate="yes" xml:space="preserve">
          <source>Narrow</source>
          <target state="translated">Narrow</target>
        </trans-unit>
        <trans-unit id="8fcc9d7a4aab9838b2b1f8ef3e8a90f55268f08a" translate="yes" xml:space="preserve">
          <source>Native DOM validation UI</source>
          <target state="translated">네이티브 DOM 유효성 검사 UI</target>
        </trans-unit>
        <trans-unit id="3cd6eb0659a1205c3d2f1ffbb5b2fe40d9662271" translate="yes" xml:space="preserve">
          <source>Native HTML elements capture a number of standard interaction patterns that are important to accessibility. When authoring Angular components, you should re-use these native elements directly when possible, rather than re-implementing well-supported behaviors.</source>
          <target state="translated">기본 HTML 요소는 접근성에 중요한 여러 표준 상호 작용 패턴을 캡처합니다. Angular 구성 요소를 제작할 때는 지원되는 동작을 다시 구현하지 않고 가능한 경우 이러한 기본 요소를 직접 재사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa7431b75f62e3afb7b428a378241bb10eefd2d8" translate="yes" xml:space="preserve">
          <source>Navigate based on the provided URL, which must be absolute.</source>
          <target state="translated">제공된 URL을 기준으로 탐색하십시오. 절대적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f00a310453dd24d0871c004718114fd725896517" translate="yes" xml:space="preserve">
          <source>Navigate based on the provided array of commands and a starting point. If no starting route is provided, the navigation is absolute.</source>
          <target state="translated">제공된 명령 배열과 시작점을 기준으로 탐색합니다. 출발 경로가 제공되지 않으면 탐색이 절대적입니다.</target>
        </trans-unit>
        <trans-unit id="bcb28231ae5f2e6c19b1274bbb244e4f8f8c72f0" translate="yes" xml:space="preserve">
          <source>Navigate imperatively from one component to another.</source>
          <target state="translated">한 구성 요소에서 다른 구성 요소로 반드시 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="afb677fe70fdcfa21d17515809a52b37d92143ff" translate="yes" xml:space="preserve">
          <source>Navigate the Component Tree with DI</source>
          <target state="translated">DI로 컴포넌트 트리 탐색</target>
        </trans-unit>
        <trans-unit id="801cddba8606ab904bff03cf42dc9bb7afdbae2f" translate="yes" xml:space="preserve">
          <source>Navigate the component tree with DI</source>
          <target state="translated">DI로 컴포넌트 트리 탐색</target>
        </trans-unit>
        <trans-unit id="054bf40cd5a09bac00514f6220f471f85443770e" translate="yes" xml:space="preserve">
          <source>Navigate to crisis list with a relative URL</source>
          <target state="translated">상대 URL을 사용하여 위기 목록으로 이동</target>
        </trans-unit>
        <trans-unit id="eac113305c9e93a9fafdff869950c44bded467f6" translate="yes" xml:space="preserve">
          <source>Navigate to the &lt;em&gt;Crisis Center&lt;/em&gt; and click &quot;Contact&quot;. you should see something like the following URL in the browser address bar.</source>
          <target state="translated">&lt;em&gt;위기 센터로&lt;/em&gt; 이동하여 &quot;연락처&quot;를 클릭하십시오. 브라우저 주소 표시 줄에 다음 URL과 같은 것이 보일 것입니다.</target>
        </trans-unit>
        <trans-unit id="de7126ba9a6d514985d538d255b366d741dfb956" translate="yes" xml:space="preserve">
          <source>Navigate to the default route when the app launches with an empty path.</source>
          <target state="translated">앱이 빈 경로로 시작되면 기본 경로로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="1b717a0f8976d0d8a1e5070b6003d01d44ed82ed" translate="yes" xml:space="preserve">
          <source>Navigate to the workspace folder, such as &lt;code&gt;my-app&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;my-app&lt;/code&gt; 과 같은 작업 공간 폴더로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="a3a585929b5d0ab87bf81346f380701a83cd3d88" translate="yes" xml:space="preserve">
          <source>Navigate to your Angular project directory.</source>
          <target state="translated">Angular 프로젝트 디렉터리로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="4518e36712637adff17a3524e56ca5f8ec3f952b" translate="yes" xml:space="preserve">
          <source>Navigates back in the platform's history.</source>
          <target state="translated">플랫폼 히스토리로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="44c635e70030c2a900ac2aefff93eea69863e5e9" translate="yes" xml:space="preserve">
          <source>Navigates forward in the platform's history.</source>
          <target state="translated">플랫폼 히스토리를 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="cb9de340b9da199ffa392dea34f8fcd85de53985" translate="yes" xml:space="preserve">
          <source>Navigates to a view using an absolute route path.</source>
          <target state="translated">절대 경로 경로를 사용하여보기로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="82436f50f9049884de9b6c3ba1b99e9bb2c9a879" translate="yes" xml:space="preserve">
          <source>Navigating back to the list component</source>
          <target state="translated">목록 구성 요소로 다시 탐색</target>
        </trans-unit>
        <trans-unit id="427f52baedb8cb5c0cd34a88518a1547a8819064" translate="yes" xml:space="preserve">
          <source>Navigating imperatively from one component to another.</source>
          <target state="translated">한 구성 요소에서 다른 구성 요소로 필수적으로 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="0c008352e202507d43afb72eafc5744d9a6d7dc5" translate="yes" xml:space="preserve">
          <source>Navigating to a component (&lt;em&gt;Heroes&lt;/em&gt; link to &quot;Heroes List&quot;).</source>
          <target state="translated">구성 요소 탐색 ( &lt;em&gt;영웅&lt;/em&gt; 은 &quot;영웅 목록&quot;에 연결됩니다).</target>
        </trans-unit>
        <trans-unit id="c20b119c54829ceba5297456fc93df8fbc3a285b" translate="yes" xml:space="preserve">
          <source>Navigating to hero details</source>
          <target state="translated">영웅 세부 정보로 이동</target>
        </trans-unit>
        <trans-unit id="cf03cf2e9cdf95a20af09137dfb9071db0c31bf2" translate="yes" xml:space="preserve">
          <source>Navigation</source>
          <target state="translated">Navigation</target>
        </trans-unit>
        <trans-unit id="0503c11edd28859dcfc3851d2db9b7108c99b553" translate="yes" xml:space="preserve">
          <source>Navigation via &lt;code&gt;routerLinks&lt;/code&gt; works correctly because they use the native anchor (&lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routerlinkwithhref&quot;&gt;a&lt;/a&gt;&amp;gt;&lt;/code&gt;) tags. You can go from the Dashboard to the Heroes page and back. You can click a hero on the Dashboard page to display its Details page.</source>
          <target state="translated">를 통해 탐색 &lt;code&gt;routerLinks&lt;/code&gt; 는 그들이 네이티브 앵커 (사용하기 때문에 제대로 작동 &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routerlinkwithhref&quot;&gt;a&lt;/a&gt;&amp;gt;&lt;/code&gt; ) 태그를. 대시 보드에서 영웅 페이지로 갈 수 있습니다. 대시 보드 페이지에서 영웅을 클릭하면 세부 정보 페이지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0b244a3e111e213e42f3366acc0ad983d7d0d78d" translate="yes" xml:space="preserve">
          <source>Navigation via &lt;code&gt;routerLinks&lt;/code&gt; works correctly because they use the native anchor (&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;) tags. You can go from the Dashboard to the Heroes page and back. You can click a hero on the Dashboard page to display its Details page.</source>
          <target state="translated">&lt;code&gt;routerLinks&lt;/code&gt; 를 통한 탐색 은 기본 앵커 ( &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; ) 태그 를 사용하기 때문에 올바르게 작동합니다 . 대시 보드에서 Heroes 페이지로 이동할 수 있습니다. 대시 보드 페이지에서 영웅을 클릭하여 세부 정보 페이지를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72b016e5e26cd3db8835ca10b9c9a3a1e8b5ff4e" translate="yes" xml:space="preserve">
          <source>NavigationBehaviorOptions</source>
          <target state="translated">NavigationBehaviorOptions</target>
        </trans-unit>
        <trans-unit id="759a28ebbc0d91e90943f8fd93691e9a220b42f4" translate="yes" xml:space="preserve">
          <source>NavigationBehaviorOptions#replaceUrl</source>
          <target state="translated">NavigationBehaviorOptions#replaceUrl</target>
        </trans-unit>
        <trans-unit id="b29602a054dd5a59680ae3377b5cddac939c04d9" translate="yes" xml:space="preserve">
          <source>NavigationBehaviorOptions#skipLocationChange</source>
          <target state="translated">NavigationBehaviorOptions#skipLocationChange</target>
        </trans-unit>
        <trans-unit id="02e50a4e01957bfa9a03fad077c09da68486f0d8" translate="yes" xml:space="preserve">
          <source>NavigationBehaviorOptions#state</source>
          <target state="translated">NavigationBehaviorOptions#state</target>
        </trans-unit>
        <trans-unit id="f6f45edabb536117eaaa8a31a3009ee45b02798c" translate="yes" xml:space="preserve">
          <source>NavigationCancel</source>
          <target state="translated">NavigationCancel</target>
        </trans-unit>
        <trans-unit id="3df2bbafb8bef3ad3c14903257e2b80c2ecf4d7f" translate="yes" xml:space="preserve">
          <source>NavigationEnd</source>
          <target state="translated">NavigationEnd</target>
        </trans-unit>
        <trans-unit id="3c6b9a9761701b6696dc96c14cded08327b354ca" translate="yes" xml:space="preserve">
          <source>NavigationError</source>
          <target state="translated">NavigationError</target>
        </trans-unit>
        <trans-unit id="5537ca588f865cbeab3cdfff2f7d54ef22a4b2fa" translate="yes" xml:space="preserve">
          <source>NavigationExtras</source>
          <target state="translated">NavigationExtras</target>
        </trans-unit>
        <trans-unit id="b70bac96f45923a632597d1d0749305fa7c5df28" translate="yes" xml:space="preserve">
          <source>NavigationExtras#preserveQueryParams has been removed from &lt;code&gt;@angular/router&lt;/code&gt;.</source>
          <target state="translated">NavigationExtras # preserveQueryParams가 &lt;code&gt;@angular/router&lt;/code&gt; 에서 제거되었습니다 .</target>
        </trans-unit>
        <trans-unit id="1a9c98c134db2cf2bf2aca63b0b8e192816b3996" translate="yes" xml:space="preserve">
          <source>NavigationStart</source>
          <target state="translated">NavigationStart</target>
        </trans-unit>
        <trans-unit id="45c7f55490f4d99e23fc1cb2f73c00322d0d19be" translate="yes" xml:space="preserve">
          <source>Nearby tests can reveal how a part works in context.</source>
          <target state="translated">근거리 테스트를 통해 부품이 어떻게 작동하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08ac0f840e3c990cb29508186b00fbf0c6c41cf3" translate="yes" xml:space="preserve">
          <source>Negative glob patterns are not supported.</source>
          <target state="translated">네거티브 글로브 패턴은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ab1f3cff45310ffbcb338033e822fd00c603e04" translate="yes" xml:space="preserve">
          <source>Neither &lt;code&gt;tap&lt;/code&gt; nor &lt;code&gt;finalize&lt;/code&gt; touch the values of the observable stream returned to the caller.</source>
          <target state="translated">어느 &lt;code&gt;tap&lt;/code&gt; 도 &lt;code&gt;finalize&lt;/code&gt; 호출자에게 반환 관찰 스트림의 값을 누릅니다.</target>
        </trans-unit>
        <trans-unit id="a660d66d678c2aa12932b6114b6a06a470213bb0" translate="yes" xml:space="preserve">
          <source>Nested &lt;em&gt;#docregions&lt;/em&gt;</source>
          <target state="translated">중첩 된 &lt;em&gt;#docregions&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8471e4625a027b35641c7d539e57cd28b22856d9" translate="yes" xml:space="preserve">
          <source>Nested component tests</source>
          <target state="translated">중첩 된 컴포넌트 테스트</target>
        </trans-unit>
        <trans-unit id="02ab9a0c82c26f180ecdcc2524a370078d4cdf6f" translate="yes" xml:space="preserve">
          <source>Nested service dependencies</source>
          <target state="translated">중첩 된 서비스 종속성</target>
        </trans-unit>
        <trans-unit id="91890a92af602dc34a0759b4044a9376f87b16a8" translate="yes" xml:space="preserve">
          <source>Nesting plural and select ICU expressions</source>
          <target state="translated">복수형 중첩 및 ICU 표현식 선택</target>
        </trans-unit>
        <trans-unit id="164c2396f149b90697b41fd738465acdad9c6bc0" translate="yes" xml:space="preserve">
          <source>Nesting routes</source>
          <target state="translated">중첩 경로</target>
        </trans-unit>
        <trans-unit id="1bd711a21d476e6fe66700859fd27013606d0d82" translate="yes" xml:space="preserve">
          <source>Netlify</source>
          <target state="translated">Netlify</target>
        </trans-unit>
        <trans-unit id="16ec400266d5ef58ca82e995098af63f1923ec9d" translate="yes" xml:space="preserve">
          <source>Never directly import lazy loaded folders</source>
          <target state="translated">지연로드 된 폴더를 직접 가져 오지 마십시오</target>
        </trans-unit>
        <trans-unit id="6403f2b7eb2aaafe6de34cbf2a029b01afebc512" translate="yes" xml:space="preserve">
          <source>New</source>
          <target state="translated">New</target>
        </trans-unit>
        <trans-unit id="988a9c9b5e8c90eb5a3e86aba8f04a9c70f8271f" translate="yes" xml:space="preserve">
          <source>New &lt;a href=&quot;i18n#localize-config&quot;&gt;localization option&lt;/a&gt; in version 9 and later.</source>
          <target state="translated">버전 9 이상에서 새로운 &lt;a href=&quot;i18n#localize-config&quot;&gt;현지화 옵션&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cbfac537ff6998d464404c7101d3e12dcf9ab187" translate="yes" xml:space="preserve">
          <source>New &lt;a href=&quot;template-expression-operators&quot;&gt;template expression operators&lt;/a&gt;, such as &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;?.&lt;/code&gt; and &lt;code&gt;!&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; 와 같은 새로운 &lt;a href=&quot;template-expression-operators&quot;&gt;템플릿 표현식 연산자 &lt;/a&gt;, &lt;code&gt;?.&lt;/code&gt; 그리고 &lt;code&gt;!&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9fc705094d287067f1988a6a0801f2814fac8b45" translate="yes" xml:space="preserve">
          <source>New &lt;a href=&quot;template-syntax#expression-operators&quot;&gt;template expression operators&lt;/a&gt;, such as &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;?.&lt;/code&gt; and &lt;code&gt;!&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;a href=&quot;template-syntax#expression-operators&quot;&gt;템플리트 표현식 연산자&lt;/a&gt; (예 : &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;?.&lt;/code&gt; 그리고 &lt;code&gt;!&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f5a752db05415c204941e38b09f34304b811b7c7" translate="yes" xml:space="preserve">
          <source>New Breaking Changes</source>
          <target state="translated">새로운 주요 변경 사항</target>
        </trans-unit>
        <trans-unit id="eab073fef5e21d102683caab1a7a85b6bb5e9bc1" translate="yes" xml:space="preserve">
          <source>New Deprecations</source>
          <target state="translated">새로운 지원 중단</target>
        </trans-unit>
        <trans-unit id="b93311a285cb539a2af7faf2aa3c20452cd7b907" translate="yes" xml:space="preserve">
          <source>New Removals of Deprecated APIs</source>
          <target state="translated">더 이상 사용되지 않는 API의 새로운 제거</target>
        </trans-unit>
        <trans-unit id="6499c7afe8658c4357e133e2d725379e590d06cd" translate="yes" xml:space="preserve">
          <source>New code</source>
          <target state="translated">새로운 코드</target>
        </trans-unit>
        <trans-unit id="3d9d5612da2d5b4b00ea65cc9544cb150870d63e" translate="yes" xml:space="preserve">
          <source>New instances</source>
          <target state="translated">새로운 인스턴스</target>
        </trans-unit>
        <trans-unit id="faf5319f3ab931a2424080ebd66686013025fb48" translate="yes" xml:space="preserve">
          <source>New locale id</source>
          <target state="translated">새로운 로캘 ID</target>
        </trans-unit>
        <trans-unit id="2272b187b02a451ebb5ad8639f2bf94e07550870" translate="yes" xml:space="preserve">
          <source>New to web development?</source>
          <target state="translated">웹 개발이 처음이십니까?</target>
        </trans-unit>
        <trans-unit id="25b0b46ee946b39e6834ebff44b402c22e9b2133" translate="yes" xml:space="preserve">
          <source>Next inject the activated route service:</source>
          <target state="translated">다음으로 활성화 된 경로 서비스를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="dc8f1ce4cebeca9a38c685a3b23068407d2e91a9" translate="yes" xml:space="preserve">
          <source>Next is &lt;code&gt;QuestionControlService&lt;/code&gt;, a simple service for transforming the questions to a &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt;. In a nutshell, the form group consumes the metadata from the question model and allows you to specify default values and validation rules.</source>
          <target state="translated">다음은 &lt;code&gt;QuestionControlService&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 으로 변환하기위한 간단한 서비스 인 QuestionControlService 입니다. 간단히 말해서 양식 그룹은 질문 모델의 메타 데이터를 사용하며 기본값 및 유효성 검사 규칙을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11fc14203dd0f4441645a9c34d5dd022905f56e4" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="translated">다음 단계</target>
        </trans-unit>
        <trans-unit id="e54feaad576821078eba1e93f7c9c60ca70fb2c0" translate="yes" xml:space="preserve">
          <source>Next steps: tools and techniques</source>
          <target state="translated">다음 단계 : 도구 및 기술</target>
        </trans-unit>
        <trans-unit id="b2a1fb63b77a247c65e2949fd2731d2882b12b5e" translate="yes" xml:space="preserve">
          <source>Next, &lt;code&gt;AppRoutingModule&lt;/code&gt; exports &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; so it will be available throughout the app.</source>
          <target state="translated">다음으로 &lt;code&gt;AppRoutingModule&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; 을 내보내 므로 앱 전체에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e40a87bc30a63dbca742228db43c858138ed67f9" translate="yes" xml:space="preserve">
          <source>Next, add &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; along with &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; to the constructor for the &lt;code&gt;Animal Service&lt;/code&gt; in &lt;code&gt;child.component.ts&lt;/code&gt;. Here are &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; in the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; constructor :</source>
          <target state="translated">다음, 추가 &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; 와 함께 &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; 의 생성자에 &lt;code&gt;Animal Service&lt;/code&gt; 에 &lt;code&gt;child.component.ts&lt;/code&gt; . &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; 생성자의 &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; 및 &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; 는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="69578ad457abc165b824fd423ac47cbb49eb4578" translate="yes" xml:space="preserve">
          <source>Next, add a &lt;code&gt;data&lt;/code&gt; object to the routes for &lt;code&gt;HeroListComponent&lt;/code&gt; and &lt;code&gt;HeroDetailComponent&lt;/code&gt;. Transitions are based on &lt;code&gt;states&lt;/code&gt; and you use the &lt;code&gt;&lt;a href=&quot;../api/animations/animation&quot;&gt;animation&lt;/a&gt;&lt;/code&gt; data from the route to provide a named animation &lt;code&gt;&lt;a href=&quot;../api/animations/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; for the transitions.</source>
          <target state="translated">다음 으로 &lt;code&gt;HeroListComponent&lt;/code&gt; 및 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 에 대한 경로에 &lt;code&gt;data&lt;/code&gt; 개체를 추가합니다 . 전환은 &lt;code&gt;states&lt;/code&gt; 기반으로 하며 경로 의 &lt;code&gt;&lt;a href=&quot;../api/animations/animation&quot;&gt;animation&lt;/a&gt;&lt;/code&gt; 데이터 를 사용 하여 전환에 대해 명명 된 애니메이션 &lt;code&gt;&lt;a href=&quot;../api/animations/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="2cbe1b3e5150553c875832797ecdc536a1901705" translate="yes" xml:space="preserve">
          <source>Next, add a &lt;code&gt;data&lt;/code&gt; object to the routes for &lt;code&gt;HeroListComponent&lt;/code&gt; and &lt;code&gt;HeroDetailComponent&lt;/code&gt;. Transitions are based on &lt;code&gt;states&lt;/code&gt; and you'll use the &lt;code&gt;&lt;a href=&quot;../api/animations/animation&quot;&gt;animation&lt;/a&gt;&lt;/code&gt; data from the route to provide a named animation &lt;code&gt;&lt;a href=&quot;../api/animations/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; for the transitions.</source>
          <target state="translated">다음으로, &lt;code&gt;HeroListComponent&lt;/code&gt; 및 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 의 경로에 &lt;code&gt;data&lt;/code&gt; 객체를 추가하십시오 . 전환은 &lt;code&gt;states&lt;/code&gt; 기반으로 하며 경로 의 &lt;code&gt;&lt;a href=&quot;../api/animations/animation&quot;&gt;animation&lt;/a&gt;&lt;/code&gt; 데이터를 사용 하여 전환에 대한 명명 된 애니메이션 &lt;code&gt;&lt;a href=&quot;../api/animations/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="fbe6d180136a82d27c10482de8b67fe1e78e0fb9" translate="yes" xml:space="preserve">
          <source>Next, add a &lt;code&gt;deleteHero()&lt;/code&gt; method to &lt;code&gt;HeroService&lt;/code&gt; like this.</source>
          <target state="translated">다음 으로 &lt;code&gt;HeroService&lt;/code&gt; 같이 &lt;code&gt;deleteHero()&lt;/code&gt; 메소드를 HeroService에 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="ca91b2e786e0c6a170fc3962eee3d4548b237fa8" translate="yes" xml:space="preserve">
          <source>Next, add the following to &lt;code&gt;app.component.html&lt;/code&gt; to take advantage of content projection.</source>
          <target state="translated">그런 다음 &lt;code&gt;app.component.html&lt;/code&gt; 에 다음을 추가하여 컨텐츠 프로젝션을 활용하십시오.</target>
        </trans-unit>
        <trans-unit id="146403171474dcf7255cdeee43c31023cf1d1e42" translate="yes" xml:space="preserve">
          <source>Next, convert your current JavaScript files into TypeScript. Since TypeScript is a super-set of ECMAScript 2015, which in turn is a super-set of ECMAScript 5, you can simply switch the file extensions from &lt;code&gt;.js&lt;/code&gt; to &lt;code&gt;.ts&lt;/code&gt; and everything will work just like it did before. As the TypeScript compiler runs, it emits the corresponding &lt;code&gt;.js&lt;/code&gt; file for every &lt;code&gt;.ts&lt;/code&gt; file and the compiled JavaScript is what actually gets executed. If you start the project HTTP server with &lt;code&gt;npm start&lt;/code&gt;, you should see the fully functional application in your browser.</source>
          <target state="translated">그런 다음 현재 JavaScript 파일을 TypeScript로 변환하십시오. TypeScript는 ECMAScript 2015의 상위 세트이므로 ECMAScript 5의 상위 세트이므로 파일 확장자를 &lt;code&gt;.js&lt;/code&gt; 에서 &lt;code&gt;.ts&lt;/code&gt; 로 간단히 전환하면 모든 것이 이전처럼 작동합니다. TypeScript 컴파일러가 실행되면 모든 &lt;code&gt;.ts&lt;/code&gt; 파일에 해당하는 &lt;code&gt;.js&lt;/code&gt; 파일을 내보내고 컴파일 된 JavaScript가 실제로 실행됩니다. &lt;code&gt;npm start&lt;/code&gt; 로 프로젝트 HTTP 서버를 시작 하면 브라우저에 모든 기능을 갖춘 응용 프로그램이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="29f04404e03c09595b5fbbccda8157911c3d6215" translate="yes" xml:space="preserve">
          <source>Next, create an &lt;code&gt;addNewItem()&lt;/code&gt; method in the same component class:</source>
          <target state="translated">다음으로 동일한 컴포넌트 클래스에서 &lt;code&gt;addNewItem()&lt;/code&gt; 메소드를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="78e562daa79a3e6eee49cbc86a107a82253ffd45" translate="yes" xml:space="preserve">
          <source>Next, create an &lt;code&gt;app.module.ts&lt;/code&gt; file and add the following &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; class:</source>
          <target state="translated">다음으로 &lt;code&gt;app.module.ts&lt;/code&gt; 파일을 만들고 다음 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 클래스를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a14bd3e0ad6c2dc72723721eabbe8211d5f62a4" translate="yes" xml:space="preserve">
          <source>Next, define the behavior that should happen when the user clicks the button. Recall that it's the parent, product list component&amp;mdash;not the product alerts component&amp;mdash;that acts when the child raises the event. In &lt;code&gt;product-list.component.ts&lt;/code&gt;, define an &lt;code&gt;onNotify()&lt;/code&gt; method, similar to the &lt;code&gt;share()&lt;/code&gt; method:</source>
          <target state="translated">다음으로, 사용자가 버튼을 클릭 할 때 발생하는 동작을 정의하십시오. 자식이 이벤트를 발생시킬 때 작동하는 것은 제품 알림 구성 요소가 아닌 상위 제품 목록 구성 요소라는 점을 상기하십시오. 에서는 &lt;code&gt;product-list.component.ts&lt;/code&gt; , 정의 &lt;code&gt;onNotify()&lt;/code&gt; 받는 유사한 방법 &lt;code&gt;share()&lt;/code&gt; 방법 :</target>
        </trans-unit>
        <trans-unit id="159e605a4cc3040ba1837fc4fc9937ebc9ada940" translate="yes" xml:space="preserve">
          <source>Next, generate the supporting components.</source>
          <target state="translated">다음으로 지원 구성 요소를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="02c66793fe3c348fdc1c4c83dd6b949eef1aae70" translate="yes" xml:space="preserve">
          <source>Next, implement the &lt;code&gt;&lt;a href=&quot;../api/router/route#canActivateChild&quot;&gt;canActivateChild&lt;/a&gt;()&lt;/code&gt; method which takes the same arguments as the &lt;code&gt;&lt;a href=&quot;../api/router/route#canActivate&quot;&gt;canActivate&lt;/a&gt;()&lt;/code&gt; method: an &lt;code&gt;&lt;a href=&quot;../api/router/activatedroutesnapshot&quot;&gt;ActivatedRouteSnapshot&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/router/routerstatesnapshot&quot;&gt;RouterStateSnapshot&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../api/router/route#canActivateChild&quot;&gt;canActivateChild&lt;/a&gt;()&lt;/code&gt; method can return an &lt;code&gt;Observable&amp;lt;boolean&amp;gt;&lt;/code&gt; or &lt;code&gt;Promise&amp;lt;boolean&amp;gt;&lt;/code&gt; for async checks and a &lt;code&gt;boolean&lt;/code&gt; for sync checks. This one returns a &lt;code&gt;boolean&lt;/code&gt;:</source>
          <target state="translated">다음으로, 구현 &lt;code&gt;&lt;a href=&quot;../api/router/route#canActivateChild&quot;&gt;canActivateChild&lt;/a&gt;()&lt;/code&gt; 는 AS 동일한 인수를 취하는 방법 &lt;code&gt;&lt;a href=&quot;../api/router/route#canActivate&quot;&gt;canActivate&lt;/a&gt;()&lt;/code&gt; : 방법 &lt;code&gt;&lt;a href=&quot;../api/router/activatedroutesnapshot&quot;&gt;ActivatedRouteSnapshot&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/router/routerstatesnapshot&quot;&gt;RouterStateSnapshot&lt;/a&gt;&lt;/code&gt; 를 . &lt;code&gt;&lt;a href=&quot;../api/router/route#canActivateChild&quot;&gt;canActivateChild&lt;/a&gt;()&lt;/code&gt; 메소드는 반환 할 &lt;code&gt;Observable&amp;lt;boolean&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;Promise&amp;lt;boolean&amp;gt;&lt;/code&gt; 비동기 검사 및 위해 &lt;code&gt;boolean&lt;/code&gt; 동기 수표. 이것은 하나를 반환 &lt;code&gt;boolean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27cf489723cd42794c2d0d2cfde2eff21f41545b" translate="yes" xml:space="preserve">
          <source>Next, implement the &lt;code&gt;canActivateChild()&lt;/code&gt; method which takes the same arguments as the &lt;code&gt;canActivate()&lt;/code&gt; method: an &lt;code&gt;&lt;a href=&quot;../api/router/activatedroutesnapshot&quot;&gt;ActivatedRouteSnapshot&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/router/routerstatesnapshot&quot;&gt;RouterStateSnapshot&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;canActivateChild()&lt;/code&gt; method can return an &lt;code&gt;Observable&amp;lt;boolean|&lt;a href=&quot;../api/router/urltree&quot;&gt;UrlTree&lt;/a&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;Promise&amp;lt;boolean|&lt;a href=&quot;../api/router/urltree&quot;&gt;UrlTree&lt;/a&gt;&amp;gt;&lt;/code&gt; for async checks and a &lt;code&gt;boolean&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../api/router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; for sync checks. This one returns either &lt;code&gt;true&lt;/code&gt; to allow the user to access the admin feature module or &lt;code&gt;&lt;a href=&quot;../api/router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; to redirect the user to the login page instead:</source>
          <target state="translated">다음으로 &lt;code&gt;canActivateChild()&lt;/code&gt; 메서드와 동일한 인수 인 &lt;code&gt;&lt;a href=&quot;../api/router/activatedroutesnapshot&quot;&gt;ActivatedRouteSnapshot&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/router/routerstatesnapshot&quot;&gt;RouterStateSnapshot&lt;/a&gt;&lt;/code&gt; 을 사용하는 &lt;code&gt;canActivate()&lt;/code&gt; 메서드 를 구현 합니다. &lt;code&gt;canActivateChild()&lt;/code&gt; 메서드는 반환 할 수 있습니다 &lt;code&gt;Observable&amp;lt;boolean|&lt;a href=&quot;../api/router/urltree&quot;&gt;UrlTree&lt;/a&gt;&amp;gt;&lt;/code&gt; &lt;a href=&quot;../api/router/urltree&quot;&gt;UrlTree&lt;/a&gt; &amp;gt; 또는 &lt;code&gt;Promise&amp;lt;boolean|&lt;a href=&quot;../api/router/urltree&quot;&gt;UrlTree&lt;/a&gt;&amp;gt;&lt;/code&gt; 비동기 검사를위한 &lt;a href=&quot;../api/router/urltree&quot;&gt;UrlTree&lt;/a&gt; &amp;gt; 및 동기화 검사를위한 &lt;code&gt;boolean&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../api/router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; . 이것은 사용자가 관리 기능 모듈에 액세스 할 수 있도록 &lt;code&gt;true&lt;/code&gt; 를 반환하거나 대신 사용자를 로그인 페이지로 리디렉션하는 &lt;code&gt;&lt;a href=&quot;../api/router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="1ce7cdbebf308621f531b33a618f458772e93ac6" translate="yes" xml:space="preserve">
          <source>Next, import the &lt;code&gt;AdminModule&lt;/code&gt; into &lt;code&gt;app.module.ts&lt;/code&gt; and add it to the &lt;code&gt;imports&lt;/code&gt; array to register the admin routes.</source>
          <target state="translated">다음으로, 수입 &lt;code&gt;AdminModule&lt;/code&gt; 을 에 &lt;code&gt;app.module.ts&lt;/code&gt; 과에 추가 &lt;code&gt;imports&lt;/code&gt; 배열에 하여 관리 경로를 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="1ba62cbb6eeadeb0cb95f3e2261d2a087737673f" translate="yes" xml:space="preserve">
          <source>Next, in the &lt;code&gt;AppComponent&lt;/code&gt;, &lt;code&gt;app.component.html&lt;/code&gt;, add the tag &lt;code&gt;&amp;lt;app-customer-dashboard&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">그런 다음 &lt;code&gt;AppComponent&lt;/code&gt; , &lt;code&gt;app.component.html&lt;/code&gt; 에서 태그를 추가하십시오. &lt;code&gt;&amp;lt;app-customer-dashboard&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ceee8a4c64453c5c9dc92d2e36c028a333a12d42" translate="yes" xml:space="preserve">
          <source>Next, in the child component template, add the following:</source>
          <target state="translated">다음으로 하위 구성 요소 템플리트에서 다음을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="437afaf0aff86e6b37d1987d254eecd1a1c7956e" translate="yes" xml:space="preserve">
          <source>Next, in the component that you want to navigate to, import the following members.</source>
          <target state="translated">다음으로 탐색하려는 구성 요소에서 다음 멤버를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="51909826c31cf2634e91d573fc593a2ca3b40e50" translate="yes" xml:space="preserve">
          <source>Next, in the parent component class, &lt;code&gt;app.component.ts&lt;/code&gt;, designate a value for &lt;code&gt;currentItem&lt;/code&gt;:</source>
          <target state="translated">다음으로 부모 컴포넌트 클래스 &lt;code&gt;app.component.ts&lt;/code&gt; 에서 &lt;code&gt;currentItem&lt;/code&gt; 의 값을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="733d4f56880fe5b33b54901da865905016d628e2" translate="yes" xml:space="preserve">
          <source>Next, in the parent's template, bind the parent's method to the child's event. Put the child selector, here &lt;code&gt;&amp;lt;app-item-output&amp;gt;&lt;/code&gt;, within the parent component's template, &lt;code&gt;app.component.html&lt;/code&gt;.</source>
          <target state="translated">그런 다음 부모 템플릿에서 부모의 메서드를 자식 이벤트에 바인딩합니다. 자식 구성 요소 ( 여기 &lt;code&gt;&amp;lt;app-item-output&amp;gt;&lt;/code&gt; )를 부모 구성 요소의 템플릿 인 &lt;code&gt;app.component.html&lt;/code&gt; 안에 넣으십시오 .</target>
        </trans-unit>
        <trans-unit id="16bbcfa504ba8fa467c5555baf8b098e75790d4b" translate="yes" xml:space="preserve">
          <source>Next, inject the child &lt;code&gt;CountdownTimerComponent&lt;/code&gt; into the private &lt;code&gt;timerComponent&lt;/code&gt; property via the &lt;code&gt;@&lt;a href=&quot;../api/core/viewchild&quot;&gt;ViewChild&lt;/a&gt;&lt;/code&gt; property decoration.</source>
          <target state="translated">그런 다음 &lt;code&gt;@&lt;a href=&quot;../api/core/viewchild&quot;&gt;ViewChild&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/viewchild&quot;&gt;CountChild&lt;/a&gt; 속성 장식을 통해 자식 &lt;code&gt;CountdownTimerComponent&lt;/code&gt; 를 개인 &lt;code&gt;timerComponent&lt;/code&gt; 속성에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="f71324dbd9f317e01f00a710d2d8e578d23b46a8" translate="yes" xml:space="preserve">
          <source>Next, make a change to the application, and watch the service worker install the update.</source>
          <target state="translated">그런 다음 응용 프로그램을 변경하고 서비스 담당자가 업데이트를 설치하는 것을보십시오.</target>
        </trans-unit>
        <trans-unit id="acfae61a91a6b0c1993304859ab3d89fe934c5b5" translate="yes" xml:space="preserve">
          <source>Next, make sure your &lt;code&gt;child.component.html&lt;/code&gt; contains the following:</source>
          <target state="translated">다음으로 &lt;code&gt;child.component.html&lt;/code&gt; 에 다음이 포함되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="39b90f5c6fb337d84f53f2af04d454c24099f6d0" translate="yes" xml:space="preserve">
          <source>Next, open &lt;code&gt;admin-routing.module.ts&lt;/code&gt;, import the &lt;code&gt;AuthGuard&lt;/code&gt; class, and update the admin route with a &lt;code&gt;&lt;a href=&quot;../api/router/route#canActivate&quot;&gt;canActivate&lt;/a&gt;&lt;/code&gt; guard property that references it:</source>
          <target state="translated">다음으로 &lt;code&gt;admin-routing.module.ts&lt;/code&gt; 를 열고 &lt;code&gt;AuthGuard&lt;/code&gt; 클래스를 가져온 다음 참조 하는 &lt;code&gt;&lt;a href=&quot;../api/router/route#canActivate&quot;&gt;canActivate&lt;/a&gt;&lt;/code&gt; guard 속성으로 관리 경로를 업데이트하십시오 .</target>
        </trans-unit>
        <trans-unit id="4bcd6930b2e49c850175559793b3ede563e638de" translate="yes" xml:space="preserve">
          <source>Next, open &lt;code&gt;admin-routing.module.ts&lt;/code&gt;, import the &lt;code&gt;AuthGuard&lt;/code&gt; class, and update the admin route with a &lt;code&gt;canActivate&lt;/code&gt; guard property that references it:</source>
          <target state="translated">다음으로, &lt;code&gt;admin-routing.module.ts&lt;/code&gt; 를 열고 &lt;code&gt;AuthGuard&lt;/code&gt; 클래스를 가져온 다음 이를 참조 하는 &lt;code&gt;canActivate&lt;/code&gt; 가드 속성으로 관리 경로를 업데이트 합니다.</target>
        </trans-unit>
        <trans-unit id="c5a49cf86820a39d8d891d616d600b6841ae4c90" translate="yes" xml:space="preserve">
          <source>Next, pass this request object to the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#request&quot;&gt;HttpClient.request()&lt;/a&gt;&lt;/code&gt; method, which returns an &lt;code&gt;Observable&lt;/code&gt; of &lt;code&gt;HttpEvents&lt;/code&gt; (the same events processed by &lt;a href=&quot;http#interceptor-events&quot;&gt;interceptors&lt;/a&gt;).</source>
          <target state="translated">다음에,이 요구에 객체를 전달 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#request&quot;&gt;HttpClient.request()&lt;/a&gt;&lt;/code&gt; 반환있어서, &lt;code&gt;Observable&lt;/code&gt; 의 &lt;code&gt;HttpEvents&lt;/code&gt; (처리 동일한 이벤트 &lt;a href=&quot;http#interceptor-events&quot;&gt;인터셉터&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9238d3dd88f48f6f024b03a222d53eac661496c6" translate="yes" xml:space="preserve">
          <source>Next, pass this request object to the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#request&quot;&gt;HttpClient.request()&lt;/a&gt;&lt;/code&gt; method, which returns an &lt;code&gt;Observable&lt;/code&gt; of &lt;code&gt;HttpEvents&lt;/code&gt;, the same events processed by interceptors:</source>
          <target state="translated">다음으로,이 요청 오브젝트를 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#request&quot;&gt;HttpClient.request()&lt;/a&gt;&lt;/code&gt; 메소드에 전달하십시오.이 메소드 는 인터셉터가 처리 한 동일한 이벤트 인 &lt;code&gt;HttpEvents&lt;/code&gt; 의 &lt;code&gt;Observable&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="433326a8e38824bb8f9a3cd7191eee156cde4fcf" translate="yes" xml:space="preserve">
          <source>Next, provide the interceptor in the providers for the server &lt;code&gt;AppModule&lt;/code&gt;.</source>
          <target state="translated">다음으로 서버 &lt;code&gt;AppModule&lt;/code&gt; 의 제공자에서 인터셉터를 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="7081de89008cec58d5674fcc6bbf610061f2490f" translate="yes" xml:space="preserve">
          <source>Next, specify that interface as the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#get&quot;&gt;HttpClient.get()&lt;/a&gt;&lt;/code&gt; call's type parameter in the service.</source>
          <target state="translated">그런 다음 해당 인터페이스를 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#get&quot;&gt;HttpClient.get()&lt;/a&gt;&lt;/code&gt; 으로 지정하십시오. 호출의 유형 매개 변수로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="e5070e8750ad2ec511978e2fe0b2557afd4ace02" translate="yes" xml:space="preserve">
          <source>Next, still in the &lt;code&gt;AppModule&lt;/code&gt;, add &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; to the &lt;code&gt;imports&lt;/code&gt; array:</source>
          <target state="translated">다음으로 여전히 &lt;code&gt;AppModule&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;imports&lt;/code&gt; 배열에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c52312ed7a332374c1934fe59d2405fafdb84b4" translate="yes" xml:space="preserve">
          <source>Next, still in the child, decorate a property with &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; in the component class. The following example &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; is called &lt;code&gt;newItemEvent&lt;/code&gt; and its type is &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt;, which means it's an event.</source>
          <target state="translated">다음으로 여전히 자식 에서 구성 요소 클래스에서 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; 으로 속성을 장식하십시오 . 다음 예제 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; 은 &lt;code&gt;newItemEvent&lt;/code&gt; 라고 하며 유형은 &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; 입니다 . 이는 이벤트임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e01f7c08a26720fb75063452fd9b610ef7552b09" translate="yes" xml:space="preserve">
          <source>Next, take a look at &lt;code&gt;customers.module.ts&lt;/code&gt;. If you&amp;rsquo;re using the CLI and following the steps outlined in this page, you don&amp;rsquo;t have to do anything here.</source>
          <target state="translated">다음으로 &lt;code&gt;customers.module.ts&lt;/code&gt; 를 살펴보십시오. . CLI를 사용 중이고이 페이지에 설명 된 단계를 따르는 경우 여기에서 아무 것도 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9a2ee25a23256be93a91a2082abdd391edc78b46" translate="yes" xml:space="preserve">
          <source>Next, take a look at the &lt;code&gt;customers.module.ts&lt;/code&gt; file. If you&amp;rsquo;re using the CLI and following the steps outlined in this page, you don&amp;rsquo;t have to do anything here.</source>
          <target state="translated">다음으로 &lt;code&gt;customers.module.ts&lt;/code&gt; 파일을 살펴보십시오 . CLI를 사용하고이 페이지에 설명 된 단계를 따르는 경우 여기에서 아무것도 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="35af59e41a5deccc29e482c85e1d22e41d6f38c7" translate="yes" xml:space="preserve">
          <source>Next, the code declares the property of &lt;code&gt;parentItem&lt;/code&gt; in its component class, in this case &lt;code&gt;AppComponent&lt;/code&gt;. In this example the type of &lt;code&gt;childItem&lt;/code&gt; is &lt;code&gt;string&lt;/code&gt;, so &lt;code&gt;parentItem&lt;/code&gt; needs to be a string. Here, &lt;code&gt;parentItem&lt;/code&gt; has the string value of &lt;code&gt;lamp&lt;/code&gt;.</source>
          <target state="translated">다음으로 코드는 해당 구성 요소 클래스 (이 경우 &lt;code&gt;AppComponent&lt;/code&gt; ) 에서 &lt;code&gt;parentItem&lt;/code&gt; 의 속성을 선언합니다 . 이 예에서 &lt;code&gt;childItem&lt;/code&gt; 유형 은 &lt;code&gt;string&lt;/code&gt; 이므로 &lt;code&gt;parentItem&lt;/code&gt; 은 문자열 이어야합니다. 여기서 &lt;code&gt;parentItem&lt;/code&gt; 은 &lt;code&gt;lamp&lt;/code&gt; 문자열 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="12d0d63dcc69960806f54f071a944f232044d099" translate="yes" xml:space="preserve">
          <source>Next, there are two methods, &lt;code&gt;dec()&lt;/code&gt; to decrease the font size and &lt;code&gt;inc()&lt;/code&gt; to increase the font size. These two methods use &lt;code&gt;resize()&lt;/code&gt; to change the value of the &lt;code&gt;size&lt;/code&gt; property within min/max value constraints, and to emit an event that conveys the new &lt;code&gt;size&lt;/code&gt; value.</source>
          <target state="translated">다음으로 글꼴 크기를 줄이는 &lt;code&gt;dec()&lt;/code&gt; 와 글꼴 크기 를 늘리는 &lt;code&gt;inc()&lt;/code&gt; 두 가지 메서드가 있습니다 . 이 두 메서드는 &lt;code&gt;resize()&lt;/code&gt; 를 사용하여 최소 / 최대 값 제약 조건 내 에서 &lt;code&gt;size&lt;/code&gt; 속성 값을 변경 하고 새 &lt;code&gt;size&lt;/code&gt; 값 을 전달하는 이벤트를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="9a052540461ab5d2b2db93b6978d55fc263fc2ce" translate="yes" xml:space="preserve">
          <source>Next, to provide better user experience, we show an appropriate error message when the form is invalid.</source>
          <target state="translated">다음으로, 더 나은 사용자 경험을 제공하기 위해 양식이 유효하지 않은 경우 적절한 오류 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="98110e1becf59d469e0d99a7be1756f248e72da0" translate="yes" xml:space="preserve">
          <source>Next, update the &lt;code&gt;HeroesModule&lt;/code&gt; metadata.</source>
          <target state="translated">다음으로 &lt;code&gt;HeroesModule&lt;/code&gt; 메타 데이터를 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="ccef43a8758ac0145668f499e8bec5e8aac64b3a" translate="yes" xml:space="preserve">
          <source>Next, update the &lt;code&gt;app.module.ts&lt;/code&gt; file by removing &lt;code&gt;RouterModule.forRoot&lt;/code&gt; in the &lt;code&gt;imports&lt;/code&gt; array.</source>
          <target state="translated">다음으로 &lt;code&gt;imports&lt;/code&gt; 배열 에서 &lt;code&gt;RouterModule.forRoot&lt;/code&gt; 를 제거 하여 &lt;code&gt;app.module.ts&lt;/code&gt; 파일을 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="f1e950c928e2e7ecce05f57f8953855497127af3" translate="yes" xml:space="preserve">
          <source>Next, update the &lt;code&gt;app.module.ts&lt;/code&gt; file, removing &lt;code&gt;RouterModule.forRoot&lt;/code&gt; in the &lt;code&gt;imports&lt;/code&gt; array.</source>
          <target state="translated">다음으로, &lt;code&gt;imports&lt;/code&gt; 배열 에서 &lt;code&gt;RouterModule.forRoot&lt;/code&gt; 를 제거 하여 &lt;code&gt;app.module.ts&lt;/code&gt; 파일을 업데이트하십시오 .</target>
        </trans-unit>
        <trans-unit id="8b2be34383d8449d30e79266ca4b72b931faa752" translate="yes" xml:space="preserve">
          <source>Next, update the template. At the moment it displays the hero's &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt;. Fix that to display only the hero's &lt;code&gt;name&lt;/code&gt; property.</source>
          <target state="translated">다음으로 템플릿을 업데이트하십시오. 현재 영웅의 &lt;code&gt;id&lt;/code&gt; 와 &lt;code&gt;name&lt;/code&gt; 을 표시합니다 . 영웅의 &lt;code&gt;name&lt;/code&gt; 속성 만 표시하도록 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f382d5fee30f4adf3e70cf9278956bd6336fceb" translate="yes" xml:space="preserve">
          <source>Next, we have to add the directive to the html template. Since the validator must be registered at the highest level in the form, we put the directive on the &lt;code&gt;form&lt;/code&gt; tag.</source>
          <target state="translated">다음으로, 지시문을 html 템플릿에 추가해야합니다. 유효성 검사기는 양식에서 최상위 수준으로 등록해야하므로 &lt;code&gt;form&lt;/code&gt; 태그 에 지시문을 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="a45433b56d573a43bfea8e8b40a108062db3dc5f" translate="yes" xml:space="preserve">
          <source>Next, you&amp;rsquo;ll need a feature module with a component to route to. To make one, enter the following command in the terminal, where &lt;code&gt;customers&lt;/code&gt; is the name of the feature module, and &lt;code&gt;customer-list&lt;/code&gt; is the route path for loading the &lt;code&gt;customers&lt;/code&gt; component:</source>
          <target state="translated">다음으로, 라우팅 할 컴포넌트가있는 기능 모듈이 필요합니다. 하나를 작성하려면 터미널에서 다음 명령을 입력하십시오. 여기서 &lt;code&gt;customers&lt;/code&gt; 는 기능 모듈의 이름이고 &lt;code&gt;customer-list&lt;/code&gt; 는 &lt;code&gt;customers&lt;/code&gt; 을로드하기위한 경로입니다. 구성 요소 .</target>
        </trans-unit>
        <trans-unit id="30a4207178eea2c03fa73fdeeb75c2e0dbe927e3" translate="yes" xml:space="preserve">
          <source>Next, you&amp;rsquo;ll need a feature module with a component to route to. To make one, enter the following command in the terminal, where &lt;code&gt;customers&lt;/code&gt; is the name of the feature module. The path for loading the &lt;code&gt;customers&lt;/code&gt; feature modules is also &lt;code&gt;customers&lt;/code&gt; because it is specified with the &lt;code&gt;--route&lt;/code&gt; option:</source>
          <target state="translated">다음으로 라우팅 할 구성 요소가있는 기능 모듈이 필요합니다. 만들려면 터미널에 다음 명령을 입력하십시오. 여기서 &lt;code&gt;customers&lt;/code&gt; 는 기능 모듈의 이름입니다. &lt;code&gt;customers&lt;/code&gt; 기능 모듈 을로드하는 경로 도 &lt;code&gt;--route&lt;/code&gt; 옵션으로 지정되기 때문에 &lt;code&gt;customers&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a96057b587190d68c3d35e191fa2ede8a5fda71" translate="yes" xml:space="preserve">
          <source>Next, you'll add a checkout form at the bottom of the &quot;Cart&quot; page.</source>
          <target state="translated">다음으로 &quot;카트&quot;페이지 하단에 체크 아웃 양식을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="07fddc141a40d546f782e352de75a718fa77dd61" translate="yes" xml:space="preserve">
          <source>Next, you'll bootstrap the application as a &lt;em&gt;hybrid application&lt;/em&gt; that supports both AngularJS and Angular components. After that, you can start converting the individual pieces to Angular.</source>
          <target state="translated">다음으로 AngularJS와 Angular 컴포넌트를 모두 지원 하는 &lt;em&gt;하이브리드 애플리케이션으로 애플리케이션&lt;/em&gt; 을 부트 스트랩합니다 . 그런 다음 개별 조각을 Angular로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f6a7f292bb2d34dbd24f570eb6ae36cda4a9b60" translate="yes" xml:space="preserve">
          <source>Next, you'll update the &lt;code&gt;HeroesModule&lt;/code&gt; metadata.</source>
          <target state="translated">다음으로 &lt;code&gt;HeroesModule&lt;/code&gt; 메타 데이터를 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="ea8bc738c3f2744292fff210de01e1a19b19be37" translate="yes" xml:space="preserve">
          <source>Next, you're targeting the &lt;code&gt;viewContainerRef&lt;/code&gt; that exists on this specific instance of the component. How do you know it's this specific instance? Because it's referring to &lt;code&gt;adHost&lt;/code&gt; and &lt;code&gt;adHost&lt;/code&gt; is the directive you set up earlier to tell Angular where to insert dynamic components.</source>
          <target state="translated">다음 으로이 특정 구성 요소 인스턴스에 존재 하는 &lt;code&gt;viewContainerRef&lt;/code&gt; 를 대상으로합니다 . 이 특정 인스턴스인지 어떻게 알 수 있습니까? &lt;code&gt;adHost&lt;/code&gt; 와 &lt;code&gt;adHost&lt;/code&gt; 를 참조하고 있기 때문에 어디 동적 요소를 삽입하는 각도에게 이전에 설정 한 지침이다.</target>
        </trans-unit>
        <trans-unit id="930eb31163a442c119ddb1c29beebf413aa587d6" translate="yes" xml:space="preserve">
          <source>NgClass</source>
          <target state="translated">NgClass</target>
        </trans-unit>
        <trans-unit id="0d21e79d490fb36429b0b5383645cbd92e7c485d" translate="yes" xml:space="preserve">
          <source>NgClassBase</source>
          <target state="translated">NgClassBase</target>
        </trans-unit>
        <trans-unit id="cd9579a5feabe299336ff967716146f9e748e162" translate="yes" xml:space="preserve">
          <source>NgComponentOutlet</source>
          <target state="translated">NgComponentOutlet</target>
        </trans-unit>
        <trans-unit id="3a340289aa623d264812176c87b9df65b745eace" translate="yes" xml:space="preserve">
          <source>NgControl</source>
          <target state="translated">NgControl</target>
        </trans-unit>
        <trans-unit id="b3e08af5e72c076c24ba32a201a892e6632cb131" translate="yes" xml:space="preserve">
          <source>NgControlStatus</source>
          <target state="translated">NgControlStatus</target>
        </trans-unit>
        <trans-unit id="b51a5a43dd26d66af41091781019c47195f9b60a" translate="yes" xml:space="preserve">
          <source>NgControlStatusGroup</source>
          <target state="translated">NgControlStatusGroup</target>
        </trans-unit>
        <trans-unit id="69619e32876644e9b1f5a2e22a9ef35084b08aca" translate="yes" xml:space="preserve">
          <source>NgElement</source>
          <target state="translated">NgElement</target>
        </trans-unit>
        <trans-unit id="835f1ff7eab741dfdcaf682956ac9649ed577345" translate="yes" xml:space="preserve">
          <source>NgElementConfig</source>
          <target state="translated">NgElementConfig</target>
        </trans-unit>
        <trans-unit id="98abd1d6e9741a567557dd4f65dccdf66d959765" translate="yes" xml:space="preserve">
          <source>NgElementConstructor</source>
          <target state="translated">NgElementConstructor</target>
        </trans-unit>
        <trans-unit id="836c0c8ba2c663fc3e59a2e9222f0246032f1f34" translate="yes" xml:space="preserve">
          <source>NgElementStrategy</source>
          <target state="translated">NgElementStrategy</target>
        </trans-unit>
        <trans-unit id="d381bec5e272dc31ba3247a1a00ea382b9a3ed51" translate="yes" xml:space="preserve">
          <source>NgElementStrategyEvent</source>
          <target state="translated">NgElementStrategyEvent</target>
        </trans-unit>
        <trans-unit id="4fe27239d38e87b6129179225480ede5cd8cf8fe" translate="yes" xml:space="preserve">
          <source>NgElementStrategyFactory</source>
          <target state="translated">NgElementStrategyFactory</target>
        </trans-unit>
        <trans-unit id="91fd7e01a74c4728b2f19ff04aea391d049f80c2" translate="yes" xml:space="preserve">
          <source>NgForOf</source>
          <target state="translated">NgForOf</target>
        </trans-unit>
        <trans-unit id="4dc7fbec31709e6db39e0116840dab3ee663f864" translate="yes" xml:space="preserve">
          <source>NgForOfContext</source>
          <target state="translated">NgForOfContext</target>
        </trans-unit>
        <trans-unit id="9aa1623811bf5374405945b7fc6cbdf5180993ff" translate="yes" xml:space="preserve">
          <source>NgForm</source>
          <target state="translated">NgForm</target>
        </trans-unit>
        <trans-unit id="02e8e8f0c3435c34f302cb262a5526aa0b3f90c3" translate="yes" xml:space="preserve">
          <source>NgFormSelectorWarning</source>
          <target state="translated">NgFormSelectorWarning</target>
        </trans-unit>
        <trans-unit id="0d47835d748f32561764d51a4ebf5edaa996ec7e" translate="yes" xml:space="preserve">
          <source>NgIf</source>
          <target state="translated">NgIf</target>
        </trans-unit>
        <trans-unit id="53ee9a1d3ac7229df365ec02e217a300949c950a" translate="yes" xml:space="preserve">
          <source>NgIf case study</source>
          <target state="translated">NgIf 사례 연구</target>
        </trans-unit>
        <trans-unit id="2d6fa6fc357e35051e9a8ca6cfad6ca37f2129d7" translate="yes" xml:space="preserve">
          <source>NgIfContext</source>
          <target state="translated">NgIfContext</target>
        </trans-unit>
        <trans-unit id="ca835c7256b39ca88da22b194239e465c9067c74" translate="yes" xml:space="preserve">
          <source>NgIterable</source>
          <target state="translated">NgIterable</target>
        </trans-unit>
        <trans-unit id="bccec7397e5a239c6d5be00ac97ab89ed6fe7be6" translate="yes" xml:space="preserve">
          <source>NgLocaleLocalization</source>
          <target state="translated">NgLocaleLocalization</target>
        </trans-unit>
        <trans-unit id="67ebfc8308dd70a519e24ec7c811ccef8c29b7e6" translate="yes" xml:space="preserve">
          <source>NgLocalization</source>
          <target state="translated">NgLocalization</target>
        </trans-unit>
        <trans-unit id="44f2da1aebd949bcff94aed08f70c531acb21927" translate="yes" xml:space="preserve">
          <source>NgModel</source>
          <target state="translated">NgModel</target>
        </trans-unit>
        <trans-unit id="8718c24f215be269df2598be1217e4f3c822d28a" translate="yes" xml:space="preserve">
          <source>NgModelGroup</source>
          <target state="translated">NgModelGroup</target>
        </trans-unit>
        <trans-unit id="37a85283effde9e3159a93126429f93b63988ed9" translate="yes" xml:space="preserve">
          <source>NgModule</source>
          <target state="translated">NgModule</target>
        </trans-unit>
        <trans-unit id="c719e20685cae40b647e31dae4879f5d3a54f894" translate="yes" xml:space="preserve">
          <source>NgModule &lt;code&gt;providers&lt;/code&gt; array</source>
          <target state="translated">NgModule &lt;code&gt;providers&lt;/code&gt; 배열</target>
        </trans-unit>
        <trans-unit id="2751d87c0801c1eab05e6a0adc782aaa4e94ee39" translate="yes" xml:space="preserve">
          <source>NgModule API</source>
          <target state="translated">NgModule API</target>
        </trans-unit>
        <trans-unit id="29a55497c5b4b6f7344c403d19c2c5926065fa3a" translate="yes" xml:space="preserve">
          <source>NgModule FAQ</source>
          <target state="translated">NgModule FAQ</target>
        </trans-unit>
        <trans-unit id="b477384b8930ceaefd252e2e359370e78a8e4520" translate="yes" xml:space="preserve">
          <source>NgModule FAQs</source>
          <target state="translated">NgModule FAQ</target>
        </trans-unit>
        <trans-unit id="51eaf01e53c72676e2b6eb26a767d791f7fb0cf3" translate="yes" xml:space="preserve">
          <source>NgModule classes</source>
          <target state="translated">NgModule 클래스</target>
        </trans-unit>
        <trans-unit id="c7c9934f0c6a24ed4a931d6152b5d880f2efc05c" translate="yes" xml:space="preserve">
          <source>NgModule for testing.</source>
          <target state="translated">테스트를위한 NgModule.</target>
        </trans-unit>
        <trans-unit id="5d256907f0513eaec7592330caaf62b23fe30e80" translate="yes" xml:space="preserve">
          <source>NgModule metadata</source>
          <target state="translated">NgModule 메타 데이터</target>
        </trans-unit>
        <trans-unit id="6d4f86141e2372c863cb09375b2963d442ad5abf" translate="yes" xml:space="preserve">
          <source>NgModule metadata does the following:</source>
          <target state="translated">NgModule 메타 데이터는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="fbfbd629d3532c0c5def39d3746df2b0de63b951" translate="yes" xml:space="preserve">
          <source>NgModule to install on the client side while using the &lt;code&gt;&lt;a href=&quot;platform-browser/transferstate&quot;&gt;TransferState&lt;/a&gt;&lt;/code&gt; to transfer state from server to client.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;platform-browser/transferstate&quot;&gt;TransferState&lt;/a&gt;&lt;/code&gt; 를 사용하여 서버에서 클라이언트로 상태를 전송 하는 동안 클라이언트 측에 설치할 NgModule .</target>
        </trans-unit>
        <trans-unit id="3d7075e87c06ced7063e0b71ef4410314d05aa75" translate="yes" xml:space="preserve">
          <source>NgModule to install on the client side while using the &lt;code&gt;&lt;a href=&quot;transferstate&quot;&gt;TransferState&lt;/a&gt;&lt;/code&gt; to transfer state from server to client.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;transferstate&quot;&gt;TransferState&lt;/a&gt;&lt;/code&gt; 를 사용하여 서버에서 클라이언트로 상태를 전송 하는 동안 클라이언트 측에 설치할 NgModule .</target>
        </trans-unit>
        <trans-unit id="6ec1e1bc15b91062588d5b99a08cf07a76b7ecce" translate="yes" xml:space="preserve">
          <source>NgModule to install on the server side while using the &lt;code&gt;&lt;a href=&quot;../platform-browser/transferstate&quot;&gt;TransferState&lt;/a&gt;&lt;/code&gt; to transfer state from server to client.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../platform-browser/transferstate&quot;&gt;TransferState&lt;/a&gt;&lt;/code&gt; 를 사용하여 서버에서 클라이언트로 상태를 전송 하는 동안 서버 측에 설치할 NgModule .</target>
        </trans-unit>
        <trans-unit id="4ef7dee469070a640beccb48d4c3f3f99ab65599" translate="yes" xml:space="preserve">
          <source>NgModule to install on the server side while using the &lt;code&gt;&lt;a href=&quot;platform-browser/transferstate&quot;&gt;TransferState&lt;/a&gt;&lt;/code&gt; to transfer state from server to client.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;platform-browser/transferstate&quot;&gt;TransferState&lt;/a&gt;&lt;/code&gt; 를 사용하여 서버에서 클라이언트로 상태를 전송 하는 동안 서버 측에 설치할 NgModule .</target>
        </trans-unit>
        <trans-unit id="a7cee648f99bd3da3cdb1992b2ccb2673f5e2b1a" translate="yes" xml:space="preserve">
          <source>NgModuleFactory</source>
          <target state="translated">NgModuleFactory</target>
        </trans-unit>
        <trans-unit id="477b488285e5a668e6c4458c6708e191a4f4ffcb" translate="yes" xml:space="preserve">
          <source>NgModuleFactoryLoader</source>
          <target state="translated">NgModuleFactoryLoader</target>
        </trans-unit>
        <trans-unit id="24ae0c9b5f5ee9d08572d93983f958413a610153" translate="yes" xml:space="preserve">
          <source>NgModuleFactoryLoader that uses SystemJS to load NgModuleFactory</source>
          <target state="translated">SystemJS를 사용하여 NgModuleFactory를로드하는 NgModuleFactoryLoader</target>
        </trans-unit>
        <trans-unit id="5b38b75ac64edf288c87958d77f610c468c097c4" translate="yes" xml:space="preserve">
          <source>NgModuleRef</source>
          <target state="translated">NgModuleRef</target>
        </trans-unit>
        <trans-unit id="3aa15d9e9ccc479546d40db5fc5285973a466031" translate="yes" xml:space="preserve">
          <source>NgModules</source>
          <target state="translated">NgModules</target>
        </trans-unit>
        <trans-unit id="8b38c143e329e8014a252fd083bf2f3a43e15e8c" translate="yes" xml:space="preserve">
          <source>NgModules and JavaScript modules</source>
          <target state="translated">NgModules 및 JavaScript 모듈</target>
        </trans-unit>
        <trans-unit id="b70b73f6df8f1327b6458e4f41dc64fef86047ca" translate="yes" xml:space="preserve">
          <source>NgModules and components</source>
          <target state="translated">Ng 모듈 및 구성 요소</target>
        </trans-unit>
        <trans-unit id="25f406cd8a0d03bbec9b10ae07063fbf7ddbd4f0" translate="yes" xml:space="preserve">
          <source>NgModules are a great way to organize an app and keep code related to a specific functionality or feature separate from other code. Use NgModules to consolidate &lt;a href=&quot;glossary#component&quot;&gt;components&lt;/a&gt;, &lt;a href=&quot;glossary#directive&quot;&gt;directives&lt;/a&gt;, and &lt;a href=&quot;glossary#pipe&quot;&gt;pipes&lt;/a&gt; into cohesive blocks of functionality. Focus each block on a feature or business domain, a workflow or navigation flow, a common collection of utilities, or one or more &lt;a href=&quot;glossary#provider&quot;&gt;providers&lt;/a&gt; for &lt;a href=&quot;glossary#service&quot;&gt;services&lt;/a&gt;.</source>
          <target state="translated">NgModules는 앱을 구성하고 특정 기능 또는 기능과 관련된 코드를 다른 코드와 별도로 유지하는 좋은 방법입니다. NgModules를 사용하여 &lt;a href=&quot;glossary#component&quot;&gt;구성 요소&lt;/a&gt; , &lt;a href=&quot;glossary#directive&quot;&gt;지시문&lt;/a&gt; 및 &lt;a href=&quot;glossary#pipe&quot;&gt;파이프&lt;/a&gt; 를 일관된 기능 블록으로 통합합니다. 기능 또는 비즈니스 도메인, 워크 플로 또는 탐색 흐름, 공용 유틸리티 모음 또는 하나 이상의 &lt;a href=&quot;glossary#service&quot;&gt;서비스 &lt;/a&gt;&lt;a href=&quot;glossary#provider&quot;&gt;제공 업체&lt;/a&gt; 에 각 블록을 집중 합니다 .</target>
        </trans-unit>
        <trans-unit id="0ad7d0bd2ccc1ce8cf9d363fc9f9ed9fe4b3a05d" translate="yes" xml:space="preserve">
          <source>NgModules are a great way to selectively aggregate classes from other NgModules and re-export them in a consolidated, convenience module.</source>
          <target state="translated">NgModules는 다른 NgModules에서 클래스를 선택적으로 집계하여 통합 된 편리한 모듈로 다시 내보낼 수있는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="54c3135ae726bd7ade61dd62fbecc04c2da09b7e" translate="yes" xml:space="preserve">
          <source>NgModules are classes decorated with &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; decorator&amp;rsquo;s &lt;code&gt;imports&lt;/code&gt; array tells Angular what other NgModules the current module needs. The modules in the &lt;code&gt;imports&lt;/code&gt; array are different than JavaScript modules because they are NgModules rather than regular JavaScript modules. Classes with an &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; decorator are by convention kept in their own files, but what makes them an &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; isn&amp;rsquo;t being in their own file, like JavaScript modules; it&amp;rsquo;s the presence of &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; and its metadata.</source>
          <target state="translated">NgModules는 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 장식 된 클래스 입니다. &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 장식의 &lt;code&gt;imports&lt;/code&gt; 배열 각도 어떤 다른 NgModules 현재 모듈의 요구를 알려줍니다. &lt;code&gt;imports&lt;/code&gt; 배열 의 모듈은 일반 JavaScript 모듈이 아닌 NgModules이므로 JavaScript 모듈과 다릅니다. &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 데코레이터가 있는 클래스 는 규칙에 따라 자체 파일에 보관되지만 JavaScript 모듈과 같이 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 이 자체 파일에없는 이유 는 무엇입니까 ? &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 과 메타 데이터 가 존재 합니다.</target>
        </trans-unit>
        <trans-unit id="b4911a8df8b9a60b2d04af43909cad3497a0627b" translate="yes" xml:space="preserve">
          <source>NgModules are typically named after the file in which the exported thing is defined. For example, the Angular &lt;a href=&quot;../api/common/datepipe&quot;&gt;DatePipe&lt;/a&gt; class belongs to a feature module named &lt;code&gt;date_pipe&lt;/code&gt; in the file &lt;code&gt;date_pipe.ts&lt;/code&gt;. You import them from an Angular &lt;a href=&quot;glossary#scoped-package&quot;&gt;scoped package&lt;/a&gt; such as &lt;code&gt;@angular/core&lt;/code&gt;.</source>
          <target state="translated">NgModules는 일반적으로 내 보낸 사물이 정의 된 파일의 이름을 따서 명명됩니다. 예를 들어 Angular &lt;a href=&quot;../api/common/datepipe&quot;&gt;DatePipe&lt;/a&gt; 클래스는 &lt;code&gt;date_pipe&lt;/code&gt; .ts 파일의 &lt;code&gt;date_pipe.ts&lt;/code&gt; 기능 모듈에 속합니다 . &lt;code&gt;@angular/core&lt;/code&gt; 와 같은 Angular &lt;a href=&quot;glossary#scoped-package&quot;&gt;범위 패키지&lt;/a&gt; 에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="a8f03b79bd627a2c287c8259f3048620ba16a568" translate="yes" xml:space="preserve">
          <source>NgModules consolidate components, directives, and pipes into cohesive blocks of functionality, each focused on a feature area, application business domain, workflow, or common collection of utilities.</source>
          <target state="translated">NgModules는 컴포넌트, 지시문 및 파이프를 기능 영역, 애플리케이션 비즈니스 영역, 워크 플로우 또는 공통 유틸리티 모음에 중점을 둔 응집력있는 기능 블록으로 통합합니다.</target>
        </trans-unit>
        <trans-unit id="af643352073d83c59890eb84260d804d31e0be0f" translate="yes" xml:space="preserve">
          <source>NgModules help organize an application into cohesive blocks of functionality.</source>
          <target state="translated">NgModules는 애플리케이션을 응집력있는 기능 블록으로 구성하는 데 도움을줍니다.</target>
        </trans-unit>
        <trans-unit id="d4f6a7850f2ca66c7a969e4238c4738a152c5e4d" translate="yes" xml:space="preserve">
          <source>NgModules or components that are loaded on launch are called eager-loaded, to distinguish them from those that are loaded at run time (lazy-loaded). See &lt;a href=&quot;glossary#lazy-load&quot;&gt;lazy loading&lt;/a&gt;.</source>
          <target state="translated">실행시로드 된 NgModules 또는 구성 요소를 런타임에로드 된 구성 요소 (지연로드)와 구별하기 위해 열성로드라고합니다. &lt;a href=&quot;glossary#lazy-load&quot;&gt;지연 로딩을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="62163a6746cd8611053224f510e2d133d17b33a4" translate="yes" xml:space="preserve">
          <source>NgModules provide a &lt;em&gt;compilation context&lt;/em&gt; for their components. A root NgModule always has a root component that is created during bootstrap, but any NgModule can include any number of additional components, which can be loaded through the router or created through the template. The components that belong to an NgModule share a compilation context.</source>
          <target state="translated">NgModules는 컴포넌트에 대한 &lt;em&gt;컴파일 컨텍스트&lt;/em&gt; 를 제공합니다 . 루트 NgModule은 항상 부트 스트랩 동안 생성되는 루트 구성 요소를 갖지만 NgModule은 라우터를 통해로드되거나 템플릿을 통해 생성 될 수있는 추가 구성 요소를 여러 개 포함 할 수 있습니다. NgModule에 속하는 컴포넌트는 컴파일 컨텍스트를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="3d52094431f1a451325421f288758094e3331fff" translate="yes" xml:space="preserve">
          <source>NgModules, defined with the &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; decorator, serve the same purpose:</source>
          <target state="translated">NgModule 데코레이터로 정의 된 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; s 는 동일한 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3329474efd238458b027081acbffcc8a300263e7" translate="yes" xml:space="preserve">
          <source>NgModules: Classes with metadata for compiling</source>
          <target state="translated">NgModules : 컴파일을위한 메타 데이터가있는 클래스</target>
        </trans-unit>
        <trans-unit id="ecddffd553c00625c6d1948c47408a7bc2694041" translate="yes" xml:space="preserve">
          <source>NgPlural</source>
          <target state="translated">NgPlural</target>
        </trans-unit>
        <trans-unit id="33e70ef97ddaac0d361c0f2e5595fdcc13aeb0b9" translate="yes" xml:space="preserve">
          <source>NgPluralCase</source>
          <target state="translated">NgPluralCase</target>
        </trans-unit>
        <trans-unit id="e95570f3c97debdfeeba52d6ae0c387d6d857374" translate="yes" xml:space="preserve">
          <source>NgProbeToken</source>
          <target state="translated">NgProbeToken</target>
        </trans-unit>
        <trans-unit id="4dce6f191737f1f14519d03138656f14a86f9c04" translate="yes" xml:space="preserve">
          <source>NgSelectOption</source>
          <target state="translated">NgSelectOption</target>
        </trans-unit>
        <trans-unit id="035fa85010deff8f88890ceff27680fb494ca12e" translate="yes" xml:space="preserve">
          <source>NgStyle</source>
          <target state="translated">NgStyle</target>
        </trans-unit>
        <trans-unit id="6be560439ddbed642468cfe1832ecbd191286f36" translate="yes" xml:space="preserve">
          <source>NgStyleBase</source>
          <target state="translated">NgStyleBase</target>
        </trans-unit>
        <trans-unit id="c6808c2a4dadb4d167ed51609818e1586d73ba91" translate="yes" xml:space="preserve">
          <source>NgSwitch</source>
          <target state="translated">NgSwitch</target>
        </trans-unit>
        <trans-unit id="75e734dbca4c572780c0f22ca962996575a8fe74" translate="yes" xml:space="preserve">
          <source>NgSwitch is like the JavaScript &lt;code&gt;switch&lt;/code&gt; statement. It displays one element from among several possible elements, based on a switch condition. Angular puts only the selected element into the DOM.</source>
          <target state="translated">NgSwitch는 JavaScript &lt;code&gt;switch&lt;/code&gt; 문과 같습니다. 스위치 조건에 따라 여러 가능한 요소 중 하나의 요소를 표시합니다. 각도는 선택한 요소 만 DOM에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="489a9f825ab046358569d6f7ba386545da71ed2e" translate="yes" xml:space="preserve">
          <source>NgSwitchCase</source>
          <target state="translated">NgSwitchCase</target>
        </trans-unit>
        <trans-unit id="2c6d09678694058cf231ebcbf7f5dbf708b69abe" translate="yes" xml:space="preserve">
          <source>NgSwitchDefault</source>
          <target state="translated">NgSwitchDefault</target>
        </trans-unit>
        <trans-unit id="172dadbce868c96252d96cade7229e7bd5b8a58d" translate="yes" xml:space="preserve">
          <source>NgTemplateOutlet</source>
          <target state="translated">NgTemplateOutlet</target>
        </trans-unit>
        <trans-unit id="d485146c2e39cc1a08c6b776692e4bf78a47870a" translate="yes" xml:space="preserve">
          <source>NgZone</source>
          <target state="translated">NgZone</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="be9710b3ab6837da4f52eccc6e0f5d30d6cb9090" translate="yes" xml:space="preserve">
          <source>No Angular &lt;em&gt;filter&lt;/em&gt; or &lt;em&gt;orderBy&lt;/em&gt; filters</source>
          <target state="translated">어떤 각도 &lt;em&gt;필터없는&lt;/em&gt; 또는 &lt;em&gt;해 orderBy&lt;/em&gt; 필터</target>
        </trans-unit>
        <trans-unit id="818604a049b51e447ca9452e0724b91621cdd14d" translate="yes" xml:space="preserve">
          <source>No arrow functions</source>
          <target state="translated">화살표 기능 없음</target>
        </trans-unit>
        <trans-unit id="93fd1717bd078eecc13bf4593e2c07b31921ef32" translate="yes" xml:space="preserve">
          <source>No brackets. No parentheses. Just &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; set to a string.</source>
          <target state="translated">괄호가 없습니다. 괄호가 없습니다. 그냥 &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 은 문자열로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e0e6790b758e9ad2708594454268be14a1fb2e80" translate="yes" xml:space="preserve">
          <source>No directive or component will implement all of the lifecycle hooks. Angular only calls a directive/component hook method &lt;em&gt;if it is defined&lt;/em&gt;.</source>
          <target state="translated">지시어 나 구성 요소가 모든 수명주기 후크를 구현하지는 않습니다. Angular는 지시어 / 구성 요소 후크 메소드 &lt;em&gt;가 정의 된 경우&lt;/em&gt; 에만 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1217b7240bdd90bc874cf17d351cb5803a44e70c" translate="yes" xml:space="preserve">
          <source>No longer has an effect.</source>
          <target state="translated">더 이상 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9bc4d71e03b80c5dedb2c76055f5e5fd3665e501" translate="yes" xml:space="preserve">
          <source>No longer needed with Ivy.</source>
          <target state="translated">아이비에는 더 이상 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a7c7d340737ed1e90c7a884ddd030908f49f4467" translate="yes" xml:space="preserve">
          <source>No longer required to disable CSS extraction during development.</source>
          <target state="translated">더 이상 개발 중에 CSS 추출을 비활성화 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a33dabb786685e6c8a1c90d4a92084eb79424856" translate="yes" xml:space="preserve">
          <source>No need to wait for content updates</source>
          <target state="translated">콘텐츠 업데이트를 기다릴 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="19791c97515fc46a0f70d4d720439311b44e04dd" translate="yes" xml:space="preserve">
          <source>No pipe</source>
          <target state="translated">파이프 없음</target>
        </trans-unit>
        <trans-unit id="d01cbbaac61e63c969eafc5bea6f8bf228e6b366" translate="yes" xml:space="preserve">
          <source>No preloading at all which is the default. Lazy loaded feature areas are still loaded on demand.</source>
          <target state="translated">사전로드가 전혀 없으며 기본값입니다. 지연로드 된 피처 영역은 여전히 ​​요청시로드됩니다.</target>
        </trans-unit>
        <trans-unit id="7c7471480762563740871584b9b53195c60bd948" translate="yes" xml:space="preserve">
          <source>No preloading, which is the default. Lazy loaded feature areas are still loaded on-demand.</source>
          <target state="translated">기본값 인 사전로드 없음. 지연로드 된 기능 영역은 여전히 ​​요청시로드됩니다.</target>
        </trans-unit>
        <trans-unit id="016f7b6391a97aa02bddbd40845410a8c78ab7db" translate="yes" xml:space="preserve">
          <source>No support for the bitwise operators such as &lt;code&gt;|&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt;</source>
          <target state="translated">같은 비트 연산자를 지원하지 않습니다 &lt;code&gt;|&lt;/code&gt; 그리고 &lt;code&gt;&amp;amp;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bd3e4268add64f72ae4ddbdf062a3d7555bc454b" translate="yes" xml:space="preserve">
          <source>No unidirectional flow worries with &lt;code&gt;AfterContent&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;AfterContent&lt;/code&gt; 로 단방향 흐름 걱정 없음</target>
        </trans-unit>
        <trans-unit id="a17d14eafac1937732100c20aae31c6593b0b98c" translate="yes" xml:space="preserve">
          <source>No visible side effects</source>
          <target state="translated">눈에 띄는 부작용 없음</target>
        </trans-unit>
        <trans-unit id="5587ffa9dbf62fd17a4559efe1a31d50d010d763" translate="yes" xml:space="preserve">
          <source>No-op method to remove the form array.</source>
          <target state="translated">양식 배열을 제거하는 No-op 방법.</target>
        </trans-unit>
        <trans-unit id="a462ef1cea806d3dcc1ea1738cd91a1aeedf0b36" translate="yes" xml:space="preserve">
          <source>No-op method to remove the form group.</source>
          <target state="translated">양식 그룹을 제거 할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="6a8da9a88f886e4153126f39d675bd3b766cccb9" translate="yes" xml:space="preserve">
          <source>NoPreloading</source>
          <target state="translated">NoPreloading</target>
        </trans-unit>
        <trans-unit id="1710b1a221c7361f089e2a52fcf70b3fd33585f1" translate="yes" xml:space="preserve">
          <source>Nobody reads the &lt;code&gt;appUnless&lt;/code&gt; property so it doesn't need a getter.</source>
          <target state="translated">아무도 &lt;code&gt;appUnless&lt;/code&gt; 속성을 읽지 않으므로 getter가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10b3493287f831e81a438811a1ffba01f8cec4b7" translate="yes" xml:space="preserve">
          <source>Node.js</source>
          <target state="translated">Node.js</target>
        </trans-unit>
        <trans-unit id="2e417e3eedf2707d935f79ec1cd1ef89ab55a380" translate="yes" xml:space="preserve">
          <source>Non-Angular classes and objects, such as strings, numbers, functions, entity models, configurations, business logic, and helper classes</source>
          <target state="translated">문자열, 숫자, 함수, 엔터티 모델, 구성, 비즈니스 논리 및 도우미 클래스와 같은 비 앵글 클래스 및 개체</target>
        </trans-unit>
        <trans-unit id="218b9057d9cc78dd657173bed27a6200c0a95fae" translate="yes" xml:space="preserve">
          <source>Non-Angular classes and objects, such as strings, numbers, functions, entity models, configurations, business logic, and helper classes.</source>
          <target state="translated">문자열, 숫자, 함수, 엔터티 모델, 구성, 비즈니스 논리 및 도우미 클래스와 같은 비 앵글 클래스 및 개체</target>
        </trans-unit>
        <trans-unit id="cb4967cfbd4130cd4553ec35331b3a3ab44adc71" translate="yes" xml:space="preserve">
          <source>Non-Angular elements named with dash case (&lt;code&gt;-&lt;/code&gt;).</source>
          <target state="translated">대시 대소 문자 ( &lt;code&gt;-&lt;/code&gt; )로 명명 된 비 앵귤러 요소 .</target>
        </trans-unit>
        <trans-unit id="4b8e6a57d88b7ccf4c24e15e2a0995483d56359b" translate="yes" xml:space="preserve">
          <source>Non-CSS style files</source>
          <target state="translated">비 CSS 스타일 파일</target>
        </trans-unit>
        <trans-unit id="4341230c37df0f830ce3196200bdc4eaa8b1649d" translate="yes" xml:space="preserve">
          <source>Non-class dependencies</source>
          <target state="translated">비 클래스 종속성</target>
        </trans-unit>
        <trans-unit id="ded852d4e83379796827d611754f95a7036735ee" translate="yes" xml:space="preserve">
          <source>Non-declarable objects such as services, functions, configurations, and entity models.</source>
          <target state="translated">서비스, ​​기능, 구성 및 엔터티 모델과 같은 선언 할 수없는 개체</target>
        </trans-unit>
        <trans-unit id="8d47a7281ff53fb1a6797410ef0833cdc906ffa9" translate="yes" xml:space="preserve">
          <source>Non-null type assertion operator</source>
          <target state="translated">널이 아닌 유형 어설 션 연산자</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="1d352db5f8dd17cd63b401e2ed0e9c468bffd2e7" translate="yes" xml:space="preserve">
          <source>None of the &lt;em&gt;class-only&lt;/em&gt; tests above can answer key questions about how the components actually behave on screen.</source>
          <target state="translated">위 의 &lt;em&gt;클래스 전용&lt;/em&gt; 테스트 중 어느 것도 구성 요소가 실제로 화면에서 어떻게 작동하는지에 대한 주요 질문에 대답 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a5b6d6e9ec12f5f8ee4edd54f85c6ad46277ecd8" translate="yes" xml:space="preserve">
          <source>Nonetheless, it's good practice to add interfaces to TypeScript directive classes in order to benefit from strong typing and editor tooling.</source>
          <target state="translated">그럼에도 불구하고 강력한 타이핑 및 편집기 툴링을 활용하려면 TypeScript 지시문 클래스에 인터페이스를 추가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="736b4cd6b71b8bdb48cb01730dfaee48e2392e16" translate="yes" xml:space="preserve">
          <source>NoopAnimationPlayer</source>
          <target state="translated">NoopAnimationPlayer</target>
        </trans-unit>
        <trans-unit id="70f82949d3496e317e02bfe915266dc2dded0fe7" translate="yes" xml:space="preserve">
          <source>NoopAnimationsModule</source>
          <target state="translated">NoopAnimationsModule</target>
        </trans-unit>
        <trans-unit id="12561ae2fb444110d629b1206986eb95f41f11a1" translate="yes" xml:space="preserve">
          <source>Normalizes URL parameters by prepending with &lt;code&gt;?&lt;/code&gt; if needed.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; 를 앞에 추가하여 URL 매개 변수를 정규화합니다 . 필요한 경우.</target>
        </trans-unit>
        <trans-unit id="ade4e4610aadfb20b6f050681409585d91cbef29" translate="yes" xml:space="preserve">
          <source>Normalizes a URL path by stripping any trailing slashes.</source>
          <target state="translated">후행 슬래시를 제거하여 URL 경로를 표준화합니다.</target>
        </trans-unit>
        <trans-unit id="18495c5e726b97b87446a944fb49811a2e5920ab" translate="yes" xml:space="preserve">
          <source>Normalizes an external URL path. If the given URL doesn't begin with a leading slash (&lt;code&gt;'/'&lt;/code&gt;), adds one before normalizing. Adds a hash if &lt;code&gt;&lt;a href=&quot;hashlocationstrategy&quot;&gt;HashLocationStrategy&lt;/a&gt;&lt;/code&gt; is in use, or the &lt;code&gt;&lt;a href=&quot;app_base_href&quot;&gt;APP_BASE_HREF&lt;/a&gt;&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;pathlocationstrategy&quot;&gt;PathLocationStrategy&lt;/a&gt;&lt;/code&gt; is in use.</source>
          <target state="translated">외부 URL 경로를 표준화합니다. 주어진 URL이 슬래시 ( &lt;code&gt;'/'&lt;/code&gt; )로 시작하지 않으면 정규화하기 전에 하나를 추가하십시오. 경우 해시를 추가 &lt;code&gt;&lt;a href=&quot;hashlocationstrategy&quot;&gt;HashLocationStrategy&lt;/a&gt;&lt;/code&gt; 가 사용 중이거나 &lt;code&gt;&lt;a href=&quot;app_base_href&quot;&gt;APP_BASE_HREF&lt;/a&gt;&lt;/code&gt; 이 경우 생성 &lt;code&gt;&lt;a href=&quot;pathlocationstrategy&quot;&gt;PathLocationStrategy&lt;/a&gt;&lt;/code&gt; 가 사용 중입니다.</target>
        </trans-unit>
        <trans-unit id="678371611e9955b829a518950afa7eca6ce63f39" translate="yes" xml:space="preserve">
          <source>Normalizes the URL from the provided string</source>
          <target state="translated">제공된 문자열에서 URL을 정규화합니다</target>
        </trans-unit>
        <trans-unit id="2e3d0802a56f44230e6b62bf9349e52129f8767b" translate="yes" xml:space="preserve">
          <source>Normalizes the URL from the provided string, search, hash, and base URL parameters</source>
          <target state="translated">제공된 문자열, 검색, 해시 및 기본 URL 매개 변수에서 URL을 정규화합니다.</target>
        </trans-unit>
        <trans-unit id="a1eeaaf174120ccf4a2abdf3240f1954f256c7d7" translate="yes" xml:space="preserve">
          <source>Normalizes the URL path for this location.</source>
          <target state="translated">이 위치의 URL 경로를 표준화합니다.</target>
        </trans-unit>
        <trans-unit id="3d018be8074135d14814ec6947f77060d77bf92a" translate="yes" xml:space="preserve">
          <source>Normalizes the given path and compares to the current normalized path.</source>
          <target state="translated">주어진 경로를 정규화하고 현재 정규화 된 경로와 비교합니다.</target>
        </trans-unit>
        <trans-unit id="fe5c4e0c718a72401fd1df547a30a83f706b43e1" translate="yes" xml:space="preserve">
          <source>Normally the starting point for search is at the point of injection. However, in this case &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt;&lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt;s are special in that they also include their own &lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt;, which is why the search starts at &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt; belonging to &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt;. (This would not be the case for a directive matched at the same location).</source>
          <target state="translated">일반적으로 검색 시작 지점은 주입 지점입니다. 그러나이 경우 &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; 는 자체 &lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt; 도 포함한다는 점에서 특별 하므로 검색은 &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; 에 속하는 &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt; 에서 시작됩니다 . (동일한 위치에서 일치하는 지시문의 경우에는 해당되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="88740cda46d55edba20813ca10d53ea4860dc02d" translate="yes" xml:space="preserve">
          <source>Normally the starting point for search is at the point of injection. However, in this case &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt;&lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt;s are special in that they also include their own &lt;code&gt;viewProviders&lt;/code&gt;, which is why the search starts at &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt; belonging to &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt;. (This would not be the case for a directive matched at the same location).</source>
          <target state="translated">일반적으로 검색 시작점은 주입 지점입니다. 그러나이 경우 &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; 는 자체 &lt;code&gt;viewProviders&lt;/code&gt; 를 포함한다는 점에서 특별합니다. 이것이 &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; 에 속하는 &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt; 에서 검색이 시작되는 이유 입니다. (동일한 위치에서 일치하는 지시문의 경우에는 해당되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="cd9f6de0a5276d4f18217b8f9147f1ef687011bc" translate="yes" xml:space="preserve">
          <source>Normally, Angular automatically sanitizes the URL, disables the dangerous code, and in development mode, logs this action to the console. To prevent this, mark the URL value as a trusted URL using the &lt;code&gt;bypassSecurityTrustUrl&lt;/code&gt; call:</source>
          <target state="translated">일반적으로 Angular는 자동으로 URL을 삭제하고 위험한 코드를 비활성화하며 개발 모드에서이 작업을 콘솔에 기록합니다. 이를 방지하려면 &lt;code&gt;bypassSecurityTrustUrl&lt;/code&gt; 을 사용하여 URL 값을 신뢰할 수있는 URL로 표시하십시오. 호출을 .</target>
        </trans-unit>
        <trans-unit id="389d7bbe04b98e76d49e7b50a7e6d1c1c26ed9fb" translate="yes" xml:space="preserve">
          <source>Norwegian Bokm&amp;aring;l</source>
          <target state="translated">노르웨이 보크 몰</target>
        </trans-unit>
        <trans-unit id="253ffb44e9d7dbc97a80decedaf0ffe8b9751cee" translate="yes" xml:space="preserve">
          <source>Not a number. Example: NaN</source>
          <target state="translated">숫자가 아닙니다. 예 : NaN</target>
        </trans-unit>
        <trans-unit id="c6e0e3f4d0bcc4a8a0945c4e32515b50d6f90e4a" translate="yes" xml:space="preserve">
          <source>Not all APIs return JSON data. In this next example, a &lt;code&gt;DownloaderService&lt;/code&gt; method reads a text file from the server and logs the file contents, before returning those contents to the caller as an &lt;code&gt;Observable&amp;lt;string&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">모든 API가 JSON 데이터를 반환하는 것은 아닙니다. 다음 예제에서 &lt;code&gt;DownloaderService&lt;/code&gt; 메서드는 서버에서 텍스트 파일을 읽고 파일 내용을 기록한 다음 해당 내용을 호출자에게 &lt;code&gt;Observable&amp;lt;string&amp;gt;&lt;/code&gt; 으로 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="777b939bfaa3119dd1cc037b06134232b6fd79ee" translate="yes" xml:space="preserve">
          <source>Not all browsers support the latest ECMAScript standard, but you can use a &lt;a href=&quot;glossary#transpile&quot;&gt;transpiler&lt;/a&gt; (like &lt;a href=&quot;glossary#typescript&quot;&gt;TypeScript&lt;/a&gt;) to write code using the latest features, which will then be transpiled to code that runs on versions that are supported by browsers.</source>
          <target state="translated">모든 브라우저가 최신 ECMAScript 표준을 지원하지는 않지만 &lt;a href=&quot;glossary#transpile&quot;&gt;TypeScript&lt;/a&gt; 와 같은 &lt;a href=&quot;glossary#typescript&quot;&gt;트랜스 &lt;/a&gt;파일러를 사용할 수 있습니다 )를 사용하여 최신 기능을 사용하여 코드를 작성한 다음 브라우저에서 지원하는 버전에서 실행되는 코드로 트랜스 파일됩니다.</target>
        </trans-unit>
        <trans-unit id="fa81708719f13e6a91ca9e3a6b7fc812211ec4fd" translate="yes" xml:space="preserve">
          <source>Not all dependencies are classes. Sometimes you want to inject a string, function, or object.</source>
          <target state="translated">모든 종속성이 클래스 인 것은 아닙니다. 때로는 문자열, 함수 또는 객체를 주입하려고합니다.</target>
        </trans-unit>
        <trans-unit id="4b22c361d6175142654cd9ef350fb28ba6d01cdc" translate="yes" xml:space="preserve">
          <source>Not all kinds of AngularJS directives can be upgraded. The directive really has to be a &lt;em&gt;component directive&lt;/em&gt;, with the characteristics &lt;a href=&quot;upgrade#using-component-directives&quot;&gt;described in the preparation guide above&lt;/a&gt;. The safest bet for ensuring compatibility is using the &lt;a href=&quot;https://docs.angularjs.org/api/ng/type/angular.Module&quot;&gt;component API&lt;/a&gt; introduced in AngularJS 1.5.</source>
          <target state="translated">모든 종류의 AngularJS 지시문을 업그레이드 할 수있는 것은 아닙니다. 지시문은 실제로 &lt;a href=&quot;upgrade#using-component-directives&quot;&gt;위의 준비 안내서에 설명 된&lt;/a&gt; 특성을 가진 &lt;em&gt;구성 요소 지시문&lt;/em&gt; 이어야합니다 . 호환성을 보장하는 가장 안전한 방법 은 AngularJS 1.5에 도입 된 &lt;a href=&quot;https://docs.angularjs.org/api/ng/type/angular.Module&quot;&gt;구성 요소 API를&lt;/a&gt; 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="0e26062ec2eb9351d044478dea4c629208506235" translate="yes" xml:space="preserve">
          <source>Not impressed? Think about it for a moment. What would you have to do to wire the button's enable/disabled state to the form's validity without Angular's help?</source>
          <target state="translated">감동하지 않습니까? 잠시 생각해보십시오. Angular의 도움없이 버튼의 활성화 / 비활성화 상태를 폼의 유효성에 연결하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="db247da90a20bc16a7bf2b86e5130f25cc599a75" translate="yes" xml:space="preserve">
          <source>Not part of public API.</source>
          <target state="translated">공개 API의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6c418c4740b6cfe7654ca9d7efbe5548bc96337a" translate="yes" xml:space="preserve">
          <source>Note also that this Observable runs outside of the Angular zone, which means that the code in the subscription to this Observable will not trigger the change detection.</source>
          <target state="translated">또한이 Observable은 Angular 영역 외부에서 실행되므로이 ​​Observable에 가입 ​​한 코드는 변경 감지를 트리거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="338176a50b852fbbdfd5e12d5724c990da959e7a" translate="yes" xml:space="preserve">
          <source>Note how &lt;code&gt;sendRequest()&lt;/code&gt; intercepts the response on its way back to the application. This method pipes the response through the &lt;code&gt;tap()&lt;/code&gt; operator, whose callback adds the response to the cache.</source>
          <target state="translated">&lt;code&gt;sendRequest()&lt;/code&gt; 가 애플리케이션으로 돌아가는 도중에 응답을 가로채는 방법에 유의하십시오 . 이 메서드 는 콜백이 캐시에 응답을 추가하는 &lt;code&gt;tap()&lt;/code&gt; 연산자를 통해 응답을 파이프합니다 .</target>
        </trans-unit>
        <trans-unit id="08223ff3b23c6a47e3a0ef6e2e8ac775f3d44a6a" translate="yes" xml:space="preserve">
          <source>Note how &lt;code&gt;sendRequest&lt;/code&gt;&lt;em&gt;intercepts the response&lt;/em&gt; on its way back to the application. It &lt;em&gt;pipes&lt;/em&gt; the response through the &lt;code&gt;tap()&lt;/code&gt; operator, whose callback adds the response to the cache.</source>
          <target state="translated">&lt;code&gt;sendRequest&lt;/code&gt; 가 애플리케이션으로 돌아가는 &lt;em&gt;동안 응답&lt;/em&gt; 을 &lt;em&gt;가로채는&lt;/em&gt; 방법에 유의하십시오 . 또한 &lt;em&gt;파이프&lt;/em&gt; 관통 응답 &lt;code&gt;tap()&lt;/code&gt; 콜백 캐시에 응답하여 추가 연산자.</target>
        </trans-unit>
        <trans-unit id="aeec8e9f93a274d7472bacdd358a15a6916f1341" translate="yes" xml:space="preserve">
          <source>Note how the &lt;code&gt;linenums&lt;/code&gt; attribute in the &lt;code&gt;&amp;lt;code-tabs&amp;gt;&lt;/code&gt; explicitly enables numbering for all panes. The &lt;code&gt;linenums&lt;/code&gt; attribute in the second pane disables line numbering for &lt;em&gt;itself only&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;code-tabs&amp;gt;&lt;/code&gt; 의 &lt;code&gt;linenums&lt;/code&gt; 속성이 모든 창에 대해 번호 매기기를 명시 적으로 활성화 하는 방법에 유의하십시오 . &lt;code&gt;linenums&lt;/code&gt; 을 위한 두 번째 창 비활성화 라인 번호에 속성 &lt;em&gt;에만 자체&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c152807d6c8f8e4db411c5cb24fabab3f316cbed" translate="yes" xml:space="preserve">
          <source>Note how the setup code assigns a test hero (&lt;code&gt;expectedHero&lt;/code&gt;) to the component's &lt;code&gt;hero&lt;/code&gt; property, emulating the way the &lt;code&gt;DashboardComponent&lt;/code&gt; would set it via the property binding in its repeater.</source>
          <target state="translated">설정 코드가 테스트 히어로 ( &lt;code&gt;expectedHero&lt;/code&gt; )를 컴포넌트의 &lt;code&gt;hero&lt;/code&gt; 특성에 지정하여 &lt;code&gt;DashboardComponent&lt;/code&gt; 가 리피터의 특성 바인딩을 통해이를 설정 하는 방식을 에뮬레이트하는 방법에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="a281167ca6f3f3d6ce6cf851b7d39c49313bd017" translate="yes" xml:space="preserve">
          <source>Note on performance</source>
          <target state="translated">성능에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="1ecc6c31ae894d6c11152c8fe4320e22dd9e10d1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;AppModule&lt;/code&gt; declares both application components, &lt;code&gt;AppComponent&lt;/code&gt; and &lt;code&gt;HeroesComponent&lt;/code&gt;.</source>
          <target state="translated">참고 것을 &lt;code&gt;AppModule&lt;/code&gt; 는 모두 응용 프로그램 구성 요소 선언 &lt;code&gt;AppComponent&lt;/code&gt; 및 &lt;code&gt;HeroesComponent&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="23b7e3ea6da8cd0785f61b0a58466e85e03fb3e9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;history.state&lt;/code&gt; does not pass an object equality test because the router adds the &lt;code&gt;navigationId&lt;/code&gt; on each navigation.</source>
          <target state="translated">참고 &lt;code&gt;history.state&lt;/code&gt; 는 라우터가 추가하기 때문에 개체 평등 테스트를 통과하지 않습니다 &lt;code&gt;navigationId&lt;/code&gt; 를 각 탐색에.</target>
        </trans-unit>
        <trans-unit id="1841155eb0ee3f9c9cf0e86152c2cae307294a31" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;switchMap()&lt;/code&gt; returns service responses in their original request order, even if the server returns them out of order.</source>
          <target state="translated">참고 &lt;code&gt;switchMap()&lt;/code&gt; 경우에도 서버가 반환 그들을 위해의, 원래의 요청 순서대로 서비스 응답을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="371ce977d55087713aef1e408da4250d837a2de7" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;next()&lt;/code&gt; function could receive, for instance, message strings, or event objects, numeric values, or structures, depending on context. As a general term, we refer to data published by an observable as a &lt;em&gt;stream&lt;/em&gt;. Any type of value can be represented with an observable, and the values are published as a stream.</source>
          <target state="translated">유의 &lt;code&gt;next()&lt;/code&gt; 함수는 문맥에 따라, 예를 들면, 메시지 문자열 또는 이벤트 오브젝트의 수치, 또는 구조를 수신 할 수있다. 일반적인 용어로, Observable이 게시 한 데이터를 &lt;em&gt;스트림이라고&lt;/em&gt; 합니다. 모든 유형의 값은 관찰 가능 항목으로 표시 할 수 있으며 값은 스트림으로 게시됩니다.</target>
        </trans-unit>
        <trans-unit id="c91511586f712ff71725e5f19eb4c2db2e15c2c8" translate="yes" xml:space="preserve">
          <source>Note that a &lt;em&gt;style property&lt;/em&gt; name can be written in either &lt;a href=&quot;glossary#dash-case&quot;&gt;dash-case&lt;/a&gt;, as shown above, or &lt;a href=&quot;glossary#camelcase&quot;&gt;camelCase&lt;/a&gt;, such as &lt;code&gt;fontSize&lt;/code&gt;.</source>
          <target state="translated">&amp;bull; 그래도 참고 &lt;em&gt;스타일 속성&lt;/em&gt; 이름 중 하나로 기록 될 수 &lt;a href=&quot;glossary#dash-case&quot;&gt;대시의 경우&lt;/a&gt; 위, 또는, &lt;a href=&quot;glossary#camelcase&quot;&gt;낙타 표기법&lt;/a&gt; 등, &lt;code&gt;fontSize&lt;/code&gt; 는 .</target>
        </trans-unit>
        <trans-unit id="2e816deca44793ddded333f88d02c4f0e6a2a7b2" translate="yes" xml:space="preserve">
          <source>Note that an empty path route inherits its parent's parameters and data.</source>
          <target state="translated">빈 경로 경로는 부모의 매개 변수와 데이터를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="1b37c5555e13999349a3161dd595e9d2a95d261a" translate="yes" xml:space="preserve">
          <source>Note that applications still need to include the HammerJS script itself. This module simply sets up the coordination layer between HammerJS and Angular's EventManager.</source>
          <target state="translated">애플리케이션은 여전히 ​​HammerJS 스크립트 자체를 포함해야합니다. 이 모듈은 HammerJS와 Angular의 EventManager 간의 조정 계층을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="4f8d89dfcf5854efbd42160b602988ec718c432b" translate="yes" xml:space="preserve">
          <source>Note that at least one blank line must follow both the opening and closing &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; tags. A blank line before the closing &lt;code&gt;&amp;lt;/div&amp;gt;&lt;/code&gt; is customary but not required.</source>
          <target state="translated">적어도 하나의 빈 줄은 여는 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 태그 와 닫는 &amp;lt;div&amp;gt; 태그 뒤에 와야 합니다. &lt;code&gt;&amp;lt;/div&amp;gt;&lt;/code&gt; 앞의 빈 줄 은 일반적이지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9b626f4af6531e5f4974b843b016802cb9727623" translate="yes" xml:space="preserve">
          <source>Note that canceling a previous &lt;code&gt;searchHeroes()&lt;/code&gt; Observable doesn't actually abort a pending HTTP request. Unwanted results are simply discarded before they reach your application code.</source>
          <target state="translated">이전 &lt;code&gt;searchHeroes()&lt;/code&gt; Observable 을 취소 해도 보류중인 HTTP 요청이 실제로 중단되지는 않습니다. 원하지 않는 결과는 응용 프로그램 코드에 도달하기 전에 단순히 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f7658c270146f742e3ed9bf3731556300413061f" translate="yes" xml:space="preserve">
          <source>Note that even though you are in an AngularJS template, &lt;strong&gt;you're using Angular attribute syntax to bind the inputs and outputs&lt;/strong&gt;. This is a requirement for downgraded components. The expressions themselves are still regular AngularJS expressions.</source>
          <target state="translated">AngularJS 템플릿을 사용하더라도 &lt;strong&gt;Angular 속성 구문을 사용하여 입력 및 출력을 바인딩하고 있습니다&lt;/strong&gt; . 다운 그레이드 된 구성 요소의 요구 사항입니다. 표현식 자체는 여전히 일반 AngularJS 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="17b350c0decc0b8e8ef8ad4265e3e25f8978757d" translate="yes" xml:space="preserve">
          <source>Note that following two providers are not equal:</source>
          <target state="translated">다음 두 제공자는 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9e8240c7cf8f7e89866ec2b04033f2ee8c17466" translate="yes" xml:space="preserve">
          <source>Note that if you edit the proxy configuration file, you must relaunch the &lt;code&gt;ng serve&lt;/code&gt; process to make your changes effective.</source>
          <target state="translated">프록시 구성 파일을 편집하는 경우 변경 사항을 적용 하려면 &lt;code&gt;ng serve&lt;/code&gt; 프로세스를 다시 시작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a7abd4e4c5101e76c0963371f945f8c2d41ba413" translate="yes" xml:space="preserve">
          <source>Note that if your component has no inputs or you use it without providing any inputs, the framework will not call &lt;code&gt;ngOnChanges()&lt;/code&gt;.</source>
          <target state="translated">구성 요소에 입력이 없거나 입력을 제공하지 않고 사용하는 경우 프레임 워크는 &lt;code&gt;ngOnChanges()&lt;/code&gt; 호출하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a0ac6f65c4036b5af95673d0a0dac90055c3605d" translate="yes" xml:space="preserve">
          <source>Note that in order to make the &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; element Zone.js-aware in your app, you need to import the &lt;code&gt;zone-patch-canvas&lt;/code&gt; patch (either in &lt;code&gt;polyfills.ts&lt;/code&gt; or in the specific file that uses &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;):</source>
          <target state="translated">참고 있는지 확인하는 순서로 &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; 앱에서 Zone.js 인식 요소, 당신이 가져올 필요 &lt;code&gt;zone-patch-canvas&lt;/code&gt; 패치를 (에 하나 &lt;code&gt;polyfills.ts&lt;/code&gt; 또는 특정 파일에 그 용도 &lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="ff8a845004bcc17b79e75f4722a9a47d76c32c9e" translate="yes" xml:space="preserve">
          <source>Note that just as a form group contains a group of controls, the &lt;em&gt;profile form&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; is bound to the &lt;code&gt;form&lt;/code&gt; element with the &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; directive, creating a communication layer between the model and the form containing the inputs. The &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrolname&quot;&gt;formControlName&lt;/a&gt;&lt;/code&gt; input provided by the &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrolname&quot;&gt;FormControlName&lt;/a&gt;&lt;/code&gt; directive binds each individual input to the form control defined in &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt;. The form controls communicate with their respective elements. They also communicate changes to the form group instance, which provides the source of truth for the model value.</source>
          <target state="translated">양식 그룹에 컨트롤 그룹이 포함 된 &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; &lt;em&gt; 프로파일 양식&lt;/em&gt; 은 &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 지시문 을 사용하여 &lt;code&gt;form&lt;/code&gt; 요소에 바인딩되어 모델과 입력을 포함하는 양식 사이에 통신 계층을 만듭니다. &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrolname&quot;&gt;formControlName&lt;/a&gt;&lt;/code&gt; 에 의해 제공된 입력 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrolname&quot;&gt;FormControlName&lt;/a&gt;&lt;/code&gt; 의 지시문에 정의 된 형태로 각각의 제어 입력을 결합 &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 를 . 양식 컨트롤은 해당 요소와 통신합니다. 또한 모델 값에 대한 진실의 원천을 제공하는 변경 사항을 양식 그룹 인스턴스에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="64afdd7197085c1106aa085fc1e8732a73632f39" translate="yes" xml:space="preserve">
          <source>Note that just as a form group contains a group of controls, the &lt;em&gt;profileForm&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; is bound to the &lt;code&gt;form&lt;/code&gt; element with the &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; directive, creating a communication layer between the model and the form containing the inputs. The &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrolname&quot;&gt;formControlName&lt;/a&gt;&lt;/code&gt; input provided by the &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrolname&quot;&gt;FormControlName&lt;/a&gt;&lt;/code&gt; directive binds each individual input to the form control defined in &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt;. The form controls communicate with their respective elements. They also communicate changes to the form group instance, which provides the source of truth for the model value.</source>
          <target state="translated">양식 그룹에 컨트롤 그룹이 포함 된 &lt;em&gt;것처럼 profileForm &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 지시문 을 사용하여 &lt;code&gt;form&lt;/code&gt; 요소에 바인딩되어 모델과 입력이 포함 된 양식 사이에 통신 계층을 만듭니다. &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrolname&quot;&gt;formControlName&lt;/a&gt;&lt;/code&gt; 에 의해 제공된 입력 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrolname&quot;&gt;FormControlName&lt;/a&gt;&lt;/code&gt; 의 지시문에 정의 된 형태로 각각의 제어 입력을 결합 &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 를 . 양식 컨트롤은 해당 요소와 통신합니다. 또한 모델 값에 대한 진실의 소스를 제공하는 양식 그룹 인스턴스에 대한 변경 사항을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="bb4d1a4548c7df19999e19b754abea2e55c5b7a1" translate="yes" xml:space="preserve">
          <source>Note that libraries are intended to be used by Angular apps. To add Angular functionality to non-Angular web apps, you can use &lt;a href=&quot;elements&quot;&gt;Angular custom elements&lt;/a&gt;.</source>
          <target state="translated">라이브러리는 Angular 앱에서 사용하기위한 것입니다. Angular 이외의 웹 앱에 Angular 기능을 추가하려면 &lt;a href=&quot;elements&quot;&gt;Angular 사용자 정의 요소를&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ffe0242b2ab4216014a3cdb02468b566ba763c0" translate="yes" xml:space="preserve">
          <source>Note that sequences of &lt;code&gt;&amp;amp;ngsp;&lt;/code&gt; are still collapsed to just one space character when the &lt;code&gt;&lt;a href=&quot;component#preserveWhitespaces&quot;&gt;preserveWhitespaces&lt;/a&gt;&lt;/code&gt; option is set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">그 서열 주 &lt;code&gt;&amp;amp;ngsp;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;component#preserveWhitespaces&quot;&gt;preserveWhitespaces&lt;/a&gt;&lt;/code&gt; 옵션이 &lt;code&gt;false&lt;/code&gt; 로 설정된 경우 여전히 공백 문자 하나로 축소됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a3b6e4c1ee0fcab165a19b23bfdaa088363d3f7" translate="yes" xml:space="preserve">
          <source>Note that sequences of &lt;code&gt;&amp;amp;ngsp;&lt;/code&gt; are still collapsed to just one space character when the &lt;code&gt;preserveWhitespaces&lt;/code&gt; option is set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">그 서열 주 &lt;code&gt;&amp;amp;ngsp;&lt;/code&gt; &lt;code&gt;preserveWhitespaces&lt;/code&gt; 옵션이 &lt;code&gt;false&lt;/code&gt; 로 설정된 경우에도 여전히 하나의 공백 문자로 축소됩니다 .</target>
        </trans-unit>
        <trans-unit id="23dfb95da673b7ac7ded68100af6e16d3ba6250a" translate="yes" xml:space="preserve">
          <source>Note that support for using the &lt;code&gt;&lt;a href=&quot;ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; input property and &lt;code&gt;ngModelChange&lt;/code&gt; event with reactive form directives was deprecated in Angular v6 and is scheduled for removal in a future version of Angular. For details, see &lt;a href=&quot;../../guide/deprecations#ngmodel-with-reactive-forms&quot;&gt;Deprecated features&lt;/a&gt;.</source>
          <target state="translated">사용에 대한 지원 참고 &lt;code&gt;&lt;a href=&quot;ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 의 입력 속성과 &lt;code&gt;ngModelChange&lt;/code&gt; 의 반응 양식의 지침에 이벤트가 각도 V6 사용되지 않습니다 및 각도의 향후 버전에서 제거 될 예정이다. 자세한 내용은 더 이상 &lt;a href=&quot;../../guide/deprecations#ngmodel-with-reactive-forms&quot;&gt;사용되지 않는 기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="351b13372de295a6f697a0c13c719516a9c8ad6d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;httprequest#responseType&quot;&gt;responseType&lt;/a&gt;&lt;/code&gt;&lt;em&gt;options&lt;/em&gt; value is a String that identifies the single data type of the response. A single overload version of the method handles each response type. The value of &lt;code&gt;&lt;a href=&quot;httprequest#responseType&quot;&gt;responseType&lt;/a&gt;&lt;/code&gt; cannot be a union, as the combined signature could imply.</source>
          <target state="translated">참고 것을 &lt;code&gt;&lt;a href=&quot;httprequest#responseType&quot;&gt;responseType&lt;/a&gt;&lt;/code&gt; 의&lt;em&gt; 옵션&lt;/em&gt; 값이 문자열인지 식별 응답의 단일 데이터 유형입니다. 메소드의 단일 과부하 버전은 각 응답 유형을 처리합니다. 결합 된 서명이 암시 할 수 있으므로 &lt;code&gt;&lt;a href=&quot;httprequest#responseType&quot;&gt;responseType&lt;/a&gt;&lt;/code&gt; 의 값은 공용체가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ff72644092676c60c465ebbeff0102fd3d910a95" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;it()&lt;/code&gt; function receives an argument of the following form.</source>
          <target state="translated">점을 유의 &lt;code&gt;it()&lt;/code&gt; 함수는 다음과 같은 형태의 인수를 수신한다.</target>
        </trans-unit>
        <trans-unit id="34c69b110792ba8e5360583e38093c34f592ed9f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;ngDirectiveDef&lt;/code&gt; property's code is switched depending if VE is present or not (this allows for the binding code to be set only for newer versions of Angular).</source>
          <target state="translated">점을 유의 &lt;code&gt;ngDirectiveDef&lt;/code&gt; 의 VE 경우 부동산의 코드는 따라서 전환된다 (바인딩 코드 만 각도의 새 버전을 설정할 수 있도록 허용이) 존재 여부이다.</target>
        </trans-unit>
        <trans-unit id="3eada5ddfb3fe75b9f5c78a68d447fd421206301" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;notification&lt;/code&gt; property does &lt;strong&gt;not&lt;/strong&gt; contain a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Notification&quot;&gt;Notification&lt;/a&gt; object but rather a &lt;a href=&quot;https://notifications.spec.whatwg.org/#dictdef-notificationoptions&quot;&gt;NotificationOptions&lt;/a&gt; object that also includes the &lt;code&gt;title&lt;/code&gt; of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Notification&quot;&gt;Notification&lt;/a&gt; object.</source>
          <target state="translated">참고 것을 &lt;code&gt;notification&lt;/code&gt; 속성은 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 포함 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Notification&quot;&gt;통지&lt;/a&gt; 객체를 오히려 &lt;a href=&quot;https://notifications.spec.whatwg.org/#dictdef-notificationoptions&quot;&gt;NotificationOptions은&lt;/a&gt; 또한 포함 개체 &lt;code&gt;title&lt;/code&gt; 의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Notification&quot;&gt;알림&lt;/a&gt; 개체를.</target>
        </trans-unit>
        <trans-unit id="a04c213fee3ffca8a5d0f569f12ebd7f77b67863" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;projects&lt;/code&gt; section of the configuration file does not correspond exactly to the workspace file structure.</source>
          <target state="translated">구성 파일 의 &lt;code&gt;projects&lt;/code&gt; 섹션은 작업 공간 파일 구조와 정확히 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="319fb4850f23ccfc80b3389db79f718317b816a2" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;responseType&lt;/code&gt;&lt;em&gt;options&lt;/em&gt; value is a String that identifies the single data type of the response. A single overload version of the method handles each response type. The value of &lt;code&gt;responseType&lt;/code&gt; cannot be a union, as the combined signature could imply.</source>
          <target state="translated">참고 것을 &lt;code&gt;responseType&lt;/code&gt; 의&lt;em&gt;옵션&lt;/em&gt; 값이 문자열인지 식별 응답의 단일 데이터 유형입니다. 메서드의 단일 오버로드 버전이 각 응답 유형을 처리합니다. 결합 된 서명이 의미 할 수 있으므로 &lt;code&gt;responseType&lt;/code&gt; 의 값은 공용체가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6989a436d4daeec411945fd1ba3b22481eeefaaa" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;send()&lt;/code&gt; method simulates latency by waiting a second before &quot;sending&quot; the message and closing the popup.</source>
          <target state="translated">&lt;code&gt;send()&lt;/code&gt; 메소드는 메시지를 &quot;보내기&quot;전에 팝업을 닫고 잠깐 대기함으로써 대기 시간을 시뮬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="cda08a86a9d72586f755e0d251c62fa6f93164fc" translate="yes" xml:space="preserve">
          <source>Note that the &lt;em&gt;Submit&lt;/em&gt; button is disabled, and the &quot;required&quot; bar to the left of the input control changes from green to red.</source>
          <target state="translated">점을 유의 &lt;em&gt;제출&lt;/em&gt; 버튼을 비활성화하고 입력 컨트롤의 왼쪽에 &quot;필요한&quot;줄이 녹색에서 빨간색으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="ece94366823fee671395805609d6a79af7a6a2da" translate="yes" xml:space="preserve">
          <source>Note that the code referenced on these pages is available as a live example.</source>
          <target state="translated">이 페이지에서 참조 된 코드는 실제 예제로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="88b11652543ed488fbf0f5540bb077e930fa39b8" translate="yes" xml:space="preserve">
          <source>Note that the corresponding left-nav TOC text should be in &quot;title case&quot;, which means that you use capital letters to start the first words and all principal words. Use lower case letters for secondary words such as &quot;in&quot;, &quot;of&quot;, and &quot;the&quot;. The TOC title can also be shortened to fit in the column.</source>
          <target state="translated">해당하는 왼쪽 탐색 목차 텍스트는 &quot;제목 대소 문자&quot;여야합니다. 즉, 대문자를 사용하여 첫 번째 단어와 모든 주요 단어를 시작해야합니다. &quot;in&quot;, &quot;of&quot;및 &quot;the&quot;와 같은 보조 단어에는 소문자를 사용하십시오. 목차 제목은 열에 맞게 축약 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="40cbe8d312f91667084c7ceb22720698f2595209" translate="yes" xml:space="preserve">
          <source>Note that the reference to the array returned for a &lt;code&gt;multi&lt;/code&gt; provider is shared between all the places where the token is injected. We recommend avoiding mutations of the array (especially for predefined tokens) as it may lead to unexpected behavior in other parts of the app that inject the same token. You can prevent the value from being mutated by setting its type to &lt;code&gt;ReadonlyArray&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;multi&lt;/code&gt; 공급자에 대해 반환 된 배열에 대한 참조 는 토큰이 삽입 된 모든 위치에서 공유됩니다. 동일한 토큰을 주입하는 앱의 다른 부분에서 예기치 않은 동작이 발생할 수 있으므로 배열의 변형 (특히 사전 정의 된 토큰의 경우)을 피하는 것이 좋습니다. 유형을 &lt;code&gt;ReadonlyArray&lt;/code&gt; 로 설정하여 값이 변경되는 것을 방지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef3cdbe1eac1af4f319fa3cd4702af2572876e7f" translate="yes" xml:space="preserve">
          <source>Note that the translation unit &lt;code&gt;id=introductionHeader&lt;/code&gt; is derived from the &lt;a href=&quot;i18n#custom-id&quot;&gt;custom &lt;code&gt;id&lt;/code&gt;&lt;/a&gt; that you set earlier, but without the &lt;code&gt;@@&lt;/code&gt; prefix required in the source HTML.</source>
          <target state="translated">번역 단위 &lt;code&gt;id=introductionHeader&lt;/code&gt; 는 소스 HTML에 &lt;code&gt;@@&lt;/code&gt; 접두사가 필요 하지 않지만 앞에서 설정 한 &lt;a href=&quot;i18n#custom-id&quot;&gt;사용자 지정 &lt;code&gt;id&lt;/code&gt; &lt;/a&gt; 에서 파생됩니다 .</target>
        </trans-unit>
        <trans-unit id="d9dec383a5fa4e7e3d1bde69011b0bab8664efb1" translate="yes" xml:space="preserve">
          <source>Note that the value of the component's &lt;code&gt;quote&lt;/code&gt; property passes through an &lt;code&gt;&lt;a href=&quot;../api/common/asyncpipe&quot;&gt;AsyncPipe&lt;/a&gt;&lt;/code&gt;. That means the property returns either a &lt;code&gt;Promise&lt;/code&gt; or an &lt;code&gt;Observable&lt;/code&gt;.</source>
          <target state="translated">컴포넌트의 &lt;code&gt;quote&lt;/code&gt; 속성 값은 &lt;code&gt;&lt;a href=&quot;../api/common/asyncpipe&quot;&gt;AsyncPipe&lt;/a&gt;&lt;/code&gt; 를 통과합니다 . 즉, 속성이 &lt;code&gt;Promise&lt;/code&gt; 또는 &lt;code&gt;Observable&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8af192be64614a476062c8741e1ff62807509a16" translate="yes" xml:space="preserve">
          <source>Note that these transformations can influence DOM nodes layout, although impact should be minimal.</source>
          <target state="translated">이러한 변환은 영향을 최소화해야하지만 DOM 노드 레이아웃에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08e64abef6e8f8eb83708761218250d9e7c3a3ec" translate="yes" xml:space="preserve">
          <source>Note that this AngularJS is an element directive (&lt;code&gt;restrict: 'E'&lt;/code&gt;) called &lt;code&gt;heroDetail&lt;/code&gt;. An AngularJS element directive is matched based on its &lt;em&gt;name&lt;/em&gt;. &lt;em&gt;The &lt;code&gt;selector&lt;/code&gt; metadata of the downgraded Angular component is ignored.&lt;/em&gt;</source>
          <target state="translated">이 AngularJS는 &lt;code&gt;heroDetail&lt;/code&gt; 이라는 요소 지시문 ( &lt;code&gt;restrict: 'E'&lt;/code&gt; ) 입니다. AngularJS 요소 지시어는 &lt;em&gt;이름을&lt;/em&gt; 기준으로 일치 합니다. &lt;em&gt;다운 그레이드 된 Angular 컴포넌트 &lt;/em&gt;&lt;em&gt;의 &lt;/em&gt;&lt;em&gt; &lt;code&gt;selector&lt;/code&gt; &lt;/em&gt;&lt;em&gt; 메타 데이터는 무시됩니다.&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8be4d44b8ca0d811ed7f0aacc58c28920fe2d083" translate="yes" xml:space="preserve">
          <source>Note that this change doesn't make existing libraries distributed in this format incompatible with the Angular CLI. The CLI will fall back and consume libraries in less desirable formats if others are not available. However, we do recommend that libraries ship their code in ES2015 format in order to make builds faster and build output smaller.</source>
          <target state="translated">이 변경으로 인해이 형식으로 배포 된 기존 라이브러리가 Angular CLI와 호환되지 않는 것은 아닙니다. CLI는 다른 것을 사용할 수없는 경우 폴백하고 덜 바람직한 형식으로 라이브러리를 사용합니다. 그러나 빌드를 더 빠르게 만들고 출력을 더 작게 만들기 위해 라이브러리가 ES2015 형식으로 코드를 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5be5650f7374d16358a82f53d2b53b69ac973171" translate="yes" xml:space="preserve">
          <source>Note that this example doesn't need to use &lt;code&gt;&lt;a href=&quot;../api/animations/state&quot;&gt;state&lt;/a&gt;()&lt;/code&gt;.</source>
          <target state="translated">이 예제에서는 &lt;code&gt;&lt;a href=&quot;../api/animations/state&quot;&gt;state&lt;/a&gt;()&lt;/code&gt; 를 사용할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e8395a5810b920638cc768b89d9fffa47ac18586" translate="yes" xml:space="preserve">
          <source>Note that this example doesn't need to use &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/%24locationshim#state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 예제는 &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/%24locationshim#state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; 를 사용할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="421e165c199e48890baa747e72133bfe28cb9468" translate="yes" xml:space="preserve">
          <source>Note that this feature is designed to be used with &lt;code&gt;&lt;a href=&quot;query&quot;&gt;query&lt;/a&gt;()&lt;/code&gt; and it will only work with animations that are assigned using the Angular animation library. CSS keyframes and transitions are not handled by this API.</source>
          <target state="translated">이 기능은 &lt;code&gt;&lt;a href=&quot;query&quot;&gt;query&lt;/a&gt;()&lt;/code&gt; 와 함께 사용하도록 설계되었으며 Angular 애니메이션 라이브러리를 사용하여 할당 된 애니메이션에서만 작동합니다. 이 API는 CSS 키 프레임 및 전환을 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ebfa7ac8d26be4b55b063af5dc86cd82d5f5aa83" translate="yes" xml:space="preserve">
          <source>Note that this happens very frequently, so any operation you perform here impacts performance significantly. See details in &lt;a href=&quot;lifecycle-hooks#onchanges&quot;&gt;Using change detection hooks&lt;/a&gt; in this document.</source>
          <target state="translated">이것은 매우 자주 발생하므로 여기서 수행하는 모든 작업은 성능에 상당한 영향을 미칩니다. 이 문서의 &lt;a href=&quot;lifecycle-hooks#onchanges&quot;&gt;변경 감지 후크 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="91d89d44f2b80821dee75ead449fb42cd0120b82" translate="yes" xml:space="preserve">
          <source>Note that this is true for any kind of polling done by your application. Check the &lt;a href=&quot;../api/core/applicationref#isStable&quot;&gt;isStable&lt;/a&gt; documentation for more information.</source>
          <target state="translated">이것은 응용 프로그램에서 수행하는 모든 종류의 폴링에 해당됩니다. 자세한 내용 은 &lt;a href=&quot;../api/core/applicationref#isStable&quot;&gt;isStable&lt;/a&gt; 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d6bb4ab06dccbc865c75f8c110a1f644eead5884" translate="yes" xml:space="preserve">
          <source>Note that this syntax is only necessary for attribute &lt;em&gt;bindings&lt;/em&gt;. Static ARIA attributes require no extra syntax.</source>
          <target state="translated">이 구문은 속성 &lt;em&gt;바인딩&lt;/em&gt; 에만 필요합니다 . 정적 ARIA 속성에는 추가 구문이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec12aa6967ca02e1c10b021742d62a604dd21e02" translate="yes" xml:space="preserve">
          <source>Note that timezone correction is not applied to an ISO string that has no time component, such as &quot;2016-09-19&quot;</source>
          <target state="translated">&quot;2016-09-19&quot;와 같이 시간 구성 요소가없는 ISO 문자열에는 시간대 수정이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c830565880b49e4eeb62db7c303088ac3a720c20" translate="yes" xml:space="preserve">
          <source>Note that we check if:</source>
          <target state="translated">다음 사항을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1ef5d74df63ffb44b460059539d2472fd656e4d3" translate="yes" xml:space="preserve">
          <source>Note that we must do the following:</source>
          <target state="translated">다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="056959b35180cefb50ec268d788c700a2899a082" translate="yes" xml:space="preserve">
          <source>Note that when using &lt;code&gt;&lt;a href=&quot;pathlocationstrategy&quot;&gt;PathLocationStrategy&lt;/a&gt;&lt;/code&gt;, neither the query nor the fragment in the &lt;code&gt;&amp;lt;base href&amp;gt;&lt;/code&gt; will be preserved, as outlined by the &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5.2.2&quot;&gt;RFC&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;pathlocationstrategy&quot;&gt;PathLocationStrategy&lt;/a&gt;&lt;/code&gt; 를 사용할 때 &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5.2.2&quot;&gt;RFC에&lt;/a&gt; 설명 된대로 &lt;code&gt;&amp;lt;base href&amp;gt;&lt;/code&gt; 의 쿼리 나 조각 이 보존 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6fd7daeb5d32df96dc1e97e8776e1f8a9ef86814" translate="yes" xml:space="preserve">
          <source>Note that when you call the &lt;code&gt;&lt;a href=&quot;sequence&quot;&gt;sequence&lt;/a&gt;()&lt;/code&gt; function within a &lt;code&gt;&lt;a href=&quot;group&quot;&gt;group()&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; call, execution does not continue to the next instruction until each of the inner animation steps have completed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;group&quot;&gt;group()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; () 호출 내 에서 &lt;code&gt;&lt;a href=&quot;sequence&quot;&gt;sequence&lt;/a&gt;()&lt;/code&gt; 함수 를 호출하면 각 내부 애니메이션 단계가 완료 될 때까지 다음 명령으로 계속 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be893394cee0a145ef756f47231d1847f588f89f" translate="yes" xml:space="preserve">
          <source>Note that you are bootstrapping the AngularJS module from inside &lt;code&gt;ngDoBootstrap&lt;/code&gt;. The arguments are the same as you would pass to &lt;code&gt;angular.bootstrap&lt;/code&gt; if you were manually bootstrapping AngularJS: the root element of the application; and an array of the AngularJS 1.x modules that you want to load.</source>
          <target state="translated">&lt;code&gt;ngDoBootstrap&lt;/code&gt; 내부에서 AngularJS 모듈을 부트 스트랩하고 있습니다. 인수는 AngularJS를 수동으로 부트 스트랩하는 경우 &lt;code&gt;angular.bootstrap&lt;/code&gt; 에 전달하는 것과 동일 합니다. 응용 프로그램의 루트 요소입니다. 로드하려는 AngularJS 1.x 모듈의 배열.</target>
        </trans-unit>
        <trans-unit id="cf695c0a43431597310e3a096780bdf1a25a0a2a" translate="yes" xml:space="preserve">
          <source>Note that you do not add a &lt;code&gt;bootstrap&lt;/code&gt; declaration to the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; decorator, since AngularJS will own the root template of the application.</source>
          <target state="translated">AngularJS는 응용 프로그램의 루트 템플릿을 소유하므로 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt; 데코레이터에 &lt;code&gt;bootstrap&lt;/code&gt; 선언을 추가하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="adb0b88be476a8167b20fa7f79cb326e9c071ed0" translate="yes" xml:space="preserve">
          <source>Note that you generally don't wrap a floating image in a &lt;code&gt;&amp;lt;figure&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">일반적으로 &lt;code&gt;&amp;lt;figure&amp;gt;&lt;/code&gt; 요소 에서 플로팅 이미지를 래핑하지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4a8f294ffa6daaf2b5c139214569f54000eef3b3" translate="yes" xml:space="preserve">
          <source>Note that you will also need to add any styles or scripts to the &lt;code&gt;test&lt;/code&gt; builder if you need them for unit tests. See also &lt;a href=&quot;using-libraries#using-runtime-global-libraries-inside-your-app&quot;&gt;Using runtime-global libraries inside your app&lt;/a&gt;.</source>
          <target state="translated">단위 테스트에 필요한 스타일이나 스크립트를 &lt;code&gt;test&lt;/code&gt; 빌더 에 추가 해야합니다. &lt;a href=&quot;using-libraries#using-runtime-global-libraries-inside-your-app&quot;&gt;앱에서 런타임 전역 라이브러리 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c018b75d4dd18f6059b6d8161aef4013d7ce967" translate="yes" xml:space="preserve">
          <source>Note that, for Angular apps, we prefer combining operators with pipes, rather than chaining. Chaining is used in many RxJS examples.</source>
          <target state="translated">Angular 앱의 경우 체인이 아닌 파이프와 연산자를 결합하는 것이 좋습니다. 체인은 많은 RxJS 예제에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4b45d8a6390f37dc310a52b481d3394cf640e928" translate="yes" xml:space="preserve">
          <source>Note that, in addition to these options for configuring a directive, you can control a component's runtime behavior by implementing life-cycle hooks. For more information, see the &lt;a href=&quot;../../guide/lifecycle-hooks&quot;&gt;Lifecycle Hooks&lt;/a&gt; guide.</source>
          <target state="translated">지시문을 구성하기위한 이러한 옵션 외에도 수명주기 후크를 구현하여 구성 요소의 런타임 동작을 제어 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;../../guide/lifecycle-hooks&quot;&gt;Lifecycle Hooks&lt;/a&gt; 안내서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">참고 :</target>
        </trans-unit>
        <trans-unit id="79ec0a3a3410a9394d865a734738613b13696ade" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;multi: true&lt;/code&gt; option. This required setting tells Angular that &lt;code&gt;&lt;a href=&quot;../api/common/http/http_interceptors&quot;&gt;HTTP_INTERCEPTORS&lt;/a&gt;&lt;/code&gt; is a token for a &lt;em&gt;multiprovider&lt;/em&gt; that injects an array of values, rather than a single value.</source>
          <target state="translated">&lt;code&gt;multi: true&lt;/code&gt; 옵션을 참고하십시오 . 이 필수 설정은 Angular에 &lt;code&gt;&lt;a href=&quot;../api/common/http/http_interceptors&quot;&gt;HTTP_INTERCEPTORS&lt;/a&gt;&lt;/code&gt; 가 단일 값이 아닌 값의 배열을 주입하는 &lt;em&gt;다중 &lt;/em&gt;제공자 의 토큰 임을 알립니다 .</target>
        </trans-unit>
        <trans-unit id="d6b7cf1b943cb4ca234f1fab970190b16a27ac91" translate="yes" xml:space="preserve">
          <source>Note the backticks ( ` ) that define a JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals&quot;&gt;&lt;em&gt;template literal&lt;/em&gt;&lt;/a&gt; for embedding the &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; 를 임베드하기위한 JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals&quot;&gt;&lt;em&gt;템플리트 리터럴&lt;/em&gt;&lt;/a&gt; 을 정의하는 백틱 (`)에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="48705657f490f3c04c65c3eeda89c8bf0e4d4e85" translate="yes" xml:space="preserve">
          <source>Note the following key points:</source>
          <target state="translated">다음 핵심 사항을 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="39f97c98c2dc337a2b518dcedf8284cf48fc62b0" translate="yes" xml:space="preserve">
          <source>Note the following three important points:</source>
          <target state="translated">다음 세 가지 중요한 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="20d78a8e421517dfc8501178399cb2a435e63306" translate="yes" xml:space="preserve">
          <source>Note the following:</source>
          <target state="translated">다음에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="dab531dc7a8ff3633c010ee3956d7a697965ef13" translate="yes" xml:space="preserve">
          <source>Note two important points about &lt;code&gt;isStable&lt;/code&gt;, demonstrated in the examples below:</source>
          <target state="translated">&lt;code&gt;isStable&lt;/code&gt; 에 대한 두 가지 중요한 점에 유의하십시오 ( 아래 예에서 설명 함).</target>
        </trans-unit>
        <trans-unit id="06abd960aeb0fb638122d836dc3ba0400f8fc4fe" translate="yes" xml:space="preserve">
          <source>Note, adding try-finally block around the work to ensure that &lt;code&gt;&lt;a href=&quot;wtfleave&quot;&gt;wtfLeave&lt;/a&gt;&lt;/code&gt; gets called can negatively impact the performance of your application. For this reason we recommend that you don't add them to ensure that &lt;code&gt;&lt;a href=&quot;wtfleave&quot;&gt;wtfLeave&lt;/a&gt;&lt;/code&gt; gets called. In production &lt;code&gt;&lt;a href=&quot;wtfleave&quot;&gt;wtfLeave&lt;/a&gt;&lt;/code&gt; is a noop and so try-finally block has no value. When debugging perf issues, skipping &lt;code&gt;&lt;a href=&quot;wtfleave&quot;&gt;wtfLeave&lt;/a&gt;&lt;/code&gt;, do to exception, will produce incorrect trace, but presence of exception signifies logic error which needs to be fixed before the app should be profiled. Add try-finally only when you expect that an exception is expected during normal execution while profiling.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;wtfleave&quot;&gt;wtfLeave&lt;/a&gt;&lt;/code&gt; 가 호출 되도록 응용 프로그램에 try-finally block을 추가하면 응용 프로그램의 성능에 부정적인 영향을 줄 수 있습니다. 이러한 이유로 &lt;code&gt;&lt;a href=&quot;wtfleave&quot;&gt;wtfLeave&lt;/a&gt;&lt;/code&gt; 가 호출 되도록하기 위해 추가하지 않는 것이 좋습니다 . 생산에서 &lt;code&gt;&lt;a href=&quot;wtfleave&quot;&gt;wtfLeave&lt;/a&gt;&lt;/code&gt; 는 아무것도 실행 등 시도 - finally 블록은 값이 없습니다. 성능 문제를 디버깅 할 때 &lt;code&gt;&lt;a href=&quot;wtfleave&quot;&gt;wtfLeave&lt;/a&gt;&lt;/code&gt; 를 건너 뛰고 예외를 수행하면 잘못된 추적이 생성되지만 예외가 있으면 앱을 프로파일 링하기 전에 수정해야하는 논리 오류를 나타냅니다. 프로파일 링하는 동안 정상적인 실행 중에 예외가 예상 될 때만 최종 시도를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="64f2409d31c24c872c979ce060ccc2926fe669dc" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;glossary#ahead-of-time-aot-compilation&quot;&gt;Ahead-of-time (AOT) compilation&lt;/a&gt; is required to localize component templates. If you changed this setting, set &lt;code&gt;&quot;aot&quot;&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; in order to use AOT.</source>
          <target state="translated">참고 : 구성 요소 템플릿을 지역화하려면 &lt;a href=&quot;glossary#ahead-of-time-aot-compilation&quot;&gt;AOT (Ahead-of-time) 컴파일&lt;/a&gt; 이 필요합니다. 이 설정을 변경 한 경우 AOT를 사용하려면 &lt;code&gt;&quot;aot&quot;&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb68d0df1914477a443a6cf208a67f3509b99949" translate="yes" xml:space="preserve">
          <source>Note: Angular API and CLI reference docs are generated from source code and/or related source files, which may have other markup styles and other ways of including code examples.</source>
          <target state="translated">참고 : Angular API 및 CLI 참조 문서는 소스 코드 및 / 또는 관련 소스 파일에서 생성되며 다른 마크 업 스타일과 코드 예제를 포함하는 다른 방법이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff636c630822e543aff0ab34cf9b6830952f048c" translate="yes" xml:space="preserve">
          <source>Note: Document might not be available in the Application Context when Application and Rendering Contexts are not the same (e.g. when running the application in a Web Worker).</source>
          <target state="translated">참고 : 응용 프로그램과 렌더링 컨텍스트가 동일하지 않은 경우 (예 : 웹 작업자에서 응용 프로그램을 실행할 때) 응용 프로그램 컨텍스트에서 문서를 사용하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e4ccabf68a50f33aef31845365abff1f84b25a3" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;--i18n-locale&lt;/code&gt; option is deprecated. Angular 9 uses the source locale configured in your app's &lt;a href=&quot;workspace-config&quot;&gt;workspace configuration&lt;/a&gt; file (&lt;code&gt;angular.json&lt;/code&gt;).</source>
          <target state="translated">참고 : &lt;code&gt;--i18n-locale&lt;/code&gt; 옵션은 더 이상 사용되지 않습니다. Angular 9는 앱의 &lt;a href=&quot;workspace-config&quot;&gt;작업 영역 구성&lt;/a&gt; 파일 ( &lt;code&gt;angular.json&lt;/code&gt; )에 구성된 소스 로캘을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="40fbd5cd3d04b0e517568e5277794798330dc515" translate="yes" xml:space="preserve">
          <source>Note: The preceding example uses a variable, &lt;code&gt;name&lt;/code&gt;, and assigns it the value based on the &lt;code&gt;name&lt;/code&gt; parameter.</source>
          <target state="translated">참고 : 앞의 예에서는 변수 &lt;code&gt;name&lt;/code&gt; 을 사용 하고 &lt;code&gt;name&lt;/code&gt; 매개 변수 에 따라 값을 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="8bd8b1cd4fae0cc49dd6a27ba7f0ab23bbc6b08a" translate="yes" xml:space="preserve">
          <source>Note: This works for JIT and AOTed components as well.</source>
          <target state="translated">참고 : 이것은 JIT 및 AOTed 구성 요소에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="97967d1a85f3b5492d61dd355f4be7d12006ee7c" translate="yes" xml:space="preserve">
          <source>Note: Use &lt;code&gt;&lt;a href=&quot;testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; in tests. It will be set to either &lt;code&gt;TestBedViewEngine&lt;/code&gt; or &lt;code&gt;TestBedRender3&lt;/code&gt; according to the compiler used.</source>
          <target state="translated">참고 : 테스트에서 &lt;code&gt;&lt;a href=&quot;testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; 를 사용하십시오 . 사용 된 컴파일러에 따라 &lt;code&gt;TestBedViewEngine&lt;/code&gt; 또는 &lt;code&gt;TestBedRender3&lt;/code&gt; 으로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="418efdf508a0626a97351f56a820e24ec7fc1046" translate="yes" xml:space="preserve">
          <source>Note: for performance reasons, Angular only runs async validators if all sync validators pass. Each must complete before errors are set.</source>
          <target state="translated">참고 : 성능상의 이유로 Angular는 모든 동기화 유효성 검사기가 통과 한 경우에만 비동기 유효성 검사기를 실행합니다. 오류가 설정되기 전에 각각 완료해야합니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="602f8eac033454f2990ff3d64fb991793d948731" translate="yes" xml:space="preserve">
          <source>Notice how a hero is added:</source>
          <target state="translated">영웅이 추가되는 방법에 주목하십시오.</target>
        </trans-unit>
        <trans-unit id="91a83f73eff71bb169090a9c9cc3574feccd6052" translate="yes" xml:space="preserve">
          <source>Notice how the test uses &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;&lt;em&gt;destructuring assignment&lt;/em&gt;&lt;/a&gt; to extract the setup variables that it needs.</source>
          <target state="translated">테스트에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;&lt;em&gt;소멸 할당&lt;/em&gt;&lt;/a&gt; 을 사용하여 필요한 설정 변수를 추출하는 방법에 주목하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3528d0c0a9120f561dcd38069f4008a50dfeb8b" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Item&lt;/code&gt; is an object that it has two properties; an &lt;code&gt;id&lt;/code&gt; and a &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">통지 &lt;code&gt;Item&lt;/code&gt; 이 두 가지 속성을 가지고 객체이다; &lt;code&gt;id&lt;/code&gt; 와 &lt;code&gt;name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25e723887b9236f1ebd791dfe2095875e35d36a8" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;TestBed.configureTestingModule&lt;/code&gt; no longer provides a (fake) &lt;code&gt;HeroService&lt;/code&gt; because it's &lt;a href=&quot;testing#spy-stub&quot;&gt;not needed&lt;/a&gt;.</source>
          <target state="translated">공지 사항 것을 &lt;code&gt;TestBed.configureTestingModule&lt;/code&gt; 는 더 이상 (가짜) 제공하지 않습니다 &lt;code&gt;HeroService&lt;/code&gt; 를 가 있기 때문에 &lt;a href=&quot;testing#spy-stub&quot;&gt;필요하지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01382c4ad55f4d450ca9e481ca0f514ec984b971" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;TestBed.configureTestingModule&lt;/code&gt; no longer provides a (fake) &lt;code&gt;HeroService&lt;/code&gt; because it's &lt;a href=&quot;testing-components-scenarios#spy-stub&quot;&gt;not needed&lt;/a&gt;.</source>
          <target state="translated">공지 사항 것을 &lt;code&gt;TestBed.configureTestingModule&lt;/code&gt; 는 더 이상 (가짜) 제공하지 않습니다 &lt;code&gt;HeroService&lt;/code&gt; 를 가 있기 때문에 &lt;a href=&quot;testing-components-scenarios#spy-stub&quot;&gt;필요하지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b500bf30eab2f8529bfd5af81ba25174f2a3133" translate="yes" xml:space="preserve">
          <source>Notice that Angular frequently calls &lt;code&gt;&lt;a href=&quot;../api/core/afterviewchecked&quot;&gt;AfterViewChecked&lt;/a&gt;()&lt;/code&gt;, often when there are no changes of interest. Write lean hook methods to avoid performance problems.</source>
          <target state="translated">Angular 는 종종 관심있는 변경 사항이 없을 때 &lt;code&gt;&lt;a href=&quot;../api/core/afterviewchecked&quot;&gt;AfterViewChecked&lt;/a&gt;()&lt;/code&gt; 호출합니다 . 성능 문제를 피하기 위해 린 후크 방법을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="4c964d9b66e51dcb8dee8e30d5c4fa9a97be13f9" translate="yes" xml:space="preserve">
          <source>Notice that all of the files the browser needs to render this application are cached. The &lt;code&gt;ngsw-config.json&lt;/code&gt; boilerplate configuration is set up to cache the specific resources used by the CLI:</source>
          <target state="translated">브라우저가이 응용 프로그램을 렌더링하는 데 필요한 모든 파일이 캐시됩니다. &lt;code&gt;ngsw-config.json&lt;/code&gt; 의 보일러 구성은 캐시에 CLI에서 사용하는 특정 자원을 설정 :</target>
        </trans-unit>
        <trans-unit id="16663f50c00b3a5325060aaa5e2ae8160f0fd60a" translate="yes" xml:space="preserve">
          <source>Notice that each &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element has an &lt;code&gt;id&lt;/code&gt; property. This is used by the &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; element's &lt;code&gt;for&lt;/code&gt; attribute to match the label to its input control. This is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label&quot;&gt;standard HTML feature&lt;/a&gt;.</source>
          <target state="translated">각 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 요소에는 &lt;code&gt;id&lt;/code&gt; 속성이 있습니다. 이것은 레이블을 입력 컨트롤과 일치시키기 &lt;code&gt;for&lt;/code&gt; &lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; 요소의 for 속성에 의해 사용됩니다 . 이것은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label&quot;&gt;표준 HTML 기능&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1cbe3b7b1030eb6319dda67c737f79e1a57d4ed5" translate="yes" xml:space="preserve">
          <source>Notice that even though the &lt;a href=&quot;dependency-injection-in-action#optional&quot;&gt;@Optional&lt;/a&gt; qualifier is there for safety, the  confirms that the &lt;code&gt;alex&lt;/code&gt; parameter is set.</source>
          <target state="translated">&lt;a href=&quot;dependency-injection-in-action#optional&quot;&gt;@Optional&lt;/a&gt; 한정자가 안전을 위해 있어도 &lt;code&gt;alex&lt;/code&gt; 매개 변수가 설정 되었음을 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="9475b2943f5dbda5c95807297eaddbdaad75c9f5" translate="yes" xml:space="preserve">
          <source>Notice that if you subscribe twice, there will be two separate streams, each emitting values every second. It looks something like this:</source>
          <target state="translated">두 번 구독하면 두 개의 개별 스트림이 있으며 각 스트림은 매 초마다 값을 방출합니다. 다음과 같이 보입니다 :</target>
        </trans-unit>
        <trans-unit id="0ec0b6daf045d676b267add4e36ed2b4e7a5d32e" translate="yes" xml:space="preserve">
          <source>Notice that in the module &lt;code&gt;imports&lt;/code&gt; array, the &lt;code&gt;AppRoutingModule&lt;/code&gt; is last and comes &lt;em&gt;after&lt;/em&gt; the &lt;code&gt;HeroesModule&lt;/code&gt;.</source>
          <target state="translated">공지 사항 모듈에 있음을 &lt;code&gt;imports&lt;/code&gt; 배열의 &lt;code&gt;AppRoutingModule&lt;/code&gt; 은 마지막이며, 제공 &lt;em&gt;후 &lt;/em&gt; &lt;code&gt;HeroesModule&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97f017994bfe8b1e812dafb1f5d643ba23e61b6f" translate="yes" xml:space="preserve">
          <source>Notice that it doesn't have any members. It never grows no matter how many members you add to the class, as long as those members are typed but not implemented.</source>
          <target state="translated">멤버가 없습니다. 멤버가 입력되었지만 구현되지 않은 한 얼마나 많은 멤버를 클래스에 추가하더라도 성장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ec892a756caf966d2763c064eb008689f0edb3d" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; tag is tucked between the &lt;code&gt;&amp;lt;after-content&amp;gt;&lt;/code&gt; tags. Never put content between a component's element tags &lt;em&gt;unless you intend to project that content into the component&lt;/em&gt;.</source>
          <target state="translated">것을 알 수 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; 태그 사이에 자리 잡고 &lt;code&gt;&amp;lt;after-content&amp;gt;&lt;/code&gt; 태그입니다. &lt;em&gt;해당 내용을 구성 요소에 투영하려는 경우가 아니면&lt;/em&gt; 구성 요소의 요소 태그 사이에 내용을 넣지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="64fd2d77e6abc918867382efcabdd9b7a7b79574" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;&lt;a href=&quot;../api/common/commonmodule&quot;&gt;CommonModule&lt;/a&gt;&lt;/code&gt; references and &lt;code&gt;declarations&lt;/code&gt; array are unnecessary, so are no longer part of &lt;code&gt;AppRoutingModule&lt;/code&gt;. The following sections explain the rest of the &lt;code&gt;AppRoutingModule&lt;/code&gt; in more detail.</source>
          <target state="translated">것을 알 수 &lt;code&gt;&lt;a href=&quot;../api/common/commonmodule&quot;&gt;CommonModule&lt;/a&gt;&lt;/code&gt; 의 참조와 &lt;code&gt;declarations&lt;/code&gt; 배열이 필요하지 않습니다 그래서의 더 이상 일부가 없습니다 &lt;code&gt;AppRoutingModule&lt;/code&gt; . 다음 섹션에서는 나머지 &lt;code&gt;AppRoutingModule&lt;/code&gt; 에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9a5f30892f2e4c0cac80275e27a0c184cd91d9f1" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;&lt;a href=&quot;../api/router/route#canDeactivate&quot;&gt;canDeactivate&lt;/a&gt;()&lt;/code&gt; method &lt;em&gt;can&lt;/em&gt; return synchronously; it returns &lt;code&gt;true&lt;/code&gt; immediately if there is no crisis or there are no pending changes. But it can also return a &lt;code&gt;Promise&lt;/code&gt; or an &lt;code&gt;Observable&lt;/code&gt; and the router will wait for that to resolve to truthy (navigate) or falsy (stay put).</source>
          <target state="translated">것을 알 수 &lt;code&gt;&lt;a href=&quot;../api/router/route#canDeactivate&quot;&gt;canDeactivate&lt;/a&gt;()&lt;/code&gt; 메소드는 &lt;em&gt;수&lt;/em&gt; 동 기적으로 반환; 위기가 없거나 보류중인 변경 사항이 없으면 즉시 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그러나 &lt;code&gt;Promise&lt;/code&gt; 또는 &lt;code&gt;Observable&lt;/code&gt; 을 반환 할 수도 있으며 라우터는 해당 정보가 진실 (탐색) 또는 거짓 (게재) 상태로 해결 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="23c9ab227663b5cf313e312746e88c04a1e2e07c" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;Logger&lt;/code&gt; service also has the &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; decorator, even though it might not need its own dependencies. In fact, the &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; decorator is &lt;strong&gt;required for all services&lt;/strong&gt;.</source>
          <target state="translated">주목하라 것을 &lt;code&gt;Logger&lt;/code&gt; 서비스도 있습니다 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; 장식을, 그것의 자신의 종속성을 필요로하지 않을 수 있습니다에도 불구하고. 실제로 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; 데코레이터는 &lt;strong&gt;모든 서비스에 필요합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="de256ece17b6a4cc0716680bb469bb36ad1f8368" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;beforeEach()&lt;/code&gt; is asynchronous and calls &lt;code&gt;TestBed.compileComponents&lt;/code&gt; because the &lt;code&gt;HeroDetailComponent&lt;/code&gt; has an external template and css file.</source>
          <target state="translated">주목하라 것을 &lt;code&gt;beforeEach()&lt;/code&gt; 비동기 호출입니다 &lt;code&gt;TestBed.compileComponents&lt;/code&gt; 때문에 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 가 외부 템플릿과 CSS 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccdec5e84214315e388b8d319ab8c3e40ae6aab9" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;canDeactivate()&lt;/code&gt; method can return synchronously; it returns &lt;code&gt;true&lt;/code&gt; immediately if there is no crisis or there are no pending changes. But it can also return a &lt;code&gt;Promise&lt;/code&gt; or an &lt;code&gt;Observable&lt;/code&gt; and the router will wait for that to resolve to truthy (navigate) or falsy (stay on the current route).</source>
          <target state="translated">것을 알 수 &lt;code&gt;canDeactivate()&lt;/code&gt; 메서드는 동 기적으로 반환 할 수 있습니다; 위기가 없거나 보류중인 변경 사항이 없으면 즉시 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그러나 &lt;code&gt;Promise&lt;/code&gt; 또는 &lt;code&gt;Observable&lt;/code&gt; 을 반환 할 수도 있으며 라우터는 이것이 진실 (탐색) 또는 거짓 (현재 경로에 머물러 있음)으로 해결 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="4b465352b50b0116a885c12cfa249a6f9a25a506" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;crisis-list&lt;/code&gt; component displays. Angular is using the route you defined to dynamically load the component. You can load the &lt;code&gt;heroes-list&lt;/code&gt; component the same way:</source>
          <target state="translated">주목하라 그 &lt;code&gt;crisis-list&lt;/code&gt; 구성 요소가 표시됩니다. Angular는 구성 요소를 동적으로로드하기 위해 정의한 경로를 사용합니다. 다음과 같은 방법으로 &lt;code&gt;heroes-list&lt;/code&gt; 구성 요소를 로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f9dc75623dd65d653e63c79ccc1cae85cf05dbd" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;alterEgo&lt;/code&gt; are sibling controls. To evaluate both controls in a single custom validator, you must perform the validation in a common ancestor control: the &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt;. You query the &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; for its child controls so that you can compare their values.</source>
          <target state="translated">주목하라 것을 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;alterEgo&lt;/code&gt; 은 형제 컨트롤입니다. 단일 사용자 지정 유효성 검사기에서 두 컨트롤을 모두 평가하려면 공통 &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 컨트롤 인 FormGroup 에서 유효성 검사를 수행해야합니다 . 해당 값을 비교할 수 있도록 해당 자식 컨트롤에 대한 &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 을 쿼리 합니다.</target>
        </trans-unit>
        <trans-unit id="0d3f60aa30d029934a47b09b0a3bbb9af25f070e" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;path&lt;/code&gt; is set to an empty string. This is because the path in &lt;code&gt;AppRoutingModule&lt;/code&gt; is already set to &lt;code&gt;customers&lt;/code&gt;, so this route in the &lt;code&gt;CustomersRoutingModule&lt;/code&gt;, is already within the &lt;code&gt;customers&lt;/code&gt; context. Every route in this routing module is a child route.</source>
          <target state="translated">것을 알 &lt;code&gt;path&lt;/code&gt; 빈 문자열로 설정됩니다. &lt;code&gt;AppRoutingModule&lt;/code&gt; 의 경로 가 이미 &lt;code&gt;customers&lt;/code&gt; 로 설정되어 있기 때문에 &lt;code&gt;CustomersRoutingModule&lt;/code&gt; 의이 경로 는 이미 &lt;code&gt;customers&lt;/code&gt; 컨텍스트 내에 있기 때문 입니다. 이 라우팅 모듈의 모든 경로는 하위 경로입니다.</target>
        </trans-unit>
        <trans-unit id="df3c6dc75f2355fd69e3e129ebcd19c803aa442b" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;required&lt;/code&gt; attribute is still present in the template. Although it's not necessary for validation, it should be retained to for accessibility purposes.</source>
          <target state="translated">공지는 것을 &lt;code&gt;required&lt;/code&gt; 속성은 여전히 템플릿에 존재한다. 유효성 검사에는 필요하지 않지만 접근성을 위해 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="3a9f36d86bfc13a1174d686677fc0501b0897fee" translate="yes" xml:space="preserve">
          <source>Notice that the Jasmine test is synchronous. There's no &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt;. Marble testing uses a test scheduler to simulate the passage of time in a synchronous test.</source>
          <target state="translated">Jasmine 테스트는 동기식입니다. &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; 가 없습니다 . 대리석 테스트는 테스트 스케줄러를 사용하여 동기 테스트에서 시간 경과를 시뮬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="c65ac5a0d6ded551e8245111532b70dcf2f4e76d" translate="yes" xml:space="preserve">
          <source>Notice that the URL in the preview window changes. The final segment is &lt;code&gt;products/#&lt;/code&gt; where &lt;code&gt;#&lt;/code&gt; is the number of the route you clicked.</source>
          <target state="translated">미리보기 창의 URL이 변경됩니다. 마지막 세그먼트는 &lt;code&gt;products/#&lt;/code&gt; 입니다. 여기서 &lt;code&gt;#&lt;/code&gt; 은 클릭 한 경로의 번호입니다.</target>
        </trans-unit>
        <trans-unit id="f0cde8607c8b99c991ac239f92c2c9536f2f3650" translate="yes" xml:space="preserve">
          <source>Notice that the URL in the preview window changes. The final segment is &lt;code&gt;products/1&lt;/code&gt;.</source>
          <target state="translated">미리보기 창의 URL이 변경됩니다. 마지막 세그먼트는 &lt;code&gt;products/1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4027ee1272622553868202a87e3af69ab1150cd2" translate="yes" xml:space="preserve">
          <source>Notice that the app stopped working when you added &lt;code&gt;[(&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;)]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[(&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;)]&lt;/code&gt; 을 추가하면 앱이 작동을 멈췄습니다 .</target>
        </trans-unit>
        <trans-unit id="32381adc36dd84f9ba0e64036e01484a6eccfa6e" translate="yes" xml:space="preserve">
          <source>Notice that the binding is to the &lt;code&gt;disabled&lt;/code&gt; property of the button's DOM element, &lt;strong&gt;not&lt;/strong&gt; the attribute. This applies to data-binding in general. Data-binding works with &lt;em&gt;properties&lt;/em&gt; of DOM elements, components, and directives, not HTML &lt;em&gt;attributes&lt;/em&gt;.</source>
          <target state="translated">바인딩은 속성이 &lt;strong&gt;아닌&lt;/strong&gt; 버튼 DOM 요소의 &lt;code&gt;disabled&lt;/code&gt; 속성에 대한 것입니다. 이것은 일반적으로 데이터 바인딩에 적용됩니다. 데이터 바인딩은 HTML &lt;em&gt;속성이&lt;/em&gt; 아닌 DOM 요소, 구성 요소 및 지시문의 &lt;em&gt;속성&lt;/em&gt; 과 함께 작동 &lt;em&gt;합니다&lt;/em&gt; .&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="869ca339c5fbddfd63af20beae58a78e6a0b940b" translate="yes" xml:space="preserve">
          <source>Notice that the configured builder for the project is different from the default builder for app projects. This builder, among other things, ensures that the library is always built with the &lt;a href=&quot;aot-compiler&quot;&gt;AOT compiler&lt;/a&gt;, without the need to specify the &lt;code&gt;--prod&lt;/code&gt; flag.</source>
          <target state="translated">프로젝트에 대해 구성된 빌더는 앱 프로젝트의 기본 빌더와 다릅니다. 이 빌더는 무엇보다도 &lt;code&gt;--prod&lt;/code&gt; 플래그 를 지정할 필요없이 라이브러리가 항상 &lt;a href=&quot;aot-compiler&quot;&gt;AOT 컴파일러로&lt;/a&gt; 빌드되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="afe74458a6eda7ec5253735cae32222403b5c053" translate="yes" xml:space="preserve">
          <source>Notice that the configured builder for the project is different from the default builder for app projects. This builder, among other things, ensures that the library is always built with the &lt;a href=&quot;aot-compiler&quot;&gt;AoT compiler&lt;/a&gt;, without the need to specify the &lt;code&gt;--prod&lt;/code&gt; flag.</source>
          <target state="translated">프로젝트에 대해 구성된 빌더가 앱 프로젝트의 기본 빌더와 다릅니다. 이 빌더는 무엇보다도 &lt;code&gt;--prod&lt;/code&gt; 플래그 를 지정할 필요없이 라이브러리가 항상 &lt;a href=&quot;aot-compiler&quot;&gt;AoT 컴파일러로&lt;/a&gt; 빌드되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="133000de2e1b1e97b650bfe5084c18cc935e5068" translate="yes" xml:space="preserve">
          <source>Notice that the custom validation directive is instantiated with &lt;code&gt;useExisting&lt;/code&gt; rather than &lt;code&gt;useClass&lt;/code&gt;. The registered validator must be &lt;em&gt;this instance&lt;/em&gt; of the &lt;code&gt;ForbiddenValidatorDirective&lt;/code&gt;&amp;mdash;the instance in the form with its &lt;code&gt;forbiddenName&lt;/code&gt; property bound to &amp;ldquo;bob&quot;.</source>
          <target state="translated">사용자 지정 유효성 검사 지시문은 &lt;code&gt;useExisting&lt;/code&gt; 가 아닌 &lt;code&gt;useClass&lt;/code&gt; 인스턴스화됩니다 . 등록 된 검증은해야 &lt;em&gt;이 인스턴스&lt;/em&gt; 의 &lt;code&gt;ForbiddenValidatorDirective&lt;/code&gt; 그와 형태 년 - 예를 &lt;code&gt;forbiddenName&lt;/code&gt; 의 &quot;밥&quot;에 바인딩 속성입니다.</target>
        </trans-unit>
        <trans-unit id="bf29db2d2b68a942b7a233c23775f60dc8fd0262" translate="yes" xml:space="preserve">
          <source>Notice that the lazy-loading syntax uses &lt;code&gt;&lt;a href=&quot;../api/router/route#loadChildren&quot;&gt;loadChildren&lt;/a&gt;&lt;/code&gt; followed by a function that uses the browser's built-in &lt;code&gt;import('...')&lt;/code&gt; syntax for dynamic imports. The import path is the relative path to the module.</source>
          <target state="translated">지연 로딩 구문은 동적 로드 를 위해 브라우저의 내장 &lt;code&gt;import('...')&lt;/code&gt; 구문을 사용하는 함수가 따르는 &lt;code&gt;&lt;a href=&quot;../api/router/route#loadChildren&quot;&gt;loadChildren&lt;/a&gt;&lt;/code&gt; 을 사용합니다 . 가져 오기 경로는 모듈의 상대 경로입니다.</target>
        </trans-unit>
        <trans-unit id="317be6811a63011511296608f693bfb98e04807f" translate="yes" xml:space="preserve">
          <source>Notice that the lazy-loading syntax uses &lt;code&gt;loadChildren&lt;/code&gt; followed by a function that uses the browser's built-in &lt;code&gt;import('...')&lt;/code&gt; syntax for dynamic imports. The import path is the relative path to the module.</source>
          <target state="translated">지연 로딩 구문은 동적 가져 오기를 위해 브라우저의 내장 &lt;code&gt;import('...')&lt;/code&gt; 구문을 사용하는 함수가 뒤 따르는 &lt;code&gt;loadChildren&lt;/code&gt; 을 사용합니다 . 가져 오기 경로는 모듈에 대한 상대 경로입니다.</target>
        </trans-unit>
        <trans-unit id="66f1f3c5e0dfda26328ffd5294fe6ae1daf8d51d" translate="yes" xml:space="preserve">
          <source>Notice that the log confirms that input properties (the &lt;code&gt;name&lt;/code&gt; property in this case) have no assigned values at construction. The input properties are available to the &lt;code&gt;onInit()&lt;/code&gt; method for further initialization.</source>
          <target state="translated">로그는 입력 속성 ( 이 경우 &lt;code&gt;name&lt;/code&gt; 속성)에 생성시 할당 된 값이 없음을 확인합니다. 입력 속성은 추가 초기화를 위해 &lt;code&gt;onInit()&lt;/code&gt; 메서드에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b1b8ffb679119622c1d7f7f438fb3bcdac1936e7" translate="yes" xml:space="preserve">
          <source>Notice that the name and alterEgo are sibling controls. To evaluate both controls in a single custom validator, we should perform the validation in a common ancestor control: the &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt;. That way, we can query the &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; for the child controls which will allow us to compare their values.</source>
          <target state="translated">이름과 alterEgo는 형제 제어입니다. 단일 사용자 정의 유효성 검사기에서 두 컨트롤을 모두 평가하려면 공통 조상 컨트롤 인 &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 에서 유효성 검사를 수행해야합니다 . &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 하면 하위 그룹에 대한 FormGroup 을 쿼리하여 값을 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de3049b45f385b162d074321887e74505bfcc3bc" translate="yes" xml:space="preserve">
          <source>Notice that the new service imports the Angular &lt;code&gt;&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;&lt;/code&gt; symbol and annotates the class with the &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; decorator. This marks the class as one that participates in the &lt;em&gt;dependency injection system&lt;/em&gt;. The &lt;code&gt;HeroService&lt;/code&gt; class is going to provide an injectable service, and it can also have its own injected dependencies. It doesn't have any dependencies yet, but &lt;a href=&quot;toh-pt4#inject-message-service&quot;&gt;it will soon&lt;/a&gt;.</source>
          <target state="translated">새로운 서비스는 Angular &lt;code&gt;&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;&lt;/code&gt; 심볼을 가져오고 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; 데코레이터로 클래스에 주석을 달았습니다 . 이것은 클래스를 &lt;em&gt;의존성 주입 시스템에&lt;/em&gt; 참여하는 클래스로 표시합니다 . &lt;code&gt;HeroService&lt;/code&gt; 의 클래스는 주 서비스를 제공 할 것입니다, 또한 자신의 주입 종속성을 가질 수 있습니다. 아직 의존성이 없지만 &lt;a href=&quot;toh-pt4#inject-message-service&quot;&gt;곧 나올 것&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d8c9e9c01ffc24a0bbd5e28c410125ecb2379d79" translate="yes" xml:space="preserve">
          <source>Notice that the parent &lt;code&gt;crisis-center&lt;/code&gt; route has a &lt;code&gt;children&lt;/code&gt; property with a single route containing the &lt;code&gt;CrisisListComponent&lt;/code&gt;. The &lt;code&gt;CrisisListComponent&lt;/code&gt; route also has a &lt;code&gt;children&lt;/code&gt; array with two routes.</source>
          <target state="translated">상위 &lt;code&gt;crisis-center&lt;/code&gt; 경로에는 &lt;code&gt;CrisisListComponent&lt;/code&gt; 가 포함 된 단일 경로 가있는 &lt;code&gt;children&lt;/code&gt; 속성이 있습니다. &lt;code&gt;CrisisListComponent&lt;/code&gt; 의 경로도 가지고 &lt;code&gt;children&lt;/code&gt; 두 경로와 배열을.</target>
        </trans-unit>
        <trans-unit id="59f693c9d311f5b6a161e98f66d3f66c45891328" translate="yes" xml:space="preserve">
          <source>Notice that the path goes up a level using the &lt;code&gt;../&lt;/code&gt; syntax. If the current crisis &lt;code&gt;id&lt;/code&gt; is &lt;code&gt;3&lt;/code&gt;, the resulting path back to the crisis list is &lt;code&gt;/crisis-center/;id=3;foo=foo&lt;/code&gt;.</source>
          <target state="translated">경로는 &lt;code&gt;../&lt;/code&gt; 구문을 사용하여 레벨이 올라갑니다 . 현재 위기 &lt;code&gt;id&lt;/code&gt; 가 &lt;code&gt;3&lt;/code&gt; 이면 위기 목록으로 돌아가는 결과 경로는 &lt;code&gt;/crisis-center/;id=3;foo=foo&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="764a2d4b65ee2443447964e923fcc96061c4bb18" translate="yes" xml:space="preserve">
          <source>Notice that the quote element displays the placeholder value (&lt;code&gt;'...'&lt;/code&gt;) after &lt;code&gt;ngOnInit()&lt;/code&gt;. The first quote hasn't arrived yet.</source>
          <target state="translated">quote 요소는 &lt;code&gt;ngOnInit()&lt;/code&gt; 뒤에 자리 표시 자 값 ( &lt;code&gt;'...'&lt;/code&gt; )을 표시합니다 . 첫 번째 견적이 아직 도착하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="f80b92ed08ad17e1bac079fbe7b35bdb73062766" translate="yes" xml:space="preserve">
          <source>Notice that the wildcard route is placed at the end of the array. The order of your routes is important, as Angular applies routes in order and uses the first match it finds.</source>
          <target state="translated">와일드 카드 경로는 배열의 끝에 배치됩니다. Angular는 경로를 순서대로 적용하고 찾은 첫 번째 일치 항목을 사용하므로 경로의 순서가 중요합니다.</target>
        </trans-unit>
        <trans-unit id="4a000921d2c433893d3386ba1934a919231e53ac" translate="yes" xml:space="preserve">
          <source>Notice that this example captures the &lt;code&gt;&lt;a href=&quot;../api/service-worker/swpush#subscription&quot;&gt;subscription&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/service-worker/swpush#unsubscribe&quot;&gt;unsubscribe()&lt;/a&gt;&lt;/code&gt; when the &lt;code&gt;AstronautComponent&lt;/code&gt; is destroyed. This is a memory-leak guard step. There is no actual risk in this app because the lifetime of a &lt;code&gt;AstronautComponent&lt;/code&gt; is the same as the lifetime of the app itself. That &lt;em&gt;would not&lt;/em&gt; always be true in a more complex application.</source>
          <target state="translated">이 예제는 &lt;code&gt;AstronautComponent&lt;/code&gt; 가 소멸 될 때 &lt;code&gt;&lt;a href=&quot;../api/service-worker/swpush#subscription&quot;&gt;subscription&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/service-worker/swpush#unsubscribe&quot;&gt;unsubscribe()&lt;/a&gt;&lt;/code&gt; 를 캡처합니다 . 메모리 누수 가드 단계입니다. &lt;code&gt;AstronautComponent&lt;/code&gt; 의 수명은 앱 자체의 수명과 동일 하므로이 앱에는 실제 위험이 없습니다 . 즉 &lt;em&gt;않을 것이다&lt;/em&gt; 항상 더 복잡한 응용 프로그램에서 사실.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb56d57d2aedeba00db6c101307815322b68ea68" translate="yes" xml:space="preserve">
          <source>Notice that this example captures the &lt;code&gt;subscription&lt;/code&gt; and &lt;code&gt;unsubscribe()&lt;/code&gt; when the &lt;code&gt;AstronautComponent&lt;/code&gt; is destroyed. This is a memory-leak guard step. There is no actual risk in this app because the lifetime of a &lt;code&gt;AstronautComponent&lt;/code&gt; is the same as the lifetime of the app itself. That &lt;em&gt;would not&lt;/em&gt; always be true in a more complex application.</source>
          <target state="translated">이 예제는 &lt;code&gt;AstronautComponent&lt;/code&gt; 가 파괴 될 때 &lt;code&gt;subscription&lt;/code&gt; 및 &lt;code&gt;unsubscribe()&lt;/code&gt; 를 캡처합니다 . 이것은 메모리 누수 보호 단계입니다. &lt;code&gt;AstronautComponent&lt;/code&gt; 의 수명이 앱 자체의 수명과 동일 하기 때문에이 앱에는 실제 위험이 없습니다 . 즉 &lt;em&gt;않을 것이다&lt;/em&gt; 항상 더 복잡한 응용 프로그램에서 사실.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e0d61f1eb2b9b620cece14307b29d5408a54c3f6" translate="yes" xml:space="preserve">
          <source>Notice that this handler returns an RxJS &lt;a href=&quot;http#rxjs&quot;&gt;&lt;code&gt;ErrorObservable&lt;/code&gt;&lt;/a&gt; with a user-friendly error message. Consumers of the service expect service methods to return an &lt;code&gt;Observable&lt;/code&gt; of some kind, even a &quot;bad&quot; one.</source>
          <target state="translated">이 핸들러는 사용자에게 친숙한 오류 메시지와 함께 RxJS &lt;a href=&quot;http#rxjs&quot;&gt; &lt;code&gt;ErrorObservable&lt;/code&gt; &lt;/a&gt; 을 반환 합니다. 서비스 소비자는 서비스 방법 이 어떤 종류 의 &lt;code&gt;Observable&lt;/code&gt; , 심지어 &quot;나쁜&quot; 것을 반환 할 것을 기대합니다 .</target>
        </trans-unit>
        <trans-unit id="966b8136539b91f682821aed1fdb541fa1442fbc" translate="yes" xml:space="preserve">
          <source>Notice that this new route uses an empty string as its path. In addition, it replaces the &lt;code&gt;component&lt;/code&gt; property with two new ones:</source>
          <target state="translated">이 새 경로는 빈 문자열을 경로로 사용합니다. 또한 &lt;code&gt;component&lt;/code&gt; 속성을 두 개의 새로운 속성으로 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="62ab125fbed21c4a8952408ef0b14de7325e3998" translate="yes" xml:space="preserve">
          <source>Notice that under the &quot;Size&quot; column, the requests state is &lt;code&gt;(from ServiceWorker)&lt;/code&gt;. This means that the resources are not being loaded from the network. Instead, they are being loaded from the service worker's cache.</source>
          <target state="translated">&quot;크기&quot;열에서 요청 상태는 &lt;code&gt;(from ServiceWorker)&lt;/code&gt; 입니다. 이는 리소스가 네트워크에서로드되지 않음을 의미합니다. 대신 서비스 워커의 캐시에서로드됩니다.</target>
        </trans-unit>
        <trans-unit id="63648c03d3e6427709280eccf49221c86f710380" translate="yes" xml:space="preserve">
          <source>Notice that you &lt;em&gt;inject&lt;/em&gt; the &lt;code&gt;AuthService&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; in the constructor. You haven't provided the &lt;code&gt;AuthService&lt;/code&gt; yet but it's good to know that you can inject helpful services into routing guards.</source>
          <target state="translated">생성자에 &lt;code&gt;AuthService&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 를 &lt;em&gt;삽입&lt;/em&gt; 합니다 . 아직 &lt;code&gt;AuthService&lt;/code&gt; 를 제공 하지는 않았지만 라우팅 가드에 유용한 서비스를 제공 할 수 있음을 아는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d08df7bfba3ae90e07f5d834f49e5d5c467ac993" translate="yes" xml:space="preserve">
          <source>Notice that you also added a &lt;code&gt;name&lt;/code&gt; attribute to the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; tag and set it to &quot;name&quot;, which makes sense for the hero's name. Any unique value will do, but using a descriptive name is helpful. Defining a &lt;code&gt;name&lt;/code&gt; attribute is a requirement when using &lt;code&gt;[(&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;)]&lt;/code&gt; in combination with a form.</source>
          <target state="translated">또한 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 태그에 &lt;code&gt;name&lt;/code&gt; 속성을 추가하고 &quot;name&quot;으로 설정하면 영웅의 이름에 적합합니다. 모든 고유 한 값이 적용되지만 설명적인 이름을 사용하면 도움이됩니다. &lt;code&gt;[(&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;)]&lt;/code&gt; &lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt; )] 을 양식과 함께 사용하려면 &lt;code&gt;name&lt;/code&gt; 속성을 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="58f22daabed29966ba88b05f45459d68f1b23998" translate="yes" xml:space="preserve">
          <source>Notice that you captured the factory provider in an exported variable, &lt;code&gt;heroServiceProvider&lt;/code&gt;. This extra step makes the factory provider reusable. You can configure a provider of &lt;code&gt;HeroService&lt;/code&gt; with this variable wherever you need it. In this sample, you need it only in &lt;code&gt;HeroesComponent&lt;/code&gt;, where &lt;code&gt;heroServiceProvider&lt;/code&gt; replaces &lt;code&gt;HeroService&lt;/code&gt; in the metadata &lt;code&gt;providers&lt;/code&gt; array.</source>
          <target state="translated">반출 된 변수 &lt;code&gt;heroServiceProvider&lt;/code&gt; 에서 팩토리 제공자를 캡처했습니다 . 이 추가 단계는 공장 공급자를 재사용 할 수있게합니다. 필요할 때 &lt;code&gt;HeroService&lt;/code&gt; 변수를 사용 하여 HeroService 공급자를 구성 할 수 있습니다 . 이 샘플에서는, 당신은 단지 그것을 필요로 &lt;code&gt;HeroesComponent&lt;/code&gt; , &lt;code&gt;heroServiceProvider&lt;/code&gt; 을 대체 &lt;code&gt;HeroService&lt;/code&gt; 메타 데이터에서 &lt;code&gt;providers&lt;/code&gt; 배열입니다.</target>
        </trans-unit>
        <trans-unit id="cc972f991724148e05496475d3f68dbf24cf9d49" translate="yes" xml:space="preserve">
          <source>Notice that you don't call &lt;strong&gt;new&lt;/strong&gt; to create an instance of the &lt;code&gt;AppComponent&lt;/code&gt; class. Angular is creating an instance for you. How?</source>
          <target state="translated">&lt;code&gt;AppComponent&lt;/code&gt; 클래스 의 인스턴스를 만들기 위해 &lt;strong&gt;new&lt;/strong&gt; 를 호출하지 않습니다 . Angular가 인스턴스를 생성하고 있습니다. 어떻게?</target>
        </trans-unit>
        <trans-unit id="2d00fb120900f9f6e0e346577e056ae4288f6990" translate="yes" xml:space="preserve">
          <source>Notice that you inject the &lt;code&gt;AuthService&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; in the constructor. You haven't provided the &lt;code&gt;AuthService&lt;/code&gt; yet but it's good to know that you can inject helpful services into routing guards.</source>
          <target state="translated">생성자에 &lt;code&gt;AuthService&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 를 삽입합니다 . 아직 &lt;code&gt;AuthService&lt;/code&gt; 를 제공 하지 않았지만 라우팅 가드에 유용한 서비스를 주입 할 수 있다는 것을 아는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="657010025921c4cba9d77c07d871864c621aceef" translate="yes" xml:space="preserve">
          <source>Notice that you keep injecting the &lt;code&gt;MessageService&lt;/code&gt; but since you'll call it so frequently, wrap it in a private &lt;code&gt;&lt;a href=&quot;../api/animations/browser/testing/mockanimationdriver#log&quot;&gt;log&lt;/a&gt;()&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;MessageService&lt;/code&gt; 를 계속 주입 하지만 자주 호출하므로 개인 &lt;code&gt;&lt;a href=&quot;../api/animations/browser/testing/mockanimationdriver#log&quot;&gt;log&lt;/a&gt;()&lt;/code&gt; 메소드로 랩핑하십시오 .</target>
        </trans-unit>
        <trans-unit id="a08c2a129b2af456b44a4642bf80699a85c7b8ec" translate="yes" xml:space="preserve">
          <source>Notice that you keep injecting the &lt;code&gt;MessageService&lt;/code&gt; but since you'll call it so frequently, wrap it in a private &lt;code&gt;log()&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;MessageService&lt;/code&gt; 를 계속 주입 하지만 너무 자주 호출하므로 개인 &lt;code&gt;log()&lt;/code&gt; 메서드로 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="4e3000d46be8e51b7f3b4b07993ea04eeafacab1" translate="yes" xml:space="preserve">
          <source>Notice that you're importing the &lt;code&gt;map&lt;/code&gt; operator of the RxJS &lt;code&gt;Observable&lt;/code&gt; separately. Do this for every RxJS operator.</source>
          <target state="translated">RxJS &lt;code&gt;Observable&lt;/code&gt; 의 &lt;code&gt;map&lt;/code&gt; 연산자를 별도로 가져옵니다 . 모든 RxJS 운영자에게이를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0fe973a854de016beb47da7cff87ced09a70d998" translate="yes" xml:space="preserve">
          <source>Notice that:</source>
          <target state="translated">그것을주의해라:</target>
        </trans-unit>
        <trans-unit id="224c6bd0b406b3c1b902663fe54c62ec5beba85d" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;:id&lt;/code&gt; token in the path. That creates a slot in the path for a &lt;strong&gt;Route Parameter&lt;/strong&gt;. In this case, the router will insert the &lt;code&gt;id&lt;/code&gt; of a hero into that slot.</source>
          <target state="translated">통지 &lt;code&gt;:id&lt;/code&gt; 경로에 토큰을. 그러면 &lt;strong&gt;경로 매개 변수&lt;/strong&gt; 의 경로에 슬롯이 생성 됩니다. 이 경우 라우터는 영웅 의 &lt;code&gt;id&lt;/code&gt; 를 해당 슬롯에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="f8ad08dbe7eecf2fed7e6c40ee0d2fa66fb61639" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; decorator. It adds metadata to the class that makes the directive's &lt;code&gt;highlightColor&lt;/code&gt; property available for binding.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; 데코레이터에 주목하십시오 . 지시문의 &lt;code&gt;highlightColor&lt;/code&gt; 속성을 바인딩에 사용할 수 있게하는 메타 데이터를 클래스에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="6634b0a0f0be00fbe2e39031dc79ddc4d0ee464d" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;@&lt;a href=&quot;api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; decorator. This indicates that the following class is a component. It provides metadata about the component, including its selector, templates, and styles.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; 데코레이터를 주목하십시오 . 이것은 다음 클래스가 구성 요소임을 나타냅니다. 선택기, 템플릿 및 스타일을 포함하여 구성 요소에 대한 메타 데이터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c60b94afc6109f221d514f644a8ae5ea5a5efbee" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;hero&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; double-quoted instruction; it is an example of a template input variable. Read more about template input variables in the &lt;a href=&quot;template-syntax#microsyntax&quot;&gt;microsyntax&lt;/a&gt; section of the &lt;a href=&quot;template-syntax&quot;&gt;Template Syntax&lt;/a&gt; page.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 큰 따옴표로 묶인 지시 에서 &lt;code&gt;hero&lt;/code&gt; 을 주목하십시오 . 템플릿 입력 변수의 예입니다. &lt;a href=&quot;template-syntax&quot;&gt;템플릿 구문&lt;/a&gt; 페이지 의 &lt;a href=&quot;template-syntax#microsyntax&quot;&gt;microsyntax&lt;/a&gt; 섹션 에서 템플릿 입력 변수에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="4562d3406b71c08ed4a9cb8f2b93ad983529d493" translate="yes" xml:space="preserve">
          <source>Notice the declaration of &lt;code&gt;heroes$&lt;/code&gt; as an &lt;code&gt;Observable&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;heroes$&lt;/code&gt; 가 &lt;code&gt;Observable&lt;/code&gt; 로 선언 된 것을 주목하십시오 :</target>
        </trans-unit>
        <trans-unit id="311928a764ab8a87b147a4229e9425b4654dfce5" translate="yes" xml:space="preserve">
          <source>Notice the difference between the &lt;code&gt;colspan&lt;/code&gt; attribute and the &lt;code&gt;colSpan&lt;/code&gt; property.</source>
          <target state="translated">사이의 차이에 주목 &lt;code&gt;colspan&lt;/code&gt; 속성과 &lt;code&gt;colSpan&lt;/code&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="44536d70a7765f95baee29c0816dfab638675325" translate="yes" xml:space="preserve">
          <source>Notice the following features illustrated by the example.</source>
          <target state="translated">예제에서 설명하는 다음 기능을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8837254f576af82cbf792e9988deb4cbfb60d7fb" translate="yes" xml:space="preserve">
          <source>Notice the odd behavior in the live example: when you add flying heroes, none of them are displayed under &quot;Heroes who fly.&quot;</source>
          <target state="translated">라이브 예제에서 이상한 행동을 확인하십시오. 플라잉 히어로를 추가 할 때 &quot;Heroes who fly&quot;아래에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a87dd19c1d892167b8ee74d68f5611cfda16020" translate="yes" xml:space="preserve">
          <source>Notice the other syntax differences: The (*) before &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; is required; the &lt;code&gt;let&lt;/code&gt; keyword identifies &lt;code&gt;movie&lt;/code&gt; as an input variable; the list preposition is &lt;code&gt;of&lt;/code&gt;, not &lt;code&gt;in&lt;/code&gt;.</source>
          <target state="translated">다른 구문 차이는 다음과 같습니다. &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 앞에 (*) 가 필요합니다. &lt;code&gt;let&lt;/code&gt; 키워드 식별의 &lt;code&gt;movie&lt;/code&gt; 입력 변수로; 목록 전치사는 &lt;code&gt;of&lt;/code&gt; 하지 &lt;code&gt;in&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0c91a28238ae10d905cde46e87869f168fa3578" translate="yes" xml:space="preserve">
          <source>Notice this component can present any type of question in your model. You only have two types of questions at this point but you can imagine many more. The &lt;code&gt;&lt;a href=&quot;../api/common/ngswitch&quot;&gt;ngSwitch&lt;/a&gt;&lt;/code&gt; determines which type of question to display.</source>
          <target state="translated">이 구성 요소는 모델에 모든 유형의 질문을 표시 할 수 있습니다. 지금은 두 가지 유형의 질문 만 있지만 더 많은 것을 상상할 수 있습니다. &lt;code&gt;&lt;a href=&quot;../api/common/ngswitch&quot;&gt;ngSwitch&lt;/a&gt;&lt;/code&gt; 는 디스플레이 문제의 유형을 결정한다.</target>
        </trans-unit>
        <trans-unit id="624c07d69e6efc6171d87ab0b0b72bf280ec0db6" translate="yes" xml:space="preserve">
          <source>Notice two different types of redirects. The first change is from &lt;code&gt;/heroes&lt;/code&gt; to &lt;code&gt;/superheroes&lt;/code&gt; without any parameters. The second change is from &lt;code&gt;/hero/:id&lt;/code&gt; to &lt;code&gt;/superhero/:id&lt;/code&gt;, which includes the &lt;code&gt;:id&lt;/code&gt; route parameter. Router redirects also use powerful pattern-matching, so the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; inspects the URL and replaces route parameters in the &lt;code&gt;path&lt;/code&gt; with their appropriate destination. Previously, you navigated to a URL such as &lt;code&gt;/hero/15&lt;/code&gt; with a route parameter &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;15&lt;/code&gt;.</source>
          <target state="translated">두 가지 유형의 리디렉션에 주목하십시오. 첫 번째 변경 사항은 매개 변수없이 &lt;code&gt;/heroes&lt;/code&gt; 에서 &lt;code&gt;/superheroes&lt;/code&gt; 로 변경 됩니다. 두 번째 변경 사항은 &lt;code&gt;/hero/:id&lt;/code&gt; 에서 &lt;code&gt;/superhero/:id&lt;/code&gt; 이며, 여기에는 &lt;code&gt;:id&lt;/code&gt; 경로 매개 변수가 포함됩니다. 라우터 리디렉션은 또한 강력한 패턴 일치를 사용하므로 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 는 URL을 검사하고 &lt;code&gt;path&lt;/code&gt; 의 경로 매개 변수를 적절한 대상으로 바꿉니다 . 이전 에는 경로 매개 변수 &lt;code&gt;id&lt;/code&gt; 가 &lt;code&gt;15&lt;/code&gt; 인 &lt;code&gt;/hero/15&lt;/code&gt; 와 같은 URL로 이동했습니다 .</target>
        </trans-unit>
        <trans-unit id="296e3dde9ed08cdaed0a40934e1b325ca788c45d" translate="yes" xml:space="preserve">
          <source>Notice, we don't use the &lt;code&gt;new&lt;/code&gt; operator because we explicitly want to have the &lt;code&gt;&lt;a href=&quot;injector&quot;&gt;Injector&lt;/a&gt;&lt;/code&gt; resolve all of the object's dependencies automatically.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;injector&quot;&gt;Injector&lt;/a&gt;&lt;/code&gt; 모든 객체의 종속성을 자동으로 해결 하도록 명시 적으로 지정하기 때문에 &lt;code&gt;new&lt;/code&gt; 연산자를 사용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="628a306f408fb8f97d2799fd6d3657d63ec32e11" translate="yes" xml:space="preserve">
          <source>Notification type</source>
          <target state="translated">알림 유형</target>
        </trans-unit>
        <trans-unit id="8600e4a94a4556b41e58d1919c7c370cb706b618" translate="yes" xml:space="preserve">
          <source>Notifies that an error has been delivered.</source>
          <target state="translated">오류가 전달되었음을 알립니다.</target>
        </trans-unit>
        <trans-unit id="42b070aa5cb4c0fbe5ccad26df6cf2f1864252f1" translate="yes" xml:space="preserve">
          <source>Notifies when code enters Angular Zone. This gets fired first on VM Turn.</source>
          <target state="translated">코드가 Angular Zone에 들어갈 때 알립니다. 이것은 VM Turn에서 처음 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="be6b88a10b80bebba1fd14aa8e278d92410f068d" translate="yes" xml:space="preserve">
          <source>Notifies when the last &lt;code&gt;onMicrotaskEmpty&lt;/code&gt; has run and there are no more microtasks, which implies we are about to relinquish VM turn. This event gets called just once.</source>
          <target state="translated">마지막 &lt;code&gt;onMicrotaskEmpty&lt;/code&gt; 가 실행되고 더 이상 마이크로 태스크가없는 경우를 알려주므로 VM 전환을 포기하려고합니다. 이 이벤트는 한 번만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e334aa61249c5a9f4d3c93e17830a67cfd2596a6" translate="yes" xml:space="preserve">
          <source>Notifies when there is no more microtasks enqueued in the current VM Turn. This is a hint for Angular to do change detection, which may enqueue more microtasks. For this reason this event can fire multiple times per VM Turn.</source>
          <target state="translated">현재 VM Turn에 대기중인 마이크로 태스크가 더 이상 없을 때 알립니다. 이것은 Angular가 변경 감지를 수행하여 더 많은 마이크로 작업을 대기시킬 수있는 힌트입니다. 이러한 이유로이 이벤트는 VM Turn 당 여러 번 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91196a4bb4525bb970608d38f446c43b9434f902" translate="yes" xml:space="preserve">
          <source>Nougat (7.0), Marshmallow (6.0), Lollipop (5.0, 5.1), KitKat (4.4)</source>
          <target state="translated">누가 (7.0), 마시멜로 (6.0), 롤리팝 (5.0, 5.1), 키트 캣 (4.4)</target>
        </trans-unit>
        <trans-unit id="d9499aa3edb773a42335b31a89b82134a0aa14d8" translate="yes" xml:space="preserve">
          <source>Nov 28, 2019</source>
          <target state="translated">2019 년 11 월 28 일</target>
        </trans-unit>
        <trans-unit id="1965edd2281e8c818ff89aadca53b4c61e55465e" translate="yes" xml:space="preserve">
          <source>Nov 28, 2020</source>
          <target state="translated">2020 년 11 월 28 일</target>
        </trans-unit>
        <trans-unit id="39f0affb54c0e760316554da0b339f4060ec9e40" translate="yes" xml:space="preserve">
          <source>Nov 3, 2018</source>
          <target state="translated">2018 년 11 월 3 일</target>
        </trans-unit>
        <trans-unit id="59cb4cac574d164db8af25ffc6bef61b907f0ac8" translate="yes" xml:space="preserve">
          <source>Nov 3, 2019</source>
          <target state="translated">2019 년 11 월 3 일</target>
        </trans-unit>
        <trans-unit id="e3b82040565bb4be6b11f778a2e3df327ed20a3b" translate="yes" xml:space="preserve">
          <source>Now</source>
          <target state="translated">Now</target>
        </trans-unit>
        <trans-unit id="dbbf3b93a5f06490dbad6953e20f867b07ab34cf" translate="yes" xml:space="preserve">
          <source>Now &lt;a href=&quot;docs-style-guide#ugly-anchors&quot;&gt;link to that custom anchor name&lt;/a&gt; as you did before.</source>
          <target state="translated">이제 이전과 마찬가지로 &lt;a href=&quot;docs-style-guide#ugly-anchors&quot;&gt;해당 사용자 지정 앵커 이름에 연결하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be2637c067a128a864587d81b2ad8e93ec4c37de" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#get&quot;&gt;HttpClient.get()&lt;/a&gt;&lt;/code&gt; returns an &lt;code&gt;Observable&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../api/common/http/httpresponse&quot;&gt;HttpResponse&lt;/a&gt;&lt;/code&gt; rather than just the JSON data contained in the body.</source>
          <target state="translated">이제 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#get&quot;&gt;HttpClient.get()&lt;/a&gt;&lt;/code&gt; 은 본문에 포함 된 JSON 데이터가 아닌 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpresponse&quot;&gt;HttpResponse&lt;/a&gt;&lt;/code&gt; 유형 의 &lt;code&gt;Observable&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0a9b3f9877bccae6c0bc6b63cbf2455a67b5c7aa" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#get&quot;&gt;HttpClient.get()&lt;/a&gt;&lt;/code&gt; returns an &lt;code&gt;Observable&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../api/common/http/httpresponse&quot;&gt;HttpResponse&lt;/a&gt;&lt;/code&gt; rather than just the JSON data.</source>
          <target state="translated">이제 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#get&quot;&gt;HttpClient.get()&lt;/a&gt;&lt;/code&gt; 은 JSON 데이터가 아닌 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpresponse&quot;&gt;HttpResponse&lt;/a&gt;&lt;/code&gt; 유형 의 &lt;code&gt;Observable&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1fb73cde75c19db6fdcefbb2cf6dead78babb5bc" translate="yes" xml:space="preserve">
          <source>Now add a new behavior:</source>
          <target state="translated">이제 새 동작을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="081aba198c945280ea9a8d78da36d3b8ee68a0d2" translate="yes" xml:space="preserve">
          <source>Now add a test that gets the component's element from &lt;code&gt;fixture.nativeElement&lt;/code&gt; and looks for the expected text.</source>
          <target state="translated">이제 &lt;code&gt;fixture.nativeElement&lt;/code&gt; 에서 컴포넌트의 요소를 가져오고 예상되는 텍스트를 찾는 테스트를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5e41bfa864085cc0d6942881475d0e793dc00ca" translate="yes" xml:space="preserve">
          <source>Now apply that reasoning to the following example:</source>
          <target state="translated">이제이 추론을 다음 예제에 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="78b9f4fb848bc82eecf129603e91b1eca3652e57" translate="yes" xml:space="preserve">
          <source>Now click the &lt;em&gt;Crisis Center&lt;/em&gt; link for a list of ongoing crises.</source>
          <target state="translated">이제 &lt;em&gt;위기 센터&lt;/em&gt; 링크를 클릭하여 진행중인 위기 목록을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2d9df8448a20deb27391d24d300f8607281087e8" translate="yes" xml:space="preserve">
          <source>Now clicking &quot;New Hero&quot; resets both the form and its control flags.</source>
          <target state="translated">이제 &quot;New Hero&quot;를 클릭하면 폼과 컨트롤 플래그가 모두 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="60b35e44ad6b6fdacc16d5fbb3ee2ef4d47f77bd" translate="yes" xml:space="preserve">
          <source>Now clicking &lt;strong&gt;New Hero&lt;/strong&gt; resets both the form and its control flags.</source>
          <target state="translated">이제 &lt;strong&gt;New Hero를&lt;/strong&gt; 클릭하면 양식과 제어 플래그가 모두 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="3bcd3030a2143c83e66b7b122008421eddf2dd05" translate="yes" xml:space="preserve">
          <source>Now conditionally exclude a &lt;em&gt;select&lt;/em&gt;&lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; with &lt;code&gt;&amp;lt;ng-container&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;&amp;lt;ng-container&amp;gt;&lt;/code&gt; 로 &lt;em&gt;select &lt;/em&gt; &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 을 조건부로 제외 &lt;em&gt;하십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d3252058bb77eeb5aa82eb998ca811799962d99d" translate="yes" xml:space="preserve">
          <source>Now consider a lazy loaded module that also provides a service called &lt;code&gt;UserService&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;UserService&lt;/code&gt; 라는 서비스를 제공하는 지연로드 모듈을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="92831a218c46c49fe732c9afcdca563a9895a096" translate="yes" xml:space="preserve">
          <source>Now convert the template of this component into Angular syntax. The search controls replace the AngularJS &lt;code&gt;$ctrl&lt;/code&gt; expressions with Angular's two-way &lt;code&gt;[(&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;)]&lt;/code&gt; binding syntax:</source>
          <target state="translated">이제이 컴포넌트의 템플리트를 Angular 구문으로 변환하십시오. 검색 컨트롤은 AngularJS &lt;code&gt;$ctrl&lt;/code&gt; 표현식을 Angular의 양방향 &lt;code&gt;[(&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;)]&lt;/code&gt; 바인딩 구문으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="a6db90e40d4dc7881bb7b39d5fc9aa711d321b27" translate="yes" xml:space="preserve">
          <source>Now create a new &lt;code&gt;app.module.ts&lt;/code&gt; with the minimum &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; class:</source>
          <target state="translated">이제 최소 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 클래스를 사용하여 새 &lt;code&gt;app.module.ts&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="95a24eeedcc9308fdb1cbf8aa172fa9e0eb25d1b" translate="yes" xml:space="preserve">
          <source>Now create the root &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; class called &lt;code&gt;AppModule&lt;/code&gt;. There is already a file named &lt;code&gt;app.module.ts&lt;/code&gt; that holds the AngularJS module. Rename it to &lt;code&gt;app.module.ajs.ts&lt;/code&gt; and update the corresponding script name in the &lt;code&gt;index.html&lt;/code&gt; as well. The file contents remain:</source>
          <target state="translated">이제 &lt;code&gt;AppModule&lt;/code&gt; 이라는 루트 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 클래스를 만듭니다 . AngularJS 모듈을 보유한 &lt;code&gt;app.module.ts&lt;/code&gt; 라는 파일이 이미 있습니다 . &lt;code&gt;app.module.ajs.ts&lt;/code&gt; 로 이름을 바꾸고 &lt;code&gt;index.html&lt;/code&gt; 에서도 해당 스크립트 이름을 업데이트하십시오 . 파일 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="05dfc259a7fb160418b361d767e881fb864d19be" translate="yes" xml:space="preserve">
          <source>Now demonstrate it in a harness component whose template defines two bindings to this pipe, both requesting the heroes from the &lt;code&gt;heroes.json&lt;/code&gt; file.</source>
          <target state="translated">이제 템플릿이이 파이프에 대한 두 개의 바인딩을 정의하는 하네스 구성 요소에서 보여줍니다. 둘 다 &lt;code&gt;heroes.json&lt;/code&gt; 파일 에서 영웅을 요청 합니다.</target>
        </trans-unit>
        <trans-unit id="461b4bc6c19d75290ddf943ec76dd7b2a1ad9862" translate="yes" xml:space="preserve">
          <source>Now deprecated:</source>
          <target state="translated">더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="964026c5dae68aec5890167594d69dd0acb0b225" translate="yes" xml:space="preserve">
          <source>Now edit the &lt;code&gt;AdminDashboardComponent&lt;/code&gt; to display the log of preloaded routes.</source>
          <target state="translated">이제 &lt;code&gt;AdminDashboardComponent&lt;/code&gt; 를 편집하여 미리로드 된 경로의 로그를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="d9ae4a25f96d363e4216ca6bb99b2ba1b57adbf6" translate="yes" xml:space="preserve">
          <source>Now edit the generated &lt;code&gt;src/app/highlight.directive.ts&lt;/code&gt; to look as follows:</source>
          <target state="translated">이제 생성 된 &lt;code&gt;src/app/highlight.directive.ts&lt;/code&gt; 를 다음과 같이 편집하십시오 .</target>
        </trans-unit>
        <trans-unit id="823a17a1466ae3779c585b18502cd6a9d65b08f2" translate="yes" xml:space="preserve">
          <source>Now extend the observable result with the &lt;code&gt;pipe()&lt;/code&gt; method and give it a &lt;code&gt;catchError()&lt;/code&gt; operator.</source>
          <target state="translated">이제 &lt;code&gt;pipe()&lt;/code&gt; 메소드로 관찰 가능한 결과를 확장하고 &lt;code&gt;catchError()&lt;/code&gt; 연산자를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="4a0fb32572aab0cfb89d0154c3f108563b519f2d" translate="yes" xml:space="preserve">
          <source>Now if you delete the Name, you violate the &quot;required&quot; rule, which is duly noted in the error message. The &lt;em&gt;Submit&lt;/em&gt; button is also disabled.</source>
          <target state="translated">이제 이름을 삭제하면 &quot;필수&quot;규칙을 위반하게됩니다.이 규칙은 오류 메시지에 제대로 표시됩니다. &lt;em&gt;제출&lt;/em&gt; 버튼은 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e286649605b4cdcc3d7475cda8c6eddeef913f5" translate="yes" xml:space="preserve">
          <source>Now imagine a hosting parent component that binds to the &lt;code&gt;deleteRequest&lt;/code&gt; event of the &lt;code&gt;ItemDetailComponent&lt;/code&gt;.</source>
          <target state="translated">이제 호스팅 상위 구성 요소를 상상 그 결합 &lt;code&gt;deleteRequest&lt;/code&gt; 의 이벤트 &lt;code&gt;ItemDetailComponent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="357f377145f4963391f7ad2b484687b5ec422a31" translate="yes" xml:space="preserve">
          <source>Now import and declare the newly created pipe and remove the filter &amp;lt;script&amp;gt; tag from &lt;code&gt;index.html&lt;/code&gt;:</source>
          <target state="translated">이제 새로 만든 파이프를 가져 와서 선언하고 &lt;code&gt;index.html&lt;/code&gt; 에서 필터 &amp;lt;script&amp;gt; 태그를 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf7170cc3ead79baf3672126979190cfd6d31f29" translate="yes" xml:space="preserve">
          <source>Now import the &lt;code&gt;AuthGuard&lt;/code&gt; into the &lt;code&gt;AppRoutingModule&lt;/code&gt; and add the &lt;code&gt;AuthGuard&lt;/code&gt; to the &lt;code&gt;&lt;a href=&quot;../api/router/route#canLoad&quot;&gt;canLoad&lt;/a&gt;&lt;/code&gt; array property for the &lt;code&gt;admin&lt;/code&gt; route. The completed admin route looks like this:</source>
          <target state="translated">이제 가져 &lt;code&gt;AuthGuard&lt;/code&gt; 에 &lt;code&gt;AppRoutingModule&lt;/code&gt; 을 하고 추가 &lt;code&gt;AuthGuard&lt;/code&gt; 을 받는 &lt;code&gt;&lt;a href=&quot;../api/router/route#canLoad&quot;&gt;canLoad&lt;/a&gt;&lt;/code&gt; 의 에 대한 배열 속성 &lt;code&gt;admin&lt;/code&gt; 경로. 완성 된 관리 경로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="97c0f3005f1bcc55e33a8201387858d1767de477" translate="yes" xml:space="preserve">
          <source>Now import the &lt;code&gt;AuthGuard&lt;/code&gt; into the &lt;code&gt;AppRoutingModule&lt;/code&gt; and add the &lt;code&gt;AuthGuard&lt;/code&gt; to the &lt;code&gt;canLoad&lt;/code&gt; array property for the &lt;code&gt;admin&lt;/code&gt; route. The completed admin route looks like this:</source>
          <target state="translated">이제 가져 &lt;code&gt;AuthGuard&lt;/code&gt; 에 &lt;code&gt;AppRoutingModule&lt;/code&gt; 을 하고 추가 &lt;code&gt;AuthGuard&lt;/code&gt; 을 받는 &lt;code&gt;canLoad&lt;/code&gt; 의 에 대한 배열 속성 &lt;code&gt;admin&lt;/code&gt; 경로. 완료된 관리 경로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="31b836f3574819289be4274fa8741846071b4a3c" translate="yes" xml:space="preserve">
          <source>Now launch the TypeScript compiler from the command line in watch mode:</source>
          <target state="translated">이제 감시 모드의 명령 행에서 TypeScript 컴파일러를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="cea9bc4df5ef0aed4f96da7f3e5fba85c3a68113" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s add some logic to it. The following code retrieves the command and arguments from the user options, spawns the new process, and waits for the process to finish. If the process is successful (returns a code of 0), it resolves the return value.</source>
          <target state="translated">이제 논리를 추가해 봅시다. 다음 코드는 사용자 옵션에서 명령과 인수를 검색하고 새 프로세스를 생성하고 프로세스가 완료되기를 기다립니다. 프로세스가 성공하면 (코드 0을 리턴 함) 리턴 값을 분석합니다.</target>
        </trans-unit>
        <trans-unit id="b24abf9dc185858f14c376ab8788987c0f0a50c3" translate="yes" xml:space="preserve">
          <source>Now look at how the browser and service worker handle the updated application.</source>
          <target state="translated">이제 브라우저 및 서비스 워커가 업데이트 된 애플리케이션을 처리하는 방법을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="aa3e4b1abb8f6fd359454a4428264d5e3c459143" translate="yes" xml:space="preserve">
          <source>Now look at the component's template.</source>
          <target state="translated">이제 구성 요소의 템플릿을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="fc5182118ed2d7a9f52a68efa9e2275c52a1ec71" translate="yes" xml:space="preserve">
          <source>Now look at the component's template:</source>
          <target state="translated">이제 컴포넌트의 템플릿을보십시오 :</target>
        </trans-unit>
        <trans-unit id="ea46e4622cad843d686ba743b22a133738e8e043" translate="yes" xml:space="preserve">
          <source>Now requests made in the course of your tests hit the testing backend instead of the normal backend.</source>
          <target state="translated">이제 테스트 과정에서 이루어진 요청이 일반 백엔드 대신 테스트 백엔드에 도달했습니다.</target>
        </trans-unit>
        <trans-unit id="75a25734338df521e44ff13a270203cce683ac11" translate="yes" xml:space="preserve">
          <source>Now requests made in the course of your tests will hit the testing backend instead of the normal backend.</source>
          <target state="translated">이제 테스트 과정에서 요청이 일반 백엔드 대신 테스트 백엔드에 도달합니다.</target>
        </trans-unit>
        <trans-unit id="98a01892c59d53b9056b9b561655ffe86dc1b126" translate="yes" xml:space="preserve">
          <source>Now run the app and look at the &lt;em&gt;Name&lt;/em&gt; input box. Follow these steps &lt;em&gt;precisely&lt;/em&gt;:</source>
          <target state="translated">이제 앱을 실행하고 &lt;em&gt;이름&lt;/em&gt; 입력 상자를 확인하십시오. 다음 단계를 &lt;em&gt;정확하게&lt;/em&gt; 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="d7dac50e126237aea132e235b38b0a6e9b8645c1" translate="yes" xml:space="preserve">
          <source>Now run the app. It should display the title and hero name:</source>
          <target state="translated">이제 앱을 실행하십시오. 제목과 영웅 이름이 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7e1ecc0ef3d5a53d92ccefa181700e0018c5594b" translate="yes" xml:space="preserve">
          <source>Now run the application to see the &lt;code&gt;HighlightDirective&lt;/code&gt; in action.</source>
          <target state="translated">이제 응용 프로그램을 실행하여 &lt;code&gt;HighlightDirective&lt;/code&gt; 가 작동 하는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="6054ca5587a773649913d761d56148660e33f0bd" translate="yes" xml:space="preserve">
          <source>Now set the remaining &lt;code&gt;phone-detail.component.ts&lt;/code&gt; as follows:</source>
          <target state="translated">이제 나머지 &lt;code&gt;phone-detail.component.ts&lt;/code&gt; 를 다음과 같이 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c367bf53fb80a0788621b443cbb2320bb48a842" translate="yes" xml:space="preserve">
          <source>Now take note of the &lt;code&gt;afterGetHeroes()&lt;/code&gt; method. Your first instinct might have been to create an &lt;code&gt;ngOnInit&lt;/code&gt; method in &lt;code&gt;SortedHeroesComponent&lt;/code&gt; and do the sorting there. But Angular calls the &lt;em&gt;derived&lt;/em&gt; class's &lt;code&gt;ngOnInit&lt;/code&gt;&lt;em&gt;before&lt;/em&gt; calling the base class's &lt;code&gt;ngOnInit&lt;/code&gt; so you'd be sorting the heroes array &lt;em&gt;before they arrived&lt;/em&gt;. That produces a nasty error.</source>
          <target state="translated">이제 &lt;code&gt;afterGetHeroes()&lt;/code&gt; 메소드에 주목하십시오 . 첫 번째 본능은 &lt;code&gt;SortedHeroesComponent&lt;/code&gt; 에서 &lt;code&gt;ngOnInit&lt;/code&gt; 메소드 를 작성 하고 정렬하는 것입니다. 그러나 각도는 통화 &lt;em&gt;파생&lt;/em&gt; 클래스의 &lt;code&gt;ngOnInit&lt;/code&gt; 을&lt;em&gt;하기 전에&lt;/em&gt; 기본 클래스의 호출 &lt;code&gt;ngOnInit&lt;/code&gt; 를 당신이 영웅 배열을 정렬 할 것, 그래서 &lt;em&gt;그들이 도착하기 전에&lt;/em&gt; . 그 결과 심한 오류가 발생합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e123e84e0d503161d6d3a1d2a1dbf668d9f537d8" translate="yes" xml:space="preserve">
          <source>Now that the &lt;code&gt;AppModule&lt;/code&gt; imports the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt;, the next step is to inject the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; service into your service so your app can fetch data and interact with external APIs and resources.</source>
          <target state="translated">이제 &lt;code&gt;AppModule&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt; 을 가져 오므 로 다음 단계는 앱이 데이터를 가져오고 외부 API 및 리소스와 상호 작용할 수 있도록 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 서비스를 서비스에 삽입하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="4447e662db5544ac0f0492a9b2c3e8a626d75280" translate="yes" xml:space="preserve">
          <source>Now that the &lt;code&gt;FlowerService&lt;/code&gt; is provided in the &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; decorator, when the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; requests the service, the injector has only to look as far as the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt;'s own &lt;code&gt;ElementInjector&lt;/code&gt;. It won't have to continue the search any further through the injector tree.</source>
          <target state="translated">이제 &lt;code&gt;FlowerService&lt;/code&gt; 가 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; 데코레이터에 제공되므로 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; 가 서비스를 요청할 때 인젝터는 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; 의 자체 &lt;code&gt;ElementInjector&lt;/code&gt; 까지만 봐야 합니다. 인젝터 트리를 통해 더 이상 검색을 계속하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="677d9053c3ba894e81177f9315671eed54630726" translate="yes" xml:space="preserve">
          <source>Now that the &lt;code&gt;getQuote()&lt;/code&gt; spy is returning async observables, most of your tests will have to be async as well.</source>
          <target state="translated">이제 &lt;code&gt;getQuote()&lt;/code&gt; 스파이가 비동기 관찰 가능 항목을 반환하므로 대부분의 테스트도 비동기 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e7dba8db77a8b9e3fc01e876c00ece6f37c8bb39" translate="yes" xml:space="preserve">
          <source>Now that the router has a route to &lt;code&gt;HeroDetailComponent&lt;/code&gt;, fix the dashboard hero links to navigate via the &lt;em&gt;parameterized&lt;/em&gt; dashboard route.</source>
          <target state="translated">라우터에 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 로의 경로가 지정 되었으므로 대시 보드 히어로 링크를 수정하여 &lt;em&gt;매개 변수화 된&lt;/em&gt; 대시 보드 경로 를 탐색하십시오 .</target>
        </trans-unit>
        <trans-unit id="e8cec91b2dc9134fb641c13185ee27ced9a52649" translate="yes" xml:space="preserve">
          <source>Now that you are loading &lt;code&gt;phone.service.ts&lt;/code&gt; through an import that is resolved by SystemJS, you should &lt;strong&gt;remove the &amp;lt;script&amp;gt; tag&lt;/strong&gt; for the service from &lt;code&gt;index.html&lt;/code&gt;. This is something you'll do to all components as you upgrade them. Simultaneously with the AngularJS to Angular upgrade you're also migrating code from scripts to modules.</source>
          <target state="translated">&lt;code&gt;phone.service.ts&lt;/code&gt; 가 해결 한 가져 오기를 통해 phone.service.ts 를 로드 했으므로 &lt;code&gt;index.html&lt;/code&gt; 에서 서비스 &lt;strong&gt;의 &amp;lt;script&amp;gt; 태그&lt;/strong&gt; 를 &lt;strong&gt;제거&lt;/strong&gt; 해야 &lt;strong&gt;합니다&lt;/strong&gt; . 업그레이드 할 때 모든 구성 요소에 수행 할 작업입니다. AngularJS에서 Angular 로의 업그레이드와 동시에 스크립트에서 모듈로 코드를 마이그레이션하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c231a5ec89ef8ef9f64c4f0e518e58b1a0bcd9fb" translate="yes" xml:space="preserve">
          <source>Now that you have TypeScript though, you can start benefiting from some of its features. There's a lot of value the language can provide to AngularJS applications.</source>
          <target state="translated">이제 TypeScript가 있으므로 일부 기능의 이점을 누릴 수 있습니다. 이 언어가 AngularJS 애플리케이션에 제공 할 수있는 많은 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d44c17683408615d821c56fc329cea0839ab82ba" translate="yes" xml:space="preserve">
          <source>Now that you have defined the complete model you are ready to create components to represent the dynamic form.</source>
          <target state="translated">완전한 모델을 정의 했으므로 동적 양식을 나타내는 컴포넌트를 작성할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="0d963739089f648dabdcabda5cd68b6b2ca45c28" translate="yes" xml:space="preserve">
          <source>Now that you have defined your routes, you can add them to your application. First, add links to the two components. Assign the anchor tag that you want to add the route to the &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;routerLink&lt;/a&gt;&lt;/code&gt; attribute. Set the value of the attribute to the component to show when a user clicks on each link. Next, update your component template to include &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt;. This element informs Angular to update the application view with the component for the selected route.</source>
          <target state="translated">경로를 정의 했으므로 이제 애플리케이션에 추가 할 수 있습니다. 먼저 두 구성 요소에 대한 링크를 추가합니다. route를 추가 할 앵커 태그를 &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;routerLink&lt;/a&gt;&lt;/code&gt; 속성 에 할당 합니다. 사용자가 각 링크를 클릭 할 때 표시 할 구성 요소에 속성 값을 설정합니다. 그런 다음 &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; 을 포함하도록 구성 요소 템플릿을 업데이트합니다 . 이 요소는 Angular에게 선택한 경로에 대한 구성 요소로 응용 프로그램보기를 업데이트하도록 알립니다.</target>
        </trans-unit>
        <trans-unit id="10512840c1bd48ee7ec3ba82fa1b9fdeb105fe26" translate="yes" xml:space="preserve">
          <source>Now that you have routes for the &lt;code&gt;Heroes&lt;/code&gt; module, register them with the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; via the &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; as you did in the &lt;code&gt;AppRoutingModule&lt;/code&gt;, with an important difference.</source>
          <target state="translated">이제에 대한 경로가 있는지 &lt;code&gt;Heroes&lt;/code&gt; 모듈의로 등록 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 비아 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; 당신이에서와 마찬가지로 &lt;code&gt;AppRoutingModule&lt;/code&gt; 중요한 차이.</target>
        </trans-unit>
        <trans-unit id="aae173e030893a651c868d22964d991589939b3b" translate="yes" xml:space="preserve">
          <source>Now that you have routes for the &lt;code&gt;Heroes&lt;/code&gt; module, register them with the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; via the &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt;&lt;em&gt;almost&lt;/em&gt; as you did in the &lt;code&gt;AppRoutingModule&lt;/code&gt;.</source>
          <target state="translated">이제에 대한 경로가 있는지 &lt;code&gt;Heroes&lt;/code&gt; 모듈의로 등록 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 비아 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; &lt;em&gt; 거의&lt;/em&gt; 당신이에서와 마찬가지로 &lt;code&gt;AppRoutingModule&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f5b424b133920495485a847554103b82eeb3505" translate="yes" xml:space="preserve">
          <source>Now that you have the infrastructure in place, you can define the main function that performs the modifications you need in the user's project.</source>
          <target state="translated">이제 인프라가 준비되었으므로 사용자 프로젝트에서 필요한 수정을 수행하는 기본 기능을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b593c745cc74a1a73f70dfc1d0de951807013f5a" translate="yes" xml:space="preserve">
          <source>Now that you have the project name, use it to retrieve the project-specific configuration information.</source>
          <target state="translated">이제 프로젝트 이름이 있으므로이를 사용하여 프로젝트 별 구성 정보를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="cbd3a712023bfce03175f02bdf61f587361932b7" translate="yes" xml:space="preserve">
          <source>Now that you're binding via the alias to the &lt;code&gt;highlightColor&lt;/code&gt;, modify the &lt;code&gt;onMouseEnter()&lt;/code&gt; method to use that property. If someone neglects to bind to &lt;code&gt;appHighlight&lt;/code&gt;, highlight the host element in red:</source>
          <target state="translated">별칭을 통해 &lt;code&gt;highlightColor&lt;/code&gt; 에 바인딩 하고 있으므로 해당 속성을 사용 하도록 &lt;code&gt;onMouseEnter()&lt;/code&gt; 메서드를 수정하십시오 . 누군가가 &lt;code&gt;appHighlight&lt;/code&gt; 에 바인딩하는 것을 무시 하면 호스트 요소를 빨간색으로 강조 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="9ed3c3d096190a1b583f3eec0c0c3a48535b2016" translate="yes" xml:space="preserve">
          <source>Now that you've defined the form model in the component class, you need a checkout form to reflect the model in the view.</source>
          <target state="translated">이제 컴포넌트 클래스에서 양식 모델을 정의 했으므로보기에 모델을 반영하기위한 체크 아웃 양식이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8bbf1d4af673e0b229add086221708378695d8ed" translate="yes" xml:space="preserve">
          <source>Now that you've seen how service workers cache your application, the next step is understanding how updates work.</source>
          <target state="translated">서비스 워커가 애플리케이션을 캐시하는 방법을 살펴 봤으므로 다음 단계는 업데이트 작동 방식을 이해하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c72b46b9c2f97721d01dbb4fc8766c089c7b8e33" translate="yes" xml:space="preserve">
          <source>Now that your app can retrieve shipping data, create a shipping component and template.</source>
          <target state="translated">이제 앱에서 배송 데이터를 검색 할 수 있으므로 배송 구성 요소와 템플릿을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="62d90a93219268bf854caa0f84caf30ae4950dfe" translate="yes" xml:space="preserve">
          <source>Now that your app can retrieve shipping data, you'll create a shipping component and associated template.</source>
          <target state="translated">앱에서 배송 데이터를 검색 할 수 있으므로 배송 구성 요소 및 관련 템플릿을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="18ccff9591e7981502d0c80f45b1c65d454c2b2e" translate="yes" xml:space="preserve">
          <source>Now that your library is installed, you can run the schematic using the &lt;code&gt;ng generate&lt;/code&gt; command.</source>
          <target state="translated">라이브러리가 설치 &lt;code&gt;ng generate&lt;/code&gt; 명령을 사용하여 회로도를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="825e70a3571f7ef43989791f0efe71a4da79cd11" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;AppModule&lt;/code&gt; knows about the feature module. If you were to add any service providers to the feature module, &lt;code&gt;AppModule&lt;/code&gt; would know about those too, as would any other feature modules. However, NgModules don&amp;rsquo;t expose their components by default.</source>
          <target state="translated">이제 &lt;code&gt;AppModule&lt;/code&gt; 은 기능 모듈에 대해 알고 있습니다. 기능 모듈에 서비스 공급자를 추가하는 경우 &lt;code&gt;AppModule&lt;/code&gt; 은 다른 기능 모듈과 마찬가지로 이들에 대해서도 알 수 있습니다. 그러나 NgModules는 기본적으로 해당 구성 요소를 노출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="994c06a9b3c626637f501e115a4a53bcc288cdfa" translate="yes" xml:space="preserve">
          <source>Now the &lt;code&gt;AppModule&lt;/code&gt; knows about the feature module. If you were to add any service providers to the feature module, &lt;code&gt;AppModule&lt;/code&gt; would know about those too, as would any other feature modules. However, NgModules don&amp;rsquo;t expose their components.</source>
          <target state="translated">이제 &lt;code&gt;AppModule&lt;/code&gt; 은 기능 모듈에 대해 알고 있습니다. 서비스 제공자를 기능 모듈에 추가하는 경우, 다른 기능 모듈과 마찬가지로 &lt;code&gt;AppModule&lt;/code&gt; 도 해당 기능 에 대해 알 수 있습니다. 그러나 NgModules는 구성 요소를 노출시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c1a435f43cdebf0feca007e512c240343d71b06" translate="yes" xml:space="preserve">
          <source>Now the app displays a &lt;em&gt;Name is required&lt;/em&gt; error message, because the input box is no longer pristine. The form remembers that you entered a name before clicking &lt;strong&gt;New Hero&lt;/strong&gt;.</source>
          <target state="translated">이제 입력 상자가 더 이상 깨끗하지 않기 때문에 앱에 &lt;em&gt;Name is required&lt;/em&gt; 오류 메시지 &lt;em&gt;가&lt;/em&gt; 표시됩니다 . 양식은 &lt;strong&gt;New Hero&lt;/strong&gt; 를 클릭하기 전에 이름을 입력했음을 기억합니다 .</target>
        </trans-unit>
        <trans-unit id="16422286fda1a8b63ef0a3cb704ce7f9dc48bb65" translate="yes" xml:space="preserve">
          <source>Now the app has no access to network interaction.</source>
          <target state="translated">이제 앱은 네트워크 상호 작용에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7add14e56319552fd92d2fc69fcc07e1a53b1142" translate="yes" xml:space="preserve">
          <source>Now the app needs to show something else while the form is in the submitted state. Add the following HTML below the &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; wrapper you just wrote:</source>
          <target state="translated">이제 양식이 제출 된 상태 인 동안 앱에서 다른 것을 표시해야합니다. 방금 작성한 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 래퍼 아래에 다음 HTML을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="04cbffd3b0130ad6c489cd7fc1fef24c43c3b6c7" translate="yes" xml:space="preserve">
          <source>Now the child component has an &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; for sending data to the parent and a method for raising an event. The next step is in the parent.</source>
          <target state="translated">이제 자식 구성 요소에는 부모에게 데이터를 보내기위한 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; 과 이벤트를 발생시키는 방법이 있습니다. 다음 단계는 부모입니다.</target>
        </trans-unit>
        <trans-unit id="e58d02cf48ab81dfcd69ff4fd10b072927c8e3cf" translate="yes" xml:space="preserve">
          <source>Now the file is as follows:</source>
          <target state="translated">이제 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="986f2c2b3de015effe713ac1a8299881bda3d82b" translate="yes" xml:space="preserve">
          <source>Now the heroes appear in an unordered list.</source>
          <target state="translated">이제 영웅이 순서가없는 목록에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="c558e1a9f826a6713ebc54a22692a56e087b7384" translate="yes" xml:space="preserve">
          <source>Now the important hooks for component manipulation and inspection are neatly organized and accessible from an instance of &lt;code&gt;Page&lt;/code&gt;.</source>
          <target state="translated">이제 구성 요소 조작 및 검사를위한 중요한 연결 고리가 깔끔하게 정리되고 &lt;code&gt;Page&lt;/code&gt; 인스턴스에서 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34948bb00fba567aba833324a1c5ef72aacfd251" translate="yes" xml:space="preserve">
          <source>Now the tests can control the component's hero directly by manipulating the spy-stub's &lt;code&gt;testHero&lt;/code&gt; and confirm that service methods were called.</source>
          <target state="translated">이제 테스트는 스파이 스텁의 &lt;code&gt;testHero&lt;/code&gt; 를 조작하여 구성 요소의 영웅을 직접 제어하고 서비스 메소드가 호출되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="79d069966db064de949cb3973e9deb864abd2d5b" translate="yes" xml:space="preserve">
          <source>Now there are two AngularJS components using an Angular service! The components don't need to be aware of this, though the fact that the service returns observables and not promises is a bit of a giveaway. In any case, what you've achieved is a migration of a service to Angular without having to yet migrate the components that use it.</source>
          <target state="translated">이제 Angular 서비스를 사용하는 2 개의 AngularJS 컴포넌트가 있습니다! 서비스가 약속을 지키지 않고 관찰 가능 항목을 반환한다는 사실은 약간의 공짜이지만 구성 요소는이를 알 필요가 없습니다. 어쨌든 달성 한 것은 서비스를 사용하는 구성 요소를 아직 마이그레이션하지 않고 Angular로 서비스를 마이그레이션하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f57fe9ffc1bae9ad4f8dd8de9bd630ea15635769" translate="yes" xml:space="preserve">
          <source>Now there's a new &lt;code&gt;&amp;lt;hero-contact&amp;gt;&lt;/code&gt; element between the &lt;code&gt;&amp;lt;hero-bio&amp;gt;&lt;/code&gt; tags. Angular &lt;em&gt;projects&lt;/em&gt;, or &lt;em&gt;transcludes&lt;/em&gt;, the corresponding &lt;code&gt;HeroContactComponent&lt;/code&gt; into the &lt;code&gt;HeroBioComponent&lt;/code&gt; view, placing it in the &lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt; slot of the &lt;code&gt;HeroBioComponent&lt;/code&gt; template.</source>
          <target state="translated">이제 &lt;code&gt;&amp;lt;hero-bio&amp;gt;&lt;/code&gt; 태그 사이에 새로운 &lt;code&gt;&amp;lt;hero-contact&amp;gt;&lt;/code&gt; 요소가 있습니다. Angular 는 해당 &lt;code&gt;HeroContactComponent&lt;/code&gt; 를 &lt;code&gt;HeroBioComponent&lt;/code&gt; 뷰에 &lt;em&gt;프로젝트&lt;/em&gt; 로 삽입하거나 &lt;em&gt;포함&lt;/em&gt; 하여 &lt;code&gt;HeroBioComponent&lt;/code&gt; 템플릿 의 &lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt; 슬롯에 배치합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="86530dec4e89aee683ff53e54908378941b3cfc5" translate="yes" xml:space="preserve">
          <source>Now update the &lt;code&gt;AppModule&lt;/code&gt; to import this &lt;code&gt;AppRoutingModule&lt;/code&gt; and also the declare the root &lt;code&gt;AppComponent&lt;/code&gt; as the bootstrap component. That tells Angular that it should bootstrap the app with the &lt;em&gt;root&lt;/em&gt;&lt;code&gt;AppComponent&lt;/code&gt; and insert its view into the host web page.</source>
          <target state="translated">이제이 &lt;code&gt;AppRoutingModule&lt;/code&gt; 을 가져 오도록 &lt;code&gt;AppModule&lt;/code&gt; 을 업데이트하고 루트 &lt;code&gt;AppComponent&lt;/code&gt; 를 부트 스트랩 구성 요소로 선언하십시오 . &lt;em&gt;루트 &lt;/em&gt; &lt;code&gt;AppComponent&lt;/code&gt; 로 앱을 부트 스트랩 하고 뷰를 호스트 웹 페이지에 삽입 해야한다고 Angular에 알립니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ef7f7bf54822569df51016f2eea7f62a075f7da1" translate="yes" xml:space="preserve">
          <source>Now use the Angular &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; directive in the template to display each item in the &lt;code&gt;heroes&lt;/code&gt; list.</source>
          <target state="translated">이제 템플릿에서 Angular &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 지시문을 사용하여 &lt;code&gt;heroes&lt;/code&gt; 목록 에 각 항목을 표시 하십시오.</target>
        </trans-unit>
        <trans-unit id="c5e8df4d912ab2294d4d374cc7572c8aa34fd245" translate="yes" xml:space="preserve">
          <source>Now we can register the &lt;code&gt;&lt;a href=&quot;downgradeinjectable&quot;&gt;downgradeInjectable&lt;/a&gt;&lt;/code&gt; factory function for the service on an AngularJS module.</source>
          <target state="translated">이제 AngularJS 모듈에서 서비스에 대한 &lt;code&gt;&lt;a href=&quot;downgradeinjectable&quot;&gt;downgradeInjectable&lt;/a&gt;&lt;/code&gt; 팩토리 기능을 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bbfe9f3467ea9d1c7a4aa835517f0ff9aab5c43b" translate="yes" xml:space="preserve">
          <source>Now we'll add a new behavior:</source>
          <target state="translated">이제 우리는 새로운 행동을 추가 할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="528d2e0908f98fa3efc83ae32c0f20bf07aa4ba7" translate="yes" xml:space="preserve">
          <source>Now when the user clicks a hero in the list, the &lt;code&gt;selectedHero&lt;/code&gt; changes. When the &lt;code&gt;selectedHero&lt;/code&gt; changes, the &lt;em&gt;property binding&lt;/em&gt; updates &lt;code&gt;hero&lt;/code&gt; and the &lt;code&gt;HeroDetailComponent&lt;/code&gt; displays the new hero.</source>
          <target state="translated">이제 사용자가 목록에서 영웅을 클릭하면 &lt;code&gt;selectedHero&lt;/code&gt; 가 변경됩니다. 때 &lt;code&gt;selectedHero&lt;/code&gt; 의 변화의 &lt;em&gt;특성 바인딩&lt;/em&gt; 업데이트 &lt;code&gt;hero&lt;/code&gt; 과 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 의 표시 새로운 영웅.</target>
        </trans-unit>
        <trans-unit id="6b2f0b55b26a6856bc208626d11d23230d46684e" translate="yes" xml:space="preserve">
          <source>Now when the user visits &lt;code&gt;/sidekicks&lt;/code&gt;, or any other invalid URL, the browser displays &quot;Page not found&quot;. The browser address bar continues to point to the invalid URL.</source>
          <target state="translated">사용자가 &lt;code&gt;/sidekicks&lt;/code&gt; 또는 다른 잘못된 URL을 방문 하면 브라우저에 &quot;페이지를 찾을 수 없음&quot;이 표시됩니다. 브라우저 주소 표시 줄이 계속 유효하지 않은 URL을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="d41c30e02191e61cbbe8d2eaa9fa3d216b97307a" translate="yes" xml:space="preserve">
          <source>Now when you open your application, it displays the &lt;code&gt;heroes-list&lt;/code&gt; component by default.</source>
          <target state="translated">이제 애플리케이션을 열면 기본적으로 &lt;code&gt;heroes-list&lt;/code&gt; 구성 요소가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f18771d1acfd3f12792bd6860e4c6e5e7b69fe39" translate="yes" xml:space="preserve">
          <source>Now when you use Angular CLI build commands such as &lt;code&gt;ng build&lt;/code&gt; and &lt;code&gt;ng serve&lt;/code&gt;, Bazel is used behind the scenes. Outputs from Bazel appear in the &lt;code&gt;dist/bin&lt;/code&gt; folder.</source>
          <target state="translated">이제 &lt;code&gt;ng build&lt;/code&gt; 및 &lt;code&gt;ng serve&lt;/code&gt; 와 같은 Angular CLI 빌드 명령을 사용하면 Bazel이 뒤에서 사용됩니다. Bazel의 출력은 &lt;code&gt;dist/bin&lt;/code&gt; 폴더에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="c7a0ab3599c8865f3372601be75f741199232fc1" translate="yes" xml:space="preserve">
          <source>Now wrap the Angular &lt;code&gt;Heroes&lt;/code&gt; in an &lt;em&gt;AngularJS factory function&lt;/em&gt; using &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgradeinjectable&quot;&gt;downgradeInjectable&lt;/a&gt;()&lt;/code&gt; and plug the factory into an AngularJS module. The name of the AngularJS dependency is up to you:</source>
          <target state="translated">이제 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgradeinjectable&quot;&gt;downgradeInjectable&lt;/a&gt;()&lt;/code&gt; ()을 사용하여 &lt;em&gt;AngularJS 팩토리 함수&lt;/em&gt; 에서 Angular &lt;code&gt;Heroes&lt;/code&gt; 를 감싸고 팩토리를 AngularJS 모듈에 꽂습니다. AngularJS 종속성의 이름은 귀하에게 달려 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b53b500dedb6cbfa865600fcab08edc6dcc7f98c" translate="yes" xml:space="preserve">
          <source>Now you are responsible for chaining promises, handling errors, and calling &lt;code&gt;&lt;a href=&quot;../api/core/applicationinitstatus#done&quot;&gt;done&lt;/a&gt;()&lt;/code&gt; at the appropriate moments.</source>
          <target state="translated">이제 약속을 연결하고 오류를 처리 하며 적절한 순간에 &lt;code&gt;&lt;a href=&quot;../api/core/applicationinitstatus#done&quot;&gt;done&lt;/a&gt;()&lt;/code&gt; 을 호출해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="1c5a201e77372f1fa1da7610c59afc6434b9079b" translate="yes" xml:space="preserve">
          <source>Now you are responsible for chaining promises, handling errors, and calling &lt;code&gt;done()&lt;/code&gt; at the appropriate moments.</source>
          <target state="translated">이제 적절한 순간에 promise를 연결하고, 오류를 처리하고, &lt;code&gt;done()&lt;/code&gt; 을 호출해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="bf3218e36c36c89f9fee5810ace8f73165c4690d" translate="yes" xml:space="preserve">
          <source>Now you can add a simpler, more meaningful parent provider to your components.</source>
          <target state="translated">이제 구성 요소에 더 단순하고 의미있는 상위 공급자를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e751b56a276d93f307ef9bedf14488b9d1a112b" translate="yes" xml:space="preserve">
          <source>Now you can bootstrap &lt;code&gt;AppModule&lt;/code&gt; using the &lt;code&gt;platformBrowserDynamic.bootstrapModule&lt;/code&gt; method.</source>
          <target state="translated">이제 &lt;code&gt;platformBrowserDynamic.bootstrapModule&lt;/code&gt; 메소드를 사용하여 &lt;code&gt;AppModule&lt;/code&gt; 을 부트 스트랩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b3a1e136b1ed93fc9d6cc4cd3e580ac201d867b" translate="yes" xml:space="preserve">
          <source>Now you can inject the configuration object into any constructor that needs it, with the help of an &lt;code&gt;@&lt;a href=&quot;../api/core/inject&quot;&gt;Inject&lt;/a&gt;()&lt;/code&gt; parameter decorator.</source>
          <target state="translated">이제 &lt;code&gt;@&lt;a href=&quot;../api/core/inject&quot;&gt;Inject&lt;/a&gt;()&lt;/code&gt; 매개 변수 데코레이터를 사용하여 구성 객체를 필요한 생성자에 삽입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92781f6a0d78ccaff03bcde26ff2133b15b2c96d" translate="yes" xml:space="preserve">
          <source>Now you can load Angular via SystemJS. You'll add the Angular polyfills and the SystemJS config to the end of the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; section, and then you'll use &lt;code&gt;System.import&lt;/code&gt; to load the actual application:</source>
          <target state="translated">이제 SystemJS를 통해 Angular를로드 할 수 있습니다. &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 섹션 의 끝에 Angular 폴리 필 및 SystemJS 구성을 추가 한 다음 &lt;code&gt;System.import&lt;/code&gt; 를 사용하여 실제 애플리케이션을로드합니다.</target>
        </trans-unit>
        <trans-unit id="671596674e3bd86db46df7786e3533ea2f9ec0b8" translate="yes" xml:space="preserve">
          <source>Now you can run the following commands to use the &lt;code&gt;--no-sandbox&lt;/code&gt; flag:</source>
          <target state="translated">이제 다음 명령을 실행하여 &lt;code&gt;--no-sandbox&lt;/code&gt; 플래그 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a632b016e2d489b2a5e6887cbe4b9669e8232050" translate="yes" xml:space="preserve">
          <source>Now you can use this function to create an observable that publishes keydown events:</source>
          <target state="translated">이제이 함수를 사용하여 키 다운 이벤트를 게시하는 Observable을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16250db81b906938bfea1e09f9e36f390523963f" translate="yes" xml:space="preserve">
          <source>Now you can write a test that expects a GET Request to occur and provides a mock response.</source>
          <target state="translated">이제 GET 요청이 발생하고 모의 응답을 제공하는 테스트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="356534438954877109de052a08e665aecd075a19" translate="yes" xml:space="preserve">
          <source>Now you could use your &lt;code&gt;ItemDirective&lt;/code&gt; in a component. This example uses &lt;code&gt;AppModule&lt;/code&gt;, but you'd do it the same way for a feature module. For more about directives, see &lt;a href=&quot;attribute-directives&quot;&gt;Attribute Directives&lt;/a&gt; and &lt;a href=&quot;structural-directives&quot;&gt;Structural Directives&lt;/a&gt;. You'd also use the same technique for &lt;a href=&quot;pipes&quot;&gt;pipes&lt;/a&gt; and components.</source>
          <target state="translated">이제 컴포넌트에서 &lt;code&gt;ItemDirective&lt;/code&gt; 를 사용할 수 있습니다 . 이 예제는 &lt;code&gt;AppModule&lt;/code&gt; 을 사용 하지만 기능 모듈에 대해서도 같은 방식으로 수행합니다. 지시문에 대한 자세한 내용은 &lt;a href=&quot;attribute-directives&quot;&gt;속성 지시문&lt;/a&gt; 및 &lt;a href=&quot;structural-directives&quot;&gt;구조&lt;/a&gt; 지시문을 참조하십시오 . &lt;a href=&quot;pipes&quot;&gt;파이프&lt;/a&gt; 및 구성 요소 에도 동일한 기술을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="08b3b4b158b49b816ee798f564ecf6070bd36d04" translate="yes" xml:space="preserve">
          <source>Now you have a reason. You'd like to send the id of the current hero with the navigation request so that the &lt;code&gt;HeroListComponent&lt;/code&gt; can highlight that hero in its list. This is a &lt;em&gt;nice-to-have&lt;/em&gt; feature; the list will display perfectly well without it.</source>
          <target state="translated">이제 이유가 있습니다. &lt;code&gt;HeroListComponent&lt;/code&gt; 가 목록에서 해당 영웅을 강조 표시 할 수 있도록 탐색 요청과 함께 현재 영웅의 ID를 보내려고 합니다. 이것은 &lt;em&gt;좋은&lt;/em&gt; 기능입니다. 목록이 없으면 완벽하게 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e3f68c2bd54737b5c6746e2a67e9c5ba506525fc" translate="yes" xml:space="preserve">
          <source>Now you have given the user a safeguard against unsaved changes.</source>
          <target state="translated">이제 저장하지 않은 변경 사항에 대한 보호 조치를 사용자에게 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="1e8ad82e05d360e9326ee3754fdc722c68635783" translate="yes" xml:space="preserve">
          <source>Now you have routes configured and a place to render them, but how do you navigate? The URL could arrive directly from the browser address bar. But most of the time you navigate as a result of some user action such as the click of an anchor tag.</source>
          <target state="translated">이제 라우트가 구성되고 렌더 할 장소가 있지만 어떻게 탐색합니까? URL은 브라우저 주소 표시 줄에서 직접 도착할 수 있습니다. 그러나 대부분 앵커 태그 클릭과 같은 일부 사용자 작업의 결과로 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="b8c6e28101d2f0f1ed27e2a0e238ac7868512ff9" translate="yes" xml:space="preserve">
          <source>Now you know how to use:</source>
          <target state="translated">이제 사용법을 알았습니다 :</target>
        </trans-unit>
        <trans-unit id="e45e3fae7d5230f9b1d361a75f6be79b5239cb1e" translate="yes" xml:space="preserve">
          <source>Now you need a component to demonstrate the pipe.</source>
          <target state="translated">이제 파이프를 시연하기위한 컴포넌트가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4865f9da84f736082da0ef0ad2c1a4452653ff0e" translate="yes" xml:space="preserve">
          <source>Now you need to display, listen, and extract at the same time.</source>
          <target state="translated">이제 동시에 표시, 청취 및 추출해야합니다.</target>
        </trans-unit>
        <trans-unit id="00d327498fa04d0aaac0be71048c528436ce2590" translate="yes" xml:space="preserve">
          <source>Now you need to downgrade the Angular component so you can use it in AngularJS. Instead of registering a component, you register a &lt;code&gt;phoneList&lt;/code&gt;&lt;em&gt;directive&lt;/em&gt;, a downgraded version of the Angular component.</source>
          <target state="translated">이제 Angular 컴포넌트를 다운 그레이드해야 AngularJS에서 사용할 수 있습니다. 컴포넌트를 등록하는 대신 Angular 컴포넌트의 다운 그레이드 된 버전 인 &lt;code&gt;phoneList&lt;/code&gt; &lt;em&gt;지시문&lt;/em&gt; 을 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="fabcfe9c39b7ee5e5ed15fce8613e94110abca6e" translate="yes" xml:space="preserve">
          <source>Now you should see both values in the browser:</source>
          <target state="translated">이제 브라우저에서 두 값을 모두 볼 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1105126bb0a082c27dd2fce38db2b1d997ad4d8a" translate="yes" xml:space="preserve">
          <source>Now you take the &lt;code&gt;Observables&lt;/code&gt; returned by the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; methods and &lt;em&gt;pipe them through&lt;/em&gt; to the error handler.</source>
          <target state="translated">이제 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 메소드가 리턴 한 &lt;code&gt;Observables&lt;/code&gt; 를 가져 와서 오류 핸들러로 &lt;em&gt;파이프&lt;/em&gt; 하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7c76b1b8a7d7aaadbd28641ed869fde4cd933d60" translate="yes" xml:space="preserve">
          <source>Now you'll add a new hero in this form. Place a &lt;em&gt;New Hero&lt;/em&gt; button at the bottom of the form and bind its click event to a &lt;code&gt;newHero&lt;/code&gt; component method.</source>
          <target state="translated">이제이 형식으로 새로운 영웅을 추가 할 것입니다. 장소 &lt;em&gt;새로운 영웅&lt;/em&gt; A와 형태 및 바인드의 클릭 이벤트의 하단에있는 버튼을 &lt;code&gt;newHero&lt;/code&gt; 구성 요소 방법.</target>
        </trans-unit>
        <trans-unit id="26617f4ec7367082b5f75aa3b416bfdad0724a39" translate="yes" xml:space="preserve">
          <source>Now you'll find new files in the Angular workspace:</source>
          <target state="translated">이제 Angular 작업 공간에 새 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d3847dde2903544e105c418a10a089b32c1dd6f" translate="yes" xml:space="preserve">
          <source>Now you're able to serve everything from the project root to the web browser. But you do &lt;em&gt;not&lt;/em&gt; want to have to change all the image and data paths used in the application code to match the development setup. For that reason, you'll add a &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; tag to &lt;code&gt;index.html&lt;/code&gt;, which will cause relative URLs to be resolved back to the &lt;code&gt;/app&lt;/code&gt; directory:</source>
          <target state="translated">이제 프로젝트 루트에서 웹 브라우저에 이르기까지 모든 것을 제공 할 수 있습니다. 그러나 개발 설정에 맞게 응용 프로그램 코드에 사용 된 모든 이미지 및 데이터 경로를 변경 하지 &lt;em&gt;않아도&lt;/em&gt; 됩니다. 따라서 &lt;code&gt;index.html&lt;/code&gt; 에 &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; 태그를 추가 하면 상대 URL이 &lt;code&gt;/app&lt;/code&gt; 디렉토리로 다시 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="363d917bd91f09c26b866a93a351a24478afcbb7" translate="yes" xml:space="preserve">
          <source>Now you're ready to upgrade the Phone service itself. Replace the ngResource-based service in &lt;code&gt;phone.service.ts&lt;/code&gt; with a TypeScript class decorated as &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">이제 전화 서비스 자체를 업그레이드 할 준비가되었습니다. 에 ngResource 기반 서비스를 교체 &lt;code&gt;phone.service.ts&lt;/code&gt; 로 장식 타이프 클래스와 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a17920b9482ce1526748ebaf014e32af7b4ed95d" translate="yes" xml:space="preserve">
          <source>Now you're running both AngularJS and Angular at the same time. That's pretty exciting! You're not running any actual Angular components yet. That's next.</source>
          <target state="translated">이제 AngularJS와 Angular를 동시에 실행하고 있습니다. 꽤 신나 네요! 아직 실제 Angular 구성 요소를 실행하고 있지 않습니다. 다음입니다.</target>
        </trans-unit>
        <trans-unit id="c5c23b237493ba58118ecd74acb24f6f9116315f" translate="yes" xml:space="preserve">
          <source>Now, TypeScript can infer the correct type the same way it does for built-in elements:</source>
          <target state="translated">이제 TypeScript는 내장 요소와 동일한 방식으로 올바른 유형을 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3073c011b4b03879fb8a69030fdf30c2deaac0bd" translate="yes" xml:space="preserve">
          <source>Now, build the project:</source>
          <target state="translated">이제 프로젝트를 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="e58d24f967ec605a4277e1e12ff5ad0a0072076d" translate="yes" xml:space="preserve">
          <source>Now, consider that &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; simply injects the &lt;code&gt;FlowerService&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; 가 단순히 &lt;code&gt;FlowerService&lt;/code&gt; 를 주입 한다는 것을 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="385db9851e8dc59eb84001ba56b61b83700866e3" translate="yes" xml:space="preserve">
          <source>Now, in addition to the title that renders by default, the &lt;code&gt;CustomerDashboardComponent&lt;/code&gt; template renders too:</source>
          <target state="translated">이제 기본적으로 렌더링되는 제목 외에도 &lt;code&gt;CustomerDashboardComponent&lt;/code&gt; 템플릿도 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="0f211056413d313893fd33573b60be910667bdea" translate="yes" xml:space="preserve">
          <source>Now, in order to see the &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; working, add the following to the parent's template:</source>
          <target state="translated">이제 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; 작동하는지 보려면 부모 템플릿에 다음을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="9816372ece2e5b46145f86d307b0ae1bede3b9e4" translate="yes" xml:space="preserve">
          <source>Now, in the &lt;code&gt;ChildComponent&lt;/code&gt; class, add a provider for &lt;code&gt;FlowerService&lt;/code&gt; to demonstrate more complex resolution rules in the upcoming sections:</source>
          <target state="translated">이제,에 &lt;code&gt;ChildComponent&lt;/code&gt; 에 대한 클래스, 공급자를 추가 &lt;code&gt;FlowerService&lt;/code&gt; 이 다가오는 섹션에서 더 복잡한 해상도 규칙을 보여줍니다 :</target>
        </trans-unit>
        <trans-unit id="c418264f80adc745aa21731adfd74b8b7b5570c4" translate="yes" xml:space="preserve">
          <source>Now, on every HTTP request made as part of rendering the app on the server, Angular can correctly resolve the request URL to an absolute URL, using the provided &lt;code&gt;options.url&lt;/code&gt;.</source>
          <target state="translated">이제 서버에서 앱 렌더링의 일부로 이루어진 모든 HTTP 요청에서 Angular는 제공된 &lt;code&gt;options.url&lt;/code&gt; 을 사용하여 요청 URL을 절대 URL로 올바르게 해석 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="164448af25ecb5d5af743c8f0404254be8b97103" translate="yes" xml:space="preserve">
          <source>Now, on every HTTP request made on the server, this interceptor will fire and replace the request URL with the absolute URL provided in the Express &lt;code&gt;Request&lt;/code&gt; object.</source>
          <target state="translated">이제 서버에서 이루어진 모든 HTTP 요청에서이 인터셉터는 요청 URL을 실행하고 Express &lt;code&gt;Request&lt;/code&gt; 오브젝트에 제공된 절대 URL로 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="e673af9c12c7e8dae720c59a0aa4117bfe1a7584" translate="yes" xml:space="preserve">
          <source>Now, put it all together in a micro-app that can display a list of heroes and add new heroes to the list. The user can add a hero by typing the hero's name in the input box and clicking &lt;strong&gt;Add&lt;/strong&gt;.</source>
          <target state="translated">이제 영웅 목록을 표시하고 목록에 새 영웅을 추가 할 수있는 마이크로 앱에 모두 통합하십시오. 입력 상자에 영웅 이름을 입력하고 &lt;strong&gt;추가를&lt;/strong&gt; 클릭하여 영웅을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c51173d5bd03aa194d309591860a911a36c467c" translate="yes" xml:space="preserve">
          <source>Now, send the &lt;code&gt;id&lt;/code&gt; of the current hero with the navigation request so that the &lt;code&gt;HeroListComponent&lt;/code&gt; can highlight that hero in its list.</source>
          <target state="translated">이제 &lt;code&gt;HeroListComponent&lt;/code&gt; 가 목록에서 해당 Hero 를 강조 표시 할 수 있도록 탐색 요청과 함께 현재 Hero 의 &lt;code&gt;id&lt;/code&gt; 를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="cb9abbba83c51ed21e4fde40ffb5f6a4d73e60ca" translate="yes" xml:space="preserve">
          <source>Now, when the user clicks on a name in the product list, the router navigates you to the distinct URL for the product, swaps out the product list component for the product details component, and displays the product details.</source>
          <target state="translated">이제 사용자가 제품 목록에서 이름을 클릭하면 라우터가 제품의 고유 URL로 이동하여 제품 세부 사항 구성 요소의 제품 목록 구성 요소를 교체하고 제품 세부 사항을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="5650646ca2461a1170d9e892c6920d58812bb7a0" translate="yes" xml:space="preserve">
          <source>Now, when users click on a name in the product list, the router navigates them to the distinct URL for the product, swaps out the product list component for the product details component, and displays the product details.</source>
          <target state="translated">이제 사용자가 제품 목록에서 이름을 클릭하면 라우터가 해당 제품의 고유 URL로 이동하고 제품 세부 정보 구성 요소에 대한 제품 목록 구성 요소를 교체하고 제품 세부 정보를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="68ad64394ecf25c54bd8b619f657dede48d26165" translate="yes" xml:space="preserve">
          <source>Now, you can click on the &lt;em&gt;Admin&lt;/em&gt; button, which takes you to the &lt;em&gt;Login&lt;/em&gt; page with the provided &lt;code&gt;queryParamMap&lt;/code&gt; and &lt;code&gt;fragment&lt;/code&gt;. After you click the login button, notice that you have been redirected to the &lt;code&gt;Admin Dashboard&lt;/code&gt; page with the query parameters and fragment still intact in the address bar.</source>
          <target state="translated">이제 &lt;em&gt;관리자&lt;/em&gt; 버튼을 클릭 하면 제공된 &lt;code&gt;queryParamMap&lt;/code&gt; 및 &lt;code&gt;fragment&lt;/code&gt; 가있는 &lt;em&gt;로그인&lt;/em&gt; 페이지로 이동합니다 . 로그인 버튼을 클릭 한 후에 는 주소 표시 줄에 쿼리 매개 변수와 조각이 그대로 있는 &lt;code&gt;Admin Dashboard&lt;/code&gt; 페이지 로 리디렉션되었음을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c46e41142e6f6ec7138e7054041639047402b9c5" translate="yes" xml:space="preserve">
          <source>Now, you can click on the Admin button, which takes you to the Login page with the provided &lt;code&gt;queryParamMap&lt;/code&gt; and &lt;code&gt;fragment&lt;/code&gt;. After you click the login button, notice that you have been redirected to the &lt;code&gt;Admin Dashboard&lt;/code&gt; page with the query parameters and fragment still intact in the address bar.</source>
          <target state="translated">이제 Admin 버튼을 클릭하면 제공된 &lt;code&gt;queryParamMap&lt;/code&gt; 및 &lt;code&gt;fragment&lt;/code&gt; 가있는 로그인 페이지로 이동합니다 . 로그인 버튼을 클릭하면 검색어 매개 변수와 조각이 주소 표시 줄에 그대로있는 상태로 &lt;code&gt;Admin Dashboard&lt;/code&gt; 페이지 로 리디렉션되었음을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e8fdc533e7ebf361eee022748adf90dbdd429b0" translate="yes" xml:space="preserve">
          <source>Number of bytes uploaded or downloaded.</source>
          <target state="translated">업로드 또는 다운로드 한 바이트 수</target>
        </trans-unit>
        <trans-unit id="8e3ed072350bf6896bfd56e3372a8adbb401f793" translate="yes" xml:space="preserve">
          <source>Number of child segments</source>
          <target state="translated">자식 세그먼트 수</target>
        </trans-unit>
        <trans-unit id="980b65576d0aa6729d710f3af55159749210dffd" translate="yes" xml:space="preserve">
          <source>NumberFormatStyle</source>
          <target state="translated">NumberFormatStyle</target>
        </trans-unit>
        <trans-unit id="669cf27771d36a7a86ce7ca843b106933857036b" translate="yes" xml:space="preserve">
          <source>NumberSymbol</source>
          <target state="translated">NumberSymbol</target>
        </trans-unit>
        <trans-unit id="f6886cefb07980bc0c752b8e9f1ae3bffc341dd5" translate="yes" xml:space="preserve">
          <source>NumberValueAccessor</source>
          <target state="translated">NumberValueAccessor</target>
        </trans-unit>
        <trans-unit id="ea7a1484b29f720f95c48a50411655a57d7b5eea" translate="yes" xml:space="preserve">
          <source>Numbers are formatted using patterns, like &lt;code&gt;#,###.00&lt;/code&gt;. For example, the pattern &lt;code&gt;#,###.00&lt;/code&gt; when used to format the number 12345.678 could result in &quot;12'345,678&quot;. That would happen if the grouping separator for your language is an apostrophe, and the decimal separator is a comma.</source>
          <target state="translated">숫자는 &lt;code&gt;#,###.00&lt;/code&gt; 과 같은 패턴을 사용하여 형식이 지정됩니다 . 예를 들어 숫자 12345.678의 형식을 지정하는 데 패턴 &lt;code&gt;#,###.00&lt;/code&gt; 을 사용하면 &quot;12'345,678&quot;이 될 수 있습니다. 해당 언어의 그룹 구분 기호가 아포스트로피이고 소수 구분 기호가 쉼표 인 경우 이런 일이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="30a62380404b3b267a5c4e21b5e111455d09031e" translate="yes" xml:space="preserve">
          <source>Numeric</source>
          <target state="translated">Numeric</target>
        </trans-unit>
        <trans-unit id="f61f58717243894f8209850e6dfa27b4866bcd15" translate="yes" xml:space="preserve">
          <source>Numeric: 1 digit</source>
          <target state="translated">숫자 : 1 자리</target>
        </trans-unit>
        <trans-unit id="c897da7ae95620ddc7ab4eaba13d88ee997ba04d" translate="yes" xml:space="preserve">
          <source>Numeric: 2 digits + zero padded</source>
          <target state="translated">숫자 : 2 자리 + 0으로 채워짐</target>
        </trans-unit>
        <trans-unit id="ac85e289a5111a49c093b32446dacd1413a69c3e" translate="yes" xml:space="preserve">
          <source>Numeric: 3 digits + zero padded</source>
          <target state="translated">숫자 : 3 자리 숫자 + 0으로 채워짐</target>
        </trans-unit>
        <trans-unit id="9c0c408032d6d01311f2e91f8ee8db893fffb761" translate="yes" xml:space="preserve">
          <source>Numeric: 3 digits + zero padded (= milliseconds)</source>
          <target state="translated">숫자 : 3 자리 + 0으로 채워짐 (= 밀리 초)</target>
        </trans-unit>
        <trans-unit id="6aafe96d17fdf0fc3b92893d2c4193c2158eab30" translate="yes" xml:space="preserve">
          <source>Numeric: 4 digits or more + zero padded</source>
          <target state="translated">숫자 : 4 자리 이상 + 0으로 채워짐</target>
        </trans-unit>
        <trans-unit id="b25a8cc7dee6909ece362fa9930471d58a49bce6" translate="yes" xml:space="preserve">
          <source>Numeric: minimum digits</source>
          <target state="translated">숫자 : 최소 자릿수</target>
        </trans-unit>
        <trans-unit id="d459255f682464b4bc2d85fd539283259e417475" translate="yes" xml:space="preserve">
          <source>O, OO &amp;amp; OOO</source>
          <target state="translated">O, OO 및 OOO</target>
        </trans-unit>
        <trans-unit id="de972b449781e8b363165664000a140bc87f8bef" translate="yes" xml:space="preserve">
          <source>OOOO</source>
          <target state="translated">OOOO</target>
        </trans-unit>
        <trans-unit id="e70d3bd602e4616ed521dbc75b821aaa43066442" translate="yes" xml:space="preserve">
          <source>OPTIONS PROPERTIES</source>
          <target state="translated">옵션 속성</target>
        </trans-unit>
        <trans-unit id="1abfd8fa9e86107dd0aaf00ccf53b9d31cdd4ba7" translate="yes" xml:space="preserve">
          <source>OR install it with npm: &lt;code&gt;npm install -g typescript@latest&lt;/code&gt;.</source>
          <target state="translated">또는 npm : &lt;code&gt;npm install -g typescript@latest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99e39cba79f65e281b455366f9242549288d5dcf" translate="yes" xml:space="preserve">
          <source>OS/X (bash)</source>
          <target state="translated">OS / X (bash)</target>
        </trans-unit>
        <trans-unit id="3367dfe3d559355fc25f130ee6514602f3493a9c" translate="yes" xml:space="preserve">
          <source>Obeys TypeScript's &lt;code&gt;strictNullChecks&lt;/code&gt; flag when validating the above.</source>
          <target state="translated">위의 유효성을 검사 할 때 TypeScript의 &lt;code&gt;strictNullChecks&lt;/code&gt; 플래그를 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="24d50592b70a997e82a3839de9c69ef0c75660a9" translate="yes" xml:space="preserve">
          <source>Objectives</source>
          <target state="translated">Objectives</target>
        </trans-unit>
        <trans-unit id="c92258fa87a7fd87bfb0eac39b2cad3876c1531d" translate="yes" xml:space="preserve">
          <source>Observable</source>
          <target state="translated">Observable</target>
        </trans-unit>
        <trans-unit id="785a3f3b0ea9d70aa55967dc49e804eb212006fc" translate="yes" xml:space="preserve">
          <source>Observable &lt;code&gt;HeroService&lt;/code&gt;</source>
          <target state="translated">관찰 가능한 &lt;code&gt;HeroService&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f6e2fb333ea04d6d296092c9bdec270aaafff8db" translate="yes" xml:space="preserve">
          <source>Observable creation functions</source>
          <target state="translated">관찰 가능한 생성 기능</target>
        </trans-unit>
        <trans-unit id="62e8435b07b0e929cc1dffa87e53ebbceb45ce20" translate="yes" xml:space="preserve">
          <source>Observable data</source>
          <target state="translated">관찰 가능한 데이터</target>
        </trans-unit>
        <trans-unit id="0f83ae35ff248bf8cb655221ad8206b62264675a" translate="yes" xml:space="preserve">
          <source>Observable execution errors are delivered to the subscriber's error handler, and the subscriber automatically unsubscribes from the observable.</source>
          <target state="translated">관찰 가능한 실행 오류는 구독자의 오류 처리기로 전달되고 구독자는 관찰 가능한 개체를 자동으로 구독 취소합니다.</target>
        </trans-unit>
        <trans-unit id="90874d5fd2f5124aeb81b5ae417389012587a628" translate="yes" xml:space="preserve">
          <source>Observable subscriptions are cancellable. Unsubscribing removes the listener from receiving further values, and notifies the subscriber function to cancel work.</source>
          <target state="translated">관찰 가능한 구독은 취소 할 수 있습니다. 구독을 취소하면 리스너가 추가 값을 수신하지 못하게하고 구독자 기능에게 작업을 취소하도록 알립니다.</target>
        </trans-unit>
        <trans-unit id="280a1a6cb91a67abe6185db4d0e161618a257d5e" translate="yes" xml:space="preserve">
          <source>Observable techniques and operators. See the &lt;a href=&quot;observables&quot;&gt;Observables&lt;/a&gt; guide.</source>
          <target state="translated">관찰 가능한 기술 및 연산자. &lt;a href=&quot;observables&quot;&gt;Observables&lt;/a&gt; 가이드를 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="8136b5b444e74956953de6d7e21de45a7208ed8b" translate="yes" xml:space="preserve">
          <source>Observables</source>
          <target state="translated">Observables</target>
        </trans-unit>
        <trans-unit id="30e14d185eeb8490cc7c75c30432edec8f889146" translate="yes" xml:space="preserve">
          <source>Observables &lt;code&gt;subscribe()&lt;/code&gt; is responsible for handling errors. Promises push errors to the child promises. This makes observables useful for centralized and predictable error handling.</source>
          <target state="translated">Observables &lt;code&gt;subscribe()&lt;/code&gt; 는 오류 처리를 담당합니다. 자녀의 약속에 오류를 미룰 것을 약속합니다. 이는 관측 가능 항목을 중앙 집중식 및 예측 가능한 오류 처리에 유용하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8966e8f44fb07002812ce2f223c191c58f1d0d9d" translate="yes" xml:space="preserve">
          <source>Observables and operators</source>
          <target state="translated">관찰자와 연산자</target>
        </trans-unit>
        <trans-unit id="2c0a8f53cdda10ab0bd4d5887abc2a699e9095ee" translate="yes" xml:space="preserve">
          <source>Observables are declarative&amp;mdash;that is, you define a function for publishing values, but it is not executed until a consumer subscribes to it. The subscribed consumer then receives notifications until the function completes, or until they unsubscribe.</source>
          <target state="translated">Observable은 선언적입니다. 즉, 값을 게시하기위한 함수를 정의하지만 소비자가 구독 할 때까지 실행되지 않습니다. 구독 한 소비자는 기능이 완료 될 때까지 또는 구독을 취소 할 때까지 알림을받습니다.</target>
        </trans-unit>
        <trans-unit id="93ab2117177a7d20d9111101ecd4f4e38e6f877b" translate="yes" xml:space="preserve">
          <source>Observables are declarative; computation does not start until subscription. Promises execute immediately on creation. This makes observables useful for defining recipes that can be run whenever you need the result.</source>
          <target state="translated">관찰 가능한 내용은 선언적입니다. 가입 할 때까지 계산이 시작되지 않습니다. 약속은 창조 즉시 실행됩니다. 결과 값이 필요할 때마다 실행될 수있는 레시피를 정의하는 데 관찰 가능 항목이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b160012c6166e34c5bdefa46dcac19c1bac94227" translate="yes" xml:space="preserve">
          <source>Observables are not executed until a consumer subscribes. The &lt;code&gt;subscribe()&lt;/code&gt; executes the defined behavior once, and it can be called again. Each subscription has its own computation. Resubscription causes recomputation of values.</source>
          <target state="translated">관찰자는 소비자가 구독 할 때까지 실행되지 않습니다. 이 &lt;code&gt;subscribe()&lt;/code&gt; 한 번 정의 된 동작을 실행하고, 다시 호출 할 수 있습니다. 각 구독에는 자체 계산이 있습니다. 다시 구독하면 값이 다시 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="2e102ee69c779948f1ae41fc642ce5644eb359da" translate="yes" xml:space="preserve">
          <source>Observables are often compared to promises. Here are some key differences:</source>
          <target state="translated">옵저버 블은 종종 약속과 비교됩니다. 주요 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9bb28d4febb9104ac022af5489313da08d4e8b56" translate="yes" xml:space="preserve">
          <source>Observables are very similar to event handlers that use the events API. Both techniques define notification handlers, and use them to process multiple values delivered over time. Subscribing to an observable is equivalent to adding an event listener. One significant difference is that you can configure an observable to transform an event before passing the event to the handler.</source>
          <target state="translated">Observable은 events API를 사용하는 이벤트 핸들러와 매우 유사합니다. 두 기술 모두 알림 핸들러를 정의하고이를 사용하여 시간이 지남에 따라 전달되는 여러 값을 처리합니다. Observable에 가입하는 것은 이벤트 리스너를 추가하는 것과 같습니다. 한 가지 중요한 차이점은 이벤트를 처리기로 전달하기 전에 이벤트를 변환하도록 Observable을 구성 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1e59290cc3930f973e0b29f99ba859aad65b89ac" translate="yes" xml:space="preserve">
          <source>Observables behave somewhat differently from the alternative techniques in each of these situations, but offer some significant advantages. Here are detailed comparisons of the differences.</source>
          <target state="translated">Observable은 이러한 각 상황에서 대체 기술과는 약간 다르게 작동하지만 몇 가지 중요한 이점을 제공합니다. 차이점에 대한 자세한 비교는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="29b86c845413a3110f1c6984def0e28e9af725a3" translate="yes" xml:space="preserve">
          <source>Observables can deliver single or multiple values of any type to subscribers, either synchronously (as a function delivers a value to its caller) or on a schedule. A subscriber receives notification of new values as they are produced and notification of either normal completion or error completion.</source>
          <target state="translated">Observable은 동기식 (함수가 호출자에게 값을 전달할 때) 또는 일정에 따라 모든 유형의 단일 또는 다중 값을 구독자에게 전달할 수 있습니다. 가입자는 새로운 값이 생성 될 때 알림을 받고 정상 완료 또는 오류 완료 알림을받습니다.</target>
        </trans-unit>
        <trans-unit id="e64a10ecf32eddcfb93b7609d0a93da2a9d645b7" translate="yes" xml:space="preserve">
          <source>Observables can simplify the implementation of type-ahead suggestions. Typically, a type-ahead has to do a series of separate tasks:</source>
          <target state="translated">Observables는 자동 완성 제안의 구현을 단순화 할 수 있습니다. 일반적으로 자동 완성 기능은 일련의 개별 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="54ed5cd5266bdfeb305f4a9d721d88b6f8ac158e" translate="yes" xml:space="preserve">
          <source>Observables compared to arrays</source>
          <target state="translated">배열과 비교 한 관찰 가능</target>
        </trans-unit>
        <trans-unit id="33061d9aa51ad55e0e39ece1c9fce85ebbe96428" translate="yes" xml:space="preserve">
          <source>Observables compared to events API</source>
          <target state="translated">이벤트 API와 비교 한 관찰 가능</target>
        </trans-unit>
        <trans-unit id="7e83cd6a82ab26bd772a156a7d590b954e6b51bd" translate="yes" xml:space="preserve">
          <source>Observables compared to other techniques</source>
          <target state="translated">다른 기술에 비해 관찰 가능</target>
        </trans-unit>
        <trans-unit id="5855fd77921e99a1e777d7a837b5fc8fbfedaf31" translate="yes" xml:space="preserve">
          <source>Observables compared to promises</source>
          <target state="translated">약속과 비교 한 관찰 가능</target>
        </trans-unit>
        <trans-unit id="4d544e0f81246ce890ad290e4eb8a63576d6546d" translate="yes" xml:space="preserve">
          <source>Observables differentiate between chaining and subscription. Promises only have &lt;code&gt;.then()&lt;/code&gt; clauses. This makes observables useful for creating complex transformation recipes to be used by other part of the system, without causing the work to be executed.</source>
          <target state="translated">옵저버 블은 체인과 구독을 구분합니다. 약속에는 &lt;code&gt;.then()&lt;/code&gt; 있습니다. 이로 인해 Observables는 작업을 실행하지 않고도 시스템의 다른 부분에서 사용할 복잡한 변환 레시피를 만드는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4f31634276ae0b6d7da9429fe6a77b639c9c5b4a" translate="yes" xml:space="preserve">
          <source>Observables differentiate between transformation function such as a map and subscription. Only subscription activates the subscriber function to start computing the values.</source>
          <target state="translated">Observable은 맵 및 구독과 같은 변환 기능을 구분합니다. 구독 만 구독자 기능을 활성화하여 값 계산을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="2542058ccb21f3ec072eb961a2e4af69d7704ac0" translate="yes" xml:space="preserve">
          <source>Observables do not mutate the server response (as can occur through chained &lt;code&gt;.then()&lt;/code&gt; calls on promises). Instead, you can use a series of operators to transform values as needed.</source>
          <target state="translated">Observable은 서버 응답을 변경하지 않습니다 &lt;code&gt;.then()&lt;/code&gt; 약속의 체인 .then () 호출을 통해 발생할 수 있음 ). 대신 일련의 연산자를 사용하여 필요에 따라 값을 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d64b02b67e25d074f407a93f93433a03bc63e743" translate="yes" xml:space="preserve">
          <source>Observables in Angular</source>
          <target state="translated">각도의 관측 가능</target>
        </trans-unit>
        <trans-unit id="9d8868d84d679957521451004f5fad171a308cdd" translate="yes" xml:space="preserve">
          <source>Observables provide many values. Promises provide one. This makes observables useful for getting multiple values over time.</source>
          <target state="translated">Observable은 많은 가치를 제공합니다. 약속은 하나를 제공합니다. 따라서 관측 가능 항목은 시간이 지남에 따라 여러 값을 얻는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="77c4a01c85c3ac2ce7133ef3e99221217b2c077f" translate="yes" xml:space="preserve">
          <source>Observables provide support for passing messages between parts of your application. They are used frequently in Angular and are the recommended technique for event handling, asynchronous programming, and handling multiple values.</source>
          <target state="translated">Observable은 애플리케이션의 일부간에 메시지 전달을 지원합니다. Angular에서 자주 사용되며 이벤트 처리, 비동기 프로그래밍 및 여러 값 처리에 권장되는 기술입니다.</target>
        </trans-unit>
        <trans-unit id="109c7ef3fece22c5a2d3b858b2a395fe70285d16" translate="yes" xml:space="preserve">
          <source>Observables provide support for passing messages between publishers and subscribers in your application. Observables offer significant benefits over other techniques for event handling, asynchronous programming, and handling multiple values.</source>
          <target state="translated">Observable은 응용 프로그램의 게시자와 구독자간에 메시지를 전달할 수 있도록 지원합니다. Observable은 이벤트 처리, 비동기식 프로그래밍 및 여러 값 처리와 같은 다른 기술에 비해 상당한 이점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="461ebaa1f07be70daced315214b9277178250b82" translate="yes" xml:space="preserve">
          <source>Observations</source>
          <target state="translated">Observations</target>
        </trans-unit>
        <trans-unit id="08168d03762ffc3483c2b2fffce378f6c11dbae9" translate="yes" xml:space="preserve">
          <source>Observe control states</source>
          <target state="translated">제어 상태 관찰</target>
        </trans-unit>
        <trans-unit id="4225298b274ef1bf2a3a26f4929b85790965a9dd" translate="yes" xml:space="preserve">
          <source>Obtaining a component reference is a bit tricky in Angular. Angular components themselves do not have a tree that you can inspect or navigate programmatically. The parent-child relationship is indirect, established through the components' &lt;a href=&quot;glossary#view&quot;&gt;view objects&lt;/a&gt;.</source>
          <target state="translated">Angular에서는 구성 요소 참조를 얻는 것이 약간 까다 롭습니다. 각도 구성 요소 자체에는 프로그래밍 방식으로 검사하거나 탐색 할 수있는 트리가 없습니다. 부모-자식 관계는 구성 요소의 &lt;a href=&quot;glossary#view&quot;&gt;뷰 객체를&lt;/a&gt; 통해 간접적으로 설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="5c35043d70a29551f83f6e081cebe2ff9400c970" translate="yes" xml:space="preserve">
          <source>Occasionally APIs change formats in a way that is not backward-compatible. A new version of the app may not be compatible with the old API format and thus may not be compatible with existing cached resources from that API.</source>
          <target state="translated">때때로 API는 이전 버전과 호환되지 않는 방식으로 형식을 변경합니다. 새 버전의 앱은 이전 API 형식과 호환되지 않을 수 있으므로 해당 API의 기존 캐시 된 리소스와 호환되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="950e5b0c6c85584f0d783503489f66ffacf77445" translate="yes" xml:space="preserve">
          <source>Occasionally it is desirable for the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; of a directive or component to alter the value bound to it, typically using a getter/setter pair for the input. As an example, consider this custom button component:</source>
          <target state="translated">경우 에 따라 지시문 또는 구성 요소 의 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 이 일반적으로 입력에 대해 getter / setter 쌍을 사용하여 바인딩 된 값을 변경하는 것이 바람직합니다 . 예를 들어 다음 사용자 정의 버튼 구성 요소를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="16303cc54c8dfe2f9470baf107ce29acea50d287" translate="yes" xml:space="preserve">
          <source>Occasionally, it may be necessary to examine the Angular service worker in a running state to investigate issues or to ensure that it is operating as designed. Browsers provide built-in tools for debugging service workers and the Angular service worker itself includes useful debugging features.</source>
          <target state="translated">경우에 따라 실행중인 상태에서 Angular 서비스 작업자를 검사하여 문제를 조사하거나 설계대로 작동하는지 확인해야 할 수도 있습니다. 브라우저는 서비스 워커 디버깅을위한 기본 제공 도구를 제공하며 Angular 서비스 워커 자체에는 유용한 디버깅 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="07da3eb47577618d394c3fa8b0a5590861dab816" translate="yes" xml:space="preserve">
          <source>Oct 18, 2018</source>
          <target state="translated">2018 년 10 월 18 일</target>
        </trans-unit>
        <trans-unit id="25cfa189f2f5f94f39538dcc8442014aa9fc4b86" translate="yes" xml:space="preserve">
          <source>October/November 2019</source>
          <target state="translated">2019 년 10 월 / 11 월</target>
        </trans-unit>
        <trans-unit id="8c0697187ec5c3bf075b63a3ce1c75bbd5841f7c" translate="yes" xml:space="preserve">
          <source>Of course it catches errors in much the same manner &lt;a href=&quot;http#error-details&quot;&gt;described above&lt;/a&gt;.</source>
          <target state="translated">물론 &lt;a href=&quot;http#error-details&quot;&gt;위에서 설명한&lt;/a&gt; 것과 거의 같은 방식으로 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="2d89f448342550836237d3ab6b17deef13e83f94" translate="yes" xml:space="preserve">
          <source>Of course specs that test the test helpers belong in the &lt;code&gt;test&lt;/code&gt; folder, next to their corresponding helper files.</source>
          <target state="translated">물론 테스트 도우미를 테스트하는 사양은 해당 도우미 파일 옆 의 &lt;code&gt;test&lt;/code&gt; 폴더에 속합니다 .</target>
        </trans-unit>
        <trans-unit id="9fcca52a438d7d41edd046584c4cc1cdfc971762" translate="yes" xml:space="preserve">
          <source>Of course you could reach into the DOM with standard JavaScript and attach event listeners manually. There are at least three problems with &lt;em&gt;that&lt;/em&gt; approach:</source>
          <target state="translated">물론 표준 JavaScript로 DOM에 접근하여 이벤트 리스너를 수동으로 연결할 수 있습니다. 적어도 세 가지 문제가 있습니다 &lt;em&gt;그&lt;/em&gt; 방법은 :</target>
        </trans-unit>
        <trans-unit id="e35b2ed1b9fd7dd8c47eb313124eb5710d9f1f7b" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;HeroListComponent&lt;/code&gt; should do something with the injected &lt;code&gt;HeroService&lt;/code&gt;. Here's the revised component, making use of the injected service, side-by-side with the previous version for comparison.</source>
          <target state="translated">물론 &lt;code&gt;HeroListComponent&lt;/code&gt; 는 주입 된 &lt;code&gt;HeroService&lt;/code&gt; 로 무언가를 수행해야합니다 . 다음은 주입 된 서비스를 이전 버전과 나란히 비교하여 수정 한 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="9b34c53405e962990aac873af90ef66759158805" translate="yes" xml:space="preserve">
          <source>Offer Google engineers better integration with Angular and Google's internal server stack</source>
          <target state="translated">Google 엔지니어에게 Angular 및 Google의 내부 서버 스택과 더 나은 통합을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ce667716547fa82bc8795ad7ef205e9410193ed0" translate="yes" xml:space="preserve">
          <source>Offset</source>
          <target state="translated">Offset</target>
        </trans-unit>
        <trans-unit id="215ce18708e65860f0fec7ec5be21add165fdd57" translate="yes" xml:space="preserve">
          <source>Often &lt;a href=&quot;interpolation&quot;&gt;interpolation&lt;/a&gt; and property binding can achieve the same results. The following binding pairs do the same thing.</source>
          <target state="translated">종종 &lt;a href=&quot;interpolation&quot;&gt;보간&lt;/a&gt; 및 속성 바인딩은 동일한 결과를 얻을 수 있습니다. 다음 바인딩 쌍은 동일한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="615221e93de5702f56502c83077e51e2f8408f40" translate="yes" xml:space="preserve">
          <source>Often this function will be implemented using an ES dynamic &lt;code&gt;import()&lt;/code&gt; expression. For example:</source>
          <target state="translated">종종이 함수는 ES 동적 &lt;code&gt;import()&lt;/code&gt; 표현식을 사용하여 구현됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d99af778bebf475f57e3b69188e55ece9df9bc8d" translate="yes" xml:space="preserve">
          <source>Often you want to focus on a fragment of code within a sample code file. In this example, you focus on the &lt;code&gt;AppModule&lt;/code&gt; class and its &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; metadata.</source>
          <target state="translated">종종 샘플 코드 파일 내의 코드 조각에 초점을 맞추려고합니다. 이 예에서는 &lt;code&gt;AppModule&lt;/code&gt; 클래스와 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 메타 데이터 에 중점을 둡니다 .</target>
        </trans-unit>
        <trans-unit id="cc7bbf74fabc76a8b347133dfb207914ea08c46f" translate="yes" xml:space="preserve">
          <source>Often, as a user navigates your application, you want to pass information from one component to another. For example, consider an application that displays a shopping list of grocery items. Each item in the list has a unique &lt;code&gt;id&lt;/code&gt;. To edit an item, users click an Edit button, which opens an &lt;code&gt;EditGroceryItem&lt;/code&gt; component. You want that component to retrieve the &lt;code&gt;id&lt;/code&gt; for the grocery item so it can display the right information to the user.</source>
          <target state="translated">종종 사용자가 애플리케이션을 탐색 할 때 한 구성 요소에서 다른 구성 요소로 정보를 전달하려고합니다. 예를 들어 식료품 항목의 쇼핑 목록을 표시하는 애플리케이션을 생각해보십시오. 목록의 각 항목에는 고유 한 &lt;code&gt;id&lt;/code&gt; 있습니다. 항목을 편집하려면 사용자는 &lt;code&gt;EditGroceryItem&lt;/code&gt; 구성 요소 를 여는 편집 단추를 클릭합니다 . 사용자 에게 올바른 정보를 표시 할 수 있도록 해당 구성 요소가 식료품 항목 의 &lt;code&gt;id&lt;/code&gt; 를 검색하기를 원합니다 .</target>
        </trans-unit>
        <trans-unit id="6a974c828df3ce86f0234cc962dac890d85796c0" translate="yes" xml:space="preserve">
          <source>Old locale id</source>
          <target state="translated">이전 로캘 ID</target>
        </trans-unit>
        <trans-unit id="1a1c62dd1450a03f009ca93d48c9895be797329d" translate="yes" xml:space="preserve">
          <source>Older browsers send page requests to the server when the location URL changes &lt;em&gt;unless&lt;/em&gt; the change occurs after a &quot;#&quot; (called the &quot;hash&quot;). Routers can take advantage of this exception by composing in-application route URLs with hashes. Here's a &quot;hash URL&quot; that routes to the &lt;em&gt;Crisis Center&lt;/em&gt;.</source>
          <target state="translated">이전 브라우저 는 &quot;#&quot;( &quot;해시&quot;라고 함) 이후에 변경이 발생 &lt;em&gt;하지 않으면&lt;/em&gt; 위치 URL이 변경 될 때 서버에 페이지 요청을 보냅니다 . 라우터는 응용 프로그램 내 라우팅 URL을 해시로 구성하여이 예외를 활용할 수 있습니다. 다음은 &lt;em&gt;Crisis Center로&lt;/em&gt; 라우팅되는 &quot;해시 URL&quot;입니다 .</target>
        </trans-unit>
        <trans-unit id="4fd2d35d4c7c88c82d5bda592619f51f5b5eda10" translate="yes" xml:space="preserve">
          <source>Older browsers send page requests to the server when the location URL changes unless the change occurs after a &quot;#&quot; (called the &quot;hash&quot;). Routers can take advantage of this exception by composing in-application route URLs with hashes. Here's a &quot;hash URL&quot; that routes to the Crisis Center.</source>
          <target state="translated">이전 브라우저는 &quot;#&quot;( &quot;해시&quot;라고 함) 뒤에 변경이 발생하지 않는 한 위치 URL이 변경 될 때 서버에 페이지 요청을 보냅니다. 라우터는 해시로 인 애플리케이션 경로 URL을 작성하여이 예외를 활용할 수 있습니다. 여기 위기 센터로 연결되는 &quot;해시 URL&quot;이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7bf167cbc746627b0166d7d071acf973da01c80" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;header&lt;/code&gt; is fine when the source of the fragment is obvious. We just said that this is a fragment of the &lt;code&gt;app.module.ts&lt;/code&gt; file which was displayed immediately above, in full, with a header. There's no need to repeat the header.</source>
          <target state="translated">조각의 출처가 분명한 경우 &lt;code&gt;header&lt;/code&gt; 생략 해도됩니다. 우리는 이것이 &lt;code&gt;app.module.ts&lt;/code&gt; 파일 의 조각이라고 말 했으며, 헤더와 함께 바로 위에 전체가 표시되었습니다. 헤더를 반복 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e6bfebc1cd263ffae5959c7c1ce56856029c45b3" translate="yes" xml:space="preserve">
          <source>Omitting the brackets renders the string &lt;code&gt;parentItem&lt;/code&gt;, not the value of &lt;code&gt;parentItem&lt;/code&gt;.</source>
          <target state="translated">괄호를 생략하면 문자열 렌더링 &lt;code&gt;parentItem&lt;/code&gt; ,하지의 값 &lt;code&gt;parentItem&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="4760b07578f04790c584723795bd92c547ce1e0d" translate="yes" xml:space="preserve">
          <source>Omitting the brackets will render the string &lt;code&gt;parentItem&lt;/code&gt;, not the value of &lt;code&gt;parentItem&lt;/code&gt;.</source>
          <target state="translated">괄호를 생략하면 문자열 렌더링 &lt;code&gt;parentItem&lt;/code&gt; 의 값이 아닌 &lt;code&gt;parentItem&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="105acb5fda378d6915b87ac3556c85450ef17416" translate="yes" xml:space="preserve">
          <source>On blur</source>
          <target state="translated">흐림</target>
        </trans-unit>
        <trans-unit id="588d59c0ad2974cf644028bc97eebdd2c225b2a3" translate="yes" xml:space="preserve">
          <source>On blur (or equivalent), your class should call the registered function to allow the forms API to update itself:</source>
          <target state="translated">흐림 (또는 동등한)에서 클래스는 등록 된 함수를 호출하여 양식 API가 자체적으로 업데이트되도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="59a5ca610dcdcc66a63d70463625356a17fb956f" translate="yes" xml:space="preserve">
          <source>On each anchor tag, you see a &lt;a href=&quot;property-binding&quot;&gt;property binding&lt;/a&gt; to the &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive&quot;&gt;RouterLinkActive&lt;/a&gt;&lt;/code&gt; directive that looks like &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive&quot;&gt;routerLinkActive&lt;/a&gt;=&quot;...&quot;&lt;/code&gt;.</source>
          <target state="translated">각 앵커 태그에, 당신은 볼 &lt;a href=&quot;property-binding&quot;&gt;속성이 바인딩을&lt;/a&gt; 받는 &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive&quot;&gt;RouterLinkActive&lt;/a&gt;&lt;/code&gt; 그 모습처럼 지시어 &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive&quot;&gt;routerLinkActive&lt;/a&gt;=&quot;...&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c3cc300b22876a2d1a6c0fc79479dd3e48948f5" translate="yes" xml:space="preserve">
          <source>On each anchor tag, you see a &lt;a href=&quot;template-syntax#property-binding&quot;&gt;property binding&lt;/a&gt; to the &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive&quot;&gt;RouterLinkActive&lt;/a&gt;&lt;/code&gt; directive that look like &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive&quot;&gt;routerLinkActive&lt;/a&gt;=&quot;...&quot;&lt;/code&gt;.</source>
          <target state="translated">각 앵커 태그에, 당신은 볼 &lt;a href=&quot;template-syntax#property-binding&quot;&gt;속성이 바인딩을&lt;/a&gt; 받는 &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive&quot;&gt;RouterLinkActive&lt;/a&gt;&lt;/code&gt; 지시 표정 같은 &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive&quot;&gt;routerLinkActive&lt;/a&gt;=&quot;...&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45078ffe0a81d3978333faab763b71dee6d9bb2d" translate="yes" xml:space="preserve">
          <source>On the &lt;code&gt;form&lt;/code&gt; tag, use an &lt;code&gt;ngSubmit&lt;/code&gt; event binding to listen for the form submission and call the &lt;code&gt;onSubmit()&lt;/code&gt; method with the &lt;code&gt;checkoutForm&lt;/code&gt; value.</source>
          <target state="translated">온 &lt;code&gt;form&lt;/code&gt; 태그, 사용 &lt;code&gt;ngSubmit&lt;/code&gt; 의 양식 제출 듣고 전화를 바인딩 이벤트 &lt;code&gt;onSubmit()&lt;/code&gt; 와 방법 &lt;code&gt;checkoutForm&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="bce75253ed75225f3fea391146a1bd210b810b5a" translate="yes" xml:space="preserve">
          <source>On the GitHub project page, configure it to &lt;a href=&quot;https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/#publishing-your-github-pages-site-from-a-docs-folder-on-your-master-branch&quot;&gt;publish from the docs folder&lt;/a&gt;.</source>
          <target state="translated">GitHub 프로젝트 페이지 &lt;a href=&quot;https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/#publishing-your-github-pages-site-from-a-docs-folder-on-your-master-branch&quot;&gt;에서 docs 폴더에서 게시&lt;/a&gt; 하도록 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ba6c65ce153f17047b9448c5c54cb5a79ea138b" translate="yes" xml:space="preserve">
          <source>On the first terminal, run the &lt;a href=&quot;cli/build&quot;&gt;&lt;code&gt;ng build&lt;/code&gt; command&lt;/a&gt; in &lt;em&gt;watch&lt;/em&gt; mode to compile the application to the &lt;code&gt;dist&lt;/code&gt; folder.</source>
          <target state="translated">첫 번째 터미널 에서 &lt;em&gt;감시&lt;/em&gt; 모드 에서 &lt;a href=&quot;cli/build&quot;&gt; &lt;code&gt;ng build&lt;/code&gt; 명령&lt;/a&gt; 을 실행 하여 응용 프로그램을 &lt;code&gt;dist&lt;/code&gt; 폴더 로 컴파일하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="47752c1f35e05bd5db3ee359b4ac43da09e4a796" translate="yes" xml:space="preserve">
          <source>On the next tick, the task to set the &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; instance value is executed.</source>
          <target state="translated">다음 틱에서 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 인스턴스 값 을 설정하는 작업 이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="cf3f308df6ab2f1567aae6a568a47bb60903252d" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;a href=&quot;https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two&quot;&gt;psychologists believe&lt;/a&gt; that humans start to struggle when the number of adjacent interesting things exceeds nine. So when a folder has ten or more files, it may be time to create subfolders.</source>
          <target state="translated">한편, &lt;a href=&quot;https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two&quot;&gt;심리학자들은&lt;/a&gt; 인접한 흥미로운 것들의 수가 9 개를 초과하면 인간이 어려움을 겪기 시작 한다고 믿습니다 . 따라서 폴더에 10 개 이상의 파일이 있으면 하위 폴더를 만들어야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dde7eb7169ccbdd8ad081e58137b9af3cf2cef5e" translate="yes" xml:space="preserve">
          <source>On the positive side, showing the element again is quick. The component's previous state is preserved and ready to display. The component doesn't re-initialize&amp;mdash;an operation that could be expensive. So hiding and showing is sometimes the right thing to do.</source>
          <target state="translated">긍정적 인 측면에서 요소를 다시 표시하는 것이 빠릅니다. 구성 요소의 이전 상태가 유지되고 표시 할 준비가되었습니다. 구성 요소는 다시 초기화되지 않으며 비용이 많이 드는 작업입니다. 따라서 숨기고 보여주는 것이 때때로 올바른 일입니다.</target>
        </trans-unit>
        <trans-unit id="8038ccc0dad229b1a3cf1eed833be0b2ac0ea190" translate="yes" xml:space="preserve">
          <source>On the right, move the &lt;code&gt;$(PATH)&lt;/code&gt; entry above the &lt;code&gt;$(DevEnvDir&lt;/code&gt;) entries. This tells Visual Studio to use the external tools (such as npm) found in the global path before using its own version of the external tools.</source>
          <target state="translated">오른쪽에서 &lt;code&gt;$(PATH)&lt;/code&gt; 항목을 &lt;code&gt;$(DevEnvDir&lt;/code&gt; ) 항목 위로 이동하십시오 . 이를 통해 Visual Studio는 자체 버전의 외부 도구를 사용하기 전에 전역 경로에있는 외부 도구 (예 : npm)를 사용하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="278c09ed5190baee2bf3aee083bd563eecb54bef" translate="yes" xml:space="preserve">
          <source>On the second terminal, install a web server (such as &lt;a href=&quot;https://github.com/johnpapa/lite-server&quot;&gt;lite-server&lt;/a&gt;), and run it against the output folder. For example:</source>
          <target state="translated">두 번째 터미널에서 웹 서버 (예 : &lt;a href=&quot;https://github.com/johnpapa/lite-server&quot;&gt;lite-server&lt;/a&gt; )를 설치하고 출력 폴더에 대해 실행하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2a183574e64873dfb0e40e4ab36cd5076c09843a" translate="yes" xml:space="preserve">
          <source>OnChanges</source>
          <target state="translated">OnChanges</target>
        </trans-unit>
        <trans-unit id="9d34c39bf776e320711c925c3b5f2ad48e75d5fd" translate="yes" xml:space="preserve">
          <source>OnDestroy</source>
          <target state="translated">OnDestroy</target>
        </trans-unit>
        <trans-unit id="cb2b8c8bff23f0b5284bd4f85d2c9e04b704d932" translate="yes" xml:space="preserve">
          <source>OnInit</source>
          <target state="translated">OnInit</target>
        </trans-unit>
        <trans-unit id="95acf127018688ca75dbc54f96c64b42301bcd48" translate="yes" xml:space="preserve">
          <source>Once data arrives, you could push their raw &lt;code&gt;toString&lt;/code&gt; values directly to the view, but that rarely makes for a good user experience. For example, in most use cases, users prefer to see a date in a simple format like</source>
          <target state="translated">데이터가 도착하면 원시 &lt;code&gt;toString&lt;/code&gt; 값을 뷰로 직접 푸시 할 수 있지만 사용자 환경이 좋지 않습니다. 예를 들어 대부분의 사용 사례에서 사용자는 날짜를 간단한 형식으로 보는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="dbc9b4b1e5f7c2efd3f7952edf2b5e8ee385e053" translate="yes" xml:space="preserve">
          <source>Once deployed, visit &lt;a href=&quot;https://your-firebase-project-name.firebaseapp.com&quot;&gt;https://your-firebase-project-name.firebaseapp.com&lt;/a&gt; to see it live!</source>
          <target state="translated">배포되면 &lt;a href=&quot;https://your-firebase-project-name.firebaseapp.com&quot;&gt;https://your-firebase-project-name.firebaseapp.com&lt;/a&gt; 을 방문 하여 실시간으로 확인하십시오!</target>
        </trans-unit>
        <trans-unit id="327e2bf497d4756dd8b46b905bd1bc8bc1d4a344" translate="yes" xml:space="preserve">
          <source>Once done, you can load SystemJS and other dependencies, and also switch the configuration for loading application files so that they are &lt;em&gt;not&lt;/em&gt; included to the page by Karma. You'll let the shim and SystemJS load them.</source>
          <target state="translated">완료되면 SystemJS 및 기타 종속성을로드 하고 Karma가 페이지에 포함 &lt;em&gt;하지&lt;/em&gt; 않도록 애플리케이션 파일을로드하기위한 구성을 전환 할 수 있습니다 . shim과 SystemJS가로드하도록합니다.</target>
        </trans-unit>
        <trans-unit id="515a285ae6999eab70e56bb9b650918ca621d734" translate="yes" xml:space="preserve">
          <source>Once included, the CLI will include the stylesheet, whether the link tag's href URL is relative to the application root or the component file.</source>
          <target state="translated">포함 된 CLI는 링크 태그의 href URL이 응용 프로그램 루트 또는 구성 요소 파일과 관련이 있는지 여부에 관계없이 스타일 시트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="bcb755436e7abaa27cacec9ff4b8b8405a381078" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;ForbiddenValidatorDirective&lt;/code&gt; is ready, you can add its selector, &lt;code&gt;appForbiddenName&lt;/code&gt;, to any input element to activate it. For example:</source>
          <target state="translated">&lt;code&gt;ForbiddenValidatorDirective&lt;/code&gt; 가 준비 되면 선택기 &lt;code&gt;appForbiddenName&lt;/code&gt; 을 입력 요소에 추가하여 활성화 할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="be979100be0f130068c6ce22440c04aade32c248" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;ForbiddenValidatorDirective&lt;/code&gt; is ready, you can simply add its selector, &lt;code&gt;appForbiddenName&lt;/code&gt;, to any input element to activate it. For example:</source>
          <target state="translated">&lt;code&gt;ForbiddenValidatorDirective&lt;/code&gt; 가 준비 되면 선택기 &lt;code&gt;appForbiddenName&lt;/code&gt; 을 입력 요소에 추가하여 활성화 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fa30d75339e67b98b3d75fc951ba0ee759735569" translate="yes" xml:space="preserve">
          <source>Once the app warms up, you'll see a row of navigation buttons and the &lt;em&gt;Heroes&lt;/em&gt; view with its list of heroes.</source>
          <target state="translated">앱이 예열되면 탐색 버튼 이 열리고 영웅 목록이 있는 &lt;em&gt;영웅&lt;/em&gt; 보기가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e725771e0112c25987b195dd04b711e9be88c11a" translate="yes" xml:space="preserve">
          <source>Once the application loads the initial route, the &lt;code&gt;CrisisCenterModule&lt;/code&gt; is preloaded. Verify this by logging in to the &lt;code&gt;Admin&lt;/code&gt; feature area and noting that the &lt;code&gt;crisis-center&lt;/code&gt; is listed in the &lt;code&gt;Preloaded Modules&lt;/code&gt;. It also logs to the browser's console.</source>
          <target state="translated">애플리케이션이 초기 경로를로드하면 &lt;code&gt;CrisisCenterModule&lt;/code&gt; 이 미리로드됩니다. &lt;code&gt;Admin&lt;/code&gt; 기능 영역 에 로그인 하고 &lt;code&gt;crisis-center&lt;/code&gt; 가 &lt;code&gt;Preloaded Modules&lt;/code&gt; 나열되어 있는지 확인하여이를 확인합니다 . 또한 브라우저의 콘솔에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="7afe0d112e482623769881f408f2b0ec643e2bf4" translate="yes" xml:space="preserve">
          <source>Once the application loads the initial route, the &lt;code&gt;CrisisCenterModule&lt;/code&gt; is preloaded. Verify this by logging in to the &lt;code&gt;Admin&lt;/code&gt; feature area and noting that the &lt;code&gt;crisis-center&lt;/code&gt; is listed in the &lt;code&gt;Preloaded Modules&lt;/code&gt;. It's also logged to the browser's console.</source>
          <target state="translated">응용 프로그램이 초기 경로를로드하면 &lt;code&gt;CrisisCenterModule&lt;/code&gt; 이 미리로드됩니다. &lt;code&gt;Admin&lt;/code&gt; 기능 영역 에 로그인 하고 &lt;code&gt;crisis-center&lt;/code&gt; 가 &lt;code&gt;Preloaded Modules&lt;/code&gt; 나열되어 있는지 확인하여이를 확인하십시오 . 브라우저의 콘솔에도 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="db1af027d419b436654d11f55fd681c8e43c8355" translate="yes" xml:space="preserve">
          <source>Once the network request completes, update the cache for future requests.</source>
          <target state="translated">네트워크 요청이 완료되면 향후 요청을 위해 캐시를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="0ff45c4702b7e2b1b69b310c107de6727e84ae7a" translate="yes" xml:space="preserve">
          <source>Once the package is installed, add the following to the &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; section of your project's &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="translated">패키지가 설치되면 프로젝트 &lt;code&gt;tsconfig.json&lt;/code&gt; 의 &lt;code&gt;&quot;compilerOptions&quot;&lt;/code&gt; 섹션에 다음을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="c231f7af231bb23e243ffe3f2f118fe7793497d8" translate="yes" xml:space="preserve">
          <source>Once these are done, run:</source>
          <target state="translated">완료되면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8ca78a6950503a5d3df5151e13211842557a6954" translate="yes" xml:space="preserve">
          <source>Once this is done we can get hold of services via the Angular &lt;code&gt;&lt;a href=&quot;../../../core/injector&quot;&gt;Injector&lt;/a&gt;&lt;/code&gt; as normal. Services that are (or have dependencies on) an upgraded AngularJS service, will be instantiated as needed by the AngularJS &lt;code&gt;$injector&lt;/code&gt;.</source>
          <target state="translated">이 작업이 완료되면 Angular &lt;code&gt;&lt;a href=&quot;../../../core/injector&quot;&gt;Injector&lt;/a&gt;&lt;/code&gt; 를 통해 정상적으로 서비스를받을 수 있습니다 . 업그레이드 된 AngularJS 서비스 인 (또는 종속성이있는) 서비스는 AngularJS &lt;code&gt;$injector&lt;/code&gt; 의해 필요에 따라 인스턴스화됩니다 .</target>
        </trans-unit>
        <trans-unit id="bab093e960e981510826adeb3fd471f0884f6381" translate="yes" xml:space="preserve">
          <source>Once this is done we can get hold of services via the Angular &lt;code&gt;&lt;a href=&quot;../../../core/injector&quot;&gt;Injector&lt;/a&gt;&lt;/code&gt; as normal. Services that are (or have dependencies on) an upgraded AngularJS service, will be instantiated as needed by the AngularJS &lt;code&gt;&lt;a href=&quot;../upgrademodule#%24injector&quot;&gt;$injector&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 작업이 완료되면 Angular &lt;code&gt;&lt;a href=&quot;../../../core/injector&quot;&gt;Injector&lt;/a&gt;&lt;/code&gt; 를 통해 정상적으로 서비스를 유지할 수 있습니다 . 업그레이드 된 AngularJS 서비스 인 (또는 의존하는) 서비스는 AngularJS &lt;code&gt;&lt;a href=&quot;../upgrademodule#%24injector&quot;&gt;$injector&lt;/a&gt;&lt;/code&gt; 의해 필요에 따라 인스턴스화됩니다 .</target>
        </trans-unit>
        <trans-unit id="525ba2620a79d64e9a8f50cede00c6c216d77769" translate="yes" xml:space="preserve">
          <source>Once this is done we can get hold of services via the AngularJS &lt;code&gt;$injector&lt;/code&gt; as normal. Services that are (or have dependencies on) a downgraded Angular service, will be instantiated as needed by the Angular root &lt;code&gt;&lt;a href=&quot;../../../core/injector&quot;&gt;Injector&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 작업이 완료되면 AngularJS &lt;code&gt;$injector&lt;/code&gt; 를 통해 정상적으로 서비스를받을 수 있습니다 . 다운 그레이드 된 Angular 서비스 인 (또는 종속성이있는) 서비스는 Angular 루트 &lt;code&gt;&lt;a href=&quot;../../../core/injector&quot;&gt;Injector&lt;/a&gt;&lt;/code&gt; 에서 필요에 따라 인스턴스화됩니다 .</target>
        </trans-unit>
        <trans-unit id="a289b477923250939e59f73b39cbad472ba133be" translate="yes" xml:space="preserve">
          <source>Once this is done we can get hold of services via the AngularJS &lt;code&gt;&lt;a href=&quot;../upgrademodule#%24injector&quot;&gt;$injector&lt;/a&gt;&lt;/code&gt; as normal. Services that are (or have dependencies on) a downgraded Angular service, will be instantiated as needed by the Angular root &lt;code&gt;&lt;a href=&quot;../../../core/injector&quot;&gt;Injector&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 작업이 완료되면 AngularJS &lt;code&gt;&lt;a href=&quot;../upgrademodule#%24injector&quot;&gt;$injector&lt;/a&gt;&lt;/code&gt; 를 통해 서비스를 정상적으로 유지할 수 있습니다 . 다운 그레이드 된 Angular 서비스이거나 의존하는 서비스는 Angular root &lt;code&gt;&lt;a href=&quot;../../../core/injector&quot;&gt;Injector&lt;/a&gt;&lt;/code&gt; 가 필요에 따라 인스턴스화됩니다 .</target>
        </trans-unit>
        <trans-unit id="0fb5c4848901bb0899c2dafc5cc3eabd8794504c" translate="yes" xml:space="preserve">
          <source>Once you have the source code downloaded and unzipped, install &lt;code&gt;Node.js&lt;/code&gt; and serve your app with the Angular CLI.</source>
          <target state="translated">소스 코드를 다운로드하고 압축을 푼 후 &lt;code&gt;Node.js&lt;/code&gt; 를 설치 하고 Angular CLI로 앱을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="20b9175c244a12b84f5bd15eed125eb5c0f3bcda" translate="yes" xml:space="preserve">
          <source>Once you have the source code downloaded and unzipped, use the &lt;a href=&quot;https://angularconsole.com&quot;&gt;Angular Console&lt;/a&gt; to serve the application, or you install &lt;code&gt;Node.js&lt;/code&gt; and have the Angular CLI installed.</source>
          <target state="translated">소스 코드를 다운로드하여 압축을 풀면 &lt;a href=&quot;https://angularconsole.com&quot;&gt;Angular Console&lt;/a&gt; 을 사용하여 응용 프로그램을 제공하거나 &lt;code&gt;Node.js&lt;/code&gt; 를 설치 하고 Angular CLI를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="e30ba625ee999d939a41ca3dd591e3de71f57409" translate="yes" xml:space="preserve">
          <source>Once you import a library using the &quot;scripts&quot; array, you should &lt;strong&gt;not&lt;/strong&gt; import it using an import statement in your TypeScript code (such as &lt;code&gt;import * as $ from 'jquery';&lt;/code&gt;). If you do, you'll end up with two different copies of the library: one imported as a global library, and one imported as a module. This is especially bad for libraries with plugins, like JQuery, because each copy will have different plugins.</source>
          <target state="translated">당신이 &quot;스크립트&quot;배열을 사용하여 라이브러리를 가져 오면, 당신은해야 &lt;strong&gt;하지&lt;/strong&gt; (예 : 당신의 타이프 코드에서 import 문을 사용하여 가져 오기 &lt;code&gt;import * as $ from 'jquery';&lt;/code&gt; ). 그렇게하면 두 개의 다른 라이브러리 사본이 생길 것입니다. 하나는 글로벌 라이브러리로 가져온 것과 다른 하나는 모듈로 가져온 것입니다. 각 사본마다 플러그인이 다르기 때문에 JQuery와 같은 플러그인이있는 라이브러리에는 특히 나쁩니다.</target>
        </trans-unit>
        <trans-unit id="1d66884cd418d38436558a48d6c0b2f3a74b4d00" translate="yes" xml:space="preserve">
          <source>Once you introduce the Angular Router, using the Angular Router triggers navigations through the unified location service, still providing a single source for navigating with AngularJS and Angular.</source>
          <target state="translated">Angular Router를 도입 한 후에 Angular Router를 사용하면 통합 위치 서비스를 통해 탐색이 트리거되고 AngularJS 및 Angular를 탐색 할 수있는 단일 소스가 계속 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ee023cd0dabed619dfa80fc59fd42f6a58a8470a" translate="yes" xml:space="preserve">
          <source>Once you start the upgrade process and bring in SystemJS, configuration changes are needed for Karma. You need to let SystemJS load all the new Angular code, which can be done with the following kind of shim file:</source>
          <target state="translated">업그레이드 프로세스를 시작하고 SystemJS를 가져 오면 Karma에 대한 구성 변경이 필요합니다. 다음과 같은 shim 파일을 사용하여 SystemJS가 모든 새 Angular 코드를로드하도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="092473dca34a9d2cc876a77d26a67e1896159e42" translate="yes" xml:space="preserve">
          <source>Once you're running a hybrid app, you can start the gradual process of upgrading code. One of the more common patterns for doing that is to use an Angular component in an AngularJS context. This could be a completely new component or one that was previously AngularJS but has been rewritten for Angular.</source>
          <target state="translated">하이브리드 앱을 실행하면 점진적으로 코드 업그레이드 프로세스를 시작할 수 있습니다. 가장 일반적인 패턴 중 하나는 AngularJS 컨텍스트에서 Angular 구성 요소를 사용하는 것입니다. 이것은 완전히 새로운 구성 요소이거나 이전에 AngularJS 였지만 Angular 용으로 다시 작성된 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd7a98f13e48be54bf5eaab3ea48f2d471fc1382" translate="yes" xml:space="preserve">
          <source>One &lt;code&gt;#docregion&lt;/code&gt; comment mentions &lt;strong&gt;&lt;em&gt;two&lt;/em&gt;&lt;/strong&gt; region names as does an &lt;code&gt;#enddocregion&lt;/code&gt; comment. This is a convenient way to start (or stop) multiple regions on the same code line. You could have put these comments on separate lines and many authors prefer to do so.</source>
          <target state="translated">한 &lt;code&gt;#docregion&lt;/code&gt; 의 의견은 언급 &lt;strong&gt;&lt;em&gt;이&lt;/em&gt;&lt;/strong&gt; 처럼 지역 이름을 &lt;code&gt;#enddocregion&lt;/code&gt; 의 코멘트를. 이것은 동일한 코드 라인에서 여러 영역을 시작 (또는 중지)하는 편리한 방법입니다. 이 주석을 별도의 줄에 넣을 수 있으며 많은 저자가 그렇게 선호합니다.</target>
        </trans-unit>
        <trans-unit id="8ac08bd7d3b020ac62f793bae708a96397cd94c4" translate="yes" xml:space="preserve">
          <source>One alternative is to provide and inject the configuration object in an NgModule like &lt;code&gt;AppModule&lt;/code&gt;.</source>
          <target state="translated">하나의 대안은 &lt;code&gt;AppModule&lt;/code&gt; 과 같은 NgModule에 구성 오브젝트를 제공하고 주입하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="87135e35d744d977c20d6f84a74947e0d0ebccf8" translate="yes" xml:space="preserve">
          <source>One approach is to configure the testing module from the individual pieces as in this example:</source>
          <target state="translated">한 가지 방법은이 예제와 같이 개별 부분에서 테스트 모듈을 구성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5fe1a5bfbd76c9b1017d3107c26a761463dc1042" translate="yes" xml:space="preserve">
          <source>One approach is to dedicate a folder to localization and store related assets, such as internationalization files, there.</source>
          <target state="translated">한 가지 방법은 폴더를 지역화 전용으로 지정하고 국제화 파일과 같은 관련 자산을 저장하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7200dfd4929de965d1957e81038031eddafa439a" translate="yes" xml:space="preserve">
          <source>One important assertion this disables verifies that a change detection pass does not result in additional changes to any bindings (also known as unidirectional data flow).</source>
          <target state="translated">이를 비활성화하는 한 가지 중요한 주장은 변경 감지 패스가 바인딩 (단방향 데이터 흐름이라고도 함)에 대한 추가 변경을 초래하지 않는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="65845d985000af3d6718bb9d79cd3a31684a2820" translate="yes" xml:space="preserve">
          <source>One of &quot;application&quot; or &quot;library&quot;. An application can run independently in a browser, while a library cannot.</source>
          <target state="translated">&quot;응용 프로그램&quot;또는 &quot;라이브러리&quot;중 하나입니다. 라이브러리에서는 응용 프로그램을 브라우저에서 독립적으로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fb8337f3d8781cba55e079191d8a366b930d1b0" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;enabled&lt;/code&gt; or &lt;code&gt;disabled&lt;/code&gt;. When set to &lt;code&gt;enabled&lt;/code&gt;, the initial navigation starts before the root component is created. The bootstrap is blocked until the initial navigation is complete. This value is required for &lt;a href=&quot;../../guide/universal&quot;&gt;server-side rendering&lt;/a&gt; to work. When set to &lt;code&gt;disabled&lt;/code&gt;, the initial navigation is not performed. The location listener is set up before the root component gets created. Use if there is a reason to have more control over when the router starts its initial navigation due to some complex initialization logic.</source>
          <target state="translated">&lt;code&gt;enabled&lt;/code&gt; 또는 &lt;code&gt;disabled&lt;/code&gt; 중 하나입니다 . &lt;code&gt;enabled&lt;/code&gt; 로 설정 하면 루트 구성 요소가 작성되기 전에 초기 탐색이 시작됩니다. 초기 탐색이 완료 될 때까지 부트 스트랩이 차단됩니다. 이 값은 &lt;a href=&quot;../../guide/universal&quot;&gt;서버 측 렌더링&lt;/a&gt; 이 작동하는 데 필요 합니다. &lt;code&gt;disabled&lt;/code&gt; 로 설정 하면 초기 탐색이 수행되지 않습니다. 위치 리스너는 루트 컴포넌트가 작성되기 전에 설정됩니다. 복잡한 초기화 로직으로 인해 라우터가 초기 탐색을 시작할 때 더 많은 제어 권한을 가질 이유가있는 경우 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="74847a2fb095301eab900b1f4bd833d7e7eef112" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;enabled&lt;/code&gt;, &lt;code&gt;enabledBlocking&lt;/code&gt;, &lt;code&gt;enabledNonBlocking&lt;/code&gt; or &lt;code&gt;disabled&lt;/code&gt;. When set to &lt;code&gt;enabled&lt;/code&gt; or &lt;code&gt;enabledBlocking&lt;/code&gt;, the initial navigation starts before the root component is created. The bootstrap is blocked until the initial navigation is complete. This value is required for &lt;a href=&quot;../../guide/universal&quot;&gt;server-side rendering&lt;/a&gt; to work. When set to &lt;code&gt;enabledNonBlocking&lt;/code&gt;, the initial navigation starts after the root component has been created. The bootstrap is not blocked on the completion of the initial navigation. When set to &lt;code&gt;disabled&lt;/code&gt;, the initial navigation is not performed. The location listener is set up before the root component gets created. Use if there is a reason to have more control over when the router starts its initial navigation due to some complex initialization logic.</source>
          <target state="translated">&lt;code&gt;enabled&lt;/code&gt; , &lt;code&gt;enabledBlocking&lt;/code&gt; , &lt;code&gt;enabledNonBlocking&lt;/code&gt; 또는 &lt;code&gt;disabled&lt;/code&gt; 중 하나입니다 . &lt;code&gt;enabled&lt;/code&gt; 또는 &lt;code&gt;enabledBlocking&lt;/code&gt; 으로 설정 하면 루트 구성 요소가 생성되기 전에 초기 탐색이 시작됩니다. 초기 탐색이 완료 될 때까지 부트 스트랩이 차단됩니다. 이 값은 &lt;a href=&quot;../../guide/universal&quot;&gt;서버 측 렌더링&lt;/a&gt; 이 작동하는 데 필요 합니다. &lt;code&gt;enabledNonBlocking&lt;/code&gt; 으로 설정 하면 루트 구성 요소가 생성 된 후 초기 탐색이 시작됩니다. 초기 탐색 완료시 부트 스트랩이 차단되지 않습니다. &lt;code&gt;disabled&lt;/code&gt; 로 설정된 경우, 초기 탐색이 수행되지 않습니다. 위치 수신기는 루트 구성 요소가 생성되기 전에 설정됩니다. 복잡한 초기화 논리로 인해 라우터가 초기 탐색을 시작할 때 더 많은 제어 권한이 필요한 경우 사용합니다.</target>
        </trans-unit>
        <trans-unit id="dd44bf9e00df7f056b06f5764807296f3f73b52c" translate="yes" xml:space="preserve">
          <source>One of the Angular compiler's most helpful features is the ability to type-check expressions within templates, and catch any errors before they cause crashes at runtime. In the template type-checking phase, the Angular template compiler uses the TypeScript compiler to validate the binding expressions in templates.</source>
          <target state="translated">Angular 컴파일러의 가장 유용한 기능 중 하나는 템플릿 내에서 표현식을 유형 검사하고 런타임에 충돌을 일으키기 전에 오류를 포착하는 기능입니다. 템플릿 유형 검사 단계에서 Angular 템플릿 컴파일러는 TypeScript 컴파일러를 사용하여 템플릿의 바인딩 식을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a6c04af86844f30e490ab3f542226d29b027b666" translate="yes" xml:space="preserve">
          <source>One of the best ways to keep your project bug free is through a test suite, but it's easy to forget to run tests all the time. Continuous integration (CI) servers let you set up your project repository so that your tests run on every commit and pull request.</source>
          <target state="translated">프로젝트 버그를 없애는 가장 좋은 방법 중 하나는 테스트 스위트를 사용하는 것이지만 테스트를 항상 실행하는 것을 잊어 버리기 쉽습니다. CI (Continuous Integration) 서버를 사용하면 모든 커밋 및 풀 요청에서 테스트를 실행할 수 있도록 프로젝트 저장소를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2df44dbf1904684ff1baf00aaa5092c07824864" translate="yes" xml:space="preserve">
          <source>One of the best ways to keep your project bug-free is through a test suite, but it's easy to forget to run tests all the time. Continuous integration (CI) servers let you set up your project repository so that your tests run on every commit and pull request.</source>
          <target state="translated">프로젝트를 버그없는 상태로 유지하는 가장 좋은 방법 중 하나는 테스트 스위트를 사용하는 것이지만 항상 테스트를 실행하는 것을 잊기 쉽습니다. CI (지속적 통합) 서버를 사용하면 모든 커밋 및 풀 요청에서 테스트가 실행되도록 프로젝트 저장소를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7652911aa9bead58c24b042fdf387cb71098df8e" translate="yes" xml:space="preserve">
          <source>One of the documentation design goals is that guide page code snippets should be examples of real, working code.</source>
          <target state="translated">문서 디자인 목표 중 하나는 가이드 페이지 코드 스 니펫이 실제 작동 코드의 예 여야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="edf6d16acb64bc01a6c63397cc7093717e206bbb" translate="yes" xml:space="preserve">
          <source>One of the easiest ways to get your site live is to host it using Firebase.</source>
          <target state="translated">사이트를 활성화하는 가장 쉬운 방법 중 하나는 Firebase를 사용하여 사이트를 호스팅하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1ee15e3b19e2a210511409a92e03792bca31bb83" translate="yes" xml:space="preserve">
          <source>One of the keys to a successful upgrade is to do it incrementally, by running the two frameworks side by side in the same application, and porting AngularJS components to Angular one by one. This makes it possible to upgrade even large and complex applications without disrupting other business, because the work can be done collaboratively and spread over a period of time. The &lt;code&gt;upgrade&lt;/code&gt; module in Angular has been designed to make incremental upgrading seamless.</source>
          <target state="translated">성공적인 업그레이드의 핵심 중 하나는 동일한 응용 프로그램에서 두 프레임 워크를 나란히 실행하고 AngularJS 구성 요소를 하나씩 Angular로 포팅하여 점진적으로 수행하는 것입니다. 따라서 다른 비즈니스를 방해하지 않으면 서 크고 복잡한 응용 프로그램을 업그레이드 할 수 있습니다. 작업은 일정 기간 동안 공동 작업을 수행하고 분산시킬 수 있기 때문입니다. Angular 의 &lt;code&gt;upgrade&lt;/code&gt; 모듈은 증분 업그레이드를 원활하게 수행하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="d321b4c2f612d92d87ff9ca870c2d0c179cdda08" translate="yes" xml:space="preserve">
          <source>One of the potential side effects of long caching is inadvertently caching an invalid resource. In a normal HTTP cache, a hard refresh or cache expiration limits the negative effects of caching an invalid file. A service worker ignores such constraints and effectively long caches the entire app. Consequently, it is essential that the service worker gets the correct content.</source>
          <target state="translated">긴 캐싱의 잠재적 인 부작용 중 하나는 부적절하게 유효하지 않은 자원을 캐싱하는 것입니다. 일반 HTTP 캐시에서 하드 새로 고침 또는 캐시 만료는 유효하지 않은 파일 캐싱의 부정적인 영향을 제한합니다. 서비스 워커는 이러한 제약 조건을 무시하고 전체 앱을 효과적으로 캐시합니다. 따라서 서비스 담당자가 올바른 컨텐츠를 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="39157ef46c453ad66cda0bcf9fdbe691e4af8017" translate="yes" xml:space="preserve">
          <source>One of the primary tools provided by ngUpgrade is called the &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt;. This is a module that contains utilities for bootstrapping and managing hybrid applications that support both Angular and AngularJS code.</source>
          <target state="translated">ngUpgrade가 제공하는 기본 도구 중 하나는 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 입니다. 이것은 Angular 및 AngularJS 코드를 모두 지원하는 하이브리드 애플리케이션을 부트 스트랩 및 관리하기위한 유틸리티를 포함하는 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="026249664bc8e8d6d2e8f156fab107887e23bd3a" translate="yes" xml:space="preserve">
          <source>One of the primary use cases for attribute binding is to set ARIA attributes, as in this example:</source>
          <target state="translated">속성 바인딩의 주요 사용 사례 중 하나는 다음 예와 같이 ARIA 속성을 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="04d0227058c93fedaf8acb513731b3d16375f926" translate="yes" xml:space="preserve">
          <source>One of these reference is in the &lt;em&gt;type position&lt;/em&gt;-- that is, it specifies &lt;code&gt;LibHeaderComponent&lt;/code&gt; as a type: &lt;code&gt;header: LibHeaderComponent;&lt;/code&gt;.</source>
          <target state="translated">이러한 참조 중 하나는 &lt;em&gt;유형 위치에 있습니다&lt;/em&gt; . 즉, &lt;code&gt;LibHeaderComponent&lt;/code&gt; 를 유형으로 지정 합니다. &lt;code&gt;header: LibHeaderComponent;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="056e56859c6f8ed9c98ae3e52da17afff459b25f" translate="yes" xml:space="preserve">
          <source>One or more animation &lt;code&gt;&lt;a href=&quot;../animations/trigger&quot;&gt;trigger&lt;/a&gt;()&lt;/code&gt; calls, containing &lt;code&gt;&lt;a href=&quot;../animations/state&quot;&gt;state&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../animations/transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; definitions. See the &lt;a href=&quot;../../guide/animations&quot;&gt;Animations guide&lt;/a&gt; and animations API documentation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../animations/state&quot;&gt;state&lt;/a&gt;()&lt;/code&gt; () 및 &lt;code&gt;&lt;a href=&quot;../animations/transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; () 정의를 포함하는 하나 이상의 애니메이션 &lt;code&gt;&lt;a href=&quot;../animations/trigger&quot;&gt;trigger&lt;/a&gt;()&lt;/code&gt; 호출 . &lt;a href=&quot;../../guide/animations&quot;&gt;애니메이션 가이드&lt;/a&gt; 및 애니메이션 API 문서를 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="afe0dd72b9bf1774a092f344805f3e7ef7abc41b" translate="yes" xml:space="preserve">
          <source>One or more animation &lt;code&gt;&lt;a href=&quot;../animations/trigger&quot;&gt;trigger&lt;/a&gt;()&lt;/code&gt; calls, containing &lt;code&gt;&lt;a href=&quot;../common/upgrade/%24locationshim#state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../animations/transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; definitions. See the &lt;a href=&quot;../../guide/animations&quot;&gt;Animations guide&lt;/a&gt; and animations API documentation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../common/upgrade/%24locationshim#state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../animations/transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; () 정의를 포함하는 하나 이상의 애니메이션 &lt;code&gt;&lt;a href=&quot;../animations/trigger&quot;&gt;trigger&lt;/a&gt;()&lt;/code&gt; 호출 . &lt;a href=&quot;../../guide/animations&quot;&gt;애니메이션 가이드&lt;/a&gt; 및 애니메이션 API 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="823e563bcdba98c7d6093dcfc55a78207defc67c" translate="yes" xml:space="preserve">
          <source>One or more animation objects to which this transition applies.</source>
          <target state="translated">이 전환이 적용되는 하나 이상의 애니메이션 객체.</target>
        </trans-unit>
        <trans-unit id="da759f83f6bf9b8c9d78c28d5e9f2fa981792d78" translate="yes" xml:space="preserve">
          <source>One or more animation objects, as returned by the &lt;code&gt;&lt;a href=&quot;animate&quot;&gt;animate&lt;/a&gt;()&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;sequence&quot;&gt;sequence&lt;/a&gt;()&lt;/code&gt; function, that form a transformation from one state to another. A sequence is used by default when you pass an array.</source>
          <target state="translated">하나의 상태에서 다른 상태로의 변환을 형성하는 &lt;code&gt;&lt;a href=&quot;animate&quot;&gt;animate&lt;/a&gt;()&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;sequence&quot;&gt;sequence&lt;/a&gt;()&lt;/code&gt; 함수에 의해 반환되는 하나 이상의 애니메이션 객체 . 배열을 전달할 때 기본적으로 시퀀스가 ​​사용됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
