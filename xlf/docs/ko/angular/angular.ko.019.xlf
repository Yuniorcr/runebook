<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="angular">
    <body>
      <group id="angular">
        <trans-unit id="8fcc9eb0d01cd2af8a401bb5fbad0ceddd4ebbd6" translate="yes" xml:space="preserve">
          <source>Useful tools and tips for Angular.</source>
          <target state="translated">Angular에 유용한 도구 및 팁.</target>
        </trans-unit>
        <trans-unit id="0b75d4ee12567b39421e5cdafacb9fdac3567042" translate="yes" xml:space="preserve">
          <source>User Input</source>
          <target state="translated">사용자 입력</target>
        </trans-unit>
        <trans-unit id="602a8dcdba61fe963a2ee0eabfa7c6c12caef58a" translate="yes" xml:space="preserve">
          <source>User actions such as clicking a link, pushing a button, and entering text raise DOM events. This page explains how to bind those events to component event handlers using the Angular event binding syntax.</source>
          <target state="translated">링크 클릭, 버튼 누르기 및 텍스트 입력과 같은 사용자 작업은 DOM 이벤트를 발생시킵니다. 이 페이지에서는 Angular 이벤트 바인딩 구문을 사용하여 해당 이벤트를 구성 요소 이벤트 핸들러에 바인딩하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="058b267dc9414eb566cadb188507382a9127c368" translate="yes" xml:space="preserve">
          <source>User events other than &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;routerLink&lt;/a&gt;&lt;/code&gt; clicks aren't supported. You must wait for the full client app to bootstrap and run, or buffer the events using libraries like &lt;a href=&quot;https://github.com/angular/preboot&quot;&gt;preboot&lt;/a&gt;, which allow you to replay these events once the client-side scripts load.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;routerLink&lt;/a&gt;&lt;/code&gt; 클릭 이외의 사용자 이벤트 는 지원되지 않습니다. 클라이언트 측 스크립트가로드되면 이러한 이벤트를 재생할 수있는 &lt;a href=&quot;https://github.com/angular/preboot&quot;&gt;preboot&lt;/a&gt; 와 같은 라이브러리를 사용하여 전체 클라이언트 앱이 부트 스트랩 및 실행을 기다리거나 이벤트를 버퍼링해야합니다 .</target>
        </trans-unit>
        <trans-unit id="09099af5b046928eebce82ffe20cae42387454fa" translate="yes" xml:space="preserve">
          <source>User input</source>
          <target state="translated">사용자 입력</target>
        </trans-unit>
        <trans-unit id="5141e17357a02f63be66086ece12a9f2d302df1e" translate="yes" xml:space="preserve">
          <source>Users can add, edit, and delete heroes and save these changes over HTTP.</source>
          <target state="translated">사용자는 영웅을 추가, 편집 및 삭제하고 HTTP를 통해 이러한 변경 사항을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffb71aafecac3c94302931b31f63e1168c9b1166" translate="yes" xml:space="preserve">
          <source>Users can click on a product name from the list to see details in a new view, with a distinct URL (route)</source>
          <target state="translated">사용자는 목록에서 제품 이름을 클릭하여 고유 한 URL (경로)을 사용하여 새보기에서 세부 사항을 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9915fd34b105ae0d8f9b856eaf8cca5ea09bd3cd" translate="yes" xml:space="preserve">
          <source>Users can click on a product name from the list to see details in a new view, with a distinct URL/route.</source>
          <target state="translated">사용자는 목록에서 제품 이름을 클릭하여 고유 한 URL / 경로를 사용하여 새보기에서 세부 정보를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6701a88f4173410a6b0358f016f5ca47cd5c83bc" translate="yes" xml:space="preserve">
          <source>Users can opt in to share their Angular CLI usage data with &lt;a href=&quot;https://support.google.com/analytics/answer/1008015?hl=en&quot;&gt;Google Analytics&lt;/a&gt;, using the &lt;a href=&quot;https://angular.io/cli/analytics&quot;&gt;&lt;code&gt;ng analytics&lt;/code&gt; CLI command&lt;/a&gt;. The data is also shared with the Angular team, and used to improve the CLI.</source>
          <target state="translated">사용자는 &lt;a href=&quot;https://angular.io/cli/analytics&quot;&gt; &lt;code&gt;ng analytics&lt;/code&gt; &lt;/a&gt; CLI 명령을 사용하여 Angular CLI 사용 데이터를 &lt;a href=&quot;https://support.google.com/analytics/answer/1008015?hl=en&quot;&gt;Google Analytics&lt;/a&gt; 와 공유하도록 선택할 수 있습니다 . 데이터는 Angular 팀과 공유되며 CLI를 개선하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9f300cd0d7b9a4b1286d7eb15eb10210c5e6bec6" translate="yes" xml:space="preserve">
          <source>Users can search for heroes by name.</source>
          <target state="translated">사용자는 이름으로 영웅을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e75567a342e40c9e2e644d8dc12675b4ec829db5" translate="yes" xml:space="preserve">
          <source>Users should be able to edit the hero name in an &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; textbox.</source>
          <target state="translated">사용자는 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 텍스트 상자 에서 영웅 이름을 편집 할 수 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="7b3840d786e1f73b113066b49ab864de5ce34535" translate="yes" xml:space="preserve">
          <source>Users that visit your URL will see a development server start up, and then your application will load.</source>
          <target state="translated">URL을 방문하는 사용자에게는 개발 서버가 시작된 다음 응용 프로그램이로드됩니다.</target>
        </trans-unit>
        <trans-unit id="39302b04bcbaac9bc8c1d2667096f87cf5896e04" translate="yes" xml:space="preserve">
          <source>Users update crisis information in the &lt;code&gt;CrisisDetailComponent&lt;/code&gt;. Unlike the &lt;code&gt;HeroDetailComponent&lt;/code&gt;, the user changes do not update the crisis entity immediately. Instead, the app updates the entity when the user presses the &lt;em&gt;Save&lt;/em&gt; button and discards the changes when the user presses the &lt;em&gt;Cancel&lt;/em&gt; button.</source>
          <target state="translated">사용자는 &lt;code&gt;CrisisDetailComponent&lt;/code&gt; 에서 위기 정보를 업데이트합니다 . &lt;code&gt;HeroDetailComponent&lt;/code&gt; 와 달리 사용자 변경 사항은 위기 엔티티를 즉시 업데이트하지 않습니다. 대신 사용자가 &lt;em&gt;저장&lt;/em&gt; 버튼을 누르면 앱이 엔티티를 업데이트 하고 사용자가 &lt;em&gt;취소&lt;/em&gt; 버튼을 누르면 변경 사항을 버립니다 .</target>
        </trans-unit>
        <trans-unit id="dd82ca7bb177e279e2683ea7fbe64334d04efc2f" translate="yes" xml:space="preserve">
          <source>Users update crisis information in the &lt;code&gt;CrisisDetailComponent&lt;/code&gt;. Unlike the &lt;code&gt;HeroDetailComponent&lt;/code&gt;, the user changes do not update the crisis entity immediately. Instead, the app updates the entity when the user presses the Save button and discards the changes when the user presses the Cancel button.</source>
          <target state="translated">사용자는 &lt;code&gt;CrisisDetailComponent&lt;/code&gt; 에서 위기 정보를 업데이트합니다 . &lt;code&gt;HeroDetailComponent&lt;/code&gt; 와 달리 사용자 변경은 위기 엔터티를 즉시 업데이트하지 않습니다. 대신 사용자가 저장 버튼을 누르면 앱이 엔티티를 업데이트하고 사용자가 취소 버튼을 누르면 변경 사항을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="7e5352cba15d17c20f0a63d91386ede57619fc48" translate="yes" xml:space="preserve">
          <source>Users want to see the heroes in alphabetical order. Rather than modify the original component, sub-class it and create a &lt;code&gt;SortedHeroesComponent&lt;/code&gt; that sorts the heroes before presenting them. The &lt;code&gt;SortedHeroesComponent&lt;/code&gt; lets the base class fetch the heroes.</source>
          <target state="translated">사용자는 영웅을 알파벳 순서로보고 싶어합니다. 원래 구성 요소를 수정하는 대신 하위 클래스로 분류하고 영웅을 제시하기 전에 정렬 하는 &lt;code&gt;SortedHeroesComponent&lt;/code&gt; 를 만듭니다 . &lt;code&gt;SortedHeroesComponent&lt;/code&gt; 는 기본 클래스는 영웅을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2f8c815cbd3d0f6b995bdfc4167eccf93e89835" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;&lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;()&lt;/code&gt; to determine which child view is entering and which is leaving the host view.</source>
          <target state="translated">용도는 &lt;code&gt;&lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;()&lt;/code&gt; 아이 뷰가 입력되고 호스트 뷰를 떠나하는 결정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31aea878b7cc6457d61c00c1a42726ffdd26bdea" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder#group&quot;&gt;group()&lt;/a&gt;&lt;/code&gt; function to make the inner animations run in parallel.</source>
          <target state="translated">용도 &lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder#group&quot;&gt;group()&lt;/a&gt;&lt;/code&gt; 내 애니메이션을 병렬로 실행할 수 있도록 기능한다.</target>
        </trans-unit>
        <trans-unit id="eb3f711d4d463174e45d6d4d25298cf04c07c73e" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;XMLHttpRequest&lt;/code&gt; to send requests to a backend server.</source>
          <target state="translated">&lt;code&gt;XMLHttpRequest&lt;/code&gt; 를 사용 하여 백엔드 서버로 요청을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="c06c023d5ad6ceae75abc64c08a60416cf72fe50" translate="yes" xml:space="preserve">
          <source>Uses &lt;code&gt;group()&lt;/code&gt; function to make the inner animations run in parallel.</source>
          <target state="translated">용도 &lt;code&gt;group()&lt;/code&gt; 내 애니메이션을 병렬로 실행할 수 있도록 기능한다.</target>
        </trans-unit>
        <trans-unit id="fb544a35f46de4fa74e1a77fac25ace9926dc2ca" translate="yes" xml:space="preserve">
          <source>Uses the cart service's &lt;code&gt;#addToCart()&lt;/code&gt; method to add the product to the cart</source>
          <target state="translated">장바구니 서비스의 &lt;code&gt;#addToCart()&lt;/code&gt; 메소드를 사용하여 장바구니 에 제품을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d2251c5dbaa5b5863575212dbae0fac395c8eebf" translate="yes" xml:space="preserve">
          <source>Uses the cart service's &lt;code&gt;addToCart()&lt;/code&gt; method to add the product the cart.</source>
          <target state="translated">카트 서비스의 &lt;code&gt;addToCart()&lt;/code&gt; 메서드를 사용하여 제품을 카트에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="26498e934159fe90edddba43e16fe5686239bbb3" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;structural-directives#ngcontainer&quot;&gt;&lt;code&gt;&amp;lt;ng-container&amp;gt;&lt;/code&gt;&lt;/a&gt; to group elements when there is no suitable host element for the directive.</source>
          <target state="translated">지시문에 적합한 호스트 요소가없는 경우 &lt;a href=&quot;structural-directives#ngcontainer&quot;&gt; &lt;code&gt;&amp;lt;ng-container&amp;gt;&lt;/code&gt; &lt;/a&gt; 를 사용하여 요소를 그룹화하십시오.</target>
        </trans-unit>
        <trans-unit id="dafc513bc116615d9bcd01ae37d00fbc6d71e7be" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; allows the TypeScript compiler to infer that the &lt;code&gt;person&lt;/code&gt; used in the binding expression will never be &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">사용 &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 는 것을 추론에 타이프 스크립트 컴파일러 수 있습니다 &lt;code&gt;person&lt;/code&gt; 바인딩 식 사용은 않을 것입니다 &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2079239a97ead0b33bc251fc5c650a30d5b63e76" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="a1906205d52b88b6a96e74121a3dd7e6924f2137" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; with template variables</source>
          <target state="translated">템플릿 변수와 함께 &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="009d6972085fee6a31f1c55238d2601d61726d62" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; in a form gives you more than just two-way data binding. It also tells you if the user touched the control, if the value changed, or if the value became invalid.</source>
          <target state="translated">양식에서 &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 을 사용하면 양방향 데이터 바인딩 이상의 기능이 제공됩니다. 또한 사용자가 컨트롤을 터치했는지, 값이 변경되었는지 또는 값이 유효하지 않은지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="ecb3202cb740968562d3700dc9265b6286e554ac" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt;</source>
          <target state="translated">사용 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b80bc244560b6471b5ebc73479dd0654103c5a79" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; is a good option for hybrid apps when you want to keep the AngularJS and Angular parts less coupled. You can still mix and match components and services from both frameworks, but you might need to manually propagate change detection. In return, &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; offers more control and better performance.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; 사용 하면 AngularJS와 Angular 부품의 결합을 줄이려는 하이브리드 앱에 적합한 옵션입니다. 두 프레임 워크에서 구성 요소와 서비스를 혼합하여 사용할 수 있지만 변경 감지를 수동으로 전파해야 할 수도 있습니다. 그에 따라 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; 은 더 많은 제어와 더 나은 성능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2d82708ea292a262e61f2d5f8621ff178f8d5983" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; together</source>
          <target state="translated">사용 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 와 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; 함께</target>
        </trans-unit>
        <trans-unit id="055d132f35168e249d6c060c65dea4376f8745af" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;providedIn&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;providedIn&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="6804585becce9a56b0b6866a6f53fbbbc7e22fcc" translate="yes" xml:space="preserve">
          <source>Using AfterContent hooks</source>
          <target state="translated">AfterContent 후크 사용</target>
        </trans-unit>
        <trans-unit id="74169e90061ae53df7dfd46eec63ac28d5d94ef4" translate="yes" xml:space="preserve">
          <source>Using Ahead-of-time compilation with hybrid apps</source>
          <target state="translated">하이브리드 앱에서 Ahead-of-time 컴파일 사용</target>
        </trans-unit>
        <trans-unit id="0f882c8db368aa93dcfdc9565b2fe479a0f65394" translate="yes" xml:space="preserve">
          <source>Using Angular Components from AngularJS Code</source>
          <target state="translated">AngularJS 코드에서 각도 구성 요소 사용</target>
        </trans-unit>
        <trans-unit id="538fdb75e4407ef4e1f9fd247aecd6cb930a0109" translate="yes" xml:space="preserve">
          <source>Using Angular routes in a single-page application</source>
          <target state="translated">단일 페이지 애플리케이션에서 Angular 경로 사용</target>
        </trans-unit>
        <trans-unit id="23d76136981acebe9548a54e9f89615171752fe2" translate="yes" xml:space="preserve">
          <source>Using Angular with Visual Studio 2015</source>
          <target state="translated">Visual Studio 2015에서 Angular 사용</target>
        </trans-unit>
        <trans-unit id="17c25861439c77e4c24ac7b18b709a16ebcd8414" translate="yes" xml:space="preserve">
          <source>Using AngularJS Component Directives from Angular Code</source>
          <target state="translated">각도 코드에서 AngularJS 구성 요소 지시문 사용</target>
        </trans-unit>
        <trans-unit id="6eedc5b4078ec5038cac8e2b9d65aa8e2af22115" translate="yes" xml:space="preserve">
          <source>Using Bazel with the Angular CLI</source>
          <target state="translated">Angular CLI와 함께 Bazel 사용</target>
        </trans-unit>
        <trans-unit id="c8043476b24c21372dff83314cac228b720e7e28" translate="yes" xml:space="preserve">
          <source>Using Component Directives</source>
          <target state="translated">구성 요소 지시문 사용</target>
        </trans-unit>
        <trans-unit id="5a929294f1668f68b734694e2f6b28e39e561245" translate="yes" xml:space="preserve">
          <source>Using Components and Injectables</source>
          <target state="translated">성분 및 주사제 사용</target>
        </trans-unit>
        <trans-unit id="8560edfb2496478ddf9a15a34d1f1a4eea8ae268" translate="yes" xml:space="preserve">
          <source>Using Ivy in a new project</source>
          <target state="translated">새 프로젝트에서 아이비 사용</target>
        </trans-unit>
        <trans-unit id="cf8265992d20fc1bd54761a66691a09bc3fa959c" translate="yes" xml:space="preserve">
          <source>Using Ivy in an existing project</source>
          <target state="translated">기존 프로젝트에서 아이비 사용</target>
        </trans-unit>
        <trans-unit id="bd58271391a20dd5989d94d3502323887e683ca7" translate="yes" xml:space="preserve">
          <source>Using Published Libraries</source>
          <target state="translated">게시 된 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="6ca8f7e641df5bbedfdd4e9bb52d03e5ec749ff9" translate="yes" xml:space="preserve">
          <source>Using SSR without Ivy</source>
          <target state="translated">Ivy없이 SSR 사용</target>
        </trans-unit>
        <trans-unit id="85890bb2deccf4180db150068e3ca159756d5544" translate="yes" xml:space="preserve">
          <source>Using UpgradeModule with Angular &lt;code&gt;NgModules&lt;/code&gt;</source>
          <target state="translated">Angular &lt;code&gt;NgModules&lt;/code&gt; 와 함께 UpgradeModule 사용</target>
        </trans-unit>
        <trans-unit id="26f2d58b409e22020a26e1496a62efdcfdf36b19" translate="yes" xml:space="preserve">
          <source>Using Web Workers with Angular CLI</source>
          <target state="translated">Angular CLI와 함께 웹 워커 사용</target>
        </trans-unit>
        <trans-unit id="25a7a129fc73369732e5d055709e4cf9d964e38c" translate="yes" xml:space="preserve">
          <source>Using a Module Loader</source>
          <target state="translated">모듈 로더 사용</target>
        </trans-unit>
        <trans-unit id="1bb470f1f27338d27d105cf1de41569b72b27987" translate="yes" xml:space="preserve">
          <source>Using a checkbox with a reactive form.</source>
          <target state="translated">반응 형과 함께 확인란 사용</target>
        </trans-unit>
        <trans-unit id="31590c1417cdeb82cd1f78154e9df03671bd0ac5" translate="yes" xml:space="preserve">
          <source>Using a class as an interface gives you the characteristics of an interface in a real JavaScript object. To minimize memory cost, however, the class should have &lt;em&gt;no implementation&lt;/em&gt;. The &lt;code&gt;MinimalLogger&lt;/code&gt; transpiles to this unoptimized, pre-minified JavaScript for a constructor function.</source>
          <target state="translated">클래스를 인터페이스로 사용하면 실제 JavaScript 객체의 인터페이스 특성이 제공됩니다. 그러나 메모리 비용을 최소화하려면 클래스에 &lt;em&gt;구현&lt;/em&gt; 이 &lt;em&gt;없어야합니다&lt;/em&gt; . &lt;code&gt;MinimalLogger&lt;/code&gt; 는 생성자 함수에 대한이 최적화되지 않은, 사전 축소 된 자바 스크립트에 transpiles.</target>
        </trans-unit>
        <trans-unit id="4d9d664f928769890dab78d8b2d3d0c3e2b54a9f" translate="yes" xml:space="preserve">
          <source>Using a custom provider allows you to provide a concrete implementation for implicit dependencies, such as built-in browser APIs. The following example uses an &lt;code&gt;&lt;a href=&quot;../api/core/injectiontoken&quot;&gt;InjectionToken&lt;/a&gt;&lt;/code&gt; to provide the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt;localStorage&lt;/a&gt; browser API as a dependency in the &lt;code&gt;BrowserStorageService&lt;/code&gt;.</source>
          <target state="translated">사용자 지정 공급자를 사용하면 기본 제공 브라우저 API와 같은 암시 적 종속성에 대한 구체적인 구현을 제공 할 수 있습니다. 다음 예제는 &lt;code&gt;&lt;a href=&quot;../api/core/injectiontoken&quot;&gt;InjectionToken&lt;/a&gt;&lt;/code&gt; 을 사용하여 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt;localStorage&lt;/a&gt; 브라우저 API를 &lt;code&gt;BrowserStorageService&lt;/code&gt; 의 종속성으로 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="02aeb5cb190c15997bab2a850739e9d394f7fa3c" translate="yes" xml:space="preserve">
          <source>Using a module loader such as &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt;, &lt;a href=&quot;http://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt;, or &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; allows us to use the built-in module systems of TypeScript or ES2015. You can use the &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; features that explicitly specify what code can and will be shared between different parts of the application. For ES5 applications you can use CommonJS style &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;module.exports&lt;/code&gt; features. In both cases, the module loader will then take care of loading all the code the application needs in the correct order.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt; , &lt;a href=&quot;http://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt; 또는 &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; 와 같은 모듈 로더 를 사용하면 TypeScript 또는 ES2015의 내장 모듈 시스템을 사용할 수 있습니다. 응용 프로그램의 다른 부분간에 공유 할 수있는 코드를 명시 적으로 지정 하는 &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;export&lt;/code&gt; 기능을 사용할 수 있습니다 . ES5 애플리케이션의 경우 CommonJS 스타일 &lt;code&gt;require&lt;/code&gt; 및 &lt;code&gt;module.exports&lt;/code&gt; 기능을 사용할 수 있습니다 . 두 경우 모두 모듈 로더는 응용 프로그램에 필요한 모든 코드를 올바른 순서로로드합니다.</target>
        </trans-unit>
        <trans-unit id="e1bd6508f8a95f5ac09473740e2f29b0e198b127" translate="yes" xml:space="preserve">
          <source>Using a module loader such as &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt;, &lt;a href=&quot;https://webpack.github.io/&quot;&gt;Webpack&lt;/a&gt;, or &lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; allows us to use the built-in module systems of TypeScript or ES2015. You can use the &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; features that explicitly specify what code can and will be shared between different parts of the application. For ES5 applications you can use CommonJS style &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;module.exports&lt;/code&gt; features. In both cases, the module loader will then take care of loading all the code the application needs in the correct order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f25102a62964a05eaec1c93977c505a046e3af36" translate="yes" xml:space="preserve">
          <source>Using a multi-select control</source>
          <target state="translated">다중 선택 컨트롤 사용</target>
        </trans-unit>
        <trans-unit id="f0463c4ad562556ca75b5685c437f035005a3898" translate="yes" xml:space="preserve">
          <source>Using a number input with a reactive form.</source>
          <target state="translated">반응 형으로 숫자 입력 사용.</target>
        </trans-unit>
        <trans-unit id="362ae0d4a6f11b3ccd18f788e1fc131f19e64607" translate="yes" xml:space="preserve">
          <source>Using a pipe in a template</source>
          <target state="translated">템플릿에서 파이프 사용</target>
        </trans-unit>
        <trans-unit id="43277715c244dfa655936028d9803ebc04d819da" translate="yes" xml:space="preserve">
          <source>Using a range input with a reactive form</source>
          <target state="translated">반응 형과 함께 범위 입력 사용</target>
        </trans-unit>
        <trans-unit id="0bc00d2438413210675960c941e89d3aaad3f65b" translate="yes" xml:space="preserve">
          <source>Using a standalone ngModel within a group</source>
          <target state="translated">그룹 내에서 독립형 ngModel 사용</target>
        </trans-unit>
        <trans-unit id="9a199801aa6b4cc01c80b73b2888fdf63af4478e" translate="yes" xml:space="preserve">
          <source>Using absolute URLs for HTTP (data) requests on the server</source>
          <target state="translated">서버에서 HTTP (데이터) 요청에 절대 URL 사용</target>
        </trans-unit>
        <trans-unit id="2339a60fcda21d90b519800c5c237255868c84d4" translate="yes" xml:space="preserve">
          <source>Using absolute URLs for server requests</source>
          <target state="translated">서버 요청에 절대 URL 사용</target>
        </trans-unit>
        <trans-unit id="838f5332e38c0970cd6624c40ba4f576025a9c67" translate="yes" xml:space="preserve">
          <source>Using ahead-of-time compilation with hybrid apps</source>
          <target state="translated">하이브리드 앱으로 사전 컴파일 사용</target>
        </trans-unit>
        <trans-unit id="3fb461289e6b21adcc3eeca9c5745cff8590fa02" translate="yes" xml:space="preserve">
          <source>Using an &lt;code&gt;&lt;a href=&quot;../api/core/ngmodulefactory&quot;&gt;NgModuleFactory&lt;/a&gt;&lt;/code&gt; requires less boilerplate and is a good default option as it supports AOT out-of-the-box. Using a custom function requires slightly more code, but gives you greater flexibility.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/core/ngmodulefactory&quot;&gt;NgModuleFactory&lt;/a&gt;&lt;/code&gt; 를 사용하면 상용구 가 적고 AOT가 기본적으로 지원되므로 기본 옵션으로 사용하는 것이 좋습니다. 사용자 정의 기능을 사용하려면 약간 더 많은 코드가 필요하지만 유연성이 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="225b30fb1178e65060dad8d2124424365a8f210e" translate="yes" xml:space="preserve">
          <source>Using an Angular custom element makes the process much simpler and more transparent, by providing all of the infrastructure and framework automatically&amp;mdash;all you have to do is define the kind of event handling you want. (You do still have to exclude the component from compilation, if you are not going to use it in your app.)</source>
          <target state="translated">Angular 사용자 정의 요소를 사용하면 모든 인프라와 프레임 워크를 자동으로 제공하여 프로세스를 훨씬 간단하고 투명하게 만들 수 있습니다. 원하는 이벤트 처리 유형을 정의하기 만하면됩니다. 앱에서 구성 요소를 사용하지 않으려는 경우 구성 요소를 컴파일에서 제외해야합니다.</target>
        </trans-unit>
        <trans-unit id="b770296ed0960ba4e0adf200d5857757fb6ba30c" translate="yes" xml:space="preserve">
          <source>Using an external &lt;code&gt;then&lt;/code&gt; template</source>
          <target state="translated">외부 사용하여 &lt;code&gt;then&lt;/code&gt; 템플릿을</target>
        </trans-unit>
        <trans-unit id="6551ed39890875715b3cd0878168d51e0620c7b7" translate="yes" xml:space="preserve">
          <source>Using an inline function</source>
          <target state="translated">인라인 함수 사용</target>
        </trans-unit>
        <trans-unit id="5b549f5ecc437dc9b61f4e3a7e36dddae8771675" translate="yes" xml:space="preserve">
          <source>Using change detection hooks</source>
          <target state="translated">변경 감지 후크 사용</target>
        </trans-unit>
        <trans-unit id="1f00ba280ffbec54abe918ad286a8c43241f37e6" translate="yes" xml:space="preserve">
          <source>Using component styles</source>
          <target state="translated">컴포넌트 스타일 사용</target>
        </trans-unit>
        <trans-unit id="326e590dcb9985b96603eaad2f203133d3ba3bbb" translate="yes" xml:space="preserve">
          <source>Using components vs services from other modules</source>
          <target state="translated">다른 모듈의 구성 요소와 서비스 사용</target>
        </trans-unit>
        <trans-unit id="a5d277d826e502273f12e8b03216771a9c8b14ca" translate="yes" xml:space="preserve">
          <source>Using containers for native elements</source>
          <target state="translated">기본 요소에 컨테이너 사용</target>
        </trans-unit>
        <trans-unit id="dcca472daafb75114b08b61eb39f9ca73d6a3a8d" translate="yes" xml:space="preserve">
          <source>Using corporate proxy</source>
          <target state="translated">회사 프록시 사용</target>
        </trans-unit>
        <trans-unit id="c2a6531054ec097e5ed70a832394e057ca205e4a" translate="yes" xml:space="preserve">
          <source>Using custom elements</source>
          <target state="translated">맞춤 요소 사용</target>
        </trans-unit>
        <trans-unit id="d9d0d750c5305782eba2c313f6df5f97406ecfca" translate="yes" xml:space="preserve">
          <source>Using directives with &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule에&lt;/a&gt; 지시문 사용</target>
        </trans-unit>
        <trans-unit id="59731cbdea4e70d97215a2a24c9617e473f8ae07" translate="yes" xml:space="preserve">
          <source>Using environment-specific variables in your app</source>
          <target state="translated">앱에서 환경 별 변수 사용</target>
        </trans-unit>
        <trans-unit id="854d21a23d274223f8cf25d100b4b8cae3bc20bf" translate="yes" xml:space="preserve">
          <source>Using forms for user input</source>
          <target state="translated">사용자 입력에 양식 사용</target>
        </trans-unit>
        <trans-unit id="4873a934571edcf42946734a7ed9212bf08a37e0" translate="yes" xml:space="preserve">
          <source>Using interceptors for caching</source>
          <target state="translated">캐싱에 인터셉터 사용</target>
        </trans-unit>
        <trans-unit id="93444e1d8dd4bd38294a6a666ceb5eff59c328d4" translate="yes" xml:space="preserve">
          <source>Using interceptors for logging</source>
          <target state="translated">로깅에 인터셉터 사용</target>
        </trans-unit>
        <trans-unit id="1562913bd8ac2c70ecf103143f1b8b29b4713652" translate="yes" xml:space="preserve">
          <source>Using interceptors to request multiple values</source>
          <target state="translated">인터셉터를 사용하여 여러 값 요청</target>
        </trans-unit>
        <trans-unit id="2321b7fbd5c1912c8bada99aaf80b8238becba61" translate="yes" xml:space="preserve">
          <source>Using lightweight injection tokens</source>
          <target state="translated">경량 주입 토큰 사용</target>
        </trans-unit>
        <trans-unit id="45700a967ebb7988c1385c71666cbbbe1b4d5004" translate="yes" xml:space="preserve">
          <source>Using named outlets and secondary routes, you can target multiple outlets in the same &lt;code&gt;&lt;a href=&quot;routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; directive.</source>
          <target state="translated">명명 된 아웃렛 및 보조 경로를 사용하여 동일한 &lt;code&gt;&lt;a href=&quot;routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; 지시문 에서 여러 아웃렛을 대상으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dbf5a34485d6afcadda2f26d6136cf55d8a92517" translate="yes" xml:space="preserve">
          <source>Using ngModel on a standalone control</source>
          <target state="translated">독립형 컨트롤에서 ngModel 사용</target>
        </trans-unit>
        <trans-unit id="9a7f37dd828f83348b0672d7bb9204b26a305b1d" translate="yes" xml:space="preserve">
          <source>Using ngModel within a form</source>
          <target state="translated">양식 내에서 ngModel 사용</target>
        </trans-unit>
        <trans-unit id="767134f57267e4073023d69bfe85a0ae385d07cf" translate="yes" xml:space="preserve">
          <source>Using observables to handle events and asynchronous operations can have the advantage of greater consistency in contexts such as HTTP requests.</source>
          <target state="translated">옵저버 블을 사용하여 이벤트 및 비동기 작업을 처리하면 HTTP 요청과 같은 컨텍스트에서 일관성이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8d68344b86e6ce83ecfc8f50f23c50bc2c3acc6" translate="yes" xml:space="preserve">
          <source>Using observables to pass values</source>
          <target state="translated">관찰 가능 항목을 사용하여 값 전달</target>
        </trans-unit>
        <trans-unit id="525cb205ecf77ef26071eabcc120a080cdae4b66" translate="yes" xml:space="preserve">
          <source>Using one of our &lt;code&gt;options&lt;/code&gt; is very straightforward, we did this in the previous section when we accessed &lt;code&gt;options.command&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 중 하나를 사용하는 것은 매우 간단합니다. 이전 섹션에서 &lt;code&gt;options.command&lt;/code&gt; 에 액세스했을 때이 작업을 수행했습니다 .</target>
        </trans-unit>
        <trans-unit id="54dca9e5d7f69c01aedf3f75ceb5a7cb672bb0ac" translate="yes" xml:space="preserve">
          <source>Using pipes</source>
          <target state="translated">파이프 사용</target>
        </trans-unit>
        <trans-unit id="0448273d89913b3c36897d03a9d34e53b74149a2" translate="yes" xml:space="preserve">
          <source>Using published libraries</source>
          <target state="translated">게시 된 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="89ebc794fed95d63f9561d0bda00bb5d55f1a0f8" translate="yes" xml:space="preserve">
          <source>Using radio buttons with reactive form directives</source>
          <target state="translated">반응 형 지시문에 라디오 버튼 사용</target>
        </trans-unit>
        <trans-unit id="0185928d3f2103e7a9ea7951c3279ef10646ca73" translate="yes" xml:space="preserve">
          <source>Using relative paths</source>
          <target state="translated">상대 경로 사용</target>
        </trans-unit>
        <trans-unit id="2e5b826e5d221359e0500389d0018c9bdd597f16" translate="yes" xml:space="preserve">
          <source>Using route information</source>
          <target state="translated">경로 정보 사용</target>
        </trans-unit>
        <trans-unit id="881f18e8deeb52c2a18dfc164af0a161e22b725b" translate="yes" xml:space="preserve">
          <source>Using runtime-global libraries inside your app</source>
          <target state="translated">앱 내에서 런타임 전역 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="9bd2ff97908a0c09c2d63474c3cfcc5434417451" translate="yes" xml:space="preserve">
          <source>Using select controls in a reactive form</source>
          <target state="translated">반응 형으로 선택 컨트롤 사용</target>
        </trans-unit>
        <trans-unit id="832a53e426313323000169f37f744b9b7aa99d81" translate="yes" xml:space="preserve">
          <source>Using select controls in a template-driven form</source>
          <target state="translated">템플릿 기반 양식에서 선택 컨트롤 사용</target>
        </trans-unit>
        <trans-unit id="99548dcfaafec32c93c0b36f56b0b0574761c0ed" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;../api/common/asyncpipe&quot;&gt;async&lt;/a&gt;&lt;/code&gt; pipe with an Observable which you know will emit synchronously.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/common/asyncpipe&quot;&gt;async&lt;/a&gt;&lt;/code&gt; 파이프를 Observable과 함께 사용하면 동 기적으로 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="88275c4f479097c72fb4415e38dc5583792a3082" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt; array</source>
          <target state="translated">은 Using &lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt; 의 배열</target>
        </trans-unit>
        <trans-unit id="8cd2ad1f42cec0fd44d2b578a1a5e65f273ee4d6" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;&lt;/code&gt; property is preferable to the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt;&lt;code&gt;providers&lt;/code&gt; array because with &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;&lt;/code&gt;, optimization tools can perform tree-shaking, which removes services that your app isn't using and results in smaller bundle sizes.</source>
          <target state="translated">은 Using &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;&lt;/code&gt; 재산은에 바람직하다 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; &lt;code&gt;providers&lt;/code&gt; 에 있기 때문에 배열 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;&lt;/code&gt; , 최적화 도구는 나무 떨고, 작은 번들 크기로 앱이 사용되지 않도록 서비스 및 결과를 제거 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e7ac3035137317853416afbb770970d2510fd53" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;&lt;/code&gt; property to refer to &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt;, or &lt;code&gt;root&lt;/code&gt;.</source>
          <target state="translated">은 Using &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;&lt;/code&gt; 특성은 참조하는 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; , 또는 &lt;code&gt;root&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c88e88f6d2f3c47b9d51e8a3ed253e6a553321dd" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt;&lt;code&gt;providedIn&lt;/code&gt; property is preferable to the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt;&lt;code&gt;providers&lt;/code&gt; array because with &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt;&lt;code&gt;providedIn&lt;/code&gt;, optimization tools can perform tree-shaking, which removes services that your app isn't using and results in smaller bundle sizes.</source>
          <target state="translated">은 Using &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; &lt;code&gt;providedIn&lt;/code&gt; 재산은에 바람직하다 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; &lt;code&gt;providers&lt;/code&gt; 에 있기 때문에 배열 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; &lt;code&gt;providedIn&lt;/code&gt; , 최적화 도구는 나무 떨고, 작은 번들 크기로 앱이 사용되지 않도록 서비스 및 결과를 제거 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44e4420ee01a69107b179c7db81fbdead7af3869" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt;&lt;code&gt;providedIn&lt;/code&gt; property to refer to &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt;, or &lt;code&gt;root&lt;/code&gt;.</source>
          <target state="translated">은 Using &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; &lt;code&gt;providedIn&lt;/code&gt; 특성은 참조하는 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; , 또는 &lt;code&gt;root&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e75e4bed92d2b5bcba6a93626663647ccf1ee802" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt;&lt;code&gt;providers&lt;/code&gt; array.</source>
          <target state="translated">은 Using &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; &lt;code&gt;providers&lt;/code&gt; 배열을.</target>
        </trans-unit>
        <trans-unit id="0c704679875decd7bc5e10cd52d8163394039311" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;@&lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt;&lt;/code&gt; decorator, the injector only looks at the component's injector for its providers. The &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;&lt;/code&gt; decorator allows you to skip the local injector and look up in the hierarchy to find a provider that satisfies this dependency. The &lt;code&gt;sessionStorageService&lt;/code&gt; instance interacts with the &lt;code&gt;BrowserStorageService&lt;/code&gt; using the &lt;code&gt;sessionStorage&lt;/code&gt; browser API, while the &lt;code&gt;localStorageService&lt;/code&gt; skips the local injector and uses the root &lt;code&gt;BrowserStorageService&lt;/code&gt; that uses the &lt;code&gt;localStorage&lt;/code&gt; browser API.</source>
          <target state="translated">은 Using &lt;code&gt;@&lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt;&lt;/code&gt; 데코레이터, 인젝터는 그 공급자에 대한 구성 요소의 인젝터 본다. &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;&lt;/code&gt; 장식은 공급자 만족이 종속성을 찾을 수있는 지역 인젝터를 건너 뛰고 계층 구조에서 찾아 볼 수 있습니다. &lt;code&gt;sessionStorageService&lt;/code&gt; 의 와 인스턴스 상호 작용 &lt;code&gt;BrowserStorageService&lt;/code&gt; 은 Using &lt;code&gt;sessionStorage&lt;/code&gt; 의 그동안, 브라우저 API를 &lt;code&gt;localStorageService&lt;/code&gt; 이 루트 로컬 인젝터를 건너 뛰고 사용 &lt;code&gt;BrowserStorageService&lt;/code&gt; 이 사용하는 &lt;code&gt;localStorage&lt;/code&gt; 브라우저 API를.</target>
        </trans-unit>
        <trans-unit id="9c2ddaa9a4477a0d280fe7ff4b0889ca96f1260c" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;providers&lt;/code&gt; array</source>
          <target state="translated">은 Using &lt;code&gt;providers&lt;/code&gt; 배열을</target>
        </trans-unit>
        <trans-unit id="b84bc590592c2922688e55ff9faad9cfa8594559" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;switchMap()&lt;/code&gt; operator</source>
          <target state="translated">은 Using &lt;code&gt;switchMap()&lt;/code&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="2a5de5cdedb36b49f976c8433065aae5da357c2e" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;viewProviders&lt;/code&gt; array</source>
          <target state="translated">은 Using &lt;code&gt;viewProviders&lt;/code&gt; 의 배열</target>
        </trans-unit>
        <trans-unit id="87db3d87246b0ba7b1f6a1e65402304267c078f0" translate="yes" xml:space="preserve">
          <source>Using the Angular CLI command &lt;a href=&quot;cli/generate&quot;&gt;&lt;code&gt;ng generate class&lt;/code&gt;&lt;/a&gt;, generate a new class named &lt;code&gt;Hero&lt;/code&gt;:</source>
          <target state="translated">Angular CLI 명령 &lt;a href=&quot;cli/generate&quot;&gt; &lt;code&gt;ng generate class&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;Hero&lt;/code&gt; 라는 새 클래스를 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="24653eb83b101fbb344fe1dd41060b459319c087" translate="yes" xml:space="preserve">
          <source>Using the Angular CLI command &lt;a href=&quot;cli/generate&quot;&gt;&lt;code&gt;ng generate component&lt;/code&gt;&lt;/a&gt;, generate a new component named &lt;code&gt;HeroForm&lt;/code&gt;:</source>
          <target state="translated">Angular CLI 명령 &lt;a href=&quot;cli/generate&quot;&gt; &lt;code&gt;ng generate component&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;HeroForm&lt;/code&gt; 이라는 새 컴포넌트를 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="26e8c88a445901a9d701f6c7f1ed54859622fdd3" translate="yes" xml:space="preserve">
          <source>Using the Angular CLI, create a new application, &lt;em&gt;angular-router-sample&lt;/em&gt;. This application will have two components: &lt;em&gt;crisis-list&lt;/em&gt; and &lt;em&gt;heroes-list&lt;/em&gt;.</source>
          <target state="translated">Angular CLI를 사용하여 새 애플리케이션 &lt;em&gt;angular-router-sample을&lt;/em&gt; 만듭니다. 이 애플리케이션에는 &lt;em&gt;위기 목록&lt;/em&gt; 과 &lt;em&gt;영웅 &lt;/em&gt;&lt;em&gt;목록의&lt;/em&gt; 두 가지 구성 요소가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="81efa0d631504c35459bdd579b8b05a652508d3a" translate="yes" xml:space="preserve">
          <source>Using the Angular CLI, create a service called &lt;code&gt;hero&lt;/code&gt;.</source>
          <target state="translated">Angular CLI를 사용하여 &lt;code&gt;hero&lt;/code&gt; 라는 서비스를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="0965eb7867ed11aa022c0e42434572bd02fabfa4" translate="yes" xml:space="preserve">
          <source>Using the Angular CLI, generate a new component named &lt;code&gt;heroes&lt;/code&gt;.</source>
          <target state="translated">Angular CLI를 사용하여 &lt;code&gt;heroes&lt;/code&gt; 라는 새 컴포넌트를 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5adb7aa313a235cb09657ba564b95feb23f9777" translate="yes" xml:space="preserve">
          <source>Using the Angular Unified Location Service</source>
          <target state="translated">각도 통합 위치 서비스 사용</target>
        </trans-unit>
        <trans-unit id="db51f3d7c0cef2b92ca0e1df1396750373f38a91" translate="yes" xml:space="preserve">
          <source>Using the FormBuilder service to generate controls</source>
          <target state="translated">FormBuilder 서비스를 사용하여 컨트롤 생성</target>
        </trans-unit>
        <trans-unit id="3385d7778ed34c624bab677d8b93113048ea3d70" translate="yes" xml:space="preserve">
          <source>Using the Hero class</source>
          <target state="translated">Hero 클래스 사용</target>
        </trans-unit>
        <trans-unit id="ff417e4e743dbd8b56962f81a4ee9bfd8fb96040" translate="yes" xml:space="preserve">
          <source>Using the PipeTransform interface</source>
          <target state="translated">PipeTransform 인터페이스 사용</target>
        </trans-unit>
        <trans-unit id="78f7880d324d4d6b362277b5293f7d5e81175744" translate="yes" xml:space="preserve">
          <source>Using the RxJS scheduler inside fakeAsync()</source>
          <target state="translated">fakeAsync () 내에서 RxJS 스케줄러 사용</target>
        </trans-unit>
        <trans-unit id="460ffdb79528b543b65d0023597d166efc0e6187" translate="yes" xml:space="preserve">
          <source>Using the Unified Angular Location Service</source>
          <target state="translated">통합 각도 위치 서비스 사용</target>
        </trans-unit>
        <trans-unit id="0eaa4a821d12f646f3302fe044d9cd570a2e3fdd" translate="yes" xml:space="preserve">
          <source>Using the default (&quot;CheckAlways&quot;) change-detection strategy, the change detector goes through the &lt;a href=&quot;glossary#view-tree&quot;&gt;view hierarchy&lt;/a&gt; on each VM turn to check every &lt;a href=&quot;glossary#data-binding&quot;&gt;data-bound property&lt;/a&gt; in the template. In the first phase, it compares the current state of the dependent data with the previous state, and collects changes. In the second phase, it updates the page DOM to reflect any new data values.</source>
          <target state="translated">기본 ( &quot;CheckAlways&quot;) 변경 감지 전략을 사용하여 변경 감지기는 각 VM 턴 의 &lt;a href=&quot;glossary#view-tree&quot;&gt;보기 계층 구조&lt;/a&gt; 를 통해 템플릿의 모든 &lt;a href=&quot;glossary#data-binding&quot;&gt;데이터 바인딩 속성&lt;/a&gt; 을 확인합니다 . 첫 번째 단계에서는 종속 데이터의 현재 상태를 이전 상태와 비교하고 변경 사항을 수집합니다. 두 번째 단계에서는 새 데이터 값을 반영하도록 페이지 DOM을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="9a66563e1975c2187a0773744f035412c7a0c811" translate="yes" xml:space="preserve">
          <source>Using the default value accessor</source>
          <target state="translated">기본값 액세서 사용</target>
        </trans-unit>
        <trans-unit id="d8d0dd351b925abe0013872e2187d3ac63a5f4b4" translate="yes" xml:space="preserve">
          <source>Using the graphviz optional dependency, you'll have a program &lt;code&gt;dot&lt;/code&gt;, which you can use with &lt;code&gt;bazel &lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">graphviz 선택적 의존성 을 사용하면 &lt;code&gt;bazel &lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/animations/query&quot;&gt;쿼리&lt;/a&gt; 와 함께 사용할 수 있는 프로그램 &lt;code&gt;dot&lt;/code&gt; 이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="701a7ae767b31ad4b44a0cd1aae2842c56741ee2" translate="yes" xml:space="preserve">
          <source>Using the key &lt;code&gt;$implicit&lt;/code&gt; in the context object will set its value as default.</source>
          <target state="translated">컨텍스트 객체에서 &lt;code&gt;$implicit&lt;/code&gt; 키를 사용하면 해당 값이 기본값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="97fd999fe0f9f9e0225af291a35e80bbf1a2a5cb" translate="yes" xml:space="preserve">
          <source>Using the template binding syntax, the form control is now registered to the &lt;code&gt;name&lt;/code&gt; input element in the template. The form control and DOM element communicate with each other: the view reflects changes in the model, and the model reflects changes in the view.</source>
          <target state="translated">템플릿 바인딩 구문을 사용하여 양식 컨트롤이 이제 템플릿 의 &lt;code&gt;name&lt;/code&gt; 입력 요소에 등록됩니다 . 폼 컨트롤과 DOM 요소는 서로 통신합니다. 뷰는 모델의 변경 사항을 반영하고 모델은 뷰의 변경 사항을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="a73267180af548e33b36453222ddbcd0a9cd7a26" translate="yes" xml:space="preserve">
          <source>Using wildcard state with multiple transition states</source>
          <target state="translated">다중 전이 상태와 함께 와일드 카드 상태 사용</target>
        </trans-unit>
        <trans-unit id="f5248445a88890c526dc548b5736616908228cef" translate="yes" xml:space="preserve">
          <source>Using wildcards with styles</source>
          <target state="translated">스타일과 함께 와일드 카드 사용</target>
        </trans-unit>
        <trans-unit id="713259890f138e39aa90aa5677e5e633bd9c843b" translate="yes" xml:space="preserve">
          <source>Using your browser's developer tools, find the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element that corresponds to the &lt;strong&gt;Name&lt;/strong&gt; input box. You can see that the element has multiple CSS classes in addition to &quot;form-control&quot;.</source>
          <target state="translated">브라우저의 개발자 도구 를 사용하여 &lt;strong&gt;이름&lt;/strong&gt; 입력 상자에 해당하는 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 요소를 찾으십시오 . 요소에 &quot;form-control&quot;외에도 여러 CSS 클래스가 있음을 알 수 있습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3732652b5c565611a56c0e8b0ff175f176f6e899" translate="yes" xml:space="preserve">
          <source>Using your own library in apps</source>
          <target state="translated">앱에서 자신의 라이브러리 사용</target>
        </trans-unit>
        <trans-unit id="36b3c5921b9dbb0818575770f742474b0a62f5c5" translate="yes" xml:space="preserve">
          <source>Usually there's only one component in this list, the &lt;em&gt;root component&lt;/em&gt; of the application.</source>
          <target state="translated">일반적으로이 목록 에는 응용 프로그램 의 &lt;em&gt;루트 구성 요소&lt;/em&gt; 인 구성 요소가 하나만 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a319f5c807a99dec0b4916cda29f6050d992dd8" translate="yes" xml:space="preserve">
          <source>Usually, setting an element property with a &lt;a href=&quot;template-syntax#property-binding&quot;&gt;property binding&lt;/a&gt; is preferable to setting the attribute with a string. However, sometimes there is no element property to bind, so attribute binding is the solution.</source>
          <target state="translated">일반적으로 문자열을 사용하여 속성을 설정하려면 속성 &lt;a href=&quot;template-syntax#property-binding&quot;&gt;바인딩으로&lt;/a&gt; 요소 속성 을 설정하는 것이 좋습니다. 그러나 바인딩 할 요소 속성이없는 경우가 있으므로 속성 바인딩이 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="89189507b2a074e98b2e877227343a6e1f27b3ab" translate="yes" xml:space="preserve">
          <source>Utility</source>
          <target state="translated">Utility</target>
        </trans-unit>
        <trans-unit id="0da3a16df4f1cfe00ccae4cb470106238ee3f50d" translate="yes" xml:space="preserve">
          <source>Validate against a maximum of 15</source>
          <target state="translated">최대 15 개에 대해 검증</target>
        </trans-unit>
        <trans-unit id="b626a91102f28dde09ef4feac857a53784030579" translate="yes" xml:space="preserve">
          <source>Validate against a minimum of 3</source>
          <target state="translated">최소 3에 대해 검증</target>
        </trans-unit>
        <trans-unit id="818e53027490cae519ac5ae2b2578a57bb9dce8d" translate="yes" xml:space="preserve">
          <source>Validate reactive or template-based form input based on the values of two sibling controls,</source>
          <target state="translated">두 형제 컨트롤의 값을 기반으로 반응 형 또는 템플릿 기반 양식 입력의 유효성을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="5f2d339a1d7ad3e7b42679e5d838c4f7db0e2db1" translate="yes" xml:space="preserve">
          <source>Validate that the field has a minimum of 3 characters</source>
          <target state="translated">필드가 3 자 이상인지 확인</target>
        </trans-unit>
        <trans-unit id="365af241d710fd38bb8fc6a89e93b90b0d1db454" translate="yes" xml:space="preserve">
          <source>Validate that the field has maximum of 5 characters</source>
          <target state="translated">필드가 최대 5 자인지 확인</target>
        </trans-unit>
        <trans-unit id="0506ee2af8e063c56ec116feb2754facf42c90d0" translate="yes" xml:space="preserve">
          <source>Validate that the field is non-empty</source>
          <target state="translated">필드가 비어 있지 않은지 확인</target>
        </trans-unit>
        <trans-unit id="a3381e343a3617a4bb231a512be6fc59fa34d569" translate="yes" xml:space="preserve">
          <source>Validate that the field matches a valid email pattern</source>
          <target state="translated">필드가 유효한 이메일 패턴과 일치하는지 확인</target>
        </trans-unit>
        <trans-unit id="403d97dc000145ae46f642bb7353f29a0deade7a" translate="yes" xml:space="preserve">
          <source>Validate that the field only contains letters or spaces</source>
          <target state="translated">필드에 문자 나 공백 만 포함되어 있는지 확인</target>
        </trans-unit>
        <trans-unit id="b1d42fbeab767bb81064a062ffe20d0f69ea59f2" translate="yes" xml:space="preserve">
          <source>Validate that the field value is true</source>
          <target state="translated">필드 값이 true인지 확인</target>
        </trans-unit>
        <trans-unit id="23b8880400d5deddab1250ea0a0ef87bbdae38db" translate="yes" xml:space="preserve">
          <source>Validate the correctness of user input.</source>
          <target state="translated">사용자 입력의 정확성을 검증하십시오.</target>
        </trans-unit>
        <trans-unit id="629f392f5c719cd17bd7372a7645ad93e4ee77d2" translate="yes" xml:space="preserve">
          <source>Validating form input</source>
          <target state="translated">양식 입력 유효성 검사</target>
        </trans-unit>
        <trans-unit id="9f6ed5d2f1e694bb85cf23568e42b7be586d5cd2" translate="yes" xml:space="preserve">
          <source>Validating input in reactive forms</source>
          <target state="translated">반응 형 입력 유효성 검사</target>
        </trans-unit>
        <trans-unit id="a3e093fcafa07fb1831865ee6052cc74c5d95600" translate="yes" xml:space="preserve">
          <source>Validating input in template-driven forms</source>
          <target state="translated">템플릿 기반 양식의 입력 유효성 검사</target>
        </trans-unit>
        <trans-unit id="f43a0dc6633797adf7396b6cf232151d02e24338" translate="yes" xml:space="preserve">
          <source>Validation is an integral part of managing any set of forms. Whether you're checking for required fields or querying an external API for an existing username, Angular provides a set of built-in validators as well as the ability to create custom validators.</source>
          <target state="translated">유효성 검사는 모든 양식 집합을 관리하는 데 필수적인 부분입니다. 필수 필드를 확인하거나 기존 사용자 이름에 대한 외부 API를 쿼리 할 때 Angular는 기본 제공 유효성 검사기 세트와 사용자 지정 유효성 검사기를 만드는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="70933a459fa1beb4c3976a98043f612aca8bc6ae" translate="yes" xml:space="preserve">
          <source>Validation is set up through validation functions rather than valdation directives.</source>
          <target state="translated">유효성 검사는 유효성 검사 지시문이 아닌 유효성 검사 기능을 통해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c3a95fd1fee387e96c0fc007cd033a377fee988e" translate="yes" xml:space="preserve">
          <source>Validation is set up through validation functions rather than validation directives.</source>
          <target state="translated">유효성 검사는 유효성 검사 지시문이 아닌 유효성 검사 함수를 통해 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="42b88cee0411df854ab9ab8680b74f241740fc3c" translate="yes" xml:space="preserve">
          <source>ValidationErrors</source>
          <target state="translated">ValidationErrors</target>
        </trans-unit>
        <trans-unit id="6e5b7a60980482ab39ae77b25489457b817517cd" translate="yes" xml:space="preserve">
          <source>Validator</source>
          <target state="translated">Validator</target>
        </trans-unit>
        <trans-unit id="e37939a31ae2f93a355efd2e41823a0ccd0104e8" translate="yes" xml:space="preserve">
          <source>Validator functions</source>
          <target state="translated">검사기 기능</target>
        </trans-unit>
        <trans-unit id="47054a0db6bc91d732240bd2a683d17e62e078f1" translate="yes" xml:space="preserve">
          <source>Validator functions can be either synchronous or asynchronous.</source>
          <target state="translated">유효성 검사기 함수는 동기 또는 비동기 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b6adf9f43ac26d416c0fe91c7ae74d404335f9c" translate="yes" xml:space="preserve">
          <source>Validator that performs no operation.</source>
          <target state="translated">작업을 수행하지 않는 유효성 검사기</target>
        </trans-unit>
        <trans-unit id="bf6a47ff451c3b9d71ebb71124e408131e842715" translate="yes" xml:space="preserve">
          <source>Validator that requires the control have a non-empty value.</source>
          <target state="translated">제어가 필요한 유효성 검사기는 비어 있지 않은 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="9b247107c6248f97a52d72465eaa594dac9f871b" translate="yes" xml:space="preserve">
          <source>Validator that requires the control's value be true. This validator is commonly used for required checkboxes.</source>
          <target state="translated">컨트롤 값이 필요한 유효성 검사기입니다. 이 유효성 검사기는 일반적으로 필수 확인란에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2ae1c5182294db9a183f7aa482d9d8a206c1d386" translate="yes" xml:space="preserve">
          <source>Validator that requires the control's value pass an email validation test.</source>
          <target state="translated">컨트롤 값이 필요한 유효성 검사기는 전자 메일 유효성 검사 테스트를 통과합니다.</target>
        </trans-unit>
        <trans-unit id="0106b5809c999beadaacdf16e65d183947be2d35" translate="yes" xml:space="preserve">
          <source>Validator that requires the control's value to be greater than or equal to the provided number. The validator exists only as a function and not as a directive.</source>
          <target state="translated">컨트롤 값이 제공된 숫자보다 크거나 같아야하는 유효성 검사기 유효성 검사기는 지시문이 아닌 함수로만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="162dfec38e764abc2921d5b06f86d1bcbeadf02b" translate="yes" xml:space="preserve">
          <source>Validator that requires the control's value to be less than or equal to the provided number. The validator exists only as a function and not as a directive.</source>
          <target state="translated">컨트롤 값이 제공된 숫자보다 작거나 같아야하는 유효성 검사기입니다. 유효성 검사기는 지시문이 아닌 함수로만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="52c39a07c7e7121efa3eaeb3fbe77b7575251296" translate="yes" xml:space="preserve">
          <source>Validator that requires the control's value to match a regex pattern. This validator is also provided by default if you use the HTML5 &lt;code&gt;&lt;a href=&quot;patternvalidator&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; attribute.</source>
          <target state="translated">정규식 패턴과 일치하는 컨트롤 값이 필요한 검사기입니다. HTML5 &lt;code&gt;&lt;a href=&quot;patternvalidator&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; 속성 을 사용하는 경우이 유효성 검사기도 기본적으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="76256d2b6665f1a3f3640f2890572f05710a20d7" translate="yes" xml:space="preserve">
          <source>Validator that requires the length of the control's value to be greater than or equal to the provided minimum length. This validator is also provided by default if you use the the HTML5 &lt;code&gt;&lt;a href=&quot;minlengthvalidator&quot;&gt;minlength&lt;/a&gt;&lt;/code&gt; attribute.</source>
          <target state="translated">컨트롤 값의 길이가 제공된 최소 길이 이상이어야하는 유효성 검사기. HTML5 &lt;code&gt;&lt;a href=&quot;minlengthvalidator&quot;&gt;minlength&lt;/a&gt;&lt;/code&gt; 속성 을 사용하는 경우이 유효성 검사기도 기본적으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a0867d5adea8f066810bd656c7ccd470cc1ce76" translate="yes" xml:space="preserve">
          <source>Validator that requires the length of the control's value to be greater than or equal to the provided minimum length. This validator is also provided by default if you use the the HTML5 &lt;code&gt;&lt;a href=&quot;minlengthvalidator&quot;&gt;minlength&lt;/a&gt;&lt;/code&gt; attribute. Note that the &lt;code&gt;minLength&lt;/code&gt; validator is intended to be used only for types that have a numeric &lt;code&gt;length&lt;/code&gt; property, such as strings or arrays. The &lt;code&gt;minLength&lt;/code&gt; validator logic is also not invoked for values when their &lt;code&gt;length&lt;/code&gt; property is 0 (for example in case of an empty string or an empty array), to support optional controls. You can use the standard &lt;code&gt;required&lt;/code&gt; validator if empty values should not be considered valid.</source>
          <target state="translated">컨트롤 값의 길이가 제공된 최소 길이보다 크거나 같아야하는 유효성 검사기입니다. 이 유효성 검사기는 HTML5 &lt;code&gt;&lt;a href=&quot;minlengthvalidator&quot;&gt;minlength&lt;/a&gt;&lt;/code&gt; 속성 을 사용하는 경우 기본적으로 제공됩니다 . 있습니다 &lt;code&gt;minLength&lt;/code&gt; 검증 의도는 단지 숫자가 유형에 사용되는 &lt;code&gt;length&lt;/code&gt; 와 같은 문자열이나 배열과 같은 속성을. &lt;code&gt;minLength&lt;/code&gt; 그 때 검증 로직은 또한 값을 호출되지 &lt;code&gt;length&lt;/code&gt; 속성은 선택 제어를 지원하기 위해, (빈 문자열 또는 빈 어레이의 경우, 예를 들어) 0이다. 빈 값이 유효하지 않은 것으로 간주되어야하는 경우 표준 &lt;code&gt;required&lt;/code&gt; 유효성 검사기를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f9d855798656a116c1182141d94fad28454e4e72" translate="yes" xml:space="preserve">
          <source>Validator that requires the length of the control's value to be less than or equal to the provided maximum length. This validator is also provided by default if you use the the HTML5 &lt;code&gt;&lt;a href=&quot;maxlengthvalidator&quot;&gt;maxlength&lt;/a&gt;&lt;/code&gt; attribute.</source>
          <target state="translated">컨트롤 값의 길이가 제공된 최대 길이보다 작거나 같아야하는 유효성 검사기입니다. HTML5 &lt;code&gt;&lt;a href=&quot;maxlengthvalidator&quot;&gt;maxlength&lt;/a&gt;&lt;/code&gt; 속성 을 사용하는 경우이 유효성 검사기도 기본적으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="487df83e2693925e041f945b95d30190bfa4f832" translate="yes" xml:space="preserve">
          <source>Validator that requires the length of the control's value to be less than or equal to the provided maximum length. This validator is also provided by default if you use the the HTML5 &lt;code&gt;&lt;a href=&quot;maxlengthvalidator&quot;&gt;maxlength&lt;/a&gt;&lt;/code&gt; attribute. Note that the &lt;code&gt;maxLength&lt;/code&gt; validator is intended to be used only for types that have a numeric &lt;code&gt;length&lt;/code&gt; property, such as strings or arrays.</source>
          <target state="translated">컨트롤 값의 길이가 제공된 최대 길이보다 작거나 같아야하는 유효성 검사기입니다. 이 유효성 검사기는 HTML5 &lt;code&gt;&lt;a href=&quot;maxlengthvalidator&quot;&gt;maxlength&lt;/a&gt;&lt;/code&gt; 속성 을 사용하는 경우 기본적으로 제공됩니다 . 있습니다 &lt;code&gt;maxLength&lt;/code&gt; 유효성 의도는 단지 숫자가 유형에 사용되는 &lt;code&gt;length&lt;/code&gt; 와 같은 문자열이나 배열과 같은 속성을.</target>
        </trans-unit>
        <trans-unit id="d29f76e695670cc31b55309fdad4de99247e6232" translate="yes" xml:space="preserve">
          <source>ValidatorFn</source>
          <target state="translated">ValidatorFn</target>
        </trans-unit>
        <trans-unit id="762f13c2259b5fbab6d8f1bdbab081fc48bc558f" translate="yes" xml:space="preserve">
          <source>Validators</source>
          <target state="translated">Validators</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="d2f1e7eaab356f70c51f6149188803cfa1f41bd2" translate="yes" xml:space="preserve">
          <source>Value providers</source>
          <target state="translated">가치 제공자</target>
        </trans-unit>
        <trans-unit id="20f9ff3e7294e59511661cc02c6349a3f6b1ebb7" translate="yes" xml:space="preserve">
          <source>Value providers: &lt;code&gt;&lt;a href=&quot;../api/core/valuesansprovider#useValue&quot;&gt;useValue&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">가치 제공자 : &lt;code&gt;&lt;a href=&quot;../api/core/valuesansprovider#useValue&quot;&gt;useValue&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="25f9d5bb9c9dd4305a271cfc44d983bba614126f" translate="yes" xml:space="preserve">
          <source>Value providers: &lt;code&gt;useValue&lt;/code&gt;</source>
          <target state="translated">값 공급자 : &lt;code&gt;useValue&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8fe3282b947225da293afc6b4fd0512f85bae210" translate="yes" xml:space="preserve">
          <source>ValueProvider</source>
          <target state="translated">ValueProvider</target>
        </trans-unit>
        <trans-unit id="e16f3c18243dc608a013837c5a79a4d00bdb7bc7" translate="yes" xml:space="preserve">
          <source>ValueSansProvider</source>
          <target state="translated">ValueSansProvider</target>
        </trans-unit>
        <trans-unit id="79e81c362d5847056b9ba6e53d829959e1399f27" translate="yes" xml:space="preserve">
          <source>Verifies that component/directive bindings are assignable to their &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt;s.</source>
          <target state="translated">구성 요소 / 지시문 바인딩이 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 할당 될 수 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="b9d5ce313e72eaec1313ad42fb993ad994a915f5" translate="yes" xml:space="preserve">
          <source>Verify lazy loading</source>
          <target state="translated">지연로드 확인</target>
        </trans-unit>
        <trans-unit id="5d5c6b67c9db0e498e790e883c5de52f385275d8" translate="yes" xml:space="preserve">
          <source>Verify that no unmatched requests are outstanding.</source>
          <target state="translated">일치하지 않는 요청이 없는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="433043efcea8c296c2c86998af2610b61eb1bd31" translate="yes" xml:space="preserve">
          <source>Verify that the components and &lt;code&gt;NgModules&lt;/code&gt; that you want to be lazy loaded are only imported in lazy modules. Anything that you import outside lazy modules can end up in the main bundle. See more details in the original issue &lt;a href=&quot;https://github.com/angular/angular-cli/issues/16146#issuecomment-557559287&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">지연로드하려는 구성 요소 및 &lt;code&gt;NgModules&lt;/code&gt; 가 지연 모듈에서만 가져 왔는지 확인합니다. 지연 모듈 외부에서 가져 오는 모든 항목은 기본 번들에 포함될 수 있습니다. &lt;a href=&quot;https://github.com/angular/angular-cli/issues/16146#issuecomment-557559287&quot;&gt;여기&lt;/a&gt; 에서 원본 호에 대한 자세한 내용을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b66631d951d23c25649362aeacc4bfae2223488" translate="yes" xml:space="preserve">
          <source>Verify that your new application runs as expected by running the &lt;code&gt;ng serve&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;ng serve&lt;/code&gt; 명령 을 실행하여 새 애플리케이션이 예상대로 실행되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="2da600bf9404843107a9531694f654e5662959e0" translate="yes" xml:space="preserve">
          <source>Version</source>
          <target state="translated">Version</target>
        </trans-unit>
        <trans-unit id="81c258b63dad449560a58fedcf568dc6b8a49576" translate="yes" xml:space="preserve">
          <source>Version from which to migrate from. Only available with a single package being updated, and only on migration only.</source>
          <target state="translated">마이그레이션 할 버전입니다. 단일 패키지가 업데이트되고 마이그레이션에서만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="fc66ec0d0963a90667a2ecf160141fe6e6b47961" translate="yes" xml:space="preserve">
          <source>Version up to which to apply migrations. Only available with a single package being updated, and only on migrations only. Requires from to be specified. Default to the installed version detected.</source>
          <target state="translated">마이그레이션을 적용 할 버전입니다. 단일 패키지가 업데이트되고 마이그레이션에서만 사용 가능합니다. from을 지정해야합니다. 설치된 버전으로 기본 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad05dbfb7d147c73816ab1fecdddddf16429566f" translate="yes" xml:space="preserve">
          <source>Versioning, release, support, and deprecation practices: &lt;a href=&quot;releases&quot;&gt;Angular versioning and releases&lt;/a&gt;</source>
          <target state="translated">버전 관리, 릴리스, 지원 및 사용 중단 사례 : &lt;a href=&quot;releases&quot;&gt;각도 버전 관리 및 릴리스&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d61d71eba7579e925f6872e472a203aa245cb90c" translate="yes" xml:space="preserve">
          <source>View Engine</source>
          <target state="translated">엔진보기</target>
        </trans-unit>
        <trans-unit id="40e309254a1c09b7db3fd4b9af2fa9ecaa53129a" translate="yes" xml:space="preserve">
          <source>View encapsulation</source>
          <target state="translated">캡슐화보기</target>
        </trans-unit>
        <trans-unit id="63a105276cb081db80a13c002ab391c84407745d" translate="yes" xml:space="preserve">
          <source>View hierarchies can be loaded and unloaded dynamically as the user navigates through the application, typically under the control of a &lt;a href=&quot;glossary#router&quot;&gt;router&lt;/a&gt;.</source>
          <target state="translated">사용자가 일반적으로 &lt;a href=&quot;glossary#router&quot;&gt;라우터&lt;/a&gt; 의 제어하에 애플리케이션을 탐색 할 때 뷰 계층을 동적으로로드 및 언로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ced146390f04d6176a1c9baafe3663557cd5bb9c" translate="yes" xml:space="preserve">
          <source>View queries are set before the &lt;code&gt;ngAfterViewInit&lt;/code&gt; callback is called.</source>
          <target state="translated">&lt;code&gt;ngAfterViewInit&lt;/code&gt; 콜백이 호출 되기 전에 뷰 쿼리가 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="ebeb1f94b601a60ee19af9034a126d23b7c58415" translate="yes" xml:space="preserve">
          <source>View your application again. As you click one of the buttons, the style for that button updates automatically, identifying the active component to the user. By adding the &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive&quot;&gt;routerLinkActive&lt;/a&gt;&lt;/code&gt; directive, you inform your application to apply a specific CSS class to the active route. In this tutorial, that CSS class is &lt;code&gt;activebutton&lt;/code&gt;, but you could use any class that you want.</source>
          <target state="translated">응용 프로그램을 다시보십시오. 버튼 중 하나를 클릭하면 해당 버튼의 스타일이 자동으로 업데이트되어 사용자에게 활성 구성 요소를 식별합니다. &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive&quot;&gt;routerLinkActive&lt;/a&gt;&lt;/code&gt; 지시문 을 추가하여 특정 CSS 클래스를 활성 경로에 적용하도록 애플리케이션에 알립니다. 이 튜토리얼에서 CSS 클래스는 &lt;code&gt;activebutton&lt;/code&gt; 이지만 원하는 클래스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="308ca7e0a726c37fbdc046355cce21f2ff308ab7" translate="yes" xml:space="preserve">
          <source>View your updated application in your browser. You should see only the application title. To view the &lt;code&gt;crisis-list&lt;/code&gt; component, add &lt;code&gt;crisis-list&lt;/code&gt; to the end of the path in your browser's address bar. For example:</source>
          <target state="translated">브라우저에서 업데이트 된 애플리케이션을 봅니다. 애플리케이션 제목 만 표시되어야합니다. &lt;code&gt;crisis-list&lt;/code&gt; 구성 요소 를 보려면 브라우저 주소 표시 줄의 경로 끝에 &lt;code&gt;crisis-list&lt;/code&gt; 을 추가 하십시오. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="70b22bdcbbd499b2cd172768582a04965d178285" translate="yes" xml:space="preserve">
          <source>ViewChild</source>
          <target state="translated">ViewChild</target>
        </trans-unit>
        <trans-unit id="731e75cc493e2b3f0e1520064261281cd209667b" translate="yes" xml:space="preserve">
          <source>ViewChildren</source>
          <target state="translated">ViewChildren</target>
        </trans-unit>
        <trans-unit id="c0b27cd972ffd1977642761def1f7be9a42f5afa" translate="yes" xml:space="preserve">
          <source>ViewContainerRef</source>
          <target state="translated">ViewContainerRef</target>
        </trans-unit>
        <trans-unit id="e5240a7ff11b6693e9588a24feef5960dd5495b8" translate="yes" xml:space="preserve">
          <source>ViewEncapsulation</source>
          <target state="translated">ViewEncapsulation</target>
        </trans-unit>
        <trans-unit id="bb27c41c6081cf7c9006a0c2e01017e596206e38" translate="yes" xml:space="preserve">
          <source>ViewRef</source>
          <target state="translated">ViewRef</target>
        </trans-unit>
        <trans-unit id="85787f7a1fbf5317a97c6316e18e928d4f590507" translate="yes" xml:space="preserve">
          <source>ViewportScroller</source>
          <target state="translated">ViewportScroller</target>
        </trans-unit>
        <trans-unit id="aa8824d0dbe6def19d33585bef0db1c629139af5" translate="yes" xml:space="preserve">
          <source>Views are typically arranged hierarchically, allowing you to modify or show and hide entire UI sections or pages as a unit. The template immediately associated with a component defines that component's &lt;em&gt;host view&lt;/em&gt;. The component can also define a &lt;em&gt;view hierarchy&lt;/em&gt;, which contains &lt;em&gt;embedded views&lt;/em&gt;, hosted by other components.</source>
          <target state="translated">보기는 일반적으로 계층 적으로 정렬되므로 전체 UI 섹션 또는 페이지를 한 단위로 수정하거나 표시하거나 숨길 수 있습니다. 컴포넌트와 즉시 연관된 템플리트는 해당 컴포넌트의 &lt;em&gt;호스트보기를&lt;/em&gt; 정의합니다 . 구성 요소는 다른 구성 요소에서 호스팅 하는 포함 &lt;em&gt;된 뷰&lt;/em&gt; 가 포함 &lt;em&gt;된 &lt;/em&gt;&lt;em&gt;뷰 계층 구조를&lt;/em&gt; 정의 할 수도 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f1386eabb408835f08cb05d409256f611a521fdc" translate="yes" xml:space="preserve">
          <source>Visibility decorators influence where the search for the injection token begins and ends in the logic tree. To do this, place visibility decorators at the point of injection, that is, the &lt;code&gt;constructor()&lt;/code&gt;, rather than at a point of declaration.</source>
          <target state="translated">가시성 데코레이터는 주입 토큰 검색이 로직 트리에서 시작하고 끝나는 위치에 영향을줍니다. 이렇게하려면 가시성 데코레이터를 선언 지점이 아닌 주입 지점, 즉 &lt;code&gt;constructor()&lt;/code&gt; 에 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="01354e09c47bfba10344c316d3973dd8d8c0c124" translate="yes" xml:space="preserve">
          <source>Visibility of provided tokens</source>
          <target state="translated">제공된 토큰의 가시성</target>
        </trans-unit>
        <trans-unit id="423f1f3d80c4d824ca917e13649a5c584a13ec87" translate="yes" xml:space="preserve">
          <source>Visual Studio Code</source>
          <target state="translated">비주얼 스튜디오 코드</target>
        </trans-unit>
        <trans-unit id="5bd87aebeff1926fd4da28c306978ef7e958002f" translate="yes" xml:space="preserve">
          <source>Visual Studio now looks first for external tools in the current workspace and if it doesn't find them, it looks in the global path. If Visual Studio doesn't find them in either location, it will use its own versions of the tools.</source>
          <target state="translated">Visual Studio는 현재 현재 작업 공간에서 외부 도구를 먼저 찾고, 찾지 못하면 전역 경로를 찾습니다. Visual Studio가 어느 위치에서나 찾지 못하면 자체 버전의 도구를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cf912685bcd3b8695b78564cf9cc45a83ef11075" translate="yes" xml:space="preserve">
          <source>Visual Studio ships with IIS Express, which has the rewrite module baked in. However, if you're using regular IIS you'll have to install the rewrite module.</source>
          <target state="translated">Visual Studio에는 다시 쓰기 모듈이 포함 된 IIS Express가 제공됩니다. 그러나 일반 IIS를 사용하는 경우 다시 쓰기 모듈을 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a00dd5a3fe4b1a6a174763f1ccc3255c559d786" translate="yes" xml:space="preserve">
          <source>Visualize a &lt;em&gt;banana in a box&lt;/em&gt; to remember that the parentheses go &lt;em&gt;inside&lt;/em&gt; the brackets.</source>
          <target state="translated">시각화 &lt;em&gt;상자에 바나나를&lt;/em&gt; 괄호가는 것을 기억하는 것이 &lt;em&gt;내부에&lt;/em&gt; 괄호.</target>
        </trans-unit>
        <trans-unit id="ae20d0dcd36854dd9c33ee0729b11a0b952fd48f" translate="yes" xml:space="preserve">
          <source>Void state</source>
          <target state="translated">무효 상태</target>
        </trans-unit>
        <trans-unit id="363d01361c13e93cb5c5849c62cc7a9e5fb2a36f" translate="yes" xml:space="preserve">
          <source>Voil&amp;agrave;! &lt;code&gt;['/crisis-center']&lt;/code&gt;.</source>
          <target state="translated">oil! &lt;code&gt;['/crisis-center']&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="7d863250597b39573e59f2dd5bbdb466dcefa3eb" translate="yes" xml:space="preserve">
          <source>W3C - Web Accessibility Initiative</source>
          <target state="translated">W3C-웹 접근성 이니셔티브</target>
        </trans-unit>
        <trans-unit id="a8973c4ad76d66d81020d94041af9480559aca02" translate="yes" xml:space="preserve">
          <source>WARNING: this pipe uses the Internationalization API which is not yet available in all browsers and may require a polyfill. See &lt;a href=&quot;../../guide/browser-support&quot;&gt;Browser Support&lt;/a&gt; for details.</source>
          <target state="translated">경고 :이 파이프는 아직 모든 브라우저에서 사용할 수없는 국제화 API를 사용하며 폴리 필이 필요할 수 있습니다. 자세한 내용은 &lt;a href=&quot;../../guide/browser-support&quot;&gt;브라우저 지원&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c07ec44ed7c7c12105929adc7842d7938752526a" translate="yes" xml:space="preserve">
          <source>WARNINGS:</source>
          <target state="translated">WARNINGS:</target>
        </trans-unit>
        <trans-unit id="6c1d5662bd95a1bc248614055dd45cd2c7c74fae" translate="yes" xml:space="preserve">
          <source>WORKER_APP_LOCATION_PROVIDERS</source>
          <target state="translated">WORKER_APP_LOCATION_PROVIDERS</target>
        </trans-unit>
        <trans-unit id="82986323ee9a26fe8f93325355793336b70d0475" translate="yes" xml:space="preserve">
          <source>WORKER_UI_LOCATION_PROVIDERS</source>
          <target state="translated">WORKER_UI_LOCATION_PROVIDERS</target>
        </trans-unit>
        <trans-unit id="fc298440e65c9e288e74a2aa8c9b6a8c4ae86157" translate="yes" xml:space="preserve">
          <source>WORKSPACE CONFIG FILES</source>
          <target state="translated">작업 공간 구성 파일</target>
        </trans-unit>
        <trans-unit id="7f50a90ea501723c024e4ce68214dc33c2125cb6" translate="yes" xml:space="preserve">
          <source>Wait before updating the view</source>
          <target state="translated">보기를 업데이트하기 전에 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="9ecaf9bcefceb097a640b14a0a1ef2fe6fb7fab4" translate="yes" xml:space="preserve">
          <source>Wait for 100ms and then run for 200ms: &lt;code&gt;'0.2s 100ms'&lt;/code&gt;</source>
          <target state="translated">100ms 동안 기다린 다음 200ms 동안 실행하십시오 : &lt;code&gt;'0.2s 100ms'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7bc78e562cbe874c8773d19cf4be97f0463bbc5e" translate="yes" xml:space="preserve">
          <source>Wait for 100ms, run for 200ms. Use a deceleration curve to start out fast and slowly decelerate to a resting point: &lt;code&gt;'0.2s 100ms ease-out'&lt;/code&gt;</source>
          <target state="translated">100ms 동안 기다렸다가 200ms 동안 실행하십시오. 감속 곡선을 사용하여 정지 점까지 빠르고 천천히 감속합니다 : &lt;code&gt;'0.2s 100ms ease-out'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b5586b3bb95ca7c31cb3c22819d08ba3bebb1c3" translate="yes" xml:space="preserve">
          <source>Wait for the application to be stable with a timeout. If the timeout is reached before that happens, the callback receives a list of the macro tasks that were pending, otherwise null.</source>
          <target state="translated">시간 초과로 응용 프로그램이 안정 될 때까지 기다리십시오. 이 시간이 초과되기 전에 시간 초과에 도달하면 콜백은 보류중인 매크로 작업 목록을받습니다. 그렇지 않으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="5397416bedc6dd6eb062cf6b283a2ffe2c518c96" translate="yes" xml:space="preserve">
          <source>Warning (default): show a 'Missing translation' warning in the console or shell.</source>
          <target state="translated">경고 (기본값) : 콘솔 또는 셸에 '번역 누락'경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="05c345e4ec19aba46a5943dc0f547f62c9342ec1" translate="yes" xml:space="preserve">
          <source>Warning (default): show a warning in the console and/or shell.</source>
          <target state="translated">경고 (기본값) : 콘솔 및 / 또는 셸에 경고를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="88b85d9988679e4293fa4ac6a48242d90d816934" translate="yes" xml:space="preserve">
          <source>Watch mode</source>
          <target state="translated">시계 모드</target>
        </trans-unit>
        <trans-unit id="49da60e0fd25a9b16323dc060a6723765664b496" translate="yes" xml:space="preserve">
          <source>Watching for &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; changes</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 변경 감시</target>
        </trans-unit>
        <trans-unit id="049327f20280160e2798ffbfea9f0196b9c52a75" translate="yes" xml:space="preserve">
          <source>We also share with you the desire for Angular to keep evolving. We strive to ensure that the foundation on top of which you are building is continuously improving and enabling you to stay up-to-date with the rest of the web ecosystem and your user needs.</source>
          <target state="translated">또한 Angular가 계속 발전하기를 원합니다. 우리는 귀하가 구축하고있는 기초가 지속적으로 개선되고 귀하가 나머지 웹 생태계와 사용자 요구에 대해 최신 상태를 유지할 수 있도록 노력하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ec69b5a41d9bbdbb14b7cb006054942a18c5599" translate="yes" xml:space="preserve">
          <source>We are going to design and implement a plan to make Zone.js optional from Angular applications. This way, we will simplify the framework, improve debugging, and reduce application bundle size. Additionally, this will allow us to take advantage of native async/await syntax, which currently Zone.js does not support.</source>
          <target state="translated">Angular 애플리케이션에서 Zone.js를 선택적으로 만들 계획을 설계하고 구현할 것입니다. 이렇게하면 프레임 워크를 단순화하고 디버깅을 개선하며 애플리케이션 번들 크기를 줄일 수 있습니다. 또한 현재 Zone.js에서 지원하지 않는 기본 async / await 구문을 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="367ba1138b6b56e08c59f2f66d2ac44e4a858807" translate="yes" xml:space="preserve">
          <source>We are working on custom elements that can be used by web apps built on other frameworks. A minimal, self-contained version of the Angular framework will be injected as a service to support the component's change-detection and data-binding functionality. For more about the direction of development, check out this &lt;a href=&quot;https://www.youtube.com/watch?v=Z1gLFPLVJjY&amp;amp;t=4s&quot;&gt;video presentation&lt;/a&gt;.</source>
          <target state="translated">다른 프레임 워크를 기반으로 구축 된 웹 앱에서 사용할 수있는 사용자 지정 요소를 연구하고 있습니다. 자체 포함 된 최소한의 Angular 프레임 워크 버전은 구성 요소의 변경 감지 및 데이터 바인딩 기능을 지원하는 서비스로 삽입됩니다. 개발 방향에 대한 자세한 내용은이 &lt;a href=&quot;https://www.youtube.com/watch?v=Z1gLFPLVJjY&amp;amp;t=4s&quot;&gt;비디오 프레젠테이션을&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="27a7cc470628aa2d92ef4427542447f20ef42c23" translate="yes" xml:space="preserve">
          <source>We are working on development tooling for Angular that will provide utilities for debugging and performance profiling. This project aims to help developers understand the component structure and the change detection in an Angular application.</source>
          <target state="translated">우리는 디버깅 및 성능 프로파일 링을위한 유틸리티를 제공 할 Angular 용 개발 도구를 개발 중입니다. 이 프로젝트는 개발자가 Angular 애플리케이션의 구성 요소 구조 및 변경 감지를 이해하도록 돕는 것을 목표로합니다.</target>
        </trans-unit>
        <trans-unit id="e6a5c87a2d5a877756756b0475d44bae01c02874" translate="yes" xml:space="preserve">
          <source>We ask all contributing authors to adhere to three aspects of style:</source>
          <target state="translated">모든 기고자에게 스타일의 세 가지 측면을 준수하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="ec11a33a55c211bc5d98f96df3c7c4a5d0617287" translate="yes" xml:space="preserve">
          <source>We can delay updating the form validity by changing the &lt;code&gt;updateOn&lt;/code&gt; property from &lt;code&gt;change&lt;/code&gt; (default) to &lt;code&gt;submit&lt;/code&gt; or &lt;code&gt;blur&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;updateOn&lt;/code&gt; 속성을 &lt;code&gt;change&lt;/code&gt; (기본값)에서 &lt;code&gt;submit&lt;/code&gt; 또는 &lt;code&gt;blur&lt;/code&gt; 로 변경하여 양식 유효성 업데이트를 지연시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd8e866ad285f0dc9892217e61259175ebd3fd46" translate="yes" xml:space="preserve">
          <source>We can provide the following schema for type validation of these values.</source>
          <target state="translated">이러한 값의 형식 유효성 검사를 위해 다음 스키마를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2931f0896f596ff16cc12f410c35306a64670a62" translate="yes" xml:space="preserve">
          <source>We can publish the builder to npm (see &lt;a href=&quot;creating-libraries#publishing-your-library&quot;&gt;Publishing your Library&lt;/a&gt;), and install it using the following command:</source>
          <target state="translated">빌더를 npm에 공개하고 ( &lt;a href=&quot;creating-libraries#publishing-your-library&quot;&gt;라이브러리 공개&lt;/a&gt; 참조 ) 다음 명령을 사용하여 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee14b2f048236515de09f569a5537a505db84ddc" translate="yes" xml:space="preserve">
          <source>We can retrieve a Logger instance from the context.</source>
          <target state="translated">컨텍스트에서 Logger 인스턴스를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38e9796d2bd43c6954316dd93675d676d438006d" translate="yes" xml:space="preserve">
          <source>We changed the default value for &lt;code&gt;relativeLinkResolution&lt;/code&gt; from &lt;code&gt;'legacy'&lt;/code&gt; to &lt;code&gt;'corrected'&lt;/code&gt; so that new applications are automatically opted-in to the corrected behavior from &lt;a href=&quot;https://github.com/angular/angular/pull/22394&quot;&gt;PR 22394&lt;/a&gt;. Applications which use the current default are updated by a migration to specify &lt;code&gt;'legacy'&lt;/code&gt; to ensure the current behavior is maintained when the default is updated. See &lt;a href=&quot;https://github.com/angular/angular/pull/25609&quot;&gt;PR 25609&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;relativeLinkResolution&lt;/code&gt; 의 기본값 을 &lt;code&gt;'legacy'&lt;/code&gt; 에서 &lt;code&gt;'corrected'&lt;/code&gt; 로 변경 하여 새 응용 프로그램이 &lt;a href=&quot;https://github.com/angular/angular/pull/22394&quot;&gt;PR 22394&lt;/a&gt; 의 수정 된 동작에 자동으로 옵트 인되도록 했습니다 . 현재 기본값을 사용하는 애플리케이션은 마이그레이션을 통해 업데이트되어 기본값이 업데이트 될 때 현재 동작이 유지되도록 &lt;code&gt;'legacy'&lt;/code&gt; 를 지정 합니다. &lt;a href=&quot;https://github.com/angular/angular/pull/25609&quot;&gt;PR 25609를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed979d867401216782d14206d29678b5df7afa90" translate="yes" xml:space="preserve">
          <source>We follow the deprecation policy described here, so you have time to update your apps to the latest APIs and best practices.</source>
          <target state="translated">여기에 설명 된 지원 중단 정책을 따르므로 앱을 최신 API 및 모범 사례로 업데이트 할 시간이 있습니다.</target>
        </trans-unit>
        <trans-unit id="72290b6faa8277fff5d3a8e9271b1ec87738226e" translate="yes" xml:space="preserve">
          <source>We have a set of benchmarks that we run against every code change to ensure Angular aligns with our performance standards. To ensure the framework&amp;rsquo;s runtime does not regress after a code change, we need to refine some of the existing infrastructure the dashboards step on.</source>
          <target state="translated">Angular가 성능 표준에 부합하는지 확인하기 위해 모든 코드 변경에 대해 실행하는 일련의 벤치 마크가 있습니다. 코드 변경 후 프레임 워크의 런타임이 회귀하지 않도록하려면 대시 보드가 실행하는 기존 인프라의 일부를 개선해야합니다.</target>
        </trans-unit>
        <trans-unit id="e9b76a51b7a99c79ff1cc0f3f2bebb68cb9f17f8" translate="yes" xml:space="preserve">
          <source>We have discussed the basic HTTP functionality in &lt;code&gt;@angular/common/&lt;a href=&quot;../api/common/http&quot;&gt;http&lt;/a&gt;&lt;/code&gt;, but sometimes you need to do more than make simple requests and get data back.</source>
          <target state="translated">&lt;code&gt;@angular/common/&lt;a href=&quot;../api/common/http&quot;&gt;http&lt;/a&gt;&lt;/code&gt; 의 기본 HTTP 기능에 대해 논의 했지만 때로는 간단한 요청을하고 데이터를 다시 가져 오는 것 이상을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="66c4f344bcf7591de9ea36041b341b78c75479da" translate="yes" xml:space="preserve">
          <source>We let you preview what's coming by providing &quot;Next&quot; and Release Candidates (&lt;code&gt;rc&lt;/code&gt;) pre-releases for each major and minor release:</source>
          <target state="translated">각 메이저 및 마이너 릴리스에 대해 &quot;다음&quot;및 릴리스 후보 ( &lt;code&gt;rc&lt;/code&gt; ) 사전 릴리스를 제공하여 향후 출시 될 제품을 미리 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3da62ac46ab52ae87815d94ca4d56bf01a862f1" translate="yes" xml:space="preserve">
          <source>We let you preview what's coming by providing Beta releases and Release Candidates (&lt;code&gt;rc&lt;/code&gt;) for each major and minor release:</source>
          <target state="translated">각 주 및 부 릴리스에 대해 베타 릴리스 및 릴리스 후보 ( &lt;code&gt;rc&lt;/code&gt; )를 제공하여 예정된 내용을 미리 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b91a3f18bcf41bca5f95939f116cf6e3d59216ba" translate="yes" xml:space="preserve">
          <source>We meet this goal by displaying code snippets that are derived directly from standalone code samples, written specifically for these guide pages.</source>
          <target state="translated">이 가이드 페이지를 위해 특별히 작성된 독립형 코드 샘플에서 직접 파생 된 코드 스 니펫을 표시하여이 목표를 달성합니다.</target>
        </trans-unit>
        <trans-unit id="3137f17ffcf69ea0fc771d5e9d7c10273ff1f4f9" translate="yes" xml:space="preserve">
          <source>We must create a &lt;code&gt;&lt;a href=&quot;../../core/directive&quot;&gt;Directive&lt;/a&gt;&lt;/code&gt; that will make this AngularJS component available inside Angular templates.</source>
          <target state="translated">이 AngularJS 컴포넌트를 Angular 템플릿 내에서 사용할 수 있도록 &lt;code&gt;&lt;a href=&quot;../../core/directive&quot;&gt;Directive&lt;/a&gt;&lt;/code&gt; 을 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cf1fc25d3116f8dea78230e2816ca8675a89a9fe" translate="yes" xml:space="preserve">
          <source>We must create an AngularJS &lt;a href=&quot;https://docs.angularjs.org/guide/directive&quot;&gt;directive&lt;/a&gt; that will make this Angular component available inside AngularJS templates. The &lt;code&gt;&lt;a href=&quot;downgradecomponent&quot;&gt;downgradeComponent&lt;/a&gt;()&lt;/code&gt; function returns a factory function that we can use to define the AngularJS directive that wraps the &quot;downgraded&quot; component.</source>
          <target state="translated">AngularJS 템플릿 내에서이 Angular 컴포넌트를 사용할 수 있도록 AngularJS &lt;a href=&quot;https://docs.angularjs.org/guide/directive&quot;&gt;지시문&lt;/a&gt; 을 작성해야합니다 . &lt;code&gt;&lt;a href=&quot;downgradecomponent&quot;&gt;downgradeComponent&lt;/a&gt;()&lt;/code&gt; 함수가 반환은 우리가 AngularJS와를 정의하는 데 사용할 수있는 공장 함수는이 (가) 구성 요소를 &quot;다운 그레이드&quot;래핑 지시어.</target>
        </trans-unit>
        <trans-unit id="4f0b3a7bbc11be9ec5f1d0d0772101f30b20afa5" translate="yes" xml:space="preserve">
          <source>We need to update the &lt;code&gt;angular.json&lt;/code&gt; file to add a target for this builder to the &quot;architect&quot; section of our new project.</source>
          <target state="translated">우리는 업데이트해야합니다 &lt;code&gt;angular.json&lt;/code&gt; 이 빌더의 대상을 새 프로젝트의 &quot;architect&quot;섹션에 추가 angular.json 파일 .</target>
        </trans-unit>
        <trans-unit id="7f07def30e46276be4e20aec308dade0a77d9924" translate="yes" xml:space="preserve">
          <source>We now have the framework in place for creating the code that actually modifies the user's application to set it up for the service defined in your library.</source>
          <target state="translated">이제 사용자의 응용 프로그램을 실제로 수정하여 라이브러리에 정의 된 서비스에 맞게 설정하는 코드를 작성하기위한 프레임 워크가 마련되었습니다.</target>
        </trans-unit>
        <trans-unit id="fdfba83206c23f3c099770c464e3ad4b48b0dbb9" translate="yes" xml:space="preserve">
          <source>We recognize that you need stability from the Angular framework. Stability ensures that reusable components and libraries, tutorials, tools, and learned practices don't become obsolete unexpectedly. Stability is essential for the ecosystem around Angular to thrive.</source>
          <target state="translated">Angular 프레임 워크의 안정성이 필요하다는 것을 알고 있습니다. 안정성은 재사용 가능한 컴포넌트 및 라이브러리, 학습서, 도구 및 학습 된 실습이 예기치 않게 사용되지 않도록합니다. 안정성은 Angular 주변의 생태계가 번창하기 위해 필수적입니다.</target>
        </trans-unit>
        <trans-unit id="81f1aefebd400f644100c7e391b9ffa63bfd67c9" translate="yes" xml:space="preserve">
          <source>We recommend that you always update to the latest patch version, as it contains fixes we released since the initial major release. For example, use the following command to take the latest 10.x.x version and use that to update.</source>
          <target state="translated">초기 주요 릴리스 이후에 릴리스 된 수정 사항이 포함되어 있으므로 항상 최신 패치 버전으로 업데이트하는 것이 좋습니다. 예를 들어 다음 명령을 사용하여 최신 10.xx 버전을 가져 와서 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="77d09fc97147b2ef90d76928341a69ca7bde154c" translate="yes" xml:space="preserve">
          <source>We recommend that you always update to the latest patch version, as it contains fixes we released since the initial major release. For example, use the following command to take the latest 7.x.x version and use that to update.</source>
          <target state="translated">초기 주요 릴리스 이후 릴리스 된 수정 프로그램이 포함되어 있으므로 항상 최신 패치 버전으로 업데이트하는 것이 좋습니다. 예를 들어, 다음 명령을 사용하여 최신 7.xx 버전을 가져 와서 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="775687186195b9a3e24a2f53506fea1a527d8ea0" translate="yes" xml:space="preserve">
          <source>We recommend that you do not force an update of all dependencies by default. Try updating specific dependencies first.</source>
          <target state="translated">기본적으로 모든 종속성을 강제로 업데이트하지 않는 것이 좋습니다. 특정 종속성을 먼저 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="80be1bb38ec0ca675a20185b65c4dba9e98272bb" translate="yes" xml:space="preserve">
          <source>We recommend that you use integration tests to test Architect builders. You can use unit tests to validate the logic that the builder executes.</source>
          <target state="translated">통합 테스트를 사용하여 Architect 빌더를 테스트하는 것이 좋습니다. 단위 테스트를 사용하여 빌더가 실행하는 논리를 유효성 검증 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="310cfdcf5af5f6be333c6538a69706c32e03c366" translate="yes" xml:space="preserve">
          <source>We want the user to click a product name to display the details for that product.</source>
          <target state="translated">사용자가 제품 이름을 클릭하여 해당 제품의 세부 사항을 표시하기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="694477aae6323c7aef0646862fb1b7d445cc1fd9" translate="yes" xml:space="preserve">
          <source>We want to consolidate release management tooling between Angular's multiple GitHub repositories (&lt;a href=&quot;https://github.com/angular/angular&quot;&gt;angular/angular&lt;/a&gt;, &lt;a href=&quot;https://github.com/angular/angular-cli&quot;&gt;angular/angular-cli&lt;/a&gt;, and &lt;a href=&quot;https://github.com/angular/components&quot;&gt;angular/components&lt;/a&gt;). This effort will allow us to reuse infrastructure, unify and simplify processes, and improve our release process's reliability.</source>
          <target state="translated">Angular의 여러 GitHub 저장소 ( &lt;a href=&quot;https://github.com/angular/angular&quot;&gt;angular / angular&lt;/a&gt; , &lt;a href=&quot;https://github.com/angular/angular-cli&quot;&gt;angular / angular-cli&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/angular/components&quot;&gt;angular / components&lt;/a&gt; ) 간에 릴리스 관리 도구를 통합하려고합니다 . 이러한 노력을 통해 인프라를 재사용하고 프로세스를 통합 및 단순화하며 릴리스 프로세스의 안정성을 개선 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c281f6d14cab33a840c42011f9bdf5c0cf84d8ff" translate="yes" xml:space="preserve">
          <source>We want to ensure Angular developers are taking advantage of the latest capabilities of RxJS and have a smooth transition to the next major releases of the framework. For this purpose, we will explore and document the scope of the changes in v7 and beyond of RxJS and plan an update strategy.</source>
          <target state="translated">Angular 개발자는 RxJS의 최신 기능을 활용하고 프레임 워크의 다음 주요 릴리스로 원활하게 전환 할 수 있기를 바랍니다. 이를 위해 RxJS v7 및 그 이후의 변경 사항 범위를 탐색 및 문서화하고 업데이트 전략을 계획합니다.</target>
        </trans-unit>
        <trans-unit id="963319a4bbeb2a266dbe49a9dbba7d16c6c97bad" translate="yes" xml:space="preserve">
          <source>We want to hear from you. &lt;a href=&quot;https://github.com/angular/angular/issues/new/choose&quot;&gt;Report problems or submit suggestions for future docs.&lt;/a&gt;</source>
          <target state="translated">우리는 당신의 의견을 듣고 싶습니다. &lt;a href=&quot;https://github.com/angular/angular/issues/new/choose&quot;&gt;문제를보고하거나 향후 문서에 대한 제안을 제출하십시오.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cdfa864a5f131ff38ec02671e103f454912d4e8f" translate="yes" xml:space="preserve">
          <source>We want to hear from you. &lt;a href=&quot;https://github.com/angular/angular/issues/new/choose&quot;&gt;Report problems or submit suggestions for future docs&lt;/a&gt;.</source>
          <target state="translated">여러분의 의견을 듣고 싶습니다. &lt;a href=&quot;https://github.com/angular/angular/issues/new/choose&quot;&gt;문제를보고하거나 향후 문서에 대한 제안을 제출하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75a1ee0c723a64b8d89f14da0c05fdaf2316016f" translate="yes" xml:space="preserve">
          <source>We want to unify commit message requirements and conformance across Angular repositories (&lt;a href=&quot;https://github.com/angular/angular&quot;&gt;angular/angular&lt;/a&gt;, &lt;a href=&quot;https://github.com/angular/components&quot;&gt;angular/components&lt;/a&gt;, &lt;a href=&quot;https://github.com/angular/angular-cli&quot;&gt;angular/angular-cli&lt;/a&gt;) to bring consistency to our development process and reuse infrastructure tooling.</source>
          <target state="translated">Angular 리포지토리 ( &lt;a href=&quot;https://github.com/angular/angular&quot;&gt;angular / angular&lt;/a&gt; , &lt;a href=&quot;https://github.com/angular/components&quot;&gt;angular / components&lt;/a&gt; , &lt;a href=&quot;https://github.com/angular/angular-cli&quot;&gt;angular / angular-cli&lt;/a&gt; )에서 커밋 메시지 요구 사항과 적합성을 통합하여 개발 프로세스에 일관성을 부여하고 인프라 도구를 재사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="e5da26ddb38c8d5f891d4d9115d7b2c0845ef29a" translate="yes" xml:space="preserve">
          <source>We will redefine the user learning journeys and refresh the introductory documentation. We will clearly state the benefits of Angular, how to explore its capabilities and provide guidance so developers can become proficient with the framework in as little time as possible.</source>
          <target state="translated">사용자 학습 여정을 재정의하고 소개 문서를 새로 고칠 것입니다. Angular의 이점, 기능을 탐색하는 방법 및 지침을 제공하여 개발자가 가능한 한 짧은 시간에 프레임 워크에 능숙해질 수 있도록 명확하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="03e48ed186e1bd1b4af5363a6a8f174374449a43" translate="yes" xml:space="preserve">
          <source>We will work on implementing stricter type checking for reactive forms. This way, we will allow developers to catch more issues during development time, enable better text editor and IDE support, and improve the type checking for reactive forms.</source>
          <target state="translated">우리는 반응 형에 대해 더 엄격한 유형 검사를 구현하기 위해 노력할 것입니다. 이렇게하면 개발자가 개발 중에 더 많은 문제를 포착하고 더 나은 텍스트 편집기 및 IDE 지원을 활성화하며 반응 형 양식에 대한 유형 검사를 개선 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08ccad7003f1e35885c0a7207dc4655e386f189a" translate="yes" xml:space="preserve">
          <source>We work hard to minimize the number of breaking changes and to provide migration tools when possible.</source>
          <target state="translated">우리는 주요 변경 사항의 수를 최소화하고 가능한 경우 마이그레이션 도구를 제공하기 위해 노력하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="80ef513b5b64fa187df26f2b88bdd0df53b470f9" translate="yes" xml:space="preserve">
          <source>We work toward a regular schedule of releases, so that you can plan and coordinate your updates with the continuing evolution of Angular.</source>
          <target state="translated">우리는 정기적 인 릴리스 일정을 향해 노력하고 있으므로 Angular의 지속적인 발전으로 업데이트를 계획하고 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f7ca8850d7d3e95260cdb1a36e87b1bd5a2f9ab" translate="yes" xml:space="preserve">
          <source>We'll add a new target section to the &quot;architect&quot; object for our project.</source>
          <target state="translated">프로젝트의 &quot;architect&quot;객체에 새로운 대상 섹션을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1f0e521cbcb2ebaba4d1dd2e5a53e9662e8db9ca" translate="yes" xml:space="preserve">
          <source>We'll assume that your library defines a service, &lt;code&gt;my-service&lt;/code&gt;, that requires some setup. You want your users to be able to generate it using the following CLI command.</source>
          <target state="translated">라이브러리 가 설정이 필요한 &lt;code&gt;my-service&lt;/code&gt; 정의한다고 가정합니다 . 다음 CLI 명령을 사용하여 사용자가이를 생성 할 수 있기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="455855d6e204ab91263b75701fa13e1551077ff1" translate="yes" xml:space="preserve">
          <source>We'll be using &lt;a href=&quot;https://developers.google.com/web/updates/2017/04/headless-chrome#cli&quot;&gt;Headless Chrome&lt;/a&gt; in these examples.</source>
          <target state="translated">이 예에서는 &lt;a href=&quot;https://developers.google.com/web/updates/2017/04/headless-chrome#cli&quot;&gt;헤드리스 크롬&lt;/a&gt; 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="0023425c9a40172e734cbb5e99d9df3d9f24d37a" translate="yes" xml:space="preserve">
          <source>We'll create the cart page in two steps:</source>
          <target state="translated">카트 페이지를 두 단계로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9c13304de9fb7403344d19d9edc7669863094bb9" translate="yes" xml:space="preserve">
          <source>We've added a &lt;code&gt;builders.json&lt;/code&gt; file next to the builder's &lt;a href=&quot;https://github.com/mgechev/cli-builders-demo/blob/master/command-builder/builders.json&quot;&gt;&lt;code&gt;package.json&lt;/code&gt; file&lt;/a&gt;, and modified the package file to point to it.</source>
          <target state="translated">빌더의 &lt;a href=&quot;https://github.com/mgechev/cli-builders-demo/blob/master/command-builder/builders.json&quot;&gt; &lt;code&gt;package.json&lt;/code&gt; &lt;/a&gt; 파일 옆에 &lt;code&gt;builders.json&lt;/code&gt; 파일을 추가했습니다. , 그리고 그것에 지점에 패키지 파일을 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="229504c90b2ed36005a13f0891c6ea34dd49cee8" translate="yes" xml:space="preserve">
          <source>Web Animations</source>
          <target state="translated">웹 애니메이션</target>
        </trans-unit>
        <trans-unit id="c689af566e60edb050fba04883329a2b969d41aa" translate="yes" xml:space="preserve">
          <source>Web Tracing Framework integration</source>
          <target state="translated">웹 추적 프레임 워크 통합</target>
        </trans-unit>
        <trans-unit id="c5b6d6d89517eff4ce180cea4ab387ae48e094cb" translate="yes" xml:space="preserve">
          <source>WebStorm</source>
          <target state="translated">WebStorm</target>
        </trans-unit>
        <trans-unit id="96c7816359b06d625431375d1cbdc07ed4556d66" translate="yes" xml:space="preserve">
          <source>Week day</source>
          <target state="translated">요일</target>
        </trans-unit>
        <trans-unit id="6cb4f0e33b17b0f52c241793df12a1dd4d39da62" translate="yes" xml:space="preserve">
          <source>Week of month</source>
          <target state="translated">매주</target>
        </trans-unit>
        <trans-unit id="b634011cda59925fcb33d601d8b1227879d65bbc" translate="yes" xml:space="preserve">
          <source>Week of year</source>
          <target state="translated">연중 주</target>
        </trans-unit>
        <trans-unit id="5d648c134f4812220981594455e9efb88e207e9e" translate="yes" xml:space="preserve">
          <source>Week-numbering year</source>
          <target state="translated">주 번호 매기기 연도</target>
        </trans-unit>
        <trans-unit id="09cfafc979eda38b81da9ec21690558d2edcbfd0" translate="yes" xml:space="preserve">
          <source>WeekDay</source>
          <target state="translated">WeekDay</target>
        </trans-unit>
        <trans-unit id="ec1d4a2eb821d65b5f91f9b7b510a0c9033552d6" translate="yes" xml:space="preserve">
          <source>Welcome to Angular!</source>
          <target state="translated">Angular에 오신 것을 환영합니다!</target>
        </trans-unit>
        <trans-unit id="f31d5caf28c1c07d1ee03f259600799b9c986539" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; directive? You didn't add an &lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt; directive.</source>
          <target state="translated">어떤 &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; 지시어? &lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm을&lt;/a&gt; 추가하지 않았습니다 지시문을 .</target>
        </trans-unit>
        <trans-unit id="550389c79bd6aad13b8b970d4d70593adcb978c0" translate="yes" xml:space="preserve">
          <source>What are structural directives?</source>
          <target state="translated">구조적 지시문이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="f9f442481556abfd102cc7155daba690e1a9a733" translate="yes" xml:space="preserve">
          <source>What changed?</source>
          <target state="translated">무엇이 바뀌 었습니까?</target>
        </trans-unit>
        <trans-unit id="f8328397c60c8af6da98225a51e8980b05f6b4e4" translate="yes" xml:space="preserve">
          <source>What classes should I &lt;code&gt;not&lt;/code&gt; add to &lt;code&gt;declarations&lt;/code&gt;?</source>
          <target state="translated">어떻게 수업을해야 &lt;code&gt;not&lt;/code&gt; 에 추가 &lt;code&gt;declarations&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="6d27e0d2fc8a84f6cbfebe6fe7c1d1ca3170ab86" translate="yes" xml:space="preserve">
          <source>What classes should I add to the &lt;code&gt;declarations&lt;/code&gt; array?</source>
          <target state="translated">&lt;code&gt;declarations&lt;/code&gt; 배열에 어떤 클래스를 추가해야 합니까?</target>
        </trans-unit>
        <trans-unit id="057eaac6f0deedde6be1f19bfebd7864c77aaaea" translate="yes" xml:space="preserve">
          <source>What do you do about unapproved, unsaved changes when the user navigates away? You can't just leave and risk losing the user's changes; that would be a terrible experience.</source>
          <target state="translated">사용자가 탐색 할 때 승인되지 않은 저장되지 않은 변경 사항에 대해 어떻게합니까? 사용자의 변경 사항을 그대로두고 잃을 위험이 없습니다. 그것은 끔찍한 경험이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="473d6c927a1e922bb838df64558b20be71bcb2f4" translate="yes" xml:space="preserve">
          <source>What does &quot;Can't bind to 'x' since it isn't a known property of 'y'&quot; mean?</source>
          <target state="translated">&quot; 'y'의 알려진 속성이 아니기 때문에 'x'에 바인딩 할 수 없습니다&quot;는 무엇을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="2a4d6e81b7048543cdc7f0bf6420334628995a10" translate="yes" xml:space="preserve">
          <source>What good are these tests?</source>
          <target state="translated">이 테스트는 어떤 점이 좋습니까?</target>
        </trans-unit>
        <trans-unit id="e9ef659a9f0dd7f7a57fd0812697b64f3b70b6ea" translate="yes" xml:space="preserve">
          <source>What happened?</source>
          <target state="translated">어떻게 된 거예요?</target>
        </trans-unit>
        <trans-unit id="a8ce06e7c8801f5352d9b466e0f76fb6c3c8a84b" translate="yes" xml:space="preserve">
          <source>What happens if the request fails on the server, or if a poor network connection prevents it from even reaching the server? &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; will return an &lt;em&gt;error&lt;/em&gt; object instead of a successful response.</source>
          <target state="translated">요청이 서버에서 실패하거나 네트워크 연결 상태가 좋지 않아 서버에 도달하지 못하는 경우 어떻게됩니까? &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 는 성공적인 응답 대신 &lt;em&gt;오류&lt;/em&gt; 객체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="10d9fbb31e05693074cbd05ef7c4fa4b5d4cc854" translate="yes" xml:space="preserve">
          <source>What happens on top of this is that components and services managed by one framework can interoperate with those from the other framework. This happens in three main areas: Dependency injection, the DOM, and change detection.</source>
          <target state="translated">무엇보다 한 프레임 워크에서 관리하는 구성 요소 및 서비스가 다른 프레임 워크의 구성 요소 및 서비스와 상호 운용 될 수 있습니다. 이는 의존성 주입, DOM 및 변경 감지의 세 가지 주요 영역에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="15d57a03ad72e64e2f967c9b58b84e47c42f4e56" translate="yes" xml:space="preserve">
          <source>What if I import the same module twice?</source>
          <target state="translated">동일한 모듈을 두 번 가져 오면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="67698516018294ce714cfa0910ed88df86860dcc" translate="yes" xml:space="preserve">
          <source>What if the service is optional?</source>
          <target state="translated">서비스가 선택 사항 인 경우 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="fdf373766dbd491f797bd75ad9a27bc85492ffa5" translate="yes" xml:space="preserve">
          <source>What if the user tries to navigate away without saving or canceling? The user could push the browser back button or click the heroes link. Both actions trigger a navigation. Should the app save or cancel automatically?</source>
          <target state="translated">사용자가 저장하거나 취소하지 않고 이동하려고하면 어떻게합니까? 사용자는 브라우저 뒤로 버튼을 누르거나 영웅 링크를 클릭 할 수 있습니다. 두 작업 모두 탐색을 트리거합니다. 앱이 자동으로 저장 또는 취소해야합니까?</target>
        </trans-unit>
        <trans-unit id="3fc3074fd43e313b68435dd9d3eccbad57fbacca" translate="yes" xml:space="preserve">
          <source>What if two modules provide the same service?</source>
          <target state="translated">두 개의 모듈이 동일한 서비스를 제공하면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="84612cf3c8dbe22a08e1d681d1e151867a37c306" translate="yes" xml:space="preserve">
          <source>What if you &lt;em&gt;don't&lt;/em&gt; know the concrete parent component class?</source>
          <target state="translated">당신이 &lt;em&gt;하지 않으면 어떻게&lt;/em&gt;구체적인 부모 구성 요소 클래스를 모른다 합니까?</target>
        </trans-unit>
        <trans-unit id="9571231b9a6513e5bda3f63b2546e2f10a6caf27" translate="yes" xml:space="preserve">
          <source>What if you aren't so lucky. What if faking the &lt;code&gt;HeroService&lt;/code&gt; is hard? What if &lt;code&gt;HeroDetailService&lt;/code&gt; makes its own server requests?</source>
          <target state="translated">운이 좋지 않으면 어떻게 될까요? &lt;code&gt;HeroService&lt;/code&gt; 를 가짜로 만드는 것이 어려운 경우 어떻게해야 합니까? &lt;code&gt;HeroDetailService&lt;/code&gt; 의 경우 자체 서버 요청을 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2af22762107db85dc423fbbae7b2defe8142ea5a" translate="yes" xml:space="preserve">
          <source>What is a &lt;code&gt;declarable&lt;/code&gt;?</source>
          <target state="translated">무엇 &lt;code&gt;declarable&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="f22c2deef328e587dff4aa9d84977cb40974b2b3" translate="yes" xml:space="preserve">
          <source>What is an &lt;code&gt;entry component&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;entry component&lt;/code&gt; 란 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="42a60fa4661b031df7525d26e30ae45290feeb4f" translate="yes" xml:space="preserve">
          <source>What is the &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;forRoot()&lt;/a&gt;&lt;/code&gt; method?</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;forRoot()&lt;/a&gt;&lt;/code&gt; 메소드 란 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="a0f27c8023b0ac7bd64253716b7d1e8a3115268b" translate="yes" xml:space="preserve">
          <source>What is the &lt;code&gt;forRoot()&lt;/code&gt; method?</source>
          <target state="translated">&lt;code&gt;forRoot()&lt;/code&gt; 메서드 는 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="393dcffc17ce162eb4715e7887f6986bef77f253" translate="yes" xml:space="preserve">
          <source>What is the Angular compiler?</source>
          <target state="translated">Angular 컴파일러 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ca032b5844df22ede2117e0697547ac14af77ed3" translate="yes" xml:space="preserve">
          <source>What it does</source>
          <target state="translated">그것이하는 일</target>
        </trans-unit>
        <trans-unit id="ce3efec53dfa7b3f17d8b379e8bb6f5b1fe81172" translate="yes" xml:space="preserve">
          <source>What kinds of modules should I have and how should I use them?</source>
          <target state="translated">어떤 종류의 모듈이 있어야하며 어떻게 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="8492f572f03fd01c98f764f87b2ecfafaba6438b" translate="yes" xml:space="preserve">
          <source>What should I &lt;code&gt;not&lt;/code&gt; export?</source>
          <target state="translated">나는 무엇을해야 &lt;code&gt;not&lt;/code&gt; 내보내?</target>
        </trans-unit>
        <trans-unit id="272547099bb1eafdb8c114cedd1c025f49babd8d" translate="yes" xml:space="preserve">
          <source>What should I export?</source>
          <target state="translated">무엇을 내 보내야합니까?</target>
        </trans-unit>
        <trans-unit id="2fba818e3c12cdfea661b9e5031ad159d26edea6" translate="yes" xml:space="preserve">
          <source>What should I import?</source>
          <target state="translated">무엇을 가져와야합니까?</target>
        </trans-unit>
        <trans-unit id="f56cc84fec0aec96345c31e5e364bd0bf53c27f7" translate="yes" xml:space="preserve">
          <source>What this means is that applications using &lt;code&gt;&lt;a href=&quot;upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; will run change detection more frequently in order to ensure that both frameworks are properly notified about possible changes. This will inevitably result in more change detection runs than necessary.</source>
          <target state="translated">이것이 의미하는 바는 &lt;code&gt;&lt;a href=&quot;upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 을 사용하는 응용 프로그램이 가능한 변경에 대해 두 프레임 워크 모두에 제대로 알릴 수 있도록 변경 감지를 더 자주 실행한다는 것입니다. 필연적으로 필요한 것보다 더 많은 변경 감지 실행이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8e748865fabf06ac85d0efb3686d535f7edbe194" translate="yes" xml:space="preserve">
          <source>What to do if Angular doesn't find what you're looking for, that is &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;()&lt;/code&gt;</source>
          <target state="translated">Angular가 당신이 찾고있는 것을 찾지 못하면, 즉 &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e88cb973cd5369993be64ec9b2cc3ad10b9b55a" translate="yes" xml:space="preserve">
          <source>What was previously done in the controller function is now done in the class constructor function. The dependency injection annotations are attached to the class using a static property &lt;code&gt;$inject&lt;/code&gt;. At runtime this becomes the &lt;code&gt;PhoneListController.$inject&lt;/code&gt; property.</source>
          <target state="translated">이전에 컨트롤러 함수에서 수행 된 작업은 이제 클래스 생성자 함수에서 수행됩니다. 종속성 인젝션 주석은 &lt;code&gt;$inject&lt;/code&gt; 정적 속성을 사용하여 클래스에 첨부됩니다 . 런타임에 이것은 &lt;code&gt;PhoneListController.$inject&lt;/code&gt; 특성이됩니다.</target>
        </trans-unit>
        <trans-unit id="36bcf3cf57500860c4fe2fa7525f4f11a0d1ee9c" translate="yes" xml:space="preserve">
          <source>What went wrong? Nothing, actually. The Angular service worker is doing its job and serving the version of the application that it has &lt;strong&gt;installed&lt;/strong&gt;, even though there is an update available. In the interest of speed, the service worker doesn't wait to check for updates before it serves the application that it has cached.</source>
          <target state="translated">무엇이 잘못 되었나요? 사실은 없습니다. 사용 가능한 업데이트가 있더라도 Angular 서비스 워커는 작업을 수행하고 &lt;strong&gt;설치된&lt;/strong&gt; 애플리케이션 버전을 제공하고 있습니다. 속도를 높이기 위해 서비스 워커는 캐시 된 응용 프로그램에 서비스를 제공하기 전에 업데이트 확인을 기다리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a604bb3c719d03268bdbbb785f2f34dc6c481a0f" translate="yes" xml:space="preserve">
          <source>What you include in your library depends on your task. For example, you could define a schematic to create a dropdown that is pre-populated with canned data to show how to add it to an app. If you want a dropdown that would contain different passed-in values each time, your library could define a schematic to create it with a given configuration. Developers could then use &lt;code&gt;ng generate&lt;/code&gt; to configure an instance for their own app.</source>
          <target state="translated">라이브러리에 포함하는 내용은 작업에 따라 다릅니다. 예를 들어 앱에 추가하는 방법을 보여주기 위해 미리 준비된 데이터로 미리 채워진 드롭 다운을 만드는 회로도를 정의 할 수 있습니다. 매번 다른 전달 된 값을 포함하는 드롭 다운을 원하는 경우 라이브러리는 지정된 구성으로 생성하도록 회로도를 정의 할 수 있습니다. 그런 다음 개발자는 &lt;code&gt;ng generate&lt;/code&gt; 를 사용하여 자체 앱에 대한 인스턴스를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f165c8fe830c74b722cf3c40b0f1a6351cc255e" translate="yes" xml:space="preserve">
          <source>What you include in your library is determined by the kind of task you are trying to accomplish. For example, if you want a dropdown with some canned data to show how to add it to your app, your library could define a schematic to create it. For a component like a dropdown that would contain different passed-in values each time, you could provide it as a component in a shared library.</source>
          <target state="translated">라이브러리에 포함하는 것은 수행하려는 작업의 종류에 따라 결정됩니다. 예를 들어 통조림 데이터가있는 드롭 다운에 앱에 데이터를 추가하는 방법을 보여 주려면 라이브러리에서 회로도를 정의하여 만들 수 있습니다. 매번 다른 전달 된 값을 포함하는 드롭 다운과 같은 구성 요소의 경우 공유 라이브러리에서 구성 요소로 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7efedb21f9cc31360041f1387aa92e01cf8751ea" translate="yes" xml:space="preserve">
          <source>What you'll build</source>
          <target state="translated">무엇을 만들 것인가</target>
        </trans-unit>
        <trans-unit id="206c37a11b4ea4cf13bb051d8b88deddea5ec07c" translate="yes" xml:space="preserve">
          <source>What's being cached?</source>
          <target state="translated">캐시되는 것은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="b0da2957891f63fe85f0b681e42bc7c99353b6ac" translate="yes" xml:space="preserve">
          <source>What's in the QuickStart seed?</source>
          <target state="translated">빠른 시작 시드에는 무엇이 있습니까?</target>
        </trans-unit>
        <trans-unit id="bbe4cab88394b14ba3632e2b2dcf364b507a5fba" translate="yes" xml:space="preserve">
          <source>What's new? What's changed? We share the most important things you need to know on the Angular blog in &lt;a href=&quot;https://blog.angular.io/tagged/release%20notes&quot;&gt;release announcements&lt;/a&gt;.</source>
          <target state="translated">새로운 소식 무엇이 바뀌 었습니까? &lt;a href=&quot;https://blog.angular.io/tagged/release%20notes&quot;&gt;릴리스 발표&lt;/a&gt; 에서 Angular 블로그에서 알아야 할 가장 중요한 사항을 공유합니다 .</target>
        </trans-unit>
        <trans-unit id="46fdeff62267a834862780ae0326b4c1aaa4483d" translate="yes" xml:space="preserve">
          <source>What's next</source>
          <target state="translated">무엇 향후 계획</target>
        </trans-unit>
        <trans-unit id="c9d5de0ac54b4a1d6831c0c5c8cc8b083df30290" translate="yes" xml:space="preserve">
          <source>What's the difference between NgModules and JavaScript Modules?</source>
          <target state="translated">NgModules와 JavaScript 모듈의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="df4456b644d2af7318557209dc4f1b5237c4e5d9" translate="yes" xml:space="preserve">
          <source>What's the difference between a &lt;code&gt;bootstrap&lt;/code&gt; component and an &lt;code&gt;entry component&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;bootstrap&lt;/code&gt; 구성 요소와 &lt;code&gt;entry component&lt;/code&gt; 요소 의 차이점은 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="a2003b1e0230fe60f289921936009ec90172775d" translate="yes" xml:space="preserve">
          <source>Whatever the source, the doc viewer renders them as &quot;code snippets&quot;, either individually with the &lt;a href=&quot;docs-style-guide#code-example&quot;&gt;&lt;em&gt;code-example&lt;/em&gt;&lt;/a&gt; component or as a tabbed collection with the &lt;a href=&quot;docs-style-guide#code-tabs&quot;&gt;&lt;em&gt;code-tabs&lt;/em&gt;&lt;/a&gt; component.</source>
          <target state="translated">소스가 무엇이든 문서 뷰어는 &lt;a href=&quot;docs-style-guide#code-example&quot;&gt;&lt;em&gt;코드 예제&lt;/em&gt;&lt;/a&gt; 구성 요소를 사용하여 개별적으로 또는 &lt;a href=&quot;docs-style-guide#code-tabs&quot;&gt;&lt;em&gt;코드 탭&lt;/em&gt;&lt;/a&gt; 구성 요소를 사용하여 탭 모음 으로 &quot;코드 스 니펫&quot;으로 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="d40735da03c29f6121c2a672d8e066562771fdbb" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;glossary#server-side-rendering&quot;&gt;server-side rendering&lt;/a&gt; (SSR) is used, the &lt;a href=&quot;../api/platform-server&quot;&gt;&lt;code&gt;platform-server&lt;/code&gt;&lt;/a&gt; package provides web server implementations of the &lt;code&gt;DOM&lt;/code&gt;, &lt;code&gt;XMLHttpRequest&lt;/code&gt;, and other low-level features that don't rely on a browser.</source>
          <target state="translated">때 &lt;a href=&quot;glossary#server-side-rendering&quot;&gt;서버 측 렌더링&lt;/a&gt; (SSR)를 사용하는 경우, &lt;a href=&quot;../api/platform-server&quot;&gt; &lt;code&gt;platform-server&lt;/code&gt; &lt;/a&gt; 패키지의 웹 서버 구현 제공 &lt;code&gt;DOM&lt;/code&gt; , &lt;code&gt;XMLHttpRequest&lt;/code&gt; 의 브라우저에 의존하지 않는, 그리고 다른 하위 수준 기능을.</target>
        </trans-unit>
        <trans-unit id="8914c537808edf1a7a626676a069039b9f296c22" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; requests the &lt;code&gt;FlowerService&lt;/code&gt;, the injector begins its search at the &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt; belonging to &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; (&lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt; is included because it is injected from &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt;) and ends with &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt;. In this case, the &lt;code&gt;FlowerService&lt;/code&gt; is resolved in the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt;'s &lt;code&gt;providers&lt;/code&gt; array with sunflower 🌻. The injector doesn't have to look any further in the injector tree. It stops as soon as it finds the &lt;code&gt;FlowerService&lt;/code&gt; and never sees the 🌺 (red hibiscus).</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; 요청 &lt;code&gt;FlowerService&lt;/code&gt; 는 상기 인젝터는 상기의 검색 시작 &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt; 에 속하는 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; ( &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt; 는 그것이로부터 분사되기 때문에 포함 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; 와 단부) &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; . 이 경우 &lt;code&gt;FlowerService&lt;/code&gt; 는 해바라기를 가진 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; 의 &lt;code&gt;providers&lt;/code&gt; 배열에서 확인됩니다. 인젝터는 인젝터 트리에서 더 이상 볼 필요가 없습니다. 그것은 &lt;code&gt;FlowerService&lt;/code&gt; 를 발견하자마자 멈추고 🌺 (빨간색 히비스커스)을 보지 못합니다.</target>
        </trans-unit>
        <trans-unit id="3a290ab7d29486d5dec0940d7942415d6fab40d8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; requests the &lt;code&gt;FlowerService&lt;/code&gt;, it is the injector's job to resolve the &lt;code&gt;FlowerService&lt;/code&gt; token. The resolution of the token happens in two phases:</source>
          <target state="translated">때 &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; 요청 &lt;code&gt;FlowerService&lt;/code&gt; 를 , 그것을 해결하기 위해 인젝터의 일이다 &lt;code&gt;FlowerService&lt;/code&gt; 의 토큰. 토큰의 해결은 두 단계로 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="21374804442ed472300ccdecb64c9e08c0ae1478" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;../upgrade/static&quot;&gt;static&lt;/a&gt;&lt;/code&gt; is not provided, uses query results to determine the timing of query resolution. If any query results are inside a nested view (such as &lt;code&gt;*&lt;a href=&quot;../common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt;), the query is resolved after change detection runs. Otherwise, it is resolved before change detection runs.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;../upgrade/static&quot;&gt;static&lt;/a&gt;&lt;/code&gt; 제공되지 않는 쿼리 해상도의 타이밍을 결정하는 쿼리 결과를 사용합니다. 쿼리 결과가 중첩 뷰 내에있는 경우 (예 : &lt;code&gt;*&lt;a href=&quot;../common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; ) 변경 감지가 실행 된 후 쿼리가 해결됩니다. 그렇지 않으면 변경 감지가 실행되기 전에 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="53e5281d1686a6ec68990211a7fd328735128905" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;../upgrade/static&quot;&gt;static&lt;/a&gt;&lt;/code&gt; is not provided, uses the query results to determine the timing of query resolution. If any query results are inside a nested view (such as &lt;code&gt;*&lt;a href=&quot;../common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt;), the query is resolved after change detection runs. Otherwise, it is resolved before change detection runs.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;../upgrade/static&quot;&gt;static&lt;/a&gt;&lt;/code&gt; 제공되지 않는 쿼리 해상도의 타이밍을 결정하기 위해 쿼리 결과를 사용합니다. 쿼리 결과가 중첩 뷰 내에있는 경우 (예 : &lt;code&gt;*&lt;a href=&quot;../common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; ) 변경 감지가 실행 된 후 쿼리가 해결됩니다. 그렇지 않으면 변경 감지가 실행되기 전에 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="9f2951b5265473e47083f23251a243f2533334e7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;@.disabled&lt;/code&gt; is true, it prevents the &lt;code&gt;@childAnimation&lt;/code&gt; trigger from animating, along with any inner animations.</source>
          <target state="translated">경우 &lt;code&gt;@.disabled&lt;/code&gt; 사실, 상기 방지 &lt;code&gt;@childAnimation&lt;/code&gt; 의 모든 내부 애니메이션과 함께 살리는에서 트리거.</target>
        </trans-unit>
        <trans-unit id="aae654a850870dc683e195d0d86f434df815ab22" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; were applied to the &lt;code&gt;FlowerService&lt;/code&gt;, which is in the &lt;code&gt;providers&lt;/code&gt; array, the result was &lt;code&gt;null&lt;/code&gt; because &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; starts its search in the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; injector, but &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; stops searching at &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt;&amp;mdash;where there is no &lt;code&gt;FlowerService&lt;/code&gt;. In the logical tree, you can see that the &lt;code&gt;FlowerService&lt;/code&gt; is visible in &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt;, not its &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; 에인가 된 &lt;code&gt;FlowerService&lt;/code&gt; 에, &lt;code&gt;providers&lt;/code&gt; 어레이 결과였다 &lt;code&gt;null&lt;/code&gt; 때문에 &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; 에서의 검색 시작 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; 인젝터하지만 &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; 검색을 중지 &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt; 에서 -FlowerService 가없는 &lt;code&gt;FlowerService&lt;/code&gt; . 논리 트리에서 &lt;code&gt;FlowerService&lt;/code&gt; 가 &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt; 가 아니라 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; 에 표시되는 것을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f26326afa93adb0e0f9cbfa39d9dbe32a7dbdac" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;@&lt;a href=&quot;inject&quot;&gt;Inject&lt;/a&gt;()&lt;/code&gt; is not present, the injector uses the type annotation of the parameter as the provider.</source>
          <target state="translated">경우 &lt;code&gt;@&lt;a href=&quot;inject&quot;&gt;Inject&lt;/a&gt;()&lt;/code&gt; 인젝터 제공자와 파라미터의 타입 주석을 사용하여, 존재하지 않는다.</target>
        </trans-unit>
        <trans-unit id="2bdf758a1a9690d4ad83702a2aa70dc21cb575b3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;addHero()&lt;/code&gt; saves successfully, the &lt;code&gt;subscribe()&lt;/code&gt; callback receives the new hero and pushes it into to the &lt;code&gt;heroes&lt;/code&gt; list for display.</source>
          <target state="translated">때 &lt;code&gt;addHero()&lt;/code&gt; 성공적으로 저장의은 &lt;code&gt;subscribe()&lt;/code&gt; 콜백은 새로운 영웅을 수신하고에로 밀어 &lt;code&gt;heroes&lt;/code&gt; 표시 목록입니다.</target>
        </trans-unit>
        <trans-unit id="f10aac19bd7597b8018bacfe0f5ef7081c6eb8a1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;bindingProperty&lt;/code&gt; is not provided, it is assumed to be equal to &lt;code&gt;directiveProperty&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;bindingProperty&lt;/code&gt; 가 제공되지 않으며,이를 동일한 것으로 간주 &lt;code&gt;directiveProperty&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f035065ead707a891990c140cba8292f7c7750c8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;false&lt;/code&gt; (the default), removes blank text nodes from compiled templates, which results in smaller emitted template factory modules. Set to &lt;code&gt;true&lt;/code&gt; to preserve blank text nodes.</source>
          <target state="translated">때 &lt;code&gt;false&lt;/code&gt; (기본), 컴파일 된 템플릿에서 빈 텍스트 노드를 제거하는 작은 방출 템플릿 공장 모듈의 결과. 빈 텍스트 노드를 유지 하려면 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed12b19518c977a855a7af5f7bcbb3780eb478a3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;false&lt;/code&gt;, disables this rewriting, requiring the rewriting to be done manually.</source>
          <target state="translated">때 &lt;code&gt;false&lt;/code&gt; , 수동으로 수행 할 재 작성 요구,이 재 작성을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="017d855b6c49b2c6a35221e4a06e560f0e54e376" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;false&lt;/code&gt;, factory files are generated only for &lt;code&gt;.ts&lt;/code&gt; files. Do this when using factory summaries.</source>
          <target state="translated">때 &lt;code&gt;false&lt;/code&gt; , 공장 파일은 생성됩니다 &lt;code&gt;.ts&lt;/code&gt; 파일입니다. 공장 요약을 사용할 때 이렇게하십시오.</target>
        </trans-unit>
        <trans-unit id="a0a78206a1f0896e2816ea253bc9930ac1c56dfe" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ngc&lt;/code&gt; runs, it compiles &lt;code&gt;AppModule&lt;/code&gt; into a module factory, which contains definitions for all the providers declared in all the modules it includes. At runtime, this factory becomes an injector that instantiates these services.</source>
          <target state="translated">&lt;code&gt;ngc&lt;/code&gt; 는 실행될 때 &lt;code&gt;AppModule&lt;/code&gt; 을 모듈 팩토리로 컴파일합니다 . 여기에는 포함 된 모든 모듈에 선언 된 모든 공급자에 대한 정의가 들어 있습니다. 런타임시이 팩토리는 이러한 서비스를 인스턴스화하는 인젝터가됩니다.</target>
        </trans-unit>
        <trans-unit id="c6b2139d05d2a8c8f3fc1f7405ee8a5d8b302144" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;selectedHero&lt;/code&gt; is undefined, the &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; removes the hero detail from the DOM. There are no &lt;code&gt;selectedHero&lt;/code&gt; bindings to consider.</source>
          <target state="translated">경우 &lt;code&gt;selectedHero&lt;/code&gt; 가 정의되지는 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 는 DOM을 행 영웅 내용을 제거한다. 고려할 &lt;code&gt;selectedHero&lt;/code&gt; 바인딩 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="657a451b51d175e64cf9315ba370f13157827231" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;strictTemplates&lt;/code&gt; is enabled, it is still possible to disable certain aspects of type checking. Setting the option &lt;code&gt;strictNullInputTypes&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; disables strict null checks within Angular templates. This flag applies for all components that are part of the application.</source>
          <target state="translated">때 &lt;code&gt;strictTemplates&lt;/code&gt; 가 활성화되어, 그것은 유형 검사의 비활성화 특정 측면에 여전히 가능하다. &lt;code&gt;strictNullInputTypes&lt;/code&gt; 옵션 을 &lt;code&gt;false&lt;/code&gt; 로 설정하면 Angular 템플릿 내에서 엄격한 null 검사가 비활성화됩니다. 이 플래그는 응용 프로그램의 일부인 모든 구성 요소에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8c0f82f5a3d1f42f3589033e4da5b7c233fdf6b3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt; (recommended), enables the &lt;a href=&quot;aot-compiler#binding-expression-validation&quot;&gt;binding expression validation&lt;/a&gt; phase of the template compiler, which uses TypeScript to validate binding expressions. For more information, see &lt;a href=&quot;template-typecheck&quot;&gt;Template type checking&lt;/a&gt;.</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; (권장)는 수 &lt;a href=&quot;aot-compiler#binding-expression-validation&quot;&gt;바인딩 식 검증&lt;/a&gt; 바인딩 식의 유효성을 검사 타이프를 사용하는 템플릿 컴파일러의 위상을. 자세한 내용은 &lt;a href=&quot;template-typecheck&quot;&gt;템플릿 유형 검사를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b6e0d659c9c6611b42ffdd8b564ed7650d25d3b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt; (recommended), reports an error for a supplied parameter whose injection type cannot be determined. When &lt;code&gt;false&lt;/code&gt; (currently the default), constructor parameters of classes marked with &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;&lt;/code&gt; whose type cannot be resolved produce a warning.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; (권장), 주입 형을 판별 할 수없는 제공된 매개 변수에 대한 에러를보고한다. 때 &lt;code&gt;false&lt;/code&gt; (현재 기본값)로 표시된 클래스의 생성자 매개 변수 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;&lt;/code&gt; , 그 유형은 생산에게 경고를 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ef4fcc09d6fb22fdf69874d9f54a814115c092ec" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt; (the default), generates factory files (&lt;code&gt;.ngfactory.js&lt;/code&gt; and &lt;code&gt;.ngstyle.js&lt;/code&gt;) for &lt;code&gt;.d.ts&lt;/code&gt; files with a corresponding &lt;code&gt;.metadata.json&lt;/code&gt; file.</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; 공장 파일 ((기본값)를 생성 &lt;code&gt;.ngfactory.js&lt;/code&gt; 및 &lt;code&gt;.ngstyle.js&lt;/code&gt; 에 대한) &lt;code&gt;.d.ts&lt;/code&gt; 의 대응과 파일을 &lt;code&gt;.metadata.json&lt;/code&gt; 의 파일입니다.</target>
        </trans-unit>
        <trans-unit id="35857c992711f66bc9264c14418549220b43d7bb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt; (the default), transforms code that is or could be used in an annotation, to allow it to be imported from template factory modules. See &lt;a href=&quot;aot-compiler#metadata-rewriting&quot;&gt;metadata rewriting&lt;/a&gt; for more information.</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; (기본), 또는이 템플릿 공장 모듈에서 수입 할 수 있도록, 주석에 사용될 수있는 변환 코드입니다. 자세한 내용은 &lt;a href=&quot;aot-compiler#metadata-rewriting&quot;&gt;메타 데이터 재 작성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2f5278ded619599ce70b6c60289ab8fa9dd9207e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, does not emit &lt;code&gt;.ngfactory.js&lt;/code&gt; and &lt;code&gt;.ngstyle.js&lt;/code&gt; files. This turns off most of the template compiler and disables the reporting of template diagnostics.</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; , 방출하지 않는 &lt;code&gt;.ngfactory.js&lt;/code&gt; 및 &lt;code&gt;.ngstyle.js&lt;/code&gt; 의 파일을. 이렇게하면 대부분의 템플릿 컴파일러가 꺼지고 템플릿 진단보고가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c9665f94608d5d80d1f67169ba46a0b7e00b8ae3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, does not produce &lt;code&gt;.metadata.json&lt;/code&gt; files. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; , 생성하지 않습니다 &lt;code&gt;.metadata.json&lt;/code&gt; 파일을. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="95b36df6783ff17039e5de66ab5e24a3f592a3f0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, enables &lt;a href=&quot;template-typecheck#strict-mode&quot;&gt;strict template type checking&lt;/a&gt; in Angular version 9. Strict mode is only available when using &lt;a href=&quot;ivy&quot;&gt;Ivy&lt;/a&gt;.</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; , 수 &lt;a href=&quot;template-typecheck#strict-mode&quot;&gt;엄격한 템플릿 유형 검사를&lt;/a&gt; 각도 버전에서 사용하는 경우 9. 엄격한 모드 만 사용할 수 있습니다 &lt;a href=&quot;ivy&quot;&gt;아이비&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bcf00297cfbafb28fc19845594f4c48f02c45597" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, enables use of the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element, which was deprecated in Angular 4.0, in favor of &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; (to avoid colliding with the DOM's element of the same name). Default is &lt;code&gt;false&lt;/code&gt;. Might be required by some third-party Angular libraries.</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; ,의 사용 가능 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 에 찬성, 각도 4.0에서 사용되지 않습니다 요소, &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; (같은 이름의 DOM의 요소와 충돌을 방지하기 위해 참조). 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. 일부 타사 Angular 라이브러리에 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56e831076fbb13304c174dd4f4f401001e893101" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, generate all possible files even if they are empty. Default is &lt;code&gt;false&lt;/code&gt;. Used by the Bazel build rules to simplify how Bazel rules track file dependencies. Do not use this option outside of the Bazel rules.</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; 가능한 모든 파일을 생성 그들은 비어있는 경우에도 마찬가지입니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. Bazel 빌드 규칙에서 Bazel 규칙이 파일 종속성을 추적하는 방법을 단순화하는 데 사용됩니다. Bazel 규칙 외부에서이 옵션을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="28fe72bab6640e479e79ce07a22289f8e316ed2e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, generates a flat module index of the given file name and the corresponding flat module metadata. Use to create flat modules that are packaged similarly to &lt;code&gt;@angular/core&lt;/code&gt; and &lt;code&gt;@angular/common&lt;/code&gt;. When this option is used, the &lt;code&gt;package.json&lt;/code&gt; for the library should refer to the generated flat module index instead of the library index file.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; 주어진 파일명의 평면 모듈 인덱스 및 대응하는 평면 모듈 메타 데이터를 생성한다. &lt;code&gt;@angular/core&lt;/code&gt; 및 &lt;code&gt;@angular/common&lt;/code&gt; 과 유사하게 패키징 된 플랫 모듈을 만드는 데 사용합니다 . 이 옵션을 사용 하는 경우 라이브러리 의 &lt;code&gt;package.json&lt;/code&gt; 은 라이브러리 색인 파일 대신 생성 된 플랫 모듈 색인을 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="5965f43ade662037029b52c576bebdf4200e293f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, prints extra information while compiling templates. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; , 템플릿을 컴파일하는 동안 추가 정보를 인쇄합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d4a6c8928a8873b74dd81fec0a55c3a18d235824" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, replaces the &lt;code&gt;templateUrl&lt;/code&gt; and &lt;code&gt;styleUrls&lt;/code&gt; property in all &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; decorators with inlined contents in &lt;code&gt;template&lt;/code&gt; and &lt;code&gt;styles&lt;/code&gt; properties.</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; 의 대체 &lt;code&gt;templateUrl&lt;/code&gt; 및 &lt;code&gt;styleUrls&lt;/code&gt; 모든 재산 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; 에 인라인 내용으로 장식 &lt;code&gt;template&lt;/code&gt; 및 &lt;code&gt;styles&lt;/code&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="987899c0968d3b4f33119bd6dd9fcc2cf4bf5417" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, reports an error to the &lt;code&gt;.metadata.json&lt;/code&gt; file if &lt;code&gt;&quot;skipMetadataEmit&quot;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. Default is &lt;code&gt;false&lt;/code&gt;. Use only when &lt;code&gt;&quot;skipMetadataEmit&quot;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;&quot;skipTemplateCodeGen&quot;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; 의에 오류를보고 &lt;code&gt;.metadata.json&lt;/code&gt; 의 경우 파일 &lt;code&gt;&quot;skipMetadataEmit&quot;&lt;/code&gt; 입니다 &lt;code&gt;false&lt;/code&gt; . 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. &lt;code&gt;&quot;skipMetadataEmit&quot;&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 이고 &lt;code&gt;&quot;skipTemplateCodeGen&quot;&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 인 경우에만 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9ff5d97e4f3421875057eca5cefa3c3f3de301d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, the compiler does not check the TypeScript version and does not report an error when an unsupported version of TypeScript is used. Not recommended, as unsupported versions of TypeScript might have undefined behavior. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; , 컴파일러는 타이프 라이터 버전을 확인하지 않고 타이프의 지원되지 않는 버전을 사용하는 경우 오류를보고하지 않습니다. 지원되지 않는 TypeScript 버전은 정의되지 않은 동작을 가질 수 있으므로 권장되지 않습니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e05e0539b42ad79b46d59d705a37b7a3d0c21c93" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, the compiler does not check the TypeScript version and does not report an error when an unsupported version of TypeScript is used. Not recommended, as unsupported versions of TypeScript might have undefined behavior. Default is false.</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; , 컴파일러는 타이프 라이터 버전을 확인하지 않고 타이프의 지원되지 않는 버전을 사용하는 경우 오류를보고하지 않습니다. 지원되지 않는 버전의 TypeScript에 정의되지 않은 동작이있을 수 있으므로 권장되지 않습니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="8670765a2a8b2049c5a1f397dfffea5db6c1ba9a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, use &lt;a href=&quot;https://github.com/angular/tsickle&quot;&gt;Tsickle&lt;/a&gt; to annotate the emitted JavaScript with &lt;a href=&quot;http://usejsdoc.org/&quot;&gt;JSDoc&lt;/a&gt; comments needed by the &lt;a href=&quot;https://github.com/google/closure-compiler&quot;&gt;Closure Compiler&lt;/a&gt;. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; , 사용 &lt;a href=&quot;https://github.com/angular/tsickle&quot;&gt;Tsickle을&lt;/a&gt; 함께 방출 된 자바 스크립트에 주석을 &lt;a href=&quot;http://usejsdoc.org/&quot;&gt;JSDoc에&lt;/a&gt; 의해 필요한 의견 &lt;a href=&quot;https://github.com/google/closure-compiler&quot;&gt;폐쇄 컴파일러&lt;/a&gt; . 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="548c1033b7a8da41ee5f0961ac1576b4e9faa14a" translate="yes" xml:space="preserve">
          <source>When Angular creates &lt;code&gt;AppComponent&lt;/code&gt;, the DI framework creates an instance of &lt;code&gt;LoggerService&lt;/code&gt; and starts to create &lt;code&gt;UserContextService&lt;/code&gt;. &lt;code&gt;UserContextService&lt;/code&gt; also needs &lt;code&gt;LoggerService&lt;/code&gt;, which the framework already has, so the framework can provide the same instance. &lt;code&gt;UserContextService&lt;/code&gt; also needs &lt;code&gt;UserService&lt;/code&gt;, which the framework has yet to create. &lt;code&gt;UserService&lt;/code&gt; has no further dependencies, so the framework can simply use &lt;code&gt;new&lt;/code&gt; to instantiate the class and provide the instance to the &lt;code&gt;UserContextService&lt;/code&gt; constructor.</source>
          <target state="translated">Angular가 &lt;code&gt;AppComponent&lt;/code&gt; 를 만들면 DI 프레임 워크는 &lt;code&gt;LoggerService&lt;/code&gt; 의 인스턴스 를 만들고 &lt;code&gt;UserContextService&lt;/code&gt; 를 만들기 시작합니다 . &lt;code&gt;UserContextService&lt;/code&gt; 에는 또한 프레임 워크에 이미있는 &lt;code&gt;LoggerService&lt;/code&gt; 가 필요 하므로 프레임 워크가 동일한 인스턴스를 제공 할 수 있습니다. &lt;code&gt;UserContextService&lt;/code&gt; 에는 프레임 워크가 아직 작성하지 않은 &lt;code&gt;UserService&lt;/code&gt; 도 필요합니다 . &lt;code&gt;UserService&lt;/code&gt; 는 더 이상 종속성이 없으므로 프레임 워크는 &lt;code&gt;new&lt;/code&gt; 를 사용 하여 클래스를 인스턴스화하고 인스턴스를 &lt;code&gt;UserContextService&lt;/code&gt; 생성자에 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c46546530ec2305526bbe60f113e24d64bb2ea5" translate="yes" xml:space="preserve">
          <source>When Angular creates &lt;code&gt;HeroesBaseComponent&lt;/code&gt;, it also creates a new instance of &lt;code&gt;HeroService&lt;/code&gt; that is visible only to that component and its children, if any.</source>
          <target state="translated">Angular는 &lt;code&gt;HeroesBaseComponent&lt;/code&gt; 를 만들 때 해당 구성 요소 및 해당 하위 항목 (있는 경우) 만 볼 수 있는 새로운 &lt;code&gt;HeroService&lt;/code&gt; 인스턴스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="d75141e96ff6cc6af5c2f22e153bb8b7726c8439" translate="yes" xml:space="preserve">
          <source>When Angular creates a &lt;code&gt;HeroesComponent&lt;/code&gt;, the &lt;a href=&quot;../guide/dependency-injection&quot;&gt;Dependency Injection&lt;/a&gt; system sets the &lt;code&gt;heroService&lt;/code&gt; parameter to the singleton instance of &lt;code&gt;HeroService&lt;/code&gt;.</source>
          <target state="translated">Angular가 &lt;code&gt;HeroesComponent&lt;/code&gt; 를 만들 때 &lt;a href=&quot;../guide/dependency-injection&quot;&gt;Dependency Injection&lt;/a&gt; 시스템은 &lt;code&gt;heroService&lt;/code&gt; 매개 변수를 HeroService 의 단일 인스턴스로 &lt;code&gt;HeroService&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="edfe45fd7cd5a3d35587c22b5138369ceba935e9" translate="yes" xml:space="preserve">
          <source>When Angular creates a class whose constructor has parameters, it looks for type and injection metadata about those parameters so that it can inject the correct service. If Angular can't find that parameter information, it throws an error. Angular can only find the parameter information &lt;em&gt;if the class has a decorator of some kind&lt;/em&gt;. The &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; decorator is the standard decorator for service classes.</source>
          <target state="translated">Angular는 생성자에 매개 변수가있는 클래스를 만들면 해당 매개 변수에 대한 형식 및 주입 메타 데이터를 찾아 올바른 서비스를 주입 할 수 있습니다. Angular가 해당 매개 변수 정보를 찾을 수 없으면 오류가 발생합니다. Angular는 &lt;em&gt;클래스에 데코레이터가있는 경우&lt;/em&gt; 에만 매개 변수 정보를 찾을 수 있습니다 . &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; 데코레이터 서비스 클래스에 대한 표준 장식입니다.</target>
        </trans-unit>
        <trans-unit id="b60a04b551961ac33eb89dab15ee5fc3d96de088" translate="yes" xml:space="preserve">
          <source>When Angular creates a lazy component for that module and injects &lt;code&gt;UserService&lt;/code&gt;, it finds a &lt;code&gt;UserService&lt;/code&gt; provider in the lazy module's &lt;em&gt;child injector&lt;/em&gt; and creates a &lt;em&gt;new&lt;/em&gt; instance of the &lt;code&gt;UserService&lt;/code&gt;. This is an entirely different &lt;code&gt;UserService&lt;/code&gt; instance than the app-wide singleton version that Angular injected in one of the eagerly loaded components.</source>
          <target state="translated">각도가 모듈과를 분사에 대한 게으른 구성 요소를 만들 때 &lt;code&gt;UserService&lt;/code&gt; 를 , 그것은 발견 &lt;code&gt;UserService&lt;/code&gt; 의 게으른 모듈의에서 제공 &lt;em&gt;자식 인젝터를&lt;/em&gt; 하고 생성 &lt;em&gt;새&lt;/em&gt; 의 인스턴스를 &lt;code&gt;UserService&lt;/code&gt; 를 . 이것은 Angular가 열악하게로드 된 구성 요소 중 하나에 주입 한 앱 전체 싱글 톤 버전과 완전히 다른 &lt;code&gt;UserService&lt;/code&gt; 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="dc69520190e3c83c55a291c33fca092b47e14bd0" translate="yes" xml:space="preserve">
          <source>When Angular creates a new instance of a component class, it determines which services or other dependencies that component needs by looking at the constructor parameter types. For example, the constructor of &lt;code&gt;HeroListComponent&lt;/code&gt; needs &lt;code&gt;HeroService&lt;/code&gt;.</source>
          <target state="translated">Angular는 구성 요소 클래스의 새 인스턴스를 만들 때 생성자 매개 변수 유형을보고 구성 요소에 필요한 서비스 또는 기타 종속성을 결정합니다. 예를 들어 &lt;code&gt;HeroListComponent&lt;/code&gt; 의 생성자는 HeroService 가 필요 &lt;code&gt;HeroService&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="daa80d0bedfc508acd3e345644f12519bac5df05" translate="yes" xml:space="preserve">
          <source>When Angular discovers that a component depends on a service, it first checks if the injector has any existing instances of that service. If a requested service instance doesn't yet exist, the injector makes one using the registered provider, and adds it to the injector before returning the service to Angular.</source>
          <target state="translated">Angular는 구성 요소가 서비스에 의존한다는 것을 발견하면 먼저 인젝터에 해당 서비스의 기존 인스턴스가 있는지 확인합니다. 요청 된 서비스 인스턴스가 아직 없으면 인젝터는 등록 된 제공자를 사용하여 인젝터를 작성하고 인젝터에 추가 한 후 서비스를 Angular로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="15fbac2ad05bb1b878e9b6aaaddf5c2a92440c52" translate="yes" xml:space="preserve">
          <source>When Angular first introduced lazy routes, there wasn't browser support for dynamically loading additional JavaScript. Angular created our own scheme using the syntax &lt;code&gt;&lt;a href=&quot;../api/router/route#loadChildren&quot;&gt;loadChildren&lt;/a&gt;: './lazy/lazy.module#LazyModule'&lt;/code&gt; and built tooling to support it. Now that ECMAScript dynamic import is supported in many browsers, Angular is moving toward this new syntax.</source>
          <target state="translated">Angular가 처음으로 게으른 경로를 도입했을 때 추가 JavaScript를 동적으로로드하기위한 브라우저 지원은 없었습니다. Angular는 &lt;code&gt;&lt;a href=&quot;../api/router/route#loadChildren&quot;&gt;loadChildren&lt;/a&gt;: './lazy/lazy.module#LazyModule'&lt;/code&gt; 구문을 사용하여 자체 스키마를 작성하고 이를 지원하는 툴을 빌드했습니다. ECMAScript 동적 가져 오기가 많은 브라우저에서 지원되므로 Angular는이 새로운 구문으로 이동하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9706bf78195978fa29fcaec311b2c1db9963924" translate="yes" xml:space="preserve">
          <source>When Angular first introduced lazy routes, there wasn't browser support for dynamically loading additional JavaScript. Angular created our own scheme using the syntax &lt;code&gt;loadChildren: './lazy/lazy.module#LazyModule'&lt;/code&gt; and built tooling to support it. Now that ECMAScript dynamic import is supported in many browsers, Angular is moving toward this new syntax.</source>
          <target state="translated">Angular가 처음 lazy route를 도입했을 때 추가 JavaScript를 동적으로로드하기위한 브라우저 지원이 없었습니다. Angular는 &lt;code&gt;loadChildren: './lazy/lazy.module#LazyModule'&lt;/code&gt; 구문을 사용하여 자체 체계를 만들고 이를 지원하는 도구를 구축했습니다. 이제 ECMAScript 동적 가져 오기가 많은 브라우저에서 지원되므로 Angular는이 새로운 구문으로 이동하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c532a909b137883ff1cc53d2b0c6b4c9086b273e" translate="yes" xml:space="preserve">
          <source>When Angular looks to inject a service for that token, it creates and delivers the instance created by the second provider.</source>
          <target state="translated">Angular는 해당 토큰에 대한 서비스를 주입하려고 할 때 두 번째 제공자가 작성한 인스턴스를 작성하고 전달합니다.</target>
        </trans-unit>
        <trans-unit id="0a3b387e0d7ce6256900c30fd7083a52d270aa24" translate="yes" xml:space="preserve">
          <source>When Angular sees this dev dependency, it provides the language service in the WebStorm environment. WebStorm then gives you colorization inside the template and autocomplete in addition to the Angular Language Service.</source>
          <target state="translated">Angular는이 dev 의존성을 볼 때 WebStorm 환경에서 언어 서비스를 제공합니다. 그런 다음 WebStorm은 Angular Language Service 외에도 템플릿 내에서 색상을 지정하고 자동 완성 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="33dad2f9fbf951339a3296d3326f729bb3e085c0" translate="yes" xml:space="preserve">
          <source>When AngularJS content gets projected inside an Angular component, it still remains in &quot;AngularJS land&quot; and is managed by the AngularJS framework.</source>
          <target state="translated">AngularJS 컨텐츠가 Angular 컴포넌트 내부에 투영 될 때 여전히 &quot;AngularJS 랜드&quot;로 유지되고 AngularJS 프레임 워크에 의해 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="5ed767ca456340b0d66612ee5b397caf978c20ac" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; test ends with pending &lt;em&gt;micro-tasks&lt;/em&gt; such as unresolved promises, the test fails with a clear error message.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; 대기와 테스트 끝에 &lt;em&gt;마이크로 작업&lt;/em&gt; 등 해결되지 않은 약속 등이 테스트는 명확한 오류 메시지와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="706c0acd77c834e1aad2b340fca6016f1fa6d670" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; test ends with pending timer event &lt;em&gt;tasks&lt;/em&gt; (queued &lt;code&gt;setTimeOut&lt;/code&gt; and &lt;code&gt;setInterval&lt;/code&gt; callbacks), the test fails with a clear error message.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; 대기 타이머 이벤트와 테스트 종료 &lt;em&gt;작업&lt;/em&gt; (대기 &lt;code&gt;setTimeOut&lt;/code&gt; 과 &lt;code&gt;setInterval&lt;/code&gt; 을 콜백), 시험은 분명한 오류 메시지와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5c0f510f249ea7d1ebc16b4ca9b7274ea4dccefc" translate="yes" xml:space="preserve">
          <source>When a child of this component asks for the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpbackend&quot;&gt;HttpBackend&lt;/a&gt;&lt;/code&gt; service, Angular provides the local &lt;code&gt;&lt;a href=&quot;../api/common/http/httpbackend&quot;&gt;HttpBackend&lt;/a&gt;&lt;/code&gt; service, not the version provided in the application root injector. Child components make proper HTTP requests no matter what other modules do to &lt;code&gt;&lt;a href=&quot;../api/common/http/httpbackend&quot;&gt;HttpBackend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 구성 요소의 자식이 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpbackend&quot;&gt;HttpBackend&lt;/a&gt;&lt;/code&gt; 서비스를 요청 하면 Angular는 응용 프로그램 루트 인젝터에 제공된 버전이 아닌 로컬 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpbackend&quot;&gt;HttpBackend&lt;/a&gt;&lt;/code&gt; 서비스를 제공합니다 . 자식 구성 요소는 다른 모듈이 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpbackend&quot;&gt;HttpBackend&lt;/a&gt;&lt;/code&gt; 에 관계없이 적절한 HTTP 요청을 합니다 .</target>
        </trans-unit>
        <trans-unit id="2f50727eaded505f27a2039589063405b5098511" translate="yes" xml:space="preserve">
          <source>When a class requires a dependency, that dependency is added to the constructor as a parameter. When Angular needs to instantiate the class, it calls upon the DI framework to supply the dependency. By default, the DI framework searches for a provider in the injector hierarchy, starting at the component's local injector of the component, and if necessary bubbling up through the injector tree until it reaches the root injector.</source>
          <target state="translated">클래스에 종속성이 필요한 경우 해당 종속성이 생성자에 매개 변수로 추가됩니다. Angular는 클래스를 인스턴스화해야 할 때 종속성을 제공하기 위해 DI 프레임 워크를 호출합니다. 기본적으로 DI 프레임 워크는 구성 요소의 구성 요소 로컬 인젝터에서 시작하여 인젝터 계층 구조에서 공급자를 검색하고 필요한 경우 인젝터 트리를 통해 루트 인젝터에 도달 할 때까지 버블 링합니다.</target>
        </trans-unit>
        <trans-unit id="cdcac278185f690641e0973ca2f176befc8267b8" translate="yes" xml:space="preserve">
          <source>When a component declares a dependency, Angular tries to satisfy that dependency with its own &lt;code&gt;ElementInjector&lt;/code&gt;. If the component's injector lacks the provider, it passes the request up to its parent component's &lt;code&gt;ElementInjector&lt;/code&gt;.</source>
          <target state="translated">구성 요소가 종속성을 선언하면 Angular는 자체 &lt;code&gt;ElementInjector&lt;/code&gt; 로 해당 종속성을 충족 시키려고 시도합니다 . 구성 요소의 인젝터에 제공자가 없으면 요청을 상위 구성 요소의 &lt;code&gt;ElementInjector&lt;/code&gt; 로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="fa934dc7384f20c5899aeb7143c3e042d42bada1" translate="yes" xml:space="preserve">
          <source>When a component has dependencies, you may wish to use the &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; to both create the component and its dependencies.</source>
          <target state="translated">구성 요소에 종속성이있는 경우 &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; 를 사용하여 구성 요소와 해당 종속성을 모두 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80c0d48aa6b194f35fb1a95277c8c0e3c66d70a2" translate="yes" xml:space="preserve">
          <source>When a component is instantiated, Angular creates a change detector, which is responsible for propagating the component's bindings. The strategy is one of:</source>
          <target state="translated">컴포넌트가 인스턴스화되면 Angular는 컴포넌트의 바인딩 전파를 담당하는 변경 감지기를 작성합니다. 전략은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="cc7c94e41269c2b8dc0737122e64dd38c738de77" translate="yes" xml:space="preserve">
          <source>When a component or service declares a dependency, the class constructor takes that dependency as a parameter. You can tell Angular that the dependency is optional by annotating the constructor parameter with &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;()&lt;/code&gt;.</source>
          <target state="translated">컴포넌트 또는 서비스가 종속성을 선언하면 클래스 생성자는 해당 종속성을 매개 변수로 사용합니다. &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;()&lt;/code&gt; 생성자 매개 변수에 주석을 달아 의존성을 선택적으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="897bc1098dfadc2e0641ad4a0a44d85138b5526f" translate="yes" xml:space="preserve">
          <source>When a library's input types are too narrow and the library hasn't added appropriate metadata for Angular to figure this out. This usually occurs with disabled or other common Boolean inputs used as attributes, for example, &lt;code&gt;&amp;lt;input disabled&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">라이브러리의 입력 유형이 너무 좁고 라이브러리가이를 파악하기 위해 Angular에 대한 적절한 메타 데이터를 추가하지 않은 경우. 이는 일반적으로 비활성화되거나 속성으로 사용되는 기타 일반적인 부울 입력 (예 : &lt;code&gt;&amp;lt;input disabled&amp;gt;&lt;/code&gt; )에서 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="6dc930c78d57112ce62f728430bda27a0ee3f50d" translate="yes" xml:space="preserve">
          <source>When a library's typings are wrong or incomplete (for example, missing &lt;code&gt;null | undefined&lt;/code&gt; if the library was not written with &lt;code&gt;strictNullChecks&lt;/code&gt; in mind).</source>
          <target state="translated">라이브러리의 입력이 잘못되었거나 불완전한 경우 (예 : 라이브러리가 &lt;code&gt;strictNullChecks&lt;/code&gt; 를 염두에두고 작성 &lt;code&gt;null | undefined&lt;/code&gt; 경우 null 누락 | undefined ).</target>
        </trans-unit>
        <trans-unit id="c92f91e13ec5352ca2d9208b3c8260e92af91884" translate="yes" xml:space="preserve">
          <source>When a module is loaded at application launch, its &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule#providers&quot;&gt;NgModule.providers&lt;/a&gt;&lt;/code&gt; have &lt;em&gt;application-wide scope&lt;/em&gt;; that is, they are available for injection throughout the application.</source>
          <target state="translated">응용 프로그램 시작시 모듈이로드되면 해당 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule#providers&quot;&gt;NgModule.providers&lt;/a&gt;&lt;/code&gt; 는 &lt;em&gt;응용 프로그램 전체 범위를&lt;/em&gt; 갖습니다 . 즉, 응용 프로그램 전체에서 사출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bd443c478a3d09a5355445d040100b60dfaf9ca" translate="yes" xml:space="preserve">
          <source>When a published library is used in an Ivy app, the Angular CLI will automatically convert it to Ivy using a tool known as the Angular compatibility compiler (&lt;code&gt;ngcc&lt;/code&gt;). Thus, publishing your libraries using the View Engine compiler ensures that they can be transparently consumed by both View Engine and Ivy apps.</source>
          <target state="translated">게시 된 라이브러리가 Ivy 앱에서 사용되는 경우 Angular CLI는 Angular 호환성 컴파일러 ( &lt;code&gt;ngcc&lt;/code&gt; ) 라는 도구를 사용하여 자동으로 Ivy로 변환합니다 . 따라서 View Engine 컴파일러를 사용하여 라이브러리를 게시하면 View Engine 및 Ivy 앱 모두에서 투명하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6422ede5f8ed58042863b6f652f29c592c282af7" translate="yes" xml:space="preserve">
          <source>When a sequence is used within a &lt;code&gt;&lt;a href=&quot;group&quot;&gt;group()&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; call, execution continues to the next instruction only after each of the inner animation steps have completed.</source>
          <target state="translated">시퀀스가 &lt;code&gt;&lt;a href=&quot;group&quot;&gt;group()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; 호출 내에서 사용되면 각 내부 애니메이션 단계가 완료된 후에 만 ​​다음 명령어로 실행이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="f7f49ac27e9c43d7f3eccbab41e653302c0fdad0" translate="yes" xml:space="preserve">
          <source>When a translation is missing, the build succeeds but generates a warning such as &lt;code&gt;Missing translation for message &quot;foo&quot;&lt;/code&gt;. You can configure the level of warning that is generated by the Angular compiler:</source>
          <target state="translated">번역이 누락되면 빌드가 성공하지만 &lt;code&gt;Missing translation for message &quot;foo&quot;&lt;/code&gt; 과 같은 경고가 생성됩니다 . Angular 컴파일러에서 생성되는 경고 수준을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3cbb8c4d353fced8240d3f69c79bebf4d68b840" translate="yes" xml:space="preserve">
          <source>When a user clicks a &lt;em&gt;Dashboard&lt;/em&gt; hero, the &lt;code&gt;DashboardComponent&lt;/code&gt; tells the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; to navigate to &lt;code&gt;heroes/:id&lt;/code&gt;. The &lt;code&gt;:id&lt;/code&gt; is a route parameter whose value is the &lt;code&gt;id&lt;/code&gt; of the hero to edit.</source>
          <target state="translated">사용자가 클릭하면 &lt;em&gt;대시 보드&lt;/em&gt; 영웅의 &lt;code&gt;DashboardComponent&lt;/code&gt; 는 알려줍니다 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 로 이동 &lt;code&gt;heroes/:id&lt;/code&gt; . &lt;code&gt;:id&lt;/code&gt; 그 값이있는 경로 매개 변수 &lt;code&gt;id&lt;/code&gt; 편집 할 영웅.</target>
        </trans-unit>
        <trans-unit id="72ff44014ef60a516903197c78b674811bdbbea1" translate="yes" xml:space="preserve">
          <source>When a user clicks the button, the &lt;code&gt;profileForm&lt;/code&gt; model is updated with new values for &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;street&lt;/code&gt;. Notice that &lt;code&gt;street&lt;/code&gt; is provided in an object inside the &lt;code&gt;address&lt;/code&gt; property. This is necessary because the &lt;code&gt;patchValue()&lt;/code&gt; method applies the update against the model structure. &lt;code&gt;PatchValue()&lt;/code&gt; only updates properties that the form model defines.</source>
          <target state="translated">사용자가 버튼을 클릭하면 &lt;code&gt;profileForm&lt;/code&gt; 모델이 &lt;code&gt;firstName&lt;/code&gt; 및 &lt;code&gt;street&lt;/code&gt; 의 새 값으로 업데이트됩니다 . 통지 &lt;code&gt;street&lt;/code&gt; 내부 객체에 제공되는 &lt;code&gt;address&lt;/code&gt; 속성입니다. &lt;code&gt;patchValue()&lt;/code&gt; 메소드는 모델 구조에 대한 업데이트를 적용 하기 때문에 필요합니다 . &lt;code&gt;PatchValue()&lt;/code&gt; 는 양식 모델이 정의한 속성 만 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="5e7904f8fa1f1502df6bd3b94de8f69ab0c6c02d" translate="yes" xml:space="preserve">
          <source>When a user presses and releases a key, the &lt;code&gt;keyup&lt;/code&gt; event occurs, and Angular provides a corresponding DOM event object in the &lt;code&gt;$event&lt;/code&gt; variable which this code passes as a parameter to the component's &lt;code&gt;onKey()&lt;/code&gt; method.</source>
          <target state="translated">사용자가 키를 눌렀다가 &lt;code&gt;keyup&lt;/code&gt; 이벤트가 발생하고 Angular는 &lt;code&gt;$event&lt;/code&gt; 변수 에 해당 DOM 이벤트 객체를 제공합니다. 이 이벤트 는이 코드가 구성 요소의 &lt;code&gt;onKey()&lt;/code&gt; 메서드에 매개 변수로 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="d3234f0499ea9f65642e43dacff906896c520058" translate="yes" xml:space="preserve">
          <source>When a view uses the &lt;a href=&quot;changedetectionstrategy#OnPush&quot;&gt;OnPush&lt;/a&gt; (checkOnce) change detection strategy, explicitly marks the view as changed so that it can be checked again.</source>
          <target state="translated">뷰가 &lt;a href=&quot;changedetectionstrategy#OnPush&quot;&gt;OnPush&lt;/a&gt; (checkOnce) 변경 감지 전략을 사용하는 경우 다시 확인할 수 있도록 뷰를 변경된 것으로 명시 적으로 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="92afbe4a7f59dc1d10742cbb3b2bd915712f7d27" translate="yes" xml:space="preserve">
          <source>When accessing multiple local refs with the same name in template bindings, the first is matched (previously, the last instance was matched).</source>
          <target state="translated">템플릿 바인딩에서 이름이 같은 여러 로컬 참조에 액세스 할 때 첫 번째가 일치합니다 (이전에는 마지막 인스턴스가 일치 함).</target>
        </trans-unit>
        <trans-unit id="f2a58965900b52ff44960aeb5d3b1ab8663f125a" translate="yes" xml:space="preserve">
          <source>When all dependencies are in place, &lt;code&gt;AppComponent&lt;/code&gt; displays the user information.</source>
          <target state="translated">모든 종속성이 있으면 &lt;code&gt;AppComponent&lt;/code&gt; 에 사용자 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bd8f6d53233742cc77fab54767b182e5f57eee9a" translate="yes" xml:space="preserve">
          <source>When all requested services have been resolved and returned, Angular can call the component's constructor with those services as arguments.</source>
          <target state="translated">요청 된 모든 서비스가 해결되고 반환되면 Angular는 해당 서비스를 인수로 사용하여 구성 요소의 생성자를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b42dedf76e9162b85f232959c900f4d227b64bc8" translate="yes" xml:space="preserve">
          <source>When all routes were in one &lt;code&gt;AppRoutingModule&lt;/code&gt;, you put the default and &lt;a href=&quot;router#wildcard&quot;&gt;wildcard&lt;/a&gt; routes last, after the &lt;code&gt;/heroes&lt;/code&gt; route, so that the router had a chance to match a URL to the &lt;code&gt;/heroes&lt;/code&gt; route &lt;em&gt;before&lt;/em&gt; hitting the wildcard route and navigating to &quot;Page not found&quot;.</source>
          <target state="translated">모든 경로가 하나의 &lt;code&gt;AppRoutingModule&lt;/code&gt; 에 있으면 &lt;code&gt;/heroes&lt;/code&gt; 경로 다음에 기본 및 &lt;a href=&quot;router#wildcard&quot;&gt;와일드 카드&lt;/a&gt; 경로를 마지막에 배치하여 라우터가 와일드 카드 경로에 도달하고 &quot;페이지가 아닌 페이지로 이동 &lt;em&gt;하기 전에 &lt;/em&gt; &lt;code&gt;/heroes&lt;/code&gt; 경로에 URL을 일치시킬 수 있습니다. 녹이다&quot;.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="53aa78629efc3a0d160c3e30a269ba4457193e3c" translate="yes" xml:space="preserve">
          <source>When all routes were in one &lt;code&gt;AppRoutingModule&lt;/code&gt;, you put the default and &lt;a href=&quot;router-tutorial-toh#wildcard&quot;&gt;wildcard&lt;/a&gt; routes last, after the &lt;code&gt;/heroes&lt;/code&gt; route, so that the router had a chance to match a URL to the &lt;code&gt;/heroes&lt;/code&gt; route &lt;em&gt;before&lt;/em&gt; hitting the wildcard route and navigating to &quot;Page not found&quot;.</source>
          <target state="translated">모든 경로가 하나 있었다 때 &lt;code&gt;AppRoutingModule&lt;/code&gt; , 기본 넣어 &lt;a href=&quot;router-tutorial-toh#wildcard&quot;&gt;와일드 카드&lt;/a&gt; 후, 마지막 경로를 &lt;code&gt;/heroes&lt;/code&gt; 라우터가에 URL과 일치 할 수있는 기회가 있다고 그래서, 경로 &lt;code&gt;/heroes&lt;/code&gt; 경로 &lt;em&gt;전에&lt;/em&gt; 와일드 카드 경로를 타격 및 페이지 &quot;를하지 탐색을 녹이다&quot;.</target>
        </trans-unit>
        <trans-unit id="6d84e128eb398288da3157378d60b0938fa2d8fd" translate="yes" xml:space="preserve">
          <source>When an AngularJS component directive supports transclusion, it may use the &lt;code&gt;ng-transclude&lt;/code&gt; directive in its template to mark the transclusion point:</source>
          <target state="translated">AngularJS 컴포넌트 지시어가 변환을 지원할 때 템플리트에서 &lt;code&gt;ng-transclude&lt;/code&gt; 지시어를 사용하여 변환점을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0886c40024cc25c975acccf0b4cfdae9f2e72493" translate="yes" xml:space="preserve">
          <source>When an application contains a form, Angular must keep the view in sync with the component model and the component model in sync with the view. As users change values and make selections through the view, the new values must be reflected in the data model. Similarly, when the program logic changes values in the data model, those values must be reflected in the view.</source>
          <target state="translated">애플리케이션에 양식이 포함 된 경우 Angular는 뷰를 구성 요소 모델과 동기화하고 구성 요소 모델을 뷰와 동기화해야합니다. 사용자가보기를 통해 값을 변경하고 선택하면 새 값이 데이터 모델에 반영되어야합니다. 마찬가지로 프로그램 논리가 데이터 모델의 값을 변경하면 해당 값이 뷰에 반영되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3b810ca0a0152d462508ed51e0332b20030ce21c" translate="yes" xml:space="preserve">
          <source>When an application is laid out feature per feature in this way, it can also be migrated one feature at a time. For applications that don't already look like this, applying the rules in the AngularJS style guide is a highly recommended preparation step. And this is not just for the sake of the upgrade - it is just solid advice in general!</source>
          <target state="translated">이러한 방식으로 기능별로 기능이 배치 된 애플리케이션은 한 번에 하나의 기능으로 마이그레이션 할 수도 있습니다. 아직 이렇게 보이지 않는 응용 프로그램의 경우 AngularJS 스타일 가이드의 규칙을 적용하는 것이 좋습니다. 그리고 이것은 단지 업그레이드를위한 것이 아니라 일반적으로 확실한 조언입니다!</target>
        </trans-unit>
        <trans-unit id="fb7971a77be20ffccf8add017ec31580e42caf7e" translate="yes" xml:space="preserve">
          <source>When an application uses your library, there might be some services that your library supplies which the client app doesn't use. In this case, the app developer should expect that service to be tree-shaken, and not contribute to the size of the compiled app. Because the application developer cannot know about or remedy a tree-shaking problem in the library, it is the responsibility of the library developer to do so. To prevent the retention of unused components, your library should use the lightweight injection token design pattern.</source>
          <target state="translated">애플리케이션이 라이브러리를 사용할 때 라이브러리가 제공하는 일부 서비스 중 클라이언트 앱이 사용하지 않는 서비스가있을 수 있습니다. 이 경우 앱 개발자는 해당 서비스가 컴파일 된 앱의 크기에 영향을주지 않고 트리가 흔들릴 것으로 예상해야합니다. 응용 프로그램 개발자는 라이브러리의 트리 흔들림 문제를 알거나 해결할 수 없기 때문에이를 수행하는 것은 라이브러리 개발자의 책임입니다. 사용하지 않는 구성 요소의 보존을 방지하려면 라이브러리에서 경량 주입 토큰 디자인 패턴을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="47d77d1d4a7d81017ab7a88f89771a6bc5639dd4" translate="yes" xml:space="preserve">
          <source>When an applications starts, Angular first configures the root injector with the providers of all eagerly loaded NgModules &lt;em&gt;before&lt;/em&gt; creating its first component and injecting any of the provided services. Once the application begins, the app root injector is closed to new providers.</source>
          <target state="translated">응용 프로그램이 시작되면 Angular는 먼저 첫 번째 구성 요소 &lt;em&gt;를&lt;/em&gt; 만들고 제공된 서비스를 주입 &lt;em&gt;하기 전에&lt;/em&gt; 열심히로드 된 모든 NgModules의 공급자로 루트 인젝터를 구성합니다. 응용 프로그램이 시작되면 응용 프로그램 루트 인젝터가 새로운 공급자에게 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="de05fecb69b29988cfd38b015be38ee5c1e10d06" translate="yes" xml:space="preserve">
          <source>When an area of the template is set to have animations disabled, &lt;strong&gt;all&lt;/strong&gt; inner components have their animations disabled as well. This means that you can disable all animations for an app by placing a host binding set on &lt;code&gt;@.disabled&lt;/code&gt; on the topmost Angular component.</source>
          <target state="translated">템플릿 영역에서 애니메이션을 비활성화하도록 설정하면 &lt;strong&gt;모든&lt;/strong&gt; 내부 구성 요소에서도 애니메이션이 비활성화됩니다. 즉 , 최상위 Angular 구성 요소의 &lt;code&gt;@.disabled&lt;/code&gt; 에 호스트 바인딩 세트를 배치하여 앱의 모든 애니메이션을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2158e7ac2d535c8a0d73be64130946207704b5dd" translate="yes" xml:space="preserve">
          <source>When an eagerly loaded module provides a service, for example a &lt;code&gt;UserService&lt;/code&gt;, that service is available application-wide. If the root module provides &lt;code&gt;UserService&lt;/code&gt; and imports another module that provides the same &lt;code&gt;UserService&lt;/code&gt;, Angular registers one of them in the root app injector (see &lt;a href=&quot;ngmodule-faq#q-reimport&quot;&gt;What if I import the same module twice?&lt;/a&gt;).</source>
          <target state="translated">열성적으로로드 된 모듈이 서비스 (예 : &lt;code&gt;UserService&lt;/code&gt; )를 제공하면 해당 서비스를 응용 프로그램 전체에서 사용할 수 있습니다. 루트 모듈이 &lt;code&gt;UserService&lt;/code&gt; 를 제공하고 동일한 &lt;code&gt;UserService&lt;/code&gt; 를 제공하는 다른 모듈을 가져 오는 경우 Angular는 루트 앱 인젝터에 그 중 하나를 등록 &lt;a href=&quot;ngmodule-faq#q-reimport&quot;&gt;합니다 (동일한 모듈을 두 번 가져 오면 어떻게합니까? 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="05aae7978db62e7e7c9429220e2ca190a4d0d35e" translate="yes" xml:space="preserve">
          <source>When an element is repeated within &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt;, the context is an &lt;code&gt;NgForRow&lt;/code&gt; whose &lt;code&gt;$implicit&lt;/code&gt; property is the value of the row instance value. For example, the &lt;code&gt;hero&lt;/code&gt; in &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;=&quot;let hero of heroes&quot;&lt;/code&gt;.</source>
          <target state="translated">요소가 &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 내에서 반복 되면 컨텍스트는 &lt;code&gt;$implicit&lt;/code&gt; 특성이 행 인스턴스 값의 값인 &lt;code&gt;NgForRow&lt;/code&gt; 입니다 . 예를 들어, &lt;code&gt;hero&lt;/code&gt; 의 &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;=&quot;let hero of heroes&quot;&lt;/code&gt; &lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor은&lt;/a&gt; &quot;영웅의 영웅을하자&quot;= .</target>
        </trans-unit>
        <trans-unit id="2c546d06df1559440a1db83b4e5c1db73f342fce" translate="yes" xml:space="preserve">
          <source>When an element within an HTML template has animations disabled using the &lt;code&gt;@.disabled&lt;/code&gt; host binding, animations are disabled on all inner elements as well. You can't selectively disable multiple animations on a single element.</source>
          <target state="translated">HTML 템플릿 내의 요소에 &lt;code&gt;@.disabled&lt;/code&gt; 호스트 바인딩을 사용하여 애니메이션을 비활성화하면 모든 내부 요소에서도 애니메이션이 비활성화됩니다. 단일 요소에서 여러 애니메이션을 선택적으로 비활성화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cf49456ce12909b793be4a1b5a0118ed11f90553" translate="yes" xml:space="preserve">
          <source>When an error occurs, you can obtain details of what failed in order to inform your user. In some cases, you might also automatically &lt;a href=&quot;http#retry&quot;&gt;retry the request&lt;/a&gt;.</source>
          <target state="translated">오류가 발생하면 사용자에게 알리기 위해 실패한 사항에 대한 세부 정보를 얻을 수 있습니다. 경우에 &lt;a href=&quot;http#retry&quot;&gt;따라 요청을&lt;/a&gt; 자동으로 재 시도 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d91d5acbcb6e8adb1db7278d2b85940b8c059799" translate="yes" xml:space="preserve">
          <source>When an item is added, a new instance of the template is added to the DOM.</source>
          <target state="translated">항목이 추가되면 템플릿의 새 인스턴스가 DOM에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6812fd0a944e938e939802bbf208e98821182752" translate="yes" xml:space="preserve">
          <source>When an item is removed, its template instance is removed from the DOM.</source>
          <target state="translated">항목이 제거되면 해당 템플리트 인스턴스가 DOM에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="5a9a8569048e0b049afa4c46c8590c8fbf5d8867" translate="yes" xml:space="preserve">
          <source>When an output property emits an event, an event handler attached to that event in the template is invoked.</source>
          <target state="translated">출력 특성이 이벤트를 생성하면 템플리트에서 해당 이벤트에 첨부 된 이벤트 핸들러가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="48be3c6780f2769a1c858ad1d1455b0a6aff02d0" translate="yes" xml:space="preserve">
          <source>When animations are disabled, &lt;code&gt;&lt;a href=&quot;../api/animations/transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; styles can be skipped, but &lt;code&gt;&lt;a href=&quot;../api/animations/state&quot;&gt;state&lt;/a&gt;()&lt;/code&gt; styles can't.</source>
          <target state="translated">애니메이션이 비활성화되면 &lt;code&gt;&lt;a href=&quot;../api/animations/transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; 스타일을 건너 뛸 수 있지만 &lt;code&gt;&lt;a href=&quot;../api/animations/state&quot;&gt;state&lt;/a&gt;()&lt;/code&gt; 스타일은 건너 뛸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e7a21063df73c511a2f56f2ef1bf9a8ff345822c" translate="yes" xml:space="preserve">
          <source>When animations are disabled, &lt;code&gt;&lt;a href=&quot;../api/animations/transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; styles can be skipped, but &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/%24locationshim#state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; styles can't.</source>
          <target state="translated">애니메이션이 비활성화되면 &lt;code&gt;&lt;a href=&quot;../api/animations/transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; 스타일은 건너 뛸 수 있지만 &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/%24locationshim#state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; 스타일은 건너 뛸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ac94510c5d5464b64237bd0b1d59b22bf0887771" translate="yes" xml:space="preserve">
          <source>When applied to an element in a template, makes that element a link that initiates navigation to a route. Navigation opens one or more routed components in one or more &lt;code&gt;&amp;lt;&lt;a href=&quot;router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; locations on the page.</source>
          <target state="translated">템플릿의 요소에 적용하면 해당 요소를 경로 탐색을 시작하는 링크로 만듭니다. 탐색은 페이지의 하나 이상의 &lt;code&gt;&amp;lt;&lt;a href=&quot;router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; 위치 에서 하나 이상의 라우팅 된 구성 요소를 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="436ea258a3a19f4814ff3c058ec982f98f3481d0" translate="yes" xml:space="preserve">
          <source>When applied to an element in a template, makes that element a link that initiates navigation to a route. Navigation opens one or more routed components in one or more &lt;code&gt;&amp;lt;&lt;a href=&quot;routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; locations on the page.</source>
          <target state="translated">템플릿의 요소에 적용하면 해당 요소를 경로 탐색을 시작하는 링크로 만듭니다. 탐색은 페이지의 하나 이상의 &lt;code&gt;&amp;lt;&lt;a href=&quot;routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; 위치 에서 하나 이상의 라우팅 된 구성 요소를 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="29c152c927172bc42277bd311cf9c51039c351e7" translate="yes" xml:space="preserve">
          <source>When autodetect is &lt;code&gt;true&lt;/code&gt;, the test fixture calls &lt;code&gt;detectChanges&lt;/code&gt; immediately after creating the component. Then it listens for pertinent zone events and calls &lt;code&gt;detectChanges&lt;/code&gt; accordingly. When your test code modifies component property values directly, you probably still have to call &lt;code&gt;fixture.detectChanges&lt;/code&gt; to trigger data binding updates.</source>
          <target state="translated">autodetect가 &lt;code&gt;true&lt;/code&gt; 인 경우 테스트 픽스처 는 구성 요소를 &lt;code&gt;detectChanges&lt;/code&gt; 후 즉시 detectChanges를 호출 합니다. 그런 다음 관련 영역 이벤트를 수신하고 &lt;code&gt;detectChanges&lt;/code&gt; 따라 detectChanges를 호출합니다 . 테스트 코드가 구성 요소 속성 값을 직접 수정 하는 경우 데이터 바인딩 업데이트를 트리거 하려면 여전히 &lt;code&gt;fixture.detectChanges&lt;/code&gt; 를 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1ecd519d8a9d8489a70ac8222bf8f59f12cfdafb" translate="yes" xml:space="preserve">
          <source>When binding to ARIA attributes in Angular, you must use the &lt;code&gt;attr.&lt;/code&gt; prefix, as the ARIA specification depends specifically on HTML attributes rather than properties of DOM elements.</source>
          <target state="translated">Angular에서 ARIA 속성에 바인딩 할 때 &lt;code&gt;attr.&lt;/code&gt; 사용해야합니다 . ARIA 사양은 DOM 요소의 속성보다는 HTML 속성에 특별히 의존하기 때문에 접두사입니다.</target>
        </trans-unit>
        <trans-unit id="a2068eaf5a2c701ccbfce60b3646bbea4685601e" translate="yes" xml:space="preserve">
          <source>When binding to ARIA attributes in Angular, you must use the &lt;code&gt;attr.&lt;/code&gt; prefix, as the ARIA specification depends specifically on HTML attributes rather than properties on DOM elements.</source>
          <target state="translated">Angular에서 ARIA 속성에 바인딩 할 때는 &lt;code&gt;attr.&lt;/code&gt; 사용해야합니다 . ARIA 사양은 DOM 요소의 속성이 아닌 HTML 속성에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="1d403c7f0a15567441991f43194df4dfc6f894d3" translate="yes" xml:space="preserve">
          <source>When bootstrapping a new root component into an application, Angular mounts the specified application component onto DOM elements identified by the componentType's selector and kicks off automatic change detection to finish initializing the component.</source>
          <target state="translated">새 루트 구성 요소를 응용 프로그램에 부트 스트랩 할 때 Angular는 지정된 응용 프로그램 구성 요소를 componentType의 선택기로 식별 된 DOM 요소에 마운트하고 자동 변경 감지를 시작하여 구성 요소 초기화를 완료합니다.</target>
        </trans-unit>
        <trans-unit id="0d4d47affb8c464a81063c15c40e841a06125813" translate="yes" xml:space="preserve">
          <source>When both guard and resolvers are specified, the resolvers are not executed until all guards have run and succeeded. For example, consider the following route configuration:</source>
          <target state="translated">가드와 리졸버가 모두 지정되면 모든 가드가 실행되고 성공할 때까지 리졸버가 실행되지 않습니다. 예를 들어 다음 경로 구성을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2b86c2426923dc82f318377489363981eae2a0e1" translate="yes" xml:space="preserve">
          <source>When building Angular applications you can take advantage of sophisticated first-party libraries, such as &lt;a href=&quot;https://material.angular.io/&quot;&gt;Angular Material&lt;/a&gt;, as well as rich ecosystem of third-party libraries. See the &lt;a href=&quot;https://angular.io/resources&quot;&gt;Angular Resources&lt;/a&gt; page for links to the most popular ones.</source>
          <target state="translated">Angular 애플리케이션을 빌드 할 때 &lt;a href=&quot;https://material.angular.io/&quot;&gt;Angular Material&lt;/a&gt; 과 같은 정교한 자사 라이브러리 및 타사 라이브러리의 풍부한 에코 시스템을 활용할 수 있습니다 . 가장 인기있는 것들에 대한 링크 는 &lt;a href=&quot;https://angular.io/resources&quot;&gt;Angular Resources&lt;/a&gt; 페이지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3538cbab0f3099d8265f02d7a64fc66ea5ca6d1e" translate="yes" xml:space="preserve">
          <source>When building Angular applications you can take advantage of sophisticated first-party libraries, such as &lt;a href=&quot;https://material.angular.io/&quot;&gt;Angular Material&lt;/a&gt;, as well as rich ecosystem of third-party libraries. See the &lt;a href=&quot;resources&quot;&gt;Angular Resources&lt;/a&gt; page for links to the most popular ones.</source>
          <target state="translated">Angular 애플리케이션을 빌드 할 때 &lt;a href=&quot;https://material.angular.io/&quot;&gt;Angular Material&lt;/a&gt; 과 같은 정교한 자사 라이브러리와 타사 라이브러리의 풍부한 에코 시스템을 활용할 수 있습니다 . 가장 인기있는 링크 는 &lt;a href=&quot;resources&quot;&gt;Angular 리소스&lt;/a&gt; 페이지를 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="89bb95bbe2563b71f388aa0a0055510166a2c680" translate="yes" xml:space="preserve">
          <source>When building applications, you want to ensure that only the required resources are loaded when necessary. Whether that be loading of assets or code, making sure everything that can be deferred until needed keeps your application running efficiently. This is especially true when running different frameworks in the same application.</source>
          <target state="translated">응용 프로그램을 빌드 할 때 필요한 경우 필요한 자원 만로드되도록하려고합니다. 자산로드 또는 코드로드 여부에 관계없이 필요할 때까지 지연 될 수있는 모든 항목으로 인해 애플리케이션이 효율적으로 실행됩니다. 동일한 응용 프로그램에서 다른 프레임 워크를 실행할 때 특히 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="9386092cd495cfdab016752500f432eb023edc15" translate="yes" xml:space="preserve">
          <source>When building complex forms, managing the different areas of information is easier in smaller sections, and some groups of information naturally fall into the same group. Using a nested form group instance allows you to break large forms groups into smaller, more manageable ones.</source>
          <target state="translated">복잡한 양식을 작성할 때 여러 섹션의 정보를보다 쉽게 ​​관리 할 수 ​​있으며 일부 정보 그룹은 자연스럽게 동일한 그룹에 속합니다. 중첩 된 양식 그룹 인스턴스를 사용하면 큰 양식 그룹을보다 작고 관리하기 쉬운 그룹으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c507192c860dccde88e0964befd1399320d26903" translate="yes" xml:space="preserve">
          <source>When building complex forms, managing the different areas of information is easier in smaller sections. Using a nested form group instance allows you to break large forms groups into smaller, more manageable ones.</source>
          <target state="translated">복잡한 양식을 작성할 때 작은 섹션에서 다양한 정보 영역을 더 쉽게 관리 할 수 ​​있습니다. 중첩 된 양식 그룹 인스턴스를 사용하면 큰 양식 그룹을 더 작고 관리하기 쉬운 그룹으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fc20bd4d6affd513b7a83567c797dc2341e8f77" translate="yes" xml:space="preserve">
          <source>When building forms in Angular, it's important to understand how the framework handles data flowing from the user or from programmatic changes. Reactive and template-driven forms follow two different strategies when handling form input. The data flow examples below begin with the favorite color input field example from above, and then show how changes to favorite color are handled in reactive forms compared to template-driven forms.</source>
          <target state="translated">Angular에서 양식을 작성할 때 프레임 워크가 사용자 또는 프로그래밍 방식 변경에서 흐르는 데이터를 처리하는 방법을 이해하는 것이 중요합니다. 반응 형 및 템플릿 기반 양식은 양식 입력을 처리 할 때 두 가지 전략을 따릅니다. 아래의 데이터 흐름 예제는 위에서 선호하는 색상 입력 필드 예제로 시작한 다음 템플릿 기반 양식에 비해 반응 형 양식에서 선호 색상 변경을 처리하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6fc9bc402f56e1c96af7199e1d509f4661b9855c" translate="yes" xml:space="preserve">
          <source>When building web applications, making sure your application is compatible with the majority of browsers is a goal. Even as JavaScript continues to evolve, with new features being introduced, not all browsers are updated with support for these new features at the same pace.</source>
          <target state="translated">웹 애플리케이션을 빌드 할 때 애플리케이션이 대부분의 브라우저와 호환되는지 확인하는 것이 목표입니다. 새로운 기능이 도입되면서 JavaScript가 계속 발전하더라도 모든 브라우저가 이러한 새로운 기능을 동일한 속도로 지원하도록 업데이트되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5b742400e1e277930228a0191e1a7a39fe26b49a" translate="yes" xml:space="preserve">
          <source>When building web applications, you want to make sure your application is compatible with the majority of browsers. Even as JavaScript continues to evolve, with new features being introduced, not all browsers are updated with support for these new features at the same pace.</source>
          <target state="translated">웹 애플리케이션을 빌드 할 때 애플리케이션이 대부분의 브라우저와 호환되는지 확인하려고합니다. 새로운 기능이 도입됨에 따라 JavaScript가 계속 발전하고 있지만 모든 브라우저가 동일한 속도로 이러한 새로운 기능을 지원하도록 업데이트되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f8b8eff21bbd0f8e5d36d2990adb2865268b95d6" translate="yes" xml:space="preserve">
          <source>When building with the CLI, be sure to include the linked style file among the assets to be copied to the server as described in the &lt;a href=&quot;https://github.com/angular/angular-cli/wiki/stories-asset-configuration&quot;&gt;CLI wiki&lt;/a&gt;.</source>
          <target state="translated">CLI로 빌드 할 때 &lt;a href=&quot;https://github.com/angular/angular-cli/wiki/stories-asset-configuration&quot;&gt;CLI 위키에&lt;/a&gt; 설명 된대로 서버에 복사 할 자산 사이에 링크 된 스타일 파일을 포함 시키십시오 .</target>
        </trans-unit>
        <trans-unit id="bab6d7c828b83308f18a53ca8a90ddce5abb3f87" translate="yes" xml:space="preserve">
          <source>When building with the CLI, you must configure the &lt;code&gt;angular.json&lt;/code&gt; to include &lt;em&gt;all external assets&lt;/em&gt;, including external style files.</source>
          <target state="translated">CLI를 사용하여 빌드 할 때 외부 스타일 파일을 포함하여 &lt;em&gt;모든 외부 자산&lt;/em&gt; 을 포함 하도록 &lt;code&gt;angular.json&lt;/code&gt; 을 구성해야 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1bf2af4af56d10c85356870b1e312679a109012f" translate="yes" xml:space="preserve">
          <source>When called with unknown elements, such as a custom element name (&lt;code&gt;popup-element&lt;/code&gt; in our example), the methods will return a generic type, such as &lt;code&gt;HTMLElement&lt;/code&gt;, since TypeScript can't infer the correct type of the returned element.</source>
          <target state="translated">사용자 정의 요소 이름 (이 예제에서는 &lt;code&gt;popup-element&lt;/code&gt; 요소)과 같은 알 수없는 요소로 호출되면 TypeScript는 반환 된 요소의 올바른 유형을 유추 할 수 없으므로 &lt;code&gt;HTMLElement&lt;/code&gt; 와 같은 일반 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="63d51b615b5761b9b503679d40bc888ba4267a20" translate="yes" xml:space="preserve">
          <source>When called within a &lt;code&gt;&lt;a href=&quot;sequence&quot;&gt;sequence&lt;/a&gt;()&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; call, does not continue to the next instruction until all of the inner animation steps have completed.</source>
          <target state="translated">내에서 호출 할 때 &lt;code&gt;&lt;a href=&quot;sequence&quot;&gt;sequence&lt;/a&gt;()&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; 호출 내부 애니메이션의 모든 단계가 완료 될 때까지, 다음 명령어로 계속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc86cf8f39cfd1795f74b2f88d47a1dafd6a033a" translate="yes" xml:space="preserve">
          <source>When compiling a template, you need to determine a set of selectors which should be used for triggering their corresponding directives.</source>
          <target state="translated">템플릿을 컴파일 할 때 해당 지시문을 트리거하는 데 사용해야하는 선택기 집합을 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="eff0e89b5209a2cd9fe83f63b8126db2c132d8ea" translate="yes" xml:space="preserve">
          <source>When creating an &lt;code&gt;&lt;a href=&quot;injectiontoken&quot;&gt;InjectionToken&lt;/a&gt;&lt;/code&gt;, you can optionally specify a factory function which returns (possibly by creating) a default value of the parameterized type &lt;code&gt;T&lt;/code&gt;. This sets up the &lt;code&gt;&lt;a href=&quot;injectiontoken&quot;&gt;InjectionToken&lt;/a&gt;&lt;/code&gt; using this factory as a provider as if it was defined explicitly in the application's root injector. If the factory function, which takes zero arguments, needs to inject dependencies, it can do so using the &lt;code&gt;inject&lt;/code&gt; function. See below for an example.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;injectiontoken&quot;&gt;InjectionToken&lt;/a&gt;&lt;/code&gt; 을 생성 할 때 매개 변수화 된 유형 &lt;code&gt;T&lt;/code&gt; 의 기본값을 작성하여 (가능한 경우) 팩토리 함수를 선택적으로 지정할 수 있습니다 . 이것은 어플리케이션의 루트 인젝터에 명시 적으로 정의 된 것처럼이 팩토리를 제공자로 사용 하여 &lt;code&gt;&lt;a href=&quot;injectiontoken&quot;&gt;InjectionToken&lt;/a&gt;&lt;/code&gt; 을 설정합니다 . 인수가 0 인 팩토리 함수가 종속성을 주입해야하는 경우, &lt;code&gt;inject&lt;/code&gt; 기능을 사용하여 수행 할 수 있습니다 . 예는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a06654762cbf15c6a7d824d62d5f3ff30f8cd430" translate="yes" xml:space="preserve">
          <source>When creating an observable you should determine how you want that observable to be used and whether or not you want to multicast its values.</source>
          <target state="translated">Observable을 생성 할 때 Observable의 사용 방법과 해당 값을 멀티 캐스트할지 여부를 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d1e3e29636aebc1983bfce61a744145fc07ef5de" translate="yes" xml:space="preserve">
          <source>When defining a &lt;a href=&quot;glossary#directive&quot;&gt;directive&lt;/a&gt;, the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; decorator on a directive property makes that property available as a &lt;em&gt;target&lt;/em&gt; of a &lt;a href=&quot;property-binding&quot;&gt;property binding&lt;/a&gt;. Data values flow into an input property from the data source identified in the &lt;a href=&quot;glossary#template-expression&quot;&gt;template expression&lt;/a&gt; to the right of the equal sign.</source>
          <target state="translated">결정적인 경우 &lt;a href=&quot;glossary#directive&quot;&gt;지시문&lt;/a&gt; 은 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 도파 특성에 장식은 그 속성으로서 사용할 수 있도록 &lt;em&gt;타겟&lt;/em&gt; (A)의 &lt;a href=&quot;property-binding&quot;&gt;결합 속성&lt;/a&gt; . 데이터 값 은 등호 오른쪽의 &lt;a href=&quot;glossary#template-expression&quot;&gt;템플릿 식에서&lt;/a&gt; 식별 된 데이터 소스에서 입력 속성으로 흐릅니다 .</target>
        </trans-unit>
        <trans-unit id="749c6b45f20c32758d29b06fe77e09e8859f0280" translate="yes" xml:space="preserve">
          <source>When defining a &lt;a href=&quot;glossary#directive&quot;&gt;directive&lt;/a&gt;, the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; decorator on a directive property makes that property available as a &lt;em&gt;target&lt;/em&gt; of a &lt;a href=&quot;template-syntax#property-binding&quot;&gt;property binding&lt;/a&gt;. Data values flow into an input property from the data source identified in the &lt;a href=&quot;glossary#template-expression&quot;&gt;template expression&lt;/a&gt; to the right of the equal sign.</source>
          <target state="translated">결정적인 경우 &lt;a href=&quot;glossary#directive&quot;&gt;지시문&lt;/a&gt; 은 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 도파 특성에 장식은 그 속성으로서 사용할 수 있도록 &lt;em&gt;타겟&lt;/em&gt; (A)의 &lt;a href=&quot;template-syntax#property-binding&quot;&gt;결합 속성&lt;/a&gt; . 데이터 값은 &lt;a href=&quot;glossary#template-expression&quot;&gt;등식&lt;/a&gt; 의 오른쪽 에있는 템플릿 표현식 에서 식별 된 데이터 소스에서 입력 특성으로 흐릅니다 .</target>
        </trans-unit>
        <trans-unit id="2801c378bff57f04aaa6ea04537d4ba004eea0d8" translate="yes" xml:space="preserve">
          <source>When defining a &lt;a href=&quot;glossary#directive&quot;&gt;directive&lt;/a&gt;, the &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;{}&lt;/code&gt; decorator on a directive property makes that property available as a &lt;em&gt;target&lt;/em&gt; of &lt;a href=&quot;event-binding&quot;&gt;event binding&lt;/a&gt;. Events stream &lt;em&gt;out&lt;/em&gt; of this property to the receiver identified in the &lt;a href=&quot;glossary#template-expression&quot;&gt;template expression&lt;/a&gt; to the right of the equal sign.</source>
          <target state="translated">결정적인 때 &lt;a href=&quot;glossary#directive&quot;&gt;지시문을&lt;/a&gt; 의 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;{}&lt;/code&gt; 지시어 재산에 장식은으로 그 속성을 사용할 수 있도록 &lt;em&gt;대상&lt;/em&gt; 의 &lt;a href=&quot;event-binding&quot;&gt;이벤트 바인딩&lt;/a&gt; . 이벤트 는이 속성 에서 등호 오른쪽의 &lt;a href=&quot;glossary#template-expression&quot;&gt;템플릿 표현식&lt;/a&gt; 에서 식별 된 수신자로 스트리밍 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4307d2cc44bc7a97d4a4418574bb1547f7624e08" translate="yes" xml:space="preserve">
          <source>When defining a &lt;a href=&quot;glossary#directive&quot;&gt;directive&lt;/a&gt;, the &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;{}&lt;/code&gt; decorator on a directive property makes that property available as a &lt;em&gt;target&lt;/em&gt; of &lt;a href=&quot;template-syntax#event-binding&quot;&gt;event binding&lt;/a&gt;. Events stream &lt;em&gt;out&lt;/em&gt; of this property to the receiver identified in the &lt;a href=&quot;glossary#template-expression&quot;&gt;template expression&lt;/a&gt; to the right of the equal sign.</source>
          <target state="translated">결정적인 때 &lt;a href=&quot;glossary#directive&quot;&gt;지시문을&lt;/a&gt; 의 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;{}&lt;/code&gt; 지시어 재산에 장식은으로 그 속성을 사용할 수 있도록 &lt;em&gt;대상&lt;/em&gt; 의 &lt;a href=&quot;template-syntax#event-binding&quot;&gt;이벤트 바인딩&lt;/a&gt; . 이 속성에서 이벤트 는 등호 오른쪽의 &lt;a href=&quot;glossary#template-expression&quot;&gt;템플릿 표현식&lt;/a&gt; 에서 식별 된 수신자에게 스트리밍 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3cef3cb91c2c647878c9cddaa3fa8393736c0a9d" translate="yes" xml:space="preserve">
          <source>When do I add components to &lt;code&gt;entryComponents&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;entryComponents&lt;/code&gt; 에 구성 요소를 언제 추가 합니까?</target>
        </trans-unit>
        <trans-unit id="e4be4307e52967d21c990d182cfe4e0ac164bd6d" translate="yes" xml:space="preserve">
          <source>When enabled, the &lt;code&gt;.js&lt;/code&gt; output of &lt;code&gt;ngc&lt;/code&gt; does not include any lazy-loaded template or style URLs.</source>
          <target state="translated">활성화하면 &lt;code&gt;ngc&lt;/code&gt; 의 &lt;code&gt;.js&lt;/code&gt; 출력에 지연로드 템플릿 또는 스타일 URL이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9fc91b10b4c2892fce952b0e57b529770411dad7" translate="yes" xml:space="preserve">
          <source>When enabling the new strict mode in version 9, you might encounter template errors that didn't arise in either of the previous modes. These errors often represent genuine type mismatches in the templates that were not caught by the previous tooling. If this is the case, the error message should make it clear where in the template the problem occurs.</source>
          <target state="translated">버전 9에서 새로운 엄격 모드를 활성화 할 때 이전 모드 중 하나에서 발생하지 않은 템플릿 오류가 발생할 수 있습니다. 이러한 오류는 종종 이전 도구에서 포착되지 않은 템플릿의 실제 유형 불일치를 나타냅니다. 이 경우 오류 메시지는 템플릿에서 문제가 발생한 위치를 명확하게 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="78cfd68dc9b0bf523c79b28df0b08d4cf40e6063" translate="yes" xml:space="preserve">
          <source>When false (the default), removes blank text nodes from compiled templates, which results in smaller emitted template factory modules. Set to true to preserve blank text nodes.</source>
          <target state="translated">false 인 경우 (기본값) 컴파일 된 템플릿에서 빈 텍스트 노드를 제거하여 더 작은 방출 템플릿 팩토리 모듈을 생성합니다. 빈 텍스트 노드를 유지하려면 true로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="a48aec62988f1ccca24b1925a6fcfd92ea3a485f" translate="yes" xml:space="preserve">
          <source>When false, disables interactive input prompts.</source>
          <target state="translated">false 인 경우 대화식 입력 프롬프트를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="187407e31db6569d8a862bbe786d50251332d665" translate="yes" xml:space="preserve">
          <source>When false, factory files are generated only for &lt;code&gt;.ts&lt;/code&gt; files. Do this when using factory summaries.</source>
          <target state="translated">false 인 경우 팩토리 파일은 &lt;code&gt;.ts&lt;/code&gt; 파일에 대해서만 생성됩니다 . 팩토리 요약을 사용할 때이를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ef603dd1a4473adca892b6e5005cb3af75201392" translate="yes" xml:space="preserve">
          <source>When generating a component file with &lt;code&gt;ng generate component&lt;/code&gt;, the CLI emits an empty CSS styles file (&lt;code&gt;.css&lt;/code&gt;) by default. You can configure the CLI to default to your preferred CSS preprocessor as explained in the &lt;a href=&quot;https://github.com/angular/angular-cli/wiki/stories-css-preprocessors&quot;&gt;CLI wiki&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ng generate component&lt;/code&gt; 로 구성 요소 파일을 생성 할 때 CLI 는 기본적으로 빈 CSS 스타일 파일 ( &lt;code&gt;.css&lt;/code&gt; )을 생성합니다. &lt;a href=&quot;https://github.com/angular/angular-cli/wiki/stories-css-preprocessors&quot;&gt;CLI 위키에&lt;/a&gt; 설명 된대로 기본 CSS 프리 프로세서를 기본값으로 CLI를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f8b7dce71874522c7e0f1d98b7e48a92163a09b" translate="yes" xml:space="preserve">
          <source>When generating a new app, the CLI prompts you to select CSS or a CSS preprocessor. For this example, accept the default of &lt;code&gt;CSS&lt;/code&gt;.</source>
          <target state="translated">새 앱을 생성 할 때 CLI는 CSS 또는 CSS 전처리기를 선택하라는 메시지를 표시합니다. 이 예에서는 기본값 인 &lt;code&gt;CSS&lt;/code&gt; 를 수락합니다 .</target>
        </trans-unit>
        <trans-unit id="e66e299f045744162ddfe45522dbce7add492b38" translate="yes" xml:space="preserve">
          <source>When given a tuple with x and y position value, the router uses that offset each time it scrolls. When given a function, the router invokes the function every time it restores scroll position.</source>
          <target state="translated">x 및 y 위치 값이있는 튜플이 제공되면 라우터는 스크롤 할 때마다 해당 오프셋을 사용합니다. 함수가 주어지면 라우터는 스크롤 위치를 복원 할 때마다 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7ef92686417b75b5cbea84d910778edba78cd2a4" translate="yes" xml:space="preserve">
          <source>When given an activated route, applies the given commands starting from the route. Otherwise, applies the given command starting from the root.</source>
          <target state="translated">활성화 된 경로가 지정되면 경로에서 시작하여 지정된 명령을 적용합니다. 그렇지 않으면 루트에서 시작하여 지정된 명령을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="53849b6fde8d2206f676efc5f57c1bff53663e80" translate="yes" xml:space="preserve">
          <source>When implementing &lt;code&gt;registerOnTouched&lt;/code&gt; in your own value accessor, save the given function so your class calls it when the control should be considered blurred or &quot;touched&quot;.</source>
          <target state="translated">자신의 값 접근 자에서 &lt;code&gt;registerOnTouched&lt;/code&gt; 를 구현할 때 컨트롤이 흐리게 표시되거나 &quot;터치&quot;된 것으로 간주 될 때 클래스가 호출하도록 지정된 함수를 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="6659f36f8906d9b6df663ed12a7ea8edf531eaf8" translate="yes" xml:space="preserve">
          <source>When implementing the &lt;code&gt;registerOnChange&lt;/code&gt; method in your own value accessor, save the given function so your class calls it at the appropriate time.</source>
          <target state="translated">자체 값 접근 자에서 &lt;code&gt;registerOnChange&lt;/code&gt; 메소드를 구현할 때 클래스가 적절한 시간에 호출하도록 지정된 함수를 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="e24b1f3a3c5786e4d0e0b368b389c36801747d1a" translate="yes" xml:space="preserve">
          <source>When injected, &lt;code&gt;&lt;a href=&quot;httpbackend&quot;&gt;HttpBackend&lt;/a&gt;&lt;/code&gt; dispatches requests directly to the backend, without going through the interceptor chain.</source>
          <target state="translated">주입되면 &lt;code&gt;&lt;a href=&quot;httpbackend&quot;&gt;HttpBackend&lt;/a&gt;&lt;/code&gt; 는 인터셉터 체인을 거치지 않고 요청을 백엔드로 직접 발송합니다.</target>
        </trans-unit>
        <trans-unit id="580455f83a9bed03f0a9761dbfac0d9fa7233a45" translate="yes" xml:space="preserve">
          <source>When instantiating a &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt;, pass in a collection of child controls as the first argument. The key for each child registers the name for the control.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 을 인스턴스화 할 때 하위 컨트롤 컬렉션을 첫 번째 인수로 전달하십시오. 각 자식의 키는 컨트롤의 이름을 등록합니다.</target>
        </trans-unit>
        <trans-unit id="1dd82c5d8059bec900275dede8a10d9747aa6216" translate="yes" xml:space="preserve">
          <source>When it appears in &lt;strong&gt;square brackets&lt;/strong&gt; ([ ]) to the &lt;strong&gt;left&lt;/strong&gt; of the equals (=), the property belongs to some &lt;em&gt;other&lt;/em&gt; component or directive; that property must be adorned with the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; decorator.</source>
          <target state="translated">이 나타나면 &lt;strong&gt;각괄호&lt;/strong&gt; ([])가로 &lt;strong&gt;왼쪽&lt;/strong&gt; 등호 (=)의 일부 속성에 속하는 &lt;em&gt;다른&lt;/em&gt; 성분 또는 지시자; 이 속성은 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; 데코레이터 로 장식해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c9f1c7ae270dcf8ed2fb36e356720b2282a2234b" translate="yes" xml:space="preserve">
          <source>When it appears in the template expression to the &lt;strong&gt;&lt;em&gt;right&lt;/em&gt;&lt;/strong&gt; of the equals (=), it belongs to the template's component and does not require the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; decorator.</source>
          <target state="translated">등호 (=) 의 &lt;strong&gt;&lt;em&gt;오른쪽&lt;/em&gt;&lt;/strong&gt; 에있는 템플리트 표현식에 표시되면 템플리트의 구성 요소에 속하며 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; 데코레이터가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="726cccf06c149c75e2bcbaec1213fc068eb64d58" translate="yes" xml:space="preserve">
          <source>When it returns true, the router will execute the regular navigation. When it returns false, the router will set the router state to an empty state. As a result, all the active components will be destroyed.</source>
          <target state="translated">true를 반환하면 라우터는 일반 탐색을 실행합니다. false를 반환하면 라우터는 라우터 상태를 빈 상태로 설정합니다. 결과적으로 모든 활성 구성 요소가 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="65bc0e8f54c69a39293ba4c95d5c5b7ea95eb9e8" translate="yes" xml:space="preserve">
          <source>When items are added, moved, or removed in the iterable, the directive must re-render the appropriate DOM nodes. To minimize churn in the DOM, only nodes that have changed are re-rendered.</source>
          <target state="translated">iterable에서 항목을 추가, 이동 또는 제거 할 때 지시문은 적절한 DOM 노드를 다시 렌더링해야합니다. DOM에서 이탈을 최소화하기 위해 변경된 노드 만 다시 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="3383a24d31d85f720ecee22674153dda0032675f" translate="yes" xml:space="preserve">
          <source>When items are reordered, their respective templates are reordered in the DOM.</source>
          <target state="translated">항목이 재정렬되면 해당 템플리트가 DOM에서 재정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="4e46635cb6851d2c8daac2e8a56141906f6c0a57" translate="yes" xml:space="preserve">
          <source>When migrating large applications from AngularJS to Angular using a hybrid approach, you want to migrate some of the most commonly used features first, and only use the less commonly used features if needed. Doing so helps you ensure that the application is still providing a seamless experience for your users while you are migrating.</source>
          <target state="translated">하이브리드 방식을 사용하여 대규모 애플리케이션을 AngularJS에서 Angular로 마이그레이션 할 때 가장 일반적으로 사용되는 기능 중 일부를 먼저 마이그레이션하고 필요한 경우 덜 일반적으로 사용되는 기능 만 사용하려고합니다. 이렇게하면 마이그레이션하는 동안 응용 프로그램이 사용자에게 완벽한 환경을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f693ef9f80d346bdc6a2cb671a6ac073cf6c8c15" translate="yes" xml:space="preserve">
          <source>When moving applications into production, module loaders also make it easier to package them all up into production bundles with batteries included.</source>
          <target state="translated">응용 프로그램을 생산 환경으로 옮길 때 모듈 로더를 사용하면 배터리가 포함 된 생산 번들로 모두 포장하기가 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="974ce48422781e5e8f141c93cec08580c47ded29" translate="yes" xml:space="preserve">
          <source>When navigating to '/team/11/legacy/user/jim', the router changes the URL segment '/team/11/legacy/user/jim' to '/team/11/user/jim', and then instantiates the Team component with the User child component in it.</source>
          <target state="translated">'/ team / 11 / legacy / user / jim'으로 이동하면 라우터는 URL 세그먼트 '/ team / 11 / legacy / user / jim'을 '/ team / 11 / user / jim'으로 변경 한 다음 사용자 하위 구성 요소가 포함 된 팀 구성 요소.</target>
        </trans-unit>
        <trans-unit id="4dabd38c86ae8f6fd64bd5a719e2864ff58a5263" translate="yes" xml:space="preserve">
          <source>When navigating to the &lt;code&gt;HeroDetailComponent&lt;/code&gt; you specified the &lt;em&gt;required&lt;/em&gt;&lt;code&gt;id&lt;/code&gt; of the hero-to-edit in the &lt;em&gt;route parameter&lt;/em&gt; and made it the second item of the &lt;a href=&quot;router#link-parameters-array&quot;&gt;&lt;em&gt;link parameters array&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;HeroDetailComponent&lt;/code&gt; 를 탐색 할 때 &lt;em&gt;route 매개 변수에&lt;/em&gt; 편집 할 hero-edit 의 &lt;em&gt;필수 &lt;/em&gt; &lt;code&gt;id&lt;/code&gt; 를 지정 하고 &lt;a href=&quot;router#link-parameters-array&quot;&gt;&lt;em&gt;링크 매개 변수 배열&lt;/em&gt;&lt;/a&gt; 의 두 번째 항목으로 지정하십시오 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d4f490523f0905f447f19a9e5f19c51771307795" translate="yes" xml:space="preserve">
          <source>When navigating to the &lt;code&gt;HeroDetailComponent&lt;/code&gt; you specified the required &lt;code&gt;id&lt;/code&gt; of the hero-to-edit in the route parameter and made it the second item of the &lt;a href=&quot;router-tutorial-toh#link-parameters-array&quot;&gt;&lt;em&gt;link parameters array&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;HeroDetailComponent&lt;/code&gt; 로 이동할 때 route 매개 변수에서 편집 할 hero 의 필수 &lt;code&gt;id&lt;/code&gt; 를 지정 하고 &lt;a href=&quot;router-tutorial-toh#link-parameters-array&quot;&gt;&lt;em&gt;링크 매개 변수 배열&lt;/em&gt;&lt;/a&gt; 의 두 번째 항목으로 만들었습니다 .</target>
        </trans-unit>
        <trans-unit id="b596202b93519fa83ba3e0636fbd745a12579c58" translate="yes" xml:space="preserve">
          <source>When navigating within the page, you can omit the page URL when specifying the link that &lt;a href=&quot;docs-style-guide#anchors&quot;&gt;scrolls up&lt;/a&gt; to the beginning of this section.</source>
          <target state="translated">페이지 내에서 탐색 할 때이 섹션의 시작 부분으로 &lt;a href=&quot;docs-style-guide#anchors&quot;&gt;스크롤&lt;/a&gt; 되는 링크를 지정할 때 페이지 URL을 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47e71f5eac56adacb97cdaa135062c7be281d29c" translate="yes" xml:space="preserve">
          <source>When operating on a blank value, the pipe returns the blank value.</source>
          <target state="translated">공백 값으로 작업 할 때 파이프는 공백 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9470fc75d4f16eb75457c7c0701e316180391ae8" translate="yes" xml:space="preserve">
          <source>When operating on an &lt;code&gt;Array&lt;/code&gt;, the returned &lt;code&gt;Array&lt;/code&gt; is always a copy even when all the elements are being returned.</source>
          <target state="translated">&lt;code&gt;Array&lt;/code&gt; 에서 작업 할 때 반환 된 &lt;code&gt;Array&lt;/code&gt; 는 모든 요소가 반환되는 경우에도 항상 사본입니다.</target>
        </trans-unit>
        <trans-unit id="af8a1731fb61ac75119cbee0bc7096781d75858e" translate="yes" xml:space="preserve">
          <source>When possible, every snippet of code on a guide page should be derived from a code sample file. You tell the Angular documentation engine which code file - or fragment of a code file - to display by configuring &lt;code&gt;&amp;lt;code-example&amp;gt;&lt;/code&gt; attributes.</source>
          <target state="translated">가능하면 가이드 페이지의 모든 코드 스 니펫은 코드 샘플 파일에서 파생되어야합니다. &lt;code&gt;&amp;lt;code-example&amp;gt;&lt;/code&gt; 속성 을 구성하여 표시 할 코드 파일 또는 코드 파일의 조각 인 Angular 문서 엔진에 지시하십시오 .</target>
        </trans-unit>
        <trans-unit id="81522af4b0c86ada0dcec0dca8396f6ec26055fe" translate="yes" xml:space="preserve">
          <source>When present, this directive/component is ignored by the AOT compiler. It remains in distributed code, and the JIT compiler attempts to compile it at run time, in the browser. To ensure the correct behavior, the app must import &lt;code&gt;@angular/compiler&lt;/code&gt;.</source>
          <target state="translated">존재하는 경우이 지시문 / 구성 요소는 AOT 컴파일러에서 무시됩니다. 분산 코드에 남아 있으며 JIT 컴파일러는 브라우저에서 런타임에 컴파일을 시도합니다. 올바른 동작을 보장하려면 앱이 &lt;code&gt;@angular/compiler&lt;/code&gt; 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="a5b961604f0d23587371ae93a940e91559d21115" translate="yes" xml:space="preserve">
          <source>When present, this module is ignored by the AOT compiler. It remains in distributed code, and the JIT compiler attempts to compile it at run time, in the browser. To ensure the correct behavior, the app must import &lt;code&gt;@angular/compiler&lt;/code&gt;.</source>
          <target state="translated">존재하는 경우이 모듈은 AOT 컴파일러에서 무시됩니다. 분산 코드에 남아 있으며 JIT 컴파일러는 브라우저에서 런타임에 컴파일을 시도합니다. 올바른 동작을 보장하려면 앱이 &lt;code&gt;@angular/compiler&lt;/code&gt; 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="00f63586288bea23dcaec8ea63ddf7ac7e1aa5a7" translate="yes" xml:space="preserve">
          <source>When prompted with &lt;code&gt;Which stylesheet format would you like to use?&lt;/code&gt;, select &lt;code&gt;CSS&lt;/code&gt;.</source>
          <target state="translated">와 메시지가 표시되면 &lt;code&gt;Which stylesheet format would you like to use?&lt;/code&gt; 에서 &lt;code&gt;CSS&lt;/code&gt; 를 선택 합니다.</target>
        </trans-unit>
        <trans-unit id="77d185254b99b0e6f27ad2e5b35d1d77632227bb" translate="yes" xml:space="preserve">
          <source>When prompted with &lt;code&gt;Would you like to add Angular routing?&lt;/code&gt;, select &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Would you like to add Angular routing?&lt;/code&gt; 라는 메시지가 표시되면 , &lt;code&gt;N&lt;/code&gt; 을 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b1e14412852555d0dead8387cd5e4230c5c2210" translate="yes" xml:space="preserve">
          <source>When reasoning about how a hybrid application works it is useful to have a mental model which describes what is happening and explains what is happening at the lowest level.</source>
          <target state="translated">하이브리드 애플리케이션의 작동 방식을 추론 할 때 발생하는 상황을 설명하고 가장 낮은 수준에서 발생하는 일을 설명하는 정신 모델을 갖는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="910d857793129df45ce010da90a7c320c1e97758" translate="yes" xml:space="preserve">
          <source>When registered at the root, the module should be used as follows</source>
          <target state="translated">루트에 등록 할 때 다음과 같이 모듈을 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="2ab8eb9f66e9c33880450da52086157c8e225499" translate="yes" xml:space="preserve">
          <source>When registering the NgModule at the root, import as follows:</source>
          <target state="translated">루트에서 NgModule을 등록 할 때 다음과 같이 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3a43104f732ee923f94742e9dafb4569962350fe" translate="yes" xml:space="preserve">
          <source>When resolving a token for a component/directive, Angular resolves it in two phases:</source>
          <target state="translated">컴포넌트 / 지시문에 대한 토큰을 분석 할 때 Angular는 다음 두 단계로 토큰을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="c2ae9e9637b2b33a1688e28b8fbf98ba2ef54d5d" translate="yes" xml:space="preserve">
          <source>When running a hybrid app, you may encounter situations where you need to inject some AngularJS dependencies into your Angular code. Maybe you have some business logic still in AngularJS services. Maybe you want access to AngularJS's built-in services like &lt;code&gt;$location&lt;/code&gt; or &lt;code&gt;$timeout&lt;/code&gt;.</source>
          <target state="translated">하이브리드 앱을 실행할 때 AngularJS 종속성을 Angular 코드에 주입해야하는 상황이 발생할 수 있습니다. 어쩌면 AngularJS 서비스에 여전히 몇 가지 비즈니스 논리가 있습니다. 아마도 &lt;code&gt;$location&lt;/code&gt; 또는 &lt;code&gt;$timeout&lt;/code&gt; 과 같은 AngularJS의 내장 서비스에 액세스하고 싶을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3bed0140c9176f2a5f051b579d76e69efbabf955" translate="yes" xml:space="preserve">
          <source>When running in a web browser, &lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;&lt;code&gt;BrowserModule&lt;/code&gt;&lt;/a&gt; is imported from the &lt;code&gt;platform-browser&lt;/code&gt; package, and supports services that simplify security and event processing, and allows applications to access browser-specific features, such as interpreting keyboard input and controlling the title of the document being displayed. All applications running in the browser use the same platform service.</source>
          <target state="translated">웹 브라우저에서 실행될 때 &lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt; &lt;code&gt;BrowserModule&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;platform-browser&lt;/code&gt; 패키지에서 가져오고 보안 및 이벤트 처리를 단순화하는 서비스를 지원하며 애플리케이션이 키보드 입력 해석 및 문서 제목 제어와 같은 브라우저 특정 기능에 액세스 할 수 있도록합니다. 표시됩니다. 브라우저에서 실행되는 모든 응용 프로그램은 동일한 플랫폼 서비스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d3b9496755bdbefbc04d83cf169903cd6a85e935" translate="yes" xml:space="preserve">
          <source>When running this test in your repo, you need the &lt;a href=&quot;https://github.com/TypeStrong/ts-node&quot;&gt;&lt;code&gt;ts-node&lt;/code&gt;&lt;/a&gt; package. You can avoid this by renaming &lt;code&gt;index.spec.ts&lt;/code&gt; to &lt;code&gt;index.spec.js&lt;/code&gt;.</source>
          <target state="translated">리포지토리에서이 테스트를 실행할 때는 &lt;a href=&quot;https://github.com/TypeStrong/ts-node&quot;&gt; &lt;code&gt;ts-node&lt;/code&gt; &lt;/a&gt; 패키지 가 필요합니다 . 당신은 이름을 변경하여이 문제를 피할 수 &lt;code&gt;index.spec.ts&lt;/code&gt; 을 에 &lt;code&gt;index.spec.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07e991503049cbbac50ec7899e8632ccd8a050c1" translate="yes" xml:space="preserve">
          <source>When running this test in your repo, you need the &lt;a href=&quot;https://github.com/TypeStrong/ts-node&quot;&gt;&lt;code&gt;ts-node&lt;/code&gt;&lt;/a&gt; package. You can avoid this by renaming &lt;code&gt;my-builder.spec.ts&lt;/code&gt; to &lt;code&gt;my-builder.spec.js&lt;/code&gt;.</source>
          <target state="translated">리포지토리에서이 테스트를 실행할 때 &lt;a href=&quot;https://github.com/TypeStrong/ts-node&quot;&gt; &lt;code&gt;ts-node&lt;/code&gt; &lt;/a&gt; 패키지 가 필요합니다 . 당신은 이름을 변경하여이 문제를 피할 수 있습니다 &lt;code&gt;my-builder.spec.ts&lt;/code&gt; 에 &lt;code&gt;my-builder.spec.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca1e00f7ccb695467c2c1c8bdcb6dc3a59945ddf" translate="yes" xml:space="preserve">
          <source>When set to 'enabled', scrolls to the anchor element when the URL has a fragment. Anchor scrolling is disabled by default.</source>
          <target state="translated">'enabled'로 설정하면 URL에 조각이있을 때 앵커 요소로 스크롤됩니다. 앵커 스크롤은 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="df46a80b7b23d043f67f6a3e6c0f76498ecbceda" translate="yes" xml:space="preserve">
          <source>When steps are defined by &lt;code&gt;&lt;a href=&quot;style&quot;&gt;style&lt;/a&gt;()&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;animate&quot;&gt;animate&lt;/a&gt;()&lt;/code&gt; function calls, each call within the group is executed instantly.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;style&quot;&gt;style&lt;/a&gt;()&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;animate&quot;&gt;animate&lt;/a&gt;()&lt;/code&gt; 함수 호출로 단계를 정의 하면 그룹 내의 각 호출이 즉시 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ec7e8de6c9a711c3fd504943c4759732a87b530d" translate="yes" xml:space="preserve">
          <source>When subscribing to an observable in a component, you almost always arrange to unsubscribe when the component is destroyed.</source>
          <target state="translated">컴포넌트에서 옵저버 블을 구독 할 때는 컴포넌트가 파괴 될 때 거의 항상 구독을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="45e5a628edb20ff84e443e611d2349ab61054cc7" translate="yes" xml:space="preserve">
          <source>When subscribing to an observable in a component, you almost always unsubscribe when the component is destroyed.</source>
          <target state="translated">컴포넌트에서 옵저버 블을 구독 할 때 컴포넌트가 파괴되면 거의 항상 구독을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="c84a9e640ad95d9f4b83e468d1eed71718bb7381" translate="yes" xml:space="preserve">
          <source>When supplied, a custom handler for a completion notification from this emitter.</source>
          <target state="translated">제공된 경우이 이미 터로부터 완료 알림을위한 사용자 정의 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="4df8413e1037a7ffe9bd25f1c95460fff8733865" translate="yes" xml:space="preserve">
          <source>When supplied, a custom handler for an error notification from this emitter.</source>
          <target state="translated">제공된 경우이 이미 터의 오류 알림에 대한 사용자 정의 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="00c39ac45b462ecb37bcc3a021a4360c58c40852" translate="yes" xml:space="preserve">
          <source>When supplied, a custom handler for emitted events.</source>
          <target state="translated">제공된 경우 생성 된 이벤트에 대한 사용자 정의 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="9cd3ac9350a3fd4b3d68c6da3292aed9974b8459" translate="yes" xml:space="preserve">
          <source>When switching between the two routes, the &lt;code&gt;HeroDetailComponent&lt;/code&gt; and &lt;code&gt;HeroListComponent&lt;/code&gt; now ease in from the left when routed to and will slide to the right when navigating away.</source>
          <target state="translated">두 경로 사이를 전환 할 때 이제 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 와 &lt;code&gt;HeroListComponent&lt;/code&gt; 가 라우팅 될 때 왼쪽에서 쉽게 들어 오고 멀리 이동할 때 오른쪽으로 미끄러집니다.</target>
        </trans-unit>
        <trans-unit id="9e9d2f5c611c356028dee0d50c203b929a7a14e8" translate="yes" xml:space="preserve">
          <source>When switching between the two routes, the &lt;code&gt;HeroDetailComponent&lt;/code&gt; and &lt;code&gt;HeroListComponent&lt;/code&gt; will ease in from the left when routed to and will slide to the right when navigating away.</source>
          <target state="translated">두 경로 사이를 전환 할 때 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 와 &lt;code&gt;HeroListComponent&lt;/code&gt; 는 경로가 지정 될 때 왼쪽에서 쉽게 들어가고 탐색 할 때 오른쪽으로 미끄러집니다.</target>
        </trans-unit>
        <trans-unit id="6d869f89c0032b7d502684b0c42e737ad757a361" translate="yes" xml:space="preserve">
          <source>When testing a component, only the service's public API should matter. In general, tests themselves should not make calls to remote servers. They should emulate such calls. The setup in this &lt;code&gt;app/twain/twain.component.spec.ts&lt;/code&gt; shows one way to do that:</source>
          <target state="translated">구성 요소를 테스트 할 때는 서비스의 공용 API 만 중요합니다. 일반적으로 테스트 자체는 원격 서버를 호출해서는 안됩니다. 그들은 그러한 부름을 모방해야합니다. 이 &lt;code&gt;app/twain/twain.component.spec.ts&lt;/code&gt; 의 설정은이 를 수행하는 한 가지 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ef0f0acd351b519e1bdbe282aaf9c197ad051fd4" translate="yes" xml:space="preserve">
          <source>When testing a service with a dependency, provide the mock in the &lt;code&gt;providers&lt;/code&gt; array.</source>
          <target state="translated">종속성이있는 서비스를 테스트 할 때 &lt;code&gt;providers&lt;/code&gt; 배열에 모의를 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="0860f03444a0fc7aa7e1b3fb17143a54bae674bc" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive#isActive&quot;&gt;isActive&lt;/a&gt;&lt;/code&gt; expression returns a truthy value, &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; adds the &lt;code&gt;ItemDetailComponent&lt;/code&gt; to the DOM. When the expression is falsy, &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; removes the &lt;code&gt;ItemDetailComponent&lt;/code&gt; from the DOM, destroying that component and all of its sub-components.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive#isActive&quot;&gt;isActive&lt;/a&gt;&lt;/code&gt; 표현식이 truthy 값을 반환, &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 는 추가 &lt;code&gt;ItemDetailComponent&lt;/code&gt; 는 DOM에 있습니다. 식이 falsy되면 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 는 제거 &lt;code&gt;ItemDetailComponent&lt;/code&gt; 을 해당 구성 요소 및 하위 구성 요소를 모두 파괴 상기 DOM에서.</target>
        </trans-unit>
        <trans-unit id="7210ba167993f8f770531f5c2b064669c209d5dc" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;@.disabled&lt;/code&gt; binding is true, the &lt;code&gt;@childAnimation&lt;/code&gt; trigger doesn't kick off.</source>
          <target state="translated">때 &lt;code&gt;@.disabled&lt;/code&gt; 입니다 사실 바인딩의 &lt;code&gt;@childAnimation&lt;/code&gt; 의 트리거는 킥오프하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8caa4e29d9b4d974dd5d9041992426ba9ac8a426" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;base&lt;/code&gt; tag is mis-configured, the app fails to load and the browser console displays &lt;code&gt;404 - Not Found&lt;/code&gt; errors for the missing files. Look at where it &lt;em&gt;tried&lt;/em&gt; to find those files and adjust the base tag appropriately.</source>
          <target state="translated">하면 &lt;code&gt;base&lt;/code&gt; 태그가 잘못 구성되어 있습니다, 응용 프로그램은로드되지 브라우저 콘솔 디스플레이 &lt;code&gt;404 - Not Found&lt;/code&gt; 누락 된 파일에 대한 오류. 그것은 어디 봐 &lt;em&gt;노력&lt;/em&gt; 해당 파일을 찾아 적절하게 기본 태그를 조정합니다.</target>
        </trans-unit>
        <trans-unit id="e75c241922935cbd3ea5df02a84d5245d7cf9eba" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;condition&lt;/code&gt; is falsy, the top (A) paragraph appears and the bottom (B) paragraph disappears. When the &lt;code&gt;condition&lt;/code&gt; is truthy, the top (A) paragraph is removed and the bottom (B) paragraph appears.</source>
          <target state="translated">때 &lt;code&gt;condition&lt;/code&gt; falsy이며, 상단 (A) 단락 나타나고 저부 (B) 단락 사라진다. 때 &lt;code&gt;condition&lt;/code&gt; truthy이며, 상단 (A) 항을 제거하고, 저부 (B) 단락 나타나있다.</target>
        </trans-unit>
        <trans-unit id="2c58fb3492f3f8aca3da2461c1f89c6f93c0a079" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;deleteRequest&lt;/code&gt; event fires, Angular calls the parent component's &lt;code&gt;deleteItem()&lt;/code&gt; method with the item.</source>
          <target state="translated">때 &lt;code&gt;deleteRequest&lt;/code&gt; 이벤트 화재, 각도는 부모 구성 요소의 호출 &lt;code&gt;deleteItem()&lt;/code&gt; 항목과 방법을.</target>
        </trans-unit>
        <trans-unit id="3dc1efd9593828d0e01af36e18c84dde19f4956e" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;deleteRequest&lt;/code&gt; event fires, Angular calls the parent component's &lt;code&gt;deleteItem()&lt;/code&gt; method, passing the &lt;em&gt;item-to-delete&lt;/em&gt; (emitted by &lt;code&gt;ItemDetail&lt;/code&gt;) in the &lt;code&gt;$event&lt;/code&gt; variable.</source>
          <target state="translated">때 &lt;code&gt;deleteRequest&lt;/code&gt; 이벤트 화재, 각도는 부모 구성 요소의 호출 &lt;code&gt;deleteItem()&lt;/code&gt; 통과, 방법을 &lt;em&gt;항목 - 투 - 삭제&lt;/em&gt; (방출 &lt;code&gt;ItemDetail&lt;/code&gt; 을 에서) &lt;code&gt;$event&lt;/code&gt; 변수입니다.</target>
        </trans-unit>
        <trans-unit id="c9a2b3437891fb18901b8b21686790b30e088379" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;id&lt;/code&gt; cannot be found, the component should re-route to the &lt;code&gt;HeroListComponent&lt;/code&gt;.</source>
          <target state="translated">하면 &lt;code&gt;id&lt;/code&gt; 찾을 수없는 구성 요소는 간 경로를 다시해야 &lt;code&gt;HeroListComponent&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="2920e2be687da84b4c5aca2ceda07ce8afeb62cf" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;isActive&lt;/code&gt; expression returns a truthy value, &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; adds the &lt;code&gt;ItemDetailComponent&lt;/code&gt; to the DOM. When the expression is falsy, &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; removes the &lt;code&gt;ItemDetailComponent&lt;/code&gt; from the DOM, destroying that component and all of its sub-components.</source>
          <target state="translated">때 &lt;code&gt;isActive&lt;/code&gt; 표현식이 truthy 값을 반환, &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 는 추가 &lt;code&gt;ItemDetailComponent&lt;/code&gt; 는 DOM에 있습니다. 식이 falsy되면 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 는 제거 &lt;code&gt;ItemDetailComponent&lt;/code&gt; 을 해당 구성 요소 및 하위 구성 요소를 모두 파괴 상기 DOM에서.</target>
        </trans-unit>
        <trans-unit id="d2e3d77dbe8594275e223d51b36cd1f3be8ab17c" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;noImplicitAny&lt;/code&gt; flag is &lt;code&gt;false&lt;/code&gt; (the default), and if the compiler cannot infer the variable type based on how it's used, the compiler silently defaults the type to &lt;code&gt;any&lt;/code&gt;. That's what is meant by &lt;em&gt;implicit &lt;code&gt;any&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">때 &lt;code&gt;noImplicitAny&lt;/code&gt; 플래그가 &lt;code&gt;false&lt;/code&gt; (기본), 컴파일러는 변수 유형 추론이 사용되는 방법에 따라 할 수없는 경우, 컴파일러 자동으로 기본값으로 유형 &lt;code&gt;any&lt;/code&gt; . 이것이 &lt;em&gt;암시 적 &lt;code&gt;any&lt;/code&gt; 의&lt;/em&gt; 의미 입니다.</target>
        </trans-unit>
        <trans-unit id="1d4a388447e5472702495919fcaedf96a0b5cef4" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;noImplicitAny&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt; and the TypeScript compiler cannot infer the type, it still generates the JavaScript files, but it also &lt;strong&gt;reports an error&lt;/strong&gt;. Many seasoned developers prefer this stricter setting because type checking catches more unintentional errors at compile time.</source>
          <target state="translated">때 &lt;code&gt;noImplicitAny&lt;/code&gt; 플래그가 &lt;code&gt;true&lt;/code&gt; 과 타이프 스크립트 컴파일러가 타입을 추론 할 수없는, 여전히 자바 스크립트 파일을 생성뿐만 아니라 &lt;strong&gt;오류를보고합니다&lt;/strong&gt; . 많은 노련한 개발자는 유형 검사시 컴파일시 의도하지 않은 오류가 더 많이 발생하므로이 엄격한 설정을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="acd1794f17ea94afe9bc086e9963108f4a25ba69" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;noImplicitAny&lt;/code&gt; flag is &lt;code&gt;true&lt;/code&gt;, you may get &lt;em&gt;implicit index errors&lt;/em&gt; as well. Most developers feel that &lt;em&gt;this particular error&lt;/em&gt; is more annoying than helpful. You can suppress them with the following additional flag:</source>
          <target state="translated">때 &lt;code&gt;noImplicitAny&lt;/code&gt; 의 플래그가 &lt;code&gt;true&lt;/code&gt; , 당신은 얻을 수 있습니다 &lt;em&gt;암시 인덱스 오류가&lt;/em&gt; 아니라. 대부분의 개발자는 &lt;em&gt;이 특정 오류&lt;/em&gt; 가 도움이되는 것보다 더 성가신 것이라고 생각합니다 . 다음 추가 플래그를 사용하여이를 억제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b4dd32657c06b2d7d1495c105ae99f00c1a5a39" translate="yes" xml:space="preserve">
          <source>When the Angular CLI generates a new component, it includes an empty constructor, the &lt;code&gt;&lt;a href=&quot;api/core/oninit&quot;&gt;OnInit&lt;/a&gt;&lt;/code&gt; interface, and the &lt;code&gt;ngOnInit()&lt;/code&gt; method. Since the following example isn't using them, they are omitted here for brevity.</source>
          <target state="translated">Angular CLI가 새 구성 요소를 생성하면 빈 생성자, &lt;code&gt;&lt;a href=&quot;api/core/oninit&quot;&gt;OnInit&lt;/a&gt;&lt;/code&gt; 인터페이스 및 &lt;code&gt;ngOnInit()&lt;/code&gt; 메서드가 포함됩니다. 다음 예제에서는이를 사용하지 않으므로 간결성을 위해 여기에서 생략합니다.</target>
        </trans-unit>
        <trans-unit id="1221ec7078025cb9fbeced33a7c810ee121599ea" translate="yes" xml:space="preserve">
          <source>When the Angular Router matches a route that uses AngularJS, the &lt;code&gt;AngularJSComponent&lt;/code&gt; is rendered, and the content is rendered within the AngularJS &lt;a href=&quot;https://docs.angularjs.org/api/ngRoute/directive/ngView&quot;&gt;&lt;code&gt;ng-view&lt;/code&gt;&lt;/a&gt; directive. When the user navigates away from the route, the &lt;code&gt;$rootScope&lt;/code&gt; is destroyed on the AngularJS application.</source>
          <target state="translated">Angular 라우터가 AngularJS를 사용하는 경로와 일치하면 &lt;code&gt;AngularJSComponent&lt;/code&gt; 가 렌더링되고 컨텐츠는 AngularJS &lt;a href=&quot;https://docs.angularjs.org/api/ngRoute/directive/ngView&quot;&gt; &lt;code&gt;ng-view&lt;/code&gt; &lt;/a&gt; 지시문 내에서 렌더링됩니다 . 사용자가 경로를 벗어나 면 AngularJS 응용 프로그램에서 &lt;code&gt;$rootScope&lt;/code&gt; 가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="080f2859f1d13e16f7fe1af393eea801d31826ab" translate="yes" xml:space="preserve">
          <source>When the Angular compiler turns this template into TypeScript code, it prevents TypeScript from reporting that &lt;code&gt;bestByDate&lt;/code&gt; is not a member of the &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; object when it runs type checking on the template.</source>
          <target state="translated">Angular 컴파일러는이 템플릿을 TypeScript 코드로 변환하면 템플릿에서 유형 검사를 실행할 때 &lt;code&gt;bestByDate&lt;/code&gt; 가 &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; 객체 의 멤버가 아니라고 TypeScript에서보고 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e2ec197551b2b4f0c2054507141a1116bbd98183" translate="yes" xml:space="preserve">
          <source>When the Angular compiler turns this template into TypeScript code, it prevents TypeScript from reporting that &lt;code&gt;bestByDate&lt;/code&gt; is not a member of the &lt;code&gt;item&lt;/code&gt; object when it runs type checking on the template.</source>
          <target state="translated">Angular 컴파일러가이 템플릿을 TypeScript 코드로 변환하면 TypeScript 가 템플릿에서 유형 검사를 실행할 때 &lt;code&gt;bestByDate&lt;/code&gt; 가 &lt;code&gt;item&lt;/code&gt; 개체 의 구성원이 아니라고 보고하는 것을 방지 합니다.</target>
        </trans-unit>
        <trans-unit id="e0289ecc8b0efe9a3b03fd5c608e586c950afcad" translate="yes" xml:space="preserve">
          <source>When the Angular compiler turns your template into TypeScript code, it prevents TypeScript from reporting that &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; might be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Angular 컴파일러는 템플릿을 TypeScript 코드로 변환 할 때 TypeScript가 해당 &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 이거나 &lt;code&gt;undefined&lt;/code&gt; 음을보고하지 못하게 합니다.</target>
        </trans-unit>
        <trans-unit id="3a21ca739168a6ca957e545449932277c2c48d4e" translate="yes" xml:space="preserve">
          <source>When the Angular compiler turns your template into TypeScript code, it prevents TypeScript from reporting that &lt;code&gt;item.color&lt;/code&gt; might be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Angular 컴파일러가 템플릿을 TypeScript 코드로 변환하면 TypeScript에서 &lt;code&gt;item.color&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 일 수 있음 을보고하지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="7b523d4946336137aa2dbed657d1c4be4adcefae" translate="yes" xml:space="preserve">
          <source>When the Angular router lazy-loads a module, it creates a new execution context. That &lt;a href=&quot;ngmodule-faq#q-why-child-injector&quot;&gt;context has its own injector&lt;/a&gt;, which is a direct child of the application injector.</source>
          <target state="translated">Angular 라우터가 모듈을 지연로드하면 새로운 실행 컨텍스트가 생성됩니다. 해당 &lt;a href=&quot;ngmodule-faq#q-why-child-injector&quot;&gt;컨텍스트에는 자체 인젝터가&lt;/a&gt; 있으며 이는 애플리케이션 인젝터의 직접적인 하위입니다.</target>
        </trans-unit>
        <trans-unit id="2cf28989035e8b08a947a71d640454a09e99a9b3" translate="yes" xml:space="preserve">
          <source>When the Angular router lazy-loads a module, it creates a new injector. This injector is a child of the root application injector. Imagine a tree of injectors; there is a single root injector and then a child injector for each lazy loaded module. The router adds all of the providers from the root injector to the child injector. When the router creates a component within the lazy-loaded context, Angular prefers service instances created from these providers to the service instances of the application root injector.</source>
          <target state="translated">Angular 라우터가 모듈을 지연 로딩하면 새로운 인젝터가 생성됩니다. 이 인젝터는 루트 애플리케이션 인젝터의 하위입니다. 인젝터 나무를 상상해보십시오. 하나의 루트 인젝터와 각 게으른로드 된 모듈에 대한 하위 인젝터가 있습니다. 라우터는 루트 인젝터의 모든 제공자를 하위 인젝터에 추가합니다. 라우터가 느리게로드 된 컨텍스트 내에서 컴포넌트를 작성할 때 Angular는 이러한 제공자에서 작성된 서비스 인스턴스를 애플리케이션 루트 인젝터의 서비스 인스턴스보다 선호합니다.</target>
        </trans-unit>
        <trans-unit id="a59c1220766a1692e2ac330d5b21be92fc1db6a9" translate="yes" xml:space="preserve">
          <source>When the CLI commands &lt;code&gt;ng test&lt;/code&gt; and &lt;code&gt;ng e2e&lt;/code&gt; are generally running the CI tests in your environment, you might still need to adjust your configuration to run the Chrome browser tests.</source>
          <target state="translated">CLI 명령 &lt;code&gt;ng test&lt;/code&gt; 및 &lt;code&gt;ng e2e&lt;/code&gt; 가 일반적으로 환경에서 CI 테스트를 실행하는 경우 Chrome 브라우저 테스트를 실행하도록 구성을 조정해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d88b7c40f460e73c24fa3f0de74d16ad21ad9d2c" translate="yes" xml:space="preserve">
          <source>When the CLI generated the &lt;code&gt;CustomerDashboardComponent&lt;/code&gt; for the feature module, it included a template, &lt;code&gt;customer-dashboard.component.html&lt;/code&gt;, with the following markup:</source>
          <target state="translated">CLI 가 기능 모듈에 대한 &lt;code&gt;CustomerDashboardComponent&lt;/code&gt; 를 생성 할 때 &lt;code&gt;customer-dashboard.component.html&lt;/code&gt; 템플리트를 다음 마크 업과 함께 포함했습니다 .</target>
        </trans-unit>
        <trans-unit id="59925ab392dd758a0d023368a837b4147d92ef54" translate="yes" xml:space="preserve">
          <source>When the CLI generated the &lt;code&gt;HeroesComponent&lt;/code&gt;, it created an empty &lt;code&gt;heroes.component.css&lt;/code&gt; stylesheet for the &lt;code&gt;HeroesComponent&lt;/code&gt; and pointed to it in &lt;code&gt;@&lt;a href=&quot;../api/core/component#styleUrls&quot;&gt;Component.styleUrls&lt;/a&gt;&lt;/code&gt; like this.</source>
          <target state="translated">CLI를 생성 할 때 &lt;code&gt;HeroesComponent&lt;/code&gt; 를 , 그것은 빈 생성 &lt;code&gt;heroes.component.css&lt;/code&gt; 의 에 대한 스타일 시트 &lt;code&gt;HeroesComponent&lt;/code&gt; 을 하고 그것을 지적 &lt;code&gt;@&lt;a href=&quot;../api/core/component#styleUrls&quot;&gt;Component.styleUrls&lt;/a&gt;&lt;/code&gt; 같이.</target>
        </trans-unit>
        <trans-unit id="aa5fd6c00e755291fcd1e8dfd434052f8247fbca" translate="yes" xml:space="preserve">
          <source>When the ES5 Browserslist result is &lt;code&gt;disabled&lt;/code&gt;, then ES5 browser support is not required. Otherwise, ES5 browser support is required.</source>
          <target state="translated">ES5 Browserslist 결과가 &lt;code&gt;disabled&lt;/code&gt; 되면 ES5 브라우저 지원이 필요하지 않습니다. 그렇지 않으면 ES5 브라우저 지원이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="eb6eeefc118f7aefbc0dab17c4da18ab107fad46" translate="yes" xml:space="preserve">
          <source>When the ServiceWorker handles a request, it checks asset groups in the order in which they appear in &lt;code&gt;ngsw-config.json&lt;/code&gt;. The first asset group that matches the requested resource handles the request.</source>
          <target state="translated">ServiceWorker는 요청을 처리 할 때 &lt;code&gt;ngsw-config.json&lt;/code&gt; 에 나타나는 순서대로 자산 그룹을 확인합니다 . 요청 된 리소스와 일치하는 첫 번째 자산 그룹이 요청을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="e51a5be86a741ecadf68b5ad073e6275afa8ec50" translate="yes" xml:space="preserve">
          <source>When the ServiceWorker handles a request, it checks data groups in the order in which they appear in &lt;code&gt;ngsw-config.json&lt;/code&gt;. The first data group that matches the requested resource handles the request.</source>
          <target state="translated">ServiceWorker는 요청을 처리 할 때 &lt;code&gt;ngsw-config.json&lt;/code&gt; 에 나타나는 순서대로 데이터 그룹을 확인합니다 . 요청 된 리소스와 일치하는 첫 번째 데이터 그룹이 요청을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="d409951125980096e2daa76599fa79723877f3d7" translate="yes" xml:space="preserve">
          <source>When the app starts, the &lt;code&gt;selectedHero&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt;&lt;em&gt;by design&lt;/em&gt;.</source>
          <target state="translated">앱이 시작되면 &lt;code&gt;selectedHero&lt;/code&gt; 는 &lt;em&gt;디자인에 의해 &lt;/em&gt; &lt;code&gt;undefined&lt;/code&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="85cce31634dd108961a3fd7d6540d6c70f895fff" translate="yes" xml:space="preserve">
          <source>When the app starts, the browser's address bar points to the web site's root. That doesn't match any existing route so the router doesn't navigate anywhere. The space below the &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; is blank.</source>
          <target state="translated">앱이 시작되면 브라우저의 주소 표시 줄이 웹 사이트의 루트를 가리 킵니다. 기존 경로와 일치하지 않으므로 라우터가 아무 곳이나 탐색하지 않습니다. &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; 아래의 공백이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d48436f6f4591ea9777a854da3f01fc9b76faf2c" translate="yes" xml:space="preserve">
          <source>When the application launches, the initial URL in the browser bar is by default:</source>
          <target state="translated">애플리케이션이 시작될 때 브라우저 표시 줄의 초기 URL은 기본적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2bea55775588ba5cf5d20de8360b1abd2270286d" translate="yes" xml:space="preserve">
          <source>When the application launches, the initial URL in the browser bar is something like:</source>
          <target state="translated">응용 프로그램이 시작되면 브라우저 표시 줄의 초기 URL은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="229415848028c721168bbcfe230abe07e6e4c7d2" translate="yes" xml:space="preserve">
          <source>When the application requests navigation to the path &lt;code&gt;/crisis-center&lt;/code&gt;, the router activates an instance of &lt;code&gt;CrisisListComponent&lt;/code&gt;, displays its view, and updates the browser's address location and history with the URL for that path.</source>
          <target state="translated">애플리케이션이 &lt;code&gt;/crisis-center&lt;/code&gt; 경로 탐색을 요청 하면 라우터는 &lt;code&gt;CrisisListComponent&lt;/code&gt; 인스턴스를 활성화하고 해당 뷰를 표시하며 브라우저의 주소 위치 및 히스토리를 해당 경로의 URL로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="c361606b02a6340c1440983835104942a028a4c0" translate="yes" xml:space="preserve">
          <source>When the bootstrap method is switched from that of &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; to pure Angular, AngularJS ceases to exist on the page completely. At this point, you need to tell Protractor that it should not be looking for an AngularJS app anymore, but instead it should find &lt;em&gt;Angular apps&lt;/em&gt; from the page.</source>
          <target state="translated">부트 스트랩 방법을 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 의 방법 에서 순수한 Angular 로 전환 하면 AngularJS가 페이지에서 완전히 존재하지 않습니다. 이 시점에서 Protractor에 AngularJS 앱을 더 이상 찾지 말고 대신 페이지에서 &lt;em&gt;Angular 앱&lt;/em&gt; 을 찾아야한다고 알려야 합니다.</target>
        </trans-unit>
        <trans-unit id="390621ac2e07fd3b6f4546222f0b4c3bdc079e78" translate="yes" xml:space="preserve">
          <source>When the browser refreshes, the app should work again. You can edit the hero's name and see the changes reflected immediately in the &lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt; above the textbox.</source>
          <target state="translated">브라우저가 새로 고침되면 앱이 다시 작동해야합니다. 영웅의 이름을 편집 하고 텍스트 상자 위의 &lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt; 에 즉시 반영된 변경 사항을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f7fdc0a3d021ba9aefb9ebd7e31adbe1a20f6b3" translate="yes" xml:space="preserve">
          <source>When the browser renders &lt;code&gt;&amp;lt;input type=&quot;text&quot; value=&quot;Sarah&quot;&amp;gt;&lt;/code&gt;, it creates a corresponding DOM node with a &lt;code&gt;value&lt;/code&gt; property initialized to &quot;Sarah&quot;.</source>
          <target state="translated">브라우저는 &lt;code&gt;&amp;lt;input type=&quot;text&quot; value=&quot;Sarah&quot;&amp;gt;&lt;/code&gt; 렌더링 할 때 &lt;code&gt;value&lt;/code&gt; 특성이 &quot;Sarah&quot;로 초기화 된 해당 DOM 노드를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="df2233bf5455bd5715e7600e6f1195db0c477e2f" translate="yes" xml:space="preserve">
          <source>When the browser's location URL changes to match the path segment &lt;code&gt;/crisis-center&lt;/code&gt;, then the router activates an instance of the &lt;code&gt;CrisisListComponent&lt;/code&gt; and displays its view.</source>
          <target state="translated">브라우저의 위치 URL이 경로 세그먼트 &lt;code&gt;/crisis-center&lt;/code&gt; 와 일치하도록 변경 되면 라우터는 &lt;code&gt;CrisisListComponent&lt;/code&gt; 의 인스턴스를 활성화하고 해당보기를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="6169562d3c2a62b330d6c334a1f65f9b57448074" translate="yes" xml:space="preserve">
          <source>When the build is complete, make a copy of &lt;code&gt;docs/index.html&lt;/code&gt; and name it &lt;code&gt;docs/404.html&lt;/code&gt;.</source>
          <target state="translated">빌드가 완료되면 &lt;code&gt;docs/index.html&lt;/code&gt; 의 사본을 작성 하고 이름을 &lt;code&gt;docs/404.html&lt;/code&gt; 로 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="f89de102a1abb74769837f142272c4ff2f6b0f07" translate="yes" xml:space="preserve">
          <source>When the component instance is destroyed, so is that service instance.</source>
          <target state="translated">구성 요소 인스턴스가 파괴되면 해당 서비스 인스턴스도 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="e835758236f115ab87e2ed9d80388fafb705e96e" translate="yes" xml:space="preserve">
          <source>When the component or directive raises the event, the handler executes the template statement. The template statement performs an action in response to the event.</source>
          <target state="translated">구성 요소 또는 지시문이 이벤트를 발생 시키면 핸들러는 템플릿 문을 실행합니다. 템플릿 문은 이벤트에 대한 응답으로 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2311871b7205a5129ce3ee5c983030b3867b7bc9" translate="yes" xml:space="preserve">
          <source>When the condition is false, &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; removes its host element from the DOM, detaches it from DOM events (the attachments that it made), detaches the component from Angular change detection, and destroys it. The component and DOM nodes can be garbage-collected and free up memory.</source>
          <target state="translated">조건이 false 인 경우 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 는 호스트 요소를 DOM에서 제거하고 DOM 이벤트 (만들어진 첨부 파일)에서 분리하고 구성 요소를 각도 변경 감지에서 분리하여 제거합니다. 컴포넌트 및 DOM 노드는 가비지 수집되어 메모리를 확보 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4524392797b14c325b60bac95b96ec334a2b3e1a" translate="yes" xml:space="preserve">
          <source>When the contents of the iterator changes, &lt;code&gt;&lt;a href=&quot;ngforof&quot;&gt;NgForOf&lt;/a&gt;&lt;/code&gt; makes the corresponding changes to the DOM:</source>
          <target state="translated">반복자의 내용이 변경되면 &lt;code&gt;&lt;a href=&quot;ngforof&quot;&gt;NgForOf&lt;/a&gt;&lt;/code&gt; 는 DOM을 해당 변경합니다.</target>
        </trans-unit>
        <trans-unit id="0e5038380ebb787d300a2c9eb39551f139a04fd3" translate="yes" xml:space="preserve">
          <source>When the current row hero is the same as the &lt;code&gt;selectedHero&lt;/code&gt;, Angular adds the &lt;code&gt;selected&lt;/code&gt; CSS class. When the two heroes are different, Angular removes the class.</source>
          <target state="translated">현재 행 히어로가 &lt;code&gt;selectedHero&lt;/code&gt; 와 동일 하면 Angular는 &lt;code&gt;selected&lt;/code&gt; CSS 클래스를 추가합니다 . 두 영웅이 다르면 Angular는 클래스를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="88f7dc097723856c6451253157ead9cee3d512b4" translate="yes" xml:space="preserve">
          <source>When the default change detector detects changes, it invokes &lt;code&gt;ngOnChanges()&lt;/code&gt; if supplied, regardless of whether you perform additional change detection. Typically, you should not use both &lt;code&gt;&lt;a href=&quot;docheck&quot;&gt;DoCheck&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;onchanges&quot;&gt;OnChanges&lt;/a&gt;&lt;/code&gt; to respond to changes on the same input.</source>
          <target state="translated">기본 변경 감지기는 변경을 감지하면 추가 변경 감지를 수행하는지 여부에 관계없이 제공된 경우 &lt;code&gt;ngOnChanges()&lt;/code&gt; 호출합니다 . 일반적으로 동일한 입력의 변경에 응답하기 위해 &lt;code&gt;&lt;a href=&quot;docheck&quot;&gt;DoCheck&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;onchanges&quot;&gt;OnChanges&lt;/a&gt;&lt;/code&gt; 를 모두 사용하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="87eced2ba76fd26a75fedaeb26d1a231925e3980" translate="yes" xml:space="preserve">
          <source>When the event is raised, the handler executes the template statement. The template statement typically involves a receiver, which performs an action in response to the event, such as storing a value from the HTML control into a model.</source>
          <target state="translated">이벤트가 발생하면 핸들러는 템플리트 명령문을 실행합니다. 템플릿 문은 일반적으로 수신자에 관련되며, HTML 컨트롤의 값을 모델에 저장하는 것과 같이 이벤트에 응답하여 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e6dde887a621ed7d8cda22827f17a6b04470ac49" translate="yes" xml:space="preserve">
          <source>When the expression is a ISO string without time (e.g. 2016-09-19) the time zone offset is not applied and the formatted text will have the same day, month and year of the expression.</source>
          <target state="translated">식이 시간이없는 ISO 문자열 (예 : 2016-09-19) 인 경우 표준 시간대 오프셋이 적용되지 않으며 형식이 지정된 텍스트는 식의 일, 월 및 연도가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="12f73a5faaa5d63601053af7fd32cddd3d869aa6" translate="yes" xml:space="preserve">
          <source>When the expression resolves to &lt;code&gt;null&lt;/code&gt;, Angular removes the attribute altogether.</source>
          <target state="translated">표현식이 &lt;code&gt;null&lt;/code&gt; 로 확인 되면 Angular는 속성을 모두 제거합니다.</target>
        </trans-unit>
        <trans-unit id="37ece522a490a41d305f59b9d00b58e362fecb66" translate="yes" xml:space="preserve">
          <source>When the given name is non-blank, the handler creates a &lt;code&gt;Hero&lt;/code&gt;-like object from the name (it's only missing the &lt;code&gt;id&lt;/code&gt;) and passes it to the services &lt;code&gt;addHero()&lt;/code&gt; method.</source>
          <target state="translated">주어진 이름이 비어 있지 않으면 핸들러 는 이름에서 &lt;code&gt;Hero&lt;/code&gt; 와 유사한 객체를 만들고 ( &lt;code&gt;id&lt;/code&gt; 만 누락 됨 ) 서비스 &lt;code&gt;addHero()&lt;/code&gt; 메서드에 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="15483efa7611420de43a81a7b88feacee6eacb09" translate="yes" xml:space="preserve">
          <source>When the key is a property of the host element, the property value is the propagated to the specified DOM property.</source>
          <target state="translated">키가 호스트 요소의 속성 인 경우 속성 값은 지정된 DOM 속성으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="8b2b2a15239650c80bd61cf3a7c4a6838674078b" translate="yes" xml:space="preserve">
          <source>When the key is a static attribute in the DOM, the attribute value is propagated to the specified property in the host element.</source>
          <target state="translated">키가 DOM에서 정적 속성 인 경우 속성 값은 호스트 요소의 지정된 특성으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="b14c86a118a766de120313191bb99bc5d8d541fc" translate="yes" xml:space="preserve">
          <source>When the map changes, &lt;code&gt;paramMap&lt;/code&gt; gets the &lt;code&gt;id&lt;/code&gt; parameter from the changed parameters.</source>
          <target state="translated">맵이 변경되면 &lt;code&gt;paramMap&lt;/code&gt; 은 변경된 매개 변수에서 &lt;code&gt;id&lt;/code&gt; 매개 변수를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="d3a68099d4829af5c295f8308c3e9d58baf906ee" translate="yes" xml:space="preserve">
          <source>When the old component logs a message with &lt;code&gt;OldLogger&lt;/code&gt;, you want the singleton instance of &lt;code&gt;NewLogger&lt;/code&gt; to handle it instead. In this case, the dependency injector should inject that singleton instance when a component asks for either the new or the old logger. &lt;code&gt;OldLogger&lt;/code&gt; should be an &lt;em&gt;alias&lt;/em&gt; for &lt;code&gt;NewLogger&lt;/code&gt;.</source>
          <target state="translated">이전 컴포넌트가 &lt;code&gt;OldLogger&lt;/code&gt; 로 메시지를 로그 할 때 NewLogger 의 싱글 톤 인스턴스가 대신 &lt;code&gt;NewLogger&lt;/code&gt; 를 처리하기를 원합니다 . 이 경우 종속성 인젝터는 구성 요소가 새 또는 이전 로거를 요청할 때 해당 단일 인스턴스를 주입해야합니다. &lt;code&gt;OldLogger&lt;/code&gt; 는 해야 &lt;em&gt;별칭&lt;/em&gt; 에 대한 &lt;code&gt;NewLogger&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ff128e54a9e6628bf482f076b33ee1b1b627b6f" translate="yes" xml:space="preserve">
          <source>When the parent component &lt;em&gt;class&lt;/em&gt; requires that kind of access, &lt;strong&gt;&lt;em&gt;inject&lt;/em&gt;&lt;/strong&gt; the child component into the parent as a &lt;em&gt;ViewChild&lt;/em&gt;.</source>
          <target state="translated">부모 구성 요소 &lt;em&gt;클래스&lt;/em&gt; 에 이러한 종류의 액세스가 필요한 경우 자식 구성 요소를 &lt;em&gt;ViewChild&lt;/em&gt; 로 부모에 &lt;strong&gt;&lt;em&gt;주입&lt;/em&gt;&lt;/strong&gt; 하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b9900aa1ed0b5e38fbcd32f4da40c0c5d962adb0" translate="yes" xml:space="preserve">
          <source>When the restore is finished, a message in the bottom message bar of Visual Studio should say: &lt;code&gt;Installing packages complete&lt;/code&gt;. Be patient. This could take a while.</source>
          <target state="translated">복원이 완료되면 Visual Studio의 하단 메시지 표시 줄에 다음과 같은 메시지가 표시 &lt;code&gt;Installing packages complete&lt;/code&gt; . 패키지 설치 완료 . 인내심을 가지십시오. 시간이 좀 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c1050711c1fd12fb5b6f194938f3e8579a393e6" translate="yes" xml:space="preserve">
          <source>When the router lazy loads a module, it creates a child injector and registers the &lt;code&gt;UserService&lt;/code&gt; provider with that child injector. The child injector is &lt;em&gt;not&lt;/em&gt; the root injector.</source>
          <target state="translated">라우터 지연은 모듈을로드 할 때 하위 인젝터를 작성하고 해당 하위 인젝터에 &lt;code&gt;UserService&lt;/code&gt; 제공자를 등록합니다 . 자식 인젝터는 루트 인젝터가 &lt;em&gt;아닙니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b0025e37841d7f66b91ac2c6b9bdbcd09b55618f" translate="yes" xml:space="preserve">
          <source>When the router navigates to a new component view, it updates the browser's location and history with a URL for that view. As this is a strictly local URL the browser won't send this URL to the server and will not reload the page.</source>
          <target state="translated">라우터가 새 구성 요소보기로 이동하면 해당보기에 대한 URL로 브라우저의 위치와 기록을 업데이트합니다. 이것은 엄격한 로컬 URL이기 때문에 브라우저는이 URL을 서버로 보내지 않고 페이지를 다시로드하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bec743e0774188316c4607e7d48359e06eca207a" translate="yes" xml:space="preserve">
          <source>When the router navigates to a new component view, it updates the browser's location and history with a URL for that view. This is a strictly local URL. The browser shouldn't send this URL to the server and should not reload the page.</source>
          <target state="translated">라우터가 새 구성 요소보기로 이동하면 브라우저의 위치 및 히스토리가 해당보기의 URL로 업데이트됩니다. 이것은 엄격하게 로컬 URL입니다. 브라우저는이 URL을 서버로 보내지 않아야하며 페이지를 다시로드해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="90b902ee771a51ea4c2789f717ed041922a6f1b5" translate="yes" xml:space="preserve">
          <source>When the router navigates to this route, it uses the &lt;code&gt;&lt;a href=&quot;../api/router/route#loadChildren&quot;&gt;loadChildren&lt;/a&gt;&lt;/code&gt; string to dynamically load the &lt;code&gt;AdminModule&lt;/code&gt;. Then it adds the &lt;code&gt;AdminModule&lt;/code&gt; routes to its current route configuration. Finally, it loads the requested route to the destination admin component.</source>
          <target state="translated">라우터가이 경로를 탐색 할 때 &lt;code&gt;&lt;a href=&quot;../api/router/route#loadChildren&quot;&gt;loadChildren&lt;/a&gt;&lt;/code&gt; 문자열을 사용 하여 &lt;code&gt;AdminModule&lt;/code&gt; 을 동적으로로드합니다 . 그런 다음 &lt;code&gt;AdminModule&lt;/code&gt; 경로를 현재 경로 구성에 추가 합니다. 마지막으로 요청 된 경로를 대상 관리자 구성 요소로로드합니다.</target>
        </trans-unit>
        <trans-unit id="e3ce36dc52085de43eccd961e83d2d4a5764f0c6" translate="yes" xml:space="preserve">
          <source>When the router navigates to this route, it uses the &lt;code&gt;loadChildren&lt;/code&gt; string to dynamically load the &lt;code&gt;AdminModule&lt;/code&gt;. Then it adds the &lt;code&gt;AdminModule&lt;/code&gt; routes to its current route configuration. Finally, it loads the requested route to the destination admin component.</source>
          <target state="translated">라우터가이 경로로 이동할 때 &lt;code&gt;loadChildren&lt;/code&gt; 문자열을 사용 하여 &lt;code&gt;AdminModule&lt;/code&gt; 을 동적으로로드합니다 . 그런 다음 &lt;code&gt;AdminModule&lt;/code&gt; 경로를 현재 경로 구성에 추가 합니다. 마지막으로 요청 된 경로를 대상 관리 구성 요소에로드합니다.</target>
        </trans-unit>
        <trans-unit id="c4793c657e648cd962d6756a48cf39fb9572cc40" translate="yes" xml:space="preserve">
          <source>When the server is ready, you'll detach the In-memory Web API, and the app's requests will go through to the server.</source>
          <target state="translated">서버가 준비되면 메모리 내 웹 API를 분리하면 앱 요청이 서버로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8c5e1c6cb471ba84681d4eec768f8daf9aee7300" translate="yes" xml:space="preserve">
          <source>When the server responds successfully with the newly added hero, the component adds that hero to the displayed &lt;code&gt;heroes&lt;/code&gt; list.</source>
          <target state="translated">서버가 새로 추가 된 영웅으로 응답하면 컴포넌트는 해당 영웅을 표시된 &lt;code&gt;heroes&lt;/code&gt; 목록에 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="7f5488c0527bdc65788bef91441700006f51550b" translate="yes" xml:space="preserve">
          <source>When the tests are complete, the command creates a new &lt;code&gt;/coverage&lt;/code&gt; folder in the project. Open the &lt;code&gt;index.html&lt;/code&gt; file to see a report with your source code and code coverage values.</source>
          <target state="translated">테스트가 완료되면 명령은 프로젝트에 새 &lt;code&gt;/coverage&lt;/code&gt; 폴더를 만듭니다 . &lt;code&gt;index.html&lt;/code&gt; 파일을 열어 소스 코드 및 코드 범위 값이 포함 된 보고서를보십시오.</target>
        </trans-unit>
        <trans-unit id="cc433f6ebd5153ea48b6acb9758c8f35454ca692" translate="yes" xml:space="preserve">
          <source>When the url is either '/user' or '/user/bob', the active-link class will be added to the &lt;code&gt;&lt;a href=&quot;routerlinkwithhref&quot;&gt;a&lt;/a&gt;&lt;/code&gt; tag. If the url changes, the class will be removed.</source>
          <target state="translated">URL이 중 '/ 사용자'또는 '/ 사용자 / 밥'일 때, 활성 링크 클래스에 추가됩니다 태그입니다. URL이 변경되면 클래스가 제거됩니다. &lt;code&gt;&lt;a href=&quot;routerlinkwithhref&quot;&gt;a&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e60d76cafe61069c609990d884f74076646d020" translate="yes" xml:space="preserve">
          <source>When the user blurs the form control element, the control is marked as &quot;touched&quot;.</source>
          <target state="translated">사용자가 폼 컨트롤 요소를 흐리게하면 컨트롤이 &quot;touched&quot;로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="668fc76cc653d1cf74fa997aa61a6d6a3d5490f4" translate="yes" xml:space="preserve">
          <source>When the user changes the value in the watched field, the control is marked as &quot;dirty&quot;.</source>
          <target state="translated">사용자가 감시 필드의 값을 변경하면 컨트롤이 &quot;dirty&quot;로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="56e24b86fc8dc4eb7c05899793fc749916e2d93a" translate="yes" xml:space="preserve">
          <source>When the user clicks a hero in the &lt;strong&gt;master&lt;/strong&gt; list, the component should display the selected hero's &lt;strong&gt;details&lt;/strong&gt; at the bottom of the page.</source>
          <target state="translated">사용자가 &lt;strong&gt;마스터&lt;/strong&gt; 목록 에서 영웅을 클릭 하면 구성 요소가 선택한 영웅의 &lt;strong&gt;세부 정보&lt;/strong&gt; 를 페이지 하단에 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="0da528ae2bbf4606a802931b278d60a04b127084" translate="yes" xml:space="preserve">
          <source>When the user clicks a hero item in the &lt;code&gt;HeroesComponent&lt;/code&gt;, the app should navigate to the &lt;code&gt;HeroDetailComponent&lt;/code&gt;, replacing the heroes list view with the hero detail view. The heroes list view should no longer show hero details as it does now.</source>
          <target state="translated">사용자가 &lt;code&gt;HeroesComponent&lt;/code&gt; 에서 영웅 항목을 클릭 하면 앱이 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 로 이동 하여 영웅 목록보기를 영웅 세부 사항보기로 바꿔야 합니다. 영웅 목록보기에는 더 이상 영웅 세부 정보가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1bfbf5227f0c5acc162274df4182ff4308452c9e" translate="yes" xml:space="preserve">
          <source>When the user clicks the &lt;strong&gt;Delete hero&lt;/strong&gt; button, Angular calls the &lt;code&gt;deleteHero()&lt;/code&gt; method in the component class.</source>
          <target state="translated">사용자가 &lt;strong&gt;영웅 삭제&lt;/strong&gt; 버튼을 클릭하면 Angular 는 구성 요소 클래스에서 &lt;code&gt;deleteHero()&lt;/code&gt; 메서드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="965cc4386347869f8766b8bd6c03a51c94b256a1" translate="yes" xml:space="preserve">
          <source>When the user clicks the back button, the &lt;code&gt;HeroDetailComponent&lt;/code&gt; constructs another &lt;em&gt;link parameters array&lt;/em&gt; which it uses to navigate back to the &lt;code&gt;HeroListComponent&lt;/code&gt;.</source>
          <target state="translated">사용자가 뒤로 가기 버튼을 클릭하면 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 는 다른 구축 &lt;em&gt;링크 파라미터 어레이&lt;/em&gt; 는 행 위로 이동하기 위해 사용 &lt;code&gt;HeroListComponent&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="b5381f2dbc392678bc72803a41a04f59cc4b7028" translate="yes" xml:space="preserve">
          <source>When the user clicks the button, Angular calls the &lt;code&gt;onClickMe&lt;/code&gt; method from &lt;code&gt;ClickMeComponent&lt;/code&gt;.</source>
          <target state="translated">사용자가 버튼을 클릭하면 Angular는 &lt;code&gt;onClickMe&lt;/code&gt; 에서 &lt;code&gt;ClickMeComponent&lt;/code&gt; 메서드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="09f436cef939df335d96f2d5d3fa0d239641f9a3" translate="yes" xml:space="preserve">
          <source>When the user deletes the name, the form should look like this:</source>
          <target state="translated">사용자가 이름을 삭제하면 양식은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="60767066f8c768e0937e2414770db47911b50141" translate="yes" xml:space="preserve">
          <source>When the user enters &quot;Sally&quot; into the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, the DOM element &lt;code&gt;value&lt;/code&gt;&lt;em&gt;property&lt;/em&gt; becomes &quot;Sally&quot;. However, if you look at the HTML attribute &lt;code&gt;value&lt;/code&gt; using &lt;code&gt;input.getAttribute('value')&lt;/code&gt;, you can see that the &lt;em&gt;attribute&lt;/em&gt; remains unchanged&amp;mdash;it returns &quot;Sarah&quot;.</source>
          <target state="translated">사용자가 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 에 &quot;Sally&quot;를 입력 하면 DOM 요소 &lt;code&gt;value&lt;/code&gt; &lt;em&gt;특성&lt;/em&gt; 이 &quot;Sally&quot;가됩니다. 그러나 &lt;code&gt;input.getAttribute('value')&lt;/code&gt; 를 사용하여 HTML 속성 &lt;code&gt;value&lt;/code&gt; 을 보면 &lt;em&gt;속성&lt;/em&gt; 이 변경되지 않고 &quot;Sarah&quot;를 반환 한다는 것을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45684a41a52534dc3a21a13492006994cdd3ce14" translate="yes" xml:space="preserve">
          <source>When the user enters a name in a search-box, the &lt;code&gt;PackageSearchComponent&lt;/code&gt; sends a search request for a package with that name to the NPM web API.</source>
          <target state="translated">사용자가 검색 상자에 이름을 입력하면 &lt;code&gt;PackageSearchComponent&lt;/code&gt; 가 해당 이름의 패키지에 대한 검색 요청을 NPM 웹 API로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="9ace1fef581dffc80280ad525aed16d3b2efed3b" translate="yes" xml:space="preserve">
          <source>When the user makes changes, the component raises the &lt;code&gt;input&lt;/code&gt; event.</source>
          <target state="translated">사용자가 변경하면 구성 요소가 &lt;code&gt;input&lt;/code&gt; 이벤트를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="77b1e2ebde77a69768e8f8ec443b80048a531b16" translate="yes" xml:space="preserve">
          <source>When the user navigates away, you can let the user decide what to do with unsaved changes. If the user cancels, you'll stay put and allow more changes. If the user approves, the app can save.</source>
          <target state="translated">사용자가 다른 곳으로 이동할 때 저장되지 않은 변경 사항에 대해 수행 할 작업을 사용자가 결정하도록 할 수 있습니다. 사용자가 취소하면 그대로두고 더 많은 변경을 허용합니다. 사용자가 승인하면 앱이 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24612cfd1409a4d5460abc7f2935bcce9977ee3f" translate="yes" xml:space="preserve">
          <source>When the user navigates from the heroes list to the &quot;Magneta&quot; hero and back, &quot;Magneta&quot; appears selected:</source>
          <target state="translated">사용자가 영웅 목록에서 &quot;Magneta&quot;영웅으로 이동 한 후 &quot;Magneta&quot;가 선택된 것으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="20759cd95c7b4ee15d25a5ac38dd65f7086028c9" translate="yes" xml:space="preserve">
          <source>When the user picks a hero, &lt;code&gt;selectedHero&lt;/code&gt; has a value and &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; puts the hero detail into the DOM.</source>
          <target state="translated">사용자가 영웅을 &lt;code&gt;selectedHero&lt;/code&gt; 때 selectedHero 는 값을 가지며 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 는 영웅 세부 정보를 DOM에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="d3a252aba875b8f256c6decf33f58be856151e22" translate="yes" xml:space="preserve">
          <source>When the user selects a hero from the list, the app should navigate to the detail view and show that hero. You tell the detail view which hero to display by including the selected hero's id in the route URL.</source>
          <target state="translated">사용자가 목록에서 영웅을 선택하면 앱이 상세보기로 이동하여 해당 영웅을 표시해야합니다. 라우트 URL에 선택한 영웅의 ID를 포함시켜 표시 할 영웅을 세부 정보보기에 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="a510d7fcc215eca3c7dadb10daf2bda07de4c2f2" translate="yes" xml:space="preserve">
          <source>When the value changes in the UI, call the registered function to allow the forms API to update itself:</source>
          <target state="translated">UI에서 값이 변경되면 등록 된 함수를 호출하여 양식 API가 자체적으로 업데이트되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="8f3a890a779d79ad9661c7749d679f59723a6996" translate="yes" xml:space="preserve">
          <source>When the workspace file structure is in place, you can use the &lt;code&gt;ng generate&lt;/code&gt; command on the command line to add functionality and data to the application. This initial root-level application is the &lt;em&gt;default app&lt;/em&gt; for CLI commands (unless you change the default after creating &lt;a href=&quot;file-structure#multiple-projects&quot;&gt;additional apps&lt;/a&gt;).</source>
          <target state="translated">작업 공간 파일 구조가 있으면 명령 행 에서 &lt;code&gt;ng generate&lt;/code&gt; 명령을 사용하여 기능 및 데이터를 애플리케이션에 추가 할 수 있습니다 . 이 초기 루트 수준 응용 프로그램은 CLI 명령 의 &lt;em&gt;기본 응용 프로그램&lt;/em&gt; 입니다 ( &lt;a href=&quot;file-structure#multiple-projects&quot;&gt;추가 응용 프로그램&lt;/a&gt; 을 만든 후 기본값을 변경하지 않는 한 ).</target>
        </trans-unit>
        <trans-unit id="3732bd2e415ded41d84e9da700bfbe65d89ef57d" translate="yes" xml:space="preserve">
          <source>When there isn't a host element, you can usually wrap the content in a native HTML container element, such as a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;, and attach the directive to that wrapper.</source>
          <target state="translated">호스트 요소가없는 경우 일반적으로 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 와 같은 기본 HTML 컨테이너 요소로 컨텐츠를 랩핑 하고 지시자를 해당 랩퍼에 첨부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7317e6f21341edc26f7b439b83e9178a3a04032" translate="yes" xml:space="preserve">
          <source>When to use the lightweight injection token pattern</source>
          <target state="translated">경량 주입 토큰 패턴을 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="83997d9f88d048b1fdd10042c4c30cc032f0c0c2" translate="yes" xml:space="preserve">
          <source>When tokens are retained</source>
          <target state="translated">토큰이 유지되는 경우</target>
        </trans-unit>
        <trans-unit id="c5db41bbc82cfe3fbe2cd98e813bc5da1625b039" translate="yes" xml:space="preserve">
          <source>When translating the text, you can move the placeholder if necessary, but don't remove it. If you remove the placeholder, the ICU expression will not appear in your translated app.</source>
          <target state="translated">텍스트를 번역 할 때 필요한 경우 자리 표시자를 이동할 수 있지만 제거하지는 마십시오. 자리 표시자를 제거하면 번역 된 앱에 ICU 표현식이 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1fc8a283755738e86c35338fd89146a3972eeed2" translate="yes" xml:space="preserve">
          <source>When true (recommended), enables the &lt;a href=&quot;aot-compiler#binding-expression-validation&quot;&gt;binding expression validation&lt;/a&gt; phase of the template compiler, which uses TypeScript to validate binding expressions.</source>
          <target state="translated">true (권장) 인 경우 TypeScript를 사용하여 &lt;a href=&quot;aot-compiler#binding-expression-validation&quot;&gt;바인딩 표현식의 유효성을 검사&lt;/a&gt; 하는 템플릿 컴파일러 의 바인딩 표현식 유효성 검사 단계를 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="878269276c4b94291dba5557e0c330a0c66c6fb8" translate="yes" xml:space="preserve">
          <source>When true (recommended), reports an error for a supplied parameter whose injection type cannot be determined. When false (currently the default), constructor parameters of classes marked with &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;&lt;/code&gt; whose type cannot be resolved produce a warning.</source>
          <target state="translated">true (권장) 인 경우 주입 유형을 결정할 수없는 제공된 매개 변수에 대한 오류를보고합니다. false (현재 기본값) 인 경우 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;&lt;/code&gt; 로 표시된 클래스의 생성자 매개 변수에서 유형을 확인할 수없는 경우 경고가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b212849a159920cad7420629011f7a9864bdde5b" translate="yes" xml:space="preserve">
          <source>When true (the default) creates files at the top level of the project.</source>
          <target state="translated">true 인 경우 (기본값) 프로젝트의 최상위 레벨에 파일을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="b398aee58d8c1adc60ea74f0c726ecef38afbcac" translate="yes" xml:space="preserve">
          <source>When true (the default), creates a new initial app project in the src folder of the new workspace. When false, creates an empty workspace with no initial app. You can then use the generate application command so that all apps are created in the projects folder.</source>
          <target state="translated">true 인 경우 (기본값) 새 작업 공간의 src 폴더에 새 초기 앱 프로젝트를 만듭니다. false 인 경우 초기 앱없이 빈 작업 공간을 만듭니다. 그런 다음 generate application 명령을 사용하여 모든 앱이 프로젝트 폴더에 작성되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f663af0bc7e20b3f486914ba507c814d922aa1c9" translate="yes" xml:space="preserve">
          <source>When true (the default), creates a new initial application project in the src folder of the new workspace. When false, creates an empty workspace with no initial app. You can then use the generate application command so that all apps are created in the projects folder.</source>
          <target state="translated">true (기본값)이면 새 작업 공간의 src 폴더에 새 초기 애플리케이션 프로젝트를 만듭니다. false이면 초기 앱이없는 빈 작업 영역을 만듭니다. 그런 다음 모든 앱이 프로젝트 폴더에 생성되도록 애플리케이션 생성 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="604d90449f9af601695e42adb4b369217d014677" translate="yes" xml:space="preserve">
          <source>When true (the default), creates files at the top level of the project.</source>
          <target state="translated">true 인 경우 (기본값) 프로젝트의 최상위 레벨에 파일을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="7dcf5b75b56e6b05b97927c0c576164a022fcc31" translate="yes" xml:space="preserve">
          <source>When true (the default), creates the new files at the top level of the current project.</source>
          <target state="translated">true 인 경우 (기본값) 현재 프로젝트의 최상위 레벨에 새 파일을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="c73f51ee5cd9b796be53e6056b6cf273b83aea52" translate="yes" xml:space="preserve">
          <source>When true (the default), generates a &quot;spec.ts&quot; test file for the new class.</source>
          <target state="translated">true 인 경우 (기본값) 새 클래스에 대한 &quot;spec.ts&quot;테스트 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ee4fe2980cd47d4b732694bd3792325d274c7180" translate="yes" xml:space="preserve">
          <source>When true (the default), generates a &quot;spec.ts&quot; test file for the new component.</source>
          <target state="translated">true 인 경우 (기본값) 새 구성 요소에 대한 &quot;spec.ts&quot;테스트 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d9eb4be401f613f74c8a47c2093669fd19d2a62c" translate="yes" xml:space="preserve">
          <source>When true (the default), generates a &quot;spec.ts&quot; test file for the new directive.</source>
          <target state="translated">true 인 경우 (기본값) 새 지시문에 대한 &quot;spec.ts&quot;테스트 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6481d790b1dddc693cad7c9e147a4da0a6eb5138" translate="yes" xml:space="preserve">
          <source>When true (the default), generates a &quot;spec.ts&quot; test file for the new guard.</source>
          <target state="translated">true 인 경우 (기본값) 새 가드에 대한 &quot;spec.ts&quot;테스트 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a7a7c6e8767122c13c74f42b5133e29df9ca038a" translate="yes" xml:space="preserve">
          <source>When true (the default), generates a &quot;spec.ts&quot; test file for the new pipe.</source>
          <target state="translated">true 인 경우 (기본값) 새 파이프에 대한 &quot;spec.ts&quot;테스트 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="67bfaa3ef25e8db2f0c7f855a6f34e4bb636d36e" translate="yes" xml:space="preserve">
          <source>When true (the default), generates a &quot;spec.ts&quot; test file for the new service.</source>
          <target state="translated">true 인 경우 (기본값) 새 서비스에 대한 &quot;spec.ts&quot;테스트 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="13601450e9623940a233839335f1507064324df7" translate="yes" xml:space="preserve">
          <source>When true (the default), generates factory files (&lt;code&gt;.ngfactory.js&lt;/code&gt; and &lt;code&gt;.ngstyle.js&lt;/code&gt;) for &lt;code&gt;.d.ts&lt;/code&gt; files with a corresponding &lt;code&gt;.metadata.json&lt;/code&gt; file.</source>
          <target state="translated">true (기본값) 인 경우 해당 &lt;code&gt;.metadata.json&lt;/code&gt; 파일 이있는 &lt;code&gt;.d.ts&lt;/code&gt; 파일에 대한 팩토리 파일 ( &lt;code&gt;.ngfactory.js&lt;/code&gt; 및 &lt;code&gt;.ngstyle.js&lt;/code&gt; )을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="2a9112845e3cd524c5442bdae74800c9bc5fcdd4" translate="yes" xml:space="preserve">
          <source>When true (the default), transforms code that is or could be used in an annotation, to allow it to be imported from template factory modules. See &lt;a href=&quot;aot-compiler#metadata-rewriting&quot;&gt;metadata rewriting&lt;/a&gt; for more information.</source>
          <target state="translated">true (기본값) 인 경우 주석에 사용되거나 사용되는 코드를 변환하여 템플릿 팩토리 모듈에서 가져올 수 있도록합니다. 자세한 내용은 &lt;a href=&quot;aot-compiler#metadata-rewriting&quot;&gt;메타 데이터 재 작성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c8e2eb7a4ced22adde9d0624fe6eddd94fe05b5f" translate="yes" xml:space="preserve">
          <source>When true, accesses the global configuration in the caller's home directory.</source>
          <target state="translated">true 인 경우 호출자의 홈 디렉토리에서 글로벌 구성에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="bb60a760b14a85a1bcf7a224a79ad3a0f0de50f6" translate="yes" xml:space="preserve">
          <source>When true, adds more details to output logging.</source>
          <target state="translated">true 인 경우 출력 로깅에 세부 사항을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ab5469a20d0799c4f5bb3006c5ea578a0eca87e5" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the application.</source>
          <target state="translated">true 인 경우 응용 프로그램을 생성 한 후 보푸라기 수정 프로그램을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="65e6119dd752e0e555791a9d0884d1adaeeefb3e" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the class.</source>
          <target state="translated">true 인 경우 클래스를 생성 한 후 보푸라기 수정 프로그램을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="0adb7edc861426173459ea0ac523eb007f0c6759" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the component.</source>
          <target state="translated">true 인 경우 구성 요소를 생성 한 후 보푸라기 수정 프로그램을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="7a95d82cb423357b0496282514270de200f32d94" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the directive.</source>
          <target state="translated">true 인 경우 지시문을 생성 한 후 보푸라기 수정 프로그램을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="6ef7b46aab6c8559b742e340fc987833a15211ca" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the enum.</source>
          <target state="translated">true 인 경우 열거를 생성 한 후 보푸라기 수정 프로그램을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="0c51368d0aa738deb6b05772bdbedf82c36e2946" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the guard.</source>
          <target state="translated">참이면 가드를 생성 한 후 보푸라기 수정 프로그램을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="fc80788537b3a3ec52f8e8f2b6f05267ea52752b" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the interceptor.</source>
          <target state="translated">true 인 경우 인터셉터를 생성 한 후 Lint 수정을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="3c7d56418b815742975279a27504721340d37164" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the interface.</source>
          <target state="translated">true 인 경우 인터페이스를 생성 한 후 보푸라기 수정 프로그램을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="9df5ce1e8f7684c6a8dc523cf880a5980072d9b1" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the library.</source>
          <target state="translated">true 인 경우 라이브러리 생성 후 보푸라기 수정 프로그램을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="ea80c5d299d07258dde76aab64937de197bfd6f4" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the module.</source>
          <target state="translated">true 인 경우, 모듈 생성 후 보푸라기 수정 프로그램을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="d3ea9a477728c77e2d1847ebc54f96051234cae6" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the pipe.</source>
          <target state="translated">참이면 파이프를 생성 한 후 보푸라기 수정 프로그램을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="568d7e9013f771f110a76cdd6a84b6900cb5a879" translate="yes" xml:space="preserve">
          <source>When true, applies lint fixes after generating the service.</source>
          <target state="translated">true 인 경우 서비스 생성 후 보푸라기 수정 프로그램을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="3a45da43566e855927acf38adb2c984647ee7977" translate="yes" xml:space="preserve">
          <source>When true, creates a bare-bones project without any testing frameworks. (Use for learning purposes only.)</source>
          <target state="translated">true 인 경우 테스트 프레임 워크없이 베어 본 프로젝트를 작성합니다. (학습 목적으로 만 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="6003cdbbdfe68bec3d9470eff199fcd83c109def" translate="yes" xml:space="preserve">
          <source>When true, creates a new app that uses the Ivy rendering engine.</source>
          <target state="translated">true 인 경우 아이비 렌더링 엔진을 사용하는 새 앱을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2cd0a15167f0e4812f706fd666aae705c50d746b" translate="yes" xml:space="preserve">
          <source>When true, creates a project without any testing frameworks. (Use for learning purposes only.)</source>
          <target state="translated">true 인 경우 테스트 프레임 워크없이 프로젝트를 작성합니다. (학습 목적으로 만 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="cbf6fb323dee4d1c82a080508b0dc4b0f8607fed" translate="yes" xml:space="preserve">
          <source>When true, creates a routing NgModule.</source>
          <target state="translated">참이면 라우팅 NgModule을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="56dbc63b0ec51cd8cb74b3a1a9ad4fe8e0e83b50" translate="yes" xml:space="preserve">
          <source>When true, creates a routing module.</source>
          <target state="translated">true 인 경우 라우팅 모듈을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="580233c10f5dcbb1225384186d03c9828f27f54c" translate="yes" xml:space="preserve">
          <source>When true, creates a workspace without any testing frameworks. (Use for learning purposes only.)</source>
          <target state="translated">true이면 테스트 프레임 워크없이 작업 영역을 만듭니다. (학습 목적으로 만 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="c2ec0ae9d8c5507501033cd46944cba3283bfeae" translate="yes" xml:space="preserve">
          <source>When true, creates the new files at the top level of the current project root.</source>
          <target state="translated">true이면 현재 프로젝트 루트의 최상위에 새 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2e8e353066e54d59ddc751dbc9d0c297d8b85adb" translate="yes" xml:space="preserve">
          <source>When true, creates the new files at the top level of the current project.</source>
          <target state="translated">true 인 경우 현재 프로젝트의 최상위 레벨에 새 파일을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="f5a93a3117cd8f1514feec73f24850b724350d92" translate="yes" xml:space="preserve">
          <source>When true, deliver events asynchronously.</source>
          <target state="translated">true 인 경우 이벤트를 비동기 적으로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="18f021c0fe33a328d88b865734d1717e7626889b" translate="yes" xml:space="preserve">
          <source>When true, disables interactive input prompts for options with a default.</source>
          <target state="translated">true 인 경우 대화식 입력 프롬프트에서 기본값으로 옵션을 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6ada5bdef828fa760b365e6b7b776cf6b17adb4" translate="yes" xml:space="preserve">
          <source>When true, does not add dependencies to the &quot;package.json&quot; file.</source>
          <target state="translated">true 인 경우 &quot;package.json&quot;파일에 종속성을 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8d98eca32aeaddff19b79ab0b97e3b4f44f897f" translate="yes" xml:space="preserve">
          <source>When true, does not create &quot;spec.ts&quot; test files for the app.</source>
          <target state="translated">true 인 경우 앱에 대한 &quot;spec.ts&quot;테스트 파일을 작성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad9dfb140ef99c5cc049b7e2fb5cd3f4028d8921" translate="yes" xml:space="preserve">
          <source>When true, does not create &quot;spec.ts&quot; test files for the application.</source>
          <target state="translated">true 인 경우 응용 프로그램에 대한 &quot;spec.ts&quot;테스트 파일을 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e5f0ff4b1329f81e381ce2feefd91e48e03360c" translate="yes" xml:space="preserve">
          <source>When true, does not create &quot;spec.ts&quot; test files for the new class.</source>
          <target state="translated">true 인 경우 새 클래스에 대한 &quot;spec.ts&quot;테스트 파일을 작성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="787db2ebf3b6d9a9cfcb5d65d02ca9380b758bf7" translate="yes" xml:space="preserve">
          <source>When true, does not create &quot;spec.ts&quot; test files for the new component.</source>
          <target state="translated">true 인 경우 새 구성 요소에 대한 &quot;spec.ts&quot;테스트 파일을 작성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a05daffc1a3871cce336c9e222772d0c5768aeb" translate="yes" xml:space="preserve">
          <source>When true, does not create &quot;spec.ts&quot; test files for the new guard.</source>
          <target state="translated">true 인 경우 새 가드에 대한 &quot;spec.ts&quot;테스트 파일을 작성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e5fb12992a47534fd457e096d7be9954e441067" translate="yes" xml:space="preserve">
          <source>When true, does not create &quot;spec.ts&quot; test files for the new interceptor.</source>
          <target state="translated">true 인 경우 새 인터셉터에 대한 &quot;spec.ts&quot;테스트 파일을 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ec16b43282885c383a356226cf0f90b2d403309" translate="yes" xml:space="preserve">
          <source>When true, does not create &quot;spec.ts&quot; test files for the new pipe.</source>
          <target state="translated">true 인 경우 새 파이프에 대한 &quot;spec.ts&quot;테스트 파일을 작성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8dca9f2d6a2bcf883e9dfe335c0e95142163fb93" translate="yes" xml:space="preserve">
          <source>When true, does not create &quot;spec.ts&quot; test files for the new resolver.</source>
          <target state="translated">true 인 경우 새 해결 프로그램에 대한 &quot;spec.ts&quot;테스트 파일을 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84d13244f42f45e24f366a7c34846f7ff3ad9285" translate="yes" xml:space="preserve">
          <source>When true, does not create &quot;spec.ts&quot; test files for the new service.</source>
          <target state="translated">true 인 경우 새 서비스에 대한 &quot;spec.ts&quot;테스트 파일을 작성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff22a4e958e901d487c01fddcd1c261ea77d1f94" translate="yes" xml:space="preserve">
          <source>When true, does not emit &lt;code&gt;.ngfactory.js&lt;/code&gt; and &lt;code&gt;.ngstyle.js&lt;/code&gt; files. This turns off most of the template compiler and disables the reporting of template diagnostics.</source>
          <target state="translated">true 인 경우 &lt;code&gt;.ngfactory.js&lt;/code&gt; 및 &lt;code&gt;.ngstyle.js&lt;/code&gt; 파일을 내 보내지 않습니다 . 이렇게하면 대부분의 템플릿 컴파일러가 꺼지고 템플릿 진단보고가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="85d57e2a3768528616abacc66eeeda04f86cb197" translate="yes" xml:space="preserve">
          <source>When true, does not generate &quot;spec.ts&quot; test files for the new project.</source>
          <target state="translated">true 인 경우 새 프로젝트에 대한 &quot;spec.ts&quot;테스트 파일을 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="021531593a5857b6b634ffa7110b7e09677de92f" translate="yes" xml:space="preserve">
          <source>When true, does not import this component into the owning NgModule.</source>
          <target state="translated">true 인 경우이 컴포넌트를 소유하는 NgModule로 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9dce1aa639bae69ca39cbea2281f5ab52e2f5810" translate="yes" xml:space="preserve">
          <source>When true, does not import this directive into the owning NgModule.</source>
          <target state="translated">true이면이 지시문을 소유하는 NgModule로 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e39a45636deab57166780dec3288520cc3551132" translate="yes" xml:space="preserve">
          <source>When true, does not import this pipe into the owning NgModule.</source>
          <target state="translated">참이면이 파이프를 소유하는 NgModule로 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="541c18226ee8c59f40f232cd042028e33b0de587" translate="yes" xml:space="preserve">
          <source>When true, does not initialize a git repository.</source>
          <target state="translated">true 인 경우 git 저장소를 초기화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="521a0120a95b14866025640c398ce8f7ff310fa4" translate="yes" xml:space="preserve">
          <source>When true, does not install dependency packages.</source>
          <target state="translated">true 인 경우 종속성 패키지를 설치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3578b18def83dc2da16f045d899e718695cd50d" translate="yes" xml:space="preserve">
          <source>When true, does not install packages for dependencies.</source>
          <target state="translated">true 인 경우 종속성을위한 패키지를 설치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0646ee7c8071d504a9e696eab789659e9bc1e696" translate="yes" xml:space="preserve">
          <source>When true, does not to produce &lt;code&gt;.metadata.json&lt;/code&gt; files. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">true 인 경우 &lt;code&gt;.metadata.json&lt;/code&gt; 파일 을 생성하지 않습니다 . 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9c9ab2f848c6e3f1274c18107fe7541116d4de99" translate="yes" xml:space="preserve">
          <source>When true, does not update &quot;tsconfig.json&quot; to add a path mapping for the new library. The path mapping is needed to use the library in an app, but can be disabled here to simplify development.</source>
          <target state="translated">true 인 경우 &quot;tsconfig.json&quot;을 업데이트하여 새 라이브러리에 대한 경로 맵핑을 추가하지 마십시오. 앱에서 라이브러리를 사용하려면 경로 매핑이 필요하지만 개발을 단순화하기 위해 여기서 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62c6bdc8aeeb938a24e46cc58eb1bf0b651c1bf5" translate="yes" xml:space="preserve">
          <source>When true, enable the location strategy that uses the URL fragment instead of the history API.</source>
          <target state="translated">true 인 경우 히스토리 API 대신 URL 단편을 사용하는 위치 전략을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="261fe77e1b294ce4d3a98b31adb772ddea771256" translate="yes" xml:space="preserve">
          <source>When true, enables use of the &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; element, which was deprecated in Angular 4.0, in favor of &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; (to avoid colliding with the DOM's element of the same name). Default is false. Might be required by some third-party Angular libraries.</source>
          <target state="translated">true이면 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 에 찬성하여 Angular 4.0에서 사용되지 않는 &lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt; 요소를 사용할 수 있습니다 (같은 이름의 DOM 요소와 충돌하지 않기 위해). 기본값은 false입니다. 일부 타사 Angular 라이브러리에 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c0d541d696d1f15840d7575ea4f510c48c941cb" translate="yes" xml:space="preserve">
          <source>When true, forces overwriting of existing files.</source>
          <target state="translated">true 인 경우 기존 파일을 강제로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="1aaf874ced3ebb154b21f8167d3778c1794023b3" translate="yes" xml:space="preserve">
          <source>When true, generate all possible files even if they are empty. Default is false. Used by the Bazel build rules to simplify how Bazel rules track file dependencies. Do not use this option outside of the Bazel rules.</source>
          <target state="translated">true 인 경우 가능한 모든 파일이 비어 있어도 생성하십시오. 기본값은 false입니다. Bazel 규칙이 파일 종속성을 추적하는 방법을 단순화하기 위해 Bazel 빌드 규칙에서 사용됩니다. Bazel 규칙 외부에서이 옵션을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5b7e7bf350c9fcf27596aa20973b3db4fd6e8bb1" translate="yes" xml:space="preserve">
          <source>When true, generates a flat module index of the given file name and the corresponding flat module metadata. Use to create flat modules that are packaged similarly to &lt;code&gt;@angular/core&lt;/code&gt; and &lt;code&gt;@angular/common&lt;/code&gt;. When this option is used, the &lt;code&gt;package.json&lt;/code&gt; for the library should refer to the generated flat module index instead of the library index file.</source>
          <target state="translated">true 인 경우 지정된 파일 이름의 플랫 모듈 색인 및 해당 플랫 모듈 메타 데이터를 생성합니다. &lt;code&gt;@angular/core&lt;/code&gt; 및 &lt;code&gt;@angular/common&lt;/code&gt; 과 유사하게 패키지 된 플랫 모듈을 작성하는 데 사용하십시오 . 이 옵션을 사용 하는 경우 라이브러리 의 &lt;code&gt;package.json&lt;/code&gt; 은 라이브러리 색인 파일 대신 생성 된 플랫 모듈 색인을 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9b819323f8f18793bab01506d1b5f14bbec5acf" translate="yes" xml:space="preserve">
          <source>When true, generates a routing module for the initial project.</source>
          <target state="translated">true 인 경우 초기 프로젝트에 대한 라우팅 모듈을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ae14fe320ea896a875f632dbc4bff5abbda0c2a2" translate="yes" xml:space="preserve">
          <source>When true, includes styles inline in the component TS file. By default, an external styles file is created and referenced in the component TS file.</source>
          <target state="translated">true 인 경우 구성 요소 TS 파일에 스타일을 인라인으로 포함시킵니다. 기본적으로 외부 스타일 파일은 구성 요소 TS 파일에서 작성되고 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="3b3beaf924cf679384a2ed4d3854a933a4318a5b" translate="yes" xml:space="preserve">
          <source>When true, includes styles inline in the component.ts file. Only CSS styles can be included inline. By default, an external styles file is created and referenced in the component.ts file.</source>
          <target state="translated">true 인 경우 component.ts 파일에 스타일을 인라인으로 포함시킵니다. CSS 스타일 만 인라인으로 포함 할 수 있습니다. 기본적으로 외부 스타일 파일이 component.ts 파일에서 작성되고 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="1fc4893016b862f1f6cb51410f367ec8369a5e97" translate="yes" xml:space="preserve">
          <source>When true, includes styles inline in the root component.ts file. Only CSS styles can be included inline. Default is false, meaning that an external styles file is created and referenced in the root component.ts file.</source>
          <target state="translated">true 인 경우 루트 component.ts 파일에 스타일을 인라인으로 포함합니다. CSS 스타일 만 인라인으로 포함 할 수 있습니다. 기본값은 false입니다. 이는 외부 스타일 파일이 작성되어 루트 component.ts 파일에서 참조됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="33247607dda0b14efd7380854b7d1b95cb8b707e" translate="yes" xml:space="preserve">
          <source>When true, includes template inline in the component TS file. By default, an external template file is created and referenced in the component TS file.</source>
          <target state="translated">true 인 경우 구성 요소 TS 파일에 템플리트 인라인을 포함시킵니다. 기본적으로 외부 템플리트 파일은 구성 요소 TS 파일에서 작성되고 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="d5899d892e6bf561e02447910478d247955babab" translate="yes" xml:space="preserve">
          <source>When true, includes template inline in the component.ts file. By default, an external template file is created and referenced in the component.ts file.</source>
          <target state="translated">true 인 경우 component.ts 파일에 인라인 템플리트를 포함시킵니다. 기본적으로 외부 템플리트 파일이 component.ts 파일에서 작성되고 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="9ddaf69f17ee1d461ed6364788294b2a4b709ebc" translate="yes" xml:space="preserve">
          <source>When true, includes template inline in the root component.ts file. Default is false, meaning that an external template file is created and referenced in the root component.ts file.</source>
          <target state="translated">true 인 경우 루트 component.ts 파일에 템플리트를 인라인으로 포함합니다. 기본값은 false입니다. 이는 외부 component 파일이 루트 component.ts 파일에서 작성되고 참조됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9fe87a52ceeabbe44e5c515a3228147cbc64b6f3" translate="yes" xml:space="preserve">
          <source>When true, injector returns an array of instances. This is useful to allow multiple providers spread across many files to provide configuration information to a common token.</source>
          <target state="translated">true 인 경우 인젝터는 인스턴스 배열을 리턴합니다. 이는 여러 공급자가 여러 파일에 분산되어 구성 정보를 공통 토큰에 제공 할 수 있도록하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f2bf503a52e77886a9df9b3b721629b7bdd83f5d" translate="yes" xml:space="preserve">
          <source>When true, log all internal navigation events to the console. Use for debugging.</source>
          <target state="translated">true 인 경우 모든 내부 탐색 이벤트를 콘솔에 로그하십시오. 디버깅에 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0ba98b8ba818a019d7726ea3cd743749164694e0" translate="yes" xml:space="preserve">
          <source>When true, navigates while replacing the current state in history.</source>
          <target state="translated">true 인 경우 히스토리에서 현재 상태를 바꾸면서 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="100b728dbc5957ef91ab9a8121d4653d7ee51209" translate="yes" xml:space="preserve">
          <source>When true, navigates without pushing a new state into history.</source>
          <target state="translated">true 인 경우 새로운 상태를 히스토리로 푸시하지 않고 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="008db015d7015b6513b946d13e89a45905cf3dd3" translate="yes" xml:space="preserve">
          <source>When true, preserves the URL fragment for the next navigation</source>
          <target state="translated">true 인 경우 다음 탐색을 위해 URL 조각을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="e7053f3ec9579533ad57553df2fc44aae15cfd47" translate="yes" xml:space="preserve">
          <source>When true, prints extra information while compiling templates. Default is false.</source>
          <target state="translated">true 인 경우 템플릿을 컴파일하는 동안 추가 정보를 인쇄합니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="470599a91818785c5ee58a0f113cae7c96500252" translate="yes" xml:space="preserve">
          <source>When true, replaces the &lt;code&gt;templateUrl&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/core/component#styleUrls&quot;&gt;styleUrls&lt;/a&gt;&lt;/code&gt; property in all &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; decorators with inlined contents in &lt;code&gt;template&lt;/code&gt; and &lt;code&gt;styles&lt;/code&gt; properties.</source>
          <target state="translated">true 인 경우 모든 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt; 데코레이터 의 &lt;code&gt;templateUrl&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/core/component#styleUrls&quot;&gt;styleUrls&lt;/a&gt;&lt;/code&gt; 속성 을 &lt;code&gt;template&lt;/code&gt; 및 &lt;code&gt;styles&lt;/code&gt; 속성의 인라인 된 내용으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="1a4f8c074303da2d063c77492f8e15e05b86f00c" translate="yes" xml:space="preserve">
          <source>When true, reports an error to the &lt;code&gt;.metadata.json&lt;/code&gt; file if &lt;code&gt;&quot;skipMetadataEmit&quot;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. Default is false. Use only when &lt;code&gt;&quot;skipMetadataEmit&quot;&lt;/code&gt; is false and &lt;code&gt;&quot;skipTemplateCodeGen&quot;&lt;/code&gt; is true.</source>
          <target state="translated">true 인 경우 &lt;code&gt;&quot;skipMetadataEmit&quot;&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 &lt;code&gt;.metadata.json&lt;/code&gt; 파일에 오류를보고합니다 . 기본값은 false입니다. &lt;code&gt;&quot;skipMetadataEmit&quot;&lt;/code&gt; 가 false이고 &lt;code&gt;&quot;skipTemplateCodeGen&quot;&lt;/code&gt; 이 true 인 경우에만 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fee2c0f9c227cd936e7e0ec7fde35afd7a82fa14" translate="yes" xml:space="preserve">
          <source>When true, runs through and reports activity without writing out results.</source>
          <target state="translated">true 인 경우 결과를 쓰지 않고 활동을보고합니다.</target>
        </trans-unit>
        <trans-unit id="248e093ad4093bf849e9a2bb8ea6c61115311429" translate="yes" xml:space="preserve">
          <source>When true, searches all of angular.io. Otherwise, searches only API reference documentation.</source>
          <target state="translated">true이면 angular.io를 모두 검색합니다. 그렇지 않으면 API 참조 문서 만 검색합니다.</target>
        </trans-unit>
        <trans-unit id="d2052aabfdb00eb60b3def41e228c021090d18cd" translate="yes" xml:space="preserve">
          <source>When true, the declaring NgModule exports this component.</source>
          <target state="translated">true 인 경우 선언하는 NgModule이이 구성 요소를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="474f66dc7056c6ae634ff04631017e86490c737b" translate="yes" xml:space="preserve">
          <source>When true, the declaring NgModule exports this directive.</source>
          <target state="translated">true 인 경우 선언하는 NgModule이이 지시문을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="89179c30c022a69730027b86caf1462ba77a87db" translate="yes" xml:space="preserve">
          <source>When true, the declaring NgModule exports this pipe.</source>
          <target state="translated">true 인 경우 선언하는 NgModule이이 파이프를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="04e0e74efef0d3f502332b17196bd16fef5f0f39" translate="yes" xml:space="preserve">
          <source>When true, the new component is the entry component of the declaring NgModule.</source>
          <target state="translated">참이면 새로운 컴포넌트는 NgModule 선언의 엔트리 컴포넌트입니다.</target>
        </trans-unit>
        <trans-unit id="6fbefb81d5660c920378ce16f4fcf3f36378b0ac" translate="yes" xml:space="preserve">
          <source>When true, the pipe is pure, meaning that the &lt;code&gt;transform()&lt;/code&gt; method is invoked only when its input arguments change. Pipes are pure by default.</source>
          <target state="translated">true 인 경우 파이프가 순수 하므로 입력 인수가 변경 될 때만 &lt;code&gt;transform()&lt;/code&gt; 메소드가 호출됩니다. 파이프는 기본적으로 순수합니다.</target>
        </trans-unit>
        <trans-unit id="56b0467d9b50fc15e1b147ea8d738c249762a269" translate="yes" xml:space="preserve">
          <source>When true, the special animation control binding &lt;code&gt;@.disabled&lt;/code&gt; binding prevents all animations from rendering. Place the &lt;code&gt;@.disabled&lt;/code&gt; binding on an element to disable animations on the element itself, as well as any inner animation triggers within the element.</source>
          <target state="translated">true 인 경우 특수 애니메이션 컨트롤 바인딩 &lt;code&gt;@.disabled&lt;/code&gt; 바인딩은 모든 애니메이션이 렌더링되지 않도록합니다. 장소 &lt;code&gt;@.disabled&lt;/code&gt; 소자 자체 비활성화 애니메이션뿐만 아니라, 소자 내의 내부 애니메이션을 트리거 요소에 바인딩.</target>
        </trans-unit>
        <trans-unit id="685f4a008223a0507d20fd336655976d7b7efaea" translate="yes" xml:space="preserve">
          <source>When true, use &lt;a href=&quot;https://github.com/angular/tsickle&quot;&gt;Tsickle&lt;/a&gt; to annotate the emitted JavaScript with &lt;a href=&quot;http://usejsdoc.org/&quot;&gt;JSDoc&lt;/a&gt; comments needed by the &lt;a href=&quot;https://github.com/google/closure-compiler&quot;&gt;Closure Compiler&lt;/a&gt;. Default is false.</source>
          <target state="translated">true 인 경우 &lt;a href=&quot;https://github.com/angular/tsickle&quot;&gt;Tsickle&lt;/a&gt; 을 사용 하여 &lt;a href=&quot;https://github.com/google/closure-compiler&quot;&gt;Closure Compiler에&lt;/a&gt; 필요한 &lt;a href=&quot;http://usejsdoc.org/&quot;&gt;JSDoc&lt;/a&gt; 주석으로 생성 된 JavaScript에 주석을 답니다 . 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="8fc2c813522ec25fd67580fe8ed8634f057ad051" translate="yes" xml:space="preserve">
          <source>When two imported modules, loaded at the same time, list a provider with the same token, the second module's provider &quot;wins&quot;. That's because both providers are added to the same injector.</source>
          <target state="translated">가져온 두 개의 모듈이 동시에로드되면 동일한 토큰을 가진 공급자를 나열하면 두 번째 모듈의 공급자가 &quot;승리&quot;합니다. 두 공급자가 동일한 인젝터에 추가 되었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="8a38590f055a7be9417ecb7107a61245f38e62ba" translate="yes" xml:space="preserve">
          <source>When updating the value for a form group instance that contains multiple controls, you may only want to update parts of the model. This section covers how to update specific parts of a form control data model.</source>
          <target state="translated">여러 컨트롤이 포함 된 양식 그룹 인스턴스의 값을 업데이트 할 때 모델의 일부만 업데이트 할 수 있습니다. 이 섹션에서는 폼 컨트롤 데이터 모델의 특정 부분을 업데이트하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0cb80c294f2ac7a6f549a1f6b747ec2a760b7c8e" translate="yes" xml:space="preserve">
          <source>When users click a &lt;em&gt;deep link&lt;/em&gt; in an email, open the detail view for a particular hero.</source>
          <target state="translated">사용자 가 이메일에서 &lt;em&gt;딥 링크&lt;/em&gt; 를 클릭 하면 특정 영웅에 대한 상세보기를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="06df6a1b0b43e2a627825e02e4d731eb142a9abd" translate="yes" xml:space="preserve">
          <source>When users click a hero name in either view, navigate to a detail view of the selected hero.</source>
          <target state="translated">사용자가 어느보기에서든 영웅 이름을 클릭하면 선택한 영웅의 상세보기로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="d2720a13b038e3604df3e775da3153607bd18d08" translate="yes" xml:space="preserve">
          <source>When users refresh the application, they see the latest fully cached version. New tabs load the latest cached code.</source>
          <target state="translated">사용자가 응용 프로그램을 새로 고치면 완전히 캐시 된 최신 버전이 표시됩니다. 새 탭은 최신 캐시 코드를로드합니다.</target>
        </trans-unit>
        <trans-unit id="89ee168cd559f7f8ec103bc580870b5f544559ab" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../../core/platformref#bootstrapmodule&quot;&gt;`bootstrapModule()`&lt;/a&gt; or &lt;a href=&quot;../../core/platformref#bootstrapmodulefactory&quot;&gt;`bootstrapModuleFactory()`&lt;/a&gt; to bootstrap the downgraded modules, each one is considered a &quot;root&quot; module. As a consequence, a new instance will be created for every injectable provided in &lt;code&gt;&quot;root&quot;&lt;/code&gt; (via &lt;a href=&quot;../../core/injectable#providedIn&quot;&gt;`providedIn`&lt;/a&gt;). If this is not your intention, you can have a shared module (that will act as act as the &quot;root&quot; module) and create all downgraded modules using that module's injector:</source>
          <target state="translated">사용시 &lt;a href=&quot;../../core/platformref#bootstrapmodule&quot;&gt;`bootstrapModule을 ()`&lt;/a&gt; 또는 &lt;a href=&quot;../../core/platformref#bootstrapmodulefactory&quot;&gt;`bootstrapModuleFactory () '&lt;/a&gt; 각각은 &quot;루트&quot;모듈로 간주되며, 다운 그레이드 모듈 부트 스트랩. 결과적으로 &lt;code&gt;&quot;root&quot;&lt;/code&gt; 로 제공되는 모든 인젝터 블 ( &lt;a href=&quot;../../core/injectable#providedIn&quot;&gt;'providedIn`을&lt;/a&gt; 통해) 에 대해 새로운 인스턴스가 생성 됩니다 . 이것이 의도가 아닌 경우, 공유 모듈 ( &quot;루트&quot;모듈로 작동 할 것)을 갖고 해당 모듈의 인젝터를 사용하여 다운 그레이드 된 모든 모듈을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ded6d3e9bc80e46e3525defd91a7c6252307962" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../api/common/http/httpclient#request&quot;&gt;&lt;code&gt;HttpClient#request()&lt;/code&gt;&lt;/a&gt; with an HTTP method, configure with &lt;a href=&quot;../api/common/http/httpclient#request&quot;&gt;&lt;code&gt;observe: 'events'&lt;/code&gt;&lt;/a&gt; to see all events, including the progress of transfers.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;../api/common/http/httpclient#request&quot;&gt; &lt;code&gt;HttpClient#request()&lt;/code&gt; &lt;/a&gt; 과 HTTP 방식으로, 구성 &lt;a href=&quot;../api/common/http/httpclient#request&quot;&gt; &lt;code&gt;observe: 'events'&lt;/code&gt; &lt;/a&gt; 전송의 진행을 포함하여 모든 이벤트를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6991172ddb2922b4845f9e0833f99ccb5df9980b" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../api/common/http/httpclient#request&quot;&gt;&lt;code&gt;HttpClient.request()&lt;/code&gt;&lt;/a&gt; with an HTTP method, configure the method with &lt;a href=&quot;../api/common/http/httpclient#request&quot;&gt;&lt;code&gt;observe: 'events'&lt;/code&gt;&lt;/a&gt; to see all events, including the progress of transfers.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;../api/common/http/httpclient#request&quot;&gt; &lt;code&gt;HttpClient.request()&lt;/code&gt; &lt;/a&gt; 하는 HTTP 방법과 방법을 구성 &lt;a href=&quot;../api/common/http/httpclient#request&quot;&gt; &lt;code&gt;observe: 'events'&lt;/code&gt; &lt;/a&gt; 전송의 진행을 포함하여 모든 이벤트를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c69f633c581d7efc3b0e3be27a1a0f2399964d92" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;$event.target&lt;/code&gt; for DOM events (because of the possibility of event bubbling, &lt;code&gt;$event.target&lt;/code&gt; in the DOM typings doesn't have the type you might expect).</source>
          <target state="translated">DOM 이벤트에 &lt;code&gt;$event.target&lt;/code&gt; 을 사용할 때 (이벤트 버블 링 가능성 때문에 DOM 유형의 &lt;code&gt;$event.target&lt;/code&gt; 에 예상 할 수있는 유형이 없습니다).</target>
        </trans-unit>
        <trans-unit id="e8e9cb3c6b273bb12f381bfd95b5afdab0eb5729" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;&lt;a href=&quot;downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt;, downgraded injectables will not be available until the Angular module that provides them is instantiated. In order to be safe, you need to ensure that the downgraded injectables are not used anywhere &lt;em&gt;outside&lt;/em&gt; the part of the app where it is guaranteed that their module has been instantiated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; 사용하는 경우 다운 그레이드 된 인젝터 블은이를 제공하는 Angular 모듈이 인스턴스화 될 때까지 사용할 수 없습니다. 안전을 위해, 다운 그레이드 된 인젝터 블이 앱의 &lt;em&gt;외부&lt;/em&gt; 에서 모듈이 인스턴스화되었다는 보장 이없는 곳에서 사용되지 않도록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="75f082f4a2a9292bee0a6ec7fcdcf08c245efeae" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;()&lt;/code&gt;, your code must be prepared for a null value. If you don't register a logger provider anywhere, the injector sets the value of &lt;code&gt;logger&lt;/code&gt; to null.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;()&lt;/code&gt; 사용할 때 코드는 null 값을 준비해야합니다. 로거 공급자를 어디에도 등록하지 않으면 인젝터가 &lt;code&gt;logger&lt;/code&gt; 값 을 null로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="20476825f82847cd1a9f8b625992073f31914a1b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;bypassSecurityTrust...&lt;/code&gt;, make sure to call the method as early as possible and as close as possible to the source of the value, to make it easy to verify no security bug is created by its use.</source>
          <target state="translated">&lt;code&gt;bypassSecurityTrust...&lt;/code&gt; 사용할 때는 가능한 빨리 값의 소스에 메소드를 호출하여 사용으로 보안 버그가 작성되지 않았는지 쉽게 확인할 수 있도록하십시오.</target>
        </trans-unit>
        <trans-unit id="1b0737e35a4e2a89a802c7501f9bcde999f119f8" translate="yes" xml:space="preserve">
          <source>When using a &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; to navigate instead of the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; service, you'd use the &lt;em&gt;same&lt;/em&gt; link parameters array, but you wouldn't provide the object with the &lt;code&gt;&lt;a href=&quot;../api/router/navigationextras#relativeTo&quot;&gt;relativeTo&lt;/a&gt;&lt;/code&gt; property. The &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; is implicit in a &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; directive.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 서비스 대신 &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; 를 사용하여 탐색 할 때 &lt;em&gt;동일한&lt;/em&gt; 링크 매개 변수 배열을 사용하지만 객체에 &lt;code&gt;&lt;a href=&quot;../api/router/navigationextras#relativeTo&quot;&gt;relativeTo&lt;/a&gt;&lt;/code&gt; 속성을 제공하지는 않습니다 . &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; 는 A의 암시이다 &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; 의 지시어.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0a811dcb555e2b511e7286f846a7606bfaba1d87" translate="yes" xml:space="preserve">
          <source>When using a &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; to navigate instead of the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; service, you'd use the same link parameters array, but you wouldn't provide the object with the &lt;code&gt;relativeTo&lt;/code&gt; property. The &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; is implicit in a &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; directive.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 서비스 대신 &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; 를 사용하여 탐색 할 때 동일한 링크 매개 변수 배열을 사용하지만 &lt;code&gt;relativeTo&lt;/code&gt; 속성을 개체에 제공하지 않습니다 . &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; 는 A의 암시이다 &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; 의 지시어.</target>
        </trans-unit>
        <trans-unit id="7e193170cfcf2c61d6cccc9238988d857864d00f" translate="yes" xml:space="preserve">
          <source>When using absolute redirects, the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; will use the query parameters and the fragment from the &lt;code&gt;redirectTo&lt;/code&gt; in the route config.</source>
          <target state="translated">절대 리디렉션 을 사용하는 경우 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 는 경로 구성에있는 &lt;code&gt;redirectTo&lt;/code&gt; 의 쿼리 매개 변수와 조각을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="c1b489e199dd0f47c8d42b6e961935b6f956c657" translate="yes" xml:space="preserve">
          <source>When using absolute redirects, the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; will use the query parameters and the fragment from the redirectTo in the route config.</source>
          <target state="translated">절대 리디렉션 을 사용하는 경우 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 는 라우팅 구성에서 redirectTo의 쿼리 매개 변수와 조각을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="26ed9b82d17457df64013b9eb1fbbaccf7274474" translate="yes" xml:space="preserve">
          <source>When using an &lt;code&gt;intervalTimer()&lt;/code&gt; such as &lt;code&gt;setInterval()&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt;, remember to cancel the timer with &lt;code&gt;clearInterval()&lt;/code&gt; after the test, otherwise the &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt; never ends.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;intervalTimer()&lt;/code&gt; 와 같은 &lt;code&gt;setInterval()&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt; 와 타이머 취소 기억 &lt;code&gt;clearInterval()&lt;/code&gt; , 시험 후를 달리 &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt; 결코 끝.</target>
        </trans-unit>
        <trans-unit id="0913755b7a1f7c285fbf6bb8b2526ee9e83ffe74" translate="yes" xml:space="preserve">
          <source>When using an &lt;code&gt;intervalTimer()&lt;/code&gt; such as &lt;code&gt;setInterval()&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../api/core/testing/waitforasync&quot;&gt;waitForAsync&lt;/a&gt;()&lt;/code&gt;, remember to cancel the timer with &lt;code&gt;clearInterval()&lt;/code&gt; after the test, otherwise the &lt;code&gt;&lt;a href=&quot;../api/core/testing/waitforasync&quot;&gt;waitForAsync&lt;/a&gt;()&lt;/code&gt; never ends.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;intervalTimer()&lt;/code&gt; 와 같은 &lt;code&gt;setInterval()&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../api/core/testing/waitforasync&quot;&gt;waitForAsync&lt;/a&gt;()&lt;/code&gt; 와 타이머 취소 기억 &lt;code&gt;clearInterval()&lt;/code&gt; , 시험 후를 달리 &lt;code&gt;&lt;a href=&quot;../api/core/testing/waitforasync&quot;&gt;waitForAsync&lt;/a&gt;()&lt;/code&gt; 결코 끝.</target>
        </trans-unit>
        <trans-unit id="134ada82c1bf109630654ad3274d0beaed098194" translate="yes" xml:space="preserve">
          <source>When using developer tools, the service worker is kept running in the background and never restarts. This can cause behavior with Dev Tools open to differ from behavior a user might experience.</source>
          <target state="translated">개발자 도구를 사용할 때 서비스 워커는 백그라운드에서 계속 실행되며 다시 시작되지 않습니다. 이로 인해 개발자 도구가 열려있는 동작이 사용자가 경험할 수있는 동작과 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86d7701f04dbf3278e6bca7d61dec82d10b279c4" translate="yes" xml:space="preserve">
          <source>When using emulated view encapsulation, Angular preprocesses all component styles so that they approximate the standard shadow CSS scoping rules.</source>
          <target state="translated">에뮬레이트 된 뷰 캡슐화를 사용하는 경우 Angular는 모든 구성 요소 스타일을 표준 그림자 CSS 범위 지정 규칙에 근접하도록 사전 처리합니다.</target>
        </trans-unit>
        <trans-unit id="f476c990cc992dd16e94e4d7fcc49cfd01a3387d" translate="yes" xml:space="preserve">
          <source>When using hidden source maps, source maps will not be referenced in the bundle. These are useful if you only want source maps to map error stack traces in error reporting tools, but don't want to expose your source maps in the browser developer tools.</source>
          <target state="translated">숨겨진 소스 맵을 사용하는 경우 번들에서 소스 맵이 참조되지 않습니다. 이 기능은 오류보고 도구에서 소스 맵만 오류 스택 추적을 매핑하도록하지만 브라우저 개발자 도구에서 소스 맵을 노출하지 않으려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="054db0ee1823c84752e38fc7a84cd6430df5dfe9" translate="yes" xml:space="preserve">
          <source>When using reactive forms:</source>
          <target state="translated">반응 형을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="a828cec6b58e6cb53d2d46a10e8a8e3c000ea7e3" translate="yes" xml:space="preserve">
          <source>When using relative redirects, the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; use the query params and the fragment from the source URL.</source>
          <target state="translated">상대 리디렉션을 사용할 때 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 는 쿼리 매개 변수와 소스 URL의 조각을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4bf6376b9afea8589f45d2366477e10bd15c8b4c" translate="yes" xml:space="preserve">
          <source>When using template expressions follow these guidelines:</source>
          <target state="translated">템플릿 표현식을 사용하는 경우 다음 지침을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="fd4419420c68cdc2d776a0c6bc7ea6c5c98b6a97" translate="yes" xml:space="preserve">
          <source>When using template-driven forms:</source>
          <target state="translated">템플릿 기반 양식을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="bb75301a3f57d2766a42cb47b657dd6174d1abe3" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;&lt;a href=&quot;ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; within &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tags, you'll also need to supply a &lt;code&gt;name&lt;/code&gt; attribute so that the control can be registered with the parent form under that name.</source>
          <target state="translated">&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 태그 내 에서 &lt;code&gt;&lt;a href=&quot;ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 을 사용하는 경우 해당 이름 아래의 부모 양식으로 컨트롤을 등록 할 수 있도록 &lt;code&gt;name&lt;/code&gt; 속성 도 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2ffcf1c257cc809ebc12f8b82bc6e12b17f71b98" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;controller as&lt;/code&gt; syntax, the binding is prefixed with the controller alias (&lt;code&gt;vm&lt;/code&gt; or &lt;code&gt;$ctrl&lt;/code&gt;) because you have to be specific about the source of the binding.</source>
          <target state="translated">&lt;code&gt;controller as&lt;/code&gt; 구문 으로 사용하는 경우 바인딩 소스를 구체적으로 지정해야하기 때문에 바인딩에 컨트롤러 별칭 ( &lt;code&gt;vm&lt;/code&gt; 또는 &lt;code&gt;$ctrl&lt;/code&gt; ) 이 접두어로 붙습니다 .</target>
        </trans-unit>
        <trans-unit id="c56383a8e88adb805d2997bbc9ee6587fb9288df" translate="yes" xml:space="preserve">
          <source>When using the component from AngularJS, you can supply contents for it. Just like they would be transcluded in AngularJS, they get projected to the location of the &lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt; tag in Angular:</source>
          <target state="translated">AngularJS에서 컴포넌트를 사용할 때 컨텐츠를 제공 할 수 있습니다. AngularJS에서 변환되는 것처럼 Angular에서 &lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt; 태그 의 위치에 투영됩니다 .</target>
        </trans-unit>
        <trans-unit id="af40b2a4b9fbeccafb0fb2865807c495201f126f" translate="yes" xml:space="preserve">
          <source>When using the shorthand syntax, Angular allows only &lt;a href=&quot;../../guide/structural-directives#one-structural-directive-per-host-element&quot;&gt;one structural directive on an element&lt;/a&gt;. If you want to iterate conditionally, for example, put the &lt;code&gt;*&lt;a href=&quot;ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; on a container element that wraps the &lt;code&gt;*&lt;a href=&quot;ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; element. For futher discussion, see &lt;a href=&quot;../../guide/structural-directives#one-per-element&quot;&gt;Structural Directives&lt;/a&gt;.</source>
          <target state="translated">속기 구문을 사용할 때 Angular는 &lt;a href=&quot;../../guide/structural-directives#one-structural-directive-per-host-element&quot;&gt;요소에 하나의 구조적 지시문&lt;/a&gt; 만 허용합니다 . 조건부 반복하려는 경우, 예를 들어, 넣어 &lt;code&gt;*&lt;a href=&quot;ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 을 감쌈 컨테이너 요소에 &lt;code&gt;*&lt;a href=&quot;ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 요소를. 추가 설명은 &lt;a href=&quot;../../guide/structural-directives#one-per-element&quot;&gt;구조 지시문을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6535dd674dcfb46d5113fb884e93a5283000217b" translate="yes" xml:space="preserve">
          <source>When would I put specs in a test folder?</source>
          <target state="translated">언제 테스트 폴더에 사양을 넣을까요?</target>
        </trans-unit>
        <trans-unit id="1c89837031479519507a2b713b0588a162366ed7" translate="yes" xml:space="preserve">
          <source>When writing a binding, be aware of a template statement's &lt;strong&gt;execution context&lt;/strong&gt;. The identifiers in a template statement belong to a specific context object, usually the Angular component controlling the template. The example above shows a single line of HTML, but that HTML belongs to a larger component:</source>
          <target state="translated">바인딩을 작성할 때 템플릿 문의 &lt;strong&gt;실행 컨텍스트를&lt;/strong&gt; 알고 있어야 합니다. 템플릿 문의 식별자는 특정 컨텍스트 객체, 일반적으로 템플릿을 제어하는 ​​Angular 구성 요소에 속합니다. 위의 예제는 한 줄의 HTML을 보여 주지만 HTML은 더 큰 구성 요소에 속합니다.</target>
        </trans-unit>
        <trans-unit id="0f96cd01fd00c2449a0dbebceeb658bd4c59c3e1" translate="yes" xml:space="preserve">
          <source>When you add a hero to the list of heroes, it appears to fly onto the page from the left.</source>
          <target state="translated">영웅 목록에 영웅을 추가하면 왼쪽에서 페이지로 이동하는 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="482aa2abe869c9716a8cb6d5ccd25b994760f22c" translate="yes" xml:space="preserve">
          <source>When you add a package with deployment capability, it'll automatically update your workspace configuration (&lt;code&gt;angular.json&lt;/code&gt; file) with a &lt;code&gt;deploy&lt;/code&gt; section for the selected project. You can then use the &lt;code&gt;ng deploy&lt;/code&gt; command to deploy that project.</source>
          <target state="translated">배포 기능이있는 패키지를 추가 하면 선택한 프로젝트 의 &lt;code&gt;deploy&lt;/code&gt; 섹션으로 작업 영역 구성 ( &lt;code&gt;angular.json&lt;/code&gt; 파일) 이 자동으로 업데이트됩니다 . 그런 다음 &lt;code&gt;ng deploy&lt;/code&gt; 명령을 사용하여 해당 프로젝트를 배포 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a2441d7ee90ea32ef89ecf67cc9c5bacf216961" translate="yes" xml:space="preserve">
          <source>When you add a required field to the form control, its initial status is invalid. This invalid status propagates to the parent form group element, making its status invalid. Access the current status of the form group instance through its &lt;code&gt;status&lt;/code&gt; property.</source>
          <target state="translated">양식 컨트롤에 필수 필드를 추가하면 초기 상태가 유효하지 않습니다. 이 유효하지 않은 상태는 상위 양식 그룹 요소로 전파되어 상태를 유효하지 않게합니다. &lt;code&gt;status&lt;/code&gt; 속성을 통해 양식 그룹 인스턴스의 현재 상태에 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="72131c2667f7d78aa1a158277222438a08f970ea" translate="yes" xml:space="preserve">
          <source>When you add a schematic to the collection, you have to point to it in the collection's schema, and provide configuration files to define options that a user can pass to the command.</source>
          <target state="translated">컬렉션에 회로도를 추가 할 때 컬렉션 스키마에서 회로도를 지정하고 사용자가 명령에 전달할 수있는 옵션을 정의하기위한 구성 파일을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b5fd936cf7003790ec725548e5e7c1c4a0a8937" translate="yes" xml:space="preserve">
          <source>When you add a service provider to the root application injector, it&amp;rsquo;s available throughout the app. Additionally, these providers are also available to all the classes in the app as long they have the lookup token.</source>
          <target state="translated">루트 응용 프로그램 인젝터에 서비스 공급자를 추가하면 앱 전체에서 사용할 수 있습니다. 또한 이러한 공급자는 조회 토큰이있는 한 앱의 모든 클래스에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="792a549ee7899276b88f55470bc47a22c686cdb5" translate="yes" xml:space="preserve">
          <source>When you add or remove a validator at run time, you must call &lt;code&gt;&lt;a href=&quot;abstractcontrol#updateValueAndValidity&quot;&gt;updateValueAndValidity()&lt;/a&gt;&lt;/code&gt; for the new validation to take effect.</source>
          <target state="translated">런타임시 유효성 검사기를 추가하거나 제거 할 때 새 유효성 검사를 적용하려면 &lt;code&gt;&lt;a href=&quot;abstractcontrol#updateValueAndValidity&quot;&gt;updateValueAndValidity()&lt;/a&gt;&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="649fdfd3c25943311b75704030eb1ba2ba9d0a77" translate="yes" xml:space="preserve">
          <source>When you add or remove a validator at run time, you must call &lt;code&gt;updateValueAndValidity()&lt;/code&gt; for the new validation to take effect.</source>
          <target state="translated">런타임에 유효성 검사기를 추가하거나 제거 할 때 새 유효성 검사를 적용하려면 &lt;code&gt;updateValueAndValidity()&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d7cbfc37168ba6757c88e3fb4728e2529d6a7c3c" translate="yes" xml:space="preserve">
          <source>When you add the &lt;code&gt;disabled&lt;/code&gt;&lt;em&gt;attribute&lt;/em&gt;, its presence alone initializes the button's &lt;code&gt;disabled&lt;/code&gt;&lt;em&gt;property&lt;/em&gt; to &lt;code&gt;true&lt;/code&gt; so the button is disabled.</source>
          <target state="translated">&lt;code&gt;disabled&lt;/code&gt; &lt;em&gt;속성&lt;/em&gt; 을 추가하면 해당 &lt;em&gt;속성&lt;/em&gt; 만으로도 버튼의 &lt;code&gt;disabled&lt;/code&gt; &lt;em&gt;속성&lt;/em&gt; 이 &lt;code&gt;true&lt;/code&gt; 로 초기화 되어 버튼이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c0a5c3f1765a8d85f609278eb91d784b7c5f3577" translate="yes" xml:space="preserve">
          <source>When you are ready to deploy your Angular application to a remote server, you have various options for deployment.</source>
          <target state="translated">Angular 응용 프로그램을 원격 서버에 배포 할 준비가되면 다양한 배포 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6b03ce57cce7fb1d00de43901f7939bfd562588" translate="yes" xml:space="preserve">
          <source>When you are using a downgraded Angular component from an AngularJS template, the need may arise to &lt;em&gt;transclude&lt;/em&gt; some content into it. This is also possible. While there is no such thing as transclusion in Angular, there is a very similar concept called &lt;em&gt;content projection&lt;/em&gt;. &lt;code&gt;&lt;a href=&quot;../api/upgrade/static&quot;&gt;upgrade/static&lt;/a&gt;&lt;/code&gt; is able to make these two features interoperate.</source>
          <target state="translated">AngularJS 템플릿에서 다운 그레이드 된 Angular 구성 요소를 사용하는 경우 일부 컨텐츠 를 &lt;em&gt;포함&lt;/em&gt; 시켜야 할 수도 있습니다 . 이것도 가능합니다. Angular에는 transclusion과 같은 것이 없지만 &lt;em&gt;content projection&lt;/em&gt; 이라는 매우 유사한 개념이 &lt;em&gt;있습니다&lt;/em&gt; . &lt;code&gt;&lt;a href=&quot;../api/upgrade/static&quot;&gt;upgrade/static&lt;/a&gt;&lt;/code&gt; 은이 두 기능을 상호 운용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2d88d2533db99d9ce2333dbaed8801d8f09a063" translate="yes" xml:space="preserve">
          <source>When you bootstrap with the &lt;code&gt;AppComponent&lt;/code&gt; class (in &lt;code&gt;main.ts&lt;/code&gt;), Angular looks for a &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; in the &lt;code&gt;index.html&lt;/code&gt;, finds it, instantiates an instance of &lt;code&gt;AppComponent&lt;/code&gt;, and renders it inside the &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">&lt;code&gt;AppComponent&lt;/code&gt; 클래스 ( &lt;code&gt;main.ts&lt;/code&gt; )로 부트 스트랩하면 Angular는 &lt;code&gt;index.html&lt;/code&gt; 에서 &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; 를 찾아서 찾은 다음 &lt;code&gt;AppComponent&lt;/code&gt; 인스턴스를 인스턴스화 하여 &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; 태그 안에 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="45bcb2f61ee4422957ba07b063ee711b3fe965bf" translate="yes" xml:space="preserve">
          <source>When you break application code down into one component per file, you often end up with a project structure with a large number of relatively small files. This is a much neater way to organize things than a small number of large files, but it doesn't work that well if you have to load all those files to the HTML page with &amp;lt;script&amp;gt; tags. Especially when you also have to maintain those tags in the correct order. That's why it's a good idea to start using a &lt;em&gt;module loader&lt;/em&gt;.</source>
          <target state="translated">응용 프로그램 코드를 파일 당 하나의 구성 요소로 나눌 때 종종 상대적으로 작은 파일 수가 많은 프로젝트 구조가 생깁니다. 이 방법은 적은 수의 큰 파일보다 훨씬 깔끔한 방법이지만 &amp;lt;script&amp;gt; 태그를 사용하여 모든 파일을 HTML 페이지에로드해야하는 경우에는 효과가 없습니다. 특히 해당 태그를 올바른 순서로 유지해야 할 때. 그렇기 때문에 &lt;em&gt;모듈 로더&lt;/em&gt; 사용을 시작하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="647d09b43375a7fb70c8eae68df84ef79563f63a" translate="yes" xml:space="preserve">
          <source>When you change the translatable text, the extractor generates a new ID for that translation unit. In most cases a text change would also require a change to the translation. Therefore, using a new ID keeps the text change in sync with translations.</source>
          <target state="translated">번역 가능한 텍스트를 변경하면 추출기가 해당 번역 단위에 대한 새 ID를 생성합니다. 대부분의 경우 텍스트를 변경하려면 번역도 변경해야합니다. 따라서 새 ID를 사용하면 텍스트 변경이 번역과 동기화 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="ce8f1b7eb5f289aae723194ecf63f4999761d3d5" translate="yes" xml:space="preserve">
          <source>When you change the translatable text, the extractor tool generates a new id for that translation unit. You must then update the translation file with the new id.</source>
          <target state="translated">번역 가능한 텍스트를 변경하면 추출기 도구가 해당 번역 단위의 새 ID를 생성합니다. 그런 다음 새 ID로 번역 파일을 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="6f39ca9d36c3ca35868c2a4c88abbba55a005690" translate="yes" xml:space="preserve">
          <source>When you click a different hero name, the read-only mini detail beneath the list reflects the new choice.</source>
          <target state="translated">다른 영웅 이름을 클릭하면 목록 아래의 읽기 전용 미니 세부 정보가 새로운 선택을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="617f657be9899b52fe5f49ef3b6d85c4d25fd73f" translate="yes" xml:space="preserve">
          <source>When you click the &lt;em&gt;Edit&lt;/em&gt; button, this block disappears and the editable form reappears.</source>
          <target state="translated">&lt;em&gt;편집&lt;/em&gt; 버튼 을 클릭하면 이 블록이 사라지고 편집 가능한 양식이 다시 나타납니다.</target>
        </trans-unit>
        <trans-unit id="37af15b64770c912fc52e08bb3cce469c7b29f47" translate="yes" xml:space="preserve">
          <source>When you click the &lt;em&gt;Submit&lt;/em&gt; button, the &lt;code&gt;submitted&lt;/code&gt; flag becomes true and the form disappears as planned.</source>
          <target state="translated">&lt;em&gt;제출&lt;/em&gt; 단추 를 클릭하면 &lt;em&gt;제출 &lt;/em&gt; &lt;code&gt;submitted&lt;/code&gt; 플래그가 true가되고 양식이 계획대로 사라집니다.</target>
        </trans-unit>
        <trans-unit id="179fcf3f9adb197fc99841183b5bfb1796369cdc" translate="yes" xml:space="preserve">
          <source>When you click the &lt;strong&gt;Submit&lt;/strong&gt; button, the &lt;code&gt;submitted&lt;/code&gt; flag becomes true and the form disappears.</source>
          <target state="translated">&lt;strong&gt;제출&lt;/strong&gt; 버튼 을 클릭하면 &lt;strong&gt;제출 &lt;/strong&gt; &lt;code&gt;submitted&lt;/code&gt; 플래그가 true가되고 양식이 사라집니다.</target>
        </trans-unit>
        <trans-unit id="706ebc53dfab50fb06336852da92a5c4919861b5" translate="yes" xml:space="preserve">
          <source>When you configure a budget, the build system warns or reports an error when a given part of the app reaches or exceeds a boundary size that you set.</source>
          <target state="translated">예산을 구성 할 때 앱의 지정된 부분이 설정 한 경계 크기에 도달하거나 초과하면 빌드 시스템에서 오류를 경고하거나보고합니다.</target>
        </trans-unit>
        <trans-unit id="869269037e3115c244f09bd94306aa003338c106" translate="yes" xml:space="preserve">
          <source>When you configure an injector with a provider, you associate that provider with a &lt;a href=&quot;glossary#di-token&quot;&gt;DI token&lt;/a&gt;. The injector maintains an internal &lt;em&gt;token-provider&lt;/em&gt; map that it references when asked for a dependency. The token is the key to the map.</source>
          <target state="translated">인젝터를 제공자와 구성 할 때 해당 제공자를 &lt;a href=&quot;glossary#di-token&quot;&gt;DI 토큰&lt;/a&gt; 과 연관 시키십시오 . 인젝터 는 종속성을 요청할 때 참조 하는 내부 &lt;em&gt;토큰 제공자&lt;/em&gt; 맵을 유지 보수합니다 . 토큰은지도의 열쇠입니다.</target>
        </trans-unit>
        <trans-unit id="bb138bee1b4372f1119c751a572188b350f1deaa" translate="yes" xml:space="preserve">
          <source>When you create a component, it's associated directly with a single view, called the &lt;em&gt;host view&lt;/em&gt;. The host view can be the root of a view hierarchy, which can contain &lt;em&gt;embedded views&lt;/em&gt;, which are in turn the host views of other components. Those components can be in the same NgModule, or can be imported from other NgModules. Views in the tree can be nested to any depth.</source>
          <target state="translated">구성 요소를 작성할 때 구성 요소는 &lt;em&gt;호스트보기&lt;/em&gt; 라는 단일보기와 직접 연관됩니다 . 호스트 뷰는 뷰 계층 구조의 루트 일 수 있으며 , 여기에는 다른 뷰의 구성 요소 인 호스트 뷰가 포함 &lt;em&gt;된 뷰&lt;/em&gt; 가 포함될 수 있습니다 . 이러한 구성 요소는 동일한 NgModule에 있거나 다른 NgModules에서 가져올 수 있습니다. 트리의 뷰는 깊이에 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b86bbfff494f9e2b0676f3988b1ce5be5ce2704e" translate="yes" xml:space="preserve">
          <source>When you create a new blank schematic with the &lt;a href=&quot;schematics-authoring#cli&quot;&gt;Schematics CLI&lt;/a&gt;, the generated entry function is a &lt;em&gt;rule factory&lt;/em&gt;. A &lt;code&gt;RuleFactory&lt;/code&gt; object defines a higher-order function that creates a &lt;code&gt;Rule&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;schematics-authoring#cli&quot;&gt;Schematics CLI&lt;/a&gt; 를 사용하여 새로운 빈 회로도를 작성할 때 생성 된 입력 기능은 &lt;em&gt;규칙 팩토리&lt;/em&gt; 입니다. &lt;code&gt;RuleFactory&lt;/code&gt; 객체는 생성하는 고차 함수를 정의하는 &lt;code&gt;Rule&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a0a0a014fd1121943e6dc450ee300f900c50eba" translate="yes" xml:space="preserve">
          <source>When you create a new workspace or an application you have an option to create them in a strict mode using the &lt;code&gt;--strict&lt;/code&gt; flag.</source>
          <target state="translated">새 작업 공간이나 애플리케이션을 만들 때 &lt;code&gt;--strict&lt;/code&gt; 플래그를 사용하여 엄격 모드에서 만들 수있는 옵션이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="77925d78fe0fa613a0f65a6981a75a2da4ed2cd4" translate="yes" xml:space="preserve">
          <source>When you create a project with the &lt;code&gt;ng new&lt;/code&gt; command, a &lt;code&gt;src/polyfills.ts&lt;/code&gt; configuration file is created as part of your project folder. This file incorporates the mandatory and many of the optional polyfills as JavaScript &lt;code&gt;import&lt;/code&gt; statements.</source>
          <target state="translated">&lt;code&gt;ng new&lt;/code&gt; 명령 으로 프로젝트를 만들면 &lt;code&gt;src/polyfills.ts&lt;/code&gt; 구성 파일이 프로젝트 폴더의 일부로 생성됩니다. 이 파일은 필수 및 많은 선택적 polyfill을 JavaScript &lt;code&gt;import&lt;/code&gt; 문 으로 통합합니다 .</target>
        </trans-unit>
        <trans-unit id="17999f2ec47c4715e77d4f497e7d7048405a374d" translate="yes" xml:space="preserve">
          <source>When you create an Angular library, you can provide and package it with schematics that integrate it with the Angular CLI. With your schematics, your users can use &lt;code&gt;ng add&lt;/code&gt; to install an initial version of your library, &lt;code&gt;ng generate&lt;/code&gt; to create artifacts defined in your library, and &lt;code&gt;ng &lt;a href=&quot;../api/forms/ngmodel#update&quot;&gt;update&lt;/a&gt;&lt;/code&gt; to adjust their project for a new version of your library that introduces breaking changes.</source>
          <target state="translated">Angular 라이브러리를 만들 때 Angular CLI와 통합하는 회로도를 제공하고 패키지화 할 수 있습니다. 회로도를 통해 사용자는 &lt;code&gt;ng add&lt;/code&gt; 를 사용 하여 라이브러리의 초기 버전을 설치하고, &lt;code&gt;ng generate&lt;/code&gt; 를 사용하여 라이브러리에 정의 된 아티팩트를 작성하고, &lt;code&gt;ng &lt;a href=&quot;../api/forms/ngmodel#update&quot;&gt;update&lt;/a&gt;&lt;/code&gt; 를 사용하여 새로운 버전의 라이브러리에 맞게 프로젝트를 조정하여 변경 사항을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fe095f0ae4d4033c7fa3ca8fbd24511377ff5da" translate="yes" xml:space="preserve">
          <source>When you create an Angular library, you can provide and package it with schematics that integrate it with the Angular CLI. With your schematics, your users can use &lt;code&gt;ng add&lt;/code&gt; to install an initial version of your library, &lt;code&gt;ng generate&lt;/code&gt; to create artifacts defined in your library, and &lt;code&gt;ng update&lt;/code&gt; to adjust their project for a new version of your library that introduces breaking changes.</source>
          <target state="translated">Angular 라이브러리를 만들 때 Angular CLI와 통합하는 회로도를 제공하고 패키지화 할 수 있습니다. 회로도와 함께 사용자는 &lt;code&gt;ng add&lt;/code&gt; 를 사용 하여 라이브러리의 초기 버전을 설치하고 &lt;code&gt;ng generate&lt;/code&gt; 를 사용하여 라이브러리에 정의 된 아티팩트를 생성하고 &lt;code&gt;ng update&lt;/code&gt; 를 사용하여 주요 변경 사항을 도입하는 라이브러리의 새 버전에 맞게 프로젝트를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47a9e3bd6a09d48157c28f5e392746f1d86da022" translate="yes" xml:space="preserve">
          <source>When you create new workspaces and projects, you have the option to use Angular's strict mode, which can help you write better, more maintainable code. For more information, see &lt;a href=&quot;strict-mode&quot;&gt;Strict mode&lt;/a&gt;.</source>
          <target state="translated">새로운 작업 공간과 프로젝트를 만들 때 Angular의 엄격 모드를 사용할 수있는 옵션이 있습니다.이 모드는 더 좋고 유지 관리가 쉬운 코드를 작성하는 데 도움이 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;strict-mode&quot;&gt;Strict 모드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c68ffb1e77a004109cf43f654a0f69c5e05d92ae" translate="yes" xml:space="preserve">
          <source>When you declare the variable on an &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt;, the variable refers to a &lt;code&gt;&lt;a href=&quot;../api/core/templateref&quot;&gt;TemplateRef&lt;/a&gt;&lt;/code&gt; instance, which represents the template.</source>
          <target state="translated">&lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 에서 변수를 선언 할 때 변수는 &lt;code&gt;&lt;a href=&quot;../api/core/templateref&quot;&gt;TemplateRef&lt;/a&gt;&lt;/code&gt; 을 나타내는 TemplateRef 인스턴스를 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="0ed0a480cce150ae491407a6f681a39b6dcf0a9e" translate="yes" xml:space="preserve">
          <source>When you define an environment variable &lt;code&gt;http_proxy&lt;/code&gt; or &lt;code&gt;HTTP_PROXY&lt;/code&gt;, an agent is automatically added to pass calls through your corporate proxy when running &lt;code&gt;npm start&lt;/code&gt;.</source>
          <target state="translated">환경 변수 &lt;code&gt;http_proxy&lt;/code&gt; 또는 &lt;code&gt;HTTP_PROXY&lt;/code&gt; 를 정의하면 &lt;code&gt;npm start&lt;/code&gt; 를 실행할 때 회사 프록시를 통해 호출을 전달하도록 에이전트가 자동으로 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="e9e188035d7f17a49c423fc87a612d3f244a912c" translate="yes" xml:space="preserve">
          <source>When you deploy using the Angular CLI build process, you can choose how and when to support differential loading. The &lt;a href=&quot;cli/build&quot;&gt;&lt;code&gt;ng build&lt;/code&gt; CLI command&lt;/a&gt; queries the browser configuration and the configured build target to determine if support for legacy browsers is required, and whether the build should produce the necessary bundles used for differential loading.</source>
          <target state="translated">Angular CLI 빌드 프로세스를 사용하여 배포 할 때 차등로드를 지원하는 방법과시기를 선택할 수 있습니다. &lt;a href=&quot;cli/build&quot;&gt; &lt;code&gt;ng build&lt;/code&gt; CLI 명령은&lt;/a&gt; 기존 브라우저에 대한 지원이 필요한 경우인지 여부를 결정하기 위해 브라우저 구성 및 구성 빌드 타겟을 조회하고 빌드는 차동로드에 사용되는 필요한 번들을 생성할지 여부를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e26780ada0ccc3b637f4b01f21aad05ca8123bc7" translate="yes" xml:space="preserve">
          <source>When you do, set the &lt;code&gt;class&lt;/code&gt; to &lt;code&gt;avoid&lt;/code&gt;. The code snippet will be framed in bright red to grab the reader's attention.</source>
          <target state="translated">그렇게 할 때 &lt;code&gt;class&lt;/code&gt; 를 &lt;code&gt;avoid&lt;/code&gt; 하도록 설정하십시오 . 코드 스 니펫은 독자의주의를 끌기 위해 밝은 빨간색으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ea188763675648ea90f96f233e7a9e4f9446785b" translate="yes" xml:space="preserve">
          <source>When you downgrade an Angular component and then use it from AngularJS, the component's inputs will be watched using AngularJS change detection. When those inputs change, the corresponding properties in the component are set. You can also hook into the changes by implementing the &lt;a href=&quot;../api/core/onchanges&quot;&gt;OnChanges&lt;/a&gt; interface in the component, just like you could if it hadn't been downgraded.</source>
          <target state="translated">Angular 구성 요소를 다운 그레이드 한 다음 AngularJS에서 사용하면 AngularJS 변경 감지를 사용하여 구성 요소의 입력을 감시합니다. 이러한 입력이 변경되면 구성 요소의 해당 속성이 설정됩니다. 다운 그레이드되지 않은 경우와 마찬가지로 구성 요소에서 &lt;a href=&quot;../api/core/onchanges&quot;&gt;OnChanges&lt;/a&gt; 인터페이스를 구현하여 변경 사항에 연결할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41408c48441c9f26930f9bc3ddb54582bdabcc94" translate="yes" xml:space="preserve">
          <source>When you enable &lt;code&gt;strictTemplates&lt;/code&gt; and the TypeScript flag &lt;code&gt;strictNullChecks&lt;/code&gt;, typecheck errors may occur for certain situations that may not easily be avoided. For example:</source>
          <target state="translated">&lt;code&gt;strictTemplates&lt;/code&gt; 및 TypeScript 플래그 &lt;code&gt;strictNullChecks&lt;/code&gt; 를 활성화하면 쉽게 피할 수없는 특정 상황에서 유형 검사 오류가 발생할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="4453dc4621733c6328eda35ed3ad7fa789798ece" translate="yes" xml:space="preserve">
          <source>When you enable production builds via &lt;code&gt;--prod&lt;/code&gt; command line flag, the runtime production mode is enabled as well.</source>
          <target state="translated">&lt;code&gt;--prod&lt;/code&gt; 명령 줄 플래그 를 통해 프로덕션 빌드를 활성화 하면 런타임 프로덕션 모드도 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="ecd81edef99e4127623ea133242d8979bb3861fc" translate="yes" xml:space="preserve">
          <source>When you enable the &lt;code&gt;enableTracing&lt;/code&gt; option, Angular logs these events to the console. For an example of filtering router navigation events, see the &lt;a href=&quot;observables-in-angular#router&quot;&gt;router section&lt;/a&gt; of the &lt;a href=&quot;observables-in-angular&quot;&gt;Observables in Angular&lt;/a&gt; guide.</source>
          <target state="translated">&lt;code&gt;enableTracing&lt;/code&gt; 옵션 을 활성화하면 Angular는 이러한 이벤트를 콘솔에 기록합니다. 라우터 탐색 이벤트를 필터링하는 예 는 &lt;a href=&quot;observables-in-angular&quot;&gt;Observable in Angular&lt;/a&gt; 가이드 의 &lt;a href=&quot;observables-in-angular#router&quot;&gt;라우터 섹션&lt;/a&gt; 을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="15be4fefbe5b03a93674980ad70988d4378dda38" translate="yes" xml:space="preserve">
          <source>When you first bring it up, the classes indicate that it has a valid value, that the value has not been changed since initialization or reset, and that the control has not been visited since initialization or reset.</source>
          <target state="translated">처음 가져올 때 클래스는 유효한 값이 있고 초기화 또는 재설정 이후 값이 변경되지 않았으며 초기화 또는 재설정 이후에 컨트롤을 방문하지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ec9b4238aa6d95593d6729819db45182901c2e3e" translate="yes" xml:space="preserve">
          <source>When you generate a library using the CLI (with a command such as &lt;code&gt;ng generate library my-lib&lt;/code&gt;), the generated files go into the projects/ folder of the workspace. For more information about creating your own libraries, see &lt;a href=&quot;creating-libraries&quot;&gt;Creating Libraries&lt;/a&gt;.</source>
          <target state="translated">CLI를 사용하여 라이브러리를 생성 할 때 ( &lt;code&gt;ng generate library my-lib&lt;/code&gt; 와 같은 명령으로 ) 생성 된 파일은 작업 공간의 프로젝트 / 폴더로 이동합니다. 자체 라이브러리 작성에 대한 자세한 정보는 라이브러리 &lt;a href=&quot;creating-libraries&quot;&gt;작성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="21ca8467ebf84648be93bc0fe65dea51105c81bc" translate="yes" xml:space="preserve">
          <source>When you generate a new library, the workspace configuration file, &lt;code&gt;angular.json&lt;/code&gt;, is updated with a project of type &lt;code&gt;library&lt;/code&gt;.</source>
          <target state="translated">새 라이브러리를 생성하면 작업 공간 구성 파일 &lt;code&gt;angular.json&lt;/code&gt; 이 &lt;code&gt;library&lt;/code&gt; 유형의 프로젝트로 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="7079e1112b4fbb0c4d85e377cb94f0248ab2af7a" translate="yes" xml:space="preserve">
          <source>When you generate an Angular app with the Angular CLI, the &lt;code&gt;app.component.html&lt;/code&gt; file is the default template containing placeholder HTML.</source>
          <target state="translated">Angular CLI를 사용하여 Angular 앱을 생성 할 때 &lt;code&gt;app.component.html&lt;/code&gt; 파일은 자리 표시 자 HTML을 포함하는 기본 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="08d3c63af033a63e4f9ede8b61e4f47f231216f5" translate="yes" xml:space="preserve">
          <source>When you generate the StackBlitz example apps that accompany the tutorials, StackBlitz creates the starter files and mock data for you. The files you'll use throughout the tutorials are in the &lt;code&gt;src&lt;/code&gt; folder of the StackBlitz example apps.</source>
          <target state="translated">자습서와 함께 제공되는 StackBlitz 예제 앱을 생성하면 StackBlitz가 시작 파일과 모의 데이터를 생성합니다. 자습서 전체에서 사용할 파일 은 StackBlitz 예제 앱 의 &lt;code&gt;src&lt;/code&gt; 폴더에 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e1c9f5c28d7a54853707acbe257fcdd9a4515d0" translate="yes" xml:space="preserve">
          <source>When you have observed the effects, you can delete the &lt;code&gt;{{diagnostic}}&lt;/code&gt; binding.</source>
          <target state="translated">효과를 관찰 한 후 &lt;code&gt;{{diagnostic}}&lt;/code&gt; 바인딩을 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c3de61ed943055bf0458f7d0abfbe8083dac68f" translate="yes" xml:space="preserve">
          <source>When you hide an element, that element and all of its descendants remain in the DOM. All components for those elements stay in memory and Angular may continue to check for changes. You could be holding onto considerable computing resources and degrading performance unnecessarily.</source>
          <target state="translated">요소를 숨기면 해당 요소와 모든 하위 요소가 DOM에 남아 있습니다. 해당 요소의 모든 구성 요소는 메모리에 유지되며 Angular는 계속 변경 사항을 확인할 수 있습니다. 상당한 컴퓨팅 리소스를 보유하고 불필요하게 성능을 저하시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="410ecc95479ff5928d45d83d664c30ac0fed7800" translate="yes" xml:space="preserve">
          <source>When you import an NgModule, Angular adds the module's service providers (the contents of its &lt;code&gt;providers&lt;/code&gt; list) to the application root injector.</source>
          <target state="translated">NgModule을 가져 오면 Angular는 모듈의 서비스 공급자 ( &lt;code&gt;providers&lt;/code&gt; 목록 의 내용 )를 응용 프로그램 루트 인젝터에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d8644a4f230a744f101351dd00d0bf4a1e1125a5" translate="yes" xml:space="preserve">
          <source>When you import something from a library in an Angular app, Angular looks for a mapping between the library name and a location on disk. When you install a library package, the mapping is in the &lt;code&gt;node_modules&lt;/code&gt; folder. When you build your own library, it has to find the mapping in your &lt;code&gt;tsconfig&lt;/code&gt; paths.</source>
          <target state="translated">Angular 앱의 라이브러리에서 무언가를 가져 오면 Angular는 라이브러리 이름과 디스크 위치 간의 매핑을 찾습니다. 라이브러리 패키지를 설치할 때 맵핑은 &lt;code&gt;node_modules&lt;/code&gt; 폴더에 있습니다. 자체 라이브러리를 빌드 할 때 &lt;code&gt;tsconfig&lt;/code&gt; 경로 에서 맵핑을 찾아야합니다 .</target>
        </trans-unit>
        <trans-unit id="d289d612e8342acce13b442e36b3c7c30d1c6461" translate="yes" xml:space="preserve">
          <source>When you imported the &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; in your component, Angular automatically created and attached an &lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt; directive to the &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tag in the template (because &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; has the selector &lt;code&gt;form&lt;/code&gt; that matches &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; elements).</source>
          <target state="translated">구성 요소 에서 &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; 을 가져 오면 Angular는 &lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt; 지시문을 템플릿 의 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 태그에 자동으로 만들어 첨부했습니다 ( &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; 에는 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 요소 와 일치 하는 선택기 &lt;code&gt;form&lt;/code&gt; 이 있기 때문 ).</target>
        </trans-unit>
        <trans-unit id="5d0bf5343123ad54489af22b2a94d022755e308e" translate="yes" xml:space="preserve">
          <source>When you internationalize with the AOT compiler, you must pre-build a separate application package for each language and serve the appropriate package based on either server-side language detection or URL parameters.</source>
          <target state="translated">AOT 컴파일러를 사용하여 국제화 할 때는 각 언어마다 별도의 응용 프로그램 패키지를 미리 빌드하고 서버 측 언어 감지 또는 URL 매개 변수를 기반으로 적절한 패키지를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="362d06f664aaa8348af755e5fbfb12b4e2256623" translate="yes" xml:space="preserve">
          <source>When you know for certain that a &lt;code&gt;HeroDetailComponent&lt;/code&gt; instance will &lt;em&gt;never, never, ever&lt;/em&gt; be re-used, you can simplify the code with the &lt;em&gt;snapshot&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;HeroDetailComponent&lt;/code&gt; 인스턴스가 &lt;em&gt;절대&lt;/em&gt; 재사용 &lt;em&gt;되지 않을&lt;/em&gt; 것이라는 것을 확실히 알고 있으면 &lt;em&gt;snapshot으로&lt;/em&gt; 코드를 단순화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be208372c1c3aafed8ae3aa23894046a805dca25" translate="yes" xml:space="preserve">
          <source>When you know for certain that a &lt;code&gt;HeroDetailComponent&lt;/code&gt; instance will never be re-used, you can use &lt;code&gt;snapshot&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HeroDetailComponent&lt;/code&gt; 인스턴스가 재사용되지 않는다는 것을 확실히 알고 있다면 &lt;code&gt;snapshot&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5fecd6f95f828bcccda31df86790f8c129c7ea0" translate="yes" xml:space="preserve">
          <source>When you migrate from AngularJS to Angular you will want to move as much responsibility as possible to Angular, so that you can take advantage of new APIs. To help with the transition, Angular provides the &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/locationupgrademodule&quot;&gt;LocationUpgradeModule&lt;/a&gt;&lt;/code&gt;. This module enables a &lt;em&gt;unified&lt;/em&gt; location service that shifts responsibilities from the AngularJS &lt;code&gt;$location&lt;/code&gt; service to the Angular &lt;code&gt;&lt;a href=&quot;../api/common/location&quot;&gt;Location&lt;/a&gt;&lt;/code&gt; service.</source>
          <target state="translated">AngularJS에서 Angular로 마이그레이션 할 때 가능한 한 많은 책임을 Angular로 이동하여 새 API를 활용할 수 있습니다. 전환을 돕기 위해 Angular는 &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/locationupgrademodule&quot;&gt;LocationUpgradeModule&lt;/a&gt;&lt;/code&gt; 을 제공합니다 . 이 모듈은 책임을 AngularJS &lt;code&gt;$location&lt;/code&gt; 서비스에서 Angular &lt;code&gt;&lt;a href=&quot;../api/common/location&quot;&gt;Location&lt;/a&gt;&lt;/code&gt; 서비스 로 전환 하는 &lt;em&gt;통합&lt;/em&gt; 위치 서비스를 가능하게합니다 .</target>
        </trans-unit>
        <trans-unit id="e14e60be15cfb3e29e23e3adf7c79ee29e0d7947" translate="yes" xml:space="preserve">
          <source>When you move the source (inevitable), you remember to move the test.</source>
          <target state="translated">소스를 이동할 때 (필연적) 테스트를 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf36cbc1f993165efdb0e64fe01fb194b2a20a39" translate="yes" xml:space="preserve">
          <source>When you need that module&amp;rsquo;s code in another module, use an &lt;code&gt;import&lt;/code&gt; statement as follows:</source>
          <target state="translated">다른 모듈에서 해당 모듈의 코드가 필요한 경우 다음과 같이 &lt;code&gt;import&lt;/code&gt; 문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fe438ebbcd8a35cf245928a1c983b9efddf4900e" translate="yes" xml:space="preserve">
          <source>When you pass an &lt;code&gt;&lt;a href=&quot;../api/core/ngmodulefactory&quot;&gt;NgModuleFactory&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; uses it to instantiate the module using &lt;a href=&quot;../api/platform-browser/platformbrowser&quot;&gt;platformBrowser&lt;/a&gt;'s &lt;a href=&quot;../api/core/platformref#bootstrapModuleFactory&quot;&gt;bootstrapModuleFactory()&lt;/a&gt;, which is compatible with ahead-of-time (AOT) compilation. AOT compilation helps make your apps load faster. For more about AOT and how to create an &lt;code&gt;&lt;a href=&quot;../api/core/ngmodulefactory&quot;&gt;NgModuleFactory&lt;/a&gt;&lt;/code&gt;, see the &lt;a href=&quot;aot-compiler&quot;&gt;Ahead-of-Time Compilation&lt;/a&gt; guide.</source>
          <target state="translated">당신이 통과하면 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodulefactory&quot;&gt;NgModuleFactory&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; 를 사용하여 모듈을 인스턴스화하는 데 사용 &lt;a href=&quot;../api/platform-browser/platformbrowser&quot;&gt;platformBrowser&lt;/a&gt; 의 &lt;a href=&quot;../api/core/platformref#bootstrapModuleFactory&quot;&gt;bootstrapModuleFactory ()&lt;/a&gt; 앞서-의 시간 (AOT) 컴파일과 호환됩니다. AOT 컴파일은 앱을 더 빠르게로드하는 데 도움이됩니다. AOT 및 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodulefactory&quot;&gt;NgModuleFactory&lt;/a&gt;&lt;/code&gt; 작성 방법에 대한 자세한 내용은 &lt;a href=&quot;aot-compiler&quot;&gt;Ahead-of-Time Compilation&lt;/a&gt; 안내서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="21d13688782c8b5894b32af1b23cd5c8e43f6163" translate="yes" xml:space="preserve">
          <source>When you pass an array of steps to a &lt;code&gt;&lt;a href=&quot;transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; call, the steps run sequentially by default. Compare this to the &lt;code&gt;&lt;a href=&quot;group&quot;&gt;group()&lt;/a&gt;&lt;/code&gt; call, which runs animation steps in parallel.</source>
          <target state="translated">단계 배열을 &lt;code&gt;&lt;a href=&quot;transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; 호출에 전달하면 단계가 기본적으로 순차적으로 실행됩니다. 이것을 애니메이션 단계를 병렬로 실행 하는 &lt;code&gt;&lt;a href=&quot;group&quot;&gt;group()&lt;/a&gt;&lt;/code&gt; 호출과 비교 하십시오.</target>
        </trans-unit>
        <trans-unit id="5ad1c2e84d6f136b6a8a42ad3ccb44378641d0aa" translate="yes" xml:space="preserve">
          <source>When you pass an interface as a type parameter to the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#get&quot;&gt;HttpClient.get()&lt;/a&gt;&lt;/code&gt; method, use the RxJS &lt;code&gt;map&lt;/code&gt; operator to transform the response data as needed by the UI. You can then pass the transformed data to the &lt;a href=&quot;../api/common/asyncpipe&quot;&gt;async pipe&lt;/a&gt;.</source>
          <target state="translated">인터페이스를 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#get&quot;&gt;HttpClient.get()&lt;/a&gt;&lt;/code&gt; 메소드에 유형 매개 변수로 전달할 때 RxJS &lt;code&gt;map&lt;/code&gt; 연산자를 사용 하여 UI에 필요한 응답 데이터를 변환하십시오. 그런 다음 변환 된 데이터를 &lt;a href=&quot;../api/common/asyncpipe&quot;&gt;비동기 파이프&lt;/a&gt; 로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b27000fba626df657879cafff92fc4e854adb82" translate="yes" xml:space="preserve">
          <source>When you pass an interface as a type parameter to the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#get&quot;&gt;HttpClient.get()&lt;/a&gt;&lt;/code&gt; method, you can use the &lt;a href=&quot;rx-library#operators&quot;&gt;RxJS &lt;code&gt;map&lt;/code&gt; operator&lt;/a&gt; to transform the response data as needed by the UI. You can then pass the transformed data to the &lt;a href=&quot;../api/common/asyncpipe&quot;&gt;async pipe&lt;/a&gt;.</source>
          <target state="translated">인터페이스를 유형 매개 변수로 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#get&quot;&gt;HttpClient.get()&lt;/a&gt;&lt;/code&gt; 메소드에 &lt;a href=&quot;rx-library#operators&quot;&gt;전달할 &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 때 RxJS 맵 연산자 를 사용 하여 UI에서 필요에 따라 응답 데이터를 변환 할 수 있습니다 . 그런 다음 변환 된 데이터를 &lt;a href=&quot;../api/common/asyncpipe&quot;&gt;비동기 파이프&lt;/a&gt; 로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2307ff4288c2d124a3fdc1efa06e1678b46c8e2" translate="yes" xml:space="preserve">
          <source>When you provide services in a component, that service is available via the &lt;code&gt;ElementInjector&lt;/code&gt; at that component instance. It may also be visible at child component/directives based on visibility rules described in the &lt;a href=&quot;hierarchical-dependency-injection#resolution-rules&quot;&gt;resolution rules&lt;/a&gt; section.</source>
          <target state="translated">컴포넌트에서 서비스를 제공하면 해당 컴포넌트 인스턴스 의 &lt;code&gt;ElementInjector&lt;/code&gt; 를 통해 해당 서비스를 사용할 수 있습니다 . &lt;a href=&quot;hierarchical-dependency-injection#resolution-rules&quot;&gt;해결 규칙&lt;/a&gt; 섹션에 설명 된 가시성 규칙을 기반으로 하위 구성 요소 / 지시문에서 표시 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56f91c3af039a87e2e5b1894a0d410dde809e81e" translate="yes" xml:space="preserve">
          <source>When you provide services in the component class, services are visible within the &lt;code&gt;ElementInjector&lt;/code&gt; tree relative to where and how you provide those services.</source>
          <target state="translated">컴포넌트 클래스에서 서비스 를 제공하면 서비스를 제공하는 위치 및 방법과 관련 하여 &lt;code&gt;ElementInjector&lt;/code&gt; 트리 내에서 서비스를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8852b03eafeb6d489c8a0d7dc06b14852ad1e11c" translate="yes" xml:space="preserve">
          <source>When you provide the service at the root level, Angular creates a single, shared instance of &lt;code&gt;HeroService&lt;/code&gt; and injects into any class that asks for it. Registering the provider in the &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;&lt;/code&gt; metadata also allows Angular to optimize an app by removing the service if it turns out not to be used after all.</source>
          <target state="translated">루트 수준에서 서비스를 제공하면 Angular는 하나의 공유 &lt;code&gt;HeroService&lt;/code&gt; 인스턴스를 생성 하고이를 요청하는 모든 클래스에 주입합니다. &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;&lt;/code&gt; 메타 데이터에 공급자를 등록 하면 Angular는 서비스를 전혀 사용하지 않는 경우 서비스를 제거하여 앱을 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f953905bda44980a6a9f0d5b1b3e121019580b78" translate="yes" xml:space="preserve">
          <source>When you provide the service at the root level, Angular creates a single, shared instance of &lt;code&gt;HeroService&lt;/code&gt; and injects it into any class that asks for it. Registering the provider in the &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; metadata also allows Angular to optimize an app by removing the service from the compiled app if it isn't used.</source>
          <target state="translated">루트 수준에서 서비스를 제공하면 Angular는 하나의 공유 &lt;code&gt;HeroService&lt;/code&gt; 인스턴스를 생성하여 이를 요청하는 모든 클래스에 주입합니다. &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; 메타 데이터에 공급자를 등록 하면 Angular는 컴파일 된 앱이 서비스를 사용하지 않는 경우 서비스를 제거하여 앱을 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b343fcf4d13bc8d991f156872899c3099cdb142c" translate="yes" xml:space="preserve">
          <source>When you register a provider at the component level, you get a new instance of the service with each new instance of that component. At the component level, register a service provider in the &lt;code&gt;providers&lt;/code&gt; property of the &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; metadata.</source>
          <target state="translated">컴포넌트 레벨에서 제공자를 등록하면 해당 컴포넌트의 새 인스턴스마다 서비스의 새 인스턴스가 제공됩니다. 컴포넌트 레벨에서 서비스 제공자를 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt; () 메타 데이터 의 &lt;code&gt;providers&lt;/code&gt; 특성에 등록하십시오 .</target>
        </trans-unit>
        <trans-unit id="46450f6e014a67295680762b08aaaf21e1fc79bc" translate="yes" xml:space="preserve">
          <source>When you register a provider with a &lt;a href=&quot;architecture-modules&quot;&gt;specific NgModule&lt;/a&gt;, the same instance of a service is available to all components in that NgModule. To register at this level, use the &lt;code&gt;providers&lt;/code&gt; property of the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; decorator,</source>
          <target state="translated">&lt;a href=&quot;architecture-modules&quot;&gt;특정 NgModule에&lt;/a&gt; 공급자를 등록하면 해당 NgModule의 모든 구성 요소에서 동일한 서비스 인스턴스를 사용할 수 있습니다. 이 레벨에서 등록하려면 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt; () 데코레이터 의 &lt;code&gt;providers&lt;/code&gt; 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc9b91912b8770f2ea04045401c1cd3c11fd358d" translate="yes" xml:space="preserve">
          <source>When you register a provider with a &lt;a href=&quot;architecture-modules&quot;&gt;specific NgModule&lt;/a&gt;, the same instance of a service is available to all components in that NgModule. To register at this level, use the &lt;code&gt;providers&lt;/code&gt; property of the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; decorator.</source>
          <target state="translated">&lt;a href=&quot;architecture-modules&quot;&gt;특정 NgModule에&lt;/a&gt; 공급자를 등록하면 해당 NgModule의 모든 구성 요소에서 동일한 서비스 인스턴스를 사용할 수 있습니다. 이 수준에서 등록하려면 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt; () 데코레이터 의 &lt;code&gt;providers&lt;/code&gt; 속성을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="162521642a27b1e5827c9301cf0ed78f5244aa15" translate="yes" xml:space="preserve">
          <source>When you remove a hero from the list, it appears to fly out to the right.</source>
          <target state="translated">목록에서 영웅을 제거하면 오른쪽으로 날아가는 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="4f1ba5f6a26ffaff14e70574d6d3162b35b43f43" translate="yes" xml:space="preserve">
          <source>When you rename the source file (inevitable), you remember to rename the test file.</source>
          <target state="translated">소스 파일의 이름을 바꿀 때 (필연적) 테스트 파일의 이름을 바꾸어야합니다.</target>
        </trans-unit>
        <trans-unit id="76143769b73c5f43fc6f3a3c4f5be082f00a281f" translate="yes" xml:space="preserve">
          <source>When you resolve an instance of &lt;code&gt;Car&lt;/code&gt; at the deepest component (C), its injector produces an instance of &lt;code&gt;Car&lt;/code&gt; resolved by injector (C) with an &lt;code&gt;Engine&lt;/code&gt; resolved by injector (B) and &lt;code&gt;Tires&lt;/code&gt; resolved by the root injector (A).</source>
          <target state="translated">가장 깊은 구성 요소 (C)에서 &lt;code&gt;Car&lt;/code&gt; 인스턴스를 해결하면 인젝터는 인젝터 (B)로 분석 된 &lt;code&gt;Engine&lt;/code&gt; 과 루트 인젝터 (A)로 해결 된 &lt;code&gt;Tires&lt;/code&gt; 로 인젝터 (C)로 해결 된 &lt;code&gt;Car&lt;/code&gt; 인스턴스를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="c7af032d22de01c80130fb9a41ddd3718e7e974c" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;ng new my-first-project&lt;/code&gt; a new folder, named &lt;code&gt;my-first-project&lt;/code&gt;, will be created in the current working directory. Since you want to be able to create files inside that folder, make sure you have sufficient rights in the current working directory before running the command.</source>
          <target state="translated">실행할 때 &lt;code&gt;ng new my-first-project&lt;/code&gt; 라는 이름의 새 폴더 &lt;code&gt;my-first-project&lt;/code&gt; 현재 작업 디렉토리에 생성됩니다. 해당 폴더 내에 파일을 작성할 수 있으려면 명령을 실행하기 전에 현재 작업 디렉토리에 대한 충분한 권한이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="83e295e43de72a208244365d9e3ac5fc39b98c0d" translate="yes" xml:space="preserve">
          <source>When you run the &lt;a href=&quot;cli/build&quot;&gt;&lt;code&gt;ng build&lt;/code&gt;&lt;/a&gt; (build only) or &lt;a href=&quot;cli/serve&quot;&gt;&lt;code&gt;ng serve&lt;/code&gt;&lt;/a&gt; (build and serve locally) CLI commands, the type of compilation (JIT or AOT) depends on the value of the &lt;code&gt;aot&lt;/code&gt; property in your build configuration specified in &lt;code&gt;angular.json&lt;/code&gt;. By default, &lt;code&gt;aot&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; for new CLI apps.</source>
          <target state="translated">당신이 실행하면 &lt;a href=&quot;cli/build&quot;&gt; &lt;code&gt;ng build&lt;/code&gt; &lt;/a&gt; (전용 빌드) 또는 &lt;a href=&quot;cli/serve&quot;&gt; &lt;code&gt;ng serve&lt;/code&gt; &lt;/a&gt; (빌드 및 로컬 제공) CLI 명령을, 컴파일의 종류 (JIT 또는 AOT)는의 값에 따라 &lt;code&gt;aot&lt;/code&gt; 에 지정된 빌드 구성의 특성 &lt;code&gt;angular.json&lt;/code&gt; . 기본적으로 &lt;code&gt;aot&lt;/code&gt; 는 새 CLI 앱에 대해 &lt;code&gt;true&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="948f7a7d608dac5f777ed3899bcfbc54038d306b" translate="yes" xml:space="preserve">
          <source>When you run the &lt;em&gt;AfterView&lt;/em&gt; sample, notice how frequently Angular calls &lt;code&gt;&lt;a href=&quot;../api/core/afterviewchecked&quot;&gt;AfterViewChecked&lt;/a&gt;()&lt;/code&gt;-often when there are no changes of interest. Be very careful about how much logic or computation you put into one of these methods.</source>
          <target state="translated">&lt;em&gt;AfterView&lt;/em&gt; 샘플 을 실행할 때 Angular가 &lt;code&gt;&lt;a href=&quot;../api/core/afterviewchecked&quot;&gt;AfterViewChecked&lt;/a&gt;()&lt;/code&gt; 얼마나 자주 호출 하는지 확인하십시오 . 이러한 방법 중 하나에 얼마나 많은 논리 또는 계산을 넣는 지에 대해 매우주의하십시오.</target>
        </trans-unit>
        <trans-unit id="5ede23bce1607d06e6f4c7d8342b9df484546033" translate="yes" xml:space="preserve">
          <source>When you run this command, the CLI installs the necessary Angular npm packages and other dependencies in a new workspace, with a root-level application named &lt;em&gt;my-project&lt;/em&gt;. The workspace root folder contains various support and configuration files, and a README file with generated descriptive text that you can customize.</source>
          <target state="translated">이 명령을 실행하면 CLI는 루트 레벨 응용 프로그램 &lt;em&gt;my-project를 사용&lt;/em&gt; 하여 필요한 Angular npm 패키지 및 기타 종속성을 새 작업 공간에 설치합니다 . 작업 공간 루트 폴더에는 다양한 지원 및 구성 파일과 사용자 정의 할 수있는 설명 텍스트가있는 README 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a6793cd65bbd67485fe71ef010251834a34604e" translate="yes" xml:space="preserve">
          <source>When you specify a custom ID, the extractor generates a translation unit with the custom ID:</source>
          <target state="translated">사용자 지정 ID를 지정하면 추출기가 사용자 지정 ID로 번역 단위를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3f89db8d780edd6ff5fede7d7a2e6d3d19f61f83" translate="yes" xml:space="preserve">
          <source>When you specify a custom id, the extractor tool and compiler generate a translation unit with that custom id.</source>
          <target state="translated">사용자 정의 ID를 지정하면 추출기 도구 및 컴파일러가 해당 사용자 정의 ID로 변환 단위를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8ff5318340747063c6cfc4c93e9fb64e1d986e7b" translate="yes" xml:space="preserve">
          <source>When you start to upgrade components and their templates to Angular, you'll make more changes because the E2E tests have matchers that are specific to AngularJS. For PhoneCat you need to make the following changes in order to make things work with Angular:</source>
          <target state="translated">구성 요소 및 해당 템플릿을 Angular로 업그레이드하기 시작하면 E2E 테스트에 AngularJS와 일치하는 일치 항목이 있으므로 더 많은 변경을 수행하게됩니다. PhoneCat의 경우 Angular에서 작동하도록 다음과 같이 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="6527e816afc32aa43b4cbfafcff471db1bf82256" translate="yes" xml:space="preserve">
          <source>When you trigger a completion list within a template, the editor first parses the template into an HTML &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;abstract syntax tree (AST)&lt;/a&gt;. The Angular compiler interprets that tree to determine the context: which module the template is part of, the current scope, the component selector, and where your cursor is in the template AST. It can then determine the symbols that could potentially be at that position..</source>
          <target state="translated">템플리트 내에서 완료 목록을 트리거하면 편집기는 먼저 템플리트를 HTML &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;추상 구문 트리 (AST)&lt;/a&gt; 로 구문 분석합니다 . Angular 컴파일러는 해당 트리를 해석하여 컨텍스트를 결정합니다. 템플릿이 속한 모듈, 현재 범위, 구성 요소 선택기 및 커서가 템플릿 AST에있는 위치. 그런 다음 해당 위치에있을 수있는 기호를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab73fe04628483ac0b3d2a9834dda0390777b014" translate="yes" xml:space="preserve">
          <source>When you try this,</source>
          <target state="translated">이걸 시도하면</target>
        </trans-unit>
        <trans-unit id="caa532613dfbcc5fb88bd71c451bea3780c7f5bb" translate="yes" xml:space="preserve">
          <source>When you update Angular to a new version, you need to make sure that any libraries you are using are current. If libraries have interdependencies, you might have to update them in a particular order. See the &lt;a href=&quot;https://update.angular.io/&quot;&gt;Angular Update Guide&lt;/a&gt; for help.</source>
          <target state="translated">Angular를 새 버전으로 업데이트 할 때는 사용중인 라이브러리가 최신 버전인지 확인해야합니다. 라이브러리에 상호 종속성이있는 경우 특정 순서로 업데이트해야 할 수 있습니다. 도움이 필요 하면 &lt;a href=&quot;https://update.angular.io/&quot;&gt;Angular Update Guide&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa18a12f3c0ee4bf831ccbbc34f0186668397d03" translate="yes" xml:space="preserve">
          <source>When you use &lt;a href=&quot;aot-compiler&quot;&gt;AOT compilation&lt;/a&gt;, you can control how your application is compiled by specifying &lt;em&gt;template&lt;/em&gt; compiler options in the &lt;a href=&quot;typescript-configuration&quot;&gt;TypeScript configuration file&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;aot-compiler&quot;&gt;AOT 컴파일&lt;/a&gt; 을 사용 하면 &lt;a href=&quot;typescript-configuration&quot;&gt;TypeScript 구성 파일&lt;/a&gt; 에 &lt;em&gt;템플릿&lt;/em&gt; 컴파일러 옵션 을 지정하여 응용 프로그램이 컴파일되는 방식을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="427748cf35ba8629915556d00d80d9456785d7fd" translate="yes" xml:space="preserve">
          <source>When you use &lt;a href=&quot;aot-compiler&quot;&gt;AoT compilation&lt;/a&gt;, you can control how your application is compiled by specifying &lt;em&gt;template&lt;/em&gt; compiler options in the &lt;code&gt;tsconfig.json&lt;/code&gt;&lt;a href=&quot;typescript-configuration&quot;&gt;TypeScript configuration file&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;aot-compiler&quot;&gt;AoT 컴파일&lt;/a&gt; 을 사용 하는 경우 &lt;code&gt;tsconfig.json&lt;/code&gt; &lt;a href=&quot;typescript-configuration&quot;&gt;TypeScript 구성 파일&lt;/a&gt; 에서 &lt;em&gt;템플릿&lt;/em&gt; 컴파일러 옵션 을 지정하여 애플리케이션 컴파일 방법을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d76d4cdd08e8ca0fc27a2d6c81a99fd7dd8f163" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt;, edit these parts of your app:</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; 을 사용할 때 앱의 다음 부분을 편집하십시오.</target>
        </trans-unit>
        <trans-unit id="a1d14249763aab18fdb2a4c4fab31db25f9743c4" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;[(&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;)]&lt;/code&gt; on an element, you must define a &lt;code&gt;name&lt;/code&gt; attribute for that element. Angular uses the assigned name to register the element with the &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; directive attached to the parent &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;[(&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;)]&lt;/code&gt; 요소에, 당신은 정의해야합니다 &lt;code&gt;name&lt;/code&gt; 해당 요소의 속성을. Angular는 할당 된 이름을 사용하여 부모 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 요소에 연결된 &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; 지시문에 요소를 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="4580e5ffc3fd526fbaef265fb610c52859c60f63" translate="yes" xml:space="preserve">
          <source>When you use a class this way, it's called a &lt;em&gt;class interface&lt;/em&gt;.</source>
          <target state="translated">이런 방식으로 클래스를 사용하는 경우이를 &lt;em&gt;클래스 인터페이스&lt;/em&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="f94a253b102233220fd281a30bb6f39b56a66d5a" translate="yes" xml:space="preserve">
          <source>When you use an SVG as the template, you are able to use directives and bindings just like with HTML templates. This means that you will be able to dynamically generate interactive graphics.</source>
          <target state="translated">SVG를 템플릿으로 사용하면 HTML 템플릿과 마찬가지로 지시문과 바인딩을 사용할 수 있습니다. 즉, 대화식 그래픽을 동적으로 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b5db936a4f10347d77d439673f77743a5c795d4" translate="yes" xml:space="preserve">
          <source>When you use an editor with a language service, the editor starts a separate language-service process and communicates with it through an &lt;a href=&quot;https://en.wikipedia.org/wiki/Remote_procedure_call&quot;&gt;RPC&lt;/a&gt;, using the &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/&quot;&gt;Language Server Protocol&lt;/a&gt;. When you type into the editor, the editor sends information to the language-service process to track the state of your project.</source>
          <target state="translated">언어 서비스와 함께 편집기를 사용하는 경우 편집기는 별도의 언어 서비스 프로세스를 시작 하고 &lt;a href=&quot;https://microsoft.github.io/language-server-protocol/&quot;&gt;언어 서버 프로토콜을&lt;/a&gt; 사용하여 &lt;a href=&quot;https://en.wikipedia.org/wiki/Remote_procedure_call&quot;&gt;RPC를&lt;/a&gt; 통해 해당 프로세스와 통신합니다 . 편집기에 입력하면 편집기는 프로젝트의 상태를 추적하기 위해 언어 서비스 프로세스에 정보를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="7091693d92ad9fcbdbcc9479803eb8ea1f9c1565" translate="yes" xml:space="preserve">
          <source>When you use ngUpgrade, what you're really doing is &lt;em&gt;running both AngularJS and Angular at the same time&lt;/em&gt;. All Angular code is running in the Angular framework, and AngularJS code in the AngularJS framework. Both of these are the actual, fully featured versions of the frameworks. There is no emulation going on, so you can expect to have all the features and natural behavior of both frameworks.</source>
          <target state="translated">ngUpgrade를 사용할 때 실제로 수행하는 작업은 &lt;em&gt;AngularJS와 Angular를 동시에 실행&lt;/em&gt; 하는 것입니다 . 모든 Angular 코드는 Angular 프레임 워크에서 실행되고 AngularJS 코드는 AngularJS 프레임 워크에서 실행됩니다. 둘 다 프레임 워크의 실제 기능을 갖춘 버전입니다. 에뮬레이션이 진행되지 않으므로 두 프레임 워크의 모든 기능과 자연스러운 동작을 기대할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1273337c88d3f5d1fda2d87de160020bcfd831bc" translate="yes" xml:space="preserve">
          <source>When you use the &lt;a href=&quot;cli&quot;&gt;Angular CLI&lt;/a&gt; command &lt;code&gt;ng new&lt;/code&gt; to generate an app, the default &lt;code&gt;AppModule&lt;/code&gt; looks like the following:</source>
          <target state="translated">당신은 사용할 때 &lt;a href=&quot;cli&quot;&gt;각도 CLI의&lt;/a&gt; 명령을 &lt;code&gt;ng new&lt;/code&gt; 응용 프로그램, 기본 생성 &lt;code&gt;AppModule&lt;/code&gt; 의 다음과 같은 외모를 :</target>
        </trans-unit>
        <trans-unit id="a2eec843f1d023d68567197d0f57ed566b9116ea" translate="yes" xml:space="preserve">
          <source>When you use the Angular CLI command &lt;a href=&quot;cli/generate&quot;&gt;&lt;code&gt;ng generate component&lt;/code&gt;&lt;/a&gt; without the &lt;code&gt;--inline-style&lt;/code&gt; flag, it creates an empty styles file for you and references that file in the component's generated &lt;code&gt;&lt;a href=&quot;../api/core/component#styleUrls&quot;&gt;styleUrls&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--inline-style&lt;/code&gt; 플래그 없이 Angular CLI 명령 &lt;a href=&quot;cli/generate&quot;&gt; &lt;code&gt;ng generate component&lt;/code&gt; &lt;/a&gt; 를 사용하면 비어있는 스타일 파일을 작성하고 해당 파일을 컴포넌트의 생성 된 &lt;code&gt;&lt;a href=&quot;../api/core/component#styleUrls&quot;&gt;styleUrls&lt;/a&gt;&lt;/code&gt; 에서 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="897e950b7b7b7944725b907f18f2c240e2dd97f3" translate="yes" xml:space="preserve">
          <source>When you use the Angular CLI command &lt;a href=&quot;cli/generate&quot;&gt;&lt;code&gt;ng generate component&lt;/code&gt;&lt;/a&gt; without the &lt;code&gt;--inline-style&lt;/code&gt; flag, it creates an empty styles file for you and references that file in the component's generated &lt;code&gt;styleUrls&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--inline-style&lt;/code&gt; 플래그 없이 &lt;a href=&quot;cli/generate&quot;&gt; &lt;code&gt;ng generate component&lt;/code&gt; &lt;/a&gt; 를 생성 하는 Angular CLI 명령을 사용하면 빈 스타일 파일이 생성되고 구성 요소의 생성 된 &lt;code&gt;styleUrls&lt;/code&gt; 에서 해당 파일을 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="247bac8024638798cef5c1812110dc811b6aae31" translate="yes" xml:space="preserve">
          <source>When you use the CLI &lt;code&gt;build&lt;/code&gt; or &lt;code&gt;serve&lt;/code&gt; command to build your application for different locales, change the output path using the &lt;code&gt;--outputPath&lt;/code&gt; command option (along with the i18n-specific command options), so that the translation files are saved to different locations. When you are serving a locale-specific version from a subdirectory, you can also change the base URL used by your app by specifying the &lt;code&gt;--baseHref&lt;/code&gt; option.</source>
          <target state="translated">CLI &lt;code&gt;build&lt;/code&gt; 또는 &lt;code&gt;serve&lt;/code&gt; 명령을 사용하여 다른 로케일에 대한 응용 프로그램을 빌드 할 때 변환 파일이 다른 위치에 저장되도록 &lt;code&gt;--outputPath&lt;/code&gt; 명령 옵션 (i18n 특정 명령 옵션과 함께)을 사용하여 출력 경로를 변경하십시오 . 하위 디렉토리에서 로케일 특정 버전을 제공 할 때 &lt;code&gt;--baseHref&lt;/code&gt; 옵션 을 지정하여 앱에서 사용하는 기본 URL을 변경할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51cfdc22d2284f7c687631623cd1f1d8f4a0ab01" translate="yes" xml:space="preserve">
          <source>When you use the CLI command &lt;code&gt;ng new --strict&lt;/code&gt;, it is set to &lt;code&gt;true&lt;/code&gt; in the generated project's configuration.</source>
          <target state="translated">당신은 CLI 명령을 사용하는 경우 &lt;code&gt;ng new --strict&lt;/code&gt; , 그것은으로 설정되어 &lt;code&gt;true&lt;/code&gt; 생성 된 프로젝트의 구성.</target>
        </trans-unit>
        <trans-unit id="f2e97de1383d763b5d6a77c6e6a143039f881b94" translate="yes" xml:space="preserve">
          <source>When you use the Schematics CLI to create a blank schematics project, the new blank schematic is the first member of the collection, and has the same name as the collection. When you add a new named schematic to this collection, it is automatically added to the &lt;code&gt;collection.json&lt;/code&gt; schema.</source>
          <target state="translated">Schematics CLI를 사용하여 빈 회로도 프로젝트를 작성하는 경우 새 빈 회로도는 콜렉션의 첫 번째 구성원이며 콜렉션과 이름이 같습니다. 이 컬렉션에 명명 된 회로도를 새로 추가하면 자동으로 &lt;code&gt;collection.json&lt;/code&gt; 스키마에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="c8e927f93087617fa5e2ad0d1654b43c538c0e7e" translate="yes" xml:space="preserve">
          <source>When you use these Angular modules, import them in &lt;code&gt;AppModule&lt;/code&gt;, or your feature module as appropriate, and list them in the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt;&lt;code&gt;imports&lt;/code&gt; array. For example, in the basic app generated by the &lt;a href=&quot;cli&quot;&gt;Angular CLI&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt; is the first import at the top of the &lt;code&gt;AppModule&lt;/code&gt;, &lt;code&gt;app.module.ts&lt;/code&gt;.</source>
          <target state="translated">이러한 Angular 모듈을 사용하는 경우 &lt;code&gt;AppModule&lt;/code&gt; 또는 기능 모듈에서 해당 모듈을 &lt;code&gt;imports&lt;/code&gt; &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; @ NgModule imports 배열에 나열하십시오. 예를 들어 &lt;a href=&quot;cli&quot;&gt;Angular CLI에&lt;/a&gt; 의해 생성 된 기본 앱 에서 &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;AppModule&lt;/code&gt; 맨 위에있는 첫 번째 가져 오기 인 &lt;code&gt;app.module.ts&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="080cd8e0ffd40797678bd6db1b07ecb17508c1bf" translate="yes" xml:space="preserve">
          <source>When you visit &lt;code&gt;http://localhost:4200&lt;/code&gt;, the &lt;code&gt;/heroes&lt;/code&gt; route loads immediately upon launch and the router starts loading the &lt;code&gt;CrisisCenterModule&lt;/code&gt; right after the &lt;code&gt;HeroesModule&lt;/code&gt; loads.</source>
          <target state="translated">당신이 방문 할 때 &lt;code&gt;http://localhost:4200&lt;/code&gt; 의 &lt;code&gt;/heroes&lt;/code&gt; 실행하는 즉시 경로로드와로드 라우터 시작 &lt;code&gt;CrisisCenterModule&lt;/code&gt; 의 사후이 바로 &lt;code&gt;HeroesModule&lt;/code&gt; 의 부하를.</target>
        </trans-unit>
        <trans-unit id="44c77ca06e436ba06a76204c91665ded53e10a97" translate="yes" xml:space="preserve">
          <source>When you want to build reactive forms</source>
          <target state="translated">반응 형 양식을 작성하려는 경우</target>
        </trans-unit>
        <trans-unit id="48f76a44e44194717a9e946c5feb9c2e6b0b52cd" translate="yes" xml:space="preserve">
          <source>When you want to build template driven forms (includes &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;NgModel&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">템플릿 기반 양식을 작성하려는 경우 ( &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;NgModel&lt;/a&gt;&lt;/code&gt; 포함 )</target>
        </trans-unit>
        <trans-unit id="4e5214feaf2e0f2b028e9529ca13429a1279a360" translate="yes" xml:space="preserve">
          <source>When you want to run your app in a browser</source>
          <target state="translated">브라우저에서 앱을 실행하려는 경우</target>
        </trans-unit>
        <trans-unit id="79cd32fcf10e349cacf13610bd6576229e1c2cc5" translate="yes" xml:space="preserve">
          <source>When you want to talk to a server</source>
          <target state="translated">서버와 대화하고 싶을 때</target>
        </trans-unit>
        <trans-unit id="9b1b99eea8d22a5434f0d6b37e29a9e079c7a914" translate="yes" xml:space="preserve">
          <source>When you want to use &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;NgFor&lt;/code&gt;</source>
          <target state="translated">사용할 때 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 을 , &lt;code&gt;NgFor&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="896f69bcc45a08c492c179d02b221484e8842f42" translate="yes" xml:space="preserve">
          <source>When you want to use &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;.forRoot()&lt;/code&gt;, and &lt;code&gt;.forChild()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;.forRoot()&lt;/code&gt; 및 &lt;code&gt;.forChild()&lt;/code&gt; 를 사용하려는 경우</target>
        </trans-unit>
        <trans-unit id="dfa0b324bbeaa7902d962fb62864b60a9b21dc09" translate="yes" xml:space="preserve">
          <source>When you write a data-binding, you're dealing exclusively with the &lt;em&gt;DOM properties&lt;/em&gt; and &lt;em&gt;events&lt;/em&gt; of the target object.</source>
          <target state="translated">데이터 바인딩을 작성할 때 대상 객체 의 &lt;em&gt;DOM 속성&lt;/em&gt; 및 &lt;em&gt;이벤트&lt;/em&gt; 만 처리 합니다.</target>
        </trans-unit>
        <trans-unit id="4bb0f31a361efec853e39b49bafb65056beed48a" translate="yes" xml:space="preserve">
          <source>When you write your own structural directives, use the following grammar:</source>
          <target state="translated">고유 한 구조적 지시문을 작성할 때는 다음 문법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b4e579e2078171bbeaf4e91de26fcbce3bcc959d" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re done, users will be able to navigate the app like this:</source>
          <target state="translated">완료되면 사용자는 다음과 같이 앱을 탐색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17951df2c8400929e977efa4744c0c861fc58da2" translate="yes" xml:space="preserve">
          <source>When you're done it looks like this.</source>
          <target state="translated">완료되면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef010cb6e75978e36467b31a7285fb58053efd7b" translate="yes" xml:space="preserve">
          <source>When you're done with this page, the app should look like this live example.</source>
          <target state="translated">이 페이지를 마치면 앱이 실제 예제와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="e6a96be9b1ba1110aa029cf80016d7fb5e9e1068" translate="yes" xml:space="preserve">
          <source>When you're done, it should look like this:</source>
          <target state="translated">완료되면 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="30a40655f733f6e41e3030f2d31ddd6f2dbe644f" translate="yes" xml:space="preserve">
          <source>When you're done, the &lt;code&gt;HeroDetailComponent&lt;/code&gt; template should look like this:</source>
          <target state="translated">완료되면 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 템플릿은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="ea335dad3c01c816d9ed76f23c43e1124bac391a" translate="yes" xml:space="preserve">
          <source>When you're done, you'll have these &lt;em&gt;hero management&lt;/em&gt; files:</source>
          <target state="translated">완료되면 다음과 같은 &lt;em&gt;영웅 관리&lt;/em&gt; 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="503695908e0b2be5d18ab6d1e3b8706361e129c4" translate="yes" xml:space="preserve">
          <source>When you're familiar with these fundamental building blocks, you can explore them in more detail in the documentation. To learn about more tools and techniques that are available to help you build and deploy Angular applications, see &lt;a href=&quot;architecture-next-steps&quot;&gt;Next steps: tools and techniques&lt;/a&gt;.</source>
          <target state="translated">이러한 기본 구성 요소에 익숙하면 설명서에서이를 자세히 살펴볼 수 있습니다. Angular 응용 프로그램을 구축 및 배포하는 데 사용할 수있는 추가 도구 및 기술에 대한 자세한 내용은 &lt;a href=&quot;architecture-next-steps&quot;&gt;다음 단계 : 도구 및 기술을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c0dae56146bb8eee79b34c8c03a03fc066445b7" translate="yes" xml:space="preserve">
          <source>When you're filtering by CSS selector and only testing properties of a browser's &lt;em&gt;native element&lt;/em&gt;, the &lt;code&gt;By.css&lt;/code&gt; approach may be overkill.</source>
          <target state="translated">CSS 선택기로 필터링하고 브라우저 &lt;em&gt;기본 요소&lt;/em&gt; 의 속성 만 테스트하는 경우 &lt;code&gt;By.css&lt;/code&gt; 접근 방식이 과도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6dec613091e0293026f13a73d50239981c86f57" translate="yes" xml:space="preserve">
          <source>When you're ready to activate the marble observables, you tell the &lt;code&gt;TestScheduler&lt;/code&gt; to &lt;em&gt;flush&lt;/em&gt; its queue of prepared tasks like this.</source>
          <target state="translated">대리석 관찰 가능 항목을 활성화 할 준비가되면 &lt;code&gt;TestScheduler&lt;/code&gt; 에게 준비된 작업 대기열 을 &lt;em&gt;플러시&lt;/em&gt; 하도록 지시 합니다 .</target>
        </trans-unit>
        <trans-unit id="7661aa2fca4df31ccc337d89f54c6916141df825" translate="yes" xml:space="preserve">
          <source>When you've defined an animation trigger for a component, you can attach it to an element in that component's template by wrapping the trigger name in brackets and preceding it with an &lt;code&gt;@&lt;/code&gt; symbol. Then, you can bind the trigger to a template expression using standard Angular property binding syntax as shown below, where &lt;code&gt;&lt;a href=&quot;../api/animations/animationevent#triggerName&quot;&gt;triggerName&lt;/a&gt;&lt;/code&gt; is the name of the trigger, and &lt;code&gt;expression&lt;/code&gt; evaluates to a defined animation state.</source>
          <target state="translated">구성 요소에 대한 애니메이션 트리거를 정의한 경우 트리거 이름을 괄호로 묶고 &lt;code&gt;@&lt;/code&gt; 기호를 앞에 붙여 해당 구성 요소의 템플릿에서 요소에 연결할 수 있습니다 . 그런 다음 아래와 같이 표준 Angular 속성 바인딩 구문을 사용하여 트리거를 템플릿 표현식에 바인딩 할 수 있습니다. 여기서 &lt;code&gt;&lt;a href=&quot;../api/animations/animationevent#triggerName&quot;&gt;triggerName&lt;/a&gt;&lt;/code&gt; 은 트리거의 이름이며 &lt;code&gt;expression&lt;/code&gt; 은 정의 된 애니메이션 상태로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="f196d6a018456796c02b3eb21de694c56f582388" translate="yes" xml:space="preserve">
          <source>When you've defined an animation trigger for a component, you can attach it to an element in that component's template by wrapping the trigger name in brackets and preceding it with an &lt;code&gt;@&lt;/code&gt; symbol. Then, you can bind the trigger to a template expression using standard Angular property binding syntax as shown below, where &lt;code&gt;triggerName&lt;/code&gt; is the name of the trigger, and &lt;code&gt;expression&lt;/code&gt; evaluates to a defined animation state.</source>
          <target state="translated">구성 요소에 대한 애니메이션 트리거를 정의한 경우 트리거 이름을 괄호로 묶고 앞에 &lt;code&gt;@&lt;/code&gt; 기호를 붙여 해당 구성 요소의 템플릿에있는 요소에 연결할 수 있습니다 . 그런 다음 아래와 같이 표준 Angular 속성 바인딩 구문을 사용하여 트리거를 템플릿 표현식에 바인딩 할 수 있습니다. 여기서 &lt;code&gt;triggerName&lt;/code&gt; 은 트리거의 이름이고 &lt;code&gt;expression&lt;/code&gt; 은 정의 된 애니메이션 상태로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="06d0715c9e5e8fde1b326bf82fa7f414cd43a882" translate="yes" xml:space="preserve">
          <source>When your app is ready, you can use the Angular CLI to extract the text messages marked with &lt;code&gt;i18n&lt;/code&gt; and attributes marked with &lt;code&gt;i18n-x&lt;/code&gt; into a translation source file. Open a terminal window at the root of the app project and run the CLI command &lt;code&gt;xi18n&lt;/code&gt;.</source>
          <target state="translated">앱이 준비되면 Angular CLI를 사용하여 &lt;code&gt;i18n&lt;/code&gt; 으로 표시된 문자 메시지 와 &lt;code&gt;i18n-x&lt;/code&gt; 로 표시된 속성을 번역 소스 파일 로 추출 할 수 있습니다 . 앱 프로젝트의 루트에서 터미널 창을 열고 CLI 명령 &lt;code&gt;xi18n&lt;/code&gt; 을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="155587edb5946e5b07a5f26004e5f36b972bf50e" translate="yes" xml:space="preserve">
          <source>When your application matches a route that needs AngularJS, the AngularJS app is loaded and bootstrapped, the AngularJS routes match the necessary URL to render their content, and your application continues to run with both AngularJS and Angular frameworks.</source>
          <target state="translated">애플리케이션이 AngularJS가 필요한 경로와 일치하면 AngularJS 앱이로드 및 부트 스트랩되고 AngularJS 경로는 콘텐츠를 렌더링하는 데 필요한 URL과 일치하며 AngularJS 및 Angular 프레임 워크 모두에서 애플리케이션이 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1112737823346d69526849d251d05ee8229526b6" translate="yes" xml:space="preserve">
          <source>When your builder calls &lt;code&gt;BuilderRun.stop()&lt;/code&gt; to exit watch mode, Architect unsubscribes from the builder&amp;rsquo;s Observable and calls the builder&amp;rsquo;s teardown logic to clean up. (This behavior also allows for long running builds to be stopped and cleaned up.)</source>
          <target state="translated">빌더가 &lt;code&gt;BuilderRun.stop()&lt;/code&gt; 모드를 종료하기 위해 BuilderRun.stop () 을 호출하면 Architect는 빌더의 Observable을 구독 취소하고 빌더의 정리 로직을 호출하여 정리합니다. (이 동작은 또한 장기 실행 빌드를 중지하고 정리할 수있게합니다.)</target>
        </trans-unit>
        <trans-unit id="40126e45c19e856e37cb61d50f01cae678591e52" translate="yes" xml:space="preserve">
          <source>When your custom element is placed on a page, the browser creates an instance of the registered class and adds it to the DOM. The content is provided by the component's template, which uses Angular template syntax, and is rendered using the component and DOM data. Input properties in the component correspond to input attributes for the element.</source>
          <target state="translated">사용자 정의 요소가 페이지에 배치되면 브라우저는 등록 된 클래스의 인스턴스를 작성하여 DOM에 추가합니다. 콘텐츠는 Angular 템플릿 구문을 사용하는 구성 요소 템플릿에서 제공되며 구성 요소와 DOM 데이터를 사용하여 렌더링됩니다. 컴포넌트의 입력 특성은 요소의 입력 속성에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="b8a317fa05b7d048a76b55b7cf3677a9fa2860a5" translate="yes" xml:space="preserve">
          <source>Whenever an &quot;upgraded&quot;/&quot;downgraded&quot; component is instantiated the host element is owned by the framework doing the instantiation. The other framework then instantiates and owns the view for that component.</source>
          <target state="translated">&quot;업그레이드 된&quot;/ &quot;다운 그레이드 된&quot;컴포넌트가 인스턴스화 될 때마다 호스트 요소는 인스턴스화를 수행하는 프레임 워크가 소유합니다. 다른 프레임 워크는 해당 구성 요소에 대한보기를 인스턴스화하고 소유합니다.</target>
        </trans-unit>
        <trans-unit id="c4fef1a1adbf1c56b8cc3ecbb53a52b91dc97ae7" translate="yes" xml:space="preserve">
          <source>Whenever an adapter component is instantiated the host element is owned by the framework doing the instantiation. The other framework then instantiates and owns the view for that component. This implies that component bindings will always follow the semantics of the instantiation framework. The syntax is always that of Angular syntax.</source>
          <target state="translated">어댑터 구성 요소가 인스턴스화 될 때마다 호스트 요소는 인스턴스화를 수행하는 프레임 워크에서 소유합니다. 다른 프레임 워크는 해당 구성 요소에 대한보기를 인스턴스화하고 소유합니다. 이는 컴포넌트 바인딩이 항상 인스턴스화 프레임 워크의 의미를 따릅니다. 구문은 항상 Angular 구문입니다.</target>
        </trans-unit>
        <trans-unit id="8ae58a1b05f2395f014006fe21deb943e33d2361" translate="yes" xml:space="preserve">
          <source>Whenever the URL is either '/user' or '/user/bob', the &quot;active-link&quot; class is added to the anchor tag. If the URL changes, the class is removed.</source>
          <target state="translated">URL이 '/ user'또는 '/ user / bob'일 때마다 &quot;active-link&quot;클래스가 앵커 태그에 추가됩니다. URL이 변경되면 클래스가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="bb18456bba2c2a76c99b73d09dd270a2142bfc64" translate="yes" xml:space="preserve">
          <source>Whenever you use a component that belongs to the other framework, a switch between framework boundaries occurs. However, that switch only happens to the elements in the template of that component. Consider a situation where you use an Angular component from AngularJS like this:</source>
          <target state="translated">다른 프레임 워크에 속하는 구성 요소를 사용할 때마다 프레임 워크 경계 간 전환이 발생합니다. 그러나 해당 스위치는 해당 구성 요소 템플릿의 요소에만 적용됩니다. AngularJS의 Angular 컴포넌트를 다음과 같이 사용하는 상황을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="4f1b08932a636904e6d51136ac6d5569fe2a8d1a" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;&amp;lt;component-name&amp;gt;&lt;/code&gt; is the name of your component.</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;component-name&amp;gt;&lt;/code&gt; 은 구성 요소의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="37c5edffc9d8dd9268e9bb4d3e92e12fb900ef58" translate="yes" xml:space="preserve">
          <source>Where the &lt;code&gt;catchError&lt;/code&gt; operator provides a simple path of recovery, the &lt;code&gt;retry&lt;/code&gt; operator lets you retry a failed request.</source>
          <target state="translated">를 Where &lt;code&gt;catchError&lt;/code&gt; 의 운영자가 복구하는 간단한 경로를 제공의 &lt;code&gt;retry&lt;/code&gt; 연산자를 사용하면 실패한 요청을 다시 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3e42f4f2adbf1be1d8f547f899caad64fb9b8c9" translate="yes" xml:space="preserve">
          <source>Where to find this element in the source component template.</source>
          <target state="translated">소스 컴포넌트 템플리트에서이 요소를 찾을 수있는 위치입니다.</target>
        </trans-unit>
        <trans-unit id="899e84e9c1a23f3a65ea931518f5051ef6f15a09" translate="yes" xml:space="preserve">
          <source>Where to start looking, that is &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt;</source>
          <target state="translated">어디서부터 시작해야 &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; @ SkipSelf ()입니다.</target>
        </trans-unit>
        <trans-unit id="dbc3168449a7edc3ef42f05f473e45c12862c64f" translate="yes" xml:space="preserve">
          <source>Where to stop looking, &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;@&lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt;()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; 및 &lt;code&gt;@&lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt; ()를 찾는 곳</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="2e0c2208909a09359c375b3d5aeecc93e7a44f87" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;$event&lt;/code&gt; will have the correct type for event bindings to DOM events. If disabled, it will be &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$event&lt;/code&gt; 가 DOM 이벤트에 대한 이벤트 바인딩에 대해 올바른 유형을 가질 지 여부 . 비활성화 된 경우 &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4eac539be36df779c3551d604f39edbed339477e" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;$event&lt;/code&gt; will have the correct type for event bindings to component/directive an &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt;, or to animation events. If disabled, it will be &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$event&lt;/code&gt; 가 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; 또는 애니메이션 이벤트에 대한 구성 요소 / 지시문에 대한 이벤트 바인딩에 대해 올바른 유형을 가질 지 여부 . 비활성화 된 경우 &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e937161658fda0f59055fdaec47bde9945c0ff55" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;strictNullChecks&lt;/code&gt; is honored when checking &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; bindings (per &lt;code&gt;strictInputTypes&lt;/code&gt;). Turning this off can be useful when using a library that was not built with &lt;code&gt;strictNullChecks&lt;/code&gt; in mind.</source>
          <target state="translated">여부 &lt;code&gt;strictNullChecks&lt;/code&gt; 을 검사 할 때 영광 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; (당 바인딩을 &lt;code&gt;strictInputTypes&lt;/code&gt; ). 이 기능을 끄면 &lt;code&gt;strictNullChecks&lt;/code&gt; 를 염두에두고 빌드되지 않은 라이브러리를 사용할 때 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37f1d496f29e5eb73daa8902f0325d27e32761df" translate="yes" xml:space="preserve">
          <source>Whether access modifiers such as &lt;code&gt;private&lt;/code&gt;/&lt;code&gt;protected&lt;/code&gt;/&lt;code&gt;readonly&lt;/code&gt; are honored when assigning a binding expression to an &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt;. If disabled, the access modifiers of the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; are ignored; only the type is checked.</source>
          <target state="translated">여부와 같은 액세스 한정자 &lt;code&gt;private&lt;/code&gt; / &lt;code&gt;protected&lt;/code&gt; / &lt;code&gt;readonly&lt;/code&gt; 내지 An 결합 식을 할당 할 때 영광 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; . 비활성화 된 경우 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; 의 액세스 수정자는 무시됩니다. 유형 만 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="2e665d9a41999f37f1f7c2d3f4a29a44a6cd8103" translate="yes" xml:space="preserve">
          <source>Whether an associated application is stable</source>
          <target state="translated">관련 응용 프로그램이 안정적인지 여부</target>
        </trans-unit>
        <trans-unit id="cc7b410bfd6fba439e9b1baa4aec1653ebd2f4ec" translate="yes" xml:space="preserve">
          <source>Whether local references to DOM elements will have the correct type. If disabled &lt;code&gt;ref&lt;/code&gt; will be of type &lt;code&gt;any&lt;/code&gt; for &lt;code&gt;&amp;lt;input #ref&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">DOM 요소에 대한 로컬 참조의 유형이 올바른지 여부. 비활성화 된 경우 &lt;code&gt;ref&lt;/code&gt; 는 &lt;code&gt;&amp;lt;input #ref&amp;gt;&lt;/code&gt; 에 대해 &lt;code&gt;any&lt;/code&gt; 유형이됩니다 .</target>
        </trans-unit>
        <trans-unit id="c1714ccb44042ca5ff4cc3d25ca89d6c4d82eaa5" translate="yes" xml:space="preserve">
          <source>Whether object and array literals declared in the template will have their type inferred. If disabled, the type of such literals will be &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">템플릿에 선언 된 객체 및 배열 리터럴이 유형을 유추할지 여부입니다. 비활성화 된 경우 이러한 리터럴의 유형은 &lt;code&gt;any&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eb474db37cd039fcdb74ad381d29c8362cc8e3e8" translate="yes" xml:space="preserve">
          <source>Whether the ServiceWorker will be registered and the related services (such as &lt;code&gt;&lt;a href=&quot;swpush&quot;&gt;SwPush&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;swupdate&quot;&gt;SwUpdate&lt;/a&gt;&lt;/code&gt;) will attempt to communicate and interact with it.</source>
          <target state="translated">ServiceWorker 등록 여부 및 관련 서비스 (예 : &lt;code&gt;&lt;a href=&quot;swpush&quot;&gt;SwPush&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;swupdate&quot;&gt;SwUpdate&lt;/a&gt;&lt;/code&gt; )는 통신 및 상호 작용을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="01d480a254eac0f05046b9ed0e18f9c8ded8044e" translate="yes" xml:space="preserve">
          <source>Whether the assignability of a binding expression to the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; field is checked. Also affects the inference of directive generic types.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 필드 에 대한 바인딩 표현식의 지정 가능성 이 검사 되는지 여부 . 지시문 제네릭 유형의 추론에도 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="2efc288f3df18953bf9fb23fadb91dbc28bef3db" translate="yes" xml:space="preserve">
          <source>Whether the contents of the root element should be preserved, or cleared upon bootstrap (default behavior). Use with &lt;code&gt;&lt;a href=&quot;viewencapsulation#ShadowDom&quot;&gt;ViewEncapsulation.ShadowDom&lt;/a&gt;&lt;/code&gt; to allow simple native content projection via &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; elements.</source>
          <target state="translated">루트 요소의 내용을 보존해야하는지 또는 부트 스트랩시 지워야하는지 여부 (기본 동작) &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 요소 를 통해 간단한 기본 컨텐츠 투영을 허용 하려면 &lt;code&gt;&lt;a href=&quot;viewencapsulation#ShadowDom&quot;&gt;ViewEncapsulation.ShadowDom&lt;/a&gt;&lt;/code&gt; 과 함께 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="679fd56c58f755345be6f286028f36ab6f697b0c" translate="yes" xml:space="preserve">
          <source>Whether the given route should detach for later reuse. Always returns false for &lt;code&gt;&lt;a href=&quot;baseroutereusestrategy&quot;&gt;BaseRouteReuseStrategy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">나중에 재사용하기 위해 지정된 경로를 분리해야하는지 여부입니다. &lt;code&gt;&lt;a href=&quot;baseroutereusestrategy&quot;&gt;BaseRouteReuseStrategy&lt;/a&gt;&lt;/code&gt; 에 대해 항상 false를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7a82aeecbb6452e4ec659c4ab75f78d16e34f84a" translate="yes" xml:space="preserve">
          <source>Whether the listener is using event capturing.</source>
          <target state="translated">리스너가 이벤트 캡처를 사용하는지 여부.</target>
        </trans-unit>
        <trans-unit id="50cfde31657c9b1fe2fdf40030fe9a96ff38a3c3" translate="yes" xml:space="preserve">
          <source>Whether the request was cancelled after it was sent.</source>
          <target state="translated">요청이 전송 된 후 취소되었는지 여부</target>
        </trans-unit>
        <trans-unit id="7f113e0ba3142ea06015cd8f51bcf988db639b1f" translate="yes" xml:space="preserve">
          <source>Whether the return type of safe navigation operations (for example, &lt;code&gt;user?.name&lt;/code&gt;) will be correctly inferred based on the type of &lt;code&gt;user&lt;/code&gt;). If disabled, &lt;code&gt;user?.name&lt;/code&gt; will be of type &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">안전한 탐색 작업의 반환 유형 (예 : &lt;code&gt;user?.name&lt;/code&gt; )이 &lt;code&gt;user&lt;/code&gt; 유형에 따라 올바르게 유추 되는지 여부 입니다. 비활성화 된 경우 &lt;code&gt;user?.name&lt;/code&gt; 유형은 &lt;code&gt;any&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4bd45560b76a4dce3c8ea0111cc1f62d210247d6" translate="yes" xml:space="preserve">
          <source>Whether the router is configured properly to navigate with that route definition is a question for a separate set of tests.</source>
          <target state="translated">라우터가 해당 경로 정의를 탐색하도록 올바르게 구성되었는지 여부는 별도의 테스트 세트에 대한 질문입니다.</target>
        </trans-unit>
        <trans-unit id="a4ae306143b886081b256a0cf1522d64a7dc41b4" translate="yes" xml:space="preserve">
          <source>Whether the segment has child segments</source>
          <target state="translated">세그먼트에 하위 세그먼트가 있는지 여부</target>
        </trans-unit>
        <trans-unit id="456355a8ff33ce384c5db09a8d5dcfc2098e26a3" translate="yes" xml:space="preserve">
          <source>Whether the status code falls in the 2xx range.</source>
          <target state="translated">상태 코드가 2xx 범위에 속하는지 여부</target>
        </trans-unit>
        <trans-unit id="c6e9743720182bd06b19205d978e8d09ab6cf7b8" translate="yes" xml:space="preserve">
          <source>Whether the type parameters of generic components will be inferred correctly (including any generic bounds). If disabled, any type parameters will be &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">일반 구성 요소의 형식 매개 변수가 올바르게 유추되는지 여부 (일반 경계 포함) 비활성화 된 경우 모든 유형 매개 변수는 &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1e28eb611de2479c2121cff8123da6d11a13577" translate="yes" xml:space="preserve">
          <source>Whether there are no outstanding microtasks or macrotasks.</source>
          <target state="translated">미시적 마이크로 태스크 또는 매크로 태스크가 없는지 여부</target>
        </trans-unit>
        <trans-unit id="8c95f88ef6319a806a46dcf12f9b346039ef053e" translate="yes" xml:space="preserve">
          <source>Whether this request should be made in a way that exposes progress events.</source>
          <target state="translated">이 요청이 진행 이벤트를 노출시키는 방식으로 이루어져야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="98f2e0d781390a03ccdfde20254e6c9d4fb73bb1" translate="yes" xml:space="preserve">
          <source>Whether this request should be sent with outgoing credentials (cookies).</source>
          <target state="translated">이 요청을 발신 자격 증명 (쿠키)과 함께 보내야하는지 여부</target>
        </trans-unit>
        <trans-unit id="e67c5849260e2c1b0ff2264f25feeb3c55f8f10c" translate="yes" xml:space="preserve">
          <source>Whether to allow updating when the repository contains modified or untracked files.</source>
          <target state="translated">저장소에 수정되거나 추적되지 않은 파일이 포함 된 경우 업데이트를 허용할지 여부</target>
        </trans-unit>
        <trans-unit id="f0483717f7b4a8d01396eafecce1a5ccc5693967" translate="yes" xml:space="preserve">
          <source>Whether to append the absolute URL to any relative HTTP requests. If set to true, this logic executes prior to any HTTP interceptors that may run later on in the request. &lt;code&gt;baseUrl&lt;/code&gt; must be supplied if this flag is enabled.</source>
          <target state="translated">상대 HTTP 요청에 절대 URL을 추가할지 여부입니다. true로 설정하면이 논리는 요청에서 나중에 실행될 수있는 HTTP 인터셉터보다 먼저 실행됩니다. 이 플래그가 활성화 된 경우 &lt;code&gt;baseUrl&lt;/code&gt; 을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="d1accf922b230f17dfe9dad34c4a8560fc1606e5" translate="yes" xml:space="preserve">
          <source>Whether to check &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; bindings that are made using text attributes (for example, &lt;code&gt;&amp;lt;mat-tab label=&quot;Step 1&quot;&amp;gt;&lt;/code&gt; vs &lt;code&gt;&amp;lt;mat-tab [label]=&quot;'Step 1'&quot;&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">텍스트 속성 (예 : &lt;code&gt;&amp;lt;mat-tab label=&quot;Step 1&quot;&amp;gt;&lt;/code&gt; 대 &lt;code&gt;&amp;lt;mat-tab [label]=&quot;'Step 1'&quot;&amp;gt;&lt;/code&gt; )을 사용하여 만들어진 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 바인딩 을 확인할지 여부 입니다 .</target>
        </trans-unit>
        <trans-unit id="70687b848d56f420e192e687505aa7a7298367bc" translate="yes" xml:space="preserve">
          <source>Whether to reload the page on change, using live-reload.</source>
          <target state="translated">실시간 새로 고침을 사용하여 변경시 페이지를 새로 고침할지 여부</target>
        </trans-unit>
        <trans-unit id="432f58be7461d276173b0b45a590420621ebf868" translate="yes" xml:space="preserve">
          <source>Whether to update all packages in package.json.</source>
          <target state="translated">package.json의 모든 패키지를 업데이트할지 여부</target>
        </trans-unit>
        <trans-unit id="1de26d1834040d0a83cfb31ff38330472c5f00df" translate="yes" xml:space="preserve">
          <source>Whether using exactMatch</source>
          <target state="translated">exactMatch 사용 여부</target>
        </trans-unit>
        <trans-unit id="de1472a6ec96dc9dffba793cead39fdbd17ce5cb" translate="yes" xml:space="preserve">
          <source>Whether you came here directly from &lt;a href=&quot;https://angular.io/start/start&quot;&gt;Part 1&lt;/a&gt;, or completed the entire online store application through the &lt;a href=&quot;https://angular.io/start/start/start-routing&quot;&gt;In-app navigation&lt;/a&gt;, &lt;a href=&quot;https://angular.io/start/start/start-data&quot;&gt;Manage data&lt;/a&gt;, and &lt;a href=&quot;https://angular.io/start/start/start-forms&quot;&gt;Forms for user input&lt;/a&gt; sections, you have an application that you can deploy by following the instructions in this section.</source>
          <target state="translated">&lt;a href=&quot;https://angular.io/start/start&quot;&gt;Part 1&lt;/a&gt; 에서 직접 왔 거나 &lt;a href=&quot;https://angular.io/start/start/start-routing&quot;&gt;앱 내 탐색&lt;/a&gt; , &lt;a href=&quot;https://angular.io/start/start/start-data&quot;&gt;데이터 관리&lt;/a&gt; 및 &lt;a href=&quot;https://angular.io/start/start/start-forms&quot;&gt;사용자 입력&lt;/a&gt; 섹션에 대한 양식을 통해 전체 온라인 스토어 애플리케이션을 완료 했든 관계없이이 섹션의 지침에 따라 배포 할 수있는 애플리케이션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c0616b2607e4abaa27bed4b0ad642dc7df038cf" translate="yes" xml:space="preserve">
          <source>Whether you came here directly from &lt;a href=&quot;https://angular.io/start/start&quot;&gt;Your First App&lt;/a&gt;, or completed the entire online store application through the &lt;a href=&quot;https://angular.io/start/start/routing&quot;&gt;Routing&lt;/a&gt;, &lt;a href=&quot;https://angular.io/start/start/data&quot;&gt;Managing Data&lt;/a&gt;, and &lt;a href=&quot;https://angular.io/start/start/forms&quot;&gt;Forms&lt;/a&gt; sections, you have an application that you can deploy by following the instructions in this section.</source>
          <target state="translated">&lt;a href=&quot;https://angular.io/start/start&quot;&gt;첫 번째 앱&lt;/a&gt; 에서 직접 왔 거나 &lt;a href=&quot;https://angular.io/start/start/routing&quot;&gt;라우팅&lt;/a&gt; , &lt;a href=&quot;https://angular.io/start/start/data&quot;&gt;데이터&lt;/a&gt; 및 &lt;a href=&quot;https://angular.io/start/start/forms&quot;&gt;양식&lt;/a&gt; 섹션을 통해 전체 온라인 상점 애플리케이션을 완료 했는지 여부에 관계 없이이 섹션의 지시 사항에 따라 배치 할 수있는 애플리케이션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6730e737d171af53aac08d450ed36cf222714c7" translate="yes" xml:space="preserve">
          <source>Whether you decide to package functionality as a library is an architectural decision, similar to deciding whether a piece of functionality is a component or a service, or deciding on the scope of a component.</source>
          <target state="translated">기능을 라이브러리로 패키지할지 여부는 기능적 요소가 구성 요소인지 서비스인지를 결정하거나 구성 요소의 범위를 결정하는 것과 유사한 구조적 결정입니다.</target>
        </trans-unit>
        <trans-unit id="2038878dfc5e4e17b17bfe1516c1eeefe95f5b86" translate="yes" xml:space="preserve">
          <source>Which strategy is best?</source>
          <target state="translated">어떤 전략이 가장 좋습니까?</target>
        </trans-unit>
        <trans-unit id="5dfd5deece18b3254cac9f524fac29bd76a83d05" translate="yes" xml:space="preserve">
          <source>While Visual Studio Update 3 ships with TypeScript support out of the box, it currently doesn&amp;rsquo;t ship with more recent versions of TypeScript, which you need to develop Angular applications.</source>
          <target state="translated">Visual Studio Update 3에는 기본적으로 TypeScript 지원이 포함되어 있지만 현재는 최신 버전의 TypeScript가 제공되지 않으므로 Angular 응용 프로그램을 개발해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f1154cb47e7f3f095cf5a680d8c709aaf901f86" translate="yes" xml:space="preserve">
          <source>While a list of items exists in another file, &lt;code&gt;mock-items.ts&lt;/code&gt;, you can specify a different item in &lt;code&gt;app.component.ts&lt;/code&gt; so that the new item will render:</source>
          <target state="translated">항목 목록이 다른 파일 인 &lt;code&gt;mock-items.ts&lt;/code&gt; 에있는 &lt;code&gt;app.component.ts&lt;/code&gt; 다른 항목을 지정 하여 새 항목이 렌더링되도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7aaf540a86b02d7ab5f5ad8d445e241cd8492b75" translate="yes" xml:space="preserve">
          <source>While a small application might have only one NgModule, most apps have many more &lt;em&gt;feature modules&lt;/em&gt;. The &lt;em&gt;root&lt;/em&gt; NgModule for an app is so named because it can include child NgModules in a hierarchy of any depth.</source>
          <target state="translated">소규모 응용 프로그램에는 NgModule이 하나만있을 수 있지만 대부분의 응용 프로그램에는 더 많은 &lt;em&gt;기능 모듈이&lt;/em&gt; 있습니다. 앱 의 &lt;em&gt;루트&lt;/em&gt; NgModule은 자식 NgModules를 모든 깊이의 계층에 포함 할 수 있기 때문에 이름이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="c9d9d4e125467027b326dad11b4db7cf192e4292" translate="yes" xml:space="preserve">
          <source>While an impure pipe can be useful, be careful using one. A long-running impure pipe could dramatically slow down your app.</source>
          <target state="translated">불순한 파이프가 유용 할 수 있지만 조심해서 사용하십시오. 오래 실행되는 불순한 파이프는 앱 속도를 크게 저하시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de3a579f287c79f1f8e62ef5741cd82572da8246" translate="yes" xml:space="preserve">
          <source>While building out the crisis center feature, you navigated to the crisis detail route using an &lt;strong&gt;absolute path&lt;/strong&gt; that begins with a &lt;em&gt;slash&lt;/em&gt;.</source>
          <target state="translated">위기 센터 기능을 구축하는 동안 &lt;em&gt;슬래시로&lt;/em&gt; 시작 하는 &lt;strong&gt;절대 경로&lt;/strong&gt; 를 사용하여 위기 세부 경로로 이동했습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b994fa5ad6a0df57005672f1bc36799b782ce013" translate="yes" xml:space="preserve">
          <source>While building out the crisis center feature, you navigated to the crisis detail route using an absolute path that begins with a slash.</source>
          <target state="translated">위기 센터 기능을 구축하는 동안 슬래시로 시작하는 절대 경로를 사용하여 위기 세부 경로로 이동했습니다.</target>
        </trans-unit>
        <trans-unit id="af0f9bfe35490be85414a0791401df3fcf8622a8" translate="yes" xml:space="preserve">
          <source>While components in dedicated folders are widely preferred, another option for small apps is to keep components flat (not in a dedicated folder). This adds up to four files to the existing folder, but also reduces the folder nesting. Whatever you choose, be consistent.</source>
          <target state="translated">전용 폴더의 구성 요소가 널리 선호되는 반면 작은 앱의 또 다른 옵션은 구성 요소를 전용 폴더가 아닌 평평하게 유지하는 것입니다. 이렇게하면 기존 폴더에 최대 4 개의 파일이 추가되지만 폴더 중첩도 줄어 듭니다. 무엇을 선택하든 일관성을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="af144108b7f59db013ae2561d54c81a42f70f29c" translate="yes" xml:space="preserve">
          <source>While declaring &lt;code&gt;inputs&lt;/code&gt; and &lt;code&gt;outputs&lt;/code&gt; in the &lt;code&gt;@&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; metadata is possible, it is a better practice to use the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; class decorators instead, as follows:</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/directive&quot;&gt;지시문&lt;/a&gt; 및 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/component&quot;&gt;구성 요소&lt;/a&gt; 메타 데이터 에서 &lt;code&gt;inputs&lt;/code&gt; 및 &lt;code&gt;outputs&lt;/code&gt; 을 선언하는 것이 가능 하지만 다음과 같이 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt; () 및 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt; () 클래스 데코레이터를 대신 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2bed2bf619f46d9561a69d126f76aa9c4fcbbd5e" translate="yes" xml:space="preserve">
          <source>While developing a library, you must install all peer dependencies through &lt;code&gt;devDependencies&lt;/code&gt; to ensure that the library compiles properly. A linked library will then have its own set of Angular libraries that it uses for building, located in its &lt;code&gt;node_modules&lt;/code&gt; folder. However, this can cause problems while building or running your application.</source>
          <target state="translated">라이브러리를 개발하는 동안 라이브러리가 올바르게 컴파일되도록 &lt;code&gt;devDependencies&lt;/code&gt; 를 통해 모든 피어 종속성을 설치해야합니다 . 그런 다음 연결된 라이브러리는 &lt;code&gt;node_modules&lt;/code&gt; 폴더 에있는 자체 라이브러리 라이브러리를 빌드에 사용 합니다. 그러나 응용 프로그램을 빌드하거나 실행하는 동안 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1a0bf45b753eb2788a0f144fc1399ff08d7a339" translate="yes" xml:space="preserve">
          <source>While documentation guide pages ultimately render as HTML, almost all of them are written in &lt;a href=&quot;https://daringfireball.net/projects/markdown/syntax&quot;&gt;markdown&lt;/a&gt;.</source>
          <target state="translated">문서 가이드 페이지는 궁극적으로 HTML로 렌더링되지만 대부분은 &lt;a href=&quot;https://daringfireball.net/projects/markdown/syntax&quot;&gt;마크 다운&lt;/a&gt; 으로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="c100e548b1e727c46d786c6921d9f15548b92d9d" translate="yes" xml:space="preserve">
          <source>While following these steps, you can &lt;a href=&quot;i18n#app-pre-translation&quot;&gt;explore the translated example app&lt;/a&gt;.</source>
          <target state="translated">이 단계를 수행하는 동안 &lt;a href=&quot;i18n#app-pre-translation&quot;&gt;번역 된 예제 앱을 탐색&lt;/a&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2bb660e2b074f370e7dfa660e9e07c484771bd07" translate="yes" xml:space="preserve">
          <source>While invisible, the element remains in the DOM.</source>
          <target state="translated">보이지 않지만 요소는 DOM에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="16ee0811bb131e7a95292c475b6b02aee8293f49" translate="yes" xml:space="preserve">
          <source>While it is possible to downgrade injectables, downgraded injectables will not be available until the Angular module that provides them is instantiated. In order to be safe, you need to ensure that the downgraded injectables are not used anywhere &lt;em&gt;outside&lt;/em&gt; the part of the app where it is guaranteed that their module has been instantiated.</source>
          <target state="translated">인젝터 블을 다운 그레이드 할 수는 있지만 다운 그레이드 인젝터 블은 제공되는 Angular 모듈이 인스턴스화 될 때까지 사용할 수 없습니다. 안전을 위해, 다운 그레이드 된 인젝터 블이 앱의 &lt;em&gt;외부&lt;/em&gt; 에서 모듈이 인스턴스화되었다는 보장 이없는 곳에서 사용되지 않도록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b21f1ae1393795395e1d8727d35b23f3416670eb" translate="yes" xml:space="preserve">
          <source>While some may not care to minify this aggressively, the Angular product shouldn't prevent anyone from minifying aggressively. Therefore, the Angular team decided that everything Angular provides will minify safely.</source>
          <target state="translated">일부는 이것을 적극적으로 축소하지 않아도되지만 Angular 제품은 다른 사람이 적극적으로 축소하는 것을 막지 않아야합니다. 따라서 Angular 팀은 Angular가 제공하는 모든 것을 안전하게 축소하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="9deda132ffe29c742d81e186d165961fa24ce75f" translate="yes" xml:space="preserve">
          <source>While testing a component this simple has little intrinsic value, it's worth knowing how. You can use one of these approaches:</source>
          <target state="translated">이 간단한 구성 요소를 테스트하는 동안 본질적인 가치는 거의 없지만 방법을 아는 것이 좋습니다. 다음 방법 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="922eaf22cdef6cf248a96c62535e56e742dd60f1" translate="yes" xml:space="preserve">
          <source>While that seems redundant, these properties have different functions. Membership in one list doesn't imply membership in another list.</source>
          <target state="translated">중복되는 것처럼 보이지만 이러한 속성에는 다른 기능이 있습니다. 한 목록의 멤버십이 다른 목록의 멤버십을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="dbaae74b0ebf41a6f36354e5583ce138e38a4b27" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; functions greatly simplify Angular asynchronous testing, you can still fall back to the traditional technique and pass &lt;code&gt;it&lt;/code&gt; a function that takes a &lt;a href=&quot;https://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support&quot;&gt;&lt;code&gt;done&lt;/code&gt; callback&lt;/a&gt;.</source>
          <target state="translated">그동안 &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; 함수는 크게 각도 비동기 테스트를 단순화, 당신은 여전히 기존의 기술로 후퇴하고 전달할 수 있습니다 &lt;code&gt;it&lt;/code&gt; 받는 함수 &lt;a href=&quot;https://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support&quot;&gt; &lt;code&gt;done&lt;/code&gt; 콜백을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6438d422db5d5c83a1b6b3842605b3bf58e4d47f" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;&lt;a href=&quot;../api/core/testing/waitforasync&quot;&gt;waitForAsync&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; functions greatly simplify Angular asynchronous testing, you can still fall back to the traditional technique and pass &lt;code&gt;it&lt;/code&gt; a function that takes a &lt;a href=&quot;https://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support&quot;&gt;&lt;code&gt;done&lt;/code&gt; callback&lt;/a&gt;.</source>
          <target state="translated">그동안 &lt;code&gt;&lt;a href=&quot;../api/core/testing/waitforasync&quot;&gt;waitForAsync&lt;/a&gt;()&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; 함수는 크게 각도 비동기 테스트를 단순화, 당신은 여전히 기존의 기술로 후퇴하고 전달할 수 있습니다 &lt;code&gt;it&lt;/code&gt; 받는 함수 &lt;a href=&quot;https://jasmine.github.io/2.0/introduction.html#section-Asynchronous_Support&quot;&gt; &lt;code&gt;done&lt;/code&gt; 콜백을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="94a171d6c589715e1067bf2483ed94b5ae7d39ea" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;AppComponent&lt;/code&gt;&lt;em&gt;class&lt;/em&gt; is empty, you may want to write unit tests to confirm that the links are wired properly to the &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; directives, perhaps for the reasons &lt;a href=&quot;testing#why-stubbed-routerlink-tests&quot;&gt;explained below&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;AppComponent&lt;/code&gt; &lt;em&gt;클래스&lt;/em&gt; 가 비어 있는 동안 &lt;a href=&quot;testing#why-stubbed-routerlink-tests&quot;&gt;아래 설명&lt;/a&gt; 된 이유로 링크가 &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; 지시문에 올바르게 연결되었는지 확인하기 위해 단위 테스트를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d75a0ea7e49d05900484224fa6f44b2f9035ba6" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;AppComponent&lt;/code&gt;&lt;em&gt;class&lt;/em&gt; is empty, you may want to write unit tests to confirm that the links are wired properly to the &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; directives, perhaps for the reasons &lt;a href=&quot;testing-components-scenarios#why-stubbed-routerlink-tests&quot;&gt;explained below&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;AppComponent&lt;/code&gt; &lt;em&gt;클래스&lt;/em&gt; 가 비어 있는 동안 링크가 &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; 지시문에 올바르게 연결되었는지 확인하는 단위 테스트를 작성할 수 &lt;a href=&quot;testing-components-scenarios#why-stubbed-routerlink-tests&quot;&gt;있습니다&lt;/a&gt; . 아마도 아래에 설명 된 이유 때문일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d3223a994c3c8a4823a7603409c5fb5030bcfbb" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;HeroesComponent&lt;/code&gt; class still works, the &lt;code&gt;onSelect()&lt;/code&gt; method and &lt;code&gt;selectedHero&lt;/code&gt; property are no longer used.</source>
          <target state="translated">&lt;code&gt;HeroesComponent&lt;/code&gt; 클래스는 여전히 작동 하지만 &lt;code&gt;onSelect()&lt;/code&gt; 메서드와 &lt;code&gt;selectedHero&lt;/code&gt; 속성은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7bfa741a35ff4ba4dd3d245eeb234b8097b7ea83" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;ngDoCheck()&lt;/code&gt; hook can detect when the hero's &lt;code&gt;name&lt;/code&gt; has changed, it has a frightful cost. This hook is called with enormous frequency&amp;mdash;after &lt;em&gt;every&lt;/em&gt; change detection cycle no matter where the change occurred. It's called over twenty times in this example before the user can do anything.</source>
          <target state="translated">&lt;code&gt;ngDoCheck()&lt;/code&gt; 훅은 영웅의 &lt;code&gt;name&lt;/code&gt; 이 변경된 시기를 감지 할 수 있지만 비용이 많이 듭니다. 이 후크는 변경이 발생한 위치에 관계없이 &lt;em&gt;모든&lt;/em&gt; 변경 감지주기 후에 막대한 빈도로 호출됩니다 . 이 예제에서는 사용자가 무엇이든 할 수 있기 전에 20 번 이상 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="a027b3d587afc8003cb6783d750fb4124670a3aa" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;ngDoCheck()&lt;/code&gt; hook can detect when the hero's &lt;code&gt;name&lt;/code&gt; has changed, it is very expensive. This hook is called with enormous frequency&amp;mdash;after &lt;em&gt;every&lt;/em&gt; change detection cycle no matter where the change occurred. It's called over twenty times in this example before the user can do anything.</source>
          <target state="translated">&lt;code&gt;ngDoCheck()&lt;/code&gt; 후크는 영웅의 &lt;code&gt;name&lt;/code&gt; 이 변경된 시기를 감지 할 수 있지만 비용이 많이 듭니다. 이 후크는 변경이 발생한 위치에 관계없이 &lt;em&gt;모든&lt;/em&gt; 변경 감지주기 후에 엄청난 빈도로 호출됩니다 . 이 예제에서는 사용자가 무엇이든 할 수 있기 전에 20 번 이상 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="a55beda27c00248790e49417c4dcaaa586bb7541" translate="yes" xml:space="preserve">
          <source>While the &lt;em&gt;code sample&lt;/em&gt; accompanying this guide demonstrates &lt;code&gt;&lt;a href=&quot;../api/common/http/testing/httpclienttestingmodule&quot;&gt;HttpClientTestingModule&lt;/a&gt;&lt;/code&gt;, this page defers to the &lt;a href=&quot;http#testing-http-requests&quot;&gt;Http guide&lt;/a&gt;, which covers testing with the &lt;code&gt;&lt;a href=&quot;../api/common/http/testing/httpclienttestingmodule&quot;&gt;HttpClientTestingModule&lt;/a&gt;&lt;/code&gt; in detail.</source>
          <target state="translated">그동안 &lt;em&gt;코드 샘플&lt;/em&gt; 이 가이드를 동반 보여줍니다 &lt;code&gt;&lt;a href=&quot;../api/common/http/testing/httpclienttestingmodule&quot;&gt;HttpClientTestingModule&lt;/a&gt;&lt;/code&gt; 받는 사람,이 페이지는 연기 &lt;a href=&quot;http#testing-http-requests&quot;&gt;의 HTTP 가이드&lt;/a&gt; 커버는 함께 테스트, &lt;code&gt;&lt;a href=&quot;../api/common/http/testing/httpclienttestingmodule&quot;&gt;HttpClientTestingModule&lt;/a&gt;&lt;/code&gt; 자세히를.</target>
        </trans-unit>
        <trans-unit id="e236f6fd7d6a981d056dc092480c2d9f7cd0493a" translate="yes" xml:space="preserve">
          <source>While the bootstrapped and routed components are &lt;em&gt;entry components&lt;/em&gt;, you don't have to add them to a module's &lt;code&gt;entryComponents&lt;/code&gt; list, as they are added implicitly.</source>
          <target state="translated">부트 스트랩되고 라우팅 된 구성 요소는 &lt;em&gt;입력 구성 요소&lt;/em&gt; 이지만 모듈 은 암시 적으로 추가 &lt;code&gt;entryComponents&lt;/code&gt; 모듈의 entryComponents 목록 에 추가 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7b948c3298099054af5c43499c67fd799579eafd" translate="yes" xml:space="preserve">
          <source>While the following guidelines describe the use of each type and their typical characteristics, in real world apps, you may see hybrids.</source>
          <target state="translated">다음 지침에서는 각 유형의 사용과 일반적인 특성에 대해 설명하지만 실제 앱에서는 하이브리드가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eedac9919ab146128bc64496dc8509fb9883c9f9" translate="yes" xml:space="preserve">
          <source>While the guard doesn't have to know which component has a deactivate method, it can detect that the &lt;code&gt;CrisisDetailComponent&lt;/code&gt; component has the &lt;code&gt;canDeactivate()&lt;/code&gt; method and call it. The guard not knowing the details of any component's deactivation method makes the guard reusable.</source>
          <target state="translated">경비원은 비활성화 메서드가있는 구성 요소를 알 필요는 &lt;code&gt;CrisisDetailComponent&lt;/code&gt; 구성 요소에 &lt;code&gt;canDeactivate()&lt;/code&gt; 메서드 가 있는지 감지 하여 호출 할 수 있습니다. 가드는 구성 요소의 비활성화 방법에 대한 세부 정보를 모르면 가드를 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="322f024cb227e4947bae54501a104f55a7646140" translate="yes" xml:space="preserve">
          <source>While the name &lt;code&gt;root&lt;/code&gt; is a special alias, other &lt;code&gt;ModuleInjector&lt;/code&gt;s don't have aliases. You have the option to create &lt;code&gt;ModuleInjector&lt;/code&gt;s whenever a dynamically loaded component is created, such as with the Router, which will create child &lt;code&gt;ModuleInjector&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;root&lt;/code&gt; 이름 은 특수한 별칭이지만 다른 &lt;code&gt;ModuleInjector&lt;/code&gt; 에는 별칭이 없습니다. 당신이 만들 수있는 옵션이 &lt;code&gt;ModuleInjector&lt;/code&gt; 의 동적으로로드 된 구성 요소는 이러한 아동이 생성됩니다 라우터와 같이 생성 될 때마다 &lt;code&gt;ModuleInjector&lt;/code&gt; 의.</target>
        </trans-unit>
        <trans-unit id="1d767a5a85783201556264a61318d016cc2125ea" translate="yes" xml:space="preserve">
          <source>While the router uses the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries&quot;&gt;HTML5 pushState&lt;/a&gt; style by default, you &lt;em&gt;must&lt;/em&gt; configure that strategy with a &lt;strong&gt;base href&lt;/strong&gt;.</source>
          <target state="translated">라우터는 기본적으로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries&quot;&gt;HTML5 pushState&lt;/a&gt; 스타일을 사용하지만 &lt;strong&gt;base href로&lt;/strong&gt; 해당 전략을 구성 &lt;em&gt;해야&lt;/em&gt; 합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37bd273b858b7de999c7d31f5f1d63976a206878" translate="yes" xml:space="preserve">
          <source>While the router uses the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries&quot;&gt;HTML5 pushState&lt;/a&gt; style by default, you must configure that strategy with a &lt;code&gt;&amp;lt;base href&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">라우터는 기본적으로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries&quot;&gt;HTML5 pushState&lt;/a&gt; 스타일을 사용하지만 &lt;code&gt;&amp;lt;base href&amp;gt;&lt;/code&gt; 를 사용하여 해당 전략을 구성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="01d95e9caebba56bfe90c85d978bfaab15d3c180" translate="yes" xml:space="preserve">
          <source>While the subscription is active, Service Worker listens for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PushEvent&quot;&gt;PushEvent&lt;/a&gt; occurrences and creates &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Notification&quot;&gt;Notification&lt;/a&gt; instances in response.</source>
          <target state="translated">구독이 활성화 된 동안 Service Worker는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PushEvent&quot;&gt;PushEvent&lt;/a&gt; 발생을 수신 하고 응답으로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Notification&quot;&gt;Notification&lt;/a&gt; 인스턴스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="e91af09c132542b901dc969980ed9ae882ac1705" translate="yes" xml:space="preserve">
          <source>While there's rarely a good reason to apply a structural directive in template &lt;em&gt;attribute&lt;/em&gt; or &lt;em&gt;element&lt;/em&gt; form, it's still important to know that Angular creates a &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; and to understand how it works. You'll refer to the &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; when you &lt;a href=&quot;structural-directives#unless&quot;&gt;write your own structural directive&lt;/a&gt;.</source>
          <target state="translated">템플릿 &lt;em&gt;속성&lt;/em&gt; 또는 &lt;em&gt;요소&lt;/em&gt; 형식 으로 구조적 지시문을 적용 할만한 이유는 거의 없지만 Angular는 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 을 만들고 작동 방식을 이해해야합니다. &lt;a href=&quot;structural-directives#unless&quot;&gt;자신 만의 구조적 지시문&lt;/a&gt; 을 작성할 때 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="13ac445e8a260522faf3df163997d45a5d55783f" translate="yes" xml:space="preserve">
          <source>While these default criteria are fine in most cases, it is sometimes desirable to configure different rules. For example, you may want to ignore specific routes (that are not part of the Angular app) and pass them through to the server.</source>
          <target state="translated">대부분의 경우 이러한 기본 기준이 적합하지만 다른 규칙을 구성하는 것이 바람직한 경우가 있습니다. 예를 들어 Angular 앱의 일부가 아닌 특정 경로를 무시하고 서버로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f9227406655f727bc3b335fbb57e7ecad4435de" translate="yes" xml:space="preserve">
          <source>While this app doesn't have a route to the &lt;code&gt;HeroDetailComponent&lt;/code&gt; that omits the &lt;code&gt;id&lt;/code&gt; parameter, it might add such a route someday. The component should do something reasonable when there is no &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">이 앱에는 &lt;code&gt;id&lt;/code&gt; 매개 변수 를 생략하는 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 에 대한 경로가 없지만 언젠가는 해당 경로를 추가 할 수 있습니다. 구성 요소는 &lt;code&gt;id&lt;/code&gt; 가 없을 때 합리적인 작업을 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3db01e5de077841c6ee63df60c8eb095a471b993" translate="yes" xml:space="preserve">
          <source>While this is a base class that NgClass extends from, the class itself acts as a container for non-VE code to setup a link to the &lt;code&gt;[class]&lt;/code&gt; host binding (via the static &lt;code&gt;ngDirectiveDef&lt;/code&gt; property on the class).</source>
          <target state="translated">이 클래스는 NgClass가 확장하는 기본 클래스이지만 클래스 자체는 &lt;code&gt;[class]&lt;/code&gt; VE ] 호스트 바인딩에 대한 링크를 설정하기위한 비 VE 코드의 컨테이너 역할을합니다 (클래스 의 정적 &lt;code&gt;ngDirectiveDef&lt;/code&gt; 속성을 통해).</target>
        </trans-unit>
        <trans-unit id="40a33dd6773969d82d18d1f0e4b8284401f3f3fa" translate="yes" xml:space="preserve">
          <source>While this is a base class that NgStyle extends from, the class itself acts as a container for non-VE code to setup a link to the &lt;code&gt;[&lt;a href=&quot;../animations/style&quot;&gt;style&lt;/a&gt;]&lt;/code&gt; host binding (via the static &lt;code&gt;ngDirectiveDef&lt;/code&gt; property on the class).</source>
          <target state="translated">이 클래스는 NgStyle이 확장하는 기본 클래스이지만 클래스 자체는 VE가 아닌 코드의 컨테이너 역할을하여 클래스 의 정적 &lt;code&gt;ngDirectiveDef&lt;/code&gt; 속성을 통해 &lt;code&gt;[&lt;a href=&quot;../animations/style&quot;&gt;style&lt;/a&gt;]&lt;/code&gt; 호스트 바인딩에 대한 링크를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="1557d255fa555f2461a9fc1ea6d89f6d4f9550b5" translate="yes" xml:space="preserve">
          <source>While this technique is suitable for toggling a single class name, consider the &lt;a href=&quot;template-syntax#ngClass&quot;&gt;&lt;code&gt;NgClass&lt;/code&gt;&lt;/a&gt; directive when managing multiple class names at the same time.</source>
          <target state="translated">이 기술은 단일 클래스 이름을 토글하는 데 적합하지만 동시에 여러 클래스 이름을 관리 할 때 &lt;a href=&quot;template-syntax#ngClass&quot;&gt; &lt;code&gt;NgClass&lt;/code&gt; &lt;/a&gt; 지시문을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="f03df879982808cab6e039552bc7f433d15c9f09" translate="yes" xml:space="preserve">
          <source>While users can navigate your application using the links you added in the previous section, they don't have an easy way to identify what the active route is. You can add this functionality using Angular's &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive&quot;&gt;routerLinkActive&lt;/a&gt;&lt;/code&gt; directive.</source>
          <target state="translated">사용자는 이전 섹션에서 추가 한 링크를 사용하여 애플리케이션을 탐색 할 수 있지만 활성 경로가 무엇인지 쉽게 식별 할 수는 없습니다. Angular의 &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive&quot;&gt;routerLinkActive&lt;/a&gt;&lt;/code&gt; 지시문을 사용하여이 기능을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d971e439874c00bf97336a91204c83d31c4d88b7" translate="yes" xml:space="preserve">
          <source>While working on a published library, you can use &lt;a href=&quot;https://docs.npmjs.com/cli/link&quot;&gt;npm link&lt;/a&gt; to avoid reinstalling the library on every build.</source>
          <target state="translated">게시 된 라이브러리에서 작업하는 동안 &lt;a href=&quot;https://docs.npmjs.com/cli/link&quot;&gt;npm 링크&lt;/a&gt; 를 사용 하여 모든 빌드에서 라이브러리를 다시 설치하지 않아도됩니다 .</target>
        </trans-unit>
        <trans-unit id="b24ca2e39219949e690787fe118cba513f0fcb23" translate="yes" xml:space="preserve">
          <source>While you can put more than one component tree on a host web page, most applications have only one component tree and bootstrap a single root component.</source>
          <target state="translated">호스트 웹 페이지에 둘 이상의 구성 요소 트리를 둘 수 있지만 대부분의 응용 프로그램에는 하나의 구성 요소 트리 만 있고 단일 루트 구성 요소를 부트 스트랩합니다.</target>
        </trans-unit>
        <trans-unit id="2995520f0730c6fe7aaf62a242e0e3198f2ff20b" translate="yes" xml:space="preserve">
          <source>While you can translate non-displayed text using a &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; tag, you are creating a new DOM element. To avoid doing so, wrap the text in an &lt;code&gt;&amp;lt;ng-container&amp;gt;&lt;/code&gt; element, which is transformed into a non-displayed HTML comment as shown in this example:</source>
          <target state="translated">&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 태그를 사용하여 표시되지 않은 텍스트를 번역 할 수 있지만 새 DOM 요소를 생성합니다. 이를 방지하려면 다음 예와 같이 표시되지 않는 HTML 주석으로 변환되는 &lt;code&gt;&amp;lt;ng-container&amp;gt;&lt;/code&gt; 요소에 텍스트를 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="7e225fb4c7e87b7b1778b247651d232843aa3aba" translate="yes" xml:space="preserve">
          <source>While you could call &lt;code&gt;getHeroes()&lt;/code&gt; in the constructor, that's not the best practice.</source>
          <target state="translated">생성자에서 &lt;code&gt;getHeroes()&lt;/code&gt; 를 호출 할 수 있지만 최선의 방법은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a0fae3fec8db9b133701c092b5757d24ffb7e3ae" translate="yes" xml:space="preserve">
          <source>While you could continue to add files to the &lt;code&gt;src/app/&lt;/code&gt; folder, that is unrealistic and ultimately not maintainable. Most developers prefer to put each feature area in its own folder.</source>
          <target state="translated">&lt;code&gt;src/app/&lt;/code&gt; 폴더 에 파일을 계속 추가 할 수는 있지만 비현실적이며 궁극적으로는 유지 관리 할 수 ​​없습니다. 대부분의 개발자는 각 기능 영역을 자체 폴더에 배치하는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="ab6a43c0bf8f0d40672e23efd7b8429687eb1e22" translate="yes" xml:space="preserve">
          <source>Why &quot;ngModel&quot;? A directive's &lt;a href=&quot;../api/core/directive&quot;&gt;exportAs&lt;/a&gt; property tells Angular how to link the reference variable to the directive. You set &lt;code&gt;name&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; because the &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; directive's &lt;code&gt;exportAs&lt;/code&gt; property happens to be &quot;ngModel&quot;.</source>
          <target state="translated">왜 &quot;ngModel&quot;입니까? 지시문의 &lt;a href=&quot;../api/core/directive&quot;&gt;exportAs&lt;/a&gt; 속성은 Angular에 참조 변수를 지시문에 연결하는 방법을 알려줍니다. &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 지시문의 &lt;code&gt;exportAs&lt;/code&gt; 속성이 &quot;ngModel&quot; 이므로 &lt;code&gt;name&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 로 설정했습니다 .</target>
        </trans-unit>
        <trans-unit id="d318f1063bfb5cd9dacbb5931bfa402cc527970e" translate="yes" xml:space="preserve">
          <source>Why &lt;code&gt;remove&lt;/code&gt; rather than &lt;code&gt;hide&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;hide&lt;/code&gt; 않고 &lt;code&gt;remove&lt;/code&gt; 해야하는 이유는 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="5e5069bc0dde0d06f00638f22a1b23e5b6061f68" translate="yes" xml:space="preserve">
          <source>Why check &lt;em&gt;dirty&lt;/em&gt; and &lt;em&gt;touched&lt;/em&gt;?</source>
          <target state="translated">왜 체크 &lt;em&gt;오염&lt;/em&gt; 과 &lt;em&gt;감동&lt;/em&gt; ?</target>
        </trans-unit>
        <trans-unit id="cdde1e44b5df9e7b5ee6f951fb7ffd01c1fe5ee3" translate="yes" xml:space="preserve">
          <source>Why declare &lt;em&gt;angular&lt;/em&gt; as &lt;em&gt;angular.IAngularStatic&lt;/em&gt;?</source>
          <target state="translated">&lt;em&gt;angular&lt;/em&gt; 를 &lt;em&gt;angular.IAngularStatic으로&lt;/em&gt; 선언하는 이유는 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="77edc57f32ccba69520fd34fd76f444ba728688a" translate="yes" xml:space="preserve">
          <source>Why does Angular need &lt;code&gt;entryComponents&lt;/code&gt;?</source>
          <target state="translated">Angular에 &lt;code&gt;entryComponents&lt;/code&gt; 가 필요한 이유는 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="51611ead610693f8035df03d882f55fdb9029100" translate="yes" xml:space="preserve">
          <source>Why does lazy loading create a child injector?</source>
          <target state="translated">왜 게으른 로딩이 하위 인젝터를 생성합니까?</target>
        </trans-unit>
        <trans-unit id="4eec386f35248e79e61fc00c25f2064798d6b68d" translate="yes" xml:space="preserve">
          <source>Why does the &lt;code&gt;doSomething()&lt;/code&gt; method wait a tick before updating &lt;code&gt;comment&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;doSomething()&lt;/code&gt; 메소드가 &lt;code&gt;comment&lt;/code&gt; 을 업데이트하기 전에 틱을 기다리는 이유는 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="eb31703be46c50bbc7eaa00a5535907610777ee9" translate="yes" xml:space="preserve">
          <source>Why doesn't Angular add lazy-loaded providers to the app root injector as it does for eagerly loaded NgModules?</source>
          <target state="translated">Angular는 열악하게로드 된 NgModules와 같이 앱 루트 인젝터에 게으른로드 된 공급자를 추가하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="1854ce5e4b6793b5d1ae83050374ba97c6c3c00c" translate="yes" xml:space="preserve">
          <source>Why is a service provided in a feature module visible everywhere?</source>
          <target state="translated">기능 모듈에서 제공되는 서비스가 모든 곳에 표시되는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="7f854e990dd8ef12c3bfdefa6688b2c3721f6c5b" translate="yes" xml:space="preserve">
          <source>Why is a service provided in a lazy-loaded module visible only to that module?</source>
          <target state="translated">지연로드 된 모듈로 제공되는 서비스가 해당 모듈에만 표시되는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="8c6b2ade23fd30b08eb34573829d5d3555214a81" translate="yes" xml:space="preserve">
          <source>Why is it bad if a shared module provides a service to a lazy-loaded module?</source>
          <target state="translated">공유 모듈이 지연로드 된 모듈에 서비스를 제공하는 경우 왜 나쁜가요?</target>
        </trans-unit>
        <trans-unit id="2e4580536b0f2359910adb76e50ba348f206ca0a" translate="yes" xml:space="preserve">
          <source>Why it works</source>
          <target state="translated">작동하는 이유</target>
        </trans-unit>
        <trans-unit id="c61aec305e608a6380d5ef5d9610794a4acd19c7" translate="yes" xml:space="preserve">
          <source>Why list the same component in multiple &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; properties?</source>
          <target state="translated">여러 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 속성 에 동일한 구성 요소를 나열하는 이유는 무엇 입니까?</target>
        </trans-unit>
        <trans-unit id="4b4def911c2cbfb92404d9a60708df645ca4036b" translate="yes" xml:space="preserve">
          <source>Why not &quot;highlight&quot;?</source>
          <target state="translated">왜 &quot;강조 표시&quot;하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="9e9f3c21f34bc99e2a0bc838edaf643242816b11" translate="yes" xml:space="preserve">
          <source>Why not defer DOM integration tests to end-to-end (E2E) testing?</source>
          <target state="translated">DOM 통합 테스트를 엔드 투 엔드 (E2E) 테스트로 연기하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="f0c9e7d2fbfbc176f66d88e4130920bb0d8e5e6d" translate="yes" xml:space="preserve">
          <source>Why not rely on E2E tests of DOM integration?</source>
          <target state="translated">DOM 통합의 E2E 테스트에 의존하지 않는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ba6cd6fa33a570d67aedda554c42dca77ff31e43" translate="yes" xml:space="preserve">
          <source>Why put spec file next to the file it tests?</source>
          <target state="translated">사양 파일을 테스트하는 파일 옆에 배치해야하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="12078275c72479f3331dcc17b12caa18d03a9c98" translate="yes" xml:space="preserve">
          <source>Why services</source>
          <target state="translated">왜 서비스</target>
        </trans-unit>
        <trans-unit id="430ea9adf8d91815946ba4f13ebf65a6528dc6b9" translate="yes" xml:space="preserve">
          <source>Why use server-side rendering?</source>
          <target state="translated">서버 측 렌더링을 사용해야하는 이유</target>
        </trans-unit>
        <trans-unit id="58eb6efb5ee2ce76380afc566adebeb87b29c2a6" translate="yes" xml:space="preserve">
          <source>Why would you use SVG as template, instead of simply adding it as image to your application?</source>
          <target state="translated">SVG를 단순히 이미지를 응용 프로그램에 이미지로 추가하는 대신 템플릿으로 사용하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="5e348a70aa9504ebb9cd2767488ed852755a1934" translate="yes" xml:space="preserve">
          <source>Why write a service?</source>
          <target state="translated">왜 서비스를 작성해야합니까?</target>
        </trans-unit>
        <trans-unit id="c4581c9bfa8088ce1bd486ec378845ae6496a3c3" translate="yes" xml:space="preserve">
          <source>Why you &lt;a href=&quot;structural-directives#one-per-element&quot;&gt;can only apply one structural directive&lt;/a&gt; to an element.</source>
          <target state="translated">요소에 &lt;a href=&quot;structural-directives#one-per-element&quot;&gt;하나의 구조적 지시문 만 적용&lt;/a&gt; 할 수있는 이유 .</target>
        </trans-unit>
        <trans-unit id="7320f16356458f846b9605ef64b13b7ecdd83423" translate="yes" xml:space="preserve">
          <source>Why you &lt;a href=&quot;structural-directives#the-asterisk--prefix&quot;&gt;prefix the directive name with an asterisk (*)&lt;/a&gt;.</source>
          <target state="translated">당신은 왜 &lt;a href=&quot;structural-directives#the-asterisk--prefix&quot;&gt;별표 (*)로 지시어 이름 앞에&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58c5b9f3361fe794e0551a73d476d4c73d87a3a4" translate="yes" xml:space="preserve">
          <source>Why you use it</source>
          <target state="translated">왜 사용 하는가</target>
        </trans-unit>
        <trans-unit id="9ec4d86f6bc5dfade050672f98a8b077a3af7db8" translate="yes" xml:space="preserve">
          <source>Wide</source>
          <target state="translated">Wide</target>
        </trans-unit>
        <trans-unit id="b920e278db060d5132eb85b067e6489cd9df8c17" translate="yes" xml:space="preserve">
          <source>Wide (fallback to &lt;code&gt;&lt;a href=&quot;../router/routerlinkwithhref&quot;&gt;a&lt;/a&gt;&lt;/code&gt; when missing)</source>
          <target state="translated">와이드 (에 폴백 없는 경우) &lt;code&gt;&lt;a href=&quot;../router/routerlinkwithhref&quot;&gt;a&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be7eb77ab67a75bdfd5c6e1433e701036125c95c" translate="yes" xml:space="preserve">
          <source>Wide images can be a problem. Most browsers try to rescale the image but wide images may overflow the document in certain viewports.</source>
          <target state="translated">넓은 이미지는 문제가 될 수 있습니다. 대부분의 브라우저는 이미지 크기를 조정하려고하지만 특정 뷰포트에서 넓은 이미지가 문서를 오버플로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df15305cc141d8294713eba43aaee44d1edfe3bd" translate="yes" xml:space="preserve">
          <source>Widget</source>
          <target state="translated">Widget</target>
        </trans-unit>
        <trans-unit id="6059a174fbd7360217d1f1806783371e4f423161" translate="yes" xml:space="preserve">
          <source>Widget NgModules</source>
          <target state="translated">위젯 NgModules</target>
        </trans-unit>
        <trans-unit id="e5ea2dcd242e9e2f7f8046f8332e2e4f97aa61fc" translate="yes" xml:space="preserve">
          <source>Widget feature modules.</source>
          <target state="translated">위젯 기능 모듈.</target>
        </trans-unit>
        <trans-unit id="4b22636bf684877a2ca0fddff96647d96827436c" translate="yes" xml:space="preserve">
          <source>Wild Cards</source>
          <target state="translated">와일드 카드</target>
        </trans-unit>
        <trans-unit id="e7838d3e850762e34afbc40f2627be6c7bd374b2" translate="yes" xml:space="preserve">
          <source>Wildcard state</source>
          <target state="translated">와일드 카드 상태</target>
        </trans-unit>
        <trans-unit id="019592ebc26ebe6bf40f0c3a3d02f90af2815eb4" translate="yes" xml:space="preserve">
          <source>Will be called for every request, so the token may change between requests.</source>
          <target state="translated">모든 요청에 ​​대해 호출되므로 토큰이 요청간에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="0fdc144c92056ab7d5f102c3d50ea2cefa690d68" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;i18n#merge-aot&quot;&gt;AOT&lt;/a&gt;, you pass the information as configuration settings.</source>
          <target state="translated">함께 &lt;a href=&quot;i18n#merge-aot&quot;&gt;AOT&lt;/a&gt; , 당신은 구성 설정과 같은 정보를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="1d09f298abe9a7fc875ef158d461d408d20664a6" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;i18n#merge-jit&quot;&gt;JIT&lt;/a&gt;, you provide the information at bootstrap time.</source>
          <target state="translated">으로 &lt;a href=&quot;i18n#merge-jit&quot;&gt;JIT&lt;/a&gt; , 당신은 부트 스트랩 시간에 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="200c19c0c9f56cf91684c9502f9b1d3d09288928" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;*&lt;a href=&quot;api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; repeats for each product in the list.</source>
          <target state="translated">함께 &lt;code&gt;*&lt;a href=&quot;api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 상기 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 반복 목록에서 각 제품.</target>
        </trans-unit>
        <trans-unit id="ede514d5069525070eaec694f407a46910806109" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;itemForm&lt;/code&gt; is a reference to the &lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt; directive with the ability to track the value and validity of every control in the form.</source>
          <target state="translated">함께 &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;itemForm&lt;/code&gt; 을 받는 기준이다 &lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm의&lt;/a&gt; 형태로 모든 제어의 유효 값을 추적하는 기능을 지정.</target>
        </trans-unit>
        <trans-unit id="0ecc3b0f037e8e08430e46acd7c70c807c3b3ffb" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt;, the two change detection systems are tied together more tightly. Whenever something happens in the AngularJS part of the app, change detection is automatically triggered on the Angular part and vice versa. This is convenient as it ensures that neither framework misses an important change. Most of the time, though, these extra change detection runs are unnecessary.</source>
          <target state="translated">로 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; , 두 변경 감지 시스템은 더 단단하게 연결되어 있습니다. 앱의 AngularJS 부분에서 무언가가 발생할 때마다 변경 감지가 Angular 부분에서 자동으로 트리거되며 그 반대도 마찬가지입니다. 이것은 어느 프레임 워크도 중요한 변화를 놓치지 않도록하기 때문에 편리합니다. 그러나 대부분의 경우 이러한 추가 변경 감지 실행이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ab2c912f60573267ca8c0c610d5904df837d8b8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt;, Angular passes the value for &lt;code&gt;currentItem&lt;/code&gt; to the child so that &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; renders as &lt;code&gt;Television&lt;/code&gt;.</source>
          <target state="translated">함께 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 각도를 값 통과 &lt;code&gt;currentItem&lt;/code&gt; 하도록 아이에게이 &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; 으로 렌더링 &lt;code&gt;Television&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b21a2ef9baf43478ec5a0b30cbfdc6df0f9a348e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt;, Angular passes the value for &lt;code&gt;currentItem&lt;/code&gt; to the child so that &lt;code&gt;item&lt;/code&gt; renders as &lt;code&gt;Television&lt;/code&gt;.</source>
          <target state="translated">함께 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 각도를 값 통과 &lt;code&gt;currentItem&lt;/code&gt; 하도록 아이에게이 &lt;code&gt;item&lt;/code&gt; 으로 렌더링 &lt;code&gt;Television&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1571093943d515929c4d2ad37e20dc85fb0cb242" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; in the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt;, the injector begins its search for the &lt;code&gt;AnimalService&lt;/code&gt; in the &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt;&lt;code&gt;ElementInjector&lt;/code&gt; and finds 🐳 (whale).</source>
          <target state="translated">함께 &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; 에서 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; , 인젝터는 자사 검색을 시작 &lt;code&gt;AnimalService&lt;/code&gt; 에서 &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; &lt;code&gt;ElementInjector&lt;/code&gt; 및 발견 🐳 (고래).</target>
        </trans-unit>
        <trans-unit id="514263be0a675439b526ac2db882f2028e8a6caa" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt;, the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; injector doesn't look to itself for the &lt;code&gt;FlowerService&lt;/code&gt;. Instead, the injector starts looking for the &lt;code&gt;FlowerService&lt;/code&gt; at the &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt;'s &lt;code&gt;ElementInjector&lt;/code&gt;, where it finds nothing. Then, it goes back to the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt;&lt;code&gt;ModuleInjector&lt;/code&gt; and finds the 🌺 (red hibiscus) value, which is available because the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt;&lt;code&gt;ModuleInjector&lt;/code&gt; and the &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt;&lt;code&gt;ModuleInjector&lt;/code&gt; are flattened into one &lt;code&gt;ModuleInjector&lt;/code&gt;. Thus, the UI renders the following:</source>
          <target state="translated">와 &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; 는 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; 인젝터를위한 자체에 보이지 않는 &lt;code&gt;FlowerService&lt;/code&gt; . 대신, 인젝터 는 &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; 의 &lt;code&gt;ElementInjector&lt;/code&gt; 에서 &lt;code&gt;FlowerService&lt;/code&gt; 를 찾기 시작합니다 . 여기서 아무것도 찾지 않습니다. 그런 다음 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; &lt;code&gt;ModuleInjector&lt;/code&gt; 로 돌아가서 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; &lt;code&gt;ModuleInjector&lt;/code&gt; 및 &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; &lt;code&gt;ModuleInjector&lt;/code&gt; 가 하나의 &lt;code&gt;ModuleInjector&lt;/code&gt; 로 병합되어 사용할 수있는 🌺 (빨간색 히비스커스) 값을 찾습니다 . 따라서 UI는 다음을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="fb338d53ab27a026f259345ae4de8e033045fa9e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;providedIn: 'any'&lt;/code&gt;, all eagerly loaded modules share a singleton instance; however, lazy loaded modules each get their own unique instance, as shown in the following diagram.</source>
          <target state="translated">함께 &lt;code&gt;providedIn: 'any'&lt;/code&gt; 모든 열망로드 모듈은 싱글 인스턴스를 공유; 그러나 지연로드 된 모듈은 다음 다이어그램과 같이 각각 고유 한 인스턴스를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6aa81c5fc739583ab2d3afe1487e3a1975b85894" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;trackBy&lt;/code&gt;, only changing the &lt;code&gt;id&lt;/code&gt; triggers element replacement.</source>
          <target state="translated">&lt;code&gt;trackBy&lt;/code&gt; 를 사용 하면 &lt;code&gt;id&lt;/code&gt; 변경 만 요소 교체를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="2b2022ad5e54a76cb4f206c08caf298b2a25eec7" translate="yes" xml:space="preserve">
          <source>With Angular Universal, you can generate landing pages for the app that look like the complete app. The pages are pure HTML, and can display even if JavaScript is disabled. The pages don't handle browser events, but they &lt;em&gt;do&lt;/em&gt; support navigation through the site using &lt;a href=&quot;router#router-link&quot;&gt;&lt;code&gt;routerLink&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Angular Universal을 사용하면 완전한 앱처럼 보이는 앱의 랜딩 페이지를 생성 할 수 있습니다. 페이지는 순수한 HTML이며 JavaScript가 비활성화되어 있어도 표시 할 수 있습니다. 페이지는 브라우저 이벤트를 처리하지 않습니다,하지만 그들은 &lt;em&gt;어떻게&lt;/em&gt; 사용하여 사이트를 통해 지원 탐색을 &lt;a href=&quot;router#router-link&quot;&gt; &lt;code&gt;routerLink&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f8fe2ab51d493e8db841e87168ff2a0ac6f0c3e" translate="yes" xml:space="preserve">
          <source>With Angular version 8, the CLI Builder API is stable and available to developers who want to customize the Angular CLI by adding or modifying commands. For example, you could supply a builder to perform an entirely new task, or to change which third-party tool is used by an existing command.</source>
          <target state="translated">Angular 버전 8에서는 CLI Builder API가 안정적이며 명령을 추가하거나 수정하여 Angular CLI를 사용자 정의하려는 개발자가 사용할 수 있습니다. 예를 들어 완전히 새로운 작업을 수행하거나 기존 명령에서 사용하는 타사 도구를 변경하도록 빌더를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2a88e1a0148b4a6869805a7a6ac97dde9e0ff28" translate="yes" xml:space="preserve">
          <source>With CSS imports.</source>
          <target state="translated">CSS 가져 오기</target>
        </trans-unit>
        <trans-unit id="04ef0a6078a8aea6fbe95f9747112cfdcf3328a3" translate="yes" xml:space="preserve">
          <source>With a pure pipe, Angular ignores changes within composite objects, such as a newly added element of an existing array, because checking a primitive value or object reference is much faster than performing a deep check for differences within objects. Angular can quickly determine if it can skip executing the pipe and updating the view.</source>
          <target state="translated">순수 파이프를 사용하는 경우 Angular는 기존 배열의 새로 추가 된 요소와 같은 복합 객체 내의 변경 사항을 무시합니다. 왜냐하면 원시 값이나 객체 참조를 확인하는 것이 객체 내의 차이를 자세히 확인하는 것보다 훨씬 빠르기 때문입니다. Angular는 파이프 실행과 뷰 업데이트를 건너 뛸 수 있는지 신속하게 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28c19341986c17ccc8e81e83b8da588a7aa5dbaa" translate="yes" xml:space="preserve">
          <source>With any object-like expression&amp;mdash;such as &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, or &lt;code&gt;Set&lt;/code&gt;&amp;mdash;the identity of the object must change for Angular to update the class list. Updating the property without changing object identity has no effect.</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; , &lt;code&gt;Array&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; 또는 &lt;code&gt;Set&lt;/code&gt; 과 같은 객체 와 유사한 표현식 을 사용하면 Angular가 클래스 목록을 업데이트하려면 객체의 ID를 변경해야합니다. 객체 ID를 변경하지 않고 속성을 업데이트해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf0a79766c3bc1ba070745fe39181ae5fe7be150" translate="yes" xml:space="preserve">
          <source>With data-binding, you can control things like the state of a button:</source>
          <target state="translated">데이터 바인딩을 사용하면 버튼 상태와 같은 것을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea72b360c242124f4790aba963e3f3a802795bd4" translate="yes" xml:space="preserve">
          <source>With interception, you declare &lt;em&gt;interceptors&lt;/em&gt; that inspect and transform HTTP requests from your application to a server. The same interceptors can also inspect and transform a server's responses on their way back to the application. Multiple interceptors form a &lt;em&gt;forward-and-backward&lt;/em&gt; chain of request/response handlers.</source>
          <target state="translated">인터 셉션을 사용하면 애플리케이션에서 서버로 HTTP 요청을 검사하고 변환하는 &lt;em&gt;인터셉터&lt;/em&gt; 를 선언 합니다. 동일한 인터셉터는 애플리케이션으로 돌아가는 도중에 서버의 응답을 검사하고 변환 할 수도 있습니다. 다중 인터셉터 는 요청 / 응답 핸들러의 &lt;em&gt;앞뒤&lt;/em&gt; 체인을 형성합니다 .</target>
        </trans-unit>
        <trans-unit id="a3e8732f285a06169348c283028ee3640fff4b7a" translate="yes" xml:space="preserve">
          <source>With its &lt;code&gt;getAds()&lt;/code&gt; method, &lt;code&gt;AdBannerComponent&lt;/code&gt; cycles through the array of &lt;code&gt;AdItems&lt;/code&gt; and loads a new component every 3 seconds by calling &lt;code&gt;loadComponent()&lt;/code&gt;.</source>
          <target state="translated">그와 &lt;code&gt;getAds()&lt;/code&gt; 메소드 &lt;code&gt;AdBannerComponent&lt;/code&gt; 의 배열을 통해 순환 &lt;code&gt;AdItems&lt;/code&gt; 호출하여로드 새로운 컴포넌트를 매 3 초마다 &lt;code&gt;loadComponent()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ceb2407ccef6b0bf3e482eb7d304bbdcd717820" translate="yes" xml:space="preserve">
          <source>With no &lt;code&gt;trackBy&lt;/code&gt;, both buttons trigger complete DOM element replacement.</source>
          <target state="translated">&lt;code&gt;trackBy&lt;/code&gt; 가 없으면 두 버튼 모두 완전한 DOM 요소 교체를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="79ef6a65be0e36c1f90e385b3612665ea585aa49" translate="yes" xml:space="preserve">
          <source>With reactive forms, set the property in the &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">반응 형 양식을 사용하면 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 속성을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="536e3572a460f32cd6bdb3410223e623acf76f40" translate="yes" xml:space="preserve">
          <source>With reactive forms, the &lt;strong&gt;&lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; instance&lt;/strong&gt; always returns a new value when the control's value is updated.</source>
          <target state="translated">반응 형을 사용 하면 컨트롤 값이 업데이트 될 때 &lt;strong&gt; &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 인스턴스가&lt;/strong&gt; 항상 새 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5e2c684a98820d22704c39326e7146086ace1878" translate="yes" xml:space="preserve">
          <source>With reactive forms, the form model is explicitly defined in the component class. The reactive form directive (in this case, &lt;code&gt;&lt;a href=&quot;../api/forms/formcontroldirective&quot;&gt;FormControlDirective&lt;/a&gt;&lt;/code&gt;) then links the existing &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; instance to a specific form element in the view using a value accessor (&lt;code&gt;&lt;a href=&quot;../api/forms/controlvalueaccessor&quot;&gt;ControlValueAccessor&lt;/a&gt;&lt;/code&gt; instance).</source>
          <target state="translated">반응 양식을 사용하면 양식 모델이 컴포넌트 클래스에 명시 적으로 정의됩니다. 반응 형 지시문 (이 경우 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontroldirective&quot;&gt;FormControlDirective&lt;/a&gt;&lt;/code&gt; )은 값 접근 자 ( &lt;code&gt;&lt;a href=&quot;../api/forms/controlvalueaccessor&quot;&gt;ControlValueAccessor&lt;/a&gt;&lt;/code&gt; 인스턴스)를사용하여기존 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 인스턴스를보기의 특정 양식 요소에링크합니다.</target>
        </trans-unit>
        <trans-unit id="97cec0a9ecc4f71051165d4067c1a202dd87fd6b" translate="yes" xml:space="preserve">
          <source>With reactive forms, you define the form model directly in the component class. The &lt;code&gt;[formControl]&lt;/code&gt; directive links the explicitly created &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; instance to a specific form element in the view, using an internal value accessor.</source>
          <target state="translated">반응 형 양식을 사용하면 구성 요소 클래스에서 직접 양식 모델을 정의 할 수 있습니다. &lt;code&gt;[formControl]&lt;/code&gt; 지정 링크 명시 적으로 생성 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 의 내부 값에 접근을 사용하여 도면에서 특정 형태의 요소에 대한 예.</target>
        </trans-unit>
        <trans-unit id="2d05e69e43f92be76d996dab286009e2290f7866" translate="yes" xml:space="preserve">
          <source>With reactive forms:</source>
          <target state="translated">반응성 형태 :</target>
        </trans-unit>
        <trans-unit id="37d58d7c1f47e889b4dc2776053c30fac3a08f9a" translate="yes" xml:space="preserve">
          <source>With special Angular syntax in your templates, you can extend the HTML vocabulary of your apps. For example, Angular helps you get and set DOM (Document Object Model) values dynamically with features such as built-in template functions, variables, event listening, and data binding.</source>
          <target state="translated">템플릿의 특별한 Angular 구문을 사용하여 앱의 HTML 어휘를 확장 할 수 있습니다. 예를 들어 Angular는 기본 제공 템플릿 함수, 변수, 이벤트 수신 및 데이터 바인딩과 같은 기능을 사용하여 DOM (문서 개체 모델) 값을 동적으로 가져오고 설정할 수 있도록 도와줍니다.</target>
        </trans-unit>
        <trans-unit id="702e65afd28c65f60593357a4ee2316aa7e23b85" translate="yes" xml:space="preserve">
          <source>With structural directives, such as &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt;, there is no way for Angular to know if a template is ever instantiated.</source>
          <target state="translated">&lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 와 같은 구조적 지시문을 사용하면 Angular가 템플릿이 인스턴스화되었는지 여부를 알 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d0daff6f8a2fee3b6ac59882c4f8ae95cb2c91b5" translate="yes" xml:space="preserve">
          <source>With template-driven forms, set the property in the template.</source>
          <target state="translated">템플릿 기반 양식을 사용하여 템플릿에서 속성을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="019eb643284aded107e069dd6344db97a92357fe" translate="yes" xml:space="preserve">
          <source>With template-driven forms, the &lt;strong&gt;favorite color property&lt;/strong&gt; is always modified to its new value.</source>
          <target state="translated">템플릿 기반 양식을 사용하면 &lt;strong&gt;자주 사용하는 색상 속성&lt;/strong&gt; 이 항상 새 값으로 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="19e073dfecca90c0a9f77a20bb44682814b67a82" translate="yes" xml:space="preserve">
          <source>With template-driven forms:</source>
          <target state="translated">템플릿 기반 양식으로 :</target>
        </trans-unit>
        <trans-unit id="be8d82817001ae7961e2f4110b21a1426c5b5835" translate="yes" xml:space="preserve">
          <source>With that concern in mind, implement an impure pipe with great care. An expensive, long-running pipe could destroy the user experience.</source>
          <target state="translated">이러한 우려를 염두에두고 불순한 파이프를 신중하게 구현하십시오. 고가의 장기 배관은 사용자 경험을 파괴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08f5cfc92b9e57c5269817cc98d1f5ea4a41a524" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;http://www.learnrxjs.io/operators/transformation/switchmap.html&quot;&gt;switchMap operator&lt;/a&gt;, every qualifying key event can trigger an &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#get&quot;&gt;HttpClient.get()&lt;/a&gt;&lt;/code&gt; method call. Even with a 300ms pause between requests, you could have multiple HTTP requests in flight and they may not return in the order sent.</source>
          <target state="translated">&lt;a href=&quot;http://www.learnrxjs.io/operators/transformation/switchmap.html&quot;&gt;switchMap 연산자를&lt;/a&gt; 사용하면 모든 한정 키 이벤트가 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#get&quot;&gt;HttpClient.get()&lt;/a&gt;&lt;/code&gt; 메소드 호출을. 요청간에 300ms의 일시 중지가 있어도 여러 HTTP 요청이 비행 중일 수 있으며 전송 된 순서대로 반환되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2352f11932b7bff23ba7057bd735b9f485a4af13" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;ngUpgrade&lt;/code&gt; library in Angular you can upgrade an existing AngularJS app incrementally by building a hybrid app where you can run both frameworks side-by-side. In these hybrid apps you can mix and match AngularJS and Angular components and services and have them interoperate seamlessly. That means you don't have to do the upgrade work all at once as there is a natural coexistence between the two frameworks during the transition period.</source>
          <target state="translated">이랑 &lt;code&gt;ngUpgrade&lt;/code&gt; Angular ngUpgrade 라이브러리를 두 프레임 워크를 나란히 실행할 수있는 하이브리드 앱을 빌드하여 기존 AngularJS 앱을 점차적으로 업그레이드 할 수 있습니다. 이 하이브리드 앱에서 AngularJS와 Angular 구성 요소 및 서비스를 혼합하여 일치시키고 원활하게 상호 운용 할 수 있습니다. 즉, 전환 기간 동안 두 프레임 워크간에 자연스러운 공존이 있으므로 업그레이드 작업을 한 번에 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e49fed6a774119cf64d353ad3c70df3051c5887f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;value&lt;/code&gt; property, which gives you a snapshot of the current value.</source>
          <target state="translated">현재 값의 스냅 샷을 제공 하는 &lt;code&gt;value&lt;/code&gt; 속성을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="074ab19623556f09735ac122589456a92b46c9ef" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;value&lt;/code&gt; property. which gives you a snapshot of the current value.</source>
          <target state="translated">이랑 &lt;code&gt;value&lt;/code&gt; 속성입니다. 현재 값의 스냅 샷을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c3e2859d149c00a8c70f651753088ada705938fd" translate="yes" xml:space="preserve">
          <source>With the Angular CLI, you can configure your global styles in the &lt;code&gt;angular.json&lt;/code&gt; file. You can rename the extension to &lt;code&gt;.scss&lt;/code&gt; to use sass.</source>
          <target state="translated">Angular CLI를 사용하면 &lt;code&gt;angular.json&lt;/code&gt; 파일 에서 글로벌 스타일을 구성 할 수 있습니다 . 확장명을 &lt;code&gt;.scss&lt;/code&gt; 로 바꿀 수 있습니다sass를 사용하기 위해 로 .</target>
        </trans-unit>
        <trans-unit id="4cc1b5658039f71e373c05a8c2d298408717f4a9" translate="yes" xml:space="preserve">
          <source>With the addition of an Angular service worker, the application behavior changes. On a refresh, the page loads normally.</source>
          <target state="translated">Angular 서비스 워커를 추가하면 응용 프로그램 동작이 변경됩니다. 새로 고침하면 페이지가 정상적으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="1ed3fd9bd4c1f256dcc104023a64d45285ef0146" translate="yes" xml:space="preserve">
          <source>With the following code:</source>
          <target state="translated">다음 코드로</target>
        </trans-unit>
        <trans-unit id="e4ba2bf51920e50ddd76d0b8ce235609e5ca3f00" translate="yes" xml:space="preserve">
          <source>With the redirects setup, all previous routes now point to their new destinations and both URLs still function as intended.</source>
          <target state="translated">리디렉션 설정을 사용하면 이전의 모든 경로가 이제 새로운 목적지를 가리키고 두 URL이 여전히 의도 한대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7b7e14ba85f043cc2153d669ef641d59ce2ba6dc" translate="yes" xml:space="preserve">
          <source>With the safe navigation operator, &lt;code&gt;?&lt;/code&gt;, Angular stops evaluating the expression when it hits the first &lt;code&gt;null&lt;/code&gt; value and renders the view without errors.</source>
          <target state="translated">안전한 탐색 연산자를 사용하면 &lt;code&gt;?&lt;/code&gt; , Angular는 첫 번째 &lt;code&gt;null&lt;/code&gt; 값에 도달하면 표현식 평가를 중지 하고 오류없이 뷰를 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="e6501ec771a7fc4bae077d3c02ffac0e8b32870f" translate="yes" xml:space="preserve">
          <source>With the server running, you can point your browser at &lt;a href=&quot;http://localhost:8080/&quot;&gt;http://localhost:8080/&lt;/a&gt;. Your application should load normally.</source>
          <target state="translated">서버가 실행중인 상태에서 브라우저를 가리킬 수 있습니다 &lt;a href=&quot;http://localhost:8080/&quot;&gt; http : // localhost : 8080 /&lt;/a&gt; . 응용 프로그램이 정상적으로로드되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8fe7cf705023fd1c89ebb3c647e04c69d1bb4ec3" translate="yes" xml:space="preserve">
          <source>With the versioning behavior of the Angular service worker, an application server can ensure that the Angular app always has a consistent set of files.</source>
          <target state="translated">응용 프로그램 서버는 Angular 서비스 워커의 버전 관리 동작을 통해 Angular 앱에 항상 일관된 파일 세트가 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bb71e2cbafb7fa82e357e6678fde6dcf2a3a792" translate="yes" xml:space="preserve">
          <source>With this configuration, the view of &lt;code&gt;&amp;lt;app-item-detail&amp;gt;&lt;/code&gt; uses the value of &lt;code&gt;lamp&lt;/code&gt; for &lt;code&gt;childItem&lt;/code&gt;.</source>
          <target state="translated">이 구성의보기 &lt;code&gt;&amp;lt;app-item-detail&amp;gt;&lt;/code&gt; 의 값을 사용하는 &lt;code&gt;lamp&lt;/code&gt; 용 &lt;code&gt;childItem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2849f0172ab7aa7e6a7d8293fb4ce2777526ea4a" translate="yes" xml:space="preserve">
          <source>With this content:</source>
          <target state="translated">이 내용으로 :</target>
        </trans-unit>
        <trans-unit id="b8b31dcf9cc7c0459f402b08f8978242705682a6" translate="yes" xml:space="preserve">
          <source>With this example, the following actions occur:</source>
          <target state="translated">이 예에서는 다음 작업이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="089eb5172d3965ed3cdbcf88655204f69aa78b7a" translate="yes" xml:space="preserve">
          <source>WithProperties</source>
          <target state="translated">WithProperties</target>
        </trans-unit>
        <trans-unit id="9bda55462ad09ef63ca623f6eb47fb05236ec79c" translate="yes" xml:space="preserve">
          <source>Within a switch container, &lt;code&gt;*&lt;a href=&quot;ngswitchcase&quot;&gt;ngSwitchCase&lt;/a&gt;&lt;/code&gt; statements specify the match expressions as attributes. Include &lt;code&gt;*&lt;a href=&quot;ngswitchdefault&quot;&gt;ngSwitchDefault&lt;/a&gt;&lt;/code&gt; as the final case.</source>
          <target state="translated">스위치 컨테이너 내에서 &lt;code&gt;*&lt;a href=&quot;ngswitchcase&quot;&gt;ngSwitchCase&lt;/a&gt;&lt;/code&gt; 문은 일치 표현식을 속성으로 지정합니다. 포함 &lt;code&gt;*&lt;a href=&quot;ngswitchdefault&quot;&gt;ngSwitchDefault&lt;/a&gt;&lt;/code&gt; 마지막 경우 를 .</target>
        </trans-unit>
        <trans-unit id="5e7fc2910f937115866b1508ba85cfd25173fbfe" translate="yes" xml:space="preserve">
          <source>Within such a factory function, using this function to request injection of a dependency is faster and more type-safe than providing an additional array of dependencies (as has been common with &lt;code&gt;&lt;a href=&quot;factorysansprovider#useFactory&quot;&gt;useFactory&lt;/a&gt;&lt;/code&gt; providers).</source>
          <target state="translated">이러한 팩토리 함수 내에서이 함수를 사용하여 종속성 주입을 요청하는 것은 추가적인 의존성 배열을 제공하는 것보다 빠르며 유형 안전합니다 ( &lt;code&gt;&lt;a href=&quot;factorysansprovider#useFactory&quot;&gt;useFactory&lt;/a&gt;&lt;/code&gt; 에서 일반적으로 사용됨) 제공자 ).</target>
        </trans-unit>
        <trans-unit id="22803a3b39417d3e155ecdc540584686725394b8" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder#group&quot;&gt;group()&lt;/a&gt;&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder#group&quot;&gt;group()&lt;/a&gt;&lt;/code&gt; 내 () 함수 :</target>
        </trans-unit>
        <trans-unit id="5bfefa8920f5ed2b5462ebc174898aa7207d9f5f" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;group()&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;group()&lt;/code&gt; 함수 내에서 :</target>
        </trans-unit>
        <trans-unit id="7d1d21894554520cbe70ca3161889946066e8693" translate="yes" xml:space="preserve">
          <source>Within the container, &lt;code&gt;*&lt;a href=&quot;ngswitchcase&quot;&gt;ngSwitchCase&lt;/a&gt;&lt;/code&gt; statements specify the match expressions as attributes. Include &lt;code&gt;*&lt;a href=&quot;ngswitchdefault&quot;&gt;ngSwitchDefault&lt;/a&gt;&lt;/code&gt; as the final case.</source>
          <target state="translated">컨테이너 내에서 &lt;code&gt;*&lt;a href=&quot;ngswitchcase&quot;&gt;ngSwitchCase&lt;/a&gt;&lt;/code&gt; 문은 일치 표현식을 속성으로 지정합니다. 포함 &lt;code&gt;*&lt;a href=&quot;ngswitchdefault&quot;&gt;ngSwitchDefault&lt;/a&gt;&lt;/code&gt; 마지막 경우 를 .</target>
        </trans-unit>
        <trans-unit id="a7276b58b727c6c410427f99bc15652f439a152d" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;&lt;a href=&quot;../api/common/ngstyle&quot;&gt;NgStyle&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/common/ngstyle&quot;&gt;NgStyle&lt;/a&gt;&lt;/code&gt; 없이</target>
        </trans-unit>
        <trans-unit id="7fcf4d2f6736413b0fdde7ba35c562ec2b3ed296" translate="yes" xml:space="preserve">
          <source>Without a framework, you would be responsible for pushing data values into the HTML controls and turning user responses into actions and value updates. Writing such push and pull logic by hand is tedious, error-prone, and a nightmare to read, as any experienced front-end JavaScript programmer can attest.</source>
          <target state="translated">프레임 워크가 없으면 데이터 값을 HTML 컨트롤로 푸시하고 사용자 응답을 동작 및 값 업데이트로 전환해야합니다. 이러한 푸시 앤 풀 로직을 손으로 작성하는 것은 경험이 많은 프론트 엔드 JavaScript 프로그래머가 입증 할 수있는 것처럼 지루하고 오류가 발생하기 쉽고 악의적입니다.</target>
        </trans-unit>
        <trans-unit id="43acf4885e6d5e8186042e70023c71257f30d8b8" translate="yes" xml:space="preserve">
          <source>Without animations, web page transitions can seem abrupt and jarring.</source>
          <target state="translated">애니메이션이 없으면 웹 페이지 전환이 갑작스럽고 혼란스럽게 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cb1b66992897f9d72d43a66457c712e7332958e" translate="yes" xml:space="preserve">
          <source>Without interception, developers would have to implement these tasks &lt;em&gt;explicitly&lt;/em&gt; for each &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; method call.</source>
          <target state="translated">가로 채기없이 개발자는 각 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 에 대해 이러한 작업을 &lt;em&gt;명시 적으로&lt;/em&gt; 구현해야합니다. 메서드 호출 .</target>
        </trans-unit>
        <trans-unit id="d8159db5355a8ad440e87c125107146e2f6c4bc2" translate="yes" xml:space="preserve">
          <source>Without rewriting, this would be invalid because lambdas are not supported and &lt;code&gt;TypicalServer&lt;/code&gt; is not exported. To allow this, the compiler automatically rewrites this to something like:</source>
          <target state="translated">다시 쓰지 않으면 람다는 지원되지 않고 &lt;code&gt;TypicalServer&lt;/code&gt; 이므로 유효하지 않습니다. 되지 않고 가 내보내 않습니다. 이를 허용하기 위해 컴파일러는이를 다음과 같이 자동으로 다시 작성합니다.</target>
        </trans-unit>
        <trans-unit id="2e3ffa4d3a6e4aed13f90e17c4b731f4eab7541d" translate="yes" xml:space="preserve">
          <source>Without that tag, the browser may not be able to load resources (images, CSS, scripts) when &quot;deep linking&quot; into the app.</source>
          <target state="translated">이 태그가 없으면 브라우저가 앱에 '딥 링크'할 때 리소스 (이미지, CSS, 스크립트)를로드하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1929ccbff6f54303435c9d6a6e88229d090523b4" translate="yes" xml:space="preserve">
          <source>Without that tag, the browser may not be able to load resources (images, CSS, scripts) when &quot;deep linking&quot; into the app. Bad things could happen when someone pastes an application link into the browser's address bar or clicks such a link in an email.</source>
          <target state="translated">해당 태그가 없으면 앱에 &quot;딥 링크&quot;할 때 브라우저가 리소스 (이미지, CSS, 스크립트)를로드하지 못할 수 있습니다. 누군가가 응용 프로그램 링크를 브라우저의 주소 표시 줄에 붙여 넣거나 전자 메일에서 해당 링크를 클릭하면 나쁜 일이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c1228232946e2951f5383bc12ebcef8a71981bd" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;ngForm&lt;/a&gt;&lt;/code&gt; attribute value, the reference value of &lt;code&gt;itemForm&lt;/code&gt; would be the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement&quot;&gt;HTMLFormElement&lt;/a&gt;, &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;. There is, however, a difference between a &lt;code&gt;&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;&lt;/code&gt; in that Angular references a &lt;code&gt;&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; without specifying the attribute value, and a &lt;code&gt;&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;&lt;/code&gt; does not change the implicit reference, or the element.</source>
          <target state="translated">포함하지 않는 &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;ngForm&lt;/a&gt;&lt;/code&gt; 의 속성 값의 기준값 &lt;code&gt;itemForm&lt;/code&gt; 는 것 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement&quot;&gt;HTMLFormElement&lt;/a&gt; , &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; . 그러나 Angular 가 속성 값을 지정하지 않고 &lt;code&gt;&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; 를 참조 하고 &lt;code&gt;&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;&lt;/code&gt; 가 암시 적 참조 또는 요소를 변경하지 않는다는 점에서 &lt;code&gt;&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;&lt;/code&gt; 사이에는 차이 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="010c5880bd6415296c88290b8d4aadcb9cfb803c" translate="yes" xml:space="preserve">
          <source>Without those braces, JavaScript would only execute the first statement when you intend to conditionally execute all of them as a single block. The &lt;code&gt;&amp;lt;ng-container&amp;gt;&lt;/code&gt; satisfies a similar need in Angular templates.</source>
          <target state="translated">이러한 중괄호가 없으면 JavaScript는 모든 명령문을 단일 블록으로 조건부로 실행하려는 경우에만 첫 번째 명령문을 실행합니다. &lt;code&gt;&amp;lt;ng-container&amp;gt;&lt;/code&gt; 만족 각도 템플릿에서 비슷한 필요성을.</target>
        </trans-unit>
        <trans-unit id="aadc0ad5cc4c5793a614ff5b3c7e25171fbbb440" translate="yes" xml:space="preserve">
          <source>Work through the &lt;a href=&quot;tutorial&quot;&gt;Tour of Heroes Tutorial&lt;/a&gt;, a complete hands-on exercise that introduces you to the app development process using the Angular CLI and walks through important subsystems.</source>
          <target state="translated">스루 작업 &lt;a href=&quot;tutorial&quot;&gt;튜토리얼 영웅의 투어&lt;/a&gt; 응용 프로그램 개발 과정을 소개하고 당신이 각도 CLI를 사용하고 있음을, 완전한 운동 실습이 중요한 서브 시스템을 통해 안내합니다.</target>
        </trans-unit>
        <trans-unit id="6e222b598a7d48d0d0b644e8596e4232c84210cd" translate="yes" xml:space="preserve">
          <source>Work through the &lt;a href=&quot;tutorial&quot;&gt;Tour of Heroes&lt;/a&gt; tutorial to get a feel for how to fit the basic building blocks together to create a well-designed application.</source>
          <target state="translated">쓰루 워크 &lt;a href=&quot;tutorial&quot;&gt;영웅의 투어는&lt;/a&gt; 잘 설계된 응용 프로그램을 만들어 함께 기본적인 빌딩 블록에 맞게하는 방법에 대한 느낌을 얻기 위해 튜토리얼.</target>
        </trans-unit>
        <trans-unit id="aadd3af5807af48641989be57a49f65d1e8f1577" translate="yes" xml:space="preserve">
          <source>Work with translation files</source>
          <target state="translated">번역 파일 작업</target>
        </trans-unit>
        <trans-unit id="76958a0cd41a3ca4e5779435c35a550beb1958a9" translate="yes" xml:space="preserve">
          <source>WorkerAppModule</source>
          <target state="translated">WorkerAppModule</target>
        </trans-unit>
        <trans-unit id="d7a484140f5f9f7f5427e1f2c44dbfc1d3ad9eea" translate="yes" xml:space="preserve">
          <source>Workflow</source>
          <target state="translated">Workflow</target>
        </trans-unit>
        <trans-unit id="01b0947f98451f2111dec9ae4e4392144c3513b4" translate="yes" xml:space="preserve">
          <source>Working around the browser APIs</source>
          <target state="translated">브라우저 API 해결</target>
        </trans-unit>
        <trans-unit id="2eb34458f36c3030ba79d7147278dcb7f42f56ba" translate="yes" xml:space="preserve">
          <source>Working on an implementation.</source>
          <target state="translated">구현 작업.</target>
        </trans-unit>
        <trans-unit id="d6da71aec46b15c632d7d6fb6b59018bb75a210a" translate="yes" xml:space="preserve">
          <source>Working with components</source>
          <target state="translated">구성 요소 작업</target>
        </trans-unit>
        <trans-unit id="7167bf283c330d509f13471db85b942b02d9c51f" translate="yes" xml:space="preserve">
          <source>Working with templates</source>
          <target state="translated">템플릿 작업</target>
        </trans-unit>
        <trans-unit id="6268699d3bbeb1ad3dd8fe27d8c8cd586c39fb67" translate="yes" xml:space="preserve">
          <source>Workspace and project configuration</source>
          <target state="translated">작업 공간 및 프로젝트 구성</target>
        </trans-unit>
        <trans-unit id="753540644098b968997d9756ca9f709602fc348a" translate="yes" xml:space="preserve">
          <source>Workspace and project file structure</source>
          <target state="translated">작업 공간 및 프로젝트 파일 구조</target>
        </trans-unit>
        <trans-unit id="c352c45f9dfd8d810dc06724fc085c520f1ecafa" translate="yes" xml:space="preserve">
          <source>Workspace configuration files</source>
          <target state="translated">작업 공간 구성 파일</target>
        </trans-unit>
        <trans-unit id="85aa6b445eca0c0cf6c798a83ec5dedaa7b66a19" translate="yes" xml:space="preserve">
          <source>Workspace npm dependencies</source>
          <target state="translated">작업 공간 npm 종속성</target>
        </trans-unit>
        <trans-unit id="5a0d418778672b7618a4ff2f76ab69dd1900780f" translate="yes" xml:space="preserve">
          <source>Workspaces and project files</source>
          <target state="translated">작업 공간 및 프로젝트 파일</target>
        </trans-unit>
        <trans-unit id="271c9d6d538b3bca13093c6cf8b704359cdcd783" translate="yes" xml:space="preserve">
          <source>Wrap the entire form in a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; and bind its &lt;code&gt;hidden&lt;/code&gt; property to the &lt;code&gt;HeroFormComponent.submitted&lt;/code&gt; property.</source>
          <target state="translated">A의 전체 양식을 감싸 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 와 바인딩의 &lt;code&gt;hidden&lt;/code&gt; 받는 재산 &lt;code&gt;HeroFormComponent.submitted&lt;/code&gt; 의 속성입니다.</target>
        </trans-unit>
        <trans-unit id="c4758386676c54543b72740b050edd6b5164b8d6" translate="yes" xml:space="preserve">
          <source>Wrap the form in a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; and bind its &lt;code&gt;hidden&lt;/code&gt; property to the &lt;code&gt;HeroFormComponent.submitted&lt;/code&gt; property.</source>
          <target state="translated">A의 양식을 감싸 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 와 바인딩의 &lt;code&gt;hidden&lt;/code&gt; 받는 재산 &lt;code&gt;HeroFormComponent.submitted&lt;/code&gt; 의 속성입니다.</target>
        </trans-unit>
        <trans-unit id="16d56174bd7b0125fea2dcc2c06879628dc61f7b" translate="yes" xml:space="preserve">
          <source>Wrap the hero detail HTML in a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;. Add Angular's &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; directive to the &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; and set it to &lt;code&gt;selectedHero&lt;/code&gt;.</source>
          <target state="translated">영웅 세부 사항 HTML을 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 로 랩핑하십시오 . Angular의 &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 지시문을 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 에 추가 하고 &lt;code&gt;selectedHero&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="80af69bfe43ca69dcb3f2fb2aa59e64fa426c886" translate="yes" xml:space="preserve">
          <source>Wrap up and final app</source>
          <target state="translated">마무리 및 최종 앱</target>
        </trans-unit>
        <trans-unit id="27cf5d4683d47a0de40a3f27346a5f855469b310" translate="yes" xml:space="preserve">
          <source>Wrapped values are unwrapped automatically during the change detection, and the unwrapped value is stored.</source>
          <target state="translated">변경 감지 중에 랩핑 된 값은 자동으로 랩핑 해제되고 랩핑되지 않은 값이 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="b618e5b1103fc5a7e8d976cd3a42fcb09070c8d7" translate="yes" xml:space="preserve">
          <source>WrappedValue</source>
          <target state="translated">WrappedValue</target>
        </trans-unit>
        <trans-unit id="57b9cb2cebc443cd6088f1e833e85368057ca6eb" translate="yes" xml:space="preserve">
          <source>Wraps a function to be executed in the fakeAsync zone:</source>
          <target state="translated">fakeAsync 영역에서 실행될 함수를 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="22a50d995cd4156654361cd37c38f681e8d33b3b" translate="yes" xml:space="preserve">
          <source>Wraps a test function in an asynchronous test zone. The test will automatically complete when all asynchronous calls within this zone are done. Can be used to wrap an &lt;a href=&quot;inject&quot;&gt;&lt;code&gt;inject&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="translated">테스트 기능을 비동기 테스트 영역에 래핑합니다. 이 영역 내에서 모든 비동기 호출이 완료되면 테스트가 자동으로 완료됩니다. 포장하는 데 사용할 수 있습니다 &lt;a href=&quot;inject&quot;&gt; &lt;code&gt;inject&lt;/code&gt; &lt;/a&gt; 전화를.</target>
        </trans-unit>
        <trans-unit id="100b402dceaf296612af0eb5e4e6515e25039258" translate="yes" xml:space="preserve">
          <source>Wraps a test function in an asynchronous test zone. The test will automatically complete when all asynchronous calls within this zone are done. Can be used to wrap an &lt;a href=&quot;testing/inject&quot;&gt;&lt;code&gt;inject&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="translated">테스트 기능을 비동기 테스트 영역에 래핑합니다. 이 영역 내에서 모든 비동기 호출이 완료되면 테스트가 자동으로 완료됩니다. 포장하는 데 사용할 수 있습니다 &lt;a href=&quot;testing/inject&quot;&gt; &lt;code&gt;inject&lt;/code&gt; &lt;/a&gt; 전화를.</target>
        </trans-unit>
        <trans-unit id="ea8f25d1acfd326e0dad7d7c32fcc318bdf66542" translate="yes" xml:space="preserve">
          <source>Write DOM tests too</source>
          <target state="translated">DOM 테스트 작성</target>
        </trans-unit>
        <trans-unit id="bbb1518b0ffd4a7ea062b980c53ed31798fec5f2" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;canActivate()&lt;/code&gt; guard method to redirect anonymous users to the login page when they try to enter the admin area.</source>
          <target state="translated">익명 사용자가 관리 영역에 들어 가려고 할 때 로그인 페이지로 리디렉션 하는 &lt;code&gt;canActivate()&lt;/code&gt; 가드 메서드를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="a20cce9d728aa06f528fda67055ff0c86a09b2b3" translate="yes" xml:space="preserve">
          <source>Write a harness to try it</source>
          <target state="translated">그것을 시도 하네스를 작성</target>
        </trans-unit>
        <trans-unit id="a8d0c494c88477774037634897be250615132ba0" translate="yes" xml:space="preserve">
          <source>Write a second component that &lt;em&gt;binds&lt;/em&gt; the pipe's format parameter to the component's &lt;code&gt;format&lt;/code&gt; property. Here's the template for that component:</source>
          <target state="translated">파이프의 형식 매개 변수를 컴포넌트의 &lt;code&gt;format&lt;/code&gt; 특성에 &lt;em&gt;바인딩&lt;/em&gt; 하는 두 번째 컴포넌트를 작성하십시오 . 해당 구성 요소의 템플릿은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c475564c93474169eccff5a8c6fbbae81a32d868" translate="yes" xml:space="preserve">
          <source>Write a structural directive</source>
          <target state="translated">구조적 지시문 작성</target>
        </trans-unit>
        <trans-unit id="0b5b915cb79464c96b638b4b04076ae4512fcc2b" translate="yes" xml:space="preserve">
          <source>Write a value to the element</source>
          <target state="translated">요소에 값을 씁니다</target>
        </trans-unit>
        <trans-unit id="50ab6e47b6478470b9f03185206a16d9f0dcd98d" translate="yes" xml:space="preserve">
          <source>Write an &lt;a href=&quot;dependency-injection-in-action#useexisting&quot;&gt;&lt;em&gt;alias provider&lt;/em&gt;&lt;/a&gt;&amp;mdash;a &lt;code&gt;provide&lt;/code&gt; object literal with a &lt;code&gt;&lt;a href=&quot;../api/core/existingsansprovider#useExisting&quot;&gt;useExisting&lt;/a&gt;&lt;/code&gt; definition&amp;mdash;that creates an &lt;em&gt;alternative&lt;/em&gt; way to inject the same component instance and add that provider to the &lt;code&gt;providers&lt;/code&gt; array of the &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; metadata for the &lt;code&gt;AlexComponent&lt;/code&gt;.</source>
          <target state="translated">쓰기 &lt;a href=&quot;dependency-injection-in-action#useexisting&quot;&gt;&lt;em&gt;별명 제공&lt;/em&gt;&lt;/a&gt; -a &lt;code&gt;provide&lt;/code&gt; 하는 개체의 리터 2 &lt;code&gt;&lt;a href=&quot;../api/core/existingsansprovider#useExisting&quot;&gt;useExisting&lt;/a&gt;&lt;/code&gt; 정의-있다는 생성 &lt;em&gt;대안&lt;/em&gt; 동일한 요소 인스턴스를 주입하고, 해당 업체를 추가하는 방법은 &lt;code&gt;providers&lt;/code&gt; 의 배열 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; 메타 데이터 &lt;code&gt;AlexComponent&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="f03d8a78e9142ec11fa984d17b5bba0431278bdc" translate="yes" xml:space="preserve">
          <source>Write an interceptor</source>
          <target state="translated">인터셉터 작성</target>
        </trans-unit>
        <trans-unit id="5104c2e3791c124e2d7f0aee44b134ee5d40b302" translate="yes" xml:space="preserve">
          <source>Write lean hook methods to avoid performance problems</source>
          <target state="translated">성능 문제를 피하기 위해 린 후크 메서드 작성</target>
        </trans-unit>
        <trans-unit id="11f4e18a688e5fb137dcbb0b8fc5b283a82a6f5a" translate="yes" xml:space="preserve">
          <source>Write one more impure pipe, a pipe that makes an HTTP request.</source>
          <target state="translated">HTTP 요청을하는 불순한 파이프를 하나 더 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="98d4c2f5112b9165b3d77fe1bbc4810bdb11e157" translate="yes" xml:space="preserve">
          <source>Write the directive code</source>
          <target state="translated">지시문 코드 작성</target>
        </trans-unit>
        <trans-unit id="328305f528e33187a05ed913c4cdfd6835ff639a" translate="yes" xml:space="preserve">
          <source>Write the first async &lt;code&gt;beforeEach&lt;/code&gt; like this.</source>
          <target state="translated">최초의 비동기 쓰기 &lt;code&gt;beforeEach&lt;/code&gt; 과 같이합니다.</target>
        </trans-unit>
        <trans-unit id="4a8c5b07a378d0e9997a7ab9a6bc9d3eb9fe12c2" translate="yes" xml:space="preserve">
          <source>Write the template</source>
          <target state="translated">템플릿 작성</target>
        </trans-unit>
        <trans-unit id="3460c1b32f74351fdabb7b72f175001fb3641df8" translate="yes" xml:space="preserve">
          <source>Write-Only</source>
          <target state="translated">Write-Only</target>
        </trans-unit>
        <trans-unit id="db8bc67982568e392f688d4f65b76786016e30fa" translate="yes" xml:space="preserve">
          <source>Writes a new value to the element.</source>
          <target state="translated">요소에 새로운 값을 씁니다.</target>
        </trans-unit>
        <trans-unit id="a0212190c31c9111ccc96747fc494e7786d20b68" translate="yes" xml:space="preserve">
          <source>Writing DOM tests to support a pipe test</source>
          <target state="translated">파이프 테스트를 지원하기위한 DOM 테스트 작성</target>
        </trans-unit>
        <trans-unit id="a2cee97467095242641dce6e6e2e22f7a3d2d50a" translate="yes" xml:space="preserve">
          <source>Writing test functions with &lt;code&gt;&lt;a href=&quot;../api/core/applicationinitstatus#done&quot;&gt;done&lt;/a&gt;()&lt;/code&gt;, is more cumbersome than &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt;and &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt;, but it is occasionally necessary when code involves the &lt;code&gt;intervalTimer()&lt;/code&gt; like &lt;code&gt;setInterval&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/core/applicationinitstatus#done&quot;&gt;done&lt;/a&gt;()&lt;/code&gt; 테스트 함수를 작성 하는 것은 &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; 보다 성가 시지만 , 코드에 &lt;code&gt;setInterval&lt;/code&gt; 과 같은 &lt;code&gt;intervalTimer()&lt;/code&gt; 포함되는 경우가 종종 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="9287ece53332183a6f3584ff3e2083d2cff0c416" translate="yes" xml:space="preserve">
          <source>Writing test functions with &lt;code&gt;done()&lt;/code&gt;, is more cumbersome than &lt;code&gt;&lt;a href=&quot;../api/core/testing/waitforasync&quot;&gt;waitForAsync&lt;/a&gt;()&lt;/code&gt;and &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt;, but it is occasionally necessary when code involves the &lt;code&gt;intervalTimer()&lt;/code&gt; like &lt;code&gt;setInterval&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;done()&lt;/code&gt; 테스트 함수를 작성 하는 것은 &lt;code&gt;&lt;a href=&quot;../api/core/testing/waitforasync&quot;&gt;waitForAsync&lt;/a&gt;()&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; 보다 번거롭지 만 코드에 &lt;code&gt;setInterval&lt;/code&gt; 과 같은 &lt;code&gt;intervalTimer()&lt;/code&gt; 가 포함될 때 가끔 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="869fbcd2d8f7216089e804c7e02a4532a37cae00" translate="yes" xml:space="preserve">
          <source>Writing tests with template-driven forms requires a detailed knowledge of the change detection process and an understanding of how directives run on each cycle to ensure that elements are queried, tested, or changed at the correct time.</source>
          <target state="translated">템플릿 기반 양식을 사용하여 테스트를 작성하려면 변경 감지 프로세스에 대한 자세한 지식과 각주기에서 지시문이 실행되는 방식을 이해해야 요소가 올바른 시간에 쿼리, 테스트 또는 변경되도록합니다.</target>
        </trans-unit>
        <trans-unit id="fba633555fbdefb41b26b54e2d1ae5197e6018a8" translate="yes" xml:space="preserve">
          <source>Writing this in full JavaScript can be quite involved. With observables, you can use a simple series of RxJS operators:</source>
          <target state="translated">이것을 완전한 JavaScript로 작성하는 것은 상당히 관련이 있습니다. 관찰 가능 항목을 사용하면 간단한 일련의 RxJS 연산자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d7b693cbfc10c6be0691f24671f3dea15cd67fa" translate="yes" xml:space="preserve">
          <source>Writing variations of the same parent &lt;em&gt;alias provider&lt;/em&gt; gets old quickly, especially this awful mouthful with a &lt;a href=&quot;dependency-injection-in-action#forwardref&quot;&gt;&lt;em&gt;forwardRef&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">동일한 부모 &lt;em&gt;별명 제공자&lt;/em&gt; 의 변형을 작성하는 것은 특히 오래되었습니다. 특히 &lt;a href=&quot;dependency-injection-in-action#forwardref&quot;&gt;&lt;em&gt;forwardRef를&lt;/em&gt;&lt;/a&gt; 사용하면이 끔찍 합니다.</target>
        </trans-unit>
        <trans-unit id="6615fce0f673668cfcbf040e610b3f243f6a5f0f" translate="yes" xml:space="preserve">
          <source>Writing your own structural directives</source>
          <target state="translated">자신 만의 구조적 지시문 작성</target>
        </trans-unit>
        <trans-unit id="bda3d503ab6e71da4ecdc7ba9799876a869c7f5d" translate="yes" xml:space="preserve">
          <source>WtfScopeFn</source>
          <target state="translated">WtfScopeFn</target>
        </trans-unit>
        <trans-unit id="0bedb6a0b3ee1a4586748a1afd482fdab6cd810e" translate="yes" xml:space="preserve">
          <source>XLIFF 1.2 (default)</source>
          <target state="translated">XLIFF 1.2 (기본값)</target>
        </trans-unit>
        <trans-unit id="7ac17d1faac505f349f9755e05f6be22993a3065" translate="yes" xml:space="preserve">
          <source>XLIFF 2</source>
          <target state="translated">XLIFF 2</target>
        </trans-unit>
        <trans-unit id="09d92a1a0c75cee4b1621a6ca1a7fc5f5e596627" translate="yes" xml:space="preserve">
          <source>XLIFF files have the extension .xlf. The XMB format generates .xmb source files but uses .xtb (XML Translation Bundle: XTB) translation files.</source>
          <target state="translated">XLIFF 파일의 확장자는 .xlf입니다. XMB 형식은 .xmb 소스 파일을 생성하지만 .xtb (XML 변환 번들 : XTB) 변환 파일을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f16fd21c83aaacaec3bd77b0e3973fdcf1cd7ce2" translate="yes" xml:space="preserve">
          <source>XLIFF files use the extension &lt;code&gt;.xlf&lt;/code&gt;. The XMB format generates &lt;code&gt;.xmb&lt;/code&gt; source language files but uses&lt;code&gt;.xtb&lt;/code&gt; (XML Translation Bundle: XTB) translation files.</source>
          <target state="translated">XLIFF 파일은 &lt;code&gt;.xlf&lt;/code&gt; 확장자를 사용합니다 . XMB 형식은 &lt;code&gt;.xmb&lt;/code&gt; 소스 언어 파일을 생성 하지만 &lt;code&gt;.xtb&lt;/code&gt; (XML 번역 번들 : XTB) 번역 파일을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0d6931c6ae08210e1032ff16fc8dc25545ff4dd5" translate="yes" xml:space="preserve">
          <source>XML Message Bundle (XMB)</source>
          <target state="translated">XML 메시지 번들 (XMB)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
