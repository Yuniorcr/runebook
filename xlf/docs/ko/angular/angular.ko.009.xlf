<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="angular">
    <body>
      <group id="angular">
        <trans-unit id="2373344a9550daa83bd9efe5a057e0eb47e2963c" translate="yes" xml:space="preserve">
          <source>Here's &lt;em&gt;Barry&lt;/em&gt;.</source>
          <target state="translated">여기 &lt;em&gt;배리&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="58dfcfb5bd2344e21c4f9234e1a0a787c9ad52c8" translate="yes" xml:space="preserve">
          <source>Here's a &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; test that demonstrates the data flow you'd expect in the real world.</source>
          <target state="translated">다음 은 실제 환경에서 예상되는 데이터 흐름을 보여주는 &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; 테스트입니다.</target>
        </trans-unit>
        <trans-unit id="3b04099851b53646b03c500d744979f7ed478b27" translate="yes" xml:space="preserve">
          <source>Here's a &lt;code&gt;provider&lt;/code&gt; example of the problem.</source>
          <target state="translated">다음 은 문제 의 &lt;code&gt;provider&lt;/code&gt; 예입니다.</target>
        </trans-unit>
        <trans-unit id="332ad9d1d1c0ec3216151d16383d075136fa7637" translate="yes" xml:space="preserve">
          <source>Here's a brief description of each exercise:</source>
          <target state="translated">각 운동에 대한 간단한 설명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="342d9dca61b9e4422f88fa45aa82e665fc20fb7d" translate="yes" xml:space="preserve">
          <source>Here's a child view that displays a hero's name in an &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 에 영웅의 이름을 표시하는 자식 뷰가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2dc49e2bfd96abcc48b54d3c3672ed317de547d8" translate="yes" xml:space="preserve">
          <source>Here's a closer look at the code.</source>
          <target state="translated">코드를 자세히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="c8cfdd2d432c327dabf4c942f49ee2de0e323ab4" translate="yes" xml:space="preserve">
          <source>Here's a component with an input field for a single control implemented using reactive forms.</source>
          <target state="translated">다음은 반응 형을 사용하여 구현 된 단일 컨트롤에 대한 입력 필드가있는 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="771c4365239b6adac9b51419ce8e2170cdf8bc02" translate="yes" xml:space="preserve">
          <source>Here's a conforming example</source>
          <target state="translated">다음은 적합한 예입니다.</target>
        </trans-unit>
        <trans-unit id="67c50f15b5597454aa71b847527a69b00db4940f" translate="yes" xml:space="preserve">
          <source>Here's a full-featured application of &lt;code&gt;NgFor&lt;/code&gt;, written both ways:</source>
          <target state="translated">다음은 두 가지 방법으로 작성된 &lt;code&gt;NgFor&lt;/code&gt; 의 모든 기능을 갖춘 응용 프로그램입니다 .</target>
        </trans-unit>
        <trans-unit id="9d07ea3700c1b14d35ec087c49afa25711851988" translate="yes" xml:space="preserve">
          <source>Here's a pertinent excerpt from the template:</source>
          <target state="translated">템플릿에서 발췌 한 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2d7220461d3f8c562324ad099c90d86389d03dea" translate="yes" xml:space="preserve">
          <source>Here's a revised version that defaults to &lt;code&gt;parent&lt;/code&gt; but also accepts an optional second parameter for a different parent class interface.</source>
          <target state="translated">다음은 기본적으로 &lt;code&gt;parent&lt;/code&gt; 버전 이지만 다른 부모 클래스 인터페이스에 대한 선택적 두 번째 매개 변수를 허용하는 수정 된 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="e1e1e0ffc9b6aee2fef781d2718e2fd868a214ee" translate="yes" xml:space="preserve">
          <source>Here's a simple root NgModule definition.</source>
          <target state="translated">다음은 간단한 루트 NgModule 정의입니다.</target>
        </trans-unit>
        <trans-unit id="13b657074051b1dd3d3aaa6052c01e4cd48c1ba0" translate="yes" xml:space="preserve">
          <source>Here's a summary of the stand-alone functions, in order of likely utility:</source>
          <target state="translated">다음은 유틸리티 가능성이 높은 독립형 함수에 대한 요약입니다.</target>
        </trans-unit>
        <trans-unit id="d52092227c7976ce49b8aa2a6d6cca685babff11" translate="yes" xml:space="preserve">
          <source>Here's a test demonstrating the component's behavior when the observed &lt;code&gt;id&lt;/code&gt; refers to an existing hero:</source>
          <target state="translated">다음은 관찰 된 &lt;code&gt;id&lt;/code&gt; 가 기존의 영웅을 나타낼 때 구성 요소의 동작을 보여주는 테스트입니다 .</target>
        </trans-unit>
        <trans-unit id="ffd0ce6376a8b892a0a4dd44632d7f49de3e0e31" translate="yes" xml:space="preserve">
          <source>Here's a visual idea of where this tutorial leads, beginning with the &quot;Dashboard&quot; view and the most heroic heroes:</source>
          <target state="translated">다음은 &quot;대시 보드&quot;보기와 가장 영웅적인 영웅으로 시작하여이 학습서의 위치에 대한 시각적 아이디어입니다.</target>
        </trans-unit>
        <trans-unit id="a58b171fff7fdf9107296da5f6e8439cb68ac2fa" translate="yes" xml:space="preserve">
          <source>Here's an embedded live example for this guide.</source>
          <target state="translated">다음은이 안내서에 대한 내장 된 라이브 예입니다.</target>
        </trans-unit>
        <trans-unit id="f8987e6cd96e95c2cfb4f4fd4c1bed76aaee7fc7" translate="yes" xml:space="preserve">
          <source>Here's an example in which the &lt;code&gt;AppComponent.fontSizePx&lt;/code&gt; is two-way bound to the &lt;code&gt;SizerComponent&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;AppComponent.fontSizePx&lt;/code&gt; 가 SizerComponent 에 양방향으로 바인딩 된 &lt;code&gt;SizerComponent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bdfacca7ab5d0824f43836325291190197ca019" translate="yes" xml:space="preserve">
          <source>Here's an example of a service class that logs to the browser console.</source>
          <target state="translated">다음은 브라우저 콘솔에 로그인하는 서비스 클래스의 예입니다.</target>
        </trans-unit>
        <trans-unit id="99e679bc16af7a1f9d179d8466452325faeeffb8" translate="yes" xml:space="preserve">
          <source>Here's an example of an error message added to the &lt;em&gt;name&lt;/em&gt; input box:</source>
          <target state="translated">&lt;em&gt;이름&lt;/em&gt; 입력 상자에 추가 된 오류 메시지의 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a801f1de6030e88253033ddfef1b99db9927d97d" translate="yes" xml:space="preserve">
          <source>Here's an example of basic metadata for &lt;code&gt;HeroListComponent&lt;/code&gt;.</source>
          <target state="translated">다음은 &lt;code&gt;HeroListComponent&lt;/code&gt; 의 기본 메타 데이터 예입니다 .</target>
        </trans-unit>
        <trans-unit id="45774d5d345882a71ea0fc59337a3b86d4253823" translate="yes" xml:space="preserve">
          <source>Here's an example of binding to the &lt;code&gt;colSpan&lt;/code&gt; property. Notice that it's not &lt;code&gt;colspan&lt;/code&gt;, which is the attribute, spelled with a lowercase &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">다음은 &lt;code&gt;colSpan&lt;/code&gt; 속성 에 바인딩하는 예입니다 . 속성은 &lt;code&gt;colspan&lt;/code&gt; 이 아니며 소문자 &lt;code&gt;s&lt;/code&gt; 로 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="4dbc92e76d1afd27809635974b4f4a7190dd2709" translate="yes" xml:space="preserve">
          <source>Here's an example of creating and subscribing to a simple observable, with an observer that logs the received message to the console:</source>
          <target state="translated">수신 된 메시지를 콘솔에 기록하는 옵저버를 사용하여 간단한 옵저버 블을 만들고 구독하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="044030613cb78d7ccdd179ec6255d8b66b6c4172" translate="yes" xml:space="preserve">
          <source>Here's an example of using keyframes to create a pulse effect:</source>
          <target state="translated">다음은 키 프레임을 사용하여 펄스 효과를 만드는 예입니다.</target>
        </trans-unit>
        <trans-unit id="fff667011fdbcb48393c9cb30c030e165456b690" translate="yes" xml:space="preserve">
          <source>Here's an example of using the &lt;code&gt;catchError&lt;/code&gt; operator to do this:</source>
          <target state="translated">&lt;code&gt;catchError&lt;/code&gt; 연산자를 사용하여 이를 수행 하는 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="541970f9030afc36a95c731be207ea924fb5f0f4" translate="yes" xml:space="preserve">
          <source>Here's an example that demonstrates the basic usage model by showing how an observable could be used to provide geolocation updates.</source>
          <target state="translated">다음은 옵저버 블을 사용하여 지리적 위치 업데이트를 제공하는 방법을 보여줌으로써 기본 사용 모델을 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="2639f3ab4611df11a6c31d7f75243294cbb8cbd4" translate="yes" xml:space="preserve">
          <source>Here's an example that excerpts certain scripts from &lt;code&gt;package.json&lt;/code&gt; into a partial file named &lt;code&gt;package.1.json&lt;/code&gt;.</source>
          <target state="translated">여기에 예제가 그 발췌에서 특정 스크립트 &lt;code&gt;package.json&lt;/code&gt; 을 일부라는 이름의 파일로 &lt;code&gt;package.1.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61f04271f847d0c8988094c50219a148be404036" translate="yes" xml:space="preserve">
          <source>Here's an example.</source>
          <target state="translated">다음은 예입니다.</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e0c943ae02f8fdb73167474d07a54374b16f800" translate="yes" xml:space="preserve">
          <source>Here's an illustrative example.</source>
          <target state="translated">여기 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e88db74062a516f02d9d37bb5e8b39b0a74ea59d" translate="yes" xml:space="preserve">
          <source>Here's another code sample using the wildcard state together with our previous example using the &lt;code&gt;open&lt;/code&gt; and &lt;code&gt;closed&lt;/code&gt; states. Instead of defining each state-to-state transition pair, we're now saying that any transition to &lt;code&gt;closed&lt;/code&gt; takes 1 second, and any transition to &lt;code&gt;open&lt;/code&gt; takes 0.5 seconds.</source>
          <target state="translated">다음은 &lt;code&gt;open&lt;/code&gt; 상태 와 &lt;code&gt;closed&lt;/code&gt; 상태 를 사용하는 이전 예제와 함께 와일드 카드 상태를 사용하는 또 다른 코드 샘플 입니다. 각 상태 간 전환 쌍을 정의하는 대신 이제 &lt;code&gt;closed&lt;/code&gt; 전환하는 데 1 초가 걸리고 &lt;code&gt;open&lt;/code&gt; 전환하는 데 0.5 초가 걸린다고합니다.</target>
        </trans-unit>
        <trans-unit id="70eda6d168054a0865515e0443b33d2b23af65a0" translate="yes" xml:space="preserve">
          <source>Here's another test that calls &lt;code&gt;HTMLElement.querySelector&lt;/code&gt; to get the paragraph element and look for the banner text:</source>
          <target state="translated">다음은 &lt;code&gt;HTMLElement.querySelector&lt;/code&gt; 를 호출 하여 단락 요소를 가져 와서 배너 텍스트를 찾는 다른 테스트입니다 .</target>
        </trans-unit>
        <trans-unit id="3dc08816743a52195484363d2e3c24a2b3c9d87d" translate="yes" xml:space="preserve">
          <source>Here's another test that changes the component's &lt;code&gt;title&lt;/code&gt; property &lt;em&gt;before&lt;/em&gt; calling &lt;code&gt;fixture.detectChanges()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fixture.detectChanges()&lt;/code&gt; &lt;em&gt;를&lt;/em&gt; 호출 &lt;em&gt;하기 전에&lt;/em&gt; 구성 요소의 &lt;code&gt;title&lt;/code&gt; 속성 을 변경하는 또 다른 테스트가 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3627df60550e33b9632085fa920812ce9f528a36" translate="yes" xml:space="preserve">
          <source>Here's are the two corresponding code snippets displayed side-by-side.</source>
          <target state="translated">다음은 두 개의 해당 코드 스 니펫이 나란히 표시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f7ca5ab98fbaecc24dee9341e08f0fa1f44c1a9" translate="yes" xml:space="preserve">
          <source>Here's how it works.</source>
          <target state="translated">작동 방식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9765338cf911741bd6fdd71fe0e9d288e68f815" translate="yes" xml:space="preserve">
          <source>Here's how the harness should work when you're done coding.</source>
          <target state="translated">코딩이 완료되면 하네스의 작동 방식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f8b16882caea78c4ae20585288bb3408690cd2a3" translate="yes" xml:space="preserve">
          <source>Here's how the user will experience this version of the app:</source>
          <target state="translated">사용자가이 버전의 앱을 경험하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4288a1aa86a0ff0cdf195279ed93bc028ad830c8" translate="yes" xml:space="preserve">
          <source>Here's how to set the attribute without binding in plain HTML:</source>
          <target state="translated">일반 HTML에서 바인딩하지 않고 속성을 설정하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ad7f50209fddbb04ba01574e4233f2906ad1ab57" translate="yes" xml:space="preserve">
          <source>Here's how you might begin:</source>
          <target state="translated">시작하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e296845164394524708679f8487b23c5b3b8bb1" translate="yes" xml:space="preserve">
          <source>Here's how you might rewrite one of the &lt;code&gt;MasterService&lt;/code&gt; tests in that style.</source>
          <target state="translated">해당 스타일로 &lt;code&gt;MasterService&lt;/code&gt; 테스트 중 하나를 다시 작성하는 방법은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3016acc8c67f96365b961ff1184679e2556919c4" translate="yes" xml:space="preserve">
          <source>Here's how you might update the authorization header (after the old token expired) before making the next request.</source>
          <target state="translated">다음 요청을하기 전에 (이전 토큰이 만료 된 후) 인증 헤더를 업데이트하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9117f64adc27738efa3e0c09ed2e0b5bf8192560" translate="yes" xml:space="preserve">
          <source>Here's the &quot;flying hero&quot; at a more reasonable scale.</source>
          <target state="translated">보다 합리적인 규모의 &quot;비행 영웅&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="2022823e06097841ddac1cf7e8178ca2d42a4a76" translate="yes" xml:space="preserve">
          <source>Here's the &lt;code&gt;FlyingHeroesPipe&lt;/code&gt; implementation, which follows the pattern for custom pipes described earlier.</source>
          <target state="translated">다음 은 앞서 설명한 사용자 지정 파이프의 패턴을 따르는 &lt;code&gt;FlyingHeroesPipe&lt;/code&gt; 구현입니다.</target>
        </trans-unit>
        <trans-unit id="6a3af23f4d1dd133edc136f6262b5e7bda291ff3" translate="yes" xml:space="preserve">
          <source>Here's the &lt;code&gt;HeroDetailComponent&lt;/code&gt; constructor:</source>
          <target state="translated">&lt;code&gt;HeroDetailComponent&lt;/code&gt; 생성자 는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="db5c622d4af61973b5a850f38a6b8490ea24df97" translate="yes" xml:space="preserve">
          <source>Here's the &lt;code&gt;NameParentComponent&lt;/code&gt; demonstrating name variations including a name with all spaces:</source>
          <target state="translated">공백이있는 이름을 포함한 이름 변형을 보여주는 &lt;code&gt;NameParentComponent&lt;/code&gt; 는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1356893ffa40f8e92ce29acc0e9093499ed4e4f0" translate="yes" xml:space="preserve">
          <source>Here's the &lt;code&gt;src&lt;/code&gt; attribute for the &quot;flying hero&quot; image belonging to this page.</source>
          <target state="translated">이 페이지에 속하는 &quot;flying hero&quot;이미지 의 &lt;code&gt;src&lt;/code&gt; 속성은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1934e4bbd6b06ebbe4498a926009f4a666e04fd4" translate="yes" xml:space="preserve">
          <source>Here's the &lt;em&gt;Crisis Center&lt;/em&gt; URL in this &quot;HTML5 pushState&quot; style:</source>
          <target state="translated">이 &quot;HTML5 pushState&quot;스타일 의 &lt;em&gt;위기 센터&lt;/em&gt; URL은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="47777d17bb1bca6811982891736189adcfcc5a34" translate="yes" xml:space="preserve">
          <source>Here's the Crisis Center URL in this &quot;HTML5 pushState&quot; style:</source>
          <target state="translated">다음은이 &quot;HTML5 pushState&quot;스타일의 위기 센터 URL입니다.</target>
        </trans-unit>
        <trans-unit id="d6f4728904a893243df57b9fc8571044a55d17d1" translate="yes" xml:space="preserve">
          <source>Here's the app in action:</source>
          <target state="translated">작동하는 앱은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9cf2ae56853b24b74c07fa91778a1f965ca1c2a0" translate="yes" xml:space="preserve">
          <source>Here's the brief markup that produced that lengthy snippet:</source>
          <target state="translated">긴 스 니펫을 생성 한 간단한 마크 업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="36ec26250a6311e0f6a9d15c00b167cc53c0abd4" translate="yes" xml:space="preserve">
          <source>Here's the complete &lt;code&gt;beforeEach()&lt;/code&gt;, using &lt;code&gt;TestBed.get()&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;beforeEach()&lt;/code&gt; 을 사용 하는 완전한 &lt;code&gt;TestBed.get()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8038d4fe87223086f55bcb456ce49a9519717a6" translate="yes" xml:space="preserve">
          <source>Here's the complete &lt;code&gt;beforeEach()&lt;/code&gt;, using &lt;code&gt;TestBed.inject()&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;beforeEach()&lt;/code&gt; 사용하여 &lt;code&gt;TestBed.inject()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="caecf0d5e0ff532d9b371ee05fe69b6c8e3e14b9" translate="yes" xml:space="preserve">
          <source>Here's the complete &lt;code&gt;crisis-center-routing.module.ts&lt;/code&gt; file with its imports.</source>
          <target state="translated">다음 은 가져 오기 가 포함 된 완전한 &lt;code&gt;crisis-center-routing.module.ts&lt;/code&gt; 파일입니다.</target>
        </trans-unit>
        <trans-unit id="2f2a29a3cb9bc753449f5909dcff9ed14073cee1" translate="yes" xml:space="preserve">
          <source>Here's the complete test for getting a quote:</source>
          <target state="translated">견적을받는 데 필요한 전체 테스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6bdcaeaf4077794f77927b6985a2ac0d9be095d9" translate="yes" xml:space="preserve">
          <source>Here's the component's full definition:</source>
          <target state="translated">구성 요소의 전체 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="62549f1989670813f8a7b7667c8ee151d97fb907" translate="yes" xml:space="preserve">
          <source>Here's the component, its template and styles:</source>
          <target state="translated">컴포넌트, 템플릿 및 스타일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="df996b8eb08a97d6354f014409427c8d6fcd7be4" translate="yes" xml:space="preserve">
          <source>Here's the conditional paragraph again, this time using &lt;code&gt;&amp;lt;ng-container&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;ng-container&amp;gt;&lt;/code&gt; 사용하여 조건부 단락을 다시 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="730aeb3d5f96c7f97f79d7090b9eeccf0261bbcb" translate="yes" xml:space="preserve">
          <source>Here's the final code:</source>
          <target state="translated">최종 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7743a871c540a8d90d5f0b6b681eb8c8d191f7eb" translate="yes" xml:space="preserve">
          <source>Here's the full, final code for the service:</source>
          <target state="translated">서비스에 대한 전체 최종 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e3f4b1fdcb29f542c15eed5d6f2f98b35f3afc23" translate="yes" xml:space="preserve">
          <source>Here's the latest version of the directive class.</source>
          <target state="translated">지시문 클래스의 최신 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b5b53ab66de81e52c96d692e7bcaea312637cb34" translate="yes" xml:space="preserve">
          <source>Here's the marble testing version of the &lt;code&gt;getQuote()&lt;/code&gt; error test.</source>
          <target state="translated">다음은 &lt;code&gt;getQuote()&lt;/code&gt; 오류 테스트 의 대리석 테스트 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="656487aec53e8c241399400466ff6b0fbb361893" translate="yes" xml:space="preserve">
          <source>Here's the markup for an &quot;avoid&quot; example in the &lt;a href=&quot;styleguide#style-05-03&quot;&gt;&lt;em&gt;Angular Style Guide&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">다음은 &lt;a href=&quot;styleguide#style-05-03&quot;&gt;&lt;em&gt;Angular Style Guide&lt;/em&gt;&lt;/a&gt; 의 &quot;avoid&quot;예제에 대한 마크 업입니다 .</target>
        </trans-unit>
        <trans-unit id="f1ce66c2b3fdb31cf1b0adc605c91b0e16e6d5e3" translate="yes" xml:space="preserve">
          <source>Here's the markup for that example.</source>
          <target state="translated">다음은 해당 예의 마크 업입니다.</target>
        </trans-unit>
        <trans-unit id="da8d856731f03ffe7562995f38730f23d3dcb96a" translate="yes" xml:space="preserve">
          <source>Here's the meat of the spec file setup.</source>
          <target state="translated">spec 파일 설정의 핵심은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="99883629747b9a103f8b3ab3da4d0b4cb0439481" translate="yes" xml:space="preserve">
          <source>Here's the output for the &lt;em&gt;main&lt;/em&gt; bundle of an example app called &lt;code&gt;cli-quickstart&lt;/code&gt;.</source>
          <target state="translated">다음 은 &lt;code&gt;cli-quickstart&lt;/code&gt; 라는 예제 앱 의 &lt;em&gt;기본&lt;/em&gt; 번들 출력입니다 .</target>
        </trans-unit>
        <trans-unit id="c32dfe48fc6e040a3debbf88b61e369677d91a75" translate="yes" xml:space="preserve">
          <source>Here's the output of a button-pushing sequence:</source>
          <target state="translated">다음은 버튼 푸시 시퀀스의 출력입니다.</target>
        </trans-unit>
        <trans-unit id="22bc28d071c5b0a1f933b3662d1adf54f39987a7" translate="yes" xml:space="preserve">
          <source>Here's the previous &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; test, re-written with the &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt; utility.</source>
          <target state="translated">다음 은 &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt; () 유틸리티로 다시 작성된 이전 &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; 테스트 입니다.</target>
        </trans-unit>
        <trans-unit id="3d6a6f8889834e3c8b1d65a05fdb25a7e2ea6f68" translate="yes" xml:space="preserve">
          <source>Here's the previous &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; test, re-written with the &lt;code&gt;&lt;a href=&quot;../api/core/testing/waitforasync&quot;&gt;waitForAsync&lt;/a&gt;()&lt;/code&gt; utility.</source>
          <target state="translated">다음 은 &lt;code&gt;&lt;a href=&quot;../api/core/testing/waitforasync&quot;&gt;waitForAsync&lt;/a&gt;()&lt;/code&gt; () 유틸리티로 다시 작성된 이전 &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; 테스트 입니다.</target>
        </trans-unit>
        <trans-unit id="65a50a9d22ad026dc17457d2ea667e0410123692" translate="yes" xml:space="preserve">
          <source>Here's the previous test, re-implemented with &lt;code&gt;fixture.debugElement.nativeElement&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;fixture.debugElement.nativeElement&lt;/code&gt; 로 다시 구현 된 이전 테스트는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f50475caf51709451a53cec5e964746fb2405109" translate="yes" xml:space="preserve">
          <source>Here's the previous test, rewritten using the click helper.</source>
          <target state="translated">클릭 도우미를 사용하여 다시 작성된 이전 테스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="050ad561b8eadf86d74804f473be2ddd0edda3a5" translate="yes" xml:space="preserve">
          <source>Here's the same component with an input field for a single control implemented using template-driven forms.</source>
          <target state="translated">템플릿 기반 양식을 사용하여 구현 된 단일 컨트롤에 대한 입력 필드가있는 동일한 구성 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d438fa0e2d2375bfdd5eb47ca1ad28ae5f460ffb" translate="yes" xml:space="preserve">
          <source>Here's the sample in action as the user makes changes.</source>
          <target state="translated">다음은 사용자가 변경하는 동안 실제로 사용하는 샘플입니다.</target>
        </trans-unit>
        <trans-unit id="53f0e5e27eee1572f4b2943467931546bb2cebe6" translate="yes" xml:space="preserve">
          <source>Here's the updated directive in full:</source>
          <target state="translated">업데이트 된 지시문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8292c62a5b64fea28e8eeec99f093a51f5489800" translate="yes" xml:space="preserve">
          <source>Here's what the new class for the phone list component controller looks like:</source>
          <target state="translated">전화 목록 구성 요소 컨트롤러의 새 클래스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="07b8c34ac5381e60250f5c47082ce1167ad4448b" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;movie&lt;/code&gt; is a user-defined local variable.</source>
          <target state="translated">여기서 &lt;code&gt;movie&lt;/code&gt; 는 사용자 정의 로컬 변수입니다.</target>
        </trans-unit>
        <trans-unit id="6153c1c7b9b946f59eac67deb18a944d2418c87d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;ref.value&lt;/code&gt; doesn't work. The structural directive, &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; instantiates the template twice because &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; iterates over the two items in the array. It is impossible to define what the &lt;code&gt;ref.value&lt;/code&gt; reference signifies.</source>
          <target state="translated">여기서 &lt;code&gt;ref.value&lt;/code&gt; 가 작동하지 않습니다. 구조 지시문 &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 가 배열의 두 항목을 반복 하기 때문에 템플릿을 두 번 인스턴스화합니다 . &lt;code&gt;ref.value&lt;/code&gt; 참조가 의미 하는 바를 정의하는 것은 불가능 합니다.</target>
        </trans-unit>
        <trans-unit id="c11022e9ff6694cd10c93ffc254eca3c356cc71f" translate="yes" xml:space="preserve">
          <source>Here, during type checking of the template for &lt;code&gt;AppComponent&lt;/code&gt;, the &lt;code&gt;[user]=&quot;selectedUser&quot;&lt;/code&gt; binding corresponds with the &lt;code&gt;UserDetailComponent.user&lt;/code&gt; input. Therefore, Angular assigns the &lt;code&gt;selectedUser&lt;/code&gt; property to &lt;code&gt;UserDetailComponent.user&lt;/code&gt;, which would result in an error if their types were incompatible. TypeScript checks the assignment according to its type system, obeying flags such as &lt;code&gt;strictNullChecks&lt;/code&gt; as they are configured in the application.</source>
          <target state="translated">여기서, 용 템플릿 유형을 확인하는 동안 &lt;code&gt;AppComponent&lt;/code&gt; 상기 &lt;code&gt;[user]=&quot;selectedUser&quot;&lt;/code&gt; 바인딩 대응 &lt;code&gt;UserDetailComponent.user&lt;/code&gt; 의 입력. 따라서 Angular는 &lt;code&gt;selectedUser&lt;/code&gt; 속성을 &lt;code&gt;UserDetailComponent.user&lt;/code&gt; 에 할당하므로 해당 유형이 호환되지 않으면 오류가 발생합니다. TypeScript는 유형 시스템에 따라 할당을 확인 하고 응용 프로그램에 구성된 대로 &lt;code&gt;strictNullChecks&lt;/code&gt; 와 같은 플래그를 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="0324e49eae3f4d465824bf23cdd72a64935bdeb9" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;&amp;lt;child-component&amp;gt;&lt;/code&gt; selector, or child directive, is embedded within a &lt;code&gt;&amp;lt;parent-component&amp;gt;&lt;/code&gt;, which serves as the child's context.</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;child-component&amp;gt;&lt;/code&gt; 선택기 또는 child 지시문은 &lt;code&gt;&amp;lt;parent-component&amp;gt;&lt;/code&gt; 내에 포함 되며 이는 자식의 컨텍스트 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="5b29c9df7ecf00768cae1dfd0a130eb35958e0ad" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;disabled&lt;/code&gt; input of the component is being passed on to the &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; in the template. All of this works as expected, as long as a &lt;code&gt;boolean&lt;/code&gt; value is bound to the input. But, suppose a consumer uses this input in the template as an attribute:</source>
          <target state="translated">여기 에서 구성 요소 의 &lt;code&gt;disabled&lt;/code&gt; 입력은 템플릿 의 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 에 전달됩니다 . 이 모든 것은 &lt;code&gt;boolean&lt;/code&gt; 값이 입력에 바인딩되어있는 한 예상대로 작동 합니다. 그러나 소비자가 템플릿의이 입력을 속성으로 사용한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="5b6b1d3cce2b45f1e510f65dbcb1fa0284af0c29" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;keyup&lt;/code&gt; event binding sends every keystroke to the component's &lt;code&gt;search()&lt;/code&gt; method. The following snippet implements debouncing for this input using RxJS operators.</source>
          <target state="translated">여기서 &lt;code&gt;keyup&lt;/code&gt; 이벤트 바인딩은 모든 키 입력을 구성 요소의 &lt;code&gt;search()&lt;/code&gt; 메서드로 보냅니다 . 다음 스 니펫은 RxJS 연산자를 사용하여이 입력에 대한 디 바운싱을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4cf7703c8c869b0d3156f399825f1391be789300" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;prepareRoute()&lt;/code&gt; method takes the value of the outlet directive (established through &lt;code&gt;#outlet=&quot;outlet&quot;&lt;/code&gt;) and returns a string value representing the state of the animation based on the custom data of the current active route. You can use this data to control which transition to execute for each route.</source>
          <target state="translated">여기서 &lt;code&gt;prepareRoute()&lt;/code&gt; 메서드는 아울렛 지시문 ( &lt;code&gt;#outlet=&quot;outlet&quot;&lt;/code&gt; 을 통해 설정 됨)의 값을 가져와 현재 활성 경로의 사용자 지정 데이터를 기반으로 애니메이션 상태를 나타내는 문자열 값을 반환합니다. 이 데이터를 사용하여 각 경로에 대해 실행할 전환을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4444abe3b6c8e06daabc19a62213ba0a77348697" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;prepareRoute()&lt;/code&gt; method takes the value of the output directive (established through &lt;code&gt;#outlet=&quot;outlet&quot;&lt;/code&gt;) and returns a string value representing the state of the animation based on the custom data of the current active route. You can use this data to control which transition to execute for each route.</source>
          <target state="translated">여기에서 &lt;code&gt;prepareRoute()&lt;/code&gt; 메소드는 출력 지시문의 값 ( &lt;code&gt;#outlet=&quot;outlet&quot;&lt;/code&gt; 을 통해 설정 됨)을 가져 와서 현재 활성 경로의 사용자 정의 데이터를 기반으로 애니메이션의 상태를 나타내는 문자열 값을 리턴합니다. 이 데이터를 사용하여 각 경로에 대해 실행할 전환을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db4f248c7a227dfd8248ff1d0b824a2832aa56db" translate="yes" xml:space="preserve">
          <source>Here, the &lt;em&gt;base URL&lt;/em&gt; is the &lt;code&gt;heroesURL&lt;/code&gt; defined in the &lt;a href=&quot;toh-pt6#heroes-and-http&quot;&gt;Heroes and HTTP&lt;/a&gt; section (&lt;code&gt;api/heroes&lt;/code&gt;) and &lt;em&gt;id&lt;/em&gt; is the number of the hero that you want to retrieve. For example, &lt;code&gt;api/heroes/11&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;em&gt;기본 URL&lt;/em&gt; 은 &lt;a href=&quot;toh-pt6#heroes-and-http&quot;&gt;Heroes 및 HTTP&lt;/a&gt; 섹션 ( &lt;code&gt;api/heroes&lt;/code&gt; )에 정의 된 &lt;code&gt;heroesURL&lt;/code&gt; 이며 &lt;em&gt;id&lt;/em&gt; 는 검색하려는 영웅의 수입니다. 예를 들어, &lt;code&gt;api/heroes/11&lt;/code&gt; 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4080166bd678f2eca4714c474d2799cbcb87810f" translate="yes" xml:space="preserve">
          <source>Here, the defined &lt;code&gt;resolve()&lt;/code&gt; function is provided as part of the &lt;code&gt;&lt;a href=&quot;route&quot;&gt;Route&lt;/a&gt;&lt;/code&gt; object in the router configuration:</source>
          <target state="translated">여기에서 정의 된 &lt;code&gt;resolve()&lt;/code&gt; 함수는 라우터 구성에서 &lt;code&gt;&lt;a href=&quot;route&quot;&gt;Route&lt;/a&gt;&lt;/code&gt; 객체의 일부로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="2e5ad69bacbe348316f6f630fe53b52c3b4a48c0" translate="yes" xml:space="preserve">
          <source>Here, the defined guard function is provided as part of the &lt;code&gt;&lt;a href=&quot;route&quot;&gt;Route&lt;/a&gt;&lt;/code&gt; object in the router configuration:</source>
          <target state="translated">여기서 정의 된 가드 기능은 라우터 구성에서 &lt;code&gt;&lt;a href=&quot;route&quot;&gt;Route&lt;/a&gt;&lt;/code&gt; 개체의 일부로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="66b196af8dfb1088f63537fb83ba051a0f53c06f" translate="yes" xml:space="preserve">
          <source>Here, the services and their values are the same, but &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; stops the injector from looking any further than the &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt; for &lt;code&gt;FlowerService&lt;/code&gt;, so it doesn't find it and returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">여기서, 서비스와 해당 값은 동일하지만, &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; 댄 더보고에서 인젝터를 중지 &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt; 에 대한 &lt;code&gt;FlowerService&lt;/code&gt; 그것을 반환을 찾을 수없는, 그래서 &lt;code&gt;null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aca1b7a82a6d95098cb364094dad936a099e0db9" translate="yes" xml:space="preserve">
          <source>Hero &lt;em&gt;Power&lt;/em&gt; selection is required. You can add the same kind of error handling to the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; if you want, but it's not imperative because the selection box already constrains the power to valid values.</source>
          <target state="translated">영웅의 &lt;em&gt;힘을&lt;/em&gt; 선택해야합니다. 원하는 경우 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 에 같은 종류의 오류 처리를 추가 할 수 있지만 선택 상자가 이미 유효 값으로 전력을 제한하기 때문에 반드시 필요한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8d272839c4c67f0a7feb7b568fa8e3446ba7617c" translate="yes" xml:space="preserve">
          <source>Hero data access services (also stubbed).</source>
          <target state="translated">영웅 데이터 액세스 서비스 (또한 스텁 됨).</target>
        </trans-unit>
        <trans-unit id="26c04b546596b8ec97053a1f0220517d0d8abd39" translate="yes" xml:space="preserve">
          <source>Hero feature routing requirements</source>
          <target state="translated">Hero 기능 라우팅 요구 사항</target>
        </trans-unit>
        <trans-unit id="b4fc9a6cb0d706d6d18b352e7c32ae4c311e5f0c" translate="yes" xml:space="preserve">
          <source>Heroes and HTTP</source>
          <target state="translated">영웅과 HTTP</target>
        </trans-unit>
        <trans-unit id="49b093aef09840217c66c59f78c8bd0a260179f8" translate="yes" xml:space="preserve">
          <source>Heroes list: optionally selecting a hero</source>
          <target state="translated">영웅 목록 : 선택적으로 영웅 선택</target>
        </trans-unit>
        <trans-unit id="526386faf0ef30d00c69495be0b464de4aa1decd" translate="yes" xml:space="preserve">
          <source>Hides the element by making it completely transparent and infinitely narrow, by setting its opacity and width to 0.</source>
          <target state="translated">불투명도와 너비를 0으로 설정하여 요소를 완전히 투명하고 좁게하여 요소를 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="4ee5157ec195c6552c32bed0fef0ec3413f5f0a8" translate="yes" xml:space="preserve">
          <source>Hiding an element is different from removing it with &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt;. For comparison, the following example shows how to control the visibility of an element with a &lt;a href=&quot;attribute-binding#class-binding&quot;&gt;class&lt;/a&gt; or &lt;a href=&quot;attribute-binding#style-binding&quot;&gt;style&lt;/a&gt; binding.</source>
          <target state="translated">요소를 숨기는 것은 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 로 제거하는 것과 다릅니다 . 비교를 위해 다음 예제에서는 &lt;a href=&quot;attribute-binding#class-binding&quot;&gt;클래스&lt;/a&gt; 또는 &lt;a href=&quot;attribute-binding#style-binding&quot;&gt;스타일&lt;/a&gt; 바인딩 을 사용하여 요소의 가시성을 제어하는 ​​방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="89da5a8471af66d6f336800d1e48f784de69b323" translate="yes" xml:space="preserve">
          <source>Hiding an element is different from removing it with &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt;. For comparison, the following example shows how to control the visibility of an element with a &lt;a href=&quot;template-syntax#class-binding&quot;&gt;class&lt;/a&gt; or &lt;a href=&quot;template-syntax#style-binding&quot;&gt;style&lt;/a&gt; binding.</source>
          <target state="translated">요소를 숨기는 것은 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 로 요소를 제거하는 것과 다릅니다 . 비교를 위해 다음 예제는 &lt;a href=&quot;template-syntax#class-binding&quot;&gt;클래스&lt;/a&gt; 또는 &lt;a href=&quot;template-syntax#style-binding&quot;&gt;스타일&lt;/a&gt; 바인딩으로 요소의 가시성을 제어하는 ​​방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="f6dfa102549e88b4ab47ff6c2781028644ccca90" translate="yes" xml:space="preserve">
          <source>Hierarchical dependency injection</source>
          <target state="translated">계층 적 종속성 주입</target>
        </trans-unit>
        <trans-unit id="8a3b1b147046025a15fb8a7690182f292845ab57" translate="yes" xml:space="preserve">
          <source>Hierarchical injectors</source>
          <target state="translated">계층 적 인젝터</target>
        </trans-unit>
        <trans-unit id="b544fd8897e805cb5efd919039294bee77b58063" translate="yes" xml:space="preserve">
          <source>High level view</source>
          <target state="translated">높은 수준의 시야</target>
        </trans-unit>
        <trans-unit id="1ea040e47ad5e315c0b6823679ca9344c5c85d16" translate="yes" xml:space="preserve">
          <source>Higher developer consistency with commit message standardization</source>
          <target state="translated">커밋 메시지 표준화로 개발자 일관성 향상</target>
        </trans-unit>
        <trans-unit id="b3e0a103daa9ae3f375b2654f0a482c7c0d36297" translate="yes" xml:space="preserve">
          <source>Hook</source>
          <target state="translated">Hook</target>
        </trans-unit>
        <trans-unit id="1f938b440e9146fcac04f1ceca1a771e15ff6a3b" translate="yes" xml:space="preserve">
          <source>Hook for manual bootstrapping of the application instead of using bootstrap array in @NgModule annotation.</source>
          <target state="translated">@NgModule 주석에서 부트 스트랩 배열을 사용하는 대신 애플리케이션의 수동 부트 스트랩을위한 후크.</target>
        </trans-unit>
        <trans-unit id="ee8d3d098543b8a4b311d8a110ff1f09abc900ff" translate="yes" xml:space="preserve">
          <source>Hook method</source>
          <target state="translated">후크 방식</target>
        </trans-unit>
        <trans-unit id="13797342eb3712b307083382e2ff0e78600433a5" translate="yes" xml:space="preserve">
          <source>Hooking into the component lifecycle</source>
          <target state="translated">구성 요소 수명주기에 연결</target>
        </trans-unit>
        <trans-unit id="3960ec4ca5fb5e5d8cdb2cc1c5121c003e426517" translate="yes" xml:space="preserve">
          <source>Host</source>
          <target state="translated">Host</target>
        </trans-unit>
        <trans-unit id="900e91ae8e4d410ba8ad214c662d46c413ba8c8a" translate="yes" xml:space="preserve">
          <source>Host to listen on.</source>
          <target state="translated">들을 호스트입니다.</target>
        </trans-unit>
        <trans-unit id="854842ca941102874ac3fd35d9a644fe6a4e58d2" translate="yes" xml:space="preserve">
          <source>HostBinding</source>
          <target state="translated">HostBinding</target>
        </trans-unit>
        <trans-unit id="04423f0c0fb006f39c47ae77e76519ec61dae9e9" translate="yes" xml:space="preserve">
          <source>HostListener</source>
          <target state="translated">HostListener</target>
        </trans-unit>
        <trans-unit id="16d6f89a6d102237e8b5809f2f6a83253c134541" translate="yes" xml:space="preserve">
          <source>Hosting an Angular app anywhere else</source>
          <target state="translated">다른 곳에서 Angular 앱 호스팅</target>
        </trans-unit>
        <trans-unit id="b2661e7c9fe866cee0abd12edc765c9ea4167169" translate="yes" xml:space="preserve">
          <source>Hosting an Angular app on Firebase</source>
          <target state="translated">Firebase에서 Angular 앱 호스팅</target>
        </trans-unit>
        <trans-unit id="c9e203bd41e585a498a9ea3bfa7c58968ec8d5be" translate="yes" xml:space="preserve">
          <source>Hosting the built project</source>
          <target state="translated">빌드 된 프로젝트 호스팅</target>
        </trans-unit>
        <trans-unit id="b2e4d2264a6740b74155a1ebd270d51ac74c7499" translate="yes" xml:space="preserve">
          <source>Hour 0-23</source>
          <target state="translated">시간 0-23</target>
        </trans-unit>
        <trans-unit id="e2e437b5f33c50fbf282a8b8ce3d5a4d0deeb077" translate="yes" xml:space="preserve">
          <source>Hour 1-12</source>
          <target state="translated">1-12 시간</target>
        </trans-unit>
        <trans-unit id="cd7d764988e4f76f3f7fbbaaa971d2513fb11bb0" translate="yes" xml:space="preserve">
          <source>How &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;forRoot()&lt;/a&gt;&lt;/code&gt; works</source>
          <target state="translated">어떻게 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;forRoot()&lt;/a&gt;&lt;/code&gt; 작동</target>
        </trans-unit>
        <trans-unit id="9bc4d8fa298867247715dc77fcde7869860686cb" translate="yes" xml:space="preserve">
          <source>How &lt;code&gt;forRoot()&lt;/code&gt; works</source>
          <target state="translated">어떻게 &lt;code&gt;forRoot()&lt;/code&gt; 작동</target>
        </trans-unit>
        <trans-unit id="983fbf13b55a5e7fb496619c191e81853401c3d8" translate="yes" xml:space="preserve">
          <source>How &lt;code&gt;ngUpgrade&lt;/code&gt; Works</source>
          <target state="translated">어떻게 &lt;code&gt;ngUpgrade&lt;/code&gt; 작품</target>
        </trans-unit>
        <trans-unit id="d6d941bd9de7fb7dc2069cff40c89a86c6b8c2dd" translate="yes" xml:space="preserve">
          <source>How AOT works</source>
          <target state="translated">AOT 작동 방식</target>
        </trans-unit>
        <trans-unit id="33f509892f89a76ff518df83752d09bab480dac2" translate="yes" xml:space="preserve">
          <source>How Angular assigns values to template variables</source>
          <target state="translated">Angular가 템플릿 변수에 값을 할당하는 방법</target>
        </trans-unit>
        <trans-unit id="ff5ca3d4267bdd4688ef2f3810892f694a4f2ec9" translate="yes" xml:space="preserve">
          <source>How a reference variable gets its value</source>
          <target state="translated">참조 변수가 값을 얻는 방법</target>
        </trans-unit>
        <trans-unit id="979c9d03c7fcc312615e96357da09f8be513691a" translate="yes" xml:space="preserve">
          <source>How can I tell if an NgModule or service was previously loaded?</source>
          <target state="translated">NgModule 또는 서비스가 이전에로드되었는지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="124b4b601ae7d0767a932ff315c4ae92f3fc2d45" translate="yes" xml:space="preserve">
          <source>How change detection works</source>
          <target state="translated">변경 감지 작동 방식</target>
        </trans-unit>
        <trans-unit id="9048d32b5da3d51d17fa1ee3d4c03154ff798961" translate="yes" xml:space="preserve">
          <source>How do I restrict service scope to a module?</source>
          <target state="translated">서비스 범위를 모듈로 제한하는 방법</target>
        </trans-unit>
        <trans-unit id="42da5511b4616e973fcfac7075b36f7d501b52f9" translate="yes" xml:space="preserve">
          <source>How do you bind to a second property when you're already binding to the &lt;code&gt;appHighlight&lt;/code&gt; attribute name?</source>
          <target state="translated">이미 &lt;code&gt;appHighlight&lt;/code&gt; 속성 이름에 바인딩 할 때 두 번째 속성에 어떻게 바인딩 합니까?</target>
        </trans-unit>
        <trans-unit id="511988e08b2a40201c02270364cefca596e7c32b" translate="yes" xml:space="preserve">
          <source>How do you combat this problem? With asynchronous routing, which loads feature modules &lt;em&gt;lazily&lt;/em&gt;, on request. Lazy loading has multiple benefits.</source>
          <target state="translated">이 문제에 어떻게 대처하십니까? 요청에 따라 기능 모듈을 &lt;em&gt;느리게&lt;/em&gt; 로드하는 비동기 라우팅을 사용합니다 . 지연 로딩에는 여러 가지 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a416099edf7824be4ef297d434f0d54367f5e352" translate="yes" xml:space="preserve">
          <source>How does Angular find components, directives, and pipes in a template?What is a</source>
          <target state="translated">Angular는 템플릿에서 구성 요소, 지시문 및 파이프를 어떻게 찾습니까?</target>
        </trans-unit>
        <trans-unit id="3191620388b1773dd5d13b4c654d9f88a6f22136" translate="yes" xml:space="preserve">
          <source>How does the target &lt;code&gt;HeroDetailComponent&lt;/code&gt; learn about that &lt;code&gt;id&lt;/code&gt;? Don't analyze the URL. Let the router do it.</source>
          <target state="translated">대상 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 는 해당 &lt;code&gt;id&lt;/code&gt; 대해 어떻게 학습 합니까? URL을 분석하지 마십시오. 라우터가 그렇게하도록하십시오.</target>
        </trans-unit>
        <trans-unit id="499d7e268f9c16c28dbe88d3eb572a2620838701" translate="yes" xml:space="preserve">
          <source>How event binding works</source>
          <target state="translated">이벤트 바인딩 작동 방식</target>
        </trans-unit>
        <trans-unit id="1dd6a17cb4033f4f74df1bb6912b8a28a8074084" translate="yes" xml:space="preserve">
          <source>How it works</source>
          <target state="translated">작동 원리</target>
        </trans-unit>
        <trans-unit id="997851a5869594d4c098e863b5fa4094939bdbc3" translate="yes" xml:space="preserve">
          <source>How meanings control text extraction and merging</source>
          <target state="translated">의미가 텍스트 추출 및 병합을 제어하는 ​​방법</target>
        </trans-unit>
        <trans-unit id="a1269b34a684f55e0b793348bbcd441f6ac9f34a" translate="yes" xml:space="preserve">
          <source>How ngUpgrade Works</source>
          <target state="translated">ngUpgrade 작동 방식</target>
        </trans-unit>
        <trans-unit id="b9f4e37b7f4ec8a20702b18e475d1c919dc443c6" translate="yes" xml:space="preserve">
          <source>How preloading works</source>
          <target state="translated">사전로드 작동 방식</target>
        </trans-unit>
        <trans-unit id="223c761d3efb8aa4fcdd8c630361b5e28186b485" translate="yes" xml:space="preserve">
          <source>How the Language Service works</source>
          <target state="translated">언어 서비스 작동 방식</target>
        </trans-unit>
        <trans-unit id="a349db6c3c3e4bc124d0c086f320cf2dc99ff08d" translate="yes" xml:space="preserve">
          <source>How to debug errors with Ivy</source>
          <target state="translated">Ivy로 오류를 디버깅하는 방법</target>
        </trans-unit>
        <trans-unit id="1b8475727e660463a6a5ca3ce7a6ab63829de5ff" translate="yes" xml:space="preserve">
          <source>How to handle a navigation request to the current URL. One of:</source>
          <target state="translated">현재 URL에 대한 탐색 요청을 처리하는 방법 다음 중 하나 :</target>
        </trans-unit>
        <trans-unit id="3acd7184a15f7cd60ff8b0cb2f254e98af8fe7db" translate="yes" xml:space="preserve">
          <source>How to handle missing translations for i18n.</source>
          <target state="translated">i18n에 대한 누락 된 번역을 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="a4312d2c2305c9665e2aa88c16af0276c80bbfb1" translate="yes" xml:space="preserve">
          <source>How to handle query parameters in a router link. One of:</source>
          <target state="translated">라우터 링크에서 쿼리 매개 변수를 처리하는 방법 다음 중 하나 :</target>
        </trans-unit>
        <trans-unit id="133736070cd8def498e352ae2671acf3d2603a1b" translate="yes" xml:space="preserve">
          <source>How to handle query parameters in the router link for the next navigation. One of:</source>
          <target state="translated">다음 탐색을 위해 라우터 링크에서 쿼리 매개 변수를 처리하는 방법 다음 중 하나 :</target>
        </trans-unit>
        <trans-unit id="a516bf86adc981bbb12eae05bdf591c9d762031d" translate="yes" xml:space="preserve">
          <source>How to make a feature module</source>
          <target state="translated">기능 모듈을 만드는 방법</target>
        </trans-unit>
        <trans-unit id="42d423686e07004d3ccb86759ad8206a78194665" translate="yes" xml:space="preserve">
          <source>How to merge parameters, data, and resolved data from parent to child routes. One of:</source>
          <target state="translated">부모에서 자식 경로로 매개 변수, 데이터 및 확인 된 데이터를 병합하는 방법 다음 중 하나 :</target>
        </trans-unit>
        <trans-unit id="ab680df21ca4ccde1eb27c6ee6427aabbfd91cc4" translate="yes" xml:space="preserve">
          <source>How to use &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt; () 을 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="271d720e4f07fc899b89ada24293400628fb4402" translate="yes" xml:space="preserve">
          <source>How to use &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt; () 을 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="2452bce6c068e1419f34d2c7498e5898f5e3f4a3" translate="yes" xml:space="preserve">
          <source>How to write your own structural directive.</source>
          <target state="translated">자신의 구조적 지시문을 작성하는 방법.</target>
        </trans-unit>
        <trans-unit id="23a119c365a39049b543486146aabe9cd6498db5" translate="yes" xml:space="preserve">
          <source>How two-way binding works</source>
          <target state="translated">양방향 바인딩 작동 방식</target>
        </trans-unit>
        <trans-unit id="abfc475c30ad52628f2cdc20da996ccdb18abcc8" translate="yes" xml:space="preserve">
          <source>How you provide services via an &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; (or &lt;code&gt;@&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;()&lt;/code&gt;) decorator determines their visibility. The following sections demonstrate &lt;code&gt;providers&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt; along with ways to modify service visibility with &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; (또는 &lt;code&gt;@&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;()&lt;/code&gt; ) 데코레이터 를 통해 서비스를 제공하는 방법에 따라 가시성이 결정됩니다. 다음 섹션에서는 &lt;code&gt;providers&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; 및 &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; 하여 서비스 가시성을 수정하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="d59e9db4583cfeade655bda1cee43c9a4d0bf9b2" translate="yes" xml:space="preserve">
          <source>How you provide services via an &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; (or &lt;code&gt;@&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;()&lt;/code&gt;) decorator determines their visibility. The following sections demonstrate &lt;code&gt;providers&lt;/code&gt; and &lt;code&gt;viewProviders&lt;/code&gt; along with ways to modify service visibility with &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; (또는 &lt;code&gt;@&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;()&lt;/code&gt; ) 데코레이터 를 통해 서비스를 제공하는 방법에 따라 가시성이 결정됩니다. 다음 섹션에서는 &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt; () 및 &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt; ()를 사용 하여 서비스 가시성을 수정하는 방법과 함께 &lt;code&gt;providers&lt;/code&gt; 및 &lt;code&gt;viewProviders&lt;/code&gt; 를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="3c06ea1a10cb3f7599812cd4dd0520ada6ed15d2" translate="yes" xml:space="preserve">
          <source>How you provide this information depends upon whether you compile with the JIT compiler or the AOT compiler.</source>
          <target state="translated">이 정보를 제공하는 방법은 JIT 컴파일러 또는 AOT 컴파일러로 컴파일하는지에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="42af694ff0648a4162e6e3bb0c6873e411523ff3" translate="yes" xml:space="preserve">
          <source>However the template binding syntax will always use the Angular style, e.g. square brackets (&lt;code&gt;[...]&lt;/code&gt;) for property binding.</source>
          <target state="translated">그러나 템플릿 바인딩 구문은 속성 바인딩에 항상 Angular 스타일 (예 : 대괄호 ( &lt;code&gt;[...]&lt;/code&gt; ))을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="dbda69fe90fc2df22f7e5b8531e85b712730ae09" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; observables are among the exceptions because &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; and its observables are insulated from the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; itself. The &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; destroys a routed component when it is no longer needed along with the injected &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; 관찰 가능 항목은 &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; 와 해당 관찰 가능 항목이 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 자체 에서 격리 되기 때문에 예외 입니다. &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 가 더 이상 주입과 함께 필요한 라우팅 된 구성 요소를 파괴 &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="a52ad01a1e6f8429d7b5fd705ab3383b484815aa" translate="yes" xml:space="preserve">
          <source>However, a pure pipe with an array as input may not work the way you want. To demonstrate this issue, change the previous example to filter the list of heroes to just those heroes who can fly. Use the &lt;code&gt;FlyingHeroesPipe&lt;/code&gt; in the &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; repeater as shown in the following code. The tabs for the example show the following:</source>
          <target state="translated">그러나 배열을 입력으로 사용하는 순수 파이프는 원하는 방식으로 작동하지 않을 수 있습니다. 이 문제를 설명하려면 이전 예제를 변경하여 영웅 목록을 비행 할 수있는 영웅으로 만 필터링합니다. 다음 코드와 같이 &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt; 리피터 에서 &lt;code&gt;FlyingHeroesPipe&lt;/code&gt; 를 사용합니다 . 예제의 탭은 다음을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="78384c3742fdf68b1246d1ffbeeb9846d7e95bf3" translate="yes" xml:space="preserve">
          <source>However, a token doesn't have to be a class and even when it is a class, it doesn't have to be the same type as the returned object. That's the subject of the next section.</source>
          <target state="translated">그러나 토큰은 클래스 일 필요는 없으며 클래스 일 때도 반환 된 객체와 동일한 유형일 필요는 없습니다. 이것이 다음 섹션의 주제입니다.</target>
        </trans-unit>
        <trans-unit id="a51870768d3d98c605578aafcc0c0d074ca996ed" translate="yes" xml:space="preserve">
          <source>However, accessing a template variable from outside the parent template doesn't work.</source>
          <target state="translated">그러나 상위 템플릿 외부에서 템플릿 변수에 액세스하는 것은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b3116f3e696e3745d93dc36e6d542835460c30c1" translate="yes" xml:space="preserve">
          <source>However, behind the scenes, Angular uses a logical view representation as follows when resolving injection requests:</source>
          <target state="translated">그러나 뒤에서 Angular는 주입 요청을 해결할 때 다음과 같이 논리적 뷰 표현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="693f46cb5ca176639aee0593be73408376b61903" translate="yes" xml:space="preserve">
          <source>However, certain JavaScript syntax is not allowed:</source>
          <target state="translated">그러나 특정 JavaScript 구문은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="16c8b7823d939bc8f045eae68088694acbb86125" translate="yes" xml:space="preserve">
          <source>However, due to the way Angular stores injection tokens, it is possible that such an unused component or service can end up in the bundle anyway. This page describes a dependency-injection design pattern that supports proper tree-shaking by using lightweight injection tokens.</source>
          <target state="translated">그러나 Angular가 주입 토큰을 저장하는 방식으로 인해 사용하지 않는 구성 요소 또는 서비스가 어쨌든 번들에 포함될 수 있습니다. 이 페이지에서는 경량 주입 토큰을 사용하여 적절한 트리 쉐이킹을 지원하는 종속성 주입 설계 패턴을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0553864b7141e33b190505316313eab2ee87daa6" translate="yes" xml:space="preserve">
          <source>However, executing a pipe to update the display with every change would slow down your app's performance. So Angular uses a faster change-detection algorithm for executing a pipe, as described in the next section.</source>
          <target state="translated">그러나 파이프를 실행하여 모든 변경 사항으로 디스플레이를 업데이트하면 앱 성능이 저하됩니다. 따라서 Angular는 다음 섹션에서 설명하는 것처럼 파이프를 실행하기 위해 더 빠른 변경 감지 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="98c48d0fa6289215af7e49a79607c8e0ccd6333d" translate="yes" xml:space="preserve">
          <source>However, if you run the tests in a &lt;strong&gt;non-CLI environment&lt;/strong&gt;, tests of this component may fail. For example, if you run the &lt;code&gt;BannerComponent&lt;/code&gt; tests in a web coding environment such as &lt;a href=&quot;https://plnkr.co/&quot;&gt;plunker&lt;/a&gt;, you'll see a message like this one:</source>
          <target state="translated">그러나 &lt;strong&gt;비 CLI 환경&lt;/strong&gt; 에서 테스트를 실행하면이 구성 요소 테스트에 실패 할 수 있습니다. 당신이 실행하는 경우 예를 들어, &lt;code&gt;BannerComponent&lt;/code&gt; 의 같은 환경을 코딩 웹에서 테스트 &lt;a href=&quot;https://plnkr.co/&quot;&gt;plunker를&lt;/a&gt; ,이 같은 메시지를 볼 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="34e226b688a864f31651d20b9d5626cdbd2a322e" translate="yes" xml:space="preserve">
          <source>However, in practice, Angular simply ignores two-way bindings to template variables. Starting in version 8, attempting to write to template variables is deprecated. In a future version, we will throw to indicate that the write is not supported.</source>
          <target state="translated">그러나 실제로 Angular는 템플릿 변수에 대한 양방향 바인딩을 무시합니다. 버전 8부터는 템플릿 변수에 쓰려고 시도하지 않습니다. 이후 버전에서는 쓰기가 지원되지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5f46d3bcb10089005d7612c3f9cc519539d288fe" translate="yes" xml:space="preserve">
          <source>However, injecting the real service rarely works well as most dependent services are difficult to create and control.</source>
          <target state="translated">그러나 실제 서비스를 주입하는 것은 거의 효과가 없으며 대부분의 종속 서비스는 작성 및 제어하기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="9233cd0b325f45f872324e3cd65f528e0634c2ca" translate="yes" xml:space="preserve">
          <source>However, selective child animations can still be run on a disabled parent in one of the following ways:</source>
          <target state="translated">그러나 다음 중 하나의 방법으로 비활성화 된 부모에서 선택적 자식 애니메이션을 계속 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="319f88f562107ebe58d7c5640582471d82bf98d7" translate="yes" xml:space="preserve">
          <source>However, some translation systems require a specific form or syntax for the ID. To address this requirement, you can mark text with &lt;em&gt;custom&lt;/em&gt; IDs. While most developers don't need to use custom IDs, some may want to use IDs that have a unique syntax to convey additional metadata (such as the library, component, or area of the app in which the text appears).</source>
          <target state="translated">그러나 일부 번역 시스템에는 ID에 대한 특정 형식이나 구문이 필요합니다. 이 요구 사항을 해결하기 위해 &lt;em&gt;사용자 지정&lt;/em&gt; ID로 텍스트를 표시 할 수 있습니다 . 대부분의 개발자는 사용자 지정 ID를 사용할 필요가 없지만 일부 개발자는 추가 메타 데이터 (예 : 텍스트가 표시되는 라이브러리, 구성 요소 또는 앱 영역)를 전달하기 위해 고유 한 구문이있는 ID를 사용하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29af858dd493651d68cc842edbeb89ea3c49cdf1" translate="yes" xml:space="preserve">
          <source>However, testing a single use case is unlikely to explore the full range of a directive's capabilities. Finding and testing all components that use the directive is tedious, brittle, and almost as unlikely to afford full coverage.</source>
          <target state="translated">그러나 단일 사용 사례를 테스트한다고해서 모든 지시어 기능을 탐색 할 수는 없습니다. 이 지침을 사용하는 모든 구성 요소를 찾고 테스트하는 작업은 지루하고 취하기 쉬우 며 전체 적용 범위를 제공 할 가능성은 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="63c4f7ceb30a9aea5c8f145005bfe8df2bd99995" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;AnimalService&lt;/code&gt;, which is provided in the &lt;code&gt;AppComponent&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt; array, is visible.</source>
          <target state="translated">그러나 &lt;code&gt;AnimalService&lt;/code&gt; 제공된다 &lt;code&gt;AppComponent&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt; 의 배열이 표시된다.</target>
        </trans-unit>
        <trans-unit id="6d2f98825b9add3ac5515eab04960da13e1e316a" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;AnimalService&lt;/code&gt;, which is provided in the &lt;code&gt;AppComponent&lt;/code&gt;&lt;code&gt;viewProviders&lt;/code&gt; array, is visible.</source>
          <target state="translated">그러나 &lt;code&gt;AnimalService&lt;/code&gt; 제공된다 &lt;code&gt;AppComponent&lt;/code&gt; &lt;code&gt;viewProviders&lt;/code&gt; 의 배열이 표시된다.</target>
        </trans-unit>
        <trans-unit id="409b0b30eacfefc2c2ac82f07ea268d1b0b9bb37" translate="yes" xml:space="preserve">
          <source>However, this might feel like an unwelcome surprise if you expect the module's services to be visible only to the components declared by that feature module. If the &lt;code&gt;HeroModule&lt;/code&gt; provides the &lt;code&gt;HeroService&lt;/code&gt; and the root &lt;code&gt;AppModule&lt;/code&gt; imports &lt;code&gt;HeroModule&lt;/code&gt;, any class that knows the &lt;code&gt;HeroService&lt;/code&gt;&lt;em&gt;type&lt;/em&gt; can inject that service, not just the classes declared in the &lt;code&gt;HeroModule&lt;/code&gt;.</source>
          <target state="translated">그러나 모듈의 서비스가 해당 기능 모듈에 의해 선언 된 구성 요소에만 표시 될 것으로 예상되는 경우 이는 예상치 못한 일입니다. 는 IF &lt;code&gt;HeroModule&lt;/code&gt; 이 제공 &lt;code&gt;HeroService&lt;/code&gt; 루트 &lt;code&gt;AppModule&lt;/code&gt; 의 수입 &lt;code&gt;HeroModule&lt;/code&gt; 는 알고있는 모든 클래스 &lt;code&gt;HeroService&lt;/code&gt; 의&lt;em&gt;유형은&lt;/em&gt; 해당 서비스를 주입 할 수 있습니다,뿐만 아니라 클래스는 선언 &lt;code&gt;HeroModule&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30edf6e204f52b61f2571aecc7c209f88b84ea1f" translate="yes" xml:space="preserve">
          <source>However, this will work:</source>
          <target state="translated">그러나 이것은 작동합니다 :</target>
        </trans-unit>
        <trans-unit id="d6af0af1a9e9d11d2d6ee59278094f54f71c5e1d" translate="yes" xml:space="preserve">
          <source>However, to set &lt;em&gt;many&lt;/em&gt; inline styles at the same time, use the &lt;code&gt;&lt;a href=&quot;../api/common/ngstyle&quot;&gt;NgStyle&lt;/a&gt;&lt;/code&gt; directive.</source>
          <target state="translated">그러나 동시에 &lt;em&gt;많은&lt;/em&gt; 인라인 스타일 을 설정 하려면 &lt;code&gt;&lt;a href=&quot;../api/common/ngstyle&quot;&gt;NgStyle&lt;/a&gt;&lt;/code&gt; 지시문을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d76129a2020266d4c676249304bb9a0e0d5fd584" translate="yes" xml:space="preserve">
          <source>However, when Angular expands the shorthand syntax, it creates another &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; tag, with &lt;code&gt;&lt;a href=&quot;ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ngif#ngIfElse&quot;&gt;ngIfElse&lt;/a&gt;&lt;/code&gt; directives. The anchor element containing the template for the &quot;then&quot; clause becomes the content of this unlabeled &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">그러나 Angular가 속기 구문을 확장하면 &lt;code&gt;&lt;a href=&quot;ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ngif#ngIfElse&quot;&gt;ngIfElse&lt;/a&gt;&lt;/code&gt; 지시문 과 함께 다른 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 태그가 작성 됩니다. &quot;then&quot;절의 템플리트를 포함하는 앵커 요소는 레이블이없는이 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 태그 의 컨텐츠가됩니다 .</target>
        </trans-unit>
        <trans-unit id="56d575a6c0a58c4606bda23eaa28f170e0ba3f40" translate="yes" xml:space="preserve">
          <source>However, when Angular expands the shorthand syntax, it creates another &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; tag, with &lt;code&gt;&lt;a href=&quot;ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;ngIfElse&lt;/code&gt; directives. The anchor element containing the template for the &quot;then&quot; clause becomes the content of this unlabeled &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">그러나 Angular가 속기 구문을 확장하면 &lt;code&gt;&lt;a href=&quot;ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;ngIfElse&lt;/code&gt; 지시문 과 함께 또 다른 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 태그 가 생성 됩니다. &quot;then&quot;절에 대한 템플릿을 포함하는 앵커 요소는 레이블이없는이 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 태그의 내용이됩니다.</target>
        </trans-unit>
        <trans-unit id="88d996735fae87b45148458d37047b283d694373" translate="yes" xml:space="preserve">
          <source>However, with &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;itemForm&lt;/code&gt; is a reference to the &lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt; directive with the ability to track the value and validity of every control in the form.</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; 의 경우 &lt;code&gt;itemForm&lt;/code&gt; 은 폼에있는 모든 컨트롤의 값과 유효성을 추적 할 수 있는 &lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt; 지시문에 대한 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="4f61b26fdb00998634e95b429fc277a6dcf31568" translate="yes" xml:space="preserve">
          <source>However, you almost always inject services into application classes using Angular dependency injection and you should have tests that reflect that usage pattern. Angular testing utilities make it easy to investigate how injected services behave.</source>
          <target state="translated">그러나 Angular 종속성 주입을 사용하여 거의 항상 서비스를 응용 프로그램 클래스에 주입하므로 해당 사용 패턴을 반영하는 테스트가 있어야합니다. 각도 테스트 유틸리티를 사용하면 주입 된 서비스의 작동 방식을 쉽게 조사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e1a2e9c4edb38cc5f33c8a92e731a540c8a4e2e" translate="yes" xml:space="preserve">
          <source>However, you might be troubled by the fact that the real service doesn't quite behave this way. The real service sends requests to a remote server. A server takes time to respond and the response certainly won't be available immediately as in the previous two tests.</source>
          <target state="translated">그러나 실제 서비스가 이러한 방식으로 작동하지 않는다는 사실 때문에 문제가 발생할 수 있습니다. 실제 서비스는 요청을 원격 서버로 보냅니다. 서버가 응답하는 데 시간이 걸리고 이전 두 테스트에서와 같이 즉시 응답을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="07028f666590e3943a2a7158467fb00b0a46d178" translate="yes" xml:space="preserve">
          <source>HttpBackend</source>
          <target state="translated">HttpBackend</target>
        </trans-unit>
        <trans-unit id="74f0d45346780c9a2f7d9ba9c77d099f9ae02d4f" translate="yes" xml:space="preserve">
          <source>HttpClient</source>
          <target state="translated">HttpClient</target>
        </trans-unit>
        <trans-unit id="3dfdf9e078469afa983319e9dbcfec4b07dc38ed" translate="yes" xml:space="preserve">
          <source>HttpClientJsonpModule</source>
          <target state="translated">HttpClientJsonpModule</target>
        </trans-unit>
        <trans-unit id="601f075dcbf43fc07aee8d1626b1bb0090dc3e86" translate="yes" xml:space="preserve">
          <source>HttpClientModule</source>
          <target state="translated">HttpClientModule</target>
        </trans-unit>
        <trans-unit id="ca61ddc922f1c4bb126860b1fcceb0121f1e72b7" translate="yes" xml:space="preserve">
          <source>HttpClientTestingModule</source>
          <target state="translated">HttpClientTestingModule</target>
        </trans-unit>
        <trans-unit id="b0e4475f7bcbcf9e3bfc2d2b8cb35a87cd9da63f" translate="yes" xml:space="preserve">
          <source>HttpClientXsrfModule</source>
          <target state="translated">HttpClientXsrfModule</target>
        </trans-unit>
        <trans-unit id="31b51a48c6488640e3d7d12f81484cc7692bc954" translate="yes" xml:space="preserve">
          <source>HttpDownloadProgressEvent</source>
          <target state="translated">HttpDownloadProgressEvent</target>
        </trans-unit>
        <trans-unit id="631eed221a0a5e1227ee747dedc56a6e5cd04856" translate="yes" xml:space="preserve">
          <source>HttpErrorResponse</source>
          <target state="translated">HttpErrorResponse</target>
        </trans-unit>
        <trans-unit id="b601dad14c6ceb3e36baf63c5302eab72656db35" translate="yes" xml:space="preserve">
          <source>HttpEvent</source>
          <target state="translated">HttpEvent</target>
        </trans-unit>
        <trans-unit id="a25e2886e345f200e99c43296e545f2ec17e87d9" translate="yes" xml:space="preserve">
          <source>HttpEventType</source>
          <target state="translated">HttpEventType</target>
        </trans-unit>
        <trans-unit id="34a6f13d629874a5d2af931439592d54346c6458" translate="yes" xml:space="preserve">
          <source>HttpHandler</source>
          <target state="translated">HttpHandler</target>
        </trans-unit>
        <trans-unit id="13819588a41868e3eb12c563e1b5ce196d242ce8" translate="yes" xml:space="preserve">
          <source>HttpHeaderResponse</source>
          <target state="translated">HttpHeaderResponse</target>
        </trans-unit>
        <trans-unit id="47652085284b8b02e10d108308cf4fafe0936706" translate="yes" xml:space="preserve">
          <source>HttpHeaders</source>
          <target state="translated">HttpHeaders</target>
        </trans-unit>
        <trans-unit id="8184f8a7796e7947f825158c72ba880534cdf906" translate="yes" xml:space="preserve">
          <source>HttpInterceptor</source>
          <target state="translated">HttpInterceptor</target>
        </trans-unit>
        <trans-unit id="306e8873cd28a3d318c8259a4ca9675c917ea59c" translate="yes" xml:space="preserve">
          <source>HttpParameterCodec</source>
          <target state="translated">HttpParameterCodec</target>
        </trans-unit>
        <trans-unit id="f0370ec95bcf0338af85d0d9ee233cbf9b147f0e" translate="yes" xml:space="preserve">
          <source>HttpParams</source>
          <target state="translated">HttpParams</target>
        </trans-unit>
        <trans-unit id="49286b34daf58a4360367b78695303f96afd888f" translate="yes" xml:space="preserve">
          <source>HttpProgressEvent</source>
          <target state="translated">HttpProgressEvent</target>
        </trans-unit>
        <trans-unit id="876884817603f1994832b258f47c862ce8f79db8" translate="yes" xml:space="preserve">
          <source>HttpRequest</source>
          <target state="translated">HttpRequest</target>
        </trans-unit>
        <trans-unit id="98a81a35f1584d5f5070065dbea832e61fb0bf0f" translate="yes" xml:space="preserve">
          <source>HttpResponse</source>
          <target state="translated">HttpResponse</target>
        </trans-unit>
        <trans-unit id="41598c5b775fa5c84b8eee569b34c38dcacdd477" translate="yes" xml:space="preserve">
          <source>HttpResponseBase</source>
          <target state="translated">HttpResponseBase</target>
        </trans-unit>
        <trans-unit id="91259ca5dbf5ee0c7be0ec1ecec66070797276f8" translate="yes" xml:space="preserve">
          <source>HttpSentEvent</source>
          <target state="translated">HttpSentEvent</target>
        </trans-unit>
        <trans-unit id="0ec2efbe19ba7e3ef035c35046c8d7e07d7af284" translate="yes" xml:space="preserve">
          <source>HttpTestingController</source>
          <target state="translated">HttpTestingController</target>
        </trans-unit>
        <trans-unit id="2594ee986b764be8ea778008c933b096d5b6bf37" translate="yes" xml:space="preserve">
          <source>HttpUploadProgressEvent</source>
          <target state="translated">HttpUploadProgressEvent</target>
        </trans-unit>
        <trans-unit id="97816692d8c249075784ff4511d32cb3200d0fae" translate="yes" xml:space="preserve">
          <source>HttpUrlEncodingCodec</source>
          <target state="translated">HttpUrlEncodingCodec</target>
        </trans-unit>
        <trans-unit id="0aa97445f8cf4a27064f48a9964e2e2e5accb9b5" translate="yes" xml:space="preserve">
          <source>HttpUserEvent</source>
          <target state="translated">HttpUserEvent</target>
        </trans-unit>
        <trans-unit id="d81289e5fca4f39bab401bd23f2b00141a74346a" translate="yes" xml:space="preserve">
          <source>HttpXhrBackend</source>
          <target state="translated">HttpXhrBackend</target>
        </trans-unit>
        <trans-unit id="7869711a68093e11cb599a1fe14c17baa6ba3dd6" translate="yes" xml:space="preserve">
          <source>HttpXsrfTokenExtractor</source>
          <target state="translated">HttpXsrfTokenExtractor</target>
        </trans-unit>
        <trans-unit id="801f2493757c72ca45a5c235d90ad1ca581f7755" translate="yes" xml:space="preserve">
          <source>Human-readable format of exponential. Example: 1.2x103</source>
          <target state="translated">사람이 읽을 수있는 지수 형식. 예 : 1.2x103</target>
        </trans-unit>
        <trans-unit id="02b7c47c72c0e2f2d5177bd712fd4bfe5eec025c" translate="yes" xml:space="preserve">
          <source>Hybrid Angular applications</source>
          <target state="translated">하이브리드 각도 응용 프로그램</target>
        </trans-unit>
        <trans-unit id="6ed0186e952f0fc2ad82383289a170a0c73f97bd" translate="yes" xml:space="preserve">
          <source>I18nPluralPipe</source>
          <target state="translated">I18nPluralPipe</target>
        </trans-unit>
        <trans-unit id="abc1f616112daf4b387de1e6658364fdc11d58ba" translate="yes" xml:space="preserve">
          <source>I18nSelectPipe</source>
          <target state="translated">I18nSelectPipe</target>
        </trans-unit>
        <trans-unit id="6d2560c581ebaf3afab03757b7c3c7c2fc658887" translate="yes" xml:space="preserve">
          <source>ICU parsing happens at runtime, so only text, HTML tags and text bindings are allowed inside ICU cases (previously, directives were also permitted inside ICUs).</source>
          <target state="translated">ICU 구문 분석은 런타임에 발생하므로 ICU 케이스 내에서는 텍스트, HTML 태그 및 텍스트 바인딩 만 허용됩니다 (이전에는 ICU 내에서도 지시문이 허용됨).</target>
        </trans-unit>
        <trans-unit id="843165076cf3bd0349681e4beeed1c6874126cc4" translate="yes" xml:space="preserve">
          <source>ID of the option element</source>
          <target state="translated">옵션 요소의 ID</target>
        </trans-unit>
        <trans-unit id="877c0ac1ba5622c5882fedcdd9a0af40b83febbd" translate="yes" xml:space="preserve">
          <source>IDs conform to the Unicode Common Locale Data Repository (CLDR). For more information about Unicode locale identifiers, see the &lt;a href=&quot;http://cldr.unicode.org/core-spec#Unicode_Language_and_Locale_Identifiers&quot;&gt;CLDR core specification&lt;/a&gt;.</source>
          <target state="translated">ID는 유니 코드 CLDR (Common Locale Data Repository)을 따릅니다. 유니 코드 로케일 식별자에 대한 자세한 내용은 &lt;a href=&quot;http://cldr.unicode.org/core-spec#Unicode_Language_and_Locale_Identifiers&quot;&gt;CLDR 핵심 사양을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ff31bb53dfc2bff233e882d367714fba682d7dc" translate="yes" xml:space="preserve">
          <source>IE</source>
          <target state="translated">IE</target>
        </trans-unit>
        <trans-unit id="e99eab8a5ebe9abaa8723fd9f1ddbf2c7d1a25dc" translate="yes" xml:space="preserve">
          <source>IE 10, IE 11</source>
          <target state="translated">IE 10, IE 11</target>
        </trans-unit>
        <trans-unit id="09500d66bc1c080dec280867c70d89f272b9554c" translate="yes" xml:space="preserve">
          <source>IE 11</source>
          <target state="translated">IE 11</target>
        </trans-unit>
        <trans-unit id="8e9963ae494f00fdfda1290439172d2aa12514d1" translate="yes" xml:space="preserve">
          <source>IE 9</source>
          <target state="translated">IE 9</target>
        </trans-unit>
        <trans-unit id="8c7d126d16997b97355174dcda4c6bb9cf8e2b48" translate="yes" xml:space="preserve">
          <source>IE Mobile</source>
          <target state="translated">IE 모바일</target>
        </trans-unit>
        <trans-unit id="60b82a5cb94fb01631398c058b59f037ae77f375" translate="yes" xml:space="preserve">
          <source>IIFE</source>
          <target state="translated">IIFE</target>
        </trans-unit>
        <trans-unit id="3449c1aa01ef7a63b3d78a29f229155083bed4a6" translate="yes" xml:space="preserve">
          <source>INITIAL_CONFIG</source>
          <target state="translated">INITIAL_CONFIG</target>
        </trans-unit>
        <trans-unit id="7242c809890f5e50a88ffd8ad02f9da60184dd4a" translate="yes" xml:space="preserve">
          <source>INJECTOR</source>
          <target state="translated">INJECTOR</target>
        </trans-unit>
        <trans-unit id="5157ac1ff7f65b428bec7bef08cc132329b63c6d" translate="yes" xml:space="preserve">
          <source>ISO8601 basic format</source>
          <target state="translated">ISO8601 기본 형식</target>
        </trans-unit>
        <trans-unit id="39097fa6a5275ab54197cd03bbe174e778b7eb1c" translate="yes" xml:space="preserve">
          <source>ISO8601 extended format + Z indicator for offset 0 (= XXXXX)</source>
          <target state="translated">오프셋 0에 대한 ISO8601 확장 형식 + Z 표시기 (= XXXXX)</target>
        </trans-unit>
        <trans-unit id="63c464b08623002f37661266e75b01e33a159ea0" translate="yes" xml:space="preserve">
          <source>Ideally, a component's job is to enable the user experience and nothing more. A component should present properties and methods for data binding, in order to mediate between the view (rendered by the template) and the application logic (which often includes some notion of a &lt;em&gt;model&lt;/em&gt;).</source>
          <target state="translated">이상적으로 구성 요소의 역할은 사용자 경험을 가능하게하는 것입니다. 컴포넌트는 뷰 (템플릿에 의해 렌더링 됨)와 애플리케이션 로직 (종종 &lt;em&gt;모델&lt;/em&gt; 개념 포함) 사이를 중개하기 위해 데이터 바인딩을위한 특성 및 메소드를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="273acb31b215d9e49019afd7c3e7cf8d4a83de16" translate="yes" xml:space="preserve">
          <source>Ideally, if an application isn't injecting a service, Angular shouldn't include it in the final output. However, Angular has to be able to identify at build time whether the app will require the service or not. Because it's always possible to inject a service directly using &lt;code&gt;injector.get(Service)&lt;/code&gt;, Angular can't identify all of the places in your code where this injection could happen, so it has no choice but to include the service in the injector. Thus, services in the NgModule &lt;code&gt;providers&lt;/code&gt; array or at component level are not tree-shakable.</source>
          <target state="translated">이상적으로 응용 프로그램이 서비스를 주입하지 않으면 Angular는 최종 출력에 서비스를 포함시키지 않아야합니다. 그러나 Angular는 빌드시 앱에 서비스가 필요한지 여부를 식별 할 수 있어야합니다. &lt;code&gt;injector.get(Service)&lt;/code&gt; 사용하여 직접 서비스를 직접 주입 할 수 있기 때문에 Angular는 코드에서이 삽입이 발생할 수있는 모든 위치를 식별 할 수 없으므로 인젝터에 서비스를 포함시킬 수밖에 없습니다. 따라서 NgModule &lt;code&gt;providers&lt;/code&gt; 배열 또는 구성 요소 수준의 서비스는 트리를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c0c74f9c69e219a901e496db780fa7e03049a871" translate="yes" xml:space="preserve">
          <source>Ideally, users should be able to click a link to navigate rather than pasting a route URL into the address bar.</source>
          <target state="translated">이상적으로, 사용자는 주소 표시 줄에 경로 URL을 붙여 넣지 않고 링크를 클릭하여 탐색 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="06b6ace8ca3f18249e8ba4ea9090c0f34564ce1c" translate="yes" xml:space="preserve">
          <source>Identifier</source>
          <target state="translated">Identifier</target>
        </trans-unit>
        <trans-unit id="f58ce3d35d93d2140b71abc0fa1b54986940d04d" translate="yes" xml:space="preserve">
          <source>Identifies and handles a given HTTP request.</source>
          <target state="translated">주어진 HTTP 요청을 식별하고 처리합니다.</target>
        </trans-unit>
        <trans-unit id="faa69bd85cc69080cb6a8a871ae2448b19bdf3da" translate="yes" xml:space="preserve">
          <source>Identifies and handles a given JSONP request.</source>
          <target state="translated">주어진 JSONP 요청을 식별하고 처리합니다.</target>
        </trans-unit>
        <trans-unit id="dee8349d1c84482e40f15df8442baac4ca99ef95" translate="yes" xml:space="preserve">
          <source>Identifies requests with the method JSONP and shifts them to the &lt;code&gt;&lt;a href=&quot;http/jsonpclientbackend&quot;&gt;JsonpClientBackend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">JSONP 메소드로 요청을 식별하고 &lt;code&gt;&lt;a href=&quot;http/jsonpclientbackend&quot;&gt;JsonpClientBackend&lt;/a&gt;&lt;/code&gt; 로 이동시킵니다 .</target>
        </trans-unit>
        <trans-unit id="f8df9c229b309d13b4e14007cc922a7bc063af20" translate="yes" xml:space="preserve">
          <source>Identifies requests with the method JSONP and shifts them to the &lt;code&gt;&lt;a href=&quot;jsonpclientbackend&quot;&gt;JsonpClientBackend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">JSONP 메소드로 요청을 식별하고 &lt;code&gt;&lt;a href=&quot;jsonpclientbackend&quot;&gt;JsonpClientBackend&lt;/a&gt;&lt;/code&gt; 로 이동시킵니다 .</target>
        </trans-unit>
        <trans-unit id="839e3114e3b9d3a3fa48867a14c4e9afe0357710" translate="yes" xml:space="preserve">
          <source>Identifies the call or event that triggered the navigation. An &lt;code&gt;imperative&lt;/code&gt; trigger is a call to &lt;code&gt;router.navigateByUrl()&lt;/code&gt; or &lt;code&gt;router.navigate()&lt;/code&gt;.</source>
          <target state="translated">탐색을 트리거 한 통화 또는 이벤트를 식별합니다. &lt;code&gt;imperative&lt;/code&gt; 트리거가에 호출입니다 &lt;code&gt;router.navigateByUrl()&lt;/code&gt; 또는 &lt;code&gt;router.navigate()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25ab5ba8ca530f5f158154b68ffbcf85362be05b" translate="yes" xml:space="preserve">
          <source>Identifies the new platform factory.</source>
          <target state="translated">새 플랫폼 팩토리를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="38af51b71aa8062ad05f52bc1d4222fe545ab1aa" translate="yes" xml:space="preserve">
          <source>Identify</source>
          <target state="translated">Identify</target>
        </trans-unit>
        <trans-unit id="2a58e4f2e431bfd56df14f3e8c74e1585ce5f28d" translate="yes" xml:space="preserve">
          <source>Identify the active route</source>
          <target state="translated">활성 경로 식별</target>
        </trans-unit>
        <trans-unit id="e4f148f2d6935d4ae76200aaec633ed31b1033b2" translate="yes" xml:space="preserve">
          <source>Identity reference</source>
          <target state="translated">신원 참조</target>
        </trans-unit>
        <trans-unit id="f24e9c9588c68667b970bc698f5d8988ec03b9be" translate="yes" xml:space="preserve">
          <source>Idle task queue</source>
          <target state="translated">유휴 작업 대기열</target>
        </trans-unit>
        <trans-unit id="6bb4d315363a95a4fbf146f2054fbe340f1c9487" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the view still renders but the displayed value is blank; you see only &quot;The item name is:&quot; with nothing after it.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; 뷰는 여전히 렌더링하지만, 표시된 값이 비어 있습니다; &quot;항목 이름은 다음과 같습니다.&quot;만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6da6a54b219d1bf81b2cc66cad7dd0e7ddd6117a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;httprequest#responseType&quot;&gt;responseType&lt;/a&gt;&lt;/code&gt; is the default &lt;code&gt;&lt;a href=&quot;../jsonpipe&quot;&gt;json&lt;/a&gt;&lt;/code&gt;, you can pass a type interface for the resulting object as a type parameter to the call.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;httprequest#responseType&quot;&gt;responseType&lt;/a&gt;&lt;/code&gt; 은 기본입니다 &lt;code&gt;&lt;a href=&quot;../jsonpipe&quot;&gt;json&lt;/a&gt;&lt;/code&gt; , 당신은 전화에 입력 매개 변수로 생성 된 객체의 유형 인터페이스를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f61235f17a9a61f1406e160be41b27344ea51d3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;@angular/localize&lt;/code&gt; is not installed, the Angular CLI may generate an error when you try to build a localized version of your app.</source>
          <target state="translated">경우 &lt;code&gt;@angular/localize&lt;/code&gt; 설치되지 않은 앱의 지역화 된 버전을 빌드 할 때, 각 CLI 오류를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20046da8dd9cbe89cc7285da01207f6baa79e09b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt; in the given options, the module will behave as if service workers are not supported by the browser, and the service worker will not be registered.</source>
          <target state="translated">경우 &lt;code&gt;enabled&lt;/code&gt; 으로 설정되어 &lt;code&gt;false&lt;/code&gt; 주어진 옵션에서, 모듈은 서비스 작업자가 브라우저에서 지원되지 않으며, 서비스 노동자가 등록하지 않을 경우로 동작합니다.</target>
        </trans-unit>
        <trans-unit id="e98a50040a0048fe1d6d721d215eaf87a57c6337" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ignoreCancelled&lt;/code&gt; is not set (the default), &lt;code&gt;verify()&lt;/code&gt; will also fail if cancelled requests were not explicitly matched.</source>
          <target state="translated">경우 &lt;code&gt;ignoreCancelled&lt;/code&gt; 이 (기본값) 설정되지 않은, &lt;code&gt;verify()&lt;/code&gt; 취소 요청이 명시 적으로 일치되지 않은 경우에도 실패합니다.</target>
        </trans-unit>
        <trans-unit id="2634a7b2c56c056a6b1cbec3a8b79516051dae63" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;item&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the view still renders but the displayed value is blank; you see only &quot;The item name is:&quot; with nothing after it.</source>
          <target state="translated">경우 &lt;code&gt;item&lt;/code&gt; 이다 &lt;code&gt;null&lt;/code&gt; 뷰는 여전히 렌더링하지만, 표시된 값이 비어 있습니다; &quot;항목 이름 :&quot;만 표시되고 그 뒤에는 아무것도 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="748b753025529c55a842c6d9f6660a18d272f322" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;myapp&lt;/code&gt; is the directory containing your app's distributable files, you would typically make available different versions for different locales in locale directories such as &lt;code&gt;myapp/fr&lt;/code&gt; for the French version and &lt;code&gt;myapp.com/es&lt;/code&gt; for the Spanish version.</source>
          <target state="translated">&lt;code&gt;myapp&lt;/code&gt; 이 앱의 배포 가능 파일이 포함 된 디렉토리 인 경우 일반적으로 프랑스어 버전의 경우 &lt;code&gt;myapp/fr&lt;/code&gt; , 스페인어 버전의 경우 &lt;code&gt;myapp.com/es&lt;/code&gt; 와 같은 로케일 디렉토리의 다른 로케일에 대해 다른 버전을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8d8422f2e65706b8497bcc51a57226f6a6115f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parentItem&lt;/code&gt; were some other type, you would need to specify &lt;code&gt;childItem&lt;/code&gt;&lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; as that type as well.</source>
          <target state="translated">&lt;code&gt;parentItem&lt;/code&gt; 이 다른 유형 인 경우 해당 유형으로 &lt;code&gt;childItem&lt;/code&gt; &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 도 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="88c7c960113eaa483cbd792b988036fe861c77b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;resourcesOutputPath&lt;/code&gt; or &lt;code&gt;assets&lt;/code&gt; paths are modified after the generation of configuration file, you need to change the paths manually in &lt;code&gt;ngsw-config.json&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;resourcesOutputPath&lt;/code&gt; 또는 &lt;code&gt;assets&lt;/code&gt; 경로가 구성 파일의 생성 후 수정, 당신은 수동으로 경로를 변경해야 &lt;code&gt;ngsw-config.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59e9c7fd5ea287685b778a83b66934b4552cf074" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;responseType&lt;/code&gt; is the default &lt;code&gt;&lt;a href=&quot;../jsonpipe&quot;&gt;json&lt;/a&gt;&lt;/code&gt;, you can pass a type interface for the resulting object as a type parameter to the call.</source>
          <target state="translated">경우 &lt;code&gt;responseType&lt;/code&gt; 은 기본입니다 &lt;code&gt;&lt;a href=&quot;../jsonpipe&quot;&gt;json&lt;/a&gt;&lt;/code&gt; , 당신은 전화에 입력 매개 변수로 생성 된 객체의 유형 인터페이스를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c26dcf1ae594af2316d44c7bd3b0f361e602408" translate="yes" xml:space="preserve">
          <source>If Angular doesn't find the provider in any &lt;code&gt;ElementInjector&lt;/code&gt;s, it goes back to the element where the request originated and looks in the &lt;code&gt;ModuleInjector&lt;/code&gt; hierarchy. If Angular still doesn't find the provider, it throws an error.</source>
          <target state="translated">Angular가 &lt;code&gt;ElementInjector&lt;/code&gt; 에서 제공자를 찾지 못하면 요청이 시작된 요소로 돌아가 &lt;code&gt;ModuleInjector&lt;/code&gt; 계층 구조 에서 찾습니다 . Angular가 여전히 공급자를 찾지 못하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7e29b3f5e2dff7dd76052d8ccd8eddda8abe0ae1" translate="yes" xml:space="preserve">
          <source>If AnimationBuilder is used, enables scrubbing support for IE/Edge and Safari. (Chrome and Firefox support this natively).</source>
          <target state="translated">AnimationBuilder를 사용하는 경우 IE / Edge 및 Safari에 대한 스크러빙 지원을 활성화합니다. (Chrome 및 Firefox는이를 기본적으로 지원합니다).</target>
        </trans-unit>
        <trans-unit id="41891637b47b87d8458f07c4a6cafe2c7fdb3d2b" translate="yes" xml:space="preserve">
          <source>If NgModule A provides a service for token 'X' and imports an NgModule B that also provides a service for token 'X', then NgModule A's service definition &quot;wins&quot;.</source>
          <target state="translated">NgModule A가 토큰 'X'에 대한 서비스를 제공하고 토큰 'X'에 대한 서비스를 제공하는 NgModule B를 가져 오면 NgModule A의 서비스 정의가 &quot;승리&quot;됩니다.</target>
        </trans-unit>
        <trans-unit id="c1eecfae70b492bc24007ffa2294728a9dfa495c" translate="yes" xml:space="preserve">
          <source>If a cachable request is found in the cache, the interceptor returns an &lt;code&gt;of()&lt;/code&gt;&lt;em&gt;observable&lt;/em&gt; with the cached response, by-passing the &lt;code&gt;next&lt;/code&gt; handler (and all other interceptors downstream).</source>
          <target state="translated">캐시에서 캐시 가능한 요청이 발견되면 인터셉터는 &lt;code&gt;next&lt;/code&gt; 핸들러 (및 다른 모든 인터셉터 다운 스트림)를 우회하여 캐시 된 응답으로 &lt;em&gt;관찰 가능한 &lt;/em&gt; &lt;code&gt;of()&lt;/code&gt; 리턴합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a557a16e0123df7fbc078703591e93ef301867af" translate="yes" xml:space="preserve">
          <source>If a cachable request is not in cache, the code calls &lt;code&gt;sendRequest&lt;/code&gt;.</source>
          <target state="translated">캐시 가능한 요청이 캐시에 없으면 코드는 &lt;code&gt;sendRequest&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e31a4be0de140cda7feef27f0475c0e43572b63f" translate="yes" xml:space="preserve">
          <source>If a cacheable request is found in the cache, the interceptor returns an &lt;code&gt;of()&lt;/code&gt;&lt;em&gt;observable&lt;/em&gt; with the cached response, by-passing the &lt;code&gt;next&lt;/code&gt; handler (and all other interceptors downstream).</source>
          <target state="translated">캐시 가능한 요청이 캐시에서 발견되면 인터셉터는 캐시 된 응답으로 &lt;em&gt;관찰 가능한 &lt;/em&gt; &lt;code&gt;of()&lt;/code&gt; 반환 하여 &lt;code&gt;next&lt;/code&gt; 핸들러 (및 다운 스트림 다른 모든 인터셉터)를 우회합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a4ef8fc972b8795ff9dbbaa46f63a9c20d56144c" translate="yes" xml:space="preserve">
          <source>If a cacheable request is not in cache, the code calls &lt;code&gt;sendRequest()&lt;/code&gt;. This function creates a &lt;a href=&quot;http#immutability&quot;&gt;request clone&lt;/a&gt; without headers, because the npm API forbids them. The function then forwards the clone of the request to &lt;code&gt;next.handle()&lt;/code&gt; which ultimately calls the server and returns the server's response.</source>
          <target state="translated">캐시 가능한 요청이 캐시에 없으면 코드는 &lt;code&gt;sendRequest()&lt;/code&gt; 호출합니다 . 이 함수 는 npm API가이를 금지하므로 헤더없이 &lt;a href=&quot;http#immutability&quot;&gt;요청 복제본&lt;/a&gt; 을 생성 합니다. 그런 다음 함수는 최종적으로 서버를 호출하고 서버의 응답을 반환하는 &lt;code&gt;next.handle()&lt;/code&gt; 요청의 복제본을 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="25a21150a7b49171680b296303c8c3068307fd81" translate="yes" xml:space="preserve">
          <source>If a component isn't an &lt;em&gt;entry component&lt;/em&gt; and isn't found in a template, the tree shaker will throw it away. So, it's best to add only the components that are truly entry components to help keep your app as trim as possible.</source>
          <target state="translated">구성 요소가 &lt;em&gt;입력 구성 요소&lt;/em&gt; 가 아니고 템플릿에없는 경우 트리 셰이커는 해당 &lt;em&gt;구성 요소를&lt;/em&gt; 버립니다. 따라서 앱을 가능한 한 깔끔하게 유지하는 데 도움이되도록 실제로 입력 구성 요소 인 구성 요소 만 추가하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="82977af04a1be023e2632c7ce2dc1d6a584c85e0" translate="yes" xml:space="preserve">
          <source>If a component isn't an &lt;em&gt;entry component&lt;/em&gt; or wasn't found in a template, the compiler omits it.</source>
          <target state="translated">구성 요소가 &lt;em&gt;입력 구성&lt;/em&gt; 요소가 아니 거나 템플리트에서 발견되지 않은 경우 컴파일러는 해당 &lt;em&gt;구성 요소를&lt;/em&gt; 생략합니다.</target>
        </trans-unit>
        <trans-unit id="928fd4fa526ed6eda7f59b8933282d6e07b0b85b" translate="yes" xml:space="preserve">
          <source>If a component, directive, or pipe belongs to a module in the &lt;code&gt;imports&lt;/code&gt; array, ​&lt;em&gt;don't&lt;/em&gt;​ re-declare it in the &lt;code&gt;declarations&lt;/code&gt; array. If you wrote it and it should belong to this module, ​&lt;em&gt;do&lt;/em&gt;​ declare it in the &lt;code&gt;declarations&lt;/code&gt; array.</source>
          <target state="translated">컴포넌트, 지시, 또는 파이프에서의 모듈에 속하는 경우 &lt;code&gt;imports&lt;/code&gt; 배열 &lt;em&gt;하지&lt;/em&gt; 그것을 재 - 선언 &lt;code&gt;declarations&lt;/code&gt; 어레이. 당신이 그것을 작성하고이 모듈에 속해야 경우 &lt;em&gt;않는&lt;/em&gt; 에 선언 &lt;code&gt;declarations&lt;/code&gt; 배열입니다.</target>
        </trans-unit>
        <trans-unit id="5412001a6342f943d1164b11e4f80c199052baef" translate="yes" xml:space="preserve">
          <source>If a library doesn't have typings available at &lt;code&gt;@types/&lt;/code&gt;, you can still use it by manually adding typings for it. To do this:</source>
          <target state="translated">라이브러리에 &lt;code&gt;@types/&lt;/code&gt; 에서 입력 할 수없는 경우 수동으로 입력을 추가하여 사용할 수 있습니다. 이것을하기 위해:</target>
        </trans-unit>
        <trans-unit id="fdb8960b3596db71a2d8f8b8dc45d058f36e0a1e" translate="yes" xml:space="preserve">
          <source>If a link in the page is a root URL (has an &lt;code&gt;authority&lt;/code&gt;), the &lt;code&gt;&amp;lt;base href&amp;gt;&lt;/code&gt; is not used. In this way, an &lt;code&gt;&lt;a href=&quot;../api/common/app_base_href&quot;&gt;APP_BASE_HREF&lt;/a&gt;&lt;/code&gt; with an authority will cause all links created by Angular to ignore the &lt;code&gt;&amp;lt;base href&amp;gt;&lt;/code&gt; value.</source>
          <target state="translated">페이지의 링크가 루트 URL ( &lt;code&gt;authority&lt;/code&gt; ) 인 경우 &lt;code&gt;&amp;lt;base href&amp;gt;&lt;/code&gt; 가 사용되지 않습니다. 이런 식으로 권한이 있는 &lt;code&gt;&lt;a href=&quot;../api/common/app_base_href&quot;&gt;APP_BASE_HREF&lt;/a&gt;&lt;/code&gt; 는 Angular에서 만든 모든 링크가 &lt;code&gt;&amp;lt;base href&amp;gt;&lt;/code&gt; 값 을 무시하도록 합니다.</target>
        </trans-unit>
        <trans-unit id="5b23cd84551a7f7a976d6aeb6c17b5809a2ed511" translate="yes" xml:space="preserve">
          <source>If a matching request has been made, fail with an error message including the given request description, if any.</source>
          <target state="translated">일치하는 요청이 이루어진 경우 주어진 요청 설명 (있는 경우)을 포함하는 오류 메시지와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="37dfd42ae1c031038225c47cb260140e0566ea26" translate="yes" xml:space="preserve">
          <source>If a module defines both providers and declarations (components, directives, pipes), then loading the module in multiple feature modules would duplicate the registration of the service. This could result in multiple service instances and the service would no longer behave as a singleton.</source>
          <target state="translated">모듈이 공급자와 선언 (구성 요소, 지시문, 파이프)을 모두 정의하는 경우 여러 기능 모듈에 모듈을로드하면 서비스 등록이 복제됩니다. 이로 인해 여러 서비스 인스턴스가 발생할 수 있으며 서비스는 더 이상 싱글 톤으로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="153c1d112fedc7715f021056fb6893af4681c150" translate="yes" xml:space="preserve">
          <source>If a particular file fails validation, the Angular service worker attempts to re-fetch the content using a &quot;cache-busting&quot; URL parameter to eliminate the effects of browser or intermediate caching. If that content also fails validation, the service worker considers the entire version of the app to be invalid and it stops serving the app. If necessary, the service worker enters a safe mode where requests fall back on the network, opting not to use its cache if the risk of serving invalid, broken, or outdated content is high.</source>
          <target state="translated">특정 파일의 유효성 검사에 실패하면 Angular 서비스 워커는 &quot;캐시 버스 팅&quot;URL 매개 변수를 사용하여 콘텐츠를 다시 가져 오려고 시도하여 브라우저 또는 중간 캐싱의 영향을 제거합니다. 해당 콘텐츠도 유효성 검사에 실패하면 서비스 워커는 전체 버전의 앱이 유효하지 않은 것으로 간주하고 앱 제공을 중지합니다. 필요한 경우, 서비스 워커는 요청이 네트워크에서 폴백되는 안전 모드로 들어갑니다. 유효하지 않거나 손상되었거나 오래된 컨텐츠를 제공 할 위험이 높은 경우 캐시를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="772ddfa5b7d68e2c32169f0370cc73c59e176504" translate="yes" xml:space="preserve">
          <source>If a previous search request is still &lt;em&gt;in-flight&lt;/em&gt; (as when the network connection is poor), it cancels that request and sends a new one.</source>
          <target state="translated">이전 검색 요청이 여전히 &lt;em&gt;진행 중이면&lt;/em&gt; (네트워크 연결 상태가 좋지 않은 경우) 해당 요청을 취소하고 새 요청을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="b53118bae5db34ffb1b4cf25da459ef342963d97" translate="yes" xml:space="preserve">
          <source>If a provider cannot be configured in this way (perhaps because it has no sensible default value), then register application-wide providers in the root &lt;code&gt;AppModule&lt;/code&gt;, not in the &lt;code&gt;AppComponent&lt;/code&gt;.</source>
          <target state="translated">공급자를 이러한 방식으로 구성 할 수없는 경우 (아마도 합리적인 기본값이 없기 때문에) 응용 프로그램 전체 공급자를 &lt;code&gt;AppComponent&lt;/code&gt; 가 아닌 루트 &lt;code&gt;AppModule&lt;/code&gt; 에 등록 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7eb25f225ddf9c958a4a310cf508da2c8b8d3cae" translate="yes" xml:space="preserve">
          <source>If a region of the DOM (or the entire application) has its animations disabled, the animation trigger callbacks still fire, but for zero seconds. When the callback fires, it provides an instance of an &lt;code&gt;&lt;a href=&quot;animationevent&quot;&gt;AnimationEvent&lt;/a&gt;&lt;/code&gt;. If animations are disabled, the &lt;code&gt;.disabled&lt;/code&gt; flag on the event is true.</source>
          <target state="translated">DOM 영역 (또는 전체 응용 프로그램)에서 해당 애니메이션이 비활성화 된 경우 애니메이션 트리거 콜백은 여전히 ​​실행되지만 0 초 동안 실행됩니다. 콜백이 발생하면 &lt;code&gt;&lt;a href=&quot;animationevent&quot;&gt;AnimationEvent&lt;/a&gt;&lt;/code&gt; 의 인스턴스를 제공합니다 . 애니메이션이 비활성화 된 경우 이벤트 에서 &lt;code&gt;.disabled&lt;/code&gt; 플래그가 true입니다.</target>
        </trans-unit>
        <trans-unit id="ed6f22701aa659882520ee8999e4722594b619bd" translate="yes" xml:space="preserve">
          <source>If a route is protected by &lt;code&gt;&lt;a href=&quot;route#canLoad&quot;&gt;canLoad&lt;/a&gt;&lt;/code&gt; guards, the preloaded will not load it.</source>
          <target state="translated">경로가 &lt;code&gt;&lt;a href=&quot;route#canLoad&quot;&gt;canLoad&lt;/a&gt;&lt;/code&gt; 가드 로 보호되는 경우 사전로드 된 경로는 로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31211ceb25db282c2778b0e7f523e65a2928bb5b" translate="yes" xml:space="preserve">
          <source>If a route is protected by &lt;code&gt;canLoad&lt;/code&gt; guards, the preloaded will not load it.</source>
          <target state="translated">경로가 &lt;code&gt;canLoad&lt;/code&gt; 가드에 의해 보호되는 경우 사전로드 된 경로가 로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9439dbdfd08109c95a98837df7b16acd71a7577" translate="yes" xml:space="preserve">
          <source>If a synchronous error happens it will be rethrown and not reported via &lt;code&gt;onError&lt;/code&gt;.</source>
          <target state="translated">동기 오류가 발생하면 다시 발생하여 &lt;code&gt;onError&lt;/code&gt; 를 통해보고되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1193b9b4175de5acb12984919c9136d2c89a4f85" translate="yes" xml:space="preserve">
          <source>If a token is injected with the &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;@&lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt;&lt;/code&gt; flag, the module injector is not searched for that token (previously, tokens marked with these flags would still search at the module level).</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;@&lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt;&lt;/code&gt; 플래그 로 토큰을 주입 하면 모듈 주입기는 해당 토큰을 검색하지 않습니다 (이전에는 이러한 플래그로 표시된 토큰이 여전히 모듈 수준에서 검색 됨).</target>
        </trans-unit>
        <trans-unit id="00daec30c96e47a317ac6daa4260ebf84859c21c" translate="yes" xml:space="preserve">
          <source>If a trigger binding value is a Boolean, it can be matched using a transition expression that compares true and false or 1 and 0. For example:</source>
          <target state="translated">트리거 바인딩 값이 부울 인 경우 true와 false 또는 1과 0을 비교하는 전이 표현식을 사용하여 일치시킬 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="126cac6a6045858048bd7e923d7b34e4f134314c" translate="yes" xml:space="preserve">
          <source>If a trigger contains a boolean value as a binding value, then this value can be matched using a &lt;code&gt;&lt;a href=&quot;../api/animations/transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; expression that compares &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;, or &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">트리거에 바인딩 값으로 부울 값이 포함 된 경우 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;0&lt;/code&gt; 을 비교 하는 &lt;code&gt;&lt;a href=&quot;../api/animations/transition&quot;&gt;transition&lt;/a&gt;()&lt;/code&gt; 표현식을 사용하여이 값을 일치시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e50e34462749ac65c8cf4317ed5676213f6e2090" translate="yes" xml:space="preserve">
          <source>If a user enters that URL into the browser address bar, the router should recognize the pattern and go to the same &quot;Magneta&quot; detail view.</source>
          <target state="translated">사용자가 브라우저 주소 표시 줄에 해당 URL을 입력하면 라우터는 패턴을 인식하고 동일한 &quot;Magneta&quot;상세보기로 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="f6919a849126284f296a0ff57039a9cf7b8e4a82" translate="yes" xml:space="preserve">
          <source>If an expression is not foldable, the collector writes it to &lt;code&gt;.metadata.json&lt;/code&gt; as an &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;AST&lt;/a&gt; for the compiler to resolve.</source>
          <target state="translated">식이 접을 수없는 경우, 콜렉터에 기록 &lt;code&gt;.metadata.json&lt;/code&gt; int로서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;AST&lt;/a&gt; 해결하기 위해 컴파일러.</target>
        </trans-unit>
        <trans-unit id="3776c3775f99b8ca1455c46376b27adc6b1e4aab" translate="yes" xml:space="preserve">
          <source>If an expression uses unsupported syntax, the collector writes an error node to the &lt;code&gt;.metadata.json&lt;/code&gt; file. The compiler later reports the error if it needs that piece of metadata to generate the application code.</source>
          <target state="translated">표현식이 지원되지 않는 구문을 사용하는 경우 콜렉터는 오류 노드를 &lt;code&gt;.metadata.json&lt;/code&gt; 파일에 씁니다 . 나중에 응용 프로그램 코드를 생성하기 위해 메타 데이터가 필요한 경우 컴파일러에서 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="2c1ea63fe3e751750d668900003cfb0b2fc2138e" translate="yes" xml:space="preserve">
          <source>If any of the passed-in parameter values are missing from this call, the default values are used. If one or more parameter values are missing before a step is animated, &lt;code&gt;&lt;a href=&quot;useanimation&quot;&gt;useAnimation&lt;/a&gt;()&lt;/code&gt; throws an error.</source>
          <target state="translated">전달 된 매개 변수 값이이 호출에서 누락 된 경우 기본값이 사용됩니다. 단계가 애니메이션되기 전에 하나 이상의 매개 변수 값이 누락되면 &lt;code&gt;&lt;a href=&quot;useanimation&quot;&gt;useAnimation&lt;/a&gt;()&lt;/code&gt; 에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8297839eeda1d6ac628fdcf349ff15b398e9f7ec" translate="yes" xml:space="preserve">
          <source>If any requests are outstanding, fail with an error message indicating which requests were not handled.</source>
          <target state="translated">요청이 해결되지 않은 경우 처리되지 않은 요청을 나타내는 오류 메시지와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="78a0a0f3d87236bcde7fe383b154888d25e30118" translate="yes" xml:space="preserve">
          <source>If compiling with the ViewEngine renderer, do not use this in a production server environment. Use pre-compiled &lt;a href=&quot;../core/ngmodulefactory&quot;&gt;&lt;code&gt;NgModuleFactory&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;rendermodulefactory&quot;&gt;&lt;code&gt;renderModuleFactory&lt;/code&gt;&lt;/a&gt; instead. If compiling with the Ivy renderer, this method is the recommended rendering method for platform-server.</source>
          <target state="translated">ViewEngine 렌더러로 컴파일하는 경우 프로덕션 서버 환경에서 사용하지 마십시오. 대신 &lt;a href=&quot;rendermodulefactory&quot;&gt; &lt;code&gt;renderModuleFactory&lt;/code&gt; &lt;/a&gt; 와 함께 미리 컴파일 된 &lt;a href=&quot;../core/ngmodulefactory&quot;&gt; &lt;code&gt;NgModuleFactory&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 . Ivy 렌더러로 컴파일하는 경우이 방법이 플랫폼 서버에 권장되는 렌더링 방법입니다.</target>
        </trans-unit>
        <trans-unit id="1fe08f5539ac4bc33409018c8e77a3cf182d48db" translate="yes" xml:space="preserve">
          <source>If desired, open the Output window (&lt;code&gt;View&lt;/code&gt; | &lt;code&gt;&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;&lt;/code&gt;) to watch the npm commands execute.</source>
          <target state="translated">원하는 경우 출력 창 ( &lt;code&gt;View&lt;/code&gt; | &lt;code&gt;&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;&lt;/code&gt; )을 열어 npm 명령이 실행되는 것을보십시오.</target>
        </trans-unit>
        <trans-unit id="a7351ddc6a7cd3e167d6abe4319ab53c493d68c8" translate="yes" xml:space="preserve">
          <source>If don't add the interface for the script-defined extension, your IDE shows an error:</source>
          <target state="translated">스크립트 정의 확장에 대한 인터페이스를 추가하지 않으면 IDE에 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ac260a05c0b8dad2568206edbc95161f250ef807" translate="yes" xml:space="preserve">
          <source>If false, will error out if installed packages are incompatible with the update.</source>
          <target state="translated">false 인 경우 설치된 패키지가 업데이트와 호환되지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f032cf6d2b03e78a246739a8908cb417e0108e0e" translate="yes" xml:space="preserve">
          <source>If forms are a central part of your application, scalability is very important. Being able to reuse form models across components is critical.</source>
          <target state="translated">양식이 응용 프로그램의 핵심 부분 인 경우 확장 성이 매우 중요합니다. 구성 요소에서 양식 모델을 재사용 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="db9bfb7eb5ad6beada080172eda6cd3931052021" translate="yes" xml:space="preserve">
          <source>If inside an embedded view (e.g. &lt;code&gt;*&lt;a href=&quot;../../common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;*&lt;a href=&quot;../../common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt;), retrieves the context of the embedded view that the element is part of. Otherwise retrieves the instance of the component whose view owns the element (in this case, the result is the same as calling &lt;code&gt;&lt;a href=&quot;nggetowningcomponent&quot;&gt;getOwningComponent&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">포함 된 뷰 (예 : &lt;code&gt;*&lt;a href=&quot;../../common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;*&lt;a href=&quot;../../common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; ) 내에있는 경우 요소가 속한 포함 된 뷰의 컨텍스트를 검색합니다. 그렇지 않으면 뷰가 요소를 소유하는 구성 요소의 인스턴스를 검색합니다 (이 경우 결과는 &lt;code&gt;&lt;a href=&quot;nggetowningcomponent&quot;&gt;getOwningComponent&lt;/a&gt;&lt;/code&gt; 호출과 동일 함 ).</target>
        </trans-unit>
        <trans-unit id="5315ddf9835a63fe9abe1f91461e4e5c8b284a75" translate="yes" xml:space="preserve">
          <source>If inside an embedded view (e.g. &lt;code&gt;*&lt;a href=&quot;../common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;*&lt;a href=&quot;../common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt;), retrieves the context of the embedded view that the element is part of. Otherwise retrieves the instance of the component whose view owns the element (in this case, the result is the same as calling &lt;code&gt;&lt;a href=&quot;global/nggetowningcomponent&quot;&gt;getOwningComponent&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">포함 된 뷰 (예 : &lt;code&gt;*&lt;a href=&quot;../common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;*&lt;a href=&quot;../common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; ) 내에있는 경우 요소가 속한 포함 된 뷰의 컨텍스트를 검색합니다. 그렇지 않으면 뷰가 요소를 소유하는 구성 요소의 인스턴스를 검색합니다 (이 경우 결과는 &lt;code&gt;&lt;a href=&quot;global/nggetowningcomponent&quot;&gt;getOwningComponent&lt;/a&gt;&lt;/code&gt; 호출과 동일 함 ).</target>
        </trans-unit>
        <trans-unit id="534d625f4fac3eff1e93003d98e3e44e789a243b" translate="yes" xml:space="preserve">
          <source>If it doesn't return a valid &lt;code&gt;Crisis&lt;/code&gt;, return an empty &lt;code&gt;Observable&lt;/code&gt;, canceling the previous in-flight navigation to the &lt;code&gt;CrisisDetailComponent&lt;/code&gt; and navigate the user back to the &lt;code&gt;CrisisListComponent&lt;/code&gt;. The update resolver service looks like this:</source>
          <target state="translated">유효한 &lt;code&gt;Crisis&lt;/code&gt; 를 반환 하지 않으면 비어있는 &lt;code&gt;Observable&lt;/code&gt; 을 반환 하여 이전 비행 중 &lt;code&gt;CrisisDetailComponent&lt;/code&gt; 로의 탐색을 취소 하고 사용자를 &lt;code&gt;CrisisListComponent&lt;/code&gt; 로 다시 탐색합니다 . 업데이트 확인자 서비스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1196f5aa5aa0dd7720977e806de967ce00602e90" translate="yes" xml:space="preserve">
          <source>If it doesn't return a valid &lt;code&gt;Crisis&lt;/code&gt;, then return an empty &lt;code&gt;Observable&lt;/code&gt;, cancel the previous in-progress navigation to the &lt;code&gt;CrisisDetailComponent&lt;/code&gt;, and navigate the user back to the &lt;code&gt;CrisisListComponent&lt;/code&gt;. The updated resolver service looks like this:</source>
          <target state="translated">유효한 &lt;code&gt;Crisis&lt;/code&gt; 를 반환하지 않으면 빈 &lt;code&gt;Observable&lt;/code&gt; 을 반환 하고 이전 진행중인 &lt;code&gt;CrisisDetailComponent&lt;/code&gt; 탐색을 취소 하고 사용자를 &lt;code&gt;CrisisListComponent&lt;/code&gt; 로 다시 탐색합니다 . 업데이트 된 해석기 서비스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="94cc9640df1c6d475f62695048e0d376c2bec854" translate="yes" xml:space="preserve">
          <source>If it returns &lt;code&gt;false&lt;/code&gt;, the navigation process stops and the user stays put.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 를 반환 하면 탐색 프로세스가 중지되고 사용자는 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="934263a7e8d3127facc33238735344f25d2875f1" translate="yes" xml:space="preserve">
          <source>If it returns &lt;code&gt;true&lt;/code&gt;, the navigation process continues.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 를 반환 하면 탐색 프로세스가 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="c061c62da9990fa021cd80362e45d9d595bd3cad" translate="yes" xml:space="preserve">
          <source>If it returns a &lt;code&gt;&lt;a href=&quot;../api/router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt;, the current navigation cancels and a new navigation is initiated to the &lt;code&gt;&lt;a href=&quot;../api/router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; returned.</source>
          <target state="translated">그것이 반환하는 경우 &lt;code&gt;&lt;a href=&quot;../api/router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 을 , 현재 탐색 취소하고에 새로운 탐색이 시작됩니다 &lt;code&gt;&lt;a href=&quot;../api/router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 이 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="ccea769affa3066668cea7a19a1c6abd478fefbc" translate="yes" xml:space="preserve">
          <source>If it's the consumer's decision whether a provider is available application-wide or not, then register providers in modules (&lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule#providers&quot;&gt;NgModule.providers&lt;/a&gt;&lt;/code&gt;) instead of registering in components (&lt;code&gt;@Component.providers&lt;/code&gt;).</source>
          <target state="translated">공급자가 응용 프로그램 전체에서 사용할 수 있는지 여부가 소비자의 결정 인 경우 구성 요소 ( &lt;code&gt;@Component.providers&lt;/code&gt; ) 에 등록하지 않고 모듈 ( &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule#providers&quot;&gt;NgModule.providers&lt;/a&gt;&lt;/code&gt; )에 공급자를 등록하십시오 .</target>
        </trans-unit>
        <trans-unit id="3de1670255b8a935f81404283d68b60a57924133" translate="yes" xml:space="preserve">
          <source>If matching by URL isn't sufficient, it's possible to implement your own matching function. For example, you could look for an outgoing request that has an authorization header:</source>
          <target state="translated">URL로 일치하는 것으로 충분하지 않은 경우 고유 한 일치 기능을 구현할 수 있습니다. 예를 들어 인증 헤더가있는 발신 요청을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="056b912650db2b88322b88ec9db23fdbd1b15e9c" translate="yes" xml:space="preserve">
          <source>If necessary, listen to the directive's &lt;code&gt;ngSubmit&lt;/code&gt; event to be notified when the user has triggered a form submission. The &lt;code&gt;ngSubmit&lt;/code&gt; event emits the original form submission event.</source>
          <target state="translated">필요한 경우 사용자가 양식 제출을 트리거했을 때 알림을 &lt;code&gt;ngSubmit&lt;/code&gt; 지시문의 ngSubmit 이벤트를 수신하십시오 . &lt;code&gt;ngSubmit&lt;/code&gt; 의 이벤트는 원래의 양식 제출 이벤트를 방출한다.</target>
        </trans-unit>
        <trans-unit id="1d1b279b18b25539f878e1f938bbd94f7b8453bd" translate="yes" xml:space="preserve">
          <source>If no names are supplied, the default cookie name is &lt;code&gt;XSRF-TOKEN&lt;/code&gt; and the default header name is &lt;code&gt;X-XSRF-TOKEN&lt;/code&gt;.</source>
          <target state="translated">이름이 제공되지 않으면 기본 쿠키 이름은 &lt;code&gt;XSRF-TOKEN&lt;/code&gt; 이고 기본 헤더 이름은 &lt;code&gt;X-XSRF-TOKEN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d46fc13fcfb33c04d67d471d163a937c0bfbc809" translate="yes" xml:space="preserve">
          <source>If no parameters are specified, the function rounds off to the nearest value using this &lt;a href=&quot;https://en.wikibooks.org/wiki/Arithmetic/Rounding&quot;&gt;rounding method&lt;/a&gt;. The behavior differs from that of the JavaScript &lt;code&gt;Math.round()&lt;/code&gt; function. In the following case for example, the pipe rounds down where &lt;code&gt;Math.round()&lt;/code&gt; rounds up:</source>
          <target state="translated">매개 변수를 지정하지 않으면이 &lt;a href=&quot;https://en.wikibooks.org/wiki/Arithmetic/Rounding&quot;&gt;반올림 방법을&lt;/a&gt; 사용하여 함수가 가장 가까운 값으로 반올림합니다 . 동작은 JavaScript &lt;code&gt;Math.round()&lt;/code&gt; 함수 와 다릅니다 . 예를 들어 다음과 같은 경우 파이프는 &lt;code&gt;Math.round()&lt;/code&gt; 반올림 되는 곳에서 내림합니다.</target>
        </trans-unit>
        <trans-unit id="4697ce1b28fc4ca20feccfb80e7cc0346431c557" translate="yes" xml:space="preserve">
          <source>If no path is given, this method checks for the error on the current control.</source>
          <target state="translated">경로를 지정하지 않으면이 방법은 현재 컨트롤의 오류를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="18e3524ed61782df3f426fecd17d77f48f0bf410" translate="yes" xml:space="preserve">
          <source>If no provider is found in the root injector, the DI framework throws an error.</source>
          <target state="translated">루트 인젝터에 공급자가 없으면 DI 프레임 워크에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="df3e28bc99646e24bb4e26e24b47cf0ecf85e067" translate="yes" xml:space="preserve">
          <source>If no such request has been made, or more than one such request has been made, fail with an error message including the given request description, if any.</source>
          <target state="translated">그러한 요청이 이루어지지 않았거나 그러한 요청이 둘 이상 이루어진 경우, 주어진 요청 설명 (있는 경우)을 포함하는 오류 메시지와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="30d7bba1ab11ca5cea6604c658835a3fa2b9e7f3" translate="yes" xml:space="preserve">
          <source>If no such type can be inferred, this method will return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이러한 유형을 유추 할 수없는 경우이 메소드는 &lt;code&gt;null&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="9f484cd2e0ac3fa9d4d2037af3783405320d1ccb" translate="yes" xml:space="preserve">
          <source>If none of the keys of the &lt;code&gt;mapping&lt;/code&gt; match the &lt;code&gt;value&lt;/code&gt;, then the content of the &lt;code&gt;other&lt;/code&gt; key is returned when present, otherwise an empty string is returned.</source>
          <target state="translated">&lt;code&gt;mapping&lt;/code&gt; 의 키 중 &lt;code&gt;value&lt;/code&gt; 과 일치하는 키가 없으면 &lt;code&gt;other&lt;/code&gt; 키 의 내용이 있을 때 반환되고, 그렇지 않으면 빈 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5289261bc01c41048f4a824110cc30dce1f1853c" translate="yes" xml:space="preserve">
          <source>If not supplied, the value is taken from &lt;code&gt;&lt;a href=&quot;compileroptions&quot;&gt;CompilerOptions&lt;/a&gt;&lt;/code&gt;. The default compiler option is &lt;code&gt;&lt;a href=&quot;viewencapsulation#Emulated&quot;&gt;ViewEncapsulation.Emulated&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">제공되지 않으면 값은 &lt;code&gt;&lt;a href=&quot;compileroptions&quot;&gt;CompilerOptions&lt;/a&gt;&lt;/code&gt; 에서 가져옵니다 . 기본 컴파일러 옵션은 &lt;code&gt;&lt;a href=&quot;viewencapsulation#Emulated&quot;&gt;ViewEncapsulation.Emulated&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a785f84f703473ade0c0ff1fe9607c482a6c9fd7" translate="yes" xml:space="preserve">
          <source>If null or undefined, the view engine won't call it. This is used as a performance optimization for production mode.</source>
          <target state="translated">null이거나 정의되지 않은 경우 뷰 엔진은이를 호출하지 않습니다. 프로덕션 모드의 성능 최적화로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b27c861d54587f90dcd31f70995af48c38707d2e" translate="yes" xml:space="preserve">
          <source>If part of the Angular upgrade plan is to also take TypeScript into use, it makes sense to bring in the TypeScript compiler even before the upgrade itself begins. This means there's one less thing to learn and think about during the actual upgrade. It also means you can start using TypeScript features in your AngularJS code.</source>
          <target state="translated">Angular 업그레이드 계획의 일부로 TypeScript도 사용하려면 업그레이드 자체가 시작되기 전에 TypeScript 컴파일러를 가져 오는 것이 좋습니다. 즉, 실제 업그레이드 중에 배우고 생각해야 할 것이 하나 더 적습니다. 또한 AngularJS 코드에서 TypeScript 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e616c57ff16a9892f31e3e14cf215a3a317fefba" translate="yes" xml:space="preserve">
          <source>If provided, a new value for the given configuration key.</source>
          <target state="translated">제공된 경우 지정된 구성 키에 대한 새로운 값.</target>
        </trans-unit>
        <trans-unit id="abca8a3c87f57071bd98c098938909b796da3ecb" translate="yes" xml:space="preserve">
          <source>If provided, overrides the configured injector.</source>
          <target state="translated">제공된 경우 구성된 인젝터를 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="32bd8e69ead64639bd08877d0b56a7d222032521" translate="yes" xml:space="preserve">
          <source>If selecting the native &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; element in a &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; where the &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt;s are created via &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt;, use the &lt;code&gt;[selected]&lt;/code&gt; property of an &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; instead of binding to the &lt;code&gt;[value]&lt;/code&gt; property of the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; element (previously, you could bind to either.) &lt;a href=&quot;ivy-compatibility-examples#select-value-binding&quot;&gt;details&lt;/a&gt;</source>
          <target state="translated">네이티브 선택하면 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; A의 요소 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 를 Where &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; S를 통해 작성된 &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; , 사용 &lt;code&gt;[selected]&lt;/code&gt; 의 AN 속성 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 대신에 결합 &lt;code&gt;[value]&lt;/code&gt; 의 속성 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 요소 (이전에는 둘 중 하나에 바인딩 할 수 있음) &lt;a href=&quot;ivy-compatibility-examples#select-value-binding&quot;&gt;세부 정보&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a11ccb963889053d0a672c70d6f2544753338193" translate="yes" xml:space="preserve">
          <source>If set, the &lt;code&gt;templateUrl&lt;/code&gt; and &lt;code&gt;styleUrl&lt;/code&gt; are resolved relative to the component.</source>
          <target state="translated">설정된 경우 &lt;code&gt;templateUrl&lt;/code&gt; 및 &lt;code&gt;styleUrl&lt;/code&gt; 은 구성 요소를 기준으로 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="5392a170eaea5c2707b51db35874eb84acc7dff0" translate="yes" xml:space="preserve">
          <source>If that doesn't work, an option of last resort is to turn off full mode entirely with &lt;code&gt;fullTemplateTypeCheck: false&lt;/code&gt;, as we've made a special effort to make Angular version 9 backwards compatible in this case.</source>
          <target state="translated">그래도 작동하지 않는 경우 마지막 수단은 &lt;code&gt;fullTemplateTypeCheck: false&lt;/code&gt; 전체 모드를 완전히 끄는 것입니다.이 경우 Angular 버전 9가 하위 호환되도록 특별히 노력했습니다.</target>
        </trans-unit>
        <trans-unit id="368133d05f6469fb1d0a68d64ec9d0ec08d47a2d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;ngmodule-faq#q-angular-compiler&quot;&gt;Angular compiler&lt;/a&gt; generated code for every declared component, it would defeat the purpose of the tree shaker.</source>
          <target state="translated">는 IF &lt;a href=&quot;ngmodule-faq#q-angular-compiler&quot;&gt;각도 컴파일러&lt;/a&gt; 모든 코드를 생성 구성 요소 선언, 그것은 나무 뿌리의 목적을 물리 칠 것이다.</target>
        </trans-unit>
        <trans-unit id="8223942c2b882d46175361a2625981bac0326595" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&amp;lt;base href&amp;gt;&lt;/code&gt; includes a &lt;code&gt;&lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;&lt;/code&gt; part, the &lt;code&gt;&lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;&lt;/code&gt; is only used if the &lt;code&gt;path&lt;/code&gt; of a link in the page is empty and has no &lt;code&gt;&lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;&lt;/code&gt;. This means that a &lt;code&gt;&lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&amp;lt;base href&amp;gt;&lt;/code&gt; is only included when using &lt;code&gt;&lt;a href=&quot;../api/common/hashlocationstrategy&quot;&gt;HashLocationStrategy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;&amp;lt;base href&amp;gt;&lt;/code&gt; 포함 &lt;code&gt;&lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;&lt;/code&gt; 부분의 &lt;code&gt;&lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;&lt;/code&gt; 경우에만 사용되는 &lt;code&gt;path&lt;/code&gt; 페이지에서 링크가 비어 있고 더없는 &lt;code&gt;&lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;&lt;/code&gt; . 즉 , &lt;code&gt;&amp;lt;base href&amp;gt;&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../api/common/hashlocationstrategy&quot;&gt;HashLocationStrategy&lt;/a&gt;&lt;/code&gt; 를 사용할 때만 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="b04069fd9407468f4ab42b45f803e9f28a2fc222" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--prod&lt;/code&gt; command line flag is also used, it is applied first, and its settings can be overridden by any configurations specified via the &lt;code&gt;--configuration&lt;/code&gt; flag.</source>
          <target state="translated">는 IF &lt;code&gt;--prod&lt;/code&gt; 명령 행 플래그도 사용되며, 먼저 적용되고 그 설정을 통해 지정된 구성 오버라이드 (override) 할 수 &lt;code&gt;--configuration&lt;/code&gt; 의 플래그.</target>
        </trans-unit>
        <trans-unit id="65f23ab622908a00b35e36a91d40431ece26a111" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; were allowed to continue, the tests would run and fail mysteriously before the compiler could finished.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; 를 계속할 수 있으면 컴파일러가 완료되기 전에 테스트가 실행되어 신비하게 실패합니다.</target>
        </trans-unit>
        <trans-unit id="560f12bb9fc58e2ddbb891d578b749239f1e6db9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; didn&amp;rsquo;t have &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;forRoot()&lt;/a&gt;&lt;/code&gt; then each feature module would instantiate a new &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; instance, which would break the application as there can only be one &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt;. By using the &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;forRoot()&lt;/a&gt;&lt;/code&gt; method, the root application module imports &lt;code&gt;RouterModule.forRoot(...)&lt;/code&gt; and gets a &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt;, and all feature modules import &lt;code&gt;RouterModule.forChild(...)&lt;/code&gt; which does not instantiate another &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; 가 없었 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;forRoot()&lt;/a&gt;&lt;/code&gt; 각 기능 모듈은 새로운 인스턴스를 것 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 하나가 될 수있는 응용 프로그램을 중단 할 경우, &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; . 루트 애플리케이션 모듈 은 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;forRoot()&lt;/a&gt;&lt;/code&gt; 메소드 를 사용하여 RouterModule.forRoot ( &lt;code&gt;RouterModule.forRoot(...)&lt;/code&gt; 를 가져오고 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 를 가져오고, 모든 기능 모듈 은 다른 모듈을 인스턴스화하지 않는 &lt;code&gt;RouterModule.forChild(...)&lt;/code&gt; 를 가져옵니다. &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 를.</target>
        </trans-unit>
        <trans-unit id="164bda4ad7759a6e7de3a29bb761c4da6091e441" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; didn&amp;rsquo;t have &lt;code&gt;forRoot()&lt;/code&gt; then each feature module would instantiate a new &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; instance, which would break the application as there can only be one &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt;. By using the &lt;code&gt;forRoot()&lt;/code&gt; method, the root application module imports &lt;code&gt;RouterModule.forRoot(...)&lt;/code&gt; and gets a &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt;, and all feature modules import &lt;code&gt;RouterModule.forChild(...)&lt;/code&gt; which does not instantiate another &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; 가 없었 &lt;code&gt;forRoot()&lt;/code&gt; 각 기능 모듈은 새로운 인스턴스를 것 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 하나가 될 수있는 응용 프로그램을 중단 할 경우, &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; . 사용하여 &lt;code&gt;forRoot()&lt;/code&gt; 방법, 루트 응용 프로그램 모듈 수입 &lt;code&gt;RouterModule.forRoot(...)&lt;/code&gt; 와 유도 할 수있는 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; , 모든 기능 모듈을 가져 &lt;code&gt;RouterModule.forChild(...)&lt;/code&gt; 다른 인스턴스화하지 않는 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="479d4c87591e468174bfa0a3f8dc2135cb777c4e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;app&lt;/code&gt; folder is the application root, as it is for the sample application, set the &lt;code&gt;href&lt;/code&gt; value &lt;em&gt;exactly&lt;/em&gt; as shown here.</source>
          <target state="translated">경우 &lt;code&gt;app&lt;/code&gt; 이 샘플 응용 프로그램처럼 폴더가 응용 프로그램 루트가있다, 설정된 &lt;code&gt;href&lt;/code&gt; 값을&lt;em&gt; 정확히&lt;/em&gt; 다음과 같이.</target>
        </trans-unit>
        <trans-unit id="302f79ea1b195ceb97811e3dba2bfd0daa9bce81" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;example-bank.com&lt;/code&gt; server lacks XSRF protection, it can't tell the difference between a legitimate request from the application and the forged request from &lt;code&gt;evil.com&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;example-bank.com&lt;/code&gt; 의 서버가 XSRF 보호 부족, 어플리케이션에서 합법적 인 요청에서 위조 요청 사이의 차이 말할 수 &lt;code&gt;evil.com&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="bf6319afad7af346a06791442f233428685da15e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;fullTemplateTypeCheck&lt;/code&gt; flag is set to &lt;code&gt;true&lt;/code&gt;, Angular is more aggressive in its type-checking within templates. In particular:</source>
          <target state="translated">는 IF &lt;code&gt;fullTemplateTypeCheck&lt;/code&gt; 의 플래그가 설정되어 &lt;code&gt;true&lt;/code&gt; , 각도 템플릿 내에서 유형 검사에서 더 공격적이다. 특히:</target>
        </trans-unit>
        <trans-unit id="94b7a597e02911683f0b073db5c9c1edeec80b49" translate="yes" xml:space="preserve">
          <source>If the Angular service worker does not have a hash to validate a given resource, it still caches its contents but it honors the HTTP caching headers by using a policy of &quot;stale while revalidate.&quot; That is, when HTTP caching headers for a cached resource indicate that the resource has expired, the Angular service worker continues to serve the content and it attempts to refresh the resource in the background. This way, broken unhashed resources do not remain in the cache beyond their configured lifetimes.</source>
          <target state="translated">Angular 서비스 워커에 지정된 리소스의 유효성을 검사하는 해시가없는 경우 여전히 해당 콘텐츠를 캐시하지만 &quot;stale while revaldate&quot;정책을 사용하여 HTTP 캐싱 헤더를 사용합니다. 즉, 캐시 된 리소스의 HTTP 캐싱 헤더가 리소스가 만료되었음을 나타내면 Angular 서비스 워커는 계속 콘텐츠를 제공하고 백그라운드에서 리소스를 새로 고치려고 시도합니다. 이렇게하면 해싱되지 않은 손상된 리소스가 구성된 수명을 초과하여 캐시에 남아 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c75c80c65f60ead7cd10749d4edad5c9af502525" translate="yes" xml:space="preserve">
          <source>If the JSON file is too big, you could copy the nodes-of-interest into markdown backticks.</source>
          <target state="translated">JSON 파일이 너무 큰 경우 관심 노드를 마크 다운 백틱으로 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be0a39c89a60cb3ed7e054bd374ca82555b74b91" translate="yes" xml:space="preserve">
          <source>If the StackBlitz preview pane isn't showing what you expect, save and then click the refresh button.</source>
          <target state="translated">StackBlitz 미리보기 창에 예상 한 내용이 표시되지 않으면 저장 후 새로 고침 단추를 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="a2bff59b5e87ba98607bcbcc161c9e072991847d" translate="yes" xml:space="preserve">
          <source>If the above &lt;code&gt;ng build&lt;/code&gt; command throws an error about missing packages, append the missing dependencies in your local project's &lt;code&gt;package.json&lt;/code&gt; file to match the one in the downloaded StackBlitz project.</source>
          <target state="translated">위의 &lt;code&gt;ng build&lt;/code&gt; 명령으로 패키지 누락에 대한 오류가 발생 하면 다운로드 한 StackBlitz 프로젝트 의 &lt;code&gt;package.json&lt;/code&gt; 와 일치하도록 로컬 프로젝트의 package.json 파일 에서 누락 된 종속성을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e4c8672ca49b8f0e25eeaa8741e82bde770f9e1" translate="yes" xml:space="preserve">
          <source>If the app uses the Angular router, you must configure the server to return the application's host page (&lt;code&gt;index.html&lt;/code&gt;) when asked for a file that it does not have.</source>
          <target state="translated">앱이 Angular 라우터를 사용하는 경우 서버 에없는 파일을 요청할 때 서버가 애플리케이션의 호스트 페이지 ( &lt;code&gt;index.html&lt;/code&gt; ) 를 반환하도록 구성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d1da36d7cd60fadceb7bc9ecf82d1339e902cc81" translate="yes" xml:space="preserve">
          <source>If the client of a library intends to use a symbol in an annotation, the template compiler does not normally report this until the client uses the symbol. This option allows detection of these errors during the build phase of the library and is used, for example, in producing Angular libraries themselves.</source>
          <target state="translated">라이브러리의 클라이언트가 주석에 심볼을 사용하려는 경우 템플릿 컴파일러는 클라이언트가 심볼을 사용할 때까지이를 일반적으로보고하지 않습니다. 이 옵션을 사용하면 라이브러리의 빌드 단계에서 이러한 오류를 감지 할 수 있으며 예를 들어 Angular 라이브러리 자체를 생성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1d578310a8295a0eae72f65936eb8dd58a18fbd2" translate="yes" xml:space="preserve">
          <source>If the component behaves as expected, clicking the hero's element should tell the component's &lt;code&gt;selected&lt;/code&gt; property to emit the &lt;code&gt;hero&lt;/code&gt; object.</source>
          <target state="translated">구성 요소가 예상대로 작동하는 경우 영웅 요소를 클릭하면 구성 요소의 &lt;code&gt;selected&lt;/code&gt; 속성이 &lt;code&gt;hero&lt;/code&gt; 개체 를 방출하도록 지시 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="8788c70542a02c168cea8e8d4e5e044281bdef0f" translate="yes" xml:space="preserve">
          <source>If the condition is falsy and the view hasn't been created previously, tell the &lt;em&gt;view container&lt;/em&gt; to create the &lt;em&gt;embedded view&lt;/em&gt; from the template.</source>
          <target state="translated">조건이 거짓이고 뷰가 이전에 생성되지 않은 경우 템플릿에서 &lt;em&gt;내장 된 뷰&lt;/em&gt; 를 생성하도록 &lt;em&gt;뷰 컨테이너에&lt;/em&gt; 지시 하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0a064b2a59ee6bd35d516ff89dac85e3c0a88034" translate="yes" xml:space="preserve">
          <source>If the condition is truthy and the view is currently displayed, clear the container which also destroys the view.</source>
          <target state="translated">조건이 진실이고보기가 현재 표시되는 경우보기를 파괴하는 컨테이너를 지우십시오.</target>
        </trans-unit>
        <trans-unit id="048b744ffc4be73f307d5360e389b7f46a5ac039" translate="yes" xml:space="preserve">
          <source>If the consumer has Angular's strictest type checking for templates enabled, this creates a problem: the empty string &lt;code&gt;''&lt;/code&gt; is not actually assignable to the &lt;code&gt;disabled&lt;/code&gt; field, which will create a type error when the attribute form is used.</source>
          <target state="translated">소비자가 템플릿에 대해 Angular의 가장 엄격한 유형 검사를 활성화하면 문제가 발생합니다. 빈 문자열 &lt;code&gt;''&lt;/code&gt; 은 실제로 &lt;code&gt;disabled&lt;/code&gt; 필드에 할당 할 수 없으며 속성 양식을 사용할 때 유형 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5c3cec2a13320fb2f220fb170d31aec1e1a03ce0" translate="yes" xml:space="preserve">
          <source>If the control has any children, also marks all children as &lt;code&gt;untouched&lt;/code&gt; and recalculates the &lt;code&gt;touched&lt;/code&gt; status of all parent controls.</source>
          <target state="translated">컨트롤에 자식이있는 경우 모든 자식을 &lt;code&gt;touched&lt;/code&gt; &lt;code&gt;untouched&lt;/code&gt; 것으로 표시 하고 터치 된 항목을 다시 계산합니다. 모든 부모 컨트롤 상태를 합니다.</target>
        </trans-unit>
        <trans-unit id="d1a83898ee5cd6fc850d88e2ec839126c806da54" translate="yes" xml:space="preserve">
          <source>If the control has any children, marks all children as &lt;code&gt;pristine&lt;/code&gt;, and recalculates the &lt;code&gt;pristine&lt;/code&gt; status of all parent controls.</source>
          <target state="translated">컨트롤에 자식이 있으면 모든 자식을 &lt;code&gt;pristine&lt;/code&gt; 으로 표시하고 모든 부모 컨트롤 의 &lt;code&gt;pristine&lt;/code&gt; 상태를 다시 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="8453b196ce8fbdb1fe41ff331de4cbcbc668e2ae" translate="yes" xml:space="preserve">
          <source>If the control has children, all children are also disabled.</source>
          <target state="translated">컨트롤에 자식이 있으면 모든 자식도 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="6da51976abd22faef9516a71a664e1ede6e2d1c6" translate="yes" xml:space="preserve">
          <source>If the control is not present, false is returned.</source>
          <target state="translated">컨트롤이 없으면 false가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="20413c6d38ae984baf834f94a3ed5662a7f00e9c" translate="yes" xml:space="preserve">
          <source>If the current tab needs to be updated to the latest app version immediately, it can ask to do so with the &lt;code&gt;&lt;a href=&quot;../api/service-worker/swupdate#activateUpdate&quot;&gt;activateUpdate()&lt;/a&gt;&lt;/code&gt; method:</source>
          <target state="translated">현재 탭을 최신 앱 버전으로 즉시 업데이트해야하는 경우 &lt;code&gt;&lt;a href=&quot;../api/service-worker/swupdate#activateUpdate&quot;&gt;activateUpdate()&lt;/a&gt;&lt;/code&gt; 메소드 를 사용하여 업데이트하도록 요청할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e4f4d6a93d3808ee9961bf48da7a9b89bc08b791" translate="yes" xml:space="preserve">
          <source>If the current tab needs to be updated to the latest app version immediately, it can ask to do so with the &lt;code&gt;activateUpdate()&lt;/code&gt; method:</source>
          <target state="translated">현재 탭을 최신 앱 버전으로 즉시 업데이트해야하는 경우 &lt;code&gt;activateUpdate()&lt;/code&gt; 메서드 를 사용하여 업데이트하도록 요청할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9104853be208753a61ab17ecc634fd45d2546fb7" translate="yes" xml:space="preserve">
          <source>If the current working directory is not the right place for your project, you can change to a more appropriate directory by running &lt;code&gt;cd &amp;lt;path-to-other-directory&amp;gt;&lt;/code&gt; first.</source>
          <target state="translated">현재 작업 디렉토리가 프로젝트에 적합한 위치가 아닌 경우 먼저 &lt;code&gt;cd &amp;lt;path-to-other-directory&amp;gt;&lt;/code&gt; 를 실행하여 더 적합한 디렉토리로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d973a83d1ca3ed65eb47b556837d050dedf92561" translate="yes" xml:space="preserve">
          <source>If the errors are gone, switch back to Ivy by removing the changes to the &lt;code&gt;tsconfig.json&lt;/code&gt; and review the list of expected changes below.</source>
          <target state="translated">오류가 사라지면 &lt;code&gt;tsconfig.json&lt;/code&gt; 의 변경 사항을 제거하여 Ivy로 다시 전환 하고 아래에서 예상되는 변경 사항 목록을 검토하십시오.</target>
        </trans-unit>
        <trans-unit id="50bc482af4aa021a010a1117f830ab47823cf166" translate="yes" xml:space="preserve">
          <source>If the event belongs to a directive or component, &lt;code&gt;$event&lt;/code&gt; has the shape that the directive or component produces.</source>
          <target state="translated">이벤트가 지시문 또는 구성 요소에 속하는 경우 &lt;code&gt;$event&lt;/code&gt; 는 지시문 또는 구성 요소가 생성하는 모양을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="f6f468153c2449365e7f2867ef5d5f456b77cbd7" translate="yes" xml:space="preserve">
          <source>If the event belongs to a directive&amp;mdash;recall that components are directives&amp;mdash;&lt;code&gt;$event&lt;/code&gt; has whatever shape the directive produces.</source>
          <target state="translated">이벤트가 지시문에 속하는 경우 (구성 요소는 지시문임을 기억하십시오) &lt;code&gt;$event&lt;/code&gt; 는 지시문이 생성하는 모든 모양을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="73152167c48aecc5313121b22afebd7bc3185f3b" translate="yes" xml:space="preserve">
          <source>If the event lacks a listener or there's some other problem, consider calling &lt;code&gt;nativeElement.dispatchEvent(eventObject)&lt;/code&gt;.</source>
          <target state="translated">이벤트에 리스너가 없거나 다른 문제가 &lt;code&gt;nativeElement.dispatchEvent(eventObject)&lt;/code&gt; 호출을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="13a1756e7082ebba2ca9b175bf1d707be6dc83b3" translate="yes" xml:space="preserve">
          <source>If the field is omitted, it defaults to:</source>
          <target state="translated">필드가 생략되면 기본값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4d62e6f61d2836ab8838dd3181e91ea4e13db082" translate="yes" xml:space="preserve">
          <source>If the final step in a transition is a call to &lt;code&gt;&lt;a href=&quot;animate&quot;&gt;animate&lt;/a&gt;()&lt;/code&gt; that uses a timing value with no style data, that step is automatically considered the final animation arc, for the element to reach the final state. Angular automatically adds or removes CSS styles to ensure that the element is in the correct final state.</source>
          <target state="translated">전환의 마지막 단계가 스타일 데이터가없는 타이밍 값을 사용하는 &lt;code&gt;&lt;a href=&quot;animate&quot;&gt;animate&lt;/a&gt;()&lt;/code&gt; 호출 () 인 경우 해당 단계는 요소가 최종 상태에 도달하기 위해 자동으로 최종 애니메이션 아크로 간주됩니다. Angular는 CSS 스타일을 자동으로 추가하거나 제거하여 요소가 올바른 최종 상태가되도록합니다.</target>
        </trans-unit>
        <trans-unit id="6b3ef72f24c3673b2a628ad0ad40c170035fde2f" translate="yes" xml:space="preserve">
          <source>If the first segment begins with &lt;code&gt;../&lt;/code&gt;, the router goes up one level in the route tree.</source>
          <target state="translated">첫 번째 세그먼트가 &lt;code&gt;../&lt;/code&gt; 로 시작 하면 라우터는 경로 트리에서 한 수준 위로 올라갑니다.</target>
        </trans-unit>
        <trans-unit id="fae4a4530bb21f9338bdba40c855940d55fb7608" translate="yes" xml:space="preserve">
          <source>If the first segment begins with &lt;code&gt;./&lt;/code&gt;, or doesn't begin with a slash, the router looks in the children of the current activated route.</source>
          <target state="translated">첫 번째 세그먼트가 &lt;code&gt;./&lt;/code&gt; 로 시작 하거나 슬래시로 시작하지 않으면 라우터는 현재 활성화 된 경로의 자식을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="e4a660dbc7897b28c034041b6f65be22015a8b7e" translate="yes" xml:space="preserve">
          <source>If the first segment begins with &lt;code&gt;./&lt;/code&gt;, or doesn't begin with a slash, the router will instead look in the children of the current activated route.</source>
          <target state="translated">첫 번째 세그먼트가 &lt;code&gt;./&lt;/code&gt; 로 시작 하거나 슬래시로 시작하지 않으면 라우터는 대신 현재 활성화 된 경로의 자식을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="282a734855bf60155a2ce97a0efd7f8533f10efb" translate="yes" xml:space="preserve">
          <source>If the first segment begins with &lt;code&gt;/&lt;/code&gt;, the router looks up the route from the root of the app.</source>
          <target state="translated">첫 번째 세그먼트가 &lt;code&gt;/&lt;/code&gt; 로 시작 하면 라우터는 앱의 루트에서 경로를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="cea0080cb58c9233caaaea94f5f228089d34ea6f" translate="yes" xml:space="preserve">
          <source>If the first segment begins with &lt;code&gt;/&lt;/code&gt;, the router will look up the route from the root of the app.</source>
          <target state="translated">첫 번째 세그먼트가 &lt;code&gt;/&lt;/code&gt; 로 시작 하면 라우터는 앱의 루트에서 경로를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="0078130fe6400ab8b49e0bc6c85e056609de7e16" translate="yes" xml:space="preserve">
          <source>If the fixture is currently &lt;em&gt;stable&lt;/em&gt;, returns &lt;code&gt;true&lt;/code&gt;. If there are async tasks that have not completed, returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">조명기가 현재 &lt;em&gt;안정적 &lt;/em&gt; &lt;code&gt;true&lt;/code&gt; 반환 합니다 . 완료되지 않은 비동기 작업이 있으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0b70a09df109c3ad19c3522771be006c2c3948dd" translate="yes" xml:space="preserve">
          <source>If the generated &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; decorator does not include the &lt;code&gt;{ &lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;: 'root' }&lt;/code&gt; statement, then insert it as shown above.</source>
          <target state="translated">생성 된 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; 데코레이터에 &lt;code&gt;{ &lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;: 'root' }&lt;/code&gt; 문이 포함되어 있지 않으면 위에 표시된대로 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="15068daa68072149e6fa5ce056eb1f52cac90044" translate="yes" xml:space="preserve">
          <source>If the global library you need to use does not have global typings, you can declare them manually as &lt;code&gt;any&lt;/code&gt; in &lt;code&gt;src/typings.d.ts&lt;/code&gt;. For example:</source>
          <target state="translated">당신이 사용하는 데 필요한 글로벌 라이브러리 글로벌 typings이없는 경우, 당신은 수동으로 선언 할 수 &lt;code&gt;any&lt;/code&gt; 의 &lt;code&gt;src/typings.d.ts&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6cb1ed9802e9478d929162c54da4c8d6fd30657e" translate="yes" xml:space="preserve">
          <source>If the injector doesn't have a provider for a requested token, it delegates the request to its parent injector, where the process repeats until there are no more injectors. If the search fails, the injector throws an error&amp;mdash;unless the request was &lt;a href=&quot;dependency-injection-in-action#optional&quot;&gt;optional&lt;/a&gt;.</source>
          <target state="translated">인젝터에 요청 된 토큰에 대한 제공자가 없으면 요청을 상위 인젝터에 위임합니다. 여기서 인젝터가 더 이상 없을 때까지 프로세스가 반복됩니다. 검색이 실패하면 요청이 &lt;a href=&quot;dependency-injection-in-action#optional&quot;&gt;선택 사항&lt;/a&gt; 이 아닌 한 인젝터에서 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="4a0b3bfb715b52caecc873a2889e0c4f7e9a1de0" translate="yes" xml:space="preserve">
          <source>If the injector has already cached an instance of the service associated with the token, it provides that instance. If it doesn't, it needs to make one using the provider associated with the token.</source>
          <target state="translated">인젝터가 이미 토큰과 연관된 서비스 인스턴스를 캐시 한 경우 해당 인스턴스를 제공합니다. 그렇지 않은 경우 토큰과 연결된 공급자를 사용하여 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="3b4f4ffe72bd420b5f6a4c66dbf5e65cc68e96f5" translate="yes" xml:space="preserve">
          <source>If the link is static, you can use the directive as follows: &lt;code&gt;&amp;lt;&lt;a href=&quot;routerlinkwithhref&quot;&gt;a&lt;/a&gt; &lt;a href=&quot;routerlink&quot;&gt;routerLink&lt;/a&gt;=&quot;/user/bob&quot;&amp;gt;link to user component&amp;lt;/&lt;a href=&quot;routerlinkwithhref&quot;&gt;a&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">: 링크가 정적 인 경우 다음과 같이 지시어를 사용할 수 있습니다 &lt;code&gt;&amp;lt;&lt;a href=&quot;routerlinkwithhref&quot;&gt;a&lt;/a&gt; &lt;a href=&quot;routerlink&quot;&gt;routerLink&lt;/a&gt;=&quot;/user/bob&quot;&amp;gt;link to user component&amp;lt;/&lt;a href=&quot;routerlinkwithhref&quot;&gt;a&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c85a5f245c5fa8e89c1c6d997ca02517847957ee" translate="yes" xml:space="preserve">
          <source>If the name fails to match a property of a known directive or element, Angular reports an &amp;ldquo;unknown directive&amp;rdquo; error.</source>
          <target state="translated">이름이 알려진 지시문 또는 요소의 속성과 일치하지 않으면 Angular는 &quot;알 수없는 지시문&quot;오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="4f09d2765c657029543ee7a53587171de5cd4ed6" translate="yes" xml:space="preserve">
          <source>If the name fails to match an element event or an output property of a known directive, Angular reports an &amp;ldquo;unknown directive&amp;rdquo; error.</source>
          <target state="translated">이름이 알려진 지시문의 요소 이벤트 또는 출력 특성과 일치하지 않으면 Angular는 &quot;알 수없는 지시문&quot;오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="f2b0f2311e32c89d65b510e7b22f6094eeb2fc32" translate="yes" xml:space="preserve">
          <source>If the network request does not complete after 0ms (i.e. immediately), fall back to the cache (ignoring cache age).</source>
          <target state="translated">네트워크 요청이 0ms 후 (즉, 즉시) 완료되지 않으면 캐시로 돌아가십시오 (캐시 수명 무시).</target>
        </trans-unit>
        <trans-unit id="d5ceb0f467be96dbdbfe940dd848a6bc931fbff8" translate="yes" xml:space="preserve">
          <source>If the pipe accepts multiple parameters, separate the values with colons. For example, &lt;code&gt;{{ amount | &lt;a href=&quot;../api/common/currencypipe&quot;&gt;currency&lt;/a&gt;:'EUR':'Euros '}}&lt;/code&gt; adds the second parameter, the string literal &lt;code&gt;'Euros '&lt;/code&gt;, to the output string. You can use any valid template expression as a parameter, such as a string literal or a component property.</source>
          <target state="translated">파이프가 여러 매개 변수를 허용하는 경우 콜론으로 값을 구분하십시오. 예 : &lt;code&gt;{{ amount | &lt;a href=&quot;../api/common/currencypipe&quot;&gt;currency&lt;/a&gt;:'EUR':'Euros '}}&lt;/code&gt; 는 두 번째 매개 변수 인 문자열 리터럴 &lt;code&gt;'Euros '&lt;/code&gt; 를 출력 문자열에 추가합니다. 문자열 리터럴 또는 구성 요소 속성과 같은 유효한 템플릿 식을 매개 변수로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b3d0f7fd76ea32112a2485de9c0071e3eac7cd6" translate="yes" xml:space="preserve">
          <source>If the pipe has internal state (that is, the result depends on state other than its arguments), set &lt;code&gt;pure&lt;/code&gt; to false. In this case, the pipe is invoked on each change-detection cycle, even if the arguments have not changed.</source>
          <target state="translated">파이프에 내부 상태가있는 경우 (즉, 결과는 인수 이외의 상태에 따라 다름) &lt;code&gt;pure&lt;/code&gt; 을 false로 설정하십시오 . 이 경우 인수가 변경되지 않은 경우에도 각 변경 감지주기마다 파이프가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4763dcf43d2d8abf4591a273eb238b96e963dfb9" translate="yes" xml:space="preserve">
          <source>If the policy is set to &lt;code&gt;&lt;a href=&quot;viewencapsulation#Emulated&quot;&gt;ViewEncapsulation.Emulated&lt;/a&gt;&lt;/code&gt; and the component has no &lt;code&gt;styles&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;component#styleUrls&quot;&gt;styleUrls&lt;/a&gt;&lt;/code&gt; specified, the policy is automatically switched to &lt;code&gt;&lt;a href=&quot;viewencapsulation#None&quot;&gt;ViewEncapsulation.None&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">정책이 &lt;code&gt;&lt;a href=&quot;viewencapsulation#Emulated&quot;&gt;ViewEncapsulation.Emulated&lt;/a&gt;&lt;/code&gt; 로 설정되고 구성 요소에 지정된 &lt;code&gt;styles&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;component#styleUrls&quot;&gt;styleUrls&lt;/a&gt;&lt;/code&gt; 가없는 경우 정책은 자동으로 &lt;code&gt;&lt;a href=&quot;viewencapsulation#None&quot;&gt;ViewEncapsulation.None&lt;/a&gt;&lt;/code&gt; 으로 전환됩니다 .</target>
        </trans-unit>
        <trans-unit id="528533bd9f3f7e28532ec0e9f917dad69f8c023f" translate="yes" xml:space="preserve">
          <source>If the policy is set to &lt;code&gt;&lt;a href=&quot;viewencapsulation#Emulated&quot;&gt;ViewEncapsulation.Emulated&lt;/a&gt;&lt;/code&gt; and the component has no &lt;code&gt;styles&lt;/code&gt; or &lt;code&gt;styleUrls&lt;/code&gt; specified, the policy is automatically switched to &lt;code&gt;&lt;a href=&quot;viewencapsulation#None&quot;&gt;ViewEncapsulation.None&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">정책이 &lt;code&gt;&lt;a href=&quot;viewencapsulation#Emulated&quot;&gt;ViewEncapsulation.Emulated&lt;/a&gt;&lt;/code&gt; 로 설정되고 구성 요소에 &lt;code&gt;styles&lt;/code&gt; 또는 &lt;code&gt;styleUrls&lt;/code&gt; 지정 되지 않은 경우 정책은 자동으로 &lt;code&gt;&lt;a href=&quot;viewencapsulation#None&quot;&gt;ViewEncapsulation.None&lt;/a&gt;&lt;/code&gt; 으로 전환됩니다 .</target>
        </trans-unit>
        <trans-unit id="2d810ad667c3b20ef3b51707d2be9b432b64b1cf" translate="yes" xml:space="preserve">
          <source>If the polyfill you want is not already in &lt;code&gt;polyfills.ts&lt;/code&gt; file, add the &lt;code&gt;import&lt;/code&gt; statement by hand.</source>
          <target state="translated">원하는 polyfill이 아직 &lt;code&gt;polyfills.ts&lt;/code&gt; 파일 에 없으면 &lt;code&gt;import&lt;/code&gt; 문을 직접 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="dbeae5467dc3bcad5134cf5b5566370850d4809d" translate="yes" xml:space="preserve">
          <source>If the request fails on the server, &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; returns an &lt;em&gt;error&lt;/em&gt; object instead of a successful response.</source>
          <target state="translated">서버에서 요청이 실패하면 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 는 성공적인 응답 대신 &lt;em&gt;오류&lt;/em&gt; 개체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="59935f40339f370a775c93f8ebfe64fdb8501b4a" translate="yes" xml:space="preserve">
          <source>If the request is not cachable, the interceptor simply forwards the request to the next handler in the chain.</source>
          <target state="translated">요청을 캐시 할 수없는 경우 인터셉터는 요청을 체인의 다음 핸들러로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="5e9cbfa57bb0afe989236f55b4bfa5b227f9e699" translate="yes" xml:space="preserve">
          <source>If the request is not cacheable, the interceptor simply forwards the request to the next handler in the chain.</source>
          <target state="translated">요청이 캐시 할 수없는 경우 인터셉터는 요청을 체인의 다음 핸들러로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="48e69ae093510c60c5092e955910531474a7b0eb" translate="yes" xml:space="preserve">
          <source>If the resource does not exist in the cache, wait for the network request anyway.</source>
          <target state="translated">리소스가 캐시에 없으면 네트워크 요청을 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="7ac51969f4d26381b937d7506df3c5ca028390e8" translate="yes" xml:space="preserve">
          <source>If the router determines that the current application state requires particular functionality, and the module that defines it hasn't been loaded, the router can &lt;em&gt;lazy-load&lt;/em&gt; the module on demand.</source>
          <target state="translated">라우터가 현재 애플리케이션 상태에 특정 기능이 필요하다고 결정하고이를 정의하는 모듈이로드되지 않은 경우 라우터는 요청시 모듈을 &lt;em&gt;지연로드&lt;/em&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="078a62a59d26aee3fda2d3094d8e784f2342103f" translate="yes" xml:space="preserve">
          <source>If the same text elements have different &lt;em&gt;descriptions&lt;/em&gt; but the same &lt;em&gt;meaning&lt;/em&gt;, they are extracted only once, with only one ID. That one translation entry is merged back into the app wherever the same text elements appear.</source>
          <target state="translated">동일한 텍스트 요소가 &lt;em&gt;설명&lt;/em&gt; 은 다르지만 &lt;em&gt;의미&lt;/em&gt; 는 동일한 경우 하나의 ID로 한 번만 추출됩니다. 하나의 번역 항목은 동일한 텍스트 요소가 나타날 때마다 앱에 다시 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="55c33d001b1da373abf39836eea39311b1acb30e" translate="yes" xml:space="preserve">
          <source>If the target event name, &lt;code&gt;myClick&lt;/code&gt; fails to match an element event or an output property of &lt;code&gt;ClickDirective&lt;/code&gt;, Angular reports an &quot;unknown directive&quot; error.</source>
          <target state="translated">대상 이벤트 이름 &lt;code&gt;myClick&lt;/code&gt; 이 요소 이벤트 또는 &lt;code&gt;ClickDirective&lt;/code&gt; 의 출력 속성과 일치하지 않으면 Angular는 &quot;알 수없는 지시문&quot;오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="8394b2e767bb12ed5ce19f8e2789f404b7484f75" translate="yes" xml:space="preserve">
          <source>If the token is not found, the injector looks for the closest parent &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; to delegate the request to.</source>
          <target state="translated">토큰을 찾을 수 없으면 인젝터는 요청을 위임 할 가장 가까운 상위 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; 을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="ecf78ef653c4d34586962407b03b480fcd055de0" translate="yes" xml:space="preserve">
          <source>If the user clicks &quot;Magneta&quot;, that hero should render with a distinctive but subtle background color like this:</source>
          <target state="translated">사용자가 &quot;Magneta&quot;를 클릭하면 해당 영웅은 다음과 같이 독특하지만 미묘한 배경색으로 렌더링해야합니다.</target>
        </trans-unit>
        <trans-unit id="c189f0f17a7b1f805b9f00a96ea0807e51814fa1" translate="yes" xml:space="preserve">
          <source>If the user is accessing your app via a browser that does not support service workers, the service worker is not registered and related behavior such as offline cache management and push notifications does not happen. More specifically:</source>
          <target state="translated">사용자가 서비스 워커를 지원하지 않는 브라우저를 통해 앱에 액세스하는 경우 서비스 워커가 등록되지 않으며 오프라인 캐시 관리 및 푸시 알림과 같은 관련 동작이 발생하지 않습니다. 더 구체적으로:</target>
        </trans-unit>
        <trans-unit id="c7bb75e93c7ef1a5eb66e798e8f358b5eede9fc4" translate="yes" xml:space="preserve">
          <source>If the user is not logged in, you store the attempted URL the user came from using the &lt;code&gt;&lt;a href=&quot;../api/router/routerstatesnapshot#url&quot;&gt;RouterStateSnapshot.url&lt;/a&gt;&lt;/code&gt; and tell the router to navigate to a login page&amp;mdash;a page you haven't created yet. This secondary navigation automatically cancels the current navigation; &lt;code&gt;checkLogin()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; just to be clear about that.</source>
          <target state="translated">사용자가 로그인하지 않은 경우 사용자가 &lt;code&gt;&lt;a href=&quot;../api/router/routerstatesnapshot#url&quot;&gt;RouterStateSnapshot.url&lt;/a&gt;&lt;/code&gt; 을 사용하여 시도한 URL을 저장 하고 라우터가 로그인 페이지 (아직 만들지 않은 페이지)로 이동하도록 지시합니다. 이 보조 탐색은 현재 탐색을 자동으로 취소합니다. &lt;code&gt;checkLogin()&lt;/code&gt; 은 그것을 명확하게하기 위해 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0e9fef2eafd5b1ccdde39a85d15a3e1d179c35d6" translate="yes" xml:space="preserve">
          <source>If the user is not logged in, you store the attempted URL the user came from using the &lt;code&gt;&lt;a href=&quot;../api/router/routerstatesnapshot#url&quot;&gt;RouterStateSnapshot.url&lt;/a&gt;&lt;/code&gt; and tell the router to redirect to a login page&amp;mdash;a page you haven't created yet. Returning a &lt;code&gt;&lt;a href=&quot;../api/router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; tells the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; to cancel the current navigation and schedule a new one to redirect the user.</source>
          <target state="translated">사용자가 로그인하지 않은 경우 &lt;code&gt;&lt;a href=&quot;../api/router/routerstatesnapshot#url&quot;&gt;RouterStateSnapshot.url&lt;/a&gt;&lt;/code&gt; 을 사용하여 사용자가 시도한 URL을 저장 하고 라우터에 로그인 페이지 (아직 만들지 않은 페이지)로 리디렉션하도록 지시합니다. &lt;code&gt;&lt;a href=&quot;../api/router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 를 반환 하면 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 가 현재 탐색을 취소하고 새 탐색을 예약하여 사용자를 리디렉션하도록합니다.</target>
        </trans-unit>
        <trans-unit id="de7fbb24093105b8d981322fd4ad3921dd415377" translate="yes" xml:space="preserve">
          <source>If the values do not match, the hero's identity remains secret, and we can safely return null. Otherwise, the hero's identity is revealed and we must mark the form as invalid by returning an error object.</source>
          <target state="translated">값이 일치하지 않으면 영웅의 신원은 비밀로 유지되며 안전하게 null을 반환 할 수 있습니다. 그렇지 않으면 영웅의 신원이 공개되고 오류 객체를 반환하여 양식을 유효하지 않은 것으로 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="192705fa856a62452b2da969a8912e6b8a173d58" translate="yes" xml:space="preserve">
          <source>If the values do not match, the hero's identity remains secret, both are valid, and the validator returns null. If they do match, the hero's identity is revealed and the validator must mark the form as invalid by returning an error object.</source>
          <target state="translated">값이 일치하지 않으면 영웅의 신원은 비밀로 유지되고 둘 다 유효하며 유효성 검사기는 null을 반환합니다. 일치하는 경우 영웅의 신원이 공개되고 유효성 검사기는 오류 개체를 반환하여 양식을 유효하지 않은 것으로 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="bda3fcdf84185ee6e87bd031022a93fa36ad65dc" translate="yes" xml:space="preserve">
          <source>If the variable specifies a name on the right-hand side, such as &lt;code&gt;#var=&quot;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&quot;&lt;/code&gt;, the variable refers to the directive or component on the element with a matching &lt;code&gt;exportAs&lt;/code&gt; name.</source>
          <target state="translated">변수가 &lt;code&gt;#var=&quot;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&quot;&lt;/code&gt; 과 같이 오른쪽에 이름을 지정하는 경우 변수는 &lt;code&gt;exportAs&lt;/code&gt; 이름 이 일치하는 요소의 지시문 또는 구성 요소를 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="96ad008e2ef13ed8ed5f5c2ec956a424d99e7a41" translate="yes" xml:space="preserve">
          <source>If there are any pending timers at the end of the function, an exception will be thrown.</source>
          <target state="translated">함수의 끝에 보류중인 타이머가 있으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f9a670037bd4af4276da780403250f1a42128b74" translate="yes" xml:space="preserve">
          <source>If there are inconsistencies (for example, if peer dependencies cannot be matched by a simple &lt;a href=&quot;https://semver.io/&quot;&gt;semver&lt;/a&gt; range), the command generates an error and does not change anything in the workspace.</source>
          <target state="translated">불일치가있는 경우 (예를 들어, 피어 종속성이 단순 &lt;a href=&quot;https://semver.io/&quot;&gt;semver&lt;/a&gt; 범위 와 일치 할 수없는 경우 ) 명령은 오류를 생성하고 작업 공간에서 아무것도 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="68b1ed93992996f8ce266b19d9921f1a6b7679ba" translate="yes" xml:space="preserve">
          <source>If there are multiple bindings to the same class name, Angular uses &lt;a href=&quot;style-precedence&quot;&gt;styling precedence&lt;/a&gt; to determine which binding to use.</source>
          <target state="translated">동일한 클래스 이름에 대한 바인딩이 여러 개있는 경우 Angular는 &lt;a href=&quot;style-precedence&quot;&gt;스타일 우선 순위&lt;/a&gt; 를 사용하여 사용할 바인딩을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="4b17fa9f251dc2328f40733768f4df7c53d0e774" translate="yes" xml:space="preserve">
          <source>If there are multiple bindings to the same style attribute, Angular uses &lt;a href=&quot;style-precedence&quot;&gt;styling precedence&lt;/a&gt; to determine which binding to use.</source>
          <target state="translated">동일한 스타일 속성에 대한 여러 바인딩이있는 경우 Angular는 &lt;a href=&quot;style-precedence&quot;&gt;스타일 우선 순위&lt;/a&gt; 를 사용하여 사용할 바인딩을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="6bce86d8e3129408ac34398b75eca72346010c23" translate="yes" xml:space="preserve">
          <source>If there are multiple matching elements, staggers in each element starting at the top of the page, with a 50-millisecond delay between each element.</source>
          <target state="translated">일치하는 요소가 여러 개인 경우 페이지 맨 위에서 시작하여 각 요소 사이에서 50 밀리 초의 지연으로 각 요소가 엇갈리게 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="5d0e50c9ab16f52d7179be4c30d0ae22030f6696" translate="yes" xml:space="preserve">
          <source>If there are no &lt;code&gt;&lt;a href=&quot;animationstylemetadata#offset&quot;&gt;offset&lt;/a&gt;&lt;/code&gt; values specified in the style entries, the offsets are calculated automatically.</source>
          <target state="translated">스타일 항목에 지정된 &lt;code&gt;&lt;a href=&quot;animationstylemetadata#offset&quot;&gt;offset&lt;/a&gt;&lt;/code&gt; 값 이 없으면 오프셋 이 자동으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="fd9120ef266d5131d0f02db2be350a2e53f38db9" translate="yes" xml:space="preserve">
          <source>If there are no &lt;code&gt;offset&lt;/code&gt; values specified in the style entries, the offsets are calculated automatically.</source>
          <target state="translated">스타일 항목에 지정된 &lt;code&gt;offset&lt;/code&gt; 값 이 없으면 오프셋 이 자동으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="ca5c24cb964d2798172bebc6b28f39e9832c4073" translate="yes" xml:space="preserve">
          <source>If there are no matches, a view with the &lt;code&gt;&lt;a href=&quot;common/ngswitchdefault&quot;&gt;ngSwitchDefault&lt;/a&gt;&lt;/code&gt; directive is rendered.</source>
          <target state="translated">일치하는 항목이 없으면 &lt;code&gt;&lt;a href=&quot;common/ngswitchdefault&quot;&gt;ngSwitchDefault&lt;/a&gt;&lt;/code&gt; 지시문이 있는보기 가 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="bdfacb45406d5e8b6f34dd5b25ce44a85e6145b1" translate="yes" xml:space="preserve">
          <source>If there are no matches, a view with the &lt;code&gt;&lt;a href=&quot;ngswitchdefault&quot;&gt;ngSwitchDefault&lt;/a&gt;&lt;/code&gt; directive is rendered.</source>
          <target state="translated">일치하는 것이 없으면 &lt;code&gt;&lt;a href=&quot;ngswitchdefault&quot;&gt;ngSwitchDefault&lt;/a&gt;&lt;/code&gt; 지시문이 있는 뷰 가 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="469567e644a4eb10f45ac06d4145cbb3283b05ab" translate="yes" xml:space="preserve">
          <source>If there is a cached value, the code &lt;em&gt;pipes&lt;/em&gt; the cached response onto &lt;code&gt;results$&lt;/code&gt;, producing a recomposed observable that emits twice, the cached response first (and immediately), followed later by the response from the server. Subscribers see a sequence of &lt;em&gt;two&lt;/em&gt; responses.</source>
          <target state="translated">캐시 된 값이있는 경우 코드 는 캐시 된 응답을 &lt;code&gt;results$&lt;/code&gt; 에 &lt;em&gt;파이프&lt;/em&gt; 하여 캐시 된 응답을 두 번 방출 한 재구성 된 관찰 가능 항목을 먼저 생성 한 다음 나중에 서버의 응답을 생성합니다. 가입자는 &lt;em&gt;두 개의&lt;/em&gt; 응답 시퀀스를 봅니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f51b2e133050bbccba4bfd98827887fed42575f" translate="yes" xml:space="preserve">
          <source>If there is a cached value, the code &lt;em&gt;pipes&lt;/em&gt; the cached response onto &lt;code&gt;results$&lt;/code&gt;, producing a recomposed observable that emits twice, the cached response first (and immediately), followed later by the response from the server. Subscribers see a sequence of two responses.</source>
          <target state="translated">캐시 된 값이있는 경우 코드 는 캐시 된 응답을 &lt;code&gt;results$&lt;/code&gt; 로 &lt;em&gt;파이프&lt;/em&gt; 하여 캐시 된 응답을 먼저 (그리고 즉시) 두 번 방출하는 재구성 된 관찰 가능 항목을 생성 한 다음 나중에 서버의 응답을 생성합니다. 구독자는 두 개의 응답 시퀀스를 봅니다.</target>
        </trans-unit>
        <trans-unit id="861f9ce42be463b31e5de676232a75f5183b6ba2" translate="yes" xml:space="preserve">
          <source>If there is a search term, the code constructs an options object with an HTML URL-encoded search parameter. If the term is &quot;cat&quot;, for example, the GET request URL would be &lt;code&gt;api/heroes?name=cat&lt;/code&gt;.</source>
          <target state="translated">검색어가있는 경우 코드는 HTML URL 인코딩 검색 매개 변수를 사용하여 옵션 개체를 구성합니다. 예를 들어 용어가 &quot;cat&quot;인 경우 GET 요청 URL은 &lt;code&gt;api/heroes?name=cat&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="99c30904c74feea9735c68b368b80ff51127fb2d" translate="yes" xml:space="preserve">
          <source>If there is a search term, the code constructs an options object with an HTML URL-encoded search parameter. If the term were &quot;foo&quot;, the GET request URL would be &lt;code&gt;api/heroes?name=foo&lt;/code&gt;.</source>
          <target state="translated">검색어가 있으면 코드는 HTML URL로 인코딩 된 검색 매개 변수를 사용하여 옵션 객체를 구성합니다. 용어가 &quot;foo&quot;인 경우 GET 요청 URL은 &lt;code&gt;api/heroes?name=foo&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d8a482ba206dfd36e3f36762fb13f8b6559b18b8" translate="yes" xml:space="preserve">
          <source>If there is a section of text that you would like to translate, you can wrap it in a &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; tag. However, if you don't want to create a new DOM element merely to facilitate translation, you can wrap the text in an &lt;code&gt;&amp;lt;ng-container&amp;gt;&lt;/code&gt; element. The &lt;code&gt;&amp;lt;ng-container&amp;gt;&lt;/code&gt; is transformed into an html comment:</source>
          <target state="translated">번역하려는 텍스트 섹션이 있으면 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 태그로 묶을 수 있습니다. 그러나 번역을 용이하게하기 위해 새 DOM 요소를 만들지 않으려면 &lt;code&gt;&amp;lt;ng-container&amp;gt;&lt;/code&gt; 요소로 텍스트를 줄 바꿈하면됩니다 . &lt;code&gt;&amp;lt;ng-container&amp;gt;&lt;/code&gt; HTML 주석로 변환된다 :</target>
        </trans-unit>
        <trans-unit id="95d0282529a24fb4dad5c5e40dfcf058c88875dc" translate="yes" xml:space="preserve">
          <source>If there is both an unbound class attribute and a &lt;code&gt;[class]&lt;/code&gt; binding, the classes in the unbound attribute will also be added (previously, the class binding would overwrite classes in the unbound attribute).</source>
          <target state="translated">바인딩되지 않은 클래스 속성과 &lt;code&gt;[class]&lt;/code&gt; 바인딩 이 모두있는 경우 바인딩되지 않은 속성의 클래스도 추가됩니다 (이전에는 클래스 바인딩이 바인딩되지 않은 속성의 클래스를 덮어 썼습니다).</target>
        </trans-unit>
        <trans-unit id="789a03391ec493accfaf2648ace4780e8da1f3e8" translate="yes" xml:space="preserve">
          <source>If there is no structural directive and you merely wrap some elements in a &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt;, those elements disappear. That's the fate of the middle &quot;Hip!&quot; in the phrase &quot;Hip! Hip! Hooray!&quot;.</source>
          <target state="translated">구조적 지시어가없고 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 의 일부 요소 만 래핑하면 해당 요소가 사라집니다. 그것이 중간 &quot;Hip!&quot;의 운명입니다. &quot;Hip! Hip! Hooray!&quot;라는 문구에</target>
        </trans-unit>
        <trans-unit id="c0a56b8fffce47376883198a8d9baa521d322597" translate="yes" xml:space="preserve">
          <source>If there's no cached value, the interceptor returns &lt;code&gt;results$&lt;/code&gt;.</source>
          <target state="translated">캐시 된 값이 없으면 인터셉터는 &lt;code&gt;results$&lt;/code&gt; 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="2c9573a993697b7205978825080a3f70b90ace3b" translate="yes" xml:space="preserve">
          <source>If these performance and minification considerations don't apply to you, you can always create your own such pipes (similar to the &lt;a href=&quot;pipes#impure-flying-heroes&quot;&gt;FlyingHeroesPipe&lt;/a&gt;) or find them in the community.</source>
          <target state="translated">이러한 성능 및 최소화 고려 사항이 적용되지 않는 경우 언제든지 자신의 파이프를 만들거나 ( &lt;a href=&quot;pipes#impure-flying-heroes&quot;&gt;FlyingHeroesPipe&lt;/a&gt; 와 유사 ) 커뮤니티에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="128c120be1c661795cc994725f81beabd4448f98" translate="yes" xml:space="preserve">
          <source>If this NgModule were the root &lt;code&gt;AppModule&lt;/code&gt;, the &lt;code&gt;UserService&lt;/code&gt; would be a singleton and available throughout the app. Though you may see it coded this way, using the &lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;&lt;/code&gt; property of the &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; decorator on the service itself is preferable as of Angular 6.0 as it makes your services tree-shakable.</source>
          <target state="translated">이 NgModule이 루트 &lt;code&gt;AppModule&lt;/code&gt; 인 경우 &lt;code&gt;UserService&lt;/code&gt; 는 싱글 톤이며 앱 전체에서 사용할 수 있습니다. 이 방법으로 코딩 된 것을 볼 수 있지만 서비스 자체 에서 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt; () 데코레이터 의 &lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;&lt;/code&gt; 속성을 사용하는 것이 서비스를 트리 스태킹 할 수 있기 때문에 Angular 6.0보다 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="52b616c30fcd1c3179a4f94d2ff26bd944939a69" translate="yes" xml:space="preserve">
          <source>If this NgModule were the root &lt;code&gt;AppModule&lt;/code&gt;, the &lt;code&gt;UserService&lt;/code&gt; would be a singleton and available throughout the app. Though you may see it coded this way, using the &lt;code&gt;providedIn&lt;/code&gt; property of the &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; decorator on the service itself is preferable as of Angular 6.0 as it makes your services tree-shakable.</source>
          <target state="translated">이 NgModule이 루트 &lt;code&gt;AppModule&lt;/code&gt; 이면 &lt;code&gt;UserService&lt;/code&gt; 는 싱글 톤이되고 앱 전체에서 사용할 수 있습니다. 이런 식으로 코딩 된 것을 볼 수 있지만 서비스 자체 에서 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt; () 데코레이터 의 &lt;code&gt;providedIn&lt;/code&gt; 속성을 사용하는 것이 Angular 6.0부터 서비스를 트리 흔들기 가능하게 만들기 때문에 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="a961d773c3ebb64dd1d2a5bb5b8857c41c94da34" translate="yes" xml:space="preserve">
          <source>If this is something you wanted to do, it would be a good idea to enable the &lt;code&gt;noImplicitAny&lt;/code&gt; configuration option in &lt;code&gt;tsconfig.json&lt;/code&gt;. This would cause the TypeScript compiler to display a warning when there's any code that does not yet have type annotations. You could use it as a guide to inform us about how close you are to having a fully annotated project.</source>
          <target state="translated">이것이 원하는 경우 &lt;code&gt;tsconfig.json&lt;/code&gt; 에서 &lt;code&gt;noImplicitAny&lt;/code&gt; 구성 옵션 을 활성화하는 것이 좋습니다 . 이렇게하면 아직 형식 주석이없는 코드가있을 때 TypeScript 컴파일러에 경고가 표시됩니다. 완전히 주석이 달린 프로젝트가 얼마나 가까운 지 알려주는 안내서로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8b697c68c21ca2b9972cd7df3c8b2c2521e942f" translate="yes" xml:space="preserve">
          <source>If this pattern does not satisfy your business needs, you can use &lt;code&gt;&lt;a href=&quot;validators#pattern&quot;&gt;Validators.pattern()&lt;/a&gt;&lt;/code&gt; to validate the value against a different pattern.</source>
          <target state="translated">이 패턴이 비즈니스 요구를 충족시키지 않으면 &lt;code&gt;&lt;a href=&quot;validators#pattern&quot;&gt;Validators.pattern()&lt;/a&gt;&lt;/code&gt; 을 사용 하여 다른 패턴에 대해 값을 검증 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12a97be36f3f8b698fee41e85a55b88f80921851" translate="yes" xml:space="preserve">
          <source>If true, this directive/component will be skipped by the AOT compiler and so will always be compiled using JIT.</source>
          <target state="translated">true 인 경우이 지시문 / 구성 요소는 AOT 컴파일러에서 건너 뛰므로 항상 JIT를 사용하여 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="dee5d11f125e7906a2306bcec4c66b607231b73c" translate="yes" xml:space="preserve">
          <source>If true, this module will be skipped by the AOT compiler and so will always be compiled using JIT.</source>
          <target state="translated">true 인 경우이 모듈은 AOT 컴파일러에서 건너 뛰므로 항상 JIT를 사용하여 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="ba78200d25bae586b98c7c392474b61cabfe4a71" translate="yes" xml:space="preserve">
          <source>If value is trusted for the context, this method will unwrap the contained safe value and use it directly. Otherwise, value will be sanitized to be safe in the given context, for example by replacing URLs that have an unsafe protocol part (such as &lt;code&gt;javascript:&lt;/code&gt;). The implementation is responsible to make sure that the value can definitely be safely used in the given context.</source>
          <target state="translated">컨텍스트에 대해 값을 신뢰할 수있는 경우이 메소드는 포함 된 안전 값을 풀고 직접 사용합니다. 그렇지 않으면, 안전하지 않은 프로토콜 부분 (예 : &lt;code&gt;javascript:&lt;/code&gt; :)이있는 URL을 바꾸는 등 주어진 컨텍스트에서 안전하도록 값이 삭제됩니다 . 구현시 주어진 컨텍스트에서 값을 안전하게 사용할 수 있도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="3bb452304863c61a02b99678f43105cff45695b0" translate="yes" xml:space="preserve">
          <source>If we create a new project with &lt;code&gt;ng new builder-test&lt;/code&gt;, the generated &lt;code&gt;angular.json&lt;/code&gt; file looks something like this, with only default builder configurations.</source>
          <target state="translated">&lt;code&gt;ng new builder-test&lt;/code&gt; 로 새 프로젝트를 작성 하면 생성 된 &lt;code&gt;angular.json&lt;/code&gt; 파일은 기본 빌더 구성 만있는 이와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="410d7d19eeff8be9f91595a2a6c28a3630cc8b2e" translate="yes" xml:space="preserve">
          <source>If we neglected to add, &lt;code&gt;#docplaster&lt;/code&gt;, the processor would insert the &lt;em&gt;default&lt;/em&gt; plaster - an ellipsis comment - between the fragments. Try removing the &lt;code&gt;#docplaster&lt;/code&gt; comment yourself to see the effect.</source>
          <target state="translated">&lt;code&gt;#docplaster&lt;/code&gt; 를 추가하지 않으면 프로세서는 조각 사이에 &lt;em&gt;기본&lt;/em&gt; 석고 (줄임표 주석)를 삽입합니다 . &lt;code&gt;#docplaster&lt;/code&gt; 주석을 직접 제거하여 효과를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="539d94c8fe072123800e0f9db24c1874e3e30bba" translate="yes" xml:space="preserve">
          <source>If you &lt;em&gt;mutate&lt;/em&gt; the array, no pipe is invoked and the display isn't updated; if you &lt;em&gt;replace&lt;/em&gt; the array, the pipe executes and the display is updated. The Flying Heroes application extends the code with checkbox switches and additional displays to help you experience these effects.</source>
          <target state="translated">배열 을 &lt;em&gt;변경&lt;/em&gt; 하면 파이프가 호출되지 않고 디스플레이가 업데이트되지 않습니다. 배열 을 &lt;em&gt;교체&lt;/em&gt; 하면 파이프가 실행되고 화면이 업데이트됩니다. Flying Heroes 응용 프로그램은 이러한 효과를 경험할 수 있도록 확인란 스위치와 추가 디스플레이로 코드를 확장합니다.</target>
        </trans-unit>
        <trans-unit id="0fabf2886d8095e393384ce3f692c1d6440c63c9" translate="yes" xml:space="preserve">
          <source>If you add &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; to the constructor for &lt;code&gt;AnimalService&lt;/code&gt;, the result is 🐶 (puppy) because the injector finds the &lt;code&gt;AnimalService&lt;/code&gt; in the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt;. Here is the &lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt; array in the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; class and &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; in the constructor:</source>
          <target state="translated">&lt;code&gt;AnimalService&lt;/code&gt; 의 생성자에 &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; 를 추가 하면 인젝터가 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;AnimalService&lt;/code&gt; 를 찾기 때문에 결과는 🐶 (puppy) 입니다. &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; 클래스 의 &lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt; 배열 과 생성자의 &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt; () 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="020ce77fbfa16628a9d3b03c2b40dcb957a7f20a" translate="yes" xml:space="preserve">
          <source>If you add &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; to the constructor for &lt;code&gt;AnimalService&lt;/code&gt;, the result is 🐶 (puppy) because the injector finds the &lt;code&gt;AnimalService&lt;/code&gt; in the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt;. Here is the &lt;code&gt;viewProviders&lt;/code&gt; array in the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; class and &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; in the constructor:</source>
          <target state="translated">&lt;code&gt;AnimalService&lt;/code&gt; 의 생성자에 &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; 를 추가 하면 인젝터가 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;AnimalService&lt;/code&gt; 를 찾기 때문에 결과는 🐶 (puppy) 입니다. 다음은 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; 클래스 의 &lt;code&gt;viewProviders&lt;/code&gt; 배열 과 생성자의 &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt; () 입니다.</target>
        </trans-unit>
        <trans-unit id="057296fa1750840f11cd0280d602d1818f95536d" translate="yes" xml:space="preserve">
          <source>If you already have an app that was created with the &lt;a href=&quot;cli&quot;&gt;Angular CLI&lt;/a&gt;, you can create a service using the &lt;a href=&quot;cli/generate&quot;&gt;&lt;code&gt;ng generate&lt;/code&gt;&lt;/a&gt; CLI command in the root project directory. Replace &lt;em&gt;User&lt;/em&gt; with the name of your service.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;Angular CLI&lt;/a&gt; 로 작성된 앱이 이미있는 경우 루트 프로젝트 디렉토리에서 &lt;a href=&quot;cli/generate&quot;&gt; &lt;code&gt;ng generate&lt;/code&gt; &lt;/a&gt; CLI 명령을 사용하여 서비스를 작성할 수 있습니다 . 교체 &lt;em&gt;사용자&lt;/em&gt; 서비스의 이름으로.</target>
        </trans-unit>
        <trans-unit id="2ff6e048cc33df5338739033fa8346eb0d4a951f" translate="yes" xml:space="preserve">
          <source>If you already have projects running on your machine that use other versions of Node.js and npm, consider using &lt;a href=&quot;https://github.com/creationix/nvm&quot;&gt;nvm&lt;/a&gt; to manage the multiple versions of Node.js and npm.</source>
          <target state="translated">다른 버전의 Node.js 및 npm을 사용하는 시스템에서 이미 프로젝트를 실행중인 경우 &lt;a href=&quot;https://github.com/creationix/nvm&quot;&gt;nvm&lt;/a&gt; 을 사용하여 여러 버전의 Node.js 및 npm을 관리하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="90d4d7fe6344c11a6f7bcd7a21dbd7b7bce219e6" translate="yes" xml:space="preserve">
          <source>If you are a library author, you should keep using the View Engine compiler as of version 9. By having all libraries continue to use View Engine, you will maintain compatibility with default v9 applications that use Ivy, as well as with applications that have opted to continue using View Engine.</source>
          <target state="translated">라이브러리 작성자 인 경우 버전 9부터 View Engine 컴파일러를 계속 사용해야합니다. 모든 라이브러리가 View Engine을 계속 사용하도록하면 Ivy를 사용하는 기본 v9 응용 프로그램 및 선택한 응용 프로그램과의 호환성을 유지할 수 있습니다. View Engine을 계속 사용하려면</target>
        </trans-unit>
        <trans-unit id="20b03c67a88235e36acc0fc42c3d9208b7a04ffe" translate="yes" xml:space="preserve">
          <source>If you are currently using AngularJS, see &lt;a href=&quot;upgrade&quot;&gt;Upgrading from AngularJS&lt;/a&gt;. &lt;em&gt;AngularJS&lt;/em&gt; is the name for all v1.x versions of Angular.</source>
          <target state="translated">현재 AngularJS를 사용중인 경우 AngularJS에서 &lt;a href=&quot;upgrade&quot;&gt;업그레이드를&lt;/a&gt; 참조하십시오 . &lt;em&gt;AngularJS&lt;/em&gt; 는 모든 v1.x 버전의 Angular의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2a8730eb4263adf9633421f884873db3bc272d64" translate="yes" xml:space="preserve">
          <source>If you are hiding large component trees, consider &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; as a more efficient alternative to showing/hiding.</source>
          <target state="translated">큰 구성 요소 트리를 숨기 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 를 표시 / 숨기기의보다 효율적인 대안으로 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd74353d5cb9e62ae95981a79ed374fcaa9e6433" translate="yes" xml:space="preserve">
          <source>If you are implementing a custom renderer, you must implement this interface.</source>
          <target state="translated">사용자 정의 렌더러를 구현하는 경우이 인터페이스를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="abfbbb4531d989e45009d6d362b78e141a014fd3" translate="yes" xml:space="preserve">
          <source>If you are new to Angular, see &lt;a href=&quot;start&quot;&gt;Getting Started&lt;/a&gt;. Getting Started helps you quickly learn the essentials of Angular, in the context of building a basic online store app. It leverages the &lt;a href=&quot;https://stackblitz.com/&quot;&gt;StackBlitz&lt;/a&gt; online development environment, so you don't need to set up your local environment until you're ready.</source>
          <target state="translated">Angular를 &lt;a href=&quot;start&quot;&gt;처음 사용하는 경우 시작하기를&lt;/a&gt; 참조하십시오 . 시작하면 기본적인 온라인 상점 앱을 구축 할 때 Angular의 필수 요소를 빠르게 배울 수 있습니다. &lt;a href=&quot;https://stackblitz.com/&quot;&gt;StackBlitz&lt;/a&gt; 온라인 개발 환경을 활용 하므로 준비가 될 때까지 로컬 환경을 설정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a2afbd5d04b514e212ac51be4531329265f23e7" translate="yes" xml:space="preserve">
          <source>If you are new to Angular, see the &lt;a href=&quot;start&quot;&gt;Getting Started&lt;/a&gt; tutorial. Getting Started helps you quickly learn the essentials of Angular, in the context of building a basic online store app.</source>
          <target state="translated">Angular를 &lt;a href=&quot;start&quot;&gt;처음 사용하는 경우 시작하기&lt;/a&gt; 자습서를 참조하십시오 . 시작하면 기본적인 온라인 상점 앱을 구축 할 때 Angular의 필수 요소를 빠르게 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c411ae285cef2e50450b7be137b68af40349548" translate="yes" xml:space="preserve">
          <source>If you are new to Angular, you might want to start with &lt;a href=&quot;start&quot;&gt;Try it now!&lt;/a&gt;, which introduces the essentials of Angular in the context of a ready-made basic online store app that you can examine and modify. This standalone tutorial takes advantage of the interactive &lt;a href=&quot;https://stackblitz.com/&quot;&gt;StackBlitz&lt;/a&gt; environment for online development. You don't need to set up your local environment until you're ready.</source>
          <target state="translated">Angular를 처음 사용 &lt;a href=&quot;start&quot;&gt;하는 경우 지금 사용해보기&lt;/a&gt; 로 시작하는 것이 좋습니다 ! , 검토하고 수정할 수있는 기성품 기본 온라인 스토어 앱의 맥락에서 Angular의 필수 사항을 소개합니다. 이 독립 실행 형 자습서는 온라인 개발을 위해 대화 형 &lt;a href=&quot;https://stackblitz.com/&quot;&gt;StackBlitz&lt;/a&gt; 환경을 활용 합니다. 준비가 될 때까지 로컬 환경을 설정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="429a085eabc08ae949cb917701bc53d58671e9e8" translate="yes" xml:space="preserve">
          <source>If you are not using the CLI, add your polyfill scripts directly to the host web page (&lt;code&gt;index.html&lt;/code&gt;).</source>
          <target state="translated">CLI를 사용하지 않는 경우 polyfill 스크립트를 호스트 웹 페이지 ( &lt;code&gt;index.html&lt;/code&gt; )에 직접 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="c294d47814c324598c601f2919036c6333fbcffe" translate="yes" xml:space="preserve">
          <source>If you are updating from &lt;strong&gt;one major version to another,&lt;/strong&gt; then we recommend that you &lt;strong&gt;don't skip major versions.&lt;/strong&gt; Follow the instructions to incrementally update to the next major version, testing and validating at each step. For example, if you want to update from version 6.x.x to version 8.x.x, we recommend that you update to the latest 7.x.x release first. After successfully updating to 7.x.x, you can then update to 8.x.x.</source>
          <target state="translated">&lt;strong&gt;하나의 메이저 버전에서 다른 메이저 버전으로&lt;/strong&gt; 업데이트하는 경우 &lt;strong&gt;메이저 버전을 &lt;/strong&gt;&lt;strong&gt;건너 뛰지 않는&lt;/strong&gt; 것이 좋습니다 &lt;strong&gt;. &lt;/strong&gt;지침에 따라 다음 주요 버전으로 점진적으로 업데이트하고 각 단계에서 테스트하고 유효성을 검사하십시오. 예를 들어 버전 6.xx에서 버전 8.xx로 업데이트하려면 먼저 최신 7.xx 릴리스로 업데이트하는 것이 좋습니다. 7.xx로 성공적으로 업데이트 한 후 8.xx로 업데이트 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5f232055071ca555fe05e8263d44377d3060b3a6" translate="yes" xml:space="preserve">
          <source>If you are updating within the &lt;strong&gt;same major version,&lt;/strong&gt; then you can skip any intermediate versions and update directly to the targeted version. For example, you can update directly from 7.0.0 to 7.2.11.</source>
          <target state="translated">&lt;strong&gt;동일한 주 버전&lt;/strong&gt; 내에서 업데이트하는 경우 중간 버전을 건너 뛰고 대상 버전으로 직접 업데이트 할 수 있습니다. 예를 들어 7.0.0에서 7.2.11로 직접 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7ada1beb7f1a3e0619c779fa66d5b774aef356f" translate="yes" xml:space="preserve">
          <source>If you are using AngularJS Material, you can install the type definitions via:</source>
          <target state="translated">AngularJS Material을 사용하는 경우 다음을 통해 유형 정의를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a19f97e563c43c87d702bca0ca63c624178ab00" translate="yes" xml:space="preserve">
          <source>If you are using one of the &lt;code&gt;@nguniversal/*-engine&lt;/code&gt; packages (such as &lt;code&gt;@nguniversal/express-engine&lt;/code&gt;), this is taken care for you automatically. You don't need to do anything to make relative URLs work on the server.</source>
          <target state="translated">&lt;code&gt;@nguniversal/*-engine&lt;/code&gt; 패키지 (예 : &lt;code&gt;@nguniversal/express-engine&lt;/code&gt; ) 중 하나를 사용하는 경우 자동으로 처리됩니다. 상대 URL이 서버에서 작동하도록하기 위해 아무것도 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6c7a81b8180cf07eda11450c5d99572d22e01ced" translate="yes" xml:space="preserve">
          <source>If you change the text, the extractor does &lt;em&gt;not&lt;/em&gt; change the ID. As a result, you don't have to take the extra step of updating the translation. The drawback of using custom IDs is that if you change the text, your translation may be out-of-sync with the newly changed source text.</source>
          <target state="translated">텍스트를 변경해도 추출기는 ID를 변경 하지 &lt;em&gt;않습니다&lt;/em&gt; . 결과적으로 번역을 업데이트하는 추가 단계를 수행 할 필요가 없습니다. 사용자 지정 ID 사용의 단점은 텍스트를 변경하면 번역이 새로 변경된 원본 텍스트와 동기화되지 않을 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="aa30f67180396da593aeadb4e26b8ee85e38af3d" translate="yes" xml:space="preserve">
          <source>If you choose to inject your pipe into a class, you must provide it in the &lt;code&gt;providers&lt;/code&gt; array of your &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">파이프를 클래스에 주입하기로 선택한 경우 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;providers&lt;/code&gt; 배열에 파이프를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f9a5cf2285ce2f7f1005a024b906069e5899271e" translate="yes" xml:space="preserve">
          <source>If you click the dashboard hero &quot;Magneta,&quot; the router opens a &quot;Hero Details&quot; view where you can change the hero's name.</source>
          <target state="translated">대시 보드 영웅 &quot;Magneta&quot;를 클릭하면 라우터에서 영웅 이름을 변경할 수있는 &quot;영웅 정보&quot;보기가 열립니다.</target>
        </trans-unit>
        <trans-unit id="8f68cc79c216b6b956bc04df5f4512033049017d" translate="yes" xml:space="preserve">
          <source>If you comment out the &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; decorator, Angular walks up the injector ancestor tree until it finds the logger at the &lt;code&gt;AppComponent&lt;/code&gt; level. The logger logic kicks in and the hero display updates with the &quot;!!!&quot; marker to indicate that the logger was found.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; 데코레이터 를 주석 처리하면 Angular는 &lt;code&gt;AppComponent&lt;/code&gt; 레벨 에서 로거를 찾을 때까지 인젝터 조상 트리를 위로 올라 갑니다 . 로거 로직이 시작되고 영웅 디스플레이가 &quot;!!!&quot;로 업데이트됩니다. 로거가 발견되었음을 나타내는 마커.</target>
        </trans-unit>
        <trans-unit id="655f88a25378a8e0bba92c48a89431e31a18d04a" translate="yes" xml:space="preserve">
          <source>If you configure an app-wide provider in the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; of &lt;code&gt;AppModule&lt;/code&gt;, it overrides one configured for &lt;code&gt;root&lt;/code&gt; in the &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; metadata. You can do this to configure a non-default provider of a service that is shared with multiple apps.</source>
          <target state="translated">당신이에서 애플리케이션 전체의 공급자를 구성하는 경우 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; 의 &lt;code&gt;AppModule&lt;/code&gt; , 그것은 하나가 구성 무시 &lt;code&gt;root&lt;/code&gt; 에 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; 메타 데이터. 이렇게하면 여러 앱과 공유되는 기본이 아닌 서비스 공급자를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53b5c56d5542295c8b28d30b021bb969efead9f2" translate="yes" xml:space="preserve">
          <source>If you create a new version of your library that introduces potential breaking changes, you can provide an &lt;em&gt;update schematic&lt;/em&gt; to enable the &lt;code&gt;ng &lt;a href=&quot;../api/forms/ngmodel#update&quot;&gt;update&lt;/a&gt;&lt;/code&gt; command to automatically resolve any such changes in the project being updated.</source>
          <target state="translated">잠재적 인 주요 변경 사항을 소개하는 새 버전의 라이브러리를 작성하는 경우 &lt;code&gt;ng &lt;a href=&quot;../api/forms/ngmodel#update&quot;&gt;update&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/forms/ngmodel#update&quot;&gt;update&lt;/a&gt; 명령이 업데이트중인 프로젝트에서 이러한 변경 사항을 자동으로 해결할 수 있도록 &lt;em&gt;업데이트 회로도&lt;/em&gt; 를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36bf0876067bb7a664673feee8ac35025366695a" translate="yes" xml:space="preserve">
          <source>If you create a new version of your library that introduces potential breaking changes, you can provide an &lt;em&gt;update schematic&lt;/em&gt; to enable the &lt;code&gt;ng update&lt;/code&gt; command to automatically resolve any such changes in the project being updated.</source>
          <target state="translated">잠재적 인 주요 변경 사항을 도입하는 새 버전의 라이브러리를 만드는 경우 &lt;code&gt;ng update&lt;/code&gt; 명령을 사용하여 업데이트 중인 프로젝트에서 이러한 변경 사항을 자동으로 해결할 수 있도록 &lt;em&gt;업데이트 회로도&lt;/em&gt; 를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f94f6f1acbb8efed36c81082ca18afd759387bb6" translate="yes" xml:space="preserve">
          <source>If you create an application using Angular's strict mode, you will also have an additional &lt;code&gt;package.json&lt;/code&gt; file in the &lt;code&gt;src/app&lt;/code&gt; directory. For more information, see &lt;a href=&quot;strict-mode&quot;&gt;Strict mode&lt;/a&gt;.</source>
          <target state="translated">Angular의 엄격 모드를 사용하여 애플리케이션을 만드는 경우 &lt;code&gt;src/app&lt;/code&gt; 디렉터리 에 추가 &lt;code&gt;package.json&lt;/code&gt; 파일이 있습니다 . 자세한 내용은 &lt;a href=&quot;strict-mode&quot;&gt;Strict 모드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6a642206c4a5d0b4ac72237fc880c34a1dcc940" translate="yes" xml:space="preserve">
          <source>If you create project with `Angular/CLI`, it is already imported in `src/test.ts`.</source>
          <target state="translated">`Angular / CLI`로 프로젝트를 만들면 이미`src / test.ts`로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="00d9ca9f25be57d4c4bdc4c5699c96a4ab982c59" translate="yes" xml:space="preserve">
          <source>If you declare the real components, you'll also have to declare &lt;em&gt;their&lt;/em&gt; nested components and provide for &lt;em&gt;all&lt;/em&gt; services injected in &lt;em&gt;any&lt;/em&gt; component in the tree.</source>
          <target state="translated">당신이 실제 구성 요소를 선언하면, 당신은 또한 선언해야합니다 &lt;em&gt;자신의&lt;/em&gt; 중첩 된 구성 요소 및 제공 &lt;em&gt;하는 모든&lt;/em&gt; 주입 서비스 &lt;em&gt;어떤&lt;/em&gt; 트리의 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="c8c8eecaa76ff1b26ee4f0a3dbfa27a318e146eb" translate="yes" xml:space="preserve">
          <source>If you declare the variable on a component, the variable refers to the component instance.</source>
          <target state="translated">구성 요소에서 변수를 선언하면 변수는 구성 요소 인스턴스를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="3e2e7ebc41078b5a92d731d4eb706af50528ef2b" translate="yes" xml:space="preserve">
          <source>If you declare the variable on a standard HTML tag, the variable refers to the element.</source>
          <target state="translated">표준 HTML 태그에서 변수를 선언하면 변수는 요소를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="537074c689f36a996573ec7830a8b959e5b1d799" translate="yes" xml:space="preserve">
          <source>If you declare the variable on an &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; element, the variable refers to a &lt;code&gt;&lt;a href=&quot;../api/core/templateref&quot;&gt;TemplateRef&lt;/a&gt;&lt;/code&gt; instance, which represents the template. For more information on &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt;, see the &lt;a href=&quot;structural-directives#the-ng-template&quot;&gt;ng-template&lt;/a&gt; section of &lt;a href=&quot;structural-directives&quot;&gt;Structural directives&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 요소 에서 변수를 선언하는 경우 변수는 &lt;code&gt;&lt;a href=&quot;../api/core/templateref&quot;&gt;TemplateRef&lt;/a&gt;&lt;/code&gt; 을 나타내는 TemplateRef 인스턴스를 참조합니다 . &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 에 대한 자세한 내용 은 &lt;a href=&quot;structural-directives&quot;&gt;Structural directives&lt;/a&gt; 의 &lt;a href=&quot;structural-directives#the-ng-template&quot;&gt;ng-template&lt;/a&gt; 섹션을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="27f3473cbc8bd4910ed874d931585deebed2a0eb" translate="yes" xml:space="preserve">
          <source>If you delete the hero name, the form displays a validation error in an attention-grabbing style:</source>
          <target state="translated">영웅 이름을 삭제하면 양식에주의를 끄는 스타일로 유효성 검사 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="be89fadd89408e928a800bd50abe498bb92298a3" translate="yes" xml:space="preserve">
          <source>If you develop angular locally with &lt;code&gt;ng serve&lt;/code&gt;, a &lt;code&gt;websocket&lt;/code&gt; connection is set up automatically between browser and local dev server, so when your code changes, the browser can automatically refresh.</source>
          <target state="translated">&lt;code&gt;ng serve&lt;/code&gt; 를 사용하여 로컬에서 각도를 개발하면 브라우저와 로컬 개발자 서버간에 웹 &lt;code&gt;websocket&lt;/code&gt; 연결이 자동으로 설정되므로 코드가 변경되면 브라우저가 자동으로 새로 고쳐질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76ffe5939fdb8b0e744ee8649f7d7239d2f7e34f" translate="yes" xml:space="preserve">
          <source>If you disable Ivy and the project uses internationalization, you can also remove the &lt;code&gt;@angular/localize&lt;/code&gt; runtime component from the project's polyfills file located be default at &lt;code&gt;src/polyfills.ts&lt;/code&gt;.</source>
          <target state="translated">Ivy를 비활성화하고 프로젝트에서 국제화를 사용하는 경우 기본 위치 인 &lt;code&gt;src/polyfills.ts&lt;/code&gt; 에있는 프로젝트의 polyfills 파일에서 &lt;code&gt;@angular/localize&lt;/code&gt; 런타임 구성 요소를 제거 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b13b1ae3a623247c92184a19c0620a0d0b0dd8f0" translate="yes" xml:space="preserve">
          <source>If you disable Ivy, you might also want to reconsider whether to make AOT compilation the default for your application development, as described &lt;a href=&quot;ivy#aot-and-ivy&quot;&gt;above&lt;/a&gt;.</source>
          <target state="translated">Ivy를 비활성화하는 경우 &lt;a href=&quot;ivy#aot-and-ivy&quot;&gt;위에서&lt;/a&gt; 설명한대로 AOT 컴파일을 애플리케이션 개발의 기본값으로 설정할지 여부를 다시 고려할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b7663d2e6e6cb92add7a2eeb86377cd1a6f1568" translate="yes" xml:space="preserve">
          <source>If you do combine a component and service in the same file, it is important to define the service first, and then the component. If you define the component before the service, you get a run-time null reference error.</source>
          <target state="translated">동일한 파일에서 컴포넌트와 서비스를 결합하는 경우 먼저 서비스를 정의한 다음 컴포넌트를 정의해야합니다. 서비스 전에 구성 요소를 정의하면 런타임 널 참조 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="70b72ee7901f1dbf6fe44eed029ec0919535d96c" translate="yes" xml:space="preserve">
          <source>If you do import &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt; into a lazy loaded feature module, Angular returns an error telling you to use &lt;code&gt;&lt;a href=&quot;../api/common/commonmodule&quot;&gt;CommonModule&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;../api/common/commonmodule&quot;&gt;CommonModule&lt;/a&gt;&lt;/code&gt; 로드 된 기능 모듈로 가져 오면 Angular는 대신 CommonModule 을 사용 하라는 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d0a50f188d24b28b62b5d94fe7caa482234cb014" translate="yes" xml:space="preserve">
          <source>If you do need to populate initial values into your form, using a one-way binding for &lt;code&gt;&lt;a href=&quot;ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; tends to be sufficient as long as you use the exported form's value rather than the domain model's value on submit.</source>
          <target state="translated">초기 값을 양식에 &lt;code&gt;&lt;a href=&quot;ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 하는 경우 제출시 도메인 모델의 값 대신 내 보낸 양식의 값을 사용하는 한 ngModel에 단방향 바인딩을 사용하면 충분합니다.</target>
        </trans-unit>
        <trans-unit id="8172efb07c1070141d767274a73b38bf7814dfc1" translate="yes" xml:space="preserve">
          <source>If you do, be sure to set the &lt;code&gt;id&lt;/code&gt; attribute - not the &lt;code&gt;name&lt;/code&gt; attribute! The docs generator will not convert the &lt;code&gt;name&lt;/code&gt; to the proper link URL.</source>
          <target state="translated">그렇다면 , &lt;code&gt;name&lt;/code&gt; 속성이 아닌 &lt;code&gt;id&lt;/code&gt; 속성 을 설정하십시오 ! 문서 생성기는 &lt;code&gt;name&lt;/code&gt; 을 적절한 링크 URL 로 변환하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="51cf49223fe57ab0167336d62a454c5e60d9cfb3" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t already have an app, you can follow the steps below to create one with the CLI. If you already have an app, skip to &lt;a href=&quot;lazy-loading-ngmodules#config-routes&quot;&gt;Configure the routes&lt;/a&gt;. Enter the following command where &lt;code&gt;customer-app&lt;/code&gt; is the name of your app:</source>
          <target state="translated">아직 앱이없는 경우 아래 단계에 따라 CLI로 만들 수 있습니다. 이미 앱이있는 경우 &lt;a href=&quot;lazy-loading-ngmodules#config-routes&quot;&gt;경로 구성으로&lt;/a&gt; 건너 뜁니다 . 다음 명령을 입력합니다. 여기서 &lt;code&gt;customer-app&lt;/code&gt; 은 앱 의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0690d6c4fb6fbd319b60dd809c871d4c4ae2c535" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t already have an app, you can follow the steps below to create one with the CLI. If you do already have an app, skip to &lt;a href=&quot;lazy-loading-ngmodules#config-routes&quot;&gt;Configure the routes&lt;/a&gt;. Enter the following command where &lt;code&gt;customer-app&lt;/code&gt; is the name of your app:</source>
          <target state="translated">아직 앱이없는 경우 아래 단계에 따라 CLI로 앱을 만들 수 있습니다. 이미 앱이있는 &lt;a href=&quot;lazy-loading-ngmodules#config-routes&quot;&gt;경우 경로 구성으로&lt;/a&gt; 건너 뜁니다 . &lt;code&gt;customer-app&lt;/code&gt; 가 앱 이름 인 다음 명령을 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ca2994953a96781a0944879ae63e39a49e4701b" translate="yes" xml:space="preserve">
          <source>If you don't add the interface for the script-defined extension, your IDE shows an error:</source>
          <target state="translated">스크립트 정의 확장에 대한 인터페이스를 추가하지 않으면 IDE에 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="459d0b6f0027ff890051041d8277b8b47d8f99dc" translate="yes" xml:space="preserve">
          <source>If you don't have it, install &lt;strong&gt;&lt;a href=&quot;https://www.visualstudio.com/en-us/news/releasenotes/vs2015-update3-vs&quot;&gt;Visual Studio 2015 Update 3&lt;/a&gt;&lt;/strong&gt;. Or use &lt;code&gt;Tools | Extensions and Updates&lt;/code&gt; to update to Update 3 directly from Visual Studio 2015.</source>
          <target state="translated">없는 경우 &lt;strong&gt;&lt;a href=&quot;https://www.visualstudio.com/en-us/news/releasenotes/vs2015-update3-vs&quot;&gt;Visual Studio 2015 업데이트 3을&lt;/a&gt;&lt;/strong&gt; 설치하십시오 . 또는 &lt;code&gt;Tools | Extensions and Updates&lt;/code&gt; Visual Studio 2015에서 직접 업데이트 3으로 업데이트 할 수있는 확장 및 업데이트</target>
        </trans-unit>
        <trans-unit id="48ed7036b0a82e03171cab5edf597919553bb1d3" translate="yes" xml:space="preserve">
          <source>If you don't provide a unit when specifying dimension, Angular assumes a default unit of pixels, or px. Expressing 50 pixels as &lt;code&gt;50&lt;/code&gt; is the same as saying &lt;code&gt;'50px'&lt;/code&gt;.</source>
          <target state="translated">치수를 지정할 때 단위를 제공하지 않으면 Angular는 기본 단위 인 픽셀 또는 px를 가정합니다. 50 픽셀을 &lt;code&gt;50&lt;/code&gt; 으로 표현하는 것은 &lt;code&gt;'50px'&lt;/code&gt; 를 말하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d1b561dc3312390e8ea84f90f931f5ed36b0f473" translate="yes" xml:space="preserve">
          <source>If you don't use the CLI, you have two options:</source>
          <target state="translated">CLI를 사용하지 않으면 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bc2f915897fc1447035a5647974d463c55c174d" translate="yes" xml:space="preserve">
          <source>If you find that changes to your library are not reflected in your app, your app is probably using an old build of the library.</source>
          <target state="translated">라이브러리의 변경 사항이 앱에 반영되지 않는 경우 앱에서 오래된 라이브러리 빌드를 사용하고있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a3bdf9252cbd8653710b518a7e90d39fa7fc1cf" translate="yes" xml:space="preserve">
          <source>If you find that you need to solve the same problem in more than one app (or want to share your solution with other developers), you have a candidate for a library. A simple example might be a button that sends users to your company website, that would be included in all apps that your company builds.</source>
          <target state="translated">둘 이상의 앱에서 동일한 문제를 해결해야하는 경우 (또는 다른 개발자와 솔루션을 공유하려는 경우) 라이브러리 후보가 있습니다. 간단한 예로 사용자를 회사 웹 사이트로 보내는 버튼이 있습니다.이 버튼은 회사에서 빌드하는 모든 앱에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3a8aa489382d8d4aec77f8acd02f621cf2ccce35" translate="yes" xml:space="preserve">
          <source>If you find your application becomes unresponsive while processing data, using Web Workers can help.</source>
          <target state="translated">데이터를 처리하는 동안 응용 프로그램이 응답하지 않는 경우 웹 작업자를 사용하면 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0433bd29313c70f90dc0cba136f09aa567988ee1" translate="yes" xml:space="preserve">
          <source>If you get a template parse error when trying to use inputs or outputs, but you know that the properties do indeed exist, double check that your properties are annotated with &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; / &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; or that you've declared them in an &lt;code&gt;inputs&lt;/code&gt;/&lt;code&gt;outputs&lt;/code&gt; array:</source>
          <target state="translated">입력 또는 출력을 사용하려고 할 때 템플릿 구문 분석 오류가 발생하지만 속성이 실제로 존재한다는 것을 알고 있다면 속성에 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; / &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; 으로 주석이 달렸 는지 또는 선언했는지 확인하십시오. &lt;code&gt;inputs&lt;/code&gt; / &lt;code&gt;outputs&lt;/code&gt; 배열 :</target>
        </trans-unit>
        <trans-unit id="495b88195246c2e62adc198264cd5c3fefd8628b" translate="yes" xml:space="preserve">
          <source>If you go directly to the &lt;a href=&quot;https://stackblitz.com/&quot;&gt;StackBlitz online development environment&lt;/a&gt; and choose to &lt;a href=&quot;https://stackblitz.com/fork/angular&quot;&gt;start a new Angular workspace&lt;/a&gt;, you get a generic stub application, rather than this &lt;a href=&quot;https://angular.io/start#new-project&quot;&gt;illustrative sample&lt;/a&gt;. Once you have been introduced to the basic concepts here, this can be helpful for working interactively while you are learning Angular.</source>
          <target state="translated">&lt;a href=&quot;https://stackblitz.com/&quot;&gt;StackBlitz 온라인 개발 환경으로&lt;/a&gt; 직접 이동 &lt;a href=&quot;https://stackblitz.com/fork/angular&quot;&gt;하여 새 Angular 작업 영역&lt;/a&gt; 을 시작 하도록 선택하면 이 &lt;a href=&quot;https://angular.io/start#new-project&quot;&gt;예시 샘플&lt;/a&gt; 대신 일반 스텁 애플리케이션이 제공 됩니다. 여기에서 기본 개념을 소개했다면 Angular를 배우는 동안 대화식으로 작업하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf717436302dddc92f72725596accc08d3335c31" translate="yes" xml:space="preserve">
          <source>If you had an expression that changed the value of something else that you were binding to, that change of value would be a side effect. Angular might or might not display the changed value. If Angular does detect the change, it throws an error.</source>
          <target state="translated">당신이 묶고 있던 다른 것의 가치를 바꾸는 표현이 있다면, 그 가치의 변화는 부작용이 될 것입니다. Angular는 변경된 값을 표시하거나 표시하지 않을 수 있습니다. Angular가 변경 사항을 감지하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="574c59f8b77bf5e82b23eb72c796ed67b3d2fb05" translate="yes" xml:space="preserve">
          <source>If you had any AngularJS services in the project, those would also be a good candidate for converting to classes, since like controllers, they're also constructor functions. But you only have the &lt;code&gt;Phone&lt;/code&gt; factory in this project, and that's a bit special since it's an &lt;code&gt;ngResource&lt;/code&gt; factory. So you won't be doing anything to it in the preparation stage. You'll instead turn it directly into an Angular service.</source>
          <target state="translated">프로젝트에 AngularJS 서비스가 있다면 컨트롤러와 마찬가지로 클래스로 변환하기에 좋은 후보가 될 것입니다. 컨트롤러와 마찬가지로 생성자 함수이기도합니다. 그러나이 프로젝트 에는 &lt;code&gt;Phone&lt;/code&gt; 팩토리 만 있으며 &lt;code&gt;ngResource&lt;/code&gt; 팩토리 이므로 약간 특별합니다 . 따라서 준비 단계에서는 아무것도하지 않습니다. 대신 Angular 서비스로 직접 전환합니다.</target>
        </trans-unit>
        <trans-unit id="1fed1253af78f190067c1aae4775c40631199cc8" translate="yes" xml:space="preserve">
          <source>If you have a content-rich app, such as the Angular app that presents this documentation, custom elements let you give your content providers sophisticated Angular functionality without requiring knowledge of Angular. For example, an Angular guide like this one is added directly to the DOM by the Angular navigation tools, but can include special elements like &lt;code&gt;&amp;lt;code-snippet&amp;gt;&lt;/code&gt; that perform complex operations. All you need to tell your content provider is the syntax of your custom element. They don't need to know anything about Angular, or anything about your component's data structures or implementation.</source>
          <target state="translated">이 설명서를 제공하는 Angular 앱과 같이 컨텐츠가 풍부한 앱이있는 경우 사용자 정의 요소를 사용하면 컨텐츠 제공자에게 Angular에 대한 지식 없이도 정교한 Angular 기능을 제공 할 수 있습니다. 예를 들어 이와 같은 Angular 안내서는 Angular 탐색 도구를 통해 DOM에 직접 추가되지만 복잡한 작업을 수행하는 &lt;code&gt;&amp;lt;code-snippet&amp;gt;&lt;/code&gt; 과 같은 특수 요소를 포함 할 수 있습니다 . 콘텐츠 제공 업체에 알리기 위해 필요한 것은 사용자 지정 요소의 구문입니다. Angular 또는 구성 요소의 데이터 구조 또는 구현에 대해 알 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f19944a29f8b906f6f0c8e4343ee837260ae1269" translate="yes" xml:space="preserve">
          <source>If you have a floating image inside an alert, callout, or a subsection, it is a good idea to apply the &lt;code&gt;clear-fix&lt;/code&gt; class to the &lt;code&gt;div&lt;/code&gt; to ensure that the image doesn't overflow its container. For example:</source>
          <target state="translated">경고, 설명 선 또는 하위 섹션 내에 떠 다니는 이미지가있는 경우 이미지가 컨테이너에 넘치지 않도록 &lt;code&gt;clear-fix&lt;/code&gt; 클래스를 &lt;code&gt;div&lt;/code&gt; 에 적용하는 것이 좋습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6397857065b35ce89a9f398af1b26fb9b1516f71" translate="yes" xml:space="preserve">
          <source>If you have developed functionality that is suitable for reuse, you can create your own libraries. These libraries can be used locally in your workspace, or you can publish them as &lt;a href=&quot;npm-packages&quot;&gt;npm packages&lt;/a&gt; to share with other projects or other Angular developers. These packages can be published to the npm registry, a private npm Enterprise registry, or a private package management system that supports npm packages. See &lt;a href=&quot;creating-libraries&quot;&gt;Creating Libraries&lt;/a&gt;.</source>
          <target state="translated">재사용에 적합한 기능을 개발 한 경우 자체 라이브러리를 작성할 수 있습니다. 이 라이브러리는 작업 공간에서 로컬로 사용하거나 &lt;a href=&quot;npm-packages&quot;&gt;npm 패키지&lt;/a&gt; 로 게시 하여 다른 프로젝트 또는 다른 Angular 개발자와 공유 할 수 있습니다 . 이러한 패키지는 npm 레지스트리, 개인 npm Enterprise 레지스트리 또는 npm 패키지를 지원하는 개인 패키지 관리 시스템에 게시 할 수 있습니다. &lt;a href=&quot;creating-libraries&quot;&gt;라이브러리 작성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b1d5fced1eafeb19e09e69c636133d8617598ad9" translate="yes" xml:space="preserve">
          <source>If you have more than two paragraphs, consider creating a new page or making it part of the main content.</source>
          <target state="translated">단락이 두 개 이상인 경우 새 페이지를 만들거나 주 내용의 일부로 만드는 것을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ce43e9168848245cd1d0950e4a6be2522d8f2b68" translate="yes" xml:space="preserve">
          <source>If you have registered a provider for the same DI token at different levels, the first one Angular encounters is the one it uses to resolve the dependency. If, for example, a provider is registered locally in the component that needs a service, Angular doesn't look for another provider of the same service.</source>
          <target state="translated">다른 레벨에서 동일한 DI 토큰에 대해 제공자를 등록한 경우 Angular에서 가장 먼저 발생하는 것은 종속성을 해결하는 데 사용됩니다. 예를 들어 서비스가 필요한 구성 요소에 공급자가 로컬로 등록되어 있으면 Angular는 동일한 서비스의 다른 공급자를 찾지 않습니다.</target>
        </trans-unit>
        <trans-unit id="244fbbf115dfe5706448ffdb4e279457395f14e1" translate="yes" xml:space="preserve">
          <source>If you haven't already, remove all references to the &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;app.module.ts&lt;/code&gt;, as well as any &lt;a href=&quot;upgrade#making-angularjs-dependencies-injectable-to-angular&quot;&gt;factory provider&lt;/a&gt; for AngularJS services, and the &lt;code&gt;app/ajs-upgraded-providers.ts&lt;/code&gt; file.</source>
          <target state="translated">당신이 이미하지 않은 경우에 대한 모든 참조 제거 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 을 에서 &lt;code&gt;app.module.ts&lt;/code&gt; ,뿐만 아니라 &lt;a href=&quot;upgrade#making-angularjs-dependencies-injectable-to-angular&quot;&gt;공장 제공&lt;/a&gt; AngularJS와 서비스 및 &lt;code&gt;app/ajs-upgraded-providers.ts&lt;/code&gt; 파일입니다.</target>
        </trans-unit>
        <trans-unit id="4963feaec493218114281088952fb43b33cce3a9" translate="yes" xml:space="preserve">
          <source>If you haven't created custom validators before, start by reviewing the &lt;a href=&quot;form-validation#custom-validators&quot;&gt;custom validators section&lt;/a&gt;.</source>
          <target state="translated">전에 맞춤 검사기를 만들지 않았다면 먼저 &lt;a href=&quot;form-validation#custom-validators&quot;&gt;맞춤 검사기 섹션&lt;/a&gt; 을 검토 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c789fcd7125f7745fca41c10481fb3d352702dd" translate="yes" xml:space="preserve">
          <source>If you intend to have multiple projects in a workspace, you can skip the initial application generation when you create the workspace, and give the workspace a unique name. The following command creates a workspace with all of the workspace-wide configuration files, but no root-level application.</source>
          <target state="translated">작업 공간에 여러 프로젝트가있는 경우 작업 공간을 작성할 때 초기 애플리케이션 생성을 건너 뛰고 작업 공간에 고유 한 이름을 지정할 수 있습니다. 다음 명령은 모든 작업 공간 전체 구성 파일을 사용하지만 루트 레벨 응용 프로그램은없는 작업 공간을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="6ed99352b2d6234cc28fecffcc038922fe7627c2" translate="yes" xml:space="preserve">
          <source>If you look at the &lt;code&gt;http-server&lt;/code&gt; logs, you can see the service worker requesting &lt;code&gt;/ngsw.json&lt;/code&gt;. This is how the service worker checks for updates.</source>
          <target state="translated">&lt;code&gt;http-server&lt;/code&gt; logs 를 보면 서비스 작업자가 &lt;code&gt;/ngsw.json&lt;/code&gt; 을 요청하는 것을 볼 수 있습니다 . 서비스 직원이 업데이트를 확인하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="09c234e78616a8f1ab6267a5b6637fade99d397d" translate="yes" xml:space="preserve">
          <source>If you look at the Network tab, you can verify that the service worker is active.</source>
          <target state="translated">네트워크 탭을 보면 서비스 워커가 활성화되어 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c5701cee3aaff758a219be513eeb916029ac2eb" translate="yes" xml:space="preserve">
          <source>If you look at the template for the &lt;code&gt;name&lt;/code&gt; input again, it is fairly similar to the template-driven example.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 입력 에 대한 템플릿을 다시 보면 템플릿 기반 예제와 상당히 유사합니다.</target>
        </trans-unit>
        <trans-unit id="73a79269220380ef80051827e018d68abab94031" translate="yes" xml:space="preserve">
          <source>If you look at the template for the name input again, it is fairly similar to the template-driven example.</source>
          <target state="translated">이름 입력을위한 템플릿을 다시 보면 템플릿 기반 예제와 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="be1adaa34051feae1f602d2f495e70b203a2addd" translate="yes" xml:space="preserve">
          <source>If you look in the Cache Storage viewer, the cache is frequently out of date. Right click the Cache Storage title and refresh the caches.</source>
          <target state="translated">캐시 스토리지 뷰어를 보면 캐시가 종종 오래된 것입니다. 캐시 스토리지 제목을 마우스 오른쪽 단추로 클릭하고 캐시를 새로 고치십시오.</target>
        </trans-unit>
        <trans-unit id="e240ddeb830d887bc58d8e84732b2ed378e0c98b" translate="yes" xml:space="preserve">
          <source>If you mean to lazy-load a module, be careful not import it in a file that's eagerly loaded when the app starts (such as the root &lt;code&gt;AppModule&lt;/code&gt;). If you do that, the module will be loaded immediately.</source>
          <target state="translated">모듈을 느리게로드하려는 경우 앱이 시작될 때 열심히로드 된 파일 (예 : 루트 &lt;code&gt;AppModule&lt;/code&gt; ) 로 모듈을 가져 오지 않도록주의하십시오 . 그렇게하면 모듈이 즉시로드됩니다.</target>
        </trans-unit>
        <trans-unit id="7a3230dc41e776853084f72cc170bbaf7e500a78" translate="yes" xml:space="preserve">
          <source>If you mean to lazy-load a module, be careful not to import it in a file that's eagerly loaded when the app starts (such as the root &lt;code&gt;AppModule&lt;/code&gt;). If you do that, the module will be loaded immediately.</source>
          <target state="translated">모듈을 지연로드하려는 경우 앱이 시작될 때 열심히로드되는 파일 (예 : 루트 &lt;code&gt;AppModule&lt;/code&gt; ) 로 모듈을 가져 오지 않도록주의하십시오 . 그렇게하면 모듈이 즉시로드됩니다.</target>
        </trans-unit>
        <trans-unit id="16773d19362678c6fc8bb45ee7f72f374bcbc644" translate="yes" xml:space="preserve">
          <source>If you must alter a request, clone it first and modify the clone before passing it to &lt;code&gt;next.handle()&lt;/code&gt;. You can clone and modify the request in a single step, as shown in the following example.</source>
          <target state="translated">요청을 변경해야하는 경우 먼저 복제하고 &lt;code&gt;next.handle()&lt;/code&gt; 전달하기 전에 복제본을 수정하십시오 . 다음 예와 같이 단일 단계로 요청을 복제하고 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd2ad358ff3a296ca464afc454eed23c1c38e476" translate="yes" xml:space="preserve">
          <source>If you must guard against this kind of &quot;provider corruption&quot;, &lt;em&gt;don't rely on a launch-time module's &lt;code&gt;providers&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">이런 종류의 &quot;제공자 손상&quot;으로부터 보호해야하는 경우 &lt;em&gt;시작 시간 모듈의 &lt;code&gt;providers&lt;/code&gt; 에 의존하지 마십시오 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3304f68a08d3080d984d8dc5da4dcc423149911b" translate="yes" xml:space="preserve">
          <source>If you must inject an instance of an ambient type, you can finesse the problem in four steps:</source>
          <target state="translated">앰비언트 유형의 인스턴스를 주입해야하는 경우 다음 네 단계로 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7e18b086d212d4c106b0c8fad4ba48df8021509" translate="yes" xml:space="preserve">
          <source>If you must load the module eagerly, when the application starts, &lt;em&gt;provide the service in a component instead.&lt;/em&gt;</source>
          <target state="translated">모듈을 열성적으로로드해야하는 경우 응용 프로그램이 시작될 때 &lt;em&gt;구성 요소로 서비스를 제공하십시오.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="54606fa4b1a1f3287874eefffbe1a9f2ddc23e2d" translate="yes" xml:space="preserve">
          <source>If you must modify the request body, follow these steps.</source>
          <target state="translated">요청 본문을 수정해야하는 경우 다음 단계를 따르십시오.</target>
        </trans-unit>
        <trans-unit id="e8ac82fe8517410b1d40420bd85029d758cdda8a" translate="yes" xml:space="preserve">
          <source>If you must mutate the request body, copy it first, change the copy, &lt;code&gt;clone()&lt;/code&gt; the request, and set the clone's body with the new body, as in the following example.</source>
          <target state="translated">요청 본문을 변경해야하는 경우 다음 예제와 같이 먼저 요청 본문을 복사하고 사본을 변경 하고 요청을 &lt;code&gt;clone()&lt;/code&gt; 한 다음 복제본을 새 본문으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="5deab0538bd8714b4af9c382cd8cc938823e841f" translate="yes" xml:space="preserve">
          <source>If you must read a target element property or call one of its methods, see the API reference for &lt;a href=&quot;../api/core/viewchild&quot;&gt;ViewChild&lt;/a&gt; and &lt;a href=&quot;../api/core/contentchild&quot;&gt;ContentChild&lt;/a&gt;.</source>
          <target state="translated">대상 요소 특성을 읽거나 해당 메소드 중 하나를 호출 &lt;a href=&quot;../api/core/viewchild&quot;&gt;해야하는&lt;/a&gt; 경우 ViewChild 및 &lt;a href=&quot;../api/core/contentchild&quot;&gt;ContentChild&lt;/a&gt; 의 API 참조를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c8d2326e60e33ffa20c7c4182475e5223e4a351" translate="yes" xml:space="preserve">
          <source>If you need an &lt;em&gt;optional&lt;/em&gt; polyfill, you must install its npm package, then uncomment or create the corresponding import statement in the &lt;code&gt;src/polyfills.ts&lt;/code&gt; configuration file.</source>
          <target state="translated">&lt;em&gt;선택적&lt;/em&gt; polyfill 이 필요한 경우 npm 패키지를 설치 한 다음 &lt;code&gt;src/polyfills.ts&lt;/code&gt; 구성 파일 에서 해당 가져 오기 명령문의 주석 처리를 제거하거나 작성해야 합니다.</target>
        </trans-unit>
        <trans-unit id="9bc172afb1ec77e9f642e2976433da99d4796934" translate="yes" xml:space="preserve">
          <source>If you need the previous behavior then set it by creating a &lt;code&gt;&lt;a href=&quot;../core/default_currency_code&quot;&gt;DEFAULT_CURRENCY_CODE&lt;/a&gt;&lt;/code&gt; provider in your application &lt;code&gt;&lt;a href=&quot;../core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">이전 동작이 필요한 경우 애플리케이션 &lt;code&gt;&lt;a href=&quot;../core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../core/default_currency_code&quot;&gt;DEFAULT_CURRENCY_CODE&lt;/a&gt;&lt;/code&gt; 공급자를 만들어 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="beb15ada72d6e27c5b0260646179c4bf9acb237d" translate="yes" xml:space="preserve">
          <source>If you need the previous behavior then set it by creating a &lt;code&gt;&lt;a href=&quot;default_currency_code&quot;&gt;DEFAULT_CURRENCY_CODE&lt;/a&gt;&lt;/code&gt; provider in your application &lt;code&gt;&lt;a href=&quot;ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">이전 동작이 필요한 경우 애플리케이션 &lt;code&gt;&lt;a href=&quot;ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;default_currency_code&quot;&gt;DEFAULT_CURRENCY_CODE&lt;/a&gt;&lt;/code&gt; 공급자를 만들어 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="2e3109a970d92c304a276ac634765200cb2660a8" translate="yes" xml:space="preserve">
          <source>If you need to access a backend that is not on &lt;code&gt;localhost&lt;/code&gt;, set the &lt;code&gt;changeOrigin&lt;/code&gt; option as well. For example:</source>
          <target state="translated">&lt;code&gt;localhost&lt;/code&gt; 에 없는 백엔드에 액세스해야하는 경우 &lt;code&gt;changeOrigin&lt;/code&gt; 옵션도 설정하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7385333e0134701bca8a7465de13704c98317745" translate="yes" xml:space="preserve">
          <source>If you need to avoid randomly generated value to be used as an application id, you can provide a custom value via a DI provider  configuring the root &lt;a href=&quot;injector&quot;&gt;&lt;code&gt;Injector&lt;/code&gt;&lt;/a&gt; using this token.</source>
          <target state="translated">임의로 생성 된 값을 애플리케이션 ID로 사용하지 않으려면 이 토큰을 사용하여 루트 &lt;a href=&quot;injector&quot;&gt; &lt;code&gt;Injector&lt;/code&gt; &lt;/a&gt; 를 구성하는 DI 제공자를 통해 사용자 정의 값을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f78d5b2a7cf462a861acdc7e39dc21266ddf374" translate="yes" xml:space="preserve">
          <source>If you need to convert user input into a trusted value, use a controller method. The following template allows users to enter a YouTube video ID and load the corresponding video in an &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;. The &lt;code&gt;&amp;lt;iframe src&amp;gt;&lt;/code&gt; attribute is a resource URL security context, because an untrusted source can, for example, smuggle in file downloads that unsuspecting users could execute. So call a method on the controller to construct a trusted video URL, which causes Angular to allow binding into &lt;code&gt;&amp;lt;iframe src&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">사용자 입력을 신뢰할 수있는 값으로 변환해야하는 경우 컨트롤러 방법을 사용하십시오. 다음 템플릿을 사용하면 사용자가 YouTube 비디오 ID를 입력하고 해당 비디오를 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 에로드 할 수 있습니다. &lt;code&gt;&amp;lt;iframe src&amp;gt;&lt;/code&gt; 신뢰할 수없는 소스, 예를 들어, 순진한 사용자가 실행할 수 있습니다 파일 다운로드에 몰래 수 있기 때문에 속성은 리소스 URL의 보안 컨텍스트입니다. 따라서 컨트롤러에서 메소드를 호출하여 신뢰할 수있는 비디오 URL을 구성하면 Angular가 &lt;code&gt;&amp;lt;iframe src&amp;gt;&lt;/code&gt; 에 바인딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="29f9ab2a5ca9fca7da3c0139902ffd0aad1ea2c6" translate="yes" xml:space="preserve">
          <source>If you need to display alternate text depending on the value of a variable, you need to translate all of the alternates.</source>
          <target state="translated">변수 값에 따라 대체 텍스트를 표시해야하는 경우 모든 대체 텍스트를 번역해야합니다.</target>
        </trans-unit>
        <trans-unit id="5583bc38486dde54355c7bd2036697b8c05b7dab" translate="yes" xml:space="preserve">
          <source>If you need to make a change that inverts the expected data flow, you must trigger a new change detection cycle to allow that change to be rendered. The examples illustrate how to make such changes safely.</source>
          <target state="translated">예상 데이터 흐름을 반전시키는 변경을 수행해야하는 경우 해당 변경이 렌더링 될 수 있도록 새 변경 감지주기를 트리거해야합니다. 예제는 이러한 변경을 안전하게 수행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b1f2654a458aa911b15f130929a6854dd20ee84a" translate="yes" xml:space="preserve">
          <source>If you need to make an HTTP request in response to user input, it's not efficient to send a request for every keystroke. It's better to wait until the user stops typing and then send a request. This technique is known as debouncing.</source>
          <target state="translated">사용자 입력에 대한 응답으로 HTTP 요청을해야하는 경우 모든 키 입력에 대해 요청을 보내는 것은 효율적이지 않습니다. 사용자가 입력을 중지 할 때까지 기다린 다음 요청을 보내는 것이 좋습니다. 이 기술을 디 바운싱이라고합니다.</target>
        </trans-unit>
        <trans-unit id="a3250f2b9a593c69bfc2b1d2c08f0d20870d9f6a" translate="yes" xml:space="preserve">
          <source>If you need to opt-out from using Bazel, you can restore the backup files:</source>
          <target state="translated">Bazel을 사용하지 않으려면 백업 파일을 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bb9cbf31fbab37e1847d62faf286db820a17f95" translate="yes" xml:space="preserve">
          <source>If you need to optionally bypass the proxy, or dynamically change the request before it's sent, add the bypass option, as shown in this JavaScript example.</source>
          <target state="translated">선택적으로 프록시를 우회하거나 요청을 보내기 전에 동적으로 변경해야하는 경우이 JavaScript 예제에 표시된대로 우회 옵션을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="9ebc63e4b9f1212654ea17d217d2e04a30598b57" translate="yes" xml:space="preserve">
          <source>If you need to respond to duplicate requests in your test, use the &lt;code&gt;match()&lt;/code&gt; API instead of &lt;code&gt;expectOne()&lt;/code&gt;. It takes the same arguments but returns an array of matching requests. Once returned, these requests are removed from future matching and you are responsible for flushing and verifying them.</source>
          <target state="translated">테스트에서 중복 요청에 응답해야하는 경우 &lt;code&gt;expectOne()&lt;/code&gt; 대신 &lt;code&gt;match()&lt;/code&gt; API를 사용하십시오 . 동일한 인수를 사용하지만 일치하는 요청의 배열을 반환합니다. 반환 된 요청은 이후의 일치 항목에서 제거되며 귀하는 요청을 플러시하고 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="e6da32d2aee99ed52ecee5a0adbf5cdb5a48c9d5" translate="yes" xml:space="preserve">
          <source>If you need to see what events are happening during the navigation lifecycle, there is the &lt;code&gt;enableTracing&lt;/code&gt; option as part of the router's default configuration. This outputs each router event that took place during each navigation lifecycle to the browser console. Use &lt;code&gt;enableTracing&lt;/code&gt; only for debugging purposes. You set the &lt;code&gt;enableTracing: true&lt;/code&gt; option in the object passed as the second argument to the &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="translated">탐색 수명주기 동안 어떤 이벤트가 발생하는지 확인해야하는 경우 라우터 기본 구성의 일부로 &lt;code&gt;enableTracing&lt;/code&gt; 옵션이 있습니다. 이렇게하면 각 탐색 수명주기 동안 발생한 각 라우터 이벤트가 브라우저 콘솔에 출력됩니다. 디버깅 목적으로 만 &lt;code&gt;enableTracing&lt;/code&gt; 을 사용하십시오 . &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; 메서드에 두 번째 인수로 전달 된 객체에서 &lt;code&gt;enableTracing: true&lt;/code&gt; 옵션을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="04c73ded6e0a3395b3dfd9ed41d7828a67bbbf93" translate="yes" xml:space="preserve">
          <source>If you need to see what events are happening during the navigation lifecycle, there is the &lt;strong&gt;enableTracing&lt;/strong&gt; option as part of the router's default configuration. This outputs each router event that took place during each navigation lifecycle to the browser console. This should only be used for &lt;em&gt;debugging&lt;/em&gt; purposes. You set the &lt;code&gt;&lt;a href=&quot;../api/router/extraoptions#enableTracing&quot;&gt;enableTracing&lt;/a&gt;: true&lt;/code&gt; option in the object passed as the second argument to the &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="translated">탐색 수명주기 동안 어떤 이벤트가 발생하는지 확인해야하는 경우 라우터 기본 구성의 일부로 &lt;strong&gt;enableTracing&lt;/strong&gt; 옵션이 있습니다. 이는 탐색주기마다 발생한 각 라우터 이벤트를 브라우저 콘솔에 출력합니다. 이것은 &lt;em&gt;디버깅&lt;/em&gt; 목적으로 만 사용해야 합니다. &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; 메소드에 두 번째 인수로 전달 된 오브젝트에서 &lt;code&gt;&lt;a href=&quot;../api/router/extraoptions#enableTracing&quot;&gt;enableTracing&lt;/a&gt;: true&lt;/code&gt; 옵션을 설정했습니다 .</target>
        </trans-unit>
        <trans-unit id="05239027809e9357cdeac1b33f2e9f9ad3528fa3" translate="yes" xml:space="preserve">
          <source>If you neglect to &lt;code&gt;subscribe()&lt;/code&gt;, the service will not send the delete request to the server. As a rule, an &lt;code&gt;Observable&lt;/code&gt;&lt;em&gt;does nothing&lt;/em&gt; until something subscribes.</source>
          <target state="translated">&lt;code&gt;subscribe()&lt;/code&gt; 를 무시 하면 서비스가 서버로 삭제 요청을 보내지 않습니다. 일반적으로 &lt;code&gt;Observable&lt;/code&gt; &lt;em&gt;은&lt;/em&gt; 무언가를 구독 할 때까지 &lt;em&gt;아무것도하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2bb56c6624ae91a5bea7e0fafc4658c9a36bf145" translate="yes" xml:space="preserve">
          <source>If you neglect to declare them, the Angular compiler won't recognize the &lt;code&gt;&amp;lt;app-banner&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;app-welcome&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; tags in the &lt;code&gt;AppComponent&lt;/code&gt; template and will throw an error.</source>
          <target state="translated">선언하지 않으면 Angular 컴파일러는 &lt;code&gt;AppComponent&lt;/code&gt; 템플릿 에서 &lt;code&gt;&amp;lt;app-banner&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;app-welcome&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; 태그를 인식하지 못하고 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="71dab46c6a678dfa01d392650ea86b654326f74b" translate="yes" xml:space="preserve">
          <source>If you neglect to make the test function async (e.g., forget to use &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt; as described below), you'll see this error message</source>
          <target state="translated">테스트 기능을 비동기로 만들지 않으면 (예 : 아래 설명에 따라 &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt; 를 사용하는 것을 잊지 마십시오 ) 이 오류 메시지가 표시됩니다</target>
        </trans-unit>
        <trans-unit id="f4864022129ceef9f74cba424383807e7e0f747d" translate="yes" xml:space="preserve">
          <source>If you neglect to make the test function async (e.g., forget to use &lt;code&gt;&lt;a href=&quot;../api/core/testing/waitforasync&quot;&gt;waitForAsync&lt;/a&gt;()&lt;/code&gt; as described below), you'll see this error message</source>
          <target state="translated">테스트 함수를 비동기로 만드는 것을 게을리하면 (예 : 아래 설명 된대로 &lt;code&gt;&lt;a href=&quot;../api/core/testing/waitforasync&quot;&gt;waitForAsync&lt;/a&gt;()&lt;/code&gt; 를 사용하는 것을 잊음 ) 이 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1dafb68babd363c5daa6a75a57bc8244a72755a1" translate="yes" xml:space="preserve">
          <source>If you notice that the size of your application's main bundle has increased with Ivy, you may want to check the following:</source>
          <target state="translated">Ivy를 사용하여 응용 프로그램의 기본 번들 크기가 증가한 것을 확인한 경우 다음을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a16062c9a5d0f73bb6c757b4c2accd4e8ddb5ef7" translate="yes" xml:space="preserve">
          <source>If you now add &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; (in addition to the &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt;) to the &lt;code&gt;@&lt;a href=&quot;../api/core/inject&quot;&gt;Inject&lt;/a&gt;&lt;/code&gt; of the &lt;code&gt;FlowerService&lt;/code&gt;, the result will be &lt;code&gt;null&lt;/code&gt;. This is because &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; limits the upper bound of the search to the &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt;. Here's the idea in the logical tree:</source>
          <target state="translated">지금 추가 할 경우 &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; 합니다 (이외에 &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; 받는 사람) &lt;code&gt;@&lt;a href=&quot;../api/core/inject&quot;&gt;Inject&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;FlowerService&lt;/code&gt; , 결과가 될 것입니다 &lt;code&gt;null&lt;/code&gt; . &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; 는 검색의 상한을 &lt;code&gt;&amp;lt;#VIEW&amp;gt;&lt;/code&gt; 로 제한 하기 때문 입니다. 논리 트리의 아이디어는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bad60c66209070a16ad3d561eadc496aed10c245" translate="yes" xml:space="preserve">
          <source>If you opt out of Ivy and your application uses &lt;a href=&quot;universal&quot;&gt;Angular Universal&lt;/a&gt; to render Angular applications on the server, you must also change the way the server performs bootstrapping.</source>
          <target state="translated">Ivy를 옵트 아웃하고 응용 프로그램이 &lt;a href=&quot;universal&quot;&gt;Angular Universal&lt;/a&gt; 을 사용 하여 서버에서 Angular 응용 프로그램을 렌더링하는 경우 서버가 부트 스트랩을 수행하는 방식도 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="81d30c47f20d917822d2488c8b61db4df77908bc" translate="yes" xml:space="preserve">
          <source>If you pass the command a set of libraries to update (or the &lt;code&gt;--all&lt;/code&gt; flag), it updates those libraries, their peer dependencies, and the peer dependencies that depend on them.</source>
          <target state="translated">명령에 업데이트 할 라이브러리 세트 (또는 &lt;code&gt;--all&lt;/code&gt; 플래그)를 전달하면 해당 라이브러리, 해당 피어 종속성 및 해당 라이브러리에 종속 된 피어 종속성이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="1bea4d710733901849b05721b28d48be60b80605" translate="yes" xml:space="preserve">
          <source>If you paste &lt;code&gt;localhost:4200/detail/11&lt;/code&gt; in the browser address bar, the router navigates to the detail view for the hero with &lt;code&gt;id: 11&lt;/code&gt;, &quot;Dr Nice&quot;.</source>
          <target state="translated">브라우저 주소 표시 줄에 &lt;code&gt;localhost:4200/detail/11&lt;/code&gt; 을 붙여 넣으면 라우터는 &lt;code&gt;id: 11&lt;/code&gt; 인 &quot;Dr Nice&quot;인 영웅의 상세보기로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="b16393ced398a24e5cb38175dcbb00a542ed2e61" translate="yes" xml:space="preserve">
          <source>If you plan to have multiple applications in the workspace, you can create an empty workspace by setting the &lt;code&gt;--createApplication&lt;/code&gt; option to false. You can then use &lt;code&gt;ng generate application&lt;/code&gt; to create an initial application. This allows a workspace name different from the initial app name, and ensures that all applications reside in the &lt;code&gt;/projects&lt;/code&gt; subfolder, matching the structure of the configuration file.</source>
          <target state="translated">작업 공간에 여러 애플리케이션을 포함하려는 경우 &lt;code&gt;--createApplication&lt;/code&gt; 옵션을 false 로 설정하여 빈 작업 공간을 만들 수 있습니다 . 그런 다음 &lt;code&gt;ng generate application&lt;/code&gt; 을 사용하여 초기 애플리케이션을 만들 수 있습니다 . 이렇게하면 초기 앱 이름과 다른 작업 공간 이름을 사용할 수 있으며 모든 애플리케이션 이 구성 파일의 구조와 일치하는 &lt;code&gt;/projects&lt;/code&gt; 하위 폴더에 상주 하도록합니다.</target>
        </trans-unit>
        <trans-unit id="a7f498a38745493c47fdb50885cc56ca61f9d272" translate="yes" xml:space="preserve">
          <source>If you plan to have multiple apps in the workspace, you can create an empty workspace by setting the &lt;code&gt;--createApplication&lt;/code&gt; option to false. You can then use &lt;code&gt;ng generate application&lt;/code&gt; to create an initial app. This allows a workspace name different from the initial app name, and ensures that all apps reside in the &lt;code&gt;/projects&lt;/code&gt; subfolder, matching the structure of the configuration file.</source>
          <target state="translated">작업 공간에 여러 개의 앱을 보유하려는 경우 &lt;code&gt;--createApplication&lt;/code&gt; 옵션을 false 로 설정하여 빈 작업 공간을 작성할 수 있습니다 . 그런 다음 &lt;code&gt;ng generate application&lt;/code&gt; 을 사용하여 초기 앱을 만들 수 있습니다. 이를 통해 초기 앱 이름과 다른 작업 영역 이름을 허용하고 모든 앱이 &lt;code&gt;/projects&lt;/code&gt; 하위 폴더에 있으며 구성 파일의 구조와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2c9da46a1c1c85d39407dcd30d927647ba079020" translate="yes" xml:space="preserve">
          <source>If you plan to use specific animation functions in component files, import those functions from &lt;code&gt;@angular/animations&lt;/code&gt;.</source>
          <target state="translated">컴포넌트 파일에서 특정 애니메이션 함수를 사용하려면 &lt;code&gt;@angular/animations&lt;/code&gt; 에서 해당 함수를 가져 오십시오 .</target>
        </trans-unit>
        <trans-unit id="058a384d58caba78f973912e1c7261709321db73" translate="yes" xml:space="preserve">
          <source>If you prefer a &lt;code&gt;File | New Project&lt;/code&gt; experience and are using &lt;strong&gt;ASP.NET Core&lt;/strong&gt;, then consider the &lt;em&gt;experimental&lt;/em&gt;&lt;a href=&quot;http://blog.stevensanderson.com/2016/10/04/angular2-template-for-visual-studio/&quot;&gt;ASP.NET Core + Angular template for Visual Studio 2015&lt;/a&gt;. Note that the resulting code does not map to the docs. Adjust accordingly.</source>
          <target state="translated">&lt;code&gt;File | New Project&lt;/code&gt; 을 선호하는 경우 | 새로운 프로젝트 경험으로 &lt;strong&gt;ASP.NET Core를&lt;/strong&gt; 사용하고 있다면 &lt;a href=&quot;http://blog.stevensanderson.com/2016/10/04/angular2-template-for-visual-studio/&quot;&gt;Visual Studio 2015 용 &lt;/a&gt;&lt;em&gt;실험 &lt;/em&gt;ASP.NET Core + Angular 템플릿을 고려하십시오 . 결과 코드는 문서에 매핑되지 않습니다. 그에 따라 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="40537ceb386711b8d7aebae59078f6588b332d47" translate="yes" xml:space="preserve">
          <source>If you provided &lt;code&gt;VillainsService&lt;/code&gt; in the root &lt;code&gt;AppModule&lt;/code&gt; (where you registered the &lt;code&gt;HeroesService&lt;/code&gt;), that would make the &lt;code&gt;VillainsService&lt;/code&gt; visible everywhere in the application, including the &lt;em&gt;Hero&lt;/em&gt; workflows. If you later modified the &lt;code&gt;VillainsService&lt;/code&gt;, you could break something in a hero component somewhere.</source>
          <target state="translated">당신이 제공 한 경우 &lt;code&gt;VillainsService&lt;/code&gt; 를 루트에 &lt;code&gt;AppModule&lt;/code&gt; (당신이 등록 된 곳 &lt;code&gt;HeroesService&lt;/code&gt; 을 ), 그것은 만들 것 &lt;code&gt;VillainsService&lt;/code&gt; 이 을 포함하여 응용 프로그램에서 모든 곳에서 볼 &lt;em&gt;영웅&lt;/em&gt; 워크 플로우. 나중에 &lt;code&gt;VillainsService&lt;/code&gt; 를 수정하면 영웅 구성 요소에서 무언가가 깨질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34e894d4b2433bfdb374e1411f1d2796623ea1fa" translate="yes" xml:space="preserve">
          <source>If you ran the app now and started typing in the &lt;em&gt;Name&lt;/em&gt; input box, adding and deleting characters, you'd see them appear and disappear from the interpolated text. At some point it might look like this:</source>
          <target state="translated">앱을 지금 실행하고 &lt;em&gt;이름&lt;/em&gt; 입력 상자에 문자를 추가하고 삭제 하기 시작 하면 보간 된 텍스트에서 해당 문자가 나타나고 사라지는 것을 볼 수 있습니다. 어느 시점에서 다음과 같이 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32f30f3a80132757d89d194ab176d54b3533a611" translate="yes" xml:space="preserve">
          <source>If you register global service providers or share providers across multiple NgModules, use the &lt;a href=&quot;singleton-services&quot;&gt;&lt;code&gt;forRoot()&lt;/code&gt; and &lt;code&gt;forChild()&lt;/code&gt; design patterns&lt;/a&gt; provided by the &lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;.</source>
          <target state="translated">여러 NgModules를 통해 글로벌 서비스 제공 또는 공유 업체를 등록하면 사용 &lt;a href=&quot;singleton-services&quot;&gt; &lt;code&gt;forRoot()&lt;/code&gt; 및 &lt;code&gt;forChild()&lt;/code&gt; 디자인 패턴&lt;/a&gt; 에 의해 제공 &lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eef190ef5d0b1e7b6837c2e3d11da6d23edc990e" translate="yes" xml:space="preserve">
          <source>If you register global service providers or share providers across multiple NgModules, use the &lt;a href=&quot;singleton-services&quot;&gt;&lt;code&gt;forRoot()&lt;/code&gt; and &lt;code&gt;forChild()&lt;/code&gt; patterns&lt;/a&gt; provided by the &lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;.</source>
          <target state="translated">여러 NgModules를 통해 글로벌 서비스 제공 또는 공유 업체를 등록하면 사용 &lt;a href=&quot;singleton-services&quot;&gt; &lt;code&gt;forRoot()&lt;/code&gt; 및 &lt;code&gt;forChild()&lt;/code&gt; 패턴&lt;/a&gt; 에 의해 제공 &lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e78fb432ea926eaccd578fd4c24d9a2cfa237ad" translate="yes" xml:space="preserve">
          <source>If you rely on the behavior that the same object instance should cause change detection, you have two options:</source>
          <target state="translated">동일한 객체 인스턴스가 변경 감지를 유발해야하는 동작에 의존하는 경우 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddd4700cea7271c0c90205b90dda623d6197e16f" translate="yes" xml:space="preserve">
          <source>If you restore the &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; decorator and comment out &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;&lt;/code&gt;, the app throws an exception when it cannot find the required logger at the host component level.</source>
          <target state="translated">당신이 복원하면 &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; 장식 및 주석 &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;&lt;/code&gt; , 응용 프로그램은 호스트 구성 요소 수준에서 필요한 로거를 찾을 수없는 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="33bb5c55ad4aa9d09fe4482cd02e6d0fd59b9479" translate="yes" xml:space="preserve">
          <source>If you run other &lt;code&gt;macroTask&lt;/code&gt; such as &lt;code&gt;HTMLCanvasElement.toBlob()&lt;/code&gt;, &lt;code&gt;Unknown macroTask scheduled in fake &lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt; test&lt;/code&gt; error will be thrown.</source>
          <target state="translated">다른 실행하면 &lt;code&gt;macroTask&lt;/code&gt; 같은 &lt;code&gt;HTMLCanvasElement.toBlob()&lt;/code&gt; , &lt;code&gt;Unknown macroTask scheduled in fake &lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt; test&lt;/code&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="37c45632d720c861eb9466ce577279a844106c86" translate="yes" xml:space="preserve">
          <source>If you run other macro tasks such as &lt;code&gt;HTMLCanvasElement.toBlob()&lt;/code&gt;, an &lt;em&gt;&quot;Unknown macroTask scheduled in fake async test&quot;&lt;/em&gt; error will be thrown.</source>
          <target state="translated">&lt;code&gt;HTMLCanvasElement.toBlob()&lt;/code&gt; 과 같은 다른 매크로 작업을 실행 하면 &lt;em&gt;&quot;가짜 비동기 테스트에서 예약 된 알 수없는 macroTask&quot;&lt;/em&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3f9f75108fc42c095c35521bcb513aee44b2b9d0" translate="yes" xml:space="preserve">
          <source>If you run tests in a &lt;strong&gt;non-CLI environment&lt;/strong&gt;, the tests may fail with a message like this one:</source>
          <target state="translated">&lt;strong&gt;CLI 환경&lt;/strong&gt; 이 &lt;strong&gt;아닌 환경&lt;/strong&gt; 에서 테스트를 실행하면 다음 과 같은 메시지와 함께 테스트가 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d43bbf23fa3e23d5c174913c8419dd08b9a38280" translate="yes" xml:space="preserve">
          <source>If you run the app now and change every hero model property, the form might display like this:</source>
          <target state="translated">지금 앱을 실행하고 모든 영웅 모델 속성을 변경하면 양식이 다음과 같이 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d950e9a165ba31caa3f90eca764582f6ada8b451" translate="yes" xml:space="preserve">
          <source>If you run the app right now, you see the list of powers in the selection control. The input elements are not yet bound to data values or events, so they are still blank and have no behavior.</source>
          <target state="translated">지금 앱을 실행하면 선택 컨트롤에 권한 목록이 표시됩니다. 입력 요소는 아직 데이터 값이나 이벤트에 바인딩되지 않았으므로 여전히 비어 있고 동작이 없습니다.</target>
        </trans-unit>
        <trans-unit id="65b31d00b7e322159d3096cefef0ef38c3b1e7fc" translate="yes" xml:space="preserve">
          <source>If you run the application now, you find that the button is enabled&amp;mdash;although it doesn't do anything useful yet.</source>
          <target state="translated">지금 응용 프로그램을 실행하면 단추가 활성화되어 있지만 아직 유용한 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="27b6400e05079e321c67fb69ac2f1ea5f2e11f6d" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;OnPush&lt;/code&gt; (&quot;CheckOnce&quot;) change-detection strategy, the change detector runs only when &lt;a href=&quot;../api/core/changedetectorref&quot;&gt;explicitly invoked&lt;/a&gt;, or when it is triggered by an &lt;code&gt;&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; reference change or event handler. This typically improves performance. For more information, see &lt;a href=&quot;https://web.dev/faster-angular-change-detection/&quot;&gt;Optimize Angular's change detection&lt;/a&gt;.</source>
          <target state="translated">당신이 설정 한 경우 &lt;code&gt;OnPush&lt;/code&gt; 변화를 감지 전략 ( &quot;CheckOnce을&quot;), 변경 검출기는 경우에만 실행 &lt;a href=&quot;../api/core/changedetectorref&quot;&gt;명시 적으로 호출&lt;/a&gt; 하거나가에 의해 트리거 될 때 &lt;code&gt;&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; 기준 변경이나 이벤트 핸들러. 이것은 일반적으로 성능을 향상시킵니다. 자세한 내용은 &lt;a href=&quot;https://web.dev/faster-angular-change-detection/&quot;&gt;Angular의 변경 감지 최적화를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="70b574c62b73c7ab82961bbe1d311a4be5bc48ca" translate="yes" xml:space="preserve">
          <source>If you still have issues after troubleshooting with these flags, you can fall back to full mode by disabling &lt;code&gt;strictTemplates&lt;/code&gt;.</source>
          <target state="translated">이러한 플래그로 문제를 해결 한 후에도 문제가 계속되면 &lt;code&gt;strictTemplates&lt;/code&gt; 를 사용 중지하여 전체 모드로 폴백 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1afbfd71a7b0f3746a5b9d786267c74b5e8c9f70" translate="yes" xml:space="preserve">
          <source>If you tell the router to navigate to the detail component and display &quot;Magneta&quot;, you expect a hero id to appear in the browser URL like this:</source>
          <target state="translated">라우터가 세부 구성 요소를 탐색하고 &quot;Magneta&quot;를 표시하도록 지시하면 다음과 같이 브라우저 ID에 영웅 ID가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8dddbeadfd16ceb49ed31d2988e2ee1b9782e74c" translate="yes" xml:space="preserve">
          <source>If you think you'll reuse this debouncing logic, consider moving it to a utility function or into the &lt;code&gt;PackageSearchService&lt;/code&gt; itself.</source>
          <target state="translated">이 탈퇴 논리를 재사용 할 것이라고 생각되면이를 유틸리티 함수 또는 &lt;code&gt;PackageSearchService&lt;/code&gt; 자체 로 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="d7a151abe2fd8d0a7aaa7a6bd6a8df4082f73f7c" translate="yes" xml:space="preserve">
          <source>If you throttle your network speed so that the client-side scripts take longer to download (instructions below), you'll notice:</source>
          <target state="translated">클라이언트 쪽 스크립트를 다운로드하는 데 시간이 오래 걸리도록 네트워크 속도를 조절하면 (아래 지침 참조) 다음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92b0949b67e72c8422501e07cc4ce8c75521a33c" translate="yes" xml:space="preserve">
          <source>If you try to alias &lt;code&gt;OldLogger&lt;/code&gt; to &lt;code&gt;NewLogger&lt;/code&gt; with &lt;code&gt;useClass&lt;/code&gt;, you end up with two different &lt;code&gt;NewLogger&lt;/code&gt; instances in your app.</source>
          <target state="translated">가상 본을하려고하면 &lt;code&gt;OldLogger&lt;/code&gt; 에 &lt;code&gt;NewLogger&lt;/code&gt; 와 &lt;code&gt;useClass&lt;/code&gt; , 당신은 두 가지로 끝날 &lt;code&gt;NewLogger&lt;/code&gt; 의 앱에 인스턴스.</target>
        </trans-unit>
        <trans-unit id="b1333d31e83b576427ff734b7c88ade3261f5d51" translate="yes" xml:space="preserve">
          <source>If you upgrade this component and use it from Angular, you can populate the component tag with contents that will then get transcluded:</source>
          <target state="translated">이 구성 요소를 업그레이드하고 Angular에서 사용하는 경우 구성 요소 태그를 내용으로 채운 다음 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5229aaba988a521b48efab8fecc2aefe3f2fe23e" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;NgFor&lt;/code&gt; with large lists, a small change to one item, such as removing or adding an item, can trigger a cascade of DOM manipulations. For example, re-querying the server could reset a list with all new item objects, even when those items were previously displayed. In this case, Angular sees only a fresh list of new object references and has no choice but to replace the old DOM elements with all new DOM elements.</source>
          <target state="translated">큰 목록으로 &lt;code&gt;NgFor&lt;/code&gt; 를 사용 하는 경우 항목 제거 또는 추가와 같이 하나의 항목을 조금만 변경하면 일련의 DOM 조작이 트리거 될 수 있습니다. 예를 들어, 서버를 다시 쿼리하면 해당 항목이 이전에 표시된 경우에도 모든 새 항목 개체로 목록을 재설정 할 수 있습니다. 이 경우 Angular는 새로운 객체 참조의 새로운 목록 만보고 이전 DOM 요소를 모든 새 DOM 요소로 대체 ​​할 수밖에 없습니다.</target>
        </trans-unit>
        <trans-unit id="a75130a39257f6837aa70edb1e7ee3064bb9921f" translate="yes" xml:space="preserve">
          <source>If you use dynamic values to generate the link, you can pass an array of path segments, followed by the params for each segment.</source>
          <target state="translated">동적 값을 사용하여 링크를 생성하는 경우 경로 세그먼트 배열을 전달한 다음 각 세그먼트에 대한 매개 변수를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95db25e1e7afc248a2cd0fe9b287c943fda5d02b" translate="yes" xml:space="preserve">
          <source>If you use the &lt;a href=&quot;cli&quot;&gt;Angular CLI&lt;/a&gt; to generate an app, the default &lt;code&gt;AppModule&lt;/code&gt; is as follows:</source>
          <target state="translated">당신이 사용하는 경우 &lt;a href=&quot;cli&quot;&gt;각도 CLI를&lt;/a&gt; 응용 프로그램을 생성하는 기본 &lt;code&gt;AppModule&lt;/code&gt; 은 같은 다음입니다 :</target>
        </trans-unit>
        <trans-unit id="a6967c4ab3b314fa46aff194dc20ed6a9dd2b60b" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()/&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt; helper function to run unit tests (for details, read the &lt;a href=&quot;testing#async-test-with-fakeasync&quot;&gt;Testing guide&lt;/a&gt;), you need to import &lt;code&gt;zone.js/dist/zone-testing&lt;/code&gt; in your test setup file.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()/&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt; (자세한 내용은 읽기 단위 테스트를 실행하는 도우미 함수를 &lt;a href=&quot;testing#async-test-with-fakeasync&quot;&gt;테스트 가이드&lt;/a&gt; ), 당신은 수입에 필요 &lt;code&gt;zone.js/dist/zone-testing&lt;/code&gt; 테스트 설치 파일에.</target>
        </trans-unit>
        <trans-unit id="033eb7a2799b446ce985cbf252d18f61a08af7e8" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()/&lt;a href=&quot;../api/core/testing/waitforasync&quot;&gt;waitForAsync&lt;/a&gt;()&lt;/code&gt; helper function to run unit tests (for details, read the &lt;a href=&quot;testing-components-scenarios#fake-async&quot;&gt;Testing guide&lt;/a&gt;), you need to import &lt;code&gt;zone.js/dist/zone-testing&lt;/code&gt; in your test setup file.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()/&lt;a href=&quot;../api/core/testing/waitforasync&quot;&gt;waitForAsync&lt;/a&gt;()&lt;/code&gt; (자세한 내용은 읽기 단위 테스트를 실행하는 도우미 함수를 &lt;a href=&quot;testing-components-scenarios#fake-async&quot;&gt;테스트 가이드&lt;/a&gt; ), 당신은 수입에 필요 &lt;code&gt;zone.js/dist/zone-testing&lt;/code&gt; 테스트 설치 파일에.</target>
        </trans-unit>
        <trans-unit id="b72f1ab9aecc24257c6414e938470c94360b2550" translate="yes" xml:space="preserve">
          <source>If you use the Angular CLI, configure this flag in &lt;code&gt;src/test.ts&lt;/code&gt;.</source>
          <target state="translated">Angular CLI를 사용하는 경우 &lt;code&gt;src/test.ts&lt;/code&gt; 에서이 플래그를 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d271b502194e43198b4eb10238cbab362121ae6" translate="yes" xml:space="preserve">
          <source>If you use the JIT compiler, specify the warning level in the compiler config at bootstrap by adding the 'MissingTranslationStrategy' property. The example below shows how to set the warning level to error.</source>
          <target state="translated">JIT 컴파일러를 사용하는 경우 부트 스트랩에서 'MissingTranslationStrategy'특성을 추가하여 컴파일러 구성에서 경고 레벨을 지정하십시오. 아래 예는 경고 수준을 오류로 설정하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ce978a5f13cee676ff853adc3785a5db0dc00166" translate="yes" xml:space="preserve">
          <source>If you use the following deprecated i18n pipes: &lt;a href=&quot;../api/common/deprecateddatepipe&quot;&gt;date&lt;/a&gt;, &lt;a href=&quot;../api/common/deprecatedcurrencypipe&quot;&gt;currency&lt;/a&gt;, &lt;a href=&quot;../api/common/deprecateddecimalpipe&quot;&gt;decimal&lt;/a&gt;, &lt;a href=&quot;../api/common/deprecatedpercentpipe&quot;&gt;percent&lt;/a&gt;</source>
          <target state="translated">더 이상 사용되지 않는 i18n 파이프를 사용하는 경우 : &lt;a href=&quot;../api/common/deprecateddatepipe&quot;&gt;date&lt;/a&gt; , &lt;a href=&quot;../api/common/deprecatedcurrencypipe&quot;&gt;currency&lt;/a&gt; , &lt;a href=&quot;../api/common/deprecateddecimalpipe&quot;&gt;decimal&lt;/a&gt; , &lt;a href=&quot;../api/common/deprecatedpercentpipe&quot;&gt;percent&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a047e1b38f5fe9531800dc758286f59e23bce528" translate="yes" xml:space="preserve">
          <source>If you view your application in the browser, you should see these two links. When you click on a link, the corresponding component appears.</source>
          <target state="translated">브라우저에서 애플리케이션을 보면이 두 링크가 표시되어야합니다. 링크를 클릭하면 해당 구성 요소가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="c4bd37b0cb03c780077913bd95b8118fa17a9f1d" translate="yes" xml:space="preserve">
          <source>If you want &lt;code&gt;ngc&lt;/code&gt; to report syntax errors immediately rather than produce a &lt;code&gt;.metadata.json&lt;/code&gt; file with errors, set the &lt;code&gt;strictMetadataEmit&lt;/code&gt; option in the TypeScript configuration file, &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="translated">당신이 원하는 경우 &lt;code&gt;ngc&lt;/code&gt; 보고서 구문 오류가 바로이 아니라 생산보다에 &lt;code&gt;.metadata.json&lt;/code&gt; 에 설정된 오류가있는 파일, &lt;code&gt;strictMetadataEmit&lt;/code&gt; 의 타이프 스크립트 구성 파일 옵션, &lt;code&gt;tsconfig.json&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="c2fa45246f68238edb8ee3d51625ac4a281cc12a" translate="yes" xml:space="preserve">
          <source>If you want &lt;code&gt;ngc&lt;/code&gt; to report syntax errors immediately rather than produce a &lt;code&gt;.metadata.json&lt;/code&gt; file with errors, set the &lt;code&gt;strictMetadataEmit&lt;/code&gt; option in the TypeScript configuration file.</source>
          <target state="translated">당신이 원하는 경우 &lt;code&gt;ngc&lt;/code&gt; 보고서 구문 오류가 바로이 아니라 생산보다에 &lt;code&gt;.metadata.json&lt;/code&gt; 에 설정된 오류가있는 파일, &lt;code&gt;strictMetadataEmit&lt;/code&gt; 의 타이프 스크립트 구성 파일에서 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="9181cff9d2f0ac3faceb9204a24748172c73f1ab" translate="yes" xml:space="preserve">
          <source>If you want a particular piece of code to trigger change detection in the AngularJS part of the app, you need to wrap it in &lt;a href=&quot;https://docs.angularjs.org/api/ng/type/%24rootScope.Scope#%24apply&quot;&gt;scope.$apply()&lt;/a&gt;. Similarly, for triggering change detection in Angular you would use &lt;a href=&quot;../api/core/ngzone#run&quot;&gt;ngZone.run()&lt;/a&gt;.</source>
          <target state="translated">앱의 AngularJS 부분에서 특정 코드 조각이 변경 감지를 트리거하도록하려면 &lt;a href=&quot;https://docs.angularjs.org/api/ng/type/%24rootScope.Scope#%24apply&quot;&gt;scope. $ apply ()&lt;/a&gt; 로 랩핑해야합니다 . 마찬가지로 Angular에서 변경 감지를 트리거하려면 &lt;a href=&quot;../api/core/ngzone#run&quot;&gt;ngZone.run ()을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c3fae0cd6000e2662a9b617f542c44356a243f5" translate="yes" xml:space="preserve">
          <source>If you want changes to persist, you must write them back to the server.</source>
          <target state="translated">변경 사항을 유지하려면 서버에 다시 써야합니다.</target>
        </trans-unit>
        <trans-unit id="52bcde3eec9eaea3236dc449439b8e942dbe703e" translate="yes" xml:space="preserve">
          <source>If you want some injectables to be shared among all downgraded modules, you can provide them as &lt;code&gt;&lt;a href=&quot;../../core/staticprovider&quot;&gt;StaticProvider&lt;/a&gt;&lt;/code&gt;s, when creating the &lt;code&gt;&lt;a href=&quot;../../core/platformref&quot;&gt;PlatformRef&lt;/a&gt;&lt;/code&gt; (e.g. via &lt;code&gt;&lt;a href=&quot;../../platform-browser/platformbrowser&quot;&gt;platformBrowser&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../platform-browser-dynamic/platformbrowserdynamic&quot;&gt;platformBrowserDynamic&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">다운 그레이드 된 모든 모듈간에 일부 &lt;code&gt;&lt;a href=&quot;../../core/staticprovider&quot;&gt;StaticProvider&lt;/a&gt;&lt;/code&gt; 공유 하려면 &lt;code&gt;&lt;a href=&quot;../../core/platformref&quot;&gt;PlatformRef&lt;/a&gt;&lt;/code&gt; 를 작성할 때 (예 : &lt;code&gt;&lt;a href=&quot;../../platform-browser/platformbrowser&quot;&gt;platformBrowser&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../../platform-browser-dynamic/platformbrowserdynamic&quot;&gt;platformBrowserDynamic&lt;/a&gt;&lt;/code&gt; 을 통해) 정적 제공자 로 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05f65a50533a43590941f359728f24c16a80ebbd" translate="yes" xml:space="preserve">
          <source>If you want to create code-coverage reports every time you test, you can set the following option in the CLI configuration file, &lt;code&gt;angular.json&lt;/code&gt;:</source>
          <target state="translated">테스트 할 때마다 코드 적용 보고서를 작성하려는 경우 CLI 구성 파일 &lt;code&gt;angular.json&lt;/code&gt; 에서 다음 옵션을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7751b871f96409ec0fd06919c70ee1e168709cf2" translate="yes" xml:space="preserve">
          <source>If you want to execute something when the app is stable, you have to wait for the application to be stable before starting your polling process.</source>
          <target state="translated">앱이 안정적 일 때 무언가를 실행하려면 폴링 프로세스를 시작하기 전에 애플리케이션이 안정적 일 때까지 기다려야합니다.</target>
        </trans-unit>
        <trans-unit id="72f364ed3fa3f7c00f99fac9b35717046eda7479" translate="yes" xml:space="preserve">
          <source>If you want to import locale data for other languages, you can do it manually:</source>
          <target state="translated">다른 언어의 로캘 데이터를 가져 오려면 수동으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f8bd9d90c1d0e27214fa6232ead13c884e44f0f" translate="yes" xml:space="preserve">
          <source>If you want to manage NgModule loading and the use of dependencies and services, see the following:</source>
          <target state="translated">NgModule 로딩과 종속성 및 서비스 사용을 관리하려면 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b1c4888fd74929044c99840ccfb42fc5c433838a" translate="yes" xml:space="preserve">
          <source>If you want to preload a module &lt;em&gt;and&lt;/em&gt; guard against unauthorized access, drop the &lt;code&gt;&lt;a href=&quot;../api/router/route#canLoad&quot;&gt;canLoad&lt;/a&gt;()&lt;/code&gt; guard method and rely on the &lt;a href=&quot;router#can-activate-guard&quot;&gt;canActivate()&lt;/a&gt; guard alone.</source>
          <target state="translated">당신은 모듈 미리로드하려는 경우 &lt;em&gt;와&lt;/em&gt; 1, 인증되지 않은 액세스로부터 보호 드롭 &lt;code&gt;&lt;a href=&quot;../api/router/route#canLoad&quot;&gt;canLoad&lt;/a&gt;()&lt;/code&gt; 보호 방법과 의지 &lt;a href=&quot;router#can-activate-guard&quot;&gt;canActivate ()&lt;/a&gt; 혼자 가드.</target>
        </trans-unit>
        <trans-unit id="1bd8c04744a232665205b0d8c9ce098c53ab9cba" translate="yes" xml:space="preserve">
          <source>If you want to preload a module as well as guard against unauthorized access, remove the &lt;code&gt;canLoad()&lt;/code&gt; guard method and rely on the &lt;a href=&quot;router-tutorial-toh#can-activate-guard&quot;&gt;canActivate()&lt;/a&gt; guard alone.</source>
          <target state="translated">모듈을 미리로드하고 무단 액세스로부터 보호하려면 &lt;code&gt;canLoad()&lt;/code&gt; 가드 메서드를 제거 하고 &lt;a href=&quot;router-tutorial-toh#can-activate-guard&quot;&gt;canActivate ()&lt;/a&gt; 가드 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e574770511b728920629db82475c655722befaa3" translate="yes" xml:space="preserve">
          <source>If you want to produce a progressive web app and are using &lt;a href=&quot;https://developers.google.com/web/tools/lighthouse/&quot;&gt;Lighthouse&lt;/a&gt; to grade the project, add the following &lt;code&gt;browserslist&lt;/code&gt; entry to your &lt;code&gt;package.json&lt;/code&gt; file, in order to eliminate the &lt;a href=&quot;https://developers.google.com/web/tools/lighthouse/audits/old-flexbox&quot;&gt;old flexbox&lt;/a&gt; prefixes:</source>
          <target state="translated">프로그레시브 웹 앱을 생성하고 &lt;a href=&quot;https://developers.google.com/web/tools/lighthouse/&quot;&gt;Lighthouse&lt;/a&gt; 를 사용 하여 프로젝트를 등급 화하려는 경우 &lt;a href=&quot;https://developers.google.com/web/tools/lighthouse/audits/old-flexbox&quot;&gt;이전 flexbox 접&lt;/a&gt; 두부 를 제거하기 위해 &lt;code&gt;package.json&lt;/code&gt; 파일에 다음 &lt;code&gt;browserslist&lt;/code&gt; 항목을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="9654c2a4c45b0218af8cbaae154038e0b00ad445" translate="yes" xml:space="preserve">
          <source>If you want to run ES5 code during development, you could disable differential loading completely. To maintain the benefits of differential loading, however, a better option is to define multiple configurations for &lt;code&gt;ng serve&lt;/code&gt;, &lt;code&gt;ng e2e&lt;/code&gt;, and &lt;code&gt;ng test&lt;/code&gt;.</source>
          <target state="translated">개발 중에 ES5 코드를 실행하려면 차등로드를 완전히 비활성화 할 수 있습니다. 그러나 차등 로딩의 이점을 유지하기 위해 더 나은 옵션은 &lt;code&gt;ng serve&lt;/code&gt; , &lt;code&gt;ng e2e&lt;/code&gt; 및 &lt;code&gt;ng test&lt;/code&gt; 에 대한 여러 구성을 정의하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="5d7009f42e7627d060101333c56524a2c640bb2d" translate="yes" xml:space="preserve">
          <source>If you want to support such a case, you need to define the &lt;code&gt;macroTask&lt;/code&gt; you want to support in &lt;code&gt;beforeEach()&lt;/code&gt;. For example:</source>
          <target state="translated">이러한 경우 를 지원하려면 &lt;code&gt;beforeEach()&lt;/code&gt; 에서 지원하려는 &lt;code&gt;macroTask&lt;/code&gt; 를 정의해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1b56e40098d70369a4d83fcac231ca5af8aa5cce" translate="yes" xml:space="preserve">
          <source>If you want to support such a case, you need to define the macro task you want to support in &lt;code&gt;beforeEach()&lt;/code&gt;. For example:</source>
          <target state="translated">이러한 경우를 지원하려면 &lt;code&gt;beforeEach()&lt;/code&gt; 에서 지원하려는 매크로 작업을 정의해야합니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="f2764b90b69b4cf903c2c31d61b196574003141d" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;strictTemplates&lt;/code&gt; and &lt;code&gt;strictNullChecks&lt;/code&gt; together, you can opt out of strict null type checking specifically for input bindings via &lt;code&gt;strictNullInputTypes&lt;/code&gt;.</source>
          <target state="translated">당신이 사용하려는 경우 &lt;code&gt;strictTemplates&lt;/code&gt; 및 &lt;code&gt;strictNullChecks&lt;/code&gt; 을 함께, 당신은을 통해 입력 바인딩을 위해 특별히 엄격한 점검 널 유형 선택 해제 할 수 있습니다 &lt;code&gt;strictNullInputTypes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c98ab8bb06c1699ee5d9fd496aa7660ad732c8b" translate="yes" xml:space="preserve">
          <source>If you want to use this component from AngularJS, you need to &lt;em&gt;downgrade&lt;/em&gt; it using the &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgradecomponent&quot;&gt;downgradeComponent&lt;/a&gt;()&lt;/code&gt; method. The result is an AngularJS &lt;em&gt;directive&lt;/em&gt;, which you can then register in the AngularJS module:</source>
          <target state="translated">AngularJS에서이 컴포넌트를 사용하려면 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgradecomponent&quot;&gt;downgradeComponent&lt;/a&gt;()&lt;/code&gt; () 메소드를 사용하여 다운&lt;em&gt; 그레이드&lt;/em&gt; 해야합니다 . 결과는 AngularJS &lt;em&gt;지시문&lt;/em&gt; 이며, AngularJS 모듈에 등록 할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d09a0a0eb3acca8806d03b8b527badb4d19f0b41" translate="yes" xml:space="preserve">
          <source>If you want your template to span multiple lines, you can use backticks (&lt;code&gt; ` &lt;/code&gt;). For example:</source>
          <target state="translated">템플릿이 여러 줄에 걸쳐 있도록하려면 백틱 ( &lt;code&gt; ` &lt;/code&gt; )을 사용할 수 있습니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="4fb183e6a6ca4b3daf2ebb1dcb39b4bdc36e09a2" translate="yes" xml:space="preserve">
          <source>If you wanted to, you could redefine the &lt;code&gt;AppComponent&lt;/code&gt; template with &lt;em&gt;Crisis Center&lt;/em&gt; routes exclusively:</source>
          <target state="translated">원하는 경우 &lt;em&gt;Crisis Center&lt;/em&gt; 경로를 사용 하여 &lt;code&gt;AppComponent&lt;/code&gt; 템플릿을 독점적으로 재정의 할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf62d295b1f1f68706351f1e160a6f3ac4994401" translate="yes" xml:space="preserve">
          <source>If you were to replace &lt;code&gt;useExisting&lt;/code&gt; with &lt;code&gt;useClass&lt;/code&gt;, then you&amp;rsquo;d be registering a new class instance, one that doesn&amp;rsquo;t have a &lt;code&gt;forbiddenName&lt;/code&gt;.</source>
          <target state="translated">당신이 대체한다면 &lt;code&gt;useExisting&lt;/code&gt; 와 &lt;code&gt;useClass&lt;/code&gt; 을 , 당신은 새로운 클래스 인스턴스하는이없는 한 등록하는 것 &lt;code&gt;forbiddenName&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="1a47d1cb386ad250a0bc5d99819cbf7f3ff10e68" translate="yes" xml:space="preserve">
          <source>If you were translating to other languages, you would repeat these steps for each target language.</source>
          <target state="translated">다른 언어로 번역하는 경우 각 대상 언어에 대해이 단계를 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="acd7dfd6b09abe0f861b08835a3b16b4feaacf7e" translate="yes" xml:space="preserve">
          <source>If you were using a real world API, there might be some delay before the data to display is returned from the server. You don't want to display a blank component while waiting for the data.</source>
          <target state="translated">실제 API를 사용하는 경우 표시 할 데이터가 서버에서 반환되기까지 약간의 지연이있을 수 있습니다. 데이터를 기다리는 동안 빈 구성 요소를 표시하고 싶지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9374a8c08fe1c474c361e4aaa7e0f9b479d03bd7" translate="yes" xml:space="preserve">
          <source>If you work behind a corporate proxy, the backend cannot directly proxy calls to any URL outside your local network. In this case, you can configure the backend proxy to redirect calls through your corporate proxy using an agent:</source>
          <target state="translated">회사 프록시 뒤에서 작업하는 경우 백엔드는 로컬 네트워크 외부의 URL에 대한 호출을 직접 프록시 할 수 없습니다. 이 경우 에이전트를 사용하여 회사 프록시를 통해 통화를 리디렉션하도록 백엔드 프록시를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2391ba640bc65fc5eb8023b8dd979ece264d84dd" translate="yes" xml:space="preserve">
          <source>If you write &lt;code&gt;&amp;lt;map [city]=&quot;user.address.city&quot;&amp;gt;&lt;/code&gt;, the compiler verifies the following:</source>
          <target state="translated">당신이 작성하는 경우 &lt;code&gt;&amp;lt;map [city]=&quot;user.address.city&quot;&amp;gt;&lt;/code&gt; , 컴파일러를 검증은 다음과 :</target>
        </trans-unit>
        <trans-unit id="12d0a113abd4c3fccdbb49cb154c353de7ca8ffc" translate="yes" xml:space="preserve">
          <source>If you wrote something like this:</source>
          <target state="translated">다음과 같이 썼다면 :</target>
        </trans-unit>
        <trans-unit id="21014f48c5ba788700f412d0e8fe50ad6d65a568" translate="yes" xml:space="preserve">
          <source>If you'd like to use something other than &lt;code&gt;{{&lt;/code&gt; and &lt;code&gt;}}&lt;/code&gt;, you can configure the interpolation delimiter via the &lt;a href=&quot;../api/core/component#interpolation&quot;&gt;interpolation&lt;/a&gt; option in the &lt;code&gt;&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; metadata.</source>
          <target state="translated">&lt;code&gt;{{&lt;/code&gt; and &lt;code&gt;}}&lt;/code&gt; 이외의 다른 것을 사용 하려면 &lt;code&gt;&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; 메타 데이터 의 &lt;a href=&quot;../api/core/component#interpolation&quot;&gt;보간&lt;/a&gt; 옵션을 통해 보간 분리 문자를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf74ecdbbfc67de6df0331823b22e879c6590cb2" translate="yes" xml:space="preserve">
          <source>If you're building with the CLI, you can write style files in &lt;a href=&quot;http://sass-lang.com/&quot;&gt;sass&lt;/a&gt;, &lt;a href=&quot;http://lesscss.org/&quot;&gt;less&lt;/a&gt;, or &lt;a href=&quot;http://stylus-lang.com/&quot;&gt;stylus&lt;/a&gt; and specify those files in the &lt;code&gt;@&lt;a href=&quot;../api/core/component#styleUrls&quot;&gt;Component.styleUrls&lt;/a&gt;&lt;/code&gt; metadata with the appropriate extensions (&lt;code&gt;.scss&lt;/code&gt;, &lt;code&gt;.less&lt;/code&gt;, &lt;code&gt;.styl&lt;/code&gt;) as in the following example:</source>
          <target state="translated">CLI로 빌드하는 경우 스타일 파일을 &lt;a href=&quot;http://sass-lang.com/&quot;&gt;sass&lt;/a&gt; , &lt;a href=&quot;http://lesscss.org/&quot;&gt;less&lt;/a&gt; 또는 &lt;a href=&quot;http://stylus-lang.com/&quot;&gt;스타일러스로 작성&lt;/a&gt; 하고 다음 과 같이 적절한 확장자 ( &lt;code&gt;.scss&lt;/code&gt; , &lt;code&gt;.less&lt;/code&gt; , &lt;code&gt;.styl&lt;/code&gt; )를 사용 하여 &lt;code&gt;@&lt;a href=&quot;../api/core/component#styleUrls&quot;&gt;Component.styleUrls&lt;/a&gt;&lt;/code&gt; 메타 데이터 에 해당 파일을 지정할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="e80d11e637a28a96a2ac8d8109c31270514af284" translate="yes" xml:space="preserve">
          <source>If you're completely new to Angular, you might want to try the &lt;a href=&quot;https://angular.io/start&quot;&gt;&lt;strong&gt;Try it now&lt;/strong&gt;&lt;/a&gt; quick-start app first. It is based on a ready-made partially-completed project, which you can examine and modify in the StackBlitz interactive development environment, where you can see the results in real time.</source>
          <target state="translated">Angular를 완전히 처음 사용하는 &lt;a href=&quot;https://angular.io/start&quot;&gt;&lt;strong&gt;경우 지금 사용해보기&lt;/strong&gt;&lt;/a&gt; 빠른 시작 앱을 먼저 &lt;strong&gt;사용해 보는 것이&lt;/strong&gt; 좋습니다. 이는 부분적으로 완성 된 기성 프로젝트를 기반으로하며 실시간으로 결과를 볼 수있는 StackBlitz 대화 형 개발 환경에서 검토하고 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c72a02ff92e827a8fbee6caf4e7a5b90fac5a766" translate="yes" xml:space="preserve">
          <source>If you're deploying to a self-managed server or there's no builder for your favorite cloud platform, you can either create a builder that allows you to use the &lt;code&gt;ng deploy&lt;/code&gt; command, or read through this guide to learn how to manually deploy your app.</source>
          <target state="translated">자체 관리 서버에 배포하거나 즐겨 사용하는 클라우드 플랫폼 용 빌더가없는 경우 &lt;code&gt;ng deploy&lt;/code&gt; 명령 을 사용할 수있는 빌더를 작성 하거나이 안내서를 읽고 수동으로 앱을 배치하는 방법을 배울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ef5fa39f7f818bc7d60070f619114bc8c792d6e" translate="yes" xml:space="preserve">
          <source>If you're following along with these code snippets, note that you must import the RxJS observable and operator symbols that appear in those snippets. These &lt;code&gt;ConfigService&lt;/code&gt; imports are typical.</source>
          <target state="translated">이러한 코드 스 니펫을 따르는 경우 해당 스 니펫에 나타나는 RxJS 관찰 가능 및 연산자 기호를 가져와야합니다. 이러한 &lt;code&gt;ConfigService&lt;/code&gt; 가져 오기는 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="5621695378eed2b9f2b258f1815ee171408f7b7e" translate="yes" xml:space="preserve">
          <source>If you're just reading this tutorial to learn about &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt;, you can &lt;a href=&quot;toh-pt6#import-heroes&quot;&gt;skip over&lt;/a&gt; this step. If you're coding along with this tutorial, stay here and add the In-memory Web API now.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 에 대해 배우기 위해이 학습서를 읽고 있다면 이 단계를 &lt;a href=&quot;toh-pt6#import-heroes&quot;&gt;건너 뛸&lt;/a&gt; 수 있습니다 . 이 튜토리얼과 함께 코딩하는 경우 여기에 머무르고 인 메모리 웹 API를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8c2b83a475d5fdd415759000ce764903884f7b3b" translate="yes" xml:space="preserve">
          <source>If you're new to Angular, see the &lt;a href=&quot;https://angular.io/start&quot;&gt;&lt;strong&gt;Getting Started tutorial.&lt;/strong&gt;&lt;/a&gt; The Getting Started tutorial covers the same major topics as this Tour of Heroes&amp;mdash;components, template syntax, routing, services, and accessing data via HTTP&amp;mdash;in a condensed format, following the most current best practices.</source>
          <target state="translated">Angular를 &lt;a href=&quot;https://angular.io/start&quot;&gt;&lt;strong&gt;처음 사용하는 경우 시작하기 자습서를&lt;/strong&gt;&lt;/a&gt; 참조하십시오 &lt;strong&gt;. &lt;/strong&gt;시작하기 자습서는 최신 모범 사례에 따라 압축 된 형식으로 구성 요소, 템플릿 구문, 라우팅, 서비스 및 HTTP를 통한 데이터 액세스와 같은이 Tour of Heroes와 동일한 주요 주제를 다룹니다.</target>
        </trans-unit>
        <trans-unit id="67ea25a303d22f5bebe608e745f2d7c92d9c27bb" translate="yes" xml:space="preserve">
          <source>If you're new to forms, start by reviewing the &lt;a href=&quot;forms&quot;&gt;Forms&lt;/a&gt; and &lt;a href=&quot;reactive-forms&quot;&gt;Reactive Forms&lt;/a&gt; guides.</source>
          <target state="translated">양식을 처음 사용하는 경우 먼저 &lt;a href=&quot;forms&quot;&gt;양식&lt;/a&gt; 및 &lt;a href=&quot;reactive-forms&quot;&gt;반응성 양식&lt;/a&gt; 안내서를 검토하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c7691dbf6e3a09bc8b03a72148e35329112bda1" translate="yes" xml:space="preserve">
          <source>If you're seeing errors, first temporarily &lt;a href=&quot;ivy#opting-out-of-angular-ivy&quot;&gt;turn off Ivy&lt;/a&gt; in your &lt;code&gt;tsconfig.json&lt;/code&gt; and re-start your app.</source>
          <target state="translated">오류가 발생하면 먼저 &lt;code&gt;tsconfig.json&lt;/code&gt; &lt;a href=&quot;ivy#opting-out-of-angular-ivy&quot;&gt;에서 Ivy&lt;/a&gt; 를 일시적 으로 끄고 앱을 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="611869e2c178bc8e06f9bea14da6d2fc3233f1ae" translate="yes" xml:space="preserve">
          <source>If you're still seeing the errors, they are not specific to Ivy. In this case, you may want to consult the &lt;a href=&quot;updating-to-version-11&quot;&gt;general update guide&lt;/a&gt;. If you've opted into any of the new, stricter type-checking settings, you may also want to check out the &lt;a href=&quot;template-typecheck&quot;&gt;template type-checking guide&lt;/a&gt;.</source>
          <target state="translated">여전히 오류가 표시된다면 Ivy에만 국한된 것이 아닙니다. 이 경우 &lt;a href=&quot;updating-to-version-11&quot;&gt;일반 업데이트 가이드&lt;/a&gt; 를 참조 할 수 있습니다 . 새롭고 더 엄격한 유형 검사 설정을 선택한 경우 &lt;a href=&quot;template-typecheck&quot;&gt;템플릿 유형 검사 가이드&lt;/a&gt; 를 확인할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fc7d26ca33d3f9ccba91fcbfc3ae3f0632834a5" translate="yes" xml:space="preserve">
          <source>If you're testing in an incognito window, open a second blank tab. This will keep the incognito and the cache state alive during your test.</source>
          <target state="translated">시크릿 창에서 테스트하는 경우 두 번째 빈 탭을 엽니 다. 테스트 중에 시크릿과 캐시 상태가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="f84e473555acc9f8c96286d3976054a4ce8ac07e" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;&lt;a href=&quot;pathlocationstrategy&quot;&gt;PathLocationStrategy&lt;/a&gt;&lt;/code&gt;, you must provide a &lt;a href=&quot;app_base_href&quot;&gt;&lt;code&gt;APP_BASE_HREF&lt;/code&gt;&lt;/a&gt; or add a &lt;code&gt;&amp;lt;base href&amp;gt;&lt;/code&gt; element to the document.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;pathlocationstrategy&quot;&gt;PathLocationStrategy&lt;/a&gt;&lt;/code&gt; 를 사용 하는 경우 &lt;a href=&quot;app_base_href&quot;&gt; &lt;code&gt;APP_BASE_HREF&lt;/code&gt; &lt;/a&gt; 를 제공 하거나 문서에 &lt;code&gt;&amp;lt;base href&amp;gt;&lt;/code&gt; 요소를 추가 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e626c7acd05b782e31724065bc7d5d37adec57da" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;&lt;a href=&quot;pathlocationstrategy&quot;&gt;PathLocationStrategy&lt;/a&gt;&lt;/code&gt;, you must provide a &lt;a href=&quot;app_base_href&quot;&gt;&lt;code&gt;APP_BASE_HREF&lt;/code&gt;&lt;/a&gt; or add a base element to the document. This URL prefix that will be preserved when generating and recognizing URLs.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;pathlocationstrategy&quot;&gt;PathLocationStrategy&lt;/a&gt;&lt;/code&gt; 를 사용 하는 경우 &lt;a href=&quot;app_base_href&quot;&gt; &lt;code&gt;APP_BASE_HREF&lt;/code&gt; &lt;/a&gt; 를 제공 하거나 문서에 기본 요소를 추가 해야합니다 . 이 URL 접두사는 URL을 생성하고 인식 할 때 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="3f30bbc0759dc1d64fa256c2ae612a954da0aa58" translate="yes" xml:space="preserve">
          <source>If you're using the CLI, &lt;code&gt;ng update&lt;/code&gt; should &lt;a href=&quot;migration-module-with-providers&quot;&gt;migrate your code automatically&lt;/a&gt;. If you're not using the CLI, you can add any missing generic types to your application manually. For example:</source>
          <target state="translated">CLI를 사용하는 경우 &lt;code&gt;ng update&lt;/code&gt; 는 &lt;a href=&quot;migration-module-with-providers&quot;&gt;코드를 자동으로 마이그레이션해야합니다&lt;/a&gt; . CLI를 사용하지 않는 경우 누락 된 일반 유형을 애플리케이션에 수동으로 추가 할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="fa080613189cdefb468866b8c597532b9871a918" translate="yes" xml:space="preserve">
          <source>If you've never published a package in npm before, you must create a user account. Read more in &lt;a href=&quot;https://docs.npmjs.com/getting-started/publishing-npm-packages&quot;&gt;Publishing npm Packages&lt;/a&gt;.</source>
          <target state="translated">npm에 패키지를 게시 한 적이 없다면 사용자 계정을 만들어야합니다. &lt;a href=&quot;https://docs.npmjs.com/getting-started/publishing-npm-packages&quot;&gt;npm 패키지 게시&lt;/a&gt; 에서 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="192e8b89a85f5cc6081ab74c317c7b8d1b4b6c1a" translate="yes" xml:space="preserve">
          <source>If your Browserslist configuration includes support for any legacy browsers, the build target in the TypeScript configuration determines whether the build will support differential loading.</source>
          <target state="translated">Browserslist 구성에 레거시 브라우저에 대한 지원이 포함 된 경우 TypeScript 구성의 빌드 대상은 빌드가 차등로드를 지원할지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="7b10a12a2f9c3567ac4e099dd03881046723129f" translate="yes" xml:space="preserve">
          <source>If your app had many feature areas, the app component trees might look like this:</source>
          <target state="translated">앱에 많은 기능 영역이있는 경우 앱 구성 요소 트리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c4813331be931a7f2a2b0d56270ac5204b124311" translate="yes" xml:space="preserve">
          <source>If your app happens to bootstrap or dynamically load a component &lt;em&gt;by type&lt;/em&gt; in some other manner, you must add it to &lt;code&gt;entryComponents&lt;/code&gt; explicitly.</source>
          <target state="translated">앱이 다른 방식으로 &lt;em&gt;유형별&lt;/em&gt; 로 구성 요소를 부트 스트랩하거나 동적으로로드하는 경우 명시 적으로 &lt;code&gt;entryComponents&lt;/code&gt; 에 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9aae5606fbeadd60c35706fd07fdcf7e6df68610" translate="yes" xml:space="preserve">
          <source>If your app uses routing, you need to teach the server to always return &lt;code&gt;index.html&lt;/code&gt; when the user asks for an HTML page for reasons explained in the &lt;a href=&quot;deployment#fallback&quot;&gt;Deployment&lt;/a&gt; guide.</source>
          <target state="translated">앱에서 라우팅을 사용하는 경우 사용자가 &lt;a href=&quot;deployment#fallback&quot;&gt;배포&lt;/a&gt; 가이드에 설명 된 이유로 HTML 페이지를 요청할 때 서버가 항상 &lt;code&gt;index.html&lt;/code&gt; 을 반환하도록 지시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5042fa1f08d3dcd4e1ea2367cfbbc1aaa6404362" translate="yes" xml:space="preserve">
          <source>If your backend service uses different names for the XSRF token cookie or header, use &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientxsrfmodule#withOptions&quot;&gt;HttpClientXsrfModule.withOptions()&lt;/a&gt;&lt;/code&gt; to override the defaults.</source>
          <target state="translated">백엔드 서비스가 XSRF 토큰 쿠키 또는 헤더에 다른 이름을 사용하는 경우 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientxsrfmodule#withOptions&quot;&gt;HttpClientXsrfModule.withOptions()&lt;/a&gt;&lt;/code&gt; 를 사용 하여 기본값을 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="95cc76e94f96c5568597c8ef92eb23b8f2b51d0e" translate="yes" xml:space="preserve">
          <source>If your builder calls another builder, it may need to read a passed target string. You can parse this string into an object by using the &lt;code&gt;targetFromTargetString()&lt;/code&gt; utility function from &lt;code&gt;@angular-devkit/architect&lt;/code&gt;.</source>
          <target state="translated">빌더가 다른 빌더를 호출하는 경우 전달 된 대상 문자열을 읽어야합니다. &lt;code&gt;@angular-devkit/architect&lt;/code&gt; 의 &lt;code&gt;targetFromTargetString()&lt;/code&gt; 유틸리티 함수를 사용하여이 문자열을 객체로 구문 분석 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="875f3a37dffcb0d70c53bfe9801cfac977a1c2c0" translate="yes" xml:space="preserve">
          <source>If your builder returns an Observable, it should clean up in the teardown logic of that Observable.</source>
          <target state="translated">빌더가 Observable을 리턴하면 해당 Observable의 분류 로직에서 정리해야합니다.</target>
        </trans-unit>
        <trans-unit id="f683916cf8a11dda2039edae9c97697849fd354d" translate="yes" xml:space="preserve">
          <source>If your installation and setup was successful, you should see a page similar to the following.</source>
          <target state="translated">설치 및 설정이 성공하면 다음과 유사한 페이지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="333ae1afb3d296c7877eaffccff73532b882ea8a" translate="yes" xml:space="preserve">
          <source>If your library code or its templates depend on other libraries (such a Angular Material, for instance), you must configure your library with those dependencies.</source>
          <target state="translated">라이브러리 코드 또는 템플릿이 다른 라이브러리 (예 : Angular Material)에 의존하는 경우 해당 종속성으로 라이브러리를 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="57fc0eeed0d306a2db798e20abb14abed289e8cc" translate="yes" xml:space="preserve">
          <source>If your library code or its templates depend on other libraries (such as Angular Material, for instance), you must configure your library with those dependencies.</source>
          <target state="translated">라이브러리 코드 또는 템플릿이 다른 라이브러리 (예 : Angular Material)에 의존하는 경우 해당 종속성으로 라이브러리를 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="14dc0564ebd063d8a83bbddec3a63a2e4959a0d9" translate="yes" xml:space="preserve">
          <source>If your library provides optional services that might not be used by all client applications, support proper tree-shaking for that case by using the &lt;a href=&quot;lightweight-injection-tokens&quot;&gt;lightweight token design pattern&lt;/a&gt;.</source>
          <target state="translated">라이브러리가 모든 클라이언트 애플리케이션에서 사용되지 않을 수있는 선택적 서비스를 제공하는 경우 &lt;a href=&quot;lightweight-injection-tokens&quot;&gt;경량 토큰 디자인 패턴&lt;/a&gt; 을 사용하여 해당 사례에 대해 적절한 트리 쉐이킹을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="3af6c56bc2cbb8e4946e71f47ee9c9fb9c31b970" translate="yes" xml:space="preserve">
          <source>If your structural directive provides a context to the instantiated template, you can properly type it inside the template by providing a static &lt;code&gt;ngTemplateContextGuard&lt;/code&gt; function. The following snippet shows an example of such a function.</source>
          <target state="translated">구조적 지시문이 인스턴스화 된 템플릿에 컨텍스트를 제공하는 경우 정적 &lt;code&gt;ngTemplateContextGuard&lt;/code&gt; 함수를 제공하여 템플릿 내에 적절하게 입력 할 수 있습니다 . 다음 스 니펫은 이러한 함수의 예를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="bc86b4b32c1ba7ddb5fb732813d619704067dcce" translate="yes" xml:space="preserve">
          <source>If your template needs to display different text messages depending on the value of a variable, you need to translate all of those alternative text messages.</source>
          <target state="translated">변수 값에 따라 템플릿에 다른 문자 메시지가 표시되어야하는 경우 대체 문자 메시지를 모두 번역해야합니다.</target>
        </trans-unit>
        <trans-unit id="e6e3128717267a5e06be8d6ef96ba80886bdd514" translate="yes" xml:space="preserve">
          <source>If your tests aren't working as you expect them to, you can inspect and debug them in the browser.</source>
          <target state="translated">테스트가 예상대로 작동하지 않는 경우 브라우저에서 검사하고 디버깅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e93ea9b6cea140a6464d1b0779bee5174f1506aa" translate="yes" xml:space="preserve">
          <source>If, for some reason, you are not using an &lt;code&gt;@nguniversal/*-engine&lt;/code&gt; package, you may need to handle it yourself.</source>
          <target state="translated">어떤 이유로 &lt;code&gt;@nguniversal/*-engine&lt;/code&gt; 패키지를 사용하지 않는 경우 직접 처리해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64ff3add03a839c971e70ed84614968956996987" translate="yes" xml:space="preserve">
          <source>Ignore the warnings.</source>
          <target state="translated">경고를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="b2a8f807164b329c0df9d6e96e08d4ec7fe93e8e" translate="yes" xml:space="preserve">
          <source>Ignore: do nothing.</source>
          <target state="translated">무시하십시오 : 아무것도하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="852440e173c82baa5ce49593ea14c314bd9d03ea" translate="yes" xml:space="preserve">
          <source>Ignores any animations that are performed when the user first opens or navigates to this page. The filter narrows what is already there, so it assumes that any HTML elements to be animated already exist in the DOM.</source>
          <target state="translated">사용자가이 페이지를 처음 열거 나 탐색 할 때 수행되는 애니메이션을 무시합니다. 이 필터는 이미 존재하는 것을 좁히기 때문에 애니메이션을 생성 할 HTML 요소가 DOM에 이미 존재한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="8b821c78f2fce2425c050c6804d937d1ae4b77c5" translate="yes" xml:space="preserve">
          <source>Illustrating the &quot;pristine&quot; state</source>
          <target state="translated">&quot;깨끗한&quot;상태 설명</target>
        </trans-unit>
        <trans-unit id="e535f7686926290a845fe4d42be0c97df203fcb9" translate="yes" xml:space="preserve">
          <source>Image compression</source>
          <target state="translated">이미지 압축</target>
        </trans-unit>
        <trans-unit id="cd2057f0131f9a4e6f1956e4114499c55873edf5" translate="yes" xml:space="preserve">
          <source>Image dimensions</source>
          <target state="translated">이미지 치수</target>
        </trans-unit>
        <trans-unit id="132d44a4489514731c7a32cfff5792dd08c9e636" translate="yes" xml:space="preserve">
          <source>Image location</source>
          <target state="translated">이미지 위치</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="9ae8f90b310c8e0aba39397a83acf0bf54cb8fae" translate="yes" xml:space="preserve">
          <source>Images and fonts directly under the configured &lt;code&gt;outputPath&lt;/code&gt; (by default &lt;code&gt;./dist/&amp;lt;project-name&amp;gt;/&lt;/code&gt;) or &lt;code&gt;resourcesOutputPath&lt;/code&gt;. See &lt;a href=&quot;cli/build&quot;&gt;&lt;code&gt;ng build&lt;/code&gt;&lt;/a&gt; for more information about these options.</source>
          <target state="translated">직접 구성에 따라 이미지와 글꼴 &lt;code&gt;outputPath&lt;/code&gt; (기본적으로 &lt;code&gt;./dist/&amp;lt;project-name&amp;gt;/&lt;/code&gt; 또는) &lt;code&gt;resourcesOutputPath&lt;/code&gt; . 이러한 옵션에 대한 자세한 내용은 &lt;a href=&quot;cli/build&quot;&gt; &lt;code&gt;ng build&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b68d291250edab27a9181298df02309fd2e3984d" translate="yes" xml:space="preserve">
          <source>Images should be specified in an &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">이미지는 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 태그 로 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f197407a881860639854b84140d3e15ce892c317" translate="yes" xml:space="preserve">
          <source>Imagine an application that helps the &lt;em&gt;Hero Employment Agency&lt;/em&gt; run its business. Heroes need work and the agency finds crises for them to solve.</source>
          <target state="translated">&lt;em&gt;Hero Employment Agency&lt;/em&gt; 가 사업을 운영 하는 데 도움이되는 응용 프로그램을 상상해보십시오 . 영웅은 일이 필요하고 대행사는 해결해야 할 위기를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="480c3b6df4de5ea5f608379d1979bb198fa722ac" translate="yes" xml:space="preserve">
          <source>Imagine one branch of a component hierarchy: &lt;em&gt;Alice&lt;/em&gt; -&amp;gt; &lt;em&gt;Barry&lt;/em&gt; -&amp;gt; &lt;em&gt;Carol&lt;/em&gt;. Both &lt;em&gt;Alice&lt;/em&gt; and &lt;em&gt;Barry&lt;/em&gt; implement the `Parent' class interface.</source>
          <target state="translated">컴포넌트 계층의 한 가지 분기를 상상해보십시오. &lt;em&gt;Alice-&lt;/em&gt; &amp;gt; &lt;em&gt;Barry-&lt;/em&gt; &amp;gt; &lt;em&gt;Carol&lt;/em&gt; . &lt;em&gt;Alice&lt;/em&gt; 와 &lt;em&gt;Barry&lt;/em&gt; 는 모두 부모 클래스 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="926d786c1286080b30759a09b32fbae972285d95" translate="yes" xml:space="preserve">
          <source>Imagine that &lt;code&gt;LoggerService&lt;/code&gt; had a large API, much larger than the actual three methods and a property. You might want to shrink that API surface to just the members you actually need. In this example, the &lt;code&gt;MinimalLogger&lt;/code&gt;&lt;a href=&quot;dependency-injection-in-action#class-interface&quot;&gt;class-interface&lt;/a&gt; reduces the API to two members:</source>
          <target state="translated">&lt;code&gt;LoggerService&lt;/code&gt; 에 실제 세 가지 메소드 및 특성보다 훨씬 큰 대형 API가 있다고 가정하십시오 . 해당 API 표면을 실제로 필요한 멤버로 축소 할 수 있습니다. 이 예제에서 &lt;code&gt;MinimalLogger&lt;/code&gt; &lt;a href=&quot;dependency-injection-in-action#class-interface&quot;&gt;클래스 인터페이스&lt;/a&gt; 는 API를 두 멤버로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="4a368b18b59eaf096cd5d55aaf4c6822025e3a9d" translate="yes" xml:space="preserve">
          <source>Imagine that in the child component, you had a different value, &lt;code&gt;🍁&lt;/code&gt; (maple leaf) but you wanted to use the parent's value instead. This is when you'd use &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt;:</source>
          <target state="translated">자식 구성 요소에서 다른 값인 &lt;code&gt;🍁&lt;/code&gt; (매플 리프)을 가졌지 만 대신 부모의 값을 사용하려고 한다고 상상해보십시오 . &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; 사용할 때입니다 .</target>
        </trans-unit>
        <trans-unit id="2ee7873715fc3090e9ad491d7196215a12eb7e13" translate="yes" xml:space="preserve">
          <source>Imagine that you don't want to inject &lt;code&gt;UserService&lt;/code&gt; directly into &lt;code&gt;HeroService&lt;/code&gt;, because you don't want to complicate that service with security-sensitive information. &lt;code&gt;HeroService&lt;/code&gt; won't have direct access to the user information to decide who is authorized and who isn't.</source>
          <target state="translated">보안에 민감한 정보로 서비스를 복잡하게 만들고 싶지 않기 때문에 &lt;code&gt;UserService&lt;/code&gt; 를 &lt;code&gt;HeroService&lt;/code&gt; 에 직접 삽입하고 싶지 않다고 상상해보십시오 . &lt;code&gt;HeroService&lt;/code&gt; 는 권한이있는 사람과 권한이없는 사람을 결정하기 위해 사용자 정보에 직접 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d9912f3cc2a458038df837cf86a4c8e01af50ffb" translate="yes" xml:space="preserve">
          <source>Imagine the effort to disable these distractions, just to prove a point that can be made satisfactorily with a &lt;em&gt;test host&lt;/em&gt; like this one:</source>
          <target state="translated">다음과 같은 &lt;em&gt;테스트 호스트&lt;/em&gt; 로 만족스럽게 만들 수있는 포인트를 증명하기 위해 이러한 방해 요소를 비활성화하려는 노력을 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="0dcb05aedf3662e3047235d20c9b3a53209ea247" translate="yes" xml:space="preserve">
          <source>Imagine the following malicious content.</source>
          <target state="translated">다음과 같은 악성 콘텐츠를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="70af22099196223b8485c95684bbf8824a9afa2b" translate="yes" xml:space="preserve">
          <source>Immutability</source>
          <target state="translated">Immutability</target>
        </trans-unit>
        <trans-unit id="6e5a32a1bd41d5b21404f176ae361427aff05142" translate="yes" xml:space="preserve">
          <source>Immutable</source>
          <target state="translated">Immutable</target>
        </trans-unit>
        <trans-unit id="569ee13fa32b96c143a875b5c890f64353650f46" translate="yes" xml:space="preserve">
          <source>Implement lifecycle hook interfaces</source>
          <target state="translated">수명주기 후크 인터페이스 구현</target>
        </trans-unit>
        <trans-unit id="ffb9191c0762a011976a2b595a59e6ed196362d4" translate="yes" xml:space="preserve">
          <source>Implement the &lt;a href=&quot;../api/core/pipetransform&quot;&gt;&lt;code&gt;PipeTransform&lt;/code&gt;&lt;/a&gt; interface in your custom pipe class to perform the transformation.</source>
          <target state="translated">사용자 지정 파이프 클래스에서 &lt;a href=&quot;../api/core/pipetransform&quot;&gt; &lt;code&gt;PipeTransform&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하여 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e3166f82b7179b9d5e343a6c1eee18f1c699887d" translate="yes" xml:space="preserve">
          <source>Implement this callback to add a class to an element in the DOM.</source>
          <target state="translated">이 콜백을 구현하여 DOM의 요소에 클래스를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="577c7009c5183eabdac20b5ae98cf2ede05d4833" translate="yes" xml:space="preserve">
          <source>Implement this callback to add a comment to the DOM of the host element.</source>
          <target state="translated">이 콜백을 구현하여 호스트 요소의 DOM에 주석을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="03cf7ca65ecc8c31118b1e6114f8595bc1760a21" translate="yes" xml:space="preserve">
          <source>Implement this callback to add text to the DOM of the host element.</source>
          <target state="translated">이 콜백을 구현하여 호스트 요소의 DOM에 텍스트를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f5bc42dfa7008f7e03d763d440ce48675c0a4f5b" translate="yes" xml:space="preserve">
          <source>Implement this callback to create an instance of the host element.</source>
          <target state="translated">이 콜백을 구현하여 호스트 요소의 인스턴스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a0d9d7c045b4660c412fe767ad1945d44a190961" translate="yes" xml:space="preserve">
          <source>Implement this callback to destroy the renderer or the host element.</source>
          <target state="translated">이 콜백을 구현하여 렌더러 또는 호스트 요소를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="1c9baa60b18459f8baab069c307bd286cedb293c" translate="yes" xml:space="preserve">
          <source>Implement this callback to get the next sibling node of a given node in the host element's DOM.</source>
          <target state="translated">이 콜백을 구현하여 호스트 요소의 DOM에서 지정된 노드의 다음 형제 노드를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="fdeb7236f29bdbcca4a28a7f60641e8db151e4d5" translate="yes" xml:space="preserve">
          <source>Implement this callback to get the parent of a given node in the host element's DOM.</source>
          <target state="translated">호스트 요소의 DOM에서 주어진 노드의 부모를 얻기 위해이 콜백을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="134030fd845fadd1044c12a523dec32ffc73a9fc" translate="yes" xml:space="preserve">
          <source>Implement this callback to insert a child node at a given position in a parent node in the host element DOM.</source>
          <target state="translated">호스트 요소 DOM의 상위 노드에서 지정된 위치에 하위 노드를 삽입하려면이 콜백을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="bba6d890df9d055ea2386440926e0760d35d6b14" translate="yes" xml:space="preserve">
          <source>Implement this callback to prepare an element to be bootstrapped as a root element, and return the element instance.</source>
          <target state="translated">이 콜백을 구현하여 루트 요소로 부트 스트랩 할 요소를 준비하고 요소 인스턴스를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="ca1ed2bafa9cae106f863767732584ec8416ebed" translate="yes" xml:space="preserve">
          <source>Implement this callback to remove a child node from the host element's DOM.</source>
          <target state="translated">호스트 요소의 DOM에서 자식 노드를 제거하려면이 콜백을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="d323d4a580fdb4dc8916989b8e38d19f0831ebb4" translate="yes" xml:space="preserve">
          <source>Implement this callback to remove a class from an element in the DOM.</source>
          <target state="translated">이 콜백을 구현하여 DOM의 요소에서 클래스를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="50a573388aabcf7019870235d46465e72add8981" translate="yes" xml:space="preserve">
          <source>Implement this callback to remove an attribute from an element in the DOM.</source>
          <target state="translated">이 콜백을 구현하여 DOM의 요소에서 속성을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="36eb90bfa5ed19d7a1a9ae6ff464b8e1d00e7822" translate="yes" xml:space="preserve">
          <source>Implement this callback to remove the value from a CSS style for an element in the DOM.</source>
          <target state="translated">이 콜백을 구현하여 DOM의 요소에 대한 CSS 스타일에서 값을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="555fb860b7a59c008619fb082a93ee194e1886c7" translate="yes" xml:space="preserve">
          <source>Implement this callback to set a CSS style for an element in the DOM.</source>
          <target state="translated">이 콜백을 구현하여 DOM의 요소에 CSS 스타일을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="7b1aa6bced0b52983533c898e87d4ea15fb2264a" translate="yes" xml:space="preserve">
          <source>Implement this callback to set an attribute value for an element in the DOM.</source>
          <target state="translated">이 콜백을 구현하여 DOM의 요소에 대한 속성 값을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="e0fc11b0c038ee4ed0794e274a3324cb43d219c5" translate="yes" xml:space="preserve">
          <source>Implement this callback to set the value of a node in the host element.</source>
          <target state="translated">이 콜백을 구현하여 호스트 요소의 노드 값을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="bb15ad08125f75b3cf386d55995af65d420d6eee" translate="yes" xml:space="preserve">
          <source>Implement this callback to set the value of a property of an element in the DOM.</source>
          <target state="translated">이 콜백을 구현하여 DOM에서 요소의 속성 값을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="59c3759a3daa56cba4ea89b70baf1e4097d64636" translate="yes" xml:space="preserve">
          <source>Implement this callback to start an event listener.</source>
          <target state="translated">이 콜백을 구현하여 이벤트 리스너를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="4a6751f61ff0fba38731f86b6104c29d3704780e" translate="yes" xml:space="preserve">
          <source>Implement this interface to create a custom form control directive that integrates with Angular forms.</source>
          <target state="translated">Angular 양식과 통합되는 사용자 정의 양식 제어 지시문을 작성하려면이 인터페이스를 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="21c4d35ad75af1e5854d9c5288b3b50d18350a45" translate="yes" xml:space="preserve">
          <source>Implementing Custom Async Validator</source>
          <target state="translated">사용자 정의 비동기 검사기 구현</target>
        </trans-unit>
        <trans-unit id="c0bdb7edcf97857a7cf5d9afdad73552296e66b0" translate="yes" xml:space="preserve">
          <source>Implementing a custom async validator</source>
          <target state="translated">사용자 지정 비동기 유효성 검사기 구현</target>
        </trans-unit>
        <trans-unit id="28243ccf2d1e04cdb0f4eea07160bd6fba54a67c" translate="yes" xml:space="preserve">
          <source>Implements Angular's core functionality, low-level services, and utilities.</source>
          <target state="translated">Angular의 핵심 기능, 저수준 서비스 및 유틸리티를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="1740cef38e5186da8de62ac9e31ab0bf9006ec4e" translate="yes" xml:space="preserve">
          <source>Implements Angular's custom-element API, which enables you to package components as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements&quot;&gt;custom elements&lt;/a&gt;.</source>
          <target state="translated">Angular의 커스텀 엘리먼트 API를 구현하여 컴포넌트를 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements&quot;&gt;커스텀 엘리먼트&lt;/a&gt; 로 패키징 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18cc1a97ca823e213e9814192dbdd3119bf93a10" translate="yes" xml:space="preserve">
          <source>Implements a domain-specific language (DSL) for defining web animation sequences for HTML elements as multiple transformations over time.</source>
          <target state="translated">HTML 요소에 대한 웹 애니메이션 시퀀스를 시간에 따른 다중 변환으로 정의하기위한 DSL (Domain-Specific Language)을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="975968eede10c072691f7af0d54dd2799c41ab94" translate="yes" xml:space="preserve">
          <source>Implements a service worker for Angular apps. Adding a service worker to an Angular app is one of the steps for turning it into a Progressive Web App (also known as a PWA).</source>
          <target state="translated">Angular 앱의 서비스 워커를 구현합니다. 서비스 워커를 Angular 앱에 추가하는 것은이를 프로그레시브 웹 앱 (PWA라고도 함)으로 전환하는 단계 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="f7bebe0232fe9f34fb464a7863f9d6804c6723a6" translate="yes" xml:space="preserve">
          <source>Implements a set of directives and providers to communicate with native DOM elements when building forms to capture user input.</source>
          <target state="translated">사용자 입력을 캡처하기 위해 양식을 작성할 때 기본 DOM 요소와 통신하도록 지시문 및 제공자 세트를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="4b32fab568e6f74138e5d102955133034be90ff5" translate="yes" xml:space="preserve">
          <source>Implements an &lt;code&gt;ngDoCheck()&lt;/code&gt; method with custom change detection. See how often Angular calls this hook and watch it post changes to a log.</source>
          <target state="translated">사용자 지정 변경 감지를 사용 하여 &lt;code&gt;ngDoCheck()&lt;/code&gt; 메소드를 구현합니다 . Angular가이 후크를 호출하는 빈도를 확인하고 로그 변경 사항을 게시하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5bd7689d46e5b12bf1f904331f09df5b9e867cb3" translate="yes" xml:space="preserve">
          <source>Implements an HTTP client API for Angular apps that relies on the &lt;code&gt;XMLHttpRequest&lt;/code&gt; interface exposed by browsers.</source>
          <target state="translated">브라우저가 공개 하는 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 인터페이스 를 사용하는 Angular 앱용 HTTP 클라이언트 API를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="0f6cbc91e3625eeea332217fda3f6cdf01f146c8" translate="yes" xml:space="preserve">
          <source>Implements an iterable interface, therefore it can be used in both ES6 javascript &lt;code&gt;for (var i of items)&lt;/code&gt; loops as well as in Angular templates with &lt;code&gt;*&lt;a href=&quot;../common/ngforof&quot;&gt;ngFor&lt;/a&gt;=&quot;let i of myList&quot;&lt;/code&gt;.</source>
          <target state="translated">반복 가능한 인터페이스를 구현하므로 ES6 javascript &lt;code&gt;for (var i of items)&lt;/code&gt; 루프와 &lt;code&gt;*&lt;a href=&quot;../common/ngforof&quot;&gt;ngFor&lt;/a&gt;=&quot;let i of myList&quot;&lt;/code&gt; 가 있는 Angular 템플릿 모두에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce097c59bce28c3d2b175a67db71e336843e0494" translate="yes" xml:space="preserve">
          <source>Implements basic Angular directives and pipes, such as NgIf, NgForOf, DecimalPipe, and so on.</source>
          <target state="translated">NgIf, NgForOf, DecimalPipe 등과 같은 기본 각도 지시문 및 파이프를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="2351e708261f2053ab218553d2efe10bd33f3716" translate="yes" xml:space="preserve">
          <source>Implements fundamental Angular framework functionality, including directives and pipes, location services used in routing, HTTP services, localization support, and so on.</source>
          <target state="translated">지시문 및 파이프, 라우팅에 사용되는 위치 서비스, HTTP 서비스, 현지화 지원 등을 포함한 기본적인 Angular 프레임 워크 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="58efc13dfdbddc59a6ed790f4530168ed9884583" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;ngDoCheck()&lt;/code&gt; method with custom change detection. Watch the hook post changes to a log to see how often Angular calls this hook.</source>
          <target state="translated">사용자 지정 변경 감지와 함께 &lt;code&gt;ngDoCheck()&lt;/code&gt; 메서드를 구현합니다 . Angular가이 후크를 호출하는 빈도를 확인하려면 후크 포스트가 로그로 변경되는 것을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d9bdfd53eb804076b673eff6ed90636bddf4f862" translate="yes" xml:space="preserve">
          <source>Implements the Angular Router service , which enables navigation from one view to the next as users perform application tasks.</source>
          <target state="translated">사용자가 응용 프로그램 작업을 수행 할 때 한보기에서 다음보기로 탐색 할 수있는 Angular Router 서비스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a92aec084fd1d304417af86c26c892bf2549ddb2" translate="yes" xml:space="preserve">
          <source>Implements the functionality needed for a custom element.</source>
          <target state="translated">사용자 정의 요소에 필요한 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="2582b4c30d27c0a060dad9d9e2d031711195f67c" translate="yes" xml:space="preserve">
          <source>Implicit, created by directives</source>
          <target state="translated">암시 적, 지시문에 의해 생성됨</target>
        </trans-unit>
        <trans-unit id="26fb786f09465d1d0559a46e5842f496183733aa" translate="yes" xml:space="preserve">
          <source>Implied by promise resolution.</source>
          <target state="translated">약속 해결에 의해 암시됩니다.</target>
        </trans-unit>
        <trans-unit id="568d13bdb851bce85938a6391267ed336fc53a69" translate="yes" xml:space="preserve">
          <source>Import &lt;a href=&quot;ngmodule-faq#q-browser-vs-common-module&quot;&gt;BrowserModule&lt;/a&gt; only in the root &lt;code&gt;AppModule&lt;/code&gt;.</source>
          <target state="translated">루트 &lt;code&gt;AppModule&lt;/code&gt; 에서만 &lt;a href=&quot;ngmodule-faq#q-browser-vs-common-module&quot;&gt;BrowserModule을&lt;/a&gt; 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="0f742f1b5efa266c3528e372a7535ae4f8d7abfb" translate="yes" xml:space="preserve">
          <source>Import &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;@angular/common/&lt;a href=&quot;../api/common/http&quot;&gt;http&lt;/a&gt;&lt;/code&gt; package.</source>
          <target state="translated">&lt;code&gt;@angular/common/&lt;a href=&quot;../api/common/http&quot;&gt;http&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/common/http&quot;&gt;http&lt;/a&gt; 패키지 에서 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="c480c63f6212aebe6f4eeb21595cbebe365b2e21" translate="yes" xml:space="preserve">
          <source>Import &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;@angular/common/&lt;a href=&quot;../api/common/http&quot;&gt;http&lt;/a&gt;&lt;/code&gt; package at the top of the file with the other imports. As there are a number of other imports, this code snippet omits them for brevity. Be sure to leave the existing imports in place.</source>
          <target state="translated">다른 가져 오기와 함께 파일 맨 위에 있는 &lt;code&gt;@angular/common/&lt;a href=&quot;../api/common/http&quot;&gt;http&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/common/http&quot;&gt;http&lt;/a&gt; 패키지에서 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt; 을 가져 옵니다. 다른 여러 가져 오기가 있으므로이 코드 스 니펫은 간결함을 위해 생략합니다. 기존 수입품은 그대로 두십시오.</target>
        </trans-unit>
        <trans-unit id="b4a640252aff8611ffd100e6d553596024dc2232" translate="yes" xml:space="preserve">
          <source>Import &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;@angular/common/&lt;a href=&quot;../api/common/http&quot;&gt;http&lt;/a&gt;&lt;/code&gt; package.</source>
          <target state="translated">&lt;code&gt;@angular/common/&lt;a href=&quot;../api/common/http&quot;&gt;http&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/common/http&quot;&gt;http&lt;/a&gt; 패키지 에서 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt; 을 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="db1318647a94b0878ebad6624d74ed324806e391" translate="yes" xml:space="preserve">
          <source>Import &lt;code&gt;&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; in the child component class:</source>
          <target state="translated">하위 구성 요소 클래스에서 &lt;code&gt;&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; 가져 오기 :</target>
        </trans-unit>
        <trans-unit id="15c4f41e277258769c0a0df5aa685cd02c57d1f7" translate="yes" xml:space="preserve">
          <source>Import &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;@angular/forms&lt;/code&gt; if your components have &lt;code&gt;[(&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;)]&lt;/code&gt; two-way binding expressions.</source>
          <target state="translated">컴포넌트에 &lt;code&gt;[(&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;)]&lt;/code&gt; &lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt; )] 양방향 바인딩 표현식 이있는 경우 &lt;code&gt;@angular/forms&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; 을 가져 오십시오 .</target>
        </trans-unit>
        <trans-unit id="8d73845fe8377c59bacd2d1ab426a96ffca230bf" translate="yes" xml:space="preserve">
          <source>Import &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; to use &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; 을 사용하기 위해 &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 가져 오기</target>
        </trans-unit>
        <trans-unit id="78a45ea4a26ee0f0dd7af27e0a27299f67d70efd" translate="yes" xml:space="preserve">
          <source>Import &lt;code&gt;&lt;a href=&quot;../api/platform-browser/animations/browseranimationsmodule&quot;&gt;BrowserAnimationsModule&lt;/a&gt;&lt;/code&gt;, which introduces the animation capabilities into your Angular root application module.</source>
          <target state="translated">애니메이션 기능을 Angular 루트 응용 프로그램 모듈에 도입하는 &lt;code&gt;&lt;a href=&quot;../api/platform-browser/animations/browseranimationsmodule&quot;&gt;BrowserAnimationsModule&lt;/a&gt;&lt;/code&gt; 을 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="352357fecdfec53327503352c52cf046f13b707c" translate="yes" xml:space="preserve">
          <source>Import &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/router/parammap&quot;&gt;ParamMap&lt;/a&gt;&lt;/code&gt; to your component.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/router/parammap&quot;&gt;ParamMap&lt;/a&gt;&lt;/code&gt; 을 구성 요소로 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="9bbd5188871ef20fa807f263a6fcc71ea078f98d" translate="yes" xml:space="preserve">
          <source>Import &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;@angular/router&lt;/code&gt; package, and the &lt;code&gt;products&lt;/code&gt; array from &lt;code&gt;../products&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@angular/router&lt;/code&gt; 패키지 에서 &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; 를 가져 &lt;code&gt;../products&lt;/code&gt; 에서 &lt;code&gt;products&lt;/code&gt; 배열을 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="6f12799296738ca1edfd6212d2a0f1ed1c4bb38b" translate="yes" xml:space="preserve">
          <source>Import &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/router/routes&quot;&gt;Routes&lt;/a&gt;&lt;/code&gt; into your routing module.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/router/routes&quot;&gt;Routes&lt;/a&gt;&lt;/code&gt; 를 라우팅 모듈로 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="f9dc372cd0ffd6143fbc7365768919e6aaef1084" translate="yes" xml:space="preserve">
          <source>Import &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;@angular/router&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@angular/router&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; 가져 오기</target>
        </trans-unit>
        <trans-unit id="438e3ddee4912def34ac11f57a93ce076783f46e" translate="yes" xml:space="preserve">
          <source>Import &lt;code&gt;&lt;a href=&quot;api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;@angular/core&lt;/code&gt;.</source>
          <target state="translated">가져 오기 &lt;code&gt;&lt;a href=&quot;api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;@angular/core&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba4323afb2767c261fa10794db535d2c4b34bb19" translate="yes" xml:space="preserve">
          <source>Import &lt;code&gt;&lt;a href=&quot;api/core/output&quot;&gt;Output&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;@angular/core&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;@angular/core&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;api/core/output&quot;&gt;Output&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; 가져 오기 :</target>
        </trans-unit>
        <trans-unit id="29ea81b3ca52ff6ccaed6e2c7a98e218c8668bbe" translate="yes" xml:space="preserve">
          <source>Import &lt;code&gt;&lt;a href=&quot;router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; to use the Router service in your app. For more usage information, see the &lt;a href=&quot;../guide/router&quot;&gt;Routing and Navigation&lt;/a&gt; guide.</source>
          <target state="translated">앱에서 라우터 서비스를 사용하려면 &lt;code&gt;&lt;a href=&quot;router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; 을 가져 옵니다 . 자세한 사용법은 &lt;a href=&quot;../guide/router&quot;&gt;Routing and Navigation&lt;/a&gt; 안내서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="378da8def68b035dc56d150d5c3f316640430460" translate="yes" xml:space="preserve">
          <source>Import &lt;code&gt;AppServerModuleNgFactory&lt;/code&gt; from the &lt;code&gt;app.server.module.ngfactory&lt;/code&gt; virtual file.</source>
          <target state="translated">&lt;code&gt;app.server.module.ngfactory&lt;/code&gt; 가상 파일 에서 &lt;code&gt;AppServerModuleNgFactory&lt;/code&gt; 를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="fea0622df7e35e3d25926c1db11132831d661da2" translate="yes" xml:space="preserve">
          <source>Import &lt;code&gt;FormsModule&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;FormsModule&lt;/code&gt; 가져 오기</target>
        </trans-unit>
        <trans-unit id="b2f696d4d9afce8de6cbc91e4145a3e2c8ec8ee4" translate="yes" xml:space="preserve">
          <source>Import &lt;code&gt;SelectivePreloadingStrategyService&lt;/code&gt; into &lt;code&gt;AppRoutingModule&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SelectivePreloadingStrategyService&lt;/code&gt; 를 &lt;code&gt;AppRoutingModule&lt;/code&gt; 로 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="ffeed5ccfb791ceee55f7360554286bcadd6091b" translate="yes" xml:space="preserve">
          <source>Import &lt;em&gt;shared&lt;/em&gt; and &lt;em&gt;feature&lt;/em&gt; modules when this module's components incorporate their components, directives, and pipes.</source>
          <target state="translated">이 모듈의 구성 요소가 해당 구성 요소, 지시문 및 파이프를 통합 할 때 &lt;em&gt;공유&lt;/em&gt; 및 &lt;em&gt;기능&lt;/em&gt; 모듈을 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="fcb63212ad3831fc17aec3ffcf8d331ecd00b985" translate="yes" xml:space="preserve">
          <source>Import NgModules whose public (exported) &lt;a href=&quot;bootstrapping#the-declarations-array&quot;&gt;declarable classes&lt;/a&gt; you need to reference in this module's component templates.</source>
          <target state="translated">이 모듈의 컴포넌트 템플릿에서 공개 (내 보낸) 선언 가능 &lt;a href=&quot;bootstrapping#the-declarations-array&quot;&gt;클래스&lt;/a&gt; 를 참조해야하는 NgModules를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="04ceef49142e281571f7a59729fdddb7c109183a" translate="yes" xml:space="preserve">
          <source>Import a domain NgModule exactly once into another NgModule, such as a domain NgModule, or into the root NgModule (&lt;code&gt;AppModule&lt;/code&gt;) of an app that contains only a few NgModules.</source>
          <target state="translated">도메인 NgModule을 도메인 NgModule과 같은 다른 NgModule로 정확히 한 번만 가져 오거나 NgModule 이 몇 개만 포함 된 앱 의 루트 NgModule ( &lt;code&gt;AppModule&lt;/code&gt; )로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f1f2839eab72da958afeb3a4698c2ccac390a557" translate="yes" xml:space="preserve">
          <source>Import a feature module</source>
          <target state="translated">기능 모듈 가져 오기</target>
        </trans-unit>
        <trans-unit id="d2c025183c7eeec9309814c88e2a9cdf1b259bbc" translate="yes" xml:space="preserve">
          <source>Import a routing NgModule only into its companion NgModule. If the companion NgModule is the root &lt;code&gt;AppModule&lt;/code&gt;, the &lt;code&gt;AppRoutingModule&lt;/code&gt; adds router configuration to its imports with &lt;code&gt;RouterModule.forRoot(routes)&lt;/code&gt;. All other routing NgModules are children that import &lt;code&gt;RouterModule.forChild(routes)&lt;/code&gt;.</source>
          <target state="translated">라우팅 NgModule을 동반 NgModule로만 가져옵니다. 동반자 NgModule 루트 인 경우 &lt;code&gt;AppModule&lt;/code&gt; 이 는 &lt;code&gt;AppRoutingModule&lt;/code&gt; 은 과의 수입에 라우터 구성을 추가 &lt;code&gt;RouterModule.forRoot(routes)&lt;/code&gt; . 다른 모든 라우팅 NgModules는 &lt;code&gt;RouterModule.forChild(routes)&lt;/code&gt; 를 가져 오는 자식입니다 .</target>
        </trans-unit>
        <trans-unit id="2547f241c308c031518bf3f1c55b103af9729c3c" translate="yes" xml:space="preserve">
          <source>Import a scoped package in the same way that you import a normal package.</source>
          <target state="translated">일반 패키지를 가져 오는 것과 같은 방법으로 범위가 지정된 패키지를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="98c0c896fabb3fc1a98419d0cde75db05d6430f1" translate="yes" xml:space="preserve">
          <source>Import a shared module</source>
          <target state="translated">공유 모듈 가져 오기</target>
        </trans-unit>
        <trans-unit id="1be630c78b766b9bfc94f1c5ca957111764f2798" translate="yes" xml:space="preserve">
          <source>Import a validator function in your form component.</source>
          <target state="translated">양식 구성 요소에서 유효성 검사기 함수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="301c1658c4350b2d60d09948ca85c6196aed28d1" translate="yes" xml:space="preserve">
          <source>Import and add the &lt;code&gt;HeroDetailComponent&lt;/code&gt; and &lt;code&gt;HeroListComponent&lt;/code&gt; to the &lt;code&gt;declarations&lt;/code&gt; array in the &lt;code&gt;HeroesModule&lt;/code&gt;.</source>
          <target state="translated">가져 오기 및 추가 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 및 &lt;code&gt;HeroListComponent&lt;/code&gt; 을 받는 &lt;code&gt;declarations&lt;/code&gt; 의 배열 &lt;code&gt;HeroesModule&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8ca796a8e658eeeab1bd1e834d4a664c92619c7" translate="yes" xml:space="preserve">
          <source>Import crisis center module into the &lt;code&gt;AppModule&lt;/code&gt; routes</source>
          <target state="translated">위기 센터 모듈을 &lt;code&gt;AppModule&lt;/code&gt; 경로 로 가져 오기</target>
        </trans-unit>
        <trans-unit id="4d7b5a83713e856ce30b92012a4b00341ee61e76" translate="yes" xml:space="preserve">
          <source>Import global variants of the locale data</source>
          <target state="translated">로케일 데이터의 글로벌 변형 가져 오기</target>
        </trans-unit>
        <trans-unit id="a526dbed5b0f6c824f5d7a0643b8d713cf803b67" translate="yes" xml:space="preserve">
          <source>Import it from</source>
          <target state="translated">에서 가져 오기</target>
        </trans-unit>
        <trans-unit id="d8154fd791df3beb7ab66f72f5ba6f3d510c808c" translate="yes" xml:space="preserve">
          <source>Import it into the appropriate module.</source>
          <target state="translated">적절한 모듈로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a6810958c8daa7a96c72da65b232b80dd64c7181" translate="yes" xml:space="preserve">
          <source>Import the &lt;code&gt;&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;&lt;/code&gt; decorator (instead of the &lt;code&gt;&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; decorator).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; 데코레이터 대신 &lt;code&gt;&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;&lt;/code&gt; 데코레이터를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="050ba3274203d622f3595bab0a8e5dd2c4cc5deb" translate="yes" xml:space="preserve">
          <source>Import the &lt;code&gt;&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/core/templateref&quot;&gt;TemplateRef&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../api/core/viewcontainerref&quot;&gt;ViewContainerRef&lt;/a&gt;&lt;/code&gt; symbols; you'll need them for &lt;em&gt;any&lt;/em&gt; structural directive.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/core/templateref&quot;&gt;TemplateRef&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/core/viewcontainerref&quot;&gt;ViewContainerRef&lt;/a&gt;&lt;/code&gt; 기호를 가져옵니다 . &lt;em&gt;모든&lt;/em&gt; 구조적 지시문에 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="e9c23b8c549ecba1a1c10a72bc128051038d670e" translate="yes" xml:space="preserve">
          <source>Import the &lt;code&gt;&lt;a href=&quot;../api/forms/formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; class from &lt;code&gt;@angular/forms&lt;/code&gt; to use for type information. The &lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder&quot;&gt;FormBuilder&lt;/a&gt;&lt;/code&gt; service is ready to create a &lt;code&gt;&lt;a href=&quot;../api/forms/formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">형식 정보에 사용할 &lt;code&gt;@angular/forms&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../api/forms/formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; 클래스를 가져옵니다 . &lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder&quot;&gt;FormBuilder&lt;/a&gt;&lt;/code&gt; 의 서비스는 만들 준비가 &lt;code&gt;&lt;a href=&quot;../api/forms/formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; 의 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="92f9ac3c714a7700d00a99c56956a7e1f3d62f58" translate="yes" xml:space="preserve">
          <source>Import the &lt;code&gt;&lt;a href=&quot;../api/forms/formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/forms/formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; 클래스를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="e331c6fc4a9ff134af60b891774820b42da2edbc" translate="yes" xml:space="preserve">
          <source>Import the &lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder&quot;&gt;FormBuilder&lt;/a&gt;&lt;/code&gt; class from the &lt;code&gt;@angular/forms&lt;/code&gt; package.</source>
          <target state="translated">&lt;code&gt;@angular/forms&lt;/code&gt; 패키지 에서 &lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder&quot;&gt;FormBuilder&lt;/a&gt;&lt;/code&gt; 클래스를 가져 오십시오 .</target>
        </trans-unit>
        <trans-unit id="773ffa7003e87f00942ce0c9d6c491f40289c3fb" translate="yes" xml:space="preserve">
          <source>Import the &lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder&quot;&gt;FormBuilder&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder&quot;&gt;FormBuilder&lt;/a&gt;&lt;/code&gt; 클래스를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="6cc9c61e025989b9b55d14be9d8b9c70af1b9fc4" translate="yes" xml:space="preserve">
          <source>Import the &lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder&quot;&gt;FormBuilder&lt;/a&gt;&lt;/code&gt; service from the &lt;code&gt;@angular/forms&lt;/code&gt; package.</source>
          <target state="translated">&lt;code&gt;@angular/forms&lt;/code&gt; 패키지 에서 &lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder&quot;&gt;FormBuilder&lt;/a&gt;&lt;/code&gt; 서비스를 가져 오십시오 .</target>
        </trans-unit>
        <trans-unit id="cdcf4dcbdeddf625623188d87e4fefc41dd00403" translate="yes" xml:space="preserve">
          <source>Import the &lt;code&gt;&lt;a href=&quot;../api/forms/validators&quot;&gt;Validators&lt;/a&gt;&lt;/code&gt; class from the &lt;code&gt;@angular/forms&lt;/code&gt; package.</source>
          <target state="translated">&lt;code&gt;@angular/forms&lt;/code&gt; 패키지 에서 &lt;code&gt;&lt;a href=&quot;../api/forms/validators&quot;&gt;Validators&lt;/a&gt;&lt;/code&gt; 클래스를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="9ee21c30a536f294238a29e1d4bea732f6f4ae02" translate="yes" xml:space="preserve">
          <source>Import the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../api/router/parammap&quot;&gt;ParamMap&lt;/a&gt;&lt;/code&gt; tokens from the router package.</source>
          <target state="translated">라우터 패키지에서 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/router/parammap&quot;&gt;ParamMap&lt;/a&gt;&lt;/code&gt; 토큰을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="686b0adef0de155a88d75b0bde6fbed3829d7341" translate="yes" xml:space="preserve">
          <source>Import the &lt;code&gt;&lt;a href=&quot;upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; into your top level &lt;a href=&quot;../../core/ngmodule&quot;&gt;Angular `NgModule`&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 을 최상위 &lt;a href=&quot;../../core/ngmodule&quot;&gt;Angular`NgModule`&lt;/a&gt; 로 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="b85dd077949ee00c90306c755fc5f7d11a648b41" translate="yes" xml:space="preserve">
          <source>Import the &lt;code&gt;AppRoutingModule&lt;/code&gt; into &lt;code&gt;AppModule&lt;/code&gt; and add it to the &lt;code&gt;imports&lt;/code&gt; array.</source>
          <target state="translated">가져 오기 &lt;code&gt;AppRoutingModule&lt;/code&gt; 을 에 &lt;code&gt;AppModule&lt;/code&gt; 과에 추가 &lt;code&gt;imports&lt;/code&gt; 배열입니다.</target>
        </trans-unit>
        <trans-unit id="0e1cedd5069238c18718cd52f3d74737564819a6" translate="yes" xml:space="preserve">
          <source>Import the &lt;code&gt;CartService&lt;/code&gt; from the &lt;code&gt;cart.service.ts&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;cart.service.ts&lt;/code&gt; 파일 에서 &lt;code&gt;CartService&lt;/code&gt; 를 가져 오십시오 .</target>
        </trans-unit>
        <trans-unit id="9d8c5fb1b2237d87ff7cd78a6f3f8b61baca81de" translate="yes" xml:space="preserve">
          <source>Import the &lt;code&gt;CrisisListComponent&lt;/code&gt;, &lt;code&gt;HeroListComponent&lt;/code&gt;, and &lt;code&gt;PageNotFoundComponent&lt;/code&gt; symbols just like you did in the &lt;code&gt;app.module.ts&lt;/code&gt;. Then move the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; imports and routing configuration, including &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt;, into this routing module.</source>
          <target state="translated">&lt;code&gt;HeroListComponent&lt;/code&gt; 에서와 &lt;code&gt;PageNotFoundComponent&lt;/code&gt; &lt;code&gt;CrisisListComponent&lt;/code&gt; , HeroListComponent 및 PageNotFoundComponent 기호를 가져 &lt;code&gt;app.module.ts&lt;/code&gt; . 그런 다음 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; 포함한 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 가져 오기 및 라우팅 구성 을이 라우팅 모듈로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="817cc00c391e59b9be4fb99905645f2cf9d9b070" translate="yes" xml:space="preserve">
          <source>Import the &lt;code&gt;DashboardComponent&lt;/code&gt; in the &lt;code&gt;AppRoutingModule&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;AppRoutingModule&lt;/code&gt; 에서 &lt;code&gt;DashboardComponent&lt;/code&gt; 를 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="d891b2d94c07cfdb42e46213e234080c12a97992" translate="yes" xml:space="preserve">
          <source>Import the &lt;code&gt;Hero&lt;/code&gt; and &lt;code&gt;HEROES&lt;/code&gt;.</source>
          <target state="translated">가져 오기 &lt;code&gt;Hero&lt;/code&gt; 과 &lt;code&gt;HEROES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df33ccfbc6cae37532f2258ca69433e9f6f71ae9" translate="yes" xml:space="preserve">
          <source>Import the &lt;code&gt;SelectivePreloadingStrategyService&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SelectivePreloadingStrategyService&lt;/code&gt; 를 가져 오십시오 .</target>
        </trans-unit>
        <trans-unit id="dfb4992a4374e8dc70168e213e70e9f20129c7fe" translate="yes" xml:space="preserve">
          <source>Import the &lt;code&gt;SharedModule&lt;/code&gt; in your &lt;em&gt;feature&lt;/em&gt; modules, both those loaded when the app starts and those you lazy load later.</source>
          <target state="translated">앱을 시작할 때로드 된 모듈과 나중에로드가 지연되는 &lt;em&gt;기능&lt;/em&gt; 모듈 모두 에서 &lt;em&gt;기능&lt;/em&gt; 모듈 에서 &lt;code&gt;SharedModule&lt;/code&gt; 을 가져옵니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e3f7d1044aa8460beba08aa7ce9ae927fdb4849c" translate="yes" xml:space="preserve">
          <source>Import the &lt;code&gt;catchError&lt;/code&gt; symbol from &lt;code&gt;rxjs/operators&lt;/code&gt;, along with some other operators you'll need later.</source>
          <target state="translated">나중에 필요한 다른 연산자와 함께 &lt;code&gt;rxjs/operators&lt;/code&gt; 에서 &lt;code&gt;catchError&lt;/code&gt; 기호를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="d41e2af4e0f9d40ee19656d61d24f3e6c1da5575" translate="yes" xml:space="preserve">
          <source>Import the &lt;code&gt;switchMap&lt;/code&gt; operator because you need it later to process the &lt;code&gt;Observable&lt;/code&gt; route parameters.</source>
          <target state="translated">나중에 &lt;code&gt;Observable&lt;/code&gt; 경로 매개 변수 를 처리하는 데 필요하므로 &lt;code&gt;switchMap&lt;/code&gt; 연산자를 가져 오십시오 .</target>
        </trans-unit>
        <trans-unit id="3a18d1695f508fdb02f8c454df1c248c094d7b2f" translate="yes" xml:space="preserve">
          <source>Import the &lt;code&gt;switchMap&lt;/code&gt; operator to perform an operation on the &lt;code&gt;Observable&lt;/code&gt; of route parameter map.</source>
          <target state="translated">임포트 &lt;code&gt;switchMap&lt;/code&gt; 의 온 동작을 수행하는 연산자 &lt;code&gt;Observable&lt;/code&gt; 경로 파라미터 맵.</target>
        </trans-unit>
        <trans-unit id="d43444878db13fcb283c40d8be13224eada6b8e0" translate="yes" xml:space="preserve">
          <source>Import the appropriate language translation file as a string constant.</source>
          <target state="translated">적절한 언어 변환 파일을 문자열 상수로 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="89a6ca85268363383daef55ec399cdadb37634d3" translate="yes" xml:space="preserve">
          <source>Import the cart service.</source>
          <target state="translated">카트 서비스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="070bfc8700bcdc05ea975d46b92b9598f201fffa" translate="yes" xml:space="preserve">
          <source>Import the defined schema interface that provides the type information for your schematic's options.</source>
          <target state="translated">회로도 옵션에 대한 유형 정보를 제공하는 정의 된 스키마 인터페이스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c4871a12d8b10b0a07d1e0cdc5dfb8d463cfc5f3" translate="yes" xml:space="preserve">
          <source>Import the feature area NgModule into the &lt;code&gt;AppModule&lt;/code&gt;.</source>
          <target state="translated">기능 영역 NgModule을 &lt;code&gt;AppModule&lt;/code&gt; 로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="42b7a45134de162ef0f09f141c0fbcd920dd4711" translate="yes" xml:space="preserve">
          <source>Import the hero components from their new locations in the &lt;code&gt;src/app/heroes/&lt;/code&gt; folder and define the two hero routes.</source>
          <target state="translated">&lt;code&gt;src/app/heroes/&lt;/code&gt; 폴더 의 새 위치에서 Hero 구성 요소를 가져 오고 두 개의 Hero 경로를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="33f2a24119b9f7ce0e76c5987bc26dfad28027be" translate="yes" xml:space="preserve">
          <source>Import the hero components from their new locations in the &lt;code&gt;src/app/heroes/&lt;/code&gt; folder, define the two hero routes.</source>
          <target state="translated">&lt;code&gt;src/app/heroes/&lt;/code&gt; 폴더 의 새로운 위치에서 영웅 구성 요소를 가져 와서 두 개의 영웅 경로를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="5bc40a5fef2a78698029cd1054594de418f9b5e0" translate="yes" xml:space="preserve">
          <source>Import the routing module into the application and create a routing configuration that defines the possible routes.</source>
          <target state="translated">라우팅 모듈을 애플리케이션으로 가져오고 가능한 경로를 정의하는 라우팅 구성을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="a46b7288ec43274590d4dd5dc8714f1e9dcd9766" translate="yes" xml:space="preserve">
          <source>Import this module at the root of your application so that Angular can work with HammerJS to detect gesture events.</source>
          <target state="translated">Angular가 HammerJS와 함께 작동하여 제스처 이벤트를 감지 할 수 있도록 애플리케이션의 루트에서이 모듈을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f9d1848dcd28345f99c78b328167a595cb31adbb" translate="yes" xml:space="preserve">
          <source>Import this resolver in the &lt;code&gt;crisis-center-routing.module.ts&lt;/code&gt; and add a &lt;code&gt;&lt;a href=&quot;../api/router/route#resolve&quot;&gt;resolve&lt;/a&gt;&lt;/code&gt; object to the &lt;code&gt;CrisisDetailComponent&lt;/code&gt; route configuration.</source>
          <target state="translated">이 해결 가져 오기 &lt;code&gt;crisis-center-routing.module.ts&lt;/code&gt; 하고 추가 &lt;code&gt;&lt;a href=&quot;../api/router/route#resolve&quot;&gt;resolve&lt;/a&gt;&lt;/code&gt; 받는 객체를 &lt;code&gt;CrisisDetailComponent&lt;/code&gt; 의 경로 구성.</target>
        </trans-unit>
        <trans-unit id="c9a38ebeeddaeaf5236d69826e1b8200c968d798" translate="yes" xml:space="preserve">
          <source>Import this resolver in the &lt;code&gt;crisis-center-routing.module.ts&lt;/code&gt; and add a &lt;code&gt;resolve&lt;/code&gt; object to the &lt;code&gt;CrisisDetailComponent&lt;/code&gt; route configuration.</source>
          <target state="translated">이 해석기를 &lt;code&gt;CrisisDetailComponent&lt;/code&gt; &lt;code&gt;crisis-center-routing.module.ts&lt;/code&gt; 에서 가져 와서 CrisisDetailComponent 경로 구성에 &lt;code&gt;resolve&lt;/code&gt; 오브젝트를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d353b4a94d95b503455bd4b11f19b1ff8a01486" translate="yes" xml:space="preserve">
          <source>Import this resolver into your module's routing module.</source>
          <target state="translated">이 해석기를 모듈의 라우팅 모듈로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7a061c456d72a9a382bb6f470489d23ae0404d27" translate="yes" xml:space="preserve">
          <source>Import what you need from it as you would from any other Angular package.</source>
          <target state="translated">다른 Angular 패키지에서와 마찬가지로 필요한 것을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f1ec2e5b75cafd71f4d2cf17bbe28874aadd8762" translate="yes" xml:space="preserve">
          <source>Import widget modules in any module whose component templates need the widgets.</source>
          <target state="translated">구성 요소 템플리트에 위젯이 필요한 모든 모듈에서 위젯 모듈을 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="8834a6fc5ae307bddfaa532d30816daae0c4e180" translate="yes" xml:space="preserve">
          <source>Important options include the &lt;em&gt;observe&lt;/em&gt; and &lt;em&gt;responseType&lt;/em&gt; properties.</source>
          <target state="translated">중요한 옵션에는 &lt;em&gt;observe&lt;/em&gt; 및 &lt;em&gt;responseType&lt;/em&gt; 속성이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="473b18365dce3edd8127f1624f5b4519efa7841b" translate="yes" xml:space="preserve">
          <source>Importantly, it doesn't check embedded views, such as &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt;, other &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; embedded view.</source>
          <target state="translated">중요한 것은 &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; , 기타 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 포함 된보기 와 같은 포함 된보기를 확인하지 않는다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="4ebe828e74096e229b55fc62674259b224c8b59f" translate="yes" xml:space="preserve">
          <source>Imported by</source>
          <target state="translated">에 의해 수입</target>
        </trans-unit>
        <trans-unit id="ca029c525e020e030b5763e634cdfa9684f0ec75" translate="yes" xml:space="preserve">
          <source>Imported providers are easily replaced by providers from another imported NgModule. Such replacement might be by design. It could be unintentional and have adverse consequences.</source>
          <target state="translated">가져온 공급자는 다른 가져온 NgModule의 공급자로 쉽게 교체 할 수 있습니다. 이러한 교체는 의도 된 것일 수 있습니다. 의도하지 않았으며 불리한 결과를 초래할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c410a4e7ce454cc0a669f85789fcc7292be2656" translate="yes" xml:space="preserve">
          <source>Importing &lt;code&gt;&lt;a href=&quot;../api/common/commonmodule&quot;&gt;CommonModule&lt;/a&gt;&lt;/code&gt; also frees feature modules for use on &lt;em&gt;any&lt;/em&gt; target platform, not just browsers.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/common/commonmodule&quot;&gt;CommonModule&lt;/a&gt;&lt;/code&gt; 을 가져 오면 브라우저뿐만 아니라 &lt;em&gt;모든&lt;/em&gt; 대상 플랫폼에서 사용할 기능 모듈이 해제 됩니다.</target>
        </trans-unit>
        <trans-unit id="0926c5352a1ed8fd6d4008f3a9505f53d26d0c72" translate="yes" xml:space="preserve">
          <source>Importing &lt;code&gt;&lt;a href=&quot;../api/service-worker/serviceworkermodule&quot;&gt;ServiceWorkerModule&lt;/a&gt;&lt;/code&gt; into your &lt;code&gt;AppModule&lt;/code&gt; doesn't just register the service worker, it also provides a few services you can use to interact with the service worker and control the caching of your app.</source>
          <target state="translated">가져 오기 &lt;code&gt;&lt;a href=&quot;../api/service-worker/serviceworkermodule&quot;&gt;ServiceWorkerModule&lt;/a&gt;&lt;/code&gt; 을 당신에 &lt;code&gt;AppModule&lt;/code&gt; 바로 서비스 노동자를 등록하지 않습니다, 그것은 또한 당신이 서비스 작업자와 상호 작용하여 응용 프로그램의 캐싱을 제어하는 데 사용할 수있는 몇 가지 서비스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bf8398dc7932850ef3407d2abc867f5242eaa718" translate="yes" xml:space="preserve">
          <source>Importing a feature module</source>
          <target state="translated">기능 모듈 가져 오기</target>
        </trans-unit>
        <trans-unit id="b15db4d28a6b8ab83dd5b14c0f07467630615c89" translate="yes" xml:space="preserve">
          <source>Importing a module does &lt;em&gt;not&lt;/em&gt; automatically re-export the imported module's imports. Module 'B' can't use &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; just because it imported module 'A' which imported &lt;code&gt;&lt;a href=&quot;../api/common/commonmodule&quot;&gt;CommonModule&lt;/a&gt;&lt;/code&gt;. Module 'B' must import &lt;code&gt;&lt;a href=&quot;../api/common/commonmodule&quot;&gt;CommonModule&lt;/a&gt;&lt;/code&gt; itself.</source>
          <target state="translated">모듈을 가져 오더라도 가져온 모듈의 가져 오기가 자동으로 다시 내보내지는 &lt;em&gt;않습니다&lt;/em&gt; . 모듈 'B'는 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 을 가져온 모듈 'A'를 가져 &lt;code&gt;&lt;a href=&quot;../api/common/commonmodule&quot;&gt;CommonModule&lt;/a&gt;&lt;/code&gt; 때문에 ngIf를 사용할 수 없습니다 . 모듈 'B'는 &lt;code&gt;&lt;a href=&quot;../api/common/commonmodule&quot;&gt;CommonModule&lt;/a&gt;&lt;/code&gt; 자체를 가져와야 합니다.</target>
        </trans-unit>
        <trans-unit id="50f4da678c72bbf5ccb3812d54bcbc40fe9377ba" translate="yes" xml:space="preserve">
          <source>Importing modules</source>
          <target state="translated">모듈 가져 오기</target>
        </trans-unit>
        <trans-unit id="6c6759a5009501ce940b68c3c6c4d0a88982af01" translate="yes" xml:space="preserve">
          <source>Importing the component's feature module can be the easiest way to configure tests when there are many mutual dependencies within the module and the module is small, as feature modules tend to be.</source>
          <target state="translated">구성 요소의 기능 모듈을 가져 오는 것은 모듈 내에 상호 의존성이 많고 기능 모듈이 작기 때문에 모듈이 작은 경우 테스트를 구성하는 가장 쉬운 방법 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21270ddcd2b8b36dcd36ba9dc2e65ba937443e00" translate="yes" xml:space="preserve">
          <source>Importing the feature area NgModule into the &lt;code&gt;AppModule&lt;/code&gt;.</source>
          <target state="translated">기능 영역 NgModule을 &lt;code&gt;AppModule&lt;/code&gt; 로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="7a3c1a6c640cbb3ff72c5cdbdda365799c5166c1" translate="yes" xml:space="preserve">
          <source>Importing your new components</source>
          <target state="translated">새 구성 요소 가져 오기</target>
        </trans-unit>
        <trans-unit id="2dc45a2a577a313a667ab95b3f67c568aecf86f0" translate="yes" xml:space="preserve">
          <source>Imports and registers the service worker in the app module.</source>
          <target state="translated">앱 워커에서 서비스 워커를 가져 와서 등록합니다.</target>
        </trans-unit>
        <trans-unit id="a83a0fc0cd6287cabf3642ac5ae77c9a4a861c22" translate="yes" xml:space="preserve">
          <source>Imports and route configuration</source>
          <target state="translated">가져 오기 및 라우트 구성</target>
        </trans-unit>
        <trans-unit id="3814cab387da7b9062d6ab2735ba73f5e9829045" translate="yes" xml:space="preserve">
          <source>Imports other modules with the components, directives, and pipes that components in the current module need.</source>
          <target state="translated">현재 모듈의 구성 요소에 필요한 구성 요소, 지시문 및 파이프가있는 다른 모듈을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d61c28aebf6d9a308688684bd0963349f916d660" translate="yes" xml:space="preserve">
          <source>Imports the animation symbols that build the animation triggers, control state, and manage transitions between states.</source>
          <target state="translated">애니메이션 트리거를 만들고 애니메이션 상태를 제어하며 상태 간 전환을 관리하는 애니메이션 심볼을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="969b1f7fd31248b651ab09920846952d22265f1a" translate="yes" xml:space="preserve">
          <source>Improve debugging with better Angular error messages</source>
          <target state="translated">더 나은 Angular 오류 메시지로 디버깅 개선</target>
        </trans-unit>
        <trans-unit id="fea98dc51784321beb1402d5791647e70f12893b" translate="yes" xml:space="preserve">
          <source>Improve overall data quality by validating user input for accuracy and completeness.</source>
          <target state="translated">정확성과 완전성을 위해 사용자 입력의 유효성을 검사하여 전반적인 데이터 품질을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="a3b0e66bdae797196b6b8788ae8a0c136f597b0d" translate="yes" xml:space="preserve">
          <source>Improve performance by pre-fetching route data and lazy loading feature modules.</source>
          <target state="translated">경로 데이터를 미리 가져오고 기능 모듈을 지연로드하여 성능을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="d44c2ca2637e46280e6e09bd5b6ff5f7c525f378" translate="yes" xml:space="preserve">
          <source>Improve performance on mobile and low-powered devices</source>
          <target state="translated">모바일 및 저전력 장치의 성능 향상</target>
        </trans-unit>
        <trans-unit id="eeeab4f650457717006bfb970c8280a15fa896ca" translate="yes" xml:space="preserve">
          <source>Improved build performance with ngc as a tsc plugin distribution</source>
          <target state="translated">ngc를 tsc 플러그인 배포로 사용하여 빌드 성능 향상</target>
        </trans-unit>
        <trans-unit id="4a27691e865b7979531873ee280a5a3243bcb0f1" translate="yes" xml:space="preserve">
          <source>Improved developer onboarding with refreshed introductory documentation</source>
          <target state="translated">새로 워진 소개 문서로 개선 된 개발자 온 보딩</target>
        </trans-unit>
        <trans-unit id="769e1298b6774dc3ae80f0664e3cf40ae3aa8a3e" translate="yes" xml:space="preserve">
          <source>Improved test times and debugging with automatic test environment tear down</source>
          <target state="translated">자동 테스트 환경 해체로 테스트 시간 및 디버깅 향상</target>
        </trans-unit>
        <trans-unit id="3c9b3986f782d4faa661a57a4c4f5fd5422669f8" translate="yes" xml:space="preserve">
          <source>Improving template type checking for custom directives</source>
          <target state="translated">사용자 지정 지시문에 대한 템플릿 유형 검사 개선</target>
        </trans-unit>
        <trans-unit id="c0414193d62ac6c0f1bf1c02847690c0c2c4c6f1" translate="yes" xml:space="preserve">
          <source>Impure pipes</source>
          <target state="translated">불순한 파이프</target>
        </trans-unit>
        <trans-unit id="6b0407cc45edc7407381780a1a2e8b0dc444dee0" translate="yes" xml:space="preserve">
          <source>Impure pipes are called whenever change detection runs for a component, which could be every few milliseconds for &lt;code&gt;CheckAlways&lt;/code&gt;. To avoid performance problems, call the server only when the requested URL changes, as shown in the following example, and use the pipe to cache the server response. The tabs show the following:</source>
          <target state="translated">불순한 파이프는 구성 요소에 대한 변경 감지가 실행될 때마다 호출되며 &lt;code&gt;CheckAlways&lt;/code&gt; 의 경우 몇 밀리 초마다 발생할 수 있습니다 . 성능 문제를 방지하려면 다음 예와 같이 요청 된 URL이 변경 될 때만 서버를 호출하고 파이프를 사용하여 서버 응답을 캐시합니다. 탭에는 다음이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="88c8cdf511a1c885e6f77a48066eec8b1854da94" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;glossary#schematic&quot;&gt;schematics&lt;/a&gt;, a function that operates on a &lt;a href=&quot;glossary#file-tree&quot;&gt;file tree&lt;/a&gt; to create, delete, or modify files in a specific manner.</source>
          <target state="translated">에서 &lt;a href=&quot;glossary#schematic&quot;&gt;회로도&lt;/a&gt; 하는에서 작동하는 기능 &lt;a href=&quot;glossary#file-tree&quot;&gt;파일 트리&lt;/a&gt; 생성, 삭제, 또는 특정 방식으로 파일을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="b691bd4b8205b08475f3b410f51f0a0d3db24979" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;glossary#schematic&quot;&gt;schematics&lt;/a&gt;, a virtual file system represented by the &lt;code&gt;Tree&lt;/code&gt; class. Schematic &lt;a href=&quot;glossary#rule&quot;&gt;rules&lt;/a&gt; take a tree object as input, operate on them, and return a new tree object.</source>
          <target state="translated">에서 &lt;a href=&quot;glossary#schematic&quot;&gt;회로도&lt;/a&gt; , 가상 파일 시스템은로 표현 &lt;code&gt;Tree&lt;/code&gt; 클래스입니다. 회로도 &lt;a href=&quot;glossary#rule&quot;&gt;규칙&lt;/a&gt; 은 트리 객체를 입력으로 사용하여 조작 한 후 새 트리 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="24e713671eb935b94463bbfce75319fb7e81b738" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http#adding-headers&quot;&gt;Adding headers&lt;/a&gt;, the &lt;code&gt;HeroesService&lt;/code&gt; set the default headers by passing an options object (&lt;code&gt;httpOptions&lt;/code&gt;) to its save methods. You can do more.</source>
          <target state="translated">에서 &lt;a href=&quot;http#adding-headers&quot;&gt;추가 헤더&lt;/a&gt; 의 &lt;code&gt;HeroesService&lt;/code&gt; 은 : 옵션 객체 (전달하여 기본 헤더를 설정 &lt;code&gt;httpOptions&lt;/code&gt; 을 그 방법에 저장하기). 더 많은 것을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="419fc7b32aa230897c77ab6ce882d85080a20dfc" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;Visual Studio Code&lt;/a&gt;, install the extension from the &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=Angular.ng-template&quot;&gt;Extensions: Marketplace&lt;/a&gt;. You can open the marketplace from the editor using the Extensions icon on the left menu pane, or use VS Quick Open (⌘+P on Mac, CTRL+P on Windows) and type &quot;? ext&quot;.</source>
          <target state="translated">에서 &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;Visual Studio를 코드&lt;/a&gt; 의에서 확장 설치 &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=Angular.ng-template&quot;&gt;마켓 플레이스 : 확장&lt;/a&gt; . 왼쪽 메뉴 창의 확장 아이콘을 사용하여 편집기에서 마켓 플레이스를 열거 나 VS 빠른 열기 (Mac의 경우 ⌘ + P, Windows의 경우 CTRL + P)를 사용하고 &quot;? ext&quot;를 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b5b24ded6357d77d1fbb26f1eab50bd8beae2b5" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://www.jetbrains.com/webstorm/&quot;&gt;WebStorm&lt;/a&gt;, enable the plugin &lt;a href=&quot;https://plugins.jetbrains.com/plugin/6971-angular-and-angularjs&quot;&gt;Angular and AngularJS&lt;/a&gt;.</source>
          <target state="translated">에서 &lt;a href=&quot;https://www.jetbrains.com/webstorm/&quot;&gt;WebStorm&lt;/a&gt; , 플러그인 수 있도록 &lt;a href=&quot;https://plugins.jetbrains.com/plugin/6971-angular-and-angularjs&quot;&gt;각도와 AngularJS와를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0de07a30f188c92d5f5c9abf71459a306a224cdb" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://www.jetbrains.com/webstorm/&quot;&gt;WebStorm&lt;/a&gt;, you must install the language service package as a project dependency.</source>
          <target state="translated">에서 &lt;a href=&quot;https://www.jetbrains.com/webstorm/&quot;&gt;WebStorm&lt;/a&gt; , 당신은 프로젝트 종속성과 같은 언어 서비스 패키지를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="189f9093d7a12a56913779caf0448dafddac81fa" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://www.sublimetext.com/&quot;&gt;Sublime Text&lt;/a&gt;, the Language Service supports only in-line templates when installed as a plug-in. You need a custom Sublime plug-in (or modifications to the current plug-in) for completions in HTML files.</source>
          <target state="translated">에서 &lt;a href=&quot;https://www.sublimetext.com/&quot;&gt;숭고한 텍스트&lt;/a&gt; 플러그인으로 설치했을 때, 언어 서비스는 인라인 템플릿을 지원합니다. HTML 파일을 완성하려면 사용자 정의 Sublime 플러그인 (또는 현재 플러그인 수정)이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c5f51ca55d5ad2c30fa2f2f2c23e29a882d2b6a5" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;ivy&quot;&gt;Angular Ivy&lt;/a&gt;, the template type checker has been completely rewritten to be more capable as well as stricter, meaning it can catch a variety of new errors that the previous type checker would not detect.</source>
          <target state="translated">에서 &lt;a href=&quot;ivy&quot;&gt;각도 아이비&lt;/a&gt; , 템플릿 유형 검사는 완전히 이전 유형 검사에서 감지 할 것이라는 새로운 다양한 오류를 잡을 수있는 의미 엄격한뿐만 아니라 더 할 수있는 것으로 다시 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="6adea1758de937c6940c286e654edf1f70a7341d" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;HeroService&lt;/code&gt;, import the &lt;code&gt;MessageService&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;HeroService&lt;/code&gt; 가져 오기 &lt;code&gt;MessageService&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="941837469f8f7292381b4b5d7fb8f52141c4b5b9" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ProfileEditorComponent&lt;/code&gt;, use the &lt;code&gt;updateProfile&lt;/code&gt; method with the example below to update the first name and street address for the user.</source>
          <target state="translated">에서 &lt;code&gt;ProfileEditorComponent&lt;/code&gt; , 사용 &lt;code&gt;updateProfile&lt;/code&gt; 에 사용자의 이름과 거리 주소를 업데이트 아래의 예와 방법을.</target>
        </trans-unit>
        <trans-unit id="c4552c52e0555afb5d7c5f59701433a331470a05" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;angular.json&lt;/code&gt; add two new configuration sections under the &lt;code&gt;build&lt;/code&gt; and &lt;code&gt;serve&lt;/code&gt; targets to point to the new TypeScript configuration.</source>
          <target state="translated">에서 &lt;code&gt;angular.json&lt;/code&gt; 세 이하 두 개의 새로운 구성 섹션을 추가 &lt;code&gt;build&lt;/code&gt; 및 &lt;code&gt;serve&lt;/code&gt; 새로운 타이프 라이터 구성에 지점에 목표를.</target>
        </trans-unit>
        <trans-unit id="afca841ae46663ab78571026445492242945a6dc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;app.component.ts&lt;/code&gt;, &lt;code&gt;currentItems&lt;/code&gt; is an array of objects in the same shape as the &lt;code&gt;Item&lt;/code&gt; object in &lt;code&gt;items.ts&lt;/code&gt;, with an &lt;code&gt;id&lt;/code&gt; and a &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">에서는 &lt;code&gt;app.component.ts&lt;/code&gt; , &lt;code&gt;currentItems&lt;/code&gt; 는 동일한 형상의 오브젝트의 배열 인 &lt;code&gt;Item&lt;/code&gt; 에 개체 &lt;code&gt;items.ts&lt;/code&gt; 함께, &lt;code&gt;id&lt;/code&gt; 및 &lt;code&gt;name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88a62840642f50411d045256c59444f30c7be873" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;app.module.ts&lt;/code&gt;, add a route for product details, with a &lt;code&gt;path&lt;/code&gt; of &lt;code&gt;products/:productId&lt;/code&gt; and &lt;code&gt;ProductDetailsComponent&lt;/code&gt; for the &lt;code&gt;component&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;app.module.ts&lt;/code&gt; 하는로, 제품 정보에 대한 경로를 추가 &lt;code&gt;path&lt;/code&gt; 의 &lt;code&gt;products/:productId&lt;/code&gt; 와 &lt;code&gt;ProductDetailsComponent&lt;/code&gt; 에 대한 &lt;code&gt;component&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c81e966129850cf415f6248bea69d0b9ed06ad7c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;app.module.ts&lt;/code&gt;, add a route for shipping. Specify a &lt;code&gt;path&lt;/code&gt; of &lt;code&gt;shipping&lt;/code&gt; and a component of &lt;code&gt;ShippingComponent&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;app.module.ts&lt;/code&gt; , 운송에 대한 경로를 추가합니다. 지정 &lt;code&gt;path&lt;/code&gt; 의 &lt;code&gt;shipping&lt;/code&gt; 과의 구성 요소 &lt;code&gt;ShippingComponent&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="6d895fdb94f9534c8a2f82b3d299e8227073cbd3" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;app.module.ts&lt;/code&gt;, remove the &lt;code&gt;AdminModule&lt;/code&gt; import statement from the top of the file and remove the &lt;code&gt;AdminModule&lt;/code&gt; from the NgModule's &lt;code&gt;imports&lt;/code&gt; array.</source>
          <target state="translated">에서 &lt;code&gt;app.module.ts&lt;/code&gt; , 제거 &lt;code&gt;AdminModule&lt;/code&gt; 파일의 상단에서 import 문을과 제거 &lt;code&gt;AdminModule&lt;/code&gt; 을 NgModule의에서 &lt;code&gt;imports&lt;/code&gt; 배열입니다.</target>
        </trans-unit>
        <trans-unit id="66c95ce78c49c2b818a248ba1ca84d28c18823cf" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;cart.component.ts&lt;/code&gt;, define an &lt;code&gt;onSubmit()&lt;/code&gt; method to process the form. Use the &lt;code&gt;CartService#clearCart()&lt;/code&gt; method to empty the cart items and reset the form after it is submitted. (In a real-world app, this method also would submit the data to an external server.)</source>
          <target state="translated">에서는 &lt;code&gt;cart.component.ts&lt;/code&gt; , 정의 &lt;code&gt;onSubmit()&lt;/code&gt; 형태로 처리하는 방법. 사용 &lt;code&gt;CartService#clearCart()&lt;/code&gt; 카트 항목을 비우고이 제출 된 후 양식을 재설정하는 방법을. 실제 앱에서이 방법은 데이터를 외부 서버에 제출할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="03b649f3d6c4a1c2196ae63a64954a5fc383db3c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;cart.component.ts&lt;/code&gt;, define an &lt;code&gt;onSubmit()&lt;/code&gt; method to process the form. Use the &lt;code&gt;CartService&lt;/code&gt;&lt;code&gt;clearCart()&lt;/code&gt; method to empty the cart items and reset the form after its submission. In a real-world app, this method would also submit the data to an external server. The entire cart component class is as follows:</source>
          <target state="translated">에서는 &lt;code&gt;cart.component.ts&lt;/code&gt; , 정의 &lt;code&gt;onSubmit()&lt;/code&gt; 형태로 처리하는 방법. 사용 &lt;code&gt;CartService&lt;/code&gt; &lt;code&gt;clearCart()&lt;/code&gt; 카트 항목을 비우고가 제출 된 후 양식을 재설정하는 방법을. 실제 앱에서이 방법은 데이터를 외부 서버에 제출합니다. 전체 카트 구성 요소 클래스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0b5334d2075d36a21eeb7a9fdb6756d0e3353959" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;index.html&lt;/code&gt;, change base href from &lt;code&gt;&amp;lt;base href=&quot;/&quot;&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;base href=&quot;/src/&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">에서는 &lt;code&gt;index.html&lt;/code&gt; 을 행 변경 기본 href &lt;code&gt;&amp;lt;base href=&quot;/&quot;&amp;gt;&lt;/code&gt; 에 &lt;code&gt;&amp;lt;base href=&quot;/src/&quot;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d4c2508f6f46eaa4133ffeeaac2bf21600b45b7" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;product-list.component.html&lt;/code&gt;, bind the &lt;code&gt;app-product-alerts&lt;/code&gt; component (which is what displays the &quot;Notify Me&quot; button) to the &lt;code&gt;onNotify()&lt;/code&gt; method of the product list component.</source>
          <target state="translated">에서 &lt;code&gt;product-list.component.html&lt;/code&gt; , 바인드 &lt;code&gt;app-product-alerts&lt;/code&gt; 받는 사람 (이하 &quot;알림&quot;버튼을 표시 것입니다) 구성 요소 &lt;code&gt;onNotify()&lt;/code&gt; 제품 목록 구성 요소의 방법.</target>
        </trans-unit>
        <trans-unit id="c03f59b331ed7156718b1228952832ea7836769c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;src/systemjs.config.js&lt;/code&gt;, near the top of the file, change the npm &lt;code&gt;path&lt;/code&gt; to &lt;code&gt;/node_modules/&lt;/code&gt; with a slash.</source>
          <target state="translated">에서 &lt;code&gt;src/systemjs.config.js&lt;/code&gt; , 파일의 상단에, 고궁 박물원의 변화 &lt;code&gt;path&lt;/code&gt; 에 &lt;code&gt;/node_modules/&lt;/code&gt; 슬래시로.</target>
        </trans-unit>
        <trans-unit id="3bc1fafefe77f9932ae7d735645c4d33c9cc2eeb" translate="yes" xml:space="preserve">
          <source>In Angular CLI version 8 and higher, applications are built using &lt;em&gt;differential loading&lt;/em&gt;, a strategy where the CLI builds two separate bundles as part of your deployed application.</source>
          <target state="translated">Angular CLI 버전 8 이상 에서 CLI는 배포 된 애플리케이션의 일부로 두 개의 개별 번들을 빌드하는 전략 인 &lt;em&gt;차등 로딩을&lt;/em&gt; 사용하여 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="e1431faabdc821757fa86b84a541dce584ba7634" translate="yes" xml:space="preserve">
          <source>In Angular CLI version 8 and higher, differential loading is enabled by default for the &lt;code&gt;ng build&lt;/code&gt; command. The &lt;code&gt;ng serve&lt;/code&gt;, &lt;code&gt;ng test&lt;/code&gt;, and &lt;code&gt;ng e2e&lt;/code&gt; commands, however, generate a single ES2015 build which cannot run in older browsers that don't support the modules, such as IE 11.</source>
          <target state="translated">Angular CLI 버전 8 이상에서는 &lt;code&gt;ng build&lt;/code&gt; 명령 에 기본적으로 차등 로딩이 활성화되어 있습니다. 그러나 &lt;code&gt;ng serve&lt;/code&gt; , &lt;code&gt;ng test&lt;/code&gt; 및 &lt;code&gt;ng e2e&lt;/code&gt; 명령은 IE 11과 같은 모듈을 지원하지 않는 이전 브라우저에서는 실행할 수없는 단일 ES2015 빌드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7b1d3994bf24bcb2d7b3fdd86f51dccd601e9753" translate="yes" xml:space="preserve">
          <source>In Angular terminology, a platform is the context in which an Angular application runs. The most common platform for Angular applications is a web browser, but it can also be an operating system for a mobile device, or a web server.</source>
          <target state="translated">Angular 용어에서 플랫폼은 Angular 응용 프로그램이 실행되는 컨텍스트입니다. Angular 응용 프로그램의 가장 일반적인 플랫폼은 웹 브라우저이지만 모바일 장치 또는 웹 서버의 운영 체제 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="46dd64bbc88ed581429aca94fdd9f3452d9971db" translate="yes" xml:space="preserve">
          <source>In Angular things are different. While change detection still occurs after every event, no one needs to call &lt;code&gt;scope.$apply()&lt;/code&gt; for that to happen. This is because all Angular code runs inside something called the &lt;a href=&quot;../api/core/ngzone&quot;&gt;Angular zone&lt;/a&gt;. Angular always knows when the code finishes, so it also knows when it should kick off change detection. The code itself doesn't have to call &lt;code&gt;scope.$apply()&lt;/code&gt; or anything like it.</source>
          <target state="translated">각도에서는 상황이 다릅니다. 모든 이벤트 후에도 변경 감지가 여전히 발생하지만 &lt;code&gt;scope.$apply()&lt;/code&gt; 를 호출 할 필요는 없습니다 . 모든 Angular 코드가 &lt;a href=&quot;../api/core/ngzone&quot;&gt;Angular zone&lt;/a&gt; 이라는 내부에서 실행되기 때문 입니다. Angular는 코드가 완료되는시기를 항상 알고 있으므로 변경 감지를 시작해야하는시기도 알고 있습니다. 코드 자체는 &lt;code&gt;scope.$apply()&lt;/code&gt; 또는 이와 유사한 것을 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d45210191612fe3bb5ec53b02b0be46f15c8ce7c" translate="yes" xml:space="preserve">
          <source>In Angular version 9, the template type checker checks whether a binding expression's type is compatible with that of the corresponding directive input. As an example, consider the following component:</source>
          <target state="translated">Angular 버전 9에서 템플릿 유형 검사기는 바인딩 표현식의 유형이 해당 지시문 입력의 유형과 호환되는지 여부를 확인합니다. 예를 들어 다음 구성 요소를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="4c74df3bafb8f0880b2718e644a5bb702ff44a77" translate="yes" xml:space="preserve">
          <source>In Angular you use similar syntax with the pipe (|) character to filter output, but now you call them &lt;strong&gt;pipes&lt;/strong&gt;. Many (but not all) of the built-in filters from AngularJS are built-in pipes in Angular.</source>
          <target state="translated">Angular에서는 파이프 (|) 문자와 유사한 구문을 사용하여 출력을 필터링하지만 이제 &lt;strong&gt;파이프&lt;/strong&gt; 라고합니다 . AngularJS의 많은 내장 필터는 Angular의 내장 파이프입니다.</target>
        </trans-unit>
        <trans-unit id="95111c94dbd226bf1c1dbcb0a6c5aa4131254f48" translate="yes" xml:space="preserve">
          <source>In Angular, &lt;code&gt;href&lt;/code&gt; is no longer used for routing. Routing uses &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;routerLink&lt;/a&gt;&lt;/code&gt;, as shown in the following example.</source>
          <target state="translated">Angular에서 &lt;code&gt;href&lt;/code&gt; 는 더 이상 라우팅에 사용되지 않습니다. 라우팅은 다음 예와 같이 &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;routerLink&lt;/a&gt;&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="5776268b8d76370b45f02f052a40cf650053642c" translate="yes" xml:space="preserve">
          <source>In Angular, &lt;strong&gt;two-way binding&lt;/strong&gt; is denoted by &lt;code&gt;[()]&lt;/code&gt;, descriptively referred to as a &quot;banana in a box&quot;. This syntax is a shortcut for defining both property binding (from the component to the view) and event binding (from the view to the component), thereby providing two-way binding.</source>
          <target state="translated">Angular에서 &lt;strong&gt;양방향 바인딩&lt;/strong&gt; 은 설명 적으로 &quot;상자에 바나나&quot;라고 하는 &lt;code&gt;[()]&lt;/code&gt; 로 표시됩니다 . 이 구문은 속성 바인딩 (구성 요소에서보기로)과 이벤트 바인딩 (보기에서 구성 요소로)을 모두 정의하여 양방향 바인딩을 제공하는 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="f933bc6fc4b7b3378ae37914c32604c21b7bac57" translate="yes" xml:space="preserve">
          <source>In Angular, a &lt;a href=&quot;glossary#project&quot;&gt;project&lt;/a&gt; that provides functionality that can be included in other Angular apps. A library isn't a complete Angular app and can't run independently. (To add re-usable Angular functionality to non-Angular web apps, you can use Angular &lt;a href=&quot;glossary#angular-element&quot;&gt;custom elements&lt;/a&gt;.)</source>
          <target state="translated">Angular에서는 다른 Angular 앱에 포함될 수있는 기능을 제공 하는 &lt;a href=&quot;glossary#project&quot;&gt;프로젝트&lt;/a&gt; 입니다. 라이브러리는 완전한 Angular 앱이 아니며 독립적으로 실행할 수 없습니다. (Angular 이외의 웹 앱에 재사용 가능한 Angular 기능을 추가하기 위해 Angular &lt;a href=&quot;glossary#angular-element&quot;&gt;사용자 정의 요소를&lt;/a&gt; 사용할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="95d6afe08573bb93eca1cae171a8aa8ac1cf2775" translate="yes" xml:space="preserve">
          <source>In Angular, a &lt;em&gt;template&lt;/em&gt; is a chunk of HTML. Within a template, you can use special syntax to leverage many of Angular's features.</source>
          <target state="translated">Angular에서 &lt;em&gt;템플릿&lt;/em&gt; 은 HTML 덩어리입니다. 템플릿 내에서 특별한 구문을 사용하여 Angular의 많은 기능을 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d102678eee21e14e16ac6c77664ce7f07fe617f" translate="yes" xml:space="preserve">
          <source>In Angular, a class with the &lt;a href=&quot;glossary#injectable&quot;&gt;@Injectable()&lt;/a&gt; decorator that encapsulates non-UI logic and code that can be reused across an application. Angular distinguishes components from services to increase modularity and reusability.</source>
          <target state="translated">Angular에서는 응용 프로그램에서 재사용 할 수있는 비 UI 논리 및 코드를 캡슐화 하는 &lt;a href=&quot;glossary#injectable&quot;&gt;@Injectable ()&lt;/a&gt; 데코레이터가 있는 클래스입니다 . Angular는 컴포넌트와 서비스를 구별하여 모듈 성과 재사용 성을 높입니다.</target>
        </trans-unit>
        <trans-unit id="42472280db2836f2049c258a790c8995069f17d9" translate="yes" xml:space="preserve">
          <source>In Angular, a set of related &lt;a href=&quot;glossary#schematic&quot;&gt;schematics&lt;/a&gt; collected in an &lt;a href=&quot;glossary#npm-package&quot;&gt;npm package&lt;/a&gt;.</source>
          <target state="translated">Angular 에서 &lt;a href=&quot;glossary#npm-package&quot;&gt;npm 패키지로&lt;/a&gt; 수집 된 관련 &lt;a href=&quot;glossary#schematic&quot;&gt;회로도&lt;/a&gt; 세트입니다 .</target>
        </trans-unit>
        <trans-unit id="e67a287fde6cc9945eb3f6d9f0c4d95950a65f6b" translate="yes" xml:space="preserve">
          <source>In Angular, a template expression in curly braces still denotes one-way binding. This binds the value of the element to a property of the component. The context of the binding is implied and is always the associated component, so it needs no reference variable.</source>
          <target state="translated">Angular에서 중괄호 안의 템플릿 표현식은 여전히 ​​단방향 바인딩을 나타냅니다. 이것은 요소의 값을 컴포넌트의 속성에 바인딩합니다. 바인딩 컨텍스트는 내재되어 있으며 항상 연관된 컴포넌트이므로 참조 변수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43af6c84f806d548cba3d9e875a82ca2c2ac11d1" translate="yes" xml:space="preserve">
          <source>In Angular, an app's root NgModule (&lt;code&gt;AppModule&lt;/code&gt;) has a &lt;code&gt;bootstrap&lt;/code&gt; property that identifies the app's top-level &lt;a href=&quot;glossary#component&quot;&gt;components&lt;/a&gt;. During the bootstrap process, Angular creates and inserts these components into the &lt;code&gt;index.html&lt;/code&gt; host web page. You can bootstrap multiple apps in the same &lt;code&gt;index.html&lt;/code&gt;. Each app contains its own components.</source>
          <target state="translated">Angular에서 앱의 루트 NgModule ( &lt;code&gt;AppModule&lt;/code&gt; )에는 앱의 최상위 &lt;a href=&quot;glossary#component&quot;&gt;구성 요소&lt;/a&gt; 를 식별 하는 &lt;code&gt;bootstrap&lt;/code&gt; 속성이 있습니다. 부트 스트랩 프로세스 동안 Angular는 이러한 구성 요소를 만들어 &lt;code&gt;index.html&lt;/code&gt; 호스트 웹 페이지에 삽입 합니다. 동일한 &lt;code&gt;index.html&lt;/code&gt; 에서 여러 앱을 부트 스트랩 할 수 있습니다 . 각 앱에는 자체 구성 요소가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="854deb5a01aad6ed0edbb17479ccae63f79a55ba" translate="yes" xml:space="preserve">
          <source>In Angular, component CSS styles are encapsulated into the component's view and don't affect the rest of the application.</source>
          <target state="translated">Angular에서 구성 요소 CSS 스타일은 구성 요소의보기에 캡슐화되며 나머지 응용 프로그램에는 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bbb7472c46802d488a515304f6fc524e7754d847" translate="yes" xml:space="preserve">
          <source>In Angular, components are the main primitive from which user interfaces are built. You define the different portions of the UI as components and compose them into a full user experience.</source>
          <target state="translated">Angular에서 컴포넌트는 사용자 인터페이스가 구축되는 주요 기본 요소입니다. UI의 다른 부분을 구성 요소로 정의하고 완전한 사용자 환경으로 구성합니다.</target>
        </trans-unit>
        <trans-unit id="d57111c7e00014610f562bb31fefc30b6f3895c6" translate="yes" xml:space="preserve">
          <source>In Angular, dependencies are typically services, but they also can be values, such as strings or functions. An &lt;a href=&quot;glossary#injector&quot;&gt;injector&lt;/a&gt; for an app (created automatically during bootstrap) instantiates dependencies when needed, using a configured &lt;a href=&quot;glossary#provider&quot;&gt;provider&lt;/a&gt; of the service or value.</source>
          <target state="translated">Angular에서 종속성은 일반적으로 서비스이지만 문자열이나 함수와 같은 값일 수도 있습니다. 앱 의 &lt;a href=&quot;glossary#injector&quot;&gt;인젝터&lt;/a&gt; (부트 스트랩 중에 자동으로 생성됨)는 필요할 때 구성된 서비스 또는 값 &lt;a href=&quot;glossary#provider&quot;&gt;공급자&lt;/a&gt; 를 사용하여 종속성을 인스턴스화 합니다.</target>
        </trans-unit>
        <trans-unit id="49a00199a43ff42e00e1d7703a54a94326ede49c" translate="yes" xml:space="preserve">
          <source>In Angular, the &lt;code&gt;&lt;a href=&quot;../api/common/ngclass&quot;&gt;ngClass&lt;/a&gt;&lt;/code&gt; directive works similarly. It includes/excludes CSS classes based on an expression.</source>
          <target state="translated">Angular에서 &lt;code&gt;&lt;a href=&quot;../api/common/ngclass&quot;&gt;ngClass&lt;/a&gt;&lt;/code&gt; 지시문은 비슷하게 작동합니다. 표현식을 기반으로 CSS 클래스를 포함 / 제외합니다.</target>
        </trans-unit>
        <trans-unit id="3bf0e4f69a8ebfd62b6c1ef86d6048033054f53f" translate="yes" xml:space="preserve">
          <source>In Angular, the &lt;code&gt;&lt;a href=&quot;../api/common/ngstyle&quot;&gt;ngStyle&lt;/a&gt;&lt;/code&gt; directive works similarly. It sets a CSS style on an HTML element based on an expression.</source>
          <target state="translated">Angular에서 &lt;code&gt;&lt;a href=&quot;../api/common/ngstyle&quot;&gt;ngStyle&lt;/a&gt;&lt;/code&gt; 지시문은 비슷하게 작동합니다. 표현식을 기반으로 HTML 요소에 CSS 스타일을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d14c88becd3c4b7ad223e1c52839e5fb106a2219" translate="yes" xml:space="preserve">
          <source>In Angular, the &lt;code&gt;&lt;a href=&quot;../api/common/ngswitch&quot;&gt;ngSwitch&lt;/a&gt;&lt;/code&gt; directive works similarly. It displays an element whose &lt;code&gt;*&lt;a href=&quot;../api/common/ngswitchcase&quot;&gt;ngSwitchCase&lt;/a&gt;&lt;/code&gt; matches the current &lt;code&gt;&lt;a href=&quot;../api/common/ngswitch&quot;&gt;ngSwitch&lt;/a&gt;&lt;/code&gt; expression value.</source>
          <target state="translated">Angular에서 &lt;code&gt;&lt;a href=&quot;../api/common/ngswitch&quot;&gt;ngSwitch&lt;/a&gt;&lt;/code&gt; 지시문은 비슷하게 작동합니다. &lt;code&gt;*&lt;a href=&quot;../api/common/ngswitchcase&quot;&gt;ngSwitchCase&lt;/a&gt;&lt;/code&gt; 가 현재 &lt;code&gt;&lt;a href=&quot;../api/common/ngswitch&quot;&gt;ngSwitch&lt;/a&gt;&lt;/code&gt; 표현식 값 과 일치 하는 요소를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="7fa35db99b5e7128d37e25c36e032619af14914f" translate="yes" xml:space="preserve">
          <source>In Angular, the DI framework provides declared dependencies to a class when that class is instantiated. This guide explains how DI works in Angular, and how you use it to make your apps flexible, efficient, and robust, as well as testable and maintainable.</source>
          <target state="translated">Angular에서 DI 프레임 워크는 클래스가 인스턴스화 될 때 클래스에 선언 된 종속성을 제공합니다. 이 가이드에서는 DI가 Angular에서 어떻게 작동하는지, 그리고이를 사용하여 앱을 유연하고 효율적이며 견고하며 테스트 가능하고 유지 관리 가능하게 만드는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="56cf5a3785dda1a9e94cccd5c7f98706c65752e1" translate="yes" xml:space="preserve">
          <source>In Angular, the best practice is to load and configure the router in a separate, top-level module that is dedicated to routing and imported by the root &lt;code&gt;AppModule&lt;/code&gt;.</source>
          <target state="translated">Angular에서 모범 사례는 루트 &lt;code&gt;AppModule&lt;/code&gt; 에 의해 라우팅 및 가져 오기 전용 인 별도의 최상위 모듈에 라우터를로드하고 구성하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="59cb913403e7197319cc31442b4a8397dc93031f" translate="yes" xml:space="preserve">
          <source>In Angular, the template no longer specifies its associated controller. Rather, the component specifies its associated template as part of the component class decorator.</source>
          <target state="translated">Angular에서 템플릿은 더 이상 관련 컨트롤러를 지정하지 않습니다. 대신, 컴포넌트는 컴포넌트 클래스 데코레이터의 일부로 연관된 템플리트를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="5d2ddeeb7cdda93a0f1d676dfcb267a980c9fb20" translate="yes" xml:space="preserve">
          <source>In Angular, transition states can be defined explicitly through the &lt;code&gt;&lt;a href=&quot;../api/animations/state&quot;&gt;state&lt;/a&gt;()&lt;/code&gt; function, or using the predefined &lt;code&gt;*&lt;/code&gt; (wildcard) and &lt;code&gt;void&lt;/code&gt; states.</source>
          <target state="translated">Angular에서 전환 상태는 &lt;code&gt;&lt;a href=&quot;../api/animations/state&quot;&gt;state&lt;/a&gt;()&lt;/code&gt; 함수를 통해 명시 적으로 정의 하거나 사전 정의 된 &lt;code&gt;*&lt;/code&gt; (와일드 카드) 및 &lt;code&gt;void&lt;/code&gt; 상태를 사용하여 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25736a6eef4ea1a73caec95ccf80b14819cbeacf" translate="yes" xml:space="preserve">
          <source>In Angular, transition states can be defined explicitly through the &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/%24locationshim#state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; function, or using the predefined &lt;code&gt;*&lt;/code&gt; (wildcard) and &lt;code&gt;void&lt;/code&gt; states.</source>
          <target state="translated">Angular에서 전이 상태는 &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/%24locationshim#state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; 함수를 통해 또는 사전 정의 된 &lt;code&gt;*&lt;/code&gt; (와일드 카드) 및 &lt;code&gt;void&lt;/code&gt; 상태를 사용하여 명시 적으로 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e131d233620271698d30ea65871deadb93e35a0" translate="yes" xml:space="preserve">
          <source>In Angular, use JSONP by including &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientjsonpmodule&quot;&gt;HttpClientJsonpModule&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; imports. In the following example, the &lt;code&gt;searchHeroes()&lt;/code&gt; method uses a JSONP request to query for heroes whose names contain the search term.</source>
          <target state="translated">Angular 에서 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 가져 오기에 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientjsonpmodule&quot;&gt;HttpClientJsonpModule&lt;/a&gt;&lt;/code&gt; 을 포함시켜 JSONP를 사용 하십시오 . 다음 예에서 &lt;code&gt;searchHeroes()&lt;/code&gt; 메서드는 JSONP 요청을 사용하여 이름에 검색어가 포함 된 영웅을 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="95bc62450c4a6ad00b962b6c8b2526a974d4070b" translate="yes" xml:space="preserve">
          <source>In Angular, you can set multiple styles without any animation. However, without further refinement, the button instantly transforms with no fade, no shrinkage, or other visible indicator that a change is occurring.</source>
          <target state="translated">Angular에서는 애니메이션없이 여러 스타일을 설정할 수 있습니다. 그러나 더 세밀하게 조정하지 않으면 버튼이 페이드, 축소 또는 변경이 발생하고 있음을 나타내는 다른 표시없이 즉시 변형됩니다.</target>
        </trans-unit>
        <trans-unit id="db7fc84f2aa2ba81061de8add0ab492452e7b00b" translate="yes" xml:space="preserve">
          <source>In Angular, you can use the &lt;code&gt;styles&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../api/core/component#styleUrls&quot;&gt;styleUrls&lt;/a&gt;&lt;/code&gt; property of the &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; metadata to define a style sheet for a particular component.</source>
          <target state="translated">Angular에서는 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt; 메타 데이터 의 &lt;code&gt;styles&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../api/core/component#styleUrls&quot;&gt;styleUrls&lt;/a&gt;&lt;/code&gt; 속성 을 사용하여 특정 구성 요소의 스타일 시트를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b15804b26932b791e746d66ee9a7371c2cdd16b6" translate="yes" xml:space="preserve">
          <source>In Angular, you can use the &lt;code&gt;styles&lt;/code&gt; or &lt;code&gt;styleUrls&lt;/code&gt; property of the &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; metadata to define a style sheet for a particular component.</source>
          <target state="translated">Angular에서는 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt; 메타 데이터 의 &lt;code&gt;styles&lt;/code&gt; 또는 &lt;code&gt;styleUrls&lt;/code&gt; 속성 을 사용하여 특정 구성 요소에 대한 스타일 시트를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="917fd81c1d70d9d7fbe4bfbac7c25842ecbe5775" translate="yes" xml:space="preserve">
          <source>In Angular, you create a component class to contain the data model and control methods. Use the TypeScript &lt;code&gt;export&lt;/code&gt; keyword to export the class so that the functionality can be imported into NgModules.</source>
          <target state="translated">Angular에서는 데이터 모델 및 컨트롤 메서드를 포함 할 구성 요소 클래스를 만듭니다. 기능을 NgModules로 가져올 수 있도록 TypeScript &lt;code&gt;export&lt;/code&gt; 키워드를 사용하여 클래스를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="9d13198215c21edc80169cd08c0e85464770e5e5" translate="yes" xml:space="preserve">
          <source>In Angular, you pass in dependencies as arguments to the component class constructor. This example injects a &lt;code&gt;MovieService&lt;/code&gt;. The first parameter's TypeScript type tells Angular what to inject, even after minification.</source>
          <target state="translated">Angular에서는 종속성을 구성 요소 클래스 생성자에 인수로 전달합니다. 이 예제는 &lt;code&gt;MovieService&lt;/code&gt; 를 삽입합니다 . 첫 번째 매개 변수의 TypeScript 유형은 축소 후에도 Angular에 주입 대상을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="2befa90df23e1fd4a51bf9026307335169223d9a" translate="yes" xml:space="preserve">
          <source>In Angular, you use property binding; there is no built-in &lt;em&gt;hide&lt;/em&gt; directive. For more information, see &lt;a href=&quot;ajs-quick-reference#ng-show&quot;&gt;ng-show&lt;/a&gt;.</source>
          <target state="translated">Angular에서는 속성 바인딩을 사용합니다. 내장 된 &lt;em&gt;hide&lt;/em&gt; 지시문 이 없습니다 . 자세한 내용은 &lt;a href=&quot;ajs-quick-reference#ng-show&quot;&gt;ng-show를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7cabd7a1d2e9dfa73456a5cfdfed14d83c3ff687" translate="yes" xml:space="preserve">
          <source>In AngularJS, an Angular module keeps track of controllers, services, and other code. The second argument defines the list of other modules that this module depends upon.</source>
          <target state="translated">AngularJS에서 Angular 모듈은 컨트롤러, 서비스 및 기타 코드를 추적합니다. 두 번째 인수는이 모듈이 의존하는 다른 모듈의 목록을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="59f6e03fe28a109551d993bba2ab50942b6034e7" translate="yes" xml:space="preserve">
          <source>In AngularJS, an expression in curly braces denotes one-way binding. This binds the value of the element to a property in the controller associated with this template.</source>
          <target state="translated">AngularJS에서 중괄호 안의 표현식은 단방향 바인딩을 나타냅니다. 이것은 요소의 값을이 템플릿과 연결된 컨트롤러의 속성에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="c6449941b0d5bd79435ee303f5b25fb1a3a1c3df" translate="yes" xml:space="preserve">
          <source>In AngularJS, an immediately invoked function expression (or IIFE) around controller code keeps it out of the global namespace.</source>
          <target state="translated">AngularJS에서 컨트롤러 코드 주위에 즉시 호출 된 함수 표현식 (또는 IIFE)은 전역 네임 스페이스에서 제외시킵니다.</target>
        </trans-unit>
        <trans-unit id="3402c056b50a9d166afa19ff142bd9f2d0f52a15" translate="yes" xml:space="preserve">
          <source>In AngularJS, the &lt;a href=&quot;https://docs.angularjs.org/api/ng/service/%24location&quot;&gt;$location service&lt;/a&gt; handles all routing configuration and navigation, encoding and decoding of URLS, redirects, and interactions with browser APIs. Angular uses its own underlying &lt;code&gt;&lt;a href=&quot;../api/common/location&quot;&gt;Location&lt;/a&gt;&lt;/code&gt; service for all of these tasks.</source>
          <target state="translated">AngularJS에서 &lt;a href=&quot;https://docs.angularjs.org/api/ng/service/%24location&quot;&gt;$ location 서비스&lt;/a&gt; 는 모든 라우팅 구성 및 탐색, URL 인코딩, 디코딩, 리디렉션 및 브라우저 API와의 상호 작용을 처리합니다. Angular는 이러한 모든 작업에 자체 기본 &lt;code&gt;&lt;a href=&quot;../api/common/location&quot;&gt;Location&lt;/a&gt;&lt;/code&gt; 서비스를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="eb398e0b3db43606304c259cfff7981355eca61f" translate="yes" xml:space="preserve">
          <source>In AngularJS, the &lt;code&gt;ng-class&lt;/code&gt; directive includes/excludes CSS classes based on an expression. That expression is often a key-value control object with each key of the object defined as a CSS class name, and each value defined as a template expression that evaluates to a Boolean value.</source>
          <target state="translated">AngularJS에서 &lt;code&gt;ng-class&lt;/code&gt; 지시문은 표현식을 기반으로 CSS 클래스를 포함 / 제외합니다. 이 표현식은 종종 오브젝트의 각 키가 CSS 클래스 이름으로 정의되고 각 값이 부울 값으로 평가되는 템플리트 표현식으로 정의 된 키-값 제어 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="818af6bd07f74440493d9b442a5bd574408dafb9" translate="yes" xml:space="preserve">
          <source>In AngularJS, the &lt;code&gt;ng-click&lt;/code&gt; directive allows you to specify custom behavior when an element is clicked.</source>
          <target state="translated">AngularJS에서 &lt;code&gt;ng-click&lt;/code&gt; 지시문을 사용하면 요소를 클릭 할 때 사용자 정의 동작을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fbad8407ae81e7c90d5bd49b9e78709b7734b35" translate="yes" xml:space="preserve">
          <source>In AngularJS, the &lt;code&gt;ng-controller&lt;/code&gt; directive attaches a controller to the view. Using the &lt;code&gt;ng-controller&lt;/code&gt; (or defining the controller as part of the routing) ties the view to the controller code associated with that view.</source>
          <target state="translated">AngularJS에서 &lt;code&gt;ng-controller&lt;/code&gt; 지시문은 컨트롤러를 뷰에 연결합니다. &lt;code&gt;ng-controller&lt;/code&gt; 를 사용 하거나 라우팅의 일부로 컨트롤러를 정의하면 해당 뷰와 관련된 컨트롤러 코드에 뷰가 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="014cadcee952b130a89b2cacda8d8fb19ba39ecf" translate="yes" xml:space="preserve">
          <source>In AngularJS, the &lt;code&gt;ng-hide&lt;/code&gt; directive shows or hides the associated HTML element based on an expression. For more information, see &lt;a href=&quot;ajs-quick-reference#ng-show&quot;&gt;ng-show&lt;/a&gt;.</source>
          <target state="translated">AngularJS에서 &lt;code&gt;ng-hide&lt;/code&gt; 지시문은 표현식을 기반으로 연관된 HTML 요소를 표시하거나 숨 깁니다. 자세한 내용은 &lt;a href=&quot;ajs-quick-reference#ng-show&quot;&gt;ng-show를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="55692422426a5f190e228d159889d4e818c0c281" translate="yes" xml:space="preserve">
          <source>In AngularJS, the &lt;code&gt;ng-href&lt;/code&gt; is often used to activate a route as part of navigation.</source>
          <target state="translated">AngularJS에서 &lt;code&gt;ng-href&lt;/code&gt; 는 종종 탐색의 일부로 경로를 활성화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="98ac54bfebe79300df81d93eb3d99942dfa78df6" translate="yes" xml:space="preserve">
          <source>In AngularJS, the &lt;code&gt;ng-if&lt;/code&gt; directive removes or recreates a portion of the DOM, based on an expression. If the expression is false, the element is removed from the DOM.</source>
          <target state="translated">AngularJS에서 &lt;code&gt;ng-if&lt;/code&gt; 지시문은 표현식을 기반으로 DOM의 일부를 제거하거나 다시 작성합니다. 표현식이 false이면 요소가 DOM에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="bae5a3f3040e93734d778be2fb6b9823f2178635" translate="yes" xml:space="preserve">
          <source>In AngularJS, the &lt;code&gt;ng-model&lt;/code&gt; directive binds a form control to a property in the controller associated with the template. This provides &lt;strong&gt;two-way binding&lt;/strong&gt;, whereby any change made to the value in the view is synchronized with the model, and any change to the model is synchronized with the value in the view.</source>
          <target state="translated">AngularJS에서 &lt;code&gt;ng-model&lt;/code&gt; 지시문은 양식 컨트롤을 템플릿과 연결된 컨트롤러의 속성에 바인딩합니다. 이는 &lt;strong&gt;양방향 바인딩을&lt;/strong&gt; 제공 하여 뷰의 값을 변경하면 모델과 동기화되고 모델을 변경하면 뷰의 값과 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="903b10b4d3b7257fdd75c38b26fddc8e2292ab92" translate="yes" xml:space="preserve">
          <source>In AngularJS, the &lt;code&gt;ng-repeat&lt;/code&gt; directive repeats the associated DOM element for each item in the specified collection.</source>
          <target state="translated">AngularJS에서 &lt;code&gt;ng-repeat&lt;/code&gt; 지시문은 지정된 컬렉션의 각 항목에 대해 연관된 DOM 요소를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="2ed583230e835e013e2faaccadd4c5987e0b6dcf" translate="yes" xml:space="preserve">
          <source>In AngularJS, the &lt;code&gt;ng-show&lt;/code&gt; directive shows or hides the associated DOM element, based on an expression.</source>
          <target state="translated">AngularJS에서 &lt;code&gt;ng-show&lt;/code&gt; 지시문은 표현식을 기반으로 연관된 DOM 요소를 표시하거나 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="71b37da7b6fe1a95ea082ca481f794b3337c391f" translate="yes" xml:space="preserve">
          <source>In AngularJS, the &lt;code&gt;ng-style&lt;/code&gt; directive sets a CSS style on an HTML element based on an expression. That expression is often a key-value control object with each key of the object defined as a CSS property, and each value defined as an expression that evaluates to a value appropriate for the style.</source>
          <target state="translated">AngularJS에서 &lt;code&gt;ng-style&lt;/code&gt; 지시문은 표현식을 기반으로 HTML 요소에 CSS 스타일을 설정합니다. 이 표현식은 종종 객체의 각 키가 CSS 속성으로 정의되고 각 값이 스타일에 적합한 값으로 평가되는 표현식으로 정의되는 키-값 제어 객체입니다.</target>
        </trans-unit>
        <trans-unit id="e0656ba1ea23edbe16f8089baec62aca2d5b8917" translate="yes" xml:space="preserve">
          <source>In AngularJS, the &lt;code&gt;ng-switch&lt;/code&gt; directive swaps the contents of an element by selecting one of the templates based on the current value of an expression.</source>
          <target state="translated">AngularJS에서 &lt;code&gt;ng-switch&lt;/code&gt; 지시문은 표현식의 현재 값을 기반으로 템플리트 중 하나를 선택하여 요소의 컨텐츠를 교환합니다.</target>
        </trans-unit>
        <trans-unit id="1d52894dd4f10a8182acd7f3bd00849e805e2e2e" translate="yes" xml:space="preserve">
          <source>In AngularJS, you pass in any dependencies as controller function arguments. This example injects a &lt;code&gt;MovieService&lt;/code&gt;.</source>
          <target state="translated">AngularJS에서는 모든 종속성을 컨트롤러 함수 인수로 전달합니다. 이 예제는 &lt;code&gt;MovieService&lt;/code&gt; 를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="9ac4f51e9351e87b9cfd8dd2361b98292c81adc4" translate="yes" xml:space="preserve">
          <source>In AngularJS, you write the code for the model and methods in a controller function.</source>
          <target state="translated">AngularJS에서는 컨트롤러 함수에서 모델 및 메소드의 코드를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="4f4f7dccd62d663335cfb71ca12781b89ca1acf4" translate="yes" xml:space="preserve">
          <source>In AngularJS, you write the code that provides the model and the methods for the view in a &lt;strong&gt;controller&lt;/strong&gt;. In Angular, you build a &lt;strong&gt;component&lt;/strong&gt;.</source>
          <target state="translated">AngularJS에서는 &lt;strong&gt;컨트롤러&lt;/strong&gt; 에서 뷰의 모델과 메소드를 제공하는 코드를 작성합니다 . Angular에서는 &lt;strong&gt;component&lt;/strong&gt; 를 빌드합니다 .</target>
        </trans-unit>
        <trans-unit id="17aa02fbd3f7b1d58bafeb9efaf4a3d0381fa09f" translate="yes" xml:space="preserve">
          <source>In HTML, these attributes are set using ordinary CSS styles such as color and opacity. In Angular, use the &lt;code&gt;&lt;a href=&quot;../api/animations/style&quot;&gt;style&lt;/a&gt;()&lt;/code&gt; function to specify a set of CSS styles for use with animations. You can collect a set of styles in an animation state, and give the state a name, such as &lt;code&gt;open&lt;/code&gt; or &lt;code&gt;closed&lt;/code&gt;.</source>
          <target state="translated">HTML에서 이러한 속성은 색상 및 불투명도와 같은 일반적인 CSS 스타일을 사용하여 설정됩니다. Angular에서 &lt;code&gt;&lt;a href=&quot;../api/animations/style&quot;&gt;style&lt;/a&gt;()&lt;/code&gt; 함수를 사용하여 애니메이션에 사용할 CSS 스타일 세트를 지정하십시오. 애니메이션 상태에서 스타일 세트를 수집하고 상태에 &lt;code&gt;open&lt;/code&gt; 또는 &lt;code&gt;closed&lt;/code&gt; 같은 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e23c70ae53e4e39b6efe1c2cca3a6e135570227" translate="yes" xml:space="preserve">
          <source>In JavaScript (ECMAScript), each file is a module and all objects defined in the file belong to that module. Objects can exported, making them public, and public objects can be imported for use by other modules.</source>
          <target state="translated">JavaScript (ECMAScript)에서 각 파일은 모듈이며 파일에 정의 된 모든 객체는 해당 모듈에 속합니다. 객체를 내 보내서 공용으로 만들 수 있으며 다른 모듈에서 사용하기 위해 공용 객체를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00113ac64c73beea3e7d378ff1f842ddd2316ba2" translate="yes" xml:space="preserve">
          <source>In JavaScript each &lt;em&gt;file&lt;/em&gt; is a module and all objects defined in the file belong to that module. The module declares some objects to be public by marking them with the &lt;code&gt;export&lt;/code&gt; key word. Other JavaScript modules use &lt;em&gt;import statements&lt;/em&gt; to access public objects from other modules.</source>
          <target state="translated">JavaScript에서 각 &lt;em&gt;파일&lt;/em&gt; 은 모듈이며 파일에 정의 된 모든 객체는 해당 모듈에 속합니다. 모듈은 일부 키워드를 &lt;code&gt;export&lt;/code&gt; 키워드 로 표시하여 공용으로 선언합니다 . 다른 JavaScript 모듈은 &lt;em&gt;import 문&lt;/em&gt; 을 사용 하여 다른 모듈에서 공용 객체에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="fb85040b15049e982959bb2339113e3e8a73a679" translate="yes" xml:space="preserve">
          <source>In JavaScript, modules are individual files with JavaScript code in them. To make what&amp;rsquo;s in them available, you write an export statement, usually after the relevant code, like this:</source>
          <target state="translated">JavaScript에서 모듈은 JavaScript 코드가 포함 된 개별 파일입니다. 그 안에 들어있는 것을 만들기 위해, 보통 다음과 같이 관련 코드 뒤에 내보내기 명령문을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="f61eadaf153a7ccf995f48d19a000c62df62384c" translate="yes" xml:space="preserve">
          <source>In Progress</source>
          <target state="translated">진행 중</target>
        </trans-unit>
        <trans-unit id="9bdc952c572e3628d4fe93bd50574b4a309ba81b" translate="yes" xml:space="preserve">
          <source>In Sass and Stylus you can make use of the &lt;code&gt;includePaths&lt;/code&gt; functionality for both component and global styles, which allows you to add extra base paths that will be checked for imports.</source>
          <target state="translated">Sass 및 Stylus에서는 구성 요소 및 전역 스타일 모두 에 대해 &lt;code&gt;includePaths&lt;/code&gt; 기능을 사용할 수 있으므로 가져 오기를 검사 할 추가 기본 경로를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92a7b3a74d45330ef286338b8bdb3743222ebf0d" translate="yes" xml:space="preserve">
          <source>In Visual Studio, select &lt;code&gt;File&lt;/code&gt; | &lt;code&gt;New&lt;/code&gt; | &lt;code&gt;Project&lt;/code&gt; from the menu.</source>
          <target state="translated">Visual Studio에서 &lt;code&gt;File&lt;/code&gt; | &lt;code&gt;New&lt;/code&gt; | 메뉴에서 &lt;code&gt;Project&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="7a46a63cb5e6dd220a5995dd3ad65a3d4cfd3913" translate="yes" xml:space="preserve">
          <source>In Windows, by default, one application can only have 6 websocket connections, &lt;a href=&quot;https://msdn.microsoft.com/library/ee330736%28v=vs.85%29.aspx?f=255&amp;amp;MSPPError=-2147217396#websocket_maxconn&quot;&gt;MSDN WebSocket Settings&lt;/a&gt;. So when IE is refreshed (manually or automatically by &lt;code&gt;ng serve&lt;/code&gt;), sometimes the websocket does not close properly. When websocket connections exceed the limitations, a &lt;code&gt;SecurityError&lt;/code&gt; will be thrown. This error will not affect the angular application, you can just restart IE to clear this error, or modify the windows registry to update the limitations.</source>
          <target state="translated">Windows에서 기본적으로 하나의 응용 프로그램은 6 개의 &lt;a href=&quot;https://msdn.microsoft.com/library/ee330736%28v=vs.85%29.aspx?f=255&amp;amp;MSPPError=-2147217396#websocket_maxconn&quot;&gt;웹 소켓&lt;/a&gt; 연결 ( MSDN WebSocket 설정) 만 가질 수 있습니다 . 따라서 IE를 새로 고치면 ( &lt;code&gt;ng serve&lt;/code&gt; 가 수동 또는 자동으로 ) 웹 소켓이 제대로 닫히지 않는 경우가 있습니다. 웹 소켓 연결이 제한을 초과하면 &lt;code&gt;SecurityError&lt;/code&gt; 가 발생합니다. 이 오류는 각도 응용 프로그램에 영향을 미치지 않습니다. IE를 다시 시작하여이 오류를 지우거나 Windows 레지스트리를 수정하여 제한을 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e58c3e6bb3aef781aa7181c15464f286c38606f" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;toh-pt6&quot;&gt;later tutorial on HTTP&lt;/a&gt;, you'll learn that Angular's &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; methods return RxJS &lt;code&gt;Observable&lt;/code&gt;s. In this tutorial, you'll simulate getting data from the server with the RxJS &lt;code&gt;of()&lt;/code&gt; function.</source>
          <target state="translated">&lt;a href=&quot;toh-pt6&quot;&gt;HTTP에&lt;/a&gt; 대한 나중의 튜토리얼 에서는 Angular의 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 메소드가 RxJS &lt;code&gt;Observable&lt;/code&gt; 을 반환 한다는 것을 알게 될 것입니다 . 이 자습서에서는 RxJS &lt;code&gt;of()&lt;/code&gt; 함수 를 사용하여 서버에서 데이터를 가져 오는 것을 시뮬레이트 합니다.</target>
        </trans-unit>
        <trans-unit id="3cf5e053e84e39697369f0ce6c53d2386e757b8d" translate="yes" xml:space="preserve">
          <source>In a common anti-XSRF technique, the application server sends a randomly generated authentication token in a cookie. The client code reads the cookie and adds a custom request header with the token in all subsequent requests. The server compares the received cookie value to the request header value and rejects the request if the values are missing or don't match.</source>
          <target state="translated">일반적인 안티 -XSRF 기술에서 응용 프로그램 서버는 임의로 생성 된 인증 토큰을 쿠키로 보냅니다. 클라이언트 코드는 쿠키를 읽고 이후의 모든 요청에서 토큰과 함께 사용자 지정 요청 헤더를 추가합니다. 서버는 수신 된 쿠키 값을 요청 헤더 값과 비교하고 값이 누락되거나 일치하지 않으면 요청을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="1d8d7cbdfb73e6a03899934d4c9da16af41b336d" translate="yes" xml:space="preserve">
          <source>In a cross-site request forgery (CSRF or XSRF), an attacker tricks the user into visiting a different web page (such as &lt;code&gt;evil.com&lt;/code&gt;) with malignant code that secretly sends a malicious request to the application's web server (such as &lt;code&gt;example-bank.com&lt;/code&gt;).</source>
          <target state="translated">크로스 사이트 요청 위조 (CSRF 또는 XSRF)에서, 공격자 트릭 (예 : 다른 웹 페이지를 방문에 사용자 &lt;code&gt;evil.com&lt;/code&gt; 비밀리에 응용 프로그램의 웹 서버에 악의적 인 요청을 전송하는 악성 코드) (예 : &lt;code&gt;example-bank.com&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6dca33d40db6d10cf9713bad29c95abc927de179" translate="yes" xml:space="preserve">
          <source>In a game, you may want to implement a transformation that raises a value exponentially to increase a hero's power. For example, if the hero's score is 2, boosting the hero's power exponentially by 10 produces a score of 1024. You can use a custom pipe for this transformation.</source>
          <target state="translated">게임에서 영웅의 힘을 높이기 위해 값을 기하 급수적으로 높이는 변환을 구현할 수 있습니다. 예를 들어, 영웅의 점수가 2 인 경우 영웅의 힘을 기하 급수적으로 10만큼 높이면 1024의 점수가 생성됩니다.이 변환에 사용자 정의 파이프를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c294d986a3a0791f76abb2659d73016c21090bb6" translate="yes" xml:space="preserve">
          <source>In a hybrid app you run both frameworks at the same time. This means that you need at least one module each from both AngularJS and Angular.</source>
          <target state="translated">하이브리드 앱에서는 두 프레임 워크를 동시에 실행합니다. 이것은 AngularJS와 Angular에서 각각 하나 이상의 모듈이 필요하다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="dd49097c4af31e8ff37d4dffaf61ab60999b9c63" translate="yes" xml:space="preserve">
          <source>In a hybrid application you run both versions of Angular at the same time. That means that you need at least one module each from both AngularJS and Angular. You will import &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; inside the NgModule, and then use it for bootstrapping the AngularJS module.</source>
          <target state="translated">하이브리드 애플리케이션에서는 두 버전의 Angular를 동시에 실행합니다. 즉, AngularJS와 Angular에서 각각 하나 이상의 모듈이 필요합니다. NgModule 내부에서 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 을 가져온 다음 AngularJS 모듈을 부트 스트랩하는 데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="eecc29f766a5b275d626b33d41f80a280c20298d" translate="yes" xml:space="preserve">
          <source>In a large translation project, you would send the &lt;code&gt;messages.fr.xlf&lt;/code&gt; file to a French translator who would enter the translations using an XLIFF file editor.</source>
          <target state="translated">대규모 번역 프로젝트에서는 &lt;code&gt;messages.fr.xlf&lt;/code&gt; 파일을 프랑스어 번역가에게 보내면 XLIFF 파일 편집기를 사용하여 번역을 입력하게됩니다.</target>
        </trans-unit>
        <trans-unit id="763a34fdd8fac0b4e83d70065f59dafe9753fced" translate="yes" xml:space="preserve">
          <source>In a likely implementation, the &lt;code&gt;&amp;lt;lib-card&amp;gt;&lt;/code&gt; component uses &lt;code&gt;@&lt;a href=&quot;../api/core/contentchild&quot;&gt;ContentChild&lt;/a&gt;()&lt;/code&gt; or &lt;code&gt;@&lt;a href=&quot;../api/core/contentchildren&quot;&gt;ContentChildren&lt;/a&gt;()&lt;/code&gt; to obtain &lt;code&gt;&amp;lt;lib-header&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;lib-body&amp;gt;&lt;/code&gt;, as in the following.</source>
          <target state="translated">가능한 구현에서 &lt;code&gt;&amp;lt;lib-card&amp;gt;&lt;/code&gt; 구성 요소는 다음과 같이 &lt;code&gt;@&lt;a href=&quot;../api/core/contentchild&quot;&gt;ContentChild&lt;/a&gt;()&lt;/code&gt; 또는 &lt;code&gt;@&lt;a href=&quot;../api/core/contentchildren&quot;&gt;ContentChildren&lt;/a&gt;()&lt;/code&gt; 을 사용하여 &lt;code&gt;&amp;lt;lib-header&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;lib-body&amp;gt;&lt;/code&gt; 를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="65d7af41d00fdcbff992b94c404b92c9d9626cd2" translate="yes" xml:space="preserve">
          <source>In a logical tree, this same idea might look like this:</source>
          <target state="translated">논리 트리에서 이와 동일한 아이디어는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7696fb27896c9162de3bfeb3b997d19364c236ec" translate="yes" xml:space="preserve">
          <source>In a more complex translation, the information and context in the &lt;a href=&quot;i18n#help-translator&quot;&gt;description and meaning elements&lt;/a&gt; described previously would help you choose the right words for translation.</source>
          <target state="translated">더 복잡한 번역에서는 이전에 설명한 &lt;a href=&quot;i18n#help-translator&quot;&gt;설명 및 의미 요소&lt;/a&gt; 의 정보와 컨텍스트가 번역에 적합한 단어를 선택하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="622221c893367be5aa97d75408ed81b53a6c93b4" translate="yes" xml:space="preserve">
          <source>In a reactive form, the source of truth is the component class. Instead of adding validators through attributes in the template, you add validator functions directly to the form control model in the component class. Angular then calls these functions whenever the value of the control changes.</source>
          <target state="translated">반응적인 형태에서 진실의 근원은 구성 요소 클래스입니다. 템플리트의 속성을 통해 유효성 검증기를 추가하는 대신 컴포넌트 클래스의 양식 제어 모델에 유효성 검증기 함수를 직접 추가합니다. 그러면 Angular는 컨트롤 값이 변경 될 때마다이 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="48d79754006d33a97227a0a4118efa5286db6a19" translate="yes" xml:space="preserve">
          <source>In a real application, the element that receives focus will depend on your specific application structure and layout. The focused element should put users in a position to immediately move into the main content that has just been routed into view. You should avoid situations where focus returns to the &lt;code&gt;body&lt;/code&gt; element after a route change.</source>
          <target state="translated">실제 응용 프로그램에서 포커스를받는 요소는 특정 응용 프로그램 구조 및 레이아웃에 따라 다릅니다. 집중된 요소는 사용자가 방금 라우팅 된 기본 컨텐츠로 즉시 이동할 수있는 위치에 있어야합니다. 경로 변경 후 초점이 &lt;code&gt;body&lt;/code&gt; 요소 로 돌아가는 상황을 피해야 합니다.</target>
        </trans-unit>
        <trans-unit id="39db9cdd4eed1089be0ce0d095908e3625bd0e28" translate="yes" xml:space="preserve">
          <source>In a real world application, the &lt;code&gt;HeroesService&lt;/code&gt; is responsible for making an HTTP request to the hero database to check if the alter ego is available. From the validator's point of view, the actual implementation of the service is not important, so we can just code against the &lt;code&gt;HeroesService&lt;/code&gt; interface.</source>
          <target state="translated">실제 응용 프로그램에서 &lt;code&gt;HeroesService&lt;/code&gt; 는 변경 자아를 사용할 수 있는지 확인하기 위해 영웅 데이터베이스에 HTTP 요청을 작성합니다. 검증 자의 관점에서 서비스의 실제 구현은 중요하지 않으므로 &lt;code&gt;HeroesService&lt;/code&gt; 인터페이스 에 대해서만 코딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4eaac616f5e5e17f7e21411145e0904350881321" translate="yes" xml:space="preserve">
          <source>In a real world application, the &lt;code&gt;HeroesService&lt;/code&gt; would be responsible for making an HTTP request to the hero database to check if the alter ego is available. From the validator's point of view, the actual implementation of the service is not important, so the example can just code against the &lt;code&gt;HeroesService&lt;/code&gt; interface.</source>
          <target state="translated">실제 응용 프로그램에서 &lt;code&gt;HeroesService&lt;/code&gt; 는 다른 자아를 사용할 수 있는지 확인하기 위해 hero 데이터베이스에 HTTP 요청을 수행합니다. 유효성 검사기의 관점에서 서비스의 실제 구현은 중요하지 않으므로 예제는 &lt;code&gt;HeroesService&lt;/code&gt; 인터페이스 에 대해 코딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65531fa3aa55e1677f978dd0f3bf9d63a3c9b899" translate="yes" xml:space="preserve">
          <source>In a single-page app, you change what the user sees by showing or hiding portions of the display that correspond to particular components, rather than going out to the server to get a new page. As users perform application tasks, they need to move between the different &lt;a href=&quot;glossary#view&quot;&gt;views&lt;/a&gt; that you have defined.</source>
          <target state="translated">단일 페이지 앱에서는 새 페이지를 가져 오기 위해 서버로 이동하는 대신 특정 구성 요소에 해당하는 디스플레이 부분을 표시하거나 숨겨서 사용자에게 표시되는 내용을 변경합니다. 사용자는 응용 프로그램 작업을 수행 할 때 정의한 다른 &lt;a href=&quot;glossary#view&quot;&gt;보기&lt;/a&gt; 사이를 이동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d4f059d661f6b60ab2d7cea20ac87eea7d864f29" translate="yes" xml:space="preserve">
          <source>In a string, as milliseconds: &lt;code&gt;'100ms'&lt;/code&gt;</source>
          <target state="translated">문자열에서 밀리 초 : &lt;code&gt;'100ms'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f2235358d12c7b39b876e3be62943c44b49d011" translate="yes" xml:space="preserve">
          <source>In a string, as seconds: &lt;code&gt;'0.1s'&lt;/code&gt;</source>
          <target state="translated">문자열에서 초 단위 : &lt;code&gt;'0.1s'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b02b6bf1c988cc6d5e45d6127bc131c047c48941" translate="yes" xml:space="preserve">
          <source>In a template-driven form the source of truth is the template. You do not have direct programmatic access to the &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; instance, as shown in Figure 2.</source>
          <target state="translated">템플릿 기반 형식에서 진실의 근원은 템플릿입니다. 그림 2와 같이 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 인스턴스에 프로그래밍 방식으로 직접 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="94ab58ff64569d109e86670107a427804d9c8361" translate="yes" xml:space="preserve">
          <source>In a typical Angular project, the polyfill is not used in production builds, so removing it should not impact production applications. The goal behind this removal is overall simplification of the build setup and decrease in the number of external dependencies.</source>
          <target state="translated">일반적인 Angular 프로젝트에서 폴리 필은 프로덕션 빌드에 사용되지 않으므로 제거하면 프로덕션 애플리케이션에 영향을 미치지 않습니다. 이 제거의 목표는 빌드 설정을 전반적으로 단순화하고 외부 종속성 수를 줄이는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f31913605e059fbded1813d77c660c2f567cb66a" translate="yes" xml:space="preserve">
          <source>In actual development you will typically use the &lt;a href=&quot;guide/glossary#command-line-interface-cli&quot;&gt;Angular CLI&lt;/a&gt;, a powerful command-line tool that lets you generate and modify applications. For a full step-by-step guide that shows how to use the CLI to create a new project and all of its parts, see &lt;a href=&quot;tutorial&quot;&gt;Tutorial: Tour of Heroes&lt;/a&gt;.</source>
          <target state="translated">실제 개발에서는 일반적으로 애플리케이션을 생성하고 수정할 수있는 강력한 명령 줄 도구 인 &lt;a href=&quot;guide/glossary#command-line-interface-cli&quot;&gt;Angular CLI&lt;/a&gt; 를 사용합니다. CLI를 사용하여 새 프로젝트 및 모든 부분을 만드는 방법을 보여주는 전체 단계별 가이드는 &lt;a href=&quot;tutorial&quot;&gt;Tutorial : Tour of Heroes를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="72b71fb915e61812888abd66b33694904bf21659" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;../&lt;/code&gt;, you can use &lt;code&gt;./&lt;/code&gt; or no leading slash to specify the current level.</source>
          <target state="translated">&lt;code&gt;../&lt;/code&gt; 외에도 &lt;code&gt;./&lt;/code&gt; 를 사용 하거나 선행 슬래시를 사용하지 않고 현재 레벨을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="faa17f4e480d1c38b9b673c33c3726b0386461a6" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;component&lt;/code&gt;, the &lt;code&gt;data&lt;/code&gt; property of each route defines the key animation-specific configuration associated with a route. The &lt;code&gt;data&lt;/code&gt; property value is passed into &lt;code&gt;AppComponent&lt;/code&gt; when the route changes. You can also pass additional data in route config that is consumed within the animation. The data property value has to match the transitions defined in the &lt;code&gt;routeAnimation&lt;/code&gt; trigger, which we'll define later.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 및 &lt;code&gt;component&lt;/code&gt; 외에도 각 경로 의 &lt;code&gt;data&lt;/code&gt; 속성은 경로 와 관련된 주요 애니메이션 별 구성을 정의합니다. &lt;code&gt;data&lt;/code&gt; 속성 값으로 전달 &lt;code&gt;AppComponent&lt;/code&gt; 경로가 변경 될 때. 애니메이션 내에서 사용되는 경로 구성에서 추가 데이터를 전달할 수도 있습니다. 데이터 속성 값은 나중에 정의 할 &lt;code&gt;routeAnimation&lt;/code&gt; 트리거에 정의 된 전환과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="518ce8e445924106f3aaaa4e7714894c154607fc" translate="yes" xml:space="preserve">
          <source>In addition to build optimizations, Angular also has a runtime production mode. Angular apps run in development mode by default, as you can see by the following message on the browser console:</source>
          <target state="translated">Angular에는 빌드 최적화 외에도 런타임 프로덕션 모드가 있습니다. 브라우저 콘솔에서 다음 메시지로 볼 수 있듯이 각도 앱은 기본적으로 개발 모드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="92e4dba02fc399ceabf0edd421996ac182385627" translate="yes" xml:space="preserve">
          <source>In addition to components, there are two other kinds of directives: &lt;em&gt;structural&lt;/em&gt; and &lt;em&gt;attribute&lt;/em&gt;. Angular defines a number of directives of both kinds, and you can define your own using the &lt;code&gt;@&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;()&lt;/code&gt; decorator.</source>
          <target state="translated">구성 요소 외에도 두 가지 다른 유형의 지시문 인 &lt;em&gt;구조적&lt;/em&gt; 및 &lt;em&gt;속성이&lt;/em&gt; 있습니다. Angular는 두 가지 유형의 여러 지시문을 정의하며 &lt;code&gt;@&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;()&lt;/code&gt; 데코레이터를 사용하여 고유 한 지시문을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c4b67e633224044ac7bd833ae2a699b14035241e" translate="yes" xml:space="preserve">
          <source>In addition to containing or pointing to the template, the &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; metadata configures, for example, how the component can be referenced in HTML and what services it requires.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; 메타 데이터 는 템플릿을 포함하거나 가리키는 것 외에도 예를 들어 HTML에서 구성 요소를 참조 할 수있는 방법과 필요한 서비스를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="c324bf827f9e8b85ddf5cbe6b3ffb5a5a9dfb74d" translate="yes" xml:space="preserve">
          <source>In addition to fetching data from a server, &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; supports other HTTP methods such as PUT, POST, and DELETE, which you can use to modify the remote data.</source>
          <target state="translated">서버에서 데이터를 가져 오는 것 외에도 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 는 원격 데이터를 수정하는 데 사용할 수있는 PUT, POST 및 DELETE와 같은 다른 HTTP 메서드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="039608b3a3dac9dddfb10f624ea1dc12072178c7" translate="yes" xml:space="preserve">
          <source>In addition to fetching data from the server, &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; supports mutating requests, that is, sending data to the server with other HTTP methods such as PUT, POST, and DELETE.</source>
          <target state="translated">서버에서 데이터를 가져 오는 것 외에도 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 는 변경 요청, 즉 PUT, POST 및 DELETE와 같은 다른 HTTP 메서드를 사용하여 서버로 데이터를 보내는 것을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="705df2c178e744c66c353109a34235be8b2f64f7" translate="yes" xml:space="preserve">
          <source>In addition to loading modules on-demand, you can load modules asynchronously with preloading.</source>
          <target state="translated">주문형 모듈로드 외에도 사전로드를 사용하여 비동기식으로 모듈을로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b29a9483bfd852b5d32af6d3606da4cd76cef0c6" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;&lt;a href=&quot;../api/common/http/testing/testrequest#error&quot;&gt;error()&lt;/a&gt;&lt;/code&gt; handler that you provide on subscription, RxJS provides the &lt;code&gt;catchError&lt;/code&gt; operator that lets you handle known errors in the observable recipe.</source>
          <target state="translated">구독시 제공 하는 &lt;code&gt;&lt;a href=&quot;../api/common/http/testing/testrequest#error&quot;&gt;error()&lt;/a&gt;&lt;/code&gt; 핸들러 외에도 RxJS는 관찰 가능한 레시피에서 알려진 오류를 처리 할 수 있는 &lt;code&gt;catchError&lt;/code&gt; 연산자를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="92c75e8ae8b6ad9aee1ec9b36daa2b6542f56b8d" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;error()&lt;/code&gt; handler that you provide on subscription, RxJS provides the &lt;code&gt;catchError&lt;/code&gt; operator that lets you handle known errors in the observable recipe.</source>
          <target state="translated">구독시 제공 하는 &lt;code&gt;error()&lt;/code&gt; 핸들러 외에도 RxJS는 관찰 가능한 레시피에서 알려진 오류를 처리 할 수 있는 &lt;code&gt;catchError&lt;/code&gt; 연산자를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="4d17e5bcfee96b98472da1a3a4c26804c7ccb773" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;component&lt;/code&gt; properties, there's a new property called &lt;code&gt;outlet&lt;/code&gt;, which is set to &lt;code&gt;'popup'&lt;/code&gt;. This route now targets the popup outlet and the &lt;code&gt;ComposeMessageComponent&lt;/code&gt; will display there.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 및 &lt;code&gt;component&lt;/code&gt; 속성 외에도 &lt;code&gt;'popup'&lt;/code&gt; 으로 설정된 &lt;code&gt;outlet&lt;/code&gt; 이라는 새 속성 이 있습니다. 이 경로는 이제 팝업 콘센트를 대상으로하며 &lt;code&gt;ComposeMessageComponent&lt;/code&gt; 가 여기에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="99a32f2cf9ab38b55656a6b1806cd88678fd2727" translate="yes" xml:space="preserve">
          <source>In addition to the full mode behavior, Angular version 9:</source>
          <target state="translated">전체 모드 동작 외에도 Angular 버전 9 :</target>
        </trans-unit>
        <trans-unit id="c1e985521f9a2f7cb86a15d64a93de26e6cd3294" translate="yes" xml:space="preserve">
          <source>In addition to the name and description, each schematic has a &lt;code&gt;factory&lt;/code&gt; property that identifies the schematic&amp;rsquo;s entry point. In the example, you invoke the schematic's defined functionality by calling the &lt;code&gt;helloWorld()&lt;/code&gt; function in the main file, &lt;code&gt;hello-world/index.ts&lt;/code&gt;.</source>
          <target state="translated">이름과 설명 외에도 각 회로도에는 회로도의 진입 점을 식별 하는 &lt;code&gt;factory&lt;/code&gt; 속성이 있습니다. 이 예에서는 기본 파일 &lt;code&gt;hello-world/index.ts&lt;/code&gt; 에서 &lt;code&gt;helloWorld()&lt;/code&gt; 함수 를 호출하여 회로도의 정의 된 기능을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="712e3fe7e7a305ad3e3b3654a51a48abbd95e90e" translate="yes" xml:space="preserve">
          <source>In addition to upgrading AngularJS dependencies, you can also &lt;em&gt;downgrade&lt;/em&gt; Angular dependencies, so that you can use them from AngularJS. This can be useful when you start migrating services to Angular or creating new services in Angular while retaining components written in AngularJS.</source>
          <target state="translated">AngularJS 종속성을 업그레이드하는 것 외에도 Angular 종속성을 &lt;em&gt;다운 그레이드&lt;/em&gt; 하여 AngularJS에서 사용할 수 있습니다. 이는 AngularJS로 작성된 구성 요소를 유지하면서 서비스를 Angular로 마이그레이션하거나 Angular에서 새 서비스를 만들 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8a500fbb4767ecd8e3cddda60f46e32e83f4867" translate="yes" xml:space="preserve">
          <source>In addition, this pattern mixes template-driven and reactive forms strategies, which prevents taking advantage of the full benefits of either strategy. Setting the value in the template violates the template-agnostic principles behind reactive forms, whereas adding a &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; layer in the class removes the convenience of defining forms in the template.</source>
          <target state="translated">또한이 패턴은 템플릿 기반 및 반응 형 양식 전략을 혼합하여 두 전략의 모든 이점을 활용하지 못하게합니다. 템플릿에 값을 설정하는 것은 반응 양식 뒤에있는 템플릿에 구애받지 않는 원칙을 위반하는 반면 , 클래스에 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 레이어를 추가 하면 템플릿에서 양식을 정의하는 편리함이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="8190e8a3e053b6c71a891443caba3b79821b866e" translate="yes" xml:space="preserve">
          <source>In addition, this pattern mixes template-driven and reactive forms strategies, which we generally don't recommend because it doesn't take advantage of the full benefits of either strategy. Setting the value in the template violates the template-agnostic principles behind reactive forms, whereas adding a &lt;code&gt;&lt;a href=&quot;formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; layer in the class removes the convenience of defining forms in the template.</source>
          <target state="translated">또한이 패턴은 템플릿 중심 및 반응 형 전략을 혼합합니다.이 전략은 전략 중 하나의 장점을 모두 활용하지 않기 때문에 일반적으로 권장하지 않습니다. 템플릿에서 값을 설정하면 반응 형 양식 뒤에있는 템플릿에 독립적 인 원칙을 위반하는 반면 클래스에 &lt;code&gt;&lt;a href=&quot;formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 레이어를 추가 하면 템플릿에서 양식을 정의 할 때 편리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af0291fe53a38a32a912d25b30993b403d4fc87a" translate="yes" xml:space="preserve">
          <source>In alignment with the versioning scheme described above, we commit to support the following update paths:</source>
          <target state="translated">위에서 설명한 버전 관리 체계에 따라 다음 업데이트 경로를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c0ecac3c059187a5fafe89e15d014bf2e83d301b" translate="yes" xml:space="preserve">
          <source>In an &lt;code&gt;&lt;a href=&quot;httpinterceptor&quot;&gt;HttpInterceptor&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;httphandler&quot;&gt;HttpHandler&lt;/a&gt;&lt;/code&gt; parameter is the next interceptor in the chain.</source>
          <target state="translated">에서 &lt;code&gt;&lt;a href=&quot;httpinterceptor&quot;&gt;HttpInterceptor&lt;/a&gt;&lt;/code&gt; 상기 &lt;code&gt;&lt;a href=&quot;httphandler&quot;&gt;HttpHandler&lt;/a&gt;&lt;/code&gt; 를 파라미터는 체인의 다음 인터셉터이다.</target>
        </trans-unit>
        <trans-unit id="d07e81908343ee4b3c3cdfd03defc53493e77ee0" translate="yes" xml:space="preserve">
          <source>In an Angular app, NgModules and JavaScript modules work together.</source>
          <target state="translated">Angular 앱에서 NgModules와 JavaScript 모듈은 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2995d3f69c1ef04572631628ef95d9cf0e177e02" translate="yes" xml:space="preserve">
          <source>In an AngularJS application you have a root AngularJS module, which will also be used to bootstrap the AngularJS application.</source>
          <target state="translated">AngularJS 애플리케이션에는 루트 AngularJS 모듈이 있으며 AngularJS 애플리케이션을 부트 스트랩하는 데에도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fd772c1089107ba4b1e2e24a4046b9da7897a2c2" translate="yes" xml:space="preserve">
          <source>In an SPA, all of your application's functions exist in a single HTML page. As users access your application's features, the browser needs to render only the parts that matter to the user, instead of loading a new page. This pattern can significantly improve your application's user experience.</source>
          <target state="translated">SPA에서 응용 프로그램의 모든 기능은 단일 HTML 페이지에 있습니다. 사용자가 애플리케이션의 기능에 액세스 할 때 브라우저는 새 페이지를로드하는 대신 사용자에게 중요한 부분 만 렌더링하면됩니다. 이 패턴은 애플리케이션의 사용자 경험을 크게 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e0bac0cafa0bf97240de46fb6da1f0f46ccf556" translate="yes" xml:space="preserve">
          <source>In an event binding, Angular configures an event handler for the target event. You can use event binding with your own custom events.</source>
          <target state="translated">이벤트 바인딩에서 Angular는 대상 이벤트에 대한 이벤트 처리기를 구성합니다. 사용자 지정 이벤트에 이벤트 바인딩을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="186700bd8ef16b21e5cb3f12259a7cc3c66151a7" translate="yes" xml:space="preserve">
          <source>In an event binding, Angular sets up an event handler for the target event.</source>
          <target state="translated">이벤트 바인딩에서 Angular는 대상 이벤트에 대한 이벤트 핸들러를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="442397b093d27259b79b2a4c113aeacd3de8b1b6" translate="yes" xml:space="preserve">
          <source>In apps built with Angular versions prior to 6.0, services are registered NgModule &lt;code&gt;providers&lt;/code&gt; arrays as follows:</source>
          <target state="translated">6.0 이전의 Angular 버전으로 빌드 된 앱에서 서비스는 다음과 같이 NgModule &lt;code&gt;providers&lt;/code&gt; 배열로 등록 됩니다.</target>
        </trans-unit>
        <trans-unit id="36a5631d9ccd89307b737000baab048281f5974e" translate="yes" xml:space="preserve">
          <source>In both AngularJS and Angular, modules help you organize your application into cohesive blocks of functionality.</source>
          <target state="translated">AngularJS와 Angular 모두에서 모듈을 사용하면 응용 프로그램을 응집력있는 기능 블록으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f57cddaa2037c3cca33aee4543b80713320351a7" translate="yes" xml:space="preserve">
          <source>In both cases, the parenthetical annotation provides the error that caused the service worker to enter the degraded state.</source>
          <target state="translated">두 경우 모두 괄호 주석은 서비스 워커가 성능 저하 상태로 들어가는 오류를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="aab616ac7bc0cc1d96378c8b4324b09775cc128a" translate="yes" xml:space="preserve">
          <source>In both components you're relying on Angular's &lt;strong&gt;formGroup&lt;/strong&gt; to connect the template HTML to the underlying control objects, populated from the question model with display and validation rules.</source>
          <target state="translated">두 구성 요소 모두 Angular의 &lt;strong&gt;formGroup&lt;/strong&gt; 을 사용하여 템플릿 HTML을 기본 제어 객체에 연결하고 질문 모델에서 표시 및 유효성 검사 규칙으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="9d09b6e2a4873e3a91fe8b87647db6546a2185d7" translate="yes" xml:space="preserve">
          <source>In browsers that support Custom Elements natively, the specification requires developers use ES2015 classes to define Custom Elements - developers can opt-in to this by setting the &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkwithhref#target&quot;&gt;target&lt;/a&gt;: &quot;es2015&quot;&lt;/code&gt; property in their project's &lt;code&gt;tsconfig.json&lt;/code&gt;. As Custom Element and ES2015 support may not be available in all browsers, developers can instead choose to use a polyfill to support older browsers and ES5 code.</source>
          <target state="translated">기본적으로 사용자 정의 요소를 지원하는 브라우저에서 스펙은 개발자가 ES2015 클래스를 사용하여 사용자 정의 요소를 정의하도록 요구합니다. 개발자 는 프로젝트의 &lt;code&gt;tsconfig.json&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkwithhref#target&quot;&gt;target&lt;/a&gt;: &quot;es2015&quot;&lt;/code&gt; 특성 을 설정하여이를 선택할 수 있습니다 . 일부 브라우저에서는 Custom Element 및 ES2015 지원이 제공되지 않을 수 있으므로 개발자는 폴리 필을 사용하여 이전 브라우저 및 ES5 코드를 지원하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f37bb8d3eb739f6063c7dcad808c341026c89642" translate="yes" xml:space="preserve">
          <source>In browsers that support Custom Elements natively, the specification requires developers use ES2015 classes to define Custom Elements - developers can opt-in to this by setting the &lt;code&gt;target: &quot;es2015&quot;&lt;/code&gt; property in their project's &lt;a href=&quot;typescript-configuration&quot;&gt;TypeScript configuration file&lt;/a&gt;. As Custom Element and ES2015 support may not be available in all browsers, developers can instead choose to use a polyfill to support older browsers and ES5 code.</source>
          <target state="translated">사용자 지정 요소를 기본적으로 지원하는 브라우저에서 사양에 따라 개발자는 ES2015 클래스를 사용하여 사용자 지정 요소를 정의해야합니다. 개발자 는 프로젝트의 &lt;a href=&quot;typescript-configuration&quot;&gt;TypeScript 구성 파일&lt;/a&gt; 에서 &lt;code&gt;target: &quot;es2015&quot;&lt;/code&gt; 속성 을 설정하여이를 선택할 수 있습니다 . 모든 브라우저에서 Custom Element 및 ES2015 지원이 제공되지 않을 수 있으므로 개발자는 대신 폴리 필을 사용하여 이전 브라우저 및 ES5 코드를 지원하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79b4eea321a5de0ddf1c5f7ef405fd4e7f93c3ff" translate="yes" xml:space="preserve">
          <source>In case of a false positive like these, there are a few options:</source>
          <target state="translated">이와 같은 오 탐지의 경우 몇 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6851ccebdc3d3c36a33544a460a1db498eebbcf2" translate="yes" xml:space="preserve">
          <source>In case of a key collision between current parameters and those in the &lt;code&gt;queryParams&lt;/code&gt; object, the new value is used.</source>
          <target state="translated">현재 매개 변수와 &lt;code&gt;queryParams&lt;/code&gt; 객체 의 매개 변수간에 키 충돌이 발생 하면 새 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="16c543a5f2150ce78c5c42b4020166d1185b5263" translate="yes" xml:space="preserve">
          <source>In cases like this you can use a &lt;em&gt;factory provider&lt;/em&gt;. Factory providers can also be useful when creating an instance of a dependency from a third-party library that wasn't designed to work with DI.</source>
          <target state="translated">이런 경우 &lt;em&gt;팩토리 공급자를&lt;/em&gt; 사용할 수 있습니다 . 공장 공급자는 DI와 함께 작동하도록 설계되지 않은 타사 라이브러리에서 종속성 인스턴스를 만들 때도 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="faae4cf3fede383457b93e931cc0ff31f3e03fdd" translate="yes" xml:space="preserve">
          <source>In certain cases, when you apply backticks around a term, it may auto-link to the API documentation. If you do not intend the term to be a link, use the following syntax:</source>
          <target state="translated">경우에 따라 용어 주위에 백틱을 적용하면 API 문서에 자동 링크 될 수 있습니다. 용어를 링크로 사용하지 않으려면 다음 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f8ea84d921ad7b0f2cb3c42488bb64d56b2bfc41" translate="yes" xml:space="preserve">
          <source>In collaboration with Google's security team, we're adding support for the new Trusted Types API. This web platform API will help developers build more secure web applications.</source>
          <target state="translated">Google의 보안 팀과 협력하여 새로운 Trusted Types API에 대한 지원을 추가하고 있습니다. 이 웹 플랫폼 API는 개발자가보다 안전한 웹 애플리케이션을 구축하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="882fb17df5830c3e1bef3d000bb9f4170d23d509" translate="yes" xml:space="preserve">
          <source>In contrast to the non-AngularJS version &lt;code&gt;location.host&lt;/code&gt; which returns &lt;code&gt;hostname:port&lt;/code&gt;, this returns the &lt;code&gt;hostname&lt;/code&gt; portion only.</source>
          <target state="translated">&lt;code&gt;hostname:port&lt;/code&gt; 를 리턴하는 AngularJS 버전이 아닌 &lt;code&gt;location.host&lt;/code&gt; 와 달리 &lt;code&gt;hostname&lt;/code&gt; 부분 만 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="87ccfab30a30e01a9400a0f86574039dd8079e53" translate="yes" xml:space="preserve">
          <source>In data binding, you declare the relationship between an HTML widget and a data source and let the framework handle the details. Data binding is an alternative to manually pushing application data values into HTML, attaching event listeners, pulling changed values from the screen, and updating application data values.</source>
          <target state="translated">데이터 바인딩에서 HTML 위젯과 데이터 소스 간의 관계를 선언하고 프레임 워크가 세부 사항을 처리하게합니다. 데이터 바인딩은 수동으로 애플리케이션 데이터 값을 HTML로 푸시하고, 이벤트 리스너를 첨부하고, 화면에서 변경된 값을 가져오고, 애플리케이션 데이터 값을 업데이트하는 대안입니다.</target>
        </trans-unit>
        <trans-unit id="818ea6e396a842959f81b286c28f47f668e4c077" translate="yes" xml:space="preserve">
          <source>In developing a form, it's important to create a data-entry experience that guides the user efficiently and effectively through the workflow.</source>
          <target state="translated">양식을 개발할 때 워크 플로를 통해 사용자를 효율적이고 효과적으로 안내하는 데이터 입력 환경을 만드는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="a083380d8f26ba15bb7df0f10b038ec65342e2e3" translate="yes" xml:space="preserve">
          <source>In development mode, &lt;code&gt;&lt;a href=&quot;applicationref#tick&quot;&gt;tick()&lt;/a&gt;&lt;/code&gt; also performs a second change detection cycle to ensure that no further changes are detected. If additional changes are picked up during this second cycle, bindings in the app have side-effects that cannot be resolved in a single change detection pass. In this case, Angular throws an error, since an Angular application can only have one change detection pass during which all change detection must complete.</source>
          <target state="translated">개발 모드에서 &lt;code&gt;&lt;a href=&quot;applicationref#tick&quot;&gt;tick()&lt;/a&gt;&lt;/code&gt; 은 추가 변경이 감지되지 않도록 두 번째 변경 감지주기를 수행합니다. 이 두 번째주기 동안 추가 변경 사항이 발생하면 앱의 바인딩에 단일 변경 감지 단계에서 해결할 수없는 부작용이 있습니다. 이 경우 Angular 응용 프로그램은 모든 변경 감지가 완료되어야하는 변경 감지 패스를 하나만 가질 수 있으므로 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="811ec2dd2684204350fa7e95f0b850000a81e45e" translate="yes" xml:space="preserve">
          <source>In development mode, &lt;code&gt;&lt;a href=&quot;testing/tick&quot;&gt;tick&lt;/a&gt;()&lt;/code&gt; also performs a second change detection cycle to ensure that no further changes are detected. If additional changes are picked up during this second cycle, bindings in the app have side-effects that cannot be resolved in a single change detection pass. In this case, Angular throws an error, since an Angular application can only have one change detection pass during which all change detection must complete.</source>
          <target state="translated">개발 모드에서 &lt;code&gt;&lt;a href=&quot;testing/tick&quot;&gt;tick&lt;/a&gt;()&lt;/code&gt; 은 두 번째 변경 감지주기를 수행하여 더 이상 변경 사항이 감지되지 않도록합니다. 이 두 번째주기 중에 추가 변경이 선택되면 앱의 바인딩에는 단일 변경 감지 단계에서 해결할 수없는 부작용이 있습니다. 이 경우 Angular 응용 프로그램은 모든 변경 감지를 완료해야하는 하나의 변경 감지 패스 만 가질 수 있으므로 Angular는 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="8edaa0e56f5e0453fa057164fddb4d07e168ba3e" translate="yes" xml:space="preserve">
          <source>In development, you typically start the server in the folder that holds &lt;code&gt;index.html&lt;/code&gt;. That's the root folder and you'd add &lt;code&gt;&amp;lt;base href=&quot;/&quot;&amp;gt;&lt;/code&gt; near the top of &lt;code&gt;index.html&lt;/code&gt; because &lt;code&gt;/&lt;/code&gt; is the root of the app.</source>
          <target state="translated">개발시 일반적으로 &lt;code&gt;index.html&lt;/code&gt; 이 있는 폴더에서 서버를 시작합니다 . 이것이 루트 폴더이며 &lt;code&gt;/&lt;/code&gt; 는 앱의 루트 이므로 &lt;code&gt;index.html&lt;/code&gt; 의 상단 근처 에 &lt;code&gt;&amp;lt;base href=&quot;/&quot;&amp;gt;&lt;/code&gt; 를 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="d5e95ebfc9910d4c5b6ab6e521556a2778701651" translate="yes" xml:space="preserve">
          <source>In either case, a &lt;code&gt;next&lt;/code&gt; handler is required. The &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;complete&lt;/code&gt; handlers are optional.</source>
          <target state="translated">두 경우 모두 &lt;code&gt;next&lt;/code&gt; 처리기가 필요합니다. &lt;code&gt;error&lt;/code&gt; 및 &lt;code&gt;complete&lt;/code&gt; 핸들러는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="3ec537881a886f5726ad8dd47b7a8886c8935dfb" translate="yes" xml:space="preserve">
          <source>In either style, the template data bindings have the same access to the component's properties.</source>
          <target state="translated">어느 스타일이든 템플릿 데이터 바인딩은 구성 요소의 속성에 동일한 액세스 권한을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="0009c17cd723f367233376c40644dec66747da7a" translate="yes" xml:space="preserve">
          <source>In fact, each &lt;code&gt;subscribe()&lt;/code&gt; initiates a separate, independent execution of the observable. Subscribing twice results in two HTTP requests.</source>
          <target state="translated">실제로, &lt;code&gt;subscribe()&lt;/code&gt; 각각 은 Observable의 독립적 인 독립적 인 실행을 시작합니다. 두 번 구독하면 두 개의 HTTP 요청이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5809f58a35d5011cd952f322fe5b7ab8b70d3f4d" translate="yes" xml:space="preserve">
          <source>In fact, if you try to declare it, Angular will throw an error because &lt;code&gt;HeroDetailComponent&lt;/code&gt; is declared in both the &lt;code&gt;HeroModule&lt;/code&gt; and the &lt;code&gt;DynamicTestModule&lt;/code&gt; created by the &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">실제로 선언하려고하면 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 가 &lt;code&gt;HeroModule&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; 에 의해 생성 된 &lt;code&gt;DynamicTestModule&lt;/code&gt; 모두에 선언되어 Angular는 오류를 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="ec88266d9e04212fedf424f84a94840a7da988a9" translate="yes" xml:space="preserve">
          <source>In fact, many libraries declare and export components you'll never use. For example, a material design library will export all components because it doesn&amp;rsquo;t know which ones you will use. However, it is unlikely that you will use them all. For the ones you don't reference, the tree shaker drops these components from the final code package.</source>
          <target state="translated">실제로 많은 라이브러리는 절대 사용하지 않을 구성 요소를 선언하고 내 보냅니다. 예를 들어 머티리얼 디자인 라이브러리는 어떤 컴포넌트를 사용할지 모르기 때문에 모든 컴포넌트를 내 보냅니다. 그러나 당신이 그것들을 모두 사용하지는 않을 것입니다. 참조하지 않는 것들에 대해 트리 셰이커는 최종 코드 패키지에서 이러한 구성 요소를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="2d17b7b9c7ecdf9e0a0cf8fcb801a644d503a501" translate="yes" xml:space="preserve">
          <source>In fact, many libraries declare and export components you'll never use. If you don't reference them, the tree shaker drops these components from the final code package.</source>
          <target state="translated">실제로 많은 라이브러리는 절대 사용하지 않을 구성 요소를 선언하고 내 보냅니다. 참조하지 않으면 트리 셰이커는 이러한 구성 요소를 최종 코드 패키지에서 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="547d2a453086180e737f6fdfa0676b0213dec7f1" translate="yes" xml:space="preserve">
          <source>In general, a module collects a block of code dedicated to a single purpose. Angular uses standard JavaScript modules and also defines an Angular module, &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반적으로 모듈은 단일 목적 전용 코드 블록을 수집합니다. Angular는 표준 JavaScript 모듈을 사용하고 Angular 모듈 인 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="4d77226bb13d928e95fd3b19205296b9adedfdf9" translate="yes" xml:space="preserve">
          <source>In general, a test should end with no queued tasks. When pending timer tasks are expected, call &lt;code&gt;&lt;a href=&quot;../api/core/testing/discardperiodictasks&quot;&gt;discardPeriodicTasks&lt;/a&gt;&lt;/code&gt; to flush the &lt;em&gt;task&lt;/em&gt; queue and avoid the error.</source>
          <target state="translated">일반적으로 테스트는 대기중인 작업이 없어야합니다. 보류중인 타이머 작업이 예상되면 &lt;code&gt;&lt;a href=&quot;../api/core/testing/discardperiodictasks&quot;&gt;discardPeriodicTasks&lt;/a&gt;&lt;/code&gt; 를 호출 하여 &lt;em&gt;작업&lt;/em&gt; 대기열 을 비우고 오류를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="7f269edbebd5dbd35be8d8d21f57ea38f14f0483" translate="yes" xml:space="preserve">
          <source>In general, a test should wait for micro-tasks to finish. When pending microtasks are expected, call &lt;code&gt;&lt;a href=&quot;../api/core/testing/flushmicrotasks&quot;&gt;flushMicrotasks&lt;/a&gt;&lt;/code&gt; to flush the &lt;em&gt;micro-task&lt;/em&gt; queue and avoid the error.</source>
          <target state="translated">일반적으로 테스트는 마이크로 작업이 완료 될 때까지 기다려야합니다. 보류중인 &lt;em&gt;마이크로 태스크&lt;/em&gt; 가 예상되면 &lt;code&gt;&lt;a href=&quot;../api/core/testing/flushmicrotasks&quot;&gt;flushMicrotasks&lt;/a&gt;&lt;/code&gt; 를 호출 하여 &lt;em&gt;마이크로 태스크&lt;/em&gt; 큐 를 비우고 오류를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="86a59b8f427eaf262041822dcf531982a1f03fc3" translate="yes" xml:space="preserve">
          <source>In general, an observable &lt;em&gt;can&lt;/em&gt; return multiple values over time. An observable from &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; always emits a single value and then completes, never to emit again.</source>
          <target state="translated">일반적으로 Observable &lt;em&gt;은&lt;/em&gt; 시간이 지남에 따라 여러 값을 반환 할 &lt;em&gt;수 있습니다&lt;/em&gt; . &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 의 Observable은 항상 단일 값을 방출 한 다음 다시 생성되지 않고 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="5e2d4d2d17239584190561155953d01ace2b72bc" translate="yes" xml:space="preserve">
          <source>In general, if your builder is watching an external event, you should separate your run into three phases.</source>
          <target state="translated">일반적으로 빌더가 외부 이벤트를보고있는 경우 실행을 3 단계로 분리해야합니다.</target>
        </trans-unit>
        <trans-unit id="aec22f95ac1b949b2998ae911c74abd01d2c15c8" translate="yes" xml:space="preserve">
          <source>In general, prefer a &lt;em&gt;required route parameter&lt;/em&gt; when the value is mandatory (for example, if necessary to distinguish one route path from another); prefer an &lt;em&gt;optional parameter&lt;/em&gt; when the value is optional, complex, and/or multivariate.</source>
          <target state="translated">일반적으로 값이 필수 인 경우 &lt;em&gt;필수 경로 매개 변수를&lt;/em&gt; 선호하십시오 (예를 들어, 하나의 경로 경로를 다른 경로 경로와 구별하기 위해 필요한 경우). 값이 선택적, 복소수 및 / 또는 다변량 인 경우 &lt;em&gt;선택적 매개 변수를&lt;/em&gt; 선호하십시오 .</target>
        </trans-unit>
        <trans-unit id="438e5f838247227524217c35d94e78235058f28b" translate="yes" xml:space="preserve">
          <source>In general, the options for which you can configure defaults correspond to the command options listed in the &lt;a href=&quot;cli&quot;&gt;CLI reference page&lt;/a&gt; for each command. Note that all options in the configuration file must use &lt;a href=&quot;glossary#case-conventions&quot;&gt;camelCase&lt;/a&gt;, rather than dash-case.</source>
          <target state="translated">일반적으로 기본값을 구성 할 수있는 옵션 은 각 명령 의 &lt;a href=&quot;cli&quot;&gt;CLI 참조 페이지&lt;/a&gt; 에 나열된 명령 옵션에 해당합니다 . 구성 파일의 모든 옵션은 대소 문자가 아닌 &lt;a href=&quot;glossary#case-conventions&quot;&gt;camelCase를&lt;/a&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="071332d3fcf4e07411ee877b3275e2eb0b4251fa" translate="yes" xml:space="preserve">
          <source>In general, use a required route parameter when the value is mandatory (for example, if necessary to distinguish one route path from another); and an optional parameter when the value is optional, complex, and/or multivariate.</source>
          <target state="translated">일반적으로 값이 필수 인 경우 (예 : 한 경로 경로를 다른 경로와 구분하는 데 필요한 경우) 필수 경로 매개 변수를 사용합니다. 및 값이 선택적, 복합 및 / 또는 다변량 인 경우 선택적 매개 변수.</target>
        </trans-unit>
        <trans-unit id="e77fd6b5b523bff7e8b440e29979790902cc0d10" translate="yes" xml:space="preserve">
          <source>In general, you can expect the following release cycle:</source>
          <target state="translated">일반적으로 다음 릴리스주기를 기대할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec28d2e4f5ad480a00ce0f05033084610af0c773" translate="yes" xml:space="preserve">
          <source>In its constructor the class expects to get the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; service. It will be injected to it and it is stored as a private field. The service is then used in the two instance methods, one of which loads the list of all phones, and the other loads the details of a specified phone:</source>
          <target state="translated">생성자에서 클래스는 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 서비스 를 가져옵니다 . 그것에 주입되고 개인 필드로 저장됩니다. 그런 다음 서비스는 두 가지 인스턴스 방법으로 사용되는데, 그 중 하나는 모든 전화 목록을로드하고 다른 하나는 지정된 전화의 세부 정보를로드합니다.</target>
        </trans-unit>
        <trans-unit id="10bee31fc3bb8a012058efc875f19fcd7d9d1a4b" translate="yes" xml:space="preserve">
          <source>In its current state of development, the list of heroes is unchanged. No hero row is highlighted.</source>
          <target state="translated">현재 개발 상태에서 영웅 목록은 변경되지 않습니다. 영웅 행은 강조 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66cd232fa17c1dc9aef0e27428be497a6d102fd7" translate="yes" xml:space="preserve">
          <source>In javascript, only the components specified will be respected (not the ordering, punctuations, ...) and details of the formatting will be dependent on the locale.</source>
          <target state="translated">자바 스크립트에서는 지정된 구성 요소 만 (순서, 문장 부호 등이 아님) 존중되며 서식의 세부 사항은 로캘에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="0d3338acd7b1b7ae166fab204760470f14dd0bf5" translate="yes" xml:space="preserve">
          <source>In keeping with the &lt;a href=&quot;https://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html&quot;&gt;&lt;em&gt;Separation of Concerns&lt;/em&gt; principle&lt;/a&gt;, changes to the &lt;em&gt;Crisis Center&lt;/em&gt; won't affect the &lt;code&gt;AppModule&lt;/code&gt; or any other feature's component.</source>
          <target state="translated">과 유지에 &lt;a href=&quot;https://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html&quot;&gt;&lt;em&gt;대한 우려의 분리&lt;/em&gt; 원칙&lt;/a&gt; 의 변경 &lt;em&gt;위기 센터는&lt;/em&gt; 에 영향을주지 않습니다 &lt;code&gt;AppModule&lt;/code&gt; 또는 기타 기능의 구성 요소를.</target>
        </trans-unit>
        <trans-unit id="853f8e6f2cb1e2c46ec738de217850a392edd833" translate="yes" xml:space="preserve">
          <source>In keeping with the &lt;a href=&quot;https://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html&quot;&gt;Separation of Concerns principle&lt;/a&gt;, changes to the Crisis Center don't affect the &lt;code&gt;AppModule&lt;/code&gt; or any other feature's component.</source>
          <target state="translated">와 유지에 &lt;a href=&quot;https://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html&quot;&gt;대한 우려 원리의 분리&lt;/a&gt; , 위기 센터에 대한 변경 사항은 적용되지 않습니다 &lt;code&gt;AppModule&lt;/code&gt; 또는 기타 기능의 구성 요소를.</target>
        </trans-unit>
        <trans-unit id="e479f9e9a5e9f21bc571985b868b0e91139c16e1" translate="yes" xml:space="preserve">
          <source>In many cases, a few extra change detection runs may not matter much. However, on larger or change-detection-heavy apps they can have a noticeable impact. By giving you more fine-grained control over the change detection propagation, &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; allows you to achieve better performance for your hybrid apps.</source>
          <target state="translated">대부분의 경우 몇 가지 추가 변경 감지 실행이 중요하지 않을 수 있습니다. 그러나 더 크거나 변경 감지가 많은 앱에서는 눈에 띄는 영향을 줄 수 있습니다. &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; 사용하면 변경 감지 전파를보다 세밀하게 제어 하여 하이브리드 앱의 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48a267ffb8eee102602f050323760c06153f17ce" translate="yes" xml:space="preserve">
          <source>In many cases, these things end up as type &lt;code&gt;any&lt;/code&gt;, which can cause subsequent parts of the expression to go unchecked.</source>
          <target state="translated">대부분의 경우 이러한 항목은 &lt;code&gt;any&lt;/code&gt; 유형으로 끝나 므로 표현식의 후속 부분이 선택 해제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a95cdd0f6492c72732a9c49a995b576fef9af845" translate="yes" xml:space="preserve">
          <source>In modern JavaScript, every file is a module (see the &lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;Modules&lt;/a&gt; page of the Exploring ES6 website). Within each file you write an &lt;code&gt;export&lt;/code&gt; statement to make parts of the module public.</source>
          <target state="translated">최신 JavaScript에서 모든 파일은 모듈입니다 ( ES6 웹 사이트 탐색 의 &lt;a href=&quot;http://exploringjs.com/es6/ch_modules.html&quot;&gt;모듈&lt;/a&gt; 페이지 참조). 각 파일 내에서 &lt;code&gt;export&lt;/code&gt; 문을 작성하여 모듈의 일부를 공개합니다.</target>
        </trans-unit>
        <trans-unit id="6b3a1936e2bb54b1733be75ba49ac81b9f04f42d" translate="yes" xml:space="preserve">
          <source>In most cases, Angular sets the reference variable's value to the element on which it is declared. In the previous example, &lt;code&gt;phone&lt;/code&gt; refers to the phone number &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;. The button's click handler passes the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; value to the component's &lt;code&gt;callPhone()&lt;/code&gt; method.</source>
          <target state="translated">대부분의 경우 Angular는 참조 변수의 값을 선언 된 요소로 설정합니다. 이전 예에서 &lt;code&gt;phone&lt;/code&gt; 은 전화 번호 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 을 나타냅니다 . 버튼의 클릭 핸들러는 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 값을 컴포넌트의 &lt;code&gt;callPhone()&lt;/code&gt; 메소드로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="33a9a0ed6ca328ae17278ce786bea9fc84b93e7f" translate="yes" xml:space="preserve">
          <source>In most cases, Angular sets the template variable's value to the element on which it occurs. In the previous example, &lt;code&gt;phone&lt;/code&gt; refers to the phone number &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;. The button's click handler passes the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; value to the component's &lt;code&gt;callPhone()&lt;/code&gt; method.</source>
          <target state="translated">대부분의 경우 Angular는 템플릿 변수의 값을 발생하는 요소로 설정합니다. 이전 예에서 &lt;code&gt;phone&lt;/code&gt; 은 전화 번호 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 을 나타냅니다 . 버튼의 클릭 핸들러는 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 값을 구성 요소의 &lt;code&gt;callPhone()&lt;/code&gt; 메서드에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="736ac1880b027df49f2ca9b04f5528a48697f8fd" translate="yes" xml:space="preserve">
          <source>In most cases, the target name is the name of a property, even when it appears to be the name of an attribute. In this example, &lt;code&gt;src&lt;/code&gt; is the name of the &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; element property.</source>
          <target state="translated">대부분의 경우 대상 이름은 속성의 이름으로 표시 되더라도 속성의 이름입니다. 이 예에서 &lt;code&gt;src&lt;/code&gt; 는 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 요소 속성 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="10ed2cfffaf26fc3e0aa3455fa0236693ac809c8" translate="yes" xml:space="preserve">
          <source>In most cases, the target name is the name of a property, even when it appears to be the name of an attribute. So in this case, &lt;code&gt;src&lt;/code&gt; is the name of the &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; element property.</source>
          <target state="translated">대부분의 경우 대상 이름은 속성의 이름 인 것처럼 보일지라도 속성의 이름입니다. 따라서이 경우 &lt;code&gt;src&lt;/code&gt; 는 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 요소 속성 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="721c8146db87ee4117c032bdef6f8eeff7ecb43e" translate="yes" xml:space="preserve">
          <source>In most cases, though, the changes made locally in a particular component are of no interest to the rest of the app. For example, if the user clicks a button that submits a form, the component usually handles the result of this action. That being said, there &lt;em&gt;are&lt;/em&gt; cases where you want to propagate changes to some other part of the app that may be controlled by the other framework. In such cases, you are responsible for notifying the interested parties by manually triggering change detection.</source>
          <target state="translated">그러나 대부분의 경우 특정 구성 요소에서 로컬로 변경 한 내용은 나머지 앱에는 관심이 없습니다. 예를 들어, 사용자가 양식을 제출하는 단추를 클릭하면 구성 요소는 일반적으로이 조치의 결과를 처리합니다. 존재가 말했다, 거기에 &lt;em&gt;있습니다&lt;/em&gt; 당신이 다른 프레임 워크에 의해 제어 될 수있다 응용 프로그램의 다른 부분에 대한 변경 내용을 전파 할 경우가. 이러한 경우, 변경 감지를 수동으로 트리거하여 이해 당사자에게 알리는 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="769178628d41a1ca0bba1b67cab81af3ded8c26b" translate="yes" xml:space="preserve">
          <source>In most environments where both Angular and AngularJS are used to render the application, both frameworks are loaded in the initial bundle being sent to the client. This results in both increased bundle size and possible reduced performance.</source>
          <target state="translated">Angular와 AngularJS가 모두 응용 프로그램을 렌더링하는 데 사용되는 대부분의 환경에서 두 프레임 워크는 모두 클라이언트로 전송되는 초기 번들에로드됩니다. 그 결과 번들 크기가 증가하고 성능이 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae2161128d8ce5a1609bf9b304c9b1e1e65fa23d" translate="yes" xml:space="preserve">
          <source>In order for &lt;code&gt;HeroListComponent&lt;/code&gt; to get heroes from &lt;code&gt;HeroService&lt;/code&gt;, it needs to ask for &lt;code&gt;HeroService&lt;/code&gt; to be injected, rather than creating its own &lt;code&gt;HeroService&lt;/code&gt; instance with &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">위해서는 &lt;code&gt;HeroListComponent&lt;/code&gt; 에서 영웅 얻을 &lt;code&gt;HeroService&lt;/code&gt; 를 , 그것은을 요청해야 &lt;code&gt;HeroService&lt;/code&gt; 이 아니라 자신의 만드는 대신 주입 할 &lt;code&gt;HeroService&lt;/code&gt; 의 와 인스턴스를 &lt;code&gt;new&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1486ae81ea2e7bfb9b8495d2847f181583dc9fa5" translate="yes" xml:space="preserve">
          <source>In order for service workers to be registered, the app must be accessed over HTTPS, not HTTP. Browsers ignore service workers on pages that are served over an insecure connection. The reason is that service workers are quite powerful, so extra care needs to be taken to ensure the service worker script has not been tampered with.</source>
          <target state="translated">서비스 워커를 등록하려면 HTTP가 아닌 HTTPS를 통해 앱에 액세스해야합니다. 브라우저는 안전하지 않은 연결을 통해 제공되는 페이지에서 서비스 워커를 무시합니다. 그 이유는 서비스 워커가 상당히 강력하기 때문에 서비스 워커 스크립트가 변경되지 않도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="55fc82f93a9cf7270fcc2c4a6b145c2d1b0c0e64" translate="yes" xml:space="preserve">
          <source>In order to affect this browser's &lt;code&gt;history.state&lt;/code&gt; entry, the &lt;code&gt;&lt;a href=&quot;../animations/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; parameter can be passed. This must be an object because the router will add the &lt;code&gt;navigationId&lt;/code&gt; property to this object before creating the new history item.</source>
          <target state="translated">이 브라우저의 &lt;code&gt;history.state&lt;/code&gt; 항목 에 영향을주기 위해 &lt;code&gt;&lt;a href=&quot;../animations/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 매개 변수를 전달할 수 있습니다. 라우터는 새 기록 항목을 만들기 전에이 객체에 &lt;code&gt;navigationId&lt;/code&gt; 속성을 추가하기 때문에 객체 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="9363114f7d8e640fa6e1518ff3f8b7dfb1b36de7" translate="yes" xml:space="preserve">
          <source>In order to avoid negatively affecting the initial rendering of the page, &lt;code&gt;&lt;a href=&quot;../api/service-worker/serviceworkermodule&quot;&gt;ServiceWorkerModule&lt;/a&gt;&lt;/code&gt; waits for up to 30 seconds by default for the app to stabilize, before registering the ServiceWorker script. Constantly polling for updates, for example, with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval&quot;&gt;setInterval()&lt;/a&gt; or RxJS' &lt;a href=&quot;https://rxjs.dev/api/index/function/interval&quot;&gt;interval()&lt;/a&gt;, will prevent the app from stabilizing and the ServiceWorker script will not be registered with the browser until the 30 seconds upper limit is reached.</source>
          <target state="translated">페이지의 초기 렌더링에 부정적인 영향을주지 않기 위해 &lt;code&gt;&lt;a href=&quot;../api/service-worker/serviceworkermodule&quot;&gt;ServiceWorkerModule&lt;/a&gt;&lt;/code&gt; 은 ServiceWorker 스크립트를 등록하기 전에 앱이 안정화 될 때까지 기본적으로 최대 30 초 동안 대기합니다. 예를 들어 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval&quot;&gt;setInterval ()&lt;/a&gt; 또는 RxJS ' &lt;a href=&quot;https://rxjs.dev/api/index/function/interval&quot;&gt;interval ()을 사용&lt;/a&gt; 하여 업데이트를 지속적으로 폴링 하면 앱이 안정화되지 않으며 30 초 상한에 도달 할 때까지 ServiceWorker 스크립트가 브라우저에 등록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a72bcb56b58b81db6f4bbe1304ae9715f5beb78e" translate="yes" xml:space="preserve">
          <source>In order to avoid negatively affecting the initial rendering, &lt;code&gt;&lt;a href=&quot;../api/service-worker/serviceworkermodule&quot;&gt;ServiceWorkerModule&lt;/a&gt;&lt;/code&gt; will by default wait for the app to stabilize, before registering the ServiceWorker script. Constantly polling for updates, e.g. with &lt;code&gt;interval()&lt;/code&gt;, will prevent the app from stabilizing and the ServiceWorker script will never be registered with the browser.</source>
          <target state="translated">초기 렌더링에 부정적인 영향을주지 않기 위해 &lt;code&gt;&lt;a href=&quot;../api/service-worker/serviceworkermodule&quot;&gt;ServiceWorkerModule&lt;/a&gt;&lt;/code&gt; 은 기본적으로 ServiceWorker 스크립트를 등록하기 전에 앱이 안정화 될 때까지 기다립니다. 예를 들어 &lt;code&gt;interval()&lt;/code&gt; 과 같은 업데이트를 지속적으로 폴링 하면 앱이 안정화되지 않으며 ServiceWorker 스크립트가 브라우저에 등록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1661111f30e20e91e134221fa291556479a53887" translate="yes" xml:space="preserve">
          <source>In order to get a service from a dependency injector, you have to give it a &lt;a href=&quot;glossary#token&quot;&gt;token&lt;/a&gt;. Angular usually handles this transaction by specifying a constructor parameter and its type. The parameter type serves as the injector lookup token. Angular passes this token to the injector and assigns the result to the parameter.</source>
          <target state="translated">의존성 인젝터에서 서비스를 받으려면 &lt;a href=&quot;glossary#token&quot;&gt;토큰&lt;/a&gt; 을 제공해야합니다 . Angular는 일반적으로 생성자 매개 변수와 해당 유형을 지정하여이 트랜잭션을 처리합니다. 매개 변수 유형은 인젝터 조회 토큰 역할을합니다. Angular는이 토큰을 인젝터에 전달하고 결과를 매개 변수에 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f94d1573a258bdbefa8fe3b0d0e6c36603f171fd" translate="yes" xml:space="preserve">
          <source>In order to prevent collisions in environments where multiple Angular apps share the same domain or subdomain, give each application a unique cookie name.</source>
          <target state="translated">여러 Angular 앱이 동일한 도메인 또는 하위 도메인을 공유하는 환경에서 충돌을 방지하려면 각 애플리케이션에 고유 한 쿠키 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="780a866d90920d282e73259eea95fab806f34d7f" translate="yes" xml:space="preserve">
          <source>In order to prevent the native DOM form validation UI from interfering with Angular's form validation, Angular automatically adds the &lt;code&gt;novalidate&lt;/code&gt; attribute on any &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; whenever &lt;code&gt;FormModule&lt;/code&gt; or &lt;code&gt;ReactiveFormModule&lt;/code&gt; are imported into the application. If you want to explicitly enable native DOM validation UI with Angular forms, you can add the &lt;code&gt;ngNativeValidate&lt;/code&gt; attribute to the &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; element:</source>
          <target state="translated">네이티브 DOM 양식 유효성 검사 UI가 Angular의 양식 유효성 검사를 방해하지 않도록하기 위해 Angular는 &lt;code&gt;FormModule&lt;/code&gt; 또는 &lt;code&gt;ReactiveFormModule&lt;/code&gt; 을 애플리케이션으로 가져올 때마다 모든 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 에 &lt;code&gt;novalidate&lt;/code&gt; 속성을 자동으로 추가합니다 . Angular 형식으로 네이티브 DOM 유효성 검사 UI를 명시 적으로 활성화하려면 &lt;code&gt;ngNativeValidate&lt;/code&gt; 속성을 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 요소에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4207009e54950800ab6d8cc8ef740aa53fc90034" translate="yes" xml:space="preserve">
          <source>In order to show how subscribing works, we need to create a new observable. There is a constructor that you use to create new instances, but for illustration, we can use some methods from the RxJS library that create simple observables of frequently used types:</source>
          <target state="translated">구독이 어떻게 작동하는지 보여 주려면 새로운 Observable을 만들어야합니다. 새 인스턴스를 만드는 데 사용하는 생성자가 있지만 설명을 위해 RxJS 라이브러리에서 자주 사용되는 유형의 간단한 Observable을 만드는 일부 메서드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7421599f9ced2cc1d0119ff73276a78a40f53ee" translate="yes" xml:space="preserve">
          <source>In order to start using any &lt;code&gt;&lt;a href=&quot;../api/upgrade/static&quot;&gt;upgrade/static&lt;/a&gt;&lt;/code&gt; APIs, you still need to load the Angular framework as you would in a normal Angular app. You can see how this can be done with SystemJS by following the instructions in the &lt;a href=&quot;upgrade-setup&quot;&gt;Upgrade Setup&lt;/a&gt; guide, selectively copying code from the &lt;a href=&quot;https://github.com/angular/quickstart&quot;&gt;QuickStart github repository&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/upgrade/static&quot;&gt;upgrade/static&lt;/a&gt;&lt;/code&gt; API 사용을 시작하려면 일반 Angular 앱에서와 같이 Angular 프레임 워크를로드해야합니다. &lt;a href=&quot;upgrade-setup&quot;&gt;업그레이드 설정&lt;/a&gt; 안내서 의 지시 사항에 따라 선택적으로 &lt;a href=&quot;https://github.com/angular/quickstart&quot;&gt;QuickStart github 저장소&lt;/a&gt; 에서 코드를 복사 하여 SystemJS로이를 수행하는 방법을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b399fc11c8e33350c9084a487ba836c3f3fbcb6" translate="yes" xml:space="preserve">
          <source>In order to use the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt;, you must first register the &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;@angular/router&lt;/code&gt; package. Define an array of routes, &lt;code&gt;appRoutes&lt;/code&gt;, and pass them to the &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; method. The &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; method returns a module that contains the configured &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; service provider, plus other providers that the routing library requires. Once the application is bootstrapped, the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; performs the initial navigation based on the current browser URL.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 를 사용 하려면 먼저 &lt;code&gt;@angular/router&lt;/code&gt; 패키지 에서 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; 을 등록해야 합니다. 경로 배열, &lt;code&gt;appRoutes&lt;/code&gt; 를 정의하고 이를 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; 메서드에 전달합니다 . &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; 메소드는 구성이 포함 된 모듈 반환 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 라우팅 라이브러리가 필요로하는 서비스 제공 업체, 플러스 다른 공급자를. 애플리케이션이 부트 스트랩되면 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 는 현재 브라우저 URL을 기반으로 초기 탐색을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4470d8f6deb5914d926efe231421cb63adc8fc6e" translate="yes" xml:space="preserve">
          <source>In order to use the Router, you must first register the &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;@angular/router&lt;/code&gt; package. Define an array of routes, &lt;code&gt;appRoutes&lt;/code&gt;, and pass them to the &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; method. It returns a module, containing the configured &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; service provider, plus other providers that the routing library requires. Once the application is bootstrapped, the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; performs the initial navigation based on the current browser URL.</source>
          <target state="translated">라우터를 사용하려면 먼저 &lt;code&gt;@angular/router&lt;/code&gt; 패키지 에서 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; 을 등록해야 합니다. 경로 배열 &lt;code&gt;appRoutes&lt;/code&gt; 를 정의 하고 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; 메서드에 전달합니다 . 구성된 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 서비스 공급자와 라우팅 라이브러리에 필요한 다른 공급자를 포함하는 모듈을 반환 합니다. 응용 프로그램이 부트 스트랩되면 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 는 현재 브라우저 URL을 기반으로 초기 탐색을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="897444e729da5c78809ebd111c1752c8e27f14fc" translate="yes" xml:space="preserve">
          <source>In order to use the routable animations, wrap the &lt;code&gt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;RouterOutlet&lt;/a&gt;&lt;/code&gt; inside an element, use the &lt;code&gt;@routeAnimation&lt;/code&gt; trigger, and bind it to the element.</source>
          <target state="translated">상기 라우팅 애니메이션을 사용하기 위해 포장 &lt;code&gt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;RouterOutlet&lt;/a&gt;&lt;/code&gt; 를 소자 내부에 사용 &lt;code&gt;@routeAnimation&lt;/code&gt; 된 트리거와 결합을하는 요소이다.</target>
        </trans-unit>
        <trans-unit id="6297dda86acaaaf319ab64751d910390522f6fd8" translate="yes" xml:space="preserve">
          <source>In order to use the routable animations, you'll need to wrap the &lt;code&gt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;RouterOutlet&lt;/a&gt;&lt;/code&gt; inside an element. You'll use the &lt;code&gt;@routeAnimation&lt;/code&gt; trigger and bind it to the element.</source>
          <target state="translated">라우팅 가능한 애니메이션을 사용하려면 &lt;code&gt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;RouterOutlet&lt;/a&gt;&lt;/code&gt; 을 요소 안에 싸야 합니다. &lt;code&gt;@routeAnimation&lt;/code&gt; 트리거를 사용 하여 요소에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="eeef063c79aeb4f50044a9152e97103442e703f1" translate="yes" xml:space="preserve">
          <source>In other words, when the user clicks this link, the router displays the component associated with the &lt;code&gt;compose&lt;/code&gt; route in the &lt;code&gt;popup&lt;/code&gt; outlet.</source>
          <target state="translated">즉, 사용자가이 링크를 클릭하면 라우터가 &lt;code&gt;popup&lt;/code&gt; 아웃렛에 경로 &lt;code&gt;compose&lt;/code&gt; 과 관련된 구성 요소를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="4e52e5c3032e6187e657dc00cec1cd2b072053ce" translate="yes" xml:space="preserve">
          <source>In other words, you're required to use &lt;code&gt;../&lt;/code&gt; rather than &lt;code&gt;./&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;./&lt;/code&gt; 대신 &lt;code&gt;../&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ba35e15dd4c15f46ec67b54f17b33214638dd487" translate="yes" xml:space="preserve">
          <source>In other words, you're required to use &lt;code&gt;../&lt;/code&gt; rather than &lt;code&gt;./&lt;/code&gt;. This is currently the default behavior. Setting this option to &lt;code&gt;corrected&lt;/code&gt; enables the fix.</source>
          <target state="translated">즉, &lt;code&gt;./&lt;/code&gt; 대신 &lt;code&gt;../&lt;/code&gt; 를 사용해야 합니다. 이것이 현재 기본 동작입니다. 이 옵션을 &lt;code&gt;corrected&lt;/code&gt; 설정하면 수정이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="87df4a79a4f147a95a370ebf7d5c2192bfdcb408" translate="yes" xml:space="preserve">
          <source>In our example, the shell command either finishes or is still executing, so there&amp;rsquo;s no need for a progress report, but we can report status so that a parent builder that called our builder would know what&amp;rsquo;s going on. Use the &lt;code&gt;BuilderContext.reportStatus()&lt;/code&gt; method to generate a status string of any length. (Note that there&amp;rsquo;s no guarantee that a long string will be shown entirely; it could be cut to fit the UI that displays it.) Pass an empty string to remove the status.</source>
          <target state="translated">이 예에서 쉘 명령이 완료되거나 여전히 실행 중이므로 진행률 보고서가 필요하지 않지만 빌더를 호출 한 상위 빌더가 진행 상황을 알 수 있도록 상태를보고 할 수 있습니다. &lt;code&gt;BuilderContext.reportStatus()&lt;/code&gt; 메소드를 사용하여 모든 길이의 상태 문자열을 생성하십시오. 긴 문자열이 완전히 표시된다는 보장은 없습니다. 표시되는 UI에 맞게 잘릴 수 있습니다. 빈 문자열을 전달하여 상태를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="56455dddd0518d118b14439b2bec10125d4d70c4" translate="yes" xml:space="preserve">
          <source>In our two-state button example, the wildcard isn't that useful because there are only two possible states, &lt;code&gt;open&lt;/code&gt; and &lt;code&gt;closed&lt;/code&gt;. Wildcard states are better when an element in one particular state has multiple potential states that it can change to. If our button can change from &lt;code&gt;open&lt;/code&gt; to either &lt;code&gt;closed&lt;/code&gt; or something like &lt;code&gt;inProgress&lt;/code&gt;, using a wildcard state could reduce the amount of coding needed.</source>
          <target state="translated">두 상태 버튼 예제에서 와일드 카드는 &lt;code&gt;open&lt;/code&gt; 및 &lt;code&gt;closed&lt;/code&gt; 두 가지 가능한 상태 만 있기 때문에 그다지 유용하지 않습니다 . 와일드 카드 상태는 특정 상태의 요소에 여러 개의 잠재적 상태가있을 때 더 좋습니다. 버튼이 &lt;code&gt;open&lt;/code&gt; 에서 &lt;code&gt;closed&lt;/code&gt; 또는 &lt;code&gt;inProgress&lt;/code&gt; 와 같이 변경 될 수있는 경우 와일드 카드 상태를 사용하면 필요한 코딩 양을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f50e734f65a9ec214fd856de2782d754d78c4fd5" translate="yes" xml:space="preserve">
          <source>In practical terms, the &lt;code&gt;package.json&lt;/code&gt; of all &lt;code&gt;@angular&lt;/code&gt; packages has changed in the following way:</source>
          <target state="translated">실제적 으로 모든 &lt;code&gt;@angular&lt;/code&gt; 패키지 의 &lt;code&gt;package.json&lt;/code&gt; 은 다음과 같이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="1caf8483b03bd6de160e2caf8712a24854fe9bca" translate="yes" xml:space="preserve">
          <source>In practice you will combine the two techniques in the same setup, as seen in this example.</source>
          <target state="translated">실제로이 예제에서 볼 수 있듯이 두 가지 기술을 동일한 설정으로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="19ce34decb85894b971f2d3e1bfcf73bc88fa732" translate="yes" xml:space="preserve">
          <source>In practice you would rarely, if ever, implement all of the interfaces the way this demo does.</source>
          <target state="translated">실제로이 데모가 수행하는 방식으로 모든 인터페이스를 구현하는 경우는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="59bc493aece50f258b777e6728d20541b44060b9" translate="yes" xml:space="preserve">
          <source>In practice, this means that data in Angular flows downward during change detection. A parent component can easily change values in its child components because the parent is checked first. A failure could occur, however, if a child component tries to change a value in its parent during change detection (inverting the expected data flow), because the parent component has already been rendered. In development mode, Angular throws the &lt;code&gt;ExpressionChangedAfterItHasBeenCheckedError&lt;/code&gt; error if your app attempts to do this, rather than silently failing to render the new value.</source>
          <target state="translated">실제로 이것은 Angular의 데이터가 변경 감지 중에 아래로 흐른다는 것을 의미합니다. 상위 구성 요소가 먼저 확인되기 때문에 상위 구성 요소는 하위 구성 요소의 값을 쉽게 변경할 수 있습니다. 그러나 부모 구성 요소가 이미 렌더링 되었기 때문에 변경 감지 (예상 데이터 흐름 반전) 중에 자식 구성 요소가 부모의 값을 변경하려고하면 실패가 발생할 수 있습니다. 개발 모드에서 Angular는 앱이 새 값을 자동으로 렌더링하는 데 실패하지 않고이를 시도하면 &lt;code&gt;ExpressionChangedAfterItHasBeenCheckedError&lt;/code&gt; 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="72487f978bdb8dcb1ae15d26b5e9d260c3656cb7" translate="yes" xml:space="preserve">
          <source>In practice, you do not need to call &lt;code&gt;$apply()&lt;/code&gt;, regardless of whether it is in AngularJS or Angular. The &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; does it for us. You &lt;em&gt;can&lt;/em&gt; still call &lt;code&gt;$apply()&lt;/code&gt; so there is no need to remove such calls from existing code. Those calls just trigger additional AngularJS change detection checks in a hybrid application.</source>
          <target state="translated">실제로 AngularJS 또는 Angular에 관계없이 &lt;code&gt;$apply()&lt;/code&gt; 를 호출 할 필요는 없습니다 . &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 는 우리를 위해 그것을 않습니다. 당신은 &lt;em&gt;할 수 있습니다&lt;/em&gt; 여전히 전화 &lt;code&gt;$apply()&lt;/code&gt; 기존 코드에서 이러한 호출을 제거 할 필요가 없습니다 그래서. 이러한 호출은 하이브리드 애플리케이션에서 추가 AngularJS 변경 감지 검사를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="56d227fe5a68e4aaa849b0aa5c4de2fef9bb36da" translate="yes" xml:space="preserve">
          <source>In practice, you'll serve a static version of the landing page to hold the user's attention. At the same time, you'll load the full Angular app behind it. The user perceives near-instant performance from the landing page and gets the full interactive experience after the full app loads.</source>
          <target state="translated">실제로는 사용자의 관심을 끌기 위해 정적 버전의 방문 페이지를 제공합니다. 동시에 전체 Angular 앱을 그 뒤에로드합니다. 사용자는 랜딩 페이지에서 거의 즉각적인 성능을 인식하고 전체 앱이로드 된 후 완전한 대화식 경험을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="e2ade5ef587790075852d0ae228268c6578796df" translate="yes" xml:space="preserve">
          <source>In production, change detection kicks in automatically when Angular creates a component or the user enters a keystroke or an asynchronous activity (e.g., AJAX) completes.</source>
          <target state="translated">생산 과정에서 Angular가 구성 요소를 만들거나 사용자가 키 입력 또는 비동기 작업 (예 : AJAX)이 완료되면 변경 감지가 자동으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="2fca238085be2c83aa003fed9d03817a9fd8a50e" translate="yes" xml:space="preserve">
          <source>In reactive forms each form element in the view is directly linked to the form model (a &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; instance). Updates from the view to the model and from the model to the view are synchronous and do not depend on how the UI is rendered.</source>
          <target state="translated">반응 형 양식에서보기의 각 양식 요소는 양식 모델 ( &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 인스턴스)에 직접 연결됩니다 . 뷰에서 모델로, 모델에서 뷰로의 업데이트는 동기식이며 UI가 렌더링되는 방식에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8936ace2212f0d937e8bae060b90d1889ddfbb89" translate="yes" xml:space="preserve">
          <source>In reactive forms, add a custom validator by passing the function directly to the &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">반응 형 양식에서는 함수를 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 에 직접 전달하여 사용자 지정 유효성 검사기를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="8a8f761c448cb0a19d0d2a50bc0673ac4a1199f4" translate="yes" xml:space="preserve">
          <source>In reactive forms, custom validators are fairly simple to add. All you have to do is pass the function directly to the &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">반응적인 형식에서 사용자 지정 유효성 검사기는 추가하기가 매우 간단합니다. 함수를 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 에 직접 전달하기 만하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="12b205922219ca09964fb9aa93ac6d2fb7837eb1" translate="yes" xml:space="preserve">
          <source>In response to a click event, call the component's click handler, &lt;code&gt;add()&lt;/code&gt;, and then clear the input field so that it's ready for another name. Add the following to the &lt;code&gt;HeroesComponent&lt;/code&gt; class:</source>
          <target state="translated">click 이벤트에 대한 응답으로 컴포넌트의 클릭 핸들러 &lt;code&gt;add()&lt;/code&gt; 호출 한 다음 다른 이름을 사용할 수 있도록 입력 필드를 지우십시오. &lt;code&gt;HeroesComponent&lt;/code&gt; 클래스에 다음을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e6c06858e21d619cbdb8f3726f8b28d11719707" translate="yes" xml:space="preserve">
          <source>In simple examples, the dependency value is an &lt;em&gt;instance&lt;/em&gt;, and the class &lt;em&gt;type&lt;/em&gt; serves as its own lookup key. Here you get a &lt;code&gt;HeroService&lt;/code&gt; directly from the injector by supplying the &lt;code&gt;HeroService&lt;/code&gt; type as the token:</source>
          <target state="translated">간단한 예에서 종속성 값은 &lt;em&gt;인스턴스&lt;/em&gt; 이며 클래스 &lt;em&gt;유형&lt;/em&gt; 은 자체 조회 키 역할을합니다. 여기서 &lt;code&gt;HeroService&lt;/code&gt; 유형을 토큰으로 제공하여 인젝터에서 직접 &lt;code&gt;HeroService&lt;/code&gt; 를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="d61cd7b51c3a752e9e5224c7c2a9c10d341bcf87" translate="yes" xml:space="preserve">
          <source>In simpler terms, you might say this of the first route:</source>
          <target state="translated">간단히 말해 첫 번째 경로에 대해 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39a7262903072552ce7e1de93133df4200dff76f" translate="yes" xml:space="preserve">
          <source>In some cases you'll want to bypass the Angular CLI builder, and run the Bazel CLI directly. The Bazel CLI is in the &lt;code&gt;@bazel/bazel&lt;/code&gt; npm package. You can install it globally to get the &lt;code&gt;bazel&lt;/code&gt; command in your path, or use &lt;code&gt;$(npm bin)/bazel&lt;/code&gt; in place of bazel below.</source>
          <target state="translated">경우에 따라 Angular CLI 빌더를 무시하고 Bazel CLI를 직접 실행하려고 할 수 있습니다. Bazel CLI는 &lt;code&gt;@bazel/bazel&lt;/code&gt; npm 패키지에 있습니다. 전역에 설치 하여 경로에 &lt;code&gt;bazel&lt;/code&gt; 명령 을 가져 오거나 아래 bazel 대신 &lt;code&gt;$(npm bin)/bazel&lt;/code&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7d9f5a7f5bfd6aa1d897c40b145e3b00e9125c8" translate="yes" xml:space="preserve">
          <source>In some cases, the version of the app used by the service worker to serve a client might be in a broken state that cannot be recovered from without a full page reload.</source>
          <target state="translated">경우에 따라 서비스 워커가 클라이언트를 제공하는 데 사용하는 앱 버전이 전체 페이지를 다시로드하지 않으면 복구 할 수없는 손상된 상태 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ab622d819a42312798e6536f01d0dc402cced7a" translate="yes" xml:space="preserve">
          <source>In some cases, you may want to bypass the service worker entirely and let the browser handle the request instead. An example is when you rely on a feature that is currently not supported in service workers (e.g. &lt;a href=&quot;https://github.com/w3c/ServiceWorker/issues/1141&quot;&gt;reporting progress on uploaded files&lt;/a&gt;).</source>
          <target state="translated">경우에 따라 서비스 워커를 완전히 무시하고 브라우저가 대신 요청을 처리하도록 할 수 있습니다. 예를 들어 현재 서비스 워커에서 지원되지 않는 기능 (예 : &lt;a href=&quot;https://github.com/w3c/ServiceWorker/issues/1141&quot;&gt;업로드 된 파일에 대한 진행률보고)&lt;/a&gt; 에 의존하는 경우가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="61bb49903d1d4b8480b074b2d9731adbded4bf41" translate="yes" xml:space="preserve">
          <source>In some cases, you need to limit the search or accommodate a missing dependency. You can modify Angular's search behavior with the &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;&lt;/code&gt; qualifying decorators on a service-valued parameter of the component's constructor.</source>
          <target state="translated">경우에 따라 검색을 제한하거나 누락 된 종속성을 수용해야합니다. 컴포넌트 생성자의 서비스 값 매개 변수 에서 &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;&lt;/code&gt; 한정 데코레이터를 사용하여 Angular의 검색 동작을 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9660b78fcdbbefc9e6c733e9357058335454ef4b" translate="yes" xml:space="preserve">
          <source>In some tests, you're more interested in how an injected service method was called and what values it returned, than what appears on screen.</source>
          <target state="translated">일부 테스트에서는 주입 된 서비스 메소드가 호출 된 방법과 리턴 된 값이 화면에 나타나는 것보다 더 관심이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d234d3f817a0a34e6196f4aad3f42f5e028ff0f6" translate="yes" xml:space="preserve">
          <source>In specific situations, it might be necessary to disable sanitization, for example if the application genuinely needs to produce a &lt;code&gt;javascript:&lt;/code&gt; style link with a dynamic value in it. Users can bypass security by constructing a value with one of the &lt;code&gt;bypassSecurityTrust...&lt;/code&gt; methods, and then binding to that value from the template.</source>
          <target state="translated">특정 상황에서 애플리케이션 이 동적 값을 가진 &lt;code&gt;javascript:&lt;/code&gt; 스타일 링크 를 생성해야하는 경우와 같이 소독을 비활성화해야 할 수도 있습니다 . &lt;code&gt;bypassSecurityTrust...&lt;/code&gt; 메소드 중 하나를 사용하여 값을 구성한 후 템플리트에서 해당 값에 바인딩하여 보안을 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8e398ebcd66ab590bdd5d974fb4832daf67c817" translate="yes" xml:space="preserve">
          <source>In sum, you can write applications with one, two or more levels of routing. The link parameters array affords the flexibility to represent any routing depth and any legal sequence of route paths, (required) router parameters, and (optional) route parameter objects.</source>
          <target state="translated">요약하면, 하나, 둘 이상의 레벨의 라우팅으로 응용 프로그램을 작성할 수 있습니다. 링크 매개 변수 배열은 라우팅 깊이와 유효한 경로 경로, (필수) 라우터 매개 변수 및 (선택적) 경로 매개 변수 객체를 표현할 수있는 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="623f5e0e06cac9546fad2e1d9d858205754ab9a5" translate="yes" xml:space="preserve">
          <source>In summary, you can write applications with one, two or more levels of routing. The link parameters array affords the flexibility to represent any routing depth and any legal sequence of route paths, (required) router parameters, and (optional) route parameter objects.</source>
          <target state="translated">요약하면, 하나, 둘 또는 그 이상의 라우팅 레벨로 애플리케이션을 작성할 수 있습니다. 링크 매개 변수 배열은 라우팅 깊이와 경로 경로, (필수) 라우터 매개 변수 및 (선택 사항) 경로 매개 변수 객체의 합법적 인 순서를 나타내는 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c33d61663fac8d5f31f41cf19abfab91e3740d51" translate="yes" xml:space="preserve">
          <source>In summary, you want to delay rendering the routed component until all necessary data has been fetched.</source>
          <target state="translated">요약하면 필요한 모든 데이터를 가져올 때까지 라우팅 된 구성 요소의 렌더링을 지연하려고합니다.</target>
        </trans-unit>
        <trans-unit id="e104dcb833aabc752ad0a3c07890da8319df3538" translate="yes" xml:space="preserve">
          <source>In summary, you want to delay rendering the routed component until all necessary data have been fetched.</source>
          <target state="translated">요약하면 필요한 모든 데이터를 가져올 때까지 라우팅 된 구성 요소 렌더링을 지연하려고합니다.</target>
        </trans-unit>
        <trans-unit id="83125967d52de259af9ac73a04025e6be705f964" translate="yes" xml:space="preserve">
          <source>In template driven forms, all &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tags are automatically tagged as &lt;code&gt;&lt;a href=&quot;ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt;. To import the &lt;code&gt;&lt;a href=&quot;formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; but skip its usage in some forms, for example, to use native HTML5 validation, add the &lt;code&gt;ngNoForm&lt;/code&gt; and the &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tags won't create an &lt;code&gt;&lt;a href=&quot;ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; directive. In reactive forms, using &lt;code&gt;ngNoForm&lt;/code&gt; is unnecessary because the &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tags are inert. In that case, you would refrain from using the &lt;code&gt;formGroup&lt;/code&gt; directive.</source>
          <target state="translated">템플릿 기반 양식에서 모든 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 태그는 &lt;code&gt;&lt;a href=&quot;ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; 으로 자동 태그 지정됩니다 . 가져 오려면 &lt;code&gt;&lt;a href=&quot;formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; 을 하지만, 기본 HTML5 유효성 검사를 사용하는 추가 예를 들어, 어떤 형태로의 사용을 건너 &lt;code&gt;ngNoForm&lt;/code&gt; 하고 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 태그는 작성하지 않습니다 &lt;code&gt;&lt;a href=&quot;ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; 의 지시를. 반응성 양식에서는 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 태그가 비활성 이므로 &lt;code&gt;ngNoForm&lt;/code&gt; 을 사용할 필요가 없습니다 . 이 경우 &lt;code&gt;formGroup&lt;/code&gt; 지시어 를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="477e647d8c0ecb9558b0cd8c664fca639f6f099b" translate="yes" xml:space="preserve">
          <source>In template driven forms, if you've imported &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt;, you don't have to do anything to the &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tag in order to make use of &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt;. Continue on to see how this works.</source>
          <target state="translated">당신이 가져온 경우 템플릿 중심 형태에서, &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; 을 , 당신은 아무것도 할 필요가 없습니다 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 의 메이크업에 사용하기 위해 태그를 &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; . 이것이 어떻게 작동하는지 계속 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="fdd04dd82ac2e2c71275724a71c50dd3e5b6d107" translate="yes" xml:space="preserve">
          <source>In template-driven forms, add a directive to the template, where the directive wraps the validator function. For example, the corresponding &lt;code&gt;ForbiddenValidatorDirective&lt;/code&gt; serves as a wrapper around the &lt;code&gt;forbiddenNameValidator&lt;/code&gt;.</source>
          <target state="translated">템플릿 기반 양식에서 지시문을 템플릿에 추가하면 지시문이 유효성 검사기 기능을 래핑합니다. 예를 들어, 해당 &lt;code&gt;ForbiddenValidatorDirective&lt;/code&gt; 는 &lt;code&gt;forbiddenNameValidator&lt;/code&gt; 주위의 래퍼 역할을합니다 .</target>
        </trans-unit>
        <trans-unit id="46f920b8d9ffd47931549ae3e7c7ae76ebf2545b" translate="yes" xml:space="preserve">
          <source>In template-driven forms, each form element is linked to a directive that manages the form model internally.</source>
          <target state="translated">템플릿 기반 양식에서 각 양식 요소는 양식 모델을 내부적으로 관리하는 지시문에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="8aa8be07d8ab554c9b5c8a2c06f23414c9fbd80f" translate="yes" xml:space="preserve">
          <source>In template-driven forms, each form element is linked to a directive that manages the form model internally. The diagrams below use the same favorite color example to demonstrate how data flows when an input field's value is changed from the view and then from the model.</source>
          <target state="translated">템플릿 기반 양식에서 각 양식 요소는 양식 모델을 내부적으로 관리하는 지시문에 연결됩니다. 아래 다이어그램은 동일한 선호 색상 예제를 사용하여 입력 필드 값이보기에서 모델로 변경 될 때 데이터가 흐르는 방식을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0bd7dd8b5ca1c595b363717724f3cb456665a859" translate="yes" xml:space="preserve">
          <source>In template-driven forms, the form model is implicit, rather than explicit. The directive &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;NgModel&lt;/a&gt;&lt;/code&gt; creates and manages a &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; instance for a given form element.</source>
          <target state="translated">템플릿 기반 양식에서 양식 모델은 명시 적이 아니라 암시 적입니다. &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;NgModel&lt;/a&gt;&lt;/code&gt; 지시문 은 주어진 양식 요소에 대한 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 인스턴스를 만들고 관리합니다 .</target>
        </trans-unit>
        <trans-unit id="93f3796113966b61681d92d3ea2c4e2687db94c5" translate="yes" xml:space="preserve">
          <source>In template-driven forms, the source of truth is the template.</source>
          <target state="translated">템플릿 기반 양식에서 진실의 근원은 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="14ecbfdcfe9548e05316a56c993192cedabf9367" translate="yes" xml:space="preserve">
          <source>In template-driven forms, you don't have direct access to the &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; instance, so you can't pass the validator in like you can for reactive forms. Instead, you need to add a directive to the template.</source>
          <target state="translated">템플릿 기반 양식에서는 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 인스턴스에 직접 액세스 할 수 없으므로 반응 형 양식에서와 같이 유효성 검사기를 전달할 수 없습니다. 대신 템플릿에 지시문을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="48492c39622ecb3062934d6f8c81b07a54a70450" translate="yes" xml:space="preserve">
          <source>In terms of project structure, this is where the work begins:</source>
          <target state="translated">프로젝트 구조 측면에서 작업이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="6af431ed4c05cfe4dc08e184fe613d756b260244" translate="yes" xml:space="preserve">
          <source>In terms of syntax, template expressions are similar to JavaScript. Many JavaScript expressions are legal template expressions, with a few exceptions.</source>
          <target state="translated">구문 측면에서 템플릿 표현식은 JavaScript와 유사합니다. 많은 JavaScript 표현식은 몇 가지 예외를 제외하고 합법적 인 템플릿 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="09e5d39b1c7c8f014b6062dd7a1bc332ba6b3f66" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;router#optional-route-parameters&quot;&gt;route parameters&lt;/a&gt; example, you only dealt with parameters specific to the route, but what if you wanted optional parameters available to all routes? This is where query parameters come into play.</source>
          <target state="translated">&lt;a href=&quot;router#optional-route-parameters&quot;&gt;라우트 매개 변수&lt;/a&gt; 예제 에서는 라우트 고유의 매개 변수 만 처리했지만 모든 라우트에 선택적 매개 변수를 사용하려면 어떻게해야합니까? 쿼리 매개 변수가 사용되는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="5ac26089710632524cad22cceefd6020163e7ab7" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;router-tutorial-toh#optional-route-parameters&quot;&gt;route parameters&lt;/a&gt; section, you only dealt with parameters specific to the route. However, you can use query parameters to get optional parameters available to all routes.</source>
          <target state="translated">&lt;a href=&quot;router-tutorial-toh#optional-route-parameters&quot;&gt;경로 매개 변수&lt;/a&gt; 섹션 에서는 경로 와 관련된 매개 변수 만 다루었습니다. 그러나 쿼리 매개 변수를 사용하여 모든 경로에서 사용 가능한 선택적 매개 변수를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0820c06ab8c6d0ef8a8fe1b0b929c48f6630bb66" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;toh-pt0#app-wide-styles&quot;&gt;first tutorial&lt;/a&gt;, you set the basic styles for the entire application in &lt;code&gt;styles.css&lt;/code&gt;. That stylesheet didn't include styles for this list of heroes.</source>
          <target state="translated">에서 &lt;a href=&quot;toh-pt0#app-wide-styles&quot;&gt;첫 번째 튜토리얼&lt;/a&gt; , 당신의 전체 응용 프로그램에 대한 기본 스타일을 설정 &lt;code&gt;styles.css&lt;/code&gt; . 이 스타일 시트에는이 영웅 목록에 대한 스타일이 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ff53014dbd002b257b76fc01a67c8662544ebee" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;toh-pt6&quot;&gt;HTTP tutorial&lt;/a&gt;, you'll call &lt;code&gt;HttpClient.get&amp;lt;Hero[]&amp;gt;()&lt;/code&gt; which also returns an &lt;code&gt;Observable&amp;lt;Hero[]&amp;gt;&lt;/code&gt; that emits &lt;em&gt;a single value&lt;/em&gt;, an array of heroes from the body of the HTTP response.</source>
          <target state="translated">에서 &lt;a href=&quot;toh-pt6&quot;&gt;HTTP 튜토리얼&lt;/a&gt; , 당신은 전화 할게 &lt;code&gt;HttpClient.get&amp;lt;Hero[]&amp;gt;()&lt;/code&gt; 도 반환 &lt;code&gt;Observable&amp;lt;Hero[]&amp;gt;&lt;/code&gt; 이 방출한다 &lt;em&gt;단일 값&lt;/em&gt; , HTTP 응답의 몸에서 영웅의 배열.</target>
        </trans-unit>
        <trans-unit id="b1d8e3e61174d25c0c4cf9e3fb0410f3a8581bbc" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;workspace-config#project-tool-configuration-options&quot;&gt;workspace configuration file&lt;/a&gt;, an &quot;architect&quot; section provides configuration options for Architect builders.</source>
          <target state="translated">에서 &lt;a href=&quot;workspace-config#project-tool-configuration-options&quot;&gt;작업 공간 구성 파일&lt;/a&gt; ,에 &quot;건축가&quot;섹션 건축가 빌더에 대한 구성 옵션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a2b4efd306cdfa6d091bc13bfe331154e2fde145" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; decorator for a component.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; 의 @ 컴포넌트 () 데코레이터에서.</target>
        </trans-unit>
        <trans-unit id="11992fcba8b5395115e22e411c3650f43745f117" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;@&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;&lt;/code&gt; decorator, notice the selector name, &lt;code&gt;ad-host&lt;/code&gt;; that's what you use to apply the directive to the element. The next section shows you how.</source>
          <target state="translated">에서 &lt;code&gt;@&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;&lt;/code&gt; 장식, 선택기 이름,주의 &lt;code&gt;ad-host&lt;/code&gt; ; 이것이 지시어를 요소에 적용하는 데 사용하는 것입니다. 다음 섹션에서는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ff586c6893dff74ac24103ccba179ce78c8fd44d" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;@&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;&lt;/code&gt; decorator, notice the selector name, &lt;code&gt;adHost&lt;/code&gt;; that's what you use to apply the directive to the element. The next section shows you how.</source>
          <target state="translated">에서 &lt;code&gt;@&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;&lt;/code&gt; 장식, 선택기 이름, 알 &lt;code&gt;adHost&lt;/code&gt; 을 ; 이것이 요소에 지시문을 적용하는 데 사용하는 것입니다. 다음 섹션에서는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="22feceeafd715b7f8da2f83c22752555ac3c93c1" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; decorator for the service itself.</source>
          <target state="translated">에서 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; 서비스 자체에 대한 장식.</target>
        </trans-unit>
        <trans-unit id="4f13851c0ebd5a6ff72bf789e168b55892a0232a" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; decorator for an NgModule.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; 위한 @ NgModule () 데코레이터에서.</target>
        </trans-unit>
        <trans-unit id="2274075c2bf540e16098ef50a72f44b04cdc14fd" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;AppComponent&lt;/code&gt; template, &lt;code&gt;fontSizePx&lt;/code&gt; is two-way bound to the &lt;code&gt;SizerComponent&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;AppComponent&lt;/code&gt; 의 템플릿, &lt;code&gt;fontSizePx&lt;/code&gt; 는 받는 사람 바인딩 두 방법입니다 &lt;code&gt;SizerComponent&lt;/code&gt; 은 .</target>
        </trans-unit>
        <trans-unit id="6486f7643dd48c9967dcdd245700203deebedc2e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;AppComponent&lt;/code&gt;, &lt;code&gt;fontSizePx&lt;/code&gt; establishes the initial &lt;code&gt;SizerComponent.size&lt;/code&gt; value by setting the value to &lt;code&gt;16&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;AppComponent&lt;/code&gt; , &lt;code&gt;fontSizePx&lt;/code&gt; 는 초기 설정 &lt;code&gt;SizerComponent.size&lt;/code&gt; 의 값을 1로 설정함으로써 값 &lt;code&gt;16&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b03921e4e22315726b2588d9aecac260d6b1661" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;AppModule&lt;/code&gt;, import the &lt;code&gt;HttpClientInMemoryWebApiModule&lt;/code&gt; and the &lt;code&gt;InMemoryDataService&lt;/code&gt; class, which you will create in a moment.</source>
          <target state="translated">에서 &lt;code&gt;AppModule&lt;/code&gt; 가져 오기 &lt;code&gt;HttpClientInMemoryWebApiModule&lt;/code&gt; 과 &lt;code&gt;InMemoryDataService&lt;/code&gt; 당신이 한 순간에 만들어집니다 클래스를.</target>
        </trans-unit>
        <trans-unit id="962c3bfac2312dcb14ad043348facd5c496cbeb9" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;AppRoutingModule&lt;/code&gt;, you used the static &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; method to register the routes and application level service providers. In a feature module you use the static &lt;code&gt;forChild()&lt;/code&gt; method.</source>
          <target state="translated">에서 &lt;code&gt;AppRoutingModule&lt;/code&gt; , 당신은 정적 사용 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; 경로 및 응용 프로그램 수준의 서비스 제공을 등록하는 방법. 기능 모듈에서는 정적 &lt;code&gt;forChild()&lt;/code&gt; 메서드 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="677f4f33e13f4a8b9fa933701588716ce9142d4f" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;BUILD.bazel&lt;/code&gt; file, each rule must first be imported, using the &lt;code&gt;load&lt;/code&gt; statement. Then the rule is called with some attributes, and the result of calling the rule is that you've declared to Bazel how it can derive some outputs given some inputs and dependencies. Then later, when you run a &lt;code&gt;bazel&lt;/code&gt; command line, Bazel loads all the rules you've declared to determine an absolute ordering of what needs to be run. Note that only the rules needed to produce the requested output will actually be executed.</source>
          <target state="translated">에서 &lt;code&gt;BUILD.bazel&lt;/code&gt; 의 파일, 각 규칙 먼저 사용하여 가져와야합니다 &lt;code&gt;load&lt;/code&gt; 문을. 그런 다음 규칙이 일부 속성으로 호출되며 규칙을 호출 한 결과 입력 및 종속성이 지정된 일부 출력을 파생시킬 수있는 방법을 Bazel에 선언했습니다. 그런 다음 나중에 &lt;code&gt;bazel&lt;/code&gt; 명령 줄 을 실행할 때 Bazel은 실행해야 할 항목의 절대 순서를 결정하기 위해 선언 한 모든 규칙을로드합니다. 요청 된 출력을 생성하는 데 필요한 규칙 만 실제로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ff73a4f29b4dafba90546044a92eb6295b78516d" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;CartComponent&lt;/code&gt; class, define the &lt;code&gt;checkoutForm&lt;/code&gt; property to store the form model.</source>
          <target state="translated">에서 &lt;code&gt;CartComponent&lt;/code&gt; 의 클래스는 정의 &lt;code&gt;checkoutForm&lt;/code&gt; 형태로 모델을 저장하는 속성을.</target>
        </trans-unit>
        <trans-unit id="01997d24bac7bafa6f0678f1e46558c3083893f4" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;CartService&lt;/code&gt; class, define an &lt;code&gt;items&lt;/code&gt; property to store the array of the current products in the cart.</source>
          <target state="translated">에서 &lt;code&gt;CartService&lt;/code&gt; 의 클래스 정의 &lt;code&gt;items&lt;/code&gt; 카트에서 현재 제품들의 어레이를 저장하는 속성.</target>
        </trans-unit>
        <trans-unit id="af276f659fcdc7e39c68c1ac45abbf64eb51dc71" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;CartService&lt;/code&gt; class, define an &lt;code&gt;items&lt;/code&gt; property to store the list (array) of the current products in the cart.</source>
          <target state="translated">에서 &lt;code&gt;CartService&lt;/code&gt; 의 클래스 정의 &lt;code&gt;items&lt;/code&gt; 카트에서 현재 제품 목록 (배열)을 저장하는 속성.</target>
        </trans-unit>
        <trans-unit id="5867d4d5bfeee0f55a7464e033d66ab84c592db8" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;Hero Detail&lt;/code&gt; and &lt;code&gt;Crisis Detail&lt;/code&gt;, the app waited until the route was activated to fetch the respective hero or crisis.</source>
          <target state="translated">에서 &lt;code&gt;Hero Detail&lt;/code&gt; 및 &lt;code&gt;Crisis Detail&lt;/code&gt; 경로가 각각의 영웅 위기를 가져 활성화 될 때까지, 앱에서 기다렸다.</target>
        </trans-unit>
        <trans-unit id="18c1043ce48596bb1dfc52c7f2a46397b1f7b0f8" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;HeroDetail&lt;/code&gt; component class, add the following &lt;code&gt;save()&lt;/code&gt; method, which persists hero name changes using the hero service &lt;code&gt;updateHero()&lt;/code&gt; method and then navigates back to the previous view.</source>
          <target state="translated">에서 &lt;code&gt;HeroDetail&lt;/code&gt; 구성 요소 클래스, 다음 추가 &lt;code&gt;save()&lt;/code&gt; 영웅 서비스 이용 주인공 이름 변경 지속 방법, &lt;code&gt;updateHero()&lt;/code&gt; 메소드를 다음 다시 이전보기로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="2156da5df59cee5a225281c56c30a9cab56708ab" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;HeroService&lt;/code&gt;, import &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/common/http/httpheaders&quot;&gt;HttpHeaders&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">에서 &lt;code&gt;HeroService&lt;/code&gt; 가져 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 를 하고 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpheaders&quot;&gt;HttpHeaders&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3b722dd2b3d365c95d5bd3fe88be0090f5c815d5" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ItemListComponent&lt;/code&gt; the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt;, &lt;code&gt;items&lt;/code&gt;, has a type of &lt;code&gt;Item[]&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;ItemListComponent&lt;/code&gt; &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; , &lt;code&gt;items&lt;/code&gt; 의 타입을 갖는다 &lt;code&gt;Item[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ca02e5a12bc00052325d452bf3f5957538434cc" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;Phone&lt;/code&gt; service, you can explicitly annotate the &lt;code&gt;$resource&lt;/code&gt; service dependency as an &lt;code&gt;angular.resource.IResourceService&lt;/code&gt; - a type defined by the AngularJS typings.</source>
          <target state="translated">에서 &lt;code&gt;Phone&lt;/code&gt; 서비스를 명시 적으로 주석을 달 수 있습니다 &lt;code&gt;$resource&lt;/code&gt; 이 AS 서비스 종속성 &lt;code&gt;angular.resource.IResourceService&lt;/code&gt; AngularJS와의 typings에 의해 정의 된 유형을 -.</target>
        </trans-unit>
        <trans-unit id="a5e662caedf020f11cf3036766fb27dbfdab3cfd" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ProductAlertsComponent&lt;/code&gt; class definition, define a property named &lt;code&gt;product&lt;/code&gt; with an &lt;code&gt;@&lt;a href=&quot;api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; decorator. The &lt;code&gt;@&lt;a href=&quot;api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; decorator indicates that the property value passes in from the component's parent, the product list component.</source>
          <target state="translated">에서 &lt;code&gt;ProductAlertsComponent&lt;/code&gt; 의 클래스 정의, 속성 이름을 정의하는 &lt;code&gt;product&lt;/code&gt; 와 &lt;code&gt;@&lt;a href=&quot;api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 데코레이터. &lt;code&gt;@&lt;a href=&quot;api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 장식은 속성 값이 컴퍼넌트의 부모, 제품 목록 구성 요소에서의 전달을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="36898b78d65205ea3838be208da032aa36540e47" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ProfileEditor&lt;/code&gt; component, add the &lt;code&gt;Validators.required&lt;/code&gt; static method as the second item in the array for the &lt;code&gt;firstName&lt;/code&gt; control.</source>
          <target state="translated">에서 &lt;code&gt;ProfileEditor&lt;/code&gt; 의 컴포넌트 추가 &lt;code&gt;Validators.required&lt;/code&gt; 의 배열에서 두 번째 아이템으로 정적 메소드 &lt;code&gt;firstName&lt;/code&gt; 제어.</target>
        </trans-unit>
        <trans-unit id="92ee776b0a8c4703a5ed41d37503aaec513d8b04" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;angular.json&lt;/code&gt; configuration file, add the associated script files to the &quot;scripts&quot; array:</source>
          <target state="translated">에서 &lt;code&gt;angular.json&lt;/code&gt; 의 구성 파일에서 &quot;스크립트&quot;배열에 관련된 스크립트 파일을 추가 :</target>
        </trans-unit>
        <trans-unit id="1a9899ccac78789435c820f6606e4531795090bf" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;angular.json&lt;/code&gt; file, each project has an &quot;architect&quot; section that contains targets which configure builders. Some of these targets correspond to &lt;a href=&quot;glossary#cli&quot;&gt;CLI commands&lt;/a&gt;, such as &lt;code&gt;build&lt;/code&gt;, &lt;code&gt;serve&lt;/code&gt;, &lt;code&gt;test&lt;/code&gt;, and &lt;code&gt;lint&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;angular.json&lt;/code&gt; 의 파일, 각 프로젝트는 구성 빌더 목표를 포함하는 &quot;건축가&quot;섹션이 있습니다. 이러한 대상 중 일부는 &lt;code&gt;build&lt;/code&gt; , &lt;code&gt;serve&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; 및 &lt;code&gt;lint&lt;/code&gt; 와 같은 &lt;a href=&quot;glossary#cli&quot;&gt;CLI 명령에&lt;/a&gt; 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="94de57a6cb371bf77619355ba9427137a477c222" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;app.component.ts&lt;/code&gt;, add a &lt;code&gt;logger()&lt;/code&gt; method.</source>
          <target state="translated">에서 &lt;code&gt;app.component.ts&lt;/code&gt; 하는 추가 &lt;code&gt;logger()&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="62dde02e97dfc75cca7459efe150d4efeef31929" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;closed&lt;/code&gt; state, shown below, the button has a height of 100 pixels, an opacity of 0.5, and a background color of green.</source>
          <target state="translated">에서 &lt;code&gt;closed&lt;/code&gt; 아래와 상태, 버튼 100 픽셀 높이 0.5 불투명도 및 녹색의 배경 색상을 갖는다.</target>
        </trans-unit>
        <trans-unit id="f0e79bc039a97e654def058d6c01677193e8e1ac" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;flying-heroes.component.html (v1)&lt;/code&gt; template, the &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; repeater displays the hero names.</source>
          <target state="translated">에서 &lt;code&gt;flying-heroes.component.html (v1)&lt;/code&gt; 템플릿의 &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 중계기 표시 주인공 이름.</target>
        </trans-unit>
        <trans-unit id="94125f0a02fd08e44127e50aa5dff39b0e271acf" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;imports&lt;/code&gt; array, update the &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; section as follows.</source>
          <target state="translated">에서 &lt;code&gt;imports&lt;/code&gt; 어레이 업데이트 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; 다음 섹션.</target>
        </trans-unit>
        <trans-unit id="b6237dfcfe55567721272937836c6e2f073f47d0" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;index.html&lt;/code&gt; file, update the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; tag to include the new style sheet.</source>
          <target state="translated">에서 &lt;code&gt;index.html&lt;/code&gt; 을 파일 업데이트 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 새로운 스타일 시트를 포함하는 태그를.</target>
        </trans-unit>
        <trans-unit id="166e5ae5219a736e7e64042d01444638aec53e58" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ngOnInit()&lt;/code&gt; method, &lt;em&gt;subscribe&lt;/em&gt; to route params and fetch the product based on the &lt;code&gt;productId&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;ngOnInit()&lt;/code&gt; 에있어서, &lt;em&gt;가입&lt;/em&gt; 경로 PARAMS 및 상기에 기초하여 제품 페치 &lt;code&gt;productId&lt;/code&gt; 에이 .</target>
        </trans-unit>
        <trans-unit id="0435da30463a3a4f676343098e858808a78ebf7b" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ngOnInit()&lt;/code&gt; method, subscribe to route parameters and fetch the product based on the &lt;code&gt;productId&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;ngOnInit()&lt;/code&gt; 에있어서, 라우팅 파라미터에 가입에 기초하여 제품 페치 &lt;code&gt;productId&lt;/code&gt; 에이 .</target>
        </trans-unit>
        <trans-unit id="e3ca67bc8f59ab32b93f10aa761e0dc952786bee" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ngOnInit()&lt;/code&gt; method, use the &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; service to retrieve the parameters for the route, pull the hero &lt;code&gt;id&lt;/code&gt; from the parameters, and retrieve the hero to display.</source>
          <target state="translated">에서 &lt;code&gt;ngOnInit()&lt;/code&gt; 메소드를 사용 &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; 의 라우트에 대한 매개 변수를 검색 영웅 당겨 서비스 &lt;code&gt;id&lt;/code&gt; 파라미터로하고, 디스플레이 영웅 검색.</target>
        </trans-unit>
        <trans-unit id="8a184e86e3a0e42b994b7ab8f4d3105c6d66f4be" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ngOnInit()&lt;/code&gt;&lt;a href=&quot;../guide/lifecycle-hooks#oninit&quot;&gt;lifecycle hook&lt;/a&gt; call &lt;code&gt;getHero()&lt;/code&gt; and define it as follows.</source>
          <target state="translated">에서 &lt;code&gt;ngOnInit()&lt;/code&gt; &lt;a href=&quot;../guide/lifecycle-hooks#oninit&quot;&gt;주기 후크&lt;/a&gt; 통화 &lt;code&gt;getHero()&lt;/code&gt; 하고 다음과 같은 정의한다.</target>
        </trans-unit>
        <trans-unit id="1ec1c3010006a416ad9d0a3a466d135533ea48e4" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;package.json&lt;/code&gt; file, add a &lt;code&gt;builders&lt;/code&gt; key that tells the Architect tool where to find our builder definition file.</source>
          <target state="translated">에서 &lt;code&gt;package.json&lt;/code&gt; 의 파일, 추가 &lt;code&gt;builders&lt;/code&gt; 우리의 빌더 정의 파일을 찾을 건축가 도구를 알려줍니다 키를 누릅니다.</target>
        </trans-unit>
        <trans-unit id="b9948e144c79c9c4f0b9dd0251b423e396dd63cb" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;product-list&lt;/code&gt; folder, open the template file &lt;code&gt;product-list.component.html&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;code&gt;product-list&lt;/code&gt; 폴더, 템플릿 파일을 열고 &lt;code&gt;product-list.component.html&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97dfb1a67e0acfe8f117f2fb6b7fbabfa7951806" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;schematics/&lt;/code&gt; folder, create an &lt;code&gt;ng-add/&lt;/code&gt; folder for your first schematic.</source>
          <target state="translated">에서 &lt;code&gt;schematics/&lt;/code&gt; 폴더, 만들 &lt;code&gt;ng-add/&lt;/code&gt; 당신의 첫 번째 회로도에 대한 폴더를.</target>
        </trans-unit>
        <trans-unit id="071be1c94586b5d59a7d3e0b251a1712459e1078" translate="yes" xml:space="preserve">
          <source>In the &lt;span name=&quot;ngmodules&quot;&gt;live example&lt;/span&gt; the root &lt;code&gt;AppModule&lt;/code&gt; imports the &lt;code&gt;GreetingModule&lt;/code&gt; and adds the &lt;code&gt;providers&lt;/code&gt; to the &lt;code&gt;AppModule&lt;/code&gt; providers. Specifically, Angular accumulates all imported providers before appending the items listed in &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule#providers&quot;&gt;NgModule.providers&lt;/a&gt;&lt;/code&gt;. This sequence ensures that whatever you add explicitly to the &lt;code&gt;AppModule&lt;/code&gt; providers takes precedence over the providers of imported modules.</source>
          <target state="translated">에서 &lt;span name=&quot;ngmodules&quot;&gt;라이브 예를 들어&lt;/span&gt; 루트 &lt;code&gt;AppModule&lt;/code&gt; 를 가져옵니다 &lt;code&gt;GreetingModule&lt;/code&gt; 와는 추가 &lt;code&gt;providers&lt;/code&gt; 받는 &lt;code&gt;AppModule&lt;/code&gt; 를 제공합니다. 특히 Angular는 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule#providers&quot;&gt;NgModule.providers&lt;/a&gt;&lt;/code&gt; 나열된 항목을 추가하기 전에 모든 가져온 공급자를 누적합니다 . 이 순서는 &lt;code&gt;AppModule&lt;/code&gt; 제공자 에 명시 적으로 추가하는 것이 가져온 모듈의 제공자보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="aabd7c813ffdc03e68f8ddf0d0e075e18a3d7a6d" translate="yes" xml:space="preserve">
          <source>In the Angular CLI, a standalone application or &lt;a href=&quot;glossary#library&quot;&gt;library&lt;/a&gt; that can be created or modified by a CLI command.</source>
          <target state="translated">Angular CLI에서 CLI 명령으로 작성하거나 수정할 수 있는 독립형 애플리케이션 또는 &lt;a href=&quot;glossary#library&quot;&gt;라이브러리&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b7b501033bcab7677bbf386ea844c636f41ee7a1" translate="yes" xml:space="preserve">
          <source>In the CLI configuration file, &lt;code&gt;angular.json&lt;/code&gt;, add the &lt;code&gt;proxyConfig&lt;/code&gt; option to the &lt;code&gt;serve&lt;/code&gt; target:</source>
          <target state="translated">CLI를 구성 파일에서 &lt;code&gt;angular.json&lt;/code&gt; , 추가 &lt;code&gt;proxyConfig&lt;/code&gt; (가)에 옵션을 &lt;code&gt;serve&lt;/code&gt; 대상 :</target>
        </trans-unit>
        <trans-unit id="61763a5a70701c3c12fbb07b3b6f0e84eaf7bbab" translate="yes" xml:space="preserve">
          <source>In the CLI configuration file, &lt;code&gt;angular.json&lt;/code&gt;, point to the JavaScript proxy configuration file:</source>
          <target state="translated">CLI 구성 파일 &lt;code&gt;angular.json&lt;/code&gt; 에서 JavaScript 프록시 구성 파일을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="122be2b5ab964b68505d923b034cfdbee86e0ef4" translate="yes" xml:space="preserve">
          <source>In the DOM of a hybrid ngUpgrade application are components and directives from both AngularJS and Angular. These components communicate with each other by using the input and output bindings of their respective frameworks, which ngUpgrade bridges together. They may also communicate through shared injected dependencies, as described above.</source>
          <target state="translated">하이브리드 ngUpgrade 애플리케이션의 DOM에는 AngularJS와 Angular의 구성 요소와 지시문이 있습니다. 이러한 구성 요소는 각 프레임 워크의 입력 및 출력 바인딩을 사용하여 서로 통신합니다. 또한 위에서 설명한대로 공유 된 주입 된 종속성을 통해 통신 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="da4aac216c4150aa0c4b76a0cbffacab0ba55a37" translate="yes" xml:space="preserve">
          <source>In the DOM of a running Angular application with emulated view encapsulation enabled, each DOM element has some extra attributes attached to it:</source>
          <target state="translated">에뮬레이트 된 뷰 캡슐화가 활성화 된 실행중인 Angular 응용 프로그램의 DOM에서 각 DOM 요소에는 몇 가지 추가 속성이 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="967824d97e856f8a5701294372f66633e02cbd55" translate="yes" xml:space="preserve">
          <source>In the HTML template file, use the trigger name to attach the defined animations to the HTML element to be animated.</source>
          <target state="translated">HTML 템플리트 파일에서 트리거 이름을 사용하여 정의 된 애니메이션을 애니메이션 할 HTML 요소에 첨부하십시오.</target>
        </trans-unit>
        <trans-unit id="083a121e6216962299890132cebbe02f632fa294" translate="yes" xml:space="preserve">
          <source>In the HTML template, the animation event is passed back via &lt;code&gt;$event&lt;/code&gt;, as &lt;code&gt;@trigger.start&lt;/code&gt; and &lt;code&gt;@trigger.done&lt;/code&gt;, where &lt;code&gt;&lt;a href=&quot;../api/animations/trigger&quot;&gt;trigger&lt;/a&gt;&lt;/code&gt; is the name of the trigger being used. In our example, the trigger &lt;code&gt;openClose&lt;/code&gt; appears as follows.</source>
          <target state="translated">HTML 템플릿에서 애니메이션 이벤트는 &lt;code&gt;$event&lt;/code&gt; &lt;code&gt;@trigger.start&lt;/code&gt; 통해 @ trigger.start 및 &lt;code&gt;@trigger.done&lt;/code&gt; 으로 다시 전달됩니다 . 여기서 &lt;code&gt;&lt;a href=&quot;../api/animations/trigger&quot;&gt;trigger&lt;/a&gt;&lt;/code&gt; 는 사용중인 트리거의 이름입니다. 이 예에서는 &lt;code&gt;openClose&lt;/code&gt; 트리거 가 다음과 같이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="9f68507ab6ee93f0f57a92342cc4e0c3de28bf7e" translate="yes" xml:space="preserve">
          <source>In the HTML template, the animation event is passed back via &lt;code&gt;$event&lt;/code&gt;, as &lt;code&gt;@trigger.start&lt;/code&gt; and &lt;code&gt;@trigger.done&lt;/code&gt;, where &lt;code&gt;&lt;a href=&quot;../api/animations/trigger&quot;&gt;trigger&lt;/a&gt;&lt;/code&gt; is the name of the trigger being used. In this example, the trigger &lt;code&gt;openClose&lt;/code&gt; appears as follows.</source>
          <target state="translated">HTML 템플릿에서 애니메이션 이벤트는 &lt;code&gt;$event&lt;/code&gt; 를 통해 &lt;code&gt;@trigger.start&lt;/code&gt; 및 &lt;code&gt;@trigger.done&lt;/code&gt; 으로 다시 전달됩니다 . 여기서 &lt;code&gt;&lt;a href=&quot;../api/animations/trigger&quot;&gt;trigger&lt;/a&gt;&lt;/code&gt; 는 사용중인 트리거의 이름입니다. 이 예에서 &lt;code&gt;openClose&lt;/code&gt; 트리거 는 다음과 같이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="dfcba8b351ad67cbd3018ae060d6b3b0cce679cf" translate="yes" xml:space="preserve">
          <source>In the Karma configuration file, &lt;code&gt;karma.conf.js&lt;/code&gt;, add a custom launcher called ChromeHeadlessCI below browsers:</source>
          <target state="translated">Karma 구성 파일 &lt;code&gt;karma.conf.js&lt;/code&gt; 에서 브라우저 아래에 ChromeHeadlessCI라는 사용자 정의 실행기를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="0d8933c6633530a939e7e7a904014c408f4331c7" translate="yes" xml:space="preserve">
          <source>In the Phone detail controller, you'll have two members: One for the phone that the user is looking at and another for the URL of the currently displayed image:</source>
          <target state="translated">휴대 전화 세부 정보 컨트롤러에는 두 명의 구성원이 있습니다. 하나는 사용자가보고있는 전화와 다른 하나는 현재 표시된 이미지의 URL입니다.</target>
        </trans-unit>
        <trans-unit id="0d1a2ab17dd8ff5eedf9e71bb387641a06044ce9" translate="yes" xml:space="preserve">
          <source>In the TypeScript configuration file, the &quot;target&quot; option in the &lt;code&gt;compilerOptions&lt;/code&gt; section determines the ECMAScript target version that the code is compiled to. Modern browsers support ES2015 natively, while ES5 is more commonly used to support legacy browsers.</source>
          <target state="translated">TypeScript 구성 파일에서 &lt;code&gt;compilerOptions&lt;/code&gt; 섹션 의 &quot;target&quot;옵션 은 코드가 컴파일되는 ECMAScript 대상 버전을 결정합니다. 최신 브라우저는 기본적으로 ES2015를 지원하는 반면 ES5는 레거시 브라우저를 지원하는 데 더 일반적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e4df01dda361adbb05b79a30335d5fac348e1b3c" translate="yes" xml:space="preserve">
          <source>In the above code snippet, &lt;code&gt;transAnimation&lt;/code&gt; is made reusable by declaring it as an export variable.</source>
          <target state="translated">위의 코드 스 니펫에서 &lt;code&gt;transAnimation&lt;/code&gt; 은 내보내기 변수로 선언하여 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="999956f8131dbd54f089f149eff9fb3d864570b4" translate="yes" xml:space="preserve">
          <source>In the above code, we applied the &lt;code&gt;void&lt;/code&gt; state when the HTML element isn't attached to a view.</source>
          <target state="translated">위 코드 에서 HTML 요소가 뷰에 연결되지 않은 경우 &lt;code&gt;void&lt;/code&gt; 상태를 적용했습니다 .</target>
        </trans-unit>
        <trans-unit id="6bcbc62f2692a7cad7cfffdc2e7cf4b7e559d979" translate="yes" xml:space="preserve">
          <source>In the above code, you applied the &lt;code&gt;void&lt;/code&gt; state when the HTML element isn't attached to a view.</source>
          <target state="translated">위 코드 에서 HTML 요소가 뷰에 연결되지 않은 경우 &lt;code&gt;void&lt;/code&gt; 상태 를 적용했습니다 .</target>
        </trans-unit>
        <trans-unit id="cea6f478656e7fe4e653914666132b5379bca812" translate="yes" xml:space="preserve">
          <source>In the above example, a breakpoint on the pipe's request for data shows the following:</source>
          <target state="translated">위의 예에서 파이프의 데이터 요청 중단 점은 다음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4e34e2cb53ddbb0085cbc3e5a61b4772c7d5c3c2" translate="yes" xml:space="preserve">
          <source>In the above example:</source>
          <target state="translated">위의 예에서 :</target>
        </trans-unit>
        <trans-unit id="8a1eba3971dbfd135fb71e9d8c51d2907a609acb" translate="yes" xml:space="preserve">
          <source>In the above scenario, the service worker is not able to serve an asset that would normally be cached. That particular app version is broken and there is no way to fix the state of the client without reloading the page. In such cases, the service worker notifies the client by sending an &lt;code&gt;&lt;a href=&quot;../api/service-worker/unrecoverablestateevent&quot;&gt;UnrecoverableStateEvent&lt;/a&gt;&lt;/code&gt; event. You can subscribe to &lt;code&gt;&lt;a href=&quot;../api/service-worker/swupdate&quot;&gt;SwUpdate&lt;/a&gt;#unrecoverable&lt;/code&gt; to be notified and handle these errors.</source>
          <target state="translated">위의 시나리오에서 서비스 워커는 일반적으로 캐시되는 자산을 제공 할 수 없습니다. 특정 앱 버전이 손상되었으며 페이지를 다시로드하지 않고는 클라이언트의 상태를 수정할 방법이 없습니다. 이러한 경우 서비스 워커는 &lt;code&gt;&lt;a href=&quot;../api/service-worker/unrecoverablestateevent&quot;&gt;UnrecoverableStateEvent&lt;/a&gt;&lt;/code&gt; 이벤트 를 전송하여 클라이언트에 알립니다 . &lt;code&gt;&lt;a href=&quot;../api/service-worker/swupdate&quot;&gt;SwUpdate&lt;/a&gt;#unrecoverable&lt;/code&gt; 에 가입하여 알림을 받고 이러한 오류를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="577e109d05bd16fdfef27736b2c5e520043e9b7f" translate="yes" xml:space="preserve">
          <source>In the ad banner, all components implement a common &lt;code&gt;AdComponent&lt;/code&gt; interface to standardize the API for passing data to the components.</source>
          <target state="translated">광고 배너에서 모든 구성 요소는 공통 &lt;code&gt;AdComponent&lt;/code&gt; 인터페이스를 구현 하여 구성 요소에 데이터를 전달하기위한 API를 표준화합니다.</target>
        </trans-unit>
        <trans-unit id="19609a3f68be8a8d8459bb2350900bd1a47c1bf5" translate="yes" xml:space="preserve">
          <source>In the basic CLI-generated app, modules are eagerly loaded which means that they are all loaded when the app launches. Angular uses an injector system to make things available between modules. In an eagerly loaded app, the root application injector makes all of the providers in all of the modules available throughout the app.</source>
          <target state="translated">기본 CLI 생성 앱에서 모듈이 열성적으로로드되므로 앱이 실행될 때 모듈이 모두로드됩니다. Angular는 인젝터 시스템을 사용하여 모듈간에 사물을 제공합니다. 열심히로드 된 앱에서 루트 응용 프로그램 인젝터는 모든 모듈의 모든 공급자를 앱 전체에서 사용할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="d217fba68efca130ef3c06341acbd707ba067782" translate="yes" xml:space="preserve">
          <source>In the builder source directory, we have created a new test file &lt;code&gt;index.spec.ts&lt;/code&gt;. The code creates new instances of &lt;code&gt;JsonSchemaRegistry&lt;/code&gt; (for schema validation), &lt;code&gt;TestingArchitectHost&lt;/code&gt; (an in-memory implementation of &lt;code&gt;ArchitectHost&lt;/code&gt;), and &lt;code&gt;Architect&lt;/code&gt;.</source>
          <target state="translated">빌더 소스 디렉토리에서 새 테스트 파일 &lt;code&gt;index.spec.ts&lt;/code&gt; 를 작성했습니다 . 이 코드는 &lt;code&gt;JsonSchemaRegistry&lt;/code&gt; (스키마 유효성 검사 용), &lt;code&gt;TestingArchitectHost&lt;/code&gt; (메모리 내 구현 &lt;code&gt;ArchitectHost&lt;/code&gt; ) 및 &lt;code&gt;Architect&lt;/code&gt; 의 새 인스턴스를 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="d959bf9da8f9b9700248ea3b26f61fd618b0cb98" translate="yes" xml:space="preserve">
          <source>In the builder source directory, we have created a new test file &lt;code&gt;my-builder.spec.ts&lt;/code&gt;. The code creates new instances of &lt;code&gt;JsonSchemaRegistry&lt;/code&gt; (for schema validation), &lt;code&gt;TestingArchitectHost&lt;/code&gt; (an in-memory implementation of &lt;code&gt;ArchitectHost&lt;/code&gt;), and &lt;code&gt;Architect&lt;/code&gt;.</source>
          <target state="translated">빌더 소스 디렉토리에서 새 테스트 파일 &lt;code&gt;my-builder.spec.ts&lt;/code&gt; 를 생성했습니다 . 이 코드는 &lt;code&gt;JsonSchemaRegistry&lt;/code&gt; (스키마 유효성 검사 용), &lt;code&gt;TestingArchitectHost&lt;/code&gt; ( &lt;code&gt;ArchitectHost&lt;/code&gt; 의 메모리 내 구현 ) 및 &lt;code&gt;Architect&lt;/code&gt; 의 새 인스턴스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="b4f98a695082e7fd1036ab253a946e35cc9beb2c" translate="yes" xml:space="preserve">
          <source>In the case of hybrid applications, the &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; bridges the AngularJS and Angular approaches. Here's what happens:</source>
          <target state="translated">하이브리드 애플리케이션의 경우 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 은 AngularJS 및 Angular 방식을 연결합니다. 다음과 같은 일이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="91461870129c519bada0129bab899cc6a8400941" translate="yes" xml:space="preserve">
          <source>In the child</source>
          <target state="translated">아이에서</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
