<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="angular">
    <body>
      <group id="angular">
        <trans-unit id="21ecfa2595cc1f5b325b2c21cfbff7962334a60c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exports&lt;/code&gt; options make the declared directives and pipes available for import by other NgModules.</source>
          <target state="translated">&lt;code&gt;exports&lt;/code&gt; 옵션은 다른 NgModules에 의해 수입에 대한 신고 지침 및 파이프를 사용할 수 있도록.</target>
        </trans-unit>
        <trans-unit id="4c7e18bb45ba4b5fd41913cd19bf2cb5879bd3d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract-i18n&lt;/code&gt; command can read and write files in three translation formats:</source>
          <target state="translated">&lt;code&gt;extract-i18n&lt;/code&gt; 명령을 읽고 세 가지 번역 형식의 파일을 작성할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ba5be89352c9b3d4545a07684018a85c193a9e6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract-i18n&lt;/code&gt; command creates a source language file named &lt;code&gt;messages.xlf&lt;/code&gt; in your project's root directory using the &lt;a href=&quot;https://en.wikipedia.org/wiki/XLIFF&quot;&gt;XML Localization Interchange File Format (XLIFF, version 1.2)&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;extract-i18n&lt;/code&gt; 명령이라는 이름의 소스 언어 파일 생성 &lt;code&gt;messages.xlf&lt;/code&gt; 을 사용하여 프로젝트의 루트 디렉토리에 &lt;a href=&quot;https://en.wikipedia.org/wiki/XLIFF&quot;&gt;XML 현지화 교환 파일 형식 (XLIFF, 버전 1.2)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="924a0bda0e58b6d45eeda97233361e4d92152b9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;factory&lt;/code&gt; function returns the &lt;code&gt;localStorage&lt;/code&gt; property that is attached to the browser window object. The &lt;code&gt;&lt;a href=&quot;../api/core/inject&quot;&gt;Inject&lt;/a&gt;&lt;/code&gt; decorator is a constructor parameter used to specify a custom provider of a dependency. This custom provider can now be overridden during testing with a mock API of &lt;code&gt;localStorage&lt;/code&gt; instead of interacting with real browser APIs.</source>
          <target state="translated">&lt;code&gt;factory&lt;/code&gt; 함수는 반환 &lt;code&gt;localStorage&lt;/code&gt; 브라우저 창 개체에 연결된 속성을. &lt;code&gt;&lt;a href=&quot;../api/core/inject&quot;&gt;Inject&lt;/a&gt;&lt;/code&gt; 장식 종속성의 사용자 지정 공급자를 지정하는 데 사용되는 생성자 매개 변수입니다. 이 사용자 지정 공급자는 이제 실제 브라우저 API와 상호 작용하는 대신 &lt;code&gt;localStorage&lt;/code&gt; 의 모의 API로 테스트하는 동안 재정의 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9be60669d284e5d6102bee94f0946b335ed3c86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;factory&lt;/code&gt; function returns the &lt;code&gt;localStorage&lt;/code&gt; property that is attached to the browser window object. The &lt;code&gt;&lt;a href=&quot;../api/core/inject&quot;&gt;Inject&lt;/a&gt;&lt;/code&gt; decorator is a constructor parameter used to specify a custom provider of a dependency. This custom provider can now be overridden during testing with a mock API of &lt;code&gt;localStorage&lt;/code&gt; instead of interactive with real browser APIs.</source>
          <target state="translated">&lt;code&gt;factory&lt;/code&gt; 함수는 반환 &lt;code&gt;localStorage&lt;/code&gt; 브라우저 창 개체에 연결된 속성을. &lt;code&gt;&lt;a href=&quot;../api/core/inject&quot;&gt;Inject&lt;/a&gt;&lt;/code&gt; 장식 종속성의 사용자 지정 공급자를 지정하는 데 사용되는 생성자 매개 변수입니다. 이 사용자 정의 제공자는 이제 실제 브라우저 API와 대화식이 아닌 &lt;code&gt;localStorage&lt;/code&gt; 의 모의 API로 테스트하는 동안 대체 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b00430e5bbaeadf8241fc073201ea7ecc5ca41b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;factory&lt;/code&gt; property points to the generated entry function. In this example, you invoke the &lt;code&gt;hello-world&lt;/code&gt; schematic by calling the &lt;code&gt;helloWorld()&lt;/code&gt; factory function.</source>
          <target state="translated">&lt;code&gt;factory&lt;/code&gt; 속성은 생성 된 입력 기능을 가리 킵니다. 이 예에서는 &lt;code&gt;helloWorld()&lt;/code&gt; 팩토리 함수 를 호출하여 &lt;code&gt;hello-world&lt;/code&gt; 회로도를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="fe36d75cc550ebe730a33a6d287578930b3b9f33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;favoriteColor&lt;/code&gt; value is updated in the component.</source>
          <target state="translated">&lt;code&gt;favoriteColor&lt;/code&gt; 의 값은 요소에 갱신된다.</target>
        </trans-unit>
        <trans-unit id="127d59be8640df24f5583305129ef01af0da1a63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fetch&lt;/code&gt; and &lt;code&gt;fetch-json&lt;/code&gt; pipes display the heroes as shown in Figure 5.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 하고 &lt;code&gt;fetch-json&lt;/code&gt; 도 5에 도시 된 바와 같이 파이프 영웅 표시.</target>
        </trans-unit>
        <trans-unit id="7108ed3bcfda58185316e0339599c6526b1f2408" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fetch&lt;/code&gt; pipe (&lt;code&gt;fetch-json.pipe.ts&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 관 ( &lt;code&gt;fetch-json.pipe.ts&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4a29f62b66251be3080836e417909a06fdd5cb52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fixture.whenStable()&lt;/code&gt; returns a promise that resolves when the JavaScript engine's task queue becomes empty. In this example, the task queue becomes empty when the observable emits the first quote.</source>
          <target state="translated">&lt;code&gt;fixture.whenStable()&lt;/code&gt; 결의는 자바 스크립트 엔진의 작업 큐가 비어하게하는 약속을 반환합니다. 이 예에서, 관찰 가능 항목이 첫 번째 인용문을 생성하면 작업 대기열이 비게됩니다.</target>
        </trans-unit>
        <trans-unit id="881baa9041fdc7ad68bbc1a717633ee715f6da9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forChild()&lt;/code&gt; method creates an &lt;code&gt;&lt;a href=&quot;../core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; that contains all the directives and the given routes, but does not include the &lt;code&gt;&lt;a href=&quot;router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; service.</source>
          <target state="translated">&lt;code&gt;forChild()&lt;/code&gt; 메소드는 생성 &lt;code&gt;&lt;a href=&quot;../core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 지시어, 지정된 경로를 모두 포함하지만, 포함하지 않는 &lt;code&gt;&lt;a href=&quot;router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 서비스를.</target>
        </trans-unit>
        <trans-unit id="b6eefc0aaa0380bddfa4cf81ec05c3559e3ac941" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forRoot()&lt;/code&gt; configuration method takes an &lt;code&gt;InMemoryDataService&lt;/code&gt; class that primes the in-memory database.</source>
          <target state="translated">&lt;code&gt;forRoot()&lt;/code&gt; 의 구성 방법은 소요 &lt;code&gt;InMemoryDataService&lt;/code&gt; 의 인 - 메모리 데이터베이스를 소수가 클래스.</target>
        </trans-unit>
        <trans-unit id="127fea156d178f36549610f61f489eddc6685d9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forRoot()&lt;/code&gt; method creates an &lt;code&gt;&lt;a href=&quot;../core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; that contains all the directives, the given routes, and the &lt;code&gt;&lt;a href=&quot;router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; service itself.</source>
          <target state="translated">&lt;code&gt;forRoot()&lt;/code&gt; 메소드는 생성 &lt;code&gt;&lt;a href=&quot;../core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 모든 지침, 주어진 경로와 포함 &lt;code&gt;&lt;a href=&quot;router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 서비스 자체를.</target>
        </trans-unit>
        <trans-unit id="55ac1b05d812482b7507362d51a4ec1a2580d80d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forRoot()&lt;/code&gt; method takes care of the &lt;em&gt;global&lt;/em&gt; injector configuration for the Router. The &lt;code&gt;forChild()&lt;/code&gt; method has no injector configuration. It uses directives such as &lt;code&gt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;RouterOutlet&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt;. For more information, see the &lt;a href=&quot;singleton-services#forRoot&quot;&gt;&lt;code&gt;forRoot()&lt;/code&gt; pattern&lt;/a&gt; section of the &lt;a href=&quot;singleton-services&quot;&gt;Singleton Services&lt;/a&gt; guide.</source>
          <target state="translated">&lt;code&gt;forRoot()&lt;/code&gt; 메소드는을 담당 &lt;em&gt;글로벌&lt;/em&gt; 라우터에 대한 인젝터 구성. &lt;code&gt;forChild()&lt;/code&gt; 메소드는 인젝터 구성이 없다. &lt;code&gt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;RouterOutlet&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; 와 같은 지시문을 사용합니다 . 자세한 내용 은 &lt;a href=&quot;singleton-services&quot;&gt;Singleton Services&lt;/a&gt; 가이드 의 &lt;a href=&quot;singleton-services#forRoot&quot;&gt; &lt;code&gt;forRoot()&lt;/code&gt; 패턴&lt;/a&gt; 섹션을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="e68a2010e1bbb32a0b1a5eab0b289f3ed8d55958" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forRoot()&lt;/code&gt; pattern</source>
          <target state="translated">&lt;code&gt;forRoot()&lt;/code&gt; 패턴</target>
        </trans-unit>
        <trans-unit id="04c1a805b485019f2266bc642ca4eb018b5b6c5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forRoot()&lt;/code&gt; static method is a convention that makes it easy for developers to configure services and providers that are intended to be singletons. A good example of &lt;code&gt;forRoot()&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;forRoot()&lt;/code&gt; 정적 방법은 싱글이 될하기위한 것입니다 구성 서비스 및 제공에 대한 개발자를위한 쉬운을 만드는 규칙이다. &lt;code&gt;forRoot()&lt;/code&gt; 의 좋은 예 는 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="dba3238be00f6a9329dd14c8cde743d8af35af2b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;forbiddenNameValidator&lt;/code&gt; factory returns the configured validator function. That function takes an Angular control object and returns &lt;em&gt;either&lt;/em&gt; null if the control value is valid &lt;em&gt;or&lt;/em&gt; a validation error object. The validation error object typically has a property whose name is the validation key, &lt;code&gt;'forbiddenName'&lt;/code&gt;, and whose value is an arbitrary dictionary of values that you could insert into an error message, &lt;code&gt;{name}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;forbiddenNameValidator&lt;/code&gt; 의 공장 구성된 검증 기능을 반환합니다. 이 함수는 각도 제어 오브젝트를 리턴 &lt;em&gt;하거나&lt;/em&gt; 제어 값이 유효한지 여부를 널 &lt;em&gt;또는&lt;/em&gt; 검증 에러 개체. 유효성 검증 오류 오브젝트에는 일반적으로 이름이 유효성 검증 키 &lt;code&gt;'forbiddenName'&lt;/code&gt; 이고 값이 오류 메시지 &lt;code&gt;{name}&lt;/code&gt; 에 삽입 할 수있는 임의의 값 사전 인 특성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6c47dfe0b4a9d194d93da6a53e2c28c4b4a6638" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;freshness&lt;/code&gt; strategy usually results in more requests sent to the server, which can increase response latency. It is recommended that you use the default performance strategy whenever possible.</source>
          <target state="translated">&lt;code&gt;freshness&lt;/code&gt; 전략은 일반적으로 응답 대기 시간을 증가시킬 수있는 서버로 보내 더 많은 요청을 초래한다. 가능하면 기본 성능 전략을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="85f621324bd7bc992e815895a148f44c50582aa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get()&lt;/code&gt; method takes two arguments; the endpoint URL from which to fetch, and an &lt;em&gt;options&lt;/em&gt; object that you can use to configure the request.</source>
          <target state="translated">&lt;code&gt;get()&lt;/code&gt; 메서드는 두 개의 인수를; 가져올 끝점 URL 및 요청을 구성하는 데 사용할 수 있는 &lt;em&gt;옵션&lt;/em&gt; 개체입니다.</target>
        </trans-unit>
        <trans-unit id="fd14df01685172b159816db8b4cc83eb319f6817" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getEventMessage&lt;/code&gt; method interprets each type of &lt;code&gt;&lt;a href=&quot;../api/common/http/httpevent&quot;&gt;HttpEvent&lt;/a&gt;&lt;/code&gt; in the event stream.</source>
          <target state="translated">&lt;code&gt;getEventMessage&lt;/code&gt; 의 방법은 각 유형의 해석 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpevent&quot;&gt;HttpEvent&lt;/a&gt;&lt;/code&gt; 이벤트 스트림을.</target>
        </trans-unit>
        <trans-unit id="0720e6119153b338ac8f3687fa78b44bc47f650b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getItems()&lt;/code&gt; method collects the items users add to the cart and returns each item with its associated quantity.</source>
          <target state="translated">&lt;code&gt;getItems()&lt;/code&gt; 메소드는 사용자가 장바구니에 추가 항목을 수집하고 관련 수량 각 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a5b92c25379c77bec5a559ce651e63e02dcdcc9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goToItems()&lt;/code&gt; method interprets the destination URI as relative to the activated route and navigates to the &lt;code&gt;items&lt;/code&gt; route.</source>
          <target state="translated">&lt;code&gt;goToItems()&lt;/code&gt; 에있어서의 해석의 활성화 경로를 탐색하고 상대와 대상 URI &lt;code&gt;items&lt;/code&gt; 노선.</target>
        </trans-unit>
        <trans-unit id="1b27c3ddf198371aface3067fae60b5f34b13c19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hero-birthday2.component.ts&lt;/code&gt; component binds the pipe's format parameter to the component's &lt;code&gt;format&lt;/code&gt; property in the &lt;code&gt;template&lt;/code&gt; section, and adds a button for a click event bound to the component's &lt;code&gt;toggleFormat()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;hero-birthday2.component.ts&lt;/code&gt; 구성 요소의 구성 요소에 결합하는 관의 형태 파라미터 &lt;code&gt;format&lt;/code&gt; 재산 &lt;code&gt;template&lt;/code&gt; 부 및 구성 요소의 결합 클릭 이벤트위한 버튼 추가 &lt;code&gt;toggleFormat()&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="5467834f536bb386d92822c337a7b0060f16f33e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hero-birthday2.component.ts&lt;/code&gt; component's &lt;code&gt;toggleFormat()&lt;/code&gt; method toggles the component's &lt;code&gt;format&lt;/code&gt; property between a short form (&lt;code&gt;'shortDate'&lt;/code&gt;) and a longer form (&lt;code&gt;'fullDate'&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;hero-birthday2.component.ts&lt;/code&gt; 구성 요소의 &lt;code&gt;toggleFormat()&lt;/code&gt; 메서드는 구성 요소의 전환 &lt;code&gt;format&lt;/code&gt; 짧은 형식 (사이 재산 &lt;code&gt;'shortDate'&lt;/code&gt; )과 더 긴 형태 ( &lt;code&gt;'fullDate'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3a70ca7b9c1c4fe66b0b5e312918acfa718fb720" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hero&lt;/code&gt; property &lt;a href=&quot;../guide/inputs-outputs&quot;&gt;must be an &lt;em&gt;Input&lt;/em&gt; property&lt;/a&gt;, annotated with the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; decorator, because the &lt;em&gt;external&lt;/em&gt;&lt;code&gt;HeroesComponent&lt;/code&gt;&lt;a href=&quot;toh-pt3#heroes-component-template&quot;&gt;will bind to it&lt;/a&gt; like this.</source>
          <target state="translated">&lt;code&gt;hero&lt;/code&gt; 속성은 &lt;a href=&quot;../guide/inputs-outputs&quot;&gt;해야 &lt;em&gt;입력&lt;/em&gt; 특성&lt;/a&gt; 주석, &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 때문에, 장식을 &lt;em&gt;외부 &lt;/em&gt; &lt;code&gt;HeroesComponent&lt;/code&gt; 이&lt;a href=&quot;toh-pt3#heroes-component-template&quot;&gt;그것에 바인딩&lt;/a&gt; 과 같이.</target>
        </trans-unit>
        <trans-unit id="39d503fba2d2e3b6c4480f750303d3e8aed59ed1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hero&lt;/code&gt; property &lt;a href=&quot;../guide/template-syntax#inputs-outputs&quot;&gt;must be an &lt;em&gt;Input&lt;/em&gt; property&lt;/a&gt;, annotated with the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; decorator, because the &lt;em&gt;external&lt;/em&gt;&lt;code&gt;HeroesComponent&lt;/code&gt;&lt;a href=&quot;toh-pt3#heroes-component-template&quot;&gt;will bind to it&lt;/a&gt; like this.</source>
          <target state="translated">&lt;code&gt;hero&lt;/code&gt; 속성은 &lt;a href=&quot;../guide/template-syntax#inputs-outputs&quot;&gt;해야 &lt;em&gt;입력&lt;/em&gt; 특성&lt;/a&gt; 주석, &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 때문에, 장식을 &lt;em&gt;외부 &lt;/em&gt; &lt;code&gt;HeroesComponent&lt;/code&gt; 이&lt;a href=&quot;toh-pt3#heroes-component-template&quot;&gt;그것에 바인딩&lt;/a&gt; 과 같이.</target>
        </trans-unit>
        <trans-unit id="a2edb9a418b0554b3bfc9b77ca9cc6ab8f255079" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;heroDe&lt;/code&gt; in the previous test is a &lt;code&gt;&lt;a href=&quot;../api/core/debugelement&quot;&gt;DebugElement&lt;/a&gt;&lt;/code&gt; that represents the hero &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;heroDe&lt;/code&gt; 이전 테스트는이다 &lt;code&gt;&lt;a href=&quot;../api/core/debugelement&quot;&gt;DebugElement&lt;/a&gt;&lt;/code&gt; 영웅 나타내는 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe76834c11e23bdf25e69d2b4d46892575be8ced" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;heroForm&lt;/code&gt; template variable is now a reference to the &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; directive instance that governs the form as a whole.</source>
          <target state="translated">&lt;code&gt;heroForm&lt;/code&gt; 의 템플릿 변수는 이제 참조이다 &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; 의 전체 형태에 적용 지향성 인스턴스.</target>
        </trans-unit>
        <trans-unit id="6362acf07cbe2fa34576d50dba32d4d4e546c13b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;home&lt;/code&gt; and &lt;code&gt;about&lt;/code&gt; paths are associated with the &lt;code&gt;HomeComponent&lt;/code&gt; and &lt;code&gt;AboutComponent&lt;/code&gt; views. The route configuration tells the Angular router to instantiate the &lt;code&gt;HomeComponent&lt;/code&gt; and &lt;code&gt;AboutComponent&lt;/code&gt; views when the navigation matches the corresponding path.</source>
          <target state="translated">&lt;code&gt;home&lt;/code&gt; 과 &lt;code&gt;about&lt;/code&gt; 경로는과 관련된 &lt;code&gt;HomeComponent&lt;/code&gt; 및 &lt;code&gt;AboutComponent&lt;/code&gt; 전망. 경로 구성은 탐색이 해당 경로와 일치 할 때 Angular 라우터에 &lt;code&gt;HomeComponent&lt;/code&gt; 및 &lt;code&gt;AboutComponent&lt;/code&gt; 보기 를 인스턴스화하도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="2a02f37aa3baaa14054711339393bc3aef4719e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; value appears in the URL as (&lt;code&gt;;id=15;foo=foo&lt;/code&gt;), not in the URL path. The path for the &quot;Heroes&quot; route doesn't have an &lt;code&gt;:id&lt;/code&gt; token.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; (값으로서 URL에 나타나는 &lt;code&gt;;id=15;foo=foo&lt;/code&gt; ) 아니라 URL 경로이다. &quot;Heroes&quot;경로의 경로에는 &lt;code&gt;:id&lt;/code&gt; 토큰 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d2a37db1eb13b9ead8103b3a67181318ca13dfa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id=&quot;introductionHeader&quot;&quot;&lt;/code&gt; is a &lt;a href=&quot;i18n#custom-id&quot;&gt;custom ID&lt;/a&gt;, but without the &lt;code&gt;@@&lt;/code&gt; prefix required in the source HTML.</source>
          <target state="translated">&lt;code&gt;id=&quot;introductionHeader&quot;&quot;&lt;/code&gt; A는 &lt;a href=&quot;i18n#custom-id&quot;&gt;사용자 정의 ID&lt;/a&gt; , 그러나없이 &lt;code&gt;@@&lt;/code&gt; 접두사 소스 HTML에서이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bcbab5f11479981553cbc81516e984d3e5ea7327" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;identity&lt;/code&gt; validator implements the &lt;code&gt;&lt;a href=&quot;../api/forms/validatorfn&quot;&gt;ValidatorFn&lt;/a&gt;&lt;/code&gt; interface. It takes an Angular control object as an argument and returns either null if the form is valid, or &lt;code&gt;&lt;a href=&quot;../api/forms/validationerrors&quot;&gt;ValidationErrors&lt;/a&gt;&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;identity&lt;/code&gt; 검증은 구현 &lt;code&gt;&lt;a href=&quot;../api/forms/validatorfn&quot;&gt;ValidatorFn&lt;/a&gt;&lt;/code&gt; 의 인터페이스를. Angular 컨트롤 개체를 인수로 사용하고 양식이 유효하면 null을 반환하고 그렇지 않으면 &lt;code&gt;&lt;a href=&quot;../api/forms/validationerrors&quot;&gt;ValidationErrors&lt;/a&gt;&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7232545d328800c53fff51138f5955f3e7f74341" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import&lt;/code&gt; statement specifies an additional &lt;code&gt;&lt;a href=&quot;../api/core/elementref&quot;&gt;ElementRef&lt;/a&gt;&lt;/code&gt; symbol from the Angular &lt;code&gt;core&lt;/code&gt; library:</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 문은 추가로 지정 &lt;code&gt;&lt;a href=&quot;../api/core/elementref&quot;&gt;ElementRef&lt;/a&gt;&lt;/code&gt; 각도에서 심볼 &lt;code&gt;core&lt;/code&gt; 라이브러리 :</target>
        </trans-unit>
        <trans-unit id="049525d2c4f861b9a942bcdfc68610b177c1bcb9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;imports&lt;/code&gt; array</source>
          <target state="translated">&lt;code&gt;imports&lt;/code&gt; 어레이</target>
        </trans-unit>
        <trans-unit id="8c1be88d9d2352c6c3fbf36e60352a74ee41e8c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in-memory-data.service.ts&lt;/code&gt; file replaces &lt;code&gt;mock-heroes.ts&lt;/code&gt;, which is now safe to delete.</source>
          <target state="translated">&lt;code&gt;in-memory-data.service.ts&lt;/code&gt; 파일은 대체 &lt;code&gt;mock-heroes.ts&lt;/code&gt; 지금 삭제하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="5948673b687ff09a4cbca50cc357fac757e1e338" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in-memory-data.service.ts&lt;/code&gt; file will take over the function of &lt;code&gt;mock-heroes.ts&lt;/code&gt;. However, don't delete &lt;code&gt;mock-heroes.ts&lt;/code&gt; yet, as you still need it for a few more steps of this tutorial.</source>
          <target state="translated">&lt;code&gt;in-memory-data.service.ts&lt;/code&gt; 파일의 기능 이상 걸릴 &lt;code&gt;mock-heroes.ts&lt;/code&gt; . 그러나 아직 &lt;code&gt;mock-heroes.ts&lt;/code&gt; 를 삭제하지 마십시오 .이 자습서의 몇 단계를 더 수행하는 데 여전히 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1ddf450cc5e1c65a6c7b59f655887b0662ef9011" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index.html&lt;/code&gt; file is also modified during the build process to include script tags that enable differential loading. See the sample output below from the &lt;code&gt;index.html&lt;/code&gt; file produced during a build using &lt;code&gt;ng build&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;index.html&lt;/code&gt; 파일은 빌드 프로세스 중에 차등로드를 가능하게하는 스크립트 태그를 포함하도록 수정됩니다. &lt;code&gt;ng build&lt;/code&gt; 를 사용하여 빌드하는 동안 생성 된 &lt;code&gt;index.html&lt;/code&gt; 파일 에서 아래의 샘플 출력을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfcc0a77d947eb184ba0eb6295bbbba9aa94afdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index.html&lt;/code&gt; will likely have script tags loading AngularJS files, so the &lt;code&gt;index.html&lt;/code&gt; for AOT must also load those files. An easy way to copy them is by adding each to the &lt;code&gt;copy-dist-files.js&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;index.html&lt;/code&gt; 소위 가능성이 AngularJS와 파일을로드 스크립트 태그를해야합니다 &lt;code&gt;index.html&lt;/code&gt; 을 AOT에 대한 또한 해당 파일을로드해야합니다. 복사하는 쉬운 방법은 각각 &lt;code&gt;copy-dist-files.js&lt;/code&gt; 파일 에 추가하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="779016803ead9dfec62b8680c130c4c7b844144b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index&lt;/code&gt; property of the &lt;code&gt;NgFor&lt;/code&gt; directive context returns the zero-based index of the item in each iteration. You can capture the &lt;code&gt;index&lt;/code&gt; in a template input variable and use it in the template.</source>
          <target state="translated">&lt;code&gt;NgFor&lt;/code&gt; 지시문 컨텍스트 의 &lt;code&gt;index&lt;/code&gt; 속성은 각 반복에서 항목의 인덱스 (0부터 시작)를 반환합니다. 템플리트 입력 변수에서 &lt;code&gt;index&lt;/code&gt; 을 캡처하여 템플리트에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e680efed95e08393f7d53fb276d913ac1224a8da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inject&lt;/code&gt; function is often adequate for this purpose. But &lt;code&gt;inject&lt;/code&gt; throws an error if it can't provide the service.</source>
          <target state="translated">&lt;code&gt;inject&lt;/code&gt; 기능들은 이러한 목적에 적절하다. 그러나 &lt;code&gt;inject&lt;/code&gt; 이 서비스를 제공 할 수없는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a871438d8f60cdf53bf645d03648573c77c8c396" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;installMode&lt;/code&gt; determines how these resources are initially cached. The &lt;code&gt;installMode&lt;/code&gt; can be either of two values:</source>
          <target state="translated">&lt;code&gt;installMode&lt;/code&gt; 는 이러한 자원이 처음에 캐시되는 방법을 결정합니다. &lt;code&gt;installMode&lt;/code&gt; 는 두 값 중 하나 일 수있다 :</target>
        </trans-unit>
        <trans-unit id="7adafbc3d7e9fcd1852e26be325cfdf1980b4479" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intercept&lt;/code&gt; method transforms a request into an &lt;code&gt;Observable&lt;/code&gt; that eventually returns the HTTP response. In this sense, each interceptor is fully capable of handling the request entirely by itself.</source>
          <target state="translated">&lt;code&gt;intercept&lt;/code&gt; 방법은에 요청 변환 &lt;code&gt;Observable&lt;/code&gt; 결국 HTTP 응답을 반환합니다. 이런 의미에서, 각 인터셉터는 요청 자체를 완전히 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="2108a2ee63b2069a96b62e4fd1f9a5f2332d2859" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isAlterEgoTaken()&lt;/code&gt; method dispatches an HTTP request that checks if the alter ego is available, and returns &lt;code&gt;Observable&amp;lt;boolean&amp;gt;&lt;/code&gt; as the result. The &lt;code&gt;validate()&lt;/code&gt; method pipes the response through the &lt;code&gt;map&lt;/code&gt; operator and transforms it into a validation result.</source>
          <target state="translated">&lt;code&gt;isAlterEgoTaken()&lt;/code&gt; 분신이 가능하며, 반환하는 경우 그 검사 방법은 HTTP 요청을 전달 &lt;code&gt;Observable&amp;lt;boolean&amp;gt;&lt;/code&gt; 결과로. &lt;code&gt;validate()&lt;/code&gt; 메소드 파이프 관통 응답 &lt;code&gt;map&lt;/code&gt; 검증 결과에 연산자 및 변환을.</target>
        </trans-unit>
        <trans-unit id="a15d1612279f7ffcaff9708155f1d1d8a675e7b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isAlterEgoTaken()&lt;/code&gt; method dispatches an HTTP request that checks if the alter ego is available, and returns &lt;code&gt;Observable&amp;lt;boolean&amp;gt;&lt;/code&gt; as the result. We pipe the response through the &lt;code&gt;map&lt;/code&gt; operator and transform it into a validation result. As always, we return &lt;code&gt;null&lt;/code&gt; if the form is valid, and &lt;code&gt;&lt;a href=&quot;../api/forms/validationerrors&quot;&gt;ValidationErrors&lt;/a&gt;&lt;/code&gt; if it is not. We make sure to handle any potential errors with the &lt;code&gt;catchError&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;isAlterEgoTaken()&lt;/code&gt; 분신이 가능하며, 반환하는 경우 그 검사 방법은 HTTP 요청을 전달 &lt;code&gt;Observable&amp;lt;boolean&amp;gt;&lt;/code&gt; 결과로. 응답을 &lt;code&gt;map&lt;/code&gt; 연산자를 통해 파이프하고 유효성 검사 결과로 변환합니다. 항상 그렇듯이, 우리 는 폼이 유효하면 &lt;code&gt;null&lt;/code&gt; 을 , 유효 하지 않으면 &lt;code&gt;&lt;a href=&quot;../api/forms/validationerrors&quot;&gt;ValidationErrors&lt;/a&gt;&lt;/code&gt; 를 반환합니다. &lt;code&gt;catchError&lt;/code&gt; 연산자로 잠재적 오류를 처리해야합니다 .</target>
        </trans-unit>
        <trans-unit id="987a0d43d85abf3ebd433e3c46293440300bbf70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isCachable()&lt;/code&gt; function determines if the request is cachable. In this sample, only GET requests to the npm package search api are cachable.</source>
          <target state="translated">&lt;code&gt;isCachable()&lt;/code&gt; 요청이 캐시 할 경우 함수를 결정한다. 이 샘플에서는 npm 패키지 검색 API에 대한 GET 요청 만 캐시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74b06e437c6efb01a3288a4392197d8254eac202" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isCacheable()&lt;/code&gt; function determines if the request is cacheable. In this sample, only GET requests to the npm package search api are cacheable.</source>
          <target state="translated">&lt;code&gt;isCacheable()&lt;/code&gt; 요청이 있으면 캐시 기능은 결정한다. 이 샘플에서는 npm 패키지 검색 API에 대한 GET 요청 만 캐시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81986ed4ffe8be92868d359a52c73e46a0bba3bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;karma.conf.js&lt;/code&gt; file is a partial Karma configuration file. The CLI constructs the full runtime configuration in memory, based on application structure specified in the &lt;code&gt;angular.json&lt;/code&gt; file, supplemented by &lt;code&gt;karma.conf.js&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;karma.conf.js&lt;/code&gt; 의 파일 부분 카르마 구성 파일입니다. CLI는 &lt;code&gt;angular.json&lt;/code&gt; 보충 된 &lt;code&gt;karma.conf.js&lt;/code&gt; 파일에 지정된 애플리케이션 구조를 기반으로 메모리에 전체 런타임 구성을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="e5ea13e13bd51c93a963c4708123611462bd790e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keyup&lt;/code&gt; event binding sends every keystroke to the component's &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/%24locationshim#search&quot;&gt;search()&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;keyup&lt;/code&gt; 바인딩 이벤트는 구성 요소의에 모든 키 입력 전송 &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/%24locationshim#search&quot;&gt;search()&lt;/a&gt;&lt;/code&gt; 메소드를.</target>
        </trans-unit>
        <trans-unit id="4d5d3ef5c47ecc1bce3f9257d6bf5a046e88f610" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let-i&lt;/code&gt; and &lt;code&gt;let-odd&lt;/code&gt; variables were defined as &lt;code&gt;let i=index&lt;/code&gt; and &lt;code&gt;let &lt;a href=&quot;../api/common/ngforofcontext#odd&quot;&gt;odd&lt;/a&gt;=&lt;a href=&quot;../api/common/ngforofcontext#odd&quot;&gt;odd&lt;/a&gt;&lt;/code&gt;. Angular sets them to the current value of the context's &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/common/ngforofcontext#odd&quot;&gt;odd&lt;/a&gt;&lt;/code&gt; properties.</source>
          <target state="translated">&lt;code&gt;let-i&lt;/code&gt; 및 &lt;code&gt;let-odd&lt;/code&gt; 로 정의 된 변수 &lt;code&gt;let i=index&lt;/code&gt; 및 &lt;code&gt;let &lt;a href=&quot;../api/common/ngforofcontext#odd&quot;&gt;odd&lt;/a&gt;=&lt;a href=&quot;../api/common/ngforofcontext#odd&quot;&gt;odd&lt;/a&gt;&lt;/code&gt; . Angular는 컨텍스트 &lt;code&gt;index&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/common/ngforofcontext#odd&quot;&gt;odd&lt;/a&gt;&lt;/code&gt; 속성 의 현재 값으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="3ca5558e21840bcf4b3b38fc07d6a40c146f008d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let-i&lt;/code&gt; and &lt;code&gt;let-odd&lt;/code&gt; variables were defined as &lt;code&gt;let i=index&lt;/code&gt; and &lt;code&gt;let odd=odd&lt;/code&gt;. Angular sets them to the current value of the context's &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;odd&lt;/code&gt; properties.</source>
          <target state="translated">&lt;code&gt;let-i&lt;/code&gt; 및 &lt;code&gt;let-odd&lt;/code&gt; 로 정의 된 변수 &lt;code&gt;let i=index&lt;/code&gt; 및 &lt;code&gt;let odd=odd&lt;/code&gt; . Angular는 컨텍스트 &lt;code&gt;index&lt;/code&gt; 및 &lt;code&gt;odd&lt;/code&gt; 속성 의 현재 값으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="d45ed2edc5561795b4fe88a5fd6a363a90124505" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; keyword before &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; creates a template input variable called &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; directive iterates over the &lt;code&gt;items&lt;/code&gt; array returned by the parent component's &lt;code&gt;items&lt;/code&gt; property and sets &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; to the current item from the array during each iteration.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 이전 키워드 &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; 이라는 템플릿 입력 변수 생성 &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 오버 지시 반복 &lt;code&gt;items&lt;/code&gt; 상위 구성 요소의에 의해 반환 된 배열 &lt;code&gt;items&lt;/code&gt; 특성과 세트 &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; 각 반복하는 동안 배열에서 현재 항목에.</target>
        </trans-unit>
        <trans-unit id="ba4f5f1907debf2c5dcfc0006affb24e12d5c62d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; keyword before &lt;code&gt;item&lt;/code&gt; creates a template input variable called &lt;code&gt;item&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; directive iterates over the &lt;code&gt;items&lt;/code&gt; array returned by the parent component's &lt;code&gt;items&lt;/code&gt; property and sets &lt;code&gt;item&lt;/code&gt; to the current item from the array during each iteration.</source>
          <target state="translated">&lt;code&gt;item&lt;/code&gt; 앞에 있는 &lt;code&gt;let&lt;/code&gt; 키워드 는 &lt;code&gt;item&lt;/code&gt; 이라는 템플릿 입력 변수를 만듭니다 . &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 오버 지시 반복 &lt;code&gt;items&lt;/code&gt; 상위 구성 요소의에 의해 반환 된 배열 &lt;code&gt;items&lt;/code&gt; 특성과 세트 &lt;code&gt;item&lt;/code&gt; 각 반복하는 동안 배열에서 현재 항목에.</target>
        </trans-unit>
        <trans-unit id="67312891b24b8f98f7077e6a626334bbd888baf9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; keyword declares a &lt;a href=&quot;structural-directives#template-input-variable&quot;&gt;&lt;em&gt;template input variable&lt;/em&gt;&lt;/a&gt; that you reference within the template. The input variables in this example are &lt;code&gt;hero&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../api/common/ngforofcontext#odd&quot;&gt;odd&lt;/a&gt;&lt;/code&gt;. The parser translates &lt;code&gt;let hero&lt;/code&gt;, &lt;code&gt;let i&lt;/code&gt;, and &lt;code&gt;let &lt;a href=&quot;../api/common/ngforofcontext#odd&quot;&gt;odd&lt;/a&gt;&lt;/code&gt; into variables named &lt;code&gt;let-hero&lt;/code&gt;, &lt;code&gt;let-i&lt;/code&gt;, and &lt;code&gt;let-odd&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 키워드는 선언 &lt;a href=&quot;structural-directives#template-input-variable&quot;&gt;&lt;em&gt;템플릿 입력 변수&lt;/em&gt;&lt;/a&gt; 템플릿 내에서 참조하는지합니다. 이 예제의 입력 변수는 &lt;code&gt;hero&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/common/ngforofcontext#odd&quot;&gt;odd&lt;/a&gt;&lt;/code&gt; 입니다. 파서 변환 &lt;code&gt;let hero&lt;/code&gt; , &lt;code&gt;let i&lt;/code&gt; 및 &lt;code&gt;let &lt;a href=&quot;../api/common/ngforofcontext#odd&quot;&gt;odd&lt;/a&gt;&lt;/code&gt; 라는 변수로 &lt;code&gt;let-hero&lt;/code&gt; , &lt;code&gt;let-i&lt;/code&gt; 및 &lt;code&gt;let-odd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="634a292f8119dbc280342cc788d0714781558b4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; keyword declares a &lt;a href=&quot;structural-directives#template-input-variable&quot;&gt;&lt;em&gt;template input variable&lt;/em&gt;&lt;/a&gt; that you reference within the template. The input variables in this example are &lt;code&gt;hero&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, and &lt;code&gt;odd&lt;/code&gt;. The parser translates &lt;code&gt;let hero&lt;/code&gt;, &lt;code&gt;let i&lt;/code&gt;, and &lt;code&gt;let odd&lt;/code&gt; into variables named &lt;code&gt;let-hero&lt;/code&gt;, &lt;code&gt;let-i&lt;/code&gt;, and &lt;code&gt;let-odd&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 키워드는 선언 &lt;a href=&quot;structural-directives#template-input-variable&quot;&gt;&lt;em&gt;템플릿 입력 변수&lt;/em&gt;&lt;/a&gt; 템플릿 내에서 참조하는지합니다. 이 예제의 입력 변수는 &lt;code&gt;hero&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; 및 &lt;code&gt;odd&lt;/code&gt; 입니다. 파서는 &lt;code&gt;let hero&lt;/code&gt; , &lt;code&gt;let i&lt;/code&gt; , &lt;code&gt;let odd&lt;/code&gt; 를 &lt;code&gt;let-hero&lt;/code&gt; , &lt;code&gt;let-i&lt;/code&gt; , &lt;code&gt;let-odd&lt;/code&gt; 라는 변수로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="f257babd3730c1022992c731831065e7e6e340b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loadComponent()&lt;/code&gt; method chooses an ad using some math.</source>
          <target state="translated">&lt;code&gt;loadComponent()&lt;/code&gt; 메소드는 어떤 수학을 사용하여 광고를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="d58598b12b02d1cfd9ce52912a2c6426fcdcb59b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loadComponent()&lt;/code&gt; method is doing a lot of the heavy lifting here. Take it step by step. First, it picks an ad.</source>
          <target state="translated">&lt;code&gt;loadComponent()&lt;/code&gt; 메소드는 여기에 무거운 많이하고있다. 단계별로 가져 가십시오. 먼저 광고를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="657da6bcc28ab42d092f42096554f848147cd763" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;messageService&lt;/code&gt; property &lt;strong&gt;must be public&lt;/strong&gt; because you're going to bind to it in the template.</source>
          <target state="translated">&lt;code&gt;messageService&lt;/code&gt; 속성은 &lt;strong&gt;공개해야&lt;/strong&gt; 템플릿에 바인딩 가고 있기 때문에.</target>
        </trans-unit>
        <trans-unit id="b39bef99ed6eb1d31b77310df12a7ce7fa0909da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;move&lt;/code&gt; method moves the provided source files to their destination when the schematic is applied.</source>
          <target state="translated">&lt;code&gt;move&lt;/code&gt; 개략적인가시에있어서 자신의 목적지로 제공되는 소스 파일을 이동시킨다.</target>
        </trans-unit>
        <trans-unit id="a555fd300f9beee4ec986089765c4c4f9d39addf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; is provided as a property from your factory function. It is the same &lt;code&gt;name&lt;/code&gt; you defined in the schema.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 당신의 공장 함수의 속성으로 제공됩니다. 스키마에서 정의한 것과 동일한 &lt;code&gt;name&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8c15bebd1c9694615338dc82048275afeb2594dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; parameter should be the name of the AngularJS directive.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 매개 변수는 AngularJS와 지시어의 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9c4f8ad580b2ff5b5d69b95f0508568f8aa6cdb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; property is &lt;code&gt;Sally&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 속성입니다 &lt;code&gt;Sally&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2858b8b17d6d9343e890b1e117c236f2f647306e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt; notification sends a value such as a number, a string, or an object.</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; 통지는 숫자, 캐릭터, 또는 목적으로하는 값을 전송한다.</target>
        </trans-unit>
        <trans-unit id="e81819a9cfe4af19f5636eb47d2ae1d60abe59cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt; object</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; 객체</target>
        </trans-unit>
        <trans-unit id="b44a1960d514a7a09b106ab46609d67cafa3ba79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt; object represents the next interceptor in the chain of interceptors. The final &lt;code&gt;next&lt;/code&gt; in the chain is the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; backend handler that sends the request to the server and receives the server's response.</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; 객체 인터셉터 체인의 다음 인터셉터를 나타낸다. 체인 의 마지막 &lt;code&gt;next&lt;/code&gt; 은 요청을 서버로 보내고 서버의 응답을받는 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 백엔드 핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="ef365b122d4f3b65df123f4627705808d9b58632" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ng &lt;a href=&quot;../api/forms/ngmodel#update&quot;&gt;update&lt;/a&gt;&lt;/code&gt; command can be used to update your workspace's library dependencies. If you supply no options or use the help option, the command examines your workspace and suggests libraries to update.</source>
          <target state="translated">&lt;code&gt;ng &lt;a href=&quot;../api/forms/ngmodel#update&quot;&gt;update&lt;/a&gt;&lt;/code&gt; 명령은 작업 공간의 라이브러리 의존성을 업데이트하는 데 사용할 수 있습니다. 옵션을 제공하지 않거나 help 옵션을 사용하면이 명령은 작업 공간을 검사하고 업데이트 할 라이브러리를 제안합니다.</target>
        </trans-unit>
        <trans-unit id="661eb26df65f06b9bd2b124b6434e53befc743b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ng add&lt;/code&gt; command uses a package manager such as &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; or &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;yarn&lt;/a&gt; to install the library package, and invokes schematics that are included in the package to other scaffolding within the project code, such as adding import statements, fonts, themes, and so on.</source>
          <target state="translated">&lt;code&gt;ng add&lt;/code&gt; 명령은 같은 패키지 관리자를 사용하여 &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;NPM&lt;/a&gt; 또는 &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;원사&lt;/a&gt; 라이브러리 패키지를 설치하고, 등등 추가 import 문, 글꼴, 테마, 같은 프로젝트 코드 내에서 다른 비계에 패키지에 포함되어 있습니다 발동 회로도.</target>
        </trans-unit>
        <trans-unit id="402924763f2c69b9a547faff6eeb2122f32401e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ng add&lt;/code&gt; command uses the npm package manager or &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;yarn&lt;/a&gt; to install the library package, and invokes schematics that are included in the package to other scaffolding within the project code, such as adding import statements, fonts, themes, and so on.</source>
          <target state="translated">&lt;code&gt;ng add&lt;/code&gt; 명령은 고궁 박물원 패키지 관리자 또는 사용 &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;원사를&lt;/a&gt; 라이브러리 패키지를 설치하고, 등등 추가 import 문, 글꼴, 테마, 같은 프로젝트 코드 내에서 다른 비계에 패키지에 포함되어 있습니다 발동 회로도.</target>
        </trans-unit>
        <trans-unit id="d7bb80a2b7541f339e003710c97fc562d5c771d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ng build&lt;/code&gt; command with the &lt;code&gt;--prod&lt;/code&gt; meta-flag (&lt;code&gt;ng build --prod&lt;/code&gt;) compiles with AOT by default.</source>
          <target state="translated">&lt;code&gt;ng build&lt;/code&gt; 와 명령 &lt;code&gt;--prod&lt;/code&gt; 메타 플래그 ( &lt;code&gt;ng build --prod&lt;/code&gt; 기본적으로 AOT와) 컴파일.</target>
        </trans-unit>
        <trans-unit id="151524c159dafe7685065a9676b66852e12e4f54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ng extract-i18n&lt;/code&gt; command (with no options) generates a source language file named &lt;code&gt;messages.xlf&lt;/code&gt; in the project &lt;code&gt;src&lt;/code&gt; folder. Create &lt;em&gt;translation&lt;/em&gt; files for each language by copying the source language file. To avoid confusion with multiple translations, you should organize the language translation files by locale in a dedicated &lt;code&gt;locale&lt;/code&gt; folder under &lt;code&gt;src/&lt;/code&gt;. Use a filename extension that matches the associated locale, such as &lt;code&gt;messages.fr.xlf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ng extract-i18n&lt;/code&gt; 명령 (옵션없이)라는 이름의 소스 언어 파일 생성 &lt;code&gt;messages.xlf&lt;/code&gt; 을 프로젝트에서 &lt;code&gt;src&lt;/code&gt; 폴더에 있습니다. 소스 언어 파일을 복사하여 각 언어에 대한 &lt;em&gt;번역&lt;/em&gt; 파일을 만듭니다 . 여러 번역과의 혼동을 피하려면 &lt;code&gt;src/&lt;/code&gt; 아래 의 전용 &lt;code&gt;locale&lt;/code&gt; 폴더에 로캘 별로 언어 번역 파일을 구성해야합니다 . &lt;code&gt;messages.fr.xlf&lt;/code&gt; 와 같이 연관된 로케일과 일치하는 파일 이름 확장자를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2198a23cdfaca74ee5cad793b7e3cc90c0218b2c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ng generate&lt;/code&gt; command creates the &lt;code&gt;projects/my-lib&lt;/code&gt; folder in your workspace, which contains a component and a service inside an NgModule.</source>
          <target state="translated">&lt;code&gt;ng generate&lt;/code&gt; 명령은 생성 &lt;code&gt;projects/my-lib&lt;/code&gt; 구성 요소와 NgModule 내부 서비스가 포함 된 작업 공간에 폴더를.</target>
        </trans-unit>
        <trans-unit id="915b5365ccaeb02cfaf1faa3905f771f9e676ca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ng new&lt;/code&gt; command prompts you for information about features to include in the initial app project. Accept the defaults by pressing the Enter or Return key.</source>
          <target state="translated">&lt;code&gt;ng new&lt;/code&gt; 기능에 대한 자세한 내용은 명령 프롬프트는 초기 응용 프로그램 프로젝트에 포함합니다. Enter 또는 Return 키를 눌러 기본값을 승인하십시오.</target>
        </trans-unit>
        <trans-unit id="47140589baf6417447acb195c1530707c4399071" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ng new&lt;/code&gt; command prompts you for information about features to include in the initial app. Accept the defaults by pressing the Enter or Return key.</source>
          <target state="translated">&lt;code&gt;ng new&lt;/code&gt; 기능에 대한 자세한 내용은 명령 프롬프트는 초기 응용 프로그램에 포함 할. Enter 또는 Return 키를 눌러 기본값을 승인하십시오.</target>
        </trans-unit>
        <trans-unit id="d53cb4d3de04d121569ef7fced8acc26fcb00968" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ng serve&lt;/code&gt; command builds the app, starts the development server, watches the source files, and rebuilds the app as you make changes to those files.</source>
          <target state="translated">&lt;code&gt;ng serve&lt;/code&gt; 명령, 응용 프로그램을 빌드 개발 서버를 시작, 소스 파일을 감시하고, 당신이 그 파일을 변경으로 응용 프로그램을 다시 작성합니다.</target>
        </trans-unit>
        <trans-unit id="decf48f9f57ece2b4916fc311b2c476376d5e095" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ng serve&lt;/code&gt; command launches the server, watches your files, and rebuilds the app as you make changes to those files.</source>
          <target state="translated">&lt;code&gt;ng serve&lt;/code&gt; 명령 출시를 서버, 파일을 감시하고, 당신이 그 파일을 변경으로 응용 프로그램을 다시 작성합니다.</target>
        </trans-unit>
        <trans-unit id="6cc6ec4618d0114656fc6e332ab1860f96ca810e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ng test&lt;/code&gt; command builds the app in &lt;em&gt;watch mode&lt;/em&gt;, and launches the &lt;a href=&quot;https://karma-runner.github.io&quot;&gt;Karma test runner&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ng test&lt;/code&gt; 명령의 응용 프로그램 빌드 &lt;em&gt;시계 모드를&lt;/em&gt; 하고 시작 &lt;a href=&quot;https://karma-runner.github.io&quot;&gt;카르마 테스트 주자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7dd4f9439ed1af7e0523f545b94e486b40d9a486" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ng update&lt;/code&gt; command can be used to update your workspace's library dependencies. If you supply no options or use the help option, the command examines your workspace and suggests libraries to update.</source>
          <target state="translated">&lt;code&gt;ng update&lt;/code&gt; 명령은 작업 공간의 라이브러리 의존성을 업데이트하는 데 사용할 수 있습니다. 옵션을 제공하지 않거나 도움말 옵션을 사용하는 경우 명령은 작업 공간을 검사하고 업데이트 할 라이브러리를 제안합니다.</target>
        </trans-unit>
        <trans-unit id="c7b6107217efb4567dcc9df7baefcf1ae3bd71db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ng xi18n&lt;/code&gt; command generates a translation source file named &lt;code&gt;messages.xlf&lt;/code&gt; in the project &lt;code&gt;src&lt;/code&gt; folder. The next step is to translate the display strings in this source file into language-specific translation files. The example in this guide creates a French translation file.</source>
          <target state="translated">&lt;code&gt;ng xi18n&lt;/code&gt; 명령이라는 이름의 번역 소스 파일 생성 &lt;code&gt;messages.xlf&lt;/code&gt; 을 프로젝트에서 &lt;code&gt;src&lt;/code&gt; 폴더에 있습니다. 다음 단계는이 소스 파일의 표시 문자열을 언어 별 번역 파일로 변환하는 것입니다. 이 안내서의 예는 프랑스어 번역 파일을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="94f0959cbc129968dc58b82a0ff7ada846d3170b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ng-href&lt;/code&gt; directive allows AngularJS to preprocess the &lt;code&gt;href&lt;/code&gt; property so that it can replace the binding expression with the appropriate URL before the browser fetches from that URL.</source>
          <target state="translated">&lt;code&gt;ng-href&lt;/code&gt; 지시어는 AngularJS와는 사전 처리 할 수 있습니다 &lt;code&gt;href&lt;/code&gt; 는 해당 URL에서 브라우저 반입 전에 적절한 URL로 바인딩 식을 장착 할 수 있도록 속성을.</target>
        </trans-unit>
        <trans-unit id="7bd2c70c6651fab453eaa2bf35d388700b4f79b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ng-src&lt;/code&gt; directive allows AngularJS to preprocess the &lt;code&gt;src&lt;/code&gt; property so that it can replace the binding expression with the appropriate URL before the browser fetches from that URL.</source>
          <target state="translated">&lt;code&gt;ng-src&lt;/code&gt; 지시어는 AngularJS와는 전처리 수 &lt;code&gt;src&lt;/code&gt; 는 해당 URL에서 브라우저 반입 전에 적절한 URL로 바인딩 식을 장착 할 수 있도록 속성을.</target>
        </trans-unit>
        <trans-unit id="857809768abb4476e5a1dc05028c8b640e255a37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ng-valid&lt;/code&gt;/&lt;code&gt;ng-invalid&lt;/code&gt; pair is particularly interesting, because you want to send a strong visual signal when the values are invalid. You also want to mark required fields.</source>
          <target state="translated">&lt;code&gt;ng-valid&lt;/code&gt; / &lt;code&gt;ng-invalid&lt;/code&gt; 당신이 값이 유효하지 않은 강한 시각적 인 신호를 보낼 때문에 쌍은 특히 흥미 롭다. 또한 필수 필드를 표시하려고합니다.</target>
        </trans-unit>
        <trans-unit id="3138ac0ec252ffe200dfb5a828a82de4ac40f99c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ng-valid&lt;/code&gt;/&lt;code&gt;ng-invalid&lt;/code&gt; pair is the most interesting, because you want to send a strong visual signal when the values are invalid. You also want to mark required fields. To create such visual feedback, add definitions for the &lt;code&gt;ng-*&lt;/code&gt; CSS classes.</source>
          <target state="translated">&lt;code&gt;ng-valid&lt;/code&gt; / &lt;code&gt;ng-invalid&lt;/code&gt; 당신이 값이 유효하지 않은 강한 시각적 인 신호를 보낼 때문에 쌍, 가장 재미있다. 필수 필드를 표시하려고합니다. 이러한 시각적 피드백을 작성하려면 &lt;code&gt;ng-*&lt;/code&gt; CSS 클래스에 대한 정의를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="84ce1e908b621b2c0b80729e1bdda280c58ec149" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngAfterViewInit()&lt;/code&gt; lifecycle hook is an important wrinkle. The timer component isn't available until &lt;em&gt;after&lt;/em&gt; Angular displays the parent view. So it displays &lt;code&gt;0&lt;/code&gt; seconds initially.</source>
          <target state="translated">&lt;code&gt;ngAfterViewInit()&lt;/code&gt; 주기 후크 중요한 주름이다. 타이머 구성 요소가 될 때까지 사용할 수 없습니다 &lt;em&gt;후&lt;/em&gt; 각도를 표시 부모보기. 따라서 처음 에는 &lt;code&gt;0&lt;/code&gt; 초를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="9ed41a4355ac7ba51dd443b347ab879e887f8572" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngExpressEngine()&lt;/code&gt; function is a wrapper around Universal's &lt;code&gt;&lt;a href=&quot;../api/platform-server/rendermodule&quot;&gt;renderModule&lt;/a&gt;()&lt;/code&gt; function which turns a client's requests into server-rendered HTML pages. It accepts an object with the following properties:</source>
          <target state="translated">&lt;code&gt;ngExpressEngine()&lt;/code&gt; 함수는 범용의 래퍼입니다 &lt;code&gt;&lt;a href=&quot;../api/platform-server/rendermodule&quot;&gt;renderModule&lt;/a&gt;()&lt;/code&gt; 서버 렌더링 된 HTML 페이지에 클라이언트의 요청을 회전 기능. 다음 속성을 가진 객체를받습니다.</target>
        </trans-unit>
        <trans-unit id="55184b9fb03b4d4f4740d8b6e58fea5b03d407bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngExpressEngine()&lt;/code&gt; function is a wrapper around Universal's &lt;code&gt;&lt;a href=&quot;../api/platform-server/rendermodulefactory&quot;&gt;renderModuleFactory&lt;/a&gt;()&lt;/code&gt; function which turns a client's requests into server-rendered HTML pages.</source>
          <target state="translated">&lt;code&gt;ngExpressEngine()&lt;/code&gt; 함수는 범용의 래퍼입니다 &lt;code&gt;&lt;a href=&quot;../api/platform-server/rendermodulefactory&quot;&gt;renderModuleFactory&lt;/a&gt;()&lt;/code&gt; 서버 렌더링 된 HTML 페이지에 클라이언트의 요청을 회전 기능.</target>
        </trans-unit>
        <trans-unit id="cea0266c75765dd1f7f192925449a11f3e7685c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngExpressEngine()&lt;/code&gt; function returns a &lt;code&gt;Promise&lt;/code&gt; callback that resolves to the rendered page. It's up to the engine to decide what to do with that page. This engine's &lt;code&gt;Promise&lt;/code&gt; callback returns the rendered page to the web server, which then forwards it to the client in the HTTP response.</source>
          <target state="translated">&lt;code&gt;ngExpressEngine()&lt;/code&gt; 함수는 반환 &lt;code&gt;Promise&lt;/code&gt; 콜백을 렌더링 된 페이지에 해결합니다. 해당 페이지로 수행 할 작업을 결정하는 것은 엔진에 달려 있습니다. 이 엔진의 &lt;code&gt;Promise&lt;/code&gt; 콜백은 렌더링 된 페이지를 웹 서버에 반환 한 다음 HTTP 응답으로 클라이언트에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="e39bac5f0d896fc7bb83309ae7c71f4c31525445" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngOnChanges()&lt;/code&gt; method is your first opportunity to access those properties. Angular calls &lt;code&gt;ngOnChanges()&lt;/code&gt; before &lt;code&gt;ngOnInit()&lt;/code&gt; and many times after that. It only calls &lt;code&gt;ngOnInit()&lt;/code&gt; once.</source>
          <target state="translated">&lt;code&gt;ngOnChanges()&lt;/code&gt; 메소드는 액세스 첫 번째 기회가 이러한 속성이다. 각도 통화 &lt;code&gt;ngOnChanges()&lt;/code&gt; 전 &lt;code&gt;ngOnInit()&lt;/code&gt; 그 후 여러 번. &lt;code&gt;ngOnInit()&lt;/code&gt; 한 번만 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c3e892008e822e750da9095703e147a840b86ca5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngOnChanges()&lt;/code&gt; method is your first opportunity to access those properties. Angular calls &lt;code&gt;ngOnChanges()&lt;/code&gt; before &lt;code&gt;ngOnInit()&lt;/code&gt;, but also many times after that. It only calls &lt;code&gt;ngOnInit()&lt;/code&gt; once.</source>
          <target state="translated">&lt;code&gt;ngOnChanges()&lt;/code&gt; 메소드는 액세스 첫 번째 기회가 이러한 속성이다. Angular는 &lt;code&gt;ngOnChanges()&lt;/code&gt; 전에 &lt;code&gt;ngOnInit()&lt;/code&gt; 호출 하지만 그 이후에도 여러 번 호출 합니다. &lt;code&gt;ngOnInit()&lt;/code&gt; 한 번만 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="8e25bbb9011f26f819a7cc6069e3c5f18a8997a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngOnChanges()&lt;/code&gt; method queues an async task to set the value for the internal &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;ngOnChanges()&lt;/code&gt; 메소드 큐는 비동기 태스크는 내부의 값을 설정하는 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 의 인스턴스.</target>
        </trans-unit>
        <trans-unit id="6dbdf349a71f02e0e98a02bd939c4d3eec1858b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngOnChanges()&lt;/code&gt; method takes an object that maps each changed property name to a &lt;a href=&quot;../api/core/simplechange&quot;&gt;SimpleChange&lt;/a&gt; object holding the current and previous property values. This hook iterates over the changed properties and logs them.</source>
          <target state="translated">&lt;code&gt;ngOnChanges()&lt;/code&gt; 메소드는, 각각 변경된 속성 이름을 매핑하는 객체 얻어 &lt;a href=&quot;../api/core/simplechange&quot;&gt;SimpleChange의&lt;/a&gt; 현재 및 이전의 속성 값을 보유 개체. 이 후크는 변경된 특성을 반복하여 기록합니다.</target>
        </trans-unit>
        <trans-unit id="a0b31050175bd4d7ae74733eff74e7b30f570426" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngOnDestroy()&lt;/code&gt; method is also the time to notify another part of the application that the component is going away.</source>
          <target state="translated">&lt;code&gt;ngOnDestroy()&lt;/code&gt; 메소드는 컴포넌트가 떨어져 가고 있음을 적용한 다른 일부를 통지하는 시간이다.</target>
        </trans-unit>
        <trans-unit id="efc6439222087df75fe7510b5276e62ea8e22f67" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngOnInit()&lt;/code&gt; and &lt;code&gt;ngOnDestroy()&lt;/code&gt; methods have more vital roles to play in real applications.</source>
          <target state="translated">&lt;code&gt;ngOnInit()&lt;/code&gt; 및 &lt;code&gt;ngOnDestroy()&lt;/code&gt; 메소드는 실제 응용 프로그램에서 재생 더 중요한 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="bc9511230c44a04ab98b667e3d7957d7db190375" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngOnInit()&lt;/code&gt; is a &lt;a href=&quot;../guide/lifecycle-hooks#oninit&quot;&gt;lifecycle hook&lt;/a&gt;. Angular calls &lt;code&gt;ngOnInit()&lt;/code&gt; shortly after creating a component. It's a good place to put initialization logic.</source>
          <target state="translated">&lt;code&gt;ngOnInit()&lt;/code&gt; A는 &lt;a href=&quot;../guide/lifecycle-hooks#oninit&quot;&gt;주기 후크&lt;/a&gt; . 각도 는 구성 요소를 만든 직후 &lt;code&gt;ngOnInit()&lt;/code&gt; 호출 합니다. 초기화 로직을 배치하기에 좋은 장소입니다.</target>
        </trans-unit>
        <trans-unit id="981284d8fe4aa73e64020d62ee523dc61af1e4c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngOnInit()&lt;/code&gt; lifecycle hook calls &lt;code&gt;getHeroes()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ngOnInit()&lt;/code&gt; 라이프 사이클 후크 호출 &lt;code&gt;getHeroes()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6587607630a415e74bae14f92d2441487296dc7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngTemplateContextGuard&lt;/code&gt; static property declares the type of the template context.</source>
          <target state="translated">&lt;code&gt;ngTemplateContextGuard&lt;/code&gt; 정적 속성은 템플릿 컨텍스트의 유형을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="4d1333fb866dfc201e0e5e6735bb9286b5f00a7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ngsw-config.json&lt;/code&gt; configuration file specifies which files and data URLs the Angular service worker should cache and how it should update the cached files and data. The &lt;a href=&quot;cli&quot;&gt;Angular CLI&lt;/a&gt; processes the configuration file during &lt;code&gt;ng build --prod&lt;/code&gt;. Manually, you can process it with the &lt;code&gt;ngsw-config&lt;/code&gt; tool (where &lt;code&gt;&amp;lt;project-name&amp;gt;&lt;/code&gt; is the name of the project being built):</source>
          <target state="translated">&lt;code&gt;ngsw-config.json&lt;/code&gt; 구성 파일을 지정하는 파일과 데이터 URL을 각 서비스 노동자는 캐시해야하며이 캐시 파일과 데이터를 업데이트하는 방법. &lt;a href=&quot;cli&quot;&gt;각도 CLI는&lt;/a&gt; 동안 구성 파일 처리 &lt;code&gt;ng build --prod&lt;/code&gt; . 수동으로 &lt;code&gt;ngsw-config&lt;/code&gt; 도구를 사용하여 처리 할 수 ​​있습니다 (여기서 &lt;code&gt;&amp;lt;project-name&amp;gt;&lt;/code&gt; 은 빌드중인 프로젝트의 이름입니다).</target>
        </trans-unit>
        <trans-unit id="f3ce7551e4c509b11e24776b5f665ec3c2322ff6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;observe&lt;/code&gt; value determines the return type, according to what you are interested in observing.</source>
          <target state="translated">&lt;code&gt;observe&lt;/code&gt; 값 은 관찰 하고자하는 대상에 따라 반환 유형을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="18b77fe3b5bee95f73d1fc1877c137e7a931d878" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;onSubmit()&lt;/code&gt; method in the &lt;code&gt;ProfileEditor&lt;/code&gt; component captures the current value of &lt;code&gt;profileForm&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; to keep the form encapsulated and to provide the form value outside the component. The following example uses &lt;code&gt;console.warn&lt;/code&gt; to log a message to the browser console.</source>
          <target state="translated">&lt;code&gt;ProfileEditor&lt;/code&gt; 구성 요소 의 &lt;code&gt;onSubmit()&lt;/code&gt; 메소드 는 &lt;code&gt;profileForm&lt;/code&gt; 의 현재 값을 캡처합니다 . &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; 를 사용 하여 양식을 캡슐화하고 구성 요소 외부에 양식 값을 제공하십시오. 다음 예제는 &lt;code&gt;console.warn&lt;/code&gt; 을 사용 하여 메시지를 브라우저 콘솔에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="ddbbb7fe03501b2cd0af133be1faf50d5e969adf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;optimization&lt;/code&gt; and &lt;code&gt;sourceMap&lt;/code&gt; browser builder options can be either a Boolean or an Object for more fine-grained configuration. In this section we will explain how to fine tune these options.</source>
          <target state="translated">&lt;code&gt;optimization&lt;/code&gt; 및 &lt;code&gt;sourceMap&lt;/code&gt; 의 옵션 빌더 브라우저는 부울 이상의 세분화 된 구성을위한 객체가 될 수 있습니다. 이 섹션에서는 이러한 옵션을 미세 조정하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="43a7d99c46c52d5a3ee1b0e0e32dce7d1e549f63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;optimization&lt;/code&gt; and &lt;code&gt;sourceMap&lt;/code&gt; command options are simple Boolean flags. You can supply an object as a configuration value for either of these to provide more detailed instruction.</source>
          <target state="translated">&lt;code&gt;optimization&lt;/code&gt; 및 &lt;code&gt;sourceMap&lt;/code&gt; 의 명령 옵션은 간단한 부울 플래그입니다. 보다 자세한 지침을 제공하기 위해 이들 중 하나에 대한 구성 값으로 객체를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06d19a4a4d049d946458a3b228278d9b59f8eeb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;optimization&lt;/code&gt; option applies to scripts, styles and fonts. You can supply a value such as the following to apply optimization to one or the other:</source>
          <target state="translated">&lt;code&gt;optimization&lt;/code&gt; 옵션은 스크립트, 스타일 및 글꼴에 적용됩니다. 다음과 같은 값을 제공하여 둘 중 하나에 최적화를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68652e30cdd6035a39eaf435363a84fbca02e905" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options.path&lt;/code&gt; determines where the schematic template files are moved to once the schematic is applied.</source>
          <target state="translated">&lt;code&gt;options.path&lt;/code&gt; 는 개략적 템플릿 파일이 회로도가 적용되면 이동되는 위치를 결정한다.</target>
        </trans-unit>
        <trans-unit id="ed45fc4fb586f918cbf123cc6aaa8ac13b46fa2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;outDir&lt;/code&gt; maps to the library's output folder. By default, this is the &lt;code&gt;dist/my-lib&lt;/code&gt; folder at the root of your workspace.</source>
          <target state="translated">&lt;code&gt;outDir&lt;/code&gt; 라이브러리의 출력 폴더에 매핑됩니다. 기본적으로 이것은 작업 공간의 루트에 있는 &lt;code&gt;dist/my-lib&lt;/code&gt; 폴더입니다.</target>
        </trans-unit>
        <trans-unit id="5736e34f4ac101b818064275d103c11a91f96223" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;outputs&lt;/code&gt; property defines a set of &lt;code&gt;directiveProperty&lt;/code&gt; to &lt;code&gt;bindingProperty&lt;/code&gt; configuration:</source>
          <target state="translated">&lt;code&gt;outputs&lt;/code&gt; 속성들의 세트를 정의 &lt;code&gt;directiveProperty&lt;/code&gt; 에 &lt;code&gt;bindingProperty&lt;/code&gt; 의 구성 :</target>
        </trans-unit>
        <trans-unit id="b99b37eb83ce95780d266653fe93326c72cd1e1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p span&lt;/code&gt; style, intended for use elsewhere, was inadvertently applied here.</source>
          <target state="translated">&lt;code&gt;p span&lt;/code&gt; 다른 곳에서 사용하기위한 스타일, 실수로 여기에 적용되었다.</target>
        </trans-unit>
        <trans-unit id="e3c80bfbed5536effebdc8bdda5d90d25e98e9b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;package.json&lt;/code&gt; for a new Angular workspace installs the &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; package, which polyfills missing features for several popular browser.</source>
          <target state="translated">&lt;code&gt;package.json&lt;/code&gt; 새로운 각도 작업 공간은 설치 &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;코어 JS의&lt;/a&gt; polyfills 여러 인기있는 브라우저 기능이없는 패키지를.</target>
        </trans-unit>
        <trans-unit id="cc416378bdfc224793314f87016f1f4a90bf5826" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;package.json&lt;/code&gt; is organized into two groups of packages:</source>
          <target state="translated">&lt;code&gt;package.json&lt;/code&gt; 는 패키지의 두 가지로 구성되어 있습니다 :</target>
        </trans-unit>
        <trans-unit id="60d300e5b06b4652df36c13692d39407023ed327" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;paramMap&lt;/code&gt; is a dictionary of route parameter values extracted from the URL. The &lt;code&gt;&quot;id&quot;&lt;/code&gt; key returns the &lt;code&gt;id&lt;/code&gt; of the hero to fetch.</source>
          <target state="translated">&lt;code&gt;paramMap&lt;/code&gt; 는 URL을 추출 경로 파라미터 값들의 사전이다. &lt;code&gt;&quot;id&quot;&lt;/code&gt; 키 반환 &lt;code&gt;id&lt;/code&gt; 영웅의 페치합니다.</target>
        </trans-unit>
        <trans-unit id="313f8e71b2fb55a766d7a1e9c76622430cf5aaac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;paramMap&lt;/code&gt; processing is a bit tricky. When the map changes, you &lt;code&gt;get()&lt;/code&gt; the &lt;code&gt;id&lt;/code&gt; parameter from the changed parameters.</source>
          <target state="translated">&lt;code&gt;paramMap&lt;/code&gt; 의 처리는 비트 까다 롭다. 지도 변경, 당신은 때 &lt;code&gt;get()&lt;/code&gt; &lt;code&gt;id&lt;/code&gt; 변경된 매개 변수에서 매개 변수를.</target>
        </trans-unit>
        <trans-unit id="14ce2d0b2c2b8d442f75a2419ce9d4c897bbebc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parentItem&lt;/code&gt; in &lt;code&gt;AppComponent&lt;/code&gt; is a string, which means that the expression, &lt;code&gt;parentItem&lt;/code&gt; within &lt;code&gt;[childItem]=&quot;parentItem&quot;&lt;/code&gt;, evaluates to a string.</source>
          <target state="translated">&lt;code&gt;parentItem&lt;/code&gt; 에 &lt;code&gt;AppComponent&lt;/code&gt; 는 문자열 인 수단 식, 즉 &lt;code&gt;parentItem&lt;/code&gt; 내의 &lt;code&gt;[childItem]=&quot;parentItem&quot;&lt;/code&gt; 문자열로, 평가한다.</target>
        </trans-unit>
        <trans-unit id="83acc7ba56c6203cb3caa1c7d75835b469828f37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;component&lt;/code&gt; properties should be familiar. There's a new property, &lt;code&gt;outlet&lt;/code&gt;, set to &lt;code&gt;'popup'&lt;/code&gt;. This route now targets the popup outlet and the &lt;code&gt;ComposeMessageComponent&lt;/code&gt; will display there.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 및 &lt;code&gt;component&lt;/code&gt; 특성을 잘 알고 있어야합니다. 새로운 속성 인 &lt;code&gt;outlet&lt;/code&gt; 이 &lt;code&gt;'popup'&lt;/code&gt; 으로 설정되었습니다 . 이 경로는 이제 팝업 콘센트를 대상으로하며 &lt;code&gt;ComposeMessageComponent&lt;/code&gt; 가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1547fce0daf2ce9593510cb48ca8ac8ab2ef2d5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; here is set to an empty string because the path in &lt;code&gt;AppRoutingModule&lt;/code&gt; is already set to &lt;code&gt;customers&lt;/code&gt;, so this route in the &lt;code&gt;CustomersRoutingModule&lt;/code&gt;, is already within the &lt;code&gt;customers&lt;/code&gt; context. Every route in this routing module is a child route.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 의 경로 때문에 여기에 빈 문자열로 설정 &lt;code&gt;AppRoutingModule&lt;/code&gt; 이 이미 설정되어 &lt;code&gt;customers&lt;/code&gt; 에서이 경로, 그래서 &lt;code&gt;CustomersRoutingModule&lt;/code&gt; 이 는 내 이미 &lt;code&gt;customers&lt;/code&gt; 컨텍스트. 이 라우팅 모듈의 모든 경로는 하위 경로입니다.</target>
        </trans-unit>
        <trans-unit id="30a8ecd4a8783bad25fd9c461e2beeda627c4a13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;path&lt;/code&gt; option in the schematic's schema is substituted by default with the current working directory. If the &lt;code&gt;path&lt;/code&gt; is not defined, use the &lt;code&gt;sourceRoot&lt;/code&gt; from the project configuration along with the &lt;code&gt;projectType&lt;/code&gt;.</source>
          <target state="translated">회로도 스키마 의 &lt;code&gt;path&lt;/code&gt; 옵션은 기본적으로 현재 작업 디렉토리로 대체됩니다. 는 IF &lt;code&gt;path&lt;/code&gt; 정의되지 않은, 사용 &lt;code&gt;sourceRoot&lt;/code&gt; 와 함께 프로젝트 구성에서을 &lt;code&gt;projectType&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62481be786da43da1d0f9f8e1f68dbc62d533af9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pathRewrite&lt;/code&gt; proxy configuration option lets you rewrite the URL path at run time. For example, you can specify the following &lt;code&gt;pathRewrite&lt;/code&gt; value to the proxy configuration to remove &quot;api&quot; from the end of a path.</source>
          <target state="translated">&lt;code&gt;pathRewrite&lt;/code&gt; 의 프록시 구성 옵션은 실행 시간에 URL 경로를 재 작성 할 수 있습니다. 예를 들어, 경로 끝에서 &quot;api&quot;를 제거하기 위해 프록시 구성에 다음 &lt;code&gt;pathRewrite&lt;/code&gt; 값을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1785d4a3a5bede37ebbe1b406daf1b64048c32dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pipe()&lt;/code&gt; function is also a method on the RxJS &lt;code&gt;Observable&lt;/code&gt;, so you use this shorter form to define the same operation:</source>
          <target state="translated">&lt;code&gt;pipe()&lt;/code&gt; 함수는도 RxJS의 방법으로 &lt;code&gt;Observable&lt;/code&gt; 동일한 동작을 정의하기 위해 더 짧은 형태를 사용하므로 :</target>
        </trans-unit>
        <trans-unit id="d7e7c8187c4be0da91d7134cd8b83260a33409a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postbuild&lt;/code&gt; script copies the schematic files after the &lt;code&gt;build&lt;/code&gt; script completes.</source>
          <target state="translated">&lt;code&gt;postbuild&lt;/code&gt; 의 애프터 스크립트를 복사 회로도 파일을 &lt;code&gt;build&lt;/code&gt; 스크립트 완료.</target>
        </trans-unit>
        <trans-unit id="83f85d6ad4060b053a8ab58108f8c7af7c260fb2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;postinstall&lt;/code&gt; script will run on every installation of &lt;code&gt;node_modules&lt;/code&gt;, including those performed by &lt;code&gt;ng update&lt;/code&gt; and &lt;code&gt;ng add&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;postinstall&lt;/code&gt; 스크립트의 모든 설치에서 실행됩니다 &lt;code&gt;node_modules&lt;/code&gt; 에 의해 수행을 포함, &lt;code&gt;ng update&lt;/code&gt; 및 &lt;code&gt;ng add&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d9a176b63dc85b5e46e29f971649dca0d030c2b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;power-booster.component.ts&lt;/code&gt; component demonstrates how to use the pipe, specifying a value (&lt;code&gt;2&lt;/code&gt;) and the exponent parameter (&lt;code&gt;10&lt;/code&gt;). Figure 2 shows the output.</source>
          <target state="translated">&lt;code&gt;power-booster.component.ts&lt;/code&gt; 성분 값 (지정 파이프를 사용하는 방법을 보여 &lt;code&gt;2&lt;/code&gt; )와 지수 파라미터 ( &lt;code&gt;10&lt;/code&gt; ). 그림 2는 출력을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="40f54f6369cce6d94790b617c953d163b4600e42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;provide&lt;/code&gt; property holds the &lt;a href=&quot;dependency-injection#token&quot;&gt;token&lt;/a&gt; that serves as the key for both locating a dependency value and configuring the injector.</source>
          <target state="translated">가 &lt;code&gt;provide&lt;/code&gt; 속성은 보유 &lt;a href=&quot;dependency-injection#token&quot;&gt;토큰&lt;/a&gt; 모두 의존 값을 찾는 인젝터를 구성하기위한 키로서 기능한다.</target>
        </trans-unit>
        <trans-unit id="a6a8cd1e8964b491959fc9628f591fbf11bb2fd0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;providers&lt;/code&gt; array</source>
          <target state="translated">&lt;code&gt;providers&lt;/code&gt; 배열</target>
        </trans-unit>
        <trans-unit id="eb886a89d7d45147e0470f5ef761dd6a685b7e73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;providers&lt;/code&gt; array shows how you might use the different provider-definition keys; &lt;code&gt;&lt;a href=&quot;../api/core/valuesansprovider#useValue&quot;&gt;useValue&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;useClass&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/core/existingsansprovider#useExisting&quot;&gt;useExisting&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../api/core/factorysansprovider#useFactory&quot;&gt;useFactory&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;providers&lt;/code&gt; 는 다른 공급자 정의 키를 사용하는 방법 배열을 보여줍니다; &lt;code&gt;&lt;a href=&quot;../api/core/valuesansprovider#useValue&quot;&gt;useValue&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;useClass&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/core/existingsansprovider#useExisting&quot;&gt;useExisting&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../api/core/factorysansprovider#useFactory&quot;&gt;useFactory&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d98bd1406a5dd084ef8572318787a9a5c06f284d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;providers&lt;/code&gt; array shows how you might use the different provider-definition keys; &lt;code&gt;useValue&lt;/code&gt;, &lt;code&gt;useClass&lt;/code&gt;, &lt;code&gt;useExisting&lt;/code&gt;, or &lt;code&gt;useFactory&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;providers&lt;/code&gt; 는 다른 공급자 정의 키를 사용하는 방법 배열을 보여줍니다; &lt;code&gt;useValue&lt;/code&gt; , &lt;code&gt;useClass&lt;/code&gt; , &lt;code&gt;useExisting&lt;/code&gt; 또는 &lt;code&gt;useFactory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="378b927aad6f36c10f879731b976a6e0020b6868" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;providers&lt;/code&gt; options configure the NgModule's injector to provide localization dependencies to members.</source>
          <target state="translated">&lt;code&gt;providers&lt;/code&gt; 옵션은 회원들에게 현지화 종속성을 제공하는 NgModule의 인젝터를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="a2194540daca9db4bdf4841e3d15d29a4b883bcf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;queryParamsHandling&lt;/code&gt; feature also provides a &lt;code&gt;merge&lt;/code&gt; option, which preserves and combines the current query parameters with any provided query parameters when navigating.</source>
          <target state="translated">&lt;code&gt;queryParamsHandling&lt;/code&gt; 의 기능도 제공 &lt;code&gt;merge&lt;/code&gt; 옵션, 보존 및 탐색 어떠한 제공 쿼리 매개 변수를 사용하여 현재 쿼리 매개 변수를 결합합니다.</target>
        </trans-unit>
        <trans-unit id="7a915b7bcf4b039c4d484c3a91457d8dafdb5258" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;queryParamsHandling&lt;/code&gt; feature also provides a &lt;code&gt;merge&lt;/code&gt; option, which will preserve and combine the current query parameters with any provided query parameters when navigating.</source>
          <target state="translated">&lt;code&gt;queryParamsHandling&lt;/code&gt; 의 기능도 제공 &lt;code&gt;merge&lt;/code&gt; 탐색 할 때 어떤 제공 쿼리 매개 변수와 함께 현재 쿼리 매개 변수를 보존하고 결합합니다 옵션을.</target>
        </trans-unit>
        <trans-unit id="4110d1ad5861201ed643c3622878a03e4b882b2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;readonly&lt;/code&gt; assignment guard can't prevent deep updates and, in particular, it can't prevent you from modifying a property of a request body object.</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; 할당 가드 특히, 그것은 요청 본문 개체의 속성을 수정하는 것을 방지 할 수 없습니다, 깊은 업데이트를 방지 할 수 없다.</target>
        </trans-unit>
        <trans-unit id="4552a998362626aab9347940b3a60b9130370b8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ready&lt;/code&gt; callback function is invoked inside the Angular zone, therefore it does not require a call to &lt;code&gt;$apply()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ready&lt;/code&gt; 콜백 함수 따라서이에 대한 호출이 필요하지 않습니다, 각 영역 내에서 호출 &lt;code&gt;$apply()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9b29f091624bf252b25bbd274d2afa6a162bf2b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;region&lt;/code&gt; value, &lt;code&gt;&quot;class&quot;&lt;/code&gt;, is the name of the &lt;code&gt;#docregion&lt;/code&gt; in the source file. Confirm that by looking at &lt;code&gt;content/examples/docs-style-guide/src/app/app.module.ts&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;region&lt;/code&gt; 가치, &lt;code&gt;&quot;class&quot;&lt;/code&gt; ,의 이름입니다 &lt;code&gt;#docregion&lt;/code&gt; 소스 파일입니다. 확인이보고에 의해 &lt;code&gt;content/examples/docs-style-guide/src/app/app.module.ts&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da87e99d42c13b635059d2acd261bddbab7185a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;required&lt;/code&gt; attribute is still present. While it's not necessary for validation purposes, you may want to keep it in your template for CSS styling or accessibility reasons.</source>
          <target state="translated">&lt;code&gt;required&lt;/code&gt; 속성은 여전히 존재합니다. 유효성 검사 목적으로 필요하지는 않지만 CSS 스타일 또는 액세스 가능성을 위해 템플릿에 유지해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39107654150053cf81cb764fb0b18adc5eabcb3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;responseType&lt;/code&gt; value determines how a successful response body is parsed.</source>
          <target state="translated">&lt;code&gt;responseType&lt;/code&gt; 의 값은 성공적으로 응답 본문은 구문 분석 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="a430ac49ac8d8d424bc937de23c156f47d8f9114" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rootDir&lt;/code&gt; specifies that your &lt;code&gt;schematics/&lt;/code&gt; folder contains the input files to be compiled.</source>
          <target state="translated">&lt;code&gt;rootDir&lt;/code&gt; 당신의 것을 지정 &lt;code&gt;schematics/&lt;/code&gt; 폴더가 입력 파일이 포함되어 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="b0360411d35f5172538620aa73c42c2a60819e07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;route.snapshot&lt;/code&gt; is a static image of the route information shortly after the component was created.</source>
          <target state="translated">&lt;code&gt;route.snapshot&lt;/code&gt; 는 컴포넌트가 생성 된 직후 경로 정보의 정지 화상이다.</target>
        </trans-unit>
        <trans-unit id="98c2a703b9341731e25cca1e1ac8295d6ba802c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;route.snapshot&lt;/code&gt; provides the initial value of the route parameter map. You can access the parameters directly without subscribing or adding observable operators. It's much simpler to write and read:</source>
          <target state="translated">&lt;code&gt;route.snapshot&lt;/code&gt; 는 경로 매개 변수지도의 초기 값을 제공합니다. 관찰 가능한 연산자를 구독하거나 추가하지 않고도 매개 변수에 직접 액세스 할 수 있습니다. 읽고 쓰는 것이 훨씬 간단합니다.</target>
        </trans-unit>
        <trans-unit id="8953d9203d44b502aeb08833c884cd6a43672586" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;schematics&lt;/code&gt; object describes the named schematics that are part of this collection.</source>
          <target state="translated">&lt;code&gt;schematics&lt;/code&gt; 객체는이 컬렉션의 일부 명명 된 회로도를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="19be2e2a404eeed259e2935213f5db1066e7e258" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;schematics&lt;/code&gt; property lists named schematics that belong to this collection. Each schematic has a plain-text description, and points to the generated entry function in the main file.</source>
          <target state="translated">&lt;code&gt;schematics&lt;/code&gt; 속성 목록이 컬렉션에 속하는 회로도를 지명했다. 각 회로도에는 일반 텍스트 설명이 있으며 기본 파일에서 생성 된 입력 함수를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="94130bec33e1eb60cd02513d2b2f41b947b417a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scope.$apply()&lt;/code&gt; is how AngularJS detects changes and updates data bindings. After every event that occurs, &lt;code&gt;scope.$apply()&lt;/code&gt; gets called. This is done either automatically by the framework, or manually by you.</source>
          <target state="translated">&lt;code&gt;scope.$apply()&lt;/code&gt; 방법 AngularJS와의 검출 변경 및 업데이트 데이터 바인딩이다. 발생하는 모든 이벤트 후에 &lt;code&gt;scope.$apply()&lt;/code&gt; 가 호출됩니다. 이 작업은 프레임 워크에서 자동으로 수행하거나 사용자가 수동으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="3c8fe632791fdc7a518369563a44ed949ab9ffe7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;searchTerms&lt;/code&gt; RxJS subject</source>
          <target state="translated">&lt;code&gt;searchTerms&lt;/code&gt; RxJS 대상</target>
        </trans-unit>
        <trans-unit id="8c1b03055bc764bd760bdc91ac7b76ad9b62de32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;searchTerms&lt;/code&gt; property is an RxJS &lt;code&gt;Subject&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;searchTerms&lt;/code&gt; 속성은 RxJS의입니다 &lt;code&gt;Subject&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4280fbbc633dd4cab834f13d28eb3c3882a952a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;searchText$&lt;/code&gt; is the sequence of search-box values coming from the user. It's defined as an RxJS &lt;code&gt;Subject&lt;/code&gt;, which means it is a multicasting &lt;code&gt;Observable&lt;/code&gt; that can also emit values for itself by calling &lt;code&gt;next(value)&lt;/code&gt;, as happens in the &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/%24locationshim#search&quot;&gt;search()&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;searchText$&lt;/code&gt; 사용자로부터 들어오는 검색 창 값의 순서입니다. RxJS &lt;code&gt;Subject&lt;/code&gt; 로 정의됩니다. 이것은 멀티 캐스팅 &lt;code&gt;Observable&lt;/code&gt; 이므로 &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/%24locationshim#search&quot;&gt;search()&lt;/a&gt;&lt;/code&gt; 메소드 에서와 같이 &lt;code&gt;next(value)&lt;/code&gt; 를 호출하여 자체 값을 생성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6916edc889efd59e821e9e69f594ee4b8ec65909" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;searchText$&lt;/code&gt; is the sequence of search-box values coming from the user. It's defined as an RxJS &lt;code&gt;Subject&lt;/code&gt;, which means it is a multicasting &lt;code&gt;Observable&lt;/code&gt; that can also emit values for itself by calling &lt;code&gt;next(value)&lt;/code&gt;, as happens in the &lt;code&gt;search()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;searchText$&lt;/code&gt; 사용자로부터 들어오는 검색 창 값의 순서입니다. RxJS &lt;code&gt;Subject&lt;/code&gt; 로 정의됩니다. 이는 &lt;code&gt;search()&lt;/code&gt; 메서드 에서 발생하는 것처럼 &lt;code&gt;next(value)&lt;/code&gt; 를 호출하여 자체 값을 내보낼 수도 있는 멀티 캐스팅 &lt;code&gt;Observable&lt;/code&gt; 임을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="76ad0c5b8da43c7b6de6250e8195a93c15204d6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;select&lt;/code&gt; clause, similar to the &lt;code&gt;plural&lt;/code&gt; clause, marks choices for alternate text based on your defined string values. For example, the following clause in the component template binds to the component's &lt;code&gt;gender&lt;/code&gt; property, which outputs one of the following string values: &quot;male&quot;, &quot;female&quot; or &quot;other&quot;. The clause maps those values to the appropriate translations:</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 받는 유사한 조항, &lt;code&gt;plural&lt;/code&gt; 절, 정의 된 문자열 값에 따라 대체 텍스트 마크 선택. 예를 들어 구성 요소 템플릿의 다음 절은 구성 요소의 &lt;code&gt;gender&lt;/code&gt; 속성에 바인딩되어 &quot;male&quot;, &quot;female&quot;또는 &quot;other&quot;문자열 값 중 하나를 출력합니다. 이 절은 해당 값을 적절한 번역에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="f1ef4e3c3557c47427af418f305913be1f3a5488" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;selector&lt;/code&gt; attribute is a CSS selector that defines where on the page the component should go. In AngularJS you do matching based on component names, but in Angular you have these explicit selectors. This one will match elements with the name &lt;code&gt;phone-list&lt;/code&gt;, just like the AngularJS version did.</source>
          <target state="translated">&lt;code&gt;selector&lt;/code&gt; 속성은 페이지의 구성 요소가 가야 위치를 정의하는 CSS 선택기입니다. AngularJS에서는 구성 요소 이름을 기준으로 일치하지만 Angular에는 이러한 명시 적 선택기가 있습니다. 이것은 AngularJS 버전과 마찬가지로 이름이 &lt;code&gt;phone-list&lt;/code&gt; 인 요소와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="11d9b9f6d8cdb36365862fee5c7e6c716ebb3596" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;selector&lt;/code&gt; identifies the component. The selector is the name you give the Angular component when it is rendered as an HTML element on the page. By convention, Angular component selectors begin with the prefix &lt;code&gt;app-&lt;/code&gt;, followed by the component name.</source>
          <target state="translated">&lt;code&gt;selector&lt;/code&gt; 구성 요소를 식별한다. 선택기는 Angular 구성 요소가 페이지에서 HTML 요소로 렌더링 될 때 제공하는 이름입니다. 일반적으로 Angular 구성 요소 선택기는 접두사 &lt;code&gt;app-&lt;/code&gt; 으로 시작하고 그 뒤에 구성 요소 이름 이옵니다 .</target>
        </trans-unit>
        <trans-unit id="263b313ccd333a2262c31082a98e1e63586d8640" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sendRequest&lt;/code&gt; function creates a &lt;a href=&quot;http#immutability&quot;&gt;request clone&lt;/a&gt; without headers because the npm api forbids them.</source>
          <target state="translated">&lt;code&gt;sendRequest&lt;/code&gt; 함수는 생성 &lt;a href=&quot;http#immutability&quot;&gt;요청 복제&lt;/a&gt; 고궁 박물원 API는이를 금지하기 때문에 헤더없이.</target>
        </trans-unit>
        <trans-unit id="98e3960b4dadf77856e4c0c4890e9f3074235a7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setup()&lt;/code&gt; function returns an object literal with the variables, such as &lt;code&gt;masterService&lt;/code&gt;, that a test might reference. You don't define &lt;em&gt;semi-global&lt;/em&gt; variables (e.g., &lt;code&gt;let masterService: MasterService&lt;/code&gt;) in the body of the &lt;code&gt;describe()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;setup()&lt;/code&gt; 함수는 다음과 같은 변수를 가진 객체 리터럴 반환 &lt;code&gt;masterService&lt;/code&gt; 를 테스트가 참조 할 수 있음. &lt;code&gt;describe()&lt;/code&gt; 본문에 &lt;em&gt;반 전역&lt;/em&gt; 변수 (예 : &lt;code&gt;let masterService: MasterService&lt;/code&gt; )를 정의하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7e7f39203bb8b9c13e311f0f854788f391b2276e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sizerComponent&lt;/code&gt; template has two buttons that each bind the click event to the &lt;code&gt;inc()&lt;/code&gt; and &lt;code&gt;dec()&lt;/code&gt; methods. When the user clicks one of the buttons, the &lt;code&gt;sizerComponent&lt;/code&gt; calls the corresponding method. Both methods, &lt;code&gt;inc()&lt;/code&gt; and &lt;code&gt;dec()&lt;/code&gt;, call the &lt;code&gt;resize()&lt;/code&gt; method with a &lt;code&gt;+1&lt;/code&gt; or &lt;code&gt;-1&lt;/code&gt;, which in turn raises the &lt;code&gt;sizeChange&lt;/code&gt; event with the new size value.</source>
          <target state="translated">&lt;code&gt;sizerComponent&lt;/code&gt; 의 템플릿은 두 개의 버튼을 가지고 각 바인드에 클릭 이벤트 &lt;code&gt;inc()&lt;/code&gt; 및 &lt;code&gt;dec()&lt;/code&gt; 방법. 사용자가 버튼 중 하나를 클릭하면 &lt;code&gt;sizerComponent&lt;/code&gt; 가 해당 메서드를 호출합니다. 두 방법, &lt;code&gt;inc()&lt;/code&gt; 및 &lt;code&gt;dec()&lt;/code&gt; 호출 &lt;code&gt;resize()&lt;/code&gt; A의 방법 &lt;code&gt;+1&lt;/code&gt; 또는 &lt;code&gt;-1&lt;/code&gt; , 차례로 상승 &lt;code&gt;sizeChange&lt;/code&gt; 의 새로운 크기 값 이벤트.</target>
        </trans-unit>
        <trans-unit id="6e385289300fdc537b82f3617d6eaaaf051383e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;source-map-explorer&lt;/code&gt; analyzes the source map generated with the bundle and draws a map of all dependencies, showing exactly which classes are included in the bundle.</source>
          <target state="translated">&lt;code&gt;source-map-explorer&lt;/code&gt; 클래스 번들에 포함 된 정확히 나타내는 번들 생성 소스 맵을 분석하고 모든 종속성의지도를 그린다.</target>
        </trans-unit>
        <trans-unit id="ccf897a30f41d2173f77117dd5c06f669759c5a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sourceMap&lt;/code&gt; option applies for both scripts and styles. You can also choose to output hidden source maps, or resolve vendor package source maps:</source>
          <target state="translated">&lt;code&gt;sourceMap&lt;/code&gt; 의 옵션은 스크립트와 스타일 모두에 적용됩니다. 숨겨진 소스 맵을 출력하거나 공급 업체 패키지 소스 맵을 해결하도록 선택할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fb8a6726597db869ba6708ca7b5b6a4986d3a3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src/app/app.module.ts&lt;/code&gt; file has a good example of a nested region.</source>
          <target state="translated">&lt;code&gt;src/app/app.module.ts&lt;/code&gt; 파일은 중첩 된 지역의 좋은 예제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="202bb3ece99aa9f958aaeb45fbc17d65040b889f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src/main.ts&lt;/code&gt; is a simple example of a file with a single &lt;em&gt;#docregion&lt;/em&gt; at the top of the file.</source>
          <target state="translated">&lt;code&gt;src/main.ts&lt;/code&gt; 하나의 파일의 간단한 예입니다 &lt;em&gt;#docregion&lt;/em&gt; 파일의 맨 위에.</target>
        </trans-unit>
        <trans-unit id="c4ebea686b86ed2e39ae542821868ac054705e37" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;src/ngsw-config.json&lt;/code&gt; configuration file specifies which files and data URLs the Angular service worker should cache and how it should update the cached files and data. The &lt;a href=&quot;cli&quot;&gt;Angular CLI&lt;/a&gt; processes the configuration file during &lt;code&gt;ng build --prod&lt;/code&gt;. Manually, you can process it with the &lt;code&gt;ngsw-config&lt;/code&gt; tool:</source>
          <target state="translated">&lt;code&gt;src/ngsw-config.json&lt;/code&gt; 구성 파일을 지정하는 파일과 데이터 URL을 각 서비스 노동자는 캐시해야하며이 캐시 파일과 데이터를 업데이트하는 방법. &lt;a href=&quot;cli&quot;&gt;각도 CLI는&lt;/a&gt; 동안 구성 파일 처리 &lt;code&gt;ng build --prod&lt;/code&gt; . &lt;code&gt;ngsw-config&lt;/code&gt; 도구를 사용하여 수동으로 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1edd2e05f84370637e39aec6246e210e01c09b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;styles&lt;/code&gt; property takes an array of strings that contain the CSS rule declarations.</source>
          <target state="translated">&lt;code&gt;styles&lt;/code&gt; 속성은 CSS 규칙 선언을 포함하는 문자열 배열을합니다.</target>
        </trans-unit>
        <trans-unit id="77201400a17a80e45079ecd99dd04f439106322c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;submit&lt;/code&gt; event is emitted by the &lt;code&gt;form&lt;/code&gt; tag using the native DOM event. You trigger the event by clicking a button with &lt;code&gt;submit&lt;/code&gt; type. This allows the user to press the &lt;strong&gt;Enter&lt;/strong&gt; key to submit the completed form.</source>
          <target state="translated">&lt;code&gt;submit&lt;/code&gt; 이벤트는에 의해 방출되는 &lt;code&gt;form&lt;/code&gt; 기본 DOM 이벤트를 사용하여 태그입니다. &lt;code&gt;submit&lt;/code&gt; 유형이 있는 단추를 클릭하여 이벤트를 트리거하십시오 . 이를 통해 사용자는 &lt;strong&gt;Enter&lt;/strong&gt; 키를 눌러 완성 된 양식을 제출할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="251e43a05f33d8e9cc990fef4b501d01abd583d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subscribe()&lt;/code&gt; method takes a JavaScript object (called an &lt;a href=&quot;glossary#observer&quot;&gt;observer&lt;/a&gt;) with up to three callbacks, one for each type of notification that an observable can deliver:</source>
          <target state="translated">은 &lt;code&gt;subscribe()&lt;/code&gt; 메소드가 (AN라는 자바 스크립트 객체 소요 &lt;a href=&quot;glossary#observer&quot;&gt;관찰자&lt;/a&gt; 세 콜백, 관찰을 제공 할 수 있음을 통지의 각 유형에 대해 하나 위로를)</target>
        </trans-unit>
        <trans-unit id="5a5783ba2b920d9635fe9461bd4e46971ccf2eb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subscribe()&lt;/code&gt; method takes a success (&lt;code&gt;next&lt;/code&gt;) and fail (&lt;code&gt;error&lt;/code&gt;) callback. Make sure you provide &lt;em&gt;both&lt;/em&gt; callbacks so that you capture errors. Neglecting to do so produces an asynchronous uncaught observable error that the test runner will likely attribute to a completely different test.</source>
          <target state="translated">&lt;code&gt;subscribe()&lt;/code&gt; 메소드는 성공 (소요 &lt;code&gt;next&lt;/code&gt; )과 (실패 &lt;code&gt;error&lt;/code&gt; ) 콜백을. 오류를 캡처 할 수 있도록 &lt;em&gt;두&lt;/em&gt; 콜백을 &lt;em&gt;모두&lt;/em&gt; 제공하십시오 . 그렇게하지 않으면 테스트 실행기가 완전히 다른 테스트를 유발할 수있는 비동기 잡힐 수없는 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8791607c61c0f05713a0307ef28d52145a479306" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;switchMap()&lt;/code&gt; operator has three important characteristics.</source>
          <target state="translated">&lt;code&gt;switchMap()&lt;/code&gt; 연산자는 세 가지 중요한 특성을 갖는다.</target>
        </trans-unit>
        <trans-unit id="86121707cc28f8a72bb7aa24c90f97195ae22d31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;switchMap()&lt;/code&gt; operator takes a function argument that returns an &lt;code&gt;Observable&lt;/code&gt;. In the example, &lt;code&gt;PackageSearchService.search&lt;/code&gt; returns an &lt;code&gt;Observable&lt;/code&gt;, as other data service methods do. If a previous search request is still in-flight (as when the network connection is poor), the operator cancels that request and sends a new one.</source>
          <target state="translated">&lt;code&gt;switchMap()&lt;/code&gt; 연산자는 반환하는 함수 인수 얻어 &lt;code&gt;Observable&lt;/code&gt; . 이 예에서 &lt;code&gt;PackageSearchService.search&lt;/code&gt; 는 다른 데이터 서비스 메서드와 마찬가지로 &lt;code&gt;Observable&lt;/code&gt; 을 반환합니다 . 이전 검색 요청이 여전히 진행중인 경우 (네트워크 연결 상태가 좋지 않은 경우) 운영자는 해당 요청을 취소하고 새 요청을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="35e89baf59c798f66de4b3a1d896130098da7dea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;switchMap&lt;/code&gt; operator also cancels previous in-flight requests. If the user re-navigates to this route with a new &lt;code&gt;id&lt;/code&gt; while the &lt;code&gt;HeroService&lt;/code&gt; is still retrieving the old &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;switchMap&lt;/code&gt; discards that old request and returns the hero for the new &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;switchMap&lt;/code&gt; 의 운영자는 이전 기내 요청을 취소합니다. 만약 새로운이 경로에 대한 사용자 재 탐색합니다 &lt;code&gt;id&lt;/code&gt; 그동안 &lt;code&gt;HeroService&lt;/code&gt; 는 여전히 이전 검색하는 &lt;code&gt;id&lt;/code&gt; , &lt;code&gt;switchMap&lt;/code&gt; 의 폐기 된 요청 및 반환을위한 새로운 영웅이 &lt;code&gt;id&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7be7153b64c1432ee8505e6e1853e08c4af23b1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;switchMap&lt;/code&gt; operator does two things. It flattens the &lt;code&gt;Observable&amp;lt;Hero&amp;gt;&lt;/code&gt; that &lt;code&gt;HeroService&lt;/code&gt; returns and cancels previous pending requests. If the user re-navigates to this route with a new &lt;code&gt;id&lt;/code&gt; while the &lt;code&gt;HeroService&lt;/code&gt; is still retrieving the old &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;switchMap&lt;/code&gt; discards that old request and returns the hero for the new &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;switchMap&lt;/code&gt; 의 연산자는 두 가지 작업을 수행합니다. &lt;code&gt;HeroService&lt;/code&gt; 가 반환하고 이전 보류중인 요청을 취소 하는 &lt;code&gt;Observable&amp;lt;Hero&amp;gt;&lt;/code&gt; 를 평면화 합니다. 만약 새로운이 경로에 대한 사용자 재 탐색합니다 &lt;code&gt;id&lt;/code&gt; 그동안 &lt;code&gt;HeroService&lt;/code&gt; 는 여전히 이전 검색하는 &lt;code&gt;id&lt;/code&gt; , &lt;code&gt;switchMap&lt;/code&gt; 의 폐기 된 요청 및 반환을위한 새로운 영웅이 &lt;code&gt;id&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f92ffc98bcb36aa1c882663131002f05e065a2c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;templateUrl&lt;/code&gt; property points to a separate file for the template HTML.</source>
          <target state="translated">&lt;code&gt;templateUrl&lt;/code&gt; 의 템플릿 HTML에 대한 별도의 파일 속성을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="e7b301cb1df5e9071174c9086184fff5dcc8819a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;thresholds&lt;/code&gt; property causes the tool to enforce a minimum of 80% code coverage when the unit tests are run in the project.</source>
          <target state="translated">&lt;code&gt;thresholds&lt;/code&gt; 속성은 단위 테스트는 프로젝트에서 실행하는 경우 80 %의 코드 커버리지의 최소 시행 할 수있는 도구가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f998cca1a6cbbd1bfbc79167fe0b64cfb77fb4ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timings&lt;/code&gt; parameter takes a string defined in three parts.</source>
          <target state="translated">&lt;code&gt;timings&lt;/code&gt; 매개 변수는 세 부분으로 정의 된 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="83fc825d674ac468c5e028de026f937ce6df1287" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transform&lt;/code&gt; method is essential to a pipe. The &lt;code&gt;&lt;a href=&quot;../api/core/pipetransform&quot;&gt;PipeTransform&lt;/a&gt;&lt;/code&gt;&lt;em&gt;interface&lt;/em&gt; defines that method and guides both tooling and the compiler. Technically, it's optional; Angular looks for and executes the &lt;code&gt;transform&lt;/code&gt; method regardless.</source>
          <target state="translated">&lt;code&gt;transform&lt;/code&gt; 방법은 파이프에 필수적이다. &lt;code&gt;&lt;a href=&quot;../api/core/pipetransform&quot;&gt;PipeTransform&lt;/a&gt;&lt;/code&gt; 의&lt;em&gt; 인터페이스&lt;/em&gt; 를 정의하는 방법과 가이드 툴과 컴파일러 모두 그. 기술적으로는 선택 사항입니다. Angular는 &lt;code&gt;transform&lt;/code&gt; 방법을 찾고 상관없이 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="970c3e531a96b857b5407a5716c7ae81e934f401" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tsconfig.json&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="1497abe2d60e017e56bc96d27cab2a044a44f729" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;url()&lt;/code&gt; method reads source files from your filesystem, relative to the schematic.</source>
          <target state="translated">&lt;code&gt;url()&lt;/code&gt; 메소드는 회로도를 기준으로 사용자의 파일 시스템에서 소스 파일을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="0bc1706a02388342ae67afeb45237c3d7508da61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;useClass&lt;/code&gt; provider key lets you create and return a new instance of the specified class.</source>
          <target state="translated">&lt;code&gt;useClass&lt;/code&gt; 의 제공 키를 생성하고 지정된 클래스의 새로운 인스턴스를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5681ccda9b1d2143ce5b503657b19dfe1f04e77f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;useExisting&lt;/code&gt; provider key lets you map one token to another. In effect, the first token is an &lt;em&gt;alias&lt;/em&gt; for the service associated with the second token, creating two ways to access the same service object.</source>
          <target state="translated">&lt;code&gt;useExisting&lt;/code&gt; 의 공급자 키는 다른 하나의 토큰을 매핑 할 수 있습니다. 실제로 첫 번째 토큰은 두 번째 토큰과 연결된 서비스 의 &lt;em&gt;별칭&lt;/em&gt; 이며 동일한 서비스 개체에 액세스하는 두 가지 방법을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="44beea326133a07d582e720ef9523e833171f6ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;useFactory&lt;/code&gt; field tells Angular that the provider is a factory function whose implementation is &lt;code&gt;heroServiceFactory&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;useFactory&lt;/code&gt; 필드는 공급자가 그 구현 공장 기능이다 각도 알려줍니다 &lt;code&gt;heroServiceFactory&lt;/code&gt; 가 .</target>
        </trans-unit>
        <trans-unit id="0315670d1b1ee3186b18e2d0b131bffe28309147" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;useFactory&lt;/code&gt; provider key lets you create a dependency object by calling a factory function, as in the following example.</source>
          <target state="translated">&lt;code&gt;useFactory&lt;/code&gt; 제공 키는 다음 예에서와 같이 공장 함수를 호출하여 종속성 개체를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd5ad9a619c838440e376c0440e8b7fcf44e692e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;useHash&lt;/code&gt; property defaults to &lt;code&gt;false&lt;/code&gt;, and the &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/locationupgradeconfig#hashPrefix&quot;&gt;hashPrefix&lt;/a&gt;&lt;/code&gt; defaults to an empty &lt;code&gt;string&lt;/code&gt;. Pass the configuration object to override the defaults.</source>
          <target state="translated">&lt;code&gt;useHash&lt;/code&gt; 의 에 속성 기본값은 &lt;code&gt;false&lt;/code&gt; , 그리고 &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/locationupgradeconfig#hashPrefix&quot;&gt;hashPrefix&lt;/a&gt;&lt;/code&gt; 의 빈 기본값 &lt;code&gt;string&lt;/code&gt; . 구성 오브젝트를 전달하여 기본값을 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="8309209875bd091e2230b33046bfd662f9462513" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;useHash&lt;/code&gt; property defaults to &lt;code&gt;false&lt;/code&gt;, and the &lt;code&gt;hashPrefix&lt;/code&gt; defaults to an empty &lt;code&gt;string&lt;/code&gt;. Pass the configuration object to override the defaults.</source>
          <target state="translated">&lt;code&gt;useHash&lt;/code&gt; 의 에 속성 기본값은 &lt;code&gt;false&lt;/code&gt; , 그리고 &lt;code&gt;hashPrefix&lt;/code&gt; 의 빈 기본값 &lt;code&gt;string&lt;/code&gt; . 기본값을 재정의하려면 구성 개체를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="5f73f12a1042cc5a37d5219d0bdd859b38d3d738" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;useValue&lt;/code&gt; key lets you associate a fixed value with a DI token. Use this technique to provide &lt;em&gt;runtime configuration constants&lt;/em&gt; such as website base addresses and feature flags. You can also use a value provider in a unit test to provide mock data in place of a production data service.</source>
          <target state="translated">&lt;code&gt;useValue&lt;/code&gt; 의 열쇠는 당신이 DI 토큰을 고정 된 값을 연결할 수 있습니다. 이 기술을 사용 하여 웹 사이트 기본 주소 및 기능 플래그와 같은 &lt;em&gt;런타임 구성 상수&lt;/em&gt; 를 제공 &lt;em&gt;합니다&lt;/em&gt; . 또한 단위 테스트에서 값 공급자를 사용하여 프로덕션 데이터 서비스 대신 모의 데이터를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ac27e4b9fb2cce116f77c1cedfc5db8b028a144" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;validate()&lt;/code&gt; functions must return a Promise or an observable,</source>
          <target state="translated">&lt;code&gt;validate()&lt;/code&gt; 함수는 약속이나 관찰을 반환해야합니다</target>
        </trans-unit>
        <trans-unit id="6d232eaaf4baaffc4ab4f10a822fa23f92ba3c9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;withRefresh&lt;/code&gt; option is explained &lt;a href=&quot;http#cache-refresh&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;withRefresh&lt;/code&gt; 의 옵션은 설명 &lt;a href=&quot;http#cache-refresh&quot;&gt;아래&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a9827f2927350bd733138c7d14854c368b34cb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;workspace projects&lt;/code&gt; object contains all the project-specific configuration information.</source>
          <target state="translated">&lt;code&gt;workspace projects&lt;/code&gt; 목적은 모든 프로젝트 별 구성 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="db4393ab4ed83533b6fd3b84f5541ee8b1e21f61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x-prompt&lt;/code&gt; field syntax supports a long form for cases where you require additional customization and control over the prompt. In this form, the &lt;code&gt;x-prompt&lt;/code&gt; field value is a JSON object with subfields that customize the behavior of the prompt.</source>
          <target state="translated">&lt;code&gt;x-prompt&lt;/code&gt; 필드 구문은 프롬프트를 통해 추가 사용자 정의 및 제어를 필요로하는 경우에 대한 긴 형식을 지원합니다. 이 양식에서 &lt;code&gt;x-prompt&lt;/code&gt; 필드 값은 프롬프트 동작을 사용자 정의하는 서브 필드가있는 JSON 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="3d90bb925c813a0b9d2c883e18e2532b96b08fd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{hero.name}}&lt;/code&gt;&lt;a href=&quot;displaying-data#interpolation&quot;&gt;&lt;em&gt;interpolation&lt;/em&gt;&lt;/a&gt; displays the component's &lt;code&gt;hero.name&lt;/code&gt; property value within the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">&lt;code&gt;{{hero.name}}&lt;/code&gt; &lt;a href=&quot;displaying-data#interpolation&quot;&gt;&lt;em&gt;보간&lt;/em&gt;&lt;/a&gt; 표시 요소의 &lt;code&gt;hero.name&lt;/code&gt; 의 내의 속성 값 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 엘리먼트.</target>
        </trans-unit>
        <trans-unit id="90d7daa71e62572b6bccfbeb192b5e244292312c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{hero.name}}&lt;/code&gt;&lt;a href=&quot;interpolation&quot;&gt;&lt;em&gt;interpolation&lt;/em&gt;&lt;/a&gt; displays the component's &lt;code&gt;hero.name&lt;/code&gt; property value within the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">&lt;code&gt;{{hero.name}}&lt;/code&gt; &lt;a href=&quot;interpolation&quot;&gt;&lt;em&gt;보간&lt;/em&gt;&lt;/a&gt; 표시 요소의 &lt;code&gt;hero.name&lt;/code&gt; 의 내의 속성 값 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 엘리먼트.</target>
        </trans-unit>
        <trans-unit id="600a6011a885e1574b4cf2f04310a223dfb82932" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;#docregion&lt;/em&gt; comment begins a code snippet region. Every line of code &lt;em&gt;after&lt;/em&gt; that comment belongs in the region &lt;em&gt;until&lt;/em&gt; the code fragment processor encounters the end of the file or a closing &lt;em&gt;#enddocregion&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;#docregion의&lt;/em&gt; 코멘트는 코드 영역을 시작합니다. 해당 주석 &lt;em&gt;다음&lt;/em&gt; 의 모든 코드 줄은 코드 조각 프로세서가 파일 끝 또는 닫는 &lt;em&gt;#enddocregion을&lt;/em&gt; 만날 &lt;em&gt;때까지&lt;/em&gt; 영역에 &lt;em&gt;속합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="09ad083d54cf158dabf6073214d23611fea930ee" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;#docregion&lt;/em&gt; is the most important kind of code snippet markup.</source>
          <target state="translated">&lt;em&gt;#docregion은&lt;/em&gt; 코드 마크 업의 가장 중요한 종류이다.</target>
        </trans-unit>
        <trans-unit id="c02d5e0186f7578d49fc4f8de24aab78e198fd8c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;#docregion&lt;/em&gt; with no name is the &lt;em&gt;default region&lt;/em&gt;. Do &lt;em&gt;not&lt;/em&gt; set the &lt;code&gt;region&lt;/code&gt; attribute when referring to the default &lt;em&gt;#docregion&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;#docregion&lt;/em&gt; 이름이없는이입니다 &lt;em&gt;기본 지역&lt;/em&gt; . 마십시오 &lt;em&gt;하지&lt;/em&gt; 설정된 &lt;code&gt;region&lt;/code&gt; 기본을 언급 할 때 속성을 &lt;em&gt;#docregion&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="551fb2af6ce44839250b3c60015b1a1f9e111031" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&amp;lt;base href&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;기본 href&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="59a4dbde46d9770b16233eaf16d19d577b5cf162" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;AfterContent&lt;/em&gt; hooks concern &lt;code&gt;&lt;a href=&quot;../api/core/contentchildren&quot;&gt;ContentChildren&lt;/a&gt;&lt;/code&gt;, the child components that Angular projected into the component.</source>
          <target state="translated">&lt;em&gt;afterContent를가&lt;/em&gt; 우려 후크 &lt;code&gt;&lt;a href=&quot;../api/core/contentchildren&quot;&gt;ContentChildren&lt;/a&gt;&lt;/code&gt; , 각도가 구성 요소로 예상하는 자식 요소를.</target>
        </trans-unit>
        <trans-unit id="f0d2a411403b9c6d4f6d980b63bb02aa5a96e5e8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;AfterContent&lt;/em&gt; sample explores the &lt;code&gt;&lt;a href=&quot;../api/core/aftercontentinit&quot;&gt;AfterContentInit&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/core/aftercontentchecked&quot;&gt;AfterContentChecked&lt;/a&gt;()&lt;/code&gt; hooks that Angular calls &lt;em&gt;after&lt;/em&gt; Angular projects external content into the component.</source>
          <target state="translated">&lt;em&gt;afterContent를 용&lt;/em&gt; 샘플은 탐구 &lt;code&gt;&lt;a href=&quot;../api/core/aftercontentinit&quot;&gt;AfterContentInit&lt;/a&gt;()&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/core/aftercontentchecked&quot;&gt;AfterContentChecked&lt;/a&gt;()&lt;/code&gt; 이 각도 후크 통화 &lt;em&gt;후의&lt;/em&gt; 각도 돌출 성분으로 외부 콘텐츠.</target>
        </trans-unit>
        <trans-unit id="fe6a5ec79638be9e0a3986c4c022d9e46840c657" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;AfterView&lt;/em&gt; hooks concern &lt;code&gt;&lt;a href=&quot;../api/core/viewchildren&quot;&gt;ViewChildren&lt;/a&gt;&lt;/code&gt;, the child components whose element tags appear &lt;em&gt;within&lt;/em&gt; the component's template.</source>
          <target state="translated">&lt;em&gt;AfterView는&lt;/em&gt; 우려 후크 &lt;code&gt;&lt;a href=&quot;../api/core/viewchildren&quot;&gt;ViewChildren&lt;/a&gt;&lt;/code&gt; , 그 요소 태그 나타나는 하위 구성 요소 &lt;em&gt;에서&lt;/em&gt; 구성 요소의 템플릿을.</target>
        </trans-unit>
        <trans-unit id="3dfed87bca66b44e4a6482e1ba65840ed36b5bf4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;AfterView&lt;/em&gt; sample explores the &lt;code&gt;&lt;a href=&quot;../api/core/afterviewinit&quot;&gt;AfterViewInit&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/core/afterviewchecked&quot;&gt;AfterViewChecked&lt;/a&gt;()&lt;/code&gt; hooks that Angular calls &lt;em&gt;after&lt;/em&gt; it creates a component's child views.</source>
          <target state="translated">&lt;em&gt;AfterView의&lt;/em&gt; 샘플은 탐구 &lt;code&gt;&lt;a href=&quot;../api/core/afterviewinit&quot;&gt;AfterViewInit&lt;/a&gt;()&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../api/core/afterviewchecked&quot;&gt;AfterViewChecked&lt;/a&gt;()&lt;/code&gt; 그 각도 전화를 후크 &lt;em&gt;후에&lt;/em&gt; 는 구성 요소의 아이 뷰를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="a02b3def534749278a0fa19f46335219b7a2c87a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Back&lt;/em&gt; and &lt;em&gt;Save&lt;/em&gt; buttons on the Details page don't work.</source>
          <target state="translated">세부 사항 페이지 의 &lt;em&gt;뒤로&lt;/em&gt; 및 &lt;em&gt;저장&lt;/em&gt; 단추가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26812ee9d2705615518cee0d2be8d4b1f022ddbf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;ComponentFixture&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ComponentFixture&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="17fe33d0dae8927c14c9294e1b5e47dcd88f9bc8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;DoCheck&lt;/em&gt; sample extends the &lt;em&gt;OnChanges&lt;/em&gt; sample with the following &lt;code&gt;ngDoCheck()&lt;/code&gt; hook:</source>
          <target state="translated">&lt;em&gt;DoCheck의&lt;/em&gt; 샘플은 연장 &lt;em&gt;OnChanges의&lt;/em&gt; 다음 샘플 &lt;code&gt;ngDoCheck()&lt;/code&gt; 후크 :</target>
        </trans-unit>
        <trans-unit id="66f7b097f518f662624a2fe89fa23bde67722c64" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Hero Employment Agency&lt;/em&gt; uses this form to maintain personal information about heroes. Every hero needs a job. It's the company mission to match the right hero with the right crisis.</source>
          <target state="translated">&lt;em&gt;영웅 직업 소개소는&lt;/em&gt; 영웅에 대한 개인 정보를 유지하기 위해이 양식을 사용합니다. 모든 영웅은 직업이 필요합니다. 올바른 영웅을 올바른 위기에 맞추는 것이 회사의 사명입니다.</target>
        </trans-unit>
        <trans-unit id="d3402fb21166e9ae4d2d51d781786ab5a98ca52d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;History&lt;/em&gt; log demonstrates that messages travel in both directions between the parent &lt;code&gt;MissionControlComponent&lt;/code&gt; and the &lt;code&gt;AstronautComponent&lt;/code&gt; children, facilitated by the service:</source>
          <target state="translated">&lt;em&gt;역사의&lt;/em&gt; 로그 메시지는 부모 사이의 양 방향으로 여행 것을 증명 &lt;code&gt;MissionControlComponent&lt;/code&gt; 과 &lt;code&gt;AstronautComponent&lt;/code&gt; 의 서비스에 의해 촉진 어린이 :</target>
        </trans-unit>
        <trans-unit id="2b32c125ecd1669f448ec3bf41c296c4bafe6250" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Name&lt;/em&gt;&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; control has the HTML5 &lt;code&gt;required&lt;/code&gt; attribute; the &lt;em&gt;Alter Ego&lt;/em&gt;&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; control does not because &lt;code&gt;alterEgo&lt;/code&gt; is optional.</source>
          <target state="translated">&lt;em&gt;이름 &lt;/em&gt; &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 컨트롤 HTML5 갖는다 &lt;code&gt;required&lt;/code&gt; 속성; &lt;em&gt;다른 자아 &lt;/em&gt; &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 때문에 제어하지 않습니다 &lt;code&gt;alterEgo&lt;/code&gt; 는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="e2265d664f6eff573fc5ee3934aa756169219d40" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;NgModel&lt;/em&gt; directive doesn't just track state; it updates the control with special Angular CSS classes that reflect the state. You can leverage those class names to change the appearance of the control.</source>
          <target state="translated">&lt;em&gt;NgModel의&lt;/em&gt; 지시어는 상태를 추적하지 않는다; 상태를 반영하는 특수 Angular CSS 클래스로 컨트롤을 업데이트합니다. 이러한 클래스 이름을 사용하여 컨트롤의 모양을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbea351a6ffcf13594aaadf605f66f73429d2df2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Parent Finder&lt;/em&gt; sample is full of circular class references that are impossible to break.</source>
          <target state="translated">&lt;em&gt;부모 파인더&lt;/em&gt; 샘플을 깰 불가능 원형 클래스 참조 가득합니다.</target>
        </trans-unit>
        <trans-unit id="6c4600462959ddfa37d5891549dbb884fbecfd73" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Reset&lt;/em&gt; button clears the &lt;code&gt;heroes&lt;/code&gt; list. Angular removes all hero &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; elements from the DOM and destroys their spy directives at the same time. The spy's &lt;code&gt;ngOnDestroy()&lt;/code&gt; method reports its last moments.</source>
          <target state="translated">&lt;em&gt;리셋&lt;/em&gt; 버튼을 지 웁니다 &lt;code&gt;heroes&lt;/code&gt; 목록을. Angular는 DOM에서 모든 hero &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 요소를 제거 하고 동시에 spy 지시문을 삭제합니다. 스파이의 &lt;code&gt;ngOnDestroy()&lt;/code&gt; 메소드는 마지막 순간을보고합니다.</target>
        </trans-unit>
        <trans-unit id="c1a352f4be8028751775aca111e668c0a33502ea" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Routing Module&lt;/em&gt;&lt;em&gt;replaces&lt;/em&gt; the routing configuration in the root or feature module. &lt;em&gt;Either&lt;/em&gt; configure routes in the Routing Module &lt;em&gt;or&lt;/em&gt; within the module itself but not in both.</source>
          <target state="translated">&lt;em&gt;라우팅 모듈은 &lt;/em&gt;&lt;em&gt;대체&lt;/em&gt; 루트 또는 기능 모듈의 라우팅 구성을. &lt;em&gt;어느&lt;/em&gt; 라우팅 모듈의 구성 경로 &lt;em&gt;또는&lt;/em&gt; 모듈 자체에 있지만 둘 다있다.</target>
        </trans-unit>
        <trans-unit id="0c5f8f5d1924de13765832553932eb057250f18c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Save&lt;/em&gt; button is disabled until the form is in a valid state. When the form is valid, you can click &lt;em&gt;Save&lt;/em&gt; and the app renders the current form values as JSON. This proves that any user input is bound back to the data model. Saving and retrieving the data is an exercise for another time.</source>
          <target state="translated">&lt;em&gt;저장&lt;/em&gt; 형태가 유효한 상태가 될 때까지 버튼을 사용할 수 없습니다. 양식이 유효하면 &lt;em&gt;저장&lt;/em&gt; 을 클릭 하면 앱이 현재 양식 값을 JSON으로 렌더링합니다. 이는 모든 사용자 입력이 데이터 모델에 다시 바인딩됨을 증명합니다. 데이터 저장 및 검색은 또 다른 연습입니다.</target>
        </trans-unit>
        <trans-unit id="7a30cd1086fc126cdbda17264a63b67bfd463386" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Tour of Heroes&lt;/em&gt; app that you build helps a staffing agency manage its stable of heroes. The app has many of the features you'd expect to find in any data-driven application. The finished app acquires and displays a list of heroes, edits a selected hero's detail, and navigates among different views of heroic data.</source>
          <target state="translated">&lt;em&gt;영웅의 투어는&lt;/em&gt; 당신이 빌드는 인력 기관은 영웅의 안정적인 관리하는 데 도움이 응용 프로그램. 이 앱에는 모든 데이터 기반 애플리케이션에서 기대할 수있는 많은 기능이 있습니다. 완성 된 앱은 영웅 목록을 획득 및 표시하고, 선택한 영웅의 세부 정보를 편집하고, 영웅 데이터의 여러보기를 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="cece2edbaa93c78578f1816377db1a1619b69bba" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;attribute selector&lt;/em&gt; pattern explains the name of this kind of directive.</source>
          <target state="translated">&lt;em&gt;속성 선택&lt;/em&gt; 패턴이 지시 이런 종류의 이름을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1b48144f080e3a52ebd72bed691562e0a4b05ef3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;cache-then-refresh&lt;/em&gt; option is triggered by the presence of a &lt;strong&gt;custom &lt;code&gt;x-refresh&lt;/code&gt; header&lt;/strong&gt;.</source>
          <target state="translated">&lt;em&gt;캐시 후 새로 고침&lt;/em&gt; 옵션은의 존재에 의해 트리거되는 &lt;strong&gt;사용자 지정 &lt;code&gt;x-refresh&lt;/code&gt; 헤더&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="cd03c6a4b57c507c800b037668226501ef677043" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;cache-then-refresh&lt;/em&gt; option is triggered by the presence of a custom &lt;code&gt;x-refresh&lt;/code&gt; header.</source>
          <target state="translated">&lt;em&gt;캐시 후 새로 고침&lt;/em&gt; 옵션은 사용자 정의의 존재에 의해 트리거되는 &lt;code&gt;x-refresh&lt;/code&gt; 헤더입니다.</target>
        </trans-unit>
        <trans-unit id="68bffbc638ce2bcff5ac27e43af13ce79019ebe1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;class&lt;/em&gt; is similar to the &lt;code&gt;HeroesComponent&lt;/code&gt; class.</source>
          <target state="translated">이 &lt;em&gt;클래스&lt;/em&gt; 는 &lt;code&gt;HeroesComponent&lt;/code&gt; 클래스 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="3b23511daee49c68fc0bd77c760d5aeb2fbfce17" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;consumer&lt;/em&gt; of an injected service doesn't need to know how to create that service. It's the job of the DI framework to create and cache dependencies. The consumer just needs to let the DI framework know which dependencies it needs.</source>
          <target state="translated">&lt;em&gt;소비자&lt;/em&gt; 주입 된 서비스는 해당 서비스를 만드는 방법을 알 필요가 없습니다. 종속성을 생성하고 캐시하는 것은 DI 프레임 워크의 역할입니다. 소비자는 DI 프레임 워크에 필요한 종속성을 알려 주기만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="68169d61d2e3c28071db2b807cf1b4e1b903706c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;expression context&lt;/em&gt; is typically the &lt;em&gt;component&lt;/em&gt; instance. In the following snippets, the &lt;code&gt;recommended&lt;/code&gt; within double curly braces and the &lt;code&gt;itemImageUrl2&lt;/code&gt; in quotes refer to properties of the &lt;code&gt;AppComponent&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;식 컨텍스트&lt;/em&gt; 통상적 인 &lt;em&gt;컴포넌트&lt;/em&gt; 인스턴스. 다음 스 니펫 에서 이중 중괄호 및 따옴표로 묶은 &lt;code&gt;itemImageUrl2&lt;/code&gt; 내 에서 &lt;code&gt;recommended&lt;/code&gt; 되는 것은 AppComponent의 특성을 나타 &lt;code&gt;AppComponent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="547e485937ee9a8482d6c575e3337f47c2760a8f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;fixture&lt;/em&gt; methods cause Angular to perform certain tasks on the component tree. Call these method to trigger Angular behavior in response to simulated user action.</source>
          <target state="translated">&lt;em&gt;고정&lt;/em&gt; 각도 원인이 방법은 구성 요소 트리에서 특정 작업을 수행 할 수 있습니다. 시뮬레이션 된 사용자 동작에 대한 응답으로 각도 동작을 트리거하려면이 메소드를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="281c18d861de6375f500f8737ccbe1fc960a8a5e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;injector&lt;/em&gt; is the main mechanism. Angular creates an application-wide injector for you during the bootstrap process, and additional injectors as needed. You don't have to create injectors.</source>
          <target state="translated">&lt;em&gt;인젝터는&lt;/em&gt; 주요 메커니즘입니다. Angular는 부트 스트랩 프로세스 중에 응용 프로그램 전체 인젝터와 필요에 따라 추가 인젝터를 만듭니다. 인젝터를 만들 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6c1ab60ab4f1d67de0ddd4e00da564b8cd65741d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;link parameters array&lt;/em&gt; contains an object with a single &lt;code&gt;outlets&lt;/code&gt; property whose value is another object keyed by one (or more) outlet names. In this case there is only the &quot;popup&quot; outlet property and its value is another &lt;em&gt;link parameters array&lt;/em&gt; that specifies the &lt;code&gt;compose&lt;/code&gt; route.</source>
          <target state="translated">&lt;em&gt;링크 파라미터 어레이는&lt;/em&gt; 하나의 오브젝트가 포함 &lt;code&gt;outlets&lt;/code&gt; 값 중 하나 (또는 그 이상)의 출구 이름에 의해 키가 다른 목적 속성. 이 경우 &quot;popup&quot;outlet 특성 만 있으며 해당 값은 &lt;code&gt;compose&lt;/code&gt; 경로 를 지정하는 다른 &lt;em&gt;링크 매개 변수 배열&lt;/em&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="6f8f3c3b5c5041d24c8b8360e46b01aea381f4f8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;local variable&lt;/em&gt; approach is simple and easy. But it is limited because the parent-child wiring must be done entirely within the parent template. The parent component &lt;em&gt;itself&lt;/em&gt; has no access to the child.</source>
          <target state="translated">&lt;em&gt;지역 변수의&lt;/em&gt; 접근 방식은 간단하고 쉽습니다. 그러나 부모-자식 배선은 부모 템플릿 내에서 완전히 수행해야하기 때문에 제한됩니다. 부모 구성 요소 &lt;em&gt;자체&lt;/em&gt; 는 자식에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="70d69092db75bbbde8d71173eb3a75beeb8e0869" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;next&lt;/em&gt; object</source>
          <target state="translated">&lt;em&gt;다음&lt;/em&gt; 객체</target>
        </trans-unit>
        <trans-unit id="680dc53f22865b98fcfe8ea1b8820ef44fdd9a8d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;observe&lt;/em&gt; option specifies how much of the response to return.</source>
          <target state="translated">는 &lt;em&gt;관찰&lt;/em&gt; 복귀에 대한 응답의 얼마나 많은 옵션을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d7c4875e7d9495788d2aae3a67d641c0812d162a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;overrideComponent&lt;/em&gt; method</source>
          <target state="translated">&lt;em&gt;overrideComponent&lt;/em&gt; 방법</target>
        </trans-unit>
        <trans-unit id="ff0fbcfe3ea4fa514b574eaf8f3d059f8b33db8a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;path&lt;/em&gt; of the route to the destination component.</source>
          <target state="translated">대상 구성 요소로 의 &lt;em&gt;경로&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="630fa707e54c08a528f955e5bb95d477c9ced61b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;plural&lt;/em&gt; and &lt;em&gt;select&lt;/em&gt; ICU expressions are extracted separately, so they require special attention when preparing for translation.</source>
          <target state="translated">&lt;em&gt;복수&lt;/em&gt; 와 &lt;em&gt;선택&lt;/em&gt; 번역을 준비 할 때 특별한주의가 필요하므로 ICU의 표현은 별도로 추출된다.</target>
        </trans-unit>
        <trans-unit id="b1863b3c0fe60749f25419b06a221dd2df30c597" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;responseType&lt;/em&gt; option specifies the format in which to return data.</source>
          <target state="translated">&lt;em&gt;responseType의&lt;/em&gt; 옵션은 데이터를 반환 할 형식을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="7ec1d5444e649cbb29fb26c5ebedf34c9f05198a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;statement context&lt;/em&gt; is typically the component instance. The &lt;em&gt;deleteHero&lt;/em&gt; in &lt;code&gt;(click)=&quot;deleteHero()&quot;&lt;/code&gt; is a method of the data-bound component.</source>
          <target state="translated">&lt;em&gt;문 컨텍스트는&lt;/em&gt; 일반적으로 구성 요소 인스턴스입니다. &lt;em&gt;deleteHero&lt;/em&gt; 의 &lt;code&gt;(click)=&quot;deleteHero()&quot;&lt;/code&gt; 데이터 바인딩 컴포넌트하는 방법이다.</target>
        </trans-unit>
        <trans-unit id="8e1155de8d03b6d218f6065cbb5b9d44effee80c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;stub component&lt;/em&gt; approach has another advantage. While the stubs in &lt;em&gt;this&lt;/em&gt; example were empty, you could give them stripped-down templates and classes if your tests need to interact with them in some way.</source>
          <target state="translated">&lt;em&gt;스터브 성분&lt;/em&gt; 접근법은 또 다른 장점을 갖는다. &lt;em&gt;이&lt;/em&gt; 예제 의 스텁 은 비어 있지만 테스트가 어떤 방식 으로든 상호 작용해야하는 경우 제거 된 템플리트 및 클래스를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91f269fce15860a4bd882bdab5721a6f6a5432e6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;target&lt;/em&gt; of a binding is the property or event inside the binding punctuation: &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;()&lt;/code&gt; or &lt;code&gt;[()]&lt;/code&gt;.</source>
          <target state="translated">바인딩 의 &lt;em&gt;대상&lt;/em&gt; 은 바인딩 문장 부호 내의 속성 또는 이벤트입니다 : &lt;code&gt;[]&lt;/code&gt; , &lt;code&gt;()&lt;/code&gt; 또는 &lt;code&gt;[()]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccdd54cecc0f13f83a35d6d76b84a2c2d17459f4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;tax-return-to-edit&lt;/em&gt; arrives via the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; property, which is implemented with getters and setters. The setter initializes the component's own instance of the &lt;code&gt;HeroTaxReturnService&lt;/code&gt; with the incoming return. The getter always returns what that service says is the current state of the hero. The component also asks the service to save and restore this tax return.</source>
          <target state="translated">&lt;em&gt;세금 반환 - 투 - 편집&lt;/em&gt; 비아 도착 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; getter와 setter로 구현되는 속성. setter 는 들어오는 리턴으로 컴포넌트의 &lt;code&gt;HeroTaxReturnService&lt;/code&gt; 인스턴스를 초기화합니다 . getter는 항상 해당 서비스가 말한 것을 영웅의 현재 상태로 반환합니다. 구성 요소는 서비스에이 세금 보고서를 저장하고 복원하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="9e36ec033ef8853bb7773e0524c7bcf886af13b5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;template&lt;/em&gt; presents a grid of hero name links.</source>
          <target state="translated">&lt;em&gt;템플릿은&lt;/em&gt; 영웅의 이름 링크의 격자를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="636d367710cec9d2d29ffff2f2fd03967c9e996d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;tick()&lt;/em&gt; function</source>
          <target state="translated">&lt;em&gt;틱 ()&lt;/em&gt; 함수를</target>
        </trans-unit>
        <trans-unit id="b73b5928bad05d3f6f07eeb7ee4604ca9d2c626e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Alter Ego&lt;/strong&gt;&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; control element does not because &lt;code&gt;alterEgo&lt;/code&gt; is optional.</source>
          <target state="translated">&lt;strong&gt;다른 자아 &lt;/strong&gt; &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 때문에 제어 요소가되지 않는다 &lt;code&gt;alterEgo&lt;/code&gt; 는 선택적이다.</target>
        </trans-unit>
        <trans-unit id="8d3bb42799c52e0ebb6f8e858f4a96af7a8b97fc" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Hero Power&lt;/strong&gt; select box is also required, but it doesn't need this kind of error handling because the selection box already constrains the selection to valid values.</source>
          <target state="translated">&lt;strong&gt;영웅 전원&lt;/strong&gt; 선택 상자도 필요하지만 선택 상자가 이미 유효한 값으로 선택을 제한하기 때문에 취급 이런 종류의 오류를 필요로하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4cbd7a46bb1ee20b0c8f13141e85002a327111af" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Main Concepts&lt;/strong&gt; section located in the table of contents contains several topics that explain how to connect the application data in your &lt;a href=&quot;glossary#component&quot;&gt;components&lt;/a&gt; to your page-display &lt;a href=&quot;glossary#template&quot;&gt;templates&lt;/a&gt;, to create a complete interactive application.</source>
          <target state="translated">&lt;strong&gt;주요 개념&lt;/strong&gt; 목차에있는 섹션에서는의 응용 프로그램 데이터를 연결하는 방법을 설명하는 몇 가지 항목을 포함하고 &lt;a href=&quot;glossary#component&quot;&gt;구성 요소&lt;/a&gt; 페이지 디스플레이에 &lt;a href=&quot;glossary#template&quot;&gt;템플릿&lt;/a&gt; , 완전한 대화 형 응용 프로그램을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7175187c085f67353fe16a56cd79779c6b4d91da" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Name&lt;/strong&gt; input box is required and clearing it turns the bar red. That indicates that something is wrong, but the user doesn't know what is wrong or what to do about it. You can provide a helpful message by checking for and responding to the control's state.</source>
          <target state="translated">&lt;strong&gt;이름&lt;/strong&gt; 입력 상자가 필요하고 삭제하는 것은 빨간색 막대를 회전한다. 이는 무언가 잘못되었음을 나타내지 만 사용자는 무엇이 잘못되었는지 또는 어떻게해야할지 알지 못합니다. 컨트롤의 상태를 확인하고 이에 응답하여 유용한 메시지를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdbf6656d06da974b0c76f21411092c5e5610d43" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Name&lt;/strong&gt;&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; control element has the HTML5 &lt;code&gt;required&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;strong&gt;이름 &lt;/strong&gt; &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 제어 요소는 HTML5 갖는다 &lt;code&gt;required&lt;/code&gt; 속성.</target>
        </trans-unit>
        <trans-unit id="38fe5f3ec6af8a496ebd01cf5cb597e571669f94" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;QuickStart seed&lt;/strong&gt; provides a basic QuickStart playground application and other files necessary for local development. Consequently, there are many files in the project folder on your machine, most of which you can &lt;a href=&quot;file-structure&quot;&gt;learn about later&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;퀵 스타트 씨는&lt;/strong&gt; 지역 발전에 필요한 기본 퀵 스타트 놀이터 응용 프로그램 및 기타 파일을 제공합니다. 결과적으로 컴퓨터의 프로젝트 폴더에 많은 파일이 있으며, 대부분 &lt;a href=&quot;file-structure&quot;&gt;나중에 나중에 배울&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb3aa4e6ae7ad082bbd31bada71f42f06ba8bb67" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Routing Module&lt;/strong&gt; has several characteristics:</source>
          <target state="translated">&lt;strong&gt;라우팅 모듈은&lt;/strong&gt; 몇 가지 특징이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="849d1c8e18bd79ab64d5f8f2f782ae35aec1f5e0" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Submit&lt;/strong&gt; button has some classes on it for styling. At this point, the form layout is all plain HTML5, with no bindings or directives.</source>
          <target state="translated">&lt;strong&gt;제출&lt;/strong&gt; 버튼을 스타일링을 위해 몇 가지 클래스가 있습니다. 이 시점에서 양식 레이아웃은 바인딩이나 지시문이없는 일반 HTML5입니다.</target>
        </trans-unit>
        <trans-unit id="8431cda422e11c057566eff6e247db10156e3002" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Submit&lt;/strong&gt; button is disabled because &lt;code&gt;profileForm&lt;/code&gt; is invalid due to the required &lt;code&gt;firstName&lt;/code&gt; form control. After you fill out the &lt;code&gt;firstName&lt;/code&gt; input, the form becomes valid and the &lt;strong&gt;Submit&lt;/strong&gt; button is enabled.</source>
          <target state="translated">&lt;strong&gt;제출&lt;/strong&gt; 하기 때문에 버튼이 비활성화됩니다 &lt;code&gt;profileForm&lt;/code&gt; 이 요구에 유효하지 않은 때문이다 &lt;code&gt;firstName&lt;/code&gt; 을의 폼 컨트롤이. 당신이 작성 후 &lt;code&gt;firstName&lt;/code&gt; 을의 입력 양식은 유효하게하고는 &lt;strong&gt;제출&lt;/strong&gt; 버튼이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="5fef189672083b94d3b83bc834df0b31d7afc9bf" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;empty path&lt;/strong&gt; in the fourth route represents the default path for the application, the place to go when the path in the URL is empty, as it typically is at the start. This default route redirects to the route for the &lt;code&gt;/heroes&lt;/code&gt; URL and, therefore, will display the &lt;code&gt;HeroesListComponent&lt;/code&gt;.</source>
          <target state="translated">네 번째 &lt;strong&gt;경로&lt;/strong&gt; 의 &lt;strong&gt;빈 경로&lt;/strong&gt; 는 응용 프로그램의 기본 경로를 나타내며, URL의 경로가 비어있을 때가는 곳입니다. 일반적으로 시작 위치에 있습니다. 이 기본 경로는 &lt;code&gt;/heroes&lt;/code&gt; URL 경로로 리디렉션 되므로 &lt;code&gt;HeroesListComponent&lt;/code&gt; 가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="6a7f6d0dd6a950a502cb905ddc90e2fe09d4e93d" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;target of a data-binding&lt;/strong&gt; is something in the DOM. Depending on the binding type, the target can be a property (element, component, or directive), an event (element, component, or directive), or sometimes an attribute name. The following table summarizes the targets for the different binding types.</source>
          <target state="translated">&lt;strong&gt;데이터 바인딩&lt;/strong&gt; 의 &lt;strong&gt;대상은&lt;/strong&gt; DOM에 있습니다. 바인딩 유형에 따라 대상은 속성 (요소, 구성 요소 또는 지시문), 이벤트 (요소, 구성 요소 또는 지시문) 또는 속성 이름 일 수 있습니다. 다음 표는 다른 바인딩 유형의 대상을 요약 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="8a78166f7358622c21dbee58ca508e7e826a4e7b" translate="yes" xml:space="preserve">
          <source>The AOT collector does not support the arrow function, &lt;code&gt;() =&amp;gt; new Server()&lt;/code&gt;, in a metadata expression. It generates an error node in place of the function. When the compiler later interprets this node, it reports an error that invites you to turn the arrow function into an &lt;em&gt;exported function&lt;/em&gt;.</source>
          <target state="translated">AOT 콜렉터는 메타 데이터 표현식에서 화살표 함수 &lt;code&gt;() =&amp;gt; new Server()&lt;/code&gt; 지원하지 않습니다 . 함수 대신 오류 노드를 생성합니다. 컴파일러는 나중에이 노드를 해석 할 때 화살표 기능을 &lt;em&gt;내 보낸 기능&lt;/em&gt; 으로 바꾸라는 오류를보고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4ec06e91967a3490f909670fcf275c0084d8ae3a" translate="yes" xml:space="preserve">
          <source>The AOT collector only understands a subset of JavaScript. Define metadata objects with the following limited syntax:</source>
          <target state="translated">AOT 콜렉터는 JavaScript의 서브 세트 만 이해합니다. 다음과 같은 제한된 구문으로 메타 데이터 개체를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="3309ff63faf07832967b0387fa813ffae5dc2636" translate="yes" xml:space="preserve">
          <source>The AOT compiler does not support &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function&quot;&gt;function expressions&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow functions&lt;/a&gt;, also called &lt;em&gt;lambda&lt;/em&gt; functions.</source>
          <target state="translated">AOT 컴파일러는 &lt;em&gt;람다&lt;/em&gt; 함수 라고도 하는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function&quot;&gt;함수 표현식&lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;화살표 함수를&lt;/a&gt; 지원하지 않습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57076a87d98a096e595ee9049523e81bc3fea517" translate="yes" xml:space="preserve">
          <source>The AOT compiler does not support tagged template expressions; avoid them in metadata expressions.</source>
          <target state="translated">AOT 컴파일러는 태그 된 템플릿 표현식을 지원하지 않습니다. 메타 데이터 표현식에서는이를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="17ec447b5468a57a4699fa18102b133cb26f2424" translate="yes" xml:space="preserve">
          <source>The Ahead-of-Time (AOT) compiler</source>
          <target state="translated">AOT (Ahead-of-Time) 컴파일러</target>
        </trans-unit>
        <trans-unit id="0f58944803c6d64ef57d8af160113fc77e4a3dba" translate="yes" xml:space="preserve">
          <source>The Angular &lt;a href=&quot;../api/router/routermodule&quot;&gt;&lt;code&gt;RouterModule&lt;/code&gt;&lt;/a&gt; exports two macro static methods, &lt;code&gt;forRoot&lt;/code&gt; and &lt;code&gt;forChild&lt;/code&gt;, to help declare root and child routes. Review the &lt;a href=&quot;https://github.com/angular/angular/blob/master/packages/router/src/router_module.ts#L139&quot;&gt;source code&lt;/a&gt; for these methods to see how macros can simplify configuration of complex &lt;a href=&quot;ngmodules&quot;&gt;NgModules&lt;/a&gt;.</source>
          <target state="translated">각 &lt;a href=&quot;../api/router/routermodule&quot;&gt; &lt;code&gt;RouterModule&lt;/code&gt; 는&lt;/a&gt; 두 개의 매크로 정적 방법, 수출 &lt;code&gt;forRoot&lt;/code&gt; 및 &lt;code&gt;forChild&lt;/code&gt; 을 도움 선언 루트와 자식 노선에. 이러한 메소드 의 &lt;a href=&quot;https://github.com/angular/angular/blob/master/packages/router/src/router_module.ts#L139&quot;&gt;소스 코드&lt;/a&gt; 를 검토하여 매크로가 복잡한 &lt;a href=&quot;ngmodules&quot;&gt;NgModules의&lt;/a&gt; 구성을 단순화하는 방법을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="47e66a7447f54311fa8c78fef83d2b71c3f6c662" translate="yes" xml:space="preserve">
          <source>The Angular &lt;a href=&quot;../guide/attribute-binding#class-binding&quot;&gt;class binding&lt;/a&gt; makes it easy to add and remove a CSS class conditionally. Just add &lt;code&gt;[class.some-css-class]=&quot;some-condition&quot;&lt;/code&gt; to the element you want to style.</source>
          <target state="translated">Angular &lt;a href=&quot;../guide/attribute-binding#class-binding&quot;&gt;클래스 바인딩을&lt;/a&gt; 사용하면 조건부로 CSS 클래스를 쉽게 추가하고 제거 할 수 있습니다. 스타일을 지정할 요소 에 &lt;code&gt;[class.some-css-class]=&quot;some-condition&quot;&lt;/code&gt; 을 추가하기 만하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="f3fb711c3b5e5fe0d0ccfb358c3cf8ff1a218dcc" translate="yes" xml:space="preserve">
          <source>The Angular &lt;a href=&quot;../guide/template-syntax#class-binding&quot;&gt;class binding&lt;/a&gt; makes it easy to add and remove a CSS class conditionally. Just add &lt;code&gt;[class.some-css-class]=&quot;some-condition&quot;&lt;/code&gt; to the element you want to style.</source>
          <target state="translated">Angular &lt;a href=&quot;../guide/template-syntax#class-binding&quot;&gt;클래스 바인딩을&lt;/a&gt; 사용하면 조건부로 CSS 클래스를 쉽게 추가하고 제거 할 수 있습니다. 스타일을 지정할 요소 에 &lt;code&gt;[class.some-css-class]=&quot;some-condition&quot;&lt;/code&gt; 을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="b7237af6c841a21a08e75ad225a0026b3080167a" translate="yes" xml:space="preserve">
          <source>The Angular &lt;a href=&quot;glossary#aot&quot;&gt;ahead-of-time (AOT) compiler&lt;/a&gt; converts your Angular HTML and TypeScript code into efficient JavaScript code during the build phase &lt;em&gt;before&lt;/em&gt; the browser downloads and runs that code. Compiling your application during the build process provides a faster rendering in the browser.</source>
          <target state="translated">Angular &lt;a href=&quot;glossary#aot&quot;&gt;AOT (Ahead-of-Time) 컴파일러&lt;/a&gt; 는 브라우저가 해당 코드를 다운로드하고 실행 &lt;em&gt;하기 전에&lt;/em&gt; 빌드 단계에서 Angular HTML 및 TypeScript 코드를 효율적인 JavaScript 코드로 변환합니다 . 빌드 프로세스 중에 애플리케이션을 컴파일하면 브라우저에서 더 빠르게 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bd53a5dd11dba31d91be2abd7e3256203b19030" translate="yes" xml:space="preserve">
          <source>The Angular &lt;code&gt;&amp;lt;ng-container&amp;gt;&lt;/code&gt; is a grouping element that doesn't interfere with styles or layout because Angular &lt;em&gt;doesn't put it in the DOM&lt;/em&gt;.</source>
          <target state="translated">Angular &lt;code&gt;&amp;lt;ng-container&amp;gt;&lt;/code&gt; 는 Angular &lt;em&gt;가 DOM에 넣지&lt;/em&gt; 않기 때문에 스타일이나 레이아웃을 방해하지 않는 그룹화 요소입니다 .</target>
        </trans-unit>
        <trans-unit id="43bb5eb6f6a28633f87170e07fbe299b89367463" translate="yes" xml:space="preserve">
          <source>The Angular &lt;code&gt;&lt;a href=&quot;../api/common/asyncpipe&quot;&gt;AsyncPipe&lt;/a&gt;&lt;/code&gt; is an interesting example of an impure pipe. The &lt;code&gt;&lt;a href=&quot;../api/common/asyncpipe&quot;&gt;AsyncPipe&lt;/a&gt;&lt;/code&gt; accepts a &lt;code&gt;Promise&lt;/code&gt; or &lt;code&gt;Observable&lt;/code&gt; as input and subscribes to the input automatically, eventually returning the emitted values.</source>
          <target state="translated">Angular &lt;code&gt;&lt;a href=&quot;../api/common/asyncpipe&quot;&gt;AsyncPipe&lt;/a&gt;&lt;/code&gt; 는 불순한 파이프의 흥미로운 예입니다. &lt;code&gt;&lt;a href=&quot;../api/common/asyncpipe&quot;&gt;AsyncPipe&lt;/a&gt;&lt;/code&gt; 는 받아 &lt;code&gt;Promise&lt;/code&gt; 또는 &lt;code&gt;Observable&lt;/code&gt; 결국 방출 값을 반환 자동 입력에 입력하고 구독한다.</target>
        </trans-unit>
        <trans-unit id="044b107dfed7b9441c1745738d1ce4219937db11" translate="yes" xml:space="preserve">
          <source>The Angular &lt;code&gt;&lt;a href=&quot;../api/common/currencypipe&quot;&gt;currency&lt;/a&gt;&lt;/code&gt; pipe is similar although some of the parameters have changed.</source>
          <target state="translated">Angular &lt;code&gt;&lt;a href=&quot;../api/common/currencypipe&quot;&gt;currency&lt;/a&gt;&lt;/code&gt; 파이프는 일부 매개 변수가 변경되었지만 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="19b4e117f4e15eeed3be79f6eaca89eed51b2798" translate="yes" xml:space="preserve">
          <source>The Angular &lt;code&gt;&lt;a href=&quot;../api/common/datepipe&quot;&gt;date&lt;/a&gt;&lt;/code&gt; pipe is similar.</source>
          <target state="translated">Angular &lt;code&gt;&lt;a href=&quot;../api/common/datepipe&quot;&gt;date&lt;/a&gt;&lt;/code&gt; 파이프는 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="3cd4a1df1710a1e282cc8be9a6f7e030631d0b5f" translate="yes" xml:space="preserve">
          <source>The Angular &lt;code&gt;&lt;a href=&quot;../api/common/decimalpipe&quot;&gt;number&lt;/a&gt;&lt;/code&gt; pipe is similar. It provides more functionality when defining the decimal places, as shown in the second example above.</source>
          <target state="translated">Angular &lt;code&gt;&lt;a href=&quot;../api/common/decimalpipe&quot;&gt;number&lt;/a&gt;&lt;/code&gt; 파이프는 비슷합니다. 위의 두 번째 예에서와 같이 소수점 이하 자릿수를 정의 할 때 더 많은 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7470cb8ba9aa4391c200e394d5eb3fd0ffc1a6a6" translate="yes" xml:space="preserve">
          <source>The Angular &lt;code&gt;&lt;a href=&quot;../api/common/jsonpipe&quot;&gt;json&lt;/a&gt;&lt;/code&gt; pipe does the same thing.</source>
          <target state="translated">Angular &lt;code&gt;&lt;a href=&quot;../api/common/jsonpipe&quot;&gt;json&lt;/a&gt;&lt;/code&gt; 파이프는 동일한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="bfc3526882f1ce975b1c02e954b284474cb59122" translate="yes" xml:space="preserve">
          <source>The Angular &lt;code&gt;&lt;a href=&quot;../api/common/lowercasepipe&quot;&gt;lowercase&lt;/a&gt;&lt;/code&gt; pipe does the same thing.</source>
          <target state="translated">앵귤러 &lt;code&gt;&lt;a href=&quot;../api/common/lowercasepipe&quot;&gt;lowercase&lt;/a&gt;&lt;/code&gt; 파이프도 같은 기능을합니다.</target>
        </trans-unit>
        <trans-unit id="810425749aeb3185f4b3f49e48b3f7db25fa3041" translate="yes" xml:space="preserve">
          <source>The Angular &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; directive inserts or removes an element based on a &lt;em&gt;truthy/falsy&lt;/em&gt; condition. To see it in action, add the following paragraph at the bottom of the template:</source>
          <target state="translated">Angular &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 지시문은 &lt;em&gt;진실 / 거짓&lt;/em&gt; 조건 에 따라 요소를 삽입하거나 제거합니다 . 실제로 작동하는지 확인하려면 템플릿 맨 아래에 다음 단락을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="bd5e639cdef0d9e6854735f421c2b0e44dd5b4a1" translate="yes" xml:space="preserve">
          <source>The Angular &lt;code&gt;&lt;a href=&quot;../api/core/forwardref&quot;&gt;forwardRef&lt;/a&gt;()&lt;/code&gt; function creates an &lt;em&gt;indirect&lt;/em&gt; reference that Angular can resolve later.</source>
          <target state="translated">Angular &lt;code&gt;&lt;a href=&quot;../api/core/forwardref&quot;&gt;forwardRef&lt;/a&gt;()&lt;/code&gt; 함수 는 Angular가 나중에 확인할 수 있는 &lt;em&gt;간접&lt;/em&gt; 참조를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="2497b896b7688ae48300df106650c098f5fdf738" translate="yes" xml:space="preserve">
          <source>The Angular &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; facilitates this kind of testing as you'll see in the sections below. But in many cases, &lt;em&gt;testing the component class alone&lt;/em&gt;, without DOM involvement, can validate much of the component's behavior in an easier, more obvious way.</source>
          <target state="translated">Angular &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; 는 아래 섹션에서 볼 수 있듯이 이러한 종류의 테스트를 용이하게합니다. 그러나 많은 경우에 DOM 관련없이 &lt;em&gt;컴포넌트 클래스 만 테스트&lt;/em&gt; 하면 더 쉽고 명확한 방법으로 컴포넌트의 동작 대부분을 검증 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="875d83e7c9770ccfa8b1c529613a326325c96e1c" translate="yes" xml:space="preserve">
          <source>The Angular &lt;code&gt;&lt;a href=&quot;../api/platform-browser/by&quot;&gt;By&lt;/a&gt;&lt;/code&gt; class has three static methods for common predicates:</source>
          <target state="translated">Angular &lt;code&gt;&lt;a href=&quot;../api/platform-browser/by&quot;&gt;By&lt;/a&gt;&lt;/code&gt; 클래스에는 공통 술어에 대한 세 가지 정적 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b679eb06adca30297563f49ac88eb9e497fa9839" translate="yes" xml:space="preserve">
          <source>The Angular &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; (&quot;the router&quot;) borrows from this model. It can interpret a browser URL as an instruction to navigate to a client-generated view. It can pass optional parameters along to the supporting view component that help it decide what specific content to present. You can bind the router to links on a page and it will navigate to the appropriate application view when the user clicks a link. You can navigate imperatively when the user clicks a button, selects from a drop box, or in response to some other stimulus from any source. And the router logs activity in the browser's history journal so the back and forward buttons work as well.</source>
          <target state="translated">Angular &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; ( &quot;라우터&quot;)는이 모델에서 차용합니다. 브라우저 URL을 클라이언트 생성보기로 이동하기위한 지시 사항으로 해석 할 수 있습니다. 표시 할 특정 컨텐츠를 결정하는 데 도움이되는 선택적보기 매개 변수를 지원보기 구성 요소에 전달할 수 있습니다. 라우터를 페이지의 링크에 바인딩 할 수 있으며 사용자가 링크를 클릭하면 적절한 응용 프로그램보기로 이동합니다. 사용자가 버튼을 클릭하거나 드롭 상자에서 선택하거나 다른 소스의 다른 자극에 반응 할 때 반드시 탐색 할 수 있습니다. 라우터는 브라우저의 기록 일지에 활동을 기록하므로 뒤로 및 앞으로 버튼도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bcb493c9e74833377850a9bc3a6c20403b7af18a" translate="yes" xml:space="preserve">
          <source>The Angular &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; NgModule provides a service that lets you define a navigation path among the different application states and view hierarchies in your app. It is modeled on the familiar browser navigation conventions:</source>
          <target state="translated">Angular &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; NgModule은 다양한 애플리케이션 상태 간의 탐색 경로를 정의하고 앱에서 계층을 볼 수있는 서비스를 제공합니다. 익숙한 브라우저 탐색 규칙에 따라 모델링됩니다.</target>
        </trans-unit>
        <trans-unit id="8b57ea74f53af589a0245e763366fd711bffc4ac" translate="yes" xml:space="preserve">
          <source>The Angular &lt;code&gt;DebugElement.triggerEventHandler&lt;/code&gt; can raise &lt;em&gt;any data-bound event&lt;/em&gt; by its &lt;em&gt;event name&lt;/em&gt;. The second parameter is the event object passed to the handler.</source>
          <target state="translated">Angular &lt;code&gt;DebugElement.triggerEventHandler&lt;/code&gt; 는 &lt;em&gt;이벤트 이름&lt;/em&gt; 별로 &lt;em&gt;모든 데이터 바운드 이벤트&lt;/em&gt; 를 발생 시킬 수 있습니다 . 두 번째 매개 변수는 핸들러로 전달 된 이벤트 오브젝트입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c3c8061180e2eb26c680deaa8488f18159bfd307" translate="yes" xml:space="preserve">
          <source>The Angular &lt;code&gt;bootstrapModule&lt;/code&gt; method has a second &lt;code&gt;compilerOptions&lt;/code&gt; parameter that can influence the behavior of the compiler. You can use it to specify the translation providers:</source>
          <target state="translated">Angular &lt;code&gt;bootstrapModule&lt;/code&gt; 메소드에는 &lt;code&gt;compilerOptions&lt;/code&gt; 의 동작에 영향을 줄 수 있는 두 번째 compilerOptions 매개 변수가 있습니다. 이를 사용하여 번역 제공자를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfa5f562ee24d3208771a463b736deb75b60079b" translate="yes" xml:space="preserve">
          <source>The Angular &lt;code&gt;currency&lt;/code&gt; pipe is similar although some of the parameters have changed.</source>
          <target state="translated">각 &lt;code&gt;currency&lt;/code&gt; 파이프는 일부 매개 변수가 변경되었지만 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="f62bb3c73f061003b3faf3aae067e7b55b5dafca" translate="yes" xml:space="preserve">
          <source>The Angular &lt;code&gt;date&lt;/code&gt; pipe is similar.</source>
          <target state="translated">각도 &lt;code&gt;date&lt;/code&gt; 파이프는 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="fcbe8e4317f36d2d4a4d3ef4bd8ffd65770ba540" translate="yes" xml:space="preserve">
          <source>The Angular &lt;code&gt;i18n&lt;/code&gt; attribute marks translatable content. Place it on every element tag whose fixed text is to be translated.</source>
          <target state="translated">Angular &lt;code&gt;i18n&lt;/code&gt; 속성은 번역 가능한 컨텐츠를 표시합니다. 고정 텍스트를 번역 할 모든 요소 태그에 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="cdf01d2b5b0c515f0663f00d093f35293facf213" translate="yes" xml:space="preserve">
          <source>The Angular &lt;code&gt;number&lt;/code&gt; pipe is similar. It provides more functionality when defining the decimal places, as shown in the second example above.</source>
          <target state="translated">각도 &lt;code&gt;number&lt;/code&gt; 파이프는 비슷합니다. 위의 두 번째 예와 같이 소수점 이하 자리를 정의 할 때 더 많은 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b99b3f86ef5c932dea53e89dd94423d13289d8bf" translate="yes" xml:space="preserve">
          <source>The Angular &lt;em&gt;NgSwitch&lt;/em&gt; is actually a set of cooperating directives: &lt;code&gt;&lt;a href=&quot;../api/common/ngswitch&quot;&gt;NgSwitch&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/common/ngswitchcase&quot;&gt;NgSwitchCase&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../api/common/ngswitchdefault&quot;&gt;NgSwitchDefault&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Angular &lt;em&gt;NgSwitch&lt;/em&gt; 는 실제로 협력 지시문 세트입니다 : &lt;code&gt;&lt;a href=&quot;../api/common/ngswitch&quot;&gt;NgSwitch&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/common/ngswitchcase&quot;&gt;NgSwitchCase&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/common/ngswitchdefault&quot;&gt;NgSwitchDefault&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04175ded62d1fec12553cfb8f3f2c9d97972748f" translate="yes" xml:space="preserve">
          <source>The Angular &lt;em&gt;fixture&lt;/em&gt; provides the component's element directly through the &lt;code&gt;fixture.nativeElement&lt;/code&gt;.</source>
          <target state="translated">Angular &lt;em&gt;Fixture&lt;/em&gt; 는 &lt;code&gt;fixture.nativeElement&lt;/code&gt; 를 통해 컴포넌트의 요소를 직접 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="75a9f1c400fe3d6b4e3401b6477de45dccf239a7" translate="yes" xml:space="preserve">
          <source>The Angular &lt;strong&gt;&lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt;&lt;/strong&gt; enables navigation from one &lt;a href=&quot;glossary#view&quot;&gt;view&lt;/a&gt; to the next as users perform application tasks.</source>
          <target state="translated">Angular &lt;strong&gt; &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 를&lt;/strong&gt; 사용하면 사용자가 응용 프로그램 작업을 수행 할 때 한보기에서 다음 &lt;a href=&quot;glossary#view&quot;&gt;보기&lt;/a&gt; 로 탐색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e0346e973842ce7bf0908428389410a777108b7" translate="yes" xml:space="preserve">
          <source>The Angular AOT compiler extracts &lt;strong&gt;metadata&lt;/strong&gt; to interpret the parts of the application that Angular is supposed to manage. You can specify the metadata explicitly in &lt;strong&gt;decorators&lt;/strong&gt; such as &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt;, or implicitly in the constructor declarations of the decorated classes. The metadata tells Angular how to construct instances of your application classes and interact with them at runtime.</source>
          <target state="translated">Angular AOT 컴파일러는 &lt;strong&gt;메타 데이터&lt;/strong&gt; 를 추출 하여 Angular가 관리해야하는 응용 프로그램 부분을 해석합니다. &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt; () 및 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt; () 과 같은 &lt;strong&gt;데코레이터&lt;/strong&gt; 에서 명시 적으로 또는 데코 레이팅 된 클래스의 생성자 선언에서 암시 적으로 메타 데이터를 지정할 수 있습니다 . 메타 데이터는 Angular에게 응용 프로그램 클래스의 인스턴스를 생성하고 런타임에 상호 작용하는 방법을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="4b8a66ad73b412d255791431bd34d06ff172ffb0" translate="yes" xml:space="preserve">
          <source>The Angular Ahead-of-Time (AOT) compiler converts your Angular HTML and TypeScript code into efficient JavaScript code during the build phase &lt;em&gt;before&lt;/em&gt; the browser downloads and runs that code. Compiling your application during the build process provides a faster rendering in the browser.</source>
          <target state="translated">AOT (Angular Ahead-of-Time) 컴파일러는 빌드 단계 에서 브라우저가 해당 코드를 다운로드하여 실행 &lt;em&gt;하기 전에&lt;/em&gt; Angular HTML 및 TypeScript 코드를 효율적인 JavaScript 코드로 변환합니다 . 빌드 프로세스 중에 응용 프로그램을 컴파일하면 브라우저에서 렌더링이 더 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="a03f8200944a32e3f51a4b6988b1c544b8ca6333" translate="yes" xml:space="preserve">
          <source>The Angular CI process runs all end-to-end tests for every Angular PR. Angular re-tests the samples after every new version of a sample and every new version of Angular itself.</source>
          <target state="translated">Angular CI 프로세스는 모든 Angular PR에 대해 모든 엔드 투 엔드 테스트를 실행합니다. Angular는 샘플의 모든 새 버전과 Angular 자체의 모든 새 버전 후에 샘플을 다시 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="fa5e030af9214f0f4cb5358ab971f2f3bbbe60cc" translate="yes" xml:space="preserve">
          <source>The Angular CLI &lt;code&gt;ng new&lt;/code&gt; command creates a workspace.</source>
          <target state="translated">Angular CLI &lt;code&gt;ng new&lt;/code&gt; 명령은 작업 공간을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="d07911428eda07c6d1e17ebfc74e10d6d40d3d5f" translate="yes" xml:space="preserve">
          <source>The Angular CLI command &lt;a href=&quot;cli/generate&quot;&gt;&lt;code&gt;ng generate component&lt;/code&gt;&lt;/a&gt; defines an empty &lt;code&gt;styles&lt;/code&gt; array when you create the component with the &lt;code&gt;--inline-style&lt;/code&gt; flag.</source>
          <target state="translated">Angular CLI 명령 &lt;a href=&quot;cli/generate&quot;&gt; &lt;code&gt;ng generate component&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;--inline-style&lt;/code&gt; 플래그 를 사용하여 구성 요소를 만들 때 빈 &lt;code&gt;styles&lt;/code&gt; 배열을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="09643dead4d1c78b462efc30f8bde1402d517017" translate="yes" xml:space="preserve">
          <source>The Angular CLI command &lt;code&gt;ng deploy&lt;/code&gt; (introduced in version 8.3.0) executes the &lt;code&gt;deploy&lt;/code&gt;&lt;a href=&quot;cli-builder&quot;&gt;CLI builder&lt;/a&gt; associated with your project. A number of third-party builders implement deployment capabilities to different platforms. You can add any of them to your project by running &lt;code&gt;ng add [package name]&lt;/code&gt;.</source>
          <target state="translated">버전 8.3.0에 도입 된 Angular CLI 명령 &lt;code&gt;ng deploy&lt;/code&gt; 는 프로젝트와 연관된 &lt;code&gt;deploy&lt;/code&gt; &lt;a href=&quot;cli-builder&quot;&gt;CLI 빌더를&lt;/a&gt; 실행합니다 . 많은 써드 파티 빌더가 다른 플랫폼에 배치 기능을 구현합니다. &lt;code&gt;ng add [package name]&lt;/code&gt; 을 실행하여 프로젝트에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a3d7512acefcea2947e134ca176993a0a2b9c106" translate="yes" xml:space="preserve">
          <source>The Angular CLI downloads and installs everything you need to test an Angular application with the &lt;a href=&quot;https://jasmine.github.io/&quot;&gt;Jasmine test framework&lt;/a&gt;.</source>
          <target state="translated">Angular CLI는 &lt;a href=&quot;https://jasmine.github.io/&quot;&gt;Jasmine 테스트 프레임 워크로&lt;/a&gt; Angular 응용 프로그램을 테스트하는 데 필요한 모든 것을 다운로드하여 설치합니다 .</target>
        </trans-unit>
        <trans-unit id="268f17b44b8897aaaa4b843da9aee7dae34c98de" translate="yes" xml:space="preserve">
          <source>The Angular CLI generated an &lt;code&gt;AppModule&lt;/code&gt; class in &lt;code&gt;src/app/app.module.ts&lt;/code&gt; when it created the project. This is where you &lt;em&gt;opt-in&lt;/em&gt; to the &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Angular CLI 는 프로젝트를 만들 때 &lt;code&gt;src/app/app.module.ts&lt;/code&gt; 에 &lt;code&gt;AppModule&lt;/code&gt; 클래스를 생성했습니다. 당신이있는 곳이다 &lt;em&gt;선택-에&lt;/em&gt; 받는 &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="107493d097ae11fbcb314a2ed3716860a96fec1b" translate="yes" xml:space="preserve">
          <source>The Angular CLI handles differential loading for you as part of the &lt;em&gt;build&lt;/em&gt; process for deployment. The &lt;code&gt;ng build&lt;/code&gt; command produces the necessary bundles used for differential loading, based on your browser support requirements and compilation target.</source>
          <target state="translated">Angular CLI는 배포를위한 &lt;em&gt;빌드&lt;/em&gt; 프로세스의 일부로 차등로드를 처리합니다. &lt;code&gt;ng build&lt;/code&gt; 명령은 브라우저 지원 요구 사항 및 컴파일 대상에 따라 차등로드에 사용되는 필요한 번들을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d5e857140d05ef6844404b8615a66b9f4c44b396" translate="yes" xml:space="preserve">
          <source>The Angular CLI includes a server, so that you can build and serve your app locally.</source>
          <target state="translated">Angular CLI에는 서버가 포함되어 있으므로 앱을 로컬에서 빌드하고 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cfbfae03eb19b3ecdbf1adb80b15d014200eb71" translate="yes" xml:space="preserve">
          <source>The Angular CLI includes a server, so that you can easily build and serve your app locally.</source>
          <target state="translated">Angular CLI에는 서버가 포함되어 있으므로 앱을 로컬에서 쉽게 빌드하고 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99240af0e017c305ac2fe38f1420a6c01c217331" translate="yes" xml:space="preserve">
          <source>The Angular CLI installs the necessary Angular &lt;code&gt;npm&lt;/code&gt; packages and other dependencies. This can take a few minutes.</source>
          <target state="translated">Angular CLI는 필요한 Angular &lt;code&gt;npm&lt;/code&gt; 패키지 및 기타 종속성을 설치합니다 . 몇 분이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44dd54dfc8964065cd90136f8e3b10b3cf1a4390" translate="yes" xml:space="preserve">
          <source>The Angular CLI installs the necessary Angular npm packages and other dependencies. This can take a few minutes.</source>
          <target state="translated">Angular CLI는 필요한 Angular npm 패키지 및 기타 종속성을 설치합니다. 몇 분이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf80b618388fecbd79473fee682b4084f17bfeb0" translate="yes" xml:space="preserve">
          <source>The Angular CLI is a command-line interface tool that you use to initialize, develop, scaffold, and maintain Angular applications directly from a command shell.</source>
          <target state="translated">Angular CLI는 명령 셸에서 직접 Angular 애플리케이션을 초기화, 개발, 스캐 폴드 및 유지 관리하는 데 사용하는 명령 줄 인터페이스 도구입니다.</target>
        </trans-unit>
        <trans-unit id="e3450aeb1031f9a687d8114c58a874fc5f5cc28c" translate="yes" xml:space="preserve">
          <source>The Angular CLI is a command-line interface tool that you use to initialize, develop, scaffold, and maintain Angular applications. You can use the tool directly in a command shell, or indirectly through an interactive UI such as &lt;a href=&quot;https://angularconsole.com&quot;&gt;Angular Console&lt;/a&gt;.</source>
          <target state="translated">Angular CLI는 Angular 응용 프로그램을 초기화, 개발, 발판 및 유지 관리하는 데 사용하는 명령 줄 인터페이스 도구입니다. 도구를 명령 셸에서 직접 사용하거나 &lt;a href=&quot;https://angularconsole.com&quot;&gt;Angular Console&lt;/a&gt; 과 같은 대화식 UI를 통해 간접적으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fae14f5aaf5497739ab1d6d16c0fd5b468b3e46c" translate="yes" xml:space="preserve">
          <source>The Angular CLI outputs warnings if it detects that your browser application depends on CommonJS modules. To disable these warnings, you can add the CommonJS module name to &lt;code&gt;allowedCommonJsDependencies&lt;/code&gt; option in the &lt;code&gt;build&lt;/code&gt; options located in &lt;code&gt;angular.json&lt;/code&gt; file.</source>
          <target state="translated">Angular CLI는 브라우저 애플리케이션이 CommonJS 모듈에 의존한다는 것을 감지하면 경고를 출력합니다. 이러한 경고를 비활성화하려면 &lt;code&gt;angular.json&lt;/code&gt; 파일 에있는 &lt;code&gt;build&lt;/code&gt; 옵션의 &lt;code&gt;allowedCommonJsDependencies&lt;/code&gt; 옵션에 CommonJS 모듈 이름을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5197f50b0a17f7cf0952ce4e36557b69ebf6c2a8" translate="yes" xml:space="preserve">
          <source>The Angular CLI performs this step automatically. The CLI also sets up a &lt;code&gt;&lt;a href=&quot;../api/router/routes&quot;&gt;Routes&lt;/a&gt;&lt;/code&gt; array for your routes and configures the &lt;code&gt;imports&lt;/code&gt; and &lt;code&gt;exports&lt;/code&gt; arrays for &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt;.</source>
          <target state="translated">Angular CLI는이 단계를 자동으로 수행합니다. CLI는 또한 &lt;code&gt;&lt;a href=&quot;../api/router/routes&quot;&gt;Routes&lt;/a&gt;&lt;/code&gt; 대한 Routes 배열을 설정하고 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt; ()에 대한 &lt;code&gt;imports&lt;/code&gt; 및 &lt;code&gt;exports&lt;/code&gt; 배열을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="755a2a64b5f04e3ccbf78d316586e03c34b19fb0" translate="yes" xml:space="preserve">
          <source>The Angular CLI performs this step for you. However, if you are creating an app manually or working with an existing, non-CLI app, verify that the imports and configuration are correct. The following is the default &lt;code&gt;AppModule&lt;/code&gt; using the CLI with the &lt;code&gt;--routing&lt;/code&gt; flag.</source>
          <target state="translated">Angular CLI가이 단계를 수행합니다. 그러나 앱을 수동으로 생성하거나 기존의 비 CLI 앱으로 작업하는 경우 가져 오기 및 구성이 올바른지 확인하십시오. 다음은 &lt;code&gt;--routing&lt;/code&gt; 플래그 와 함께 CLI를 사용 하는 기본 &lt;code&gt;AppModule&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="af511e0852aa578eafccf55c3ef084749c706727" translate="yes" xml:space="preserve">
          <source>The Angular CLI tools.</source>
          <target state="translated">각도 CLI 도구.</target>
        </trans-unit>
        <trans-unit id="e7315acf64ffba967535cd146e3b147b69209359" translate="yes" xml:space="preserve">
          <source>The Angular CLI uses two configurations for differential loading:</source>
          <target state="translated">Angular CLI는 차등 로딩에 두 가지 구성을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0b647147cda79b8b71174240ba657c01cc0282ef" translate="yes" xml:space="preserve">
          <source>The Angular Framework, Angular CLI, and components used by Angular applications are packaged as &lt;a href=&quot;https://docs.npmjs.com/getting-started/what-is-npm&quot;&gt;npm packages&lt;/a&gt; and distributed via the &lt;a href=&quot;https://docs.npmjs.com/&quot;&gt;npm registry&lt;/a&gt;.</source>
          <target state="translated">Angular 응용 프로그램에서 사용하는 Angular Framework, Angular CLI 및 구성 요소는 &lt;a href=&quot;https://docs.npmjs.com/getting-started/what-is-npm&quot;&gt;npm 패키지로 패키지&lt;/a&gt; 되어 &lt;a href=&quot;https://docs.npmjs.com/&quot;&gt;npm 레지스트리&lt;/a&gt; 를 통해 배포됩니다 .</target>
        </trans-unit>
        <trans-unit id="ac23c8d82634ad1235f0eec2bb7598c143df4b5f" translate="yes" xml:space="preserve">
          <source>The Angular Injector *</source>
          <target state="translated">각도 인젝터 *</target>
        </trans-unit>
        <trans-unit id="18be8272f01590e93bfcd42d6f4136d2716d2a98" translate="yes" xml:space="preserve">
          <source>The Angular Language Service can forewarn you of mistakes in your code. In this example, Angular doesn't know what &lt;code&gt;orders&lt;/code&gt; is or where it comes from.</source>
          <target state="translated">Angular Language Service는 코드의 실수를 미리 알려줍니다. 이 예제에서 Angular는 &lt;code&gt;orders&lt;/code&gt; 이 무엇인지 , 어디에서 왔는지 알 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6596c329e39ca54d0c7f8e5df88c15b4e19b0aaf" translate="yes" xml:space="preserve">
          <source>The Angular Language Service provides code editors with a way to get completions, errors, hints, and navigation inside Angular templates. It works with external templates in separate HTML files, and also with in-line templates.</source>
          <target state="translated">Angular Language Service는 코드 편집기에 Angular 템플릿 내에서 완료, 오류, 힌트 및 탐색을 얻는 방법을 제공합니다. 별도의 HTML 파일의 외부 템플릿과 인라인 템플릿과 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3e67a34f16363de23bed96136c061107da748ea8" translate="yes" xml:space="preserve">
          <source>The Angular Router is an optional service that presents a particular component view for a given URL. It is not part of the Angular core and thus is in its own library package, &lt;code&gt;@angular/router&lt;/code&gt;.</source>
          <target state="translated">Angular Router는 주어진 URL에 대한 특정 구성 요소보기를 제공하는 선택적 서비스입니다. Angular 코어의 일부가 아니므로 자체 라이브러리 패키지 &lt;code&gt;@angular/router&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd1cdcf22210d9763bd0c78281e3611dadc0f91d" translate="yes" xml:space="preserve">
          <source>The Angular Router is an optional service that presents a particular component view for a given URL. It is not part of the Angular core. It is in its own library package, &lt;code&gt;@angular/router&lt;/code&gt;. Import what you need from it as you would from any other Angular package.</source>
          <target state="translated">Angular Router는 지정된 URL에 대한 특정 구성 요소보기를 제공하는 선택적 서비스입니다. Angular 코어의 일부가 아닙니다. 자체 라이브러리 패키지 &lt;code&gt;@angular/router&lt;/code&gt; 있습니다. 다른 Angular 패키지에서와 마찬가지로 필요한 것을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9eb08a795c65471995e5535981ebfa362dda2718" translate="yes" xml:space="preserve">
          <source>The Angular Update Guide provides customized update instructions, based on the current and target versions that you specify. It includes basic and advanced update paths, to match the complexity of your applications. It also includes troubleshooting information and any recommended manual changes to help you get the most out of the new release.</source>
          <target state="translated">Angular Update Guide는 지정한 현재 버전과 대상 버전을 기반으로 사용자 정의 된 업데이트 지침을 제공합니다. 여기에는 응용 프로그램의 복잡성에 맞게 기본 및 고급 업데이트 경로가 포함됩니다. 또한 새 릴리스를 최대한 활용하는 데 도움이되는 문제 해결 정보 및 권장 수동 변경 사항이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b661c9f690153924a7c2703de890f3bc79be1136" translate="yes" xml:space="preserve">
          <source>The Angular ahead-of-time (AOT) compiler converts Angular HTML and TypeScript code into efficient JavaScript code during the build phase, before the browser downloads and runs that code. This is the best compilation mode for production environments, with decreased load time and increased performance compared to &lt;a href=&quot;glossary#jit&quot;&gt;just-in-time (JIT) compilation&lt;/a&gt;.</source>
          <target state="translated">AOT (Angular ahead-of-time) 컴파일러는 빌드 단계에서 브라우저가 해당 코드를 다운로드하여 실행하기 전에 Angular HTML 및 TypeScript 코드를 효율적인 JavaScript 코드로 변환합니다. 이는 &lt;a href=&quot;glossary#jit&quot;&gt;JIT (Just-In-Time) 컴파일에&lt;/a&gt; 비해로드 시간이 줄어들고 성능이 향상된 프로덕션 환경에 가장 적합한 컴파일 모드입니다 .</target>
        </trans-unit>
        <trans-unit id="20c9ec499f8aa2e01b35b329a7f155394dc66c5b" translate="yes" xml:space="preserve">
          <source>The Angular application manages what the user sees and can do, achieving this through the interaction of a component class instance (the &lt;em&gt;component&lt;/em&gt;) and its user-facing template.</source>
          <target state="translated">Angular 응용 프로그램은 사용자가보고 수행 할 수있는 작업을 관리하여 구성 요소 클래스 인스턴스 ( &lt;em&gt;구성 요소&lt;/em&gt; )와 사용자 대면 템플릿 의 상호 작용을 통해이를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="60a34b9c53677e6872367240f8da49f2a0c10121" translate="yes" xml:space="preserve">
          <source>The Angular build tools.</source>
          <target state="translated">각도 빌드 도구.</target>
        </trans-unit>
        <trans-unit id="89876cc2d5b7c9baf7d2993913b0abae3dac5cd8" translate="yes" xml:space="preserve">
          <source>The Angular compiler converts the application code you write into highly performant JavaScript code. The &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; metadata plays an important role in guiding the compilation process.</source>
          <target state="translated">Angular 컴파일러는 작성한 응용 프로그램 코드를 고성능 JavaScript 코드로 변환합니다. &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 메타 데이터가 컴파일 과정을 안내하는 데 중요한 역할을한다.</target>
        </trans-unit>
        <trans-unit id="0307d0ec8fe91a6388457b087bee98707153506e" translate="yes" xml:space="preserve">
          <source>The Angular compiler creates the &lt;code&gt;BannerComponentStub&lt;/code&gt; for the &lt;code&gt;&amp;lt;app-banner&amp;gt;&lt;/code&gt; element and applies the &lt;code&gt;RouterLinkStubDirective&lt;/code&gt; to the anchors with the &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;routerLink&lt;/a&gt;&lt;/code&gt; attribute, but it ignores the &lt;code&gt;&amp;lt;app-welcome&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; tags.</source>
          <target state="translated">각 컴파일러는 생성 &lt;code&gt;BannerComponentStub&lt;/code&gt; 에 대한 &lt;code&gt;&amp;lt;app-banner&amp;gt;&lt;/code&gt; 요소와 적용 &lt;code&gt;RouterLinkStubDirective&lt;/code&gt; 을 와 앵커에 &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;routerLink&lt;/a&gt;&lt;/code&gt; 의 특성,하지만 무시 &lt;code&gt;&amp;lt;app-welcome&amp;gt;&lt;/code&gt; 와 &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; 태그입니다.</target>
        </trans-unit>
        <trans-unit id="f2099e1bb42f72af03878b03cb23d738d02f0370" translate="yes" xml:space="preserve">
          <source>The Angular compiler extracts the metadata &lt;em&gt;once&lt;/em&gt; and generates a &lt;em&gt;factory&lt;/em&gt; for &lt;code&gt;TypicalComponent&lt;/code&gt;. When it needs to create a &lt;code&gt;TypicalComponent&lt;/code&gt; instance, Angular calls the factory, which produces a new visual element, bound to a new instance of the component class with its injected dependency.</source>
          <target state="translated">Angular 컴파일러는 메타 데이터를 &lt;em&gt;한 번&lt;/em&gt; 추출하고 &lt;code&gt;TypicalComponent&lt;/code&gt; 의 &lt;em&gt;팩토리&lt;/em&gt; 를 생성합니다 . &lt;code&gt;TypicalComponent&lt;/code&gt; 인스턴스 를 생성 해야하는 경우 Angular는 팩토리를 호출하여 새로운 시각적 요소를 생성하고 주입 된 종속성으로 컴포넌트 클래스의 새 인스턴스에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="7f25ae265c05f2ca418855270245f3c2089c6ef1" translate="yes" xml:space="preserve">
          <source>The Angular compiler finds a component or directive in a template when it can match the &lt;em&gt;selector&lt;/em&gt; of that component or directive to some HTML in that template.</source>
          <target state="translated">Angular 컴파일러는 해당 컴포넌트 또는 지시문의 &lt;em&gt;선택자를&lt;/em&gt; 해당 템플리트의 일부 HTML 과 일치시킬 수있는 경우 템플리트에서 컴포넌트 또는 지시문을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="2ec324b0b04115ae909396e8d599ab544a424d3c" translate="yes" xml:space="preserve">
          <source>The Angular compiler reads the template markup, combines it with the corresponding component class code, and emits &lt;em&gt;component factories&lt;/em&gt;.</source>
          <target state="translated">Angular 컴파일러는 템플릿 마크 업을 읽고 해당 컴포넌트 클래스 코드와 결합하여 &lt;em&gt;컴포넌트 팩토리를 생성&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f5ebc9e9914857b1641e25cdad9ec2fbf7a0b1b5" translate="yes" xml:space="preserve">
          <source>The Angular compiler, which is invoked by the Angular CLI's &lt;code&gt;ng build&lt;/code&gt; and &lt;code&gt;ng serve&lt;/code&gt; commands.</source>
          <target state="translated">Angular 컴파일러는 Angular CLI의 &lt;code&gt;ng build&lt;/code&gt; 및 &lt;code&gt;ng serve&lt;/code&gt; 명령에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="ac9db4e8ab53e00307263bffc47d982c1e256eae" translate="yes" xml:space="preserve">
          <source>The Angular extraction tool (described in &lt;a href=&quot;i18n#ng-xi18n&quot;&gt;Work with translation files&lt;/a&gt; in this guide) generates a translation unit entry for each &lt;code&gt;i18n&lt;/code&gt; attribute in a template. It assigns each translation unit a unique ID based on the &lt;em&gt;meaning&lt;/em&gt; and &lt;em&gt;description&lt;/em&gt;.</source>
          <target state="translated">각도 추출 도구 ( 이 가이드의 &lt;a href=&quot;i18n#ng-xi18n&quot;&gt;번역 파일 작업에&lt;/a&gt; 설명 됨 ) 는 템플릿의 각 &lt;code&gt;i18n&lt;/code&gt; 속성에 대한 번역 단위 항목을 생성합니다 . &lt;em&gt;의미&lt;/em&gt; 와 &lt;em&gt;설명&lt;/em&gt; 에 따라 각 번역 단위에 고유 한 ID를 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="cdc01358f63d4bea105e06d264c95e64af6796fa" translate="yes" xml:space="preserve">
          <source>The Angular extraction tool preserves both the meaning and the description in the translation source file to facilitate contextually-specific translations, but only the combination of meaning and text message are used to generate the specific id of a translation. If you have two similar text messages with different meanings, they are extracted separately. If you have two similar text messages with different descriptions (not different meanings), then they are extracted only once.</source>
          <target state="translated">각도 추출 도구는 상황 별 번역을 용이하게하기 위해 번역 소스 파일의 의미와 설명을 모두 유지하지만 번역의 특정 ID를 생성하는 데 의미와 텍스트 메시지의 조합 만 사용됩니다. 의미가 다른 두 개의 유사한 문자 메시지가있는 경우 별도로 추출됩니다. 설명이 다른 두 개의 유사한 문자 메시지 (다른 의미가 아님)가있는 경우 한 번만 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="56065a39a7119008e9a39c78658ad09336f7d947" translate="yes" xml:space="preserve">
          <source>The Angular extractor generates a file with a translation unit entry for each &lt;code&gt;i18n&lt;/code&gt; attribute in a template. As described previously (in &lt;a href=&quot;i18n#transaction-unit-ids&quot;&gt;How meanings control text extraction and merging&lt;/a&gt;), Angular assigns each translation unit a unique ID such as the following:</source>
          <target state="translated">Angular 추출기 는 템플릿의 각 &lt;code&gt;i18n&lt;/code&gt; 속성에 대한 변환 단위 항목이있는 파일을 생성합니다 . 앞서 설명한대로 ( &lt;a href=&quot;i18n#transaction-unit-ids&quot;&gt;의미가 텍스트 추출 및 병합을 제어하는 ​​방법&lt;/a&gt; 에서 ) Angular는 각 번역 단위에 다음과 같은 고유 ID를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="c7bed172ef3f576a631fea5fc78a1554b8751f9a" translate="yes" xml:space="preserve">
          <source>The Angular form discussed in this page takes advantage of the following framework features to provide support for data modification, validation, and more.</source>
          <target state="translated">이 페이지에서 설명하는 Angular 양식은 다음 프레임 워크 기능을 활용하여 데이터 수정, 유효성 검사 등을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="9401af39b6d9558ec8f95390db5e947910915008" translate="yes" xml:space="preserve">
          <source>The Angular form discussed in this page takes advantage of the following framework features to provide support for data modification, validation, and more:</source>
          <target state="translated">이 페이지에서 논의 된 Angular 형식은 다음 프레임 워크 기능을 활용하여 데이터 수정, 유효성 검사 등을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="cfa9faecdc950e49e0de1c849935984c499cc08c" translate="yes" xml:space="preserve">
          <source>The Angular framework itself is loaded as a set of JavaScript modules.</source>
          <target state="translated">Angular 프레임 워크 자체는 JavaScript 모듈 집합으로로드됩니다.</target>
        </trans-unit>
        <trans-unit id="b614d48db6c124a58526470dfe61af1ee15a7578" translate="yes" xml:space="preserve">
          <source>The Angular just-in-time (JIT) compiler converts your Angular HTML and TypeScript code into efficient JavaScript code at run time, as part of bootstrapping.</source>
          <target state="translated">JIT (Angular Just-In-Time) 컴파일러는 부트 스트랩의 일부로 런타임에 Angular HTML 및 TypeScript 코드를 효율적인 JavaScript 코드로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="105f93ad850589d58764ef97e15115bfd2d26310" translate="yes" xml:space="preserve">
          <source>The Angular microsyntax lets you configure a directive in a compact, friendly string. The microsyntax parser translates that string into attributes on the &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Angular 마이크로 구문을 사용하면 작고 친숙한 문자열로 지시문을 구성 할 수 있습니다. microsyntax 구문 분석기는 해당 문자열을 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 의 속성으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="9143f5ef451f8d1a9405683f722d57d62564c553" translate="yes" xml:space="preserve">
          <source>The Angular module is not instantiated until the app actually needs it.</source>
          <target state="translated">Angular 모듈은 앱이 실제로 필요할 때까지 인스턴스화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="07693af4435d3ea992bcd5d6d76e1a0c64d51494" translate="yes" xml:space="preserve">
          <source>The Angular module will be bootstrapped once (when requested for the first time) and the same reference will be used from that point onwards.</source>
          <target state="translated">Angular 모듈은 한 번 부트 스트랩되며 (처음 요청한 경우) 그 시점부터 동일한 참조가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="248192779b7cf444374f15b0f0bd950ae02e3662" translate="yes" xml:space="preserve">
          <source>The Angular non-null assertion operator, &lt;code&gt;!&lt;/code&gt;, serves the same purpose in an Angular template. For example, after you use &lt;a href=&quot;template-syntax#ngIf&quot;&gt;*ngIf&lt;/a&gt; to check that &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; is defined, you can assert that &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; properties are also defined.</source>
          <target state="translated">널이 아닌 어설 션 연산자 &lt;code&gt;!&lt;/code&gt; , 각도 템플릿에서 동일한 용도로 사용됩니다. 예를 들어 &lt;a href=&quot;template-syntax#ngIf&quot;&gt;* ngIf&lt;/a&gt; 를 사용 하여 &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; 이 정의 되었는지 확인한 후 &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; 속성도 정의되어 있다고 주장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8ea8a72b52be7e9e55271d6843b9cb7e8a6bc13" translate="yes" xml:space="preserve">
          <source>The Angular non-null assertion operator, &lt;code&gt;!&lt;/code&gt;, serves the same purpose in an Angular template. For example, you can assert that &lt;code&gt;item&lt;/code&gt; properties are also defined.</source>
          <target state="translated">Angular non-null 어설 션 연산자 &lt;code&gt;!&lt;/code&gt; , Angular 템플릿에서 동일한 용도로 사용됩니다. 예를 들어 &lt;code&gt;item&lt;/code&gt; 속성도 정의되어 있다고 주장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed5cca36be0033131d61848f431beb9c0a775bfc" translate="yes" xml:space="preserve">
          <source>The Angular platform is the entry point for Angular on a web page. Each page has exactly one platform, and services (such as reflection) which are common to every Angular application running on the page are bound in its scope.</source>
          <target state="translated">Angular 플랫폼은 웹 페이지에서 Angular의 진입 점입니다. 각 페이지에는 정확히 하나의 플랫폼이 있으며 페이지에서 실행되는 모든 Angular 응용 프로그램에 공통적 인 서비스 (예 : 리플렉션)는 해당 범위에 속합니다.</target>
        </trans-unit>
        <trans-unit id="655e7b4bd5e668ad1b165b930308d201753125e9" translate="yes" xml:space="preserve">
          <source>The Angular platform is the entry point for Angular on a web page. Each page has exactly one platform. Services (such as reflection) which are common to every Angular application running on the page are bound in its scope. A page's platform is initialized implicitly when a platform is created using a platform factory such as &lt;code&gt;PlatformBrowser&lt;/code&gt;, or explicitly by calling the &lt;code&gt;&lt;a href=&quot;core/createplatform&quot;&gt;createPlatform&lt;/a&gt;()&lt;/code&gt; function.</source>
          <target state="translated">Angular 플랫폼은 웹 페이지에서 Angular의 진입 점입니다. 각 페이지에는 정확히 하나의 플랫폼이 있습니다. 페이지에서 실행되는 모든 Angular 애플리케이션에 공통적 인 서비스 (예 : 리플렉션)는 해당 범위에 바인딩됩니다. 페이지의 플랫폼은 &lt;code&gt;PlatformBrowser&lt;/code&gt; 와 같은 플랫폼 팩토리를 사용하여 플랫폼이 생성 될 때 암시 적으로 초기화 되거나 &lt;code&gt;&lt;a href=&quot;core/createplatform&quot;&gt;createPlatform&lt;/a&gt;()&lt;/code&gt; 함수를 호출하여 명시 적으로 초기화 됩니다.</target>
        </trans-unit>
        <trans-unit id="2a946c6be79932ce3cd70c89889bd3ece84c512a" translate="yes" xml:space="preserve">
          <source>The Angular platform is the entry point for Angular on a web page. Each page has exactly one platform. Services (such as reflection) which are common to every Angular application running on the page are bound in its scope. A page's platform is initialized implicitly when a platform is created using a platform factory such as &lt;code&gt;PlatformBrowser&lt;/code&gt;, or explicitly by calling the &lt;code&gt;&lt;a href=&quot;createplatform&quot;&gt;createPlatform&lt;/a&gt;()&lt;/code&gt; function.</source>
          <target state="translated">Angular 플랫폼은 웹 페이지에서 Angular의 진입 점입니다. 각 페이지에는 정확히 하나의 플랫폼이 있습니다. 페이지에서 실행되는 모든 Angular 애플리케이션에 공통적 인 서비스 (예 : 리플렉션)는 해당 범위에 바인딩됩니다. 페이지의 플랫폼은 &lt;code&gt;PlatformBrowser&lt;/code&gt; 와 같은 플랫폼 팩토리를 사용하여 플랫폼이 생성 될 때 암시 적으로 초기화 되거나 &lt;code&gt;&lt;a href=&quot;createplatform&quot;&gt;createPlatform&lt;/a&gt;()&lt;/code&gt; 함수를 호출하여 명시 적으로 초기화 됩니다.</target>
        </trans-unit>
        <trans-unit id="51e83b347ed63e4f22ca0037f663340cff3e1b26" translate="yes" xml:space="preserve">
          <source>The Angular router comes with high-level animation functions that let you animate the transitions between views when a route changes. To produce an animation sequence when switching between routes, you need to define nested animation sequences. Start with the top-level component that hosts the view, and nest additional animations in the components that host the embedded views.</source>
          <target state="translated">Angular 라우터에는 경로가 변경 될 때 뷰 간 전환에 애니메이션을 적용 할 수있는 고급 애니메이션 기능이 있습니다. 경로 간 전환시 애니메이션 시퀀스를 생성하려면 중첩 된 애니메이션 시퀀스를 정의해야합니다. 뷰를 호스팅하는 최상위 구성 요소로 시작하고 포함 된 뷰를 호스팅하는 구성 요소에 추가 애니메이션을 중첩시킵니다.</target>
        </trans-unit>
        <trans-unit id="d9f0032b42360a33f96c2700f66e29a088d29c3e" translate="yes" xml:space="preserve">
          <source>The Angular router passes route parameters differently. Correct the &lt;code&gt;PhoneDetail&lt;/code&gt; component constructor to expect an injected &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; object. Extract the &lt;code&gt;phoneId&lt;/code&gt; from the &lt;code&gt;ActivatedRoute.snapshot.params&lt;/code&gt; and fetch the phone data as before:</source>
          <target state="translated">Angular 라우터는 경로 매개 변수를 다르게 전달합니다. 주입 된 &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; 오브젝트 를 예상 하도록 &lt;code&gt;PhoneDetail&lt;/code&gt; 컴포넌트 생성자를 정정하십시오 . &lt;code&gt;ActivatedRoute.snapshot.params&lt;/code&gt; 에서 &lt;code&gt;phoneId&lt;/code&gt; 를 추출하고 이전 과 같이 전화 데이터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c8b73d6430f433c7da9f2d92333b1bf0785c4de0" translate="yes" xml:space="preserve">
          <source>The Angular router service solves these problems. Using the router, you can declaratively specify application states, manage state transitions while taking care of the URL, and load bundles on demand.</source>
          <target state="translated">Angular 라우터 서비스는 이러한 문제를 해결합니다. 라우터를 사용하면 선언적으로 애플리케이션 상태를 지정하고 URL을 관리하면서 상태 전이를 관리하며 필요에 따라 번들을로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dab83935ff401e86ed6557ca14b267ff0f454743" translate="yes" xml:space="preserve">
          <source>The Angular safe navigation operator, &lt;code&gt;?&lt;/code&gt;, guards against &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values in property paths. Here, it protects against a view render failure if &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">각도 안전 탐색 연산자 &lt;code&gt;?&lt;/code&gt; 속성 경로에서 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 값 으로부터 보호 합니다. 여기에서 &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 인 경우 뷰 렌더 실패를 방지합니다 .</target>
        </trans-unit>
        <trans-unit id="8ddc74c782a2050af4c53d84e52e93568c0f322b" translate="yes" xml:space="preserve">
          <source>The Angular safe navigation operator, &lt;code&gt;?&lt;/code&gt;, guards against &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values in property paths. Here, it protects against a view render failure if &lt;code&gt;item&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">Angular 안전 탐색 연산자, &lt;code&gt;?&lt;/code&gt; , 속성 경로의 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 값 으로부터 보호 합니다. 여기서 &lt;code&gt;item&lt;/code&gt; 이 &lt;code&gt;null&lt;/code&gt; 인 경우 뷰 렌더링 실패로부터 보호합니다 .</target>
        </trans-unit>
        <trans-unit id="7fbe3e7ab9f2d469c6b7858e6a2fd9557c1f66e1" translate="yes" xml:space="preserve">
          <source>The Angular service worker can use either of two caching strategies for data resources.</source>
          <target state="translated">Angular 서비스 워커는 데이터 리소스에 대해 두 가지 캐싱 전략 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="628376db8f0ac4a5e89fdb142bdb959ca43ed0a2" translate="yes" xml:space="preserve">
          <source>The Angular service worker exposes debugging information under the &lt;code&gt;ngsw/&lt;/code&gt; virtual directory. Currently, the single exposed URL is &lt;code&gt;ngsw/&lt;a href=&quot;../api/animations/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;. Here is an example of this debug page's contents:</source>
          <target state="translated">Angular 서비스 워커는 &lt;code&gt;ngsw/&lt;/code&gt; virtual directory 아래에 디버깅 정보를 제공합니다 . 현재 노출 된 단일 URL은 &lt;code&gt;ngsw/&lt;a href=&quot;../api/animations/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 입니다. 이 디버그 페이지 내용의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af4ec1fe2fee6a89e95ee555d45246e775d5740e" translate="yes" xml:space="preserve">
          <source>The Angular service worker is a small script that runs in web browsers. From time to time, the service worker will be updated with bug fixes and feature improvements.</source>
          <target state="translated">Angular 서비스 워커는 웹 브라우저에서 실행되는 작은 스크립트입니다. 때때로 서비스 워커는 버그 수정 및 기능 개선으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="d3546f707eceba9f99b7dc3c4e5c9394adc9a4c1" translate="yes" xml:space="preserve">
          <source>The Angular service worker is aware of which versions are in use at any given moment and it cleans up versions when no tab is using them.</source>
          <target state="translated">Angular 서비스 워커는 특정 시점에 사용중인 버전을 알고 있으며 탭을 사용하지 않는 버전을 정리합니다.</target>
        </trans-unit>
        <trans-unit id="f2a5f7d21ae9f877f32d7f98ed2d1d923e4614b3" translate="yes" xml:space="preserve">
          <source>The Angular service worker is downloaded when the app is first opened and when the app is accessed after a period of inactivity. If the service worker has changed, the service worker will be updated in the background.</source>
          <target state="translated">Angular 서비스 워커는 앱을 처음 열 때와 일정 기간 사용하지 않으면 앱에 액세스 할 때 다운로드됩니다. 서비스 워커가 변경된 경우 서비스 워커는 백그라운드에서 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="a252a8e893b6b6b8b10ee8c9b4f3cd02606c9d40" translate="yes" xml:space="preserve">
          <source>The Angular service worker provides a guarantee: a running app will continue to run the same version of the app. If another instance of the app is opened in a new web browser tab, then the most current version of the app is served. As a result, that new tab can be running a different version of the app than the original tab.</source>
          <target state="translated">Angular 서비스 워커는 보증을 제공합니다. 실행중인 앱은 계속해서 동일한 버전의 앱을 실행합니다. 새 웹 브라우저 탭에서 앱의 다른 인스턴스가 열리면 최신 버전의 앱이 제공됩니다. 결과적으로 새 탭에서 원래 탭과 다른 버전의 앱을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe402d3476432010b35039b6b27c73a7e145e854" translate="yes" xml:space="preserve">
          <source>The Angular service worker's behavior follows that design goal:</source>
          <target state="translated">Angular 서비스 워커의 행동은 그 설계 목표를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="35fb47a111d3bbf54cae3962bd6417ce1c2ad683" translate="yes" xml:space="preserve">
          <source>The Angular team and many experienced Angular developers strongly recommend moving filtering and sorting logic into the component itself. The component can expose a &lt;code&gt;filteredHeroes&lt;/code&gt; or &lt;code&gt;sortedHeroes&lt;/code&gt; property and take control over when and how often to execute the supporting logic. Any capabilities that you would have put in a pipe and shared across the app can be written in a filtering/sorting service and injected into the component.</source>
          <target state="translated">Angular 팀과 많은 숙련 된 Angular 개발자는 필터링 및 정렬 논리를 구성 요소 자체로 옮기는 것이 좋습니다. 구성 요소는 &lt;code&gt;filteredHeroes&lt;/code&gt; 또는 &lt;code&gt;sortedHeroes&lt;/code&gt; 속성을 노출 하고 지원 로직을 언제, 얼마나 자주 실행할지 제어 할 수 있습니다. 파이프에 넣고 앱에서 공유 할 수있는 모든 기능은 필터링 / 정렬 서비스로 작성되어 구성 요소에 주입 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afddc4c461f42ac8c8b97eba88b298533d0bfa2c" translate="yes" xml:space="preserve">
          <source>The Angular team has worked hard to ensure Ivy is as backwards-compatible with the previous rendering engine (&quot;View Engine&quot;) as possible. However, in rare cases, minor changes were necessary to ensure that the Angular's behavior was predictable and consistent, correcting issues in the View Engine implementation. In order to smooth the transition, we have provided automated migrations wherever possible so your application and library code is migrated automatically by the CLI. That said, some applications will likely need to apply some manual updates.</source>
          <target state="translated">Angular 팀은 Ivy가 이전 렌더링 엔진 ( &quot;View Engine&quot;)과 가능한 한 역 호환되도록 열심히 노력했습니다. 그러나 드물게 Angular의 동작이 예측 가능하고 일관되게 보이도록 약간 변경하여 View Engine 구현의 문제를 수정해야했습니다. 원활한 전환을 위해 가능한 경우 자동화 된 마이그레이션을 제공하여 애플리케이션 및 라이브러리 코드가 CLI에 의해 자동으로 마이그레이션됩니다. 즉, 일부 응용 프로그램은 일부 수동 업데이트를 적용해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="caca85786341f11cf0a7293e6415cac816f540c6" translate="yes" xml:space="preserve">
          <source>The Angular template expression language employs a subset of JavaScript syntax supplemented with a few special operators for specific scenarios. The next sections cover three of these operators:</source>
          <target state="translated">Angular 템플릿 표현 언어는 특정 시나리오를 위해 몇 가지 특수 연산자가 추가 된 JavaScript 구문의 하위 집합을 사용합니다. 다음 섹션에서는 다음 세 가지 연산자를 다룹니다.</target>
        </trans-unit>
        <trans-unit id="cbe6f2f94a12a95461a34df7f7964259a25e067b" translate="yes" xml:space="preserve">
          <source>The Angular testing utilities include the &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;../api/core/testing/componentfixture&quot;&gt;ComponentFixture&lt;/a&gt;&lt;/code&gt;, and a handful of functions that control the test environment. The &lt;a href=&quot;testing#testbed-api-summary&quot;&gt;&lt;em&gt;TestBed&lt;/em&gt;&lt;/a&gt; and &lt;a href=&quot;testing#component-fixture-api-summary&quot;&gt;&lt;em&gt;ComponentFixture&lt;/em&gt;&lt;/a&gt; classes are covered separately.</source>
          <target state="translated">Angular 테스트 유틸리티에는 &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/core/testing/componentfixture&quot;&gt;ComponentFixture&lt;/a&gt;&lt;/code&gt; 및 테스트 환경을 제어하는 ​​소수의 함수가 포함됩니다. &lt;a href=&quot;testing#testbed-api-summary&quot;&gt;&lt;em&gt;테스트 베드&lt;/em&gt;&lt;/a&gt; 및 &lt;a href=&quot;testing#component-fixture-api-summary&quot;&gt;&lt;em&gt;ComponentFixture&lt;/em&gt;&lt;/a&gt; 클래스는 별도로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="0f47a7ce39ae098185a294fd9d6afdc9374f5cc2" translate="yes" xml:space="preserve">
          <source>The Angular testing utilities include the &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;../api/core/testing/componentfixture&quot;&gt;ComponentFixture&lt;/a&gt;&lt;/code&gt;, and a handful of functions that control the test environment. The &lt;a href=&quot;testing-utility-apis#testbed-api-summary&quot;&gt;&lt;em&gt;TestBed&lt;/em&gt;&lt;/a&gt; and &lt;a href=&quot;testing-utility-apis#component-fixture-api-summary&quot;&gt;&lt;em&gt;ComponentFixture&lt;/em&gt;&lt;/a&gt; classes are covered separately.</source>
          <target state="translated">Angular 테스트 유틸리티에는 &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/core/testing/componentfixture&quot;&gt;ComponentFixture&lt;/a&gt;&lt;/code&gt; 및 테스트 환경을 제어하는 ​​몇 가지 기능이 포함됩니다. &lt;a href=&quot;testing-utility-apis#testbed-api-summary&quot;&gt;&lt;em&gt;테스트 베드&lt;/em&gt;&lt;/a&gt; 및 &lt;a href=&quot;testing-utility-apis#component-fixture-api-summary&quot;&gt;&lt;em&gt;ComponentFixture&lt;/em&gt;&lt;/a&gt; 클래스는 별도로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="00e6647d8c4f5f646f29b66e47261762ef67b7c3" translate="yes" xml:space="preserve">
          <source>The Angular workspace where the user has installed your library contains multiple projects (applications and libraries). The user can specify the project on the command line, or allow it to default. In either case, your code needs to identify the specific project to which this schematic is being applied, so that you can retrieve information from the project configuration.</source>
          <target state="translated">사용자가 라이브러리를 설치 한 Angular 작업 공간에는 여러 프로젝트 (응용 프로그램 및 라이브러리)가 있습니다. 사용자는 명령 행에서 프로젝트를 지정하거나 기본값으로 설정할 수 있습니다. 두 경우 모두 코드에서이 회로도를 적용 할 특정 프로젝트를 식별해야 프로젝트 구성에서 정보를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37b60b160b483ff496036f979d0455b028438655" translate="yes" xml:space="preserve">
          <source>The AngularJS &lt;code&gt;$injector&lt;/code&gt; for the upgrade application.</source>
          <target state="translated">업그레이드 애플리케이션을위한 AngularJS &lt;code&gt;$injector&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d5315ae95f5757a73971de6b5edb7c0835d0995" translate="yes" xml:space="preserve">
          <source>The AngularJS &lt;code&gt;&lt;a href=&quot;upgrademodule#%24injector&quot;&gt;$injector&lt;/a&gt;&lt;/code&gt; for the upgrade application.</source>
          <target state="translated">업그레이드 응용 프로그램을위한 AngularJS &lt;code&gt;&lt;a href=&quot;upgrademodule#%24injector&quot;&gt;$injector&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="423653fbea2bc7af48c7bd9f46190694e996131f" translate="yes" xml:space="preserve">
          <source>The AngularJS directive had a &lt;code&gt;checkmark&lt;/code&gt;&lt;em&gt;filter&lt;/em&gt;. Turn that into an Angular &lt;strong&gt;pipe&lt;/strong&gt;.</source>
          <target state="translated">AngularJS 지시문에는 확인 &lt;code&gt;checkmark&lt;/code&gt; &lt;em&gt;필터가&lt;/em&gt; 있습니다. 이것을 앵귤러 &lt;strong&gt;파이프&lt;/strong&gt; 로 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="af1fbf592b50c90c013c4592c8797fd707e0871b" translate="yes" xml:space="preserve">
          <source>The AngularJS injector has an AngularJS router dependency called &lt;code&gt;$routeParams&lt;/code&gt;, which was injected into &lt;code&gt;PhoneDetails&lt;/code&gt; when it was still an AngularJS controller. You intend to inject it into the new &lt;code&gt;PhoneDetailsComponent&lt;/code&gt;.</source>
          <target state="translated">AngularJS 인젝터에는 &lt;code&gt;$routeParams&lt;/code&gt; 라는 AngularJS 라우터 종속성 이 있으며, 여전히 AngularJS 컨트롤러 일 때 &lt;code&gt;PhoneDetails&lt;/code&gt; 에 삽입되었습니다 . 새 &lt;code&gt;PhoneDetailsComponent&lt;/code&gt; 에 삽입하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="5d426c6e68e95c3032932fd384898742c4cdf7d7" translate="yes" xml:space="preserve">
          <source>The AoT compiler does not support tagged template expressions; avoid them in metadata expressions.</source>
          <target state="translated">AoT 컴파일러는 태그가 지정된 템플릿 표현식을 지원하지 않습니다. 메타 데이터 표현식에서는 피하십시오.</target>
        </trans-unit>
        <trans-unit id="319355695648b782b2ef8282fd1ba6b0fb5992ad" translate="yes" xml:space="preserve">
          <source>The Application Shell</source>
          <target state="translated">응용 프로그램 셸</target>
        </trans-unit>
        <trans-unit id="07d707d654b9db1b392eb58df6d0436c1594d090" translate="yes" xml:space="preserve">
          <source>The Architect target to run.</source>
          <target state="translated">실행할 Architect 대상입니다.</target>
        </trans-unit>
        <trans-unit id="e4be9c76b0e4b71fda293faca97b9a6d8c0bdc15" translate="yes" xml:space="preserve">
          <source>The Architect tool provides a set of builders. The &lt;a href=&quot;cli/new&quot;&gt;&lt;code&gt;ng new&lt;/code&gt; command&lt;/a&gt; provides a set of targets for the initial application project. The &lt;a href=&quot;cli/generate#application&quot;&gt;&lt;code&gt;ng generate application&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;cli/generate#library&quot;&gt;&lt;code&gt;ng generate library&lt;/code&gt;&lt;/a&gt; commands provide a set of targets for each new &lt;a href=&quot;glossary#project&quot;&gt;project&lt;/a&gt;. These targets, their options and configurations, can be customized to meet the needs of your project. For example, you may want to add a &quot;staging&quot; or &quot;testing&quot; configuration to a project's &quot;build&quot; target.</source>
          <target state="translated">Architect 도구는 빌더 세트를 제공합니다. &lt;a href=&quot;cli/new&quot;&gt; &lt;code&gt;ng new&lt;/code&gt; 명령은&lt;/a&gt; 초기 응용 프로그램 프로젝트 목표의 집합을 제공합니다. 는 &lt;a href=&quot;cli/generate#application&quot;&gt; &lt;code&gt;ng generate application&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;cli/generate#library&quot;&gt; &lt;code&gt;ng generate library&lt;/code&gt; &lt;/a&gt; 명령은 각각의 새로운에 대한 목표 세트 제공 &lt;a href=&quot;glossary#project&quot;&gt;프로젝트를&lt;/a&gt; . 이러한 목표, 옵션 및 구성은 프로젝트 요구에 맞게 사용자 정의 할 수 있습니다. 예를 들어 프로젝트의 &quot;빌드&quot;대상에 &quot;스테이징&quot;또는 &quot;테스트&quot;구성을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98622091c7e082d28fb1d1aee12f2d15a684fd7e" translate="yes" xml:space="preserve">
          <source>The Async pipe saves boilerplate in the component code. The component doesn't have to subscribe to the async data source, extract the resolved values and expose them for binding, and have to unsubscribe when it's destroyed (a potent source of memory leaks).</source>
          <target state="translated">비동기 파이프는 상용구를 구성 요소 코드에 저장합니다. 컴포넌트는 비동기 데이터 소스를 구독 할 필요가없고, 확인 된 값을 추출하여 바인딩을 위해 노출하고, 파괴 될 때 구독을 취소해야합니다 (메모리 누수의 강력한 소스).</target>
        </trans-unit>
        <trans-unit id="a093f7952b1838c4dd6aeda28ea5e1fc38030960" translate="yes" xml:space="preserve">
          <source>The Basics</source>
          <target state="translated">기초</target>
        </trans-unit>
        <trans-unit id="d038565a16aac226bd4ac01c0d0edf10f676271a" translate="yes" xml:space="preserve">
          <source>The Boolean expression to evaluate as the condition for showing a template.</source>
          <target state="translated">템플릿을 표시하기위한 조건으로 평가할 부울 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="b00950b6c88ca36515aea3fda70a4337ec7e16d4" translate="yes" xml:space="preserve">
          <source>The Browserslist configuration allows you to ignore browsers without ES2015 support. In this case, a single build is produced.</source>
          <target state="translated">Browserslist 구성을 사용하면 ES2015가 지원되지 않는 브라우저를 무시할 수 있습니다. 이 경우 단일 빌드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="d7567b31beb9558ff7dba046ce91751f2b441018" translate="yes" xml:space="preserve">
          <source>The Browserslist configuration file is included in your application &lt;a href=&quot;file-structure#application-configuration-files&quot;&gt;project structure&lt;/a&gt; and provides the minimum browsers your application supports. See the &lt;a href=&quot;https://github.com/browserslist/browserslist&quot;&gt;Browserslist spec&lt;/a&gt; for complete configuration options.</source>
          <target state="translated">Browserslist 구성 파일은 애플리케이션 &lt;a href=&quot;file-structure#application-configuration-files&quot;&gt;프로젝트 구조에&lt;/a&gt; 포함되어 있으며 애플리케이션이 지원하는 최소 브라우저를 제공합니다. 전체 구성 옵션 은 &lt;a href=&quot;https://github.com/browserslist/browserslist&quot;&gt;Browserslist 사양&lt;/a&gt; 을 참조 하세요.</target>
        </trans-unit>
        <trans-unit id="a8e793e92efbd3bfda3b03dee3bd1b71b6e869ea" translate="yes" xml:space="preserve">
          <source>The CLI &lt;code&gt;build&lt;/code&gt; command uses a different builder and invokes a different build tool for libraries than it does for applications.</source>
          <target state="translated">CLI &lt;code&gt;build&lt;/code&gt; 명령은 다른 빌더를 사용하고 애플리케이션의 라이브러리와 다른 빌드 도구를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="cefa3504277e4ce69bb8bd444d4e3b698be704b2" translate="yes" xml:space="preserve">
          <source>The CLI Builder API includes progress and status reporting tools, which can provide hints for certain functions and interfaces.</source>
          <target state="translated">CLI Builder API에는 특정 기능 및 인터페이스에 대한 힌트를 제공 할 수있는 진행 및 상태보고 도구가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a227bf9384f47a8e8130c6145e670165e7b6db89" translate="yes" xml:space="preserve">
          <source>The CLI Builder API provides a new way of changing the behavior of the Angular CLI by using builders to execute custom logic.</source>
          <target state="translated">CLI Builder API는 빌더를 사용하여 사용자 정의 논리를 실행하여 Angular CLI의 동작을 변경하는 새로운 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="497aad274b240601c7f91912c8f56b2c07944aa0" translate="yes" xml:space="preserve">
          <source>The CLI also adds &lt;code&gt;RouterModule.forChild(routes)&lt;/code&gt; to feature routing modules. This way, Angular knows that the route list is only responsible for providing additional routes and is intended for feature modules. You can use &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forChild&quot;&gt;forChild()&lt;/a&gt;&lt;/code&gt; in multiple modules.</source>
          <target state="translated">CLI는 또한 &lt;code&gt;RouterModule.forChild(routes)&lt;/code&gt; 모듈에 RouterModule.forChild (routes) 를 추가 합니다. 이런 식으로 Angular는 경로 목록이 추가 경로를 제공 할 책임이 있으며 기능 모듈을위한 것임을 알고 있습니다. 여러 모듈에서 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forChild&quot;&gt;forChild()&lt;/a&gt;&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e003e455d02dc123a8ac974ae7c477f9d1f63b09" translate="yes" xml:space="preserve">
          <source>The CLI also adds &lt;code&gt;RouterModule.forChild(routes)&lt;/code&gt; to feature routing modules. This way, Angular knows that the route list is only responsible for providing additional routes and is intended for feature modules. You can use &lt;code&gt;forChild()&lt;/code&gt; in multiple modules.</source>
          <target state="translated">또한 CLI는 기능 라우팅 모듈에 &lt;code&gt;RouterModule.forChild(routes)&lt;/code&gt; 를 추가 합니다. 이런 식으로 Angular는 경로 목록이 추가 경로를 제공하는 역할 만 담당하며 기능 모듈을위한 것임을 알고 있습니다. 여러 모듈에서 &lt;code&gt;forChild()&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8fc535c7f2308b068ad4b9779b7f1680bc5ff6a5" translate="yes" xml:space="preserve">
          <source>The CLI automatically added each feature module to the routes map at the application level. Finish this off by adding the default route. In &lt;code&gt;AppRoutingModule&lt;/code&gt;, update the &lt;code&gt;routes&lt;/code&gt; array with the following:</source>
          <target state="translated">CLI는 애플리케이션 레벨에서 각 기능 모듈을 라우트 맵에 자동으로 추가했습니다. 기본 경로를 추가하여이 작업을 완료하십시오. 에서 &lt;code&gt;AppRoutingModule&lt;/code&gt; 업데이트 &lt;code&gt;routes&lt;/code&gt; 다음과 배열을 :</target>
        </trans-unit>
        <trans-unit id="4d4a19df84ae241a7d6d36271e33ebbc2de83a13" translate="yes" xml:space="preserve">
          <source>The CLI automatically added each feature module to the routes map at the application level. Finish this off by adding the default route. In the &lt;code&gt;app-routing.module.ts&lt;/code&gt; file, update the &lt;code&gt;routes&lt;/code&gt; array with the following:</source>
          <target state="translated">CLI는 애플리케이션 수준에서 각 기능 모듈을 경로 맵에 자동으로 추가했습니다. 기본 경로를 추가하여 완료하십시오. 에서 &lt;code&gt;app-routing.module.ts&lt;/code&gt; 파일 업데이트 &lt;code&gt;routes&lt;/code&gt; 다음과 배열을 :</target>
        </trans-unit>
        <trans-unit id="40e4396ee6ff6f7efc8d22f8aab7c357291cb2d8" translate="yes" xml:space="preserve">
          <source>The CLI automatically appends &lt;code&gt;&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt;, so if you were to write &lt;code&gt;first-component&lt;/code&gt;, your component would be &lt;code&gt;FirstComponentComponent&lt;/code&gt;.</source>
          <target state="translated">CLI는 자동으로 &lt;code&gt;&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; 를 추가 하므로 &lt;code&gt;first-component&lt;/code&gt; 를 작성하는 경우 구성 요소는 &lt;code&gt;FirstComponentComponent&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="9e89170bf76b307b4155c5c76bc1a7193e2cfc09" translate="yes" xml:space="preserve">
          <source>The CLI build process runs the pertinent CSS preprocessor.</source>
          <target state="translated">CLI 빌드 프로세스는 관련 CSS 프리 프로세서를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="ec9a848601bcc0ff8bb0d93ca86877e1c801c9a0" translate="yes" xml:space="preserve">
          <source>The CLI can run unit tests and create code coverage reports. Code coverage reports show you any parts of our code base that may not be properly tested by your unit tests.</source>
          <target state="translated">CLI는 단위 테스트를 실행하고 코드 범위 보고서를 작성할 수 있습니다. 코드 적용 범위 보고서는 코드 테스트에서 단위 테스트로 제대로 테스트되지 않은 부분을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="09ef963a966d76d23f313b59169f46873874e2f7" translate="yes" xml:space="preserve">
          <source>The CLI can run unit tests and create code coverage reports. Code coverage reports show you any parts of your code base that may not be properly tested by your unit tests.</source>
          <target state="translated">CLI는 단위 테스트를 실행하고 코드 검사 보고서를 생성 할 수 있습니다. 코드 커버리지 보고서는 단위 테스트에서 제대로 테스트되지 않을 수있는 코드베이스의 모든 부분을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="cde5e1cc27e1ba5721adcfdbc19a938b7153a4a7" translate="yes" xml:space="preserve">
          <source>The CLI command &lt;code&gt;ng new&lt;/code&gt; creates a &lt;code&gt;package.json&lt;/code&gt; file when it creates the new workspace. This &lt;code&gt;package.json&lt;/code&gt; is used by all projects in the workspace, including the initial app project that is created by the CLI when it creates the workspace.</source>
          <target state="translated">CLI 명령 &lt;code&gt;ng new&lt;/code&gt; 생성 &lt;code&gt;package.json&lt;/code&gt; 의 는 새로운 작업 공간을 만들 때 파일을. 이 &lt;code&gt;package.json&lt;/code&gt; 은 작업 공간을 작성할 때 CLI에 의해 작성된 초기 앱 프로젝트를 포함하여 작업 공간의 모든 프로젝트에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="107cf47d31ef2dc53110f777a2ab23d698cd86c8" translate="yes" xml:space="preserve">
          <source>The CLI creates &lt;code&gt;src/app/highlight.directive.ts&lt;/code&gt;, a corresponding test file &lt;code&gt;src/app/highlight.directive.spec.ts&lt;/code&gt;, and &lt;em&gt;declares&lt;/em&gt; the directive class in the root &lt;code&gt;AppModule&lt;/code&gt;.</source>
          <target state="translated">CLI는 생성 &lt;code&gt;src/app/highlight.directive.ts&lt;/code&gt; , 해당 테스트 파일 &lt;code&gt;src/app/highlight.directive.spec.ts&lt;/code&gt; 하고, &lt;em&gt;선언&lt;/em&gt; 루트의 지시 클래스 &lt;code&gt;AppModule&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="43f97c1cdef4a721c1e2980898de65659eac4823" translate="yes" xml:space="preserve">
          <source>The CLI creates a new folder, &lt;code&gt;src/app/heroes/&lt;/code&gt;, and generates the three files of the &lt;code&gt;HeroesComponent&lt;/code&gt; along with a test file.</source>
          <target state="translated">CLI는 &lt;code&gt;src/app/heroes/&lt;/code&gt; 라는 새 폴더를 만들고 테스트 파일과 함께 &lt;code&gt;HeroesComponent&lt;/code&gt; 의 세 파일을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="562195fe3077662b5420503e57124701828dc0ad" translate="yes" xml:space="preserve">
          <source>The CLI creates a new workspace and a simple Welcome app, ready to run.</source>
          <target state="translated">CLI는 실행할 준비가 된 새 작업 공간과 간단한 시작 앱을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c76b8649bdc58625eb3fdf9b951e9796dccced1c" translate="yes" xml:space="preserve">
          <source>The CLI creates an initial test file for you by default when you ask it to generate a new component.</source>
          <target state="translated">CLI는 새 구성 요소를 생성하도록 요청할 때 기본적으로 초기 테스트 파일을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="b481cc4f2e36d975cb69b55ee8a2ea791c24d3e5" translate="yes" xml:space="preserve">
          <source>The CLI creates the component files in the &lt;code&gt;src/app/&lt;a href=&quot;../api/service-worker/swpush#messages&quot;&gt;messages&lt;/a&gt;&lt;/code&gt; folder and declares the &lt;code&gt;MessagesComponent&lt;/code&gt; in &lt;code&gt;AppModule&lt;/code&gt;.</source>
          <target state="translated">CLI는 &lt;code&gt;src/app/&lt;a href=&quot;../api/service-worker/swpush#messages&quot;&gt;messages&lt;/a&gt;&lt;/code&gt; 폴더 에 컴포넌트 파일을 작성하고 &lt;code&gt;AppModule&lt;/code&gt; 에 &lt;code&gt;MessagesComponent&lt;/code&gt; 를 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="f634da899e07e330e3945989266198f9dd7248a3" translate="yes" xml:space="preserve">
          <source>The CLI creates the component files in the &lt;code&gt;src/app/messages&lt;/code&gt; folder and declares the &lt;code&gt;MessagesComponent&lt;/code&gt; in &lt;code&gt;AppModule&lt;/code&gt;.</source>
          <target state="translated">CLI는 &lt;code&gt;src/app/messages&lt;/code&gt; 폴더 에 구성 요소 파일을 만들고 &lt;code&gt;AppModule&lt;/code&gt; 에서 &lt;code&gt;MessagesComponent&lt;/code&gt; 를 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="c2fe0f772eeb3a795c33f5730abf4513989e1ce6" translate="yes" xml:space="preserve">
          <source>The CLI does not support running Angular itself in a web worker.</source>
          <target state="translated">CLI는 웹 작업자에서 Angular 자체를 실행하는 것을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d7552e6edb702636aac502cd8cfd91bc772afa18" translate="yes" xml:space="preserve">
          <source>The CLI generated a test file for the &lt;code&gt;AppComponent&lt;/code&gt; named &lt;code&gt;app.component.spec.ts&lt;/code&gt;.</source>
          <target state="translated">CLI는 &lt;code&gt;AppComponent&lt;/code&gt; 라는 &lt;code&gt;app.component.spec.ts&lt;/code&gt; 대한 테스트 파일을 생성했습니다 .</target>
        </trans-unit>
        <trans-unit id="c07dc10a94742c4bb5a9957fc3001dbe354c0f3e" translate="yes" xml:space="preserve">
          <source>The CLI generated three metadata properties:</source>
          <target state="translated">CLI는 세 가지 메타 데이터 특성을 생성했습니다.</target>
        </trans-unit>
        <trans-unit id="e487350ab467b6173a436d5d4ae9f4ad9e39868c" translate="yes" xml:space="preserve">
          <source>The CLI generates the files for the &lt;code&gt;DashboardComponent&lt;/code&gt; and declares it in &lt;code&gt;AppModule&lt;/code&gt;.</source>
          <target state="translated">CLI는 &lt;code&gt;DashboardComponent&lt;/code&gt; 에 대한 파일을 생성하고 &lt;code&gt;AppModule&lt;/code&gt; 에 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="f2fb1c8beb04af8f237714937dc1863d998eb460" translate="yes" xml:space="preserve">
          <source>The CLI generates the three &lt;code&gt;HeroSearchComponent&lt;/code&gt; files and adds the component to the &lt;code&gt;AppModule&lt;/code&gt; declarations.</source>
          <target state="translated">CLI는 3 개의 &lt;code&gt;HeroSearchComponent&lt;/code&gt; 파일을 생성 하고 &lt;code&gt;AppModule&lt;/code&gt; 선언에 컴포넌트를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="447927c37568dec9cf9cbd281c45494d91a9a56c" translate="yes" xml:space="preserve">
          <source>The CLI loads and registers the locale data, places each generated version in a locale-specific directory to keep it separate from other locale versions, and puts the directories within the configured &lt;code&gt;outputPath&lt;/code&gt; for the project. For each application variant the &lt;code&gt;lang&lt;/code&gt; attribute of the &lt;code&gt;html&lt;/code&gt; element is set to the locale. The CLI also adjusts the HTML base HREF for each version of the app by adding the locale to the configured &lt;code&gt;baseHref&lt;/code&gt;.</source>
          <target state="translated">CLI는 로케일 데이터를로드 및 등록하고, 생성 된 각 버전을 로케일 별 디렉토리에 배치하여 다른 로케일 버전과 별도로 유지하고 , 프로젝트에 대해 구성된 &lt;code&gt;outputPath&lt;/code&gt; 내에 디렉토리를 배치합니다 . 각 애플리케이션 변형 에 대해 &lt;code&gt;html&lt;/code&gt; 요소 의 &lt;code&gt;lang&lt;/code&gt; 속성은 로케일로 설정됩니다. CLI는 또한 구성된 &lt;code&gt;baseHref&lt;/code&gt; 에 로케일을 추가하여 앱의 각 버전에 대한 HTML 기본 HREF를 조정합니다 .</target>
        </trans-unit>
        <trans-unit id="0a865953b65c01bef1508b821a18a24c3ddf118b" translate="yes" xml:space="preserve">
          <source>The CLI project is now set up to use the Angular service worker.</source>
          <target state="translated">CLI 프로젝트는 이제 Angular 서비스 워커를 사용하도록 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="a5d9a740a1ce9aabea72ad09bde9b5b2a4edf30b" translate="yes" xml:space="preserve">
          <source>The CLI queries the Browserslist configuration, and checks the &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkwithhref#target&quot;&gt;target&lt;/a&gt;&lt;/code&gt; to determine if support for legacy browsers is required. The combination of these two configurations determines whether multiple bundles are produced when you create a &lt;em&gt;build&lt;/em&gt;. When you create a development build using &lt;a href=&quot;cli/build&quot;&gt;&lt;code&gt;ng build&lt;/code&gt;&lt;/a&gt; and differential loading is enabled, the output produced is simpler and easier to debug, allowing you to rely less on sourcemaps of compiled code. When you create a production build using &lt;a href=&quot;cli/build&quot;&gt;&lt;code&gt;ng build --prod&lt;/code&gt;&lt;/a&gt;, the CLI uses the defined configurations above to determine the bundles to build for deployment of your application.</source>
          <target state="translated">CLI는 Browserslist 구성을 조회하고 &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkwithhref#target&quot;&gt;target&lt;/a&gt;&lt;/code&gt; 을 검사하여 레거시 브라우저에 대한 지원이 필요한지 판별합니다. 이 두 구성의 조합은 &lt;em&gt;빌드&lt;/em&gt; 를 작성할 때 여러 번들이 생성되는지 여부를 결정합니다 . &lt;a href=&quot;cli/build&quot;&gt; &lt;code&gt;ng build&lt;/code&gt; &lt;/a&gt; 빌드를 사용하여 개발 빌드를 작성 하고 차등로드를 사용하면 생성 된 출력이 더 단순하고 디버그하기 쉬워 컴파일 된 코드의 소스 맵에 덜 의존 할 수 있습니다. &lt;a href=&quot;cli/build&quot;&gt; &lt;code&gt;ng build --prod&lt;/code&gt; 를&lt;/a&gt; 사용하여 프로덕션 빌드를 작성할 때 CLI는 위에 정의 된 구성을 사용하여 애플리케이션 배치를 위해 빌드 할 번들을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="9ab80ceb4180fea29dd3ed369dd71b4e773daaf8" translate="yes" xml:space="preserve">
          <source>The CLI runs the &lt;a href=&quot;https://github.com/angular/angular-cli/tree/master/packages/%40ngtools/webpack&quot;&gt;Angular Ahead-of-Time Webpack Plugin&lt;/a&gt; which automatically recognizes lazy-loaded &lt;code&gt;NgModules&lt;/code&gt; and creates separate bundles for them.</source>
          <target state="translated">CLI는 지연로드 된 &lt;code&gt;NgModules&lt;/code&gt; 를 자동으로 인식 하고 별도의 번들을 작성 하는 &lt;a href=&quot;https://github.com/angular/angular-cli/tree/master/packages/%40ngtools/webpack&quot;&gt;Angular Ahead-of-Time Webpack 플러그인&lt;/a&gt; 을 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="9f77f83623d98ca08196d70d7b704bf6aab56a56" translate="yes" xml:space="preserve">
          <source>The CLI runs the &lt;a href=&quot;https://github.com/angular/angular-cli/tree/master/packages/ngtools/webpack&quot;&gt;Angular Ahead-of-Time Webpack Plugin&lt;/a&gt; which automatically recognizes lazy-loaded &lt;code&gt;NgModules&lt;/code&gt; and creates separate bundles for them.</source>
          <target state="translated">CLI는 지연로드 된 &lt;code&gt;NgModules&lt;/code&gt; 를 자동으로 인식 하고 별도의 번들을 생성 하는 &lt;a href=&quot;https://github.com/angular/angular-cli/tree/master/packages/ngtools/webpack&quot;&gt;Angular Ahead-of-Time Webpack 플러그인&lt;/a&gt; 을 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="5525140bd0a8e5581222783db91519ae612bd0be" translate="yes" xml:space="preserve">
          <source>The CLI takes care of Jasmine and Karma configuration for you.</source>
          <target state="translated">CLI는 Jasmine 및 Karma 구성을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="f3acaf66dda92c0d17299abf2258305e56011531" translate="yes" xml:space="preserve">
          <source>The CLI uses &lt;a href=&quot;https://github.com/postcss/autoprefixer&quot;&gt;Autoprefixer&lt;/a&gt; to ensure compatibility with different browser and browser versions. You may find it necessary to target specific browsers or exclude certain browser versions from your build.</source>
          <target state="translated">CLI는 &lt;a href=&quot;https://github.com/postcss/autoprefixer&quot;&gt;Autoprefixer&lt;/a&gt; 를 사용 하여 다른 브라우저 및 브라우저 버전과의 호환성을 보장합니다. 특정 브라우저를 대상으로하거나 빌드에서 특정 브라우저 버전을 제외해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a0e6928ac9fe75ef6b546726ef4323cbed6b649" translate="yes" xml:space="preserve">
          <source>The CSS &lt;code&gt;selector&lt;/code&gt; in the &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; decorator specifies an element named &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt;. That element is a placeholder in the body of your &lt;code&gt;index.html&lt;/code&gt; file:</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt; 데코레이터 의 CSS &lt;code&gt;selector&lt;/code&gt; 는 &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; 라는 요소를 지정합니다 . 이 요소는 &lt;code&gt;index.html&lt;/code&gt; 파일 본문의 자리 표시 자입니다 .</target>
        </trans-unit>
        <trans-unit id="740e3c1cdea94a0c07c6e845612438b44c70c7e2" translate="yes" xml:space="preserve">
          <source>The CSS classes are updated as follows, depending on the type of the expression evaluation:</source>
          <target state="translated">표현식 평가 유형에 따라 CSS 클래스가 다음과 같이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="e54eff89405ec8c10d6f19133fc3bf85e640c99e" translate="yes" xml:space="preserve">
          <source>The CSS selector for this query.</source>
          <target state="translated">이 쿼리의 CSS 선택기</target>
        </trans-unit>
        <trans-unit id="6c7f73c45ff8c0130785cd941b19dfcbde5b8c0e" translate="yes" xml:space="preserve">
          <source>The CSS selector that identifies this directive in a template and triggers instantiation of the directive.</source>
          <target state="translated">템플릿에서이 지시문을 식별하고 지시문의 인스턴스화를 트리거하는 CSS 선택기입니다.</target>
        </trans-unit>
        <trans-unit id="9bfcb014ac0d0ab03137c5b7b21ee99ad5558efe" translate="yes" xml:space="preserve">
          <source>The CSS styles associated with this state.</source>
          <target state="translated">이 상태와 관련된 CSS 스타일.</target>
        </trans-unit>
        <trans-unit id="46f17cd8fea6f967e28bec5eeaa4def431c17955" translate="yes" xml:space="preserve">
          <source>The ChangeDetectorRef for the component</source>
          <target state="translated">구성 요소의 ChangeDetectorRef</target>
        </trans-unit>
        <trans-unit id="ca1d76d56eaeb3857a3b30c857a59305b798ada4" translate="yes" xml:space="preserve">
          <source>The ComponentFactoryResolver to get hold of the ComponentFactories declared in the &lt;code&gt;entryComponents&lt;/code&gt; property of the module.</source>
          <target state="translated">모듈 의 &lt;code&gt;entryComponents&lt;/code&gt; 속성에 선언 된 ComponentFactories를 가져 오는 ComponentFactoryResolver</target>
        </trans-unit>
        <trans-unit id="719c39204c291cea2ecbc86a653ba0b9ba5cac48" translate="yes" xml:space="preserve">
          <source>The DI framework lets you supply data to a component from an injectable &lt;em&gt;service&lt;/em&gt; class, defined in its own file. To demonstrate, we'll create an injectable service class that provides a list of heroes, and register that class as a provider of that service.</source>
          <target state="translated">DI 프레임 워크를 사용하면 자체 파일에 정의 된 주사 가능한 &lt;em&gt;서비스&lt;/em&gt; 클래스 의 구성 요소에 데이터를 제공 할 수 있습니다 . 시연을 위해 영웅 목록을 제공하는 주사 가능한 서비스 클래스를 만들고 해당 클래스를 해당 서비스의 공급자로 등록합니다.</target>
        </trans-unit>
        <trans-unit id="a6e4d23b100081f1b4bf84813996800b7b7e0b03" translate="yes" xml:space="preserve">
          <source>The DI token for setting the initial config for the platform.</source>
          <target state="translated">플랫폼의 초기 구성을 설정하기위한 DI 토큰.</target>
        </trans-unit>
        <trans-unit id="9993b1eeb40876035f00bb4ad779bd1d89bff72d" translate="yes" xml:space="preserve">
          <source>The DOM attributes are parsed by the framework that owns the current template. So attributes in AngularJS templates must use kebab-case, while AngularJS templates must use camelCase.</source>
          <target state="translated">DOM 속성은 현재 템플릿을 소유 한 프레임 워크에 의해 구문 분석됩니다. 따라서 AngularJS 템플릿의 속성은 kebab-case를 사용해야하지만 AngularJS 템플릿은 camelCase를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="40aba8e91dedb65b6b75ee94b6c800ec39ec06a8" translate="yes" xml:space="preserve">
          <source>The DOM element &lt;code&gt;&amp;lt;a-component&amp;gt;&lt;/code&gt; will remain to be an AngularJS managed element, because it's defined in an AngularJS template. That also means you can apply additional AngularJS directives to it, but &lt;em&gt;not&lt;/em&gt; Angular directives. It is only in the template of the &lt;code&gt;&amp;lt;a-component&amp;gt;&lt;/code&gt; where Angular steps in. This same rule also applies when you use AngularJS component directives from Angular.</source>
          <target state="translated">DOM 요소 &lt;code&gt;&amp;lt;a-component&amp;gt;&lt;/code&gt; 는 AngularJS 템플릿에 정의되어 있으므로 AngularJS 관리 요소로 유지됩니다. 이는 또한 Angular 지시문이 &lt;em&gt;아닌&lt;/em&gt; 추가 AngularJS 지시문을 적용 할 수 있음을 의미합니다 . Angular 가있는 &lt;code&gt;&amp;lt;a-component&amp;gt;&lt;/code&gt; 의 템플리트에만 있습니다. Angular에서 AngularJS 컴포넌트 지시문을 사용할 때도 동일한 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ef37725e8017d864dbbc0ce41db1775b05a49609" translate="yes" xml:space="preserve">
          <source>The DOM element to which to attach the animation.</source>
          <target state="translated">애니메이션을 첨부 할 DOM 요소입니다.</target>
        </trans-unit>
        <trans-unit id="88ce3ced1c7d105ca467fac76be3733534705ffd" translate="yes" xml:space="preserve">
          <source>The DOM element.</source>
          <target state="translated">DOM 요소</target>
        </trans-unit>
        <trans-unit id="d5b6648ab37ea69fa6db16f13fe369e9e3c17dd2" translate="yes" xml:space="preserve">
          <source>The DOM event to listen for.</source>
          <target state="translated">수신 할 DOM 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="6928a76a137e5a6aa8b409d1e1866c18fe4c109d" translate="yes" xml:space="preserve">
          <source>The DOM property that is bound to a data property.</source>
          <target state="translated">데이터 속성에 바인딩 된 DOM 속성입니다.</target>
        </trans-unit>
        <trans-unit id="fed37b463aa73566258c88f3425a4af03786431a" translate="yes" xml:space="preserve">
          <source>The DebugElement associated with the root element of this component.</source>
          <target state="translated">이 컴포넌트의 루트 요소와 연관된 DebugElement입니다.</target>
        </trans-unit>
        <trans-unit id="698531beda7f91ea6b29506a74d0b3e9ca30258a" translate="yes" xml:space="preserve">
          <source>The ElementRef for the element at the root of the component.</source>
          <target state="translated">구성 요소의 루트에있는 요소의 ElementRef입니다.</target>
        </trans-unit>
        <trans-unit id="0366d0d0ffb1591153e2e01125018d2c703fc4c6" translate="yes" xml:space="preserve">
          <source>The Filter/Stagger tab in the live example shows a list of heroes with an introductory sequence. The entire list of heroes cascades in, with a slight delay from top to bottom.</source>
          <target state="translated">라이브 예의 필터 / 스 태거 탭에는 소개 시퀀스가있는 영웅 목록이 표시됩니다. 영웅의 전체 목록은 계단식으로 진행되며 위에서 아래로 약간 지연됩니다.</target>
        </trans-unit>
        <trans-unit id="1ca923870d72f3903f980d65fb8b21ef21dad089" translate="yes" xml:space="preserve">
          <source>The HTML &lt;a href=&quot;router&quot;&gt;&lt;em&gt;&amp;lt;base href=&quot;...&quot;/&amp;gt;&lt;/em&gt;&lt;/a&gt; specifies a base path for resolving relative URLs to assets such as images, scripts, and style sheets. For example, given the &lt;code&gt;&amp;lt;base href=&quot;/my/app/&quot;&amp;gt;&lt;/code&gt;, the browser resolves a URL such as &lt;code&gt;some/place/foo.jpg&lt;/code&gt; into a server request for &lt;code&gt;my/app/some/place/foo.jpg&lt;/code&gt;. During navigation, the Angular router uses the &lt;em&gt;base href&lt;/em&gt; as the base path to component, template, and module files.</source>
          <target state="translated">HTML &lt;a href=&quot;router&quot;&gt;&lt;em&gt;&amp;lt;base href = &quot;...&quot;/&amp;gt;&lt;/em&gt;&lt;/a&gt; 는 이미지, 스크립트 및 스타일 시트와 같은 자산에 상대 URL을 해석하기위한 기본 경로를 지정합니다. 예를 들어 &lt;code&gt;&amp;lt;base href=&quot;/my/app/&quot;&amp;gt;&lt;/code&gt; 에서 브라우저는 &lt;code&gt;some/place/foo.jpg&lt;/code&gt; 와 같은 URL 을 &lt;code&gt;my/app/some/place/foo.jpg&lt;/code&gt; 에 대한 서버 요청으로 해석 합니다. 탐색 중에 Angular 라우터는 &lt;em&gt;기본 href&lt;/em&gt; 를 구성 요소, 템플리트 및 모듈 파일의 기본 경로로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6934597188d99f726b47ffd4352dab662b44d834" translate="yes" xml:space="preserve">
          <source>The HTML &lt;code&gt;base&lt;/code&gt; tag with the &lt;code&gt;href&lt;/code&gt; attribute specifies the base URI, or URL, for relative links. If you set the &lt;code&gt;&quot;localize&quot;&lt;/code&gt; option in &lt;code&gt;angular.json&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; or to an array of locale IDs, the CLI adjusts the base &lt;code&gt;href&lt;/code&gt; for each version of the app by adding the locale to the configured &lt;code&gt;&quot;baseHref&quot;&lt;/code&gt;. You can specify the &lt;code&gt;&quot;baseHref&quot;&lt;/code&gt; for each locale in your workspace configuration file (&lt;code&gt;angular.json&lt;/code&gt;), as shown in the following example, which sets &lt;code&gt;&quot;baseHref&quot;&lt;/code&gt; to an empty string:</source>
          <target state="translated">&lt;code&gt;href&lt;/code&gt; 속성 이있는 HTML &lt;code&gt;base&lt;/code&gt; 태그 는 상대 링크에 대한 기본 URI 또는 ​​URL을 지정합니다. &lt;code&gt;angular.json&lt;/code&gt; 의 &lt;code&gt;&quot;localize&quot;&lt;/code&gt; 옵션 을 &lt;code&gt;true&lt;/code&gt; 또는 로케일 ID 배열로 설정하면 CLI는 구성된 &lt;code&gt;&quot;baseHref&quot;&lt;/code&gt; 에 로케일을 추가하여 앱의 각 버전에 대한 기본 &lt;code&gt;href&lt;/code&gt; 를 조정합니다 . 당신은 지정할 수 있습니다 &lt;code&gt;&quot;baseHref&quot;&lt;/code&gt; 작업 공간 구성 파일 (각 로케일에 대해 &lt;code&gt;angular.json&lt;/code&gt; 하는 세트 다음 예에서와 같이) &lt;code&gt;&quot;baseHref&quot;&lt;/code&gt; 빈 문자열 :</target>
        </trans-unit>
        <trans-unit id="3d87779df17c7f23d08f5fc1783cce1d26501ce4" translate="yes" xml:space="preserve">
          <source>The HTML attribute &lt;code&gt;value&lt;/code&gt; specifies the &lt;em&gt;initial&lt;/em&gt; value; the DOM &lt;code&gt;value&lt;/code&gt; property is the &lt;em&gt;current&lt;/em&gt; value.</source>
          <target state="translated">HTML 속성 &lt;code&gt;value&lt;/code&gt; 은 &lt;em&gt;초기&lt;/em&gt; 값을 지정합니다 . DOM &lt;code&gt;value&lt;/code&gt; 속성은 &lt;em&gt;현재&lt;/em&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="1c559ea997a344c5ea6c1ce9d3e4c628fd9a47c6" translate="yes" xml:space="preserve">
          <source>The HTML element &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; and the Angular decorator &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; are different. This documentation is about component communication in Angular as it pertains to &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt;. For more information on the HTML element &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, see the &lt;a href=&quot;https://www.w3.org/TR/html5/sec-forms.html#the-input-element&quot;&gt;W3C Recommendation&lt;/a&gt;.</source>
          <target state="translated">HTML 요소 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 과 Angular 데코레이터 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 이 다릅니다. 이 문서는이 요소에 관한 각도로의 통신에 관한 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 및 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; . HTML 요소 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 에 대한 자세한 내용 은 &lt;a href=&quot;https://www.w3.org/TR/html5/sec-forms.html#the-input-element&quot;&gt;W3C Recommendation을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9dc8a4343ef71551d0c82a9eaadfd64de660f2a" translate="yes" xml:space="preserve">
          <source>The HTML element to receive event notifications.</source>
          <target state="translated">이벤트 알림을 수신 할 HTML 요소입니다.</target>
        </trans-unit>
        <trans-unit id="d14904cf4a58c3d8c0afeac7bf2f0cdc11c30fbe" translate="yes" xml:space="preserve">
          <source>The HTML for the list of heroes should look like this:</source>
          <target state="translated">영웅 목록의 HTML은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="f71b50d004800ebb1d4d3080fd26d84a67ac0e78" translate="yes" xml:space="preserve">
          <source>The HTML includes an &lt;em&gt;Edit&lt;/em&gt; button whose click event is bound to an expression that clears the &lt;code&gt;submitted&lt;/code&gt; flag.</source>
          <target state="translated">HTML에는 클릭 이벤트가 &lt;code&gt;submitted&lt;/code&gt; 플래그 를 지우는 표현식에 바인드 된 &lt;em&gt;편집&lt;/em&gt; 단추가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fd12f6544608fc7b30088b6abc736ac21e18907" translate="yes" xml:space="preserve">
          <source>The HTML selector of the Universal app</source>
          <target state="translated">유니버설 앱의 HTML 선택기</target>
        </trans-unit>
        <trans-unit id="fd9120ff3800ba174966eda03c783d69e8e4cda4" translate="yes" xml:space="preserve">
          <source>The HTML selector to use for this component.</source>
          <target state="translated">이 컴포넌트에 사용할 HTML 선택기입니다.</target>
        </trans-unit>
        <trans-unit id="e7578d99ffd7e1da8e3cea279451c4297b5806ca" translate="yes" xml:space="preserve">
          <source>The HTML selector to use for this directive.</source>
          <target state="translated">이 지시문에 사용할 HTML 선택기입니다.</target>
        </trans-unit>
        <trans-unit id="2a36834f34b8455f136644a787a93d8cd1f575d0" translate="yes" xml:space="preserve">
          <source>The HTML template contains a trigger called &lt;code&gt;filterAnimation&lt;/code&gt;.</source>
          <target state="translated">HTML 템플릿에는 &lt;code&gt;filterAnimation&lt;/code&gt; 이라는 트리거가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1aa3f12e11c8cd99f37c0e90b346ffe248ed2a88" translate="yes" xml:space="preserve">
          <source>The HTML template that defines the view.</source>
          <target state="translated">뷰를 정의하는 HTML 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="fb27ae2c8025973c57454777adc583cc3d95a51c" translate="yes" xml:space="preserve">
          <source>The HTTP client service offers the following major features.</source>
          <target state="translated">HTTP 클라이언트 서비스는 다음과 같은 주요 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="25316bd1e8e7dd9558acd79051ccba3b8b0de428" translate="yes" xml:space="preserve">
          <source>The HTTP method.</source>
          <target state="translated">HTTP 메소드</target>
        </trans-unit>
        <trans-unit id="e004648df3406974846237d4e5339d7a5db71263" translate="yes" xml:space="preserve">
          <source>The HTTP module uses observables to handle AJAX requests and responses.</source>
          <target state="translated">HTTP 모듈은 Observable을 사용하여 AJAX 요청 및 응답을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="4063f45ae6db2ac3b918eaf7efd11f13ab6d0885" translate="yes" xml:space="preserve">
          <source>The HTTP options to send with the request.</source>
          <target state="translated">요청과 함께 보낼 HTTP 옵션.</target>
        </trans-unit>
        <trans-unit id="f569b6437ab842c7c172d6eaf1d50cb52cb3b0df" translate="yes" xml:space="preserve">
          <source>The Hero Editor</source>
          <target state="translated">영웅 편집자</target>
        </trans-unit>
        <trans-unit id="789e49c75eaf57227f3c68b65a2f12a91300f2e7" translate="yes" xml:space="preserve">
          <source>The ICU clauses adhere to the &lt;a href=&quot;http://userguide.icu-project.org/formatparse/messages&quot;&gt;ICU Message Format&lt;/a&gt; specified in the &lt;a href=&quot;http://cldr.unicode.org/index/cldr-spec/plural-rules&quot;&gt;CLDR pluralization rules&lt;/a&gt;.</source>
          <target state="translated">ICU 절 은 &lt;a href=&quot;http://cldr.unicode.org/index/cldr-spec/plural-rules&quot;&gt;CLDR 복수화 규칙에&lt;/a&gt; 지정된 &lt;a href=&quot;http://userguide.icu-project.org/formatparse/messages&quot;&gt;ICU 메시지 형식을 &lt;/a&gt;따릅니다 .</target>
        </trans-unit>
        <trans-unit id="ad0024a992c3624450ab558546a68e7c18c3fd2c" translate="yes" xml:space="preserve">
          <source>The ID consists of a language identifier, such as &lt;code&gt;en&lt;/code&gt; for English or &lt;code&gt;fr&lt;/code&gt; for French, followed by a dash (&lt;code&gt;-&lt;/code&gt;) and a locale extension, such as &lt;code&gt;US&lt;/code&gt; for the United States or &lt;code&gt;CA&lt;/code&gt; for Canada. For example, &lt;code&gt;en-US&lt;/code&gt; refers to English in the United States, and &lt;code&gt;fr-CA&lt;/code&gt; refers to French in Canada. Angular uses this ID to find the correct corresponding locale data.</source>
          <target state="translated">ID는 영어의 경우 &lt;code&gt;en&lt;/code&gt; , 프랑스어의 경우 &lt;code&gt;fr&lt;/code&gt; 과 같은 언어 식별자와 대시 ( &lt;code&gt;-&lt;/code&gt; ) 및 로케일 확장자 (예 : &lt;code&gt;US&lt;/code&gt; 경우 US , 캐나다의 경우 &lt;code&gt;CA&lt;/code&gt; ) 로 구성됩니다. 예를 들어 &lt;code&gt;en-US&lt;/code&gt; 는 미국 에서 영어를, &lt;code&gt;fr-CA&lt;/code&gt; 는 캐나다에서 프랑스어를 나타냅니다. Angular는이 ID를 사용하여 올바른 해당 로케일 데이터를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="506fcf27093bc174f67c1d402388302182ceec78" translate="yes" xml:space="preserve">
          <source>The ID of the anchor element.</source>
          <target state="translated">앵커 요소의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="ac7e7310379be287aa7d416f11a8dd96c9a6d0ee" translate="yes" xml:space="preserve">
          <source>The Idle Task Queue is the queue of all pending tasks that happen in the background in the service worker. If there are any tasks in the queue, they are listed with a description. In this example, the service worker has one such task scheduled, a post-initialization operation involving an update check and cleanup of stale caches.</source>
          <target state="translated">유휴 작업 큐는 서비스 작업자의 백그라운드에서 발생하는 모든 보류중인 작업의 큐입니다. 대기열에 작업이 있으면 설명과 함께 나열됩니다. 이 예에서 서비스 워커는 업데이트 확인 및 오래된 캐시 정리와 관련된 초기화 후 작업과 같은 예약 된 하나의 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b00f55586209c5611cf844fe2c21fbd033033eb7" translate="yes" xml:space="preserve">
          <source>The JSON schema that defines a schematic's options supports extensions to allow the declarative definition of prompts and their respective behavior. No additional logic or changes are required to the code of a schematic to support the prompts. The following JSON schema is a complete description of the long-form syntax for the &lt;code&gt;x-prompt&lt;/code&gt; field.</source>
          <target state="translated">회로도의 옵션을 정의하는 JSON 스키마는 프롬프트 및 해당 동작의 선언적 정의를 허용하는 확장을 지원합니다. 프롬프트를 지원하기 위해 회로도 코드에 대한 추가 논리 나 변경이 필요하지 않습니다. 다음 JSON 스키마는 &lt;code&gt;x-prompt&lt;/code&gt; 필드 의 긴 형식 구문에 대한 완전한 설명입니다 .</target>
        </trans-unit>
        <trans-unit id="6b14e7b839406e6c6e07b41831c981d00cdb2be0" translate="yes" xml:space="preserve">
          <source>The JSON schemas for the default schematics used by the CLI to generate projects and parts of projects are collected in the package &lt;a href=&quot;https://github.com/angular/angular-cli/blob/7.0.x/packages/schematics/angular/application/schema.json&quot;&gt;&lt;code&gt;@schematics/angular&lt;/code&gt;&lt;/a&gt;. The schema describes the options available to the CLI for each of the &lt;code&gt;ng generate&lt;/code&gt; sub-commands, as shown in the &lt;code&gt;--help&lt;/code&gt; output.</source>
          <target state="translated">CLI가 프로젝트 및 프로젝트의 일부를 생성하는 데 사용하는 기본 회로도에 대한 JSON 스키마는 &lt;a href=&quot;https://github.com/angular/angular-cli/blob/7.0.x/packages/schematics/angular/application/schema.json&quot;&gt; &lt;code&gt;@schematics/angular&lt;/code&gt; &lt;/a&gt; 패키지에 수집됩니다 . 이 스키마 는 &lt;code&gt;--help&lt;/code&gt; 출력에 표시된대로 각 &lt;code&gt;ng generate&lt;/code&gt; 하위 명령 에 대해 CLI에서 사용할 수있는 옵션을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="39ad755f2d2f00791e1d617d38aca11a845811ee" translate="yes" xml:space="preserve">
          <source>The JSON schemas for the default schematics used by the CLI to generate projects and parts of projects are collected in the package &lt;a href=&quot;https://raw.githubusercontent.com/angular/angular-cli/v7.0.0/packages/schematics/angular/application/schema.json&quot;&gt;&lt;code&gt;@schematics/angular&lt;/code&gt;&lt;/a&gt;. The schema describes the options available to the CLI for each of the &lt;code&gt;ng generate&lt;/code&gt; sub-commands, as shown in the &lt;code&gt;--help&lt;/code&gt; output.</source>
          <target state="translated">CLI가 프로젝트 및 프로젝트의 일부를 생성하는 데 사용하는 기본 회로도에 대한 JSON 스키마는 &lt;a href=&quot;https://raw.githubusercontent.com/angular/angular-cli/v7.0.0/packages/schematics/angular/application/schema.json&quot;&gt; &lt;code&gt;@schematics/angular&lt;/code&gt; &lt;/a&gt; 패키지에 수집됩니다 . 이 스키마 는 &lt;code&gt;--help&lt;/code&gt; 출력에 표시된대로 각 &lt;code&gt;ng generate&lt;/code&gt; 하위 명령 에 대해 CLI에서 사용할 수있는 옵션을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="f07f2ef6bdc0276dc66c13525614930ce905b490" translate="yes" xml:space="preserve">
          <source>The NPM registry to use.</source>
          <target state="translated">사용할 NPM 레지스트리</target>
        </trans-unit>
        <trans-unit id="ddfa2dc248ef3e69640a4a039271e3809480eb1f" translate="yes" xml:space="preserve">
          <source>The NgModule classes differ from JavaScript module in the following key ways:</source>
          <target state="translated">NgModule 클래스는 다음과 같은 주요 방법으로 JavaScript 모듈과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3c3d2df9acaceef7f08c09fa40d55f3607762e32" translate="yes" xml:space="preserve">
          <source>The NgModule instance.</source>
          <target state="translated">NgModule 인스턴스</target>
        </trans-unit>
        <trans-unit id="0747755c8b239fe51fe8a94eabd907811f0aaa1b" translate="yes" xml:space="preserve">
          <source>The NgModule system is different from and unrelated to the JavaScript (ES2015) module system for managing collections of JavaScript objects. These are &lt;em&gt;complementary&lt;/em&gt; module systems that you can use together to write your apps.</source>
          <target state="translated">NgModule 시스템은 JavaScript 객체 컬렉션을 관리하기위한 JavaScript (ES2015) 모듈 시스템과 다르거 나 관련이 없습니다. 이들은 함께 사용하여 앱을 작성할 수 있는 &lt;em&gt;보완&lt;/em&gt; 모듈 시스템입니다.</target>
        </trans-unit>
        <trans-unit id="e78772f224ee2af36b30cd74fcf9b437c350b4e9" translate="yes" xml:space="preserve">
          <source>The PhoneCat project has both E2E Protractor tests and some Karma unit tests in it. Of these two, E2E tests can be dealt with much more easily: By definition, E2E tests access the application from the &lt;em&gt;outside&lt;/em&gt; by interacting with the various UI elements the app puts on the screen. E2E tests aren't really that concerned with the internal structure of the application components. That also means that, although you modify the project quite a bit during the upgrade, the E2E test suite should keep passing with just minor modifications. You didn't change how the application behaves from the user's point of view.</source>
          <target state="translated">PhoneCat 프로젝트에는 E2E 각도기 테스트와 일부 Karma 단위 테스트가 있습니다. 이 두 가지 중에서 E2E 테스트는 훨씬 쉽게 처리 할 수 ​​있습니다. 정의에 따라 E2E 테스트 는 앱이 화면에 표시하는 다양한 UI 요소와 상호 작용 하여 &lt;em&gt;외부&lt;/em&gt; 에서 애플리케이션에 액세스합니다 . E2E 테스트는 실제로 애플리케이션 구성 요소의 내부 구조와 관련이 없습니다. 또한 업그레이드하는 동안 프로젝트를 약간 수정하더라도 E2E 테스트 스위트는 약간의 수정만으로도 계속 통과해야합니다. 사용자의 관점에서 응용 프로그램의 동작 방식을 변경하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="f2ae4909a5e215dd224a806bec7a9225a92ca5ec" translate="yes" xml:space="preserve">
          <source>The Popup Service example app (shown below) defines a component that you can either load dynamically or convert to a custom element.</source>
          <target state="translated">팝업 서비스 예제 앱 (아래 표시)은 동적으로로드하거나 사용자 지정 요소로 변환 할 수있는 구성 요소를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="84993d2db560df7bc9b4de2bc50d97c62f64d0f4" translate="yes" xml:space="preserve">
          <source>The Router also makes use of multiple providers associated with a single token. When you provide multiple sets of routes using &lt;a href=&quot;../api/router/routermodule#forroot&quot;&gt;RouterModule.forRoot&lt;/a&gt; and &lt;a href=&quot;../api/router/routermodule#forchild&quot;&gt;RouterModule.forChild&lt;/a&gt; in a single module, the &lt;a href=&quot;../api/router/routes&quot;&gt;ROUTES&lt;/a&gt; token combines all the different provided sets of routes into a single value.</source>
          <target state="translated">라우터는 또한 단일 토큰과 관련된 여러 공급자를 사용합니다. 단일 모듈에서 &lt;a href=&quot;../api/router/routermodule#forroot&quot;&gt;RouterModule.forRoot&lt;/a&gt; 및 &lt;a href=&quot;../api/router/routermodule#forchild&quot;&gt;RouterModule.forChild&lt;/a&gt; 를 사용하여 여러 경로 세트를 제공 하면 &lt;a href=&quot;../api/router/routes&quot;&gt;ROUTES&lt;/a&gt; 토큰은 제공된 모든 다른 경로 세트를 단일 값으로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="06f152c32b945154045d8af9ca9b76a3d1746fea" translate="yes" xml:space="preserve">
          <source>The Router and Forms modules use observables to listen for and respond to user-input events.</source>
          <target state="translated">라우터 및 양식 모듈은 관찰 가능 항목을 사용하여 사용자 입력 이벤트를 수신하고 응답합니다.</target>
        </trans-unit>
        <trans-unit id="6719949fe48b382a4f5d441956e3a39da43a1cf4" translate="yes" xml:space="preserve">
          <source>The RouterLink directive gives the router control over the anchor element. In this case, the route (URL) contains one fixed segment (&lt;code&gt;/products&lt;/code&gt;) and the final segment is variable, inserting the id property of the current product. For example, the URL for a product with an &lt;code&gt;id&lt;/code&gt; of 1 will be similar to &lt;code&gt;https://getting-started-myfork.stackblitz.io/products/1&lt;/code&gt;.</source>
          <target state="translated">RouterLink 지시문은 라우터가 앵커 요소를 제어하도록합니다. 이 경우 경로 (URL)에는 하나의 고정 세그먼트 ( &lt;code&gt;/products&lt;/code&gt; )가 포함되며 최종 세그먼트는 가변적이며 현재 제품의 id 속성을 삽입합니다. 예를 들어, &lt;code&gt;id&lt;/code&gt; 가 1 인 제품의 URL은 &lt;code&gt;https://getting-started-myfork.stackblitz.io/products/1&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="ec9884b83270d5dfad5b0c687a2bc2fbf8233d70" translate="yes" xml:space="preserve">
          <source>The RouterLink directive gives the router control over the anchor element. In this case, the route, or URL, contains one fixed segment, &lt;code&gt;/products&lt;/code&gt;, while the final segment is variable, inserting the id property of the current product. For example, the URL for a product with an &lt;code&gt;id&lt;/code&gt; of 1 will be similar to &lt;code&gt;https://getting-started-myfork.stackblitz.io/products/1&lt;/code&gt;.</source>
          <target state="translated">RouterLink 지시문은 앵커 요소에 대한 라우터 제어를 제공합니다. 이 경우 경로 또는 URL에는 하나의 고정 세그먼트 인 &lt;code&gt;/products&lt;/code&gt; 가 포함되며 최종 세그먼트는 가변적이며 현재 제품의 id 속성을 삽입합니다. 예를 들어 &lt;code&gt;id&lt;/code&gt; 가 1 인 제품의 URL은 &lt;code&gt;https://getting-started-myfork.stackblitz.io/products/1&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="bb5da276658695e0be6ae79161628d231d307feb" translate="yes" xml:space="preserve">
          <source>The Routing Module has several characteristics:</source>
          <target state="translated">라우팅 모듈에는 몇 가지 특성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="35fd3904247e990d23cf1026f75cc708c81d26d7" translate="yes" xml:space="preserve">
          <source>The Routing Module is a design choice whose value is most obvious when the configuration is complex and includes specialized guard and resolver services. It can seem like overkill when the actual configuration is dead simple.</source>
          <target state="translated">라우팅 모듈은 구성이 복잡하고 특수한 보호 및 해결 자 서비스를 포함 할 때 가장 가치있는 설계 선택 사항입니다. 실제 구성이 단순하지 않으면 과도하게 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6fe2baca6e2f506f7a1094ee33169d007121a3d" translate="yes" xml:space="preserve">
          <source>The RxJS &lt;code&gt;last()&lt;/code&gt; operator emits the observable's last value before completing, which will be the test quote. The &lt;code&gt;subscribe&lt;/code&gt; callback calls &lt;code&gt;&lt;a href=&quot;../api/core/testing/componentfixture#detectChanges&quot;&gt;detectChanges()&lt;/a&gt;&lt;/code&gt; to update the quote element with the test quote, in the same manner as the earlier tests.</source>
          <target state="translated">RxJS &lt;code&gt;last()&lt;/code&gt; 연산자는 완료하기 전에 관찰 가능 항목의 마지막 값을 내 보내며 이는 테스트 따옴표입니다. 은 &lt;code&gt;subscribe&lt;/code&gt; 콜백 통화 &lt;code&gt;&lt;a href=&quot;../api/core/testing/componentfixture#detectChanges&quot;&gt;detectChanges()&lt;/a&gt;&lt;/code&gt; 이전 테스트와 동일한 방식으로 테스트 견적과 견적 요소를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4ef5b64a22e5f089b247e3fce5803948ddbdd68" translate="yes" xml:space="preserve">
          <source>The RxJS &lt;code&gt;last()&lt;/code&gt; operator emits the observable's last value before completing, which will be the test quote. The &lt;code&gt;subscribe&lt;/code&gt; callback calls &lt;code&gt;detectChanges()&lt;/code&gt; to update the quote element with the test quote, in the same manner as the earlier tests.</source>
          <target state="translated">RxJS &lt;code&gt;last()&lt;/code&gt; 연산자는 완료하기 전에 Observable의 마지막 값을 내 보냅니다 . 이것은 테스트 견적이 될 것입니다. 은 &lt;code&gt;subscribe&lt;/code&gt; 콜백 통화 &lt;code&gt;detectChanges()&lt;/code&gt; 이전 테스트와 동일한 방식으로 테스트 견적과 견적 요소를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcaa953111009647a434b575f4fd13ea2b557407" translate="yes" xml:space="preserve">
          <source>The RxJS &lt;code&gt;tap&lt;/code&gt; operator (as in &quot;wiretap&quot;) lets the code inspect both success and error values passing through the observable without disturbing them.</source>
          <target state="translated">RxJS &lt;code&gt;tap&lt;/code&gt; 연산자 ( &quot; 와이어 탭 &quot;에서와 같이)를 통해 코드는 관찰 가능 값을 방해하지 않고 통과 및 성공 값을 모두 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d1cccc9cf3740247de7c91761afdad5881ffa16" translate="yes" xml:space="preserve">
          <source>The RxJS &lt;code&gt;tap&lt;/code&gt; operator captures whether the request succeeded or failed. The RxJS &lt;code&gt;finalize&lt;/code&gt; operator is called when the response observable either errors or completes (which it must), and reports the outcome to the &lt;code&gt;MessageService&lt;/code&gt;.</source>
          <target state="translated">RxJS &lt;code&gt;tap&lt;/code&gt; 연산자는 요청의 성공 여부를 캡처합니다. RxJS &lt;code&gt;finalize&lt;/code&gt; 연산자는 응답을 관찰 할 수있는 오류 또는 완료 (필수)가있을 때 호출되며 결과를 &lt;code&gt;MessageService&lt;/code&gt; 에보고 합니다.</target>
        </trans-unit>
        <trans-unit id="827ac77d8ed61c8b49d2de8b0bdc53bf70d6d536" translate="yes" xml:space="preserve">
          <source>The RxJS library</source>
          <target state="translated">RxJS 라이브러리</target>
        </trans-unit>
        <trans-unit id="f0136a6174ce00439105cc5cccfc1cdfbe02fb4c" translate="yes" xml:space="preserve">
          <source>The Schematics framework provides a file templating system, which supports both path and content templates. The system operates on placeholders defined inside files or paths that loaded in the input &lt;code&gt;Tree&lt;/code&gt;. It fills these in using values passed into the &lt;code&gt;Rule&lt;/code&gt;.</source>
          <target state="translated">Schematics 프레임 워크는 파일 템플릿 시스템을 제공하며 경로 및 컨텐츠 템플릿을 모두 지원합니다. 시스템은 입력 &lt;code&gt;Tree&lt;/code&gt; 로드 된 파일 또는 경로 내에 정의 된 자리 표시 자에서 작동합니다 . &lt;code&gt;Rule&lt;/code&gt; 에 전달 된 값을 사용하여이를 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="a709c4d8482569aaa0ad00942fcea4cbbe6b52ed" translate="yes" xml:space="preserve">
          <source>The ServiceWorker will redirect navigation requests that don't match any &lt;code&gt;asset&lt;/code&gt; or &lt;code&gt;data&lt;/code&gt; group to the specified &lt;a href=&quot;service-worker-config#index-file&quot;&gt;index file&lt;/a&gt;. A request is considered to be a navigation request if:</source>
          <target state="translated">ServiceWorker는 &lt;code&gt;asset&lt;/code&gt; 또는 &lt;code&gt;data&lt;/code&gt; 그룹 과 일치하지 않는 탐색 요청을 지정된 &lt;a href=&quot;service-worker-config#index-file&quot;&gt;색인 파일로&lt;/a&gt; 리디렉션 합니다 . 다음과 같은 경우 요청이 탐색 요청으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="05060365aca92ff57a2a8cb3fad933d606282ffe" translate="yes" xml:space="preserve">
          <source>The StackBlitz generator might provide the cart service in &lt;code&gt;app.module.ts&lt;/code&gt; by default. That differs from the example, which uses a bundle-optimization technique, an &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; decorator with the &lt;code&gt;{ providedIn: 'root' }&lt;/code&gt; statement. For more information about services, see &lt;a href=&quot;../guide/architecture-services&quot;&gt;Introduction to Services and Dependency Injection&lt;/a&gt;.</source>
          <target state="translated">StackBlitz 생성기는 기본적으로 &lt;code&gt;app.module.ts&lt;/code&gt; 에서 카트 서비스를 제공 할 수 있습니다 . 이는 번들 최적화 기술인 &lt;code&gt;{ providedIn: 'root' }&lt;/code&gt; 문이 있는 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; 데코레이터 를 사용하는 예제와 다릅니다 . 서비스에 대한 자세한 내용은 서비스 &lt;a href=&quot;../guide/architecture-services&quot;&gt;소개 및 종속성 주입을&lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="0a8e6705d088a4f6f8c71e996096d93779313a26" translate="yes" xml:space="preserve">
          <source>The SystemJS configuration file &lt;code&gt;systemjs.config.js&lt;/code&gt; to the project root directory.</source>
          <target state="translated">SystemJS 구성 파일 &lt;code&gt;systemjs.config.js&lt;/code&gt; 는 프로젝트 루트 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="55401394d273b717445755bd856afd574e272014" translate="yes" xml:space="preserve">
          <source>The Testability service provides testing hooks that can be accessed from the browser and by services such as Protractor. Each bootstrapped Angular application on the page will have an instance of Testability.</source>
          <target state="translated">Testability 서비스는 브라우저 및 Protractor와 같은 서비스에서 액세스 할 수있는 테스트 후크를 제공합니다. 페이지의 각 부트 스트랩 Angular 응용 프로그램에는 Testability 인스턴스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5766cb1be4ee9631ce9045b332f79763bfe74b65" translate="yes" xml:space="preserve">
          <source>The Tour of Heroes &lt;code&gt;HeroesComponent&lt;/code&gt; is currently getting and displaying fake data.</source>
          <target state="translated">Tour of Heroes &lt;code&gt;HeroesComponent&lt;/code&gt; 는 현재 가짜 데이터를 가져오고 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d2f2b03e1a17c636938183bec1a40bd186d69702" translate="yes" xml:space="preserve">
          <source>The Tour of Heroes app displays a list of heroes in a Master/Detail view.</source>
          <target state="translated">영웅 투어 앱에는 마스터 / 세부 정보보기에 영웅 목록이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="29d68459c27733c932fb0a3e9b100ffb25836775" translate="yes" xml:space="preserve">
          <source>The Tour of Heroes is a comprehensive tutorial that guides you through the process of building an application with many of Angular's most popular features.</source>
          <target state="translated">Tour of Heroes는 Angular의 가장 인기있는 많은 기능을 사용하여 애플리케이션을 빌드하는 과정을 안내하는 포괄적 인 튜토리얼입니다.</target>
        </trans-unit>
        <trans-unit id="a4c698daff2c8aa5974a237e4112ae50ff6e51cc" translate="yes" xml:space="preserve">
          <source>The TypeScript and Angular have a wide range of options which can be used to configure type-checking features and generated output. For more information, see the &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#configuration-inheritance-with-extends&quot;&gt;Configuration inheritance with extends&lt;/a&gt; section of the TypeScript documentation.</source>
          <target state="translated">TypeScript 및 Angular에는 유형 검사 기능 및 생성 된 출력을 구성하는 데 사용할 수있는 다양한 옵션이 있습니다. 자세한 내용 은 TypeScript 문서의 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#configuration-inheritance-with-extends&quot;&gt;확장을 사용한 구성 상속&lt;/a&gt; 섹션을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="8568fa0f23ba2d73c5291a0c991f3fc03b8708b2" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler does some of the analytic work of the first phase. It emits the &lt;code&gt;.d.ts&lt;/code&gt;&lt;em&gt;type definition files&lt;/em&gt; with type information that the AOT compiler needs to generate application code. At the same time, the AOT &lt;strong&gt;collector&lt;/strong&gt; analyzes the metadata recorded in the Angular decorators and outputs metadata information in &lt;strong&gt;&lt;code&gt;.metadata.json&lt;/code&gt;&lt;/strong&gt; files, one per &lt;code&gt;.d.ts&lt;/code&gt; file.</source>
          <target state="translated">TypeScript 컴파일러는 첫 번째 단계의 일부 분석 작업을 수행합니다. 그것은 방출 &lt;code&gt;.d.ts&lt;/code&gt; 의&lt;em&gt;유형 정의 파일을&lt;/em&gt; AOT 컴파일러는 응용 프로그램 코드를 생성하는 데 필요한 유형의 정보. 동시에 AOT &lt;strong&gt;수집기&lt;/strong&gt; 는 Angular 데코레이터에 기록 된 메타 데이터를 분석하고 &lt;code&gt;.d.ts&lt;/code&gt; 파일 당 하나씩 &lt;strong&gt; &lt;code&gt;.metadata.json&lt;/code&gt; &lt;/strong&gt; 파일로 메타 데이터 정보를 출력 합니다.</target>
        </trans-unit>
        <trans-unit id="6e0a06e36760a2eff0336b6bc84af9dbdc59d36a" translate="yes" xml:space="preserve">
          <source>The TypeScript compiler generates a public field for each &lt;code&gt;public&lt;/code&gt; constructor parameter and automatically assigns the parameter&amp;rsquo;s value to that field when you create heroes.</source>
          <target state="translated">TypeScript 컴파일러는 각 &lt;code&gt;public&lt;/code&gt; 생성자 매개 변수에 대한 공용 필드를 생성하고 영웅을 만들 때 해당 필드에 매개 변수 값을 자동으로 할당합니다.</target>
        </trans-unit>
        <trans-unit id="544dc91fe288513548a9233bbe8426452eb2d737" translate="yes" xml:space="preserve">
          <source>The TypeScript language server, including the &lt;em&gt;tsc&lt;/em&gt; TypeScript compiler.</source>
          <target state="translated">&lt;em&gt;tsc&lt;/em&gt; TypeScript 컴파일러를 포함한 TypeScript 언어 서버</target>
        </trans-unit>
        <trans-unit id="585484bd3428c42d4450046039048a1e517dabea" translate="yes" xml:space="preserve">
          <source>The URL bound to the &lt;code&gt;[&lt;a href=&quot;../api/router/routerlink&quot;&gt;routerLink&lt;/a&gt;]&lt;/code&gt; attribute flows in to the directive's &lt;code&gt;linkParams&lt;/code&gt; property.</source>
          <target state="translated">&lt;code&gt;[&lt;a href=&quot;../api/router/routerlink&quot;&gt;routerLink&lt;/a&gt;]&lt;/code&gt; 속성에 바인딩 된 URL 은 지시문의 &lt;code&gt;linkParams&lt;/code&gt; 속성으로 유입됩니다 .</target>
        </trans-unit>
        <trans-unit id="d3b7615b7e3818d17d835d95dfcc876f7081b556" translate="yes" xml:space="preserve">
          <source>The URL for the current application state. This is used for initializing the platform's location. &lt;code&gt;protocol&lt;/code&gt;, &lt;code&gt;hostname&lt;/code&gt;, and &lt;code&gt;port&lt;/code&gt; will be overridden if &lt;code&gt;baseUrl&lt;/code&gt; is set.</source>
          <target state="translated">현재 애플리케이션 상태의 URL입니다. 이것은 플랫폼의 위치를 ​​초기화하는 데 사용됩니다. &lt;code&gt;baseUrl&lt;/code&gt; 이 설정된 경우 &lt;code&gt;protocol&lt;/code&gt; , &lt;code&gt;hostname&lt;/code&gt; 및 &lt;code&gt;port&lt;/code&gt; 가 재정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3b58a08584550f73eae9ff3e2376fdabaeb0c99" translate="yes" xml:space="preserve">
          <source>The URL fragment shared by all the routes</source>
          <target state="translated">모든 경로가 공유하는 URL 조각</target>
        </trans-unit>
        <trans-unit id="7375623d6e6cb15b981147758fafc25c5fab9496" translate="yes" xml:space="preserve">
          <source>The URL in &lt;code&gt;&amp;lt;action type=&quot;Rewrite&quot; url=&quot;/src/&quot;/&amp;gt;&lt;/code&gt; should match the base href in &lt;code&gt;index.html&lt;/code&gt;.</source>
          <target state="translated">의 URL &lt;code&gt;&amp;lt;action type=&quot;Rewrite&quot; url=&quot;/src/&quot;/&amp;gt;&lt;/code&gt; 에서 기본 href 일치해야 &lt;code&gt;index.html&lt;/code&gt; 을을 .</target>
        </trans-unit>
        <trans-unit id="c30899e221cfea13e24ea0a470ee42b50353e939" translate="yes" xml:space="preserve">
          <source>The URL is the heroes resource URL plus the &lt;code&gt;id&lt;/code&gt; of the hero to delete.</source>
          <target state="translated">URL은 영웅 자원 URL과 삭제할 영웅 &lt;code&gt;id&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6c5643dddca94caf55142e6ccbe6d6ec8803e3a0" translate="yes" xml:space="preserve">
          <source>The URL is unchanged. The heroes web API knows which hero to update by looking at the hero's &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">URL은 변경되지 않습니다. 영웅 웹 API는 영웅의 &lt;code&gt;id&lt;/code&gt; 를 보고 업데이트 할 영웅을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="08c013a55e0baa8ffe5403ca40144123b223ee92" translate="yes" xml:space="preserve">
          <source>The URL must not contain &lt;code&gt;__&lt;/code&gt;.</source>
          <target state="translated">URL은 &lt;code&gt;__&lt;/code&gt; 을 포함 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="81837d96bfb7f069e22ae8b8419daf579e0ede35" translate="yes" xml:space="preserve">
          <source>The URL must not contain a file extension (i.e. a &lt;code&gt;.&lt;/code&gt;) in the last path segment.</source>
          <target state="translated">URL은 마지막 경로 세그먼트에 파일 확장자 (예 : &lt;code&gt;.&lt;/code&gt; )를 포함해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c1a40ff35abb3598077b170eeaec00c0f54cc0e" translate="yes" xml:space="preserve">
          <source>The URL path</source>
          <target state="translated">URL 경로</target>
        </trans-unit>
        <trans-unit id="c0dd8facec71b1ec87d76b9020042f5cba77847d" translate="yes" xml:space="preserve">
          <source>The URL segments matched by this route</source>
          <target state="translated">이 경로와 일치하는 URL 세그먼트</target>
        </trans-unit>
        <trans-unit id="cc2bde1fb3859667c3bfd03de6cc864cffab7897" translate="yes" xml:space="preserve">
          <source>The URL segments of this group. See &lt;code&gt;&lt;a href=&quot;urlsegment&quot;&gt;UrlSegment&lt;/a&gt;&lt;/code&gt; for more information</source>
          <target state="translated">이 그룹의 URL 세그먼트입니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;urlsegment&quot;&gt;UrlSegment&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2b38217a179daea3d6656686b81dd85b6b4153c1" translate="yes" xml:space="preserve">
          <source>The URL string.</source>
          <target state="translated">URL 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="52453743ef9a067eaee16ecf0d5bfffaa8d88e34" translate="yes" xml:space="preserve">
          <source>The URL that is the destination for this navigation.</source>
          <target state="translated">이 탐색의 대상인 URL입니다.</target>
        </trans-unit>
        <trans-unit id="82fa7104935e782b71b9ac41f1f70a9244a9aa62" translate="yes" xml:space="preserve">
          <source>The URL that the browser client (or live-reload client, if enabled) should use to connect to the development server. Use for a complex dev server setup, such as one with reverse proxies.</source>
          <target state="translated">브라우저 클라이언트 (또는 사용 가능한 경우 라이브 리로드 클라이언트)가 개발 서버에 연결하는 데 사용해야하는 URL입니다. 리버스 프록시가있는 복잡한 dev 서버 설정에 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c519406384bbfabb8d794f38fa84b37a2a8a8261" translate="yes" xml:space="preserve">
          <source>The ability to alter the state of a value after its creation. &lt;a href=&quot;glossary#reactive-forms&quot;&gt;Reactive forms&lt;/a&gt; perform immutable changes in that each change to the data model produces a new data model rather than modifying the existing one. &lt;a href=&quot;glossary#template-driven-forms&quot;&gt;Template-driven forms&lt;/a&gt; perform mutable changes with &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;NgModel&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;glossary#data-binding&quot;&gt;two-way data binding&lt;/a&gt; to modify the existing data model in place.</source>
          <target state="translated">생성 후 값의 상태를 변경하는 기능 &lt;a href=&quot;glossary#reactive-forms&quot;&gt;반응 양식&lt;/a&gt; 은 데이터 모델을 변경할 때마다 기존 데이터 모델을 수정하지 않고 새 데이터 모델을 생성하므로 변경 불가능한 변경을 수행합니다. &lt;a href=&quot;glossary#template-driven-forms&quot;&gt;템플릿 기반 양식&lt;/a&gt; 은 &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;NgModel&lt;/a&gt;&lt;/code&gt; 및 &lt;a href=&quot;glossary#data-binding&quot;&gt;양방향 데이터 바인딩&lt;/a&gt; 을 사용하여 변경 가능한 변경을 수행 하여 기존 데이터 모델 을 적절 하게 수정합니다.</target>
        </trans-unit>
        <trans-unit id="caa4182924ebe66fa358bd4a3e14ba6d81b491fb" translate="yes" xml:space="preserve">
          <source>The ability to configure one or more providers at different levels opens up useful possibilities. For a look at the following scenarios in a working app, see the heroes use case examples.</source>
          <target state="translated">다른 수준에서 하나 이상의 공급자를 구성 할 수 있으면 유용한 가능성이 열립니다. 작동하는 앱에서 다음 시나리오를 살펴 보려면 영웅 사용 사례 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d357726f6694fec9b1683368af646f1226db5511" translate="yes" xml:space="preserve">
          <source>The ability to request &lt;a href=&quot;http#typed-response&quot;&gt;typed response objects&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http#typed-response&quot;&gt;형식화 된 응답 개체&lt;/a&gt; 를 요청하는 기능 .</target>
        </trans-unit>
        <trans-unit id="50fe34565db9f623c1a4c2f1c8f3d0239b4b1371" translate="yes" xml:space="preserve">
          <source>The above command completes the following actions:</source>
          <target state="translated">위 명령은 다음 작업을 완료합니다.</target>
        </trans-unit>
        <trans-unit id="d10343d799b7008227efc9a02b184cf8a761ab84" translate="yes" xml:space="preserve">
          <source>The above example demonstrates changing a component's code to accommodate a pipe.</source>
          <target state="translated">위의 예는 파이프를 수용하기 위해 컴포넌트의 코드를 변경하는 것을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d5d6af0be00ddd39a1a4c1567712c9175938cf95" translate="yes" xml:space="preserve">
          <source>The absolute URL for the latter example, including the &lt;code&gt;localhost&lt;/code&gt; origin, is</source>
          <target state="translated">&lt;code&gt;localhost&lt;/code&gt; 원점을 포함하여 후자의 예에 대한 절대 URL 은</target>
        </trans-unit>
        <trans-unit id="63cb971f43856a00f354567181daff31d8142b01" translate="yes" xml:space="preserve">
          <source>The absolute URL for the latter example, including the &lt;code&gt;localhost&lt;/code&gt; origin, is as follows:</source>
          <target state="translated">&lt;code&gt;localhost&lt;/code&gt; 출처를 포함한 후자의 절대 URL 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c4e256b4477c3d36ae67c61de1ee6c1a8ff7190f" translate="yes" xml:space="preserve">
          <source>The abstract base class for the concrete form control classes &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../api/forms/formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt;. It provides their common behaviors and properties.</source>
          <target state="translated">구체적 양식 컨트롤 클래스 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/forms/formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; 의 추상 기본 클래스입니다 . 일반적인 동작과 속성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="402b1c3034ebb0af6c0f9e2efa6f13695bff7d6e" translate="yes" xml:space="preserve">
          <source>The abstraction of the form model promotes simplicity over structure. The template-driven form directive &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;NgModel&lt;/a&gt;&lt;/code&gt; is responsible for creating and managing the &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; instance for a given form element. It's less explicit, but you no longer have direct control over the form model.</source>
          <target state="translated">양식 모델의 추상화는 구조에 대한 단순성을 촉진합니다. 템플릿 기반 양식 지시문 &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;NgModel&lt;/a&gt;&lt;/code&gt; 은 주어진 양식 요소에 대한 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 인스턴스를 작성하고 관리합니다 . 덜 명확하지만 더 이상 양식 모델을 직접 제어 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e35904284dfba5a413162707ebab87af73ae1a76" translate="yes" xml:space="preserve">
          <source>The act of subscribing to an observable triggers its execution, associates callbacks with it, and creates a &lt;code&gt;Subscription&lt;/code&gt; object that lets you unsubscribe.</source>
          <target state="translated">Observable에 가입하면 실행이 트리거되고 콜백이 연결되어 &lt;code&gt;Subscription&lt;/code&gt; 을 취소 할 수 있는 Subscription 객체가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="14342a1287cec6129e7b1a94b8d02bdf3a5f1f89" translate="yes" xml:space="preserve">
          <source>The actions and effects are as follows:</source>
          <target state="translated">동작 및 효과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c6b7761a008c0eacb4c9720e87a44ff177306a4" translate="yes" xml:space="preserve">
          <source>The ad banner uses a helper directive called &lt;code&gt;AdDirective&lt;/code&gt; to mark valid insertion points in the template.</source>
          <target state="translated">광고 배너는 &lt;code&gt;AdDirective&lt;/code&gt; 라는 도우미 지시문을 사용 하여 템플릿에 유효한 삽입 점을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="727d776b678ae681b954ef7437bc5f9ca400e1a0" translate="yes" xml:space="preserve">
          <source>The admin feature file structure looks like this:</source>
          <target state="translated">관리자 기능 파일 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d83a95f34e4382511e2a151024543d721552d92d" translate="yes" xml:space="preserve">
          <source>The admin feature is now protected by the guard, albeit protected poorly.</source>
          <target state="translated">관리 기능은 이제 보호 수준이 낮지 만 가드에 의해 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="4747864fdf4438dfdda6f414c25b73c364d2192c" translate="yes" xml:space="preserve">
          <source>The admin feature is now protected by the guard, but the guard requires more customization to work fully.</source>
          <target state="translated">관리 기능은 이제 가드에 의해 보호되지만 가드가 완전히 작동하려면 더 많은 사용자 정의가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="96aed0c722ab88a83207ea9b85e25c7e2f416849" translate="yes" xml:space="preserve">
          <source>The admin feature module contains the &lt;code&gt;AdminComponent&lt;/code&gt; used for routing within the feature module, a dashboard route and two unfinished components to manage crises and heroes.</source>
          <target state="translated">관리 기능 모듈에는 기능 모듈 내에서 라우팅하는 데 사용되는 &lt;code&gt;AdminComponent&lt;/code&gt; , 대시 보드 경로 및 위기와 영웅을 관리하기위한 완료되지 않은 두 구성 요소가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab267a14770ddb26fa34604e27d4f4b4861c73ef" translate="yes" xml:space="preserve">
          <source>The aggregate value of the &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt;, including any disabled controls.</source>
          <target state="translated">비활성화 된 컨트롤을 포함 하여 &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 의 집계 값입니다 .</target>
        </trans-unit>
        <trans-unit id="fd0a4fc774ffbf4fe8af10420d93bf7b1af6f41a" translate="yes" xml:space="preserve">
          <source>The aggregate value of the array, including any disabled controls.</source>
          <target state="translated">비활성화 된 컨트롤을 포함한 배열의 집계 값입니다.</target>
        </trans-unit>
        <trans-unit id="0f45a54234e4cd13b23944c4560457d66bc0cc78" translate="yes" xml:space="preserve">
          <source>The aliases control in the form group instance is now populated with a single control until more controls are added dynamically.</source>
          <target state="translated">양식 그룹 인스턴스의 별칭 컨트롤은 이제 더 많은 컨트롤이 동적으로 추가 될 때까지 단일 컨트롤로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="84256de55279155b325c264a0950f97a32368023" translate="yes" xml:space="preserve">
          <source>The alternative display includes an &lt;em&gt;Edit&lt;/em&gt; button whose click event is bound to an expression that clears the &lt;code&gt;submitted&lt;/code&gt; flag.</source>
          <target state="translated">대체 디스플레이에는 &lt;code&gt;submitted&lt;/code&gt; 플래그 를 지우는 표현식에 클릭 이벤트가 바인딩 된 &lt;em&gt;편집&lt;/em&gt; 버튼이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="e34fac3a099ab7998cdfc1b5ee75e1f1e111edc0" translate="yes" xml:space="preserve">
          <source>The alternative is a reactive form. For an introduction and comparison of both forms approaches, see &lt;a href=&quot;forms-overview&quot;&gt;Introduction to Angular Forms&lt;/a&gt;.</source>
          <target state="translated">대안은 반응 형입니다. 두 양식 접근 방식의 소개 및 비교는 &lt;a href=&quot;forms-overview&quot;&gt;각도 양식 소개를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1941cf59d3da9ef9cde211095dfc431f3816eae8" translate="yes" xml:space="preserve">
          <source>The alternative is a template-driven form. For an introduction and comparison of both forms approaches, see &lt;a href=&quot;forms-overview&quot;&gt;Introduction to Angular Forms&lt;/a&gt;.</source>
          <target state="translated">대안은 템플릿 중심 양식입니다. 두 양식 접근 방식의 소개 및 비교는 &lt;a href=&quot;forms-overview&quot;&gt;각도 양식 소개를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2afb8502dfea931790e61f9165c97e230612b7ba" translate="yes" xml:space="preserve">
          <source>The anchor directive</source>
          <target state="translated">앵커 지시어</target>
        </trans-unit>
        <trans-unit id="d6857daa67f01cf8f26a596689dfd09a6f899822" translate="yes" xml:space="preserve">
          <source>The anchor element in the parent view for this embedded view.</source>
          <target state="translated">이 포함 된 뷰에 대한 부모 뷰의 앵커 요소입니다.</target>
        </trans-unit>
        <trans-unit id="6c969a2cfd58f9109f69d4b274dd9f759efa168a" translate="yes" xml:space="preserve">
          <source>The angular i18n extractor tool generates a file with a translation unit entry for each &lt;code&gt;i18n&lt;/code&gt; attribute in a template. By default, it assigns each translation unit a unique id such as this one:</source>
          <target state="translated">각도 i18n 추출기 도구 는 템플리트의 각 &lt;code&gt;i18n&lt;/code&gt; 속성에 대한 변환 단위 항목이있는 파일을 생성합니다 . 기본적으로 각 번역 단위에 다음과 같은 고유 ID를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="b4ed70517cf63237f526da9af09e8982010ac6a8" translate="yes" xml:space="preserve">
          <source>The animation &lt;code&gt;&lt;a href=&quot;../api/animations/trigger&quot;&gt;trigger&lt;/a&gt;()&lt;/code&gt; function emits &lt;em&gt;callbacks&lt;/em&gt; when it starts and when it finishes. In the example below we have a component that contains an &lt;code&gt;openClose&lt;/code&gt; trigger.</source>
          <target state="translated">애니메이션 &lt;code&gt;&lt;a href=&quot;../api/animations/trigger&quot;&gt;trigger&lt;/a&gt;()&lt;/code&gt; 함수 는 시작 및 종료시 &lt;em&gt;콜백&lt;/em&gt; 을 생성합니다. 아래 예에는 &lt;code&gt;openClose&lt;/code&gt; 트리거 가 포함 된 구성 요소가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f36fc312f8edc026c035d420a1e31c8179cfbb5" translate="yes" xml:space="preserve">
          <source>The animation &lt;code&gt;&lt;a href=&quot;../api/animations/trigger&quot;&gt;trigger&lt;/a&gt;()&lt;/code&gt; function emits &lt;em&gt;callbacks&lt;/em&gt; when it starts and when it finishes. The example below features a component that contains an &lt;code&gt;openClose&lt;/code&gt; trigger.</source>
          <target state="translated">애니메이션 &lt;code&gt;&lt;a href=&quot;../api/animations/trigger&quot;&gt;trigger&lt;/a&gt;()&lt;/code&gt; 함수 는 시작 및 완료 될 때 &lt;em&gt;콜백&lt;/em&gt; 을 내 보냅니다. 아래 예제는 &lt;code&gt;openClose&lt;/code&gt; 트리거 를 포함하는 구성 요소를 특징으로 합니다.</target>
        </trans-unit>
        <trans-unit id="32c58e882c1163e1488d4a8deb42e2f4a125fcae" translate="yes" xml:space="preserve">
          <source>The animation code does the following after styling the views:</source>
          <target state="translated">뷰를 스타일링 한 후 애니메이션 코드는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="39510d97650c99c8d731a36b1b5cab49af76350b" translate="yes" xml:space="preserve">
          <source>The animation definition does several things:</source>
          <target state="translated">애니메이션 정의는 여러 가지 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="5c15153dc0c0d7f3e168540e74067114fac5f559" translate="yes" xml:space="preserve">
          <source>The animation does the following:</source>
          <target state="translated">애니메이션은 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="359225b3095525891affab38ee53ef7bf8f5aa89" translate="yes" xml:space="preserve">
          <source>The animation is executed or triggered when the expression value changes to a new state.</source>
          <target state="translated">표현식 값이 새로운 상태로 변경되면 애니메이션이 실행되거나 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="e37c1ace322c9054988c345df432382153656a5c" translate="yes" xml:space="preserve">
          <source>The animation phase in which the callback was invoked, one of &quot;start&quot; or &quot;done&quot;.</source>
          <target state="translated">콜백이 호출 된 애니메이션 단계입니다 ( &quot;시작&quot;또는 &quot;완료&quot;중 하나).</target>
        </trans-unit>
        <trans-unit id="880fbe2cde1e59f262c1b3a83415a83ff7f6bba6" translate="yes" xml:space="preserve">
          <source>The answer is grounded in a fundamental characteristic of the Angular dependency-injection system. An injector can add providers &lt;em&gt;until it's first used&lt;/em&gt;. Once an injector starts creating and delivering services, its provider list is frozen; no new providers are allowed.</source>
          <target state="translated">답은 각도 의존성 주입 시스템의 기본 특성에 근거합니다. 인젝터는 &lt;em&gt;처음 사용될 때까지&lt;/em&gt; 제공자를 추가 할 수 있습니다 . 인젝터가 서비스 작성 및 전달을 시작하면 제공자 목록이 고정됩니다. 새로운 제공자는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a0e08c28364e929009cd4fcd1fafe952fc3e50ec" translate="yes" xml:space="preserve">
          <source>The app ID to use in withServerTransition().</source>
          <target state="translated">withServerTransition ()에서 사용할 앱 ID입니다.</target>
        </trans-unit>
        <trans-unit id="25a56b32ae6b92c99875f10e2a3113c098b85214" translate="yes" xml:space="preserve">
          <source>The app and its translation file</source>
          <target state="translated">앱과 번역 파일</target>
        </trans-unit>
        <trans-unit id="db254e7060d83009dcee1a2432f520bc87c194ef" translate="yes" xml:space="preserve">
          <source>The app displays &quot;Miss Marple&quot; as the user instead of the default &quot;Sherlock Holmes&quot;.</source>
          <target state="translated">앱은 기본 &quot;Sherlock Holmes&quot;대신 &quot;Miss Marple&quot;을 사용자로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="027095d9f26f0b5344d94ebc0591a3e4f039f94d" translate="yes" xml:space="preserve">
          <source>The app identifier to use for transition.</source>
          <target state="translated">전환에 사용할 앱 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="c5d365172cdf1df024ceeae484b684f201469335" translate="yes" xml:space="preserve">
          <source>The app is already set up to use the Angular &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; and to use routing to navigate to the product list component you modified earlier. This section shows you how to define a route to show individual product details.</source>
          <target state="translated">앱은 이미 Angular &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 를 사용하고 라우팅을 사용하여 이전에 수정 한 제품 목록 구성 요소로 이동하도록 설정되어 있습니다. 이 섹션에서는 개별 제품 세부 정보를 표시하는 경로를 정의하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0ac4d8abd7c8f6886de0bd1d638135e72499484d" translate="yes" xml:space="preserve">
          <source>The app is already set up to use the Angular router and to use routing to navigate to the product list component you modified earlier. Let's define a route to show individual product details.</source>
          <target state="translated">앱은 이미 Angular 라우터를 사용하고 라우팅을 사용하여 이전에 수정 한 제품 목록 구성 요소로 이동하도록 설정되어 있습니다. 개별 제품 세부 정보를 표시하는 경로를 정의하겠습니다.</target>
        </trans-unit>
        <trans-unit id="afc7c88884fd7e0ec8cfc8b97f304e1f0a3e0b9e" translate="yes" xml:space="preserve">
          <source>The app now displays the name and description of each product in the list. Notice that the final product does not have a description paragraph. Because the product's description property is empty, Angular doesn't create the &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element&amp;mdash;including the word &quot;Description&quot;.</source>
          <target state="translated">앱은 이제 각 제품의 이름과 설명을 목록에 표시합니다. 최종 제품에는 설명 단락이 없습니다. 제품의 description 속성이 비어 있기 때문에 Angular는 &quot;Description&quot;이라는 단어를 포함하여 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 요소를 만들지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="80b00fe83f126d464662ae9b7cb3f238f2be6cf8" translate="yes" xml:space="preserve">
          <source>The app now has a product list and sharing feature. In the process, you've learned to use five common features of Angular's template syntax:</source>
          <target state="translated">이제 앱에 제품 목록 및 공유 기능이 있습니다. 이 과정에서 Angular 템플릿 구문의 5 가지 공통 기능을 사용하는 방법을 배웠습니다.</target>
        </trans-unit>
        <trans-unit id="0cdfea076c0644e956bc7ea95c84f491e7fb9c75" translate="yes" xml:space="preserve">
          <source>The app now shows unexpected behavior: When the user adds flying heroes, none of them appear under &quot;Heroes who fly.&quot; This happens because the code that adds a hero does so by pushing it onto the &lt;code&gt;heroes&lt;/code&gt; array:</source>
          <target state="translated">이제 앱에 예기치 않은 동작이 표시됩니다. 사용자가 비행 영웅을 추가하면 &quot;나는 영웅&quot;아래에 아무것도 나타나지 않습니다. 이는 hero를 추가하는 코드가이를 &lt;code&gt;heroes&lt;/code&gt; 배열 로 푸시하여 수행하기 때문에 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="4004b359d1942125b76739a78f40d94105d5d4b8" translate="yes" xml:space="preserve">
          <source>The app probably defines more than a dozen financial instrument components. If you're lucky, they all implement the same base class whose API your &lt;code&gt;NewsComponent&lt;/code&gt; understands.</source>
          <target state="translated">응용 프로그램은 아마도 12 개 이상의 금융 상품 구성 요소를 정의합니다. 운이 좋으면 &lt;code&gt;NewsComponent&lt;/code&gt; 이해 하는 API와 동일한 기본 클래스를 모두 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="dbbf8f3b96fb7d36c8dd7548739bff46943fc834" translate="yes" xml:space="preserve">
          <source>The app renders with a row of navigation buttons and the &lt;em&gt;Heroes&lt;/em&gt; view with its list of heroes.</source>
          <target state="translated">앱은 탐색 버튼 행과 &lt;em&gt;Heroes&lt;/em&gt; 목록과 함께 &lt;em&gt;Heroes&lt;/em&gt; 보기로 렌더링됩니다 .</target>
        </trans-unit>
        <trans-unit id="8180573e4452faa80c9d5ca340e48884d6391a8a" translate="yes" xml:space="preserve">
          <source>The app root with the navigation links.</source>
          <target state="translated">탐색 링크가있는 앱 루트</target>
        </trans-unit>
        <trans-unit id="6a56d757961d70a0621db9660baa94da256fbc99" translate="yes" xml:space="preserve">
          <source>The app's code defines the data directly inside the component, which isn't best practice. In a simple demo, however, it's fine.</source>
          <target state="translated">앱의 코드는 구성 요소 내부의 데이터를 직접 정의하지만 모범 사례는 아닙니다. 그러나 간단한 데모에서는 괜찮습니다.</target>
        </trans-unit>
        <trans-unit id="ff5f015f00e1b7bcc2b5b1966f795b0d2d4559e6" translate="yes" xml:space="preserve">
          <source>The appendix material isn't essential. Continued reading is for the curious.</source>
          <target state="translated">부록 자료는 필수가 아닙니다. 계속 읽는 것은 호기심입니다.</target>
        </trans-unit>
        <trans-unit id="b9a3afbab00f003cf626b8798a7fe9cd10bab21f" translate="yes" xml:space="preserve">
          <source>The application builder uses the &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt; build tool, with default configuration options specified in the workspace configuration file (&lt;code&gt;angular.json&lt;/code&gt;) or with a named alternative configuration. A &quot;production&quot; configuration is created by default when you use the CLI to create the project, and you can use that configuration by specifying the &lt;code&gt;--configuration=&quot;production&quot;&lt;/code&gt; or the &lt;code&gt;--prod&lt;/code&gt; option.</source>
          <target state="translated">애플리케이션 빌더는 작업 공간 구성 파일 ( &lt;code&gt;angular.json&lt;/code&gt; )에 지정된 기본 구성 옵션 또는 명명 된 대체 구성과 함께 &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt; 빌드 도구를 사용합니다 . CLI를 사용하여 프로젝트를 생성하면 기본적으로 &quot;프로덕션&quot;구성이 생성되며 &lt;code&gt;--configuration=&quot;production&quot;&lt;/code&gt; 또는 &lt;code&gt;--prod&lt;/code&gt; 옵션 을 지정하여 해당 구성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9dd362d11a1ef5a6531528132f21de5203087f19" translate="yes" xml:space="preserve">
          <source>The application builder uses the &lt;a href=&quot;https://webpack.js.org/&quot;&gt;webpack&lt;/a&gt; build tool, with default configuration options specified in the workspace configuration file (&lt;code&gt;angular.json&lt;/code&gt;) or with a named alternative configuration. A &quot;production&quot; configuration is created by default when you use the CLI to create the project, and you can use that configuration by specifying the &lt;code&gt;--configuration=&quot;production&quot;&lt;/code&gt; or the &lt;code&gt;--prod=&quot;true&quot;&lt;/code&gt; option.</source>
          <target state="translated">애플리케이션 빌더는 작업 공간 구성 파일 ( &lt;code&gt;angular.json&lt;/code&gt; )에 지정된 기본 구성 옵션 또는 명명 된 대체 구성과 함께 &lt;a href=&quot;https://webpack.js.org/&quot;&gt;웹팩&lt;/a&gt; 빌드 도구를 사용합니다 . CLI를 사용하여 프로젝트를 작성할 때 기본적으로 &quot;프로덕션&quot;구성이 작성되며 &lt;code&gt;--configuration=&quot;production&quot;&lt;/code&gt; 또는 &lt;code&gt;--prod=&quot;true&quot;&lt;/code&gt; 옵션 을 지정하여 해당 구성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d185e637c749a1de6fd1f1bdb29eb36d9acb4054" translate="yes" xml:space="preserve">
          <source>The application continues to work just the same, and you can use &lt;code&gt;AppRoutingModule&lt;/code&gt; as the central place to maintain future routing configuration.</source>
          <target state="translated">응용 프로그램은 계속 동일하게 작동하며 &lt;code&gt;AppRoutingModule&lt;/code&gt; 을 중앙 위치로 사용하여 향후 라우팅 구성을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b0dcdc763eccf27206af346ed5971a7a9acc7e5" translate="yes" xml:space="preserve">
          <source>The application enables the Forms feature and registers the created form component.</source>
          <target state="translated">응용 프로그램은 양식 기능을 활성화하고 생성 된 양식 구성 요소를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="f896208078e253c6d0d2530b1eb7048144ab3290" translate="yes" xml:space="preserve">
          <source>The application fails if the user clicks that button because you haven't defined a &lt;code&gt;&quot;/sidekicks&quot;&lt;/code&gt; route yet.</source>
          <target state="translated">아직 &lt;code&gt;&quot;/sidekicks&quot;&lt;/code&gt; 경로를 정의하지 않았기 때문에 사용자가 해당 단추를 클릭하면 응용 프로그램이 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="5a42b907321006905eeb06152c339b50f8d052cb" translate="yes" xml:space="preserve">
          <source>The application has a configured router. The shell component has a &lt;code&gt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;RouterOutlet&lt;/a&gt;&lt;/code&gt; where it can display views produced by the router. It has &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt;s that users can click to navigate via the router.</source>
          <target state="translated">응용 프로그램에 구성된 라우터가 있습니다. 쉘 구성 요소에는 라우터가 생성 &lt;code&gt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;RouterOutlet&lt;/a&gt;&lt;/code&gt; 표시 할 수 있는 RouterOutlet 이 있습니다. 그것은이 &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; 의 사용자가 라우터를 통해 이동을 클릭 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c989c3b0f1e6e8f53d9a09edb55240976ed8f5a3" translate="yes" xml:space="preserve">
          <source>The application has three main feature areas:</source>
          <target state="translated">응용 프로그램에는 세 가지 주요 기능 영역이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3065b933415b7cf762046554acdd3e29eb0e7df7" translate="yes" xml:space="preserve">
          <source>The application is currently bootstrapped using the AngularJS &lt;code&gt;ng-app&lt;/code&gt; directive attached to the &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; element of the host page. This will no longer work in the hybrid app. Switch to the &lt;a href=&quot;upgrade#bootstrapping-hybrid-applications&quot;&gt;ngUpgrade bootstrap&lt;/a&gt; method instead.</source>
          <target state="translated">응용 프로그램은 현재 호스트 페이지 의 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 요소에 연결된 AngularJS &lt;code&gt;ng-app&lt;/code&gt; 지시문을 사용하여 부트 스트랩 됩니다. 하이브리드 앱에서는 더 이상 작동하지 않습니다. 대신 &lt;a href=&quot;upgrade#bootstrapping-hybrid-applications&quot;&gt;ngUpgrade 부트 스트랩&lt;/a&gt; 방법으로 전환하십시오 .</target>
        </trans-unit>
        <trans-unit id="56483481d00ea138c4f54373a7ad2676459f0061" translate="yes" xml:space="preserve">
          <source>The application is still bootstrapped as a hybrid app. There's no need for that anymore.</source>
          <target state="translated">애플리케이션은 여전히 ​​하이브리드 앱으로 부트 스트랩됩니다. 더 이상 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="659c0372b9f399b6beeebc7431038c78d51f057e" translate="yes" xml:space="preserve">
          <source>The application launches by bootstrapping the root &lt;code&gt;AppModule&lt;/code&gt;, which is also referred to as an &lt;code&gt;entryComponent&lt;/code&gt;. Among other things, the bootstrapping process creates the component(s) listed in the &lt;code&gt;bootstrap&lt;/code&gt; array and inserts each one into the browser DOM.</source>
          <target state="translated">응용 프로그램은 루트 &lt;code&gt;AppModule&lt;/code&gt; 을 부트 스트랩하여 시작하며 , 이는 &lt;code&gt;entryComponent&lt;/code&gt; 라고도합니다 . 무엇보다 부트 스트랩 프로세스는 &lt;code&gt;bootstrap&lt;/code&gt; 배열에 나열된 구성 요소를 생성하고 각 구성 요소를 브라우저 DOM에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="2612b202ec4ed4dd6768f7b59b7e18c77e0da23e" translate="yes" xml:space="preserve">
          <source>The application needs a &lt;strong&gt;default route&lt;/strong&gt; to a valid page. The default page for this app is the list of heroes. The app should navigate there as if the user clicked the &quot;Heroes&quot; link or pasted &lt;code&gt;localhost:4200/heroes&lt;/code&gt; into the address bar.</source>
          <target state="translated">응용 프로그램 은 유효한 페이지 로 &lt;strong&gt;기본 경로&lt;/strong&gt; 가 필요 &lt;strong&gt;합니다&lt;/strong&gt; . 이 앱의 기본 페이지는 영웅 목록입니다. 사용자가 &quot;영웅&quot;링크를 클릭하거나 &lt;code&gt;localhost:4200/heroes&lt;/code&gt; 를 주소 표시 줄에 붙여 넣은 것처럼 앱이 탐색해야 합니다.</target>
        </trans-unit>
        <trans-unit id="092f74418595cfa6d21b651c2f1df92beae38cb2" translate="yes" xml:space="preserve">
          <source>The application needs a default route to a valid page. The default page for this app is the list of heroes. The app should navigate there as if the user clicked the &quot;Heroes&quot; link or pasted &lt;code&gt;localhost:4200/heroes&lt;/code&gt; into the address bar.</source>
          <target state="translated">응용 프로그램에는 유효한 페이지에 대한 기본 경로가 필요합니다. 이 앱의 기본 페이지는 영웅 목록입니다. 앱은 사용자가 &quot;Heroes&quot;링크를 클릭하거나 주소 표시 줄에 &lt;code&gt;localhost:4200/heroes&lt;/code&gt; 를 붙여 넣은 것처럼 여기로 이동해야 합니다.</target>
        </trans-unit>
        <trans-unit id="56d4a232475d28d6ebfb5660d2c232d4d967e1c8" translate="yes" xml:space="preserve">
          <source>The application now has a basic title. Next you will create a new component to display hero information and place that component in the application shell.</source>
          <target state="translated">응용 프로그램은 이제 기본 제목을 갖습니다. 다음으로 영웅 정보를 표시하고 해당 구성 요소를 응용 프로그램 셸에 배치 할 새 구성 요소를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="829934fd6d860a7ab62d3a61aa92f15b4a6b5b9a" translate="yes" xml:space="preserve">
          <source>The application startup process is called &lt;strong&gt;bootstrapping&lt;/strong&gt;.</source>
          <target state="translated">응용 프로그램 시작 프로세스를 &lt;strong&gt;bootstrapping&lt;/strong&gt; 이라고 합니다.</target>
        </trans-unit>
        <trans-unit id="2fe6858c50e849cafada85f8462c70c2503bf77f" translate="yes" xml:space="preserve">
          <source>The application still works. Clicking &quot;back&quot; returns to the hero list view.</source>
          <target state="translated">응용 프로그램이 여전히 작동합니다. &quot;뒤로&quot;를 클릭하면 영웅 목록보기로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="046b8cfa4320e7c42d24954dca5b601917075b16" translate="yes" xml:space="preserve">
          <source>The application that StackBlitz generates for this guide comes with predefined shipping data in &lt;code&gt;assets/shipping.json&lt;/code&gt;. Use this data to add shipping prices for items in the cart.</source>
          <target state="translated">StackBlitz가이 가이드를 위해 생성하는 애플리케이션은 &lt;code&gt;assets/shipping.json&lt;/code&gt; 에 미리 정의 된 배송 데이터와 함께 제공됩니다 . 이 데이터를 사용하여 장바구니에있는 항목의 배송비를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f8660ff77e53d3af1d6b5d25c45bdc8f5312cc9f" translate="yes" xml:space="preserve">
          <source>The application will fail if the user clicks that button because you haven't defined a &lt;code&gt;&quot;/sidekicks&quot;&lt;/code&gt; route yet.</source>
          <target state="translated">&lt;code&gt;&quot;/sidekicks&quot;&lt;/code&gt; 경로를 아직 정의하지 않았기 때문에 사용자가 해당 단추를 클릭하면 응용 프로그램이 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="ed54cdb1c808ba8673445f1d2779954ad42d3eed" translate="yes" xml:space="preserve">
          <source>The application-specific configuration files for the root application reside at the workspace root level. For a multi-project workspace, project-specific configuration files are in the project root, under &lt;code&gt;projects/project-name/&lt;/code&gt;.</source>
          <target state="translated">루트 애플리케이션의 애플리케이션 특정 구성 파일은 작업 공간 루트 레벨에 있습니다. 다중 프로젝트 작업 공간의 경우 프로젝트 특정 구성 파일은 프로젝트 루트의 &lt;code&gt;projects/project-name/&lt;/code&gt; 아래에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13ff0efc21d065f969a6bbdb7ff0db29bd8d03e9" translate="yes" xml:space="preserve">
          <source>The architecture of an Angular application relies on certain fundamental concepts. The basic building blocks of the Angular framework are Angular components that are organized into &lt;em&gt;NgModules&lt;/em&gt;. NgModules collect related code into functional sets; an Angular app is defined by a set of NgModules. An app always has at least a &lt;em&gt;root module&lt;/em&gt; that enables bootstrapping, and typically has many more &lt;em&gt;feature modules&lt;/em&gt;.</source>
          <target state="translated">Angular 애플리케이션의 아키텍처는 특정 기본 개념에 의존합니다. Angular 프레임 워크의 기본 구성 요소는 &lt;em&gt;NgModules&lt;/em&gt; 로 구성된 Angular 구성 요소입니다 . NgModules는 관련 코드를 기능 집합으로 수집합니다. Angular 앱은 NgModules 집합으로 정의됩니다. 앱에는 항상 부트 스트랩을 지원 하는 &lt;em&gt;루트 모듈&lt;/em&gt; 이 하나 이상 있으며 일반적으로 더 많은 &lt;em&gt;기능 모듈이&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="212fe89436e2176aa80e03136d002159d641788a" translate="yes" xml:space="preserve">
          <source>The associated Angular directives are prefixed with &lt;code&gt;form&lt;/code&gt;, such as &lt;code&gt;formControl&lt;/code&gt;, &lt;code&gt;formGroup&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrolname&quot;&gt;formControlName&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">연관된 각도 지시문 접두어 &lt;code&gt;form&lt;/code&gt; 같은 &lt;code&gt;formControl&lt;/code&gt; , &lt;code&gt;formGroup&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrolname&quot;&gt;formControlName&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d1134f1a0eb2fdd5f3a8e0fb4e5b2e806b71dc5" translate="yes" xml:space="preserve">
          <source>The associated Angular directives are prefixed with &lt;code&gt;ng&lt;/code&gt; such as &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;ngForm&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodelgroup&quot;&gt;ngModelGroup&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">연관된 Angular 지시문에는 &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;ngForm&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodelgroup&quot;&gt;ngModelGroup&lt;/a&gt;&lt;/code&gt; 과 같은 &lt;code&gt;ng&lt;/code&gt; 가 접두어로 붙 습니다 .</target>
        </trans-unit>
        <trans-unit id="b789263e42e1ba12a8ef45ee17e36b2666f38151" translate="yes" xml:space="preserve">
          <source>The asterisk (*) prefix</source>
          <target state="translated">별표 (*) 접두사</target>
        </trans-unit>
        <trans-unit id="cf3cb31b10ef2ee87b7198fc18b7ebdda8470524" translate="yes" xml:space="preserve">
          <source>The asterisk (*) syntax is more clear than the desugared form. Use &lt;a href=&quot;structural-directives#ng-container&quot;&gt;&amp;lt;ng-container&amp;gt;&lt;/a&gt; when there's no single element to host the directive.</source>
          <target state="translated">별표 (*) 구문은 설탕 제거 양식보다 명확합니다. 지시문을 호스팅 할 단일 요소가없는 경우 &lt;a href=&quot;structural-directives#ng-container&quot;&gt;&amp;lt;ng-container&amp;gt;를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="751e6d020be23e3837cb4d0404a963f68690e654" translate="yes" xml:space="preserve">
          <source>The asterisk is &quot;syntactic sugar&quot; for something a bit more complicated. Internally, Angular translates the &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt;&lt;em&gt;attribute&lt;/em&gt; into a &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt;&lt;em&gt;element&lt;/em&gt;, wrapped around the host element, like this.</source>
          <target state="translated">별표는 좀 더 복잡한 것을위한 &quot;구문 설탕&quot;입니다. 내부적으로 Angular는 &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; &lt;em&gt; 속성&lt;/em&gt; 을 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; &lt;em&gt;요소&lt;/em&gt; 로 변환 하여 호스트 요소를 다음과 같이 감 쌉니다.</target>
        </trans-unit>
        <trans-unit id="3b4a29f29c11882e809acfcb05aa2c373ab6faac" translate="yes" xml:space="preserve">
          <source>The async &lt;em&gt;beforeEach&lt;/em&gt;</source>
          <target state="translated">비동기 &lt;em&gt;beforeEach&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5c45708a98d5362eedbae57d26a0c6334302defc" translate="yes" xml:space="preserve">
          <source>The async observable was produced by an &lt;code&gt;asyncData&lt;/code&gt; helper. The &lt;code&gt;asyncData&lt;/code&gt; helper is a utility function that you'll have to write yourself, or you can copy this one from the sample code.</source>
          <target state="translated">비동기 관찰 가능은 &lt;code&gt;asyncData&lt;/code&gt; 도우미에 의해 생성되었습니다 . &lt;code&gt;asyncData&lt;/code&gt; 의 도우미는 사용자가 직접 작성해야하거나 샘플 코드에서이 하나를 복사 할 수있는 유틸리티 기능입니다.</target>
        </trans-unit>
        <trans-unit id="20002a8d76c8443af179a912eabfe7d2bd723ba6" translate="yes" xml:space="preserve">
          <source>The async validators registered with this group.</source>
          <target state="translated">이 그룹에 등록 된 비동기 유효성 검사기</target>
        </trans-unit>
        <trans-unit id="2fbd14477caf9ebf68f9c80df83d21e5c5c18a6c" translate="yes" xml:space="preserve">
          <source>The attribute name.</source>
          <target state="translated">속성 이름</target>
        </trans-unit>
        <trans-unit id="46f07f08fc1b4870de9353911f6a05a26df4cdc3" translate="yes" xml:space="preserve">
          <source>The author of a guide page is responsible for the code sample that supports that page. The author must also write end-to-end tests for the sample.</source>
          <target state="translated">가이드 페이지 작성자는 해당 페이지를 지원하는 코드 샘플을 담당합니다. 또한 저자는 샘플에 대한 종단 간 테스트를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="c55158bff8f14a5af007abfba787b3d08fdaf5eb" translate="yes" xml:space="preserve">
          <source>The authority to change the &lt;code&gt;navigation.json&lt;/code&gt; file is limited to a few core team members. But for a new guide page, you should suggest a navigation title and position in the left-side navigation panel called the &quot;side nav&quot;.</source>
          <target state="translated">&lt;code&gt;navigation.json&lt;/code&gt; 파일 을 변경하는 권한 은 몇 가지 핵심 팀 구성원으로 제한됩니다. 그러나 새로운 가이드 페이지의 경우 왼쪽 탐색 패널에서 &quot;사이드 탐색&quot;이라는 탐색 제목과 위치를 제안해야합니다.</target>
        </trans-unit>
        <trans-unit id="c9cca8eb36b32cb72b65257ae685ecc71bda7db3" translate="yes" xml:space="preserve">
          <source>The balance of this guide is a set of appendices that elaborate some of the points you covered quickly above.</source>
          <target state="translated">이 안내서의 균형은 위에서 언급 한 몇 가지 사항을 자세히 설명하는 일련의 부록입니다.</target>
        </trans-unit>
        <trans-unit id="62e80f8200c53dbaacf1f70959c15d031920c2db" translate="yes" xml:space="preserve">
          <source>The base &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; configuration for projects in the workspace. All other configuration files inherit from this base file. For more information, see the &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#configuration-inheritance-with-extends&quot;&gt;Configuration inheritance with extends&lt;/a&gt; section of the TypeScript documentation.</source>
          <target state="translated">작업 공간의 프로젝트에 대한 기본 &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; 구성입니다. 다른 모든 구성 파일은이 기본 파일에서 상속됩니다. 자세한 내용 은 TypeScript 문서의 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#configuration-inheritance-with-extends&quot;&gt;확장을 사용한 구성 상속&lt;/a&gt; 섹션을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="522287acd1fcc8d0b65512fb495f5cbde0a52b11" translate="yes" xml:space="preserve">
          <source>The base URL for resolving absolute URL for HTTP requests. It must be set if &lt;code&gt;useAbsoluteUrl&lt;/code&gt; is true, and must consist of protocol, hostname, and optional port. This option has no effect if &lt;code&gt;useAbsoluteUrl&lt;/code&gt; is not enabled.</source>
          <target state="translated">HTTP 요청에 대한 절대 URL을 확인하기위한 기본 URL입니다. &lt;code&gt;useAbsoluteUrl&lt;/code&gt; 이 true 인 경우 설정되어야하며 프로토콜, 호스트 이름 및 선택적 포트로 구성되어야합니다. 이 옵션은 &lt;code&gt;useAbsoluteUrl&lt;/code&gt; 이 활성화되지 않은 경우 효과 가 없습니다.</target>
        </trans-unit>
        <trans-unit id="28e0d32989f227e01be5c403027f23cddf2ddede" translate="yes" xml:space="preserve">
          <source>The base URL for the URL</source>
          <target state="translated">URL의 기본 URL</target>
        </trans-unit>
        <trans-unit id="57099de5f5cfe3bbdb7d5e04cfb9753de8a79ecf" translate="yes" xml:space="preserve">
          <source>The base class to implement.</source>
          <target state="translated">구현할 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="3535061e9163fbc474fb7bea7e4b0e4221db4845" translate="yes" xml:space="preserve">
          <source>The base file &lt;code&gt;environment.ts&lt;/code&gt;, contains the default environment settings. For example:</source>
          <target state="translated">기본 파일 &lt;code&gt;environment.ts&lt;/code&gt; 는 기본 환경 설정을 포함합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eba0a2970a5d5416f712668687e7f717166ec56a" translate="yes" xml:space="preserve">
          <source>The base for the URL</source>
          <target state="translated">URL의 기본</target>
        </trans-unit>
        <trans-unit id="f719337e6149dc965109a2c27fc6710518952795" translate="yes" xml:space="preserve">
          <source>The baseline size for comparison.</source>
          <target state="translated">비교할 기준 크기입니다.</target>
        </trans-unit>
        <trans-unit id="acd2918d5aedfdef3ee567f11a80ee9bf8efacd9" translate="yes" xml:space="preserve">
          <source>The basic NgModule</source>
          <target state="translated">기본 NgModule</target>
        </trans-unit>
        <trans-unit id="effcca684bb65593213fc80d2f4bc7710498f947" translate="yes" xml:space="preserve">
          <source>The basic building blocks of an Angular application are &lt;em&gt;NgModules&lt;/em&gt;, which provide a compilation context for &lt;em&gt;components&lt;/em&gt;. NgModules collect related code into functional sets; an Angular app is defined by a set of NgModules. An app always has at least a &lt;em&gt;root module&lt;/em&gt; that enables bootstrapping, and typically has many more &lt;em&gt;feature modules&lt;/em&gt;.</source>
          <target state="translated">Angular 응용 프로그램의 기본 빌딩 블록은 &lt;em&gt;NgModules&lt;/em&gt; 이며 &lt;em&gt;구성 요소에&lt;/em&gt; 대한 컴파일 컨텍스트를 제공합니다 . NgModules는 관련 코드를 기능 세트로 수집합니다. Angular 앱은 NgModules 집합으로 정의됩니다. 앱에는 항상 부트 스트랩을 가능하게 하는 &lt;em&gt;루트 모듈&lt;/em&gt; 이 있으며 일반적으로 더 많은 &lt;em&gt;기능 모듈이&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cefca9c2b8409ec18d9ee7ef0e08cb1327edec9" translate="yes" xml:space="preserve">
          <source>The basic version can evolve to support a richer variety of questions, more graceful rendering, and superior user experience.</source>
          <target state="translated">기본 버전은보다 다양한 질문,보다 우아한 렌더링 및 우수한 사용자 경험을 지원하도록 발전 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6650d02a072a3d2f1f14aae05a80f687c7755565" translate="yes" xml:space="preserve">
          <source>The basics of &lt;a href=&quot;architecture-components#template-syntax&quot;&gt;Angular template syntax&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;architecture-components#template-syntax&quot;&gt;Angular 템플릿 구문&lt;/a&gt; 의 기초 .</target>
        </trans-unit>
        <trans-unit id="891e8b0d931b98e89c149cf4d8b8e9a75dec7e52" translate="yes" xml:space="preserve">
          <source>The basics of &lt;a href=&quot;template-syntax&quot;&gt;Angular template syntax&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;template-syntax&quot;&gt;Angular 템플릿 구문&lt;/a&gt; 의 기초 .</target>
        </trans-unit>
        <trans-unit id="fcfb49ac405d1244456d49ab443227db937f7f95" translate="yes" xml:space="preserve">
          <source>The beauty of marble testing is in the visual definition of the observable streams. This test defines a &lt;a href=&quot;testing#cold-observable&quot;&gt;&lt;em&gt;cold&lt;/em&gt; observable&lt;/a&gt; that waits three &lt;a href=&quot;testing#marble-frame&quot;&gt;frames&lt;/a&gt; (&lt;code&gt;---&lt;/code&gt;), emits a value (&lt;code&gt;x&lt;/code&gt;), and completes (&lt;code&gt;|&lt;/code&gt;). In the second argument you map the value marker (&lt;code&gt;x&lt;/code&gt;) to the emitted value (&lt;code&gt;testQuote&lt;/code&gt;).</source>
          <target state="translated">대리석 테스트의 아름다움은 관찰 가능한 스트림의 시각적 정의에 있습니다. 이 테스트는 3 개의 &lt;a href=&quot;testing#marble-frame&quot;&gt;프레임&lt;/a&gt; ( &lt;code&gt;---&lt;/code&gt; ) 을 대기 하고 값 ( &lt;code&gt;x&lt;/code&gt; )을 방출 하고 완료 ( &lt;code&gt;|&lt;/code&gt; ) 하는 &lt;a href=&quot;testing#cold-observable&quot;&gt;&lt;em&gt;콜드&lt;/em&gt; 옵저버 블&lt;/a&gt; 을 정의합니다 . 두 번째 인수에서는 값 마커 ( &lt;code&gt;x&lt;/code&gt; )를 방출 된 값 ( &lt;code&gt;testQuote&lt;/code&gt; )에 맵핑 합니다.</target>
        </trans-unit>
        <trans-unit id="043f7bfbada1679dd54dd8a56e0f46a600dbbd8c" translate="yes" xml:space="preserve">
          <source>The beauty of marble testing is in the visual definition of the observable streams. This test defines a &lt;a href=&quot;testing-components-scenarios#cold-observable&quot;&gt;&lt;em&gt;cold&lt;/em&gt; observable&lt;/a&gt; that waits three &lt;a href=&quot;testing-components-scenarios#marble-frame&quot;&gt;frames&lt;/a&gt; (&lt;code&gt;---&lt;/code&gt;), emits a value (&lt;code&gt;x&lt;/code&gt;), and completes (&lt;code&gt;|&lt;/code&gt;). In the second argument you map the value marker (&lt;code&gt;x&lt;/code&gt;) to the emitted value (&lt;code&gt;testQuote&lt;/code&gt;).</source>
          <target state="translated">대리석 테스트의 아름다움은 관찰 가능한 스트림의 시각적 정의에 있습니다. 이 테스트는 세 &lt;a href=&quot;testing-components-scenarios#marble-frame&quot;&gt;프레임&lt;/a&gt; ( &lt;code&gt;---&lt;/code&gt; ) 을 대기 하고 값 ( &lt;code&gt;x&lt;/code&gt; )을 내 보낸 후 완료 ( &lt;code&gt;|&lt;/code&gt; ) 하는 &lt;a href=&quot;testing-components-scenarios#cold-observable&quot;&gt;&lt;em&gt;콜드&lt;/em&gt; 옵저버 블&lt;/a&gt; 을 정의합니다 . 두 번째 인수에서 값 마커 ( &lt;code&gt;x&lt;/code&gt; )를 내 보낸 값 ( &lt;code&gt;testQuote&lt;/code&gt; )에 매핑 합니다.</target>
        </trans-unit>
        <trans-unit id="2edba611517a05b39ecce086b35051547ded4fc7" translate="yes" xml:space="preserve">
          <source>The behavior is similar when you write a constructor that requires an injected class-based dependency. When you define a constructor parameter with the &lt;code&gt;HeroService&lt;/code&gt; class type, Angular knows to inject the service associated with that &lt;code&gt;HeroService&lt;/code&gt; class token:</source>
          <target state="translated">주입 된 클래스 기반 종속성이 필요한 생성자를 작성할 때의 동작은 비슷합니다. &lt;code&gt;HeroService&lt;/code&gt; 클래스 유형 으로 생성자 매개 변수를 정의하면 Angular는 해당 &lt;code&gt;HeroService&lt;/code&gt; 클래스 토큰 과 연관된 서비스를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="32153d084333f937ba427f5295fec97c1fe75cf8" translate="yes" xml:space="preserve">
          <source>The binding conveys information about the event. This information can include data values such as an event object, string, or number named &lt;code&gt;$event&lt;/code&gt;.</source>
          <target state="translated">바인딩은 이벤트에 대한 정보를 전달합니다. 이 정보에는 이벤트 객체, 문자열 또는 &lt;code&gt;$event&lt;/code&gt; 라는 숫자와 같은 데이터 값이 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d0b9ef8d2bdf9e1a86196d518bf9f9db67ec13e" translate="yes" xml:space="preserve">
          <source>The binding executes the statement within a context that includes the DOM event object, &lt;code&gt;$event&lt;/code&gt;.</source>
          <target state="translated">바인딩은 DOM 이벤트 객체 &lt;code&gt;$event&lt;/code&gt; 를 포함하는 컨텍스트 내에서 명령문을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="e66feaf21874ec24c62d2c0bfdf3e80de0fdbb10" translate="yes" xml:space="preserve">
          <source>The binding matcher relies on AngularJS data binding</source>
          <target state="translated">바인딩 매처는 AngularJS 데이터 바인딩에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="fde66a8e4a2d1977e8552f1e09947ea468bf5e21" translate="yes" xml:space="preserve">
          <source>The bootstrap zone for the upgrade application</source>
          <target state="translated">업그레이드 응용 프로그램의 부트 스트랩 영역</target>
        </trans-unit>
        <trans-unit id="02e0a35afc164ea455b1247684f9f9299b769401" translate="yes" xml:space="preserve">
          <source>The bootstrapped root &lt;code&gt;AppComponent&lt;/code&gt; is an &lt;em&gt;entry component&lt;/em&gt;. True, its selector matches an element tag in &lt;code&gt;index.html&lt;/code&gt;. But &lt;code&gt;index.html&lt;/code&gt; isn't a component template and the &lt;code&gt;AppComponent&lt;/code&gt; selector doesn't match an element in any component template.</source>
          <target state="translated">부트 스트랩 된 루트 &lt;code&gt;AppComponent&lt;/code&gt; 는 &lt;em&gt;항목 구성 요소&lt;/em&gt; 입니다. 사실, 선택기는 &lt;code&gt;index.html&lt;/code&gt; 의 요소 태그와 일치합니다 . 그러나 &lt;code&gt;index.html&lt;/code&gt; 은 구성 요소 템플릿이 아니며 &lt;code&gt;AppComponent&lt;/code&gt; 선택기는 구성 요소 템플릿의 요소와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="438a9cd3a363b134dfcd99e057df9d3a75cf0cef" translate="yes" xml:space="preserve">
          <source>The bootstrapped root component.</source>
          <target state="translated">부트 스트랩 된 루트 구성 요소</target>
        </trans-unit>
        <trans-unit id="5399b75d7a78532d352ee3f6549ed287c3a81704" translate="yes" xml:space="preserve">
          <source>The brackets, &lt;code&gt;[]&lt;/code&gt;, cause Angular to evaluate the right-hand side of the assignment as a dynamic expression. Without the brackets, Angular treats the the right-hand side as a string literal and sets the property to that static value.</source>
          <target state="translated">대괄호 &lt;code&gt;[]&lt;/code&gt; 는 Angular가 할당의 오른쪽을 동적 표현식으로 평가하도록합니다. 대괄호가 없으면 Angular는 오른쪽을 문자열 리터럴로 취급하고 속성을 해당 정적 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8ef4ee708285425cb9ef88beb31132640eba2132" translate="yes" xml:space="preserve">
          <source>The brackets, &lt;code&gt;[]&lt;/code&gt;, tell Angular to evaluate the template expression. If you omit the brackets, Angular treats the string as a constant and &lt;em&gt;initializes the target property&lt;/em&gt; with that string:</source>
          <target state="translated">괄호 &lt;code&gt;[]&lt;/code&gt; 는 Angular에게 템플릿 표현식을 평가하도록 지시합니다. 대괄호를 생략하면 Angular는 문자열을 상수로 취급하고 해당 문자열로 &lt;em&gt;대상 속성&lt;/em&gt; 을 &lt;em&gt;초기화&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c1feb87ec9550df145615086e8f3767f244e3a08" translate="yes" xml:space="preserve">
          <source>The browser address bar shows &lt;code&gt;.../heroes&lt;/code&gt; as if you'd navigated there directly.</source>
          <target state="translated">브라우저 주소 표시 줄에 &lt;code&gt;.../heroes&lt;/code&gt; 이 직접 탐색 한 것처럼 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="bd60d31fa4f304dfebce4165416af0762306c2cf" translate="yes" xml:space="preserve">
          <source>The browser does not download the service worker script and &lt;code&gt;ngsw.json&lt;/code&gt; manifest file.</source>
          <target state="translated">브라우저는 서비스 워커 스크립트 및 &lt;code&gt;ngsw.json&lt;/code&gt; 매니페스트 파일을 다운로드하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4dff3dc3654746ecbf5404102b359a8b2ed8a409" translate="yes" xml:space="preserve">
          <source>The browser doesn't process the HTML and instead displays it raw, as follows.</source>
          <target state="translated">브라우저는 HTML을 처리하지 않고 대신 다음과 같이 원시 상태로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="35b0e92376d69e4ef661396d137d20849c9d556f" translate="yes" xml:space="preserve">
          <source>The browser is a familiar model of application navigation:</source>
          <target state="translated">브라우저는 익숙한 응용 프로그램 탐색 모델입니다.</target>
        </trans-unit>
        <trans-unit id="15d36d861b545a684a9e5ea9c902708889325b8b" translate="yes" xml:space="preserve">
          <source>The browser now renders the following, omitting the previous examples for brevity:</source>
          <target state="translated">브라우저는 이제 다음을 렌더링하고 간결하게하기 위해 이전 예제를 생략합니다.</target>
        </trans-unit>
        <trans-unit id="4e64586da0c751f5944b08cc25ed0266a7ab13d6" translate="yes" xml:space="preserve">
          <source>The browser refreshes and displays the app title and heroes link, but not the heroes list.</source>
          <target state="translated">브라우저가 앱 제목과 영웅 링크를 새로 고치고 표시하지만 영웅 목록은 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="133c2ebe14781b8826924474cf293ac9fc41ab61" translate="yes" xml:space="preserve">
          <source>The browser refreshes and displays the hero's information.</source>
          <target state="translated">브라우저가 새로 고쳐지고 영웅의 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a8489bb56b8d3c19ce6ee0631e9a122a2265bf15" translate="yes" xml:space="preserve">
          <source>The browser refreshes and displays the new application title.</source>
          <target state="translated">브라우저가 새로 고쳐지고 새 응용 프로그램 제목이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="10d2bffee74f9f32b1e61f1be54989dd1c6cc5fa" translate="yes" xml:space="preserve">
          <source>The browser refreshes and now the hero's name is displayed in capital letters.</source>
          <target state="translated">브라우저가 새로 고쳐지고 이제 영웅의 이름이 대문자로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="35ae0dc5e77b04c47f765fe14b310abb1d8a872a" translate="yes" xml:space="preserve">
          <source>The browser refreshes and the app crashes with a compiler error. &lt;code&gt;HeroService&lt;/code&gt; doesn't have a &lt;code&gt;getHero()&lt;/code&gt; method. Add it now.</source>
          <target state="translated">브라우저가 새로 고쳐지고 앱이 컴파일러 오류와 충돌합니다. &lt;code&gt;HeroService&lt;/code&gt; 에는 &lt;code&gt;getHero()&lt;/code&gt; 메소드 가 없습니다 . 지금 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ddd180f39b4c9fc1fda12238a08d9a92883f1c13" translate="yes" xml:space="preserve">
          <source>The browser refreshes and the app is working again. You can click a hero in the dashboard or in the heroes list and navigate to that hero's detail view.</source>
          <target state="translated">브라우저가 새로 고쳐지고 앱이 다시 작동합니다. 대시 보드 또는 영웅 목록에서 영웅을 클릭하고 해당 영웅의 상세보기로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e88d32f27973b4cfeee563874f1886550dc5ac79" translate="yes" xml:space="preserve">
          <source>The browser refreshes and the app starts working again as it did before.</source>
          <target state="translated">브라우저가 새로 고쳐지고 앱이 이전처럼 다시 작동하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="ff713c5acce26c8a8f6436f37009b416e9435f49" translate="yes" xml:space="preserve">
          <source>The browser refreshes and the page displays the list of heroes. Scroll to the bottom to see the message from the &lt;code&gt;HeroService&lt;/code&gt; in the message area. Click the &quot;clear&quot; button and the message area disappears.</source>
          <target state="translated">브라우저가 새로 고쳐지고 페이지에 영웅 목록이 표시됩니다. 메시지 영역에서 &lt;code&gt;HeroService&lt;/code&gt; 의 메시지를 보려면 맨 아래로 스크롤하십시오 . &quot;삭제&quot;버튼을 클릭하면 메시지 영역이 사라집니다.</target>
        </trans-unit>
        <trans-unit id="cdb7b4eed65968a0c60496c1330166de228b5429" translate="yes" xml:space="preserve">
          <source>The browser should refresh and display the app title but not the list of heroes.</source>
          <target state="translated">브라우저는 앱 제목을 새로 고쳐서 표시해야하지만 영웅 목록은 표시하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="3980e997a7b117fe62ffce3f3b2a0b5e77fea676" translate="yes" xml:space="preserve">
          <source>The browser won't display an &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; within a &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">브라우저는 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 내에 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 을 표시하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="14e80d1c5f056a696f1915bb5d74d05712d1d29b" translate="yes" xml:space="preserve">
          <source>The build process uses &lt;a href=&quot;glossary#ahead-of-time-aot-compilation&quot;&gt;ahead-of-time (AOT) compilation&lt;/a&gt; to produce a small, fast, ready-to-run app. With Ivy in Angular version 9, AOT is used by default for both development and production builds, and AOT is required to localize component templates.</source>
          <target state="translated">빌드 프로세스는 &lt;a href=&quot;glossary#ahead-of-time-aot-compilation&quot;&gt;AOT (Ahead-of-Time) 컴파일&lt;/a&gt; 을 사용하여 작고 빠르며 바로 실행할 수있는 앱을 생성합니다. Angular 버전 9의 Ivy에서는 AOT가 기본적으로 개발 및 프로덕션 빌드 모두에 사용되며 AOT는 구성 요소 템플릿을 지역화하는 데 필요합니다.</target>
        </trans-unit>
        <trans-unit id="92146b9358486bbcf5077ab8741177ac14e2a2bf" translate="yes" xml:space="preserve">
          <source>The build step is important if you haven't published your library as an npm package and then installed the package back into your app from npm. For instance, if you clone your git repository and run &lt;code&gt;npm install&lt;/code&gt;, your editor will show the &lt;code&gt;my-lib&lt;/code&gt; imports as missing if you haven't yet built your library.</source>
          <target state="translated">라이브러리를 npm 패키지로 게시하지 않은 다음 npm에서 앱에 패키지를 다시 설치 한 경우 빌드 단계가 중요합니다. 예를 들어, git 저장소를 복제하고 &lt;code&gt;npm install&lt;/code&gt; 을 실행 하면 라이브러리를 아직 빌드하지 않은 경우 편집기에 &lt;code&gt;my-lib&lt;/code&gt; 가져 오기가 누락 된 것으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b332d6a59c4de48eb194eed9848b874deab58d55" translate="yes" xml:space="preserve">
          <source>The build system for apps, &lt;code&gt;@angular-devkit/build-angular&lt;/code&gt;, is based on &lt;code&gt;webpack&lt;/code&gt;, and is included in all new Angular CLI projects.</source>
          <target state="translated">&lt;code&gt;@angular-devkit/build-angular&lt;/code&gt; 앱용 빌드 시스템은 &lt;code&gt;webpack&lt;/code&gt; 을 기반으로 하며 모든 새로운 Angular CLI 프로젝트에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f7834a2399202ec039da155d28f4732ed390ded5" translate="yes" xml:space="preserve">
          <source>The build system for libraries is based on &lt;code&gt;ng-packagr&lt;/code&gt;. It is only added to your dependencies when you add a library using &lt;code&gt;ng generate library my-lib&lt;/code&gt;.</source>
          <target state="translated">라이브러리의 빌드 시스템은 &lt;code&gt;ng-packagr&lt;/code&gt; 기반입니다 . &lt;code&gt;ng generate library my-lib&lt;/code&gt; 를 사용하여 라이브러리를 추가 할 때만 종속성에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="e9d7c89f6355b9b74a563d2b71f0981c52287f26" translate="yes" xml:space="preserve">
          <source>The builder function is not executed until the scheduler returns a &lt;code&gt;BuilderRun&lt;/code&gt; control object. The CLI typically schedules tasks by calling the &lt;code&gt;BuilderContext.scheduleTarget()&lt;/code&gt; function, and then resolves input options using the target definition in the &lt;code&gt;angular.json&lt;/code&gt; file.</source>
          <target state="translated">스케줄러가 &lt;code&gt;BuilderRun&lt;/code&gt; 제어 오브젝트를 리턴 할 때까지 빌더 기능이 실행되지 않습니다 . CLI는 일반적으로 &lt;code&gt;BuilderContext.scheduleTarget()&lt;/code&gt; 함수 를 호출하여 작업을 예약 한 다음 &lt;code&gt;angular.json&lt;/code&gt; 파일 의 대상 정의를 사용하여 입력 옵션을 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="60025dc689d82f5907f20636b33bf1a757ea740e" translate="yes" xml:space="preserve">
          <source>The builder handler function can be synchronous (return a value) or asynchronous (return a Promise), or it can watch and return multiple values (return an Observable). The return value or values must always be of type &lt;code&gt;BuilderOutput&lt;/code&gt;. This object contains a Boolean &lt;code&gt;success&lt;/code&gt; field and an optional &lt;code&gt;error&lt;/code&gt; field that can contain an error message.</source>
          <target state="translated">빌더 핸들러 함수는 동기식 (값 리턴) 또는 비동기식 (Promise 리턴)이거나 여러 값을보고 리턴 (Observable 리턴) 할 수 있습니다. 리턴 값은 항상 &lt;code&gt;BuilderOutput&lt;/code&gt; 유형이어야합니다 . 이 개체는 부울 &lt;code&gt;success&lt;/code&gt; 필드와 오류 메시지를 포함 할 수 있는 선택적 &lt;code&gt;error&lt;/code&gt; 필드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="fbde09f90e553f00908e4a943a5ad8a525206f7a" translate="yes" xml:space="preserve">
          <source>The builder should always emit a &lt;code&gt;BuilderOutput&lt;/code&gt; object after each execution. Once it&amp;rsquo;s been executed, it can enter a watch mode, to be triggered by an external event. If an event triggers it to restart, the builder should execute the &lt;code&gt;BuilderContext.reportRunning()&lt;/code&gt; function to tell Architect that it is running again. This prevents Architect from stopping the builder if another run is scheduled.</source>
          <target state="translated">빌더는 각 실행 후 항상 &lt;code&gt;BuilderOutput&lt;/code&gt; 오브젝트를 방출해야합니다 . 일단 실행되면 외부 이벤트에 의해 트리거되도록 감시 모드로 들어갈 수 있습니다. 이벤트가 다시 시작하도록 트리거하는 경우 빌더는 &lt;code&gt;BuilderContext.reportRunning()&lt;/code&gt; 함수를 실행하여 Architect에게 다시 실행 중임을 알려야합니다. 이는 다른 실행이 스케줄 된 경우 Architect가 빌더를 중지하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="f49f4287e9775e1849d1d16275e5c1d9b379ace2" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;../api/common/jsonpipe&quot;&gt;JsonPipe&lt;/a&gt; provides a way to diagnose a mysteriously failing data binding or to inspect an object for future binding.</source>
          <target state="translated">기본 제공 &lt;a href=&quot;../api/common/jsonpipe&quot;&gt;JsonPipe&lt;/a&gt; 는 신비하게 실패한 데이터 바인딩을 진단하거나 향후 바인딩을 위해 개체를 검사하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dd3cba59a8ad93f9f11597609f818467f4d13876" translate="yes" xml:space="preserve">
          <source>The built-in AngularJS &lt;code&gt;filter&lt;/code&gt; and &lt;code&gt;orderBy&lt;/code&gt; filters do not exist in Angular, so you need to do the filtering and sorting yourself.</source>
          <target state="translated">내장 AngularJS &lt;code&gt;filter&lt;/code&gt; 및 &lt;code&gt;orderBy&lt;/code&gt; 필터는 Angular에 존재하지 않으므로 직접 필터링하고 정렬해야합니다.</target>
        </trans-unit>
        <trans-unit id="27c4675a67e0eef6db4eb2262eed281861d1655a" translate="yes" xml:space="preserve">
          <source>The built-in browser DOM APIs don't automatically protect you from security vulnerabilities. For example, &lt;code&gt;&lt;a href=&quot;../api/platform-server/platformconfig#document&quot;&gt;document&lt;/a&gt;&lt;/code&gt;, the node available through &lt;code&gt;&lt;a href=&quot;../api/core/elementref&quot;&gt;ElementRef&lt;/a&gt;&lt;/code&gt;, and many third-party APIs contain unsafe methods. In the same way, if you interact with other libraries that manipulate the DOM, you likely won't have the same automatic sanitization as with Angular interpolations. Avoid directly interacting with the DOM and instead use Angular templates where possible.</source>
          <target state="translated">기본 제공 브라우저 DOM API는 보안 취약점으로부터 자동으로 보호하지 않습니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;../api/platform-server/platformconfig#document&quot;&gt;document&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/core/elementref&quot;&gt;ElementRef&lt;/a&gt;&lt;/code&gt; 를 통해 사용 가능한 노드 및 많은 타사 API에는 안전하지 않은 메소드가 포함되어 있습니다. 같은 방식으로 DOM을 조작하는 다른 라이브러리와 상호 작용하면 각도 보간과 동일한 자동 살균이 없을 수 있습니다. DOM과 직접 상호 작용하지 말고 가능한 경우 Angular 템플릿을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="27a7000125e6fd5e12b64464ee5108af7e83095b" translate="yes" xml:space="preserve">
          <source>The built-in browser DOM APIs don't automatically protect you from security vulnerabilities. For example, &lt;code&gt;document&lt;/code&gt;, the node available through &lt;code&gt;&lt;a href=&quot;../api/core/elementref&quot;&gt;ElementRef&lt;/a&gt;&lt;/code&gt;, and many third-party APIs contain unsafe methods. In the same way, if you interact with other libraries that manipulate the DOM, you likely won't have the same automatic sanitization as with Angular interpolations. Avoid directly interacting with the DOM and instead use Angular templates where possible.</source>
          <target state="translated">내장 된 브라우저 DOM API는 보안 취약성으로부터 사용자를 자동으로 보호하지 않습니다. 예를 들어, &lt;code&gt;document&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/core/elementref&quot;&gt;ElementRef&lt;/a&gt;&lt;/code&gt; 를 통해 사용 가능한 노드 및 많은 타사 API에는 안전하지 않은 메서드가 포함되어 있습니다. 같은 방식으로 DOM을 조작하는 다른 라이브러리와 상호 작용하는 경우 Angular 보간과 동일한 자동 삭제 기능이 없을 것입니다. DOM과 직접 상호 작용하지 말고 가능한 경우 Angular 템플릿을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ba40c60b86170477c8de2f47167fe787c47e2c28" translate="yes" xml:space="preserve">
          <source>The built-in validators don't always match the exact use case of your application, so you sometimes need to create a custom validator.</source>
          <target state="translated">기본 제공 유효성 검사기가 애플리케이션의 정확한 사용 사례와 항상 일치하는 것은 아니므로 때때로 사용자 지정 유효성 검사기를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="39744b033a42ddea775e1f902f35f4d12364d185" translate="yes" xml:space="preserve">
          <source>The bundle is injected by default, but you can set &lt;code&gt;inject&lt;/code&gt; to false to exclude the bundle from injection. For example, the following object values create and name a bundle that contains styles and scripts, and excludes it from injection:</source>
          <target state="translated">번들은 기본적으로 주입되지만 &lt;code&gt;inject&lt;/code&gt; 에서 번들을 제외하도록 inject 를 false로 설정할 수 있습니다 . 예를 들어, 다음 객체 값은 스타일과 스크립트가 포함 된 번들을 작성하고 이름을 지정하고 삽입에서 제외합니다.</target>
        </trans-unit>
        <trans-unit id="9ff88152d1671e545c950355e4856d89b2193246" translate="yes" xml:space="preserve">
          <source>The bundling configuration must take lazy loading into consideration. Because lazy-loaded modules aren't imported in JavaScript, bundlers exclude them by default. Bundlers don't know about the router configuration and can't create separate bundles for lazy-loaded modules. You would have to create these bundles manually.</source>
          <target state="translated">번들링 구성은 지연 로딩을 고려해야합니다. 지연로드 된 모듈은 JavaScript로 가져 오지 않으므로 번 들러는 기본적으로 해당 모듈을 제외합니다. 번 들러는 라우터 구성에 대해 알지 못하고 지연로드 된 모듈에 대해 별도의 번들을 작성할 수 없습니다. 이 번들을 수동으로 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="d8708bfa23fa52e22c67b7fb716a9c92a7fff5da" translate="yes" xml:space="preserve">
          <source>The callback function</source>
          <target state="translated">콜백 함수</target>
        </trans-unit>
        <trans-unit id="182e95510ced064ca2569f30358a8b0ad32b1752" translate="yes" xml:space="preserve">
          <source>The callback function name.</source>
          <target state="translated">콜백 함수 이름</target>
        </trans-unit>
        <trans-unit id="1c1819b20078d68dd56a0742a60395369c73dff3" translate="yes" xml:space="preserve">
          <source>The callback function that is triggered for the listener when the URL changes.</source>
          <target state="translated">URL이 변경 될 때 리스너에 대해 트리거되는 콜백 함수입니다.</target>
        </trans-unit>
        <trans-unit id="f29546adb0a293b59216f583d9f5377716b2a139" translate="yes" xml:space="preserve">
          <source>The callback function that is triggered when an error occurs.</source>
          <target state="translated">오류가 발생하면 트리거되는 콜백 함수입니다.</target>
        </trans-unit>
        <trans-unit id="7e8f5213291a0dccb35f253ed9c74c78e2074d16" translate="yes" xml:space="preserve">
          <source>The callback function to register</source>
          <target state="translated">등록 할 콜백 함수</target>
        </trans-unit>
        <trans-unit id="324517c75dfdff3257b5e48b32727d2719bed16b" translate="yes" xml:space="preserve">
          <source>The callback function.</source>
          <target state="translated">콜백 함수</target>
        </trans-unit>
        <trans-unit id="44ad2e447a43167d715b851a2f95ea045f8de842" translate="yes" xml:space="preserve">
          <source>The callback in the updated component method receives a typed data object, which is easier and safer to consume:</source>
          <target state="translated">업데이트 된 컴포넌트 메소드의 콜백은 유형이 지정된 데이터 객체를 수신하여 더 쉽고 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7989cb817f3892197b63d55f812a8feae326844" translate="yes" xml:space="preserve">
          <source>The callback method to update the model from the view when requested</source>
          <target state="translated">요청시 뷰에서 모델을 업데이트하는 콜백 메소드</target>
        </trans-unit>
        <trans-unit id="9de01ab978bcaa115dbc245728b09c7ed9d15018" translate="yes" xml:space="preserve">
          <source>The callback to invoke when Angular is stable or the timeout expires whichever comes first.</source>
          <target state="translated">Angular가 안정적이거나 시간 초과가 만료 될 때 호출 할 콜백입니다.</target>
        </trans-unit>
        <trans-unit id="f3a7dd48a909e9970fb1da807f08ca215abf3f7f" translate="yes" xml:space="preserve">
          <source>The callbacks attached to the component's &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;&lt;/code&gt; properties and/or the element's event properties.</source>
          <target state="translated">구성 요소의 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;&lt;/code&gt; 속성 및 / 또는 요소의 이벤트 속성에 연결된 콜백 입니다.</target>
        </trans-unit>
        <trans-unit id="8360f1396c197b509f36e79abbf7f8bed7725084" translate="yes" xml:space="preserve">
          <source>The change detection strategy to use in the new component.</source>
          <target state="translated">새 구성 요소에 사용할 변경 감지 전략.</target>
        </trans-unit>
        <trans-unit id="d8068b6c20a86a548f92c8754f7e23bf2d24a0bb" translate="yes" xml:space="preserve">
          <source>The change detector for this component instance.</source>
          <target state="translated">이 컴포넌트 인스턴스의 변경 감지기.</target>
        </trans-unit>
        <trans-unit id="b15fbfe9cced7df5ea9485a05cd1a48449704aef" translate="yes" xml:space="preserve">
          <source>The change detector ignores changes to elements of an array, so the pipe doesn't run.</source>
          <target state="translated">변경 감지기는 배열 요소에 대한 변경을 무시하므로 파이프가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67f5cdf216cb0945406d5e4965afcbf10659fe3b" translate="yes" xml:space="preserve">
          <source>The change handler function, which take a URL and a location history state.</source>
          <target state="translated">URL 및 위치 기록 상태를 취하는 변경 핸들러 기능</target>
        </trans-unit>
        <trans-unit id="3343e149a2f6f98e9fba5ecd1fe5527f3ae22370" translate="yes" xml:space="preserve">
          <source>The change tracking method plays a role in the efficiency of your application.</source>
          <target state="translated">변경 내용 추적 방법은 응용 프로그램의 효율성에 중요한 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="3093bb2a5ab46a9af4b283f32aac491c34e27270" translate="yes" xml:space="preserve">
          <source>The change-detection strategy to use for this component.</source>
          <target state="translated">이 구성 요소에 사용할 변경 감지 전략.</target>
        </trans-unit>
        <trans-unit id="8d6b5bb93f2a36dfade3aee37283efde684f1ce3" translate="yes" xml:space="preserve">
          <source>The change-tracking method plays a role in the efficiency of your application.</source>
          <target state="translated">변경 추적 방법은 애플리케이션의 효율성에 중요한 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="8d0536d0b3c762f5645d9b26cad792c0eb3a67f3" translate="yes" xml:space="preserve">
          <source>The changed properties.</source>
          <target state="translated">변경된 속성.</target>
        </trans-unit>
        <trans-unit id="796e4cce084e241e06d5ee695cffadaaa1312b5b" translate="yes" xml:space="preserve">
          <source>The checked value</source>
          <target state="translated">확인 된 값</target>
        </trans-unit>
        <trans-unit id="21eac29c346266d04fe1ecdfdafa7f73a1cb4c45" translate="yes" xml:space="preserve">
          <source>The child component class and template</source>
          <target state="translated">자식 컴포넌트 클래스와 템플릿</target>
        </trans-unit>
        <trans-unit id="98bc7cef6b7350b74e17dc76fe9675f388d460b3" translate="yes" xml:space="preserve">
          <source>The child component exposes an &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; property with which it &lt;code&gt;emits&lt;/code&gt; events when something happens. The parent binds to that event property and reacts to those events.</source>
          <target state="translated">하위 구성 요소는 노출 &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; 의 가있는 건물 &lt;code&gt;emits&lt;/code&gt; 일이 발생하면 이벤트를. 부모는 해당 이벤트 속성에 바인딩하고 해당 이벤트에 반응합니다.</target>
        </trans-unit>
        <trans-unit id="336bbbacf94a88998e2de3b06f6103b4483a4bcd" translate="yes" xml:space="preserve">
          <source>The child component uses the &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; property to raise an event to notify the parent of the change. To raise an event, an &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; must have the type of &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt;, which is a class in &lt;code&gt;@angular/core&lt;/code&gt; that you use to emit custom events.</source>
          <target state="translated">자식 구성 요소는 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; 속성을 사용하여 부모에게 변경 사항을 알리는 이벤트를 발생시킵니다. 이벤트를 발생 시키려면 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; 유형이 있어야합니다.이 유형은 사용자 지정 이벤트를 생성하는 데 사용하는 &lt;code&gt;@angular/core&lt;/code&gt; 의 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="de2ff0bbaa0c25d3965be8b69d52b30ddde19e03" translate="yes" xml:space="preserve">
          <source>The child node to query.</source>
          <target state="translated">조회 할 자식 노드.</target>
        </trans-unit>
        <trans-unit id="b838a97bc91f5bd4d3163e9eb632cf7f1cec63fa" translate="yes" xml:space="preserve">
          <source>The child node to remove.</source>
          <target state="translated">제거 할 자식 노드입니다.</target>
        </trans-unit>
        <trans-unit id="28113636f1f53ec2086b37193a976e332ddde875" translate="yes" xml:space="preserve">
          <source>The child route under the &lt;code&gt;AdminComponent&lt;/code&gt; has a &lt;code&gt;path&lt;/code&gt; and a &lt;code&gt;children&lt;/code&gt; property but it's not using a &lt;code&gt;component&lt;/code&gt;. This defines a &lt;em&gt;component-less&lt;/em&gt; route.</source>
          <target state="translated">&lt;code&gt;AdminComponent&lt;/code&gt; 아래의 자식 경로 에는 &lt;code&gt;path&lt;/code&gt; 와 &lt;code&gt;children&lt;/code&gt; 속성이 있지만 &lt;code&gt;component&lt;/code&gt; 사용하지 않습니다 . 이것은 &lt;em&gt;구성 요소가없는&lt;/em&gt; 경로를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="8909b8dd5928a2ca32979b4c5eb8646b0c1ed1ee" translate="yes" xml:space="preserve">
          <source>The child selector is &lt;code&gt;&amp;lt;app-input-output&amp;gt;&lt;/code&gt; with &lt;code&gt;item&lt;/code&gt; and &lt;code&gt;deleteRequest&lt;/code&gt; being &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; properties in the child component class. The property &lt;code&gt;currentItem&lt;/code&gt; and the method &lt;code&gt;crossOffItem()&lt;/code&gt; are both in the parent component class.</source>
          <target state="translated">자식 선택기는 &lt;code&gt;item&lt;/code&gt; 및 &lt;code&gt;deleteRequest&lt;/code&gt; 가 자식 구성 요소 클래스의 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt; () 및 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt; () 속성 인 &lt;code&gt;&amp;lt;app-input-output&amp;gt;&lt;/code&gt; 입니다 . &lt;code&gt;currentItem&lt;/code&gt; 속성 과 &lt;code&gt;crossOffItem()&lt;/code&gt; 메서드 는 모두 부모 구성 요소 클래스에 있습니다.</target>
        </trans-unit>
        <trans-unit id="73fee6cefa43b5b1a569bd5a82fbaedf48efdb3f" translate="yes" xml:space="preserve">
          <source>The child's &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; property is an &lt;strong&gt;&lt;em&gt;output property&lt;/em&gt;&lt;/strong&gt;, typically adorned with an &lt;a href=&quot;inputs-outputs#output&quot;&gt;@Output() decorator&lt;/a&gt; as seen in this &lt;code&gt;VoterComponent&lt;/code&gt;:</source>
          <target state="translated">자식의 &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; 속성은 일반적 으로이 &lt;code&gt;VoterComponent&lt;/code&gt; 에서 볼 수 있는 &lt;a href=&quot;inputs-outputs#output&quot;&gt;@Output () 데코레이터&lt;/a&gt; 로 장식 된 &lt;strong&gt;&lt;em&gt;출력 속성입니다&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3ebaac95fe3c0183cb6f4ac86416f49de1d80ee6" translate="yes" xml:space="preserve">
          <source>The child's &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; property is an &lt;strong&gt;&lt;em&gt;output property&lt;/em&gt;&lt;/strong&gt;, typically adorned with an &lt;a href=&quot;template-syntax#inputs-outputs&quot;&gt;@Output decoration&lt;/a&gt; as seen in this &lt;code&gt;VoterComponent&lt;/code&gt;:</source>
          <target state="translated">자식의 &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; 속성은 &lt;strong&gt;&lt;em&gt;output 속성&lt;/em&gt;&lt;/strong&gt; 이며, 일반적 으로이 &lt;code&gt;VoterComponent&lt;/code&gt; 에 표시된 대로 &lt;a href=&quot;template-syntax#inputs-outputs&quot;&gt;@Output 데코레이션&lt;/a&gt; 으로 장식 됩니다 .</target>
        </trans-unit>
        <trans-unit id="45c5e393302819e4131079c6fe541b42e859ee2b" translate="yes" xml:space="preserve">
          <source>The child's template has two controls. The first is an HTML &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; with a &lt;a href=&quot;template-reference-variables&quot;&gt;template reference variable&lt;/a&gt; , &lt;code&gt;#newItem&lt;/code&gt;, where the user types in an item name. The &lt;code&gt;value&lt;/code&gt; property of the &lt;code&gt;#newItem&lt;/code&gt; variable stores what the user types into the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">자녀의 템플릿에는 두 가지 컨트롤이 있습니다. 먼저 인 HTML &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; A의 &lt;a href=&quot;template-reference-variables&quot;&gt;템플릿 참조 변수&lt;/a&gt; , &lt;code&gt;#newItem&lt;/code&gt; 여기서 항목명의 사용자 유형. &lt;code&gt;#newItem&lt;/code&gt; 변수 의 &lt;code&gt;value&lt;/code&gt; 속성은 사용자가 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 에 입력 한 내용을 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="4d21e7048f090003f6988e5a99ace595822566be" translate="yes" xml:space="preserve">
          <source>The child's template has two controls. The first is an HTML &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; with a &lt;a href=&quot;template-syntax#ref-var&quot;&gt;template reference variable&lt;/a&gt; , &lt;code&gt;#newItem&lt;/code&gt;, where the user types in an item name. Whatever the user types into the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; gets stored in the &lt;code&gt;#newItem&lt;/code&gt; variable.</source>
          <target state="translated">자녀의 템플릿에는 두 가지 컨트롤이 있습니다. 첫 번째는 &lt;a href=&quot;template-syntax#ref-var&quot;&gt;템플릿 참조 변수&lt;/a&gt; , &lt;code&gt;#newItem&lt;/code&gt; 이있는 HTML &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 입니다. 여기서 사용자는 항목 이름을 입력합니다. 사용자가 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 에 입력 한 내용은 &lt;code&gt;#newItem&lt;/code&gt; 변수에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="9815f861c67f39ad3a340bdc46586f227e38f0d3" translate="yes" xml:space="preserve">
          <source>The children of this route in the router state tree</source>
          <target state="translated">라우터 상태 트리에서이 경로의 자식</target>
        </trans-unit>
        <trans-unit id="88f283ebf90d73f7691965239f91c83b97c637c7" translate="yes" xml:space="preserve">
          <source>The children of this route in the router state tree.</source>
          <target state="translated">라우터 상태 트리에서이 경로의 자식</target>
        </trans-unit>
        <trans-unit id="cd478977dac1aaeeb2106c8d25bd353cbf9a9248" translate="yes" xml:space="preserve">
          <source>The choice between inline and separate HTML is a matter of taste, circumstances, and organization policy. Here the app uses inline HTML because the template is small and the demo is simpler without the additional HTML file.</source>
          <target state="translated">인라인 HTML과 별도 HTML 중 하나를 선택하는 것은 취향, 환경 및 조직 정책의 문제입니다. 템플릿이 작고 추가 HTML 파일없이 데모가 더 간단하기 때문에 앱은 인라인 HTML을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a4f2b79a3029d546fba201c93d23eabb4aa329ff" translate="yes" xml:space="preserve">
          <source>The class additionally declares three members: The array of phones, the name of the current sort key, and the search query. These are all things you have already been attaching to the controller but that weren't explicitly declared anywhere. The last one of these isn't actually used in the TypeScript code since it's only referred to in the template, but for the sake of clarity you should define all of the controller members.</source>
          <target state="translated">이 클래스는 전화 배열, 현재 정렬 키 이름 및 검색 쿼리라는 세 가지 멤버를 추가로 선언합니다. 이것들은 이미 컨트롤러에 연결되어 있지만 명시 적으로 선언되지 않은 모든 것입니다. 마지막 것은 템플릿에서만 참조되므로 TypeScript 코드에서는 실제로 사용되지 않지만 명확성을 위해 모든 컨트롤러 멤버를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="386c4da46833767828efb663588fa86f0b351c05" translate="yes" xml:space="preserve">
          <source>The class name.</source>
          <target state="translated">클래스 이름</target>
        </trans-unit>
        <trans-unit id="cfb8e2fa1ec41a7877ca2cf24377f2bbac37fc6a" translate="yes" xml:space="preserve">
          <source>The class we have created provides a service. The &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; decorator marks it as a service that can be injected, but Angular can't actually inject it anywhere until you configure an Angular &lt;a href=&quot;glossary#injector&quot;&gt;dependency injector&lt;/a&gt; with a &lt;a href=&quot;glossary#provider&quot;&gt;provider&lt;/a&gt; of that service.</source>
          <target state="translated">우리가 만든 수업은 서비스를 제공합니다. &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; 데코레이터를 주입 할 수있는 서비스로 마크를하지만, 당신이 코너 구성 할 때까지 각도 실제로 어디를 주입 할 수없는 &lt;a href=&quot;glossary#injector&quot;&gt;의존성 주입을&lt;/a&gt; 로 &lt;a href=&quot;glossary#provider&quot;&gt;제공&lt;/a&gt; 하는 서비스.</target>
        </trans-unit>
        <trans-unit id="9bb76e82307d0c0d07213e61c7341ddb5167bded" translate="yes" xml:space="preserve">
          <source>The class-provider syntax is a shorthand expression that expands into a provider configuration, defined by the &lt;a href=&quot;../api/core/provider&quot;&gt;&lt;code&gt;Provider&lt;/code&gt; interface&lt;/a&gt;. The following code snippets shows how a class that is given as the &lt;code&gt;providers&lt;/code&gt; value is expanded into a full provider object.</source>
          <target state="translated">클래스 제공자 구문은 &lt;a href=&quot;../api/core/provider&quot;&gt; &lt;code&gt;Provider&lt;/code&gt; 인터페이스로&lt;/a&gt; 정의 된 제공자 구성으로 확장되는 속기 표현식입니다 . 다음 코드 스 니펫은 &lt;code&gt;providers&lt;/code&gt; 값으로 제공된 클래스가 전체 제공자 오브젝트로 확장되는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="e4378e45dd65db5c919f1a83b79501f5e742c2cc" translate="yes" xml:space="preserve">
          <source>The code behind it customizes how and where the DI framework provides dependencies. The use cases illustrate different ways to use the &lt;a href=&quot;dependency-injection-providers#provide&quot;&gt;&lt;em&gt;provide&lt;/em&gt; object literal&lt;/a&gt; to associate a definition object with a DI token.</source>
          <target state="translated">그 뒤에있는 코드는 DI 프레임 워크가 종속성을 제공하는 방법과 위치를 사용자 정의합니다. 유스 케이스는 &lt;a href=&quot;dependency-injection-providers#provide&quot;&gt;&lt;em&gt;제공&lt;/em&gt; 오브젝트 리터럴&lt;/a&gt; 을 사용하여 정의 오브젝트를 DI 토큰과 연관시키는 다양한 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="970ee2781eada9efc03e7fd17ce53917ceee0e8f" translate="yes" xml:space="preserve">
          <source>The code binds to the &lt;code&gt;input&lt;/code&gt; event of the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element, which allows the code to listen for changes.</source>
          <target state="translated">코드 는 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 요소 의 &lt;code&gt;input&lt;/code&gt; 이벤트에 바인딩되어 코드가 변경 사항을 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f96fcb6e3857904aa9aa4b964b93a302cc574eb0" translate="yes" xml:space="preserve">
          <source>The code coverage percentages let you estimate how much of your code is tested. If your team decides on a set minimum amount to be unit tested, you can enforce this minimum with the Angular CLI.</source>
          <target state="translated">코드 적용률을 통해 테스트되는 코드 양을 추정 할 수 있습니다. 팀에서 단위 테스트를 위해 설정된 최소 금액을 결정하면 Angular CLI를 사용하여 최소 금액을 시행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5dce1db38cdc532ad3d7c72afd2efd8358fd816" translate="yes" xml:space="preserve">
          <source>The code for this color change might look like this.</source>
          <target state="translated">이 색상 변경 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cbeac1c9a0c35dbccb31f978400fc2fe2a5e2a4a" translate="yes" xml:space="preserve">
          <source>The code imports the Angular core library and the &lt;code&gt;Hero&lt;/code&gt; model you just created.</source>
          <target state="translated">이 코드는 방금 만든 Angular 코어 라이브러리와 &lt;code&gt;Hero&lt;/code&gt; 모델을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="68f0a3da097460a4e1aa89208185bd3703ba9e66" translate="yes" xml:space="preserve">
          <source>The code must &lt;em&gt;detach&lt;/em&gt; the listener when the directive is destroyed to avoid memory leaks.</source>
          <target state="translated">메모리 누수를 피하기 위해 지시문이 삭제되면 코드 에서 리스너 를 &lt;em&gt;분리&lt;/em&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="46c6a7d6568026289889fe5df8dce62319144252" translate="yes" xml:space="preserve">
          <source>The code of the error to check</source>
          <target state="translated">확인할 오류 코드</target>
        </trans-unit>
        <trans-unit id="6f27e3b52d7266eb93e97fdd4a94b9f45b555f31" translate="yes" xml:space="preserve">
          <source>The code of the locale whose currency code we want.</source>
          <target state="translated">우리가 원하는 통화 코드를 가진 로케일의 코드.</target>
        </trans-unit>
        <trans-unit id="10c0011222fc6b4866ac8487498f45dd83f02549" translate="yes" xml:space="preserve">
          <source>The code sample below shows how to use this feature.</source>
          <target state="translated">아래 코드 샘플은이 기능을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="52a764918c407ee86da193bb47e766db1ee7d4cb" translate="yes" xml:space="preserve">
          <source>The code sets &lt;code&gt;packages$&lt;/code&gt; to this re-composed &lt;code&gt;Observable&lt;/code&gt; of search results. The template subscribes to &lt;code&gt;packages$&lt;/code&gt; with the &lt;a href=&quot;../api/common/asyncpipe&quot;&gt;AsyncPipe&lt;/a&gt; and displays search results as they arrive.</source>
          <target state="translated">이 코드는 &lt;code&gt;packages$&lt;/code&gt; 를이 재구성 된 검색 결과 &lt;code&gt;Observable&lt;/code&gt; 로 설정합니다. 템플릿 은 &lt;a href=&quot;../api/common/asyncpipe&quot;&gt;AsyncPipe&lt;/a&gt; 를 사용하여 &lt;code&gt;packages$&lt;/code&gt; 를 구독 하고 도착하면 검색 결과를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="f6ed28c9f178e87589fbe392d21c577aea987e8f" translate="yes" xml:space="preserve">
          <source>The code snippet for this animation might look like this.</source>
          <target state="translated">이 애니메이션의 코드 스 니펫은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="688745f4df04e9e5819d70cbf741b8a833c173c4" translate="yes" xml:space="preserve">
          <source>The code with offsets specified would be as follows.</source>
          <target state="translated">오프셋이 지정된 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa6d3cc42e5d49bc58e9f59a5de8ba857d85cdb3" translate="yes" xml:space="preserve">
          <source>The code you write in development using TypeScript is compiled and bundled into ES2015, the JavaScript syntax that is compatible with most browsers. All modern browsers support ES2015 and beyond, but in most cases, you still have to account for users accessing your application from a browser that doesn't. When targeting older browsers, &lt;a href=&quot;browser-support#polyfills&quot;&gt;polyfills&lt;/a&gt; can bridge the gap by providing functionality that doesn't exist in the older versions of JavaScript supported by those browsers.</source>
          <target state="translated">TypeScript를 사용하여 개발할 때 작성하는 코드는 대부분의 브라우저와 호환되는 JavaScript 구문 인 ES2015에 컴파일되어 번들로 제공됩니다. 모든 최신 브라우저는 ES2015 이상을 지원하지만 대부분의 경우 브라우저가 아닌 브라우저에서 애플리케이션에 액세스하는 사용자를 고려해야합니다. 오래된 브라우저를 타겟팅 할 때 &lt;a href=&quot;browser-support#polyfills&quot;&gt;폴리 필&lt;/a&gt; 은 해당 브라우저에서 지원하는 이전 버전의 JavaScript에는없는 기능을 제공하여 차이를 메울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7e52622776d7c1959881d2e660fa7a5fa2ffc44" translate="yes" xml:space="preserve">
          <source>The code you write isn't immediately executable. For example, components have templates that contain custom elements, attribute directives, Angular binding declarations, and some peculiar syntax that clearly isn't native HTML.</source>
          <target state="translated">작성한 코드는 즉시 실행 가능하지 않습니다. 예를 들어 구성 요소에는 사용자 지정 요소, 특성 지시문, 각도 바인딩 선언 및 고유 HTML이 아닌 고유 한 구문이 포함 된 템플릿이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c98252757016faf472023968bc36999991222bc9" translate="yes" xml:space="preserve">
          <source>The collector accepts any function or static method that contains a single &lt;code&gt;return&lt;/code&gt; statement. The compiler, however, only supports macros in the form of functions or static methods that return an &lt;em&gt;expression&lt;/em&gt;.</source>
          <target state="translated">콜렉터는 단일 &lt;code&gt;return&lt;/code&gt; 문 이 포함 된 모든 함수 또는 정적 메소드를 승인합니다 . 그러나 컴파일러는 함수 또는 &lt;em&gt;식&lt;/em&gt; 을 반환하는 정적 메서드 형식의 매크로 만 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="775ba5d48c201b80c8c8ae9cd1d70622bb775dd4" translate="yes" xml:space="preserve">
          <source>The collector can evaluate references to module-local &lt;code&gt;const&lt;/code&gt; declarations and initialized &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; declarations, effectively removing them from the &lt;code&gt;.metadata.json&lt;/code&gt; file.</source>
          <target state="translated">콜렉터는 모듈 로컬 &lt;code&gt;const&lt;/code&gt; 선언 및 초기화 된 &lt;code&gt;var&lt;/code&gt; 및 &lt;code&gt;let&lt;/code&gt; 선언에 대한 참조를 평가 하여 &lt;code&gt;.metadata.json&lt;/code&gt; 파일 에서 효과적으로 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f9ef0ca017a80f8e54b27d25998685f9c051e40" translate="yes" xml:space="preserve">
          <source>The collector can represent a function call or object creation with &lt;code&gt;new&lt;/code&gt; as long as the syntax is valid. The compiler, however, can later refuse to generate a call to a &lt;em&gt;particular&lt;/em&gt; function or creation of a &lt;em&gt;particular&lt;/em&gt; object.</source>
          <target state="translated">콜렉터는 구문이 유효한 한 &lt;code&gt;new&lt;/code&gt; 함수 호출 또는 오브젝트 작성을 나타낼 수 있습니다 . 그러나 컴파일러는 나중에 &lt;em&gt;특정&lt;/em&gt; 함수에 대한 호출 이나 &lt;em&gt;특정&lt;/em&gt; 객체의 생성을 거부 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04cdce6617c90dd9e3023f3aef0d2359e60d969d" translate="yes" xml:space="preserve">
          <source>The collector makes no attempt to understand the metadata that it collects and outputs to &lt;code&gt;.metadata.json&lt;/code&gt;. It represents the metadata as best it can and records errors when it detects a metadata syntax violation. It's the compiler's job to interpret the &lt;code&gt;.metadata.json&lt;/code&gt; in the code generation phase.</source>
          <target state="translated">수집기는 수집하고 &lt;code&gt;.metadata.json&lt;/code&gt; 으로 출력하는 메타 데이터를 이해하려고 시도하지 않습니다 . 메타 데이터 구문을 감지하면 메타 데이터를 최대한 잘 나타내고 오류를 기록합니다. 코드 생성 단계에서 &lt;code&gt;.metadata.json&lt;/code&gt; 을 해석하는 것은 컴파일러의 작업 입니다.</target>
        </trans-unit>
        <trans-unit id="c94e729ff8a27c730c157a9c5bcc96f4b75e729a" translate="yes" xml:space="preserve">
          <source>The collector reduces this expression to its equivalent &lt;em&gt;folded&lt;/em&gt; string:</source>
          <target state="translated">콜렉터는이 표현식을 해당 &lt;em&gt;접힌&lt;/em&gt; 문자열로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="2cb307c5d9a821cbeb1291555d897d427eb70d97" translate="yes" xml:space="preserve">
          <source>The colon (:) in the &lt;code&gt;path&lt;/code&gt; indicates that &lt;code&gt;:id&lt;/code&gt; is a placeholder for a specific hero &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 의 콜론 (:)은 &lt;code&gt;:id&lt;/code&gt; 가 특정 hero &lt;code&gt;id&lt;/code&gt; 의 자리 표시 자임을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="822a3863f5cea533bb631122ed79d3a3234d1e18" translate="yes" xml:space="preserve">
          <source>The command also adds the &lt;code&gt;HeroDetailComponent&lt;/code&gt; as a declaration in the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; decorator of the &lt;code&gt;src/app/app.module.ts&lt;/code&gt; file.</source>
          <target state="translated">이 명령은 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 를 &lt;code&gt;src/app/app.module.ts&lt;/code&gt; 파일 의 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 데코레이터에 선언으로 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="ecfcfd92ddc1e6e65d554b28efd2166d3482d5a8" translate="yes" xml:space="preserve">
          <source>The command can be used to build a project of type &quot;application&quot; or &quot;library&quot;. When used to build a library, a different builder is invoked, and only the &lt;code&gt;ts-config&lt;/code&gt;, &lt;code&gt;configuration&lt;/code&gt;, and &lt;code&gt;watch&lt;/code&gt; options are applied. All other options apply only to building applications.</source>
          <target state="translated">이 명령은 &quot;application&quot;또는 &quot;library&quot;유형의 프로젝트를 빌드하는 데 사용할 수 있습니다. 라이브러리를 빌드하는 데 사용될 때 다른 빌더가 호출되고 &lt;code&gt;ts-config&lt;/code&gt; , &lt;code&gt;configuration&lt;/code&gt; 및 &lt;code&gt;watch&lt;/code&gt; 옵션 만 적용됩니다. 다른 모든 옵션은 응용 프로그램 작성에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="512e225eda6cc1639eea07b5d955a25e07759d5d" translate="yes" xml:space="preserve">
          <source>The command can read and write files in three translation formats:</source>
          <target state="translated">이 명령은 세 가지 변환 형식으로 파일을 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf84844b9e75c71ac51168fed3b964af90b550ed" translate="yes" xml:space="preserve">
          <source>The command configures your app to use service workers by adding the service-worker package and generating the necessary support files.</source>
          <target state="translated">이 명령은 service-worker 패키지를 추가하고 필요한 지원 파일을 생성하여 서비스 워커를 사용하도록 앱을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="60cbb6bb9baee1657c5aabadd3c30a172960868d" translate="yes" xml:space="preserve">
          <source>The command creates the following &lt;code&gt;HeroService&lt;/code&gt; skeleton.</source>
          <target state="translated">이 명령은 다음과 같은 &lt;code&gt;HeroService&lt;/code&gt; 스켈레톤을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="fb7672e8c965167d0a611c29c3e95da6a052157c" translate="yes" xml:space="preserve">
          <source>The command creates the following folder structure.</source>
          <target state="translated">이 명령은 다음 폴더 구조를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="23f6fb999f367965df4e9072feb6668a104067e3" translate="yes" xml:space="preserve">
          <source>The command generates a skeleton &lt;code&gt;HeroService&lt;/code&gt; class in &lt;code&gt;src/app/hero.service.ts&lt;/code&gt; as follows:</source>
          <target state="translated">이 명령 은 다음과 같이 &lt;code&gt;src/app/hero.service.ts&lt;/code&gt; 에 스켈레톤 &lt;code&gt;HeroService&lt;/code&gt; 클래스를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="f84057f8a139bc98948e34aa76f1de7682fe3a1c" translate="yes" xml:space="preserve">
          <source>The command generates the new named schematic inside your collection, with a main &lt;code&gt;index.ts&lt;/code&gt; file and its associated test spec. It also adds the name, description, and factory function for the new schematic to the collection's schema in the &lt;code&gt;collection.json&lt;/code&gt; file.</source>
          <target state="translated">이 명령은 기본 &lt;code&gt;index.ts&lt;/code&gt; 파일 및 관련 테스트 사양과 함께 컬렉션 내에 새로운 명명 된 회로도를 생성합니다 . 또한 새 회로도의 이름, 설명 및 팩토리 기능을 &lt;code&gt;collection.json&lt;/code&gt; 파일 의 콜렉션 스키마에 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="032b5d312dec4716aade5ccf6d268d0aee388017" translate="yes" xml:space="preserve">
          <source>The command is interactive. In this case, you must have or create a Firebase account, and authenticate using that account. The command prompts you to select a Firebase project for deployment</source>
          <target state="translated">명령은 대화식입니다. 이 경우 Firebase 계정이 있거나 계정을 생성하고 해당 계정을 사용하여 인증해야합니다. 배포 할 Firebase 프로젝트를 선택하라는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e0238e94e6ed6d69aeb9b7186b5420a4c6cccd58" translate="yes" xml:space="preserve">
          <source>The command passes the builder the set of default options specified in the &quot;options&quot; section. If you pass the &lt;code&gt;--configuration=production&lt;/code&gt; flag, it uses the override values specified in the &lt;code&gt;production&lt;/code&gt; alternative configuration. You can specify further option overrides individually on the command line. You might also add more alternative configurations to the &lt;code&gt;build&lt;/code&gt; target, to define other environments such as &lt;code&gt;stage&lt;/code&gt; or &lt;code&gt;qa&lt;/code&gt;.</source>
          <target state="translated">명령은 &quot;옵션&quot;섹션에 지정된 기본 옵션 세트를 빌더에 전달합니다. &lt;code&gt;--configuration=production&lt;/code&gt; 플래그 를 전달 하면 &lt;code&gt;production&lt;/code&gt; 대체 구성에 지정된 재정의 값이 사용 됩니다. 명령 행에서 추가 옵션 대체를 개별적으로 지정할 수 있습니다. &lt;code&gt;stage&lt;/code&gt; 또는 &lt;code&gt;qa&lt;/code&gt; 와 같은 다른 환경을 정의 하기 위해 &lt;code&gt;build&lt;/code&gt; 대상 에 더 많은 대체 구성을 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb2912a10269d45a749dd2c9c3467ad9cb8c57d9" translate="yes" xml:space="preserve">
          <source>The command performs the following actions.</source>
          <target state="translated">이 명령은 다음 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d05643aa6337d26acd02d68221885268cc4cdae7" translate="yes" xml:space="preserve">
          <source>The command replaces the original messages with translated text, and generates a new version of the app in the target language.</source>
          <target state="translated">이 명령은 원본 메시지를 번역 된 텍스트로 바꾸고 대상 언어로 새 버전의 앱을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="26f3e6fe9701a42c19f4d2b3080bd162ab88cf06" translate="yes" xml:space="preserve">
          <source>The command scaffolds the following:</source>
          <target state="translated">이 명령은 다음을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="afe6b95bc4862f31c695e35a376168015bb8944a" translate="yes" xml:space="preserve">
          <source>The command takes an optional project name, as specified in the &lt;code&gt;projects&lt;/code&gt; section of the &lt;code&gt;angular.json&lt;/code&gt; workspace configuration file. When a project name is not supplied, executes the &lt;code&gt;deploy&lt;/code&gt; builder for the default project.</source>
          <target state="translated">이 명령은 &lt;code&gt;angular.json&lt;/code&gt; 작업 공간 구성 파일 의 &lt;code&gt;projects&lt;/code&gt; 섹션에 지정된대로 선택적 프로젝트 이름을 사용합니다. 프로젝트 이름이 제공되지 않으면 기본 프로젝트 의 &lt;code&gt;deploy&lt;/code&gt; 빌더를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2367757f500b2b5e14443d0ffa2b6ea5d19b891" translate="yes" xml:space="preserve">
          <source>The command-line output includes extra logging from Bazel. We plan to reduce this in the future.</source>
          <target state="translated">명령 줄 출력에는 Bazel의 추가 로깅이 포함됩니다. 우리는 앞으로 이것을 줄일 계획입니다.</target>
        </trans-unit>
        <trans-unit id="deebac4a0e4d9463353e1ba094d4311ba5bced82" translate="yes" xml:space="preserve">
          <source>The comment text.</source>
          <target state="translated">주석 텍스트.</target>
        </trans-unit>
        <trans-unit id="f727b50279d21957a5ea426f3f6ef5d1c870a679" translate="yes" xml:space="preserve">
          <source>The common commands in Bazel are:</source>
          <target state="translated">Bazel의 일반적인 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4dce573efdc896e6762e4abce3c4ef846a95893d" translate="yes" xml:space="preserve">
          <source>The commonly-needed services, pipes, and directives provided by the Angular team. The &lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;&lt;code&gt;HttpClientModule&lt;/code&gt;&lt;/a&gt; is also here, in the &lt;a href=&quot;../api/common/http&quot;&gt;&lt;code&gt;@angular/common/http&lt;/code&gt;&lt;/a&gt; subfolder. For more information, see the &lt;a href=&quot;http&quot;&gt;HttpClient guide&lt;/a&gt;.</source>
          <target state="translated">Angular 팀이 제공하는 일반적으로 필요한 서비스, 파이프 및 지침. &lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt; &lt;code&gt;HttpClientModule&lt;/code&gt; 는&lt;/a&gt; 에서, 여기에 있습니다 &lt;a href=&quot;../api/common/http&quot;&gt; &lt;code&gt;@angular/common/http&lt;/code&gt; &lt;/a&gt; 하위 폴더. 자세한 정보는 &lt;a href=&quot;http&quot;&gt;HttpClient 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="91fd0e342d19fa9a326ec600aa54532eda1d7b70" translate="yes" xml:space="preserve">
          <source>The companion component class provides heroes, adds heroes into the array, and can reset the array.</source>
          <target state="translated">컴패니언 구성 요소 클래스는 영웅을 제공하고 배열에 영웅을 추가하며 배열을 재설정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68d35ebfa15210ab8b65604e0da1d1214dd4d36d" translate="yes" xml:space="preserve">
          <source>The compilation and rendering pipeline used by Angular before version 9. Compare &lt;a href=&quot;glossary#ivy&quot;&gt;Ivy&lt;/a&gt;.</source>
          <target state="translated">버전 9 이전의 Angular에서 사용하는 컴파일 및 렌더링 파이프 라인 입니다. &lt;a href=&quot;glossary#ivy&quot;&gt;Ivy&lt;/a&gt; 비교 .</target>
        </trans-unit>
        <trans-unit id="5a7467e3bed5cce9e9e9439293f13cf8bbe37b57" translate="yes" xml:space="preserve">
          <source>The compilation process is the same whether the translation file is in &lt;code&gt;.xlf&lt;/code&gt; format or in another format that Angular understands, such as &lt;code&gt;.xtb&lt;/code&gt;.</source>
          <target state="translated">컴파일 프로세스는 변환 파일이 &lt;code&gt;.xlf&lt;/code&gt; 형식인지 또는 Angular가 이해하는 다른 형식 (예 : &lt;code&gt;.xtb&lt;/code&gt; ) 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="20e023920577f4366d6e8bec0ad15d5c1dfa3ffb" translate="yes" xml:space="preserve">
          <source>The compiler also has some major limitations in this mode:</source>
          <target state="translated">컴파일러는 또한이 모드에서 몇 가지 주요 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fbe0c27d00d7023e6067129fe8bbf4a24d10a6a" translate="yes" xml:space="preserve">
          <source>The compiler can only create instances of certain classes, supports only core decorators, and only supports calls to macros (functions or static methods) that return expressions.</source>
          <target state="translated">컴파일러는 특정 클래스의 인스턴스 만 만들 수 있으며 핵심 데코레이터 만 지원하며 식을 반환하는 매크로 (함수 또는 정적 메서드)에 대한 호출 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="bee270b045da60269f4d9d82490b3eec3eb7fedb" translate="yes" xml:space="preserve">
          <source>The compiler can only reference &lt;em&gt;exported symbols&lt;/em&gt;.</source>
          <target state="translated">컴파일러는 &lt;em&gt;내 보낸 심볼&lt;/em&gt; 만 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3502a185963958198b9a85072d430d31a7108b0" translate="yes" xml:space="preserve">
          <source>The compiler can only resolve references to &lt;strong&gt;&lt;em&gt;exported&lt;/em&gt;&lt;/strong&gt; symbols. The collector, however, can evaluate an expression during collection and record the result in the &lt;code&gt;.metadata.json&lt;/code&gt;, rather than the original expression. This allows you to make limited use of non-exported symbols within expressions.</source>
          <target state="translated">컴파일러는 &lt;strong&gt;&lt;em&gt;내 보낸&lt;/em&gt;&lt;/strong&gt; 심볼에 대한 참조 만 확인할 수 있습니다 . 그러나 콜렉터는 수집 중에 표현식을 평가 하고 원래 표현식이 아닌 &lt;code&gt;.metadata.json&lt;/code&gt; 에 결과를 기록 할 수 있습니다 . 이를 통해 표현식 내에서 내 보내지 않은 심볼을 제한적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3de2fe859e8aea7858d788054cb92a56c24aa22f" translate="yes" xml:space="preserve">
          <source>The compiler can understand simple enum values but not complex values such as those derived from computed properties.</source>
          <target state="translated">컴파일러는 간단한 열거 형 값을 이해할 수 있지만 계산 된 속성에서 파생 된 것과 같은 복잡한 값은 이해할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="19f4a053ad2943ecc2598d242fc7f107dd7fdda1" translate="yes" xml:space="preserve">
          <source>The compiler cannot wait until runtime to get the template information. It must statically derive the value of the &lt;code&gt;someTemplate&lt;/code&gt; variable from the source code so that it can generate the component factory, which includes instructions for building the element based on the template.</source>
          <target state="translated">컴파일러는 템플릿 정보를 얻기 위해 런타임까지 기다릴 수 없습니다. 소스 코드에서 &lt;code&gt;someTemplate&lt;/code&gt; 변수 의 값을 정적으로 파생 시켜 템플릿을 기반으로 요소를 빌드하기위한 지침이 포함 된 컴포넌트 팩토리를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d06c32faa1f9142e1197fcd5ba01c4a27e47837e" translate="yes" xml:space="preserve">
          <source>The compiler could not refer to the &lt;code&gt;template&lt;/code&gt; constant because it isn't exported. The collector, however, can fold the &lt;code&gt;template&lt;/code&gt; constant into the metadata definition by in-lining its contents. The effect is the same as if you had written:</source>
          <target state="translated">&lt;code&gt;template&lt;/code&gt; 상수가 내보내 지지 않아서 컴파일러가 템플릿 상수를 참조 할 수 없습니다 . 그러나 콜렉터 는 컨텐츠를 인라인하여 &lt;code&gt;template&lt;/code&gt; 상수를 메타 데이터 정의로 접을 수 있습니다 . 효과는 마치 작성한 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bd1ef8c2b73d68e5b22c9b1138d099eae1677b0f" translate="yes" xml:space="preserve">
          <source>The compiler does not currently support &lt;a href=&quot;aot-compiler#function-expression&quot;&gt;function expressions or lambda functions&lt;/a&gt;. For example, you cannot set a provider's &lt;code&gt;&lt;a href=&quot;../api/core/factorysansprovider#useFactory&quot;&gt;useFactory&lt;/a&gt;&lt;/code&gt; to an anonymous function or arrow function like this.</source>
          <target state="translated">컴파일러는 현재 &lt;a href=&quot;aot-compiler#function-expression&quot;&gt;함수 표현식 또는 람다 함수를&lt;/a&gt; 지원하지 않습니다 . 예를 들어, 제공자의 &lt;code&gt;&lt;a href=&quot;../api/core/factorysansprovider#useFactory&quot;&gt;useFactory&lt;/a&gt;&lt;/code&gt; 를 익명 함수 또는 이와 같은 화살표 함수로 설정할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8d63679f07b8e39bfb7c96d9e6a44e1bdd0523a8" translate="yes" xml:space="preserve">
          <source>The compiler does not currently support &lt;a href=&quot;aot-compiler#function-expression&quot;&gt;function expressions or lambda functions&lt;/a&gt;. For example, you cannot set a provider's &lt;code&gt;useFactory&lt;/code&gt; to an anonymous function or arrow function like this.</source>
          <target state="translated">컴파일러는 현재 &lt;a href=&quot;aot-compiler#function-expression&quot;&gt;함수 식이나 람다 함수를&lt;/a&gt; 지원하지 않습니다 . 예를 들어 공급자의 &lt;code&gt;useFactory&lt;/code&gt; 를 이와 같은 익명 함수 또는 화살표 함수로 설정할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="420d66550ed93c835ed583c6e68981a83a4d586b" translate="yes" xml:space="preserve">
          <source>The compiler does not support references to variables assigned by &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/variable-declarations.html#destructuring&quot;&gt;destructuring&lt;/a&gt;.</source>
          <target state="translated">컴파일러는 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/variable-declarations.html#destructuring&quot;&gt;destructuring&lt;/a&gt; 에 의해 할당 된 변수에 대한 참조를 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4e2d31b8c52b289dfbc88a3b991740e86003b12c" translate="yes" xml:space="preserve">
          <source>The compiler does not verify that the value of &lt;code&gt;user.address.city&lt;/code&gt; is assignable to the city input of the &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; component.</source>
          <target state="translated">컴파일러는 &lt;code&gt;user.address.city&lt;/code&gt; 값이 &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; 구성 요소 의 도시 입력에 할당 가능한지 확인하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="858c40dd3910dea8d82725091f2c0604dc6827af" translate="yes" xml:space="preserve">
          <source>The compiler does the rewriting during the emit of the &lt;code&gt;.js&lt;/code&gt; file. It does not, however, rewrite the &lt;code&gt;.d.ts&lt;/code&gt; file, so TypeScript doesn't recognize it as being an export. and it does not interfere with the ES module's exported API.</source>
          <target state="translated">컴파일러는 &lt;code&gt;.js&lt;/code&gt; 파일을 내보내는 동안 다시 쓰기를 수행 합니다. 그러나 &lt;code&gt;.d.ts&lt;/code&gt; 파일을 다시 쓰지 않으므로 TypeScript는 파일을 내보내기로 인식하지 못합니다. ES 모듈의 내 보낸 API를 방해하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="157b36dfa249eaae0f0223d7b4e275b5742dd33b" translate="yes" xml:space="preserve">
          <source>The compiler encountered a JavaScript ES2015 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals&quot;&gt;tagged template expression&lt;/a&gt; such as the following.</source>
          <target state="translated">컴파일러 에서 다음과 같은 JavaScript ES2015 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals&quot;&gt;태그가 지정된 템플리트 표현식이&lt;/a&gt; 발생했습니다 .</target>
        </trans-unit>
        <trans-unit id="1f7ded75927c1788a32dd4918360a2ddcd0a071f" translate="yes" xml:space="preserve">
          <source>The compiler encountered a referenced to a locally defined symbol that either wasn't exported or wasn't initialized.</source>
          <target state="translated">컴파일러에서 내 보내지 않았거나 초기화되지 않은 로컬로 정의 된 심볼에 대한 참조가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="98ec5135addca132edc67362962593357c1995fe" translate="yes" xml:space="preserve">
          <source>The compiler erases &lt;em&gt;type position&lt;/em&gt; references after conversion from TypeScript, so they have no impact on tree-shaking.</source>
          <target state="translated">컴파일러 는 TypeScript에서 변환 한 후 &lt;em&gt;유형 위치&lt;/em&gt; 참조를 지우므로 트리 쉐이킹에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca1bd41286b7b47d0a30a94f678cfe97b2c0aa55" translate="yes" xml:space="preserve">
          <source>The compiler finds a pipe if the pipe's &lt;em&gt;name&lt;/em&gt; appears within the pipe syntax of the template HTML.</source>
          <target state="translated">파이프 &lt;em&gt;이름&lt;/em&gt; 이 템플릿 HTML의 파이프 구문 내에 나타나면 컴파일러는 파이프를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="85ca245c9abcc7994f5066093444c00be9929c1e" translate="yes" xml:space="preserve">
          <source>The compiler found a reference to an exported variable or static field that wasn't initialized. It needs the value of that variable to generate code.</source>
          <target state="translated">컴파일러가 초기화되지 않은 내 보낸 변수 또는 정적 필드에 대한 참조를 찾았습니다. 코드를 생성하려면 해당 변수의 값이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8ae63bcc430b2dd230e7e26c813c3c02cb2734f3" translate="yes" xml:space="preserve">
          <source>The compiler generates the component factory, which includes the &lt;code&gt;&lt;a href=&quot;../api/core/valuesansprovider#useValue&quot;&gt;useValue&lt;/a&gt;&lt;/code&gt; provider code, in a separate module. &lt;em&gt;That&lt;/em&gt; factory module can't reach back to &lt;em&gt;this&lt;/em&gt; source module to access the local (non-exported) &lt;code&gt;foo&lt;/code&gt; variable.</source>
          <target state="translated">컴파일러는 &lt;code&gt;&lt;a href=&quot;../api/core/valuesansprovider#useValue&quot;&gt;useValue&lt;/a&gt;&lt;/code&gt; 공급자 코드 가 포함 된 구성 요소 팩토리를 별도의 모듈로 생성합니다. &lt;em&gt;해당&lt;/em&gt; 팩토리 모듈은 &lt;em&gt;이&lt;/em&gt; 소스 모듈에 도달하여 로컬 (내보내기되지 않은) &lt;code&gt;foo&lt;/code&gt; 변수 에 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="92ce2206bc50448555d44e682fc1007463818f9c" translate="yes" xml:space="preserve">
          <source>The compiler generates the component factory, which includes the &lt;code&gt;useValue&lt;/code&gt; provider code, in a separate module. &lt;em&gt;That&lt;/em&gt; factory module can't reach back to &lt;em&gt;this&lt;/em&gt; source module to access the local (non-exported) &lt;code&gt;foo&lt;/code&gt; variable.</source>
          <target state="translated">컴파일러 는 별도의 모듈에서 &lt;code&gt;useValue&lt;/code&gt; 공급자 코드 를 포함하는 구성 요소 팩토리를 생성합니다 . &lt;em&gt;해당&lt;/em&gt; 팩토리 모듈은 &lt;em&gt;이&lt;/em&gt; 소스 모듈 에 다시 도달 하여 로컬 (비 내보내기) &lt;code&gt;foo&lt;/code&gt; 변수 에 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0712bff79b6ba8bd1174d1e3baa5133a297e4d4c" translate="yes" xml:space="preserve">
          <source>The compiler handles token references in these positions differently.</source>
          <target state="translated">컴파일러는 이러한 위치의 토큰 참조를 다르게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="1c2d272b65afaacb9c96d83311fa7679569cb638" translate="yes" xml:space="preserve">
          <source>The compiler must retain &lt;em&gt;value position&lt;/em&gt; references at runtime, which prevents the component from being tree-shaken.</source>
          <target state="translated">컴파일러는 런타임에 &lt;em&gt;값 위치&lt;/em&gt; 참조를 유지해야 하므로 구성 요소가 트리 흔들리는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ada9db2a3fbbffaa6e62a942bdef132fbfb3595" translate="yes" xml:space="preserve">
          <source>The compiler needs the value of the &lt;code&gt;template&lt;/code&gt; property &lt;em&gt;right now&lt;/em&gt; to generate the component factory. The variable reference alone is insufficient. Prefixing the declaration with &lt;code&gt;export&lt;/code&gt; merely produces a new error, &quot;&lt;a href=&quot;aot-metadata-errors#only-initialized-variables&quot;&gt;&lt;code&gt;Only initialized variables and constants can be referenced&lt;/code&gt;&lt;/a&gt;&quot;.</source>
          <target state="translated">컴파일러는 값이 필요 &lt;code&gt;template&lt;/code&gt; 속성을 &lt;em&gt;지금&lt;/em&gt; 구성 요소 공장을 생성 할 수 있습니다. 변수 참조만으로는 충분하지 않습니다. 선언에 &lt;code&gt;export&lt;/code&gt; 를 접두사에 추가하면 &quot; &lt;a href=&quot;aot-metadata-errors#only-initialized-variables&quot;&gt; &lt;code&gt;Only initialized variables and constants can be referenced&lt;/code&gt; &lt;/a&gt; &quot;라는 새로운 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="126c486c473104383ae1229ed43b46dfdfc50d01" translate="yes" xml:space="preserve">
          <source>The compiler only allows metadata that create instances of the class &lt;code&gt;&lt;a href=&quot;../api/core/injectiontoken&quot;&gt;InjectionToken&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;@angular/core&lt;/code&gt;.</source>
          <target state="translated">컴파일러 는 &lt;code&gt;@angular/core&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../api/core/injectiontoken&quot;&gt;InjectionToken&lt;/a&gt;&lt;/code&gt; 클래스의 인스턴스를 만드는 메타 데이터 만 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="c9f89138d6d0f2fb62cfc6fb9e28cc12abb7395f" translate="yes" xml:space="preserve">
          <source>The compiler only supports metadata for the &lt;a href=&quot;../api/core#decorators&quot;&gt;Angular decorators in the &lt;code&gt;@angular/core&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">컴파일러 &lt;a href=&quot;../api/core#decorators&quot;&gt;는 &lt;code&gt;@angular/core&lt;/code&gt; 모듈&lt;/a&gt; 의 Angular 데코레이터에 대한 메타 데이터 만 지원 합니다 .</target>
        </trans-unit>
        <trans-unit id="dc097f6a4e195c52e2bb0c422611001de27e4295" translate="yes" xml:space="preserve">
          <source>The compiler starts with the entry components, then it generates code for the declared components it &lt;a href=&quot;ngmodule-faq#q-template-reference&quot;&gt;finds&lt;/a&gt; in an entry component's template, then for the declared components it discovers in the templates of previously compiled components, and so on. At the end of the process, the compiler has generated code for every entry component and every component reachable from an entry component.</source>
          <target state="translated">컴파일러는 입력 구성 요소로 시작한 다음 입력 구성 요소의 템플릿에서 &lt;a href=&quot;ngmodule-faq#q-template-reference&quot;&gt;찾은&lt;/a&gt; 선언 된 구성 요소에 대한 코드를 생성 한 다음 이전에 컴파일 된 구성 요소의 템플릿에서 검색 한 선언 된 구성 요소 등에 대한 코드를 생성합니다 . 프로세스가 끝나면 컴파일러는 모든 입력 구성 요소 및 입력 구성 요소에서 도달 할 수있는 모든 구성 요소에 대한 코드를 생성했습니다.</target>
        </trans-unit>
        <trans-unit id="30de544841894f2a949ed7ed373dd95bbee68599" translate="yes" xml:space="preserve">
          <source>The compiler treats object literals containing the fields &lt;code&gt;useClass&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/core/valuesansprovider#useValue&quot;&gt;useValue&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/core/factorysansprovider#useFactory&quot;&gt;useFactory&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;data&lt;/code&gt; specially, converting the expression initializing one of these fields into an exported variable that replaces the expression. This process of rewriting these expressions removes all the restrictions on what can be in them because the compiler doesn't need to know the expression's value&amp;mdash;it just needs to be able to generate a reference to the value.</source>
          <target state="translated">컴파일러는 &lt;code&gt;useClass&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/core/valuesansprovider#useValue&quot;&gt;useValue&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/core/factorysansprovider#useFactory&quot;&gt;useFactory&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;data&lt;/code&gt; 필드를 포함하는 객체 리터럴을 특수하게 처리하여 이러한 필드 중 하나를 초기화하는 표현식을 표현식을 대체하는 내 보낸 변수로 변환합니다. 이러한 표현식을 다시 작성하는 프로세스는 컴파일러가 표현식의 값을 알 필요가 없으므로 값에 대한 참조를 생성 할 수 있어야하기 때문에 그 안에있을 수있는 모든 제한 사항을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="465dc08186ad9c2bbff559d79ad3f0253ec651d2" translate="yes" xml:space="preserve">
          <source>The compiler treats object literals containing the fields &lt;code&gt;useClass&lt;/code&gt;, &lt;code&gt;useValue&lt;/code&gt;, &lt;code&gt;useFactory&lt;/code&gt;, and &lt;code&gt;data&lt;/code&gt; specially, converting the expression initializing one of these fields into an exported variable that replaces the expression. This process of rewriting these expressions removes all the restrictions on what can be in them because the compiler doesn't need to know the expression's value&amp;mdash;it just needs to be able to generate a reference to the value.</source>
          <target state="translated">컴파일러는 &lt;code&gt;useClass&lt;/code&gt; , &lt;code&gt;useValue&lt;/code&gt; , &lt;code&gt;useFactory&lt;/code&gt; 및 &lt;code&gt;data&lt;/code&gt; 필드를 포함하는 객체 리터럴을 특별히 처리하여 이러한 필드 중 하나를 초기화하는 표현식을 표현식을 대체하는 내 보낸 변수로 변환합니다. 이러한 식을 다시 작성하는이 프로세스는 컴파일러가 식의 값을 알 필요가없고 값에 대한 참조를 생성 할 수만 있으면되기 때문에 식에 포함될 수있는 모든 제한을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="db26295d71e3539c97b99511069043f20a6fd3aa" translate="yes" xml:space="preserve">
          <source>The compiler treats this usage as if you had written:</source>
          <target state="translated">컴파일러는이 사용법을 마치 작성한 것처럼 취급합니다.</target>
        </trans-unit>
        <trans-unit id="24b187f48898ccf4dbc0fdd64dfa738c3e7bfd6e" translate="yes" xml:space="preserve">
          <source>The compiler understands all syntax forms that the collector supports, but it may reject &lt;em&gt;syntactically&lt;/em&gt; correct metadata if the &lt;em&gt;semantics&lt;/em&gt; violate compiler rules.</source>
          <target state="translated">컴파일러는 콜렉터가 지원하는 모든 구문 양식을 이해하지만 &lt;em&gt;의미&lt;/em&gt; 가 컴파일러 규칙을 위반 하면 &lt;em&gt;구문 적으로&lt;/em&gt; 올바른 메타 데이터를 거부 할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5929dc62de7601c08bcabe703705f0dbec26534b" translate="yes" xml:space="preserve">
          <source>The compiler will &lt;a href=&quot;aot-compiler#code-folding&quot;&gt;fold&lt;/a&gt; the expression into the provider as if you had written this.</source>
          <target state="translated">컴파일러는 마치 작성한 것처럼 표현식을 공급자로 &lt;a href=&quot;aot-compiler#code-folding&quot;&gt;접&lt;/a&gt; 습니다.</target>
        </trans-unit>
        <trans-unit id="138f31c0677c88cc7b7a7fd6bf76154f84ce3954" translate="yes" xml:space="preserve">
          <source>The compiler will recognize the &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; element and the &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;routerLink&lt;/a&gt;&lt;/code&gt; attribute because you declared a corresponding &lt;code&gt;AppComponent&lt;/code&gt; and &lt;code&gt;RouterLinkDirectiveStub&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; configuration.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; 구성 에서 해당 &lt;code&gt;AppComponent&lt;/code&gt; 및 &lt;code&gt;RouterLinkDirectiveStub&lt;/code&gt; 을 선언 했으므로 컴파일러는 &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; 요소 및 &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;routerLink&lt;/a&gt;&lt;/code&gt; 속성을 인식 합니다.</target>
        </trans-unit>
        <trans-unit id="715bb9b8568dd05e7eb02ef4fd3d2ba93fd18630" translate="yes" xml:space="preserve">
          <source>The completed directive code looks like this:</source>
          <target state="translated">완성 된 지시문 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5053850abd39601781be8b25dae3426c32eb731b" translate="yes" xml:space="preserve">
          <source>The component DOM tests described in this guide often require extensive setup and advanced techniques whereas the &lt;a href=&quot;testing#component-class-testing&quot;&gt;unit tests&lt;/a&gt; are comparatively simple.</source>
          <target state="translated">이 가이드에 설명 된 구성 요소 DOM 테스트에는 광범위한 설정 및 고급 기술이 필요한 반면 &lt;a href=&quot;testing#component-class-testing&quot;&gt;단위 테스트&lt;/a&gt; 는 비교적 간단합니다.</target>
        </trans-unit>
        <trans-unit id="945dcf8f41bb23dc85788ad4c63aa881eb1cb6bf" translate="yes" xml:space="preserve">
          <source>The component defines a &lt;code&gt;deleteRequest&lt;/code&gt; property that returns an &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt;. When the user clicks &lt;em&gt;delete&lt;/em&gt;, the component invokes the &lt;code&gt;delete()&lt;/code&gt; method, telling the &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; to emit an &lt;code&gt;Item&lt;/code&gt; object.</source>
          <target state="translated">컴포넌트는 &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; 를 리턴하는 &lt;code&gt;deleteRequest&lt;/code&gt; 특성을 정의합니다 . 사용자가 &lt;em&gt;delete를&lt;/em&gt; 클릭 하면 구성 요소는 &lt;code&gt;delete()&lt;/code&gt; 메서드를 호출 하여 &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;Item&lt;/code&gt; 객체를 내보내 도록 지시 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5fed15d886f224a42d47fdb41a31f93da40106cc" translate="yes" xml:space="preserve">
          <source>The component defines a &lt;code&gt;deleteRequest&lt;/code&gt; property that returns an &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt;. When the user clicks &lt;strong&gt;Delete&lt;/strong&gt;, the component invokes the &lt;code&gt;delete()&lt;/code&gt; method, telling the &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; to emit an &lt;code&gt;Item&lt;/code&gt; object.</source>
          <target state="translated">구성 요소는 &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; 를 반환하는 &lt;code&gt;deleteRequest&lt;/code&gt; 속성을 정의합니다 . 사용자가 &lt;strong&gt;Delete를&lt;/strong&gt; 클릭 하면 구성 요소가 &lt;code&gt;delete()&lt;/code&gt; 메서드를 호출 하여 &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;Item&lt;/code&gt; 객체를 내보내 도록 지시 합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8eb8273c79d0db2bd78752acb04c3573261ff2c7" translate="yes" xml:space="preserve">
          <source>The component defines an accessibility-enabled element with both the standard HTML attribute &lt;code&gt;role&lt;/code&gt;, and ARIA attributes. The ARIA attribute &lt;code&gt;aria-valuenow&lt;/code&gt; is bound to the user's input.</source>
          <target state="translated">구성 요소는 표준 HTML 속성 &lt;code&gt;role&lt;/code&gt; 및 ARIA 속성 을 모두 사용하여 액세스 가능 요소를 정의 합니다. ARIA 속성 &lt;code&gt;aria-valuenow&lt;/code&gt; 는 사용자 입력에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="4f9ce139efb795e90ce6b8f3abad0b17a35b4fb0" translate="yes" xml:space="preserve">
          <source>The component definition also exports the class, &lt;code&gt;ProductAlertsComponent&lt;/code&gt;, which handles functionality for the component.</source>
          <target state="translated">컴포넌트 정의는 컴포넌트의 기능을 처리하는 &lt;code&gt;ProductAlertsComponent&lt;/code&gt; 클래스도 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="fa73e1af978181527b58e22c002fc64877e2e6db" translate="yes" xml:space="preserve">
          <source>The component directive example from above looks like this when expressed using the component API:</source>
          <target state="translated">컴포넌트 API를 사용하여 표현할 때 위의 컴포넌트 지시문 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7bc7b389fbcb64544804120818c464acab440078" translate="yes" xml:space="preserve">
          <source>The component file contains three transitions.</source>
          <target state="translated">구성 요소 파일에는 세 가지 전환이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="05a22aee3a73845cd036df1c66514d97e0d66817" translate="yes" xml:space="preserve">
          <source>The component is instantiated by being listed in Angular template. This means that the host element is controlled by Angular, but the component's view will be controlled by AngularJS.</source>
          <target state="translated">컴포넌트는 각도 템플릿에 나열되어 인스턴스화됩니다. 이는 호스트 요소가 Angular에 의해 제어되지만 구성 요소의보기는 AngularJS에 의해 제어됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="634e741b6ed10e05a132403dcdaef42865cb78fc" translate="yes" xml:space="preserve">
          <source>The component is instantiated by being listed in AngularJS template. This means that the host element is controlled by AngularJS, but the component's view will be controlled by Angular.</source>
          <target state="translated">컴포넌트는 AngularJS 템플리트에 나열되어 인스턴스화됩니다. 이는 호스트 요소가 AngularJS에 의해 제어되지만 구성 요소의보기는 Angular에 의해 제어됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="87bfe9e9cc407bbc45693a944d489ceb1150ea14" translate="yes" xml:space="preserve">
          <source>The component isn't expecting a result from the delete operation, so it subscribes without a callback. Even though you are not using the result, you still have to subscribe. Calling the &lt;code&gt;subscribe()&lt;/code&gt; method &lt;em&gt;executes&lt;/em&gt; the observable, which is what initiates the DELETE request.</source>
          <target state="translated">구성 요소가 삭제 작업의 결과를 기대하지 않으므로 콜백없이 구독합니다. 결과를 사용하지 않더라도 여전히 가입해야합니다. &lt;code&gt;subscribe()&lt;/code&gt; 메소드를 호출하면 observable이 &lt;em&gt;실행&lt;/em&gt; 되어 DELETE 요청이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="4b73c6bddfe52c8459168da819770d17a2a129c6" translate="yes" xml:space="preserve">
          <source>The component of the route</source>
          <target state="translated">경로의 구성 요소</target>
        </trans-unit>
        <trans-unit id="4aa79cea92ca5f94c22df8eaa184e84e014458cf" translate="yes" xml:space="preserve">
          <source>The component of the route, a constant.</source>
          <target state="translated">경로의 구성 요소, 상수</target>
        </trans-unit>
        <trans-unit id="1f39c6523ba2e6e387e161f0f9a129bc4867c79e" translate="yes" xml:space="preserve">
          <source>The component quickly becomes cluttered with data access minutia. The component becomes harder to understand, harder to test, and the data access logic can't be re-used or standardized.</source>
          <target state="translated">데이터 액세스를 최소화하여 구성 요소가 빠르게 복잡해집니다. 구성 요소를 이해하기 어렵고 테스트하기가 어려워지고 데이터 액세스 논리를 재사용하거나 표준화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f56d078cb463ae3dcc2533c399d9111710a9122" translate="yes" xml:space="preserve">
          <source>The component renders as the following:</source>
          <target state="translated">구성 요소는 다음과 같이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="d642e45463b12cd87110e913308fd35c74b02d00" translate="yes" xml:space="preserve">
          <source>The component should only display the selected hero details if the &lt;code&gt;selectedHero&lt;/code&gt; exists.</source>
          <target state="translated">&lt;code&gt;selectedHero&lt;/code&gt; 가 존재하는 경우 구성 요소에 선택한 영웅 세부 정보 만 표시되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="bd71cc1bc88a121f31376dc02838f1a5e74183b1" translate="yes" xml:space="preserve">
          <source>The component template interpolates the content as follows:</source>
          <target state="translated">구성 요소 템플릿은 다음과 같이 콘텐츠를 보간합니다.</target>
        </trans-unit>
        <trans-unit id="c7dbc7c28ecb5af85fcbc4145f18fa9e1be06908" translate="yes" xml:space="preserve">
          <source>The component test file generated by the CLI calls &lt;code&gt;compileComponents()&lt;/code&gt; even though it is never required when running &lt;code&gt;ng test&lt;/code&gt;.</source>
          <target state="translated">CLI에서 생성 된 구성 요소 테스트 파일 은 &lt;code&gt;ng test&lt;/code&gt; 실행시 절대 필요하지 않더라도 &lt;code&gt;compileComponents()&lt;/code&gt; 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="8a0311eba241fe09acc7a2c71109494bced8b04d" translate="yes" xml:space="preserve">
          <source>The component to instantiate when the path matches. Can be empty if child routes specify components.</source>
          <target state="translated">경로가 일치 할 때 인스턴스화 할 구성 요소입니다. 하위 경로가 구성 요소를 지정하는 경우 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c07c7ab7dee70787d92839f5740c175aea5adee" translate="yes" xml:space="preserve">
          <source>The component to transform.</source>
          <target state="translated">변환 할 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="c03142546a7a9067dc7bd0f3bdc5f667718c42e5" translate="yes" xml:space="preserve">
          <source>The component tree can be very deep and, most of the time, the nested components play no role in testing the component at the top of the tree.</source>
          <target state="translated">컴포넌트 트리는 매우 깊을 수 있으며 대부분의 경우 중첩 된 컴포넌트는 트리 상단에서 컴포넌트를 테스트하는 데 아무런 역할을하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e15674fa536b1448524d88911c6fd3a5af7c894" translate="yes" xml:space="preserve">
          <source>The component type.</source>
          <target state="translated">구성 요소 유형.</target>
        </trans-unit>
        <trans-unit id="a025e9eb678c1adf18cef368c04d88f1706b83ff" translate="yes" xml:space="preserve">
          <source>The component's &lt;code&gt;birthday&lt;/code&gt; value flows through the &lt;a href=&quot;template-expression-operators#pipe&quot;&gt;pipe operator&lt;/a&gt; ( | ) to the &lt;a href=&quot;../api/common/datepipe&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">구성 요소의 &lt;code&gt;birthday&lt;/code&gt; 값은 &lt;a href=&quot;template-expression-operators#pipe&quot;&gt;파이프 연산자&lt;/a&gt; (|)를 통해 &lt;a href=&quot;../api/common/datepipe&quot;&gt; &lt;code&gt;date&lt;/code&gt; &lt;/a&gt; 함수로 흐릅니다 .</target>
        </trans-unit>
        <trans-unit id="3a0e4aec9a04b168fe5b9cfc031aad8b684a6788" translate="yes" xml:space="preserve">
          <source>The component's &lt;code&gt;ngOnInit&lt;/code&gt; lifecycle hook calls the &lt;code&gt;HeroService&lt;/code&gt; method, not the constructor.</source>
          <target state="translated">구성 요소의 &lt;code&gt;ngOnInit&lt;/code&gt; 수명주기 후크 는 생성자가 아닌 &lt;code&gt;HeroService&lt;/code&gt; 메서드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a393e0445991d1a36a41d0c3b83117e4d646235e" translate="yes" xml:space="preserve">
          <source>The component's &lt;code&gt;selected&lt;/code&gt; property returns an &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt;, which looks like an RxJS synchronous &lt;code&gt;Observable&lt;/code&gt; to consumers. The test subscribes to it &lt;em&gt;explicitly&lt;/em&gt; just as the host component does &lt;em&gt;implicitly&lt;/em&gt;.</source>
          <target state="translated">구성 요소의 &lt;code&gt;selected&lt;/code&gt; 속성은 소비자에게 RxJS 동기식 &lt;code&gt;Observable&lt;/code&gt; 처럼 보이는 &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; 를 반환합니다 . 테스트 는 호스트 구성 요소가 &lt;em&gt;암시 적&lt;/em&gt; 으로 수행하는 것처럼 &lt;em&gt;명시 적으로&lt;/em&gt; 구독합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b1e101d4a9e06ccb23308352dafb1f38a636d4e4" translate="yes" xml:space="preserve">
          <source>The component's &lt;code&gt;selector&lt;/code&gt; value of &quot;app-hero-form&quot; means you can drop this form in a parent template using the &lt;code&gt;&amp;lt;app-hero-form&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">구성 요소의 &lt;code&gt;selector&lt;/code&gt; 값 &quot;app-hero-form&quot;은 &lt;code&gt;&amp;lt;app-hero-form&amp;gt;&lt;/code&gt; 태그를 사용하여이 양식을 상위 템플릿에 놓을 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="1962b26c443a8f93187c9613e919572df2a309b4" translate="yes" xml:space="preserve">
          <source>The component's &lt;code&gt;showConfigResponse()&lt;/code&gt; method displays the response headers as well as the configuration:</source>
          <target state="translated">구성 요소의 &lt;code&gt;showConfigResponse()&lt;/code&gt; 메서드는 구성뿐만 아니라 응답 헤더도 표시합니다.</target>
        </trans-unit>
        <trans-unit id="8bb55779cfa560056a11685cf4309c305487f8a0" translate="yes" xml:space="preserve">
          <source>The component's HTML selector.</source>
          <target state="translated">컴포넌트의 HTML 선택기</target>
        </trans-unit>
        <trans-unit id="45c242f97cfe38564c598a3971646c8412339c77" translate="yes" xml:space="preserve">
          <source>The conditional displays the data only if &lt;code&gt;userStream&lt;/code&gt; returns a value, so you don't need to use the &lt;a href=&quot;../../guide/template-expression-operators#safe-navigation-operator&quot;&gt;safe-navigation-operator&lt;/a&gt; (&lt;code&gt;?.&lt;/code&gt;) to guard against null values when accessing properties. You can display an alternative template while waiting for the data.</source>
          <target state="translated">조건부는 &lt;code&gt;userStream&lt;/code&gt; 이 값을 반환하는 경우에만 데이터를 표시 하므로 속성에 액세스 할 때 null 값을 방지 하기 위해 &lt;a href=&quot;../../guide/template-expression-operators#safe-navigation-operator&quot;&gt;safe-navigation-operator&lt;/a&gt; ( &lt;code&gt;?.&lt;/code&gt; )를 사용할 필요가 없습니다 . 데이터를 기다리는 동안 대체 템플릿을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="906d8cdaee971e09d03956839d141439a00f4e7f" translate="yes" xml:space="preserve">
          <source>The conditional displays the data only if &lt;code&gt;userStream&lt;/code&gt; returns a value, so you don't need to use the &lt;a href=&quot;../../guide/template-syntax#safe-navigation-operator&quot;&gt;safe-navigation-operator&lt;/a&gt; (&lt;code&gt;?.&lt;/code&gt;) to guard against null values when accessing properties. You can display an alternative template while waiting for the data.</source>
          <target state="translated">조건부에서는 &lt;code&gt;userStream&lt;/code&gt; 이 값을 반환하는 경우에만 데이터를 표시 하므로, 속성에 액세스 할 때 &lt;a href=&quot;../../guide/template-syntax#safe-navigation-operator&quot;&gt;안전 탐색 연산자&lt;/a&gt; ( &lt;code&gt;?.&lt;/code&gt; )를 사용하여 null 값을 방지 할 필요가 없습니다 . 데이터를 기다리는 동안 대체 템플릿을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d86de5c94963265bd4f854ea02275e5968f8001b" translate="yes" xml:space="preserve">
          <source>The configurable options for a default or targeted build generally correspond to the options available for the &lt;a href=&quot;cli/build&quot;&gt;&lt;code&gt;ng build&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;cli/serve&quot;&gt;&lt;code&gt;ng serve&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;cli/test&quot;&gt;&lt;code&gt;ng test&lt;/code&gt;&lt;/a&gt; commands. For details of those options and their possible values, see the &lt;a href=&quot;cli&quot;&gt;CLI Reference&lt;/a&gt;.</source>
          <target state="translated">기본 또는 대상 빌드에 대해 구성 가능한 옵션은 일반적으로 &lt;a href=&quot;cli/build&quot;&gt; &lt;code&gt;ng build&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;cli/serve&quot;&gt; &lt;code&gt;ng serve&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;cli/test&quot;&gt; &lt;code&gt;ng test&lt;/code&gt; &lt;/a&gt; 명령에 사용 가능한 옵션에 해당 합니다. 해당 옵션 및 가능한 값에 대한 자세한 내용은 &lt;a href=&quot;cli&quot;&gt;CLI 참조를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8683e9a1dac5420bfeea384e8f30a82f93d62bfe" translate="yes" xml:space="preserve">
          <source>The configuration file uses the JSON format. All file paths must begin with &lt;code&gt;/&lt;/code&gt;, which corresponds to the deployment directory&amp;mdash;usually &lt;code&gt;dist/&amp;lt;project-name&amp;gt;&lt;/code&gt; in CLI projects.</source>
          <target state="translated">구성 파일은 JSON 형식을 사용합니다. 모든 파일 경로는 배포 디렉토리에 해당하는 &lt;code&gt;/&lt;/code&gt; 로 시작해야합니다. 일반적으로 CLI 프로젝트에서는 &lt;code&gt;dist/&amp;lt;project-name&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="40e87f989f48f3ba9948b17f612ebb52c1eb9ad7" translate="yes" xml:space="preserve">
          <source>The configuration file uses the JSON format. All file paths must begin with &lt;code&gt;/&lt;/code&gt;, which is the deployment directory&amp;mdash;usually &lt;code&gt;dist&lt;/code&gt; in CLI projects.</source>
          <target state="translated">구성 파일은 JSON 형식을 사용합니다. 모든 파일 경로는 배포 디렉토리 인 &lt;code&gt;/&lt;/code&gt; 로 시작해야합니다 ( 일반적으로 CLI 프로젝트의 경우 &lt;code&gt;dist&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="9b69952674dd4b63a3a568c2873291a95fb4f9db" translate="yes" xml:space="preserve">
          <source>The configuration key to set or query, in JSON path format. For example: &quot;a[3].foo.bar[2]&quot;. If no new value is provided, returns the current value of this key.</source>
          <target state="translated">JSON 경로 형식으로 설정하거나 쿼리 할 구성 키입니다. 예 : &quot;a [3] .foo.bar [2]&quot; 새 값을 제공하지 않으면이 키의 현재 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eb6fc904e89e428b0083d3c15ea355abb65dfe2a" translate="yes" xml:space="preserve">
          <source>The configuration options generally correspond to the command options. You can override individual configuration defaults by specifying the corresponding options on the command line. The command can accept option names given in either dash-case or camelCase. Note that in the configuration file, you must specify names in camelCase.</source>
          <target state="translated">구성 옵션은 일반적으로 명령 옵션에 해당합니다. 명령 행에서 해당 옵션을 지정하여 개별 구성 기본값을 대체 할 수 있습니다. 명령은 대소 문자 또는 camelCase로 지정된 옵션 이름을 승인 할 수 있습니다. 구성 파일에서 camelCase에 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7b16623cd8cb243d6de3e15d7611a5847bcf2f77" translate="yes" xml:space="preserve">
          <source>The configuration to apply service worker to.</source>
          <target state="translated">서비스 워커를 적용 할 구성입니다.</target>
        </trans-unit>
        <trans-unit id="c64e682f36d33924e7b55e376fb7962258b0cea6" translate="yes" xml:space="preserve">
          <source>The configuration used to match this route *</source>
          <target state="translated">이 경로와 일치하는 데 사용되는 구성 *</target>
        </trans-unit>
        <trans-unit id="63af88f97d299ed29fc90f13430520c0ca49701b" translate="yes" xml:space="preserve">
          <source>The configuration used to match this route.</source>
          <target state="translated">이 경로와 일치하는 데 사용되는 구성입니다.</target>
        </trans-unit>
        <trans-unit id="68528e3bdae3eede6b9bd6f97339c8df83d69334" translate="yes" xml:space="preserve">
          <source>The configuration's injector is the initial injector set on the class, and used by default for each created instance.This behavior can be overridden with the static property to affect all newly created instances, or as a constructor argument for one-off creations.</source>
          <target state="translated">구성의 인젝터는 클래스에 설정된 초기 인젝터이며 생성 된 각 인스턴스에 대해 기본적으로 사용됩니다.이 동작은 새로 만든 모든 인스턴스에 영향을주기 위해 정적 속성으로 재정의하거나 일회성 생성의 생성자 인수로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="834a1e227c0c50a09a054c8e9e6ce66a5e71337b" translate="yes" xml:space="preserve">
          <source>The configurations key is optional, we'll leave it out for now.</source>
          <target state="translated">구성 키는 선택 사항이므로 지금은 제외하겠습니다.</target>
        </trans-unit>
        <trans-unit id="a6f51a44f469c2e24865a1040b3de3b6516154cf" translate="yes" xml:space="preserve">
          <source>The console output looks a bit like this:</source>
          <target state="translated">콘솔 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="72c105d38074b2df6181fbe4b841b458d3e091b7" translate="yes" xml:space="preserve">
          <source>The constructed paragraph renders strangely.</source>
          <target state="translated">구성된 단락이 이상하게 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="c7fdd6a63e113f58fb8d465907d502d5baf57f6c" translate="yes" xml:space="preserve">
          <source>The constructor asks for an injected instance of &lt;code&gt;Logger&lt;/code&gt; and stores it in a private field called &lt;code&gt;logger&lt;/code&gt;. The &lt;code&gt;getHeroes()&lt;/code&gt; method logs a message when asked to fetch heroes.</source>
          <target state="translated">생성자는 삽입 된 &lt;code&gt;Logger&lt;/code&gt; 인스턴스를 요청하여 &lt;code&gt;logger&lt;/code&gt; 라는 개인 필드에 저장합니다 . &lt;code&gt;getHeroes()&lt;/code&gt; 영웅을 가져 물었을 때 방법은 메시지를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="36406f88f194439134400738d911a712dacb18ae" translate="yes" xml:space="preserve">
          <source>The constructor expects Angular to inject the &lt;code&gt;HeroService&lt;/code&gt; into a private &lt;code&gt;heroService&lt;/code&gt; property.</source>
          <target state="translated">생성자는 Angular가 &lt;code&gt;HeroService&lt;/code&gt; 를 개인 &lt;code&gt;heroService&lt;/code&gt; 속성 에 주입 할 것으로 예상 합니다.</target>
        </trans-unit>
        <trans-unit id="02e6daf629ba2d69937d75255228c5dcdccc4d38" translate="yes" xml:space="preserve">
          <source>The constructor injects the &lt;code&gt;HeroesService&lt;/code&gt;, which defines the following interface.</source>
          <target state="translated">생성자 는 다음 인터페이스를 정의하는 &lt;code&gt;HeroesService&lt;/code&gt; 를 주입합니다 .</target>
        </trans-unit>
        <trans-unit id="7eab4a9cd938314dc3fba0ac964a8f9a79e0b72b" translate="yes" xml:space="preserve">
          <source>The constructor isn't an Angular hook &lt;em&gt;per se&lt;/em&gt;. The log confirms that input properties (the &lt;code&gt;name&lt;/code&gt; property in this case) have no assigned values at construction.</source>
          <target state="translated">생성자는 Angular hook &lt;em&gt;자체&lt;/em&gt; 가 아닙니다 . 로그는 구성시 입력 속성 ( 이 경우 &lt;code&gt;name&lt;/code&gt; 속성)에 할당 된 값이 없음을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a26127b5ec5fe19c64995c70e6ae4945b4c33a2f" translate="yes" xml:space="preserve">
          <source>The constructor tells Angular to inject the &lt;code&gt;GreetingModule&lt;/code&gt; into itself. The injection would be circular if Angular looked for &lt;code&gt;GreetingModule&lt;/code&gt; in the &lt;em&gt;current&lt;/em&gt; injector, but the &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; decorator means &quot;look for &lt;code&gt;GreetingModule&lt;/code&gt; in an ancestor injector, above me in the injector hierarchy.&quot;</source>
          <target state="translated">생성자는 Angular에게 &lt;code&gt;GreetingModule&lt;/code&gt; 을 자신 에게 주입하도록 지시 합니다. Angular가 &lt;em&gt;현재&lt;/em&gt; 인젝터 에서 &lt;code&gt;GreetingModule&lt;/code&gt; 을 찾은 경우 주입은 원형 이지만 &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt; () 데코레이터는 &quot; 인젝터 계층에서 나보다 상위 조상 인젝터에서 &lt;code&gt;GreetingModule&lt;/code&gt; 을 찾습니다&quot;를 의미 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2a0a07f08ada0f60a409bcf703aee3b141535d37" translate="yes" xml:space="preserve">
          <source>The content to replace with.</source>
          <target state="translated">바꿀 내용입니다.</target>
        </trans-unit>
        <trans-unit id="434978912cc545b69caa64dbe5cbc7693818a867" translate="yes" xml:space="preserve">
          <source>The contents of &lt;code&gt;node_modules/some-package/images/&lt;/code&gt; will be available in &lt;code&gt;dist/some-package/&lt;/code&gt;.</source>
          <target state="translated">의 내용 &lt;code&gt;node_modules/some-package/images/&lt;/code&gt; 에서 사용할 수 있습니다 &lt;code&gt;dist/some-package/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de9762d967849535b472516dad70dc2a5e2d798a" translate="yes" xml:space="preserve">
          <source>The context for terms in an expression is a blend of the &lt;em&gt;template variables&lt;/em&gt;, the directive's &lt;em&gt;context&lt;/em&gt; object (if it has one), and the component's &lt;em&gt;members&lt;/em&gt;. If you reference a name that belongs to more than one of these namespaces, the template variable name takes precedence, followed by a name in the directive's &lt;em&gt;context&lt;/em&gt;, and, lastly, the component's member names.</source>
          <target state="translated">표현식에서 용어의 컨텍스트는 &lt;em&gt;템플리트 변수&lt;/em&gt; , 지시문의 &lt;em&gt;컨텍스트&lt;/em&gt; 오브젝트 (있는 경우) 및 컴포넌트의 &lt;em&gt;멤버&lt;/em&gt; 가 혼합 된 것입니다 . 이러한 네임 스페이스 중 둘 이상에 속하는 이름을 참조하는 경우 템플리트 변수 이름이 우선하고 지시문의 &lt;em&gt;컨텍스트&lt;/em&gt; 에있는 이름 과 마지막으로 컴포넌트의 멤버 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="516e999a9dfd7f3d5bfbc11b52a151eecf3c24d1" translate="yes" xml:space="preserve">
          <source>The context for this view, inherited from the anchor element.</source>
          <target state="translated">이 뷰의 컨텍스트는 anchor 요소에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="3c82f52221a89639198df33fedec6d9813e4dcee" translate="yes" xml:space="preserve">
          <source>The context in which to listen for events. Can be the entire window or document, the body of the document, or a specific DOM element.</source>
          <target state="translated">이벤트를 청취 할 컨텍스트입니다. 전체 창 또는 문서, 문서 본문 또는 특정 DOM 요소 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8c9c8d1c4b92136befec8a41da007e51cffd2d0" translate="yes" xml:space="preserve">
          <source>The context object passed into a rule provides access to utility functions and metadata that the schematic may need to work with, including a logging API to help with debugging. The context also defines a &lt;em&gt;merge strategy&lt;/em&gt; that determines how changes are merged from the staged tree into the base tree. A change can be accepted or ignored, or throw an exception.</source>
          <target state="translated">규칙에 전달 된 컨텍스트 개체는 디버깅에 도움이되는 로깅 API를 포함하여 회로도와 함께 작동해야하는 유틸리티 기능 및 메타 데이터에 대한 액세스를 제공합니다. 또한 컨텍스트는 스테이지 트리에서 기본 트리로 변경 사항을 병합하는 방법을 결정하는 &lt;em&gt;병합 전략&lt;/em&gt; 을 정의합니다 . 변경을 수락하거나 무시하거나 예외를 던질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac7cbb9fe3e4587d9144d9bbb440b6a49b7cc42b" translate="yes" xml:space="preserve">
          <source>The context of a template statement can be the component class instance or the template. Because of this, template statements cannot refer to anything in the global namespace such as &lt;code&gt;window&lt;/code&gt; or &lt;code&gt;document&lt;/code&gt;. For example, template statements can't call &lt;code&gt;console.log()&lt;/code&gt; or &lt;code&gt;Math.max()&lt;/code&gt;.</source>
          <target state="translated">템플릿 문의 컨텍스트는 구성 요소 클래스 인스턴스 또는 템플릿 일 수 있습니다. 이 때문에 템플릿 문은 &lt;code&gt;window&lt;/code&gt; 또는 &lt;code&gt;document&lt;/code&gt; 와 같은 전역 네임 스페이스의 어떤 것도 참조 할 수 없습니다 . 예를 들어 템플릿 문은 &lt;code&gt;console.log()&lt;/code&gt; 또는 &lt;code&gt;Math.max()&lt;/code&gt; 호출 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="62f2c493dfbb04d85e053c932b8ad74fee0d374f" translate="yes" xml:space="preserve">
          <source>The context property for &lt;code&gt;let-hero&lt;/code&gt; wasn't specified. Its intended source is implicit. Angular sets &lt;code&gt;let-hero&lt;/code&gt; to the value of the context's &lt;code&gt;$implicit&lt;/code&gt; property, which &lt;code&gt;NgFor&lt;/code&gt; has initialized with the hero for the current iteration.</source>
          <target state="translated">&lt;code&gt;let-hero&lt;/code&gt; 의 컨텍스트 속성 이 지정되지 않았습니다. 의도 된 소스는 암시 적입니다. Angular는 &lt;code&gt;let-hero&lt;/code&gt; 를 컨텍스트의 &lt;code&gt;$implicit&lt;/code&gt; 속성 값으로 설정합니다. &lt;code&gt;NgFor&lt;/code&gt; 가 현재 반복에 대한 hero로 초기화했습니다.</target>
        </trans-unit>
        <trans-unit id="c7a76e231011258158f2254b2b16d3db05a38e38" translate="yes" xml:space="preserve">
          <source>The control directive from which to get the &lt;code&gt;&lt;a href=&quot;formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 을 가져올 제어 지시문입니다 .</target>
        </trans-unit>
        <trans-unit id="2bbb61d0c4df311e8b07462ca259b3c982a86148" translate="yes" xml:space="preserve">
          <source>The control directive to add to the form.</source>
          <target state="translated">양식에 추가 할 제어 지시문입니다.</target>
        </trans-unit>
        <trans-unit id="8cf41ea4b3493c2c856c54199afc949817c4eac6" translate="yes" xml:space="preserve">
          <source>The control has been visited.</source>
          <target state="translated">컨트롤을 방문했습니다.</target>
        </trans-unit>
        <trans-unit id="8285061d6a84be25121b021c12ee6bd37827dfdd" translate="yes" xml:space="preserve">
          <source>The control name to add to the collection</source>
          <target state="translated">컬렉션에 추가 할 컨트롤 이름</target>
        </trans-unit>
        <trans-unit id="5410d4b9567d41805c92f96af4682275c27445e2" translate="yes" xml:space="preserve">
          <source>The control name to check for existence in the collection</source>
          <target state="translated">컬렉션에 존재하는지 확인할 컨트롤 이름</target>
        </trans-unit>
        <trans-unit id="27a6dcc8aa638e92c26671752f447bfd819f1fd0" translate="yes" xml:space="preserve">
          <source>The control name to register in the collection</source>
          <target state="translated">컬렉션에 등록 할 컨트롤 이름</target>
        </trans-unit>
        <trans-unit id="ecc2af5b43a3852f887c5005940458e40013ceda" translate="yes" xml:space="preserve">
          <source>The control name to remove from the collection</source>
          <target state="translated">컬렉션에서 제거 할 컨트롤 이름</target>
        </trans-unit>
        <trans-unit id="ecdbba447a430bfa7169d3caa0fdd744eda0f7c5" translate="yes" xml:space="preserve">
          <source>The control name to replace in the collection</source>
          <target state="translated">컬렉션에서 바꿀 컨트롤 이름</target>
        </trans-unit>
        <trans-unit id="9760257811426aae616bf4d1494569b4a3c52759" translate="yes" xml:space="preserve">
          <source>The control to validate against.</source>
          <target state="translated">검증 할 컨트롤입니다.</target>
        </trans-unit>
        <trans-unit id="5b425478a2596d27714c9aeca87c94e3908535ff" translate="yes" xml:space="preserve">
          <source>The control value accessor also calls the &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel#viewToModelUpdate&quot;&gt;NgModel.viewToModelUpdate()&lt;/a&gt;&lt;/code&gt; method which emits an &lt;code&gt;ngModelChange&lt;/code&gt; event.</source>
          <target state="translated">제어 값 액세서는 또한 &lt;code&gt;ngModelChange&lt;/code&gt; 이벤트 를 생성하는 &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel#viewToModelUpdate&quot;&gt;NgModel.viewToModelUpdate()&lt;/a&gt;&lt;/code&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="bd98c4bcc74109310318a5dad8988a21d99457b6" translate="yes" xml:space="preserve">
          <source>The control value accessor attached to the input triggers the &lt;code&gt;setValue()&lt;/code&gt; method on the &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">입력에 연결된 컨트롤 값 접근 자는 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 인스턴스 에서 &lt;code&gt;setValue()&lt;/code&gt; 메서드를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="f1cc67d8c922fc67a0beca6d8cfcfeb12e494a15" translate="yes" xml:space="preserve">
          <source>The control value accessor listening for events on the form input element immediately relays the new value to the &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">양식 입력 요소에서 이벤트를 수신하는 제어 값 접근자는 즉시 새 값을 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 인스턴스에 릴레이합니다 .</target>
        </trans-unit>
        <trans-unit id="6d0f6693ae5ef3a6a4bffa9b91611a36bc4a2862" translate="yes" xml:space="preserve">
          <source>The control value accessor on the form input element updates the element with the new value.</source>
          <target state="translated">양식 입력 요소의 제어 값 접근자는 요소를 새 값으로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="e1fe9f7a09b8a92372a5486a9d79fb459c696cac" translate="yes" xml:space="preserve">
          <source>The control value accessor updates the form input element in the view with the latest &lt;code&gt;favoriteColor&lt;/code&gt; value.</source>
          <target state="translated">제어 값 접근자는보기에서 양식 입력 요소를 최신 &lt;code&gt;favoriteColor&lt;/code&gt; 값으로 업데이트 합니다.</target>
        </trans-unit>
        <trans-unit id="57410b20d49ca1897c2b04634df3cd7ef8cf74c9" translate="yes" xml:space="preserve">
          <source>The control's value has changed.</source>
          <target state="translated">컨트롤 값이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="ca5764f6850cc69be0e8c8077aba090d028119b4" translate="yes" xml:space="preserve">
          <source>The control's value is valid.</source>
          <target state="translated">컨트롤 값이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="e9901119ca7da8a80f5cee35a4eeb845a13e8315" translate="yes" xml:space="preserve">
          <source>The conversion process implements the &lt;code&gt;&lt;a href=&quot;../api/elements/ngelementconstructor&quot;&gt;NgElementConstructor&lt;/a&gt;&lt;/code&gt; interface, and creates a constructor class that is configured to produce a self-bootstrapping instance of your component.</source>
          <target state="translated">변환 프로세스는 &lt;code&gt;&lt;a href=&quot;../api/elements/ngelementconstructor&quot;&gt;NgElementConstructor&lt;/a&gt;&lt;/code&gt; 인터페이스를 구현하고 구성 요소의 자체 부트 스트랩 인스턴스를 생성하도록 구성된 생성자 클래스를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="c62334e88935fbdcec541fa91d80d7ebfb110faa" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;code&gt;ForbiddenValidatorDirective&lt;/code&gt; serves as a wrapper around the &lt;code&gt;forbiddenNameValidator&lt;/code&gt;.</source>
          <target state="translated">해당 &lt;code&gt;ForbiddenValidatorDirective&lt;/code&gt; 는 &lt;code&gt;forbiddenNameValidator&lt;/code&gt; 주위의 래퍼 역할을합니다 .</target>
        </trans-unit>
        <trans-unit id="71f13dbbb53ef63c0ce04dd500aaa91a7309173e" translate="yes" xml:space="preserve">
          <source>The corresponding DOM element in the browser (null for WebWorkers).</source>
          <target state="translated">브라우저의 해당 DOM 요소 (WebWorkers의 경우 널)</target>
        </trans-unit>
        <trans-unit id="6c2cbb3d5c755eeb2e5b9b3e623ec0e5d0851a99" translate="yes" xml:space="preserve">
          <source>The corresponding component template looks like this:</source>
          <target state="translated">해당 구성 요소 템플릿은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="32c9b0cfa7f7e663d7530ee0ae139a0a521b8ab6" translate="yes" xml:space="preserve">
          <source>The created object does not get cached by the injector.</source>
          <target state="translated">작성된 오브젝트는 인젝터에 의해 캐시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2dda5305b34fe50eac42c633b9209406f904f2ac" translate="yes" xml:space="preserve">
          <source>The creation API parses the component looking for input properties, and defines corresponding attributes for the custom element. It transforms the property names to make them compatible with custom elements, which do not recognize case distinctions. The resulting attribute names use dash-separated lowercase. For example, for a component with &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;('myInputProp') inputProp&lt;/code&gt;, the corresponding custom element defines an attribute &lt;code&gt;my-input-prop&lt;/code&gt;.</source>
          <target state="translated">작성 API는 입력 특성을 찾는 구성 요소를 구문 분석하고 사용자 정의 요소의 해당 속성을 정의합니다. 대소 문자 구분을 인식하지 못하는 사용자 정의 요소와 호환되도록 특성 이름을 변환합니다. 결과 속성 이름은 대시로 구분 된 소문자를 사용합니다. 예를 들어, &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;('myInputProp') inputProp&lt;/code&gt; 인 컴포넌트의 경우 해당 사용자 정의 요소는 속성 &lt;code&gt;my-input-prop&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a7ada0b3e583a0ac804c845e4cb5c1762cf95099" translate="yes" xml:space="preserve">
          <source>The curious, dedicated reader might enjoy this lengthy blog post, &lt;a href=&quot;https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/&quot;&gt;&quot;&lt;em&gt;Tasks, microtasks, queues and schedules&lt;/em&gt;&quot;&lt;/a&gt;.</source>
          <target state="translated">호기심 많고 헌신적 인 독자라면이 긴 블로그 게시물 인 &lt;a href=&quot;https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/&quot;&gt;&quot; &lt;em&gt;작업, 마이크로 태스크, 대기열 및 일정&lt;/em&gt; &quot;을&lt;/a&gt; 즐길 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d763599e77a8e6d59d75f1dcf9f6e13a9029d04" translate="yes" xml:space="preserve">
          <source>The currency code.</source>
          <target state="translated">통화 코드.</target>
        </trans-unit>
        <trans-unit id="1e961714f083647d9f7ae1dda7fc90792c835c30" translate="yes" xml:space="preserve">
          <source>The current &lt;code&gt;BannerComponent&lt;/code&gt; presents static title text in the HTML template.</source>
          <target state="translated">현재 &lt;code&gt;BannerComponent&lt;/code&gt; 는 HTML 템플릿에 정적 제목 텍스트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6b2680b0b6ad0710d65d5e5d0746df48e0918d04" translate="yes" xml:space="preserve">
          <source>The current &lt;code&gt;HeroService.getHeroes()&lt;/code&gt; uses the RxJS &lt;code&gt;of()&lt;/code&gt; function to return an array of mock heroes as an &lt;code&gt;Observable&amp;lt;Hero[]&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;HeroService.getHeroes()&lt;/code&gt; 는 RxJS &lt;code&gt;of()&lt;/code&gt; 함수를 사용하여 모의 영웅 배열을 &lt;code&gt;Observable&amp;lt;Hero[]&amp;gt;&lt;/code&gt; 으로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f0560dbef41d1c541841cce2b26360211c4eacaf" translate="yes" xml:space="preserve">
          <source>The current Navigation object if one exists</source>
          <target state="translated">현재 탐색 객체 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="7657c044778fdf6db1068d532e80d6b9bbb7dca8" translate="yes" xml:space="preserve">
          <source>The current URL.</source>
          <target state="translated">현재 URL입니다.</target>
        </trans-unit>
        <trans-unit id="f730ad3ca5d926f1046ca241082281a7fc5a38ff" translate="yes" xml:space="preserve">
          <source>The current guidelines allow for a three-level navigation structure with two header levels. Don't add a third header level.</source>
          <target state="translated">현재 가이드 라인은 두 개의 헤더 레벨을 가진 3 단계 탐색 구조를 허용합니다. 세 번째 헤더 레벨을 추가하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ba120156cf1c2d4ed712977962e77791a19b845b" translate="yes" xml:space="preserve">
          <source>The current snapshot of the router state</source>
          <target state="translated">라우터 상태의 현재 스냅 샷</target>
        </trans-unit>
        <trans-unit id="f8da6bf8a2bb6f6853fcc1eb9997ee7e13be10da" translate="yes" xml:space="preserve">
          <source>The current snapshot of this route</source>
          <target state="translated">이 경로의 현재 스냅 샷</target>
        </trans-unit>
        <trans-unit id="21d77846b699af6d4d8754e17ac9142b0c9df316" translate="yes" xml:space="preserve">
          <source>The current state of routing in this NgModule.</source>
          <target state="translated">이 NgModule에서의 현재 라우팅 상태입니다.</target>
        </trans-unit>
        <trans-unit id="a53af39d47142b7e376378e57c34e7d410be02ee" translate="yes" xml:space="preserve">
          <source>The current state of the router including a tree of the currently activated routes together with convenience methods for traversing the route tree.</source>
          <target state="translated">현재 활성화 된 경로 트리를 포함하는 라우터의 현재 상태와 경로 트리를 순회하기위한 편리한 방법.</target>
        </trans-unit>
        <trans-unit id="c415c67c1ff9b11622afff6651c02db58a193f2a" translate="yes" xml:space="preserve">
          <source>The current value</source>
          <target state="translated">현재 가치</target>
        </trans-unit>
        <trans-unit id="e0698114602d013efa358ad69baa59d634483f5a" translate="yes" xml:space="preserve">
          <source>The current value of the control.</source>
          <target state="translated">컨트롤의 현재 값입니다.</target>
        </trans-unit>
        <trans-unit id="166fd9baf2239e5db9cc405e59c759c3c4b062a1" translate="yes" xml:space="preserve">
          <source>The current version becomes invalid due to a failed hash.</source>
          <target state="translated">해시 실패로 인해 현재 버전이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e72187959d2f6f8846ed4b702c80eccf7a5d636" translate="yes" xml:space="preserve">
          <source>The custom element feature extends HTML by allowing you to define a tag whose content is created and controlled by JavaScript code. A custom element (also called a &lt;em&gt;web component&lt;/em&gt;) is recognized by a browser when it's added to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry&quot;&gt;CustomElementRegistry&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 요소 기능은 JavaScript 코드로 컨텐츠를 작성하고 제어하는 ​​태그를 정의 할 수 있도록하여 HTML을 확장합니다. 사용자 정의 요소 ( &lt;em&gt;웹 컴포넌트&lt;/em&gt; 라고도 함 )는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry&quot;&gt;CustomElementRegistry에&lt;/a&gt; 추가 될 때 브라우저에서 인식됩니다 .</target>
        </trans-unit>
        <trans-unit id="79531376d994372336113a8ca4d9f22bc6ea61d5" translate="yes" xml:space="preserve">
          <source>The custom id is persistent. The extractor tool does not change it when the translatable text changes. Therefore, you do not need to update the translation. This approach makes maintenance easier.</source>
          <target state="translated">맞춤 ID는 영구적입니다. 번역 가능한 텍스트가 변경 될 때 추출기 도구는이를 변경하지 않습니다. 따라서 번역을 업데이트 할 필요가 없습니다. 이 접근 방식은 유지 관리를 더 쉽게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="602948966524c9d08153f6c90b9a75768c2a47aa" translate="yes" xml:space="preserve">
          <source>The data model for this type of form must represent a question. The example includes the &lt;code&gt;DynamicFormQuestionComponent&lt;/code&gt;, which defines a question as the fundamental object in the model.</source>
          <target state="translated">이 유형의 양식에 대한 데이터 모델은 질문을 나타내야합니다. 이 예제에는 질문을 모델의 기본 개체로 정의하는 &lt;code&gt;DynamicFormQuestionComponent&lt;/code&gt; 가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b5e4745435b5221cc9e2e4e96dbb049887d7068" translate="yes" xml:space="preserve">
          <source>The data-binding and injection contexts of embedded views created from this &lt;code&gt;&lt;a href=&quot;templateref&quot;&gt;TemplateRef&lt;/a&gt;&lt;/code&gt; inherit from the contexts of this location.</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;templateref&quot;&gt;TemplateRef&lt;/a&gt;&lt;/code&gt; 에서 작성된 임베디드 뷰의 데이터 바인딩 및 삽입 컨텍스트는이 위치의 컨텍스트에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="f5a2918cf9fc155916140d56e47a05739e0b8db4" translate="yes" xml:space="preserve">
          <source>The data-binding context of the embedded view, as declared in the &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; usage.</source>
          <target state="translated">&lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 사용법에 선언 된 내장 뷰의 데이터 바인딩 컨텍스트입니다 .</target>
        </trans-unit>
        <trans-unit id="91f462d727aaa6e3286220f710d54dc9c89b65cd" translate="yes" xml:space="preserve">
          <source>The date expression: a &lt;code&gt;Date&lt;/code&gt; object, a number (milliseconds since UTC epoch), or an ISO string (&lt;a href=&quot;https://www.w3.org/TR/NOTE-datetime&quot;&gt;https://www.w3.org/TR/NOTE-datetime&lt;/a&gt;).</source>
          <target state="translated">날짜 표현식 : &lt;code&gt;Date&lt;/code&gt; 객체, 숫자 (UTC epoch 이후 밀리 초) 또는 ISO 문자열 ( &lt;a href=&quot;https://www.w3.org/TR/NOTE-datetime&quot;&gt;https://www.w3.org/TR/NOTE-datetime&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="6be1ff2545cf2f4032129392887400693da8322e" translate="yes" xml:space="preserve">
          <source>The date to format, as a Date, or a number (milliseconds since UTC epoch) or an &lt;a href=&quot;https://www.w3.org/TR/NOTE-datetime&quot;&gt;ISO date-time string&lt;/a&gt;.</source>
          <target state="translated">날짜 또는 숫자 (UTC 에포크 이후 밀리 초) 또는 &lt;a href=&quot;https://www.w3.org/TR/NOTE-datetime&quot;&gt;ISO 날짜-시간 문자열&lt;/a&gt; 로 형식화 할 날짜 입니다.</target>
        </trans-unit>
        <trans-unit id="a32c99fba05678acf40c6cb230f29e12bd614202" translate="yes" xml:space="preserve">
          <source>The date-time components to include. See &lt;code&gt;&lt;a href=&quot;datepipe&quot;&gt;DatePipe&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">포함 할 날짜-시간 구성 요소입니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;datepipe&quot;&gt;DatePipe&lt;/a&gt;&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4682d1b62b750807cc0fad3edaa1edf9e246371a" translate="yes" xml:space="preserve">
          <source>The date/time components to include, using predefined options or a custom format string.</source>
          <target state="translated">사전 정의 된 옵션 또는 사용자 정의 형식 문자열을 사용하여 포함 할 날짜 / 시간 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="d9f490b1b139b96680fa4c11b44dad3844d370ec" translate="yes" xml:space="preserve">
          <source>The declaring NgModule.</source>
          <target state="translated">NgModule 선언.</target>
        </trans-unit>
        <trans-unit id="98c201f69b3b13f5cb6ff04cc4ea1ccaa2f85377" translate="yes" xml:space="preserve">
          <source>The decorator requirement is imposed by TypeScript. TypeScript normally discards parameter type information when it &lt;a href=&quot;glossary#transpile&quot;&gt;transpiles&lt;/a&gt; the code to JavaScript. TypeScript preserves this information if the class has a decorator and the &lt;code&gt;emitDecoratorMetadata&lt;/code&gt; compiler option is set &lt;code&gt;true&lt;/code&gt; in TypeScript's &lt;code&gt;tsconfig.json&lt;/code&gt; configuration file. The CLI configures &lt;code&gt;tsconfig.json&lt;/code&gt; with &lt;code&gt;emitDecoratorMetadata: true&lt;/code&gt;.</source>
          <target state="translated">데코레이터 요구 사항은 TypeScript에 의해 부과됩니다. TypeScript는 일반적으로 코드를 JavaScript로 코드 &lt;a href=&quot;glossary#transpile&quot;&gt;변환&lt;/a&gt; 할 때 매개 변수 유형 정보를 버립니다 . 클래스가 장식을 가지고 있으며, 경우에 타이프 라이터는이 정보를 보존 &lt;code&gt;emitDecoratorMetadata&lt;/code&gt; 의 컴파일러 옵션이 설정되어있는 &lt;code&gt;true&lt;/code&gt; 타이프의에서 &lt;code&gt;tsconfig.json&lt;/code&gt; 의 구성 파일. CLI 는 &lt;code&gt;emitDecoratorMetadata: true&lt;/code&gt; &lt;code&gt;tsconfig.json&lt;/code&gt; 을 구성 합니다 .</target>
        </trans-unit>
        <trans-unit id="4251b78ae593ecab9f27a838a16244d1b57f7e3e" translate="yes" xml:space="preserve">
          <source>The deep details of structural directives are covered in the &lt;a href=&quot;structural-directives&quot;&gt;Structural Directives&lt;/a&gt; guide, which explains the following:</source>
          <target state="translated">구조적 지시문에 대한 자세한 내용은 다음을 설명하는 &lt;a href=&quot;structural-directives&quot;&gt;구조 지시문&lt;/a&gt; 안내서에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="712324aee1adee04b50e7221977f131f39e9ab45" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;&lt;a href=&quot;controlvalueaccessor&quot;&gt;ControlValueAccessor&lt;/a&gt;&lt;/code&gt; for writing a value and listening to changes on input elements. The accessor is used by the &lt;code&gt;&lt;a href=&quot;formcontroldirective&quot;&gt;FormControlDirective&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;formcontrolname&quot;&gt;FormControlName&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;ngmodel&quot;&gt;NgModel&lt;/a&gt;&lt;/code&gt; directives.</source>
          <target state="translated">값을 쓰고 입력 요소의 변경 사항을 수신하기위한 기본 &lt;code&gt;&lt;a href=&quot;controlvalueaccessor&quot;&gt;ControlValueAccessor&lt;/a&gt;&lt;/code&gt; 입니다. 접근자는 &lt;code&gt;&lt;a href=&quot;formcontroldirective&quot;&gt;FormControlDirective&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;formcontrolname&quot;&gt;FormControlName&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;ngmodel&quot;&gt;NgModel&lt;/a&gt;&lt;/code&gt; 지시문에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f7b6c4995ba6a4dfd9eaabf3e2d50d81a0d5b1e8" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;&lt;a href=&quot;forms/controlvalueaccessor&quot;&gt;ControlValueAccessor&lt;/a&gt;&lt;/code&gt; for writing a value and listening to changes on input elements. The accessor is used by the &lt;code&gt;&lt;a href=&quot;forms/formcontroldirective&quot;&gt;FormControlDirective&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;forms/formcontrolname&quot;&gt;FormControlName&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;forms/ngmodel&quot;&gt;NgModel&lt;/a&gt;&lt;/code&gt; directives.</source>
          <target state="translated">값을 쓰고 입력 요소의 변경 사항을 수신하기위한 기본 &lt;code&gt;&lt;a href=&quot;forms/controlvalueaccessor&quot;&gt;ControlValueAccessor&lt;/a&gt;&lt;/code&gt; 입니다. 접근자는 &lt;code&gt;&lt;a href=&quot;forms/formcontroldirective&quot;&gt;FormControlDirective&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;forms/formcontrolname&quot;&gt;FormControlName&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;forms/ngmodel&quot;&gt;NgModel&lt;/a&gt;&lt;/code&gt; 지시문에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4e719651b95774d5d34ffe3d1bbd55b00706ab7b" translate="yes" xml:space="preserve">
          <source>The default Renderer implementation is &lt;code&gt;DomRenderer&lt;/code&gt;. Also available is &lt;code&gt;WebWorkerRenderer&lt;/code&gt;.</source>
          <target state="translated">기본 렌더러 구현은 &lt;code&gt;DomRenderer&lt;/code&gt; 입니다. &lt;code&gt;WebWorkerRenderer&lt;/code&gt; 도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8144ff44256c0840ffad9f04ff6fa0e5521432e2" translate="yes" xml:space="preserve">
          <source>The default application created by the Angular CLI only has one component, &lt;code&gt;AppComponent&lt;/code&gt;, so it is in both the &lt;code&gt;declarations&lt;/code&gt; and the &lt;code&gt;bootstrap&lt;/code&gt; arrays.</source>
          <target state="translated">Angular CLI에 의해 작성된 기본 애플리케이션에는 하나의 구성 요소 인 &lt;code&gt;AppComponent&lt;/code&gt; 만 있으므로 &lt;code&gt;declarations&lt;/code&gt; 및 &lt;code&gt;bootstrap&lt;/code&gt; 배열 모두에 있습니다.</target>
        </trans-unit>
        <trans-unit id="faf5e63ed78ca0e97a9ecedb41e45ca7f39187d5" translate="yes" xml:space="preserve">
          <source>The default behavior of registering once the application stabilizes (i.e. as soon as there are no pending micro- and macro-tasks) is designed to register the ServiceWorker as soon as possible but without affecting the application's first time load.</source>
          <target state="translated">응용 프로그램이 안정화되면 (즉, 보류중인 마이크로 및 매크로 작업이없는 즉시) 등록하는 기본 동작은 응용 프로그램의 첫로드에 영향을주지 않고 가능한 한 빨리 ServiceWorker를 등록하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="672d2814be4490a28b926b37ab8405f75d9fe39e" translate="yes" xml:space="preserve">
          <source>The default behavior of registering once the application stabilizes (i.e. as soon as there are no pending micro- and macro-tasks), is designed register the ServiceWorker as soon as possible but without affecting the application's first time load.</source>
          <target state="translated">응용 프로그램이 안정화되면 (즉, 보류중인 마이크로 및 매크로 작업이없는 즉시) 등록하는 기본 동작은 가능한 한 빨리 응용 프로그램의 첫 번째로드에 영향을주지 않고 ServiceWorker를 등록하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="cce4ed312ef59874b902e6e384a1d10149839da4" translate="yes" xml:space="preserve">
          <source>The default browser opens and displays the Getting Started sample application.</source>
          <target state="translated">기본 브라우저가 열리고 시작하기 샘플 응용 프로그램이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0f5ba8741324b5f3ed216ef4d87ba588c6257ad8" translate="yes" xml:space="preserve">
          <source>The default change-detection algorithm looks for differences by comparing bound-property values by reference across change detection runs. You can use this hook to check for and respond to changes by some other means.</source>
          <target state="translated">기본 변경 감지 알고리즘은 변경 감지 실행에서 참조로 바운드 특성 값을 비교하여 차이를 찾습니다. 이 후크를 사용하여 다른 방법으로 변경 사항을 확인하고 응답 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bdda24538401899e9cf064e6950ae0505e59468" translate="yes" xml:space="preserve">
          <source>The default currency code is currently always &lt;code&gt;USD&lt;/code&gt; but this is deprecated from v9.</source>
          <target state="translated">기본 통화 코드는 현재 항상 &lt;code&gt;USD&lt;/code&gt; 이지만 v9에서는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="082b0e1b657a0cc56834735f1afbffb10d4ce270" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;code&gt;&lt;a href=&quot;errorhandler&quot;&gt;ErrorHandler&lt;/a&gt;&lt;/code&gt; prints error messages to the &lt;code&gt;console&lt;/code&gt;. To intercept error handling, write a custom exception handler that replaces this default as appropriate for your app.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;errorhandler&quot;&gt;ErrorHandler&lt;/a&gt;&lt;/code&gt; 의 기본 구현은 오류 메시지를 &lt;code&gt;console&lt;/code&gt; 인쇄합니다 . 오류 처리를 가로 채려면 앱에 맞게이 기본값을 대체하는 사용자 지정 예외 처리기를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="db3547e124faaafb5a7338dfb8bf9084eed6ca08" translate="yes" xml:space="preserve">
          <source>The default in v11 is &lt;code&gt;corrected&lt;/code&gt;.</source>
          <target state="translated">v11의 기본값이 &lt;code&gt;corrected&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3da2e963162d2e85424f83d2c8181d34306ac18d" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;false&lt;/code&gt;. Testers who prefer fine control over test behavior tend to keep it &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. 테스트 동작에 대한 정밀한 제어를 선호하는 테스터는이를 &lt;code&gt;false&lt;/code&gt; 으로 유지하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ebb2e2795a7b0b2584064979361ec77fdedf64e" translate="yes" xml:space="preserve">
          <source>The default is defined as the first currency which is still in use.</source>
          <target state="translated">기본값은 아직 사용중인 첫 번째 통화로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f3ba8d89cb5ef08f208e48a85b605b4310bf02cf" translate="yes" xml:space="preserve">
          <source>The default linting tool is &lt;a href=&quot;https://palantir.github.io/tslint/&quot;&gt;TSLint&lt;/a&gt;, and the default configuration is specified in the project's &lt;code&gt;tslint.json&lt;/code&gt; file.</source>
          <target state="translated">기본 linting 도구는 &lt;a href=&quot;https://palantir.github.io/tslint/&quot;&gt;TSLint&lt;/a&gt; 이며 기본 구성은 프로젝트의 &lt;code&gt;tslint.json&lt;/code&gt; 파일에 지정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa5bb1f5c1cbe109211dd889cbb9c6ae3627b274" translate="yes" xml:space="preserve">
          <source>The default path-match strategy is 'prefix', which means that the router checks URL elements from the left to see if the URL matches a specified path. For example, '/team/11/user' matches 'team/:id'.</source>
          <target state="translated">기본 경로 일치 전략은 '접두사'입니다. 즉, 라우터가 왼쪽에서 URL 요소를 확인하여 URL이 지정된 경로와 일치하는지 확인합니다. 예를 들어, '/ team / 11 / user'는 'team / : id'와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a47bf320097df757ab7493c282071f6bfda35329" translate="yes" xml:space="preserve">
          <source>The default project is the value of &lt;code&gt;defaultProject&lt;/code&gt; in &lt;code&gt;angular.json&lt;/code&gt;.</source>
          <target state="translated">기본 프로젝트의 값입니다 &lt;code&gt;defaultProject&lt;/code&gt; 에서 &lt;code&gt;angular.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41162e3fcbf077344fe0553550fad85de67bc73a" translate="yes" xml:space="preserve">
          <source>The default route should redirect to the &lt;code&gt;HeroListComponent&lt;/code&gt; only when the entire url is &lt;code&gt;''&lt;/code&gt;. Remember to restore the redirect to &lt;code&gt;pathMatch = 'full'&lt;/code&gt;.</source>
          <target state="translated">기본 경로는 전체 URL이 &lt;code&gt;''&lt;/code&gt; 인 경우에만 &lt;code&gt;HeroListComponent&lt;/code&gt; 로 리디렉션되어야합니다 . 리디렉션을 &lt;code&gt;pathMatch = 'full'&lt;/code&gt; 로 복원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="35028a29988fb7b9cfea4b5e01d0bd632d1882bd" translate="yes" xml:space="preserve">
          <source>The default route should redirect to the &lt;code&gt;HeroListComponent&lt;/code&gt;&lt;em&gt;only&lt;/em&gt; when the &lt;em&gt;entire&lt;/em&gt; url is &lt;code&gt;''&lt;/code&gt;. Remember to restore the redirect to &lt;code&gt;&lt;a href=&quot;../api/router/route#pathMatch&quot;&gt;pathMatch&lt;/a&gt; = '&lt;a href=&quot;../api/core/version#full&quot;&gt;full&lt;/a&gt;'&lt;/code&gt;.</source>
          <target state="translated">기본 경로는 &lt;em&gt;전체&lt;/em&gt; URL이 &lt;code&gt;''&lt;/code&gt; 인 경우 &lt;em&gt;에만 &lt;/em&gt; &lt;code&gt;HeroListComponent&lt;/code&gt; 로 경로 재지 정해야합니다 . &lt;code&gt;&lt;a href=&quot;../api/router/route#pathMatch&quot;&gt;pathMatch&lt;/a&gt; = '&lt;a href=&quot;../api/core/version#full&quot;&gt;full&lt;/a&gt;'&lt;/code&gt; = ' &lt;a href=&quot;../api/core/version#full&quot;&gt;full&lt;/a&gt; '으로 리디렉션을 복원해야합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="40dc3536f16b1ce21d8af7dde493b0505694ab3d" translate="yes" xml:space="preserve">
          <source>The definition of a &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; element to match or create.</source>
          <target state="translated">일치하거나 만들 &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; 요소 의 정의입니다 .</target>
        </trans-unit>
        <trans-unit id="29c7e53a19049e62c9da95d6a0a14c4a3484e84c" translate="yes" xml:space="preserve">
          <source>The dependency injector provides services to a component, such as the router service that lets you define navigation among views.</source>
          <target state="translated">종속성 인젝터는보기 간 탐색을 정의 할 수있는 라우터 서비스와 같은 컴포넌트에 서비스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b7a62bbd3b9e12b19e45e6db0e78136526c99fd6" translate="yes" xml:space="preserve">
          <source>The dependency object (returned by the factory function) is typically a class instance, but can be other things as well. In this example, the dependency object is a string of the names of the runners up to the &quot;Hero of the Month&quot; contest.</source>
          <target state="translated">팩토리 함수에 의해 반환되는 의존성 객체는 일반적으로 클래스 인스턴스이지만 다른 것들도 될 수 있습니다. 이 예에서 종속성 개체는 &quot;달의 영웅&quot;컨테스트까지 주자의 이름으로 구성된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="0c7316f7415af94bc3bb1c1645bdc8512fc3d426" translate="yes" xml:space="preserve">
          <source>The detail view is different. It displays a particular hero. It can't know which hero to show on its own. That information must come from outside.</source>
          <target state="translated">상세도는 다릅니다. 특정 영웅을 표시합니다. 어떤 영웅을 스스로 보여줄지 알 수 없습니다. 그 정보는 외부에서 나와야합니다.</target>
        </trans-unit>
        <trans-unit id="4c817e48763ae86e1867cf929f8071103e83a6b1" translate="yes" xml:space="preserve">
          <source>The details are specific to each kind of element and therefore the &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;NgModel&lt;/a&gt;&lt;/code&gt; directive only works for an element supported by a &lt;a href=&quot;../api/forms/controlvalueaccessor&quot;&gt;ControlValueAccessor&lt;/a&gt; that adapts an element to this protocol. Angular provides &lt;em&gt;value accessors&lt;/em&gt; for all of the basic HTML form elements and the &lt;a href=&quot;forms&quot;&gt;Forms&lt;/a&gt; guide shows how to bind to them.</source>
          <target state="translated">세부 사항은 각 유형의 요소에 고유하므로 &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;NgModel&lt;/a&gt;&lt;/code&gt; 지시문 은 요소를이 프로토콜에 맞게 조정하는 &lt;a href=&quot;../api/forms/controlvalueaccessor&quot;&gt;ControlValueAccessor&lt;/a&gt; 가 지원하는 요소에 대해서만 작동 합니다. Angular는 모든 기본 HTML 양식 요소에 대한 &lt;em&gt;값 접근&lt;/em&gt; 자를 제공 하며 &lt;a href=&quot;forms&quot;&gt;양식&lt;/a&gt; 안내서는 요소 에 바인딩하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a724916e40e1a922d989c92b3ecf082d7928f9a8" translate="yes" xml:space="preserve">
          <source>The details child route requires an &lt;code&gt;id&lt;/code&gt; route parameter.</source>
          <target state="translated">하위 경로 세부 사항에는 &lt;code&gt;id&lt;/code&gt; 경로 매개 변수 가 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="f0ac9df13cb70c5c72364ce763f333d5013d07ec" translate="yes" xml:space="preserve">
          <source>The details of Angular router configuration are best left to the &lt;a href=&quot;router&quot;&gt;Routing documentation&lt;/a&gt; which recommends that you create a &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; dedicated to router configuration (called a &lt;em&gt;Routing Module&lt;/em&gt;).</source>
          <target state="translated">각도 라우터 구성의 세부 사항은 가장에 남아있는 &lt;a href=&quot;router&quot;&gt;라우팅 문서&lt;/a&gt; 당신이 만드는 것이 좋습니다 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; (A라는 라우터 구성 전용 &lt;em&gt;라우팅 모듈&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="8a9f2a38fc0d832b04fd3ce2fa72347e9013e429" translate="yes" xml:space="preserve">
          <source>The diagnostic is evidence that values really are flowing from the input box to the model and back again.</source>
          <target state="translated">진단은 값이 실제로 입력 상자에서 모델로 흐르고 다시 흐르고 있다는 증거입니다.</target>
        </trans-unit>
        <trans-unit id="6cfa18b3ca324abf3063bbd00b532a641ab1a8b0" translate="yes" xml:space="preserve">
          <source>The diagnostic line that shows interpolated values demonstrates that values are really flowing from the input box to the model and back again.</source>
          <target state="translated">보간 된 값을 보여주는 진단 라인은 값이 실제로 입력 상자에서 모델로 그리고 다시 되돌아 오는 것을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="21adcbdc5aef6ef62df6c7fe98623baf3748c6ed" translate="yes" xml:space="preserve">
          <source>The diagnostic near the top of the form confirms that all of your changes are reflected in the model.</source>
          <target state="translated">양식 상단 근처의 진단은 모든 변경 사항이 모델에 반영되었음을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e6efeb726810925d371a1fb1a6d0474051cdf771" translate="yes" xml:space="preserve">
          <source>The difference between hiding and removing doesn't matter for a simple paragraph. It does matter when the host element is attached to a resource intensive component. Such a component's behavior continues even when hidden. The component stays attached to its DOM element. It keeps listening to events. Angular keeps checking for changes that could affect data bindings. Whatever the component was doing, it keeps doing.</source>
          <target state="translated">숨기기와 제거의 차이점은 간단한 단락에 중요하지 않습니다. 호스트 요소가 자원 집약적 구성 요소에 접속되는시기는 중요합니다. 이러한 구성 요소의 동작은 숨겨져 있어도 계속됩니다. 컴포넌트는 DOM 요소에 연결된 상태를 유지합니다. 이벤트를 계속 듣고 있습니다. Angular는 데이터 바인딩에 영향을 줄 수있는 변경 사항을 계속 확인합니다. 구성 요소가 무엇을하든 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="05f9c87a5a6b790829816cc1f58f2d347fb1340f" translate="yes" xml:space="preserve">
          <source>The difference is a matter of trust. Angular treats a component's template as &lt;em&gt;belonging&lt;/em&gt; to the component. The component and its template trust each other implicitly. Therefore, the component's own template may bind to &lt;em&gt;any&lt;/em&gt; property of that component, with or without the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; decorator.</source>
          <target state="translated">차이점은 신뢰의 문제입니다. Angular는 구성 요소의 템플릿을 구성 요소에 &lt;em&gt;속하는&lt;/em&gt; 것으로 취급합니다 . 구성 요소와 해당 템플릿은 서로를 암시 적으로 신뢰합니다. 따라서 컴포넌트 자체 템플릿은 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt; 데코레이터를 사용하거나 사용하지 않고 해당 컴포넌트의 &lt;em&gt;모든&lt;/em&gt; 속성에 바인딩 할 &lt;em&gt;수&lt;/em&gt; 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34d8a0c8d3141d61c5f06db8d5d7c912587d8341" translate="yes" xml:space="preserve">
          <source>The difference is demonstrated in the examples above using the &lt;strong&gt;favorite color&lt;/strong&gt; input element.</source>
          <target state="translated">차이점은 &lt;strong&gt;선호하는 색상&lt;/strong&gt; 입력 요소를 사용하여 위의 예에서 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="d0b68e8984c3be4843fe55f903fdbda57abf5093" translate="yes" xml:space="preserve">
          <source>The difference is demonstrated in the previous examples that use the favorite-color input element.</source>
          <target state="translated">차이점은 선호하는 색상 입력 요소를 사용하는 이전 예제에서 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="ea05ec71ce84c9eace3d13785908f6ad65b675c9" translate="yes" xml:space="preserve">
          <source>The differences between &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; end here. The rest of the &lt;code&gt;&lt;a href=&quot;../api/upgrade/static&quot;&gt;upgrade/static&lt;/a&gt;&lt;/code&gt; APIs and concepts work in the exact same way for both types of hybrid apps. See &lt;a href=&quot;upgrade&quot;&gt;Upgrading from AngularJS&lt;/a&gt; to learn about:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 의 차이점은 여기서 끝납니다. 나머지 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static&quot;&gt;upgrade/static&lt;/a&gt;&lt;/code&gt; API 및 개념은 두 가지 유형의 하이브리드 앱에 대해 동일한 방식으로 작동합니다. 다음 에 대해 배우려면 &lt;a href=&quot;upgrade&quot;&gt;AngularJS&lt;/a&gt; 에서 업그레이드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6588061d3d1691e6fff573c5dfe4f13036d79c9f" translate="yes" xml:space="preserve">
          <source>The differences from the WHATWG version include:</source>
          <target state="translated">WHATWG 버전과의 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c0cd765a4fa83561fb7b303deb68bf2d797c31c7" translate="yes" xml:space="preserve">
          <source>The different parts of the above declaration are as follows:</source>
          <target state="translated">위 선언의 다른 부분은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b57de4f61f7ca0b603af7696485495da36c5ceb" translate="yes" xml:space="preserve">
          <source>The directive (&lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt;) that marks where the router displays a view.</source>
          <target state="translated">라우터가보기를 표시하는 위치를 표시하는 지시문 ( &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e2a943aff4c59b087f2ebcb886a4b3d822ed396d" translate="yes" xml:space="preserve">
          <source>The directive &lt;em&gt;attribute name&lt;/em&gt; should be spelled in &lt;em&gt;lowerCamelCase&lt;/em&gt; and begin with a prefix. Don't use &lt;code&gt;ng&lt;/code&gt;. That prefix belongs to Angular. Pick something short that fits you or your company. In this example, the prefix is &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="translated">지시문 &lt;em&gt;속성 이름&lt;/em&gt; 은 &lt;em&gt;lowerCamelCase&lt;/em&gt; 에서 철자를 입력 하고 접두어로 시작 해야합니다 . &lt;code&gt;ng&lt;/code&gt; 를 사용하지 마십시오 . 해당 접두사는 Angular에 속합니다. 자신이나 회사에 적합한 짧은 것을 선택하십시오. 이 예에서 접두사는 &lt;code&gt;app&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ba6a347d4773ad30b8df5e51d0a337cc8bc69a55" translate="yes" xml:space="preserve">
          <source>The directive &lt;em&gt;class&lt;/em&gt; name ends in &lt;code&gt;&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;&lt;/code&gt; per the &lt;a href=&quot;styleguide#02-03&quot;&gt;style guide&lt;/a&gt;. Angular's own directives do not.</source>
          <target state="translated">지시문 &lt;em&gt;클래스&lt;/em&gt; 이름 은 &lt;a href=&quot;styleguide#02-03&quot;&gt;스타일 안내서&lt;/a&gt; 에 &lt;code&gt;&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;&lt;/code&gt; 끝납니다 . Angular의 자체 지시문은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="51842e95f5cffa45ec0bfdc97ee2a7c20674dbdc" translate="yes" xml:space="preserve">
          <source>The directive class then implements the &lt;code&gt;&lt;a href=&quot;../api/forms/validator&quot;&gt;Validator&lt;/a&gt;&lt;/code&gt; interface, so that it can easily integrate with Angular forms. Here is the rest of the directive to help you get an idea of how it all comes together.</source>
          <target state="translated">그런 다음 지시어 클래스 는 Angular 형식과 쉽게 통합 할 수 있도록 &lt;code&gt;&lt;a href=&quot;../api/forms/validator&quot;&gt;Validator&lt;/a&gt;&lt;/code&gt; 인터페이스 를 구현합니다 . 이 모든 것이 어떻게 결합되는지에 대한 아이디어를 얻는 데 도움이되는 나머지 지침은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="478c2c1ea3888dc7a9fd6ef30943705c388014aa" translate="yes" xml:space="preserve">
          <source>The directive class then implements the &lt;code&gt;&lt;a href=&quot;../api/forms/validator&quot;&gt;Validator&lt;/a&gt;&lt;/code&gt; interface, so that it can easily integrate with Angular forms. Here is the rest of the directive to help you get an idea of how it all comes together:</source>
          <target state="translated">지시문 클래스는 &lt;code&gt;&lt;a href=&quot;../api/forms/validator&quot;&gt;Validator&lt;/a&gt;&lt;/code&gt; 인터페이스 를 구현하여 Angular 양식과 쉽게 통합 할 수 있습니다. 다음은 지시문이 모두 어떻게 구성되는지 이해하는 데 도움이되는 지시문의 나머지 부분입니다.</target>
        </trans-unit>
        <trans-unit id="b6bcdd91bdc7b44148909c3bc1149dbbef3ee183" translate="yes" xml:space="preserve">
          <source>The directive configures the component template to define how the user navigates to the route or URL. When the user clicks a product name, the app displays the details for that product.</source>
          <target state="translated">이 지시문은 사용자가 경로 또는 URL로 이동하는 방법을 정의하도록 구성 요소 템플릿을 구성합니다. 사용자가 제품 이름을 클릭하면 해당 제품에 대한 세부 정보가 앱에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fef982e6c8f1c3d4a71424e22b9ee7addfb89bda" translate="yes" xml:space="preserve">
          <source>The directive consumer expects to bind a true/false condition to &lt;code&gt;[appUnless]&lt;/code&gt;. That means the directive needs an &lt;code&gt;appUnless&lt;/code&gt; property, decorated with &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">지시어 소비자는 true / false 조건을 &lt;code&gt;[appUnless]&lt;/code&gt; 에 바인딩해야합니다 . 지시어가 필요로하는 수단 &lt;code&gt;appUnless&lt;/code&gt; 의 장식 속성을, &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e4d5899afdcb557b6934f6b0ba2aaa7025a8c64" translate="yes" xml:space="preserve">
          <source>The directive creates an &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; and exposes it as a property.</source>
          <target state="translated">이 지시문은 &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; 를 만들고 속성으로 노출합니다.</target>
        </trans-unit>
        <trans-unit id="3fce666c3d79d1e2430245c510a12d4b3059abdd" translate="yes" xml:space="preserve">
          <source>The directive defines &lt;code&gt;ngOnInit()&lt;/code&gt; and &lt;code&gt;ngOnDestroy()&lt;/code&gt; hooks that log messages to the parent via an injected &lt;code&gt;LoggerService&lt;/code&gt;.</source>
          <target state="translated">지시문은 삽입 된 &lt;code&gt;LoggerService&lt;/code&gt; 를 통해 부모에게 메시지를 기록하는 &lt;code&gt;ngOnInit()&lt;/code&gt; 및 &lt;code&gt;ngOnDestroy()&lt;/code&gt; 후크를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="db669c56bde0e0533c1d29dfee5bfc6ec09764ad" translate="yes" xml:space="preserve">
          <source>The directive for adding/removing classes from an HTML element when an associated &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;routerLink&lt;/a&gt;&lt;/code&gt; contained on or inside the element becomes active/inactive.</source>
          <target state="translated">요소 내부 또는 내부에 포함 된 연관된 &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;routerLink&lt;/a&gt;&lt;/code&gt; 가 활성화 / 비활성화 될 때 HTML 요소에서 클래스를 추가 / 제거하기위한 지시문입니다 .</target>
        </trans-unit>
        <trans-unit id="7b6fd6a150b5d66afb816ae7295a48ec4f8688d7" translate="yes" xml:space="preserve">
          <source>The directive for binding a clickable HTML element to a route. Clicking an element with a &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;routerLink&lt;/a&gt;&lt;/code&gt; directive that is bound to a</source>
          <target state="translated">클릭 가능한 HTML 요소를 경로에 바인딩하기위한 지시문입니다. 바인드 된 &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;routerLink&lt;/a&gt;&lt;/code&gt; 지시문이 있는 요소 클릭</target>
        </trans-unit>
        <trans-unit id="720f2f8cb29907d240dec98a3b152961aea40b80" translate="yes" xml:space="preserve">
          <source>The directive instance.</source>
          <target state="translated">지시어 인스턴스.</target>
        </trans-unit>
        <trans-unit id="f9fd79ce44d9191d35df57d19db01b5aa188436a" translate="yes" xml:space="preserve">
          <source>The directive sets the background to a highlight color when the user mouses over the DOM element to which the directive is applied.</source>
          <target state="translated">지시문은 사용자가 지시문이 적용되는 DOM 요소 위에 마우스를 놓을 때 배경을 강조 색상으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="3179195806726150a32be026d2382af65d93e04a" translate="yes" xml:space="preserve">
          <source>The directive then calls &lt;code&gt;EventEmitter.emit(data)&lt;/code&gt; to emit an event, passing in message data, which can be anything.</source>
          <target state="translated">그런 다음 지시문은 &lt;code&gt;EventEmitter.emit(data)&lt;/code&gt; 를 호출 하여 이벤트를 생성하고 메시지 데이터를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="3dadb675af202c36e02cf9e0644a0f6784933e09" translate="yes" xml:space="preserve">
          <source>The directive's &lt;em&gt;selector&lt;/em&gt; is typically the directive's &lt;strong&gt;attribute name&lt;/strong&gt; in square brackets, &lt;code&gt;[appUnless]&lt;/code&gt;. The brackets define a CSS &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors&quot;&gt;attribute selector&lt;/a&gt;.</source>
          <target state="translated">지시문의 &lt;em&gt;선택기&lt;/em&gt; 는 일반적으로 대괄호 &lt;code&gt;[appUnless]&lt;/code&gt; 로 지시문의 &lt;strong&gt;속성 이름&lt;/strong&gt; 입니다 . 대괄호는 CSS &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors&quot;&gt;속성 선택기를&lt;/a&gt; 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a65366dfec5fde7acab8128614c62e56b18c5c2e" translate="yes" xml:space="preserve">
          <source>The directory name to create the workspace in.</source>
          <target state="translated">작업 공간을 작성할 디렉토리 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0c859cde8538cadb116c397acbbea91d60134e68" translate="yes" xml:space="preserve">
          <source>The disabled status to set on the element</source>
          <target state="translated">요소에 설정할 수없는 상태</target>
        </trans-unit>
        <trans-unit id="0dedb18c8e3657fdad61ad7a842be7e630e26797" translate="yes" xml:space="preserve">
          <source>The disabled value</source>
          <target state="translated">비활성화 된 값</target>
        </trans-unit>
        <trans-unit id="f237bd4f809c19acaa65706b33e3dc5e3b8749b9" translate="yes" xml:space="preserve">
          <source>The display looks the same, but the code is clearer.</source>
          <target state="translated">디스플레이는 동일하게 보이지만 코드가 더 명확합니다.</target>
        </trans-unit>
        <trans-unit id="d8bcb8d5d64520feb45a9a032da8776b213521b0" translate="yes" xml:space="preserve">
          <source>The displayed value changes as you update the form control element.</source>
          <target state="translated">양식 컨트롤 요소를 업데이트하면 표시된 값이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="166a9002f622127466458a0d9c6c3c60c8874330" translate="yes" xml:space="preserve">
          <source>The distinction between an HTML attribute and a DOM property is key to understanding how Angular binding works. &lt;strong&gt;Attributes are defined by HTML. Properties are accessed from DOM (Document Object Model) nodes.&lt;/strong&gt;</source>
          <target state="translated">HTML 속성과 DOM 속성의 구별은 각도 바인딩의 작동 방식을 이해하는 데 중요합니다. &lt;strong&gt;속성은 HTML로 정의됩니다. 속성은 DOM (Document Object Model) 노드에서 액세스합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5be893a71b5822406de32b6141daaf6fcfc26fc8" translate="yes" xml:space="preserve">
          <source>The doc generation process consumes the markdown files in the &lt;code&gt;content/guide&lt;/code&gt; directory and produces JSON files in the &lt;code&gt;src/generated/docs/guide&lt;/code&gt; directory, which is also flat. Those JSON files contain a combination of document metadata and HTML content.</source>
          <target state="translated">문서 생성 프로세스는 &lt;code&gt;content/guide&lt;/code&gt; 디렉토리 에서 마크 다운 파일을 사용 하고 &lt;code&gt;src/generated/docs/guide&lt;/code&gt; 디렉토리 에서 JSON 파일을 생성 합니다. 이러한 JSON 파일에는 문서 메타 데이터와 HTML 컨텐츠의 조합이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="757ded666a68b6c3ac40103b86cb3424cfc48bbf" translate="yes" xml:space="preserve">
          <source>The doc generation process erases these comments before displaying them in the doc viewer. It also strips them from stackblitz and sample code downloads.</source>
          <target state="translated">문서 생성 프로세스는 이러한 주석을 문서 뷰어에 표시하기 전에 지 웁니다. 또한 stackblitz 및 샘플 코드 다운로드에서 제거합니다.</target>
        </trans-unit>
        <trans-unit id="4c43f4f32a923e773c7cd6d68f1699d4b637e4d5" translate="yes" xml:space="preserve">
          <source>The doc generator reads the image dimensions from the file and adds width and height attributes to the &lt;code&gt;img&lt;/code&gt; tag automatically. If you want to control the size of the image, supply your own width and height attributes.</source>
          <target state="translated">문서 생성기는 파일에서 이미지 크기를 읽고 너비 및 높이 속성을 &lt;code&gt;img&lt;/code&gt; 태그에 자동으로 추가합니다. 이미지의 크기를 제어하려면 고유 한 너비 및 높이 속성을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="0db28a33c3d601d7a77b4ee9b1f07754d91499dd" translate="yes" xml:space="preserve">
          <source>The doc tooling reports an error if the file identified in the path does not exist &lt;strong&gt;or is &lt;em&gt;git&lt;/em&gt;-ignored&lt;/strong&gt;.</source>
          <target state="translated">경로에서 확인 된 파일이 존재하지 않는 경우 문서 공구는 오류를보고 &lt;strong&gt;이거나 &lt;em&gt;자식&lt;/em&gt; -ignored&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a8ce0feb69612f68f0f5866a34dd0b783bcf3d1b" translate="yes" xml:space="preserve">
          <source>The documentation generally refers to &lt;em&gt;elements&lt;/em&gt; (&lt;code&gt;&lt;a href=&quot;../api/core/elementref&quot;&gt;ElementRef&lt;/a&gt;&lt;/code&gt; instances), as distinct from &lt;em&gt;DOM elements&lt;/em&gt; (which can be accessed directly if necessary).</source>
          <target state="translated">이 문서는 일반적으로 &lt;em&gt;DOM 요소&lt;/em&gt; 와 구별되는 &lt;em&gt;요소&lt;/em&gt; ( &lt;code&gt;&lt;a href=&quot;../api/core/elementref&quot;&gt;ElementRef&lt;/a&gt;&lt;/code&gt; 인스턴스)를 말합니다 ( 필요한 경우 직접 액세스 할 수 있음).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6950b5369e17c747d6d6f1e74badedf7eff1e093" translate="yes" xml:space="preserve">
          <source>The double curly braces are Angular's &lt;em&gt;interpolation binding&lt;/em&gt; syntax. This interpolation binding presents the component's &lt;code&gt;title&lt;/code&gt; property value inside the HTML header tag.</source>
          <target state="translated">이중 중괄호는 Angular의 &lt;em&gt;보간 바인딩&lt;/em&gt; 구문입니다. 이 보간 바인딩 은 HTML 헤더 태그 내에 구성 요소의 &lt;code&gt;title&lt;/code&gt; 속성 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="60368b0fb0530b310d1b03d0c629cde2a42557de" translate="yes" xml:space="preserve">
          <source>The drop down works properly.</source>
          <target state="translated">드롭 다운이 제대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f7df533c465dacb0b3380c1fdf650cf2849bea23" translate="yes" xml:space="preserve">
          <source>The dynamic form itself will be represented by a container component, which you will add in a later step. Each question is represented in the form component's template by an &lt;code&gt;&amp;lt;app-question&amp;gt;&lt;/code&gt; tag, which matches an instance of &lt;code&gt;DynamicFormQuestionComponent&lt;/code&gt;.</source>
          <target state="translated">동적 양식 자체는 이후 단계에서 추가 할 컨테이너 구성 요소로 표시됩니다. 각 질문은 &lt;code&gt;DynamicFormQuestionComponent&lt;/code&gt; 인스턴스와 일치하는 &lt;code&gt;&amp;lt;app-question&amp;gt;&lt;/code&gt; 태그로 양식 구성 요소의 템플릿에 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="d7022688694dc65a2c8f3c08da2b0a9b3ae17aba" translate="yes" xml:space="preserve">
          <source>The eagerly loaded scenario</source>
          <target state="translated">열심히로드 된 시나리오</target>
        </trans-unit>
        <trans-unit id="ea57f8da3c0e12c71f28c904fd0f0841386ae246" translate="yes" xml:space="preserve">
          <source>The easiest way to create a component is with the Angular CLI. You can also create a component manually.</source>
          <target state="translated">구성 요소를 만드는 가장 쉬운 방법은 Angular CLI를 사용하는 것입니다. 구성 요소를 수동으로 생성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c12f2ea045d53bad086859121475d2ad2a833c0a" translate="yes" xml:space="preserve">
          <source>The easiest way to display a component property is to bind the property name through interpolation. With interpolation, you put the property name in the view template, enclosed in double curly braces: &lt;code&gt;{{myHero}}&lt;/code&gt;.</source>
          <target state="translated">구성 요소 속성을 표시하는 가장 쉬운 방법은 보간을 통해 속성 이름을 바인딩하는 것입니다. 보간을 사용하면 속성 템플릿 이름을 이중 중괄호 &lt;code&gt;{{myHero}}&lt;/code&gt; 로 묶어 뷰 템플릿에 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="2d1ec4c9b3516ed0310d2e6eabdaf99dbd349d4a" translate="yes" xml:space="preserve">
          <source>The easing value controls how the animation accelerates and decelerates during its runtime. Value is one of &lt;code&gt;ease&lt;/code&gt;, &lt;code&gt;ease-in&lt;/code&gt;, &lt;code&gt;ease-out&lt;/code&gt;, &lt;code&gt;ease-in-out&lt;/code&gt;, or a &lt;code&gt;cubic-bezier()&lt;/code&gt; function call. If not supplied, no easing is applied.</source>
          <target state="translated">여유 값은 런타임 동안 애니메이션의 가속 및 감속 방법을 제어합니다. 값은 &lt;code&gt;ease&lt;/code&gt; , &lt;code&gt;ease-in&lt;/code&gt; , &lt;code&gt;ease-out&lt;/code&gt; , &lt;code&gt;ease-in-out&lt;/code&gt; 또는 &lt;code&gt;cubic-bezier()&lt;/code&gt; 함수 호출 중 하나입니다. 공급되지 않으면 여유가 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="673d673b2746886a3adde806bd89c20b0680bdef" translate="yes" xml:space="preserve">
          <source>The element tag name, if it is an element.</source>
          <target state="translated">요소 태그 이름 (요소 인 경우)</target>
        </trans-unit>
        <trans-unit id="d27c746aa80a187e9f22b16f7b95f9f1bed7667f" translate="yes" xml:space="preserve">
          <source>The element that will recognize gestures.</source>
          <target state="translated">제스처를 인식 할 요소입니다.</target>
        </trans-unit>
        <trans-unit id="e0442f5cd8f77d16465566da511146ed7ff5097c" translate="yes" xml:space="preserve">
          <source>The element to query, or a set of elements that contain Angular-specific characteristics, specified with one or more of the following tokens.</source>
          <target state="translated">쿼리 할 요소 또는 각도 별 특성을 포함하는 요소 집합으로, 다음 토큰 중 하나 이상으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="84276241b9685b6ea2701e6001dbf22cb649f9c1" translate="yes" xml:space="preserve">
          <source>The element to render.</source>
          <target state="translated">렌더링 할 요소입니다.</target>
        </trans-unit>
        <trans-unit id="9131974bc73e41cfa82641177ab47b4bbe64ec2b" translate="yes" xml:space="preserve">
          <source>The element to which the animation is attached.</source>
          <target state="translated">애니메이션이 첨부 된 요소입니다.</target>
        </trans-unit>
        <trans-unit id="46178d56386d4cf368fc2af3376e280cef598d8e" translate="yes" xml:space="preserve">
          <source>The element to which you apply a directive is its &lt;em&gt;host&lt;/em&gt; element. The &lt;code&gt;&amp;lt;happy-hero&amp;gt;&lt;/code&gt; is the host element for the happy &lt;code&gt;*&lt;a href=&quot;../api/common/ngswitchcase&quot;&gt;ngSwitchCase&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&amp;lt;unknown-hero&amp;gt;&lt;/code&gt; is the host element for the &lt;code&gt;*&lt;a href=&quot;../api/common/ngswitchdefault&quot;&gt;ngSwitchDefault&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지시문을 적용 할 요소 는 해당 &lt;em&gt;호스트&lt;/em&gt; 요소입니다. &lt;code&gt;&amp;lt;happy-hero&amp;gt;&lt;/code&gt; 행복의 호스트 요소 &lt;code&gt;*&lt;a href=&quot;../api/common/ngswitchcase&quot;&gt;ngSwitchCase&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;&amp;lt;unknown-hero&amp;gt;&lt;/code&gt; 의 호스트 요소 &lt;code&gt;*&lt;a href=&quot;../api/common/ngswitchdefault&quot;&gt;ngSwitchDefault&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21955f7341d9631161057f2409976b172f526079" translate="yes" xml:space="preserve">
          <source>The element's own component instance, if it has one.</source>
          <target state="translated">요소 자체의 구성 요소 인스턴스 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="3bf4b7ea68f964a8343706cfd8e0de47b6ae2323" translate="yes" xml:space="preserve">
          <source>The element.</source>
          <target state="translated">요소.</target>
        </trans-unit>
        <trans-unit id="4ad5959dbe7800ed816d9f5708f3fc045876a16c" translate="yes" xml:space="preserve">
          <source>The empty path in the fourth route represents the default path for the application&amp;mdash;the place to go when the path in the URL is empty, as it typically is at the start. This default route redirects to the route for the &lt;code&gt;/heroes&lt;/code&gt; URL and, therefore, displays the &lt;code&gt;HeroesListComponent&lt;/code&gt;.</source>
          <target state="translated">네 번째 경로의 빈 경로는 응용 프로그램의 기본 경로를 나타냅니다. URL의 경로가 비어있을 때 이동할 위치는 일반적으로 시작 부분입니다. 이 기본 경로는 &lt;code&gt;/heroes&lt;/code&gt; URL에 대한 경로로 리디렉션 되므로 &lt;code&gt;HeroesListComponent&lt;/code&gt; 를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="f953b82a33a57fd342ecf714841bf89e003c89ed" translate="yes" xml:space="preserve">
          <source>The encoded key name.</source>
          <target state="translated">인코딩 된 키 이름</target>
        </trans-unit>
        <trans-unit id="77a9b35bf33aad2c1e20f1db858b00aff0e15a54" translate="yes" xml:space="preserve">
          <source>The encoded value.</source>
          <target state="translated">인코딩 된 값입니다.</target>
        </trans-unit>
        <trans-unit id="b4d1c435b55c4bd54f0e5938665f180e3308a59f" translate="yes" xml:space="preserve">
          <source>The ending location just happens to be the same as the component itself, because it is the topmost component in this application.</source>
          <target state="translated">종료 위치는이 응용 프로그램에서 최상위 구성 요소이므로 구성 요소 자체와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="53f8087657d38ede7c7b2e78926607c4e103415b" translate="yes" xml:space="preserve">
          <source>The endpoint URL.</source>
          <target state="translated">엔드 포인트 URL</target>
        </trans-unit>
        <trans-unit id="ce758382f5b525c72c93874bf2a5511cf0624108" translate="yes" xml:space="preserve">
          <source>The entire &lt;a href=&quot;http://v7.angular.io/api/http&quot;&gt;&lt;code&gt;@angular/http&lt;/code&gt;&lt;/a&gt; package has been removed. Use &lt;a href=&quot;../api/common/http&quot;&gt;&lt;code&gt;@angular/common/http&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">전체 &lt;a href=&quot;http://v7.angular.io/api/http&quot;&gt; &lt;code&gt;@angular/http&lt;/code&gt; &lt;/a&gt; 패키지가 제거되었습니다. 대신 &lt;a href=&quot;../api/common/http&quot;&gt; &lt;code&gt;@angular/common/http&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="09267d94484132cc08f19cf699a998d66e34af3d" translate="yes" xml:space="preserve">
          <source>The entire cart component is shown below:</source>
          <target state="translated">전체 카트 구성 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="517d85bc6d5992973ef1adac25e14215d5732b6c" translate="yes" xml:space="preserve">
          <source>The entire template translation is complete. The next section describes how to load that translation into the app.</source>
          <target state="translated">전체 템플릿 번역이 완료되었습니다. 다음 섹션에서는 해당 번역을 앱에로드하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="65be920f45735066f65d3093424f23271e09fd22" translate="yes" xml:space="preserve">
          <source>The error location is the beginning of the text node that contains the interpolation expression with the error. If the error is in an attribute binding such as &lt;code&gt;[value]=&quot;person.address.street&quot;&lt;/code&gt;, the error location is the location of the attribute that contains the error.</source>
          <target state="translated">오류 위치는 오류가있는 보간 표현식을 포함하는 텍스트 노드의 시작입니다. 오류가 &lt;code&gt;[value]=&quot;person.address.street&quot;&lt;/code&gt; 와 같은 속성 바인딩에있는 경우 오류 위치는 오류가 포함 된 속성의 위치입니다.</target>
        </trans-unit>
        <trans-unit id="5b2800e5c7af1b4412b364a4614c015c995767e2" translate="yes" xml:space="preserve">
          <source>The event binding listens for the button's click events and calls the component's &lt;code&gt;onSave()&lt;/code&gt; method whenever a click occurs.</source>
          <target state="translated">이벤트 바인딩은 버튼의 클릭 이벤트를 수신 하고 클릭이 발생할 때마다 구성 요소의 &lt;code&gt;onSave()&lt;/code&gt; 메서드를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="69ff142aa61a33181c0a1759ca603b78c8f65052" translate="yes" xml:space="preserve">
          <source>The event binding to the textbox's &lt;code&gt;input&lt;/code&gt; event calls the &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/%24locationshim#search&quot;&gt;search()&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="translated">텍스트 상자의 &lt;code&gt;input&lt;/code&gt; 이벤트에 대한 이벤트 바인딩 은 &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/%24locationshim#search&quot;&gt;search()&lt;/a&gt;&lt;/code&gt; 메서드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="6ed6e9ce266d18a90fadd7e10b03d03c8dbd92d9" translate="yes" xml:space="preserve">
          <source>The event binding to the textbox's &lt;code&gt;input&lt;/code&gt; event calls the &lt;code&gt;search()&lt;/code&gt; method.</source>
          <target state="translated">텍스트 상자의 &lt;code&gt;input&lt;/code&gt; 이벤트에 대한 이벤트 바인딩 은 &lt;code&gt;search()&lt;/code&gt; 메서드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="6b1b6fe126f9ca22b76040da84e54d75ff818550" translate="yes" xml:space="preserve">
          <source>The event binding, &lt;code&gt;(newItemEvent)='addItem($event)'&lt;/code&gt;, connects the event in the child, &lt;code&gt;newItemEvent&lt;/code&gt;, to the method in the parent, &lt;code&gt;addItem()&lt;/code&gt;.</source>
          <target state="translated">이벤트 바인딩 &lt;code&gt;(newItemEvent)='addItem($event)'&lt;/code&gt; 는 자식 이벤트 &lt;code&gt;newItemEvent&lt;/code&gt; 를 부모 &lt;code&gt;addItem()&lt;/code&gt; 메서드에 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="3639fbd6435142847d3144a74c6667bfa653654c" translate="yes" xml:space="preserve">
          <source>The event binding, &lt;code&gt;(newItemEvent)='addItem($event)'&lt;/code&gt;, tells Angular to connect the event in the child, &lt;code&gt;newItemEvent&lt;/code&gt;, to the method in the parent, &lt;code&gt;addItem()&lt;/code&gt;, and that the event that the child is notifying the parent about is to be the argument of &lt;code&gt;addItem()&lt;/code&gt;. In other words, this is where the actual hand off of data takes place. The &lt;code&gt;$event&lt;/code&gt; contains the data that the user types into the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; in the child template UI.</source>
          <target state="translated">이벤트 바인딩 &lt;code&gt;(newItemEvent)='addItem($event)'&lt;/code&gt; 은 Angular에게 자식 &lt;code&gt;newItemEvent&lt;/code&gt; 의 이벤트를 부모 &lt;code&gt;addItem()&lt;/code&gt; 의 메소드에 연결 하고 자식이 부모에게 알리는 이벤트를 연결하도록 지시 합니다. about은 &lt;code&gt;addItem()&lt;/code&gt; 의 인수입니다 . 즉, 실제 데이터 전달이 이루어지는 곳입니다. &lt;code&gt;$event&lt;/code&gt; 데이터를 포함하는 것을에 사용자 유형 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 아이 템플릿 UI이다.</target>
        </trans-unit>
        <trans-unit id="ad8b492b040130403394a8b8405002e8fbe05184" translate="yes" xml:space="preserve">
          <source>The event name for control to update upon.</source>
          <target state="translated">컨트롤을 업데이트 할 이벤트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f4f20723f533d5e629777325cd0a3634e4a127e2" translate="yes" xml:space="preserve">
          <source>The event to listen for.</source>
          <target state="translated">들을 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="91ef2a7a591ac9092eaa2b69ce5e271726e45b75" translate="yes" xml:space="preserve">
          <source>The events occur in the following sequence:</source>
          <target state="translated">이벤트는 다음 순서로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="54c1184dacbaa43055ccffb47a5d3e22a00bb1c7" translate="yes" xml:space="preserve">
          <source>The exact values of these attributes aren't important. They are automatically generated and you never refer to them in application code. But they are targeted by the generated component styles, which are in the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; section of the DOM:</source>
          <target state="translated">이러한 속성의 정확한 값은 중요하지 않습니다. 그것들은 자동으로 생성되며 응용 프로그램 코드에서 절대 참조하지 않습니다. 그러나 DOM 의 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 섹션 에있는 생성 된 컴포넌트 스타일을 대상으로합니다 .</target>
        </trans-unit>
        <trans-unit id="4b7a62544532a45cb6e60791b758a5ec3dddf356" translate="yes" xml:space="preserve">
          <source>The example above casts the &lt;code&gt;$event&lt;/code&gt; as an &lt;code&gt;any&lt;/code&gt; type. That simplifies the code at a cost. There is no type information that could reveal properties of the event object and prevent silly mistakes.</source>
          <target state="translated">위의 예는 &lt;code&gt;$event&lt;/code&gt; 를 &lt;code&gt;any&lt;/code&gt; 유형 으로 캐스트합니다 . 이는 비용을 들여 코드를 단순화합니다. 이벤트 객체의 속성을 표시하고 어리석은 실수를 방지 할 수있는 유형 정보가 없습니다.</target>
        </trans-unit>
        <trans-unit id="273eb5d9b6efb1eb7fc204e5b2fd8c9a9f9a424d" translate="yes" xml:space="preserve">
          <source>The example above shows the preferred way to provide a service in a module. This method is preferred because it enables tree-shaking of the service if nothing injects it. If it's not possible to specify in the service which module should provide it, you can also declare a provider for the service within the module:</source>
          <target state="translated">위의 예는 모듈에서 서비스를 제공하는 기본 방법을 보여줍니다. 이 방법은 아무 것도 주입하지 않으면 서비스의 트리 쉐이킹을 가능하게하기 때문에 선호됩니다. 어떤 모듈이 어떤 모듈을 제공해야하는지 서비스에서 지정할 수 없다면, 모듈 내에서 서비스 제공자를 선언 할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="b2e27e8c2c92276e05378262ff057e11c8b22f08" translate="yes" xml:space="preserve">
          <source>The example added a &lt;code&gt;name&lt;/code&gt; attribute to the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element and set it to &quot;name&quot;, which makes sense for the hero's name. Any unique value will do, but using a descriptive name is helpful.</source>
          <target state="translated">이 예제 에서는 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 요소에 &lt;code&gt;name&lt;/code&gt; 속성을 추가 하고 영웅의 이름에 적합한 &quot;name&quot;으로 설정했습니다. 모든 고유 값이 가능하지만 설명이 포함 된 이름을 사용하는 것이 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="effbc7d2c80d5854e16babc4c844f954f764345c" translate="yes" xml:space="preserve">
          <source>The example app features a second service, the &lt;code&gt;AnimalService&lt;/code&gt; to demonstrate &lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">예제 앱에는 &lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt; 를 보여주는 두 번째 서비스 인 &lt;code&gt;AnimalService&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c78f64c7b89201f40e03d1b69154355e19de092e" translate="yes" xml:space="preserve">
          <source>The example app features a second service, the &lt;code&gt;AnimalService&lt;/code&gt; to demonstrate &lt;code&gt;viewProviders&lt;/code&gt;.</source>
          <target state="translated">예제 앱에는 &lt;code&gt;viewProviders&lt;/code&gt; 를 보여주는 두 번째 서비스 인 &lt;code&gt;AnimalService&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d59f9bd8904b6d345e194680af23a795fc7a0b5" translate="yes" xml:space="preserve">
          <source>The example app has a &lt;code&gt;FlowerService&lt;/code&gt; provided in &lt;code&gt;root&lt;/code&gt; with an &lt;code&gt;emoji&lt;/code&gt; value of &lt;code&gt;🌺&lt;/code&gt; (red hibiscus).</source>
          <target state="translated">예시적인 애플리케이션은 보유 &lt;code&gt;FlowerService&lt;/code&gt; 에 설치된 &lt;code&gt;root&lt;/code&gt; 와 &lt;code&gt;emoji&lt;/code&gt; 의 값 &lt;code&gt;🌺&lt;/code&gt; (적색 히비스커스).</target>
        </trans-unit>
        <trans-unit id="7e293a7ac30ffcbf40d0aa732b70cb22ea0ae688" translate="yes" xml:space="preserve">
          <source>The example below shows how to use a &lt;code&gt;plural&lt;/code&gt; ICU expression to display one of those three options based on when the update occurred:</source>
          <target state="translated">아래 예제는 &lt;code&gt;plural&lt;/code&gt; ICU 표현식 을 사용 하여 업데이트 발생시기를 기준으로 이러한 세 가지 옵션 중 하나를 표시 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="32f43e0dcae0b20b112d1f2cf6afab0db54ce258" translate="yes" xml:space="preserve">
          <source>The example catches errors as &lt;a href=&quot;http#error-details&quot;&gt;described above&lt;/a&gt;.</source>
          <target state="translated">이 예제 &lt;a href=&quot;http#error-details&quot;&gt;는 위에서 설명한대로&lt;/a&gt; 오류를 포착합니다 .</target>
        </trans-unit>
        <trans-unit id="fd77271eb13f69fabbed387e0cde0a99c8b25dd3" translate="yes" xml:space="preserve">
          <source>The example component, &lt;code&gt;OnChangesComponent&lt;/code&gt;, has two input properties: &lt;code&gt;hero&lt;/code&gt; and &lt;code&gt;power&lt;/code&gt;.</source>
          <target state="translated">예제 구성 요소 인 &lt;code&gt;OnChangesComponent&lt;/code&gt; 에는 &lt;code&gt;hero&lt;/code&gt; 및 &lt;code&gt;power&lt;/code&gt; 의 두 가지 입력 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9155530069679df1e8e17804347a08779c0b88f" translate="yes" xml:space="preserve">
          <source>The example conforms to the best practices for creating scalable solutions by defining a re-usable &lt;a href=&quot;glossary#service&quot;&gt;injectable service&lt;/a&gt; to perform the data-handling functionality. In addition to fetching data, the service can post-process the data, add error handling, and add retry logic.</source>
          <target state="translated">이 예제 는 데이터 처리 기능을 수행하기 위해 재사용 가능한 &lt;a href=&quot;glossary#service&quot;&gt;주입 가능 서비스&lt;/a&gt; 를 정의하여 확장 가능한 솔루션을 만드는 모범 사례를 따릅니다 . 데이터를 가져 오는 것 외에도 서비스는 데이터를 사후 처리하고, 오류 처리를 추가하고, 재시도 논리를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5ae9273f0a2796a26e3fdc2b5495b83160ccdd7" translate="yes" xml:space="preserve">
          <source>The example defines a &lt;code&gt;Parent&lt;/code&gt; class interface.</source>
          <target state="translated">이 예제는 &lt;code&gt;Parent&lt;/code&gt; 클래스 인터페이스 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="78dfaeee725082d98ba4c1ba36ee3d43f4320105" translate="yes" xml:space="preserve">
          <source>The example does not perform any initialization or clean-up. It just tracks the appearance and disappearance of an element in the view by recording when the directive itself is instantiated and destroyed.</source>
          <target state="translated">이 예제는 초기화 또는 정리를 수행하지 않습니다. 지시어 자체가 인스턴스화되고 소멸되는시기를 기록하여 뷰에서 요소의 모양과 사라짐을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="b1a19339f0623e57becdf428e24d9054631f017e" translate="yes" xml:space="preserve">
          <source>The example in this cookbook is a dynamic form to build an online application experience for heroes seeking employment. The agency is constantly tinkering with the application process. You can create the forms on the fly &lt;em&gt;without changing the application code&lt;/em&gt;.</source>
          <target state="translated">이 요리 책의 예는 고용을 원하는 영웅들을위한 온라인 응용 프로그램 경험을 구축하기위한 역동적 인 형태입니다. 에이전시는 신청 절차를 끊임없이 고민하고 있습니다. &lt;em&gt;응용 프로그램 코드를 변경하지 않고도&lt;/em&gt; 양식을 즉석에서 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21368d5aa0e0f57cc1e8629018f6a96fc88d7046" translate="yes" xml:space="preserve">
          <source>The example provides a model for a job application for heroes, but there are no references to any specific hero question other than the objects returned by &lt;code&gt;QuestionService&lt;/code&gt;. This separation of model and data allows you to repurpose the components for any type of survey as long as it's compatible with the &lt;em&gt;question&lt;/em&gt; object model.</source>
          <target state="translated">이 예제는 Hero에 대한 작업 응용 프로그램에 대한 모델을 제공하지만 &lt;code&gt;QuestionService&lt;/code&gt; 에서 반환 된 개체 이외의 특정 영웅 질문에 대한 참조는 없습니다 . 이러한 모델과 데이터의 분리를 통해 &lt;em&gt;질문&lt;/em&gt; 개체 모델 과 호환되는 한 모든 유형의 설문 조사에 대한 구성 요소의 용도를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fda3065caba1d5eb2c8f5fe0c2d8e9d5653e9812" translate="yes" xml:space="preserve">
          <source>The examples use cross-validation to ensure that heroes do not reveal their true identities by filling out the Hero Form. The validators do this by checking that the hero names and alter egos do not match.</source>
          <target state="translated">예제는 교차 검증을 사용하여 영웅이 영웅 양식을 작성하여 자신의 진정한 신원을 드러내지 않도록합니다. 검증 인은 영웅 이름과 분신이 일치하지 않는지 확인하여이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="6bc3566154c29af35184ae0bd0cc18f2f2008688" translate="yes" xml:space="preserve">
          <source>The existing &lt;code&gt;AuthGuard&lt;/code&gt; already has the essential logic in its &lt;code&gt;checkLogin()&lt;/code&gt; method to support the &lt;code&gt;&lt;a href=&quot;../api/router/canload&quot;&gt;CanLoad&lt;/a&gt;&lt;/code&gt; guard.</source>
          <target state="translated">기존 &lt;code&gt;AuthGuard&lt;/code&gt; 에는 이미 &lt;code&gt;checkLogin()&lt;/code&gt; 메소드에 &lt;code&gt;&lt;a href=&quot;../api/router/canload&quot;&gt;CanLoad&lt;/a&gt;&lt;/code&gt; 가드 를 지원하는 필수 로직이 있습니다.</target>
        </trans-unit>
        <trans-unit id="718c865b634d55ae8dfe4de1b660b49d34f475af" translate="yes" xml:space="preserve">
          <source>The existing AngularJS code works as before &lt;em&gt;and&lt;/em&gt; you are ready to start adding Angular code.</source>
          <target state="translated">기존 AngularJS 코드는 이전 &lt;em&gt;과&lt;/em&gt; 같이 작동하며 Angular 코드 추가를 시작할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="ab13d61d6ddb887413912e2f62c6e3e7fc4aac41" translate="yes" xml:space="preserve">
          <source>The existing child node before which &lt;code&gt;newChild&lt;/code&gt; is inserted.</source>
          <target state="translated">&lt;code&gt;newChild&lt;/code&gt; 가 삽입 되기 전에 기존 자식 노드 입니다.</target>
        </trans-unit>
        <trans-unit id="f5fd876d33ea042d6b4add9cc8574eee41bd22c4" translate="yes" xml:space="preserve">
          <source>The existing child node that should precede the new node.</source>
          <target state="translated">새 노드 앞에 있어야하는 기존 자식 노드</target>
        </trans-unit>
        <trans-unit id="d872770ece0f419b22a9305fbf0ce1956dbee659" translate="yes" xml:space="preserve">
          <source>The expanded provider configuration is an object literal with two properties.</source>
          <target state="translated">확장 된 제공자 구성은 두 가지 특성이있는 오브젝트 리터럴입니다.</target>
        </trans-unit>
        <trans-unit id="0a901e7e7f6e2f5a9cf69a27df265c2237d91887" translate="yes" xml:space="preserve">
          <source>The expected response type of the server.</source>
          <target state="translated">서버의 예상 응답 유형입니다.</target>
        </trans-unit>
        <trans-unit id="756b02a42955f8fd84e0875c967bff67e4bc2260" translate="yes" xml:space="preserve">
          <source>The experience might be better if all of this were handled first, before the route is activated. A &lt;code&gt;CrisisDetailResolver&lt;/code&gt; service could retrieve a &lt;code&gt;Crisis&lt;/code&gt; or navigate away if the &lt;code&gt;Crisis&lt;/code&gt; does not exist &lt;em&gt;before&lt;/em&gt; activating the route and creating the &lt;code&gt;CrisisDetailComponent&lt;/code&gt;.</source>
          <target state="translated">경로가 활성화되기 전에이 모든 것을 먼저 처리하면 경험이 더 나을 수 있습니다. &lt;code&gt;CrisisDetailResolver&lt;/code&gt; 의 서비스는 검색 할 수있는 &lt;code&gt;Crisis&lt;/code&gt; 하거나 경우에 멀리 이동 &lt;code&gt;Crisis&lt;/code&gt; 존재하지 않는 &lt;em&gt;전에&lt;/em&gt; 경로를 활성화하고 만드는 &lt;code&gt;CrisisDetailComponent&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="231b4a30ec02743f59b6dc1ae1cd48da208d12aa" translate="yes" xml:space="preserve">
          <source>The experience might be better if all of this were handled first, before the route is activated. A &lt;code&gt;CrisisDetailResolver&lt;/code&gt; service could retrieve a &lt;code&gt;Crisis&lt;/code&gt; or navigate away, if the &lt;code&gt;Crisis&lt;/code&gt; did not exist, &lt;em&gt;before&lt;/em&gt; activating the route and creating the &lt;code&gt;CrisisDetailComponent&lt;/code&gt;.</source>
          <target state="translated">경로가 활성화되기 전에이 모든 것이 먼저 처리되면 경험이 더 좋을 수 있습니다. &lt;code&gt;CrisisDetailResolver&lt;/code&gt; 의 서비스는 검색 할 수있는 &lt;code&gt;Crisis&lt;/code&gt; 경우, 또는 멀리 이동 &lt;code&gt;Crisis&lt;/code&gt; 존재하지 않았다 &lt;em&gt;전에&lt;/em&gt; 경로를 활성화하고 만드는 &lt;code&gt;CrisisDetailComponent&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="d0105ecd0834a0a52efb835dd0c06c79018cfc2a" translate="yes" xml:space="preserve">
          <source>The expression can invoke methods of the host component such as &lt;code&gt;getVal()&lt;/code&gt; in the following example:</source>
          <target state="translated">표현식은 다음 예제에서 &lt;code&gt;getVal()&lt;/code&gt; 과 같은 호스트 구성 요소의 메소드를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc38af0a3f6b603a4f52ccb0dc5abcee023d78a0" translate="yes" xml:space="preserve">
          <source>The expression string can contain multiple comma-separated statements; for example &quot;state1 =&amp;gt; state2, state3 =&amp;gt; state4&quot;.</source>
          <target state="translated">표현식 문자열은 여러 개의 쉼표로 구분 된 명령문을 포함 할 수 있습니다. 예를 들어 &quot;state1 =&amp;gt; state2, state3 =&amp;gt; state4&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="a13861ade07df9e378c5d3fa8b540dff690597ea" translate="yes" xml:space="preserve">
          <source>The expression used in an &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; directive is used to narrow type unions in the Angular template compiler, the same way the &lt;code&gt;if&lt;/code&gt; expression does in TypeScript. For example, to avoid &lt;code&gt;Object is possibly 'undefined'&lt;/code&gt; error in the template above, modify it to only emit the interpolation if the value of &lt;code&gt;person&lt;/code&gt; is initialized as shown below:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 지시문에 사용 된 표현식은 AngScript 템플릿 컴파일러에서 유형 통합을 좁히는 데 사용되며 &lt;code&gt;if&lt;/code&gt; 표현식이 TypeScript에서 와 같은 방식으로 사용 됩니다 . 예를 들어 위 템플릿에서 &lt;code&gt;Object is possibly 'undefined'&lt;/code&gt; 오류 를 피하려면 &lt;code&gt;person&lt;/code&gt; 의 값이 아래와 같이 초기화 된 경우에만 보간을 내도록 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef8c01f4c0d7e68b89c220ac9f8c5253404cce00" translate="yes" xml:space="preserve">
          <source>The external typings for AngularJS may be uninstalled as well. The only ones you still need are for Jasmine and Angular polyfills. The &lt;code&gt;@angular/upgrade&lt;/code&gt; package and its mapping in &lt;code&gt;systemjs.config.js&lt;/code&gt; can also go.</source>
          <target state="translated">AngularJS의 외부 입력도 제거 할 수 있습니다. 여전히 필요한 유일한 것은 Jasmine 및 Angular 폴리 필입니다. &lt;code&gt;@angular/upgrade&lt;/code&gt; 패키지에서의 매핑 &lt;code&gt;systemjs.config.js&lt;/code&gt; 는 도 갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9487dc824b5a06931326438975b3fa897554272" translate="yes" xml:space="preserve">
          <source>The extraction tool broke that into two translation units because ICU expressions are extracted separately.</source>
          <target state="translated">추출 도구는 ICU 표현식이 개별적으로 추출되므로이를 두 개의 변환 단위로 나 bro습니다.</target>
        </trans-unit>
        <trans-unit id="9417ff966974590689ce184e11dd80a18dd2fcc6" translate="yes" xml:space="preserve">
          <source>The extraction tool uses the locale to add the app locale information into your translation source file. This information is not used by Angular, but external translation tools may need it.</source>
          <target state="translated">추출 도구는 로캘을 사용하여 앱 로캘 정보를 번역 소스 파일에 추가합니다. 이 정보는 Angular에서 사용되지 않지만 외부 번역 도구에 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85f84c0e0492c512641e357031e4b8a990681047" translate="yes" xml:space="preserve">
          <source>The factory function used to create an instance of the &lt;code&gt;&lt;a href=&quot;%24locationshim&quot;&gt;$locationShim&lt;/a&gt;&lt;/code&gt; in Angular, and provides an API-compatiable &lt;code&gt;$locationProvider&lt;/code&gt; for AngularJS.</source>
          <target state="translated">팩토리 함수 는 Angular 에서 &lt;code&gt;&lt;a href=&quot;%24locationshim&quot;&gt;$locationShim&lt;/a&gt;&lt;/code&gt; 의 인스턴스를 작성하는 데 사용되며 AngularJS에 API 호환 가능 &lt;code&gt;$locationProvider&lt;/code&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="b0b48f7c53cdcc9a28c5b33f627658903f534c56" translate="yes" xml:space="preserve">
          <source>The factory function used to create an instance of the &lt;code&gt;&lt;a href=&quot;upgrade/%24locationshim&quot;&gt;$locationShim&lt;/a&gt;&lt;/code&gt; in Angular, and provides an API-compatiable &lt;code&gt;$locationProvider&lt;/code&gt; for AngularJS.</source>
          <target state="translated">팩토리 함수 는 Angular 에서 &lt;code&gt;&lt;a href=&quot;upgrade/%24locationshim&quot;&gt;$locationShim&lt;/a&gt;&lt;/code&gt; 의 인스턴스를 작성하는 데 사용되며 AngularJS에 API 호환 가능 &lt;code&gt;$locationProvider&lt;/code&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="fff2a09918a1b2d112204afd22582dc9b903d3db" translate="yes" xml:space="preserve">
          <source>The factory to use.</source>
          <target state="translated">사용할 공장.</target>
        </trans-unit>
        <trans-unit id="45110d699eb402accd2b39408cf613ccace142aa" translate="yes" xml:space="preserve">
          <source>The feature module has its own routing module, &lt;code&gt;customers-routing.module.ts&lt;/code&gt;. The &lt;code&gt;AppRoutingModule&lt;/code&gt; imports the feature module, &lt;code&gt;CustomersModule&lt;/code&gt;, and &lt;code&gt;CustomersModule&lt;/code&gt; in turn imports the &lt;code&gt;CustomersRoutingModule&lt;/code&gt;.</source>
          <target state="translated">기능 모듈에는 자체 라우팅 모듈 &lt;code&gt;customers-routing.module.ts&lt;/code&gt; 가 있습니다. &lt;code&gt;AppRoutingModule&lt;/code&gt; 의 수입 기능 모듈, &lt;code&gt;CustomersModule&lt;/code&gt; 및 &lt;code&gt;CustomersModule&lt;/code&gt; 차례 수입의 &lt;code&gt;CustomersRoutingModule&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c68df8d13f8a11bcd08a42b67de607bb1fe78496" translate="yes" xml:space="preserve">
          <source>The feature-specific route definition file &lt;code&gt;customers-routing.module.ts&lt;/code&gt; imports its own feature component defined in the &lt;code&gt;customers.component.ts&lt;/code&gt; file, along with the other JavaScript import statements. It then maps the empty path to the &lt;code&gt;CustomersComponent&lt;/code&gt;.</source>
          <target state="translated">기능별 경로 정의 파일 &lt;code&gt;customers-routing.module.ts&lt;/code&gt; 는 다른 JavaScript 가져 오기 문과 함께 &lt;code&gt;customers.component.ts&lt;/code&gt; 파일에 정의 된 고유 한 기능 구성 요소를 가져옵니다. 그런 다음 빈 경로를 &lt;code&gt;CustomersComponent&lt;/code&gt; 에 매핑합니다 .</target>
        </trans-unit>
        <trans-unit id="6957954dfc17f6637256e21496069d6d7edfa00a" translate="yes" xml:space="preserve">
          <source>The feature-specific routing module imports its own feature component, &lt;code&gt;CustomerListComponent&lt;/code&gt;, along with the other JavaScript import statements. It also adds the route to its own component.</source>
          <target state="translated">기능별 라우팅 모듈 은 다른 JavaScript 가져 오기 명령문과 함께 자체 기능 구성 요소 &lt;code&gt;CustomerListComponent&lt;/code&gt; 를 가져옵니다. 또한 자체 구성 요소에 경로를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b6679a077d80a4fae996b201686c099a780913b7" translate="yes" xml:space="preserve">
          <source>The features described in this guide &amp;mdash; and the more advanced features described in the related Angular animations guides &amp;mdash; are demonstrated in an example app available as a live example.</source>
          <target state="translated">이 안내서에 설명 된 기능과 관련 Angular 애니메이션 안내서에 설명 된 고급 기능은 실제 예제로 제공되는 예제 앱에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5d913855a2f92d2ad9226bb9153c9058915ef08a" translate="yes" xml:space="preserve">
          <source>The fields given in the schema correspond to the allowed argument values and defaults for the CLI sub-command options. You can update your workspace schema file to set a different default for a sub-command option.</source>
          <target state="translated">스키마에 제공된 필드는 CLI 부속 명령 옵션에 허용되는 인수 값 및 기본값에 해당합니다. 하위 명령 옵션에 다른 기본값을 설정하도록 작업 공간 스키마 파일을 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e46781c8a8accd7cee0f511396c96eb0f907cd9" translate="yes" xml:space="preserve">
          <source>The file extension or preprocessor to use for style files.</source>
          <target state="translated">스타일 파일에 사용할 파일 확장자 또는 전 처리기입니다.</target>
        </trans-unit>
        <trans-unit id="4df1821dbd4788e87e9499318c4ec670cf47f860" translate="yes" xml:space="preserve">
          <source>The file extension to use for style files.</source>
          <target state="translated">스타일 파일에 사용할 파일 확장자입니다.</target>
        </trans-unit>
        <trans-unit id="6406bc3d893f537b5bde48e17108b2279f261462" translate="yes" xml:space="preserve">
          <source>The file name reported in the error message, &lt;code&gt;my.component.ts.MyComponent.html&lt;/code&gt;, is a synthetic file generated by the template compiler that holds contents of the &lt;code&gt;MyComponent&lt;/code&gt; class template. The compiler never writes this file to disk. The line and column numbers are relative to the template string in the &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; annotation of the class, &lt;code&gt;MyComponent&lt;/code&gt; in this case. If a component uses &lt;code&gt;templateUrl&lt;/code&gt; instead of &lt;code&gt;template&lt;/code&gt;, the errors are reported in the HTML file referenced by the &lt;code&gt;templateUrl&lt;/code&gt; instead of a synthetic file.</source>
          <target state="translated">오류 메시지 &lt;code&gt;my.component.ts.MyComponent.html&lt;/code&gt; 에보 고 된 파일 이름 은 &lt;code&gt;MyComponent&lt;/code&gt; 클래스 템플리트의 컨텐츠를 보유하는 템플리트 컴파일러에 의해 생성 된 합성 파일 입니다. 컴파일러는이 파일을 디스크에 쓰지 않습니다. 줄 번호와 열 번호는 이 경우 &lt;code&gt;MyComponent&lt;/code&gt; 클래스 의 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; 주석에있는 템플리트 문자열 과 관련이 있습니다. 구성 요소가 사용하는 경우 &lt;code&gt;templateUrl&lt;/code&gt; 을 대신 &lt;code&gt;template&lt;/code&gt; , 오류는이 참조하는 HTML 파일에보고 &lt;code&gt;templateUrl&lt;/code&gt; 대신 합성 파일.</target>
        </trans-unit>
        <trans-unit id="dc59a059fa420961f9dd7f4d741b5a2264a08f45" translate="yes" xml:space="preserve">
          <source>The files in &lt;code&gt;@angular/common/locales&lt;/code&gt; contain most of the locale data that you need, but some advanced formatting options might only be available in the extra dataset that you can import from &lt;code&gt;@angular/common/locales/extra&lt;/code&gt;. An error message informs you when this is the case.</source>
          <target state="translated">&lt;code&gt;@angular/common/locales&lt;/code&gt; 의 파일 에는 필요한 대부분의 로케일 데이터가 포함되어 있지만 &lt;code&gt;@angular/common/locales/extra&lt;/code&gt; 에서 가져올 수있는 추가 데이터 세트에서만 일부 고급 형식화 옵션을 사용할 수 있습니다 . 이 경우 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cc5da9fb73116aefd1be69567f1edca5171f0c86" translate="yes" xml:space="preserve">
          <source>The files in the &lt;code&gt;dist/my-project-name&lt;/code&gt; folder are static and can be hosted on any web server capable of serving files (&lt;code&gt;Node.js&lt;/code&gt;, Java, .NET) or any backend (Firebase, Google Cloud, App Engine, others).</source>
          <target state="translated">의 파일 &lt;code&gt;dist/my-project-name&lt;/code&gt; 정적 파일 (제공 할 수있는 모든 웹 서버에서 호스팅 할 수 폴더 &lt;code&gt;Node.js&lt;/code&gt; 를 , 자바, .NET) 또는 백엔드 (중포 기지, Google 클라우드, 앱 엔진, 기타) .</target>
        </trans-unit>
        <trans-unit id="cfd2525e778d44ca48268a14e2d4009355f67534" translate="yes" xml:space="preserve">
          <source>The files in the &lt;code&gt;dist/my-project-name&lt;/code&gt; folder are static. This means you can host them on any web server capable of serving files (such as &lt;code&gt;Node.js&lt;/code&gt;, Java, .NET), or any backend (such as Firebase, Google Cloud, or App Engine).</source>
          <target state="translated">의 파일 &lt;code&gt;dist/my-project-name&lt;/code&gt; 폴더 정적이다. 즉 , 파일을 제공 할 수있는 모든 웹 서버 (예 : &lt;code&gt;Node.js&lt;/code&gt; , Java, .NET) 또는 모든 백엔드 (예 : Firebase, Google Cloud 또는 App Engine) 에서 호스팅 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fef6eeb99c812c89811914cb86075f88c7c8f8c4" translate="yes" xml:space="preserve">
          <source>The files marked with &lt;code&gt;*&lt;/code&gt; are new and not in the original tutorial sample.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 로 표시된 파일 은 새로운 것으로 원본 튜토리얼 샘플에는 없습니다.</target>
        </trans-unit>
        <trans-unit id="4958ad54ba499fda7072a0286fdc85fb538ec9d8" translate="yes" xml:space="preserve">
          <source>The filter works in real time as you type. Elements leave the page as you type each new letter and the filter gets progressively stricter. The heroes list gradually re-enters the page as you delete each letter in the filter box.</source>
          <target state="translated">입력하는 동안 필터가 실시간으로 작동합니다. 새 문자를 입력 할 때 요소가 페이지를 떠나고 필터가 점차 엄격 해집니다. 필터 상자에서 각 문자를 삭제하면 영웅 목록이 점차적으로 페이지에 다시 입력됩니다.</target>
        </trans-unit>
        <trans-unit id="f573bd26d52dc028307ae3e04564422e663eec0d" translate="yes" xml:space="preserve">
          <source>The final UI looks like this:</source>
          <target state="translated">최종 UI는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5b275336e85842a3e2bdbdc55d315d60de9615b" translate="yes" xml:space="preserve">
          <source>The final ad banner looks like this:</source>
          <target state="translated">최종 광고 배너는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="321d2b68064070be07256e2a5abc3418d809f653" translate="yes" xml:space="preserve">
          <source>The final form looks like this:</source>
          <target state="translated">최종 양식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="041dc8a5f34133da31fcc036e9813dc9a7c7dd5c" translate="yes" xml:space="preserve">
          <source>The final source code follows:</source>
          <target state="translated">최종 소스 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4efdfc25a6effd16bf1e38707887ca8fdb33714e" translate="yes" xml:space="preserve">
          <source>The finished &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; looks like this:</source>
          <target state="translated">완성 된 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 는 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="56cb402b12029a303e5d291a33be2607644acc0c" translate="yes" xml:space="preserve">
          <source>The first argument is the controller name. The second argument defines the string names of all dependencies injected into this controller, and a reference to the controller function.</source>
          <target state="translated">첫 번째 인수는 컨트롤러 이름입니다. 두 번째 인수는이 컨트롤러에 주입 된 모든 종속성의 문자열 이름과 컨트롤러 함수에 대한 참조를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f9457d5b3e7c5601a8125917a5c64688ac0a8255" translate="yes" xml:space="preserve">
          <source>The first bundle contains modern ES2015 syntax, takes advantage of built-in support in modern browsers, ships less polyfills, and results in a smaller bundle size.</source>
          <target state="translated">첫 번째 번들에는 최신 ES2015 구문이 포함되어 있으며 최신 브라우저에서 기본적으로 지원되며, 폴리 필이 적고 번들 크기가 더 작습니다.</target>
        </trans-unit>
        <trans-unit id="95633f9df24fc0ecf3fe00fc31e5e62805addea1" translate="yes" xml:space="preserve">
          <source>The first bundle contains modern ES2015 syntax. This bundle takes advantage of built-in support in modern browsers, ships fewer polyfills, and results in a smaller bundle size.</source>
          <target state="translated">첫 번째 번들에는 최신 ES2015 구문이 포함되어 있습니다. 이 번들은 최신 브라우저의 기본 제공 지원을 활용하고 더 적은 폴리 필을 제공하므로 번들 크기가 더 작아집니다.</target>
        </trans-unit>
        <trans-unit id="7f4b8a42566c14174c062c29a822d5296acfbeec" translate="yes" xml:space="preserve">
          <source>The first child of this route in the router state tree</source>
          <target state="translated">라우터 상태 트리에서이 경로의 첫 번째 자식</target>
        </trans-unit>
        <trans-unit id="0cf5b8a30d51a55deb1ed42e3408e1848f44035a" translate="yes" xml:space="preserve">
          <source>The first child of this route in the router state tree.</source>
          <target state="translated">라우터 상태 트리에서이 경로의 첫 번째 자식입니다.</target>
        </trans-unit>
        <trans-unit id="cbbf9616cd583ee698811321ffe898de8bb5be2c" translate="yes" xml:space="preserve">
          <source>The first configuration defines an array of two routes with minimal paths leading to the &lt;code&gt;CrisisListComponent&lt;/code&gt; and &lt;code&gt;HeroListComponent&lt;/code&gt;.</source>
          <target state="translated">첫 번째 구성은 &lt;code&gt;CrisisListComponent&lt;/code&gt; 및 &lt;code&gt;HeroListComponent&lt;/code&gt; 로 연결되는 최소 경로를 사용하여 두 경로의 배열을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="90ce335c264ff739546ba0f108b7867bf473ab4e" translate="yes" xml:space="preserve">
          <source>The first configuration defines an array of two routes with simple paths leading to the &lt;code&gt;CrisisListComponent&lt;/code&gt; and &lt;code&gt;HeroListComponent&lt;/code&gt;. Generate the &lt;code&gt;CrisisList&lt;/code&gt; and &lt;code&gt;HeroList&lt;/code&gt; components.</source>
          <target state="translated">첫 번째 구성은 &lt;code&gt;CrisisListComponent&lt;/code&gt; 및 &lt;code&gt;HeroListComponent&lt;/code&gt; 로 연결되는 간단한 경로를 가진 두 경로의 배열을 정의합니다 . &lt;code&gt;CrisisList&lt;/code&gt; 및 &lt;code&gt;HeroList&lt;/code&gt; 구성 요소를 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc5ab8411a999f00314640e534a4f07a7e314733" translate="yes" xml:space="preserve">
          <source>The first entry is for a schematic named &lt;code&gt;ng-add&lt;/code&gt;. It contains the description, and points to the factory function that is called when your schematic is executed.</source>
          <target state="translated">첫 번째 항목은 &lt;code&gt;ng-add&lt;/code&gt; 회로도 입니다. 여기에는 설명이 포함되며 회로도를 실행할 때 호출되는 팩토리 기능을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="86c941d39038cbf4e554b9137f55a474253a3b56" translate="yes" xml:space="preserve">
          <source>The first example performs the following steps to verify the view-to-model data flow.</source>
          <target state="translated">첫 번째 예에서는 다음 단계를 수행하여 뷰-모델 데이터 흐름을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f7c494230675324afd6a402aadf921b3773a5f5c" translate="yes" xml:space="preserve">
          <source>The first explicitly generated application goes into the &lt;code&gt;projects/&lt;/code&gt; folder along with all other projects in the workspace. Newly generated libraries are also added under &lt;code&gt;projects/&lt;/code&gt;. When you create projects this way, the file structure of the workspace is entirely consistent with the structure of the &lt;a href=&quot;workspace-config&quot;&gt;workspace configuration file&lt;/a&gt;, &lt;code&gt;angular.json&lt;/code&gt;.</source>
          <target state="translated">명시 적으로 생성 된 첫 번째 애플리케이션은 작업 공간의 다른 모든 프로젝트와 함께 &lt;code&gt;projects/&lt;/code&gt; 폴더로 이동합니다. 새로 생성 된 라이브러리도 &lt;code&gt;projects/&lt;/code&gt; 아래에 추가됩니다 . 이 방법을 프로젝트를 만들 때, 작업 공간의 파일 구조의 구조와 완전히 일치 &lt;a href=&quot;workspace-config&quot;&gt;작업 공간 구성 파일&lt;/a&gt; , &lt;code&gt;angular.json&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5daa0866ecdb0176ba5151f4125dd5f05620ba13" translate="yes" xml:space="preserve">
          <source>The first form is not actually rendered, only the finished product ends up in the DOM.</source>
          <target state="translated">첫 번째 양식은 실제로 렌더링되지 않으며 완성 된 제품 만 DOM에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4f7f9d4b304e201ea1705223665d4d800899a939" translate="yes" xml:space="preserve">
          <source>The first injector configured with a provider supplies the dependency (a service instance or value) to the constructor.</source>
          <target state="translated">공급자로 구성된 첫 번째 인젝터는 종속성 (서비스 인스턴스 또는 값)을 생성자에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="78ec94cfb431864b60956eb8b8ac569aa3b4907a" translate="yes" xml:space="preserve">
          <source>The first is a sanity test; it confirms that the stubbed &lt;code&gt;UserService&lt;/code&gt; is called and working.</source>
          <target state="translated">첫 번째는 위생 테스트입니다. 스텁 된 &lt;code&gt;UserService&lt;/code&gt; 가 호출되어 작동 중인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="2fe10133ce5f0b8442b0b35164dad9dce4a33027" translate="yes" xml:space="preserve">
          <source>The first item in the array identifies the parent route (&lt;code&gt;/crisis-center&lt;/code&gt;).</source>
          <target state="translated">배열의 첫 번째 항목은 상위 경로 ( &lt;code&gt;/crisis-center&lt;/code&gt; )를 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="ef2dfd24b47c1df0d44ab06dc8c75e10571cb271" translate="yes" xml:space="preserve">
          <source>The first line indicates the driver state:</source>
          <target state="translated">첫 번째 줄은 드라이버 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6ae643662b050aa4b42fc55539a448dfb7866f94" translate="yes" xml:space="preserve">
          <source>The first parameter is &lt;code&gt;AppServerModule&lt;/code&gt;. It's the bridge between the Universal server-side renderer and the Angular application.</source>
          <target state="translated">첫 번째 매개 변수는 &lt;code&gt;AppServerModule&lt;/code&gt; 입니다. Universal 서버 측 렌더러와 Angular 응용 프로그램 사이의 다리입니다.</target>
        </trans-unit>
        <trans-unit id="62953bff7e26f22cabbf685caa0a5a1a6c295ca3" translate="yes" xml:space="preserve">
          <source>The first parameter is an object containing the locale data imported from &lt;code&gt;@angular/common/locales&lt;/code&gt;. By default, the imported locale data is registered with the locale id that is defined in the Angular locale data itself. If you want to register the imported locale data with another locale id, use the second parameter to specify a custom locale id. For example, Angular's locale data defines the locale id for French as &quot;fr&quot;. You can use the second parameter to associate the imported French locale data with the custom locale id &quot;fr-FR&quot; instead of &quot;fr&quot;.</source>
          <target state="translated">첫 번째 매개 변수는 &lt;code&gt;@angular/common/locales&lt;/code&gt; 에서 가져온 로케일 데이터를 포함하는 객체 입니다. 기본적으로 가져온 로캘 데이터는 Angular 로캘 데이터 자체에 정의 된 로캘 ID로 등록됩니다. 가져온 로케일 데이터를 다른 로케일 ID로 등록하려면 두 번째 매개 변수를 사용하여 사용자 정의 로케일 ID를 지정하십시오. 예를 들어 Angular의 로캘 데이터는 프랑스어의 로캘 ID를 &quot;fr&quot;로 정의합니다. 두 번째 매개 변수를 사용하면 가져온 프랑스어 로캘 데이터를 &quot;fr&quot;대신 사용자 지정 로캘 ID &quot;fr-FR&quot;과 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4e326dc69f53ccaa57af61d7dcbe29b421b04c0" translate="yes" xml:space="preserve">
          <source>The first parameter is the &lt;em&gt;element-to-click&lt;/em&gt;. If you wish, you can pass a custom event object as the second parameter. The default is a (partial) &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button&quot;&gt;left-button mouse event object&lt;/a&gt; accepted by many handlers including the &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; directive.</source>
          <target state="translated">첫 번째 매개 변수는 &lt;em&gt;클릭&lt;/em&gt; 할 &lt;em&gt;요소&lt;/em&gt; 입니다. 원하는 경우 사용자 정의 이벤트 객체를 두 번째 매개 변수로 전달할 수 있습니다. 디폴트는 &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; 지시문을 포함하여 많은 핸들러가 승인 하는 (부분) &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button&quot;&gt;왼쪽 단추 마우스 이벤트 오브젝트&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f3697ff5f0aeb3ecb5abdfb5882b9887cea92e64" translate="yes" xml:space="preserve">
          <source>The first parameter is the key. It is bound to the component property (&lt;code&gt;minutes&lt;/code&gt;), which determines the number of minutes.</source>
          <target state="translated">첫 번째 매개 변수는 키입니다. &lt;code&gt;minutes&lt;/code&gt; 수를 결정하는 구성 요소 속성 ( minutes )에 바인딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4f25fbb7333cd732b136fdcf04f2c24da137856" translate="yes" xml:space="preserve">
          <source>The first parameter of &lt;code&gt;&lt;a href=&quot;router#navigate&quot;&gt;navigate()&lt;/a&gt;&lt;/code&gt; is a delta to be applied to the current URL or the one provided in the &lt;code&gt;&lt;a href=&quot;navigationextras#relativeTo&quot;&gt;relativeTo&lt;/a&gt;&lt;/code&gt; property of the second parameter (the &lt;code&gt;&lt;a href=&quot;navigationextras&quot;&gt;NavigationExtras&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;router#navigate&quot;&gt;navigate()&lt;/a&gt;&lt;/code&gt; 의 첫 번째 매개 변수는 현재 URL 또는 두 번째 매개 변수 의 &lt;code&gt;&lt;a href=&quot;navigationextras#relativeTo&quot;&gt;relativeTo&lt;/a&gt;&lt;/code&gt; 속성 ( &lt;code&gt;&lt;a href=&quot;navigationextras&quot;&gt;NavigationExtras&lt;/a&gt;&lt;/code&gt; )에 제공되는 델타 입니다.</target>
        </trans-unit>
        <trans-unit id="9345528a3c56bcfad8473c4b0ab2f6cb3a19cf3d" translate="yes" xml:space="preserve">
          <source>The first parameter, &lt;code&gt;minutes&lt;/code&gt;, is bound to the component property (&lt;code&gt;minutes&lt;/code&gt;), which determines the number of minutes.</source>
          <target state="translated">첫 번째 매개 변수 인 &lt;code&gt;minutes&lt;/code&gt; 는 분 수를 결정하는 구성 요소 특성 ( &lt;code&gt;minutes&lt;/code&gt; )에 바인딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="7ef08564247507d1853a70de3837b4de95a01686" translate="yes" xml:space="preserve">
          <source>The first part, &lt;code&gt;duration&lt;/code&gt;, is required. The duration can be expressed in milliseconds as a simple number without quotes, or in seconds with quotes and a time specifier. For example, a duration of a tenth of a second can be expressed as follows:</source>
          <target state="translated">첫 번째 부분 인 &lt;code&gt;duration&lt;/code&gt; 이 필요합니다. 지속 시간은 따옴표없이 간단한 숫자로 밀리 초 단위로 표시하거나 따옴표와 시간 지정자를 사용하여 초 단위로 표시 할 수 있습니다. 예를 들어, 1/10 초의 지속 시간은 다음과 같이 표현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8129f1ba089dbdcf14610c20d5972d429db07c52" translate="yes" xml:space="preserve">
          <source>The first piece you'll port over to Angular is the &lt;code&gt;Phone&lt;/code&gt; service, which resides in &lt;code&gt;app/core/phone/phone.service.ts&lt;/code&gt; and makes it possible for components to load phone information from the server. Right now it's implemented with ngResource and you're using it for two things:</source>
          <target state="translated">Angular로 포팅하는 첫 번째 부분은 &lt;code&gt;Phone&lt;/code&gt; 서비스입니다. &lt;code&gt;app/core/phone/phone.service.ts&lt;/code&gt; 에 구성 요소가 서버에서 전화 정보를로드 할 수있게합니다. 지금은 ngResource로 구현되었으며 두 가지 용도로 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d409bc236492541655f27b252a1ca412eb1c6dd8" translate="yes" xml:space="preserve">
          <source>The first provider is the &lt;em&gt;de-sugared&lt;/em&gt;, expanded form of the most typical case in which the class to be created (&lt;code&gt;HeroService&lt;/code&gt;) is also the provider's dependency injection token. The short form is generally preferred; this long form makes the details explicit.</source>
          <target state="translated">첫 번째 공급자는 클래스가 생성되는 가장 일반적인 경우의 &lt;em&gt;설탕을 제거&lt;/em&gt; 하고 확장 한 형태입니다 ( &lt;code&gt;HeroService&lt;/code&gt; )가 공급자의 종속성 주입 토큰 인 . 짧은 형태가 일반적으로 바람직하다; 이 긴 형식은 세부 사항을 명시 적으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4833e5a707db3bf1798a161d416463da98bc30af" translate="yes" xml:space="preserve">
          <source>The first provides an existing instance of the &lt;code&gt;Hero&lt;/code&gt; class to use for the &lt;code&gt;Hero&lt;/code&gt; token, rather than requiring the injector to create a new instance with &lt;code&gt;new&lt;/code&gt; or use its own cached instance. Here, the token is the class itself.</source>
          <target state="translated">먼저 기존의 인스턴스를 제공 &lt;code&gt;Hero&lt;/code&gt; 에 사용하는 클래스를 &lt;code&gt;Hero&lt;/code&gt; 대신에 새로운 인스턴스 생성 인젝터를 필요로하는 것보다, 토큰 &lt;code&gt;new&lt;/code&gt; 하거나 자신의 캐시 인스턴스를 사용합니다. 여기서 토큰은 클래스 자체입니다.</target>
        </trans-unit>
        <trans-unit id="7e391d5af3994d07831d1d59d60f4b82bee03d07" translate="yes" xml:space="preserve">
          <source>The first route does the following:</source>
          <target state="translated">첫 번째 경로는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d24e841b0aac44b0fa2a6d557695a951fb865d88" translate="yes" xml:space="preserve">
          <source>The first segment name can be prepended with &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;./&lt;/code&gt;, or &lt;code&gt;../&lt;/code&gt;.</source>
          <target state="translated">첫 번째 세그먼트 이름 앞에 &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;./&lt;/code&gt; 또는 &lt;code&gt;../&lt;/code&gt; 를 붙일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c812f6529ca065b3990e70e2407682a3f9b80ef0" translate="yes" xml:space="preserve">
          <source>The first segment name can be prepended with &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;./&lt;/code&gt;, or &lt;code&gt;../&lt;/code&gt;:</source>
          <target state="translated">첫 번째 세그먼트 이름 앞에 &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;./&lt;/code&gt; 또는 &lt;code&gt;../&lt;/code&gt; 를 붙일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be494398bc29b0cab8b00ca0ac7181001cb339b3" translate="yes" xml:space="preserve">
          <source>The first test creates a &lt;code&gt;ValueService&lt;/code&gt; with &lt;code&gt;new&lt;/code&gt; and passes it to the &lt;code&gt;MasterService&lt;/code&gt; constructor.</source>
          <target state="translated">첫 번째 테스트 는 &lt;code&gt;new&lt;/code&gt; 를 사용하여 &lt;code&gt;ValueService&lt;/code&gt; 를 작성하고 이를 &lt;code&gt;MasterService&lt;/code&gt; 생성자에 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="e5c06683cd16e03e55d325b4c0dc8a1f41e8cc0c" translate="yes" xml:space="preserve">
          <source>The first test shows the benefit of automatic change detection.</source>
          <target state="translated">첫 번째 테스트는 자동 변경 감지의 이점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="aa509a8a6923fb66806ca57c1af7a5c17aa9333e" translate="yes" xml:space="preserve">
          <source>The first two lines, with the bindings, are there from previous steps. The new parts are &lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;app-inspector&amp;gt;&lt;/code&gt;. &lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt; allows you to project content, and &lt;code&gt;&amp;lt;app-inspector&amp;gt;&lt;/code&gt; inside the &lt;code&gt;ChildComponent&lt;/code&gt; template makes the &lt;code&gt;InspectorComponent&lt;/code&gt; a child component of &lt;code&gt;ChildComponent&lt;/code&gt;.</source>
          <target state="translated">바인딩이있는 처음 두 줄은 이전 단계의 것입니다. 새로운 부분은 &lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;app-inspector&amp;gt;&lt;/code&gt; 입니다. &lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt; 를 사용하면 컨텐츠를 투영 할 수 있으며 &lt;code&gt;ChildComponent&lt;/code&gt; 템플릿 내의 &lt;code&gt;&amp;lt;app-inspector&amp;gt;&lt;/code&gt; 는 &lt;code&gt;InspectorComponent&lt;/code&gt; 를 &lt;code&gt;ChildComponent&lt;/code&gt; 의 하위 구성 요소로 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="c7f348f21943da7baa131bdaaaeacb38df6dc474" translate="yes" xml:space="preserve">
          <source>The first two paths are the routes to the &lt;code&gt;CustomersModule&lt;/code&gt; and the &lt;code&gt;OrdersModule&lt;/code&gt;. The final entry defines a default route. The empty path matches everything that doesn't match an earlier path.</source>
          <target state="translated">처음 두 경로는 &lt;code&gt;CustomersModule&lt;/code&gt; 및 &lt;code&gt;OrdersModule&lt;/code&gt; 에 대한 경로 입니다. 마지막 항목은 기본 경로를 정의합니다. 빈 경로는 이전 경로와 일치하지 않는 모든 항목과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="dc8e7d683a61ef16411f45a78aa24508cfc2fdad" translate="yes" xml:space="preserve">
          <source>The first unit contains the text that was outside of the &lt;code&gt;select&lt;/code&gt;. In place of the &lt;code&gt;select&lt;/code&gt; is a placeholder, &lt;code&gt;&amp;lt;x id=&quot;ICU&quot;&amp;gt;&lt;/code&gt;, that represents the &lt;code&gt;select&lt;/code&gt; message. Translate the text and move around the placeholder if necessary, but don't remove it. If you remove the placeholder, the ICU expression will not be present in your translated app.</source>
          <target state="translated">첫 번째 단위는 &lt;code&gt;select&lt;/code&gt; 외부에 있던 텍스트를 포함합니다 . &lt;code&gt;select&lt;/code&gt; 대신에 &lt;code&gt;select&lt;/code&gt; 메시지 를 나타내는 자리 표시 자 &lt;code&gt;&amp;lt;x id=&quot;ICU&quot;&amp;gt;&lt;/code&gt; 가 있습니다. 필요한 경우 텍스트를 번역하고 자리 표시 자 주위를 이동하지만 제거하지 마십시오. 자리 표시자를 제거하면 번역 된 앱에 ICU식이 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a43bddb336b6d795fd036d0b5ceb9112cbcc9c51" translate="yes" xml:space="preserve">
          <source>The fix - hide empty details with &lt;em&gt;*ngIf&lt;/em&gt;</source>
          <target state="translated">수정- &lt;em&gt;* ngIf로&lt;/em&gt; 빈 세부 정보 숨기기&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0c4e5c41140f56ca78f4718c5d160184adeef566" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;--optimization=&quot;true&quot;&lt;/code&gt; applies to both scripts and styles. You can supply a value such as the following to apply optimization to one or the other:</source>
          <target state="translated">&lt;code&gt;--optimization=&quot;true&quot;&lt;/code&gt; 플래그 는 스크립트와 스타일 모두에 적용됩니다. 다음과 같은 값을 제공하여 둘 중 하나에 최적화를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cae6ccc26c43113c77ba86a6a7f857871cb6761" translate="yes" xml:space="preserve">
          <source>The flag &lt;code&gt;--sourceMap=&quot;true&quot;&lt;/code&gt; outputs source maps for both scripts and styles. You can configure the option to apply to one or the other. You can also choose to output hidden source maps, or resolve vendor package source maps. For example:</source>
          <target state="translated">&lt;code&gt;--sourceMap=&quot;true&quot;&lt;/code&gt; 플래그 는 스크립트와 스타일 모두에 대한 소스 맵을 출력합니다. 옵션을 하나에 적용하도록 구성 할 수 있습니다. 숨겨진 소스 맵을 출력하거나 공급 업체 패키지 소스 맵을 해결하도록 선택할 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3f3ed63d6d77ed1a3c84fa9fd5bacb244d6a6a3c" translate="yes" xml:space="preserve">
          <source>The folllowing sections highlight some core router concepts.</source>
          <target state="translated">다음 섹션에서는 몇 가지 핵심 라우터 개념을 강조합니다.</target>
        </trans-unit>
        <trans-unit id="1493706ed03721d1c78b58ccff4d87d10377338c" translate="yes" xml:space="preserve">
          <source>The follow example shows how to use radio buttons in a reactive form. When using radio buttons in a reactive form, radio buttons in the same group should have the same &lt;code&gt;&lt;a href=&quot;formcontrolname&quot;&gt;formControlName&lt;/a&gt;&lt;/code&gt;. Providing a &lt;code&gt;name&lt;/code&gt; attribute is optional.</source>
          <target state="translated">다음 예는 반응 형으로 라디오 버튼을 사용하는 방법을 보여줍니다. 반응 형 형식의 라디오 버튼을 사용하는 경우 같은 그룹의 라디오 버튼은 &lt;code&gt;&lt;a href=&quot;formcontrolname&quot;&gt;formControlName&lt;/a&gt;&lt;/code&gt; 이 같아야 합니다. &lt;code&gt;name&lt;/code&gt; 속성을 제공하는 것은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="310dc1587f604138be8759e6a89d07e7cc01679f" translate="yes" xml:space="preserve">
          <source>The follow example shows you how to use a multi-select control with a reactive form.</source>
          <target state="translated">다음 예제는 반응 형과 함께 다중 선택 컨트롤을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="8c6f2a7b56c63473c3a42c22b17753fcb52e791f" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;&lt;a href=&quot;../api/core/errorhandler#handleError&quot;&gt;handleError()&lt;/a&gt;&lt;/code&gt; method reports the error and then returns an innocuous result so that the application keeps working.</source>
          <target state="translated">다음 &lt;code&gt;&lt;a href=&quot;../api/core/errorhandler#handleError&quot;&gt;handleError()&lt;/a&gt;&lt;/code&gt; 메서드는 오류를보고 한 다음 응용 프로그램이 계속 작동 할 수 있도록 무해한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="785ab51680d18375d227cf4bdd9454c50b68a18c" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;&lt;a href=&quot;../api/core/errorhandler#handleError&quot;&gt;handleError()&lt;/a&gt;&lt;/code&gt; will be shared by many &lt;code&gt;HeroService&lt;/code&gt; methods so it's generalized to meet their different needs.</source>
          <target state="translated">다음의 &lt;code&gt;&lt;a href=&quot;../api/core/errorhandler#handleError&quot;&gt;handleError()&lt;/a&gt;&lt;/code&gt; 는 많은 &lt;code&gt;HeroService&lt;/code&gt; 메소드와 공유 되므로 서로 다른 요구를 충족하도록 일반화됩니다.</target>
        </trans-unit>
        <trans-unit id="9fac4999708b255d65710166eee053bb3a438369" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;ActivatedRouteStub&lt;/code&gt; class serves as a test double for &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">다음 &lt;code&gt;ActivatedRouteStub&lt;/code&gt; 클래스는 ActivatedRoute에 대한 테스트 이중 역할을 &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e61ca55af810cb77b591c0e8d0cf9110b85b7a31" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;QuestionBase&lt;/code&gt; is a base class for a set of controls that can represent the question and its answer in the form.</source>
          <target state="translated">다음 &lt;code&gt;QuestionBase&lt;/code&gt; 는 양식에서 질문과 대답을 나타낼 수있는 컨트롤 집합에 대한 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="b2b988a26abe5c751d6ffb4eba65994971ffa485" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;QuestionBase&lt;/code&gt; is a fundamental question class.</source>
          <target state="translated">다음 &lt;code&gt;QuestionBase&lt;/code&gt; 는 기본적인 질문 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="c06281078d15555932d1ae78c47b2ddcf06d4228" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;WelcomeComponent&lt;/code&gt; depends on the &lt;code&gt;UserService&lt;/code&gt; to know the name of the user to greet.</source>
          <target state="translated">다음 &lt;code&gt;WelcomeComponent&lt;/code&gt; 는 &lt;code&gt;UserService&lt;/code&gt; 에 의존 하여 인사 할 사용자 이름을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0f7c8570c75a7fbfc3c92a94edaa5d338b173de" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;devDependencies&lt;/code&gt; are provided in the default &lt;code&gt;package.json&lt;/code&gt; file for a new Angular workspace.</source>
          <target state="translated">다음과 같은 &lt;code&gt;devDependencies&lt;/code&gt; 가 새 Angular 작업 공간을위한 기본 &lt;code&gt;package.json&lt;/code&gt; 파일에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="36e2b7d7bec0be04c77013b1d36bd5f9bd31299b" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;go()&lt;/code&gt; function navigates to the &lt;code&gt;list&lt;/code&gt; route by interpreting the destination URI as relative to the activated &lt;code&gt;child&lt;/code&gt; route</source>
          <target state="translated">다음 &lt;code&gt;go()&lt;/code&gt; 함수 는 활성화 된 &lt;code&gt;child&lt;/code&gt; 경로 를 기준으로 대상 URI를 해석하여 &lt;code&gt;list&lt;/code&gt; 경로를 탐색 합니다.</target>
        </trans-unit>
        <trans-unit id="c66deeeadbe10c60879e8a84f1e34c983c81d32e" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;handleError()&lt;/code&gt; method reports the error and then returns an innocuous result so that the application keeps working.</source>
          <target state="translated">다음 &lt;code&gt;handleError()&lt;/code&gt; 메서드는 오류를보고 한 다음 무해한 결과를 반환하므로 응용 프로그램이 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="116cc41ee5347f1fb8e9c5ef258684090ee5b82d" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;handleError()&lt;/code&gt; will be shared by many &lt;code&gt;HeroService&lt;/code&gt; methods so it's generalized to meet their different needs.</source>
          <target state="translated">다음 &lt;code&gt;handleError()&lt;/code&gt; 는 많은 &lt;code&gt;HeroService&lt;/code&gt; 메서드에서 공유 되므로 다른 요구 사항을 충족하도록 일반화됩니다.</target>
        </trans-unit>
        <trans-unit id="0a445c25398c4982342ee1c37ee98932b7260ab6" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;searchHeroes&lt;/code&gt; method queries for heroes whose names contain the search term. Start by importing &lt;code&gt;&lt;a href=&quot;../api/common/http/httpparams&quot;&gt;HttpParams&lt;/a&gt;&lt;/code&gt; class.</source>
          <target state="translated">다음 &lt;code&gt;searchHeroes&lt;/code&gt; 메소드는 이름에 검색어가 포함 된 영웅을 조회합니다. &lt;code&gt;&lt;a href=&quot;../api/common/http/httpparams&quot;&gt;HttpParams&lt;/a&gt;&lt;/code&gt; 클래스 를 가져 와서 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="91fa256b1d95446c100727849d7fffe9e6eee18c" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;sizerComponent&lt;/code&gt; has a &lt;code&gt;size&lt;/code&gt; value property and a &lt;code&gt;sizeChange&lt;/code&gt; event. The &lt;code&gt;size&lt;/code&gt; property is an &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt;, so data can flow into the &lt;code&gt;sizerComponent&lt;/code&gt;. The &lt;code&gt;sizeChange&lt;/code&gt; event is an &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt;, which allows data to flow out of the &lt;code&gt;sizerComponent&lt;/code&gt; to the parent component.</source>
          <target state="translated">다음 &lt;code&gt;sizerComponent&lt;/code&gt; 에는 &lt;code&gt;size&lt;/code&gt; 값 속성과 &lt;code&gt;sizeChange&lt;/code&gt; 이벤트가 있습니다. &lt;code&gt;size&lt;/code&gt; 속성은이다 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 데이터로 흐를 수 있도록 &lt;code&gt;sizerComponent&lt;/code&gt; . &lt;code&gt;sizeChange&lt;/code&gt; 의 이벤트는 인 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; 데이터가 흐를 수 있으며, &lt;code&gt;sizerComponent&lt;/code&gt; 부모 컴포넌트.</target>
        </trans-unit>
        <trans-unit id="cf12f77efe304835f70e6db2fb5c41f976783ba1" translate="yes" xml:space="preserve">
          <source>The following &lt;em&gt;AfterContent&lt;/em&gt; hooks take action based on changing values in a &lt;em&gt;content child&lt;/em&gt;, which can only be reached by querying for them via the property decorated with &lt;a href=&quot;../api/core/contentchild&quot;&gt;@ContentChild&lt;/a&gt;.</source>
          <target state="translated">다음 &lt;em&gt;AfterContent&lt;/em&gt; 후크는 &lt;em&gt;컨텐츠 하위의&lt;/em&gt; 값 변경에 따라 조치를 취하며 , 이는 &lt;a href=&quot;../api/core/contentchild&quot;&gt;@ContentChild로&lt;/a&gt; 장식 된 특성을 통해 쿼리하여 도달 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="116e174584a29bb6840145432c80d1ed6f312131" translate="yes" xml:space="preserve">
          <source>The following &lt;em&gt;code-example&lt;/em&gt; displays the sample's &lt;code&gt;app.module.ts&lt;/code&gt;.</source>
          <target state="translated">다음 &lt;em&gt;코드 예제&lt;/em&gt; 는 샘플의 &lt;code&gt;app.module.ts&lt;/code&gt; &lt;em&gt;를&lt;/em&gt; 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="7ff1e333381c65ecbd5243d727c0316791951c07" translate="yes" xml:space="preserve">
          <source>The following &lt;em&gt;negative&lt;/em&gt; example defines the &lt;code&gt;AppComponent&lt;/code&gt;, bootstraps the app, defines the &lt;code&gt;Hero&lt;/code&gt; model object, and loads heroes from the server all in the same file. &lt;em&gt;Don't do this&lt;/em&gt;.</source>
          <target state="translated">다음 &lt;em&gt;음수&lt;/em&gt; 예제는 &lt;code&gt;AppComponent&lt;/code&gt; 를 정의하고 , 앱을 부트 스트랩하고, &lt;code&gt;Hero&lt;/code&gt; 모델 객체를 정의하며 , 서버에서 모두 같은 파일로 영웅을로드합니다. &lt;em&gt;하지 마십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f753905a9a1f06f9639773508814519f5c2d410a" translate="yes" xml:space="preserve">
          <source>The following APIs have been removed starting with version 11.0.0*:</source>
          <target state="translated">버전 11.0.0 *부터 다음 API가 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="994aa1e70e47f4c7e017a337b6ce6547e5ba554b" translate="yes" xml:space="preserve">
          <source>The following APIs have been removed starting with version 8.0.0:</source>
          <target state="translated">버전 8.0.0부터 다음 API가 제거되었습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
