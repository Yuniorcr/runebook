<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="angular">
    <body>
      <group id="angular">
        <trans-unit id="d02e253b850f113d73bfb00512bed301e76af61e" translate="yes" xml:space="preserve">
          <source>The server (&lt;a href=&quot;https://expressjs.com/&quot;&gt;Node.js Express&lt;/a&gt; in this guide's example) passes client requests for application pages to the NgUniversal &lt;code&gt;ngExpressEngine&lt;/code&gt;. Under the hood, this calls Universal's &lt;code&gt;&lt;a href=&quot;../api/platform-server/rendermodule&quot;&gt;renderModule&lt;/a&gt;()&lt;/code&gt; function, while providing caching and other helpful utilities.</source>
          <target state="translated">서버 ( 이 가이드의 예제에서 &lt;a href=&quot;https://expressjs.com/&quot;&gt;Node.js Express&lt;/a&gt; )는 애플리케이션 페이지에 대한 클라이언트 요청을 NgUniversal &lt;code&gt;ngExpressEngine&lt;/code&gt; 에 전달 합니다. 내부적으로는 Universal의 &lt;code&gt;&lt;a href=&quot;../api/platform-server/rendermodule&quot;&gt;renderModule&lt;/a&gt;()&lt;/code&gt; 함수를 호출 하는 동시에 캐싱 및 기타 유용한 유틸리티를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="833b0d09ecb324069b98f0951ab344fac2fef24f" translate="yes" xml:space="preserve">
          <source>The server backend might reject the request, returning an HTTP response with a status code such as 404 or 500. These are error &lt;em&gt;responses&lt;/em&gt;.</source>
          <target state="translated">서버 백엔드는 요청을 거부하여 404 또는 500과 같은 상태 코드와 함께 HTTP 응답을 반환 할 수 있습니다 . 이는 오류 &lt;em&gt;응답&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b91c33e79c6d8ce1f35c11a0064ccf17c1206386" translate="yes" xml:space="preserve">
          <source>The server platform that supports the runtime compiler.</source>
          <target state="translated">런타임 컴파일러를 지원하는 서버 플랫폼.</target>
        </trans-unit>
        <trans-unit id="fdc7974bddc4251d37c899dec154f7616873a7f7" translate="yes" xml:space="preserve">
          <source>The server should respond with a single hero rather than an array of heroes.</source>
          <target state="translated">서버는 여러 영웅이 아닌 단일 영웅으로 응답해야합니다.</target>
        </trans-unit>
        <trans-unit id="eca5a8837e9ee160489059a172e9ebc977dd83cd" translate="yes" xml:space="preserve">
          <source>The server will automatically reload your browser when new files are output.</source>
          <target state="translated">새 파일이 출력되면 서버가 자동으로 브라우저를 다시로드합니다.</target>
        </trans-unit>
        <trans-unit id="0d9613e884c4d7057875fd99d39be99f233ae206" translate="yes" xml:space="preserve">
          <source>The server's data API determines the shape of the JSON data. The &lt;em&gt;Tour of Heroes&lt;/em&gt; data API returns the hero data as an array.</source>
          <target state="translated">서버의 데이터 API가 JSON 데이터의 형태를 결정합니다. &lt;em&gt;영웅의 투어&lt;/em&gt; 데이터 API는 배열로 영웅의 데이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d608ede8654d1838eb5137faa0d8ed16a87869ad" translate="yes" xml:space="preserve">
          <source>The server-rendered app still launches quickly but the full client app may take seconds to load.</source>
          <target state="translated">서버 렌더링 앱은 여전히 ​​빠르게 시작되지만 전체 클라이언트 앱을로드하는 데 몇 초가 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e791eab073e4d3b4cd8bc1aca0e02dd44233a6e7" translate="yes" xml:space="preserve">
          <source>The service can be instantiated by configuring a factory function, as in the following example.</source>
          <target state="translated">다음 예와 같이 팩토리 기능을 구성하여 서비스를 인스턴스화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b01cb6b08662ccfbcebed41545cd05a24d2577c4" translate="yes" xml:space="preserve">
          <source>The service exposes its cache of &lt;code&gt;&lt;a href=&quot;../api/service-worker/swpush#messages&quot;&gt;messages&lt;/a&gt;&lt;/code&gt; and two methods: one to &lt;code&gt;add()&lt;/code&gt; a message to the cache and another to &lt;code&gt;&lt;a href=&quot;../api/forms/formarray#clear&quot;&gt;clear()&lt;/a&gt;&lt;/code&gt; the cache.</source>
          <target state="translated">서비스는 &lt;code&gt;&lt;a href=&quot;../api/service-worker/swpush#messages&quot;&gt;messages&lt;/a&gt;&lt;/code&gt; 캐시와 메시지를 캐시에 &lt;code&gt;add()&lt;/code&gt; 하는 방법 과 캐시를 &lt;code&gt;&lt;a href=&quot;../api/forms/formarray#clear&quot;&gt;clear()&lt;/a&gt;&lt;/code&gt; 방법의 두 가지 방법을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="e6443c7850c012b2c10c16adbba71b75368fdc4f" translate="yes" xml:space="preserve">
          <source>The service exposes its cache of &lt;code&gt;messages&lt;/code&gt; and two methods: one to &lt;code&gt;add()&lt;/code&gt; a message to the cache and another to &lt;code&gt;clear()&lt;/code&gt; the cache.</source>
          <target state="translated">이 서비스는 &lt;code&gt;messages&lt;/code&gt; 캐시 와 두 가지 메서드를 노출 합니다. 하나 는 메시지를 캐시 에 &lt;code&gt;add()&lt;/code&gt; 하고 다른 하나는 캐시를 &lt;code&gt;clear()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8fbb599e20de587b80201a2202b3533ea4c17924" translate="yes" xml:space="preserve">
          <source>The service itself is a class that the CLI generated and that's decorated with &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt;. By default, this decorator has a &lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;&lt;/code&gt; property, which creates a provider for the service. In this case, &lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;: 'root'&lt;/code&gt; specifies that Angular should provide the service in the root injector.</source>
          <target state="translated">서비스 자체는 CLI가 생성하고 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; 장식 된 클래스입니다 . 이 데코레이터에는 기본적으로 서비스 제공 업체를 &lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;&lt;/code&gt; 하는 providedIn 속성이 있습니다. 이 경우 &lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;: 'root'&lt;/code&gt; 는 Angular가 루트 인젝터에서 서비스를 제공하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1eb2341b2a56fcef48a10982c82e78d778efcf41" translate="yes" xml:space="preserve">
          <source>The service itself is a class that the CLI generated and that's decorated with &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt;. By default, this decorator has a &lt;code&gt;providedIn&lt;/code&gt; property, which creates a provider for the service. In this case, &lt;code&gt;providedIn: 'root'&lt;/code&gt; specifies that Angular should provide the service in the root injector.</source>
          <target state="translated">서비스 자체는 CLI가 생성 한 클래스이며 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; 장식되어 있습니다 . 기본적으로이 데코레이터에는 서비스 공급자를 생성하는 &lt;code&gt;providedIn&lt;/code&gt; 속성이 있습니다. 이 경우, &lt;code&gt;providedIn: 'root'&lt;/code&gt; 는 Angular가 루트 인젝터에서 서비스를 제공해야 함을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="a8d86534f286c4014047b48e39157c9ac642d3f4" translate="yes" xml:space="preserve">
          <source>The service provided by the root &lt;code&gt;AppModule&lt;/code&gt; takes precedence over services provided by imported NgModules. The &lt;code&gt;AppModule&lt;/code&gt; always wins.</source>
          <target state="translated">루트 &lt;code&gt;AppModule&lt;/code&gt; 에서 제공하는 서비스는 가져온 NgModules에서 제공하는 서비스보다 우선합니다. &lt;code&gt;AppModule&lt;/code&gt; 은 항상 이긴다.</target>
        </trans-unit>
        <trans-unit id="e4c344300d7fd4d9f966ba1a8642b3e11076118a" translate="yes" xml:space="preserve">
          <source>The service uses the &lt;code&gt;import()&lt;/code&gt; method to load your bundled AngularJS application lazily. This decreases the initial bundle size of your application as you're not loading code your user doesn't need yet. You also need to provide a way to &lt;em&gt;bootstrap&lt;/em&gt; the application manually after it has been loaded. AngularJS provides a way to manually bootstrap an application using the &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.bootstrap&quot;&gt;angular.bootstrap()&lt;/a&gt; method with a provided HTML element. Your AngularJS app should also expose a &lt;code&gt;bootstrap&lt;/code&gt; method that bootstraps the AngularJS app.</source>
          <target state="translated">이 서비스는 &lt;code&gt;import()&lt;/code&gt; 메소드를 사용하여 번들로 제공되는 AngularJS 애플리케이션을 느리게로드합니다. 사용자가 아직 필요로하지 않는 코드를로드하지 않기 때문에 애플리케이션의 초기 번들 크기가 줄어 듭니다. 또한 응용 프로그램을로드 한 후 수동으로 &lt;em&gt;부트 스트랩&lt;/em&gt; 하는 방법을 제공해야합니다 . AngularJS는 제공된 HTML 요소와 함께 &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.bootstrap&quot;&gt;angular.bootstrap ()&lt;/a&gt; 메소드를 사용하여 애플리케이션을 수동으로 부트 스트랩하는 방법을 제공합니다. AngularJS 앱은 AngularJS 앱 을 부트 스트랩 하는 &lt;code&gt;bootstrap&lt;/code&gt; 메소드 도 제공해야 합니다.</target>
        </trans-unit>
        <trans-unit id="dc4b5f46b09780ea494a593541c8cc9fef7174dd" translate="yes" xml:space="preserve">
          <source>The service worker conserves bandwidth when possible. Resources are only downloaded if they've changed.</source>
          <target state="translated">서비스 담당자는 가능한 경우 대역폭을 절약합니다. 리소스는 변경된 경우에만 다운로드됩니다.</target>
        </trans-unit>
        <trans-unit id="73a76971f818809f629500d6b5210621468c33c3" translate="yes" xml:space="preserve">
          <source>The service worker installed the updated version of your app &lt;em&gt;in the background&lt;/em&gt;, and the next time the page is loaded or reloaded, the service worker switches to the latest version.</source>
          <target state="translated">서비스 워커 &lt;em&gt;는 백그라운드에서&lt;/em&gt; 업데이트 된 앱 버전을 설치했으며 다음에 페이지를로드하거나 다시로드하면 서비스 워커가 최신 버전으로 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="e5e8a28aed57347d4280ded734f47df1ae665528" translate="yes" xml:space="preserve">
          <source>The service worker is unable to find the asset in the cache (remember that the browser evicted it). Nor is it able to retrieve it from the server (since the server now only has &lt;code&gt;lazy-chunk.&amp;lt;lazy-hash-2&amp;gt;.js&lt;/code&gt; from the newer version).</source>
          <target state="translated">서비스 워커가 캐시에서 자산을 찾을 수 없습니다 (브라우저가 자산을 제거했음을 기억하십시오). 또한 서버에서 검색 할 수도 없습니다 (서버에는 이제 최신 버전의 &lt;code&gt;lazy-chunk.&amp;lt;lazy-hash-2&amp;gt;.js&lt;/code&gt; 만 있으므로).</target>
        </trans-unit>
        <trans-unit id="cc0df69a7bfbd6545911d095948cf97558edba0d" translate="yes" xml:space="preserve">
          <source>The set of NgModules whose exported &lt;a href=&quot;../../guide/glossary#declarable&quot;&gt;declarables&lt;/a&gt; are available to templates in this module.</source>
          <target state="translated">수출 NgModules 세트 &lt;a href=&quot;../../guide/glossary#declarable&quot;&gt;승인 된 기술&lt;/a&gt; 이 모듈에서 템플릿을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abd06758e4687a7c44919fabc0c064aac2354cc2" translate="yes" xml:space="preserve">
          <source>The set of components that are bootstrapped when this module is bootstrapped. The components listed here are automatically added to &lt;code&gt;entryComponents&lt;/code&gt;.</source>
          <target state="translated">이 모듈이 부트 스트랩 될 때 부트 스트랩되는 구성 요소 세트. 여기에 나열된 컴포넌트는 &lt;code&gt;entryComponents&lt;/code&gt; 에 자동으로 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="32d438c2e575af5904ec9ce7fda3a5333ad0ee04" translate="yes" xml:space="preserve">
          <source>The set of components to compile when this NgModule is defined, so that they can be dynamically loaded into the view.</source>
          <target state="translated">이 NgModule이 정의 될 때 컴파일 할 컴포넌트 세트로, 뷰에 동적으로로드 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fb26e057f395ff1c2bbe69c4c8605bab3259d00" translate="yes" xml:space="preserve">
          <source>The set of components, directives, and pipes (&lt;a href=&quot;../../guide/glossary#declarable&quot;&gt;declarables&lt;/a&gt;) that belong to this module.</source>
          <target state="translated">이 모듈에 속하는 구성 요소, 지시문 및 파이프 ( &lt;a href=&quot;../../guide/glossary#declarable&quot;&gt;선언 가능&lt;/a&gt; ) 세트 .</target>
        </trans-unit>
        <trans-unit id="7b2caf88051dc93e4146531fb1b86232037cd52e" translate="yes" xml:space="preserve">
          <source>The set of components, directives, and pipes declared in this NgModule that can be used in the template of any component that is part of an NgModule that imports this NgModule. Exported declarations are the module's public API.</source>
          <target state="translated">이 NgModule을 가져 오는 NgModule의 일부인 구성 요소의 템플리트에서 사용할 수있는이 NgModule에 선언 된 구성 요소, 지시문 및 파이프 세트. 내 보낸 선언은 모듈의 공용 API입니다.</target>
        </trans-unit>
        <trans-unit id="0c259b27e27fec00cdb957688cd4f00e39150e77" translate="yes" xml:space="preserve">
          <source>The set of injectable objects that are available in the injector of this module.</source>
          <target state="translated">이 모듈의 인젝터에서 사용 가능한 인젝터 블 오브젝트 세트입니다.</target>
        </trans-unit>
        <trans-unit id="d5765ec9ddf94071c5020c93344913452a009948" translate="yes" xml:space="preserve">
          <source>The set of questions you've defined for the job application is returned from the &lt;code&gt;QuestionService&lt;/code&gt;. In a real app you'd retrieve these questions from storage.</source>
          <target state="translated">작업 애플리케이션에 대해 정의한 질문 세트가 &lt;code&gt;QuestionService&lt;/code&gt; 에서 리턴됩니다 . 실제 앱에서는 저장소에서 이러한 질문을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="21e915a97b647841a3c77d6bb5bc493db4e59530" translate="yes" xml:space="preserve">
          <source>The set of schemas that declare elements to be allowed in the NgModule. Elements and properties that are neither Angular components nor directives must be declared in a schema.</source>
          <target state="translated">NgModule에서 허용 될 요소를 선언하는 스키마 세트. 각도 컴포넌트 나 지시어가 아닌 요소와 속성은 스키마에 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="f833bd6b1e79171a431acd5cc244779fb79402e4" translate="yes" xml:space="preserve">
          <source>The set of selectors that are available to a template include those declared here, and those that are exported from imported NgModules.</source>
          <target state="translated">템플릿에 사용 가능한 선택기 집합에는 여기에 선언 된 항목과 가져온 NgModules에서 내 보낸 선택기가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b6a30893f8633b1e28a52635e18ed8118090a942" translate="yes" xml:space="preserve">
          <source>The setter of the &lt;code&gt;name&lt;/code&gt; input property in the child &lt;code&gt;NameChildComponent&lt;/code&gt; trims the whitespace from a name and replaces an empty value with default text.</source>
          <target state="translated">자식 &lt;code&gt;NameChildComponent&lt;/code&gt; 의 &lt;code&gt;name&lt;/code&gt; 입력 속성 설정자는 이름 에서 공백을 제거하고 빈 값을 기본 텍스트로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="882e77e815d86faba535964e8ae6e6a1f26ffa49" translate="yes" xml:space="preserve">
          <source>The setup for the &lt;em&gt;test-host&lt;/em&gt; tests is similar to the setup for the stand-alone tests:</source>
          <target state="translated">에 대한 설정 &lt;em&gt;테스트 호스트&lt;/em&gt; 테스트는 독립 실행 형 테스트에 대한 설정과 유사합니다 :</target>
        </trans-unit>
        <trans-unit id="52f4e19d49b1e5a67a00d5af99c62cbc1c7875a5" translate="yes" xml:space="preserve">
          <source>The shadow-dom-piercing descendant combinator is deprecated and support is being &lt;a href=&quot;https://developers.google.com/web/updates/2017/10/remove-shadow-piercing&quot;&gt;removed from major browsers and tools&lt;/a&gt;. As such, in v4 we deprecated support in Angular for all 3 of &lt;code&gt;/deep/&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;::ng-deep&lt;/code&gt;. Until removal, &lt;code&gt;::ng-deep&lt;/code&gt; is preferred for broader compatibility with the tools.</source>
          <target state="translated">shadow-dom-piercing 하위 항목 콤비 네이터는 더 이상 사용되지 않으며 &lt;a href=&quot;https://developers.google.com/web/updates/2017/10/remove-shadow-piercing&quot;&gt;주요 브라우저 및 도구에서&lt;/a&gt; 지원이 제거됩니다 . 따라서 v4에서는 &lt;code&gt;/deep/&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;::ng-deep&lt;/code&gt; 모두에 대해 Angular에서 지원이 중단되었습니다 . 제거 할 때까지 &lt;code&gt;::ng-deep&lt;/code&gt; 이 도구와의 광범위한 호환성을 위해 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="e4af087be2847b1c9f00ac636a9cf97937c7f75f" translate="yes" xml:space="preserve">
          <source>The shadow-piercing descendant combinator is deprecated and &lt;a href=&quot;https://www.chromestatus.com/feature/6750456638341120&quot;&gt;support is being removed from major browsers&lt;/a&gt; and tools. As such we plan to drop support in Angular (for all 3 of &lt;code&gt;/deep/&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;::ng-deep&lt;/code&gt;). Until then &lt;code&gt;::ng-deep&lt;/code&gt; should be preferred for a broader compatibility with the tools.</source>
          <target state="translated">섀도 피어싱 하위 결합자는 더 이상 사용되지 않으며 &lt;a href=&quot;https://www.chromestatus.com/feature/6750456638341120&quot;&gt;주요 브라우저&lt;/a&gt; 및 도구 에서 지원이 제거됩니다 . 따라서 Angular에서 지원을 중단 할 계획입니다 ( &lt;code&gt;/deep/&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;::ng-deep&lt;/code&gt; 3 개 모두 ). 그 전까지 는 도구와의 광범위한 호환성을 위해 &lt;code&gt;::ng-deep&lt;/code&gt; 을 선호해야합니다.</target>
        </trans-unit>
        <trans-unit id="e2b9108143779ec04ceb04bcde0783f4eb419bdf" translate="yes" xml:space="preserve">
          <source>The shadow-piercing descendant combinator is deprecated and &lt;a href=&quot;https://www.chromestatus.com/features/6750456638341120&quot;&gt;support is being removed from major browsers&lt;/a&gt; and tools. As such we plan to drop support in Angular (for all 3 of &lt;code&gt;/deep/&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;::ng-deep&lt;/code&gt;). Until then &lt;code&gt;::ng-deep&lt;/code&gt; should be preferred for a broader compatibility with the tools.</source>
          <target state="translated">섀도 피어싱 하위 항목 콤비 네이터는 더 이상 사용되지 않으며 &lt;a href=&quot;https://www.chromestatus.com/features/6750456638341120&quot;&gt;주요 브라우저&lt;/a&gt; 및 도구 에서 지원이 제거됩니다 . 따라서 Angular에서 지원을 중단 할 계획입니다 ( &lt;code&gt;/deep/&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;::ng-deep&lt;/code&gt; ). 그때까지는 도구와의 광범위한 호환성을 위해 &lt;code&gt;::ng-deep&lt;/code&gt; 이 선호되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d1572bbd4b2543d39de382abeaa39b959a062225" translate="yes" xml:space="preserve">
          <source>The shim first loads the SystemJS configuration, then Angular's test support libraries, and then the application's spec files themselves.</source>
          <target state="translated">shim은 먼저 SystemJS 구성을로드 한 다음 Angular의 테스트 지원 라이브러리, 애플리케이션 사양 파일을로드합니다.</target>
        </trans-unit>
        <trans-unit id="d9c0ff4882b7ddca991893d98816e7055727d7c4" translate="yes" xml:space="preserve">
          <source>The shorthand form expands into a long form that uses the &lt;code&gt;&lt;a href=&quot;ngforof&quot;&gt;ngForOf&lt;/a&gt;&lt;/code&gt; selector on an &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; element. The content of the &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; element is the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element that held the short-form directive.</source>
          <target state="translated">속기 양식 은 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 요소 에서 &lt;code&gt;&lt;a href=&quot;ngforof&quot;&gt;ngForOf&lt;/a&gt;&lt;/code&gt; 선택기 를 사용하는 긴 양식으로 확장됩니다 . &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 요소 의 내용은 짧은 형식 지시문을 보유한 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소입니다.</target>
        </trans-unit>
        <trans-unit id="553922474ce1ca6a6f30eca0ff378d2e094bbbe1" translate="yes" xml:space="preserve">
          <source>The shorthand syntax &lt;code&gt;*&lt;a href=&quot;ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; expands into two separate template specifications for the &quot;then&quot; and &quot;else&quot; clauses. For example, consider the following shorthand statement, that is meant to show a loading page while waiting for data to be loaded.</source>
          <target state="translated">약식 구문 &lt;code&gt;*&lt;a href=&quot;ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 는 &quot;then&quot;및 &quot;else&quot;절에 대해 두 개의 개별 템플리트 스펙으로 확장됩니다. 예를 들어 데이터가로드되기를 기다리는 동안로드 페이지를 표시하기위한 다음 속기 설명을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="1c97c8ccbdc799a2ca76696b4e244bd5effa4af9" translate="yes" xml:space="preserve">
          <source>The signature registerLocaleData(data: any, extraData?: any) is deprecated since v5.1</source>
          <target state="translated">registerLocaleData (data : any, extraData ?: any) 서명은 v5.1부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="153a8913765ac20b181614adc3911db7022d20a6" translate="yes" xml:space="preserve">
          <source>The single parameter accepted is an initialization hash. Any properties of the response passed there will override the default values.</source>
          <target state="translated">허용되는 단일 매개 변수는 초기화 해시입니다. 전달 된 응답의 모든 속성은 기본값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="7ae02ec48c2aa6b29e8bf62369aed78347f97d35" translate="yes" xml:space="preserve">
          <source>The smallest grouping of display elements that can be created and destroyed together. Angular renders a view under the control of one or more &lt;a href=&quot;glossary#directive&quot;&gt;directives&lt;/a&gt;, especially &lt;a href=&quot;glossary#component&quot;&gt;component&lt;/a&gt; directives and their companion &lt;a href=&quot;glossary#template&quot;&gt;templates&lt;/a&gt;.</source>
          <target state="translated">함께 만들고 파괴 할 수있는 최소 디스플레이 요소 그룹입니다. Angular는 하나 이상의 &lt;a href=&quot;glossary#directive&quot;&gt;지시문&lt;/a&gt; , 특히 &lt;a href=&quot;glossary#component&quot;&gt;구성 요소&lt;/a&gt; 지시문 및 해당 동반자 &lt;a href=&quot;glossary#template&quot;&gt;템플릿&lt;/a&gt; 의 제어하에 뷰를 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="dd8270c38ce691281c77b7ee88227b5e7764e526" translate="yes" xml:space="preserve">
          <source>The smallest grouping of display elements that can be created and destroyed together. Angular renders a view under the control of one or more &lt;a href=&quot;glossary#directive&quot;&gt;directives&lt;/a&gt;.</source>
          <target state="translated">함께 만들고 삭제할 수있는 가장 작은 표시 요소 그룹입니다. Angular는 하나 이상의 &lt;a href=&quot;glossary#directive&quot;&gt;지시문&lt;/a&gt; 의 제어하에 뷰를 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="fd28324682f0c17450b3cf5ed2f78e84c835aa30" translate="yes" xml:space="preserve">
          <source>The sneaky spy directive is simple, consisting almost entirely of &lt;code&gt;ngOnInit()&lt;/code&gt; and &lt;code&gt;ngOnDestroy()&lt;/code&gt; hooks that log messages to the parent via an injected &lt;code&gt;LoggerService&lt;/code&gt;.</source>
          <target state="translated">몰래 스파이 지시어는 단순 하며 주입 된 &lt;code&gt;LoggerService&lt;/code&gt; 를 통해 부모에게 메시지를 기록하는 &lt;code&gt;ngOnInit()&lt;/code&gt; 및 &lt;code&gt;ngOnDestroy()&lt;/code&gt; 후크 로 거의 전적으로 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="a51977b23bb7ecc232209e8d1327212e8a3ebfb7" translate="yes" xml:space="preserve">
          <source>The source code for this tutorial and the complete &lt;em&gt;Tour of Heroes&lt;/em&gt; global styles are available in the live example.</source>
          <target state="translated">이 튜토리얼의 소스 코드와 전체 &lt;em&gt;Tour of Heroes&lt;/em&gt; 글로벌 스타일은 라이브 예제에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="197396630d371033ea63576d710b5005e3bd9ab9" translate="yes" xml:space="preserve">
          <source>The source component's injector.</source>
          <target state="translated">소스 컴포넌트의 인젝터</target>
        </trans-unit>
        <trans-unit id="26d4b7c388a1bdb518c645561859bb64e0fbf361" translate="yes" xml:space="preserve">
          <source>The source of truth provides the value and status of the form element at a given point in time. In reactive forms, the form model is the source of truth. In the example above, the form model is the &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; instance.</source>
          <target state="translated">진실의 근원은 주어진 시점에서 양식 요소의 가치와 상태를 제공합니다. 반응 형에서 양식 모델은 진실의 원천입니다. 위의 예에서 양식 모델은 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="711481c7ae759061bd5e4428a64fc27d4832dd02" translate="yes" xml:space="preserve">
          <source>The spy is designed such that any call to &lt;code&gt;getQuote&lt;/code&gt; receives an observable with a test quote. Unlike the real &lt;code&gt;getQuote()&lt;/code&gt; method, this spy bypasses the server and returns a synchronous observable whose value is available immediately.</source>
          <target state="translated">스파이는 &lt;code&gt;getQuote&lt;/code&gt; 에 대한 모든 호출 이 테스트 견적과 함께 관찰 가능 항목을 받도록 설계되었습니다 . 실제 &lt;code&gt;getQuote()&lt;/code&gt; 메서드 와 달리이 스파이는 서버를 무시하고 값을 즉시 사용할 수있는 동기식 관찰 가능 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="90b43b9097739862d0cb30d76b768225cec8d2a5" translate="yes" xml:space="preserve">
          <source>The starter app's structure looks like this:</source>
          <target state="translated">스타터 앱의 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8fa84009f343b37f2c309935ebef67d3cf1bb17d" translate="yes" xml:space="preserve">
          <source>The state name, unique within the component.</source>
          <target state="translated">구성 요소 내에서 고유 한 상태 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8ba0f66a562868f6f0949ad17ceaa5aa9040735a" translate="yes" xml:space="preserve">
          <source>The state object is defined by &lt;code&gt;&lt;a href=&quot;navigationextras&quot;&gt;NavigationExtras&lt;/a&gt;&lt;/code&gt;, and contains any developer-defined state value, as well as a unique ID that the router assigns to every router transition/navigation.</source>
          <target state="translated">상태 객체는 &lt;code&gt;&lt;a href=&quot;navigationextras&quot;&gt;NavigationExtras&lt;/a&gt;&lt;/code&gt; 에 의해 정의되며 개발자가 정의한 상태 값과 라우터가 모든 라우터 전환 / 탐색에 할당하는 고유 ID를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="94da77aa1c11c6ad0070c12223f965f714061382" translate="yes" xml:space="preserve">
          <source>The statement context may also refer to properties of the template's own context. In the following example, the component's event handling method, &lt;code&gt;onSave()&lt;/code&gt; takes the template's own &lt;code&gt;$event&lt;/code&gt; object as an argument. On the next two lines, the &lt;code&gt;deleteHero()&lt;/code&gt; method takes a &lt;a href=&quot;built-in-directives#template-input-variable&quot;&gt;template input variable&lt;/a&gt;, &lt;code&gt;hero&lt;/code&gt;, and &lt;code&gt;onSubmit()&lt;/code&gt; takes a &lt;a href=&quot;template-reference-variables&quot;&gt;template reference variable&lt;/a&gt;, &lt;code&gt;#heroForm&lt;/code&gt;.</source>
          <target state="translated">문 컨텍스트는 템플릿 자체 컨텍스트의 속성을 참조 할 수도 있습니다. 다음 예제에서 구성 요소의 이벤트 처리 메서드 인 &lt;code&gt;onSave()&lt;/code&gt; 는 템플릿의 자체 &lt;code&gt;$event&lt;/code&gt; 객체를 인수로 사용합니다. 다음 두 줄에서 &lt;code&gt;deleteHero()&lt;/code&gt; 메서드는 &lt;a href=&quot;built-in-directives#template-input-variable&quot;&gt;템플릿 입력 변수&lt;/a&gt; 인 &lt;code&gt;hero&lt;/code&gt; 를 사용하고 &lt;code&gt;onSubmit()&lt;/code&gt; 은 &lt;a href=&quot;template-reference-variables&quot;&gt;템플릿 참조 변수&lt;/a&gt; 인 &lt;code&gt;#heroForm&lt;/code&gt; 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="29682628931d961e1dc643e174f6cb46d55f3a40" translate="yes" xml:space="preserve">
          <source>The statement context may also refer to properties of the template's own context. In the following examples, the template &lt;code&gt;$event&lt;/code&gt; object, a &lt;a href=&quot;template-syntax#template-input-variable&quot;&gt;template input variable&lt;/a&gt; (&lt;code&gt;let hero&lt;/code&gt;), and a &lt;a href=&quot;template-syntax#ref-vars&quot;&gt;template reference variable&lt;/a&gt; (&lt;code&gt;#heroForm&lt;/code&gt;) are passed to an event handling method of the component.</source>
          <target state="translated">명령문 컨텍스트는 템플리트 자체 컨텍스트의 특성을 나타낼 수도 있습니다. 다음 예제에서 템플릿 &lt;code&gt;$event&lt;/code&gt; 객체, &lt;a href=&quot;template-syntax#template-input-variable&quot;&gt;템플릿 입력 변수&lt;/a&gt; ( &lt;code&gt;let hero&lt;/code&gt; ) 및 &lt;a href=&quot;template-syntax#ref-vars&quot;&gt;템플릿 참조 변수&lt;/a&gt; ( &lt;code&gt;#heroForm&lt;/code&gt; )는 구성 요소의 이벤트 처리 방법으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="ee7031536fc9f3201d33e673cc50dc352588d037" translate="yes" xml:space="preserve">
          <source>The static and resolved data of this route</source>
          <target state="translated">이 경로의 정적 및 해결 된 데이터</target>
        </trans-unit>
        <trans-unit id="6079268a1495ab3832f3c122c48c8debcb04466b" translate="yes" xml:space="preserve">
          <source>The steps are the same as using the &lt;code&gt;providers&lt;/code&gt; array, with the exception of using the &lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt; array instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt; 배열을 대신 사용하는 것을 제외하고는 단계는 &lt;code&gt;providers&lt;/code&gt; 배열 을 사용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="cebfcbb525983dfc838b3ae9b82235f2b846443b" translate="yes" xml:space="preserve">
          <source>The steps are the same as using the &lt;code&gt;providers&lt;/code&gt; array, with the exception of using the &lt;code&gt;viewProviders&lt;/code&gt; array instead.</source>
          <target state="translated">단계는 &lt;code&gt;providers&lt;/code&gt; 배열 을 사용하는 것과 동일하지만 , 대신 &lt;code&gt;viewProviders&lt;/code&gt; 배열 을 사용하는 것을 제외 하고는 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="7019f7ed50fbce076b2ffcd0fd378bb53f9230fa" translate="yes" xml:space="preserve">
          <source>The steps below outline the data flow from model to view when the &lt;code&gt;favoriteColor&lt;/code&gt; changes from &lt;em&gt;Blue&lt;/em&gt; to &lt;em&gt;Red&lt;/em&gt;.</source>
          <target state="translated">아래 단계는 &lt;code&gt;favoriteColor&lt;/code&gt; 가 &lt;em&gt;파란색&lt;/em&gt; 에서 &lt;em&gt;빨간색으로&lt;/em&gt; 변경 될 때 모델에서 데이터 흐름을 보여 줍니다.</target>
        </trans-unit>
        <trans-unit id="8f083b699a0e24cfb31552a7c5515dedc3bffa68" translate="yes" xml:space="preserve">
          <source>The steps below outline the data flow from model to view.</source>
          <target state="translated">아래 단계에서는 모델 간 데이터 흐름을 간략하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d6d931d512cd5180e215ff2bd54df9514cdbd37a" translate="yes" xml:space="preserve">
          <source>The steps below outline the data flow from view to model when the input value changes from &lt;em&gt;Red&lt;/em&gt; to &lt;em&gt;Blue&lt;/em&gt;.</source>
          <target state="translated">아래 단계에서는 입력 값이 &lt;em&gt;빨간색&lt;/em&gt; 에서 &lt;em&gt;파란색으로&lt;/em&gt; 변경 될 때 뷰에서 모델로의 데이터 흐름을 간략하게 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="cf66d9ec419458eca31557b6784e06c3d74c7302" translate="yes" xml:space="preserve">
          <source>The steps below outline the data flow from view to model.</source>
          <target state="translated">아래 단계는 뷰에서 모델로의 데이터 흐름을 간략하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="93bcd38a5f62ce5f433e4b3619e142ff10dbf2d5" translate="yes" xml:space="preserve">
          <source>The steps below show you how to do the following:</source>
          <target state="translated">아래 단계는 다음을 수행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b62b2ca3bd1da7bcd7ed67d55220aa0c687e3b42" translate="yes" xml:space="preserve">
          <source>The strategy that controls how a component is transformed in a custom element.</source>
          <target state="translated">사용자 정의 요소에서 구성 요소를 변환하는 방법을 제어하는 ​​전략입니다.</target>
        </trans-unit>
        <trans-unit id="930fe4769070145b5d1902f6b39df80e384668cc" translate="yes" xml:space="preserve">
          <source>The strategy that the default change detector uses to detect changes. When set, takes effect the next time change detection is triggered.</source>
          <target state="translated">기본 변경 감지기가 변경을 감지하는 데 사용하는 전략입니다. 설정하면 다음에 변경 감지가 트리거 될 때 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="bf8be7fcf53ea5a196bf46985745bd43109fefe5" translate="yes" xml:space="preserve">
          <source>The strict checks of the &lt;code&gt;setValue()&lt;/code&gt; method help catch nesting errors in complex forms, while &lt;code&gt;patchValue()&lt;/code&gt; fails silently on those errors.</source>
          <target state="translated">&lt;code&gt;setValue()&lt;/code&gt; 메소드 의 엄격한 검사는 복잡한 형식의 중첩 오류를 포착하는 데 도움이되는 반면 &lt;code&gt;patchValue()&lt;/code&gt; 는 해당 오류에서 자동으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="6a9ea9c73e5951ca219b42e33dc1405dd30050db" translate="yes" xml:space="preserve">
          <source>The string assigned to &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; is not a &lt;a href=&quot;interpolation&quot;&gt;template expression&lt;/a&gt;. Rather, it's a &lt;em&gt;microsyntax&lt;/em&gt;&amp;mdash;a little language of its own that Angular interprets. The string &lt;code&gt;&quot;let item of items&quot;&lt;/code&gt; means:</source>
          <target state="translated">&lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 에 할당 된 문자열 은 &lt;a href=&quot;interpolation&quot;&gt;템플릿 표현식&lt;/a&gt; 이 아닙니다 . 오히려 그것은 Angular가 해석하는 자체의 작은 언어 인 &lt;em&gt;마이크로 구문&lt;/em&gt; 입니다. &lt;code&gt;&quot;let item of items&quot;&lt;/code&gt; 문자열 은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="372bafa1bce494ea990979dd34c53dd96c7cc2ca" translate="yes" xml:space="preserve">
          <source>The string assigned to &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; is not a &lt;a href=&quot;template-syntax#template-expressions&quot;&gt;template expression&lt;/a&gt;. Rather, it's a &lt;em&gt;microsyntax&lt;/em&gt;&amp;mdash;a little language of its own that Angular interprets. The string &lt;code&gt;&quot;let &lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt; of items&quot;&lt;/code&gt; means:</source>
          <target state="translated">&lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 에 지정된 문자열 은 &lt;a href=&quot;template-syntax#template-expressions&quot;&gt;템플릿 표현식&lt;/a&gt; 이 아닙니다 . 오히려, 그것은 Angular가 해석하는 자체 언어 인 작은 &lt;em&gt;구문&lt;/em&gt; 입니다. 문자열 &lt;code&gt;&quot;let &lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt; of items&quot;&lt;/code&gt; 은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e44daa65c98054f261ccfa5f7cf11e49ee653d27" translate="yes" xml:space="preserve">
          <source>The string form of &lt;code&gt;&lt;a href=&quot;loadchildren&quot;&gt;LoadChildren&lt;/a&gt;&lt;/code&gt; is deprecated (see &lt;code&gt;&lt;a href=&quot;deprecatedloadchildren&quot;&gt;DeprecatedLoadChildren&lt;/a&gt;&lt;/code&gt;). The function form (&lt;code&gt;&lt;a href=&quot;loadchildrencallback&quot;&gt;LoadChildrenCallback&lt;/a&gt;&lt;/code&gt;) should be used instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;loadchildren&quot;&gt;LoadChildren&lt;/a&gt;&lt;/code&gt; 의 문자열 형식 은 더 이상 사용되지 않습니다 ( &lt;code&gt;&lt;a href=&quot;deprecatedloadchildren&quot;&gt;DeprecatedLoadChildren&lt;/a&gt;&lt;/code&gt; 참조 ). 대신 함수 양식 ( &lt;code&gt;&lt;a href=&quot;loadchildrencallback&quot;&gt;LoadChildrenCallback&lt;/a&gt;&lt;/code&gt; )을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c5e2186518aafc34e0de597f98ce5a35b638ef12" translate="yes" xml:space="preserve">
          <source>The string is a fixed value that you can put directly into the template.</source>
          <target state="translated">문자열은 템플릿에 직접 넣을 수있는 고정 된 값입니다.</target>
        </trans-unit>
        <trans-unit id="ee37f1eaca83dd9bb097b5466bff65a943fac485" translate="yes" xml:space="preserve">
          <source>The string to transform to lower case.</source>
          <target state="translated">소문자로 변환 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="cb45bf71782ca8d0a97a51a6af91cbb4a490dedc" translate="yes" xml:space="preserve">
          <source>The string to transform to title case.</source>
          <target state="translated">제목 대소 문자로 변환 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="417a5ce2ca98d102c22ce8871b11edab28c7f8e7" translate="yes" xml:space="preserve">
          <source>The string to transform to upper case.</source>
          <target state="translated">대문자로 변환 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="79bdda991ab152b790e3070b35eb8fda7e4c2b45" translate="yes" xml:space="preserve">
          <source>The structure of an NgModule is the same whether it is a root module or a feature module. In the CLI generated feature module, there are two JavaScript import statements at the top of the file: the first imports &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt;, which, like the root module, lets you use the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; decorator; the second imports &lt;code&gt;&lt;a href=&quot;../api/common/commonmodule&quot;&gt;CommonModule&lt;/a&gt;&lt;/code&gt;, which contributes many common directives such as &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt;. Feature modules import &lt;code&gt;&lt;a href=&quot;../api/common/commonmodule&quot;&gt;CommonModule&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt;, which is only imported once in the root module. &lt;code&gt;&lt;a href=&quot;../api/common/commonmodule&quot;&gt;CommonModule&lt;/a&gt;&lt;/code&gt; only contains information for common directives such as &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; which are needed in most templates, whereas &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt; configures the Angular app for the browser which needs to be done only once.</source>
          <target state="translated">NgModule의 구조는 루트 모듈이든 피처 모듈이든 동일합니다. CLI 생성 기능 모듈에는 파일 맨 위에 두 개의 JavaScript 가져 오기 명령문이 있습니다. 첫 번째 가져 오기 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 은 루트 모듈과 같이 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 데코레이터 를 사용할 수 있습니다 . 두 번째는 &lt;code&gt;&lt;a href=&quot;../api/common/commonmodule&quot;&gt;CommonModule&lt;/a&gt;&lt;/code&gt; 을 가져 오며 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 와 같은 많은 공통 지시문 을 제공 합니다. 피처 모듈 은 &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;../api/common/commonmodule&quot;&gt;CommonModule&lt;/a&gt;&lt;/code&gt; 을 가져옵니다 . 루트 모듈에서는 한 번만 가져옵니다 . &lt;code&gt;&lt;a href=&quot;../api/common/commonmodule&quot;&gt;CommonModule&lt;/a&gt;&lt;/code&gt; 에는 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 와 같은 공통 지시문에 대한 정보 만 포함됩니다. &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt; 은 한 번만 수행해야하는 브라우저의 Angular 앱을 구성하는 반면 대부분의 템플릿에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="de78df528fc5f787d89545140bece8187c6b8538" translate="yes" xml:space="preserve">
          <source>The stub selectors match the selectors for the corresponding real components. But their templates and classes are empty.</source>
          <target state="translated">스터브 선택기는 해당 실제 구성 요소의 선택기와 일치합니다. 그러나 템플릿과 클래스는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2d59788c70b71518e84d399dc1f8c1b1995a79e" translate="yes" xml:space="preserve">
          <source>The styles specified in &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; metadata &lt;em&gt;apply only within the template of that component&lt;/em&gt;.</source>
          <target state="translated">에 지정된 스타일 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; 메타 데이터 &lt;em&gt;에만 해당 구성 요소의 템플릿 내에서 적용됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f48dea481324aa0b7a7a250484ea3649910069fd" translate="yes" xml:space="preserve">
          <source>The suggested polyfills are the ones that run full Angular applications. You may need additional polyfills to support features not covered by this list. Note that polyfills cannot magically transform an old, slow browser into a modern, fast one.</source>
          <target state="translated">제안 된 폴리 필은 전체 각도 응용 프로그램을 실행하는 폴리 필입니다. 이 목록에서 다루지 않는 기능을 지원하려면 추가 폴리 필이 필요할 수 있습니다. 폴리 필은 오래되고 느린 브라우저를 현대적이고 빠른 브라우저로 마술처럼 변형시킬 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="629cf41ae2bb443d131c775aab136684c9761d9b" translate="yes" xml:space="preserve">
          <source>The switch directives are particularly useful for adding and removing &lt;em&gt;component elements&lt;/em&gt;. This example switches among four &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; components defined in the &lt;code&gt;item-switch.components.ts&lt;/code&gt; file. Each component has an &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt;&lt;a href=&quot;template-syntax#inputs-outputs&quot;&gt;input property&lt;/a&gt; which is bound to the &lt;code&gt;currentItem&lt;/code&gt; of the parent component.</source>
          <target state="translated">스위치 지시문은 특히 &lt;em&gt;구성 요소&lt;/em&gt; 를 추가하고 제거하는 데 유용합니다 . 이 예 에서는 &lt;code&gt;item-switch.components.ts&lt;/code&gt; 파일에 정의 된 4 개의 &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; 구성 요소 간에 전환 합니다. 각 컴포넌트에는 상위 컴포넌트 의 &lt;code&gt;currentItem&lt;/code&gt; 에 바인딩 된 &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;template-syntax#inputs-outputs&quot;&gt; 입력 특성&lt;/a&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a89ade83ec04e3798353f8fcdcde955060d9b066" translate="yes" xml:space="preserve">
          <source>The switch directives are particularly useful for adding and removing &lt;em&gt;component elements&lt;/em&gt;. This example switches among four &lt;code&gt;item&lt;/code&gt; components defined in the &lt;code&gt;item-switch.components.ts&lt;/code&gt; file. Each component has an &lt;code&gt;item&lt;/code&gt;&lt;a href=&quot;inputs-outputs#input&quot;&gt;input property&lt;/a&gt; which is bound to the &lt;code&gt;currentItem&lt;/code&gt; of the parent component.</source>
          <target state="translated">스위치 지시문은 &lt;em&gt;구성 요소&lt;/em&gt; 를 추가하고 제거하는 데 특히 유용합니다 . 이 예제 는 &lt;code&gt;item-switch.components.ts&lt;/code&gt; 파일에 정의 된 네 가지 &lt;code&gt;item&lt;/code&gt; 구성 요소 사이를 전환 합니다. 각 구성 요소에는 상위 구성 요소 의 &lt;code&gt;currentItem&lt;/code&gt; 에 바인딩 된 &lt;code&gt;item&lt;/code&gt; &lt;a href=&quot;inputs-outputs#input&quot;&gt;입력 속성&lt;/a&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb1898cd24b327b717bb4aef090ad4e9542fafed" translate="yes" xml:space="preserve">
          <source>The switch from the &lt;em&gt;local variable&lt;/em&gt; to the &lt;em&gt;ViewChild&lt;/em&gt; technique is solely for the purpose of demonstration.</source>
          <target state="translated">&lt;em&gt;로컬 변수&lt;/em&gt; 에서 &lt;em&gt;ViewChild&lt;/em&gt; 기술로 의 전환 은 데모 목적으로 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="40988748687c9ee6daa755f997551a5b4a1441e8" translate="yes" xml:space="preserve">
          <source>The switch value assigned to &lt;code&gt;&lt;a href=&quot;../api/common/ngswitch&quot;&gt;NgSwitch&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;hero.emotion&lt;/code&gt;) determines which (if any) of the switch cases are displayed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/common/ngswitch&quot;&gt;NgSwitch&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;hero.emotion&lt;/code&gt; )에 지정된 스위치 값 은 표시되는 스위치 케이스 (있는 경우)를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="9a62c528f0a931f89b2287d8a503aed1f8009829" translate="yes" xml:space="preserve">
          <source>The symbol to localize.</source>
          <target state="translated">현지화 할 기호입니다.</target>
        </trans-unit>
        <trans-unit id="4ed679bf2daa47968c73d3b3701e2547464b78f8" translate="yes" xml:space="preserve">
          <source>The synchronous &lt;em&gt;beforeEach&lt;/em&gt;</source>
          <target state="translated">동기적인 &lt;em&gt;beforeEach&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="abbd548fb3da1a05f8609c8a3757af73c0e7704c" translate="yes" xml:space="preserve">
          <source>The synchronous validators registered with this group.</source>
          <target state="translated">이 그룹에 등록 된 동기 유효성 검증기</target>
        </trans-unit>
        <trans-unit id="d372dcb466775574685c3fae862c265b2b17aef2" translate="yes" xml:space="preserve">
          <source>The syntax in this example is as follows:</source>
          <target state="translated">이 예제의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e8b4d98df92da09eb34184a7a9efa8bfa65588d" translate="yes" xml:space="preserve">
          <source>The syntax may seem strange to you but users are unlikely to notice or care as long as the URL can be emailed and pasted into a browser address bar as this one can.</source>
          <target state="translated">구문이 이상하게 보일지 모르지만 URL을 이메일로 보내서 브라우저 주소 표시 줄에 붙여 넣을 수있는 한 사용자는주의를 기울이거나주의를 기울이지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="5f242d259e92ca5a53c10705d273887b830471cd" translate="yes" xml:space="preserve">
          <source>The table below summarizes the key differences between reactive and template-driven forms.</source>
          <target state="translated">아래 표에는 반응 형과 템플릿 기반 양식의 주요 차이점이 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c4e7caf543ca7199e467fdb0d9c36eb0a217ab0" translate="yes" xml:space="preserve">
          <source>The tabs in the following example demonstrates toggling between two different formats (&lt;code&gt;'shortDate'&lt;/code&gt; and &lt;code&gt;'fullDate'&lt;/code&gt;):</source>
          <target state="translated">다음 예제의 탭은 서로 다른 두 형식 ( &lt;code&gt;'shortDate'&lt;/code&gt; 및 &lt;code&gt;'fullDate'&lt;/code&gt; ) 간 전환을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="220ad8eac98ea25feaee853e9a31ab932f922b98" translate="yes" xml:space="preserve">
          <source>The tag attribute and value to match against, in the format &lt;code&gt;&quot;tag_attribute='value string'&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;tag_attribute='value string'&quot;&lt;/code&gt; 형식으로 일치시킬 태그 속성 및 값 입니다.</target>
        </trans-unit>
        <trans-unit id="d90e8518f65ddbaf9cd91f81cdabaaf8afb11625" translate="yes" xml:space="preserve">
          <source>The tag definition to match against to identify an existing tag.</source>
          <target state="translated">기존 태그를 식별하기 위해 일치시킬 태그 정의입니다.</target>
        </trans-unit>
        <trans-unit id="dfe05f51b185acbf840147ce35d32d01c530d4c8" translate="yes" xml:space="preserve">
          <source>The tag description with which to replace the existing tag content.</source>
          <target state="translated">기존 태그 콘텐츠를 대체 할 태그 설명입니다.</target>
        </trans-unit>
        <trans-unit id="08365a3c201aa0c652bb798a6188518150b14a2a" translate="yes" xml:space="preserve">
          <source>The target event determines the shape of the &lt;code&gt;$event&lt;/code&gt; object. If the target event is a native DOM element event, then &lt;code&gt;$event&lt;/code&gt; is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;DOM event object&lt;/a&gt;, with properties such as &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkwithhref#target&quot;&gt;target&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;target.value&lt;/code&gt;.</source>
          <target state="translated">대상 이벤트는 &lt;code&gt;$event&lt;/code&gt; 객체 의 모양을 결정 합니다. 대상 이벤트가 기본 DOM 요소 이벤트 인 경우 &lt;code&gt;$event&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkwithhref#target&quot;&gt;target&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;target.value&lt;/code&gt; 와 같은 특성을 가진 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;DOM 이벤트 오브젝트&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="204c978751f63d09d4d7fdfadbc1e4791b804461" translate="yes" xml:space="preserve">
          <source>The target event determines the shape of the &lt;code&gt;$event&lt;/code&gt; object. If the target event is a native DOM element event, then &lt;code&gt;$event&lt;/code&gt; is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;DOM event object&lt;/a&gt;, with properties such as &lt;code&gt;target&lt;/code&gt; and &lt;code&gt;target.value&lt;/code&gt;.</source>
          <target state="translated">대상 이벤트는 &lt;code&gt;$event&lt;/code&gt; 개체 의 모양을 결정 합니다. 대상 이벤트가 기본 DOM 요소 이벤트 인 경우 &lt;code&gt;$event&lt;/code&gt; 는 &lt;code&gt;target&lt;/code&gt; 및 &lt;code&gt;target.value&lt;/code&gt; 와 같은 속성 이있는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events&quot;&gt;DOM 이벤트 객체&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="088749979b09bfd46d68e94f37fbfac7f9f02497" translate="yes" xml:space="preserve">
          <source>The target in the square brackets, &lt;code&gt;[]&lt;/code&gt;, is the property you decorate with &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; in the child component. The binding source, the part to the right of the equal sign, is the data that the parent component passes to the nested component.</source>
          <target state="translated">대괄호 &lt;code&gt;[]&lt;/code&gt; 의 대상 은 자식 구성 요소에서 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 으로 장식하는 속성 입니다. 등호 오른쪽에있는 바인딩 소스는 부모 구성 요소가 중첩 구성 요소에 전달하는 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="ea8a5033f54ae9c4081d5ab74a38829cd1975b5f" translate="yes" xml:space="preserve">
          <source>The target named &quot;touch&quot; uses our builder, which we published to &lt;code&gt;@example/command-runner&lt;/code&gt;. (See &lt;a href=&quot;creating-libraries#publishing-your-library&quot;&gt;Publishing your Library&lt;/a&gt;)</source>
          <target state="translated">&quot;touch&quot;라는 대상은 빌더를 사용하며 &lt;code&gt;@example/command-runner&lt;/code&gt; 게시했습니다 . ( &lt;a href=&quot;creating-libraries#publishing-your-library&quot;&gt;도서관 공개&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="83189c190de1ae321a2890e3cde83b83c7039a71" translate="yes" xml:space="preserve">
          <source>The target property accepts a string value.</source>
          <target state="translated">대상 속성은 문자열 값을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="9803929ad21484881b4d3f6acabd34faf9ef3af2" translate="yes" xml:space="preserve">
          <source>The target to apply service worker to.</source>
          <target state="translated">서비스 워커를 적용 할 대상입니다.</target>
        </trans-unit>
        <trans-unit id="758b33e79798a18b4b5d7ce28a40f40423430f66" translate="yes" xml:space="preserve">
          <source>The target to apply web worker to.</source>
          <target state="translated">웹 워커를 적용 할 대상입니다.</target>
        </trans-unit>
        <trans-unit id="4832cdf5716df7acd57fe0ac87672a04e59ff3aa" translate="yes" xml:space="preserve">
          <source>The target, &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt;, which is an &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; property in the child component class, receives its value from the parent's property, &lt;code&gt;currentItem&lt;/code&gt;. When you click delete, the child component raises an event, &lt;code&gt;deleteRequest&lt;/code&gt;, which is the argument for the parent's &lt;code&gt;crossOffItem()&lt;/code&gt; method.</source>
          <target state="translated">자식 구성 요소 클래스 의 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt; () 속성 인 대상 &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; 은 부모 속성 인 &lt;code&gt;currentItem&lt;/code&gt; 으로부터 값을받습니다 . delete를 클릭하면 자식 구성 요소 는 부모의 &lt;code&gt;crossOffItem()&lt;/code&gt; 메서드에 대한 인수 인 &lt;code&gt;deleteRequest&lt;/code&gt; 이벤트 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="fba0b19cd787422e1cf01da19ec8f25d07cada93" translate="yes" xml:space="preserve">
          <source>The target, &lt;code&gt;item&lt;/code&gt;, which is an &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; property in the child component class, receives its value from the parent's property, &lt;code&gt;currentItem&lt;/code&gt;. When you click delete, the child component raises an event, &lt;code&gt;deleteRequest&lt;/code&gt;, which is the argument for the parent's &lt;code&gt;crossOffItem()&lt;/code&gt; method.</source>
          <target state="translated">자식 구성 요소 클래스 의 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt; () 속성 인 대상 &lt;code&gt;item&lt;/code&gt; 은 부모 속성 &lt;code&gt;currentItem&lt;/code&gt; 에서 해당 값을받습니다 . 삭제를 클릭하면 자식 구성 요소가 부모의 &lt;code&gt;crossOffItem()&lt;/code&gt; 메서드에 대한 인수 인 &lt;code&gt;deleteRequest&lt;/code&gt; 이벤트 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="4f1ff5014d8414a2f274237e4b393821bcc007a8" translate="yes" xml:space="preserve">
          <source>The technique is particularly useful when you have a type of form whose content must change frequently to meet rapidly changing business and regulatory requirements. A typical use case is a questionaire. You might need to get input from users in different contexts. The format and style of the forms a user sees should remain constant, while the actual questions you need to ask vary with the context.</source>
          <target state="translated">이 기술은 빠르게 변화하는 비즈니스 및 규제 요구 사항을 충족하기 위해 콘텐츠를 자주 변경해야하는 양식 유형이있는 경우 특히 유용합니다. 일반적인 사용 사례는 설문지입니다. 다른 컨텍스트의 사용자로부터 입력을 받아야 할 수도 있습니다. 사용자가 보는 양식의 형식과 스타일은 일정하게 유지되어야하며 실제 질문은 상황에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="cd2fa7e7402ff15d8269c74078e6ca3033630d4e" translate="yes" xml:space="preserve">
          <source>The telltale signs of &lt;em&gt;content projection&lt;/em&gt; are twofold:</source>
          <target state="translated">&lt;em&gt;콘텐츠 프로젝션의 주요&lt;/em&gt; 징후 는 두 가지입니다.</target>
        </trans-unit>
        <trans-unit id="5e77a452f056e2f53277faeefa0476eb5ee812b2" translate="yes" xml:space="preserve">
          <source>The template (&lt;code&gt;flying-heroes.component.html (flyers)&lt;/code&gt;) with the new pipe.</source>
          <target state="translated">새 파이프가있는 템플릿 ( &lt;code&gt;flying-heroes.component.html (flyers)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e2a40647498302ae30e3c37d356dbc6aee8a2f1c" translate="yes" xml:space="preserve">
          <source>The template and style filenames reference the HTML and CSS files that StackBlitz generates.</source>
          <target state="translated">템플릿 및 스타일 파일 이름은 StackBlitz가 생성하는 HTML 및 CSS 파일을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="c4786e4078a2207abe9c4cfa9d1d9cf3ab9a3992" translate="yes" xml:space="preserve">
          <source>The template associated with a component binds an animation trigger to an element.</source>
          <target state="translated">구성 요소와 연결된 템플릿은 애니메이션 트리거를 요소에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="7456b59897a0fe9f7fab60b1fd5714f118ee168e" translate="yes" xml:space="preserve">
          <source>The template associated with this component makes use of the defined trigger by binding to an element within its template code.</source>
          <target state="translated">이 컴포넌트와 연관된 템플리트는 템플리트 코드 내의 요소에 바인딩하여 정의 된 트리거를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ad2640340c3b2204b3e2187d3156835ccc870fd9" translate="yes" xml:space="preserve">
          <source>The template displays the two component properties using double curly brace interpolation:</source>
          <target state="translated">템플릿은 이중 중괄호 보간을 사용하여 두 가지 구성 요소 속성을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="576bb8173300bc75c8165cf5e1686bbdae4c4807" translate="yes" xml:space="preserve">
          <source>The template expression inside the double quotes, &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;=&quot;heroes.length &amp;gt; 3&quot;&lt;/code&gt;, looks and behaves much like TypeScript. When the component's list of heroes has more than three items, Angular adds the paragraph to the DOM and the message appears. If there are three or fewer items, Angular omits the paragraph, so no message appears. For more information, see the &lt;a href=&quot;template-syntax#template-expressions&quot;&gt;template expressions&lt;/a&gt; section of the &lt;a href=&quot;template-syntax&quot;&gt;Template Syntax&lt;/a&gt; page.</source>
          <target state="translated">큰 따옴표 안의 템플릿 표현식 &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;=&quot;heroes.length &amp;gt; 3&quot;&lt;/code&gt; 은 TypeScript와 매우 유사하게 보이고 동작합니다. 구성 요소의 영웅 목록에 3 개 이상의 항목이 있으면 Angular는 단락을 DOM에 추가하고 메시지가 나타납니다. 항목이 3 개 이하인 경우 Angular는 단락을 생략하므로 메시지가 나타나지 않습니다. 자세한 내용 은 &lt;a href=&quot;template-syntax&quot;&gt;템플릿 구문&lt;/a&gt; 페이지 의 &lt;a href=&quot;template-syntax#template-expressions&quot;&gt;템플릿 표현식&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="06a26eec315b228b84cdf45c3df4a6172bf6d5de" translate="yes" xml:space="preserve">
          <source>The template expression should evaluate to the type of value that the target property expects. Return a string if the target property expects a string, a number if it expects a number, an object if it expects an object, and so on.</source>
          <target state="translated">템플릿 표현식은 대상 속성에 필요한 값 유형으로 평가해야합니다. 대상 속성에 문자열이 필요한 경우 문자열, 숫자가 필요한 경우 숫자, 개체가 필요한 경우 개체 등을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ac5e4c5de5dc648043bccd61180f0f506003d6cf" translate="yes" xml:space="preserve">
          <source>The template expression to the right of the equal sign, &lt;code&gt;=&lt;/code&gt;, contains a space-delimited string of CSS classes that the Router adds when this link is active (and removes when the link is inactive). You set the &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive&quot;&gt;RouterLinkActive&lt;/a&gt;&lt;/code&gt; directive to a string of classes such as &lt;code&gt;[&lt;a href=&quot;../api/router/routerlinkactive&quot;&gt;routerLinkActive&lt;/a&gt;]=&quot;'active fluffy'&quot;&lt;/code&gt; or bind it to a component property that returns such a string.</source>
          <target state="translated">등호 &lt;code&gt;=&lt;/code&gt; 의 오른쪽에있는 템플릿 표현식 에는이 링크가 활성화 될 때 라우터가 추가하는 (그리고 링크가 비활성화 될 때 제거되는) CSS 클래스의 공백으로 구분 된 문자열이 포함됩니다. &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive&quot;&gt;RouterLinkActive&lt;/a&gt;&lt;/code&gt; 지시문을 &lt;code&gt;[&lt;a href=&quot;../api/router/routerlinkactive&quot;&gt;routerLinkActive&lt;/a&gt;]=&quot;'active fluffy'&quot;&lt;/code&gt; 와 같은 클래스 문자열로 설정 하거나 이러한 문자열을 반환하는 구성 요소 속성에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="c2d8c395975bbaf307f8b6ad3d0e90daae25b98a" translate="yes" xml:space="preserve">
          <source>The template expression to the right of the equals (=) contains a space-delimited string of CSS classes that the Router will add when this link is active (and remove when the link is inactive). You set the &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive&quot;&gt;RouterLinkActive&lt;/a&gt;&lt;/code&gt; directive to a string of classes such as &lt;code&gt;[&lt;a href=&quot;../api/router/routerlinkactive&quot;&gt;routerLinkActive&lt;/a&gt;]=&quot;'active fluffy'&quot;&lt;/code&gt; or bind it to a component property that returns such a string.</source>
          <target state="translated">등호 (=)의 오른쪽에있는 템플리트 표현식에는 공백으로 구분 된 CSS 클래스 문자열이 포함되어 있습니다. CSS 링크는이 링크가 활성화 될 때 추가되고 링크가 비활성화되면 제거됩니다. &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive&quot;&gt;RouterLinkActive&lt;/a&gt;&lt;/code&gt; 지시문을 &lt;code&gt;[&lt;a href=&quot;../api/router/routerlinkactive&quot;&gt;routerLinkActive&lt;/a&gt;]=&quot;'active fluffy'&quot;&lt;/code&gt; 와 같은 클래스 문자열로 설정 하거나 이러한 문자열을 리턴하는 컴포넌트 특성에 바인드하십시오.</target>
        </trans-unit>
        <trans-unit id="c4a5ffd1d833be7be8234c4da4123676ff8d6c69" translate="yes" xml:space="preserve">
          <source>The template input elements do &lt;em&gt;not&lt;/em&gt; use &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">템플릿 입력 요소는 &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 을 사용 하지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e42a3efc7ee16d8ee04f26132d4fe495e4010874" translate="yes" xml:space="preserve">
          <source>The template is a multi-line string within ECMAScript 2015 backticks (&lt;code&gt;`&lt;/code&gt;). The backtick (&lt;code&gt;`&lt;/code&gt;)&amp;mdash;which is &lt;em&gt;not&lt;/em&gt; the same character as a single quote (&lt;code&gt;'&lt;/code&gt;)&amp;mdash;allows you to compose a string over several lines, which makes the HTML more readable.</source>
          <target state="translated">템플릿은 ECMAScript 2015 백틱 ( &lt;code&gt;`&lt;/code&gt; ) 내의 여러 줄 문자열 입니다. 작은 따옴표 ( &lt;code&gt;'&lt;/code&gt; ) 와 같은 문자 가 &lt;em&gt;아닌&lt;/em&gt; 역 따옴표 ( &lt;code&gt;`&lt;/code&gt; ) 를 사용하면 여러 줄에 걸쳐 문자열을 작성할 수있어 HTML을 더 읽기 쉽게 만들 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3bfaca46091594f4d1d50328af755b641a1f6fb4" translate="yes" xml:space="preserve">
          <source>The template is compiled within the context of an NgModule&amp;mdash;the NgModule within which the template's component is declared&amp;mdash;which determines the set of selectors using the following rules:</source>
          <target state="translated">템플릿은 NgModule (템플릿의 구성 요소가 선언 된 NgModule)의 컨텍스트 내에서 컴파일되어 다음 규칙을 사용하여 선택기 세트를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="08d9755e408a260636b09bfef92316faea44cef4" translate="yes" xml:space="preserve">
          <source>The template is completely self contained. It doesn't bind to the component, and the component does nothing.</source>
          <target state="translated">템플릿은 완전히 자체 포함되어 있습니다. 구성 요소에 바인딩되지 않으며 구성 요소가 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70313244a4cd1e80d96df911743747c5b1d0a1c0" translate="yes" xml:space="preserve">
          <source>The template options object, &lt;code&gt;angularCompilerOptions&lt;/code&gt;, is a sibling to the &lt;code&gt;compilerOptions&lt;/code&gt; object that supplies standard options to the TypeScript compiler.</source>
          <target state="translated">템플릿 옵션 객체 인 &lt;code&gt;angularCompilerOptions&lt;/code&gt; 는 TypeScript 컴파일러에 표준 옵션을 제공 하는 &lt;code&gt;compilerOptions&lt;/code&gt; 객체 의 형제 입니다.</target>
        </trans-unit>
        <trans-unit id="3b72560eddb355fd40b07d7d81925030a83c57a2" translate="yes" xml:space="preserve">
          <source>The template reference variable (&lt;code&gt;#name&lt;/code&gt;) is set to &lt;code&gt;&quot;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&quot;&lt;/code&gt; because that is the value of the &lt;a href=&quot;../api/core/directive#exportAs&quot;&gt;&lt;code&gt;NgModel.exportAs&lt;/code&gt;&lt;/a&gt; property. This property tells Angular how to link a reference variable to a directive.</source>
          <target state="translated">템플릿 참조 변수 ( &lt;code&gt;#name&lt;/code&gt; )는 &lt;a href=&quot;../api/core/directive#exportAs&quot;&gt; &lt;code&gt;NgModel.exportAs&lt;/code&gt; &lt;/a&gt; 속성 의 값이기 때문에 &lt;code&gt;&quot;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&quot;&lt;/code&gt; 설정됩니다 . 이 속성은 참조 변수를 지시문에 연결하는 방법을 Angular에 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="51b07ca66a0c80d8a3f63013141583e49737c085" translate="yes" xml:space="preserve">
          <source>The template reference variable named &lt;code&gt;box&lt;/code&gt;, declared on the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element, refers to the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element itself. The code uses the &lt;code&gt;box&lt;/code&gt; variable to get the input element's &lt;code&gt;value&lt;/code&gt; and display it with interpolation between &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; tags.</source>
          <target state="translated">&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 요소 에 선언 된 &lt;code&gt;box&lt;/code&gt; 라는 템플리트 참조 변수 는 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 요소 자체를 참조합니다. 이 코드는 &lt;code&gt;box&lt;/code&gt; 변수를 사용하여 입력 요소의 &lt;code&gt;value&lt;/code&gt; 을 가져 와서 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 태그 사이의 보간으로 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="be99d9963797c6d6b4d78974ccde065adf89a39f" translate="yes" xml:space="preserve">
          <source>The template syntax guides show you how you can control the UX/UI by coordinating data between the class and the template.</source>
          <target state="translated">템플릿 구문 가이드는 클래스와 템플릿간에 데이터를 조정하여 UX / UI를 제어하는 ​​방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="de2262f6eff650096d5ec2a922c11474976de6e1" translate="yes" xml:space="preserve">
          <source>The template syntax provides specialized one-way bindings for scenarios less well-suited to property binding.</source>
          <target state="translated">템플릿 구문은 속성 바인딩에 적합하지 않은 시나리오를위한 특수한 단방향 바인딩을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="083a3f1dd8ef9b722e60e2598176af5110f9dbf5" translate="yes" xml:space="preserve">
          <source>The test assumes (correctly in this case) that the runtime event handler&amp;mdash;the component's &lt;code&gt;click()&lt;/code&gt; method&amp;mdash;doesn't care about the event object.</source>
          <target state="translated">테스트에서는 런타임 이벤트 핸들러 &lt;code&gt;click()&lt;/code&gt; 구성 요소의 click () 메소드 ) 가 이벤트 객체를 신경 쓰지 않는다고 가정합니다 (이 경우에는 올바르게 ) .</target>
        </trans-unit>
        <trans-unit id="3fee678255a89c608b1621887a0565d3703b71c4" translate="yes" xml:space="preserve">
          <source>The test configuration can use the &lt;code&gt;SharedModule&lt;/code&gt; too as seen in this alternative setup:</source>
          <target state="translated">테스트 &lt;code&gt;SharedModule&lt;/code&gt; 이 대체 설정에서 볼 수있는 것처럼 SharedModule을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b3f7b35cc6454035e62b2373f127b23cbdae65d" translate="yes" xml:space="preserve">
          <source>The test consumes that spy in the same way it did earlier.</source>
          <target state="translated">테스트는 이전과 같은 방식으로 스파이를 소비합니다.</target>
        </trans-unit>
        <trans-unit id="64d8dd78adadc9a255e228a4c2bdbf4eb2d5cae3" translate="yes" xml:space="preserve">
          <source>The test detects that event through its subscription to &lt;code&gt;selected&lt;/code&gt;.</source>
          <target state="translated">테스트는 &lt;code&gt;selected&lt;/code&gt; 에 대한 구독을 통해 해당 이벤트를 감지합니다 .</target>
        </trans-unit>
        <trans-unit id="8a9ff9ce0ff2aea3ea5d9b5e4c05171faa52806f" translate="yes" xml:space="preserve">
          <source>The test fails when the &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; tries to create the component.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; 가 구성 요소를 작성하려고 시도 하면 테스트에 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="dc61697c7a24dc30137c8a1be726e1064a8ae44b" translate="yes" xml:space="preserve">
          <source>The test file extension &lt;strong&gt;must be &lt;code&gt;.spec.ts&lt;/code&gt;&lt;/strong&gt; so that tooling can identify it as a file with tests (AKA, a &lt;em&gt;spec&lt;/em&gt; file).</source>
          <target state="translated">툴링 이 테스트 파일 (AKA, &lt;em&gt;스펙&lt;/em&gt; 파일) 로 식별 할 수 있도록 테스트 파일 확장자 &lt;strong&gt;는 &lt;code&gt;.spec.ts&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; 여야합니다&lt;/strong&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e1c2770aafe4156298be6944b33c74e2f41bc2b8" translate="yes" xml:space="preserve">
          <source>The test host sets the component's &lt;code&gt;hero&lt;/code&gt; input property with its test hero. It binds the component's &lt;code&gt;selected&lt;/code&gt; event with its &lt;code&gt;onSelected&lt;/code&gt; handler, which records the emitted hero in its &lt;code&gt;selectedHero&lt;/code&gt; property.</source>
          <target state="translated">테스트 호스트는 구성 요소의 &lt;code&gt;hero&lt;/code&gt; 입력 속성을 테스트 히어로로 설정합니다. 구성 요소의 &lt;code&gt;selected&lt;/code&gt; 이벤트를 &lt;code&gt;onSelected&lt;/code&gt; 핸들러 와 바인딩합니다.이 핸들러는 &lt;code&gt;selectedHero&lt;/code&gt; 속성 에 방출 된 영웅을 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="fb31db149beae9a822efe838f27bfc240e01968b" translate="yes" xml:space="preserve">
          <source>The test must wait for the &lt;code&gt;getQuote()&lt;/code&gt; observable to emit the next quote. Instead of calling &lt;a href=&quot;../api/core/testing/tick&quot;&gt;tick()&lt;/a&gt;, it calls &lt;code&gt;fixture.whenStable()&lt;/code&gt;.</source>
          <target state="translated">테스트는 &lt;code&gt;getQuote()&lt;/code&gt; 이 다음 따옴표를 방출 할 때까지 기다려야합니다 . &lt;a href=&quot;../api/core/testing/tick&quot;&gt;tick ()&lt;/a&gt; 을 호출하는 대신 &lt;code&gt;fixture.whenStable()&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3f2fe2155132bb0d67244809298ea98ce16fe29e" translate="yes" xml:space="preserve">
          <source>The test must wait for the &lt;code&gt;getQuote()&lt;/code&gt; observable to emit the next quote. Instead of calling &lt;code&gt;&lt;a href=&quot;../api/core/applicationref#tick&quot;&gt;tick()&lt;/a&gt;&lt;/code&gt;, it calls &lt;code&gt;fixture.whenStable()&lt;/code&gt;.</source>
          <target state="translated">테스트는 &lt;code&gt;getQuote()&lt;/code&gt; 이 다음 인용문을 방출 할 때까지 기다려야합니다 . &lt;code&gt;&lt;a href=&quot;../api/core/applicationref#tick&quot;&gt;tick()&lt;/a&gt;&lt;/code&gt; 을 호출하는 대신 &lt;code&gt;fixture.whenStable()&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="eae43c82340aebd9536a260fd2377f5061a497ef" translate="yes" xml:space="preserve">
          <source>The test resumes within the promise callback, which calls &lt;code&gt;&lt;a href=&quot;../api/core/testing/componentfixture#detectChanges&quot;&gt;detectChanges()&lt;/a&gt;&lt;/code&gt; to update the quote element with the expected text.</source>
          <target state="translated">promise 콜백 내에서 테스트가 다시 시작됩니다.이 콜백에서는 &lt;code&gt;&lt;a href=&quot;../api/core/testing/componentfixture#detectChanges&quot;&gt;detectChanges()&lt;/a&gt;&lt;/code&gt; 를 호출 하여 quote 요소를 예상 텍스트로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="6513a6033669aff320e259d0c6833fb95d1491eb" translate="yes" xml:space="preserve">
          <source>The test resumes within the promise callback, which calls &lt;code&gt;detectChanges()&lt;/code&gt; to update the quote element with the expected text.</source>
          <target state="translated">테스트는 promise 콜백 내에서 재개되며 &lt;code&gt;detectChanges()&lt;/code&gt; 를 호출 하여 예상 텍스트로 quote 요소를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="9991de36b4ebc0ec198e7d693844d908feef9de2" translate="yes" xml:space="preserve">
          <source>The test suite setup provided the same router spy &lt;a href=&quot;testing#routing-component&quot;&gt;described above&lt;/a&gt; which spies on the router without actually navigating.</source>
          <target state="translated">테스트 스위트 설정은 실제로 탐색하지 않고 라우터를 감시 &lt;a href=&quot;testing#routing-component&quot;&gt;하는 위에서 설명한&lt;/a&gt; 동일한 라우터 스파이를 제공했습니다 .</target>
        </trans-unit>
        <trans-unit id="26c2531c64b39001e8bbe987859331ff8589c07b" translate="yes" xml:space="preserve">
          <source>The test suite setup provided the same router spy &lt;a href=&quot;testing-components-scenarios#routing-component&quot;&gt;described above&lt;/a&gt; which spies on the router without actually navigating.</source>
          <target state="translated">테스트 스위트 설정은 실제로 탐색하지 않고 라우터를 스파이 &lt;a href=&quot;testing-components-scenarios#routing-component&quot;&gt;하는 위에서 설명한&lt;/a&gt; 것과 동일한 라우터 스파이를 제공했습니다 .</target>
        </trans-unit>
        <trans-unit id="6e4274a8f1842c774f28cff1fab41deb042b588a" translate="yes" xml:space="preserve">
          <source>The test triggered a &quot;click&quot; event with a &lt;code&gt;null&lt;/code&gt; event object.</source>
          <target state="translated">테스트에서 &lt;code&gt;null&lt;/code&gt; 이벤트 오브젝트 가있는 &quot;click&quot;이벤트가 트리거되었습니다 .</target>
        </trans-unit>
        <trans-unit id="7fc3193a4fa820f2db5a35cc3a595865239a463f" translate="yes" xml:space="preserve">
          <source>The testing documentation offers tips and techniques for unit and integration testing Angular applications through a sample application created with the &lt;a href=&quot;cli&quot;&gt;Angular CLI&lt;/a&gt;. This sample application is much like the one in the &lt;a href=&quot;tutorial&quot;&gt;&lt;em&gt;Tour of Heroes&lt;/em&gt; tutorial&lt;/a&gt;.</source>
          <target state="translated">테스트 문서는 &lt;a href=&quot;cli&quot;&gt;Angular CLI로&lt;/a&gt; 만든 샘플 애플리케이션을 통해 Angular 애플리케이션의 단위 및 통합 테스트를위한 팁과 기술을 제공합니다 . 이 샘플 애플리케이션은 &lt;a href=&quot;tutorial&quot;&gt;&lt;em&gt;Tour of Heroes&lt;/em&gt; 튜토리얼 &lt;em&gt;의&lt;/em&gt;&lt;/a&gt; 애플리케이션과 매우 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="64322dc55f479cb397712aa1ca434f09788d33d9" translate="yes" xml:space="preserve">
          <source>The testing goal is to verify that such bindings work as expected. The tests should set input values and listen for output events.</source>
          <target state="translated">테스트 목표는 이러한 바인딩이 예상대로 작동하는지 확인하는 것입니다. 테스트는 입력 값을 설정하고 출력 이벤트를 수신해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e2010246d07d1175ff55b50a4ac15be59351555" translate="yes" xml:space="preserve">
          <source>The testing shims (&lt;code&gt;karma-test-shim&lt;/code&gt;, &lt;code&gt;browser-test-shim&lt;/code&gt;) call it for you so there is rarely a reason for you to call it yourself.</source>
          <target state="translated">테스트 심 ( &lt;code&gt;karma-test-shim&lt;/code&gt; , &lt;code&gt;browser-test-shim&lt;/code&gt; ) 이이 를 호출하므로 직접 호출 할 이유가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="148b2781f0537830461040ebc4675f60de170e4e" translate="yes" xml:space="preserve">
          <source>The testing shims (&lt;code&gt;karma-test-shim&lt;/code&gt;, &lt;code&gt;browser-test-shim&lt;/code&gt;) establish the &lt;a href=&quot;testing&quot;&gt;initial test environment&lt;/a&gt; and a default testing module. The default testing module is configured with basic declaratives and some Angular service substitutes that every tester needs.</source>
          <target state="translated">테스트 심 ( &lt;code&gt;karma-test-shim&lt;/code&gt; , &lt;code&gt;browser-test-shim&lt;/code&gt; )은 &lt;a href=&quot;testing&quot;&gt;초기 테스트 환경&lt;/a&gt; 과 기본 테스트 모듈을 설정합니다. 기본 테스트 모듈은 기본 선언과 모든 테스터가 필요로하는 일부 Angular 서비스 대체물로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="32d01fc5844e040dbbc5a7fa7fc314aed7f8af26" translate="yes" xml:space="preserve">
          <source>The tests described in this guide are in &lt;code&gt;src/testing/http-client.spec.ts&lt;/code&gt;. There are also tests of an application data service that call &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;src/app/heroes/heroes.service.spec.ts&lt;/code&gt;.</source>
          <target state="translated">이 안내서에 설명 된 테스트는 &lt;code&gt;src/testing/http-client.spec.ts&lt;/code&gt; 에 있습니다. &lt;code&gt;src/app/heroes/heroes.service.spec.ts&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 를 호출하는 응용 프로그램 데이터 서비스에 대한 테스트도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c46d6deffac15f691e67af3e7802efbd62c6f4b5" translate="yes" xml:space="preserve">
          <source>The tests in this guide are designed to run in a browser so a &lt;code&gt;nativeElement&lt;/code&gt; value will always be an &lt;code&gt;HTMLElement&lt;/code&gt; or one of its derived classes.</source>
          <target state="translated">이 안내서의 테스트는 브라우저에서 실행되도록 설계되었으므로 &lt;code&gt;nativeElement&lt;/code&gt; 값은 항상 &lt;code&gt;HTMLElement&lt;/code&gt; 또는 파생 클래스 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="97411629b7777fd387f17c68fd54b77f893a322d" translate="yes" xml:space="preserve">
          <source>The tests in this guide only call &lt;code&gt;compileComponents&lt;/code&gt; when necessary.</source>
          <target state="translated">이 가이드의 테스트는 필요할 때만 &lt;code&gt;compileComponents&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="b9b3c07155cb24bc62c23428c9b9b89113dffe1f" translate="yes" xml:space="preserve">
          <source>The tests need access to the (stub) &lt;code&gt;UserService&lt;/code&gt; injected into the &lt;code&gt;WelcomeComponent&lt;/code&gt;.</source>
          <target state="translated">테스트 는 &lt;code&gt;WelcomeComponent&lt;/code&gt; 에 삽입 된 (스텁) &lt;code&gt;UserService&lt;/code&gt; 에 액세스해야합니다 .</target>
        </trans-unit>
        <trans-unit id="552798847cfd969bee03bd536ec0eaa7b9abccb0" translate="yes" xml:space="preserve">
          <source>The tests themselves are almost identical to the stand-alone version:</source>
          <target state="translated">테스트 자체는 독립형 버전과 거의 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f24377c82eb7c604520a6472b6cdeda1e15d8e75" translate="yes" xml:space="preserve">
          <source>The text between the braces is often the name of a component property. Angular replaces that name with the string value of the corresponding component property.</source>
          <target state="translated">중괄호 사이의 텍스트는 종종 구성 요소 특성의 이름입니다. Angular는 해당 이름을 해당 구성 요소 속성의 문자열 값으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="7001ead9ab548d59ed3b0b0d47f9fc2feadd5c3b" translate="yes" xml:space="preserve">
          <source>The text string.</source>
          <target state="translated">텍스트 문자열</target>
        </trans-unit>
        <trans-unit id="019a0c6e6325000b9ec468afe8f97d5dd0f39c5b" translate="yes" xml:space="preserve">
          <source>The textbox should both &lt;em&gt;display&lt;/em&gt; the hero's &lt;code&gt;name&lt;/code&gt; property and &lt;em&gt;update&lt;/em&gt; that property as the user types. That means data flows from the component class &lt;em&gt;out to the screen&lt;/em&gt; and from the screen &lt;em&gt;back to the class&lt;/em&gt;.</source>
          <target state="translated">텍스트 상자 에는 영웅의 &lt;code&gt;name&lt;/code&gt; 속성이 &lt;em&gt;표시&lt;/em&gt; 되고 사용자 유형에 따라 해당 속성이 &lt;em&gt;업데이트&lt;/em&gt; 되어야합니다. 이는 데이터가 컴포넌트 클래스 &lt;em&gt;에서 화면으로&lt;/em&gt; 그리고 화면에서 &lt;em&gt;다시&lt;/em&gt; 클래스로 흘러가는 것을 의미합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9c58df2e0d216969a6b8f76eb1c801e78a85b760" translate="yes" xml:space="preserve">
          <source>The third argument, &lt;code&gt;easing&lt;/code&gt;, controls how the animation &lt;a href=&quot;http://easings.net/&quot;&gt;accelerates and decelerates&lt;/a&gt; during its runtime. For example, &lt;code&gt;ease-in&lt;/code&gt; causes the animation to begin slowly, and to pick up speed as it progresses.</source>
          <target state="translated">세 번째 인수 인 &lt;code&gt;easing&lt;/code&gt; 은 런타임 동안 애니메이션의 &lt;a href=&quot;http://easings.net/&quot;&gt;가속 및 감속&lt;/a&gt; 방법을 제어합니다 . 예를 들어 &lt;code&gt;ease-in&lt;/code&gt; 을 사용 하면 애니메이션이 느리게 시작되고 진행 속도가 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="387ef2ede0548f8a7e5227510a281240ebc65597" translate="yes" xml:space="preserve">
          <source>The third parameter defines a pattern of pluralization categories and their matching values:</source>
          <target state="translated">세 번째 매개 변수는 복수화 카테고리의 패턴과 일치하는 값을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="02b20036ccb6a097e5d6133a873e25f13d920be9" translate="yes" xml:space="preserve">
          <source>The third parameter defines a pluralization pattern consisting of pluralization categories and their matching values.</source>
          <target state="translated">세 번째 매개 변수는 복수화 범주 및 해당 값으로 구성된 복수화 패턴을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="9e89f13f3f25c09bfbb1e27588e7ce09b251770a" translate="yes" xml:space="preserve">
          <source>The three modes of type-checking treat embedded views differently. Consider the following example.</source>
          <target state="translated">세 가지 유형 검사 모드는 포함 된 뷰를 다르게 처리합니다. 다음 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e1fbe17ffff22abb0345952cf457c1a79e7059ef" translate="yes" xml:space="preserve">
          <source>The threshold for error relative to the baseline (min &amp;amp; max).</source>
          <target state="translated">기준과 관련된 오류의 임계 값입니다 (최소 및 최대).</target>
        </trans-unit>
        <trans-unit id="60c47ee6ec4aee3d2f301fc3d304a4955e681b57" translate="yes" xml:space="preserve">
          <source>The threshold for warning relative to the baseline (min &amp;amp; max).</source>
          <target state="translated">기준과 관련된 경고의 임계 값입니다 (최소 및 최대).</target>
        </trans-unit>
        <trans-unit id="c4b55d03441bffab6eec1d8c5b1ac161eb54aa13" translate="yes" xml:space="preserve">
          <source>The time it takes the animation to complete, in milliseconds.</source>
          <target state="translated">애니메이션을 완료하는 데 걸리는 시간 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="39672ec6c077499845ec25181d8fdddc36ce80f6" translate="yes" xml:space="preserve">
          <source>The time zone. A time zone offset from GMT (such as &lt;code&gt;'+0430'&lt;/code&gt;), or a standard UTC/GMT or continental US time zone abbreviation. If not specified, uses host system settings.</source>
          <target state="translated">시간대 GMT에서 표준 시간대 오프셋 (예 : &lt;code&gt;'+0430'&lt;/code&gt; ) 또는 표준 UTC / GMT 또는 미국 대륙 표준 시간대 약어입니다. 지정하지 않으면 호스트 시스템 설정을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="20e4e50a13a151170196f0e0befe4c1c2ba96789" translate="yes" xml:space="preserve">
          <source>The timing data for the step.</source>
          <target state="translated">단계의 타이밍 데이터.</target>
        </trans-unit>
        <trans-unit id="3a5862865c9788bb436ccfadcc4ca1e2e0ed4f85" translate="yes" xml:space="preserve">
          <source>The timing data for the steps.</source>
          <target state="translated">단계의 타이밍 데이터.</target>
        </trans-unit>
        <trans-unit id="9bb53d35a2e2718224cdb5414e304756bc3d18c6" translate="yes" xml:space="preserve">
          <source>The title should appear at the top of the physical page. Begin the title with the markdown &lt;code&gt;#&lt;/code&gt; character. Alternatively, you can write the equivalent &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">제목은 실제 페이지 상단에 나타납니다. 마크 다운 &lt;code&gt;#&lt;/code&gt; 문자로 제목을 시작하십시오 . 또는 동등한 &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; 을 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="964f1d13124f53046f40e305bcf164695c936261" translate="yes" xml:space="preserve">
          <source>The token is used as a type specifier for constructor injection.</source>
          <target state="translated">토큰은 생성자 주입을위한 형식 지정자로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8f009ca4174665a8b55345b2eea3c338ed581af6" translate="yes" xml:space="preserve">
          <source>The token is used in the value position of a &lt;a href=&quot;lifecycle-hooks#using-aftercontent-hooks&quot;&gt;content query&lt;/a&gt;.</source>
          <target state="translated">토큰은 &lt;a href=&quot;lifecycle-hooks#using-aftercontent-hooks&quot;&gt;콘텐츠 쿼리&lt;/a&gt; 의 값 위치에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7392074d5488bfada1cba2db29c9e3aaea938dec" translate="yes" xml:space="preserve">
          <source>The tool that the CLI uses to perform complex tasks such as compilation and test running, according to a provided configuration. Architect is a shell that runs a &lt;a href=&quot;glossary#builder&quot;&gt;builder&lt;/a&gt; (defined in an &lt;a href=&quot;glossary#npm-package&quot;&gt;npm package&lt;/a&gt;) with a given &lt;a href=&quot;glossary#target&quot;&gt;target configuration&lt;/a&gt;.</source>
          <target state="translated">제공된 구성에 따라 CLI가 컴파일 및 테스트 실행과 같은 복잡한 작업을 수행하는 데 사용하는 도구입니다. Architect는 주어진 &lt;a href=&quot;glossary#target&quot;&gt;대상 구성&lt;/a&gt; 으로 &lt;a href=&quot;glossary#builder&quot;&gt;빌더&lt;/a&gt; ( &lt;a href=&quot;glossary#npm-package&quot;&gt;npm 패키지에&lt;/a&gt; 정의 됨) 를 실행하는 쉘입니다 .</target>
        </trans-unit>
        <trans-unit id="a41ed1a3c20f3b032ce6bf341b07b3ff788f0e6c" translate="yes" xml:space="preserve">
          <source>The top level of the root project folder for a collection contains configuration files, a &lt;code&gt;node_modules&lt;/code&gt; folder, and a &lt;code&gt;src/&lt;/code&gt; folder. The &lt;code&gt;src/&lt;/code&gt; folder contains subfolders for named schematics in the collection, and a schema, &lt;code&gt;collection.json&lt;/code&gt;, which describes the collected schematics. Each schematic is created with a name, description, and factory function.</source>
          <target state="translated">컬렉션에 대한 루트 프로젝트 폴더의 최상위 수준에는 구성 파일, &lt;code&gt;node_modules&lt;/code&gt; 폴더 및 &lt;code&gt;src/&lt;/code&gt; 폴더가 있습니다. &lt;code&gt;src/&lt;/code&gt; 라는 이름의 컬렉션의 회로도 및 스키마에 대한 하위 폴더가 들어있는 폴더를 &lt;code&gt;collection.json&lt;/code&gt; 수집 된 회로도를 설명합니다. 각 회로도는 이름, 설명 및 팩토리 기능으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="3f8c3bac42ac19a6aeec66ddbb65426c9445956b" translate="yes" xml:space="preserve">
          <source>The top paragraph is in the DOM. The bottom, disused paragraph is not; in its place is a comment about &quot;bindings&quot; (more about that &lt;a href=&quot;structural-directives#asterisk&quot;&gt;later&lt;/a&gt;).</source>
          <target state="translated">상단 단락은 DOM에 있습니다. 사용하지 않는 마지막 단락은 아닙니다. 그 자리에는 &quot;바인딩&quot;에 대한 주석이 있습니다 ( &lt;a href=&quot;structural-directives#asterisk&quot;&gt;나중에&lt;/a&gt; 더 자세히 설명 ).</target>
        </trans-unit>
        <trans-unit id="00501897b059678bdf07befdac7616fe6a03505a" translate="yes" xml:space="preserve">
          <source>The top-level directive for this control if present, otherwise null.</source>
          <target state="translated">이 컨트롤의 최상위 지시어가있는 경우는 그렇지 않은 경우는 null</target>
        </trans-unit>
        <trans-unit id="aa4c65514687fcb647bd478319e8cd7a18baae19" translate="yes" xml:space="preserve">
          <source>The top-level directive for this group if present, otherwise null.</source>
          <target state="translated">존재하는 경우,이 그룹의 최상위 지시문. 그렇지 않은 경우는 null</target>
        </trans-unit>
        <trans-unit id="7f59f229151882c691c9c4dbd40db2c8cf35cf79" translate="yes" xml:space="preserve">
          <source>The top-level form directive for the control.</source>
          <target state="translated">컨트롤의 최상위 폼 지시어입니다.</target>
        </trans-unit>
        <trans-unit id="aa96b6dd3b9c83ecd894feff632ccdcd8ce5055e" translate="yes" xml:space="preserve">
          <source>The total run time of the animation, in milliseconds.</source>
          <target state="translated">애니메이션의 총 실행 시간 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="14aee0513a51a8b6574f4395af2536721cbd0b69" translate="yes" xml:space="preserve">
          <source>The transition from the server-rendered app to the client app happens quickly on a development machine, but you should always test your apps in real-world scenarios.</source>
          <target state="translated">서버 렌더링 앱에서 클라이언트 앱으로의 전환은 개발 시스템에서 빠르게 이루어 지지만 항상 실제 시나리오에서 앱을 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b2c02e508d78290b606f3c251693a83d5dd77d7" translate="yes" xml:space="preserve">
          <source>The translation file format.</source>
          <target state="translated">번역 파일 형식입니다.</target>
        </trans-unit>
        <trans-unit id="a01d8be6610dc7e8ff92abc660e7a063be84ddba" translate="yes" xml:space="preserve">
          <source>The translation file.</source>
          <target state="translated">번역 파일.</target>
        </trans-unit>
        <trans-unit id="566718f0b46f66443c966e183abd9ebc1557a5c4" translate="yes" xml:space="preserve">
          <source>The translation process that transforms one version of JavaScript to another version; for example, down-leveling ES2015 to the older ES5 version.</source>
          <target state="translated">한 버전의 JavaScript를 다른 버전으로 변환하는 번역 프로세스. 예를 들어 ES2015를 이전 ES5 버전으로 다운 레벨링합니다.</target>
        </trans-unit>
        <trans-unit id="349bc86574d83717c24e66cc03a3095ffbe80534" translate="yes" xml:space="preserve">
          <source>The translator may also need to know the meaning or intent of the text message within this particular app context, in order to translate it the same way as other text with the same meaning. Start the &lt;code&gt;i18n&lt;/code&gt; attribute value with the &lt;em&gt;meaning&lt;/em&gt; and separate it from the &lt;em&gt;description&lt;/em&gt; with the &lt;code&gt;|&lt;/code&gt; character: &lt;code&gt;&amp;lt;meaning&amp;gt;|&amp;lt;description&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">번역자는 동일한 의미를 가진 다른 텍스트와 동일한 방식으로 번역하기 위해이 특정 앱 컨텍스트 내에서 텍스트 메시지의 의미 나 의도를 알아야 할 수도 있습니다. 시작 &lt;code&gt;i18n&lt;/code&gt; 과 속성 값을 &lt;em&gt;의미&lt;/em&gt; 하고,에서 분리 &lt;em&gt;설명&lt;/em&gt; 와 &lt;code&gt;|&lt;/code&gt; 문자 : &lt;code&gt;&amp;lt;meaning&amp;gt;|&amp;lt;description&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2fd93ca59b690739d63aaf50fa1d89967d7ba17a" translate="yes" xml:space="preserve">
          <source>The translator may also need to know the meaning or intent of the text message within this particular app context.</source>
          <target state="translated">번역 사는이 특정 앱 컨텍스트 내에서 문자 메시지의 의미 나 의도를 알아야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c27e3942c3254b8b0f806e9fac192f3f58c19b32" translate="yes" xml:space="preserve">
          <source>The tree-shaking problem arises when a component is used as an injection token. There are two cases when that can happen.</source>
          <target state="translated">구성 요소가 주입 토큰으로 사용될 때 트리 흔들림 문제가 발생합니다. 그럴 수있는 두 가지 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cbae59239e49c4968e3b2022136d5ac4b8dd7eb" translate="yes" xml:space="preserve">
          <source>The trigger name, used to associate it with an element. Unique within the component.</source>
          <target state="translated">요소와 연관시키는 데 사용되는 트리거 이름. 구성 요소 내에서 고유합니다.</target>
        </trans-unit>
        <trans-unit id="d35231c4743a554b907dbe3ec68e6d1c03c3e04e" translate="yes" xml:space="preserve">
          <source>The tutorial walks you through the following steps.</source>
          <target state="translated">이 자습서는 다음 단계를 안내합니다.</target>
        </trans-unit>
        <trans-unit id="599b7384324d0565d53e3693b7036e321e474501" translate="yes" xml:space="preserve">
          <source>The tutorial's &quot;in-memory web API&quot; module, a demo and development tool, intercepts all HTTP calls and simulates the behavior of a remote data server. In practice, you would remove that module and register your web API middleware on the server here.</source>
          <target state="translated">데모 및 개발 도구 인 학습서의 &quot;메모리 내 웹 API&quot;모듈은 모든 HTTP 호출을 가로 채 원격 데이터 서버의 동작을 시뮬레이션합니다. 실제로 해당 모듈을 제거하고 여기에서 서버에 웹 API 미들웨어를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="29c54a0ff6d263b78d0ad5a2dc608fb24dc18c92" translate="yes" xml:space="preserve">
          <source>The tutorial's &lt;code&gt;HeroService&lt;/code&gt; and &lt;code&gt;HeroSearchService&lt;/code&gt; delegate to the Angular &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; module to fetch application data. These services send requests to &lt;em&gt;relative&lt;/em&gt; URLs such as &lt;code&gt;api/heroes&lt;/code&gt;. In a Universal app, HTTP URLs must be &lt;em&gt;absolute&lt;/em&gt; (for example, &lt;code&gt;https://my-server.com/api/heroes&lt;/code&gt;). This means you need to change your services to make requests with absolute URLs when running on the server and with relative URLs when running in the browser.</source>
          <target state="translated">학습서의 &lt;code&gt;HeroService&lt;/code&gt; 및 &lt;code&gt;HeroSearchService&lt;/code&gt; 는 Angular &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 모듈에 위임하여 애플리케이션 데이터를 가져옵니다. 이러한 서비스 는 &lt;code&gt;api/heroes&lt;/code&gt; 와 같은 &lt;em&gt;상대&lt;/em&gt; URL 로 요청을 보냅니다 . 범용 앱에서 HTTP URL은 &lt;em&gt;절대적&lt;/em&gt; 이어야합니다 (예 : &lt;code&gt;https://my-server.com/api/heroes&lt;/code&gt; ). 이는 서버에서 실행될 때 절대 URL과 브라우저에서 실행될 때 상대 URL로 요청을 수행하도록 서비스를 변경해야 함을 의미합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="305db64f25ecd1b1da157b5b8c651450a07346de" translate="yes" xml:space="preserve">
          <source>The tutorial's &lt;code&gt;HeroService&lt;/code&gt; and &lt;code&gt;HeroSearchService&lt;/code&gt; delegate to the Angular &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; module to fetch application data. These services send requests to &lt;em&gt;relative&lt;/em&gt; URLs such as &lt;code&gt;api/heroes&lt;/code&gt;. In a server-side rendered app, HTTP URLs must be &lt;em&gt;absolute&lt;/em&gt; (for example, &lt;code&gt;https://my-server.com/api/heroes&lt;/code&gt;). This means that the URLs must be somehow converted to absolute when running on the server and be left relative when running in the browser.</source>
          <target state="translated">튜토리얼의 &lt;code&gt;HeroService&lt;/code&gt; 및 &lt;code&gt;HeroSearchService&lt;/code&gt; 는 Angular &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 모듈에 위임하여 애플리케이션 데이터를 가져옵니다. 이러한 서비스 는 &lt;code&gt;api/heroes&lt;/code&gt; 와 같은 &lt;em&gt;상대&lt;/em&gt; URL 로 요청을 보냅니다 . 서버 측 렌더링 된 앱에서 HTTP URL은 &lt;em&gt;절대적&lt;/em&gt; 이어야합니다 (예 : &lt;code&gt;https://my-server.com/api/heroes&lt;/code&gt; ). 이는 URL이 서버에서 실행될 때 절대로 변환되어야하고 브라우저에서 실행될 때 상대적으로 남아 있어야 함을 의미합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="67bfdaa72e9953f6fcebc0bfa93857733007382e" translate="yes" xml:space="preserve">
          <source>The two asterisks, &lt;code&gt;**&lt;/code&gt;, indicate to Angular that this &lt;code&gt;routes&lt;/code&gt; definition is a wildcard route. For the component property, you can define any component in your application. Common choices include an application-specific &lt;code&gt;PageNotFoundComponent&lt;/code&gt;, which you can define to &lt;a href=&quot;router#404-page-how-to&quot;&gt;display a 404 page&lt;/a&gt; to your users; or a redirect to your application's main component. A wildcard route is the last route because it matches any URL. For more detail on why order matters for routes, see &lt;a href=&quot;router#route-order&quot;&gt;Route order&lt;/a&gt;.</source>
          <target state="translated">두 개의 별표 &lt;code&gt;**&lt;/code&gt; 는이 &lt;code&gt;routes&lt;/code&gt; 정의가 와일드 카드 경로 임을 Angular에 나타냅니다 . 구성 요소 속성의 경우 응용 프로그램의 모든 구성 요소를 정의 할 수 있습니다. 일반적인 선택에는 사용자에게 &lt;a href=&quot;router#404-page-how-to&quot;&gt;404 페이지&lt;/a&gt; 를 표시하도록 정의 할 수 있는 애플리케이션 별 &lt;code&gt;PageNotFoundComponent&lt;/code&gt; 가 포함됩니다 . 또는 애플리케이션의 주요 구성 요소로 리디렉션합니다. 와일드 카드 경로는 모든 URL과 일치하므로 마지막 경로입니다. 순서가 경로에 중요한 이유에 대한 자세한 내용은 &lt;a href=&quot;router#route-order&quot;&gt;경로 순서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="afc05ea2dd3769a2464a65395b0f8fc1046a9410" translate="yes" xml:space="preserve">
          <source>The two build systems support different things, and even where they support the same things, they do those things differently. This means that the TypeScript source can result in different JavaScript code in a built library than it would in a built application.</source>
          <target state="translated">두 빌드 시스템은 서로 다른 것을 지원하며 심지어 동일한 것을 지원하는 경우에도 서로 다르게 수행합니다. 이는 TypeScript 소스가 빌드 된 응용 프로그램과 다른 라이브러리에서 다른 JavaScript 코드를 생성 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3d6bab88072a051c166e9e7471ac45c3b0a3264e" translate="yes" xml:space="preserve">
          <source>The two components will have a parent/child relationship. The parent &lt;code&gt;HeroesComponent&lt;/code&gt; will control the child &lt;code&gt;HeroDetailComponent&lt;/code&gt; by sending it a new hero to display whenever the user selects a hero from the list.</source>
          <target state="translated">두 구성 요소는 상위 / 하위 관계를 갖습니다. 부모 &lt;code&gt;HeroesComponent&lt;/code&gt; 는 사용자가 목록에서 영웅을 선택할 때마다 표시 할 새로운 hero를 보내서 자식 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 를 제어 합니다.</target>
        </trans-unit>
        <trans-unit id="5afe858ace0f507f6e00dcce82eccd00126d0833" translate="yes" xml:space="preserve">
          <source>The two types of validators are passed in separately as the second and third arg respectively, or together as part of an options object.</source>
          <target state="translated">두 가지 유형의 유효성 검사기는 각각 두 번째 및 세 번째 인수로 별도로 또는 옵션 개체의 일부로 함께 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b4abd53c0253243e985b7e065cc9f874147ab4e8" translate="yes" xml:space="preserve">
          <source>The two update events, &lt;code&gt;available&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/service-worker/swupdate#activated&quot;&gt;activated&lt;/a&gt;&lt;/code&gt;, are &lt;code&gt;Observable&lt;/code&gt; properties of &lt;code&gt;&lt;a href=&quot;../api/service-worker/swupdate&quot;&gt;SwUpdate&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">두 개의 업데이트 이벤트, &lt;code&gt;available&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/service-worker/swupdate#activated&quot;&gt;activated&lt;/a&gt;&lt;/code&gt; ,이다 &lt;code&gt;Observable&lt;/code&gt; 속성 &lt;code&gt;&lt;a href=&quot;../api/service-worker/swupdate&quot;&gt;SwUpdate&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="681906e7bceda4d76618f4d591a5d4a3561cc264" translate="yes" xml:space="preserve">
          <source>The two update events, &lt;code&gt;available&lt;/code&gt; and &lt;code&gt;activated&lt;/code&gt;, are &lt;code&gt;Observable&lt;/code&gt; properties of &lt;code&gt;&lt;a href=&quot;../api/service-worker/swupdate&quot;&gt;SwUpdate&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">두 개의 업데이트 이벤트, &lt;code&gt;available&lt;/code&gt; 및 &lt;code&gt;activated&lt;/code&gt; ,이다 &lt;code&gt;Observable&lt;/code&gt; 속성 &lt;code&gt;&lt;a href=&quot;../api/service-worker/swupdate&quot;&gt;SwUpdate&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1dbdba75ae5eb9e9bc50a6b2bc270a30ddeeee80" translate="yes" xml:space="preserve">
          <source>The two-way binding syntax is a great convenience compared to separate property and event bindings. It would be convenient to use two-way binding with HTML form elements like &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;. However, no native HTML element follows the &lt;code&gt;x&lt;/code&gt; value and &lt;code&gt;xChange&lt;/code&gt; event pattern.</source>
          <target state="translated">양방향 바인딩 구문은 별도의 속성 및 이벤트 바인딩과 비교할 때 매우 편리합니다. &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 와 같은 HTML 양식 요소에 양방향 바인딩을 사용하는 것이 편리합니다 . 그러나 &lt;code&gt;x&lt;/code&gt; 값과 &lt;code&gt;xChange&lt;/code&gt; 이벤트 패턴 뒤에는 기본 HTML 요소가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="552f44eabf3bee5b16dbbe6d805c5e4727da9fe7" translate="yes" xml:space="preserve">
          <source>The two-way binding syntax is really just syntactic sugar for a &lt;em&gt;property&lt;/em&gt; binding and an &lt;em&gt;event&lt;/em&gt; binding. Angular desugars the &lt;code&gt;SizerComponent&lt;/code&gt; binding into this:</source>
          <target state="translated">양방향 바인딩 구문은 실제로 &lt;em&gt;속성&lt;/em&gt; 바인딩 및 &lt;em&gt;이벤트&lt;/em&gt; 바인딩에 대한 구문 설탕입니다 . Angular는 &lt;code&gt;SizerComponent&lt;/code&gt; 바인딩을 다음과 같이 탈당 합니다.</target>
        </trans-unit>
        <trans-unit id="76cff48315da67038bca27defef7706ac9ac1f06" translate="yes" xml:space="preserve">
          <source>The two-way binding syntax is shorthand for a combination of property binding and event binding. The &lt;code&gt;SizerComponent&lt;/code&gt; binding as separate property binding and event binding is as follows.</source>
          <target state="translated">양방향 바인딩 구문은 속성 바인딩과 이벤트 바인딩의 조합에 대한 축약 형입니다. &lt;code&gt;SizerComponent&lt;/code&gt; 는 별도 재산권 바인딩 및 이벤트에 바인딩만큼 다음 바인딩.</target>
        </trans-unit>
        <trans-unit id="194f581853ac13d61cf24a5c84685394267efc75" translate="yes" xml:space="preserve">
          <source>The type checker also throws an error if it can't determine whether a variable will be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; at runtime. You tell the type checker not to throw an error by applying the postfix &lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator&quot;&gt;non-null assertion operator, !&lt;/a&gt;.</source>
          <target state="translated">유형 검사기는 런타임에 변수가 &lt;code&gt;null&lt;/code&gt; 인지 아니면 &lt;code&gt;undefined&lt;/code&gt; 는지 확인할 수없는 경우에도 오류를 발생시킵니다 . 접미사 &lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator&quot;&gt;널이 아닌 어설 션 연산자&lt;/a&gt; 를 적용하여 유형 검사기에 오류가 발생하지 않도록 지시합니다 .! .</target>
        </trans-unit>
        <trans-unit id="6513ae7688b62a5255ebc4d625abc9be33526ee7" translate="yes" xml:space="preserve">
          <source>The type checker also throws an error if it can't determine whether a variable will be &lt;code&gt;null&lt;/code&gt; or undefined at runtime. You tell the type checker not to throw an error by applying the postfix &lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator&quot;&gt;non-null assertion operator, !&lt;/a&gt;.</source>
          <target state="translated">런타임에 변수가 &lt;code&gt;null&lt;/code&gt; 인지 또는 정의되지 않았 는지 확인할 수없는 경우 형식 검사기에서 오류가 발생 합니다. &lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator&quot;&gt;널이 아닌 어설 션 연산자!&lt;/a&gt; 를 적용하여 형식 검사기에 오류가 발생하지 않도록 지시합니다 .! .</target>
        </trans-unit>
        <trans-unit id="d949ded92c64bb6e37f7798775515186c690205d" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;&lt;a href=&quot;../api/forms/abstractcontrol&quot;&gt;AbstractControl&lt;/a&gt;#parent&lt;/code&gt; now indicates that it may be null. See &lt;a href=&quot;https://github.com/angular/angular/pull/32671&quot;&gt;PR 32671&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/forms/abstractcontrol&quot;&gt;AbstractControl&lt;/a&gt;#parent&lt;/code&gt; 의 유형은 이제 null 일 수 있음을 나타냅니다. &lt;a href=&quot;https://github.com/angular/angular/pull/32671&quot;&gt;PR 32671을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="81dce0b481d7ac34dd874fc96a0c29f5d10a16ae" translate="yes" xml:space="preserve">
          <source>The type of budget. One of:</source>
          <target state="translated">예산 유형 다음 중 하나 :</target>
        </trans-unit>
        <trans-unit id="c15292902555eb7a2059d3f203806ac34a995f12" translate="yes" xml:space="preserve">
          <source>The type of component the factory will create.</source>
          <target state="translated">팩토리가 생성 할 구성 요소 유형입니다.</target>
        </trans-unit>
        <trans-unit id="7c0884d61dcbf36812f4f429d57a3fd536285ae5" translate="yes" xml:space="preserve">
          <source>The type of numeric value to be formatted (such as &lt;code&gt;Decimal&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;numberformatstyle#Currency&quot;&gt;Currency&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">형식화 할 숫자 값의 유형 (예 : &lt;code&gt;Decimal&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;numberformatstyle#Currency&quot;&gt;Currency&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4ca1c6ea29abaecf66afa18e36661807315423ea" translate="yes" xml:space="preserve">
          <source>The type of numeric value to be formatted (such as &lt;code&gt;Decimal&lt;/code&gt; or &lt;code&gt;Currency&lt;/code&gt;.)</source>
          <target state="translated">형식화 할 숫자 값의 유형 (예 : &lt;code&gt;Decimal&lt;/code&gt; 또는 &lt;code&gt;Currency&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="1914de4f10fd251ed62f048b8948f40fc99532fb" translate="yes" xml:space="preserve">
          <source>The type of object that &lt;a href=&quot;viewchildren&quot;&gt;&lt;code&gt;ViewChildren&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;contentchildren&quot;&gt;&lt;code&gt;ContentChildren&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;querylist&quot;&gt;&lt;code&gt;QueryList&lt;/code&gt;&lt;/a&gt; provide.</source>
          <target state="translated">&lt;a href=&quot;viewchildren&quot;&gt; &lt;code&gt;ViewChildren&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;contentchildren&quot;&gt; &lt;code&gt;ContentChildren&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;querylist&quot;&gt; &lt;code&gt;QueryList&lt;/code&gt; 가&lt;/a&gt; 제공하는 객체의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="2cee06caf5b085e8040bc4dd74a44cf2669ac0d4" translate="yes" xml:space="preserve">
          <source>The type of this component (as created by a &lt;code&gt;&lt;a href=&quot;componentfactory&quot;&gt;ComponentFactory&lt;/a&gt;&lt;/code&gt; class).</source>
          <target state="translated">이 컴퍼넌트의 형태 ( &lt;code&gt;&lt;a href=&quot;componentfactory&quot;&gt;ComponentFactory&lt;/a&gt;&lt;/code&gt; 클래스에 의해 작성 )</target>
        </trans-unit>
        <trans-unit id="351e662a9168935a10d637a721b52c3db93d0b18" translate="yes" xml:space="preserve">
          <source>The type parameter, &lt;code&gt;T&lt;/code&gt;, is the kind of metadata you'd pass to the &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; decorator:</source>
          <target state="translated">type 매개 변수 &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; 데코레이터에 전달할 메타 데이터 종류입니다 .</target>
        </trans-unit>
        <trans-unit id="92e0731044a01c861010ac8dd3364de0bab42484" translate="yes" xml:space="preserve">
          <source>The type parameter, while optional, conveys the dependency's type to developers and tooling. The token description is another developer aid.</source>
          <target state="translated">type 매개 변수는 선택 사항이지만 종속성 유형을 개발자와 툴링에 전달합니다. 토큰 설명은 또 다른 개발자 지원입니다.</target>
        </trans-unit>
        <trans-unit id="3be642a3bc4d6290043093ef6c6b0e31a8237f3c" translate="yes" xml:space="preserve">
          <source>The types of the &lt;code&gt;observe&lt;/code&gt; and &lt;code&gt;response&lt;/code&gt; options are &lt;em&gt;string unions&lt;/em&gt;, rather than plain strings.</source>
          <target state="translated">&lt;code&gt;observe&lt;/code&gt; 및 &lt;code&gt;response&lt;/code&gt; 옵션 의 유형은 일반 문자열이 아닌 &lt;em&gt;문자열 공용체&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fdab28b804a5bc2df8ed953cd182dcd879bebcd0" translate="yes" xml:space="preserve">
          <source>The underlying native element or &lt;code&gt;null&lt;/code&gt; if direct access to native elements is not supported (e.g. when the application runs in a web worker).</source>
          <target state="translated">기본 고유 요소 또는 기본 요소에 대한 직접 액세스가 지원되지 않는 경우 (예 : 응용 프로그램이 웹 작업자에서 실행될 때) &lt;code&gt;null&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9fb3d4a522a7d59fc653358ee450cd39cd54d77" translate="yes" xml:space="preserve">
          <source>The unit test files themselves also need to be switched to Angular when their production counterparts are switched. The specs for the checkmark pipe are probably the most straightforward, as the pipe has no dependencies:</source>
          <target state="translated">생산 테스트 파일을 전환 할 때 단위 테스트 파일 자체도 Angular로 전환해야합니다. 파이프에 종속성이 없으므로 확인 표시 파이프의 사양이 가장 간단합니다.</target>
        </trans-unit>
        <trans-unit id="7b843cdeff59d7337d09dffec8474c659f368f17" translate="yes" xml:space="preserve">
          <source>The unit test for the phone service is a bit more involved. You need to switch from the mocked-out AngularJS &lt;code&gt;$httpBackend&lt;/code&gt; to a mocked-out Angular Http backend.</source>
          <target state="translated">전화 서비스의 단위 테스트는 조금 더 복잡합니다. &lt;code&gt;$httpBackend&lt;/code&gt; 아웃 AngularJS $ httpBackend 에서 모의 아웃 Angular Http 백엔드 로 전환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="789acab94f4da6bd1b31fd8d53475bbe9758d87a" translate="yes" xml:space="preserve">
          <source>The updated &lt;code&gt;HeroesRoutingModule&lt;/code&gt; looks like this:</source>
          <target state="translated">업데이트 된 &lt;code&gt;HeroesRoutingModule&lt;/code&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="987de19a86a67d115685949783bff6fddad8b8ee" translate="yes" xml:space="preserve">
          <source>The upgrade NgModule.</source>
          <target state="translated">NgModule 업그레이드.</target>
        </trans-unit>
        <trans-unit id="d44b088804cbf01923d7400df118887612abd201" translate="yes" xml:space="preserve">
          <source>The url from which this snapshot was created</source>
          <target state="translated">이 스냅 샷이 작성된 URL</target>
        </trans-unit>
        <trans-unit id="0ee83b79b718d1a4ec36d1b3d58ebe726ac3e494" translate="yes" xml:space="preserve">
          <source>The url serialization strategy is customizable. You can make all URLs case insensitive by providing a custom UrlSerializer.</source>
          <target state="translated">URL 직렬화 전략은 사용자 정의 할 수 있습니다. 사용자 정의 UrlSerializer를 제공하여 모든 URL을 대소 문자를 구분하지 않게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad97874a0022a010e0155677ec6967027c4314b9" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;name&lt;/code&gt; attributes for validation and form-element change tracking.</source>
          <target state="translated">유효성 검사 및 양식 요소 변경 내용 추적 에 &lt;code&gt;name&lt;/code&gt; 특성 사용</target>
        </trans-unit>
        <trans-unit id="9154043e44b5d932b8c61e6a2f25ebf4ef5aea92" translate="yes" xml:space="preserve">
          <source>The user calls the &lt;code&gt;favoriteColorControl.setValue()&lt;/code&gt; method, which updates the &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">사용자는 &lt;code&gt;favoriteColorControl.setValue()&lt;/code&gt; 메소드를 호출 하여 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 값 을 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="0a5976d96dbc10bd55988a4a489b75fc9937bde4" translate="yes" xml:space="preserve">
          <source>The user can select a hero and see that hero's details.</source>
          <target state="translated">사용자는 영웅을 선택하고 해당 영웅의 세부 정보를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b99c1b741aee49f63e964f6109422ed732ed9ff3" translate="yes" xml:space="preserve">
          <source>The user closes the app and does not open it for a while.</source>
          <target state="translated">사용자가 앱을 닫고 잠시 동안 열지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa661a59e3356526e5cd2452506236a954f28c3e" translate="yes" xml:space="preserve">
          <source>The user needs a way to open the popup. Open the &lt;code&gt;AppComponent&lt;/code&gt; and add a &quot;Contact&quot; link.</source>
          <target state="translated">사용자는 팝업을 여는 방법이 필요합니다. &lt;code&gt;AppComponent&lt;/code&gt; 를 열고 &quot;Contact&quot;링크를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ec95381196d078fadc8f2f14dd8fb15e40e96c16" translate="yes" xml:space="preserve">
          <source>The user opens the app again. The service worker serves the latest version known to it at this point, namely the old version (&lt;code&gt;index.html&lt;/code&gt; and &lt;code&gt;main.&amp;lt;main-hash-1&amp;gt;.js&lt;/code&gt;).</source>
          <target state="translated">사용자가 앱을 다시 엽니 다. 서비스 워커는 현재 알려진 최신 버전, 즉 이전 버전 ( &lt;code&gt;index.html&lt;/code&gt; 및 &lt;code&gt;main.&amp;lt;main-hash-1&amp;gt;.js&lt;/code&gt; )을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="369264e6d1f498d1106a6d3877d3ee5e43560ae5" translate="yes" xml:space="preserve">
          <source>The user should be able to get to these details in three ways.</source>
          <target state="translated">사용자는 세 가지 방법으로 이러한 세부 정보를 얻을 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="bbafb9f9e9d3caf33087f60e1818944be5dd3d9b" translate="yes" xml:space="preserve">
          <source>The user should be able to navigate back and forth between the &lt;code&gt;DashboardComponent&lt;/code&gt; and the &lt;code&gt;HeroesComponent&lt;/code&gt; by clicking links in the navigation area near the top of the page.</source>
          <target state="translated">사용자는 페이지 상단 근처의 탐색 영역에서 링크를 클릭하여 &lt;code&gt;DashboardComponent&lt;/code&gt; 와 &lt;code&gt;HeroesComponent&lt;/code&gt; 간에 앞뒤로 이동할 수 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="e9cc50a2572132b6fe866bbf0976206cd31bec89" translate="yes" xml:space="preserve">
          <source>The user should be able to submit this form after filling it in. The &lt;em&gt;Submit&lt;/em&gt; button at the bottom of the form does nothing on its own, but it will trigger a form submit because of its type (&lt;code&gt;type=&quot;submit&quot;&lt;/code&gt;).</source>
          <target state="translated">사용자는이 양식을 작성한 후 제출할 수 있어야합니다. 양식 맨 아래에있는 &lt;em&gt;제출&lt;/em&gt; 단추는 자체적으로 아무 것도 수행하지 않지만 유형 ( &lt;code&gt;type=&quot;submit&quot;&lt;/code&gt; )으로 인해 양식 제출이 트리거됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e8ef51761e17807182420e3debbce24091d7fd9" translate="yes" xml:space="preserve">
          <source>The user should be able to submit this form after filling it in. The &lt;strong&gt;Submit&lt;/strong&gt; button at the bottom of the form does nothing on its own, but it does trigger a form-submit event because of its type (&lt;code&gt;type=&quot;submit&quot;&lt;/code&gt;). To respond to this event, take the following steps.</source>
          <target state="translated">사용자는이 양식을 작성한 후 제출할 수 있어야합니다. 양식 하단의 &lt;strong&gt;제출&lt;/strong&gt; 버튼은 자체적으로 아무 작업도 수행하지 않지만 유형 ( &lt;code&gt;type=&quot;submit&quot;&lt;/code&gt; ) 때문에 양식 제출 이벤트를 트리거합니다 . 이 이벤트에 응답하려면 다음 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="01ba075c2899372b1eb9a9b167514bce8549789e" translate="yes" xml:space="preserve">
          <source>The user types &lt;em&gt;Blue&lt;/em&gt; into the input element.</source>
          <target state="translated">사용자 는 입력 요소에 &lt;em&gt;Blue&lt;/em&gt; 를 입력합니다.</target>
        </trans-unit>
        <trans-unit id="746db581b79b8e44db4102f1f4a9027db5fb21fd" translate="yes" xml:space="preserve">
          <source>The user types a value into the input element, in this case the favorite color &lt;em&gt;Blue&lt;/em&gt;.</source>
          <target state="translated">사용자는 입력 요소에 값을 입력합니다 (이 경우 선호하는 색상 &lt;em&gt;Blue)&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0f5eade11b7a8a4872382f56342ccc7dae30caf1" translate="yes" xml:space="preserve">
          <source>The validation status of the control. There are four possible validation status values:</source>
          <target state="translated">컨트롤의 유효성 검사 상태입니다. 네 가지 가능한 유효성 검사 상태 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="98b77f9877456963068b672348f174d66942c7cb" translate="yes" xml:space="preserve">
          <source>The validation uses the TypeScript type checker and the options supplied to the TypeScript compiler to control how detailed the type validation is. For example, if the &lt;code&gt;strictTypeChecks&lt;/code&gt; is specified, the error &lt;code&gt;my.component.ts.MyComponent.html(1,1): : Object is possibly 'undefined'&lt;/code&gt; is reported as well as the above error message.</source>
          <target state="translated">유효성 검사는 TypeScript 형식 검사기와 TypeScript 컴파일러에 제공된 옵션을 사용하여 형식 유효성 검사의 세부 수준을 제어합니다. 예를 들어, &lt;code&gt;strictTypeChecks&lt;/code&gt; 가 지정된 경우, 오류 &lt;code&gt;my.component.ts.MyComponent.html(1,1): : Object is possibly 'undefined'&lt;/code&gt; 과 위의 오류 메시지가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="a629e0949c3e58ce213f6f6bd6ae68dbb3fa29cd" translate="yes" xml:space="preserve">
          <source>The validator code is as follows.</source>
          <target state="translated">유효성 검사기 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0d21ce6b8675f7d9e43afcf309b4fddb296bc7b1" translate="yes" xml:space="preserve">
          <source>The validator code is as follows:</source>
          <target state="translated">유효성 검사기 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9d7dbc5ca49f1ab98a4c94cd5b17358e1f32e71" translate="yes" xml:space="preserve">
          <source>The validator retrieves the child controls by calling the &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt;'s &lt;a href=&quot;../api/forms/abstractcontrol#get&quot;&gt;get&lt;/a&gt; method, then compares the values of the &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;alterEgo&lt;/code&gt; controls.</source>
          <target state="translated">유효성 검사기는 &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 의 &lt;a href=&quot;../api/forms/abstractcontrol#get&quot;&gt;get&lt;/a&gt; 메서드 를 호출하여 자식 컨트롤을 검색 한 다음 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;alterEgo&lt;/code&gt; 컨트롤 의 값을 비교 합니다.</target>
        </trans-unit>
        <trans-unit id="e446494ebae458b5aea2681dfd535005a9fb5001" translate="yes" xml:space="preserve">
          <source>The value</source>
          <target state="translated">가치</target>
        </trans-unit>
        <trans-unit id="b3ab44397f0e829c1263e8d41c48f13f570826c7" translate="yes" xml:space="preserve">
          <source>The value accessor for the control</source>
          <target state="translated">컨트롤의 값 접근 자</target>
        </trans-unit>
        <trans-unit id="516bd69561122628d42ad25e8281d2c0a9abe779" translate="yes" xml:space="preserve">
          <source>The value for each day of the week, based on the &lt;code&gt;en-US&lt;/code&gt; locale</source>
          <target state="translated">&lt;code&gt;en-US&lt;/code&gt; 로캘을 기반으로 한 요일의 값</target>
        </trans-unit>
        <trans-unit id="c2748ca458055ddfd5db76827b1b28c8b741c19c" translate="yes" xml:space="preserve">
          <source>The value is the statement to execute when the event occurs. If the statement evaluates to &lt;code&gt;false&lt;/code&gt;, then &lt;code&gt;preventDefault&lt;/code&gt; is applied on the DOM event. A handler method can refer to the &lt;code&gt;$event&lt;/code&gt; local variable.</source>
          <target state="translated">값은 이벤트가 발생할 때 실행할 명령문입니다. 에 문 평가되면 &lt;code&gt;false&lt;/code&gt; , 다음 &lt;code&gt;preventDefault&lt;/code&gt; DOM 이벤트에 적용됩니다. 핸들러 메소드는 &lt;code&gt;$event&lt;/code&gt; 로컬 변수를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a8273c4bd416c41f6f045c126981755bb55c2fa6" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../api/core/testing/componentfixture#nativeElement&quot;&gt;ComponentFixture.nativeElement&lt;/a&gt;&lt;/code&gt; has the &lt;code&gt;any&lt;/code&gt; type. Later you'll encounter the &lt;code&gt;&lt;a href=&quot;../api/core/debugelement#nativeElement&quot;&gt;DebugElement.nativeElement&lt;/a&gt;&lt;/code&gt; and it too has the &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/core/testing/componentfixture#nativeElement&quot;&gt;ComponentFixture.nativeElement&lt;/a&gt;&lt;/code&gt; 의 값은 &lt;code&gt;any&lt;/code&gt; 유형을 갖습니다 . 나중에 &lt;code&gt;&lt;a href=&quot;../api/core/debugelement#nativeElement&quot;&gt;DebugElement.nativeElement&lt;/a&gt;&lt;/code&gt; 가 발생 하고 &lt;code&gt;any&lt;/code&gt; 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ad903e2fa7af996e920297f63f7b7748e6d5872" translate="yes" xml:space="preserve">
          <source>The value of &lt;em&gt;settingOrProject&lt;/em&gt; is one of the following.</source>
          <target state="translated">&lt;em&gt;settingOrProject&lt;/em&gt; 의 값은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="74c4007c0c9568fe1d9f263c845a7b9cdffe9674" translate="yes" xml:space="preserve">
          <source>The value of a &lt;em&gt;value provider&lt;/em&gt; must be defined before you specify it here. The title string literal is immediately available. The &lt;code&gt;someHero&lt;/code&gt; variable in this example was set earlier in the file as shown below. You can't use a variable whose value will be defined later.</source>
          <target state="translated">여기에 &lt;em&gt;값 제공자&lt;/em&gt; 를 지정하기 전에 &lt;em&gt;값 제공자&lt;/em&gt; 의 값을 정의해야합니다. 제목 문자열 리터럴을 즉시 사용할 수 있습니다. 이 예제 의 &lt;code&gt;someHero&lt;/code&gt; 변수는 파일에서 이전에 아래와 같이 설정되었습니다. 나중에 값을 정의 할 변수는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c638e133e6a98cc0fc2d797245f610b6e500f4d6" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;enableIvy&lt;/code&gt; flag is set to &lt;code&gt;true&lt;/code&gt; by default, as of version 9.</source>
          <target state="translated">&lt;code&gt;enableIvy&lt;/code&gt; 플래그 의 값은 버전 9부터 기본적 으로 &lt;code&gt;true&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e40077c9021d6667f8d32f6871c8f00bc068d9d" translate="yes" xml:space="preserve">
          <source>The value of the iterable expression, which can be used as a &lt;a href=&quot;../../guide/structural-directives#template-input-variable&quot;&gt;template input variable&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../guide/structural-directives#template-input-variable&quot;&gt;템플리트 입력 변수&lt;/a&gt; 로 사용할 수있는 반복 가능한 표현식의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="e5b7782babd6cd47ebb1077395fdc52934d8acaf" translate="yes" xml:space="preserve">
          <source>The value or values to delete for the given header.</source>
          <target state="translated">주어진 헤더에 대해 삭제할 값입니다.</target>
        </trans-unit>
        <trans-unit id="c3a47c38e67f33789b5fcdb66f3ebef0b8ae5f17" translate="yes" xml:space="preserve">
          <source>The value or values to set or overide for the given header.</source>
          <target state="translated">주어진 헤더에 대해 설정하거나 재정의 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="9ea1a4ae4b9c004c5d2afcb14b6504f978c0f7ea" translate="yes" xml:space="preserve">
          <source>The value to append.</source>
          <target state="translated">추가 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="2b048ad41afe70b72be36c6e88e6bdc321667a94" translate="yes" xml:space="preserve">
          <source>The value to emit.</source>
          <target state="translated">방출 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="1d37da7064bd8c9a2adb3a8365e6b179578a33bb" translate="yes" xml:space="preserve">
          <source>The value to inject.</source>
          <target state="translated">주입 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="965b65af75152cd8483b194aca89f3d4a3563d3b" translate="yes" xml:space="preserve">
          <source>The value to remove, if provided.</source>
          <target state="translated">제공된 경우 제거 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="36090b23e6b19abea403f7cf11708f739d6ebe0a" translate="yes" xml:space="preserve">
          <source>The value.</source>
          <target state="translated">가치.</target>
        </trans-unit>
        <trans-unit id="752b8837b88dbea5e1b07283811801b832bbf900" translate="yes" xml:space="preserve">
          <source>The values in the store are serialized/deserialized using JSON.stringify/JSON.parse. So only boolean, number, string, null and non-class objects will be serialized and deserialzied in a non-lossy manner.</source>
          <target state="translated">상점의 값은 JSON.stringify / JSON.parse를 사용하여 직렬화 / 역 직렬화됩니다. 따라서 부울, 숫자, 문자열, null 및 비 클래스 객체 만 비 손실 방식으로 직렬화 및 역 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="52ff44818e20f7220d3cd6a6457d439574feaba5" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;heroForm&lt;/code&gt; is now a reference to the &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; directive that governs the form as a whole.</source>
          <target state="translated">변수 &lt;code&gt;heroForm&lt;/code&gt; 은 이제 폼을 전체적으로 제어하는 &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; 지시문에 대한 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="54da2a6d6e9f9a935b31b81218374530af583f38" translate="yes" xml:space="preserve">
          <source>The verbose form shows that &lt;code&gt;ref2&lt;/code&gt; is outside the parent template.</source>
          <target state="translated">자세한 형식은 &lt;code&gt;ref2&lt;/code&gt; 가 상위 템플릿 외부에 있음을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="3f524c06d92d1f81ab05583d4d275b72aa86fd3a" translate="yes" xml:space="preserve">
          <source>The version identifier of the app is determined by the contents of all resources, and it changes if any of them change. In practice, the version is determined by the contents of the &lt;code&gt;ngsw.json&lt;/code&gt; file, which includes hashes for all known content. If any of the cached files change, the file's hash will change in &lt;code&gt;ngsw.json&lt;/code&gt;, causing the Angular service worker to treat the active set of files as a new version.</source>
          <target state="translated">앱의 버전 식별자는 모든 리소스의 내용에 따라 결정되며 변경되면 변경됩니다. 실제로 버전은 모든 알려진 컨텐츠에 대한 해시를 포함 하는 &lt;code&gt;ngsw.json&lt;/code&gt; 파일 의 컨텐츠에 의해 결정됩니다 . 캐시 된 파일이 변경되면 파일의 해시가 &lt;code&gt;ngsw.json&lt;/code&gt; 에서 변경되어 Angular 서비스 워커가 활성 파일 세트를 새 버전으로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="61010f814fd314444171513bbb7090fb2e7c56e3" translate="yes" xml:space="preserve">
          <source>The version number is incremented based on the level of change included in the release.</source>
          <target state="translated">버전 번호는 릴리스에 포함 된 변경 레벨에 따라 증가합니다.</target>
        </trans-unit>
        <trans-unit id="a40aa756483f3a5f523498855f5257b57156b5a8" translate="yes" xml:space="preserve">
          <source>The view encapsulation strategy to use in the initial project.</source>
          <target state="translated">초기 프로젝트에서 사용할 뷰 캡슐화 전략.</target>
        </trans-unit>
        <trans-unit id="fa51a23f655a6d3d42ddb64f7327a8e642728256" translate="yes" xml:space="preserve">
          <source>The view encapsulation strategy to use in the new app.</source>
          <target state="translated">새 앱에서 사용할 뷰 캡슐화 전략</target>
        </trans-unit>
        <trans-unit id="fcf377037a7d42bc71c7f002d89b4f46b0d68cfa" translate="yes" xml:space="preserve">
          <source>The view encapsulation strategy to use in the new component.</source>
          <target state="translated">새 구성 요소에서 사용할 뷰 캡슐화 전략</target>
        </trans-unit>
        <trans-unit id="3f5b538e2927dd6de153329e296a74a421bc0c36" translate="yes" xml:space="preserve">
          <source>The view encapsulation type, which determines how styles are applied to DOM elements. One of</source>
          <target state="translated">스타일이 DOM 요소에 적용되는 방식을 결정하는 뷰 캡슐화 유형입니다. 중 하나</target>
        </trans-unit>
        <trans-unit id="52604a8e00ae2362f799cae913f8150372948692" translate="yes" xml:space="preserve">
          <source>The view hierarchy doesn't imply a component hierarchy. Views that are embedded in the context of a particular hierarchy can be host views of other components. Those components can be in the same NgModule as the hosting component, or belong to other NgModules.</source>
          <target state="translated">뷰 계층 구조는 구성 요소 계층 구조를 의미하지 않습니다. 특정 계층의 컨텍스트에 포함 된 뷰는 다른 구성 요소의 호스트 뷰일 수 있습니다. 이러한 구성 요소는 호스팅 구성 요소와 동일한 NgModule에 있거나 다른 NgModules에 속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7838a7b8c734a7282cb30df6d8616064238194b" translate="yes" xml:space="preserve">
          <source>The view to insert.</source>
          <target state="translated">삽입 할 뷰입니다.</target>
        </trans-unit>
        <trans-unit id="4ea024c3fe94500d702337f77198fe17d570e08e" translate="yes" xml:space="preserve">
          <source>The view to move.</source>
          <target state="translated">이동할보기입니다.</target>
        </trans-unit>
        <trans-unit id="64ae54575a804f27c02ce687200e683460668cdb" translate="yes" xml:space="preserve">
          <source>The view to query.</source>
          <target state="translated">조회 할보기입니다.</target>
        </trans-unit>
        <trans-unit id="c984239cd56798261fc1dbd922778058b32b773d" translate="yes" xml:space="preserve">
          <source>The view-to-model diagram shows how data flows when an input field's value is changed from the view through the following steps.</source>
          <target state="translated">뷰-모델 다이어그램은 다음 단계를 통해 입력 필드의 값이 뷰에서 변경 될 때 데이터 흐름을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f7eca5f51435a85c65dffa7d0a3287d518cfc6d9" translate="yes" xml:space="preserve">
          <source>The virtual file system is represented by a &lt;code&gt;Tree&lt;/code&gt;. The &lt;code&gt;Tree&lt;/code&gt; data structure contains a &lt;em&gt;base&lt;/em&gt; (a set of files that already exists) and a &lt;em&gt;staging area&lt;/em&gt; (a list of changes to be applied to the base). When making modifications, you don't actually change the base, but add those modifications to the staging area.</source>
          <target state="translated">가상 파일 시스템은 &lt;code&gt;Tree&lt;/code&gt; 로 표시됩니다 . &lt;code&gt;Tree&lt;/code&gt; 데이터 구조가 포함 된 &lt;em&gt;기지국&lt;/em&gt; (이미 존재하는 파일의 집합)와 &lt;em&gt;스테이징 영역&lt;/em&gt; (변화 목록 기재에 적용되는 참조). 수정을 할 때는 실제로베이스를 변경하지 않고 스테이징 영역에 수정 사항을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="2cefd7f9cff91ac8ee2cb82756abed3d99ad82ad" translate="yes" xml:space="preserve">
          <source>The web is used by a wide variety of people, including those who have visual or motor impairments. A variety of assistive technologies are available that make it much easier for these groups to interact with web-based software applications. In addition, designing an application to be more accessible generally improves the user experience for all users.</source>
          <target state="translated">웹은 시각 또는 운동 장애가있는 사람들을 포함하여 다양한 사람들이 사용합니다. 이러한 그룹이 웹 기반 소프트웨어 응용 프로그램과보다 쉽게 ​​상호 작용할 수 있도록 다양한 보조 기술을 사용할 수 있습니다. 또한보다 쉽게 ​​액세스 할 수 있도록 응용 프로그램을 디자인하면 일반적으로 모든 사용자의 사용자 경험이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="0870b1ddd7a401e28edca7748851260cf0d812b1" translate="yes" xml:space="preserve">
          <source>The web server must distinguish &lt;em&gt;app page requests&lt;/em&gt; from other kinds of requests.</source>
          <target state="translated">웹 서버는 &lt;em&gt;앱 페이지 요청&lt;/em&gt; 을 다른 종류의 요청 과 구분해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3bcd56955050ccb3584a4da36608073e9ca82456" translate="yes" xml:space="preserve">
          <source>The wildcard state &lt;code&gt;*&lt;/code&gt; matches to &lt;em&gt;any&lt;/em&gt; state, including &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">와일드 카드 상태 &lt;code&gt;*&lt;/code&gt; 는 &lt;code&gt;void&lt;/code&gt; 를 포함한 &lt;em&gt;모든&lt;/em&gt; 상태 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="cdfa623802e57793c0a1db6ff9d61453c796514c" translate="yes" xml:space="preserve">
          <source>The word &lt;code&gt;&lt;a href=&quot;../api/common/uppercasepipe&quot;&gt;uppercase&lt;/a&gt;&lt;/code&gt; in the interpolation binding, right after the pipe operator ( | ), activates the built-in &lt;code&gt;UppercasePipe&lt;/code&gt;.</source>
          <target state="translated">파이프 연산자 (|) 바로 다음에 보간 바인딩에서 &lt;code&gt;&lt;a href=&quot;../api/common/uppercasepipe&quot;&gt;uppercase&lt;/a&gt;&lt;/code&gt; 라는 단어 가 내장 된 &lt;code&gt;UppercasePipe&lt;/code&gt; 를 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="b02e653c1a608596d35a7fd022b60a7182b55381" translate="yes" xml:space="preserve">
          <source>The wording of each guideline indicates how strong the recommendation is.</source>
          <target state="translated">각 지침의 문구는 권장 사항이 얼마나 강력한지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7c860c7e7f5c46dabbf52c5dc7a52a91bc246694" translate="yes" xml:space="preserve">
          <source>Their details are quite different in architecture and implementation. In AngularJS, you add Angular assets to the &lt;code&gt;angular.module&lt;/code&gt; property. In Angular, you create one or more classes adorned with an &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; decorator that describes Angular assets in metadata. The differences blossom from there.</source>
          <target state="translated">그들의 세부 사항은 아키텍처와 구현에서 상당히 다릅니다. AngularJS에서는 &lt;code&gt;angular.module&lt;/code&gt; 속성에 Angular 자산을 추가 합니다. Angular에서는 메타 데이터의 Angular 자산을 설명 하는 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 데코레이터 로 장식 된 하나 이상의 클래스를 만듭니다 . 거기에서 차이점이 생깁니다.</target>
        </trans-unit>
        <trans-unit id="1c9f03dfa8dacad02e2c3ca38cbf5ee7fdadd4d0" translate="yes" xml:space="preserve">
          <source>Their details are quite different in architecture and implementation. In AngularJS, you create a module by specifying its name and dependencies with &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.module&quot;&gt;angular.module()&lt;/a&gt;. Then you can add assets using its various methods. In Angular, you create a class adorned with an &lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt; decorator that describes assets in metadata.</source>
          <target state="translated">그들의 세부 사항은 아키텍처와 구현에서 상당히 다릅니다. AngularJS에서는 &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.module&quot;&gt;angular.module ()으로&lt;/a&gt; 이름과 종속성을 지정하여 모듈을 만듭니다 . 그런 다음 다양한 방법을 사용하여 자산을 추가 할 수 있습니다. Angular에서는 메타 데이터의 자산을 설명 하는 &lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt; 데코레이터 로 장식 된 클래스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="4a746b75626a8bf1b8d141962d550672ee26a9a0" translate="yes" xml:space="preserve">
          <source>Then Angular calls the &lt;code&gt;ngAfterViewInit&lt;/code&gt; lifecycle hook at which time it is &lt;em&gt;too late&lt;/em&gt; to update the parent view's display of the countdown seconds. Angular's unidirectional data flow rule prevents updating the parent view's in the same cycle. The app has to &lt;em&gt;wait one turn&lt;/em&gt; before it can display the seconds.</source>
          <target state="translated">그런 다음 Angular는 &lt;code&gt;ngAfterViewInit&lt;/code&gt; 수명주기 후크를 호출하여 &lt;em&gt;너무 늦어&lt;/em&gt; 부모 뷰의 카운트 다운 초 표시를 업데이트하지 않습니다. Angular의 단방향 데이터 흐름 규칙은 동일한주기에서 상위 뷰를 업데이트하지 못하게합니다. 앱은 초를 표시하기 전에 &lt;em&gt;한 번 기다려야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="dbecf897d73ac2b6641e82fba7920890079f1124" translate="yes" xml:space="preserve">
          <source>Then add &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; to the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; metadata's &lt;code&gt;imports&lt;/code&gt; array, which contains a list of external modules that the app needs.</source>
          <target state="translated">그런 다음 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt; 메타 데이터의 &lt;code&gt;imports&lt;/code&gt; 배열 에 &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; 을 추가 합니다. 여기에는 앱에 필요한 외부 모듈 목록이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="302c6ab52d600acc4553bea66d084dd5f7f37330" translate="yes" xml:space="preserve">
          <source>Then add a &lt;em&gt;parameterized&lt;/em&gt; route to the &lt;code&gt;AppRoutingModule.routes&lt;/code&gt; array that matches the path pattern to the &lt;em&gt;hero detail&lt;/em&gt; view.</source>
          <target state="translated">그런 다음 경로 패턴과 &lt;em&gt;히어로 상세&lt;/em&gt; 보기 와 일치하는 &lt;code&gt;AppRoutingModule.routes&lt;/code&gt; 배열에 &lt;em&gt;매개 변수화 된&lt;/em&gt; 경로를 추가하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7087a31795c1cc6622e1648ea10337e6e7796752" translate="yes" xml:space="preserve">
          <source>Then add it to the &lt;code&gt;providers&lt;/code&gt; array of the testing module configuration:</source>
          <target state="translated">그런 다음 테스트 모듈 구성 의 &lt;code&gt;providers&lt;/code&gt; 배열에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="476c63ff60da4bb61e86cb5f4efd206fa03aa9dc" translate="yes" xml:space="preserve">
          <source>Then add the &lt;code&gt;&lt;a href=&quot;../api/common/http/testing/httpclienttestingmodule&quot;&gt;HttpClientTestingModule&lt;/a&gt;&lt;/code&gt; to the &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; and continue with the setup of the &lt;em&gt;service-under-test&lt;/em&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;../api/common/http/testing/httpclienttestingmodule&quot;&gt;HttpClientTestingModule&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; 에 추가하고 &lt;em&gt;테스트중인 서비스&lt;/em&gt; 설정을 계속하십시오 .</target>
        </trans-unit>
        <trans-unit id="1bfa821c841240ffbf8adf699d29a6b8346ac678" translate="yes" xml:space="preserve">
          <source>Then add two event handlers that respond when the mouse enters or leaves, each adorned by the &lt;code&gt;&lt;a href=&quot;../api/core/hostlistener&quot;&gt;HostListener&lt;/a&gt;&lt;/code&gt; decorator.</source>
          <target state="translated">그런 다음 마우스가 들어 오거나 나올 때 응답하는 두 개의 이벤트 핸들러를 각각 &lt;code&gt;&lt;a href=&quot;../api/core/hostlistener&quot;&gt;HostListener&lt;/a&gt;&lt;/code&gt; 데코레이터가 장식합니다.</target>
        </trans-unit>
        <trans-unit id="2077cb3e1b43eb4d0aa0bdfb4e87ddd6fe05d012" translate="yes" xml:space="preserve">
          <source>Then change &lt;code&gt;main-aot.ts&lt;/code&gt; to bootstrap the &lt;code&gt;AppComponentFactory&lt;/code&gt; that was generated by the AOT compiler:</source>
          <target state="translated">다음 변경 &lt;code&gt;main-aot.ts&lt;/code&gt; 부트 스트랩하는 &lt;code&gt;AppComponentFactory&lt;/code&gt; AOT 컴파일러에 의해 생성 하였다 :</target>
        </trans-unit>
        <trans-unit id="8f98a3b01b00f3cdc0645e1bb016df36002ccc41" translate="yes" xml:space="preserve">
          <source>Then create some HTML to try it.</source>
          <target state="translated">그런 다음 HTML을 만들어보십시오.</target>
        </trans-unit>
        <trans-unit id="ed0c20efaf787e9c5968245911ff8d07f8f0da7a" translate="yes" xml:space="preserve">
          <source>Then declare them in the &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; configuration next to the components, directives, and pipes that need to be real.</source>
          <target state="translated">그런 다음 실제 필요한 구성 요소, 지시문 및 파이프 옆 의 &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; 구성 에서이를 선언하십시오 .</target>
        </trans-unit>
        <trans-unit id="e412dc563abd459ce251cf7cfccd9f863136e63b" translate="yes" xml:space="preserve">
          <source>Then each test invokes &lt;code&gt;setup()&lt;/code&gt; in its first line, before continuing with steps that manipulate the test subject and assert expectations.</source>
          <target state="translated">그런 다음 각 테스트는 첫 번째 행에서 &lt;code&gt;setup()&lt;/code&gt; 을 호출 하여 테스트 주제를 조작하고 기대를 확인하는 단계를 계속합니다.</target>
        </trans-unit>
        <trans-unit id="150a9555cd5004b3999517db04d6f79faab05564" translate="yes" xml:space="preserve">
          <source>Then exercise the component class, remembering to call the &lt;a href=&quot;lifecycle-hooks&quot;&gt;lifecycle hook methods&lt;/a&gt; as Angular does when running the app.</source>
          <target state="translated">그런 다음 앱을 실행할 때 Angular에서와 같이 &lt;a href=&quot;lifecycle-hooks&quot;&gt;수명주기 후크 메서드&lt;/a&gt; 를 호출하는 것을 기억하면서 구성 요소 클래스를 연습하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb4a68d7b2f52dce99079de606d30ebaa5bb531f" translate="yes" xml:space="preserve">
          <source>Then go to &lt;code&gt;localhost:4200&lt;/code&gt; where you should see &amp;ldquo;app works!&amp;rdquo; and three buttons.</source>
          <target state="translated">그런 다음 &lt;code&gt;localhost:4200&lt;/code&gt; 으로 이동하여 &amp;ldquo;app works!&amp;rdquo;가 표시되어야합니다. 그리고 세 개의 버튼.</target>
        </trans-unit>
        <trans-unit id="a49419a5b8645cd07645760c057756d92e18c23d" translate="yes" xml:space="preserve">
          <source>Then go to &lt;code&gt;localhost:4200&lt;/code&gt; where you should see &amp;ldquo;customer-app&amp;rdquo; and three buttons.</source>
          <target state="translated">그런 다음 &quot;customer-app&quot;과 세 개의 버튼이 표시되는 &lt;code&gt;localhost:4200&lt;/code&gt; 으로 이동 합니다.</target>
        </trans-unit>
        <trans-unit id="38933987a79b6e0405d4682b79b28629cbf06cda" translate="yes" xml:space="preserve">
          <source>Then import and add it to the &lt;code&gt;AppModule&lt;/code&gt;&lt;em&gt;providers array&lt;/em&gt; like this:</source>
          <target state="translated">그런 다음 &lt;code&gt;AppModule&lt;/code&gt; &lt;em&gt;provider 배열에 &lt;/em&gt;가져와 다음과 같이 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba51c703735b0a9ca10a1f38c791fa66ebf4dc99" translate="yes" xml:space="preserve">
          <source>Then inject &lt;code&gt;&lt;a href=&quot;upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; into your Angular &lt;code&gt;&lt;a href=&quot;../../core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; and use it to bootstrap the top level &lt;a href=&quot;https://docs.angularjs.org/api/ng/type/angular.Module&quot;&gt;AngularJS module&lt;/a&gt; in the &lt;code&gt;ngDoBootstrap()&lt;/code&gt; method.</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 을 Angular &lt;code&gt;&lt;a href=&quot;../../core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 에 주입 하고이를 사용 하여 &lt;code&gt;ngDoBootstrap()&lt;/code&gt; 메소드 에서 최상위 &lt;a href=&quot;https://docs.angularjs.org/api/ng/type/angular.Module&quot;&gt;AngularJS 모듈&lt;/a&gt; 을 부트 스트랩하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea80e24f31be172808e0a76630ab02df1fbba4cf" translate="yes" xml:space="preserve">
          <source>Then inject it inside a test by calling &lt;code&gt;TestBed.get()&lt;/code&gt; with the service class as the argument.</source>
          <target state="translated">그런 다음 서비스 클래스를 인수로하여 &lt;code&gt;TestBed.get()&lt;/code&gt; 을 호출하여 테스트에 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="dee306a2d35591d51fe2402e82a0ca9f0820f749" translate="yes" xml:space="preserve">
          <source>Then inject it inside a test by calling &lt;code&gt;TestBed.inject()&lt;/code&gt; with the service class as the argument.</source>
          <target state="translated">그런 다음 서비스 클래스를 인수로 사용하여 &lt;code&gt;TestBed.inject()&lt;/code&gt; 를 호출하여 테스트 내부에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="ed47e3226a89095f74e2f4a490e662cccb0ebbc0" translate="yes" xml:space="preserve">
          <source>Then modify the &lt;code&gt;app.component.ts&lt;/code&gt; file by changing the template and the body of the component.</source>
          <target state="translated">그런 다음 템플리트 및 컴포넌트 본문을 변경 하여 &lt;code&gt;app.component.ts&lt;/code&gt; 파일을 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f2ea7f19a02db5f1bb037406ad378d2b4d2753b" translate="yes" xml:space="preserve">
          <source>Then provide and inject &lt;em&gt;both the&lt;/em&gt;&lt;strong&gt;component&lt;/strong&gt;&lt;em&gt;and the service&lt;/em&gt; in the &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; configuration.</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; 구성 에서 &lt;strong&gt;구성 요소 &lt;/strong&gt;&lt;em&gt;와 서비스&lt;/em&gt; 를 제공하고 주입 &lt;em&gt;하십시오&lt;/em&gt; .&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6575d9ffd1443fafb383b5f99065fc07d42c1e8a" translate="yes" xml:space="preserve">
          <source>Then provide the &lt;code&gt;&lt;a href=&quot;../api/core/locale_id&quot;&gt;LOCALE_ID&lt;/a&gt;&lt;/code&gt; in the main module:</source>
          <target state="translated">그런 다음 기본 모듈에서 &lt;code&gt;&lt;a href=&quot;../api/core/locale_id&quot;&gt;LOCALE_ID&lt;/a&gt;&lt;/code&gt; 를 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="5cd36815d6513b0d19bf87503dfe0afab93f9fa9" translate="yes" xml:space="preserve">
          <source>Then reload with &lt;code&gt;Cmd+r&lt;/code&gt; or &lt;code&gt;Ctrl+r&lt;/code&gt;, depending on your platform.</source>
          <target state="translated">그런 다음 플랫폼에 따라 &lt;code&gt;Cmd+r&lt;/code&gt; 또는 &lt;code&gt;Ctrl+r&lt;/code&gt; 로 다시로드 하십시오.</target>
        </trans-unit>
        <trans-unit id="62acde2949df74c80c6b969effb470f5543854f7" translate="yes" xml:space="preserve">
          <source>Then the following link &lt;code&gt;&amp;lt;&lt;a href=&quot;routerlinkwithhref&quot;&gt;a&lt;/a&gt; [&lt;a href=&quot;routerlink&quot;&gt;routerLink&lt;/a&gt;]=&quot;['/user/jim']&quot;&amp;gt;Jim&amp;lt;/&lt;a href=&quot;routerlinkwithhref&quot;&gt;a&lt;/a&gt;&amp;gt;&lt;/code&gt; will generate the link &lt;code&gt;/user/(jim//aux:team)&lt;/code&gt;.</source>
          <target state="translated">그런 다음, 다음 링크 &lt;code&gt;&amp;lt;&lt;a href=&quot;routerlinkwithhref&quot;&gt;a&lt;/a&gt; [&lt;a href=&quot;routerlink&quot;&gt;routerLink&lt;/a&gt;]=&quot;['/user/jim']&quot;&amp;gt;Jim&amp;lt;/&lt;a href=&quot;routerlinkwithhref&quot;&gt;a&lt;/a&gt;&amp;gt;&lt;/code&gt; 링크 생성 &lt;code&gt;/user/(jim//aux:team)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf4cba0cf8f8221ce918d56c4b25cb5bf60574f6" translate="yes" xml:space="preserve">
          <source>Then use &lt;code&gt;relativeTo&lt;/code&gt; in your navigation method. After the link parameters array, which here contains &lt;code&gt;items&lt;/code&gt;, add an object with the &lt;code&gt;relativeTo&lt;/code&gt; property set to the &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt;, which is &lt;code&gt;this.route&lt;/code&gt;.</source>
          <target state="translated">그런 다음 탐색 방법에서 &lt;code&gt;relativeTo&lt;/code&gt; 를 사용 하십시오. 여기에 포함 된 링크 파라미터 배열 후에 &lt;code&gt;items&lt;/code&gt; 의 목적으로 추가 &lt;code&gt;relativeTo&lt;/code&gt; 받는 특성 세트 &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; 이다 &lt;code&gt;this.route&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31a24e38017cc0ca331b2c164af11448fb71f88f" translate="yes" xml:space="preserve">
          <source>Then use the service inside your component by injecting it in the component constructor using its class as a type annotation:</source>
          <target state="translated">그런 다음 클래스를 유형 주석으로 사용하여 컴포넌트 생성자에 컴포넌트를 삽입하여 컴포넌트 내부의 서비스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3d28664e3228d12b67d0ad4e11b39b8bfa234399" translate="yes" xml:space="preserve">
          <source>Then you can assert that the quote element displays the expected text.</source>
          <target state="translated">그런 다음 quote 요소가 예상 텍스트를 표시하도록 주장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb5aa1a656847347c6ad33e809979b893a2a0af1" translate="yes" xml:space="preserve">
          <source>Then you can use the &quot;upgraded&quot; AngularJS service by injecting it into an Angular component or service.</source>
          <target state="translated">그런 다음 &quot;업그레이드 된&quot;AngularJS 서비스를 Angular 컴포넌트 또는 서비스에 삽입하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7235d5f78eb3fc75c9de23a894249dff7395ce21" translate="yes" xml:space="preserve">
          <source>Then you create a child component (B) that defines its own, &lt;em&gt;specialized&lt;/em&gt; providers for &lt;code&gt;CarService&lt;/code&gt; and &lt;code&gt;EngineService&lt;/code&gt; that have special capabilities suitable for whatever is going on in component (B).</source>
          <target state="translated">그런 다음 컴포넌트 (B)에서 발생하는 모든 작업에 적합한 특수 기능이있는 &lt;code&gt;CarService&lt;/code&gt; 및 &lt;code&gt;EngineService&lt;/code&gt; 에 대한 고유 한 &lt;em&gt;특수&lt;/em&gt; 제공자를 정의하는 하위 컴포넌트 (B)를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="13b7250037e2791c30d8b2b60220889c166804a2" translate="yes" xml:space="preserve">
          <source>Then you inject the &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;HeroListComponent&lt;/code&gt; constructor.</source>
          <target state="translated">그런 다음 주입 &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; 을 에 &lt;code&gt;HeroListComponent&lt;/code&gt; 의 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="06b87cc1eeb739adae3341e69733b9a6c335c899" translate="yes" xml:space="preserve">
          <source>Then you should define an Angular provider to be included in your &lt;code&gt;&lt;a href=&quot;../../core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt;&lt;code&gt;providers&lt;/code&gt; property.</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;../../core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; &lt;code&gt;providers&lt;/code&gt; 속성에 포함 할 Angular 제공자를 정의해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3996f4d02c86b0214c6856fbd020c552536ef23e" translate="yes" xml:space="preserve">
          <source>Then you tell the &lt;code&gt;HeroService&lt;/code&gt; to fetch the hero with that &lt;code&gt;id&lt;/code&gt; and return the result of the &lt;code&gt;HeroService&lt;/code&gt; request.</source>
          <target state="translated">그런 다음 &lt;code&gt;HeroService&lt;/code&gt; 에 해당 &lt;code&gt;id&lt;/code&gt; 가진 영웅을 가져오고 &lt;code&gt;HeroService&lt;/code&gt; 요청 의 결과를 리턴하도록 지시하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed06e960c3c34ee183cdb9c0a6a2a5d5f20a03f6" translate="yes" xml:space="preserve">
          <source>Then, another animation can be called when the current animation finishes. For example, the button goes from the &lt;code&gt;inProgress&lt;/code&gt; state to the &lt;code&gt;closed&lt;/code&gt; state when the API call is completed.</source>
          <target state="translated">그런 다음 현재 애니메이션이 끝나면 다른 애니메이션을 호출 할 수 있습니다. 예를 들어, 버튼에서가는 &lt;code&gt;inProgress&lt;/code&gt; 받는 상태 &lt;code&gt;closed&lt;/code&gt; API 호출이 완료 될 때 상태입니다.</target>
        </trans-unit>
        <trans-unit id="6309056a807e88260ec1b8e1f7ee99de74f63bb1" translate="yes" xml:space="preserve">
          <source>Then, the code contains an &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; decorator with the &lt;code&gt;childItem&lt;/code&gt; property so data can flow into it.</source>
          <target state="translated">그런 다음 코드에는 데이터가 유입 될 수 있도록 &lt;code&gt;childItem&lt;/code&gt; 속성 이있는 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 데코레이터가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="edf82d0382f477967edce3fb6b12681334c96dc8" translate="yes" xml:space="preserve">
          <source>Then, when some component injects &lt;code&gt;UserService&lt;/code&gt;, Angular finds it in the app root injector, and delivers the app-wide singleton service. No problem.</source>
          <target state="translated">그런 다음 일부 구성 요소가 &lt;code&gt;UserService&lt;/code&gt; 를 주입 하면 Angular는이를 응용 프로그램 루트 인젝터에서 찾아서 응용 프로그램 전체의 싱글 톤 서비스를 제공합니다. 문제 없어요.</target>
        </trans-unit>
        <trans-unit id="c3a0ceb7d76985503f10a062c39d4ecc9f73b6e5" translate="yes" xml:space="preserve">
          <source>Then, when you need that file&amp;rsquo;s code in another file, you import it like this:</source>
          <target state="translated">그런 다음 다른 파일에 해당 파일의 코드가 필요할 때 다음과 같이 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7f94783b2fdbdd4b5788239abe980a7f9c2a0feb" translate="yes" xml:space="preserve">
          <source>Then, you change into your library directory to build the schematic</source>
          <target state="translated">그런 다음 라이브러리 디렉토리로 변경하여 회로도를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b558f2a5f6c20368ac31efe8ab04dc45d807c8b6" translate="yes" xml:space="preserve">
          <source>There are &lt;em&gt;important differences&lt;/em&gt; in the way the router treats these &lt;em&gt;child routes&lt;/em&gt;.</source>
          <target state="translated">라우터가 이러한 &lt;em&gt;하위 경로를&lt;/em&gt; 처리하는 방식 에는 &lt;em&gt;중요한 차이점&lt;/em&gt; 이 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="566ab24996dda55d07b696f9fcb91995338b7d7a" translate="yes" xml:space="preserve">
          <source>There are a few cases where you give a component an attribute, such as when you want to augment a built-in element. For example, &lt;a href=&quot;https://material.angular.io/components/button/overview&quot;&gt;Material Design&lt;/a&gt; uses this technique with &lt;code&gt;&amp;lt;button mat-button&amp;gt;&lt;/code&gt;. However, you wouldn't use this technique on a custom element.</source>
          <target state="translated">내장 요소를 기능 보강하려는 경우와 같이 구성 요소에 속성을 제공하는 경우가 있습니다. 예를 들어 &lt;a href=&quot;https://material.angular.io/components/button/overview&quot;&gt;머티리얼 디자인&lt;/a&gt; 은이 기술을 &lt;code&gt;&amp;lt;button mat-button&amp;gt;&lt;/code&gt; 과 함께 사용합니다 . 그러나 사용자 지정 요소에는이 기술을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a44db3593849baa6fd286f1a9dad3ee4be9f41f" translate="yes" xml:space="preserve">
          <source>There are a few exceptional observables where this is not necessary. The &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; observables are among the exceptions.</source>
          <target state="translated">이것이 필요하지 않은 예외적 인 관측 물이 몇 가지 있습니다. &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; 의 관찰 가능한이 예외 중입니다.</target>
        </trans-unit>
        <trans-unit id="1e9c60f04e3a15c6ff01e79a5018c059fb20d209" translate="yes" xml:space="preserve">
          <source>There are a few limited reasons why the Angular service worker might change the version of a running app. Some of them are error conditions:</source>
          <target state="translated">Angular 서비스 워커가 실행중인 앱의 버전을 변경하는 데는 몇 가지 제한적인 이유가 있습니다. 그들 중 일부는 오류 조건입니다.</target>
        </trans-unit>
        <trans-unit id="a6013a4fe41dc5c7411d2f89c39f1e20616a17ba" translate="yes" xml:space="preserve">
          <source>There are a few options if you want to get correct types for your custom elements. Let's assume you create a &lt;code&gt;my-dialog&lt;/code&gt; custom element based on the following component:</source>
          <target state="translated">사용자 정의 요소에 올바른 유형을 얻으려면 몇 가지 옵션이 있습니다. 다음 컴포넌트를 기반으로 &lt;code&gt;my-dialog&lt;/code&gt; 사용자 정의 요소 를 작성한다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="3191a1618b8faa99c49daa031fba849003a13bd3" translate="yes" xml:space="preserve">
          <source>There are a few rules in particular that will make it much easier to do &lt;em&gt;an incremental upgrade&lt;/em&gt; using the Angular &lt;code&gt;&lt;a href=&quot;../api/upgrade/static&quot;&gt;upgrade/static&lt;/a&gt;&lt;/code&gt; module:</source>
          <target state="translated">특히 Angular &lt;code&gt;&lt;a href=&quot;../api/upgrade/static&quot;&gt;upgrade/static&lt;/a&gt;&lt;/code&gt; 모듈을 사용하여 &lt;em&gt;증분 업그레이드&lt;/em&gt; 를 훨씬 쉽게 수행 할 수있는 몇 가지 규칙이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a01d9115f3a3ad52c673da81193da8c683b0a1c6" translate="yes" xml:space="preserve">
          <source>There are a few things to note, though:</source>
          <target state="translated">그러나 몇 가지주의 할 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdc057156f4a0afc834e3e15f4b4be9942560eb6" translate="yes" xml:space="preserve">
          <source>There are a number of options for modifying the default search behavior, using &lt;em&gt;parameter decorators&lt;/em&gt; on the service-valued parameters of a class constructor.</source>
          <target state="translated">클래스 생성자의 서비스 값 매개 변수에 &lt;em&gt;매개 변수 데코레이터&lt;/em&gt; 를 사용하여 기본 검색 동작을 수정하는 여러 가지 옵션이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c676ec6b692f6df001e20a544ca9a4ac7cc35255" translate="yes" xml:space="preserve">
          <source>There are also completions within elements. Any elements you have as a component selector will show up in the completion list.</source>
          <target state="translated">요소 내에 완성도 있습니다. 컴포넌트 선택기로 보유한 모든 요소가 완료 목록에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2b0041e80379dba90a5c135457752493c4e52ac4" translate="yes" xml:space="preserve">
          <source>There are configuration files for both the &lt;a href=&quot;https://karma-runner.github.io/latest/config/configuration-file.html&quot;&gt;Karma JavaScript test runner&lt;/a&gt; and &lt;a href=&quot;https://www.protractortest.org/#/api-overview&quot;&gt;Protractor&lt;/a&gt; end-to-end testing tool, which you must adjust to start Chrome without sandboxing.</source>
          <target state="translated">&lt;a href=&quot;https://karma-runner.github.io/latest/config/configuration-file.html&quot;&gt;Karma JavaScript 테스트 러너&lt;/a&gt; 및 &lt;a href=&quot;https://www.protractortest.org/#/api-overview&quot;&gt;각도기&lt;/a&gt; 엔드 투 엔드 테스트 도구에 대한 구성 파일이 있으며 샌드 박싱없이 Chrome을 시작하도록 조정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8f70e6e9da25ad1b098bbc6719f6c5877729d762" translate="yes" xml:space="preserve">
          <source>There are five general categories of feature modules which tend to fall into the following groups:</source>
          <target state="translated">다음과 같은 그룹으로 분류되는 5 가지 일반적인 기능 모듈 범주가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f083c43f33d22558e0080c2eef9a154aecda0827" translate="yes" xml:space="preserve">
          <source>There are important differences in the way the router treats child routes.</source>
          <target state="translated">라우터가 하위 경로를 처리하는 방식에는 중요한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d24499582f9d74be4e55dfd292e78d548d73a51" translate="yes" xml:space="preserve">
          <source>There are many more interceptors in the complete sample code.</source>
          <target state="translated">완전한 샘플 코드에는 더 많은 인터셉터가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a08951de0f1de6bd2f6e60bba79ba111ed7ae1d7" translate="yes" xml:space="preserve">
          <source>There are many resources to complement the Angular docs. Mozilla's MDN docs include both &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/HTML&quot;&gt;HTML&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript&quot;&gt;JavaScript&lt;/a&gt; introductions. &lt;a href=&quot;https://www.typescriptlang.org/docs/home.html&quot;&gt;TypeScript's docs&lt;/a&gt; include a 5-minute tutorial. Various online course platforms, such as &lt;a href=&quot;http://www.udemy.com&quot;&gt;Udemy&lt;/a&gt; and &lt;a href=&quot;https://www.codecademy.com/&quot;&gt;Codecademy&lt;/a&gt;, also cover web development basics.</source>
          <target state="translated">Angular 문서를 보완하는 많은 리소스가 있습니다. Mozilla의 MDN 문서에는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/HTML&quot;&gt;HTML&lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript&quot;&gt;JavaScript&lt;/a&gt; 소개가 모두 포함되어 있습니다 . &lt;a href=&quot;https://www.typescriptlang.org/docs/home.html&quot;&gt;TypeScript의 문서&lt;/a&gt; 에는 5 분 자습서가 포함되어 있습니다. &lt;a href=&quot;http://www.udemy.com&quot;&gt;Udemy&lt;/a&gt; 및 &lt;a href=&quot;https://www.codecademy.com/&quot;&gt;Codecademy&lt;/a&gt; 와 같은 다양한 온라인 코스 플랫폼 도 웹 개발 기본 사항을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="66ad0af28f7ac3d95ccbf0739cccfa8af77155a9" translate="yes" xml:space="preserve">
          <source>There are many ways to structure AngularJS applications. When you begin to upgrade these applications to Angular, some will turn out to be much more easy to work with than others. There are a few key techniques and patterns that you can apply to future proof apps even before you begin the migration.</source>
          <target state="translated">AngularJS 애플리케이션을 구성하는 방법에는 여러 가지가 있습니다. 이러한 응용 프로그램을 Angular로 업그레이드하기 시작하면 일부 응용 프로그램이 다른 응용 프로그램보다 작업하기가 훨씬 쉽습니다. 마이그레이션을 시작하기 전에도 미래의 증거 앱에 적용 할 수있는 몇 가지 주요 기술과 패턴이 있습니다.</target>
        </trans-unit>
        <trans-unit id="00d98f0576741a1e108297fca91f90e751881e55" translate="yes" xml:space="preserve">
          <source>There are multiple ways to prevent this:</source>
          <target state="translated">이를 방지하는 여러 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff870a40c32b15241e0dc290ffe99e696ec7e316" translate="yes" xml:space="preserve">
          <source>There are new requirements for the Tour of Heroes app:</source>
          <target state="translated">Tour of Heroes 앱에 대한 새로운 요구 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7c35a18e43689374a55ffc6988124f5f7c095f9" translate="yes" xml:space="preserve">
          <source>There are no easy answers to these questions. Prohibiting multiple structural directives makes them moot. There's an easy solution for this use case: put the &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; on a container element that wraps the &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; element. One or both elements can be an &lt;a href=&quot;structural-directives#ngcontainer&quot;&gt;&lt;code&gt;ng-container&lt;/code&gt;&lt;/a&gt; so you don't have to introduce extra levels of HTML.</source>
          <target state="translated">이 질문들에 대한 쉬운 대답은 없습니다. 여러 구조적 지시문을 금지하면 문제가 발생합니다. 이 사용 사례에 대한 쉬운 해결책이있다 : 풋 &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 을 감쌈 컨테이너 요소에 &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 요소를. 요소 중 하나 또는 둘 다 &lt;a href=&quot;structural-directives#ngcontainer&quot;&gt; &lt;code&gt;ng-container&lt;/code&gt; &lt;/a&gt; 있으므로 추가 수준의 HTML을 도입 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="93b4d15b36f576847810650de967eae2da32c1f5" translate="yes" xml:space="preserve">
          <source>There are no parameters for this parent route so you're done with it.</source>
          <target state="translated">이 상위 경로에 대한 매개 변수가 없으므로 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="08a0080e437b247c15d7d516f9eb6d35b78c311f" translate="yes" xml:space="preserve">
          <source>There are no parameters for this parent route.</source>
          <target state="translated">이 상위 경로에 대한 매개 변수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fcf8d135851b80ffbe87dcd35d86d4ad22ed02e6" translate="yes" xml:space="preserve">
          <source>There are no parameters.</source>
          <target state="translated">매개 변수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="347acdbd61105fadd07872f8156b46696cb3b692" translate="yes" xml:space="preserve">
          <source>There are only two changes. The &lt;code&gt;template&lt;/code&gt; is simply the new element tag identified by the component's &lt;code&gt;selector&lt;/code&gt; property. This displays the hero form when the application component is loaded. Don't forget to remove the &lt;code&gt;name&lt;/code&gt; field from the class body as well.</source>
          <target state="translated">두 가지 변경 사항 만 있습니다. &lt;code&gt;template&lt;/code&gt; 단순히 구성 요소의 식별 새로운 요소 태그입니다 &lt;code&gt;selector&lt;/code&gt; 속성입니다. 애플리케이션 컴포넌트가로드 될 때 영웅 양식이 표시됩니다. 클래스 본문에서 &lt;code&gt;name&lt;/code&gt; 필드 를 제거하는 것을 잊지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="159f34be61579ceb6ae8d16ef7ee7eeb786eef01" translate="yes" xml:space="preserve">
          <source>There are paid CI services like Circle CI and Travis CI, and you can also host your own for free using Jenkins and others. Although Circle CI and Travis CI are paid services, they are provided free for open source projects. You can create a public project on GitHub and add these services without paying. Contributions to the Angular repo are automatically run through a whole suite of Circle CI tests.</source>
          <target state="translated">Circle CI 및 Travis CI와 같은 유료 CI 서비스가 있으며 Jenkins 및 기타를 사용하여 무료로 호스트 할 수도 있습니다. Circle CI 및 Travis CI는 유료 서비스이지만 오픈 소스 프로젝트를 위해 무료로 제공됩니다. GitHub에서 공개 프로젝트를 생성하고 비용을 지불하지 않고 이러한 서비스를 추가 할 수 있습니다. Angular 리포지토리에 대한 기여는 전체 Circle CI 테스트 스위트를 통해 자동으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="879cd324a70c4c96acf893c99d3b9dc84ee024ff" translate="yes" xml:space="preserve">
          <source>There are several examples over the next few sections.</source>
          <target state="translated">다음 몇 섹션에 몇 가지 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cf39c6658c13b371aa454d5575113ab2b716d55" translate="yes" xml:space="preserve">
          <source>There are several notable changes here:</source>
          <target state="translated">여기에 몇 가지 주목할만한 변경 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3ecb535a2ce87ce6aa9dd8adc9feb06a8b4ddfd" translate="yes" xml:space="preserve">
          <source>There are several ways to add styles to a component:</source>
          <target state="translated">컴포넌트에 스타일을 추가하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b266b00929430b0621b4b49767764faeeeeab85" translate="yes" xml:space="preserve">
          <source>There are three categories of directive:</source>
          <target state="translated">지시문에는 세 가지 범주가 있습니다.</target>
        </trans-unit>
        <trans-unit id="38597e951fad51067690768d9f762544a13ddd71" translate="yes" xml:space="preserve">
          <source>There are three different &lt;em&gt;urgency levels&lt;/em&gt; used to style the alerts based on the severity or importance of the content.</source>
          <target state="translated">콘텐츠의 심각도 또는 중요도에 따라 경고의 스타일을 지정하는 데 사용되는 세 가지 &lt;em&gt;긴급 수준&lt;/em&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="24e9e91fde41867db08419b1f04c4cbe517ddcb5" translate="yes" xml:space="preserve">
          <source>There are three fundamental building blocks to creating a route.</source>
          <target state="translated">경로를 만드는 데는 세 가지 기본 구성 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e76077d148cfb3df1507661f67b5067f5ff2d5a6" translate="yes" xml:space="preserve">
          <source>There are three kinds of directives in Angular:</source>
          <target state="translated">Angular에는 세 가지 종류의 지시문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="25e737b2092b55d9eb5f239e56b9516518d5f446" translate="yes" xml:space="preserve">
          <source>There are three main reasons to create a Universal version of your app.</source>
          <target state="translated">유니버설 버전의 앱을 만들어야하는 세 가지 주요 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4f700c6eaa2262317c0d957e29675f3621c94d0" translate="yes" xml:space="preserve">
          <source>There are three main steps to setting up a lazy-loaded feature module:</source>
          <target state="translated">지연로드 기능 모듈을 설정하는 주요 단계는 세 가지입니다.</target>
        </trans-unit>
        <trans-unit id="165573f1548a8f99cacaaa3440578c4519f99108" translate="yes" xml:space="preserve">
          <source>There are three phases of AOT compilation.</source>
          <target state="translated">AOT 컴파일에는 세 단계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab9b96e090b917419a7b4b07d60725578c370783" translate="yes" xml:space="preserve">
          <source>There are three significant differences from &lt;code&gt;getHeroes()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;getHeroes()&lt;/code&gt; 와는 세 가지 중요한 차이점이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6700c051353ace657c742055b93c035122544edb" translate="yes" xml:space="preserve">
          <source>There are three steps to using form controls.</source>
          <target state="translated">양식 컨트롤을 사용하는 세 단계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dd01b7be4e57b57b1627f79224ce07af7d2d99e" translate="yes" xml:space="preserve">
          <source>There are three supported input types.</source>
          <target state="translated">지원되는 입력 유형은 세 가지입니다.</target>
        </trans-unit>
        <trans-unit id="f5034306f8346e549a24ab826839194a108f3818" translate="yes" xml:space="preserve">
          <source>There are two categories of pipes: &lt;em&gt;pure&lt;/em&gt; and &lt;em&gt;impure&lt;/em&gt;. Pipes are pure by default. Every pipe you've seen so far has been pure. You make a pipe impure by setting its pure flag to false. You could make the &lt;code&gt;FlyingHeroesPipe&lt;/code&gt; impure like this:</source>
          <target state="translated">파이프에는 &lt;em&gt;순수&lt;/em&gt; 와 &lt;em&gt;불순&lt;/em&gt; 의 두 가지 범주가 있습니다 . 파이프는 기본적으로 순수합니다. 지금까지 본 모든 파이프는 순수했습니다. 순수한 플래그를 false로 설정하여 파이프를 불순하게 만듭니다. &lt;code&gt;FlyingHeroesPipe&lt;/code&gt; 를 다음 과 같이 불순 하게 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0d0261683ac70f77d2cb64caaaa6be2e633442f" translate="yes" xml:space="preserve">
          <source>There are two changes:</source>
          <target state="translated">두 가지 변경 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0757ae2710d35ffd65d63c8e4408b8f8b222e032" translate="yes" xml:space="preserve">
          <source>There are two important things to keep in mind when using Web Workers in Angular projects:</source>
          <target state="translated">Angular 프로젝트에서 웹 워커를 사용할 때 명심해야 할 두 가지 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed5307db9a7ed9a50bdf282cc464f6252ca2c8b1" translate="yes" xml:space="preserve">
          <source>There are two independent frameworks running in a single application, each framework treats the other as a black box.</source>
          <target state="translated">단일 애플리케이션에서 실행되는 두 개의 독립적 인 프레임 워크가 있으며 각 프레임 워크는 다른 프레임 워크를 블랙 박스로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="ad6b0f208e637f748bf275b29c341ba579e95709" translate="yes" xml:space="preserve">
          <source>There are two injector hierarchies in Angular:</source>
          <target state="translated">Angular에는 두 가지 인젝터 계층이 있습니다.</target>
        </trans-unit>
        <trans-unit id="43178632845a92d22afa35ca0676f6eb7a1f7062" translate="yes" xml:space="preserve">
          <source>There are two kinds of generated attributes:</source>
          <target state="translated">생성 된 속성에는 두 가지 종류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae6efc4f0655823ca7f29eb7bf3eefe1625ce1e5" translate="yes" xml:space="preserve">
          <source>There are two main kinds of entry components:</source>
          <target state="translated">엔트리 구성 요소에는 두 가지 주요 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="36eef38b4cd7460eba454e934ddc760e1199d5bf" translate="yes" xml:space="preserve">
          <source>There are two main steps to setting up a lazy-loaded feature module:</source>
          <target state="translated">지연로드 기능 모듈을 설정하는 두 가지 주요 단계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="550828cc689d902dc2704d305cf15fafb615c2b6" translate="yes" xml:space="preserve">
          <source>There are two more injectors above &lt;code&gt;root&lt;/code&gt;, an additional &lt;code&gt;ModuleInjector&lt;/code&gt; and &lt;code&gt;NullInjector()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;root&lt;/code&gt; 위에 추가 &lt;code&gt;ModuleInjector&lt;/code&gt; 및 &lt;code&gt;NullInjector()&lt;/code&gt; 두 개의 인젝터가 더 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec82505f597f4541fee947d1b90b7670a8bfe1fc" translate="yes" xml:space="preserve">
          <source>There are two other kinds of Angular directives, described extensively elsewhere: (1) components and (2) attribute directives.</source>
          <target state="translated">(1) 구성 요소 및 (2) 속성 지시문 등 다른 곳에 광범위하게 설명 된 다른 종류의 Angular 지시문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eee5ab865a86fd0b73b19b491d8642111214cd0d" translate="yes" xml:space="preserve">
          <source>There are two possible degraded states:</source>
          <target state="translated">가능한 두 가지 저하 상태가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc52776a75e0fe43e572fa425a1db8d585ca5328" translate="yes" xml:space="preserve">
          <source>There are two potential workarounds to the above issues:</source>
          <target state="translated">위의 문제에 대한 두 가지 잠재적 인 해결 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="25650f34b85cc033bcf18133335c7c20ab26b348" translate="yes" xml:space="preserve">
          <source>There are two types of validator functions: sync validators and async validators.</source>
          <target state="translated">유효성 검사기 기능에는 동기화 유효성 검사기와 비동기 유효성 검사기의 두 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f8e7458d2bd37a51a02a94b62cdecdc59f8af4c" translate="yes" xml:space="preserve">
          <source>There are two ways to make a service a singleton in Angular:</source>
          <target state="translated">Angular에서 서비스를 싱글 톤으로 만드는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="faa6ad5446f7861f6ecf46da71ea515c5fb5f071" translate="yes" xml:space="preserve">
          <source>There are two ways to update the model value:</source>
          <target state="translated">모델 값을 업데이트하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f26b5471a1dd6edb128afdf26847e8bb73608215" translate="yes" xml:space="preserve">
          <source>There are usually one or more main sections that may be further divided into secondary sections.</source>
          <target state="translated">보조 섹션으로 더 나눌 수있는 하나 이상의 기본 섹션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d5c6b97ecc7419e7dd8afaaeb5bfae0e26e836c" translate="yes" xml:space="preserve">
          <source>There can also be false positives when the typings of an Angular library are either incomplete or incorrect, or when the typings don't quite line up with expectations as in the following cases.</source>
          <target state="translated">Angular 라이브러리의 타이핑이 불완전하거나 부정확하거나 타이핑이 다음과 같은 기대치와 일치하지 않는 경우에도 오 탐지가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca00ae37aaf723dcf8b96d9e5fe70f20f93c9cc4" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;hierarchical-dependency-injection&quot;&gt;tree hierarchy of injectors&lt;/a&gt;, with a root injector and an additional injector for each component.</source>
          <target state="translated">가 &lt;a href=&quot;hierarchical-dependency-injection&quot;&gt;인젝터의 트리 계층&lt;/a&gt; 루트 인젝터 및 각 구성 요소에 대한 추가 인젝터와 함께.</target>
        </trans-unit>
        <trans-unit id="027fb989b8678c3235e885de0c12df209840f1d8" translate="yes" xml:space="preserve">
          <source>There is a rule for each defined day period. The first rule is applied to the first day period and so on. Fall back to AM/PM when no rules are available.</source>
          <target state="translated">정의 된 각 기간에 대한 규칙이 있습니다. 첫 번째 규칙은 첫 번째 기간 등에 적용됩니다. 사용 가능한 규칙이 없으면 AM / PM으로 폴백합니다.</target>
        </trans-unit>
        <trans-unit id="7654c24d9c7b87cc2fb7d574ad4e33ff2eb6cd63" translate="yes" xml:space="preserve">
          <source>There is a small but critical difference. In the &lt;code&gt;AppRoutingModule&lt;/code&gt;, you used the static &lt;strong&gt;&lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt;&lt;/strong&gt; method to register the routes and application level service providers. In a feature module you use the static &lt;strong&gt;&lt;code&gt;forChild&lt;/code&gt;&lt;/strong&gt; method.</source>
          <target state="translated">작지만 중요한 차이점이 있습니다. 에서 &lt;code&gt;AppRoutingModule&lt;/code&gt; , 당신은 정적 사용 &lt;strong&gt; &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; &lt;/strong&gt; 경로 및 응용 프로그램 수준의 서비스 제공을 등록하는 방법. 기능 모듈에서는 정적 &lt;strong&gt; &lt;code&gt;forChild&lt;/code&gt; &lt;/strong&gt; 메소드 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="1089bb549e548f1eece3447abc86312a541125a5" translate="yes" xml:space="preserve">
          <source>There is an API for navigating &lt;em&gt;down&lt;/em&gt; the view hierarchy. Check out &lt;code&gt;&lt;a href=&quot;../api/core/query&quot;&gt;Query&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/core/querylist&quot;&gt;QueryList&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/core/viewchildren&quot;&gt;ViewChildren&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../api/core/contentchildren&quot;&gt;ContentChildren&lt;/a&gt;&lt;/code&gt; in the &lt;a href=&quot;../api/index&quot;&gt;API Reference&lt;/a&gt;.</source>
          <target state="translated">탐색을위한 API가 &lt;em&gt;아래로&lt;/em&gt; 보기 계층 구조. 확인 &lt;code&gt;&lt;a href=&quot;../api/core/query&quot;&gt;Query&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/core/querylist&quot;&gt;QueryList&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/core/viewchildren&quot;&gt;ViewChildren&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/core/contentchildren&quot;&gt;ContentChildren&lt;/a&gt;&lt;/code&gt; 을 에 &lt;a href=&quot;../api/index&quot;&gt;API 참조&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf10db6389feae71b1aa42ec8c45a030a861e2e0" translate="yes" xml:space="preserve">
          <source>There is an important distinction between using another module's component and using a service from another module. Import modules when you want to use directives, pipes, and components. Importing a module with services means that you will have a new instance of that service, which typically is not what you need (typically one wants to reuse an existing service). Use module imports to control service instantiation.</source>
          <target state="translated">다른 모듈의 구성 요소를 사용하는 것과 다른 모듈의 서비스를 사용하는 것에는 중요한 차이점이 있습니다. 지시문, 파이프 및 구성 요소를 사용하려는 경우 모듈을 가져옵니다. 서비스가 포함 된 모듈을 가져 오면 해당 서비스의 새 인스턴스가 생길 것입니다. 이는 일반적으로 필요하지 않습니다 (일반적으로 기존 서비스를 재사용하려고 함). 서비스 가져 오기를 제어하려면 모듈 가져 오기를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cceabdb690dfa8a94f69d03b06952860cf555cc4" translate="yes" xml:space="preserve">
          <source>There is exactly one injector. Even in multi-module applications, everything is poured into one big namespace.</source>
          <target state="translated">정확히 하나의 인젝터가 있습니다. 다중 모듈 응용 프로그램에서도 모든 것이 하나의 큰 네임 스페이스에 부어집니다.</target>
        </trans-unit>
        <trans-unit id="8b6ca3d80875d293406dd0f142004f9fede44d55" translate="yes" xml:space="preserve">
          <source>There is no &lt;em&gt;live example&lt;/em&gt; for this cookbook because it describes Visual Studio, not the Angular application itself. It uses the starter Angular application created by the CLI command &lt;a href=&quot;cli/new&quot;&gt;&lt;code&gt;ng new&lt;/code&gt;&lt;/a&gt; as an example.</source>
          <target state="translated">이 요리 책에는 Angular 응용 프로그램 자체가 아닌 Visual Studio를 설명하기 때문에 &lt;em&gt;실제 예제&lt;/em&gt; 가 없습니다 . CLI 명령 &lt;a href=&quot;cli/new&quot;&gt; &lt;code&gt;ng new&lt;/code&gt; &lt;/a&gt; 로 작성된 starter Angular 응용 프로그램을 예로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="133a9567390a248ff96c3ddfeb770bd616eadd71" translate="yes" xml:space="preserve">
          <source>There is no default for the child route so you need to pick one.</source>
          <target state="translated">하위 경로에는 기본값이 없으므로 하나를 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="c9bb67cef244a52a5902839951c12ad9006e5375" translate="yes" xml:space="preserve">
          <source>There is no issue when the user navigates to that URL from within a running client. The Angular router interprets the URL and routes to that page and hero.</source>
          <target state="translated">사용자가 실행중인 클라이언트 내에서 해당 URL로 이동할 때 문제가 없습니다. Angular 라우터는 URL을 해석하고 해당 페이지와 히어로로 라우트합니다.</target>
        </trans-unit>
        <trans-unit id="565fc140f826820d99228d067e03328fac73f380" translate="yes" xml:space="preserve">
          <source>There is no longer a reference to &lt;code&gt;template&lt;/code&gt; and, therefore, nothing to trouble the compiler when it later interprets the &lt;em&gt;collector's&lt;/em&gt; output in &lt;code&gt;.metadata.json&lt;/code&gt;.</source>
          <target state="translated">더 이상 &lt;code&gt;template&lt;/code&gt; 대한 참조가 없으므로 나중에 &lt;code&gt;.metadata.json&lt;/code&gt; 의 &lt;em&gt;콜렉터&lt;/em&gt; 출력을 해석 할 때 컴파일러에 문제 가되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4e748fc4f70bcf252a46a3d8e24d8e97b2bd9b8c" translate="yes" xml:space="preserve">
          <source>There is no public API for acquiring a parent reference. However, because every component instance is added to an injector's container, you can use Angular dependency injection to reach a parent component.</source>
          <target state="translated">부모 참조를 얻기위한 공개 API는 없습니다. 그러나 모든 구성 요소 인스턴스가 인젝터 컨테이너에 추가되므로 각도 의존성 주입을 사용하여 상위 구성 요소에 도달 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e1f226d0769c2006bed4876b7fe7a774057642d" translate="yes" xml:space="preserve">
          <source>There is no single configuration that works for every server. The following sections describe configurations for some of the most popular servers. The list is by no means exhaustive, but should provide you with a good starting point.</source>
          <target state="translated">모든 서버에서 작동하는 단일 구성은 없습니다. 다음 섹션에서는 가장 많이 사용되는 일부 서버의 구성에 대해 설명합니다. 이 목록이 완전한 것은 아니지만 좋은 출발점을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="259bb0afbd8fefe05bdc556bd5eef64a565fd518" translate="yes" xml:space="preserve">
          <source>There is no specific API for upgrading an AngularJS service. Instead you should just follow the following recipe:</source>
          <target state="translated">AngularJS 서비스를 업그레이드하기위한 특정 API는 없습니다. 대신 다음 레시피를 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="550621addec4fd2e0708772894f55350f2a0f79c" translate="yes" xml:space="preserve">
          <source>There is no upgrade method to convert filters into pipes. You won't miss it. It's easy to turn the filter function into an equivalent Pipe class. The implementation is the same as before, repackaged in the &lt;code&gt;transform&lt;/code&gt; method. Rename the file to &lt;code&gt;checkmark.pipe.ts&lt;/code&gt; to conform with Angular conventions:</source>
          <target state="translated">필터를 파이프로 변환하는 업그레이드 방법은 없습니다. 당신은 그것을 놓치지 않을 것입니다. 필터 기능을 동등한 Pipe 클래스로 쉽게 전환 할 수 있습니다. 구현은 이전과 동일하며 &lt;code&gt;transform&lt;/code&gt; 메소드 에서 다시 패키지됩니다 . 각도 규칙에 따라 파일 이름을 &lt;code&gt;checkmark.pipe.ts&lt;/code&gt; 로 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="781eeaf093073ff0f504a446a6e2751d0558d133" translate="yes" xml:space="preserve">
          <source>There is one exception to this behavior that applies to &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; has &lt;code&gt;trackBy&lt;/code&gt; functionality that can deal with referential inequality of objects when iterating over them. See &lt;a href=&quot;built-in-directives#ngfor-with-trackby&quot;&gt;*ngFor with &lt;code&gt;trackBy&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 에 적용되는이 동작에는 한 가지 예외가 있습니다 . &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 에는 객체를 반복 할 때 객체의 참조 부등식을 처리 할 수있는 &lt;code&gt;trackBy&lt;/code&gt; 기능이 있습니다. 자세한 내용은 &lt;a href=&quot;built-in-directives#ngfor-with-trackby&quot;&gt;* ngFor with &lt;code&gt;trackBy&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4367e8254fa20fae31dcd949ca18914ce55ee3c5" translate="yes" xml:space="preserve">
          <source>There is one exception to this behavior that applies to &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; has &lt;code&gt;trackBy&lt;/code&gt; functionality that can deal with referential inequality of objects when iterating over them. See &lt;a href=&quot;template-syntax#ngfor-with-trackby&quot;&gt;*ngFor with &lt;code&gt;trackBy&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">이 동작에는 &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 에 적용되는 예외가 있습니다 . &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 는 이 &lt;code&gt;trackBy&lt;/code&gt; 의 반복하는 그들에 객체 참조 불평등을 해결할 수있는 기능. 자세한 내용은 &lt;a href=&quot;template-syntax#ngfor-with-trackby&quot;&gt;* ngForFor &lt;code&gt;trackBy&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7dd62d5ae3789ef38b487eab0e8d1f7f87b82b99" translate="yes" xml:space="preserve">
          <source>There is one exception to this rule. Attributes can be changed by &lt;code&gt;&lt;a href=&quot;template-syntax&quot;&gt;setAttribute()&lt;/a&gt;&lt;/code&gt;, which re-initializes corresponding DOM properties.</source>
          <target state="translated">이 규칙에는 한 가지 예외가 있습니다. 속성은 해당 DOM 특성을 다시 초기화하는 &lt;code&gt;&lt;a href=&quot;template-syntax&quot;&gt;setAttribute()&lt;/a&gt;&lt;/code&gt; 로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11dbb8bce3c3271a707e1c42a72d9f859744e253" translate="yes" xml:space="preserve">
          <source>There is one exception to this rule. Attributes can be changed by &lt;code&gt;setAttribute()&lt;/code&gt;, which re-initializes corresponding DOM properties.</source>
          <target state="translated">이 규칙에는 한 가지 예외가 있습니다. 속성은 해당 DOM 속성을 다시 초기화하는 &lt;code&gt;setAttribute()&lt;/code&gt; 로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d33886b39df983b142ac0e4c678d0df8e24d2439" translate="yes" xml:space="preserve">
          <source>There is one exception to this rule: to make local development easier, browsers do &lt;em&gt;not&lt;/em&gt; require a secure connection when accessing an app on &lt;code&gt;localhost&lt;/code&gt;.</source>
          <target state="translated">이 규칙에는 한 가지 예외가 있습니다. 로컬 개발을 쉽게하기 위해 &lt;code&gt;localhost&lt;/code&gt; 의 앱에 액세스 할 때 브라우저는 보안 연결이 필요 하지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="56ed5ae7d3569c2686c1ede9ce1a1546720090e8" translate="yes" xml:space="preserve">
          <source>There is only one root injector for an app. Providing &lt;code&gt;UserService&lt;/code&gt; at the &lt;code&gt;root&lt;/code&gt; or &lt;code&gt;AppModule&lt;/code&gt; level means it is registered with the root injector. There is just one &lt;code&gt;UserService&lt;/code&gt; instance in the entire app and every class that injects &lt;code&gt;UserService&lt;/code&gt; gets this service instance &lt;em&gt;unless&lt;/em&gt; you configure another provider with a &lt;em&gt;child injector&lt;/em&gt;.</source>
          <target state="translated">앱에는 하나의 루트 인젝터 만 있습니다. &lt;code&gt;root&lt;/code&gt; 또는 &lt;code&gt;AppModule&lt;/code&gt; 수준 에서 &lt;code&gt;UserService&lt;/code&gt; 를 제공 한다는 것은 루트 인젝터에 등록 된 것을 의미합니다. 전체 앱에는 &lt;code&gt;UserService&lt;/code&gt; 인스턴스가 하나만 있으며 &lt;em&gt;하위 인젝터로&lt;/em&gt; 다른 공급자를 구성 &lt;em&gt;하지 않으면 &lt;/em&gt; &lt;code&gt;UserService&lt;/code&gt; 를 주입하는 모든 클래스 가이 서비스 인스턴스를 가져 옵니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aa0f46f07be6d7bd145a95e639f76d57f093602d" translate="yes" xml:space="preserve">
          <source>There isn't anything the client application can do about these errors. The server must be configured to accept the application's requests. Read about how to enable CORS for specific servers at &lt;a href=&quot;http://enable-cors.org/server.html&quot;&gt;enable-cors.org&lt;/a&gt;.</source>
          <target state="translated">클라이언트 응용 프로그램이 이러한 오류에 대해 수행 할 수있는 작업이 없습니다. 서버는 응용 프로그램의 요청을 승인하도록 구성되어야합니다. &lt;a href=&quot;http://enable-cors.org/server.html&quot;&gt;enable-cors.org&lt;/a&gt; 에서 특정 서버에 CORS를 사용하는 방법에 대해 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="bd29a80577a16149f809aa709e10802120f26a64" translate="yes" xml:space="preserve">
          <source>There will be one additional argument to the &lt;code&gt;transform&lt;/code&gt; method for each parameter passed to the pipe. Your pipe has one such parameter: the &lt;code&gt;exponent&lt;/code&gt;.</source>
          <target state="translated">파이프에 전달 된 각 매개 변수에 대해 &lt;code&gt;transform&lt;/code&gt; 메소드에 대한 추가 인수가 있습니다 . 파이프에는 &lt;code&gt;exponent&lt;/code&gt; 라는 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cc5eb405460e77c124b415c5ccacffdb138ea7a" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s nothing special about this component, nothing form-specific, nothing to distinguish it from any component you've written before.</source>
          <target state="translated">이 구성 요소에는 특별한 것이 없으며 양식별로 다르며 이전에 작성한 구성 요소와 구별 할 것도 없습니다.</target>
        </trans-unit>
        <trans-unit id="542467bb8ed2c1b3891b718134b4968a6fc9a566" translate="yes" xml:space="preserve">
          <source>There's a good reason for this circuitous path to the element.</source>
          <target state="translated">요소에 대한 이러한 회로적인 경로에는 충분한 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="508e59adf4df546f2bbce6e533bf9e238970539b" translate="yes" xml:space="preserve">
          <source>There's a similar helper for producing an async error.</source>
          <target state="translated">비동기 오류를 생성하는 비슷한 도우미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="84cc470613727d84aabbfa2c1862c5ad36fcaf45" translate="yes" xml:space="preserve">
          <source>There's also the &lt;code&gt;bind-&lt;/code&gt; prefix alternative:</source>
          <target state="translated">도있다 &lt;code&gt;bind-&lt;/code&gt; 접두사 대안 :</target>
        </trans-unit>
        <trans-unit id="0909bf3d1ff44badd0511d8a77fa43424485ad25" translate="yes" xml:space="preserve">
          <source>There's an easier way: bind to Angular's &lt;code&gt;keyup.enter&lt;/code&gt; pseudo-event. Then Angular calls the event handler only when the user presses &lt;em&gt;Enter&lt;/em&gt;.</source>
          <target state="translated">더 쉬운 방법이 있습니다 : Angular의 &lt;code&gt;keyup.enter&lt;/code&gt; pseudo-event에 바인딩하십시오 . 그런 다음 Angular는 사용자가 &lt;em&gt;Enter 키를&lt;/em&gt; 누를 때만 이벤트 핸들러를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="ab30027be9f11ddbb2b70f4586d177e63c2b9249" translate="yes" xml:space="preserve">
          <source>There's another school of testing that never calls &lt;code&gt;beforeEach()&lt;/code&gt; and prefers to create classes explicitly rather than use the &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;beforeEach()&lt;/code&gt; 호출하지 않고 &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; 를 사용하는 대신 명시 적으로 클래스를 작성하는 것을 선호하는 또 다른 테스트 학교 가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea61c19309ff72246ea3a2984fbfffe7d47f7033" translate="yes" xml:space="preserve">
          <source>There's another way to get the user data: use Angular &lt;a href=&quot;template-syntax#ref-vars&quot;&gt;&lt;strong&gt;template reference variables&lt;/strong&gt;&lt;/a&gt;. These variables provide direct access to an element from within the template. To declare a template reference variable, precede an identifier with a hash (or pound) character (#).</source>
          <target state="translated">사용자 데이터를 얻는 또 다른 방법이 있습니다 : Angular &lt;a href=&quot;template-syntax#ref-vars&quot;&gt;&lt;strong&gt;template reference variables를&lt;/strong&gt;&lt;/a&gt; 사용 &lt;strong&gt;하십시오&lt;/strong&gt; . 이러한 변수는 템플릿 내에서 요소에 직접 액세스 할 수 있도록합니다. 템플릿 참조 변수를 선언하려면 식별자 앞에 해시 (또는 파운드) 문자 (#)를 붙입니다.</target>
        </trans-unit>
        <trans-unit id="649efc388a11470109bc9e7158e40958a6267aea" translate="yes" xml:space="preserve">
          <source>There's no harm in calling &lt;code&gt;compileComponents()&lt;/code&gt; when it's not required.</source>
          <target state="translated">필요하지 않은 &lt;code&gt;compileComponents()&lt;/code&gt; 를 호출해도 아무런 해 가 없습니다.</target>
        </trans-unit>
        <trans-unit id="37d89c9051846e27681d13e418f11f2bb4feecdd" translate="yes" xml:space="preserve">
          <source>There's no link to the new shipping component yet, but you can see its template in the preview pane by entering the URL its route specifies. The URL has the pattern: &lt;code&gt;https://getting-started.stackblitz.io/shipping&lt;/code&gt; where the &lt;code&gt;getting-started.stackblitz.io&lt;/code&gt; part may be different for your StackBlitz project.</source>
          <target state="translated">아직 새 배송 구성 요소에 대한 링크가 없지만 경로가 지정하는 URL을 입력하면 미리보기 창에서 해당 템플릿을 볼 수 있습니다. URL에는 &lt;code&gt;https://getting-started.stackblitz.io/shipping&lt;/code&gt; 패턴이 있습니다. 여기서 &lt;code&gt;getting-started.stackblitz.io&lt;/code&gt; 부분은 StackBlitz 프로젝트에 따라 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d18f6add8e2e8495aacfbde5fe0813a6561d85a2" translate="yes" xml:space="preserve">
          <source>There's no need to declare or import anything else. The default test module is pre-configured with something like the &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;@angular/platform-browser&lt;/code&gt;.</source>
          <target state="translated">다른 것을 선언하거나 가져올 필요가 없습니다. 기본 테스트 모듈은 같은 사전 구성되어 &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;@angular/platform-browser&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9485387892c4a4b5f9d2bd3163e6e9e7f2a2b699" translate="yes" xml:space="preserve">
          <source>There's no need to list a component in both the &lt;code&gt;bootstrap&lt;/code&gt; and &lt;code&gt;entryComponents&lt;/code&gt; lists, although doing so is harmless.</source>
          <target state="translated">&lt;code&gt;bootstrap&lt;/code&gt; 과 &lt;code&gt;entryComponents&lt;/code&gt; 목록 모두에 구성 요소를 나열 할 필요 는 없지만 해롭지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="c90aada73387116e19e933942a34d908ca737c3b" translate="yes" xml:space="preserve">
          <source>There's often a &lt;em&gt;root&lt;/em&gt; element that can and should host the structural directive. The list element (&lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;) is a typical host element of an &lt;code&gt;NgFor&lt;/code&gt; repeater.</source>
          <target state="translated">구조적 지시어를 호스팅 할 수 있고 호스팅해야하는 &lt;em&gt;루트&lt;/em&gt; 요소가 종종 있습니다. list 요소 ( &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; )는 &lt;code&gt;NgFor&lt;/code&gt; repeater 의 일반적인 호스트 요소입니다 .</target>
        </trans-unit>
        <trans-unit id="ca6a4c5f2988457896869f467e895a0eeb19531f" translate="yes" xml:space="preserve">
          <source>There's one notable exception to the rule of using Angular attribute syntax for downgraded components. It has to do with input or output names that consist of multiple words. In Angular, you would bind these attributes using camelCase:</source>
          <target state="translated">다운 그레이드 된 구성 요소에 각도 속성 구문을 사용하는 규칙에는 주목할만한 예외가 있습니다. 여러 단어로 구성된 입력 또는 출력 이름과 관련이 있습니다. Angular에서는 camelCase를 사용하여 이러한 속성을 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="6cf332e6a1ddffd2a30959312ecbc288187e50d8" translate="yes" xml:space="preserve">
          <source>There's really nothing for the component to do with the &lt;code&gt;Observable&lt;/code&gt; returned by &lt;code&gt;heroService.delete()&lt;/code&gt;&lt;strong&gt;but it must subscribe anyway&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;heroService.delete()&lt;/code&gt; 의해 리턴 된 &lt;code&gt;Observable&lt;/code&gt; 과 컴포넌트는 아무런 관련이 &lt;strong&gt;없지만 어쨌든 구독해야합니다&lt;/strong&gt; .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2e367708179b8c6b769aeb5784a73ff30d8bb02d" translate="yes" xml:space="preserve">
          <source>There's the hero again, displayed read-only with interpolation bindings. This &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; appears only while the component is in the submitted state.</source>
          <target state="translated">보간 바인딩과 함께 읽기 전용으로 표시되는 영웅이 다시 있습니다. 이 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 는 구성 요소가 제출 된 상태 인 동안에 만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="6dd1142b94c5ac636081fac9b5a1e93324c5c2d5" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;import&lt;/code&gt; statements add several important elements that your component needs. To learn more about each, see the following API pages:</source>
          <target state="translated">이러한 &lt;code&gt;import&lt;/code&gt; 문 은 구성 요소에 필요한 몇 가지 중요한 요소를 추가합니다. 각각에 대해 자세히 알아 보려면 다음 API 페이지를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="83d7c16de255fb2bdba11db803994a1ace7987c7" translate="yes" xml:space="preserve">
          <source>These Angular docs help you learn and use the Angular framework and development platform, from your first application to optimizing complex single-page apps for enterprises. Tutorials and guides include downloadable examples to accelerate your projects.</source>
          <target state="translated">이러한 Angular 문서는 첫 번째 애플리케이션에서 기업용 복잡한 단일 페이지 앱 최적화에 이르기까지 Angular 프레임 워크 및 개발 플랫폼을 배우고 사용하는 데 도움이됩니다. 튜토리얼 및 가이드에는 프로젝트 가속화를위한 다운로드 가능한 예제가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7f47f5fef07e1400c8770e346e27dd983d3210c" translate="yes" xml:space="preserve">
          <source>These Angular docs help you learn and use the Angular platform and framework, from your first app to optimizing complex enterprise apps. Tutorials and guides include downloadable example to accelerate your projects.</source>
          <target state="translated">이 Angular 문서는 첫 번째 앱에서 복잡한 엔터프라이즈 앱 최적화에 이르기까지 Angular 플랫폼 및 프레임 워크를 배우고 사용하는 데 도움이됩니다. 학습서 및 안내서에는 프로젝트 가속화를위한 다운로드 가능한 예제가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c8f4170de94e38e103661daa9cd09d22d382f76" translate="yes" xml:space="preserve">
          <source>These are all features you'll want to test.</source>
          <target state="translated">이것들은 모두 테스트하고 싶은 기능입니다.</target>
        </trans-unit>
        <trans-unit id="19fa4dd3c3af8618e37296f1894ca8c3663deadc" translate="yes" xml:space="preserve">
          <source>These are short, simple functions that you can write yourself. Unfortunately, they're too simple for many common scenarios. An observable often emits multiple times, perhaps after a significant delay. A component may coordinate multiple observables with overlapping sequences of values and errors.</source>
          <target state="translated">이것들은 스스로 쓸 수있는 짧고 간단한 기능입니다. 불행히도 많은 일반적인 시나리오에서는 너무 간단합니다. 관찰 가능 항목은 종종 상당한 지연 후에 여러 번 방출됩니다. 구성 요소는 중복되는 값과 오류 시퀀스로 여러 관측 값을 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15a8bdbc2d27676173c0870bb9d476a44f9c0ec8" translate="yes" xml:space="preserve">
          <source>These are techniques for &lt;em&gt;Shallow Component Testing&lt;/em&gt; , so-named because they reduce the visual surface of the component to just those elements in the component's template that matter for tests.</source>
          <target state="translated">&lt;em&gt;Shallow Component Testing&lt;/em&gt; 기술은 &lt;em&gt;구성 요소&lt;/em&gt; 의 시각적 표면을 구성 요소 템플릿에서 테스트에 중요한 요소로 축소하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="874d82075cf5a1fb8e894c6a1831e2a99c4f9cf5" translate="yes" xml:space="preserve">
          <source>These are tests of the pipe &lt;em&gt;in isolation&lt;/em&gt;. They can't tell if the &lt;code&gt;&lt;a href=&quot;../api/common/titlecasepipe&quot;&gt;TitleCasePipe&lt;/a&gt;&lt;/code&gt; is working properly as applied in the application components.</source>
          <target state="translated">이것은 파이프 &lt;em&gt;의 절연&lt;/em&gt; 테스트입니다 . &lt;code&gt;&lt;a href=&quot;../api/common/titlecasepipe&quot;&gt;TitleCasePipe&lt;/a&gt;&lt;/code&gt; 가 응용 프로그램 구성 요소에 적용된대로 제대로 작동하는지 알 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7aa6e184a2127bbab023de5210efd3d94de5eaf2" translate="yes" xml:space="preserve">
          <source>These are the polyfills required to run an Angular application on each supported browser:</source>
          <target state="translated">다음은 지원되는 각 브라우저에서 Angular 응용 프로그램을 실행하는 데 필요한 폴리 필입니다.</target>
        </trans-unit>
        <trans-unit id="d6422d60e6eed75caf6b039379d70a9d2b91599f" translate="yes" xml:space="preserve">
          <source>These buttons work, because the CLI automatically added the routes to the feature modules to the &lt;code&gt;routes&lt;/code&gt; array in &lt;code&gt;app.module.ts&lt;/code&gt;.</source>
          <target state="translated">CLI 는 &lt;code&gt;app.module.ts&lt;/code&gt; 의 &lt;code&gt;routes&lt;/code&gt; 배열에 기능 모듈의 경로를 자동으로 추가했기 때문에 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="4fadb046a4f69a8a29a6dfda895733f7808fc510" translate="yes" xml:space="preserve">
          <source>These complications argue for &lt;em&gt;avoiding component inheritance&lt;/em&gt;.</source>
          <target state="translated">이러한 합병증은 &lt;em&gt;구성 요소 상속&lt;/em&gt; 을 &lt;em&gt;피&lt;/em&gt; 한다고 주장합니다 .</target>
        </trans-unit>
        <trans-unit id="3cd97d4aaaa391802aacd2112d378fb5a981f75d" translate="yes" xml:space="preserve">
          <source>These declared classes are visible within the module but invisible to components in a different module unless they are exported from this module and the other module imports this one.</source>
          <target state="translated">이 선언 된 클래스는 모듈 내에서 볼 수 있지만이 모듈에서 내보내고 다른 모듈에서이 클래스를 가져 오지 않는 한 다른 모듈의 구성 요소에는 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e0813bed7ed16b4e0b736f3f56fccf8998f10650" translate="yes" xml:space="preserve">
          <source>These decorators can be used individually or together, as shown in the example. This &lt;code&gt;HeroBiosAndContactsComponent&lt;/code&gt; is a revision of &lt;code&gt;HeroBiosComponent&lt;/code&gt; which you looked at &lt;a href=&quot;dependency-injection-in-action#hero-bios-component&quot;&gt;above&lt;/a&gt;.</source>
          <target state="translated">이 데코레이터는 예제와 같이 개별적으로 또는 함께 사용할 수 있습니다. 이 &lt;code&gt;HeroBiosAndContactsComponent&lt;/code&gt; 은 개정이다 &lt;code&gt;HeroBiosComponent&lt;/code&gt; 당신이 바라 보았다 &lt;a href=&quot;dependency-injection-in-action#hero-bios-component&quot;&gt;위&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e87f8d2277a30ddb602eb3ef7903e879dae9750f" translate="yes" xml:space="preserve">
          <source>These differences argue for a re-usable stub class.</source>
          <target state="translated">이러한 차이는 재사용 가능한 스터브 클래스를 주장합니다.</target>
        </trans-unit>
        <trans-unit id="5d480207010587b40e48ea63c6eb80e8e93917ee" translate="yes" xml:space="preserve">
          <source>These docs assume that you are already familiar with &lt;a href=&quot;https://developer.mozilla.org/docs/Learn/HTML/Introduction_to_HTML&quot;&gt;HTML&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/docs/Learn/CSS/First_steps&quot;&gt;CSS&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript&quot;&gt;JavaScript&lt;/a&gt;, and some of the tools from the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Language_Resources&quot;&gt;latest standards&lt;/a&gt;, such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt;classes&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;modules&lt;/a&gt;. The code samples are written using &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt;. Most Angular code can be written with just the latest JavaScript, using &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/classes.html&quot;&gt;types&lt;/a&gt; for dependency injection, and using &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/decorators.html&quot;&gt;decorators&lt;/a&gt; for metadata.</source>
          <target state="translated">이 문서는 사용자가 &lt;a href=&quot;https://developer.mozilla.org/docs/Learn/HTML/Introduction_to_HTML&quot;&gt;HTML&lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/docs/Learn/CSS/First_steps&quot;&gt;CSS&lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript&quot;&gt;JavaScript&lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Language_Resources&quot;&gt;최신 표준&lt;/a&gt; 의 일부 도구 ( 예 : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt;클래스&lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;모듈)에&lt;/a&gt; 이미 익숙하다고 가정 합니다 . 코드 샘플은 &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript를&lt;/a&gt; 사용하여 작성 되었습니다 . 대부분의 Angular 코드는 종속성 주입에 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/classes.html&quot;&gt;유형&lt;/a&gt; 을 사용 하고 메타 데이터에 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/decorators.html&quot;&gt;데코레이터&lt;/a&gt; 를 사용 하여 최신 JavaScript로만 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="332167a123f1d6b741515c29ca0f4c696c2a51c9" translate="yes" xml:space="preserve">
          <source>These docs assume that you are already familiar with HTML, CSS, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript&quot;&gt;JavaScript&lt;/a&gt;, and some of the tools from the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Language_Resources&quot;&gt;latest standards&lt;/a&gt;, such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt;classes&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;modules&lt;/a&gt;. The code samples are written using &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt;. Most Angular code can be written with just the latest JavaScript, using &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/classes.html&quot;&gt;types&lt;/a&gt; for dependency injection, and using &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/decorators.html&quot;&gt;decorators&lt;/a&gt; for metadata.</source>
          <target state="translated">이 문서에서는 HTML, CSS, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript&quot;&gt;JavaScript&lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt;클래스&lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;모듈&lt;/a&gt; 과 같은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Language_Resources&quot;&gt;최신 표준&lt;/a&gt; 의 일부 도구에 이미 익숙하다고 가정 합니다 . 코드 샘플은 &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript를&lt;/a&gt; 사용하여 작성됩니다 . 대부분의 Angular 코드는 의존성 주입 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/classes.html&quot;&gt;유형&lt;/a&gt; 과 메타 데이터에 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/decorators.html&quot;&gt;데코레이터&lt;/a&gt; 를 사용 하여 최신 JavaScript만으로 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0248cf761a672df747afacece78839e13096947" translate="yes" xml:space="preserve">
          <source>These events are logged to the console when the &lt;code&gt;&lt;a href=&quot;../api/router/extraoptions#enableTracing&quot;&gt;enableTracing&lt;/a&gt;&lt;/code&gt; option is enabled also. For an example of filtering router navigation events, visit the &lt;a href=&quot;observables-in-angular#router&quot;&gt;router section&lt;/a&gt; of the &lt;a href=&quot;observables-in-angular&quot;&gt;Observables in Angular&lt;/a&gt; guide.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/router/extraoptions#enableTracing&quot;&gt;enableTracing&lt;/a&gt;&lt;/code&gt; 옵션도 활성화 하면 이러한 이벤트가 콘솔에 기록됩니다 . 라우터 탐색 이벤트를 필터링하는 예 는 &lt;a href=&quot;observables-in-angular&quot;&gt;Observables in Angular&lt;/a&gt; 안내서 의 &lt;a href=&quot;observables-in-angular#router&quot;&gt;라우터 섹션&lt;/a&gt; 을 방문하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f157bfae90a971b921468f9fd643dfd20928fdb" translate="yes" xml:space="preserve">
          <source>These examples demonstrate features of Angular components.</source>
          <target state="translated">이 예제는 Angular 구성 요소의 기능을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="87d6961b56e31c059fead7fe33dd1106be84b901" translate="yes" xml:space="preserve">
          <source>These examples demonstrate features of Angular templates.</source>
          <target state="translated">이 예제는 Angular 템플릿의 기능을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="16439e0a64a943344cbb334dca94796483e78e42" translate="yes" xml:space="preserve">
          <source>These examples demonstrate minimal, fundamental concepts.</source>
          <target state="translated">이 예제는 최소한의 기본 개념을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2680c5c9b2a75fe66adbcbcf8321b6c19da88cdf" translate="yes" xml:space="preserve">
          <source>These examples transform a date into various formats, assuming that &lt;code&gt;dateObj&lt;/code&gt; is a JavaScript &lt;code&gt;Date&lt;/code&gt; object for year: 2015, month: 6, day: 15, hour: 21, minute: 43, second: 11, given in the local time for the &lt;code&gt;en-US&lt;/code&gt; locale.</source>
          <target state="translated">이러한 예는 가정, 다양한 형식으로 날짜를 변환 &lt;code&gt;dateObj&lt;/code&gt; 는 자바 스크립트입니다 &lt;code&gt;Date&lt;/code&gt; 2015 년 월 : 6 일 : 15시 : 21 분 : 43 초 : 11에 대한 현지 시간으로 특정 연도에 대한 객체 &lt;code&gt;en-US&lt;/code&gt; 로케일.</target>
        </trans-unit>
        <trans-unit id="2c3bf4e06192c72785cca976fd12148948a7cb90" translate="yes" xml:space="preserve">
          <source>These examples use a shorthand form of the prompt syntax, supplying only the text of the question. In most cases, this is all that is required. Notice however, that the two prompts expect different types of input. When using the shorthand form, the most appropriate type is automatically selected based on the property's schema. In the example, the &lt;code&gt;name&lt;/code&gt; prompt uses the &lt;code&gt;input&lt;/code&gt; type because it it is a string property. The &lt;code&gt;useColor&lt;/code&gt; prompt uses a &lt;code&gt;confirmation&lt;/code&gt; type because it is a Boolean property. In this case, &quot;yes&quot; corresponds to &lt;code&gt;true&lt;/code&gt; and &quot;no&quot; corresponds to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 예제는 간단한 형식의 프롬프트 구문을 사용하여 질문의 텍스트 만 제공합니다. 대부분의 경우 이것이 필요한 전부입니다. 그러나 두 프롬프트는 다른 유형의 입력을 예상합니다. 속기 양식을 사용하는 경우 특성의 스키마에 따라 가장 적합한 유형이 자동으로 선택됩니다. 이 예에서 &lt;code&gt;name&lt;/code&gt; 프롬프트는 &lt;code&gt;input&lt;/code&gt; 유형이 문자열 특성이므로 입력 유형을 사용합니다 . &lt;code&gt;useColor&lt;/code&gt; 는 프롬프트 사용하는 &lt;code&gt;confirmation&lt;/code&gt; 유형은 부울 특성이기 때문이다. 이 경우 &quot;yes&quot;는 &lt;code&gt;true&lt;/code&gt; 에 해당 하고 &quot;no&quot;는 &lt;code&gt;false&lt;/code&gt; 에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="d24eb680a33027e2617530dc12e6676b87a2c5ca" translate="yes" xml:space="preserve">
          <source>These files need to be copied together with the polyfills. The files the application needs at runtime, like the &lt;code&gt;.json&lt;/code&gt; phone lists and images, also need to be copied.</source>
          <target state="translated">이러한 파일은 폴리 필과 함께 복사해야합니다. &lt;code&gt;.json&lt;/code&gt; 전화 번호부 및 이미지와 같이 런타임에 응용 프로그램에 필요한 파일 도 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="02b3a7df8a6c77dd99266ab2b91a34b6a3d23a77" translate="yes" xml:space="preserve">
          <source>These four bindings demonstrate the difference between &lt;code&gt;providers&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt;. Since the 🐶 (puppy) is declared inside the &amp;lt;#VIEW&amp;gt;, it isn't visible to the projected content. Instead, the projected content sees the 🐳 (whale).</source>
          <target state="translated">이 네 가지 바인딩은 &lt;code&gt;providers&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt; 의 차이점을 보여줍니다 . 🐶 (강아지)는 &amp;lt;#VIEW&amp;gt; 내부에 선언되어 있기 때문에 투사 된 콘텐츠에는 보이지 않습니다. 대신, 투사 된 콘텐츠는 🐳 (고래)를 봅니다.</target>
        </trans-unit>
        <trans-unit id="b30edd37d2f476685d4ba739caa2c47f5b94f2fd" translate="yes" xml:space="preserve">
          <source>These four bindings demonstrate the difference between &lt;code&gt;providers&lt;/code&gt; and &lt;code&gt;viewProviders&lt;/code&gt;. Since the 🐶 (puppy) is declared inside the &amp;lt;#VIEW&amp;gt;, it isn't visible to the projected content. Instead, the projected content sees the 🐳 (whale).</source>
          <target state="translated">이 네 가지 바인딩은 &lt;code&gt;providers&lt;/code&gt; 와 &lt;code&gt;viewProviders&lt;/code&gt; 의 차이점을 보여줍니다 . 🐶 (강아지)는 &amp;lt;#VIEW&amp;gt; 내부에 선언되어 있으므로 투영 된 콘텐츠에 표시되지 않습니다. 대신 투영 된 콘텐츠는 🐳 (고래)를 봅니다.</target>
        </trans-unit>
        <trans-unit id="8eb673fe0a5db30500d447cd8ed9df2e9892d31d" translate="yes" xml:space="preserve">
          <source>These inputs and outputs can be supplied from the AngularJS template, and the &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgradecomponent&quot;&gt;downgradeComponent&lt;/a&gt;()&lt;/code&gt; method takes care of wiring them up:</source>
          <target state="translated">이러한 입력 및 출력은 AngularJS 템플릿에서 제공 할 수 있으며 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgradecomponent&quot;&gt;downgradeComponent&lt;/a&gt;()&lt;/code&gt; 메소드는이를 연결합니다.</target>
        </trans-unit>
        <trans-unit id="aca1e5487bdae512316a9552870710cde2c7edc4" translate="yes" xml:space="preserve">
          <source>These kinds of parameters don't fit easily in a URL &lt;em&gt;path&lt;/em&gt;. Even if you could define a suitable URL token scheme, doing so greatly complicates the pattern matching required to translate an incoming URL to a named route.</source>
          <target state="translated">이러한 종류의 매개 변수는 URL &lt;em&gt;경로&lt;/em&gt; 에 쉽게 맞지 않습니다 . 적절한 URL 토큰 체계를 정의 할 수 있더라도 들어오는 URL을 명명 된 경로로 변환하는 데 필요한 패턴 일치가 크게 복잡해집니다.</target>
        </trans-unit>
        <trans-unit id="29425b5274cb55ea0877f8425586bc76b4a9c960" translate="yes" xml:space="preserve">
          <source>These may not be troubling questions for the simple components illustrated above. But many components have complex interactions with the DOM elements described in their templates, causing HTML to appear and disappear as the component state changes.</source>
          <target state="translated">위에서 설명한 간단한 구성 요소에 대해서는 문제가되지 않을 수 있습니다. 그러나 많은 구성 요소는 템플릿에 설명 된 DOM 요소와 복잡한 상호 작용을하여 구성 요소 상태가 변경되면 HTML이 나타나거나 사라집니다.</target>
        </trans-unit>
        <trans-unit id="9280883bdf2743a9d36490d0dc135e8e9a512cc2" translate="yes" xml:space="preserve">
          <source>These methods access the injected timer component directly.</source>
          <target state="translated">이 메소드는 주입 된 타이머 구성 요소에 직접 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="c22429bdeba56aae46b0da88ebbd1eba5c9f7eb4" translate="yes" xml:space="preserve">
          <source>These microsyntax mechanisms are also available to you when you write your own structural directives. For example, microsyntax in Angular allows you to write &lt;code&gt;&amp;lt;div *&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;=&quot;let &lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt; of items&quot;&amp;gt;{{&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;}}&amp;lt;/div&amp;gt;&lt;/code&gt; instead of &lt;code&gt;&amp;lt;ng-template &lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt; [&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngForOf&lt;/a&gt;]=&quot;items&quot;&amp;gt;&amp;lt;div&amp;gt;{{&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;}}&amp;lt;/div&amp;gt;&amp;lt;/ng-template&amp;gt;&lt;/code&gt;. The following sections provide detailed information on constraints, grammar, and translation of microsyntax.</source>
          <target state="translated">이러한 마이크로 구문 메커니즘은 자체 구조적 지시문을 작성할 때도 사용할 수 있습니다. 예를 들어 Angular의 마이크로 구문을 사용하면 &lt;code&gt;&amp;lt;ng-template &lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt; [&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngForOf&lt;/a&gt;]=&quot;items&quot;&amp;gt;&amp;lt;div&amp;gt;{{&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;}}&amp;lt;/div&amp;gt;&amp;lt;/ng-template&amp;gt;&lt;/code&gt; &lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt; [ &lt;a href=&quot;../api/common/ngforof&quot;&gt;ngForOf&lt;/a&gt; ] = &quot;items&quot;&amp;gt; &amp;lt;div&amp;gt; { 대신 &lt;code&gt;&amp;lt;div *&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;=&quot;let &lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt; of items&quot;&amp;gt;{{&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;}}&amp;lt;/div&amp;gt;&lt;/code&gt; 을 쓸 수 있습니다 . { &lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt; }} &amp;lt;/ div&amp;gt; &amp;lt;/ ng-template&amp;gt; 입니다. 다음 섹션에서는 제약 조건, 문법 및 마이크로 구문 번역에 대한 자세한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a5772cf07dfef80156b6e9a71682c4a0275d4733" translate="yes" xml:space="preserve">
          <source>These microsyntax mechanisms are also available to you when you write your own structural directives. For example, microsyntax in Angular allows you to write &lt;code&gt;&amp;lt;div *&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;=&quot;let item of items&quot;&amp;gt;{{item}}&amp;lt;/div&amp;gt;&lt;/code&gt; instead of &lt;code&gt;&amp;lt;ng-template &lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt; let-item [&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngForOf&lt;/a&gt;]=&quot;items&quot;&amp;gt;&amp;lt;div&amp;gt;{{item}}&amp;lt;/div&amp;gt;&amp;lt;/ng-template&amp;gt;&lt;/code&gt;. The following sections provide detailed information on constraints, grammar, and translation of microsyntax.</source>
          <target state="translated">이러한 마이크로 구문 메커니즘은 자체 구조 지시문을 작성할 때도 사용할 수 있습니다. 예를 들어 Angular의 마이크로 구문을 사용하면 &lt;code&gt;&amp;lt;ng-template &lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt; let-item [&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngForOf&lt;/a&gt;]=&quot;items&quot;&amp;gt;&amp;lt;div&amp;gt;{{item}}&amp;lt;/div&amp;gt;&amp;lt;/ng-template&amp;gt;&lt;/code&gt; &lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt; let-item [ &lt;a href=&quot;../api/common/ngforof&quot;&gt;ngForOf&lt;/a&gt; ] = &quot;items&quot;&amp;gt; &amp;lt; 대신 &lt;code&gt;&amp;lt;div *&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;=&quot;let item of items&quot;&amp;gt;{{item}}&amp;lt;/div&amp;gt;&lt;/code&gt; 를 작성할 수 있습니다. DIV&amp;gt; {{항목}} &amp;lt;/ DIV&amp;gt; &amp;lt;/ NG 템플릿&amp;gt; . 다음 섹션에서는 제약 조건, 문법 및 마이크로 구문 번역에 대한 자세한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5b1b2fa607afc63d8c9722ad2df075b0b65154ed" translate="yes" xml:space="preserve">
          <source>These options are used to modify the matching behavior of requests. They are passed to the browsers &lt;code&gt;Cache#match&lt;/code&gt; function. See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Cache/match&quot;&gt;MDN&lt;/a&gt; for details. Currently, only the following options are supported:</source>
          <target state="translated">이러한 옵션은 요청의 일치 동작을 수정하는 데 사용됩니다. 브라우저 &lt;code&gt;Cache#match&lt;/code&gt; 함수 로 전달됩니다 . 자세한 내용은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Cache/match&quot;&gt;MDN&lt;/a&gt; 을 참조하십시오. 현재 다음 옵션 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f75727d0e53686975b5f9fe934821fc5ef2a010f" translate="yes" xml:space="preserve">
          <source>These providers are insulated from changes to application providers with the same lookup token. When the router creates a component within the lazy-loaded context, Angular prefers service instances created from these providers to the service instances of the application root injector.</source>
          <target state="translated">이러한 공급자는 동일한 조회 토큰을 가진 응용 프로그램 공급자의 변경으로부터 격리됩니다. 라우터가 느리게로드 된 컨텍스트 내에서 컴포넌트를 작성할 때 Angular는 이러한 제공자에서 작성된 서비스 인스턴스를 애플리케이션 루트 인젝터의 서비스 인스턴스보다 선호합니다.</target>
        </trans-unit>
        <trans-unit id="24dcfb3b1d815ddbfc80be55b49ecf74b9b01fec" translate="yes" xml:space="preserve">
          <source>These services become available for injection into any component, directive, pipe or service which is a child of this injector.</source>
          <target state="translated">이러한 서비스는이 인젝터의 자식 인 모든 구성 요소, 지침, 파이프 또는 서비스에 주입 할 수있게됩니다.</target>
        </trans-unit>
        <trans-unit id="f9b0721484302592e733b6e272928008f313a2ba" translate="yes" xml:space="preserve">
          <source>These situations should be very rare, and extraordinary care must be taken to avoid creating a Cross Site Scripting (XSS) security bug!</source>
          <target state="translated">이러한 상황은 매우 드 물어야하며 XSS (Cross Site Scripting) 보안 버그가 발생하지 않도록 특별한주의를 기울여야합니다!</target>
        </trans-unit>
        <trans-unit id="a17e78995649c771b926fa480048cee49ac14e32" translate="yes" xml:space="preserve">
          <source>These standard testing techniques are great for unit testing services in isolation.</source>
          <target state="translated">이러한 표준 테스트 기술은 단위 테스트 서비스를 격리하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="471f11bedf623af5e51a7550b62738fa78f523b0" translate="yes" xml:space="preserve">
          <source>These status values are mutually exclusive, so a control cannot be both valid AND invalid or invalid AND disabled.</source>
          <target state="translated">이 상태 값은 상호 배타적이므로 제어가 유효하거나 유효하지 않거나 유효하지 않으며 무효가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="05f39205bd9c10860f4038f8cb6f1f80b35432f1" translate="yes" xml:space="preserve">
          <source>These styles are post-processed so that each selector is augmented with &lt;code&gt;_nghost&lt;/code&gt; or &lt;code&gt;_ngcontent&lt;/code&gt; attribute selectors. These extra selectors enable the scoping rules described in this page.</source>
          <target state="translated">이러한 스타일은 사후 처리되므로 각 선택기가 &lt;code&gt;_nghost&lt;/code&gt; 또는 &lt;code&gt;_ngcontent&lt;/code&gt; 속성 선택기로 기능을 보강 합니다. 이러한 추가 선택기는이 페이지에 설명 된 범위 지정 규칙을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="59ed30c14d44ecaa6cf045e5333024f1a3034ced" translate="yes" xml:space="preserve">
          <source>These techniques are useful for small-scale demonstrations, but they quickly become verbose and clumsy when handling large amounts of user input. Two-way data binding is a more elegant and compact way to move values between data entry fields and model properties. The next page, &lt;code&gt;Forms&lt;/code&gt;, explains how to write two-way bindings with &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;NgModel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 기술은 소규모 데모에 유용하지만 많은 양의 사용자 입력을 처리 할 때 빠르게 장황하고 어색해집니다. 양방향 데이터 바인딩은 데이터 입력 필드와 모델 속성간에 값을 이동하는보다 우아하고 간결한 방법입니다. 다음 페이지 인 &lt;code&gt;Forms&lt;/code&gt; 에서는 &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;NgModel&lt;/a&gt;&lt;/code&gt; 을 사용 하여 양방향 바인딩을 작성하는 방법에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="53c3322dcb945c3c38eca1315cb0acd70af9667e" translate="yes" xml:space="preserve">
          <source>These tests could fail or timeout if the &lt;code&gt;HeroDetailService&lt;/code&gt; made its own XHR calls to a remote server. There might not be a remote server to call.</source>
          <target state="translated">&lt;code&gt;HeroDetailService&lt;/code&gt; 가 원격 서버에 대한 자체 XHR 호출을 수행 한 경우 이러한 테스트가 실패하거나 시간 초과 될 수 있습니다. 호출 할 원격 서버가 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce3f767e6032b95a5a603034551bf8233c93f3f2" translate="yes" xml:space="preserve">
          <source>These three examples cover the need for an app with one level routing. The moment you add a child router, such as the crisis center, you create new link array possibilities.</source>
          <target state="translated">이 세 가지 예는 하나의 레벨 라우팅으로 앱의 필요성을 다룹니다. 위기 센터와 같은 하위 라우터를 추가하는 순간 새로운 링크 배열 가능성이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="9c84bcfdd1bbb4bcd869d39ead56a3ce00137884" translate="yes" xml:space="preserve">
          <source>These three examples cover the needs of an app with one level of routing. However, with a child router, such as in the crisis center, you create new link array possibilities.</source>
          <target state="translated">이 세 가지 예는 한 수준의 라우팅으로 앱의 요구 사항을 다룹니다. 그러나 위기 센터와 같은 하위 라우터를 사용하면 새로운 링크 어레이 가능성을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a858b580e5d1dabed41a7075d6de4bc56502ab07" translate="yes" xml:space="preserve">
          <source>These two properties have subtle differences, so switching to &lt;code&gt;textContent&lt;/code&gt; under the hood can be surprising to users. For this reason, we are deprecating this behavior. Going forward, users should explicitly bind to &lt;code&gt;textContent&lt;/code&gt; when using Domino.</source>
          <target state="translated">이 두 속성에는 미묘한 차이가 있으므로 사용자가 후드 에서 &lt;code&gt;textContent&lt;/code&gt; 로 전환하는 것은 놀라운 일입니다. 이러한 이유로이 동작은 더 이상 사용되지 않습니다. 앞으로 사용자는 Domino를 사용할 때 명시 적으로 &lt;code&gt;textContent&lt;/code&gt; 에 바인딩해야합니다 .</target>
        </trans-unit>
        <trans-unit id="db3d1e9b8dc7f1d6ba6781b5d1aeadad60243cbb" translate="yes" xml:space="preserve">
          <source>These two routes navigate to the crisis center child components, &lt;code&gt;CrisisCenterHomeComponent&lt;/code&gt; and &lt;code&gt;CrisisDetailComponent&lt;/code&gt;, respectively.</source>
          <target state="translated">이 두 경로는 위기 센터 하위 구성 요소 인 &lt;code&gt;CrisisCenterHomeComponent&lt;/code&gt; 및 &lt;code&gt;CrisisDetailComponent&lt;/code&gt; 로 각각 이동합니다.</target>
        </trans-unit>
        <trans-unit id="ce122e04c4a0e2a0a5f7ad63d194e4fea023293d" translate="yes" xml:space="preserve">
          <source>They are &lt;em&gt;not inherited&lt;/em&gt; by any components nested within the template nor by any content projected into the component.</source>
          <target state="translated">그들은되는 &lt;em&gt;상속되지&lt;/em&gt; 템플릿 내도 구성 요소에 투영 된 어떤 내용으로 중첩 된 구성 요소에 의해.</target>
        </trans-unit>
        <trans-unit id="16ada202f0f526edb509f857ec3037ca6a0f4115" translate="yes" xml:space="preserve">
          <source>They are displayed in named outlets.</source>
          <target state="translated">이름이 지정된 콘센트에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1b990f73ae62c0da4608dce9f08db78466a71820" translate="yes" xml:space="preserve">
          <source>They are immutable for a good reason: the app may retry a request several times before it succeeds, which means that the interceptor chain may re-process the same request multiple times. If an interceptor could modify the original request object, the re-tried operation would start from the modified request rather than the original. Immutability ensures that interceptors see the same request for each try.</source>
          <target state="translated">앱은 요청이 성공하기 전에 여러 번 요청을 다시 시도 할 수 있으므로 인터셉터 체인에서 동일한 요청을 여러 번 다시 처리 할 수 ​​있습니다. 인터셉터가 원래 요청 오브젝트를 수정할 수있는 경우 재 시도 된 조작은 원래 요청이 아닌 수정 된 요청에서 시작됩니다. 불변성은 인터셉터가 각 시도에 대해 동일한 요청을 보도록합니다.</target>
        </trans-unit>
        <trans-unit id="0a5e8503c85509faa05b6e855e4edcff069456e9" translate="yes" xml:space="preserve">
          <source>They are independent of each other.</source>
          <target state="translated">그들은 서로 독립적입니다.</target>
        </trans-unit>
        <trans-unit id="6afb78efe8cab856821000146ea4a61b8a334fa8" translate="yes" xml:space="preserve">
          <source>They are very similar with the only difference being:</source>
          <target state="translated">유일한 차이점은 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="cfd5fb1fb1b07124fb1aace027accf1df4c99e03" translate="yes" xml:space="preserve">
          <source>They follow a common pattern: a &lt;em&gt;parent&lt;/em&gt; component serves as a test rig for a &lt;em&gt;child&lt;/em&gt; component that illustrates one or more of the lifecycle hook methods.</source>
          <target state="translated">이들은 공통 패턴을 따릅니다. &lt;em&gt;상위&lt;/em&gt; 컴포넌트는 하나 이상의 라이프 사이클 후크 메소드를 보여주는 &lt;em&gt;하위&lt;/em&gt; 컴포넌트 의 테스트 리그 역할을 합니다.</target>
        </trans-unit>
        <trans-unit id="73b47ba16ec3ed20f7c0f09044645d6af1239f79" translate="yes" xml:space="preserve">
          <source>They might be imported by the root &lt;code&gt;AppModule&lt;/code&gt; of a small application that lacks routing.</source>
          <target state="translated">라우팅이없는 작은 응용 프로그램 의 루트 &lt;code&gt;AppModule&lt;/code&gt; 에서 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0bd9de91dc582fbf7daa5013098dfee5a9baa9df" translate="yes" xml:space="preserve">
          <source>They might. By default, the router re-uses a component instance when it re-navigates to the same component type without visiting a different component first. The route parameters could change each time.</source>
          <target state="translated">그들은 그렇습니다. 기본적으로 라우터는 다른 구성 요소를 먼저 방문하지 않고 동일한 구성 요소 유형으로 다시 탐색 할 때 구성 요소 인스턴스를 재사용합니다. 경로 매개 변수는 매번 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcebc66109bd0b943ba34a0b34f724475faa7a20" translate="yes" xml:space="preserve">
          <source>They must return a Promise or an Observable,</source>
          <target state="translated">약속 또는 관찰 가능한 물건을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="6a1d3b6796b2728eca30d7dc142c330459e6d1b9" translate="yes" xml:space="preserve">
          <source>They typically have a top component that acts as the feature root and private, supporting sub-components descend from it.</source>
          <target state="translated">일반적으로 루트 및 개인 기능의 역할을하는 최상위 구성 요소가 있으며 하위 구성 요소를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f8026517cd2a6484e993db7a3cd1d56c8845b6ed" translate="yes" xml:space="preserve">
          <source>They work in combination with other routes.</source>
          <target state="translated">그들은 다른 경로와 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3d3f6d4959980160a0fdb422743d1ab226d66d6a" translate="yes" xml:space="preserve">
          <source>They'll do that with the RxJS &lt;code&gt;tap()&lt;/code&gt; operator, which looks at the observable values, does something with those values, and passes them along. The &lt;code&gt;tap()&lt;/code&gt; call back doesn't touch the values themselves.</source>
          <target state="translated">관찰 가능한 값을보고 해당 값으로 무언가를 수행하는 RxJS &lt;code&gt;tap()&lt;/code&gt; 연산자를 사용하여이를 수행합니다. &lt;code&gt;tap()&lt;/code&gt; 호출 다시는 값 자체를 만지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6764cd39877eeca69ad10d4286668ee2c1b61792" translate="yes" xml:space="preserve">
          <source>Things go wrong, especially when you're getting data from a remote server. The &lt;code&gt;HeroService.getHeroes()&lt;/code&gt; method should catch errors and do something appropriate.</source>
          <target state="translated">특히 원격 서버에서 데이터를 가져올 때 문제가 발생합니다. &lt;code&gt;HeroService.getHeroes()&lt;/code&gt; 메서드는 오류를 잡아 뭔가 적절한을해야한다.</target>
        </trans-unit>
        <trans-unit id="bba021091f297904597c2bb05d6e5e449bd86e0a" translate="yes" xml:space="preserve">
          <source>Things to keep in mind, when downgrading multiple modules:</source>
          <target state="translated">여러 모듈을 다운 그레이드 할 때 명심해야 할 사항 :</target>
        </trans-unit>
        <trans-unit id="756e27539ff0999bdbcc7f5377fff9d815ce78d8" translate="yes" xml:space="preserve">
          <source>Third step of the Tour of Heroes example application. For more information, see &lt;a href=&quot;../tutorial/toh-pt3&quot;&gt;Create a feature component&lt;/a&gt;.</source>
          <target state="translated">Tour of Heroes 예제 애플리케이션의 세 번째 단계입니다. 자세한 내용 &lt;a href=&quot;../tutorial/toh-pt3&quot;&gt;은 기능 구성 요소 만들기를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e70dff18e1178a855b0cc1f8fc21945818c734cb" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;, which shows a read-only hero with interpolation bindings, appears only while the component is in the submitted state.</source>
          <target state="translated">보간 바인딩이있는 읽기 전용 Hero를 표시하는 이 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 는 구성 요소가 제출 된 상태에있는 동안에 만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="2c24139a9de681ae61f6d7ec726db576f5f264b0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; displays the error if the &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; has the cross validation error returned by the &lt;code&gt;identityRevealed&lt;/code&gt; validator, but only if the user has finished &lt;a href=&quot;form-validation#dirty-or-touched&quot;&gt;interacting with the form&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;identityRevealed&lt;/code&gt; 유효성 검사기 가 반환 한 교차 유효성 검사 오류가있는 경우 오류를 표시 하지만 사용자가 &lt;a href=&quot;form-validation#dirty-or-touched&quot;&gt;양식과의 상호 작용을&lt;/a&gt; 완료 한 경우에만 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="c7b69adf603ad8f6d0e880b3effde6a1bd75ec06" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; example:</source>
          <target state="translated">이 &lt;code&gt;&lt;a href=&quot;ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 의 예 :</target>
        </trans-unit>
        <trans-unit id="258e5fd8f98e77a1547ddec9b070f084c89034c4" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;MissionService&lt;/code&gt; connects the &lt;code&gt;MissionControlComponent&lt;/code&gt; to multiple &lt;code&gt;AstronautComponent&lt;/code&gt; children.</source>
          <target state="translated">이 &lt;code&gt;MissionService&lt;/code&gt; 는 연결 대상 &lt;code&gt;MissionControlComponent&lt;/code&gt; 배수 &lt;code&gt;AstronautComponent&lt;/code&gt; 의 아이들.</target>
        </trans-unit>
        <trans-unit id="59e007abb53ac82deffb3014ce0885f777370e0d" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;VersionChildComponent&lt;/code&gt; detects changes to the &lt;code&gt;&lt;a href=&quot;../api/core/version#major&quot;&gt;major&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/core/version#minor&quot;&gt;minor&lt;/a&gt;&lt;/code&gt; input properties and composes a log message reporting these changes:</source>
          <target state="translated">이 &lt;code&gt;VersionChildComponent&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../api/core/version#major&quot;&gt;major&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/core/version#minor&quot;&gt;minor&lt;/a&gt;&lt;/code&gt; 입력 속성 의 변경을 감지 하고 다음 변경을보고하는 로그 메시지를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="5e474d161be24784860c8aaa6c3af723b09d2443" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;VersionChildComponent&lt;/code&gt; detects changes to the &lt;code&gt;major&lt;/code&gt; and &lt;code&gt;minor&lt;/code&gt; input properties and composes a log message reporting these changes:</source>
          <target state="translated">이 &lt;code&gt;VersionChildComponent&lt;/code&gt; 는 &lt;code&gt;major&lt;/code&gt; 및 &lt;code&gt;minor&lt;/code&gt; 입력 속성 의 변경 사항을 감지 하고 이러한 변경 사항을보고하는 로그 메시지를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="fbe66defed731afe2b351869493bed1b439539c0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;[(&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;)]&lt;/code&gt; syntax can only &lt;em&gt;set&lt;/em&gt; a data-bound property. If you need to do something more, you can write the expanded form; for example, the following changes the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; value to uppercase:</source>
          <target state="translated">이 &lt;code&gt;[(&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;)]&lt;/code&gt; 구문은 데이터 바인딩 된 속성 만 &lt;em&gt;설정할&lt;/em&gt; 수 있습니다 . 더 많은 것을해야한다면 확장 된 형태를 쓸 수 있습니다. 예를 들어, 다음은 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 값을 대문자로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="d891bfbbc30a830ed00d349d04e68d42b5ea2457" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;bootstrap&lt;/code&gt; method is a direct replacement (takes same arguments) for AngularJS &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.bootstrap&quot;&gt;&lt;code&gt;bootstrap&lt;/code&gt;&lt;/a&gt; method. Unlike AngularJS, this bootstrap is asynchronous.</source>
          <target state="translated">이 &lt;code&gt;bootstrap&lt;/code&gt; 메소드는 AngularJS &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.bootstrap&quot;&gt; &lt;code&gt;bootstrap&lt;/code&gt; &lt;/a&gt; 메소드 를 직접 대체합니다 (동일한 인수를 취함) . AngularJS와 달리이 부트 스트랩은 비동기식입니다.</target>
        </trans-unit>
        <trans-unit id="a81bbff7f4c2b4f66516ab105c5f2da6f8908842" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;getHeroes()&lt;/code&gt; returns the sliced list of heroes at positions 1 and 5, returning only four of the Top Heroes (2nd, 3rd, 4th, and 5th).</source>
          <target state="translated">이 &lt;code&gt;getHeroes()&lt;/code&gt; 는 위치 1과 5에있는 슬라이스 된 영웅 목록을 리턴하고 상위 영웅 중 4 명 (2, 3, 4, 5) 만 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9b89a86d9e9910b9545a4d39e96b18d0d3af5a5b" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;outlets&lt;/code&gt; object within an outer object was completely unnecessary when there was only one route and one &lt;em&gt;unnamed&lt;/em&gt; outlet to think about.</source>
          <target state="translated">이 &lt;code&gt;outlets&lt;/code&gt; 하나 개의 경로와 하나 개있을 때 외부 객체 내 목적은 완전히 불필요 &lt;em&gt;이름이&lt;/em&gt; 생각하는 콘센트.</target>
        </trans-unit>
        <trans-unit id="5491cacef48b72757c7e430268f1e44c75a5a9c3" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;outlets&lt;/code&gt; object within an outer object was unnecessary when there was only one route and one unnamed outlet.</source>
          <target state="translated">이 &lt;code&gt;outlets&lt;/code&gt; 하나의 행 및 하나 개의 출구 이름이있을 때 외부 객체 내의 객체는 불필요했다.</target>
        </trans-unit>
        <trans-unit id="7f20e0dbf005f61cffb8c3dd9af39a375a30b434" translate="yes" xml:space="preserve">
          <source>This &lt;em&gt;Tour of Heroes&lt;/em&gt; tutorial provides an introduction to the fundamentals of Angular. It shows you how to set up your local development environment and develop an app using the &lt;a href=&quot;https://angular.io/cli&quot;&gt;Angular CLI tool&lt;/a&gt;.</source>
          <target state="translated">이 &lt;em&gt;Tour of Heroes&lt;/em&gt; 튜토리얼은 Angular의 기본 사항을 소개합니다. &lt;a href=&quot;https://angular.io/cli&quot;&gt;Angular CLI 도구를&lt;/a&gt; 사용하여 로컬 개발 환경을 설정하고 앱을 개발하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="c24943786f27bf8eb8f423a4535eae1d8c0db2ea" translate="yes" xml:space="preserve">
          <source>This &lt;em&gt;Tour of Heroes&lt;/em&gt; tutorial shows you how to set up your local development environment and develop an app using the &lt;a href=&quot;https://angular.io/cli&quot;&gt;Angular CLI tool&lt;/a&gt;, and provides an introduction to the fundamentals of Angular.</source>
          <target state="translated">이 &lt;em&gt;Tour of Heroes&lt;/em&gt; 튜토리얼은 &lt;a href=&quot;https://angular.io/cli&quot;&gt;Angular CLI 도구를&lt;/a&gt; 사용하여 로컬 개발 환경을 설정하고 앱을 개발하는 방법을 보여주고 Angular 의 기본 사항을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="f09b226e4f2c4eb0d926e572d4a75f6880da5490" translate="yes" xml:space="preserve">
          <source>This &lt;em&gt;no-op&lt;/em&gt; interceptor simply calls &lt;code&gt;next.handle()&lt;/code&gt; with the original request and returns the observable without doing a thing.</source>
          <target state="translated">이 &lt;em&gt;no-op&lt;/em&gt; 인터셉터는 단순히 원래 요청으로 &lt;code&gt;next.handle()&lt;/code&gt; 을 호출 하고 수행하지 않고 관찰 가능 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="50210317fa118bab69579c2022e5d9a816190d39" translate="yes" xml:space="preserve">
          <source>This API is the recommended way to construct injectors in performance-sensitive parts.</source>
          <target state="translated">이 API는 성능에 민감한 부분에 인젝터를 구성하는 데 권장되는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="0afd71a82786c8f3561d56c5cfd0be5839b4503c" translate="yes" xml:space="preserve">
          <source>This HTML uses an Angular directive, &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;routerLink&lt;/a&gt;&lt;/code&gt;. This directive connects the routes you defined to your template files.</source>
          <target state="translated">이 HTML은 Angular 지시문 인 &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;routerLink&lt;/a&gt;&lt;/code&gt; 를 사용합니다 . 이 지시문은 정의한 경로를 템플릿 파일에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="469f1d1eec641289327d7f725b8bc80d83c5b953" translate="yes" xml:space="preserve">
          <source>This Style Guide is for anyone who contributes to the Angular documentation (this site). These guidelines should be followed by all authors. Deviations must be approved by a documentation editor.</source>
          <target state="translated">이 스타일 가이드는 Angular 설명서 (이 사이트)에 기고 한 사람을위한 것입니다. 이 지침은 모든 저자가 따라야합니다. 편차는 문서 편집기에서 승인해야합니다.</target>
        </trans-unit>
        <trans-unit id="3415857a9e6030331c79e1e76604015a5df5e041" translate="yes" xml:space="preserve">
          <source>This UI uses the HTML unordered list with &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; tags. The &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element is the Angular &quot;repeater&quot; directive. It marks that &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element (and its children) as the &quot;repeater template&quot;:</source>
          <target state="translated">이 UI는 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 태그 와 함께 HTML 비 순차 목록을 사용합니다 . &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 는 에서 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소는 각도 &quot;중계기&quot;지시자이다. 이 마크가 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 은 &quot;리피터 템플릿&quot;등의 요소 (및 자녀) :</target>
        </trans-unit>
        <trans-unit id="2b4ebc81415f90795ab79ed8a5b2cd8f2bb7595a" translate="yes" xml:space="preserve">
          <source>This XML element represents the translation of the &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; greeting tag that you marked with the &lt;code&gt;i18n&lt;/code&gt; attribute earlier in this guide.</source>
          <target state="translated">이 XML 요소는 이 안내서 앞부분에서 &lt;code&gt;i18n&lt;/code&gt; 속성으로 표시 한 &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; 인사말 태그 의 번역을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="48298b5a19ab51f248711bfb5fa88cc617b0670f" translate="yes" xml:space="preserve">
          <source>This allows the Angular Language Service to provide diagnostics and completions in &lt;code&gt;.ts&lt;/code&gt; files.</source>
          <target state="translated">이를 통해 Angular Language Service는 &lt;code&gt;.ts&lt;/code&gt; 파일의 진단 및 완료를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98f7af4e84f120f59a1303fcf4a9447a45a5d38a" translate="yes" xml:space="preserve">
          <source>This allows the compiler to generate a reference to &lt;code&gt;ɵ0&lt;/code&gt; in the factory without having to know what the value of &lt;code&gt;ɵ0&lt;/code&gt; contains.</source>
          <target state="translated">이를 통해 컴파일러 는 &lt;code&gt;ɵ0&lt;/code&gt; 값에 포함 된 값을 몰라도 팩토리에서 &lt;code&gt;ɵ0&lt;/code&gt; 에 대한 참조를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24015a5bb2d8b1f8210c5acd6f640d4dc6d483b2" translate="yes" xml:space="preserve">
          <source>This allows us to add new states without having to include separate transitions for each one.</source>
          <target state="translated">이를 통해 각 상태에 대해 별도의 전환을 포함하지 않고도 새로운 상태를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbe0ef929bc0631d02b1205466d152dddaeabe4f" translate="yes" xml:space="preserve">
          <source>This allows you to set appropriate styles for individual components that won&amp;rsquo;t leak into other parts of the application.</source>
          <target state="translated">이를 통해 응용 프로그램의 다른 부분으로 누출되지 않는 개별 구성 요소에 적합한 스타일을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa04bc183c4a35ffd59532acaddb459c40802b8c" translate="yes" xml:space="preserve">
          <source>This always means importing &lt;code&gt;&lt;a href=&quot;../api/common/commonmodule&quot;&gt;CommonModule&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;@angular/common&lt;/code&gt; for access to the Angular directives such as &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;NgFor&lt;/code&gt;. You can import it directly or from another NgModule that &lt;a href=&quot;ngmodule-faq#q-reexport&quot;&gt;re-exports&lt;/a&gt; it.</source>
          <target state="translated">이것은 항상 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;NgFor&lt;/code&gt; 같은 Angular 지시문에 액세스하기 위해 &lt;code&gt;@angular/common&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../api/common/commonmodule&quot;&gt;CommonModule&lt;/a&gt;&lt;/code&gt; 을 가져 오는 것을 의미 합니다. 직접 가져 오거나 &lt;a href=&quot;ngmodule-faq#q-reexport&quot;&gt;다시 내보내는&lt;/a&gt; 다른 NgModule에서 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e4af21eecd43fe210746ff3a4c62a38f49ffe7f9" translate="yes" xml:space="preserve">
          <source>This app has many of the features you'd expect to find in a data-driven application. It acquires and displays a list of heroes, edits a selected hero's detail, and navigates among different views of heroic data.</source>
          <target state="translated">이 응용 프로그램에는 데이터 기반 응용 프로그램에서 기대할 수있는 많은 기능이 있습니다. 영웅 목록을 가져 와서 표시하고 선택한 영웅의 세부 정보를 편집하며 다양한 영웅 데이터보기를 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="f17ea08bfc5149a70f6152907b2632dc2a63714a" translate="yes" xml:space="preserve">
          <source>This app provides &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; in the app's root injector, as a side-effect of importing the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;AppModule&lt;/code&gt;. You should provide interceptors in &lt;code&gt;AppModule&lt;/code&gt; as well.</source>
          <target state="translated">이 응용 프로그램은 제공 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 를을 수입의 부작용으로, 응용 프로그램의 루트 인젝터에 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt; 을 에 &lt;code&gt;AppModule&lt;/code&gt; . &lt;code&gt;AppModule&lt;/code&gt; 에서도 인터셉터를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9010af53dce21e99cd1b98b6918ed08a568edceb" translate="yes" xml:space="preserve">
          <source>This app uses more terse &quot;variable assignment&quot; style simply for brevity.</source>
          <target state="translated">이 응용 프로그램은 간결성을 위해 더 간결한 &quot;변수 할당&quot;스타일을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e2dd29b7095751503adbe18ae104950880b8fed2" translate="yes" xml:space="preserve">
          <source>This application deletes a hero with the &lt;code&gt;HttpClient.delete&lt;/code&gt; method by passing the hero's id in the request URL.</source>
          <target state="translated">이 애플리케이션 은 요청 URL에 히어로의 ID를 전달하여 &lt;code&gt;HttpClient.delete&lt;/code&gt; 메소드로 히어로를 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="fb866e223d05018eca2dedfbe444966b166935fb" translate="yes" xml:space="preserve">
          <source>This application won't re-use the &lt;code&gt;HeroDetailComponent&lt;/code&gt;. The user always returns to the hero list to select another hero to view. There's no way to navigate from one hero detail to another hero detail without visiting the list component in between. Therefore, the router creates a new &lt;code&gt;HeroDetailComponent&lt;/code&gt; instance every time.</source>
          <target state="translated">이 애플리케이션은 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 를 재사용하지 않습니다 . 사용자는 항상 영웅 목록으로 돌아가서 볼 다른 영웅을 선택합니다. 그 사이에있는 목록 구성 요소를 방문하지 않고 한 영웅 세부 정보에서 다른 영웅 세부 정보로 이동할 수있는 방법은 없습니다. 따라서 라우터는 매번 새로운 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 인스턴스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="448875963d3ea5d9faf62ce4ea4e238a24bd4684" translate="yes" xml:space="preserve">
          <source>This approach makes it easier to re-use the component somewhere else and deliver the component's intended appearance even if the global styles are different.</source>
          <target state="translated">이 방법을 사용하면 전역 스타일이 다르더라도 구성 요소를 다른 곳에서 쉽게 재사용하고 구성 요소의 의도 된 모양을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="736cdde48162e97e7bae316bb32e7680eb170f89" translate="yes" xml:space="preserve">
          <source>This approach works for prototyping, but is not robust or maintainable. As soon as you try to test this component or get heroes from a remote server, you have to change the implementation of &lt;code&gt;HeroesListComponent&lt;/code&gt; and replace every use of the &lt;code&gt;HEROES&lt;/code&gt; mock data.</source>
          <target state="translated">이 방법은 프로토 타이핑에 적용되지만 강력하거나 유지 관리 할 수는 없습니다. 이 구성 요소를 테스트하거나 원격 서버에서 영웅을 가져 &lt;code&gt;HeroesListComponent&lt;/code&gt; 하면 HeroesListComponent 의 구현을 변경하고 모든 &lt;code&gt;HEROES&lt;/code&gt; 모의 데이터 사용을 바꿔야 합니다.</target>
        </trans-unit>
        <trans-unit id="0acaa2b4ca7df60a89c610729a6dc049181aab2c" translate="yes" xml:space="preserve">
          <source>This array lacks a route parameter because previously you didn't need to send information to the &lt;code&gt;HeroListComponent&lt;/code&gt;.</source>
          <target state="translated">이전에는 &lt;code&gt;HeroListComponent&lt;/code&gt; 에 정보를 보낼 필요가 없었기 때문에이 배열에는 경로 매개 변수가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d2207c94db1f3c39ac92627d2d416a732485be1c" translate="yes" xml:space="preserve">
          <source>This array lacks a route parameter because you had no reason to send information to the &lt;code&gt;HeroListComponent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HeroListComponent&lt;/code&gt; 에 정보를 보낼 이유가 없기 때문에이 배열에는 경로 매개 변수가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e9b9947c5ef101e16618174c23e01f209fae9d4e" translate="yes" xml:space="preserve">
          <source>This article explains how to configure your project to run Circle CI and Travis CI, and also update your test configuration to be able to run tests in the Chrome browser in either environment.</source>
          <target state="translated">이 도움말에서는 Circle CI 및 Travis CI를 실행하도록 프로젝트를 구성하는 방법과 두 환경의 Chrome 브라우저에서 테스트를 실행할 수 있도록 테스트 구성을 업데이트하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4e02ae1fdc78e80303d48713d37550a281676bcb" translate="yes" xml:space="preserve">
          <source>This asynchronous approach &lt;em&gt;will work&lt;/em&gt; when the &lt;code&gt;HeroService&lt;/code&gt; requests heroes from the server.</source>
          <target state="translated">이 비동기 방식 &lt;em&gt;은 &lt;/em&gt; &lt;code&gt;HeroService&lt;/code&gt; 가 서버에서 영웅을 요청할 때 &lt;em&gt;작동&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9e58e666a6e882960d6b1daf78543b6547ba94f0" translate="yes" xml:space="preserve">
          <source>This attack is only successful if the returned JSON is executable as JavaScript. Servers can prevent an attack by prefixing all JSON responses to make them non-executable, by convention, using the well-known string &lt;code&gt;&quot;)]}',\n&quot;&lt;/code&gt;.</source>
          <target state="translated">이 공격은 반환 된 JSON이 JavaScript로 실행 가능한 경우에만 성공합니다. 서버는 잘 알려진 문자열 &lt;code&gt;&quot;)]}',\n&quot;&lt;/code&gt; 사용하여 규칙에 따라 모든 JSON 응답을 접두어로 실행하여 실행 불가능하게함으로써 공격을 방지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="651be0a8100915d5529b17ae73b92bbe7b153f12" translate="yes" xml:space="preserve">
          <source>This bare minimum &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; imports &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt;, the module every Angular browser-based app must have. It also defines an empty &lt;code&gt;ngDoBootstrap()&lt;/code&gt; method, to prevent the &lt;a href=&quot;../api/core/compiler&quot;&gt;Compiler&lt;/a&gt; from returning errors. This is necessary because the module will not have a &lt;code&gt;bootstrap&lt;/code&gt; declaration on its &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; decorator.</source>
          <target state="translated">이 최소한의 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 은 모든 Angular 브라우저 기반 앱이 가지고 있어야하는 모듈 인 &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt; 을 가져옵니다 . 또한 &lt;a href=&quot;../api/core/compiler&quot;&gt;컴파일러&lt;/a&gt; 가 오류를 반환 하지 않도록 빈 &lt;code&gt;ngDoBootstrap()&lt;/code&gt; 메서드를 정의 합니다. 이는 모듈이 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 데코레이터 에 &lt;code&gt;bootstrap&lt;/code&gt; 선언을 가지지 않기 때문에 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="f56abc002d8d199ab12c7a00e8eceb4cb5324712" translate="yes" xml:space="preserve">
          <source>This bare minimum &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; imports &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt;, the module every Angular browser-based app must have. It also imports &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;@angular/upgrade/&lt;a href=&quot;../api/upgrade/static&quot;&gt;static&lt;/a&gt;&lt;/code&gt;, which exports providers that will be used for upgrading and downgrading services and components.</source>
          <target state="translated">이 최소한의 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 은 모든 Angular 브라우저 기반 앱이 가지고 있어야하는 모듈 인 &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt; 을 가져옵니다 . 또한 &lt;code&gt;@angular/upgrade/&lt;a href=&quot;../api/upgrade/static&quot;&gt;static&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/upgrade/static&quot;&gt;static&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 을 가져와 서비스 및 구성 요소를 업그레이드 및 다운 그레이드하는 데 사용할 공급자를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="b7707e5e049453b4bfe2c53a590c89b76a5930cb" translate="yes" xml:space="preserve">
          <source>This base route reuse strategy only reuses routes when the matched router configs are identical. This prevents components from being destroyed and recreated when just the fragment or query parameters change (that is, the existing component is &lt;em&gt;reused&lt;/em&gt;).</source>
          <target state="translated">이 기본 경로 재사용 전략은 일치하는 라우터 구성이 동일한 경우에만 경로를 재사용합니다. 이렇게하면 조각 또는 쿼리 매개 변수 만 변경 될 때 (즉, 기존 구성 요소가 &lt;em&gt;재사용&lt;/em&gt; 될 때) 구성 요소가 파괴되고 다시 생성되는 것을 방지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4182fbf9bcd985eb43d694af8b1af19720683102" translate="yes" xml:space="preserve">
          <source>This behavior necessarily changes when you use lazy loading. Lazy loading is when you load modules only when you need them; for example, when routing. They aren&amp;rsquo;t loaded right away like with eagerly loaded modules. This means that any services listed in their provider arrays aren&amp;rsquo;t available because the root injector doesn&amp;rsquo;t know about these modules.</source>
          <target state="translated">이 동작은 지연 로딩을 사용할 때 반드시 변경됩니다. 지연로드는 필요할 때만 모듈을로드 할 때입니다. 예를 들어 라우팅 할 때. 모듈은 열성적으로로드 된 것처럼 즉시로드되지 않습니다. 이는 루트 인젝터가 이러한 모듈에 대해 알지 못하기 때문에 제공자 배열에 나열된 서비스를 사용할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d78768b8b53f7f8d52aad3d6a653f672b2d18303" translate="yes" xml:space="preserve">
          <source>This binding causes the &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; to span two columns.</source>
          <target state="translated">이 바인딩으로 인해 &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; 이 두 열에 걸쳐 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab02175f78bb844c7114edbf8c6e52980e6dba3f" translate="yes" xml:space="preserve">
          <source>This cadence of releases gives eager developers access to new features as soon as they are fully developed and pass through our code review and integration testing processes, while maintaining the stability and reliability of the platform for production users that prefer to receive features after they have been validated by Google and other developers that use the pre-release builds.</source>
          <target state="translated">이 릴리스주기는 열성적인 개발자가 완전히 개발되고 코드 검토 및 통합 테스트 프로세스를 통과하는 즉시 새로운 기능에 액세스 할 수 있도록하는 동시에, 기능을받은 후 기능을 선호하는 프로덕션 사용자를 위해 플랫폼의 안정성과 안정성을 유지합니다. Google 및 출시 전 빌드를 사용하는 다른 개발자가 검증했습니다.</target>
        </trans-unit>
        <trans-unit id="35a35e5d7d8bb3b5d8a866028a9f757d0c2abbb7" translate="yes" xml:space="preserve">
          <source>This cadence of releases gives you access to new features as soon as they are ready, while maintaining the stability and reliability of the platform for production users.</source>
          <target state="translated">이 릴리스의 릴리스는 프로덕션 사용자를위한 플랫폼의 안정성과 안정성을 유지하면서 새로운 기능이 준비되는 즉시 액세스 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="de8dbaffe2662ccb066fdee3c1966e668ead9335" translate="yes" xml:space="preserve">
          <source>This can be a problem if you have to change your app's location. If you setup a redirect from the old location (for example &lt;code&gt;example.com&lt;/code&gt;) to the new location (for example &lt;code&gt;www.example.com&lt;/code&gt;) the worker will stop working. Also, the redirect won't even trigger for users who are loading the site entirely from Service Worker. The old worker (registered at &lt;code&gt;example.com&lt;/code&gt;) tries to update and sends requests to the old location &lt;code&gt;example.com&lt;/code&gt; which get redirected to the new location &lt;code&gt;www.example.com&lt;/code&gt; and create the error &lt;code&gt;The script resource is behind &lt;a href=&quot;../api/router/routerlinkwithhref&quot;&gt;a&lt;/a&gt; redirect, which is disallowed&lt;/code&gt;.</source>
          <target state="translated">앱의 위치를 ​​변경해야하는 경우 문제가 될 수 있습니다. 이전 위치 (예 : &lt;code&gt;example.com&lt;/code&gt; )에서 새 위치 (예 : &lt;code&gt;www.example.com&lt;/code&gt; ) 로 리디렉션을 설정 하면 작업자가 작업을 중지합니다. 또한 사이트 전체를 Service Worker에서로드하는 사용자에게는 리디렉션이 트리거되지 않습니다. (에 등록 된 오래된 노동자 &lt;code&gt;example.com&lt;/code&gt; 은 ) 업데이트하려고하고 이전 위치로 요청을 보내는 &lt;code&gt;example.com&lt;/code&gt; 새 위치로 리디렉션 &lt;code&gt;www.example.com&lt;/code&gt; 과 오류 생성 &lt;code&gt;The script resource is behind &lt;a href=&quot;../api/router/routerlinkwithhref&quot;&gt;a&lt;/a&gt; redirect, which is disallowed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf472237a640d8cae814bf8d16bcc95349771c9f" translate="yes" xml:space="preserve">
          <source>This can be a problem if you have to change your app's location. If you setup a redirect from the old location (for example &lt;code&gt;example.com&lt;/code&gt;) to the new location (for example &lt;code&gt;www.example.com&lt;/code&gt;) the worker will stop working. Also, the redirect won't even trigger for users who are loading the site entirely from Service Worker. The old worker (registered at &lt;code&gt;example.com&lt;/code&gt;) tries to update and sends requests to the old location &lt;code&gt;example.com&lt;/code&gt; which get redirected to the new location &lt;code&gt;www.example.com&lt;/code&gt; and create the error &lt;code&gt;The script resource is behind a redirect, which is disallowed&lt;/code&gt;.</source>
          <target state="translated">앱의 위치를 ​​변경해야하는 경우 문제가 될 수 있습니다. 이전 위치 (예 : &lt;code&gt;example.com&lt;/code&gt; )에서 새 위치 (예 : &lt;code&gt;www.example.com&lt;/code&gt; ) 로의 리디렉션을 설정 하면 작업자가 작업을 중지합니다. 또한 리디렉션은 Service Worker에서 사이트를 완전히로드하는 사용자에게도 트리거되지 않습니다. 이전 작업자 ( &lt;code&gt;example.com&lt;/code&gt; 에 등록됨 )는 새 위치 &lt;code&gt;www.example.com&lt;/code&gt; 으로 리디렉션되는 이전 위치 &lt;code&gt;example.com&lt;/code&gt; 으로 업데이트를 시도하고 요청을 보내고 &lt;code&gt;The script resource is behind a redirect, which is disallowed&lt;/code&gt; 오류를 생성합니다. .</target>
        </trans-unit>
        <trans-unit id="3a25a7112462a90a222ddd01185604490e952693" translate="yes" xml:space="preserve">
          <source>This can be used to resume testing after events have triggered asynchronous activity or asynchronous change detection.</source>
          <target state="translated">이벤트가 비동기 활동 또는 비동기 변경 감지를 트리거 한 후 테스트를 재개하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="934112ccd1aa2b6915e125429be40b8b0e576f0a" translate="yes" xml:space="preserve">
          <source>This can be useful when scanning through code and looking for observable values. Also, if you want a property to store the most recent value from an observable, it can be convenient to simply use the same name with or without the &amp;ldquo;$&amp;rdquo;.</source>
          <target state="translated">이것은 코드를 통해 스캔하고 관찰 가능한 값을 찾을 때 유용 할 수 있습니다. 또한 속성에서 관찰 가능 항목의 최신 값을 저장하려면 &quot;$&quot;가 있거나없는 동일한 이름을 사용하는 것이 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="9f44c321dfe09485e6daf24efdf592a980b9e74b" translate="yes" xml:space="preserve">
          <source>This can cause confusion. For example:</source>
          <target state="translated">이로 인해 혼동이 발생할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="2b2a566810683bdb154f2660dc33dfd48367534d" translate="yes" xml:space="preserve">
          <source>This can happen if you refer to an ambient type. For example, the &lt;code&gt;Window&lt;/code&gt; type is an ambient type declared in the global &lt;code&gt;.d.ts&lt;/code&gt; file.</source>
          <target state="translated">주변 유형을 참조하면 이런 일이 발생할 수 있습니다. 예를 들어, &lt;code&gt;Window&lt;/code&gt; 유형은 전역 &lt;code&gt;.d.ts&lt;/code&gt; 파일에 선언 된 주변 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="6476281277699a0797217af1c8c95aadca9fed5f" translate="yes" xml:space="preserve">
          <source>This can happen if you use a number as a property name as in the following example.</source>
          <target state="translated">다음 예와 같이 숫자를 속성 이름으로 사용하면 이런 일이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b41585be32bdaba39097b77ac3bb57808c72252" translate="yes" xml:space="preserve">
          <source>This can happen when a &lt;a href=&quot;../../guide/router#milestone-5-route-guards&quot;&gt;route guard&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt; or initiates a redirect by returning a &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;../../guide/router#milestone-5-route-guards&quot;&gt;라우트 가드&lt;/a&gt; 가 &lt;code&gt;false&lt;/code&gt; 를 반환하거나 &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 를 반환하여 리디렉션을 시작할 때 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="161acaf31fb43a0787ee8fbb9353bde452188f86" translate="yes" xml:space="preserve">
          <source>This causes the CLI to create a folder called &lt;code&gt;customer-dashboard&lt;/code&gt; with a file inside called &lt;code&gt;customer-dashboard.module.ts&lt;/code&gt; with the following contents:</source>
          <target state="translated">이로 인해 CLI는 &lt;code&gt;customer-dashboard&lt;/code&gt; .module.ts 내부 에 다음 내용을 포함하는 &lt;code&gt;customer-dashboard.module.ts&lt;/code&gt; 라는 폴더를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="5019a44a75c49b88537ac9e8329f1c2eab2831e5" translate="yes" xml:space="preserve">
          <source>This class is an &lt;code&gt;&lt;a href=&quot;../../core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt;, which you import to provide AngularJS core services, and has an instance method used to bootstrap the hybrid upgrade application.</source>
          <target state="translated">이 클래스는 &lt;code&gt;&lt;a href=&quot;../../core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 이며 AngularJS 핵심 서비스를 제공하기 위해 가져 오며 하이브리드 업그레이드 애플리케이션을 부트 스트랩하는 데 사용되는 인스턴스 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="025bc612549c84721126511ec42b2a6d0ff1d56c" translate="yes" xml:space="preserve">
          <source>This class is immutable; all mutation operations return a new instance.</source>
          <target state="translated">이 클래스는 불변입니다. 모든 돌연변이 작업은 새로운 인스턴스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d3d60295749b3a3a0404d6398d78e18e444489d5" translate="yes" xml:space="preserve">
          <source>This class is only used internally in the &lt;code&gt;&lt;a href=&quot;reactiveformsmodule&quot;&gt;ReactiveFormsModule&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 &lt;code&gt;&lt;a href=&quot;reactiveformsmodule&quot;&gt;ReactiveFormsModule&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; 내부에서만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="801d9cace214c9cf01792d4f29b30f5848a25da1" translate="yes" xml:space="preserve">
          <source>This class should not be used directly by an application developer. Instead, use &lt;a href=&quot;common/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 응용 프로그램 개발자가 직접 사용해서는 안됩니다. 대신 &lt;a href=&quot;common/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d1d6a70007738552506319e31c6ae61765926844" translate="yes" xml:space="preserve">
          <source>This class should not be used directly by an application developer. Instead, use &lt;a href=&quot;location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 클래스는 응용 프로그램 개발자가 직접 사용해서는 안됩니다. 대신 &lt;a href=&quot;location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1130101a82611d98bbdc3094466ba2af2e0c67ec" translate="yes" xml:space="preserve">
          <source>This code adds the &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; to the &lt;code&gt;imports&lt;/code&gt; array. Next, the code uses the &lt;code&gt;forRoot()&lt;/code&gt; method of the &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; to define your two routes. This method takes an array of JavaScript objects, with each object defining the proprties of a route. The &lt;code&gt;forRoot()&lt;/code&gt; method ensures that your application only instantiates one &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt;. For more information, see &lt;a href=&quot;singleton-services#forroot-and-the-router&quot;&gt;Singleton Services&lt;/a&gt;.</source>
          <target state="translated">이 코드는 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;imports&lt;/code&gt; 배열에 추가합니다 . 다음 코드는 사용 &lt;code&gt;forRoot()&lt;/code&gt; 의 방법 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; 당신이 개 경로를 정의 할 수 있습니다. 이 메서드는 각 객체가 경로의 속성을 정의하는 JavaScript 객체의 배열을 사용합니다. &lt;code&gt;forRoot()&lt;/code&gt; 메소드 보장하지만 응용 프로그램은 하나의 인스턴스 것을 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; 을 . 자세한 내용은 &lt;a href=&quot;singleton-services#forroot-and-the-router&quot;&gt;Singleton Services를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f7dbb83be6aba801790f665b970b9f834230c23e" translate="yes" xml:space="preserve">
          <source>This code inspects certain &lt;em&gt;values of interest&lt;/em&gt;, capturing and comparing their current state against previous values. It writes a special message to the log when there are no substantive changes to the &lt;code&gt;hero&lt;/code&gt; or the &lt;code&gt;power&lt;/code&gt; so you can see how often &lt;code&gt;&lt;a href=&quot;../api/core/docheck&quot;&gt;DoCheck&lt;/a&gt;()&lt;/code&gt; is called. The results are illuminating.</source>
          <target state="translated">이 코드 &lt;em&gt;는 관심있는&lt;/em&gt; 특정 &lt;em&gt;값을&lt;/em&gt; 검사 하여 현재 상태를 캡처하고 이전 값과 비교합니다. &lt;code&gt;hero&lt;/code&gt; 이나 &lt;code&gt;power&lt;/code&gt; 실질적인 변화가 없을 때 로그에 특별한 메시지를 &lt;code&gt;&lt;a href=&quot;../api/core/docheck&quot;&gt;DoCheck&lt;/a&gt;()&lt;/code&gt; 가 얼마나 자주 호출 되는지 볼 수 있습니다 . 결과는 분명합니다.</target>
        </trans-unit>
        <trans-unit id="d5c998372f08c1a101f67cf6fc6453dc480a13a2" translate="yes" xml:space="preserve">
          <source>This code inspects certain &lt;em&gt;values of interest&lt;/em&gt;, capturing and comparing their current state against previous values. It writes a special message to the log when there are no substantive changes to the &lt;code&gt;hero&lt;/code&gt; or the &lt;code&gt;power&lt;/code&gt; so you can see how often &lt;code&gt;&lt;a href=&quot;../api/core/docheck&quot;&gt;DoCheck&lt;/a&gt;&lt;/code&gt; is called. The results are illuminating:</source>
          <target state="translated">이 코드 &lt;em&gt;는 관심있는&lt;/em&gt; 특정 &lt;em&gt;값을&lt;/em&gt; 검사 하여 현재 상태를 캡처하고 이전 값과 비교합니다. &lt;code&gt;hero&lt;/code&gt; 이나 &lt;code&gt;power&lt;/code&gt; 실질적인 변화가 없을 때 로그에 특별한 메시지를 작성하여 &lt;code&gt;&lt;a href=&quot;../api/core/docheck&quot;&gt;DoCheck&lt;/a&gt;&lt;/code&gt; 가 얼마나 자주 호출 되는지 확인할 수 있습니다 . 결과는 밝습니다.</target>
        </trans-unit>
        <trans-unit id="db010d4e9e3ffb1514bc2b0d8a75b9801342ba2f" translate="yes" xml:space="preserve">
          <source>This code repeats the &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; tag for each power in the list of powers. The &lt;code&gt;pow&lt;/code&gt; template input variable is a different power in each iteration; you display its name using the interpolation syntax.</source>
          <target state="translated">이 코드는 전원 목록의 각 전원에 대해 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 태그를 반복합니다 . &lt;code&gt;pow&lt;/code&gt; 템플릿의 입력 변수는 각각의 반복에서 상이한 전력이고; 보간 구문을 사용하여 이름을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="75b5c5fa1c91023ea749d4aa233f6b4929e1dfb1" translate="yes" xml:space="preserve">
          <source>This code sets the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; property by binding to the &lt;code&gt;name&lt;/code&gt; property. To listen for changes to the value, the code binds to the &lt;code&gt;input&lt;/code&gt; event of the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element. When the user makes changes, the &lt;code&gt;input&lt;/code&gt; event is raised, and the binding executes the statement within a context that includes the DOM event object, &lt;code&gt;$event&lt;/code&gt;.</source>
          <target state="translated">이 코드는 &lt;code&gt;name&lt;/code&gt; 속성 에 바인딩 하여 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 속성을 설정합니다 . 값의 변경 사항을 수신하기 위해 코드 는 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 요소 의 &lt;code&gt;input&lt;/code&gt; 이벤트에 바인딩합니다 . 사용자가 변경하면 &lt;code&gt;input&lt;/code&gt; 이벤트가 발생하고 바인딩은 DOM 이벤트 객체 &lt;code&gt;$event&lt;/code&gt; 를 포함하는 컨텍스트 내에서 명령문을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="c635cb0e548cea6b4f39f0f4a00a64dd0890bc38" translate="yes" xml:space="preserve">
          <source>This code uses only one &lt;code&gt;&lt;a href=&quot;asyncpipe&quot;&gt;AsyncPipe&lt;/a&gt;&lt;/code&gt;, so only one subscription is created. The conditional statement stores the result of &lt;code&gt;userStream|&lt;a href=&quot;asyncpipe&quot;&gt;async&lt;/a&gt;&lt;/code&gt; in the local variable &lt;code&gt;user&lt;/code&gt;. You can then bind the local &lt;code&gt;user&lt;/code&gt; repeatedly.</source>
          <target state="translated">이 코드는 하나의 &lt;code&gt;&lt;a href=&quot;asyncpipe&quot;&gt;AsyncPipe&lt;/a&gt;&lt;/code&gt; 만 사용 하므로 하나의 구독 만 생성됩니다. 조건문은 &lt;code&gt;userStream|&lt;a href=&quot;asyncpipe&quot;&gt;async&lt;/a&gt;&lt;/code&gt; 의 결과를 저장합니다. 로컬 변수 &lt;code&gt;user&lt;/code&gt; 의비동기 . 그런 다음 로컬 &lt;code&gt;user&lt;/code&gt; 반복적으로 바인딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="077f99384ba94951a54310fe9d28e905bc2e0a9b" translate="yes" xml:space="preserve">
          <source>This code uses only one &lt;code&gt;&lt;a href=&quot;asyncpipe&quot;&gt;AsyncPipe&lt;/a&gt;&lt;/code&gt;, so only one subscription is created. The conditional statement stores the result of &lt;code&gt;userStream|async&lt;/code&gt; in the local variable &lt;code&gt;user&lt;/code&gt;. You can then bind the local &lt;code&gt;user&lt;/code&gt; repeatedly.</source>
          <target state="translated">이 코드는 하나의 &lt;code&gt;&lt;a href=&quot;asyncpipe&quot;&gt;AsyncPipe&lt;/a&gt;&lt;/code&gt; 만 사용 하므로 하나의 구독 만 작성됩니다. 조건문은 &lt;code&gt;userStream|async&lt;/code&gt; 의 결과를 로컬 변수 &lt;code&gt;user&lt;/code&gt; 에 저장 합니다. 그런 다음 로컬 &lt;code&gt;user&lt;/code&gt; 반복해서 바인딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13648ab24db66abd7c6828bea92fd0f6dff2d7ba" translate="yes" xml:space="preserve">
          <source>This command creates the following &lt;code&gt;UserService&lt;/code&gt; skeleton:</source>
          <target state="translated">이 명령은 다음 &lt;code&gt;UserService&lt;/code&gt; 스켈레톤을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="53ca835c29b278849f8cc8fdbc5ec1ec43128a05" translate="yes" xml:space="preserve">
          <source>This command updates both &lt;code&gt;@angular/material&lt;/code&gt; and its dependency &lt;code&gt;@angular/cdk&lt;/code&gt; in your workspace's &lt;code&gt;package.json&lt;/code&gt;. If either package contains an update schematic that covers migration from the existing version to a new version, the command runs that schematic on your workspace.</source>
          <target state="translated">이 명령 은 작업 공간의 &lt;code&gt;package.json&lt;/code&gt; 에서 &lt;code&gt;@angular/material&lt;/code&gt; 및 해당 종속성 &lt;code&gt;@angular/cdk&lt;/code&gt; 를 모두 업데이트합니다 . 패키지 중 하나에 기존 버전에서 새 버전으로의 마이그레이션을 다루는 업데이트 회로도가 포함되어 있으면 명령이 작업 공간에서 해당 회로도를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="d476387d6c2e84ce2ff55faed0c0f68d60302141" translate="yes" xml:space="preserve">
          <source>This command updates your project's &lt;code&gt;package.json&lt;/code&gt; and &lt;code&gt;polyfills.ts&lt;/code&gt; files to import the &lt;code&gt;@angular/localize&lt;/code&gt; package.</source>
          <target state="translated">이 명령어는 프로젝트의 &lt;code&gt;package.json&lt;/code&gt; 및 &lt;code&gt;polyfills.ts&lt;/code&gt; 파일을 업데이트하여 &lt;code&gt;@angular/localize&lt;/code&gt; 패키지 를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="5f08f688b42cedaf1c2687380db97e840fa25cee" translate="yes" xml:space="preserve">
          <source>This completes the cross validation example. We managed to:</source>
          <target state="translated">이것으로 교차 검증 예를 완성합니다. 우리는 다음을 관리했습니다.</target>
        </trans-unit>
        <trans-unit id="5c82d5954347561c2d21641e18971743651dd806" translate="yes" xml:space="preserve">
          <source>This component and its tree of child components receive &lt;code&gt;DateLoggerService&lt;/code&gt; instance. Components outside the tree continue to receive the original &lt;code&gt;LoggerService&lt;/code&gt; instance.</source>
          <target state="translated">이 구성 요소와 해당 하위 구성 요소 &lt;code&gt;DateLoggerService&lt;/code&gt; 인스턴스를 받습니다 . 트리 외부의 구성 요소는 계속 원래 &lt;code&gt;LoggerService&lt;/code&gt; 인스턴스 를받습니다 .</target>
        </trans-unit>
        <trans-unit id="597e9233caedd83ac990f5386a4ce276f54df4c0" translate="yes" xml:space="preserve">
          <source>This component class has no dependencies. To test a service with no dependencies, you create it with &lt;code&gt;new&lt;/code&gt;, poke at its API, and assert expectations on its public state. Do the same with the component class.</source>
          <target state="translated">이 컴포넌트 클래스는 종속성이 없습니다. 종속성이없는 서비스를 테스트하려면 &lt;code&gt;new&lt;/code&gt; 로 서비스를 작성 하고 API를 찌르고 공개 상태에 대한 기대를 주장하십시오. 컴포넌트 클래스와 동일하게 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c6c28a7b4cc8e7fda5755e8855df5f2f683d4200" translate="yes" xml:space="preserve">
          <source>This component class has no dependencies. To test these types of classes, follow the same steps as you would for a service that has no dependencies:</source>
          <target state="translated">이 구성 요소 클래스에는 종속성이 없습니다. 이러한 유형의 클래스를 테스트하려면 종속성이없는 서비스와 동일한 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="065a8c2a12fca59785e66b9536ad7a4d7503a70d" translate="yes" xml:space="preserve">
          <source>This component instance.</source>
          <target state="translated">이 구성 요소 인스턴스</target>
        </trans-unit>
        <trans-unit id="a07464de42a69a73871d1c32b4cddf78f4a39cff" translate="yes" xml:space="preserve">
          <source>This component's &lt;code&gt;doSomething()&lt;/code&gt; method update's the component's data-bound &lt;code&gt;comment&lt;/code&gt; property immediately. There's no &lt;a href=&quot;lifecycle-hooks#wait-a-tick&quot;&gt;need to wait&lt;/a&gt;.</source>
          <target state="translated">이 컴포넌트의 &lt;code&gt;doSomething()&lt;/code&gt; 메소드 업데이트는 컴포넌트의 데이터 바인딩 된 &lt;code&gt;comment&lt;/code&gt; 특성을 즉시 업데이트 합니다. &lt;a href=&quot;lifecycle-hooks#wait-a-tick&quot;&gt;기다릴 필요가&lt;/a&gt; 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d24274c6577dbd524765b9a3853f26d6cf76951e" translate="yes" xml:space="preserve">
          <source>This component's &lt;code&gt;doSomething()&lt;/code&gt; method updates the component's data-bound &lt;code&gt;comment&lt;/code&gt; property immediately. There's no need to &lt;a href=&quot;lifecycle-hooks#wait-a-tick&quot;&gt;delay the update to ensure proper rendering&lt;/a&gt;.</source>
          <target state="translated">이 구성 요소의 &lt;code&gt;doSomething()&lt;/code&gt; 메서드는 구성 요소의 데이터 바인딩 된 &lt;code&gt;comment&lt;/code&gt; 속성을 즉시 업데이트합니다 . &lt;a href=&quot;lifecycle-hooks#wait-a-tick&quot;&gt;적절한 렌더링을 보장하기 위해 업데이트를 지연&lt;/a&gt; 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8831291497a6d0587b26b1c8ca5ca8dbd14f9441" translate="yes" xml:space="preserve">
          <source>This component's injector lookup tokens. Includes the component itself plus the tokens that the component lists in its &lt;code&gt;providers&lt;/code&gt; metadata.</source>
          <target state="translated">이 컴포넌트의 인젝터 조회 토큰. 구성 요소 자체와 구성 요소가 &lt;code&gt;providers&lt;/code&gt; 메타 데이터에 나열하는 토큰을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="7b0506327a430462426c6e68b6e09fd639e04c8d" translate="yes" xml:space="preserve">
          <source>This concludes the &quot;Tour of Heroes&quot; tutorial. You're ready to learn more about Angular development in the fundamentals section, starting with the &lt;a href=&quot;../guide/architecture&quot;&gt;Architecture&lt;/a&gt; guide.</source>
          <target state="translated">이것으로 &quot;Tour of Heroes&quot;튜토리얼을 마칩니다. &lt;a href=&quot;../guide/architecture&quot;&gt;아키텍처&lt;/a&gt; 가이드 부터 시작하여 기본 사항 섹션에서 각도 개발에 대해 자세히 배울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e37d0d91df8ad47c0dbbb5e123254e61fce1c600" translate="yes" xml:space="preserve">
          <source>This configuration caches &lt;code&gt;node_modules/&lt;/code&gt; and uses &lt;a href=&quot;https://docs.npmjs.com/cli/run-script&quot;&gt;&lt;code&gt;npm run&lt;/code&gt;&lt;/a&gt; to run CLI commands, because &lt;code&gt;@angular/cli&lt;/code&gt; is not installed globally. The double dash (&lt;code&gt;--&lt;/code&gt;) is needed to pass arguments into the &lt;code&gt;npm&lt;/code&gt; script.</source>
          <target state="translated">&lt;code&gt;@angular/cli&lt;/code&gt; 가 전체적으로 설치되지 않기 때문에이 구성은 &lt;code&gt;node_modules/&lt;/code&gt; 캐시 하고 &lt;a href=&quot;https://docs.npmjs.com/cli/run-script&quot;&gt; &lt;code&gt;npm run&lt;/code&gt; &lt;/a&gt; 을 사용 하여 CLI 명령을 실행합니다 . 인수를 &lt;code&gt;npm&lt;/code&gt; 스크립트 에 전달하려면 이중 대시 ( &lt;code&gt;--&lt;/code&gt; )가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="1b488b5be2952d75c23fd56a333c827a2b7d402f" translate="yes" xml:space="preserve">
          <source>This configures the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; preloader to immediately load all lazy loaded routes (routes with a &lt;code&gt;loadChildren&lt;/code&gt; property).</source>
          <target state="translated">이렇게 하면 지연로드 된 모든 경로 ( &lt;code&gt;loadChildren&lt;/code&gt; 속성 이있는 경로)를 즉시로드 하도록 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 프리 로더가 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="40d0adebce1666f54fd687822290b1370ce51244" translate="yes" xml:space="preserve">
          <source>This cookbook contains recipes for common component communication scenarios in which two or more components share information.</source>
          <target state="translated">이 쿡북에는 둘 이상의 구성 요소가 정보를 공유하는 일반적인 구성 요소 통신 시나리오를위한 레시피가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a322972c7d99a3ec23cfc786253fdee6e876e02e" translate="yes" xml:space="preserve">
          <source>This cookbook describes the steps required to set up and use Angular app files in Visual Studio 2015 within an ASP.NET 4.x project.</source>
          <target state="translated">이 쿡북은 ASP.NET 4.x 프로젝트 내에서 Visual Studio 2015에서 Angular 앱 파일을 설정하고 사용하는 데 필요한 단계를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="81fab89603358b3015fbab03f643f5619e9e7e16" translate="yes" xml:space="preserve">
          <source>This cookbook shows you how to use &lt;code&gt;&lt;a href=&quot;../api/core/componentfactoryresolver&quot;&gt;ComponentFactoryResolver&lt;/a&gt;&lt;/code&gt; to add components dynamically.</source>
          <target state="translated">이 요리 책은 &lt;code&gt;&lt;a href=&quot;../api/core/componentfactoryresolver&quot;&gt;ComponentFactoryResolver&lt;/a&gt;&lt;/code&gt; 를 사용하여 컴포넌트 를 동적으로 추가 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="e813c2193e41174a6e571245c4cd3c17e5e9558e" translate="yes" xml:space="preserve">
          <source>This cookbook shows you how to use &lt;code&gt;formGroup&lt;/code&gt; to dynamically render a simple form with different control types and validation. It's a primitive start. It might evolve to support a much richer variety of questions, more graceful rendering, and superior user experience. All such greatness has humble beginnings.</source>
          <target state="translated">이 요리 책은 &lt;code&gt;formGroup&lt;/code&gt; 을 사용 하여 다른 제어 유형 및 유효성 검증 을 사용 하여 간단한 양식을 동적으로 렌더링하는 방법을 보여줍니다 . 기본 시작입니다. 훨씬 더 다양한 질문,보다 우아한 렌더링 및 우수한 사용자 경험을 지원하도록 발전 할 수 있습니다. 그러한 위대함은 겸손하게 시작되었습니다.</target>
        </trans-unit>
        <trans-unit id="d822107036c9c9bdc81f05621421ed35206b48fe" translate="yes" xml:space="preserve">
          <source>This cookbook uses &lt;a href=&quot;reactive-forms&quot;&gt;reactive forms&lt;/a&gt;.</source>
          <target state="translated">이 요리 책은 &lt;a href=&quot;reactive-forms&quot;&gt;반응 형을&lt;/a&gt; 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="d23601ec63a90736809116d022f4fadccabb0fbd" translate="yes" xml:space="preserve">
          <source>This cookbook uses the &lt;code&gt;Empty&lt;/code&gt; template with no added folders, no authentication, and no hosting. Pick the template and options appropriate for your project.</source>
          <target state="translated">이 요리 책은 폴더 추가, 인증 및 호스팅이없는 &lt;code&gt;Empty&lt;/code&gt; 템플릿을 사용합니다 . 프로젝트에 적합한 템플릿과 옵션을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="b56c91898d64379544ac2ea2325b00bc842db730" translate="yes" xml:space="preserve">
          <source>This creates a &lt;code&gt;customers&lt;/code&gt; folder having the new lazy-loadable feature module &lt;code&gt;CustomersModule&lt;/code&gt; defined in the &lt;code&gt;customers.module.ts&lt;/code&gt; file and the routing module &lt;code&gt;CustomersRoutingModule&lt;/code&gt; defined in the &lt;code&gt;customers-routing.module.ts&lt;/code&gt; file. The command automatically declares the &lt;code&gt;CustomersComponent&lt;/code&gt; and imports &lt;code&gt;CustomersRoutingModule&lt;/code&gt; inside the new feature module.</source>
          <target state="translated">이렇게하면 &lt;code&gt;customers.module.ts&lt;/code&gt; 파일에 정의 된 새로운 지연로드 기능 모듈 &lt;code&gt;CustomersModule&lt;/code&gt; 과 &lt;code&gt;customers-routing.module.ts&lt;/code&gt; 파일에 정의 된 라우팅 모듈 &lt;code&gt;CustomersRoutingModule&lt;/code&gt; 이있는 &lt;code&gt;customers&lt;/code&gt; 폴더가 생성 됩니다. 이 명령은 자동으로 선언 &lt;code&gt;CustomersComponent&lt;/code&gt; 수입 &lt;code&gt;CustomersRoutingModule&lt;/code&gt; 새로운 기능 모듈 내부.</target>
        </trans-unit>
        <trans-unit id="a651647f94c034ce66b15f4ab627c4ac2e28535c" translate="yes" xml:space="preserve">
          <source>This creates a &lt;code&gt;customers&lt;/code&gt; folder with the new lazy-loadable module &lt;code&gt;CustomersModule&lt;/code&gt; defined in the file &lt;code&gt;customers.module.ts&lt;/code&gt;. The command automatically adds the &lt;code&gt;CustomerComponent&lt;/code&gt; to the new feature module.</source>
          <target state="translated">이것은 만들어 &lt;code&gt;customers&lt;/code&gt; 새로운 게으른로드 가능한 모듈과 폴더 &lt;code&gt;CustomersModule&lt;/code&gt; 파일에 정의 &lt;code&gt;customers.module.ts&lt;/code&gt; . 이 명령은 &lt;code&gt;CustomerComponent&lt;/code&gt; 를 새 기능 모듈에 자동으로 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="14b67ee4f93cd53fc641ba3366b0aa1e81714ab4" translate="yes" xml:space="preserve">
          <source>This creates a new folder called &lt;code&gt;orders&lt;/code&gt; containing an &lt;code&gt;OrdersModule&lt;/code&gt; and &lt;code&gt;OrdersRoutingModule&lt;/code&gt;, along with the new &lt;code&gt;OrderComponent&lt;/code&gt; source files. The &lt;code&gt;order-list&lt;/code&gt; route is added to the &lt;code&gt;&lt;a href=&quot;../api/router/routes&quot;&gt;Routes&lt;/a&gt;&lt;/code&gt; array in &lt;code&gt;app-routing.module.ts&lt;/code&gt;, using the lazy-loading syntax.</source>
          <target state="translated">그러면 새 &lt;code&gt;OrderComponent&lt;/code&gt; 소스 파일 과 함께 &lt;code&gt;OrdersModule&lt;/code&gt; 및 &lt;code&gt;OrdersRoutingModule&lt;/code&gt; 을 포함하는 &lt;code&gt;orders&lt;/code&gt; 라는 새 폴더가 생성 됩니다. &lt;code&gt;order-list&lt;/code&gt; 경로가 추가된다 &lt;code&gt;&lt;a href=&quot;../api/router/routes&quot;&gt;Routes&lt;/a&gt;&lt;/code&gt; 에 배열 &lt;code&gt;app-routing.module.ts&lt;/code&gt; 게으른 로딩 구문을 사용.</target>
        </trans-unit>
        <trans-unit id="12212d34d2986bacb58c68284883a32c3bce8fdb" translate="yes" xml:space="preserve">
          <source>This creates a new folder called &lt;code&gt;orders&lt;/code&gt; containing the &lt;code&gt;OrdersModule&lt;/code&gt; and &lt;code&gt;OrdersRoutingModule&lt;/code&gt;, along with the new &lt;code&gt;OrdersComponent&lt;/code&gt; source files. The &lt;code&gt;orders&lt;/code&gt; route, specified with the &lt;code&gt;--route&lt;/code&gt; option, is added to the &lt;code&gt;routes&lt;/code&gt; array inside the &lt;code&gt;app-routing.module.ts&lt;/code&gt; file, using the lazy-loading syntax.</source>
          <target state="translated">그러면 새로운 &lt;code&gt;OrdersComponent&lt;/code&gt; 소스 파일 과 함께 &lt;code&gt;OrdersModule&lt;/code&gt; 및 &lt;code&gt;OrdersRoutingModule&lt;/code&gt; 이 포함 된 &lt;code&gt;orders&lt;/code&gt; 라는 새 폴더가 생성 됩니다. &lt;code&gt;orders&lt;/code&gt; 으로 지정된 경로, &lt;code&gt;--route&lt;/code&gt; 옵션은 추가됩니다 &lt;code&gt;routes&lt;/code&gt; 내부 배열 &lt;code&gt;app-routing.module.ts&lt;/code&gt; 게으른 로딩 구문을 사용하여 파일.</target>
        </trans-unit>
        <trans-unit id="a0adbda48788d27b45342d5c21c7e2786033726c" translate="yes" xml:space="preserve">
          <source>This creates a separate file named &lt;code&gt;my-module-routing.module.ts&lt;/code&gt; to store the NgModule's routes. The file includes an empty &lt;code&gt;&lt;a href=&quot;../api/router/routes&quot;&gt;Routes&lt;/a&gt;&lt;/code&gt; object that you can fill with routes to different components and NgModules.</source>
          <target state="translated">이것은 NgModule의 경로를 저장하기 위해 &lt;code&gt;my-module-routing.module.ts&lt;/code&gt; 라는 별도의 파일을 만듭니다 . 파일에는 다른 구성 요소 및 NgModules에 대한 경로를 채울 수 있는 빈 &lt;code&gt;&lt;a href=&quot;../api/router/routes&quot;&gt;Routes&lt;/a&gt;&lt;/code&gt; 객체가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e0fcef7f7df8d4e453466c52facdaf940fe0d0a" translate="yes" xml:space="preserve">
          <source>This creates an app called &lt;code&gt;customer-app&lt;/code&gt; and the &lt;code&gt;--routing&lt;/code&gt; flag generates a file called &lt;code&gt;app-routing.module.ts&lt;/code&gt;, which is one of the files you need for setting up lazy loading for your feature module. Navigate into the project by issuing the command &lt;code&gt;cd customer-app&lt;/code&gt;.</source>
          <target state="translated">이 응용 프로그램이라고 만들어 &lt;code&gt;customer-app&lt;/code&gt; 하고 &lt;code&gt;--routing&lt;/code&gt; 플래그라는 파일이 생성 &lt;code&gt;app-routing.module.ts&lt;/code&gt; 당신이 당신의 기능 모듈에 대한 지연로드를 설정에 필요한 파일 중 하나입니다. &lt;code&gt;cd customer-app&lt;/code&gt; 명령을 실행하여 프로젝트를 탐색하십시오 .</target>
        </trans-unit>
        <trans-unit id="0198faa84961169c4d04809b0185acf9e3ac22b4" translate="yes" xml:space="preserve">
          <source>This creates the &lt;code&gt;projects/my-lib&lt;/code&gt; folder in your workspace, which contains a component and a service inside an NgModule. The workspace configuration file, &lt;code&gt;angular.json&lt;/code&gt;, is updated with a project of type 'library'.</source>
          <target state="translated">그러면 NgModule 내부에 컴포넌트와 서비스가 포함 된 &lt;code&gt;projects/my-lib&lt;/code&gt; 폴더가 작업 공간에 작성됩니다. 작업 공간 구성 파일 &lt;code&gt;angular.json&lt;/code&gt; 은 'library'유형의 프로젝트로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="742c3e2e58b8f0be6640dfb54f738b9a9e7625e7" translate="yes" xml:space="preserve">
          <source>This declares that the input property &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; of the &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; directive should be treated as a guard to the use of its template, implying that the template will only be instantiated if the &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; input property is true.</source>
          <target state="translated">이는 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 지시문 의 입력 속성 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 가 템플릿 사용에 대한 보호로 취급되어야한다고 선언하며, &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 입력 속성이 true 인 경우에만 템플릿이 인스턴스화됨을 암시 합니다.</target>
        </trans-unit>
        <trans-unit id="048e83daee9abd14678f6339d9376992f4af52ee" translate="yes" xml:space="preserve">
          <source>This default behavior is suitable for a typical &quot;multi-repo&quot; development style where each application resides in its own workspace. Beginners and intermediate users are encouraged to use &lt;code&gt;ng new&lt;/code&gt; to create a separate workspace for each application.</source>
          <target state="translated">이 기본 동작은 각 응용 프로그램이 자체 작업 영역에있는 일반적인 &quot;다중 리포지토리&quot;개발 스타일에 적합합니다. 초보자와 중급 사용자는 &lt;code&gt;ng new&lt;/code&gt; 를 사용하여 각 응용 프로그램에 대해 별도의 작업 영역을 만드는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6587344c6ac0fb7a73ec81835299d2d7ce729572" translate="yes" xml:space="preserve">
          <source>This demo does neither. Instead, it asks the user to make that choice explicitly in a confirmation dialog box that &lt;em&gt;waits asynchronously for the user's answer&lt;/em&gt;.</source>
          <target state="translated">이 데모도 마찬가지입니다. 대신, &lt;em&gt;사용자의 답변을 비동기 적으로 기다리는&lt;/em&gt; 확인 대화 상자에서 명시 적으로 선택하도록 요청합니다 .</target>
        </trans-unit>
        <trans-unit id="87db080ed00574e5e5d7d6687a8530849c3aceb8" translate="yes" xml:space="preserve">
          <source>This demo uses dummy data for &lt;code&gt;model&lt;/code&gt; and &lt;code&gt;powers&lt;/code&gt;. In a real app, you would inject a data service to get and save real data, or expose these properties as inputs and outputs.</source>
          <target state="translated">이 데모는 &lt;code&gt;model&lt;/code&gt; 및 &lt;code&gt;powers&lt;/code&gt; 더미 데이터를 사용합니다 . 실제 앱에서는 데이터 서비스를 주입하여 실제 데이터를 가져와 저장하거나 이러한 속성을 입력 및 출력으로 노출합니다.</target>
        </trans-unit>
        <trans-unit id="6b5876f473d01141acbb800a8ab479df9db1837f" translate="yes" xml:space="preserve">
          <source>This directive accepts an existing &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; instance. It will then use this &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; instance to match any child &lt;code&gt;&lt;a href=&quot;formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; instances to child &lt;code&gt;&lt;a href=&quot;formcontrolname&quot;&gt;FormControlName&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;formgroupname&quot;&gt;FormGroupName&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;formarrayname&quot;&gt;FormArrayName&lt;/a&gt;&lt;/code&gt; directives.</source>
          <target state="translated">이 지시문은 기존 &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 인스턴스를 허용 합니다. 그런 다음이 &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 인스턴스를 사용 하여 하위 &lt;code&gt;&lt;a href=&quot;formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; 인스턴스를 하위 &lt;code&gt;&lt;a href=&quot;formcontrolname&quot;&gt;FormControlName&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;formgroupname&quot;&gt;FormGroupName&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;formarrayname&quot;&gt;FormArrayName&lt;/a&gt;&lt;/code&gt; 지시문 과 일치시킵니다 .</target>
        </trans-unit>
        <trans-unit id="a7989fce38212429c7062b9c5da6235e1e43e7a8" translate="yes" xml:space="preserve">
          <source>This directive can only be used as a child of &lt;code&gt;&lt;a href=&quot;ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; (within &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tags).</source>
          <target state="translated">이 지시문은 &lt;code&gt;&lt;a href=&quot;ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; 의 하위 항목으로 만 사용할 수 있습니다 ( &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 태그 내).</target>
        </trans-unit>
        <trans-unit id="251b666c976f4261c91fe4beed08cf42cce8548f" translate="yes" xml:space="preserve">
          <source>This directive can only be used with a parent &lt;code&gt;&lt;a href=&quot;formgroupdirective&quot;&gt;FormGroupDirective&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 지시문은 부모 &lt;code&gt;&lt;a href=&quot;formgroupdirective&quot;&gt;FormGroupDirective&lt;/a&gt;&lt;/code&gt; 와 함께 만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e18d93c8deadcb10dbc3f3516c1984ce080db614" translate="yes" xml:space="preserve">
          <source>This directive is designed to be used with a parent &lt;code&gt;&lt;a href=&quot;formgroupdirective&quot;&gt;FormGroupDirective&lt;/a&gt;&lt;/code&gt; (selector: &lt;code&gt;[formGroup]&lt;/code&gt;).</source>
          <target state="translated">이 지시문은 부모 &lt;code&gt;&lt;a href=&quot;formgroupdirective&quot;&gt;FormGroupDirective&lt;/a&gt;&lt;/code&gt; (선택기 : &lt;code&gt;[formGroup]&lt;/code&gt; ) 와 함께 사용하도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="8ac905b9010d53abe6967453b6081cf348d35f38" translate="yes" xml:space="preserve">
          <source>This directive is solely used to display warnings when the deprecated &lt;code&gt;&lt;a href=&quot;forms/ngform&quot;&gt;ngForm&lt;/a&gt;&lt;/code&gt; selector is used.</source>
          <target state="translated">이 지시문은 더 이상 사용되지 않는 &lt;code&gt;&lt;a href=&quot;forms/ngform&quot;&gt;ngForm&lt;/a&gt;&lt;/code&gt; 선택기를 사용할 때 경고를 표시하는 데만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b316720613e231db957c48b5c531a72244e235ef" translate="yes" xml:space="preserve">
          <source>This directive is solely used to display warnings when the deprecated &lt;code&gt;&lt;a href=&quot;ngform&quot;&gt;ngForm&lt;/a&gt;&lt;/code&gt; selector is used.</source>
          <target state="translated">이 지시문은 더 이상 사용되지 않는 &lt;code&gt;&lt;a href=&quot;ngform&quot;&gt;ngForm&lt;/a&gt;&lt;/code&gt; 선택기를 사용할 때 경고를 표시하는 데만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cf3a222ca96206b5b9edc9d51a79dbc263b73654" translate="yes" xml:space="preserve">
          <source>This directive is used by itself or as part of a larger form. Use the &lt;code&gt;&lt;a href=&quot;ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; selector to activate it.</source>
          <target state="translated">이 지시문은 단독으로 또는 더 큰 양식의 일부로 사용됩니다. &lt;code&gt;&lt;a href=&quot;ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 선택기를 사용하여 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="079bfc81b016d5fdb9440e147c8f59ceacfd53ed" translate="yes" xml:space="preserve">
          <source>This directive lets you add a CSS class to an element when the link's route becomes active.</source>
          <target state="translated">이 지시문을 사용하면 링크의 경로가 활성화 될 때 CSS 클래스를 요소에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75bdf4a08a98952e88ab0d9d8d3f69ffb18f7db5" translate="yes" xml:space="preserve">
          <source>This document contains information and resources to help you keep your Angular apps and libraries up-to-date.</source>
          <target state="translated">이 문서에는 Angular 앱과 라이브러리를 최신 상태로 유지하는 데 도움이되는 정보와 리소스가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c3c465a1a031a3ba31db55cb2026597de7378a1" translate="yes" xml:space="preserve">
          <source>This document contains the practices that we follow to provide you with a leading-edge app development platform, balanced with stability. We strive to ensure that future changes are always introduced in a predictable way. We want everyone who depends on Angular to know when and how new features are added, and to be well-prepared when obsolete ones are removed.</source>
          <target state="translated">이 문서에는 안정성과 균형 잡힌 최첨단 앱 개발 플랫폼을 제공하기 위해 따르는 관행이 포함되어 있습니다. 우리는 미래의 변화가 항상 예측 가능한 방식으로 도입되도록 노력합니다. 우리는 Angular에 의존하는 모든 사람들이 언제 그리고 어떻게 새로운 기능이 추가되는지 알고, 더 이상 사용되지 않는 기능이 제거되면 잘 준비되기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="5bc557b45ba44abe0921a0e64654f12154157a7c" translate="yes" xml:space="preserve">
          <source>This document explains how CLI builders integrate with the workspace configuration file, and shows how you can create your own builder.</source>
          <target state="translated">이 문서는 CLI 빌더가 작업 공간 구성 파일과 통합하는 방법을 설명하고 고유 한 빌더를 작성하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a18d52460187370aee9da7ba825b392cfeb2488a" translate="yes" xml:space="preserve">
          <source>This document explains how to enable Angular service worker support in projects that you created with the &lt;a href=&quot;cli&quot;&gt;Angular CLI&lt;/a&gt;. It then uses a simple example to show you a service worker in action, demonstrating loading and basic caching.</source>
          <target state="translated">이 문서는 &lt;a href=&quot;cli&quot;&gt;Angular CLI로&lt;/a&gt; 생성 한 프로젝트에서 Angular 서비스 워커 지원을 활성화하는 방법을 설명합니다 . 그런 다음 간단한 예제를 사용하여로드 및 기본 캐싱을 ​​시연하는 서비스 작업자를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="91cf023004b2aaf04380d0ea7e79d9a637aeaec2" translate="yes" xml:space="preserve">
          <source>This document refers to a unit of translatable text as &quot;text,&quot; a &quot;message&quot;, or a &quot;text message.&quot;</source>
          <target state="translated">이 문서는 번역 가능한 텍스트 단위를 &quot;텍스트&quot;, &quot;메시지&quot;또는 &quot;텍스트 메시지&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="f12cdb59b126570dec1c8c00fc1543f0b13ae7d0" translate="yes" xml:space="preserve">
          <source>This does not use the deprecated jsdoc tag on purpose because it renders all overloads as deprecated in TSLint due to &lt;a href=&quot;https://github.com/palantir/tslint/issues/4522&quot;&gt;https://github.com/palantir/tslint/issues/4522&lt;/a&gt;.</source>
          <target state="translated">사용되지 않는 jsdoc 태그는 &lt;a href=&quot;https://github.com/palantir/tslint/issues/4522&quot;&gt;https://github.com/palantir/tslint/issues/4522&lt;/a&gt; 로 인해 TSLint에서 사용되지 않는 모든 과부하를 렌더링하기 때문에 의도적으로 사용되지 않는 jsdoc 태그를 사용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="49942dcd9689b7ed449bd1f739e91d6c6991a659" translate="yes" xml:space="preserve">
          <source>This does the same things as the Circle CI configuration, except that Travis doesn't come with Chrome, so we use Chromium instead.</source>
          <target state="translated">Travis에 Chrome이 포함되어 있지 않다는 점을 제외하면 Circle CI 구성과 동일한 기능을 수행하므로 Chromium을 대신 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e20d0e4a3c8903623d5db93d1eaa42a7319f2bb4" translate="yes" xml:space="preserve">
          <source>This does the same things as the CircleCI configuration, except that Travis doesn't come with Chrome, so use Chromium instead.</source>
          <target state="translated">Travis가 Chrome과 함께 제공되지 않는다는 점을 제외하고 CircleCI 구성과 동일한 작업을 수행하므로 대신 Chromium을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7a173481108f8e08ee23eccdc0ba37f48670a382" translate="yes" xml:space="preserve">
          <source>This duration string specifies the network timeout. The network timeout is how long the Angular service worker will wait for the network to respond before using a cached response, if configured to do so. &lt;code&gt;timeout&lt;/code&gt; is a duration string, using the following unit suffixes:</source>
          <target state="translated">이 기간 문자열은 네트워크 시간 초과를 지정합니다. 네트워크 시간 초과는 캐시 된 응답을 사용하도록 구성된 경우 Angular 서비스 워커가 네트워크가 응답하기를 기다리는 시간입니다. &lt;code&gt;timeout&lt;/code&gt; 는 다음 단위 접미사를 사용하는 기간 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="148a52c96fd5321b2e9f47b1c411e3997ad1ee54" translate="yes" xml:space="preserve">
          <source>This ensures that the build and serve commands can find the configurations for specific build targets.</source>
          <target state="translated">이를 통해 build 및 serve 명령이 특정 빌드 대상의 구성을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd6ef74d3212dfa09ccacfec3ba04d981a0ae6bd" translate="yes" xml:space="preserve">
          <source>This error can occur if you use an expression in the &lt;code&gt;extends&lt;/code&gt; clause of a class.</source>
          <target state="translated">클래스 의 &lt;code&gt;extends&lt;/code&gt; 절 에서 표현식을 사용하는 경우이 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f96ad016e893a674d5f49749d37377695df58a8c" translate="yes" xml:space="preserve">
          <source>This error often means that you haven't declared the directive &quot;x&quot; or haven't imported the NgModule to which &quot;x&quot; belongs.</source>
          <target state="translated">이 오류는 종종 지시문 &quot;x&quot;를 선언하지 않았거나 &quot;x&quot;가 속한 NgModule을 가져 오지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ef4ec03d4ed605a8e9e66585cd5c2453ff07a4af" translate="yes" xml:space="preserve">
          <source>This example adds a few getter methods. In a reactive form, you can always access any form control through the &lt;code&gt;get&lt;/code&gt; method on its parent group, but sometimes it's useful to define getters as shorthands for the template.</source>
          <target state="translated">이 예제는 몇 가지 getter 메소드를 추가합니다. 반응 형 양식에서는 항상 부모 그룹 의 &lt;code&gt;get&lt;/code&gt; 메소드를 통해 모든 양식 컨트롤에 액세스 할 수 있지만 때로는 getter를 템플릿의 속기로 정의하는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="835a254bafaad8e2e761a6f3738065e79183f666" translate="yes" xml:space="preserve">
          <source>This example adds a state transition from the &lt;code&gt;closed&lt;/code&gt; state to the &lt;code&gt;open&lt;/code&gt; state with a 0.5 second transition animation arc.</source>
          <target state="translated">이 예에서는 0.5 초 전환 애니메이션 호 를 사용하여 &lt;code&gt;closed&lt;/code&gt; 상태에서 &lt;code&gt;open&lt;/code&gt; 상태로 상태 전환을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="e27903790bcd6cf8a4d227d598fb3d9c51e485a2" translate="yes" xml:space="preserve">
          <source>This example also adds a few getter methods. In a reactive form, you can always access any form control through the &lt;code&gt;get&lt;/code&gt; method on its parent group, but sometimes it's useful to define getters as shorthand for the template.</source>
          <target state="translated">이 예제는 또한 몇 가지 getter 메소드를 추가합니다. 반응 형에서는 부모 그룹 의 &lt;code&gt;get&lt;/code&gt; 메서드를 통해 항상 모든 양식 컨트롤에 액세스 할 수 있지만, 경우에 따라 템플릿의 약어로 getter를 정의하는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="47a1afa39668210136eb0481e3dfa7dda063e91e" translate="yes" xml:space="preserve">
          <source>This example app asks the user to be explicit with a confirmation dialog box that waits asynchronously for the user's response.</source>
          <target state="translated">이 예제 앱은 사용자의 응답을 비동기 적으로 기다리는 확인 대화 상자를 통해 명시 적으로 사용자에게 요청합니다.</target>
        </trans-unit>
        <trans-unit id="3871ea91cb489329270131828414d4e4a419b07f" translate="yes" xml:space="preserve">
          <source>This example applies the &lt;code&gt;SpyDirective&lt;/code&gt; from the previous example to the &lt;code&gt;CounterComponent&lt;/code&gt; log, in order to watch the creation and destruction of log entries.</source>
          <target state="translated">이 예 에서는 로그 항목의 생성 및 삭제를 감시하기 위해 이전 예의 &lt;code&gt;SpyDirective&lt;/code&gt; 를 &lt;code&gt;CounterComponent&lt;/code&gt; 로그에 적용 합니다.</target>
        </trans-unit>
        <trans-unit id="91b20a46620fed8511ccd3504ac47cc1854c74e2" translate="yes" xml:space="preserve">
          <source>This example applies the &lt;code&gt;SpyDirective&lt;/code&gt; to a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; in an &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt;&lt;em&gt;hero&lt;/em&gt; repeater managed by the parent &lt;code&gt;SpyComponent&lt;/code&gt;.</source>
          <target state="translated">이 예제는 &lt;code&gt;SpyDirective&lt;/code&gt; 를 상위 &lt;code&gt;SpyComponent&lt;/code&gt; 가 관리 하는 &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; &lt;em&gt; hero&lt;/em&gt; repeater 의 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 에 적용합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3dfd88d242d31d74d24a1d273231ff4e8624d83a" translate="yes" xml:space="preserve">
          <source>This example binds a &lt;code&gt;Promise&lt;/code&gt; to the view. Clicking the &lt;code&gt;&lt;a href=&quot;../router/resolve&quot;&gt;Resolve&lt;/a&gt;&lt;/code&gt; button resolves the promise.</source>
          <target state="translated">이 예제는 &lt;code&gt;Promise&lt;/code&gt; 을 뷰에 바인딩합니다 . &lt;code&gt;&lt;a href=&quot;../router/resolve&quot;&gt;Resolve&lt;/a&gt;&lt;/code&gt; 버튼을 클릭하면 약속이 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="76fea2ff263dbc0e5640bda0886d27fd33ac4eb8" translate="yes" xml:space="preserve">
          <source>This example completely replaces the component's &lt;code&gt;providers&lt;/code&gt; array with a new array containing a &lt;code&gt;HeroDetailServiceSpy&lt;/code&gt;.</source>
          <target state="translated">이 예제는 구성 요소의 &lt;code&gt;providers&lt;/code&gt; 배열을 &lt;code&gt;HeroDetailServiceSpy&lt;/code&gt; 가 포함 된 새 배열로 완전히 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="b38e94209799b7cb2ad45b15b4c0f49aebeeaf6c" translate="yes" xml:space="preserve">
          <source>This example features an &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; where a user can enter a value and click a &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; that raises an event. The &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; then relays the data to the parent component.</source>
          <target state="translated">이 예에는 사용자가 값을 입력 하고 이벤트를 발생 시키는 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 을 클릭 할 수 있는 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 이 있습니다 . &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; 는 그 부모 구성 요소로 데이터를 중계한다.</target>
        </trans-unit>
        <trans-unit id="e3900b3c5f734c8b42b0423653ffc07e9a8c5717" translate="yes" xml:space="preserve">
          <source>This example filters the &lt;code&gt;title&lt;/code&gt; property to uppercase.</source>
          <target state="translated">이 예에서는 &lt;code&gt;title&lt;/code&gt; 속성을 대문자로 필터링합니다 .</target>
        </trans-unit>
        <trans-unit id="175ec0e7ef7252b24060674256a084243d66f30a" translate="yes" xml:space="preserve">
          <source>This example from the &lt;code&gt;HeroListComponent&lt;/code&gt; template uses three of these forms.</source>
          <target state="translated">&lt;code&gt;HeroListComponent&lt;/code&gt; 템플릿 의이 예제 는이 형식 중 세 가지를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c018c65b2f71e95da11870a345d0bd8ce8ee7841" translate="yes" xml:space="preserve">
          <source>This example has a special trigger for the enter and leave animation called &lt;code&gt;myInsertRemoveTrigger&lt;/code&gt;. The HTML template contains the following code.</source>
          <target state="translated">이 예제에는 &lt;code&gt;myInsertRemoveTrigger&lt;/code&gt; 라는 들어가기 및 나가기 애니메이션에 대한 특수 트리거가 있습니다. HTML 템플릿에는 다음 코드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c383e4bfd674f8c3ca365e3f2524cda5c7864ed8" translate="yes" xml:space="preserve">
          <source>This example has a temporary diagnostic interpolation after each input tag, &lt;code&gt;{{model.name}}&lt;/code&gt;, to show the current data value of the corresponding property. The note reminds you to remove the diagnostic lines when you have finished observing the two-way data binding at work.</source>
          <target state="translated">이 예제에는 해당 속성의 현재 데이터 값을 표시하기 위해 각 입력 태그 &lt;code&gt;{{model.name}}&lt;/code&gt; 뒤에 임시 진단 보간이 있습니다. 이 메모는 직장에서 양방향 데이터 바인딩 관찰을 마쳤을 때 진단 라인을 제거하도록 상기시킵니다.</target>
        </trans-unit>
        <trans-unit id="48f92247fb3553c5917ea007bd2c3e17c2e4d8ad" translate="yes" xml:space="preserve">
          <source>This example is so simple that it is tempting to write the &lt;code&gt;Http.get()&lt;/code&gt; inside the component itself and skip the service. In practice, however, data access rarely stays this simple. You typically need to post-process the data, add error handling, and maybe some retry logic to cope with intermittent connectivity.</source>
          <target state="translated">이 예제는 너무 단순 해서 컴포넌트 자체 내에 &lt;code&gt;Http.get()&lt;/code&gt; 을 작성 하고 서비스를 건너 뛰고 싶어 합니다. 그러나 실제로는 데이터 액세스가 이러한 단순성을 유지하는 경우는 거의 없습니다. 일반적으로 데이터를 사후 처리하고, 오류 처리를 추가하고, 간헐적 연결에 대처하기 위해 일부 재시도 로직을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7738f3bfb08d1f44b77915ef508354d761db0235" translate="yes" xml:space="preserve">
          <source>This example provides a state transition from &lt;code&gt;open&lt;/code&gt; to &lt;code&gt;closed&lt;/code&gt; with a one second transition between states.</source>
          <target state="translated">이 예에서 상태 천이 제공 &lt;code&gt;open&lt;/code&gt; 에 &lt;code&gt;closed&lt;/code&gt; 상태 사이의 일초와 천이한다.</target>
        </trans-unit>
        <trans-unit id="9e2fbcbc42a2d75d74a3222a5d342beb0a9c1ce0" translate="yes" xml:space="preserve">
          <source>This example recreates the heroes feature in the &quot;Services&quot; episode of the &lt;a href=&quot;../tutorial/toh-pt4&quot;&gt;Tour of Heroes tutorial&lt;/a&gt;, and you'll be copying much of the code from the .</source>
          <target state="translated">이 예제는 &lt;a href=&quot;../tutorial/toh-pt4&quot;&gt;Tour of Heroes 튜토리얼&lt;/a&gt; 의 &quot;Services&quot;에피소드에서 heroes 기능을 다시 작성하며 의 코드를 대부분 복사합니다.</target>
        </trans-unit>
        <trans-unit id="373455b46f233c304aab2070dd6730bb07e917cc" translate="yes" xml:space="preserve">
          <source>This example shows some of the most useful &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; configuration options:</source>
          <target state="translated">이 예는 가장 유용한 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; 구성 옵션 중 일부를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="9700001752d1ddad2bef57a54fdbab31b4d92d72" translate="yes" xml:space="preserve">
          <source>This example wires parent buttons to the child's &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; and uses interpolation to display the child's &lt;code&gt;seconds&lt;/code&gt; property.</source>
          <target state="translated">이 예제에서는 부모 버튼을 자식의 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 하고 보간을 사용하여 자식의 &lt;code&gt;seconds&lt;/code&gt; 속성 을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="7de281f2ca63df5ae46cabdcc5a3f0a47f5d8df0" translate="yes" xml:space="preserve">
          <source>This example&amp;mdash;which displays &lt;strong&gt;&lt;samp&gt;FRIDAY, APRIL 15, 1988&lt;/samp&gt;&lt;/strong&gt;&amp;mdash;chains the same pipes as above, but passes in a parameter to &lt;code&gt;date&lt;/code&gt; as well.</source>
          <target state="translated">이 예 &amp;mdash; 표시 &lt;strong&gt;&lt;samp&gt;1988 년 4 월 15 일 금요일&lt;/samp&gt;&lt;/strong&gt;&amp;mdash; 위와 동일한 파이프를 연결하지만 &lt;code&gt;date&lt;/code&gt; 매개 변수를 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="4820eaf9e83b02c2a47b5745671a9d1f9f915362" translate="yes" xml:space="preserve">
          <source>This examples show how an Object or a Map can be iterated by ngFor with the use of this keyvalue pipe.</source>
          <target state="translated">이 예제는이 키값 파이프를 사용하여 ngFor에서 오브젝트 또는 맵을 반복하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d18607ddf27a24b42e28d94bce4f221af52bab0a" translate="yes" xml:space="preserve">
          <source>This exercise shows how you can respond to a native HTML button-click event by adding to the model data. To let form users add a new hero, you will add a &lt;strong&gt;New Hero&lt;/strong&gt; button that responds to a click event.</source>
          <target state="translated">이 연습에서는 모델 데이터에 추가하여 기본 HTML 버튼 클릭 이벤트에 응답 할 수있는 방법을 보여줍니다. 양식 사용자가 &lt;strong&gt;새 Hero&lt;/strong&gt; 를 추가 할 수 있도록 클릭 이벤트에 응답 하는 &lt;strong&gt;New Hero&lt;/strong&gt; 버튼을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="d13f81c361ce43971a48c424f3851c8dbc4f0ebf" translate="yes" xml:space="preserve">
          <source>This exists to support future Ivy work and has no effect currently.</source>
          <target state="translated">이것은 미래의 아이비 작업을 지원하기 위해 존재하며 현재 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="29df732f2a0c84758770605719258bd4b737a4b9" translate="yes" xml:space="preserve">
          <source>This field contains an array of URLs and &lt;a href=&quot;service-worker-config#glob-patterns&quot;&gt;glob-like&lt;/a&gt; URL patterns that will be matched at runtime. It can contain both negative patterns (i.e. patterns starting with &lt;code&gt;!&lt;/code&gt;) and non-negative patterns and URLs.</source>
          <target state="translated">이 필드에는 런타임에 일치하는 URL 및 &lt;a href=&quot;service-worker-config#glob-patterns&quot;&gt;glob-like&lt;/a&gt; URL 패턴 배열이 포함 됩니다. 음수 패턴 ( &lt;code&gt;!&lt;/code&gt; 로 시작하는 패턴 )과 음이 아닌 패턴 및 URL을 모두 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a65db321c5e9974fc66318e4ba5bcd4b192ba5d" translate="yes" xml:space="preserve">
          <source>This field contains an array of asset groups, each of which defines a set of asset resources and the policy by which they are cached.</source>
          <target state="translated">이 필드에는 자산 그룹 배열이 포함되어 있으며, 각 자산 그룹은 자산 자원 세트와 이들이 캐시하는 정책을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1c59748df0f341098bafef8c91da8de48dc6bd24" translate="yes" xml:space="preserve">
          <source>This field contains an array of data groups, each of which defines a set of data resources and the policy by which they are cached.</source>
          <target state="translated">이 필드에는 데이터 그룹의 배열이 포함되며, 각 그룹은 데이터 리소스 집합과 해당 리소스가 캐시되는 정책을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="db68317d18e90d33c9d724f39c1b4574e3e29e26" translate="yes" xml:space="preserve">
          <source>This field does not need to have a value. Its existence communicates to the Angular type checker that the &lt;code&gt;disabled&lt;/code&gt; input should be considered as accepting bindings that match the type &lt;code&gt;boolean|''&lt;/code&gt;. The suffix should be the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt;&lt;em&gt;field&lt;/em&gt; name.</source>
          <target state="translated">이 필드에는 값이 필요하지 않습니다. 그것의 존재는 Angular 유형 검사기에 &lt;code&gt;disabled&lt;/code&gt; 입력이 &lt;code&gt;boolean|''&lt;/code&gt; 유형과 일치하는 바인딩을 허용하는 것으로 간주되어야 함을 전달합니다 . 접미사는 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; &lt;em&gt; 필드&lt;/em&gt; 이름 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="39dca8bdfadccce3aa32a1f0f34acf9df4dfd38c" translate="yes" xml:space="preserve">
          <source>This file contains imports and functionality that is available to the entire app.</source>
          <target state="translated">이 파일에는 전체 앱에서 사용할 수있는 가져 오기 및 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c09c8b1c3afe0b2f3e211e35dda11d6b49d046a2" translate="yes" xml:space="preserve">
          <source>This file contains options and flags that are essential for Angular applications.</source>
          <target state="translated">이 파일에는 Angular 응용 프로그램에 필수적인 옵션과 플래그가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7774dea1cbb9ba9a9affbe79a52ad87b124f3078" translate="yes" xml:space="preserve">
          <source>This file does the following:</source>
          <target state="translated">이 파일은 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8e6fad8835e771be15a7e60de8d9f839976d92ca" translate="yes" xml:space="preserve">
          <source>This file integrity is especially important when lazy loading modules. A JS bundle may reference many lazy chunks, and the filenames of the lazy chunks are unique to the particular build of the app. If a running app at version &lt;code&gt;X&lt;/code&gt; attempts to load a lazy chunk, but the server has updated to version &lt;code&gt;X + 1&lt;/code&gt; already, the lazy loading operation will fail.</source>
          <target state="translated">이 파일 무결성은 모듈을 느리게로드 할 때 특히 중요합니다. JS 번들은 많은 지연 청크를 참조 할 수 있으며 지연 청크의 파일 이름은 앱의 특정 빌드에 고유합니다. 버전 &lt;code&gt;X&lt;/code&gt; 에서 실행중인 앱 이 지연 청크를로드하려고 시도하지만 서버가 이미 버전 &lt;code&gt;X + 1&lt;/code&gt; 업데이트 된 경우 지연로드 작업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="18dc9ff9208e9157f8adfe6cb8c2bceab30b16aa" translate="yes" xml:space="preserve">
          <source>This first implementation sets the background color of the host element to yellow.</source>
          <target state="translated">이 첫 번째 구현은 호스트 요소의 배경색을 노란색으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e338895d77bf3b3efdf78e1a4135c26e375e5651" translate="yes" xml:space="preserve">
          <source>This form differs from the template-driven version in that it no longer exports any directives. Instead, it uses the &lt;code&gt;name&lt;/code&gt; getter defined in the component class.</source>
          <target state="translated">이 양식은 더 이상 지시문을 내 보내지 않는다는 점에서 템플릿 기반 버전과 다릅니다. 대신 구성 요소 클래스에 정의 된 &lt;code&gt;name&lt;/code&gt; getter를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="fc36f6372162820e0033b4e4ebdc541bbbe324f4" translate="yes" xml:space="preserve">
          <source>This function &lt;em&gt;must&lt;/em&gt; match the form above: an arrow function of the form &lt;code&gt;() =&amp;gt; import('...').then(mod =&amp;gt; mod.MODULE)&lt;/code&gt;.</source>
          <target state="translated">이 기능 &lt;em&gt;해야&lt;/em&gt; 상술 형태 결과 : 폼의 화살표 기능 &lt;code&gt;() =&amp;gt; import('...').then(mod =&amp;gt; mod.MODULE)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4878fd2cfdcaf11685e5e72d2354cd83ec8f9724" translate="yes" xml:space="preserve">
          <source>This function is functionally the same as &lt;a href=&quot;formcontrol#setValue&quot;&gt;setValue&lt;/a&gt; at this level. It exists for symmetry with &lt;a href=&quot;formgroup#patchValue&quot;&gt;patchValue&lt;/a&gt; on &lt;code&gt;FormGroups&lt;/code&gt; and &lt;code&gt;FormArrays&lt;/code&gt;, where it does behave differently.</source>
          <target state="translated">이 기능은 이 수준에서 기능적으로 &lt;a href=&quot;formcontrol#setValue&quot;&gt;setValue&lt;/a&gt; 와 동일 합니다. 그것은과 대칭을 위해 존재 &lt;a href=&quot;formgroup#patchValue&quot;&gt;patchValue&lt;/a&gt; 에 &lt;code&gt;FormGroups&lt;/code&gt; 및 &lt;code&gt;FormArrays&lt;/code&gt; 는 다르게 행동 않습니다.</target>
        </trans-unit>
        <trans-unit id="56d3f264d77db65b5e665e640dd42a9db6e677ef" translate="yes" xml:space="preserve">
          <source>This function returns an &lt;code&gt;&lt;a href=&quot;../../../core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; decorated class that is configured to wire up the Angular and AngularJS injectors without the need to actually bootstrap a hybrid application. This makes it simpler and faster to unit test services.</source>
          <target state="translated">이 함수는 실제로 하이브리드 애플리케이션을 부트 스트랩 할 필요없이 Angular 및 AngularJS 인젝터를 연결하도록 구성된 &lt;code&gt;&lt;a href=&quot;../../../core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 장식 클래스를 리턴합니다 . 따라서 단위 테스트 서비스를보다 간단하고 빠르게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6acc9bce8fe23418fda41554da4f4e2de103857" translate="yes" xml:space="preserve">
          <source>This function returns an AngularJS module that is configured to wire up the AngularJS and Angular injectors without the need to actually bootstrap a hybrid application. This makes it simpler and faster to unit test services.</source>
          <target state="translated">이 함수는 실제로 하이브리드 애플리케이션을 부트 스트랩 할 필요없이 AngularJS 및 Angular 인젝터를 연결하도록 구성된 AngularJS 모듈을 리턴합니다. 따라서 단위 테스트 서비스를보다 간단하고 빠르게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec2de2fde95bef298a51f31a0130f6587e05afec" translate="yes" xml:space="preserve">
          <source>This functionality is only available when you have loaded the full locale data. See the &lt;a href=&quot;../../guide/i18n#i18n-pipes&quot;&gt;&quot;I18n guide&quot;&lt;/a&gt;.</source>
          <target state="translated">이 기능은 전체 로캘 데이터를로드 한 경우에만 사용할 수 있습니다. &lt;a href=&quot;../../guide/i18n#i18n-pipes&quot;&gt;&quot;I18n 안내서&quot;를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="71d1005561ab53d8d9b93d80838e0492d40b9143" translate="yes" xml:space="preserve">
          <source>This general rule can help you build a mental model of attributes and DOM properties: &lt;strong&gt;Attributes initialize DOM properties and then they are done. Property values can change; attribute values can't.&lt;/strong&gt;</source>
          <target state="translated">이 일반 규칙은 속성 및 DOM 속성의 정신 모델을 작성하는 데 도움이됩니다. &lt;strong&gt;속성은 DOM 속성을 초기화 한 다음 완료됩니다. 속성 값은 변경 될 수 있습니다. 속성 값은 할 수 없습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ed51a3d987c448eabd0caaad7d11446c5f4ee98e" translate="yes" xml:space="preserve">
          <source>This generates a folder for the new component within the customer-dashboard folder and updates the feature module with the &lt;code&gt;CustomerDashboardComponent&lt;/code&gt; info:</source>
          <target state="translated">그러면 customer-dashboard 폴더 내에 새 구성 요소의 폴더가 생성되고 &lt;code&gt;CustomerDashboardComponent&lt;/code&gt; 정보로 기능 모듈이 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="a8ca933ae9ed34a8a06321e5395d5386f3467055" translate="yes" xml:space="preserve">
          <source>This gives users a meaningful first paint of your application that appears quickly because the browser can simply render the HTML and CSS without the need to initialize any JavaScript.</source>
          <target state="translated">브라우저는 JavaScript를 초기화 할 필요없이 HTML과 CSS를 간단히 렌더링 할 수 있기 때문에 사용자에게 애플리케이션의 의미있는 첫 번째 페인트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7491170871e6c27e83f7232d07de91c8f51b4dc0" translate="yes" xml:space="preserve">
          <source>This glossary lists the most prominent terms and a few less familiar ones with unusual or unexpected definitions.</source>
          <target state="translated">이 용어집에는 가장 두드러진 용어와 특이하거나 예기치 않은 정의가있는 몇 가지 덜 익숙한 용어가 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdd0dd4255112079ec8cd2cac891a62c3bc630af" translate="yes" xml:space="preserve">
          <source>This guard returns a synchronous boolean result. If the user is logged in, it returns true and the navigation continues.</source>
          <target state="translated">이 가드는 동기식 부울 결과를 반환합니다. 사용자가 로그인 한 경우 true를 반환하고 탐색이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="99832741e09d1b5644ac6acf807f68e045c1d8e4" translate="yes" xml:space="preserve">
          <source>This guide assumes that you have a basic understanding of the following.</source>
          <target state="translated">이 가이드는 사용자가 다음 사항을 기본적으로 이해하고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="71b0a76f127063119253692ead9f31153f3cf61f" translate="yes" xml:space="preserve">
          <source>This guide assumes you are already familiar with developing and building Angular applications using the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;.</source>
          <target state="translated">이 안내서는 &lt;a href=&quot;cli&quot;&gt;CLI를&lt;/a&gt; 사용하여 Angular 응용 프로그램을 개발하고 작성하는 데 이미 익숙하다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="f91f9ca40378a30abae72457a623c7d9b92e26f1" translate="yes" xml:space="preserve">
          <source>This guide contains a summary of all Angular APIs and features that are currently deprecated.</source>
          <target state="translated">이 안내서에는 현재 사용되지 않는 모든 Angular API 및 기능이 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="663987c724bd81899dc1933e4786c728fbe26b01" translate="yes" xml:space="preserve">
          <source>This guide contains information related to updating to the latest version of Angular.</source>
          <target state="translated">이 가이드에는 최신 버전의 Angular로 업데이트하는 것과 관련된 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a03008f3c8f9dc5daf041fcc08d5096f9ec3c5aa" translate="yes" xml:space="preserve">
          <source>This guide covers the basic Angular animation features to get you started on adding Angular animations to your project.</source>
          <target state="translated">이 안내서는 프로젝트에 Angular 애니메이션을 추가하기 시작하는 기본 Angular 애니메이션 기능을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="72e2d1efd7dc0408171b8a02495eccd2a194f9ee" translate="yes" xml:space="preserve">
          <source>This guide covers the router's primary features, illustrating them through the evolution of a small application that you can run live in the browser.</source>
          <target state="translated">이 안내서는 라우터의 주요 기능을 다루며 브라우저에서 실시간으로 실행할 수있는 작은 응용 프로그램의 진화를 통해이를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="16b4b3c7d27b05a7a93d7585fd80da6f87695735" translate="yes" xml:space="preserve">
          <source>This guide demonstrates that scenario with an example in the Tour of Heroes theme. Imagine an outer &lt;code&gt;HeroListComponent&lt;/code&gt; that displays a list of super heroes.</source>
          <target state="translated">이 안내서는 Tour of Heroes 테마의 예제와 함께 해당 시나리오를 보여줍니다. 수퍼 영웅 목록을 표시 하는 외부 &lt;code&gt;HeroListComponent&lt;/code&gt; 를 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="94795f12569496bcae1ed95d5adfb2856a55c12a" translate="yes" xml:space="preserve">
          <source>This guide describes &lt;strong&gt;Angular Universal&lt;/strong&gt;, a technology that renders Angular applications on the server.</source>
          <target state="translated">이 안내서는 &lt;strong&gt;Angular&lt;/strong&gt; 응용 프로그램을 서버에서 렌더링하는 기술인 &lt;strong&gt;Angular Universal에&lt;/strong&gt; 대해 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="7c79df812f600818480fccaad006560ab578d116" translate="yes" xml:space="preserve">
          <source>This guide describes development of a multi-page routed sample application. Along the way, it highlights design decisions and describes key features of the router such as:</source>
          <target state="translated">이 안내서는 다중 페이지 라우트 샘플 응용 프로그램 개발에 대해 설명합니다. 그 과정에서 설계 결정을 강조하고 다음과 같은 라우터의 주요 기능을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="85b1e7320fc65610cb0b9d5744a3924bbc69efbb" translate="yes" xml:space="preserve">
          <source>This guide describes development of a multi-page routed sample application. Along the way, it highlights key features of the router such as:</source>
          <target state="translated">이 가이드에서는 다중 페이지 라우팅 샘플 애플리케이션 개발에 대해 설명합니다. 그 과정에서 다음과 같은 라우터의 주요 기능을 강조합니다.</target>
        </trans-unit>
        <trans-unit id="5eaa5268ab448450e02df4dcd7d854a3b74ebfd4" translate="yes" xml:space="preserve">
          <source>This guide describes how to develop locally on your own machine. Setting up a new project on your machine is quick and easy with the &lt;a href=&quot;https://github.com/angular/quickstart&quot;&gt;QuickStart seed on github&lt;/a&gt;.</source>
          <target state="translated">이 안내서는 자신의 컴퓨터에서 로컬로 개발하는 방법을 설명합니다. &lt;a href=&quot;https://github.com/angular/quickstart&quot;&gt;github&lt;/a&gt; 의 QuickStart 시드를 사용하면 머신에서 새 프로젝트를 쉽고 빠르게 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a071d6040e5b884251f92cb51a3a612a4400f9c1" translate="yes" xml:space="preserve">
          <source>This guide describes some of the built-in tools for efficiently migrating AngularJS projects over to the Angular platform, one piece at a time. It is very similar to &lt;a href=&quot;upgrade&quot;&gt;Upgrading from AngularJS&lt;/a&gt; with the exception that this one uses the &lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule()&lt;/a&gt; helper function instead of the &lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt; class. This affects how the app is bootstrapped and how change detection is propagated between the two frameworks. It allows you to upgrade incrementally while improving the speed of your hybrid apps and leveraging the latest of Angular in AngularJS apps early in the process of upgrading.</source>
          <target state="translated">이 안내서는 AngularJS 프로젝트를 한 번에 하나씩 Angular 플랫폼으로 효율적으로 마이그레이션하기위한 몇 가지 기본 제공 도구를 설명합니다. &lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt; 대신 &lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule ()&lt;/a&gt; 도우미 함수를 사용한다는 점을 제외하면 &lt;a href=&quot;upgrade&quot;&gt;AngularJS&lt;/a&gt; 에서 업그레이드 와 매우 유사 합니다. 클래스 . 이는 앱이 부트 스트랩되는 방식과 두 프레임 워크간에 변경 감지가 전파되는 방식에 영향을줍니다. 하이브리드 앱의 속도를 향상시키고 업그레이드 프로세스 초기에 Angular의 최신 AngularJS 앱을 활용하면서 점진적으로 업그레이드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52f91de3b44e77776bb5d72dda1262736b0f2d6c" translate="yes" xml:space="preserve">
          <source>This guide explains how to build and test Angular apps with Bazel.</source>
          <target state="translated">이 가이드는 Bazel을 사용하여 Angular 앱을 빌드하고 테스트하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a7f2364975bf639296fbad2e6ccfbf1dc9b2ff63" translate="yes" xml:space="preserve">
          <source>This guide explains how to set up your environment for Angular development using the &lt;a href=&quot;cli&quot;&gt;Angular CLI tool&lt;/a&gt;. It includes information about prerequisites, installing the CLI, creating an initial workspace and starter app, and running that app locally to verify your setup.</source>
          <target state="translated">이 안내서는 &lt;a href=&quot;cli&quot;&gt;Angular CLI 도구를&lt;/a&gt; 사용하여 Angular 개발을위한 환경을 설정하는 방법을 설명합니다 . 사전 설치 소프트웨어, CLI 설치, 초기 작업 공간 및 스타터 앱 작성 및 해당 앱을 로컬로 실행하여 설정을 확인하는 데 대한 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4e5dc8be1da9c2744ee3e6ff19277fa157b7049" translate="yes" xml:space="preserve">
          <source>This guide explains how to specify metadata and apply available compiler options to compile your applications efficiently using the AOT compiler.</source>
          <target state="translated">이 안내서는 메타 데이터를 지정하고 사용 가능한 컴파일러 옵션을 적용하여 AOT 컴파일러를 사용하여 애플리케이션을 효율적으로 컴파일하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bde2ceb420303c6bb7fd13502c38aab2782431cb" translate="yes" xml:space="preserve">
          <source>This guide explores common component testing use cases.</source>
          <target state="translated">이 가이드에서는 일반적인 구성 요소 테스트 사용 사례를 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="e8e0ddc6e4a1bac092793252db146528b491a1a7" translate="yes" xml:space="preserve">
          <source>This guide follows that approach. It has a &lt;code&gt;&lt;a href=&quot;../api/common/nglocalelocalization#locale&quot;&gt;locale&lt;/a&gt;&lt;/code&gt; folder under &lt;code&gt;src/&lt;/code&gt;. Assets within that folder have a filename extension that matches their associated locale.</source>
          <target state="translated">이 가이드는 이러한 접근 방식을 따릅니다. 그것은이 &lt;code&gt;&lt;a href=&quot;../api/common/nglocalelocalization#locale&quot;&gt;locale&lt;/a&gt;&lt;/code&gt; 에서 폴더 &lt;code&gt;src/&lt;/code&gt; . 해당 폴더 내의 자산은 파일 이름 확장자가 관련 로케일과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2488b81bee26c1a6b3945e50d5b7209076c7232f" translate="yes" xml:space="preserve">
          <source>This guide goes into greater depth on special transition states such as &lt;code&gt;*&lt;/code&gt; (wildcard) and &lt;code&gt;void&lt;/code&gt;, and show how these special states are used for elements entering and leaving a view. This chapter also explores multiple animation triggers, animation callbacks, and sequence-based animation using keyframes.</source>
          <target state="translated">이 가이드는 &lt;code&gt;*&lt;/code&gt; (와일드 카드) 및 &lt;code&gt;void&lt;/code&gt; 와 같은 특수 전환 상태에 대해 자세히 설명하고 이러한 특수 상태가 뷰에 들어오고 나가는 요소에 어떻게 사용되는지 보여줍니다. 이 장에서는 또한 키 프레임을 사용하는 여러 애니메이션 트리거, 애니메이션 콜백 및 시퀀스 기반 애니메이션을 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="a4fe0eebc6c53dfd8ba7ae172b29d6085d11576f" translate="yes" xml:space="preserve">
          <source>This guide helps you transition from AngularJS to Angular by mapping AngularJS syntax to the equivalent Angular syntax.</source>
          <target state="translated">이 안내서는 AngularJS 구문을 해당 Angular 구문에 매핑하여 AngularJS에서 Angular로 전환하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="8b1d6ce9f824c1b57c26e8b4535de072da1382f6" translate="yes" xml:space="preserve">
          <source>This guide is a &lt;em&gt;living document&lt;/em&gt;; it changes over time. We strive for consistency to the extent feasible, but you may find parts of our documentation that don't match this style guide. When in doubt, &lt;strong&gt;follow this guide rather than imitating existing documents.&lt;/strong&gt;</source>
          <target state="translated">이 안내서는 &lt;em&gt;살아있는 문서입니다&lt;/em&gt; . 시간이 지남에 따라 변경됩니다. 가능한 범위 내에서 일관성을 유지하려고 노력하지만이 스타일 가이드와 일치하지 않는 설명서의 일부를 찾을 수 있습니다. 의심 &lt;strong&gt;스러운 경우 기존 문서를 모방하지 말고이 안내서를 따르십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b86a88184ea70d17effff794189dd4cb85c357f" translate="yes" xml:space="preserve">
          <source>This guide looks at how Angular manipulates the DOM with &lt;strong&gt;structural directives&lt;/strong&gt; and how you can write your own structural directives to do the same thing.</source>
          <target state="translated">이 안내서에서는 Angular가 &lt;strong&gt;구조적 지시문으로&lt;/strong&gt; DOM을 조작하는 방법과 동일한 작업을 수행하기 위해 고유 한 구조적 지시문을 작성할 수있는 방법을 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="593d82739fc5c50f931f13f1ea5af12b64068cec" translate="yes" xml:space="preserve">
          <source>This guide offers tips and techniques for unit and integration testing Angular applications.</source>
          <target state="translated">이 안내서는 각도 응용 프로그램의 단위 및 통합 테스트를위한 팁과 기술을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ef57621e56bb2f75a1048b0c3475daddc587411b" translate="yes" xml:space="preserve">
          <source>This guide proceeds as a sequence of milestones as if you were building the app step-by-step, but assumes you are familiar with basic &lt;a href=&quot;architecture&quot;&gt;Angular concepts&lt;/a&gt;. For a general introduction to angular, see the &lt;a href=&quot;start&quot;&gt;Getting Started&lt;/a&gt;. For a more in-depth overview, see the &lt;a href=&quot;tutorial&quot;&gt;Tour of Heroes&lt;/a&gt; tutorial.</source>
          <target state="translated">이 가이드는 앱을 단계별로 빌드하는 것처럼 일련의 마일스톤으로 진행되지만 기본 &lt;a href=&quot;architecture&quot;&gt;Angular 개념에&lt;/a&gt; 익숙하다고 가정합니다 . 각도에 대한 일반적인 소개는 &lt;a href=&quot;start&quot;&gt;시작하기를&lt;/a&gt; 참조하십시오 . 자세한 개요는 &lt;a href=&quot;tutorial&quot;&gt;Tour of Heroes&lt;/a&gt; 튜토리얼을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c0d6e75bcf91e32b2e66ca76df8b63da387d1f38" translate="yes" xml:space="preserve">
          <source>This guide proceeds in phases, marked by milestones, starting from a simple two-pager and building toward a modular, multi-view design with child routes.</source>
          <target state="translated">이 가이드는 간단한 2 페이지에서 시작하여 하위 경로가 포함 된 모듈 식 멀티 뷰 디자인을 구축하는 단계로 마일스톤으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d3c69f9ce0aa91fc4ff28ea4156ea22eb64b216f" translate="yes" xml:space="preserve">
          <source>This guide provides information to help you decide which type of form works best for your situation. It introduces the common building blocks used by both approaches. It also summarizes the key differences between the two approaches, and demonstrates those differences in the context of setup, data flow, and testing.</source>
          <target state="translated">이 안내서는 상황에 가장 적합한 양식 유형을 결정하는 데 도움이되는 정보를 제공합니다. 두 가지 방법으로 사용되는 공통 빌딩 블록을 소개합니다. 또한 두 가지 접근 방식의 주요 차이점을 요약하고 설정, 데이터 흐름 및 테스트와 관련된 차이점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ff1a4eed9922504491639bfc2f2085934810a731" translate="yes" xml:space="preserve">
          <source>This guide shows you how to use Angular &lt;a href=&quot;../guide/glossary#router&quot;&gt;routing&lt;/a&gt; to give the user in-app navigation. In a single-page app, instead of loading new pages, you show different components and data to the user based on where the user is in the application.</source>
          <target state="translated">이 가이드는 Angular &lt;a href=&quot;../guide/glossary#router&quot;&gt;라우팅&lt;/a&gt; 을 사용하여 사용자에게 앱 내 탐색을 제공하는 방법을 보여줍니다 . 단일 페이지 앱에서는 새 페이지를로드하는 대신 사용자가 애플리케이션에있는 위치에 따라 사용자에게 다른 구성 요소와 데이터를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="5d34585a93f67fec9f496e464bff52a80a3a9cbe" translate="yes" xml:space="preserve">
          <source>This guide uses the StackBlitz Generator to show you a ready-made, simple application that you can examine and play with interactively. In actual development you will typically use the &lt;a href=&quot;guide/glossary#command-line-interface-cli&quot;&gt;Angular CLI&lt;/a&gt;, a powerful command-line tool that lets you generate and modify applications. For more information, see the &lt;a href=&quot;https://angular.io/cli&quot;&gt;CLI Overview&lt;/a&gt;.</source>
          <target state="translated">이 안내서는 StackBlitz Generator를 사용하여 대화식으로 검토하고 사용할 수있는 기성품, 간단한 응용 프로그램을 보여줍니다. 실제 개발에서는 일반적으로 응용 프로그램을 생성하고 수정할 수있는 강력한 명령 줄 도구 인 &lt;a href=&quot;guide/glossary#command-line-interface-cli&quot;&gt;Angular CLI&lt;/a&gt; 를 사용합니다. 자세한 정보는 &lt;a href=&quot;https://angular.io/cli&quot;&gt;CLI 개요를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e586281684b3e248038b701f36893a54ff5a55bc" translate="yes" xml:space="preserve">
          <source>This guide won't repeat how to &lt;em&gt;use&lt;/em&gt; them. But it does explain &lt;em&gt;how they work&lt;/em&gt; and how to &lt;a href=&quot;structural-directives#unless&quot;&gt;write your own&lt;/a&gt; structural directive.</source>
          <target state="translated">이 가이드는 방법을 반복하지 않을 것이다 &lt;em&gt;사용&lt;/em&gt; 을. 그러나 그것은 &lt;em&gt;그들이 어떻게 작동&lt;/em&gt; 하고 어떻게 &lt;a href=&quot;structural-directives#unless&quot;&gt;자신&lt;/a&gt; 을 작성 하는지 설명 &lt;em&gt;합니다&lt;/em&gt; 구조적 지시문 .</target>
        </trans-unit>
        <trans-unit id="e3989ef0ea3239b97b243b6842c7b698d20fb5bb" translate="yes" xml:space="preserve">
          <source>This guide works with a CLI-generated Angular app. If you are working manually, make sure that you have &lt;code&gt;&amp;lt;base href=&quot;/&quot;&amp;gt;&lt;/code&gt; in the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; of your index.html file. This assumes that the &lt;code&gt;app&lt;/code&gt; folder is the application root, and uses &lt;code&gt;&quot;/&quot;&lt;/code&gt;.</source>
          <target state="translated">이 가이드는 CLI 생성 Angular 앱에서 작동합니다. 수동으로 작업하는 경우 index.html 파일 의 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 에 &lt;code&gt;&amp;lt;base href=&quot;/&quot;&amp;gt;&lt;/code&gt; 가 있는지 확인하십시오 . 이것은 &lt;code&gt;app&lt;/code&gt; 폴더가 응용 프로그램 루트이고 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 를 사용 한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="051838d2f6789f70fb2f89d0d3b7b55f2fd66a1e" translate="yes" xml:space="preserve">
          <source>This has been deprecated for a few reasons. First, developers have found this pattern confusing. It seems like the actual &lt;code&gt;&lt;a href=&quot;ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; directive is being used, but in fact it's an input/output property named &lt;code&gt;&lt;a href=&quot;ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; on the reactive form directive that simply approximates (some of) its behavior. Specifically, it allows getting/setting the value and intercepting value events. However, some of &lt;code&gt;&lt;a href=&quot;ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt;'s other features - like delaying updates with&lt;code&gt;ngModelOptions&lt;/code&gt; or exporting the directive - simply don't work, which has understandably caused some confusion.</source>
          <target state="translated">몇 가지 이유로 더 이상 사용되지 않습니다. 먼저, 개발자들은이 패턴이 혼란 스러웠습니다. 실제 &lt;code&gt;&lt;a href=&quot;ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 지시문이 사용되는 것처럼 보이지만 실제로 는 반응 양식 지시문에서 동작의 근사치에 가까운 &lt;code&gt;&lt;a href=&quot;ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 이라는 입력 / 출력 속성 입니다. 특히 값을 가져 오거나 설정하고 값 이벤트를 가로 챌 수 있습니다. 그러나 &lt;code&gt;&lt;a href=&quot;ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; Options로 업데이트 지연 또는 지시문 내보내기 와 같은 ngModel 의 다른 기능 중 일부는 작동하지 않으므로 이해하기 &lt;code&gt;ngModelOptions&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a36abc535f66e5a2a598972e3e540ed77c184f6" translate="yes" xml:space="preserve">
          <source>This has been deprecated for several reasons. First, developers have found this pattern confusing. It seems like the actual &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; directive is being used, but in fact it's an input/output property named &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; on the reactive form directive that approximates some, but not all, of the directive's behavior. It allows getting and setting a value and intercepting value events, but some of &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt;'s other features, such as delaying updates with&lt;code&gt;ngModelOptions&lt;/code&gt; or exporting the directive, don't work.</source>
          <target state="translated">이것은 몇 가지 이유로 더 이상 사용되지 않습니다. 첫째, 개발자는이 패턴이 혼란 스럽다는 것을 알게되었습니다. 실제 &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 지시어가 사용되는 것처럼 보이지만 실제로 는 지시어 동작의 전부는 아니지만 일부에 가까운 반응 형 지시문의 &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 이라는 입력 / 출력 속성 입니다. 그것은 점점하고 값을 설정하고 값 이벤트를 차단 할 수 있지만 일부 &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 등으로 업데이트 지연 등의 다른 기능, &lt;code&gt;ngModelOptions&lt;/code&gt; 또는 지시를 수출은 일을하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb14c528bca95d7e4e8b5c0e75434cfae54a895b" translate="yes" xml:space="preserve">
          <source>This has been deprecated to keep selectors consistent with other core Angular selectors, as element selectors are typically written in kebab-case.</source>
          <target state="translated">요소 선택기는 일반적으로 케밥 케이스로 작성되므로 선택기는 다른 핵심 각도 선택기와 일치하도록 선택되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="753971c71e6ca491908f50d23acb603dc1a664a4" translate="yes" xml:space="preserve">
          <source>This has the same effect as the binding:</source>
          <target state="translated">이것은 바인딩과 동일한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1095f7e1edc68ff18dd9e80137271b101bd86c29" translate="yes" xml:space="preserve">
          <source>This helper class should be used as a base class for creating Angular directives that wrap AngularJS components that need to be &quot;upgraded&quot;.</source>
          <target state="translated">이 헬퍼 클래스는 &quot;업그레이드&quot;되어야하는 AngularJS 구성 요소를 랩핑하는 Angular 지시문을 작성하기위한 기본 클래스로 사용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4a9910a470680f461d5e2a2614c8675ebcbbb9c4" translate="yes" xml:space="preserve">
          <source>This helper function returns a factory function that provides access to the Angular service identified by the &lt;code&gt;token&lt;/code&gt; parameter.</source>
          <target state="translated">이 도우미 함수는 &lt;code&gt;token&lt;/code&gt; 매개 변수로 식별되는 Angular 서비스에 대한 액세스를 제공하는 팩토리 함수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3feef579a17c24eb18bbf65e912c0af25f671bc1" translate="yes" xml:space="preserve">
          <source>This helper function returns a factory function to be used for registering an AngularJS wrapper directive for &quot;downgrading&quot; an Angular component.</source>
          <target state="translated">이 도우미 함수는 Angular 구성 요소를 &quot;다운 그레이드&quot;하기 위해 AngularJS 래퍼 지시문을 등록하는 데 사용되는 팩토리 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="47aa8d05f2d4f3b4a736e0ea1dd586657dd4775e" translate="yes" xml:space="preserve">
          <source>This helper is for testing services not Components. For Component testing you must still bootstrap a hybrid app. See &lt;code&gt;&lt;a href=&quot;../upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="translated">이 도우미는 구성 요소가 아닌 서비스 테스트에 사용됩니다. 구성 요소 테스트의 경우 여전히 하이브리드 앱을 부트 스트랩해야합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;../upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4eef553362f7318dd361d3d0f6a5760f3585a142" translate="yes" xml:space="preserve">
          <source>This helper is for testing services not components. For Component testing you must still bootstrap a hybrid app. See &lt;code&gt;&lt;a href=&quot;../upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="translated">이 도우미는 구성 요소가 아닌 서비스를 테스트하기위한 것입니다. 컴포넌트 테스트의 경우 여전히 하이브리드 앱을 부트 스트랩해야합니다. 자세한 내용은 &lt;code&gt;&lt;a href=&quot;../upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9b9ba1412b83f44b56ecd7943b94f7e6d7ad49fa" translate="yes" xml:space="preserve">
          <source>This helper's observable emits the &lt;code&gt;data&lt;/code&gt; value in the next turn of the JavaScript engine.</source>
          <target state="translated">이 헬퍼의 Observable은 JavaScript 엔진의 다음 차례에 &lt;code&gt;data&lt;/code&gt; 값을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="326ed6100992d8304a4c4512b4ef1b97e697f367" translate="yes" xml:space="preserve">
          <source>This highlight directive has a single customizable property. In a real app, it may need more.</source>
          <target state="translated">이 강조 지시문에는 단일 사용자 정의 가능 특성이 있습니다. 실제 앱에서는 더 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8424043c89606ac692d26ae91eabcf058b3b255" translate="yes" xml:space="preserve">
          <source>This implies that the component bindings will always follow the semantics of the instantiation framework.</source>
          <target state="translated">이는 컴포넌트 바인딩이 항상 인스턴스화 프레임 워크의 시맨틱을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="13526051beab5c2cb1409738f1705df68acfffb7" translate="yes" xml:space="preserve">
          <source>This indicates the last time the service worker checked for a new version, or update, of the app. &lt;code&gt;never&lt;/code&gt; indicates that the service worker has never checked for an update.</source>
          <target state="translated">이는 서비스 워커가 마지막으로 앱의 새 버전 또는 업데이트를 확인한 시간을 나타냅니다. 서비스 직원이 업데이트를 확인한 &lt;code&gt;never&lt;/code&gt; 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c6866fb4d3be58dfa31c9fcb707a31824d7cdb10" translate="yes" xml:space="preserve">
          <source>This initial value never changes.</source>
          <target state="translated">이 초기 값은 변하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8fdbd80f7713591b405acb108f078354e86bdf7e" translate="yes" xml:space="preserve">
          <source>This installs the &lt;code&gt;schematics&lt;/code&gt; executable, which you can use to create a new schematics &lt;a href=&quot;glossary#collection&quot;&gt;collection&lt;/a&gt; with an initial named schematic. The collection folder is a workspace for schematics. You can also use the &lt;code&gt;schematics&lt;/code&gt; command to add a new schematic to an existing collection, or extend an existing schematic.</source>
          <target state="translated">그러면 &lt;code&gt;schematics&lt;/code&gt; 실행 파일 이 설치 되며, 초기 회로도를 사용하여 새 회로도 &lt;a href=&quot;glossary#collection&quot;&gt;컬렉션&lt;/a&gt; 을 만드는 데 사용할 수 있습니다 . 컬렉션 폴더는 회로도를위한 작업 공간입니다. 또한 &lt;code&gt;schematics&lt;/code&gt; 명령을 사용하여 기존 컬렉션에 새 회로도를 추가하거나 기존 회로도를 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4f376c92f4d721a1cb60edfb651e536ba4f5e3e" translate="yes" xml:space="preserve">
          <source>This installs the &lt;code&gt;schematics&lt;/code&gt; executable, which you can use to create a new schematics collection in its own project folder, add a new schematic to an existing collection, or extend an existing schematic.</source>
          <target state="translated">그러면 자체 프로젝트 폴더에 새 회로도 컬렉션을 생성하거나 기존 컬렉션에 새 회로도를 추가하거나 기존 회로도를 확장하는 데 사용할 수 있는 &lt;code&gt;schematics&lt;/code&gt; 실행 파일 이 설치됩니다 .</target>
        </trans-unit>
        <trans-unit id="1b7cb0effa29e839a96dca4c18f240ba5551dbba" translate="yes" xml:space="preserve">
          <source>This installs the command &lt;code&gt;ng&lt;/code&gt; on your system, which is the command you use to create new workspaces, new projects, serve your application during development, or produce builds to share or distribute.</source>
          <target state="translated">이렇게 하면 새 작업 영역, 새 프로젝트를 만들고 개발 중에 애플리케이션을 제공하거나 공유 또는 배포 할 빌드를 생성하는 데 사용 하는 명령 인 &lt;code&gt;ng&lt;/code&gt; 명령이 시스템에 설치됩니다 .</target>
        </trans-unit>
        <trans-unit id="b28a949d24ede3e30d4f2425cea4c004accffb6c" translate="yes" xml:space="preserve">
          <source>This interface allows access to the underlying &lt;code&gt;&lt;a href=&quot;../httprequest&quot;&gt;HttpRequest&lt;/a&gt;&lt;/code&gt;, and allows responding with &lt;code&gt;&lt;a href=&quot;../httpevent&quot;&gt;HttpEvent&lt;/a&gt;&lt;/code&gt;s or &lt;code&gt;&lt;a href=&quot;../httperrorresponse&quot;&gt;HttpErrorResponse&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">이 인터페이스는 기본 &lt;code&gt;&lt;a href=&quot;../httprequest&quot;&gt;HttpRequest&lt;/a&gt;&lt;/code&gt; 에 대한 액세스를 허용하고 &lt;code&gt;&lt;a href=&quot;../httpevent&quot;&gt;HttpEvent&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../httperrorresponse&quot;&gt;HttpErrorResponse&lt;/a&gt;&lt;/code&gt; 로 응답 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f14b1937cf79a6a85c55fe443bf06ded14c39fe9" translate="yes" xml:space="preserve">
          <source>This is a &lt;em&gt;cold&lt;/em&gt; observable that waits three frames and then emits an error, The hash (&lt;code&gt;#&lt;/code&gt;) indicates the timing of the error that is specified in the third argument. The second argument is null because the observable never emits a value.</source>
          <target state="translated">이것은 3 개의 프레임을 기다린 다음 오류를 발생시키는 &lt;em&gt;콜드&lt;/em&gt; 옵저버 블입니다. 해시 ( &lt;code&gt;#&lt;/code&gt; )는 세 번째 인수에 지정된 오류의 타이밍을 나타냅니다. observable이 값을 생성하지 않으므로 두 번째 인수는 null입니다.</target>
        </trans-unit>
        <trans-unit id="325c383689dc505c167a4efdf3ff1bfffcda2dac" translate="yes" xml:space="preserve">
          <source>This is a common middleware pattern found in frameworks such as Express.js.</source>
          <target state="translated">이것은 Express.js와 같은 프레임 워크에서 발견되는 일반적인 미들웨어 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="8a0404a183044b9e9c6ffe40bc631a912f26a05f" translate="yes" xml:space="preserve">
          <source>This is a considerable effort and it often isn't worth it, especially since you are in the process of moving your code to Angular. Instead, declare &lt;code&gt;angular&lt;/code&gt; as &lt;code&gt;angular.IAngularStatic&lt;/code&gt; to indicate it is a global variable and still have full typing support.</source>
          <target state="translated">이것은 상당한 노력이며 특히 코드를 Angular로 옮기는 과정에 있기 때문에 종종 가치가 없습니다. 대신 &lt;code&gt;angular&lt;/code&gt; 를 &lt;code&gt;angular.IAngularStatic&lt;/code&gt; 으로 선언 하여 전역 변수이고 여전히 완전한 타이핑 지원을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ebfc1fc3ae76182d341bfaf13595ca3c04aee718" translate="yes" xml:space="preserve">
          <source>This is a general purpose guard&amp;mdash;you can imagine other features that require authenticated users&amp;mdash;so you generate an &lt;code&gt;AuthGuard&lt;/code&gt; in the &lt;code&gt;auth&lt;/code&gt; folder.</source>
          <target state="translated">당신은 생성이 범용 가드 - 당신이 인증을 필요로하는 다른 기능 상상할 수있는 것입니다 사용자를-있도록 &lt;code&gt;AuthGuard&lt;/code&gt; 에서 &lt;code&gt;auth&lt;/code&gt; 폴더에 있습니다.</target>
        </trans-unit>
        <trans-unit id="745624b6290490997a074676dc013e0ad3433575" translate="yes" xml:space="preserve">
          <source>This is a good candidate for an impure pipe because the &lt;code&gt;transform&lt;/code&gt; function is trivial and fast.</source>
          <target state="translated">&lt;code&gt;transform&lt;/code&gt; 기능이 사소하고 빠르기 때문에 불순한 파이프에 적합합니다 .</target>
        </trans-unit>
        <trans-unit id="5b9b9bda285209856e8b9f18df0fc5414bc4d50e" translate="yes" xml:space="preserve">
          <source>This is a good way to quickly get TypeScript features, such as type checking and autocomplete support, for you custom element. But it can get cumbersome if you need it in several places, because you have to cast the return type on every occurrence.</source>
          <target state="translated">이것은 사용자 정의 요소에 대한 유형 검사 및 자동 완성 지원과 같은 TypeScript 기능을 신속하게 얻는 좋은 방법입니다. 그러나 여러 곳에서 필요한 경우 반환 유형을 캐스팅해야하기 때문에 번거로울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fe29256f1b66a8c5853dd12c474275473bc08da" translate="yes" xml:space="preserve">
          <source>This is a good way to quickly get TypeScript features, such as type checking and autocomplete support, for your custom element. But it can get cumbersome if you need it in several places, because you have to cast the return type on every occurrence.</source>
          <target state="translated">이것은 사용자 정의 요소에 대한 유형 검사 및 자동 완성 지원과 같은 TypeScript 기능을 빠르게 얻을 수있는 좋은 방법입니다. 그러나 여러 곳에서 필요하면 모든 경우에 반환 유형을 캐스팅해야하기 때문에 번거로울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6520fb09eb7f64f65fec620f22a827ad129c5147" translate="yes" xml:space="preserve">
          <source>This is a nonissue in Angular because ES 2015 modules handle the namespacing for you.</source>
          <target state="translated">ES 2015 모듈이 네임 스페이스를 처리하므로 Angular에서는 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b1360d42910235d11c8da57171809f03949b89f4" translate="yes" xml:space="preserve">
          <source>This is a tree of activated route snapshots. Every node in this tree knows about the &quot;consumed&quot; URL segments, the extracted parameters, and the resolved data.</source>
          <target state="translated">이것은 활성화 된 라우트 스냅 샷의 트리입니다. 이 트리의 모든 노드는 &quot;소비 된&quot;URL 세그먼트, 추출 된 매개 변수 및 분석 된 데이터에 대해 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="308f6f1ffa549dea73f1268332bb7efda867f32b" translate="yes" xml:space="preserve">
          <source>This is a typical &quot;&lt;em&gt;service-in-service&lt;/em&gt;&quot; scenario: you inject the &lt;code&gt;MessageService&lt;/code&gt; into the &lt;code&gt;HeroService&lt;/code&gt; which is injected into the &lt;code&gt;HeroesComponent&lt;/code&gt;.</source>
          <target state="translated">이것은 전형적인 &quot;입니다 &lt;em&gt;서비스의 서비스&lt;/em&gt; &quot;시나리오 : 당신을 주입 &lt;code&gt;MessageService&lt;/code&gt; 에 &lt;code&gt;HeroService&lt;/code&gt; 에 주입 &lt;code&gt;HeroesComponent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd1783005dfb776d1af2f04f6577b41eaa1ff956" translate="yes" xml:space="preserve">
          <source>This is a very simple example, but the use of a schema for validation can be very powerful. For more information, see the &lt;a href=&quot;http://json-schema.org/&quot;&gt;JSON schemas website&lt;/a&gt;.</source>
          <target state="translated">이것은 매우 간단한 예이지만 유효성 검사를 위해 스키마를 사용하는 것은 매우 강력 할 수 있습니다. 자세한 정보는 &lt;a href=&quot;http://json-schema.org/&quot;&gt;JSON 스키마 웹 사이트를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="98e22f6dda8c73c831d901b714a07d0b7689f227" translate="yes" xml:space="preserve">
          <source>This is actually a convenience method, implemented as &lt;code&gt;fixture.debugElement.nativeElement&lt;/code&gt;.</source>
          <target state="translated">실제로는 &lt;code&gt;fixture.debugElement.nativeElement&lt;/code&gt; 로 구현 된 편리한 메소드 입니다.</target>
        </trans-unit>
        <trans-unit id="dd436a739a02b80b45abdb0c1ad5a566028baa06" translate="yes" xml:space="preserve">
          <source>This is actually a pretty good starting point. The code uses the AngularJS 1.5 component API and the organization follows the &lt;a href=&quot;https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md&quot;&gt;AngularJS Style Guide&lt;/a&gt;, which is an important &lt;a href=&quot;upgrade#follow-the-angular-styleguide&quot;&gt;preparation step&lt;/a&gt; before a successful upgrade.</source>
          <target state="translated">이것은 실제로 꽤 좋은 출발점입니다. 이 코드는 AngularJS 1.5 구성 요소 API를 사용하며 조직은 &lt;a href=&quot;https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md&quot;&gt;AngularJS 스타일 가이드를&lt;/a&gt; 따르며 , 이는 성공적인 업그레이드 전에 중요한 &lt;a href=&quot;upgrade#follow-the-angular-styleguide&quot;&gt;준비 단계&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b8005693863fa9b16e3799069756d7fed430b5f1" translate="yes" xml:space="preserve">
          <source>This is an example of Angular's &lt;a href=&quot;../guide/event-binding&quot;&gt;event binding&lt;/a&gt; syntax.</source>
          <target state="translated">이것은 Angular의 &lt;a href=&quot;../guide/event-binding&quot;&gt;이벤트 바인딩&lt;/a&gt; 구문 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="28fd6969c6d6369ceb7285ab5a770ea3315ffab8" translate="yes" xml:space="preserve">
          <source>This is an example of Angular's &lt;a href=&quot;../guide/template-syntax#event-binding&quot;&gt;event binding&lt;/a&gt; syntax.</source>
          <target state="translated">이것은 Angular의 &lt;a href=&quot;../guide/template-syntax#event-binding&quot;&gt;이벤트 바인딩&lt;/a&gt; 구문 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="edb830bd9f42a141071913f2de5f0ee10c46edce" translate="yes" xml:space="preserve">
          <source>This is an interim code sample that will allow you to provide and use the &lt;code&gt;HeroService&lt;/code&gt;. At this point, the code will differ from the &lt;code&gt;HeroService&lt;/code&gt; in the &lt;a href=&quot;toh-pt4#final-code-review&quot;&gt;&quot;final code review&quot;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;HeroService&lt;/code&gt; 를 제공하고 사용할 수있는 임시 코드 샘플입니다 . 이 시점에서 코드는 &lt;a href=&quot;toh-pt4#final-code-review&quot;&gt;&quot;최종 코드 검토&quot;&lt;/a&gt; 에서 &lt;code&gt;HeroService&lt;/code&gt; 와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="b3974dfe8a8053bf2f0f9d406986e6d789c88746" translate="yes" xml:space="preserve">
          <source>This is an internal project to add support for Angular front-ends to Google's internal integrated server stack.</source>
          <target state="translated">이것은 Google의 내부 통합 서버 스택에 Angular 프런트 엔드에 대한 지원을 추가하는 내부 프로젝트입니다.</target>
        </trans-unit>
        <trans-unit id="b2b55aa5e71e846d741afa9a4891157e8f09cdfb" translate="yes" xml:space="preserve">
          <source>This is an opaque value the router will give to a custom route reuse strategy to store and retrieve later on.</source>
          <target state="translated">이는 라우터가 나중에 사용자 지정 경로 재사용 전략에 저장하고 검색 할 수있는 불투명 한 값입니다.</target>
        </trans-unit>
        <trans-unit id="47187f9c60a312936c257bcbf674f7a846c9c3b7" translate="yes" xml:space="preserve">
          <source>This is disagreeable. The word, &lt;code&gt;appHighlight&lt;/code&gt;, is a terrible property name and it doesn't convey the property's intent.</source>
          <target state="translated">이것은 동의 할 수 없습니다. &lt;code&gt;appHighlight&lt;/code&gt; 라는 단어 는 끔찍한 속성 이름이며 속성의 의도를 전달하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="402dd3cc505c92b3ebc8041d5e0f5ce4dca64317" translate="yes" xml:space="preserve">
          <source>This is especially useful when child components are defined with an empty path string, as in the following example. With this configuration, navigating to '/parent/10' creates the main child and aux components.</source>
          <target state="translated">다음 예제와 같이 하위 구성 요소가 빈 경로 문자열로 정의 된 경우 특히 유용합니다. 이 구성에서 '/ parent / 10'으로 이동하면 기본 하위 및 보조 구성 요소가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="f0a8eee1520084e40ddb251d4ee70816b2810239" translate="yes" xml:space="preserve">
          <source>This is how you associate a template with logic, which is defined in the component class.</source>
          <target state="translated">이것이 컴포넌트 클래스에 정의 된 로직과 템플리트를 연관시키는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="3a2de92bdd97f6fbeeca5fdc9ee29a195958c537" translate="yes" xml:space="preserve">
          <source>This is illustrated in the following image, which displays the logging date.</source>
          <target state="translated">로깅 날짜를 표시하는 다음 이미지에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4461ea0ba25396c618a6f8a0d7132ba6f60a3420" translate="yes" xml:space="preserve">
          <source>This is manifestly more complicated than &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; and rightly so. The &lt;code&gt;NgFor&lt;/code&gt; directive has more features, both required and optional, than the &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; shown in this guide. At minimum &lt;code&gt;NgFor&lt;/code&gt; needs a looping variable (&lt;code&gt;let hero&lt;/code&gt;) and a list (&lt;code&gt;heroes&lt;/code&gt;).</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 보다 분명히 복잡 합니다. &lt;code&gt;NgFor&lt;/code&gt; 의 지시어는 더 많은 기능을 가지고, 모두보다, 필수 및 선택 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 는 이 안내서에 나와있는. &lt;code&gt;NgFor&lt;/code&gt; 는 최소한 루핑 변수 ( &lt;code&gt;let hero&lt;/code&gt; )와 목록 ( &lt;code&gt;heroes&lt;/code&gt; )이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7efe4c9363e221388c4cd38d8c3a512cea782501" translate="yes" xml:space="preserve">
          <source>This is often the case with &lt;em&gt;routing components&lt;/em&gt;. As a rule you test the component, not the router, and care only if the component navigates with the right address under the given conditions.</source>
          <target state="translated">&lt;em&gt;라우팅 구성 요소&lt;/em&gt; 의 경우가 종종 있습니다. 일반적으로 라우터가 아닌 구성 요소를 테스트하고 지정된 조건에서 구성 요소가 올바른 주소로 탐색하는 경우에만주의하십시오.</target>
        </trans-unit>
        <trans-unit id="60412eee3362861bf6dd3a41df31f62ad91b66a4" translate="yes" xml:space="preserve">
          <source>This is one of the three fundamental building blocks of Angular forms, along with &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt;. It extends the &lt;code&gt;&lt;a href=&quot;abstractcontrol&quot;&gt;AbstractControl&lt;/a&gt;&lt;/code&gt; class that implements most of the base functionality for accessing the value, validation status, user interactions and events.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; 와 함께 Angular 양식의 세 가지 기본 구성 요소 중 하나입니다 . 값, 유효성 검사 상태, 사용자 상호 작용 및 이벤트에 액세스하기위한 대부분의 기본 기능을 구현 하는 &lt;code&gt;&lt;a href=&quot;abstractcontrol&quot;&gt;AbstractControl&lt;/a&gt;&lt;/code&gt; 클래스를 확장 합니다.</target>
        </trans-unit>
        <trans-unit id="c8af7d6538861c4de12ed064fb23bf497866d794" translate="yes" xml:space="preserve">
          <source>This is one of the three fundamental building blocks of Angular forms, along with &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt;. It extends the &lt;code&gt;&lt;a href=&quot;abstractcontrol&quot;&gt;AbstractControl&lt;/a&gt;&lt;/code&gt; class that implements most of the base functionality for accessing the value, validation status, user interactions and events. See &lt;a href=&quot;formcontrol#usage-notes&quot;&gt;usage examples below&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; 와 함께 Angular 양식의 세 가지 기본 구성 요소 중 하나입니다 . 값, 유효성 검사 상태, 사용자 상호 작용 및 이벤트에 액세스하기위한 대부분의 기본 기능을 구현 하는 &lt;code&gt;&lt;a href=&quot;abstractcontrol&quot;&gt;AbstractControl&lt;/a&gt;&lt;/code&gt; 클래스를 확장 합니다. 아래 &lt;a href=&quot;formcontrol#usage-notes&quot;&gt;사용 예를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="51b5158af868b9258e387116060b9c47ff8fb973" translate="yes" xml:space="preserve">
          <source>This is similar to the phone list component. The new wrinkle is the &lt;code&gt;RouteParams&lt;/code&gt; type annotation that identifies the &lt;code&gt;routeParams&lt;/code&gt; dependency.</source>
          <target state="translated">이것은 전화 목록 구성 요소와 유사합니다. 새로운 주름은이다 &lt;code&gt;RouteParams&lt;/code&gt; 유형 약어가 식별합니다 &lt;code&gt;routeParams&lt;/code&gt; 의 의존성.</target>
        </trans-unit>
        <trans-unit id="804a4031c3f14f499869d2204177c75dee70978b" translate="yes" xml:space="preserve">
          <source>This is the SHA1 hash of the most up-to-date version of the app that the service worker knows about.</source>
          <target state="translated">이것은 서비스 워커가 알고있는 최신 버전의 앱 SHA1 해시입니다.</target>
        </trans-unit>
        <trans-unit id="16525e697531723027c408ae314d617a3cee22fa" translate="yes" xml:space="preserve">
          <source>This is the base class for &lt;code&gt;&lt;a href=&quot;formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; 의 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="32e4434471515868a1b3925d1547dbdde41ab113" translate="yes" xml:space="preserve">
          <source>This is the base class for &lt;code&gt;&lt;a href=&quot;forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;forms/formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;forms/formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; 의 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="09772e314d49341cf87eb2642be70a9dc5fc7d9f" translate="yes" xml:space="preserve">
          <source>This is the default option.</source>
          <target state="translated">이것이 기본 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="2f800de1b08868e8b8e49cce1d56cd86eef0162b" translate="yes" xml:space="preserve">
          <source>This is the inner &lt;code&gt;&lt;a href=&quot;templateref&quot;&gt;TemplateRef&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">이것은 내부 &lt;code&gt;&lt;a href=&quot;templateref&quot;&gt;TemplateRef&lt;/a&gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="cff98b359039fbd0f2a88788c0ca5a17c544f06f" translate="yes" xml:space="preserve">
          <source>This is the outer &lt;code&gt;&lt;a href=&quot;templateref&quot;&gt;TemplateRef&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">이것은 외부 &lt;code&gt;&lt;a href=&quot;templateref&quot;&gt;TemplateRef&lt;/a&gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="6fbcbb942159ed1a22b254df114719bad20d47a4" translate="yes" xml:space="preserve">
          <source>This is the perfect infiltration job for a directive. The heroes will never know they're being watched.</source>
          <target state="translated">이것은 지침에 대한 완벽한 침투 작업입니다. 영웅들은 그들이보고 있다는 것을 결코 알지 못할 것입니다.</target>
        </trans-unit>
        <trans-unit id="4ccba53d17df213bee27c394101fd3424e3c0b6f" translate="yes" xml:space="preserve">
          <source>This is the place to free resources that won't be garbage collected automatically. Unsubscribe from Observables and DOM events. Stop interval timers. Unregister all callbacks that this directive registered with global or application services. You risk memory leaks if you neglect to do so.</source>
          <target state="translated">가비지 수집되지 않는 리소스를 자동으로 확보 할 수있는 곳입니다. Observables 및 DOM 이벤트를 구독 취소하십시오. 인터벌 타이머를 중지하십시오. 이 지시문이 글로벌 또는 애플리케이션 서비스에 등록한 모든 콜백을 등록 취소하십시오. 그렇게하지 않으면 메모리 누수 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f5ed6fbbb5f8dadb12202b2e0fbdec880ace274" translate="yes" xml:space="preserve">
          <source>This is the place to free resources that won't be garbage-collected automatically. You risk memory leaks if you neglect to do so.</source>
          <target state="translated">자동으로 가비지 수집되지 않는 리소스를 해제하는 장소입니다. 그렇게하지 않으면 메모리 누수가 위험합니다.</target>
        </trans-unit>
        <trans-unit id="9a6525a4da9f9f2b0077e6c20e8b8ad052414394" translate="yes" xml:space="preserve">
          <source>This is the same in both template-driven and reactive forms.</source>
          <target state="translated">이는 템플릿 기반 형식과 반응 형식 모두에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="87a555dd35ff17530be3a1fe3b938e47130474eb" translate="yes" xml:space="preserve">
          <source>This is the simplest production-ready deployment of your application.</source>
          <target state="translated">이것은 가장 간단한 프로덕션 용 배포 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="c58e06956699ce3b5d0d19719918b6ae26cfc2f3" translate="yes" xml:space="preserve">
          <source>This is the time to notify another part of the application that the component is going away.</source>
          <target state="translated">지금은 애플리케이션의 다른 부분에 구성 요소가 사라지고 있음을 알리는 시간입니다.</target>
        </trans-unit>
        <trans-unit id="5d3cebde8a1c748058ff6feaf6d6fd7fffbd33c4" translate="yes" xml:space="preserve">
          <source>This is used to parse the response appropriately before returning it to the requestee.</source>
          <target state="translated">요청자에게 응답을 보내기 전에 응답을 적절하게 구문 분석하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4575447306482a712f678b2a9d395b8a07e7fe6d" translate="yes" xml:space="preserve">
          <source>This is usually created automatically by &lt;code&gt;Injector.resolveAndCreate&lt;/code&gt;.</source>
          <target state="translated">이것은 보통 &lt;code&gt;Injector.resolveAndCreate&lt;/code&gt; 에 의해 자동으로 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="8d4f6bc5f09e6fd5355e7d9f2a9258c893547afc" translate="yes" xml:space="preserve">
          <source>This is very important since it allows you to repurpose the components for any type of survey as long as it's compatible with the &lt;em&gt;question&lt;/em&gt; object model. The key is the dynamic data binding of metadata used to render the form without making any hardcoded assumptions about specific questions. In addition to control metadata, you are also adding validation dynamically.</source>
          <target state="translated">&lt;em&gt;질문&lt;/em&gt; 개체 모델 과 호환되는 한 모든 유형의 설문에 대한 구성 요소를 재사용 할 수 있기 때문에 이것은 매우 중요 합니다. 핵심은 특정 질문에 대한 하드 코딩 된 가정없이 양식을 렌더링하는 데 사용되는 메타 데이터의 동적 데이터 바인딩입니다. 메타 데이터를 제어하는 ​​것 외에도 유효성 검사를 동적으로 추가합니다.</target>
        </trans-unit>
        <trans-unit id="30cc4dc7a4b6f15bc6646908fab43b52eb183eb7" translate="yes" xml:space="preserve">
          <source>This isn't an oversight. Angular doesn't offer such pipes because they perform poorly and prevent aggressive minification. Both &lt;code&gt;filter&lt;/code&gt; and &lt;code&gt;orderBy&lt;/code&gt; require parameters that reference object properties. Earlier in this page, you learned that such pipes must be &lt;a href=&quot;pipes#pure-and-impure-pipes&quot;&gt;impure&lt;/a&gt; and that Angular calls impure pipes in almost every change-detection cycle.</source>
          <target state="translated">이것은 감독이 아닙니다. Angular는 성능이 떨어지고 공격적인 축소를 방지하기 때문에 이러한 파이프를 제공하지 않습니다. &lt;code&gt;filter&lt;/code&gt; 및 &lt;code&gt;orderBy&lt;/code&gt; 모두 오브젝트 특성을 참조하는 매개 변수가 필요합니다. 이 페이지의 앞부분에서 이러한 파이프가 &lt;a href=&quot;pipes#pure-and-impure-pipes&quot;&gt;불완전&lt;/a&gt; 해야 하고 Angular 호출은 거의 모든 변경 감지주기에서 파이프를 불완전하게한다는 것을 배웠습니다 .</target>
        </trans-unit>
        <trans-unit id="bf87feeb4d56bb09ecc40ffedbf5b9b09eea90de" translate="yes" xml:space="preserve">
          <source>This isn't necessarily good design. This example is examining &lt;em&gt;whether a component can inject its parent via the parent's base class&lt;/em&gt;.</source>
          <target state="translated">반드시 좋은 디자인은 아닙니다. 이 예제는 &lt;em&gt;컴포넌트가 부모의 기본 클래스를 통해 부모를 주입 할 수 있는지 여부를&lt;/em&gt; 검사 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6eaca4844068379a7e60176fbbfc6443308fe713" translate="yes" xml:space="preserve">
          <source>This isn't usually a problem, especially if you adhere to the recommended &lt;em&gt;one class per file&lt;/em&gt; rule. But sometimes circular references are unavoidable. You're in a bind when class 'A' refers to class 'B' and 'B' refers to 'A'. One of them has to be defined first.</source>
          <target state="translated">&lt;em&gt;파일&lt;/em&gt; 규칙 &lt;em&gt;당&lt;/em&gt; 권장되는 &lt;em&gt;하나의 클래스&lt;/em&gt; 를 준수하는 경우 일반적으로 문제가되지 않습니다 . 그러나 때때로 순환 참조는 피할 수 없습니다. 클래스 'A'가 클래스 'B'를 참조하고 'B'가 'A'를 참조하면 바인드 상태입니다. 그중 하나가 먼저 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c05a6f671aee7310acf8516389c5116cf909b2b4" translate="yes" xml:space="preserve">
          <source>This list of modules are those that export components, directives, or pipes that component templates in this module reference. In this case, the component is &lt;code&gt;AppComponent&lt;/code&gt;, which references components, directives, or pipes in &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt;. A component template can reference another component, directive, or pipe when the referenced class is declared in this module or the class was imported from another module.</source>
          <target state="translated">이 모듈 목록은이 모듈 참조의 구성 요소 템플릿을 내보내는 구성 요소, 지시문 또는 파이프입니다. 이 경우, 컴포넌트는 &lt;code&gt;AppComponent&lt;/code&gt; , 참조되는 구성 요소, 지시 또는 파이프 &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt; . 참조 된 클래스가이 모듈에서 선언되거나 클래스가 다른 모듈에서 가져온 경우 구성 요소 템플릿은 다른 구성 요소, 지시문 또는 파이프를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee0b3ac2c6c7f7ea1c3093b1d935ac0ccfed0cd9" translate="yes" xml:space="preserve">
          <source>This list of modules are those that export components, directives, or pipes that the component templates in this module reference. In this case, the component is &lt;code&gt;AppComponent&lt;/code&gt;, which references components, directives, or pipes in &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt;. A component template can reference another component, directive, or pipe when the referenced class is declared in this module or the class was imported from another module.</source>
          <target state="translated">이 모듈 목록은이 모듈의 구성 요소 템플리트가 참조하는 구성 요소, 지시문 또는 파이프를 내보내는 것입니다. 이 경우 구성 요소는 &lt;code&gt;AppComponent&lt;/code&gt; 이며 &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt; 의 구성 요소, 지시문 또는 파이프를 참조합니다 . 참조 된 클래스가이 모듈에서 선언되었거나 클래스를 다른 모듈에서 가져올 때 컴포넌트 템플리트는 다른 컴포넌트, 지시문 또는 파이프를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a9afe5b810e772d3eb663f9b40c1dd4d79aaccb" translate="yes" xml:space="preserve">
          <source>This makes the controller code look a lot more like Angular already. You're all set to actually introduce Angular into the project.</source>
          <target state="translated">이렇게하면 컨트롤러 코드가 이미 Angular와 훨씬 비슷해 보입니다. 실제로 Angular를 프로젝트에 도입하도록 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="cf52b88eeaa1d49f9b18045164c3a40eae3476c3" translate="yes" xml:space="preserve">
          <source>This makes the provider visible to every class in the application that knows the provider's lookup token, or name.</source>
          <target state="translated">그러면 공급자의 조회 토큰 또는 이름을 알고있는 응용 프로그램의 모든 클래스에 공급자가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e402b132534c7c9be62f7464642b0941cc482405" translate="yes" xml:space="preserve">
          <source>This mapping ensures that your library always loads the local copies of the modules it needs.</source>
          <target state="translated">이 맵핑은 라이브러리가 항상 필요한 모듈의 로컬 사본을로드하도록합니다.</target>
        </trans-unit>
        <trans-unit id="31460d71bf9e1b081028cbc8de1171f82e87335e" translate="yes" xml:space="preserve">
          <source>This may only be called once, to set up the common providers for the current test suite on the current platform. If you absolutely need to change the providers, first use &lt;code&gt;resetTestEnvironment&lt;/code&gt;.</source>
          <target state="translated">현재 플랫폼에서 현재 테스트 스위트에 대한 공통 제공자를 설정하기 위해 한 번만 호출 할 수 있습니다. 제공자를 절대 변경해야하는 경우 먼저 &lt;code&gt;resetTestEnvironment&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="61958d29a3c8058968147c18b0f01bb5c73d67d0" translate="yes" xml:space="preserve">
          <source>This may seem like what the app has been doing all along. Not quite. The &lt;code&gt;AppModule&lt;/code&gt; is loaded when the application starts; that's &lt;em&gt;eager&lt;/em&gt; loading. Now the &lt;code&gt;AdminModule&lt;/code&gt; loads only when the user clicks on a link; that's &lt;em&gt;lazy&lt;/em&gt; loading.</source>
          <target state="translated">이것은 앱이 모든 것을 수행 한 것처럼 보일 수 있습니다. 좀 빠지는. &lt;code&gt;AppModule&lt;/code&gt; 은 응용 프로그램이 시작될 때로드됩니다; 그것은 &lt;em&gt;열망&lt;/em&gt; 입니다. 이제 &lt;code&gt;AdminModule&lt;/code&gt; 은 사용자가 링크를 클릭 할 때만로드됩니다. 그건 &lt;em&gt;게으른&lt;/em&gt; 로드.</target>
        </trans-unit>
        <trans-unit id="12bc8c3aa7a62420ea2cb6d2e429c4880c25f7b6" translate="yes" xml:space="preserve">
          <source>This may seem restrictive but it's also fast. An object reference check is fast&amp;mdash;much faster than a deep check for differences&amp;mdash;so Angular can quickly determine if it can skip both the pipe execution and a view update.</source>
          <target state="translated">이것은 제한적으로 보일 수 있지만 빠릅니다. 객체 참조 확인은 빠르고 (차이점을 확인하는 것보다 훨씬 빠름) Angular는 파이프 실행과 뷰 업데이트를 모두 건너 뛸 수 있는지 신속하게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ad5340f87862c854151cf06f5fd6043a1b00b74" translate="yes" xml:space="preserve">
          <source>This means that an NgModule behaves differently depending on whether it's loaded during application start or lazy-loaded later. Neglecting that difference can lead to &lt;a href=&quot;ngmodule-faq#q-why-bad&quot;&gt;adverse consequences&lt;/a&gt;.</source>
          <target state="translated">이는 NgModule이 애플리케이션 시작 중로드되었는지 또는 나중에 지연로드되는지에 따라 다르게 작동 함을 의미합니다. 그 차이를 무시하면 &lt;a href=&quot;ngmodule-faq#q-why-bad&quot;&gt;부정적인 결과&lt;/a&gt; 를 초래할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e6e948c64201b9f8912c19889c92106c85c33fc" translate="yes" xml:space="preserve">
          <source>This means that when you build your production configuration (using &lt;code&gt;ng build --prod&lt;/code&gt; or &lt;code&gt;ng build --configuration=production&lt;/code&gt;), the &lt;code&gt;src/environments/environment.ts&lt;/code&gt; file is replaced with the target-specific version of the file, &lt;code&gt;src/environments/environment.prod.ts&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;ng build --prod&lt;/code&gt; 또는 &lt;code&gt;ng build --configuration=production&lt;/code&gt; 을 사용하여 프로덕션 구성을 빌드 하면 &lt;code&gt;src/environments/environment.ts&lt;/code&gt; 파일이 대상별 버전의 파일 인 &lt;code&gt;src/environments/environment.prod.ts&lt;/code&gt; 로 대체됩니다. /environment.prod.ts .</target>
        </trans-unit>
        <trans-unit id="7b42c601f1b0de6ca86d93b51f7a4f0d84c91d6c" translate="yes" xml:space="preserve">
          <source>This means you're responsible for putting &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; on your service classes.</source>
          <target state="translated">즉 , 서비스 클래스에 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; 을 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="b37292a0b3e74c75b71eca67292a0c0b9392a296" translate="yes" xml:space="preserve">
          <source>This method also updates the value and validity of the control.</source>
          <target state="translated">이 방법은 또한 컨트롤의 값과 유효성을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="e754eab77abab498cd7f7a0b1268613ab289c6ed" translate="yes" xml:space="preserve">
          <source>This method does not update the value or validity of the control. Use &lt;a href=&quot;formgroup#addControl&quot;&gt;addControl&lt;/a&gt; instead.</source>
          <target state="translated">이 방법은 컨트롤의 값이나 유효성을 업데이트하지 않습니다. 대신 &lt;a href=&quot;formgroup#addControl&quot;&gt;addControl&lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="100a8e77d4f74abe1033d79495767430a1882094" translate="yes" xml:space="preserve">
          <source>This method is called by the forms API on initialization to update the form model when values propagate from the view to the model.</source>
          <target state="translated">이 메소드는 값이보기에서 모델로 전파 될 때 양식 모델을 업데이트하기 위해 초기화시 양식 API에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="957d45ae3b8977944714e03589b7ce213ef76cbd" translate="yes" xml:space="preserve">
          <source>This method is called by the forms API to write to the view when programmatic changes from model to view are requested.</source>
          <target state="translated">이 메소드는 모델에서 보기로의 프로그래밍 변경이 요청 될 때보기에 쓰기 위해 양식 API에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d4c0ca924e5a897aa17682cd4a412c4b9b49e4bc" translate="yes" xml:space="preserve">
          <source>This method is for development and testing only, and is not a supported or secure way of deploying an application.</source>
          <target state="translated">이 방법은 개발 및 테스트 용도로만 사용되며 지원되는 안전한 배포 방법이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6edd05f81e26ff6f38d68bee1458846ab8ffe7a0" translate="yes" xml:space="preserve">
          <source>This method is supported only in HTML5 mode and only in browsers supporting the HTML5 History API methods such as &lt;code&gt;pushState&lt;/code&gt; and &lt;code&gt;replaceState&lt;/code&gt;. If you need to support older browsers (like Android &amp;lt; 4.0), don't use this method.</source>
          <target state="translated">이 메소드는 HTML5 모드에서만 지원되며 &lt;code&gt;pushState&lt;/code&gt; 및 &lt;code&gt;replaceState&lt;/code&gt; 와 같은 HTML5 History API 메소드를 지원하는 브라우저에서만 지원됩니다 . 이전 브라우저 (예 : Android &amp;lt;4.0)를 지원해야하는 경우이 방법을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="07d75e6c897ca8fced62ff854dd31dff479c1ea8" translate="yes" xml:space="preserve">
          <source>This method is supported only in HTML5 mode and only in browsers supporting the HTML5 History API methods such as &lt;code&gt;pushState&lt;/code&gt; and &lt;code&gt;replaceState&lt;/code&gt;. If you need to support older browsers (like IE9 or Android &amp;lt; 4.0), don't use this method.</source>
          <target state="translated">이 메소드는 HTML5 모드에서만 지원되며 &lt;code&gt;pushState&lt;/code&gt; 및 &lt;code&gt;replaceState&lt;/code&gt; 와 같은 HTML5 히스토리 API 메소드를 지원하는 브라우저에서만 지원됩니다. . IE9 또는 Android &amp;lt;4.0과 같은 이전 브라우저를 지원해야하는 경우이 방법을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="582cc9eb2f1253026d9fec705c1a27f27a1e5797" translate="yes" xml:space="preserve">
          <source>This method performs strict checks, and throws an error if you try to set the value of a control that doesn't exist or if you exclude the value of a control.</source>
          <target state="translated">이 방법은 엄격한 검사를 수행하고 존재하지 않는 컨트롤 값을 설정하려고하거나 컨트롤 값을 제외하면 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="38f2789fcaf15e04940002919821b82465849aa8" translate="yes" xml:space="preserve">
          <source>This method returns a &lt;code&gt;Promise&lt;/code&gt; which indicates that the update check has completed successfully, though it does not indicate whether an update was discovered as a result of the check. Even if one is found, the service worker must still successfully download the changed files, which can fail. If successful, the &lt;code&gt;available&lt;/code&gt; event will indicate availability of a new version of the app.</source>
          <target state="translated">이 메서드는 업데이트 확인이 성공적으로 완료되었음을 나타내는 &lt;code&gt;Promise&lt;/code&gt; 을 반환 하지만 확인 결과 업데이트가 검색되었는지 여부는 나타내지 않습니다. 발견 된 경우라도 서비스 워커는 여전히 변경된 파일을 성공적으로 다운로드해야하는데 실패 할 수 있습니다. 성공하면 &lt;code&gt;available&lt;/code&gt; 이벤트는 새 버전의 앱 사용 가능함 을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7240a76f2e460d49075a05cb693f1cf044c80345" translate="yes" xml:space="preserve">
          <source>This might seem strange if you're used to dependency injection in strongly typed languages where an interface is the preferred dependency lookup key. However, JavaScript, doesn't have interfaces, so when TypeScript is transpiled to JavaScript, the interface disappears. There is no interface type information left for Angular to find at runtime.</source>
          <target state="translated">인터페이스가 선호되는 종속성 조회 키인 강력한 형식의 언어에서 종속성 주입에 익숙한 경우 이상하게 보일 수 있습니다. 그러나 JavaScript에는 인터페이스가 없으므로 TypeScript가 JavaScript로 변환되면 인터페이스가 사라집니다. 런타임에 Angular가 찾을 수있는 인터페이스 유형 정보가 없습니다.</target>
        </trans-unit>
        <trans-unit id="cebcf45fa5843285adb17f4750feda2527b4caa3" translate="yes" xml:space="preserve">
          <source>This milestone covers the following:</source>
          <target state="translated">이 마일스톤은 다음을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="0e15ee716458e352dc7390a8a35261c1328b3839" translate="yes" xml:space="preserve">
          <source>This milestone shows you how to configure a special-purpose module called a &lt;em&gt;Routing Module&lt;/em&gt;, which holds your app's routing configuration.</source>
          <target state="translated">이 마일스톤은 앱의 라우팅 구성을 보유 하는 &lt;em&gt;Routing Module&lt;/em&gt; 이라는 특수 목적 모듈을 구성하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="01a6160cc6927cc87e97af3ca12f5d7c3e578c05" translate="yes" xml:space="preserve">
          <source>This module defines a &lt;code&gt;routes&lt;/code&gt; object with two routes to the two phone components and a default route for the empty path. It passes the &lt;code&gt;routes&lt;/code&gt; to the &lt;code&gt;RouterModule.forRoot&lt;/code&gt; method which does the rest.</source>
          <target state="translated">이 모듈은 두 개의 전화 구성 요소에 대한 두 개의 경로와 빈 경로의 기본 경로를 가진 &lt;code&gt;routes&lt;/code&gt; 개체를 정의 합니다. 나머지를 수행하는 &lt;code&gt;RouterModule.forRoot&lt;/code&gt; 메소드로 &lt;code&gt;routes&lt;/code&gt; 를 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="81b384ca39cda92728b7bd10a1501aede53ebbbb" translate="yes" xml:space="preserve">
          <source>This next example binds an &lt;code&gt;Observable&lt;/code&gt; of message strings (&lt;code&gt;&lt;a href=&quot;../api/common/http/httperrorresponse#message&quot;&gt;message&lt;/a&gt;$&lt;/code&gt;) to a view with the &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;&lt;/code&gt; pipe.</source>
          <target state="translated">다음 예제는 &lt;code&gt;Observable&lt;/code&gt; 메시지 문자열 ( &lt;code&gt;&lt;a href=&quot;../api/common/http/httperrorresponse#message&quot;&gt;message&lt;/a&gt;$&lt;/code&gt; )을 &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;&lt;/code&gt; 파이프 가있는 뷰에 바인딩합니다 .</target>
        </trans-unit>
        <trans-unit id="1f28fed5c95e4e5fc2cf216bb7edd12cd2cdd95f" translate="yes" xml:space="preserve">
          <source>This one root component is usually called &lt;code&gt;AppComponent&lt;/code&gt; and is in the root module's &lt;code&gt;bootstrap&lt;/code&gt; array.</source>
          <target state="translated">이 루트 구성 요소는 일반적으로 &lt;code&gt;AppComponent&lt;/code&gt; 라고 하며 루트 모듈의 &lt;code&gt;bootstrap&lt;/code&gt; 배열에 있습니다.</target>
        </trans-unit>
        <trans-unit id="553c357233905d7a357b67f87ff6741c54ba7d0c" translate="yes" xml:space="preserve">
          <source>This option can take one of the following &lt;a href=&quot;https://angular.io/cli/cli/generate#schematic-commands&quot;&gt;sub-commands&lt;/a&gt;:</source>
          <target state="translated">이 옵션은 다음 &lt;a href=&quot;https://angular.io/cli/cli/generate#schematic-commands&quot;&gt;하위 명령&lt;/a&gt; 중 하나를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e2bdd9bc4821ec6e25c48f5020fa352d5d592c1" translate="yes" xml:space="preserve">
          <source>This option is intended to validate the &lt;code&gt;.metadata.json&lt;/code&gt; files emitted for bundling with an &lt;code&gt;npm&lt;/code&gt; package. The validation is strict and can emit errors for metadata that would never produce an error when used by the template compiler. You can choose to suppress the error emitted by this option for an exported symbol by including &lt;code&gt;@dynamic&lt;/code&gt; in the comment documenting the symbol.</source>
          <target state="translated">이 옵션은 &lt;code&gt;npm&lt;/code&gt; 패키지 와 함께 번들로 생성 된 &lt;code&gt;.metadata.json&lt;/code&gt; 파일의 유효성을 검사하기위한 것 입니다. 유효성 검사는 엄격하며 템플릿 컴파일러에서 사용할 때 오류가 발생하지 않는 메타 데이터에 대해 오류를 생성 할 수 있습니다. 심볼을 설명하는 주석에 &lt;code&gt;@dynamic&lt;/code&gt; 을 포함시켜 내 보낸 심볼에 대해이 옵션에서 발생하는 오류를 억제하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6eab3c2994a6a17d4115d07f1dae680ac2ec26d" translate="yes" xml:space="preserve">
          <source>This option is only available if application URLs look like normal web URLs without hashes (#) in the middle.</source>
          <target state="translated">이 옵션은 애플리케이션 URL이 중간에 해시 (#)가없는 일반 웹 URL처럼 보이는 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8136dad883434011e60763326dfd8b6bf0a135fa" translate="yes" xml:space="preserve">
          <source>This optional property enables you to configure how the service worker handles navigation requests:</source>
          <target state="translated">이 선택적 속성을 사용하면 서비스 워커가 탐색 요청을 처리하는 방법을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b706956040eab679c0d00e95b8bd1fb93cd1e1bf" translate="yes" xml:space="preserve">
          <source>This optional section enables you to specify a custom list of URLs that will be redirected to the index file.</source>
          <target state="translated">이 선택적 섹션을 사용하면 색인 파일로 리디렉션 될 사용자 정의 URL 목록을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d49647d5cde74d419f8b7a1440d72e1fa1cdb7e9" translate="yes" xml:space="preserve">
          <source>This page answers the questions many developers ask about NgModule design and implementation.</source>
          <target state="translated">이 페이지는 NgModule 설계 및 구현에 관해 많은 개발자들이 묻는 질문에 대한 답변입니다.</target>
        </trans-unit>
        <trans-unit id="e470076e6470a706c5e7519008e46a929c297415" translate="yes" xml:space="preserve">
          <source>This page covered how to use the &lt;a href=&quot;../api/upgrade/static&quot;&gt;upgrade/static&lt;/a&gt; package to incrementally upgrade existing AngularJS apps at your own pace and without impeding further development of the app for the duration of the upgrade process.</source>
          <target state="translated">이 페이지는 &lt;a href=&quot;../api/upgrade/static&quot;&gt;업그레이드 / 정적&lt;/a&gt; 사용법을 다루었습니다. 패키지 하여 업그레이드 프로세스 동안 앱의 추가 개발을 방해하지 않으면 서 기존 AngularJS 앱을 원하는 속도로 점진적으로 업그레이드하는 방법에 대해 설명했습니다.</target>
        </trans-unit>
        <trans-unit id="81be0c6f770103c818ad9a59d216fef97dd57b87" translate="yes" xml:space="preserve">
          <source>This page covered how to:</source>
          <target state="translated">이 페이지는 다음을 수행하는 방법을 다루었습니다.</target>
        </trans-unit>
        <trans-unit id="c3d2f38bcda77f3d0e583e4cbd59a23c93e26dd3" translate="yes" xml:space="preserve">
          <source>This page covers some aspects of TypeScript configuration and the TypeScript environment that are important to Angular developers, including details about the following files:</source>
          <target state="translated">이 페이지는 다음 파일에 대한 세부 사항을 포함하여 Angular 개발자에게 중요한 TypeScript 구성 및 TypeScript 환경의 일부 측면을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="dc6463bb109d0d9d7a3485b00e656aa5ad4447d1" translate="yes" xml:space="preserve">
          <source>This page demonstrates building a simple &lt;em&gt;appHighlight&lt;/em&gt; attribute directive to set an element's background color when the user hovers over that element. You can apply it like this:</source>
          <target state="translated">이 페이지 는 사용자가 해당 요소 위로 마우스를 가져갈 때 요소의 배경색을 설정하는 간단한 &lt;em&gt;appHighlight&lt;/em&gt; 속성 지시문을 &lt;em&gt;작성&lt;/em&gt; 하는 방법을 보여줍니다 . 다음과 같이 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f41f995aa12a74f7c35870947d8b3dfcd851015a" translate="yes" xml:space="preserve">
          <source>This page describes Angular's built-in protections against common web-application vulnerabilities and attacks such as cross-site scripting attacks. It doesn't cover application-level security, such as authentication (&lt;em&gt;Who is this user?&lt;/em&gt;) and authorization (&lt;em&gt;What can this user do?&lt;/em&gt;).</source>
          <target state="translated">이 페이지에서는 일반적인 웹 응용 프로그램 취약점 및 사이트 간 스크립팅 공격과 같은 공격에 대한 Angular의 기본 제공 보호 기능에 대해 설명합니다. 인증 ( &lt;em&gt;이 사용자는 누구입니까?&lt;/em&gt; ) 및 권한 부여 ( &lt;em&gt;이 사용자는 무엇을 할 수 &lt;/em&gt;&lt;em&gt;있습니까?&lt;/em&gt; )와 같은 응용 프로그램 수준 보안은 다루지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b0a26a5d944df815f572ce97ca9af1ebb2bdb5a7" translate="yes" xml:space="preserve">
          <source>This page describes how to load and apply these component styles.</source>
          <target state="translated">이 페이지에서는 이러한 구성 요소 스타일을로드하고 적용하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9ea2990707bfb1eb329f12d6cb790431a215270f" translate="yes" xml:space="preserve">
          <source>This page describes the most useful Angular testing features.</source>
          <target state="translated">이 페이지에서는 가장 유용한 Angular 테스트 기능을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="09ae81e8cd8b8d7fc27be03d544055e093469b55" translate="yes" xml:space="preserve">
          <source>This page discusses best practices for designing Angular applications that work well for all users, including those who rely on assistive technologies.</source>
          <target state="translated">이 페이지에서는 보조 기술에 의존하는 사용자를 포함하여 모든 사용자에게 잘 작동하는 Angular 응용 프로그램을 설계하는 모범 사례에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="670a5a082b047a72ce1a558bd250325e58e09d59" translate="yes" xml:space="preserve">
          <source>This page discusses build-specific configuration options for Angular projects.</source>
          <target state="translated">이 페이지에서는 Angular 프로젝트의 빌드 별 구성 옵션에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e05b95dc7d3d7d081939018409b02519ccacc29a" translate="yes" xml:space="preserve">
          <source>This page guides you through creating the shopping cart in three phases:</source>
          <target state="translated">이 페이지에서는 다음 세 단계로 장바구니를 만드는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="cbfa8125c3023f0e5a452262dd4b80eb0950ad8c" translate="yes" xml:space="preserve">
          <source>This page is a comprehensive technical reference to the Angular template language. It explains basic principles of the template language and describes most of the syntax that you'll encounter elsewhere in the documentation.</source>
          <target state="translated">이 페이지는 Angular 템플릿 언어에 대한 포괄적 인 기술 참조입니다. 템플릿 언어의 기본 원칙을 설명하고 설명서의 다른 곳에서 발생하는 대부분의 구문에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7fad648d853b5ed4d555cb38fbfbacd9ba7992b6" translate="yes" xml:space="preserve">
          <source>This page is a reference for deploying and supporting production apps that use the Angular service worker. It explains how the Angular service worker fits into the larger production environment, the service worker's behavior under various conditions, and available resources and fail-safes.</source>
          <target state="translated">이 페이지는 Angular 서비스 워커를 사용하는 프로덕션 앱을 배포하고 지원하기위한 참조입니다. Angular 서비스 워커가 더 큰 프로덕션 환경, 다양한 조건에서 서비스 워커의 동작, 가용 리소스 및 페일 세이프에 어떻게 적용되는지 설명합니다.</target>
        </trans-unit>
        <trans-unit id="be3ec6216875616431f7d6ed1137be9c33cace38" translate="yes" xml:space="preserve">
          <source>This page provides a conceptual overview of a dependency injection technique that is recommended for library developers. Designing your library with &lt;em&gt;lightweight injection tokens&lt;/em&gt; helps optimize the bundle size of client applications that use your library.</source>
          <target state="translated">이 페이지는 라이브러리 개발자에게 권장되는 종속성 주입 기술의 개념적 개요를 제공합니다. &lt;em&gt;경량 주입 토큰으로&lt;/em&gt; 라이브러리를 설계 하면 라이브러리를 사용하는 클라이언트 애플리케이션의 번들 크기를 최적화하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="5d3133b3ab2dc9616d7ee04b4ceb9f767579da99" translate="yes" xml:space="preserve">
          <source>This page provides a conceptual overview of how you can create and publish new libraries to extend Angular functionality.</source>
          <target state="translated">이 페이지에서는 Angular 기능을 확장하기 위해 새 라이브러리를 만들고 게시하는 방법에 대한 개념적 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="97c20e865f128e08c87e8b02ca1209e92134e457" translate="yes" xml:space="preserve">
          <source>This page shows how to validate user input in the UI and display useful validation messages using both reactive and template-driven forms. It assumes some basic knowledge of the two forms modules.</source>
          <target state="translated">이 페이지는 UI에서 사용자 입력의 유효성을 검사하고 반응 형 및 템플릿 기반 양식을 사용하여 유용한 유효성 검사 메시지를 표시하는 방법을 보여줍니다. 두 양식 모듈에 대한 기본 지식이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="5d4c0327323a7a67f27b56ff84bda976d2f25fa4" translate="yes" xml:space="preserve">
          <source>This page shows you how to build a simple form from scratch. Along the way you'll learn how to:</source>
          <target state="translated">이 페이지는 간단한 양식을 처음부터 작성하는 방법을 보여줍니다. 다음과 같은 방법을 배우게됩니다.</target>
        </trans-unit>
        <trans-unit id="809f471c9fda21049d71c0885d6f8ee1429911d6" translate="yes" xml:space="preserve">
          <source>This particular &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#get&quot;&gt;HttpClient.get()&lt;/a&gt;&lt;/code&gt; call returns an &lt;code&gt;Observable&amp;lt;Hero[]&amp;gt;&lt;/code&gt;; that is, &quot;&lt;em&gt;an observable of hero arrays&lt;/em&gt;&quot;. In practice, it will only return a single hero array.</source>
          <target state="translated">이 특정 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#get&quot;&gt;HttpClient.get()&lt;/a&gt;&lt;/code&gt; 호출은 &lt;code&gt;Observable&amp;lt;Hero[]&amp;gt;&lt;/code&gt; 반환합니다 . 즉, &quot; &lt;em&gt;영웅 배열의 관찰 가능&lt;/em&gt; &quot;입니다. 실제로는 단일 영웅 배열 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d836ca04f6cff950392c8ae7f7d0cf1a60a94c96" translate="yes" xml:space="preserve">
          <source>This particular test suite supplies a minimal mock of the &lt;code&gt;UserService&lt;/code&gt; that satisfies the needs of the &lt;code&gt;WelcomeComponent&lt;/code&gt; and its tests:</source>
          <target state="translated">이 특정 테스트 스위트 는 &lt;code&gt;WelcomeComponent&lt;/code&gt; 의 요구 와 테스트 를 충족시키는 최소한의 &lt;code&gt;UserService&lt;/code&gt; 모의를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="ff6ecdb8628c90cfa56e0ff26fbdce1243318d07" translate="yes" xml:space="preserve">
          <source>This pipe definition reveals the following key points:</source>
          <target state="translated">이 파이프 정의는 다음과 같은 핵심 사항을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="9c06cdda191efa55a95c5ebbcd3348ce80c0d189" translate="yes" xml:space="preserve">
          <source>This platform has to be included in any other platform</source>
          <target state="translated">이 플랫폼은 다른 플랫폼에 포함되어야합니다</target>
        </trans-unit>
        <trans-unit id="1a66dd83805fb99c52388b0a549137c596348fd3" translate="yes" xml:space="preserve">
          <source>This produces the following error:</source>
          <target state="translated">다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cc28ea5e9b1a6b51e4c29ff84265e5f10b52e574" translate="yes" xml:space="preserve">
          <source>This registers Angular's &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; providers globally.</source>
          <target state="translated">이것은 Angular의 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 공급자를 전 세계적으로 등록 합니다.</target>
        </trans-unit>
        <trans-unit id="40b2f3a8cf72659eb5e60961a2342494b2510413" translate="yes" xml:space="preserve">
          <source>This registers a drop-in replacement for the &lt;code&gt;$location&lt;/code&gt; provider in AngularJS. Once registered, all navigation, routing broadcast messages, and any necessary digest cycles in AngularJS triggered during navigation are handled by Angular. This gives you a single way to navigate within both sides of your hybrid application consistently.</source>
          <target state="translated">이것은 AngularJS에서 &lt;code&gt;$location&lt;/code&gt; 공급자 의 드롭 인 대체를 등록합니다 . 일단 등록되면 탐색 중에 트리거 된 모든 탐색, 라우팅 브로드 캐스트 메시지 및 AngularJS의 필요한 다이제스트주기가 Angular에 의해 처리됩니다. 이를 통해 하이브리드 애플리케이션의 양쪽에서 일관되게 탐색 할 수있는 단일 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="768b48e740a696bfc0705b3b4a88ffb9387d0941" translate="yes" xml:space="preserve">
          <source>This removal has no impact on CLI users, unless they modified their build configuration to explicitly consume these code distributions.</source>
          <target state="translated">이 제거는 이러한 코드 배포를 명시 적으로 사용하도록 빌드 구성을 수정하지 않는 한 CLI 사용자에게 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06f56de558de0a575487e683fea999edf392ee43" translate="yes" xml:space="preserve">
          <source>This request passes the &lt;code&gt;heroesURL&lt;/code&gt; as the first parameter and the callback function name as the second parameter. The response is wrapped in the callback function, which takes the observables returned by the JSONP method and pipes them through to the error handler.</source>
          <target state="translated">이 요청은 &lt;code&gt;heroesURL&lt;/code&gt; 을 첫 번째 매개 변수로, 콜백 함수 이름을 두 번째 매개 변수로 전달합니다. 응답은 콜백 함수에 래핑됩니다. 콜백 함수는 JSONP 메서드에서 반환 된 관찰 가능 항목을 가져 와서 오류 처리기로 파이프합니다.</target>
        </trans-unit>
        <trans-unit id="d9fd7c2c4a20b1de98c590fa48930235dc6aba0d" translate="yes" xml:space="preserve">
          <source>This route redirects a URL that fully matches the empty path to the route whose path is &lt;code&gt;'/dashboard'&lt;/code&gt;.</source>
          <target state="translated">이 경로는 빈 경로와 완전히 일치하는 URL을 경로가 &lt;code&gt;'/dashboard'&lt;/code&gt; 인 경로로 리디렉션합니다 .</target>
        </trans-unit>
        <trans-unit id="6c41f8a018f7563801e156030ed8a8f8ca194ad0" translate="yes" xml:space="preserve">
          <source>This rule is essential to Angular's &quot;unidirectional data flow&quot; policy. You should never worry that reading a component value might change some other displayed value. The view should be stable throughout a single rendering pass.</source>
          <target state="translated">이 규칙은 Angular의 &quot;단방향 데이터 흐름&quot;정책에 필수적입니다. 구성 요소 값을 읽으면 표시되는 다른 값이 변경 될 수 있습니다. 단일 렌더링 패스에서 뷰가 안정적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="57892addca2408cf0e87807e6475ac5695bf2874" translate="yes" xml:space="preserve">
          <source>This sample app recreates the heroes feature in the &quot;Services&quot; section of the &lt;a href=&quot;../tutorial/toh-pt4&quot;&gt;Tour of Heroes tutorial&lt;/a&gt;, and reuses much of the code from the .</source>
          <target state="translated">이 샘플 앱은 &lt;a href=&quot;../tutorial/toh-pt4&quot;&gt;Tour of Heroes 가이드&lt;/a&gt; 의 '서비스'섹션에있는 Heroes 기능을 다시 만들고.</target>
        </trans-unit>
        <trans-unit id="0d1e4a2f1c53200691565434ab456d518f0bf3a4" translate="yes" xml:space="preserve">
          <source>This sample file is easy to translate without a special editor or knowledge of French.</source>
          <target state="translated">이 샘플 파일은 특별한 편집자 나 프랑스어에 대한 지식없이 쉽게 번역 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="480408f47c676f8c57b3cde5a055d6686d241608" translate="yes" xml:space="preserve">
          <source>This scenario causes your app to create a new instance every time, instead of using the singleton.</source>
          <target state="translated">이 시나리오에서는 앱이 싱글 톤을 사용하지 않고 매번 새 인스턴스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="99aa2e43a5383e16a847762330ebaee6bfd37ca5" translate="yes" xml:space="preserve">
          <source>This scoping restriction is a &lt;strong&gt;&lt;em&gt;styling modularity feature&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">이 범위 제한은 &lt;strong&gt;&lt;em&gt;스타일링 모듈화 기능&lt;/em&gt;&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="31d68c7991b2366acf1e70e15d44815dc09ecff1" translate="yes" xml:space="preserve">
          <source>This script can be used both to deactivate &lt;code&gt;@angular/service-worker&lt;/code&gt; as well as any other Service Workers which might have been served in the past on your site.</source>
          <target state="translated">이 스크립트는 &lt;code&gt;@angular/service-worker&lt;/code&gt; 및 사이트에서 과거에 서비스를 받았던 다른 서비스 워커를 모두 비활성화하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c18fae7524b94c2e1854507242de01f07367e013" translate="yes" xml:space="preserve">
          <source>This section about &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; has its own . The following subsections highlight key points in the sample app.</source>
          <target state="translated">약이 섹션 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 와 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; 자신이있다. 다음 하위 섹션에서는 샘플 앱의 요점을 강조합니다.</target>
        </trans-unit>
        <trans-unit id="b64223a794713879607f46b9296695b6693dcfef" translate="yes" xml:space="preserve">
          <source>This section assumes you are familiar with &lt;a href=&quot;https://docs.bazel.build&quot;&gt;Bazel&lt;/a&gt;.</source>
          <target state="translated">이 섹션에서는 사용자가 &lt;a href=&quot;https://docs.bazel.build&quot;&gt;Bazel에&lt;/a&gt; 익숙하다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="61775d2ada3e1aaca95806012a1cae0e038b820d" translate="yes" xml:space="preserve">
          <source>This section contains a complete list all of the currently deprecated CLI flags.</source>
          <target state="translated">이 섹션에는 현재 사용되지 않는 모든 CLI 플래그의 전체 목록이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="11a0d4f001f44cf92c4d038ced8939573bb0e86d" translate="yes" xml:space="preserve">
          <source>This section contains a complete list all of the currently-deprecated APIs, with details to help you plan your migration to a replacement.</source>
          <target state="translated">이 섹션에는 현재 사용되지 않는 모든 API의 전체 목록과 교체로의 마이그레이션 계획을 세우는 데 도움이되는 세부 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5235be074b4aa0d4b2e76c1864190fa474d6ead" translate="yes" xml:space="preserve">
          <source>This section contains default build target options, used when no named alternative configuration is specified. See &lt;a href=&quot;workspace-config#default-build-targets&quot;&gt;Default build targets&lt;/a&gt; below.</source>
          <target state="translated">이 섹션에는 명명 된 대체 구성이 지정되지 않은 경우 사용되는 기본 빌드 대상 옵션이 포함되어 있습니다. 아래의 &lt;a href=&quot;workspace-config#default-build-targets&quot;&gt;기본 빌드 대상을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6f4ac6b1d629df1dd4126322ebc082c11c00de6" translate="yes" xml:space="preserve">
          <source>This section covers changes you may have make to the server or to files deployed to the server.</source>
          <target state="translated">이 섹션에서는 서버 또는 서버에 배포 된 파일에 대한 변경 사항에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b00ef0591ba8184696f1413d52cca1b7afa05294" translate="yes" xml:space="preserve">
          <source>This section covers changes you may have to make to the server or to files deployed on the server.</source>
          <target state="translated">이 섹션에서는 서버 또는 서버에 배포 된 파일에 대해 수행해야 할 수있는 변경 사항을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="1b184253cc42d7415bb50e2b1f1ae4bfa4d58e73" translate="yes" xml:space="preserve">
          <source>This section defines and names alternative configurations for different intended destinations. It contains a section for each named configuration, which sets the default options for that intended environment. See &lt;a href=&quot;workspace-config#build-configs&quot;&gt;Alternate build configurations&lt;/a&gt; below.</source>
          <target state="translated">이 섹션에서는 다른 대상에 대한 대체 구성을 정의하고 이름을 지정합니다. 여기에는 해당 환경에 대한 기본 옵션을 설정하는 각 명명 된 구성에 대한 섹션이 포함되어 있습니다. 아래의 &lt;a href=&quot;workspace-config#build-configs&quot;&gt;대체 빌드 구성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7378faaab25e8cea0f89eb0420acd35173d6d0c" translate="yes" xml:space="preserve">
          <source>This section defines the policy by which matching requests will be cached.</source>
          <target state="translated">이 섹션에서는 일치하는 요청을 캐시하는 정책을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="085d9b2381ce33b95badee4ece65c04252ae8b07" translate="yes" xml:space="preserve">
          <source>This section demonstrates a service worker in action, using an example application.</source>
          <target state="translated">이 섹션에서는 예제 응용 프로그램을 사용하여 서비스 워커의 실제 작업을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b0beb9d185cb05154e1dd17453c7c97560febcea" translate="yes" xml:space="preserve">
          <source>This section demonstrates how to write providers that deliver dependent services.</source>
          <target state="translated">이 섹션에서는 종속 서비스를 제공하는 제공자를 작성하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="eb2c533b5e2645aa61c4b0e279f37acd6ba4506b" translate="yes" xml:space="preserve">
          <source>This section describes how to add a single form control. In the example, the user enters their name into an input field, captures that input value, and displays the current value of the form control element.</source>
          <target state="translated">이 섹션에서는 단일 폼 컨트롤을 추가하는 방법에 대해 설명합니다. 이 예에서 사용자는 입력 필드에 이름을 입력하고 해당 입력 값을 캡처하여 양식 제어 요소의 현재 값을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="8df9a0125bfce0a631c00cf027d6c0c9e9c21223" translate="yes" xml:space="preserve">
          <source>This section describes how to limit the scope of the beginning and ending &lt;code&gt;ElementInjector&lt;/code&gt; using the visibility decorators &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt;, &lt;code&gt;@&lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt;()&lt;/code&gt;, and &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt;.</source>
          <target state="translated">이 섹션에서는 가시성 데코레이터 &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt; () , &lt;code&gt;@&lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt; () 및 &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt; ()를 사용하여 시작 및 끝 &lt;code&gt;ElementInjector&lt;/code&gt; 의 범위를 제한하는 방법에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="93a1f837d6690ccc5052bae1311690c80cb118fa" translate="yes" xml:space="preserve">
          <source>This section describes some techniques for doing that.</source>
          <target state="translated">이 섹션에서는이를 수행하는 몇 가지 기술에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7d51845aea280551e7377855a04b80ead1d2f4bd" translate="yes" xml:space="preserve">
          <source>This section describes the resources to cache, broken up into the following groups:</source>
          <target state="translated">이 섹션에서는 캐시 할 리소스에 대해 설명하며 다음 그룹으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="69a1ff0385a87975f95ae5a798ec38b6e1fa9506" translate="yes" xml:space="preserve">
          <source>This section describes the resources to cache, broken up into three groups.</source>
          <target state="translated">이 섹션에서는 캐시 할 리소스를 세 그룹으로 분류하여 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7164aeb8b556a0ff400bdf3da7f1df7d1f517925" translate="yes" xml:space="preserve">
          <source>This section describes two techniques for minimizing the setup. Use them, alone or in combination, to stay focused on testing the primary component.</source>
          <target state="translated">이 섹션에서는 설정을 최소화하는 두 가지 기술을 설명합니다. 기본 구성 요소를 테스트하는 데 집중하려면 단독으로 또는 조합하여 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="25d342d94221065f56ba9567318ef23b976b78cb" translate="yes" xml:space="preserve">
          <source>This section describes two techniques for minimizing the setup. Use them, alone or in combination, to stay focused on the testing the primary component.</source>
          <target state="translated">이 섹션에서는 설정을 최소화하기위한 두 가지 기술에 대해 설명합니다. 기본 구성 요소 테스트에 중점을 두려면 단독으로 또는 조합하여 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4b6eb3ab67768fa1db1718443a20d6bef34cf012" translate="yes" xml:space="preserve">
          <source>This section enables you to pass any data you want that describes this particular version of the app. The &lt;code&gt;&lt;a href=&quot;../api/service-worker/swupdate&quot;&gt;SwUpdate&lt;/a&gt;&lt;/code&gt; service includes that data in the update notifications. Many apps use this section to provide additional information for the display of UI popups, notifying users of the available update.</source>
          <target state="translated">이 섹션에서는이 특정 버전의 앱을 설명하는 원하는 데이터를 전달할 수 있습니다. &lt;code&gt;&lt;a href=&quot;../api/service-worker/swupdate&quot;&gt;SwUpdate&lt;/a&gt;&lt;/code&gt; 의 서비스는 업데이트 알림에 데이터가 포함되어 있습니다. 많은 앱이이 섹션을 사용하여 사용자에게 사용 가능한 업데이트를 알리는 UI 팝업 표시에 대한 추가 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="47fc123a3ed1f0d231e027d8288971ed0c72aa21" translate="yes" xml:space="preserve">
          <source>This section explores many of the features of dependency injection (DI) in Angular.</source>
          <target state="translated">이 섹션에서는 Angular의 많은 DI (dependency injection) 기능을 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="4384b75486bddedfea304c2a90535f59084acc2a" translate="yes" xml:space="preserve">
          <source>This section guides you through adding a custom strategy that only preloads routes whose &lt;code&gt;data.preload&lt;/code&gt; flag is set to &lt;code&gt;true&lt;/code&gt;. Recall that you can add anything to the &lt;code&gt;data&lt;/code&gt; property of a route.</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;data.preload&lt;/code&gt; 플래그가 &lt;code&gt;true&lt;/code&gt; 로 설정된 경로 만 미리로드하는 커스텀 전략을 추가하는 방법을 안내 합니다 . 경로 의 &lt;code&gt;data&lt;/code&gt; 속성에는 무엇이든 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4ab163f1040a173c8f1fee4855a987c614055d5" translate="yes" xml:space="preserve">
          <source>This section guides you through extending the crisis center with some new administrative features. Start by adding a new feature module named &lt;code&gt;AdminModule&lt;/code&gt;.</source>
          <target state="translated">이 섹션에서는 몇 가지 새로운 관리 기능으로 위기 센터를 확장하는 방법을 안내합니다. &lt;code&gt;AdminModule&lt;/code&gt; 이라는 새 기능 모듈을 추가하여 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa94115b584195aa264c16e4fb5711861e3ddede" translate="yes" xml:space="preserve">
          <source>This section guides you through migrating the &lt;code&gt;Hero&lt;/code&gt; routes to new URLs. The &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; checks for redirects in your configuration before navigating, so each redirect is triggered when needed. To support this change, add redirects from the old routes to the new routes in the &lt;code&gt;heroes-routing.module&lt;/code&gt;.</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;Hero&lt;/code&gt; 경로를 새 URL로 마이그레이션하는 방법을 안내 합니다. &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 필요할 때 이동하기 전에 구성에서 리디렉션에 대한 검사는, 각각의 리디렉션 트리거됩니다. 이 변경 사항을 지원하려면 &lt;code&gt;heroes-routing.module&lt;/code&gt; 의 이전 경로에서 새 경로로의 리디렉션을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="3fbce57e38fce3ed83994d74968cf78f64dac167" translate="yes" xml:space="preserve">
          <source>This section guides you through the following:</source>
          <target state="translated">이 섹션에서는 다음을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="e327b6a9a7d25aeebecb0e4a2e3d8dd80bb60d4b" translate="yes" xml:space="preserve">
          <source>This section guides you through updating the &lt;code&gt;CrisisCenterModule&lt;/code&gt; to load lazily by default and use the &lt;code&gt;&lt;a href=&quot;../api/router/preloadallmodules&quot;&gt;PreloadAllModules&lt;/a&gt;&lt;/code&gt; strategy to load all lazy loaded modules.</source>
          <target state="translated">이 섹션에서는 기본적으로 느리게로드 되도록 &lt;code&gt;CrisisCenterModule&lt;/code&gt; 을 업데이트하고 지연로드 된 모든 모듈을로드 하려면 &lt;code&gt;&lt;a href=&quot;../api/router/preloadallmodules&quot;&gt;PreloadAllModules&lt;/a&gt;&lt;/code&gt; 전략을 사용하는 방법을 안내 합니다.</target>
        </trans-unit>
        <trans-unit id="a01d00f37cdecb7bf80e6521a92c1f8871d11b3b" translate="yes" xml:space="preserve">
          <source>This section has covered the following:</source>
          <target state="translated">이 섹션에서는 다음 내용을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="25546f650c09fba6868c4a94f07eeaca55c8fedb" translate="yes" xml:space="preserve">
          <source>This section introduces the basic procedure for configuring a lazy-loaded route. For a step-by-step example, see the &lt;a href=&quot;lazy-loading-ngmodules#step-by-step&quot;&gt;step-by-step setup&lt;/a&gt; section on this page.</source>
          <target state="translated">이 섹션에서는 지연로드 경로를 구성하는 기본 절차를 소개합니다. 단계별 예제 는이 페이지의 &lt;a href=&quot;lazy-loading-ngmodules#step-by-step&quot;&gt;단계별 설정&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3a63d68a98a00a26a92cce922c9931db461a38cf" translate="yes" xml:space="preserve">
          <source>This section is an introduction to the common built-in structural directives:</source>
          <target state="translated">이 섹션은 일반적인 내장 구조 지시문에 대한 소개입니다.</target>
        </trans-unit>
        <trans-unit id="c4d630efe539af7ec5dfcdfbcacacc0d6a4f3dbc" translate="yes" xml:space="preserve">
          <source>This section lists all of the currently-deprecated features, which includes template syntax, configuration options, and any other deprecations not listed in the &lt;a href=&quot;deprecations#deprecated-apis&quot;&gt;Deprecated APIs&lt;/a&gt; section above. It also includes deprecated API usage scenarios or API combinations, to augment the information above.</source>
          <target state="translated">이 섹션에는 템플릿 구문, 구성 옵션 및 위 의 더 이상 사용되지 &lt;a href=&quot;deprecations#deprecated-apis&quot;&gt;않는 API&lt;/a&gt; 섹션에 나열되지 않은 다른 더 이상 사용되지 않는 기능을 포함하여 현재 사용되지 않는 모든 기능이 나열됩니다 . 또한 위의 정보를 보강하기 위해 더 이상 사용되지 않는 API 사용 시나리오 또는 API 조합을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="7cae31034c8a2571577d2c3c5b7550e76da38a59" translate="yes" xml:space="preserve">
          <source>This section provides example of both kinds of type-guard property.</source>
          <target state="translated">이 섹션에서는 두 종류의 type-guard 속성에 대한 예제를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="306aadf682fc11264f3cfeb1c732892c12664c75" translate="yes" xml:space="preserve">
          <source>This section shows how to animate elements entering or leaving a page.</source>
          <target state="translated">이 섹션에서는 페이지에 들어가거나 나가는 요소에 애니메이션을 적용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3b6e09c67f8a39342ff4c0257fcd5cc67bae2f2c" translate="yes" xml:space="preserve">
          <source>This section shows how to create asynchronous validators. It assumes some basic knowledge of creating &lt;a href=&quot;form-validation#custom-validators&quot;&gt;custom validators&lt;/a&gt;.</source>
          <target state="translated">이 섹션에서는 비동기 유효성 검사기를 만드는 방법을 보여줍니다. &lt;a href=&quot;form-validation#custom-validators&quot;&gt;사용자 정의 유효성 검사기&lt;/a&gt; 를 만드는 데 대한 기본 지식이 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="c1876bae15f4c669767ab3331f67eef88c5960e8" translate="yes" xml:space="preserve">
          <source>This section shows how to perform cross field validation. It assumes some basic knowledge of creating custom validators.</source>
          <target state="translated">이 섹션에서는 교차 필드 유효성 검사를 수행하는 방법을 보여줍니다. 사용자 지정 유효성 검사기를 만드는 데 대한 기본 지식이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="d5c59841ebf0b19060f6d7b48397f23337988937" translate="yes" xml:space="preserve">
          <source>This section shows you how refactor the app into different feature modules, import them into the main module and navigate among them.</source>
          <target state="translated">이 섹션에서는 앱을 여러 기능 모듈로 리팩터링하고 기본 모듈로 가져 와서 탐색하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="75b7c3faa674491b569ef3f7a4a266fb1b70aa3c" translate="yes" xml:space="preserve">
          <source>This section shows you how to add child routes and use relative routing in your app.</source>
          <target state="translated">이 섹션에서는 앱에서 하위 경로를 추가하고 상대 라우팅을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="40c08e782b8b4dce59c05abd346b382ec356f9f6" translate="yes" xml:space="preserve">
          <source>This section shows you how to add some &lt;a href=&quot;animations&quot;&gt;animations&lt;/a&gt; to the &lt;code&gt;HeroDetailComponent&lt;/code&gt;.</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 에&lt;a href=&quot;animations&quot;&gt;애니메이션&lt;/a&gt; 을 추가하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="28698d05d33f5b1671f713ab414eca9161933dd5" translate="yes" xml:space="preserve">
          <source>This section shows you how to organize the crisis center to conform to the following recommended pattern for Angular applications:</source>
          <target state="translated">이 섹션에서는 Angular 애플리케이션에 대해 다음 권장 패턴을 준수하도록 위기 센터를 구성하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6e5105772fe1e30775a6f76ca44803f4e4116d09" translate="yes" xml:space="preserve">
          <source>This section shows you how to use the HTTP client to retrieve shipping prices from an external file.</source>
          <target state="translated">이 섹션에서는 HTTP 클라이언트를 사용하여 외부 파일에서 배송비를 검색하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e00ccb32c33d8d2804037de8c12b3f968f52ceea" translate="yes" xml:space="preserve">
          <source>This section shows you how to use the cart service to display the products in the cart.</source>
          <target state="translated">이 섹션에서는 카트 서비스를 사용하여 카트에있는 제품을 표시하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="8555832b3f593de35864e26800451467378353f6" translate="yes" xml:space="preserve">
          <source>This section takes inventory of the most useful Angular testing features and summarizes what they do.</source>
          <target state="translated">이 섹션에서는 가장 유용한 Angular 테스트 기능의 인벤토리를 살펴보고 그 기능을 요약합니다.</target>
        </trans-unit>
        <trans-unit id="e477486420bece3d0d8e61799151b739e8e6daf2" translate="yes" xml:space="preserve">
          <source>This section walks you through adding a form-based checkout feature to collect user information as part of checkout.</source>
          <target state="translated">이 섹션에서는 체크 아웃의 일부로 사용자 정보를 수집하기 위해 양식 기반 체크 아웃 기능을 추가하는 방법을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="87e4800653dc5aadd7144d1a9d30485a59601d33" translate="yes" xml:space="preserve">
          <source>This section walks you through using the cart service to add a product to the cart with a &quot;Buy&quot; button.</source>
          <target state="translated">이 섹션에서는 카트 서비스를 사용하여 &quot;구매&quot;버튼으로 카트에 제품을 추가하는 방법을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="15bf3c33e1424399ab26287ac6065fe7557dd98a" translate="yes" xml:space="preserve">
          <source>This setup also calls &lt;code&gt;TestBed.get()&lt;/code&gt; to inject the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; service and the mocking controller so they can be referenced during the tests.</source>
          <target state="translated">이 설정은 또한 &lt;code&gt;TestBed.get()&lt;/code&gt; 을 호출 하여 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 서비스와 조롱 컨트롤러 를 주입 하여 테스트 중에 참조 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="c78041ba40d1fbcc918dbb701fe401ee868f8518" translate="yes" xml:space="preserve">
          <source>This setup also calls &lt;code&gt;TestBed.inject()&lt;/code&gt; to inject the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; service and the mocking controller so they can be referenced during the tests.</source>
          <target state="translated">이 설정은 &lt;code&gt;TestBed.inject()&lt;/code&gt; 를 호출 하여 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 서비스와 모의 컨트롤러 를 삽입 하여 테스트 중에 참조 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="456f1cff8a28d651f522a6a70eb2cb94a641a08f" translate="yes" xml:space="preserve">
          <source>This setup guide uses the &lt;a href=&quot;https://docs.npmjs.com/cli/install&quot;&gt;npm client&lt;/a&gt; command line interface, which is installed with &lt;code&gt;Node.js&lt;/code&gt; by default.</source>
          <target state="translated">이 설정 안내서는 기본적 으로 &lt;code&gt;Node.js&lt;/code&gt; 와 함께 설치되는 &lt;a href=&quot;https://docs.npmjs.com/cli/install&quot;&gt;npm 클라이언트&lt;/a&gt; 명령 행 인터페이스를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="92609043e3a5049fe9cf167aad090f47caad57aa" translate="yes" xml:space="preserve">
          <source>This simple rule factory returns the tree without modification. The options are the option values passed through from the &lt;code&gt;ng generate&lt;/code&gt; command.</source>
          <target state="translated">이 간단한 규칙 팩토리는 수정없이 트리를 반환합니다. 옵션은 &lt;code&gt;ng generate&lt;/code&gt; 명령 에서 전달 된 옵션 값 입니다.</target>
        </trans-unit>
        <trans-unit id="3d73db06502687b0e565f94857691c977b98bee9" translate="yes" xml:space="preserve">
          <source>This small test demonstrates how Angular tests can verify a component's visual representation&amp;mdash;something not possible with &lt;a href=&quot;testing#component-class-testing&quot;&gt;component class tests&lt;/a&gt;&amp;mdash;at low cost and without resorting to much slower and more complicated end-to-end tests.</source>
          <target state="translated">이 작은 테스트는 Angular 테스트가 &lt;a href=&quot;testing#component-class-testing&quot;&gt;구성 요소 클래스 테스트로는&lt;/a&gt; 불가능한 구성 요소의 시각적 표현을 저렴하고 더 느리고 복잡한 엔드 투 엔드 테스트에 의존하지 않고 어떻게 확인할 수 있는지 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="5fd279f89c1525d18c06d2c05403b810e6621320" translate="yes" xml:space="preserve">
          <source>This small test demonstrates how Angular tests can verify a component's visual representation&amp;mdash;something not possible with &lt;a href=&quot;testing-components-basics#component-class-testing&quot;&gt;component class tests&lt;/a&gt;&amp;mdash;at low cost and without resorting to much slower and more complicated end-to-end tests.</source>
          <target state="translated">이 작은 테스트는 Angular 테스트가 구성 요소의 시각적 표현 ( &lt;a href=&quot;testing-components-basics#component-class-testing&quot;&gt;구성 요소 클래스 테스트로는&lt;/a&gt; 불가능한 일)을 저렴한 비용으로 훨씬 느리고 복잡한 종단 간 테스트에 의존하지 않고 확인할 수있는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="cb009288ce29b0288afe49f6ee2aab850b60725f" translate="yes" xml:space="preserve">
          <source>This snapshot reflects the state of the log after the user clicked the &lt;em&gt;Create...&lt;/em&gt; button and then the &lt;em&gt;Destroy...&lt;/em&gt; button.</source>
          <target state="translated">이 스냅 샷은 사용자가 &lt;em&gt;Create ...&lt;/em&gt; 버튼을 클릭 한 다음 &lt;em&gt;Destroy ...&lt;/em&gt; 버튼 을 클릭 한 후의 로그 상태를 반영 합니다.</target>
        </trans-unit>
        <trans-unit id="3191364fc32b6e08abc6a27512ac0807ec66c575" translate="yes" xml:space="preserve">
          <source>This step serves a purpose analogous to &lt;a href=&quot;../api/core/testing/tick&quot;&gt;tick()&lt;/a&gt; and &lt;code&gt;whenStable()&lt;/code&gt; in the earlier &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/core/testing/waitforasync&quot;&gt;waitForAsync&lt;/a&gt;()&lt;/code&gt; examples. The balance of the test is the same as those examples.</source>
          <target state="translated">이 단계는 이전 &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; () 및 &lt;code&gt;&lt;a href=&quot;../api/core/testing/waitforasync&quot;&gt;waitForAsync&lt;/a&gt;()&lt;/code&gt; () 예제의 &lt;a href=&quot;../api/core/testing/tick&quot;&gt;tick ()&lt;/a&gt; 및 &lt;code&gt;whenStable()&lt;/code&gt; 과 유사한 목적으로 사용 됩니다. 테스트의 균형은 해당 예제와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="079dfe1488f95b55bfe4eaaff729c5ed46abb14d" translate="yes" xml:space="preserve">
          <source>This step serves a purpose analogous to &lt;code&gt;&lt;a href=&quot;../api/core/applicationref#tick&quot;&gt;tick()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;whenStable()&lt;/code&gt; in the earlier &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt; examples. The balance of the test is the same as those examples.</source>
          <target state="translated">이 단계는 이전 &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; () 및 &lt;code&gt;&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt; () 예제의 &lt;code&gt;&lt;a href=&quot;../api/core/applicationref#tick&quot;&gt;tick()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;whenStable()&lt;/code&gt; 과 유사한 목적을 제공합니다 . 테스트의 균형은 해당 예제와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="dd15d4d4538f8653d2b222f1a75f8aaa65446a2d" translate="yes" xml:space="preserve">
          <source>This strategy allows you to continue to build your web application to support multiple browsers, but only load the necessary code that the browser needs.</source>
          <target state="translated">이 전략을 통해 여러 브라우저를 지원하도록 웹 응용 프로그램을 계속 구축 할 수 있지만 브라우저에 필요한 코드 만로드하십시오.</target>
        </trans-unit>
        <trans-unit id="a6549f07c80220a17e94351180403481dcd649c2" translate="yes" xml:space="preserve">
          <source>This strategy allows you to continue to build your web application to support multiple browsers, but only load the necessary code that the browser needs. For more information about how this works, see &lt;a href=&quot;deployment#differential-loading&quot;&gt;Differential Loading&lt;/a&gt; in the &lt;a href=&quot;deployment&quot;&gt;Deployment guide&lt;/a&gt;.</source>
          <target state="translated">이 전략을 통해 여러 브라우저를 지원하도록 웹 응용 프로그램을 계속 구축 할 수 있지만 브라우저에 필요한 코드 만로드하십시오. 작동 방식에 대한 자세한 내용은 &lt;a href=&quot;deployment&quot;&gt;배포 안내서의 &lt;/a&gt;&lt;a href=&quot;deployment#differential-loading&quot;&gt;차등로드&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e609b20e1c574bc355c924ed6553ac80401ff0e8" translate="yes" xml:space="preserve">
          <source>This strategy does not store any routes for later reuse.</source>
          <target state="translated">이 전략은 나중에 다시 사용할 수 있도록 경로를 저장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d7f27f72ef1db3f4b8e0b64ac49c35d1b3d860d4" translate="yes" xml:space="preserve">
          <source>This strategy is enabled by default.</source>
          <target state="translated">이 전략은 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7c2cab4ddb78ce7228d94edd854eab1d7580006d" translate="yes" xml:space="preserve">
          <source>This stricter type checking is not enabled by default in version 9, but can be enabled by setting the &lt;code&gt;strictTemplates&lt;/code&gt; configuration option. We do expect to make strict type checking the default in the future.</source>
          <target state="translated">&lt;code&gt;strictTemplates&lt;/code&gt; 엄격한 유형 검사는 버전 9에서 기본적으로 활성화되지 않지만 strictTemplates 구성 옵션 을 설정하여 활성화 할 수 있습니다 . 앞으로 엄격한 유형 검사를 기본값으로 할 예정입니다.</target>
        </trans-unit>
        <trans-unit id="8c4a67f46bf55c4aa1042894ef01b904f273ef12" translate="yes" xml:space="preserve">
          <source>This style guide is for anyone who contributes to the Angular documentation (this site). These guidelines should be followed by all authors. Deviations must be approved by a documentation editor.</source>
          <target state="translated">이 스타일 가이드는 Angular 문서 (이 사이트)에 기여하는 모든 사람을위한 것입니다. 이 지침은 모든 저자가 따라야합니다. 편차는 문서 편집자의 승인을 받아야합니다.</target>
        </trans-unit>
        <trans-unit id="b4dc934e925dfc611be024d59208b2dd13b6d211" translate="yes" xml:space="preserve">
          <source>This syntax conforms to the &lt;a href=&quot;http://userguide.icu-project.org/formatparse/messages&quot;&gt;ICU Message Format&lt;/a&gt; as specified in the &lt;a href=&quot;http://cldr.unicode.org/index/cldr-spec/plural-rules&quot;&gt;CLDR pluralization rules&lt;/a&gt;.</source>
          <target state="translated">이 구문 은 &lt;a href=&quot;http://cldr.unicode.org/index/cldr-spec/plural-rules&quot;&gt;CLDR 복수 규칙에&lt;/a&gt; 지정된 &lt;a href=&quot;http://userguide.icu-project.org/formatparse/messages&quot;&gt;ICU 메시지 형식&lt;/a&gt; 을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="a921404409acb321a0300d0ef76d994ae2a236f1" translate="yes" xml:space="preserve">
          <source>This syntax tells the Angular compiler to read the external files during component compilation.</source>
          <target state="translated">이 구문은 Angular 컴파일러에게 구성 요소 컴파일 중에 외부 파일을 읽도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="f054420c1ce338910d0afb64bdc92e93d64d0562" translate="yes" xml:space="preserve">
          <source>This technique can improve performance on mobile and low-powered devices and improve the user experience by showing a static first page quickly while the client-side app is loading. The static version can also make your app more visible to web crawlers.</source>
          <target state="translated">이 기술은 클라이언트 측 앱이로드되는 동안 정적 첫 페이지를 빠르게 표시하여 모바일 및 저전력 장치의 성능을 향상시키고 사용자 경험을 향상시킬 수 있습니다. 정적 버전을 사용하면 웹 크롤러가 앱을 더 잘 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac27da6a3425110fb4858d56fa56042a9d64c44f" translate="yes" xml:space="preserve">
          <source>This technique is effective because all browsers implement the &lt;em&gt;same origin policy&lt;/em&gt;. Only code from the website on which cookies are set can read the cookies from that site and set custom headers on requests to that site. That means only your application can read this cookie token and set the custom header. The malicious code on &lt;code&gt;evil.com&lt;/code&gt; can't.</source>
          <target state="translated">이 기술은 모든 브라우저가 &lt;em&gt;동일한 원본 정책을&lt;/em&gt; 구현하기 때문에 효과적 입니다. 쿠키가 설정된 웹 사이트의 코드 만 해당 사이트에서 쿠키를 읽고 해당 사이트에 대한 요청에 사용자 지정 헤더를 설정할 수 있습니다. 즉, 애플리케이션 만이 쿠키 토큰을 읽고 사용자 정의 헤더를 설정할 수 있습니다. &lt;code&gt;evil.com&lt;/code&gt; 의 악성 코드는 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="edaf5e02d43ccc1019d65ebdfbccee03f175b8c8" translate="yes" xml:space="preserve">
          <source>This technique is suitable for setting a single style, but consider the &lt;a href=&quot;template-syntax#ngStyle&quot;&gt;&lt;code&gt;NgStyle&lt;/code&gt;&lt;/a&gt; directive when setting several inline styles at the same time.</source>
          <target state="translated">이 기술은 단일 스타일을 설정하는 데 적합하지만 여러 인라인 스타일을 동시에 설정할 때는 &lt;a href=&quot;template-syntax#ngStyle&quot;&gt; &lt;code&gt;NgStyle&lt;/code&gt; &lt;/a&gt; 지시문을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="f819a7b1e0aafa1d2068ac4808d42099765b1fd4" translate="yes" xml:space="preserve">
          <source>This technique works for any attribute of any element.</source>
          <target state="translated">이 기술은 모든 요소의 모든 속성에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c1e03a2b5a2ead7f58623d3d33ead88c0cbed81a" translate="yes" xml:space="preserve">
          <source>This tells the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; preloader to immediately load &lt;em&gt;all&lt;/em&gt; lazy loaded routes (routes with a &lt;code&gt;&lt;a href=&quot;../api/router/route#loadChildren&quot;&gt;loadChildren&lt;/a&gt;&lt;/code&gt; property).</source>
          <target state="translated">이렇게하면 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 프리 로더가 지연로드 된 &lt;em&gt;모든&lt;/em&gt; 라우트 ( &lt;code&gt;&lt;a href=&quot;../api/router/route#loadChildren&quot;&gt;loadChildren&lt;/a&gt;&lt;/code&gt; 특성 이있는 라우트) 를 즉시로드하도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="02a67f3677df899c9872b4c722cacd0ea9415c83" translate="yes" xml:space="preserve">
          <source>This tells the router to match that URL to &lt;code&gt;path: 'heroes'&lt;/code&gt; and display the &lt;code&gt;HeroesComponent&lt;/code&gt; when the URL is something like &lt;code&gt;localhost:4200/heroes&lt;/code&gt;.</source>
          <target state="translated">이것은 라우터에게 해당 URL을 &lt;code&gt;path: 'heroes'&lt;/code&gt; 와 일치 시키고 URL이 &lt;code&gt;localhost:4200/heroes&lt;/code&gt; 와 같은 경우 &lt;code&gt;HeroesComponent&lt;/code&gt; 를 표시하도록 지시 합니다 .</target>
        </trans-unit>
        <trans-unit id="ec46416c5da71796079b783f64e64dd6e3d3f4fd" translate="yes" xml:space="preserve">
          <source>This template applies the &lt;code&gt;SpyDirective&lt;/code&gt; to a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt;&lt;em&gt;hero&lt;/em&gt; repeater managed by the parent &lt;code&gt;SpyComponent&lt;/code&gt;.</source>
          <target state="translated">이 템플릿 은 상위 &lt;code&gt;SpyComponent&lt;/code&gt; 에 의해 관리되는 &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; &lt;em&gt; hero&lt;/em&gt; repeater 의 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 에 &lt;code&gt;SpyDirective&lt;/code&gt; 를 적용합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b56327c98c0651adf92a3962b35326d9411155a9" translate="yes" xml:space="preserve">
          <source>This template binds directly to the component's &lt;code&gt;messageService&lt;/code&gt;.</source>
          <target state="translated">이 템플릿은 구성 요소의 &lt;code&gt;messageService&lt;/code&gt; 에 직접 바인딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e9c43c15900050160dc8be35d6067a63318aec5" translate="yes" xml:space="preserve">
          <source>This template looks a lot like the &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; repeater in the &lt;code&gt;HeroesComponent&lt;/code&gt; template.</source>
          <target state="translated">이 템플릿은 &lt;code&gt;HeroesComponent&lt;/code&gt; 템플릿 의 &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 리피터 와 매우 비슷합니다 .</target>
        </trans-unit>
        <trans-unit id="d637ab123347ac13fe17a004c73c98b4dddb234f" translate="yes" xml:space="preserve">
          <source>This template uses typical HTML elements like &lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;, and also includes Angular template-syntax elements, &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;{{hero.name}}&lt;/code&gt;, &lt;code&gt;(click)&lt;/code&gt;, &lt;code&gt;[hero]&lt;/code&gt;, and &lt;code&gt;&amp;lt;app-hero-detail&amp;gt;&lt;/code&gt;. The template-syntax elements tell Angular how to render the HTML to the screen, using program logic and data.</source>
          <target state="translated">이 템플릿은 &lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; &amp;gt; 와 같은 일반적인 HTML 요소를 사용 하며 Angular 템플릿 구문 요소, &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;{{hero.name}}&lt;/code&gt; , &lt;code&gt;(click)&lt;/code&gt; , &lt;code&gt;[hero]&lt;/code&gt; 및 &lt;code&gt;&amp;lt;app-hero-detail&amp;gt;&lt;/code&gt; . 템플릿 구문 요소는 프로그램 로직과 데이터를 사용하여 HTML을 화면에 렌더링하는 방법을 Angular에 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="33f50f397f4ca96e33bfb10d036f4db70c1735c8" translate="yes" xml:space="preserve">
          <source>This test expects the component to try to navigate to the &lt;code&gt;HeroListComponent&lt;/code&gt;.</source>
          <target state="translated">이 테스트에서는 구성 요소가 &lt;code&gt;HeroListComponent&lt;/code&gt; 로 이동하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="501a5e4c0d88821fa944fe51ad014be796c1b208" translate="yes" xml:space="preserve">
          <source>This test host binds to &lt;code&gt;DashboardHeroComponent&lt;/code&gt; as the &lt;code&gt;DashboardComponent&lt;/code&gt; would but without the noise of the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;HeroService&lt;/code&gt;, or the &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; repeater.</source>
          <target state="translated">이 테스트 호스트는 &lt;code&gt;DashboardHeroComponent&lt;/code&gt; 처럼 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;HeroService&lt;/code&gt; 또는 &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt; 리피터 의 노이즈없이 &lt;code&gt;DashboardComponent&lt;/code&gt; 바인딩합니다 .</target>
        </trans-unit>
        <trans-unit id="6f65de663612898c193d6874b17e0426d7e59e43" translate="yes" xml:space="preserve">
          <source>This testing module configuration shows three important differences:</source>
          <target state="translated">이 테스트 모듈 구성은 세 가지 중요한 차이점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="750aba5f80080e328a3f7b0b79fa476b6891b62b" translate="yes" xml:space="preserve">
          <source>This text wraps around to the right of the floating &quot;flying hero&quot; image.</source>
          <target state="translated">이 텍스트는 떠 다니는 &quot;비행 영웅&quot;이미지의 오른쪽으로 둘러 쌉니다.</target>
        </trans-unit>
        <trans-unit id="113e418e350b558b02724dea8b12bbcc059f4851" translate="yes" xml:space="preserve">
          <source>This time you'll be navigating in the opposite direction, from the &lt;code&gt;HeroDetailComponent&lt;/code&gt; to the &lt;code&gt;HeroListComponent&lt;/code&gt;.</source>
          <target state="translated">이번에는 당신은에서 반대 방향으로 이동 수 있습니다 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 받는 &lt;code&gt;HeroListComponent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cefc645993bf706c88455dca56b4abc1e03879d3" translate="yes" xml:space="preserve">
          <source>This time, in addition to declaring the &lt;em&gt;component-under-test&lt;/em&gt;, the configuration adds a &lt;code&gt;UserService&lt;/code&gt; provider to the &lt;code&gt;providers&lt;/code&gt; list. But not the real &lt;code&gt;UserService&lt;/code&gt;.</source>
          <target state="translated">이번에는 &lt;em&gt;테스트 대상 구성 요소&lt;/em&gt; 를 선언하는 것 외에도 구성에서 &lt;code&gt;UserService&lt;/code&gt; 공급자를 &lt;code&gt;providers&lt;/code&gt; 목록에 추가 합니다. 그러나 실제 &lt;code&gt;UserService&lt;/code&gt; 는 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="af2165b1138d7807abb0f9b20b74189222b793e4" translate="yes" xml:space="preserve">
          <source>This time, the value of &lt;code&gt;'popup'&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;. That's not a route, but it is a legitimate value. Setting the popup &lt;code&gt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;RouterOutlet&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;null&lt;/code&gt; clears the outlet and removes the secondary popup route from the current URL.</source>
          <target state="translated">이번에는 &lt;code&gt;'popup'&lt;/code&gt; 값 이 &lt;code&gt;null&lt;/code&gt; 입니다. 그것은 경로가 아니지만 합법적 인 가치입니다. 팝업 &lt;code&gt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;RouterOutlet&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;null&lt;/code&gt; 로 설정하면 콘센트가 지워지고 현재 URL에서 보조 팝업 경로가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="40bbb2371cebbdf60ae15d1ec5b7666df5d5300a" translate="yes" xml:space="preserve">
          <source>This topic describes how to create and configure an Angular component.</source>
          <target state="translated">이 항목에서는 Angular 구성 요소를 만들고 구성하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5176ea8b8dc3fac7511f8583255f1137f947700f" translate="yes" xml:space="preserve">
          <source>This topic provides a conceptual overview of the different categories of &lt;a href=&quot;glossary#ngmodule&quot;&gt;NgModules&lt;/a&gt; you can create in order to organize your code in a modular structure. These categories are not cast in stone&amp;mdash;they are suggestions. You may want to create NgModules for other purposes, or combine the characteristics of some of these categories.</source>
          <target state="translated">이 항목에서는 모듈 식 구조로 코드를 구성하기 위해 만들 수 있는 &lt;a href=&quot;glossary#ngmodule&quot;&gt;NgModules&lt;/a&gt; 의 다양한 범주에 대한 개념적 개요를 제공합니다 . 이러한 범주는 돌로 던져진 것이 아니라 제안입니다. 다른 목적으로 NgModules를 만들거나 이러한 범주 중 일부의 특성을 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d92a7f4ae8e3f11ab9554b88f4a5af57e0a872c" translate="yes" xml:space="preserve">
          <source>This topic provides some guidelines for the following general categories of NgModules:</source>
          <target state="translated">이 항목에서는 NgModules의 다음과 같은 일반 범주에 대한 몇 가지 지침을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="21b58f299c596628607bfe82d7a2f31208c5268b" translate="yes" xml:space="preserve">
          <source>This tutorial describes how you can build a single-page application, SPA that uses multiple Angular routes.</source>
          <target state="translated">이 자습서에서는 여러 Angular 경로를 사용하는 단일 페이지 애플리케이션 SPA를 빌드하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1017b080efe853ab4a37570f7704ed1185bde730" translate="yes" xml:space="preserve">
          <source>This tutorial introduces you to the essentials of Angular by walking you through a simple e-commerce site with a catalog, shopping cart, and check-out form. To help you get started right away, this guide uses a simple ready-made application that you can examine and modify interactively (without having to &lt;a href=&quot;guide/setup-local&quot;&gt;set up a local work environment&lt;/a&gt;).</source>
          <target state="translated">이 튜토리얼은 카탈로그, 쇼핑 카트 및 체크 아웃 양식이있는 간단한 전자 상거래 사이트를 안내하여 Angular의 필수 사항을 소개합니다. 바로 시작할 수 있도록이 가이드에서는 &lt;a href=&quot;guide/setup-local&quot;&gt;로컬 작업 환경&lt;/a&gt; 을 설정 하지 않고도 대화 형으로 검사하고 수정할 수있는 간단한 기성 애플리케이션을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="4d58a98a6b42341e9f6814cfed96b99344da3020" translate="yes" xml:space="preserve">
          <source>This tutorial introduces you to the essentials of Angular by walking you through building a simple e-commerce site with a catalog, shopping cart, and check-out form. It uses the &lt;a href=&quot;https://stackblitz.com/&quot;&gt;StackBlitz&lt;/a&gt; online development environment so you can get started right away.</source>
          <target state="translated">이 튜토리얼은 카탈로그, 쇼핑 카트 및 체크 아웃 양식으로 간단한 전자 상거래 사이트를 구축하는 과정을 안내하여 Angular의 필수 사항을 소개합니다. 그것은 사용 &lt;a href=&quot;https://stackblitz.com/&quot;&gt;StackBlitz&lt;/a&gt; 당신이 바로 시작할 수 있도록 온라인 개발 환경을.</target>
        </trans-unit>
        <trans-unit id="75cca6ba2330a0de32bc9736198f0aa60de95f31" translate="yes" xml:space="preserve">
          <source>This tutorial provides an extensive overview of the Angular router. In this tutorial, you will build upon a basic router configuration to explore features such as child routes, route parameters, lazy load NgModules, guard routes, and preloading data to improve the user experience.</source>
          <target state="translated">이 튜토리얼은 Angular 라우터에 대한 광범위한 개요를 제공합니다. 이 자습서에서는 기본 라우터 구성을 기반으로하여 하위 경로, 경로 매개 변수, 지연로드 NgModules, 보호 경로, 데이터 사전로드와 같은 기능을 탐색하여 사용자 경험을 개선합니다.</target>
        </trans-unit>
        <trans-unit id="4be47255fc4c07ae300b4da88c16205f91d089d6" translate="yes" xml:space="preserve">
          <source>This tutorial sample mimics communication with a remote data server by using the &lt;a href=&quot;https://github.com/angular/in-memory-web-api&quot;&gt;In-memory Web API&lt;/a&gt; module.</source>
          <target state="translated">이 학습서 샘플은 &lt;a href=&quot;https://github.com/angular/in-memory-web-api&quot;&gt;인 메모리 웹 API&lt;/a&gt; 모듈 을 사용하여 원격 데이터 서버와의 통신을 모방 합니다.</target>
        </trans-unit>
        <trans-unit id="bc3024b13e02f53d3e498300f1c2e6300a2d72b3" translate="yes" xml:space="preserve">
          <source>This tutorial shows how to build a a questionaire, which is just one kind of dynamic form. The example uses &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; to collect a set of controls. For an example of a different type of dynamic form, see the section &lt;a href=&quot;reactive-forms#creating-dynamic-forms&quot;&gt;Creating dynamic forms&lt;/a&gt; in the Reactive Forms guide. That example also shows how to use &lt;code&gt;&lt;a href=&quot;../api/forms/formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; to collect a set of controls.</source>
          <target state="translated">이 튜토리얼에서는 동적 양식의 한 종류 인 설문지를 작성하는 방법을 보여줍니다. 이 예제에서는 &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 을 사용 하여 컨트롤 집합을 수집합니다. 다른 유형의 동적 양식의 예 는 반응 양식 가이드의 &lt;a href=&quot;reactive-forms#creating-dynamic-forms&quot;&gt;동적 양식 만들기&lt;/a&gt; 섹션을 참조하세요 . 이 예제에서는 &lt;code&gt;&lt;a href=&quot;../api/forms/formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 를 사용하여 컨트롤 집합을 수집하는 방법도 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="5ab45a75c827944992e1db362a0b5c036c3ecd7e" translate="yes" xml:space="preserve">
          <source>This tutorial shows you how to build a form from scratch, using a simplified sample form like the one from the &lt;a href=&quot;tutorial&quot;&gt;Tour of Heroes tutorial&lt;/a&gt; to illustrate the techniques.</source>
          <target state="translated">이 자습서에서는 &lt;a href=&quot;tutorial&quot;&gt;Tour of Heroes 자습서&lt;/a&gt; 와 같은 간단한 샘플 양식을 사용 하여 기술을 설명 하여 처음부터 양식을 작성하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="52b747de47c76fdb387428a809e8e59e74cebd64" translate="yes" xml:space="preserve">
          <source>This tutorial shows you how to create a template-driven form whose control elements are bound to data properties, with input validation to maintain data integrity and styling to improve the user experience.</source>
          <target state="translated">이 자습서에서는 제어 요소가 데이터 속성에 바인딩 된 템플릿 기반 양식을 만드는 방법을 보여줍니다. 입력 유효성 검사를 통해 데이터 무결성을 유지하고 스타일을 지정하여 사용자 환경을 개선하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="bb98a6fecbbb46c54191cd7e4fdf79d8bfd8c9d6" translate="yes" xml:space="preserve">
          <source>This tutorial teaches you how to do the following:</source>
          <target state="translated">이 튜토리얼은 다음을 수행하는 방법을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="d9d67a376ed76f9dd9f3998880f05555c2f237ea" translate="yes" xml:space="preserve">
          <source>This user experience is the developer's choice. Some developers want the message to display at all times. If you ignore the &lt;code&gt;pristine&lt;/code&gt; state, you would hide the message only when the value is valid. If you arrive in this component with a new (blank) hero or an invalid hero, you'll see the error message immediately, before you've done anything.</source>
          <target state="translated">이 사용자 경험은 개발자의 선택입니다. 일부 개발자는 메시지가 항상 표시되기를 원합니다. &lt;code&gt;pristine&lt;/code&gt; 상태 를 무시 하면 값이 유효한 경우에만 메시지를 숨길 수 있습니다. 새로운 (공백) 영웅이나 유효하지 않은 영웅과 함께이 구성 요소에 도착하면 아무 작업도 수행하기 전에 즉시 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f2e4047e551556a93bbd7f194989120c57f25bea" translate="yes" xml:space="preserve">
          <source>This value accessor is used by default for &lt;code&gt;&amp;lt;input type=&quot;text&quot;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;a href=&quot;defaultvalueaccessor&quot;&gt;textarea&lt;/a&gt;&amp;gt;&lt;/code&gt; elements, but you could also use it for custom components that have similar behavior and do not require special processing. In order to attach the default value accessor to a custom element, add the &lt;code&gt;&lt;a href=&quot;defaultvalueaccessor&quot;&gt;ngDefaultControl&lt;/a&gt;&lt;/code&gt; attribute as shown below.</source>
          <target state="translated">이 값 접근자는 기본적으로 &lt;code&gt;&amp;lt;input type=&quot;text&quot;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;&lt;a href=&quot;defaultvalueaccessor&quot;&gt;textarea&lt;/a&gt;&amp;gt;&lt;/code&gt; 요소에 사용되지만 유사한 동작이 있고 특별한 처리가 필요하지 않은 사용자 지정 구성 요소에도 사용할 수 있습니다. 기본값 접근자를 사용자 지정 요소에 연결하려면 아래와 같이 &lt;code&gt;&lt;a href=&quot;defaultvalueaccessor&quot;&gt;ngDefaultControl&lt;/a&gt;&lt;/code&gt; 특성을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="7fe52a203b046ba6736edeae46dcac27488617b9" translate="yes" xml:space="preserve">
          <source>This version of the &lt;code&gt;HeroListComponent&lt;/code&gt; gets heroes from the &lt;code&gt;HEROES&lt;/code&gt; array, an in-memory collection defined in a separate &lt;code&gt;mock-heroes&lt;/code&gt; file.</source>
          <target state="translated">이 버전의 &lt;code&gt;HeroListComponent&lt;/code&gt; 는 별도의 &lt;code&gt;mock-heroes&lt;/code&gt; 파일에 정의 된 메모리 내 컬렉션 인 &lt;code&gt;HEROES&lt;/code&gt; 배열 에서 영웅을 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="5ac5c50e4fc7fc8f690f46a387d86d6cd4e8a480" translate="yes" xml:space="preserve">
          <source>This will call the &lt;code&gt;ls&lt;/code&gt; command instead of the &lt;code&gt;touch&lt;/code&gt; command. Because we did not override the &lt;em&gt;args&lt;/em&gt; option, it will list information about the &lt;code&gt;src/main.ts&lt;/code&gt; file (the default value provided for the target).</source>
          <target state="translated">&lt;code&gt;touch&lt;/code&gt; 명령 대신 &lt;code&gt;ls&lt;/code&gt; 명령 을 호출합니다 . &lt;em&gt;args&lt;/em&gt; 옵션을 재정의하지 않았으므로 &lt;code&gt;src/main.ts&lt;/code&gt; 파일 (대상에 제공된 기본값) 에 대한 정보가 나열됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2d850926d891f5f4c805e3e17fdc18eb990f42f2" translate="yes" xml:space="preserve">
          <source>This will essentially do the following:</source>
          <target state="translated">이것은 본질적으로 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9312003f28c3729ef201319a34848ad897938e4a" translate="yes" xml:space="preserve">
          <source>This will install the command &lt;code&gt;ng&lt;/code&gt; into your system, which is the command you use to create new workspaces, new projects, serve your application during development, or produce builds that can be shared or distributed.</source>
          <target state="translated">그러면 &lt;code&gt;ng&lt;/code&gt; 명령이 시스템에 설치됩니다.이 명령 은 새 작업 공간, 새 프로젝트를 작성하거나 개발 중에 응용 프로그램을 제공하거나 공유 또는 분배 할 수있는 빌드를 작성하는 데 사용하는 명령입니다.</target>
        </trans-unit>
        <trans-unit id="9bb5987cb75dc888fb534638627a4e1a3c031126" translate="yes" xml:space="preserve">
          <source>This will not work in a real app. You're getting away with it now because the service currently returns &lt;em&gt;mock heroes&lt;/em&gt;. But soon the app will fetch heroes from a remote server, which is an inherently &lt;em&gt;asynchronous&lt;/em&gt; operation.</source>
          <target state="translated">실제 앱에서는 작동하지 않습니다. 이 서비스는 현재 &lt;em&gt;모의 영웅을&lt;/em&gt; 반환하기 때문에 지금 당장 벗어나고 있습니다 . 그러나 곧 앱은 원격 서버에서 영웅을 가져옵니다 . 이는 본질적으로 &lt;em&gt;비동기&lt;/em&gt; 작업입니다.</target>
        </trans-unit>
        <trans-unit id="c8a4d0a01462100bf09cd9c7a8827ae3dcb63eb8" translate="yes" xml:space="preserve">
          <source>This will produce the files that you need to deploy.</source>
          <target state="translated">배포해야하는 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="9b630be3829ca4b43f0c0f13ae624094630240e5" translate="yes" xml:space="preserve">
          <source>This will run the &lt;code&gt;touch&lt;/code&gt; command on the &lt;code&gt;src/main.ts&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;src/main.ts&lt;/code&gt; 파일 에서 &lt;code&gt;touch&lt;/code&gt; 명령 이 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="4fb5514b164bef25ddca759f879da4b392519146" translate="yes" xml:space="preserve">
          <source>This will set the active-link class on the div tag if the url is either '/user/jim' or '/user/bob'.</source>
          <target state="translated">URL이 '/ user / jim'또는 '/ user / bob'인 경우 div 태그에서 활성 링크 클래스를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d430f7cac5ea324357497bb1e85a43cc3ac98f1a" translate="yes" xml:space="preserve">
          <source>This won't work if the service is an application-wide singleton. Every component would share the same service instance, and each component would overwrite the tax return that belonged to another hero.</source>
          <target state="translated">서비스가 응용 프로그램 전체의 싱글 톤 인 경우 작동하지 않습니다. 모든 구성 요소는 동일한 서비스 인스턴스를 공유하며 각 구성 요소는 다른 영웅에 속한 세금 보고서를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="66ee2090966d8e328167f9dd11bd703bc89361b7" translate="yes" xml:space="preserve">
          <source>This worked well, but there's a better way. If you were using a real world API, there might be some delay before the data to display is returned from the server. You don't want to display a blank component while waiting for the data.</source>
          <target state="translated">이것은 잘 작동했지만 더 좋은 방법이 있습니다. 실제 API를 사용하는 경우 표시 할 데이터가 서버에서 리턴되기 전에 약간의 지연이있을 수 있습니다. 데이터를 기다리는 동안 빈 구성 요소를 표시하고 싶지 않습니다.</target>
        </trans-unit>
        <trans-unit id="61821e653cb092afa1d5fad2bdbb72bc70644e00" translate="yes" xml:space="preserve">
          <source>Those developers may still use HTML5 URLs by taking the following two steps:</source>
          <target state="translated">이러한 개발자는 다음 두 단계를 수행하여 HTML5 URL을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3030da2c36d0ffb5bb1a38f3d3ab06bd0ba9aebe" translate="yes" xml:space="preserve">
          <source>Those developers may still use HTML5 URLs by taking two remedial steps:</source>
          <target state="translated">이러한 개발자는 두 가지 수정 단계를 수행하여 HTML5 URL을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4c3697ed1231b34be5a06d277ed21d7aec6aac6" translate="yes" xml:space="preserve">
          <source>Those three steps look like the following. In the file where you create your directive, export it. The following example, named &lt;code&gt;ItemDirective&lt;/code&gt; is the default directive structure that the CLI generates in its own file, &lt;code&gt;item.directive.ts&lt;/code&gt;:</source>
          <target state="translated">이 세 단계는 다음과 같습니다. 지시문을 작성하는 파일에서 내보내십시오. &lt;code&gt;ItemDirective&lt;/code&gt; 라는 다음 예제 는 CLI가 자체 파일 &lt;code&gt;item.directive.ts&lt;/code&gt; 에서 생성하는 기본 지시문 구조입니다 .</target>
        </trans-unit>
        <trans-unit id="7282182d46ba8591a3fb80eb88450d7e6e0fb75f" translate="yes" xml:space="preserve">
          <source>Though &lt;a href=&quot;template-syntax#template-expressions&quot;&gt;template expressions&lt;/a&gt; shouldn't have &lt;a href=&quot;template-syntax#avoid-side-effects&quot;&gt;side effects&lt;/a&gt;, template statements usually do. The &lt;code&gt;deleteItem()&lt;/code&gt; method does have a side effect: it deletes an item.</source>
          <target state="translated">&lt;a href=&quot;template-syntax#template-expressions&quot;&gt;템플릿 표현식&lt;/a&gt; 에는 &lt;a href=&quot;template-syntax#avoid-side-effects&quot;&gt;부작용이&lt;/a&gt; 없어야 하지만 일반적으로 템플릿 문 에는 부작용 이 없습니다 . &lt;code&gt;deleteItem()&lt;/code&gt; 메소드는 부작용을 가지고 :이 항목을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="8b45283f651e66eedd857eedb3d79dccba5ecff8" translate="yes" xml:space="preserve">
          <source>Though &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; provides the 🌻 (sunflower), the app renders the 🌺 (red hibiscus) because &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; causes the current injector to skip itself and look to its parent.</source>
          <target state="translated">&lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; 는 🌻 (해바라기)을 제공 하지만 &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; 인해 현재 인젝터가 자체적으로 건너 뛰고 부모를 찾게 되므로 앱은 🌺 (빨간색 히비스커스)을 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="1075a1e80e7f93a1f8a46fd5766714abf59a2e2d" translate="yes" xml:space="preserve">
          <source>Though &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; often appear together in apps, you can use them separately. If the nested component is such that it only needs to send data to its parent, you wouldn't need an &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt;, only an &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt;. The reverse is also true in that if the child only needs to receive data from the parent, you'd only need &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt;.</source>
          <target state="translated">하지만 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 와 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; 자주 개별적으로 사용할 수있는 앱에 함께 나타납니다. 중첩 된 구성 요소가 단지 부모에 데이터를 보낼 필요가 같은 경우, 당신은 필요가 없을 것입니다 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; , 단지 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; . 자식이 부모로부터 데이터를 수신 해야하는 경우 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 만 필요하다는 점에서도 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="76c63fbb51bf2e00185f379ad812f423247e2cf5" translate="yes" xml:space="preserve">
          <source>Though &lt;em&gt;highlight&lt;/em&gt; would be a more concise selector than &lt;em&gt;appHighlight&lt;/em&gt; and it would work, the best practice is to prefix selector names to ensure they don't conflict with standard HTML attributes. This also reduces the risk of colliding with third-party directive names. The CLI added the &lt;code&gt;app&lt;/code&gt; prefix for you.</source>
          <target state="translated">하지만 &lt;em&gt;하이라이트는&lt;/em&gt; 보다 더 간결 선택이 될 것입니다 &lt;em&gt;appHighlight&lt;/em&gt; 하고 일하는 것이, 가장 좋은 방법은 표준 HTML 속성과 충돌하지 않도록하는 접두사 선택기 이름이다. 또한 타사 지시문 이름과 충돌 할 위험이 줄어 듭니다. CLI가 &lt;code&gt;app&lt;/code&gt; 접두사를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="e7794513d8ab6b404efc84e17a85b45fb430b7cb" translate="yes" xml:space="preserve">
          <source>Though the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; decorator has an &lt;code&gt;entryComponents&lt;/code&gt; array, most of the time you won't have to explicitly set any entry components because Angular adds components listed in &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule#bootstrap&quot;&gt;NgModule.bootstrap&lt;/a&gt;&lt;/code&gt; and those in route definitions to entry components automatically. Though these two mechanisms account for most entry components, if your app happens to bootstrap or dynamically load a component by type imperatively, you must add it to &lt;code&gt;entryComponents&lt;/code&gt; explicitly.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 데코레이터에 &lt;code&gt;entryComponents&lt;/code&gt; 배열 이 있지만 Angular는 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule#bootstrap&quot;&gt;NgModule.bootstrap&lt;/a&gt;&lt;/code&gt; 나열된 구성 요소 와 경로 정의에있는 구성 요소를 자동으로 입력 구성 요소에 추가하므로 대부분 입력 구성 요소를 명시 적으로 설정할 필요가 없습니다 . 이 두 가지 메커니즘이 대부분의 입력 구성 요소를 설명하지만 앱이 유형별로 구성 요소를 부트 스트랩하거나 동적으로로드하는 경우 항목을 명시 적으로 &lt;code&gt;entryComponents&lt;/code&gt; 에 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c0c89634e88d4f46eb100cf74294ba38817d4923" translate="yes" xml:space="preserve">
          <source>Though the target name is usually the name of a property, there is an automatic attribute-to-property mapping in Angular for several common attributes. These include &lt;code&gt;class&lt;/code&gt;/&lt;code&gt;className&lt;/code&gt;, &lt;code&gt;innerHtml&lt;/code&gt;/&lt;code&gt;innerHTML&lt;/code&gt;, and &lt;code&gt;tabindex&lt;/code&gt;/&lt;code&gt;tabIndex&lt;/code&gt;.</source>
          <target state="translated">대상 이름은 일반적으로 속성 이름이지만 Angular에는 몇 가지 일반적인 속성에 대한 자동 속성 대 속성 매핑이 있습니다. 여기에는 &lt;code&gt;class&lt;/code&gt; / &lt;code&gt;className&lt;/code&gt; , &lt;code&gt;innerHtml&lt;/code&gt; / &lt;code&gt;innerHTML&lt;/code&gt; 및 &lt;code&gt;tabindex&lt;/code&gt; / &lt;code&gt;tabIndex&lt;/code&gt; 가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="6bdc5ca158e9ca814a1efdfbdd56e2547c9decdf" translate="yes" xml:space="preserve">
          <source>Though you can limit access to a service by providing it in a lazy loaded module or providing it in a component, providing services in a component can lead to multiple instances of those services. Thus, the lazy loading is preferable.</source>
          <target state="translated">지연로드 된 모듈로 제공하거나 구성 요소에서 제공하여 서비스에 대한 액세스를 제한 할 수 있지만 구성 요소에 서비스를 제공하면 해당 서비스의 여러 인스턴스가 발생할 수 있습니다. 따라서, 지연 로딩이 바람직하다.</target>
        </trans-unit>
        <trans-unit id="90e178c89e79710297fa1f0d8ae614004845fcca" translate="yes" xml:space="preserve">
          <source>Though you can provide services by lazy loading modules, not all services can be lazy loaded. For instance, some modules only work in the root module, such as the Router. The Router works with the global location object in the browser.</source>
          <target state="translated">지연로드 모듈로 서비스를 제공 할 수 있지만 모든 서비스가 지연로드 될 수있는 것은 아닙니다. 예를 들어 일부 모듈은 라우터와 같은 루트 모듈에서만 작동합니다. 라우터는 브라우저에서 전역 위치 개체와 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4ac43ae059a7abe0952abd693cdca4e55b219478" translate="yes" xml:space="preserve">
          <source>Though you can type the URL into the address bar, a navigation UI is easier for the user and more common. Replace the default placeholder markup in &lt;code&gt;app.component.html&lt;/code&gt; with a custom nav so you can easily navigate to your modules in the browser:</source>
          <target state="translated">주소 표시 줄에 URL을 입력 할 수 있지만 탐색 UI가 사용자에게 더 쉽고 일반적입니다. &lt;code&gt;app.component.html&lt;/code&gt; 의 기본 자리 표시 자 마크 업을 맞춤 탐색 메뉴 로 바꾸면 브라우저에서 모듈로 쉽게 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="528e1795eb218a5f3792808cc39b7bcce25ad8db" translate="yes" xml:space="preserve">
          <source>Though you could technically set the &lt;code&gt;[attr.disabled]&lt;/code&gt; attribute binding, the values are different in that the property binding requires to a boolean value, while its corresponding attribute binding relies on whether the value is &lt;code&gt;null&lt;/code&gt; or not. Consider the following:</source>
          <target state="translated">기술적으로 &lt;code&gt;[attr.disabled]&lt;/code&gt; 속성 바인딩을 설정할 수는 있지만 속성 바인딩에 필요한 값은 부울 값으로 다르지만 해당 속성 바인딩은 값이 &lt;code&gt;null&lt;/code&gt; 인지 여부에 따라 달라집니다 . 다음을 고려하세요:</target>
        </trans-unit>
        <trans-unit id="ab6a81da6264ab1813a6ae0bf0a2c52eb58c33e9" translate="yes" xml:space="preserve">
          <source>Though you could technically set the &lt;code&gt;[attr.disabled]&lt;/code&gt; attribute binding, the values are different in that the property binding requires to be a boolean value, while its corresponding attribute binding relies on whether the value is &lt;code&gt;null&lt;/code&gt; or not. Consider the following:</source>
          <target state="translated">기술적으로 &lt;code&gt;[attr.disabled]&lt;/code&gt; 속성 바인딩을 설정할 수 있지만 속성 바인딩이 부울 값이어야한다는 점에서 값이 다르지만 해당 속성 바인딩은 값이 &lt;code&gt;null&lt;/code&gt; 인지 여부에 따라 달라집니다 . 다음을 고려하세요:</target>
        </trans-unit>
        <trans-unit id="171a82320fbdf7d2e2689bc12c98963504c6696d" translate="yes" xml:space="preserve">
          <source>Three instances of &lt;code&gt;HeroBioComponent&lt;/code&gt; can't share the same instance of &lt;code&gt;HeroCacheService&lt;/code&gt;, as they'd be competing with each other to determine which hero to cache.</source>
          <target state="translated">3 개의 &lt;code&gt;HeroBioComponent&lt;/code&gt; 인스턴스는 서로 경쟁하여 캐시 할 영웅을 결정 하므로 동일한 &lt;code&gt;HeroCacheService&lt;/code&gt; 인스턴스를 공유 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e85a3cc08728cca8939b51f9d98196530fcc997a" translate="yes" xml:space="preserve">
          <source>Three of the common, built-in structural directives&amp;mdash;&lt;a href=&quot;built-in-directives#ngIf&quot;&gt;NgIf&lt;/a&gt;, &lt;a href=&quot;built-in-directives#ngFor&quot;&gt;NgFor&lt;/a&gt;, and &lt;a href=&quot;built-in-directives#ngSwitch&quot;&gt;NgSwitch...&lt;/a&gt;&amp;mdash;are described in the &lt;a href=&quot;built-in-directives&quot;&gt;Built-in directives&lt;/a&gt; guide and seen in samples throughout the Angular documentation. Here's an example of them in a template:</source>
          <target state="translated">기본 제공되는 세 가지 구조 지시문 인 &lt;a href=&quot;built-in-directives#ngIf&quot;&gt;NgIf&lt;/a&gt; , &lt;a href=&quot;built-in-directives#ngFor&quot;&gt;NgFor&lt;/a&gt; 및 &lt;a href=&quot;built-in-directives#ngSwitch&quot;&gt;NgSwitch ... &lt;/a&gt;&lt;a href=&quot;built-in-directives&quot;&gt;는 기본 제공 지시문&lt;/a&gt; 가이드 에 설명되어 있으며 Angular 문서 전체의 샘플에서 볼 수 있습니다. 다음은 템플릿의 예입니다.</target>
        </trans-unit>
        <trans-unit id="5d80c7ef855b73b71c4ca5c1c8a2d8119c7fa21b" translate="yes" xml:space="preserve">
          <source>Three of the common, built-in structural directives&amp;mdash;&lt;a href=&quot;template-syntax#ngIf&quot;&gt;NgIf&lt;/a&gt;, &lt;a href=&quot;template-syntax#ngFor&quot;&gt;NgFor&lt;/a&gt;, and &lt;a href=&quot;template-syntax#ngSwitch&quot;&gt;NgSwitch...&lt;/a&gt;&amp;mdash;are described in the &lt;a href=&quot;template-syntax&quot;&gt;&lt;em&gt;Template Syntax&lt;/em&gt;&lt;/a&gt; guide and seen in samples throughout the Angular documentation. Here's an example of them in a template:</source>
          <target state="translated">세 가지 일반적인 내장 구조 지시문 인 &lt;a href=&quot;template-syntax#ngIf&quot;&gt;NgIf&lt;/a&gt; , &lt;a href=&quot;template-syntax#ngFor&quot;&gt;NgFor&lt;/a&gt; 및 &lt;a href=&quot;template-syntax#ngSwitch&quot;&gt;NgSwitch ...&lt;/a&gt; 는 &lt;a href=&quot;template-syntax&quot;&gt;&lt;em&gt;템플릿 구문&lt;/em&gt;&lt;/a&gt; 안내서에 설명되어 있으며 Angular 설명서 전체의 샘플에서 볼 수 있습니다. 템플릿에 포함 된 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8703c0daee7a3560153b94bc34a950b511daab36" translate="yes" xml:space="preserve">
          <source>Three points of special interest:</source>
          <target state="translated">세 가지 특별한 관심 사항 :</target>
        </trans-unit>
        <trans-unit id="6b164df9c4f94a91727830fddbf131671bff71ec" translate="yes" xml:space="preserve">
          <source>Three providers tell the JIT compiler how to translate the template texts for a particular language while compiling the app:</source>
          <target state="translated">세 명의 공급자가 JIT 컴파일러에게 앱을 컴파일하는 동안 특정 언어의 템플릿 텍스트를 번역하는 방법을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="ed12cc77bbd83748afc157b996ead876c3c5517c" translate="yes" xml:space="preserve">
          <source>Through the &lt;code&gt;valueChanges&lt;/code&gt; observable where you can listen for changes in the form's value in the template using &lt;code&gt;&lt;a href=&quot;../api/common/asyncpipe&quot;&gt;AsyncPipe&lt;/a&gt;&lt;/code&gt; or in the component class using the &lt;code&gt;subscribe()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/common/asyncpipe&quot;&gt;AsyncPipe&lt;/a&gt;&lt;/code&gt; 를 사용하는 템플릿 또는 &lt;code&gt;subscribe()&lt;/code&gt; 메서드를 사용하는 구성 요소 클래스에서 폼 값의 변경 내용을들을 수 있는 &lt;code&gt;valueChanges&lt;/code&gt; 관찰 가능을 통해</target>
        </trans-unit>
        <trans-unit id="5a4cab0ebea476f32aa1e1c5fba91f40707b2ad6" translate="yes" xml:space="preserve">
          <source>Throughout this guide, you'll see a directive spelled in both &lt;em&gt;UpperCamelCase&lt;/em&gt; and &lt;em&gt;lowerCamelCase&lt;/em&gt;. Already you've seen &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt;. There's a reason. &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; refers to the directive &lt;em&gt;class&lt;/em&gt;; &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; refers to the directive's &lt;em&gt;attribute name&lt;/em&gt;.</source>
          <target state="translated">이 안내서 전체에서 &lt;em&gt;UpperCamelCase&lt;/em&gt; 와 &lt;em&gt;lowerCamelCase&lt;/em&gt; 에 지시문이 있습니다. 이미 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 를 보았습니다 . 이유가 있습니다. &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 는 지시어 &lt;em&gt;클래스를&lt;/em&gt; 참조한다 ; &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 는 지시문의 &lt;em&gt;속성 이름을&lt;/em&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f9f4b0f30b3f06e61b21febef173645d29891305" translate="yes" xml:space="preserve">
          <source>Throws</source>
          <target state="translated">Throws</target>
        </trans-unit>
        <trans-unit id="6c82e6dd86807ee3db07e3c82bec1ae1ce00b08b" translate="yes" xml:space="preserve">
          <source>Time</source>
          <target state="translated">Time</target>
        </trans-unit>
        <trans-unit id="f7ea2d8763887c41cd7da975aaf8c487045171ac" translate="yes" xml:space="preserve">
          <source>Time passes and application logic triggers lazy loading of an NgModule. Angular must add the lazy-loaded module's providers to an injector somewhere. It can't add them to the app root injector because that injector is closed to new providers. So Angular creates a new child injector for the lazy-loaded module context.</source>
          <target state="translated">시간이 지나고 애플리케이션 로직이 NgModule의 지연로드를 트리거합니다. Angular는 지연로드 모듈의 공급자를 인젝터에 어딘가에 추가해야합니다. 인젝터가 새 공급자에게 닫혀 있기 때문에 앱 루트 인젝터에 추가 할 수 없습니다. 따라서 Angular는 지연로드 모듈 컨텍스트에 대한 새로운 하위 인젝터를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8f86764c71eb5f28fd785ba95ea223af744160bb" translate="yes" xml:space="preserve">
          <source>Timezone of the formatted text will be the local system timezone of the end-user's machine.</source>
          <target state="translated">형식이 지정된 텍스트의 시간대는 최종 사용자 컴퓨터의 로컬 시스템 시간대입니다.</target>
        </trans-unit>
        <trans-unit id="098024dc5537ca3623978ac7c0a6140ce39062b8" translate="yes" xml:space="preserve">
          <source>Timing</source>
          <target state="translated">Timing</target>
        </trans-unit>
        <trans-unit id="ff73d9b2c838aef0837103246944b6eeaac4e811" translate="yes" xml:space="preserve">
          <source>Tip: In the &lt;a href=&quot;api&quot;&gt;API reference section&lt;/a&gt; of this doc site, deprecated APIs are indicated by &lt;del&gt;strikethrough.&lt;/del&gt; You can filter the API list by &lt;a href=&quot;api?status=deprecated&quot;&gt;&lt;strong&gt;Status: deprecated&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">팁 : 이 문서 사이트 의 &lt;a href=&quot;api&quot;&gt;API 참조 섹션&lt;/a&gt; 에서 더 이상 사용되지 않는 API는&lt;del&gt;취소 선.&lt;/del&gt;&lt;a href=&quot;api?status=deprecated&quot;&gt;&lt;strong&gt;Status : deprecated로&lt;/strong&gt;&lt;/a&gt; API 목록을 필터링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="768e0c1c69573fb588f61f1308a015c11468e05f" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">Title</target>
        </trans-unit>
        <trans-unit id="cd78803504972c001f389f4b2e207d6fc9adc057" translate="yes" xml:space="preserve">
          <source>Title text should be in &quot;Sentence case&quot;, which means the first word is capitalized and all other words are lower case (unless they are technical terms that are always capitalized, like &quot;Angular&quot;).</source>
          <target state="translated">제목 텍스트는 &quot;Sentence case&quot;여야합니다. 즉, 첫 번째 단어는 대문자이고 다른 모든 단어는 소문자입니다 ( &quot;Angular&quot;와 같이 항상 대문자로 표시되는 기술 용어가 아닌 경우).</target>
        </trans-unit>
        <trans-unit id="1ef4826ff87f22d637cb47eb360c1525fcf04ada" translate="yes" xml:space="preserve">
          <source>Title text should be in &quot;Title Case&quot;, which means that you use capital letters to start the first words and all &lt;em&gt;principal&lt;/em&gt; words. Use lower case letters for &lt;em&gt;secondary&lt;/em&gt; words such as &quot;in&quot;, &quot;of&quot;, and &quot;the&quot;.</source>
          <target state="translated">제목 텍스트는 &quot;제목 대소 문자&quot;로되어 있어야합니다 . 즉, 대문자를 사용하여 첫 단어와 모든 &lt;em&gt;기본&lt;/em&gt; 단어 를 시작해야합니다 . &quot;in&quot;, &quot;of&quot;및 &quot;the&quot;와 같은 &lt;em&gt;보조&lt;/em&gt; 단어 에는 소문자를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0443511f0f0d69e0669b6cc477969ba0177c046d" translate="yes" xml:space="preserve">
          <source>TitleCasePipe</source>
          <target state="translated">TitleCasePipe</target>
        </trans-unit>
        <trans-unit id="1edfc91ff1a795fb8fae2c2845186edc649e929e" translate="yes" xml:space="preserve">
          <source>To &lt;a href=&quot;http&quot;&gt;communicate with backend services using HTTP&lt;/a&gt;, the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; service uses observables and offers the &lt;code&gt;HTTPClient.get()&lt;/code&gt; method to fetch data from a server. The asynchronous method sends an HTTP request, and returns an observable that emits the requested data for the response.</source>
          <target state="translated">&lt;a href=&quot;http&quot;&gt;HTTP를 사용하여 백엔드 서비스와 통신&lt;/a&gt; 하기 위해 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 서비스는 Observable을 사용하고 &lt;code&gt;HTTPClient.get()&lt;/code&gt; 메서드를 제공하여 서버에서 데이터를 가져옵니다. 비동기 메서드는 HTTP 요청을 보내고 응답을 위해 요청 된 데이터를 내보내는 관찰 가능 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ed1a0b0c87e134832acc7d87c80e1e27c802b764" translate="yes" xml:space="preserve">
          <source>To access properties that are defined in an interface, you must explicitly convert the Object you get from the JSON to the required response type. For example, the following &lt;code&gt;subscribe&lt;/code&gt; callback receives &lt;code&gt;data&lt;/code&gt; as an Object, and then type-casts it in order to access the properties.</source>
          <target state="translated">인터페이스에 정의 된 특성에 액세스하려면 JSON에서 가져온 오브젝트를 필요한 응답 유형으로 명시 적으로 변환해야합니다. 예를 들어, 다음 &lt;code&gt;subscribe&lt;/code&gt; 콜백은 &lt;code&gt;data&lt;/code&gt; 를 Object로 수신 한 다음 속성에 액세스하기 위해 데이터 를 타입 캐스팅합니다.</target>
        </trans-unit>
        <trans-unit id="090bde2470cfa5d91164f0dd5ac0b680c316fd8a" translate="yes" xml:space="preserve">
          <source>To access properties that are defined in an interface, you must explicitly convert the plain object you get from the JSON to the required response type. For example, the following &lt;code&gt;subscribe&lt;/code&gt; callback receives &lt;code&gt;data&lt;/code&gt; as an Object, and then type-casts it in order to access the properties.</source>
          <target state="translated">인터페이스에 정의 된 속성에 액세스하려면 JSON에서 가져온 일반 개체를 필수 응답 유형으로 명시 적으로 변환해야합니다. 예를 들어 다음 &lt;code&gt;subscribe&lt;/code&gt; 콜백은 &lt;code&gt;data&lt;/code&gt; 를 Object로 수신 한 다음 속성에 액세스하기 위해 유형 캐스팅합니다.</target>
        </trans-unit>
        <trans-unit id="612822e1f2a2307aaa6e2b3ed143cfc5b79f8e35" translate="yes" xml:space="preserve">
          <source>To achieve this effect, extend the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; tag with the following:</source>
          <target state="translated">이 효과를 얻으려면 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 태그를 다음과 같이 확장하십시오 .</target>
        </trans-unit>
        <trans-unit id="bfbef04c66fa9ac05c09e94801b6ea0bdf69d6fb" translate="yes" xml:space="preserve">
          <source>To add a form group to this component, take the following steps.</source>
          <target state="translated">이 구성 요소에 양식 그룹을 추가하려면 다음 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4de9b850b6bc48b2b817512c2db67f3f4f4de00a" translate="yes" xml:space="preserve">
          <source>To add a hero, this app only needs the hero's name. You can use an &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element paired with an add button.</source>
          <target state="translated">영웅을 추가하려면이 앱에 영웅 이름 만 있으면됩니다. 추가 버튼과 함께 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 요소를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da8e56238639cdc891b1d4ed923efdcffe46b6f3" translate="yes" xml:space="preserve">
          <source>To add a new &lt;code&gt;devDependency&lt;/code&gt;, use either one of the following commands:</source>
          <target state="translated">새로운 &lt;code&gt;devDependency&lt;/code&gt; 를 추가하려면 다음 명령 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="27d7686824adeea94d6f50645d6b9afbe94609dd" translate="yes" xml:space="preserve">
          <source>To add a new dependency, use the &lt;a href=&quot;cli/add&quot;&gt;&lt;code&gt;ng add&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">새로운 종속성을 추가하려면 &lt;a href=&quot;cli/add&quot;&gt; &lt;code&gt;ng add&lt;/code&gt; &lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f457092233f40d2f34e89cbae624605c9b59951d" translate="yes" xml:space="preserve">
          <source>To add a schematic to an existing collection, use the same command you use to start a new schematics project, but run the command inside the project folder.</source>
          <target state="translated">기존 컬렉션에 회로도를 추가하려면 새 회로도 프로젝트를 시작하는 데 사용하는 것과 동일한 명령을 사용하지만 프로젝트 폴더 내에서 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="e0dff7476603a4365ce04e28daa6e5ae648874f0" translate="yes" xml:space="preserve">
          <source>To add a validator to the &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt;, pass the new validator in as the second argument on creation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 에 유효성 검증기를 추가하려면 작성시 두 번째 인수로 새 유효성 검증기를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="6e5aa5b2615deae73ee3a7a681ef04a97504d33d" translate="yes" xml:space="preserve">
          <source>To add a web worker to an existing project, use the Angular CLI &lt;code&gt;ng generate&lt;/code&gt; command.</source>
          <target state="translated">웹 작업자를 기존 프로젝트에 추가하려면 Angular CLI &lt;code&gt;ng generate&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5af208734231896485781dd45087dcf140d59c94" translate="yes" xml:space="preserve">
          <source>To add another product, click &quot;My Store&quot; to return to the product list.</source>
          <target state="translated">다른 제품을 추가하려면 &quot;내 상점&quot;을 클릭하여 제품 목록으로 돌아가십시오.</target>
        </trans-unit>
        <trans-unit id="b7c21a740943c10dfa15804fca8321cd2e41101e" translate="yes" xml:space="preserve">
          <source>To add another product, click &quot;My Store&quot; to return to the product list. Repeat the steps above.</source>
          <target state="translated">다른 제품을 추가하려면 &quot;내 상점&quot;을 클릭하여 제품 목록으로 돌아가십시오. 위 단계를 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="af30217cecee494619d1758d399f71f84dae729e" translate="yes" xml:space="preserve">
          <source>To add artifacts to a project, your schematic needs its own template files. Schematic templates support special syntax to execute code and variable substitution.</source>
          <target state="translated">프로젝트에 아티팩트를 추가하려면 회로도에 자체 템플릿 파일이 필요합니다. 회로도 템플릿은 코드 및 변수 대체를 실행하기위한 특수 구문을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="5c8962d1b60c02af2c0fa75a87fff3fbce78ea63" translate="yes" xml:space="preserve">
          <source>To add more features to the app's current crisis center, take similar steps as for the heroes feature:</source>
          <target state="translated">앱의 현재 위기 센터에 더 많은 기능을 추가하려면 Heroes 기능과 유사한 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b6b988734470ea226b7bc93e7814ababa57cf8ea" translate="yes" xml:space="preserve">
          <source>To add or remove a &lt;em&gt;single&lt;/em&gt; class, use &lt;a href=&quot;attribute-binding#class-binding&quot;&gt;class binding&lt;/a&gt; rather than &lt;code&gt;&lt;a href=&quot;../api/common/ngclass&quot;&gt;NgClass&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;단일&lt;/em&gt; 클래스 를 추가하거나 제거하려면 &lt;code&gt;&lt;a href=&quot;../api/common/ngclass&quot;&gt;NgClass&lt;/a&gt;&lt;/code&gt; 대신 &lt;a href=&quot;attribute-binding#class-binding&quot;&gt;클래스 바인딩을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3d2051452de0323eb6efd5aedc607498069cdae" translate="yes" xml:space="preserve">
          <source>To add or remove a &lt;em&gt;single&lt;/em&gt; class, use &lt;a href=&quot;template-syntax#class-binding&quot;&gt;class binding&lt;/a&gt; rather than &lt;code&gt;&lt;a href=&quot;../api/common/ngclass&quot;&gt;NgClass&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;단일&lt;/em&gt; 클래스 를 추가하거나 제거하려면 &lt;code&gt;&lt;a href=&quot;../api/common/ngclass&quot;&gt;NgClass&lt;/a&gt;&lt;/code&gt; 대신 &lt;a href=&quot;template-syntax#class-binding&quot;&gt;클래스 바인딩을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9da25919d51d1a85e0005bea2eb758313daa6fe" translate="yes" xml:space="preserve">
          <source>To add paths, use the &lt;code&gt;stylePreprocessorOptions&lt;/code&gt; option:</source>
          <target state="translated">경로를 추가하려면 &lt;code&gt;stylePreprocessorOptions&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="43fd32e81bc1770347d28bdfa0c8f42aa2ce4a7b" translate="yes" xml:space="preserve">
          <source>To add the classes only when the URL matches the link exactly, add the option &lt;code&gt;exact: true&lt;/code&gt;:</source>
          <target state="translated">URL이 링크와 정확히 일치하는 경우에만 클래스를 추가하려면 &lt;code&gt;exact: true&lt;/code&gt; 옵션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="496b7ad1d0a0eed5827dc1a97fd622e7f8d94e93" translate="yes" xml:space="preserve">
          <source>To add the component to the template, you call &lt;code&gt;createComponent()&lt;/code&gt; on &lt;code&gt;&lt;a href=&quot;../api/core/viewcontainerref&quot;&gt;ViewContainerRef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">컴포넌트를 템플릿에 추가하려면 &lt;code&gt;&lt;a href=&quot;../api/core/viewcontainerref&quot;&gt;ViewContainerRef&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;createComponent()&lt;/code&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="987b409e8bf18353ecffd982c4a6027176175f26" translate="yes" xml:space="preserve">
          <source>To add the schematics to the library bundle, add scripts to the library's &lt;code&gt;package.json&lt;/code&gt; file.</source>
          <target state="translated">라이브러리 번들에 회로도를 추가하려면 라이브러리의 &lt;code&gt;package.json&lt;/code&gt; 파일에 스크립트를 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="1a7a24ab6c517387fe4fb759c2cbbe67fd7e654f" translate="yes" xml:space="preserve">
          <source>To add the stylesheet, open &lt;code&gt;styles.css&lt;/code&gt; and add the following import line at the top:</source>
          <target state="translated">스타일 시트를 추가하려면 &lt;code&gt;styles.css&lt;/code&gt; 를 열고 맨 위에 다음 가져 오기 행을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d7a97119528a1219e01d41b64f89cfc156ab2111" translate="yes" xml:space="preserve">
          <source>To add validation to a template-driven form, you add the same validation attributes as you would with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation&quot;&gt;native HTML form validation&lt;/a&gt;. Angular uses directives to match these attributes with validator functions in the framework.</source>
          <target state="translated">템플릿 기반 양식에 유효성 검사를 추가하려면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation&quot;&gt;기본 HTML 양식 유효성 검사&lt;/a&gt; 와 동일한 유효성 검사 속성을 추가합니다 . Angular는 지시문을 사용하여 이러한 속성을 프레임 워크의 유효성 검사기 함수와 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="ce70784e6a2d0e1e0652eb7bae45da63bd42c69d" translate="yes" xml:space="preserve">
          <source>To alter the request, clone it first and modify the clone before passing it to &lt;code&gt;next.handle()&lt;/code&gt;. You can clone and modify the request in a single step as in this example.</source>
          <target state="translated">요청을 변경하려면 먼저 요청을 복제하고 &lt;code&gt;next.handle()&lt;/code&gt; 전달하기 전에 복제본을 수정하십시오 . 이 예제와 같이 단일 단계에서 요청을 복제하고 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be9073f11e0afa56717eb05e0a7001960b7a1b99" translate="yes" xml:space="preserve">
          <source>To alter where the injector starts looking for &lt;code&gt;FlowerService&lt;/code&gt;, add &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; to the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt;&lt;code&gt;@&lt;a href=&quot;../api/core/inject&quot;&gt;Inject&lt;/a&gt;&lt;/code&gt; declaration for the &lt;code&gt;FlowerService&lt;/code&gt;. This declaration is in the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; constructor as shown in &lt;code&gt;child.component.ts&lt;/code&gt;:</source>
          <target state="translated">찾고 인젝터의 시작 위치를 변경하려면 &lt;code&gt;FlowerService&lt;/code&gt; 가 추가 &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; 받는 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; &lt;code&gt;@&lt;a href=&quot;../api/core/inject&quot;&gt;Inject&lt;/a&gt;&lt;/code&gt; 에 대한 선언 &lt;code&gt;FlowerService&lt;/code&gt; . 이 선언은 &lt;code&gt;child.component.ts&lt;/code&gt; 와 같이 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; 생성자에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="22c3b2cba8f53e2ffe5dab01bc5b91f88e756346" translate="yes" xml:space="preserve">
          <source>To answer these kinds of questions, you have to create the DOM elements associated with the components, you must examine the DOM to confirm that component state displays properly at the appropriate times, and you must simulate user interaction with the screen to determine whether those interactions cause the component to behave as expected.</source>
          <target state="translated">이러한 종류의 질문에 대답하려면 구성 요소와 연관된 DOM 요소를 작성하고, DOM을 검사하여 구성 요소 상태가 적절한 시간에 올바르게 표시되는지 확인한 후 화면과의 사용자 상호 작용을 시뮬레이션하여 해당 상호 작용이 있는지 판별해야합니다. 구성 요소가 예상대로 작동하도록합니다.</target>
        </trans-unit>
        <trans-unit id="b914cc85efa6a3ee58a159fd0169f8e78be87368" translate="yes" xml:space="preserve">
          <source>To apply a pipe, use the pipe operator (&lt;code&gt;|&lt;/code&gt;) within a template expression as shown in the following code example, along with the &lt;em&gt;name&lt;/em&gt; of the pipe, which is &lt;code&gt;&lt;a href=&quot;../api/common/datepipe&quot;&gt;date&lt;/a&gt;&lt;/code&gt; for the built-in &lt;a href=&quot;../api/common/datepipe&quot;&gt;&lt;code&gt;DatePipe&lt;/code&gt;&lt;/a&gt;. The tabs in the example show the following:</source>
          <target state="translated">파이프를 적용하려면 기본 제공 &lt;a href=&quot;../api/common/datepipe&quot;&gt; &lt;code&gt;DatePipe&lt;/code&gt; 의&lt;/a&gt; &lt;code&gt;&lt;a href=&quot;../api/common/datepipe&quot;&gt;date&lt;/a&gt;&lt;/code&gt; 파이프 &lt;em&gt;이름&lt;/em&gt; 과 함께 다음 코드 예제와 같이 템플릿 표현식 내 에서 파이프 연산자 ( &lt;code&gt;|&lt;/code&gt; )를 사용합니다 . 예제의 탭은 다음을 표시합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dcf8f543ff93bfc9b163241813212b02a20d1ea1" translate="yes" xml:space="preserve">
          <source>To apply specific build options to only one locale, you can create a custom locale-specific configuration by specifying a single locale as shown in the following example:</source>
          <target state="translated">특정 빌드 옵션을 하나의 로캘에만 적용하려면 다음 예제와 같이 단일 로캘을 지정하여 사용자 지정 로캘 별 구성을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36d091e0c047395da2a56a9e24df2133c4a12994" translate="yes" xml:space="preserve">
          <source>To attach the aliases from your form model, you must add it to the template. Similar to the &lt;code&gt;&lt;a href=&quot;../api/forms/formgroupname&quot;&gt;formGroupName&lt;/a&gt;&lt;/code&gt; input provided by &lt;code&gt;FormGroupNameDirective&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/forms/formarrayname&quot;&gt;formArrayName&lt;/a&gt;&lt;/code&gt; binds communication from the form array instance to the template with &lt;code&gt;FormArrayNameDirective&lt;/code&gt;.</source>
          <target state="translated">양식 모델에서 별명을 첨부하려면 템플리트에 별명을 추가해야합니다. 받는 유사 &lt;code&gt;&lt;a href=&quot;../api/forms/formgroupname&quot;&gt;formGroupName&lt;/a&gt;&lt;/code&gt; 에 의해 제공되는 입력 &lt;code&gt;FormGroupNameDirective&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/forms/formarrayname&quot;&gt;formArrayName&lt;/a&gt;&lt;/code&gt; 을 가진 템플릿 형태로 배열 인스턴스에서 통신 결합 &lt;code&gt;FormArrayNameDirective&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b439955a79dbd833d42d99f6fa91279d6ef67f27" translate="yes" xml:space="preserve">
          <source>To automate that data flow, setup a two-way data binding between the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; form element and the &lt;code&gt;hero.name&lt;/code&gt; property.</source>
          <target state="translated">해당 데이터 흐름을 자동화하려면 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 양식 요소와 &lt;code&gt;hero.name&lt;/code&gt; 속성 사이에 양방향 데이터 바인딩을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="c97596f545bc3c4cf4d6e36b38363f8b20cb690b" translate="yes" xml:space="preserve">
          <source>To avoid relying solely on visual cues, you need to make sure your routing code updates focus after page navigation. Use the &lt;code&gt;&lt;a href=&quot;../api/router/navigationend&quot;&gt;NavigationEnd&lt;/a&gt;&lt;/code&gt; event from the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; service to know when to update focus.</source>
          <target state="translated">시각적 단서에만 의존하지 않으려면 페이지 탐색 후 라우팅 코드 업데이트에 초점이 맞춰져야합니다. &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 서비스 의 &lt;code&gt;&lt;a href=&quot;../api/router/navigationend&quot;&gt;NavigationEnd&lt;/a&gt;&lt;/code&gt; 이벤트를 사용하여 포커스를 업데이트 할시기를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b14c5694baf8932f7e55e412b232c287b7bc7e46" translate="yes" xml:space="preserve">
          <source>To avoid this error, a &lt;a href=&quot;lifecycle-hooks&quot;&gt;lifecycle hook&lt;/a&gt; method that seeks to make such a change should trigger a new change detection run. The new run follows the same direction as before, but succeeds in picking up the new value.</source>
          <target state="translated">이 오류를 방지하려면 이러한 변경을 시도 하는 &lt;a href=&quot;lifecycle-hooks&quot;&gt;수명주기 후크&lt;/a&gt; 메서드가 새 변경 감지 실행을 트리거해야합니다. 새로운 실행은 이전과 같은 방향을 따르지만 새로운 값을 선택하는 데 성공합니다.</target>
        </trans-unit>
        <trans-unit id="441327a3b62f31f08d7ebf067ab65b6221abce4c" translate="yes" xml:space="preserve">
          <source>To avoid this expensive operation, you can customize the default tracking algorithm. by supplying the &lt;code&gt;trackBy&lt;/code&gt; option to &lt;code&gt;&lt;a href=&quot;ngforof&quot;&gt;NgForOf&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;trackBy&lt;/code&gt; takes a function that has two arguments: &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;trackBy&lt;/code&gt; is given, Angular tracks changes by the return value of the function.</source>
          <target state="translated">이 비싼 작업을 피하기 위해 기본 추적 알고리즘을 사용자 정의 할 수 있습니다. 공급에 의해 &lt;code&gt;trackBy&lt;/code&gt; 의 에 옵션 &lt;code&gt;&lt;a href=&quot;ngforof&quot;&gt;NgForOf&lt;/a&gt;&lt;/code&gt; 을 . &lt;code&gt;trackBy&lt;/code&gt; 는 &lt;code&gt;index&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; 이라는 두 개의 인수가있는 함수를 사용합니다 . 경우 &lt;code&gt;trackBy&lt;/code&gt; 가 주어진 각도 궤도 함수의 리턴 값으로 변경한다.</target>
        </trans-unit>
        <trans-unit id="4e45c920ee8a5bfaeada08016996d3dc7a94099f" translate="yes" xml:space="preserve">
          <source>To avoid this expensive operation, you can customize the default tracking algorithm. by supplying the &lt;code&gt;trackBy&lt;/code&gt; option to &lt;code&gt;&lt;a href=&quot;ngforof&quot;&gt;NgForOf&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;trackBy&lt;/code&gt; takes a function that has two arguments: &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;item&lt;/code&gt;. If &lt;code&gt;trackBy&lt;/code&gt; is given, Angular tracks changes by the return value of the function.</source>
          <target state="translated">이러한 비용이 많이 드는 작업을 방지하기 위해 기본 추적 알고리즘을 사용자 지정할 수 있습니다. &lt;code&gt;trackBy&lt;/code&gt; 옵션을 &lt;code&gt;&lt;a href=&quot;ngforof&quot;&gt;NgForOf&lt;/a&gt;&lt;/code&gt; 에 제공하여 . &lt;code&gt;trackBy&lt;/code&gt; 는 두 개의 인수 인 &lt;code&gt;index&lt;/code&gt; 및 &lt;code&gt;item&lt;/code&gt; 이있는 함수를 사용합니다 . 경우 &lt;code&gt;trackBy&lt;/code&gt; 가 주어진 각도 궤도 함수의 리턴 값으로 변경한다.</target>
        </trans-unit>
        <trans-unit id="e8cfc2c0e9fadb81aa5e73b8bb58085461fa57a5" translate="yes" xml:space="preserve">
          <source>To avoid this problem, import the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt; only in the &lt;code&gt;AppModule&lt;/code&gt;, the application &lt;em&gt;root module&lt;/em&gt;.</source>
          <target state="translated">이 문제를 피하려면 응용 프로그램 &lt;em&gt;루트 모듈 인 &lt;/em&gt; &lt;code&gt;AppModule&lt;/code&gt; 에서만 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt; 을 가져 오십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="598b94eaf0a9207b1b2f7e14b6bb329e39eadeca" translate="yes" xml:space="preserve">
          <source>To be Angular compatible, an AngularJS component directive should configure these attributes:</source>
          <target state="translated">Angular와 호환 되려면 AngularJS 구성 요소 지시문이 다음 속성을 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="123c3019791e3c52ebbcbe83a892f8e6e401c499" translate="yes" xml:space="preserve">
          <source>To be notified when new releases are available, follow &lt;a href=&quot;https://twitter.com/angular&quot;&gt;@angular&lt;/a&gt; on Twitter or subscribe to the &lt;a href=&quot;https://blog.angular.io&quot;&gt;Angular blog&lt;/a&gt;.</source>
          <target state="translated">새 릴리스가 출시 될 때 알림을 &lt;a href=&quot;https://twitter.com/angular&quot;&gt;받으려면&lt;/a&gt; Twitter에서 @angular 를 따르 거나 &lt;a href=&quot;https://blog.angular.io&quot;&gt;Angular 블로그를&lt;/a&gt; 구독하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd4700612dcf5dc9d98d073d3fec1a9bda0633ef" translate="yes" xml:space="preserve">
          <source>To be used with watch mode, a builder handler function should return an Observable. Architect subscribes to the Observable until it completes and might reuse it if the builder is scheduled again with the same arguments.</source>
          <target state="translated">감시 모드와 함께 사용하려면 빌더 핸들러 함수가 Observable을 리턴해야합니다. Architect는 Observable을 완료 할 때까지 구독하고 빌더가 동일한 인수로 다시 스케줄 된 경우이를 다시 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6264ce2f8d176973d84cc88a177c1b8d2ae8301" translate="yes" xml:space="preserve">
          <source>To begin converting your AngularJS application to a hybrid, you need to load the Angular framework. You can see how this can be done with SystemJS by following the instructions in &lt;a href=&quot;upgrade-setup&quot;&gt;Setup for Upgrading to AngularJS&lt;/a&gt; for selectively copying code from the &lt;a href=&quot;https://github.com/angular/quickstart&quot;&gt;QuickStart github repository&lt;/a&gt;.</source>
          <target state="translated">AngularJS 애플리케이션을 하이브리드로 변환하려면 Angular 프레임 워크를로드해야합니다. &lt;a href=&quot;https://github.com/angular/quickstart&quot;&gt;QuickStart github 저장소&lt;/a&gt; 에서 코드를 선택적으로 복사 &lt;a href=&quot;upgrade-setup&quot;&gt;하기 위해 AngularJS&lt;/a&gt; 로 업그레이드하기위한 설정 의 지시 사항에 따라 SystemJS로이를 수행하는 방법을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ff25a3d91e518e6022fbcb82db9614eb3a86d036" translate="yes" xml:space="preserve">
          <source>To begin testing calls to &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt;, import the &lt;code&gt;&lt;a href=&quot;../api/common/http/testing/httpclienttestingmodule&quot;&gt;HttpClientTestingModule&lt;/a&gt;&lt;/code&gt; and the mocking controller, &lt;code&gt;&lt;a href=&quot;../api/common/http/testing/httptestingcontroller&quot;&gt;HttpTestingController&lt;/a&gt;&lt;/code&gt;, along with the other symbols your tests require.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 에 대한 호출 테스트를 시작하려면 테스트에 필요한 다른 기호와 함께 &lt;code&gt;&lt;a href=&quot;../api/common/http/testing/httpclienttestingmodule&quot;&gt;HttpClientTestingModule&lt;/a&gt;&lt;/code&gt; 및 조롱 컨트롤러 &lt;code&gt;&lt;a href=&quot;../api/common/http/testing/httptestingcontroller&quot;&gt;HttpTestingController&lt;/a&gt;&lt;/code&gt; 를 가져 오십시오 .</target>
        </trans-unit>
        <trans-unit id="970d997b1f905a43219b5008925290bb634cfd6b" translate="yes" xml:space="preserve">
          <source>To begin using Angular service workers, see &lt;a href=&quot;service-worker-getting-started&quot;&gt;Getting Started with service workers&lt;/a&gt;.</source>
          <target state="translated">Angular 서비스 워커 사용을 시작하려면 서비스 워커 &lt;a href=&quot;service-worker-getting-started&quot;&gt;시작하기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="de460edf05dca2d464a1be91407ed6ffea7d7a8e" translate="yes" xml:space="preserve">
          <source>To begin using the CLI for a new project, see &lt;a href=&quot;setup-local&quot;&gt;Local Environment Setup&lt;/a&gt;.</source>
          <target state="translated">새 프로젝트에 CLI를 사용하려면 &lt;a href=&quot;setup-local&quot;&gt;로컬 환경 설정을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b18b6e1679f6b673ab980d8c28e59713ff54dfa" translate="yes" xml:space="preserve">
          <source>To begin, configure a set of routes using methods available in the &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; class. This route configuration tells the router how to navigate.</source>
          <target state="translated">시작하려면 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; 클래스 에서 사용 가능한 메소드를 사용하여 라우트 세트를 구성하십시오 . 이 경로 구성은 라우터에게 탐색 방법을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="008987cccbf2a31fda96aa5a830cd40924b91032" translate="yes" xml:space="preserve">
          <source>To begin, create a new subfolder, &lt;code&gt;my-service&lt;/code&gt;, in the &lt;code&gt;schematics&lt;/code&gt; folder.</source>
          <target state="translated">시작하려면 &lt;code&gt;schematics&lt;/code&gt; 폴더 에 새 하위 폴더 &lt;code&gt;my-service&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6dd9e1c57cc321e0fe725c8e45cb7fc4f6d13c75" translate="yes" xml:space="preserve">
          <source>To benefit from the Angular service worker, your app must run in a web browser that supports service workers in general. Currently, service workers are supported in the latest versions of Chrome, Firefox, Edge, Safari, Opera, UC Browser (Android version) and Samsung Internet. Browsers like IE and Opera Mini do not support service workers.</source>
          <target state="translated">Angular 서비스 워커의 혜택을 받으려면 앱이 일반적으로 서비스 워커를 지원하는 웹 브라우저에서 실행되어야합니다. 현재 서비스 근로자는 최신 버전의 Chrome, Firefox, Edge, Safari, Opera, UC Browser (Android 버전) 및 Samsung Internet에서 지원됩니다. IE 및 Opera Mini와 같은 브라우저는 서비스 워커를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="823f8f6067a0bd01cd8d63ba6022a1d82417c4ca" translate="yes" xml:space="preserve">
          <source>To better explain the condition under which token retention occurs, consider a library that provides a library-card component, which contains a body and can contain an optional header.</source>
          <target state="translated">토큰 보유가 발생하는 조건을 더 잘 설명하려면 본문을 포함하고 선택적 헤더를 포함 할 수있는 라이브러리 카드 구성 요소를 제공하는 라이브러리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a4b9a0b3c93987f15167a935557553029127ee66" translate="yes" xml:space="preserve">
          <source>To bind the &lt;code&gt;src&lt;/code&gt; property of an &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; element to a component's property, place the target, &lt;code&gt;src&lt;/code&gt;, in square brackets followed by an equal sign and then the property. The property here is &lt;code&gt;itemImageUrl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 요소 의 &lt;code&gt;src&lt;/code&gt; 속성을 구성 요소의 속성에 바인딩하려면 대상 &lt;code&gt;src&lt;/code&gt; 를 대괄호로 묶은 다음 등호와 속성을 차례로 배치합니다. 여기의 속성은 &lt;code&gt;itemImageUrl&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="aceceb9344b852a619d58c97b4a87fbc9c2dc9ab" translate="yes" xml:space="preserve">
          <source>To bind to a DOM event, surround the DOM event name in parentheses and assign a quoted &lt;a href=&quot;template-syntax#template-statements&quot;&gt;template statement&lt;/a&gt; to it.</source>
          <target state="translated">DOM 이벤트에 바인드하려면 DOM 이벤트 이름을 괄호로 묶고 인용 된 &lt;a href=&quot;template-syntax#template-statements&quot;&gt;템플리트 명령문&lt;/a&gt; 을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="8805e78091225819c8ec4f163b041709b022dc53" translate="yes" xml:space="preserve">
          <source>To bind to an element's property, enclose it in square brackets, &lt;code&gt;[]&lt;/code&gt;, which identifies the property as a target property. A target property is the DOM property to which you want to assign a value. For example, the target property in the following code is the image element's &lt;code&gt;src&lt;/code&gt; property.</source>
          <target state="translated">요소의 속성에 바인딩하려면 속성을 대상 속성으로 식별하는 대괄호 &lt;code&gt;[]&lt;/code&gt; 로 묶습니다 . 대상 속성은 값을 할당하려는 DOM 속성입니다. 예를 들어 다음 코드의 target 속성은 이미지 요소의 &lt;code&gt;src&lt;/code&gt; 속성입니다.</target>
        </trans-unit>
        <trans-unit id="b6c9d270dcb9439d7a8e35a87d442f4c07eaf0b5" translate="yes" xml:space="preserve">
          <source>To bind to an event you use the Angular event binding syntax. This syntax consists of a target event name within parentheses to the left of an equal sign, and a quoted template statement to the right. In the following example, the target event name is &lt;code&gt;click&lt;/code&gt; and the template statement is &lt;code&gt;onSave()&lt;/code&gt;.</source>
          <target state="translated">이벤트에 바인딩하려면 Angular 이벤트 바인딩 구문을 사용합니다. 이 구문은 등호 왼쪽에있는 괄호 안에있는 대상 이벤트 이름과 오른쪽에 인용 된 템플릿 문으로 구성됩니다. 다음 예제에서 대상 이벤트 이름은 &lt;code&gt;click&lt;/code&gt; 이고 템플릿 문은 &lt;code&gt;onSave()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2d778e18735c77251c6e68dfae859e34ec242ed1" translate="yes" xml:space="preserve">
          <source>To bind to multiple classes, use &lt;code&gt;[class]&lt;/code&gt; set to an expression&amp;mdash;for example, &lt;code&gt;[class]=&quot;classExpression&quot;&lt;/code&gt;. The expression can be a space-delimited string of class names, or an object with class names as the keys and truthy or falsy expressions as the values. With an object format, Angular adds a class only if its associated value is truthy.</source>
          <target state="translated">여러 클래스에 바인딩하려면 &lt;code&gt;[class]&lt;/code&gt; 를 식으로 설정하여 사용 합니다 (예 : &lt;code&gt;[class]=&quot;classExpression&quot;&lt;/code&gt; ) . 표현식은 공백으로 구분 된 클래스 이름 문자열이거나, 클래스 이름을 키로 사용하고 진실 또는 거짓 표현식을 값으로 사용하는 객체 일 수 있습니다. 객체 형식을 사용하면 Angular는 관련 값이 진실 인 경우에만 클래스를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2a2b43d8d4759c302041d5555e84a74b033db308" translate="yes" xml:space="preserve">
          <source>To block XSS attacks, you must prevent malicious code from entering the DOM (Document Object Model). For example, if attackers can trick you into inserting a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag in the DOM, they can run arbitrary code on your website. The attack isn't limited to &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags&amp;mdash;many elements and properties in the DOM allow code execution, for example, &lt;code&gt;&amp;lt;img onerror=&quot;...&quot;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routerlinkwithhref&quot;&gt;a&lt;/a&gt; href=&quot;javascript:...&quot;&amp;gt;&lt;/code&gt;. If attacker-controlled data enters the DOM, expect security vulnerabilities.</source>
          <target state="translated">XSS 공격을 차단하려면 악성 코드가 DOM (Document Object Model)에 들어 가지 않도록해야합니다. 예를 들어 공격자가 DOM에 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그 를 삽입하도록 속일 수 있으면 웹 사이트에서 임의의 코드를 실행할 수 있습니다. 공격이에 한정되지 않고, &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 예를 들어, 코드 실행 DOM을 태그-많은 요소와 속성 수 있도록, &lt;code&gt;&amp;lt;img onerror=&quot;...&quot;&amp;gt;&lt;/code&gt; 와 &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routerlinkwithhref&quot;&gt;a&lt;/a&gt; href=&quot;javascript:...&quot;&amp;gt;&lt;/code&gt; . 공격자 제어 데이터가 DOM에 침입하면 보안 취약점이 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="bf32545d272d3b9cbadb82b7e3da443ce9a08440" translate="yes" xml:space="preserve">
          <source>To block XSS attacks, you must prevent malicious code from entering the DOM (Document Object Model). For example, if attackers can trick you into inserting a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag in the DOM, they can run arbitrary code on your website. The attack isn't limited to &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags&amp;mdash;many elements and properties in the DOM allow code execution, for example, &lt;code&gt;&amp;lt;img onerror=&quot;...&quot;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;a href=&quot;javascript:...&quot;&amp;gt;&lt;/code&gt;. If attacker-controlled data enters the DOM, expect security vulnerabilities.</source>
          <target state="translated">XSS 공격을 차단하려면 악성 코드가 DOM (Document Object Model)에 들어가는 것을 방지해야합니다. 예를 들어 공격자가 DOM에 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그 를 삽입하도록 속일 수있는 경우 웹 사이트에서 임의의 코드를 실행할 수 있습니다. 공격은 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그에 국한되지 않습니다 . DOM의 많은 요소와 속성이 코드 실행을 허용합니다 (예 : &lt;code&gt;&amp;lt;img onerror=&quot;...&quot;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;a href=&quot;javascript:...&quot;&amp;gt;&lt;/code&gt; ) . 공격자가 제어하는 ​​데이터가 DOM에 들어가면 보안 취약성이 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="82e29a55d59b6b2bd0a517982412ccec5411a4a1" translate="yes" xml:space="preserve">
          <source>To bootstrap a hybrid application, you must bootstrap each of the Angular and AngularJS parts of the application. You must bootstrap the Angular bits first and then ask the &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; to bootstrap the AngularJS bits next.</source>
          <target state="translated">하이브리드 애플리케이션을 부트 스트랩하려면 애플리케이션의 각 Angular 및 AngularJS 파트를 부트 스트랩해야합니다. Angular 비트를 먼저 부트 스트랩 한 다음 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 에 다음 AngularJS 비트를 부트 스트랩 하도록 요청해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="4f304161933cd5ad06abfd2e9cde018e77079b3d" translate="yes" xml:space="preserve">
          <source>To build a separate distributable copy of the app for each locale, &lt;a href=&quot;i18n#localize-config&quot;&gt;define the locales in the build configuration&lt;/a&gt; in your project's workspace configuration file &lt;a href=&quot;workspace-config&quot;&gt;&lt;code&gt;angular.json&lt;/code&gt;&lt;/a&gt;. This method shortens the build process by removing the requirement to perform a full app build for each locale.</source>
          <target state="translated">각 로케일에 대해 별도의 배포 가능한 앱 사본을 빌드하려면 프로젝트의 작업 공간 구성 파일 &lt;a href=&quot;workspace-config&quot;&gt; &lt;code&gt;angular.json&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;i18n#localize-config&quot;&gt;빌드 구성&lt;/a&gt; 에 로케일을 정의하십시오 . 이 방법은 각 로케일에 대해 전체 앱 빌드를 수행해야하는 요구 사항을 제거하여 빌드 프로세스를 단축합니다.</target>
        </trans-unit>
        <trans-unit id="e4ec3081d8abfef81b9c7b98512682fe817069de" translate="yes" xml:space="preserve">
          <source>To build up the generation schematic, start with an empty rule factory.</source>
          <target state="translated">생성 회로도를 작성하려면 빈 규칙 팩토리로 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="8901fe39170514d01f50341a27e20f9604a9825a" translate="yes" xml:space="preserve">
          <source>To build using the staging configuration, run the following command:</source>
          <target state="translated">스테이징 구성을 사용하여 빌드하려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="c4203d9a357f968995a61263dcb595eb193e91ce" translate="yes" xml:space="preserve">
          <source>To build your application locally or for production, download the source code from your StackBlitz project by clicking the &lt;code&gt;Download Project&lt;/code&gt; icon in the left menu across from &lt;code&gt;Project&lt;/code&gt; to download your files.</source>
          <target state="translated">로컬 또는 생산을위한 응용 프로그램을 빌드하려면 클릭하여 StackBlitz 프로젝트에서 소스 코드를 다운로드 &lt;code&gt;Download Project&lt;/code&gt; 맞은 편 왼쪽 메뉴에 아이콘을 &lt;code&gt;Project&lt;/code&gt; 파일을 다운로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e28bdfee0dc7a60965eea042b0b40687dbd667f9" translate="yes" xml:space="preserve">
          <source>To build your application locally or for production, you will need to download the source code from your StackBlitz project. Click the &lt;code&gt;Download Project&lt;/code&gt; icon in the left menu across from &lt;code&gt;Project&lt;/code&gt; to download your files.</source>
          <target state="translated">응용 프로그램을 로컬로 또는 프로덕션 용으로 빌드하려면 StackBlitz 프로젝트에서 소스 코드를 다운로드해야합니다. &lt;code&gt;Download Project&lt;/code&gt; 의 왼쪽 메뉴에서 &lt;code&gt;Project&lt;/code&gt; 다운로드 아이콘을 클릭 하여 파일을 다운로드하십시오.</target>
        </trans-unit>
        <trans-unit id="0466ae768a4d93cf77c8e4981171d89f8a7ca6ff" translate="yes" xml:space="preserve">
          <source>To bundle your schematics together with your library, you must configure the library to build the schematics separately, then add them to the bundle. You must build your schematics &lt;em&gt;after&lt;/em&gt; you build your library, so they are placed in the correct directory.</source>
          <target state="translated">회로도와 라이브러리를 번들로 묶으려면 회로도를 개별적으로 빌드하도록 라이브러리를 구성한 다음 번들에 추가해야합니다. 라이브러리를 빌드 &lt;em&gt;한 후&lt;/em&gt; 회로도를 작성해야 올바른 디렉토리에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="885d50f557834570c68a2e5e1be6b220c9216f5a" translate="yes" xml:space="preserve">
          <source>To bypass the service worker you can set &lt;code&gt;ngsw-bypass&lt;/code&gt; as a request header, or as a query parameter. (The value of the header or query parameter is ignored and can be empty or omitted.)</source>
          <target state="translated">서비스 워커를 우회하기 위해 &lt;code&gt;ngsw-bypass&lt;/code&gt; 를 요청 헤더 또는 쿼리 매개 변수로 설정할 수 있습니다 . (헤더 또는 쿼리 매개 변수의 값은 무시되며 비어 있거나 생략 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="12534712788ba78416f7f95870eaa280458520d6" translate="yes" xml:space="preserve">
          <source>To catch errors, you &lt;strong&gt;&quot;pipe&quot; the observable&lt;/strong&gt; result from &lt;code&gt;http.get()&lt;/code&gt; through an RxJS &lt;code&gt;catchError()&lt;/code&gt; operator.</source>
          <target state="translated">오류를 포착하기 위해 RxJS &lt;code&gt;catchError()&lt;/code&gt; 연산자를 통해 &lt;code&gt;http.get()&lt;/code&gt; 에서 &lt;strong&gt;관찰 가능한&lt;/strong&gt; 결과 를 &lt;strong&gt;&quot;파이프&quot;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b1399e0f4384532fff4fb5004d497a9b72d3762f" translate="yes" xml:space="preserve">
          <source>To change the appearance in this way, take the following steps.</source>
          <target state="translated">이러한 방식으로 모양을 변경하려면 다음 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1e0fe49f14510b713680172388a0dd717d0f6c10" translate="yes" xml:space="preserve">
          <source>To change the controls in the array, use the &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;removeAt&lt;/code&gt; or &lt;code&gt;clear&lt;/code&gt; methods in &lt;code&gt;&lt;a href=&quot;formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; itself. These methods ensure the controls are properly tracked in the form's hierarchy. Do not modify the array of &lt;code&gt;&lt;a href=&quot;abstractcontrol&quot;&gt;AbstractControl&lt;/a&gt;&lt;/code&gt;s used to instantiate the &lt;code&gt;&lt;a href=&quot;formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; directly, as that result in strange and unexpected behavior such as broken change detection.</source>
          <target state="translated">배열의 컨트롤을 변경하려면 &lt;code&gt;&lt;a href=&quot;formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; 자체 에서 &lt;code&gt;push&lt;/code&gt; , &lt;code&gt;insert&lt;/code&gt; , &lt;code&gt;removeAt&lt;/code&gt; 또는 &lt;code&gt;clear&lt;/code&gt; 메서드를 사용 하십시오 . 이러한 방법을 사용하면 컨트롤이 폼의 계층 구조에서 올바르게 추적됩니다. &lt;code&gt;&lt;a href=&quot;formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; 를 직접 인스턴스화하는 데 사용되는 &lt;code&gt;&lt;a href=&quot;abstractcontrol&quot;&gt;AbstractControl&lt;/a&gt;&lt;/code&gt; 의 배열을 수정하지 마십시오 . 변경 감지 오류와 같은 이상하고 예기치 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fa6c4e125d9030b1dd5bdb271106b3ee1210b79c" translate="yes" xml:space="preserve">
          <source>To change the name of the source language file generated by the extraction tool, use the &lt;code&gt;--outFile&lt;/code&gt; command option:</source>
          <target state="translated">추출 도구로 생성 된 소스 언어 파일의 이름을 변경하려면 &lt;code&gt;--outFile&lt;/code&gt; 명령 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="63029d22a7a0498f402e2ef9e4441e473404955c" translate="yes" xml:space="preserve">
          <source>To check that you have the npm client installed, run &lt;code&gt;npm -v&lt;/code&gt; in a terminal/console window.</source>
          <target state="translated">npm 클라이언트가 설치되어 있는지 확인하려면 터미널 / 콘솔 창에서 &lt;code&gt;npm -v&lt;/code&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca63fd9203fa01e0094b45d6b8d3f7271e129840" translate="yes" xml:space="preserve">
          <source>To check that your services are working as you intend, you can write tests specifically for them.</source>
          <target state="translated">서비스가 의도 한대로 작동하는지 확인하기 위해 특별히 테스트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e948743b462eea7115d418352e1dbfa4b4b10ff" translate="yes" xml:space="preserve">
          <source>To check your app's version of Angular: From within your project directory, use the &lt;code&gt;ng version&lt;/code&gt; command.</source>
          <target state="translated">앱의 Angular 버전을 확인하려면 : 프로젝트 디렉토리에서 &lt;code&gt;ng version&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="13078c07edb73de738fd267221caa6c4bad9f0a1" translate="yes" xml:space="preserve">
          <source>To check your version, run &lt;code&gt;node -v&lt;/code&gt; in a terminal/console window.</source>
          <target state="translated">버전을 확인하려면 터미널 / 콘솔 창에서 &lt;code&gt;node -v&lt;/code&gt; 를 실행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="07cec4d840c8d65fc9e2b7b36b758a8ade445776" translate="yes" xml:space="preserve">
          <source>To combine property and event bindings using the banana-in-a-box syntax, &lt;code&gt;[()]&lt;/code&gt;, see &lt;a href=&quot;template-syntax#two-way&quot;&gt;Two-way Binding&lt;/a&gt;.</source>
          <target state="translated">box-in-a-box 구문 &lt;code&gt;[()]&lt;/code&gt; 을 사용하여 속성 및 이벤트 바인딩을 결합하려면 &lt;a href=&quot;template-syntax#two-way&quot;&gt;양방향 바인딩을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="642e16b417c34000ddb663b1633653c4924b0252" translate="yes" xml:space="preserve">
          <source>To combine property and event bindings using the banana-in-a-box syntax, &lt;code&gt;[()]&lt;/code&gt;, see &lt;a href=&quot;two-way-binding&quot;&gt;Two-way Binding&lt;/a&gt;.</source>
          <target state="translated">banana-in-a-box 구문, &lt;code&gt;[()]&lt;/code&gt; 를 사용하여 속성 및 이벤트 바인딩을 결합하려면 &lt;a href=&quot;two-way-binding&quot;&gt;양방향 바인딩을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="81d564a34225b7a86fd760cbe08da660a47b6d5c" translate="yes" xml:space="preserve">
          <source>To complete this tutorial, you should have a basic understanding of the following concepts:</source>
          <target state="translated">이 자습서를 완료하려면 다음 개념에 대한 기본적인 이해가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b3236306fb71061a53e3712837b9be971697d08d" translate="yes" xml:space="preserve">
          <source>To conditionally display an element, place the element's &lt;code&gt;hidden&lt;/code&gt; property in square brackets and set it to a quoted template expression that evaluates to the &lt;em&gt;opposite&lt;/em&gt; of &lt;em&gt;show&lt;/em&gt;.</source>
          <target state="translated">조건 적 요소를 표시하려면 요소의 배치 &lt;code&gt;hidden&lt;/code&gt; 대괄호 속성을하고 인용 템플릿 표현으로 설정 그 평가 &lt;em&gt;반대&lt;/em&gt; 의 &lt;em&gt;쇼&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="53182894e9c6995045a12635221f90b2e4299c08" translate="yes" xml:space="preserve">
          <source>To configure access to your own users' CLI usage data, use the &lt;code&gt;ng &lt;a href=&quot;../api/router/router#config&quot;&gt;config&lt;/a&gt;&lt;/code&gt; command to add a key to your global &lt;a href=&quot;../guide/workspace-config&quot;&gt;&lt;code&gt;angular.json&lt;/code&gt; workspace configuration file&lt;/a&gt;. The key goes under &lt;code&gt;cli.analyticsSharing&lt;/code&gt; at the top level of the file, outside the &lt;code&gt;projects&lt;/code&gt; sections. The value of the key is your organization's tracking ID, as assigned by Google Analytics. This ID is a string that looks like &lt;code&gt;UA-123456-12&lt;/code&gt;.</source>
          <target state="translated">사용자의 CLI 사용 데이터에 대한 액세스를 구성하려면 &lt;code&gt;ng &lt;a href=&quot;../api/router/router#config&quot;&gt;config&lt;/a&gt;&lt;/code&gt; 명령을 사용 하여 글로벌 &lt;a href=&quot;../guide/workspace-config&quot;&gt; &lt;code&gt;angular.json&lt;/code&gt; 작업 공간 구성 파일에&lt;/a&gt; 키를 추가 하십시오 . 키는 &lt;code&gt;projects&lt;/code&gt; 섹션 외부의 파일 최상위 레벨 에서 &lt;code&gt;cli.analyticsSharing&lt;/code&gt; 아래에 있습니다. 키의 가치는 Google 애널리틱스에서 할당 한 조직의 추적 ID입니다. 이 ID는 &lt;code&gt;UA-123456-12&lt;/code&gt; 와 같은 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="43641662c305bf9094c3e1aabcca4466e6a5d8e8" translate="yes" xml:space="preserve">
          <source>To configure access to your own users' CLI usage data, use the &lt;code&gt;ng config&lt;/code&gt; command to add a key to your global &lt;a href=&quot;../guide/workspace-config&quot;&gt;&lt;code&gt;angular.json&lt;/code&gt; workspace configuration file&lt;/a&gt;. The key goes under &lt;code&gt;cli.analyticsSharing&lt;/code&gt; at the top level of the file, outside the &lt;code&gt;projects&lt;/code&gt; sections. The value of the key is your organization's tracking ID, as assigned by Google Analytics. This ID is a string that looks like &lt;code&gt;UA-123456-12&lt;/code&gt;.</source>
          <target state="translated">자체 사용자의 CLI 사용량 데이터에 대한 액세스를 구성하려면 &lt;code&gt;ng config&lt;/code&gt; 명령을 사용 하여 글로벌 &lt;a href=&quot;../guide/workspace-config&quot;&gt; &lt;code&gt;angular.json&lt;/code&gt; 작업 공간 구성 파일에&lt;/a&gt; 키를 추가 하십시오 . 키는 &lt;code&gt;projects&lt;/code&gt; 섹션 외부의 파일 최상위 수준에있는 &lt;code&gt;cli.analyticsSharing&lt;/code&gt; 아래에 있습니다. 키 값은 Google 애널리틱스에서 할당 한 조직의 추적 ID입니다. 이 ID는 &lt;code&gt;UA-123456-12&lt;/code&gt; 와 같은 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="081b1f073ba92cd82743621b3f2f2eb2c90049a3" translate="yes" xml:space="preserve">
          <source>To configure the Angular Router, you must define a route for AngularJS URLs. To match those URLs, you add a route configuration that uses the &lt;code&gt;&lt;a href=&quot;../api/router/route#matcher&quot;&gt;matcher&lt;/a&gt;&lt;/code&gt; property. The &lt;code&gt;&lt;a href=&quot;../api/router/route#matcher&quot;&gt;matcher&lt;/a&gt;&lt;/code&gt; allows you to use custom pattern matching for URL paths. The Angular Router tries to match on more specific routes such as static and variable routes first. When it doesn't find a match, it then looks at custom matchers defined in your route configuration. If the custom matchers don't match a route, it then goes to catch-all routes, such as a 404 page.</source>
          <target state="translated">Angular Router를 구성하려면 AngularJS URL에 대한 경로를 정의해야합니다. 해당 URL을 일치 시키려면 &lt;code&gt;&lt;a href=&quot;../api/router/route#matcher&quot;&gt;matcher&lt;/a&gt;&lt;/code&gt; 특성 을 사용하는 경로 구성을 추가하십시오 . &lt;code&gt;&lt;a href=&quot;../api/router/route#matcher&quot;&gt;matcher&lt;/a&gt;&lt;/code&gt; 당신이 URL 경로에 대한 사용자 정의 패턴 매칭을 사용할 수 있습니다. Angular Router는 정적 및 가변 경로와 같은보다 구체적인 경로를 먼저 일치시킵니다. 일치하는 항목을 찾지 못하면 경로 구성에 정의 된 사용자 지정 매처를 찾습니다. 사용자 정의 매 처가 라우트와 일치하지 않으면 404 페이지와 같은 포괄 루트로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="8b0d3dc20b07af14896fcbb5d5c567cd4a2c240d" translate="yes" xml:space="preserve">
          <source>To configure the Angular Router, you must define a route for AngularJS URLs. To match those URLs, you add a route configuration that uses the &lt;code&gt;matcher&lt;/code&gt; property. The &lt;code&gt;matcher&lt;/code&gt; allows you to use custom pattern matching for URL paths. The Angular Router tries to match on more specific routes such as static and variable routes first. When it doesn't find a match, it then looks at custom matchers defined in your route configuration. If the custom matchers don't match a route, it then goes to catch-all routes, such as a 404 page.</source>
          <target state="translated">Angular Router를 구성하려면 AngularJS URL에 대한 경로를 정의해야합니다. 이러한 URL을 일치 시키려면 &lt;code&gt;matcher&lt;/code&gt; 속성 을 사용하는 경로 구성을 추가합니다 . &lt;code&gt;matcher&lt;/code&gt; 당신이 URL 경로에 대한 사용자 정의 패턴 매칭을 사용할 수 있습니다. Angular Router는 먼저 정적 및 가변 경로와 같은보다 구체적인 경로에서 일치를 시도합니다. 일치하는 항목을 찾지 못하면 경로 구성에 정의 된 사용자 지정 일치자를 찾습니다. 커스텀 매 처가 경로와 일치하지 않으면 404 페이지와 같은 포괄 경로로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="e972c128dc7bc14f3f17a87fcada88a6a2d87a1e" translate="yes" xml:space="preserve">
          <source>To configure whether navigation requests are sent through to the network or not, see the &lt;a href=&quot;service-worker-config#navigation-request-strategy&quot;&gt;navigationRequestStrategy&lt;/a&gt; section.</source>
          <target state="translated">탐색 요청이 네트워크를 통해 전송되는지 여부를 구성하려면 &lt;a href=&quot;service-worker-config#navigation-request-strategy&quot;&gt;navigationRequestStrategy&lt;/a&gt; 섹션을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="b884870273119a7d7e697d247c4d659cdde8b585" translate="yes" xml:space="preserve">
          <source>To confirm submission, open the console where you should see an object containing the name and address you submitted.</source>
          <target state="translated">제출을 확인하려면 제출 한 이름과 주소가 포함 된 개체를 볼 수있는 콘솔을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="85a5f9228b0c283a4c0767bf17f5218cf21f432e" translate="yes" xml:space="preserve">
          <source>To confirm that the display updates as the user adds heroes, see the live example.</source>
          <target state="translated">사용자가 Hero를 추가 할 때 디스플레이가 업데이트되는지 확인하려면 라이브 예제를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="f6838e6bcfc83475121bb1e4ad55f4fbcaddb58b" translate="yes" xml:space="preserve">
          <source>To confirm that two-way data binding works for the entire hero model, add a new binding at the top to the component's &lt;code&gt;diagnostic&lt;/code&gt; property.</source>
          <target state="translated">양방향 데이터 바인딩이 전체 Hero 모델에 대해 작동하는지 확인하려면 상단에 새 바인딩을 구성 요소의 &lt;code&gt;diagnostic&lt;/code&gt; 속성에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="99be46bd11d0de83ad9e296968ef2c5a7118146b" translate="yes" xml:space="preserve">
          <source>To continue exploring Angular, choose either of the following options:</source>
          <target state="translated">Angular를 계속 탐색하려면 다음 옵션 중 하나를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="a3014c43a2313b977c6aed25419c31a95265fa08" translate="yes" xml:space="preserve">
          <source>To contrast the two types of components, there are components which are included in the template, which are declarative. Additionally, there are components which you load imperatively; that is, entry components.</source>
          <target state="translated">두 가지 유형의 구성 요소를 대조하기 위해 템플릿에 포함 된 구성 요소가 있습니다. 또한 반드시로드해야하는 구성 요소가 있습니다. 즉, 입력 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="959d46928d85d110fdade5f2293bf97890445838" translate="yes" xml:space="preserve">
          <source>To control how this encapsulation happens on a &lt;em&gt;per component&lt;/em&gt; basis, you can set the &lt;em&gt;view encapsulation mode&lt;/em&gt; in the component metadata. Choose from the following modes:</source>
          <target state="translated">이 캡슐화가 &lt;em&gt;구성 요소&lt;/em&gt; 별로 수행 되는 방식을 제어하기 위해 구성 요소 메타 데이터에서 &lt;em&gt;보기 캡슐화 모드&lt;/em&gt; 를 설정할 수 있습니다 . 다음 모드 중에서 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="c93024cc33ad0ddbba14e6bbd25bf12722637c4a" translate="yes" xml:space="preserve">
          <source>To control the state of the button, set the &lt;code&gt;disabled&lt;/code&gt;&lt;em&gt;property&lt;/em&gt;,</source>
          <target state="translated">버튼의 상태를 제어하려면 &lt;code&gt;disabled&lt;/code&gt; &lt;em&gt;속성을&lt;/em&gt; 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="fbe3fde2fb0a60e4ec9cfcd947c47d4e664ce7a7" translate="yes" xml:space="preserve">
          <source>To convert this binding to use specialized objects, turn the array of hero names into an array of &lt;code&gt;Hero&lt;/code&gt; objects. For that you'll need a &lt;code&gt;Hero&lt;/code&gt; class:</source>
          <target state="translated">특수한 개체를 사용하도록이 바인딩을 변환하려면 영웅 이름 배열을 &lt;code&gt;Hero&lt;/code&gt; 개체 배열로 바꿉니다 . 이를 위해서는 &lt;code&gt;Hero&lt;/code&gt; 클래스 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="3e235ca1b49cbf515a53d4eb460cb0a499395651" translate="yes" xml:space="preserve">
          <source>To copy a code example from this tutorial, click the icon at the top right of the code example box, and then paste the code snippet from the clipboard into StackBlitz.</source>
          <target state="translated">이 학습서에서 코드 예제를 복사하려면 코드 예제 상자의 오른쪽 상단에있는 아이콘을 클릭 한 후 클립 보드의 코드 스 니펫을 StackBlitz에 붙여 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="b27e4d885fe2defbb235fa198172a39e1ab9f6e4" translate="yes" xml:space="preserve">
          <source>To correct the problem, call &lt;code&gt;compileComponents()&lt;/code&gt; as explained &lt;a href=&quot;testing#compile-components&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">문제를 해결하려면 &lt;a href=&quot;testing#compile-components&quot;&gt;아래&lt;/a&gt; 설명 된 대로 &lt;code&gt;compileComponents()&lt;/code&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="b99d3a2a82a487cd7d58a6066fda66fb46065bff" translate="yes" xml:space="preserve">
          <source>To correct the problem, call &lt;code&gt;compileComponents()&lt;/code&gt; as explained &lt;a href=&quot;testing-components-scenarios#compile-components&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">문제를 해결하려면 &lt;a href=&quot;testing-components-scenarios#compile-components&quot;&gt;아래&lt;/a&gt; 설명 된 대로 &lt;code&gt;compileComponents()&lt;/code&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="979325cb37deb2c50164b83f04e810b1ac2b55a5" translate="yes" xml:space="preserve">
          <source>To correct this error, export a function from the module and refer to the function in a &lt;code&gt;&lt;a href=&quot;../api/core/factorysansprovider#useFactory&quot;&gt;useFactory&lt;/a&gt;&lt;/code&gt; provider instead.</source>
          <target state="translated">이 오류를 정정하려면 모듈에서 함수를 &lt;code&gt;&lt;a href=&quot;../api/core/factorysansprovider#useFactory&quot;&gt;useFactory&lt;/a&gt;&lt;/code&gt; 대신 useFactory 제공자 의 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0de991b19c02e8ee0427a429122c7e2d73a6ca37" translate="yes" xml:space="preserve">
          <source>To correct this error, export a function from the module and refer to the function in a &lt;code&gt;useFactory&lt;/code&gt; provider instead.</source>
          <target state="translated">이 오류를 수정하려면 모듈에서 함수를 &lt;code&gt;useFactory&lt;/code&gt; 대신 useFactory 공급자 의 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ecaf5471a0ced58416233b3602e2e5a39d32a9d" translate="yes" xml:space="preserve">
          <source>To correct this error, provide the initial value of the variable in an initializer clause &lt;em&gt;on the same line&lt;/em&gt;.</source>
          <target state="translated">이 오류를 정정하려면 &lt;em&gt;동일한 행&lt;/em&gt; 의 이니셜 라이저 절 &lt;em&gt;에서&lt;/em&gt; 변수의 초기 값을 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="4dee6cdbff0c50b18b7cf0744c39d9afb9e81794" translate="yes" xml:space="preserve">
          <source>To correct this error, refer to non-destructured values.</source>
          <target state="translated">이 오류를 해결하려면 비 구조화 값을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="babb4800b9ce7124e0062940991131f750bd641a" translate="yes" xml:space="preserve">
          <source>To create a component using the Angular CLI:</source>
          <target state="translated">Angular CLI를 사용하여 구성 요소를 생성하려면 :</target>
        </trans-unit>
        <trans-unit id="88fabc18833c78d0934957c18fe19782c262d822" translate="yes" xml:space="preserve">
          <source>To create a component, verify that you have met the following prerequisites:</source>
          <target state="translated">구성 요소를 생성하려면 다음 전제 조건을 충족했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="67bb6a40877c035fe23caa2365ec0af551e4e717" translate="yes" xml:space="preserve">
          <source>To create a file in the &lt;code&gt;src/locale&lt;/code&gt; directory, specify the output path as an option, as shown in the following example:</source>
          <target state="translated">&lt;code&gt;src/locale&lt;/code&gt; 디렉토리에 파일을 생성하려면 다음 예와 같이 출력 경로를 옵션으로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="8122f0d68c6098d4c122991ebd95c6cf88d61b30" translate="yes" xml:space="preserve">
          <source>To create a nested group in &lt;code&gt;profileForm&lt;/code&gt;, add a nested &lt;code&gt;address&lt;/code&gt; element to the form group instance.</source>
          <target state="translated">&lt;code&gt;profileForm&lt;/code&gt; 에 중첩 된 그룹을 만들려면 중첩 된 &lt;code&gt;address&lt;/code&gt; 요소를 양식 그룹 인스턴스에 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="fafbd773ca94ccd66053f04954d31716c4ab9f28" translate="yes" xml:space="preserve">
          <source>To create a new application in the strict mode within an existing non-strict workspace, run the following command:</source>
          <target state="translated">기존의 엄격하지 않은 작업 공간 내에서 엄격 모드로 새 애플리케이션을 작성하려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="dbca6227b9db6ab1847c89187b909d5fe85abac4" translate="yes" xml:space="preserve">
          <source>To create a new component manually:</source>
          <target state="translated">새 구성 요소를 수동으로 생성하려면 :</target>
        </trans-unit>
        <trans-unit id="d2bf7fb2d3e94211afcd57a10f20c4c45cfe0d7d" translate="yes" xml:space="preserve">
          <source>To create a new workspace and an initial app project:</source>
          <target state="translated">새 작업 공간 및 초기 앱 프로젝트를 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5bd4653200aaca61df950cdd4eca5d949291ae56" translate="yes" xml:space="preserve">
          <source>To create a new workspace and application using the strict mode, run the following command:</source>
          <target state="translated">엄격 모드를 사용하여 새 작업 공간 및 애플리케이션을 작성하려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="f144d38768edd99f2d27499d71edd950a08584a3" translate="yes" xml:space="preserve">
          <source>To create a new workspace and initial starter app:</source>
          <target state="translated">새 작업 공간 및 초기 스타터 앱을 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1aa719950868f1d4fa3ac83a344dcfa8c80b6018" translate="yes" xml:space="preserve">
          <source>To create a reusable animation, use the &lt;a href=&quot;../api/animations/animation&quot;&gt;&lt;code&gt;animation()&lt;/code&gt;&lt;/a&gt; method to define an animation in a separate &lt;code&gt;.ts&lt;/code&gt; file and declare this animation definition as a &lt;code&gt;const&lt;/code&gt; export variable. You can then import and reuse this animation in any of your app components using the &lt;a href=&quot;../api/animations/useanimation&quot;&gt;&lt;code&gt;useAnimation()&lt;/code&gt;&lt;/a&gt; API.</source>
          <target state="translated">재사용 가능한 애니메이션을 만들려면 &lt;a href=&quot;../api/animations/animation&quot;&gt; &lt;code&gt;animation()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 별도의 &lt;code&gt;.ts&lt;/code&gt; 파일에 애니메이션을 정의하고이 애니메이션 정의를 &lt;code&gt;const&lt;/code&gt; 내보내기 변수 로 선언하십시오 . 그런 다음 &lt;a href=&quot;../api/animations/useanimation&quot;&gt; &lt;code&gt;useAnimation()&lt;/code&gt; &lt;/a&gt; API를 사용하여 앱 구성 요소에서이 애니메이션을 가져 와서 재사용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75d0e30751a493533457e112686e8dcb02d5af60" translate="yes" xml:space="preserve">
          <source>To create a single class binding, use the prefix &lt;code&gt;class&lt;/code&gt; followed by a dot and the name of the CSS class&amp;mdash;for example, &lt;code&gt;[class.sale]=&quot;onSale&quot;&lt;/code&gt;. Angular adds the class when the bound expression, &lt;code&gt;onSale&lt;/code&gt; is truthy, and it removes the class when the expression is falsy&amp;mdash;with the exception of &lt;code&gt;undefined&lt;/code&gt;. See &lt;a href=&quot;style-precedence#styling-delegation&quot;&gt;styling delegation&lt;/a&gt; for more information.</source>
          <target state="translated">단일 클래스 바인딩을 만들려면 접두사 &lt;code&gt;class&lt;/code&gt; 뒤에 점과 CSS 클래스 이름을 사용합니다 (예 : &lt;code&gt;[class.sale]=&quot;onSale&quot;&lt;/code&gt; ) . Angular는 바인딩 된 표현식 &lt;code&gt;onSale&lt;/code&gt; 이 진실 일 때 클래스를 추가하고 , &lt;code&gt;undefined&lt;/code&gt; 를 제외하고 표현식이 거짓 일 때 클래스를 제거합니다 . 자세한 내용은 &lt;a href=&quot;style-precedence#styling-delegation&quot;&gt;스타일 위임&lt;/a&gt; 을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="654531e7f01f2a99237d0195284ddb4817aa8ab0" translate="yes" xml:space="preserve">
          <source>To create a single style binding, use the prefix &lt;code&gt;&lt;a href=&quot;../api/animations/style&quot;&gt;style&lt;/a&gt;&lt;/code&gt; followed by a dot and the name of the CSS style property&amp;mdash;for example, &lt;code&gt;[style.width]=&quot;width&quot;&lt;/code&gt;. Angular sets the property to the value of the bound expression, which is usually a string. Optionally, you can add a unit extension like &lt;code&gt;em&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt;, which requires a number type.</source>
          <target state="translated">단일 스타일 바인딩을 만들려면 접두사 &lt;code&gt;&lt;a href=&quot;../api/animations/style&quot;&gt;style&lt;/a&gt;&lt;/code&gt; 다음에 점과 CSS 스타일 속성의 이름을 사용합니다 (예 : &lt;code&gt;[style.width]=&quot;width&quot;&lt;/code&gt; ) . Angular는 속성을 일반적으로 문자열 인 바인딩 된 식의 값으로 설정합니다. 선택적 으로 숫자 유형이 필요한 &lt;code&gt;em&lt;/code&gt; 또는 &lt;code&gt;%&lt;/code&gt; 와 같은 단위 확장자를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="29ae33325b206d2fd3cdedfd24a2c41e5f192288" translate="yes" xml:space="preserve">
          <source>To create the cart page, you begin by following the same steps you did to create the product details component and to set up routing for the new component.</source>
          <target state="translated">장바구니 페이지를 작성하려면 제품 세부 사항 구성 요소를 작성하고 새 구성 요소에 대한 라우팅을 설정하는 단계와 동일한 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="090dfe1a5c79f77a9be595e199d5fab1f453c8d6" translate="yes" xml:space="preserve">
          <source>To create the cart view, begin by following the same steps you did to create the product details component and configure routing for the new component.</source>
          <target state="translated">카트보기를 만들려면 먼저 제품 세부 정보 구성 요소를 만들고 새 구성 요소에 대한 라우팅을 구성 할 때 수행 한 것과 동일한 단계를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="594ec3ddcc19c25f73ea897495b521aecaf86016" translate="yes" xml:space="preserve">
          <source>To create the server-side app module, &lt;code&gt;app.server.module.ts&lt;/code&gt;, run the following CLI command.</source>
          <target state="translated">서버 측 앱 모듈 &lt;code&gt;app.server.module.ts&lt;/code&gt; 를 작성하려면 다음 CLI 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="a1d7d554f2d72ca28c730058079d294822be35c1" translate="yes" xml:space="preserve">
          <source>To create, build, and serve a new, basic Angular project on a development server, go to the parent directory of your new workspace use the following commands:</source>
          <target state="translated">개발 서버에서 새 기본 Angular 프로젝트를 작성, 빌드 및 제공하려면 다음 명령을 사용하여 새 작업 공간의 상위 디렉토리로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="65acbd001432e22b30e796e7e61e3dfe440088a8" translate="yes" xml:space="preserve">
          <source>To customize the default option comparison algorithm, &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; supports &lt;code&gt;compareWith&lt;/code&gt; input. &lt;code&gt;compareWith&lt;/code&gt; takes a &lt;strong&gt;function&lt;/strong&gt; which has two arguments: &lt;code&gt;option1&lt;/code&gt; and &lt;code&gt;option2&lt;/code&gt;. If &lt;code&gt;compareWith&lt;/code&gt; is given, Angular selects option by the return value of the function.</source>
          <target state="translated">기본 옵션 비교 알고리즘을 사용자 정의하기 위해 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 는 &lt;code&gt;compareWith&lt;/code&gt; 입력을 지원합니다 . &lt;code&gt;compareWith&lt;/code&gt; 는 &lt;code&gt;option1&lt;/code&gt; 과 &lt;code&gt;option2&lt;/code&gt; 의 두 가지 인수가 있는 &lt;strong&gt;함수&lt;/strong&gt; 를 사용 합니다. 경우 &lt;code&gt;compareWith&lt;/code&gt; 이 주어진 함수의 반환 값에 의해 각도 선택 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="c9057dec56a92572abc6bcb328cdc254209b6283" translate="yes" xml:space="preserve">
          <source>To customize the default option comparison algorithm, &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; supports &lt;code&gt;compareWith&lt;/code&gt; input. See the &lt;code&gt;&lt;a href=&quot;selectcontrolvalueaccessor&quot;&gt;SelectControlValueAccessor&lt;/a&gt;&lt;/code&gt; for usage.</source>
          <target state="translated">기본 옵션 비교 알고리즘을 사용자 정의하기 위해 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 는 &lt;code&gt;compareWith&lt;/code&gt; 입력을 지원합니다 . 사용법 은 &lt;code&gt;&lt;a href=&quot;selectcontrolvalueaccessor&quot;&gt;SelectControlValueAccessor&lt;/a&gt;&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="12614d5a0a4f9980916f0bd6829fb9e94aeee5ca" translate="yes" xml:space="preserve">
          <source>To deactivate the service worker, remove or rename the &lt;code&gt;ngsw.json&lt;/code&gt; file. When the service worker's request for &lt;code&gt;ngsw.json&lt;/code&gt; returns a &lt;code&gt;404&lt;/code&gt;, then the service worker removes all of its caches and de-registers itself, essentially self-destructing.</source>
          <target state="translated">서비스 워커를 비활성화하려면 &lt;code&gt;ngsw.json&lt;/code&gt; 파일을 제거하거나 이름을 바꾸십시오 . &lt;code&gt;ngsw.json&lt;/code&gt; 에 대한 서비스 워커의 요청 이 &lt;code&gt;404&lt;/code&gt; 를 리턴하면 , 서비스 워커는 모든 캐시를 제거하고 본질적으로 자체 파괴적인 자체를 등록 취소합니다.</target>
        </trans-unit>
        <trans-unit id="9108d6f3d8bba0bf373979ce840c2d85dbc55392" translate="yes" xml:space="preserve">
          <source>To declare the styles for a component in a separate file, add a &lt;code&gt;stylesUrls&lt;/code&gt; property to the &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; decorator.</source>
          <target state="translated">별도의 파일에서 구성 요소의 스타일을 선언하려면 &lt;code&gt;stylesUrls&lt;/code&gt; 속성을 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; 데코레이터에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="95e38d849c5796bd6398c2761b41e463c7976d04" translate="yes" xml:space="preserve">
          <source>To define a class as a service in Angular, use the &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; decorator to provide the metadata that allows Angular to inject it into a component as a &lt;em&gt;dependency&lt;/em&gt;. Similarly, use the &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; decorator to indicate that a component or other class (such as another service, a pipe, or an NgModule) &lt;em&gt;has&lt;/em&gt; a dependency.</source>
          <target state="translated">Angular에서 클래스를 서비스로 정의하려면 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; 데코레이터를 사용하여 Angular가 클래스를 구성 요소에 &lt;em&gt;종속성&lt;/em&gt; 으로 주입 할 수있는 메타 데이터를 제공하십시오 . 마찬가지로 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; 데코레이터를 사용하여 구성 요소 나 다른 클래스 (예 : 다른 서비스, 파이프 또는 NgModule) 에 종속성 &lt;em&gt;이&lt;/em&gt; 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ad6c984d27957b7c6989d1d288e104c9c138aa30" translate="yes" xml:space="preserve">
          <source>To define a directive, mark the class with the decorator and provide metadata.</source>
          <target state="translated">지시문을 정의하려면 데코레이터로 클래스를 표시하고 메타 데이터를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="02af62d3d61d2c5e19973a6b482fa1173a786ab6" translate="yes" xml:space="preserve">
          <source>To define a dynamic form, take the following steps.</source>
          <target state="translated">동적 양식을 정의하려면 다음 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e42033ffe1eecc4e2eee5697858df411d08f9c66" translate="yes" xml:space="preserve">
          <source>To define a template as an external file, add a &lt;code&gt;templateUrl&lt;/code&gt; property to the &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; decorator.</source>
          <target state="translated">템플릿을 외부 파일로 정의하려면 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt; 데코레이터에 &lt;code&gt;templateUrl&lt;/code&gt; 속성을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="52964b4b5ce54e1050f8c2ee29cd57e64a45fb23" translate="yes" xml:space="preserve">
          <source>To define a template within the component, add a &lt;code&gt;template&lt;/code&gt; property to the &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; decorator that contains the HTML you want to use.</source>
          <target state="translated">구성 요소 내에서 템플릿을 정의하려면 사용할 HTML이 포함 된 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt; 데코레이터에 &lt;code&gt;template&lt;/code&gt; 속성을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="7461bcf852b17248b69621e8549d73cd98177d21" translate="yes" xml:space="preserve">
          <source>To define and show an error message when appropriate, take the following steps.</source>
          <target state="translated">적절한 경우 오류 메시지를 정의하고 표시하려면 다음 단계를 수행하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
