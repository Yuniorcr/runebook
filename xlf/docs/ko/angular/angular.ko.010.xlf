<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="angular">
    <body>
      <group id="angular">
        <trans-unit id="aabd7c813ffdc03e68f8ddf0d0e075e18a3d7a6d" translate="yes" xml:space="preserve">
          <source>In the Angular CLI, a standalone application or &lt;a href=&quot;glossary#library&quot;&gt;library&lt;/a&gt; that can be created or modified by a CLI command.</source>
          <target state="translated">Angular CLI에서 CLI 명령으로 작성하거나 수정할 수 있는 독립형 애플리케이션 또는 &lt;a href=&quot;glossary#library&quot;&gt;라이브러리&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b7b501033bcab7677bbf386ea844c636f41ee7a1" translate="yes" xml:space="preserve">
          <source>In the CLI configuration file, &lt;code&gt;angular.json&lt;/code&gt;, add the &lt;code&gt;proxyConfig&lt;/code&gt; option to the &lt;code&gt;serve&lt;/code&gt; target:</source>
          <target state="translated">CLI를 구성 파일에서 &lt;code&gt;angular.json&lt;/code&gt; , 추가 &lt;code&gt;proxyConfig&lt;/code&gt; (가)에 옵션을 &lt;code&gt;serve&lt;/code&gt; 대상 :</target>
        </trans-unit>
        <trans-unit id="61763a5a70701c3c12fbb07b3b6f0e84eaf7bbab" translate="yes" xml:space="preserve">
          <source>In the CLI configuration file, &lt;code&gt;angular.json&lt;/code&gt;, point to the JavaScript proxy configuration file:</source>
          <target state="translated">CLI 구성 파일 &lt;code&gt;angular.json&lt;/code&gt; 에서 JavaScript 프록시 구성 파일을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="122be2b5ab964b68505d923b034cfdbee86e0ef4" translate="yes" xml:space="preserve">
          <source>In the DOM of a hybrid ngUpgrade application are components and directives from both AngularJS and Angular. These components communicate with each other by using the input and output bindings of their respective frameworks, which ngUpgrade bridges together. They may also communicate through shared injected dependencies, as described above.</source>
          <target state="translated">하이브리드 ngUpgrade 애플리케이션의 DOM에는 AngularJS와 Angular의 구성 요소와 지시문이 있습니다. 이러한 구성 요소는 각 프레임 워크의 입력 및 출력 바인딩을 사용하여 서로 통신합니다. 또한 위에서 설명한대로 공유 된 주입 된 종속성을 통해 통신 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="da4aac216c4150aa0c4b76a0cbffacab0ba55a37" translate="yes" xml:space="preserve">
          <source>In the DOM of a running Angular application with emulated view encapsulation enabled, each DOM element has some extra attributes attached to it:</source>
          <target state="translated">에뮬레이트 된 뷰 캡슐화가 활성화 된 실행중인 Angular 응용 프로그램의 DOM에서 각 DOM 요소에는 몇 가지 추가 속성이 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="967824d97e856f8a5701294372f66633e02cbd55" translate="yes" xml:space="preserve">
          <source>In the HTML template file, use the trigger name to attach the defined animations to the HTML element to be animated.</source>
          <target state="translated">HTML 템플리트 파일에서 트리거 이름을 사용하여 정의 된 애니메이션을 애니메이션 할 HTML 요소에 첨부하십시오.</target>
        </trans-unit>
        <trans-unit id="083a121e6216962299890132cebbe02f632fa294" translate="yes" xml:space="preserve">
          <source>In the HTML template, the animation event is passed back via &lt;code&gt;$event&lt;/code&gt;, as &lt;code&gt;@trigger.start&lt;/code&gt; and &lt;code&gt;@trigger.done&lt;/code&gt;, where &lt;code&gt;&lt;a href=&quot;../api/animations/trigger&quot;&gt;trigger&lt;/a&gt;&lt;/code&gt; is the name of the trigger being used. In our example, the trigger &lt;code&gt;openClose&lt;/code&gt; appears as follows.</source>
          <target state="translated">HTML 템플릿에서 애니메이션 이벤트는 &lt;code&gt;$event&lt;/code&gt; &lt;code&gt;@trigger.start&lt;/code&gt; 통해 @ trigger.start 및 &lt;code&gt;@trigger.done&lt;/code&gt; 으로 다시 전달됩니다 . 여기서 &lt;code&gt;&lt;a href=&quot;../api/animations/trigger&quot;&gt;trigger&lt;/a&gt;&lt;/code&gt; 는 사용중인 트리거의 이름입니다. 이 예에서는 &lt;code&gt;openClose&lt;/code&gt; 트리거 가 다음과 같이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="9f68507ab6ee93f0f57a92342cc4e0c3de28bf7e" translate="yes" xml:space="preserve">
          <source>In the HTML template, the animation event is passed back via &lt;code&gt;$event&lt;/code&gt;, as &lt;code&gt;@trigger.start&lt;/code&gt; and &lt;code&gt;@trigger.done&lt;/code&gt;, where &lt;code&gt;&lt;a href=&quot;../api/animations/trigger&quot;&gt;trigger&lt;/a&gt;&lt;/code&gt; is the name of the trigger being used. In this example, the trigger &lt;code&gt;openClose&lt;/code&gt; appears as follows.</source>
          <target state="translated">HTML 템플릿에서 애니메이션 이벤트는 &lt;code&gt;$event&lt;/code&gt; 를 통해 &lt;code&gt;@trigger.start&lt;/code&gt; 및 &lt;code&gt;@trigger.done&lt;/code&gt; 으로 다시 전달됩니다 . 여기서 &lt;code&gt;&lt;a href=&quot;../api/animations/trigger&quot;&gt;trigger&lt;/a&gt;&lt;/code&gt; 는 사용중인 트리거의 이름입니다. 이 예에서 &lt;code&gt;openClose&lt;/code&gt; 트리거 는 다음과 같이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="dfcba8b351ad67cbd3018ae060d6b3b0cce679cf" translate="yes" xml:space="preserve">
          <source>In the Karma configuration file, &lt;code&gt;karma.conf.js&lt;/code&gt;, add a custom launcher called ChromeHeadlessCI below browsers:</source>
          <target state="translated">Karma 구성 파일 &lt;code&gt;karma.conf.js&lt;/code&gt; 에서 브라우저 아래에 ChromeHeadlessCI라는 사용자 정의 실행기를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="0d8933c6633530a939e7e7a904014c408f4331c7" translate="yes" xml:space="preserve">
          <source>In the Phone detail controller, you'll have two members: One for the phone that the user is looking at and another for the URL of the currently displayed image:</source>
          <target state="translated">휴대 전화 세부 정보 컨트롤러에는 두 명의 구성원이 있습니다. 하나는 사용자가보고있는 전화와 다른 하나는 현재 표시된 이미지의 URL입니다.</target>
        </trans-unit>
        <trans-unit id="0d1a2ab17dd8ff5eedf9e71bb387641a06044ce9" translate="yes" xml:space="preserve">
          <source>In the TypeScript configuration file, the &quot;target&quot; option in the &lt;code&gt;compilerOptions&lt;/code&gt; section determines the ECMAScript target version that the code is compiled to. Modern browsers support ES2015 natively, while ES5 is more commonly used to support legacy browsers.</source>
          <target state="translated">TypeScript 구성 파일에서 &lt;code&gt;compilerOptions&lt;/code&gt; 섹션 의 &quot;target&quot;옵션 은 코드가 컴파일되는 ECMAScript 대상 버전을 결정합니다. 최신 브라우저는 기본적으로 ES2015를 지원하는 반면 ES5는 레거시 브라우저를 지원하는 데 더 일반적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e4df01dda361adbb05b79a30335d5fac348e1b3c" translate="yes" xml:space="preserve">
          <source>In the above code snippet, &lt;code&gt;transAnimation&lt;/code&gt; is made reusable by declaring it as an export variable.</source>
          <target state="translated">위의 코드 스 니펫에서 &lt;code&gt;transAnimation&lt;/code&gt; 은 내보내기 변수로 선언하여 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="999956f8131dbd54f089f149eff9fb3d864570b4" translate="yes" xml:space="preserve">
          <source>In the above code, we applied the &lt;code&gt;void&lt;/code&gt; state when the HTML element isn't attached to a view.</source>
          <target state="translated">위 코드 에서 HTML 요소가 뷰에 연결되지 않은 경우 &lt;code&gt;void&lt;/code&gt; 상태를 적용했습니다 .</target>
        </trans-unit>
        <trans-unit id="6bcbc62f2692a7cad7cfffdc2e7cf4b7e559d979" translate="yes" xml:space="preserve">
          <source>In the above code, you applied the &lt;code&gt;void&lt;/code&gt; state when the HTML element isn't attached to a view.</source>
          <target state="translated">위 코드 에서 HTML 요소가 뷰에 연결되지 않은 경우 &lt;code&gt;void&lt;/code&gt; 상태 를 적용했습니다 .</target>
        </trans-unit>
        <trans-unit id="cea6f478656e7fe4e653914666132b5379bca812" translate="yes" xml:space="preserve">
          <source>In the above example, a breakpoint on the pipe's request for data shows the following:</source>
          <target state="translated">위의 예에서 파이프의 데이터 요청 중단 점은 다음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4e34e2cb53ddbb0085cbc3e5a61b4772c7d5c3c2" translate="yes" xml:space="preserve">
          <source>In the above example:</source>
          <target state="translated">위의 예에서 :</target>
        </trans-unit>
        <trans-unit id="8a1eba3971dbfd135fb71e9d8c51d2907a609acb" translate="yes" xml:space="preserve">
          <source>In the above scenario, the service worker is not able to serve an asset that would normally be cached. That particular app version is broken and there is no way to fix the state of the client without reloading the page. In such cases, the service worker notifies the client by sending an &lt;code&gt;&lt;a href=&quot;../api/service-worker/unrecoverablestateevent&quot;&gt;UnrecoverableStateEvent&lt;/a&gt;&lt;/code&gt; event. You can subscribe to &lt;code&gt;&lt;a href=&quot;../api/service-worker/swupdate&quot;&gt;SwUpdate&lt;/a&gt;#unrecoverable&lt;/code&gt; to be notified and handle these errors.</source>
          <target state="translated">위의 시나리오에서 서비스 워커는 일반적으로 캐시되는 자산을 제공 할 수 없습니다. 특정 앱 버전이 손상되었으며 페이지를 다시로드하지 않고는 클라이언트의 상태를 수정할 방법이 없습니다. 이러한 경우 서비스 워커는 &lt;code&gt;&lt;a href=&quot;../api/service-worker/unrecoverablestateevent&quot;&gt;UnrecoverableStateEvent&lt;/a&gt;&lt;/code&gt; 이벤트 를 전송하여 클라이언트에 알립니다 . &lt;code&gt;&lt;a href=&quot;../api/service-worker/swupdate&quot;&gt;SwUpdate&lt;/a&gt;#unrecoverable&lt;/code&gt; 에 가입하여 알림을 받고 이러한 오류를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="577e109d05bd16fdfef27736b2c5e520043e9b7f" translate="yes" xml:space="preserve">
          <source>In the ad banner, all components implement a common &lt;code&gt;AdComponent&lt;/code&gt; interface to standardize the API for passing data to the components.</source>
          <target state="translated">광고 배너에서 모든 구성 요소는 공통 &lt;code&gt;AdComponent&lt;/code&gt; 인터페이스를 구현 하여 구성 요소에 데이터를 전달하기위한 API를 표준화합니다.</target>
        </trans-unit>
        <trans-unit id="19609a3f68be8a8d8459bb2350900bd1a47c1bf5" translate="yes" xml:space="preserve">
          <source>In the basic CLI-generated app, modules are eagerly loaded which means that they are all loaded when the app launches. Angular uses an injector system to make things available between modules. In an eagerly loaded app, the root application injector makes all of the providers in all of the modules available throughout the app.</source>
          <target state="translated">기본 CLI 생성 앱에서 모듈이 열성적으로로드되므로 앱이 실행될 때 모듈이 모두로드됩니다. Angular는 인젝터 시스템을 사용하여 모듈간에 사물을 제공합니다. 열심히로드 된 앱에서 루트 응용 프로그램 인젝터는 모든 모듈의 모든 공급자를 앱 전체에서 사용할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="d217fba68efca130ef3c06341acbd707ba067782" translate="yes" xml:space="preserve">
          <source>In the builder source directory, we have created a new test file &lt;code&gt;index.spec.ts&lt;/code&gt;. The code creates new instances of &lt;code&gt;JsonSchemaRegistry&lt;/code&gt; (for schema validation), &lt;code&gt;TestingArchitectHost&lt;/code&gt; (an in-memory implementation of &lt;code&gt;ArchitectHost&lt;/code&gt;), and &lt;code&gt;Architect&lt;/code&gt;.</source>
          <target state="translated">빌더 소스 디렉토리에서 새 테스트 파일 &lt;code&gt;index.spec.ts&lt;/code&gt; 를 작성했습니다 . 이 코드는 &lt;code&gt;JsonSchemaRegistry&lt;/code&gt; (스키마 유효성 검사 용), &lt;code&gt;TestingArchitectHost&lt;/code&gt; (메모리 내 구현 &lt;code&gt;ArchitectHost&lt;/code&gt; ) 및 &lt;code&gt;Architect&lt;/code&gt; 의 새 인스턴스를 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="d959bf9da8f9b9700248ea3b26f61fd618b0cb98" translate="yes" xml:space="preserve">
          <source>In the builder source directory, we have created a new test file &lt;code&gt;my-builder.spec.ts&lt;/code&gt;. The code creates new instances of &lt;code&gt;JsonSchemaRegistry&lt;/code&gt; (for schema validation), &lt;code&gt;TestingArchitectHost&lt;/code&gt; (an in-memory implementation of &lt;code&gt;ArchitectHost&lt;/code&gt;), and &lt;code&gt;Architect&lt;/code&gt;.</source>
          <target state="translated">빌더 소스 디렉토리에서 새 테스트 파일 &lt;code&gt;my-builder.spec.ts&lt;/code&gt; 를 생성했습니다 . 이 코드는 &lt;code&gt;JsonSchemaRegistry&lt;/code&gt; (스키마 유효성 검사 용), &lt;code&gt;TestingArchitectHost&lt;/code&gt; ( &lt;code&gt;ArchitectHost&lt;/code&gt; 의 메모리 내 구현 ) 및 &lt;code&gt;Architect&lt;/code&gt; 의 새 인스턴스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="b4f98a695082e7fd1036ab253a946e35cc9beb2c" translate="yes" xml:space="preserve">
          <source>In the case of hybrid applications, the &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; bridges the AngularJS and Angular approaches. Here's what happens:</source>
          <target state="translated">하이브리드 애플리케이션의 경우 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 은 AngularJS 및 Angular 방식을 연결합니다. 다음과 같은 일이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="91461870129c519bada0129bab899cc6a8400941" translate="yes" xml:space="preserve">
          <source>In the child</source>
          <target state="translated">아이에서</target>
        </trans-unit>
        <trans-unit id="514d6aabad56aee8cc774c96c1fb20cc55ba211e" translate="yes" xml:space="preserve">
          <source>In the child's template</source>
          <target state="translated">자녀의 템플릿에서</target>
        </trans-unit>
        <trans-unit id="4ba5c1d9c582fab11dbc6b441f66b76c1660fd68" translate="yes" xml:space="preserve">
          <source>In the code snippet above, the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator indicates unidirectional transitions, and &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; is bidirectional. Within the transition, &lt;code&gt;&lt;a href=&quot;../api/animations/animate&quot;&gt;animate&lt;/a&gt;()&lt;/code&gt; specifies how long the transition takes. In this case, the state change from &lt;code&gt;open&lt;/code&gt; to &lt;code&gt;closed&lt;/code&gt; takes one second, expressed here as &lt;code&gt;1s&lt;/code&gt;.</source>
          <target state="translated">위의 코드 조각에서 &lt;code&gt;=&amp;gt;&lt;/code&gt; 연산자는 단방향 전환을 나타내고 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 는 양방향입니다. 전환 내에서 &lt;code&gt;&lt;a href=&quot;../api/animations/animate&quot;&gt;animate&lt;/a&gt;()&lt;/code&gt; 는 전환에 걸리는 시간을 지정합니다. 이 경우의 상태 변화 &lt;code&gt;open&lt;/code&gt; 에 &lt;code&gt;closed&lt;/code&gt; 여기에 표현 된 1 초 소요 &lt;code&gt;1s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78631c8d5215d0ec4e7d6e3f883171b073d2d4ca" translate="yes" xml:space="preserve">
          <source>In the code snippet above, the HTML template binds a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; element to a trigger named &lt;code&gt;openClose&lt;/code&gt; with a status expression of &lt;code&gt;isOpen&lt;/code&gt;, and with possible values of &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;. This is an alternative to the practice of creating two named states of &lt;code&gt;open&lt;/code&gt; and &lt;code&gt;close&lt;/code&gt;.</source>
          <target state="translated">위의 코드 스 니펫에서 HTML 템플리트는 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 요소를 상태 표현식 &lt;code&gt;isOpen&lt;/code&gt; 및 가능한 값은 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 로 &lt;code&gt;openClose&lt;/code&gt; 라는 트리거에 바인딩합니다 . 이것은 &lt;code&gt;open&lt;/code&gt; 과 &lt;code&gt;close&lt;/code&gt; 의 두 가지 명명 된 상태를 만드는 방법의 대안 입니다.</target>
        </trans-unit>
        <trans-unit id="711a62a7d9cbae68bebfcfcc21e1d3cea5413624" translate="yes" xml:space="preserve">
          <source>In the component class, decorate a property with &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt;. The following example &lt;code&gt;newItemEvent&lt;/code&gt;&lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; has a type of &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt;, which means it's an event.</source>
          <target state="translated">구성 요소 클래스에서 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; 하여 속성을 장식합니다 . 다음 예제 &lt;code&gt;newItemEvent&lt;/code&gt; &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; 에는 &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; 유형이 있으며 이는 이벤트임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c1b78f88da88a23dd477bf417a4c041c6b8167c0" translate="yes" xml:space="preserve">
          <source>In the component class, define a property named &lt;code&gt;notify&lt;/code&gt; with an &lt;code&gt;@&lt;a href=&quot;api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; decorator and an instance of &lt;code&gt;&lt;a href=&quot;api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;()&lt;/code&gt;. This allows the product alert component to emit an event when the value of the notify property changes.</source>
          <target state="translated">컴포넌트 클래스에서 &lt;code&gt;@&lt;a href=&quot;api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;api/core/output&quot;&gt;Output&lt;/a&gt; () 데코레이터 및 &lt;code&gt;&lt;a href=&quot;api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;()&lt;/code&gt; () 인스턴스를 사용하여 &lt;code&gt;notify&lt;/code&gt; 라는 특성을 정의하십시오 . 이를 통해 알림 속성 값이 변경 될 때 제품 알림 구성 요소가 이벤트를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbb5316d37953947a7dc6e4e53440d5ca9eea88b" translate="yes" xml:space="preserve">
          <source>In the component code, in the &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; metadata under the &lt;code&gt;animations:&lt;/code&gt; property, when the state evaluates to &lt;code&gt;true&lt;/code&gt; (meaning &quot;open&quot; here), the associated HTML element's height is a wildcard style or default. In this case, use whatever height the element already had before the animation started. When the element is &quot;closed,&quot; the element animates to a height of 0, which makes it invisible.</source>
          <target state="translated">구성 요소 코드 에서 &lt;code&gt;animations:&lt;/code&gt; 속성 아래 의 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; 메타 데이터에서 상태가 &lt;code&gt;true&lt;/code&gt; 로 평가되면 (여기서는 &quot;열기&quot;의미) 연결된 HTML 요소의 높이는 와일드 카드 스타일 또는 기본값입니다. 이 경우 애니메이션이 시작되기 전에 요소의 높이를 사용하십시오. 요소가 &quot;닫히면&quot;요소의 높이가 0이되어 보이지 않게됩니다.</target>
        </trans-unit>
        <trans-unit id="750773967d6728414256aab053c5bf8fe9e2f436" translate="yes" xml:space="preserve">
          <source>In the component file, add a metadata property called &lt;code&gt;animations:&lt;/code&gt; within the &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; decorator. You put the trigger that defines an animation within the &lt;code&gt;animations&lt;/code&gt; metadata property.</source>
          <target state="translated">구성 요소 파일 에서 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt; () 데코레이터 내에 &lt;code&gt;animations:&lt;/code&gt; 라는 메타 데이터 속성을 추가합니다 . &lt;code&gt;animations&lt;/code&gt; 메타 데이터 속성 내에 애니메이션을 정의하는 트리거를 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="b647954d61a159e6208fef117f191a4dea85cacc" translate="yes" xml:space="preserve">
          <source>In the component file, add the hero-creation method to the hero data model.</source>
          <target state="translated">구성 요소 파일에서 히어로 생성 방법을 히어로 데이터 모델에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4196bcf6a715efdf0a9de2a019d7382007a47ed6" translate="yes" xml:space="preserve">
          <source>In the component file, the &lt;code&gt;:enter&lt;/code&gt; transition sets an initial opacity of 0, and then animates it to change that opacity to 1 as the element is inserted into the view.</source>
          <target state="translated">구성 요소 파일에서 &lt;code&gt;:enter&lt;/code&gt; 전환은 초기 불투명도를 0으로 설정 한 다음 요소가 뷰에 삽입 될 때 불투명도를 1로 변경하도록 애니메이션을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="2a6156782315dab6b8822877f620cda0f59ab064" translate="yes" xml:space="preserve">
          <source>In the component or file that uses the library, add the following code.</source>
          <target state="translated">라이브러리를 사용하는 구성 요소 또는 파일에서 다음 코드를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8243140d8235a39ddc9786840d3f4bf1a925f034" translate="yes" xml:space="preserve">
          <source>In the component or file that uses the library, add the following code:</source>
          <target state="translated">라이브러리를 사용하는 구성 요소 또는 파일에서 다음 코드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="87a9383fa91e555bd99945b3b362ea9dcee5dfa7" translate="yes" xml:space="preserve">
          <source>In the component template, the content might be used with interpolation:</source>
          <target state="translated">컴포넌트 템플리트에서 컨텐츠는 보간과 함께 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f702faec19daad8be0cca783fb00aba111958cee" translate="yes" xml:space="preserve">
          <source>In the component, use an &lt;code&gt;Observable&lt;/code&gt; to get the data from the &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">구성 요소에서 &lt;code&gt;Observable&lt;/code&gt; 을 사용 하여 &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; 에서 데이터를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="3ae6371e7bf5654fb5d754771d4b6f032b299e13" translate="yes" xml:space="preserve">
          <source>In the console, you will see that the schematic was run and the &lt;code&gt;my-data.service.ts&lt;/code&gt; file was created in your app folder.</source>
          <target state="translated">콘솔에서 회로도가 실행되고 &lt;code&gt;my-data.service.ts&lt;/code&gt; 파일이 앱 폴더에 생성 된 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db2383126f18633eaf688b99cb2074de976819a7" translate="yes" xml:space="preserve">
          <source>In the constructor of the &lt;code&gt;AppModule&lt;/code&gt;, use dependency injection to get a hold of the &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; instance, and use it to bootstrap the AngularJS app in the &lt;code&gt;AppModule.ngDoBootstrap&lt;/code&gt; method. The &lt;code&gt;upgrade.bootstrap&lt;/code&gt; method takes the exact same arguments as &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.bootstrap&quot;&gt;angular.bootstrap&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;AppModule&lt;/code&gt; 의 생성자에서 종속성 주입을 사용하여 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 인스턴스를 보유 하고이를 사용하여 &lt;code&gt;AppModule.ngDoBootstrap&lt;/code&gt; 메소드 에서 AngularJS 앱을 부트 스트랩하십시오 . &lt;code&gt;upgrade.bootstrap&lt;/code&gt; 의 방법으로 동일한 인수를 &lt;a href=&quot;https://docs.angularjs.org/api/ng/function/angular.bootstrap&quot;&gt;angular.bootstrap&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ab2886cc60ad2bc7616d008c0fde504da14578f6" translate="yes" xml:space="preserve">
          <source>In the context of a parent form, it's often unnecessary to include one-way or two-way binding, as the parent form syncs the value for you. You access its properties by exporting it into a local template variable using &lt;code&gt;&lt;a href=&quot;ngform&quot;&gt;ngForm&lt;/a&gt;&lt;/code&gt; such as (&lt;code&gt;#f=&quot;&lt;a href=&quot;ngform&quot;&gt;ngForm&lt;/a&gt;&quot;&lt;/code&gt;). Use the variable where needed on form submission.</source>
          <target state="translated">부모 양식의 경우 부모 양식이 값을 동기화하므로 단방향 또는 양방향 바인딩을 포함하지 않아도됩니다. ( &lt;code&gt;#f=&quot;&lt;a href=&quot;ngform&quot;&gt;ngForm&lt;/a&gt;&quot;&lt;/code&gt; &lt;a href=&quot;ngform&quot;&gt;ngForm&lt;/a&gt; &quot; ) 과 같은 &lt;code&gt;&lt;a href=&quot;ngform&quot;&gt;ngForm&lt;/a&gt;&lt;/code&gt; 을 사용하여 로컬 템플릿 변수로 내보내 속성에 액세스합니다 . 양식 제출시 필요한 경우 변수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9f2d7dd8dafe93b7500c8077037b8da178a715a9" translate="yes" xml:space="preserve">
          <source>In the context of an Angular service worker, a &quot;version&quot; is a collection of resources that represent a specific build of the Angular app. Whenever a new build of the app is deployed, the service worker treats that build as a new version of the app. This is true even if only a single file is updated. At any given time, the service worker may have multiple versions of the app in its cache and it may be serving them simultaneously. For more information, see the &lt;a href=&quot;service-worker-devops#tabs&quot;&gt;App tabs&lt;/a&gt; section below.</source>
          <target state="translated">Angular 서비스 워커와 관련하여 &quot;버전&quot;은 특정 Angular 앱 빌드를 나타내는 리소스 모음입니다. 앱의 새 빌드가 배포 될 때마다 서비스 워커는 해당 빌드를 새 버전의 앱으로 취급합니다. 단일 파일 만 업데이트 된 경우에도 마찬가지입니다. 언제든지 서비스 작업자는 캐시에 여러 버전의 앱이있을 수 있으며 동시에 서비스를 제공 할 수 있습니다. 자세한 내용은 아래의 &lt;a href=&quot;service-worker-devops#tabs&quot;&gt;앱 탭&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="31e6c8b0cca98e1d45c93db3ef9b3d328609662f" translate="yes" xml:space="preserve">
          <source>In the course of this tutorial, you bind a sample form to data and handle user input using the following steps.</source>
          <target state="translated">이 자습서의 과정에서는 다음 단계를 사용하여 샘플 양식을 데이터에 바인딩하고 사용자 입력을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="97dae99a0d255226f4238d22cccbbb910df66b7e" translate="yes" xml:space="preserve">
          <source>In the example above, Angular evaluates the &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;itemImageUrl&lt;/code&gt; properties and fills in the blanks, first displaying some title text and then an image.</source>
          <target state="translated">위의 예에서 Angular는 &lt;code&gt;title&lt;/code&gt; 및 &lt;code&gt;itemImageUrl&lt;/code&gt; 속성을 평가 하고 공백을 채우고 먼저 제목 텍스트를 표시 한 다음 이미지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="81fa08fa9b494460742d62ebecc855ff605ead0a" translate="yes" xml:space="preserve">
          <source>In the example above, the three options are specified according to that pluralization pattern. For talking about zero minutes, you use &lt;code&gt;=0 {just now}&lt;/code&gt;. For one minute, you use &lt;code&gt;=1 {one minute}&lt;/code&gt;. Any unmatched cardinality uses &lt;code&gt;other {{{minutes}} minutes ago}&lt;/code&gt;. You could choose to add patterns for two, three, or any other number if the pluralization rules were different. For the example of &quot;minute&quot;, only these three patterns are necessary in English.</source>
          <target state="translated">위의 예에서 세 가지 옵션은 해당 복수 패턴에 따라 지정됩니다. 0 분 정도 이야기하려면 &lt;code&gt;=0 {just now}&lt;/code&gt; 를 사용하십시오 . 1 분 동안 &lt;code&gt;=1 {one minute}&lt;/code&gt; 합니다. 일치하지 않는 카디널리티는 &lt;code&gt;other {{{minutes}} minutes ago}&lt;/code&gt; 합니다. 복수 규칙이 다른 경우 2, 3 또는 다른 숫자의 패턴을 추가하도록 선택할 수 있습니다. &quot;분&quot;의 예를 들어,이 세 가지 패턴 만 영어로 필요합니다.</target>
        </trans-unit>
        <trans-unit id="550d39672c182d504b9a08b7ed75f156116ef64f" translate="yes" xml:space="preserve">
          <source>In the example above, you use the &lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder#group&quot;&gt;group()&lt;/a&gt;&lt;/code&gt; method with the same object to define the properties in the model. The value for each control name is an array containing the initial value as the first item in the array.</source>
          <target state="translated">위의 예 에서 같은 객체에 &lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder#group&quot;&gt;group()&lt;/a&gt;&lt;/code&gt; 메서드를 사용하여 모델의 속성을 정의합니다. 각 제어 이름의 값은 배열의 첫 번째 항목으로 초기 값을 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="1f2d3286c150f077c26feea80a8021812e74c85b" translate="yes" xml:space="preserve">
          <source>In the example above, you use the &lt;code&gt;group()&lt;/code&gt; method with the same object to define the properties in the model. The value for each control name is an array containing the initial value as the first item in the array.</source>
          <target state="translated">위의 예 에서 동일한 객체와 함께 &lt;code&gt;group()&lt;/code&gt; 메서드를 사용하여 모델의 속성을 정의합니다. 각 컨트롤 이름의 값은 배열의 첫 번째 항목으로 초기 값을 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="1ba8d292e19c80620ac6c43293a763a286812912" translate="yes" xml:space="preserve">
          <source>In the example app, the &lt;code&gt;BannerComponent&lt;/code&gt; presents static title text in the HTML template.</source>
          <target state="translated">예제 앱에서 &lt;code&gt;BannerComponent&lt;/code&gt; 는 HTML 템플릿에 정적 제목 텍스트를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4bcfb2b53fd4dc6373ea6524bb4d8990492b6ddf" translate="yes" xml:space="preserve">
          <source>In the example below the custom id &lt;code&gt;myId&lt;/code&gt; is used for two different messages:</source>
          <target state="translated">아래 예에서 사용자 정의 ID &lt;code&gt;myId&lt;/code&gt; 는 두 가지 다른 메시지에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5ada26207b7af3fde1615048bf33c296c6978a3e" translate="yes" xml:space="preserve">
          <source>In the example below, an &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; tag displays a simple English language greeting, &quot;Hello i18n!&quot;</source>
          <target state="translated">아래 예에서 &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; 태그는 간단한 영어 인사말 &quot;Hello i18n!&quot;을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="761e65706bb821211699b0101d7fa79785ca1c40" translate="yes" xml:space="preserve">
          <source>In the example case, the constraints are:</source>
          <target state="translated">예제의 경우 제약 조건은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d36c3d786cc14bcc8155416686a9fb73a1c42c26" translate="yes" xml:space="preserve">
          <source>In the example of the simple root module above, the application module needs material from within &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt;. To access that material, add it to the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; metadata &lt;code&gt;imports&lt;/code&gt; like this.</source>
          <target state="translated">위의 단순 루트 모듈의 예에서 애플리케이션 모듈은 &lt;code&gt;&lt;a href=&quot;../api/platform-browser/browsermodule&quot;&gt;BrowserModule&lt;/a&gt;&lt;/code&gt; 내에서 자료가 필요합니다 . 해당 자료에 액세스하려면 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 메타 데이터 &lt;code&gt;imports&lt;/code&gt; 과 같이 자료를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="54c9f76e0c79a2bab0002fa1804da3ccf230830a" translate="yes" xml:space="preserve">
          <source>In the example, the &lt;code&gt;color&lt;/code&gt; style is set to the current value of the &lt;code&gt;colorPreference&lt;/code&gt; variable.</source>
          <target state="translated">이 예에서 &lt;code&gt;color&lt;/code&gt; 스타일은 &lt;code&gt;colorPreference&lt;/code&gt; 변수 의 현재 값으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="eb7ba0a8d8a0d2a3fec268eda2d727b9e01b2be7" translate="yes" xml:space="preserve">
          <source>In the example, the compiler retains the &lt;code&gt;LibHeaderComponent&lt;/code&gt; token that occurs in the value position, which prevents the referenced component from being tree-shaken, even if the application developer does not actually use &lt;code&gt;&amp;lt;lib-header&amp;gt;&lt;/code&gt; anywhere. If &lt;code&gt;LibHeaderComponent&lt;/code&gt; is large (code, template, and styles), including it unnecessarily can significantly increase the size of the client application.</source>
          <target state="translated">이 예제에서 컴파일러는 값 위치에 발생 하는 &lt;code&gt;LibHeaderComponent&lt;/code&gt; 토큰을 유지하므로 응용 프로그램 개발자가 실제로 &lt;code&gt;&amp;lt;lib-header&amp;gt;&lt;/code&gt; 를 어디에도 사용하지 않더라도 참조 된 구성 요소가 트리 흔들리지 않도록 방지합니다 . &lt;code&gt;LibHeaderComponent&lt;/code&gt; 가 큰 경우 (코드, 템플릿 및 스타일) 불필요하게 포함하면 클라이언트 응용 프로그램의 크기가 크게 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92b5e03d39252fa9bf7d83cab030749ee5f4c3e4" translate="yes" xml:space="preserve">
          <source>In the example, the local state is the number &lt;code&gt;2&lt;/code&gt;, the number of runners up that the component should show. The state value is passed as an argument to &lt;code&gt;runnersUpFactory()&lt;/code&gt;. The &lt;code&gt;runnersUpFactory()&lt;/code&gt; returns the &lt;em&gt;provider factory function&lt;/em&gt;, which can use both the passed-in state value and the injected services &lt;code&gt;Hero&lt;/code&gt; and &lt;code&gt;HeroService&lt;/code&gt;.</source>
          <target state="translated">이 예에서 로컬 상태는 구성 요소가 표시해야하는 러너 수인 &lt;code&gt;2&lt;/code&gt; 입니다. 상태 값은 &lt;code&gt;runnersUpFactory()&lt;/code&gt; 인수로 전달됩니다 . &lt;code&gt;runnersUpFactory()&lt;/code&gt; 수익 &lt;em&gt;제공자 팩토리 함수를&lt;/em&gt; 사용하여 모두 전달 된 상태 값과 주입 서비스 &lt;code&gt;Hero&lt;/code&gt; 및 &lt;code&gt;HeroService&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8effc0805c439cacc9c0f76f324195e103dda94" translate="yes" xml:space="preserve">
          <source>In the first example, the &lt;code&gt;active&lt;/code&gt; class is applied to the element if &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive#isActive&quot;&gt;isActive&lt;/a&gt;&lt;/code&gt; is true.</source>
          <target state="translated">첫 번째 예에서 &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkactive#isActive&quot;&gt;isActive&lt;/a&gt;&lt;/code&gt; 가 true 인 경우 &lt;code&gt;active&lt;/code&gt; 클래스가 요소에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="80c263cbce8c782dbf85361c2a0637996123f4a6" translate="yes" xml:space="preserve">
          <source>In the first example, the &lt;code&gt;active&lt;/code&gt; class is applied to the element if &lt;code&gt;isActive&lt;/code&gt; is true.</source>
          <target state="translated">첫 번째 예에서 &lt;code&gt;isActive&lt;/code&gt; 가 true 인 경우 &lt;code&gt;active&lt;/code&gt; 클래스가 요소에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="27a19498c633dd57a4f9dced2864e307540358ac" translate="yes" xml:space="preserve">
          <source>In the first example, the &lt;code&gt;color&lt;/code&gt; style is set to the current value of the &lt;code&gt;colorPreference&lt;/code&gt; variable.</source>
          <target state="translated">첫 번째 예에서 &lt;code&gt;color&lt;/code&gt; 스타일은 &lt;code&gt;colorPreference&lt;/code&gt; 변수 의 현재 값으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="c2c9e4a3b7e12aaeed408d98456f50d5888a5780" translate="yes" xml:space="preserve">
          <source>In the first example, when a user clicks the button, the &lt;code&gt;toggleImage()&lt;/code&gt; method in the associated component is executed.</source>
          <target state="translated">첫 번째 예에서 사용자가 버튼을 클릭 하면 연결된 구성 요소 의 &lt;code&gt;toggleImage()&lt;/code&gt; 메서드가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="51f81f798ea0c7741e39924caa444daf3cc19a74" translate="yes" xml:space="preserve">
          <source>In the first example, when the user clicks the button, the &lt;code&gt;toggleImage()&lt;/code&gt; method in the controller referenced by the &lt;code&gt;vm&lt;/code&gt;&lt;code&gt;controller as&lt;/code&gt; alias is executed.</source>
          <target state="translated">첫 번째 예에서 사용자가 버튼을 클릭 하면 &lt;code&gt;vm&lt;/code&gt; &lt;code&gt;controller as&lt;/code&gt; 별칭 으로 참조하는 컨트롤러 의 &lt;code&gt;toggleImage()&lt;/code&gt; 메서드 가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c32207f14912960f8c997ef3cafe72412ad10f67" translate="yes" xml:space="preserve">
          <source>In the first technique, you create and declare stub versions of the components and directive that play little or no role in the tests.</source>
          <target state="translated">첫 번째 기술에서는 테스트에서 거의 또는 전혀 역할을하지 않는 구성 요소 및 지시문의 스텁 버전을 작성하고 선언합니다.</target>
        </trans-unit>
        <trans-unit id="108b8931e71d306a76dfcfce9f527d5a471ad881" translate="yes" xml:space="preserve">
          <source>In the following code snippet, &lt;code&gt;HeroesService&lt;/code&gt; is an Angular service that depends upon an AngularJS service, &lt;code&gt;titleCase&lt;/code&gt;.</source>
          <target state="translated">다음 코드 스 니펫에서 &lt;code&gt;HeroesService&lt;/code&gt; 는 AngularJS 서비스 &lt;code&gt;titleCase&lt;/code&gt; 에 의존하는 Angular 서비스입니다 .</target>
        </trans-unit>
        <trans-unit id="e6676bc73be4bf155526fd49d72a84de468c0b2c" translate="yes" xml:space="preserve">
          <source>In the following code snippet, &lt;code&gt;heroesService&lt;/code&gt; is a downgraded Angular service that we are accessing from AngularJS.</source>
          <target state="translated">다음 코드 스 니펫에서 &lt;code&gt;heroesService&lt;/code&gt; 는 AngularJS에서 액세스하는 다운 그레이드 된 Angular 서비스입니다.</target>
        </trans-unit>
        <trans-unit id="fb78ea39c5a1ee00dc639658e1a750d3438ad7fa" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we are configuring the &lt;code&gt;$injector&lt;/code&gt; with two modules: The AngularJS &lt;code&gt;ng1AppModule&lt;/code&gt;, which is the AngularJS part of our hybrid application and the &lt;code&gt;Ng2AppModule&lt;/code&gt;, which is the Angular part.</source>
          <target state="translated">다음 코드 스 니펫에서는 하이브리드 애플리케이션의 AngularJS 부분 인 AngularJS &lt;code&gt;Ng2AppModule&lt;/code&gt; 과 Angular 부분 인 &lt;code&gt;ng1AppModule&lt;/code&gt; 의 두 모듈로 &lt;code&gt;$injector&lt;/code&gt; 를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="bf4a28c55f909788b70b87596cb2bfc51aafb4fc" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we are configuring the &lt;code&gt;&lt;a href=&quot;../upgrademodule#%24injector&quot;&gt;$injector&lt;/a&gt;&lt;/code&gt; with two modules: The AngularJS &lt;code&gt;ng1AppModule&lt;/code&gt;, which is the AngularJS part of our hybrid application and the &lt;code&gt;Ng2AppModule&lt;/code&gt;, which is the Angular part.</source>
          <target state="translated">다음 코드에서, 우리는 구성하는 &lt;code&gt;&lt;a href=&quot;../upgrademodule#%24injector&quot;&gt;$injector&lt;/a&gt;&lt;/code&gt; AngularJS와 두 개의 모듈 &lt;code&gt;ng1AppModule&lt;/code&gt; 우리의 하이브리드 응용 프로그램과의 AngularJS와 부분입니다, &lt;code&gt;Ng2AppModule&lt;/code&gt; 각 부분이다.</target>
        </trans-unit>
        <trans-unit id="96af67a04e682b5cdce9f3c7c26caa5301abaf6c" translate="yes" xml:space="preserve">
          <source>In the following code snippet, we are configuring the TestBed with two imports. The &lt;code&gt;Ng2AppModule&lt;/code&gt; is the Angular part of our hybrid application and the &lt;code&gt;ng1AppModule&lt;/code&gt; is the AngularJS part.</source>
          <target state="translated">다음 코드 스 니펫에서는 두 가지 가져 오기로 TestBed를 구성합니다. &lt;code&gt;Ng2AppModule&lt;/code&gt; 은 우리 하이브리드 애플리케이션의 각 부분과 &lt;code&gt;ng1AppModule&lt;/code&gt; 는 AngularJS와 부분이다.</target>
        </trans-unit>
        <trans-unit id="1089fa92e7d1b3e9f8331b6e2a577f4fccb3f18e" translate="yes" xml:space="preserve">
          <source>In the following code, the pipe only calls the server when the requested URL changes and it caches the server response. The code uses the &lt;a href=&quot;http&quot;&gt;Angular http&lt;/a&gt; client to retrieve data:</source>
          <target state="translated">다음 코드에서 파이프는 요청 된 URL이 변경 될 때만 서버를 호출하고 서버 응답을 캐시합니다. 이 코드는 &lt;a href=&quot;http&quot;&gt;Angular http&lt;/a&gt; 클라이언트를 사용하여 데이터를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="03604da2fdf914c5e14b22f5a5170342aa59b0a0" translate="yes" xml:space="preserve">
          <source>In the following configuration, when navigating to &lt;code&gt;/team/11&lt;/code&gt;, the router instantiates the 'AllUsers' component.</source>
          <target state="translated">다음 구성에서 &lt;code&gt;/team/11&lt;/code&gt; 로 이동하면 라우터는 'AllUsers'구성 요소를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="c19512eeae1d510572e03aff79e442da189e3793" translate="yes" xml:space="preserve">
          <source>In the following example the code sets the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;&lt;code&gt;value&lt;/code&gt; property by binding to the &lt;code&gt;name&lt;/code&gt; property.</source>
          <target state="translated">다음 예제에서 코드는 &lt;code&gt;name&lt;/code&gt; 속성 에 바인딩 하여 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 속성을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="ddd2e72487db9568e443e8ac17f1325efafcf0bf" translate="yes" xml:space="preserve">
          <source>In the following example, 'MainChild' and 'AuxChild' are siblings. When navigating to 'parent/10/(a//aux:b)', the route instantiates the main child and aux child components next to each other. For this to work, the application component must have the primary and aux outlets defined.</source>
          <target state="translated">다음 예에서 'MainChild'및 'AuxChild'는 형제입니다. 'parent / 10 / (a ​​// aux : b)'로 이동하면 경로는 기본 하위 구성 요소와 보조 하위 구성 요소를 서로 인스턴스화합니다. 이것이 작동하려면 응용 프로그램 구성 요소에 기본 및 보조 콘센트가 정의되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9b1fde84a1cd92229e619c7056dab800c00030c3" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;RepeatPipe&lt;/code&gt; repeats a given value a given number of times.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;RepeatPipe&lt;/code&gt; 는 주어진 횟수만큼 주어진 값을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="f35e0eba3b9006549e40ff4f159f53a0132367aa" translate="yes" xml:space="preserve">
          <source>In the following example, a component defines two output properties that create event emitters. When the title is clicked, the emitter emits an open or close event to toggle the current visibility state.</source>
          <target state="translated">다음 예제에서 구성 요소는 이벤트 이미 터를 작성하는 두 개의 출력 특성을 정의합니다. 제목을 클릭하면 이미 터가 현재 공개 상태를 토글하기 위해 열기 또는 닫기 이벤트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="daf2c7ac24c6883d82dbb39bacd2dd7aad01ed95" translate="yes" xml:space="preserve">
          <source>In the following example, a container element wraps a list of items stamped out by an &lt;code&gt;&lt;a href=&quot;../common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt;. The container element contains an animation trigger that will later be set to query for each of the inner items.</source>
          <target state="translated">다음 예제에서 컨테이너 요소는 &lt;code&gt;&lt;a href=&quot;../common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 에 의해 각인 된 항목 목록을 래핑합니다 . 컨테이너 요소에는 나중에 각 내부 항목을 쿼리하도록 설정되는 애니메이션 트리거가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="eda535300d18a5aaccbaa0e7a874fe9ca84d2dca" translate="yes" xml:space="preserve">
          <source>In the following example, an async validator ensures that heroes pick an alter ego that is not already taken. New heroes are constantly enlisting and old heroes are leaving the service, so the list of available alter egos cannot be retrieved ahead of time. To validate the potential alter ego entry, the validator must initiate an asynchronous operation to consult a central database of all currently enlisted heroes.</source>
          <target state="translated">다음 예에서 비동기 유효성 검사기는 영웅이 아직 가져 오지 않은 분신을 선택하도록합니다. 새로운 영웅이 지속적으로 입대하고 오래된 영웅이 서비스를 떠나므로 사용 가능한 분신 목록을 미리 검색 할 수 없습니다. 잠재적 인 분신 항목을 검증하기 위해 검증자는 현재 등록 된 모든 영웅의 중앙 데이터베이스를 참조하는 비동기 작업을 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="ba9f38c751750ffec0044f30b25ab52fed51d3f3" translate="yes" xml:space="preserve">
          <source>In the following example, both uses of the &lt;code&gt;OtherComponent&lt;/code&gt; token cause retention of &lt;code&gt;OtherComponent&lt;/code&gt; (that is, prevent it from being tree-shaken when it is not used).</source>
          <target state="translated">다음 예제에서 &lt;code&gt;OtherComponent&lt;/code&gt; 토큰을 모두 사용하면 OtherComponent 가 유지 &lt;code&gt;OtherComponent&lt;/code&gt; (즉, 사용되지 않을 때 트리가 흔들리지 않도록 방지).</target>
        </trans-unit>
        <trans-unit id="b7d27f2282051c38c08c5ba5268a13c0e70b8f95" translate="yes" xml:space="preserve">
          <source>In the following example, casting &lt;code&gt;person&lt;/code&gt; to the &lt;code&gt;any&lt;/code&gt; type suppresses the error &lt;code&gt;Property address does not exist&lt;/code&gt;.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;person&lt;/code&gt; 을 &lt;code&gt;any&lt;/code&gt; 유형으로 캐스팅 하면 &lt;code&gt;Property address does not exist&lt;/code&gt; 오류 가 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f0c0be80d970b7039b7040a00f1d4d013a07fb7a" translate="yes" xml:space="preserve">
          <source>In the following example, chained pipes first apply a format to a date value, then convert the formatted date to uppercase characters. The first tab for the &lt;code&gt;src/app/app.component.html&lt;/code&gt; template chains &lt;code&gt;&lt;a href=&quot;../api/common/datepipe&quot;&gt;DatePipe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/common/uppercasepipe&quot;&gt;UpperCasePipe&lt;/a&gt;&lt;/code&gt; to display the birthday as &lt;strong&gt;APR 15, 1988&lt;/strong&gt;. The second tab for the &lt;code&gt;src/app/app.component.html&lt;/code&gt; template passes the &lt;code&gt;fullDate&lt;/code&gt; parameter to &lt;code&gt;&lt;a href=&quot;../api/common/datepipe&quot;&gt;date&lt;/a&gt;&lt;/code&gt; before chaining to &lt;code&gt;&lt;a href=&quot;../api/common/uppercasepipe&quot;&gt;uppercase&lt;/a&gt;&lt;/code&gt;, which produces &lt;strong&gt;FRIDAY, APRIL 15, 1988&lt;/strong&gt;.</source>
          <target state="translated">다음 예에서 체인 파이프는 먼저 형식을 날짜 값에 적용한 다음 형식이 지정된 날짜를 대문자로 변환합니다. &lt;code&gt;src/app/app.component.html&lt;/code&gt; 템플릿 의 첫 번째 탭은 &lt;code&gt;&lt;a href=&quot;../api/common/datepipe&quot;&gt;DatePipe&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/common/uppercasepipe&quot;&gt;UpperCasePipe&lt;/a&gt;&lt;/code&gt; 를 연결하여 생일을 &lt;strong&gt;APR 15, 1988&lt;/strong&gt; 로 표시합니다 . &lt;code&gt;src/app/app.component.html&lt;/code&gt; 템플릿 의 두 번째 탭 은 &lt;code&gt;fullDate&lt;/code&gt; 매개 변수 를 &lt;code&gt;&lt;a href=&quot;../api/common/uppercasepipe&quot;&gt;uppercase&lt;/a&gt;&lt;/code&gt; 연결하기 전에 &lt;code&gt;&lt;a href=&quot;../api/common/datepipe&quot;&gt;date&lt;/a&gt;&lt;/code&gt; 전달하여 &lt;strong&gt;1988 년 4 월 15 일 금요일&lt;/strong&gt; 을 생성합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="71f0504b947cf5e51ff21890897ccd6044cad871" translate="yes" xml:space="preserve">
          <source>In the following example, changing the text in the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; changes the value in the &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; because Angular immediately updates changes through the template variable, &lt;code&gt;ref1&lt;/code&gt;.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 의 텍스트를 변경하면 Angular가 템플릿 변수 &lt;code&gt;ref1&lt;/code&gt; 을 통해 변경 사항을 즉시 업데이트하므로 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 의 값이 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="07d4a2f467fef38713e2368d4993474e3b3049f6" translate="yes" xml:space="preserve">
          <source>In the following example, however, Angular &lt;a href=&quot;security#sanitization-and-security-contexts&quot;&gt;sanitizes&lt;/a&gt; the values before displaying them.</source>
          <target state="translated">그러나 다음 예제에서 Angular 는 값을 표시하기 전에 &lt;a href=&quot;security#sanitization-and-security-contexts&quot;&gt;삭제&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7002095cfd601df6d3724b03478da2bfdf6f6ef9" translate="yes" xml:space="preserve">
          <source>In the following example, supplying the 'full' &lt;code&gt;&lt;a href=&quot;route#pathMatch&quot;&gt;pathMatch&lt;/a&gt;&lt;/code&gt; strategy ensures that the router applies the redirect if and only if navigating to '/'.</source>
          <target state="translated">다음 예에서 ' &lt;code&gt;&lt;a href=&quot;route#pathMatch&quot;&gt;pathMatch&lt;/a&gt;&lt;/code&gt; 전략을 제공하면 라우터가 '/'로 이동하는 경우에만 리디렉션을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="152808b4dfa2dfb2a4fba28e543e9d00b2e26e2f" translate="yes" xml:space="preserve">
          <source>In the following example, supplying the 'full' &lt;code&gt;pathMatch&lt;/code&gt; strategy ensures that the router applies the redirect if and only if navigating to '/'.</source>
          <target state="translated">다음 예에서 '전체' &lt;code&gt;pathMatch&lt;/code&gt; 전략을 제공하면 라우터가 '/'로 이동하는 경우에만 리디렉션을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="f03d09f2145f0f8488d0b621cb15ad8cbf98ece8" translate="yes" xml:space="preserve">
          <source>In the following example, the &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; metadata object and the class constructor tell Angular how to create and display an instance of &lt;code&gt;TypicalComponent&lt;/code&gt;.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; 메타 데이터 개체와 클래스 생성자는 Angular에 &lt;code&gt;TypicalComponent&lt;/code&gt; 인스턴스를 만들고 표시하는 방법을 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="87c8b2b86175bcdf14e8fc1308d68a17c35a8a2f" translate="yes" xml:space="preserve">
          <source>In the following example, the &lt;code&gt;childItem&lt;/code&gt; property of the &lt;code&gt;ItemDetailComponent&lt;/code&gt; expects a string, which is exactly what you're sending in the property binding:</source>
          <target state="translated">다음 예에서 &lt;code&gt;childItem&lt;/code&gt; 의 특성 &lt;code&gt;ItemDetailComponent&lt;/code&gt; 은 당신이 바인딩 속성에 보내는 정확히 문자열을 기대한다 :</target>
        </trans-unit>
        <trans-unit id="c653d272b91f35a022b3aaa5efde4f0e88ccbf1d" translate="yes" xml:space="preserve">
          <source>In the following example, the &lt;code&gt;childItem&lt;/code&gt; property of the &lt;code&gt;ItemDetailComponent&lt;/code&gt; expects a string.</source>
          <target state="translated">다음 예에서 &lt;code&gt;childItem&lt;/code&gt; 의 특성 &lt;code&gt;ItemDetailComponent&lt;/code&gt; 는 문자열을 기대하고있다.</target>
        </trans-unit>
        <trans-unit id="fe0c10c153d72102ce705c591678f282d3984439" translate="yes" xml:space="preserve">
          <source>In the following example, the &lt;code&gt;person&lt;/code&gt; and &lt;code&gt;address&lt;/code&gt; properties are always set together, implying that &lt;code&gt;address&lt;/code&gt; is always non-null if &lt;code&gt;person&lt;/code&gt; is non-null. There is no convenient way to describe this constraint to TypeScript and the template compiler, but the error is suppressed in the example by using &lt;code&gt;address!.street&lt;/code&gt;.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;person&lt;/code&gt; 및 &lt;code&gt;address&lt;/code&gt; 속성은 항상 함께 설정 되므로 &lt;code&gt;person&lt;/code&gt; 이 null이 아닌 경우 &lt;code&gt;address&lt;/code&gt; 는 항상 null이 아닙니다 . 이 제약 조건을 TypeScript 및 템플릿 컴파일러에 설명하는 편리한 방법은 없지만 예제에서는 &lt;code&gt;address!.street&lt;/code&gt; 를 사용하여 오류가 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5a8c2c89e4051bc66352ee40fcff2387a159fe44" translate="yes" xml:space="preserve">
          <source>In the following example, the dependency can be resolved by the local injector when instantiating the class itself, but not when instantiating a child.</source>
          <target state="translated">다음 예제에서 클래스 자체를 인스턴스화 할 때 로컬 인젝터가 종속성을 해결할 수 있지만 하위 인스턴스를 작성할 때는 종속성을 해결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6642cb00d9e5a2ab01358f07d9d792e0040e3173" translate="yes" xml:space="preserve">
          <source>In the following example, the dependency can be resolved when instantiating a child, but not when instantiating the class itself.</source>
          <target state="translated">다음 예제에서 하위 클래스를 인스턴스화 할 때 종속성을 해결할 수 있지만 클래스 자체를 인스턴스화 할 때는 종속성을 해결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7e4d63a4f8062e875d1e6ed5ee6b5e59adf2c961" translate="yes" xml:space="preserve">
          <source>In the following example, the error &lt;code&gt;Property addresss does not exist&lt;/code&gt; is suppressed by casting &lt;code&gt;person&lt;/code&gt; to the &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">다음 예에서는 &lt;code&gt;person&lt;/code&gt; 을 &lt;code&gt;any&lt;/code&gt; 유형 으로 캐스팅하여 &lt;code&gt;Property addresss does not exist&lt;/code&gt; . 오류 가 표시 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="562706a4e12d6092424ac9d37c82b8da887b3ddb" translate="yes" xml:space="preserve">
          <source>In the following example, the hero form uses the &lt;code&gt;.ng-valid&lt;/code&gt; and &lt;code&gt;.ng-invalid&lt;/code&gt; classes to set the color of each form control's border.</source>
          <target state="translated">다음 예제에서 hero 양식은 &lt;code&gt;.ng-valid&lt;/code&gt; 및 &lt;code&gt;.ng-invalid&lt;/code&gt; 클래스를 사용하여 각 양식 컨트롤의 테두리 색상을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="7663b43194ad1c35a2249f294f3b0c9a0ab1d18b" translate="yes" xml:space="preserve">
          <source>In the following example, the mock is a spy object.</source>
          <target state="translated">다음 예에서 모형은 스파이 개체입니다.</target>
        </trans-unit>
        <trans-unit id="2b33cf5a735f73710d739825bb0ebb9e113d2114" translate="yes" xml:space="preserve">
          <source>In the following example, the offset values describe when each &lt;code&gt;backgroundColor&lt;/code&gt; value is applied. The color is red at the start, and changes to blue when 20% of the total time has elapsed.</source>
          <target state="translated">다음 예제에서 오프셋 값은 각 &lt;code&gt;backgroundColor&lt;/code&gt; 값이 적용되는시기를 나타냅니다. 시작시 색상이 빨간색이고 총 시간의 20 %가 경과하면 파란색으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="24025e5e5f590539cab86355ec040952c01584ba" translate="yes" xml:space="preserve">
          <source>In the following example, the optional, injected &lt;code&gt;UserServiceConfig&lt;/code&gt; extends the greeting &lt;code&gt;UserService&lt;/code&gt;. If a &lt;code&gt;UserServiceConfig&lt;/code&gt; exists, the &lt;code&gt;UserService&lt;/code&gt; sets the user name from that config.</source>
          <target state="translated">다음 예제에서 선택적으로 주입 된 &lt;code&gt;UserServiceConfig&lt;/code&gt; 는 인사말 &lt;code&gt;UserService&lt;/code&gt; 를 확장합니다 . 경우 &lt;code&gt;UserServiceConfig&lt;/code&gt; 이 존재의 &lt;code&gt;UserService&lt;/code&gt; 는 그 설정에서 사용자 이름을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="79980625496444d650c75674c1a6f2e716b5d188" translate="yes" xml:space="preserve">
          <source>In the following example, the parent &lt;code&gt;AlexComponent&lt;/code&gt; has several children including a &lt;code&gt;CathyComponent&lt;/code&gt;:</source>
          <target state="translated">다음 예제에서 상위 &lt;code&gt;AlexComponent&lt;/code&gt; 에는 CathyComponent 를 포함하여 여러 하위가 &lt;code&gt;CathyComponent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97bde64184548aee2d9e6e03dbad3ef9c4f94d3b" translate="yes" xml:space="preserve">
          <source>In the following example, the property takes an enumerated value, so the schematic automatically chooses the list type, and creates a menu from the possible values.</source>
          <target state="translated">다음 예에서 속성은 열거 된 값을 가져 오므로 회로도가 자동으로 목록 유형을 선택하고 가능한 값에서 메뉴를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6c392769910b861e7b93dfe5e5804173fd59771a" translate="yes" xml:space="preserve">
          <source>In the following example, the template statement &lt;code&gt;deleteHero()&lt;/code&gt; appears in quotes to the right of the &lt;code&gt;=&lt;/code&gt; symbol as in &lt;code&gt;(event)=&quot;statement&quot;&lt;/code&gt;.</source>
          <target state="translated">다음 예제에서 템플릿 문 &lt;code&gt;deleteHero()&lt;/code&gt; 는 &lt;code&gt;(event)=&quot;statement&quot;&lt;/code&gt; 와 같이 &lt;code&gt;=&lt;/code&gt; 기호 오른쪽에 따옴표로 묶여 있습니다.</target>
        </trans-unit>
        <trans-unit id="c54e3333d43519134c5d78d38632858279c3d079" translate="yes" xml:space="preserve">
          <source>In the following example, the two-way binding means that &lt;code&gt;optionName&lt;/code&gt; should be written when the &lt;code&gt;valueChange&lt;/code&gt; event fires.</source>
          <target state="translated">다음 예제에서 양방향 바인딩 은 &lt;code&gt;valueChange&lt;/code&gt; 이벤트가 발생할 때 &lt;code&gt;optionName&lt;/code&gt; 을 작성해야 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="681d32dc4e5adc22dab536e5b1be6eebdc4f1f76" translate="yes" xml:space="preserve">
          <source>In the following example, using groups on both &lt;code&gt;:enter&lt;/code&gt; and &lt;code&gt;:leave&lt;/code&gt; allow for two different timing configurations. They're applied to the same element in parallel, but run independently.</source>
          <target state="translated">다음 예에서 &lt;code&gt;:enter&lt;/code&gt; 및 &lt;code&gt;:leave&lt;/code&gt; 모두에서 그룹을 사용 하면 서로 다른 두 가지 타이밍 구성이 가능합니다. 그것들은 같은 요소에 병렬로 적용되지만 독립적으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="8e243f96c1e3aa3da393a2b376a50bcdce46ecb5" translate="yes" xml:space="preserve">
          <source>In the following example, we bind the &lt;code&gt;colspan&lt;/code&gt; attribute to the expression &lt;code&gt;1 + 1&lt;/code&gt;.</source>
          <target state="translated">다음 예에서는 &lt;code&gt;colspan&lt;/code&gt; 속성을 표현식 &lt;code&gt;1 + 1&lt;/code&gt; 바인딩합니다 .</target>
        </trans-unit>
        <trans-unit id="cd98385101f7ec15002cf4d6b360a40c88e98235" translate="yes" xml:space="preserve">
          <source>In the following section, validation is performed asynchronously to ensure that our heroes pick an alter ego that is not already taken. New heroes are constantly enlisting and old heroes are leaving the service. That means that we do not have the list of available alter egos ahead of time.</source>
          <target state="translated">다음 섹션에서, 우리 영웅들이 아직 취하지 않은 다른 자아를 선택할 수 있도록 유효성 검사가 비동기 적으로 수행됩니다. 새로운 영웅은 끊임없이 참여하고 있으며 오래된 영웅은 서비스를 떠나고 있습니다. 즉, 사전에 이용 가능한 대체 자아 목록이 없습니다.</target>
        </trans-unit>
        <trans-unit id="6c3b3d738b040ea34330a9874710677277ec5aa4" translate="yes" xml:space="preserve">
          <source>In the following section, we will make sure that our heroes do not reveal their true identities by filling out the Hero Form. We will do that by validating that the hero names and alter egos do not match.</source>
          <target state="translated">다음 섹션에서는 영웅 양식을 작성하여 영웅이 자신의 진정한 정체성을 나타내지 않도록합니다. 우리는 영웅의 이름과 자존심이 일치하지 않는지 확인함으로써 그렇게 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="d5e8ea1209a297ac53c182cdecd191c2bcbcffe8" translate="yes" xml:space="preserve">
          <source>In the following sections, we will create a new schematics collection using the CLI in order to introduce the files and file structure, and some of the basic concepts.</source>
          <target state="translated">다음 섹션에서는 파일과 파일 구조 및 일부 기본 개념을 소개하기 위해 CLI를 사용하여 새 회로도 컬렉션을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0acace1863c72c536f219d9c87ba3c000a59f9d9" translate="yes" xml:space="preserve">
          <source>In the following snippet, &lt;code&gt;{{ currentCustomer }}&lt;/code&gt; is an example of interpolation.</source>
          <target state="translated">다음 스 니펫에서 &lt;code&gt;{{ currentCustomer }}&lt;/code&gt; 는 보간의 예입니다.</target>
        </trans-unit>
        <trans-unit id="f92a97dafecf0ff63df469ad3dbf2f7287a1ee03" translate="yes" xml:space="preserve">
          <source>In the following typical example, the &lt;code&gt;Logger&lt;/code&gt; class itself provides a &lt;code&gt;Logger&lt;/code&gt; instance.</source>
          <target state="translated">다음 일반적인 예에서 &lt;code&gt;Logger&lt;/code&gt; 클래스 자체는 &lt;code&gt;Logger&lt;/code&gt; 인스턴스를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="9263e2adc28d440e0cdfa9d945ab8ceef993f6ee" translate="yes" xml:space="preserve">
          <source>In the initial route configuration, you provided a simple setup with two routes used to configure the application for routing. This is perfectly fine for simple routing. As the application grows and you make use of more &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; features, such as guards, resolvers, and child routing, you'll naturally want to refactor the routing configuration into its own file. We recommend moving the routing information into a special-purpose module called a &lt;em&gt;Routing Module&lt;/em&gt;.</source>
          <target state="translated">초기 경로 구성에서는 라우팅을 위해 응용 프로그램을 구성하는 데 사용되는 두 가지 경로로 간단한 설정을 제공했습니다. 간단한 라우팅에는 완벽합니다. 응용 프로그램이 커지고 가드, 리졸버 및 자식 라우팅과 같은 더 많은 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 기능 을 사용함에 따라 라우팅 구성을 자체 파일로 리팩터링하는 것이 당연합니다. 우리는라는 특수 목적 모듈에 라우팅 정보를 이동하는 것이 좋습니다 &lt;em&gt;라우팅 모듈&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ecc8204fd046d58554a4265d4a7d62d6183d43e8" translate="yes" xml:space="preserve">
          <source>In the lazy-loaded module's routing module, add a route for the component.</source>
          <target state="translated">지연로드 된 모듈의 라우팅 모듈에서 구성 요소에 대한 경로를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8939bb7d20361052e28964c91af95d20bb24f0bb" translate="yes" xml:space="preserve">
          <source>In the logical tree, this would be represented as follows:</source>
          <target state="translated">논리 트리에서 이는 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e61466e206b3ec0ac4d4feec978969505b42cf15" translate="yes" xml:space="preserve">
          <source>In the marketplace, search for Angular Language Service extension, and click the &lt;strong&gt;Install&lt;/strong&gt; button.</source>
          <target state="translated">마켓 플레이스에서 Angular Language Service 확장을 검색하고 &lt;strong&gt;설치&lt;/strong&gt; 버튼을 클릭하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee29ab8b4fc806fd90c92d9225b82f01c19a7e67" translate="yes" xml:space="preserve">
          <source>In the meantime, the user's browser decides to evict &lt;code&gt;lazy-chunk.&amp;lt;lazy-hash-1&amp;gt;.js&lt;/code&gt; from its cache. Browsers may decide to evict specific (or all) resources from a cache in order to reclaim disk space.</source>
          <target state="translated">그 동안 사용자의 브라우저는 캐시에서 &lt;code&gt;lazy-chunk.&amp;lt;lazy-hash-1&amp;gt;.js&lt;/code&gt; 를 제거하기로 결정 합니다. 브라우저는 디스크 공간을 확보하기 위해 캐시에서 특정 (또는 모든) 리소스를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="135913a2ad9622082620cc8052cee479a2283783" translate="yes" xml:space="preserve">
          <source>In the microsyntax expression, set &lt;code&gt;trackBy&lt;/code&gt; to the &lt;code&gt;trackByItems()&lt;/code&gt; method.</source>
          <target state="translated">마이크로 구문 표현식에서 &lt;code&gt;trackBy&lt;/code&gt; 를 &lt;code&gt;trackByItems()&lt;/code&gt; 메소드로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="1161c17590b5bc612006dc669107bf6f21e58fcd" translate="yes" xml:space="preserve">
          <source>In the most basic type-checking mode, with the &lt;code&gt;fullTemplateTypeCheck&lt;/code&gt; flag set to &lt;code&gt;false&lt;/code&gt;, Angular validates only top-level expressions in a template.</source>
          <target state="translated">가장 기본적인 유형 검사 모드에서 &lt;code&gt;fullTemplateTypeCheck&lt;/code&gt; 플래그가 &lt;code&gt;false&lt;/code&gt; 로 설정된 상태 에서 Angular는 템플릿의 최상위 표현식 만 유효성을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="aeae7e3450618ec2a6c67802527cba205d86410b" translate="yes" xml:space="preserve">
          <source>In the new files, change every mention of &quot;hero&quot; to &quot;crisis&quot;, and &quot;heroes&quot; to &quot;crises&quot;.</source>
          <target state="translated">새 파일에서 &quot;hero&quot;에 대한 모든 언급을 &quot;crisis&quot;로, &quot;heroes&quot;를 &quot;crises&quot;로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="cab7ba9e3cb300cd56f89341c1fe5eaa7652a159" translate="yes" xml:space="preserve">
          <source>In the new version, you import the Angular HTTP module and call its &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; service instead of &lt;code&gt;ngResource&lt;/code&gt;.</source>
          <target state="translated">새 버전에서는 Angular HTTP 모듈을 가져 와서 &lt;code&gt;ngResource&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 서비스를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="fa45dc36ef2e509c03cb485f20fb4a25dc19e3d0" translate="yes" xml:space="preserve">
          <source>In the next example, the component uses the default, aggressive change detection strategy to monitor and update its display of every hero in the &lt;code&gt;heroes&lt;/code&gt; array. Here's the template:</source>
          <target state="translated">다음 예에서 구성 요소는 공격적인 기본 변경 감지 전략을 사용하여 &lt;code&gt;heroes&lt;/code&gt; 배열 의 모든 영웅 표시를 모니터링하고 업데이트합니다 . 템플릿은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="21babd8c9e3406ba32d7975f643689c6321dff5c" translate="yes" xml:space="preserve">
          <source>In the next section, define an &lt;code&gt;onSelect()&lt;/code&gt; method in &lt;code&gt;HeroesComponent&lt;/code&gt; to display the hero that was defined in the &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; expression.</source>
          <target state="translated">다음 섹션 에서 &lt;code&gt;HeroesComponent&lt;/code&gt; 에서 &lt;code&gt;onSelect()&lt;/code&gt; 메소드를 정의하여 &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt; 표현식 에 정의 된 히어로를 표시하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e27fa6280b06a48c06de4d2223a0f2a93964163" translate="yes" xml:space="preserve">
          <source>In the normal course of HTML development, you create a visual structure with HTML elements, and you modify those elements by setting element attributes with string constants.</source>
          <target state="translated">일반적인 HTML 개발 과정에서 HTML 요소로 시각적 구조를 만들고 문자열 상수로 요소 특성을 설정하여 해당 요소를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="5df49583093875b25bd10a8f1c9aa47bad102a04" translate="yes" xml:space="preserve">
          <source>In the parent</source>
          <target state="translated">부모님</target>
        </trans-unit>
        <trans-unit id="f6cd4009229c716121ae40e31ca29e7d231e9536" translate="yes" xml:space="preserve">
          <source>In the parent component class, designate a value for &lt;code&gt;currentItem&lt;/code&gt;:</source>
          <target state="translated">상위 구성 요소 클래스에서 &lt;code&gt;currentItem&lt;/code&gt; 의 값을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="4ed3fcdf2f49b1de9c02b587cd3980ece017f8c4" translate="yes" xml:space="preserve">
          <source>In the parent's template</source>
          <target state="translated">부모의 템플릿에서</target>
        </trans-unit>
        <trans-unit id="193ba2131cd5b3d9617d379626162cf928d3798c" translate="yes" xml:space="preserve">
          <source>In the parent's template, bind the parent's method to the child's event.</source>
          <target state="translated">부모의 템플릿에서 부모의 메서드를 자식의 이벤트에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="9448f1e5e82adc8fa114ca01e663ddcb3ca64590" translate="yes" xml:space="preserve">
          <source>In the preview page, you should see a URL that looks like &lt;code&gt;https://&amp;lt;Project ID&amp;gt;.stackblitz.io&lt;/code&gt;.</source>
          <target state="translated">미리보기 페이지에 &lt;code&gt;https://&amp;lt;Project ID&amp;gt;.stackblitz.io&lt;/code&gt; 와 같은 URL이 표시되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="12b331a031d5526e2ce679556bb4798bc27c1678" translate="yes" xml:space="preserve">
          <source>In the preview pane, hold the pointer over a product name to see the bound name property value, which is the product name plus the word &quot;details&quot;. Interpolation &lt;code&gt;{{ }}&lt;/code&gt; lets you render the property value as text; property binding &lt;code&gt;[ ]&lt;/code&gt; lets you use the property value in a template expression.</source>
          <target state="translated">미리보기 창에서 제품 이름 위에 포인터를 놓으면 제품 이름과 &quot;세부 사항&quot;이라는 단어의 바운드 이름 속성 값이 표시됩니다. 보간 &lt;code&gt;{{ }}&lt;/code&gt; 사용하면 속성 값을 텍스트로 렌더링 할 수 있습니다. 속성 바인딩 &lt;code&gt;[ ]&lt;/code&gt; 사용하면 템플릿 표현식에서 속성 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f527efcbc5138dc59f029ba483544b213cb3a7c6" translate="yes" xml:space="preserve">
          <source>In the preview pane, you should see a URL that looks like &lt;code&gt;https://&amp;lt;Project ID&amp;gt;.stackblitz.io&lt;/code&gt;.</source>
          <target state="translated">미리보기 창에 &lt;code&gt;https://&amp;lt;Project ID&amp;gt;.stackblitz.io&lt;/code&gt; 와 같은 URL이 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="9b0f4cf5ae261da923380b748662b8cfdefddb57" translate="yes" xml:space="preserve">
          <source>In the previous code sample, the second &lt;code&gt;fetch&lt;/code&gt; pipe binding demonstrates more pipe chaining. It displays the same hero data in JSON format by chaining through to the built-in &lt;code&gt;&lt;a href=&quot;../api/common/jsonpipe&quot;&gt;JsonPipe&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이전 코드 샘플에서 두 번째 &lt;code&gt;fetch&lt;/code&gt; 파이프 바인딩은 더 많은 파이프 체인을 보여줍니다. 내장 &lt;code&gt;&lt;a href=&quot;../api/common/jsonpipe&quot;&gt;JsonPipe&lt;/a&gt;&lt;/code&gt; 에 연결하여 동일한 히어로 데이터를 JSON 형식으로 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="01a420c7f79a44c801ee09dbcac8fa73d6879ec4" translate="yes" xml:space="preserve">
          <source>In the previous example, the call to &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#get&quot;&gt;HttpClient.get()&lt;/a&gt;&lt;/code&gt; did not specify any options. By default, it returned the JSON data contained in the response body.</source>
          <target state="translated">이전 예제에서 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#get&quot;&gt;HttpClient.get()&lt;/a&gt;&lt;/code&gt; 대한 호출은 옵션을 지정하지 않았습니다. 기본적으로 응답 본문에 포함 된 JSON 데이터를 반환했습니다.</target>
        </trans-unit>
        <trans-unit id="2ad8b81ae652063e5ec08425ca076c90868e19f1" translate="yes" xml:space="preserve">
          <source>In the previous example, the current state of the input box is lost if the user mouses away and clicks elsewhere on the page without first pressing &lt;em&gt;Enter&lt;/em&gt;. The component's &lt;code&gt;value&lt;/code&gt; property is updated only when the user presses &lt;em&gt;Enter&lt;/em&gt;.</source>
          <target state="translated">이전 예제에서 사용자가 마우스를 치우고 &lt;em&gt;Enter 키&lt;/em&gt; 를 먼저 누르지 않고 페이지의 다른 곳을 클릭하면 입력 상자의 현재 상태가 손실됩니다 . 구성 요소의 &lt;code&gt;value&lt;/code&gt; 속성은 사용자가 &lt;em&gt;Enter 키를&lt;/em&gt; 누를 때만 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="763460cc5323fe0919754ecc16f1acecffc53597" translate="yes" xml:space="preserve">
          <source>In the previous example, the then-clause template is specified inline, as the content of the tag that contains the &lt;code&gt;&lt;a href=&quot;ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; directive. You can also specify a template that is defined externally, by referencing a labeled &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; element. When you do this, you can change which template to use at runtime, as shown in the following example.</source>
          <target state="translated">이전 예에서 then-clause 템플릿은 &lt;code&gt;&lt;a href=&quot;ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 지시문 이 포함 된 태그의 내용으로 인라인으로 지정됩니다. 레이블이 지정된 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 요소 를 참조하여 외부 적으로 정의 된 템플릿을 지정할 수도 있습니다 . 이렇게하면 다음 예제와 같이 런타임에 사용할 템플릿을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a19249881705cdc1b85acc1634672c260e4f10e" translate="yes" xml:space="preserve">
          <source>In the previous section, we saw a simple two-state transition. Now we'll create an animation with multiple steps run in sequence using &lt;em&gt;keyframes&lt;/em&gt;.</source>
          <target state="translated">이전 섹션에서는 간단한 2 상태 전환을 보았습니다. 이제 &lt;em&gt;keyframes를&lt;/em&gt; 사용하여 여러 단계를 순서대로 실행하는 애니메이션을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="75e13f3b00323a0edd780a29605d91a4037e1e98" translate="yes" xml:space="preserve">
          <source>In the product alert template, &lt;code&gt;product-alerts.component.html&lt;/code&gt;, update the &quot;Notify Me&quot; button with an event binding to call the &lt;code&gt;notify.emit()&lt;/code&gt; method.</source>
          <target state="translated">제품 알림 템플릿 인 &lt;code&gt;product-alerts.component.html&lt;/code&gt; 에서 이벤트 바인딩으로 &quot;알림&quot;버튼을 업데이트하여 &lt;code&gt;notify.emit()&lt;/code&gt; 메소드 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="0360d761f9068dfd9ca829b686f2df2fa1225044" translate="yes" xml:space="preserve">
          <source>In the real world, you might have to accumulate the users changes, validate across fields, validate on the server, or hold changes in a pending state until the user confirms them as a group or cancels and reverts all changes.</source>
          <target state="translated">실제 환경에서는 사용자 변경 사항을 누적하고, 필드에서 유효성을 검사하고, 서버에서 유효성을 검사하거나, 사용자가 그룹으로 확인하거나 모든 변경 사항을 취소하고 되돌릴 때까지 변경 사항을 보류 상태로 유지해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea818ef7af8d7132c773be77df3abe5612f313e0" translate="yes" xml:space="preserve">
          <source>In the real world, you might have to accumulate the users changes. You might have to validate across fields. You might have to validate on the server. You might have to hold changes in a pending state until the user confirms them &lt;em&gt;as a group&lt;/em&gt; or cancels and reverts all changes.</source>
          <target state="translated">실제로는 사용자 변경 사항을 누적해야 할 수도 있습니다. 여러 필드에서 유효성을 검사해야 할 수도 있습니다. 서버에서 유효성을 검사해야 할 수도 있습니다. 사용자가 변경 사항을 &lt;em&gt;그룹으로&lt;/em&gt; 확인 하거나 모든 변경 사항을 취소하고 되돌릴 때까지 변경 사항을 보류 상태로 유지해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04ff1f44e350c222b1e5578340bd8b97370a5ce6" translate="yes" xml:space="preserve">
          <source>In the root folder of your e2e tests project, create a new file named &lt;code&gt;protractor-ci.conf.js&lt;/code&gt;. This new file extends the original &lt;code&gt;protractor.conf.js&lt;/code&gt;.</source>
          <target state="translated">e2e tests 프로젝트의 루트 폴더에서 &lt;code&gt;protractor-ci.conf.js&lt;/code&gt; 라는 새 파일을 작성하십시오 . 이 새 파일은 원본 &lt;code&gt;protractor.conf.js&lt;/code&gt; 를 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="e83762a98939c0a3a7a3035af5d78fda350610db" translate="yes" xml:space="preserve">
          <source>In the same file (&lt;code&gt;HeroesComponent&lt;/code&gt; class), define a component property called &lt;code&gt;heroes&lt;/code&gt; to expose the &lt;code&gt;HEROES&lt;/code&gt; array for binding.</source>
          <target state="translated">동일한 파일 ( &lt;code&gt;HeroesComponent&lt;/code&gt; 클래스)에서 &lt;code&gt;heroes&lt;/code&gt; 라는 구성 요소 속성을 정의하여 바인딩 할 &lt;code&gt;HEROES&lt;/code&gt; 배열 을 노출시킵니다 .</target>
        </trans-unit>
        <trans-unit id="de3aa6f39e38ab8dae66e318d5fbdd408f9fe728" translate="yes" xml:space="preserve">
          <source>In the second approach, add &lt;code&gt;&lt;a href=&quot;../api/core/no_errors_schema&quot;&gt;NO_ERRORS_SCHEMA&lt;/a&gt;&lt;/code&gt; to the &lt;code&gt;TestBed.schemas&lt;/code&gt; metadata.</source>
          <target state="translated">두 번째 방법에서는 &lt;code&gt;&lt;a href=&quot;../api/core/no_errors_schema&quot;&gt;NO_ERRORS_SCHEMA&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;TestBed.schemas&lt;/code&gt; 메타 데이터에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="ebf229663e5442007be46c7c1f0611fa1c4d2bac" translate="yes" xml:space="preserve">
          <source>In the second case, TypeScript infers the type of &lt;code&gt;options&lt;/code&gt; to be &lt;code&gt;{responseType: string}&lt;/code&gt;. The type is too wide to pass to &lt;code&gt;HttpClient.get&lt;/code&gt; which is expecting the type of &lt;code&gt;responseType&lt;/code&gt; to be one of the &lt;em&gt;specific&lt;/em&gt; strings. &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; is typed explicitly this way so that the compiler can report the correct return type based on the options you provided.</source>
          <target state="translated">두 번째 경우, 타이프 라이터는 유형 추론 &lt;code&gt;options&lt;/code&gt; 수 &lt;code&gt;{responseType: string}&lt;/code&gt; . 유형이 너무 넓어서 &lt;code&gt;responseType&lt;/code&gt; 유형 이 &lt;em&gt;특정&lt;/em&gt; 문자열 중 하나가 될 것으로 예상하는 &lt;code&gt;HttpClient.get&lt;/code&gt; 에 전달할 수 없습니다 . &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 는 이러한 방식으로 명시 적으로 형식화되므로 컴파일러가 제공 한 옵션을 기반으로 올바른 반환 형식을보고 할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="431f8caabee69341acea4b6f059e0ce718e1b02a" translate="yes" xml:space="preserve">
          <source>In the service worker configuration file &lt;code&gt;ngsw-config.json&lt;/code&gt;, &lt;code&gt;versionedFiles&lt;/code&gt; and &lt;code&gt;files&lt;/code&gt; have the same behavior. As of v6, &lt;code&gt;versionedFiles&lt;/code&gt; is deprecated; use &lt;code&gt;files&lt;/code&gt; instead.</source>
          <target state="translated">서비스 워커 구성 파일 &lt;code&gt;ngsw-config.json&lt;/code&gt; 에서 &lt;code&gt;versionedFiles&lt;/code&gt; 및 &lt;code&gt;files&lt;/code&gt; 의 동작은 동일합니다. v6부터 &lt;code&gt;versionedFiles&lt;/code&gt; 는 더 이상 사용되지 않습니다. 대신 &lt;code&gt;files&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc40e4dc159163c26df92dd1a1e680e199a71f26" translate="yes" xml:space="preserve">
          <source>In the short form, the type is inferred from the property's type and constraints.</source>
          <target state="translated">짧은 형식으로 유형은 속성의 유형 및 제약 조건에서 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="d0f5a292f2cae7ab9d3d79db4add6202faa4eff6" translate="yes" xml:space="preserve">
          <source>In the table below, you can find a list of packages which implement deployment functionality to different platforms. The &lt;code&gt;deploy&lt;/code&gt; command for each package may require different command line options. You can read more by following the links associated with the package names below:</source>
          <target state="translated">아래 표에서 다양한 플랫폼에 배포 기능을 구현하는 패키지 목록을 찾을 수 있습니다. 각 패키지 의 &lt;code&gt;deploy&lt;/code&gt; 명령에는 다른 명령 줄 옵션이 필요할 수 있습니다. 아래 패키지 이름과 관련된 링크를 따라 자세한 내용을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80a71042ab5f19d1b606e00cd661194ad1abb6c7" translate="yes" xml:space="preserve">
          <source>In the template tree, select &lt;code&gt;Templates&lt;/code&gt; | &lt;code&gt;Visual C#&lt;/code&gt; (or &lt;code&gt;Visual Basic&lt;/code&gt;) | &lt;code&gt;Web&lt;/code&gt;.</source>
          <target state="translated">템플릿 트리에서 &lt;code&gt;Templates&lt;/code&gt; | &lt;code&gt;Visual C#&lt;/code&gt; (또는 &lt;code&gt;Visual Basic&lt;/code&gt; ) | &lt;code&gt;Web&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53cc553ac138c2e23462667f98a5b59c505018c2" translate="yes" xml:space="preserve">
          <source>In the template type-checking phase, the Angular template compiler uses the TypeScript compiler to validate the binding expressions in templates. Enable this phase explicitly by adding the compiler option &lt;code&gt;&quot;fullTemplateTypeCheck&quot;&lt;/code&gt; in the &lt;code&gt;&quot;angularCompilerOptions&quot;&lt;/code&gt; of the project's &lt;code&gt;tsconfig.json&lt;/code&gt; (see &lt;a href=&quot;angular-compiler-options&quot;&gt;Angular Compiler Options&lt;/a&gt;).</source>
          <target state="translated">템플릿 유형 확인 단계에서 Angular 템플릿 컴파일러는 TypeScript 컴파일러를 사용하여 템플릿의 바인딩 식을 확인합니다. 컴파일러 옵션을 추가하여 명시 적으로이 단계를 사용 &lt;code&gt;&quot;fullTemplateTypeCheck&quot;&lt;/code&gt; 에서 &lt;code&gt;&quot;angularCompilerOptions&quot;&lt;/code&gt; 프로젝트의 &lt;code&gt;tsconfig.json&lt;/code&gt; (참조 &lt;a href=&quot;angular-compiler-options&quot;&gt;각도 컴파일러 옵션&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a81a0084e724fa8d67181befb8d1973d9b649133" translate="yes" xml:space="preserve">
          <source>In the template, each control is displayed as a separate input field.</source>
          <target state="translated">템플릿에서 각 컨트롤은 별도의 입력 필드로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ebcb733aa3fcdeeca539a469b4874e83e11653a1" translate="yes" xml:space="preserve">
          <source>In the template, include the non-null assertion operator &lt;code&gt;!&lt;/code&gt; at the end of a nullable expression, such as &lt;code&gt;&amp;lt;user-detail [user]=&quot;user!&quot; /&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">템플릿에 널이 아닌 어설 션 연산자를 포함하십시오 &lt;code&gt;!&lt;/code&gt; &lt;code&gt;&amp;lt;user-detail [user]=&quot;user!&quot; /&amp;gt;&lt;/code&gt; 와 같은 Null 허용 식의 끝 /&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="5f973f5113f94431e75ce55450b06c69738655c9" translate="yes" xml:space="preserve">
          <source>In the template, place a &quot;New Hero&quot; &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; element at the bottom of the form.</source>
          <target state="translated">템플릿 에서 양식 하단에 &quot;New Hero&quot; &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 요소를 배치합니다.</target>
        </trans-unit>
        <trans-unit id="4d5b02da4c4c29131d5446cd9c56b5adca992c39" translate="yes" xml:space="preserve">
          <source>In the template, the &lt;code&gt;aria-label&lt;/code&gt; attribute ensures that the control is accessible to screen readers.</source>
          <target state="translated">템플릿에서 &lt;code&gt;aria-label&lt;/code&gt; 속성은 스크린 리더가 컨트롤에 액세스 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="a62513ae1ff1a6a6efa8b1e4006e3b394f8cda0b" translate="yes" xml:space="preserve">
          <source>In the template, you use the hash symbol, &lt;code&gt;#&lt;/code&gt;, to declare a template variable. The following template variable, &lt;code&gt;#phone&lt;/code&gt;, declares a &lt;code&gt;phone&lt;/code&gt; variable on an &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">템플릿에서 해시 기호 &lt;code&gt;#&lt;/code&gt; 를 사용하여 템플릿 변수를 선언합니다. 다음 템플릿 변수 &lt;code&gt;#phone&lt;/code&gt; 은 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 요소 에 &lt;code&gt;phone&lt;/code&gt; 변수를 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="3123807d4c800f4e675338a3f651fcf553e5eb18" translate="yes" xml:space="preserve">
          <source>In the terminal window at the root of your project, install the &lt;code&gt;devDependencies&lt;/code&gt; with &lt;code&gt;npm&lt;/code&gt; or &lt;code&gt;yarn&lt;/code&gt;:</source>
          <target state="translated">프로젝트 루트의 터미널 창에서 &lt;code&gt;npm&lt;/code&gt; 또는 &lt;code&gt;yarn&lt;/code&gt; 을 사용하여 &lt;code&gt;devDependencies&lt;/code&gt; 를 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="65a72a975b3735dcf036c8f8c9493f16a7f24225" translate="yes" xml:space="preserve">
          <source>In the tree on the left, select &lt;code&gt;Projects and Solutions&lt;/code&gt; | &lt;code&gt;External Web Tools&lt;/code&gt;.</source>
          <target state="translated">왼쪽의 트리에서 &lt;code&gt;Projects and Solutions&lt;/code&gt; | &lt;code&gt;External Web Tools&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ba4a7c7d59a8cba5b32269012bfcf935dd49cc8" translate="yes" xml:space="preserve">
          <source>In the two-state button example, the wildcard isn't that useful because there are only two possible states, &lt;code&gt;open&lt;/code&gt; and &lt;code&gt;closed&lt;/code&gt;. Wildcard states are better when an element in one particular state has multiple potential states that it can change to. If the button can change from &lt;code&gt;open&lt;/code&gt; to either &lt;code&gt;closed&lt;/code&gt; or something like &lt;code&gt;inProgress&lt;/code&gt;, using a wildcard state could reduce the amount of coding needed.</source>
          <target state="translated">2- 상태 버튼 예제에서, 가능한 상태는 &lt;code&gt;open&lt;/code&gt; 및 &lt;code&gt;closed&lt;/code&gt; 두 가지뿐이므로 와일드 카드는 그다지 유용하지 않습니다 . 와일드 카드 상태는 특정 상태의 요소에 변경할 수있는 여러 잠재적 상태가있을 때 더 좋습니다. 버튼이 &lt;code&gt;open&lt;/code&gt; 에서 &lt;code&gt;closed&lt;/code&gt; 또는 &lt;code&gt;inProgress&lt;/code&gt; 와 같은 것으로 변경 될 수있는 경우 와일드 카드 상태를 사용하면 필요한 코딩 양을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5953890c3c12b1a1d4e4941138925956ddcb1936" translate="yes" xml:space="preserve">
          <source>In these cases, you can use a special wildcard &lt;code&gt;*&lt;/code&gt; property value under &lt;code&gt;&lt;a href=&quot;../api/animations/style&quot;&gt;style&lt;/a&gt;()&lt;/code&gt;, so that the value of that particular style property is computed at runtime and then plugged into the animation.</source>
          <target state="translated">이러한 경우 &lt;code&gt;&lt;a href=&quot;../api/animations/style&quot;&gt;style&lt;/a&gt;()&lt;/code&gt; () 아래에 특수 와일드 카드 &lt;code&gt;*&lt;/code&gt; 속성 값을 사용하여 해당 특정 스타일 속성의 값이 런타임에 계산 된 다음 애니메이션에 연결되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e96b145ad3ef101a9a5349da867c2602f97778e" translate="yes" xml:space="preserve">
          <source>In these situations, it is possible to &lt;em&gt;upgrade&lt;/em&gt; an AngularJS provider to Angular. This makes it possible to then inject it somewhere in Angular code. For example, you might have a service called &lt;code&gt;HeroesService&lt;/code&gt; in AngularJS:</source>
          <target state="translated">이러한 상황에서는 AngularJS 제공자를 Angular 로 &lt;em&gt;업그레이드&lt;/em&gt; 할 수 있습니다 . 그러면 각도 코드 어딘가에 삽입 할 수 있습니다. 예를 들어 AngularJS에 &lt;code&gt;HeroesService&lt;/code&gt; 라는 서비스가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="540f547baf27d40ff42671c435006ba47fae2226" translate="yes" xml:space="preserve">
          <source>In this &lt;em&gt;Tour of Heroes&lt;/em&gt; tutorial, you will build an app that helps a staffing agency manage its stable of heroes.</source>
          <target state="translated">이 &lt;em&gt;Tour of Heroes&lt;/em&gt; 튜토리얼에서는 직원 대행사가 안정적인 영웅을 관리하는 데 도움이되는 앱을 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="e98ea4cfef6e5f121ccbfc306924f5544139d4ea" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; is displaying an array, but &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; can repeat items for any &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;iterable&lt;/a&gt; object.</source>
          <target state="translated">이 경우 &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 는 배열을 표시하지만 &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 는 반복 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;가능한&lt;/a&gt; 객체에 대해 항목을 반복 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9152d9aaf0f4804a6151c4e1e55932c83c01c34e" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; decorates the property &lt;code&gt;item&lt;/code&gt;, which has a type of &lt;code&gt;string&lt;/code&gt;, however, &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; properties can have any type, such as &lt;code&gt;&lt;a href=&quot;../api/common/decimalpipe&quot;&gt;number&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, or &lt;code&gt;object&lt;/code&gt;. The value for &lt;code&gt;item&lt;/code&gt; comes from the parent component.</source>
          <target state="translated">이 경우 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 은 &lt;code&gt;string&lt;/code&gt; 유형을 가진 &lt;code&gt;item&lt;/code&gt; 속성을 데코레이션 하지만 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt; () 속성은 &lt;code&gt;&lt;a href=&quot;../api/common/decimalpipe&quot;&gt;number&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;boolean&lt;/code&gt; 또는 &lt;code&gt;object&lt;/code&gt; 와 같은 모든 유형을 가질 수 있습니다 . &lt;code&gt;item&lt;/code&gt; 값 은 상위 구성 요소에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6b79b6ff431d28fff0de7299c5e8f98be33e351c" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; decorates the property &lt;code&gt;item&lt;/code&gt;, which has a type of &lt;code&gt;string&lt;/code&gt;, however, &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; properties can have any type, such as &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, or &lt;code&gt;object&lt;/code&gt;. The value for &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; will come from the parent component, which the next section covers.</source>
          <target state="translated">이 경우 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 은 &lt;code&gt;string&lt;/code&gt; 유형이있는 속성 &lt;code&gt;item&lt;/code&gt; 장식 하지만 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt; () 속성은 &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;boolean&lt;/code&gt; 또는 &lt;code&gt;object&lt;/code&gt; 와 같은 모든 유형을 가질 수 있습니다 . &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; 값 은 다음 섹션에서 다루는 상위 구성 요소에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="eb00ef72a4a1581ddb03343a0b1a91065133fc3f" translate="yes" xml:space="preserve">
          <source>In this case, the URL is relative to the CSS file into which you're importing.</source>
          <target state="translated">이 경우 URL은 가져 오는 CSS 파일을 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="28c41d5d9a09f8ff971841552d898d001d4abc7f" translate="yes" xml:space="preserve">
          <source>In this case, the compiler doesn't understand how to inject something with the &lt;code&gt;Window&lt;/code&gt; token.</source>
          <target state="translated">이 경우 컴파일러는 &lt;code&gt;Window&lt;/code&gt; 토큰으로 무언가를 주입하는 방법을 이해하지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="9c70127c467d27d51e62747cdfd36e0f50102f8e" translate="yes" xml:space="preserve">
          <source>In this case, the installed &lt;code&gt;@types/jquery&lt;/code&gt; doesn't include &lt;code&gt;myPlugin&lt;/code&gt;, so you need to add an interface in &lt;code&gt;src/typings.d.ts&lt;/code&gt;. For example:</source>
          <target state="translated">이 경우 설치된 &lt;code&gt;@types/jquery&lt;/code&gt; &lt;code&gt;myPlugin&lt;/code&gt; 이 포함되어 있지 않으므로 &lt;code&gt;src/typings.d.ts&lt;/code&gt; 에 인터페이스를 추가해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef9a0cfbc3978a23bac648732aecf66dda795c0d" translate="yes" xml:space="preserve">
          <source>In this case, the value you'd get for &lt;code&gt;emoji&lt;/code&gt; would be &lt;code&gt;🌿&lt;/code&gt; (fern), not &lt;code&gt;🍁&lt;/code&gt; (maple leaf).</source>
          <target state="translated">이 경우 &lt;code&gt;emoji&lt;/code&gt; 얻을 수있는 값 은 &lt;code&gt;🌿&lt;/code&gt; ( 매엽 )이 아니라 &lt;code&gt;🍁&lt;/code&gt; ( 고사리 )입니다.</target>
        </trans-unit>
        <trans-unit id="bfd20680b9b498ed5f14027a21db5b47a1c4a2e2" translate="yes" xml:space="preserve">
          <source>In this case, there is an implied &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; around the &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; and the definition of the variable is outside of it. Accessing a template variable from the parent template works because the child template inherits the context from the parent template.</source>
          <target state="translated">이 경우 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 주위에 묵시적 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 이 있고 변수의 정의는 그 밖에 있습니다. 상위 템플릿에서 템플릿 변수에 액세스하는 것은 하위 템플릿이 상위 템플릿의 컨텍스트를 상속하기 때문에 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4439bb06c28a004aad6a895a5a28f3b2a6d5d2b6" translate="yes" xml:space="preserve">
          <source>In this contrived example, &lt;code&gt;SortedHeroesComponent&lt;/code&gt; inherits from &lt;code&gt;HeroesBaseComponent&lt;/code&gt; to display a &lt;em&gt;sorted&lt;/em&gt; list of heroes.</source>
          <target state="translated">이 고안된 예에서 &lt;code&gt;SortedHeroesComponent&lt;/code&gt; 는 &lt;code&gt;HeroesBaseComponent&lt;/code&gt; 에서 상속 &lt;em&gt;되어 정렬 된&lt;/em&gt; 영웅 목록 을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="b5d0fc9c03a45683f8fef40516bc682df34feb20" translate="yes" xml:space="preserve">
          <source>In this demo, the &lt;code&gt;highlightColor&lt;/code&gt; property is an &lt;strong&gt;&lt;em&gt;input&lt;/em&gt;&lt;/strong&gt; property of the &lt;code&gt;HighlightDirective&lt;/code&gt;. You've seen it applied without an alias:</source>
          <target state="translated">이 데모에서 &lt;code&gt;highlightColor&lt;/code&gt; 속성은 &lt;code&gt;HighlightDirective&lt;/code&gt; 의 &lt;strong&gt;&lt;em&gt;입력&lt;/em&gt;&lt;/strong&gt; 속성입니다 . 별명없이 적용 된 것을 보았습니다.</target>
        </trans-unit>
        <trans-unit id="c8f2e72386b9b53a8533513dbcfa25c5d02a6eb9" translate="yes" xml:space="preserve">
          <source>In this example debug file, the update check is currently scheduled, as explained the next section.</source>
          <target state="translated">이 예제 디버그 파일에서 다음 섹션에 설명 된대로 업데이트 확인이 현재 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="02d2c8724e6a540145a981a2031d64f7d39e59d8" translate="yes" xml:space="preserve">
          <source>In this example it is recommended to include the checking of &lt;code&gt;address&lt;/code&gt; in the &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; as shown below:</source>
          <target state="translated">이 예는의 검사 포함 추천 &lt;code&gt;address&lt;/code&gt; 에서 &lt;code&gt;*&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 을 아래와 같이</target>
        </trans-unit>
        <trans-unit id="b774b69bbfb4a217d822daab677e5225b9498242" translate="yes" xml:space="preserve">
          <source>In this example the parent queries the token to obtain the child component, and stores the resulting component reference if it is present. Before calling a method in the child, the parent component checks to see if the child component is present. If the child component has been tree-shaken, there is no runtime reference to it, and no call to its method.</source>
          <target state="translated">이 예에서 부모는 토큰을 쿼리하여 자식 구성 요소를 가져오고 결과 구성 요소 참조가있는 경우 저장합니다. 자식에서 메서드를 호출하기 전에 부모 구성 요소는 자식 구성 요소가 있는지 확인합니다. 자식 구성 요소가 트리 셰이 킹 된 경우 런타임 참조가없고 해당 메서드에 대한 호출도 없습니다.</target>
        </trans-unit>
        <trans-unit id="12681fef4106e092359d97b4ddfc2ed1ade7f74a" translate="yes" xml:space="preserve">
          <source>In this example you can see that we must derive from the &lt;code&gt;&lt;a href=&quot;upgradecomponent&quot;&gt;UpgradeComponent&lt;/a&gt;&lt;/code&gt; base class but also provide an &lt;a href=&quot;../../core/directive&quot;&gt;`@Directive`&lt;/a&gt; decorator. This is because the AOT compiler requires that this information is statically available at compile time.</source>
          <target state="translated">이 예제에서는 &lt;code&gt;&lt;a href=&quot;upgradecomponent&quot;&gt;UpgradeComponent&lt;/a&gt;&lt;/code&gt; 기본 클래스 에서 파생되어야 하지만 &lt;a href=&quot;../../core/directive&quot;&gt;`@ Directive`&lt;/a&gt; 데코레이터 도 제공 해야 함을 알 수 있습니다 . 이는 AOT 컴파일러가이 정보가 컴파일 시간에 정적으로 사용 가능하도록 요구하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b620465ba0900e951bd37550e9f4865b71f4e6f7" translate="yes" xml:space="preserve">
          <source>In this example you can see that we must derive from the &lt;code&gt;&lt;a href=&quot;upgradecomponent&quot;&gt;UpgradeComponent&lt;/a&gt;&lt;/code&gt; base class but also provide an &lt;a href=&quot;../../core/directive&quot;&gt;`@Directive`&lt;/a&gt; decorator. This is because the AoT compiler requires that this information is statically available at compile time.</source>
          <target state="translated">이 예제에서는 &lt;code&gt;&lt;a href=&quot;upgradecomponent&quot;&gt;UpgradeComponent&lt;/a&gt;&lt;/code&gt; 기본 클래스 에서 파생해야 하며 &lt;a href=&quot;../../core/directive&quot;&gt;`@ Directive`&lt;/a&gt; 데코레이터 도 제공해야합니다 . AoT 컴파일러는이 정보를 컴파일 타임에 정적으로 사용할 수 있어야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="999cba4e5d3608eb750ca4d8169b051362b41fc2" translate="yes" xml:space="preserve">
          <source>In this example you upgraded a service class. You can use a TypeScript type annotation when you inject it. While it doesn't affect how the dependency is handled, it enables the benefits of static type checking. This is not required though, and any AngularJS service, factory, or provider can be upgraded.</source>
          <target state="translated">이 예에서는 서비스 클래스를 업그레이드했습니다. 삽입 할 때 TypeScript 유형 주석을 사용할 수 있습니다. 종속성 처리 방법에는 영향을 미치지 않지만 정적 유형 검사의 이점을 사용할 수 있습니다. 그러나 필수 사항은 아니며 AngularJS 서비스, 팩토리 또는 공급자를 업그레이드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7763722043d3b5d9efcc966176e2b82c6d6a5d7f" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;AppComponent&lt;/code&gt; specifies a different &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; object (&lt;code&gt;currentItem&lt;/code&gt;) and passes it to the nested &lt;code&gt;ListItemComponent&lt;/code&gt;. &lt;code&gt;ListItemComponent&lt;/code&gt; was able to use &lt;code&gt;currentItem&lt;/code&gt; because it matches what an &lt;code&gt;Item&lt;/code&gt; object is according to &lt;code&gt;item.ts&lt;/code&gt;. The &lt;code&gt;item.ts&lt;/code&gt; file is where &lt;code&gt;ListItemComponent&lt;/code&gt; gets its definition of an &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 예에서 &lt;code&gt;AppComponent&lt;/code&gt; 는 다른 &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; 객체 ( &lt;code&gt;currentItem&lt;/code&gt; )를 지정하고 중첩 된 &lt;code&gt;ListItemComponent&lt;/code&gt; 에 전달합니다 . &lt;code&gt;ListItemComponent&lt;/code&gt; 는 &lt;code&gt;item.ts&lt;/code&gt; 에 따라 &lt;code&gt;Item&lt;/code&gt; 객체 와 일치하므로 &lt;code&gt;currentItem&lt;/code&gt; 을 사용할 수있었습니다 . &lt;code&gt;item.ts&lt;/code&gt; 의 경우 파일은 &lt;code&gt;ListItemComponent&lt;/code&gt; 이 의 그 정의 얻을 &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b1113ef229de9681ba37dd24148caf319decf0c" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;HeroBiosComponent&lt;/code&gt; presents three instances of &lt;code&gt;HeroBioComponent&lt;/code&gt;.</source>
          <target state="translated">이 예에서 &lt;code&gt;HeroBiosComponent&lt;/code&gt; 는 HeroBioComponent의 세 인스턴스를 &lt;code&gt;HeroBioComponent&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="eb6d2e0877ff8bb6ab9b60da3559f19869b2670b" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;ItemListComponent&lt;/code&gt; is a child component of &lt;code&gt;AppComponent&lt;/code&gt; and the &lt;code&gt;items&lt;/code&gt; property expects an array of objects.</source>
          <target state="translated">이 예에서, &lt;code&gt;ItemListComponent&lt;/code&gt; 는 의 하위 구성 요소 &lt;code&gt;AppComponent&lt;/code&gt; 상기 &lt;code&gt;items&lt;/code&gt; 속성은 오브젝트의 배열을 기대하고있다.</target>
        </trans-unit>
        <trans-unit id="bcdd5ca8e804eec05ea345bce2cc9b339710030a" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;address &lt;a href=&quot;../api/animations/group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; combines the current &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt; controls with the new &lt;code&gt;street&lt;/code&gt;, &lt;code&gt;city&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/animations/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;zip&lt;/code&gt; controls. Even though the &lt;code&gt;address&lt;/code&gt; element in the form group is a child of the overall &lt;code&gt;profileForm&lt;/code&gt; element in the form group, the same rules apply with value and status changes. Changes in status and value from the nested form group propagate to the parent form group, maintaining consistency with the overall model.</source>
          <target state="translated">이 예에서 &lt;code&gt;address &lt;a href=&quot;../api/animations/group&quot;&gt;group&lt;/a&gt;&lt;/code&gt; 은 현재 &lt;code&gt;firstName&lt;/code&gt; 및 &lt;code&gt;lastName&lt;/code&gt; 컨트롤을 새로운 &lt;code&gt;street&lt;/code&gt; , &lt;code&gt;city&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/animations/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;zip&lt;/code&gt; 컨트롤 과 결합 합니다. 양식 그룹 의 &lt;code&gt;address&lt;/code&gt; 요소가 양식 그룹에있는 전체 &lt;code&gt;profileForm&lt;/code&gt; 요소 의 하위 인 경우 에도 동일한 규칙이 값 및 상태 변경에 적용됩니다. 중첩 된 양식 그룹의 상태 및 값 변경은 전체 모델과 일관성을 유지하면서 상위 양식 그룹으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="6568bcbea95dafb76ba6158489a1f4c7cfeff05d" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;address group&lt;/code&gt; combines the current &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt; controls with the new &lt;code&gt;street&lt;/code&gt;, &lt;code&gt;city&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/animations/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;zip&lt;/code&gt; controls. Even though the &lt;code&gt;address&lt;/code&gt; element in the form group is a child of the overall &lt;code&gt;profileForm&lt;/code&gt; element in the form group, the same rules apply with value and status changes. Changes in status and value from the nested form group propagate to the parent form group, maintaining consistency with the overall model.</source>
          <target state="translated">이 예에서 &lt;code&gt;address group&lt;/code&gt; 은 현재 &lt;code&gt;firstName&lt;/code&gt; 및 &lt;code&gt;lastName&lt;/code&gt; 컨트롤을 새로운 &lt;code&gt;street&lt;/code&gt; , &lt;code&gt;city&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/animations/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;zip&lt;/code&gt; 컨트롤 과 결합 합니다. 양식 그룹 의 &lt;code&gt;address&lt;/code&gt; 요소가 양식 그룹에있는 전체 &lt;code&gt;profileForm&lt;/code&gt; 요소 의 하위 요소 인 경우에도 동일한 규칙이 값 및 상태 변경에 적용됩니다. 중첩 된 양식 그룹의 상태 및 값 변경은 상위 양식 그룹으로 전파되어 전체 모델과의 일관성을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="7cee86bfe07ecf66a51c7598a472099fbbc80f94" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;isStable&lt;/code&gt; will never emit &lt;code&gt;true&lt;/code&gt;, and the trace &quot;App is stable now&quot; will never get logged.</source>
          <target state="translated">이 예제에서 &lt;code&gt;isStable&lt;/code&gt; 은 절대 &lt;code&gt;true&lt;/code&gt; 를 방출하지 않으며 &quot;App is secure now&quot;추적은 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c79344ccbfa54921494830310030314d6d9e755c" translate="yes" xml:space="preserve">
          <source>In this example, Angular extracts the expression into two translation units. The first contains the text outside of the &lt;code&gt;select&lt;/code&gt; clause, and uses a placeholder for &lt;code&gt;select&lt;/code&gt; (&lt;code&gt;&amp;lt;x id=&quot;ICU&quot;&amp;gt;&lt;/code&gt;):</source>
          <target state="translated">이 예에서 Angular는 표현식을 두 개의 번역 단위로 추출합니다. 첫 번째는 &lt;code&gt;select&lt;/code&gt; 절 외부의 텍스트를 포함하고 &lt;code&gt;select&lt;/code&gt; ( &lt;code&gt;&amp;lt;x id=&quot;ICU&quot;&amp;gt;&lt;/code&gt; )에 자리 표시자를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="47e50b8623e6a33c605f9c63cfc99fe2a4fd5105" translate="yes" xml:space="preserve">
          <source>In this example, a &lt;code&gt;CounterComponent&lt;/code&gt; logs a change (via &lt;code&gt;ngOnChanges&lt;/code&gt;) every time the parent component increments its input counter property. Meanwhile, the &lt;code&gt;SpyDirective&lt;/code&gt; from the previous example is applied to the &lt;code&gt;CounterComponent&lt;/code&gt; log where it watches log entries being created and destroyed.</source>
          <target state="translated">이 예에서 &lt;code&gt;CounterComponent&lt;/code&gt; 는 부모 구성 요소가 입력 카운터 속성을 증가시킬 때마다 &lt;code&gt;ngOnChanges&lt;/code&gt; 를 통해 변경 사항을 기록 합니다. 한편 이전 예제 의 &lt;code&gt;SpyDirective&lt;/code&gt; 는 &lt;code&gt;CounterComponent&lt;/code&gt; 로그에 적용되어 로그 항목이 작성 및 삭제되는 것을 감시합니다.</target>
        </trans-unit>
        <trans-unit id="eea996b3cfb2e36d293eb699e6a686b5dec933eb" translate="yes" xml:space="preserve">
          <source>In this example, a &lt;code&gt;CounterComponent&lt;/code&gt; uses the &lt;code&gt;ngOnChanges()&lt;/code&gt; method to log a change every time the parent component increments its input &lt;code&gt;counter&lt;/code&gt; property.</source>
          <target state="translated">이 예제에서 &lt;code&gt;CounterComponent&lt;/code&gt; 는 &lt;code&gt;ngOnChanges()&lt;/code&gt; 메서드를 사용 하여 부모 구성 요소가 입력 &lt;code&gt;counter&lt;/code&gt; 속성을 증가시킬 때마다 변경 사항을 기록 합니다.</target>
        </trans-unit>
        <trans-unit id="4795c3bc01ada269031f573d0bb0dec2cbfc2b88" translate="yes" xml:space="preserve">
          <source>In this example, clicking the button calls the &lt;code&gt;log()&lt;/code&gt; function, which outputs the value of &lt;code&gt;#ref3&lt;/code&gt; to the console. Because the &lt;code&gt;#ref&lt;/code&gt; variable is on an &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt;, the value is &lt;code&gt;&lt;a href=&quot;../api/core/templateref&quot;&gt;TemplateRef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 버튼을 클릭하면 &lt;code&gt;log()&lt;/code&gt; 함수가 호출 되어 콘솔 에 &lt;code&gt;#ref3&lt;/code&gt; 값이 출력 됩니다. &lt;code&gt;#ref&lt;/code&gt; 변수가 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 에 있기 때문에 값은 &lt;code&gt;&lt;a href=&quot;../api/core/templateref&quot;&gt;TemplateRef&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b34c27516f98552db8673b22efff281ea6a08dc6" translate="yes" xml:space="preserve">
          <source>In this example, if &lt;code&gt;favoriteHero&lt;/code&gt; is not set, the &lt;code&gt;&lt;a href=&quot;../api/common/ngswitch&quot;&gt;ngSwitch&lt;/a&gt;&lt;/code&gt; value is &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;*&lt;a href=&quot;../api/common/ngswitchdefault&quot;&gt;ngSwitchDefault&lt;/a&gt;&lt;/code&gt; displays, &quot;Please enter ...&quot;. If &lt;code&gt;favoriteHero&lt;/code&gt; is set, the app checks the movie hero by calling a component method. If that method returns &lt;code&gt;true&lt;/code&gt;, the app selects &lt;code&gt;*&lt;a href=&quot;../api/common/ngswitchcase&quot;&gt;ngSwitchCase&lt;/a&gt;=&quot;true&quot;&lt;/code&gt; and displays: &quot;Excellent choice!&quot; If that methods returns &lt;code&gt;false&lt;/code&gt;, the app selects &lt;code&gt;*&lt;a href=&quot;../api/common/ngswitchcase&quot;&gt;ngSwitchCase&lt;/a&gt;=&quot;false&quot;&lt;/code&gt; and displays: &quot;No movie, sorry!&quot;</source>
          <target state="translated">이 예에서 &lt;code&gt;favoriteHero&lt;/code&gt; 를 설정하지 않으면 &lt;code&gt;&lt;a href=&quot;../api/common/ngswitch&quot;&gt;ngSwitch&lt;/a&gt;&lt;/code&gt; 값이 &lt;code&gt;null&lt;/code&gt; 이고 &lt;code&gt;*&lt;a href=&quot;../api/common/ngswitchdefault&quot;&gt;ngSwitchDefault&lt;/a&gt;&lt;/code&gt; 에 &quot;Please enter ...&quot;가 표시됩니다. &lt;code&gt;favoriteHero&lt;/code&gt; 가 설정된 경우 앱은 구성 요소 메서드를 호출하여 영화의 영웅을 확인합니다. 해당 메소드가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 앱은 &lt;code&gt;*&lt;a href=&quot;../api/common/ngswitchcase&quot;&gt;ngSwitchCase&lt;/a&gt;=&quot;true&quot;&lt;/code&gt; 를 선택하고 &quot;Excellent choice!&quot;를 표시합니다. 해당 메소드가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 앱은 &lt;code&gt;*&lt;a href=&quot;../api/common/ngswitchcase&quot;&gt;ngSwitchCase&lt;/a&gt;=&quot;false&quot;&lt;/code&gt; 를 선택 하고 &quot;No movie, sorry!&quot;를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="72f1f2d37ac6c79270b0a7d0849a98d48abc0296" translate="yes" xml:space="preserve">
          <source>In this example, if &lt;code&gt;favoriteHero&lt;/code&gt; is not set, the template displays &quot;Please enter ...&quot;. If &lt;code&gt;favoriteHero&lt;/code&gt; is set, it checks the movie hero by calling a controller method. If that method returns &lt;code&gt;true&lt;/code&gt;, the template displays &quot;Excellent choice!&quot;. If that methods returns &lt;code&gt;false&lt;/code&gt;, the template displays &quot;No movie, sorry!&quot;.</source>
          <target state="translated">이 예에서 &lt;code&gt;favoriteHero&lt;/code&gt; 가 설정되어 있지 않으면 템플릿에 &quot;Please enter ...&quot;가 표시됩니다. 경우 &lt;code&gt;favoriteHero&lt;/code&gt; 이 설정되어, 그것은 컨트롤러 메서드를 호출하여 영화의 주인공을 확인합니다. 해당 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면 템플리트는 &quot;Excellent choice!&quot;를 표시합니다. 해당 메소드가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 템플릿에 &quot;No movie, sorry!&quot;가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="af3bdcb5fef615d78019a726d74324f420e52102" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; element is hidden if the &lt;code&gt;favoriteHero&lt;/code&gt; variable is not truthy.</source>
          <target state="translated">이 예 에서 &lt;code&gt;favoriteHero&lt;/code&gt; 변수가 사실이 아닌 경우 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 요소가 숨겨집니다 .</target>
        </trans-unit>
        <trans-unit id="45a0870a00e40b52bff70afae912dde516d98427" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; element is shown if the &lt;code&gt;favoriteHero&lt;/code&gt; variable is truthy.</source>
          <target state="translated">이 예 에서 &lt;code&gt;favoriteHero&lt;/code&gt; 변수가 진실 이면 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 요소가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="eaed41066495437d45b6edacc8a7e191ea8479ea" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; element is removed from the DOM unless the &lt;code&gt;movies&lt;/code&gt; array has a length greater than zero.</source>
          <target state="translated">이 예제 에서 &lt;code&gt;movies&lt;/code&gt; 배열의 길이가 0보다 크지 않으면 &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; 요소가 DOM에서 제거 됩니다.</target>
        </trans-unit>
        <trans-unit id="29ba1a50a860d713db88a878e1386a55649ba999" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; element is removed from the DOM unless the &lt;code&gt;movies&lt;/code&gt; array has a length.</source>
          <target state="translated">이 예제 에서 &lt;code&gt;movies&lt;/code&gt; 배열의 길이가 없으면 &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; 요소가 DOM에서 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="9914b2e1524218e10a4fe48a32a9e8b2977bb5c9" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;BannerComponent&lt;/code&gt; is the only component to compile. Other examples configure the testing module with multiple components and may import application modules that hold yet more components. Any of them could be require external files.</source>
          <target state="translated">이 예제에서 &lt;code&gt;BannerComponent&lt;/code&gt; 는 컴파일 할 유일한 구성 요소입니다. 다른 예는 여러 구성 요소로 테스트 모듈을 구성하며 더 많은 구성 요소를 보유한 응용 프로그램 모듈을 가져올 수 있습니다. 외부 파일이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3390a9441f57488ac443819ff9b1e78631a8db37" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;BannerComponent&lt;/code&gt; is the only component to compile. Other examples configure the testing module with multiple components and may import application modules that hold yet more components. Any of them could require external files.</source>
          <target state="translated">이 예제에서 &lt;code&gt;BannerComponent&lt;/code&gt; 는 컴파일 할 유일한 구성 요소입니다. 다른 예제는 여러 구성 요소로 테스트 모듈을 구성하고 더 많은 구성 요소를 보유하는 응용 프로그램 모듈을 가져올 수 있습니다. 그들 중 어느 것도 외부 파일이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="119771170aaca742e78ea766c300375a30e9f747" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;LibCardComponent&lt;/code&gt; implementation no longer refers to &lt;code&gt;LibHeaderComponent&lt;/code&gt; in either the type position or the value position. This allows full tree shaking of &lt;code&gt;LibHeaderComponent&lt;/code&gt; to take place. The &lt;code&gt;LibHeaderToken&lt;/code&gt; is retained, but it is only a class declaration, with no concrete implementation. It is small and does not materially impact the application size when retained after compilation.</source>
          <target state="translated">이 예제에서 &lt;code&gt;LibCardComponent&lt;/code&gt; 구현은 더 이상 유형 위치 또는 값 위치에서 &lt;code&gt;LibHeaderComponent&lt;/code&gt; 를 참조하지 않습니다 . 이를 통해 &lt;code&gt;LibHeaderComponent&lt;/code&gt; 의 전체 트리 흔들림이 발생할 수 있습니다. &lt;code&gt;LibHeaderToken&lt;/code&gt; 은 유지되지만 구체적인 구현과, 단지 클래스 선언이다. 크기가 작고 컴파일 후 유지 될 때 응용 프로그램 크기에 큰 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="021f289166efe72931574fd499284cc05ab8c72e" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;LoadingState&amp;lt;T&amp;gt;&lt;/code&gt; type permits either of two states, &lt;code&gt;Loaded&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;Loading&lt;/code&gt;. The expression used as the directive&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;../api/animations/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; input is of the umbrella type &lt;code&gt;LoadingState&lt;/code&gt;, as it&amp;rsquo;s unknown what the loading state is at that point.</source>
          <target state="translated">이 예제에서 &lt;code&gt;LoadingState&amp;lt;T&amp;gt;&lt;/code&gt; 유형은 &lt;code&gt;Loaded&amp;lt;T&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;Loading&lt;/code&gt; 두 가지 상태 중 하나를 허용합니다 . 지시문의 &lt;code&gt;&lt;a href=&quot;../api/animations/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 입력 으로 사용되는 표현식 은 해당 시점의 로딩 상태가 무엇인지 알 수 &lt;code&gt;LoadingState&lt;/code&gt; 때문에 우산 유형 LoadingState 입니다.</target>
        </trans-unit>
        <trans-unit id="5f0121c1cd7668454f283fbaa22a823417529960" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;TwainComponent.getQuote()&lt;/code&gt; method tells you that the &lt;code&gt;quote&lt;/code&gt; property returns an &lt;code&gt;Observable&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 &lt;code&gt;TwainComponent.getQuote()&lt;/code&gt; 메서드는 &lt;code&gt;quote&lt;/code&gt; 속성이 &lt;code&gt;Observable&lt;/code&gt; 을 반환 한다는 것을 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="a652a084958d1f1ea901db7f1428a4b9bc52595b" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;doSomething()&lt;/code&gt; method updates the screen when the hero name exceeds 10 characters, but waits a tick before updating &lt;code&gt;comment&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 &lt;code&gt;doSomething()&lt;/code&gt; 메서드는 hero 이름이 10자를 초과하면 화면을 업데이트하지만 &lt;code&gt;comment&lt;/code&gt; 를 업데이트하기 전에 틱을 기다립니다 .</target>
        </trans-unit>
        <trans-unit id="d8dc87778ed16f68aed10d08c1afb1cc4c8aa4f0" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;h1&lt;/code&gt; style applies only to the &lt;code&gt;HeroAppComponent&lt;/code&gt;, not to the nested &lt;code&gt;HeroMainComponent&lt;/code&gt; nor to &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; tags anywhere else in the application.</source>
          <target state="translated">이 예제에서 &lt;code&gt;h1&lt;/code&gt; 스타일 은 중첩 된 &lt;code&gt;HeroMainComponent&lt;/code&gt; 또는 애플리케이션의 다른 곳에서는 &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; 태그가 아닌 &lt;code&gt;HeroAppComponent&lt;/code&gt; 에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="67de3693d36a539340b8927be4b004d3faaeb677" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;name&lt;/code&gt; control sets up two built-in validators&amp;mdash;&lt;code&gt;Validators.required&lt;/code&gt; and &lt;code&gt;Validators.minLength(4)&lt;/code&gt;&amp;mdash;and one custom validator, &lt;code&gt;forbiddenNameValidator&lt;/code&gt;. (For more details see &lt;a href=&quot;form-validation#custom-validators&quot;&gt;custom validators&lt;/a&gt; below.)</source>
          <target state="translated">이 예에서 &lt;code&gt;name&lt;/code&gt; 컨트롤은 내장 된 유효성 검사기 &lt;code&gt;Validators.required&lt;/code&gt; 및 &lt;code&gt;Validators.minLength(4)&lt;/code&gt; 개와 사용자 지정 유효성 검사기 &lt;code&gt;forbiddenNameValidator&lt;/code&gt; 하나를 설정 합니다. (자세한 내용은 아래 &lt;a href=&quot;form-validation#custom-validators&quot;&gt;맞춤 유효성 검사기를&lt;/a&gt; 참조하세요.)</target>
        </trans-unit>
        <trans-unit id="581286bbe5a7e8813d9bd8f6ce48e4c91dae6d3b" translate="yes" xml:space="preserve">
          <source>In this example, the Angular CLI compiles and bundles the Universal version of the app with the &lt;a href=&quot;aot-compiler&quot;&gt;Ahead-of-Time (AOT) compiler&lt;/a&gt;. A Node.js Express web server compiles HTML pages with Universal based on client requests.</source>
          <target state="translated">이 예제에서 Angular CLI는 &lt;a href=&quot;aot-compiler&quot;&gt;AOT (Ahead-of-Time) 컴파일러&lt;/a&gt; 를 사용하여 앱의 유니버설 버전을 컴파일하고 번들로 제공합니다 . Node.js Express 웹 서버는 클라이언트 요청에 따라 Universal로 HTML 페이지를 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="70fdbfe2246483712f70ef97797c46fb0bec5603" translate="yes" xml:space="preserve">
          <source>In this example, the Angular CLI compiles and bundles the Universal version of the app with the &lt;a href=&quot;aot-compiler&quot;&gt;Ahead-of-Time (AoT) compiler&lt;/a&gt;. A Node Express web server compiles HTML pages with Universal based on client requests.</source>
          <target state="translated">이 예제에서 Angular CLI는 &lt;a href=&quot;aot-compiler&quot;&gt;AoT (Ahead-of-Time) 컴파일러&lt;/a&gt; 와 함께 앱의 범용 버전을 컴파일하고 번들로 제공합니다 . Node Express 웹 서버는 클라이언트 요청에 따라 범용으로 HTML 페이지를 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="f1117862898e16209748d37073fb954a643784bc" translate="yes" xml:space="preserve">
          <source>In this example, the compiler disregards type incompatibilities in nullability, just as in TypeScript code. In the case of the &lt;code&gt;&lt;a href=&quot;../api/common/asyncpipe&quot;&gt;async&lt;/a&gt;&lt;/code&gt; pipe, note that the expression needs to be wrapped in parentheses, as in &lt;code&gt;&amp;lt;user-detail [user]=&quot;(user$ | async)!&quot; /&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 컴파일러는 TypeScript 코드에서와 마찬가지로 null 허용 여부에서 유형 비 호환성을 무시합니다. &lt;code&gt;&lt;a href=&quot;../api/common/asyncpipe&quot;&gt;async&lt;/a&gt;&lt;/code&gt; 파이프 의 경우 &lt;code&gt;&amp;lt;user-detail [user]=&quot;(user$ | async)!&quot; /&amp;gt;&lt;/code&gt; 와 같이 표현식을 괄호로 묶어야합니다 . /&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="7f0c59ac145dae8f5ddcee4ccb7a940b3dee4652" translate="yes" xml:space="preserve">
          <source>In this example, the context of the &lt;code&gt;$event&lt;/code&gt; object, &lt;code&gt;hero&lt;/code&gt;, and &lt;code&gt;#heroForm&lt;/code&gt; is the template.</source>
          <target state="translated">이 예에서 &lt;code&gt;$event&lt;/code&gt; 객체, &lt;code&gt;hero&lt;/code&gt; 및 &lt;code&gt;#heroForm&lt;/code&gt; 의 컨텍스트 가 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="3c77e55816f54a0b51362c2c86c1b0a18effa47f" translate="yes" xml:space="preserve">
          <source>In this example, the function receives the current &lt;code&gt;Tree&lt;/code&gt; and returns it without any modifications. If you need to, you can do additional setup when your package is installed, such as generating files, updating configuration, or any other initial setup your library requires.</source>
          <target state="translated">이 예제에서 함수는 현재 &lt;code&gt;Tree&lt;/code&gt; 를 받아서 수정없이 반환합니다. 필요한 경우 파일 생성, 구성 업데이트 또는 라이브러리에 필요한 기타 초기 설정과 같이 패키지를 설치할 때 추가 설정을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f760e6853240f1a247368ea5cf4ca224bc0cab0" translate="yes" xml:space="preserve">
          <source>In this example, the metadata object passed to &lt;code&gt;TestBed.configureTestingModule&lt;/code&gt; simply declares &lt;code&gt;BannerComponent&lt;/code&gt;, the component to test.</source>
          <target state="translated">이 예에서, 메타 데이터에 전달 된 객체 &lt;code&gt;TestBed.configureTestingModule&lt;/code&gt; 은 단순히 선언 &lt;code&gt;BannerComponent&lt;/code&gt; 테스트의 컴포넌트.</target>
        </trans-unit>
        <trans-unit id="4fa761fa0db5279057ebbd7c918d23d617db68c2" translate="yes" xml:space="preserve">
          <source>In this example, the parent component is &lt;code&gt;AppComponent&lt;/code&gt;, but you could use any component in which you could nest the child.</source>
          <target state="translated">이 예제에서 상위 컴포넌트는 &lt;code&gt;AppComponent&lt;/code&gt; 이지만 하위를 중첩 할 수있는 모든 컴포넌트를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f6f8011b5dc464a23b1d8849f6646fc7783a339" translate="yes" xml:space="preserve">
          <source>In this example, the service worker has one version of the app cached and being used to serve two different tabs. Note that this version hash is the &quot;latest manifest hash&quot; listed above. Both clients are on the latest version. Each client is listed by its ID from the &lt;code&gt;Clients&lt;/code&gt; API in the browser.</source>
          <target state="translated">이 예에서 서비스 워커는 하나의 버전의 앱을 캐시하고 두 개의 다른 탭을 제공하는 데 사용됩니다. 이 버전 해시는 위에 나열된 &quot;최신 매니페스트 해시&quot;입니다. 두 클라이언트 모두 최신 버전입니다. 각 클라이언트는 브라우저 의 &lt;code&gt;Clients&lt;/code&gt; API에서 ID별로 나열됩니다 .</target>
        </trans-unit>
        <trans-unit id="141adfd803373a7562c9907611167c881b44c8b3" translate="yes" xml:space="preserve">
          <source>In this example, the table row (&lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt;) element repeats for each movie object in the collection of movies.</source>
          <target state="translated">이 예제에서 테이블 행 ( &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; ) 요소는 영화 컬렉션의 각 영화 객체에 대해 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="e76b2c3a28485e6785406f24973109ce2379794c" translate="yes" xml:space="preserve">
          <source>In this example, the third route is a redirect so that the router defaults to the &lt;code&gt;first-component&lt;/code&gt; route. Notice that this redirect precedes the wildcard route. Here, &lt;code&gt;path: ''&lt;/code&gt; means to use the initial relative URL (&lt;code&gt;''&lt;/code&gt;).</source>
          <target state="translated">이 예에서 세 번째 경로는 리디렉션이므로 라우터는 기본적으로 &lt;code&gt;first-component&lt;/code&gt; 경로를 사용합니다. 이 리디렉션은 와일드 카드 경로보다 우선합니다. 여기서 &lt;code&gt;path: ''&lt;/code&gt; 는 초기 상대 URL ( &lt;code&gt;''&lt;/code&gt; ) 을 사용함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="a1fc753a972a0e8642c389f78d449c6f46254fae" translate="yes" xml:space="preserve">
          <source>In this example, the trace &quot;App is stable now&quot; will be logged and then the counter starts incrementing every second.</source>
          <target state="translated">이 예에서는 추적 &quot;앱이 안정적입니다&quot;가 기록되고 카운터가 1 초마다 증가하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="e1adb1392f66f2621eeb646a78fc33dc4ca7ed9c" translate="yes" xml:space="preserve">
          <source>In this example, there are two additional child components, &lt;code&gt;child-a&lt;/code&gt;, and &lt;code&gt;child-b&lt;/code&gt;. Here, &lt;code&gt;FirstComponent&lt;/code&gt; has its own &lt;code&gt;&amp;lt;nav&amp;gt;&lt;/code&gt; and a second &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; in addition to the one in &lt;code&gt;AppComponent&lt;/code&gt;.</source>
          <target state="translated">이 예에서, 두 개의 추가 자식 구성 요소가있는 &lt;code&gt;child-a&lt;/code&gt; 와 &lt;code&gt;child-b&lt;/code&gt; . 여기서, &lt;code&gt;FirstComponent&lt;/code&gt; 은 자체 보유 &lt;code&gt;&amp;lt;nav&amp;gt;&lt;/code&gt; 및 제 &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; 의 하나 이외에 &lt;code&gt;AppComponent&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="55313e1b1881081b73a426b4b5ede5214265a96f" translate="yes" xml:space="preserve">
          <source>In this example, there is a parent provider and injecting the service will return the value, however, injecting the service with &lt;code&gt;@&lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;()&lt;/code&gt; will return &lt;code&gt;null&lt;/code&gt; because &lt;code&gt;@&lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt;()&lt;/code&gt; tells the injector to stop searching in the current host element.</source>
          <target state="translated">이 예제에는 부모 공급자가 있으며 서비스를 주입하면 값을 반환하지만 &lt;code&gt;@&lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt;()&lt;/code&gt; 및 &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;()&lt;/code&gt; 을 사용 하여 서비스를 주입하면 &lt;code&gt;@&lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt; () 가 인젝터에게 현재 검색을 중지하도록 지시 하므로 &lt;code&gt;null&lt;/code&gt; 을 반환 합니다. 호스트 요소.</target>
        </trans-unit>
        <trans-unit id="e9fbe267e141148afaa5adfc5af6e3bf9cbfcb38" translate="yes" xml:space="preserve">
          <source>In this example, we have a new macro task (nested setTimeout), by default, when we &lt;code&gt;&lt;a href=&quot;../api/core/testing/tick&quot;&gt;tick&lt;/a&gt;&lt;/code&gt;, the setTimeout &lt;code&gt;outside&lt;/code&gt; and &lt;code&gt;nested&lt;/code&gt; will both be triggered.</source>
          <target state="translated">이 예제에서, 우리는 우리가 할 때, 기본적으로 새 매크로 작업 (중첩의 setTimeout)가 &lt;code&gt;&lt;a href=&quot;../api/core/testing/tick&quot;&gt;tick&lt;/a&gt;&lt;/code&gt; 의의 setTimeout &lt;code&gt;outside&lt;/code&gt; 와 &lt;code&gt;nested&lt;/code&gt; 의지 모두가 트리거 될 수있다.</target>
        </trans-unit>
        <trans-unit id="db3b7288e76c9764175a504022fe6dac60eb02e9" translate="yes" xml:space="preserve">
          <source>In this example, we have a special trigger for the enter and leave animation called &lt;code&gt;myInsertRemoveTrigger&lt;/code&gt;. The HTML template contains the following code.</source>
          <target state="translated">이 예제에는 &lt;code&gt;myInsertRemoveTrigger&lt;/code&gt; 라는 enter and leave 애니메이션에 대한 특수 트리거가 있습니다 . HTML 템플릿에는 다음 코드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f23673ea8bd0a665773af3bb10e9ab0cc487c74" translate="yes" xml:space="preserve">
          <source>In this example, we have a trigger called &lt;code&gt;shrinkOut&lt;/code&gt;, used when an HTML element leaves the page. The animation takes whatever height the element has before it leaves, and animates from that height to zero.</source>
          <target state="translated">이 예제 에는 HTML 요소가 페이지를 떠날 때 사용되는 &lt;code&gt;shrinkOut&lt;/code&gt; 트리거가 있습니다 . 애니메이션은 요소가 떠나기 전에 모든 높이를 가져와 해당 높이에서 0으로 애니메이션합니다.</target>
        </trans-unit>
        <trans-unit id="d5449a4988ffee8945fd260d02e422915ed66b26" translate="yes" xml:space="preserve">
          <source>In this example, we tell the processor to put the fragments together without anything in between - without any &quot;plaster&quot;. Most sample files define this &lt;em&gt;empty plaster&lt;/em&gt;.</source>
          <target state="translated">이 예에서는 프로세서에 &quot;플레 스터&quot;없이 조각을 넣지 않도록 지시합니다. 대부분의 샘플 파일은이 &lt;em&gt;빈 석고를&lt;/em&gt; 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="9f8e0d121e50e60163e599d82947e2d681ecf6cb" translate="yes" xml:space="preserve">
          <source>In this example, we'll name the trigger &lt;code&gt;openClose&lt;/code&gt;, and attach it to the &lt;code&gt;button&lt;/code&gt; element. The trigger describes the open and closed states, and the timings for the two transitions.</source>
          <target state="translated">이 예제에서는 트리거의 이름을 &lt;code&gt;openClose&lt;/code&gt; 로 지정하고 &lt;code&gt;button&lt;/code&gt; 요소에 연결합니다 . 트리거는 열림 및 닫힘 상태와 두 전환의 타이밍을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0f166860e3bda6fd17d0325d2f54b8f0ba7afcd0" translate="yes" xml:space="preserve">
          <source>In this example, when the &lt;code&gt;isOpen&lt;/code&gt; expression evaluates to a defined state of &lt;code&gt;open&lt;/code&gt; or &lt;code&gt;closed&lt;/code&gt;, it notifies the trigger &lt;code&gt;openClose&lt;/code&gt; of a state change. Then it's up to the &lt;code&gt;openClose&lt;/code&gt; code to handle the state change and kick off a state change animation.</source>
          <target state="translated">이 예제에서 &lt;code&gt;isOpen&lt;/code&gt; 표현식이 정의 된 &lt;code&gt;open&lt;/code&gt; 또는 &lt;code&gt;closed&lt;/code&gt; 상태로 평가되면 &lt;code&gt;openClose&lt;/code&gt; 트리거 에 상태 변경을 알립니다 . 그런 다음 상태 변경을 처리하고 상태 변경 애니메이션을 시작 하는 것은 &lt;code&gt;openClose&lt;/code&gt; 코드에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="8122141c419796ccece90e8861443226d3fc7efb" translate="yes" xml:space="preserve">
          <source>In this example, you hide the message when the control is either valid or &lt;em&gt;pristine&lt;/em&gt;. Pristine means the user hasn't changed the value since it was displayed in this form. If you ignore the &lt;code&gt;pristine&lt;/code&gt; state, you would hide the message only when the value is valid. If you arrive in this component with a new (blank) hero or an invalid hero, you'll see the error message immediately, before you've done anything.</source>
          <target state="translated">이 예에서는 컨트롤이 valid 또는 &lt;em&gt;pristine&lt;/em&gt; 일 때 메시지를 숨 깁니다 . Pristine은이 양식으로 표시된 이후 사용자가 값을 변경하지 않았 음을 의미합니다. &lt;code&gt;pristine&lt;/code&gt; 상태 를 무시 하면 값이 유효한 경우에만 메시지를 숨 깁니다. 새로운 (빈) Hero 또는 잘못된 Hero와 함께이 구성 요소에 도착하면 작업을 수행하기 전에 즉시 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="857e41f3d387f7cf872a74341b0658452c56adc6" translate="yes" xml:space="preserve">
          <source>In this example, you hide the message when the control is valid or pristine; &quot;pristine&quot; means the user hasn't changed the value since it was displayed in this form.</source>
          <target state="translated">이 예에서는 컨트롤이 유효하거나 깨끗할 때 메시지를 숨 깁니다. &quot;pristine&quot;은 사용자가이 양식으로 표시된 이후 값을 변경하지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="baf3737ace5606abd1ec8225579802cb34f52588" translate="yes" xml:space="preserve">
          <source>In this example, you retrieve the route parameter map from an &lt;code&gt;Observable&lt;/code&gt;. That implies that the route parameter map can change during the lifetime of this component.</source>
          <target state="translated">이 예에서는 &lt;code&gt;Observable&lt;/code&gt; 에서 경로 매개 변수 맵을 검색합니다 . 이는이 구성 요소의 수명 동안 경로 매개 변수 맵이 변경 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="22dacf1b0042c1fad5409535bd55de92eadb09f0" translate="yes" xml:space="preserve">
          <source>In this guide, we go into greater depth on special transition states such as &lt;code&gt;*&lt;/code&gt; (wildcard) and &lt;code&gt;void&lt;/code&gt;, and show how these special states are used for elements entering and leaving a view. The chapter also explores multiple animation triggers, animation callbacks and sequence-based animation using keyframes.</source>
          <target state="translated">이 안내서에서는 &lt;code&gt;*&lt;/code&gt; (와일드 카드) 및 &lt;code&gt;void&lt;/code&gt; 와 같은 특수 전환 상태에 대해 자세히 살펴보고 이러한 특수 상태가 뷰에 들어오고 나가는 요소에 어떻게 사용되는지 보여줍니다. 이 장에서는 키 프레임을 사용하여 여러 애니메이션 트리거, 애니메이션 콜백 및 시퀀스 기반 애니메이션에 대해서도 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d391ee1c171a2767942bc43f6ae9952564664a67" translate="yes" xml:space="preserve">
          <source>In this implementation, the component should create and display a new hero. New heroes have &lt;code&gt;id=0&lt;/code&gt; and a blank &lt;code&gt;name&lt;/code&gt;. This test confirms that the component behaves as expected:</source>
          <target state="translated">이 구현에서 구성 요소는 새로운 영웅을 만들고 표시해야합니다. 새로운 영웅은 &lt;code&gt;id=0&lt;/code&gt; 이고 빈 &lt;code&gt;name&lt;/code&gt; 갖습니다 . 이 테스트는 구성 요소가 예상대로 작동하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="76cbc5a9e329031cf1bab2ff3296215a7ffaf283" translate="yes" xml:space="preserve">
          <source>In this last exercise, you learn to chain &lt;code&gt;Observable&lt;/code&gt; operators together so you can minimize the number of similar HTTP requests and consume network bandwidth economically.</source>
          <target state="translated">이 마지막 연습에서는 &lt;code&gt;Observable&lt;/code&gt; 연산자를 함께 연결하여 유사한 HTTP 요청 수를 최소화하고 네트워크 대역폭을 경제적으로 소비하는 방법을 배웁니다 .</target>
        </trans-unit>
        <trans-unit id="9b0401f148735f00014a29894e7c27898d1d095b" translate="yes" xml:space="preserve">
          <source>In this mode, typed variables disallow &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; by default. The type checker throws an error if you leave a variable unassigned or try to assign &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; to a variable whose type disallows &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">이 모드에서 유형이 지정된 변수 는 기본적으로 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 를 허용하지 않습니다 . 변수를 할당되지 않은 상태로 두거나 형식이 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 를 허용하지 않는 변수에 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 를 지정하려고하면 형식 검사기가 오류를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="280da26e99ef856ec857edb7fba6fd1a43c74759" translate="yes" xml:space="preserve">
          <source>In this next section, you'll extend the crisis center with some new &lt;em&gt;administrative&lt;/em&gt; features. Those features aren't defined yet. But you can start by adding a new feature module named &lt;code&gt;AdminModule&lt;/code&gt;.</source>
          <target state="translated">다음 섹션에서는 몇 가지 새로운 &lt;em&gt;관리&lt;/em&gt; 기능으로 위기 센터를 확장 할 것 입니다. 이러한 기능은 아직 정의되지 않았습니다. 그러나 &lt;code&gt;AdminModule&lt;/code&gt; 이라는 새 기능 모듈을 추가하여 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e77ddac00429a19af490ee0fff3eb26cd48acc6" translate="yes" xml:space="preserve">
          <source>In this next section, you'll update the &lt;code&gt;CrisisCenterModule&lt;/code&gt; to load lazily by default and use the &lt;code&gt;&lt;a href=&quot;../api/router/preloadallmodules&quot;&gt;PreloadAllModules&lt;/a&gt;&lt;/code&gt; strategy to load it (and &lt;em&gt;all other&lt;/em&gt; lazy loaded modules) as soon as possible.</source>
          <target state="translated">이 다음 섹션에서는 기본적으로 &lt;code&gt;CrisisCenterModule&lt;/code&gt; 을 업데이트하여 느리게로드하고 &lt;code&gt;&lt;a href=&quot;../api/router/preloadallmodules&quot;&gt;PreloadAllModules&lt;/a&gt;&lt;/code&gt; 전략을 사용하여 가능한 빨리 모듈 (및 &lt;em&gt;다른 모든&lt;/em&gt; 게으른로드 된 모듈)을로드합니다.</target>
        </trans-unit>
        <trans-unit id="910d57aa8f2c9d322a7ddfffafff5a1e12be15d4" translate="yes" xml:space="preserve">
          <source>In this page, you'll create a component with a list of heroes. You'll display the list of hero names and conditionally show a message below the list.</source>
          <target state="translated">이 페이지에서는 영웅 목록이 포함 된 구성 요소를 만듭니다. 영웅 이름 목록을 표시하고 목록 아래에 메시지를 조건부로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="5991263aee79edfabb240fd4a80ec9aca9c4f379" translate="yes" xml:space="preserve">
          <source>In this page, you'll expand the Tour of Heroes app to display a list of heroes, and allow users to select a hero and display the hero's details.</source>
          <target state="translated">이 페이지에서 Tour of Heroes 앱을 확장하여 영웅 목록을 표시하고 사용자가 영웅을 선택하고 영웅의 세부 정보를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36e07abc829fe293c414ff2c42ec086b5bcaa116" translate="yes" xml:space="preserve">
          <source>In this page, you'll take the first step in that direction by moving the hero details into a separate, reusable &lt;code&gt;HeroDetailComponent&lt;/code&gt;.</source>
          <target state="translated">이 페이지에서는 영웅 세부 정보를 재사용 가능한 별도의 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 로 이동하여 해당 방향으로 첫 단계를 진행합니다 .</target>
        </trans-unit>
        <trans-unit id="41eadd61e2099c9b71eca402988c22d2dc4da72a" translate="yes" xml:space="preserve">
          <source>In this part of the tutorial, you'll do the following:</source>
          <target state="translated">학습서의이 부분에서는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="f9704e3a1c4e2e88d3b06005691f30d54c3fe8a0" translate="yes" xml:space="preserve">
          <source>In this sample app, an &lt;code&gt;Item&lt;/code&gt; is an object that has two properties; an &lt;code&gt;id&lt;/code&gt; and a &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">이 샘플 앱에서 &lt;code&gt;Item&lt;/code&gt; 은 두 가지 속성이있는 객체입니다. &lt;code&gt;id&lt;/code&gt; 와 &lt;code&gt;name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a920eb2f136fa29d3d8fd6be1642038fa8343dd7" translate="yes" xml:space="preserve">
          <source>In this sample, the &lt;code&gt;AboutComponent&lt;/code&gt; template hosts a &lt;code&gt;TwainComponent&lt;/code&gt;. The &lt;code&gt;TwainComponent&lt;/code&gt; displays Mark Twain quotes.</source>
          <target state="translated">이 샘플에서 &lt;code&gt;AboutComponent&lt;/code&gt; 템플리트는 &lt;code&gt;TwainComponent&lt;/code&gt; 를 호스팅합니다 . &lt;code&gt;TwainComponent&lt;/code&gt; 는 마크 트웨인 따옴표를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="83a3e6ce2e81d5334705552ed704c13c7a012cad" translate="yes" xml:space="preserve">
          <source>In this sample, the &lt;code&gt;preload()&lt;/code&gt; method loads the route if the route's &lt;code&gt;data.preload&lt;/code&gt; flag is truthy.</source>
          <target state="translated">이 샘플에서 &lt;code&gt;preload()&lt;/code&gt; 메서드는 경로의 &lt;code&gt;data.preload&lt;/code&gt; 플래그가 사실 이면 경로를로드합니다 .</target>
        </trans-unit>
        <trans-unit id="d4570e44a44492eaf23a15501bcef8aeda6caf07" translate="yes" xml:space="preserve">
          <source>In this sample, the &lt;code&gt;preload&lt;/code&gt; method loads the route if the route's &lt;code&gt;data.preload&lt;/code&gt; flag is truthy.</source>
          <target state="translated">이 샘플 에서 경로의 &lt;code&gt;data.preload&lt;/code&gt; 플래그가 사실 이면 &lt;code&gt;preload&lt;/code&gt; 메소드는 경로를로드합니다 .</target>
        </trans-unit>
        <trans-unit id="53df60f2bbc6ff801450ca15e253828f19eef2d8" translate="yes" xml:space="preserve">
          <source>In this sample, the forbidden name is &quot;bob&quot;, so the validator will reject any hero name containing &quot;bob&quot;. Elsewhere it could reject &quot;alice&quot; or any name that the configuring regular expression matches.</source>
          <target state="translated">이 샘플에서 금지 된 이름은 &quot;bob&quot;이므로 유효성 검사기는 &quot;bob&quot;을 포함하는 모든 영웅 이름을 거부합니다. 다른 곳에서는 &quot;alice&quot;또는 구성 정규식이 일치하는 이름을 거부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1cff468c4938260e2ee129abcb3fdbc441be47c" translate="yes" xml:space="preserve">
          <source>In this scenario, &lt;code&gt;ListItemComponent&lt;/code&gt; is nested within &lt;code&gt;AppComponent&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; property expects an object.</source>
          <target state="translated">이 시나리오에서 &lt;code&gt;ListItemComponent&lt;/code&gt; 는 &lt;code&gt;AppComponent&lt;/code&gt; 내에 중첩 되며 &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; 속성에는 개체가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bb1ad6d637c2681a211a37960e4482d763186a33" translate="yes" xml:space="preserve">
          <source>In this scenario, the user could click the heroes link, cancel, push the browser back button, or navigate away without saving.</source>
          <target state="translated">이 시나리오에서 사용자는 Heroes 링크를 클릭하거나 취소하거나 브라우저 뒤로 버튼을 누르거나 저장하지 않고 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="108f5e361f5279c807a1b95c7212da592113b5c1" translate="yes" xml:space="preserve">
          <source>In this section, you add a &quot;Buy&quot; button to the product details view and set up a cart service to store information about products in the cart.</source>
          <target state="translated">이 섹션에서는 제품 세부 정보보기에 &quot;구매&quot;버튼을 추가하고 카트에있는 제품에 대한 정보를 저장하는 카트 서비스를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="866e463973eba9b6978ee8e41218dfba8d744659" translate="yes" xml:space="preserve">
          <source>In this section, you will see how to use the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpparams&quot;&gt;HttpParams&lt;/a&gt;&lt;/code&gt; class to add URL query strings in your &lt;code&gt;&lt;a href=&quot;../api/common/http/httprequest&quot;&gt;HttpRequest&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpparams&quot;&gt;HttpParams&lt;/a&gt;&lt;/code&gt; 클래스를 사용 하여 &lt;code&gt;&lt;a href=&quot;../api/common/http/httprequest&quot;&gt;HttpRequest&lt;/a&gt;&lt;/code&gt; 에 URL 쿼리 문자열을 추가 하는 방법을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="031c1b1a94c645c385beb5a16ec41f21634daadf" translate="yes" xml:space="preserve">
          <source>In this section, you write an &lt;code&gt;UnlessDirective&lt;/code&gt; structural directive that does the opposite of &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; displays the template content when the condition is &lt;code&gt;true&lt;/code&gt;. &lt;code&gt;UnlessDirective&lt;/code&gt; displays the content when the condition is &lt;strong&gt;&lt;em&gt;false&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">이 섹션에서는, 당신은 쓰기 &lt;code&gt;UnlessDirective&lt;/code&gt; 의 반대 않는 구조 지시 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 을 . 조건이 &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 는 템플리트 컨텐츠를 표시 합니다 . &lt;code&gt;UnlessDirective&lt;/code&gt; 는 조건이 &lt;strong&gt;&lt;em&gt;false 일&lt;/em&gt;&lt;/strong&gt; 때 내용을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="e63bcb3ea1e33ee82569b40699b6b77935276464" translate="yes" xml:space="preserve">
          <source>In this section, you'll add a &quot;Buy&quot; button to the product details page. You'll also set up a cart service to store information about products in the cart.</source>
          <target state="translated">이 섹션에서는 제품 세부 정보 페이지에 &quot;구매&quot;버튼을 추가합니다. 장바구니에 제품 정보를 저장하는 장바구니 서비스도 설정합니다.</target>
        </trans-unit>
        <trans-unit id="41614ef975f51a1aa45b0453fbf9c5d863d0f122" translate="yes" xml:space="preserve">
          <source>In this section, you'll add a custom strategy that &lt;em&gt;only&lt;/em&gt; preloads routes whose &lt;code&gt;data.preload&lt;/code&gt; flag is set to &lt;code&gt;true&lt;/code&gt;. Recall that you can add anything to the &lt;code&gt;data&lt;/code&gt; property of a route.</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;data.preload&lt;/code&gt; 플래그가 &lt;code&gt;true&lt;/code&gt; 로 설정된 경로 &lt;em&gt;만&lt;/em&gt; 미리로드 하는 사용자 지정 전략을 추가 합니다 . 경로 의 &lt;code&gt;data&lt;/code&gt; 속성에 무엇이든 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f368e147277bce5919185a90ecf1ce77809a6f65" translate="yes" xml:space="preserve">
          <source>In this section, you'll create the shopping cart. You'll:</source>
          <target state="translated">이 섹션에서는 쇼핑 카트를 만듭니다. 당신은 :</target>
        </trans-unit>
        <trans-unit id="3ea0b8c21cff6d2dfec5ecbd44d0d0beb599e670" translate="yes" xml:space="preserve">
          <source>In this section, you'll define two routes:</source>
          <target state="translated">이 섹션에서는 두 가지 경로를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e48b893529d0a4f861fdf041e0a05ca27fb957eb" translate="yes" xml:space="preserve">
          <source>In this section, you'll enable navigation to the &lt;code&gt;HeroDetailsComponent&lt;/code&gt; and liberate it from the &lt;code&gt;HeroesComponent&lt;/code&gt;.</source>
          <target state="translated">이 섹션에서는에 탐색을 가능하게합니다 &lt;code&gt;HeroDetailsComponent&lt;/code&gt; 과에서 해방 &lt;code&gt;HeroesComponent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a56f98809a826693d78cbbbfd23fc132fc6017b" translate="yes" xml:space="preserve">
          <source>In this section, you'll extend the app to display full product details in separate pages, with their own URLs.</source>
          <target state="translated">이 섹션에서는 앱을 확장하여 고유 한 URL을 사용하여 전체 제품 세부 정보를 별도의 페이지에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="2b0c69edf13235c900832e080c6999a183c272d5" translate="yes" xml:space="preserve">
          <source>In this section, you'll finish the app by adding a form-based checkout feature. You'll create a form to collect user information as part of checkout.</source>
          <target state="translated">이 섹션에서는 폼 기반 체크 아웃 기능을 추가하여 앱을 완성합니다. 결제의 일부로 사용자 정보를 수집하는 양식을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="0bd6664792b4ac76642b5f4d66e0875468eb9a2d" translate="yes" xml:space="preserve">
          <source>In this section, you'll learn to prepare and upgrade an application with &lt;code&gt;ngUpgrade&lt;/code&gt;. The example app is &lt;a href=&quot;https://github.com/angular/angular-phonecat&quot;&gt;Angular PhoneCat&lt;/a&gt; from &lt;a href=&quot;https://docs.angularjs.org/tutorial&quot;&gt;the original AngularJS tutorial&lt;/a&gt;, which is where many of us began our Angular adventures. Now you'll see how to bring that application to the brave new world of Angular.</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;ngUpgrade&lt;/code&gt; 를 사용 하여 응용 프로그램을 준비하고 업그레이드하는 방법을 배웁니다 . 예제 응용 프로그램입니다 &lt;a href=&quot;https://github.com/angular/angular-phonecat&quot;&gt;각도 PhoneCat&lt;/a&gt; 에서 &lt;a href=&quot;https://docs.angularjs.org/tutorial&quot;&gt;원래 AngularJS와 튜토리얼&lt;/a&gt; 우리 중 많은 사람들이 우리의 각도 모험을 시작했다입니다. 이제이 응용 프로그램을 용감한 새로운 Angular 세계로 가져 오는 방법을 알아 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="269f51a639c36e1471d48fe5ff3480c172f854ea" translate="yes" xml:space="preserve">
          <source>In this section, you'll listen for the hero item click event and update the hero detail.</source>
          <target state="translated">이 섹션에서는 영웅 항목 클릭 이벤트를 듣고 영웅 세부 사항을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="ce0395b82a4ff81ea97cdb312448ce93adb39b78" translate="yes" xml:space="preserve">
          <source>In this section, you'll update the cart component to use the cart service to display the products in the cart.</source>
          <target state="translated">이 섹션에서는 장바구니 서비스를 사용하여 장바구니에 제품을 표시하도록 장바구니 구성 요소를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="403a238e3ee56ad0c6dd6b48f47e5f1604928707" translate="yes" xml:space="preserve">
          <source>In this section, you'll update the product details component to use the cart service. You'll add a &quot;Buy&quot; button to the product details view. When the &quot;Buy&quot; button is clicked, you'll use the cart service to add the current product to the cart.</source>
          <target state="translated">이 섹션에서는 카트 서비스를 사용하도록 제품 세부 정보 구성 요소를 업데이트합니다. 제품 세부 사항보기에 &quot;구매&quot;버튼을 추가합니다. &quot;구매&quot;버튼을 클릭하면 장바구니 서비스를 사용하여 현재 제품을 장바구니에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4679907f079a44d062477a8ebc33625407f5d2e5" translate="yes" xml:space="preserve">
          <source>In this section, you'll use the HTTP client to retrieve shipping prices from an external file.</source>
          <target state="translated">이 섹션에서는 HTTP 클라이언트를 사용하여 외부 파일에서 운송 가격을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="ab0be9ab1fa97bc67050d6fe01871e1e7b0d6047" translate="yes" xml:space="preserve">
          <source>In this step of the tutorial, you add a route that redirects the user to display the &lt;code&gt;/heroes-list&lt;/code&gt; component.</source>
          <target state="translated">자습서의이 단계에서는 &lt;code&gt;/heroes-list&lt;/code&gt; 구성 요소 를 표시하도록 사용자를 리디렉션하는 경로를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="9b61ea9c73f9814540ae97c3ffffaa25de48d7af" translate="yes" xml:space="preserve">
          <source>In this test suite, the &lt;em&gt;only&lt;/em&gt; provider of &lt;code&gt;UserService&lt;/code&gt; is the root testing module, so it is safe to call &lt;code&gt;TestBed.get()&lt;/code&gt; as follows:</source>
          <target state="translated">이 테스트 스위트에서 &lt;code&gt;UserService&lt;/code&gt; 의 &lt;em&gt;유일한&lt;/em&gt; 제공자 는 루트 테스트 모듈이므로 다음과 같이 &lt;code&gt;TestBed.get()&lt;/code&gt; 을 호출하는 것이 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="12fefbb22f8d1910173d08c25cf569bed05fd095" translate="yes" xml:space="preserve">
          <source>In this test suite, the &lt;em&gt;only&lt;/em&gt; provider of &lt;code&gt;UserService&lt;/code&gt; is the root testing module, so it is safe to call &lt;code&gt;TestBed.inject()&lt;/code&gt; as follows:</source>
          <target state="translated">이 테스트 스위트에서 &lt;code&gt;UserService&lt;/code&gt; 의 &lt;em&gt;유일한&lt;/em&gt; 공급자 는 루트 테스트 모듈이므로 다음과 같이 &lt;code&gt;TestBed.inject()&lt;/code&gt; 를 호출하는 것이 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="b4f452c4e432a31d79ddbadb986cc809d85ed173" translate="yes" xml:space="preserve">
          <source>In this tutorial you will build a dynamic form that presents a basic questionaire. You will build an online application for heroes seeking employment. The agency is constantly tinkering with the application process, but by using the dynamic form you can create the new forms on the fly without changing the application code.</source>
          <target state="translated">이 자습서에서는 기본 질문을 제공하는 동적 양식을 작성합니다. 취업을 원하는 영웅을위한 온라인 신청서를 작성합니다. 대행사는 지속적으로 신청 프로세스를 수정하고 있지만 동적 양식을 사용하면 응용 프로그램 코드를 변경하지 않고도 즉시 새 양식을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a18179f288ce84d2374dd0900930551cdf29b37" translate="yes" xml:space="preserve">
          <source>In this tutorial, &lt;code&gt;HeroService.getHeroes()&lt;/code&gt; will return an &lt;code&gt;Observable&lt;/code&gt; because it will eventually use the Angular &lt;code&gt;HttpClient.get&lt;/code&gt; method to fetch the heroes and &lt;a href=&quot;../guide/http&quot;&gt;&lt;code&gt;HttpClient.get()&lt;/code&gt; returns an &lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 튜토리얼에서는, &lt;code&gt;HeroService.getHeroes()&lt;/code&gt; 반환 &lt;code&gt;Observable&lt;/code&gt; 가 결국 각도 사용하기 때문에 &lt;code&gt;HttpClient.get&lt;/code&gt; 영웅을 가져 오는 방법과 &lt;a href=&quot;../guide/http&quot;&gt; &lt;code&gt;HttpClient.get()&lt;/code&gt; 반환 &lt;code&gt;Observable&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b96485397f1891bdc067a73371f08a27a24de8c0" translate="yes" xml:space="preserve">
          <source>In this tutorial, you build your own app from the ground up, providing experience with the typical development process, as well as an introduction to basic app-design concepts, tools, and terminology.</source>
          <target state="translated">이 자습서에서는 기본 앱 디자인 개념, 도구 및 용어에 대한 소개뿐만 아니라 일반적인 개발 프로세스에 대한 경험을 제공하여 처음부터 고유 한 앱을 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="25a44de4babd077d4a5b26746a125c8769135775" translate="yes" xml:space="preserve">
          <source>In this tutorial, you'll add the following data persistence features with help from Angular's &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 학습서에서는 Angular의 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 의 도움으로 다음 데이터 지속성 기능을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="06bb8951e44a68507e6e489ed686a8a717656ad3" translate="yes" xml:space="preserve">
          <source>In this tutorial, you'll create a &lt;code&gt;HeroService&lt;/code&gt; that all application classes can use to get heroes. Instead of creating that service with &lt;code&gt;new&lt;/code&gt;, you'll rely on Angular &lt;a href=&quot;../guide/dependency-injection&quot;&gt;&lt;em&gt;dependency injection&lt;/em&gt;&lt;/a&gt; to inject it into the &lt;code&gt;HeroesComponent&lt;/code&gt; constructor.</source>
          <target state="translated">이 학습서에서는 모든 애플리케이션 클래스가 영웅을 얻는 데 사용할 수 있는 &lt;code&gt;HeroService&lt;/code&gt; 를 작성합니다 . &lt;code&gt;new&lt;/code&gt; 로 해당 서비스를 생성하는 대신 Angular &lt;a href=&quot;../guide/dependency-injection&quot;&gt;&lt;em&gt;종속성 주입&lt;/em&gt;&lt;/a&gt; 을 사용하여 &lt;code&gt;HeroesComponent&lt;/code&gt; 생성자에 서비스 를 주입합니다 .</target>
        </trans-unit>
        <trans-unit id="1dbc39e7249eb4c5faa1c9f0d048d5c7f317eadd" translate="yes" xml:space="preserve">
          <source>In this tutorial, you'll create a &lt;code&gt;HeroService&lt;/code&gt; that all application classes can use to get heroes. Instead of creating that service with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new&quot;&gt;&lt;code&gt;new&lt;/code&gt; keyword&lt;/a&gt;, you'll rely on Angular &lt;a href=&quot;../guide/dependency-injection&quot;&gt;&lt;em&gt;dependency injection&lt;/em&gt;&lt;/a&gt; to inject it into the &lt;code&gt;HeroesComponent&lt;/code&gt; constructor.</source>
          <target state="translated">이 자습서에서는 모든 애플리케이션 클래스가 &lt;code&gt;HeroService&lt;/code&gt; 를 가져 오는 데 사용할 수 있는 HeroService 를 만듭니다 . &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new&quot;&gt; &lt;code&gt;new&lt;/code&gt; 키워드로&lt;/a&gt; 해당 서비스를 만드는 대신 Angular &lt;a href=&quot;../guide/dependency-injection&quot;&gt;&lt;em&gt;종속성 주입&lt;/em&gt;&lt;/a&gt; 을 사용하여 &lt;code&gt;HeroesComponent&lt;/code&gt; 생성자에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="e7cea9c259c2a7bf3c9e055e0e44722b8938e8d0" translate="yes" xml:space="preserve">
          <source>In this way you're using the Angular and JavaScript module systems &lt;em&gt;together&lt;/em&gt;. Although it's easy to confuse the two systems, which share the common vocabulary of &quot;imports&quot; and &quot;exports&quot;, you will become familiar with the different contexts in which they are used.</source>
          <target state="translated">이런 식으로 Angular 및 JavaScript 모듈 시스템을 &lt;em&gt;함께 사용&lt;/em&gt; 합니다. &quot;수입&quot;및 &quot;수출&quot;이라는 공통 어휘를 공유하는 두 시스템을 혼동하기는 쉽지만 사용되는 서로 다른 상황에 익숙해 질 것입니다.</target>
        </trans-unit>
        <trans-unit id="a21cab056614ba2cdbfb90d04db7c7d0479ad584" translate="yes" xml:space="preserve">
          <source>In two-way binding, a data property value flows to the input box from the component as with property binding. The user's changes also flow back to the component, resetting the property to the latest value, as with event binding.</source>
          <target state="translated">양방향 바인딩에서 데이터 속성 값은 속성 바인딩과 마찬가지로 구성 요소에서 입력 상자로 흐릅니다. 사용자의 변경 사항은 구성 요소로 다시 흘러 이벤트 바인딩과 마찬가지로 속성을 최신 값으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="31fa5a791d28202748d016367736fc9b97f5d0f5" translate="yes" xml:space="preserve">
          <source>In typical use, application code asks for the dependencies in the constructor and they are resolved by the &lt;code&gt;&lt;a href=&quot;injector&quot;&gt;Injector&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">일반적으로 응용 프로그램 코드는 생성자의 종속성을 요청하며 &lt;code&gt;&lt;a href=&quot;injector&quot;&gt;Injector&lt;/a&gt;&lt;/code&gt; 의해 해결됩니다 .</target>
        </trans-unit>
        <trans-unit id="57e2e8623c9d79c4da58de13b115b73b40ee0112" translate="yes" xml:space="preserve">
          <source>In v5, Angular replaced the &lt;code&gt;&lt;a href=&quot;../api/core/reflectiveinjector&quot;&gt;ReflectiveInjector&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;StaticInjector&lt;/code&gt;. The injector no longer requires the Reflect polyfill, reducing application size for most developers.</source>
          <target state="translated">v5에서 Angular는 &lt;code&gt;&lt;a href=&quot;../api/core/reflectiveinjector&quot;&gt;ReflectiveInjector&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;StaticInjector&lt;/code&gt; 로 대체했습니다 . 인젝터에는 더 이상 Reflect 폴리 필이 필요하지 않으므로 대부분의 개발자의 응용 프로그램 크기가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="a84fd42297b1dcb30b0f64f06976c4d1727bfa6a" translate="yes" xml:space="preserve">
          <source>In version 4.3, Angular introduced new number, date, and currency pipes that increase standardization across browsers and eliminate the need for i18n polyfills. These pipes use the Unicode Common Locale Data Repository (CLDR) instead of the JS Intl API to provide extensive locale support.</source>
          <target state="translated">4.3 버전에서 Angular는 브라우저에서 표준화를 높이고 i18n 폴리 필이 필요없는 새로운 번호, 날짜 및 통화 파이프를 도입했습니다. 이 파이프는 JS Intl API 대신 유니 코드 공통 로케일 데이터 저장소 (CLDR)를 사용하여 광범위한 로케일 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="71d97d3019c4bcc2733ae13ec2df5b3eb65a683b" translate="yes" xml:space="preserve">
          <source>In version 5 and later, the compiler automatically performs this rewriting while emitting the &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">버전 5 이상에서 컴파일러는 &lt;code&gt;.js&lt;/code&gt; 파일 을 내보내는 동안 자동으로이 재 작성을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="c45bfe7a0bc278e7de4469f4b336dda62d4667b6" translate="yes" xml:space="preserve">
          <source>In version 5.0.0, Angular updated its standard pipes to use the CLRD implementation. At that time, Angular also added &lt;a href=&quot;../api/common/deprecatedi18npipesmodule&quot;&gt;&lt;code&gt;DeprecatedI18NPipesModule&lt;/code&gt;&lt;/a&gt; and related APIs to provide limited-time access to the old behavior. If you need to use these &lt;code&gt;Deprecated*&lt;/code&gt; pipes, see &lt;a href=&quot;https://github.com/angular/angular/blob/master/CHANGELOG.md#i18n-pipes&quot;&gt;Angular change log&lt;/a&gt; and the &lt;a href=&quot;https://docs.google.com/spreadsheets/d/12iygt-_cakNP1VO7MV9g4lq9NsxVWG4tSfc98HpHb0k/edit#gid=0&quot;&gt;Date Formats mappings&lt;/a&gt;.</source>
          <target state="translated">버전 5.0.0에서 Angular는 CLRD 구현을 사용하도록 표준 파이프를 업데이트했습니다. 당시 Angular는 &lt;a href=&quot;../api/common/deprecatedi18npipesmodule&quot;&gt; &lt;code&gt;DeprecatedI18NPipesModule&lt;/code&gt; &lt;/a&gt; 및 관련 API를 추가 하여 이전 동작에 대한 제한된 시간 액세스를 제공합니다. 이러한 &lt;code&gt;Deprecated*&lt;/code&gt; 파이프 를 사용해야하는 경우 &lt;a href=&quot;https://github.com/angular/angular/blob/master/CHANGELOG.md#i18n-pipes&quot;&gt;각도 변경 로그&lt;/a&gt; 및 &lt;a href=&quot;https://docs.google.com/spreadsheets/d/12iygt-_cakNP1VO7MV9g4lq9NsxVWG4tSfc98HpHb0k/edit#gid=0&quot;&gt;날짜 형식 매핑을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9241b9e01cd99078b4ff06f46cefe6357b7cf80a" translate="yes" xml:space="preserve">
          <source>In version 8, the string syntax for the &lt;a href=&quot;../api/router/loadchildren&quot;&gt;&lt;code&gt;loadChildren&lt;/code&gt;&lt;/a&gt; route specification was deprecated, in favor of new syntax that uses &lt;code&gt;import()&lt;/code&gt; syntax.</source>
          <target state="translated">버전 8에서는 &lt;a href=&quot;../api/router/loadchildren&quot;&gt; &lt;code&gt;loadChildren&lt;/code&gt; &lt;/a&gt; 라우트 스펙 의 문자열 구문 이 더 이상 사용되지 않으며 &lt;code&gt;import()&lt;/code&gt; 구문 을 사용하는 새 구문을 선호 합니다.</target>
        </trans-unit>
        <trans-unit id="4f9ab07b83f4d06de00ebcc1eb973f38d10ad222" translate="yes" xml:space="preserve">
          <source>In version 9, Ivy is the default. For compatibility with current workflows during the update process, you can choose to opt out of Ivy and continue using the previous compiler, View Engine.</source>
          <target state="translated">버전 9에서는 Ivy가 기본값입니다. 업데이트 프로세스 중 현재 워크 플로와의 호환성을 위해 Ivy를 옵트 아웃하고 이전 컴파일러 인 View Engine을 계속 사용하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9edf1a71374f3d46fc3414dc47fc6036e0aaa971" translate="yes" xml:space="preserve">
          <source>In version 9, the server builder which is used for &lt;a href=&quot;app-shell&quot;&gt;App shell&lt;/a&gt; and &lt;a href=&quot;universal&quot;&gt;Angular Universal&lt;/a&gt; has the &lt;code&gt;bundleDependencies&lt;/code&gt; option enabled by default. If you opt-out of bundling dependencies you will need to run the standalone Angular compatibility compiler (&lt;code&gt;ngcc&lt;/code&gt;). This is needed because otherwise Node will be unable to resolve the Ivy version of the packages.</source>
          <target state="translated">버전 9에서 &lt;a href=&quot;app-shell&quot;&gt;앱 셸&lt;/a&gt; 및 &lt;a href=&quot;universal&quot;&gt;Angular Universal에&lt;/a&gt; 사용되는 서버 빌더 에는 기본적으로 &lt;code&gt;bundleDependencies&lt;/code&gt; 옵션이 활성화되어 있습니다. 종속성 번들링을 거부하는 경우 독립형 Angular 호환성 컴파일러 ( &lt;code&gt;ngcc&lt;/code&gt; ) 를 실행해야합니다 . 그렇지 않으면 Node가 패키지의 Ivy 버전을 확인할 수 없기 때문에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="65b1e0f69125d604941dd3273cdaf553c34f079e" translate="yes" xml:space="preserve">
          <source>In your Angular application, you need a component as a placeholder for your AngularJS content. This component uses the service you create to load and bootstrap your AngularJS app after the component is initialized.</source>
          <target state="translated">Angular 애플리케이션에는 AngularJS 컨텐츠의 자리 표시 자로 컴포넌트가 필요합니다. 이 구성 요소는 생성 한 서비스를 사용하여 구성 요소가 초기화 된 후 AngularJS 앱을로드하고 부트 스트랩합니다.</target>
        </trans-unit>
        <trans-unit id="ca7e1be139d5918a6ba13a88e83f886ca1299b5f" translate="yes" xml:space="preserve">
          <source>In your StackBlitz project, make sure you have forked or saved your project.</source>
          <target state="translated">StackBlitz 프로젝트에서 프로젝트를 분기 또는 저장했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9e38ffcf83f81a498acb2fef8ccde38da9e38905" translate="yes" xml:space="preserve">
          <source>In your apps, import from the library by name:</source>
          <target state="translated">앱에서 이름으로 라이브러리에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="fbadbb5b6473967b5312043c7bbc97ef238f1be3" translate="yes" xml:space="preserve">
          <source>In your browser, open &lt;a href=&quot;http://localhost:4200/&quot;&gt;http://localhost:4200/&lt;/a&gt; to see the new app run. When you use the &lt;a href=&quot;https://angular.io/cli/serve&quot;&gt;ng serve&lt;/a&gt; command to build an app and serve it locally, the server automatically rebuilds the app and reloads the page when you change any of the source files.</source>
          <target state="translated">브라우저에서 &lt;a href=&quot;http://localhost:4200/&quot;&gt;http : // localhost : 4200 /&lt;/a&gt; 을 열어 새 앱 실행을 확인하십시오. 당신이 사용하는 경우 &lt;a href=&quot;https://angular.io/cli/serve&quot;&gt;NG를 제공&lt;/a&gt; 응용 프로그램을 구축하는 명령을 로컬에 서비스를 제공, 서버는 자동으로 응용 프로그램 및 다시로드 소스 파일을 변경 페이지를 다시 작성합니다.</target>
        </trans-unit>
        <trans-unit id="34c360dd0f8faf40b5e6d4e59b4cc7a4861f4594" translate="yes" xml:space="preserve">
          <source>In your code editor, locate the file, &lt;code&gt;crisis-list.component.html&lt;/code&gt; and replace the placeholder content with the following HTML.</source>
          <target state="translated">코드 편집기에서 파일 ( &lt;code&gt;crisis-list.component.html&lt;/code&gt; )을 찾고 자리 표시 자 내용을 다음 HTML 로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="253ec15e24309b01fdf9d235fb65adb71c186cd2" translate="yes" xml:space="preserve">
          <source>In your code editor, locate the file, &lt;code&gt;heroes-list.component.html&lt;/code&gt; and replace the placeholder content with the following HTML.</source>
          <target state="translated">코드 편집기에서 &lt;code&gt;heroes-list.component.html&lt;/code&gt; 파일을 찾고 자리 표시 자 콘텐츠를 다음 HTML 로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="8ec4a6d13d43ea7dd54f7c5d72944d8815af444e" translate="yes" xml:space="preserve">
          <source>In your code editor, open the file, &lt;code&gt;app.component.html&lt;/code&gt; and replace its contents with the following HTML.</source>
          <target state="translated">코드 편집기에서 &lt;code&gt;app.component.html&lt;/code&gt; 파일을 열고 해당 내용을 다음 HTML로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="f21b76242519b87008bb820433618b31f09a3a4a" translate="yes" xml:space="preserve">
          <source>In your editor's user preferences (&lt;code&gt;Cmd+,&lt;/code&gt; or &lt;code&gt;Ctrl+,&lt;/code&gt;), add the following:</source>
          <target state="translated">편집기의 사용자 환경 설정 ( &lt;code&gt;Cmd+,&lt;/code&gt; 또는 &lt;code&gt;Ctrl+,&lt;/code&gt; )에서 다음을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="727a7c9f30cdfd8d4dd3c2209d749ac7719e0931" translate="yes" xml:space="preserve">
          <source>In your guard class, implement the guard you want to use. The following example uses &lt;code&gt;&lt;a href=&quot;../api/router/canactivate&quot;&gt;CanActivate&lt;/a&gt;&lt;/code&gt; to guard the route.</source>
          <target state="translated">가드 클래스에서 사용하려는 가드를 구현하십시오. 다음 예제에서는 &lt;code&gt;&lt;a href=&quot;../api/router/canactivate&quot;&gt;CanActivate&lt;/a&gt;&lt;/code&gt; 를 사용 하여 경로를 보호합니다.</target>
        </trans-unit>
        <trans-unit id="e9d09b0521b2a8f8f641dc6031d35a9df0c68728" translate="yes" xml:space="preserve">
          <source>In your library project's &lt;code&gt;package.json&lt;/code&gt; file, add a &quot;schematics&quot; entry with the path to your schema file. The Angular CLI uses this entry to find named schematics in your collection when it runs commands.</source>
          <target state="translated">라이브러리 프로젝트의 &lt;code&gt;package.json&lt;/code&gt; 파일에서 스키마 파일의 경로와 함께 &quot;스키마&quot;항목을 추가하십시오. Angular CLI는이 항목을 사용하여 명령을 실행할 때 컬렉션에서 명명 된 회로도를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="3b08d5f94915a160ca1817acb5c6f70371ec0b65" translate="yes" xml:space="preserve">
          <source>In your library's root folder, create a &lt;code&gt;schematics/&lt;/code&gt; folder.</source>
          <target state="translated">라이브러리의 루트 폴더에서 &lt;code&gt;schematics/&lt;/code&gt; 폴더를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="1f1c44296526073034fe28dcedd37942e5286e42" translate="yes" xml:space="preserve">
          <source>In your new CLI generated app, replace the &lt;code&gt;/src&lt;/code&gt; folder with the one from your &lt;code&gt;StackBlitz&lt;/code&gt; download, and then perform a build.</source>
          <target state="translated">새 CLI 생성 앱에서 &lt;code&gt;/src&lt;/code&gt; 폴더를 &lt;code&gt;StackBlitz&lt;/code&gt; 다운로드 의 폴더로 바꾼 다음 빌드를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="196ec867c2435e7c91db397d1f83ee4ef616a06a" translate="yes" xml:space="preserve">
          <source>In your routing NgModule, re-export the &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; as a convenience so that components of the companion NgModule have access to router directives such as &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;RouterOutlet&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">라우팅 NgModule 에서 동반 NgModule의 구성 요소가 &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;RouterOutlet&lt;/a&gt;&lt;/code&gt; 과 같은 라우터 지시문에 액세스 할 수 있도록 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; 을 편의상 다시 내보내십시오 .</target>
        </trans-unit>
        <trans-unit id="30cfc944e0b921f322a32900e990ff35bbccfcee" translate="yes" xml:space="preserve">
          <source>In your routing module, use the appropriate property in your &lt;code&gt;routes&lt;/code&gt; configuration. Here, &lt;code&gt;canActivate&lt;/code&gt; tells the router to mediate navigation to this particular route.</source>
          <target state="translated">라우팅 모듈에서 &lt;code&gt;routes&lt;/code&gt; 구성 에 적절한 속성을 사용합니다 . 여기서 &lt;code&gt;canActivate&lt;/code&gt; 는이 특정 경로에 대한 탐색을 중재하도록 라우터에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="399353050f6f971c4351995b83ecf4b94005b8cf" translate="yes" xml:space="preserve">
          <source>In your service, import the following router members, implement &lt;code&gt;&lt;a href=&quot;../api/router/resolve&quot;&gt;Resolve&lt;/a&gt;&lt;/code&gt;, and inject the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; service:</source>
          <target state="translated">서비스에서 다음 라우터 구성원을 가져오고 &lt;code&gt;&lt;a href=&quot;../api/router/resolve&quot;&gt;Resolve&lt;/a&gt;&lt;/code&gt; 를 구현 하고 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 서비스를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="850625969ea40ebbce6399197743447eb486664b" translate="yes" xml:space="preserve">
          <source>In-app Routing and Navigation</source>
          <target state="translated">인앱 라우팅 및 탐색</target>
        </trans-unit>
        <trans-unit id="b08704b5f05695c4e9631bc892eb0365d32b461a" translate="yes" xml:space="preserve">
          <source>In-app navigation: routing to views</source>
          <target state="translated">인앱 탐색 :보기로 라우팅</target>
        </trans-unit>
        <trans-unit id="ce97d1ac42d70ee94d614eb0f89cf54d2d267038" translate="yes" xml:space="preserve">
          <source>Include an installation schematic so that &lt;code&gt;ng add&lt;/code&gt; can add your library to a project.</source>
          <target state="translated">&lt;code&gt;ng add&lt;/code&gt; 가 라이브러리를 프로젝트에 추가 할 수 있도록 설치 회로도를 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="08720542b91aacc8813c92e6ceea960b5ca4fe91" translate="yes" xml:space="preserve">
          <source>Include an update schematic so that &lt;code&gt;ng &lt;a href=&quot;../api/forms/ngmodel#update&quot;&gt;update&lt;/a&gt;&lt;/code&gt; can update your library&amp;rsquo;s dependencies and provide migrations for breaking changes in new releases.</source>
          <target state="translated">&lt;code&gt;ng &lt;a href=&quot;../api/forms/ngmodel#update&quot;&gt;update&lt;/a&gt;&lt;/code&gt; 가 라이브러리의 종속성을 업데이트하고 새 릴리스의 변경 사항을 위반하기위한 마이그레이션을 제공 할 수 있도록 업데이트 회로도를 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="6707611a40ef57bc0b4bbd844cd17854567e9ab1" translate="yes" xml:space="preserve">
          <source>Include an update schematic so that &lt;code&gt;ng update&lt;/code&gt; can update your library&amp;rsquo;s dependencies and provide migrations for breaking changes in new releases.</source>
          <target state="translated">&lt;code&gt;ng update&lt;/code&gt; 가 라이브러리의 종속성을 업데이트하고 새 릴리스의 주요 변경 사항에 대한 마이그레이션을 제공 할 수 있도록 업데이트 회로도를 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="282924231e939d92199d1eca77627325f87ee961" translate="yes" xml:space="preserve">
          <source>Include generation schematics in your library so that &lt;code&gt;ng generate&lt;/code&gt; can scaffold your defined artifacts (components, services, tests, and so on) in a project.</source>
          <target state="translated">생성 &lt;code&gt;ng generate&lt;/code&gt; 가 프로젝트에서 정의 된 아티팩트 (구성 요소, 서비스, 테스트 등)를 스캐 폴드 할 수 있도록 라이브러리에 생성 회로도를 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="4bb4ec7c27202bd27c6403b4450d02067c520d2b" translate="yes" xml:space="preserve">
          <source>Include required infrastructure such as the &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; 과 같은 필수 인프라를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="ec6e7b9747e35ebc5f30dc0a428e02bb8ff75e90" translate="yes" xml:space="preserve">
          <source>Include the service in the &lt;code&gt;AppModule&lt;/code&gt; or in a module that is only imported by the &lt;code&gt;AppModule&lt;/code&gt;</source>
          <target state="translated">에서 서비스 포함 &lt;code&gt;AppModule&lt;/code&gt; 만을 수입되거나 모듈 &lt;code&gt;AppModule&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="8aba49aa4e1a02e3008081bffbd5efbadc7cf869" translate="yes" xml:space="preserve">
          <source>Include your pipe in the &lt;code&gt;declarations&lt;/code&gt; field of the &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; metadata in order for it to be available to a template. See the &lt;code&gt;app.module.ts&lt;/code&gt; file in the example app (live example). For details, see &lt;a href=&quot;ngmodules&quot;&gt;NgModules&lt;/a&gt;.</source>
          <target state="translated">파이프를 템플릿에서 사용할 수 있도록 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 메타 데이터 의 &lt;code&gt;declarations&lt;/code&gt; 필드에 포함합니다 . 예제 앱 (실제 예제) 의 &lt;code&gt;app.module.ts&lt;/code&gt; 파일을 참조하십시오 . 자세한 내용은 &lt;a href=&quot;ngmodules&quot;&gt;NgModules를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="497e47d580938603d6e2f90429b6ca666fccc44c" translate="yes" xml:space="preserve">
          <source>Includes &lt;a href=&quot;../api/core/provider&quot;&gt;providers&lt;/a&gt; and methods to compile and run the app on the client using the &lt;a href=&quot;aot-compiler&quot;&gt;JIT compiler&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;aot-compiler&quot;&gt;JIT 컴파일러를&lt;/a&gt; 사용하여 클라이언트에서 앱을 컴파일하고 실행하는 &lt;a href=&quot;../api/core/provider&quot;&gt;제공자&lt;/a&gt; 및 메소드를 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="0ad6c20b67c9ef5c8bae321419d3e7b82dfca42c" translate="yes" xml:space="preserve">
          <source>Includes a link to add the &lt;code&gt;manifest.json&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;manifest.json&lt;/code&gt; 파일 을 추가하는 링크를 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="ec7fab0bf1d7fbc129b6a52468ce43ec265c54c5" translate="yes" xml:space="preserve">
          <source>Includes a link to add the &lt;code&gt;manifest.webmanifest&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;manifest.webmanifest&lt;/code&gt; 파일 을 추가하기위한 링크가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ede5524d447137c6007fc3872dcd98681351a7c8" translate="yes" xml:space="preserve">
          <source>Includes testability features, typed request and response objects, request and response interception, observable APIs, and streamlined error handling.</source>
          <target state="translated">테스트 가능성 기능, 유형이 지정된 요청 및 응답 객체, 요청 및 응답 차단, 관찰 가능한 API 및 간소화 된 오류 처리가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9b0793ed118cccc9349319604ac83b01285a42ad" translate="yes" xml:space="preserve">
          <source>Including a route parameter (passing the Hero &lt;code&gt;id&lt;/code&gt; while routing to the &quot;Hero Detail&quot;).</source>
          <target state="translated">경로 매개 변수 포함 ( &quot;영웅 세부 사항&quot;으로 라우팅하는 동안 Hero &lt;code&gt;id&lt;/code&gt; 를 전달 함)</target>
        </trans-unit>
        <trans-unit id="98e74adf3229ab63477c62be5d7146a7e849046e" translate="yes" xml:space="preserve">
          <source>Inclusive Components</source>
          <target state="translated">포함 된 구성 요소</target>
        </trans-unit>
        <trans-unit id="7099fad44ed7e3e008c2391fbea8ece07dcd4d22" translate="yes" xml:space="preserve">
          <source>Increased security with native &lt;a href=&quot;https://web.dev/trusted-types/&quot;&gt;Trusted Types&lt;/a&gt; in Angular</source>
          <target state="translated">Angular의 기본 &lt;a href=&quot;https://web.dev/trusted-types/&quot;&gt;신뢰할 수있는 유형&lt;/a&gt; 으로 보안 강화</target>
        </trans-unit>
        <trans-unit id="d686caf322ed32f4566b224dd18bea8a4089d16d" translate="yes" xml:space="preserve">
          <source>Increases the number of pending request</source>
          <target state="translated">보류중인 요청 수 증가</target>
        </trans-unit>
        <trans-unit id="a1d5d5a9b2dbc095f06632faa7f8d2ec706001b6" translate="yes" xml:space="preserve">
          <source>Incremental builds can be run as a background process in your dev environment. To take advantage of this feature add the &lt;code&gt;--watch&lt;/code&gt; flag to the build command:</source>
          <target state="translated">증분 빌드는 개발 환경에서 백그라운드 프로세스로 실행될 수 있습니다. 이 기능을 활용하려면 &lt;code&gt;--watch&lt;/code&gt; 플래그를 build 명령에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="57a507dedf4559e07065957eca1175bc03ba365d" translate="yes" xml:space="preserve">
          <source>Index in the array to insert the control</source>
          <target state="translated">컨트롤을 삽입 할 배열의 인덱스</target>
        </trans-unit>
        <trans-unit id="ee3ba6ae75b8a4c10a8036ec35138251054f277c" translate="yes" xml:space="preserve">
          <source>Index in the array to remove the control</source>
          <target state="translated">컨트롤을 제거하기위한 배열의 인덱스</target>
        </trans-unit>
        <trans-unit id="66e18f43642f8990d457a1934bd052577f94b398" translate="yes" xml:space="preserve">
          <source>Index in the array to replace the control</source>
          <target state="translated">컨트롤을 대체 할 배열의 인덱스</target>
        </trans-unit>
        <trans-unit id="5f69ec55403ddc6ac8d13721d541e09482a7940b" translate="yes" xml:space="preserve">
          <source>Index in the array to retrieve the control</source>
          <target state="translated">컨트롤을 검색 할 배열의 인덱스</target>
        </trans-unit>
        <trans-unit id="6906761e076d1a610413de4171c8d5dea67905df" translate="yes" xml:space="preserve">
          <source>Indicates if the provider is a multi-provider or a regular provider.</source>
          <target state="translated">공급자가 다중 공급자인지 일반 공급자인지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a226b2f1a87e5950fc108a1472b50623b2217451" translate="yes" xml:space="preserve">
          <source>Indicates that the result of a &lt;a href=&quot;core/pipe&quot;&gt;&lt;code&gt;Pipe&lt;/code&gt;&lt;/a&gt; transformation has changed even though the reference has not changed.</source>
          <target state="translated">참조가 변경되지 않은 경우에도 &lt;a href=&quot;core/pipe&quot;&gt; &lt;code&gt;Pipe&lt;/code&gt; &lt;/a&gt; 변환 결과 가 변경 되었음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ef1f129438ed53e3939954fd8d48915df19e8c7b" translate="yes" xml:space="preserve">
          <source>Indicates that the result of a &lt;a href=&quot;pipe&quot;&gt;&lt;code&gt;Pipe&lt;/code&gt;&lt;/a&gt; transformation has changed even though the reference has not changed.</source>
          <target state="translated">참조가 변경되지 않은 경우에도 &lt;a href=&quot;pipe&quot;&gt; &lt;code&gt;Pipe&lt;/code&gt; &lt;/a&gt; 변환 결과 가 변경 되었음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="73f7d541bd341c43c84d9404f23680ea85ea9d12" translate="yes" xml:space="preserve">
          <source>Indicates when a location is initialized.</source>
          <target state="translated">위치가 초기화되는시기를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2339b8ad3625abec50c5fec9ccfe1b4c0adb5b6e" translate="yes" xml:space="preserve">
          <source>Indonesian</source>
          <target state="translated">Indonesian</target>
        </trans-unit>
        <trans-unit id="e30c5310c8d6f412a378028007bd3332f3ddf51a" translate="yes" xml:space="preserve">
          <source>Infers template context types where configured (for example, allowing correct type-checking of &lt;code&gt;NgFor&lt;/code&gt;).</source>
          <target state="translated">구성된 경우 템플릿 컨텍스트 유형을 유추합니다 (예 : &lt;code&gt;NgFor&lt;/code&gt; 의 올바른 유형 검사 허용 ).</target>
        </trans-unit>
        <trans-unit id="ff0a8f1a1348503cfadffc6b2cad445ba983c4ab" translate="yes" xml:space="preserve">
          <source>Infers the correct type of &lt;code&gt;$event&lt;/code&gt; in component/directive, DOM, and animation event bindings.</source>
          <target state="translated">구성 요소 / 지시문, DOM 및 애니메이션 이벤트 바인딩에서 올바른 유형의 &lt;code&gt;$event&lt;/code&gt; 를 유추합니다 .</target>
        </trans-unit>
        <trans-unit id="cfaf4d7a931a957a0518549794c679bcfefd25f7" translate="yes" xml:space="preserve">
          <source>Infers the correct type of components/directives, including generics.</source>
          <target state="translated">제네릭을 포함하여 올바른 유형의 구성 요소 / 지시문을 추론합니다.</target>
        </trans-unit>
        <trans-unit id="0518dc3b51a7ad378102d238e804098cc7c8a2c5" translate="yes" xml:space="preserve">
          <source>Infers the correct type of local references to DOM elements, based on the tag name (for example, the type that &lt;code&gt;document.createElement&lt;/code&gt; would return for that tag).</source>
          <target state="translated">태그 이름 (예 : &lt;code&gt;document.createElement&lt;/code&gt; 가 해당 태그에 대해 반환 하는 유형)을 기반으로 DOM 요소에 대한 올바른 유형의 로컬 참조를 유추합니다 .</target>
        </trans-unit>
        <trans-unit id="fe8a63fb884b51a65ffbab786ee171700ba71dca" translate="yes" xml:space="preserve">
          <source>Infinity, can be used with plus and minus. Example: &amp;infin;, +&amp;infin;, -&amp;infin;</source>
          <target state="translated">무한대는 플러스 및 마이너스와 함께 사용할 수 있습니다. 예 : &amp;infin;, + &amp;infin;, -&amp;infin;</target>
        </trans-unit>
        <trans-unit id="71b2d6934c04d0811bdb26319c33abe4a79bac50" translate="yes" xml:space="preserve">
          <source>Information about a navigation operation. Retrieve the most recent navigation object with the &lt;a href=&quot;router#getcurrentnavigation&quot;&gt;Router.getCurrentNavigation() method&lt;/a&gt; .</source>
          <target state="translated">탐색 작업에 대한 정보입니다. &lt;a href=&quot;router#getcurrentnavigation&quot;&gt;Router.getCurrentNavigation () 메서드를&lt;/a&gt; 사용하여 최신 탐색 객체를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="b3dedb476a249b2a3aeb52da6fa5d5b4c4e0f38c" translate="yes" xml:space="preserve">
          <source>Information about a navigation operation. Retrieve the most recent navigation object with the &lt;a href=&quot;router/router#getcurrentnavigation&quot;&gt;Router.getCurrentNavigation() method&lt;/a&gt; .</source>
          <target state="translated">탐색 작업에 대한 정보입니다. &lt;a href=&quot;router/router#getcurrentnavigation&quot;&gt;Router.getCurrentNavigation () 메서드를&lt;/a&gt; 사용하여 최신 탐색 객체를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="17e8aa425129cc14c2dcfed09c7bb96d8d9d34ce" translate="yes" xml:space="preserve">
          <source>Information about a navigation operation. Retrieve the most recent navigation object with the &lt;code&gt;router.getCurrentNavigation()&lt;/code&gt; method.</source>
          <target state="translated">탐색 조작에 대한 정보 &lt;code&gt;router.getCurrentNavigation()&lt;/code&gt; 메소드를 사용하여 가장 최근의 탐색 오브젝트를 검색하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d8911a7c835165927ce0fe2f98e8c5ee99367a3" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;directive&quot;&gt;Directive&lt;/a&gt; decorator</source>
          <target state="translated">&lt;a href=&quot;directive&quot;&gt;지시어&lt;/a&gt; 데코레이터 에서 상속</target>
        </trans-unit>
        <trans-unit id="dcd77ef0b804e5064dd803f77b8a828a13037e8e" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;code&gt;&lt;a href=&quot;abstractcontroldirective&quot;&gt;AbstractControlDirective&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;abstractcontroldirective&quot;&gt;AbstractControlDirective&lt;/a&gt;&lt;/code&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="b2e16c0ede4e151e344b0a7018a817ca81bff170" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;code&gt;&lt;a href=&quot;abstractformgroupdirective&quot;&gt;AbstractFormGroupDirective&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;abstractformgroupdirective&quot;&gt;AbstractFormGroupDirective&lt;/a&gt;&lt;/code&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="7b0e6fa8afe9fe66b319e4ffce4d5b04030afdd1" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;code&gt;&lt;a href=&quot;controlcontainer&quot;&gt;ControlContainer&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;controlcontainer&quot;&gt;ControlContainer&lt;/a&gt;&lt;/code&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="9aa6e1c6b872fa792c0cda39792e0c2d17339088" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;code&gt;&lt;a href=&quot;ngclassbase&quot;&gt;NgClassBase&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ngclassbase&quot;&gt;NgClassBase&lt;/a&gt;&lt;/code&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="0b58cc13a8f7a9113f65b285338c3c8ecc3a76ce" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;code&gt;&lt;a href=&quot;ngcontrol&quot;&gt;NgControl&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ngcontrol&quot;&gt;NgControl&lt;/a&gt;&lt;/code&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="9240846abcc88d5bc03f7b8b3ea9b93dc9d94d85" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;code&gt;&lt;a href=&quot;ngstylebase&quot;&gt;NgStyleBase&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ngstylebase&quot;&gt;NgStyleBase&lt;/a&gt;&lt;/code&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="77f97d1404eeb944941dce572340411b8745a17f" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;code&gt;&lt;a href=&quot;requiredvalidator&quot;&gt;RequiredValidator&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;requiredvalidator&quot;&gt;RequiredValidator&lt;/a&gt;&lt;/code&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="20a9fca8990fcc98b2b18559e85df597fd3a6518" translate="yes" xml:space="preserve">
          <source>Initial Tour of Heroes example application for beginning the tutorial. For more information, see &lt;a href=&quot;../tutorial/toh-pt0&quot;&gt;Create a new project&lt;/a&gt;.</source>
          <target state="translated">튜토리얼을 시작하기위한 Initial Tour of Heroes 예제 응용 프로그램입니다. 자세한 내용 &lt;a href=&quot;../tutorial/toh-pt0&quot;&gt;은 새 프로젝트 만들기를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f370e247cdb302508a8b07274aac235758f135a4" translate="yes" xml:space="preserve">
          <source>Initial git repository commit information.</source>
          <target state="translated">초기 자식 저장소 커밋 정보.</target>
        </trans-unit>
        <trans-unit id="571af2d87fcb6ae228307d5bca556e15b485b55f" translate="yes" xml:space="preserve">
          <source>Initial load</source>
          <target state="translated">초기 하중</target>
        </trans-unit>
        <trans-unit id="9295a6b527e07161cef57e1c1ccd71b70c89f70d" translate="yes" xml:space="preserve">
          <source>InitialNavigation</source>
          <target state="translated">InitialNavigation</target>
        </trans-unit>
        <trans-unit id="67c3a59c8fd61dc6486a966bfc500708124ba415" translate="yes" xml:space="preserve">
          <source>Initialize a control as disabled</source>
          <target state="translated">컨트롤을 비활성화로 초기화</target>
        </trans-unit>
        <trans-unit id="4eebcc10a8e490cd62529c5e8e054755f7da1680" translate="yes" xml:space="preserve">
          <source>Initialize the AbstractControl instance.</source>
          <target state="translated">AbstractControl 인스턴스를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="2d9f5b3d7a71b9315bdd35eb72e500c9bc28970b" translate="yes" xml:space="preserve">
          <source>Initialize the directive or component after Angular first displays the data-bound properties and sets the directive or component's input properties. See details in &lt;a href=&quot;lifecycle-hooks#oninit&quot;&gt;Initializing a component or directive&lt;/a&gt; in this document.</source>
          <target state="translated">Angular가 데이터 바인딩 된 속성을 먼저 표시하고 지시문 또는 구성 요소의 입력 속성을 설정 한 후 지시문 또는 구성 요소를 초기화합니다. 이 문서 &lt;a href=&quot;lifecycle-hooks#oninit&quot;&gt;의 구성 요소 또는 지시문 초기화&lt;/a&gt; 에서 자세한 내용을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9dc3a6c3f424e12509055f6982dc7843c5ee3f57" translate="yes" xml:space="preserve">
          <source>Initialize the directive/component after Angular first displays the data-bound properties and sets the directive/component's input properties.</source>
          <target state="translated">Angular가 먼저 데이터 바인딩 된 속성을 표시하고 지시문 / 구성 요소의 입력 속성을 설정 한 후 지시문 / 구성 요소를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="a95372f851a37c7ccab21bff14bd44def255e637" translate="yes" xml:space="preserve">
          <source>Initialize the environment for testing with a compiler factory, a PlatformRef, and an angular module. These are common to every test in the suite.</source>
          <target state="translated">컴파일러 팩토리, PlatformRef 및 각도 모듈로 테스트 할 환경을 초기화하십시오. 이들은 제품군의 모든 테스트에 공통입니다.</target>
        </trans-unit>
        <trans-unit id="0c3674ebd78fe94c6d9fa6c8cfe3b72434b691fc" translate="yes" xml:space="preserve">
          <source>Initialize the testing environment for the entire test run.</source>
          <target state="translated">전체 테스트 실행에 대한 테스트 환경을 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="aa1459b074a250001c22df0a6ff4d2a090a6bddc" translate="yes" xml:space="preserve">
          <source>Initializes a constructor instance.</source>
          <target state="translated">생성자 인스턴스를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="c9db2ae584e270a26cd5d19e6158467ad592c103" translate="yes" xml:space="preserve">
          <source>Initializes an instance of the event-manager service.</source>
          <target state="translated">이벤트 관리자 서비스의 인스턴스를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="754ef6b0761c3646e19a5a7b638f7d2b30efe518" translate="yes" xml:space="preserve">
          <source>Initializes that property with the corresponding argument when creating an instance of the class.</source>
          <target state="translated">클래스의 인스턴스를 만들 때 해당 인수로 해당 속성을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="2699534e66ed5e13056581917d48556f49da8381" translate="yes" xml:space="preserve">
          <source>Initializes the animation.</source>
          <target state="translated">애니메이션을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="d7bc389cad16303b5a27f5b7ab489c3a1a9d4378" translate="yes" xml:space="preserve">
          <source>Initializes the control with an initial state value, or with an object that contains both a value and a disabled status.</source>
          <target state="translated">초기 상태 값 또는 값과 비활성화 된 상태가 모두 포함 된 개체를 사용하여 컨트롤을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="45131dcddc1529f6f3b00cd78ce30c35d914b381" translate="yes" xml:space="preserve">
          <source>Initializes the control with an initial value, or an object that defines the initial value and disabled state.</source>
          <target state="translated">초기 값 또는 초기 값과 비활성화 된 상태를 정의하는 개체를 사용하여 컨트롤을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="37ee460935fc0f5ed51a8e919d18a3056e25d96f" translate="yes" xml:space="preserve">
          <source>Initializes the given channel and attaches a new &lt;a href=&quot;clientmessagebroker&quot;&gt;&lt;code&gt;ClientMessageBroker&lt;/code&gt;&lt;/a&gt; to it.</source>
          <target state="translated">주어진 채널을 초기화하고 새로운 &lt;a href=&quot;clientmessagebroker&quot;&gt; &lt;code&gt;ClientMessageBroker&lt;/code&gt; &lt;/a&gt; 를 연결 합니다.</target>
        </trans-unit>
        <trans-unit id="642b54430a0eb721573dc494e1c4d52db3a4409f" translate="yes" xml:space="preserve">
          <source>Initializes the given channel and attaches a new &lt;a href=&quot;servicemessagebroker&quot;&gt;&lt;code&gt;ServiceMessageBroker&lt;/code&gt;&lt;/a&gt; to it.</source>
          <target state="translated">주어진 채널을 초기화하고 새로운 &lt;a href=&quot;servicemessagebroker&quot;&gt; &lt;code&gt;ServiceMessageBroker&lt;/code&gt; &lt;/a&gt; 를 연결 합니다.</target>
        </trans-unit>
        <trans-unit id="45c1066fbea6cba9ced272d9562f0736aff32776" translate="yes" xml:space="preserve">
          <source>Initializing Form Controls</source>
          <target state="translated">폼 컨트롤 초기화</target>
        </trans-unit>
        <trans-unit id="21a441852885d7b36abf9a2af6624106cec7028b" translate="yes" xml:space="preserve">
          <source>Initializing a component or directive</source>
          <target state="translated">구성 요소 또는 지시문 초기화</target>
        </trans-unit>
        <trans-unit id="1fe4e72a93c746bc6e02495144ba7947c1a26ff3" translate="yes" xml:space="preserve">
          <source>Initially, the form contains one &lt;code&gt;Alias&lt;/code&gt; field. To add another field, click the &lt;strong&gt;Add Alias&lt;/strong&gt; button. You can also validate the array of aliases reported by the form model displayed by &lt;code&gt;&lt;a href=&quot;../api/forms/form&quot;&gt;Form&lt;/a&gt; &lt;a href=&quot;reactive-forms&quot;&gt;Value&lt;/a&gt;&lt;/code&gt; at the bottom of the template.</source>
          <target state="translated">처음에는 양식에 하나의 &lt;code&gt;Alias&lt;/code&gt; 필드 가 포함되어 있습니다 . 다른 필드를 추가하려면 &lt;strong&gt;별칭 추가&lt;/strong&gt; 버튼을 클릭하십시오 . 템플릿 하단 에 &lt;code&gt;&lt;a href=&quot;../api/forms/form&quot;&gt;Form&lt;/a&gt; &lt;a href=&quot;reactive-forms&quot;&gt;Value&lt;/a&gt;&lt;/code&gt; 표시되는 양식 모델이보고 한 별칭 배열의 유효성을 검사 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42eadde3ebeedcb01845dc3c87d03e98510aa2f2" translate="yes" xml:space="preserve">
          <source>Initially, the form contains one &lt;code&gt;Alias&lt;/code&gt; field. To add another field, click the &lt;strong&gt;Add Alias&lt;/strong&gt; button. You can also validate the array of aliases reported by the form model displayed by &lt;code&gt;&lt;a href=&quot;../api/forms/form&quot;&gt;Form&lt;/a&gt; Value&lt;/code&gt; at the bottom of the template.</source>
          <target state="translated">처음에는 양식에 하나의 &lt;code&gt;Alias&lt;/code&gt; 필드가 있습니다. 다른 필드를 추가하려면 &lt;strong&gt;별칭 추가&lt;/strong&gt; 버튼을 클릭 합니다. 템플릿 맨 아래 에 &lt;code&gt;&lt;a href=&quot;../api/forms/form&quot;&gt;Form&lt;/a&gt; Value&lt;/code&gt; 표시되는 양식 모델에서보고 한 별칭 배열의 유효성을 검사 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18f7dc17ff8fd13a734c298c804eb7b21097f85d" translate="yes" xml:space="preserve">
          <source>Initially, this &lt;code&gt;package.json&lt;/code&gt; includes &lt;em&gt;a starter set of packages&lt;/em&gt;, some of which are required by Angular and others that support common application scenarios. You add packages to &lt;code&gt;package.json&lt;/code&gt; as your application evolves. You may even remove some.</source>
          <target state="translated">처음에이 &lt;code&gt;package.json&lt;/code&gt; 에는 &lt;em&gt;스타터 패키지 세트가&lt;/em&gt; 포함되어 &lt;em&gt;있으며&lt;/em&gt; , 그중 일부는 Angular에 필요하고 다른 일부는 일반적인 애플리케이션 시나리오를 지원합니다. 애플리케이션이 발전함에 따라 &lt;code&gt;package.json&lt;/code&gt; 에 패키지를 추가합니다 . 일부를 제거 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0514cac9bc7568beb69cbbc30da8b406819cc6b" translate="yes" xml:space="preserve">
          <source>Inject</source>
          <target state="translated">Inject</target>
        </trans-unit>
        <trans-unit id="7268a66f5506231753b6382da0b8d3a4a8843b60" translate="yes" xml:space="preserve">
          <source>Inject &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; into the &lt;code&gt;CartService&lt;/code&gt; constructor:</source>
          <target state="translated">를 주입 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 를 에 &lt;code&gt;CartService&lt;/code&gt; 의 생성자 :</target>
        </trans-unit>
        <trans-unit id="a0b584ab9a7933f64f5ad564c80c4c66772a45ff" translate="yes" xml:space="preserve">
          <source>Inject &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; into the constructor of the &lt;code&gt;CartService&lt;/code&gt; component class:</source>
          <target state="translated">를 주입 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 를 의 생성자에 &lt;code&gt;CartService&lt;/code&gt; 구성 요소 클래스 :</target>
        </trans-unit>
        <trans-unit id="169d2e7db743680da7bcee35e770f063b1748fe7" translate="yes" xml:space="preserve">
          <source>Inject &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; in the constructor of the component class so they are available to this component:</source>
          <target state="translated">이 구성 요소에서 사용할 수 있도록 구성 요소 클래스의 생성자에 &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 를 삽입 합니다 .</target>
        </trans-unit>
        <trans-unit id="07e6446b3ec41eff6e77df6a94f68f05da7cbf47" translate="yes" xml:space="preserve">
          <source>Inject &lt;code&gt;&lt;a href=&quot;httptestingcontroller&quot;&gt;HttpTestingController&lt;/a&gt;&lt;/code&gt; to expect and flush requests in your tests.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;httptestingcontroller&quot;&gt;HttpTestingController&lt;/a&gt;&lt;/code&gt; 를 삽입 하여 테스트에서 요청을 예상하고 플러시하십시오.</target>
        </trans-unit>
        <trans-unit id="0952ea7f63acfd82b419fcf6cced10453de431df" translate="yes" xml:space="preserve">
          <source>Inject &lt;code&gt;defaultValue&lt;/code&gt; instead if token not found.</source>
          <target state="translated">토큰을 찾지 못하면 대신 &lt;code&gt;defaultValue&lt;/code&gt; 를 주입하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f91c79ea7fa6708f138cf01e5ccc0fc1c490de0" translate="yes" xml:space="preserve">
          <source>Inject an instance of &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; by adding it to your application's constructor:</source>
          <target state="translated">애플리케이션의 생성자에 추가하여 &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; 인스턴스를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="d35e138d7924df4f57c58f11f62047d6ce402802" translate="yes" xml:space="preserve">
          <source>Inject in HeroService, which uses the service to send a message.</source>
          <target state="translated">서비스를 사용하여 메시지를 보내는 HeroService에 주입합니다.</target>
        </trans-unit>
        <trans-unit id="b30cf752176e7d45dca92a9a96dfc9004399a587" translate="yes" xml:space="preserve">
          <source>Inject in MessagesComponent, which displays that message, and also displays the ID when the user clicks a hero.</source>
          <target state="translated">메시지를 표시하는 MessagesComponent에 삽입하고 사용자가 영웅을 클릭 할 때 ID도 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d1eeaaa0b805224cf7a0933509d9f3a0615a6f94" translate="yes" xml:space="preserve">
          <source>Inject into a derived class</source>
          <target state="translated">파생 클래스에 주입</target>
        </trans-unit>
        <trans-unit id="b3f6806d5b467cb7c3bc8bc8ecba219c8ede60db" translate="yes" xml:space="preserve">
          <source>Inject it into the &lt;code&gt;HeroService&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;HeroService&lt;/code&gt; 에 주입</target>
        </trans-unit>
        <trans-unit id="3d776a9677bf6c1c0ad00a83d4d70c493a2bace4" translate="yes" xml:space="preserve">
          <source>Inject it into the dashboard's constructor.</source>
          <target state="translated">대시 보드의 생성자에 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="c6a769a7874598dad610ef89ad42c1d6435742d6" translate="yes" xml:space="preserve">
          <source>Inject the &lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder&quot;&gt;FormBuilder&lt;/a&gt;&lt;/code&gt; service.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder&quot;&gt;FormBuilder&lt;/a&gt;&lt;/code&gt; 서비스를 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="28003182cc950317a6abaadf804293a86af1d3ae" translate="yes" xml:space="preserve">
          <source>Inject the &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;HeroListComponent&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;code&gt;HeroListComponent&lt;/code&gt; 생성자에 &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; 를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="420762bbb815b0bd858d87aa0d93b5c20b06538d" translate="yes" xml:space="preserve">
          <source>Inject the &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;HeroService&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../api/common/location&quot;&gt;Location&lt;/a&gt;&lt;/code&gt; services into the constructor, saving their values in private fields:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;HeroService&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/common/location&quot;&gt;Location&lt;/a&gt;&lt;/code&gt; 서비스를 생성자에 주입하여 값을 개인 필드에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="2e1405e8adb50326460760ac57b28afebe1b1ae0" translate="yes" xml:space="preserve">
          <source>Inject the &lt;code&gt;CartService&lt;/code&gt; so that the cart component can use it.</source>
          <target state="translated">카트 구성 요소가 사용할 수 있도록 &lt;code&gt;CartService&lt;/code&gt; 를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="a800bd5a4004e16e0370dad20e9742d5664827db" translate="yes" xml:space="preserve">
          <source>Inject the &lt;code&gt;CartService&lt;/code&gt; to manage cart information.</source>
          <target state="translated">&lt;code&gt;CartService&lt;/code&gt; 를 삽입하여 카트 정보를 관리하십시오.</target>
        </trans-unit>
        <trans-unit id="65162f531f207477535e62e7ea7492fac9f6c223" translate="yes" xml:space="preserve">
          <source>Inject the &lt;code&gt;CrisisService&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; and implement the &lt;code&gt;&lt;a href=&quot;../api/core/reflectiveinjector#resolve&quot;&gt;resolve()&lt;/a&gt;&lt;/code&gt; method. That method could return a &lt;code&gt;Promise&lt;/code&gt;, an &lt;code&gt;Observable&lt;/code&gt;, or a synchronous return value.</source>
          <target state="translated">&lt;code&gt;CrisisService&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 를 삽입하고 &lt;code&gt;&lt;a href=&quot;../api/core/reflectiveinjector#resolve&quot;&gt;resolve()&lt;/a&gt;&lt;/code&gt; 메소드를 구현하십시오 . 이 메소드는 &lt;code&gt;Promise&lt;/code&gt; , &lt;code&gt;Observable&lt;/code&gt; 또는 동기 리턴 값을 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b16f99c02b8f10852282d8d6eebe4a3cc42a9b4" translate="yes" xml:space="preserve">
          <source>Inject the &lt;code&gt;CrisisService&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; and implement the &lt;code&gt;resolve()&lt;/code&gt; method. That method could return a &lt;code&gt;Promise&lt;/code&gt;, an &lt;code&gt;Observable&lt;/code&gt;, or a synchronous return value.</source>
          <target state="translated">&lt;code&gt;CrisisService&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 삽입하고 &lt;code&gt;resolve()&lt;/code&gt; 메서드를 구현합니다 . 이 메서드는 &lt;code&gt;Promise&lt;/code&gt; , &lt;code&gt;Observable&lt;/code&gt; 또는 동기 반환 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b20e458e5aa5f29eda7fa30aedd57b1b45f296a2" translate="yes" xml:space="preserve">
          <source>Inject the &lt;code&gt;HeroService&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;HeroService&lt;/code&gt; 를 주입하십시오</target>
        </trans-unit>
        <trans-unit id="e0008c9832891895e4197fb26311d64785b52f25" translate="yes" xml:space="preserve">
          <source>Inject the cart service by adding it to the &lt;code&gt;constructor()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;constructor()&lt;/code&gt; 카트 서비스를 추가하여 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfe1510a03a138b089478140897f394368c5b8a7" translate="yes" xml:space="preserve">
          <source>Inject the cart service in the &lt;code&gt;ShippingComponent&lt;/code&gt; constructor:</source>
          <target state="translated">&lt;code&gt;ShippingComponent&lt;/code&gt; 생성자 에 카트 서비스를 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="d16b7c4a0cd536e6bacd2ccd43f6080006784561" translate="yes" xml:space="preserve">
          <source>Inject the cart service into the &lt;code&gt;ShippingComponent&lt;/code&gt; class:</source>
          <target state="translated">카트 서비스를 &lt;code&gt;ShippingComponent&lt;/code&gt; 클래스에 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="43ae56b717b1d07da26cefb067628e0d35f4e121" translate="yes" xml:space="preserve">
          <source>Inject the cart service.</source>
          <target state="translated">카트 서비스를 주입하십시오.</target>
        </trans-unit>
        <trans-unit id="45806a7b832a7aa36033546e2909b1fb99fc8062" translate="yes" xml:space="preserve">
          <source>Inject the component's DOM element</source>
          <target state="translated">컴포넌트의 DOM 요소 주입</target>
        </trans-unit>
        <trans-unit id="b9cc71265ff0cedc6025f851aa1090e10ae4106d" translate="yes" xml:space="preserve">
          <source>InjectFlags</source>
          <target state="translated">InjectFlags</target>
        </trans-unit>
        <trans-unit id="cd7616c62bcee7b28a2504d9962636cfb31a65c9" translate="yes" xml:space="preserve">
          <source>InjectSetupWrapper</source>
          <target state="translated">InjectSetupWrapper</target>
        </trans-unit>
        <trans-unit id="032faf52b4d806d5f16a644601453c9eb56123b1" translate="yes" xml:space="preserve">
          <source>Injectable</source>
          <target state="translated">Injectable</target>
        </trans-unit>
        <trans-unit id="408e9d9b7375e404fefb7bdc04837a04c20b6309" translate="yes" xml:space="preserve">
          <source>Injectable providers used in &lt;code&gt;@&lt;a href=&quot;core/injectable&quot;&gt;Injectable&lt;/a&gt;&lt;/code&gt; decorator.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;core/injectable&quot;&gt;Injectable&lt;/a&gt;&lt;/code&gt; 데코레이터에 사용되는 주사 가능한 공급자 .</target>
        </trans-unit>
        <trans-unit id="7d89bf3bcb75ed56c72f7c17563209bdb5e2382a" translate="yes" xml:space="preserve">
          <source>Injectable providers used in &lt;code&gt;@&lt;a href=&quot;injectable&quot;&gt;Injectable&lt;/a&gt;&lt;/code&gt; decorator.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;injectable&quot;&gt;Injectable&lt;/a&gt;&lt;/code&gt; 데코레이터에 사용되는 주사 가능한 공급자 .</target>
        </trans-unit>
        <trans-unit id="2a77ff4292cc82f8396306b5f586ac5f5ffc12ad" translate="yes" xml:space="preserve">
          <source>Injectable service that provides a low-level interface for modifying the UI.</source>
          <target state="translated">UI 수정을위한 저수준 인터페이스를 제공하는 주사 가능한 서비스.</target>
        </trans-unit>
        <trans-unit id="156e1f6f9747e475b38a1e470e8d079a4be1aadb" translate="yes" xml:space="preserve">
          <source>InjectableProvider</source>
          <target state="translated">InjectableProvider</target>
        </trans-unit>
        <trans-unit id="448a62a5bd5844abb70fe1a20a84b72bb981925f" translate="yes" xml:space="preserve">
          <source>InjectableType</source>
          <target state="translated">InjectableType</target>
        </trans-unit>
        <trans-unit id="56d719f116fb18f959e9f077cb6114537d0a4be7" translate="yes" xml:space="preserve">
          <source>Injecting a class with a view provider</source>
          <target state="translated">뷰 공급자로 클래스 주입</target>
        </trans-unit>
        <trans-unit id="c9ee8821d919d7751df2bcbc666729c175774e79" translate="yes" xml:space="preserve">
          <source>Injecting services</source>
          <target state="translated">주사 서비스</target>
        </trans-unit>
        <trans-unit id="b141699eb731deeb1b3864e217053b13aad88af5" translate="yes" xml:space="preserve">
          <source>Injecting the real &lt;code&gt;UserService&lt;/code&gt; could be a nightmare. The real service might ask the user for login credentials and attempt to reach an authentication server. These behaviors can be hard to intercept. It is far easier and safer to create and register a test double in place of the real &lt;code&gt;UserService&lt;/code&gt;.</source>
          <target state="translated">실제 &lt;code&gt;UserService&lt;/code&gt; 를 주입하는 것은 악몽 일 수 있습니다. 실제 서비스는 사용자에게 로그인 자격 증명을 요청하고 인증 서버에 연결을 시도 할 수 있습니다. 이러한 동작은 가로 채기가 어려울 수 있습니다. 실제 &lt;code&gt;UserService&lt;/code&gt; 대신 테스트 이중화를 작성하고 등록하는 것이 훨씬 쉽고 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="15703d66fca65cfd4fa012d37f65af1377c00996" translate="yes" xml:space="preserve">
          <source>Injection flags for DI.</source>
          <target state="translated">DI에 대한 주입 플래그.</target>
        </trans-unit>
        <trans-unit id="3fefed6e20021dd0a517b637697a6956a93a1560" translate="yes" xml:space="preserve">
          <source>Injection of the lightweight pattern, using &lt;code&gt;@&lt;a href=&quot;../api/core/contentchild&quot;&gt;ContentChild&lt;/a&gt;()&lt;/code&gt; or &lt;code&gt;@&lt;a href=&quot;../api/core/contentchildren&quot;&gt;ContentChildren&lt;/a&gt;()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/contentchild&quot;&gt;ContentChild&lt;/a&gt;()&lt;/code&gt; 또는 &lt;code&gt;@&lt;a href=&quot;../api/core/contentchildren&quot;&gt;ContentChildren&lt;/a&gt;()&lt;/code&gt; 사용하여 경량 패턴을 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="0a3916cd31d033e233732648d3cdccd52f27b6e3" translate="yes" xml:space="preserve">
          <source>Injection token used to provide a &lt;a href=&quot;hammerloader&quot;&gt;&lt;code&gt;HammerLoader&lt;/code&gt;&lt;/a&gt; to Angular.</source>
          <target state="translated">&lt;a href=&quot;hammerloader&quot;&gt; &lt;code&gt;HammerLoader&lt;/code&gt; &lt;/a&gt; 를 Angular 에 제공하는 데 사용되는 주입 토큰 .</target>
        </trans-unit>
        <trans-unit id="57c26333c9513bf60f948651b07cba48e8ae53ff" translate="yes" xml:space="preserve">
          <source>Injection token used to provide a &lt;a href=&quot;platform-browser/hammerloader&quot;&gt;&lt;code&gt;HammerLoader&lt;/code&gt;&lt;/a&gt; to Angular.</source>
          <target state="translated">&lt;a href=&quot;platform-browser/hammerloader&quot;&gt; &lt;code&gt;HammerLoader&lt;/code&gt; &lt;/a&gt; 를 Angular 에 제공하는 데 사용되는 주입 토큰 .</target>
        </trans-unit>
        <trans-unit id="298d0251e89d6600ae4b408002fa0e4b1b404c23" translate="yes" xml:space="preserve">
          <source>InjectionToken</source>
          <target state="translated">InjectionToken</target>
        </trans-unit>
        <trans-unit id="2ca8a0d344a0e19a0d77c7ff904b9681383397eb" translate="yes" xml:space="preserve">
          <source>Injector</source>
          <target state="translated">Injector</target>
        </trans-unit>
        <trans-unit id="181fb401efe3b0268d07d54a65b4c3aee191549f" translate="yes" xml:space="preserve">
          <source>Injector hierarchy and service instances</source>
          <target state="translated">인젝터 계층 및 서비스 인스턴스</target>
        </trans-unit>
        <trans-unit id="6681c4b8cc73e181819eb4ae89965a8a02cef140" translate="yes" xml:space="preserve">
          <source>InjectorType</source>
          <target state="translated">InjectorType</target>
        </trans-unit>
        <trans-unit id="491d5d6666614da901294ee7bd33510be9f0dcaa" translate="yes" xml:space="preserve">
          <source>Injectors are inherited, which means that if a given injector can't resolve a dependency, it asks the parent injector to resolve it. A component can get services from its own injector, from the injectors of its component ancestors, from the injector of its parent NgModule, or from the &lt;code&gt;root&lt;/code&gt; injector.</source>
          <target state="translated">인젝터는 상속됩니다. 즉, 주어진 인젝터가 종속성을 해결할 수없는 경우 상위 인젝터에게이를 해결하도록 요청합니다. 컴포넌트는 자체 인젝터, 컴포넌트 조상의 인젝터, 상위 NgModule 인젝터 또는 &lt;code&gt;root&lt;/code&gt; 인젝터 에서 서비스를받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cba0bd0bb6098207c32cc66a9233a7a7ca6e5abc" translate="yes" xml:space="preserve">
          <source>Injectors in Angular have rules that you can leverage to achieve the desired visibility of injectables in your apps. By understanding these rules, you can determine in which NgModule, Component or Directive you should declare a provider.</source>
          <target state="translated">Angular의 인젝터에는 앱에서 원하는 인젝터 블 가시성을 달성하기 위해 활용할 수있는 규칙이 있습니다. 이러한 규칙을 이해하면 제공자를 선언해야하는 NgModule, 구성 요소 또는 지시문을 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d99dc5eac81a5aa984fbb526ba0c84043ed22e8" translate="yes" xml:space="preserve">
          <source>Injects a token from the currently active injector.</source>
          <target state="translated">현재 활성화 된 인젝터에서 토큰을 주입합니다.</target>
        </trans-unit>
        <trans-unit id="07d77bcc29918d26c0c5de34e66f5b60a93c70cd" translate="yes" xml:space="preserve">
          <source>Injects one or more services from the current &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; injector into a test function. It cannot inject a service provided by the component itself. See discussion of the &lt;a href=&quot;testing#get-injected-services&quot;&gt;debugElement.injector&lt;/a&gt;.</source>
          <target state="translated">현재 &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; 인젝터 에서 하나 이상의 서비스를 테스트 기능에 주입합니다. 구성 요소 자체에서 제공하는 서비스를 주입 할 수 없습니다. &lt;a href=&quot;testing#get-injected-services&quot;&gt;debugElement.injector에&lt;/a&gt; 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ebfda58e347c4ba615c724f5aac71296dadfc9b8" translate="yes" xml:space="preserve">
          <source>Injects one or more services from the current &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; injector into a test function. It cannot inject a service provided by the component itself. See discussion of the &lt;a href=&quot;testing-components-scenarios#get-injected-services&quot;&gt;debugElement.injector&lt;/a&gt;.</source>
          <target state="translated">현재 &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; 인젝터 의 하나 이상의 서비스를 테스트 기능에 삽입합니다. 컴포넌트 자체에서 제공하는 서비스를 삽입 할 수 없습니다. &lt;a href=&quot;testing-components-scenarios#get-injected-services&quot;&gt;debugElement.injector의&lt;/a&gt; 토론을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb54a2c7aa72c7bb392f1b151e7266612f3ef4e8" translate="yes" xml:space="preserve">
          <source>Inline code-snippets</source>
          <target state="translated">인라인 코드 스 니펫</target>
        </trans-unit>
        <trans-unit id="d784c6f0a89bdbfeb9496814987b8c32870f48b5" translate="yes" xml:space="preserve">
          <source>Inline in the template HTML.</source>
          <target state="translated">템플릿 HTML에 인라인.</target>
        </trans-unit>
        <trans-unit id="fc54e2872104e0208a49eb9c210abc9dea3a97c7" translate="yes" xml:space="preserve">
          <source>Inline template or external template URL of the component's view.</source>
          <target state="translated">구성 요소보기의 인라인 템플리트 또는 외부 템플리트 URL</target>
        </trans-unit>
        <trans-unit id="3c5fc6f34e31d2439d02789f5061ec164e3d81e3" translate="yes" xml:space="preserve">
          <source>Inline, hand-coded snippets like this one are &lt;em&gt;not&lt;/em&gt; testable and, therefore, are intrinsically unreliable. This example belongs to the small set of pre-approved, inline snippets that includes user input in a command shell or the &lt;em&gt;output&lt;/em&gt; of some process.</source>
          <target state="translated">인라인,이 같은 손으로 코딩 조각은 &lt;em&gt;하지&lt;/em&gt; 검증하고, 따라서 본질적으로 신뢰할 수 있습니다. 이 예제는 명령 셸 또는 일부 프로세스 의 &lt;em&gt;출력&lt;/em&gt; 에 사용자 입력을 포함하는 사전 승인 된 인라인 스 니펫의 작은 세트에 속합니다 .</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="630cbac3ad3755357bd8db01e781e15971700af2" translate="yes" xml:space="preserve">
          <source>Input Type</source>
          <target state="translated">입력 유형</target>
        </trans-unit>
        <trans-unit id="82f4a61e5306720ccacc3322e115835fcae38855" translate="yes" xml:space="preserve">
          <source>Input and Output properties</source>
          <target state="translated">입력 및 출력 속성</target>
        </trans-unit>
        <trans-unit id="6a18227787f1646b26acd2c3b05cd5b674174bc5" translate="yes" xml:space="preserve">
          <source>Input setter coercion</source>
          <target state="translated">입력 세터 강제</target>
        </trans-unit>
        <trans-unit id="61bbcbfa889da817407bf948fa239f50c645e934" translate="yes" xml:space="preserve">
          <source>Input type</source>
          <target state="translated">입력 유형</target>
        </trans-unit>
        <trans-unit id="33e5e7e82f76a11ddf2991effebf767de7f3deb5" translate="yes" xml:space="preserve">
          <source>Input validation</source>
          <target state="translated">입력 검증</target>
        </trans-unit>
        <trans-unit id="a9e020d632ebb33c3a6a2f5cc2af3d36d9ba1540" translate="yes" xml:space="preserve">
          <source>Input value</source>
          <target state="translated">입력 값</target>
        </trans-unit>
        <trans-unit id="f1681e51507bda05aef42afafef4821ba7b10818" translate="yes" xml:space="preserve">
          <source>Input variables</source>
          <target state="translated">입력 변수</target>
        </trans-unit>
        <trans-unit id="b1cf92c5a5350b19a2842a71f5dc2b70d785c5ad" translate="yes" xml:space="preserve">
          <source>Inputs and Outputs</source>
          <target state="translated">입력 및 출력</target>
        </trans-unit>
        <trans-unit id="13af01c384b8f6141cc7bc08db1b4b5b83bd95b2" translate="yes" xml:space="preserve">
          <source>Inputs and type-checking</source>
          <target state="translated">입력 및 유형 검사</target>
        </trans-unit>
        <trans-unit id="76712fc3bc998bc9cc80a5bbd57bbfcecb460078" translate="yes" xml:space="preserve">
          <source>Insert a new &lt;code&gt;&lt;a href=&quot;abstractcontrol&quot;&gt;AbstractControl&lt;/a&gt;&lt;/code&gt; at the end of the array.</source>
          <target state="translated">배열의 끝에 새로운 &lt;code&gt;&lt;a href=&quot;abstractcontrol&quot;&gt;AbstractControl&lt;/a&gt;&lt;/code&gt; 을 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6f3c89a17ee2cf468c4630a524d6bd18db775d8" translate="yes" xml:space="preserve">
          <source>Insert a new &lt;code&gt;&lt;a href=&quot;abstractcontrol&quot;&gt;AbstractControl&lt;/a&gt;&lt;/code&gt; at the given &lt;code&gt;index&lt;/code&gt; in the array.</source>
          <target state="translated">주어진 &lt;code&gt;index&lt;/code&gt; 에 새로운 &lt;code&gt;&lt;a href=&quot;abstractcontrol&quot;&gt;AbstractControl&lt;/a&gt;&lt;/code&gt; 을 배열에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="a763a3ea24b93a6618a09ee6d0076c1dae54d6ab" translate="yes" xml:space="preserve">
          <source>Insert an &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; within the &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; that displays properties of a &lt;code&gt;hero&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hero&lt;/code&gt; 속성을 표시 하는 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 내에 &amp;lt;li&amp;gt;를 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0df1c34b6777b550f977e456758483fab9bfd30" translate="yes" xml:space="preserve">
          <source>Insert the following into the &lt;code&gt;HeroesComponent&lt;/code&gt; template, just after the heading:</source>
          <target state="translated">제목 바로 다음에 &lt;code&gt;HeroesComponent&lt;/code&gt; 템플릿에 다음을 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="23f5944e1199c8f9232153ef3a60afa86a40d070" translate="yes" xml:space="preserve">
          <source>Inserts a view into this container.</source>
          <target state="translated">이 컨테이너에 뷰를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="50011e1a54a656c04fc02bf9c77175e034f25652" translate="yes" xml:space="preserve">
          <source>Inserts an embedded view from a prepared &lt;code&gt;&lt;a href=&quot;../core/templateref&quot;&gt;TemplateRef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">준비된 &lt;code&gt;&lt;a href=&quot;../core/templateref&quot;&gt;TemplateRef&lt;/a&gt;&lt;/code&gt; 에서 포함 된 뷰를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="75d0650f178b6f787feea44111266946b9ecd87d" translate="yes" xml:space="preserve">
          <source>Inserts an embedded view from a prepared &lt;code&gt;&lt;a href=&quot;core/templateref&quot;&gt;TemplateRef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">준비된 &lt;code&gt;&lt;a href=&quot;core/templateref&quot;&gt;TemplateRef&lt;/a&gt;&lt;/code&gt; 에서 포함 된 뷰를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="f7a13f1a4948982fb94e88aa36e8881e135f85a8" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;*ngFor&lt;/code&gt;</source>
          <target state="translated">내부 &lt;code&gt;*ngFor&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19ed5cba849af683656b54b43049a241ffe5b0d8" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;NgSwitch&lt;/code&gt; directives</source>
          <target state="translated">내부 &lt;code&gt;NgSwitch&lt;/code&gt; 지시문</target>
        </trans-unit>
        <trans-unit id="255b0977970291621f43e1151716c4e23e21af87" translate="yes" xml:space="preserve">
          <source>Inside an AngularJS component's controller we can get hold of the downgraded service via the name we gave when downgrading.</source>
          <target state="translated">AngularJS 구성 요소의 컨트롤러 내에서 다운 그레이드 할 때 지정한 이름을 통해 다운 그레이드 된 서비스를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="072282cc9231ad60c9cc9690bf8418d6381ccca7" translate="yes" xml:space="preserve">
          <source>Inside that directory four files are generated:</source>
          <target state="translated">해당 디렉토리 안에 네 개의 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="6d5ecf03917471adf142cf23f4f2c3c4b339b21a" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;src/&lt;/code&gt; folder, the &lt;code&gt;app/&lt;/code&gt; folder contains your project's logic and data. Angular components, templates, and styles go here.</source>
          <target state="translated">&lt;code&gt;src/&lt;/code&gt; 폴더 안에 &lt;code&gt;app/&lt;/code&gt; 폴더에는 프로젝트의 논리와 데이터가 들어 있습니다. 각도 구성 요소, 템플릿 및 스타일이 여기에 있습니다.</target>
        </trans-unit>
        <trans-unit id="43dc34d6ca14b24f422ae821aed69fec4d0746ee" translate="yes" xml:space="preserve">
          <source>Inside the feature module</source>
          <target state="translated">기능 모듈 내부</target>
        </trans-unit>
        <trans-unit id="99a0a59687e515effa9af831817de2a42be88bcb" translate="yes" xml:space="preserve">
          <source>Inside the interpolation expression, you flow the component's &lt;code&gt;birthday&lt;/code&gt; value through the &lt;a href=&quot;template-syntax#pipe&quot;&gt;pipe operator&lt;/a&gt; ( | ) to the &lt;a href=&quot;../api/common/datepipe&quot;&gt;Date pipe&lt;/a&gt; function on the right. All pipes work this way.</source>
          <target state="translated">보간 표현식 내에서 &lt;a href=&quot;template-syntax#pipe&quot;&gt;파이프 연산자&lt;/a&gt; (|)를 통해 구성 요소의 &lt;code&gt;birthday&lt;/code&gt; 값을 오른쪽 의 &lt;a href=&quot;../api/common/datepipe&quot;&gt;날짜 파이프&lt;/a&gt; 함수로 흐릅니다 . 모든 파이프는 이런 식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="df4011fe1a09f1043a4b2b06cd1697fa041ae820" translate="yes" xml:space="preserve">
          <source>Inspect the bundles</source>
          <target state="translated">번들 검사</target>
        </trans-unit>
        <trans-unit id="215770189e6d0e21c2e4dcd73cf798410232e895" translate="yes" xml:space="preserve">
          <source>Inspect the router's configuration</source>
          <target state="translated">라우터 구성 검사</target>
        </trans-unit>
        <trans-unit id="f5dd0a6a7ea6173ab33b717cf0e2c38499a6b62a" translate="yes" xml:space="preserve">
          <source>Inspecting generated CSS</source>
          <target state="translated">생성 된 CSS 검사</target>
        </trans-unit>
        <trans-unit id="00f4891662ba21393eafa47f4ff9e723df6085f7" translate="yes" xml:space="preserve">
          <source>Inspecting the element in the browser tools reveals that the &lt;em&gt;name&lt;/em&gt; input box is &lt;em&gt;no longer pristine&lt;/em&gt;. The form remembers that you entered a name before clicking &lt;em&gt;New Hero&lt;/em&gt;. Replacing the hero object &lt;em&gt;did not restore the pristine state&lt;/em&gt; of the form controls.</source>
          <target state="translated">브라우저 도구에서 요소를 검사하면 &lt;em&gt;이름&lt;/em&gt; 입력 상자가 &lt;em&gt;더 이상 깨끗하지 않습니다&lt;/em&gt; . 양식은 &lt;em&gt;New Hero&lt;/em&gt; 를 클릭하기 전에 이름을 입력했음을 기억합니다 . 영웅 개체를 &lt;em&gt;교체해도&lt;/em&gt; 양식 컨트롤 &lt;em&gt;의 원래 상태&lt;/em&gt; 는 &lt;em&gt;복원되지 않았습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3cffd5bd9bd048669135ad23ec9b71ceb62833ce" translate="yes" xml:space="preserve">
          <source>Install &lt;a href=&quot;https://firebase.google.com/docs/cli&quot;&gt;Firebase CLI&lt;/a&gt; globally using &lt;code&gt;npm install -g firebase-tools&lt;/code&gt;.</source>
          <target state="translated">설치 &lt;a href=&quot;https://firebase.google.com/docs/cli&quot;&gt;중포 기지 CLI는&lt;/a&gt; 전 세계적으로 사용 &lt;code&gt;npm install -g firebase-tools&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="767d840fb58485232878c237b7ed2fe6e569ced7" translate="yes" xml:space="preserve">
          <source>Install &lt;code&gt;fs-extra&lt;/code&gt; via &lt;code&gt;npm install fs-extra --save-dev&lt;/code&gt; for better file copying, and change &lt;code&gt;copy-dist-files.js&lt;/code&gt; to the following:</source>
          <target state="translated">설치 &lt;code&gt;fs-extra&lt;/code&gt; 를 통해 &lt;code&gt;npm install fs-extra --save-dev&lt;/code&gt; 더 나은 파일 복사 및 변경 &lt;code&gt;copy-dist-files.js&lt;/code&gt; 다음에 :</target>
        </trans-unit>
        <trans-unit id="2b5240a912c78956650075c76cef901344fb7d53" translate="yes" xml:space="preserve">
          <source>Install &lt;code&gt;source-map-explorer&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;source-map-explorer&lt;/code&gt; 를 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="5722ef718aa35b09e478fcff4fbda0f369c92662" translate="yes" xml:space="preserve">
          <source>Install &lt;strong&gt;&lt;a href=&quot;https://nodejs.org/en/download/&quot;&gt;Node.js&amp;reg; and npm&lt;/a&gt;&lt;/strong&gt; if they are not already on your machine. See &lt;a href=&quot;setup-local&quot;&gt;Local Environment Setup&lt;/a&gt; for supported versions and instructions.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://nodejs.org/en/download/&quot;&gt;Node.js&amp;reg; 및 npm&lt;/a&gt;&lt;/strong&gt; 이 아직 시스템에 없으면 설치 하십시오. 지원되는 버전 및 지침 은 &lt;a href=&quot;setup-local&quot;&gt;로컬 환경 설정&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e8d135e6ccd34e326cce716adb2bf33aeca9a237" translate="yes" xml:space="preserve">
          <source>Install Angular into the project, along with the SystemJS module loader. Take a look at the results of the &lt;a href=&quot;upgrade-setup&quot;&gt;upgrade setup instructions&lt;/a&gt; and get the following configurations from there:</source>
          <target state="translated">SystemJS 모듈 로더와 함께 Angular를 프로젝트에 설치하십시오. &lt;a href=&quot;upgrade-setup&quot;&gt;업그레이드 설정 지침&lt;/a&gt; 의 결과를보고 다음 구성을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="1261f2c456b1f62133aa270d8e5fd5d048b8b664" translate="yes" xml:space="preserve">
          <source>Install the &lt;code&gt;firebase-tools&lt;/code&gt; CLI that will handle your deployment using &lt;code&gt;npm install -g firebase-tools&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;npm install -g firebase-tools&lt;/code&gt; 를 사용하여 배치를 처리 할 &lt;code&gt;firebase-tools&lt;/code&gt; CLI를 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd383d8abcaf9309b3e8d4c4392877db6730239a" translate="yes" xml:space="preserve">
          <source>Install the &lt;code&gt;upgrade&lt;/code&gt; package via &lt;code&gt;npm install @angular/upgrade --save&lt;/code&gt; and add a mapping for the &lt;code&gt;@angular/upgrade/&lt;a href=&quot;../api/upgrade/static&quot;&gt;static&lt;/a&gt;&lt;/code&gt; package.</source>
          <target state="translated">설치 &lt;code&gt;upgrade&lt;/code&gt; 를 통해 패키지 &lt;code&gt;npm install @angular/upgrade --save&lt;/code&gt; 와의 매핑을 추가 &lt;code&gt;@angular/upgrade/&lt;a href=&quot;../api/upgrade/static&quot;&gt;static&lt;/a&gt;&lt;/code&gt; 패키지를.</target>
        </trans-unit>
        <trans-unit id="2c6ba9043f36b22f823292eb108df95f5f18e948" translate="yes" xml:space="preserve">
          <source>Install the Angular CLI</source>
          <target state="translated">Angular CLI 설치</target>
        </trans-unit>
        <trans-unit id="987677d76fa5c1deda62223710a489453421d4ae" translate="yes" xml:space="preserve">
          <source>Install the Angular CLI globally.</source>
          <target state="translated">Angular CLI를 전체적으로 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="6a32adb90b36db0ed2141c3193f082788870e5bd" translate="yes" xml:space="preserve">
          <source>Install the Angular CLI.</source>
          <target state="translated">Angular CLI를 설치합니다.</target>
        </trans-unit>
        <trans-unit id="bdcb3dfef60b666573c8ce1ed8b494f2716b38c6" translate="yes" xml:space="preserve">
          <source>Install the Angular Language Service package in the same location:</source>
          <target state="translated">Angular Language Service 패키지를 같은 위치에 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="9d42883b764f1c8c553d34790e6e538c26173f08" translate="yes" xml:space="preserve">
          <source>Install the CLI using the &lt;code&gt;npm&lt;/code&gt; package manager:</source>
          <target state="translated">&lt;code&gt;npm&lt;/code&gt; 패키지 관리자를 사용하여 CLI를 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a392da3b3f2f11041c5fe8719aff8e6bcc76e63" translate="yes" xml:space="preserve">
          <source>Install the In-memory Web API package from npm with the following command:</source>
          <target state="translated">다음 명령을 사용하여 npm에서 인 메모리 웹 API 패키지를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="6a2e11d433615c4e688e8c2e1a2f370f9f882859" translate="yes" xml:space="preserve">
          <source>Install the latest version of TypeScript in a local &lt;code&gt;node_modules&lt;/code&gt; directory:</source>
          <target state="translated">로컬 &lt;code&gt;node_modules&lt;/code&gt; 디렉토리 에 최신 버전의 TypeScript를 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="a55b0d6eaf5833f9d1d83c86418e84d35b30f379" translate="yes" xml:space="preserve">
          <source>Install type definitions for the existing libraries that you're using but that don't come with prepackaged types: AngularJS and the Jasmine unit test framework.</source>
          <target state="translated">사용 중이지만 사전 패키징 된 유형이 제공되지 않는 기존 라이브러리 (AngularJS 및 Jasmine 단위 테스트 프레임 워크)에 대한 유형 정의를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="d251edf4bd4d2213540b80ec0286e5d42780e1b1" translate="yes" xml:space="preserve">
          <source>Install type definitions for the existing libraries that you're using but that don't come with prepackaged types: AngularJS, AngularJS Material, and the Jasmine unit test framework.</source>
          <target state="translated">사용중인 기존 라이브러리에 대한 유형 정의를 설치하지만 AngularJS, AngularJS Material 및 Jasmine 단위 테스트 프레임 워크와 같은 사전 패키지 유형과 함께 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="007650eba9764fc0e78e4bc1bd31b1198fb68fbf" translate="yes" xml:space="preserve">
          <source>Installable typings files</source>
          <target state="translated">설치 가능한 타이핑 파일</target>
        </trans-unit>
        <trans-unit id="590df37bbf3a109889319af6d9048be9a71e39d5" translate="yes" xml:space="preserve">
          <source>Installing Angular</source>
          <target state="translated">각도 설치</target>
        </trans-unit>
        <trans-unit id="93c51dd01f96d8f057ca0640853a63493a184144" translate="yes" xml:space="preserve">
          <source>Installing Angular CLI</source>
          <target state="translated">Angular CLI 설치</target>
        </trans-unit>
        <trans-unit id="29ff101f42f25faf7396162f5dcaed389e809afb" translate="yes" xml:space="preserve">
          <source>Installing libraries</source>
          <target state="translated">라이브러리 설치</target>
        </trans-unit>
        <trans-unit id="943d24405b833810f0fc6a9ac5fedf1d6c7c1920" translate="yes" xml:space="preserve">
          <source>Installing the Angular service worker is as simple as including an &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt;. In addition to registering the Angular service worker with the browser, this also makes a few services available for injection which interact with the service worker and can be used to control it. For example, an application can ask to be notified when a new update becomes available, or an application can ask the service worker to check the server for available updates.</source>
          <target state="translated">Angular 서비스 워커 설치는 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 을 포함하는 것만 큼 간단 합니다. Angular 서비스 워커를 브라우저에 등록하는 것 외에도 서비스 워커와 상호 작용하고이를 제어하는 ​​데 사용할 수있는 몇 가지 서비스를 인젝션에 사용할 수 있습니다. 예를 들어, 새 업데이트를 사용할 수있게되면 응용 프로그램에 알림을 요청하거나 서비스 담당자에게 서버에 사용 가능한 업데이트가 있는지 확인하도록 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35ca16d7e501ce1fe7afeb879255850001c28e41" translate="yes" xml:space="preserve">
          <source>Installs icon files to support the installed Progressive Web App (PWA).</source>
          <target state="translated">설치된 Progressive Web App (PWA)을 지원하기 위해 아이콘 파일을 설치합니다.</target>
        </trans-unit>
        <trans-unit id="20e716e0358bb09e7445aa9236e78946959e553b" translate="yes" xml:space="preserve">
          <source>Instantiate a &lt;code&gt;&lt;a href=&quot;formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt;, with an initial value.</source>
          <target state="translated">초기 값 으로 &lt;code&gt;&lt;a href=&quot;formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 을 인스턴스화하십시오 .</target>
        </trans-unit>
        <trans-unit id="38aa8686f3352f5834571410dfa3840955e59d4b" translate="yes" xml:space="preserve">
          <source>Instantiates a single &lt;a href=&quot;../core/component&quot;&gt;&lt;code&gt;Component&lt;/code&gt;&lt;/a&gt; type and inserts its Host View into current View. &lt;code&gt;&lt;a href=&quot;ngcomponentoutlet&quot;&gt;NgComponentOutlet&lt;/a&gt;&lt;/code&gt; provides a declarative approach for dynamic component creation.</source>
          <target state="translated">단일 &lt;a href=&quot;../core/component&quot;&gt; &lt;code&gt;Component&lt;/code&gt; &lt;/a&gt; 유형을 인스턴스화하고 해당 호스트보기를 현재보기에 삽입합니다. &lt;code&gt;&lt;a href=&quot;ngcomponentoutlet&quot;&gt;NgComponentOutlet&lt;/a&gt;&lt;/code&gt; 은 동적 구성 요소 생성을위한 선언적 접근 방식을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="38063d7822dcc8a96973053e6ba2f0de5af9a983" translate="yes" xml:space="preserve">
          <source>Instantiates a single &lt;a href=&quot;core/component&quot;&gt;&lt;code&gt;Component&lt;/code&gt;&lt;/a&gt; type and inserts its Host View into current View. &lt;code&gt;&lt;a href=&quot;common/ngcomponentoutlet&quot;&gt;NgComponentOutlet&lt;/a&gt;&lt;/code&gt; provides a declarative approach for dynamic component creation.</source>
          <target state="translated">단일 &lt;a href=&quot;core/component&quot;&gt; &lt;code&gt;Component&lt;/code&gt; &lt;/a&gt; 유형을 인스턴스화하고 해당 호스트보기를 현재보기에 삽입합니다. &lt;code&gt;&lt;a href=&quot;common/ngcomponentoutlet&quot;&gt;NgComponentOutlet&lt;/a&gt;&lt;/code&gt; 은 동적 구성 요소 생성을위한 선언적 접근 방식을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="052c0bf072f0f51a894d30e77a4f689971e12fb7" translate="yes" xml:space="preserve">
          <source>Instantiates a single component and inserts its host view into this container.</source>
          <target state="translated">단일 구성 요소를 인스턴스화하고 해당 호스트보기를이 컨테이너에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="a4ad199a6b556b860c928a9e27b923ade54a8ac0" translate="yes" xml:space="preserve">
          <source>Instantiates an embedded view and inserts it into this container.</source>
          <target state="translated">내장 된 뷰를 인스턴스화하여이 컨테이너에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="f0776be631be3564e94e31e5dc32990150beac7b" translate="yes" xml:space="preserve">
          <source>Instantiates an embedded view based on this template, and attaches it to the view container.</source>
          <target state="translated">이 템플릿을 기반으로 내장 된 뷰를 인스턴스화하여 뷰 컨테이너에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="786c58358d9228836c715a34ab083c47efb00357" translate="yes" xml:space="preserve">
          <source>Instantiates an object using a resolved provider in the context of the injector.</source>
          <target state="translated">인젝터 컨텍스트에서 분석 된 제공자를 사용하여 오브젝트를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="a0357399dd1a1a04fdeed5dfc91f8d7b7be0a893" translate="yes" xml:space="preserve">
          <source>Instantiating the Angular module on-demand</source>
          <target state="translated">주문형 Angular 모듈 인스턴스화</target>
        </trans-unit>
        <trans-unit id="c4d60afbec7f43d48d04b31d9b35a7e492a2e8d9" translate="yes" xml:space="preserve">
          <source>Instead of adding the &lt;code&gt;&quot;/sidekicks&quot;&lt;/code&gt; route, define a &lt;code&gt;wildcard&lt;/code&gt; route and have it navigate to a &lt;code&gt;PageNotFoundComponent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;/sidekicks&quot;&lt;/code&gt; 경로 를 추가하는 대신 &lt;code&gt;wildcard&lt;/code&gt; 경로를 정의 하고 &lt;code&gt;PageNotFoundComponent&lt;/code&gt; 로 이동하도록합니다 .</target>
        </trans-unit>
        <trans-unit id="43fb80c7057cc5fd575a66171218e4c5dcaa2c7b" translate="yes" xml:space="preserve">
          <source>Instead of adding the &lt;code&gt;&quot;/sidekicks&quot;&lt;/code&gt; route, define a &lt;code&gt;wildcard&lt;/code&gt; route instead and have it navigate to a simple &lt;code&gt;PageNotFoundComponent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;/sidekicks&quot;&lt;/code&gt; 라우트 를 추가하는 대신 &lt;code&gt;wildcard&lt;/code&gt; 라우트를 정의 하고 간단한 &lt;code&gt;PageNotFoundComponent&lt;/code&gt; 로 이동 하십시오. .</target>
        </trans-unit>
        <trans-unit id="4545e903884ce10d8860ee7224edb38d91aba382" translate="yes" xml:space="preserve">
          <source>Instead of defining all member classes in one giant file as in a JavaScript module, you list the module's classes in the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule#declarations&quot;&gt;NgModule.declarations&lt;/a&gt;&lt;/code&gt; list.</source>
          <target state="translated">JavaScript 모듈처럼 하나의 거대한 파일에 모든 멤버 클래스를 정의하는 대신 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule#declarations&quot;&gt;NgModule.declarations&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/ngmodule#declarations&quot;&gt;NgModule&lt;/a&gt; 에 모듈 클래스를 나열합니다. 목록 나열합니다.</target>
        </trans-unit>
        <trans-unit id="bcea27d4a4ea890a7b5b46266c065c932d9159ff" translate="yes" xml:space="preserve">
          <source>Instead of handling the error directly, it returns an error handler function to &lt;code&gt;catchError&lt;/code&gt; that it has configured with both the name of the operation that failed and a safe return value.</source>
          <target state="translated">오류를 직접 처리하는 대신 오류 처리기 함수를 &lt;code&gt;catchError&lt;/code&gt; 에 반환합니다. 작업 이름과 안전한 반환 값으로 구성된 합니다.</target>
        </trans-unit>
        <trans-unit id="2ced3569fe32156e54433459c9f7274b0cae7ecf" translate="yes" xml:space="preserve">
          <source>Instead of using the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; decorators to declare inputs and outputs, you can identify members in the &lt;code&gt;inputs&lt;/code&gt; and &lt;code&gt;outputs&lt;/code&gt; arrays of the directive metadata, as in this example:</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 및 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; 데코레이터를 사용하여 입력 및 출력을 선언 하는 대신 다음 예제와 같이 지시문 메타 데이터 의 &lt;code&gt;inputs&lt;/code&gt; 및 &lt;code&gt;outputs&lt;/code&gt; 배열 에서 멤버를 식별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41c9b9e64f30d6ebdd7548f0f306b5e519819b75" translate="yes" xml:space="preserve">
          <source>Instead they return observables of &lt;code&gt;&lt;a href=&quot;../api/common/http/httpevent&quot;&gt;HttpEvent&lt;/a&gt;&amp;lt;any&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">대신에 그들은 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpevent&quot;&gt;HttpEvent&lt;/a&gt;&amp;lt;any&amp;gt;&lt;/code&gt; 의 옵저버 블 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="ce684a983c63ce2f1f454c04e646d6d8a3bc7367" translate="yes" xml:space="preserve">
          <source>Instead you can mock the dependency, use a dummy value, or create a &lt;a href=&quot;https://jasmine.github.io/2.0/introduction.html#section-Spies&quot;&gt;spy&lt;/a&gt; on the pertinent service method.</source>
          <target state="translated">대신 종속성을 조롱하거나 더미 값을 사용하거나 관련 서비스 방법에 대한 &lt;a href=&quot;https://jasmine.github.io/2.0/introduction.html#section-Spies&quot;&gt;스파이&lt;/a&gt; 를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="461b96eba4f5a430cd543bbe85601a5e70ae7271" translate="yes" xml:space="preserve">
          <source>Instead you'll write a &lt;code&gt;&lt;a href=&quot;../api/router/route#canActivate&quot;&gt;canActivate&lt;/a&gt;()&lt;/code&gt; guard method to redirect anonymous users to the login page when they try to enter the admin area.</source>
          <target state="translated">대신 &lt;code&gt;&lt;a href=&quot;../api/router/route#canActivate&quot;&gt;canActivate&lt;/a&gt;()&lt;/code&gt; ()를 작성합니다. 익명 사용자가 관리 영역에 들어 가려고 할 때 로그인 페이지로 리디렉션 guard 메소드를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="d3964f48718ba9278c74706508750ce239c41a70" translate="yes" xml:space="preserve">
          <source>Instead, &lt;code&gt;LibHeaderComponent&lt;/code&gt; itself implements the abstract &lt;code&gt;LibHeaderToken&lt;/code&gt; class. You can safely use that token as the provider in the component definition, allowing Angular to correctly inject the concrete type.</source>
          <target state="translated">대신 &lt;code&gt;LibHeaderComponent&lt;/code&gt; 자체가 추상 &lt;code&gt;LibHeaderToken&lt;/code&gt; 클래스를 구현합니다 . 구성 요소 정의에서 해당 토큰을 공급자로 안전하게 사용할 수 있으므로 Angular가 구체적인 유형을 올바르게 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49a4d7b52c2322fe3ec1102b059fd40a0edaba63" translate="yes" xml:space="preserve">
          <source>Instead, call &lt;code&gt;getHeroes()&lt;/code&gt; inside the &lt;a href=&quot;../guide/lifecycle-hooks&quot;&gt;&lt;em&gt;ngOnInit lifecycle hook&lt;/em&gt;&lt;/a&gt; and let Angular call &lt;code&gt;ngOnInit()&lt;/code&gt; at an appropriate time &lt;em&gt;after&lt;/em&gt; constructing a &lt;code&gt;HeroesComponent&lt;/code&gt; instance.</source>
          <target state="translated">대신, 통화 &lt;code&gt;getHeroes()&lt;/code&gt; 내부 &lt;a href=&quot;../guide/lifecycle-hooks&quot;&gt;&lt;em&gt;ngOnInit 라이프 사이클 후크&lt;/em&gt;&lt;/a&gt; 및 각도 호출 할 수 &lt;code&gt;ngOnInit()&lt;/code&gt; 적절한시기에 &lt;em&gt;후&lt;/em&gt; 건설 &lt;code&gt;HeroesComponent&lt;/code&gt; 의 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="fdd12a96a1f80e924cc94c2ae62043da14036314" translate="yes" xml:space="preserve">
          <source>Instead, download typings for your library (&lt;code&gt;npm install @types/jquery&lt;/code&gt;) and follow the library installation steps. This gives you access to the global variables exposed by that library.</source>
          <target state="translated">대신, 라이브러리 입력 ( &lt;code&gt;npm install @types/jquery&lt;/code&gt; )을 다운로드하고 라이브러리 설치 단계를 따르십시오. 이를 통해 해당 라이브러리에 의해 노출 된 전역 변수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b0bf66c25d9781be7cefa931b18abbac35f3e32" translate="yes" xml:space="preserve">
          <source>Instead, each &lt;code&gt;HeroBioComponent&lt;/code&gt; gets its &lt;em&gt;own&lt;/em&gt;&lt;code&gt;HeroCacheService&lt;/code&gt; instance by listing &lt;code&gt;HeroCacheService&lt;/code&gt; in its metadata &lt;code&gt;providers&lt;/code&gt; array.</source>
          <target state="translated">대신 각 &lt;code&gt;HeroBioComponent&lt;/code&gt; 는 메타 데이터 &lt;code&gt;providers&lt;/code&gt; 배열에 &lt;code&gt;HeroCacheService&lt;/code&gt; 를 나열 하여 &lt;em&gt;자체 &lt;/em&gt; &lt;code&gt;HeroCacheService&lt;/code&gt; 인스턴스를 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="0d305901f6c4d49bcedd325e78ae1b0860a4fb31" translate="yes" xml:space="preserve">
          <source>Instead, the &lt;code&gt;ngOnInit()&lt;/code&gt; method pipes the &lt;code&gt;searchTerms&lt;/code&gt; observable through a sequence of RxJS operators that reduce the number of calls to the &lt;code&gt;searchHeroes()&lt;/code&gt;, ultimately returning an observable of timely hero search results (each a &lt;code&gt;Hero[]&lt;/code&gt;).</source>
          <target state="translated">대신 &lt;code&gt;ngOnInit()&lt;/code&gt; 에있어서 배관 &lt;code&gt;searchTerms&lt;/code&gt; 받는 통화 수가 감소 RxJS 사업자의 순서를 관찰 &lt;code&gt;searchHeroes()&lt;/code&gt; 궁극적으로 적절한 영웅 검색 결과의 관찰을 반환 (각 &lt;code&gt;Hero[]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3d9ebd1ce2ebf177d0250948ce46e33ab5af6b38" translate="yes" xml:space="preserve">
          <source>Instead, the compiler adopts a recursive strategy that generates code only for the components you use.</source>
          <target state="translated">대신 컴파일러는 사용하는 구성 요소에 대해서만 코드를 생성하는 재귀 전략을 채택합니다.</target>
        </trans-unit>
        <trans-unit id="8bd754a169b9bacb9390642cdd317359fddea194" translate="yes" xml:space="preserve">
          <source>Instead, the injector will begin at the &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt;&lt;code&gt;ElementInjector&lt;/code&gt;. Remember that the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; class provides the &lt;code&gt;AnimalService&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt; array with a value of 🐶 (puppy):</source>
          <target state="translated">대신 인젝터는 &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; &lt;code&gt;ElementInjector&lt;/code&gt; 에서 시작합니다 . 기억 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; 클래스가 제공 &lt;code&gt;AnimalService&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../api/core/component#viewProviders&quot;&gt;viewProviders&lt;/a&gt;&lt;/code&gt; 의 🐶 (강아지)의 값으로 배열을 :</target>
        </trans-unit>
        <trans-unit id="2fc262139e9da7fc5a46366f8088811d41bc2d11" translate="yes" xml:space="preserve">
          <source>Instead, the injector will begin at the &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt;&lt;code&gt;ElementInjector&lt;/code&gt;. Remember that the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; class provides the &lt;code&gt;AnimalService&lt;/code&gt; in the &lt;code&gt;viewProviders&lt;/code&gt; array with a value of 🐶 (puppy):</source>
          <target state="translated">대신 인젝터는 &lt;code&gt;&amp;lt;app-root&amp;gt;&lt;/code&gt; &lt;code&gt;ElementInjector&lt;/code&gt; 에서 시작됩니다 . 기억 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; 클래스가 제공 &lt;code&gt;AnimalService&lt;/code&gt; 에서 &lt;code&gt;viewProviders&lt;/code&gt; 의 🐶 (강아지)의 값으로 배열을 :</target>
        </trans-unit>
        <trans-unit id="17aa745e67d203c05d76b91653148f77342ccc8f" translate="yes" xml:space="preserve">
          <source>Instead, update the empty path route in &lt;code&gt;app-routing.module.ts&lt;/code&gt; to redirect to &lt;code&gt;/superheroes&lt;/code&gt;.</source>
          <target state="translated">대신 &lt;code&gt;app-routing.module.ts&lt;/code&gt; 의 빈 경로 경로를 업데이트하여 &lt;code&gt;/superheroes&lt;/code&gt; 로 리디렉션하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4d21a07e95b9953380838df336b7bcbf54fa876" translate="yes" xml:space="preserve">
          <source>Instead, you can provide the &lt;code&gt;VillainsService&lt;/code&gt; in the &lt;code&gt;providers&lt;/code&gt; metadata of the &lt;code&gt;VillainsListComponent&lt;/code&gt; like this:</source>
          <target state="translated">대신 제공 할 수 &lt;code&gt;VillainsService&lt;/code&gt; 에서 &lt;code&gt;providers&lt;/code&gt; 의 메타 데이터 &lt;code&gt;VillainsListComponent&lt;/code&gt; 같은를 :</target>
        </trans-unit>
        <trans-unit id="551fe93146e649cede5e84c7c64fdd5129d01274" translate="yes" xml:space="preserve">
          <source>Instead, you need a way to load a new component without a fixed reference to the component in the ad banner's template.</source>
          <target state="translated">대신 광고 배너 템플릿의 구성 요소에 대한 고정 참조없이 새 구성 요소를로드하는 방법이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3cd340c809823308a4cc4e69ad216846bec763e0" translate="yes" xml:space="preserve">
          <source>Instead, you'd use property binding and write it like this:</source>
          <target state="translated">대신 속성 바인딩을 사용하여 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="935c5dd61b56d9204ed4186be8b2db4497e1e865" translate="yes" xml:space="preserve">
          <source>Integrate routing with your app</source>
          <target state="translated">앱과 라우팅 통합</target>
        </trans-unit>
        <trans-unit id="5a59fb5b70ad75f96031a69bba18f29e2692a460" translate="yes" xml:space="preserve">
          <source>Integrating with the CLI</source>
          <target state="translated">CLI와 통합</target>
        </trans-unit>
        <trans-unit id="5613136c801d2ad2f323cc7ab35810249066fe2b" translate="yes" xml:space="preserve">
          <source>Integrating with the CLI using code-generation schematics</source>
          <target state="translated">코드 생성 회로도를 사용하여 CLI와 통합</target>
        </trans-unit>
        <trans-unit id="3bd6ede907470fb16d3cec8333066bb3ecc44047" translate="yes" xml:space="preserve">
          <source>Intercept input property changes with &lt;code&gt;ngOnChanges()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ngOnChanges()&lt;/code&gt; 하여 입력 특성 변경 사항 인터셉트</target>
        </trans-unit>
        <trans-unit id="fd68d13ca9ca2470bae05c55573d064542db92fb" translate="yes" xml:space="preserve">
          <source>Intercept input property changes with a setter</source>
          <target state="translated">setter를 사용하여 입력 특성 변경 사항 인터셉트</target>
        </trans-unit>
        <trans-unit id="f77e1393f432e2814c4e2431fb8336cf5ac39ef5" translate="yes" xml:space="preserve">
          <source>Intercepting requests and responses</source>
          <target state="translated">요청 및 응답 차단</target>
        </trans-unit>
        <trans-unit id="763892b6e7a2d1ac84d61ec316cc6bf8b1d9cc3e" translate="yes" xml:space="preserve">
          <source>Interceptor order</source>
          <target state="translated">인터셉터 순서</target>
        </trans-unit>
        <trans-unit id="49b669e2ea2af9c86b0cdbcb202a2a4cee9dafbb" translate="yes" xml:space="preserve">
          <source>Interceptors can handle requests by themselves, without forwarding to &lt;code&gt;next.handle()&lt;/code&gt;.</source>
          <target state="translated">인터셉터는 &lt;code&gt;next.handle()&lt;/code&gt; 전달하지 않고 스스로 요청을 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="46734f11cb3498f3b31bc09aa4d5892c9572c37b" translate="yes" xml:space="preserve">
          <source>Interceptors can perform a variety of &lt;em&gt;implicit&lt;/em&gt; tasks, from authentication to logging, in a routine, standard way, for every HTTP request/response.</source>
          <target state="translated">인터셉터는 모든 HTTP 요청 / 응답에 대해 일상적인 표준 방식으로 인증에서 로깅에 이르기까지 다양한 &lt;em&gt;암시 적&lt;/em&gt; 태스크를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78777651ce595557401c9f74bf00aced47fcba6c" translate="yes" xml:space="preserve">
          <source>Interceptors sit between the &lt;code&gt;&lt;a href=&quot;httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; interface and the &lt;code&gt;&lt;a href=&quot;httpbackend&quot;&gt;HttpBackend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인터셉터는 &lt;code&gt;&lt;a href=&quot;httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 인터페이스와 &lt;code&gt;&lt;a href=&quot;httpbackend&quot;&gt;HttpBackend&lt;/a&gt;&lt;/code&gt; 사이에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1e0f70c8d07051766080d71ba2f745bf68b9ae3" translate="yes" xml:space="preserve">
          <source>Intercepts and handles an &lt;code&gt;&lt;a href=&quot;http/httprequest&quot;&gt;HttpRequest&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;http/httpresponse&quot;&gt;HttpResponse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http/httprequest&quot;&gt;HttpRequest&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;http/httpresponse&quot;&gt;HttpResponse&lt;/a&gt;&lt;/code&gt; 를 가로 채고 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="ee4ce4943c7c8f62cc7efe1749d8027783f80f63" translate="yes" xml:space="preserve">
          <source>Intercepts and handles an &lt;code&gt;&lt;a href=&quot;httprequest&quot;&gt;HttpRequest&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;httpresponse&quot;&gt;HttpResponse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;httprequest&quot;&gt;HttpRequest&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;httpresponse&quot;&gt;HttpResponse&lt;/a&gt;&lt;/code&gt; 를 가로 채고 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="51feddee76f6ae2ad0215641743746a9f5b45fb4" translate="yes" xml:space="preserve">
          <source>Interface for options provided to an &lt;code&gt;&lt;a href=&quot;abstractcontrol&quot;&gt;AbstractControl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;abstractcontrol&quot;&gt;AbstractControl&lt;/a&gt;&lt;/code&gt; 에 제공되는 옵션의 인터페이스입니다 .</target>
        </trans-unit>
        <trans-unit id="2fcbaf5b57a8ead29b181bc23a1d29fcef1a8f14" translate="yes" xml:space="preserve">
          <source>Interface for options provided to an &lt;code&gt;&lt;a href=&quot;forms/abstractcontrol&quot;&gt;AbstractControl&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;forms/abstractcontrol&quot;&gt;AbstractControl&lt;/a&gt;&lt;/code&gt; 에 제공되는 옵션의 인터페이스입니다 .</target>
        </trans-unit>
        <trans-unit id="c3789cc9f6d7a24798ad678cfda27d1e007aa43c" translate="yes" xml:space="preserve">
          <source>Interface for the events emitted through the NgElementStrategy.</source>
          <target state="translated">NgElementStrategy를 통해 생성 된 이벤트에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="3deee779f810298f9a0e89f2ff8482ea01f5a511" translate="yes" xml:space="preserve">
          <source>Interface that a class can implement to be a guard deciding if a child route can be activated. If all guards return &lt;code&gt;true&lt;/code&gt;, navigation continues. If any guard returns &lt;code&gt;false&lt;/code&gt;, navigation is cancelled. If any guard returns a &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt;, current navigation is cancelled and a new navigation begins to the &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; returned from the guard.</source>
          <target state="translated">클래스가 자식 경로를 활성화 할 수 있는지를 결정하는 가드로 구현할 수있는 인터페이스입니다. 모든 가드가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 탐색이 계속됩니다. 가드가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 탐색이 취소됩니다. 모든 경비는 반환하면 &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 을 , 현재 탐색이 취소되고 새로운 탐색이 시작됩니다 &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 이 가드에서 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="bc42104552e7bf76c3652dc332a30f2a41ab427f" translate="yes" xml:space="preserve">
          <source>Interface that a class can implement to be a guard deciding if a child route can be activated. If all guards return &lt;code&gt;true&lt;/code&gt;, navigation continues. If any guard returns &lt;code&gt;false&lt;/code&gt;, navigation is cancelled. If any guard returns a &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt;, current navigation is cancelled and a new navigation begins to the &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; returned from the guard.</source>
          <target state="translated">클래스가 자식 경로를 활성화 할 수 있는지를 결정하는 가드로 구현할 수있는 인터페이스입니다. 모든 가드가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 탐색이 계속됩니다. 가드가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 탐색이 취소됩니다. 모든 경비는 반환하면 &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 을 , 현재 탐색이 취소되고 새로운 탐색이 시작됩니다 &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 이 가드에서 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="618b7ef5256168d128b4d93fe5abd44e6760f4d3" translate="yes" xml:space="preserve">
          <source>Interface that a class can implement to be a guard deciding if a child route can be activated. If all guards return &lt;code&gt;true&lt;/code&gt;, navigation will continue. If any guard returns &lt;code&gt;false&lt;/code&gt;, navigation will be cancelled. If any guard returns a &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt;, current navigation will be cancelled and a new navigation will be kicked off to the &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; returned from the guard.</source>
          <target state="translated">자식 라우트가 활성화 될 수 있는지 결정하는 보호자로 클래스가 구현할 수있는 인터페이스입니다. 모든 가드가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 탐색이 계속됩니다. 가드가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 탐색이 취소됩니다. 모든 경비는 반환하면 &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 을 , 현재 탐색이 취소되고 새로운 내비게이션은에 쫓겨됩니다 &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 이 가드에서 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="ff140188a7896c0f0df7b9ddc4cf62e57c908572" translate="yes" xml:space="preserve">
          <source>Interface that a class can implement to be a guard deciding if a child route can be activated. If all guards return &lt;code&gt;true&lt;/code&gt;, navigation will continue. If any guard returns &lt;code&gt;false&lt;/code&gt;, navigation will be cancelled. If any guard returns a &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt;, current navigation will be cancelled and a new navigation will be kicked off to the &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; returned from the guard.</source>
          <target state="translated">자식 라우트가 활성화 될 수 있는지 결정하는 보호자로 클래스가 구현할 수있는 인터페이스입니다. 모든 가드가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 탐색이 계속됩니다. 가드가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 탐색이 취소됩니다. 모든 경비는 반환하면 &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 을 , 현재 탐색이 취소되고 새로운 내비게이션은에 쫓겨됩니다 &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 이 가드에서 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="5f9ec727fd5f67833f4f7d28c1b4a64a95ad822a" translate="yes" xml:space="preserve">
          <source>Interface that a class can implement to be a guard deciding if a route can be activated. If all guards return &lt;code&gt;true&lt;/code&gt;, navigation continues. If any guard returns &lt;code&gt;false&lt;/code&gt;, navigation is cancelled. If any guard returns a &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt;, the current navigation is cancelled and a new navigation begins to the &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; returned from the guard.</source>
          <target state="translated">라우트 활성화 여부를 결정하는 가드 역할을하기 위해 클래스가 구현할 수있는 인터페이스입니다. 모든 가드가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 탐색이 계속됩니다. 가드가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 탐색이 취소됩니다. 모든 경비는 반환하면 &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 을 , 현재 탐색이 취소되고 새로운 탐색이 시작됩니다 &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 이 가드에서 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="d370cd413b65e79295cc3a38df96afee0599824f" translate="yes" xml:space="preserve">
          <source>Interface that a class can implement to be a guard deciding if a route can be activated. If all guards return &lt;code&gt;true&lt;/code&gt;, navigation continues. If any guard returns &lt;code&gt;false&lt;/code&gt;, navigation is cancelled. If any guard returns a &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt;, the current navigation is cancelled and a new navigation begins to the &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; returned from the guard.</source>
          <target state="translated">라우트 활성화 여부를 결정하는 가드 역할을하기 위해 클래스가 구현할 수있는 인터페이스입니다. 모든 가드가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 탐색이 계속됩니다. 가드가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 탐색이 취소됩니다. 모든 경비는 반환하면 &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 을 , 현재 탐색이 취소되고 새로운 탐색이 시작됩니다 &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 이 가드에서 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="1551571b2aa685eaa6e8ab4305875c5d8fb03db8" translate="yes" xml:space="preserve">
          <source>Interface that a class can implement to be a guard deciding if a route can be activated. If all guards return &lt;code&gt;true&lt;/code&gt;, navigation will continue. If any guard returns &lt;code&gt;false&lt;/code&gt;, navigation will be cancelled. If any guard returns a &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt;, current navigation will be cancelled and a new navigation will be kicked off to the &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; returned from the guard.</source>
          <target state="translated">경로를 활성화 할 수 있는지를 결정하는 보호자로 클래스가 구현할 수있는 인터페이스입니다. 모든 가드가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 탐색이 계속됩니다. 가드가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 탐색이 취소됩니다. 모든 경비는 반환하면 &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 을 , 현재 탐색이 취소되고 새로운 내비게이션은에 쫓겨됩니다 &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 이 가드에서 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="db6235325e50211534e110c30d230e1939bbd7e2" translate="yes" xml:space="preserve">
          <source>Interface that a class can implement to be a guard deciding if a route can be activated. If all guards return &lt;code&gt;true&lt;/code&gt;, navigation will continue. If any guard returns &lt;code&gt;false&lt;/code&gt;, navigation will be cancelled. If any guard returns a &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt;, current navigation will be cancelled and a new navigation will be kicked off to the &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; returned from the guard.</source>
          <target state="translated">경로를 활성화 할 수 있는지를 결정하는 보호자로 클래스가 구현할 수있는 인터페이스입니다. 모든 가드가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 탐색이 계속됩니다. 가드가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 탐색이 취소됩니다. 모든 경비는 반환하면 &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 을 , 현재 탐색이 취소되고 새로운 내비게이션은에 쫓겨됩니다 &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 이 가드에서 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="ff66dd9940e5fc1eaf1f9f31562fd3ffff52df63" translate="yes" xml:space="preserve">
          <source>Interface that a class can implement to be a guard deciding if a route can be deactivated. If all guards return &lt;code&gt;true&lt;/code&gt;, navigation continues. If any guard returns &lt;code&gt;false&lt;/code&gt;, navigation is cancelled. If any guard returns a &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt;, current navigation is cancelled and a new navigation begins to the &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; returned from the guard.</source>
          <target state="translated">클래스가 경로를 비활성화 할 수 있는지 결정하는 가드로 구현할 수있는 인터페이스입니다. 모든 가드가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 탐색이 계속됩니다. 가드가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 탐색이 취소됩니다. 모든 경비는 반환하면 &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 을 , 현재 탐색이 취소되고 새로운 탐색이 시작됩니다 &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 이 가드에서 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="b846a1dd4c0cda77778910c5d707df7a5a6026fd" translate="yes" xml:space="preserve">
          <source>Interface that a class can implement to be a guard deciding if a route can be deactivated. If all guards return &lt;code&gt;true&lt;/code&gt;, navigation continues. If any guard returns &lt;code&gt;false&lt;/code&gt;, navigation is cancelled. If any guard returns a &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt;, current navigation is cancelled and a new navigation begins to the &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; returned from the guard.</source>
          <target state="translated">클래스가 경로를 비활성화 할 수 있는지 결정하는 가드로 구현할 수있는 인터페이스입니다. 모든 가드가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 탐색이 계속됩니다. 가드가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 탐색이 취소됩니다. 모든 경비는 반환하면 &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 을 , 현재 탐색이 취소되고 새로운 탐색이 시작됩니다 &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 이 가드에서 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="2ab6f18536cd13083f15ab9129ff97d10da6e8d6" translate="yes" xml:space="preserve">
          <source>Interface that a class can implement to be a guard deciding if a route can be deactivated. If all guards return &lt;code&gt;true&lt;/code&gt;, navigation will continue. If any guard returns &lt;code&gt;false&lt;/code&gt;, navigation will be cancelled. If any guard returns a &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt;, current navigation will be cancelled and a new navigation will be kicked off to the &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; returned from the guard.</source>
          <target state="translated">경로를 비활성화 할 수 있는지를 결정하는 보호자로 클래스가 구현할 수있는 인터페이스입니다. 모든 가드가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 탐색이 계속됩니다. 가드가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 탐색이 취소됩니다. 모든 경비는 반환하면 &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 을 , 현재 탐색이 취소되고 새로운 내비게이션은에 쫓겨됩니다 &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 이 가드에서 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="679e3b4aabe2bdba94497f1ab16312f39b501277" translate="yes" xml:space="preserve">
          <source>Interface that a class can implement to be a guard deciding if a route can be deactivated. If all guards return &lt;code&gt;true&lt;/code&gt;, navigation will continue. If any guard returns &lt;code&gt;false&lt;/code&gt;, navigation will be cancelled. If any guard returns a &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt;, current navigation will be cancelled and a new navigation will be kicked off to the &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; returned from the guard.</source>
          <target state="translated">경로를 비활성화 할 수 있는지를 결정하는 보호자로 클래스가 구현할 수있는 인터페이스입니다. 모든 가드가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 탐색이 계속됩니다. 가드가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 탐색이 취소됩니다. 모든 경비는 반환하면 &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 을 , 현재 탐색이 취소되고 새로운 내비게이션은에 쫓겨됩니다 &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 이 가드에서 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="c42293e0f6055cbed8f6ec3d952ba787d4b46e25" translate="yes" xml:space="preserve">
          <source>Interface that a class can implement to be a guard deciding if children can be loaded.</source>
          <target state="translated">자식을로드 할 수 있는지를 결정하는 보호자로 클래스가 구현할 수있는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="f8b9288cc98a27c1da610942b0801f722868ae04" translate="yes" xml:space="preserve">
          <source>Interface that a class can implement to be a guard deciding if children can be loaded. If all guards return &lt;code&gt;true&lt;/code&gt;, navigation continues. If any guard returns &lt;code&gt;false&lt;/code&gt;, navigation is cancelled. If any guard returns a &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt;, current navigation is cancelled and a new navigation starts to the &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; returned from the guard.</source>
          <target state="translated">클래스가 자식을로드 할 수 있는지를 결정하는 가드로 구현할 수있는 인터페이스입니다. 모든 가드가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 탐색이 계속됩니다. 가드가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 탐색이 취소됩니다. 모든 경비는 반환하면 &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 을 , 현재 탐색이 취소되고에 새로운 탐색이 시작됩니다 &lt;code&gt;&lt;a href=&quot;router/urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 은 가드에서 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="9ec3033b72314d711e1348f87c857ff9df7af33d" translate="yes" xml:space="preserve">
          <source>Interface that a class can implement to be a guard deciding if children can be loaded. If all guards return &lt;code&gt;true&lt;/code&gt;, navigation continues. If any guard returns &lt;code&gt;false&lt;/code&gt;, navigation is cancelled. If any guard returns a &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt;, current navigation is cancelled and a new navigation starts to the &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; returned from the guard.</source>
          <target state="translated">클래스가 자식을로드 할 수 있는지를 결정하는 가드로 구현할 수있는 인터페이스입니다. 모든 가드가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 탐색이 계속됩니다. 가드가 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 탐색이 취소됩니다. 모든 경비는 반환하면 &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 을 , 현재 탐색이 취소되고에 새로운 탐색이 시작됩니다 &lt;code&gt;&lt;a href=&quot;urltree&quot;&gt;UrlTree&lt;/a&gt;&lt;/code&gt; 은 가드에서 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="364f380bef9f10b167def7bdabd0691206b530fd" translate="yes" xml:space="preserve">
          <source>Interface that classes can implement to be a data provider. A data provider class can be used with the router to resolve data during navigation. The interface defines a &lt;code&gt;&lt;a href=&quot;../core/reflectiveinjector#resolve&quot;&gt;resolve()&lt;/a&gt;&lt;/code&gt; method that will be invoked when the navigation starts. The router will then wait for the data to be resolved before the route is finally activated.</source>
          <target state="translated">클래스가 데이터 공급자로 구현할 수있는 인터페이스입니다. 데이터 제공자 클래스는 탐색 중에 데이터를 해결하기 위해 라우터와 함께 사용될 수 있습니다. 인터페이스는 탐색이 시작될 때 호출 될 &lt;code&gt;&lt;a href=&quot;../core/reflectiveinjector#resolve&quot;&gt;resolve()&lt;/a&gt;&lt;/code&gt; 메소드를 정의 합니다. 라우터는 경로가 최종적으로 활성화되기 전에 데이터가 해결 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="336ad0810efbe57a2c014e406a008686e9defe4c" translate="yes" xml:space="preserve">
          <source>Interface that classes can implement to be a data provider. A data provider class can be used with the router to resolve data during navigation. The interface defines a &lt;code&gt;&lt;a href=&quot;core/reflectiveinjector#resolve&quot;&gt;resolve()&lt;/a&gt;&lt;/code&gt; method that will be invoked when the navigation starts. The router will then wait for the data to be resolved before the route is finally activated.</source>
          <target state="translated">클래스가 데이터 공급자로 구현할 수있는 인터페이스입니다. 데이터 제공자 클래스는 탐색 중에 데이터를 해결하기 위해 라우터와 함께 사용될 수 있습니다. 인터페이스는 탐색이 시작될 때 호출 될 &lt;code&gt;&lt;a href=&quot;core/reflectiveinjector#resolve&quot;&gt;resolve()&lt;/a&gt;&lt;/code&gt; 메소드를 정의 합니다. 라우터는 경로가 최종적으로 활성화되기 전에 데이터가 해결 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="c21234c017f5d910ba8b68062b70053a6f22de69" translate="yes" xml:space="preserve">
          <source>Interface that classes can implement to be a data provider. A data provider class can be used with the router to resolve data during navigation. The interface defines a &lt;code&gt;resolve()&lt;/code&gt; method that is invoked when the navigation starts. The router waits for the data to be resolved before the route is finally activated.</source>
          <target state="translated">클래스가 데이터 공급자로 구현할 수있는 인터페이스입니다. 데이터 공급자 클래스를 라우터와 함께 사용하여 탐색 중에 데이터를 확인할 수 있습니다. 인터페이스는 탐색이 시작될 때 호출 되는 &lt;code&gt;resolve()&lt;/code&gt; 메소드를 정의 합니다. 라우터는 경로가 최종적으로 활성화되기 전에 데이터가 해결 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="cd29d518f005626eb95c3c088e7f4c477fbfc0c8" translate="yes" xml:space="preserve">
          <source>Interfaces are optional (technically)</source>
          <target state="translated">인터페이스는 선택 사항입니다 (기술적으로).</target>
        </trans-unit>
        <trans-unit id="0876cab9619be6a4ff7f8271f44afd88e6881f3c" translate="yes" xml:space="preserve">
          <source>Internal reference to the view model value.</source>
          <target state="translated">뷰 모델 값에 대한 내부 참조</target>
        </trans-unit>
        <trans-unit id="c8abcefa3f2571ad565289956a9b68baa5b5d92e" translate="yes" xml:space="preserve">
          <source>Internal.</source>
          <target state="translated">Internal.</target>
        </trans-unit>
        <trans-unit id="5fc8faa1decb29c0de03ec7af94ce77c99a7f168" translate="yes" xml:space="preserve">
          <source>Internally, Angular creates &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; instances and registers them with an &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; directive that Angular attached to the &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tag. Each &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; is registered under the name you assigned to the &lt;code&gt;name&lt;/code&gt; attribute. Read more in the previous section, &lt;a href=&quot;forms#ngForm&quot;&gt;The NgForm directive&lt;/a&gt;.</source>
          <target state="translated">내부적으로 Angular는 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 인스턴스를 만들고 Angular가 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 태그에 연결된 &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; 지시문에 등록합니다 . 각 &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;name&lt;/code&gt; 속성에 지정한 이름으로 등록됩니다 . 이전 섹션 인 &lt;a href=&quot;forms#ngForm&quot;&gt;NgForm 지시문&lt;/a&gt; 에서 자세히 읽어보십시오 .</target>
        </trans-unit>
        <trans-unit id="fbce7514dd339094119f9b2d11f6944248b678c0" translate="yes" xml:space="preserve">
          <source>Internally, Autoprefixer relies on a library called &lt;a href=&quot;https://github.com/browserslist/browserslist&quot;&gt;Browserslist&lt;/a&gt; to figure out which browsers to support with prefixing. Browserlist looks for configuration options in a &lt;code&gt;browserslist&lt;/code&gt; property of the package configuration file, or in a configuration file named &lt;code&gt;.browserslistrc&lt;/code&gt;. Autoprefixer looks for the &lt;code&gt;browserslist&lt;/code&gt; configuration when it prefixes your CSS.</source>
          <target state="translated">내부적으로 Autoprefixer는 &lt;a href=&quot;https://github.com/browserslist/browserslist&quot;&gt;Browserslist&lt;/a&gt; 라는 라이브러리 를 사용하여 접두사를 지원하는 브라우저를 찾습니다 . Browserlist는 패키지 구성 파일 의 &lt;code&gt;browserslist&lt;/code&gt; 속성 또는 &lt;code&gt;.browserslistrc&lt;/code&gt; 라는 구성 파일에서 구성 옵션을 찾습니다 . 자동 접두사는 CSS 접두사로 &lt;code&gt;browserslist&lt;/code&gt; 구성을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="4a58c18b307abf758e113f2eeb5fbc842f890084" translate="yes" xml:space="preserve">
          <source>Internally, all static methods cover methods of the current runtime &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; instance, which is also returned by the &lt;code&gt;&lt;a href=&quot;../api/core/testing/gettestbed&quot;&gt;getTestBed&lt;/a&gt;()&lt;/code&gt; function.</source>
          <target state="translated">내부적으로 모든 정적 메서드는 현재 런타임 &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; 인스턴스 의 메서드를 &lt;code&gt;&lt;a href=&quot;../api/core/testing/gettestbed&quot;&gt;getTestBed&lt;/a&gt;()&lt;/code&gt; 함수에 의해 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="7fc8aa8e4bf0323d00c15a7a4943933fbf6fb9ae" translate="yes" xml:space="preserve">
          <source>Internationalization (i18n)</source>
          <target state="translated">국제화 (i18n)</target>
        </trans-unit>
        <trans-unit id="507e49b9434f4f57a7db4cbad55a28939d060bc6" translate="yes" xml:space="preserve">
          <source>Internationalization (i18n) Guide</source>
          <target state="translated">국제화 (i18n) 안내서</target>
        </trans-unit>
        <trans-unit id="2ceac5014bae5904c30ddb08d140fc4b7928f48a" translate="yes" xml:space="preserve">
          <source>Interpolated content is always escaped&amp;mdash;the HTML isn't interpreted and the browser displays angle brackets in the element's text content.</source>
          <target state="translated">보간 된 내용은 항상 이스케이프됩니다. HTML은 해석되지 않으며 브라우저는 요소의 텍스트 내용에 꺾쇠 괄호를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="c0d5f0c6fbe15f854b359c7977dd0323a5c988dc" translate="yes" xml:space="preserve">
          <source>Interpolation &lt;code&gt;{{ }}&lt;/code&gt;</source>
          <target state="translated">보간 &lt;code&gt;{{ }}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="15241bfb250242f27aea0edbf654c3c0b6eff9c1" translate="yes" xml:space="preserve">
          <source>Interpolation &lt;code&gt;{{...}}&lt;/code&gt;</source>
          <target state="translated">보간 &lt;code&gt;{{...}}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cad50a4f2d79b7204d7fa4ee552feedad7652e19" translate="yes" xml:space="preserve">
          <source>Interpolation Property Attribute Class Style</source>
          <target state="translated">보간 속성 속성 클래스 스타일</target>
        </trans-unit>
        <trans-unit id="9ece64b7320504fa399841a6d62c9a3dbd7784b2" translate="yes" xml:space="preserve">
          <source>Interpolation allows you to incorporate calculated strings into the text between HTML element tags and within attribute assignments. Template expressions are what you use to calculate those strings.</source>
          <target state="translated">보간을 통해 계산 된 문자열을 HTML 요소 태그 사이 및 속성 할당 내의 텍스트에 통합 할 수 있습니다. 템플릿 표현식은 해당 문자열을 계산하는 데 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="37649b57fe7cf149ac8228d3effb6bd49c8873d2" translate="yes" xml:space="preserve">
          <source>Interpolation and Template Expressions</source>
          <target state="translated">보간 및 템플릿 표현식</target>
        </trans-unit>
        <trans-unit id="3c8d084daa415eab3f33192cfd217ea5a72927e7" translate="yes" xml:space="preserve">
          <source>Interpolation and template expressions</source>
          <target state="translated">보간 및 템플릿 표현식</target>
        </trans-unit>
        <trans-unit id="3d349805b5ca7ad2d64bafc375f7ad1fb4256432" translate="yes" xml:space="preserve">
          <source>Interpolation handles the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags differently than property binding but both approaches render the content harmlessly. The following is the browser output of the &lt;code&gt;evilTitle&lt;/code&gt; examples.</source>
          <target state="translated">보간은 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그를 속성 바인딩과 다르게 처리 하지만 두 방법 모두 내용을 무해하게 만듭니다. 다음은 &lt;code&gt;evilTitle&lt;/code&gt; 예제 의 브라우저 출력입니다 .</target>
        </trans-unit>
        <trans-unit id="782432f138e6c2551df031091e97964894c9f91b" translate="yes" xml:space="preserve">
          <source>Interpolation handles the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags differently than property binding, but both approaches render the content harmlessly. The following is the browser output of the sanitized &lt;code&gt;evilTitle&lt;/code&gt; example.</source>
          <target state="translated">보간은 속성 바인딩과는 다르게 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그를 처리 하지만 두 방법 모두 콘텐츠를 무해하게 렌더링합니다. 다음은 삭제 된 &lt;code&gt;evilTitle&lt;/code&gt; 예제 의 브라우저 출력입니다 .</target>
        </trans-unit>
        <trans-unit id="4d3d39599f1e253e5d15323a3b40cf507133a6e4" translate="yes" xml:space="preserve">
          <source>Interpolation is a convenient alternative to property binding in many cases. When rendering data values as strings, there is no technical reason to prefer one form to the other, though readability tends to favor interpolation. However, &lt;em&gt;when setting an element property to a non-string data value, you must use property binding&lt;/em&gt;.</source>
          <target state="translated">보간은 많은 경우 속성 바인딩에 대한 편리한 대안입니다. 데이터 값을 문자열로 렌더링 할 때는 가독성이 내삽을 선호하는 경향이 있지만 한 형식을 다른 형식을 선호하는 기술적 이유는 없습니다. 그러나 &lt;em&gt;요소 특성을 문자열이 아닌 데이터 값으로 설정하는 경우 특성 바인딩을 사용해야합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7a70d18508c1f3509d81cd385ef5f470b52a349a" translate="yes" xml:space="preserve">
          <source>Interpolation refers to embedding expressions into marked up text. By default, interpolation uses as its delimiter the double curly braces, &lt;code&gt;{{&lt;/code&gt; and &lt;code&gt;}}&lt;/code&gt;.</source>
          <target state="translated">보간은 마크 업 된 텍스트에 표현식을 포함시키는 것을 말합니다. 기본적으로 보간은 이중 중괄호 &lt;code&gt;{{&lt;/code&gt; and &lt;code&gt;}}&lt;/code&gt; 를 구분 기호로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="18549284fbd31fe50d2af013bc5f2f807b255c5d" translate="yes" xml:space="preserve">
          <source>Interpolation: &lt;code&gt;&amp;lt;comp greeting=&quot;Hello {{name}}!&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">보간 : &lt;code&gt;&amp;lt;comp greeting=&quot;Hello {{name}}!&quot;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="148008a6c97111d9a4baac98fac041378bd84ebd" translate="yes" xml:space="preserve">
          <source>Intl</source>
          <target state="translated">Intl</target>
        </trans-unit>
        <trans-unit id="b3e69f2a42a9ebe8a619598951f3e7f96f8435fa" translate="yes" xml:space="preserve">
          <source>Intl API</source>
          <target state="translated">국제 API</target>
        </trans-unit>
        <trans-unit id="e11d234c418f535d475bc472816ff39f325d47a4" translate="yes" xml:space="preserve">
          <source>Introducing Angular pipes, a way to write display-value transformations that you can declare in your HTML.</source>
          <target state="translated">HTML로 선언 할 수있는 표시 값 변환을 작성하는 방법 인 각도 파이프를 소개합니다.</target>
        </trans-unit>
        <trans-unit id="39324c26031e2c93ca39870003886cbe2b2e25bf" translate="yes" xml:space="preserve">
          <source>Introducing another container element&amp;mdash;typically a &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;&amp;mdash;to group the elements under a single &lt;em&gt;root&lt;/em&gt; is usually harmless. &lt;em&gt;Usually&lt;/em&gt; ... but not &lt;em&gt;always&lt;/em&gt;.</source>
          <target state="translated">단일 &lt;em&gt;루트&lt;/em&gt; 아래에 요소를 그룹화하기 위해 다른 컨테이너 요소 (일반적으로 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; ) 를 도입하는 것은 일반적으로 무해합니다. &lt;em&gt;보통은&lt;/em&gt; 아니지만 &lt;em&gt;항상 그런&lt;/em&gt; 것은 &lt;em&gt;아닙니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e4f43f29bd2dc8b1b3dcc99d7b8cc0944588ec40" translate="yes" xml:space="preserve">
          <source>Introduction to Angular animations</source>
          <target state="translated">각도 애니메이션 소개</target>
        </trans-unit>
        <trans-unit id="77fdbd720d56c685098d00d0ba39402f14f89357" translate="yes" xml:space="preserve">
          <source>Introduction to Angular concepts</source>
          <target state="translated">Angular 개념 소개</target>
        </trans-unit>
        <trans-unit id="7a88af9c7af43c51b51f00d5d0cbef442684cf51" translate="yes" xml:space="preserve">
          <source>Introduction to Components</source>
          <target state="translated">구성 요소 소개</target>
        </trans-unit>
        <trans-unit id="037e78ee72bb786b3b99727257ded097b29ed22c" translate="yes" xml:space="preserve">
          <source>Introduction to Modules</source>
          <target state="translated">모듈 소개</target>
        </trans-unit>
        <trans-unit id="77695aa23083353741cc8e577e0d1f52b59146ec" translate="yes" xml:space="preserve">
          <source>Introduction to Services and DI</source>
          <target state="translated">서비스 및 DI 소개</target>
        </trans-unit>
        <trans-unit id="1891a5d7cdaa920a5fcf4904feb061ee52d40600" translate="yes" xml:space="preserve">
          <source>Introduction to Template-driven forms</source>
          <target state="translated">템플릿 기반 양식 소개</target>
        </trans-unit>
        <trans-unit id="47739d8d7f900214f17011b232b38873a5ba56b9" translate="yes" xml:space="preserve">
          <source>Introduction to components</source>
          <target state="translated">구성 요소 소개</target>
        </trans-unit>
        <trans-unit id="4338ab77cbd7d66a84347792c0bded85b09f38fe" translate="yes" xml:space="preserve">
          <source>Introduction to components and templates</source>
          <target state="translated">구성 요소 및 템플릿 소개</target>
        </trans-unit>
        <trans-unit id="b56bd365155a67ad44616a3cfaa0c6f87e0813cf" translate="yes" xml:space="preserve">
          <source>Introduction to forms in Angular</source>
          <target state="translated">Angular 양식 소개</target>
        </trans-unit>
        <trans-unit id="7cccb3d4fcea31dd15a08fa2a5f77cb23a273075" translate="yes" xml:space="preserve">
          <source>Introduction to modules</source>
          <target state="translated">모듈 소개</target>
        </trans-unit>
        <trans-unit id="0709e3f3783847d46c02c3e879b4d2aa32e91ee8" translate="yes" xml:space="preserve">
          <source>Introduction to reactive forms</source>
          <target state="translated">반응 형 소개</target>
        </trans-unit>
        <trans-unit id="de2848f98042a65b60c04421d206e68ca3490213" translate="yes" xml:space="preserve">
          <source>Introduction to services and dependency injection</source>
          <target state="translated">서비스 및 의존성 주입 소개</target>
        </trans-unit>
        <trans-unit id="31bd018950090c5c6cd607bed84ff15ec170f2b3" translate="yes" xml:space="preserve">
          <source>Introductory application demonstrating Angular features. For more information, see &lt;a href=&quot;start&quot;&gt;Getting started&lt;/a&gt;.</source>
          <target state="translated">Angular 기능을 보여주는 입문 응용 프로그램입니다. 자세한 내용은 &lt;a href=&quot;start&quot;&gt;시작하기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d784ef7dd559f90510b1c51d9366c7111e5f69d8" translate="yes" xml:space="preserve">
          <source>Introductory documentation for the root app.</source>
          <target state="translated">루트 앱에 대한 입문서.</target>
        </trans-unit>
        <trans-unit id="aace78cff547d716715d45872adbd62b2b745412" translate="yes" xml:space="preserve">
          <source>Invert the selection specified by the 'grep' option.</source>
          <target state="translated">'grep'옵션으로 지정된 선택을 반전합니다.</target>
        </trans-unit>
        <trans-unit id="ef11e3a45fcbddfa8943f16664c96693dbbd2dac" translate="yes" xml:space="preserve">
          <source>Invoke Push Notifications by pushing a message with the following payload.</source>
          <target state="translated">다음 페이로드로 메시지를 푸시하여 푸시 알림을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="88241a92475e9beecdb4c31ab3c1fdf7de6dab59" translate="yes" xml:space="preserve">
          <source>Invoke as decorator.</source>
          <target state="translated">데코레이터로 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="59d70d5937eb1157be8db1664978fb31d22e53bb" translate="yes" xml:space="preserve">
          <source>Invoke the tool on the command line through the &lt;code&gt;ng&lt;/code&gt; executable. Online help is available on the command line. Enter the following to list commands or options for a given command (such as &lt;a href=&quot;https://angular.io/cli/generate&quot;&gt;generate&lt;/a&gt;) with a short description.</source>
          <target state="translated">&lt;code&gt;ng&lt;/code&gt; 실행 파일을 통해 명령 행에서 도구를 호출하십시오 . 명령 행에서 온라인 도움말을 사용할 수 있습니다. 간단한 설명과 함께 주어진 명령 (예 : &lt;a href=&quot;https://angular.io/cli/generate&quot;&gt;generate&lt;/a&gt; )에 대한 명령 또는 옵션을 나열하려면 다음을 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="bcf4fe5e09f5109017dca07a3cf2d814a91d3785" translate="yes" xml:space="preserve">
          <source>Invoke this method to explicitly process change detection and its side-effects.</source>
          <target state="translated">변경 감지 및 해당 부작용을 명시 적으로 처리하려면이 메소드를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="f71314c70f579581e6aeb34f93359ab3921893e3" translate="yes" xml:space="preserve">
          <source>Invokes the deploy builder for a specified project or for the default project in the workspace.</source>
          <target state="translated">작업 공간에서 지정된 프로젝트 또는 기본 프로젝트에 대한 배치 빌더를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="d1940ca4cbd9dbd0eb38f2bc2ef028f64f0e3ebe" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;{{ 'ok' | repeat:3 }}&lt;/code&gt; in a template produces &lt;code&gt;okokok&lt;/code&gt;.</source>
          <target state="translated">호출 &lt;code&gt;{{ 'ok' | repeat:3 }}&lt;/code&gt; 은 &lt;code&gt;okokok&lt;/code&gt; 을 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="8ecb88a0d7e8f36c9744ae06147a6fdb631de233" translate="yes" xml:space="preserve">
          <source>Is &lt;code&gt;Lightswitch.clicked()&lt;/code&gt; bound to anything such that the user can invoke it?</source>
          <target state="translated">되어 &lt;code&gt;Lightswitch.clicked()&lt;/code&gt; 사용자가 호출 할 수 있도록 어떤 바인딩?</target>
        </trans-unit>
        <trans-unit id="ac8f08f500ef6eac216f7e2f6acc17d63f159658" translate="yes" xml:space="preserve">
          <source>Is its own tax return editing session.</source>
          <target state="translated">자체 세금 환급 편집 세션입니다.</target>
        </trans-unit>
        <trans-unit id="26b69a05483ffab3d41808c70bd31cc4f9e37b16" translate="yes" xml:space="preserve">
          <source>Is the &lt;code&gt;Lightswitch.message&lt;/code&gt; displayed?</source>
          <target state="translated">는 IS &lt;code&gt;Lightswitch.message&lt;/code&gt; 가 표시되는 이유는 무엇인가요?</target>
        </trans-unit>
        <trans-unit id="3ccfab603206383b681f28870947bbf1d675dda5" translate="yes" xml:space="preserve">
          <source>Is the hero name displayed as expected (i.e, in uppercase)?</source>
          <target state="translated">영웅 이름이 예상대로 표시됩니까 (예 : 대문자)?</target>
        </trans-unit>
        <trans-unit id="62759ede6184ca8bf2ccab209b605f3ebc11e427" translate="yes" xml:space="preserve">
          <source>Is the welcome message displayed by the template of &lt;code&gt;WelcomeComponent&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;WelcomeComponent&lt;/code&gt; 템플릿에 환영 메시지가 표시 됩니까?</target>
        </trans-unit>
        <trans-unit id="a59c6ce02a2484a37dbf441374573cec25db7336" translate="yes" xml:space="preserve">
          <source>It &lt;em&gt;creates&lt;/em&gt; the &lt;code&gt;TestHostComponent&lt;/code&gt; instead of the &lt;code&gt;DashboardHeroComponent&lt;/code&gt;.</source>
          <target state="translated">그것은 &lt;em&gt;생성 &lt;/em&gt; &lt;code&gt;TestHostComponent&lt;/code&gt; 대신의 &lt;code&gt;DashboardHeroComponent&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="94b8e34baeefba35b8b89673f3480499d94bf056" translate="yes" xml:space="preserve">
          <source>It &lt;em&gt;declares&lt;/em&gt; both the &lt;code&gt;DashboardHeroComponent&lt;/code&gt; and the &lt;code&gt;TestHostComponent&lt;/code&gt;.</source>
          <target state="translated">이 &lt;em&gt;선언&lt;/em&gt; 양쪽 &lt;code&gt;DashboardHeroComponent&lt;/code&gt; 과 &lt;code&gt;TestHostComponent&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="b21529cea838e2b6b15441950bdae0264cbbefbf" translate="yes" xml:space="preserve">
          <source>It accepts a &lt;code&gt;text/html&lt;/code&gt; response (as determined by the value of the &lt;code&gt;Accept&lt;/code&gt; header).</source>
          <target state="translated">그것은 수용 &lt;code&gt;text/html&lt;/code&gt; (의 값에 의해 결정된 바와 같이 응답을 &lt;code&gt;Accept&lt;/code&gt; 헤더).</target>
        </trans-unit>
        <trans-unit id="aaf41bb3d14f2e414d4fcc67dfff4cef7f7b3b73" translate="yes" xml:space="preserve">
          <source>It accepts a domain model as an optional &lt;code&gt;&lt;a href=&quot;../core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt;. If you have a one-way binding to &lt;code&gt;&lt;a href=&quot;ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;[]&lt;/code&gt; syntax, changing the domain model's value in the component class sets the value in the view. If you have a two-way binding with &lt;code&gt;[()]&lt;/code&gt; syntax (also known as 'banana-in-a-box syntax'), the value in the UI always syncs back to the domain model in your class.</source>
          <target state="translated">도메인 모델을 선택적인 &lt;code&gt;&lt;a href=&quot;../core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; 으로 받아들 입니다. 당신이 결합 단방향있는 경우 &lt;code&gt;&lt;a href=&quot;ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 로를 &lt;code&gt;[]&lt;/code&gt; 구문은 구성 요소 클래스의 도메인 모델의 값을 변경하면 뷰의 값을 설정합니다. &lt;code&gt;[()]&lt;/code&gt; 구문 ( 'banana-in-a-box 구문'이라고도 함 )을 사용하는 양방향 바인딩이 있는 경우 UI의 값은 항상 클래스의 도메인 모델에 다시 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="e2ae87480d790dfa92913ec2c7c57b94a67e403b" translate="yes" xml:space="preserve">
          <source>It accepts a domain model as an optional &lt;code&gt;&lt;a href=&quot;../core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt;. If you have a one-way binding to &lt;code&gt;&lt;a href=&quot;ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;[]&lt;/code&gt; syntax, changing the value of the domain model in the component class sets the value in the view. If you have a two-way binding with &lt;code&gt;[()]&lt;/code&gt; syntax (also known as 'banana-box syntax'), the value in the UI always syncs back to the domain model in your class.</source>
          <target state="translated">도메인 모델을 선택적인 &lt;code&gt;&lt;a href=&quot;../core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; 으로 받아들 입니다. 만약 결합 단방향 있다면 &lt;code&gt;&lt;a href=&quot;ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 로를 &lt;code&gt;[]&lt;/code&gt; 구문은 컴포넌트 클래스 도메인 모델의 값을 변경하면 볼의 값을 설정한다. &lt;code&gt;[()]&lt;/code&gt; 구문 ( '바나나 상자 구문'이라고도 함 ) 으로 양방향 바인딩을 사용 하는 경우 UI의 값은 항상 클래스의 도메인 모델과 다시 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="d1ef5600898e0ae01610d043a4a9f983f75191ed" translate="yes" xml:space="preserve">
          <source>It accepts both super-sets and sub-sets of the array without throwing an error.</source>
          <target state="translated">오류를 발생시키지 않고 배열의 수퍼 세트와 하위 세트를 모두 허용합니다.</target>
        </trans-unit>
        <trans-unit id="4bccd25078f3c01228e73bdbae0161e45566c3cb" translate="yes" xml:space="preserve">
          <source>It accepts both super-sets and sub-sets of the group without throwing an error.</source>
          <target state="translated">오류를 발생시키지 않고 그룹의 수퍼 세트와 하위 세트를 모두 허용합니다.</target>
        </trans-unit>
        <trans-unit id="c13d32540d684ec2971d8a6aa07a438b2688dad0" translate="yes" xml:space="preserve">
          <source>It accepts the string name of the nested &lt;code&gt;&lt;a href=&quot;formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; you want to link, and will look for a &lt;code&gt;&lt;a href=&quot;formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; registered with that name in the parent &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; instance you passed into &lt;code&gt;&lt;a href=&quot;formgroupdirective&quot;&gt;FormGroupDirective&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그것은 중첩의 캐릭터 이름을 받아 &lt;code&gt;&lt;a href=&quot;formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; 연결하려는를하고 찾을 것이다 &lt;code&gt;&lt;a href=&quot;formarray&quot;&gt;FormArray&lt;/a&gt;&lt;/code&gt; 는 부모에 그 이름으로 등록 &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 의 당신에 전달 예를 &lt;code&gt;&lt;a href=&quot;formgroupdirective&quot;&gt;FormGroupDirective&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92bb130acb69f1ba28771910ed692ccf19a723f9" translate="yes" xml:space="preserve">
          <source>It accepts the string name of the nested &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; to link, and looks for a &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; registered with that name in the parent &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; instance you passed into &lt;code&gt;&lt;a href=&quot;formgroupdirective&quot;&gt;FormGroupDirective&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그것은 중첩의 캐릭터 이름을 받아 &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 링크를하고 찾습니다 &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 는 부모에 그 이름으로 등록 &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 의 당신에 전달 예를 &lt;code&gt;&lt;a href=&quot;formgroupdirective&quot;&gt;FormGroupDirective&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8a6c222dced75a612315602dfc6bf860b4fcfb4" translate="yes" xml:space="preserve">
          <source>It allows instantiating or even loading the Angular part lazily, which improves the initial loading time. In some cases this may waive the cost of running a second framework altogether.</source>
          <target state="translated">앵귤러 파트를 느리게 인스턴스화하거나 로딩 할 수있어 초기 로딩 시간이 향상됩니다. 경우에 따라 두 번째 프레임 워크를 모두 실행하는 비용이 면제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e63edca4aba60ae769633e65db45ce6b8cda1c2" translate="yes" xml:space="preserve">
          <source>It allows loading/bootstrapping the Angular part of a hybrid application lazily and not having to pay the cost up-front. For example, you can have an AngularJS application that uses Angular for specific routes and only instantiate the Angular modules if/when the user visits one of these routes.</source>
          <target state="translated">하이브리드 애플리케이션의 Angular 부분을 느리게로드 / 부트 스트랩 할 수 있으며 선불 비용을 지불하지 않아도됩니다. 예를 들어 특정 경로에 Angular를 사용하는 AngularJS 응용 프로그램을 사용하고 사용자가 이러한 경로 중 하나를 방문 할 때만 Angular 모듈을 인스턴스화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fb8a3420da7cbbbfae709f23348ef16e743e69f" translate="yes" xml:space="preserve">
          <source>It also contains properties to access the &lt;a href=&quot;upgrademodule#injector&quot;&gt;root injector&lt;/a&gt;, the bootstrap &lt;code&gt;&lt;a href=&quot;../../core/ngzone&quot;&gt;NgZone&lt;/a&gt;&lt;/code&gt; and the &lt;a href=&quot;https://docs.angularjs.org/api/auto/service/%24injector&quot;&gt;AngularJS $injector&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;upgrademodule#injector&quot;&gt;루트 인젝터&lt;/a&gt; , 부트 스트랩 &lt;code&gt;&lt;a href=&quot;../../core/ngzone&quot;&gt;NgZone&lt;/a&gt;&lt;/code&gt; 및 &lt;a href=&quot;https://docs.angularjs.org/api/auto/service/%24injector&quot;&gt;AngularJS $ injector&lt;/a&gt; 에 액세스 할 수있는 속성도 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f071a0b65644eeeccb34ee7fdae07a260e0e9140" translate="yes" xml:space="preserve">
          <source>It also creates the following workspace and starter project files:</source>
          <target state="translated">또한 다음 작업 공간 및 스타터 프로젝트 파일을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="6c32f9929135cab965aabc48fd19faf6dd6dce8a" translate="yes" xml:space="preserve">
          <source>It also generates an initial test file for the component, &lt;code&gt;banner-external.component.spec.ts&lt;/code&gt;, that looks like this:</source>
          <target state="translated">또한 &lt;code&gt;banner-external.component.spec.ts&lt;/code&gt; 구성 요소의 초기 테스트 파일을 다음과 같이 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8efa0771b30ff267b601afb0f7067fc48209cdec" translate="yes" xml:space="preserve">
          <source>It also has a side-effect. &lt;code&gt;SelectivePreloadingStrategyService&lt;/code&gt; logs the &lt;code&gt;path&lt;/code&gt; of a selected route in its public &lt;code&gt;preloadedModules&lt;/code&gt; array.</source>
          <target state="translated">또한 부작용이 있습니다. &lt;code&gt;SelectivePreloadingStrategyService&lt;/code&gt; 는 로그 &lt;code&gt;path&lt;/code&gt; 의 공공 장소에서 선택된 경로의 &lt;code&gt;preloadedModules&lt;/code&gt; 의 배열을.</target>
        </trans-unit>
        <trans-unit id="10fdc8fee72f7646b8b3adf2c52bb9b3221fcdfe" translate="yes" xml:space="preserve">
          <source>It appears within the template of a parent component, which binds a &lt;em&gt;hero&lt;/em&gt; to the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; property and listens for an event raised through the &lt;em&gt;selected&lt;/em&gt;&lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;&lt;/code&gt; property.</source>
          <target state="translated">&lt;em&gt;영웅&lt;/em&gt; 을 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; 속성에 바인딩 하고 &lt;em&gt;선택한 &lt;/em&gt; &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;&lt;/code&gt; 속성을 통해 발생한 이벤트를 수신 대기 하는 부모 구성 요소의 템플릿 내에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="f279ef89e1bf02c3528c17799c4418cc58336a95" translate="yes" xml:space="preserve">
          <source>It belongs to the optional &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; and you must &lt;em&gt;opt-in&lt;/em&gt; to using it.</source>
          <target state="translated">이 옵션에 속하는 &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; 당신은 있어야 &lt;em&gt;선택-에&lt;/em&gt; 그것을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="26023f5577f25d3446bc370676b0a6f86e7e8aba" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#post&quot;&gt;HttpClient.post()&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#put&quot;&gt;put()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#put&quot;&gt;put()&lt;/a&gt;&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#post&quot;&gt;HttpClient.post()&lt;/a&gt;&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3420de52d9f27308e43685dc19d302c9fa7999ee" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#post&quot;&gt;HttpClient.post()&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;put()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;put()&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#post&quot;&gt;HttpClient.post()&lt;/a&gt;&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e20098109d5ecc4ec6a976711ca2510fe455a018" translate="yes" xml:space="preserve">
          <source>It can be created manually, as follows:</source>
          <target state="translated">다음과 같이 수동으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bc5d4c1a8b1283e28876118079505f0a82bc822" translate="yes" xml:space="preserve">
          <source>It can be problematic for an app if the version of resources it's receiving changes suddenly or without warning. See the &lt;a href=&quot;service-worker-devops#versions&quot;&gt;Versions&lt;/a&gt; section above for a description of such issues.</source>
          <target state="translated">받는 리소스 버전이 갑자기 또는 경고없이 변경되면 앱에 문제가 될 수 있습니다. 이러한 문제에 대한 설명은 위 의 &lt;a href=&quot;service-worker-devops#versions&quot;&gt;버전&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="08426e933f904dc80c16feae7eab518a4a961cf1" translate="yes" xml:space="preserve">
          <source>It can be provided to this method in one of two formats:</source>
          <target state="translated">이 방법에는 다음 두 가지 형식 중 하나로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a5b556bf784cd334e9ae2c20c87115e67fc96c1" translate="yes" xml:space="preserve">
          <source>It can be used as a base class for custom route reuse strategies, i.e. you can create your own class that extends the &lt;code&gt;&lt;a href=&quot;baseroutereusestrategy&quot;&gt;BaseRouteReuseStrategy&lt;/a&gt;&lt;/code&gt; one.</source>
          <target state="translated">사용자 지정 경로 재사용 전략을위한 기본 클래스로 사용할 수 있습니다. 즉, &lt;code&gt;&lt;a href=&quot;baseroutereusestrategy&quot;&gt;BaseRouteReuseStrategy&lt;/a&gt;&lt;/code&gt; 를 확장하는 자체 클래스를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d56cfef604890a297d3766102bad859f461f7ec" translate="yes" xml:space="preserve">
          <source>It can't just reference the &lt;code&gt;id&lt;/code&gt; property of the &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute#paramMap&quot;&gt;ActivatedRoute.paramMap&lt;/a&gt;&lt;/code&gt;. The component has to &lt;em&gt;subscribe&lt;/em&gt; to the &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute#paramMap&quot;&gt;ActivatedRoute.paramMap&lt;/a&gt;&lt;/code&gt; observable and be prepared for the &lt;code&gt;id&lt;/code&gt; to change during its lifetime.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/router/activatedroute#paramMap&quot;&gt;ActivatedRoute.paramMap&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;id&lt;/code&gt; 속성 만 참조 할 수는 없습니다 . 구성 요소가하는 &lt;em&gt;가입&lt;/em&gt; 받는 &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute#paramMap&quot;&gt;ActivatedRoute.paramMap&lt;/a&gt;&lt;/code&gt; 관찰하고 준비 할 &lt;code&gt;id&lt;/code&gt; 의 수명 기간 동안 변경 될 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cfb1bbd0359c2cf1cb726dd86d8ce0539e6977ba" translate="yes" xml:space="preserve">
          <source>It declares and exports the utility pipe, directive, and component classes.</source>
          <target state="translated">유틸리티 파이프, 지시문 및 구성 요소 클래스를 선언하고 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="d7d019223649a73995168e563585db9bbe9dadab" translate="yes" xml:space="preserve">
          <source>It defines a &lt;code&gt;heroes&lt;/code&gt; array property.</source>
          <target state="translated">&lt;code&gt;heroes&lt;/code&gt; 배열 속성을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a6f7ce9a8a99f6706e4390e417534249fdbde969" translate="yes" xml:space="preserve">
          <source>It describes features which are part of Angular Labs, and are not considered a stable, supported API.</source>
          <target state="translated">Angular Labs의 일부이며 안정적인 지원되는 API로 간주되지 않는 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8e59fc3b69ee2f0a812b49f8920bf497ae137922" translate="yes" xml:space="preserve">
          <source>It displays a short form with a header, an input box for the message, and two buttons, &quot;Send&quot; and &quot;Cancel&quot;.</source>
          <target state="translated">헤더, 메시지 입력 상자, &quot;보내기&quot;및 &quot;취소&quot;두 개의 버튼이있는 짧은 양식이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e74c4df29123d7f1b28af5c3920c37049db746dc" translate="yes" xml:space="preserve">
          <source>It displays a simple form with a header, an input box for the message, and two buttons, &quot;Send&quot; and &quot;Cancel&quot;.</source>
          <target state="translated">헤더, 메시지 입력 상자 및 &quot;보내기&quot;및 &quot;취소&quot;버튼이있는 간단한 양식을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="bf7952a8d431d45427cd14b51695264b8ed72382" translate="yes" xml:space="preserve">
          <source>It does not require you to change how you bootstrap your AngularJS app.</source>
          <target state="translated">AngularJS 앱의 부트 스트랩 방법을 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="419e645994e8d30b7174dbb517386ed3b5affc24" translate="yes" xml:space="preserve">
          <source>It doesn't figure out the types of &lt;code&gt;#refs&lt;/code&gt;, the results of pipes, the type of &lt;code&gt;$event&lt;/code&gt; in event bindings, and so on.</source>
          <target state="translated">&lt;code&gt;#refs&lt;/code&gt; 유형 , 파이프 결과, 이벤트 바인딩 의 &lt;code&gt;$event&lt;/code&gt; 유형 등을 파악하지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="6b9ed176655d2ae7894637c252aa287ceb5d8d56" translate="yes" xml:space="preserve">
          <source>It enforces the use of component best practices like &lt;code&gt;controllerAs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;controllerAs&lt;/code&gt; 와 같은 구성 요소 우수 사례를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="42cd08f715154702ba1bfcb5f060c73f70e0f76a" translate="yes" xml:space="preserve">
          <source>It expects the server to generate an id for the new hero, which it returns in the &lt;code&gt;Observable&amp;lt;Hero&amp;gt;&lt;/code&gt; to the caller.</source>
          <target state="translated">서버는 새로운 영웅의 id를 생성 할 것으로 예상되며, &lt;code&gt;Observable&amp;lt;Hero&amp;gt;&lt;/code&gt; 에서 호출자에게 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="95d0bff9d24171d2c283dde8af92d28339fe8434" translate="yes" xml:space="preserve">
          <source>It forwards that request to &lt;code&gt;next.handle()&lt;/code&gt; which ultimately calls the server and returns the server's response.</source>
          <target state="translated">그것은 그 요청을 &lt;code&gt;next.handle()&lt;/code&gt; 전달하여 궁극적으로 서버를 호출하고 서버의 응답을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cff060b2c8359f3ecbce1c4cf07f83a9266ef3a7" translate="yes" xml:space="preserve">
          <source>It has Angular properties and methods that abstract interaction with the native element. This test calls the &lt;code&gt;DebugElement.triggerEventHandler&lt;/code&gt; with the &quot;click&quot; event name. The &quot;click&quot; event binding responds by calling &lt;code&gt;DashboardHeroComponent.click()&lt;/code&gt;.</source>
          <target state="translated">네이티브 요소와의 상호 작용을 추상화하는 Angular 속성 및 메서드가 있습니다. 이 테스트 는 &quot;click&quot;이벤트 이름으로 &lt;code&gt;DebugElement.triggerEventHandler&lt;/code&gt; 를 호출합니다 . &quot;click&quot;이벤트 바인딩은 &lt;code&gt;DashboardHeroComponent.click()&lt;/code&gt; 을 호출하여 응답합니다 .</target>
        </trans-unit>
        <trans-unit id="77cb21518043d46f3f115c5e67031ef805971a8e" translate="yes" xml:space="preserve">
          <source>It has a legitimate purpose in this guide. It demonstrates how to find a &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; element, click it, and inspect a result, without engaging the full router machinery. This is a skill you may need to test a more sophisticated component, one that changes the display, re-calculates parameters, or re-arranges navigation options when the user clicks the link.</source>
          <target state="translated">이 안내서에서 합법적 인 목적을 가지고 있습니다. 전체 라우터 기계를 사용하지 않고 &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; 요소 를 찾아 클릭 한 후 결과를 검사하는 방법을 보여줍니다 . 사용자가 링크를 클릭 할 때 디스플레이를 변경하거나 매개 변수를 다시 계산하거나 탐색 옵션을 다시 정렬하는보다 복잡한 구성 요소를 테스트해야하는 기술입니다.</target>
        </trans-unit>
        <trans-unit id="e4df5dc55e01418d5fe02e4482c23400263dcc59" translate="yes" xml:space="preserve">
          <source>It has a simple template that only includes the &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt;. This component just renders the contents of the active route and nothing else.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; 만 포함하는 간단한 템플릿이 있습니다. 이 구성 요소는 활성 경로의 내용 만 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="9922a6848ec3f5a8b7802dc76ee7ad819c476823" translate="yes" xml:space="preserve">
          <source>It has good default values for directive attributes like &lt;code&gt;&lt;a href=&quot;../api/service-worker/swregistrationoptions#scope&quot;&gt;scope&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;restrict&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/service-worker/swregistrationoptions#scope&quot;&gt;scope&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;restrict&lt;/code&gt; 와 같은 지시문 속성에 대한 좋은 기본값이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1eec011488d2e2fc8d294fd38efcceda66f669ca" translate="yes" xml:space="preserve">
          <source>It has good default values for directive attributes like &lt;code&gt;scope&lt;/code&gt; and &lt;code&gt;restrict&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;scope&lt;/code&gt; 및 &lt;code&gt;restrict&lt;/code&gt; 과 같은 지시어 속성에 대한 좋은 기본값이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bea15911cc873bfe30f8a513aaa359e498d5ee43" translate="yes" xml:space="preserve">
          <source>It imports the &lt;code&gt;&lt;a href=&quot;../api/common/commonmodule&quot;&gt;CommonModule&lt;/a&gt;&lt;/code&gt; because the module's component needs common directives.</source>
          <target state="translated">모듈의 구성 요소에는 공통 지시문이 필요하므로 &lt;code&gt;&lt;a href=&quot;../api/common/commonmodule&quot;&gt;CommonModule&lt;/a&gt;&lt;/code&gt; 을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="ad4bae11dc99871b8342e876ba6993b4893ae7e5" translate="yes" xml:space="preserve">
          <source>It improves performance by avoiding unnecessary change detection runs while giving the developer greater ability to customize.</source>
          <target state="translated">불필요한 변경 감지 실행을 피하면서 개발자에게 더 많은 사용자 정의 기능을 제공함으로써 성능을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="4164a929740068617e47d44247f8d7f7d80f5919" translate="yes" xml:space="preserve">
          <source>It is a &lt;em&gt;shell&lt;/em&gt; for the crisis management feature area, just as the &lt;code&gt;AppComponent&lt;/code&gt; is a shell to manage the high-level workflow.</source>
          <target state="translated">그것은이다 &lt;em&gt;쉘&lt;/em&gt; 의인으로, 위기 관리 기능 영역에 대한 &lt;code&gt;AppComponent&lt;/code&gt; 은 높은 수준의 워크 플로우를 관리 할 수있는 쉘입니다.</target>
        </trans-unit>
        <trans-unit id="39bf93eba307188a64bd26bb14fbc70e653f1001" translate="yes" xml:space="preserve">
          <source>It is a better practice to redistribute the component and its supporting classes into their own, dedicated files.</source>
          <target state="translated">구성 요소 및 지원 클래스를 고유 한 전용 파일로 재분배하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6769c0a53dc2a5685598a3855be2789b7ba33c3d" translate="yes" xml:space="preserve">
          <source>It is a shell for the crisis management feature area, just as the &lt;code&gt;AppComponent&lt;/code&gt; is a shell to manage the high-level workflow.</source>
          <target state="translated">&lt;code&gt;AppComponent&lt;/code&gt; 가 고급 워크 플로를 관리하는 셸인 것처럼 위기 관리 기능 영역 의 셸입니다.</target>
        </trans-unit>
        <trans-unit id="f4c906b1ec5168c0204d5b89211f8c14a110d92c" translate="yes" xml:space="preserve">
          <source>It is also rare but valid for an interceptor to return multiple responses on the event stream for a single request.</source>
          <target state="translated">인터셉터가 단일 요청에 대해 이벤트 스트림에서 여러 응답을 리턴하는 것도 드물지만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="7c3e6bd90e578a6d369fe153a9ba93c287cbf958" translate="yes" xml:space="preserve">
          <source>It is customary but not required to &lt;em&gt;precede&lt;/em&gt; the &lt;em&gt;closing HTML&lt;/em&gt; tag with a blank line as well.</source>
          <target state="translated">그것은 관례지만 할 필요가 없습니다 &lt;em&gt;선행 &lt;/em&gt;&lt;em&gt;닫는 HTML의&lt;/em&gt; 빈 줄뿐만 아니라 태그를.</target>
        </trans-unit>
        <trans-unit id="e2c901bdbe9622031dbf422258b1577bf6c7cfb3" translate="yes" xml:space="preserve">
          <source>It is highly recommended that you ensure that your app works even without service worker support in the browser. Although an unsupported browser ignores service worker caching, it will still report errors if the app attempts to interact with the service worker. For example, calling &lt;code&gt;&lt;a href=&quot;../api/service-worker/swupdate#checkForUpdate&quot;&gt;SwUpdate.checkForUpdate()&lt;/a&gt;&lt;/code&gt; will return rejected promises. To avoid such an error, you can check whether the Angular service worker is enabled using &lt;code&gt;&lt;a href=&quot;../api/service-worker/swupdate#isEnabled&quot;&gt;SwUpdate.isEnabled&lt;/a&gt;()&lt;/code&gt;.</source>
          <target state="translated">브라우저에서 서비스 워커 지원 없이도 앱이 작동하는지 확인하는 것이 좋습니다. 지원되지 않는 브라우저는 서비스 워커 캐싱을 무시하지만 앱이 서비스 워커와 상호 작용하려고 시도해도 여전히 오류를보고합니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;../api/service-worker/swupdate#checkForUpdate&quot;&gt;SwUpdate.checkForUpdate()&lt;/a&gt;&lt;/code&gt; 를 호출 하면 거부 된 약속이 반환됩니다. 이러한 오류를 피하기 위해 &lt;code&gt;&lt;a href=&quot;../api/service-worker/swupdate#isEnabled&quot;&gt;SwUpdate.isEnabled&lt;/a&gt;()&lt;/code&gt; 사용하여 Angular 서비스 워커가 활성화되어 있는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bca41d7798c2016edf356fbe8a535a8995b45502" translate="yes" xml:space="preserve">
          <source>It is important to note that service workers don't work behind redirect. You may have already encountered the error &lt;code&gt;The script resource is behind &lt;a href=&quot;../api/router/routerlinkwithhref&quot;&gt;a&lt;/a&gt; redirect, which is disallowed&lt;/code&gt;.</source>
          <target state="translated">서비스 워커는 경로 재 지정 작업을하지 않습니다. &lt;code&gt;The script resource is behind &lt;a href=&quot;../api/router/routerlinkwithhref&quot;&gt;a&lt;/a&gt; redirect, which is disallowed&lt;/code&gt; 오류가 발생했을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb4e957d60d2a88226f503a54462cd580636fb97" translate="yes" xml:space="preserve">
          <source>It is important to note that service workers don't work behind redirect. You may have already encountered the error &lt;code&gt;The script resource is behind a redirect, which is disallowed&lt;/code&gt;.</source>
          <target state="translated">서비스 워커는 리디렉션 뒤에서 작동하지 않는다는 점에 유의해야합니다. 이미 오류가 발생했을 수 있습니다. &lt;code&gt;The script resource is behind a redirect, which is disallowed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6149684d6a8cae8e0ae20c1797198ea032977a49" translate="yes" xml:space="preserve">
          <source>It is important to note that the asynchronous validation happens after the synchronous validation, and is performed only if the synchronous validation is successful. This check allows forms to avoid potentially expensive async validation processes such as an HTTP request if more basic validation methods fail.</source>
          <target state="translated">비동기 유효성 검사는 동기 유효성 검사 후에 발생하며 동기 유효성 검사가 성공한 경우에만 수행됩니다. 이 검사를 통해보다 기본적인 유효성 검사 방법이 실패한 경우 양식에서 HTTP 요청과 같은 잠재적으로 비싼 비동기 유효성 검사 프로세스를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96d7f100fd14c118e644c78eb99afbea37e0600c" translate="yes" xml:space="preserve">
          <source>It is important to remember that &lt;em&gt;HTML attribute&lt;/em&gt; and the &lt;em&gt;DOM property&lt;/em&gt; are different things, even when they have the same name. In Angular, the only role of HTML attributes is to initialize element and directive state.</source>
          <target state="translated">&lt;em&gt;HTML 속성&lt;/em&gt; 과 &lt;em&gt;DOM 속성&lt;/em&gt; 은 이름이 같더라도 다른 것임을 기억하는 것이 중요합니다 . Angular에서 HTML 속성의 유일한 역할은 요소 및 지시문 상태를 초기화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b0fefa48f8275785f28ed330c1e6500e50579c8a" translate="yes" xml:space="preserve">
          <source>It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous code. The sanitizer leaves safe values intact.</source>
          <target state="translated">값이 안전한 경우 (예를 들어 의심스러운 프로토콜로 시작하지 않는 URL 또는 위험한 코드가 포함되지 않은 HTML 스 니펫) 보안을 우회 할 필요가 없으며 권장하지 않습니다. 소독제는 안전한 가치를 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="387f085f27e111a9c4bb8916669c057b5f6b9de7" translate="yes" xml:space="preserve">
          <source>It is now an error to assign values to template-only variables like &lt;code&gt;item&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;=&quot;let item of items&quot;&lt;/code&gt; (previously, the compiler would ignore these assignments).</source>
          <target state="translated">지금과 같은 템플릿 전용 변수에 할당 된 값에 오류가 발생 &lt;code&gt;item&lt;/code&gt; 에 &lt;code&gt;&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;=&quot;let item of items&quot;&lt;/code&gt; (이전에, 컴파일러는 이러한 과제를 무시합니다).</target>
        </trans-unit>
        <trans-unit id="99529fc95ba91bf865b8bdc126836b31f7c4b6ea" translate="yes" xml:space="preserve">
          <source>It is often a good idea to &lt;em&gt;lock-in&lt;/em&gt; a good anchor name.</source>
          <target state="translated">좋은 앵커 이름 을 &lt;em&gt;잠그는&lt;/em&gt; 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4db5a6501589861c8253d34112728578aa1f6cad" translate="yes" xml:space="preserve">
          <source>It is possible for a schematic to provide all of its logic in the &lt;code&gt;index.ts&lt;/code&gt; file, without additional templates. You can create dynamic schematics for Angular, however, by providing components and templates in the &lt;code&gt;files/&lt;/code&gt; folder, like those in standalone Angular projects. The logic in the index file configures these templates by defining rules that inject data and modify variables.</source>
          <target state="translated">회로도에서 추가 템플릿없이 &lt;code&gt;index.ts&lt;/code&gt; 파일 에 모든 논리를 제공 할 수 있습니다. 그러나 독립형 Angular 프로젝트에서와 같이 &lt;code&gt;files/&lt;/code&gt; 폴더 에 구성 요소 및 템플릿을 제공하여 Angular에 대한 동적 회로도를 작성할 수 있습니다 . 인덱스 파일의 논리는 데이터를 주입하고 변수를 수정하는 규칙을 정의하여 이러한 템플릿을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="276b591d0b815d8888e428d7faf78a45d3cb29e5" translate="yes" xml:space="preserve">
          <source>It is possible for a user to try to access a route that you have not defined. To account for this behavior, the best practice is to display a 404 page. In this section, you'll create a 404 page and update your route configuration to show that page for any unspecified routes.</source>
          <target state="translated">사용자가 정의하지 않은 경로에 액세스를 시도 할 수 있습니다. 이 동작을 설명하기 위해 모범 사례는 404 페이지를 표시하는 것입니다. 이 섹션에서는 404 페이지를 만들고 지정되지 않은 경로에 대해 해당 페이지를 표시하도록 경로 구성을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="ffeddf5c1683cd01631856186ef36a7b7e49a9d5" translate="yes" xml:space="preserve">
          <source>It is possible to define the component first with the help of the &lt;code&gt;&lt;a href=&quot;../api/core/forwardref&quot;&gt;forwardRef&lt;/a&gt;()&lt;/code&gt; method as explained in this &lt;a href=&quot;http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html&quot;&gt;블로그 게시물&lt;/a&gt; 에서 설명한대로 &lt;code&gt;&lt;a href=&quot;../api/core/forwardref&quot;&gt;forwardRef&lt;/a&gt;()&lt;/code&gt; 메서드 를 사용하여 먼저 구성 요소를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2473f74c9fd722cdbf273d992f76f8c4263ad073" translate="yes" xml:space="preserve">
          <source>It is possible to downgrade multiple modules and include them in an AngularJS application. In that case, each downgraded module will be bootstrapped when an associated downgraded component or injectable needs to be instantiated.</source>
          <target state="translated">여러 모듈을 다운 그레이드하고 AngularJS 응용 프로그램에 포함시킬 수 있습니다. 이 경우 관련 다운 그레이드 된 구성 요소 또는 주입 가능한 인스턴스를 인스턴스화해야 할 때 다운 그레이드 된 각 모듈이 부트 스트랩됩니다.</target>
        </trans-unit>
        <trans-unit id="84af64f653bfc89c603108eaa38ffc63b5f37827" translate="yes" xml:space="preserve">
          <source>It is possible to use SVG as valid templates in Angular. All of the template syntax below is applicable to both SVG and HTML. Learn more in the SVG &lt;a href=&quot;https://www.w3.org/TR/SVG11/&quot;&gt;1.1&lt;/a&gt; and &lt;a href=&quot;https://www.w3.org/TR/SVG2/&quot;&gt;2.0&lt;/a&gt; specifications.</source>
          <target state="translated">SVG를 유효한 템플릿으로 Angular에서 사용할 수 있습니다. 아래의 모든 템플릿 구문은 SVG와 HTML 모두에 적용됩니다. SVG &lt;a href=&quot;https://www.w3.org/TR/SVG11/&quot;&gt;1.1&lt;/a&gt; 및 &lt;a href=&quot;https://www.w3.org/TR/SVG2/&quot;&gt;2.0&lt;/a&gt; 사양 에서 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="84f6e26f10188c89b058327e2a32272c027943f0" translate="yes" xml:space="preserve">
          <source>It is recommended that you avoid depending on CommonJS modules in your Angular applications. Depending on CommonJS modules can prevent bundlers and minifiers from optimizing your application, which results in larger bundle sizes. Instead, it is recommended that you use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;ECMAScript modules&lt;/a&gt; in your entire application. For more information, see &lt;a href=&quot;https://web.dev/commonjs-larger-bundles/&quot;&gt;How CommonJS is making your bundles larger&lt;/a&gt;.</source>
          <target state="translated">Angular 애플리케이션에서 CommonJS 모듈에 의존하지 않는 것이 좋습니다. CommonJS 모듈에 따라 번 들러와 미니 파이어가 애플리케이션을 최적화하지 못해 번들 크기가 커집니다. 대신 전체 애플리케이션에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;ECMAScript 모듈&lt;/a&gt; 을 사용하는 것이 좋습니다 . 자세한 정보 &lt;a href=&quot;https://web.dev/commonjs-larger-bundles/&quot;&gt;는 CommonJS가 번들을 더 크게 만드는 방법을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1031dd12dc6c396336a813b3dadae7f6f7e75ce9" translate="yes" xml:space="preserve">
          <source>It is recommended that you put the more specific asset groups higher in the list. For example, an asset group that matches &lt;code&gt;/foo.js&lt;/code&gt; should appear before one that matches &lt;code&gt;*.js&lt;/code&gt;.</source>
          <target state="translated">보다 구체적인 자산 그룹을 목록의 상위에 배치하는 것이 좋습니다. 예를 들어 &lt;code&gt;/foo.js&lt;/code&gt; 와 일치하는 자산 그룹은 &lt;code&gt;*.js&lt;/code&gt; 와 일치하는 자산 그룹 앞에 나타나야 합니다 .</target>
        </trans-unit>
        <trans-unit id="6801d16c249805651ee46dca90c0e3319d7bdd03" translate="yes" xml:space="preserve">
          <source>It is recommended that you put the more specific data groups higher in the list. For example, a data group that matches &lt;code&gt;/api/foo.json&lt;/code&gt; should appear before one that matches &lt;code&gt;/api/*.json&lt;/code&gt;.</source>
          <target state="translated">목록에서보다 구체적인 데이터 그룹을 상위에 배치하는 것이 좋습니다. 예를 들어, &lt;code&gt;/api/foo.json&lt;/code&gt; 과 일치하는 데이터 그룹은 /api/*.json 과 일치하는 데이터 그룹 앞에 &lt;code&gt;/api/*.json&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="423c72666d4582438903aed1e354553173f2f747" translate="yes" xml:space="preserve">
          <source>It is recommended that you set an element property with a &lt;a href=&quot;property-binding&quot;&gt;property binding&lt;/a&gt; whenever possible. However, sometimes you don't have an element property to bind. In those situations, you can use attribute binding.</source>
          <target state="translated">가능한 한 &lt;a href=&quot;property-binding&quot;&gt;속성 바인딩&lt;/a&gt; 을 사용하여 요소 속성을 설정하는 것이 좋습니다 . 그러나 바인딩 할 요소 속성이없는 경우도 있습니다. 이러한 상황에서는 속성 바인딩을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76d730517d126f32e97587e9cbc5e3cf785c0aea" translate="yes" xml:space="preserve">
          <source>It is the &lt;em&gt;root&lt;/em&gt; of the crisis center area, just as &lt;code&gt;AppComponent&lt;/code&gt; is the root of the entire application.</source>
          <target state="translated">그것은이다 &lt;em&gt;루트&lt;/em&gt; 것처럼, 위기 센터 영역의 &lt;code&gt;AppComponent&lt;/code&gt; 은 전체 응용 프로그램의 루트입니다.</target>
        </trans-unit>
        <trans-unit id="f0ce6c1a9e19d02a76258f37c5efc06fb5db9120" translate="yes" xml:space="preserve">
          <source>It is the root of the crisis center area, just as &lt;code&gt;AppComponent&lt;/code&gt; is the root of the entire application.</source>
          <target state="translated">&lt;code&gt;AppComponent&lt;/code&gt; 가 전체 애플리케이션의 루트 인 것처럼 위기 센터 영역 의 루트입니다.</target>
        </trans-unit>
        <trans-unit id="c5288fb8c9de08ed91bcc1bec73e759d6ce69568" translate="yes" xml:space="preserve">
          <source>It is time to take off the training wheels and let the application begin its new life as a pure, shiny Angular app. The remaining tasks all have to do with removing code - which of course is every programmer's favorite task!</source>
          <target state="translated">이제 훈련 바퀴를 벗고 응용 프로그램이 새롭고 반짝이는 Angular 앱으로 새로운 삶을 시작할 수있게되었습니다. 나머지 작업은 모두 코드를 제거하는 것과 관련이 있습니다. 물론 모든 프로그래머가 가장 좋아하는 작업입니다!</target>
        </trans-unit>
        <trans-unit id="ccb342aa8e1714c7437fd8ad1e8831908215d07c" translate="yes" xml:space="preserve">
          <source>It is valid for &lt;code&gt;.metadata.json&lt;/code&gt; files to contain errors. The template compiler reports these errors if the metadata is used to determine the contents of an annotation. The metadata collector cannot predict the symbols that are designed for use in an annotation, so it preemptively includes error nodes in the metadata for the exported symbols. The template compiler can then use the error nodes to report an error if these symbols are used.</source>
          <target state="translated">&lt;code&gt;.metadata.json&lt;/code&gt; 파일에 오류가있는 것이 유효 합니다. 메타 데이터가 주석의 컨텐츠를 판별하는 데 사용되는 경우 템플리트 컴파일러는 이러한 오류를보고합니다. 메타 데이터 수집기는 주석에 사용하도록 설계된 심볼을 예측할 수 없으므로 내 보낸 심볼의 메타 데이터에 오류 노드를 선점 적으로 포함합니다. 그런 다음 템플릿 컴파일러는 이러한 기호가 사용되는 경우 오류 노드를 사용하여 오류를보고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d7207af03b5af04389d3df1257a354179fd4eef" translate="yes" xml:space="preserve">
          <source>It looks about the same as any other component you've seen in this guide. There are two noteworthy differences.</source>
          <target state="translated">이 가이드에서 본 다른 구성 요소와 동일하게 보입니다. 두 가지 주목할만한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e8998f7abfdb1faca5ef4124813aa06fd13c960" translate="yes" xml:space="preserve">
          <source>It looks similar to any other component in this guide, but there are two key differences.</source>
          <target state="translated">이 가이드의 다른 구성 요소와 비슷해 보이지만 두 가지 주요 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce0f95ba15adcc1262d25210b5a0ac97badbdb0a" translate="yes" xml:space="preserve">
          <source>It may be advantageous to deviate from the &lt;em&gt;one-thing-per-file&lt;/em&gt; rule when you have a set of small, closely-related features that are better discovered and understood in a single file than as multiple files. Be wary of this loophole.</source>
          <target state="translated">여러 파일보다 단일 파일에서 더 잘 발견되고 이해되는 작고 밀접한 관련 기능 세트가있는 경우 &lt;em&gt;파일 당 하나의&lt;/em&gt; 규칙 을 벗어나는 것이 유리할 수 있습니다 . 이 허점에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="13dbe81d25cc860ec205d64166f5c721b4b86799" translate="yes" xml:space="preserve">
          <source>It may be difficult to imagine how this directive actually works. In this section, you'll turn &lt;code&gt;AppComponent&lt;/code&gt; into a harness that lets you pick the highlight color with a radio button and bind your color choice to the directive.</source>
          <target state="translated">이 지시어가 실제로 어떻게 작동하는지 상상하기 어려울 수 있습니다. 이 섹션에서는 &lt;code&gt;AppComponent&lt;/code&gt; 를 하네스로 전환 하여 라디오 버튼으로 강조 색상을 선택하고 색상 선택을 지시문에 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77eed6237424237999f7c2a34a9fb9ff0e0091ce" translate="yes" xml:space="preserve">
          <source>It may be more economical to create the forms dynamically, based on metadata that describes the business object model.</source>
          <target state="translated">비즈니스 오브젝트 모델을 설명하는 메타 데이터를 기반으로 양식을 동적으로 작성하는 것이 더 경제적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bacb242ddb0949af950399df1070a8a6e831b848" translate="yes" xml:space="preserve">
          <source>It might not look like the class has properties, but it does. The declaration of the constructor parameters takes advantage of a TypeScript shortcut.</source>
          <target state="translated">클래스에 속성이있는 것처럼 보이지 않을 수도 있지만 그렇지 않습니다. 생성자 매개 변수 선언은 TypeScript 바로 가기를 활용합니다.</target>
        </trans-unit>
        <trans-unit id="e089e64834f141326fc0828463df856289d092cb" translate="yes" xml:space="preserve">
          <source>It must be known ahead of time so that IDEs can parse it without knowing the underlying semantics of the directive or what directives are present.</source>
          <target state="translated">IDE가 지시문의 기본 의미 또는 존재하는 지시문을 몰라도 구문 분석 할 수 있도록 미리 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="cd59871da798733ed7ae9afa636c133a8f98ca66" translate="yes" xml:space="preserve">
          <source>It must translate to key-value attributes in the DOM.</source>
          <target state="translated">DOM에서 키-값 속성으로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4b70d7ad2d5ef809560d50e542640d494da5baf" translate="yes" xml:space="preserve">
          <source>It navigates imperatively with the &lt;code&gt;&lt;a href=&quot;../api/router/router#navigate&quot;&gt;Router.navigate()&lt;/a&gt;&lt;/code&gt; method, passing in a &lt;a href=&quot;router#link-parameters-array&quot;&gt;link parameters array&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/router/router#navigate&quot;&gt;Router.navigate()&lt;/a&gt;&lt;/code&gt; 메소드를 사용하여 &lt;a href=&quot;router#link-parameters-array&quot;&gt;링크 매개 변수 array를&lt;/a&gt; 전달 하여 필수적으로 탐색 합니다.</target>
        </trans-unit>
        <trans-unit id="90f73e390a5723e407fe6308cf983a850544d1b6" translate="yes" xml:space="preserve">
          <source>It presents a list of questions, each bound to a &lt;code&gt;&amp;lt;app-question&amp;gt;&lt;/code&gt; component element. The &lt;code&gt;&amp;lt;app-question&amp;gt;&lt;/code&gt; tag matches the &lt;code&gt;DynamicFormQuestionComponent&lt;/code&gt;, the component responsible for rendering the details of each &lt;em&gt;individual&lt;/em&gt; question based on values in the data-bound question object.</source>
          <target state="translated">&lt;code&gt;&amp;lt;app-question&amp;gt;&lt;/code&gt; 컴포넌트 요소에 각각 바인딩 된 질문 목록을 제공합니다 . &lt;code&gt;&amp;lt;app-question&amp;gt;&lt;/code&gt; 태그는 일치 &lt;code&gt;DynamicFormQuestionComponent&lt;/code&gt; , 각각의 세부 렌더링 컴포넌트 책임 &lt;em&gt;개별&lt;/em&gt; 데이터 바인딩 질문 개체의 값을 기준으로 질문을.</target>
        </trans-unit>
        <trans-unit id="82a5d3b75fdd687a86c692b5142357640cb12862" translate="yes" xml:space="preserve">
          <source>It provides some of the shared behavior that all controls and groups of controls have, like running validators, calculating status, and resetting state. It also defines the properties that are shared between all sub-classes, like &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;valid&lt;/code&gt;, and &lt;code&gt;dirty&lt;/code&gt;. It shouldn't be instantiated directly.</source>
          <target state="translated">유효성 검사기 실행, 상태 계산 및 상태 재설정과 같은 모든 컨트롤과 컨트롤 그룹에있는 일부 공유 동작을 제공합니다. 또한 &lt;code&gt;value&lt;/code&gt; , &lt;code&gt;valid&lt;/code&gt; 및 &lt;code&gt;dirty&lt;/code&gt; 와 같은 모든 하위 클래스간에 공유되는 속성을 정의합니다 . 직접 인스턴스화해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d171e074941cff4fb7a54c6be8c58fcc87175574" translate="yes" xml:space="preserve">
          <source>It re-exports the &lt;code&gt;&lt;a href=&quot;../api/common/commonmodule&quot;&gt;CommonModule&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/common/commonmodule&quot;&gt;CommonModule&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; 을 다시 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="293d2ed2212503b7e45e9caa6fdd2a81620b6623" translate="yes" xml:space="preserve">
          <source>It renders properly.</source>
          <target state="translated">제대로 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="0ae169fa3e47383715acb011e05d54b05113d563" translate="yes" xml:space="preserve">
          <source>It requires less boilerplate code.</source>
          <target state="translated">상용구 코드가 덜 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bef3630aa143887d2a90b2232f4fa65407f77fcf" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;Observable&lt;/code&gt; that &lt;em&gt;resolves&lt;/em&gt; when the user eventually decides what to do: either to discard changes and navigate away (&lt;code&gt;true&lt;/code&gt;) or to preserve the pending changes and stay in the crisis editor (&lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">변경 사항을 버리고 탐색하지 않거나 ( &lt;code&gt;true&lt;/code&gt; ) 보류중인 변경 사항을 보존하고 위기 편집기에 머 무르려면 ( &lt;code&gt;false&lt;/code&gt; ) 사용자가 최종적으로 수행 할 조치를 결정할 때 &lt;em&gt;해결&lt;/em&gt; 되는 &lt;code&gt;Observable&lt;/code&gt; 을 리턴 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="86d9d6efd22f39114ebd226c95a029f0c8dc9071" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;Observable&lt;/code&gt; that resolves when the user eventually decides what to do: either to discard changes and navigate away (&lt;code&gt;true&lt;/code&gt;) or to preserve the pending changes and stay in the crisis editor (&lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">사용자가 최종적으로 수행 할 작업을 결정할 때 해결 하는 &lt;code&gt;Observable&lt;/code&gt; 을 반환합니다 . 변경 사항을 취소하고 탐색 ( &lt;code&gt;true&lt;/code&gt; )하거나 보류중인 변경 사항을 보존하고 위기 편집기에 남아 ( &lt;code&gt;false&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f17b788f117ba6e453d05b278cd784e7b06521e5" translate="yes" xml:space="preserve">
          <source>It returns service responses in their original request order, even if the server returns them out of order.</source>
          <target state="translated">서버가 순서를 바꾸지 않아도 원래 요청 순서대로 서비스 응답을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e8347f69be7f37a1644f92b33a93b2dee7c617e2" translate="yes" xml:space="preserve">
          <source>It should look something like this, depending on where you run it:</source>
          <target state="translated">실행 위치에 따라 다음과 같이 보일 것입니다.</target>
        </trans-unit>
        <trans-unit id="fde1c30a4ed9c7ecc8b3522111845cd4f468613d" translate="yes" xml:space="preserve">
          <source>It takes a bit more work to get the child view into the parent component &lt;em&gt;class&lt;/em&gt;.</source>
          <target state="translated">자식 구성 요소를 부모 구성 요소 &lt;em&gt;클래스&lt;/em&gt; 로 가져 오려면 약간의 작업이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="2f20885a1acc0aea1959ff23c8f48814d62d5065" translate="yes" xml:space="preserve">
          <source>It takes a function argument that returns an &lt;code&gt;Observable&lt;/code&gt;. &lt;code&gt;PackageSearchService.search&lt;/code&gt; returns an &lt;code&gt;Observable&lt;/code&gt;, as other data service methods do.</source>
          <target state="translated">&lt;code&gt;Observable&lt;/code&gt; 을 반환하는 함수 인수가 필요합니다 . &lt;code&gt;PackageSearchService.search&lt;/code&gt; 는 다른 데이터 서비스 메소드와 마찬가지로 &lt;code&gt;Observable&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="674f64671b4a8d0cb23d0caf55d87a3f7dde911d" translate="yes" xml:space="preserve">
          <source>It takes two arguments: the component type to override (&lt;code&gt;HeroDetailComponent&lt;/code&gt;) and an override metadata object. The &lt;a href=&quot;testing#metadata-override-object&quot;&gt;override metadata object&lt;/a&gt; is a generic defined as follows:</source>
          <target state="translated">재정의 할 구성 요소 유형 ( &lt;code&gt;HeroDetailComponent&lt;/code&gt; )과 재정의 메타 데이터 개체라는 두 가지 인수가 필요 합니다. &lt;a href=&quot;testing#metadata-override-object&quot;&gt;재정의 메타 데이터 개체는&lt;/a&gt; 다음과 같이 정의 일반적인입니다 :</target>
        </trans-unit>
        <trans-unit id="fe763eb54958bc5bce1ca54318ae85f6b15cea14" translate="yes" xml:space="preserve">
          <source>It takes two arguments: the component type to override (&lt;code&gt;HeroDetailComponent&lt;/code&gt;) and an override metadata object. The &lt;a href=&quot;testing-utility-apis#metadata-override-object&quot;&gt;override metadata object&lt;/a&gt; is a generic defined as follows:</source>
          <target state="translated">두 개의 인수 , 즉 재정의 할 구성 요소 유형 ( &lt;code&gt;HeroDetailComponent&lt;/code&gt; )과 재정의 메타 데이터 개체가 필요합니다. &lt;a href=&quot;testing-utility-apis#metadata-override-object&quot;&gt;재정의 메타 데이터 개체는&lt;/a&gt; 다음과 같이 정의 일반적인입니다 :</target>
        </trans-unit>
        <trans-unit id="6b7ade15f2e40422ade0a9b4e8bd3a6ec4688da6" translate="yes" xml:space="preserve">
          <source>It takes two more parameters:</source>
          <target state="translated">두 가지 매개 변수가 더 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ca9ca3b7d869e7250ea3e82c4497b55685884167" translate="yes" xml:space="preserve">
          <source>It tells the injector to start its search for a &lt;code&gt;Parent&lt;/code&gt; dependency in a component &lt;em&gt;above&lt;/em&gt; itself, which &lt;em&gt;is&lt;/em&gt; what parent means.</source>
          <target state="translated">그것은에 대한 검색을 시작하는 인젝터를 알려줍니다 &lt;code&gt;Parent&lt;/code&gt; 구성 요소에 종속 &lt;em&gt;위&lt;/em&gt; 자체 &lt;em&gt;입니다&lt;/em&gt; 무엇 부모 수단.</target>
        </trans-unit>
        <trans-unit id="87287c749aedf291db51189f1922d8e0ed42f2e2" translate="yes" xml:space="preserve">
          <source>It used to display the hero details on its own, before you cut that portion of the template. Now it will delegate to the &lt;code&gt;HeroDetailComponent&lt;/code&gt;.</source>
          <target state="translated">템플릿의 해당 부분을 잘라 내기 전에 영웅 세부 정보를 자체적으로 표시하는 데 사용되었습니다. 이제 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 에 위임합니다 .</target>
        </trans-unit>
        <trans-unit id="26603cbdf502504b4bafbb3d1bd7c3f1f9536e25" translate="yes" xml:space="preserve">
          <source>It will be either an instance of &lt;code&gt;TestBedViewEngine&lt;/code&gt; or &lt;code&gt;TestBedRender3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TestBedViewEngine&lt;/code&gt; 또는 &lt;code&gt;TestBedRender3&lt;/code&gt; 의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="b2aee283c41ff9b11753db47219f0539ccacca7d" translate="yes" xml:space="preserve">
          <source>It worked because the Angular CLI declared &lt;code&gt;HeroesComponent&lt;/code&gt; in the &lt;code&gt;AppModule&lt;/code&gt; when it generated that component.</source>
          <target state="translated">Angular CLI가 해당 구성 요소를 생성 할 때 &lt;code&gt;AppModule&lt;/code&gt; 에서 &lt;code&gt;HeroesComponent&lt;/code&gt; 를 선언했기 때문에 효과가 있었습니다 .</target>
        </trans-unit>
        <trans-unit id="a18d731dddd044fda8c0206e03d977e14385f507" translate="yes" xml:space="preserve">
          <source>It works perfectly with long property paths such as &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkwithhref&quot;&gt;a&lt;/a&gt;?.b?.c?.d&lt;/code&gt;.</source>
          <target state="translated">그것은 같은 긴 속성 경로를 완벽하게 작동 &lt;code&gt;&lt;a href=&quot;../api/router/routerlinkwithhref&quot;&gt;a&lt;/a&gt;?.b?.c?.d&lt;/code&gt; .&lt;a href=&quot;../api/router/routerlinkwithhref&quot;&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b61828efce1a32f9f0c8ea1d12bb762c91b945f" translate="yes" xml:space="preserve">
          <source>It works perfectly with long property paths such as &lt;code&gt;a?.b?.c?.d&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a?.b?.c?.d&lt;/code&gt; 와 같은 긴 속성 경로에서 완벽하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="f1bf143650c4c43d18c8241673d0204f40c18a4a" translate="yes" xml:space="preserve">
          <source>It would be ideal to change the type of &lt;code&gt;value&lt;/code&gt; here, from &lt;code&gt;boolean&lt;/code&gt; to &lt;code&gt;boolean|''&lt;/code&gt;, to match the set of values which are actually accepted by the setter. TypeScript requires that both the getter and setter have the same type, so if the getter should return a &lt;code&gt;boolean&lt;/code&gt; then the setter is stuck with the narrower type.</source>
          <target state="translated">setter가 실제로 수락하는 값 세트와 일치하도록 여기에서 &lt;code&gt;value&lt;/code&gt; 유형을 &lt;code&gt;boolean&lt;/code&gt; 에서 &lt;code&gt;boolean|''&lt;/code&gt; 로 변경하는 것이 이상적입니다 . TypeScript는 getter와 setter가 모두 동일한 유형을 가져야하므로 getter가 &lt;code&gt;boolean&lt;/code&gt; 을 반환해야하는 경우 setter는 더 좁은 유형으로 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="af0e2debe677c9c678729b2bc1cbfd09e3f7a0d9" translate="yes" xml:space="preserve">
          <source>It would be nice to have a button on the &lt;code&gt;HeroDetail&lt;/code&gt; view that can do that.</source>
          <target state="translated">이를 수행 할 수 있는 &lt;code&gt;HeroDetail&lt;/code&gt; 보기 에 버튼이 있으면 좋을 것입니다.</target>
        </trans-unit>
        <trans-unit id="0051be8012a415185793f036c9c8e5128fc7e68d" translate="yes" xml:space="preserve">
          <source>It's a &lt;em&gt;one way&lt;/em&gt; data binding from the &lt;code&gt;selectedHero&lt;/code&gt; property of the &lt;code&gt;HeroesComponent&lt;/code&gt; to the &lt;code&gt;hero&lt;/code&gt; property of the target element, which maps to the &lt;code&gt;hero&lt;/code&gt; property of the &lt;code&gt;HeroDetailComponent&lt;/code&gt;.</source>
          <target state="translated">그것은이다 &lt;em&gt;편도&lt;/em&gt; 으로부터 데이터 바인딩 &lt;code&gt;selectedHero&lt;/code&gt; 의 의 특성 &lt;code&gt;HeroesComponent&lt;/code&gt; 받는 &lt;code&gt;hero&lt;/code&gt; 받는 사람 매핑 대상 요소의 특성 &lt;code&gt;hero&lt;/code&gt; 의 특성 &lt;code&gt;HeroDetailComponent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60b2581c46072f14693ad4b2115581cbacdca79b" translate="yes" xml:space="preserve">
          <source>It's a bit tighter and smaller, with fewer import statements (not shown).</source>
          <target state="translated">수입 명세서가 적고 조금 더 단단하고 작습니다 (표시되지 않음).</target>
        </trans-unit>
        <trans-unit id="69a8bddb93aeeda0022b562464f122f8b32da08f" translate="yes" xml:space="preserve">
          <source>It's a different story if you improperly import &lt;code&gt;GreetingModule&lt;/code&gt; into a lazy loaded module such as &lt;code&gt;CustomersModule&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;GreetingModule&lt;/code&gt; 을 &lt;code&gt;CustomersModule&lt;/code&gt; 과 같은 게으른로드 된 모듈로 잘못 가져 오면 다른 이야기 입니다.</target>
        </trans-unit>
        <trans-unit id="09434c75600174446486b9af36cce437fffe1ce2" translate="yes" xml:space="preserve">
          <source>It's a good idea to put unit test spec files in the same folder as the application source code files that they test:</source>
          <target state="translated">단위 테스트 사양 파일을 테스트하는 응용 프로그램 소스 코드 파일과 동일한 폴더에 배치하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9bcfe973543c84bb66b75ce9b66043cdfd62ffa5" translate="yes" xml:space="preserve">
          <source>It's a little more involved if you are in an interpolation. If you have an interpolation of &lt;code&gt;{{data.---}}&lt;/code&gt; inside a &lt;code&gt;div&lt;/code&gt; and need the completion list after &lt;code&gt;data.---&lt;/code&gt;, the compiler can't use the HTML AST to find the answer. The HTML AST can only tell the compiler that there is some text with the characters &quot;&lt;code&gt;{{data.---}}&lt;/code&gt;&quot;. That's when the template parser produces an expression AST, which resides within the template AST. The Angular Language Services then looks at &lt;code&gt;data.---&lt;/code&gt; within its context, asks the TypeScript Language Service what the members of &lt;code&gt;data&lt;/code&gt; are, and returns the list of possibilities.</source>
          <target state="translated">보간에 있다면 조금 더 복잡합니다. 당신의 보간이있는 경우 &lt;code&gt;{{data.---}}&lt;/code&gt; , 안쪽 &lt;code&gt;div&lt;/code&gt; 하고 후 완성 목록 필요한 &lt;code&gt;data.---&lt;/code&gt; , 컴파일러는 답을 찾기 위해 HTML의 AST를 사용할 수 없습니다. HTML AST는 &quot; &lt;code&gt;{{data.---}}&lt;/code&gt; &quot; 문자를 가진 텍스트가 있음을 컴파일러에게만 알려줄 수 있습니다 . 이때 템플릿 파서는 템플릿 AST 내에있는 표현식 AST를 생성합니다. 그런 다음 Angular Language Services는 해당 컨텍스트 내 에서 &lt;code&gt;data.---&lt;/code&gt; 를보고 TypeScript Language Service에 &lt;code&gt;data&lt;/code&gt; 멤버가 무엇인지 묻고 가능성 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fcb0348ea77c1a0b6ee18a979c38ff18f522a08c" translate="yes" xml:space="preserve">
          <source>It's a simpler and more efficient alternative to removing all elements one by one:</source>
          <target state="translated">모든 요소를 ​​하나씩 제거하는보다 간단하고 효율적인 대안입니다.</target>
        </trans-unit>
        <trans-unit id="6a71d528e9fd07b4df2b1b862b68940c3e7e83b3" translate="yes" xml:space="preserve">
          <source>It's also possible to specify that a service should be provided in a particular &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt;. For example, if you don't want &lt;code&gt;UserService&lt;/code&gt; to be available to applications unless they import a &lt;code&gt;UserModule&lt;/code&gt; you've created, you can specify that the service should be provided in the module:</source>
          <target state="translated">특정 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 에 서비스를 제공하도록 지정할 수도 있습니다 . 예를 들어, 생성 한 &lt;code&gt;UserModule&lt;/code&gt; 을 가져 오지 않으면 서 응용 프로그램에서 &lt;code&gt;UserService&lt;/code&gt; 를 사용할 수 없게 하려면 모듈에서 서비스를 제공하도록 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9552d457536c1b64a297fca25a1283d35d3a935d" translate="yes" xml:space="preserve">
          <source>It's also possible to use &lt;code&gt;&lt;a href=&quot;../core/testing/async&quot;&gt;async&lt;/a&gt;&lt;/code&gt; with Observables. The example below binds the &lt;code&gt;&lt;a href=&quot;asyncpipe&quot;&gt;time&lt;/a&gt;&lt;/code&gt; Observable to the view. The Observable continuously updates the view with the current time.</source>
          <target state="translated">Observables와 &lt;code&gt;&lt;a href=&quot;../core/testing/async&quot;&gt;async&lt;/a&gt;&lt;/code&gt; 를 사용하는 것도 가능합니다 . 아래 예제는 Observable &lt;code&gt;&lt;a href=&quot;asyncpipe&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 을 뷰에 바인딩합니다 . Observable은 현재 시간으로보기를 지속적으로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="573c20ee769df0dbbf6c5bedf2b66b0de69acbe1" translate="yes" xml:space="preserve">
          <source>It's also possible to use &lt;code&gt;&lt;a href=&quot;asyncpipe&quot;&gt;async&lt;/a&gt;&lt;/code&gt; with Observables. The example below binds the &lt;code&gt;time&lt;/code&gt; Observable to the view. The Observable continuously updates the view with the current time.</source>
          <target state="translated">Observable과 함께 &lt;code&gt;&lt;a href=&quot;asyncpipe&quot;&gt;async&lt;/a&gt;&lt;/code&gt; 를 사용할 수도 있습니다 . 아래 예제는 Observable &lt;code&gt;time&lt;/code&gt; 을 뷰에 바인딩합니다 . Observable은 현재 시간으로 뷰를 지속적으로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="321bd8fb08a8edefb40590d92c8b9e018f5c3cce" translate="yes" xml:space="preserve">
          <source>It's also recommended to export the &lt;code&gt;heroesServiceFactory&lt;/code&gt; function so that Ahead-of-Time compilation can pick it up.</source>
          <target state="translated">또한 Ahead-of-Time 컴파일에서 선택할 수 있도록 &lt;code&gt;heroesServiceFactory&lt;/code&gt; 함수 를 내보내는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f699da3b1f9e220fa97ad28cd922a1330c2a3881" translate="yes" xml:space="preserve">
          <source>It's an anemic model with few requirements and no behavior. Perfect for the demo.</source>
          <target state="translated">요구 사항이 적고 동작이없는 빈혈 모델입니다. 데모에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="f2f02356a25344321ea932ed9aa84284ad0b5391" translate="yes" xml:space="preserve">
          <source>It's better to pause and let the user decide what to do. If the user cancels, you'll stay put and allow more changes. If the user approves, the app can save.</source>
          <target state="translated">일시 중지하고 사용자가 무엇을해야할지 결정하는 것이 좋습니다. 사용자가 취소하면 그대로두고 더 많은 변경을 허용합니다. 사용자가 승인하면 앱을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f78888bb37d208c4ff42770338b7ad54c0ab57e" translate="yes" xml:space="preserve">
          <source>It's better to use the &lt;code&gt;&lt;a href=&quot;../router/router&quot;&gt;Router&lt;/a&gt;#navigate&lt;/code&gt; service to trigger route changes. Use &lt;code&gt;&lt;a href=&quot;location&quot;&gt;Location&lt;/a&gt;&lt;/code&gt; only if you need to interact with or create normalized URLs outside of routing.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../router/router&quot;&gt;Router&lt;/a&gt;#navigate&lt;/code&gt; 서비스 를 사용하여 경로 변경을 트리거 하는 것이 좋습니다 . 라우팅 외부에서 표준화 된 URL과 상호 작용하거나 생성해야하는 경우에만 &lt;code&gt;&lt;a href=&quot;location&quot;&gt;Location&lt;/a&gt;&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8b602ffbddc224ba7425e27dba721fa66a2d522" translate="yes" xml:space="preserve">
          <source>It's called an &lt;em&gt;input&lt;/em&gt; property because data flows from the binding expression &lt;em&gt;into&lt;/em&gt; the directive. Without that input metadata, Angular rejects the binding; see &lt;a href=&quot;attribute-directives#why-input&quot;&gt;below&lt;/a&gt; for more about that.</source>
          <target state="translated">데이터가 바인딩 표현식 에서 지시문 &lt;em&gt;으로&lt;/em&gt; 흐르기 때문에 &lt;em&gt;입력&lt;/em&gt; 특성 이라고합니다 . 입력 메타 데이터가 없으면 Angular는 바인딩을 거부합니다. 이에 대한 자세한 내용 은 &lt;a href=&quot;attribute-directives#why-input&quot;&gt;아래&lt;/a&gt; 를 참조하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a1c5b2c14f47a4acb6a4e31a66880f00d640c203" translate="yes" xml:space="preserve">
          <source>It's certainly a good idea to give the user some kind of feedback when data access fails. But displaying the raw error object returned by &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; is far from the best way to do it.</source>
          <target state="translated">데이터 액세스가 실패 할 때 사용자에게 일종의 피드백을 제공하는 것이 좋습니다. 그러나 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 가 반환 한 원시 오류 객체를 표시하는 것이 가장 좋은 방법은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f716eb9a6b02b45e7ef6afb1e41d83af97f96b96" translate="yes" xml:space="preserve">
          <source>It's difficult to identify the &lt;em&gt;selected hero&lt;/em&gt; in the list when all &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; elements look alike.</source>
          <target state="translated">모든 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소가 비슷해 보일 때 목록에서 &lt;em&gt;선택된 영웅&lt;/em&gt; 을 식별하기가 어렵 습니다.</target>
        </trans-unit>
        <trans-unit id="f18821981bfd33d573d82ec783fb8b3c0ddffd55" translate="yes" xml:space="preserve">
          <source>It's easier to get to the input box with the template reference variable than to go through the &lt;code&gt;$event&lt;/code&gt; object. Here's a rewrite of the previous &lt;code&gt;keyup&lt;/code&gt; example that uses a template reference variable to get the user's input.</source>
          <target state="translated">&lt;code&gt;$event&lt;/code&gt; 객체를 거치는 것보다 템플릿 참조 변수를 사용하여 입력 상자에 들어가는 것이 더 쉽습니다 . 다음 은 템플릿 참조 변수를 사용하여 사용자 입력을 얻는 이전 &lt;code&gt;keyup&lt;/code&gt; 예제를 다시 작성한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="13c09e93ba14e7c6aec0f030ed4749ec45cde327" translate="yes" xml:space="preserve">
          <source>It's faster to run without the debugger by pressing &lt;code&gt;Ctrl-F5&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Ctrl-F5&lt;/code&gt; 를 눌러 디버거없이 실행하는 것이 더 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="c0a37d50ae18f2cda48cc6b441cf45b1f4e85db3" translate="yes" xml:space="preserve">
          <source>It's harder to target an element that is entering a view because it isn't in the DOM yet. So, use the aliases &lt;code&gt;:enter&lt;/code&gt; and &lt;code&gt;:leave&lt;/code&gt; to target HTML elements that are inserted or removed from a view.</source>
          <target state="translated">뷰에 들어가는 요소는 아직 DOM에 없기 때문에 타겟팅하기가 더 어렵습니다. 따라서 뷰에서 삽입되거나 제거 된 HTML 요소를 대상으로 지정하려면 &lt;code&gt;:enter&lt;/code&gt; 및 &lt;code&gt;:leave&lt;/code&gt; 별명을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ce2298b180c8607f70e58c08e6ccdb870ec4f0c" translate="yes" xml:space="preserve">
          <source>It's identical to &lt;em&gt;Carol&lt;/em&gt;'s constructor except for the additional &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;&lt;/code&gt; decorator.</source>
          <target state="translated">그것은 동일의 &lt;em&gt;캐롤&lt;/em&gt; 추가를 제외하고 '생성자 &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;&lt;/code&gt; 장식.</target>
        </trans-unit>
        <trans-unit id="eae527c8fde7a93b29c9ba68e0c762ac9e719b0c" translate="yes" xml:space="preserve">
          <source>It's important to note that this guarantee is &lt;strong&gt;stronger&lt;/strong&gt; than that provided by the normal web deployment model. Without a service worker, there is no guarantee that code lazily loaded later in a running app is from the same version as the initial code for the app.</source>
          <target state="translated">이 보증은 일반 웹 배포 모델에서 제공하는 것보다 &lt;strong&gt;강력&lt;/strong&gt; 하다는 점 에 유의해야합니다 . 서비스 워커가 없으면 나중에 실행중인 앱에 느리게로드 된 코드가 앱의 초기 코드와 동일한 버전임을 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9db5b0bbcab65b4cd73852c1ab0915c241d74fda" translate="yes" xml:space="preserve">
          <source>It's important to note that you cannot register this worker directly, as old clients with cached state may not see a new &lt;code&gt;index.html&lt;/code&gt; which installs the different worker script. Instead, you must serve the contents of &lt;code&gt;safety-worker.js&lt;/code&gt; at the URL of the Service Worker script you are trying to unregister, and must continue to do so until you are certain all users have successfully unregistered the old worker. For most sites, this means that you should serve the safety worker at the old Service Worker URL forever.</source>
          <target state="translated">캐시 된 상태의 이전 클라이언트 에는 다른 작업자 스크립트를 설치 하는 새로운 &lt;code&gt;index.html&lt;/code&gt; 이 표시되지 않을 수 있으므로이 작업자를 직접 등록 할 수는 없습니다 . 대신 등록을 취소하려는 Service Worker 스크립트의 URL에서 &lt;code&gt;safety-worker.js&lt;/code&gt; 의 내용을 제공 해야하며 모든 사용자가 이전 작업자를 성공적으로 등록 취소 할 때까지 계속해야합니다. 대부분의 사이트에서 이는 이전 서비스 작업자 URL에서 안전 작업자를 영원히 서비스해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e74e1f2339eafee8c333b7f5cf205b600c69bb1c" translate="yes" xml:space="preserve">
          <source>It's nice to tidy up and you'll be grateful to yourself later. Here's the class after pruning away the dead code.</source>
          <target state="translated">정리하는 것이 좋으며 나중에 스스로에게 감사 할 것입니다. 죽은 코드를 정리 한 후의 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="34494c9030345f1487599d11e1d17558d38fe1c0" translate="yes" xml:space="preserve">
          <source>It's no longer possible to overwrite lifecycle hooks with mocks on directive instances for testing (instead, modify the lifecycle hook on the directive type itself).</source>
          <target state="translated">더 이상 테스트를 위해 지시문 인스턴스에서 모의로 라이프 사이클 후크를 덮어 쓸 수 없습니다 (대신 지시문 유형 자체에서 라이프 사이클 후크를 수정).</target>
        </trans-unit>
        <trans-unit id="a88c6800d206ae0cb17eaddfbc40c121f4954f34" translate="yes" xml:space="preserve">
          <source>It's not as simple as intercepting a request to the root address &lt;code&gt;/&lt;/code&gt;. The browser could ask for one of the application routes such as &lt;code&gt;/dashboard&lt;/code&gt;, &lt;code&gt;/heroes&lt;/code&gt;, or &lt;code&gt;/detail:12&lt;/code&gt;. In fact, if the app were only rendered by the server, &lt;em&gt;every&lt;/em&gt; app link clicked would arrive at the server as a navigation URL intended for the router.</source>
          <target state="translated">루트 주소 &lt;code&gt;/&lt;/code&gt; 에 대한 요청을 가로채는 것만 큼 간단하지 않습니다 . 브라우저는 &lt;code&gt;/dashboard&lt;/code&gt; , &lt;code&gt;/heroes&lt;/code&gt; 또는 &lt;code&gt;/detail:12&lt;/code&gt; 와 같은 응용 프로그램 경로 중 하나를 요청할 수 있습니다. 실제로 앱이 서버에 의해서만 렌더링 된 경우 클릭 한 &lt;em&gt;모든&lt;/em&gt; 앱 링크는 라우터 용 탐색 URL로 서버에 도착합니다.</target>
        </trans-unit>
        <trans-unit id="4480eae9954dacdb424800801156a46c1ca47a25" translate="yes" xml:space="preserve">
          <source>It's not much fun updating the template to test the custom pipe. Upgrade the example to a &quot;Power Boost Calculator&quot; that combines your pipe and two-way data binding with &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">커스텀 파이프를 테스트하기 위해 템플릿을 업데이트하는 것은 그리 재미 있지 않습니다. 파이프와 양방향 데이터 바인딩을 &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 과 결합한 &quot;파워 부스트 계산기&quot;로 예제를 업그레이드하십시오 .</target>
        </trans-unit>
        <trans-unit id="36d858deb7acc1b44aba6f193eae181e7610542d" translate="yes" xml:space="preserve">
          <source>It's not possible to stub the component's &lt;code&gt;HeroDetailService&lt;/code&gt; in the &lt;code&gt;providers&lt;/code&gt; of the &lt;code&gt;TestBed.configureTestingModule&lt;/code&gt;. Those are providers for the &lt;em&gt;testing module&lt;/em&gt;, not the component. They prepare the dependency injector at the &lt;em&gt;fixture level&lt;/em&gt;.</source>
          <target state="translated">이 구성 요소의 스텁 수는 없습니다 &lt;code&gt;HeroDetailService&lt;/code&gt; 을 에서 &lt;code&gt;providers&lt;/code&gt; 의 &lt;code&gt;TestBed.configureTestingModule&lt;/code&gt; . 이들은 구성 요소가 아닌 &lt;em&gt;테스트 모듈의&lt;/em&gt; 공급자입니다 . 그들은 &lt;em&gt;정착물 수준&lt;/em&gt; 에서 의존성 인젝터를 준비합니다 .</target>
        </trans-unit>
        <trans-unit id="7933cc3e6088270dbdd94b164b5a3e681402b77e" translate="yes" xml:space="preserve">
          <source>It's often better to create an appropriate folder for them in the &lt;code&gt;tests&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;tests&lt;/code&gt; 디렉토리 에 적절한 폴더를 만드는 것이 더 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="69b70cec57aa9f3f0a7a6b85e143f4fb3199dd40" translate="yes" xml:space="preserve">
          <source>It's often easier and more clear to filter with a standard &lt;code&gt;HTMLElement&lt;/code&gt; method such as &lt;code&gt;&lt;a href=&quot;testing&quot;&gt;querySelector()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;testing&quot;&gt;querySelectorAll()&lt;/a&gt;&lt;/code&gt;, as you'll see in the next set of tests.</source>
          <target state="translated">다음 테스트 세트에서 볼 수 있듯이 &lt;code&gt;&lt;a href=&quot;testing&quot;&gt;querySelector()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;testing&quot;&gt;querySelectorAll()&lt;/a&gt;&lt;/code&gt; 과 같은 표준 &lt;code&gt;HTMLElement&lt;/code&gt; 메소드 로 필터링하는 것이 더 쉽고 명확합니다 .</target>
        </trans-unit>
        <trans-unit id="33dd8893cf93c4e6ca6f4628047b460d359f5f36" translate="yes" xml:space="preserve">
          <source>It's often easier and more clear to filter with a standard &lt;code&gt;HTMLElement&lt;/code&gt; method such as &lt;code&gt;querySelector()&lt;/code&gt; or &lt;code&gt;querySelectorAll()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;querySelector()&lt;/code&gt; 또는 &lt;code&gt;querySelectorAll()&lt;/code&gt; 과 같은 표준 &lt;code&gt;HTMLElement&lt;/code&gt; 메소드 로 필터링하는 것이 더 쉽고 명확합니다 .</target>
        </trans-unit>
        <trans-unit id="de2e6fbff08a65946c5039baf520c82a6fb6449d" translate="yes" xml:space="preserve">
          <source>It's possible for &lt;code&gt;$locationChange&lt;/code&gt; events to happen, but for the browser URL (window.location) to remain unchanged. This &lt;code&gt;onChange&lt;/code&gt; callback will fire only when AngularJS actually updates the browser URL (window.location).</source>
          <target state="translated">그것은을 위해 가능 &lt;code&gt;$locationChange&lt;/code&gt; 이벤트가 발생하는 것이 아니라 브라우저의 URL (에서는 window.location)에 대한 변경되지 않은 상태로 유지 할 수 있습니다. 이 &lt;code&gt;onChange&lt;/code&gt; 콜백은 AngularJS가 실제로 브라우저 URL (window.location)을 업데이트 할 때만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0cb9b96f78d78cd173396cf253b6e58b220b0340" translate="yes" xml:space="preserve">
          <source>It's possible to ask the service worker to check if any updates have been deployed to the server. The service worker checks for updates during initialization and on each navigation request&amp;mdash;that is, when the user navigates from a different address to your app. However, you might choose to manually check for updates if you have a site that changes frequently or want updates to happen on a schedule.</source>
          <target state="translated">서비스 워커에게 업데이트가 서버에 배포되었는지 확인하도록 요청할 수 있습니다. 서비스 워커는 초기화 중 및 각 탐색 요청, 즉 사용자가 다른 주소에서 앱으로 이동할 때 업데이트를 확인합니다. 그러나 자주 변경되는 사이트가 있거나 일정에 따라 업데이트를 수행하려는 경우 수동으로 업데이트를 확인하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d37c9df140e369670ed6bb296a85b5b6dfb223d" translate="yes" xml:space="preserve">
          <source>It's possible to ask the service worker to check if any updates have been deployed to the server. You might choose to do this if you have a site that changes frequently or want updates to happen on a schedule.</source>
          <target state="translated">서비스 담당자에게 업데이트가 서버에 배포되었는지 확인하도록 요청할 수 있습니다. 자주 변경되는 사이트가 있거나 일정에 따라 업데이트를 수행하려는 경우이 작업을 수행하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af32a95f4c2aebf2b62f7cd376de21ad5a8dffab" translate="yes" xml:space="preserve">
          <source>It's preferable to pre-fetch data from the server so it's ready the moment the route is activated. This also allows you to handle errors before routing to the component. There's no point in navigating to a crisis detail for an &lt;code&gt;id&lt;/code&gt; that doesn't have a record. It'd be better to send the user back to the &lt;code&gt;Crisis &lt;a href=&quot;../api/common/numbersymbol#List&quot;&gt;List&lt;/a&gt;&lt;/code&gt; that shows only valid crisis centers.</source>
          <target state="translated">경로가 활성화되는 순간을 대비할 수 있도록 서버에서 데이터를 미리 가져 오는 것이 좋습니다. 또한 구성 요소로 라우팅하기 전에 오류를 처리 할 수 ​​있습니다. 기록이없는 &lt;code&gt;id&lt;/code&gt; 대한 위기 세부 정보를 탐색 할 필요는 없습니다. 유효한 위기 센터 만 표시 하는 &lt;code&gt;Crisis &lt;a href=&quot;../api/common/numbersymbol#List&quot;&gt;List&lt;/a&gt;&lt;/code&gt; 사용자를 다시 보내는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="871df3f9bf4a0065fd65bd1d8ff90e84ce8843d2" translate="yes" xml:space="preserve">
          <source>It's still an async test, calling &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; and &lt;a href=&quot;../api/core/testing/tick&quot;&gt;tick()&lt;/a&gt;, because the component itself calls &lt;code&gt;setTimeout()&lt;/code&gt; when processing errors.</source>
          <target state="translated">오류를 처리 할 때 구성 요소 자체가 &lt;code&gt;setTimeout()&lt;/code&gt; 호출하기 때문에 여전히 비동기 테스트이며 &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; 및 &lt;a href=&quot;../api/core/testing/tick&quot;&gt;tick ()을&lt;/a&gt; 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="75b5fea13d499ea02d483d5825f4588a4c55e4de" translate="yes" xml:space="preserve">
          <source>It's still an async test, calling &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/core/applicationref#tick&quot;&gt;tick()&lt;/a&gt;&lt;/code&gt;, because the component itself calls &lt;code&gt;setTimeout()&lt;/code&gt; when processing errors.</source>
          <target state="translated">구성 요소 자체에서 오류를 처리 할 때 &lt;code&gt;setTimeout()&lt;/code&gt; 호출하기 때문에 &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/core/applicationref#tick&quot;&gt;tick()&lt;/a&gt;&lt;/code&gt; 호출하는 여전히 비동기 테스트 입니다.</target>
        </trans-unit>
        <trans-unit id="11cce46b02b398c680b8cd2e4906b38f9b8086dd" translate="yes" xml:space="preserve">
          <source>It's the brackets (&lt;code&gt;[]&lt;/code&gt;) that make it an attribute selector. Angular locates each element in the template that has an attribute named &lt;code&gt;appHighlight&lt;/code&gt; and applies the logic of this directive to that element.</source>
          <target state="translated">속성 선택 자로 만드는 것은 대괄호 ( &lt;code&gt;[]&lt;/code&gt; )입니다. Angular는 &lt;code&gt;appHighlight&lt;/code&gt; 라는 속성이있는 템플리트에서 각 요소를 찾고이 지시문의 논리를 해당 요소에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="d0e169e22ebee633303a5cfbc4f3efc6239042d4" translate="yes" xml:space="preserve">
          <source>It's time to add real features to the app's current placeholder crisis center.</source>
          <target state="translated">이제 앱의 현재 자리 표시 자 위기 센터에 실제 기능을 추가 할 차례입니다.</target>
        </trans-unit>
        <trans-unit id="93572108533b695852669c26df4d5072f1d7409a" translate="yes" xml:space="preserve">
          <source>It's used throughout the application, perhaps most simply in the &lt;code&gt;AboutComponent&lt;/code&gt;:</source>
          <target state="translated">응용 프로그램 전체에서 사용되며 아마도 &lt;code&gt;AboutComponent&lt;/code&gt; 에서 가장 간단하게 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="90d2c8844c1e3e393da4af416666932eaeab7062" translate="yes" xml:space="preserve">
          <source>IterableChangeRecord</source>
          <target state="translated">IterableChangeRecord</target>
        </trans-unit>
        <trans-unit id="65bf71a2aefacfda4d7b23bc058c87dadebdf19f" translate="yes" xml:space="preserve">
          <source>IterableChanges</source>
          <target state="translated">IterableChanges</target>
        </trans-unit>
        <trans-unit id="c04313d783fe0e607c4d190cf131f3656b1d8927" translate="yes" xml:space="preserve">
          <source>IterableDiffer</source>
          <target state="translated">IterableDiffer</target>
        </trans-unit>
        <trans-unit id="c7213c9ad2d27ea342b15057ff78294c56b1b169" translate="yes" xml:space="preserve">
          <source>IterableDifferFactory</source>
          <target state="translated">IterableDifferFactory</target>
        </trans-unit>
        <trans-unit id="4364a912da1d06d537974eb8581e6a149ccdd75d" translate="yes" xml:space="preserve">
          <source>IterableDiffers</source>
          <target state="translated">IterableDiffers</target>
        </trans-unit>
        <trans-unit id="b4f02bf069d0c4048fa93e0b57dc8e1868b21afd" translate="yes" xml:space="preserve">
          <source>Iterate over a set of operations which when applied to the original &lt;code&gt;Iterable&lt;/code&gt; will produce the new &lt;code&gt;Iterable&lt;/code&gt;.</source>
          <target state="translated">원래 &lt;code&gt;Iterable&lt;/code&gt; 에 적용될 때 새로운 &lt;code&gt;Iterable&lt;/code&gt; 을 생성 하는 일련의 작업을 반복 합니다.</target>
        </trans-unit>
        <trans-unit id="d9ffa02faa4bce072280e6f955939fc074385b0c" translate="yes" xml:space="preserve">
          <source>Iterate over all added items.</source>
          <target state="translated">추가 된 모든 항목을 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="7b02d8c737198c5290f7d076a7fb4c7d9d683e29" translate="yes" xml:space="preserve">
          <source>Iterate over all changes. &lt;code&gt;&lt;a href=&quot;iterablechangerecord&quot;&gt;IterableChangeRecord&lt;/a&gt;&lt;/code&gt; will contain information about changes to each item.</source>
          <target state="translated">모든 변경 사항을 반복하십시오. &lt;code&gt;&lt;a href=&quot;iterablechangerecord&quot;&gt;IterableChangeRecord&lt;/a&gt;&lt;/code&gt; 에는 각 항목의 변경 사항에 대한 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="beb98ba78ea6ecd3802b7151eadeefd5b1c99318" translate="yes" xml:space="preserve">
          <source>Iterate over all changes. &lt;code&gt;&lt;a href=&quot;keyvaluechangerecord&quot;&gt;KeyValueChangeRecord&lt;/a&gt;&lt;/code&gt; will contain information about changes to each item.</source>
          <target state="translated">모든 변경 사항을 반복하십시오. &lt;code&gt;&lt;a href=&quot;keyvaluechangerecord&quot;&gt;KeyValueChangeRecord&lt;/a&gt;&lt;/code&gt; 에는 각 항목의 변경 사항에 대한 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="29c0d96526568e9909421843c0f1afea4a690e7c" translate="yes" xml:space="preserve">
          <source>Iterate over all items which had their identity (as computed by the &lt;code&gt;&lt;a href=&quot;trackbyfunction&quot;&gt;TrackByFunction&lt;/a&gt;&lt;/code&gt;) changed.</source>
          <target state="translated">ID가 변경된 모든 항목 ( &lt;code&gt;&lt;a href=&quot;trackbyfunction&quot;&gt;TrackByFunction&lt;/a&gt;&lt;/code&gt; 에 의해 계산 됨 )을 반복하십시오 .</target>
        </trans-unit>
        <trans-unit id="4e85b2b64bc908fceeecabec10e0065e19464566" translate="yes" xml:space="preserve">
          <source>Iterate over all keys for which values have changed.</source>
          <target state="translated">값이 변경된 모든 키를 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="fb1385171738b82cea0b7d429c1042f5e8978d31" translate="yes" xml:space="preserve">
          <source>Iterate over all moved items.</source>
          <target state="translated">이동 한 모든 항목을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="cfb6e0e8a0c18815505bb8efd4f29e4d8ac463a0" translate="yes" xml:space="preserve">
          <source>Iterate over all removed items.</source>
          <target state="translated">제거 된 모든 항목을 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="d45779a25ee648454d24aa9fdd02da54d493be84" translate="yes" xml:space="preserve">
          <source>Iterate over changes in the order of original &lt;code&gt;Iterable&lt;/code&gt; showing where the original items have moved.</source>
          <target state="translated">반복 처리를 통해 원래의 순서 변경 &lt;code&gt;Iterable&lt;/code&gt; 원본 항목이 이동 한 게재.</target>
        </trans-unit>
        <trans-unit id="66bd7b588566a69a193c5a2f36874c0414c74a1d" translate="yes" xml:space="preserve">
          <source>Iterate over changes in the order of original Map showing where the original items have moved.</source>
          <target state="translated">원래 항목이 이동 한 위치를 표시하는 원래 맵 순서대로 변경 사항을 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="ea79adbb1c7288e6d303027d9db472281313ff38" translate="yes" xml:space="preserve">
          <source>Iterating through the values in a stream</source>
          <target state="translated">스트림의 값을 반복</target>
        </trans-unit>
        <trans-unit id="6406032da55c56d8885f6b288e705bcb402f7d72" translate="yes" xml:space="preserve">
          <source>Its &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/mode&quot;&gt;mode&lt;/a&gt; is &lt;code&gt;navigation&lt;/code&gt;.</source>
          <target state="translated">그것의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/mode&quot;&gt;모드&lt;/a&gt; 입니다 &lt;code&gt;navigation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b563b2914e52ad780cc6bdd2b9a6539c97c4b58" translate="yes" xml:space="preserve">
          <source>Its URL matches certain criteria (see below).</source>
          <target state="translated">URL은 특정 기준과 일치합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="2e88fcbebf8ad2a04b9f75bc715de634f8a37725" translate="yes" xml:space="preserve">
          <source>Its companion component class &lt;code&gt;flying-heroes.component.ts (v1)&lt;/code&gt; provides heroes, adds heroes into the array, and resets the array.</source>
          <target state="translated">동반 구성 요소 클래스 &lt;code&gt;flying-heroes.component.ts (v1)&lt;/code&gt; 는 영웅을 제공하고, 영웅을 배열에 추가하고, 배열을 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="f3742ddc65ddad911e4f7f284021686e152498d7" translate="yes" xml:space="preserve">
          <source>Ivy</source>
          <target state="translated">Ivy</target>
        </trans-unit>
        <trans-unit id="6417fef38d8d9de0afac7152272dfc555180d824" translate="yes" xml:space="preserve">
          <source>Ivy and Universal/App shell</source>
          <target state="translated">Ivy 및 Universal / App 셸</target>
        </trans-unit>
        <trans-unit id="160098452aad6512767e7539f0472d4967ddc942" translate="yes" xml:space="preserve">
          <source>Ivy and libraries</source>
          <target state="translated">아이비와 도서관</target>
        </trans-unit>
        <trans-unit id="46a052845c1cd470a77a7e698fb651d5f8c56d52" translate="yes" xml:space="preserve">
          <source>Ivy applications can be built with libraries that were created with the View Engine compiler. This compatibility is provided by a tool known as the Angular compatibility compiler (&lt;code&gt;ngcc&lt;/code&gt;). CLI commands run &lt;code&gt;ngcc&lt;/code&gt; as needed when performing an Angular build.</source>
          <target state="translated">Ivy 애플리케이션은 View Engine 컴파일러로 만든 라이브러리로 빌드 할 수 있습니다. 이 호환성은 Angular 호환성 컴파일러 ( &lt;code&gt;ngcc&lt;/code&gt; ) 라는 도구에 의해 제공됩니다 . CLI 명령 은 Angular 빌드를 수행 할 때 필요에 따라 &lt;code&gt;ngcc&lt;/code&gt; 를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="6172cf4831e34f113151cb2ac9635dff5d8d0b0d" translate="yes" xml:space="preserve">
          <source>Ivy compatibility guide</source>
          <target state="translated">아이비 호환성 가이드</target>
        </trans-unit>
        <trans-unit id="84a2abde412642218f0e5080324588754f35f7af" translate="yes" xml:space="preserve">
          <source>Ivy does not support merging i18n translations when using JIT mode. If you &lt;a href=&quot;ivy#opting-out-of-ivy-in-version-9&quot;&gt;disable Ivy&lt;/a&gt; and are using JIT mode, see &lt;a href=&quot;https://v8.angular.io/guide/i18n#merge-with-the-jit-compiler&quot;&gt;merging with the JIT compiler&lt;/a&gt;.</source>
          <target state="translated">Ivy는 JIT 모드를 사용할 때 i18n 번역 병합을 지원하지 않습니다. &lt;a href=&quot;ivy#opting-out-of-ivy-in-version-9&quot;&gt;Ivy&lt;/a&gt; 를 비활성화 하고 JIT 모드를 사용 &lt;a href=&quot;https://v8.angular.io/guide/i18n#merge-with-the-jit-compiler&quot;&gt;하는 경우 JIT 컴파일러와 병합을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1683c48b5f7747723f4d8164bb4a3451f3cc60d" translate="yes" xml:space="preserve">
          <source>Ivy features and compatibility</source>
          <target state="translated">Ivy 기능 및 호환성</target>
        </trans-unit>
        <trans-unit id="533daa94e88ce1081e6444153c285b64693f39ce" translate="yes" xml:space="preserve">
          <source>Ivy is the code name for Angular's &lt;a href=&quot;https://blog.angular.io/a-plan-for-version-8-0-and-ivy-b3318dfc19f7&quot;&gt;next-generation compilation and rendering pipeline&lt;/a&gt;. Starting with Angular version 8, you can choose to opt in to start using a preview version of Ivy and help in its continuing development and tuning.</source>
          <target state="translated">아이비는 Angular의 &lt;a href=&quot;https://blog.angular.io/a-plan-for-version-8-0-and-ivy-b3318dfc19f7&quot;&gt;차세대 컴파일 및 렌더링 파이프 라인&lt;/a&gt; 의 코드 이름입니다 . Angular 버전 8부터는 Ivy의 미리보기 버전 사용을 시작하도록 선택하고 계속 개발 및 조정하는 데 도움을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33a8f2f4e1a0fb21c331debb10a11bb20a968878" translate="yes" xml:space="preserve">
          <source>Ivy is the code name for Angular's &lt;a href=&quot;https://blog.angular.io/a-plan-for-version-8-0-and-ivy-b3318dfc19f7&quot;&gt;next-generation compilation and rendering pipeline&lt;/a&gt;. With the version 9 release of Angular, the new compiler and runtime instructions are used by default instead of the older compiler and runtime, known as &lt;a href=&quot;glossary#ve&quot;&gt;View Engine&lt;/a&gt;.</source>
          <target state="translated">Ivy는 Angular의 &lt;a href=&quot;https://blog.angular.io/a-plan-for-version-8-0-and-ivy-b3318dfc19f7&quot;&gt;차세대 컴파일 및 렌더링 파이프 라인&lt;/a&gt; 의 코드 이름입니다 . Angular 버전 9 릴리스에서는 &lt;a href=&quot;glossary#ve&quot;&gt;View Engine&lt;/a&gt; 이라고하는 이전 컴파일러 및 런타임 대신 새 컴파일러 및 런타임 명령이 기본적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="914de7c4c667979756cde1759caaab274ed4150c" translate="yes" xml:space="preserve">
          <source>Ivy is the code name for Angular's &lt;a href=&quot;https://blog.angular.io/a-plan-for-version-8-0-and-ivy-b3318dfc19f7&quot;&gt;next-generation compilation and rendering pipeline&lt;/a&gt;. With the version 9 release of Angular, the new compiler and runtime instructions are used by default instead of the older compiler and runtime, known as View Engine.</source>
          <target state="translated">Ivy는 Angular의 &lt;a href=&quot;https://blog.angular.io/a-plan-for-version-8-0-and-ivy-b3318dfc19f7&quot;&gt;차세대 컴파일 및 렌더링 파이프 라인&lt;/a&gt; 의 코드 이름입니다 . Angular 버전 9 릴리스에서는 View Engine으로 알려진 이전 컴파일러 및 런타임 대신 새 컴파일러 및 런타임 명령이 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="97c35ca691769b08824133a20d0b01e844696c10" translate="yes" xml:space="preserve">
          <source>JIT compilation is the default (as opposed to AOT compilation) when you run Angular's &lt;code&gt;ng build&lt;/code&gt; and &lt;code&gt;ng serve&lt;/code&gt; CLI commands, and is a good choice during development. JIT mode is strongly discouraged for production use because it results in large application payloads that hinder the bootstrap performance.</source>
          <target state="translated">JIT 컴파일은 Angular의 &lt;code&gt;ng build&lt;/code&gt; 및 &lt;code&gt;ng serve&lt;/code&gt; CLI 명령 을 실행할 때 기본값 (AOT 컴파일과 달리) 이며 개발 중에 선택하는 것이 좋습니다. JIT 모드는 큰 응용 프로그램 페이로드로 인해 부트 스트랩 성능을 방해하므로 프로덕션 용도로는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="100955a614a47a100a0c1d379a56348ad67eab92" translate="yes" xml:space="preserve">
          <source>JIT compilation is the default when you run the &lt;a href=&quot;cli/build&quot;&gt;&lt;code&gt;ng build&lt;/code&gt;&lt;/a&gt; (build only) or &lt;a href=&quot;cli/serve&quot;&gt;&lt;code&gt;ng serve&lt;/code&gt;&lt;/a&gt; (build and serve locally) CLI commands:</source>
          <target state="translated">JIT 컴파일은 &lt;a href=&quot;cli/build&quot;&gt; &lt;code&gt;ng build&lt;/code&gt; &lt;/a&gt; (빌드 전용) 또는 &lt;a href=&quot;cli/serve&quot;&gt; &lt;code&gt;ng serve&lt;/code&gt; &lt;/a&gt; (빌드 및 로컬로 제공) CLI 명령 을 실행할 때의 기본값입니다 .</target>
        </trans-unit>
        <trans-unit id="f39e4bdefdba26f9731fa104f4dc571370e960e1" translate="yes" xml:space="preserve">
          <source>JSON files</source>
          <target state="translated">JSON 파일</target>
        </trans-unit>
        <trans-unit id="200ea8b30d97106e227dd426de9470d1b9e5f6dc" translate="yes" xml:space="preserve">
          <source>JSONP Example</source>
          <target state="translated">JSONP 예</target>
        </trans-unit>
        <trans-unit id="5126883581dd0d87d57ac5704c8df63b2bc61717" translate="yes" xml:space="preserve">
          <source>Jasmine &lt;em&gt;done()&lt;/em&gt;</source>
          <target state="translated">재스민 &lt;em&gt;완료 ()&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7b8ef1b9cd0e4f4d6572da9bde4bff2706b7e3ca" translate="yes" xml:space="preserve">
          <source>Jasmine also provides a &lt;code&gt;clock&lt;/code&gt; feature to mock dates. Angular automatically runs tests that are run after &lt;code&gt;jasmine.clock().install()&lt;/code&gt; is called inside a &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; method until &lt;code&gt;jasmine.clock().uninstall()&lt;/code&gt; is called. &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; is not needed and throws an error if nested.</source>
          <target state="translated">Jasmine은 날짜를 조롱 하는 &lt;code&gt;clock&lt;/code&gt; 기능 도 제공합니다 . Angular 는 &lt;code&gt;jasmine.clock().uninstall()&lt;/code&gt; 이 호출 될 때까지 jasmine.clock (). &lt;code&gt;jasmine.clock().install()&lt;/code&gt; 이 &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; 메서드 내에서 호출 된 후 실행되는 테스트를 자동으로 실행합니다 . &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; () 가 필요하지 않으며 중첩 된 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="e4e56910ea532a32775fa361c6e193dfb89d0f17" translate="yes" xml:space="preserve">
          <source>JavaScript Modules vs. NgModules</source>
          <target state="translated">자바 스크립트 모듈과 NgModules</target>
        </trans-unit>
        <trans-unit id="fdca30518a58215f071ba5c35508f58fe8c3fc88" translate="yes" xml:space="preserve">
          <source>JavaScript and Angular use modules to organize code, and though they organize it differently, Angular apps rely on both.</source>
          <target state="translated">JavaScript와 Angular는 모듈을 사용하여 코드를 구성하며, 코드를 다르게 구성하지만 Angular 앱은 둘 다에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="e427373b78bde22bea74df011ec7e3ebee573414" translate="yes" xml:space="preserve">
          <source>JavaScript features new to ES2015, like arrow functions, &lt;code&gt;let&lt;/code&gt;s and &lt;code&gt;const&lt;/code&gt;s, default function parameters, and destructuring assignments can also be gradually added to make the code more expressive.</source>
          <target state="translated">화살표 기능, &lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt; , 기본 기능 매개 변수 및 구조 지정 할당과 같이 ES2015에 새로 추가 된 JavaScript 기능을 점차적으로 추가하여 코드를보다 표현 적으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="813155b28b8ee2bbf4f6efd8be0aff1a8379446a" translate="yes" xml:space="preserve">
          <source>JavaScript modules</source>
          <target state="translated">자바 스크립트 모듈</target>
        </trans-unit>
        <trans-unit id="6272c55fb8883905bd42232de7e38543bd97f3e0" translate="yes" xml:space="preserve">
          <source>JavaScript modules and NgModules can help you modularize your code, but they are very different. Angular apps rely on both kinds of modules.</source>
          <target state="translated">JavaScript 모듈과 NgModules는 코드를 모듈화하는 데 도움이 될 수 있지만 매우 다릅니다. Angular 앱은 두 종류의 모듈에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="80315fb1334c813a6b687f8cf6aba6867ead2d1b" translate="yes" xml:space="preserve">
          <source>JavaScript modules help you namespace, preventing accidental global variables.</source>
          <target state="translated">JavaScript 모듈은 네임 스페이스를 도와 우발적 인 전역 변수를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="638d218e5afc21a4aaced22467fdfeee6f031a25" translate="yes" xml:space="preserve">
          <source>JavaScript modules vs. NgModules</source>
          <target state="translated">자바 스크립트 모듈 vs. NgModules</target>
        </trans-unit>
        <trans-unit id="3b77e8995b03370ac676628ae0b22c65d3fac5b0" translate="yes" xml:space="preserve">
          <source>JavaScript modules: Files containing code</source>
          <target state="translated">JavaScript 모듈 : 코드가 포함 된 파일</target>
        </trans-unit>
        <trans-unit id="7466df73c7a75f7fab07289c7c1fb62ec498abba" translate="yes" xml:space="preserve">
          <source>JitCompilerFactory</source>
          <target state="translated">JitCompilerFactory</target>
        </trans-unit>
        <trans-unit id="a22aee298933fd3299920aebce3877a6554d67bf" translate="yes" xml:space="preserve">
          <source>Join our community</source>
          <target state="translated">우리 커뮤니티에 가입</target>
        </trans-unit>
        <trans-unit id="b069d85c6c5a1040d5766e98392651c7573ae4fc" translate="yes" xml:space="preserve">
          <source>Join the Angular community</source>
          <target state="translated">Angular 커뮤니티에 가입하세요</target>
        </trans-unit>
        <trans-unit id="87e6a6731c3d14a812bc4b63bb7fde49224e7eb9" translate="yes" xml:space="preserve">
          <source>Joins two parts of a URL with a slash if needed.</source>
          <target state="translated">필요한 경우 URL의 두 부분을 슬래시로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="5476e9b9f4a192c11d46458bd1af59f8fb187f48" translate="yes" xml:space="preserve">
          <source>JsonPipe</source>
          <target state="translated">JsonPipe</target>
        </trans-unit>
        <trans-unit id="f9734727c3307bfa948623de46c33ca6cfb42687" translate="yes" xml:space="preserve">
          <source>JsonpClientBackend</source>
          <target state="translated">JsonpClientBackend</target>
        </trans-unit>
        <trans-unit id="6dc692df4f14103795aed4e22a3eac866f471215" translate="yes" xml:space="preserve">
          <source>JsonpInterceptor</source>
          <target state="translated">JsonpInterceptor</target>
        </trans-unit>
        <trans-unit id="46405c235890cb26d0b5a6bcba77b2127eb88a79" translate="yes" xml:space="preserve">
          <source>Jun 24, 2020</source>
          <target state="translated">2020 년 6 월 24 일</target>
        </trans-unit>
        <trans-unit id="3d20c8ac3c0ebca318b90dcf112410be899903bd" translate="yes" xml:space="preserve">
          <source>Just as TypeScript catches type errors in your code, Angular checks the expressions and bindings within the templates of your application and can report any type errors it finds. Angular currently has three modes of doing this, depending on the value of the &lt;code&gt;fullTemplateTypeCheck&lt;/code&gt; and &lt;code&gt;strictTemplates&lt;/code&gt; flags in the &lt;a href=&quot;typescript-configuration&quot;&gt;TypeScript configuration file&lt;/a&gt;.</source>
          <target state="translated">TypeScript가 코드에서 유형 오류를 포착하는 것처럼 Angular는 애플리케이션의 템플릿 내에서 표현식과 바인딩을 확인하고 발견 된 유형 오류를보고 할 수 있습니다. Angular에는 현재 &lt;a href=&quot;typescript-configuration&quot;&gt;TypeScript 구성 파일&lt;/a&gt; 의 &lt;code&gt;fullTemplateTypeCheck&lt;/code&gt; 및 &lt;code&gt;strictTemplates&lt;/code&gt; 플래그 값에 따라 세 가지 모드가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86ade25665aab98adbdecbd2678a114f46ce9f95" translate="yes" xml:space="preserve">
          <source>Just as a form control instance gives you control over a single input field, a form group instance tracks the form state of a group of form control instances (for example, a form). Each control in a form group instance is tracked by name when creating the form group. The following example shows how to manage multiple form control instances in a single group.</source>
          <target state="translated">양식 제어 인스턴스가 단일 입력 필드를 제어 할 수있는 것처럼 양식 그룹 인스턴스는 양식 제어 인스턴스 그룹 (예 : 양식)의 양식 상태를 추적합니다. 양식 그룹 인스턴스의 각 컨트롤은 양식 그룹을 만들 때 이름별로 추적됩니다. 다음 예는 단일 그룹에서 여러 양식 제어 인스턴스를 관리하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7ba5c7cfe37fd57ce918bf417c82139cfd6e4c6d" translate="yes" xml:space="preserve">
          <source>Just as for components, the metadata for a directive associates the decorated class with a &lt;code&gt;selector&lt;/code&gt; element that you use to insert it into HTML. In templates, directives typically appear within an element tag as attributes, either by name or as the target of an assignment or a binding.</source>
          <target state="translated">컴포넌트와 마찬가지로 지시문의 메타 데이터는 데코 레이팅 된 클래스 를 HTML에 삽입하는 데 사용 하는 &lt;code&gt;selector&lt;/code&gt; 요소 와 연관시킵니다 . 템플릿에서 지시문은 일반적으로 요소 태그 내에 속성으로 이름 또는 할당 대상 또는 바인딩 대상으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="952028f0e1b2702fd956f9f61aab0587b89f85ff" translate="yes" xml:space="preserve">
          <source>Just as in the &lt;code&gt;FlowerService&lt;/code&gt; example, if you add &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; to the constructor for the &lt;code&gt;AnimalService&lt;/code&gt;, the injector won't look in the current &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt;'s &lt;code&gt;ElementInjector&lt;/code&gt; for the &lt;code&gt;AnimalService&lt;/code&gt;.</source>
          <target state="translated">그냥 같이 &lt;code&gt;FlowerService&lt;/code&gt; 의 추가 예, &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; 의 생성자에 &lt;code&gt;AnimalService&lt;/code&gt; , 인젝터는 현재에 보이지 않는 것 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; 의 &lt;code&gt;ElementInjector&lt;/code&gt; 에 대한 &lt;code&gt;AnimalService&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50a3565cd343f55461efc882d3f1056f8f2843ef" translate="yes" xml:space="preserve">
          <source>Just as with the &lt;code&gt;FlowerService&lt;/code&gt; example, the &lt;code&gt;AnimalService&lt;/code&gt; is provided in the &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt;&lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; decorator. This means that since the injector first looks in the &lt;code&gt;ElementInjector&lt;/code&gt; of the component, it finds the &lt;code&gt;AnimalService&lt;/code&gt; value of 🐶 (puppy). It doesn't need to continue searching the &lt;code&gt;ElementInjector&lt;/code&gt; tree, nor does it need to search the &lt;code&gt;ModuleInjector&lt;/code&gt;.</source>
          <target state="translated">단지와 마찬가지로 &lt;code&gt;FlowerService&lt;/code&gt; 의 예는 &lt;code&gt;AnimalService&lt;/code&gt; 은 에 제공되는 &lt;code&gt;&amp;lt;app-child&amp;gt;&lt;/code&gt; &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; 장식. 이는 인젝터 가 구성 요소 의 &lt;code&gt;ElementInjector&lt;/code&gt; 를 먼저 찾으므로 &lt;code&gt;AnimalService&lt;/code&gt; 값인 🐶 (puppy)를 찾습니다 . &lt;code&gt;ElementInjector&lt;/code&gt; 트리 를 계속 검색 할 필요가없고 &lt;code&gt;ModuleInjector&lt;/code&gt; 를 검색 할 필요도 없습니다 .</target>
        </trans-unit>
        <trans-unit id="bcbe13374c0b6e5160a92304e2958769789d6903" translate="yes" xml:space="preserve">
          <source>Just as you can project AngularJS content into Angular components, you can &lt;em&gt;transclude&lt;/em&gt; Angular content into AngularJS components, whenever you are using upgraded versions from them.</source>
          <target state="translated">AngularJS 컨텐츠를 Angular 컴포넌트로 투영 할 수있는 것처럼 업그레이드 된 버전을 사용할 때마다 Angular 컨텐츠를 AngularJS 컴포넌트로 &lt;em&gt;변환&lt;/em&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d3b5872a8da8780f730b9a6d692e8ef62ba276b" translate="yes" xml:space="preserve">
          <source>Just like Web and the entire web ecosystem, Angular is continuously improving. Angular balances continuous improvement with a strong focus on stability and making updates easy. Keeping your Angular app up-to-date enables you to take advantage of leading-edge new features, as well as optimizations and bug fixes.</source>
          <target state="translated">웹 및 전체 웹 에코 시스템과 마찬가지로 Angular는 지속적으로 개선되고 있습니다. Angular는 안정성에 중점을두고 지속적으로 개선하고 업데이트를 쉽게 만듭니다. Angular 앱을 최신 상태로 유지하면 최적화 및 버그 수정뿐만 아니라 최신 새로운 기능을 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ca2b5f86d531d00a29d9169b827a1109624e083" translate="yes" xml:space="preserve">
          <source>Just like synchronous validators have the &lt;code&gt;&lt;a href=&quot;../api/forms/validatorfn&quot;&gt;ValidatorFn&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/forms/validator&quot;&gt;Validator&lt;/a&gt;&lt;/code&gt; interfaces, asynchronous validators have their own counterparts: &lt;code&gt;&lt;a href=&quot;../api/forms/asyncvalidatorfn&quot;&gt;AsyncValidatorFn&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/forms/asyncvalidator&quot;&gt;AsyncValidator&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">동기식 유효성 검사기에 &lt;code&gt;&lt;a href=&quot;../api/forms/validatorfn&quot;&gt;ValidatorFn&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/forms/validator&quot;&gt;Validator&lt;/a&gt;&lt;/code&gt; 인터페이스 가있는 것처럼 비동기식 유효성 검사기는 자체 &lt;code&gt;&lt;a href=&quot;../api/forms/asyncvalidatorfn&quot;&gt;AsyncValidatorFn&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/forms/asyncvalidator&quot;&gt;AsyncValidator&lt;/a&gt;&lt;/code&gt; 를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="d673c861402fe0c15e579d517c4f053b2fcbfefe" translate="yes" xml:space="preserve">
          <source>Just like with &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt;, you can use &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; on a property of the child component but its type should be &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">단지와 같이 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; , 당신은 사용할 수 있습니다 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; 하위 구성 요소의 속성에 있지만, 그 유형은해야 &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="817700a4464e4e191b283e342f94c1991f779ce0" translate="yes" xml:space="preserve">
          <source>Just the Stackblitz</source>
          <target state="translated">그냥 스택 블리츠</target>
        </trans-unit>
        <trans-unit id="a1f18edf65e1f35b5d98a957b4ea1ca6278d408c" translate="yes" xml:space="preserve">
          <source>Karma configuration should then be changed so that it uses the application root dir as the base directory, instead of &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;app&lt;/code&gt; 대신 응용 프로그램 루트 디렉토리를 기본 디렉토리로 사용하도록 Karma 구성을 변경해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="42600b11fefe8ad521ad30fad8660704a0b4ffbf" translate="yes" xml:space="preserve">
          <source>Karma reporters to use. Directly passed to the karma runner.</source>
          <target state="translated">사용할 카르마 기자. 카르마 러너에게 직접 전달되었습니다.</target>
        </trans-unit>
        <trans-unit id="b4460e678bcf89af04481e0ca8656d0cee5a316f" translate="yes" xml:space="preserve">
          <source>Keep constructors simple</source>
          <target state="translated">생성자를 단순하게 유지</target>
        </trans-unit>
        <trans-unit id="8850b59a0703a38117329723734c5d92e2073bb3" translate="yes" xml:space="preserve">
          <source>Keep current by following the &lt;a href=&quot;https://blog.angular.io/&quot;&gt;Angular blog&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://blog.angular.io/&quot;&gt;Angular 블로그&lt;/a&gt; 를 따라 최신 정보를 유지하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e0d5a5af4787be28dd80c60ff4a76f4d1dcf910" translate="yes" xml:space="preserve">
          <source>Keep in mind that a directive's data-bound input properties are not set until &lt;em&gt;after construction&lt;/em&gt;. If you need to initialize the directive based on those properties, set them when &lt;code&gt;ngOnInit()&lt;/code&gt; runs.</source>
          <target state="translated">지시문의 데이터 바인딩 입력 속성은 &lt;em&gt;생성 후&lt;/em&gt; 까지 설정되지 않습니다 . 이러한 속성을 기반으로 지시문을 초기화해야하는 경우 &lt;code&gt;ngOnInit()&lt;/code&gt; 가 실행될 때 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="d9e51787ad5d5b5ca81319e00bd3e2af12366b1b" translate="yes" xml:space="preserve">
          <source>Keep template statements minimal by using method calls or basic property assignments.</source>
          <target state="translated">메서드 호출 또는 기본 속성 할당을 사용하여 템플릿 문을 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="5de9b63aa5c026111c38b95e17436330040893dc" translate="yes" xml:space="preserve">
          <source>Keep this process running in the background, watching and recompiling as you make changes.</source>
          <target state="translated">이 프로세스를 백그라운드에서 계속 실행하면서 변경하면서보고 재 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="75b190e26551d30888434ef5e10c264fd2094702" translate="yes" xml:space="preserve">
          <source>Keeping all features in one component as the application grows will not be maintainable. You'll want to split up large components into smaller sub-components, each focused on a specific task or workflow.</source>
          <target state="translated">응용 프로그램이 증가함에 따라 모든 기능을 하나의 구성 요소로 유지하는 것은 유지 관리 할 수 ​​없습니다. 큰 구성 요소를 각각 특정 작업 또는 워크 플로에 중점을 둔 더 작은 하위 구성 요소로 분할하려고합니다.</target>
        </trans-unit>
        <trans-unit id="3950ebebea0b9fa7aab3b677f39dbcffdc5260a0" translate="yes" xml:space="preserve">
          <source>Keeping your Angular Projects Up-to-Date</source>
          <target state="translated">Angular 프로젝트를 최신 상태로 유지</target>
        </trans-unit>
        <trans-unit id="009c1fdcb326fe22fdb96d8f6b762042126fa6be" translate="yes" xml:space="preserve">
          <source>Keeping your Angular projects up-to-date</source>
          <target state="translated">Angular 프로젝트를 최신 상태로 유지</target>
        </trans-unit>
        <trans-unit id="0e98238c1a123f2c93163aa116c02a7491e9b3d0" translate="yes" xml:space="preserve">
          <source>Key differences</source>
          <target state="translated">주요 차이점</target>
        </trans-unit>
        <trans-unit id="d24f1a6439a067297b07682b27dca0466177ddc2" translate="yes" xml:space="preserve">
          <source>Key event filtering (with &lt;code&gt;key.enter&lt;/code&gt;)</source>
          <target state="translated">키 이벤트 필터링 ( &lt;code&gt;key.enter&lt;/code&gt; 사용 )</target>
        </trans-unit>
        <trans-unit id="e6a63d973ce4fce07ea7910869aeaa58dcc486e5" translate="yes" xml:space="preserve">
          <source>Key takeaways:</source>
          <target state="translated">주요 내용 :</target>
        </trans-unit>
        <trans-unit id="bb3c05a548b50d8ab473aa91a3bc6c081c4b5c99" translate="yes" xml:space="preserve">
          <source>KeyValue</source>
          <target state="translated">KeyValue</target>
        </trans-unit>
        <trans-unit id="9b3401cf8def25530e9fd1c26637d0047a8726c9" translate="yes" xml:space="preserve">
          <source>KeyValueChangeRecord</source>
          <target state="translated">KeyValueChangeRecord</target>
        </trans-unit>
        <trans-unit id="73aa019b64cd0c76d411a1451198da70801d52c4" translate="yes" xml:space="preserve">
          <source>KeyValueChanges</source>
          <target state="translated">KeyValueChanges</target>
        </trans-unit>
        <trans-unit id="c9f3815ecee4aa3527346e46c9976e1e8f5842c1" translate="yes" xml:space="preserve">
          <source>KeyValueDiffer</source>
          <target state="translated">KeyValueDiffer</target>
        </trans-unit>
        <trans-unit id="b74cac1bdb5561f5eaed8f9096562dbc1cbfcbb5" translate="yes" xml:space="preserve">
          <source>KeyValueDifferFactory</source>
          <target state="translated">KeyValueDifferFactory</target>
        </trans-unit>
        <trans-unit id="c6bbedfd75cd733b25c3584df7236c67ccd8bcba" translate="yes" xml:space="preserve">
          <source>KeyValueDiffers</source>
          <target state="translated">KeyValueDiffers</target>
        </trans-unit>
        <trans-unit id="9ba558627c56c78559234ffc0ae09f6dc16dea1a" translate="yes" xml:space="preserve">
          <source>KeyValuePipe</source>
          <target state="translated">KeyValuePipe</target>
        </trans-unit>
        <trans-unit id="987e5e1f455e03766d3ef3740947f4db46336d53" translate="yes" xml:space="preserve">
          <source>Keyframes</source>
          <target state="translated">Keyframes</target>
        </trans-unit>
        <trans-unit id="6eb2cb65b6b265087cc2d5112489a6c3d6948a43" translate="yes" xml:space="preserve">
          <source>Keyframes include an &lt;em&gt;offset&lt;/em&gt; that defines the point in the animation where each style change occurs. Offsets are relative measures from zero to one, marking the beginning and end of the animation, respectively and should be applied to each of the keyframe's steps if used at least once.</source>
          <target state="translated">키 프레임에는 각 스타일 변경이 발생하는 애니메이션의 점을 정의 하는 &lt;em&gt;오프셋&lt;/em&gt; 이 포함 됩니다. 오프셋은 0에서 1까지의 상대적인 측정 값으로, 애니메이션의 시작과 끝을 각각 표시하며 적어도 한 번 사용하는 경우 각 키 프레임 단계에 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="893056aa39e96a084b3d311ebde22e7acf05fc70" translate="yes" xml:space="preserve">
          <source>Keyframes summary</source>
          <target state="translated">키 프레임 요약</target>
        </trans-unit>
        <trans-unit id="d6a03b41f716acfc6fd0ac6d70d7b37c373ace99" translate="yes" xml:space="preserve">
          <source>Keyframes with a pulsation</source>
          <target state="translated">맥동이있는 키 프레임</target>
        </trans-unit>
        <trans-unit id="258044e7b813d16f725b367c95a2d8e459f094fc" translate="yes" xml:space="preserve">
          <source>Keys have:</source>
          <target state="translated">열쇠는 :</target>
        </trans-unit>
        <trans-unit id="284add57ddefeac62dc890be8a4e8973296321db" translate="yes" xml:space="preserve">
          <source>Kicks off the animation and serves as a container for all other animation function calls. HTML template binds to &lt;code&gt;&lt;a href=&quot;../api/animations/animationevent#triggerName&quot;&gt;triggerName&lt;/a&gt;&lt;/code&gt;. Use the first argument to declare a unique trigger name. Uses array syntax.</source>
          <target state="translated">애니메이션을 시작하고 다른 모든 애니메이션 함수 호출을위한 컨테이너 역할을합니다. HTML 템플릿은 &lt;code&gt;&lt;a href=&quot;../api/animations/animationevent#triggerName&quot;&gt;triggerName&lt;/a&gt;&lt;/code&gt; 에 바인딩합니다 . 고유 한 트리거 이름을 선언하려면 첫 번째 인수를 사용하십시오. 배열 구문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fa438cb50759fa5742977214c2ee1e81a57db99b" translate="yes" xml:space="preserve">
          <source>Kicks off the animation and serves as a container for all other animation function calls. HTML template binds to &lt;code&gt;triggerName&lt;/code&gt;. Use the first argument to declare a unique trigger name. Uses array syntax.</source>
          <target state="translated">애니메이션을 시작하고 다른 모든 애니메이션 함수 호출을위한 컨테이너 역할을합니다. HTML 템플릿은 &lt;code&gt;triggerName&lt;/code&gt; 에 바인딩됩니다 . 첫 번째 인수를 사용하여 고유 한 트리거 이름을 선언하십시오. 배열 구문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b9a401030ae31427bf36aafaa6d13ce01e5c38e0" translate="yes" xml:space="preserve">
          <source>Kidding aside, pay attention to two key points:</source>
          <target state="translated">다음과 같은 두 가지 핵심 사항에주의를 기울이십시오.</target>
        </trans-unit>
        <trans-unit id="e4b6a725b52a13d1cccf14a76ba4d885abd9d4b0" translate="yes" xml:space="preserve">
          <source>Knowing that it is an &lt;code&gt;HTMLElement&lt;/code&gt; of some sort, you can use the standard HTML &lt;code&gt;querySelector&lt;/code&gt; to dive deeper into the element tree.</source>
          <target state="translated">그것이 일종의 &lt;code&gt;HTMLElement&lt;/code&gt; 라는 것을 알면 표준 HTML &lt;code&gt;querySelector&lt;/code&gt; 를 사용 하여 요소 트리를 더 깊이 파고들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="71131f7aee7025ef5618a88cee7db1bc11db3816" translate="yes" xml:space="preserve">
          <source>Knowledge of &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; is helpful, but not required.</source>
          <target state="translated">&lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript에 대한&lt;/a&gt; 지식 은 도움이되지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c4b1aea668c6b62ca0106cddefaf0fd61af5def7" translate="yes" xml:space="preserve">
          <source>Knowledge of this structure can inform how you provide and inject your services, and give you complete control of service visibility.</source>
          <target state="translated">이 구조에 대한 지식은 서비스 제공 및 주입 방법을 알려주고 서비스 가시성을 완전히 제어 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="855b4c3da111de1cc3bf0426bb3c3d9b0c13d293" translate="yes" xml:space="preserve">
          <source>L (S)</source>
          <target state="translated">L (S)</target>
        </trans-unit>
        <trans-unit id="ad97b692157548122b2491efcefede18a971027f" translate="yes" xml:space="preserve">
          <source>LIBRARY SOURCE FILES</source>
          <target state="translated">라이브러리 소스 파일</target>
        </trans-unit>
        <trans-unit id="1460dc33fdc66db88bdcc5b32057457efeed3ce5" translate="yes" xml:space="preserve">
          <source>LL</source>
          <target state="translated">LL</target>
        </trans-unit>
        <trans-unit id="ae6269698bf58fd847def39ce4ac2fae66e5387f" translate="yes" xml:space="preserve">
          <source>LLL</source>
          <target state="translated">LLL</target>
        </trans-unit>
        <trans-unit id="366642afad85161718d3199bbb3eeec4323b4561" translate="yes" xml:space="preserve">
          <source>LLLL</source>
          <target state="translated">LLLL</target>
        </trans-unit>
        <trans-unit id="2f63457c6d31c1457c936d330e5d022b720e7ea8" translate="yes" xml:space="preserve">
          <source>LLLLL</source>
          <target state="translated">LLLLL</target>
        </trans-unit>
        <trans-unit id="46dbfd3ddbab363ec3229828156cfc7cbbf79e53" translate="yes" xml:space="preserve">
          <source>LOCALE_ID</source>
          <target state="translated">LOCALE_ID</target>
        </trans-unit>
        <trans-unit id="5054e68056df235551347e024191933731ac90af" translate="yes" xml:space="preserve">
          <source>LOCATION_INITIALIZED</source>
          <target state="translated">LOCATION_INITIALIZED</target>
        </trans-unit>
        <trans-unit id="b5e0fa918e23be61311591d33895ec581f8ea479" translate="yes" xml:space="preserve">
          <source>LOCATION_UPGRADE_CONFIGURATION</source>
          <target state="translated">LOCATION_UPGRADE_CONFIGURATION</target>
        </trans-unit>
        <trans-unit id="80fea83804bf0e1f73c7272f7a19c26bc52d63ef" translate="yes" xml:space="preserve">
          <source>LTS</source>
          <target state="translated">LTS</target>
        </trans-unit>
        <trans-unit id="c3cddb869a298772e4140a9d210d3c1e037f73e9" translate="yes" xml:space="preserve">
          <source>LTS Ends</source>
          <target state="translated">LTS 끝</target>
        </trans-unit>
        <trans-unit id="ebe84b18d41b3defb8e3d74f6f0bd38e69c3d734" translate="yes" xml:space="preserve">
          <source>LTS fixes</source>
          <target state="translated">LTS 수정</target>
        </trans-unit>
        <trans-unit id="ddc05edf33a67ff62443367b7faa25ddb394059a" translate="yes" xml:space="preserve">
          <source>Language features outside of the compiler's &lt;a href=&quot;aot-compiler#expression-syntax&quot;&gt;restricted expression syntax&lt;/a&gt; can produce this error, as seen in the following example:</source>
          <target state="translated">다음 예제와 같이 컴파일러의 &lt;a href=&quot;aot-compiler#expression-syntax&quot;&gt;제한된 표현식 구문&lt;/a&gt; 이외의 언어 기능으로 인해이 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="838123c690032c3d77f2cf978058b56afa0f2909" translate="yes" xml:space="preserve">
          <source>Language services include:</source>
          <target state="translated">언어 서비스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="734fa40ff03686294aa0c60e9fa60f8ca7b15bcd" translate="yes" xml:space="preserve">
          <source>Large image files can be slow to load, harming the user experience. Always compress the image. Consider using an image compression web site such as &lt;a href=&quot;https://tinypng.com/&quot;&gt;tinypng&lt;/a&gt;.</source>
          <target state="translated">큰 이미지 파일은로드 속도가 느려서 사용자 경험에 해를 줄 수 있습니다. 항상 이미지를 압축하십시오. &lt;a href=&quot;https://tinypng.com/&quot;&gt;tinypng&lt;/a&gt; 와 같은 이미지 압축 웹 사이트를 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="fdbfb45b871130cc5890d749d31a074e087dbb17" translate="yes" xml:space="preserve">
          <source>Last update check</source>
          <target state="translated">마지막 업데이트 확인</target>
        </trans-unit>
        <trans-unit id="70a03b91dbc99c3f4c22b136089730dab49465a9" translate="yes" xml:space="preserve">
          <source>Lastly, call it within the &lt;code&gt;imports&lt;/code&gt; list of the &lt;code&gt;AppModule&lt;/code&gt;. In the following snippet, other parts of the file are left out. For the complete file, see the , or continue to the next section of this document.</source>
          <target state="translated">마지막으로 &lt;code&gt;AppModule&lt;/code&gt; 의 &lt;code&gt;imports&lt;/code&gt; 목록 내에서 호출하십시오 . 다음 스 니펫에서는 파일의 다른 부분이 생략됩니다. 전체 파일을 보려면를 참조하거나이 문서의 다음 섹션을 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="512803435153cdf149e51c2b7560f6d2d5123dc7" translate="yes" xml:space="preserve">
          <source>Later in this guide you will create &lt;a href=&quot;router#heroes-functionality&quot;&gt;multiple routing modules&lt;/a&gt; and discover that you must import those routing modules &lt;a href=&quot;router#routing-module-order&quot;&gt;in the correct order&lt;/a&gt;.</source>
          <target state="translated">이 가이드의 뒷부분에서 &lt;a href=&quot;router#heroes-functionality&quot;&gt;여러 라우팅 모듈&lt;/a&gt; 을 만들고 해당 라우팅 모듈 &lt;a href=&quot;router#routing-module-order&quot;&gt;을 올바른 순서로&lt;/a&gt; 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="1d334b9a4b3cf925264a3a1774fc490eb6e86a86" translate="yes" xml:space="preserve">
          <source>Later you'll call &lt;code&gt;TestBed.configureTestingModule()&lt;/code&gt; with imports, providers, and more declarations to suit your testing needs. Optional &lt;code&gt;override&lt;/code&gt; methods can further fine-tune aspects of the configuration.</source>
          <target state="translated">나중에 테스트 요구에 맞게 가져 오기, 공급자 및 추가 선언과 함께 &lt;code&gt;TestBed.configureTestingModule()&lt;/code&gt; 을 호출 합니다. 선택적 &lt;code&gt;override&lt;/code&gt; 방법은 구성 측면을 더욱 세밀하게 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06d986c1b367afb8ba4fb3fbdad2551ff5cf409a" translate="yes" xml:space="preserve">
          <source>Later, in the &lt;a href=&quot;https://angular.io/start/start/forms&quot;&gt;Forms&lt;/a&gt; part of this tutorial, this cart service also will be accessed from the page where the user checks out.</source>
          <target state="translated">나중에이 학습서 의 &lt;a href=&quot;https://angular.io/start/start/forms&quot;&gt;양식&lt;/a&gt; 부분에서이 장바구니 서비스는 사용자가 체크 아웃 한 페이지에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="754103d0963cb240496afc2220bcce0c35ff57b6" translate="yes" xml:space="preserve">
          <source>Later, in the &lt;code&gt;ngOnInit&lt;/code&gt; method, you use the &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; service to retrieve the parameters for the route, pull the hero &lt;code&gt;id&lt;/code&gt; from the parameters and retrieve the hero to display.</source>
          <target state="translated">나중에 &lt;code&gt;ngOnInit&lt;/code&gt; 메소드에서 &lt;code&gt;&lt;a href=&quot;../api/router/activatedroute&quot;&gt;ActivatedRoute&lt;/a&gt;&lt;/code&gt; 서비스를 사용하여 경로에 대한 매개 변수를 검색하고 매개 변수에서 히어로 &lt;code&gt;id&lt;/code&gt; 를 가져온 후 표시 할 히어로를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="e7547ca42bb362a9b11d36774bbdfcd704b4a366" translate="yes" xml:space="preserve">
          <source>Later, the tests will be able to easily check &lt;code&gt;selectedHero&lt;/code&gt; to verify that the &lt;code&gt;DashboardHeroComponent.selected&lt;/code&gt; event emitted the expected hero.</source>
          <target state="translated">나중에 테스트에서 &lt;code&gt;selectedHero&lt;/code&gt; 를 쉽게 확인 하여 &lt;code&gt;DashboardHeroComponent.selected&lt;/code&gt; 이벤트가 예상되는 영웅을 배출 했는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5515a41b4344b9f65fe779948499e1d5d6f34c6d" translate="yes" xml:space="preserve">
          <source>Later, this guide shows you how to create &lt;a href=&quot;router-tutorial-toh#heroes-functionality&quot;&gt;multiple routing modules&lt;/a&gt; and import those routing modules &lt;a href=&quot;router-tutorial-toh#routing-module-order&quot;&gt;in the correct order&lt;/a&gt;.</source>
          <target state="translated">나중에이 가이드에서는 &lt;a href=&quot;router-tutorial-toh#heroes-functionality&quot;&gt;여러 라우팅 모듈&lt;/a&gt; 을 만들고 해당 라우팅 모듈 &lt;a href=&quot;router-tutorial-toh#routing-module-order&quot;&gt;을 올바른 순서로&lt;/a&gt; 가져 오는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="21fda7ea70f96e74170c060719d7b5657f338386" translate="yes" xml:space="preserve">
          <source>Latest manifest hash</source>
          <target state="translated">최신 매니페스트 해시</target>
        </trans-unit>
        <trans-unit id="5e52348bd45eeec46b21e6ad2ead896b3cef0bb5" translate="yes" xml:space="preserve">
          <source>Launch the server by using the CLI command &lt;code&gt;ng serve&lt;/code&gt;, with the &lt;code&gt;--open&lt;/code&gt; option.</source>
          <target state="translated">CLI 명령 &lt;code&gt;ng serve&lt;/code&gt; 를 &lt;code&gt;--open&lt;/code&gt; 옵션 과 함께 사용하여 서버를 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ee1107c3f31dfe72f1b2c8c9f4dbd7811c4a206" translate="yes" xml:space="preserve">
          <source>Launching your app</source>
          <target state="translated">앱 시작</target>
        </trans-unit>
        <trans-unit id="8cdd14c7391daa639de4c11bd4f21bff8eb8dfdd" translate="yes" xml:space="preserve">
          <source>Launching your app with a root module</source>
          <target state="translated">루트 모듈로 앱 시작</target>
        </trans-unit>
        <trans-unit id="ae7bffee7c5009ade8cdb896ee38347b7b498008" translate="yes" xml:space="preserve">
          <source>Lazily retrieves the reference value from a forwardRef.</source>
          <target state="translated">Lazily는 forwardRef에서 참조 값을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="9d8fd079f87e6df7079e2cb3921cb7d7a59ad6f7" translate="yes" xml:space="preserve">
          <source>Lazy Loaded folders</source>
          <target state="translated">지연로드 된 폴더</target>
        </trans-unit>
        <trans-unit id="53a754e3d992d869269c4cb92a2837bbd5a07aee" translate="yes" xml:space="preserve">
          <source>Lazy Loading</source>
          <target state="translated">게으른 로딩</target>
        </trans-unit>
        <trans-unit id="b9db421e8fed8420ce1824b3ccff0707fa4d9adc" translate="yes" xml:space="preserve">
          <source>Lazy Loading AngularJS</source>
          <target state="translated">지연 로딩 AngularJS</target>
        </trans-unit>
        <trans-unit id="e85192724b293a8f60c1280d0d24a8c45ab04f15" translate="yes" xml:space="preserve">
          <source>Lazy Loading Feature Modules</source>
          <target state="translated">지연 로딩 기능 모듈</target>
        </trans-unit>
        <trans-unit id="0db7bee2dbf162d4bb73916ab3193a20850ec970" translate="yes" xml:space="preserve">
          <source>Lazy Loading route configuration</source>
          <target state="translated">지연 로딩 경로 구성</target>
        </trans-unit>
        <trans-unit id="961dcc883b258c2d939be82886386097e05d2115" translate="yes" xml:space="preserve">
          <source>Lazy load the &lt;em&gt;crisis center&lt;/em&gt;</source>
          <target state="translated">게으른 &lt;em&gt;위기 센터&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d4e26b5d436da7c36bc26793e58eaeec1fdc4705" translate="yes" xml:space="preserve">
          <source>Lazy load the crisis center</source>
          <target state="translated">레이지로드 위기 센터</target>
        </trans-unit>
        <trans-unit id="8745c3d3f236ee4ba968248b7004084810969715" translate="yes" xml:space="preserve">
          <source>Lazy loading</source>
          <target state="translated">게으른 로딩</target>
        </trans-unit>
        <trans-unit id="78f2517723ef00321461f6e4e944eac63fbf25bc" translate="yes" xml:space="preserve">
          <source>Lazy loading NgModules</source>
          <target state="translated">지연 로딩 NgModules</target>
        </trans-unit>
        <trans-unit id="f002b47a9674f08e88a467d632ae3477aad802fe" translate="yes" xml:space="preserve">
          <source>Lazy loading an &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 지연로드 .</target>
        </trans-unit>
        <trans-unit id="52a025ef2198526b4b9361d282bbf81bda351341" translate="yes" xml:space="preserve">
          <source>Lazy loading basics</source>
          <target state="translated">지연로드 기본 사항</target>
        </trans-unit>
        <trans-unit id="a70dd563d0cf22b10094a8634ce271d270a2f3d3" translate="yes" xml:space="preserve">
          <source>Lazy loading feature modules.</source>
          <target state="translated">지연 로딩 기능 모듈.</target>
        </trans-unit>
        <trans-unit id="dafd78a2060910a592eef7719a94d1cb70951800" translate="yes" xml:space="preserve">
          <source>Lazy loading speeds up application load time by splitting the application into multiple bundles and loading them on demand. To use lazy loading, provide the &lt;code&gt;&lt;a href=&quot;route#loadChildren&quot;&gt;loadChildren&lt;/a&gt;&lt;/code&gt; property instead of the &lt;code&gt;children&lt;/code&gt; property.</source>
          <target state="translated">지연 로딩은 애플리케이션을 여러 번들로 분할하고 필요할 때로드함으로써 애플리케이션 로딩 시간을 단축시킵니다. 지연 로딩을 사용하려면 &lt;code&gt;children&lt;/code&gt; 속성 대신 &lt;code&gt;&lt;a href=&quot;route#loadChildren&quot;&gt;loadChildren&lt;/a&gt;&lt;/code&gt; 속성을 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9a626761db78fd38db2cdd82e365bb22188a611" translate="yes" xml:space="preserve">
          <source>Lazy loading speeds up application load time by splitting the application into multiple bundles and loading them on demand. To use lazy loading, provide the &lt;code&gt;loadChildren&lt;/code&gt; property in the &lt;code&gt;&lt;a href=&quot;route&quot;&gt;Route&lt;/a&gt;&lt;/code&gt; object, instead of the &lt;code&gt;children&lt;/code&gt; property.</source>
          <target state="translated">지연로드는 애플리케이션을 여러 번들로 분할하고 요청시로드하여 애플리케이션로드 시간을 단축합니다. 지연로드를 사용하려면 &lt;code&gt;children&lt;/code&gt; 속성 대신 &lt;code&gt;&lt;a href=&quot;route&quot;&gt;Route&lt;/a&gt;&lt;/code&gt; 개체 에 &lt;code&gt;loadChildren&lt;/code&gt; 속성을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="628c7bafd341d3b8b82c1179cbcc0927f03d5efc" translate="yes" xml:space="preserve">
          <source>Lazy-loaded modules and their components can inject &lt;code&gt;AppModule&lt;/code&gt; services; they can't inject &lt;code&gt;AppComponent&lt;/code&gt; services.</source>
          <target state="translated">지연로드 된 모듈 및 해당 구성 요소는 &lt;code&gt;AppModule&lt;/code&gt; 서비스를 주입 할 수 있습니다. &lt;code&gt;AppComponent&lt;/code&gt; 서비스를 주입 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="957a78005dabe65160b5a15925b793d1fa82108f" translate="yes" xml:space="preserve">
          <source>Lazy-loaded services are scoped to the lazy module's injector. If a lazy-loaded module also provides the &lt;code&gt;UserService&lt;/code&gt;, any component created within that module's context (such as by router navigation) gets the local instance of the service, not the instance in the root application injector.</source>
          <target state="translated">지연로드 된 서비스는 지연 모듈의 인젝터로 범위가 지정됩니다. 지연로드 된 모듈이 &lt;code&gt;UserService&lt;/code&gt; 를 제공하는 경우 해당 모듈의 컨텍스트 내에서 작성된 컴포넌트 (예 : 라우터 탐색)는 루트 애플리케이션 인젝터의 인스턴스가 아닌 서비스의 로컬 인스턴스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d9c40704401e4873ac74e3957c70dadaa21ecc87" translate="yes" xml:space="preserve">
          <source>Lazy-loading feature modules</source>
          <target state="translated">지연 로딩 기능 모듈</target>
        </trans-unit>
        <trans-unit id="3f620ff844008aa025233953d1ce142aa5cda2f1" translate="yes" xml:space="preserve">
          <source>Learn about &lt;code&gt;ngOnChanges()&lt;/code&gt; in the &lt;a href=&quot;lifecycle-hooks&quot;&gt;Lifecycle Hooks&lt;/a&gt; chapter.</source>
          <target state="translated">&lt;a href=&quot;lifecycle-hooks&quot;&gt;수명주기 후크&lt;/a&gt; 장 에서 &lt;code&gt;ngOnChanges()&lt;/code&gt; 에 대해 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="14b272638be9bcb6a919ee9155d34a360ce378ea" translate="yes" xml:space="preserve">
          <source>Learn about marble testing</source>
          <target state="translated">대리석 테스트에 대해 알아보기</target>
        </trans-unit>
        <trans-unit id="e7fdfe1b303da9330f863be0ed83883e1c50ecd2" translate="yes" xml:space="preserve">
          <source>Learn about providers and the bootstrap process in the &lt;a href=&quot;dependency-injection#bootstrap&quot;&gt;Dependency Injection guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;dependency-injection#bootstrap&quot;&gt;Dependency Injection 안내서&lt;/a&gt; 에서 제공자 및 부트 스트랩 프로세스에 대해 학습하십시오 .</target>
        </trans-unit>
        <trans-unit id="da27a2f7b1e6d4b67b7e83f584c9c5f289cfc65d" translate="yes" xml:space="preserve">
          <source>Learn how to &lt;a href=&quot;https://github.com/ng-packagr/ng-packagr/blob/master/docs/copy-assets.md&quot;&gt;copy assets into your library as part of the build&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/ng-packagr/ng-packagr/blob/master/docs/copy-assets.md&quot;&gt;빌드의 일부로 라이브러리에 자산&lt;/a&gt; 을 복사 하는 방법을 알아 봅니다 .</target>
        </trans-unit>
        <trans-unit id="a66275f34e1f5a7519630477918b8d4723a6bbad" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;dependency-injection-providers&quot;&gt;DI tokens and providers&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;dependency-injection-providers&quot;&gt;DI 토큰 및 공급자&lt;/a&gt; 에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="929d9c410b56408fb863a3b3762f37617edbdee9" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;dependency-injection-providers&quot;&gt;different kinds of providers&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;dependency-injection-providers&quot;&gt;다양한 종류의 제공자&lt;/a&gt; 에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="64e85116af3881f2b807a4ac93b6ca6a118e4228" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;hierarchical-dependency-injection&quot;&gt;where to configure providers&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;hierarchical-dependency-injection&quot;&gt;공급자를 구성 할 위치에&lt;/a&gt; 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="42696a9635d606ebe6044734ac2f34dd63e3b588" translate="yes" xml:space="preserve">
          <source>Learn more about Circle CI from &lt;a href=&quot;https://circleci.com/docs/2.0/&quot;&gt;Circle CI documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://circleci.com/docs/2.0/&quot;&gt;Circle CI 문서&lt;/a&gt; 에서 Circle CI 에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="fbd3617cce085a5e8ca250fd33373a22ecbb1c83" translate="yes" xml:space="preserve">
          <source>Learn more about Travis CI testing from &lt;a href=&quot;https://docs.travis-ci.com/&quot;&gt;Travis CI documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.travis-ci.com/&quot;&gt;Travis CI 문서&lt;/a&gt; 에서 Travis CI 테스트에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="ab522e0dc334f2f66198b9d67ad8d7c7cf8fade9" translate="yes" xml:space="preserve">
          <source>Learn more about decorators on the web.</source>
          <target state="translated">웹의 데코레이터에 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="3d9f8497153e69f1f8ced844ece70962ae1dc467" translate="yes" xml:space="preserve">
          <source>Learn more about how Angular uses &lt;a href=&quot;npm-packages&quot;&gt;Npm Packages&lt;/a&gt;.</source>
          <target state="translated">Angular가 &lt;a href=&quot;npm-packages&quot;&gt;Npm 패키지를&lt;/a&gt; 사용하는 방법에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="5b69eeeb2b9edc6d0b9216f8daf3d46902457fb8" translate="yes" xml:space="preserve">
          <source>Learn more about how the &lt;a href=&quot;hierarchical-dependency-injection&quot;&gt;injector hierarchy&lt;/a&gt; works.</source>
          <target state="translated">&lt;a href=&quot;hierarchical-dependency-injection&quot;&gt;인젝터 계층 구조&lt;/a&gt; 작동 방식에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="bce1b146d96af53018096aeb9c71ae57f7bbc6d0" translate="yes" xml:space="preserve">
          <source>Learn more about how to use the tool to &lt;a href=&quot;https://github.com/ng-packagr/ng-packagr/blob/master/docs/embed-assets-css.md&quot;&gt;embed assets in CSS&lt;/a&gt;.</source>
          <target state="translated">도구를 사용하여 &lt;a href=&quot;https://github.com/ng-packagr/ng-packagr/blob/master/docs/embed-assets-css.md&quot;&gt;CSS에 애셋&lt;/a&gt; 을 삽입 하는 방법에 대해 자세히 알아보세요 .</target>
        </trans-unit>
        <trans-unit id="3ca3602b6be5394836ea6883fbc98df272116471" translate="yes" xml:space="preserve">
          <source>Learn more about nested injectors in &lt;a href=&quot;hierarchical-dependency-injection&quot;&gt;Hierarchical Dependency Injection&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;hierarchical-dependency-injection&quot;&gt;계층 적 의존성 주입&lt;/a&gt; 에서 중첩 된 인젝터에 대해 자세히 학습하십시오 .</target>
        </trans-unit>
        <trans-unit id="2491968c7982a380d0f03c94567638e978e99d66" translate="yes" xml:space="preserve">
          <source>Learn more about parameter decorators in &lt;a href=&quot;hierarchical-dependency-injection&quot;&gt;Hierarchical Dependency Injectors&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;hierarchical-dependency-injection&quot;&gt;Hierarchical Dependency Injectors의&lt;/a&gt; 매개 변수 데코레이터에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="f0a54e4c772828f62d79c92c5650ee3ba4fd8547" translate="yes" xml:space="preserve">
          <source>Learn more about reactive and template-driven forms in the &lt;a href=&quot;forms-overview&quot;&gt;Introduction to forms in Angular&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;forms-overview&quot;&gt;Angular의 양식 소개&lt;/a&gt; 에서 반응 형 및 템플릿 기반 양식에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="70918ca856d1bb3ddb3a6cf983a40bf830f966f5" translate="yes" xml:space="preserve">
          <source>Learn more about the &lt;a href=&quot;dependency-injection-providers&quot;&gt;different kinds of providers&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;dependency-injection-providers&quot;&gt;다양한 종류의 제공자&lt;/a&gt; 에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="143c65e04478f769cd31bc055ec2c74e5a0f04f2" translate="yes" xml:space="preserve">
          <source>Learn more about the &lt;a href=&quot;https://www.youtube.com/watch?v=anphffaCZrQ&quot;&gt;Compiler&lt;/a&gt; and &lt;a href=&quot;https://www.youtube.com/watch?v=S0o-4yc2n-8&quot;&gt;Runtime&lt;/a&gt; in these videos from our team.</source>
          <target state="translated">우리 팀의 비디오에서 &lt;a href=&quot;https://www.youtube.com/watch?v=anphffaCZrQ&quot;&gt;컴파일러&lt;/a&gt; 및 &lt;a href=&quot;https://www.youtube.com/watch?v=S0o-4yc2n-8&quot;&gt;런타임&lt;/a&gt; 에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="096d0c679238ccb9dceaa845a2ed7a9859c6fc35" translate="yes" xml:space="preserve">
          <source>Learn more about the JavaScript module system on the web.</source>
          <target state="translated">웹에서 JavaScript 모듈 시스템에 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="b5b77382c3ceee8b94fb94d422b9199a86328115" translate="yes" xml:space="preserve">
          <source>Learn more about the injector hierarchy in &lt;a href=&quot;hierarchical-dependency-injection&quot;&gt;Hierarchical Dependency Injectors&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;hierarchical-dependency-injection&quot;&gt;계층 적 종속성 인젝터&lt;/a&gt; 에서 인젝터 계층에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="58a34f4059f910727e76619fb8f09151e30f4164" translate="yes" xml:space="preserve">
          <source>Learn more about zones in this &lt;a href=&quot;https://www.youtube.com/watch?v=3IqtmUscE_U&quot;&gt;Brian Ford video&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;https://www.youtube.com/watch?v=3IqtmUscE_U&quot;&gt;Brian Ford 비디오&lt;/a&gt; 에서 영역에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="5a06dd36c4697393e8591b0aebf3314fd66a43a1" translate="yes" xml:space="preserve">
          <source>Learn more from the &lt;a href=&quot;ngmodules&quot;&gt;NgModules&lt;/a&gt; guide.</source>
          <target state="translated">&lt;a href=&quot;ngmodules&quot;&gt;NgModules&lt;/a&gt; 안내서 에서 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="49ef03ab06d34819f0df49aacfb549f83abffb4f" translate="yes" xml:space="preserve">
          <source>Learn more in &lt;a href=&quot;attribute-directives&quot;&gt;Attribute Directives&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;attribute-directives&quot;&gt;속성 지시문&lt;/a&gt; 에서 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="061e792bcfae6a72b414a42e4732a01bdfcc764a" translate="yes" xml:space="preserve">
          <source>Learn more in &lt;a href=&quot;bootstrapping&quot;&gt;Bootstrapping&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;bootstrapping&quot;&gt;부트 스트랩&lt;/a&gt; 에서 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="a2595474c0bb630d7c9233d6e9cb83f4e1984c4e" translate="yes" xml:space="preserve">
          <source>Learn more in &lt;a href=&quot;dependency-injection&quot;&gt;Dependency Injection in Angular&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;dependency-injection&quot;&gt;Angular의 Dependency Injection에서&lt;/a&gt; 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="d65e1d322ab658292d1ee386605706fe88f9423a" translate="yes" xml:space="preserve">
          <source>Learn more in &lt;a href=&quot;dependency-injection&quot;&gt;Dependency Injection&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;dependency-injection&quot;&gt;Dependency Injection&lt;/a&gt; 에서 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="543454a1ea1ed89206ddafe40279ccb14fd61601" translate="yes" xml:space="preserve">
          <source>Learn more in &lt;a href=&quot;elements&quot;&gt;Angular Elements Overview&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;elements&quot;&gt;각도 요소 개요&lt;/a&gt; 에서 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="d5562b1d6f1c92ab22ddd2839b427022bb5479b0" translate="yes" xml:space="preserve">
          <source>Learn more in &lt;a href=&quot;https://developers.google.com/web/fundamentals/architecture/app-shell&quot;&gt;The App Shell Model&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developers.google.com/web/fundamentals/architecture/app-shell&quot;&gt;앱 셸 모델&lt;/a&gt; 에서 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="69e83458aeba90795b2ec92b95ac860501f7f762" translate="yes" xml:space="preserve">
          <source>Learn more in Victor Savkin's &lt;a href=&quot;http://vsavkin.tumblr.com/post/146722301646/angular-router-empty-paths-componentless-routes&quot;&gt;post on redirects&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://vsavkin.tumblr.com/post/146722301646/angular-router-empty-paths-componentless-routes&quot;&gt;리디렉션에 대한&lt;/a&gt; Victor Savkin의 게시물 에서 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="ee5bfdc51cf5efa838170544062b01249b630636" translate="yes" xml:space="preserve">
          <source>Learn more in the &lt;a href=&quot;../../guide/dependency-injection&quot;&gt;&quot;Dependency Injection Guide&quot;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../guide/dependency-injection&quot;&gt;&quot;종속성 주입 안내서&quot;&lt;/a&gt; 에서 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="1ea4f3e368bdb8ee46d30b3c881b3f2fae673597" translate="yes" xml:space="preserve">
          <source>Learn more in the &lt;a href=&quot;../../guide/dependency-injection-in-action#skip&quot;&gt;Dependency Injection guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../guide/dependency-injection-in-action#skip&quot;&gt;Dependency Injection 안내서&lt;/a&gt; 에서 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="8722cd7f2f8e80fc745d60c7437d08c266bd0da6" translate="yes" xml:space="preserve">
          <source>Learn more in the &lt;a href=&quot;attribute-directives&quot;&gt;Attribute Directives&lt;/a&gt; and &lt;a href=&quot;structural-directives&quot;&gt;Structural Directives&lt;/a&gt; guides.</source>
          <target state="translated">&lt;a href=&quot;attribute-directives&quot;&gt;속성 지시문&lt;/a&gt; 및 &lt;a href=&quot;structural-directives&quot;&gt;구조 지시문&lt;/a&gt; 안내서 에서 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="335b559673f68f2f45eacd159df851d58d214e55" translate="yes" xml:space="preserve">
          <source>Learn more in the &lt;a href=&quot;router#preventing-unauthorized-access&quot;&gt;Routing and Navigation&lt;/a&gt; guide.</source>
          <target state="translated">&lt;a href=&quot;router#preventing-unauthorized-access&quot;&gt;라우팅 및 탐색&lt;/a&gt; 가이드 에서 자세히 알아보세요 .</target>
        </trans-unit>
        <trans-unit id="f281d9bb8a624734a3f2318519573c93302200b0" translate="yes" xml:space="preserve">
          <source>Learn more in the &lt;a href=&quot;testing&quot;&gt;Testing&lt;/a&gt; guide.</source>
          <target state="translated">&lt;a href=&quot;testing&quot;&gt;테스트&lt;/a&gt; 가이드 에서 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="123406725caa64a10ae164244ffa8356f20fb2c7" translate="yes" xml:space="preserve">
          <source>Learn more: See &lt;a href=&quot;../guide/architecture-services&quot;&gt;Introduction to Services and Dependency Injection&lt;/a&gt; for more information about services.</source>
          <target state="translated">자세히 알아보기 : &lt;a href=&quot;../guide/architecture-services&quot;&gt;서비스에&lt;/a&gt; 대한 자세한 내용은 서비스 소개 및 종속성 주입 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1fcac7e737821f3c88ed512904352d47d44d6e8e" translate="yes" xml:space="preserve">
          <source>Learn more: See &lt;a href=&quot;../guide/router&quot;&gt;Routing &amp;amp; Navigation&lt;/a&gt; for more information about the Angular router.</source>
          <target state="translated">자세히 알아보기 : 각도 라우터에 대한 자세한 내용은 &lt;a href=&quot;../guide/router&quot;&gt;라우팅 및 탐색&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b9654aca29b333345621b40d474db8caace16011" translate="yes" xml:space="preserve">
          <source>Learn more: See the &lt;a href=&quot;../guide/http&quot;&gt;HttpClient guide&lt;/a&gt; for more information about Angular's &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">자세히 알아보기 : Angular의 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 에 대한 자세한 내용은 &lt;a href=&quot;../guide/http&quot;&gt;HttpClient 안내서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb1ae2aa745d0c404aecbc5148457ae04537a735" translate="yes" xml:space="preserve">
          <source>Learning Angular</source>
          <target state="translated">각도 학습</target>
        </trans-unit>
        <trans-unit id="51a8db0b974271a01e08c116fc2ed02f73e9f5ca" translate="yes" xml:space="preserve">
          <source>Learning about new features</source>
          <target state="translated">새로운 기능에 대해 배우기</target>
        </trans-unit>
        <trans-unit id="cc650de6468563e40595e1b2eb359a2020010fc2" translate="yes" xml:space="preserve">
          <source>Leave the default and the wildcard routes as these are still in use at the top level of the application.</source>
          <target state="translated">기본값과 와일드 카드 경로는 애플리케이션의 최상위 수준에서 계속 사용되므로 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="04a7f280698f2243487f6b62f727ea79038a1f1b" translate="yes" xml:space="preserve">
          <source>Legacy JavaScript libraries that are not imported into an app can be added to the runtime global scope and loaded as if they were in a script tag. Configure the CLI to do this at build time using the &quot;scripts&quot; and &quot;styles&quot; options of the build target in the &lt;a href=&quot;workspace-config&quot;&gt;CLI configuration file&lt;/a&gt;, &lt;code&gt;angular.json&lt;/code&gt;.</source>
          <target state="translated">앱으로 가져 오지 않은 레거시 JavaScript 라이브러리는 런타임 글로벌 범위에 추가하고 마치 스크립트 태그에있는 것처럼로드 할 수 있습니다. 은 &quot;스크립트&quot;과의 빌드 타겟의 &quot;스타일&quot;옵션을 사용하여 빌드시에이 작업을 수행하는 CLI 구성 &lt;a href=&quot;workspace-config&quot;&gt;CLI 구성 파일&lt;/a&gt; , &lt;code&gt;angular.json&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="eb7a7527cb3b41fff45bdf01cc4023654295db7c" translate="yes" xml:space="preserve">
          <source>Legacy values are deprecated since v4 and should not be used for new applications:</source>
          <target state="translated">레거시 값은 v4부터 더 이상 사용되지 않으며 새 애플리케이션에는 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="6c5bb53f486dae84d16877b1a814f7a9af911ad8" translate="yes" xml:space="preserve">
          <source>Length of the control array.</source>
          <target state="translated">컨트롤 배열의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="79524b43bbfafb265085c4285b823ad36756f103" translate="yes" xml:space="preserve">
          <source>Less common changes</source>
          <target state="translated">덜 일반적인 변경</target>
        </trans-unit>
        <trans-unit id="ddc8669a8abb9a8a2505c175a74ead6882464f81" translate="yes" xml:space="preserve">
          <source>Less explicit, created by directives</source>
          <target state="translated">덜 명시 적이며 지시문으로 생성</target>
        </trans-unit>
        <trans-unit id="7ea222e5b87aefaada7cfc3c3f8a56b08c51fc09" translate="yes" xml:space="preserve">
          <source>Let it control the highlight color with a property binding.</source>
          <target state="translated">속성 바인딩으로 강조 색상을 제어하십시오.</target>
        </trans-unit>
        <trans-unit id="004d38bc3d9031d71cb310214ca0b608ad86e5f7" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a simple &lt;code&gt;angular.json&lt;/code&gt; file that puts target configurations into context.</source>
          <target state="translated">대상 구성을 컨텍스트에 넣는 간단한 &lt;code&gt;angular.json&lt;/code&gt; 파일을 만들어 봅시다 .</target>
        </trans-unit>
        <trans-unit id="01795115ab37723d08f0d9b07ef9dfa96d603a40" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at an example that counts from 1 to 3, with a one-second delay after each number emitted.</source>
          <target state="translated">1에서 3까지 카운트하고 각 숫자가 방출 된 후 1 초 지연되는 예제를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="0676c335f0a95ff58af45724e2f7974f94d0ddb5" translate="yes" xml:space="preserve">
          <source>Let's add a new target that will run our builder to execute a particular command. This target will tell the builder to run &lt;code&gt;touch&lt;/code&gt; on a file, in order to update its modified date.</source>
          <target state="translated">빌더를 실행하여 특정 명령을 실행할 새 대상을 추가하겠습니다. 이 대상은 빌더가 수정 된 날짜를 업데이트하기 위해 파일을 &lt;code&gt;touch&lt;/code&gt; 하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="ffd15a05977d9b50a1e2b66ca7733331ed9bd1b5" translate="yes" xml:space="preserve">
          <source>Let's animate a simple transition that changes a single HTML element from one state to another. For example, you can specify that a button displays either &lt;strong&gt;Open&lt;/strong&gt; or &lt;strong&gt;Closed&lt;/strong&gt; based on the user's last action. When the button is in the &lt;code&gt;open&lt;/code&gt; state, it's visible and yellow. When it's the &lt;code&gt;closed&lt;/code&gt; state, it's transparent and green.</source>
          <target state="translated">단일 HTML 요소를 한 상태에서 다른 상태로 변경하는 간단한 전환에 애니메이션을 적용 해 보겠습니다. 예를 들어, 사용자의 마지막 작업에 따라 단추가 &lt;strong&gt;열림&lt;/strong&gt; 또는 &lt;strong&gt;닫힘을&lt;/strong&gt; 표시하도록 지정할 수 있습니다 . 버튼이 &lt;code&gt;open&lt;/code&gt; 상태이면 버튼이 보이고 노란색입니다. 그것은 때 &lt;code&gt;closed&lt;/code&gt; 상태, 그것은 투명하고 녹색이다.</target>
        </trans-unit>
        <trans-unit id="a182086c861ef403fccc741e4f9e3fffb9b4f5cd" translate="yes" xml:space="preserve">
          <source>Let's assume that we are routing from the &lt;em&gt;Home =&amp;gt; About&lt;/em&gt;.</source>
          <target state="translated">우리가 &lt;em&gt;Home =&amp;gt; About&lt;/em&gt; 에서 라우팅한다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="ee3e3e3afa20d18becc2636614b18f6aaf75e485" translate="yes" xml:space="preserve">
          <source>Let's assume that you have an Angular component called &lt;code&gt;ng2Heroes&lt;/code&gt; that needs to be made available in AngularJS templates.</source>
          <target state="translated">AngularJS 템플릿에서 사용할 수 있어야하는 &lt;code&gt;ng2Heroes&lt;/code&gt; 라는 Angular 구성 요소가 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="3a0e89b617672fce2fabac2e7f5f5850f70a9142" translate="yes" xml:space="preserve">
          <source>Let's assume that you have an AngularJS component called &lt;code&gt;ng1Hero&lt;/code&gt; that needs to be made available in Angular templates.</source>
          <target state="translated">Angular 템플릿에서 사용할 수 있어야하는 &lt;code&gt;ng1Hero&lt;/code&gt; 라는 AngularJS 구성 요소가 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="51663bc4d8fc83af90e5716b6dec0d20f693b0a7" translate="yes" xml:space="preserve">
          <source>Let's change the example to display a message if there are more than three heroes.</source>
          <target state="translated">영웅이 세 명 이상인 경우 메시지를 표시하도록 예제를 변경해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="b44579a57df4195be1460c0b0de8ed1fb8e88665" translate="yes" xml:space="preserve">
          <source>Let's illustrate a router transition animation by navigating between two routes, &lt;em&gt;Home&lt;/em&gt; and &lt;em&gt;About&lt;/em&gt; associated with the &lt;code&gt;HomeComponent&lt;/code&gt; and &lt;code&gt;AboutComponent&lt;/code&gt; views respectively. Both of these component views are children of the top-most view, hosted by &lt;code&gt;AppComponent&lt;/code&gt;. We'll implement a router transition animation that slides in the new view to the right and slides out the old view when the user navigates between the two routes.</source>
          <target state="translated">&lt;code&gt;HomeComponent&lt;/code&gt; 및 &lt;code&gt;AboutComponent&lt;/code&gt; 보기와 각각 연관된 &lt;em&gt;Home&lt;/em&gt; 및 &lt;em&gt;About&lt;/em&gt; 두 경로 사이를 탐색하여 라우터 전환 애니메이션을 설명하겠습니다 . 이 컴포넌트 뷰는 모두 최상위 뷰의 자식이며 &lt;code&gt;AppComponent&lt;/code&gt; 가 호스팅합니다 . 사용자가 두 경로 사이를 탐색 할 때 새보기에서 오른쪽으로 슬라이드하고 이전보기를 슬라이드하는 라우터 전환 애니메이션을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="51c9e9bb879b365c74c45744fdcb949bb94a2d8f" translate="yes" xml:space="preserve">
          <source>Let's imagine that instead of logging the counter value, you update a field of your component and display it in its template.</source>
          <target state="translated">카운터 값을 기록하는 대신 구성 요소의 필드를 업데이트하여 템플릿에 표시한다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="26d1e55048167bc6baaf2e0793fb782ee863e26b" translate="yes" xml:space="preserve">
          <source>Let's imagine that you start a recurrent task (here incrementing a counter, using RxJS &lt;code&gt;interval&lt;/code&gt;), and at the same time subscribe to &lt;code&gt;isStable&lt;/code&gt;.</source>
          <target state="translated">반복 작업을 시작하고 (여기서는 RxJS &lt;code&gt;interval&lt;/code&gt; 사용하여 카운터 증가 ) &lt;code&gt;isStable&lt;/code&gt; 을 구독한다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="b5946821487f82e01968f21fb28ca6f81745022b" translate="yes" xml:space="preserve">
          <source>Let's say you don't want to inject &lt;code&gt;UserService&lt;/code&gt; directly into &lt;code&gt;HeroService&lt;/code&gt;, because you don't want to complicate that service with security-sensitive information. &lt;code&gt;HeroService&lt;/code&gt; won't have direct access to the user information to decide who is authorized and who isn't.</source>
          <target state="translated">보안에 민감한 정보로 해당 서비스를 복잡하게 만들고 싶지 않기 때문에 &lt;code&gt;UserService&lt;/code&gt; 를 &lt;code&gt;HeroService&lt;/code&gt; 에 직접 주입하고 싶지 않다고 가정 해 봅시다 . &lt;code&gt;HeroService&lt;/code&gt; 는 권한이있는 사람과 권한이없는 사람을 결정하기 위해 사용자 정보에 직접 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="951a6b55c578c36b78a513bf32b448dca8905f11" translate="yes" xml:space="preserve">
          <source>Let's say you have an AngularJS service:</source>
          <target state="translated">AngularJS 서비스가 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="4227a9febaa50aa231ec79ac6d7a0b59e1802b16" translate="yes" xml:space="preserve">
          <source>Let's see how Angular's &lt;code&gt;&lt;a href=&quot;../api/animations/state&quot;&gt;state&lt;/a&gt;()&lt;/code&gt; function works with the &lt;code&gt;&lt;a href=&quot;../api/animations/style&quot;&gt;style&lt;/a&gt;⁣&amp;shy;(⁠)&lt;/code&gt; function to set CSS style attributes. In this code snippet, multiple style attributes are set at the same time for the state. In the &lt;code&gt;open&lt;/code&gt; state, the button has a height of 200 pixels, an opacity of 1, and a background color of yellow.</source>
          <target state="translated">CSS 스타일 속성을 설정하기 위해 Angular의 &lt;code&gt;&lt;a href=&quot;../api/animations/state&quot;&gt;state&lt;/a&gt;()&lt;/code&gt; 함수가 &lt;code&gt;&lt;a href=&quot;../api/animations/style&quot;&gt;style&lt;/a&gt;⁣&amp;shy;(⁠)&lt;/code&gt; 함수 와 어떻게 작동 하는지 살펴 보겠습니다 . 이 코드 스 니펫에서 여러 스타일 속성이 상태에 대해 동시에 설정됩니다. 에서 &lt;code&gt;open&lt;/code&gt; 상태, 버튼 (200 개)의 픽셀의 높이, (1)의 불투명도 및 옐로우의 배경색을 갖는다.</target>
        </trans-unit>
        <trans-unit id="3bfc635473c5d0a274aeaebda63d5676a80f9758" translate="yes" xml:space="preserve">
          <source>Let's see how Angular's &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/%24locationshim#state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; function works with the &lt;code&gt;&lt;a href=&quot;../api/animations/style&quot;&gt;style&lt;/a&gt;⁣&amp;shy;(⁠)&lt;/code&gt; function to set CSS style attributes. In this code snippet, multiple style attributes are set at the same time for the state. In the &lt;code&gt;open&lt;/code&gt; state, the button has a height of 200 pixels, an opacity of 1, and a background color of yellow.</source>
          <target state="translated">하자가 어떻게 보는지 각도의 &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/%24locationshim#state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; 와 기능의 작품 &lt;code&gt;&lt;a href=&quot;../api/animations/style&quot;&gt;style&lt;/a&gt;⁣&amp;shy;(⁠)&lt;/code&gt; 세트 CSS 스타일 속성에 기능. 이 코드 스 니펫에서는 여러 스타일 속성이 상태에 대해 동시에 설정됩니다. 에서 &lt;code&gt;open&lt;/code&gt; 상태, 버튼 (200 개)의 픽셀의 높이, (1)의 불투명도 및 옐로우의 배경색을 갖는다.</target>
        </trans-unit>
        <trans-unit id="b2ffa03a6796485c7010eeb3285db01c52a7f841" translate="yes" xml:space="preserve">
          <source>Let's start by creating the validator class.</source>
          <target state="translated">유효성 검사기 클래스를 만들어 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="99f7276b18539354571fb0b39a65472e8470d3e1" translate="yes" xml:space="preserve">
          <source>Let's take a look at another animation on the live example page. Under the Filter/Stagger tab, enter some text into the &lt;strong&gt;Search Heroes&lt;/strong&gt; text box, such as &lt;code&gt;Magnet&lt;/code&gt; or &lt;code&gt;tornado&lt;/code&gt;.</source>
          <target state="translated">라이브 예제 페이지에서 다른 애니메이션을 살펴 보겠습니다. 필터 / 스 태거 탭에서 &lt;strong&gt;검색 영웅&lt;/strong&gt; 텍스트 상자에 &lt;code&gt;Magnet&lt;/code&gt; 또는 &lt;code&gt;tornado&lt;/code&gt; 와 같은 텍스트를 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="a78a57bd9b98e941523e213b265835c6bf8b7325" translate="yes" xml:space="preserve">
          <source>Let's take the &lt;code&gt;Hero&lt;/code&gt; routes and migrate them to new URLs. The &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; checks for redirects in your configuration before navigating, so each redirect is triggered when needed. To support this change, you'll add redirects from the old routes to the new routes in the &lt;code&gt;heroes-routing.module&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hero&lt;/code&gt; 경로를 가져 와서 새 URL로 마이그레이션 합시다 . &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 필요할 때 이동하기 전에 구성에서 리디렉션에 대한 검사는, 각각의 리디렉션 트리거됩니다. 이 변경을 지원하기 위해 &lt;code&gt;heroes-routing.module&lt;/code&gt; 의 이전 경로에서 새 경로로 리디렉션을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="731147e6fd716658458f531b1b9ea06ed3c678b7" translate="yes" xml:space="preserve">
          <source>Lets you add a CSS class to an element when the link's route becomes active.</source>
          <target state="translated">링크의 경로가 활성화 될 때 요소에 CSS 클래스를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc9c5c8e30a394eae9d072458a3e300ebe3613cd" translate="yes" xml:space="preserve">
          <source>Lets you link to specific routes in your app.</source>
          <target state="translated">앱의 특정 경로에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="185c8d387520a8df821ea96c64127c9ce02efa89" translate="yes" xml:space="preserve">
          <source>Leverage full framework capabilities with Zone.js opt-out</source>
          <target state="translated">Zone.js 옵트 아웃으로 전체 프레임 워크 기능 활용</target>
        </trans-unit>
        <trans-unit id="3fd4d244695eda3ce03c3906d63aa441208d0648" translate="yes" xml:space="preserve">
          <source>Libraries (unlike applications and their associated e2e projects) have their own &lt;code&gt;package.json&lt;/code&gt; configuration files.</source>
          <target state="translated">라이브러리 (응용 프로그램 및 관련 e2e 프로젝트와 달리)에는 자체 &lt;code&gt;package.json&lt;/code&gt; 구성 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="249a68415825c618581383ebd8e77e0d58a9f6d8" translate="yes" xml:space="preserve">
          <source>Libraries are published as &lt;a href=&quot;npm-packages&quot;&gt;npm packages&lt;/a&gt;, usually together with schematics that integrate them with the Angular CLI. To integrate reusable library code into an application, you need to install the package and import the provided functionality where you will use it. For most published Angular libraries, you can use the Angular CLI &lt;code&gt;ng add &amp;lt;lib_name&amp;gt;&lt;/code&gt; command.</source>
          <target state="translated">라이브러리는 일반적으로 Angular CLI와 통합되는 회로도와 함께 &lt;a href=&quot;npm-packages&quot;&gt;npm 패키지&lt;/a&gt; 로 게시됩니다 . 재사용 가능한 라이브러리 코드를 응용 프로그램에 통합하려면 패키지를 설치하고 사용할 기능을 가져와야합니다. 대부분의 게시 된 Angular 라이브러리의 경우 Angular CLI &lt;code&gt;ng add &amp;lt;lib_name&amp;gt;&lt;/code&gt; 명령을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9699d0766df04c3c3118cb5d84d81f7cbe5b396a" translate="yes" xml:space="preserve">
          <source>Libraries can be updated by their publishers, and also have their own dependencies which need to be kept current. To check for updates to your installed libraries, use the &lt;a href=&quot;cli/update&quot;&gt;&lt;code&gt;ng update&lt;/code&gt; command&lt;/a&gt;.</source>
          <target state="translated">라이브러리는 게시자가 업데이트 할 수 있으며 최신 상태를 유지해야하는 자체 종속성이 있습니다. 설치된 라이브러리의 업데이트를 확인하려면 &lt;a href=&quot;cli/update&quot;&gt; &lt;code&gt;ng update&lt;/code&gt; 명령을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0376bb56d3bac292a79a960dea3ef8945bb90d1d" translate="yes" xml:space="preserve">
          <source>Libraries extend Angular's base functionality. For example, to add &lt;a href=&quot;reactive-forms&quot;&gt;reactive forms&lt;/a&gt; to an app, add the library package using &lt;code&gt;ng add @angular/forms&lt;/code&gt;, then import the &lt;code&gt;&lt;a href=&quot;../api/forms/reactiveformsmodule&quot;&gt;ReactiveFormsModule&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;@angular/forms&lt;/code&gt; library in your application code. Similarly, adding the &lt;a href=&quot;service-worker-intro&quot;&gt;service worker&lt;/a&gt; library to an Angular application is one of the steps for turning an application into a &lt;a href=&quot;https://developers.google.com/web/progressive-web-apps/&quot;&gt;Progressive Web App&lt;/a&gt; (PWA). &lt;a href=&quot;https://material.angular.io/&quot;&gt;Angular Material&lt;/a&gt; is an example of a large, general-purpose library that provides sophisticated, reusable, and adaptable UI components.</source>
          <target state="translated">라이브러리는 Angular의 기본 기능을 확장합니다. 예를 들어 &lt;a href=&quot;reactive-forms&quot;&gt;반응 형 양식&lt;/a&gt; 을 앱에 추가하려면 &lt;code&gt;ng add @angular/forms&lt;/code&gt; 사용하여 라이브러리 패키지를 추가 한 다음 애플리케이션 코드 의 &lt;code&gt;@angular/forms&lt;/code&gt; 라이브러리에서 &lt;code&gt;&lt;a href=&quot;../api/forms/reactiveformsmodule&quot;&gt;ReactiveFormsModule&lt;/a&gt;&lt;/code&gt; 을 가져 오십시오 . 마찬가지로 &lt;a href=&quot;service-worker-intro&quot;&gt;서비스 워커&lt;/a&gt; 라이브러리를 Angular 응용 프로그램에 추가하는 것은 응용 프로그램을 PWA ( &lt;a href=&quot;https://developers.google.com/web/progressive-web-apps/&quot;&gt;Progressive Web App)&lt;/a&gt; 로 전환하는 단계 중 하나입니다 . &lt;a href=&quot;https://material.angular.io/&quot;&gt;Angular Material&lt;/a&gt; 은 정교하고 재사용 가능하며 적용 가능한 UI 구성 요소를 제공하는 대규모 범용 라이브러리의 예입니다.</target>
        </trans-unit>
        <trans-unit id="0a8fcac923bdc2f041e17f19ca0ee882b12e109e" translate="yes" xml:space="preserve">
          <source>Library developers can use the &lt;a href=&quot;glossary#cli&quot;&gt;Angular CLI&lt;/a&gt; to &lt;code&gt;generate&lt;/code&gt; scaffolding for a new library in an existing &lt;a href=&quot;glossary#workspace&quot;&gt;workspace&lt;/a&gt;, and can publish a library as an &lt;code&gt;npm&lt;/code&gt; package.</source>
          <target state="translated">라이브러리 개발자는 &lt;a href=&quot;glossary#cli&quot;&gt;Angular CLI&lt;/a&gt; 를 사용하여 기존 &lt;a href=&quot;glossary#workspace&quot;&gt;작업 공간&lt;/a&gt; 에서 새 라이브러리에 대한 스캐 폴딩 을 &lt;code&gt;generate&lt;/code&gt; 하고 라이브러리를 &lt;code&gt;npm&lt;/code&gt; 패키지 로 공개 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa66e52846472f9fd27f98294eccf19a26b04dd3" translate="yes" xml:space="preserve">
          <source>Library packages often include typings in &lt;code&gt;.d.ts&lt;/code&gt; files; see examples in &lt;code&gt;node_modules/@angular/material&lt;/code&gt;. If your library's package does not include typings and your IDE complains, you may need to install the library's associated &lt;code&gt;@types/&amp;lt;lib_name&amp;gt;&lt;/code&gt; package.</source>
          <target state="translated">라이브러리 패키지에는 종종 &lt;code&gt;.d.ts&lt;/code&gt; 파일 에 입력 하는 것이 포함됩니다 . &lt;code&gt;node_modules/@angular/material&lt;/code&gt; 예제를 참조하십시오 . 라이브러리 패키지에 타이핑이 포함되어 있지 않고 IDE에 불만이있는 경우 라이브러리 관련 &lt;code&gt;@types/&amp;lt;lib_name&amp;gt;&lt;/code&gt; 패키지 를 설치해야 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="369dc2dcfb562bc1b488d8c1c0682319334ebd52" translate="yes" xml:space="preserve">
          <source>Library project files</source>
          <target state="translated">라이브러리 프로젝트 파일</target>
        </trans-unit>
        <trans-unit id="5caffd27e3ec471b46ded28417241aa0b83195e8" translate="yes" xml:space="preserve">
          <source>Library typings</source>
          <target state="translated">라이브러리 타이핑</target>
        </trans-unit>
        <trans-unit id="9e9de5dc714b0ebcdc870442c864fb8d36ef6f88" translate="yes" xml:space="preserve">
          <source>Library-specific &lt;a href=&quot;https://karma-runner.github.io/2.0/config/configuration-file.html&quot;&gt;Karma&lt;/a&gt; configuration.</source>
          <target state="translated">라이브러리 별 &lt;a href=&quot;https://karma-runner.github.io/2.0/config/configuration-file.html&quot;&gt;카르마&lt;/a&gt; 구성.</target>
        </trans-unit>
        <trans-unit id="1462d279df315f445494a726cde98792d2ce8e8e" translate="yes" xml:space="preserve">
          <source>Library-specific &lt;a href=&quot;https://palantir.github.io/tslint/&quot;&gt;TSLint&lt;/a&gt; configuration.</source>
          <target state="translated">라이브러리 별 &lt;a href=&quot;https://palantir.github.io/tslint/&quot;&gt;TSLint&lt;/a&gt; 구성.</target>
        </trans-unit>
        <trans-unit id="b7467e05747f314fdd1067fd36131c4e4aa55601" translate="yes" xml:space="preserve">
          <source>Library-specific &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; configuration, including TypeScript and Angular template compiler options. See &lt;a href=&quot;typescript-configuration&quot;&gt;TypeScript Configuration&lt;/a&gt;.</source>
          <target state="translated">TypeScript 및 Angular 템플릿 컴파일러 옵션을 포함한 라이브러리 별 &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; 구성 &lt;a href=&quot;typescript-configuration&quot;&gt;TypeScript 구성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">License</target>
        </trans-unit>
        <trans-unit id="e91f6ba4ec02c67a796600daa345b1a2b526d763" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution License 4.0.</source>
          <target state="translated">Creative Commons Attribution License 4.0에 따라 라이센스가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="4e48f698aadae9546857e8298a5bcd17843d6036" translate="yes" xml:space="preserve">
          <source>Lifecycle Hooks</source>
          <target state="translated">수명주기 후크</target>
        </trans-unit>
        <trans-unit id="543997ccf23b19cef73c5b0ec7004f7141aabd78" translate="yes" xml:space="preserve">
          <source>Lifecycle event sequence</source>
          <target state="translated">라이프 사이클 이벤트 순서</target>
        </trans-unit>
        <trans-unit id="18f610992ae69af4410d455e6cbeb4fbb02b2d58" translate="yes" xml:space="preserve">
          <source>Lifecycle example set</source>
          <target state="translated">라이프 사이클 예제 세트</target>
        </trans-unit>
        <trans-unit id="b958ad9eb9a6b36ba54104b6bc92f5faa443cc61" translate="yes" xml:space="preserve">
          <source>Lifecycle examples</source>
          <target state="translated">수명주기 예</target>
        </trans-unit>
        <trans-unit id="37857eb2e2aa8efab7a0ac716f62d18f83e34871" translate="yes" xml:space="preserve">
          <source>Lifecycle hooks</source>
          <target state="translated">수명주기 후크</target>
        </trans-unit>
        <trans-unit id="b4399d677c3a4329e5891e6b3f01426b36bd04ad" translate="yes" xml:space="preserve">
          <source>Lifecycle hooks guide</source>
          <target state="translated">수명주기 후크 가이드</target>
        </trans-unit>
        <trans-unit id="8ced92a0a018d03498243304ed4b11aebef88de0" translate="yes" xml:space="preserve">
          <source>Lifecycle method called after the view is initialized. For internal use only.</source>
          <target state="translated">뷰가 초기화 된 후 호출 된 수명주기 메소드. 내부 전용.</target>
        </trans-unit>
        <trans-unit id="8bcc83c9b4f7ee797688986e365040d42abe8375" translate="yes" xml:space="preserve">
          <source>Lifecycle method called before the directive's instance is destroyed. For internal use only.</source>
          <target state="translated">지시어 인스턴스가 삭제되기 전에 호출 된 수명주기 메소드. 내부 전용.</target>
        </trans-unit>
        <trans-unit id="c76a477802c13c19852bc378c8dbbea9cf0b4d8f" translate="yes" xml:space="preserve">
          <source>Lifecycle sequence</source>
          <target state="translated">수명주기 순서</target>
        </trans-unit>
        <trans-unit id="4c3ad870fd2ee3048b365677c3d250426730e41f" translate="yes" xml:space="preserve">
          <source>Lightweight injection tokens are only useful with components. The Angular style guide suggests that you name components using the &quot;Component&quot; suffix. The example &quot;LibHeaderComponent&quot; follows this convention.</source>
          <target state="translated">경량 주입 토큰은 구성 요소에만 유용합니다. Angular 스타일 가이드는 &quot;Component&quot;접미사를 사용하여 구성 요소의 이름을 지정하도록 제안합니다. &quot;LibHeaderComponent&quot;예제는이 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="df16d57ee0cc4cdc69baadd4526493b4e9b3cea2" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;interpolation&quot;&gt;template expressions&lt;/a&gt;, template statements use a language that looks like JavaScript. However, the parser for template statements differs from the parser for template expressions. In addition, the template statements parser specifically supports both basic assignment, &lt;code&gt;=&lt;/code&gt;, and chaining expressions with semicolons, &lt;code&gt;;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;interpolation&quot;&gt;템플릿 표현식&lt;/a&gt; 과 마찬가지로 템플릿 문은 자바 스크립트처럼 보이는 언어를 사용합니다. 그러나 템플릿 문에 대한 구문 분석기는 템플릿 표현식에 대한 구문 분석기와 다릅니다. 또한 템플릿 문 파서는 기본 할당 &lt;code&gt;=&lt;/code&gt; 및 세미콜론이있는 연결 식을 모두 지원합니다 &lt;code&gt;;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbd1175e41951b23bc6a03577b221bca30219cd8" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;toh-pt4#observable-heroservice&quot;&gt;&lt;code&gt;getHeroes()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;getHero()&lt;/code&gt; has an asynchronous signature. It returns a &lt;em&gt;mock hero&lt;/em&gt; as an &lt;code&gt;Observable&lt;/code&gt;, using the RxJS &lt;code&gt;of()&lt;/code&gt; function.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;toh-pt4#observable-heroservice&quot;&gt; &lt;code&gt;getHeroes()&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;getHero()&lt;/code&gt; 비동기 서명이. RxJS &lt;code&gt;of()&lt;/code&gt; 함수를 사용하여 &lt;em&gt;모의 영웅&lt;/em&gt; 을 &lt;code&gt;Observable&lt;/code&gt; 로 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="f813a9b214ba457adfc3f3b7f635326573cb767b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;../api/common/http/jsonpinterceptor#intercept&quot;&gt;intercept()&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;handle()&lt;/code&gt; method transforms an HTTP request into an &lt;code&gt;Observable&lt;/code&gt; of &lt;a href=&quot;http#httpevents&quot;&gt;&lt;code&gt;HttpEvents&lt;/code&gt;&lt;/a&gt; which ultimately include the server's response. The &lt;code&gt;&lt;a href=&quot;../api/common/http/jsonpinterceptor#intercept&quot;&gt;intercept()&lt;/a&gt;&lt;/code&gt; method could inspect that observable and alter it before returning it to the caller.</source>
          <target state="translated">추천 &lt;code&gt;&lt;a href=&quot;../api/common/http/jsonpinterceptor#intercept&quot;&gt;intercept()&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;handle()&lt;/code&gt; 메소드 변환로의 HTTP 요청을 &lt;code&gt;Observable&lt;/code&gt; 의 &lt;a href=&quot;http#httpevents&quot;&gt; &lt;code&gt;HttpEvents&lt;/code&gt; &lt;/a&gt; 궁극적 서버의 응답을 포함한다. &lt;code&gt;&lt;a href=&quot;../api/common/http/jsonpinterceptor#intercept&quot;&gt;intercept()&lt;/a&gt;&lt;/code&gt; 메소드는 관찰을 검사하고 호출자에게 반환하기 전에 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cac87216a54ce1ed331461ec55435eb45df8962d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; instances, you choose to pass in validators and async validators as part of an options object.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 인스턴스 와 마찬가지로 유효성 검사기 및 비동기 유효성 검사기를 옵션 개체의 일부로 전달하도록 선택합니다.</target>
        </trans-unit>
        <trans-unit id="59351fc10bef4908180431ddc9136fdd2825ec9d" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;EvenBetterLogger&lt;/code&gt;, &lt;code&gt;HeroService&lt;/code&gt; needs to know if the user is authorized to see secret heroes. That authorization can change during the course of a single application session, as when you log in a different user.</source>
          <target state="translated">마찬가지로 &lt;code&gt;EvenBetterLogger&lt;/code&gt; , &lt;code&gt;HeroService&lt;/code&gt; 는 사용자가 비밀 영웅을 볼 권한이 있는지 알 필요가있다. 다른 사용자로 로그인 할 때와 같이 단일 권한 부여 세션 동안 해당 권한이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="daf09706446fb58188e9e62e06dc4a762e1c0cea" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;intercept()&lt;/code&gt;, the &lt;code&gt;handle()&lt;/code&gt; method transforms an HTTP request into an &lt;code&gt;Observable&lt;/code&gt; of &lt;a href=&quot;http#interceptor-events&quot;&gt;&lt;code&gt;HttpEvents&lt;/code&gt;&lt;/a&gt; which ultimately include the server's response. The &lt;code&gt;intercept()&lt;/code&gt; method could inspect that observable and alter it before returning it to the caller.</source>
          <target state="translated">추천 &lt;code&gt;intercept()&lt;/code&gt; 는 &lt;code&gt;handle()&lt;/code&gt; 메소드 변환로의 HTTP 요청을 &lt;code&gt;Observable&lt;/code&gt; 의 &lt;a href=&quot;http#interceptor-events&quot;&gt; &lt;code&gt;HttpEvents&lt;/code&gt; &lt;/a&gt; 궁극적 서버의 응답을 포함한다. &lt;code&gt;intercept()&lt;/code&gt; 메소드는 관찰을 검사하고 호출자에게 반환하기 전에 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2712b30047f7466a2e4dc145651016587aaff9e5" translate="yes" xml:space="preserve">
          <source>Like JavaScript modules, NgModules can import functionality from other NgModules, and allow their own functionality to be exported and used by other NgModules. For example, to use the router service in your app, you import the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; NgModule.</source>
          <target state="translated">JavaScript 모듈과 마찬가지로 NgModules는 다른 NgModules에서 기능을 가져오고 다른 NgModules에서 자체 기능을 내보내고 사용할 수 있습니다. 예를 들어 앱에서 라우터 서비스를 사용하려면 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; NgModule 을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="9c551f24bba1fc42974492065f7f565414accad5" translate="yes" xml:space="preserve">
          <source>Like a &lt;a href=&quot;glossary#module&quot;&gt;JavaScript module&lt;/a&gt;, an NgModule can export functionality for use by other NgModules and import public functionality from other NgModules. The metadata for an NgModule class collects components, directives, and pipes that the application uses along with the list of imports and exports. See also &lt;a href=&quot;glossary#declarable&quot;&gt;declarable&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;glossary#module&quot;&gt;JavaScript 모듈&lt;/a&gt; 과 마찬가지로 NgModule은 다른 NgModules에서 사용할 기능을 내보내고 다른 NgModules에서 공용 기능을 가져올 수 있습니다. NgModule 클래스의 메타 데이터는 애플리케이션이 가져 오기 및 내보내기 목록과 함께 사용하는 구성 요소, 지시문 및 파이프를 수집합니다. &lt;a href=&quot;glossary#declarable&quot;&gt;선언 가능&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="585189adbddf6995a44ae66c57e2a58943711031" translate="yes" xml:space="preserve">
          <source>Like all routers, it needs a place in the UI to display routed views. For Angular that's the &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; and it belongs in a &lt;em&gt;root component&lt;/em&gt; at the top of the applications component tree.</source>
          <target state="translated">모든 라우터와 마찬가지로 라우팅 뷰를 표시하려면 UI에 배치해야합니다. Angular의 경우 &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; 이며 응용 프로그램 구성 요소 트리 맨 위에 있는 &lt;em&gt;루트 구성 요소&lt;/em&gt; 에 속합니다 .</target>
        </trans-unit>
        <trans-unit id="e9fb86eb5b7b244ce3a393d7bf88fb154e10ed44" translate="yes" xml:space="preserve">
          <source>Like any complex system, bugs or broken configurations can cause the Angular service worker to act in unforeseen ways. While its design attempts to minimize the impact of such problems, the Angular service worker contains several failsafe mechanisms in case an administrator ever needs to deactivate the service worker quickly.</source>
          <target state="translated">복잡한 시스템과 마찬가지로 버그 나 구성이 손상되면 Angular 서비스 워커가 예기치 않은 방식으로 작동 할 수 있습니다. Angular 서비스 워커는 이러한 문제의 영향을 최소화하도록 설계되었지만 관리자가 서비스 워커를 빠르게 비활성화해야하는 경우를 대비하여 몇 가지 비상 안전 메커니즘을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="91b6a9c73693ab7273fd7bd5232e5b0489fdfe05" translate="yes" xml:space="preserve">
          <source>Like in AngularJS, Angular automatically mirrors many control properties onto the form control element as CSS classes. You can use these classes to style form control elements according to the state of the form. The following classes are currently supported:</source>
          <target state="translated">AngularJS와 마찬가지로 Angular는 많은 컨트롤 속성을 CSS 클래스와 같은 폼 컨트롤 요소에 자동으로 미러링합니다. 이 클래스를 사용하여 폼의 상태에 따라 폼 컨트롤 요소의 스타일을 지정할 수 있습니다. 다음 클래스가 현재 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6ba9bb36f4f12f28285f91a1591a915e06d43a4b" translate="yes" xml:space="preserve">
          <source>Like most shells, the &lt;code&gt;CrisisCenterComponent&lt;/code&gt; class is minimal because it has no business logic, and its template has no links, just a title and &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; for the crisis center child component.</source>
          <target state="translated">대부분의 셸과 마찬가지로 &lt;code&gt;CrisisCenterComponent&lt;/code&gt; 클래스는 비즈니스 논리가없고 템플릿에 링크가없고 위기 센터 하위 구성 요소에 대한 제목과 &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; 만 있기 때문에 최소 수준입니다 .</target>
        </trans-unit>
        <trans-unit id="d328b7053c6feca70f5f37fd0b1b8634858620c3" translate="yes" xml:space="preserve">
          <source>Like most shells, the &lt;code&gt;CrisisCenterComponent&lt;/code&gt; class is very simple, simpler even than &lt;code&gt;AppComponent&lt;/code&gt;: it has no business logic, and its template has no links, just a title and &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; for the crisis center child component.</source>
          <target state="translated">대부분의 쉘과 마찬가지로, &lt;code&gt;CrisisCenterComponent&lt;/code&gt; 의 클래스도보다 간단하고 매우 간단 &lt;code&gt;AppComponent&lt;/code&gt; 이 더 비즈니스 로직이 없으며, 그 템플릿에는 링크, 단지 제목과 없습니다 : &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; 위기 센터 하위 구성 요소를.</target>
        </trans-unit>
        <trans-unit id="ad5fbe7de515867968271cf92da0ab219dfe53ce" translate="yes" xml:space="preserve">
          <source>Like regular outlets, secondary outlets persists until you navigate away to a new component.</source>
          <target state="translated">일반 콘센트와 마찬가지로 보조 콘센트는 새 구성 요소로 이동할 때까지 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="3c960f51394e20fb877a0120ae9db80a6aba3cf3" translate="yes" xml:space="preserve">
          <source>Like template expressions, template &lt;em&gt;statements&lt;/em&gt; use a language that looks like JavaScript. The template statement parser differs from the template expression parser and specifically supports both basic assignment (&lt;code&gt;=&lt;/code&gt;) and chaining expressions (with &lt;code&gt;;&lt;/code&gt; or &lt;code&gt;,&lt;/code&gt;).</source>
          <target state="translated">템플릿 표현식과 마찬가지로 템플릿 &lt;em&gt;문&lt;/em&gt; 은 JavaScript와 유사한 언어를 사용합니다. 템플리트 명령문 구문 분석기는 템플리트 표현식 구문 분석기와 다르며 특히 기본 지정 ( &lt;code&gt;=&lt;/code&gt; ) 및 연결 표현식 ( &lt;code&gt;;&lt;/code&gt; 또는 &lt;code&gt;,&lt;/code&gt; )을 모두 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="83341afc572aa00f0348ef8d662d360d9825cc0f" translate="yes" xml:space="preserve">
          <source>Like the &lt;code&gt;ng serve&lt;/code&gt; command, this regenerates output files when source files change.</source>
          <target state="translated">&lt;code&gt;ng serve&lt;/code&gt; 명령 과 마찬가지로 소스 파일이 변경 될 때 출력 파일을 재생성합니다.</target>
        </trans-unit>
        <trans-unit id="4690ba435c1d9c2e19677d724dba0cd8f8b810f8" translate="yes" xml:space="preserve">
          <source>Like the TypeScript compiler, The Angular AOT compiler also supports &lt;code&gt;extends&lt;/code&gt; in the &lt;code&gt;angularCompilerOptions&lt;/code&gt; section of the TypeScript configuration file. The &lt;code&gt;extends&lt;/code&gt; property is at the top level, parallel to &lt;code&gt;compilerOptions&lt;/code&gt; and &lt;code&gt;angularCompilerOptions&lt;/code&gt;.</source>
          <target state="translated">TypeScript 컴파일러와 마찬가지로 Angular AOT 컴파일러는 TypeScript 구성 파일 의 &lt;code&gt;angularCompilerOptions&lt;/code&gt; 섹션 에서 &lt;code&gt;extends&lt;/code&gt; 을 지원 합니다. 는 &lt;code&gt;extends&lt;/code&gt; 속성 평행 상위 레벨 인 &lt;code&gt;compilerOptions&lt;/code&gt; 및 &lt;code&gt;angularCompilerOptions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9eb90305b666c99c946bb5838a4ddc083cb67f27" translate="yes" xml:space="preserve">
          <source>Like the TypeScript compiler, The Angular AoT compiler also supports &lt;code&gt;extends&lt;/code&gt; in the &lt;code&gt;angularCompilerOptions&lt;/code&gt; section of the TypeScript configuration file, &lt;code&gt;tsconfig.json&lt;/code&gt;. The &lt;code&gt;extends&lt;/code&gt; property is at the top level, parallel to &lt;code&gt;compilerOptions&lt;/code&gt; and &lt;code&gt;angularCompilerOptions&lt;/code&gt;.</source>
          <target state="translated">TypeScript 컴파일러와 마찬가지로 Angular AoT 컴파일러는 TypeScript 구성 파일 &lt;code&gt;tsconfig.json&lt;/code&gt; 의 &lt;code&gt;angularCompilerOptions&lt;/code&gt; 섹션 에서 &lt;code&gt;extends&lt;/code&gt; 을 지원합니다 . 는 &lt;code&gt;extends&lt;/code&gt; 속성 평행 상위 레벨 인 &lt;code&gt;compilerOptions&lt;/code&gt; 및 &lt;code&gt;angularCompilerOptions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6fbfb2e44912c9fae79f4fff1fd632c52f34ac5" translate="yes" xml:space="preserve">
          <source>Like the array bound to the &lt;em&gt;Contact&lt;/em&gt;&lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;AppComponent&lt;/code&gt;, this one includes an object with an &lt;code&gt;outlets&lt;/code&gt; property. The &lt;code&gt;outlets&lt;/code&gt; property value is another object with outlet names for keys. The only named outlet is &lt;code&gt;'popup'&lt;/code&gt;.</source>
          <target state="translated">받는 결합 배열과 마찬가지로 &lt;em&gt;연락 &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;../api/router/routerlink&quot;&gt;RouterLink&lt;/a&gt;&lt;/code&gt; 에 &lt;code&gt;AppComponent&lt;/code&gt; , 이것과는 목적 포함 &lt;code&gt;outlets&lt;/code&gt; 속성. &lt;code&gt;outlets&lt;/code&gt; 속성 값은 키 출구 이름 또 다른 목적이다. 이름이 지정된 유일한 콘센트는 &lt;code&gt;'popup'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="71038456701c3916973173203244b127960e1aa5" translate="yes" xml:space="preserve">
          <source>Limit &lt;a href=&quot;aot-compiler#expression-syntax&quot;&gt;expression syntax&lt;/a&gt; to the supported subset of JavaScript.</source>
          <target state="translated">지원되는 JavaScript 서브 세트로 &lt;a href=&quot;aot-compiler#expression-syntax&quot;&gt;표현식 구문&lt;/a&gt; 을 제한하십시오 .</target>
        </trans-unit>
        <trans-unit id="aeed6a8852492bee7de657e7a04fde558cde0b38" translate="yes" xml:space="preserve">
          <source>Limit service scope to a component subtree</source>
          <target state="translated">서비스 범위를 컴포넌트 서브 트리로 제한</target>
        </trans-unit>
        <trans-unit id="673e281991136d9d7e9c64e2f080eb1b1ecac1ef" translate="yes" xml:space="preserve">
          <source>Limitation: The &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; function won't work if the test body makes an &lt;code&gt;XMLHttpRequest&lt;/code&gt; (XHR) call. XHR calls within a test are rare, but if you need to call XHR, see &lt;a href=&quot;testing#async&quot;&gt;&lt;code&gt;async()&lt;/code&gt;&lt;/a&gt;, below.</source>
          <target state="translated">제한 사항 : 테스트 본문이 XHR ( &lt;code&gt;XMLHttpRequest&lt;/code&gt; )을 호출 하면 &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; 함수가 작동하지 않습니다 . 테스트 내의 XHR 호출은 드물지만 XHR을 호출해야하는 경우 아래 &lt;a href=&quot;testing#async&quot;&gt; &lt;code&gt;async()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0d0f482405b1ca09a504168b85c0821c0a7b2c58" translate="yes" xml:space="preserve">
          <source>Limitation: The &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; function won't work if the test body makes an &lt;code&gt;XMLHttpRequest&lt;/code&gt; (XHR) call. XHR calls within a test are rare, but if you need to call XHR, see &lt;a href=&quot;testing-components-scenarios#waitForAsync&quot;&gt;&lt;code&gt;waitForAsync()&lt;/code&gt;&lt;/a&gt;, below.</source>
          <target state="translated">제한 사항 : 테스트 본문이 &lt;code&gt;XMLHttpRequest&lt;/code&gt; (XHR) 호출을 수행하면 &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()&lt;/code&gt; 함수가 작동하지 않습니다 . 테스트 내에서 XHR 호출은 드물지만 XHR을 호출해야하는 경우 아래 &lt;a href=&quot;testing-components-scenarios#waitForAsync&quot;&gt; &lt;code&gt;waitForAsync()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ded306388332ec989fda506a02d51aba128c7138" translate="yes" xml:space="preserve">
          <source>Limiting provider scope by lazy loading modules</source>
          <target state="translated">지연 로딩 모듈로 공급자 범위 제한</target>
        </trans-unit>
        <trans-unit id="89ab768d7c5f66203eca0f427be89355c7490b9e" translate="yes" xml:space="preserve">
          <source>Limiting provider scope with components</source>
          <target state="translated">구성 요소로 공급자 범위 제한</target>
        </trans-unit>
        <trans-unit id="dafc778c795eaafcbc7950d059ea632b0bbed413" translate="yes" xml:space="preserve">
          <source>Link parameters array</source>
          <target state="translated">링크 매개 변수 배열</target>
        </trans-unit>
        <trans-unit id="ebeeb12b89ea951a3d70569f3a883c5068bcd2c5" translate="yes" xml:space="preserve">
          <source>Link tag</source>
          <target state="translated">링크 태그</target>
        </trans-unit>
        <trans-unit id="05a4c3bd058773e937f5a60f7f7a6ac340bd0ee8" translate="yes" xml:space="preserve">
          <source>Link the library</source>
          <target state="translated">도서관 연결</target>
        </trans-unit>
        <trans-unit id="e95ec7effe5117842199bf6a8a33372713843750" translate="yes" xml:space="preserve">
          <source>Linked libraries</source>
          <target state="translated">연결된 라이브러리</target>
        </trans-unit>
        <trans-unit id="5abd1d8d73b4555d463bfb879da84e8d8357edc1" translate="yes" xml:space="preserve">
          <source>List Example</source>
          <target state="translated">목록 예</target>
        </trans-unit>
        <trans-unit id="fe441653b156494ea24f494a301178e5b59c44e7" translate="yes" xml:space="preserve">
          <source>List heroes with &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor로&lt;/a&gt; 영웅 목록</target>
        </trans-unit>
        <trans-unit id="9554ab96c5780c8e77824d964ff8ec18697124d1" translate="yes" xml:space="preserve">
          <source>List of additional NgModule files that will be lazy loaded. Lazy router modules will be discovered automatically.</source>
          <target state="translated">지연로드 될 추가 NgModule 파일 목록 게으른 라우터 모듈은 자동으로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="cbce62cc871e24eefa3b59c5e93efe28fffa5a14" translate="yes" xml:space="preserve">
          <source>List of components not referenced in any reachable template, for example dynamically created from code.</source>
          <target state="translated">도달 가능한 템플릿에서 참조되지 않은 구성 요소 목록 (예 : 코드에서 동적으로 생성)</target>
        </trans-unit>
        <trans-unit id="efe7666b861fee17fb6c8a4c39c06756c03bb105" translate="yes" xml:space="preserve">
          <source>List of components to bootstrap when this module is bootstrapped.</source>
          <target state="translated">이 모듈이 부트 스트랩 될 때 부트 스트랩 할 구성 요소 목록.</target>
        </trans-unit>
        <trans-unit id="4095ea4985f0e38f002f69cf452dec18fa4bd79e" translate="yes" xml:space="preserve">
          <source>List of components, directives, and pipes that belong to this module.</source>
          <target state="translated">이 모듈에 속하는 구성 요소, 지시문 및 파이프의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="c889ce564a34bf3ed0a510d34b49b021f11d1487" translate="yes" xml:space="preserve">
          <source>List of components, directives, and pipes visible to modules that import this module.</source>
          <target state="translated">이 모듈을 가져 오는 모듈에 표시되는 구성 요소, 지시문 및 파이프 목록.</target>
        </trans-unit>
        <trans-unit id="d1207345ca32d222a8e432068269adabe143d033" translate="yes" xml:space="preserve">
          <source>List of dependency injection providers for this directive and its children.</source>
          <target state="translated">이 지시문 및 해당 하위에 대한 종속성 주입 제공자 목록.</target>
        </trans-unit>
        <trans-unit id="fe1604c69069d34dff1de4bebbd2c00d202aad46" translate="yes" xml:space="preserve">
          <source>List of dependency injection providers scoped to this component's view.</source>
          <target state="translated">이 구성 요소의 관점에서 범위가 지정된 종속성 주입 공급자 목록입니다.</target>
        </trans-unit>
        <trans-unit id="0764d9c4b1ea0aa7ca88575f1383a8a28c5e17ce" translate="yes" xml:space="preserve">
          <source>List of dependency injection providers visible both to the contents of this module and to importers of this module.</source>
          <target state="translated">이 모듈의 내용과이 모듈의 수입자 모두에게 보이는 의존성 주입 공급자 목록.</target>
        </trans-unit>
        <trans-unit id="1f045cc2a6aef9ce1b80467ca9aa73e97e4a5cf7" translate="yes" xml:space="preserve">
          <source>List of hosts that are allowed to access the dev server.</source>
          <target state="translated">개발 서버에 액세스 할 수있는 호스트 목록입니다.</target>
        </trans-unit>
        <trans-unit id="1705616178a33f362179ee1acbbd208dd8db8f30" translate="yes" xml:space="preserve">
          <source>List of inline CSS styles or external stylesheet URLs for styling the component&amp;rsquo;s view.</source>
          <target state="translated">구성 요소보기의 스타일을 지정하기위한 인라인 CSS 스타일 또는 외부 스타일 시트 URL 목록입니다.</target>
        </trans-unit>
        <trans-unit id="f5d4fc5e3688560af7a94670d8c7f9b85064b9c2" translate="yes" xml:space="preserve">
          <source>List of modules to import into this module. Everything from the imported modules is available to &lt;code&gt;declarations&lt;/code&gt; of this module.</source>
          <target state="translated">이 모듈로 가져올 모듈 목록. 가져온 모듈의 모든 것을 이 모듈의 &lt;code&gt;declarations&lt;/code&gt; 에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0d5e8ade3dc66891a3b11ab132029d51b67ca80" translate="yes" xml:space="preserve">
          <source>List the generated bundles in the &lt;code&gt;dist/&lt;/code&gt; folder.</source>
          <target state="translated">&lt;code&gt;dist/&lt;/code&gt; 폴더 에 생성 된 번들을 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="beb3e6d282efa5be1b17ff0ef3d00e6cf72f51b8" translate="yes" xml:space="preserve">
          <source>List the generated bundles in the &lt;code&gt;dist/project-name/&lt;/code&gt; folder.</source>
          <target state="translated">생성 된 번들을 &lt;code&gt;dist/project-name/&lt;/code&gt; 폴더에 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="73d6d61553d6923f0e56af93936294f91739b3f9" translate="yes" xml:space="preserve">
          <source>List-item separator. Example: &quot;one, two, and three&quot;</source>
          <target state="translated">목록 항목 구분 기호 예 : &quot;하나, 둘, 셋&quot;</target>
        </trans-unit>
        <trans-unit id="f819e377af6a253cf7b15c400531f8b31594b0b4" translate="yes" xml:space="preserve">
          <source>Listed below are the base classes and services used to create and manage form controls.</source>
          <target state="translated">아래에는 양식 컨트롤을 만들고 관리하는 데 사용되는 기본 클래스 및 서비스가 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a90c21e873b5d8262d59496442bc0220f95054ad" translate="yes" xml:space="preserve">
          <source>Listen for data from an input.</source>
          <target state="translated">입력 데이터를 수신하십시오.</target>
        </trans-unit>
        <trans-unit id="148541005c620fc1e1bb09453d368cfc1c05ad83" translate="yes" xml:space="preserve">
          <source>Listen for keystrokes, but provide a stream representing the value in the input.</source>
          <target state="translated">키 입력을 수신하지만 입력 값을 나타내는 스트림을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="37ea46b5942beaeb21bb4e06a14e4f7232d2a1b0" translate="yes" xml:space="preserve">
          <source>Listener</source>
          <target state="translated">Listener</target>
        </trans-unit>
        <trans-unit id="a6bab703979ffded38cb18ceafb2498266b4ba40" translate="yes" xml:space="preserve">
          <source>Listening for form submission</source>
          <target state="translated">양식 제출 청취</target>
        </trans-unit>
        <trans-unit id="de906cfc91b32a32df4f149847ed0a39eecca3f3" translate="yes" xml:space="preserve">
          <source>Listening to progress events</source>
          <target state="translated">진행 이벤트 듣기</target>
        </trans-unit>
        <trans-unit id="f9528c7fd458964ab7b0b92b633774bce83a6ea7" translate="yes" xml:space="preserve">
          <source>Listens for an element change event.</source>
          <target state="translated">요소 변경 이벤트를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="461c42998bd4b841c62ede37f929ff1a1b0ebff3" translate="yes" xml:space="preserve">
          <source>Lists CSS files that supply styles for a project. The extension reflects the style preprocessor you have configured for the project.</source>
          <target state="translated">프로젝트의 스타일을 제공하는 CSS 파일을 나열합니다. 확장은 프로젝트에 대해 구성한 스타일 프리 프로세서를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="4155cc0df13221795a620210d3c6cbdaea741275" translate="yes" xml:space="preserve">
          <source>Lists available commands and their short descriptions.</source>
          <target state="translated">사용 가능한 명령과 간단한 설명을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="16ed44692d8ad77b79438ff89f70547bfc2c8f59" translate="yes" xml:space="preserve">
          <source>Literal array</source>
          <target state="translated">리터럴 배열</target>
        </trans-unit>
        <trans-unit id="5e5d6608e9c1043b497854f14ddd3f434365adbb" translate="yes" xml:space="preserve">
          <source>Literal boolean</source>
          <target state="translated">리터럴 부울</target>
        </trans-unit>
        <trans-unit id="aefb6c535c633d3fd4c244f05f9150051f95d764" translate="yes" xml:space="preserve">
          <source>Literal null</source>
          <target state="translated">리터럴 널</target>
        </trans-unit>
        <trans-unit id="f09a5cb4fe044da34e2089937646a3266bcb0772" translate="yes" xml:space="preserve">
          <source>Literal number</source>
          <target state="translated">리터럴 번호</target>
        </trans-unit>
        <trans-unit id="e873017807fac060c5a6a2540134ecd7af88ac3a" translate="yes" xml:space="preserve">
          <source>Literal object</source>
          <target state="translated">리터럴 객체</target>
        </trans-unit>
        <trans-unit id="0dd2df3bdd58ea3fee6371ca12874b46ac5a08a5" translate="yes" xml:space="preserve">
          <source>Literal string</source>
          <target state="translated">리터럴 문자열</target>
        </trans-unit>
        <trans-unit id="b57452dc90c7272633a6e55b09bbe97b6fc736c0" translate="yes" xml:space="preserve">
          <source>Live Example for named Stackblitz</source>
          <target state="translated">명명 된 Stackblitz의 라이브 예</target>
        </trans-unit>
        <trans-unit id="388c9001eb6fdc7be89eee00a249fe06fb40880d" translate="yes" xml:space="preserve">
          <source>Live Example with download-only</source>
          <target state="translated">다운로드 전용 라이브 예</target>
        </trans-unit>
        <trans-unit id="07ff11a723e5a565044db2e9077a5159e72c2853" translate="yes" xml:space="preserve">
          <source>Live Example without download</source>
          <target state="translated">다운로드하지 않은 라이브 예</target>
        </trans-unit>
        <trans-unit id="15dae1e0d363cb6cbea91c5b210a73bf0dfaf3ce" translate="yes" xml:space="preserve">
          <source>Live example from another guide</source>
          <target state="translated">다른 가이드의 라이브 예</target>
        </trans-unit>
        <trans-unit id="7df310a49c994290ecfc7e21b62d9c4caf2a0804" translate="yes" xml:space="preserve">
          <source>Live example with content label</source>
          <target state="translated">컨텐츠 레이블이있는 실제 예</target>
        </trans-unit>
        <trans-unit id="d66c6803c67f60624e428beacade6cb10972157a" translate="yes" xml:space="preserve">
          <source>Live examples</source>
          <target state="translated">라이브 예</target>
        </trans-unit>
        <trans-unit id="8a7981f020f2c3393efbc6bb8b6d8826836467e9" translate="yes" xml:space="preserve">
          <source>Live examples (AKA &quot;stackblitz&quot;) are defined by one or more &lt;code&gt;stackblitz.json&lt;/code&gt; files in the root of a code sample folder. Each sample folder usually has a single unnamed definition file, the default &lt;code&gt;stackblitz.json&lt;/code&gt;.</source>
          <target state="translated">라이브 예제 (일명 &quot;stackblitz&quot;)는 코드 샘플 폴더의 루트에있는 하나 이상의 &lt;code&gt;stackblitz.json&lt;/code&gt; 파일로 정의됩니다 . 각 샘플 폴더에는 일반적으로 이름이 지정되지 않은 단일 정의 파일 인 기본 &lt;code&gt;stackblitz.json&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c411dac4ba609b8397b10861a22cedb488ad6bfe" translate="yes" xml:space="preserve">
          <source>Load the module lazily if you can. Angular gives a &lt;a href=&quot;ngmodule-faq#q-lazy-loaded-module-provider-visibility&quot;&gt;lazy-loaded module&lt;/a&gt; its own child injector. The module's providers are visible only within the component tree created with this injector.</source>
          <target state="translated">가능하면 모듈을 느리게로드하십시오. Angular는 &lt;a href=&quot;ngmodule-faq#q-lazy-loaded-module-provider-visibility&quot;&gt;지연 로딩 모듈&lt;/a&gt; 에 자체 자식 인젝터를 제공합니다. 모듈의 제공자는이 인젝터로 작성된 컴포넌트 트리 내에서만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="855626215880fd7dea9a3f607d78c18204bfbf46" translate="yes" xml:space="preserve">
          <source>Load the router library.</source>
          <target state="translated">라우터 라이브러리를로드하십시오.</target>
        </trans-unit>
        <trans-unit id="2fc4426cd416a32214c9b3b17bd86f3d1c1570cf" translate="yes" xml:space="preserve">
          <source>LoadChildren</source>
          <target state="translated">LoadChildren</target>
        </trans-unit>
        <trans-unit id="9f0b098c811d75663f50ef7845bc4eb008bd71e1" translate="yes" xml:space="preserve">
          <source>LoadChildrenCallback</source>
          <target state="translated">LoadChildrenCallback</target>
        </trans-unit>
        <trans-unit id="31112e015bc59afed4d726bc9b3b2423316d6d0e" translate="yes" xml:space="preserve">
          <source>Loading component styles</source>
          <target state="translated">구성 요소 스타일로드</target>
        </trans-unit>
        <trans-unit id="35b7de4928575370e540a435aa94cc96210fd6a0" translate="yes" xml:space="preserve">
          <source>Loading components</source>
          <target state="translated">구성 요소로드</target>
        </trans-unit>
        <trans-unit id="ef1b3efd0750b6cb1d1bea14f88b3643b10ef11c" translate="yes" xml:space="preserve">
          <source>Loading external stylesheets is a blocking operation, which means that the browser can&amp;rsquo;t start rendering your application until it loads all the referenced CSS. Having render-blocking resources in the header of a page can significantly impact its load performance, for example, its &lt;a href=&quot;https://web.dev/first-contentful-paint/&quot;&gt;first contentful paint&lt;/a&gt;. To make apps faster, we&amp;rsquo;ve been collaborating with the Google Chrome team on inlining critical CSS and loading the rest of the styles asynchronously.</source>
          <target state="translated">외부 스타일 시트를로드하는 것은 차단 작업입니다. 즉, 브라우저가 참조 된 모든 CSS를로드 할 때까지 애플리케이션 렌더링을 시작할 수 없습니다. 페이지 헤더에 렌더링 차단 리소스가 있으면로드 성능에 상당한 영향을 미칠 수 있습니다 (예 : &lt;a href=&quot;https://web.dev/first-contentful-paint/&quot;&gt;첫 번째 콘텐츠 페인트)&lt;/a&gt; . 앱을 더 빠르게 만들기 위해 Google은 중요한 CSS를 인라인하고 나머지 스타일을 비동기식으로로드하기 위해 Chrome 팀과 협력하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="f359a44a5b3782750e70ce88ac64b11e5f3123ba" translate="yes" xml:space="preserve">
          <source>Local development in older browsers</source>
          <target state="translated">구형 브라우저에서의 로컬 개발</target>
        </trans-unit>
        <trans-unit id="d1e5308b3d59fa3cd12e651dd78e919dc9761776" translate="yes" xml:space="preserve">
          <source>Local references to DOM elements.</source>
          <target state="translated">DOM 요소에 대한 로컬 참조.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
