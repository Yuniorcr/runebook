<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="angular">
    <body>
      <group id="angular">
        <trans-unit id="94b7d838e156ba687705d55bf53cfaea0e2c0706" translate="yes" xml:space="preserve">
          <source>An options object containing developer-defined parameters that provide styling defaults and can be overridden on invocation.</source>
          <target state="translated">스타일링 기본값을 제공하고 호출시 대체 될 수있는 개발자 정의 매개 변수를 포함하는 옵션 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="003f413ea648a113813256191625bc45b897caef" translate="yes" xml:space="preserve">
          <source>An options object that can contain a delay value for the start of the animation, and additional developer-defined parameters. Provided values for additional parameters are used as defaults, and override values can be passed to the caller on invocation.</source>
          <target state="translated">애니메이션 시작에 대한 지연 값 및 추가 개발자 정의 매개 변수를 포함 할 수있는 옵션 객체입니다. 추가 매개 변수에 제공된 값이 기본값으로 사용되며 호출시 대체 값을 호출자에게 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69da736740d2be7cce09038dd8384329068cb27f" translate="yes" xml:space="preserve">
          <source>An options object that can contain a delay value for the start of the animation, and additional override values for developer-defined parameters.</source>
          <target state="translated">애니메이션 시작에 대한 지연 값과 개발자 정의 매개 변수에 대한 추가 재정의 값을 포함 할 수있는 옵션 객체입니다.</target>
        </trans-unit>
        <trans-unit id="eb15eab209a0162e90e8de577b3e4f749717a52f" translate="yes" xml:space="preserve">
          <source>An options object that determines how the URL should be constructed or interpreted.</source>
          <target state="translated">URL을 구성하거나 해석하는 방법을 결정하는 옵션 개체입니다.</target>
        </trans-unit>
        <trans-unit id="f2ba026d039587baf26944d77bd6fbe6191f4188" translate="yes" xml:space="preserve">
          <source>An options object. Use the 'limit' field to limit the total number of items to collect.</source>
          <target state="translated">옵션 객체. '제한'필드를 사용하여 수집 할 총 품목 수를 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="2b8661ad4d0353fe1ca3345139fe01a98c998165" translate="yes" xml:space="preserve">
          <source>An outgoing HTTP request with an optional typed body.</source>
          <target state="translated">선택적 유형 본문이있는 발신 HTTP 요청</target>
        </trans-unit>
        <trans-unit id="2b3e6f58b8017320fb8ad2d620bfa5f840b529df" translate="yes" xml:space="preserve">
          <source>An unmodifiable list of items that Angular keeps up to date when the state of the application changes.</source>
          <target state="translated">응용 프로그램 상태가 변경 될 때 Angular가 최신 상태로 유지하는 수정 불가능한 항목 목록입니다.</target>
        </trans-unit>
        <trans-unit id="b0c610b5f38365ac89cc6b28fe1af7503fdd6a36" translate="yes" xml:space="preserve">
          <source>An unrelated error causes the service worker to enter safe mode; that is, temporary deactivation.</source>
          <target state="translated">관련이없는 오류로 인해 서비스 작업자는 안전 모드로 들어갑니다. 즉, 일시적 비활성화입니다.</target>
        </trans-unit>
        <trans-unit id="cc3c9eefabc7f0cea08522cde34fd4642d6273a0" translate="yes" xml:space="preserve">
          <source>An unsurprising observation for a demo. To be honest, jazzing it up won't teach you anything new about forms. But this is an opportunity to exercise some of your newly won binding skills. If you aren't interested, skip to this page's conclusion.</source>
          <target state="translated">데모에 대한 놀라운 관찰. 솔직히 말해서, 재즈는 양식에 대해 새로운 것을 가르쳐주지 않습니다. 그러나 이것은 당신이 새로이긴 바인딩 기술을 연습 할 수있는 기회입니다. 관심이 없다면이 페이지의 결론으로 ​​건너 뛰십시오.</target>
        </trans-unit>
        <trans-unit id="452cffe88932ae77fe68dbf055515d671319274e" translate="yes" xml:space="preserve">
          <source>An upgraded component may also have inputs and outputs, as defined by the scope/controller bindings of the original AngularJS component directive. When you use the component from an Angular template, provide the inputs and outputs using &lt;strong&gt;Angular template syntax&lt;/strong&gt;, observing the following rules:</source>
          <target state="translated">업그레이드 된 구성 요소에는 원래 AngularJS 구성 요소 지시문의 범위 / 컨트롤러 바인딩에 의해 정의 된대로 입력 및 출력이있을 수 있습니다. Angular 템플릿에서 컴포넌트를 사용하는 경우 다음 규칙을 준수 하여 &lt;strong&gt;Angular 템플릿 구문을&lt;/strong&gt; 사용하여 입력 및 출력을 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="c32307f2c480f6053e5eabae11932dca1c5bd1fb" translate="yes" xml:space="preserve">
          <source>An upload progress event was received.</source>
          <target state="translated">업로드 진행 이벤트가 수신되었습니다.</target>
        </trans-unit>
        <trans-unit id="3ecd206c90170f8ae7938d7cd6bd36735ba58063" translate="yes" xml:space="preserve">
          <source>An upload progress event.</source>
          <target state="translated">업로드 진행 이벤트</target>
        </trans-unit>
        <trans-unit id="e2e2a215be86f3d1acdd9e0d7a47d98ae4b62c70" translate="yes" xml:space="preserve">
          <source>Anchor element that specifies the location of this container in the containing view. Each view container can have only one anchor element, and each anchor element can have only a single view container.</source>
          <target state="translated">포함하는보기에서이 컨테이너의 위치를 ​​지정하는 앵커 요소입니다. 각 뷰 컨테이너에는 앵커 요소가 하나만있을 수 있으며 각 앵커 요소에는 단일 뷰 컨테이너 만있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5d76a3a5f5caf5269f66c1a65575cf3b3e26baf" translate="yes" xml:space="preserve">
          <source>Anchor scrolling does not happen on 'popstate'. Instead, we restore the position that we stored or scroll to the top.</source>
          <target state="translated">'popstate'에서는 앵커 스크롤이 발생하지 않습니다. 대신, 저장 한 위치를 복원하거나 맨 위로 스크롤합니다.</target>
        </trans-unit>
        <trans-unit id="a307a637b89fe16e9922778e99bea2ed2e8e496b" translate="yes" xml:space="preserve">
          <source>Anchors</source>
          <target state="translated">Anchors</target>
        </trans-unit>
        <trans-unit id="f51084cd80a34108fd5adb4fd8ede43309c33705" translate="yes" xml:space="preserve">
          <source>And because this component is being used from the AngularJS module, and is an entry point into the Angular application, you must add it to the &lt;code&gt;entryComponents&lt;/code&gt; for the NgModule.</source>
          <target state="translated">또한이 컴포넌트는 AngularJS 모듈에서 사용되며 Angular 애플리케이션의 진입 점 &lt;code&gt;entryComponents&lt;/code&gt; 의 entryComponents 에 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="220dca1fbf38afa8fcb52d2808f50aad1904d032" translate="yes" xml:space="preserve">
          <source>And both together:</source>
          <target state="translated">그리고 둘 다 함께 :</target>
        </trans-unit>
        <trans-unit id="4cb748fd250adc2e2b24d881d384cd3f1ceeff26" translate="yes" xml:space="preserve">
          <source>And for the phone list component, a few adjustments to the router make the &lt;code&gt;RouteLink&lt;/code&gt; directives work.</source>
          <target state="translated">전화 목록 구성 요소의 경우 라우터를 약간 조정하면 &lt;code&gt;RouteLink&lt;/code&gt; 지시문이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="029ba4666a2a6cfed9bf04394f2a405b66d1d323" translate="yes" xml:space="preserve">
          <source>And here are some tests:</source>
          <target state="translated">다음은 몇 가지 테스트입니다.</target>
        </trans-unit>
        <trans-unit id="fffb5f839ebabc375dc3442fb647c4f7c7a16fe5" translate="yes" xml:space="preserve">
          <source>And here's how you could use it with a different parent type.</source>
          <target state="translated">다음은 다른 부모 유형과 함께 사용하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="726041286efb6514f4d5c48dff50434ecdff60e6" translate="yes" xml:space="preserve">
          <source>And if the first segment begins with &lt;code&gt;../&lt;/code&gt;, the router will go up one level.</source>
          <target state="translated">그리고 첫 번째 세그먼트가 &lt;code&gt;../&lt;/code&gt; 로 시작 하면 라우터는 한 수준 위로 올라갑니다.</target>
        </trans-unit>
        <trans-unit id="ace9fdb010266cfc5897288d4e8cb9c930bc595b" translate="yes" xml:space="preserve">
          <source>And in some case, we don't want to trigger the new macro task when ticking, we can use &lt;code&gt;&lt;a href=&quot;../api/core/testing/tick&quot;&gt;tick&lt;/a&gt;(milliseconds, {processNewMacroTasksSynchronously: false})&lt;/code&gt; to not invoke new macro task.</source>
          <target state="translated">그리고 어떤 경우에는 틱할 때 새 매크로 작업을 트리거하고 싶지 않습니다. &lt;code&gt;&lt;a href=&quot;../api/core/testing/tick&quot;&gt;tick&lt;/a&gt;(milliseconds, {processNewMacroTasksSynchronously: false})&lt;/code&gt; 을 사용하여 새 매크로 작업을 호출하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="581486c9bdaa42d9745149011abbcef5b3d346e8" translate="yes" xml:space="preserve">
          <source>And in the earlier versions of &lt;code&gt;Angular&lt;/code&gt;, the following files were imported or added in your html file:</source>
          <target state="translated">그리고 이전 버전의 &lt;code&gt;Angular&lt;/code&gt; 에서는 html 파일에서 다음 파일을 가져 오거나 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="b2274e10984bdcfe61fe3f96ba22a2a4c56b464e" translate="yes" xml:space="preserve">
          <source>And in the same file, add it to the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt;&lt;code&gt;declarations&lt;/code&gt; array:</source>
          <target state="translated">그리고 같은 파일에서 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; &lt;code&gt;declarations&lt;/code&gt; 배열에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="514df4d7b03eb7b4bff57e5cc4c1f60e85c21481" translate="yes" xml:space="preserve">
          <source>And later the value can be read from the router through &lt;code&gt;router.getCurrentNavigation&lt;/code&gt;. For example, to capture the &lt;code&gt;tracingId&lt;/code&gt; above during the &lt;code&gt;&lt;a href=&quot;navigationstart&quot;&gt;NavigationStart&lt;/a&gt;&lt;/code&gt; event:</source>
          <target state="translated">그리고 나중에 &lt;code&gt;router.getCurrentNavigation&lt;/code&gt; 을 통해 라우터에서 값을 읽을 수 있습니다 . 예를 들어 &lt;code&gt;&lt;a href=&quot;navigationstart&quot;&gt;NavigationStart&lt;/a&gt;&lt;/code&gt; 이벤트 중에 위 의 &lt;code&gt;tracingId&lt;/code&gt; 를 캡처하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba55a85734b9b1212d4da61228070f47cd0a644b" translate="yes" xml:space="preserve">
          <source>And since you are routing to &lt;code&gt;PhoneListComponent&lt;/code&gt; and &lt;code&gt;PhoneDetailComponent&lt;/code&gt; directly rather than using a route template with a &lt;code&gt;&amp;lt;phone-list&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;phone-detail&amp;gt;&lt;/code&gt; tag, you can do away with their Angular selectors as well.</source>
          <target state="translated">&lt;code&gt;&amp;lt;phone-list&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;phone-detail&amp;gt;&lt;/code&gt; 태그가 있는 라우트 템플릿을 사용하지 않고 &lt;code&gt;PhoneListComponent&lt;/code&gt; 및 &lt;code&gt;PhoneDetailComponent&lt;/code&gt; 로 직접 라우팅하므로 Angular 선택기를 사용하지 않아도 됩니다 .</target>
        </trans-unit>
        <trans-unit id="661c680937dcc4b25a3517246569dc41b5dcad75" translate="yes" xml:space="preserve">
          <source>And that is all you need to do to get the full benefit of AOT for hybrid Angular apps.</source>
          <target state="translated">그리고 이것이 하이브리드 Angular 앱에 대한 AOT의 이점을 최대한 활용하기 위해 필요한 모든 것입니다.</target>
        </trans-unit>
        <trans-unit id="fe495daae12d4210a639f103ea132191cdb68bc6" translate="yes" xml:space="preserve">
          <source>And that's all you need do to get the full benefit of AOT for Angular apps!</source>
          <target state="translated">그리고 이것이 Angular 앱을위한 AOT를 최대한 활용하기 위해 필요한 모든 것입니다!</target>
        </trans-unit>
        <trans-unit id="4d279d81a0c6f6d0a1bd9ed9c92b0938afbbfc7a" translate="yes" xml:space="preserve">
          <source>And that's all you need to use AOT while upgrading your app!</source>
          <target state="translated">그리고 이것이 앱을 업그레이드하는 동안 AOT를 사용해야하는 전부입니다!</target>
        </trans-unit>
        <trans-unit id="f94852fb7b378d191158016d057691422128d0e7" translate="yes" xml:space="preserve">
          <source>And the second is the phone links spec:</source>
          <target state="translated">두 번째는 전화 링크 사양입니다.</target>
        </trans-unit>
        <trans-unit id="a104acccd6d3a8c8cdd1533ec92d99aac644c44f" translate="yes" xml:space="preserve">
          <source>And you can also &lt;a href=&quot;pipes#parameterizing-a-pipe&quot;&gt;apply parameters&lt;/a&gt; to a pipe:</source>
          <target state="translated">파이프에 &lt;a href=&quot;pipes#parameterizing-a-pipe&quot;&gt;매개 변수&lt;/a&gt; 를 적용 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1928f95c598b9e69462fcb512625cf8e28923044" translate="yes" xml:space="preserve">
          <source>Android</source>
          <target state="translated">Android</target>
        </trans-unit>
        <trans-unit id="8e09000e5c2a6bef346596ec2e0dec0fbf7495a6" translate="yes" xml:space="preserve">
          <source>Angular</source>
          <target state="translated">Angular</target>
        </trans-unit>
        <trans-unit id="9ce4e3444001628938f2114d22cede0cbf3a7345" translate="yes" xml:space="preserve">
          <source>Angular &lt;code&gt;NgModule&lt;/code&gt; names</source>
          <target state="translated">각도 &lt;code&gt;NgModule&lt;/code&gt; 이름</target>
        </trans-unit>
        <trans-unit id="1f6360f096ca639bc12a094822b3c9d70dfbe98f" translate="yes" xml:space="preserve">
          <source>Angular &lt;code&gt;TestBed&lt;/code&gt;</source>
          <target state="translated">각도 &lt;code&gt;TestBed&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="006832a598bcc0cfd1bccafa8c1be8086583b93a" translate="yes" xml:space="preserve">
          <source>Angular &lt;em&gt;NgModules&lt;/em&gt; differ from and complement JavaScript (ES2015) modules. An NgModule declares a compilation context for a set of components that is dedicated to an application domain, a workflow, or a closely related set of capabilities. An NgModule can associate its components with related code, such as services, to form functional units.</source>
          <target state="translated">Angular &lt;em&gt;NgModules&lt;/em&gt; 는 JavaScript (ES2015) 모듈과 다릅니다. NgModule은 애플리케이션 도메인, 워크 플로우 또는 밀접하게 관련된 기능 세트 전용 컴포넌트 세트에 대한 컴파일 컨텍스트를 선언합니다. NgModule은 구성 요소를 서비스와 같은 관련 코드와 연관시켜 기능 단위를 형성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a90be85a404ed076f232eda66f6c97b3763ffdd" translate="yes" xml:space="preserve">
          <source>Angular &lt;em&gt;TestBed&lt;/em&gt;</source>
          <target state="translated">각도 &lt;em&gt;테스트 베드&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="53cd3baaa80c39be7dbd5ce81eccbf14c1556192" translate="yes" xml:space="preserve">
          <source>Angular &lt;strong&gt;pipes&lt;/strong&gt; provide formatting and transformation for data in the template, similar to AngularJS &lt;strong&gt;filters&lt;/strong&gt;. Many of the built-in filters in AngularJS have corresponding pipes in Angular. For more information on pipes, see &lt;a href=&quot;pipes&quot;&gt;Pipes&lt;/a&gt;.</source>
          <target state="translated">각도 &lt;strong&gt;파이프&lt;/strong&gt; 는 AngularJS &lt;strong&gt;필터&lt;/strong&gt; 와 유사하게 템플리트의 데이터에 대한 형식화 및 변환을 제공 &lt;strong&gt;합니다&lt;/strong&gt; . AngularJS의 많은 내장 필터에는 Angular에 해당 파이프가 있습니다. 파이프에 대한 자세한 내용은 &lt;a href=&quot;pipes&quot;&gt;파이프&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e4edf38643031effae8215b553b7b9f34ca0029f" translate="yes" xml:space="preserve">
          <source>Angular CLI</source>
          <target state="translated">Angular CLI</target>
        </trans-unit>
        <trans-unit id="1da97b715125a7200320cdfe21476ab138911186" translate="yes" xml:space="preserve">
          <source>Angular CLI Builders</source>
          <target state="translated">앵귤러 CLI 빌더</target>
        </trans-unit>
        <trans-unit id="3653bc26169ea2a82f0e32bcc7ee3413e62dae01" translate="yes" xml:space="preserve">
          <source>Angular CLI builders</source>
          <target state="translated">Angular CLI 빌더</target>
        </trans-unit>
        <trans-unit id="4bb2c93eefe07b05ec8b83738295b287544a8994" translate="yes" xml:space="preserve">
          <source>Angular Components Overview</source>
          <target state="translated">각도 구성 요소 개요</target>
        </trans-unit>
        <trans-unit id="0b62b52e382c94a5e31cfe2e45350c0ad57bfde2" translate="yes" xml:space="preserve">
          <source>Angular DI has a &lt;a href=&quot;hierarchical-dependency-injection&quot;&gt;hierarchical injection system&lt;/a&gt;, which means that nested injectors can create their own service instances. Angular regularly creates nested injectors. Whenever Angular creates a new instance of a component that has &lt;code&gt;providers&lt;/code&gt; specified in &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt;, it also creates a new &lt;em&gt;child injector&lt;/em&gt; for that instance. Similarly, when a new NgModule is lazy-loaded at run time, Angular can create an injector for it with its own providers.</source>
          <target state="translated">Angular DI는 &lt;a href=&quot;hierarchical-dependency-injection&quot;&gt;계층 적 인젝션 시스템&lt;/a&gt; 을 가지고있어 중첩 된 인젝터가 자체 서비스 인스턴스를 생성 할 수 있습니다. 각도는 정기적으로 중첩 인젝터를 만듭니다. Angular 는 &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt; () 에 &lt;code&gt;providers&lt;/code&gt; 지정된 구성 요소의 새 인스턴스를 만들 때마다 해당 인스턴스에 대한 새 &lt;em&gt;자식 인젝터&lt;/em&gt; 도 만듭니다 . 마찬가지로, 새로운 NgModule이 런타임에 지연 로딩되면 Angular는 자체 공급자와 함께 인젝터를 생성 할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b6f10f0e075446afd6bd0316044e6433708768b2" translate="yes" xml:space="preserve">
          <source>Angular Documentation</source>
          <target state="translated">각도 문서</target>
        </trans-unit>
        <trans-unit id="f800173505ee0bcc1b11e1ddf36ce8a030dd7494" translate="yes" xml:space="preserve">
          <source>Angular Documentation Style Guide</source>
          <target state="translated">각도 문서 스타일 안내서</target>
        </trans-unit>
        <trans-unit id="4656edbf91cfa36158075026931a11032cead650" translate="yes" xml:space="preserve">
          <source>Angular Elements Overview</source>
          <target state="translated">각도 요소 개요</target>
        </trans-unit>
        <trans-unit id="a712d3ddcf5a40d1f3dbf3886b04c348fc777701" translate="yes" xml:space="preserve">
          <source>Angular Ivy</source>
          <target state="translated">앵귤러 아이비</target>
        </trans-unit>
        <trans-unit id="e07038b6aad22461ee7bae9dc2b45c7a7c2e2daf" translate="yes" xml:space="preserve">
          <source>Angular JSONP requests return an &lt;code&gt;Observable&lt;/code&gt;. Follow the pattern for subscribing to observables and use the RxJS &lt;code&gt;map&lt;/code&gt; operator to transform the response before using the &lt;a href=&quot;../api/common/asyncpipe&quot;&gt;async pipe&lt;/a&gt; to manage the results.</source>
          <target state="translated">각도 JSONP 요청은 &lt;code&gt;Observable&lt;/code&gt; 을 반환합니다 . &lt;a href=&quot;../api/common/asyncpipe&quot;&gt;비동기 파이프&lt;/a&gt; 를 사용하여 결과를 관리 하기 전에 관찰 가능 항목을 구독하는 패턴을 따르고 RxJS &lt;code&gt;map&lt;/code&gt; 연산자를 사용하여 응답을 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc9d2d14b4723cc3db1775007d3a69846afb3014" translate="yes" xml:space="preserve">
          <source>Angular Labs</source>
          <target state="translated">앵귤러 랩</target>
        </trans-unit>
        <trans-unit id="9e7a56e64dea1098d28d55765096fc618a9b8502" translate="yes" xml:space="preserve">
          <source>Angular Labs is an initiative to cultivate new features and iterate on them quickly. Angular Labs provides a safe place for exploration and experimentation by the Angular team.</source>
          <target state="translated">Angular Labs는 새로운 기능을 개발하고 신속하게 반복하기위한 이니셔티브입니다. Angular Labs는 Angular 팀이 탐색하고 실험 할 수있는 안전한 장소를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b00d2c229068abc17cff954895b39cdc3bf5ff0d" translate="yes" xml:space="preserve">
          <source>Angular Labs projects are not ready for production use, and no commitment is made to bring them to production. The policies and practices that are described in this document do not apply to Angular Labs projects.</source>
          <target state="translated">Angular Labs 프로젝트는 프로덕션 사용 준비가되지 않았으며 프로덕션 환경으로 가져갈 약속이 없습니다. 이 문서에서 설명하는 정책 및 관행은 Angular Labs 프로젝트에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14af2b4bd0445fb663d36a7aa76d50d4caa6816b" translate="yes" xml:space="preserve">
          <source>Angular Language Service</source>
          <target state="translated">각도 언어 서비스</target>
        </trans-unit>
        <trans-unit id="72a9af2d40cd0cddac1ab7c8148463ece8b5ffc7" translate="yes" xml:space="preserve">
          <source>Angular Language Service in your editor</source>
          <target state="translated">에디터의 Angular Language Service</target>
        </trans-unit>
        <trans-unit id="b73e3a2a2136a6a52f2f163943dedb823749ad44" translate="yes" xml:space="preserve">
          <source>Angular Language Service is currently available as an extension for &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;Visual Studio Code&lt;/a&gt;, &lt;a href=&quot;https://www.jetbrains.com/webstorm&quot;&gt;WebStorm&lt;/a&gt;, and &lt;a href=&quot;https://www.sublimetext.com/&quot;&gt;Sublime Text&lt;/a&gt;.</source>
          <target state="translated">Angular Language Service는 현재 &lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;Visual Studio Code&lt;/a&gt; , &lt;a href=&quot;https://www.jetbrains.com/webstorm&quot;&gt;WebStorm&lt;/a&gt; 및 &lt;a href=&quot;https://www.sublimetext.com/&quot;&gt;Sublime Text&lt;/a&gt; 의 확장으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="23326d8b3d91491eb282a0110a38cbdd0d630fcc" translate="yes" xml:space="preserve">
          <source>Angular Material, for example, supplies generation schematics for the UI components that it defines. The following command uses one of these schematics to render an Angular Material &lt;code&gt;&amp;lt;mat-table&amp;gt;&lt;/code&gt; that is pre-configured with a datasource for sorting and pagination.</source>
          <target state="translated">예를 들어, 앵귤러 머티리얼은 정의한 UI 컴포넌트에 대한 생성 회로도를 제공합니다. 다음 명령은 이러한 회로도 중 하나를 사용 하여 정렬 및 페이지 매김을 위해 데이터 소스로 사전 구성된 Angular Material &lt;code&gt;&amp;lt;mat-table&amp;gt;&lt;/code&gt; 을 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="eb970b461e5095261dfad388a7452d357e39a442" translate="yes" xml:space="preserve">
          <source>Angular Push Notifications</source>
          <target state="translated">각도 푸시 알림</target>
        </trans-unit>
        <trans-unit id="5abfa4de29cb28a07c1f78cb93d892d7047d5f4b" translate="yes" xml:space="preserve">
          <source>Angular Roadmap</source>
          <target state="translated">Angular 로드맵</target>
        </trans-unit>
        <trans-unit id="cc237f83efa1a2b5e00294a0bdae42196f8db9d6" translate="yes" xml:space="preserve">
          <source>Angular UI components</source>
          <target state="translated">각도 UI 구성 요소</target>
        </trans-unit>
        <trans-unit id="ace4d235cf67a63f6410e00d7c53d4995b98a87e" translate="yes" xml:space="preserve">
          <source>Angular Universal can generate a static version of your app that is easily searchable, linkable, and navigable without JavaScript. Universal also makes a site preview available since each URL returns a fully rendered page.</source>
          <target state="translated">Angular Universal은 JavaScript없이 쉽게 검색, 연결 및 탐색 할 수있는 정적 버전의 앱을 생성 할 수 있습니다. 또한 Universal은 각 URL이 완전히 렌더링 된 페이지를 반환하므로 사이트 미리보기를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="03a5c1283a3b0775a44e17725d52243197c5b04f" translate="yes" xml:space="preserve">
          <source>Angular Versioning and Releases</source>
          <target state="translated">각도 버전 및 릴리스</target>
        </trans-unit>
        <trans-unit id="a8e46db497a411dfa77cebcd5f020de2e1dd9c9a" translate="yes" xml:space="preserve">
          <source>Angular Workspace Configuration</source>
          <target state="translated">각도 작업 공간 구성</target>
        </trans-unit>
        <trans-unit id="cec48440aa352f69975cc33a6148da27d5bd34ec" translate="yes" xml:space="preserve">
          <source>Angular adds &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule#providers&quot;&gt;NgModule.providers&lt;/a&gt;&lt;/code&gt; to the application root injector, unless the NgModule is lazy-loaded. For a lazy-loaded NgModule, Angular creates a &lt;em&gt;child injector&lt;/em&gt; and adds the module's providers to the child injector.</source>
          <target state="translated">NgModule이 느리게로드되지 않으면 Angular는 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule#providers&quot;&gt;NgModule.providers&lt;/a&gt;&lt;/code&gt; 를 응용 프로그램 루트 인젝터에 추가합니다 . 지연로드 된 NgModule의 경우 Angular는 &lt;em&gt;하위 인젝터를&lt;/em&gt; 작성 하고 모듈의 제공자를 &lt;em&gt;하위 인젝터&lt;/em&gt; 에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8e142da275e31e83a34423dee09ae7d117ad91d6" translate="yes" xml:space="preserve">
          <source>Angular adds a decorator to the component class to provide any required metadata. The &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; decorator declares that the class is a component and provides metadata about that component such as its selector (or tag) and its template.</source>
          <target state="translated">Angular는 구성 요소 클래스에 데코레이터를 추가하여 필요한 메타 데이터를 제공합니다. &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; 장식 클래스가 컴포넌트이며, 셀렉터 (또는 태그) 및 주형으로 그 구성 예에 대한 메타 데이터를 제공한다고 선언한다.</target>
        </trans-unit>
        <trans-unit id="aca3ec94d9d835e1ed7052f9071ac32c46856347" translate="yes" xml:space="preserve">
          <source>Angular adds a directive to the injector of the element to which it is applied. The test for the default color uses the injector of the second &lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt; to get its &lt;code&gt;HighlightDirective&lt;/code&gt; instance and its &lt;code&gt;defaultColor&lt;/code&gt;.</source>
          <target state="translated">Angular는 적용되는 요소의 인젝터에 지시문을 추가합니다. 기본 색상 테스트에서는 두 번째 &lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt; 인젝터를 사용하여 &lt;code&gt;HighlightDirective&lt;/code&gt; 인스턴스와 &lt;code&gt;defaultColor&lt;/code&gt; 를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="da8913da0b293e00f59a47b8577bbaab64befa70" translate="yes" xml:space="preserve">
          <source>Angular adds certain components to &lt;em&gt;entry components&lt;/em&gt; automatically. Components listed in &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule#bootstrap&quot;&gt;NgModule.bootstrap&lt;/a&gt;&lt;/code&gt; are added automatically. Components referenced in router configuration are added automatically. These two mechanisms account for almost all entry components.</source>
          <target state="translated">각도는 특정 구성 요소를 &lt;em&gt;입력 구성 요소에&lt;/em&gt; 자동으로 추가합니다 . &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule#bootstrap&quot;&gt;NgModule.bootstrap&lt;/a&gt;&lt;/code&gt; 나열된 구성 요소 가 자동으로 추가됩니다. 라우터 구성에서 참조 된 구성 요소가 자동으로 추가됩니다. 이 두 가지 메커니즘은 거의 모든 엔트리 구성 요소를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f50aee85f7427b0f3d13af1fcaba2844470cacc5" translate="yes" xml:space="preserve">
          <source>Angular already contains locale data for &lt;code&gt;en-US&lt;/code&gt;. The Angular CLI automatically includes the locale data and sets the &lt;code&gt;&lt;a href=&quot;../api/core/locale_id&quot;&gt;LOCALE_ID&lt;/a&gt;&lt;/code&gt; value when you use the &lt;code&gt;--localize&lt;/code&gt; option with &lt;a href=&quot;cli/build&quot;&gt;&lt;code&gt;ng build&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Angular에는 이미 &lt;code&gt;en-US&lt;/code&gt; 에 대한 로케일 데이터가 포함되어 있습니다 . Angular CLI는 자동으로 로케일 데이터를 포함하고 &lt;a href=&quot;cli/build&quot;&gt; &lt;code&gt;ng build&lt;/code&gt; &lt;/a&gt; 와 함께 &lt;code&gt;--localize&lt;/code&gt; 옵션 을 사용할 때 &lt;code&gt;&lt;a href=&quot;../api/core/locale_id&quot;&gt;LOCALE_ID&lt;/a&gt;&lt;/code&gt; 값을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="8180ba453d2cdcbd2ab6f26a1150063377e78bc1" translate="yes" xml:space="preserve">
          <source>Angular also extracts alternate &lt;code&gt;select&lt;/code&gt; ICU expressions as separate translation units. The following shows a &lt;code&gt;select&lt;/code&gt; ICU expression in the component template:</source>
          <target state="translated">Angular는 또한 별도의 번역 단위로 대체 &lt;code&gt;select&lt;/code&gt; ICU 표현식을 추출 합니다. 다음은 구성 요소 템플릿 의 &lt;code&gt;select&lt;/code&gt; ICU 표현식을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="1bfaa4d4afc1fe6d25c5ea40750798df1ebd8735" translate="yes" xml:space="preserve">
          <source>Angular also has &lt;strong&gt;class binding&lt;/strong&gt;, which is a good way to add or remove a single class, as shown in the third example.</source>
          <target state="translated">Angular는 &lt;strong&gt;클래스 바인딩&lt;/strong&gt; 도 가지고 있는데, 이는 세 번째 예제와 같이 단일 클래스를 추가하거나 제거하는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="aab5930151c105e1c5d03b6b3f8697b3dc85e9e7" translate="yes" xml:space="preserve">
          <source>Angular also has &lt;strong&gt;style binding&lt;/strong&gt;, which is good way to set a single style. This is shown in the second example.</source>
          <target state="translated">Angular에는 &lt;strong&gt;스타일 바인딩&lt;/strong&gt; 도 있습니다 . 이는 단일 스타일을 설정하는 좋은 방법입니다. 이것은 두 번째 예에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="010abb47fc3adc05722e4ae6eda90d0b3da5b301" translate="yes" xml:space="preserve">
          <source>Angular also has a &lt;code&gt;&lt;a href=&quot;../api/common/percentpipe&quot;&gt;percent&lt;/a&gt;&lt;/code&gt; pipe, which formats a number as a local percentage as shown in the third example.</source>
          <target state="translated">Angular 에는 세 번째 예제와 같이 숫자를 로컬 백분율로 형식화 하는 &lt;code&gt;&lt;a href=&quot;../api/common/percentpipe&quot;&gt;percent&lt;/a&gt;&lt;/code&gt; 파이프 도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44d0b768fde4742dc1976b77eaf1b2e28afafb0a" translate="yes" xml:space="preserve">
          <source>Angular also has a &lt;code&gt;percent&lt;/code&gt; pipe, which formats a number as a local percentage as shown in the third example.</source>
          <target state="translated">Angular는 또한 &lt;code&gt;percent&lt;/code&gt; 파이프를 가지고 있는데,이 파이프는 세 번째 예제와 같이 숫자를 로컬 백분율로 형식화합니다.</target>
        </trans-unit>
        <trans-unit id="e7acf3cac93b6dc1dff702f72a776e3bad75bb0b" translate="yes" xml:space="preserve">
          <source>Angular also has an extensive &lt;a href=&quot;https://angular.io/resources&quot;&gt;network of 3rd-party tools and libraries&lt;/a&gt;.</source>
          <target state="translated">Angular는 광범위한 &lt;a href=&quot;https://angular.io/resources&quot;&gt;타사 도구 및 라이브러리 네트워크를&lt;/a&gt; 보유하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="461978cf1e142163ebf7b8be2cfa6ba767095496" translate="yes" xml:space="preserve">
          <source>Angular also has an extensive &lt;a href=&quot;https://angular.io/start/resources&quot;&gt;network of 3rd-party tools and libraries&lt;/a&gt;.</source>
          <target state="translated">Angular는 또한 광범위한 &lt;a href=&quot;https://angular.io/start/resources&quot;&gt;타사 도구 및 라이브러리 네트워크를&lt;/a&gt; 보유하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4f6f4c8cab83c598f5f92135c20c5a81d3804e3" translate="yes" xml:space="preserve">
          <source>Angular also supports workspaces with &lt;a href=&quot;file-structure#multiple-projects&quot;&gt;multiple projects&lt;/a&gt;. This type of development environment is suitable for advanced users who are developing &lt;a href=&quot;glossary#library&quot;&gt;shareable libraries&lt;/a&gt;, and for enterprises that use a &quot;monorepo&quot; development style, with a single repository and global configuration for all Angular projects.</source>
          <target state="translated">Angular는 또한 &lt;a href=&quot;file-structure#multiple-projects&quot;&gt;여러 프로젝트&lt;/a&gt; 가있는 작업 공간을 지원합니다 . 이 유형의 개발 환경은 &lt;a href=&quot;glossary#library&quot;&gt;공유 가능한 라이브러리를&lt;/a&gt; 개발하는 고급 사용자 및 모든 Angular 프로젝트에 대한 단일 저장소 및 글로벌 구성으로 &quot;모노 레포&quot;개발 스타일을 사용하는 기업에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="18ccac82f42afc30dc13eb8f7f4a5b6af31380eb" translate="yes" xml:space="preserve">
          <source>Angular and i18n</source>
          <target state="translated">각도와 i18n</target>
        </trans-unit>
        <trans-unit id="6dd49b5a09165a329e3b3706c72d3ba95738b3ba" translate="yes" xml:space="preserve">
          <source>Angular animations are based on CSS web transition functionality, so anything that can be styled or transformed in CSS can be animated the same way in Angular. Angular animations allow you to:</source>
          <target state="translated">각도 애니메이션은 CSS 웹 전환 기능을 기반으로하므로 CSS에서 스타일을 지정하거나 변형 할 수있는 모든 항목을 Angular에서 동일한 방식으로 애니메이션 할 수 있습니다. 각도 애니메이션을 통해 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a46f7dce153dad41d3155a72294e1932c658d00" translate="yes" xml:space="preserve">
          <source>Angular app-design fundamentals, as described in &lt;a href=&quot;architecture&quot;&gt;Angular Concepts&lt;/a&gt;</source>
          <target state="translated">Angular &lt;a href=&quot;architecture&quot;&gt;개념에&lt;/a&gt; 설명 된 Angular 앱 디자인 기본 사항</target>
        </trans-unit>
        <trans-unit id="8bd34f6fdaef4e5ba180dda435f076837cce8336" translate="yes" xml:space="preserve">
          <source>Angular app-design fundamentals, as described in &lt;a href=&quot;architecture&quot;&gt;Angular Concepts&lt;/a&gt;.</source>
          <target state="translated">Angular &lt;a href=&quot;architecture&quot;&gt;개념에&lt;/a&gt; 설명 된대로 Angular 앱 디자인 기본 사항 .</target>
        </trans-unit>
        <trans-unit id="fa2b46cf1fafda0f8f1b1015605c3b0e0c977cd6" translate="yes" xml:space="preserve">
          <source>Angular applications are styled with standard CSS. That means you can apply everything you know about CSS stylesheets, selectors, rules, and media queries directly to Angular applications.</source>
          <target state="translated">각도 응용 프로그램은 표준 CSS로 스타일이 지정됩니다. 즉, CSS 스타일 시트, 선택기, 규칙 및 미디어 쿼리에 대한 모든 정보를 Angular 응용 프로그램에 직접 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14d869c3fb5c7a4d91b5a670f800823baa6232f8" translate="yes" xml:space="preserve">
          <source>Angular applications must follow the same security principles as regular web applications, and must be audited as such. Angular-specific APIs that should be audited in a security review, such as the &lt;a href=&quot;security#bypass-security-apis&quot;&gt;&lt;em&gt;bypassSecurityTrust&lt;/em&gt;&lt;/a&gt; methods, are marked in the documentation as security sensitive.</source>
          <target state="translated">각도 응용 프로그램은 일반 웹 응용 프로그램과 동일한 보안 원칙을 따라야하며 감사해야합니다. &lt;a href=&quot;security#bypass-security-apis&quot;&gt;&lt;em&gt;bypassSecurityTrust&lt;/em&gt;&lt;/a&gt; 메소드 와 같이 보안 검토에서 감사해야하는 각도 별 API 는 문서에서 보안에 민감한 것으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a1bf3aeaee18f4e10d8c47a1a0151f85f3df9106" translate="yes" xml:space="preserve">
          <source>Angular applications, and specifically applications that relied on the JIT compiler, used to require a polyfill for the &lt;a href=&quot;https://github.com/rbuckton/reflect-metadata&quot;&gt;reflect-metadata&lt;/a&gt; APIs.</source>
          <target state="translated">Angular 응용 프로그램, 특히 JIT 컴파일러를 사용하는 응용 프로그램은 &lt;a href=&quot;https://github.com/rbuckton/reflect-metadata&quot;&gt;reflect-metadata&lt;/a&gt; API에 대한 polyfill이 필요했습니다 .</target>
        </trans-unit>
        <trans-unit id="91733de9ca0b6019e9d774051ac122f55526d61d" translate="yes" xml:space="preserve">
          <source>Angular applications, as single-page applications, are in a prime position to benefit from the advantages of service workers. Starting with version 5.0.0, Angular ships with a service worker implementation. Angular developers can take advantage of this service worker and benefit from the increased reliability and performance it provides, without needing to code against low-level APIs.</source>
          <target state="translated">단일 페이지 응용 프로그램 인 각도 응용 프로그램은 서비스 작업자의 이점을 활용할 수있는 최고의 위치에 있습니다. 버전 5.0.0부터 Angular는 서비스 워커 구현과 함께 제공됩니다. 앵귤러 개발자는이 서비스 워커를 활용하여 낮은 수준의 API에 대해 코딩 할 필요없이 향상된 안정성과 성능을 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30f0ca07ec9a65e367f6da8100c80d678801905c" translate="yes" xml:space="preserve">
          <source>Angular applies interceptors in the order that you provide them. If you provide interceptors &lt;em&gt;A&lt;/em&gt;, then &lt;em&gt;B&lt;/em&gt;, then &lt;em&gt;C&lt;/em&gt;, requests flow in &lt;em&gt;A-&amp;gt;B-&amp;gt;C&lt;/em&gt; and responses flow out &lt;em&gt;C-&amp;gt;B-&amp;gt;A&lt;/em&gt;.</source>
          <target state="translated">Angular는 제공 한 순서대로 인터셉터를 적용합니다. 인터셉터 &lt;em&gt;A&lt;/em&gt; , &lt;em&gt;B&lt;/em&gt; , &lt;em&gt;C를 제공&lt;/em&gt; 하면 요청은 &lt;em&gt;A-&amp;gt; B-&amp;gt; C로&lt;/em&gt; , 응답은 &lt;em&gt;C-&amp;gt; B-&amp;gt; A로&lt;/em&gt; 흘러 갑니다.</target>
        </trans-unit>
        <trans-unit id="6a6de042c4c8b613bc14b1004499391dfb5f5947" translate="yes" xml:space="preserve">
          <source>Angular applies interceptors in the order that you provide them. If you provide interceptors &lt;em&gt;A&lt;/em&gt;, then &lt;em&gt;B&lt;/em&gt;, then &lt;em&gt;C&lt;/em&gt;, requests will flow in &lt;em&gt;A-&amp;gt;B-&amp;gt;C&lt;/em&gt; and responses will flow out &lt;em&gt;C-&amp;gt;B-&amp;gt;A&lt;/em&gt;.</source>
          <target state="translated">Angular는 제공 한 순서대로 인터셉터를 적용합니다. 인터셉터 &lt;em&gt;A&lt;/em&gt; , &lt;em&gt;B&lt;/em&gt; , &lt;em&gt;C를 제공&lt;/em&gt; 하면 요청은 &lt;em&gt;A-&amp;gt; B-&amp;gt; C로&lt;/em&gt; 흐르고 응답은 &lt;em&gt;C-&amp;gt; B-&amp;gt; A로&lt;/em&gt; 흐릅니다 .</target>
        </trans-unit>
        <trans-unit id="d48a23ccd7bfb25f976351b26c70f523a8ecb5d3" translate="yes" xml:space="preserve">
          <source>Angular applies the class &lt;code&gt;special&lt;/code&gt; to the &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element so that you can use &lt;code&gt;special&lt;/code&gt; to apply CSS styles.</source>
          <target state="translated">Angular는 &lt;code&gt;special&lt;/code&gt; 클래스 를 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 요소 에 적용 하므로 &lt;code&gt;special&lt;/code&gt; 을 사용 하여 CSS 스타일을 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="926bf2f3242ed68256b3bd4a48a61bdbc87faa0e" translate="yes" xml:space="preserve">
          <source>Angular apps are modular and Angular has its own modularity system called &lt;em&gt;NgModules&lt;/em&gt;. NgModules are containers for a cohesive block of code dedicated to an application domain, a workflow, or a closely related set of capabilities. They can contain components, service providers, and other code files whose scope is defined by the containing NgModule. They can import functionality that is exported from other NgModules, and export selected functionality for use by other NgModules.</source>
          <target state="translated">Angular 앱은 모듈 &lt;em&gt;식이며&lt;/em&gt; Angular에는 &lt;em&gt;NgModules&lt;/em&gt; 라는 자체 모듈 식 시스템이 &lt;em&gt;있습니다&lt;/em&gt; . NgModules는 응용 프로그램 도메인, 워크 플로 또는 밀접하게 관련된 기능 집합 전용의 응집력있는 코드 블록을위한 컨테이너입니다. 여기에는 컴포넌트, 서비스 제공자 및 포함하는 NgModule에 의해 범위가 정의 된 기타 코드 파일이 포함될 수 있습니다. 다른 NgModules에서 내 보낸 기능을 가져오고 다른 NgModules에서 사용하기 위해 선택한 기능을 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25fa7e10b2ea8373e96b925201550beca498120d" translate="yes" xml:space="preserve">
          <source>Angular apps are perfect candidates for serving with a simple static HTML server. You don't need a server-side engine to dynamically compose application pages because Angular does that on the client-side.</source>
          <target state="translated">Angular 앱은 간단한 정적 HTML 서버를 제공하기에 완벽한 후보입니다. Angular는 클라이언트 쪽에서 응용 프로그램 페이지를 동적으로 작성하기 위해 서버 쪽 엔진이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89a4897f290e40a2133713a97fbe6e813fdda23d" translate="yes" xml:space="preserve">
          <source>Angular asks the injector for the service associated with &lt;code&gt;LoggerService&lt;/code&gt; and assigns the returned value to the &lt;code&gt;logger&lt;/code&gt; parameter.</source>
          <target state="translated">Angular는 인젝터에게 &lt;code&gt;LoggerService&lt;/code&gt; 와 연관된 서비스를 요청하고 리턴 된 값을 &lt;code&gt;logger&lt;/code&gt; 매개 변수에 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="467553e1fe6dc736a362530881af11583c4c3cac" translate="yes" xml:space="preserve">
          <source>Angular assigns a template variable a value based on where you declare the variable:</source>
          <target state="translated">Angular는 변수를 선언하는 위치에 따라 템플릿 변수에 값을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="34736d096c8d01abb937a1a803b97d49650c45e4" translate="yes" xml:space="preserve">
          <source>Angular automatically adds components in the module's &lt;code&gt;bootstrap&lt;/code&gt; and route definitions into the &lt;code&gt;entryComponents&lt;/code&gt; list.</source>
          <target state="translated">Angular는 모듈의 &lt;code&gt;bootstrap&lt;/code&gt; 및 경로 정의에 컴포넌트를 자동으로 &lt;code&gt;entryComponents&lt;/code&gt; 목록 에 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="f64e43a20cf90e560e0797b938ab839d7501e2c4" translate="yes" xml:space="preserve">
          <source>Angular automatically adds components in the module's bootstrap and route definitions into the &lt;code&gt;entryComponents&lt;/code&gt; list. Use this option to add components that are bootstrapped using one of the imperative techniques, such as &lt;code&gt;ViewContainerRef.createComponent()&lt;/code&gt;.</source>
          <target state="translated">Angular는 모듈의 부트 스트랩 및 경로 정의에 컴포넌트를 자동으로 &lt;code&gt;entryComponents&lt;/code&gt; 목록 에 추가 합니다. &lt;code&gt;ViewContainerRef.createComponent()&lt;/code&gt; 와 같은 필수 기술 중 하나를 사용하여 부트 스트랩 된 구성 요소를 추가하려면이 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0629ce337235f8f877e6fa641ca67b726d78f938" translate="yes" xml:space="preserve">
          <source>Angular automatically checks host property bindings during change detection. If a binding changes, Angular updates the directive's host element.</source>
          <target state="translated">Angular는 변경 감지 중에 호스트 속성 바인딩을 자동으로 확인합니다. 바인딩이 변경되면 Angular는 지시문의 호스트 요소를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="8b9a86a14f14da58711979c6e06ad0d7a208e6d2" translate="yes" xml:space="preserve">
          <source>Angular automatically expands the shorthand syntax as it compiles the template. The context for each embedded view is logically merged to the current component context according to its lexical position.</source>
          <target state="translated">Angular는 템플릿을 컴파일 할 때 약식 구문을 자동으로 확장합니다. 각 임베디드 뷰의 컨텍스트는 어휘 위치에 따라 현재 컴포넌트 컨텍스트에 논리적으로 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="93f51725a20586ce3e33f655c1e7ce3a5377f16e" translate="yes" xml:space="preserve">
          <source>Angular automatically mirrors many control properties onto the form control element as CSS classes. You can use these classes to style form control elements according to the state of the form. The following classes are currently supported.</source>
          <target state="translated">Angular는 CSS 클래스로 양식 컨트롤 요소에 많은 컨트롤 속성을 자동으로 미러링합니다. 이러한 클래스를 사용하여 양식 상태에 따라 양식 제어 요소의 스타일을 지정할 수 있습니다. 현재 지원되는 클래스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66b49eb10d70820437d8d869bc39bde44099684f" translate="yes" xml:space="preserve">
          <source>Angular automatically pulls the value of the &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;myHero&lt;/code&gt; properties from the component and inserts those values into the browser. Angular updates the display when these properties change.</source>
          <target state="translated">Angular는 자동으로 구성 요소에서 &lt;code&gt;title&lt;/code&gt; 및 &lt;code&gt;myHero&lt;/code&gt; 속성 값을 가져 와서 해당 값을 브라우저에 삽입합니다. 이러한 속성이 변경되면 각도가 표시를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="ff00d645a7fcd89b83ee39d6fc1b51274985e3e6" translate="yes" xml:space="preserve">
          <source>Angular automatically updates input properties during change detection. The &lt;code&gt;inputs&lt;/code&gt; property defines a set of &lt;code&gt;directiveProperty&lt;/code&gt; to &lt;code&gt;bindingProperty&lt;/code&gt; configuration:</source>
          <target state="translated">Angular는 변경 감지 중에 입력 속성을 자동으로 업데이트합니다. &lt;code&gt;inputs&lt;/code&gt; 속성의 집합을 정의 &lt;code&gt;directiveProperty&lt;/code&gt; 에 &lt;code&gt;bindingProperty&lt;/code&gt; 의 구성 :</target>
        </trans-unit>
        <trans-unit id="2fdcfb49d5c09fbaa84f9aee2d20c4bb5eaf5efe" translate="yes" xml:space="preserve">
          <source>Angular by default uses &lt;code&gt;en-US&lt;/code&gt; (English in the United States) as your app's source locale.</source>
          <target state="translated">Angular는 기본적으로 앱의 소스 로캘로 &lt;code&gt;en-US&lt;/code&gt; ( 미국의 경우 영어)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4fb8d9e96c7ac6343272dadc9bead965bdb5f2ef" translate="yes" xml:space="preserve">
          <source>Angular calls &lt;code&gt;ngOnInit()&lt;/code&gt; shortly after creating a component.</source>
          <target state="translated">각도 는 구성 요소를 만든 직후 &lt;code&gt;ngOnInit()&lt;/code&gt; 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="799636d3f55ab95abfe31d9616161e11148256ec" translate="yes" xml:space="preserve">
          <source>Angular calls both &lt;em&gt;AfterContent&lt;/em&gt; hooks before calling either of the &lt;em&gt;AfterView&lt;/em&gt; hooks. Angular completes composition of the projected content &lt;em&gt;before&lt;/em&gt; finishing the composition of this component's view. There is a small window between the &lt;code&gt;AfterContent...&lt;/code&gt; and &lt;code&gt;AfterView...&lt;/code&gt; hooks that allows you to modify the host view.</source>
          <target state="translated">각도 전화에 모두 &lt;em&gt;afterContent를의&lt;/em&gt; 의 중 하나를 호출하기 전에 후크 &lt;em&gt;AfterView의&lt;/em&gt; 후크. Angular 는이 컴포넌트 뷰의 구성을 완료 &lt;em&gt;하기 전에&lt;/em&gt; 투영 된 콘텐츠 의 구성을 완료합니다. &lt;code&gt;AfterContent...&lt;/code&gt; 와 &lt;code&gt;AfterView...&lt;/code&gt; 후크 사이 에는 호스트보기를 수정할 수 있는 작은 창이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0761730ce747644c7286543b08d9331ae7b0e5b5" translate="yes" xml:space="preserve">
          <source>Angular calls hook methods for &lt;em&gt;directives&lt;/em&gt; as well as components.</source>
          <target state="translated">각도 호출은 &lt;em&gt;지시문&lt;/em&gt; 및 구성 요소에 대한 후크 메소드입니다 .</target>
        </trans-unit>
        <trans-unit id="700fb4f4fabe764d32bfd76c4bdde2ed1a283939" translate="yes" xml:space="preserve">
          <source>Angular calls its &lt;code&gt;ngOnChanges()&lt;/code&gt; method whenever it detects changes to &lt;strong&gt;&lt;em&gt;input properties&lt;/em&gt;&lt;/strong&gt; of the component (or directive). This example monitors the &lt;code&gt;&lt;a href=&quot;../api/core/onchanges&quot;&gt;OnChanges&lt;/a&gt;&lt;/code&gt; hook.</source>
          <target state="translated">Angular 는 구성 요소 (또는 지시문)의 &lt;strong&gt;&lt;em&gt;입력 속성&lt;/em&gt;&lt;/strong&gt; 변경을 감지 할 때마다 &lt;code&gt;ngOnChanges()&lt;/code&gt; 메서드를 호출합니다 . 이 예는 &lt;code&gt;&lt;a href=&quot;../api/core/onchanges&quot;&gt;OnChanges&lt;/a&gt;&lt;/code&gt; 후크 를 모니터링합니다 .&lt;strong&gt;&lt;em&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4118fdcd8c7c3292cb71b321cb427d4c834148fd" translate="yes" xml:space="preserve">
          <source>Angular calls the &lt;code&gt;ngOnChanges()&lt;/code&gt; method of a component or directive whenever it detects changes to the &lt;strong&gt;&lt;em&gt;input properties&lt;/em&gt;&lt;/strong&gt;. The &lt;em&gt;onChanges&lt;/em&gt; example demonstrates this by monitoring the &lt;code&gt;&lt;a href=&quot;../api/core/onchanges&quot;&gt;OnChanges&lt;/a&gt;()&lt;/code&gt; hook.</source>
          <target state="translated">Angular 는 &lt;strong&gt;&lt;em&gt;입력 속성의&lt;/em&gt;&lt;/strong&gt; 변경 사항을 감지 할 때마다 구성 요소 또는 지시문 의 &lt;code&gt;ngOnChanges()&lt;/code&gt; 메서드를 호출합니다 . &lt;em&gt;onChanges의&lt;/em&gt; 예는 모니터링이 보여 &lt;code&gt;&lt;a href=&quot;../api/core/onchanges&quot;&gt;OnChanges&lt;/a&gt;()&lt;/code&gt; () 후크.&lt;strong&gt;&lt;em&gt;&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7fba1c4e305809dca3c5497ed6c4e8bdddcee9d5" translate="yes" xml:space="preserve">
          <source>Angular calls these hook methods in the following order:</source>
          <target state="translated">Angular는 이러한 순서를 다음 순서로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="2eb6be30b85620d64c1287fc12627576cab0e3cb" translate="yes" xml:space="preserve">
          <source>Angular can launch with multiple bootstrap components, each with its own location in the host web page.</source>
          <target state="translated">Angular는 호스트 웹 페이지에서 자체 위치가있는 여러 부트 스트랩 구성 요소로 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8d9d853fd628beed82fbc871f08b75361246094" translate="yes" xml:space="preserve">
          <source>Angular can't know at compile time what kind of HTML element the &lt;code&gt;nativeElement&lt;/code&gt; is or if it even is an HTML element. The app might be running on a &lt;em&gt;non-browser platform&lt;/em&gt;, such as the server or a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;Web Worker&lt;/a&gt;, where the element may have a diminished API or not exist at all.</source>
          <target state="translated">Angular는 컴파일 타임에 &lt;code&gt;nativeElement&lt;/code&gt; 가 어떤 종류의 HTML 요소인지 또는 심지어 HTML 요소인지 알 수 없습니다 . 앱이 서버 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;웹 워커 (Web Worker)&lt;/a&gt; 와 같은 &lt;em&gt;브라우저&lt;/em&gt; 가 &lt;em&gt;아닌 플랫폼&lt;/em&gt; 에서 실행 중일 수 있으며 ,이 경우 요소에 API가 없거나 전혀 존재하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="832d4b42c678434cf266550b2ed8c8f21564c3ee" translate="yes" xml:space="preserve">
          <source>Angular coding style guide</source>
          <target state="translated">각도 코딩 스타일 가이드</target>
        </trans-unit>
        <trans-unit id="36d17ffea363e96f44fadf63bb3a1bdbe014532f" translate="yes" xml:space="preserve">
          <source>Angular comes with a stock of pipes such as &lt;code&gt;&lt;a href=&quot;../api/common/datepipe&quot;&gt;DatePipe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/common/uppercasepipe&quot;&gt;UpperCasePipe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/common/lowercasepipe&quot;&gt;LowerCasePipe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/common/currencypipe&quot;&gt;CurrencyPipe&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../api/common/percentpipe&quot;&gt;PercentPipe&lt;/a&gt;&lt;/code&gt;. They are all available for use in any template.</source>
          <target state="translated">Angular에는 &lt;code&gt;&lt;a href=&quot;../api/common/datepipe&quot;&gt;DatePipe&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/common/uppercasepipe&quot;&gt;UpperCasePipe&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/common/lowercasepipe&quot;&gt;LowerCasePipe&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/common/currencypipe&quot;&gt;CurrencyPipe&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/common/percentpipe&quot;&gt;PercentPipe&lt;/a&gt;&lt;/code&gt; 와 같은 파이프가 제공됩니다 . 모든 템플릿에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a907878ebd06df52b7177c708b1d8e885c2837c" translate="yes" xml:space="preserve">
          <source>Angular comes with its own API for loading components dynamically.</source>
          <target state="translated">Angular에는 구성 요소를 동적으로로드하기위한 자체 API가 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd56aedc09d6c5dc3108daa71ce3e03750969451" translate="yes" xml:space="preserve">
          <source>Angular compatibility compiler. If you build your app using &lt;a href=&quot;glossary#ivy&quot;&gt;Ivy&lt;/a&gt;, but it depends on libraries that have not been compiled with Ivy, the CLI uses &lt;code&gt;ngcc&lt;/code&gt; to automatically update the dependent libraries to use Ivy.</source>
          <target state="translated">각도 호환성 컴파일러. &lt;a href=&quot;glossary#ivy&quot;&gt;Ivy를&lt;/a&gt; 사용하여 앱을 빌드 하지만 Ivy 로 컴파일되지 않은 라이브러리에 의존하는 경우 CLI는 &lt;code&gt;ngcc&lt;/code&gt; 를 사용하여 Ivy를 사용하도록 종속 라이브러리를 자동으로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="d2363ce386377b1af5430cd7665d83300366b428" translate="yes" xml:space="preserve">
          <source>Angular compiler options</source>
          <target state="translated">각도 컴파일러 옵션</target>
        </trans-unit>
        <trans-unit id="15a73b4d8e7403ebf3810f68763eaa4ff736a997" translate="yes" xml:space="preserve">
          <source>Angular components</source>
          <target state="translated">각도 구성 요소</target>
        </trans-unit>
        <trans-unit id="ffb4bdd5d65587e2e6c9c3c9d1f3cb6da8838095" translate="yes" xml:space="preserve">
          <source>Angular components always execute inside Angular framework codebase regardless of where they are instantiated.</source>
          <target state="translated">Angular 구성 요소는 인스턴스화되는 위치에 관계없이 항상 Angular 프레임 워크 코드베이스 내에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="233d6374ce6c4c863b26cd0f6a1152e33095938e" translate="yes" xml:space="preserve">
          <source>Angular components always execute inside the Angular framework codebase regardless of where they are instantiated.</source>
          <target state="translated">Angular 구성 요소는 인스턴스화되는 위치에 관계없이 항상 Angular 프레임 워크 코드베이스 내에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a938ce5b6c5838ce8346e5bb8644d6b61ec091d8" translate="yes" xml:space="preserve">
          <source>Angular components are a subset of directives, always associated with a template. Unlike other directives, only one component can be instantiated for a given element in a template.</source>
          <target state="translated">각도 구성 요소는 항상 템플릿과 연결된 지시문의 하위 집합입니다. 다른 지시문과 달리 템플릿의 지정된 요소에 대해 하나의 구성 요소 만 인스턴스화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4225f862d6288eb7075b556d3706e253ca5d1d9" translate="yes" xml:space="preserve">
          <source>Angular components are a subset of directives, always associated with a template. Unlike other directives, only one component can be instantiated per an element in a template.</source>
          <target state="translated">각도 구성 요소는 지시문의 서브 세트이며 항상 템플리트와 연관됩니다. 다른 지시문과 달리 템플릿의 요소 당 하나의 구성 요소 만 인스턴스화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4d73c4846ec246a55f1aa13c811b021c01194e2" translate="yes" xml:space="preserve">
          <source>Angular components that support content projection make use of an &lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt; tag within them. Here's an example of such a component:</source>
          <target state="translated">컨텐츠 투영을 지원하는 각도 구성 요소는 그 안에 &lt;code&gt;&amp;lt;ng-content&amp;gt;&lt;/code&gt; 태그를 사용합니다. 이러한 구성 요소의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="060321b0fff1405ad06cb58d9ee155a149fcc9fa" translate="yes" xml:space="preserve">
          <source>Angular concepts</source>
          <target state="translated">Angular 개념</target>
        </trans-unit>
        <trans-unit id="1071c499d51beceec87025fac82a393ee1e49214" translate="yes" xml:space="preserve">
          <source>Angular consumed the &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; content during its actual rendering and replaced the &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; with a diagnostic comment.</source>
          <target state="translated">각도는 소비 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 실제 렌더링시 내용과 교체 된 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 진단 코멘트와 함께.</target>
        </trans-unit>
        <trans-unit id="8636812be488a9e06f44b489bdc2a9078adde645" translate="yes" xml:space="preserve">
          <source>Angular creates &lt;code&gt;ElementInjector&lt;/code&gt;s implicitly for each DOM element.</source>
          <target state="translated">Angular 는 각 DOM 요소에 대해 &lt;code&gt;ElementInjector&lt;/code&gt; 를 암시 적으로 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="c0741d3945dd49502e54a223724b94ed7a5fa8fc" translate="yes" xml:space="preserve">
          <source>Angular creates a lazy loaded module with its own injector, a child of the root injector. &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; causes Angular to look for a &lt;code&gt;GreetingModule&lt;/code&gt; in the parent injector, which this time is the root injector. Of course it finds the instance imported by the root &lt;code&gt;AppModule&lt;/code&gt;. Now &lt;code&gt;parentModule&lt;/code&gt; exists and the constructor throws the error.</source>
          <target state="translated">Angular는 자체 인젝터, 루트 인젝터의 자식으로 지연로드 모듈을 만듭니다. &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; 는 Angular가 부모 인젝터에서 &lt;code&gt;GreetingModule&lt;/code&gt; 을 찾도록합니다. 이번에는 루트 인젝터입니다. 물론 루트 &lt;code&gt;AppModule&lt;/code&gt; 에서 가져온 인스턴스를 찾습니다 . 이제 &lt;code&gt;parentModule&lt;/code&gt; 이 존재하고 생성자가 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="977c8f330d7f7406517c33d255bec85d1010c0fb" translate="yes" xml:space="preserve">
          <source>Angular creates and renders components along with their children, checks when their data-bound properties change, and destroys them before removing them from the DOM.</source>
          <target state="translated">Angular는 자식과 함께 구성 요소를 생성 및 렌더링하고, 데이터 바인딩 된 속성이 변경되는시기를 확인한 후 DOM에서 제거하기 전에 해당 구성 요소를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="ba24eb58c283a7912305a525ff29bc67536b0f26" translate="yes" xml:space="preserve">
          <source>Angular creates the component with its &lt;em&gt;own&lt;/em&gt; injector, which is a &lt;em&gt;child&lt;/em&gt; of the fixture injector. It registers the component's providers (the &lt;code&gt;HeroDetailService&lt;/code&gt; in this case) with the child injector.</source>
          <target state="translated">Angular 는 픽스처 인젝터 의 &lt;em&gt;자식&lt;/em&gt; 인 &lt;em&gt;자체&lt;/em&gt; 인젝터로 구성 요소를 만듭니다 . 구성 요소 공급자 ( 이 경우 &lt;code&gt;HeroDetailService&lt;/code&gt; )를 자식 인젝터에 등록합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8cd6666fc9fd18813b4f61de2cc4a4167a9bcabc" translate="yes" xml:space="preserve">
          <source>Angular creates, updates, and destroys components as the user moves through the application. Your app can take action at each moment in this lifecycle through optional &lt;a href=&quot;lifecycle-hooks&quot;&gt;lifecycle hooks&lt;/a&gt;, like &lt;code&gt;ngOnInit()&lt;/code&gt;.</source>
          <target state="translated">Angular는 사용자가 응용 프로그램을 이동할 때 구성 요소를 생성, 업데이트 및 삭제합니다. 앱은 &lt;code&gt;ngOnInit()&lt;/code&gt; 와 같은 선택적 &lt;a href=&quot;lifecycle-hooks&quot;&gt;수명주기 후크&lt;/a&gt; 를 통해이 수명주기의 각 순간에 조치를 취할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1491a873fca02f484086bb4c25c113973485dbc4" translate="yes" xml:space="preserve">
          <source>Angular defines an &lt;code&gt;&lt;a href=&quot;../api/core/elementref&quot;&gt;ElementRef&lt;/a&gt;&lt;/code&gt; class to wrap render-specific native UI elements. In most cases, this allows you to use Angular templates and data binding to access DOM elements without reference to the native element.</source>
          <target state="translated">Angular는 렌더링 별 네이티브 UI 요소를 래핑하기 위해 &lt;code&gt;&lt;a href=&quot;../api/core/elementref&quot;&gt;ElementRef&lt;/a&gt;&lt;/code&gt; 클래스를 정의합니다 . 대부분의 경우 기본 요소를 참조하지 않고 Angular 템플릿 및 데이터 바인딩을 사용하여 DOM 요소에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29b75e3aa5bf733082f6f2be9dc6166f8724c4b5" translate="yes" xml:space="preserve">
          <source>Angular defines decorators that attach metadata to classes or properties so that it knows what those classes or properties mean and how they should work.</source>
          <target state="translated">Angular는 클래스 또는 속성에 메타 데이터를 첨부하는 데코레이터를 정의하여 해당 클래스 또는 속성의 의미와 작동 방식을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54a4705b9139dd29bd0480b9f3c8657f03607bed" translate="yes" xml:space="preserve">
          <source>Angular defines default builders for use with specific CLI commands, or with the general &lt;code&gt;ng run&lt;/code&gt; command. The JSON schemas that the define the options and defaults for each of these default builders are collected in the &lt;a href=&quot;https://github.com/angular/angular-cli/blob/8.0.x/packages/angular/cli/lib/config/schema.json&quot;&gt;&lt;code&gt;@angular-devkit/build-angular&lt;/code&gt;&lt;/a&gt; package. The schemas configure options for the following builders.</source>
          <target state="translated">Angular는 특정 CLI 명령 또는 일반 &lt;code&gt;ng run&lt;/code&gt; 명령 과 함께 사용할 기본 빌더를 정의합니다 . 이러한 각 기본 빌더에 대한 옵션 및 기본값을 정의하는 JSON 스키마는 &lt;a href=&quot;https://github.com/angular/angular-cli/blob/8.0.x/packages/angular/cli/lib/config/schema.json&quot;&gt; &lt;code&gt;@angular-devkit/build-angular&lt;/code&gt; &lt;/a&gt; 패키지에 수집 됩니다. 스키마는 다음 빌더의 옵션을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="dee1921a916c378e7946c3b9eeea976785c29693" translate="yes" xml:space="preserve">
          <source>Angular defines the following security contexts:</source>
          <target state="translated">Angular는 다음 보안 컨텍스트를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="6fb8bcc74fbecb42b212d7bf6efe735e1d1e63cd" translate="yes" xml:space="preserve">
          <source>Angular defines various pipes, such as the &lt;a href=&quot;../api/common/datepipe&quot;&gt;date&lt;/a&gt; pipe and &lt;a href=&quot;../api/common/currencypipe&quot;&gt;currency&lt;/a&gt; pipe; for a complete list, see the &lt;a href=&quot;../api?type=pipe&quot;&gt;Pipes API list&lt;/a&gt;. You can also define new pipes.</source>
          <target state="translated">각도는 &lt;a href=&quot;../api/common/datepipe&quot;&gt;날짜&lt;/a&gt; 파이프 및 &lt;a href=&quot;../api/common/currencypipe&quot;&gt;통화&lt;/a&gt; 파이프 와 같은 다양한 파이프를 정의합니다 . 전체 목록은 &lt;a href=&quot;../api?type=pipe&quot;&gt;Pipes API 목록을&lt;/a&gt; 참조하십시오 . 새 파이프를 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d17ca00c0eee29556940c4f3d3c141a911271225" translate="yes" xml:space="preserve">
          <source>Angular defines various pipes, such as the &lt;a href=&quot;../api/common/datepipe&quot;&gt;date&lt;/a&gt; pipe and &lt;a href=&quot;../api/common/currencypipe&quot;&gt;currency&lt;/a&gt; pipe; for a complete list, see the &lt;a href=&quot;api?type=pipe&quot;&gt;Pipes API list&lt;/a&gt;. You can also define new pipes.</source>
          <target state="translated">Angular는 &lt;a href=&quot;../api/common/datepipe&quot;&gt;날짜&lt;/a&gt; 파이프 및 &lt;a href=&quot;../api/common/currencypipe&quot;&gt;통화&lt;/a&gt; 파이프 와 같은 다양한 파이프를 정의합니다 . 전체 목록은 &lt;a href=&quot;api?type=pipe&quot;&gt;Pipes API 목록을&lt;/a&gt; 참조하십시오 . 새 파이프를 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="36fd385bfb0f2bc723f93bd55ac70bf1b8515f00" translate="yes" xml:space="preserve">
          <source>Angular dependency injection is easiest when the provider token is a class that is also the type of the returned dependency object, or service.</source>
          <target state="translated">제공자 종속성이 리턴 된 종속성 오브젝트 또는 서비스의 유형 인 클래스 인 경우 각도 종속성 삽입이 가장 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="354f00bb969990f37d0cfc82991b44682a87aec0" translate="yes" xml:space="preserve">
          <source>Angular detects each change and immediately runs the pipe. This is fine for primitive input values. However, if you change something &lt;em&gt;inside&lt;/em&gt; a composite object (such as the month of a date, an element of an array, or an object property), you need to understand how change detection works, and how to use an &lt;code&gt;impure&lt;/code&gt; pipe.</source>
          <target state="translated">Angular는 각 변경 사항을 감지하고 즉시 파이프를 실행합니다. 이것은 기본 입력 값에 적합합니다. 그러나 복합 객체 &lt;em&gt;내부&lt;/em&gt; 에서 무언가를 변경하는 경우 (예 : 날짜의 월, 배열 요소 또는 객체 속성) 변경 감지 작동 방식과 &lt;code&gt;impure&lt;/code&gt; 파이프 사용 방법을 이해해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2fdc7ee4e969732e2733a769bd9625a839effc81" translate="yes" xml:space="preserve">
          <source>Angular developers may encounter a &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot;&gt; &lt;i&gt;cross-origin resource sharing&lt;/i&gt;&lt;/a&gt; error when making a service request (typically a data service request) to a server other than the application's own host server. Browsers forbid such requests unless the server permits them explicitly.</source>
          <target state="translated">응용 프로그램 자체의 호스트 서버 이외의 서버에 서비스 요청 (일반적으로 데이터 서비스 요청)을 수행 할 때 각도 개발자가 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot;&gt;&lt;i&gt;교차 출처 리소스 공유&lt;/i&gt;&lt;/a&gt; 오류 가 발생할 수 있습니다 . 서버가 명시 적으로 허용하지 않는 한 브라우저는 이러한 요청을 금지합니다. &lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="33ead61c5ae99389962924106e86b6fa486483dc" translate="yes" xml:space="preserve">
          <source>Angular did. Angular automatically creates and attaches an &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; directive to the &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">앵귤러 Angular는 &lt;code&gt;&lt;a href=&quot;../api/forms/ngform&quot;&gt;NgForm&lt;/a&gt;&lt;/code&gt; 지시문을 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 태그에 자동으로 만들어 첨부합니다 .</target>
        </trans-unit>
        <trans-unit id="0c8cd873ef07f78a6133e0a8205b20af3eb32885" translate="yes" xml:space="preserve">
          <source>Angular distinguishes components from services to increase modularity and reusability. By separating a component's view-related functionality from other kinds of processing, you can make your component classes lean and efficient.</source>
          <target state="translated">Angular는 컴포넌트와 서비스를 구별하여 모듈 성과 재사용 성을 높입니다. 구성 요소의 뷰 관련 기능을 다른 종류의 처리와 분리하여 구성 요소 클래스를보다 효율적이고 효율적으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ef98a05d3c9d89272386206620e0b855fdc66c0" translate="yes" xml:space="preserve">
          <source>Angular doc generation copies these image folders to the &lt;em&gt;runtime&lt;/em&gt; location, &lt;code&gt;generated/images&lt;/code&gt;. Set the image &lt;code&gt;src&lt;/code&gt; attribute to begin in &lt;em&gt;that&lt;/em&gt; directory.</source>
          <target state="translated">각도 문서 생성은 이러한 이미지 폴더를 &lt;code&gt;generated/images&lt;/code&gt; &lt;em&gt;런타임&lt;/em&gt; 위치 로 복사합니다 . &lt;em&gt;해당&lt;/em&gt; 디렉토리 에서 시작 하도록 이미지 &lt;code&gt;src&lt;/code&gt; 속성을 설정하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4527482607342ce8ca88ecd6e7dda8e4473c14f4" translate="yes" xml:space="preserve">
          <source>Angular documentation style guide</source>
          <target state="translated">Angular 문서 스타일 가이드</target>
        </trans-unit>
        <trans-unit id="9731c83bf305f628189c25e13177875fa54b80aa" translate="yes" xml:space="preserve">
          <source>Angular does not allow HTML with &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags, neither with &lt;a href=&quot;interpolation&quot;&gt;interpolation&lt;/a&gt; nor property binding, which prevents the JavaScript from running.</source>
          <target state="translated">Angular는 &lt;a href=&quot;interpolation&quot;&gt;보간&lt;/a&gt; 이나 속성 바인딩이 없는 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그가있는 HTML을 허용하지 않으므로 JavaScript가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05d4d08bb1ab2fe726e25cd17ea946e354b440dc" translate="yes" xml:space="preserve">
          <source>Angular does something similar with the &lt;code&gt;&lt;a href=&quot;../api/common/document&quot;&gt;DOCUMENT&lt;/a&gt;&lt;/code&gt; token so you can inject the browser's &lt;code&gt;&lt;a href=&quot;../api/platform-server/platformconfig#document&quot;&gt;document&lt;/a&gt;&lt;/code&gt; object (or an abstraction of it, depending upon the platform in which the application runs).</source>
          <target state="translated">Angular는 &lt;code&gt;&lt;a href=&quot;../api/common/document&quot;&gt;DOCUMENT&lt;/a&gt;&lt;/code&gt; 토큰 과 비슷한 작업을 수행 하므로 브라우저의 &lt;code&gt;&lt;a href=&quot;../api/platform-server/platformconfig#document&quot;&gt;document&lt;/a&gt;&lt;/code&gt; 객체 (또는 응용 프로그램이 실행되는 플랫폼에 따라 추상화)를 삽입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c44939aad5d12f8f29f0ad08371766a5ea5b53c8" translate="yes" xml:space="preserve">
          <source>Angular does something similar with the &lt;code&gt;&lt;a href=&quot;../api/common/document&quot;&gt;DOCUMENT&lt;/a&gt;&lt;/code&gt; token so you can inject the browser's &lt;code&gt;document&lt;/code&gt; object (or an abstraction of it, depending upon the platform in which the application runs).</source>
          <target state="translated">Angular는 &lt;code&gt;&lt;a href=&quot;../api/common/document&quot;&gt;DOCUMENT&lt;/a&gt;&lt;/code&gt; 토큰 과 유사한 작업을 수행 하므로 브라우저의 &lt;code&gt;document&lt;/code&gt; 객체 (또는 애플리케이션이 실행되는 플랫폼에 따라 추상화)를 삽입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="316fdcfddbfe253f5be7d7577a1028ffa824c548" translate="yes" xml:space="preserve">
          <source>Angular doesn't &lt;em&gt;enforce&lt;/em&gt; these principles. Angular does help you &lt;em&gt;follow&lt;/em&gt; these principles by making it easy to factor your application logic into services and make those services available to components through &lt;em&gt;dependency injection&lt;/em&gt;.</source>
          <target state="translated">Angular는 이러한 원칙을 &lt;em&gt;시행&lt;/em&gt; 하지 않습니다 . Angular는 응용 프로그램 논리를 서비스로 쉽게 인수 화하고 &lt;em&gt;종속성 주입을&lt;/em&gt; 통해 해당 서비스를 구성 요소에서 사용할 수 있도록하여 이러한 원칙 을 &lt;em&gt;따르는&lt;/em&gt; 데 도움이 됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bec27d0e4374bf5d0fe0b39083d667524fda6667" translate="yes" xml:space="preserve">
          <source>Angular doesn't have a &lt;code&gt;FilterPipe&lt;/code&gt; or an &lt;code&gt;OrderByPipe&lt;/code&gt; for reasons explained in the &lt;a href=&quot;pipes#no-filter-pipe&quot;&gt;Appendix&lt;/a&gt; of this page.</source>
          <target state="translated">각도가없는 &lt;code&gt;FilterPipe&lt;/code&gt; 또는 &lt;code&gt;OrderByPipe&lt;/code&gt; 이유가 설명 &lt;a href=&quot;pipes#no-filter-pipe&quot;&gt;부록&lt;/a&gt; 이 페이지의.</target>
        </trans-unit>
        <trans-unit id="d7de62023255791a40ee52811b94f5c474b98e55" translate="yes" xml:space="preserve">
          <source>Angular doesn't have a bootstrap directive. To launch the app in code, explicitly bootstrap the application's root module (&lt;code&gt;AppModule&lt;/code&gt;) in &lt;code&gt;main.ts&lt;/code&gt; and the application's root component (&lt;code&gt;AppComponent&lt;/code&gt;) in &lt;code&gt;app.module.ts&lt;/code&gt;.</source>
          <target state="translated">Angular에는 부트 스트랩 지시문이 없습니다. 코드에서 응용 프로그램을 실행 명시 적으로 응용 프로그램의 루트 모듈 (부트 스트랩 &lt;code&gt;AppModule&lt;/code&gt; 에서) &lt;code&gt;main.ts&lt;/code&gt; 및 응용 프로그램의 루트 구성 요소 ( &lt;code&gt;AppComponent&lt;/code&gt; 에서) &lt;code&gt;app.module.ts&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="1db4be0ad95a78f2180c038b6339b94ffad67719" translate="yes" xml:space="preserve">
          <source>Angular doesn't know that you set the input element's &lt;code&gt;value&lt;/code&gt; property. It won't read that property until you raise the element's &lt;code&gt;input&lt;/code&gt; event by calling &lt;code&gt;&lt;a href=&quot;testing&quot;&gt;dispatchEvent()&lt;/a&gt;&lt;/code&gt;. &lt;em&gt;Then&lt;/em&gt; you call &lt;code&gt;&lt;a href=&quot;../api/core/testing/componentfixture#detectChanges&quot;&gt;detectChanges()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Angular는 입력 요소의 &lt;code&gt;value&lt;/code&gt; 속성 을 설정했다는 것을 모릅니다 . &lt;code&gt;&lt;a href=&quot;testing&quot;&gt;dispatchEvent()&lt;/a&gt;&lt;/code&gt; 를 호출 하여 요소의 &lt;code&gt;input&lt;/code&gt; 이벤트 를 발생시킬 때까지 해당 속성을 읽지 않습니다 . &lt;em&gt;그런 다음 &lt;/em&gt; &lt;code&gt;&lt;a href=&quot;../api/core/testing/componentfixture#detectChanges&quot;&gt;detectChanges()&lt;/a&gt;&lt;/code&gt; 를 호출 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b47387f69f445968d061e38730acd7cac89dc62e" translate="yes" xml:space="preserve">
          <source>Angular doesn't know that you set the input element's &lt;code&gt;value&lt;/code&gt; property. It won't read that property until you raise the element's &lt;code&gt;input&lt;/code&gt; event by calling &lt;code&gt;dispatchEvent()&lt;/code&gt;. &lt;em&gt;Then&lt;/em&gt; you call &lt;code&gt;detectChanges()&lt;/code&gt;.</source>
          <target state="translated">Angular는 입력 요소의 &lt;code&gt;value&lt;/code&gt; 속성 을 설정했는지 알지 못합니다 . &lt;code&gt;dispatchEvent()&lt;/code&gt; 를 호출 하여 요소의 &lt;code&gt;input&lt;/code&gt; 이벤트 를 발생시킬 때까지 해당 속성을 읽지 않습니다 . &lt;em&gt;그런 다음 &lt;/em&gt; &lt;code&gt;detectChanges()&lt;/code&gt; 를 호출 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dd520f6af29e767755a3104595b3766e46582132" translate="yes" xml:space="preserve">
          <source>Angular doesn't like NgModules with circular references, so don't let Module 'A' import Module 'B', which imports Module 'A'.</source>
          <target state="translated">Angular는 순환 참조가있는 NgModules를 좋아하지 않으므로 모듈 'A'가 모듈 'A'를 가져 오는 모듈 'B'를 가져 오게하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0fe275456a97ff34d2bc7a9ec6f6a087e43077a0" translate="yes" xml:space="preserve">
          <source>Angular doesn't provide pipes for filtering or sorting lists. Developers familiar with AngularJS know these as &lt;code&gt;filter&lt;/code&gt; and &lt;code&gt;orderBy&lt;/code&gt;. There are no equivalents in Angular.</source>
          <target state="translated">Angular는 목록을 필터링하거나 정렬하기위한 파이프를 제공하지 않습니다. AngularJS에 익숙한 개발자는이를 &lt;code&gt;filter&lt;/code&gt; 및 &lt;code&gt;orderBy&lt;/code&gt; 로 알고 있습니다. Angular에는 이에 상응하는 것이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d035376ad03249c3d06ea41a32cd0585ba3807fd" translate="yes" xml:space="preserve">
          <source>Angular duplicates the &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; for each item in the list, setting the &lt;code&gt;hero&lt;/code&gt; variable to the item (the hero) in the current iteration. Angular uses that variable as the context for the interpolation in the double curly braces.</source>
          <target state="translated">Angular 는 목록의 각 항목에 대해 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 를 복제하여 현재 반복에서 &lt;code&gt;hero&lt;/code&gt; 변수를 항목 (hero)으로 설정합니다. Angular는이 변수를 이중 중괄호 내삽의 컨텍스트로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="85015daf970f460cc4cdb8249ea3dcc38c78f993" translate="yes" xml:space="preserve">
          <source>Angular element</source>
          <target state="translated">각도 요소</target>
        </trans-unit>
        <trans-unit id="196a77ae5d8842832ab963740bce5e17b220f324" translate="yes" xml:space="preserve">
          <source>Angular elements overview</source>
          <target state="translated">각도 요소 개요</target>
        </trans-unit>
        <trans-unit id="cc9d62dd0c487b775ce03f3a8c3d97cf94a169d1" translate="yes" xml:space="preserve">
          <source>Angular erases the middle &quot;Hip!&quot;, leaving the cheer a bit less enthusiastic.</source>
          <target state="translated">Angular는 중간 &quot;Hip!&quot;을 지우고 환호를 조금 덜 열성적으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9de65d4e4807d361a824604d00a11e49f70b5d15" translate="yes" xml:space="preserve">
          <source>Angular evaluates all expressions in double curly braces, converts the expression results to strings, and links them with neighboring literal strings. Finally, it assigns this composite interpolated result to an &lt;strong&gt;element or directive property&lt;/strong&gt;.</source>
          <target state="translated">Angular는 모든 표현식을 이중 중괄호로 평가하고 표현식 결과를 문자열로 변환 한 다음 인접한 리터럴 문자열과 연결합니다. 마지막으로이 복합 보간 결과를 &lt;strong&gt;요소 또는 지시문 속성에&lt;/strong&gt; 할당 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="46b3eae0baafae45c7e6c0a56aa7f909f9c5b753" translate="yes" xml:space="preserve">
          <source>Angular event binding syntax consists of a &lt;strong&gt;target event&lt;/strong&gt; name within parentheses on the left of an equal sign, and a quoted template statement on the right. The following event binding listens for the button's click events, calling the component's &lt;code&gt;onSave()&lt;/code&gt; method whenever a click occurs:</source>
          <target state="translated">각도 이벤트 바인딩 구문은 등호 왼쪽의 괄호 안에 있는 &lt;strong&gt;대상 이벤트&lt;/strong&gt; 이름과 오른쪽에 인용 된 템플리트 명령문으로 구성됩니다. 다음 이벤트 바인딩은 버튼의 클릭 이벤트를 수신 하여 클릭이 발생할 때마다 구성 요소의 &lt;code&gt;onSave()&lt;/code&gt; 메서드를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="9a1e5ca49dc26e677715c17ed169b11bf4be97c1" translate="yes" xml:space="preserve">
          <source>Angular executes a &lt;em&gt;pure pipe&lt;/em&gt; only when it detects a &lt;em&gt;pure change&lt;/em&gt; to the input value. A pure change is either a change to a primitive input value (&lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;) or a changed object reference (&lt;code&gt;Date&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt;, &lt;code&gt;Object&lt;/code&gt;).</source>
          <target state="translated">Angular 는 입력 값 의 &lt;em&gt;순수한 변화&lt;/em&gt; 를 감지 할 때만 &lt;em&gt;순수 파이프를&lt;/em&gt; 실행 합니다. 순수한 변경은 기본 입력 값 ( &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Number&lt;/code&gt; , &lt;code&gt;Boolean&lt;/code&gt; , &lt;code&gt;Symbol&lt;/code&gt; )에 대한 변경 또는 변경된 객체 참조 ( &lt;code&gt;Date&lt;/code&gt; , &lt;code&gt;Array&lt;/code&gt; , &lt;code&gt;Function&lt;/code&gt; , &lt;code&gt;Object&lt;/code&gt; )입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="10e61b854f3aa7e97f224d066c41aff35eeab1f5" translate="yes" xml:space="preserve">
          <source>Angular executes an &lt;em&gt;impure pipe&lt;/em&gt; during every component change detection cycle. An impure pipe is called often, as often as every keystroke or mouse-move.</source>
          <target state="translated">Angular는 모든 구성 요소 변경 감지주기 동안 &lt;em&gt;불순한 파이프를&lt;/em&gt; 실행합니다 . 매번 키를 누르거나 마우스를 움직일 때마다 불순한 파이프가 자주 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="30048831bd39a80f3d9aad084b8380f724c8d4fb" translate="yes" xml:space="preserve">
          <source>Angular executes hook methods in the following sequence. You can use them to perform the following kinds of operations.</source>
          <target state="translated">Angular는 다음 순서로 후크 메서드를 실행합니다. 이를 사용하여 다음과 같은 종류의 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3f08b38aea522e78394f75ae5fb4ddda9056304" translate="yes" xml:space="preserve">
          <source>Angular executes template expressions after every change detection cycle. Change detection cycles are triggered by many asynchronous activities such as promise resolutions, HTTP results, timer events, key presses and mouse moves.</source>
          <target state="translated">Angular는 모든 변경 감지주기 후에 템플릿 표현식을 실행합니다. 약속 탐지, HTTP 결과, 타이머 이벤트, 키 누름 및 마우스 이동과 같은 많은 비동기 활동에 의해 변경 감지주기가 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="93fd7debae3edda32d9bdc394dafa95f04ee8ce9" translate="yes" xml:space="preserve">
          <source>Angular follows the Unicode LDML convention that uses stable identifiers (Unicode locale identifiers) based on the norm &lt;a href=&quot;http://www.rfc-editor.org/rfc/bcp/bcp47.txt&quot;&gt;BCP47&lt;/a&gt;. It is very important that you follow this convention when you define your locale, because the Angular i18n tools use this locale id to find the correct corresponding locale data.</source>
          <target state="translated">Angular는 표준 &lt;a href=&quot;http://www.rfc-editor.org/rfc/bcp/bcp47.txt&quot;&gt;BCP47&lt;/a&gt; 기반의 안정적인 식별자 (유니 코드 로캘 식별자)를 사용하는 유니 코드 LDML 규칙을 따릅니다 . Angular i18n 도구는이 로캘 ID를 사용하여 올바른 해당 로캘 데이터를 찾기 때문에 로캘을 정의 할 때이 규칙을 따르는 것이 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="e5403b18984f04aca1cbbd4e8aad53057e69dc66" translate="yes" xml:space="preserve">
          <source>Angular forms allow you to:</source>
          <target state="translated">각도 양식을 사용하면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1a9dce4e9c4b6bdfc09512c4aaf5cc2e6bb0b2e" translate="yes" xml:space="preserve">
          <source>Angular forms don't require a style library</source>
          <target state="translated">각도 양식에는 스타일 라이브러리가 필요하지 않습니다</target>
        </trans-unit>
        <trans-unit id="a53bf8fe33eabf51e7d2da4584dccc79ed01e757" translate="yes" xml:space="preserve">
          <source>Angular functions for animating multiple elements start with &lt;code&gt;&lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;()&lt;/code&gt; to find inner elements, for example gathering all images within a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;. The remaining functions, &lt;code&gt;&lt;a href=&quot;../api/animations/stagger&quot;&gt;stagger&lt;/a&gt;()&lt;/code&gt;, &lt;a href=&quot;../api/animations/group&quot;&gt;&lt;code&gt;group()&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;&lt;a href=&quot;../api/animations/sequence&quot;&gt;sequence&lt;/a&gt;()&lt;/code&gt;, apply cascades or allow you to control how multiple animation steps are applied.</source>
          <target state="translated">여러 요소를 애니메이션화하는 각도 함수는 &lt;code&gt;&lt;a href=&quot;../api/animations/query&quot;&gt;query&lt;/a&gt;()&lt;/code&gt; 로 시작하여 내부 요소를 찾습니다 ( 예 : &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 내의 모든 이미지 수집) . 나머지 함수 인 &lt;code&gt;&lt;a href=&quot;../api/animations/stagger&quot;&gt;stagger&lt;/a&gt;()&lt;/code&gt; , &lt;a href=&quot;../api/animations/group&quot;&gt; &lt;code&gt;group()&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/animations/sequence&quot;&gt;sequence&lt;/a&gt;()&lt;/code&gt; 는 계단식을 적용하거나 여러 애니메이션 단계가 적용되는 방법을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="347ddc68bb0465a1bdad6eaa3b2963e0159918e2" translate="yes" xml:space="preserve">
          <source>Angular fundamentals</source>
          <target state="translated">Angular 기초</target>
        </trans-unit>
        <trans-unit id="6bd9d0319f292ad5b74842fe2d764295ebf9d611" translate="yes" xml:space="preserve">
          <source>Angular generates a class factory in a separate module and that factory &lt;a href=&quot;aot-compiler#exported-symbols&quot;&gt;can only access exported classes&lt;/a&gt;. To correct this error, export the referenced class.</source>
          <target state="translated">Angular는 별도의 모듈에서 클래스 팩토리를 생성하며 해당 팩토리 &lt;a href=&quot;aot-compiler#exported-symbols&quot;&gt;는 내 보낸 클래스에만 액세스 할 수 있습니다&lt;/a&gt; . 이 오류를 해결하려면 참조 된 클래스를 내보내십시오.</target>
        </trans-unit>
        <trans-unit id="952768c15a2572a986f6ae3389d91e52e5d8c2ee" translate="yes" xml:space="preserve">
          <source>Angular generates a class factory in a separate module and that factory &lt;a href=&quot;aot-compiler#exported-symbols&quot;&gt;can only access exported functions&lt;/a&gt;. To correct this error, export the function.</source>
          <target state="translated">Angular는 별도의 모듈에서 클래스 팩토리를 생성하며 해당 팩토리 &lt;a href=&quot;aot-compiler#exported-symbols&quot;&gt;는 내 보낸 함수에만 액세스 할 수 있습니다&lt;/a&gt; . 이 오류를 해결하려면 기능을 내보내십시오.</target>
        </trans-unit>
        <trans-unit id="a776357d683de5262cf58f9728286d0531d34b15" translate="yes" xml:space="preserve">
          <source>Angular generation &lt;a href=&quot;glossary#schematic&quot;&gt;schematics&lt;/a&gt; are instructions for modifying a project by adding files or modifying existing files. Individual schematics for the default Angular CLI &lt;code&gt;ng generate&lt;/code&gt; sub-commands are collected in the package &lt;code&gt;@angular&lt;/code&gt;. Specify the schematic name for a subcommand in the format &lt;code&gt;schematic-package:schematic-name&lt;/code&gt;; for example, the schematic for generating a component is &lt;code&gt;@angular:component&lt;/code&gt;.</source>
          <target state="translated">각도 생성 &lt;a href=&quot;glossary#schematic&quot;&gt;회로도&lt;/a&gt; 는 파일을 추가하거나 기존 파일을 수정하여 프로젝트를 수정하기위한 지침입니다. 기본 Angular CLI &lt;code&gt;ng generate&lt;/code&gt; 하위 명령에 대한 개별 회로도는 &lt;code&gt;@angular&lt;/code&gt; 패키지에 수집됩니다 . 하위 명령에 대한 회로도 이름을 &lt;code&gt;schematic-package:schematic-name&lt;/code&gt; 형식 으로 지정하십시오 . 예를 들어, 컴포넌트를 생성하기위한 회로도는 &lt;code&gt;@angular:component&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="089b7f9bea4b756f67f9eed4c52f2969b5e785ba" translate="yes" xml:space="preserve">
          <source>Angular has a hierarchical injection system. There can be injectors at multiple levels, from the root injector created by the &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; down through the component tree.</source>
          <target state="translated">앵귤러에는 계층 적 주입 시스템이 있습니다. &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; 에 의해 생성 된 루트 인젝터 부터 컴포넌트 트리 까지 여러 레벨의 인젝터가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8203852c3d2c9dbdc69314b56a03f0403dac7220" translate="yes" xml:space="preserve">
          <source>Angular has an &lt;a href=&quot;router&quot;&gt;all-new router&lt;/a&gt;.</source>
          <target state="translated">Angular에는 &lt;a href=&quot;router&quot;&gt;완전히 새로운 라우터가&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="0aa5ff740e38d6d18edbfc10a1644f100e11e1f4" translate="yes" xml:space="preserve">
          <source>Angular has been creating new instances of the real &lt;code&gt;HeroDetailService&lt;/code&gt; all along!</source>
          <target state="translated">Angular는 실제 &lt;code&gt;HeroDetailService&lt;/code&gt; 의 새로운 인스턴스를 생성했습니다 !</target>
        </trans-unit>
        <trans-unit id="a5090fe3d42da3f7912eb530ce278090a19f01ff" translate="yes" xml:space="preserve">
          <source>Angular has built-in support to help prevent two common HTTP vulnerabilities, cross-site request forgery (CSRF or XSRF) and cross-site script inclusion (XSSI). Both of these must be mitigated primarily on the server side, but Angular provides helpers to make integration on the client side easier.</source>
          <target state="translated">Angular는 두 가지 일반적인 HTTP 취약점 인 사이트 간 요청 위조 (CSRF 또는 XSRF)와 사이트 간 스크립트 포함 (XSSI)을 방지하기 위해 기본적으로 지원됩니다. 이 두 가지 모두 주로 서버 쪽에서 완화해야하지만 Angular는 클라이언트쪽에 쉽게 통합 할 수 있도록 돕는 도우미를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="75f9cada0487eab03f3583131e1b6541f4ca7704" translate="yes" xml:space="preserve">
          <source>Angular has its own vocabulary. Most Angular terms are common English words or computing terms that have a specific meaning within the Angular system.</source>
          <target state="translated">Angular에는 자체 어휘가 있습니다. 대부분의 Angular 용어는 Angular 시스템 내에서 특정 의미를 갖는 일반적인 영어 단어 또는 컴퓨팅 용어입니다.</target>
        </trans-unit>
        <trans-unit id="36cef403a50f03b999516ba0de6de9a10a58c8db" translate="yes" xml:space="preserve">
          <source>Angular has more pre-defined directives that either alter the layout structure (for example, &lt;a href=&quot;built-in-directives#ngSwitch&quot;&gt;ngSwitch&lt;/a&gt;) or modify aspects of DOM elements and components (for example, &lt;a href=&quot;built-in-directives#ngStyle&quot;&gt;ngStyle&lt;/a&gt; and &lt;a href=&quot;built-in-directives#ngClass&quot;&gt;ngClass&lt;/a&gt;).</source>
          <target state="translated">Angular에는 레이아웃 구조 (예 : &lt;a href=&quot;built-in-directives#ngSwitch&quot;&gt;ngSwitch&lt;/a&gt; )를 변경하거나 DOM 요소 및 구성 요소 (예 : &lt;a href=&quot;built-in-directives#ngStyle&quot;&gt;ngStyle&lt;/a&gt; 및 &lt;a href=&quot;built-in-directives#ngClass&quot;&gt;ngClass&lt;/a&gt; )의 측면을 수정 하는 사전 정의 된 지시문이 더 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="020323b35fdea984dabd628de596cd425d7e51fa" translate="yes" xml:space="preserve">
          <source>Angular has more pre-defined directives that either alter the layout structure (for example, &lt;a href=&quot;template-syntax#ngSwitch&quot;&gt;ngSwitch&lt;/a&gt;) or modify aspects of DOM elements and components (for example, &lt;a href=&quot;template-syntax#ngStyle&quot;&gt;ngStyle&lt;/a&gt; and &lt;a href=&quot;template-syntax#ngClass&quot;&gt;ngClass&lt;/a&gt;).</source>
          <target state="translated">Angular에는 레이아웃 구조 (예 : &lt;a href=&quot;template-syntax#ngSwitch&quot;&gt;ngSwitch&lt;/a&gt; )를 변경하거나 DOM 요소 및 구성 요소의 측면 (예 : &lt;a href=&quot;template-syntax#ngStyle&quot;&gt;ngStyle&lt;/a&gt; 및 &lt;a href=&quot;template-syntax#ngClass&quot;&gt;ngClass&lt;/a&gt; )을 수정 하는 사전 정의 된 지시문이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1686cbfe82438a65326efb7fbfc9ed594c24a6e5" translate="yes" xml:space="preserve">
          <source>Angular has true template input variables that are explicitly defined using the &lt;code&gt;let&lt;/code&gt; keyword.</source>
          <target state="translated">Angular에는 &lt;code&gt;let&lt;/code&gt; 키워드를 사용하여 명시 적으로 정의 된 실제 템플릿 입력 변수가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9aa8ff3ec993f9613874918fdca308390a782abe" translate="yes" xml:space="preserve">
          <source>Angular ignores changes within (composite) objects. It won't call a pure pipe if you change an input month, add to an input array, or update an input object property.</source>
          <target state="translated">각도는 (복합) 객체 내의 변경 사항을 무시합니다. 입력 월을 변경하거나 입력 배열에 추가하거나 입력 객체 속성을 업데이트하면 순수 파이프를 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9ea659473cf06cf26e6026f2da7a0eb79db0ddc" translate="yes" xml:space="preserve">
          <source>Angular instead inspects directive and component classes and calls the hook methods &lt;em&gt;if they are defined&lt;/em&gt;. Angular finds and calls methods like &lt;code&gt;ngOnInit()&lt;/code&gt;, with or without the interfaces.</source>
          <target state="translated">대신 Angular는 지시문과 컴포넌트 클래스를 검사하고 &lt;em&gt;정의 된 경우&lt;/em&gt; 후크 메소드를 호출합니다 . Angular는 인터페이스 유무에 관계없이 &lt;code&gt;ngOnInit()&lt;/code&gt; 와 같은 메소드를 찾아 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="9d2787f184c1925b33fab871a39bcac0b55b64cf" translate="yes" xml:space="preserve">
          <source>Angular invokes the &lt;code&gt;transform&lt;/code&gt; method with the value of a binding as the first argument, and any parameters as the second argument in list form, and returns the transformed value.</source>
          <target state="translated">Angular는 바인딩 값을 첫 번째 인수로 사용하고 매개 변수를 목록 형식의 두 번째 인수로 사용하여 &lt;code&gt;transform&lt;/code&gt; 메서드를 호출하고 변환 된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5b42b26f4e53b4e9e433f908be1ae23996faf473" translate="yes" xml:space="preserve">
          <source>Angular is a collection of many packages, sub-projects, and tools. To prevent accidental use of private APIs&amp;mdash;and so that you can clearly understand what is covered by the practices described here&amp;mdash;we document what is and is not considered our public API surface. For details, see &lt;a href=&quot;https://github.com/angular/angular/blob/master/docs/PUBLIC_API.md&quot;&gt;Supported Public API Surface of Angular&lt;/a&gt;.</source>
          <target state="translated">Angular는 많은 패키지, 하위 프로젝트 및 도구 모음입니다. 개인 API의 우발적 인 사용을 방지하고 여기에 설명 된 관행에서 다루는 내용을 명확하게 이해할 수 있도록 공개 API 표면으로 간주되는 것과 그렇지 않은 것을 문서화합니다. 자세한 내용은 &lt;a href=&quot;https://github.com/angular/angular/blob/master/docs/PUBLIC_API.md&quot;&gt;지원되는 공개 API 표면의 각도를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cedb8ef1bd5824f0f32e164656ec8ed996c2415d" translate="yes" xml:space="preserve">
          <source>Angular is a platform and framework for building client applications in HTML and TypeScript. Angular is written in TypeScript. It implements core and optional functionality as a set of TypeScript libraries that you import into your apps.</source>
          <target state="translated">Angular는 HTML 및 TypeScript로 클라이언트 응용 프로그램을 구축하기위한 플랫폼 및 프레임 워크입니다. Angular는 TypeScript로 작성되었습니다. 핵심 및 선택적 기능을 앱으로 가져 오는 TypeScript 라이브러리 세트로 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c09e1dc78236e7af0800454292bf644c4910bcee" translate="yes" xml:space="preserve">
          <source>Angular is a platform and framework for building single-page client applications using HTML and TypeScript. Angular is written in TypeScript. It implements core and optional functionality as a set of TypeScript libraries that you import into your apps.</source>
          <target state="translated">Angular는 HTML 및 TypeScript를 사용하여 단일 페이지 클라이언트 응용 프로그램을 빌드하기위한 플랫폼 및 프레임 워크입니다. Angular는 TypeScript로 작성되었습니다. 앱으로 가져 오는 TypeScript 라이브러리 세트로 핵심 및 선택적 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="944adaf5cf94f6c56a0403bf343031231a5680bd" translate="yes" xml:space="preserve">
          <source>Angular is a reimagined version of the best parts of AngularJS. In that sense, its goals are the same as the AngularJS Style Guide's: To preserve the good parts of AngularJS, and to avoid the bad parts. There's a lot more to Angular than just that of course, but this does mean that &lt;em&gt;following the style guide helps make your AngularJS app more closely aligned with Angular&lt;/em&gt;.</source>
          <target state="translated">Angular는 AngularJS의 최고 부분을 재 해석 한 버전입니다. 그런 의미에서 목표는 AngularJS 스타일 가이드와 동일합니다 : AngularJS의 좋은 부분을 보존하고 나쁜 부분을 피하는 것. 물론 Angular에는 훨씬 많은 것이 있지만 이는 &lt;em&gt;스타일 가이드를&lt;/em&gt; 따르면 &lt;em&gt;AngularJS 앱이 Angular와 더 밀접하게 정렬되는 데 도움&lt;/em&gt; 이된다는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="e88edc1d9d2323834676f35f85d122a43a5b00b3" translate="yes" xml:space="preserve">
          <source>Angular is an application design framework and development platform for creating efficient and sophisticated single-page apps.</source>
          <target state="translated">Angular는 효율적이고 정교한 단일 페이지 앱을 만들기위한 애플리케이션 디자인 프레임 워크 및 개발 플랫폼입니다.</target>
        </trans-unit>
        <trans-unit id="cdbe94ed1821482a4bf72519359a4832dfb721ff" translate="yes" xml:space="preserve">
          <source>Angular is bootstrapped first; AngularJS is bootstrapped second. AngularJS always owns the root component of the application.</source>
          <target state="translated">각도가 먼저 부트 스트랩됩니다. AngularJS는 두 번째 부트 스트랩됩니다. AngularJS는 항상 응용 프로그램의 루트 구성 요소를 소유합니다.</target>
        </trans-unit>
        <trans-unit id="67c408d51f3d9541622ae37dc07fd998e2b6d4a6" translate="yes" xml:space="preserve">
          <source>Angular is built on the latest standards of the web platform. Targeting such a wide range of browsers is challenging because they do not support all features of modern browsers. You compensate by loading polyfill scripts (&quot;polyfills&quot;) for the browsers that you must support. The &lt;a href=&quot;browser-support#polyfill-libs&quot;&gt;table below&lt;/a&gt; identifies most of the polyfills you might need.</source>
          <target state="translated">Angular는 웹 플랫폼의 최신 표준을 기반으로합니다. 이러한 광범위한 브라우저를 대상으로하는 것은 최신 브라우저의 모든 기능을 지원하지 않으므로 어렵습니다. 지원해야하는 브라우저에 대한 폴리 필 스크립트 ( &quot;폴리 필&quot;)를로드하여 보상합니다. &lt;a href=&quot;browser-support#polyfill-libs&quot;&gt;아래 표&lt;/a&gt; 당신이해야 할 수도 있습니다 polyfills의 대부분을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="e7c5a8227c920abc2ab831e8b743010e5cec1f51" translate="yes" xml:space="preserve">
          <source>Angular isn't showing and hiding the message. It is adding and removing the paragraph element from the DOM. That improves performance, especially in larger projects when conditionally including or excluding big chunks of HTML with many data bindings.</source>
          <target state="translated">Angular가 메시지를 표시하거나 숨기지 않습니다. DOM에서 단락 요소를 추가하고 제거합니다. 이는 많은 데이터 바인딩을 사용하여 큰 HTML 청크를 조건부로 포함하거나 제외 할 때 특히 대규모 프로젝트에서 성능을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="bfddc46758f816dd29441664cdec5b402661cdef" translate="yes" xml:space="preserve">
          <source>Angular knows that the &lt;code&gt;defaultColor&lt;/code&gt; binding belongs to the &lt;code&gt;HighlightDirective&lt;/code&gt; because you made it &lt;em&gt;public&lt;/em&gt; with the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; decorator.</source>
          <target state="translated">각도는 것을 알고 &lt;code&gt;defaultColor&lt;/code&gt; 바인딩이 속한 &lt;code&gt;HighlightDirective&lt;/code&gt; 당신이 만들었 기 때문에 &lt;em&gt;공공&lt;/em&gt; 와 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; 장식.</target>
        </trans-unit>
        <trans-unit id="6520112c4953366a0de588a54b18493a41a7c8f8" translate="yes" xml:space="preserve">
          <source>Angular libraries</source>
          <target state="translated">각도 라이브러리</target>
        </trans-unit>
        <trans-unit id="3f426e8d596d5b3588e555663b8f3b96dfed3e9f" translate="yes" xml:space="preserve">
          <source>Angular libraries are NgModules, such as &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt;. Many third-party libraries are available as NgModules such as &lt;a href=&quot;https://material.angular.io/&quot;&gt;Material Design&lt;/a&gt;, &lt;a href=&quot;http://ionicframework.com/&quot;&gt;Ionic&lt;/a&gt;, and &lt;a href=&quot;https://github.com/angular/angularfire2&quot;&gt;AngularFire2&lt;/a&gt;.</source>
          <target state="translated">각도 라이브러리는 NgModules입니다 (예 : &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule&quot;&gt;RouterModule&lt;/a&gt;&lt;/code&gt; ) . &lt;a href=&quot;https://material.angular.io/&quot;&gt;Material Design&lt;/a&gt; , &lt;a href=&quot;http://ionicframework.com/&quot;&gt;Ionic&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/angular/angularfire2&quot;&gt;AngularFire2&lt;/a&gt; 와 같은 많은 타사 라이브러리를 NgModules로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dad4b4472bc88f1f5698b422a998c38c20704e3c" translate="yes" xml:space="preserve">
          <source>Angular libraries have this option to ensure that all Angular &lt;code&gt;.metadata.json&lt;/code&gt; files are clean and it is a best practice to do the same when building your own libraries.</source>
          <target state="translated">Angular 라이브러리에는이 옵션이있어 모든 Angular &lt;code&gt;.metadata.json&lt;/code&gt; 파일을 깨끗하게 유지하고 자신의 라이브러리를 빌드 할 때 동일하게 수행하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="be3f78b53fc2c577daabc8bc52b4aa660d4e9dae" translate="yes" xml:space="preserve">
          <source>Angular libraries should list all &lt;code&gt;@angular/*&lt;/code&gt; dependencies as peer dependencies. This ensures that when modules ask for Angular, they all get the exact same module. If a library lists &lt;code&gt;@angular/core&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../api/core/resolvedreflectivefactory#dependencies&quot;&gt;dependencies&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;peerDependencies&lt;/code&gt;, it might get a different Angular module instead, which would cause your application to break.</source>
          <target state="translated">각도 라이브러리는 모든 &lt;code&gt;@angular/*&lt;/code&gt; 종속성을 피어 종속성으로 나열해야합니다 . 이를 통해 모듈이 Angular를 요청할 때 모두 동일한 모듈을 얻을 수 있습니다. 라이브러리 가 &lt;code&gt;peerDependencies&lt;/code&gt; 대신 &lt;code&gt;&lt;a href=&quot;../api/core/resolvedreflectivefactory#dependencies&quot;&gt;dependencies&lt;/a&gt;&lt;/code&gt; &lt;code&gt;@angular/core&lt;/code&gt; 를 나열하면 대신 다른 Angular 모듈이 생겨 응용 프로그램이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="440b921c958820163daec667135fde70d6e18758" translate="yes" xml:space="preserve">
          <source>Angular libraries should list all &lt;code&gt;@angular/*&lt;/code&gt; dependencies as peer dependencies. This ensures that when modules ask for Angular, they all get the exact same module. If a library lists &lt;code&gt;@angular/core&lt;/code&gt; in &lt;code&gt;dependencies&lt;/code&gt; instead of &lt;code&gt;peerDependencies&lt;/code&gt;, it might get a different Angular module instead, which would cause your application to break.</source>
          <target state="translated">Angular 라이브러리는 모든 &lt;code&gt;@angular/*&lt;/code&gt; 종속성을 피어 종속성으로 나열해야합니다 . 이렇게하면 모듈이 Angular를 요청할 때 모두 똑같은 모듈을 얻습니다. 라이브러리 가 &lt;code&gt;peerDependencies&lt;/code&gt; 대신 &lt;code&gt;dependencies&lt;/code&gt; &lt;code&gt;@angular/core&lt;/code&gt; 를 나열하면 대신 다른 Angular 모듈을 가져와 애플리케이션이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29d44f7fda091b59312a3e7e208e6d0e349017ad" translate="yes" xml:space="preserve">
          <source>Angular libraries use Ivy</source>
          <target state="translated">Angular 라이브러리는 Ivy를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a25634352050885006a3b6152b0eb2a9010080c0" translate="yes" xml:space="preserve">
          <source>Angular loads a component declaratively when using the component's selector to locate the element in the template. Angular then creates the HTML representation of the component and inserts it into the DOM at the selected element. These aren't entry components.</source>
          <target state="translated">컴포넌트의 셀렉터를 사용하여 템플릿에서 요소를 찾을 때 Angular는 컴포넌트를 선언적으로로드합니다. 그런 다음 Angular는 구성 요소의 HTML 표현을 만들어 선택한 요소의 DOM에 삽입합니다. 이들은 엔트리 구성 요소가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="995f2b8032fa111ae2d621211fc7064ea0317af9" translate="yes" xml:space="preserve">
          <source>Angular loads a root &lt;code&gt;AppComponent&lt;/code&gt; dynamically because it's listed by type in &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule#bootstrap&quot;&gt;NgModule.bootstrap&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Angular는 루트 &lt;code&gt;AppComponent&lt;/code&gt; 를 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule#bootstrap&quot;&gt;NgModule.bootstrap&lt;/a&gt;&lt;/code&gt; 형식으로 나열하기 때문에 동적으로 로드합니다 .</target>
        </trans-unit>
        <trans-unit id="08a4bd02cf20c2f65095b4e5963e1bb2afe416d9" translate="yes" xml:space="preserve">
          <source>Angular loads as a collection of JavaScript modules. You can think of them as library modules. Each Angular library name begins with the &lt;code&gt;@angular&lt;/code&gt; prefix. Install them with the node package manager &lt;code&gt;npm&lt;/code&gt; and import parts of them with JavaScript &lt;code&gt;import&lt;/code&gt; statements.</source>
          <target state="translated">JavaScript 모듈의 모음으로 각도로드 그것들을 라이브러리 모듈로 생각할 수 있습니다. 각 Angular 라이브러리 이름은 &lt;code&gt;@angular&lt;/code&gt; 접두사로 시작 합니다. 노드 패키지 관리자 &lt;code&gt;npm&lt;/code&gt; 을 사용하여 설치하고 JavaScript &lt;code&gt;import&lt;/code&gt; 문 을 사용하여 일부를 가져 오십시오 .</target>
        </trans-unit>
        <trans-unit id="34efda63681d11b2077d5df610262c0a6c29b126" translate="yes" xml:space="preserve">
          <source>Angular looks for changes to data-bound values in a &lt;a href=&quot;glossary#change-detection&quot;&gt;change detection&lt;/a&gt; process that runs after every DOM event: every keystroke, mouse move, timer tick, and server response. The following example, which doesn't use a pipe, demonstrates how Angular uses its default change detection strategy to monitor and update its display of every hero in the &lt;code&gt;heroes&lt;/code&gt; array. The example tabs show the following:</source>
          <target state="translated">Angular는 모든 DOM 이벤트 이후에 실행 되는 &lt;a href=&quot;glossary#change-detection&quot;&gt;변경 감지&lt;/a&gt; 프로세스 (모든 키 입력, 마우스 이동, 타이머 틱 및 서버 응답) 에서 데이터 바인딩 된 값의 변경 사항을 찾습니다 . 파이프를 사용하지 않는 다음 예제는 Angular가 기본 변경 감지 전략을 사용하여 &lt;code&gt;heroes&lt;/code&gt; 배열 에있는 모든 영웅의 디스플레이를 모니터링하고 업데이트하는 방법을 보여줍니다 . 예제 탭은 다음을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="853e166961741611ece2f458d671b607ed487c72" translate="yes" xml:space="preserve">
          <source>Angular looks for changes to data-bound values through a &lt;em&gt;change detection&lt;/em&gt; process that runs after every DOM event: every keystroke, mouse move, timer tick, and server response. This could be expensive. Angular strives to lower the cost whenever possible and appropriate.</source>
          <target state="translated">Angular는 모든 키 이벤트, 마우스 이동, 타이머 틱 및 서버 응답과 같은 모든 DOM 이벤트 후에 실행 되는 &lt;em&gt;변경 감지&lt;/em&gt; 프로세스를 통해 데이터 바인딩 된 값의 변경 사항을 찾습니다 . 이것은 비쌀 수 있습니다. Angular는 가능할 때마다 비용을 낮추려고 노력합니다.</target>
        </trans-unit>
        <trans-unit id="698612677c72d7d99a71306fe64680c45b867fa2" translate="yes" xml:space="preserve">
          <source>Angular makes no use of the &lt;code&gt;container&lt;/code&gt;, &lt;code&gt;form-group&lt;/code&gt;, &lt;code&gt;form-control&lt;/code&gt;, and &lt;code&gt;btn&lt;/code&gt; classes or the styles of any external library. Angular apps can use any CSS library or none at all.</source>
          <target state="translated">Angular는 &lt;code&gt;container&lt;/code&gt; , &lt;code&gt;form-group&lt;/code&gt; , &lt;code&gt;form-control&lt;/code&gt; 및 &lt;code&gt;btn&lt;/code&gt; 클래스 또는 외부 라이브러리 스타일을 사용하지 않습니다. 각도 앱은 모든 CSS 라이브러리를 사용하거나 전혀 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d8d1474460cc15db876a17834bf926386371bf34" translate="yes" xml:space="preserve">
          <source>Angular makes the process easy by handling many of the repetitive, boilerplate tasks you'd otherwise wrestle with yourself.</source>
          <target state="translated">Angular는 다른 반복적 인 상용구 작업을 처리하여 프로세스를 쉽게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="733393efef5ce43977efcba35cca922753ae83e7" translate="yes" xml:space="preserve">
          <source>Angular makes use of observables as an interface to handle a variety of common asynchronous operations. For example:</source>
          <target state="translated">Angular는 옵저버 블을 다양한 공통 비동기 작업을 처리하기위한 인터페이스로 사용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c952b87a2d4235b4fa18e60db17580ca8f99e1d9" translate="yes" xml:space="preserve">
          <source>Angular modularity</source>
          <target state="translated">각도 모듈성</target>
        </trans-unit>
        <trans-unit id="f60bec56de0d46a0d6f36063b2d445f9aa6ecf52" translate="yes" xml:space="preserve">
          <source>Angular modules</source>
          <target state="translated">각도 모듈</target>
        </trans-unit>
        <trans-unit id="5d2b463cfcddb80a14ef8505352142925769b3e0" translate="yes" xml:space="preserve">
          <source>Angular needs to know how the pieces of your application fit together and what other files and libraries the app requires. This information is called &lt;em&gt;metadata&lt;/em&gt;.</source>
          <target state="translated">Angular는 응용 프로그램 조각이 어떻게 어울리는 지, 응용 프로그램에 필요한 다른 파일과 라이브러리를 알아야합니다. 이 정보를 &lt;em&gt;메타 데이터&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c8907e4049cbb49a2de258115f28db0236a6b67a" translate="yes" xml:space="preserve">
          <source>Angular offers &lt;strong&gt;lifecycle hooks&lt;/strong&gt; that provide visibility into these key life moments and the ability to act when they occur.</source>
          <target state="translated">Angular는 이러한 주요 수명 순간에 대한 가시성과 발생시 행동 할 수있는 &lt;strong&gt;수명주기 후크&lt;/strong&gt; 를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d76e449c5b5a82a11aa58826c48ff9172d4b34e4" translate="yes" xml:space="preserve">
          <source>Angular offers a special &lt;em&gt;two-way data binding&lt;/em&gt; syntax for this purpose, &lt;code&gt;[()]&lt;/code&gt;. The &lt;code&gt;[()]&lt;/code&gt; syntax combines the brackets of property binding, &lt;code&gt;[]&lt;/code&gt;, with the parentheses of event binding, &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">Angular는 이러한 목적 &lt;em&gt;으로&lt;/em&gt; 특별한 &lt;em&gt;양방향 데이터 바인딩&lt;/em&gt; 구문 인 &lt;code&gt;[()]&lt;/code&gt; 을 제공 합니다. 는 &lt;code&gt;[()]&lt;/code&gt; 의 구문은 결합 특성의 브래킷 결합 &lt;code&gt;[]&lt;/code&gt; , 바인딩 이벤트들의 괄호, &lt;code&gt;()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b96c491c78ad4254c4a00563220ea3cb04a021b" translate="yes" xml:space="preserve">
          <source>Angular offers many more capabilities, and you now have a foundation that empowers you to build an application and explore those other capabilities:</source>
          <target state="translated">Angular는 더 많은 기능을 제공하며 이제 응용 프로그램을 구축하고 다른 기능을 탐색 할 수있는 기반을 갖추 었습니다.</target>
        </trans-unit>
        <trans-unit id="b54553b1cb0eae873f191d62095e66d3e101c047" translate="yes" xml:space="preserve">
          <source>Angular offers two kinds of built-in directives: &lt;a href=&quot;attribute-directives&quot;&gt;&lt;em&gt;attribute&lt;/em&gt; directives&lt;/a&gt; and &lt;a href=&quot;structural-directives&quot;&gt;&lt;em&gt;structural&lt;/em&gt; directives&lt;/a&gt;.</source>
          <target state="translated">Angular는 &lt;a href=&quot;attribute-directives&quot;&gt;&lt;em&gt;속성&lt;/em&gt; 지시문&lt;/a&gt; 과 &lt;a href=&quot;structural-directives&quot;&gt;&lt;em&gt;구조&lt;/em&gt; 지시문&lt;/a&gt; 의 두 가지 내장 지시문을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="abc451db75214bb8f5bb03f627de0240f5b091b0" translate="yes" xml:space="preserve">
          <source>Angular offers two kinds of built-in directives: attribute directives and structural directives. This segment reviews some of the most common built-in directives, classified as either &lt;a href=&quot;template-syntax#attribute-directives&quot;&gt;&lt;em&gt;attribute&lt;/em&gt; directives&lt;/a&gt; or &lt;a href=&quot;template-syntax#structural-directives&quot;&gt;&lt;em&gt;structural&lt;/em&gt; directives&lt;/a&gt; and has its own &lt;span name=&quot;built-in-directives&quot;&gt;built-in directives example&lt;/span&gt;.</source>
          <target state="translated">Angular는 속성 지시문과 구조적 지시문이라는 두 가지 종류의 내장 지시문을 제공합니다. 이 세그먼트는 &lt;a href=&quot;template-syntax#attribute-directives&quot;&gt;&lt;em&gt;속성&lt;/em&gt; 지시문&lt;/a&gt; 또는 &lt;a href=&quot;template-syntax#structural-directives&quot;&gt;&lt;em&gt;구조적&lt;/em&gt; 지시문&lt;/a&gt; 으로 분류되고 자체 &lt;span name=&quot;built-in-directives&quot;&gt;내장 지시문 예제&lt;/span&gt; 가있는 가장 일반적인 내장 지시문 중 일부를 검토 합니다.</target>
        </trans-unit>
        <trans-unit id="f6ecdff766f22fe112f392e3b5f72cdc4a54fa55" translate="yes" xml:space="preserve">
          <source>Angular offers two ways to compile your application:</source>
          <target state="translated">Angular는 응용 프로그램을 컴파일하는 두 가지 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="46473abcb3dc6366d18741a180865bfdefc2a988" translate="yes" xml:space="preserve">
          <source>Angular only allows directives to apply on CSS selectors that do not cross element boundaries.</source>
          <target state="translated">Angular는 지시문이 요소 경계를 넘지 않는 CSS 선택기에 적용되도록 허용합니다.</target>
        </trans-unit>
        <trans-unit id="ab4a735a9f53cef22a8e09069eaf331c806e03b7" translate="yes" xml:space="preserve">
          <source>Angular only binds to &lt;em&gt;public&lt;/em&gt; component properties.</source>
          <target state="translated">Angular는 &lt;em&gt;공용&lt;/em&gt; 구성 요소 속성 에만 바인딩 합니다.</target>
        </trans-unit>
        <trans-unit id="0796c5a0e37f43354cb8a990d1da6f63a399b35c" translate="yes" xml:space="preserve">
          <source>Angular only calls the hook when the value of the input property changes. The value of the &lt;code&gt;hero&lt;/code&gt; property is the &lt;em&gt;reference to the hero object&lt;/em&gt;. Angular doesn't care that the hero's own &lt;code&gt;name&lt;/code&gt; property changed. The hero object &lt;em&gt;reference&lt;/em&gt; didn't change so, from Angular's perspective, there is no change to report!</source>
          <target state="translated">Angular는 입력 속성 값이 변경 될 때만 후크를 호출합니다. &lt;code&gt;hero&lt;/code&gt; 속성 의 값은 &lt;em&gt;hero 객체에 대한 참조&lt;/em&gt; 입니다. Angular는 영웅의 &lt;code&gt;name&lt;/code&gt; 속성이 변경 되었음을 신경 쓰지 않습니다 . 영웅 객체 &lt;em&gt;참조&lt;/em&gt; 는 변경되지 않았으므로 Angular의 관점에서보고 할 변경 사항은 없습니다!</target>
        </trans-unit>
        <trans-unit id="73365649ff96710832ccaf130004428d6aa4b134" translate="yes" xml:space="preserve">
          <source>Angular only matches selectors and pipe names for classes that are declared by this module or exported by a module that this module imports.</source>
          <target state="translated">Angular는이 모듈에서 선언하거나이 모듈에서 가져 오는 모듈에서 내 보낸 클래스의 선택기 및 파이프 이름 만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="8f7a44453028015a36d7371b079e0572cb894294" translate="yes" xml:space="preserve">
          <source>Angular packages</source>
          <target state="translated">앵귤러 패키지</target>
        </trans-unit>
        <trans-unit id="6b8abf66079d4d2aea96a3f990cecede4a31001d" translate="yes" xml:space="preserve">
          <source>Angular picks a simpler, faster change detection algorithm when you use a pipe.</source>
          <target state="translated">파이프를 사용할 때 Angular는 더 간단하고 빠른 변경 감지 알고리즘을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="ef398c20fe5cffcede85fd0486274f77bc4fc926" translate="yes" xml:space="preserve">
          <source>Angular pipes can help you with internationalization: the &lt;code&gt;&lt;a href=&quot;../api/common/datepipe&quot;&gt;DatePipe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/common/currencypipe&quot;&gt;CurrencyPipe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/common/decimalpipe&quot;&gt;DecimalPipe&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/common/percentpipe&quot;&gt;PercentPipe&lt;/a&gt;&lt;/code&gt; use locale data to format data based on the &lt;code&gt;&lt;a href=&quot;../api/core/locale_id&quot;&gt;LOCALE_ID&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">각도 파이프는 국제화에 도움을 줄 수 있습니다. &lt;code&gt;&lt;a href=&quot;../api/common/datepipe&quot;&gt;DatePipe&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/common/currencypipe&quot;&gt;CurrencyPipe&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/common/decimalpipe&quot;&gt;DecimalPipe&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/common/percentpipe&quot;&gt;PercentPipe&lt;/a&gt;&lt;/code&gt; 는 로케일 데이터를 사용하여 &lt;code&gt;&lt;a href=&quot;../api/core/locale_id&quot;&gt;LOCALE_ID&lt;/a&gt;&lt;/code&gt; 에 따라 데이터를 형식화합니다 .</target>
        </trans-unit>
        <trans-unit id="356e1f5698485995ec39cd81b77ba95feef0a58a" translate="yes" xml:space="preserve">
          <source>Angular pipes let you declare display-value transformations in your template HTML. A class with the &lt;code&gt;@&lt;a href=&quot;../api/core/pipe&quot;&gt;Pipe&lt;/a&gt;&lt;/code&gt; decorator defines a function that transforms input values to output values for display in a view.</source>
          <target state="translated">각도 파이프를 사용하면 템플릿 HTML에서 표시 값 변환을 선언 할 수 있습니다. &lt;code&gt;@&lt;a href=&quot;../api/core/pipe&quot;&gt;Pipe&lt;/a&gt;&lt;/code&gt; 데코레이터가 있는 클래스 는 뷰에 표시하기 위해 입력 값을 출력 값으로 변환하는 함수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4a45524e5e1533679255725c285e1a9a90ce6d59" translate="yes" xml:space="preserve">
          <source>Angular previously has supported an integration with the &lt;a href=&quot;https://google.github.io/tracing-framework/&quot;&gt;Web Tracing Framework (WTF)&lt;/a&gt; for performance testing of Angular applications. This integration has not been maintained and defunct. As a result, the integration was deprecated in Angular version 8 and due to no evidence of any existing usage removed in version 9.</source>
          <target state="translated">Angular는 이전 에 Angular 응용 프로그램의 성능 테스트를 위해 &lt;a href=&quot;https://google.github.io/tracing-framework/&quot;&gt;WTF (Web Tracing Framework)&lt;/a&gt; 와의 통합을 지원했습니다 . 이 통합은 유지되지 않고 없어졌습니다. 결과적으로 통합은 Angular 버전 8에서 더 이상 사용되지 않으며 버전 9에서 제거 된 기존 사용에 대한 증거가 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="991be4c3543e8e594fad4f932af19f57bb79c179" translate="yes" xml:space="preserve">
          <source>Angular previously has supported an integration with the Web Tracing Framework (WTF) for performance testing of Angular applications. This integration has not been maintained and likely does not work for the majority of Angular applications today. As a result, we are deprecating the integration in Angular version 8.</source>
          <target state="translated">Angular는 이전에 Angular 응용 프로그램의 성능 테스트를 위해 WTF (Web Tracing Framework)와의 통합을 지원했습니다. 이 통합은 유지되지 않았으며 오늘날 대부분의 Angular 응용 프로그램에서는 작동하지 않을 수 있습니다. 결과적으로 Angular 버전 8의 통합은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98ad75656ac46547061cbdeae1e7061decebb700" translate="yes" xml:space="preserve">
          <source>Angular previously supported a view encapsulation mode &lt;code&gt;ViewEncapsulaion.Native&lt;/code&gt; that was based on the v0 Shadow DOM Draft APIs. These APIs have been superceeded by the final Shadow DOM APIs, which are enabled via &lt;code&gt;&lt;a href=&quot;../api/core/viewencapsulation#ShadowDom&quot;&gt;ViewEncapsulation.ShadowDom&lt;/a&gt;&lt;/code&gt;. For background information about this change, see &lt;a href=&quot;https://developers.google.com/web/updates/2019/07/web-components-time-to-upgrade&quot;&gt;Web Components update: more time to upgrade to v1 APIs&lt;/a&gt;.</source>
          <target state="translated">각도는 이전에 볼 캡슐화 모드 지원 &lt;code&gt;ViewEncapsulaion.Native&lt;/code&gt; V0 그림자 DOM 초안 API를 기반으로했다. 이러한 API는 &lt;code&gt;&lt;a href=&quot;../api/core/viewencapsulation#ShadowDom&quot;&gt;ViewEncapsulation.ShadowDom&lt;/a&gt;&lt;/code&gt; 을 통해 활성화되는 최종 Shadow DOM API로 대체되었습니다 . 이 변경 사항에 대한 배경 정보는 &lt;a href=&quot;https://developers.google.com/web/updates/2019/07/web-components-time-to-upgrade&quot;&gt;웹 구성 요소 업데이트 : v1 API로 업그레이드하는 데 더 많은 시간을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ab7532910f8e47c865be64a0bfffac882f25041" translate="yes" xml:space="preserve">
          <source>Angular processes &lt;em&gt;all&lt;/em&gt; data bindings once for each JavaScript event cycle, from the root of the application component tree through all child components.</source>
          <target state="translated">Angular 는 응용 프로그램 구성 요소 트리의 루트에서 모든 하위 구성 요소에 이르기까지 각 JavaScript 이벤트주기마다 한 번씩 &lt;em&gt;모든&lt;/em&gt; 데이터 바인딩을 처리 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4bfe0e1a65f34be08732e68dc2f47387fc26057f" translate="yes" xml:space="preserve">
          <source>Angular provides a built-in module loader that supports SystemJS to load modules asynchronously. If you were using another bundling tool, such as Webpack, you would use the Webpack mechanism for asynchronously loading modules.</source>
          <target state="translated">Angular는 SystemJS를 지원하여 모듈을 비동기식으로로드하는 내장 모듈 로더를 제공합니다. Webpack과 같은 다른 번들링 도구를 사용하는 경우 모듈을 비동기식으로로드하기 위해 Webpack 메커니즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c71dd9205f0bd6822569474cf04a436f39b8d809" translate="yes" xml:space="preserve">
          <source>Angular provides a framework for single-page apps, where most of the logic and data resides on the client. Most apps still need to access a server using the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; to access and save data. For some platforms and applications, you might also want to use the PWA (Progressive Web App) model to improve the user experience.</source>
          <target state="translated">Angular는 대부분의 논리와 데이터가 클라이언트에있는 단일 페이지 앱용 프레임 워크를 제공합니다. 대부분의 앱은 여전히 데이터에 액세스하고 저장하기 위해 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 를 사용하여 서버에 액세스해야합니다 . 일부 플랫폼 및 애플리케이션의 경우 PWA (Progressive Web App) 모델을 사용하여 사용자 경험을 개선 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="26ab5724f97b042d8e6c3e60e5d984f689e157a5" translate="yes" xml:space="preserve">
          <source>Angular provides a number of built-in injection-token constants that you can use to customize the behavior of various systems.</source>
          <target state="translated">Angular는 다양한 시스템의 동작을 사용자 정의하는 데 사용할 수있는 여러 가지 기본 제공 주입 토큰 상수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b3c5e069bb7f86fbf8b8fc59544cf9cae9badc49" translate="yes" xml:space="preserve">
          <source>Angular provides a set of schematics for use with the CLI. See the &lt;a href=&quot;cli&quot;&gt;Angular CLI command reference&lt;/a&gt;. The &lt;a href=&quot;cli/add&quot;&gt;&lt;code&gt;ng add&lt;/code&gt;&lt;/a&gt; command runs schematics as part of adding a library to your project. The &lt;a href=&quot;cli/generate&quot;&gt;&lt;code&gt;ng generate&lt;/code&gt;&lt;/a&gt; command runs schematics to create apps, libraries, and Angular code constructs.</source>
          <target state="translated">Angular는 CLI와 함께 사용할 회로도를 제공합니다. 참고 항목 &lt;a href=&quot;cli&quot;&gt;각도 CLI 명령 참조&lt;/a&gt; . &lt;a href=&quot;cli/add&quot;&gt; &lt;code&gt;ng add&lt;/code&gt; &lt;/a&gt; 명령은 프로젝트에 라이브러리를 추가 한 부분으로 회로도를 실행합니다. 는 &lt;a href=&quot;cli/generate&quot;&gt; &lt;code&gt;ng generate&lt;/code&gt; &lt;/a&gt; 응용 프로그램, 라이브러리 및 각도 코드 구조를 만들 명령을 실행 회로도를.</target>
        </trans-unit>
        <trans-unit id="542775cd7da8f6f4765aa0bb672705ccbe83ec20" translate="yes" xml:space="preserve">
          <source>Angular provides advanced capabilities for mobile apps, animation, internationalization, server-side rendering, and more.</source>
          <target state="translated">Angular는 모바일 앱, 애니메이션, 국제화, 서버 측 렌더링 등을위한 고급 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3de379101dcba483b91ed5758dac0e3158b96650" translate="yes" xml:space="preserve">
          <source>Angular provides an &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; class that is used when publishing values from a component through the &lt;a href=&quot;inputs-outputs#output&quot;&gt;&lt;code&gt;@Output()&lt;/code&gt; decorator&lt;/a&gt;. &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; extends &lt;a href=&quot;https://rxjs.dev/api/index/class/Subject&quot;&gt;RxJS &lt;code&gt;Subject&lt;/code&gt;&lt;/a&gt;, adding an &lt;code&gt;emit()&lt;/code&gt; method so it can send arbitrary values. When you call &lt;code&gt;emit()&lt;/code&gt;, it passes the emitted value to the &lt;code&gt;next()&lt;/code&gt; method of any subscribed observer.</source>
          <target state="translated">Angular는 &lt;a href=&quot;inputs-outputs#output&quot;&gt; &lt;code&gt;@Output()&lt;/code&gt; &lt;/a&gt; 데코레이터를 통해 구성 요소의 값을 게시 할 때 사용되는 &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; 클래스를 제공합니다 . &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; 는&lt;a href=&quot;https://rxjs.dev/api/index/class/Subject&quot;&gt; RxJS &lt;/a&gt; &lt;code&gt;Subject&lt;/code&gt; 를 확장 하여 임의의 값을 보낼 수 있도록 &lt;code&gt;emit()&lt;/code&gt; 메서드를 추가 합니다. &lt;code&gt;emit()&lt;/code&gt; 를 호출하면 내 보낸 값을 구독중인 관찰자 의 &lt;code&gt;next()&lt;/code&gt; 메서드에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="dd1639fcd16106284432fd62af8a0553b09d8af2" translate="yes" xml:space="preserve">
          <source>Angular provides an &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; class that is used when publishing values from a component through the &lt;a href=&quot;template-syntax#how-to-use-output&quot;&gt;&lt;code&gt;@Output()&lt;/code&gt; decorator&lt;/a&gt;. &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; extends &lt;a href=&quot;https://rxjs.dev/api/index/class/Subject&quot;&gt;RxJS &lt;code&gt;Subject&lt;/code&gt;&lt;/a&gt;, adding an &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter#emit&quot;&gt;emit()&lt;/a&gt;&lt;/code&gt; method so it can send arbitrary values. When you call &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter#emit&quot;&gt;emit()&lt;/a&gt;&lt;/code&gt;, it passes the emitted value to the &lt;code&gt;next()&lt;/code&gt; method of any subscribed observer.</source>
          <target state="translated">Angular는 &lt;a href=&quot;template-syntax#how-to-use-output&quot;&gt; &lt;code&gt;@Output()&lt;/code&gt; &lt;/a&gt; decorator를 통해 구성 요소에서 값을 게시 할 때 사용되는 &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; 클래스를 제공합니다 . &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter&quot;&gt;EventEmitter&lt;/a&gt;&lt;/code&gt; 는&lt;a href=&quot;https://rxjs.dev/api/index/class/Subject&quot;&gt; RxJS &lt;/a&gt; &lt;code&gt;Subject&lt;/code&gt; 를 확장 하여 &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter#emit&quot;&gt;emit()&lt;/a&gt;&lt;/code&gt; 메소드를 추가하여 임의의 값을 보낼 수 있습니다. &lt;code&gt;&lt;a href=&quot;../api/core/eventemitter#emit&quot;&gt;emit()&lt;/a&gt;&lt;/code&gt; 를 호출 하면 방출 된 값을 구독 된 옵저버 의 &lt;code&gt;next()&lt;/code&gt; 메소드로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="dd1128121ec9058a99f03a8e0d5165e2fca8f13c" translate="yes" xml:space="preserve">
          <source>Angular provides built-in pipes for typical data transformations, including transformations for internationalization (i18n), which use locale information to format data. The following are commonly used built-in pipes for data formatting:</source>
          <target state="translated">Angular는 로케일 정보를 사용하여 데이터 형식을 지정하는 국제화 (i18n) 변환을 포함하여 일반적인 데이터 변환을위한 내장 파이프를 제공합니다. 다음은 데이터 형식화에 일반적으로 사용되는 내장 파이프입니다.</target>
        </trans-unit>
        <trans-unit id="3ee46a639825d9725e9da43cb62b0f60f904e60a" translate="yes" xml:space="preserve">
          <source>Angular provides many kinds of data-binding. Binding types can be grouped into three categories distinguished by the direction of data flow:</source>
          <target state="translated">Angular는 많은 종류의 데이터 바인딩을 제공합니다. 바인딩 유형은 데이터 흐름 방향으로 구별되는 세 가지 범주로 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb6bbbf3a5e95ea73ec84dc48e2d08bd47f217b5" translate="yes" xml:space="preserve">
          <source>Angular provides some builders that are used by the CLI for commands such as &lt;code&gt;ng build&lt;/code&gt;, &lt;code&gt;ng test&lt;/code&gt;, and &lt;code&gt;ng lint&lt;/code&gt;. Default target configurations for these and other built-in CLI builders can be found (and customized) in the &quot;architect&quot; section of the &lt;a href=&quot;workspace-config&quot;&gt;workspace configuration file&lt;/a&gt;, &lt;code&gt;angular.json&lt;/code&gt;. You can also extend and customize Angular by creating your own builders, which you can run using the &lt;a href=&quot;cli/run&quot;&gt;&lt;code&gt;ng run&lt;/code&gt; CLI command&lt;/a&gt;.</source>
          <target state="translated">Angular는 CLI에서 &lt;code&gt;ng build&lt;/code&gt; , &lt;code&gt;ng test&lt;/code&gt; 및 &lt;code&gt;ng lint&lt;/code&gt; 와 같은 명령에 사용하는 일부 빌더를 제공합니다 . 빌더가의 &quot;건축가&quot;섹션에서 찾을 (및 사용자 정의) 할 수 있습니다 CLI 내장 이러한 및 기타의 기본 목표 설정 &lt;a href=&quot;workspace-config&quot;&gt;작업 공간 구성 파일&lt;/a&gt; , &lt;code&gt;angular.json&lt;/code&gt; . &lt;a href=&quot;cli/run&quot;&gt; &lt;code&gt;ng run&lt;/code&gt; CLI 명령을&lt;/a&gt; 사용하여 실행할 수있는 자체 빌더를 작성하여 Angular를 확장하고 사용자 정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54e1fe50f3cab60a422c1f61c16b90ad321a060b" translate="yes" xml:space="preserve">
          <source>Angular provides some injectable abstractions over these objects, such as &lt;a href=&quot;../api/common/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../api/common/document&quot;&gt;&lt;code&gt;DOCUMENT&lt;/code&gt;&lt;/a&gt;; it may substitute adequately for these APIs. If Angular doesn't provide it, it's possible to write new abstractions that delegate to the browser APIs while in the browser and to an alternative implementation while on the server (aka shimming).</source>
          <target state="translated">Angular는 &lt;a href=&quot;../api/common/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../api/common/document&quot;&gt; &lt;code&gt;DOCUMENT&lt;/code&gt; &lt;/a&gt; 와 같은 이러한 객체에 대한 주사 가능한 추상화를 제공합니다 . 이러한 API를 적절히 대체 할 수 있습니다. Angular가 제공하지 않으면 브라우저에있는 동안 브라우저 API에 위임하고 서버에있는 대체 구현 (일명 shimming)에 위임하는 새로운 추상화를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d8f440b029f6084e216f022e4aad088e8ed5e77" translate="yes" xml:space="preserve">
          <source>Angular provides the &lt;code&gt;&lt;a href=&quot;../api/elements/createcustomelement&quot;&gt;createCustomElement&lt;/a&gt;()&lt;/code&gt; function for converting an Angular component, together with its dependencies, to a custom element. The function collects the component's observable properties, along with the Angular functionality the browser needs to create and destroy instances, and to detect and respond to changes.</source>
          <target state="translated">Angular는 Angular 구성 요소를 종속성과 함께 사용자 지정 요소로 변환하기위한 &lt;code&gt;&lt;a href=&quot;../api/elements/createcustomelement&quot;&gt;createCustomElement&lt;/a&gt;()&lt;/code&gt; 함수를 제공합니다 . 이 함수는 브라우저가 인스턴스를 생성 및 제거하고 변경 사항을 감지하고 응답하는 데 필요한 Angular 기능과 함께 구성 요소의 관찰 가능한 속성을 수집합니다.</target>
        </trans-unit>
        <trans-unit id="75ebcd58fdf52db86f77be2b9791ff7cb86491f4" translate="yes" xml:space="preserve">
          <source>Angular provides the following built-in data transformation &lt;a href=&quot;glossary#pipe&quot;&gt;pipes&lt;/a&gt; that use the &lt;a href=&quot;../api/core/locale_id&quot;&gt;&lt;code&gt;LOCALE_ID&lt;/code&gt;&lt;/a&gt; token to format data according to the locale's rules:</source>
          <target state="translated">Angular는 &lt;a href=&quot;../api/core/locale_id&quot;&gt; &lt;code&gt;LOCALE_ID&lt;/code&gt; &lt;/a&gt; 토큰을 사용 하여 로케일 규칙에 따라 데이터 형식을 지정 하는 다음과 같은 기본 제공 데이터 변환 &lt;a href=&quot;glossary#pipe&quot;&gt;파이프&lt;/a&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="30e1cd4051db96810a5d5e1dbab2055cb8d90a11" translate="yes" xml:space="preserve">
          <source>Angular provides two different approaches to handling user input through forms: reactive and template-driven. Both capture user input events from the view, validate the user input, create a form model and data model to update, and provide a way to track changes.</source>
          <target state="translated">Angular는 양식을 통해 사용자 입력을 처리하는 두 가지 접근 방식 (반응 형 및 템플릿 기반)을 제공합니다. 둘 다보기에서 사용자 입력 이벤트를 캡처하고 사용자 입력을 유효성 검증하며 업데이트 할 양식 모델 및 데이터 모델을 작성하며 변경 사항을 추적하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="37e085544dc51dc2350db34c85e0ac7c2f1de728" translate="yes" xml:space="preserve">
          <source>Angular receives a large number of feature requests, both from inside Google and from the broader open-source community. At the same time, our list of projects contains plenty of maintenance tasks, code refactorings, potential performance improvements, and so on. We bring together representatives from developer relations, product management, and engineering to prioritize this list. As new projects come into the queue, we regularly position them based on relative priority to other projects. As work gets done, projects will move up in the queue.</source>
          <target state="translated">Angular는 Google 내부와 더 광범위한 오픈 소스 커뮤니티에서 많은 기능 요청을받습니다. 동시에 프로젝트 목록에는 많은 유지 관리 작업, 코드 리팩토링, 잠재적 인 성능 향상 등이 포함됩니다. 개발자 관계, 제품 관리 및 엔지니어링 담당자를한데 모아이 목록의 우선 순위를 정합니다. 새로운 프로젝트가 대기열에 들어 오면 다른 프로젝트에 대한 상대적 우선 순위에 따라 정기적으로 배치합니다. 작업이 완료되면 프로젝트가 대기열에서 위로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="4023aa2209d987433d511efd5c6272087b321931" translate="yes" xml:space="preserve">
          <source>Angular recognizes the directive's role in the validation process because the directive registers itself with the &lt;code&gt;&lt;a href=&quot;../api/forms/ng_validators&quot;&gt;NG_VALIDATORS&lt;/a&gt;&lt;/code&gt; provider, a provider with an extensible collection of validators.</source>
          <target state="translated">Angular는 유효성 검사 프로세스에서 지시문의 역할을 인식합니다. 지시문 은 확장 가능한 유효성 검사기 모음이있는 제공자 인 &lt;code&gt;&lt;a href=&quot;../api/forms/ng_validators&quot;&gt;NG_VALIDATORS&lt;/a&gt;&lt;/code&gt; 제공자에 등록되기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="879357b8bc87f50bec4b8b9fdc77c6180285e7e6" translate="yes" xml:space="preserve">
          <source>Angular recognizes the directive's role in the validation process because the directive registers itself with the &lt;code&gt;&lt;a href=&quot;../api/forms/ng_validators&quot;&gt;NG_VALIDATORS&lt;/a&gt;&lt;/code&gt; provider, as shown in the following example. &lt;code&gt;&lt;a href=&quot;../api/forms/ng_validators&quot;&gt;NG_VALIDATORS&lt;/a&gt;&lt;/code&gt; is a predefined provider with an extensible collection of validators.</source>
          <target state="translated">Angular 는 다음 예제와 같이 지시문이 &lt;code&gt;&lt;a href=&quot;../api/forms/ng_validators&quot;&gt;NG_VALIDATORS&lt;/a&gt;&lt;/code&gt; 공급자에 등록되기 때문에 유효성 검사 프로세스에서 지시문의 역할을 인식합니다 . &lt;code&gt;&lt;a href=&quot;../api/forms/ng_validators&quot;&gt;NG_VALIDATORS&lt;/a&gt;&lt;/code&gt; 는 확장 가능한 유효성 검사기 컬렉션이있는 미리 정의 된 공급자입니다.</target>
        </trans-unit>
        <trans-unit id="378a56a09a2bc8c55214ba40b10672b984ed51c4" translate="yes" xml:space="preserve">
          <source>Angular recognizes the value as unsafe and automatically sanitizes it, which removes the &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag but keeps safe content such as the &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; element.</source>
          <target state="translated">Angular는 값을 안전하지 않은 것으로 인식하고 자동으로 삭제하여 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그 를 제거 하지만 &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; 요소 와 같은 안전한 내용은 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="a124b894fc0aadcd5a3d3d6b85932c692b5117df" translate="yes" xml:space="preserve">
          <source>Angular registers all startup module providers with the application root injector. The services that root injector providers create have application scope, which means they are available to the entire application.</source>
          <target state="translated">Angular는 모든 시작 모듈 공급자를 응용 프로그램 루트 인젝터에 등록합니다. 루트 인젝터 공급자가 만드는 서비스에는 응용 프로그램 범위가 있으므로 전체 응용 프로그램에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="925daa517f76b33161b91ea28daef5e4bea3e10e" translate="yes" xml:space="preserve">
          <source>Angular registers its own providers with every injector, for services that Angular defines. You can register your own providers for services that your app needs.</source>
          <target state="translated">Angular는 Angular가 정의한 서비스를 위해 모든 인젝터에 자체 공급자를 등록합니다. 앱에 필요한 서비스에 대해 고유 한 공급자를 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63df769c252c01cddc5b9fc4a5c36530656fab5b" translate="yes" xml:space="preserve">
          <source>Angular registers these providers with the NgModule's injector. If it is the NgModule used for bootstrapping then it is the root injector.</source>
          <target state="translated">Angular는 이러한 제공자를 NgModule의 인젝터에 등록합니다. 부트 스트랩에 사용되는 NgModule 인 경우 루트 인젝터입니다.</target>
        </trans-unit>
        <trans-unit id="94f603c4b0f5b4c970534ab64ea69e7b16cf94f8" translate="yes" xml:space="preserve">
          <source>Angular relies on the &lt;code&gt;&lt;a href=&quot;../api/core/debugelement&quot;&gt;DebugElement&lt;/a&gt;&lt;/code&gt; abstraction to work safely across &lt;em&gt;all supported platforms&lt;/em&gt;. Instead of creating an HTML element tree, Angular creates a &lt;code&gt;&lt;a href=&quot;../api/core/debugelement&quot;&gt;DebugElement&lt;/a&gt;&lt;/code&gt; tree that wraps the &lt;em&gt;native elements&lt;/em&gt; for the runtime platform. The &lt;code&gt;nativeElement&lt;/code&gt; property unwraps the &lt;code&gt;&lt;a href=&quot;../api/core/debugelement&quot;&gt;DebugElement&lt;/a&gt;&lt;/code&gt; and returns the platform-specific element object.</source>
          <target state="translated">Angular는 &lt;em&gt;지원되는 모든 플랫폼에서&lt;/em&gt; 안전하게 작동하기 위해 &lt;code&gt;&lt;a href=&quot;../api/core/debugelement&quot;&gt;DebugElement&lt;/a&gt;&lt;/code&gt; 추상화 에 의존 &lt;em&gt;합니다&lt;/em&gt; . Angular는 HTML 요소 트리를 만드는 대신 런타임 플랫폼 의 &lt;em&gt;기본 요소&lt;/em&gt; 를 래핑 하는 &lt;code&gt;&lt;a href=&quot;../api/core/debugelement&quot;&gt;DebugElement&lt;/a&gt;&lt;/code&gt; 트리를 만듭니다 . &lt;code&gt;nativeElement&lt;/code&gt; 의 속성은 언랩 &lt;code&gt;&lt;a href=&quot;../api/core/debugelement&quot;&gt;DebugElement&lt;/a&gt;&lt;/code&gt; 을 하고 플랫폼 별 요소 개체를 반환합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6599d35b316da91d120de3a4ffc0e370ef3d5559" translate="yes" xml:space="preserve">
          <source>Angular relies on zone.js to run Angular's change detection processes when native JavaScript operations raise events. Zone.js is an implementation of a &lt;a href=&quot;https://gist.github.com/mhevery/63fdcdf7c65886051d55&quot;&gt;specification&lt;/a&gt; currently before the &lt;a href=&quot;http://www.ecma-international.org/memento/TC39.htm&quot;&gt;TC39&lt;/a&gt; committee that determines standards for the JavaScript language.</source>
          <target state="translated">Angular는 zone.js를 사용하여 기본 JavaScript 작업이 이벤트를 발생시킬 때 Angular의 변경 감지 프로세스를 실행합니다. Zone.js는 현재 &lt;a href=&quot;http://www.ecma-international.org/memento/TC39.htm&quot;&gt;TC39&lt;/a&gt; 위원회 이전 에 JavaScript 언어의 표준을 결정 하는 &lt;a href=&quot;https://gist.github.com/mhevery/63fdcdf7c65886051d55&quot;&gt;사양을&lt;/a&gt; 구현 한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="f56aade6b82e2c3943e565652c5c962cb68a983c" translate="yes" xml:space="preserve">
          <source>Angular relies on zone.js to run Angular's change detection processes when native JavaScript operations raise events. Zone.js is an implementation of a &lt;a href=&quot;https://gist.github.com/mhevery/63fdcdf7c65886051d55&quot;&gt;specification&lt;/a&gt; currently before the &lt;a href=&quot;https://www.ecma-international.org/memento/tc39.htm&quot;&gt;TC39&lt;/a&gt; committee that determines standards for the JavaScript language.</source>
          <target state="translated">Angular는 zone.js를 사용하여 네이티브 JavaScript 작업이 이벤트를 발생시킬 때 Angular의 변경 감지 프로세스를 실행합니다. Zone.js는 JavaScript 언어에 대한 표준을 결정 하는 &lt;a href=&quot;https://www.ecma-international.org/memento/tc39.htm&quot;&gt;TC39&lt;/a&gt; 위원회 이전에 현재 &lt;a href=&quot;https://gist.github.com/mhevery/63fdcdf7c65886051d55&quot;&gt;사양을&lt;/a&gt; 구현 한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="400c95b463a974784a617426bfeda0f26de33b43" translate="yes" xml:space="preserve">
          <source>Angular requires &lt;code&gt;Node.js&lt;/code&gt; version 10.9.0 or later.</source>
          <target state="translated">Angular에는 &lt;code&gt;Node.js&lt;/code&gt; 버전 10.9.0 이상이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="180d82d0fbc33b0db02ba4e56262d98745427882" translate="yes" xml:space="preserve">
          <source>Angular requires a &lt;a href=&quot;https://nodejs.org/about/releases&quot;&gt;current, active LTS, or maintenance LTS&lt;/a&gt; version of Node.js.</source>
          <target state="translated">Angular에는 Node.js 의 &lt;a href=&quot;https://nodejs.org/about/releases&quot;&gt;최신 활성 LTS 또는 유지 관리 LTS&lt;/a&gt; 버전이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="77c29c47b48c888b5c8e2dc0ff189a4e742ddaee" translate="yes" xml:space="preserve">
          <source>Angular retrieves the changed text by following the path &lt;code&gt;$event.target.value&lt;/code&gt; and updates the &lt;code&gt;name&lt;/code&gt; property.</source>
          <target state="translated">Angular는 &lt;code&gt;$event.target.value&lt;/code&gt; 경로를 따라 변경된 텍스트를 검색하고 &lt;code&gt;name&lt;/code&gt; 속성을 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="bef32477f038457ec76edcd6fb2cb0f29b6948d9" translate="yes" xml:space="preserve">
          <source>Angular sanitizes untrusted values for HTML, styles, and URLs; sanitizing resource URLs isn't possible because they contain arbitrary code. In development mode, Angular prints a console warning when it has to change a value during sanitization.</source>
          <target state="translated">Angular는 HTML, 스타일 및 URL에 대해 신뢰할 수없는 값을 삭제합니다. 리소스 URL에 임의의 코드가 포함되어있어 살균 할 수 없습니다. 개발 모드에서 Angular는 살균 중에 값을 변경해야 할 때 콘솔 경고를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="95d6c94f88761a819224e7f7ef31c0e016974ef3" translate="yes" xml:space="preserve">
          <source>Angular service worker introduction</source>
          <target state="translated">앵귤러 서비스 작업자 소개</target>
        </trans-unit>
        <trans-unit id="ece6de84f6157a2281fd204f372508b6e8936e9e" translate="yes" xml:space="preserve">
          <source>Angular sets the &lt;code&gt;appUnless&lt;/code&gt; property whenever the value of the condition changes. Because the &lt;code&gt;appUnless&lt;/code&gt; property does work, it needs a setter.</source>
          <target state="translated">Angular는 조건 값이 변경 될 때마다 &lt;code&gt;appUnless&lt;/code&gt; 속성을 설정합니다 . &lt;code&gt;appUnless&lt;/code&gt; 속성이 작동 하기 때문에 setter가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b48433aa9a27d0daa63f87a6c53ae76ff80c318e" translate="yes" xml:space="preserve">
          <source>Angular sets the constructor's &lt;code&gt;el&lt;/code&gt; parameter to the injected &lt;code&gt;&lt;a href=&quot;../api/core/elementref&quot;&gt;ElementRef&lt;/a&gt;&lt;/code&gt;. (An &lt;code&gt;&lt;a href=&quot;../api/core/elementref&quot;&gt;ElementRef&lt;/a&gt;&lt;/code&gt; is a wrapper around a DOM element, whose &lt;code&gt;nativeElement&lt;/code&gt; property exposes the DOM element for the directive to manipulate.)</source>
          <target state="translated">Angular는 생성자의 &lt;code&gt;el&lt;/code&gt; 매개 변수를 주입 된 &lt;code&gt;&lt;a href=&quot;../api/core/elementref&quot;&gt;ElementRef&lt;/a&gt;&lt;/code&gt; 로 설정 합니다. ( &lt;code&gt;&lt;a href=&quot;../api/core/elementref&quot;&gt;ElementRef&lt;/a&gt;&lt;/code&gt; DOM 요소, 래퍼이다 &lt;code&gt;nativeElement&lt;/code&gt; 속성 지시어 조작 대상의 DOM 요소를 노출시킨다.)</target>
        </trans-unit>
        <trans-unit id="0897472d9acb678fe4ea07d3a7bc055bd1af6070" translate="yes" xml:space="preserve">
          <source>Angular ships as a collection of JavaScript modules (also called libraries). Each Angular library name begins with the &lt;code&gt;@angular&lt;/code&gt; prefix. Install Angular libraries with the &lt;a href=&quot;https://docs.npmjs.com/getting-started/what-is-npm&quot;&gt;npm package manager&lt;/a&gt; and import parts of them with JavaScript &lt;code&gt;import&lt;/code&gt; declarations.</source>
          <target state="translated">Angular는 JavaScript 모듈 (라이브러리라고도 함)의 모음으로 제공됩니다. 각 Angular 라이브러리 이름은 &lt;code&gt;@angular&lt;/code&gt; 접두사로 시작 합니다. &lt;a href=&quot;https://docs.npmjs.com/getting-started/what-is-npm&quot;&gt;npm 패키지 관리자로&lt;/a&gt; Angular 라이브러리를 설치 하고 JavaScript &lt;code&gt;import&lt;/code&gt; 선언으로 라이브러리의 일부를 가져 오십시오 .</target>
        </trans-unit>
        <trans-unit id="c2ed54e54eda3c09a0744999f1f67eb581505b10" translate="yes" xml:space="preserve">
          <source>Angular simplifies the following aspects of internationalization:</source>
          <target state="translated">Angular는 다음과 같은 국제화 측면을 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="0b4571fc697e46d0f07cb794315e2abe97a50faa" translate="yes" xml:space="preserve">
          <source>Angular strives to balance innovation and stability. Sometimes, APIs and features become obsolete and need to be removed or replaced so that Angular can stay current with new best practices, changing dependencies, or changes in the (web) platform itself.</source>
          <target state="translated">Angular는 혁신과 안정성의 균형을 유지하기 위해 노력합니다. 때로는 API와 기능이 더 이상 사용되지 않아 Angular가 새로운 모범 사례, 종속성 변경 또는 (웹) 플랫폼 자체의 변경 사항을 최신 상태로 유지할 수 있도록 제거하거나 교체해야합니다.</target>
        </trans-unit>
        <trans-unit id="5b3dd1bbaa7482ecb455dc8c4b78b8e67ed96278" translate="yes" xml:space="preserve">
          <source>Angular supplies a number of built-in directives that begin with the &lt;code&gt;ng&lt;/code&gt; prefix. You can also create new directives to implement your own functionality. You associate a &lt;em&gt;selector&lt;/em&gt; (an HTML tag such as &lt;code&gt;&amp;lt;my-directive&amp;gt;&lt;/code&gt;) with a custom directive, thereby extending the &lt;a href=&quot;template-syntax&quot;&gt;template syntax&lt;/a&gt; that you can use in your apps.</source>
          <target state="translated">Angular는 &lt;code&gt;ng&lt;/code&gt; 접두사로 시작하는 많은 내장 지시문을 제공합니다 . 고유 한 기능을 구현하기 위해 새 지시문을 작성할 수도 있습니다. 당신은 연결 &lt;em&gt;선택기를&lt;/em&gt; (HTML 태그 등 &lt;code&gt;&amp;lt;my-directive&amp;gt;&lt;/code&gt; 하여 확장, 사용자 정의 지시어로) &lt;a href=&quot;template-syntax&quot;&gt;템플릿 구문&lt;/a&gt; 당신이 당신의 응용 프로그램에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bd39507a08adc6ad5177ae79d86f8ce148fdf68" translate="yes" xml:space="preserve">
          <source>Angular supports &lt;em&gt;two-way data binding&lt;/em&gt;, a mechanism for coordinating the parts of a template with the parts of a component. Add binding markup to the template HTML to tell Angular how to connect both sides.</source>
          <target state="translated">Angular는 &lt;em&gt;양방향 데이터 바인딩을&lt;/em&gt; 지원합니다. &lt;em&gt;이 방법&lt;/em&gt; 은 템플릿의 일부를 구성 요소의 일부와 조정하는 메커니즘입니다. 템플릿 HTML에 바인딩 마크 업을 추가하여 Angular에 양면 연결 방법을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="7ea371269e61139c2a9831641c5589131284de96" translate="yes" xml:space="preserve">
          <source>Angular supports most recent browsers. This includes the following specific versions:</source>
          <target state="translated">Angular는 최신 브라우저를 지원합니다. 여기에는 다음과 같은 특정 버전이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="007574459f34a1d4f369b68122eeaa0b0e8c282f" translate="yes" xml:space="preserve">
          <source>Angular supports two design approaches for interactive forms. You can build forms by writing templates using Angular &lt;a href=&quot;glossary#template&quot;&gt;template syntax and directives&lt;/a&gt; with the form-specific directives and techniques described in this tutorial, or you can use a reactive (or model-driven) approach to build forms.</source>
          <target state="translated">Angular는 대화 형 양식에 대해 두 가지 디자인 접근 방식을 지원합니다. 이 자습서에 설명 된 양식 별 지시문 및 기술과 함께 Angular &lt;a href=&quot;glossary#template&quot;&gt;템플릿 구문 및 지시문&lt;/a&gt; 을 사용하여 템플릿을 작성하여 양식을 작성 하거나 반응 적 (또는 모델 기반) 접근 방식을 사용하여 양식을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8e04243c1697b41d29fbfba8b823298c738e03c" translate="yes" xml:space="preserve">
          <source>Angular templates are &lt;em&gt;dynamic&lt;/em&gt;. When Angular renders them, it transforms the DOM according to the instructions given by &lt;em&gt;directives&lt;/em&gt;. A directive is a class with a &lt;code&gt;@&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;()&lt;/code&gt; decorator.</source>
          <target state="translated">각도 템플릿은 &lt;em&gt;동적&lt;/em&gt; 입니다. Angular가 렌더링 할 때, &lt;em&gt;지시문이&lt;/em&gt; 제공 한 &lt;em&gt;지시&lt;/em&gt; 사항에 따라 DOM을 변환합니다 . 지시문은 &lt;code&gt;@&lt;a href=&quot;../api/core/directive&quot;&gt;Directive&lt;/a&gt;()&lt;/code&gt; 데코레이터 가있는 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="75360540a862cda10bfe5d3cc9e4e3d8b9249e08" translate="yes" xml:space="preserve">
          <source>Angular throws a cyclic dependency error if you omit the &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;&lt;/code&gt; decorator.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;&lt;/code&gt; 데코레이터 를 생략하면 Angular에서 주기적 종속성 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="dffe45e60da8df6adcbb8bd717d7b920a8f70a40" translate="yes" xml:space="preserve">
          <source>Angular throws an error if the hook updates the component's data-bound &lt;code&gt;comment&lt;/code&gt; property immediately (try it!). The &lt;code&gt;LoggerService.tick_then()&lt;/code&gt; postpones the log update for one turn of the browser's JavaScript cycle and that's just long enough.</source>
          <target state="translated">후크가 구성 요소의 데이터 바인딩 된 &lt;code&gt;comment&lt;/code&gt; 속성을 즉시 업데이트하면 오류가 발생 합니다 (시도하십시오!). &lt;code&gt;LoggerService.tick_then()&lt;/code&gt; 브라우저의 자바 스크립트주기의 한 차례의 로그 업데이트를 연기하고는 충분히 있습니다.</target>
        </trans-unit>
        <trans-unit id="e332f37242cc9fcbbae5b381770424eb2cc4ab0e" translate="yes" xml:space="preserve">
          <source>Angular throws an error if you haven't also decorated the property with &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;()&lt;/code&gt;. When the property is marked as optional, Angular sets &lt;code&gt;loggerService&lt;/code&gt; to null and the rest of the component adapts.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;()&lt;/code&gt; 속성을 장식하지 않으면 Angular에서 오류가 발생합니다 . 특성이 선택적으로 표시되면 Angular는 &lt;code&gt;loggerService&lt;/code&gt; 를 널로 설정 하고 나머지 구성 요소는 적응합니다.</target>
        </trans-unit>
        <trans-unit id="5e4db9368e884831e9e20c6790dc42c39f7b1964" translate="yes" xml:space="preserve">
          <source>Angular transforms the &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; in similar fashion from asterisk (*) syntax to &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt;&lt;em&gt;element&lt;/em&gt;.</source>
          <target state="translated">Angular 는 별표 (*) 구문에서 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; &lt;em&gt;요소&lt;/em&gt; 와 유사한 방식으로 &lt;code&gt;*&lt;a href=&quot;../api/common/ngforof&quot;&gt;ngFor&lt;/a&gt;&lt;/code&gt; 를 변환합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e67e3de40fe95a8c00d4dd1bff2697445d28684b" translate="yes" xml:space="preserve">
          <source>Angular translates this instruction into an &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; around the host element, then uses this template repeatedly to create a new set of elements and bindings for each &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; in the list. For more information about microsyntax, see the &lt;a href=&quot;structural-directives#microsyntax&quot;&gt;Structural Directives&lt;/a&gt; guide.</source>
          <target state="translated">Angular는이 명령어를 호스트 요소 주위의 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 으로 변환 한 다음이 템플릿을 반복해서 사용 하여 목록의 각 &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; 에 대한 새 요소 세트와 바인딩을 만듭니다 . 마이크로 구문에 대한 자세한 정보는 &lt;a href=&quot;structural-directives#microsyntax&quot;&gt;Structural Directives&lt;/a&gt; 안내서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c282c74d23f70527b9a9a2fdef131f850048669" translate="yes" xml:space="preserve">
          <source>Angular translates this instruction into an &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; around the host element, then uses this template repeatedly to create a new set of elements and bindings for each &lt;code&gt;item&lt;/code&gt; in the list. For more information about microsyntax, see the &lt;a href=&quot;structural-directives#microsyntax&quot;&gt;Structural Directives&lt;/a&gt; guide.</source>
          <target state="translated">Angular는이 명령어를 호스트 요소 주변의 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 으로 변환 한 다음이 템플릿을 반복적으로 사용 하여 목록의 각 &lt;code&gt;item&lt;/code&gt; 에 대한 새 요소 및 바인딩 집합을 만듭니다 . 마이크로 구문에 대한 자세한 내용은 &lt;a href=&quot;structural-directives#microsyntax&quot;&gt;Structural Directives&lt;/a&gt; 가이드를 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="6f421782afe50f58ad1ed9fbccc815096a4e227d" translate="yes" xml:space="preserve">
          <source>Angular treats a nested expression in the same manner as an alternate expression, extracting it into two translation units. The first contains the text outside of the nested expression:</source>
          <target state="translated">Angular는 중첩 된 표현식을 대체 표현식과 동일한 방식으로 처리하여 두 개의 번역 단위로 추출합니다. 첫 번째는 중첩 된 표현식 외부의 텍스트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="d6acd0291e45c98173358bf8fc914f274d361be6" translate="yes" xml:space="preserve">
          <source>Angular updates the bindings (and therefore the screen) only if the app does something in response to asynchronous events, such as keystrokes. This example code binds the &lt;code&gt;keyup&lt;/code&gt; event to the number 0, the shortest template statement possible. While the statement does nothing useful, it satisfies Angular's requirement so that Angular will update the screen.</source>
          <target state="translated">Angular는 앱이 키 입력과 같은 비동기 이벤트에 대한 응답으로 무언가를 수행하는 경우에만 바인딩 (및 화면)을 업데이트합니다. 이 예제 코드는 &lt;code&gt;keyup&lt;/code&gt; 이벤트를 가능한 가장 짧은 템플릿 명령문 인 숫자 0에 바인딩 합니다. 이 문장은 아무 쓸모가 없지만 Angular가 화면을 업데이트하도록 Angular의 요구 사항을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="ab5ccc966eff22cc30bc6d91001c94c57cd1dec3" translate="yes" xml:space="preserve">
          <source>Angular updates the display every time the user adds a hero. If the user clicks the &lt;strong&gt;Reset&lt;/strong&gt; button, Angular replaces &lt;code&gt;heroes&lt;/code&gt; with a new array of the original heroes and updates the display. If you add the ability to remove or change a hero, Angular would detect those changes and update the display as well.</source>
          <target state="translated">Angular는 사용자가 영웅을 추가 할 때마다 디스플레이를 업데이트합니다. 사용자가 &lt;strong&gt;재설정&lt;/strong&gt; 버튼을 클릭하면 Angular는 &lt;code&gt;heroes&lt;/code&gt; 을 원래 영웅의 새로운 배열로 교체 하고 디스플레이를 업데이트합니다. 영웅을 제거하거나 변경하는 기능을 추가하면 Angular는 이러한 변경 사항을 감지하고 디스플레이도 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="550b4fe7f3f5d9e42a538e1d35676d32309e777c" translate="yes" xml:space="preserve">
          <source>Angular used to rely on the browser to provide number, date, and currency formatting using browser i18n APIs. This practice meant that most apps needed to use a polyfill, users were seeing inconsistent results across browsers, and common formats (such as the currency pipe) didn&amp;rsquo;t match developer expectations out of the box.</source>
          <target state="translated">Angular는 브라우저를 사용하여 브라우저 i18n API를 사용하여 숫자, 날짜 및 통화 형식을 제공합니다. 이 관행은 대부분의 앱이 폴리 필을 사용해야하고 사용자가 브라우저에서 일관되지 않은 결과를 보았으며 일반적인 형식 (예 : 통화 파이프)이 개발자의 기대치와 일치하지 않음을 의미했습니다.</target>
        </trans-unit>
        <trans-unit id="d6fa9d5a8d38e3d4d26da6cf34336adf1c339739" translate="yes" xml:space="preserve">
          <source>Angular used to sanitize &lt;code&gt;[&lt;a href=&quot;../api/animations/style&quot;&gt;style&lt;/a&gt;]&lt;/code&gt; and &lt;code&gt;[style.prop]&lt;/code&gt; bindings to prevent malicious code from being inserted through &lt;code&gt;javascript:&lt;/code&gt; expressions in CSS &lt;code&gt;url()&lt;/code&gt; entries. However, most modern browsers no longer support the usage of these expressions, so sanitization was only maintained for the sake of IE 6 and 7. Given that Angular does not support either IE 6 or 7 and sanitization has a performance cost, we will no longer sanitize style bindings as of version 10 of Angular.</source>
          <target state="translated">CSS &lt;code&gt;url()&lt;/code&gt; 항목의 &lt;code&gt;javascript:&lt;/code&gt; 표현식을 통해 악성 코드가 삽입되는 것을 방지하기 위해 &lt;code&gt;[&lt;a href=&quot;../api/animations/style&quot;&gt;style&lt;/a&gt;]&lt;/code&gt; 및 &lt;code&gt;[style.prop]&lt;/code&gt; 바인딩 을 삭제하는 데 사용되는 Angular 입니다. 그러나 대부분의 최신 브라우저는 더 이상 이러한 표현식의 사용을 지원하지 않으므로 삭제는 IE 6 및 7을 위해서만 유지되었습니다. Angular는 IE 6 또는 7을 지원하지 않고 삭제에 성능 비용이 발생하므로 더 이상 삭제하지 않습니다. Angular 버전 10부터 스타일 바인딩을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="d34417d3060d2e52591c5133c737a9fc73577780" translate="yes" xml:space="preserve">
          <source>Angular uses a third-party library called &lt;a href=&quot;http://reactivex.io/rxjs/&quot;&gt;Reactive Extensions (RxJS)&lt;/a&gt;.</source>
          <target state="translated">Angular는 &lt;a href=&quot;http://reactivex.io/rxjs/&quot;&gt;RxJS (Reactive Extensions)&lt;/a&gt; 라는 타사 라이브러리를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="238cd9c643f7186f47327fa3f20d86506d261bf2" translate="yes" xml:space="preserve">
          <source>Angular uses capitalization conventions to distinguish the names of various types, as described in the &lt;a href=&quot;styleguide#02-01&quot;&gt;naming guidelines section&lt;/a&gt; of the Style Guide. Here's a summary of the case types:</source>
          <target state="translated">Angular는 스타일 가이드 의 &lt;a href=&quot;styleguide#02-01&quot;&gt;명명 지침 섹션&lt;/a&gt; 에 설명 된대로 대문자 표기 규칙을 사용하여 다양한 유형의 이름을 구별합니다 . 사례 유형에 대한 요약은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b23d17cee636d84970f89a7ad98f26ce7fdce1aa" translate="yes" xml:space="preserve">
          <source>Angular uses object identity to select option. It's possible for the identities of items to change while the data does not. This can happen, for example, if the items are produced from an RPC to the server, and that RPC is re-run. Even if the data hasn't changed, the second response will produce objects with different identities.</source>
          <target state="translated">Angular는 객체 ID를 사용하여 옵션을 선택합니다. 데이터는 변경되지 않지만 항목의 ID는 변경 될 수 있습니다. 예를 들어, 항목이 RPC에서 서버로 생성되고 해당 RPC가 다시 실행되는 경우에 발생할 수 있습니다. 데이터가 변경되지 않은 경우에도 두 번째 응답은 다른 ID를 가진 객체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="afa3e2aab5eb44abf792978d1175dab7157473c8" translate="yes" xml:space="preserve">
          <source>Angular uses object identity to track insertions and deletions within the iterator and reproduce those changes in the DOM. This has important implications for animations and any stateful controls that are present, such as &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; elements that accept user input. Inserted rows can be animated in, deleted rows can be animated out, and unchanged rows retain any unsaved state such as user input. For more on animations, see &lt;a href=&quot;../../guide/transition-and-triggers&quot;&gt;Transitions and Triggers&lt;/a&gt;.</source>
          <target state="translated">Angular는 객체 아이덴티티를 사용하여 이터레이터 내에서 삽입 및 삭제를 추적하고 DOM에서 이러한 변경 사항을 재현합니다. 이는 사용자 입력을 허용하는 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 요소 와 같은 애니메이션 및 상태 저장 컨트롤에 중요한 영향을 미칩니다 . 삽입 된 행은 애니메이션화 될 수 있고 삭제 된 행은 애니메이션화 될 수 있으며 변경되지 않은 행은 사용자 입력과 같은 저장되지 않은 상태를 유지합니다. 애니메이션에 대한 자세한 내용은 &lt;a href=&quot;../../guide/transition-and-triggers&quot;&gt;전환 및 트리거를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1cb885a8c762330f16faa7918e600c17bab6fcad" translate="yes" xml:space="preserve">
          <source>Angular uses property binding; there is no built-in &lt;em&gt;href&lt;/em&gt; directive. Place the element's &lt;code&gt;href&lt;/code&gt; property in square brackets and set it to a quoted template expression.</source>
          <target state="translated">Angular는 속성 바인딩을 사용합니다. 내장 &lt;em&gt;href&lt;/em&gt; 지시문 이 없습니다 . 요소의 &lt;code&gt;href&lt;/code&gt; 속성을 대괄호로 묶고 인용 된 템플릿 표현식으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="72ad9c35cd585d33a4b440a583ddfd37683769b7" translate="yes" xml:space="preserve">
          <source>Angular uses property binding; there is no built-in &lt;em&gt;show&lt;/em&gt; directive. For hiding and showing elements, bind to the HTML &lt;code&gt;hidden&lt;/code&gt; property.</source>
          <target state="translated">Angular는 속성 바인딩을 사용합니다. 내장 된 &lt;em&gt;show&lt;/em&gt; 지시문 이 없습니다 . 요소를 숨기거나 표시하려면 HTML &lt;code&gt;hidden&lt;/code&gt; 속성에 바인딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b8039827d9181117e8916b7566b190665ccc87d" translate="yes" xml:space="preserve">
          <source>Angular uses property binding; there is no built-in &lt;em&gt;src&lt;/em&gt; directive. Place the &lt;code&gt;src&lt;/code&gt; property in square brackets and set it to a quoted template expression.</source>
          <target state="translated">Angular는 속성 바인딩을 사용합니다. 내장 &lt;em&gt;src&lt;/em&gt; 지시어 가 없습니다 . 장소 &lt;code&gt;src&lt;/code&gt; 대괄호 안에 속성을하고 인용 템플릿 표현으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="51bb56d88f545ecd21c8b3295d3ae0c08827925b" translate="yes" xml:space="preserve">
          <source>Angular uses this strategy by default.</source>
          <target state="translated">Angular는 기본적으로이 전략을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a9686cbe9cdd1e05634250b025f2d23aea2544f0" translate="yes" xml:space="preserve">
          <source>Angular version 9 maintains the behavior of the &lt;code&gt;fullTemplateTypeCheck&lt;/code&gt; flag, and introduces a third &quot;strict mode&quot;. Strict mode is a superset of full mode, and is accessed by setting the &lt;code&gt;strictTemplates&lt;/code&gt; flag to true. This flag supersedes the &lt;code&gt;fullTemplateTypeCheck&lt;/code&gt; flag. In strict mode, Angular version 9 adds checks that go beyond the version 8 type-checker. Note that strict mode is only available if using Ivy.</source>
          <target state="translated">Angular 버전 9는 &lt;code&gt;fullTemplateTypeCheck&lt;/code&gt; 플래그 의 동작을 유지하고 세 번째 &quot;엄격 모드&quot;를 도입합니다. Strict 모드는 전체 모드의 상위 집합이며 &lt;code&gt;strictTemplates&lt;/code&gt; 플래그를 true 로 설정하여 액세스 합니다. 이 플래그는 &lt;code&gt;fullTemplateTypeCheck&lt;/code&gt; 플래그를 대체합니다 . 엄격 모드에서 Angular 버전 9는 버전 8 유형 검사기를 넘어서는 검사를 추가합니다. 엄격 모드는 Ivy를 사용하는 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bc76e6d5243f1e5063ab51dd2791ed0cb2ccde1" translate="yes" xml:space="preserve">
          <source>Angular version numbers have three parts: &lt;code&gt;major.minor.patch&lt;/code&gt;. For example, version 7.2.11 indicates major version 7, minor version 2, and patch level 11.</source>
          <target state="translated">각도 버전 번호는 &lt;code&gt;major.minor.patch&lt;/code&gt; 의 세 부분으로 구성 됩니다. 예를 들어, 버전 7.2.11은 주 버전 7, 부 버전 2 및 패치 레벨 11을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e66d745516cc0cbdc5a199f2171badeb163e055a" translate="yes" xml:space="preserve">
          <source>Angular version numbers indicate the level of changes that are introduced by the release. This use of &lt;a href=&quot;https://semver.org/&quot;&gt;semantic versioning&lt;/a&gt; helps you understand the potential impact of updating to a new version.</source>
          <target state="translated">각도 버전 번호는 릴리스에서 도입 된 변경 수준을 나타냅니다. 이러한 &lt;a href=&quot;https://semver.org/&quot;&gt;시맨틱 버전 관리를&lt;/a&gt; 사용 하면 새 버전으로 업데이트 할 때의 잠재적 영향을 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="6667c0e19d01e9c6b4ce15412ca271371a87af6e" translate="yes" xml:space="preserve">
          <source>Angular versioning</source>
          <target state="translated">각도 버전</target>
        </trans-unit>
        <trans-unit id="481459b7a7a53cb010c10084e6cbefbbce0d18d7" translate="yes" xml:space="preserve">
          <source>Angular versioning and releases</source>
          <target state="translated">Angular 버전 관리 및 릴리스</target>
        </trans-unit>
        <trans-unit id="ae599289dc507efb8c0a1716c60673504ba85f7d" translate="yes" xml:space="preserve">
          <source>Angular versions ^4.0.0 and ^5.0.0 are no longer under support.</source>
          <target state="translated">각도 버전 ^ 4.0.0 및 ^ 5.0.0은 더 이상 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7354076fee398ac2174e62901aad04648bfc7170" translate="yes" xml:space="preserve">
          <source>Angular versions ^4.0.0, ^5.0.0, ^6.0.0 and ^7.0.0 are no longer under support.</source>
          <target state="translated">Angular 버전 ^ 4.0.0, ^ 5.0.0, ^ 6.0.0 및 ^ 7.0.0은 더 이상 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f7eb6ab6bf508573fe3789219842611216a65fe" translate="yes" xml:space="preserve">
          <source>Angular will automatically include locale data if you configure the locale using the &lt;code&gt;--localize&lt;/code&gt; option with &lt;a href=&quot;cli/build&quot;&gt;&lt;code&gt;ng build&lt;/code&gt;&lt;/a&gt; CLI command.</source>
          <target state="translated">Angular는 &lt;a href=&quot;cli/build&quot;&gt; &lt;code&gt;ng build&lt;/code&gt; &lt;/a&gt; CLI 명령 과 함께 &lt;code&gt;--localize&lt;/code&gt; 옵션을 사용하여 로케일을 구성하는 경우 자동으로 로케일 데이터를 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="70d1eaafbfdbdadd395ad40f8c2e94be887f2a15" translate="yes" xml:space="preserve">
          <source>Angular workspace configuration</source>
          <target state="translated">각도 작업 공간 구성</target>
        </trans-unit>
        <trans-unit id="50dcd5af91abd8b4ee5691549f133ec7e54a19b3" translate="yes" xml:space="preserve">
          <source>Angular&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; returns observables from HTTP method calls. For instance, &lt;code&gt;http.get(&amp;lsquo;/api&amp;rsquo;)&lt;/code&gt; returns an observable. This provides several advantages over promise-based HTTP APIs:</source>
          <target state="translated">Angular의 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 는 HTTP 메소드 호출에서 관찰 가능 항목을 반환합니다. 예를 들어 &lt;code&gt;http.get(&amp;lsquo;/api&amp;rsquo;)&lt;/code&gt; 는 관찰 가능 항목을 반환합니다. 이는 약속 기반 HTTP API에 비해 몇 가지 장점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="39d9244a49d87a2a7a6aedec6ed8bfecbe27e003" translate="yes" xml:space="preserve">
          <source>Angular&amp;rsquo;s cross-site scripting security model</source>
          <target state="translated">Angular의 교차 사이트 스크립팅 보안 모델</target>
        </trans-unit>
        <trans-unit id="361440e87ccdb1fecd73d942a162a4cb298411a7" translate="yes" xml:space="preserve">
          <source>Angular's &lt;a href=&quot;https://github.com/angular/angular/blob/master/packages/compiler-cli/src/metadata/schema.ts&quot;&gt;schema.ts&lt;/a&gt; describes the JSON format as a collection of TypeScript interfaces.</source>
          <target state="translated">Angular의 &lt;a href=&quot;https://github.com/angular/angular/blob/master/packages/compiler-cli/src/metadata/schema.ts&quot;&gt;schema.ts&lt;/a&gt; 는 JSON 형식을 TypeScript 인터페이스의 모음으로 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8b0004daae3fceeb6dd522584dd3f1c3e15008d4" translate="yes" xml:space="preserve">
          <source>Angular's &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; has built-in support for the client-side half of this technique. Read about it more in the &lt;a href=&quot;http&quot;&gt;HttpClient guide&lt;/a&gt;.</source>
          <target state="translated">Angular의 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 는이 기술의 클라이언트 측 절반을 기본적으로 지원합니다. &lt;a href=&quot;http&quot;&gt;HttpClient 안내서&lt;/a&gt; 에서 자세한 내용을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="bc370eef79da781852b848b1734c368b87b68ffa" translate="yes" xml:space="preserve">
          <source>Angular's &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; has built-in support for the client-side half of this technique. Read about it more in the &lt;a href=&quot;http#security-xsrf-protection&quot;&gt;HttpClient guide&lt;/a&gt;.</source>
          <target state="translated">Angular의 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 는이 기술의 클라이언트 측 절반을 기본적으로 지원합니다. 자세한 내용은 &lt;a href=&quot;http#security-xsrf-protection&quot;&gt;HttpClient 가이드를 참조&lt;/a&gt; 하세요.</target>
        </trans-unit>
        <trans-unit id="4fb50cce578f3a5a5a7abdb4dd6da589ba21a121" translate="yes" xml:space="preserve">
          <source>Angular's &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; library recognizes this convention and automatically strips the string &lt;code&gt;&quot;)]}',\n&quot;&lt;/code&gt; from all responses before further parsing.</source>
          <target state="translated">Angular의 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 라이브러리는이 규칙을 인식하고 추가 구문 분석 전에 모든 응답에서 문자열 &lt;code&gt;&quot;)]}',\n&quot;&lt;/code&gt; 을 자동으로 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="14617516211b35ab06a4b2a6b666a840eb5b82fd" translate="yes" xml:space="preserve">
          <source>Angular's &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt; registers the providers needed to use a single instance of the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; service throughout your app. The &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; service is what you inject into your services to fetch data and interact with external APIs and resources.</source>
          <target state="translated">Angular의 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt; 은 앱 전체 에서 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 서비스 의 단일 인스턴스를 사용하는 데 필요한 공급자를 등록합니다 . &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 를 서비스는 외부 API와 자원 데이터와 상호 작용을 가져 오기 위해 당신의 서비스에 주입하는 것이다.</target>
        </trans-unit>
        <trans-unit id="f464c195e5c33d89fa74ab8b0d73354d62ba9d69" translate="yes" xml:space="preserve">
          <source>Angular's &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt; registers the providers your app needs to use a single instance of the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; service throughout your app.</source>
          <target state="translated">Angular의 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt; 은 앱 전체 에서 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 서비스 의 단일 인스턴스를 사용하는 데 필요한 공급자를 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="ec334ceb63562c7ef49674b3cead9e9d4cba4020" translate="yes" xml:space="preserve">
          <source>Angular's &lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder&quot;&gt;FormBuilder&lt;/a&gt;&lt;/code&gt; service provides convenient methods for generating controls. As with the other services you've used, you need to import and inject the service before you can use it:</source>
          <target state="translated">Angular의 &lt;code&gt;&lt;a href=&quot;../api/forms/formbuilder&quot;&gt;FormBuilder&lt;/a&gt;&lt;/code&gt; 서비스는 컨트롤 생성을위한 편리한 메소드를 제공합니다. 사용한 다른 서비스와 마찬가지로 사용하기 전에 서비스를 가져 와서 주입해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf774047e36d0ca6ef5a720dc672fae05bb9fc52" translate="yes" xml:space="preserve">
          <source>Angular's &lt;code&gt;keyframe()&lt;/code&gt; function is similar to keyframes in CSS. Keyframes allow several style changes within a single timing segment. For example, our button, instead of fading, could change color several times over a single 2-second timespan.</source>
          <target state="translated">Angular의 &lt;code&gt;keyframe()&lt;/code&gt; 함수는 CSS의 키 프레임과 유사합니다. 키 프레임을 사용하면 단일 타이밍 세그먼트 내에서 여러 스타일을 변경할 수 있습니다. 예를 들어, 페이드 대신 버튼이 2 초 동안 단일 색상으로 여러 번 변할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9919eee2a51b81bfdf76bbbffe272989ae666ca0" translate="yes" xml:space="preserve">
          <source>Angular's &lt;code&gt;keyframe()&lt;/code&gt; function is similar to keyframes in CSS. Keyframes allow several style changes within a single timing segment. For example, the button, instead of fading, could change color several times over a single 2-second timespan.</source>
          <target state="translated">Angular의 &lt;code&gt;keyframe()&lt;/code&gt; 함수는 CSS의 키 프레임과 유사합니다. 키 프레임을 사용하면 단일 타이밍 세그먼트 내에서 여러 스타일을 변경할 수 있습니다. 예를 들어, 버튼은 페이딩 대신 2 초 동안 여러 번 색상을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35707b1741a5656cd81137fd131c1cecf9c96f83" translate="yes" xml:space="preserve">
          <source>Angular's HTTP testing library is designed for a pattern of testing in which the app executes code and makes requests first. The test then expects that certain requests have or have not been made, performs assertions against those requests, and finally provides responses by &quot;flushing&quot; each expected request.</source>
          <target state="translated">Angular의 HTTP 테스트 라이브러리는 앱이 코드를 실행하고 요청을 먼저하는 테스트 패턴을 위해 설계되었습니다. 그런 다음 테스트는 특정 요청이 이루어 졌거나 이루어지지 않았 음을 기대하고 해당 요청에 대해 어설 션을 수행하며 마지막으로 각 요청을 &quot;플러시&quot;하여 응답을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="44f361bf81db534631a0013ce3d42b1478068b98" translate="yes" xml:space="preserve">
          <source>Angular's animation support builds on top of web animations, so you can animate any property that the browser considers animatable. This includes positions, sizes, transforms, colors, borders, and more. The W3C maintains a list of animatable properties on its &lt;a href=&quot;https://www.w3.org/TR/css-transitions-1/&quot;&gt;CSS Transitions&lt;/a&gt; page.</source>
          <target state="translated">Angular의 애니메이션 지원은 웹 애니메이션 위에 구축되므로 브라우저가 애니메이션 가능한 것으로 간주하는 모든 속성에 애니메이션을 적용 할 수 있습니다. 여기에는 위치, 크기, 변형, 색상, 테두리 등이 포함됩니다. W3C는 &lt;a href=&quot;https://www.w3.org/TR/css-transitions-1/&quot;&gt;CSS 전환&lt;/a&gt; 페이지 에서 애니메이션 가능한 속성 목록을 유지 관리합니다 .</target>
        </trans-unit>
        <trans-unit id="f1bc2a1c230dc36047042d454f2cb3150e707c25" translate="yes" xml:space="preserve">
          <source>Angular's animation system is built on CSS functionality, which means you can animate any property that the browser considers animatable. This includes positions, sizes, transforms, colors, borders, and more. The W3C maintains a list of animatable properties on its &lt;a href=&quot;https://www.w3.org/TR/css-transitions-1/&quot;&gt;CSS Transitions&lt;/a&gt; page.</source>
          <target state="translated">Angular의 애니메이션 시스템은 CSS 기능을 기반으로합니다. 즉, 브라우저가 애니메이션 가능한 것으로 간주하는 모든 속성에 애니메이션을 적용 할 수 있습니다. 여기에는 위치, 크기, 변형, 색상, 테두리 등이 포함됩니다. W3C는 &lt;a href=&quot;https://www.w3.org/TR/css-transitions-1/&quot;&gt;CSS 전환&lt;/a&gt; 페이지 에서 애니메이션 가능한 속성 목록을 유지 관리합니다 .</target>
        </trans-unit>
        <trans-unit id="c259b63cddb04acf22e950acc14653da9d32a74e" translate="yes" xml:space="preserve">
          <source>Angular's animations library makes it easy to define and apply animation effects such as page and list transitions. For more information, see the &lt;a href=&quot;animations&quot;&gt;Animations guide&lt;/a&gt;.</source>
          <target state="translated">Angular의 애니메이션 라이브러리를 사용하면 페이지 및 목록 전환과 같은 애니메이션 효과를 쉽게 정의하고 적용 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;animations&quot;&gt;애니메이션 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ae8350364c17bca7b7f63ffe70ee1b69a60cc69" translate="yes" xml:space="preserve">
          <source>Angular's continuous integration process runs unit tests of the framework on all of these browsers for every pull request, using &lt;a href=&quot;https://saucelabs.com/&quot;&gt;SauceLabs&lt;/a&gt; and &lt;a href=&quot;https://www.browserstack.com&quot;&gt;Browserstack&lt;/a&gt;.</source>
          <target state="translated">Angular의 지속적인 통합 프로세스는 &lt;a href=&quot;https://saucelabs.com/&quot;&gt;SauceLabs&lt;/a&gt; 및 &lt;a href=&quot;https://www.browserstack.com&quot;&gt;Browserstack을&lt;/a&gt; 사용하여 모든 풀 요청마다 이러한 모든 브라우저에서 프레임 워크의 단위 테스트를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="cf8707d44d9ba4cc582ed7d651d0ee4d537dd6ef" translate="yes" xml:space="preserve">
          <source>Angular's resolution behavior can be modified with &lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;()&lt;/code&gt;, &lt;code&gt;@&lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt;()&lt;/code&gt;, &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt;. Import each of them from &lt;code&gt;@angular/core&lt;/code&gt; and use each in the component class constructor when you inject your service.</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;../api/core/optional&quot;&gt;Optional&lt;/a&gt;()&lt;/code&gt; , &lt;code&gt;@&lt;a href=&quot;../api/core/self&quot;&gt;Self&lt;/a&gt;()&lt;/code&gt; , &lt;code&gt;@&lt;a href=&quot;../api/core/skipself&quot;&gt;SkipSelf&lt;/a&gt;()&lt;/code&gt; 및 &lt;code&gt;@&lt;a href=&quot;../api/core/host&quot;&gt;Host&lt;/a&gt;()&lt;/code&gt; Angular의 해상도 동작을 수정할 수 있습니다 . &lt;code&gt;@angular/core&lt;/code&gt; 에서 각각을 가져 와서 서비스를 주입 할 때 컴포넌트 클래스 생성자에서 각각 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1786feb384dc29da2b7d0b362b7546fe85676b4f" translate="yes" xml:space="preserve">
          <source>Angular's service worker is designed to optimize the end user experience of using an application over a slow or unreliable network connection, while also minimizing the risks of serving outdated content.</source>
          <target state="translated">Angular의 서비스 워커는 느리거나 신뢰할 수없는 네트워크 연결을 통해 애플리케이션을 사용하는 최종 사용자 경험을 최적화하고 오래된 컨텐츠를 제공 할 위험을 최소화하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="504cd5fa4c7a2dccac0652568a0bf7e92fa161e4" translate="yes" xml:space="preserve">
          <source>Angular's template compiler. It understands templates and can convert them to code that makes the application run and render. Typically you don&amp;rsquo;t interact with the compiler directly; rather, you use it indirectly via &lt;code&gt;platform-browser-dynamic&lt;/code&gt; when JIT compiling in the browser. For more information, see the &lt;a href=&quot;aot-compiler&quot;&gt;Ahead-of-time Compilation guide&lt;/a&gt;.</source>
          <target state="translated">Angular의 템플릿 컴파일러. 템플릿을 이해하고 애플리케이션을 실행하고 렌더링하는 코드로 변환 할 수 있습니다. 일반적으로 컴파일러와 직접 상호 작용하지 않습니다. 오히려 &lt;code&gt;platform-browser-dynamic&lt;/code&gt; 에서 JIT 컴파일시 플랫폼 브라우저 동적을 통해 간접적으로 사용 합니다. 자세한 내용은 &lt;a href=&quot;aot-compiler&quot;&gt;Ahead-of-time Compilation guide를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff40c7b19b49d4d5e133e555bcb91882845c5f9c" translate="yes" xml:space="preserve">
          <source>Angular's template syntax extends HTML and JavaScript. This section introduces template syntax by enhancing the &quot;Products&quot; area.</source>
          <target state="translated">Angular의 템플릿 구문은 HTML 및 JavaScript를 확장합니다. 이 섹션에서는 &quot;제품&quot;영역을 향상시켜 템플릿 구문을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="3ff1791e829c37910787b485c2e7587138023981" translate="yes" xml:space="preserve">
          <source>Angular's two-way binding syntax is a combination of square brackets and parentheses, &lt;code&gt;[()]&lt;/code&gt;. The &lt;code&gt;[()]&lt;/code&gt; syntax combines the brackets of property binding, &lt;code&gt;[]&lt;/code&gt;, with the parentheses of event binding, &lt;code&gt;()&lt;/code&gt;, as follows.</source>
          <target state="translated">Angular의 양방향 바인딩 구문은 대괄호와 괄호, &lt;code&gt;[()]&lt;/code&gt; 의 조합입니다 . &lt;code&gt;[()]&lt;/code&gt; 속성의 브래킷 결합 구 콤바인은 &lt;code&gt;[]&lt;/code&gt; 이벤트의 괄호 바인딩, &lt;code&gt;()&lt;/code&gt; 로서 다음과 같다.</target>
        </trans-unit>
        <trans-unit id="3ddc03baf11e86bab9597295ea44e229f6cb702e" translate="yes" xml:space="preserve">
          <source>Angular's unidirectional data flow rule forbids updates to the view &lt;em&gt;after&lt;/em&gt; it has been composed. Both of these hooks fire &lt;em&gt;after&lt;/em&gt; the component's view has been composed.</source>
          <target state="translated">Angular의 단방향 데이터 흐름 규칙은 뷰 가 구성된 &lt;em&gt;후에&lt;/em&gt; 업데이트를 금지합니다 . 구성 요소의보기가 구성된 &lt;em&gt;후에이&lt;/em&gt; 두 후크 가 모두 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="574d58aea3098c9ffb9984b160cf4eb2c3fecec7" translate="yes" xml:space="preserve">
          <source>Angular, the Angular CLI, and Angular applications depend on &lt;a href=&quot;https://docs.npmjs.com/getting-started/what-is-npm&quot;&gt;npm packages&lt;/a&gt; for many features and functions. To download and install npm packages, you need an npm package manager. This guide uses the &lt;a href=&quot;https://docs.npmjs.com/cli/install&quot;&gt;npm client&lt;/a&gt; command line interface, which is installed with &lt;code&gt;Node.js&lt;/code&gt; by default. To check that you have the npm client installed, run &lt;code&gt;npm -v&lt;/code&gt; in a terminal window.</source>
          <target state="translated">Angular, Angular CLI 및 Angular 애플리케이션은 많은 기능을 위해 &lt;a href=&quot;https://docs.npmjs.com/getting-started/what-is-npm&quot;&gt;npm 패키지&lt;/a&gt; 에 의존 합니다. npm 패키지를 다운로드하고 설치하려면 npm 패키지 관리자가 필요합니다. 이 가이드는 기본적 으로 &lt;code&gt;Node.js&lt;/code&gt; 와 함께 설치되는 &lt;a href=&quot;https://docs.npmjs.com/cli/install&quot;&gt;npm 클라이언트&lt;/a&gt; 명령 줄 인터페이스를 사용합니다 . npm 클라이언트가 설치되어 있는지 확인하려면 터미널 창에서 &lt;code&gt;npm -v&lt;/code&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5adb3a8bc2d1144d715b4e241c8b97e75acec4c" translate="yes" xml:space="preserve">
          <source>Angular, the Angular CLI, and Angular apps depend on features and functionality provided by libraries that are available as &lt;a href=&quot;https://docs.npmjs.com/getting-started/what-is-npm&quot;&gt;npm packages&lt;/a&gt;. To download and install npm packages, you must have an npm package manager.</source>
          <target state="translated">Angular, Angular CLI 및 Angular 앱은 &lt;a href=&quot;https://docs.npmjs.com/getting-started/what-is-npm&quot;&gt;npm 패키지&lt;/a&gt; 로 제공되는 라이브러리에서 제공하는 기능에 따라 다릅니다 . npm 패키지를 다운로드하여 설치하려면 npm 패키지 관리자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2a3de4a9dc7c9f3bd23b0b53226033777b1c013b" translate="yes" xml:space="preserve">
          <source>AngularJS</source>
          <target state="translated">AngularJS</target>
        </trans-unit>
        <trans-unit id="6e35a378aa54bd494ebc719b125fbf5b36ab4fb7" translate="yes" xml:space="preserve">
          <source>AngularJS 1.5 introduces the &lt;a href=&quot;https://docs.angularjs.org/api/ng/type/angular.Module#component&quot;&gt;component API&lt;/a&gt; that makes it easier to define component directives like these. It is a good idea to use this API for component directives for several reasons:</source>
          <target state="translated">AngularJS 1.5에는 이와 같은 컴포넌트 지시문을보다 쉽게 ​​정의 할 수 있는 &lt;a href=&quot;https://docs.angularjs.org/api/ng/type/angular.Module#component&quot;&gt;컴포넌트 API&lt;/a&gt; 가 도입되었습니다 . 여러 가지 이유로 컴포넌트 지시문에이 API를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="be95540cbaad0a5ea6f38f0fb89f4c1fe637785c" translate="yes" xml:space="preserve">
          <source>AngularJS apps are great. Always consider the business case before moving to Angular. An important part of that case is the time and effort to get there. This guide describes the built-in tools for efficiently migrating AngularJS projects over to the Angular platform, a piece at a time.</source>
          <target state="translated">AngularJS 앱은 훌륭합니다. Angular로 이동하기 전에 항상 비즈니스 사례를 고려하십시오. 이 사건의 중요한 부분은 거기에 도달하는 시간과 노력입니다. 이 안내서는 AngularJS 프로젝트를 한 번에 하나씩 Angular 플랫폼으로 효율적으로 마이그레이션하기위한 기본 제공 도구에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ad3374e34ac229a514bcb825e7c41831585eac3c" translate="yes" xml:space="preserve">
          <source>AngularJS developers know this technique as &lt;em&gt;transclusion&lt;/em&gt;.</source>
          <target state="translated">AngularJS 개발자들은이 기술을 &lt;em&gt;transclusion으로&lt;/em&gt; 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b756697e8af3cfff41be5b54a86bcc40435ed5a" translate="yes" xml:space="preserve">
          <source>AngularJS directives always execute inside AngularJS framework codebase regardless of where they are instantiated.</source>
          <target state="translated">AngularJS 지시문은 인스턴스화되는 위치에 관계없이 항상 AngularJS 프레임 워크 코드베이스 내에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5883a4552c1e380fb9e76fe1a405dd956e2e041a" translate="yes" xml:space="preserve">
          <source>AngularJS directives always execute inside the AngularJS framework codebase regardless of where they are instantiated.</source>
          <target state="translated">AngularJS 지시문은 인스턴스화되는 위치에 관계없이 항상 AngularJS 프레임 워크 코드베이스 내에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a2361ecb57211e492282d07e7e196e2d57b74a2f" translate="yes" xml:space="preserve">
          <source>AngularJS event-based directives do not exist in Angular. Rather, define one-way binding from the template view to the component using &lt;strong&gt;event binding&lt;/strong&gt;.</source>
          <target state="translated">AngularJS 이벤트 기반 지시문은 Angular에 없습니다. 대신, &lt;strong&gt;이벤트 바인딩을&lt;/strong&gt; 사용하여 템플리트보기에서 컴포넌트로의 단방향 바인딩을 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ba2194b47c5f56823c853e12f0552deafc5b008" translate="yes" xml:space="preserve">
          <source>AngularJS expects controllers to be constructor functions. That's exactly what ES2015/TypeScript classes are under the hood, so that means you can just plug in a class as a component controller and AngularJS will happily use it.</source>
          <target state="translated">AngularJS는 컨트롤러가 생성자 함수일 것으로 예상합니다. 이것이 바로 ES2015 / TypeScript 클래스의 핵심입니다. 따라서 클래스를 컴포넌트 컨트롤러로 꽂기 만하면 AngularJS가이를 행복하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="112a877bf72d4bfc8bf612a04c77986c603a5169" translate="yes" xml:space="preserve">
          <source>AngularJS has code in each controller that looks up an appropriate Angular module and registers the controller with that module.</source>
          <target state="translated">AngularJS는 각 컨트롤러에 적절한 Angular 모듈을 찾고 해당 모듈에 컨트롤러를 등록하는 코드를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7245580254db776b68e6171f5b629c700d61b34" translate="yes" xml:space="preserve">
          <source>AngularJS is always bootstrapped first and owns the bottom most view.</source>
          <target state="translated">AngularJS는 항상 부트 스트랩되고 맨 아래 최다 뷰를 소유합니다.</target>
        </trans-unit>
        <trans-unit id="2aef830187741c51c79d0fdd323c04bb9f1d5a18" translate="yes" xml:space="preserve">
          <source>AngularJS is currently loaded by a script tag in &lt;code&gt;index.html&lt;/code&gt;, which means that the whole app has access to it as a global and uses the same instance of the &lt;code&gt;angular&lt;/code&gt; variable. If you used &lt;code&gt;import * as angular from 'angular'&lt;/code&gt; instead, you'd also have to load every file in the AngularJS app to use ES2015 modules in order to ensure AngularJS was being loaded correctly.</source>
          <target state="translated">AngularJS는 현재 &lt;code&gt;index.html&lt;/code&gt; 의 스크립트 태그에 의해로드됩니다. 즉, 전체 앱이 전역으로 액세스 할 수 있으며 &lt;code&gt;angular&lt;/code&gt; 변수 의 동일한 인스턴스를 사용합니다 . 대신 &lt;code&gt;import * as angular from 'angular'&lt;/code&gt; 사용한 경우 AngularJS가 올바르게로드되도록하려면 ES2015 모듈을 사용하도록 AngularJS 앱의 모든 파일을로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="398510dbda26c2a8fe4e08585f1a59953ba02faf" translate="yes" xml:space="preserve">
          <source>AngularJS provides more than seventy built-in directives for templates. Many of them aren't needed in Angular because of its more capable and expressive binding system. The following are some of the key AngularJS built-in directives and their equivalents in Angular.</source>
          <target state="translated">AngularJS는 템플릿에 대해 70 개가 넘는 내장 지시문을 제공합니다. 더 많은 능력과 표현력이있는 바인딩 시스템으로 인해 Angular에서는 필요하지 않습니다. 다음은 주요 AngularJS 내장 지시문 중 일부이며 Angular의 해당 지시어입니다.</target>
        </trans-unit>
        <trans-unit id="3adbc04c8f21c0c77451b7e8d0376cba32bd94e5" translate="yes" xml:space="preserve">
          <source>AngularJS to Angular Concepts: Quick Reference</source>
          <target state="translated">AngularJS에서 각도 개념으로 : 빠른 참조</target>
        </trans-unit>
        <trans-unit id="a79d7666f12753eb1593d8d55349080a460f08f1" translate="yes" xml:space="preserve">
          <source>AngularJS to Angular concepts: Quick reference</source>
          <target state="translated">AngularJS to Angular 개념 : 빠른 참조</target>
        </trans-unit>
        <trans-unit id="71e9e741df0a590eafd026f54096b7bc961874d9" translate="yes" xml:space="preserve">
          <source>AngularJS, uses a &lt;code&gt;link&lt;/code&gt; tag in the head section of the &lt;code&gt;index.html&lt;/code&gt; file to define the styles for the application.</source>
          <target state="translated">AngularJS 는 &lt;code&gt;index.html&lt;/code&gt; 파일 의 head 섹션에 있는 &lt;code&gt;link&lt;/code&gt; 태그를 사용 하여 애플리케이션의 스타일을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4cee08c4b7c72405159cc26c7780b76851e3a3fd" translate="yes" xml:space="preserve">
          <source>AngularJSUrlCodec</source>
          <target state="translated">AngularJSUrlCodec</target>
        </trans-unit>
        <trans-unit id="beb2fb26a90715a16ad2b713f52643af07bc8e11" translate="yes" xml:space="preserve">
          <source>Animatable properties and units</source>
          <target state="translated">애니메이션 가능 속성 및 단위</target>
        </trans-unit>
        <trans-unit id="0769c5775aae589f50623888b4c64c6191ca75c0" translate="yes" xml:space="preserve">
          <source>Animate HTML elements as they are inserted and removed from the DOM, including responsive real-time filtering.</source>
          <target state="translated">반응 형 실시간 필터링을 포함하여 HTML 요소가 DOM에서 삽입 및 제거 될 때 애니메이션을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="618592a1a0b18cf010c11404c857093fca94afc4" translate="yes" xml:space="preserve">
          <source>Animate HTML elements in complex sequences and choreographies.</source>
          <target state="translated">복잡한 시퀀스와 안무에서 HTML 요소에 애니메이션을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="22f5b7d24e1ffc8c67c552e6bdc267d15ad51cc1" translate="yes" xml:space="preserve">
          <source>Animate each element on screen for 0.5 seconds using a custom-defined easing curve, simultaneously fading it in and un-transforming it.</source>
          <target state="translated">사용자 정의 여유 곡선을 사용하여 화면의 각 요소에 0.5 초 동안 애니메이션을 적용하면서 동시에 페이드 인 및 변형하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bbd45932cc4b4e9e342cbb31ef89450062658db7" translate="yes" xml:space="preserve">
          <source>Animate multiple elements using query() and stagger() functions</source>
          <target state="translated">query () 및 stagger () 함수를 사용하여 여러 요소 애니메이션</target>
        </trans-unit>
        <trans-unit id="1df44453e1f5986603739440ade7f2955dce87e3" translate="yes" xml:space="preserve">
          <source>Animate parent and child elements.</source>
          <target state="translated">부모 및 자식 요소에 애니메이션을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="1231f267f34e53a86804d9ed850d53253508e336" translate="yes" xml:space="preserve">
          <source>AnimateChildOptions</source>
          <target state="translated">AnimateChildOptions</target>
        </trans-unit>
        <trans-unit id="d7cf5bc56891490654005df5eefb910d609dce34" translate="yes" xml:space="preserve">
          <source>AnimateTimings</source>
          <target state="translated">AnimateTimings</target>
        </trans-unit>
        <trans-unit id="d913287670141916915aa8af33ee5f086ec77a65" translate="yes" xml:space="preserve">
          <source>Animates in the element over 300 milliseconds. During the animation, the element assumes its default width and opacity.</source>
          <target state="translated">요소에서 300 밀리 초 이상으로 애니메이션합니다. 애니메이션 중에 요소는 기본 너비와 불투명도를 가정합니다.</target>
        </trans-unit>
        <trans-unit id="820b9c7157225f0d4bfc03fe34474f3177ca57d5" translate="yes" xml:space="preserve">
          <source>Animating a simple transition</source>
          <target state="translated">간단한 전환 애니메이션</target>
        </trans-unit>
        <trans-unit id="1acb2e94dc3017b424ec642021dbc908a4c12566" translate="yes" xml:space="preserve">
          <source>Animating entering and leaving a view</source>
          <target state="translated">뷰에 들어가고 나가는 애니메이션</target>
        </trans-unit>
        <trans-unit id="7886cadc604f670181386ae5ea9a46ff00865c33" translate="yes" xml:space="preserve">
          <source>Animating to the final state</source>
          <target state="translated">최종 상태로 애니메이션</target>
        </trans-unit>
        <trans-unit id="aff1288fe6cdc9b27c1923584d50a269fdc280dc" translate="yes" xml:space="preserve">
          <source>Animation callbacks</source>
          <target state="translated">애니메이션 콜백</target>
        </trans-unit>
        <trans-unit id="42515a4b18b3e75a9a05c13c308ead18b0c1cf76" translate="yes" xml:space="preserve">
          <source>Animation definition</source>
          <target state="translated">애니메이션 정의</target>
        </trans-unit>
        <trans-unit id="dbcb7927796307d3da6f12d7006d5bd2f5657cd1" translate="yes" xml:space="preserve">
          <source>Animation definitions are linked to components through the &lt;code&gt;&lt;a href=&quot;core/component#animations&quot;&gt;animations&lt;/a&gt;&lt;/code&gt; property in the &lt;code&gt;@&lt;a href=&quot;core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; metadata, typically in the component file of the HTML element to be animated. The &lt;code&gt;&lt;a href=&quot;animations/trigger&quot;&gt;trigger&lt;/a&gt;()&lt;/code&gt; function encapsulates a named animation, with all other function calls nested within. Use the trigger name to bind the named animation to a specific triggering element in the HTML template.</source>
          <target state="translated">애니메이션 정의는 &lt;code&gt;@&lt;a href=&quot;core/component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;core/component&quot;&gt;Component&lt;/a&gt; 메타 데이터, 일반적으로 애니메이션을 생성 할 HTML 요소의 구성 요소 파일에있는 &lt;code&gt;&lt;a href=&quot;core/component#animations&quot;&gt;animations&lt;/a&gt;&lt;/code&gt; 속성을 통해 구성 요소에 연결됩니다 . &lt;code&gt;&lt;a href=&quot;animations/trigger&quot;&gt;trigger&lt;/a&gt;()&lt;/code&gt; () 함수 내에 중첩 된 다른 모든 함수 호출로 명명 된 애니메이션을 캡슐화합니다. 트리거 이름을 사용하여 명명 된 애니메이션을 HTML 템플릿의 특정 트리거 요소에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="310caf407085ad7f23432a3af12093d2c5b45918" translate="yes" xml:space="preserve">
          <source>Animation metadata: duration, delay, and easing</source>
          <target state="translated">애니메이션 메타 데이터 : 지속 시간, 지연 및 여유</target>
        </trans-unit>
        <trans-unit id="070dc1a18e384d7b8c26273653b21f0661b190a1" translate="yes" xml:space="preserve">
          <source>Animation provides the illusion of motion: HTML elements change styling over time. Well-designed animations can make your application more fun and easier to use, but they aren't just cosmetic. Animations can improve your app and user experience in a number of ways:</source>
          <target state="translated">애니메이션은 모션의 환상을 제공합니다. HTML 요소는 시간이 지남에 따라 스타일을 변경합니다. 잘 디자인 된 애니메이션은 응용 프로그램을보다 재미 있고 사용하기 쉽게 만들 수 있지만 장식적인 것은 아닙니다. 애니메이션은 여러 가지 방법으로 앱과 사용자 경험을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0c7db30f689dea02b345d4feb19f80be591a5b4" translate="yes" xml:space="preserve">
          <source>Animation sequence summary</source>
          <target state="translated">애니메이션 시퀀스 요약</target>
        </trans-unit>
        <trans-unit id="a2f413b428d01e3d852c9e02cf22d9856f4c9161" translate="yes" xml:space="preserve">
          <source>Animation state and styles</source>
          <target state="translated">애니메이션 상태 및 스타일</target>
        </trans-unit>
        <trans-unit id="4c76d2cc2e089a0e490b689a8cc8e9feb5728375" translate="yes" xml:space="preserve">
          <source>Animation trigger bindings convert all values to strings, and then match the previous and current values against any linked transitions. Booleans can be specified as &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">애니메이션 트리거 바인딩은 모든 값을 문자열로 변환 한 다음 연결된 전이에 대해 이전 값과 현재 값을 일치시킵니다. 부울은 &lt;code&gt;1&lt;/code&gt; 또는 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab4cf7592d8d437f90159cdf1869e12aa12d56dc" translate="yes" xml:space="preserve">
          <source>AnimationAnimateChildMetadata</source>
          <target state="translated">AnimationAnimateChildMetadata</target>
        </trans-unit>
        <trans-unit id="a8199a8fd1152906437f37e892432a0117740e62" translate="yes" xml:space="preserve">
          <source>AnimationAnimateMetadata</source>
          <target state="translated">AnimationAnimateMetadata</target>
        </trans-unit>
        <trans-unit id="7666f03f557808da2899925571c1dc35a2eac29b" translate="yes" xml:space="preserve">
          <source>AnimationAnimateRefMetadata</source>
          <target state="translated">AnimationAnimateRefMetadata</target>
        </trans-unit>
        <trans-unit id="a6c33451ee1ed3313b74b3e177d7107746a4a7b7" translate="yes" xml:space="preserve">
          <source>AnimationBuilder</source>
          <target state="translated">AnimationBuilder</target>
        </trans-unit>
        <trans-unit id="b6988ea2371fbf582630d88819c0e3f3c9bffeed" translate="yes" xml:space="preserve">
          <source>AnimationDriver</source>
          <target state="translated">AnimationDriver</target>
        </trans-unit>
        <trans-unit id="b68b862342361922d8aeebe8914e3813b3a82ea4" translate="yes" xml:space="preserve">
          <source>AnimationEvent</source>
          <target state="translated">AnimationEvent</target>
        </trans-unit>
        <trans-unit id="b8bfdf6ac4276ec091b33b31fa025b59d8ae6d7d" translate="yes" xml:space="preserve">
          <source>AnimationFactory</source>
          <target state="translated">AnimationFactory</target>
        </trans-unit>
        <trans-unit id="a3a7882964c227f42de2f45e1e825e6e7dbaf958" translate="yes" xml:space="preserve">
          <source>AnimationGroupMetadata</source>
          <target state="translated">AnimationGroupMetadata</target>
        </trans-unit>
        <trans-unit id="3e9f8514aa4837ac7a9591838d80d05da6ea30b5" translate="yes" xml:space="preserve">
          <source>AnimationKeyframesSequenceMetadata</source>
          <target state="translated">AnimationKeyframesSequenceMetadata</target>
        </trans-unit>
        <trans-unit id="6fb97195c310cce7c5f508b709bcb87dd08d499f" translate="yes" xml:space="preserve">
          <source>AnimationMetadata</source>
          <target state="translated">AnimationMetadata</target>
        </trans-unit>
        <trans-unit id="53f1eba48611407f4a1975724592be1e71afd91a" translate="yes" xml:space="preserve">
          <source>AnimationMetadataType</source>
          <target state="translated">AnimationMetadataType</target>
        </trans-unit>
        <trans-unit id="fb0b93cca54964c4444fc172d338b01d02dd2b94" translate="yes" xml:space="preserve">
          <source>AnimationOptions</source>
          <target state="translated">AnimationOptions</target>
        </trans-unit>
        <trans-unit id="209f8c7f66e9bd69a25c35a1868b922ae003930a" translate="yes" xml:space="preserve">
          <source>AnimationPlayer</source>
          <target state="translated">AnimationPlayer</target>
        </trans-unit>
        <trans-unit id="6fb8a7cdef7876dff2df1190c171576bf5a725ed" translate="yes" xml:space="preserve">
          <source>AnimationQueryMetadata</source>
          <target state="translated">AnimationQueryMetadata</target>
        </trans-unit>
        <trans-unit id="78889e2ae13c736ba48dc387ac4d3316766916b3" translate="yes" xml:space="preserve">
          <source>AnimationQueryOptions</source>
          <target state="translated">AnimationQueryOptions</target>
        </trans-unit>
        <trans-unit id="2c5530db9d40f1553b25c85091789d55b95b926e" translate="yes" xml:space="preserve">
          <source>AnimationReferenceMetadata</source>
          <target state="translated">AnimationReferenceMetadata</target>
        </trans-unit>
        <trans-unit id="c65c6a5a21639ea491959e7e81065101b6d31f48" translate="yes" xml:space="preserve">
          <source>AnimationSequenceMetadata</source>
          <target state="translated">AnimationSequenceMetadata</target>
        </trans-unit>
        <trans-unit id="f9a31525fd95249ef37b0b3be3b81f19770b6d77" translate="yes" xml:space="preserve">
          <source>AnimationStaggerMetadata</source>
          <target state="translated">AnimationStaggerMetadata</target>
        </trans-unit>
        <trans-unit id="d5c9e1c8b8703497373c017c5a25ac585f71dca2" translate="yes" xml:space="preserve">
          <source>AnimationStateMetadata</source>
          <target state="translated">AnimationStateMetadata</target>
        </trans-unit>
        <trans-unit id="9f838574e71a14ec4034fc9c668e17daeaa733e1" translate="yes" xml:space="preserve">
          <source>AnimationStyleMetadata</source>
          <target state="translated">AnimationStyleMetadata</target>
        </trans-unit>
        <trans-unit id="2bfef012b3c0bb7a9c8988f6ac24a5853564b567" translate="yes" xml:space="preserve">
          <source>AnimationTransitionMetadata</source>
          <target state="translated">AnimationTransitionMetadata</target>
        </trans-unit>
        <trans-unit id="c9a79289360f62c0f790d371279f9ed9ef6dffec" translate="yes" xml:space="preserve">
          <source>AnimationTriggerMetadata</source>
          <target state="translated">AnimationTriggerMetadata</target>
        </trans-unit>
        <trans-unit id="c77dcdedc0f40e8dac08a08c8bef7255abb90e75" translate="yes" xml:space="preserve">
          <source>Animations</source>
          <target state="translated">Animations</target>
        </trans-unit>
        <trans-unit id="0f54eb841ec3b22a39fd482ff66e7904acc8641b" translate="yes" xml:space="preserve">
          <source>Animations API summary</source>
          <target state="translated">애니메이션 API 요약</target>
        </trans-unit>
        <trans-unit id="52512eb45e2b30a744e5257c969ca3111e25423f" translate="yes" xml:space="preserve">
          <source>Animations are defined in the metadata of the component that controls the HTML element to be animated. Put the code that defines your animations under the &lt;code&gt;animations:&lt;/code&gt; property within the &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; decorator.</source>
          <target state="translated">애니메이션은 HTML 요소를 애니메이션으로 제어하는 ​​구성 요소의 메타 데이터에서 정의됩니다. &lt;code&gt;@&lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/component&quot;&gt;Component&lt;/a&gt; () 데코레이터 내의 &lt;code&gt;animations:&lt;/code&gt; 속성 아래에 애니메이션 을 정의하는 코드를 넣으십시오 .</target>
        </trans-unit>
        <trans-unit id="06c3f02ce6046751e8afb6c9448801d6483e310e" translate="yes" xml:space="preserve">
          <source>Animations can be defined directly inside your components. For this example we are defining the animations in a separate file, which allows us to re-use the animations.</source>
          <target state="translated">구성 요소 내에서 애니메이션을 직접 정의 할 수 있습니다. 이 예제에서는 애니메이션을 별도의 파일로 정의하여 애니메이션을 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d23b44688014855fdd9501d6bbd3e413501debb" translate="yes" xml:space="preserve">
          <source>Animations transitions and triggers</source>
          <target state="translated">애니메이션 전환 및 트리거</target>
        </trans-unit>
        <trans-unit id="c3caa79244ee020e6b1824a6e588366f508b747d" translate="yes" xml:space="preserve">
          <source>Anno Domini</source>
          <target state="translated">서기</target>
        </trans-unit>
        <trans-unit id="53096344fdb247ca5b187e37878713fdf03e1195" translate="yes" xml:space="preserve">
          <source>Another TypeScript feature you can make use of is &lt;em&gt;classes&lt;/em&gt;. In particular, you can turn component controllers into classes. That way they'll be a step closer to becoming Angular component classes, which will make life easier once you upgrade.</source>
          <target state="translated">사용할 수있는 또 다른 TypeScript 기능은 &lt;em&gt;클래스&lt;/em&gt; 입니다. 특히 컴포넌트 컨트롤러를 클래스로 바꿀 수 있습니다. 이렇게하면 Angular 구성 요소 클래스가되기에 한 걸음 더 다가 갈 수있어 업그레이드 후에 더 쉽게 생활 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56b080272940939ced695e0e8fccf51d1f089b8b" translate="yes" xml:space="preserve">
          <source>Another advantage of &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; is that you can use it to guard against null. Show/hide is best suited for very simple use cases, so when you need a guard, opt instead for &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt;. Angular will throw an error if a nested expression tries to access a property of &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 의 또 다른 장점은 이를 사용하여 null을 방지 할 수 있다는 것입니다. 표시 / 숨기기는 매우 간단한 사용 사례에 가장 적합하므로 가드가 필요할 때는 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 대신 선택 하십시오 . 중첩식이 &lt;code&gt;null&lt;/code&gt; 속성에 액세스하려고하면 Angular에서 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="6fcce88157a90349b33951e206a2c653b84c62ec" translate="yes" xml:space="preserve">
          <source>Another class, &lt;code&gt;EvenBetterLogger&lt;/code&gt;, might display the user name in the log message. This logger gets the user from an injected &lt;code&gt;UserService&lt;/code&gt; instance.</source>
          <target state="translated">다른 클래스 인 &lt;code&gt;EvenBetterLogger&lt;/code&gt; 는 로그 메시지에 사용자 이름을 표시 할 수 있습니다. 이 로거는 주입 된 &lt;code&gt;UserService&lt;/code&gt; 인스턴스 에서 사용자를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="81038be782361cd7a156e96f6d6e6dae45bb260d" translate="yes" xml:space="preserve">
          <source>Another common use case for attribute binding is with the &lt;code&gt;colspan&lt;/code&gt; attribute in tables. Binding to the &lt;code&gt;colspan&lt;/code&gt; attribute helps you keep your tables programmatically dynamic. Depending on the amount of data that your application populates a table with, the number of columns that a row spans could change.</source>
          <target state="translated">속성 바인딩의 또 다른 일반적인 사용 사례 는 테이블 의 &lt;code&gt;colspan&lt;/code&gt; 속성입니다. &lt;code&gt;colspan&lt;/code&gt; 속성에 바인딩하면 테이블을 프로그래밍 방식으로 동적으로 유지할 수 있습니다. 애플리케이션이 테이블을 채우는 데이터 양에 따라 행에 걸쳐있는 열 수가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2181ba65b8c1858b15868800a96303556d7912aa" translate="yes" xml:space="preserve">
          <source>Another domain</source>
          <target state="translated">다른 도메인</target>
        </trans-unit>
        <trans-unit id="2815d2c42633ed5d5b751d955945df92e687f95c" translate="yes" xml:space="preserve">
          <source>Another domain (for routing)</source>
          <target state="translated">다른 도메인 (라우팅 용)</target>
        </trans-unit>
        <trans-unit id="1c927043925bf388c4a50fabc1ec3f662f2dd811" translate="yes" xml:space="preserve">
          <source>Another domain, AppModule</source>
          <target state="translated">다른 도메인, AppModule</target>
        </trans-unit>
        <trans-unit id="7e1638d3363efdfbe5466eef1db2d2342c31fe3e" translate="yes" xml:space="preserve">
          <source>Another example</source>
          <target state="translated">다른 예시</target>
        </trans-unit>
        <trans-unit id="0ed013f9e94cdc0d63ce5a44b4f989895c245c7d" translate="yes" xml:space="preserve">
          <source>Another example is disabling a button when the component says that it &lt;code&gt;isUnchanged&lt;/code&gt;:</source>
          <target state="translated">또 다른 예는 구성 요소가 변경되지 &lt;code&gt;isUnchanged&lt;/code&gt; 말할 때 버튼을 비활성화하는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="3c964816bf2def0a4255f7c53c2ee3c595ece4c7" translate="yes" xml:space="preserve">
          <source>Another example shows the component class with a provider for &lt;code&gt;FlowerService&lt;/code&gt;. In this case, the injector looks no further than the current &lt;code&gt;ElementInjector&lt;/code&gt; because it finds the &lt;code&gt;FlowerService&lt;/code&gt; and returns the yellow flower 🌼.</source>
          <target state="translated">또 다른 예는 &lt;code&gt;FlowerService&lt;/code&gt; 제공자가있는 컴포넌트 클래스를 보여줍니다 . 이 경우 인젝터는 &lt;code&gt;FlowerService&lt;/code&gt; 를 찾아 노란색 꽃 🌼을 반환 하기 때문에 현재 &lt;code&gt;ElementInjector&lt;/code&gt; 보다 더 이상 보지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f02c387e6e60b792589c26b7e606d305ef9df377" translate="yes" xml:space="preserve">
          <source>Another is setting a property of a directive:</source>
          <target state="translated">다른 하나는 지시문의 속성을 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="602cc167054f68080e0cc0803ee3cbf5add9046c" translate="yes" xml:space="preserve">
          <source>Another key difference between &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; is that the latter requires you to instantiate both the AngularJS and Angular modules up-front. This means that you have to pay the cost of instantiating the Angular part of the app, even if you don't use any Angular assets until later. &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; is again less aggressive. It will only instantiate the Angular part when it is required for the first time; that is, as soon as it needs to create a downgraded component.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 의 또 다른 주요 차이점 은 후자가 AngularJS와 Angular 모듈을 모두 인스턴스화해야한다는 것입니다. 이것은 나중에 Angular 애셋을 사용하지 않더라도 앱의 Angular 부분을 인스턴스화하는 비용을 지불해야 함을 의미합니다. &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; 은 다시 덜 공격적입니다. Angular 부분이 처음 필요할 때만 인스턴스화됩니다. 즉, 다운 그레이드 된 구성 요소를 만들어야하는 즉시입니다.</target>
        </trans-unit>
        <trans-unit id="1fc73f82cc15907fd525993478d793760025df4c" translate="yes" xml:space="preserve">
          <source>Another platform factory to modify. Allows you to compose factories to build up configurations that might be required by different libraries or parts of the application.</source>
          <target state="translated">수정할 다른 플랫폼 팩토리입니다. 다른 라이브러리 또는 애플리케이션의 일부에 필요할 수있는 구성을 구축하기 위해 팩토리를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81aea9981f12bfceefc57291e2e46e0a448fc33b" translate="yes" xml:space="preserve">
          <source>Another problem: some HTML elements require all immediate children to be of a specific type. For example, the &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; element requires &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; children. You can't wrap the &lt;em&gt;options&lt;/em&gt; in a conditional &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; or a &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">또 다른 문제 : 일부 HTML 요소는 모든 직계 자식이 특정 유형이어야합니다. 예를 들어 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 요소에는 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 하위 가 필요합니다 . 조건부 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 에서 &lt;em&gt;옵션&lt;/em&gt; 을 줄 바꿈 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5500271b188473b9589122039f8e0d10390b1818" translate="yes" xml:space="preserve">
          <source>Another reason to re-provide a service at another level is to substitute a &lt;em&gt;more specialized&lt;/em&gt; implementation of that service, deeper in the component tree.</source>
          <target state="translated">다른 수준에서 서비스를 다시 제공해야하는 또 다른 이유 는 구성 요소 트리에서 더 깊게 해당 서비스를 &lt;em&gt;보다 전문적으로&lt;/em&gt; 구현하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5452461849c5467ea0a5cfad43f0fcf8652c8206" translate="yes" xml:space="preserve">
          <source>Another service is needed to supply a specific set of questions from which to build an individual form. For this exercise you will create the &lt;code&gt;QuestionService&lt;/code&gt; to supply this array of questions from the hard-coded sample data. In a real-world app, the service might fetch data from a backend system. The key point, however, is that you control the hero job-application questions entirely through the objects returned from &lt;code&gt;QuestionService&lt;/code&gt;. To maintain the questionnaire as requirements change, you only need to add, update, and remove objects from the &lt;code&gt;questions&lt;/code&gt; array.</source>
          <target state="translated">개별 양식을 작성하기위한 특정 질문 세트를 제공하려면 또 다른 서비스가 필요합니다. 이 연습 에서는 하드 코딩 된 샘플 데이터에서이 질문 배열을 제공 하는 &lt;code&gt;QuestionService&lt;/code&gt; 를 만듭니다 . 실제 앱에서 서비스는 백엔드 시스템에서 데이터를 가져올 수 있습니다. 그러나 핵심은 &lt;code&gt;QuestionService&lt;/code&gt; 에서 반환 된 객체를 통해 전적으로 영웅 구인 신청 질문을 제어한다는 것 입니다. 요구 사항이 변경 될 때 설문지를 유지하려면 &lt;code&gt;questions&lt;/code&gt; 배열 에서 개체를 추가, 업데이트 및 제거 하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="b4edcd9ca213bdd8b52b2310e46e71e39a3e13ee" translate="yes" xml:space="preserve">
          <source>Another simple way to deploy your Angular app is to use &lt;a href=&quot;https://help.github.com/articles/what-is-github-pages/&quot;&gt;GitHub Pages&lt;/a&gt;.</source>
          <target state="translated">Angular 앱을 배포하는 또 다른 간단한 방법은 &lt;a href=&quot;https://help.github.com/articles/what-is-github-pages/&quot;&gt;GitHub Pages&lt;/a&gt; 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="1a0232ed081a1f2af117924de181bf23193259db" translate="yes" xml:space="preserve">
          <source>Another solution to choosing a provider token for non-class dependencies is to define and use an &lt;code&gt;&lt;a href=&quot;../api/core/injectiontoken&quot;&gt;InjectionToken&lt;/a&gt;&lt;/code&gt; object. The following example shows how to define such a token.</source>
          <target state="translated">비 클래스 종속성에 대한 제공자 토큰을 선택하는 또 다른 솔루션은 &lt;code&gt;&lt;a href=&quot;../api/core/injectiontoken&quot;&gt;InjectionToken&lt;/a&gt;&lt;/code&gt; 오브젝트 를 정의하고 사용하는 것입니다. 다음 예제는 이러한 토큰을 정의하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e18a7fa42b657d430a040fcb6744c6085d9b4ae0" translate="yes" xml:space="preserve">
          <source>Another thing you can do is start adding &lt;em&gt;type safety&lt;/em&gt; to your code. This has actually partially already happened because of the AngularJS typings you installed. TypeScript are checking that you are calling AngularJS APIs correctly when you do things like register components to Angular modules.</source>
          <target state="translated">당신이 할 수있는 또 다른 일은 코드에 &lt;em&gt;타입 안전&lt;/em&gt; 을 추가 하는 것입니다. 실제로 설치 한 AngularJS 입력으로 인해 부분적으로 이미 발생했습니다. TypeScript는 컴포넌트를 Angular 모듈에 등록하는 등의 작업을 수행 할 때 AngularJS API를 올바르게 호출하고 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c3810aa894a3348cc470b2185cd6df4bf822a9c5" translate="yes" xml:space="preserve">
          <source>Another way to limit provider scope is by adding the service you want to limit to the component&amp;rsquo;s &lt;code&gt;providers&lt;/code&gt; array. Component providers and NgModule providers are independent of each other. This method is helpful for when you want to eagerly load a module that needs a service all to itself. Providing a service in the component limits the service only to that component (other components in the same module can&amp;rsquo;t access it.)</source>
          <target state="translated">공급자 범위를 제한하는 다른 방법은 구성 요소의 &lt;code&gt;providers&lt;/code&gt; 배열 에 제한하려는 서비스를 추가하는 것 입니다. 컴포넌트 제공자와 NgModule 제공자는 서로 독립적입니다. 이 방법은 서비스가 필요한 모듈을 열성적으로로드하려는 경우에 유용합니다. 컴포넌트에 서비스를 제공하면 해당 컴포넌트로만 서비스가 제한됩니다 (동일한 모듈의 다른 컴포넌트는 액세스 할 수 없음).</target>
        </trans-unit>
        <trans-unit id="251ae41000e8afa24184650218abb2c7d40f51c8" translate="yes" xml:space="preserve">
          <source>Another way to limit provider scope is by adding the service you want to limit to the component&amp;rsquo;s &lt;code&gt;providers&lt;/code&gt; array. Component providers and NgModule providers are independent of each other. This method is helpful when you want to eagerly load a module that needs a service all to itself. Providing a service in the component limits the service only to that component and its descendants. Other components in the same module can&amp;rsquo;t access it.</source>
          <target state="translated">공급자 범위를 제한하는 또 다른 방법은 제한 할 서비스를 구성 요소의 &lt;code&gt;providers&lt;/code&gt; 배열에 추가하는 것입니다. 구성 요소 공급자와 NgModule 공급자는 서로 독립적입니다. 이 방법은 서비스가 필요한 모듈을 자체적으로로드하려는 경우 유용합니다. 구성 요소에서 서비스를 제공하면 해당 구성 요소와 해당 하위 항목으로 만 서비스가 제한됩니다. 동일한 모듈의 다른 구성 요소는 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="da3ac8b45123b40210a3b3867ac927476f2704e1" translate="yes" xml:space="preserve">
          <source>Any app developer can use these and other libraries that have been published as npm packages by the Angular team or by third parties. See &lt;a href=&quot;using-libraries&quot;&gt;Using Published Libraries&lt;/a&gt;.</source>
          <target state="translated">모든 앱 개발자는 Angular 팀 또는 타사에서 npm 패키지로 게시 한 라이브러리 및 기타 라이브러리를 사용할 수 있습니다. &lt;a href=&quot;using-libraries&quot;&gt;게시 된 라이브러리 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34c22c53a0508cf256d35202481e3c5e94595954" translate="yes" xml:space="preserve">
          <source>Any application still relying on the &lt;code&gt;esm5&lt;/code&gt; and &lt;code&gt;fesm5&lt;/code&gt; as the input to its build system will need to ensure that the build pipeline is capable of accepting JavaScript code conforming to ECMAScript 2015 (ES2015) language specification.</source>
          <target state="translated">빌드 시스템에 대한 입력으로 &lt;code&gt;esm5&lt;/code&gt; 및 &lt;code&gt;fesm5&lt;/code&gt; 를 여전히 사용하는 모든 애플리케이션 은 빌드 파이프 라인이 ECMAScript 2015 (ES2015) 언어 사양을 준수하는 JavaScript 코드를 수용 할 수 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="d9e225c8709529016fb0fe3d9aaeca9255591cfb" translate="yes" xml:space="preserve">
          <source>Any changes to the public API surface will be done using the versioning, support, and depreciation policies describe above.</source>
          <target state="translated">공개 API 표면에 대한 모든 변경은 위에서 설명한 버전 관리, 지원 및 감가 상각 정책을 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4252573f476e0bf8d0ee4fd8ca2af51dda805825" translate="yes" xml:space="preserve">
          <source>Any class with the &lt;code&gt;@&lt;a href=&quot;component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;@&lt;a href=&quot;directive&quot;&gt;Directive&lt;/a&gt;&lt;/code&gt; decorator</source>
          <target state="translated">&lt;code&gt;@&lt;a href=&quot;component&quot;&gt;Component&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;@&lt;a href=&quot;directive&quot;&gt;Directive&lt;/a&gt;&lt;/code&gt; 데코레이터 가있는 클래스</target>
        </trans-unit>
        <trans-unit id="faa5c260ff9b2e13ba3a7e065117c51a53243e3b" translate="yes" xml:space="preserve">
          <source>Any component created within a lazy loaded module&amp;rsquo;s context, such as by router navigation, gets the local instance of the service, not the instance in the root application injector. Components in external modules continue to receive the instance created for the application root.</source>
          <target state="translated">라우터 탐색과 같이 느리게로드 된 모듈 컨텍스트 내에서 생성 된 모든 구성 요소는 루트 응용 프로그램 인젝터의 인스턴스가 아닌 서비스의 로컬 인스턴스를 가져옵니다. 외부 모듈의 구성 요소는 응용 프로그램 루트에 대해 생성 된 인스턴스를 계속받습니다.</target>
        </trans-unit>
        <trans-unit id="06a75db5d4bcefd57aafb04659c4d9594738124e" translate="yes" xml:space="preserve">
          <source>Any error returned on the &lt;code&gt;Observable&lt;/code&gt; response stream will be wrapped in an &lt;code&gt;&lt;a href=&quot;httperrorresponse&quot;&gt;HttpErrorResponse&lt;/a&gt;&lt;/code&gt; to provide additional context about the state of the HTTP layer when the error occurred. The error property will contain either a wrapped Error object or the error response returned from the server.</source>
          <target state="translated">&lt;code&gt;Observable&lt;/code&gt; 응답 스트림 에 반환 된 오류 는 &lt;code&gt;&lt;a href=&quot;httperrorresponse&quot;&gt;HttpErrorResponse&lt;/a&gt;&lt;/code&gt; 에 래핑되어 오류가 발생할 때 HTTP 계층의 상태에 대한 추가 컨텍스트를 제공합니다. error 속성에는 래핑 된 Error 개체 또는 서버에서 반환 된 오류 응답이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9b490d3957cd57eaa58b9061b9b93abf6f8fceda" translate="yes" xml:space="preserve">
          <source>Any future tasks or microtasks scheduled from within this function will continue executing from outside of the Angular zone.</source>
          <target state="translated">이 기능 내에서 예약 된 향후 작업 또는 마이크로 태스크는 Angular 영역 외부에서 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="858f110f5dd01bf7e8dc4320e306d0feb61a7a50" translate="yes" xml:space="preserve">
          <source>Any future tasks or microtasks scheduled from within this function will continue executing from within the Angular zone.</source>
          <target state="translated">이 기능 내에서 예약 된 향후 작업 또는 마이크로 태스크는 Angular 영역 내에서 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="93532a30b014f85c589d7c068d4130fc1fccc7b1" translate="yes" xml:space="preserve">
          <source>Any observables that the components subscribe to internally should be cleaned up and disposed of during the lifecycle of those components.</source>
          <target state="translated">구성 요소가 내부적으로 구독하는 모든 관찰 가능 구성 요소는 해당 구성 요소의 수명주기 동안 청소 및 폐기해야합니다.</target>
        </trans-unit>
        <trans-unit id="1ac78989853c9b050e2eda23ff2928dfb610d9c3" translate="yes" xml:space="preserve">
          <source>Any provider defined in the child component tree of the current component (e.g. &lt;code&gt;@&lt;a href=&quot;viewchild&quot;&gt;ViewChild&lt;/a&gt;(SomeService) someService: SomeService&lt;/code&gt;)</source>
          <target state="translated">현재 컴포넌트의 하위 컴포넌트 트리에 정의 된 제공자 (예 : &lt;code&gt;@&lt;a href=&quot;viewchild&quot;&gt;ViewChild&lt;/a&gt;(SomeService) someService: SomeService&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="df5462a835da0acf093fceb883fd8b853fd7d033" translate="yes" xml:space="preserve">
          <source>Any provider defined through a string token (e.g. &lt;code&gt;@&lt;a href=&quot;viewchild&quot;&gt;ViewChild&lt;/a&gt;('someToken') someTokenVal: any&lt;/code&gt;)</source>
          <target state="translated">문자열 토큰을 통해 정의 된 제공자 (예 : &lt;code&gt;@&lt;a href=&quot;viewchild&quot;&gt;ViewChild&lt;/a&gt;('someToken') someTokenVal: any&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9b53bf1c187ff8e5d85d8461d6cbd8075538730c" translate="yes" xml:space="preserve">
          <source>Any subscribers to the &lt;code&gt;valueChanges&lt;/code&gt; observable receive the new value.</source>
          <target state="translated">관찰 가능한 &lt;code&gt;valueChanges&lt;/code&gt; 구독자 는 새 값을받습니다.</target>
        </trans-unit>
        <trans-unit id="63ef43a80069c779b3ee5167397831492df1e816" translate="yes" xml:space="preserve">
          <source>Anything that uses a regular expression is worth testing thoroughly. Use simple Jasmine to explore the expected cases and the edge cases.</source>
          <target state="translated">정규식을 사용하는 것은 철저히 테스트 할 가치가 있습니다. 간단한 Jasmine을 사용하여 예상 사례와 최종 사례를 탐색하십시오.</target>
        </trans-unit>
        <trans-unit id="88cda930404408fa5b6b5bb5ea64822d75f409c3" translate="yes" xml:space="preserve">
          <source>Anything under &lt;code&gt;assets&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;assets&lt;/code&gt; 아래에있는 모든 것 .</target>
        </trans-unit>
        <trans-unit id="93cd385e58bd290f15ae342c6fdf3fea9806d612" translate="yes" xml:space="preserve">
          <source>AoT metadata errors</source>
          <target state="translated">AoT 메타 데이터 오류</target>
        </trans-unit>
        <trans-unit id="0b5958b0f53cb499388dd9ee04a106a30b02c5d1" translate="yes" xml:space="preserve">
          <source>Apache</source>
          <target state="translated">Apache</target>
        </trans-unit>
        <trans-unit id="0d6c7d4967052bf08ff030cdd321d82fc75c2851" translate="yes" xml:space="preserve">
          <source>Apart from &lt;code&gt;&lt;a href=&quot;upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt;, you can use the rest of the &lt;code&gt;&lt;a href=&quot;../static&quot;&gt;upgrade/static&lt;/a&gt;&lt;/code&gt; helpers as usual to build a hybrid application. Note that the Angular pieces (e.g. downgraded services) will not be available until the downgraded module has been bootstrapped, i.e. by instantiating a downgraded component.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 외에도 , 다른 &lt;code&gt;&lt;a href=&quot;../static&quot;&gt;upgrade/static&lt;/a&gt;&lt;/code&gt; 헬퍼를 사용하여 하이브리드 애플리케이션을 빌드 할 수 있습니다. 다운 그레이드 된 모듈이 부트 스트랩 될 때까지, 즉 다운 그레이드 된 구성 요소를 인스턴스화 할 때까지 각도 부분 (예 : 다운 그레이드 된 서비스)을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="57807d7e38eb807484ab254a0fac6301d23c9944" translate="yes" xml:space="preserve">
          <source>App &lt;code&gt;root module&lt;/code&gt;</source>
          <target state="translated">앱 &lt;code&gt;root module&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5aa3cc756775d4afef149117b0695738c8d5e450" translate="yes" xml:space="preserve">
          <source>App Shell</source>
          <target state="translated">앱 셸</target>
        </trans-unit>
        <trans-unit id="7b4fd1b17b918b41d314d1e08cfa7e5547f2b386" translate="yes" xml:space="preserve">
          <source>App shell</source>
          <target state="translated">앱 셸</target>
        </trans-unit>
        <trans-unit id="f44820b851018adfc0c40223a29fecd82923e3f3" translate="yes" xml:space="preserve">
          <source>App shell is a way to render a portion of your application via a route at build time. It can improve the user experience by quickly launching a static rendered page (a skeleton common to all pages) while the browser downloads the full client version and switches to it automatically after the code loads.</source>
          <target state="translated">앱 셸은 빌드시 경로를 통해 애플리케이션의 일부를 렌더링하는 방법입니다. 브라우저가 전체 클라이언트 버전을 다운로드하고 코드가로드 된 후 자동으로 전환하는 동안 정적 렌더링 페이지 (모든 페이지에 공통적 인 골격)를 빠르게 시작하여 사용자 경험을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95c4786d84aa1c9b22007dc04178f6b25983cd88" translate="yes" xml:space="preserve">
          <source>App shell is a way to render a portion of your application via a route at build time. This gives users a meaningful first paint of your application that appears quickly because the browser can render static HTML and CSS without the need to initialize JavaScript.</source>
          <target state="translated">앱 셸은 빌드시 경로를 통해 애플리케이션의 일부를 렌더링하는 방법입니다. 브라우저가 JavaScript를 초기화 할 필요없이 정적 HTML 및 CSS를 렌더링 할 수 있기 때문에 사용자에게 애플리케이션의 의미있는 첫 번째 페인트가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="63d67384492343e219bf6928f05ecac25471ffd5" translate="yes" xml:space="preserve">
          <source>App tabs</source>
          <target state="translated">앱 탭</target>
        </trans-unit>
        <trans-unit id="540143c662eb90de02a65e482599c49fa15df426" translate="yes" xml:space="preserve">
          <source>App versions</source>
          <target state="translated">앱 버전</target>
        </trans-unit>
        <trans-unit id="75913f9fcc32232a451e534954939bf6b759d88c" translate="yes" xml:space="preserve">
          <source>AppModule</source>
          <target state="translated">AppModule</target>
        </trans-unit>
        <trans-unit id="3bc3e2080ed9e689cda76f06895f83510ab7fc40" translate="yes" xml:space="preserve">
          <source>Append &lt;code&gt;/heroes&lt;/code&gt; to the URL in the browser address bar. You should see the familiar heroes master/detail view.</source>
          <target state="translated">브라우저 주소 표시 줄의 URL에 &lt;code&gt;/heroes&lt;/code&gt; 를 추가하십시오 . 익숙한 영웅 마스터 / 세부 정보보기가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="73973cfd168d40bb8277e2f6044ecdb605409c4e" translate="yes" xml:space="preserve">
          <source>Appendices</source>
          <target state="translated">Appendices</target>
        </trans-unit>
        <trans-unit id="f3f60044b06335eb6c4230e3c39f5e0218445878" translate="yes" xml:space="preserve">
          <source>Appendix</source>
          <target state="translated">Appendix</target>
        </trans-unit>
        <trans-unit id="261d623be7e2a959a5a15cb6df845be318cf00fe" translate="yes" xml:space="preserve">
          <source>Appendix: &lt;code&gt;LocationStrategy&lt;/code&gt; and browser URL styles</source>
          <target state="translated">부록 : &lt;code&gt;LocationStrategy&lt;/code&gt; 및 브라우저 URL 스타일</target>
        </trans-unit>
        <trans-unit id="01e09299c9c5043bbe3cce453e5e966ce28cdece" translate="yes" xml:space="preserve">
          <source>Appendix: Develop locally with IE</source>
          <target state="translated">부록 : IE를 이용한 로컬 개발</target>
        </trans-unit>
        <trans-unit id="2399a201033dbd00d9af405e9941b75deec4a79f" translate="yes" xml:space="preserve">
          <source>Appendix: No &lt;code&gt;FilterPipe&lt;/code&gt; or &lt;code&gt;OrderByPipe&lt;/code&gt;</source>
          <target state="translated">부록 : &lt;code&gt;FilterPipe&lt;/code&gt; 또는 &lt;code&gt;OrderByPipe&lt;/code&gt; 없음</target>
        </trans-unit>
        <trans-unit id="29b3b122df7e77e777ce5cfcd64d2161ed3b1c44" translate="yes" xml:space="preserve">
          <source>Appendix: Test using &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()/&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt;</source>
          <target state="translated">부록 : &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()/&lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt;()&lt;/code&gt; () / &lt;a href=&quot;../api/core/testing/async&quot;&gt;async&lt;/a&gt; ()를 사용한 테스트</target>
        </trans-unit>
        <trans-unit id="9b005c7c5c5f6b1e73b6ef1e3f05d714b908ab33" translate="yes" xml:space="preserve">
          <source>Appendix: Test using &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()/&lt;a href=&quot;../api/core/testing/waitforasync&quot;&gt;waitForAsync&lt;/a&gt;()&lt;/code&gt;</source>
          <target state="translated">부록 : &lt;code&gt;&lt;a href=&quot;../api/core/testing/fakeasync&quot;&gt;fakeAsync&lt;/a&gt;()/&lt;a href=&quot;../api/core/testing/waitforasync&quot;&gt;waitForAsync&lt;/a&gt;()&lt;/code&gt; () / &lt;a href=&quot;../api/core/testing/waitforasync&quot;&gt;waitForAsync&lt;/a&gt; ()를 사용하여 테스트</target>
        </trans-unit>
        <trans-unit id="42746499949a4a6af72f7d65e860d0f5ca0c6702" translate="yes" xml:space="preserve">
          <source>Appendix: Upgrading PhoneCat Tests</source>
          <target state="translated">부록 : PhoneCat 테스트 업그레이드</target>
        </trans-unit>
        <trans-unit id="bf96aa3c3ab705a8143ebfc310d65c579728b4f9" translate="yes" xml:space="preserve">
          <source>Appendix: Why add &lt;code&gt;@Input&lt;/code&gt;?</source>
          <target state="translated">부록 : 왜 &lt;code&gt;@Input&lt;/code&gt; 을 추가 해야 합니까?</target>
        </trans-unit>
        <trans-unit id="15354e68bf45ee9bc58f7687ae8aefa5f4126715" translate="yes" xml:space="preserve">
          <source>Appendix: link parameters array</source>
          <target state="translated">부록 : 링크 매개 변수 배열</target>
        </trans-unit>
        <trans-unit id="0c3eb7cc790639955b7256cc7f14b387fadfdb01" translate="yes" xml:space="preserve">
          <source>Appends URL segments to the current URL tree to create a new URL tree.</source>
          <target state="translated">URL 세그먼트를 현재 URL 트리에 추가하여 새 URL 트리를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a10d6a6e5b58825f456a1c60aceb9233acfe1a06" translate="yes" xml:space="preserve">
          <source>Appends a child to a given parent node in the host element DOM.</source>
          <target state="translated">호스트 요소 DOM에서 지정된 상위 노드에 하위를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="72435c978d47a75814bd8d62487eb4a1c5cb31ca" translate="yes" xml:space="preserve">
          <source>Appends a new value to existing values for a parameter.</source>
          <target state="translated">매개 변수의 기존 값에 새 값을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c07e8121475f29caa6a36b6ae4d27742e3366d83" translate="yes" xml:space="preserve">
          <source>Appends a new value to the existing set of values for a header and returns them in a clone of the original instance.</source>
          <target state="translated">헤더의 기존 값 세트에 새 값을 추가하고이를 원래 인스턴스의 복제본으로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b1fb92ce49bfdc66b691a4febcac0bbe43b53838" translate="yes" xml:space="preserve">
          <source>Application architecture</source>
          <target state="translated">애플리케이션 아키텍처</target>
        </trans-unit>
        <trans-unit id="8ea5b66a6bf60adea7d20d7175746bf7940fdf1c" translate="yes" xml:space="preserve">
          <source>Application components often need to share information. You can often use loosely coupled techniques for sharing information, such as data binding and service sharing, but sometimes it makes sense for one component to have a direct reference to another component. You need a direct reference, for instance, to access values or call methods on that component.</source>
          <target state="translated">응용 프로그램 구성 요소는 종종 정보를 공유해야합니다. 데이터 바인딩 및 서비스 공유와 같은 정보 공유를 위해 느슨하게 결합 된 기술을 사용할 수 있지만 한 구성 요소가 다른 구성 요소를 직접 참조하는 것이 합리적 일 수 있습니다. 예를 들어 해당 구성 요소의 값에 액세스하거나 메소드를 호출하려면 직접 참조가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f12a2c662c36b27f3825a6d97ac01c1d7cd35295" translate="yes" xml:space="preserve">
          <source>Application configuration files</source>
          <target state="translated">응용 프로그램 구성 파일</target>
        </trans-unit>
        <trans-unit id="cfc388605134e26efe5e73bd8340a05bc5c0fa1b" translate="yes" xml:space="preserve">
          <source>Application developers can use the &lt;a href=&quot;glossary#cli&quot;&gt;Angular CLI&lt;/a&gt; to &lt;code&gt;add&lt;/code&gt; a published library for use with an application in the same &lt;a href=&quot;glossary#workspace&quot;&gt;workspace&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램 개발자는 &lt;a href=&quot;glossary#cli&quot;&gt;Angular CLI&lt;/a&gt; 를 사용하여 동일한 &lt;a href=&quot;glossary#workspace&quot;&gt;작업 공간&lt;/a&gt; 에서 응용 프로그램과 함께 사용할 게시 된 라이브러리 를 &lt;code&gt;add&lt;/code&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a33d5f89e5c84fccd922ef838522228abdaae944" translate="yes" xml:space="preserve">
          <source>Application integration specs can test the interactions of multiple parts spread across folders and modules. They don't really belong to any part in particular, so they don't have a natural home next to any one file.</source>
          <target state="translated">응용 프로그램 통합 사양은 폴더와 모듈에 분산 된 여러 부품의 상호 작용을 테스트 할 수 있습니다. 그들은 실제로 어떤 부분에도 속하지 않으므로 어떤 파일 옆에도 자연스러운 집이 없습니다.</target>
        </trans-unit>
        <trans-unit id="6703104cd9653acb1e2ab46ed23c7db66b5070c2" translate="yes" xml:space="preserve">
          <source>Application internationalization is a many-faceted area of development, focused on making applications available and user-friendly to a worldwide audience. This page describes Angular's internationalization (i18n) tools, which can help you make your app available in multiple languages.</source>
          <target state="translated">응용 프로그램 국제화는 전 세계 사용자가 응용 프로그램을 사용하고 사용하기 쉽게 만드는 데 중점을 둔 다양한 개발 영역입니다. 이 페이지에서는 Angular의 국제화 (i18n) 도구에 대해 설명하며,이를 통해 앱을 여러 언어로 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e39567047450a98becc249aa176cdaef7b8b173f" translate="yes" xml:space="preserve">
          <source>Application project files</source>
          <target state="translated">응용 프로그램 프로젝트 파일</target>
        </trans-unit>
        <trans-unit id="8e4ad605d8891f443ed5a723fd540aecfca8c921" translate="yes" xml:space="preserve">
          <source>Application source files</source>
          <target state="translated">응용 프로그램 소스 파일</target>
        </trans-unit>
        <trans-unit id="c57c792b55f79d5a6454ef57144a28767e266988" translate="yes" xml:space="preserve">
          <source>Application structure and NgModules</source>
          <target state="translated">응용 프로그램 구조 및 NgModules</target>
        </trans-unit>
        <trans-unit id="0d128f2c09ef2323b0706b60301684346dd9280f" translate="yes" xml:space="preserve">
          <source>Application-specific &lt;a href=&quot;https://karma-runner.github.io/2.0/config/configuration-file.html&quot;&gt;Karma&lt;/a&gt; configuration.</source>
          <target state="translated">응용 프로그램 별 &lt;a href=&quot;https://karma-runner.github.io/2.0/config/configuration-file.html&quot;&gt;카르마&lt;/a&gt; 구성.</target>
        </trans-unit>
        <trans-unit id="852183ace80b773b249836fdf431f837dea2630d" translate="yes" xml:space="preserve">
          <source>Application-specific &lt;a href=&quot;https://palantir.github.io/tslint/&quot;&gt;TSLint&lt;/a&gt; configuration.</source>
          <target state="translated">응용 프로그램 별 &lt;a href=&quot;https://palantir.github.io/tslint/&quot;&gt;TSLint&lt;/a&gt; 구성.</target>
        </trans-unit>
        <trans-unit id="91f8372b527502933df6ad01e48251bd30a40415" translate="yes" xml:space="preserve">
          <source>Application-specific &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; configuration, including TypeScript and Angular template compiler options. See &lt;a href=&quot;typescript-configuration&quot;&gt;TypeScript Configuration&lt;/a&gt; and &lt;a href=&quot;angular-compiler-options&quot;&gt;Angular Compiler Options&lt;/a&gt;.</source>
          <target state="translated">TypeScript 및 Angular 템플릿 컴파일러 옵션을 포함한 응용 프로그램 별 &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; 구성. &lt;a href=&quot;typescript-configuration&quot;&gt;TypeScript 구성&lt;/a&gt; 및 &lt;a href=&quot;angular-compiler-options&quot;&gt;각도 컴파일러 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4066e5ad49d67457e01b647961a4e8b547f7af40" translate="yes" xml:space="preserve">
          <source>Application-specific &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; configuration, including TypeScript and Angular template compiler options. See &lt;a href=&quot;typescript-configuration&quot;&gt;TypeScript Configuration&lt;/a&gt;.</source>
          <target state="translated">TypeScript 및 Angular 템플릿 컴파일러 옵션을 포함한 응용 프로그램 별 &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; 구성. &lt;a href=&quot;typescript-configuration&quot;&gt;TypeScript 구성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="99dc2d0240c5a1385595b3dd59d6c536156041c4" translate="yes" xml:space="preserve">
          <source>ApplicationInitStatus</source>
          <target state="translated">ApplicationInitStatus</target>
        </trans-unit>
        <trans-unit id="b39dbb54c7c825fcef1a44e2124b1bb2b58086c8" translate="yes" xml:space="preserve">
          <source>ApplicationModule</source>
          <target state="translated">ApplicationModule</target>
        </trans-unit>
        <trans-unit id="399fe43d84dcab4d8f86ce2f9647859550a7904b" translate="yes" xml:space="preserve">
          <source>ApplicationRef</source>
          <target state="translated">ApplicationRef</target>
        </trans-unit>
        <trans-unit id="2ab362ac17e1086087cf71af4e5f979258df1d92" translate="yes" xml:space="preserve">
          <source>Applications often request JSON data from a server. In the &lt;code&gt;ConfigService&lt;/code&gt; example, the app needs a configuration file on the server, &lt;code&gt;config.json&lt;/code&gt;, that specifies resource URLs.</source>
          <target state="translated">애플리케이션은 종종 서버에서 JSON 데이터를 요청합니다. 에서 &lt;code&gt;ConfigService&lt;/code&gt; 의 예를 들어, 응용 프로그램은 서버의 구성 파일이 필요 &lt;code&gt;config.json&lt;/code&gt; 을 하도록 지정 자원의 URL.</target>
        </trans-unit>
        <trans-unit id="a196327a18feb01ef9db58391bd17fb22de7eda2" translate="yes" xml:space="preserve">
          <source>Applications often request JSON data from the server. For example, the app might need a configuration file on the server, &lt;code&gt;config.json&lt;/code&gt;, that specifies resource URLs.</source>
          <target state="translated">애플리케이션은 종종 서버에서 JSON 데이터를 요청합니다. 예를 들어, 앱에는 서버에 &lt;code&gt;config.json&lt;/code&gt; 이라는 리소스 파일 을 지정 하는 구성 파일이 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0629fc80e38645caefd8ff8a582d44f1f864f7a" translate="yes" xml:space="preserve">
          <source>Applications often restrict access to a feature area based on who the user is. You could permit access only to authenticated users or to users with a specific role. You might block or limit access until the user's account is activated.</source>
          <target state="translated">응용 프로그램은 종종 사용자가 누구인지에 따라 기능 영역에 대한 액세스를 제한합니다. 인증 된 사용자 또는 특정 역할을 가진 사용자에게만 액세스를 허용 할 수 있습니다. 사용자 계정이 활성화 될 때까지 액세스를 차단하거나 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38ff861aa4a446344adef0afc1e488d02130c3f4" translate="yes" xml:space="preserve">
          <source>Applications should use the &lt;code&gt;&lt;a href=&quot;../router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;location&quot;&gt;Location&lt;/a&gt;&lt;/code&gt; services to interact with application route state.</source>
          <target state="translated">응용 프로그램은 &lt;code&gt;&lt;a href=&quot;../router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;location&quot;&gt;Location&lt;/a&gt;&lt;/code&gt; 서비스를 사용하여 응용 프로그램 경로 상태와 상호 작용해야합니다.</target>
        </trans-unit>
        <trans-unit id="db68ba2d12235e40251d82b803326c61a95f231a" translate="yes" xml:space="preserve">
          <source>Applies an array of commands to the current URL tree and creates a new URL tree.</source>
          <target state="translated">현재 URL 트리에 명령 배열을 적용하고 새 URL 트리를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="73e49fcb5b988ce38774338e29d9e9c9583cfff5" translate="yes" xml:space="preserve">
          <source>Applies the changes when needed.</source>
          <target state="translated">필요할 때 변경 사항을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="fc45517f9cdde05557806db0dfe4a757bd3c77fc" translate="yes" xml:space="preserve">
          <source>Apply specific build options for just one locale</source>
          <target state="translated">하나의 로케일에만 특정 빌드 옵션 적용</target>
        </trans-unit>
        <trans-unit id="8c8b40621714f724e48fb235040b7320d47f4c4a" translate="yes" xml:space="preserve">
          <source>Apply that logic to navigation within the crisis center for which the parent path is &lt;code&gt;/crisis-center&lt;/code&gt;.</source>
          <target state="translated">상위 경로가 &lt;code&gt;/crisis-center&lt;/code&gt; 인 위기 센터 내 탐색에 해당 논리를 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d0e2a91303b222bcb13c0011660cfd943c66dc1" translate="yes" xml:space="preserve">
          <source>Apply the &lt;a href=&quot;https://wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;&lt;i&gt;single responsibility principle&lt;/i&gt; (SRP)&lt;/a&gt; to all components, services, and other symbols. This helps make the app cleaner, easier to read and maintain, and more testable.</source>
          <target state="translated">적용 &lt;a href=&quot;https://wikipedia.org/wiki/Single_responsibility_principle&quot;&gt;&lt;i&gt;단일 책임 원칙&lt;/i&gt; (SRP)을&lt;/a&gt; 모든 구성 요소, 서비스 및 기타 심볼. 이를 통해 앱을보다 깨끗하고 읽기 쉽고 유지 관리하며 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70fadc1252a55edfa904aa436966e9eecc7d3821" translate="yes" xml:space="preserve">
          <source>Apply the attribute directive</source>
          <target state="translated">속성 지시어 적용</target>
        </trans-unit>
        <trans-unit id="81d85d7da74461d1b53ba77a7b92cf43a5bb3128" translate="yes" xml:space="preserve">
          <source>Apply the decorator to the directive class.</source>
          <target state="translated">지시어 클래스에 데코레이터를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="45a85d2d0edb8623c0d82d2eb0a9a6cc99f9a2bb" translate="yes" xml:space="preserve">
          <source>Applying routable animations based on the page.</source>
          <target state="translated">페이지를 기반으로 라우팅 가능한 애니메이션 적용</target>
        </trans-unit>
        <trans-unit id="c804b003ae54f7640d1e2bbcc163cd9e623fb3dc" translate="yes" xml:space="preserve">
          <source>Applying the &lt;code&gt;::ng-deep&lt;/code&gt; pseudo-class to any CSS rule completely disables view-encapsulation for that rule. Any style with &lt;code&gt;::ng-deep&lt;/code&gt; applied becomes a global style. In order to scope the specified style to the current component and all its descendants, be sure to include the &lt;code&gt;:&lt;a href=&quot;../api/core/directive#host&quot;&gt;host&lt;/a&gt;&lt;/code&gt; selector before &lt;code&gt;::ng-deep&lt;/code&gt;. If the &lt;code&gt;::ng-deep&lt;/code&gt; combinator is used without the &lt;code&gt;:&lt;a href=&quot;../api/core/directive#host&quot;&gt;host&lt;/a&gt;&lt;/code&gt; pseudo-class selector, the style can bleed into other components.</source>
          <target state="translated">CSS 규칙에 &lt;code&gt;::ng-deep&lt;/code&gt; 의사 클래스를 적용하면 해당 규칙에 대한 뷰 캡슐화가 완전히 비활성화됩니다. 어떤 스타일의 &lt;code&gt;::ng-deep&lt;/code&gt; 적용은 전역 스타일이된다. 지정된 스타일을 현재 구성 요소 및 모든 하위 항목으로 범위를 지정하려면 &lt;code&gt;::ng-deep&lt;/code&gt; 앞에 &lt;code&gt;:&lt;a href=&quot;../api/core/directive#host&quot;&gt;host&lt;/a&gt;&lt;/code&gt; 선택자를 포함시켜야합니다 . 는 IF &lt;code&gt;::ng-deep&lt;/code&gt; 콤비가없이 사용 &lt;code&gt;:&lt;a href=&quot;../api/core/directive#host&quot;&gt;host&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/directive#host&quot;&gt;호스트&lt;/a&gt; 의사 클래스 선택기, 스타일이 다른 구성 요소에 피가 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ea007e76a7fe27744692b393421324935c1977d" translate="yes" xml:space="preserve">
          <source>Applying the &lt;code&gt;::ng-deep&lt;/code&gt; pseudo-class to any CSS rule completely disables view-encapsulation for that rule. Any style with &lt;code&gt;::ng-deep&lt;/code&gt; applied becomes a global style. In order to scope the specified style to the current component and all its descendants, be sure to include the &lt;code&gt;:host&lt;/code&gt; selector before &lt;code&gt;::ng-deep&lt;/code&gt;. If the &lt;code&gt;::ng-deep&lt;/code&gt; combinator is used without the &lt;code&gt;:host&lt;/code&gt; pseudo-class selector, the style can bleed into other components.</source>
          <target state="translated">적용 &lt;code&gt;::ng-deep&lt;/code&gt; 있는 CSS 규칙에 의사 클래스 완전히 그 규칙에 대한 뷰 캡슐화를 사용하지 않습니다. &lt;code&gt;::ng-deep&lt;/code&gt; 이 적용된 모든 스타일 은 전역 스타일이됩니다. 지정된 스타일의 범위를 현재 구성 요소 및 모든 하위 항목으로 지정하려면 &lt;code&gt;::ng-deep&lt;/code&gt; 앞에 &lt;code&gt;:host&lt;/code&gt; 선택기 를 포함해야합니다 . 는 IF &lt;code&gt;::ng-deep&lt;/code&gt; 콤비가없이 사용 &lt;code&gt;:host&lt;/code&gt; 의사 클래스 선택기, 스타일이 다른 구성 요소에 피가 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="971660e3eff74f1e73a9bc8202a365f6b3daf22d" translate="yes" xml:space="preserve">
          <source>Apps can use the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; to make &lt;a href=&quot;https://en.wikipedia.org/wiki/JSONP&quot;&gt;JSONP&lt;/a&gt; requests across domains when a server doesn't support &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS&quot;&gt;CORS protocol&lt;/a&gt;.</source>
          <target state="translated">앱은 서버가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS&quot;&gt;CORS 프로토콜을&lt;/a&gt; 지원하지 않는 경우 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 를 사용하여 도메인간에 &lt;a href=&quot;https://en.wikipedia.org/wiki/JSONP&quot;&gt;JSONP&lt;/a&gt; 요청을 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5626fa7bcd970831b49f0ca8814b78f9ec4931b4" translate="yes" xml:space="preserve">
          <source>Apps can use the the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; to make &lt;a href=&quot;https://en.wikipedia.org/wiki/JSONP&quot;&gt;JSONP&lt;/a&gt; requests across domains when the server doesn't support &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS&quot;&gt;CORS protocol&lt;/a&gt;.</source>
          <target state="translated">서버가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS&quot;&gt;CORS 프로토콜을&lt;/a&gt; 지원하지 않는 경우 앱은 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 를 사용하여 여러 도메인에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/JSONP&quot;&gt;JSONP&lt;/a&gt; 요청을 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e1bbeca79619dc168ee72be62c4c17e14e649d8" translate="yes" xml:space="preserve">
          <source>Apps do not typically need to create their own animation players, but if you do need to, follow these steps:</source>
          <target state="translated">앱은 일반적으로 자체 애니메이션 플레이어를 만들 필요는 없지만 필요한 경우 다음 단계를 따르십시오.</target>
        </trans-unit>
        <trans-unit id="8a2f874c6db468662ffb58a8875448a198ac499b" translate="yes" xml:space="preserve">
          <source>Apps often POST data to a server. They POST when submitting a form. In the following example, the &lt;code&gt;HeroesService&lt;/code&gt; posts when adding a hero to the database.</source>
          <target state="translated">앱은 종종 서버에 데이터를 POST합니다. 그들은 양식을 제출할 때 POST합니다. 다음 예에서 &lt;code&gt;HeroesService&lt;/code&gt; 는 데이터베이스에 영웅을 추가 할 때 게시합니다.</target>
        </trans-unit>
        <trans-unit id="30b7a831fd8ffb7da2ad0a9cf451a0c40ac3345a" translate="yes" xml:space="preserve">
          <source>Apps often define configuration objects with lots of small facts, like the title of the application or the address of a web API endpoint. These configuration objects aren't always instances of a class. They can be object literals, as shown in the following example.</source>
          <target state="translated">앱은 종종 애플리케이션 제목이나 웹 API 엔드 포인트의 주소와 같이 작은 사실이 많은 구성 객체를 정의합니다. 이러한 구성 개체가 항상 클래스의 인스턴스는 아닙니다. 다음 예제와 같이 객체 리터럴이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31f6ac215467451080a5eed53c7386613db6c2d4" translate="yes" xml:space="preserve">
          <source>Apps often send data to a server with a POST request when submitting a form. In the following example, the &lt;code&gt;HeroesService&lt;/code&gt; makes an HTTP POST request when adding a hero to the database.</source>
          <target state="translated">앱은 양식을 제출할 때 POST 요청과 함께 서버로 데이터를 보내는 경우가 많습니다. 다음 예에서 &lt;code&gt;HeroesService&lt;/code&gt; 는 데이터베이스에 Hero를 추가 할 때 HTTP POST 요청을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="382db7830add4fb204b6af3f246c22df74c9e4e7" translate="yes" xml:space="preserve">
          <source>Apps often use an interceptor to set default headers on outgoing requests.</source>
          <target state="translated">앱은 종종 인터셉터를 사용하여 발신 요청에 기본 헤더를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6ac8c049d51dfba584e44ce33593cd0fd0498c0b" translate="yes" xml:space="preserve">
          <source>Apps pass a &lt;code&gt;&lt;a href=&quot;../api/router/routes&quot;&gt;Routes&lt;/a&gt;&lt;/code&gt; array to &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; in order to configure the app-wide &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; service with routes. &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; returns a &lt;a href=&quot;../api/core/modulewithproviders&quot;&gt;ModuleWithProviders&lt;/a&gt;. You add that result to the &lt;code&gt;imports&lt;/code&gt; list of the root &lt;code&gt;AppModule&lt;/code&gt;.</source>
          <target state="translated">앱은 &lt;code&gt;&lt;a href=&quot;../api/router/routes&quot;&gt;Routes&lt;/a&gt;&lt;/code&gt; 있는 앱 전체 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 서비스 를 구성하기 위해 Routes 배열을 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; 에 전달합니다 . &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; 는 &lt;a href=&quot;../api/core/modulewithproviders&quot;&gt;ModuleWithProviders를&lt;/a&gt; 반환합니다 . 해당 결과를 루트 &lt;code&gt;AppModule&lt;/code&gt; 의 &lt;code&gt;imports&lt;/code&gt; 목록에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="e361112818e4768cac11b5e923f0fa29d5292891" translate="yes" xml:space="preserve">
          <source>Apps pass a &lt;code&gt;&lt;a href=&quot;../api/router/routes&quot;&gt;Routes&lt;/a&gt;&lt;/code&gt; object to &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; in order to configure the app-wide &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; service with routes. &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; returns a &lt;a href=&quot;../api/core/modulewithproviders&quot;&gt;ModuleWithProviders&lt;/a&gt;. You add that result to the &lt;code&gt;imports&lt;/code&gt; list of the root &lt;code&gt;AppModule&lt;/code&gt;.</source>
          <target state="translated">앱은 &lt;code&gt;&lt;a href=&quot;../api/router/routes&quot;&gt;Routes&lt;/a&gt;&lt;/code&gt; 를 사용하여 앱 전체의 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 서비스 를 구성하기 위해 Routes 객체를 &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; 에 전달합니다 . &lt;code&gt;&lt;a href=&quot;../api/router/routermodule#forRoot&quot;&gt;RouterModule.forRoot()&lt;/a&gt;&lt;/code&gt; 는 &lt;a href=&quot;../api/core/modulewithproviders&quot;&gt;ModuleWithProviders를&lt;/a&gt; 반환합니다 . 해당 결과를 루트 &lt;code&gt;AppModule&lt;/code&gt; 의 &lt;code&gt;imports&lt;/code&gt; 목록에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="cc390285ebab82a2a8d69e9aa75a08e70733597e" translate="yes" xml:space="preserve">
          <source>Apr 18, 2019</source>
          <target state="translated">2019 년 4 월 18 일</target>
        </trans-unit>
        <trans-unit id="89df6f0f2f5be74f2452247a90bf7057dde93046" translate="yes" xml:space="preserve">
          <source>Apr 18, 2020</source>
          <target state="translated">2020 년 4 월 18 일</target>
        </trans-unit>
        <trans-unit id="1571960f64dc1bbd85c8afae57c18c2fe87dc77c" translate="yes" xml:space="preserve">
          <source>April 15, 1988</source>
          <target state="translated">1988 년 4 월 15 일</target>
        </trans-unit>
        <trans-unit id="16639cf778dca6a11a26844b092710e566557dbc" translate="yes" xml:space="preserve">
          <source>Architect</source>
          <target state="translated">Architect</target>
        </trans-unit>
        <trans-unit id="2e99cf09904565828c48434629a7dae4ca7ab60a" translate="yes" xml:space="preserve">
          <source>Architect expects builders to run once (by default) and return. This behavior is not entirely compatible with a builder that watches for changes (like Webpack, for example). Architect can support watch mode, but there are some things to look out for.</source>
          <target state="translated">Architect는 빌더가 기본적으로 한 번 실행되어 돌아올 것으로 예상합니다. 이 동작은 변경을 감시하는 빌더 (예 : Webpack)와 완전히 호환되지 않습니다. Architect는 감시 모드를 지원할 수 있지만주의해야 할 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb12b45f1feccd3ae9df35525912508afafb94e0" translate="yes" xml:space="preserve">
          <source>Architect is the tool that the CLI uses to perform complex tasks such as compilation, according to provided configurations. The CLI commands run Architect targets such as &lt;code&gt;build&lt;/code&gt;, &lt;code&gt;serve&lt;/code&gt;, &lt;code&gt;test&lt;/code&gt;, and &lt;code&gt;lint&lt;/code&gt;. Each named target has a default configuration, specified by an &quot;options&quot; object, and an optional set of named alternate configurations in the &quot;configurations&quot; object.</source>
          <target state="translated">Architect는 제공된 구성에 따라 CLI가 컴파일과 같은 복잡한 작업을 수행하는 데 사용하는 도구입니다. CLI 명령은 &lt;code&gt;build&lt;/code&gt; , &lt;code&gt;serve&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; 및 &lt;code&gt;lint&lt;/code&gt; 와 같은 Architect 대상을 실행 합니다. 각각의 명명 된 대상에는 &quot;옵션&quot;개체에 의해 지정된 기본 구성과 &quot;구성&quot;개체에 명명 된 대체 구성의 선택적 세트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="87e9ee57ab4d3251e3425b9e1edd8474dc28d887" translate="yes" xml:space="preserve">
          <source>Architect is the tool that the CLI uses to perform complex tasks, such as compilation and test running. Architect is a shell that runs a specified &lt;a href=&quot;glossary#builder&quot;&gt;builder&lt;/a&gt; to perform a given task, according to a &lt;a href=&quot;glossary#target&quot;&gt;target&lt;/a&gt; configuration. You can define and configure new builders and targets to extend the CLI. See &lt;a href=&quot;cli-builder&quot;&gt;Angular CLI Builders&lt;/a&gt;.</source>
          <target state="translated">Architect는 CLI가 컴파일 및 테스트 실행과 같은 복잡한 작업을 수행하는 데 사용하는 도구입니다. Architect는 &lt;a href=&quot;glossary#target&quot;&gt;대상&lt;/a&gt; 구성 에 따라 지정된 &lt;a href=&quot;glossary#builder&quot;&gt;빌더&lt;/a&gt; 를 실행하여 지정된 태스크를 수행 하는 쉘입니다 . CLI를 확장하기 위해 새 빌더 및 대상을 정의하고 구성 할 수 있습니다. &lt;a href=&quot;cli-builder&quot;&gt;Angular CLI Builders를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="68a0175db55fe6829a7c4fdd2c0b28db697a3b08" translate="yes" xml:space="preserve">
          <source>Architect resolves input options for a given target by taking the default options object, then overwriting values from the configuration used (if any), then further overwriting values from the overrides object passed to &lt;code&gt;BuilderContext.scheduleTarget()&lt;/code&gt;. For the Angular CLI, the overrides object is built from command line arguments.</source>
          <target state="translated">Architect는 기본 옵션 오브젝트를 사용하여 사용 된 구성 (있는 경우)에서 값을 겹쳐 쓴 후 &lt;code&gt;BuilderContext.scheduleTarget()&lt;/code&gt; 전달 된 대체 오브젝트에서 값을 겹쳐 써서 지정된 대상의 입력 옵션을 분석합니다 . Angular CLI의 경우 대체 오브젝트는 명령 행 인수에서 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="650e1a2c31f381d1ef315d6ecb1f9821f346be20" translate="yes" xml:space="preserve">
          <source>Architect runs builders asynchronously. To invoke a builder, you schedule a task to be run when all configuration resolution is complete.</source>
          <target state="translated">Architect는 빌더를 비동기 적으로 실행합니다. 빌더를 호출하려면 모든 구성 분석이 완료 될 때 태스크가 실행되도록 스케줄하십시오.</target>
        </trans-unit>
        <trans-unit id="b8187a8b2aa9dac023d1b4014ab0ac3ced813c4c" translate="yes" xml:space="preserve">
          <source>Architect validates the resulting options values against the schema of the builder. If inputs are valid, Architect creates the context and executes the builder.</source>
          <target state="translated">Architect는 빌더의 스키마에 대해 결과 옵션 값의 유효성을 검증합니다. 입력이 유효하면 Architect는 컨텍스트를 작성하고 빌더를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="a8051a2dd19694f0d3cd62e35d681d609ea33a34" translate="yes" xml:space="preserve">
          <source>Architectural reasons may lead you to restrict access to a service to the application domain where it belongs. For example, the guide sample includes a &lt;code&gt;VillainsListComponent&lt;/code&gt; that displays a list of villains. It gets those villains from a &lt;code&gt;VillainsService&lt;/code&gt;.</source>
          <target state="translated">아키텍처상의 이유로 서비스에 대한 서비스가 속한 응용 프로그램 도메인에 대한 액세스를 제한 할 수 있습니다. 예를 들어, 가이드 샘플에는 &lt;code&gt;VillainsListComponent&lt;/code&gt; 목록을 표시하는 VillainsListComponent 가 포함되어 있습니다. 그것은 &lt;code&gt;VillainsService&lt;/code&gt; 에서 그 악당을 얻는다 .</target>
        </trans-unit>
        <trans-unit id="77cbe978decf7e18ac53e8ff64911f09e83509bc" translate="yes" xml:space="preserve">
          <source>Architecture Overview</source>
          <target state="translated">아키텍처 개요</target>
        </trans-unit>
        <trans-unit id="f01976881a77559b65df5022645150a74a52ede0" translate="yes" xml:space="preserve">
          <source>Architecture overview</source>
          <target state="translated">아키텍처 개요</target>
        </trans-unit>
        <trans-unit id="2745debaa64a20eedb49d9f14a0b807c87aa2d2a" translate="yes" xml:space="preserve">
          <source>Area</source>
          <target state="translated">Area</target>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="6001476930bb93c3e465d55fc3340756fadc4aa9" translate="yes" xml:space="preserve">
          <source>Argument and option names can be given in either &lt;a href=&quot;guide/glossary#case-types&quot;&gt;camelCase or dash-case&lt;/a&gt;. &lt;code&gt;--myOptionName&lt;/code&gt; is equivalent to &lt;code&gt;--my-option-name&lt;/code&gt;.</source>
          <target state="translated">인수 및 옵션 이름은 &lt;a href=&quot;guide/glossary#case-types&quot;&gt;camelCase 또는 dash-case&lt;/a&gt; 로 제공 될 수 있습니다 . &lt;code&gt;--myOptionName&lt;/code&gt; 은 &lt;code&gt;--my-option-name&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="c2f3a054448adb7997b5c36e72f9be845a0b4d34" translate="yes" xml:space="preserve">
          <source>Arguments (dependencies) to the &lt;code&gt;factory&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;factory&lt;/code&gt; 기능 에 대한 인수 (종속성)</target>
        </trans-unit>
        <trans-unit id="6b9d43f8a1c9ac290af8a299e9d3af0066551611" translate="yes" xml:space="preserve">
          <source>Arrange to use product data from an external file.</source>
          <target state="translated">외부 파일의 제품 데이터를 사용하도록 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="a2c4769fd815d0f8646a06e09c4545f8498d2d6d" translate="yes" xml:space="preserve">
          <source>Array index</source>
          <target state="translated">배열 인덱스</target>
        </trans-unit>
        <trans-unit id="6f34d9dcb007316860a77e1a43c21a988e0aec6d" translate="yes" xml:space="preserve">
          <source>Array of latest values for the controls</source>
          <target state="translated">컨트롤에 대한 최신 값의 배열</target>
        </trans-unit>
        <trans-unit id="73e2cda4b11ea7d0351e69232f425f934d2b347b" translate="yes" xml:space="preserve">
          <source>Array of values for the controls</source>
          <target state="translated">컨트롤의 값 배열</target>
        </trans-unit>
        <trans-unit id="b4549d1caf74aaf959dfe06fbea3422a27392589" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;toh-pt2&quot;&gt;before&lt;/a&gt;, whenever a user clicks on a hero name, the hero detail appears below the hero list. Now the &lt;code&gt;HeroDetailComponent&lt;/code&gt; is presenting those details instead of the &lt;code&gt;HeroesComponent&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;toh-pt2&quot;&gt;이전&lt;/a&gt; 과 마찬가지로 사용자가 영웅 이름을 클릭 할 때마다 영웅 세부 정보가 영웅 목록 아래에 나타납니다. 이제 &lt;code&gt;HeroDetailComponent&lt;/code&gt; 는 그 세부 사항 대신 제시 &lt;code&gt;HeroesComponent&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="135905d4765136f425c8108ca9e5fc0ab1204814" translate="yes" xml:space="preserve">
          <source>As Angular traverses the &lt;a href=&quot;glossary#view-hierarchy&quot;&gt;view hierarchy&lt;/a&gt; during change detection, it needs to be sure that a change in a child does not attempt to cause a change in its own parent. Such a change would not be rendered properly, because of how &lt;a href=&quot;glossary#unidirectional-data-flow&quot;&gt;unidirectional data flow&lt;/a&gt; works.</source>
          <target state="translated">Angular는 변경 감지 중에 &lt;a href=&quot;glossary#view-hierarchy&quot;&gt;뷰 계층 구조를&lt;/a&gt; 탐색하므로 자식의 변경으로 인해 자신의 부모가 변경되지 않도록해야합니다. 이러한 변경은 &lt;a href=&quot;glossary#unidirectional-data-flow&quot;&gt;단방향 데이터 흐름이&lt;/a&gt; 작동 하는 방식으로 인해 제대로 렌더링되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3c842fa8a1c751fb5dc02dea9b6a6f064a4ffc78" translate="yes" xml:space="preserve">
          <source>As a best practice, use only properties and methods that return values.</source>
          <target state="translated">가장 좋은 방법은 값을 반환하는 속성과 메서드 만 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ec3d80f7d4b233899494dbf2775945a44d2a0b43" translate="yes" xml:space="preserve">
          <source>As a general rule, a fix is considered for an LTS version if it resolves one of:</source>
          <target state="translated">일반적으로 다음 중 하나를 해결하는 경우 LTS 버전에 대한 수정 사항이 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="8320fed1ae9fa1073ff9c98aaa4a06e5e4044fa3" translate="yes" xml:space="preserve">
          <source>As a general rule, import modules with providers &lt;em&gt;exactly once&lt;/em&gt;, preferably in the application's &lt;em&gt;root module&lt;/em&gt;. That's also usually the best place to configure, wrap, and override them.</source>
          <target state="translated">일반적으로 공급자가있는 모듈 은 응용 프로그램의 &lt;em&gt;루트 모듈&lt;/em&gt; 에서 &lt;em&gt;정확히 한 번만&lt;/em&gt; 가져 오십시오 . 또한 일반적으로 구성, 랩 및 재정의하기에 가장 좋은 장소입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="deffe223d373efbae49c2b4d79dc103d2e7fb62c" translate="yes" xml:space="preserve">
          <source>As a host page for the &quot;Crisis Center&quot; feature, generate a &lt;code&gt;CrisisCenterHome&lt;/code&gt; component in the &lt;code&gt;crisis-center&lt;/code&gt; folder.</source>
          <target state="translated">&quot;Crisis Center&quot;기능의 호스트 페이지로 &lt;code&gt;crisis-center&lt;/code&gt; 폴더 에 &lt;code&gt;CrisisCenterHome&lt;/code&gt; 컴포넌트를 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="6741a935b466ce3ba8568d14e44c986be6ba23e2" translate="yes" xml:space="preserve">
          <source>As a library author, you can take several measures to provide an optimal experience for your users. First, enabling &lt;code&gt;strictNullChecks&lt;/code&gt; and including &lt;code&gt;null&lt;/code&gt; in an input's type, as appropriate, communicates to your consumers whether they can provide a nullable value or not. Additionally, it is possible to provide type hints that are specific to the template type checker. See &lt;a href=&quot;structural-directives#directive-type-checks&quot;&gt;Improving template type checking for custom directives&lt;/a&gt;, and &lt;a href=&quot;template-typecheck#input-setter-coercion&quot;&gt;Input setter coercion&lt;/a&gt; below.</source>
          <target state="translated">라이브러리 작성자는 사용자에게 최적의 환경을 제공하기 위해 몇 가지 조치를 취할 수 있습니다. 첫째, 가능 &lt;code&gt;strictNullChecks&lt;/code&gt; 을 포함하여 &lt;code&gt;null&lt;/code&gt; 을 적절하게 입력의 유형을, 당신의 소비자와 통신은이 널 (NULL) 값을 제공 할 수 있는지 여부. 또한 템플릿 유형 검사기와 관련된 유형 힌트를 제공 할 수 있습니다. 아래의 &lt;a href=&quot;structural-directives#directive-type-checks&quot;&gt;사용자 지정 지시문에 대한 템플릿 유형 검사 개선&lt;/a&gt; 및 &lt;a href=&quot;template-typecheck#input-setter-coercion&quot;&gt;입력 setter 강제를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0367e00c5bf2f26492dcf63c921938c118e9f471" translate="yes" xml:space="preserve">
          <source>As a library developer, you can create your own collections of custom schematics to integrate your library with the Angular CLI.</source>
          <target state="translated">라이브러리 개발자는 라이브러리를 Angular CLI와 통합하기 위해 고유 한 사용자 정의 회로도 모음을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dae413a6ba6d2275c4b29345c399c39ff53553d6" translate="yes" xml:space="preserve">
          <source>As a plain number, in milliseconds: &lt;code&gt;100&lt;/code&gt;</source>
          <target state="translated">밀리 초 단위의 일반 숫자 : &lt;code&gt;100&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d6c917d0ac550880e60ac6263e147c30d2fadd4" translate="yes" xml:space="preserve">
          <source>As a publisher, you create an &lt;code&gt;Observable&lt;/code&gt; instance that defines a &lt;em&gt;subscriber&lt;/em&gt; function. This is the function that is executed when a consumer calls the &lt;code&gt;subscribe()&lt;/code&gt; method. The subscriber function defines how to obtain or generate values or messages to be published.</source>
          <target state="translated">게시자 는 &lt;em&gt;구독자&lt;/em&gt; 기능 을 정의 하는 &lt;code&gt;Observable&lt;/code&gt; 인스턴스를 만듭니다 . 소비자가 &lt;code&gt;subscribe()&lt;/code&gt; 메소드를 호출 할 때 실행되는 함수입니다 . 구독자 기능은 게시 할 값 또는 메시지를 얻거나 생성하는 방법을 정의합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c55a0bd388216011207cfeb979c311669ad519c8" translate="yes" xml:space="preserve">
          <source>As a result, Angular isn't able to access the value and returns an error.</source>
          <target state="translated">결과적으로 Angular는 값에 액세스 할 수 없으며 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2fe3037ee9472bbe2a08e74181eb628e70a574ad" translate="yes" xml:space="preserve">
          <source>As a result, any text marked with &lt;code&gt;site header&lt;/code&gt; as the &lt;em&gt;meaning&lt;/em&gt; is translated exactly the same way.</source>
          <target state="translated">결과적으로 &lt;code&gt;site header&lt;/code&gt; 가 &lt;em&gt;의미&lt;/em&gt; 로 표시된 모든 텍스트 는 정확히 같은 방식으로 번역됩니다.</target>
        </trans-unit>
        <trans-unit id="f99b1d12288f5a74a23db49ac392deada3c9214a" translate="yes" xml:space="preserve">
          <source>As a result, templates that previously compiled under View Engine can fail type checking under Ivy. This can happen because Ivy's stricter checking catches genuine errors, or because application code is not typed correctly, or because the application uses libraries in which typings are inaccurate or not specific enough.</source>
          <target state="translated">결과적으로 이전에 View Engine에서 컴파일 한 템플릿은 Ivy에서 유형 검사에 실패 할 수 있습니다. 이것은 Ivy의 엄격한 검사가 진짜 오류를 포착하거나 애플리케이션 코드가 올바르게 입력되지 않았거나 애플리케이션이 입력이 정확하지 않거나 충분히 구체적이지 않은 라이브러리를 사용하기 때문에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90863afd93efc1b713bee9807c95ef1c370a7606" translate="yes" xml:space="preserve">
          <source>As a service &lt;em&gt;tester&lt;/em&gt;, you must at least think about the first level of service dependencies but you &lt;em&gt;can&lt;/em&gt; let Angular DI do the service creation and deal with constructor argument order when you use the &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; testing utility to provide and create services.</source>
          <target state="translated">서비스로 &lt;em&gt;시험기&lt;/em&gt; , 적어도 서비스 종속성의 첫 번째 수준에 대해 생각해야하지만 당신은 &lt;em&gt;할 수 있습니다&lt;/em&gt; 당신이 사용할 때 각도 DI는 생성자의 인자 순서로 서비스 생성과 거래를 할 수 있도록 &lt;code&gt;&lt;a href=&quot;../api/core/testing/testbed&quot;&gt;TestBed&lt;/a&gt;&lt;/code&gt; 제공 및 서비스를 만드는 테스트 유틸리티를.</target>
        </trans-unit>
        <trans-unit id="616385f40de73bc1604f409e096ab6453c995cb2" translate="yes" xml:space="preserve">
          <source>As a side-effect, &lt;code&gt;SelectivePreloadingStrategyService&lt;/code&gt; logs the &lt;code&gt;path&lt;/code&gt; of a selected route in its public &lt;code&gt;preloadedModules&lt;/code&gt; array.</source>
          <target state="translated">부작용으로 &lt;code&gt;SelectivePreloadingStrategyService&lt;/code&gt; 는 로그 &lt;code&gt;path&lt;/code&gt; 공개 중 선택된 경로 &lt;code&gt;preloadedModules&lt;/code&gt; 의 배열.</target>
        </trans-unit>
        <trans-unit id="4b7ecaa28f2dff4ab449f30fd1ccc45445c8a41d" translate="yes" xml:space="preserve">
          <source>As a two-way binding: &lt;code&gt;&amp;lt;my-component [(myValue)]=&quot;anExpression&quot;&amp;gt;&lt;/code&gt;. Since most AngularJS two-way bindings actually only need a one-way binding in practice, &lt;code&gt;&amp;lt;my-component [myValue]=&quot;anExpression&quot;&amp;gt;&lt;/code&gt; is often enough.</source>
          <target state="translated">양방향 바인딩으로 : &lt;code&gt;&amp;lt;my-component [(myValue)]=&quot;anExpression&quot;&amp;gt;&lt;/code&gt; . 대부분의 AngularJS 양방향 바인딩에는 실제로 단방향 바인딩 만 필요하기 때문에 &lt;code&gt;&amp;lt;my-component [myValue]=&quot;anExpression&quot;&amp;gt;&lt;/code&gt; 이면 충분합니다.</target>
        </trans-unit>
        <trans-unit id="6a5046b79e09cacb258f1a59b23f0229cab23310" translate="yes" xml:space="preserve">
          <source>As a workaround for this problem, Angular supports checking a wider, more permissive type for &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; than is declared for the input field itself. Enable this by adding a static property with the &lt;code&gt;ngAcceptInputType_&lt;/code&gt; prefix to the component class:</source>
          <target state="translated">이 문제에 대한 해결 방법으로 Angular는 입력 필드 자체에 대해 선언 된 것보다 더 넓고 허용적인 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; 유형 검사를 지원 합니다. &lt;code&gt;ngAcceptInputType_&lt;/code&gt; 접두사가 있는 정적 속성을 구성 요소 클래스 에 추가하여이를 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="70711c31150ebda36f5058c7ef67fc2dc552d337" translate="yes" xml:space="preserve">
          <source>As above, the target is the button's click event.</source>
          <target state="translated">위와 같이 대상은 버튼의 클릭 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="a2fa8220cfc617a4e487c2e9bd8726e63796dd6d" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s create a builder that executes a shell command. To create a builder, use the &lt;code&gt;createBuilder()&lt;/code&gt; CLI Builder function, and return a &lt;code&gt;BuilderOutput&lt;/code&gt; object.</source>
          <target state="translated">예를 들어, 쉘 명령을 실행하는 빌더를 작성하십시오. 빌더를 작성하려면 &lt;code&gt;createBuilder()&lt;/code&gt; CLI 빌더 함수를 사용하고 &lt;code&gt;BuilderOutput&lt;/code&gt; 오브젝트를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d7ae9f459bc0881d55f11ec081e180bb57aec8d" translate="yes" xml:space="preserve">
          <source>As an example, let's create a builder that executes a shell command. To create a builder, use the &lt;code&gt;createBuilder()&lt;/code&gt; CLI Builder function, and return a &lt;code&gt;Promise&amp;lt;BuilderOutput&amp;gt;&lt;/code&gt; object.</source>
          <target state="translated">예를 들어 셸 명령을 실행하는 빌더를 만들어 보겠습니다. 빌더를 생성하려면 &lt;code&gt;createBuilder()&lt;/code&gt; CLI Builder 함수를 사용하고 &lt;code&gt;Promise&amp;lt;BuilderOutput&amp;gt;&lt;/code&gt; 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="a1693faa6c4defc1d4a4ffd82c7efdcbe67d91f3" translate="yes" xml:space="preserve">
          <source>As applications grow in functionality, they also grow in size. The CLI allows you to set size thresholds in your configuration to ensure that parts of your application stay within size boundaries that you define.</source>
          <target state="translated">응용 프로그램의 기능이 커지면 크기도 커집니다. CLI를 사용하면 구성에서 크기 임계 값을 설정하여 응용 프로그램의 일부가 사용자가 정의한 크기 범위 내에 있도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="426d689742e365afbaea750636ace81f4c7d3a54" translate="yes" xml:space="preserve">
          <source>As described above, in reactive forms each form element in the view is directly linked to a form model (&lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; instance). Updates from the view to the model and from the model to the view are synchronous and aren't dependent on the UI rendered. The diagrams below use the same favorite color example to demonstrate how data flows when an input field's value is changed from the view and then from the model.</source>
          <target state="translated">전술 한 바와 같이, 반응성 형태에서, 뷰의 각 형태 요소는 형태 모델 ( &lt;code&gt;&lt;a href=&quot;../api/forms/formcontrol&quot;&gt;FormControl&lt;/a&gt;&lt;/code&gt; 인스턴스)에 직접 연결된다 . 뷰에서 모델로, 모델에서 뷰로의 업데이트는 동기식이며 렌더링 된 UI에 의존하지 않습니다. 아래 다이어그램은 동일한 선호 색상 예제를 사용하여 입력 필드 값이보기에서 모델로 변경 될 때 데이터가 흐르는 방식을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="880f9c880127736c203edc896434eeab319390fd" translate="yes" xml:space="preserve">
          <source>As discussed earlier, component CSS styles are encapsulated into the component's view and don't affect the rest of the application.</source>
          <target state="translated">앞에서 설명한 것처럼 구성 요소 CSS 스타일은 구성 요소의보기로 캡슐화되며 나머지 응용 프로그램에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b0f7dd7e0658c043afd1da5639cb6335884c9a5" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;testing#compile-components&quot;&gt;&lt;em&gt;Calling compileComponents()&lt;/em&gt;&lt;/a&gt; above, these tests could be run in a non-CLI environment where Angular would have to compile them in the browser.</source>
          <target state="translated">위의 &lt;a href=&quot;testing#compile-components&quot;&gt;&lt;em&gt;compileComponents () 호출&lt;/em&gt;&lt;/a&gt; 에서 설명한대로 Angular가 브라우저에서 컴파일해야하는 CLI 환경이 아닌 환경에서 이러한 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20a3fc12c0b57f9f4fde41ae63301b30c12c4ab4" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;testing-components-scenarios#compile-components&quot;&gt;&lt;em&gt;Calling compileComponents()&lt;/em&gt;&lt;/a&gt; above, these tests could be run in a non-CLI environment where Angular would have to compile them in the browser.</source>
          <target state="translated">위의 &lt;a href=&quot;testing-components-scenarios#compile-components&quot;&gt;&lt;em&gt;compileComponents () 호출&lt;/em&gt;&lt;/a&gt; 에서 설명한 것처럼 이러한 테스트는 Angular가 브라우저에서 컴파일해야하는 비 CLI 환경에서 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79d75fcadb38a027a00ab11f48886637114c88fe" translate="yes" xml:space="preserve">
          <source>As for any external dependency, you must mock the HTTP backend so your tests can simulate interaction with a remote server. The &lt;code&gt;@angular/common/&lt;a href=&quot;../api/common/http&quot;&gt;http&lt;/a&gt;/testing&lt;/code&gt; library makes it straightforward to set up such mocking.</source>
          <target state="translated">외부 종속성의 경우 테스트에서 원격 서버와의 상호 작용을 시뮬레이션 할 수 있도록 HTTP 백엔드를 조롱해야합니다. &lt;code&gt;@angular/common/&lt;a href=&quot;../api/common/http&quot;&gt;http&lt;/a&gt;/testing&lt;/code&gt; 라이브러리 것은 그러한 조롱을 설정하는 간단합니다.</target>
        </trans-unit>
        <trans-unit id="58c8b5c36d35cc82268e080bce5657fe17ae5ed0" translate="yes" xml:space="preserve">
          <source>As for any of the HTTP methods that return an observable, the caller, &lt;code&gt;HeroesComponent.update()&lt;/code&gt;&lt;a href=&quot;http#always-subscribe&quot;&gt;must &lt;code&gt;subscribe()&lt;/code&gt;&lt;/a&gt; to the observable returned from the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#put&quot;&gt;HttpClient.put()&lt;/a&gt;&lt;/code&gt; in order to initiate the request.</source>
          <target state="translated">Observable을 반환하는 HTTP 메서드의 경우 호출자 인 &lt;code&gt;HeroesComponent.update()&lt;/code&gt; &lt;a href=&quot;http#always-subscribe&quot;&gt;는 &lt;code&gt;subscribe()&lt;/code&gt; &lt;/a&gt; 요청을 시작하기 위해 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient#put&quot;&gt;HttpClient.put()&lt;/a&gt;&lt;/code&gt; 에서 반환 된 Observable에 subscribe () 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0535610d785a6f15d9d14a76e023b8b818afd751" translate="yes" xml:space="preserve">
          <source>As mentioned before, one of the key differences between &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; has to do with change detection and how it is propagated between the two frameworks.</source>
          <target state="translated">앞에서 언급했듯이 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 의 주요 차이점 중 하나는 변경 감지 및 두 프레임 워크간에 전파되는 방식과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="53b618af56c304e8ae9ebf8b1422dcc8b530788c" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; needs to know how to instantiate the Angular module. It needs a recipe. You define that recipe by providing a factory function that can create an instance of the Angular module. &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; accepts two types of factory functions:</source>
          <target state="translated">앞에서 언급했듯이 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; 은 Angular 모듈을 인스턴스화하는 방법을 알아야합니다. 레시피가 필요합니다. Angular 모듈의 인스턴스를 생성 할 수있는 팩토리 함수를 제공하여 해당 레시피를 정의합니다. &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; 은 두 가지 유형의 팩토리 함수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="6075532c0eead9c5665dc3a24b06aa65dfa58aa5" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;dependency-injection-providers#interface-not-valid-token&quot;&gt;DI Providers&lt;/a&gt;, an interface is not a valid DI token because it is a TypeScript artifact that doesn't exist at run time. Use this abstract class interface to get the strong typing of an interface, and also use it as a provider token in the way you would a normal class.</source>
          <target state="translated">&lt;a href=&quot;dependency-injection-providers#interface-not-valid-token&quot;&gt;DI Providers&lt;/a&gt; 에서 언급했듯이 인터페이스는 런타임에 존재하지 않는 TypeScript 아티팩트이므로 유효한 DI 토큰이 아닙니다. 이 추상 클래스 인터페이스를 사용하여 인터페이스를 강력하게 입력하고 일반 클래스와 같은 방식으로 제공자 토큰으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="33d0f422fdd64842f16a4d3168edce86723cf79d" translate="yes" xml:space="preserve">
          <source>As minimal as this is, you decide to add a test to confirm that component actually displays the right content where you think it should.</source>
          <target state="translated">최소한으로 테스트를 추가하여 구성 요소가 실제로 표시되어야한다고 생각하는 올바른 콘텐츠를 표시하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="cd46491ceb36e17c510a8c461798cf44a0906cd6" translate="yes" xml:space="preserve">
          <source>As of Angular v8, the CLI primarily consumes the &lt;code&gt;fesm2015&lt;/code&gt; variant of the code distributed via &lt;code&gt;@angular/*&lt;/code&gt; npm packages. This renders the &lt;code&gt;esm5&lt;/code&gt; and &lt;code&gt;fesm5&lt;/code&gt; distributions obsolete and unnecessary, adding bloat to the package size and slowing down npm installations.</source>
          <target state="translated">Angular v8부터 CLI는 주로 &lt;code&gt;@angular/*&lt;/code&gt; npm 패키지 를 통해 배포 된 코드 의 &lt;code&gt;fesm2015&lt;/code&gt; 변형을 사용 합니다. 이로 인해 &lt;code&gt;esm5&lt;/code&gt; 및 &lt;code&gt;fesm5&lt;/code&gt; 배포가 쓸모없고 불필요 해져 패키지 크기가 커지고 npm 설치 속도가 느려집니다.</target>
        </trans-unit>
        <trans-unit id="b355748c485647b9309423108913382295cddbcc" translate="yes" xml:space="preserve">
          <source>As of Angular version 8, all &lt;code&gt;platform-webworker&lt;/code&gt; APIs are deprecated. This includes both packages: &lt;code&gt;@angular/platform-webworker&lt;/code&gt; and &lt;code&gt;@angular/platform-webworker-dynamic&lt;/code&gt;.</source>
          <target state="translated">Angular 버전 8 &lt;code&gt;platform-webworker&lt;/code&gt; 모든 플랫폼 웹 워크 API가 더 이상 사용되지 않습니다. 여기에는 &lt;code&gt;@angular/platform-webworker&lt;/code&gt; 및 &lt;code&gt;@angular/platform-webworker-dynamic&lt;/code&gt; 패키지가 모두 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="7a5efb4af0cce4e2df85ce6e18e4d43895419baa" translate="yes" xml:space="preserve">
          <source>As of Angular version 8, lazy loading code can be accomplished simply by using the dynamic import syntax &lt;code&gt;import('...')&lt;/code&gt;. In your application, you create a new service that uses dynamic imports to lazy load AngularJS.</source>
          <target state="translated">Angular 버전 8부터는 동적 가져 오기 구문 &lt;code&gt;import('...')&lt;/code&gt; 를 사용하여 지연 로딩 코드를 간단히 수행 할 수 있습니다 . 애플리케이션에서 동적 가져 오기를 사용하여 AngularJS를 지연로드하는 새 서비스를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="f2b967a3b46ad610174c160fc5ddca36a5857336" translate="yes" xml:space="preserve">
          <source>As of Angular version 9, you can provide a new instance of a service with each lazy loaded module. The following code adds this functionality to &lt;code&gt;UserService&lt;/code&gt;.</source>
          <target state="translated">Angular 버전 9부터는 지연로드 된 각 모듈에 서비스의 새 인스턴스를 제공 할 수 있습니다. 다음 코드는이 기능을 &lt;code&gt;UserService&lt;/code&gt; 에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="c5ee2759213bc4f0ebf30b6a7a48dab5168a4a75" translate="yes" xml:space="preserve">
          <source>As of Typescript 2.0, you can enforce &lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html&quot;&gt;strict null checking&lt;/a&gt; with the &lt;code&gt;--strictNullChecks&lt;/code&gt; flag. TypeScript then ensures that no variable is unintentionally &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Typescript 2.0부터 &lt;code&gt;--strictNullChecks&lt;/code&gt; 플래그를 사용하여 &lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html&quot;&gt;엄격한 null 검사&lt;/a&gt; 를 시행 할 수 있습니다 . TypeScript는 의도하지 않게 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 변수가 없는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="1a5d8ac3e628f548a6202a37c401e9210549cc5a" translate="yes" xml:space="preserve">
          <source>As of Typescript 2.0, you can enforce &lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html&quot;&gt;strict null checking&lt;/a&gt; with the &lt;code&gt;--strictNullChecks&lt;/code&gt; flag. TypeScript then ensures that no variable is unintentionally null or undefined.</source>
          <target state="translated">Typescript 2.0부터 &lt;code&gt;--strictNullChecks&lt;/code&gt; 플래그를 사용하여 &lt;a href=&quot;http://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html&quot;&gt;엄격한 null 검사&lt;/a&gt; 를 시행 할 수 있습니다 . 그런 다음 TypeScript는 실수로 null이거나 정의되지 않은 변수가 없는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d061698b8c3e7c9261daa566883ca6fd0824feb8" translate="yes" xml:space="preserve">
          <source>As part of the v11 release, we introduced an opt-in preview of webpack 5 in the Angular CLI. To ensure stability, we&amp;rsquo;ll continue iterating on the implementation to enable build speed and bundle size improvements.</source>
          <target state="translated">v11 릴리스의 일부로 Angular CLI에서 webpack 5의 옵트 인 미리보기를 도입했습니다. 안정성을 보장하기 위해 빌드 속도와 번들 크기를 개선 할 수 있도록 구현을 계속 반복 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="6c04205c526a4908855b8b9cd7699a33503a185d" translate="yes" xml:space="preserve">
          <source>As service &lt;em&gt;consumer&lt;/em&gt;, you don't worry about any of this. You don't worry about the order of constructor arguments or how they're created.</source>
          <target state="translated">서비스 &lt;em&gt;소비자&lt;/em&gt; 는 이에 대해 걱정하지 않아도됩니다. 생성자 인수의 순서 나 생성 방식에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="09675c24345fed803a2cf94990f46e1bde9b0591" translate="yes" xml:space="preserve">
          <source>As shown in the previous section, you can use the impure &lt;code&gt;&lt;a href=&quot;../api/common/asyncpipe&quot;&gt;AsyncPipe&lt;/a&gt;&lt;/code&gt; to accept an observable as input and subscribe to the input automatically. You can also create an impure pipe to make and cache an HTTP request.</source>
          <target state="translated">이전 섹션에서 볼 수 &lt;code&gt;&lt;a href=&quot;../api/common/asyncpipe&quot;&gt;AsyncPipe&lt;/a&gt;&lt;/code&gt; , 순수 AsyncPipe 를 사용하여 Observable을 입력으로 받아들이고 입력을 자동으로 구독 할 수 있습니다. HTTP 요청을 만들고 캐시하기 위해 불순한 파이프를 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d046d3787fe0555ffbe29692f926aa83f46f12d8" translate="yes" xml:space="preserve">
          <source>As soon as you import the &lt;code&gt;&lt;a href=&quot;formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt;, this directive becomes active by default on all &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tags. You don't need to add a special selector.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; 을 가져 오면 이 지시문은 기본적으로 모든 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 태그 에서 활성화됩니다 . 특수 선택기를 추가하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="1c2a6c1dd7997586cb51494b2cd0194944234721" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;NgFor&lt;/code&gt; directive loops through the list, it sets and resets properties of its own &lt;em&gt;context&lt;/em&gt; object. These properties can include, but aren't limited to, &lt;code&gt;index&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../api/common/ngforofcontext#odd&quot;&gt;odd&lt;/a&gt;&lt;/code&gt;, and a special property named &lt;code&gt;$implicit&lt;/code&gt;.</source>
          <target state="translated">는 AS &lt;code&gt;NgFor&lt;/code&gt; 의 리스트를 지정 문 루프, 그것을 설정하고 자신의 재설정 속성 &lt;em&gt;컨텍스트&lt;/em&gt; 객체입니다. 이러한 속성에는 &lt;code&gt;index&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../api/common/ngforofcontext#odd&quot;&gt;odd&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;$implicit&lt;/code&gt; 이라는 특수 속성 이 포함될 수 있지만 이에 국한되지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f7b7f4dc0aa08937d1e4f42bb1268cea1478924f" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;NgFor&lt;/code&gt; directive loops through the list, it sets and resets properties of its own &lt;em&gt;context&lt;/em&gt; object. These properties can include, but aren't limited to, &lt;code&gt;index&lt;/code&gt;, &lt;code&gt;odd&lt;/code&gt;, and a special property named &lt;code&gt;$implicit&lt;/code&gt;.</source>
          <target state="translated">는 AS &lt;code&gt;NgFor&lt;/code&gt; 의 리스트를 지정 문 루프, 그것을 설정하고 자신의 재설정 속성 &lt;em&gt;컨텍스트&lt;/em&gt; 객체입니다. 이러한 속성에는 &lt;code&gt;index&lt;/code&gt; , &lt;code&gt;odd&lt;/code&gt; 및 &lt;code&gt;$implicit&lt;/code&gt; 라는 특수 속성 이 포함될 수 있지만 이에 국한되지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="cb72e80f48988fd1b9af9fabfe152ff02575aa3d" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;isStable&lt;/code&gt; Observable runs outside the zone, the &lt;code&gt;value&lt;/code&gt; field will be updated properly, but the template will not be refreshed!</source>
          <target state="translated">는 AS &lt;code&gt;isStable&lt;/code&gt; 관찰 가능한이 영역 외부에서 실행의 &lt;code&gt;value&lt;/code&gt; 필드가 제대로 업데이트되지만 템플릿은 갱신되지 않습니다!</target>
        </trans-unit>
        <trans-unit id="b2ba4060e4e4afd4ec60303640effc6e19da00de" translate="yes" xml:space="preserve">
          <source>As the app grows, this rule becomes even more important. &lt;a href=&quot;styleguide#toc&quot;&gt;Back to top&lt;/a&gt;</source>
          <target state="translated">앱이 커질수록이 규칙이 더욱 중요해집니다. &lt;a href=&quot;styleguide#toc&quot;&gt;맨 위로&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9fd7ba003f3292144c561737946a97b69bfe0de5" translate="yes" xml:space="preserve">
          <source>As the application logic updates component data, values that are bound to DOM properties in the view can change. The change detector is responsible for updating the view to reflect the current data model. Similarly, the user can interact with the UI, causing events that change the state of the data model. These events can trigger change detection.</source>
          <target state="translated">응용 프로그램 논리가 구성 요소 데이터를 업데이트하면 뷰의 DOM 속성에 바인딩 된 값이 변경 될 수 있습니다. 변경 감지기는 현재 데이터 모델을 반영하도록 뷰를 업데이트합니다. 마찬가지로 사용자는 UI와 상호 작용하여 데이터 모델의 상태를 변경하는 이벤트를 일으킬 수 있습니다. 이러한 이벤트는 변경 감지를 트리거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83b41c56b3b8492075b0d6fee4f3faaeb4fc7ed3" translate="yes" xml:space="preserve">
          <source>As the diagram shows, use inputs and outputs together in the same manner as using them separately. Here, the child selector is &lt;code&gt;&amp;lt;app-input-output&amp;gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;deleteRequest&lt;/code&gt; being &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; properties in the child component class. The property &lt;code&gt;currentItem&lt;/code&gt; and the method &lt;code&gt;crossOffItem()&lt;/code&gt; are both in the parent component class.</source>
          <target state="translated">다이어그램에서 볼 수 있듯이 입력과 출력을 따로 사용하는 것과 같은 방식으로 함께 사용하십시오. 여기에서 자식 선택기는 자식 구성 요소 클래스의 &lt;code&gt;&lt;a href=&quot;../api/core/iterablechangerecord#item&quot;&gt;item&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;deleteRequest&lt;/code&gt; 가 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt; () 및 &lt;code&gt;@&lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/output&quot;&gt;Output&lt;/a&gt; () 속성 인 &lt;code&gt;&amp;lt;app-input-output&amp;gt;&lt;/code&gt; 입니다 . &lt;code&gt;currentItem&lt;/code&gt; 속성 과 &lt;code&gt;crossOffItem()&lt;/code&gt; 메서드 는 모두 부모 구성 요소 클래스에 있습니다.</target>
        </trans-unit>
        <trans-unit id="576de19f7cd986ea910a0781414027d767fdf59f" translate="yes" xml:space="preserve">
          <source>As the message says, the &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; element does not have a &lt;code&gt;colspan&lt;/code&gt; property. This is true because &lt;code&gt;colspan&lt;/code&gt; is an attribute&amp;mdash;&lt;code&gt;colSpan&lt;/code&gt;, with a capital &lt;code&gt;S&lt;/code&gt;, is the corresponding property. Interpolation and property binding can set only &lt;em&gt;properties&lt;/em&gt;, not attributes.</source>
          <target state="translated">메시지에서 알 수 있듯이 &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; 요소에는 &lt;code&gt;colspan&lt;/code&gt; 속성 이 없습니다 . 때문에 마찬가지입니다 &lt;code&gt;colspan&lt;/code&gt; attribute-입니다 &lt;code&gt;colSpan&lt;/code&gt; 자본으로, &lt;code&gt;S&lt;/code&gt; , 해당 속성입니다. 보간 및 속성 바인딩은 &lt;em&gt;속성&lt;/em&gt; 이 아닌 속성 만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44bacbc3e7fdb0b748fcb62abf55c43e15ce9165" translate="yes" xml:space="preserve">
          <source>As the user types in the search box, an input event binding calls the component's &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/%24locationshim#search&quot;&gt;search()&lt;/a&gt;&lt;/code&gt; method with the new search box value.</source>
          <target state="translated">사용자가 검색 상자에 입력하면 입력 이벤트 바인딩 이 새 검색 상자 값으로 구성 요소의 &lt;code&gt;&lt;a href=&quot;../api/common/upgrade/%24locationshim#search&quot;&gt;search()&lt;/a&gt;&lt;/code&gt; 메서드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="ec9c4d6216d77cc7b2875d1877e97fc0a3a9215c" translate="yes" xml:space="preserve">
          <source>As the user types in the search box, an input event binding calls the component's &lt;code&gt;search()&lt;/code&gt; method with the new search box value.</source>
          <target state="translated">사용자가 검색 상자에 입력하면 입력 이벤트 바인딩 이 새 검색 상자 값으로 구성 요소의 &lt;code&gt;search()&lt;/code&gt; 메서드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="9055245f3b1e80adc8f94fdba52f5ad34bb44d2d" translate="yes" xml:space="preserve">
          <source>As the validation begins, the &lt;code&gt;UniqueAlterEgoValidator&lt;/code&gt; delegates to the &lt;code&gt;HeroesService&lt;/code&gt;&lt;code&gt;isAlterEgoTaken()&lt;/code&gt; method with the current control value. At this point the control is marked as &lt;code&gt;pending&lt;/code&gt; and remains in this state until the observable chain returned from the &lt;code&gt;validate()&lt;/code&gt; method completes.</source>
          <target state="translated">유효성 검사가 시작되면 &lt;code&gt;UniqueAlterEgoValidator&lt;/code&gt; 는 현재 제어 값 을 사용하여 &lt;code&gt;HeroesService&lt;/code&gt; &lt;code&gt;isAlterEgoTaken()&lt;/code&gt; 메서드에 위임 합니다. 이 시점에서 제어는 &lt;code&gt;pending&lt;/code&gt; 표시되며 &lt;code&gt;validate()&lt;/code&gt; 메소드 에서 리턴 된 관찰 가능 체인이 완료 될 때까지이 상태를 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="9155140d162aff11a01a9aaf192b5c36f36d8504" translate="yes" xml:space="preserve">
          <source>As these kinds of parameters don't fit easily in a URL path, you can use optional parameters for conveying arbitrarily complex information during navigation. Optional parameters aren't involved in pattern matching and afford flexibility of expression.</source>
          <target state="translated">이러한 종류의 매개 변수는 URL 경로에 쉽게 맞지 않으므로 탐색 중에 임의의 복잡한 정보를 전달하기 위해 선택적 매개 변수를 사용할 수 있습니다. 선택적 매개 변수는 패턴 일치에 관여하지 않으며 표현의 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="012a24a970804ecbbe43bf6ba131c69195b1c31f" translate="yes" xml:space="preserve">
          <source>As these validators are all sync validators, you pass them in as the second argument.</source>
          <target state="translated">이 유효성 검사기는 모두 동기화 유효성 검사기이므로 두 번째 인수로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="0f45027f55358700d46117f934776e60e6b2ad7a" translate="yes" xml:space="preserve">
          <source>As users enter form data, you'll capture their changes and update an instance of a model. You can't lay out the form until you know what the model looks like.</source>
          <target state="translated">사용자가 양식 데이터를 입력하면 변경 사항을 캡처하고 모델 인스턴스를 업데이트합니다. 모델의 모양을 알 때까지 양식을 배치 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1b00d72f3724db2eb2f17c415c8acad26e63056a" translate="yes" xml:space="preserve">
          <source>As usual, you write a constructor that asks Angular to inject services that the component requires and reference them as private variables.</source>
          <target state="translated">평소와 같이, Angular에게 컴포넌트에 필요한 서비스를 주입하고 프라이빗 변수로 참조하도록 요청하는 생성자를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="2a5fa238e4e05c9102523cdc407b74b4b0c63df8" translate="yes" xml:space="preserve">
          <source>As with components, you can add as many directive property bindings as you need by stringing them along in the template. The developer should be able to write the following template HTML to both bind to the &lt;code&gt;AppComponent.color&lt;/code&gt; and fall back to &quot;violet&quot; as the default color.</source>
          <target state="translated">컴포넌트와 마찬가지로 템플릿에서 문자열을 묶어 필요한만큼 지시문 속성 바인딩을 추가 할 수 있습니다. 개발자는 &lt;code&gt;AppComponent.color&lt;/code&gt; 에 바인딩 하고 기본 색상으로 &quot;violet&quot;으로 대체 하기 위해 다음 템플릿 HTML을 작성할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="30b5e960013eb063b20be7ecc6ff05c14a6c57f8" translate="yes" xml:space="preserve">
          <source>As with expressions, avoid writing complex template statements. A method call or simple property assignment should be the norm.</source>
          <target state="translated">식과 마찬가지로 복잡한 템플릿 문을 작성하지 마십시오. 메서드 호출이나 간단한 속성 할당이 표준이어야합니다.</target>
        </trans-unit>
        <trans-unit id="07c4c64d5513511be2cb127c82fcb01ee8b7e55a" translate="yes" xml:space="preserve">
          <source>As with expressions, statements can refer only to what's in the statement context such as an event handling method of the component instance.</source>
          <target state="translated">표현식과 마찬가지로 명령문은 구성 요소 인스턴스의 이벤트 처리 방법과 같은 명령문 컨텍스트에있는 내용 만 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb901be354860557451c002789bc0c1663e2f0b6" translate="yes" xml:space="preserve">
          <source>As with other directives, you apply a structural directive to a &lt;em&gt;host element&lt;/em&gt;. The directive then does whatever it's supposed to do with that host element and its descendants.</source>
          <target state="translated">다른 지시문과 마찬가지로 &lt;em&gt;호스트&lt;/em&gt; 지시문에 구조적 지시문을 적용합니다 . 그런 다음 지시문은 해당 호스트 요소 및 해당 하위 요소와 관련된 모든 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1d5b6417cba4ef881daf50c6a534671a6568bcbd" translate="yes" xml:space="preserve">
          <source>As with other structural directives, the &lt;code&gt;&lt;a href=&quot;../api/common/ngswitchcase&quot;&gt;NgSwitchCase&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/common/ngswitchdefault&quot;&gt;NgSwitchDefault&lt;/a&gt;&lt;/code&gt; can be desugared into the &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; element form.</source>
          <target state="translated">다른 구조적 지시문과 마찬가지로 &lt;code&gt;&lt;a href=&quot;../api/common/ngswitchcase&quot;&gt;NgSwitchCase&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/common/ngswitchdefault&quot;&gt;NgSwitchDefault&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&amp;lt;ng-template&amp;gt;&lt;/code&gt; 요소 형식 으로 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf9ee189724da5d4f748ccae4de0e3edcce56bb7" translate="yes" xml:space="preserve">
          <source>As with the &lt;code&gt;HeroesModule&lt;/code&gt;, you must add the &lt;code&gt;CrisisCenterModule&lt;/code&gt; to the &lt;code&gt;imports&lt;/code&gt; array of the &lt;code&gt;AppModule&lt;/code&gt;&lt;em&gt;before&lt;/em&gt; the &lt;code&gt;AppRoutingModule&lt;/code&gt;:</source>
          <target state="translated">와 마찬가지로 &lt;code&gt;HeroesModule&lt;/code&gt; , 당신은 추가해야합니다 &lt;code&gt;CrisisCenterModule&lt;/code&gt; 을 받는 &lt;code&gt;imports&lt;/code&gt; 의 배열 &lt;code&gt;AppModule&lt;/code&gt; &lt;em&gt;전에 &lt;/em&gt; &lt;code&gt;AppRoutingModule&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6d5ad368cf59cb55a48ed7f1273bd908182ba7f4" translate="yes" xml:space="preserve">
          <source>As with the previous &lt;code&gt;expectOne()&lt;/code&gt;, the test fails if 0 or 2+ requests satisfy this predicate.</source>
          <target state="translated">이전 &lt;code&gt;expectOne()&lt;/code&gt; 과 마찬가지로 0 개 또는 2 개 이상의 요청이이 술어를 충족하면 테스트가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="7ce201841a7ab6826908ab4e2e8a1bf231d9b18c" translate="yes" xml:space="preserve">
          <source>As with the previous &lt;code&gt;expectOne()&lt;/code&gt;, the test will fail if 0 or 2+ requests satisfy this predicate.</source>
          <target state="translated">이전 &lt;code&gt;expectOne()&lt;/code&gt; 과 마찬가지로 0 또는 2+ 요청이이 술어를 만족하면 테스트가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="78b22aea998f810381c17b06fb2333a37588a173" translate="yes" xml:space="preserve">
          <source>As you add and delete characters, you can see them appear and disappear from the data model. For example:</source>
          <target state="translated">문자를 추가 및 삭제하면 해당 문자가 데이터 모델에서 나타나고 사라지는 것을 볼 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="ec0a709258428a25296d9a2a6bba7576693ff220" translate="yes" xml:space="preserve">
          <source>As you can see here, the &lt;code&gt;parentItem&lt;/code&gt; in &lt;code&gt;AppComponent&lt;/code&gt; is a string, which the &lt;code&gt;ItemDetailComponent&lt;/code&gt; expects:</source>
          <target state="translated">당신이 여기에서 볼 수 있듯이, &lt;code&gt;parentItem&lt;/code&gt; 에서 &lt;code&gt;AppComponent&lt;/code&gt; 는 문자열입니다 &lt;code&gt;ItemDetailComponent&lt;/code&gt; 는 기대는 :</target>
        </trans-unit>
        <trans-unit id="b8ce8f85bb4b5482efa912931cf27e2ce382563a" translate="yes" xml:space="preserve">
          <source>As you can see, the &lt;code&gt;UniqueAlterEgoValidator&lt;/code&gt; class implements the &lt;code&gt;&lt;a href=&quot;../api/forms/asyncvalidator&quot;&gt;AsyncValidator&lt;/a&gt;&lt;/code&gt; interface. In the constructor, we inject the &lt;code&gt;HeroesService&lt;/code&gt; that has the following interface:</source>
          <target state="translated">보다시피 &lt;code&gt;UniqueAlterEgoValidator&lt;/code&gt; 클래스는 &lt;code&gt;&lt;a href=&quot;../api/forms/asyncvalidator&quot;&gt;AsyncValidator&lt;/a&gt;&lt;/code&gt; 인터페이스를 구현합니다 . 생성자 에서 다음 인터페이스가있는 &lt;code&gt;HeroesService&lt;/code&gt; 를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="f958b9634ee0ca82f703565029116255553f7d8f" translate="yes" xml:space="preserve">
          <source>As you can see, the response object has a &lt;code&gt;body&lt;/code&gt; property of the correct type.</source>
          <target state="translated">보시다시피 응답 객체에는 올바른 유형 의 &lt;code&gt;body&lt;/code&gt; 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="30b1da4a374a4b82201be5944135fd88e7c2eeb0" translate="yes" xml:space="preserve">
          <source>As you click the button, the displayed date alternates between &quot;&lt;strong&gt;&lt;samp&gt;04/15/1988&lt;/samp&gt;&lt;/strong&gt;&quot; and &quot;&lt;strong&gt;&lt;samp&gt;Friday, April 15, 1988&lt;/samp&gt;&lt;/strong&gt;&quot;.</source>
          <target state="translated">버튼을 클릭하면 표시된 날짜가 &quot;&lt;strong&gt;&lt;samp&gt;1988 년 4 월 15 일&lt;/samp&gt;&lt;/strong&gt;&quot;와&quot;&lt;strong&gt;&lt;samp&gt;1988 년 4 월 15 일 금요일&lt;/samp&gt;&lt;/strong&gt;&quot;.</target>
        </trans-unit>
        <trans-unit id="ab33e4cc94b129cb31d7c97d8407c2606a472c70" translate="yes" xml:space="preserve">
          <source>As you create new interceptors, add them to the &lt;code&gt;httpInterceptorProviders&lt;/code&gt; array and you won't have to revisit the &lt;code&gt;AppModule&lt;/code&gt;.</source>
          <target state="translated">새로운 인터셉터를 만들 때 &lt;code&gt;httpInterceptorProviders&lt;/code&gt; 배열에 추가 하면 &lt;code&gt;AppModule&lt;/code&gt; 을 다시 방문 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b35cd950e3abf3c41b9d1fee6bfbba54cf41fa95" translate="yes" xml:space="preserve">
          <source>As you may recall, &lt;code&gt;AdDirective&lt;/code&gt; injects &lt;code&gt;&lt;a href=&quot;../api/core/viewcontainerref&quot;&gt;ViewContainerRef&lt;/a&gt;&lt;/code&gt; into its constructor. This is how the directive accesses the element that you want to use to host the dynamic component.</source>
          <target state="translated">당신이 기억다시피, &lt;code&gt;AdDirective&lt;/code&gt; 는 주입 &lt;code&gt;&lt;a href=&quot;../api/core/viewcontainerref&quot;&gt;ViewContainerRef&lt;/a&gt;&lt;/code&gt; 를 생성자로. 이것이 지시문이 동적 구성 요소를 호스팅하는 데 사용하려는 요소에 액세스하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="66db9819ffe3ed53a6e4700b9705018402a68de2" translate="yes" xml:space="preserve">
          <source>As you might have guessed, you don't need to change anything in the way you bootstrap your existing AngularJS app. Unlike &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt;&amp;mdash;which requires some extra steps&amp;mdash; &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; is able to take care of bootstrapping the Angular module, as long as you provide the recipe.</source>
          <target state="translated">짐작할 수 있듯이 기존 AngularJS 앱을 부트 스트랩하는 방식으로 아무것도 변경할 필요가 없습니다. 추가 단계가 필요한 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 과 달리 &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; 은 레시피를 제공하는 한 Angular 모듈의 부트 스트랩을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="b0d2196193897c3d628ff542df1f728e1990a4fd" translate="yes" xml:space="preserve">
          <source>As you near the end of the development process, serving the contents of your output folder from a local web server can give you a better idea of how your application will behave when it is deployed to a remote server. You will need two terminals to get the live-reload experience.</source>
          <target state="translated">개발 프로세스가 끝날 무렵 로컬 웹 서버에서 출력 폴더의 내용을 제공하면 응용 프로그램이 원격 서버에 배포 될 때 어떻게 작동하는지 더 잘 알 수 있습니다. 실시간 재 장전 경험을 얻으려면 두 개의 터미널이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4e0151055d71dd61f258f216803c7ce77b59e409" translate="yes" xml:space="preserve">
          <source>As you work with this form, you will learn how to include validation logic, how to customize the presentation with standard CSS, and how to handle error conditions to ensure valid input. If the user deletes the hero name, for example, the form becomes invalid. The app detects the changed status, and displays a validation error in an attention-grabbing style. In addition, the &lt;strong&gt;Submit&lt;/strong&gt; button is disabled, and the &quot;required&quot; bar to the left of the input control changes from green to red.</source>
          <target state="translated">이 양식으로 작업하면서 유효성 검사 논리를 포함하는 방법, 표준 CSS로 프레젠테이션을 사용자 지정하는 방법, 유효한 입력을 보장하기 위해 오류 조건을 처리하는 방법을 배웁니다. 예를 들어 사용자가 영웅 이름을 삭제하면 양식이 유효하지 않게됩니다. 앱은 변경된 상태를 감지하고 주목을 끄는 스타일로 유효성 검사 오류를 표시합니다. 또한 &lt;strong&gt;제출&lt;/strong&gt; 버튼이 비활성화되고 입력 컨트롤 왼쪽에있는 &quot;필수&quot;막대가 녹색에서 빨간색으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="5cf5b93ed1e9a45e9ec8c8bf0566005ffc514ad0" translate="yes" xml:space="preserve">
          <source>As you'll be navigating to the &lt;em&gt;Admin Dashboard&lt;/em&gt; route after logging in, you'll update it to handle the query parameters and fragment.</source>
          <target state="translated">로그인 한 후 &lt;em&gt;관리 대시 보드&lt;/em&gt; 경로를 탐색 할 때 쿼리 매개 변수 및 조각을 처리하도록 경로를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="f0b43016a337094572c49d0ebcd7d6f06663336c" translate="yes" xml:space="preserve">
          <source>As you've learned, a component in an outlet persists until you navigate away to a new component. Secondary outlets are no different in this regard.</source>
          <target state="translated">학습 한대로 콘센트의 구성 요소는 새 구성 요소로 이동할 때까지 지속됩니다. 이차 콘센트는 이와 관련하여 다르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1b726055d199d23cbbaf0bbb7c90f5393684b71" translate="yes" xml:space="preserve">
          <source>As you've seen, multiple components can leverage the same service. Later in this tutorial, the shipping component will use the cart service to retrieve shipping data via HTTP from the &lt;code&gt;shipping.json&lt;/code&gt; file. Here you'll define the &lt;code&gt;get()&lt;/code&gt; method that will be used.</source>
          <target state="translated">앞에서 본 것처럼 여러 구성 요소가 동일한 서비스를 활용할 수 있습니다. 이 학습서의 뒷부분에서 운송 구성 요소는 장바구니 서비스를 사용하여 &lt;code&gt;shipping.json&lt;/code&gt; 파일 에서 HTTP를 통해 운송 데이터를 검색 합니다. 여기서는 사용할 &lt;code&gt;get()&lt;/code&gt; 메소드를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="c81caf6ffe3d326f41b1efc1332f0197102bbbe8" translate="yes" xml:space="preserve">
          <source>As you've worked through the milestones, the application has naturally gotten larger. As you continue to build out feature areas, the overall application size will continue to grow. At some point you'll reach a tipping point where the application takes a long time to load.</source>
          <target state="translated">이정표를 살펴본 결과 응용 프로그램이 자연스럽게 커졌습니다. 기능 영역을 계속 구축함에 따라 전체 응용 프로그램 크기가 계속 증가합니다. 어느 시점에서 애플리케이션을로드하는 데 시간이 오래 걸리는 팁 포인트에 도달 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fe40b33592723c9ffed418ea5b179b50d789586" translate="yes" xml:space="preserve">
          <source>As you've worked through the milestones, the application has naturally gotten larger. At some point you'll reach a point where the application takes a long time to load.</source>
          <target state="translated">이정표를 살펴보면서 응용 프로그램이 자연스럽게 커졌습니다. 어느 시점에서 응용 프로그램을로드하는 데 오랜 시간이 걸리는 지점에 도달하게됩니다.</target>
        </trans-unit>
        <trans-unit id="f3171c48f50cadb18be953d56f6aadf2c1470f7e" translate="yes" xml:space="preserve">
          <source>As your app grows, you can organize code relevant for a specific feature. This helps apply clear boundaries for features. With feature modules, you can keep code related to a specific functionality or feature separate from other code. Delineating areas of your app helps with collaboration between developers and teams, separating directives, and managing the size of the root module.</source>
          <target state="translated">앱이 성장함에 따라 특정 기능과 관련된 코드를 구성 할 수 있습니다. 이는 기능에 명확한 경계를 적용하는 데 도움이됩니다. 기능 모듈을 사용하면 특정 기능 또는 기능과 관련된 코드를 다른 코드와 별도로 유지할 수 있습니다. 앱 영역을 설명하면 개발자와 팀 간의 공동 작업, 지시문 분리 및 루트 모듈의 크기 관리에 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="2eed7ce85e255e9ab9ff2d8f035497961189f71e" translate="yes" xml:space="preserve">
          <source>As your application grows more complex, you may want to create routes that are relative to a component other than your root component. These types of nested routes are called child routes. This means you're adding a second &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; to your app, because it is in addition to the &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; in &lt;code&gt;AppComponent&lt;/code&gt;.</source>
          <target state="translated">애플리케이션이 더 복잡 해짐에 따라 루트 구성 요소가 아닌 다른 구성 요소와 관련된 경로를 만들 수 있습니다. 이러한 유형의 중첩 경로를 하위 경로라고합니다. 이는 &lt;code&gt;AppComponent&lt;/code&gt; 의 &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; &lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt; &amp;gt; 에 추가되기 때문에 두 번째 &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; 을 앱에 추가한다는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="ff3222db2ced161973e02584ac4049af0ec6632b" translate="yes" xml:space="preserve">
          <source>Asking the service worker to activate the latest version of the app for the current tab.</source>
          <target state="translated">서비스 담당자에게 현재 탭에 대한 최신 버전의 앱을 활성화하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="fbc52ac881315f0b01fcb3898c6bbefb4ca717ed" translate="yes" xml:space="preserve">
          <source>Asking the service worker to check the server for new updates.</source>
          <target state="translated">서비스 담당자에게 서버에 새 업데이트가 있는지 확인하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="5b45b5ea2e28d732a01d25a9ef132499d3d14bc3" translate="yes" xml:space="preserve">
          <source>Assert expectations on its public state.</source>
          <target state="translated">공개 상태에 대한 기대치를 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="269d80f2e6ae0d9c46cde478b4e5500f9c28b64f" translate="yes" xml:space="preserve">
          <source>Assert that the component &lt;code&gt;favoriteColor&lt;/code&gt; property value matches the value from the input.</source>
          <target state="translated">component &lt;code&gt;favoriteColor&lt;/code&gt; 속성 값이 입력 값과 일치 하는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="3add2d771e4f408357de38d3cf1e4671e71d6e99" translate="yes" xml:space="preserve">
          <source>Assert that the component's &lt;code&gt;favoriteColorControl&lt;/code&gt; value matches the value from the input.</source>
          <target state="translated">컴포넌트의 &lt;code&gt;favoriteColorControl&lt;/code&gt; 값이 입력 값과 일치 하는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="60d381f9c278556bf5f707455aa4e181db801691" translate="yes" xml:space="preserve">
          <source>Assert that the input value matches the value of the &lt;code&gt;favoriteColor&lt;/code&gt; property in the component instance.</source>
          <target state="translated">입력 값 이 구성 요소 인스턴스 의 &lt;code&gt;favoriteColor&lt;/code&gt; 속성 값과 일치하는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="2cac1bd12dceb2fce01f7d2c39980b6f3eb123f1" translate="yes" xml:space="preserve">
          <source>Assert that the new value set on the control matches the value in the input.</source>
          <target state="translated">컨트롤에 설정된 새 값이 입력 값과 일치하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="102dbd8a0d9de9bd9ed34eaa50b57bc20f17597a" translate="yes" xml:space="preserve">
          <source>Assert the correct type of the expression bound to the &lt;code&gt;&lt;a href=&quot;ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; input within the template.</source>
          <target state="translated">템플리트 내의 &lt;code&gt;&lt;a href=&quot;ngif&quot;&gt;ngIf&lt;/a&gt;&lt;/code&gt; 입력에 바인드 된 올바른 유형의 표현식을 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="34ae054cee78e0c6e83c3e3cd694a67e5d64d9d1" translate="yes" xml:space="preserve">
          <source>Asserts the correct type of the context for the template that &lt;code&gt;&lt;a href=&quot;ngforof&quot;&gt;NgForOf&lt;/a&gt;&lt;/code&gt; will render.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ngforof&quot;&gt;NgForOf&lt;/a&gt;&lt;/code&gt; 가 렌더링 할 템플릿에 대해 올바른 컨텍스트 유형을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="471940a95e6ccb6eae6400e44be1438188978b50" translate="yes" xml:space="preserve">
          <source>Asserts the correct type of the context for the template that &lt;code&gt;&lt;a href=&quot;ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; will render.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 가 렌더링 할 템플릿에 대한 올바른 유형의 컨텍스트를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="64db28c14c3f75eaf3fe6ba74774a54e6cbb89bd" translate="yes" xml:space="preserve">
          <source>Asset groups follow the Typescript interface shown here:</source>
          <target state="translated">자산 그룹은 여기에 표시된 Typescript 인터페이스를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="d6c9dfdc694085b6f0d02ea7e1e4fd3d4df7e99c" translate="yes" xml:space="preserve">
          <source>Assets configuration</source>
          <target state="translated">자산 구성</target>
        </trans-unit>
        <trans-unit id="e6a6bbc5e96926eeccb08d147396e13b4a2aa489" translate="yes" xml:space="preserve">
          <source>Assignments (&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;...&lt;/code&gt;)</source>
          <target state="translated">할당 ( &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; , &lt;code&gt;...&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7a1a70a899ae4731ff189ca13512ffc94c946adb" translate="yes" xml:space="preserve">
          <source>Assigns this bus to the given zone. Any callbacks attached to channels where runInZone was set to true on initialization will be executed in the given zone.</source>
          <target state="translated">이 버스를 주어진 구역에 할당합니다. 초기화시 runInZone이 true로 설정된 채널에 연결된 모든 콜백은 지정된 영역에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="d242cadc4aa1e98583aee808bc5bd94b0df50df6" translate="yes" xml:space="preserve">
          <source>Assigns this sink to the given zone. Any channels which are initialized with runInZone set to true will wait for the given zone to exit before sending messages.</source>
          <target state="translated">이 싱크를 지정된 영역에 할당합니다. runInZone을 true로 설정하여 초기화 된 채널은 메시지를 보내기 전에 지정된 영역이 종료 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="8f94f199baf1d5d8266597ec2112eb1be1c1fb69" translate="yes" xml:space="preserve">
          <source>Assigns this source to the given zone. Any channels which are initialized with runInZone set to true will emit events that will be executed within the given zone.</source>
          <target state="translated">이 소스를 지정된 영역에 할당합니다. runInZone을 true로 설정하여 초기화 된 채널은 지정된 영역 내에서 실행될 이벤트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="49fcc4238bbf2b339cfcfa762b3396453c32af91" translate="yes" xml:space="preserve">
          <source>Associate the &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; model and view.</source>
          <target state="translated">준회원 &lt;code&gt;&lt;a href=&quot;../api/forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 의 모델과 뷰를.</target>
        </trans-unit>
        <trans-unit id="274e2293c4a3f531e996553089413c2aeb58f8c2" translate="yes" xml:space="preserve">
          <source>Associates a named animation state with a set of CSS styles. See &lt;code&gt;&lt;a href=&quot;../common/upgrade/%24locationshim#state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">명명 된 애니메이션 상태를 CSS 스타일 세트와 연관시킵니다. &lt;code&gt;&lt;a href=&quot;../common/upgrade/%24locationshim#state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; 참조</target>
        </trans-unit>
        <trans-unit id="1c606a19977855e292dd7286f4f48996ac6f7432" translate="yes" xml:space="preserve">
          <source>Associates a named animation state with a set of CSS styles. See &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state&lt;/a&gt;()&lt;/code&gt;</source>
          <target state="translated">명명 된 애니메이션 상태를 CSS 스타일 집합과 연결합니다. &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state&lt;/a&gt;()&lt;/code&gt; 참조 ()</target>
        </trans-unit>
        <trans-unit id="4ae49ef1cd7752015463f129314f634187b62c7a" translate="yes" xml:space="preserve">
          <source>Associates an animation with an entry trigger that can be attached to an element. See &lt;code&gt;&lt;a href=&quot;trigger&quot;&gt;trigger&lt;/a&gt;()&lt;/code&gt;</source>
          <target state="translated">애니메이션을 요소에 첨부 할 수있는 입력 트리거와 연결합니다. &lt;code&gt;&lt;a href=&quot;trigger&quot;&gt;trigger&lt;/a&gt;()&lt;/code&gt; () 참조</target>
        </trans-unit>
        <trans-unit id="4784eaa8aeb7a762e1180e053368ca4e65b375b2" translate="yes" xml:space="preserve">
          <source>Assume the user is logged into the application at &lt;code&gt;example-bank.com&lt;/code&gt;. The user opens an email and clicks a link to &lt;code&gt;evil.com&lt;/code&gt;, which opens in a new tab.</source>
          <target state="translated">사용자가 &lt;code&gt;example-bank.com&lt;/code&gt; 에서 애플리케이션에 로그인했다고 가정하십시오 . 사용자가 이메일 을 열고 &lt;code&gt;evil.com&lt;/code&gt; 링크를 클릭 하면 새 탭에서 열립니다.</target>
        </trans-unit>
        <trans-unit id="e46bf719d36c903e3f4ff538c57fdd22e7050c74" translate="yes" xml:space="preserve">
          <source>Assume you have a library project &lt;code&gt;my-lib&lt;/code&gt; in your Angular workspace. To tell the library how to build the schematics, add a &lt;code&gt;tsconfig.schematics.json&lt;/code&gt; file next to the generated &lt;code&gt;tsconfig.lib.json&lt;/code&gt; file that configures the library build.</source>
          <target state="translated">Angular 작업 공간에 라이브러리 프로젝트 &lt;code&gt;my-lib&lt;/code&gt; 가 있다고 가정하십시오 . 방법, 설계도를 빌드 추가하는 라이브러리를 말할 &lt;code&gt;tsconfig.schematics.json&lt;/code&gt; 의 옆 생성에 파일을 &lt;code&gt;tsconfig.lib.json&lt;/code&gt; 의 파일를 구성하고 그 라이브러리 빌드.</target>
        </trans-unit>
        <trans-unit id="75818174243243561c9a25a5467849a1c2d2c022" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;dateObj&lt;/code&gt; is (year: 2010, month: 9, day: 3, hour: 12 PM, minute: 05, second: 08) in the &lt;em&gt;local&lt;/em&gt; time and locale is 'en-US':</source>
          <target state="translated">가정 &lt;code&gt;dateObj&lt;/code&gt; 가 됩니다 (년 : 2010, 월 : 9 일 : 3, 시간 : 12 PM, 분 : 05, 초 08)을에서 &lt;em&gt;현지&lt;/em&gt; 시간 로케일은 'EN-US'입니다 :</target>
        </trans-unit>
        <trans-unit id="5873ba4b7149a08e105140ef51ae2d0ffcc5d42b" translate="yes" xml:space="preserve">
          <source>Assuming that the CLI &lt;code&gt;ng serve&lt;/code&gt; command is still running, the browser should refresh and display both the application title and the hero name.</source>
          <target state="translated">CLI &lt;code&gt;ng serve&lt;/code&gt; 명령이 여전히 실행 중이라고 가정하면 브라우저는 애플리케이션 제목과 히어로 이름을 모두 새로 고쳐 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="94f5418a94f3eedc92108d6697fb720a530c5a6c" translate="yes" xml:space="preserve">
          <source>Assuming you already have an app that you created with the &lt;a href=&quot;cli&quot;&gt;Angular CLI&lt;/a&gt;, create a feature module using the CLI by entering the following command in the root project directory. Replace &lt;code&gt;CustomerDashboard&lt;/code&gt; with the name of your module. You can omit the &quot;Module&quot; suffix from the name because the CLI appends it:</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;Angular CLI로&lt;/a&gt; 작성한 앱이 이미 있다고 가정하면 루트 프로젝트 디렉토리에 다음 명령을 입력하여 CLI를 사용하여 기능 모듈을 작성하십시오. 교체 &lt;code&gt;CustomerDashboard&lt;/code&gt; 을 모듈의 이름으로. CLI가 추가하므로 이름에서 &quot;모듈&quot;접미 부를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b593995c88f61a609044a01e37e8e4ccc22e065" translate="yes" xml:space="preserve">
          <source>Assumptions</source>
          <target state="translated">Assumptions</target>
        </trans-unit>
        <trans-unit id="850c312e6795e144c4801560d1a8a36931550927" translate="yes" xml:space="preserve">
          <source>Async Validation</source>
          <target state="translated">비동기 검증</target>
        </trans-unit>
        <trans-unit id="3d8523026285ca381ac26c6046011d703dc76210" translate="yes" xml:space="preserve">
          <source>Async observable helpers</source>
          <target state="translated">비동기 관찰 가능한 도우미</target>
        </trans-unit>
        <trans-unit id="a2115adcf8a7abd68847a06a2ca483273231f7b5" translate="yes" xml:space="preserve">
          <source>Async observables</source>
          <target state="translated">비동기 관찰 가능</target>
        </trans-unit>
        <trans-unit id="66faa9aa7a8da44bac968eb4f9651b0395d1e769" translate="yes" xml:space="preserve">
          <source>Async pipe</source>
          <target state="translated">비동기 파이프</target>
        </trans-unit>
        <trans-unit id="465bdb8533ebb255eef127b77064a4450ccdad5a" translate="yes" xml:space="preserve">
          <source>Async test with &lt;em&gt;async()&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;async ()를&lt;/em&gt; 사용한 &lt;em&gt;비동기&lt;/em&gt; 테스트&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d3dfebbe72d4e3d6b50b5f6205bf253eb9e510d1" translate="yes" xml:space="preserve">
          <source>Async test with &lt;em&gt;fakeAsync()&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fakeAsync ()&lt;/em&gt; 를 &lt;em&gt;사용한&lt;/em&gt; 비동기 테스트&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="60055bf8c9508ed73c9e2d6fc18babce7a1caa3d" translate="yes" xml:space="preserve">
          <source>Async test with &lt;em&gt;waitForAsync()&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;waitForAsync ()&lt;/em&gt; 를 &lt;em&gt;사용한&lt;/em&gt; 비동기 테스트&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a3a2a031d9a78f06359a7d5ceed4a4220e47722c" translate="yes" xml:space="preserve">
          <source>Async validator function composed of all the async validators registered with this directive.</source>
          <target state="translated">이 지시어에 등록 된 모든 비동기 유효성 검사기로 구성된 비동기 유효성 검사기 기능.</target>
        </trans-unit>
        <trans-unit id="08889716a00afbaa4f75748cfc88dc19b867511d" translate="yes" xml:space="preserve">
          <source>AsyncPipe</source>
          <target state="translated">AsyncPipe</target>
        </trans-unit>
        <trans-unit id="d3db89bff8169aadf0002b749871c33ae8202bab" translate="yes" xml:space="preserve">
          <source>AsyncValidator</source>
          <target state="translated">AsyncValidator</target>
        </trans-unit>
        <trans-unit id="ffde100172e9b0262a458c11ee4575fc6b847d60" translate="yes" xml:space="preserve">
          <source>AsyncValidatorFn</source>
          <target state="translated">AsyncValidatorFn</target>
        </trans-unit>
        <trans-unit id="3d7fac7964f752248f02c5aa61c85fd417dcfbcf" translate="yes" xml:space="preserve">
          <source>Asynchronous</source>
          <target state="translated">Asynchronous</target>
        </trans-unit>
        <trans-unit id="37a310b45a04c0a244854134bbf202646220195b" translate="yes" xml:space="preserve">
          <source>Asynchronous validation happens after the synchronous validation, and is performed only if the synchronous validation is successful. This check allows forms to avoid potentially expensive async validation processes (such as an HTTP request) if the more basic validation methods have already found invalid input.</source>
          <target state="translated">비동기 유효성 검사는 동기 유효성 검사 후에 발생하며 동기 유효성 검사가 성공한 경우에만 수행됩니다. 이 검사를 통해 양식은 더 기본적인 유효성 검사 방법이 이미 잘못된 입력을 찾은 경우 잠재적으로 비용이 많이 드는 비동기 유효성 검사 프로세스 (예 : HTTP 요청)를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="998ed05f053e1853c01b49907d986bbc10b73e44" translate="yes" xml:space="preserve">
          <source>Asynchronous validator function composed of all the asynchronous validators registered with this directive.</source>
          <target state="translated">이 지시문에 등록 된 모든 비동기 유효성 검사기로 구성된 비동기 유효성 검사 기능입니다.</target>
        </trans-unit>
        <trans-unit id="575694c2cb16e00e61ffa3cd7d69fb6ab26b8495" translate="yes" xml:space="preserve">
          <source>Asynchronous validators implement the &lt;code&gt;&lt;a href=&quot;../api/forms/asyncvalidatorfn&quot;&gt;AsyncValidatorFn&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/forms/asyncvalidator&quot;&gt;AsyncValidator&lt;/a&gt;&lt;/code&gt; interfaces. These are very similar to their synchronous counterparts, with the following differences.</source>
          <target state="translated">비동기 유효성 검사기는 &lt;code&gt;&lt;a href=&quot;../api/forms/asyncvalidatorfn&quot;&gt;AsyncValidatorFn&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/forms/asyncvalidator&quot;&gt;AsyncValidator&lt;/a&gt;&lt;/code&gt; 인터페이스를 구현합니다 . 이것들은 동기식 대응 물과 매우 유사하지만 다음과 같은 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3eeded95df5b44a415fcb5e4ef49bdffbb7e6a1" translate="yes" xml:space="preserve">
          <source>At a high level, NgModules are a way to organize Angular apps and they accomplish this through the metadata in the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; decorator. The metadata falls into three categories:</source>
          <target state="translated">NgModules는 높은 수준에서 Angular 앱을 구성하는 방법이며 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 데코레이터 의 메타 데이터를 통해이를 수행합니다 . 메타 데이터는 세 가지 범주로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="242134a4310d9dba08222aef54e2257cacc08268" translate="yes" xml:space="preserve">
          <source>At its simplest, a service worker is a script that runs in the web browser and manages caching for an application.</source>
          <target state="translated">가장 간단하게 서비스 워커는 웹 브라우저에서 실행되고 응용 프로그램의 캐싱을 관리하는 스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="8e510f3f50eecae75e2f194727aa6e0658b6fbe6" translate="yes" xml:space="preserve">
          <source>At its simplest, a service worker is a script that runs in the web browser and manages caching for an application. Service workers function as a network proxy. They intercept all outgoing HTTP requests made by the application and can choose how to respond to them.</source>
          <target state="translated">가장 간단하게 서비스 워커는 웹 브라우저에서 실행되고 응용 프로그램의 캐싱을 관리하는 스크립트입니다. 서비스 워커는 네트워크 프록시로 작동합니다. 그들은 응용 프로그램에서 보낸 모든 나가는 HTTP 요청을 가로 채고 응답 방법을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02c3f16fdd9df9a64633ff91d643eaf302e53ae5" translate="yes" xml:space="preserve">
          <source>At runtime, the input will be set to the empty string, which is not a &lt;code&gt;boolean&lt;/code&gt; value. Angular component libraries that deal with this problem often &quot;coerce&quot; the value into the right type in the setter:</source>
          <target state="translated">런타임에 입력은 &lt;code&gt;boolean&lt;/code&gt; 값 이 아닌 빈 문자열로 설정됩니다 . 이 문제를 처리하는 Angular 구성 요소 라이브러리는 종종 setter에서 값을 올바른 유형으로 &quot;강제&quot;합니다.</target>
        </trans-unit>
        <trans-unit id="f2fb1d2b6dd484c68fa3057e82590ac4a166dcd3" translate="yes" xml:space="preserve">
          <source>At some later point, the app requests the lazy bundle, &lt;code&gt;lazy-chunk.&amp;lt;lazy-hash-1&amp;gt;.js&lt;/code&gt;.</source>
          <target state="translated">나중에 앱은 lazy 번들 &lt;code&gt;lazy-chunk.&amp;lt;lazy-hash-1&amp;gt;.js&lt;/code&gt; 를 요청 합니다.</target>
        </trans-unit>
        <trans-unit id="cae1b7e929dfc6e1600a1a1671f28d169e95e10a" translate="yes" xml:space="preserve">
          <source>At the bottom of the template, add an HTML form to capture user information.</source>
          <target state="translated">템플릿 하단에 사용자 정보를 캡처하는 HTML 양식을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0a86dc5ece1ac9e833952415de9250d745d527c3" translate="yes" xml:space="preserve">
          <source>At the bottom of the template, add an empty HTML form to capture user information.</source>
          <target state="translated">템플릿 맨 아래에 빈 HTML 양식을 추가하여 사용자 정보를 캡처하십시오.</target>
        </trans-unit>
        <trans-unit id="0a72f978f7bf5ae9b84f741e034c4300f3de1323" translate="yes" xml:space="preserve">
          <source>At the end of &lt;a href=&quot;https://angular.io/start/start&quot;&gt;Your First App&lt;/a&gt;, the online store application has a basic product catalog. The app doesn't have any variable states or navigation. There is one URL, and that URL always displays the &quot;My Store&quot; page with a list of products and their descriptions.</source>
          <target state="translated">&lt;a href=&quot;https://angular.io/start/start&quot;&gt;첫 번째 앱&lt;/a&gt; 끝 에서 온라인 상점 애플리케이션에는 기본 제품 카탈로그가 있습니다. 앱에 변수 상태 나 탐색 기능이 없습니다. 하나의 URL이 있으며 해당 URL은 항상 &quot;내 상점&quot;페이지에 제품 목록과 설명이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="51ce5900aad4e680b18674d74b2c9f48486d18e2" translate="yes" xml:space="preserve">
          <source>At the end of &lt;a href=&quot;https://angular.io/start/start&quot;&gt;part 1&lt;/a&gt;, the online store application has a basic product catalog. The app doesn't have any variable states or navigation. There is one URL, and that URL always displays the &quot;My Store&quot; page with a list of products and their descriptions.</source>
          <target state="translated">&lt;a href=&quot;https://angular.io/start/start&quot;&gt;1 부&lt;/a&gt; 말미 에는 온라인 상점 애플리케이션에 기본 제품 카탈로그가 있습니다. 앱에는 변수 상태 나 탐색이 없습니다. 하나의 URL이 있으며 해당 URL은 항상 제품 및 설명 목록과 함께 &quot;내 상점&quot;페이지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="f3a019d3473bd7c74189945ba7fdf2d2de78293b" translate="yes" xml:space="preserve">
          <source>At the end of &lt;a href=&quot;https://angular.io/start/start/data&quot;&gt;Managing Data&lt;/a&gt;, the online store application has a product catalog and a shopping cart.</source>
          <target state="translated">&lt;a href=&quot;https://angular.io/start/start/data&quot;&gt;데이터 관리&lt;/a&gt; 가 끝나면 온라인 상점 애플리케이션에는 제품 카탈로그와 장바구니가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d55658fc25831b063983ee22a2f5946a2c03370f" translate="yes" xml:space="preserve">
          <source>At the end of &lt;a href=&quot;https://angular.io/start/start/routing&quot;&gt;Routing&lt;/a&gt;, the online store application has a product catalog with two views: a product list and product details. Users can click on a product name from the list to see details in a new view, with a distinct URL (route).</source>
          <target state="translated">&lt;a href=&quot;https://angular.io/start/start/routing&quot;&gt;라우팅&lt;/a&gt; 종료시 온라인 상점 애플리케이션에는 두 가지보기 (제품 목록 및 제품 세부 사항)가있는 제품 카탈로그가 있습니다. 사용자는 목록에서 제품 이름을 클릭하여 고유 한 URL (경로)과 함께 새보기에서 세부 사항을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fd575c0566b76e5d3207e1cb47b414cc567e6ea" translate="yes" xml:space="preserve">
          <source>At the end of &lt;a href=&quot;https://angular.io/start/start/start-data&quot;&gt;Managing Data&lt;/a&gt;, the online store application has a product catalog and a shopping cart.</source>
          <target state="translated">&lt;a href=&quot;https://angular.io/start/start/start-data&quot;&gt;데이터 관리&lt;/a&gt; 가 끝나면 온라인 상점 애플리케이션에 제품 카탈로그와 장바구니가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddf3ff007dbc67f83d50f7b5e29d38404d81b3c3" translate="yes" xml:space="preserve">
          <source>At the end of &lt;a href=&quot;https://angular.io/start/start/start-routing&quot;&gt;In-app Navigation&lt;/a&gt;, the online store application has a product catalog with two views: a product list and product details. Users can click on a product name from the list to see details in a new view, with a distinct URL, or route.</source>
          <target state="translated">&lt;a href=&quot;https://angular.io/start/start/start-routing&quot;&gt;인앱 탐색&lt;/a&gt; 이 끝나면 온라인 스토어 애플리케이션에 제품 목록과 제품 세부 정보의 두 가지보기가있는 제품 카탈로그가 있습니다. 사용자는 목록에서 제품 이름을 클릭하여 고유 한 URL 또는 경로가있는 새보기에서 세부 정보를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa2383077a65ab0c0336fa3575224c0a072cec68" translate="yes" xml:space="preserve">
          <source>At the end of the hero detail template, add a save button with a &lt;code&gt;click&lt;/code&gt; event binding that invokes a new component method named &lt;code&gt;save()&lt;/code&gt;.</source>
          <target state="translated">hero detail 템플리트의 끝에 &lt;code&gt;save()&lt;/code&gt; 라는 새 컴포넌트 메소드를 호출하는 &lt;code&gt;click&lt;/code&gt; 이벤트 바인딩이 있는 저장 단추를 추가 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a77379b17f9d43f8aa4ce2a08643a4ee08cf070" translate="yes" xml:space="preserve">
          <source>At the end, tests can verify that the app has made no unexpected requests.</source>
          <target state="translated">마지막으로 테스트를 통해 앱이 예상치 못한 요청을하지 않았는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04e2e3448d97cf88b4c8cf92be8647a5d5df0f65" translate="yes" xml:space="preserve">
          <source>At the end, tests may verify that the app has made no unexpected requests.</source>
          <target state="translated">결국 테스트에서 앱이 예기치 않은 요청을하지 않았는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cb6df513db3bf3228849da6550d8a1fbd416ea9" translate="yes" xml:space="preserve">
          <source>At the moment you're interested in seeing how guards work so the first version does nothing useful. It simply logs to console and &lt;code&gt;returns&lt;/code&gt; true immediately, allowing navigation to proceed:</source>
          <target state="translated">현재 당신은 경비원의 작동 방식에 관심이있어 첫 번째 버전은 아무 효과가 없습니다. 단순히 콘솔에 로그인하고 즉시 true를 &lt;code&gt;returns&lt;/code&gt; 하여 탐색을 진행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ab7474646e972990366803a61deec9eef2838ea" translate="yes" xml:space="preserve">
          <source>At the moment, &lt;em&gt;any&lt;/em&gt; user can navigate &lt;em&gt;anywhere&lt;/em&gt; in the application &lt;em&gt;anytime&lt;/em&gt;. That's not always the right thing to do.</source>
          <target state="translated">지금이 순간, &lt;em&gt;어떤&lt;/em&gt; 사용자는 탐색 할 수 있습니다 &lt;em&gt;어디에서나&lt;/em&gt; 응용 프로그램에 &lt;em&gt;언제든지&lt;/em&gt; . 항상 옳은 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0298961e0cfbc7c30a7134ed224539d2fc943e7c" translate="yes" xml:space="preserve">
          <source>At the moment, any user can navigate anywhere in the application anytime, but sometimes you need to control access to different parts of your app for various reasons. Some of which may include the following:</source>
          <target state="translated">현재 모든 사용자는 애플리케이션의 어디에서나 언제든지 탐색 할 수 있지만 때로는 다양한 이유로 앱의 다른 부분에 대한 액세스를 제어해야합니다. 그중 일부에는 다음이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a90472fb52fd14133af6b5ed45a846d07c7f8d7" translate="yes" xml:space="preserve">
          <source>At the moment, the &lt;code&gt;CrisisDetailComponent&lt;/code&gt; retrieves the selected crisis. If the crisis is not found, it navigates back to the crisis list view.</source>
          <target state="translated">현재 &lt;code&gt;CrisisDetailComponent&lt;/code&gt; 는 선택된 위기를 검색합니다. 위기가 발견되지 않으면 위기 목록보기로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="43e554d2ee4258d9a49f0d60c344262753f16233" translate="yes" xml:space="preserve">
          <source>At the moment, the &lt;code&gt;CrisisDetailComponent&lt;/code&gt; retrieves the selected crisis. If the crisis is not found, the router navigates back to the crisis list view.</source>
          <target state="translated">현재 &lt;code&gt;CrisisDetailComponent&lt;/code&gt; 는 선택한 위기를 검색합니다. 위기가 발견되지 않으면 라우터는 위기 목록보기로 다시 이동합니다.</target>
        </trans-unit>
        <trans-unit id="060de0fabf75a3678ad4f86fea6ae7d325cd7a4c" translate="yes" xml:space="preserve">
          <source>At the moment, the &lt;code&gt;HeroesComponent&lt;/code&gt; displays both the list of heroes and the selected hero's details.</source>
          <target state="translated">현재 &lt;code&gt;HeroesComponent&lt;/code&gt; 는 영웅 목록과 선택한 영웅의 세부 정보를 모두 표시합니다.</target>
        </trans-unit>
        <trans-unit id="82fe33a58877ad32663a5e6978a18d91edefa44b" translate="yes" xml:space="preserve">
          <source>At the moment, the binding is to an array of strings. In real applications, most bindings are to more specialized objects.</source>
          <target state="translated">현재 바인딩은 문자열 배열에 대한 것입니다. 실제 응용 프로그램에서 대부분의 바인딩은보다 특수화 된 개체에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="bbc8860a6469db18738b3c14f8fcb5e7a919ea3c" translate="yes" xml:space="preserve">
          <source>At the moment, the default color&amp;mdash;the color that prevails until the user picks a highlight color&amp;mdash;is hard-coded as &quot;red&quot;. Let the template developer set the default color.</source>
          <target state="translated">현재 기본 색상 (사용자가 강조 색상을 선택할 때까지 통용되는 색상)은 &quot;빨간색&quot;으로 하드 코딩되어 있습니다. 템플릿 개발자가 기본 색상을 설정하도록합니다.</target>
        </trans-unit>
        <trans-unit id="3b5f7eb081d98212ad7a07dd8a9a528a0bc15a1a" translate="yes" xml:space="preserve">
          <source>At the root level of the &lt;code&gt;schematics/&lt;/code&gt; folder, create a &lt;code&gt;collection.json&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;schematics/&lt;/code&gt; 폴더 의 루트 레벨 에서 &lt;code&gt;collection.json&lt;/code&gt; 파일을 작성 하십시오.</target>
        </trans-unit>
        <trans-unit id="6dde421309dba3de54f0b4271bbd276260c091cc" translate="yes" xml:space="preserve">
          <source>At the top are the import statements. The next section is where you configure the &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; by stating what components and directives belong to it (&lt;code&gt;declarations&lt;/code&gt;) as well as which other modules it uses (&lt;code&gt;imports&lt;/code&gt;). For more information on the structure of an &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt;, be sure to read &lt;a href=&quot;bootstrapping&quot;&gt;Bootstrapping&lt;/a&gt;.</source>
          <target state="translated">맨 위에는 수입 명세서가 있습니다. 다음 섹션에서는 어떤 컴포넌트와 지시어가 어떤 컴포넌트와 &lt;code&gt;declarations&lt;/code&gt; 에 포함되는지 ( 선언 )뿐만 아니라 어떤 다른 모듈이 사용하는지 ( &lt;code&gt;imports&lt;/code&gt; ) 지정 하여 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 을 구성합니다 . 의 구조에 대한 자세한 내용은 &lt;code&gt;@&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt; , 읽으십시오 &lt;a href=&quot;bootstrapping&quot;&gt;부트 스트랩을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="883786d3cc76dbd1ed79ce5408eeff3078f7cc41" translate="yes" xml:space="preserve">
          <source>At the top level of &lt;code&gt;angular.json&lt;/code&gt;, a few properties configure the workspace, and a &lt;code&gt;projects&lt;/code&gt; section contains the remaining per-project configuration options. CLI defaults set at the workspace level can be overridden by defaults set at the project level, and defaults set at the project level can be overridden on the command line.</source>
          <target state="translated">&lt;code&gt;angular.json&lt;/code&gt; 의 최상위 레벨 에서 몇 가지 특성이 작업 공간을 구성하고 &lt;code&gt;projects&lt;/code&gt; 섹션에는 나머지 프로젝트 별 구성 옵션이 포함됩니다. 작업 공간 레벨에서 설정된 CLI 기본값은 프로젝트 레벨에서 설정된 기본값으로 대체 될 수 있으며 프로젝트 레벨에서 설정된 기본값은 명령 행에서 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0434ec7f407a6a347e8b9b391b94f54a3a508b6b" translate="yes" xml:space="preserve">
          <source>At the top level, paths that begin with &lt;code&gt;/&lt;/code&gt; refer to the root of the application. But child routes &lt;em&gt;extend&lt;/em&gt; the path of the parent route. With each step down the route tree, you add a slash followed by the route path, unless the path is &lt;em&gt;empty&lt;/em&gt;.</source>
          <target state="translated">최상위 레벨에서 &lt;code&gt;/&lt;/code&gt; 로 시작하는 경로 는 응용 프로그램의 루트를 나타냅니다. 그러나 하위 경로는 상위 경로의 경로를 &lt;em&gt;확장&lt;/em&gt; 합니다. 경로 트리가 아래로 내려갈 때마다 경로가 &lt;em&gt;비어&lt;/em&gt; 있지 않으면 슬래시 다음에 경로 경로가 추가 됩니다.</target>
        </trans-unit>
        <trans-unit id="0ca36d7923bc24c8310134d3ad6ad7fd24b95c13" translate="yes" xml:space="preserve">
          <source>At the top level, paths that begin with &lt;code&gt;/&lt;/code&gt; refer to the root of the application. But child routes extend the path of the parent route. With each step down the route tree, you add a slash followed by the route path, unless the path is empty.</source>
          <target state="translated">최상위 수준에서 &lt;code&gt;/&lt;/code&gt; 로 시작하는 경로 는 응용 프로그램의 루트를 참조합니다. 그러나 자식 경로는 부모 경로의 경로를 확장합니다. 경로 트리 아래의 각 단계에서 경로가 비어 있지 않는 한 슬래시 뒤에 경로 경로를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="79f1f417baccaeeb34023ad1f4a392c36910fe7d" translate="yes" xml:space="preserve">
          <source>At the top of the file, add the following import statement.</source>
          <target state="translated">파일 맨 위에 다음 import 문을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="a3945a27c64e5bd8255624f2566551f7cf697583" translate="yes" xml:space="preserve">
          <source>At this point, Visual Studio is ready. It&amp;rsquo;s a good idea to close Visual Studio and restart it to make sure everything is clean.</source>
          <target state="translated">이제 Visual Studio가 준비되었습니다. Visual Studio를 닫고 다시 시작하여 모든 것이 깨끗해 지도록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="57bf3ff8bf6006519207c4fc0ce314056ecd80b1" translate="yes" xml:space="preserve">
          <source>At this point, all application routes are in place.</source>
          <target state="translated">이 시점에서 모든 응용 프로그램 경로가 제자리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="d94328cb8894f9ca14552461df3b4d75737edab8" translate="yes" xml:space="preserve">
          <source>At this point, users can put items in the cart by clicking &quot;Buy&quot;, but they can't yet see their cart.</source>
          <target state="translated">이 시점에서 사용자는 &quot;구매&quot;를 클릭하여 장바구니에 품목을 넣을 수 있지만 아직 장바구니를 볼 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="8bd123a0eac56e2896e3fe55bff44567829141a2" translate="yes" xml:space="preserve">
          <source>At this point, you can switch the two components to use the new service instead of the old one. While you &lt;code&gt;$inject&lt;/code&gt; it as the downgraded &lt;code&gt;phone&lt;/code&gt; factory, it's really an instance of the &lt;code&gt;Phone&lt;/code&gt; class and you annotate its type accordingly:</source>
          <target state="translated">이 시점에서 이전 구성 요소 대신 새 서비스를 사용하도록 두 구성 요소를 전환 할 수 있습니다. 다운 그레이드 된 &lt;code&gt;phone&lt;/code&gt; 팩토리 로 &lt;code&gt;$inject&lt;/code&gt; 하는 동안 실제로 &lt;code&gt;Phone&lt;/code&gt; 클래스 의 인스턴스이며 그에 따라 유형에 주석을 달 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57733aea6c15b3f06327309b16c1e0c4da909346" translate="yes" xml:space="preserve">
          <source>At this point, you have a basic application that uses Angular's routing feature to change what components the user can see based on the URL address. You have extended these features to include a redirect, as well as a wildcard route to display a custom 404 page.</source>
          <target state="translated">이 시점에서 Angular의 라우팅 기능을 사용하여 URL 주소를 기반으로 사용자가 볼 수있는 구성 요소를 변경하는 기본 응용 프로그램이 있습니다. 사용자 지정 404 페이지를 표시하는 와일드 카드 경로뿐만 아니라 리디렉션을 포함하도록 이러한 기능을 확장했습니다.</target>
        </trans-unit>
        <trans-unit id="8ec1691c150b8de77b5a17dca474a04f2c0bb6ff" translate="yes" xml:space="preserve">
          <source>At this point, you have defined two routes for your application. However, your application still has both the &lt;code&gt;crisis-list&lt;/code&gt; and &lt;code&gt;heroes-list&lt;/code&gt; components hard-coded in your &lt;code&gt;app.component.html&lt;/code&gt; template. For your routes to work, you need to update your template to dynamically load a component based on the URL path.</source>
          <target state="translated">이 시점에서 애플리케이션에 대해 두 가지 경로를 정의했습니다. 그러나 애플리케이션에는 여전히 &lt;code&gt;app.component.html&lt;/code&gt; 템플릿 에 하드 코딩 된 &lt;code&gt;crisis-list&lt;/code&gt; 및 &lt;code&gt;heroes-list&lt;/code&gt; 구성 요소 가 모두 있습니다. 경로가 작동하려면 URL 경로를 기반으로 구성 요소를 동적으로로드하도록 템플릿을 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="86a28f831b9d378b2f9f53fe3f306868566a3b98" translate="yes" xml:space="preserve">
          <source>At this point, you've replaced all AngularJS application components with their Angular counterparts, even though you're still serving them from the AngularJS router.</source>
          <target state="translated">이 시점에서 여전히 AngularJS 라우터에서 제공하는 경우에도 모든 AngularJS 응용 프로그램 구성 요소를 해당 Angular로 대체했습니다.</target>
        </trans-unit>
        <trans-unit id="881d0e72fd3eb18bc7f9bce749c2a557083835f3" translate="yes" xml:space="preserve">
          <source>Attaches a view so that it will be dirty checked. The view will be automatically detached when it is destroyed. This will throw if the view is already attached to a ViewContainer.</source>
          <target state="translated">더러워 지도록 뷰를 첨부합니다. 뷰가 파괴되면 뷰가 자동으로 분리됩니다. 뷰가 이미 ViewContainer에 연결된 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a086d942884a301b827479029ba19c2746237425" translate="yes" xml:space="preserve">
          <source>Attribute</source>
          <target state="translated">Attribute</target>
        </trans-unit>
        <trans-unit id="b2a054d9997fa913c6ff1d1261a85f354b37c1d2" translate="yes" xml:space="preserve">
          <source>Attribute (the exception)</source>
          <target state="translated">속성 (예외)</target>
        </trans-unit>
        <trans-unit id="7706e49eec94755bbb4164b09d500329ccb21352" translate="yes" xml:space="preserve">
          <source>Attribute Directive Testing</source>
          <target state="translated">속성 지시문 테스트</target>
        </trans-unit>
        <trans-unit id="55c1659b17ee19bef5fd528a73b2941e917a57a8" translate="yes" xml:space="preserve">
          <source>Attribute Directives</source>
          <target state="translated">속성 지시문</target>
        </trans-unit>
        <trans-unit id="c334bb508016d6901c14a951eec64345dab38157" translate="yes" xml:space="preserve">
          <source>Attribute binding</source>
          <target state="translated">속성 바인딩</target>
        </trans-unit>
        <trans-unit id="688c7d0ab88d8b7d6e839cac9ec8e4a8393f65d2" translate="yes" xml:space="preserve">
          <source>Attribute binding in Angular helps you set values for attributes directly. With attribute binding, you can improve accessibility, style your application dynamically, and manage multiple CSS classes or styles simultaneously.</source>
          <target state="translated">Angular의 속성 바인딩을 사용하면 속성 값을 직접 설정할 수 있습니다. 속성 바인딩을 사용하면 접근성을 높이고 애플리케이션의 스타일을 동적으로 지정하고 여러 CSS 클래스 또는 스타일을 동시에 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="29ab6806b510c7b11c4ab616151d71b7f958362f" translate="yes" xml:space="preserve">
          <source>Attribute binding syntax resembles &lt;a href=&quot;property-binding&quot;&gt;property binding&lt;/a&gt;, but instead of an element property between brackets, you precede the name of the attribute with the prefix &lt;code&gt;attr&lt;/code&gt;, followed by a dot. Then, you set the attribute value with an expression that resolves to a string.</source>
          <target state="translated">속성 바인딩 구문은 &lt;a href=&quot;property-binding&quot;&gt;속성 바인딩&lt;/a&gt; 과 비슷 하지만 대괄호 사이의 요소 속성 대신 속성 이름 앞에 &lt;code&gt;attr&lt;/code&gt; 접두사를 붙인 다음 점이옵니다. 그런 다음 문자열로 해석되는 표현식으로 속성 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d9b950dd914b91e0fb66d15ece878e4a67694934" translate="yes" xml:space="preserve">
          <source>Attribute binding syntax resembles property binding, but instead of an element property between brackets, start with the prefix &lt;code&gt;attr&lt;/code&gt;, followed by a dot (&lt;code&gt;.&lt;/code&gt;), and the name of the attribute. You then set the attribute value, using an expression that resolves to a string, or remove the attribute when the expression resolves to &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">속성 바인딩 구문은 속성 바인딩과 비슷하지만 대괄호 사이의 요소 속성 대신 접두사 &lt;code&gt;attr&lt;/code&gt; 로 시작하고 그 뒤에 점 ( &lt;code&gt;.&lt;/code&gt; ) 및 속성 이름이옵니다. 그런 다음 문자열로 해석되는 표현식을 사용하여 속성 값을 설정하거나 표현식이 &lt;code&gt;null&lt;/code&gt; 로 해석 될 때 속성을 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="279ab89039ba64c6b0da183f3b7147bf2cea8ccf" translate="yes" xml:space="preserve">
          <source>Attribute directives</source>
          <target state="translated">속성 지시문</target>
        </trans-unit>
        <trans-unit id="5d12ef2a9da048d322efb7149e52d65f30b28dfa" translate="yes" xml:space="preserve">
          <source>Attribute directives listen to and modify the behavior of other HTML elements, attributes, properties, and components. You usually apply them to elements as if they were HTML attributes, hence the name.</source>
          <target state="translated">속성 지시문은 다른 HTML 요소, 속성, 속성 및 구성 요소의 동작을 듣고 수정합니다. 일반적으로 요소를 HTML 속성 인 것처럼 요소에 적용하므로 이름이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="20513020a514d725b1470eb9d9c5e82080471bcc" translate="yes" xml:space="preserve">
          <source>Attribute directives&amp;mdash;change the appearance or behavior of an element, component, or another directive.</source>
          <target state="translated">속성 지시문 &amp;mdash; 요소, 구성 요소 또는 다른 지시문의 모양이나 동작을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="8ea298a1d48c262be17e654c22323e471414de8a" translate="yes" xml:space="preserve">
          <source>Attribute, class, and style bindings</source>
          <target state="translated">속성, 클래스 및 스타일 바인딩</target>
        </trans-unit>
        <trans-unit id="1b88cfba520774bf5bca05743d6b49bf17294180" translate="yes" xml:space="preserve">
          <source>Attribute: &lt;code&gt;&amp;lt;comp name=&quot;World&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">속성 : &lt;code&gt;&amp;lt;comp name=&quot;World&quot;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba9f41e65786ab28a5cc7739fa9524275b749e4a" translate="yes" xml:space="preserve">
          <source>Auditing Angular applications</source>
          <target state="translated">Angular 애플리케이션 감사</target>
        </trans-unit>
        <trans-unit id="2d71759f1ce5e34ba7c6cb30dce5f95b0d00e1df" translate="yes" xml:space="preserve">
          <source>Aug 06, 2020</source>
          <target state="translated">2020 년 08 월 06 일</target>
        </trans-unit>
        <trans-unit id="6fea604e02e90409b49b69fe833ca2813b27ee65" translate="yes" xml:space="preserve">
          <source>Aug 06, 2021</source>
          <target state="translated">2021 년 8 월 6 일</target>
        </trans-unit>
        <trans-unit id="ddf0bb467a9afb82ce8505717567f73467a792d6" translate="yes" xml:space="preserve">
          <source>Augmenting native elements</source>
          <target state="translated">기본 요소 보강</target>
        </trans-unit>
        <trans-unit id="a16633a9eb6827787eb85e86d22dfda752672360" translate="yes" xml:space="preserve">
          <source>Authenticate with &lt;code&gt;AuthGuard&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;AuthGuard&lt;/code&gt; 로 인증</target>
        </trans-unit>
        <trans-unit id="66e15602646e8c5a159e78f8d9953cf08b4cdadb" translate="yes" xml:space="preserve">
          <source>Authentication/authorization</source>
          <target state="translated">Authentication/authorization</target>
        </trans-unit>
        <trans-unit id="0efd1e55177485c760611f1570d33e1b5e47d03a" translate="yes" xml:space="preserve">
          <source>Authoring Schematics</source>
          <target state="translated">제작 회로도</target>
        </trans-unit>
        <trans-unit id="fe7fe41ba1e2091f0bf1b06a8e056db0a0210d00" translate="yes" xml:space="preserve">
          <source>Authoring schematics</source>
          <target state="translated">회로도 작성</target>
        </trans-unit>
        <trans-unit id="92b94f5df6479e29b25d986076b0ee811c9a3f18" translate="yes" xml:space="preserve">
          <source>Auto-styling can be used to define a state that depends on layout or other environmental factors.</source>
          <target state="translated">자동 스타일을 사용하여 레이아웃 또는 기타 환경 요인에 따라 상태를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4696360f61ce7b39a54fa976acbcf3c37e4dd61" translate="yes" xml:space="preserve">
          <source>Autocompletion</source>
          <target state="translated">Autocompletion</target>
        </trans-unit>
        <trans-unit id="a8576cba49fa626f39a56bc18330709f71819814" translate="yes" xml:space="preserve">
          <source>Autocompletion can speed up your development time by providing you with contextual possibilities and hints as you type. This example shows autocomplete in an interpolation. As you type it out, you can hit tab to complete.</source>
          <target state="translated">자동 완성 기능은 입력 할 때 상황에 맞는 가능성과 힌트를 제공하여 개발 시간을 단축 할 수 있습니다. 이 예제는 보간에서 자동 완성을 보여줍니다. 입력하면 탭을 눌러 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cc042e9fe579c82af6f851ae39215cc25b9ea23" translate="yes" xml:space="preserve">
          <source>Automatic change detection</source>
          <target state="translated">자동 변경 감지</target>
        </trans-unit>
        <trans-unit id="6eba8d49fe5d13d1fca5b019f42b110fe985ad30" translate="yes" xml:space="preserve">
          <source>Automatic deployment with the CLI</source>
          <target state="translated">CLI를 사용한 자동 배포</target>
        </trans-unit>
        <trans-unit id="8645d08355f818059391b51cb42d575086fb447b" translate="yes" xml:space="preserve">
          <source>Automatic property calculation with wildcards</source>
          <target state="translated">와일드 카드를 사용한 자동 속성 계산</target>
        </trans-unit>
        <trans-unit id="ba24e92f551ffc6d70286e830ff60471df994992" translate="yes" xml:space="preserve">
          <source>Available and activated updates</source>
          <target state="translated">사용 가능하고 활성화 된 업데이트</target>
        </trans-unit>
        <trans-unit id="6b9113ae3a57f7a0dceaa44494d0a520cabe3576" translate="yes" xml:space="preserve">
          <source>Avoid aliasing &lt;code&gt;inputs&lt;/code&gt; and &lt;code&gt;outputs&lt;/code&gt;</source>
          <target state="translated">앨리어싱 &lt;code&gt;inputs&lt;/code&gt; 및 &lt;code&gt;outputs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35d10846ee5de515ce9531aa71d75239dda439f0" translate="yes" xml:space="preserve">
          <source>Avoid referring to enums with complicated initializers or computed properties.</source>
          <target state="translated">복잡한 이니셜 라이저 또는 계산 된 속성이있는 열거 형을 참조하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a4763469397ba3b0cc9e116ced71e140704d303a" translate="yes" xml:space="preserve">
          <source>Avoid side effects</source>
          <target state="translated">부작용을 피하십시오</target>
        </trans-unit>
        <trans-unit id="8d9ef20f693ba88acc4b2ad8c040f990e01cea96" translate="yes" xml:space="preserve">
          <source>Avoid this error by sticking to the compiler's &lt;a href=&quot;aot-compiler#expression-syntax&quot;&gt;restricted expression syntax&lt;/a&gt; when writing Angular metadata and be wary of new or unusual TypeScript features.</source>
          <target state="translated">Angular 메타 데이터를 작성할 때 컴파일러의 &lt;a href=&quot;aot-compiler#expression-syntax&quot;&gt;제한된 표현식 구문&lt;/a&gt; 을 사용하여이 오류를 피하고 새롭거나 특이한 TypeScript 기능에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="6f85b2bfcbb0fa2f75065b9806f3edc8026fee56" translate="yes" xml:space="preserve">
          <source>Azure</source>
          <target state="translated">Azure</target>
        </trans-unit>
        <trans-unit id="5f5f6d9b2535d125e7ae46352acf0bb3d116f1ee" translate="yes" xml:space="preserve">
          <source>B, BB &amp;amp; BBB</source>
          <target state="translated">B, BB 및 BBB</target>
        </trans-unit>
        <trans-unit id="4c55e5e5fc2235cc8c201e69a345f7fab3fb46fa" translate="yes" xml:space="preserve">
          <source>BBBB</source>
          <target state="translated">BBBB</target>
        </trans-unit>
        <trans-unit id="4601044687c40f1a23385d338d02f9fc7f5d512d" translate="yes" xml:space="preserve">
          <source>BBBBB</source>
          <target state="translated">BBBBB</target>
        </trans-unit>
        <trans-unit id="ebdcf0a202669a291a7d498007aa30cf730e825d" translate="yes" xml:space="preserve">
          <source>BEFORE_APP_SERIALIZED</source>
          <target state="translated">BEFORE_APP_SERIALIZED</target>
        </trans-unit>
        <trans-unit id="75b1c4c9960810fdc4641aa8201594f9d464b4ce" translate="yes" xml:space="preserve">
          <source>BY default, the value is randomly generated and assigned to the application by Angular. To provide a custom ID value, use a DI provider  to configure the root &lt;a href=&quot;injector&quot;&gt;&lt;code&gt;Injector&lt;/code&gt;&lt;/a&gt; that uses this token.</source>
          <target state="translated">기본적으로 값은 Angular에 의해 임의로 생성되고 응용 프로그램에 할당됩니다. 사용자 지정 ID 값을 제공하려면 DI 공급자를 사용하여이 토큰을 사용 하는 루트 &lt;a href=&quot;injector&quot;&gt; &lt;code&gt;Injector&lt;/code&gt; &lt;/a&gt; 를 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="2cb09bf3a8782ed3fdbd196ecf0ac3ab8e92b47b" translate="yes" xml:space="preserve">
          <source>Back in the &quot;Heroes&quot; workflow, the app accepts every change to a hero immediately without hesitation or validation.</source>
          <target state="translated">&quot;영웅&quot;워크 플로로 돌아 가면 앱은 망설임이나 검증없이 영웅의 모든 변경 사항을 즉시 수락합니다.</target>
        </trans-unit>
        <trans-unit id="3ebd1dea933ed2810c5164716b5f9c9a32c50825" translate="yes" xml:space="preserve">
          <source>Back in the &quot;Heroes&quot; workflow, the app accepts every change to a hero immediately without validation.</source>
          <target state="translated">&quot;Heroes&quot;워크 플로로 돌아 가면 앱은 유효성 검사없이 Hero에 대한 모든 변경 사항을 즉시 수락합니다.</target>
        </trans-unit>
        <trans-unit id="5e754f85ea186e7a88cea5b09eb25dfdcf33a1ed" translate="yes" xml:space="preserve">
          <source>Back in the &lt;code&gt;AppComponent&lt;/code&gt;, import the &lt;code&gt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;RouterOutlet&lt;/a&gt;&lt;/code&gt; token from the &lt;code&gt;@angular/router&lt;/code&gt; package and the &lt;code&gt;slideInAnimation&lt;/code&gt; from &lt;code&gt;'./animations.ts&lt;/code&gt;.</source>
          <target state="translated">위로의 &lt;code&gt;AppComponent&lt;/code&gt; 가져 오기 &lt;code&gt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;RouterOutlet&lt;/a&gt;&lt;/code&gt; 를 으로부터 토큰 &lt;code&gt;@angular/router&lt;/code&gt; 패키지와 &lt;code&gt;slideInAnimation&lt;/code&gt; 에서 &lt;code&gt;'./animations.ts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9c883a905731bc3ab1e5b1797dcc17a576c4565" translate="yes" xml:space="preserve">
          <source>Back to top</source>
          <target state="translated">맨 위로</target>
        </trans-unit>
        <trans-unit id="38d71168a65ccaba07740a310c00c10c1cf04c0f" translate="yes" xml:space="preserve">
          <source>Background processing using web workers</source>
          <target state="translated">웹 작업자를 사용한 백그라운드 처리</target>
        </trans-unit>
        <trans-unit id="f4290a336cc02b12946c3c89719cd2e7d3a69574" translate="yes" xml:space="preserve">
          <source>Backward compatibility with CSS grid</source>
          <target state="translated">CSS 그리드와의 호환성</target>
        </trans-unit>
        <trans-unit id="f080bd1737639dbd750a023ba99fa346cf943a9f" translate="yes" xml:space="preserve">
          <source>Backward compatibility with Lighthouse</source>
          <target state="translated">Lighthouse와의 호환성</target>
        </trans-unit>
        <trans-unit id="3578397cf875eb735f9e4ec895bfefcd6ea0e18c" translate="yes" xml:space="preserve">
          <source>Base URL for protractor to connect to.</source>
          <target state="translated">각도기에 연결할 기본 URL입니다.</target>
        </trans-unit>
        <trans-unit id="69488c399a2c06d8cc98c0a654ba1be00ce481f8" translate="yes" xml:space="preserve">
          <source>Base class for Angular Views, provides change detection functionality. A change-detection tree collects all views that are to be checked for changes. Use the methods to add and remove views from the tree, initiate change-detection, and explicitly mark views as &lt;em&gt;dirty&lt;/em&gt;, meaning that they have changed and need to be rerendered.</source>
          <target state="translated">각도보기의 기본 클래스는 변경 감지 기능을 제공합니다. 변경 감지 트리는 변경 사항을 점검 할 모든보기를 수집합니다. 메소드를 사용하여 트리에서보기를 추가 및 제거하고 변경 감지를 시작하며보기를 명시 적으로 &lt;em&gt;dirty&lt;/em&gt; 로 표시하십시오 . 이는 변경되어 다시 렌더링해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="dc5f559c4c1d7d90f2ea8b32a7e1b1c62788bfb3" translate="yes" xml:space="preserve">
          <source>Base class for a factory that can create a component dynamically. Instantiate a factory for a given type of component with &lt;code&gt;&lt;a href=&quot;componentfactory&quot;&gt;resolveComponentFactory()&lt;/a&gt;&lt;/code&gt;. Use the resulting &lt;code&gt;ComponentFactory.create()&lt;/code&gt; method to create a component of that type.</source>
          <target state="translated">구성 요소를 동적으로 작성할 수있는 팩토리의 기본 클래스입니다. &lt;code&gt;&lt;a href=&quot;componentfactory&quot;&gt;resolveComponentFactory()&lt;/a&gt;&lt;/code&gt; 를 사용하여 지정된 유형의 컴포넌트에 대한 팩토리를 인스턴스화하십시오 . 결과 &lt;code&gt;ComponentFactory.create()&lt;/code&gt; 메소드를 사용하여 해당 유형의 컴포넌트를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="873cd738027a52aee557333ae0d35f162d826794" translate="yes" xml:space="preserve">
          <source>Base class for a factory that can create a component dynamically. Instantiate a factory for a given type of component with &lt;code&gt;&lt;a href=&quot;core&quot;&gt;resolveComponentFactory()&lt;/a&gt;&lt;/code&gt;. Use the resulting &lt;code&gt;ComponentFactory.create()&lt;/code&gt; method to create a component of that type.</source>
          <target state="translated">구성 요소를 동적으로 작성할 수있는 팩토리의 기본 클래스입니다. &lt;code&gt;&lt;a href=&quot;core&quot;&gt;resolveComponentFactory()&lt;/a&gt;&lt;/code&gt; 를 사용하여 지정된 유형의 컴포넌트에 대한 팩토리를 인스턴스화하십시오 . 결과 &lt;code&gt;ComponentFactory.create()&lt;/code&gt; 메소드를 사용하여 해당 유형의 컴포넌트를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="3dfe758a4a0fb105b1876786c681bb3f3bbe104e" translate="yes" xml:space="preserve">
          <source>Base class for a factory that can create a component dynamically. Instantiate a factory for a given type of component with &lt;code&gt;resolveComponentFactory()&lt;/code&gt;. Use the resulting &lt;code&gt;ComponentFactory.create()&lt;/code&gt; method to create a component of that type.</source>
          <target state="translated">구성 요소를 동적으로 만들 수있는 팩토리의 기본 클래스입니다. &lt;code&gt;resolveComponentFactory()&lt;/code&gt; 를 사용하여 주어진 유형의 구성 요소에 대한 팩토리를 인스턴스화합니다 . 결과 &lt;code&gt;ComponentFactory.create()&lt;/code&gt; 메서드를 사용하여 해당 유형의 구성 요소를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="06b6cf30fccd592a4f7ad01aa440cf8322efc7d5" translate="yes" xml:space="preserve">
          <source>Base class for both &lt;code&gt;&lt;a href=&quot;http/httpresponse&quot;&gt;HttpResponse&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http/httpheaderresponse&quot;&gt;HttpHeaderResponse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http/httpresponse&quot;&gt;HttpResponse&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;http/httpheaderresponse&quot;&gt;HttpHeaderResponse&lt;/a&gt;&lt;/code&gt; 모두에 대한 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="b72bab4ba60f36cf05e4cf503864db197ec58d1a" translate="yes" xml:space="preserve">
          <source>Base class for both &lt;code&gt;&lt;a href=&quot;httpresponse&quot;&gt;HttpResponse&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;httpheaderresponse&quot;&gt;HttpHeaderResponse&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;httpresponse&quot;&gt;HttpResponse&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;httpheaderresponse&quot;&gt;HttpHeaderResponse&lt;/a&gt;&lt;/code&gt; 모두에 대한 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="d87cd5ed68b6935afddd679162562d7c105b48bf" translate="yes" xml:space="preserve">
          <source>Base class for control directives.</source>
          <target state="translated">제어 지시문의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="7c8bf5beced837666a3fcfff47faf58811883c9f" translate="yes" xml:space="preserve">
          <source>Base class for query metadata.</source>
          <target state="translated">쿼리 메타 데이터의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="635e9ee2a4c721f49b71cfa0e21b4e6c42eeb839" translate="yes" xml:space="preserve">
          <source>Base class that provides change detection functionality. A change-detection tree collects all views that are to be checked for changes. Use the methods to add and remove views from the tree, initiate change-detection, and explicitly mark views as &lt;em&gt;dirty&lt;/em&gt;, meaning that they have changed and need to be re-rendered.</source>
          <target state="translated">변경 감지 기능을 제공하는 기본 클래스입니다. 변경 감지 트리는 변경 사항을 확인해야하는 모든보기를 수집합니다. 메소드를 사용하여 트리에서 뷰를 추가 및 제거하고, 변경 감지를 시작하고, 뷰 가 변경되었으며 다시 렌더링해야 함을 의미하는 &lt;em&gt;dirty&lt;/em&gt; 로 명시 적으로 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="ae3542392d51807f46bde8565dbb42d8fcc3c899" translate="yes" xml:space="preserve">
          <source>Base for animation data structures.</source>
          <target state="translated">애니메이션 데이터 구조의 기초.</target>
        </trans-unit>
        <trans-unit id="332796bde2e92bb79ea8d8b003db847231db277a" translate="yes" xml:space="preserve">
          <source>Base for events the router goes through, as opposed to events tied to a specific route. Fired one time for any given navigation.</source>
          <target state="translated">특정 경로에 연결된 이벤트와 달리 라우터가 통과하는 이벤트의 기본입니다. 특정 탐색에 대해 한 번만 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="dc0e3cb0c30a7fd999cfb13abd9ca5e0359899bd" translate="yes" xml:space="preserve">
          <source>Base interface for progress events.</source>
          <target state="translated">진행 이벤트를위한 기본 인터페이스.</target>
        </trans-unit>
        <trans-unit id="19c642b2c76cffbbba7c48b8234e3965239d1723" translate="yes" xml:space="preserve">
          <source>Base url for the application being built.</source>
          <target state="translated">빌드중인 애플리케이션의 기본 URL입니다.</target>
        </trans-unit>
        <trans-unit id="c15b8155598bbd0eb4ddda108efeed6d3faaa586" translate="yes" xml:space="preserve">
          <source>Base your decision on your comfort level. Use a flatter structure until there is an obvious value to creating a new folder.</source>
          <target state="translated">편안함 수준에 따라 결정하십시오. 새 폴더를 만드는 데 확실한 가치가있을 때까지 더 평평한 구조를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3076d2f98148e70924e7e811bb728bbdd8a7383a" translate="yes" xml:space="preserve">
          <source>BaseRouteReuseStrategy</source>
          <target state="translated">BaseRouteReuseStrategy</target>
        </trans-unit>
        <trans-unit id="457c8d9bebfca77b21842bdcc7ca17bb844fb9ac" translate="yes" xml:space="preserve">
          <source>Based on the &lt;code&gt;--target&lt;/code&gt;, TypeScript adds &lt;em&gt;additional&lt;/em&gt; ambient declarations like &lt;code&gt;Promise&lt;/code&gt; if the target is &lt;code&gt;es6&lt;/code&gt;.</source>
          <target state="translated">에 기초 &lt;code&gt;--target&lt;/code&gt; , 타이프 덧붙인다 &lt;em&gt;추가&lt;/em&gt; 같은 주변 선언 &lt;code&gt;Promise&lt;/code&gt; 대상인지 &lt;code&gt;es6&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dac6b24f78471a132bc9a7ec7774530351b54fb0" translate="yes" xml:space="preserve">
          <source>Basic Example</source>
          <target state="translated">기본 예</target>
        </trans-unit>
        <trans-unit id="04e8ea10d9114654af829cd500f25ab6581dd803" translate="yes" xml:space="preserve">
          <source>Basic deployment to a remote server</source>
          <target state="translated">원격 서버에 대한 기본 배포</target>
        </trans-unit>
        <trans-unit id="063ab1d912949e267d46aeb8da49267a312d5fc8" translate="yes" xml:space="preserve">
          <source>Basic knowledge of &lt;a href=&quot;reactive-forms&quot;&gt;reactive forms&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;reactive-forms&quot;&gt;반응 형에&lt;/a&gt; 대한 기본 지식 .</target>
        </trans-unit>
        <trans-unit id="700ed102a28fe8fc4eddc583c6a8a0bbe5b01d1d" translate="yes" xml:space="preserve">
          <source>Basic mode</source>
          <target state="translated">기본 모드</target>
        </trans-unit>
        <trans-unit id="653ae9d4bc08db3838f9c6c61951682ba7657958" translate="yes" xml:space="preserve">
          <source>Basic usage and terms</source>
          <target state="translated">기본 사용법 및 용어</target>
        </trans-unit>
        <trans-unit id="189ceeabec801d69e58e27b3296832fd339cfd5c" translate="yes" xml:space="preserve">
          <source>Basic workflow</source>
          <target state="translated">기본 워크 플로우</target>
        </trans-unit>
        <trans-unit id="a35274a9de216b3996a2a6b71246c15e2bcf3d04" translate="yes" xml:space="preserve">
          <source>Basics of components</source>
          <target state="translated">구성 요소의 기본</target>
        </trans-unit>
        <trans-unit id="fc01111eade2759f3e275f9731fae544b98ca2d8" translate="yes" xml:space="preserve">
          <source>Basics of either &lt;a href=&quot;forms&quot;&gt;Template-driven Forms&lt;/a&gt; or &lt;a href=&quot;reactive-forms&quot;&gt;Reactive Forms&lt;/a&gt;.</source>
          <target state="translated">하나의 기본 &lt;a href=&quot;forms&quot;&gt;템플릿 기반의 양식&lt;/a&gt; 또는 &lt;a href=&quot;reactive-forms&quot;&gt;반응성 양식&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e61b0285152a2eae841cd8ebb75ab77a99b10a1d" translate="yes" xml:space="preserve">
          <source>Basics of templates</source>
          <target state="translated">템플릿의 기초</target>
        </trans-unit>
        <trans-unit id="4815228259a0751e18e68db23b416c479a8fcde2" translate="yes" xml:space="preserve">
          <source>Basics of testing components</source>
          <target state="translated">구성 요소 테스트의 기초</target>
        </trans-unit>
        <trans-unit id="21db9140fd5c55af9b7daf2fcc86cdbecd519ae0" translate="yes" xml:space="preserve">
          <source>Basics of two-way binding</source>
          <target state="translated">양방향 바인딩의 기초</target>
        </trans-unit>
        <trans-unit id="1276e18d03ecc54657c7ab3b6a5e107e8237506b" translate="yes" xml:space="preserve">
          <source>Basics wrap up</source>
          <target state="translated">기본 마무리</target>
        </trans-unit>
        <trans-unit id="10297ac57954a12cf832e6d7cca38640fa142a64" translate="yes" xml:space="preserve">
          <source>Bazel builder and schematics</source>
          <target state="translated">Bazel 빌더 및 회로도</target>
        </trans-unit>
        <trans-unit id="0fd52192ef4a4a502c98dddd59b2a553be18b512" translate="yes" xml:space="preserve">
          <source>Bazel builder and schematics were introduced in Angular Labs to let users try out Bazel without having to manage Bazel version and BUILD files. This feature has been deprecated. For more information, please refer to the &lt;a href=&quot;https://github.com/angular/angular/blob/master/packages/bazel/src/schematics/README.md&quot;&gt;migration doc&lt;/a&gt;.</source>
          <target state="translated">사용자가 Bazel 버전 및 BUILD 파일을 관리하지 않고도 Bazel을 사용해 볼 수 있도록 Bazel 빌더 및 회로도가 Angular Labs에 도입되었습니다. 이 기능은 더 이상 사용되지 않습니다. 자세한 내용은 &lt;a href=&quot;https://github.com/angular/angular/blob/master/packages/bazel/src/schematics/README.md&quot;&gt;마이그레이션 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b910aa222ba05ed1cabb9a85eecf07e8960306d" translate="yes" xml:space="preserve">
          <source>Be explicit and implement the &lt;code&gt;&lt;a href=&quot;../api/router/resolve&quot;&gt;Resolve&lt;/a&gt;&lt;/code&gt; interface with a type of &lt;code&gt;Crisis&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Crisis&lt;/code&gt; 유형으로 &lt;code&gt;&lt;a href=&quot;../api/router/resolve&quot;&gt;Resolve&lt;/a&gt;&lt;/code&gt; 인터페이스를 명시하고 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="381c08b859c05a623a77795b6faef27c11b8be2b" translate="yes" xml:space="preserve">
          <source>Be explicit. Implement the &lt;code&gt;&lt;a href=&quot;../api/router/resolve&quot;&gt;Resolve&lt;/a&gt;&lt;/code&gt; interface with a type of &lt;code&gt;Crisis&lt;/code&gt;.</source>
          <target state="translated">명시 적이어야합니다. &lt;code&gt;Crisis&lt;/code&gt; 유형으로 &lt;code&gt;&lt;a href=&quot;../api/router/resolve&quot;&gt;Resolve&lt;/a&gt;&lt;/code&gt; 인터페이스를 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="1bf79b7186da202dc35b6c9fdce5e4c57c7d1a68" translate="yes" xml:space="preserve">
          <source>Be sure to check that the context exists and throw the appropriate error.</source>
          <target state="translated">컨텍스트가 존재하는지 확인하고 적절한 오류를 발생 시키십시오.</target>
        </trans-unit>
        <trans-unit id="795a90d1a8ee5cbdff797b42bb7461a0906585d9" translate="yes" xml:space="preserve">
          <source>Be sure to create module components as children of this module's top component.</source>
          <target state="translated">모듈 구성 요소를이 모듈의 최상위 구성 요소의 하위로 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="e61c47ca4bb6fa8b383f353cab783005cfd6efe8" translate="yes" xml:space="preserve">
          <source>Be sure to define custom IDs that are unique. If you use the same ID for two different text elements, the extraction tool extracts only the first one, and Angular uses its translation in place of both original text elements.</source>
          <target state="translated">고유 한 사용자 지정 ID를 정의해야합니다. 두 개의 다른 텍스트 요소에 동일한 ID를 사용하는 경우 추출 도구는 첫 번째 요소 만 추출하고 Angular는 두 원본 텍스트 요소 대신 번역을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7d5bf806d7d027af1dddb36dc70adddb33b479b7" translate="yes" xml:space="preserve">
          <source>Be sure to define custom ids that are unique. If you use the same id for two different text messages, only the first one is extracted, and its translation is used in place of both original text messages.</source>
          <target state="translated">고유 한 사용자 정의 ID를 정의하십시오. 서로 다른 두 개의 문자 메시지에 동일한 ID를 사용하는 경우 첫 번째 문자 메시지 만 추출되고 원래 문자 메시지 대신 번역이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d49c7d22f7883e13f3cefcd14247137e8f69ed59" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;lib-header&amp;gt;&lt;/code&gt; is optional, the element can appear in the template in its minimal form, &lt;code&gt;&amp;lt;lib-card&amp;gt;&amp;lt;/lib-card&amp;gt;&lt;/code&gt;. In this case, &lt;code&gt;&amp;lt;lib-header&amp;gt;&lt;/code&gt; is not used and you would expect it to be tree-shaken, but that is not what happens. This is because &lt;code&gt;LibCardComponent&lt;/code&gt; actually contains two references to the &lt;code&gt;LibHeaderComponent&lt;/code&gt;.</source>
          <target state="translated">때문에 &lt;code&gt;&amp;lt;lib-header&amp;gt;&lt;/code&gt; 선택 사항이며, 요소가 그 최소한의 양식 서식 파일에 나타날 수있는 &lt;code&gt;&amp;lt;lib-card&amp;gt;&amp;lt;/lib-card&amp;gt;&lt;/code&gt; . 이 경우 &lt;code&gt;&amp;lt;lib-header&amp;gt;&lt;/code&gt; 는 사용되지 않으며 트리가 흔들릴 것으로 예상 할 수 있지만 그렇지 않습니다. 때문이다 &lt;code&gt;LibCardComponent&lt;/code&gt; 은 실제로 두 개의 참조가 포함되어 &lt;code&gt;LibHeaderComponent&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="3cb44eeb12ea39170bc603c6fb44cf6110a2d9a2" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;HeroDetailComponent&lt;/code&gt; is an Angular component, you must also add it to the &lt;code&gt;declarations&lt;/code&gt; in the &lt;code&gt;AppModule&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HeroDetailComponent&lt;/code&gt; 는 Angular 컴포넌트 이므로 &lt;code&gt;AppModule&lt;/code&gt; 의 &lt;code&gt;declarations&lt;/code&gt; 에 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a71b98122cf3ec666c4be311886fe1a144f93c35" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;compileComponents&lt;/code&gt; is asynchronous, it uses the &lt;a href=&quot;../api/core/testing/waitforasync&quot;&gt;&lt;code&gt;waitForAsync&lt;/code&gt;&lt;/a&gt; utility function imported from &lt;code&gt;@angular/core/testing&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;compileComponents&lt;/code&gt; 는 비동기식 이므로 &lt;code&gt;@angular/core/testing&lt;/code&gt; 에서 가져온 &lt;a href=&quot;../api/core/testing/waitforasync&quot;&gt; &lt;code&gt;waitForAsync&lt;/code&gt; &lt;/a&gt; 유틸리티 함수를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="71459b0877ea037c4247f79f200b0627331cfde5" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;ng serve&lt;/code&gt; does not work with service workers, you must use a separate HTTP server to test your project locally. You can use any HTTP server. The example below uses the &lt;a href=&quot;https://www.npmjs.com/package/http-server&quot;&gt;http-server&lt;/a&gt; package from npm. To reduce the possibility of conflicts and avoid serving stale content, test on a dedicated port and disable caching.</source>
          <target state="translated">때문에 &lt;code&gt;ng serve&lt;/code&gt; 서비스 근로자 작동하지 않습니다, 당신은 로컬 프로젝트를 테스트하기 위해 별도의 HTTP 서버를 사용해야합니다. 모든 HTTP 서버를 사용할 수 있습니다. 아래 예 는 npm 의 &lt;a href=&quot;https://www.npmjs.com/package/http-server&quot;&gt;http-server&lt;/a&gt; 패키지를 사용합니다 . 충돌 가능성을 줄이고 오래된 콘텐츠를 제공하지 않으려면 전용 포트에서 테스트하고 캐싱을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="342f36e72319b97e67057da06eb0202d32290ccf" translate="yes" xml:space="preserve">
          <source>Because Angular applications are mostly written in TypeScript, you will typically know when a variable is an observable. Although the Angular framework does not enforce a naming convention for observables, you will often see observables named with a trailing &amp;ldquo;$&amp;rdquo; sign.</source>
          <target state="translated">Angular 응용 프로그램은 대부분 TypeScript로 작성되기 때문에 변수가 언제 관찰 가능한지 알 수 있습니다. Angular 프레임 워크에서는 관찰 가능 개체에 대한 명명 규칙을 적용하지 않지만 &quot;$&quot;기호가 붙은 관측 가능 개체가 종종 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="80706cd8d34e9df3aebbbfc71eb5c40862507ed2" translate="yes" xml:space="preserve">
          <source>Because Bazel constructs a graph out of your targets, you can find lots of useful information.</source>
          <target state="translated">Bazel은 대상에서 그래프를 생성하므로 유용한 정보를 많이 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3244368a86d6561aba583792cc03eff7eff140ec" translate="yes" xml:space="preserve">
          <source>Because a Universal app doesn't execute in the browser, some of the browser APIs and capabilities may be missing on the server.</source>
          <target state="translated">브라우저에서 범용 앱이 실행되지 않기 때문에 일부 브라우저 API 및 기능이 서버에서 누락되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f4be1daa693b107a5635c119a5bcab95b440545" translate="yes" xml:space="preserve">
          <source>Because directives and pipes appear in component templates, the Angular compiler incorporates them into compiled component code too.</source>
          <target state="translated">지시문과 파이프는 컴포넌트 템플릿에 나타나기 때문에 Angular 컴파일러는 컴파일 된 컴포넌트 코드에도이를 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="f73de75658f57ce63ea356bf33e3b7801f62fafb" translate="yes" xml:space="preserve">
          <source>Because each service method returns a different kind of &lt;code&gt;Observable&lt;/code&gt; result, &lt;code&gt;&lt;a href=&quot;../api/core/errorhandler#handleError&quot;&gt;handleError()&lt;/a&gt;&lt;/code&gt; takes a type parameter so it can return the safe value as the type that the app expects.</source>
          <target state="translated">각 서비스 메서드는 서로 다른 종류의 &lt;code&gt;Observable&lt;/code&gt; 결과 를 반환하므로 &lt;code&gt;&lt;a href=&quot;../api/core/errorhandler#handleError&quot;&gt;handleError()&lt;/a&gt;&lt;/code&gt; 는 형식 매개 변수를 사용하므로 앱이 기대하는 형식으로 안전한 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ccabadf6eacc3ed0298a9f1066397f953b77131" translate="yes" xml:space="preserve">
          <source>Because each service method returns a different kind of &lt;code&gt;Observable&lt;/code&gt; result, &lt;code&gt;handleError()&lt;/code&gt; takes a type parameter so it can return the safe value as the type that the app expects.</source>
          <target state="translated">각 서비스 메서드는 다른 종류의 &lt;code&gt;Observable&lt;/code&gt; 결과를 반환하기 때문에 &lt;code&gt;handleError()&lt;/code&gt; 는 앱이 예상하는 형식으로 안전한 값을 반환 할 수 있도록 형식 매개 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="46939d4d0ba537e542bde8f87ab09af4cea60a09" translate="yes" xml:space="preserve">
          <source>Because interceptors are (optional) dependencies of the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; service, you must provide them in the same injector (or a parent of the injector) that provides &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt;. Interceptors provided &lt;em&gt;after&lt;/em&gt; DI creates the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; are ignored.</source>
          <target state="translated">인터셉터는 (옵션) 의존성 때문에 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 를 서비스, 당신이 제공하는 동일한 인젝터 (또는 인젝터의 부모)에이를 제공해야 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 를 . DI가 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 를 생성 &lt;em&gt;한 후&lt;/em&gt; 제공된 인터셉터 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ebedc3d0a5c7a3fec99ebbc8e460b97a0d2a4cf2" translate="yes" xml:space="preserve">
          <source>Because interceptors can process the request and response &lt;em&gt;together&lt;/em&gt;, they can do things like time and log an entire HTTP operation.</source>
          <target state="translated">인터셉터는 요청과 응답을 &lt;em&gt;함께&lt;/em&gt; 처리 할 수 있으므로 시간과 같은 작업을 수행하고 전체 HTTP 조작을 로그 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2d71f3190ead35022f872f1cc8b0026fc4180ab" translate="yes" xml:space="preserve">
          <source>Because interceptors can process the request and response &lt;em&gt;together&lt;/em&gt;, they can perform tasks such as timing and logging an entire HTTP operation.</source>
          <target state="translated">인터셉터는 요청과 응답을 &lt;em&gt;함께&lt;/em&gt; 처리 할 수 있으므로 전체 HTTP 작업의 타이밍 및 로깅과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d9990b0c02c63922de8ac7eb597a4dbd80a3bf1" translate="yes" xml:space="preserve">
          <source>Because many app components need the &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;../api/common/titlecasepipe&quot;&gt;TitleCasePipe&lt;/a&gt;&lt;/code&gt;, the developer created a &lt;code&gt;SharedModule&lt;/code&gt; to combine these and other frequently requested parts.</source>
          <target state="translated">많은 응용 프로그램의 구성 요소가 필요하기 때문에 &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;../api/common/titlecasepipe&quot;&gt;TitleCasePipe&lt;/a&gt;&lt;/code&gt; 을 , 개발자는 생성 된 &lt;code&gt;SharedModule&lt;/code&gt; 이들과 다른 자주 요청되는 부분을 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7309f02327abcb02906eb27e1961d1e11ff57034" translate="yes" xml:space="preserve">
          <source>Because much AngularJS code is in JavaScript, JavaScript code is shown in the AngularJS column. The Angular code is shown using TypeScript.</source>
          <target state="translated">많은 AngularJS 코드가 JavaScript에 있기 때문에 JavaScript 코드는 AngularJS 열에 표시됩니다. 각도 코드는 TypeScript를 사용하여 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b19a9e8492a1eac84038f4635a1cd76785f5684a" translate="yes" xml:space="preserve">
          <source>Because no native HTML element follows the &lt;code&gt;x&lt;/code&gt; value and &lt;code&gt;xChange&lt;/code&gt; event pattern, two-way binding with form elements requires &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;NgModel&lt;/a&gt;&lt;/code&gt;. For more information on how to use two-way binding in forms, see Angular &lt;a href=&quot;built-in-directives#ngModel&quot;&gt;NgModel&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 값 및 &lt;code&gt;xChange&lt;/code&gt; 이벤트 패턴을 따르는 기본 HTML 요소가 없기 때문에 양식 요소를 사용한 양방향 바인딩에는 &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;NgModel&lt;/a&gt;&lt;/code&gt; 이 필요합니다 . 양식에서 양방향 바인딩을 사용하는 방법에 대한 자세한 내용은 Angular &lt;a href=&quot;built-in-directives#ngModel&quot;&gt;NgModel을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f63ecad480eaacde83f906bac0c6143c6ea2184e" translate="yes" xml:space="preserve">
          <source>Because observables produce values asynchronously, try/catch will not effectively catch errors. Instead, you handle errors by specifying an &lt;code&gt;error&lt;/code&gt; callback on the observer. Producing an error also causes the observable to clean up subscriptions and stop producing values. An observable can either produce values (calling the &lt;code&gt;next&lt;/code&gt; callback), or it can complete, calling either the &lt;code&gt;complete&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt; callback.</source>
          <target state="translated">관찰 가능 항목은 비동기 적으로 값을 생성하므로 try / catch는 효과적으로 오류를 포착하지 않습니다. 대신 관찰자 에서 &lt;code&gt;error&lt;/code&gt; 콜백을 지정하여 오류 를 처리합니다 . 또한 오류를 생성하면 옵저버 블이 구독을 정리하고 값 생성을 중지합니다. Observable은 값을 생성하거나 ( &lt;code&gt;next&lt;/code&gt; 콜백 호출) &lt;code&gt;complete&lt;/code&gt; 또는 &lt;code&gt;error&lt;/code&gt; 콜백을 호출하여 완료 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b1058fd96afe9d690d0969b15ba453bf7c67528" translate="yes" xml:space="preserve">
          <source>Because of these advantages, observables are used extensively within Angular, and are recommended for app development as well.</source>
          <target state="translated">이러한 장점으로 인해 Observable은 Angular 내에서 광범위하게 사용되며 앱 개발에도 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="a3b6660bf41bb567678e15b0038461e5765da5cb" translate="yes" xml:space="preserve">
          <source>Because of these many obstacles, you should test DOM interaction with unit testing techniques as much as possible.</source>
          <target state="translated">이러한 많은 장애물 때문에 가능한 한 단위 테스트 기술과 DOM 상호 작용을 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="772276ca842c13128ca4d0e6c6d501e1f891a5e6" translate="yes" xml:space="preserve">
          <source>Because template-driven forms are in their own module, you need to add the &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; to the array of &lt;code&gt;imports&lt;/code&gt; for the application module before you can use forms.</source>
          <target state="translated">템플릿 기반 양식은 자체 모듈에 있으므로 양식을 사용하기 전에 응용 프로그램 모듈 의 &lt;code&gt;imports&lt;/code&gt; 배열에 &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; 을 추가해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f75c667b11d2d8cfaed8c93263c0b980c8478dec" translate="yes" xml:space="preserve">
          <source>Because the &lt;a href=&quot;testing#dashboard-hero-component&quot;&gt;template&lt;/a&gt; passes the hero name through the Angular &lt;code&gt;&lt;a href=&quot;../api/common/uppercasepipe&quot;&gt;UpperCasePipe&lt;/a&gt;&lt;/code&gt;, the test must match the element value with the upper-cased name.</source>
          <target state="translated">때문에 &lt;a href=&quot;testing#dashboard-hero-component&quot;&gt;템플릿&lt;/a&gt; 각도를 통해 영웅의 이름을 통과 &lt;code&gt;&lt;a href=&quot;../api/common/uppercasepipe&quot;&gt;UpperCasePipe&lt;/a&gt;&lt;/code&gt; , 시험은 상단 맡았다 이름을 가진 요소의 값과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="6f5db9bdd91a54612d57188e6c89f939ca3ea573" translate="yes" xml:space="preserve">
          <source>Because the &lt;a href=&quot;testing-components-scenarios#dashboard-hero-component&quot;&gt;template&lt;/a&gt; passes the hero name through the Angular &lt;code&gt;&lt;a href=&quot;../api/common/uppercasepipe&quot;&gt;UpperCasePipe&lt;/a&gt;&lt;/code&gt;, the test must match the element value with the upper-cased name.</source>
          <target state="translated">때문에 &lt;a href=&quot;testing-components-scenarios#dashboard-hero-component&quot;&gt;템플릿&lt;/a&gt; 각도를 통해 영웅의 이름을 통과 &lt;code&gt;&lt;a href=&quot;../api/common/uppercasepipe&quot;&gt;UpperCasePipe&lt;/a&gt;&lt;/code&gt; , 시험은 상단 맡았다 이름을 가진 요소의 값과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="7fffab32755aa9a95819efcad47313434ea4ee47" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;HeroesModule&lt;/code&gt; now provides the &lt;code&gt;HeroListComponent&lt;/code&gt;, remove it from the &lt;code&gt;AppModule&lt;/code&gt;'s &lt;code&gt;declarations&lt;/code&gt; array. Now that you have a separate &lt;code&gt;HeroesModule&lt;/code&gt;, you can evolve the hero feature with more components and different routes.</source>
          <target state="translated">때문에 &lt;code&gt;HeroesModule&lt;/code&gt; 가 지금 제공 &lt;code&gt;HeroListComponent&lt;/code&gt; 을 의에서 제거 &lt;code&gt;AppModule&lt;/code&gt; 의 &lt;code&gt;declarations&lt;/code&gt; 배열입니다. 이제 별도의 &lt;code&gt;HeroesModule&lt;/code&gt; 이 있으므로 더 많은 구성 요소와 다른 경로를 사용하여 Hero 기능을 발전시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb19305312e2b1bf07f79171f6856a936e20b002" translate="yes" xml:space="preserve">
          <source>Because the component template uses two-way data binding for the &lt;code&gt;favoriteColor&lt;/code&gt; property, the &lt;code&gt;favoriteColor&lt;/code&gt; property in the component is updated to the value emitted by the &lt;code&gt;ngModelChange&lt;/code&gt; event (&lt;em&gt;Blue&lt;/em&gt;).</source>
          <target state="translated">구성 요소 템플릿은 &lt;code&gt;favoriteColor&lt;/code&gt; 속성에 양방향 데이터 바인딩을 사용하므로 구성 요소 의 &lt;code&gt;favoriteColor&lt;/code&gt; 속성은 &lt;code&gt;ngModelChange&lt;/code&gt; 이벤트 ( &lt;em&gt;Blue&lt;/em&gt; ) 에서 생성 된 값으로 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="3559bd87675d83ca7d84212b131b57dd2128c250" translate="yes" xml:space="preserve">
          <source>Because the custom id is the same, both of the elements in the resulting translation contain the same text, &lt;code&gt;Bonjour&lt;/code&gt;:</source>
          <target state="translated">사용자 정의 ID가 동일하므로 결과 번역의 두 요소 모두 &lt;code&gt;Bonjour&lt;/code&gt; 같은 동일한 텍스트를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="ac60673f94b3d3376ab5d403b236e2c865d35a46" translate="yes" xml:space="preserve">
          <source>Because the new module is meant to be lazy-loaded, the command does NOT add a reference for the new feature module to the root application's module file, &lt;code&gt;app.module.ts&lt;/code&gt;. Instead, it adds the declared route, &lt;code&gt;customer-list&lt;/code&gt; to the &lt;code&gt;&lt;a href=&quot;../api/router/routes&quot;&gt;Routes&lt;/a&gt;&lt;/code&gt; array declared in the module provided as the &lt;code&gt;--module&lt;/code&gt; option.</source>
          <target state="translated">새 모듈은 지연로드되도록되어 있기 때문에 명령은 새 기능 모듈에 대한 참조를 루트 애플리케이션의 모듈 파일 &lt;code&gt;app.module.ts&lt;/code&gt; 에 추가하지 않습니다 . 대신 선언 된 route, &lt;code&gt;customer-list&lt;/code&gt; 를 &lt;code&gt;--module&lt;/code&gt; 옵션으로 제공된 모듈에 선언 된 &lt;code&gt;&lt;a href=&quot;../api/router/routes&quot;&gt;Routes&lt;/a&gt;&lt;/code&gt; 배열에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="f7da6c9a81975e26c4d0dd69691dee4a8dec5786" translate="yes" xml:space="preserve">
          <source>Because the new module is meant to be lazy-loaded, the command does NOT add a reference to the new feature module in the application's root module file, &lt;code&gt;app.module.ts&lt;/code&gt;. Instead, it adds the declared route, &lt;code&gt;customers&lt;/code&gt; to the &lt;code&gt;routes&lt;/code&gt; array declared in the module provided as the &lt;code&gt;--module&lt;/code&gt; option.</source>
          <target state="translated">새 모듈은 지연로드되는 것을 의미 &lt;code&gt;app.module.ts&lt;/code&gt; 명령은 애플리케이션의 루트 모듈 파일 app.module.ts 에있는 새 기능 모듈에 대한 참조를 추가하지 않습니다 . 대신 &lt;code&gt;--module&lt;/code&gt; 옵션으로 제공되는 모듈에 선언 된 &lt;code&gt;routes&lt;/code&gt; 배열에 선언 된 경로, &lt;code&gt;customers&lt;/code&gt; 을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="8f72bc222c5187cbceca225395ab2edb41eb5670" translate="yes" xml:space="preserve">
          <source>Because the sample tests for this guide are designed to run only in a browser, a &lt;code&gt;nativeElement&lt;/code&gt; in these tests is always an &lt;code&gt;HTMLElement&lt;/code&gt; whose familiar methods and properties you can explore within a test.</source>
          <target state="translated">이 안내서의 샘플 테스트는 브라우저에서만 실행되도록 설계 &lt;code&gt;nativeElement&lt;/code&gt; 테스트 의 nativeElement 는 항상 테스트 내에서 탐색 할 수있는 친숙한 메소드 및 특성을 가진 &lt;code&gt;HTMLElement&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="011af8b0f357ff673113afd8db33d1ac6ff8678e" translate="yes" xml:space="preserve">
          <source>Because the service method returns an &lt;code&gt;Observable&lt;/code&gt; of configuration data, the component &lt;em&gt;subscribes&lt;/em&gt; to the method's return value. The subscription callback performs minimal post-processing. It copies the data fields into the component's &lt;code&gt;config&lt;/code&gt; object, which is data-bound in the component template for display.</source>
          <target state="translated">서비스 메서드는 구성 데이터 의 &lt;code&gt;Observable&lt;/code&gt; 을 반환하기 때문에 구성 요소 는 메서드의 반환 값을 &lt;em&gt;구독&lt;/em&gt; 합니다. 구독 콜백은 최소한의 사후 처리를 수행합니다. 표시를 위해 구성 요소 템플릿에 데이터 바인딩 된 구성 요소의 &lt;code&gt;config&lt;/code&gt; 개체에 데이터 필드를 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="5ba2132d051625545e383f4b78d7ded919141bef" translate="yes" xml:space="preserve">
          <source>Because the service method returns an &lt;code&gt;Observable&lt;/code&gt; of configuration data, the component &lt;strong&gt;subscribes&lt;/strong&gt; to the method's return value. The subscription callback copies the data fields into the component's &lt;code&gt;&lt;a href=&quot;../api/router/router#config&quot;&gt;config&lt;/a&gt;&lt;/code&gt; object, which is data-bound in the component template for display.</source>
          <target state="translated">서비스 메소드는 &lt;code&gt;Observable&lt;/code&gt; of configuration 데이터를 리턴 하므로 컴포넌트 는 메소드의 리턴 값을 &lt;strong&gt;구독&lt;/strong&gt; 합니다. 구독 콜백은 데이터 필드를 구성 요소의 &lt;code&gt;&lt;a href=&quot;../api/router/router#config&quot;&gt;config&lt;/a&gt;&lt;/code&gt; 오브젝트 로 복사합니다 . 구성 요소는 표시 할 구성 요소 템플리트에서 데이터 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="8460f3c5a0030447eadc8c95b36ae1865a187e73" translate="yes" xml:space="preserve">
          <source>Because the spy result returns synchronously, the &lt;code&gt;getQuote()&lt;/code&gt; method updates the message on screen immediately &lt;em&gt;after&lt;/em&gt; the first change detection cycle during which Angular calls &lt;code&gt;ngOnInit&lt;/code&gt;.</source>
          <target state="translated">동 기적으로 스파이 결과를 반환하기 때문에, &lt;code&gt;getQuote()&lt;/code&gt; 메소드는 즉시 화면에 메시지를 업데이트 &lt;em&gt;한 후&lt;/em&gt; 각도가 호출하는 동안 첫 번째 변경 감지주기 &lt;code&gt;ngOnInit&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="e716f7ac284970330d5ea0ebf9a16fdfedd60bbd" translate="yes" xml:space="preserve">
          <source>Because the value of the property &lt;code&gt;isUnchanged&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; in the &lt;code&gt;AppComponent&lt;/code&gt;, Angular disables the button.</source>
          <target state="translated">속성 값이므로 &lt;code&gt;isUnchanged&lt;/code&gt; 가 있다 &lt;code&gt;true&lt;/code&gt; 에 &lt;code&gt;AppComponent&lt;/code&gt; 각도 비활성화 버튼.</target>
        </trans-unit>
        <trans-unit id="ae3ebebb2c33ca11b4aadf44642620433d674fef" translate="yes" xml:space="preserve">
          <source>Because we use routing, we can easily recognize the three types of requests and handle them differently.</source>
          <target state="translated">라우팅을 사용하기 때문에 세 가지 유형의 요청을 쉽게 인식하고 다르게 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="7c1e35fdf2c95e740d747fb6e8d2cb1e5ce349b8" translate="yes" xml:space="preserve">
          <source>Before a view is displayed, Angular evaluates the directives and resolves the binding syntax in the template to modify the HTML elements and the DOM, according to your program data and logic. Angular supports &lt;em&gt;two-way data binding&lt;/em&gt;, meaning that changes in the DOM, such as user choices, are also reflected in your program data.</source>
          <target state="translated">뷰가 표시되기 전에 Angular는 지시문을 평가하고 템플릿의 바인딩 구문을 분석하여 프로그램 데이터 및 논리에 따라 HTML 요소와 DOM을 수정합니다. Angular는 &lt;em&gt;양방향 데이터 바인딩을&lt;/em&gt; 지원합니다 . 즉, 사용자 선택과 같은 DOM의 변경 사항도 프로그램 데이터에 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="3f3310ad85328d69644a5539eaa58ef7a2519e78" translate="yes" xml:space="preserve">
          <source>Before creating a route, you should be familiar with the following:</source>
          <target state="translated">경로를 만들기 전에 다음 사항을 숙지해야합니다.</target>
        </trans-unit>
        <trans-unit id="9612053115f04a1c2064165c3d23081783892532" translate="yes" xml:space="preserve">
          <source>Before disabling Ivy, check out the debugging recommendations in the &lt;a href=&quot;ivy-compatibility#debugging&quot;&gt;Ivy Compatibility Guide&lt;/a&gt;.</source>
          <target state="translated">Ivy를 비활성화하기 전에 &lt;a href=&quot;ivy-compatibility#debugging&quot;&gt;Ivy 호환성 가이드&lt;/a&gt; 에서 디버깅 권장 사항을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="56a2690d6d4ee87e844d5b45b79d0937210c67e9" translate="yes" xml:space="preserve">
          <source>Before discussing how you can use &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; to create hybrid apps, there are things that you can do to ease the upgrade process even before you begin upgrading. Because the steps are the same regardless of how you upgrade, refer to the &lt;a href=&quot;upgrade#preparation&quot;&gt;Preparation&lt;/a&gt; section of &lt;a href=&quot;upgrade&quot;&gt;Upgrading from AngularJS&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; 을 사용하여 하이브리드 앱을 만드는 방법을 논의하기 전에 업그레이드를 시작하기 전에 업그레이드 프로세스를 쉽게 수행 할 수있는 작업이 있습니다. 업그레이드 방법에 관계없이 단계가 동일하므로 &lt;a href=&quot;upgrade&quot;&gt;AngularJS에서 업그레이드&lt;/a&gt; 의 &lt;a href=&quot;upgrade#preparation&quot;&gt;준비&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2bd6921a15a4cc4213b02c123a7b7fdf88397ce4" translate="yes" xml:space="preserve">
          <source>Before doing that, understand the difference between pure and impure, starting with a pure pipe.</source>
          <target state="translated">이를 수행하기 전에 순수한 파이프로 시작하여 순수와 불순의 차이점을 이해하십시오.</target>
        </trans-unit>
        <trans-unit id="fc24538f225bd74078ff36203b3ade5aa341dca1" translate="yes" xml:space="preserve">
          <source>Before doing this tutorial, you should have a basic understanding to the following.</source>
          <target state="translated">이 자습서를 수행하기 전에 다음에 대한 기본적인 이해가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="938bfb0cc4fb4eee22c10427c31d0ba174568291" translate="yes" xml:space="preserve">
          <source>Before fully deploying your application, you can test the process, build configuration, and deployed behavior by using one of these interim techniques.</source>
          <target state="translated">응용 프로그램을 완전히 배포하기 전에 이러한 임시 기술 중 하나를 사용하여 프로세스를 테스트하고 구성을 구축하며 동작을 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b79cd0b493b0831cb177440164f7335b569a885f" translate="yes" xml:space="preserve">
          <source>Before going further into reactive forms, you should have a basic understanding of the following:</source>
          <target state="translated">반응 형으로 진행하기 전에 다음 사항에 대한 기본적인 이해가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="fba9d1e7e32986f6b3010a0a9c710cb5b1f8bf77" translate="yes" xml:space="preserve">
          <source>Before going further into template-driven forms, you should have a basic understanding of the following.</source>
          <target state="translated">템플릿 기반 양식으로 이동하기 전에 다음 사항에 대한 기본적인 이해가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="39ea417f7b18f1f328e8e078cd323d7e7c780e6b" translate="yes" xml:space="preserve">
          <source>Before going into the source structure, the next section shows how to fill out the HTML &lt;em&gt;template&lt;/em&gt; for the product list, using the provided sample data. This should give you an idea how easy it is to modify and update the page dynamically.</source>
          <target state="translated">소스 구조로 이동하기 전에 다음 섹션에서는 제공된 샘플 데이터를 사용하여 제품 목록에 대한 HTML &lt;em&gt;템플릿&lt;/em&gt; 을 작성하는 방법을 보여줍니다 . 이렇게하면 페이지를 동적으로 수정하고 업데이트하는 것이 얼마나 쉬운 지 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bc7b12fb67f6014a2a594cc0af99c3d142d39db" translate="yes" xml:space="preserve">
          <source>Before learning template syntax, you should be familiar with the following:</source>
          <target state="translated">템플릿 구문을 배우기 전에 다음 사항을 숙지해야합니다.</target>
        </trans-unit>
        <trans-unit id="70ee43513c9f4b63eb3ac4252e5589a69d05feb0" translate="yes" xml:space="preserve">
          <source>Before publishing a library to NPM, build it using the &lt;code&gt;--prod&lt;/code&gt; flag which will use the older compiler and runtime known as View Engine instead of Ivy.</source>
          <target state="translated">라이브러리를 NPM에 게시하기 전에 Ivy 대신 View Engine으로 알려진 이전 컴파일러 및 런타임을 사용하는 &lt;code&gt;--prod&lt;/code&gt; 플래그를 사용하여 라이브러리를 빌드하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d610fad0d4a841b5b934aeb1045f3ad689f743a" translate="yes" xml:space="preserve">
          <source>Before reading about form validation, you should have a basic understanding of the following.</source>
          <target state="translated">양식 유효성 검사에 대해 읽기 전에 다음 사항에 대한 기본적인 이해가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="31ade65586fac3f6c67ae72205b4dfe90fd2d49b" translate="yes" xml:space="preserve">
          <source>Before updating the &lt;code&gt;app-routing.module.ts&lt;/code&gt;, you'll need to consider an important rule. Currently, our empty path route redirects to &lt;code&gt;/heroes&lt;/code&gt;, which redirects to &lt;code&gt;/superheroes&lt;/code&gt;. This &lt;em&gt;won't&lt;/em&gt; work and is by design as the &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; handles redirects once at each level of routing configuration. This prevents chaining of redirects, which can lead to endless redirect loops.</source>
          <target state="translated">&lt;code&gt;app-routing.module.ts&lt;/code&gt; 를 업데이트하기 전에 중요한 규칙을 고려해야합니다. 현재 비어있는 경로 경로는 &lt;code&gt;/heroes&lt;/code&gt; 로 리디렉션되고 이는 &lt;code&gt;/superheroes&lt;/code&gt; 로 리디렉션됩니다 . 이 &lt;em&gt;되지 않습니다&lt;/em&gt; 작동과 같은 디자인입니다 &lt;code&gt;&lt;a href=&quot;../api/router/router&quot;&gt;Router&lt;/a&gt;&lt;/code&gt; 구성 라우팅의 각 단계에서 한 번 핸들 리디렉션. 이는 리디렉션 체인을 방지하여 무한 리디렉션 루프로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2adebd0eb41e8f1c544074f8aa1193608616af7e" translate="yes" xml:space="preserve">
          <source>Before using the &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; directive in a two-way data binding, you must import the &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; and add it to the NgModule's &lt;code&gt;imports&lt;/code&gt; list. Learn more about the &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; in &lt;a href=&quot;forms#ngModel&quot;&gt;Forms&lt;/a&gt;.</source>
          <target state="translated">사용하기 전에 &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 의 양방향 데이터 바인딩에 지시를, 당신은 가져와야합니다 &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; 을 하고 NgModule의에 추가 &lt;code&gt;imports&lt;/code&gt; 목록입니다. &lt;a href=&quot;forms#ngModel&quot;&gt;Forms&lt;/a&gt; 의 &lt;code&gt;&lt;a href=&quot;../api/forms/formsmodule&quot;&gt;FormsModule&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 에 대해 자세히 학습하십시오 .</target>
        </trans-unit>
        <trans-unit id="50199f21b3e8912b7bc32276a7bc2c2750704da6" translate="yes" xml:space="preserve">
          <source>Before working with lifecycle hooks, you should have a basic understanding of the following:</source>
          <target state="translated">수명주기 후크로 작업하기 전에 다음 사항에 대한 기본적인 이해가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c082dce0b08f61c3e4a5f8021cefd8d4ab1289e7" translate="yes" xml:space="preserve">
          <source>Before working with the &lt;code&gt;HTTPClientModule&lt;/code&gt;, you should have a basic understanding of the following:</source>
          <target state="translated">&lt;code&gt;HTTPClientModule&lt;/code&gt; 을 사용 하기 전에 다음 사항에 대한 기본적인 이해가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="cfeb39e482f633aad50966874d14d00ba4e281e9" translate="yes" xml:space="preserve">
          <source>Before writing tests for your Angular app, you should have a basic understanding of the following concepts:</source>
          <target state="translated">Angular 앱에 대한 테스트를 작성하기 전에 다음 개념에 대한 기본적인 이해가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="974b03fe0fa1d7a6ed31bea40eba5437fd1ccda1" translate="yes" xml:space="preserve">
          <source>Before you begin, make sure your development environment includes &lt;code&gt;Node.js&amp;reg;&lt;/code&gt; and an npm package manager.</source>
          <target state="translated">시작하기 전에 개발 환경에 &lt;code&gt;Node.js&amp;reg;&lt;/code&gt; 및 npm 패키지 관리자가 포함되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="919d29e47188004264e245ab74f85d9fecbc4581" translate="yes" xml:space="preserve">
          <source>Before you can add components you have to define an anchor point to tell Angular where to insert components.</source>
          <target state="translated">컴포넌트를 추가하기 전에 컴포넌트를 삽입 할 위치를 Angular에 알려주는 앵커 포인트를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="d407fa25385c1b1dc197a82d6a0637678cc33a4a" translate="yes" xml:space="preserve">
          <source>Before you can use &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt;, you need to import the Angular &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt;. Most apps do so in the root &lt;code&gt;AppModule&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 를 사용하기 전에 Angular &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt; 을 가져와야합니다 . 대부분의 앱은 루트 &lt;code&gt;AppModule&lt;/code&gt; 에서 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="41aa0ac3fdb9b01b90db0924c5bc2b5cb4b0c80e" translate="yes" xml:space="preserve">
          <source>Before you can use Angular's HTTP client, you must configure your app to use &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Angular의 HTTP 클라이언트를 사용하려면 먼저 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt; 을 사용하도록 앱을 구성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b7480739e4d2bfb1b2c1291af6d204a69a044469" translate="yes" xml:space="preserve">
          <source>Before you can use Angular's HTTP client, you must set up your app to use &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Angular의 HTTP 클라이언트를 사용하기 전에 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt; 을 사용하도록 앱을 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="72fa1b5683e2296972d6d0e97ba335789c635353" translate="yes" xml:space="preserve">
          <source>Before you can use the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt;, you need to import the Angular &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt;. Most apps do so in the root &lt;code&gt;AppModule&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; 를 사용 하려면 Angular &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclientmodule&quot;&gt;HttpClientModule&lt;/a&gt;&lt;/code&gt; 을 가져와야합니다 . 대부분의 앱은 루트 &lt;code&gt;AppModule&lt;/code&gt; 에서 그렇게합니다 .</target>
        </trans-unit>
        <trans-unit id="842beb51ca9c5417a27f472386d0e0d52dcc074f" translate="yes" xml:space="preserve">
          <source>Before:</source>
          <target state="translated">Before:</target>
        </trans-unit>
        <trans-unit id="ce372ed4595d7ee7562947bc03d901bf1fa43b3a" translate="yes" xml:space="preserve">
          <source>Begin a main section heading with the markdown &lt;code&gt;##&lt;/code&gt; characters. Alternatively, you can write the equivalent &lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt; HTML tag.</source>
          <target state="translated">마크 다운 &lt;code&gt;##&lt;/code&gt; 문자 로 기본 섹션 제목을 시작하십시오 . 또는 동등한 &lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt; HTML 태그를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="77b54c71ffe46696eb1cabec8c578b7430387d98" translate="yes" xml:space="preserve">
          <source>Begin a secondary heading with the markdown &lt;code&gt;###&lt;/code&gt; characters. Alternatively, you can write the equivalent &lt;code&gt;&amp;lt;h3&amp;gt;&lt;/code&gt; HTML tag.</source>
          <target state="translated">마크 다운 &lt;code&gt;###&lt;/code&gt; 문자 로 보조 제목을 시작하십시오 . 또는 동등한 &lt;code&gt;&amp;lt;h3&amp;gt;&lt;/code&gt; HTML 태그를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68ffa95f663f190607f3c471b59d100f255b0429" translate="yes" xml:space="preserve">
          <source>Begin by adding &lt;code&gt;&lt;a href=&quot;../api/core/hostlistener&quot;&gt;HostListener&lt;/a&gt;&lt;/code&gt; to the list of imported symbols.</source>
          <target state="translated">가져온 심볼 목록에 &lt;code&gt;&lt;a href=&quot;../api/core/hostlistener&quot;&gt;HostListener&lt;/a&gt;&lt;/code&gt; 를 추가하여 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d5d9a6ea323fdd57d9e1215bac5a83bb80d88b5" translate="yes" xml:space="preserve">
          <source>Begin by adding &lt;code&gt;&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; to the list of symbols imported from &lt;code&gt;@angular/core&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@angular/core&lt;/code&gt; 에서 가져온 심볼 목록에 &lt;code&gt;&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; 을 추가하여 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="c07371f1cc4e4d389c0f8860f26b0137449c4516" translate="yes" xml:space="preserve">
          <source>Begin by imitating the heroes feature:</source>
          <target state="translated">영웅 기능을 모방하여 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="eee54c68da088a30ccd7f437a9e53e1b0bb1026c" translate="yes" xml:space="preserve">
          <source>Begin by installing TypeScript to the project.</source>
          <target state="translated">프로젝트에 TypeScript를 설치하여 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="c985c7dda4282902d2451041dfd2a01b559349f8" translate="yes" xml:space="preserve">
          <source>Begin by putting re-usable, preparatory code in a &lt;em&gt;setup&lt;/em&gt; function instead of &lt;code&gt;beforeEach()&lt;/code&gt;.</source>
          <target state="translated">재사용 가능한 예비 코드 를 &lt;code&gt;beforeEach()&lt;/code&gt; 대신 &lt;em&gt;설정&lt;/em&gt; 함수 에 넣는 것으로 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed8e17d942d58d6ace8c56724dbb3f4cb3ceab40" translate="yes" xml:space="preserve">
          <source>Begin with a basic version of the app that navigates between two empty views.</source>
          <target state="translated">두 개의 빈보기 사이를 탐색하는 기본 버전의 앱으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="9dc6969f62da20a6afb1f322ebadb8b41abaac3c" translate="yes" xml:space="preserve">
          <source>Begin with a simple version of the app that navigates between two empty views.</source>
          <target state="translated">두 개의 빈 뷰 사이를 탐색하는 간단한 버전의 앱으로 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="d6548854aa27000232e1d1aba5f49a3acb40b7ae" translate="yes" xml:space="preserve">
          <source>Begin with the first form of data binding&amp;mdash;interpolation&amp;mdash;to see how much richer template HTML can be.</source>
          <target state="translated">템플릿 HTML이 얼마나 풍부한 지 확인하려면 첫 번째 데이터 바인딩 형식 인 보간으로 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="592d6d7c575706de86d4d071fdf75790be29837c" translate="yes" xml:space="preserve">
          <source>Beginning with Angular 6.0, the preferred way to create a singleton service is to set &lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;root&lt;/code&gt; on the service's &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; decorator. This tells Angular to provide the service in the application root.</source>
          <target state="translated">Angular 6.0부터는 싱글 톤 서비스를 만드는 가장 좋은 방법은 &lt;code&gt;&lt;a href=&quot;../api/core/injectable#providedIn&quot;&gt;providedIn&lt;/a&gt;&lt;/code&gt; 을 서비스의 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt; () 데코레이터 에서 &lt;code&gt;root&lt;/code&gt; 로 설정 하는 것 입니다. 이것은 Angular에게 응용 프로그램 루트에서 서비스를 제공하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="d0385b0bf87c6f88582259958a9f27bfb7f3be7f" translate="yes" xml:space="preserve">
          <source>Beginning with Angular 6.0, the preferred way to create a singleton service is to set &lt;code&gt;providedIn&lt;/code&gt; to &lt;code&gt;root&lt;/code&gt; on the service's &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; decorator. This tells Angular to provide the service in the application root.</source>
          <target state="translated">Angular 6.0부터 싱글 톤 서비스를 만드는 데 선호되는 방법 은 서비스의 &lt;code&gt;@&lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt;()&lt;/code&gt; &lt;a href=&quot;../api/core/injectable&quot;&gt;Injectable&lt;/a&gt; () 데코레이터 에서 &lt;code&gt;providedIn&lt;/code&gt; 을 &lt;code&gt;root&lt;/code&gt; 로 설정 하는 것 입니다. 이것은 Angular에게 애플리케이션 루트에서 서비스를 제공하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="3b66259b5d10f5e4dfd17260980e9448c27c8990" translate="yes" xml:space="preserve">
          <source>Behind the scenes, Angular creates a new control for each input element, provided you have set up a &lt;code&gt;name&lt;/code&gt; attribute and two-way binding for each input.</source>
          <target state="translated">씬 뒤에는 각 입력에 대해 &lt;code&gt;name&lt;/code&gt; 속성과 양방향 바인딩을 설정 한 경우 Angular가 각 입력 요소에 대한 새 컨트롤을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="f1577aef7d5c90af9c045dcc7b86cbeeacf9fc65" translate="yes" xml:space="preserve">
          <source>Behind the scenes, Angular sets the &lt;code&gt;logger&lt;/code&gt; parameter to the full service registered under the &lt;code&gt;LoggingService&lt;/code&gt; token, which happens to be the &lt;code&gt;DateLoggerService&lt;/code&gt; instance that was &lt;a href=&quot;dependency-injection-in-action#useclass&quot;&gt;provided above&lt;/a&gt;.</source>
          <target state="translated">장면 뒤에서 Angular는 &lt;code&gt;logger&lt;/code&gt; 매개 변수를 &lt;code&gt;LoggingService&lt;/code&gt; 토큰에 등록 된 전체 서비스로 설정합니다.이 서비스 는 &lt;a href=&quot;dependency-injection-in-action#useclass&quot;&gt;위에 제공된 &lt;/a&gt; &lt;code&gt;DateLoggerService&lt;/code&gt; 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="e82af82e7e882e82e6f17fc0109858d570cb6fa5" translate="yes" xml:space="preserve">
          <source>Behind the scenes, each component sets up its own injector with zero, one, or more providers defined for that component itself.</source>
          <target state="translated">배후에서 각 구성 요소는 해당 구성 요소 자체에 대해 0 개, 하나 이상의 공급자가 정의 된 자체 인젝터를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f1b2830245d3e2ff98c8e67a5f1a960600c64153" translate="yes" xml:space="preserve">
          <source>Behind this behavior is the router's &lt;code&gt;&lt;a href=&quot;../api/router/candeactivate&quot;&gt;CanDeactivate&lt;/a&gt;&lt;/code&gt; guard. The guard gives you a chance to clean-up or ask the user's permission before navigating away from the current view.</source>
          <target state="translated">이 동작 뒤에는 라우터의 &lt;code&gt;&lt;a href=&quot;../api/router/candeactivate&quot;&gt;CanDeactivate&lt;/a&gt;&lt;/code&gt; 가드가 있습니다. 가드는 현재보기에서 벗어나기 전에 정리하거나 사용자의 권한을 요청할 수있는 기회를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3a5f33c6e631fd4b9b6828f4a98022745cdde1db" translate="yes" xml:space="preserve">
          <source>Below is the &quot;Little Tour of Heroes&quot; component.</source>
          <target state="translated">아래는 &quot;Little Tour of Heroes&quot;구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="a6d54f04eb5f64dea38939b332ee485453c0ed14" translate="yes" xml:space="preserve">
          <source>Below is the content of our example &lt;code&gt;select&lt;/code&gt; ICU expression in the component template:</source>
          <target state="translated">다음은 컴포넌트 템플릿에서 예제 &lt;code&gt;select&lt;/code&gt; ICU expression 의 내용입니다 .</target>
        </trans-unit>
        <trans-unit id="4e0f6ab73f39d0ec2a1809d528963c447a13f3b6" translate="yes" xml:space="preserve">
          <source>Below it add an HTML unordered list (&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">아래에 HTML 비 순차 목록 ( &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; )을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="b84a1be2c29811cc7905b853f73dea56408133ea" translate="yes" xml:space="preserve">
          <source>Below the &lt;code&gt;clearCart()&lt;/code&gt; method, define a new &lt;code&gt;getShippingPrices()&lt;/code&gt; method that uses the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;#get()&lt;/code&gt; method to retrieve the shipping data (types and prices).</source>
          <target state="translated">&lt;code&gt;clearCart()&lt;/code&gt; 메소드 아래에서 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;#get()&lt;/code&gt; #get () 메소드를 사용하여 운송 데이터 (유형 및 가격)를 검색 하는 새 &lt;code&gt;getShippingPrices()&lt;/code&gt; 메소드를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="c876a01df6b2f0af560f30fe53ac86ce42ab2d2c" translate="yes" xml:space="preserve">
          <source>Below the &lt;code&gt;clearCart()&lt;/code&gt; method, define a new &lt;code&gt;getShippingPrices()&lt;/code&gt; method that uses the &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt;&lt;code&gt;get()&lt;/code&gt; method to retrieve the shipping data.</source>
          <target state="translated">&lt;code&gt;clearCart()&lt;/code&gt; 메서드 아래에서 &lt;code&gt;&lt;a href=&quot;../api/common/http/httpclient&quot;&gt;HttpClient&lt;/a&gt;&lt;/code&gt; &lt;code&gt;get()&lt;/code&gt; 메서드를 사용하여 배송 데이터를 검색 하는 새로운 &lt;code&gt;getShippingPrices()&lt;/code&gt; 메서드를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="4134985fe5ce5666849835575205259905697417" translate="yes" xml:space="preserve">
          <source>Benefits of a routing module</source>
          <target state="translated">라우팅 모듈의 이점</target>
        </trans-unit>
        <trans-unit id="8cc0379f41ff0ba0e46288baf9de039b96b071ca" translate="yes" xml:space="preserve">
          <source>Besides their different API, there are two important internal differences between &lt;code&gt;&lt;a href=&quot;downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; that affect the behavior of hybrid applications:</source>
          <target state="translated">서로 다른 API 외에도 하이브리드 애플리케이션의 동작에 영향을주는 &lt;code&gt;&lt;a href=&quot;downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;upgrademodule&quot;&gt;UpgradeModule&lt;/a&gt;&lt;/code&gt; 사이에는 두 가지 중요한 내부 차이점 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1aebe50f6c72461f39b5c56140bf2bf0b673fa65" translate="yes" xml:space="preserve">
          <source>Besides using the CLI on the command line, you can also manipulate files directly in the app's source folder and configuration files.</source>
          <target state="translated">명령 줄에서 CLI를 사용하는 것 외에도 앱의 소스 폴더 및 구성 파일에서 직접 파일을 조작 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9faf878af4c349c49c9509b240e538390447757b" translate="yes" xml:space="preserve">
          <source>Besides using the CLI on the command line, you can also use an interactive development environment like &lt;a href=&quot;https://angularconsole.com/&quot;&gt;Angular Console&lt;/a&gt;, or manipulate files directly in the app's source folder and configuration files.</source>
          <target state="translated">명령 행에서 CLI를 사용하는 것 외에도 &lt;a href=&quot;https://angularconsole.com/&quot;&gt;Angular Console&lt;/a&gt; 과 같은 대화식 개발 환경을 사용 하거나 앱의 소스 폴더 및 구성 파일에서 직접 파일을 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb8de9ce8757ee3c542141ac80ff3b33dc04edff" translate="yes" xml:space="preserve">
          <source>Best practices</source>
          <target state="translated">모범 사례</target>
        </trans-unit>
        <trans-unit id="9ff1983a50453d1cae8d9a5eebf8b44e9ceb723c" translate="yes" xml:space="preserve">
          <source>Better developer ergonomics with strict typing for &lt;code&gt;@angular/forms&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@angular/forms&lt;/code&gt; 대한 엄격한 타이핑을 통해 더 나은 개발자 인체 공학</target>
        </trans-unit>
        <trans-unit id="82ef826d9fb859d576a0907d18d1a66926bd8669" translate="yes" xml:space="preserve">
          <source>Beyond that, you may interleave the two frameworks. You always cross the boundary between the two frameworks by one of two ways:</source>
          <target state="translated">그 외에도 두 프레임 워크를 인터리브 할 수 있습니다. 두 프레임 워크 사이의 경계를 항상 두 가지 방법 중 하나로 교차합니다.</target>
        </trans-unit>
        <trans-unit id="16d85a9f9536bdb143337018c722df8b0f3c81b3" translate="yes" xml:space="preserve">
          <source>Bind component methods to user events, like keystrokes and clicks.</source>
          <target state="translated">키 입력 및 클릭과 같은 구성 요소 메소드를 사용자 이벤트에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="5e9e55d218847019581b70053a614ddd2a5a9018" translate="yes" xml:space="preserve">
          <source>Bind data properties to each form control using the &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; two-way data-binding syntax.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 양방향 데이터 바인딩 구문을 사용하여 각 폼 컨트롤에 데이터 속성을 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="e0ff0b03776800840d9030209136719fe8494575" translate="yes" xml:space="preserve">
          <source>Bind form controls to data properties using the &lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; directive and two-way data-binding syntax.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/forms/ngmodel&quot;&gt;ngModel&lt;/a&gt;&lt;/code&gt; 지시문 및 양방향 데이터 바인딩 구문을 사용하여 양식 컨트롤을 데이터 속성 에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="33154f63694b74d4827c50175132e4f395023e05" translate="yes" xml:space="preserve">
          <source>Bind input controls to data properties</source>
          <target state="translated">입력 컨트롤을 데이터 속성에 바인딩</target>
        </trans-unit>
        <trans-unit id="5f1cd87627492a075b5e1b02e1f2c3ff5fdc07ba" translate="yes" xml:space="preserve">
          <source>Bind the &lt;code&gt;HeroesComponent.selectedHero&lt;/code&gt; to the element's &lt;code&gt;hero&lt;/code&gt; property like this.</source>
          <target state="translated">&lt;code&gt;HeroesComponent.selectedHero&lt;/code&gt; 를 요소의 &lt;code&gt;hero&lt;/code&gt; 속성에 바인딩합니다 .</target>
        </trans-unit>
        <trans-unit id="cb518f94f4f55866c328e383a2856fb5473ed9a4" translate="yes" xml:space="preserve">
          <source>Bind the button's click event to a hero-creation method, &lt;code&gt;newHero()&lt;/code&gt;.</source>
          <target state="translated">버튼의 클릭 이벤트를 영웅 생성 메서드 &lt;code&gt;newHero()&lt;/code&gt; 바인딩합니다 .</target>
        </trans-unit>
        <trans-unit id="be1a38a295ddc34a08b0e541437a179ec69851e1" translate="yes" xml:space="preserve">
          <source>Bind the form's &lt;a href=&quot;../api/forms/ngform#properties&quot;&gt;&lt;code&gt;ngSubmit&lt;/code&gt;&lt;/a&gt; event property to the hero-form component's &lt;code&gt;onSubmit()&lt;/code&gt; method.</source>
          <target state="translated">양식의 &lt;a href=&quot;../api/forms/ngform#properties&quot;&gt; &lt;code&gt;ngSubmit&lt;/code&gt; &lt;/a&gt; 이벤트 속성을 hero-form 구성 요소의 &lt;code&gt;onSubmit()&lt;/code&gt; 메서드에 바인딩합니다 .</target>
        </trans-unit>
        <trans-unit id="b2792d4ffa16115ba7c001505491305b2d5c88f6" translate="yes" xml:space="preserve">
          <source>Bind to a second property</source>
          <target state="translated">두 번째 속성에 바인딩</target>
        </trans-unit>
        <trans-unit id="697a78adb0268f346f175f0419a81cb28cea06a1" translate="yes" xml:space="preserve">
          <source>Bind to an &lt;code&gt;@Input&lt;/code&gt; alias</source>
          <target state="translated">&lt;code&gt;@Input&lt;/code&gt; 별칭에 바인딩</target>
        </trans-unit>
        <trans-unit id="5662c554f6ba4f36018195821022c704fa19317c" translate="yes" xml:space="preserve">
          <source>Bind to the &lt;code&gt;MessageService&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;MessageService&lt;/code&gt; 에 바인딩</target>
        </trans-unit>
        <trans-unit id="9af2bb479915615a2ff7e67d9debd7fe3d47d969" translate="yes" xml:space="preserve">
          <source>Bind to the &lt;code&gt;click&lt;/code&gt; event</source>
          <target state="translated">&lt;code&gt;click&lt;/code&gt; 이벤트에 바인딩</target>
        </trans-unit>
        <trans-unit id="21c9dd5766d21c48bc079c417359f429b538c0e9" translate="yes" xml:space="preserve">
          <source>Bind to the &lt;code&gt;hidden&lt;/code&gt; property</source>
          <target state="translated">&lt;code&gt;hidden&lt;/code&gt; 속성에 바인딩</target>
        </trans-unit>
        <trans-unit id="f2a12bb43f4f20a3308c6e7f43110abc164b3cbe" translate="yes" xml:space="preserve">
          <source>Bind to the &lt;code&gt;href&lt;/code&gt; property</source>
          <target state="translated">&lt;code&gt;href&lt;/code&gt; 속성에 바인딩</target>
        </trans-unit>
        <trans-unit id="c50c22644a97886a75576f3ad55786f5139b6a3f" translate="yes" xml:space="preserve">
          <source>Bind to the &lt;code&gt;src&lt;/code&gt; property</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 속성에 바인딩</target>
        </trans-unit>
        <trans-unit id="b5950f11f19abbc55748a4b766158ae890c0276e" translate="yes" xml:space="preserve">
          <source>Bind values between components</source>
          <target state="translated">구성 요소 간 값 바인딩</target>
        </trans-unit>
        <trans-unit id="47592223c16cb8585ef509e09353d7b2abfd8d49" translate="yes" xml:space="preserve">
          <source>Binding ARIA attributes</source>
          <target state="translated">ARIA 속성 바인딩</target>
        </trans-unit>
        <trans-unit id="9d134d09d5f4e94212c7d30c73cde26bde681995" translate="yes" xml:space="preserve">
          <source>Binding Type</source>
          <target state="translated">바인딩 유형</target>
        </trans-unit>
        <trans-unit id="0c74318c4ebf86394efdd83afd59fbdcebcf11b6" translate="yes" xml:space="preserve">
          <source>Binding definition</source>
          <target state="translated">바인딩 정의</target>
        </trans-unit>
        <trans-unit id="5839396aa9317f9099934df61297930a2f609f5a" translate="yes" xml:space="preserve">
          <source>Binding expressions in the template that refer to properties of &lt;code&gt;selectedHero&lt;/code&gt;&amp;mdash;expressions like &lt;code&gt;{{selectedHero.name}}&lt;/code&gt;&amp;mdash;&lt;em&gt;must fail&lt;/em&gt; because there is no selected hero.</source>
          <target state="translated">의 특성을 참조 템플릿의 표현 바인딩 &lt;code&gt;selectedHero&lt;/code&gt; 의 같은 -expressions을 &lt;code&gt;{{selectedHero.name}}&lt;/code&gt; - &lt;em&gt;실패한다&lt;/em&gt; 어떤 선택 영웅이 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1893c99928000b73c034f5d13d20f170b63a568e" translate="yes" xml:space="preserve">
          <source>Binding happens when Angular performs &lt;strong&gt;change detection&lt;/strong&gt;.</source>
          <target state="translated">바인딩은 Angular가 &lt;strong&gt;변경 감지를&lt;/strong&gt; 수행 할 때 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="7bd59c5a7fe5f05639190e405278fb2261e77836" translate="yes" xml:space="preserve">
          <source>Binding syntax</source>
          <target state="translated">바인딩 구문</target>
        </trans-unit>
        <trans-unit id="9f17435a7231c370dd9b277051fa279efb03be5c" translate="yes" xml:space="preserve">
          <source>Binding syntax: an overview</source>
          <target state="translated">바인딩 구문 : 개요</target>
        </trans-unit>
        <trans-unit id="d5647a339d9f5d3f491fea7dce9161e510086700" translate="yes" xml:space="preserve">
          <source>Binding targets</source>
          <target state="translated">바인딩 대상</target>
        </trans-unit>
        <trans-unit id="a982e338e15a591ad314d19385a8465d3771cb08" translate="yes" xml:space="preserve">
          <source>Binding to &lt;code&gt;colspan&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;colspan&lt;/code&gt; 에 바인딩</target>
        </trans-unit>
        <trans-unit id="f1cd0d1adc0c5198881b5fa4d0d0d93ed50065f6" translate="yes" xml:space="preserve">
          <source>Binding to &lt;code&gt;innerText&lt;/code&gt; in &lt;code&gt;platform-server&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;platform-server&lt;/code&gt; 에서 &lt;code&gt;innerText&lt;/code&gt; 에 바인딩</target>
        </trans-unit>
        <trans-unit id="b2e5336d4d941fc97797cbe0832ef02f3f640bb9" translate="yes" xml:space="preserve">
          <source>Binding to a property</source>
          <target state="translated">속성에 바인딩</target>
        </trans-unit>
        <trans-unit id="4e9cfb8a8abcf1aa0ba62678633b4cd778b8d7a0" translate="yes" xml:space="preserve">
          <source>Binding to a single CSS &lt;code&gt;class&lt;/code&gt;</source>
          <target state="translated">단일 CSS &lt;code&gt;class&lt;/code&gt; 바인딩</target>
        </trans-unit>
        <trans-unit id="9b65098a59c5ee8b6c9dabf70ba5b3148fe25310" translate="yes" xml:space="preserve">
          <source>Binding to a single style</source>
          <target state="translated">단일 스타일에 바인딩</target>
        </trans-unit>
        <trans-unit id="41bde9dd651e82f521b541fdc41775c9aa970888" translate="yes" xml:space="preserve">
          <source>Binding to an &lt;code&gt;@Input&lt;/code&gt; property</source>
          <target state="translated">&lt;code&gt;@Input&lt;/code&gt; 속성에 바인딩</target>
        </trans-unit>
        <trans-unit id="3f2e69830b8c0be6838669447ee2c213786fcbf8" translate="yes" xml:space="preserve">
          <source>Binding to an attribute</source>
          <target state="translated">속성에 바인딩</target>
        </trans-unit>
        <trans-unit id="cb97ee066e6802a64304ae39dded8ff71691fa30" translate="yes" xml:space="preserve">
          <source>Binding to events</source>
          <target state="translated">이벤트에 바인딩</target>
        </trans-unit>
        <trans-unit id="caf6b7d4e34b730bb276803588b70b02e34630e3" translate="yes" xml:space="preserve">
          <source>Binding to multiple CSS classes</source>
          <target state="translated">여러 CSS 클래스에 바인딩</target>
        </trans-unit>
        <trans-unit id="2fa96d5fd278e78320d12bff2da7f173c23bea10" translate="yes" xml:space="preserve">
          <source>Binding to multiple styles</source>
          <target state="translated">여러 스타일에 바인딩</target>
        </trans-unit>
        <trans-unit id="49966c759fad1cab8449cbae782ea4be4768a782" translate="yes" xml:space="preserve">
          <source>Binding to the &lt;code&gt;class&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 속성에 바인딩</target>
        </trans-unit>
        <trans-unit id="2903fdce986b4bc5dc0928e7c935dc3e839d92fa" translate="yes" xml:space="preserve">
          <source>Binding to the style attribute</source>
          <target state="translated">스타일 속성에 바인딩</target>
        </trans-unit>
        <trans-unit id="1008f5e8313e01e8a35aaef1612e93ffb2fdf201" translate="yes" xml:space="preserve">
          <source>Binding to user input events</source>
          <target state="translated">사용자 입력 이벤트에 바인딩</target>
        </trans-unit>
        <trans-unit id="a0900669bf69957ea18b3c6bc31b0c068974fb65" translate="yes" xml:space="preserve">
          <source>Binding types and targets</source>
          <target state="translated">바인딩 유형 및 대상</target>
        </trans-unit>
        <trans-unit id="3d8a515e1c9d4c4474858b033088bbcd501cde60" translate="yes" xml:space="preserve">
          <source>Binding types other than interpolation have a &lt;strong&gt;target name&lt;/strong&gt; to the left of the equal sign, either surrounded by punctuation, &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;()&lt;/code&gt;, or preceded by a prefix: &lt;code&gt;bind-&lt;/code&gt;, &lt;code&gt;on-&lt;/code&gt;, &lt;code&gt;bindon-&lt;/code&gt;.</source>
          <target state="translated">보간 이외의 바인딩 유형이있는 &lt;strong&gt;대상 이름&lt;/strong&gt; 어느 구두점 둘러싸인 등호 좌측에, &lt;code&gt;[]&lt;/code&gt; 또는 &lt;code&gt;()&lt;/code&gt; , 또는 프리픽스 앞에 : &lt;code&gt;bind-&lt;/code&gt; , &lt;code&gt;on-&lt;/code&gt; , &lt;code&gt;bindon-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9489430053bbe362e29d4adc605c0ee490984678" translate="yes" xml:space="preserve">
          <source>Bindings/interpolation</source>
          <target state="translated">Bindings/interpolation</target>
        </trans-unit>
        <trans-unit id="c5508d22bc8524cbfc21537e7df0e0da3d89023d" translate="yes" xml:space="preserve">
          <source>Bindings:</source>
          <target state="translated">Bindings:</target>
        </trans-unit>
        <trans-unit id="6fdec0a2d226423ce21951dc8d539e2b83505cca" translate="yes" xml:space="preserve">
          <source>Binds a host element property (here, the CSS class &lt;code&gt;valid&lt;/code&gt;) to a directive/component property (&lt;code&gt;isValid&lt;/code&gt;).</source>
          <target state="translated">호스트 요소 속성 (여기서는 CSS 클래스 &lt;code&gt;valid&lt;/code&gt; )을 지시문 / 구성 요소 속성 ( &lt;code&gt;isValid&lt;/code&gt; )에 바인딩합니다 .</target>
        </trans-unit>
        <trans-unit id="2a03f296a2db9a927b9dbda94190effddfbe9a35" translate="yes" xml:space="preserve">
          <source>Binds a property to an interpolated string, for example, &quot;Hello Seabiscuit&quot;. Equivalent to: &lt;code&gt;&amp;lt;div [title]=&quot;'Hello ' + ponyName&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">보간 된 문자열 (예 : &quot;Hello Seabiscuit&quot;)에 속성을 바인딩합니다. 당량 : &lt;code&gt;&amp;lt;div [title]=&quot;'Hello ' + ponyName&quot;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d7ccc5ce4a07981d8fbbdb0cd830cbe571385e3" translate="yes" xml:space="preserve">
          <source>Binds an existing &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; to a DOM element.</source>
          <target state="translated">기존 &lt;code&gt;&lt;a href=&quot;formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 을 DOM 요소에 바인딩합니다 .</target>
        </trans-unit>
        <trans-unit id="9ccd1d736a8432535c2d3c15a12d59d85c60d529" translate="yes" xml:space="preserve">
          <source>Binds an existing &lt;code&gt;&lt;a href=&quot;forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; to a DOM element.</source>
          <target state="translated">기존 &lt;code&gt;&lt;a href=&quot;forms/formgroup&quot;&gt;FormGroup&lt;/a&gt;&lt;/code&gt; 을 DOM 요소에 바인딩합니다 .</target>
        </trans-unit>
        <trans-unit id="16fe924da3cac78aab1564f33684600fc3e54d31" translate="yes" xml:space="preserve">
          <source>Binds attribute &lt;code&gt;role&lt;/code&gt; to the result of expression &lt;code&gt;myAriaRole&lt;/code&gt;.</source>
          <target state="translated">속성 &lt;code&gt;role&lt;/code&gt; 을 &lt;code&gt;myAriaRole&lt;/code&gt; 표현식의 결과에 바인딩 합니다.</target>
        </trans-unit>
        <trans-unit id="f54affac6186ad384ce54918e8587b01c740b31d" translate="yes" xml:space="preserve">
          <source>Binds property &lt;code&gt;value&lt;/code&gt; to the result of expression &lt;code&gt;firstName&lt;/code&gt;.</source>
          <target state="translated">특성 &lt;code&gt;value&lt;/code&gt; 을 표현식 &lt;code&gt;firstName&lt;/code&gt; 의 결과에 바인드합니다 .</target>
        </trans-unit>
        <trans-unit id="f28cdf8e45d544332ba50c27586202007f4d2bd8" translate="yes" xml:space="preserve">
          <source>Binds style property &lt;code&gt;width&lt;/code&gt; to the result of expression &lt;code&gt;mySize&lt;/code&gt; in pixels. Units are optional.</source>
          <target state="translated">스타일 특성 &lt;code&gt;width&lt;/code&gt; 를 &lt;code&gt;mySize&lt;/code&gt; 표현식의 결과 에 픽셀로 바인딩 합니다. 단위는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="17a444202922e95677dbac286aa416c23efd0983" translate="yes" xml:space="preserve">
          <source>Binds text content to an interpolated string, for example, &quot;Hello Seabiscuit&quot;.</source>
          <target state="translated">텍스트 내용을 보간 된 문자열 (예 : &quot;Hello Seabiscuit&quot;)에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="8a53a7d5df799e913a7ec437d4dd501a26095ee7" translate="yes" xml:space="preserve">
          <source>Binds the first result of the component content query (&lt;code&gt;myPredicate&lt;/code&gt;) to a property (&lt;code&gt;myChildComponent&lt;/code&gt;) of the class.</source>
          <target state="translated">컴포넌트 컨텐츠 쿼리 ( &lt;code&gt;myPredicate&lt;/code&gt; ) 의 첫 번째 결과를 특성 ( &lt;code&gt;myChildComponent&lt;/code&gt; )에 바인딩합니다. 클래스 )에 합니다.</target>
        </trans-unit>
        <trans-unit id="d462ed51c89027f3d448e6304b58618b5f4dc0bb" translate="yes" xml:space="preserve">
          <source>Binds the first result of the component view query (&lt;code&gt;myPredicate&lt;/code&gt;) to a property (&lt;code&gt;myChildComponent&lt;/code&gt;) of the class. Not available for directives.</source>
          <target state="translated">컴포넌트 뷰 쿼리 ( &lt;code&gt;myPredicate&lt;/code&gt; ) 의 첫 번째 결과를 클래스 의 특성 ( &lt;code&gt;myChildComponent&lt;/code&gt; )에 바인딩 합니다. 지시문에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0e092be7e1c05ee4dd0e489bb77875249aed43ca" translate="yes" xml:space="preserve">
          <source>Binds the presence of CSS classes on the element to the truthiness of the associated map values. The right-hand expression should return {class-name: true/false} map.</source>
          <target state="translated">요소에 CSS 클래스의 존재를 연관된 맵 값의 진실성에 바인딩합니다. 오른쪽 표현식은 {class-name : true / false} 맵을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="671bb5d878441fb7fa959c57f931fb9e81582167" translate="yes" xml:space="preserve">
          <source>Binds the presence of the CSS class &lt;code&gt;extra-sparkle&lt;/code&gt; on the element to the truthiness of the expression &lt;code&gt;isDelightful&lt;/code&gt;.</source>
          <target state="translated">CSS 클래스의 존재를 요소에 &lt;code&gt;extra-sparkle&lt;/code&gt; 스파클링하여 isDelightful 표현식의 &lt;code&gt;isDelightful&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="a75de65e1c312de631f318f4e7d379f7e3b0db7e" translate="yes" xml:space="preserve">
          <source>Binds the results of the component content query (&lt;code&gt;myPredicate&lt;/code&gt;) to a property (&lt;code&gt;myChildComponents&lt;/code&gt;) of the class.</source>
          <target state="translated">컴포넌트 컨텐츠 쿼리 ( &lt;code&gt;myPredicate&lt;/code&gt; ) 결과를 클래스 의 특성 ( &lt;code&gt;myChildComponents&lt;/code&gt; )에 바인딩 합니다.</target>
        </trans-unit>
        <trans-unit id="2153c3e38b198c59245e2713a80794aac2809840" translate="yes" xml:space="preserve">
          <source>Binds the results of the component view query (&lt;code&gt;myPredicate&lt;/code&gt;) to a property (&lt;code&gt;myChildComponents&lt;/code&gt;) of the class. Not available for directives.</source>
          <target state="translated">컴포넌트 뷰 쿼리 ( &lt;code&gt;myPredicate&lt;/code&gt; ) 의 결과를 클래스 의 특성 ( &lt;code&gt;myChildComponents&lt;/code&gt; )에 바인딩 합니다. 지시문에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c24315eb20cc1f5a565ec08f29abab31c0925f1a" translate="yes" xml:space="preserve">
          <source>Blob</source>
          <target state="translated">Blob</target>
        </trans-unit>
        <trans-unit id="226ebb87480ef673fc8c86d3504690e25d113738" translate="yes" xml:space="preserve">
          <source>Bodies are not enforced to be immutable, as they can include a reference to any user-defined data type. However, interceptors should take care to preserve idempotence by treating them as such.</source>
          <target state="translated">본문은 사용자 정의 데이터 형식에 대한 참조를 포함 할 수 있으므로 변경 불가능합니다. 그러나 인터셉터는 dem 등식을 보존하여 dem 등식을 보존해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a7fdd8c17425252332ea0e89a35722b72d83135" translate="yes" xml:space="preserve">
          <source>Books</source>
          <target state="translated">Books</target>
        </trans-unit>
        <trans-unit id="af107074fdc94049367385cfa9e21226f2eb6a09" translate="yes" xml:space="preserve">
          <source>Boolean (marked deprecated in v5): &lt;code&gt;true&lt;/code&gt; for symbol and false for &lt;code&gt;code&lt;/code&gt;.</source>
          <target state="translated">부울 (v5에서 더 이상 사용되지 않음으로 표시됨) : symbol의 &lt;code&gt;true&lt;/code&gt; 이고 &lt;code&gt;code&lt;/code&gt; 의 경우 false입니다 .</target>
        </trans-unit>
        <trans-unit id="b4ee3c164f30fd674db7923067c5585c6016a895" translate="yes" xml:space="preserve">
          <source>Boolean and enumerated options</source>
          <target state="translated">부울 및 열거 옵션</target>
        </trans-unit>
        <trans-unit id="ee3701cfb07b487ff0074c548b7c853abc094675" translate="yes" xml:space="preserve">
          <source>Boolean options have two forms: &lt;code&gt;--thisOption&lt;/code&gt; sets the flag, &lt;code&gt;--noThisOption&lt;/code&gt; clears it. If neither option is supplied, the flag remains in its default state, as listed in the reference documentation.</source>
          <target state="translated">부울 옵션은 두 가지 형태가 있습니다 &lt;code&gt;--thisOption&lt;/code&gt; 이 플래그를 설정하고, &lt;code&gt;--noThisOption&lt;/code&gt; 을 지 웁니다. 옵션이 제공되지 않으면 플래그는 참조 문서에 나열된대로 기본 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="43aac281118e73bd2de105009d38e4c096ce545e" translate="yes" xml:space="preserve">
          <source>Boolean value matching</source>
          <target state="translated">부울 값 일치</target>
        </trans-unit>
        <trans-unit id="22cb4db816b227d666bef5f940023e6d431b8292" translate="yes" xml:space="preserve">
          <source>Boolean values in transitions</source>
          <target state="translated">전환의 부울 값</target>
        </trans-unit>
        <trans-unit id="89ec4ec2bf400e823f3ca49d0cb938b0fedd7bab" translate="yes" xml:space="preserve">
          <source>Bootstrap</source>
          <target state="translated">Bootstrap</target>
        </trans-unit>
        <trans-unit id="984a1c95ee8f803062739b46151930f8fcc64cc3" translate="yes" xml:space="preserve">
          <source>Bootstrap The runtime instance of this class contains a &lt;a href=&quot;upgrademodule#bootstrap&quot;&gt;`bootstrap()`&lt;/a&gt; method, which you use to bootstrap the top level AngularJS module onto an element in the DOM for the hybrid upgrade app.</source>
          <target state="translated">부트 스트랩이 클래스의 런타임 인스턴스에는 &lt;a href=&quot;upgrademodule#bootstrap&quot;&gt;`bootstrap ()`&lt;/a&gt; 메소드 가 포함되어 있는데 ,이 메소드는 최상위 AngularJS 모듈을 하이브리드 업그레이드 앱의 DOM 요소에 부트 스트랩하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b2bfe58675219a1dbbfc6b3475d2142be8257202" translate="yes" xml:space="preserve">
          <source>Bootstrap a hybrid AngularJS / Angular application.</source>
          <target state="translated">하이브리드 AngularJS / Angular 애플리케이션을 부트 스트랩합니다.</target>
        </trans-unit>
        <trans-unit id="51ee9ae036bd74ef9a86c64b16240b06c2a27ba8" translate="yes" xml:space="preserve">
          <source>Bootstrap a new component at the root level of the application.</source>
          <target state="translated">응용 프로그램의 루트 수준에서 새 구성 요소를 부트 스트랩합니다.</target>
        </trans-unit>
        <trans-unit id="e4a6b7f980306983d4418b9e062151bb02f12137" translate="yes" xml:space="preserve">
          <source>Bootstrap an AngularJS application from this NgModule</source>
          <target state="translated">이 NgModule에서 AngularJS 애플리케이션을 부트 스트랩</target>
        </trans-unit>
        <trans-unit id="c43ac6907ee5f49cf786f03c5183c92913a7be9f" translate="yes" xml:space="preserve">
          <source>Bootstrap process</source>
          <target state="translated">부트 스트랩 프로세스</target>
        </trans-unit>
        <trans-unit id="f816445d2cdd3ec11a7f0bc29a3553b746ba7f58" translate="yes" xml:space="preserve">
          <source>Bootstrap the &lt;code&gt;AppModule&lt;/code&gt; in &lt;code&gt;main.ts&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;main.ts&lt;/code&gt; 에서 &lt;code&gt;AppModule&lt;/code&gt; 을 부트 스트랩합니다 .</target>
        </trans-unit>
        <trans-unit id="a8e9582bb8e53711c79f2e9de1050077a16c41c3" translate="yes" xml:space="preserve">
          <source>Bootstrap the app with those providers.</source>
          <target state="translated">해당 공급자와 앱을 부트 스트랩합니다.</target>
        </trans-unit>
        <trans-unit id="09273e0b3502cd35874b01a3ba91c106f87a667f" translate="yes" xml:space="preserve">
          <source>Bootstrapping</source>
          <target state="translated">Bootstrapping</target>
        </trans-unit>
        <trans-unit id="5a7db5fc491694b2f101ec433ecf1bf5688abf3d" translate="yes" xml:space="preserve">
          <source>Bootstrapping a hybrid PhoneCat</source>
          <target state="translated">하이브리드 PhoneCat 부트 스트랩</target>
        </trans-unit>
        <trans-unit id="9aa9a98e544eb5606246801d9bd2a8d5e0833195" translate="yes" xml:space="preserve">
          <source>Bootstrapping hybrid applications</source>
          <target state="translated">부트 스트랩 하이브리드 애플리케이션</target>
        </trans-unit>
        <trans-unit id="09c0fece45f5112a211482199d5921f05490b2bf" translate="yes" xml:space="preserve">
          <source>Bootstrapping of a hybrid Angular application which contains both of the frameworks coexisting in a single application.</source>
          <target state="translated">단일 애플리케이션에 공존하는 두 프레임 워크를 모두 포함하는 하이브리드 Angular 애플리케이션의 부트 스트랩</target>
        </trans-unit>
        <trans-unit id="0ca02e3c0ffaf3a6883168e9851d5db6a98acc44" translate="yes" xml:space="preserve">
          <source>Bootstrapping with &lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/upgrade/static/downgrademodule&quot;&gt;downgradeModule&lt;/a&gt;()&lt;/code&gt; 사용한 부트 스트랩 ()</target>
        </trans-unit>
        <trans-unit id="be52c694b99b80c209e0ec9f6005df403bbc8030" translate="yes" xml:space="preserve">
          <source>Bootstraps the app, using the root component from the specified &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;&lt;a href=&quot;../api/core/ngmodule&quot;&gt;NgModule&lt;/a&gt;&lt;/code&gt; 의 루트 구성 요소를 사용하여 앱을 부트 스트랩합니다 .</target>
        </trans-unit>
        <trans-unit id="bc574769bfd4b0921435e1d96eebd017fb7655ce" translate="yes" xml:space="preserve">
          <source>Bootstraps the worker ui.</source>
          <target state="translated">작업자 UI를 부트 스트랩합니다.</target>
        </trans-unit>
        <trans-unit id="843c4cada239f4bc2cc6160b3122b53d22b9e4aa" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;ng build&lt;/code&gt; and &lt;code&gt;ng serve&lt;/code&gt; clear the output folder before they build the project, but only the &lt;code&gt;ng build&lt;/code&gt; command writes the generated build artifacts to the output folder.</source>
          <target state="translated">두 &lt;code&gt;ng build&lt;/code&gt; 및 &lt;code&gt;ng serve&lt;/code&gt; 가 프로젝트를 빌드하기 전에 출력 폴더를 삭제하지만, 단지 &lt;code&gt;ng build&lt;/code&gt; 명령은 출력 폴더에 생성 된 빌드 아티팩트를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="9ea4794ef24c179c732e4dbb95359c533623f529" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;npm&lt;/code&gt; and &lt;code&gt;yarn&lt;/code&gt; install the packages that are identified in a &lt;a href=&quot;https://docs.npmjs.com/files/package.json&quot;&gt;&lt;code&gt;package.json&lt;/code&gt;&lt;/a&gt; file.</source>
          <target state="translated">두 &lt;code&gt;npm&lt;/code&gt; 과 &lt;code&gt;yarn&lt;/code&gt; A의 식별 패키지 설치 &lt;a href=&quot;https://docs.npmjs.com/files/package.json&quot;&gt; &lt;code&gt;package.json&lt;/code&gt; 의&lt;/a&gt; 파일을.</target>
        </trans-unit>
        <trans-unit id="efd9072be34ddd4cd3ac6531f4cdfce31589a567" translate="yes" xml:space="preserve">
          <source>Both AngularJS and Angular have their own concept of modules to help organize an app into cohesive blocks of functionality.</source>
          <target state="translated">AngularJS와 Angular는 모두 고유 한 모듈 개념을 가지고있어 앱을 응집력있는 기능 블록으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8b1d87ddf1e625974551a1a9492af7f227f733c" translate="yes" xml:space="preserve">
          <source>Both AngularJS and Angular have their own concept of modules to help organize an application into cohesive blocks of functionality.</source>
          <target state="translated">AngularJS와 Angular는 응용 프로그램을 응집력있는 기능 블록으로 구성하는 데 도움이되는 자체 모듈 개념을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d564c53c4c40f094481604ce9c087637f753034c" translate="yes" xml:space="preserve">
          <source>Both buttons navigate back to the crisis list after save or cancel.</source>
          <target state="translated">저장 또는 취소 후 두 버튼 모두 위기 목록으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="64ed4a76603ad54f5413c0e8debcdd97dd1aa9b1" translate="yes" xml:space="preserve">
          <source>Both components and services are simply classes, with &lt;em&gt;decorators&lt;/em&gt; that mark their type and provide metadata that tells Angular how to use them.</source>
          <target state="translated">컴포넌트와 서비스는 단순히 클래스이며, 형식을 표시하고 Angular에게 사용법을 알려주는 메타 데이터를 제공 하는 &lt;em&gt;데코레이터&lt;/em&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c09c3f8cf9bbef0b8dcd1109994c96416fac328" translate="yes" xml:space="preserve">
          <source>Both elements now use the same translation (&lt;code&gt;Bonjour&lt;/code&gt;) because they were defined with the same custom ID:</source>
          <target state="translated">두 요소 는 동일한 사용자 정의 ID로 정의 되었으므로 이제 동일한 번역 ( &lt;code&gt;Bonjour&lt;/code&gt; )을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="ed0a9be87024bfe0406f2632088e389834c9a494" translate="yes" xml:space="preserve">
          <source>Both reactive and template-driven forms are built on the following base classes.</source>
          <target state="translated">반응 형 및 템플릿 기반 양식은 모두 다음 기본 클래스를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="f690c03e061a7fd137c00dd8ab89db4c52afd0e5" translate="yes" xml:space="preserve">
          <source>Both reactive and template-driven forms share underlying building blocks.</source>
          <target state="translated">반응 형 및 템플릿 기반 양식은 모두 기본 구성 요소를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="979fd0ef5434b1b36edceaf3d9bc579f6c5937ab" translate="yes" xml:space="preserve">
          <source>Both reactive and template-driven forms track value changes between the form input elements that users interact with and the form data in your component model. The two approaches share underlying building blocks, but differ in how you create and manage the common form-control instances.</source>
          <target state="translated">반응 형 및 템플릿 기반 양식 모두 사용자가 상호 작용하는 양식 입력 요소와 구성 요소 모델의 양식 데이터 간의 값 변경을 추적합니다. 두 가지 접근 방식은 기본 구성 요소를 공유하지만 일반적인 양식 제어 인스턴스를 만들고 관리하는 방법이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c547c7a0a78e9d790dbe284eb7240f0e366c99c3" translate="yes" xml:space="preserve">
          <source>Both states are temporary; they are saved only for the lifetime of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope&quot;&gt;ServiceWorker instance&lt;/a&gt;. The browser sometimes terminates an idle service worker to conserve memory and processor power, and creates a new service worker instance in response to network events. The new instance starts in the &lt;code&gt;NORMAL&lt;/code&gt; mode, regardless of the state of the previous instance.</source>
          <target state="translated">두 상태 모두 일시적입니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope&quot;&gt;ServiceWorker 인스턴스&lt;/a&gt; 의 수명 동안 만 저장됩니다 . 브라우저는 때때로 유휴 서비스 워커를 종료하여 메모리와 프로세서 전원을 절약하고 네트워크 이벤트에 대한 응답으로 새 서비스 워커 인스턴스를 만듭니다. 새 인스턴스 는 이전 인스턴스의 상태에 관계없이 &lt;code&gt;NORMAL&lt;/code&gt; 모드 에서 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="2d33f13edcd4c6f3ed84da53d2a75dfa7b13538d" translate="yes" xml:space="preserve">
          <source>Both successful and unsuccessful responses can be delivered via &lt;code&gt;&lt;a href=&quot;../../../core/testing/flush&quot;&gt;flush&lt;/a&gt;()&lt;/code&gt;.</source>
          <target state="translated">성공적인 응답과 실패한 응답 모두 &lt;code&gt;&lt;a href=&quot;../../../core/testing/flush&quot;&gt;flush&lt;/a&gt;()&lt;/code&gt; 를 통해 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb0fb25a4a028a2cda7733bb08d025271905f029" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;&lt;a href=&quot;../api/core/afterviewinit&quot;&gt;AfterViewInit&lt;/a&gt;()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../api/core/afterviewchecked&quot;&gt;AfterViewChecked&lt;/a&gt;()&lt;/code&gt; hooks fire after the component's view has been composed. If you modify the code so that the hook updates the component's data-bound &lt;code&gt;comment&lt;/code&gt; property immediately, you can see that Angular throws an error.</source>
          <target state="translated">양 &lt;code&gt;&lt;a href=&quot;../api/core/afterviewinit&quot;&gt;AfterViewInit&lt;/a&gt;()&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../api/core/afterviewchecked&quot;&gt;AfterViewChecked&lt;/a&gt;()&lt;/code&gt; 구성 요소의 뷰가 구성된 후 불을 후크. 후크가 구성 요소의 데이터 바인딩 된 &lt;code&gt;comment&lt;/code&gt; 속성을 즉시 업데이트하도록 코드를 수정하면 Angular에서 오류가 발생하는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14a724638caaef22868a74a59cb2138ec4f02873" translate="yes" xml:space="preserve">
          <source>Break circularities with a forward class reference (&lt;code&gt;forwardRef&lt;/code&gt;)</source>
          <target state="translated">순방향 클래스 참조 ( &lt;code&gt;forwardRef&lt;/code&gt; )로 순환도 끊기</target>
        </trans-unit>
        <trans-unit id="19e2cd28b09ef3682ded6d1478601de1d625cc30" translate="yes" xml:space="preserve">
          <source>Break the circularity with &lt;code&gt;&lt;a href=&quot;../api/core/forwardref&quot;&gt;forwardRef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../api/core/forwardref&quot;&gt;forwardRef&lt;/a&gt;&lt;/code&gt; 로 순환 성을 끊습니다 .</target>
        </trans-unit>
        <trans-unit id="54a2cf5e634dbba0be2bf8a55f79252f5c790bdb" translate="yes" xml:space="preserve">
          <source>Browser</source>
          <target state="translated">Browser</target>
        </trans-unit>
        <trans-unit id="caa7ae8131b0e358dca91885f3b90f7468dff074" translate="yes" xml:space="preserve">
          <source>Browser support</source>
          <target state="translated">브라우저 지원</target>
        </trans-unit>
        <trans-unit id="2d988f6baee731e13c5ed58b15e6403c0f5d437c" translate="yes" xml:space="preserve">
          <source>Browser support for custom elements</source>
          <target state="translated">사용자 정의 요소에 대한 브라우저 지원</target>
        </trans-unit>
        <trans-unit id="3e5c46f54fdcf3e89274890de50e1bbd5f0cdb1b" translate="yes" xml:space="preserve">
          <source>BrowserAnimationsModule</source>
          <target state="translated">BrowserAnimationsModule</target>
        </trans-unit>
        <trans-unit id="1b19571f37782c3b7a2529d132b7eeafffb9c8b7" translate="yes" xml:space="preserve">
          <source>BrowserDynamicTestingModule</source>
          <target state="translated">BrowserDynamicTestingModule</target>
        </trans-unit>
        <trans-unit id="489e469aaed844504ea81ebeeb21f713325a5454" translate="yes" xml:space="preserve">
          <source>BrowserModule</source>
          <target state="translated">BrowserModule</target>
        </trans-unit>
        <trans-unit id="39e941a302cc8d62cbd7fd0aa04f1f300f6db868" translate="yes" xml:space="preserve">
          <source>BrowserTestingModule</source>
          <target state="translated">BrowserTestingModule</target>
        </trans-unit>
        <trans-unit id="1170851384c0cf693a98b5cd9a90dfd12e351c34" translate="yes" xml:space="preserve">
          <source>BrowserTransferStateModule</source>
          <target state="translated">BrowserTransferStateModule</target>
        </trans-unit>
        <trans-unit id="b53e7dea10c2c28052bb71dd93c9ae381907b043" translate="yes" xml:space="preserve">
          <source>Browsers (Desktop &amp;amp; Mobile)</source>
          <target state="translated">브라우저 (데스크탑 및 모바일)</target>
        </trans-unit>
        <trans-unit id="7472f880b5ebe7a2522b3da766321267d335a017" translate="yes" xml:space="preserve">
          <source>Browsers can't execute TypeScript directly. Typescript must be &quot;transpiled&quot; into JavaScript using the &lt;em&gt;tsc&lt;/em&gt; compiler, which requires some configuration.</source>
          <target state="translated">브라우저는 TypeScript를 직접 실행할 수 없습니다. 타이프 스크립트는 &lt;em&gt;tsc&lt;/em&gt; 컴파일러를 사용하여 JavaScript로 &quot;변환&quot;되어야하며 , 일부 구성이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7331906d686c4ec9c7fb5e96c8a75a52e6649767" translate="yes" xml:space="preserve">
          <source>Browsers list The &lt;code&gt;browserslist&lt;/code&gt; configuration file is included in your application &lt;a href=&quot;file-structure#application-configuration-files&quot;&gt;project structure&lt;/a&gt; and provides the minimum browsers your application supports. See the &lt;a href=&quot;https://github.com/browserslist/browserslist&quot;&gt;Browserslist spec&lt;/a&gt; for complete configuration options.</source>
          <target state="translated">브라우저 목록 &lt;code&gt;browserslist&lt;/code&gt; 구성 파일은 응용 프로그램 &lt;a href=&quot;file-structure#application-configuration-files&quot;&gt;프로젝트 구조에&lt;/a&gt; 포함되며 응용 프로그램이 지원하는 최소 브라우저를 제공합니다. 전체 구성 옵션 은 &lt;a href=&quot;https://github.com/browserslist/browserslist&quot;&gt;Browserslist 사양&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5fd48f06506544e724e31bc1d27319aa4940aeb2" translate="yes" xml:space="preserve">
          <source>Browsers such as Chrome provide developer tools for interacting with service workers. Such tools can be powerful when used properly, but there are a few things to keep in mind.</source>
          <target state="translated">Chrome과 같은 브라우저는 서비스 작업자와 상호 작용하기위한 개발자 도구를 제공합니다. 이러한 도구는 올바르게 사용하면 강력 할 수 있지만 명심해야 할 것이 몇 가지 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ac1c219ed9db5609130bf09817b19913aa7f75c" translate="yes" xml:space="preserve">
          <source>Browserslist</source>
          <target state="translated">Browserslist</target>
        </trans-unit>
        <trans-unit id="5f4763bbd263cd5434b3654e03112db678b6b161" translate="yes" xml:space="preserve">
          <source>Build Result</source>
          <target state="translated">빌드 결과</target>
        </trans-unit>
        <trans-unit id="c674564300cade5252a5db51fce3d3eeff1e91ac" translate="yes" xml:space="preserve">
          <source>Build a simple attribute directive</source>
          <target state="translated">간단한 속성 지시문 작성</target>
        </trans-unit>
        <trans-unit id="63a1d3442e3d58ff2cfb7be5462ee9514f437b01" translate="yes" xml:space="preserve">
          <source>Build a template-driven form</source>
          <target state="translated">템플릿 기반 양식 작성</target>
        </trans-unit>
        <trans-unit id="a1ab8e1d24bf4b36f9398025bfb1689b7314ddb9" translate="yes" xml:space="preserve">
          <source>Build an Angular form with a component and template.</source>
          <target state="translated">컴포넌트와 템플릿으로 Angular 폼을 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="0b16ed964ca1d0b9633697442124487216e8c15a" translate="yes" xml:space="preserve">
          <source>Build and launch the app with debugger by clicking the &lt;strong&gt;Run&lt;/strong&gt; button or by pressing &lt;code&gt;F5&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;실행&lt;/strong&gt; 버튼을 클릭하거나 &lt;code&gt;F5&lt;/code&gt; 를 눌러 디버거로 앱을 빌드하고 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="a841e5989fc4a3f8e040bebb8d4e89ce53e2ea2d" translate="yes" xml:space="preserve">
          <source>Build and run the server again:</source>
          <target state="translated">서버를 다시 빌드하고 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="d6e1e6845b1c24e4e46ae9e1811d147c1fd4b03b" translate="yes" xml:space="preserve">
          <source>Build artifacts (JS and CSS bundles).</source>
          <target state="translated">아티팩트 빌드 (JS 및 CSS 번들)</target>
        </trans-unit>
        <trans-unit id="fe668d7b9bd1bdd039e15e4e4878232c9f14cf75" translate="yes" xml:space="preserve">
          <source>Build for multiple locales</source>
          <target state="translated">여러 로케일을위한 빌드</target>
        </trans-unit>
        <trans-unit id="7d8144a3c59905f4260f61d31b9b788252b947a5" translate="yes" xml:space="preserve">
          <source>Build from the command line</source>
          <target state="translated">명령 줄에서 빌드</target>
        </trans-unit>
        <trans-unit id="2ecff7853ffb7bfb041edba485c0757a60f0fd6c" translate="yes" xml:space="preserve">
          <source>Build result</source>
          <target state="translated">빌드 결과</target>
        </trans-unit>
        <trans-unit id="55d71d005605b731983e1212cab3067f5e36bf4a" translate="yes" xml:space="preserve">
          <source>Build target</source>
          <target state="translated">빌드 대상</target>
        </trans-unit>
        <trans-unit id="b97a5bae4bb0dc9aea2ba383a4c9d6b011be2aa7" translate="yes" xml:space="preserve">
          <source>Build the basic form.</source>
          <target state="translated">기본 양식을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="4ebaaba151b4fa323c7853acaedf81d4316c1d03" translate="yes" xml:space="preserve">
          <source>Build the form</source>
          <target state="translated">양식 작성</target>
        </trans-unit>
        <trans-unit id="0e3634fbe639279233d0d5ba2b0a7a9a5c30747b" translate="yes" xml:space="preserve">
          <source>Build the library. You cannot use a library before it is built.</source>
          <target state="translated">라이브러리를 빌드하십시오. 라이브러리는 빌드되기 전에 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="10f95352487e622a50d6a09f351680b2e04970de" translate="yes" xml:space="preserve">
          <source>Build using Ahead of Time compilation.</source>
          <target state="translated">Ahead of Time 컴파일을 사용하여 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="12147b38fd3c8e49fbaaf0d27106cec8cf6bf7a1" translate="yes" xml:space="preserve">
          <source>Build your app for production &lt;em&gt;including the source maps&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;소스 맵을 포함하여&lt;/em&gt; 프로덕션 용 앱 빌드&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4e1f7908a8fa15b11aa7a8fec3020d998a1cb595" translate="yes" xml:space="preserve">
          <source>Build your library and schematics</source>
          <target state="translated">라이브러리 및 회로도 구축</target>
        </trans-unit>
        <trans-unit id="3a8f2b080985e84ff16f5bd0acaede8ad59a5039" translate="yes" xml:space="preserve">
          <source>Build your project using Github project name, with the Angular CLI command &lt;a href=&quot;cli/build&quot;&gt;&lt;code&gt;ng build&lt;/code&gt;&lt;/a&gt; and the options shown here:</source>
          <target state="translated">Angular CLI 명령 &lt;a href=&quot;cli/build&quot;&gt; &lt;code&gt;ng build&lt;/code&gt; &lt;/a&gt; 및 여기에 표시된 옵션을 사용하여 Github 프로젝트 이름을 사용하여 프로젝트를 빌드 하십시오.</target>
        </trans-unit>
        <trans-unit id="338940014efbeb76bf00b87e6fd1a0b5d3d0dc9f" translate="yes" xml:space="preserve">
          <source>Builder input</source>
          <target state="translated">빌더 입력</target>
        </trans-unit>
        <trans-unit id="7ef7408461360b6d8e74a044b183f8de6fc8be2e" translate="yes" xml:space="preserve">
          <source>Builder project structure</source>
          <target state="translated">빌더 프로젝트 구조</target>
        </trans-unit>
        <trans-unit id="7cec90732540af8e27f18d76711bdd709e2926f7" translate="yes" xml:space="preserve">
          <source>Builders can be synchronous or asynchronous, execute once or watch for external events, and can schedule other builders or targets.</source>
          <target state="translated">빌더는 동기식 또는 비동기식, 한 번 실행 또는 외부 이벤트를 감시하고 다른 빌더 또는 대상을 스케줄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a596c9d2eb919381175f356f2ed5bae199a81aa" translate="yes" xml:space="preserve">
          <source>Builders definition.</source>
          <target state="translated">빌더 정의.</target>
        </trans-unit>
        <trans-unit id="3fc44ef66b534b8d05ed7f18b305da65952fa0a1" translate="yes" xml:space="preserve">
          <source>Builders have option defaults specified in the &lt;code&gt;angular.json&lt;/code&gt; configuration file, which can be overwritten by an alternate configuration for the target, and further overwritten by command line flags.</source>
          <target state="translated">빌더에는 &lt;code&gt;angular.json&lt;/code&gt; 구성 파일에 지정된 옵션 기본값 이 있으며, 대상의 대체 구성으로 겹쳐 쓰고 명령 행 플래그로 겹쳐 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c40455fd1dd802b3a381a69ec531aea076ff8b2" translate="yes" xml:space="preserve">
          <source>Building a template-driven form</source>
          <target state="translated">템플릿 기반 양식 작성</target>
        </trans-unit>
        <trans-unit id="c3dd970b85d3d73006d2f7e6aba2ff655bbf3277" translate="yes" xml:space="preserve">
          <source>Building accessible web experience often involves setting &lt;a href=&quot;https://developers.google.com/web/fundamentals/accessibility/semantics-aria&quot;&gt;ARIA attributes&lt;/a&gt; to provide semantic meaning where it might otherwise be missing. Use &lt;a href=&quot;attribute-binding&quot;&gt;attribute binding&lt;/a&gt; template syntax to control the values of accessibility-related attributes.</source>
          <target state="translated">액세스 가능한 웹 경험을 구축 하려면 &lt;a href=&quot;https://developers.google.com/web/fundamentals/accessibility/semantics-aria&quot;&gt;ARIA 속성&lt;/a&gt; 을 설정 하여 그렇지 않으면 누락 될 수있는 의미 론적 의미를 제공하는 경우가 많습니다 . 사용 &lt;a href=&quot;attribute-binding&quot;&gt;바인딩 속성&lt;/a&gt; 접근성 관련 속성의 값을 제어하는 템플릿 구문을.</target>
        </trans-unit>
        <trans-unit id="58423fd7c3d8a2b3b0288c434ca19a63c03fddd4" translate="yes" xml:space="preserve">
          <source>Building accessible web experience often involves setting &lt;a href=&quot;https://developers.google.com/web/fundamentals/accessibility/semantics-aria&quot;&gt;ARIA attributes&lt;/a&gt; to provide semantic meaning where it might otherwise be missing. Use &lt;a href=&quot;template-syntax#attribute-binding&quot;&gt;attribute binding&lt;/a&gt; template syntax to control the values of accessibility-related attributes.</source>
          <target state="translated">액세스 가능한 웹 환경을 구축 하려면 &lt;a href=&quot;https://developers.google.com/web/fundamentals/accessibility/semantics-aria&quot;&gt;ARIA 속성&lt;/a&gt; 을 설정 하여 의미가없는 경우 의미 적 의미를 제공해야합니다. 사용 &lt;a href=&quot;template-syntax#attribute-binding&quot;&gt;바인딩 속성&lt;/a&gt; 접근성 관련 속성의 값을 제어하는 템플릿 구문을.</target>
        </trans-unit>
        <trans-unit id="ffb0d65cff95173c9727f4ed3f1046730b30b49a" translate="yes" xml:space="preserve">
          <source>Building and rebuilding your library</source>
          <target state="translated">라이브러리 구축 및 재건</target>
        </trans-unit>
        <trans-unit id="f7125bd3b210a7172b096873cf19164849e1f6b3" translate="yes" xml:space="preserve">
          <source>Building and serving Angular apps</source>
          <target state="translated">Angular 앱 빌드 및 제공</target>
        </trans-unit>
        <trans-unit id="38044acdb5b1bf0f8b98c5b7c6e09d68e6dbf057" translate="yes" xml:space="preserve">
          <source>Building and serving from disk</source>
          <target state="translated">디스크에서 빌드 및 제공</target>
        </trans-unit>
        <trans-unit id="5f44ed433a18b75e46be9d13f403d1b209869c46" translate="yes" xml:space="preserve">
          <source>Building and serving the app for a given locale, using the translated text.</source>
          <target state="translated">번역 된 텍스트를 사용하여 지정된 로캘에 대한 앱 빌드 및 제공</target>
        </trans-unit>
        <trans-unit id="a441046d59751ffd55f2c40318e3e1ef1eb52dca" translate="yes" xml:space="preserve">
          <source>Building dynamic forms</source>
          <target state="translated">동적 양식 작성</target>
        </trans-unit>
        <trans-unit id="14d7cef5094185320d88e754c57130b67a38a3c8" translate="yes" xml:space="preserve">
          <source>Building handcrafted forms can be costly and time-consuming, especially if you need a great number of them, they're similar to each other, and they change frequently to meet rapidly changing business and regulatory requirements.</source>
          <target state="translated">수작업으로 제작 한 양식을 작성하는 데 많은 비용과 시간이 소요될 수 있습니다. 특히 많은 수의 양식이 필요한 경우 서로 유사하며 급변하는 비즈니스 및 규정 요구 사항을 충족하기 위해 자주 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="99b633b8b55f4a4a0e4b874bf81f4324ac607609" translate="yes" xml:space="preserve">
          <source>Building locally</source>
          <target state="translated">로컬로 구축</target>
        </trans-unit>
        <trans-unit id="ea19476edd9c5bc2591da244c58924cd2d0448a0" translate="yes" xml:space="preserve">
          <source>Building with Bazel</source>
          <target state="translated">Bazel로 빌딩</target>
        </trans-unit>
        <trans-unit id="592a2f2da2ad52e24a8c5d5555474faed5b11d88" translate="yes" xml:space="preserve">
          <source>Building your schematics</source>
          <target state="translated">회로도 만들기</target>
        </trans-unit>
        <trans-unit id="74dbfc5fed244390666be30faae5de6b93204f0d" translate="yes" xml:space="preserve">
          <source>Builds a class that encapsulates the functionality of the provided component and uses the configuration information to provide more context to the class. Takes the component factory's inputs and outputs to convert them to the proper custom element API and add hooks to input changes.</source>
          <target state="translated">제공된 구성 요소의 기능을 캡슐화하고 구성 정보를 사용하여 클래스에 더 많은 컨텍스트를 제공하는 클래스를 작성합니다. 컴포넌트 팩토리의 입력 및 출력을 가져 와서 적절한 사용자 정의 요소 API로 변환하고 입력 변경에 후크를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="232819cbe5519dee306aa0895ba18910a5ec7859" translate="yes" xml:space="preserve">
          <source>Builds a factory for producing a defined animation.</source>
          <target state="translated">정의 된 애니메이션 제작을위한 팩토리를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="29a6ebd47094fe74b2826b82789b68332b6c3967" translate="yes" xml:space="preserve">
          <source>Builds and serves an Angular app, then runs end-to-end tests using Protractor.</source>
          <target state="translated">Angular 앱을 빌드하고 제공 한 다음 각도기를 사용하여 엔드 투 엔드 테스트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="e2a7d33be0b02d6a586a825825ca723c6f2b203a" translate="yes" xml:space="preserve">
          <source>Builds and serves your app, rebuilding on file changes.</source>
          <target state="translated">파일 변경 사항을 재구성하여 앱을 빌드하고 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3699f6d3ab9939f61e3dfd80b624361cc8f93a32" translate="yes" xml:space="preserve">
          <source>Built-in &lt;code&gt;structural&lt;/code&gt; directives</source>
          <target state="translated">내장 &lt;code&gt;structural&lt;/code&gt; 지시문</target>
        </trans-unit>
        <trans-unit id="788c41440c17fec4a3ceedf2627edc4891b3e70f" translate="yes" xml:space="preserve">
          <source>Built-in attribute directives</source>
          <target state="translated">내장 속성 지시문</target>
        </trans-unit>
        <trans-unit id="34fc1e1b84850bf75a3a8ab79f67893426bb2dbb" translate="yes" xml:space="preserve">
          <source>Built-in directives</source>
          <target state="translated">내장 지시문</target>
        </trans-unit>
        <trans-unit id="f1881fdacac2d002db723126c9b7e1fc54324ce1" translate="yes" xml:space="preserve">
          <source>Built-in directives use only public APIs; that is, they do not have special access to any private APIs that other directives can't access.</source>
          <target state="translated">내장 지시문은 공용 API 만 사용합니다. 즉, 다른 지시문이 액세스 할 수없는 개인 API에 대한 특별한 액세스 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="14c8e0c882b739a0956ce99a903aa60c7db8e7b0" translate="yes" xml:space="preserve">
          <source>Built-in pipes</source>
          <target state="translated">내장 파이프</target>
        </trans-unit>
        <trans-unit id="f846a8ef31181b4f0e27e3db37268decf8f99a23" translate="yes" xml:space="preserve">
          <source>Built-in template functions</source>
          <target state="translated">내장 템플릿 기능</target>
        </trans-unit>
        <trans-unit id="04b04243ac876d4efb6192834885a2963c11c58b" translate="yes" xml:space="preserve">
          <source>Built-in validator functions</source>
          <target state="translated">내장 유효성 검사기 기능</target>
        </trans-unit>
        <trans-unit id="853adbe6a9c9185cf38b20fec800da9b6c47bf4a" translate="yes" xml:space="preserve">
          <source>Built-in validators</source>
          <target state="translated">내장 유효성 검사기</target>
        </trans-unit>
        <trans-unit id="23270ff48782c619fd08871d4873b8a228d6bad4" translate="yes" xml:space="preserve">
          <source>Bundling: concatenates your many application and library files into a few bundles.</source>
          <target state="translated">번들링 : 많은 응용 프로그램 및 라이브러리 파일을 몇 개의 번들로 연결합니다.</target>
        </trans-unit>
        <trans-unit id="b77c50fe85e215a333530a2770df5fc00971a9a0" translate="yes" xml:space="preserve">
          <source>But a component is more than just its class. A component interacts with the DOM and with other components. The &lt;em&gt;class-only&lt;/em&gt; tests can tell you about class behavior. They cannot tell you if the component is going to render properly, respond to user input and gestures, or integrate with its parent and child components.</source>
          <target state="translated">그러나 구성 요소는 단순한 클래스 그 이상입니다. 컴포넌트는 DOM 및 다른 컴포넌트와 상호 작용합니다. &lt;em&gt;클래스 전용&lt;/em&gt; 테스트는 클래스의 행동에 대해 알 수 있습니다. 구성 요소가 올바르게 렌더링되는지, 사용자 입력 및 제스처에 응답하거나, 상위 및 하위 구성 요소와 통합되는지 알려줄 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dd16c28b37bfac9fd975ec035f73fbe88687604a" translate="yes" xml:space="preserve">
          <source>But a component or directive shouldn't blindly trust &lt;em&gt;other&lt;/em&gt; components and directives. The properties of a component or directive are hidden from binding by default. They are &lt;em&gt;private&lt;/em&gt; from an Angular binding perspective. When adorned with the &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; decorator, the property becomes &lt;em&gt;public&lt;/em&gt; from an Angular binding perspective. Only then can it be bound by some other component or directive.</source>
          <target state="translated">그러나 구성 요소 또는 지시문이 &lt;em&gt;다른&lt;/em&gt; 구성 요소 및 지시문을 맹목적으로 신뢰해서는 안됩니다 . 컴포넌트 또는 지시문의 속성은 기본적으로 바인딩에서 숨겨집니다. 그들은 Angular 바인딩 관점에서 &lt;em&gt;비공개&lt;/em&gt; 입니다. 장식하면 &lt;code&gt;@&lt;a href=&quot;../api/core/input&quot;&gt;Input&lt;/a&gt;&lt;/code&gt; 장식의 속성이된다 &lt;em&gt;공용&lt;/em&gt; 각도 결합 관점. 그래야만 다른 구성 요소 나 지시문에 의해 바인딩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c3ff50267ef1b91995b1701f72f05cd08be99af" translate="yes" xml:space="preserve">
          <source>But always implement a &lt;em&gt;pure pipe&lt;/em&gt; with a &lt;em&gt;pure function&lt;/em&gt;. Otherwise, you'll see many console errors regarding expressions that changed after they were checked.</source>
          <target state="translated">그러나 항상 &lt;em&gt;순수한 기능을&lt;/em&gt; 가진 &lt;em&gt;순수한 파이프&lt;/em&gt; 를 구현하십시오 . 그렇지 않으면, 확인 후 변경된 표현식과 관련된 많은 콘솔 오류가 표시됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1dad324eea1e02746dc15d325e015070ea526f47" translate="yes" xml:space="preserve">
          <source>But an interceptor can change this to an &lt;em&gt;observable&lt;/em&gt; that emits more than once.</source>
          <target state="translated">그러나 인터셉터는 이것을 두 번 이상 방출 하는 &lt;em&gt;관찰 가능으로&lt;/em&gt; 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80bd50bba245c58f59752096de59db1d05418d3c" translate="yes" xml:space="preserve">
          <source>But clicking a link in an email, entering it in the browser address bar, or merely refreshing the browser while on the hero detail page &amp;mdash; all of these actions are handled by the browser itself, &lt;em&gt;outside&lt;/em&gt; the running application. The browser makes a direct request to the server for that URL, bypassing the router.</source>
          <target state="translated">그러나 전자 메일의 링크를 클릭하거나 브라우저 주소 표시 줄에 입력하거나 영웅 세부 정보 페이지에서 브라우저를 새로 고치면 이러한 모든 작업은 실행중인 응용 프로그램 &lt;em&gt;외부&lt;/em&gt; 의 브라우저 자체에서 처리됩니다 . 브라우저는 라우터를 무시하고 해당 URL을 서버에 직접 요청합니다.</target>
        </trans-unit>
        <trans-unit id="fa03a76338d6f6af61aea8774405dc940313388b" translate="yes" xml:space="preserve">
          <source>But first, make a few changes to the &lt;code&gt;AppRoutingModule&lt;/code&gt;.</source>
          <target state="translated">그러나 먼저 &lt;code&gt;AppRoutingModule&lt;/code&gt; 을 약간 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="c27f7b3e935b9fc74c79376898a71d98935aa436" translate="yes" xml:space="preserve">
          <source>But in the absence of a compelling reason to keep them around, your preference should be to remove DOM elements that the user can't see and recover the unused resources with a structural directive like &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">그러나이를 유지해야 할 강력한 이유가 없다면 사용자는 &lt;code&gt;&lt;a href=&quot;../api/common/ngif&quot;&gt;NgIf&lt;/a&gt;&lt;/code&gt; 같은 구조적 지시문으로 사용하지 않는 자원을보고 복구 할 수없는 DOM 요소를 제거해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3edb9da96e057d100aa5383d0834fa22e414c6e1" translate="yes" xml:space="preserve">
          <source>But interceptors that examine and modify the response from &lt;code&gt;next.handle()&lt;/code&gt; will see all of these events. Your interceptor should return &lt;em&gt;every event untouched&lt;/em&gt; unless it has a &lt;em&gt;compelling reason to do otherwise&lt;/em&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;next.handle()&lt;/code&gt; 의 응답을 검사하고 수정하는 인터셉터 는 이러한 모든 이벤트를 볼 수 있습니다. 인터셉터는 &lt;em&gt;다른 이유가없는&lt;/em&gt; 한 &lt;em&gt;모든 이벤트를 건드리지 않은 채&lt;/em&gt; 반환 &lt;em&gt;해야합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a36ff3370e272264824942a257a5f735eab10803" translate="yes" xml:space="preserve">
          <source>But on the shared or production server, you might serve the app from a subfolder. For example, when the URL to load the app is something like &lt;code&gt;http://www.mysite.com/my/app/&lt;/code&gt;, the subfolder is &lt;code&gt;my/app/&lt;/code&gt; and you should add &lt;code&gt;&amp;lt;base href=&quot;/my/app/&quot;&amp;gt;&lt;/code&gt; to the server version of the &lt;code&gt;index.html&lt;/code&gt;.</source>
          <target state="translated">그러나 공유 또는 프로덕션 서버에서는 하위 폴더에서 앱을 제공 할 수 있습니다. 예를 들어 앱을로드 할 URL이 &lt;code&gt;http://www.mysite.com/my/app/&lt;/code&gt; 와 같은 경우 하위 폴더는 &lt;code&gt;my/app/&lt;/code&gt; 이며 &lt;code&gt;&amp;lt;base href=&quot;/my/app/&quot;&amp;gt;&lt;/code&gt; 추가해야합니다. &amp;gt; 서버 버전의 &lt;code&gt;index.html&lt;/code&gt; 로 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b97cebd5bc435fb7714257eba2ba270e61f5214" translate="yes" xml:space="preserve">
          <source>But the compiler won't throw an error when it encounters &lt;code&gt;&amp;lt;app-banner&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;app-welcome&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt;. It simply renders them as empty tags and the browser ignores them.</source>
          <target state="translated">그러나 &lt;code&gt;&amp;lt;app-banner&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;app-welcome&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;&lt;a href=&quot;../api/router/routeroutlet&quot;&gt;router-outlet&lt;/a&gt;&amp;gt;&lt;/code&gt; 이 발생하면 컴파일러에서 오류가 발생하지 않습니다 . 단순히 빈 태그로 렌더링하고 브라우저는이를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="a6e1ffc936f0d832154812aedbbbdd45670ea6cb" translate="yes" xml:space="preserve">
          <source>But the router is still loading the &lt;code&gt;AdminModule&lt;/code&gt; even if the user can't visit any of its components. Ideally, you'd only load the &lt;code&gt;AdminModule&lt;/code&gt; if the user is logged in.</source>
          <target state="translated">그러나 사용자가 구성 요소를 방문 할 수없는 경우에도 라우터는 여전히 &lt;code&gt;AdminModule&lt;/code&gt; 을 로드합니다 . 사용자가 로그인 한 경우 에만 &lt;code&gt;AdminModule&lt;/code&gt; 을 로드하는 것이 이상적 입니다.</target>
        </trans-unit>
        <trans-unit id="5cf7129241a1e1a5c0fa7cf971437230767eaf7b" translate="yes" xml:space="preserve">
          <source>But the test's asynchronous nature is revealed by the call to &lt;code&gt;fixture.whenStable()&lt;/code&gt;, which breaks the linear flow of control.</source>
          <target state="translated">그러나 테스트의 비동기 특성은 &lt;code&gt;fixture.whenStable()&lt;/code&gt; 호출하여 제어의 선형 흐름을 깨뜨리는 것으로 밝혀졌습니다 .</target>
        </trans-unit>
        <trans-unit id="8cea244f43f2793e842872ae957b0a1f13e42a42" translate="yes" xml:space="preserve">
          <source>But there's plenty of template complexity even in this simple form.</source>
          <target state="translated">그러나이 간단한 형식으로도 템플릿 복잡성이 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b11b3e52dfeccee3a7be0007f3d3766d07568c9" translate="yes" xml:space="preserve">
          <source>But when using them from AngularJS templates, you must use kebab-case:</source>
          <target state="translated">그러나 AngularJS 템플릿에서 사용할 때는 kebab-case를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="943e02425418f80a99a67821520af9a48faca8cd" translate="yes" xml:space="preserve">
          <source>But you can also start adding &lt;em&gt;type annotations&lt;/em&gt; to get even more out of TypeScript's type system. For instance, you can annotate the checkmark filter so that it explicitly expects booleans as arguments. This makes it clearer what the filter is supposed to do.</source>
          <target state="translated">그러나 TypeScript 유형 시스템을 최대한 활용하기 위해 &lt;em&gt;유형 주석&lt;/em&gt; 추가를 시작할 수도 있습니다. 예를 들어, 체크 표시 필터에 주석을 달아 부울을 인수로 명시 적으로 기대할 수 있습니다. 이것은 필터가 무엇을해야 하는지를보다 명확하게합니다.</target>
        </trans-unit>
        <trans-unit id="cfadbd7a577133041a60f331a0e2ad6af20f3f8b" translate="yes" xml:space="preserve">
          <source>By</source>
          <target state="translated">By</target>
        </trans-unit>
        <trans-unit id="9979e502bac7109b83a440b9de42340f258ddfa0" translate="yes" xml:space="preserve">
          <source>By adding &lt;code&gt;&amp;lt;live-example&amp;gt;&lt;/code&gt; to the page you generate links that run sample code in the Stackblitz live coding environment and download that code to the reader's file system.</source>
          <target state="translated">추가함으로써 &lt;code&gt;&amp;lt;live-example&amp;gt;&lt;/code&gt; 페이지로 당신은 Stackblitz에서 샘플 코드를 실행 링크 라이브 코딩 환경과 다운로드를 생성하는 독자의 파일 시스템에 코드입니다.</target>
        </trans-unit>
        <trans-unit id="2cf4fb2c70012c8404bf6ea7e18e7ae9d001da1c" translate="yes" xml:space="preserve">
          <source>By clicking a hero in the dashboard.</source>
          <target state="translated">대시 보드에서 영웅을 클릭합니다.</target>
        </trans-unit>
        <trans-unit id="06c882c348dd5f75caf8d98a0cc0eb826d015cff" translate="yes" xml:space="preserve">
          <source>By clicking a hero in the heroes list.</source>
          <target state="translated">영웅 목록에서 영웅을 클릭합니다.</target>
        </trans-unit>
        <trans-unit id="0ea68802c089f45528d4b35900b0fde6854239f2" translate="yes" xml:space="preserve">
          <source>By clicking the browser's back button, you can go back to the hero list or dashboard view, depending upon which sent you to the detail view.</source>
          <target state="translated">브라우저의 뒤로 버튼을 클릭하면 상세보기로 보낸 메시지에 따라 영웅 목록 또는 대시 보드보기로 돌아갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a5dc8091fb2b001718c9b188eeb628b36637423" translate="yes" xml:space="preserve">
          <source>By compiling your application using the &lt;code&gt;ngc&lt;/code&gt; command-line tool, you can bootstrap directly to a module factory, so you don't need to include the Angular compiler in your JavaScript bundle.</source>
          <target state="translated">&lt;code&gt;ngc&lt;/code&gt; 명령 줄 도구를 사용하여 응용 프로그램을 컴파일 하면 모듈 팩토리에 직접 부트 스트랩 할 수 있으므로 JavaScript 번들에 Angular 컴파일러를 포함시킬 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e83663bb4eeda0ed5495f37b7c40ecac703dc7a4" translate="yes" xml:space="preserve">
          <source>By contrast, Angular registers &lt;code&gt;AppComponent&lt;/code&gt; providers with the &lt;code&gt;AppComponent&lt;/code&gt;'s own injector. &lt;code&gt;AppComponent&lt;/code&gt; services are available only to that component and its component tree. They have component scope.</source>
          <target state="translated">반대로 Angular 는 &lt;code&gt;AppComponent&lt;/code&gt; 자체 인젝터에 &lt;code&gt;AppComponent&lt;/code&gt; 제공자를 등록 합니다. &lt;code&gt;AppComponent&lt;/code&gt; 서비스는 해당 컴포넌트 및 해당 컴포넌트 트리에서만 사용할 수 있습니다. 구성 요소 범위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d00a813e7486c3605092212dc4aceb4cad4fd7d3" translate="yes" xml:space="preserve">
          <source>By convention, HTML attributes use lowercase names (&lt;code&gt;tabindex&lt;/code&gt;), while properties use camelCase names (&lt;code&gt;tabIndex&lt;/code&gt;).</source>
          <target state="translated">일반적으로 HTML 속성은 소문자 이름 ( &lt;code&gt;tabindex&lt;/code&gt; )을 사용하고 속성은 camelCase 이름 ( &lt;code&gt;tabIndex&lt;/code&gt; )을 사용합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
