<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="89c3a76b400f69bc409951d41f44580e1ce5b550" translate="yes" xml:space="preserve">
          <source>When a scripting language specific quoting is in effect, everything between a top-level opening atom and its matching %(end) is evaluated according to the semantics of the opening atom and only its result from the top-level is quoted.</source>
          <target state="translated">스크립팅 언어 별 인용이 유효 할 때 최상위 레벨 오프닝 원자와 일치하는 % (end) 사이의 모든 것이 오프닝 원자의 의미론에 따라 평가되며 최상위 레벨의 결과 만 인용됩니다.</target>
        </trans-unit>
        <trans-unit id="1d0d6b410e7d083b396401fa9485dd3214d89132" translate="yes" xml:space="preserve">
          <source>When a variable is said to take a boolean value, many synonyms are accepted for &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;; these are all case-insensitive.</source>
          <target state="translated">변수가 부울 값을 사용한다고 말하면 많은 동의어가 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 에 대해 허용됩니다 . 이것들은 모두 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="085e4eddfd9be8c4f3b576466769939a6475604e" translate="yes" xml:space="preserve">
          <source>When accepting a new code drop for a vendor branch, you probably want to record both the removal of paths and additions of new paths as well as modifications of existing paths.</source>
          <target state="translated">공급 업체 지점에 대한 새 코드 삭제를 승인 할 때 경로 제거 및 새 경로 추가 및 기존 경로 수정을 모두 기록하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98d4ec1ab85d43886cf359223c5c65ec41aa50b0" translate="yes" xml:space="preserve">
          <source>When accepting a signed push (see &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;), the signed push certificate is stored in a blob and an environment variable &lt;code&gt;GIT_PUSH_CERT&lt;/code&gt; can be consulted for its object name. See the description of &lt;code&gt;post-receive&lt;/code&gt; hook for an example. In addition, the certificate is verified using GPG and the result is exported with the following environment variables:</source>
          <target state="translated">서명 된 푸시를 수락하면 ( &lt;a href=&quot;git-push&quot;&gt;git-push [1] 참조&lt;/a&gt; ) 서명 된 푸시 인증서는 BLOB에 저장되고 해당 객체 이름에 대해 환경 변수 &lt;code&gt;GIT_PUSH_CERT&lt;/code&gt; 를 참조 할 수 있습니다. 예는 &lt;code&gt;post-receive&lt;/code&gt; 후크에 대한 설명을 참조하십시오 . 또한 인증서는 GPG를 사용하여 확인되며 결과는 다음 환경 변수와 함께 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="5d78f94855bee5654824b328b5c74fbbbf68d2ce" translate="yes" xml:space="preserve">
          <source>When acquiring credentials, consider the &quot;path&quot; component of an http or https URL to be important. Defaults to false. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for more information.</source>
          <target state="translated">신임 정보를 획득 할 때 http 또는 https URL의 &quot;경로&quot;구성 요소가 중요하다고 생각하십시오. 기본값은 false입니다. 자세한 내용은 &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="36125e3b1dadcf8415f427875bfbe6e3edb592ec" translate="yes" xml:space="preserve">
          <source>When adding notes to an object that already has notes, overwrite the existing notes (instead of aborting).</source>
          <target state="translated">이미 메모가있는 개체에 메모를 추가 할 때 중단 대신 기존 메모를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="31a6893d1f507cb4bce24b6631d6f67bbe0ca8c3" translate="yes" xml:space="preserve">
          <source>When advertising tips of available history from an alternate, use the shell to execute the specified command instead of &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;. The first argument is the absolute path of the alternate. Output must contain one hex object id per line (i.e., the same as produced by &lt;code&gt;git for-each-ref
--format='%(objectname)'&lt;/code&gt;).</source>
          <target state="translated">대체에서 사용 가능한 히스토리 팁을 광고 할 때 &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt; 대신 쉘을 사용하여 지정된 명령을 실행하십시오 . 첫 번째 인수는 대체의 절대 경로입니다. 출력은 라인 당 하나의 16 진 오브젝트 ID를 포함해야합니다 (즉, &lt;code&gt;git for-each-ref --format='%(objectname)'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="aee562f05eaa47b0988f9365fa4403a675334ce1" translate="yes" xml:space="preserve">
          <source>When an argument can be misunderstood as either a revision or a path, they can be disambiguated by placing &lt;code&gt;--&lt;/code&gt; between them. E.g. &lt;code&gt;git diff -- HEAD&lt;/code&gt; is, &quot;I have a file called HEAD in my work tree. Please show changes between the version I staged in the index and what I have in the work tree for that file&quot;, not &quot;show difference between the HEAD commit and the work tree as a whole&quot;. You can say &lt;code&gt;git diff HEAD --&lt;/code&gt; to ask for the latter.</source>
          <target state="translated">인수가 개정이나 경로 중 하나로 오해 할 수있을 때, 그들은 배치하여 명확화 할 수있다 &lt;code&gt;--&lt;/code&gt; 그들 사이. 예를 들어 &lt;code&gt;git diff -- HEAD&lt;/code&gt; 는 &quot;작업 트리에 HEAD라는 파일이 있습니다. 색인에서 준비한 버전과 해당 파일의 작업 트리에있는 버전 간의 변경 사항을 표시하십시오&quot;라는 차이점이 아니라 HEAD 커밋 및 작업 트리 전체 &quot; &lt;code&gt;git diff HEAD --&lt;/code&gt; 라고 말하면 후자를 요청할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ed1e316e9f06aa8f0fbb451acc5e5dd1d53d618" translate="yes" xml:space="preserve">
          <source>When an argument may be understood either as a reference or as a file name, choose to understand it as a format-patch argument (&lt;code&gt;--format-patch&lt;/code&gt;) or as a file name (&lt;code&gt;--no-format-patch&lt;/code&gt;). By default, when such a conflict occurs, git send-email will fail.</source>
          <target state="translated">인수가 참조 또는 파일 이름으로 이해 될 수있는 경우, 인수를 format-patch 인수 ( &lt;code&gt;--format-patch&lt;/code&gt; ) 또는 파일 이름 ( &lt;code&gt;--no-format-patch&lt;/code&gt; ) 으로 이해하도록 선택하십시오 . 기본적으로 이러한 충돌이 발생하면 git send-email이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="daa45faaafc93f57dcfa6219226fd8a2224c7353" translate="yes" xml:space="preserve">
          <source>When an interactive command (such as &lt;code&gt;git add --patch&lt;/code&gt;) shows a colorized diff, git will pipe the diff through the shell command defined by this configuration variable. The command may mark up the diff further for human consumption, provided that it retains a one-to-one correspondence with the lines in the original diff. Defaults to disabled (no filtering).</source>
          <target state="translated">대화식 명령 (예 : &lt;code&gt;git add --patch&lt;/code&gt; )에 색상 화 된 diff가 표시되면 git은이 구성 변수로 정의 된 쉘 명령을 통해 diff를 파이프합니다. 이 명령은 원래 diff의 라인과 일대일로 대응되는 경우 diff를 사람이 소비 할 수 있도록 추가로 마크 업할 수 있습니다. 기본값은 비활성화 (필터링 없음)입니다.</target>
        </trans-unit>
        <trans-unit id="66bd09d84d7f728fe64b22afe9c1d5b02faccf2f" translate="yes" xml:space="preserve">
          <source>When an optional Git branch name (or a Git commit object name) is specified as an argument, the subcommand works on the specified branch, not on the current branch.</source>
          <target state="translated">선택적 Git 브랜치 이름 (또는 Git 커밋 오브젝트 이름)이 인수로 지정되면 부속 명령은 현재 브랜치가 아닌 지정된 브랜치에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="54600ca959ccb5286a6125f852754e8a441f6246" translate="yes" xml:space="preserve">
          <source>When an update changes a branch (or more in general, a ref) that used to point at commit A to point at another commit B, it is called a fast-forward update if and only if B is a descendant of A.</source>
          <target state="translated">업데이트가 커밋 A를 가리키고 다른 커밋 B를 가리킬 때 사용 된 분기 (또는 일반적으로 ref)를 변경하면 B가 A의 자손 인 경우에만 업데이트를 빨리 감기라고합니다.</target>
        </trans-unit>
        <trans-unit id="b999dfcfa57d71ee62dbc42f4d8a0527e63491d1" translate="yes" xml:space="preserve">
          <source>When applying a patch, detect a new or modified line that has whitespace errors. What are considered whitespace errors is controlled by &lt;code&gt;core.whitespace&lt;/code&gt; configuration. By default, trailing whitespaces (including lines that solely consist of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors.</source>
          <target state="translated">패치를 적용 할 때 공백 오류가있는 새 줄이나 수정 된 줄을 찾으십시오. 공백 오류로 간주되는 것은 &lt;code&gt;core.whitespace&lt;/code&gt; 구성에 의해 제어됩니다 . 기본적으로 후행 공백 (공백만으로 구성되는 줄 포함)과 줄의 처음 들여 쓰기 안에 탭 문자가 뒤에 오는 공백 문자는 공백 오류로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b3581e25b4edfc3eae85f688560f931e31414d31" translate="yes" xml:space="preserve">
          <source>When applying a patch, ignore additions made by the patch. This can be used to extract the common part between two files by first running &lt;code&gt;diff&lt;/code&gt; on them and applying the result with this option, which would apply the deletion part but not the addition part.</source>
          <target state="translated">패치를 적용 할 때 패치가 추가 한 내용은 무시하십시오. 이 파일을 사용하여 먼저 &lt;code&gt;diff&lt;/code&gt; 를 실행 하고이 옵션으로 결과를 적용하여 두 파일 사이의 공통 부분을 추출하는 데 사용할 수 있습니다. 이 옵션은 삭제 부분을 적용하지만 추가 부분은 적용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6bf2c606b0bf760a50dfcc2e9e2a1dfc6d6ce1b9" translate="yes" xml:space="preserve">
          <source>When applying a patch, ignore changes in whitespace in context lines if necessary. Context lines will preserve their whitespace, and they will not undergo whitespace fixing regardless of the value of the &lt;code&gt;--whitespace&lt;/code&gt; option. New lines will still be fixed, though.</source>
          <target state="translated">패치를 적용 할 때 필요한 경우 컨텍스트 행에서 공백의 변경 사항을 무시하십시오. 상황에 맞는 줄은 공백을 유지하며 &lt;code&gt;--whitespace&lt;/code&gt; 옵션 의 값에 관계없이 공백을 수정하지 않습니다 . 그러나 새로운 줄은 여전히 ​​수정 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="588f408b6e1e0374e87fb8fe5ff6e5cd0dca42b8" translate="yes" xml:space="preserve">
          <source>When applying the patch only to the working tree, mark new files to be added to the index later (see &lt;code&gt;--intent-to-add&lt;/code&gt; option in &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;). This option is ignored unless running in a Git repository and &lt;code&gt;--index&lt;/code&gt; is not specified. Note that &lt;code&gt;--index&lt;/code&gt; could be implied by other options such as &lt;code&gt;--cached&lt;/code&gt; or &lt;code&gt;--3way&lt;/code&gt;.</source>
          <target state="translated">작업 트리에만 패치를 적용하는 경우 나중에 색인에 추가 할 새 파일을 표시하십시오 ( &lt;a href=&quot;git-add&quot;&gt;git-add [1]의 &lt;/a&gt; &lt;code&gt;--intent-to-add&lt;/code&gt; 옵션 참조 ). Git 리포지토리에서 실행 중이고 &lt;code&gt;--index&lt;/code&gt; 를 지정 하지 않으면이 옵션은 무시 됩니다. 참고 &lt;code&gt;--index&lt;/code&gt; 이 같은 다른 옵션을 암시 할 수 &lt;code&gt;--cached&lt;/code&gt; 또는 &lt;code&gt;--3way&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59fa333bf5332a3a74a0fa1b62097787ae41682d" translate="yes" xml:space="preserve">
          <source>When asking to &lt;code&gt;abort&lt;/code&gt; (which is the default), this program will die when encountering a signed tag. With &lt;code&gt;strip&lt;/code&gt;, the tags will silently be made unsigned, with &lt;code&gt;warn-strip&lt;/code&gt; they will be made unsigned but a warning will be displayed, with &lt;code&gt;verbatim&lt;/code&gt;, they will be silently exported and with &lt;code&gt;warn&lt;/code&gt;, they will be exported, but you will see a warning.</source>
          <target state="translated">&lt;code&gt;abort&lt;/code&gt; 요청하면 (기본값) 서명 된 태그가 발생하면이 프로그램이 종료됩니다. 함께 &lt;code&gt;strip&lt;/code&gt; 과 태그가 자동으로 서명되지 않은 될 것이다 &lt;code&gt;warn-strip&lt;/code&gt; 과, 그들이 서명하게되지만 경고가 표시됩니다 &lt;code&gt;verbatim&lt;/code&gt; , 그들은 자동으로 내 보냅니다과 함께 &lt;code&gt;warn&lt;/code&gt; , 그들은 내보낼 것이다, 그러나 경고가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="a094fa226ab8da9ad05df22ffe9e8c64cbd9aea9" translate="yes" xml:space="preserve">
          <source>When asking to &lt;code&gt;abort&lt;/code&gt; (which is the default), this program will die when encountering such a tag. With &lt;code&gt;drop&lt;/code&gt; it will omit such tags from the output. With &lt;code&gt;rewrite&lt;/code&gt;, if the tagged object is a commit, it will rewrite the tag to tag an ancestor commit (via parent rewriting; see &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;abort&lt;/code&gt; 요청할 때 (기본값)이 태그가 있으면이 프로그램이 종료됩니다. &lt;code&gt;drop&lt;/code&gt; 을 사용 하면 출력에서 ​​해당 태그를 생략합니다. 로 &lt;code&gt;rewrite&lt;/code&gt; 태깅 된 물체가있는 경우, A는 커밋이 조상 커밋 태그 태그 재기록한다 (재기록 부모를 통해, 참조 &lt;a href=&quot;git-rev-list&quot;&gt;자식-REV-목록 [1]&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="034f3e54dc418fd0aaba391926e4cdc6f9338cc5" translate="yes" xml:space="preserve">
          <source>When called with &lt;code&gt;--incremental&lt;/code&gt; option, the command outputs the result as it is built. The output generally will talk about lines touched by more recent commits first (i.e. the lines will be annotated out of order) and is meant to be used by interactive viewers.</source>
          <target state="translated">&lt;code&gt;--incremental&lt;/code&gt; 옵션 과 함께 호출 하면 명령이 빌드 될 때 결과를 출력합니다. 출력은 일반적으로 가장 최근의 커밋에 의해 먼저 터치 된 라인에 대해 이야기합니다 (즉, 라인에 순서가 주석 처리되지 않음). 인터랙티브 뷰어가 사용합니다.</target>
        </trans-unit>
        <trans-unit id="37ed40c0b9c191bc52be1eea56e95c21c8c30c92" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, check out stage #2 (&lt;code&gt;ours&lt;/code&gt;) or #3 (&lt;code&gt;theirs&lt;/code&gt;) for unmerged paths.</source>
          <target state="translated">인덱스에서 경로를 조사한 결과에 의하면,이 스테이지 # 2 (체크 아웃 &lt;code&gt;ours&lt;/code&gt; ) 또는 # 3 ( &lt;code&gt;theirs&lt;/code&gt; 병합 경로에 대한 참조).</target>
        </trans-unit>
        <trans-unit id="b2d7eb083886da1526ca38a6780f9e98825df5e6" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, do not fail upon unmerged entries; instead, unmerged entries are ignored.</source>
          <target state="translated">색인에서 경로를 체크 아웃 할 때 병합되지 않은 항목에 실패하지 마십시오. 대신 병합되지 않은 항목은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="87b021689017efd0b4fbe642f48fde6408f7cde4" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, this option lets you recreate the conflicted merge in the specified paths.</source>
          <target state="translated">인덱스에서 경로를 체크 아웃 할 때이 옵션을 사용하면 지정된 경로에서 충돌 병합을 다시 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44968c91f62b2f1c7eb77848556b128eac9d4512" translate="yes" xml:space="preserve">
          <source>When cloning an SVN repository, if none of the options for describing the repository layout is used (--trunk, --tags, --branches, --stdlayout), &lt;code&gt;git svn clone&lt;/code&gt; will create a Git repository with completely linear history, where branches and tags appear as separate directories in the working copy. While this is the easiest way to get a copy of a complete repository, for projects with many branches it will lead to a working copy many times larger than just the trunk. Thus for projects using the standard directory structure (trunk/branches/tags), it is recommended to clone with option &lt;code&gt;--stdlayout&lt;/code&gt;. If the project uses a non-standard structure, and/or if branches and tags are not required, it is easiest to only clone one directory (typically trunk), without giving any repository layout options. If the full history with branches and tags is required, the options &lt;code&gt;--trunk&lt;/code&gt; / &lt;code&gt;--branches&lt;/code&gt; / &lt;code&gt;--tags&lt;/code&gt; must be used.</source>
          <target state="translated">SVN 저장소를 복제 할 때 저장소 레이아웃을 설명하는 옵션이 사용되지 않으면 (--trunk, --tags, --branches, --stdlayout) &lt;code&gt;git svn clone&lt;/code&gt; 은 완전히 선형적인 히스토리가있는 Git 저장소를 작성합니다. 분기 및 태그는 작업 복사본에서 별도의 디렉토리로 나타납니다. 이것이 완전한 저장소의 사본을 얻는 가장 쉬운 방법이지만 분기가 많은 프로젝트의 경우 트렁크보다 몇 배 더 큰 작업 사본으로 이어질 것입니다. 따라서 표준 디렉토리 구조 (트렁크 / 분기 / 태그)를 사용하는 프로젝트의 경우 &lt;code&gt;--stdlayout&lt;/code&gt; 옵션을 사용하여 복제하는 것이 좋습니다.. 프로젝트가 비표준 구조를 사용하거나 분기 및 태그가 필요하지 않은 경우 저장소 레이아웃 옵션을 제공하지 않고 하나의 디렉토리 (일반적으로 트렁크) 만 복제하는 것이 가장 쉽습니다. 브랜치와 태그와 전체 역사는이 필요한 경우, 옵션은 &lt;code&gt;--trunk&lt;/code&gt; / &lt;code&gt;--branches&lt;/code&gt; / &lt;code&gt;--tags&lt;/code&gt; 가 사용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="cf5bdc8ee9de0e891bd2e2ffd6ad5374a27fb398" translate="yes" xml:space="preserve">
          <source>When cloning or pulling a repository containing submodules the submodules will not be checked out by default; You can instruct &lt;code&gt;clone&lt;/code&gt; to recurse into submodules. The &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; subcommands of &lt;code&gt;git submodule&lt;/code&gt; will maintain submodules checked out and at an appropriate revision in your working tree. Alternatively you can set &lt;code&gt;submodule.recurse&lt;/code&gt; to have &lt;code&gt;checkout&lt;/code&gt; recursing into submodules.</source>
          <target state="translated">서브 모듈을 포함하는 저장소를 복제하거나 가져올 때 서브 모듈은 기본적으로 체크 아웃되지 않습니다. &lt;code&gt;clone&lt;/code&gt; 가 하위 모듈로 재귀 하도록 지시 할 수 있습니다 . &lt;code&gt;git submodule&lt;/code&gt; 의 &lt;code&gt;init&lt;/code&gt; 및 &lt;code&gt;update&lt;/code&gt; 하위 명령은 하위 트리를 체크 아웃 한 상태로 작업 트리에서 적절히 수정합니다. 또는 &lt;code&gt;submodule.recurse&lt;/code&gt; 를 설정 하여 &lt;code&gt;checkout&lt;/code&gt; 서브 모듈 로 되풀이되도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2bdda0ba49ff183f8b76fb42fb3146b89e404d42" translate="yes" xml:space="preserve">
          <source>When cloning or pulling a repository containing submodules the submodules will not be checked out by default; you can instruct &lt;code&gt;clone&lt;/code&gt; to recurse into submodules. The &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; subcommands of &lt;code&gt;git submodule&lt;/code&gt; will maintain submodules checked out and at an appropriate revision in your working tree. Alternatively you can set &lt;code&gt;submodule.recurse&lt;/code&gt; to have &lt;code&gt;checkout&lt;/code&gt; recursing into submodules (note that &lt;code&gt;submodule.recurse&lt;/code&gt; also affects other Git commands, see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for a complete list).</source>
          <target state="translated">하위 모듈을 포함하는 저장소를 복제하거나 가져올 때 하위 모듈은 기본적으로 체크 아웃되지 않습니다. &lt;code&gt;clone&lt;/code&gt; 에게 하위 모듈로 재귀 하도록 지시 할 수 있습니다 . &lt;code&gt;git submodule&lt;/code&gt; 의 &lt;code&gt;init&lt;/code&gt; 및 &lt;code&gt;update&lt;/code&gt; 하위 명령은 하위 모듈을 체크 아웃하고 작업 트리의 적절한 개정판으로 유지합니다. 또는 &lt;code&gt;submodule.recurse&lt;/code&gt; 를 설정 하여 &lt;code&gt;checkout&lt;/code&gt; 하위 모듈 로 반복되도록 할 수 있습니다 ( &lt;code&gt;submodule.recurse&lt;/code&gt; 는 다른 Git 명령에도 영향을줍니다 . 전체 목록 은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6d739b21b6194611c8a45df16bb823ac3b01a4bd" translate="yes" xml:space="preserve">
          <source>When combined with the &lt;code&gt;run&lt;/code&gt; subcommand, run maintenance tasks only if certain thresholds are met. For example, the &lt;code&gt;gc&lt;/code&gt; task runs when the number of loose objects exceeds the number stored in the &lt;code&gt;gc.auto&lt;/code&gt; config setting, or when the number of pack-files exceeds the &lt;code&gt;gc.autoPackLimit&lt;/code&gt; config setting. Not compatible with the &lt;code&gt;--schedule&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 하위 명령 과 함께 사용 하면 특정 임계 값이 충족되는 경우에만 유지 관리 작업을 실행합니다. 예를 들어 느슨한 객체의 수가 &lt;code&gt;gc.auto&lt;/code&gt; config 설정에 저장된 수를 초과 하거나 pack-file의 수가 &lt;code&gt;gc.autoPackLimit&lt;/code&gt; 구성 설정을 초과 할 때 &lt;code&gt;gc&lt;/code&gt; 작업이 실행됩니다 . &lt;code&gt;--schedule&lt;/code&gt; 옵션 과 호환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="61eed3296a596b65de979964c073754bc8210abb" translate="yes" xml:space="preserve">
          <source>When combined with the &lt;code&gt;run&lt;/code&gt; subcommand, run maintenance tasks only if certain time conditions are met, as specified by the &lt;code&gt;maintenance.&amp;lt;task&amp;gt;.schedule&lt;/code&gt; config value for each &lt;code&gt;&amp;lt;task&amp;gt;&lt;/code&gt;. This config value specifies a number of seconds since the last time that task ran, according to the &lt;code&gt;maintenance.&amp;lt;task&amp;gt;.lastRun&lt;/code&gt; config value. The tasks that are tested are those provided by the &lt;code&gt;--task=&amp;lt;task&amp;gt;&lt;/code&gt; option(s) or those with &lt;code&gt;maintenance.&amp;lt;task&amp;gt;.enabled&lt;/code&gt; set to true.</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 하위 명령 과 결합 된 경우 각 &lt;code&gt;&amp;lt;task&amp;gt;&lt;/code&gt; 에 대한 &lt;code&gt;maintenance.&amp;lt;task&amp;gt;.schedule&lt;/code&gt; 구성 값에 지정된대로 특정 시간 조건이 충족되는 경우에만 유지 관리 작업을 실행합니다 . 이 구성 값은 &lt;code&gt;maintenance.&amp;lt;task&amp;gt;.lastRun&lt;/code&gt; 구성 값 에 따라 작업이 마지막으로 실행 된 이후의 시간 (초)을 지정 합니다. 테스트되는 작업은 &lt;code&gt;--task=&amp;lt;task&amp;gt;&lt;/code&gt; 옵션으로 제공되는 작업 또는 &lt;code&gt;maintenance.&amp;lt;task&amp;gt;.enabled&lt;/code&gt; 가 true로 설정된 작업 입니다.</target>
        </trans-unit>
        <trans-unit id="e96f700dec6ecf67635f001fe97af20a3a1af7ba" translate="yes" xml:space="preserve">
          <source>When combining multiple &lt;code&gt;--contains&lt;/code&gt; and &lt;code&gt;--no-contains&lt;/code&gt; filters, only references that contain at least one of the &lt;code&gt;--contains&lt;/code&gt; commits and contain none of the &lt;code&gt;--no-contains&lt;/code&gt; commits are shown.</source>
          <target state="translated">여러 &lt;code&gt;--contains&lt;/code&gt; 및 &lt;code&gt;--no-contains&lt;/code&gt; 필터를 결합 할 때 &lt;code&gt;--contains&lt;/code&gt; 커밋 중 하나 이상을 포함 하고 &lt;code&gt;--no-contains&lt;/code&gt; 커밋을 포함하지 않는 참조 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3693ecef45adf0e594fc21eeb7dc1180a98b303e" translate="yes" xml:space="preserve">
          <source>When combining multiple &lt;code&gt;--merged&lt;/code&gt; and &lt;code&gt;--no-merged&lt;/code&gt; filters, only references that are reachable from at least one of the &lt;code&gt;--merged&lt;/code&gt; commits and from none of the &lt;code&gt;--no-merged&lt;/code&gt; commits are shown.</source>
          <target state="translated">여러 개의 &lt;code&gt;--merged&lt;/code&gt; 및 &lt;code&gt;--no-merged&lt;/code&gt; 필터를 결합 할 때 &lt;code&gt;--merged&lt;/code&gt; 커밋 중 하나 이상에서 도달 할 수 있고 &lt;code&gt;--no-merged&lt;/code&gt; 커밋 중 하나에서도 도달 할 수있는 참조 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f6f5e261fa8e1325a05e77f0fa02cd4e804a016b" translate="yes" xml:space="preserve">
          <source>When committing fixups, consider using &lt;code&gt;merge&lt;/code&gt; to connect the commit(s) which are supplying file revisions to the fixup branch. Doing so will allow tools such as &lt;code&gt;git blame&lt;/code&gt; to track through the real commit history and properly annotate the source files.</source>
          <target state="translated">수정 사항을 커미트 할 때 &lt;code&gt;merge&lt;/code&gt; 을 사용하여 파일 개정판을 제공하는 커미트를 수정 사항 브랜치에 연결하십시오. 그렇게하면 &lt;code&gt;git blame&lt;/code&gt; 과 같은 도구 가 실제 커밋 기록을 추적하고 소스 파일에 주석을 달 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="187746ad8497cb1dac2dfe493269450955422d85" translate="yes" xml:space="preserve">
          <source>When committing to svn from Git (as part of &lt;code&gt;set-tree&lt;/code&gt; or &lt;code&gt;dcommit&lt;/code&gt; operations), if the existing log message doesn&amp;rsquo;t already have a &lt;code&gt;From:&lt;/code&gt; or &lt;code&gt;Signed-off-by:&lt;/code&gt; line, append a &lt;code&gt;From:&lt;/code&gt; line based on the Git commit&amp;rsquo;s author string. If you use this, then &lt;code&gt;--use-log-author&lt;/code&gt; will retrieve a valid author string for all commits.</source>
          <target state="translated">&lt;code&gt;set-tree&lt;/code&gt; 또는 &lt;code&gt;dcommit&lt;/code&gt; 작업의 일부로 Git에서 svn을 커밋 할 때 기존 로그 메시지에 &lt;code&gt;From:&lt;/code&gt; 또는 &lt;code&gt;Signed-off-by:&lt;/code&gt; 행 이없는 경우 Git 커밋을 기반으로 &lt;code&gt;From:&lt;/code&gt; 행을 추가하십시오 . 저자 문자열. 이것을 사용하면 &lt;code&gt;--use-log-author&lt;/code&gt; 는 모든 커밋에 대해 유효한 작성자 문자열을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="93d9f9b7d88e7e5ba3d52728cd609bd56e74440d" translate="yes" xml:space="preserve">
          <source>When committing to svn from Git (as part of &lt;code&gt;set-tree&lt;/code&gt; or &lt;code&gt;dcommit&lt;/code&gt; operations), if the existing log message doesn&amp;rsquo;t already have a &lt;code&gt;From:&lt;/code&gt; or &lt;code&gt;Signed-off-by&lt;/code&gt; trailer, append a &lt;code&gt;From:&lt;/code&gt; line based on the Git commit&amp;rsquo;s author string. If you use this, then &lt;code&gt;--use-log-author&lt;/code&gt; will retrieve a valid author string for all commits.</source>
          <target state="translated">Git에서 svn에 커밋 할 때 ( &lt;code&gt;set-tree&lt;/code&gt; 또는 &lt;code&gt;dcommit&lt;/code&gt; 작업의 일부로 ) 기존 로그 메시지에 아직 &lt;code&gt;From:&lt;/code&gt; 또는 &lt;code&gt;Signed-off-by&lt;/code&gt; 트레일러 가없는 경우 Git 커밋의 작성자에 따라 &lt;code&gt;From:&lt;/code&gt; 줄을 추가합니다 . 끈. 이것을 사용하면 &lt;code&gt;--use-log-author&lt;/code&gt; 는 모든 커밋에 대해 유효한 작성자 문자열을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="df4d9e8de337675930b7c7d126c3cbfdb0d919e8" translate="yes" xml:space="preserve">
          <source>When common porcelain operations that create objects are run, they will check whether the repository has grown substantially since the last maintenance, and if so run &lt;code&gt;git gc&lt;/code&gt; automatically. See &lt;code&gt;gc.auto&lt;/code&gt; below for how to disable this behavior.</source>
          <target state="translated">객체를 생성하는 일반적인 도자기 작업이 실행될 때 리포지토리가 마지막 유지 관리 이후 실질적으로 커 졌는지 확인하고 &lt;code&gt;git gc&lt;/code&gt; 를 자동으로 실행 합니다. 이 동작을 비활성화하는 방법은 아래 &lt;code&gt;gc.auto&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5cef5cc19d56f034a0850f6ce0dc6add0c966a70" translate="yes" xml:space="preserve">
          <source>When comparing two trees, the ID of both trees (separated by a space and terminated by a newline) is printed before the difference. When comparing commits, the ID of the first (or only) commit, followed by a newline, is printed.</source>
          <target state="translated">두 트리를 비교할 때 두 트리의 ID (공백으로 구분되고 줄 바꾸기로 종료 됨)가 차이 전에 인쇄됩니다. 커밋을 비교할 때 첫 번째 (또는 유일한) 커밋의 ID와 그 뒤에 줄 바꿈이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="fe249445673b1134855083e0c3b366c4aeeb2c8e" translate="yes" xml:space="preserve">
          <source>When converting a value to its canonical form using the &lt;code&gt;--type=bool&lt;/code&gt; type specifier, &lt;code&gt;git config&lt;/code&gt; will ensure that the output is &quot;true&quot; or &quot;false&quot; (spelled in lowercase).</source>
          <target state="translated">&lt;code&gt;--type=bool&lt;/code&gt; 유형 지정자를 사용하여 값을 표준 형식으로 변환 할 때 &lt;code&gt;git config&lt;/code&gt; 는 출력이 &quot;true&quot;또는 &quot;false&quot;(소문자로 표시)인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5800d8777d6f116b967a3c4b503079e04a8dd27b" translate="yes" xml:space="preserve">
          <source>When copying a remote repository, you&amp;rsquo;ll want to at a minimum update the index cache when you do this, and especially with other peoples' repositories you often want to make sure that the index cache is in some known state (you don&amp;rsquo;t know &lt;strong&gt;what&lt;/strong&gt; they&amp;rsquo;ve done and not yet checked in), so usually you&amp;rsquo;ll precede the &lt;code&gt;git update-index&lt;/code&gt; with a</source>
          <target state="translated">원격 리포지토리를 복사 할 때는 인덱스 캐시를 최소한 업데이트해야하며, 특히 다른 사람의 리포지토리를 사용하는 경우 인덱스 캐시가 알려진 상태에 있는지 확인하려고합니다. 그들이 &lt;strong&gt;무엇&lt;/strong&gt; 을했고 아직 체크인하지 않았 &lt;strong&gt;는지&lt;/strong&gt; 알기 때문에 일반적으로 &lt;code&gt;git update-index&lt;/code&gt; 앞에 a</target>
        </trans-unit>
        <trans-unit id="a0c9c076efebd050282e8220820bf37e469a5914" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite (see the &quot;notes.rewrite.&amp;lt;command&amp;gt;&quot; option), determines what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. Defaults to &lt;code&gt;concatenate&lt;/code&gt;.</source>
          <target state="translated">다시 쓰는 동안 메모를 복사 할 때 ( &quot;notes.rewrite. &amp;lt;command&amp;gt;&quot;옵션 참조) 대상 커밋에 이미 메모가있는 경우 수행 할 작업을 결정합니다. &lt;code&gt;overwrite&lt;/code&gt; , &lt;code&gt;concatenate&lt;/code&gt; , &lt;code&gt;cat_sort_uniq&lt;/code&gt; 또는 &lt;code&gt;ignore&lt;/code&gt; 중 하나 여야합니다 . &lt;code&gt;concatenate&lt;/code&gt; 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="f2daf889c63a8ae3ef0bd84b9e0a7bae3186ea5d" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied. May be a glob, in which case notes in all matching refs will be copied. You may also specify this configuration several times.</source>
          <target state="translated">다시 쓰는 동안 메모를 복사 할 때 메모를 복사해야하는 정규화 된 참조를 지정합니다. glob 일 수 있으며,이 경우 일치하는 모든 참조의 메모가 복사됩니다. 이 구성을 여러 번 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c445d369a5c50740a59f3ad28697ace644e2811e" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied. The ref may be a glob, in which case notes in all matching refs will be copied. You may also specify this configuration several times.</source>
          <target state="translated">다시 쓰는 동안 메모를 복사 할 때 메모를 복사해야하는 정규화 된 참조를 지정합니다. 심판은 글로브 일 수 있으며,이 경우 일치하는 모든 심판의 노트가 복사됩니다. 이 구성을 여러 번 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1243aaab79ff33e7a2d49c8eb8b4f16703a1c016" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. Defaults to &lt;code&gt;concatenate&lt;/code&gt;.</source>
          <target state="translated">다시 쓰는 동안 메모를 복사 할 때 대상 커밋에 이미 메모가있는 경우 수행 할 작업입니다. &lt;code&gt;overwrite&lt;/code&gt; , &lt;code&gt;concatenate&lt;/code&gt; , &lt;code&gt;cat_sort_uniq&lt;/code&gt; 또는 &lt;code&gt;ignore&lt;/code&gt; 중 하나 여야합니다 . &lt;code&gt;concatenate&lt;/code&gt; 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="fb6ea94e62e06bb5ee870300111df0d9f630f320" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. This overrides the &lt;code&gt;core.rewriteMode&lt;/code&gt; setting.</source>
          <target state="translated">다시 쓰는 동안 메모를 복사 할 때 대상 커밋에 이미 메모가있는 경우 수행 할 작업입니다. &lt;code&gt;overwrite&lt;/code&gt; , &lt;code&gt;concatenate&lt;/code&gt; , &lt;code&gt;cat_sort_uniq&lt;/code&gt; 또는 &lt;code&gt;ignore&lt;/code&gt; 중 하나 여야합니다 . 이것은 &lt;code&gt;core.rewriteMode&lt;/code&gt; 설정을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="fa7e030aba2e9a9a4e5882753f19d2b4a66b4e16" translate="yes" xml:space="preserve">
          <source>When creating a new branch, if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a branch, mark it as &quot;upstream&quot; from the new branch. This is the default if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a remote-tracking branch. See &quot;--track&quot; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">새 분기를 만들 때 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 가 분기 인 경우 새 분기에서 &quot;업스트림&quot;으로 표시하십시오. &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 가 원격 추적 분기 인 경우 이것이 기본값 입니다. 자세한 내용은 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]의&lt;/a&gt; &quot;--track&quot; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4e04dc75cba18b40521f918d2128a9cc7f50298f" translate="yes" xml:space="preserve">
          <source>When creating a new branch, if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a branch, mark it as &quot;upstream&quot; from the new branch. This is the default if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a remote-tracking branch. See &lt;code&gt;--track&lt;/code&gt; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">새 브랜치를 만들 때 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 가 브랜치이면 새 브랜치에서 &quot;업스트림&quot;으로 표시합니다. &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 가 원격 추적 분기 인 경우 이것이 기본값 입니다. 자세한 내용 은 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]의 &lt;/a&gt; &lt;code&gt;--track&lt;/code&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="54d8049451fa958ada38921d90347d3ee7c4d771" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &quot;upstream&quot; configuration. &lt;code&gt;-c&lt;/code&gt; is implied. See &lt;code&gt;--track&lt;/code&gt; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">새 브랜치를 생성 할 때 &quot;업스트림&quot;구성을 설정하십시오. &lt;code&gt;-c&lt;/code&gt; 가 암시됩니다. 자세한 내용 은 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]의 &lt;/a&gt; &lt;code&gt;--track&lt;/code&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="fc590aa31fec73c4296b9f428640a84b6d3e91a7" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &quot;upstream&quot; configuration. See &quot;--track&quot; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">새 브랜치를 생성 할 때 &quot;업스트림&quot;구성을 설정하십시오. 자세한 내용은 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]의&lt;/a&gt; &quot;--track&quot; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="67211ea9327a11f7c102d4d6622e44707e57316e" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; configuration entries to mark the start-point branch as &quot;upstream&quot; from the new branch. This configuration will tell git to show the relationship between the two branches in &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git branch -v&lt;/code&gt;. Furthermore, it directs &lt;code&gt;git pull&lt;/code&gt; without arguments to pull from the upstream when the new branch is checked out.</source>
          <target state="translated">새 분기를 만들 때는 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 및 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 구성 항목을 설정하여 새 분기에서 시작 지점을 &quot;업스트림&quot;으로 표시하십시오. 이 설정은 git에게 &lt;code&gt;git status&lt;/code&gt; 와 &lt;code&gt;git branch -v&lt;/code&gt; 의 두 브랜치 사이의 관계를 보여줄 것을 지시합니다 . 또한 새로운 분기가 체크 아웃 될 때 인수없이 &lt;code&gt;git pull&lt;/code&gt; 이 업스트림에서 끌어 오도록 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="30421c6d8900807173aa121649f943a72b9b4dbe" translate="yes" xml:space="preserve">
          <source>When creating a packed archive in a repository that has existing packs, the command reuses existing deltas. This sometimes results in a slightly suboptimal pack. This flag tells the command not to reuse existing deltas but compute them from scratch.</source>
          <target state="translated">기존 팩이있는 저장소에서 묶음 아카이브를 작성할 때 명령은 기존 델타를 재사용합니다. 이로 인해 때때로 약간 차선책이됩니다. 이 플래그는 명령에 기존 델타를 재사용하지 말고 처음부터 계산하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="40641904740525d3a46d2f53ea1f042429403d62" translate="yes" xml:space="preserve">
          <source>When creating files, prepend &amp;lt;string&amp;gt; (usually a directory including a trailing /)</source>
          <target state="translated">파일을 만들 때 &amp;lt;string&amp;gt;을 추가하십시오 (일반적으로 후행 /를 포함하는 디렉토리)</target>
        </trans-unit>
        <trans-unit id="55d2573d14b31c180f96244b6210a62251fe4b79" translate="yes" xml:space="preserve">
          <source>When dealing with &lt;code&gt;git diff-tree&lt;/code&gt; output, it takes advantage of the fact that the patch is prefixed with the object name of the commit, and outputs two 40-byte hexadecimal strings. The first string is the patch ID, and the second string is the commit ID. This can be used to make a mapping from patch ID to commit ID.</source>
          <target state="translated">&lt;code&gt;git diff-tree&lt;/code&gt; 출력을 다룰 때 , 패치는 커밋의 객체 이름으로 접두사가 붙고 2 개의 40 바이트 16 진 문자열을 출력한다는 사실을 이용합니다. 첫 번째 문자열은 패치 ID이고 두 번째 문자열은 커밋 ID입니다. 패치 ID에서 커밋 ID로 매핑하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d776ef3252048cd13183a8501d7c0015731386cd" translate="yes" xml:space="preserve">
          <source>When deciding what attributes are assigned to a path, Git consults &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; file (which has the highest precedence), &lt;code&gt;.gitattributes&lt;/code&gt; file in the same directory as the path in question, and its parent directories up to the toplevel of the work tree (the further the directory that contains &lt;code&gt;.gitattributes&lt;/code&gt; is from the path in question, the lower its precedence). Finally global and system-wide files are considered (they have the lowest precedence).</source>
          <target state="translated">경로에 할당 할 속성을 결정할 때 Git은 &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; 파일 (가장 높은 우선 순위), 해당 경로와 동일한 디렉토리에있는 &lt;code&gt;.gitattributes&lt;/code&gt; 파일 및 상위 디렉토리까지 상위 디렉토리를 참조합니다. 작업 트리 ( &lt;code&gt;.gitattributes&lt;/code&gt; 를 포함하는 디렉토리가 멀면 문제의 경로에서 멀어 질수록 우선 순위가 낮습니다). 마지막으로 전역 및 시스템 전체 파일이 고려됩니다 (가장 낮은 우선 순위를 가짐).</target>
        </trans-unit>
        <trans-unit id="be47e73cae5925c270f0353e0b448f44fba38688" translate="yes" xml:space="preserve">
          <source>When deinitialized or deleted (see below), the submodule&amp;rsquo;s Git directory is automatically moved to &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; of the superproject.</source>
          <target state="translated">초기화가 해제되거나 삭제되면 (아래 참조) 서브 모듈의 Git 디렉토리는 자동으로 수퍼 &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; 으로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="d6198e5c096df70165a4ba7282b14c9062838d85" translate="yes" xml:space="preserve">
          <source>When displaying names of reachable objects, in addition to the SHA-1 also display a name that describes &lt;strong&gt;how&lt;/strong&gt; they are reachable, compatible with &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;, e.g. &lt;code&gt;HEAD@{1234567890}~25^2:src/&lt;/code&gt;.</source>
          <target state="translated">도달 가능한 객체의 이름을 표시 할 때 SHA-1 외에도 &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt; 과 호환되는 &lt;strong&gt;방법 (&lt;/strong&gt; 예 : &lt;code&gt;HEAD@{1234567890}~25^2:src/&lt;/code&gt; 을 설명 &lt;strong&gt;하는&lt;/strong&gt; 이름도 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="39ccc422d97039f55d5b75b982904e65809f0ab0" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in a porcelain-ready format. See &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; for details. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">드라이-런을 수행 할 때는 출력을 도자기 준비 형식으로 제공하십시오. 자세한 내용은 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 를 참조하십시오. &lt;code&gt;--dry-run&lt;/code&gt; 을 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="91fdf83cd4cf2351c13b94fc0d59dcd9a51c5b73" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in the long-format. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">드라 이런을 수행 할 때는 출력을 긴 형식으로 제공하십시오. &lt;code&gt;--dry-run&lt;/code&gt; 을 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="7320eee3c7f6d76666dfe697952518d827846a03" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in the short-format. See &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; for details. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">드라 이런을 수행 할 때는 짧은 형식으로 출력하십시오. 자세한 내용은 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 를 참조하십시오. &lt;code&gt;--dry-run&lt;/code&gt; 을 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="9aa102d4a4b04252e6d4b5a0080dce309ef777d4" translate="yes" xml:space="preserve">
          <source>When doing a repository conversion, use a unique mark per commit (&lt;code&gt;mark :&amp;lt;n&amp;gt;&lt;/code&gt;) and supply the --export-marks option on the command line. fast-import will dump a file which lists every mark and the Git object SHA-1 that corresponds to it. If the frontend can tie the marks back to the source repository, it is easy to verify the accuracy and completeness of the import by comparing each Git commit to the corresponding source revision.</source>
          <target state="translated">저장소 변환을 수행 할 때 고유 한 커밋 당 표시 ( &lt;code&gt;mark :&amp;lt;n&amp;gt;&lt;/code&gt; )를 사용하고 명령 행에 --export-marks 옵션을 제공하십시오. fast-import는 모든 마크와 이에 해당하는 Git 객체 SHA-1을 나열하는 파일을 덤프합니다. 프론트 엔드가 마크를 소스 리포지토리에 다시 연결할 수있는 경우 각 Git 커밋을 해당 소스 개정과 비교하여 가져 오기의 정확성과 완전성을 쉽게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f397bf185a0b1be7403f8c718221517e54d79b2" translate="yes" xml:space="preserve">
          <source>When editing the commit message, start the editor with the contents in the given file. The &lt;code&gt;commit.template&lt;/code&gt; configuration variable is often used to give this option implicitly to the command. This mechanism can be used by projects that want to guide participants with some hints on what to write in the message in what order. If the user exits the editor without editing the message, the commit is aborted. This has no effect when a message is given by other means, e.g. with the &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; options.</source>
          <target state="translated">커밋 메시지를 편집 할 때 주어진 파일의 내용으로 편집기를 시작하십시오. &lt;code&gt;commit.template&lt;/code&gt; 의 구성 변수는 종종 명령에 암시 적으로이 옵션을 제공하는 데 사용됩니다. 이 메커니즘은 메시지에 어떤 순서로 작성해야하는지에 대한 힌트를 참가자에게 안내하려는 프로젝트에서 사용할 수 있습니다. 사용자가 메시지를 편집하지 않고 편집기를 종료하면 커밋이 중단됩니다. 메시지가 다른 수단 (예 : &lt;code&gt;-m&lt;/code&gt; 또는 &lt;code&gt;-F&lt;/code&gt; 옵션 )으로 제공되는 경우에는 효과가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7835173f74e58e15c8891f5a3e0b3af743fd1c66" translate="yes" xml:space="preserve">
          <source>When editing, provide the raw object contents rather than pretty-printed ones. Currently this only affects trees, which will be shown in their binary form. This is harder to work with, but can help when repairing a tree that is so corrupted it cannot be pretty-printed. Note that you may need to configure your editor to cleanly read and write binary data.</source>
          <target state="translated">편집 할 때 예쁘게 인쇄 된 것이 아니라 원시 객체 내용을 제공하십시오. 현재 이것은 나무에만 영향을 미치며 이진 형식으로 표시됩니다. 이것은 작업하기가 어렵지만 너무 손상된 나무를 고칠 때는 꽤 인쇄 할 수 없습니다. 이진 데이터를 깨끗하게 읽고 쓰도록 편집기를 구성해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce47e94310de9fcb0d82c1f052bbcc38f3a11f76" translate="yes" xml:space="preserve">
          <source>When enabled, the default &lt;code&gt;post-update&lt;/code&gt; hook runs &lt;code&gt;git update-server-info&lt;/code&gt; to keep the information used by dumb transports (e.g., HTTP) up to date. If you are publishing a Git repository that is accessible via HTTP, you should probably enable this hook.</source>
          <target state="translated">활성화 된 경우 기본 &lt;code&gt;post-update&lt;/code&gt; 후크는 &lt;code&gt;git update-server-info&lt;/code&gt; 를 실행 하여 바보 전송 (예 : HTTP)에서 사용하는 정보를 최신 상태로 유지합니다. HTTP를 통해 액세스 할 수있는 Git 저장소를 공개하는 경우이 후크를 사용 가능하게해야합니다.</target>
        </trans-unit>
        <trans-unit id="a529b1482d7666548417edb1d901df1240194350" translate="yes" xml:space="preserve">
          <source>When encountering a non-ASCII message or subject that does not declare its encoding, add headers/quoting to indicate it is encoded in &amp;lt;encoding&amp;gt;. Default is the value of the &lt;code&gt;sendemail.assume8bitEncoding&lt;/code&gt;; if that is unspecified, this will be prompted for if any non-ASCII files are encountered.</source>
          <target state="translated">비 ASCII 메시지 또는 인코딩을 선언하지 않은 제목이 나타나면 &amp;lt;encoding&amp;gt;으로 인코딩되었음을 나타내는 헤더 / 인용 부호를 추가하십시오. 기본값은 &lt;code&gt;sendemail.assume8bitEncoding&lt;/code&gt; 의 값입니다 . 지정되지 않은 경우 비 ASCII 파일이 있는지 묻는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c331bd8bb74634e4f18684aaa53f36ba8f8cf37d" translate="yes" xml:space="preserve">
          <source>When erasing credentials, matching credentials will be erased from all files.</source>
          <target state="translated">자격 증명을 지우면 일치하는 자격 증명이 모든 파일에서 지워집니다.</target>
        </trans-unit>
        <trans-unit id="74e58a3904b06fc63c005d33dc33b553098868b7" translate="yes" xml:space="preserve">
          <source>When extensions.worktreeConfig is enabled, the config file &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; is read after &lt;code&gt;.git/config&lt;/code&gt; is.</source>
          <target state="translated">extensions.worktreeConfig가 활성화되면 &lt;code&gt;.git/config&lt;/code&gt; 가 실행 된 후 구성 파일 &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; 를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="3a73371934954e7de3c00c5b21339d1552e97b06" translate="yes" xml:space="preserve">
          <source>When false, merge the current branch into the upstream branch.</source>
          <target state="translated">false 인 경우 현재 분기를 업스트림 분기로 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="d5dfb7a500ca38e6f311c3fe54f4fbaf71bc47ce" translate="yes" xml:space="preserve">
          <source>When fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of &lt;code&gt;remote.*.fetch&lt;/code&gt; configuration variables for the remote repository. Providing an empty &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; to the &lt;code&gt;--refmap&lt;/code&gt; option causes Git to ignore the configured refspecs and rely entirely on the refspecs supplied as command-line arguments. See section on &quot;Configured Remote-tracking Branches&quot; for details.</source>
          <target state="translated">명령 줄에 나열된 참조를 &lt;code&gt;remote.*.fetch&lt;/code&gt; 때 원격 저장소에 대한 remote. *. fetch 구성 변수 값 대신 지정된 참조 사양 (두 번 이상 제공 가능)을 사용하여 참조를 원격 추적 분기에 매핑 합니다. &lt;code&gt;--refmap&lt;/code&gt; 옵션에 빈 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 을 제공 하면 Git은 구성된 refspec 을 무시하고 명령 줄 인수로 제공된 refspec에 전적으로 의존합니다. 자세한 내용은 &quot;구성된 원격 추적 분기&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c8afe72df4116adf55dd615031acfafbceae0ec5" translate="yes" xml:space="preserve">
          <source>When fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of &lt;code&gt;remote.*.fetch&lt;/code&gt; configuration variables for the remote repository. See section on &quot;Configured Remote-tracking Branches&quot; for details.</source>
          <target state="translated">명령 행에 나열된 참조를 페치 할 때, 지정된 refspec (두 번 이상 제공 가능)을 사용 하여 원격 저장소에 대한 &lt;code&gt;remote.*.fetch&lt;/code&gt; 구성 변수 값 대신 참조를 원격 추적 분기에 맵핑하십시오 . 자세한 내용은 &quot;구성된 원격 추적 분기&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f131c02a4584603f0de6ca46a404ddf3258dbf13" translate="yes" xml:space="preserve">
          <source>When files are modified outside of Git, the user will need to stage the modified files explicitly (e.g. see &lt;code&gt;Examples&lt;/code&gt; section in &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;). Git will not normally detect changes to those files.</source>
          <target state="translated">Git 외부에서 파일을 수정하는 경우 사용자는 수정 된 파일을 명시 적으로 스테이징해야합니다 (예 : &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]의 &lt;/a&gt; &lt;code&gt;Examples&lt;/code&gt; 섹션 참조 ). Git은 일반적으로 해당 파일의 변경 사항을 감지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e95f7718835508fa2f714691dae7615b5ccee03a" translate="yes" xml:space="preserve">
          <source>When filtering history with &lt;code&gt;&amp;lt;path&amp;gt;&amp;hellip;​&lt;/code&gt;, does not prune some history. (See &quot;History simplification&quot; in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for a more detailed explanation.)</source>
          <target state="translated">와 역사를 필터링 할 때 &lt;code&gt;&amp;lt;path&amp;gt;&amp;hellip;​&lt;/code&gt; , 어떤 역사를 제거하지 않습니다. ( 자세한 설명 은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]의&lt;/a&gt; &quot;히스토리 단순화&quot;를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="18f94df4064f0faddb37415d13a088dd57356563" translate="yes" xml:space="preserve">
          <source>When first created, objects are stored in individual files, but for efficiency may later be compressed together into &quot;pack files&quot;.</source>
          <target state="translated">처음 생성 할 때 개체는 개별 파일에 저장되지만 효율성을 위해 나중에 &quot;팩 파일&quot;로 압축 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ce1186a221491da0c957498f84e962314b0f4f4" translate="yes" xml:space="preserve">
          <source>When given a range of commits to display (e.g. &lt;code&gt;commit1..commit2&lt;/code&gt; or &lt;code&gt;commit2 ^commit1&lt;/code&gt;), only display commits that exist directly on the ancestry chain between the &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt;, i.e. commits that are both descendants of &lt;code&gt;commit1&lt;/code&gt;, and ancestors of &lt;code&gt;commit2&lt;/code&gt;.</source>
          <target state="translated">(예를 들어 디스플레이 커밋의 범위를 특정하면 &lt;code&gt;commit1..commit2&lt;/code&gt; 또는 &lt;code&gt;commit2 ^commit1&lt;/code&gt; )만을 사이 조상 체인에 직접 존재 커밋 표시 &lt;code&gt;commit1&lt;/code&gt; 및 &lt;code&gt;commit2&lt;/code&gt; 의 자손들 모두, 즉, 커밋 &lt;code&gt;commit1&lt;/code&gt; , 그리고 조상 &lt;code&gt;commit2&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="e006844e32fc3d063be827d3911798e9ae2b69bd" translate="yes" xml:space="preserve">
          <source>When given a range of commits to display (e.g. &lt;code&gt;commit1..commit2&lt;/code&gt; or &lt;code&gt;commit2 ^commit1&lt;/code&gt;), only display commits that exist directly on the ancestry chain between the &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt;, i.e. commits that are both descendants of &lt;code&gt;commit1&lt;/code&gt;, and ancestors of &lt;code&gt;commit2&lt;/code&gt;. (See &quot;History simplification&quot; in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for a more detailed explanation.)</source>
          <target state="translated">(예를 들어 디스플레이 커밋의 범위를 특정하면 &lt;code&gt;commit1..commit2&lt;/code&gt; 또는 &lt;code&gt;commit2 ^commit1&lt;/code&gt; )만을 사이 조상 체인에 직접 존재 커밋 표시 &lt;code&gt;commit1&lt;/code&gt; 및 &lt;code&gt;commit2&lt;/code&gt; 의 자손들 모두, 즉, 커밋 &lt;code&gt;commit1&lt;/code&gt; , 그리고 조상 &lt;code&gt;commit2&lt;/code&gt; 를 . ( 자세한 설명 은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]의&lt;/a&gt; &quot;히스토리 단순화&quot;를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="8281565ed0f01821dd04f5b4f8a282147fc8eb15" translate="yes" xml:space="preserve">
          <source>When given a two-part name section.key, the value for section.&amp;lt;url&amp;gt;.key whose &amp;lt;url&amp;gt; part matches the best to the given URL is returned (if no such key exists, the value for section.key is used as a fallback). When given just the section as name, do so for all the keys in the section and list them. Returns error code 1 if no value is found.</source>
          <target state="translated">두 부분으로 된 section.key라는 이름이 주어지면 &amp;lt;url&amp;gt; 부분이 주어진 URL과 가장 일치하는 section. &amp;lt;url&amp;gt; .key의 값이 반환됩니다 (해당 키가 없으면 section.key의 값이 사용됨). 대체로). 섹션으로 만 이름이 지정되면 섹션의 모든 키에 대해 그렇게하고 나열하십시오. 값이 없으면 오류 코드 1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f88bacf945cb9e0553c03a8ac1d906d306ca24eb" translate="yes" xml:space="preserve">
          <source>When given an SVN revision number of the form &lt;code&gt;rN&lt;/code&gt;, returns the corresponding Git commit hash (this can optionally be followed by a tree-ish to specify which branch should be searched). When given a tree-ish, returns the corresponding SVN revision number.</source>
          <target state="translated">&lt;code&gt;rN&lt;/code&gt; 형식의 SVN 개정 번호 가 제공되면 해당 Git 커밋 해시를 반환합니다 (선택적으로 검색 할 브랜치를 지정하기 위해 트리를 따를 수 있음). 트리가 주어지면 해당 SVN 개정 번호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a96423d691859ec79cd98b29f7765677feb267ba" translate="yes" xml:space="preserve">
          <source>When given, and the repository to clone from is accessed via ssh, this specifies a non-default path for the command run on the other end.</source>
          <target state="translated">지정된 경우 복제 할 저장소에 ssh를 통해 액세스하면 다른 쪽에서 실행되는 명령의 기본 경로가 아닌 경로를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d1fb59a7ba9cbb456b044d488d1684f86345d108" translate="yes" xml:space="preserve">
          <source>When given, and the repository to fetch from is handled by &lt;code&gt;git fetch-pack&lt;/code&gt;, &lt;code&gt;--exec=&amp;lt;upload-pack&amp;gt;&lt;/code&gt; is passed to the command to specify non-default path for the command run on the other end.</source>
          <target state="translated">주어진 저장소에서 가져올 저장소가 &lt;code&gt;git fetch-pack&lt;/code&gt; 에 의해 처리 되면 &lt;code&gt;--exec=&amp;lt;upload-pack&amp;gt;&lt;/code&gt; 이 명령으로 전달되어 다른 쪽에서 실행되는 명령의 기본 경로가 아닌 경로를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="347806ba4d643d64e35fb6159f6ca9df9bd36627" translate="yes" xml:space="preserve">
          <source>When giving multiple pattern expressions combined with &lt;code&gt;--or&lt;/code&gt;, this flag is specified to limit the match to files that have lines to match all of them.</source>
          <target state="translated">&lt;code&gt;--or&lt;/code&gt; 와 결합 된 여러 패턴 표현식을 제공 할 때이 플래그는 모두 일치하는 행이있는 파일로 일치를 제한하도록 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="a0b6fe15df65f2d5daa97101d52d41abe4f1ad3a" translate="yes" xml:space="preserve">
          <source>When grepping the object store (with &lt;code&gt;--cached&lt;/code&gt; or giving tree objects), running with multiple threads might perform slower than single threaded if &lt;code&gt;--textconv&lt;/code&gt; is given and there&amp;rsquo;re too many text conversions. So if you experience low performance in this case, it might be desirable to use &lt;code&gt;--threads=1&lt;/code&gt;.</source>
          <target state="translated">객체 저장소를 탐색 할 때 ( &lt;code&gt;--cached&lt;/code&gt; 또는 트리 객체 제공) &lt;code&gt;--textconv&lt;/code&gt; 가 제공되고 텍스트 변환이 너무 많으면 다중 스레드로 실행하는 것이 단일 스레드보다 느리게 수행 될 수 있습니다 . 따라서이 경우 성능이 저하되는 경우 &lt;code&gt;--threads=1&lt;/code&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4aea2178dff194f0c4c01be5fd5d2a4667a09068" translate="yes" xml:space="preserve">
          <source>When he&amp;rsquo;s ready, he tells Alice to pull changes from the repository at /home/bob/myrepo. She does this with:</source>
          <target state="translated">준비가되면 / home / bob / myrepo의 저장소에서 변경 사항을 가져 오도록 Alice에게 지시합니다. 그녀는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="66bba6f8c73ac5f72ec362ac6e58a5210f96d2e5" translate="yes" xml:space="preserve">
          <source>When importing a renamed file or directory, simply delete the old name(s) and modify the new name(s) during the corresponding commit. Git performs rename detection after-the-fact, rather than explicitly during a commit.</source>
          <target state="translated">이름이 바뀐 파일이나 디렉토리를 가져올 때는 해당 커밋 중에 이전 이름을 삭제하고 새 이름을 수정하면됩니다. Git은 커밋하는 동안 명시 적으로 수행하지 않고 이름 변경 감지를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="547b791fe6e4a112ecfb6e63c2e9ee0d26e77b05" translate="yes" xml:space="preserve">
          <source>When in cone mode, the &lt;code&gt;git sparse-checkout set&lt;/code&gt; subcommand takes a list of directories instead of a list of sparse-checkout patterns. In this mode, the command &lt;code&gt;git sparse-checkout set A/B/C&lt;/code&gt; sets the directory &lt;code&gt;A/B/C&lt;/code&gt; as a recursive pattern, the directories &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;A/B&lt;/code&gt; are added as parent patterns. The resulting sparse-checkout file is now</source>
          <target state="translated">cone 모드에서 &lt;code&gt;git sparse-checkout set&lt;/code&gt; 하위 명령은 스파 스 체크 아웃 패턴 목록 대신 디렉토리 목록을 사용합니다. 이 모드에서 &lt;code&gt;git sparse-checkout set A/B/C&lt;/code&gt; 명령 은 디렉터리 &lt;code&gt;A/B/C&lt;/code&gt; 를 재귀 패턴으로 설정하고 디렉터리 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;A/B&lt;/code&gt; 는 부모 패턴으로 추가됩니다. 결과 스파 스 체크 아웃 파일은 이제</target>
        </trans-unit>
        <trans-unit id="3cdd5299d04b153fd0e295904b9e12eec6b499c8" translate="yes" xml:space="preserve">
          <source>When in list mode, show sha1 and commit subject line for each head, along with relationship to upstream branch (if any). If given twice, print the path of the linked worktree (if any) and the name of the upstream branch, as well (see also &lt;code&gt;git remote show &amp;lt;remote&amp;gt;&lt;/code&gt;). Note that the current worktree&amp;rsquo;s HEAD will not have its path printed (it will always be your current directory).</source>
          <target state="translated">리스트 모드에있을 때, 업스트림 브랜치 (있는 경우)와의 관계와 함께 sha1을 표시하고 각 헤드의 제목 줄을 커밋하십시오. 두 번 주어진 경우, 연결된 작업 트리의 경로 (있는 경우)와 업스트림 분기의 이름도 인쇄하십시오 ( &lt;code&gt;git remote show &amp;lt;remote&amp;gt;&lt;/code&gt; 참조 ). 현재 작업 트리의 HEAD에는 경로가 인쇄되지 않습니다 (항상 현재 디렉토리 임).</target>
        </trans-unit>
        <trans-unit id="df3e42ff48559b3d46a4606cc43ea02a4d5742e5" translate="yes" xml:space="preserve">
          <source>When informative errors are turned on, git-daemon will report more verbose errors to the client, differentiating conditions like &quot;no such repository&quot; from &quot;repository not exported&quot;. This is more convenient for clients, but may leak information about the existence of unexported repositories. When informative errors are not enabled, all errors report &quot;access denied&quot; to the client. The default is --no-informative-errors.</source>
          <target state="translated">유익한 오류가 설정되면 git-daemon은 클라이언트에 더 자세한 오류를보고하여 &quot;이러한 저장소 없음&quot;과 같은 조건을 &quot;저장소가 내보내지지 않음&quot;과 구별합니다. 이는 클라이언트에게는 더 편리하지만 내 보내지 않은 리포지토리의 존재에 대한 정보가 유출 될 수 있습니다. 정보 오류가 활성화되지 않은 경우 모든 오류는 클라이언트에 &quot;액세스 거부&quot;를보고합니다. 기본값은 --no-informative-errors입니다.</target>
        </trans-unit>
        <trans-unit id="882f7c25abfabdf5a0527656f301ec49c21b72e8" translate="yes" xml:space="preserve">
          <source>When initializing submodules, a &lt;code&gt;.gitmodules&lt;/code&gt; file in the top-level directory of the containing repository is used to find the url of each submodule. This file should be formatted in the same way as &lt;code&gt;$GIT_DIR/config&lt;/code&gt;. The key to each submodule url is &quot;submodule.$name.url&quot;. See &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; for details.</source>
          <target state="translated">하위 모듈을 초기화 할 때 포함 저장소의 최상위 디렉토리에 있는 &lt;code&gt;.gitmodules&lt;/code&gt; 파일이 각 하위 모듈의 URL을 찾는 데 사용됩니다. 이 파일은 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 와 같은 방식으로 포맷되어야합니다 . 각 하위 모듈 URL의 키는 &quot;submodule. $ name.url&quot;입니다. 자세한 내용은 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="854c3f2001a62b8064a99a360e1e32072b64ad8e" translate="yes" xml:space="preserve">
          <source>When initially invoking &lt;code&gt;git am&lt;/code&gt;, you give it the names of the mailboxes to process. Upon seeing the first patch that does not apply, it aborts in the middle. You can recover from this in one of two ways:</source>
          <target state="translated">처음으로 &lt;code&gt;git am&lt;/code&gt; 을 호출 할 때 처리 할 메일 함의 이름을 지정하십시오. 적용되지 않는 첫 번째 패치를 보면 중간에 중단됩니다. 다음 두 가지 방법 중 하나로이를 복구 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae919810620b188b4a098cb2c7010981f59eb2a8" translate="yes" xml:space="preserve">
          <source>When invoking a custom merge tool, Git uses a set of temporary files to pass to the tool. If the tool returns an error and this variable is set to &lt;code&gt;true&lt;/code&gt;, then these temporary files will be preserved, otherwise they will be removed after the tool has exited. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">사용자 정의 병합 도구를 호출 할 때 Git은 임시 파일 세트를 사용하여 도구에 전달합니다. 도구가 오류를 리턴하고이 변수가 &lt;code&gt;true&lt;/code&gt; 로 설정된 경우 이러한 임시 파일은 보존되며 그렇지 않으면 도구가 종료 된 후에 제거됩니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b149cf0c1c59f45e7d020f119cab62bcf88ef5e" translate="yes" xml:space="preserve">
          <source>When it comes to editing that commit, execute &lt;code&gt;git reset HEAD^&lt;/code&gt;. The effect is that the HEAD is rewound by one, and the index follows suit. However, the working tree stays the same.</source>
          <target state="translated">커밋을 편집 할 때 &lt;code&gt;git reset HEAD^&lt;/code&gt; 실행하십시오 . 그 결과 HEAD가 1 개씩 되 감겨지고 인덱스가 적합합니다. 그러나 작업 트리는 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="54d95c16d8a8ecd15ca228486caba0d9b645aa97" translate="yes" xml:space="preserve">
          <source>When it is not obvious how to apply a change, the following happens:</source>
          <target state="translated">변경 사항을 적용하는 방법이 확실하지 않은 경우 다음이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="42b78027e34d66bfdfc08d7cf571f024832571b4" translate="yes" xml:space="preserve">
          <source>When it is not obvious how to reconcile the changes, the following happens:</source>
          <target state="translated">변경 사항을 조정하는 방법이 명확하지 않은 경우 다음이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ac3a9525cba718f2ba4c34b577914369145b2d3f" translate="yes" xml:space="preserve">
          <source>When listing references from an alternate, list only references that begin with the given prefix. Prefixes match as if they were given as arguments to &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;. To list multiple prefixes, separate them with whitespace. If &lt;code&gt;core.alternateRefsCommand&lt;/code&gt; is set, setting &lt;code&gt;core.alternateRefsPrefixes&lt;/code&gt; has no effect.</source>
          <target state="translated">대체의 참조를 나열 할 때는 주어진 접두사로 시작하는 참조 만 나열하십시오. 접두사는 마치 &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]에&lt;/a&gt; 인수로 주어진 것처럼 일치 합니다. 접두사를 여러 개 나열하려면 접두사를 공백으로 구분하십시오. 경우 &lt;code&gt;core.alternateRefsCommand&lt;/code&gt; 가 설정되어, 설정 &lt;code&gt;core.alternateRefsPrefixes&lt;/code&gt; 하는 것은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9485b24ac5fd9e24de580d1b4ae98203a381daa8" translate="yes" xml:space="preserve">
          <source>When listing, use the specified &amp;lt;format&amp;gt;, which can be one of &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt;. When omitted, the format defaults to &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">나열 할 때 지정된 &amp;lt;format&amp;gt;을 사용하십시오 . &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;medium&lt;/code&gt; 및 &lt;code&gt;long&lt;/code&gt; 중 하나 일 수 있습니다 . 생략하면 형식은 기본적으로 &lt;code&gt;short&lt;/code&gt; 로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="0de171dd2f5efd6969d6cc172c7d84e26d4bf231" translate="yes" xml:space="preserve">
          <source>When loosening unreachable objects, do not bother loosening any objects older than &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt;. This can be used to optimize out the write of any objects that would be immediately pruned by a follow-up &lt;code&gt;git prune&lt;/code&gt;.</source>
          <target state="translated">도달 할 수없는 객체를 풀 &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; 보다 오래된 객체를 풀지 마십시오 . 이것은 후속 &lt;code&gt;git prune&lt;/code&gt; 에 의해 즉시 제거 될 오브젝트의 쓰기를 최적화하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ecd3bb7ffbd4f19e0c8d754d499b7e6453c84ef" translate="yes" xml:space="preserve">
          <source>When merging an annotated (and possibly signed) tag, Git always creates a merge commit even if a fast-forward merge is possible, and the commit message template is prepared with the tag message. Additionally, if the tag is signed, the signature check is reported as a comment in the message template. See also &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;.</source>
          <target state="translated">주석이 달린 (및 서명 될 수있는) 태그를 병합 할 때 Git은 빨리 감기 병합이 가능하더라도 항상 병합 커밋을 생성하고 커밋 메시지 템플릿은 태그 메시지와 함께 준비됩니다. 또한 태그에 서명 한 경우 서명 확인이 메시지 템플릿에 주석으로보고됩니다. &lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe18117100b1e7049979d08b3604c39a0ff0f463" translate="yes" xml:space="preserve">
          <source>When merging notes, be more verbose. When pruning notes, report all object names whose notes are removed.</source>
          <target state="translated">메모를 병합 할 때 더 자세하게 설명하십시오. 노트를 제거 할 때 노트가 제거 된 모든 오브젝트 이름을보고하십시오.</target>
        </trans-unit>
        <trans-unit id="2a6ffb56c555f1836377a0b4eb9f01a6db423b92" translate="yes" xml:space="preserve">
          <source>When merging notes, operate quietly.</source>
          <target state="translated">음표를 병합 할 때는 조용히 조작하십시오.</target>
        </trans-unit>
        <trans-unit id="452e3643271eefd0a90ad1d2e336613f571129ec" translate="yes" xml:space="preserve">
          <source>When merging notes, resolve notes conflicts using the given strategy. The following strategies are recognized: &quot;manual&quot; (default), &quot;ours&quot;, &quot;theirs&quot;, &quot;union&quot; and &quot;cat_sort_uniq&quot;. This option overrides the &quot;notes.mergeStrategy&quot; configuration setting. See the &quot;NOTES MERGE STRATEGIES&quot; section below for more information on each notes merge strategy.</source>
          <target state="translated">메모를 병합 할 때 주어진 전략을 사용하여 메모 충돌을 해결하십시오. &quot;수동&quot;(기본값), &quot;우리&quot;, &quot;그들의&quot;, &quot;연합&quot;및 &quot;cat_sort_uniq&quot;전략이 인식됩니다. 이 옵션은 &quot;notes.mergeStrategy&quot;구성 설정을 대체합니다. 각 노트 병합 전략에 대한 자세한 내용은 아래의 &quot;노트 병합 전략&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a1f0170f40742ebfd5d162ab78a6fe6f60fbd4e1" translate="yes" xml:space="preserve">
          <source>When missing or is set to &lt;code&gt;default&lt;/code&gt;, many fields in the stat structure are checked to detect if a file has been modified since Git looked at it. When this configuration variable is set to &lt;code&gt;minimal&lt;/code&gt;, sub-second part of mtime and ctime, the uid and gid of the owner of the file, the inode number (and the device number, if Git was compiled to use it), are excluded from the check among these fields, leaving only the whole-second part of mtime (and ctime, if &lt;code&gt;core.trustCtime&lt;/code&gt; is set) and the filesize to be checked.</source>
          <target state="translated">누락되거나 &lt;code&gt;default&lt;/code&gt; 설정되면 Git을 검토 한 후 파일이 수정되었는지 여부를 감지하기 위해 통계 구조의 많은 필드가 검사됩니다. 이 구성 변수로 설정하면 &lt;code&gt;minimal&lt;/code&gt; 에 mtime 및 ctime을 상기 UID의 서브 번째 부분과 파일 아이 노드 번호의 소유자 gid가 (및 장치 번호 힘내 사용하도록 컴파일 된 경우)에서 제외 mtime의 전체 초 부분 ( &lt;code&gt;core.trustCtime&lt;/code&gt; 이 설정되어있는 경우 ctime) 만 남겨두고 파일 크기를 검사하도록 두 필드를 점검하십시오.</target>
        </trans-unit>
        <trans-unit id="0689b4b76e007bf9e9f69e1368a4eed9e3d9055a" translate="yes" xml:space="preserve">
          <source>When more than one pattern matches the path, a later line overrides an earlier line. This overriding is done per attribute.</source>
          <target state="translated">둘 이상의 패턴이 경로와 일치하면 나중 라인이 이전 라인보다 우선합니다. 이 재정의는 속성마다 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7de11bcf0fc6f31a9913abfce53b7b83c6075119" translate="yes" xml:space="preserve">
          <source>When moved lines are colored using e.g. the &lt;code&gt;diff.colorMoved&lt;/code&gt; setting, this option controls the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; how spaces are treated for details of valid modes see &lt;code&gt;--color-moved-ws&lt;/code&gt; in &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;.</source>
          <target state="translated">이동 된 선은 예를 들면 컬러를 사용하는 경우 &lt;code&gt;diff.colorMoved&lt;/code&gt; 의 설정이 옵션 제어 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 스페이스를 유효 모드의 세부 사항을 처리하는 방법을 알 &lt;code&gt;--color-moved-ws&lt;/code&gt; 의 &lt;a href=&quot;git-diff&quot;&gt;자식 DIFF-[1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="52b8058d0bfbbff70a9ce60ad478453479b9a747" translate="yes" xml:space="preserve">
          <source>When multiple patches are output, the subject prefix will instead be &quot;[PATCH n/m] &quot;. To force 1/1 to be added for a single patch, use &lt;code&gt;-n&lt;/code&gt;. To omit patch numbers from the subject, use &lt;code&gt;-N&lt;/code&gt;.</source>
          <target state="translated">여러 패치가 출력되면 제목 접두사가 &quot;[PATCH n / m]&quot;이됩니다. 단일 패치에 1/1을 강제로 추가하려면 &lt;code&gt;-n&lt;/code&gt; 을 사용하십시오 . 주제에서 패치 번호를 생략하려면 &lt;code&gt;-N&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1cdd3c7b73eb4476790691d3f8180aaaecc09ec" translate="yes" xml:space="preserve">
          <source>When multiple working trees are used, most of files in $GIT_DIR are per-worktree with a few known exceptions. All files under &lt;code&gt;common&lt;/code&gt; however will be shared between all working trees.</source>
          <target state="translated">여러 작업 트리가 사용되는 경우 $ GIT_DIR에있는 대부분의 파일은 몇 가지 알려진 예외를 제외하고 작업 트리 별입니다. 그러나 &lt;code&gt;common&lt;/code&gt; 모든 파일 은 모든 작업 트리간에 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="dea6d60865820d20f017799a5c24231f89c30494" translate="yes" xml:space="preserve">
          <source>When neither the command-line nor the configuration specify what to push, the default behavior is used, which corresponds to the &lt;code&gt;simple&lt;/code&gt; value for &lt;code&gt;push.default&lt;/code&gt;: the current branch is pushed to the corresponding upstream branch, but as a safety measure, the push is aborted if the upstream branch does not have the same name as the local one.</source>
          <target state="translated">명령 줄이나 구성에서 푸시 대상을 지정하지 않으면 push에 대한 &lt;code&gt;simple&lt;/code&gt; 값에 해당하는 기본 동작이 사용됩니다. &lt;code&gt;push.default&lt;/code&gt; : 현재 분기는 해당 업스트림 분기로 푸시되지만 안전 측정으로는 푸시 업스트림 분기의 이름이 로컬 분기와 같지 않으면 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="60de604c8e6be170ca14a17caf3d8c66cf8e4c1f" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; is given, &lt;code&gt;stash@{0}&lt;/code&gt; is assumed, otherwise &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; must be a reference of the form &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 가 제공 되지 않으면 &lt;code&gt;stash@{0}&lt;/code&gt; 이 가정되고, 그렇지 않으면 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 는 &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt; 형식의 참조 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="1cb728a038f1c7e17113ec68844d5bac04accdd7" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; argument is given from the command line, &lt;code&gt;git push&lt;/code&gt; behaves as if each &amp;lt;value&amp;gt; of this variable is given as &lt;code&gt;--push-option=&amp;lt;value&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">어떠한 경우 &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; 인수는 명령 라인에서 제공되지 않는, &lt;code&gt;git push&lt;/code&gt; 동작합니다이 변수들 각각 &amp;lt;값&amp;gt;로 주어진 것처럼 &lt;code&gt;--push-option=&amp;lt;value&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a166fc08fc71ee0e3d700a37b70f8845fb53d565" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;--whitespace&lt;/code&gt; flag is given from the command line, this configuration item is used as the default.</source>
          <target state="translated">명령 행에서 &lt;code&gt;--whitespace&lt;/code&gt; 플래그가 제공 되지 않으면 이 구성 항목이 기본값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b29755631cf67968424c24b41012b3c14a5bc20f" translate="yes" xml:space="preserve">
          <source>When no refspec was given on the command line, then &lt;code&gt;git pull&lt;/code&gt; uses the refspec from the configuration or &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt;. In such cases, the following rules apply:</source>
          <target state="translated">명령 행에 refspec이 지정되지 않은 경우 &lt;code&gt;git pull&lt;/code&gt; 은 구성 또는 &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; 의 refspec을 사용합니다 . 이러한 경우 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="feee7e6efffd7b04e5558aa779c91bc6a7b795bd" translate="yes" xml:space="preserve">
          <source>When no remote is specified (via -r) the &lt;code&gt;HEAD&lt;/code&gt; branch from CVS is imported to the &lt;code&gt;origin&lt;/code&gt; branch within the Git repository, as &lt;code&gt;HEAD&lt;/code&gt; already has a special meaning for Git. When a remote is specified the &lt;code&gt;HEAD&lt;/code&gt; branch is named remotes/&amp;lt;remote&amp;gt;/master mirroring &lt;code&gt;git clone&lt;/code&gt; behaviour. Use this option if you want to import into a different branch.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 가 이미 Git에 특별한 의미를 가지고 있기 때문에 -r을 통해 원격이 지정되지 않은 경우 (-r을 통해) CVS 의 &lt;code&gt;HEAD&lt;/code&gt; 분기 가 Git 리포지토리 의 &lt;code&gt;origin&lt;/code&gt; 분기로 가져옵니다 . 리모트가 지정되면 &lt;code&gt;HEAD&lt;/code&gt; 브랜치의 이름은 remotes / &amp;lt;remote&amp;gt; / master mirroring &lt;code&gt;git clone&lt;/code&gt; behavior로 지정됩니다. 다른 지점으로 가져 오려면이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ac03f302c1aadb048fb52d65d000d2a5006af96e" translate="yes" xml:space="preserve">
          <source>When no remote is specified, by default the &lt;code&gt;origin&lt;/code&gt; remote will be used, unless there&amp;rsquo;s an upstream branch configured for the current branch.</source>
          <target state="translated">원격이 지정 되지 않은 경우 현재 분기에 대해 업스트림 분기가 구성되어 있지 않으면 기본적으로 &lt;code&gt;origin&lt;/code&gt; 원격이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d52e3dbbfef371828cf1a5d65a8a3d7860fbbc07" translate="yes" xml:space="preserve">
          <source>When on branch &amp;lt;name&amp;gt;, it overrides &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; for pushing. It also overrides &lt;code&gt;remote.pushDefault&lt;/code&gt; for pushing from branch &amp;lt;name&amp;gt;. When you pull from one place (e.g. your upstream) and push to another place (e.g. your own publishing repository), you would want to set &lt;code&gt;remote.pushDefault&lt;/code&gt; to specify the remote to push to for all branches, and use this option to override it for a specific branch.</source>
          <target state="translated">분기 &amp;lt;name&amp;gt;에 있으면 밀어 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 위해 branch. &amp;lt;name&amp;gt; .remote 를 재정의 합니다. 또한 &amp;lt;name&amp;gt; 분기에서 푸시하기 위해 &lt;code&gt;remote.pushDefault&lt;/code&gt; 를 재정의 합니다. 한 장소 (예 : 업스트림)에서 다른 장소 (예 : 자체 게시 저장소) 로 푸시 할 때 &lt;code&gt;remote.pushDefault&lt;/code&gt; 를 설정하여 모든 브랜치에 대해 푸시 할 원격을 지정하고이 옵션을 사용하여이를 재정의하려는 경우 특정 지점의 경우</target>
        </trans-unit>
        <trans-unit id="2c5d62eaf7dc4c0abb09284bfc14bacce3f382aa" translate="yes" xml:space="preserve">
          <source>When on branch &amp;lt;name&amp;gt;, it tells &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; which remote to fetch from/push to. The remote to push to may be overridden with &lt;code&gt;remote.pushDefault&lt;/code&gt; (for all branches). The remote to push to, for the current branch, may be further overridden by &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt;. If no remote is configured, or if you are not on any branch, it defaults to &lt;code&gt;origin&lt;/code&gt; for fetching and &lt;code&gt;remote.pushDefault&lt;/code&gt; for pushing. Additionally, &lt;code&gt;.&lt;/code&gt; (a period) is the current local repository (a dot-repository), see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;'s final note below.</source>
          <target state="translated">분기 &amp;lt;name&amp;gt;에있을 때 &lt;code&gt;git fetch&lt;/code&gt; 및 &lt;code&gt;git push&lt;/code&gt; 에게 어느 원격에서 가져 오거나 푸시 할지 알려줍니다 . 푸시 할 리모컨은 &lt;code&gt;remote.pushDefault&lt;/code&gt; (모든 분기에 대해) 로 재정의 될 수 있습니다 . 현재 브랜치에 대해 푸시 할 리모트는 &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; 로 추가로 대체 될 수 있습니다 . 원격이 구성되어 있지 않거나 브랜치에 있지 않은 경우 기본적으로 페치의 &lt;code&gt;origin&lt;/code&gt; 이되고 푸시의 경우 &lt;code&gt;remote.pushDefault&lt;/code&gt; 가됩니다. 또한 &lt;code&gt;.&lt;/code&gt; (마침표)는 현재 로컬 저장소 (도트 저장소)입니다. 아래의 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 의 마지막 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="99875f2b6ac5843dc20c0934eb9cdf10f7711c8e" translate="yes" xml:space="preserve">
          <source>When one of these flags is specified, the object name recorded for the paths are not updated. Instead, these options set and unset the &quot;fsmonitor valid&quot; bit for the paths. See section &quot;File System Monitor&quot; below for more information.</source>
          <target state="translated">이러한 플래그 중 하나가 지정되면 경로에 대해 기록 된 오브젝트 이름이 업데이트되지 않습니다. 대신,이 옵션은 경로에 대한 &quot;fsmonitor valid&quot;비트를 설정 및 설정 해제합니다. 자세한 내용은 아래의 &quot;파일 시스템 모니터&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="095b3a1631077463d64190b5c04e9903f37eec26" translate="yes" xml:space="preserve">
          <source>When one of these flags is specified, the object name recorded for the paths are not updated. Instead, these options set and unset the &quot;skip-worktree&quot; bit for the paths. See section &quot;Skip-worktree bit&quot; below for more information.</source>
          <target state="translated">이러한 플래그 중 하나가 지정되면 경로에 대해 기록 된 오브젝트 이름이 업데이트되지 않습니다. 대신,이 옵션은 경로에 대한 &quot;skip-worktree&quot;비트를 설정 및 설정 해제합니다. 자세한 내용은 아래의 &quot;건너 뛰기 작업 비트&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6e8f4e10b13b6ff83d83df5063d58c36d64a87b8" translate="yes" xml:space="preserve">
          <source>When one or more &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; are specified explicitly (whether on the command line or via &lt;code&gt;--stdin&lt;/code&gt;), it can be either a single pattern, or a pair of such pattern separated by a colon &quot;:&quot; (this means that a ref name cannot have a colon in it). A single pattern &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is just a shorthand for &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">하나 이상의 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 가 명시 적으로 지정되면 (명령 행 또는 &lt;code&gt;--stdin&lt;/code&gt; 을 통해 ) 콜론 &quot;:&quot;으로 구분 된 단일 패턴 또는 이러한 패턴 쌍일 수 있습니다 (이는 ref 이름은 콜론을 가질 수 없습니다). 단일 패턴 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 은 &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt; 의 약어입니다 .</target>
        </trans-unit>
        <trans-unit id="9a9b16c534806b7638cc46892a28dd173752ed8c" translate="yes" xml:space="preserve">
          <source>When packing a blob fast-import always attempts to deltify against the last blob written. Unless specifically arranged for by the frontend, this will probably not be a prior version of the same file, so the generated delta will not be the smallest possible. The resulting packfile will be compressed, but will not be optimal.</source>
          <target state="translated">Blob 빠른 가져 오기를 패킹 할 때는 항상 마지막으로 작성된 Blob에 대해 deltify를 시도합니다. 프런트 엔드에서 특별히 지정하지 않는 한이 파일은 동일한 파일의 이전 버전이 아닐 수 있으므로 생성 된 델타가 가장 작을 수는 없습니다. 결과 팩 파일은 압축되지만 최적은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="76e4bf1d99930055a44aa05818b2c065730f60bb" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--ignore-paths&lt;/code&gt;.</source>
          <target state="translated">에 전달하면 &lt;code&gt;init&lt;/code&gt; 또는 &lt;code&gt;clone&lt;/code&gt; 이 정규 표현식은 설정 키로 유지됩니다. &lt;code&gt;--ignore-paths&lt;/code&gt; 에 대한 설명은 &lt;code&gt;fetch&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6a3308486ea0114e28423fc585e726bdfefa0d3" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--ignore-refs&lt;/code&gt;.</source>
          <target state="translated">에 전달하면 &lt;code&gt;init&lt;/code&gt; 또는 &lt;code&gt;clone&lt;/code&gt; 이 정규 표현식은 설정 키로 유지됩니다. &lt;code&gt;--ignore-refs&lt;/code&gt; 에 대한 설명은 &lt;code&gt;fetch&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="247954c989ece2f916f72b869f8bb1eb7f01f09e" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--include-paths&lt;/code&gt;.</source>
          <target state="translated">에 전달하면 &lt;code&gt;init&lt;/code&gt; 또는 &lt;code&gt;clone&lt;/code&gt; 이 정규 표현식은 설정 키로 유지됩니다. &lt;code&gt;--include-paths&lt;/code&gt; 에 대한 설명은 &lt;code&gt;fetch&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="701b3c119f368819101d8af88b842359e5cb7ac8" translate="yes" xml:space="preserve">
          <source>When paths are given, show them (note that this isn&amp;rsquo;t really raw pathnames, but rather a list of patterns to match). Otherwise implicitly uses the root level of the tree as the sole path argument.</source>
          <target state="translated">경로가 주어지면 표시하십시오 (이것은 실제로 원시 경로 이름이 아니라 일치하는 패턴 목록입니다). 그렇지 않으면 트리의 루트 레벨을 단독 경로 인수로 내재적으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a12bc3537fe67daac72917848a655d5078c91711" translate="yes" xml:space="preserve">
          <source>When pathspec is given on the command line, commit the contents of the files that match the pathspec without recording the changes already added to the index. The contents of these files are also staged for the next commit on top of what have been staged before.</source>
          <target state="translated">명령 행에 pathspec이 지정되면 색인에 이미 추가 된 변경 사항을 기록하지 않고 pathspec과 일치하는 파일의 컨텐츠를 커미트하십시오. 이 파일의 내용은 이전에 준비된 것 외에 다음 커밋을 위해 준비됩니다.</target>
        </trans-unit>
        <trans-unit id="1a6dc462ca36ebe8779cf750259e000c162a076a" translate="yes" xml:space="preserve">
          <source>When pathspec is given to &lt;code&gt;git stash push&lt;/code&gt;, the new stash entry records the modified states only for the files that match the pathspec. The index entries and working tree files are then rolled back to the state in HEAD only for these files, too, leaving files that do not match the pathspec intact.</source>
          <target state="translated">pathspec이 &lt;code&gt;git stash push&lt;/code&gt; 에 제공되면 새 숨김 항목은 pathspec과 일치하는 파일에 대해서만 수정 된 상태를 기록합니다. 그런 다음 인덱스 항목과 작업 트리 파일은 이러한 파일에 대해서만 HEAD의 상태로 롤백되므로 pathspec과 일치하지 않는 파일은 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="20284d20320c7f9cdd342728ed75cf98e12a1b6c" translate="yes" xml:space="preserve">
          <source>When possible, &lt;code&gt;pack-objects&lt;/code&gt; tries to reuse existing on-disk deltas to avoid having to search for new ones on the fly. This is an important optimization for serving fetches, because it means the server can avoid inflating most objects at all and just send the bytes directly from disk. This optimization can&amp;rsquo;t work when an object is stored as a delta against a base which the receiver does not have (and which we are not already sending). In that case the server &quot;breaks&quot; the delta and has to find a new one, which has a high CPU cost. Therefore it&amp;rsquo;s important for performance that the set of objects in on-disk delta relationships match what a client would fetch.</source>
          <target state="translated">가능하면 &lt;code&gt;pack-objects&lt;/code&gt; 는 기존 온 디스크 델타를 재사용하려고 시도하여 새로운 델타를 즉시 검색하지 않아도됩니다. 이는 서버가 대부분의 객체를 전혀 팽창시키지 않고 바이트를 디스크에서 직접 보낼 수 있기 때문에 가져 오기를 제공하는 데 중요한 최적화입니다. 이 최적화는 객체가 수신자가 가지고 있지 않은 (그리고 아직 보내지 않은)베이스에 대한 델타로 저장 될 때 작동하지 않습니다. 이 경우 서버는 델타를 &quot;중단&quot;하고 CPU 비용이 높은 새로운 델타를 찾아야합니다. 따라서 디스크상의 델타 관계에있는 오브젝트 세트가 클라이언트가 가져 오는 것과 일치하는 것이 성능에 중요합니다.</target>
        </trans-unit>
        <trans-unit id="a5d1e2c9c76493f4d0a607592b15388eabc93e4e" translate="yes" xml:space="preserve">
          <source>When present, it will also copy the value of &lt;code&gt;submodule.$name.update&lt;/code&gt;. This command does not alter existing information in .git/config. You can then customize the submodule clone URLs in .git/config for your local setup and proceed to &lt;code&gt;git submodule update&lt;/code&gt;; you can also just use &lt;code&gt;git submodule update --init&lt;/code&gt; without the explicit &lt;code&gt;init&lt;/code&gt; step if you do not intend to customize any submodule locations.</source>
          <target state="translated">존재하는 경우 &lt;code&gt;submodule.$name.update&lt;/code&gt; 의 값도 복사합니다 . 이 명령은 .git / config의 기존 정보를 변경하지 않습니다. 그런 다음 로컬 설정을 위해 .git / config에서 하위 모듈 복제 URL을 사용자 정의하고 &lt;code&gt;git submodule update&lt;/code&gt; 진행할 수 있습니다 . 하위 모듈 위치를 사용자 정의하지 않으려는 경우 명시적인 &lt;code&gt;init&lt;/code&gt; 단계 없이 &lt;code&gt;git submodule update --init&lt;/code&gt; 을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb5aacfd35a68a879acea2ba6edf150f79c935f9" translate="yes" xml:space="preserve">
          <source>When pushing to a remote that is different from the remote you normally pull from, work as &lt;code&gt;current&lt;/code&gt;. This is the safest option and is suited for beginners.</source>
          <target state="translated">일반적으로 당기는 리모컨과 다른 리모컨으로 밀 때 &lt;code&gt;current&lt;/code&gt; 작동하십시오 . 이것은 가장 안전한 옵션이며 초보자에게 적합합니다.</target>
        </trans-unit>
        <trans-unit id="f99e4f9643f5e033d51557f2aab4b69c000e9e23" translate="yes" xml:space="preserve">
          <source>When pushing, request the remote server to update refs in a single atomic transaction. If successful, all refs will be updated, or none will. If the remote side does not support this capability, the push will fail.</source>
          <target state="translated">푸시 할 때 원격 서버에 단일 원자 트랜잭션에서 참조를 업데이트하도록 요청하십시오. 성공하면 모든 심판이 업데이트되거나 아무도 없습니다. 원격 측이이 기능을 지원하지 않으면 푸시가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="24e8d08f5bcd393fd98db303b5bfff38ae149335" translate="yes" xml:space="preserve">
          <source>When reading the &lt;code&gt;core.repositoryformatversion&lt;/code&gt; variable, a git implementation which supports version 1 MUST also read any configuration keys found in the &lt;code&gt;extensions&lt;/code&gt; section of the configuration file.</source>
          <target state="translated">&lt;code&gt;core.repositoryformatversion&lt;/code&gt; 변수를 읽을 때 버전 1을 지원하는 git 구현 은 구성 파일 의 &lt;code&gt;extensions&lt;/code&gt; 섹션에있는 구성 키도 읽어야 합니다.</target>
        </trans-unit>
        <trans-unit id="d49438aa2f88cdc57a3b7001a0406b8491bbad55" translate="yes" xml:space="preserve">
          <source>When reading trailers, there can be whitespaces after the token, the separator and the value. There can also be whitespaces inside the token and the value. The value may be split over multiple lines with each subsequent line starting with whitespace, like the &quot;folding&quot; in RFC 822.</source>
          <target state="translated">트레일러를 읽을 때 토큰, 구분 기호 및 값 뒤에 공백이있을 수 있습니다. 토큰 내부에 공백과 값이있을 수도 있습니다. RFC 822의 &quot;접기&quot;와 같이 공백으로 시작하는 각 후속 줄을 사용하여 값을 여러 줄로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c808cfa1e01223bf6f90ceb1edbec20a1b9b3321" translate="yes" xml:space="preserve">
          <source>When reading, the values are read from the system, global and repository local configuration files by default, and options &lt;code&gt;--system&lt;/code&gt;, &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--local&lt;/code&gt;, &lt;code&gt;--worktree&lt;/code&gt; and &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; can be used to tell the command to read from only that location (see &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt;).</source>
          <target state="translated">읽을 때 기본적으로 시스템, 글로벌 및 저장소 로컬 구성 파일에서 값을 읽으며 &lt;code&gt;--system&lt;/code&gt; , &lt;code&gt;--global&lt;/code&gt; , &lt;code&gt;--local&lt;/code&gt; , &lt;code&gt;--worktree&lt;/code&gt; 및 &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; 옵션 을 사용하여 해당 위치에서만 읽을 수있는 명령입니다 ( &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="35058e27fd0502a5cbd6b1225fdbfa49a5b7004d" translate="yes" xml:space="preserve">
          <source>When recording the commit, append a line that says &quot;(cherry picked from commit &amp;hellip;​)&quot; to the original commit message in order to indicate which commit this change was cherry-picked from. This is done only for cherry picks without conflicts. Do not use this option if you are cherry-picking from your private branch because the information is useless to the recipient. If on the other hand you are cherry-picking between two publicly visible branches (e.g. backporting a fix to a maintenance branch for an older release from a development branch), adding this information can be useful.</source>
          <target state="translated">커밋을 기록 할 때이 변경이 체리에서 선택된 커밋을 나타 내기 위해 원래 커밋 메시지에 &quot;(체리에서 커밋 &amp;hellip;&amp;hellip;)&quot;이라는 줄을 추가하십시오. 이것은 충돌없이 체리 픽에만 적용됩니다. 정보는 수신자에게 쓸모가 없으므로 개인 지점에서 체리 픽을 선택하는 경우이 옵션을 사용하지 마십시오. 반면에 공개적으로 보이는 두 가지 사이에서 체리 픽을 선택하는 경우 (예 : 개발 브랜치에서 이전 릴리스의 유지 보수 브랜치로 수정을 백 포트하는 경우)이 정보를 추가하면 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccaf8e1c6e304870dc79f0b6ba9e209459375c19" translate="yes" xml:space="preserve">
          <source>When recording your own work, the contents of modified files in your working tree are temporarily stored to a staging area called the &quot;index&quot; with &lt;code&gt;git add&lt;/code&gt;. A file can be reverted back, only in the index but not in the working tree, to that of the last commit with &lt;code&gt;git restore --staged &amp;lt;file&amp;gt;&lt;/code&gt;, which effectively reverts &lt;code&gt;git add&lt;/code&gt; and prevents the changes to this file from participating in the next commit. After building the state to be committed incrementally with these commands, &lt;code&gt;git commit&lt;/code&gt; (without any pathname parameter) is used to record what has been staged so far. This is the most basic form of the command. An example:</source>
          <target state="translated">자신의 작업을 기록 할 때 작업 트리에서 수정 된 파일의 내용은 &lt;code&gt;git add&lt;/code&gt; 를 사용하여 &quot;index&quot;라는 준비 영역에 임시 저장됩니다 . 파일은 작업 트리가 아닌 인덱스에서만 &lt;code&gt;git restore --staged &amp;lt;file&amp;gt;&lt;/code&gt; 을 사용하는 마지막 커밋의 파일 로 되돌릴 수 &lt;code&gt;git add&lt;/code&gt; . 다음 커밋. 이러한 명령으로 상태를 점진적으로 커밋하도록 빌드 한 후 &lt;code&gt;git commit&lt;/code&gt; (경로 매개 변수 없음)은 지금까지 준비된 내용을 기록하는 데 사용됩니다. 이것이 가장 기본적인 형태의 명령입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="35cd60207a202ee3a283a2d8b2047b148806b6b3" translate="yes" xml:space="preserve">
          <source>When remote and local branch are both named &quot;test&quot;:</source>
          <target state="translated">원격 및 로컬 지점의 이름이 &quot;test&quot;인 경우 :</target>
        </trans-unit>
        <trans-unit id="2eefb86cce90a60f5ab07db6487aa99da3ba4333" translate="yes" xml:space="preserve">
          <source>When rename/copy is involved, &lt;code&gt;file1&lt;/code&gt; and &lt;code&gt;file2&lt;/code&gt; show the name of the source file of the rename/copy and the name of the file that rename/copy produces, respectively.</source>
          <target state="translated">이름 바꾸기 / 복사가 관련된 경우, &lt;code&gt;file1&lt;/code&gt; 및 &lt;code&gt;file2&lt;/code&gt; 는 이름 바꾸기 / 복사의 소스 파일 이름과 이름 바꾸기 / 복사에 의해 생성 된 파일 이름을 각각 표시합니다.</target>
        </trans-unit>
        <trans-unit id="3475b12f6b8e32c3a9c4f496f5f906d95460d63d" translate="yes" xml:space="preserve">
          <source>When repacking with delta islands the delta window tends to get clogged with candidates that are forbidden by the config. Repacking with a big --window helps (and doesn&amp;rsquo;t take as long as it otherwise might because we can reject some object pairs based on islands before doing any computation on the content).</source>
          <target state="translated">델타 아일랜드로 리 패킹 할 때 델타 창은 구성에서 금지 된 후보로 막히는 경향이 있습니다. 큰 창으로 재 포장하면 도움이됩니다 (내용에 대한 계산을 수행하기 전에 섬을 기반으로 일부 객체 쌍을 거부 할 수 있기 때문에 시간이 오래 걸리지 않습니다).</target>
        </trans-unit>
        <trans-unit id="9f9b14ed67913870e54606a7e4140c245c13e689" translate="yes" xml:space="preserve">
          <source>When restoring files in the working tree from the index, use stage #2 (&lt;code&gt;ours&lt;/code&gt;) or #3 (&lt;code&gt;theirs&lt;/code&gt;) for unmerged paths.</source>
          <target state="translated">작업 트리의 파일을 인덱스에서 복원 할 때 병합되지 않은 경로에 스테이지 # 2 ( &lt;code&gt;ours&lt;/code&gt; ) 또는 # 3 ( &lt;code&gt;theirs&lt;/code&gt; )을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f350add778942f50c4b0b2f8798762ec9d6fc205" translate="yes" xml:space="preserve">
          <source>When restoring files on the working tree from the index, do not abort the operation if there are unmerged entries and neither &lt;code&gt;--ours&lt;/code&gt;, &lt;code&gt;--theirs&lt;/code&gt;, &lt;code&gt;--merge&lt;/code&gt; or &lt;code&gt;--conflict&lt;/code&gt; is specified. Unmerged paths on the working tree are left alone.</source>
          <target state="translated">인덱스에서 작업 트리에서 파일을 복원 할 때이 병합되지 않은 항목과도있는 경우 작업을 중단하지 &lt;code&gt;--ours&lt;/code&gt; , &lt;code&gt;--theirs&lt;/code&gt; , &lt;code&gt;--merge&lt;/code&gt; 또는 &lt;code&gt;--conflict&lt;/code&gt; 이 지정됩니다. 작업 트리의 병합되지 않은 경로는 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="84ac309392e16a1f3dcc1a792805de1c5dea7161" translate="yes" xml:space="preserve">
          <source>When restoring files on the working tree from the index, recreate the conflicted merge in the unmerged paths.</source>
          <target state="translated">작업 트리의 파일을 인덱스에서 복원 할 때 병합되지 않은 경로에서 충돌이 발생한 병합을 다시 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0bde8e78161181c9b276b62a2eb0f3a92764228a" translate="yes" xml:space="preserve">
          <source>When retrieving svn commits into Git (as part of &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, or &lt;code&gt;dcommit&lt;/code&gt; operations), look for the first &lt;code&gt;From:&lt;/code&gt; line or &lt;code&gt;Signed-off-by&lt;/code&gt; trailer in the log message and use that as the author string.</source>
          <target state="translated">svn 커밋을 Git으로 검색 할 때 ( &lt;code&gt;fetch&lt;/code&gt; , &lt;code&gt;rebase&lt;/code&gt; 또는 &lt;code&gt;dcommit&lt;/code&gt; 작업의 일부로 ) 로그 메시지에서 첫 번째 &lt;code&gt;From:&lt;/code&gt; 줄 또는 &lt;code&gt;Signed-off-by&lt;/code&gt; 트레일러를 찾아서 작성자 문자열로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="273a9228c51e5936f4d142f339102a2bbdd8c3b8" translate="yes" xml:space="preserve">
          <source>When retrieving svn commits into Git (as part of &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, or &lt;code&gt;dcommit&lt;/code&gt; operations), look for the first &lt;code&gt;From:&lt;/code&gt; or &lt;code&gt;Signed-off-by:&lt;/code&gt; line in the log message and use that as the author string.</source>
          <target state="translated">svn 커밋을 Git으로 가져올 때 ( &lt;code&gt;fetch&lt;/code&gt; , &lt;code&gt;rebase&lt;/code&gt; 또는 &lt;code&gt;dcommit&lt;/code&gt; 작업의 일부로 ) 로그 메시지에서 첫 번째 &lt;code&gt;From:&lt;/code&gt; 또는 &lt;code&gt;Signed-off-by:&lt;/code&gt; 행을 찾아 저자 문자열로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="78d119701beb340fc1dce20129de3c1bebaf8055" translate="yes" xml:space="preserve">
          <source>When revision range specifiers are used to limit the annotation, lines that have not changed since the range boundary (either the commit v2.6.18 or the most recent commit that is more than 3 weeks old in the above example) are blamed for that range boundary commit.</source>
          <target state="translated">수정 범위 지정자를 사용하여 주석을 제한하는 경우, 범위 경계 이후에 변경되지 않은 행 (커밋 v2.6.18 또는 위의 예에서 3 주 이상 지난 최신 커밋)이 해당 범위 경계에 대한 책임이 있습니다. 범하다.</target>
        </trans-unit>
        <trans-unit id="802f2e7848870b44ce9f04fb441477cd05447e6c" translate="yes" xml:space="preserve">
          <source>When rewriting commits with &amp;lt;command&amp;gt; (currently &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;) and this variable is set to &lt;code&gt;true&lt;/code&gt;, Git automatically copies your notes from the original to the rewritten commit. Defaults to &lt;code&gt;true&lt;/code&gt;, but see &quot;notes.rewriteRef&quot; below.</source>
          <target state="translated">&amp;lt;command&amp;gt; (현재 &lt;code&gt;amend&lt;/code&gt; 또는 &lt;code&gt;rebase&lt;/code&gt; )로 커밋을 다시 작성 하고이 변수가 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 Git은 자동으로 노트를 원래의 커밋으로 다시 복사합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 이지만 아래의 &quot;notes.rewriteRef&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b9c5c034bfc575d885230ecf217359276486be76" translate="yes" xml:space="preserve">
          <source>When rewriting commits with &amp;lt;command&amp;gt; (currently &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;), if this variable is &lt;code&gt;false&lt;/code&gt;, git will not copy notes from the original to the rewritten commit. Defaults to &lt;code&gt;true&lt;/code&gt;. See also &quot;&lt;code&gt;notes.rewriteRef&lt;/code&gt;&quot; below.</source>
          <target state="translated">&amp;lt;command&amp;gt; (현재 &lt;code&gt;amend&lt;/code&gt; 또는 &lt;code&gt;rebase&lt;/code&gt; )로 커밋을 다시 쓸 때이 변수가 &lt;code&gt;false&lt;/code&gt; 인 경우 git은 원본에서 다시 쓴 커밋으로 노트를 복사하지 않습니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. 아래의 &quot; &lt;code&gt;notes.rewriteRef&lt;/code&gt; &quot; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0528b909a801bc351dbefd46a3e339150f63bb9d" translate="yes" xml:space="preserve">
          <source>When rewriting commits, which notes to copy from the original to the rewritten commit. Must be a colon-delimited list of refs or globs.</source>
          <target state="translated">커밋을 다시 쓸 때 원본에서 다시 쓴 커밋으로 복사 할 노트입니다. 콜론으로 구분 된 심판 또는 글로브 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="777967b1b1cbeac1b786b4e659ef472d75c08474" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a &amp;lt;path&amp;gt; as an argument.</source>
          <target state="translated">프로젝트의 서브 디렉토리에서 실행될 때 디렉토리 외부의 변경 사항을 제외하고이 옵션을 사용하여 디렉토리와 관련된 경로 이름을 표시하도록 지시 할 수 있습니다. 하위 디렉토리에 있지 않은 경우 (예 : Bare Repository) &amp;lt;path&amp;gt;를 인수로 지정하여 출력을 기준으로하는 하위 디렉토리의 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1526deda1d1c171ba9bb8aedb499ef46fa3558ac" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a &amp;lt;path&amp;gt; as an argument. &lt;code&gt;--no-relative&lt;/code&gt; can be used to countermand both &lt;code&gt;diff.relative&lt;/code&gt; config option and previous &lt;code&gt;--relative&lt;/code&gt;.</source>
          <target state="translated">프로젝트의 하위 디렉토리에서 실행할 때이 옵션을 사용하여 디렉토리 외부의 변경 사항을 제외하고 관련 경로 이름을 표시하도록 지시 할 수 있습니다. 하위 디렉토리 (예 : 베어 저장소)에 있지 않은 경우 &amp;lt;path&amp;gt;를 인수로 제공하여 출력을 상대적으로 만들 하위 디렉토리의 이름을 지정할 수 있습니다. &lt;code&gt;--no-relative&lt;/code&gt; 는 &lt;code&gt;diff.relative&lt;/code&gt; 구성 옵션과 이전 &lt;code&gt;--relative&lt;/code&gt; 를 모두 대응하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c27ca634a7183f46a280e82c3af06c829ca10b89" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory, the command usually outputs paths relative to the current directory. This option forces paths to be output relative to the project top directory.</source>
          <target state="translated">하위 디렉토리에서 실행할 때 명령은 일반적으로 현재 디렉토리에 상대적인 경로를 출력합니다. 이 옵션은 프로젝트 최상위 디렉토리를 기준으로 경로를 강제로 출력합니다.</target>
        </trans-unit>
        <trans-unit id="ed0ff11c4a5dd052209fd6d888b93db83b1003f1" translate="yes" xml:space="preserve">
          <source>When run in a directory that does not have &quot;.git&quot; repository directory, Git tries to find such a directory in the parent directories to find the top of the working tree, but by default it does not cross filesystem boundaries. This environment variable can be set to true to tell Git not to stop at filesystem boundaries. Like &lt;code&gt;GIT_CEILING_DIRECTORIES&lt;/code&gt;, this will not affect an explicit repository directory set via &lt;code&gt;GIT_DIR&lt;/code&gt; or on the command line.</source>
          <target state="translated">&quot;.git&quot;저장소 디렉토리가없는 디렉토리에서 실행될 때, Git은 부모 디렉토리에서 이러한 디렉토리를 찾아 작업 트리의 최상위를 찾으려고하지만 기본적으로 파일 시스템 경계를 넘지 않습니다. 이 환경 변수는 Git에게 파일 시스템 경계에서 멈추지 말도록 true로 설정할 수 있습니다. 마찬가지로 &lt;code&gt;GIT_CEILING_DIRECTORIES&lt;/code&gt; ,이를 통해 명시 적 저장소 디렉토리 설정에 영향을주지 않습니다 &lt;code&gt;GIT_DIR&lt;/code&gt; 또는 명령 줄을.</target>
        </trans-unit>
        <trans-unit id="9ce1b9e20fc14e8e8925879039b8daf3d52acd6a" translate="yes" xml:space="preserve">
          <source>When running the command with &lt;code&gt;-u&lt;/code&gt; and &lt;code&gt;-m&lt;/code&gt; options, the merge result may need to overwrite paths that are not tracked in the current branch. The command usually refuses to proceed with the merge to avoid losing such a path. However this safety valve sometimes gets in the way. For example, it often happens that the other branch added a file that used to be a generated file in your branch, and the safety valve triggers when you try to switch to that branch after you ran &lt;code&gt;make&lt;/code&gt; but before running &lt;code&gt;make clean&lt;/code&gt; to remove the generated file. This option tells the command to read per-directory exclude file (usually &lt;code&gt;.gitignore&lt;/code&gt;) and allows such an untracked but explicitly ignored file to be overwritten.</source>
          <target state="translated">&lt;code&gt;-u&lt;/code&gt; 및 &lt;code&gt;-m&lt;/code&gt; 옵션 과 함께 명령을 실행할 때 병합 결과는 현재 분기에서 추적되지 않은 경로를 덮어 써야 할 수 있습니다. 명령은 일반적으로 이러한 경로를 잃지 않도록 병합을 진행하지 않습니다. 그러나이 안전 밸브는 때때로 방해가됩니다. 예를 들어, 종종 그 지점에 스위치하려고 할 때 실행 한 후 다른 지점이 지점에서 생성 된 파일로 사용하는 파일 및 안전 밸브 트리거를 추가 한 일이 &lt;code&gt;make&lt;/code&gt; 하지만 실행하기 전에 &lt;code&gt;make clean&lt;/code&gt; 제거하기 위해 생성 된 파일. 이 옵션은 명령이 디렉토리 별 제외 파일 (일반적으로 &lt;code&gt;.gitignore&lt;/code&gt; ) 을 읽도록 지시하고 추적되지 않지만 명시 적으로 무시 된 파일을 덮어 쓸 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="df426fd8f20937aff52c156a03a07b3202618140" translate="yes" xml:space="preserve">
          <source>When sending a patch this way, most often you are sending your own patch, so in addition to the &quot;&lt;code&gt;From $SHA1 $magic_timestamp&lt;/code&gt;&quot; marker you should omit &lt;code&gt;From:&lt;/code&gt; and &lt;code&gt;Date:&lt;/code&gt; lines from the patch file. The patch title is likely to be different from the subject of the discussion the patch is in response to, so it is likely that you would want to keep the Subject: line, like the example above.</source>
          <target state="translated">이런 방식으로 패치를 보낼 때 가장 자주 패치를 보내므로 &quot; &lt;code&gt;From $SHA1 $magic_timestamp&lt;/code&gt; &quot;마커 외에도 패치 파일에서 &lt;code&gt;From:&lt;/code&gt; 및 &lt;code&gt;Date:&lt;/code&gt; 행을 생략해야 합니다. 패치 제목은 패치에 대한 토론의 주제와 다를 수 있으므로 위의 예와 같이 Subject : 행을 유지하고 싶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85b26b0293721642a3d3ba409cae09a21a570f47" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;always&lt;/code&gt;, always highlight matches. When &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;), never. When set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, use color only when the output is written to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">&lt;code&gt;always&lt;/code&gt; 로 설정하면 항상 일치 항목을 강조 표시하십시오. &lt;code&gt;false&lt;/code&gt; 때 (또는 &lt;code&gt;never&lt;/code&gt; ) 절대로 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;auto&lt;/code&gt; 로 설정되면 출력이 터미널에 쓰여질 때만 색상을 사용하십시오. 설정하지 않으면 &lt;code&gt;color.ui&lt;/code&gt; 의 값 이 사용됩니다 ( 기본적으로 &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dfd0a45591bf4cdb6d73f4e9b16cc039b04690be" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;always&lt;/code&gt;, always use colors for interactive prompts and displays (such as those used by &quot;git-add --interactive&quot; and &quot;git-clean --interactive&quot;). When false (or &lt;code&gt;never&lt;/code&gt;), never. When set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, use colors only when the output is to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">&lt;code&gt;always&lt;/code&gt; 로 설정되면 대화 형 프롬프트 및 디스플레이에 항상 색상을 사용하십시오 (예 : &quot;git-add --interactive&quot;및 &quot;git-clean --interactive&quot;에 사용되는 색상). 거짓 일 때 (또는 &lt;code&gt;never&lt;/code&gt; ) 절대로 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;auto&lt;/code&gt; 로 설정되면 출력이 터미널에있을 때만 색상을 사용하십시오. 설정하지 않으면 &lt;code&gt;color.ui&lt;/code&gt; 의 값 이 사용됩니다 ( 기본적으로 &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9ba7d00c9f4d532d2b9486b8c87259ed84e278f3" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;change&lt;/code&gt;, tells &lt;code&gt;git apply&lt;/code&gt; to ignore changes in whitespace, in the same way as the &lt;code&gt;--ignore-space-change&lt;/code&gt; option. When set to one of: no, none, never, false tells &lt;code&gt;git apply&lt;/code&gt; to respect all whitespace differences. See &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;change&lt;/code&gt; 로 설정 하면 &lt;code&gt;--ignore-space-change&lt;/code&gt; 옵션 과 같은 방식으로 &lt;code&gt;git apply&lt;/code&gt; 가 공백 변경을 무시하도록 지시 합니다. no, none, never 중 하나로 설정되면 &lt;code&gt;git apply&lt;/code&gt; 모든 공백 차이를 존중하도록 git에 지시 합니다. &lt;a href=&quot;git-apply&quot;&gt;git-apply [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d6e4c3c7b2c6d56efae11b1e0ed0dcb5ce2357b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;merges&lt;/code&gt;, rebase using &lt;code&gt;git rebase --rebase-merges&lt;/code&gt; so that the local merge commits are included in the rebase (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">로 설정하면 &lt;code&gt;merges&lt;/code&gt; 사용 리베이스 &lt;code&gt;git rebase --rebase-merges&lt;/code&gt; 그래서 로컬 병합 커밋이 REBASE에 포함되어 있는지 (참조 &lt;a href=&quot;git-rebase&quot;&gt;자식-REBASE [1]&lt;/a&gt; 세부 사항 참조).</target>
        </trans-unit>
        <trans-unit id="3726def44fed6d7863a8f10abeef80361e6f2701" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;preserve&lt;/code&gt; (deprecated in favor of &lt;code&gt;merges&lt;/code&gt;), rebase with the &lt;code&gt;--preserve-merges&lt;/code&gt; option passed to &lt;code&gt;git rebase&lt;/code&gt; so that locally created merge commits will not be flattened.</source>
          <target state="translated">&lt;code&gt;preserve&lt;/code&gt; 하도록 설정하면 ( &lt;code&gt;merges&lt;/code&gt; 를 위해 더 이상 사용되지 않음 ) &lt;code&gt;--preserve-merges&lt;/code&gt; 옵션을 사용하여 &lt;code&gt;git rebase&lt;/code&gt; 를 git rebase로 전달하면 로컬로 생성 된 병합 커밋이 병합되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14ded32327ec4343589fd7082ddc1f7fdc8962f6" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;git reset&lt;/code&gt; will default to the &lt;code&gt;--quiet&lt;/code&gt; option.</source>
          <target state="translated">true로 설정하면 &lt;code&gt;git reset&lt;/code&gt; 은 &lt;code&gt;--quiet&lt;/code&gt; 옵션 으로 기본 설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="01f095efe30e9d32fee48e094d88f96d4eba1bad" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;git-rerere&lt;/code&gt; updates the index with the resulting contents after it cleanly resolves conflicts using previously recorded resolution. Defaults to false.</source>
          <target state="translated">true로 설정하면 &lt;code&gt;git-rerere&lt;/code&gt; 는 이전에 기록 된 해상도를 사용하여 충돌을 완전히 해결 한 후 결과 내용으로 색인을 업데이트합니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="e2cc234f1ab166d2852bd6878a576806a19d5021" translate="yes" xml:space="preserve">
          <source>When set to true, a clone of this submodule will be performed as a shallow clone (with a history depth of 1) unless the user explicitly asks for a non-shallow clone.</source>
          <target state="translated">true로 설정되면 사용자가 명시 적으로 얕은 클론을 요청하지 않는 한이 서브 모듈의 복제는 얕은 복제본 (이력 깊이가 1 인)으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6b72e60e4df8bc4b62a55c38ddf1b7b574998e6d" translate="yes" xml:space="preserve">
          <source>When set to true, automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run merge on a dirty worktree. However, use with care: the final stash application after a successful merge might result in non-trivial conflicts. This option can be overridden by the &lt;code&gt;--no-autostash&lt;/code&gt; and &lt;code&gt;--autostash&lt;/code&gt; options of &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;. Defaults to false.</source>
          <target state="translated">true로 설정하면 작업이 시작되기 전에 자동으로 임시 숨김 항목을 만들고 작업이 끝난 후에 적용합니다. 이는 더티 워크 트리에서 병합을 실행할 수 있음을 의미합니다. 그러나주의해서 사용하십시오. 성공적인 병합 후 최종 숨김 애플리케이션은 사소한 충돌을 초래할 수 있습니다. 이 옵션 은 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt; 의 &lt;code&gt;--no-autostash&lt;/code&gt; 및 &lt;code&gt;--autostash&lt;/code&gt; 옵션 으로 재정의 할 수 있습니다 . 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="c92df8026c7e3a5d595e452302b48399c0fa7807" translate="yes" xml:space="preserve">
          <source>When set to true, automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run rebase on a dirty worktree. However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts. This option can be overridden by the &lt;code&gt;--no-autostash&lt;/code&gt; and &lt;code&gt;--autostash&lt;/code&gt; options of &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;. Defaults to false.</source>
          <target state="translated">true로 설정하면 작업이 시작되기 전에 임시 숨김 항목을 자동으로 생성하고 작업이 끝난 후에 적용합니다. 이는 더티 작업 트리에서 리베이스를 실행할 수 있음을 의미합니다. 그러나주의해서 사용하십시오. 리베이스에 성공한 후 최종 숨김 응용 프로그램은 사소한 충돌을 일으킬 수 있습니다. 이 옵션 은 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; 의 &lt;code&gt;--no-autostash&lt;/code&gt; 및 &lt;code&gt;--autostash&lt;/code&gt; 옵션 으로 재정의 할 수 있습니다 . 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="454e58d95a3a4a743aeef0859eac2b9c78e6f07a" translate="yes" xml:space="preserve">
          <source>When set to true, fetching from this remote by default will also remove any local tags that no longer exist on the remote if pruning is activated in general via &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt;, &lt;code&gt;fetch.prune&lt;/code&gt; or &lt;code&gt;--prune&lt;/code&gt;. Overrides &lt;code&gt;fetch.pruneTags&lt;/code&gt; settings, if any.</source>
          <target state="translated">true로 설정하면 기본적으로이 원격에서 가져 오면 정리가 일반적으로 &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; , &lt;code&gt;fetch.prune&lt;/code&gt; 또는 &lt;code&gt;--prune&lt;/code&gt; 을 통해 활성화되면 원격에 더 이상 존재하지 않는 로컬 태그도 제거됩니다 . &lt;code&gt;fetch.pruneTags&lt;/code&gt; 설정을 재정의 합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="2f08cdfbf2bbbb5ba49961d7515ae4f7f92a166e" translate="yes" xml:space="preserve">
          <source>When set to true, fetching from this remote by default will also remove any remote-tracking references that no longer exist on the remote (as if the &lt;code&gt;--prune&lt;/code&gt; option was given on the command line). Overrides &lt;code&gt;fetch.prune&lt;/code&gt; settings, if any.</source>
          <target state="translated">true로 설정하면 기본적으로이 원격 장치에서 가져 오면 원격에 더 이상 존재하지 않는 원격 추적 참조도 제거됩니다 ( &lt;code&gt;--prune&lt;/code&gt; 옵션이 명령 줄에 지정된 것처럼 ). &lt;code&gt;fetch.prune&lt;/code&gt; 설정을 재정의 합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="5739477a3b9489a88899be9378f898520709209f" translate="yes" xml:space="preserve">
          <source>When set to true, git-receive-pack will advertise the push options capability to its clients. False by default.</source>
          <target state="translated">true로 설정하면 git-receive-pack은 푸시 옵션 기능을 클라이언트에게 알립니다. 기본적으로 False입니다.</target>
        </trans-unit>
        <trans-unit id="af12eb66ec26d00e256f0fbfcc7125aeb108aa2e" translate="yes" xml:space="preserve">
          <source>When set to true, this remote will be used to fetch promisor objects.</source>
          <target state="translated">true로 설정하면이 리모콘을 사용하여 약속 개체를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="384788e82f8977bea09d8463e5bbfca26ec8a699" translate="yes" xml:space="preserve">
          <source>When set, the fetch or receive will abort in the case of a malformed object or a link to a nonexistent object. In addition, various other issues are checked for, including legacy issues (see &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt;), and potential security issues like the existence of a &lt;code&gt;.GIT&lt;/code&gt; directory or a malicious &lt;code&gt;.gitmodules&lt;/code&gt; file (see the release notes for v2.2.1 and v2.17.1 for details). Other sanity and security checks may be added in future releases.</source>
          <target state="translated">설정하면 잘못된 오브젝트 또는 존재하지 않는 오브젝트에 대한 링크의 경우 페치 또는 수신이 중단됩니다. 또한, 다양한 다른 문제는 기존의 문제 (참조를 포함하여 검사하는 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; ), 그리고의 존재와 같은 잠재적 인 보안 문제 &lt;code&gt;.GIT&lt;/code&gt; 의 디렉토리 또는 악의적 인 &lt;code&gt;.gitmodules&lt;/code&gt; 의 파일 (v2의 릴리스 노트를 참조하십시오. 자세한 내용은 2.1 및 v2.17.1을 참조하십시오. 다음 릴리스에서는 다른 무결성 및 보안 검사가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51a9809b150b3fa600feb6c1ea57e78e8de9e787" translate="yes" xml:space="preserve">
          <source>When showing &lt;code&gt;short&lt;/code&gt; or &lt;code&gt;porcelain&lt;/code&gt; status output, print the filename verbatim and terminate the entries with NUL, instead of LF. If no format is given, implies the &lt;code&gt;--porcelain&lt;/code&gt; output format. Without the &lt;code&gt;-z&lt;/code&gt; option, filenames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">도시 때 &lt;code&gt;short&lt;/code&gt; 이나 &lt;code&gt;porcelain&lt;/code&gt; 상태 출력을, LF 대신에, 축어 파일명 인쇄 NUL과 같이 종료. 형식이 지정되지 않으면 &lt;code&gt;--porcelain&lt;/code&gt; 출력 형식을 나타냅니다. &lt;code&gt;-z&lt;/code&gt; 옵션이 없으면 구성 변수 &lt;code&gt;core.quotePath&lt;/code&gt; 에 설명 된대로 &quot;특이하지 않은&quot;문자가 포함 된 파일 이름이 인용됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="43f2e6f1690661b84f31283fe1b400a9df885029" translate="yes" xml:space="preserve">
          <source>When showing a change that involves a rename or a copy, &lt;code&gt;--stat&lt;/code&gt; output formats the pathnames compactly by combining common prefix and suffix of the pathnames. For example, a change that moves &lt;code&gt;arch/i386/Makefile&lt;/code&gt; to &lt;code&gt;arch/x86/Makefile&lt;/code&gt; while modifying 4 lines will be shown like this:</source>
          <target state="translated">이름 바꾸기 또는 사본과 관련된 변경 사항을 표시 할 때 &lt;code&gt;--stat&lt;/code&gt; 출력은 경로 이름의 공통 접두사와 접미사를 결합하여 경로 이름을 압축합니다. 예를 들어, 4 줄을 수정하는 동안 &lt;code&gt;arch/i386/Makefile&lt;/code&gt; 을 &lt;code&gt;arch/x86/Makefile&lt;/code&gt; 로 이동하는 변경 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5d4332d6cfe825bd00a3bfef76e9ffde728a5dde" translate="yes" xml:space="preserve">
          <source>When showing commit messages, also show notes which are stored in the given ref. The ref must be fully qualified. If the given ref does not exist, it is not an error but means that no notes should be printed.</source>
          <target state="translated">커밋 메시지를 표시 할 때 주어진 참조에 저장된 메모도 표시하십시오. 심판은 정규화되어야합니다. 주어진 심판이 존재하지 않는다면, 그것은 오류가 아니지만 노트가 인쇄되지 않아야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="43020b05da28d5245a5572e708a459c7bb4d40bf" translate="yes" xml:space="preserve">
          <source>When showing object names, prefix them with &lt;code&gt;^&lt;/code&gt; and strip &lt;code&gt;^&lt;/code&gt; prefix from the object names that already have one.</source>
          <target state="translated">개체 이름을 표시 할 때, 그들을 앞에 &lt;code&gt;^&lt;/code&gt; 스트립 &lt;code&gt;^&lt;/code&gt; 개체 이름에서 접두어 이미 하나를 가지고 그.</target>
        </trans-unit>
        <trans-unit id="bf158ec030a04af48fd84ff99f4cdef61dbc802c" translate="yes" xml:space="preserve">
          <source>When showing the value of &amp;lt;name&amp;gt; as a symbolic ref, try to shorten the value, e.g. from &lt;code&gt;refs/heads/master&lt;/code&gt; to &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">&amp;lt;name&amp;gt;의 값을 기호 참조로 표시 할 때 값을 줄이십시오 (예 : &lt;code&gt;refs/heads/master&lt;/code&gt; 에서 &lt;code&gt;master&lt;/code&gt; 로) .</target>
        </trans-unit>
        <trans-unit id="d07871fea9de7a0886062f3dfa8bbc506d97b667" translate="yes" xml:space="preserve">
          <source>When shown by &lt;code&gt;git diff-tree -c&lt;/code&gt;, it compares the parents of a merge commit with the merge result (i.e. file1..fileN are the parents). When shown by &lt;code&gt;git diff-files -c&lt;/code&gt;, it compares the two unresolved merge parents with the working tree file (i.e. file1 is stage 2 aka &quot;our version&quot;, file2 is stage 3 aka &quot;their version&quot;).</source>
          <target state="translated">&lt;code&gt;git diff-tree -c&lt;/code&gt; 로 표시되면 병합 커밋의 부모를 병합 결과와 비교합니다 (즉, file1..fileN은 부모입니다). &lt;code&gt;git diff-files -c&lt;/code&gt; 로 표시되면 해결되지 않은 두 병합 부모를 작업 트리 파일과 비교합니다 (즉, file1은 &quot;우리 버전&quot;이라는 2 단계, file2는 &quot;그들의 버전&quot;이라고합니다).</target>
        </trans-unit>
        <trans-unit id="aea42e2933202e5e3d5f69076d6bebeb378dfcd9" translate="yes" xml:space="preserve">
          <source>When some commits have been skipped (using &quot;git bisect skip&quot;), then the bisection algorithm is the same for step 1) to 3). But then we use roughly the following steps:</source>
          <target state="translated">일부 커밋을 건너 뛴 경우 ( &quot;git bisect skip&quot;사용) 이분법 알고리즘은 1 단계에서 동일 함) ~ 3). 그러나 우리는 대략 다음 단계를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4192528671a22eca45fcad6bb5614a7ec165a5d4" translate="yes" xml:space="preserve">
          <source>When specified one or more times, &lt;code&gt;-L&lt;/code&gt; restricts annotation to the requested lines.</source>
          <target state="translated">한 번 이상 지정된 경우 &lt;code&gt;-L&lt;/code&gt; 은 주석을 요청 된 행으로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="75acd7ee44b0e77c6b233d3615dca447d4cfdc8c" translate="yes" xml:space="preserve">
          <source>When specifying the -v option the format used is:</source>
          <target state="translated">-v 옵션을 지정할 때 사용되는 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3b090cc032845d040434a6c212a06329d4b2d7ed" translate="yes" xml:space="preserve">
          <source>When subcommands such as &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;rename&lt;/code&gt;, and &lt;code&gt;remove&lt;/code&gt; can&amp;rsquo;t find the remote in question, the exit status is &lt;code&gt;2&lt;/code&gt;. When the remote already exists, the exit status is &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;add&lt;/code&gt; , &lt;code&gt;rename&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; 같은 하위 명령 이 문제의 원격을 찾을 수없는 경우 종료 상태는 &lt;code&gt;2&lt;/code&gt; 입니다. 리모트가 이미 존재하는 경우 종료 상태는 &lt;code&gt;3&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0550af8039db48de114d18431bb7375cee83b91b" translate="yes" xml:space="preserve">
          <source>When switching branches with &lt;code&gt;--merge&lt;/code&gt;, staged changes may be lost.</source>
          <target state="translated">&lt;code&gt;--merge&lt;/code&gt; 로 분기를 전환하면 단계적 변경 사항이 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f4fa4b7e00510c39cb24519dad3b49f07cff89d" translate="yes" xml:space="preserve">
          <source>When switching branches, if you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch.</source>
          <target state="translated">분기를 전환 할 때 현재 분기와 전환중인 분기간에 다른 하나 이상의 파일을 로컬로 수정 한 경우 명령은 컨텍스트에서 수정 사항을 보존하기 위해 분기 전환을 거부합니다. 그러나이 옵션을 사용하면 현재 분기, 작업 트리 내용 및 새 분기간에 3 방향 병합이 수행되고 새 분기에있게됩니다.</target>
        </trans-unit>
        <trans-unit id="7b0d58bb9103d272bfd260e85d337e6780ed225d" translate="yes" xml:space="preserve">
          <source>When switching branches, proceed even if the index or the working tree differs from &lt;code&gt;HEAD&lt;/code&gt;. This is used to throw away local changes.</source>
          <target state="translated">분기를 전환 할 때 색인 또는 작업 트리가 &lt;code&gt;HEAD&lt;/code&gt; 와 다른 경우에도 진행하십시오 . 로컬 변경 사항을 버리는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c0e1144ec53aca779c8724f81a0ba0a804f51a81" translate="yes" xml:space="preserve">
          <source>When the &quot;-C&quot; option is used, the original contents of modified files, and deleted files (and also unmodified files, if the &quot;--find-copies-harder&quot; option is used) are considered as candidates of the source files in rename/copy operation. If the input were like these filepairs, that talk about a modified file fileY and a newly created file file0:</source>
          <target state="translated">&quot;-C&quot;옵션을 사용하면 수정 된 파일의 원래 내용과 삭제 된 파일 (및 &quot;--find-copies-harder&quot;옵션을 사용하는 경우 수정되지 않은 파일)도 소스 파일의 후보로 간주됩니다. 이름 바꾸기 / 복사 작업. 입력이 이러한 파일 쌍과 같으면 수정 된 파일 fileY와 새로 작성된 파일 file0에 대해 이야기합니다.</target>
        </trans-unit>
        <trans-unit id="f6565c60ff0e235a6b049473d40ff8e72074a702" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; argument is a branch name, the &lt;code&gt;--detach&lt;/code&gt; option can be used to detach &lt;code&gt;HEAD&lt;/code&gt; at the tip of the branch (&lt;code&gt;git checkout
&amp;lt;branch&amp;gt;&lt;/code&gt; would check out that branch without detaching &lt;code&gt;HEAD&lt;/code&gt;).</source>
          <target state="translated">때 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 인수가 지점 이름의 &lt;code&gt;--detach&lt;/code&gt; 옵션을 분리하는 데 사용할 수 있습니다 &lt;code&gt;HEAD&lt;/code&gt; 분기의 끝에서 ( &lt;code&gt;git checkout &amp;lt;branch&amp;gt;&lt;/code&gt; 분리하지 않고 해당 분기 체크 아웃 할 &lt;code&gt;HEAD&lt;/code&gt; 를 ).</target>
        </trans-unit>
        <trans-unit id="588cf4af82a088b4d8241fca9de08188511b35c3" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--aggressive&lt;/code&gt; option is supplied, &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt; will be invoked with the &lt;code&gt;-f&lt;/code&gt; flag, which in turn will pass &lt;code&gt;--no-reuse-delta&lt;/code&gt; to &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;. This will throw away any existing deltas and re-compute them, at the expense of spending much more time on the repacking.</source>
          <target state="translated">때 &lt;code&gt;--aggressive&lt;/code&gt; 옵션이 제공되며, &lt;a href=&quot;git-repack&quot;&gt;자식 - 재 포장 [1]&lt;/a&gt; 호출한다 &lt;code&gt;-f&lt;/code&gt; 차례로 통과 할 플래그 &lt;code&gt;--no-reuse-delta&lt;/code&gt; 로 &lt;a href=&quot;git-pack-objects&quot;&gt;자식 팩 - 오브젝트 [1]&lt;/a&gt; . 이렇게하면 기존 델타를 버리고 재 포장에 훨씬 더 많은 시간을 소비하면서 재 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36c732582138b85601314513444f94ba223454f7" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--auto-merge&lt;/code&gt; is given, meld will merge all non-conflicting parts automatically, highlight the conflicting parts and wait for user decision. Setting &lt;code&gt;mergetool.meld.useAutoMerge&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; tells Git to unconditionally use the &lt;code&gt;--auto-merge&lt;/code&gt; option with &lt;code&gt;meld&lt;/code&gt;. Setting this value to &lt;code&gt;auto&lt;/code&gt; makes git detect whether &lt;code&gt;--auto-merge&lt;/code&gt; is supported and will only use &lt;code&gt;--auto-merge&lt;/code&gt; when available. A value of &lt;code&gt;false&lt;/code&gt; avoids using &lt;code&gt;--auto-merge&lt;/code&gt; altogether, and is the default value.</source>
          <target state="translated">때 &lt;code&gt;--auto-merge&lt;/code&gt; 주어, MELD는 자동으로 모든 충돌하지 않는 부분을 병합 충돌하는 부분을 강조 표시하고 사용자의 결정을 기다립니다. &lt;code&gt;mergetool.meld.useAutoMerge&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하면 Git 이 &lt;code&gt;meld&lt;/code&gt; 와 함께 &lt;code&gt;--auto-merge&lt;/code&gt; 옵션 을 무조건 사용하도록 지시 합니다. 이 값을 &lt;code&gt;auto&lt;/code&gt; 로 설정 하면 git이 &lt;code&gt;--auto-merge&lt;/code&gt; 가 지원 되는지 여부를 감지 하고 사용 가능한 경우 &lt;code&gt;--auto-merge&lt;/code&gt; 만 사용 합니다. &lt;code&gt;false&lt;/code&gt; 값은 &lt;code&gt;--auto-merge&lt;/code&gt; 를 함께 사용하지 않도록 하며 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="82879b1b4c41ea78abef977470f6f223214f239a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--stdin&lt;/code&gt; option is provided, the patterns are read from standard in as a newline-delimited list instead of from the arguments.</source>
          <target state="translated">때 &lt;code&gt;--stdin&lt;/code&gt; 옵션 옵션이 제공되면, 패턴의 개행 문자로 분리 된 목록으로 대신 인수에서 표준에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="0e72b560677fc7dbf879d4b64bab949efbe4ffc6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;-l&lt;/code&gt; option is used, format changes to</source>
          <target state="translated">때 &lt;code&gt;-l&lt;/code&gt; 옵션을 사용, 형식으로 변경</target>
        </trans-unit>
        <trans-unit id="2d7535050bbd171bed81a20302444843893d883d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;-z&lt;/code&gt; option is given, pathnames are printed as is and without any quoting and lines are terminated with a NUL (ASCII 0x00) byte.</source>
          <target state="translated">때 &lt;code&gt;-z&lt;/code&gt; 옵션이 주어, 경로 이름은 그대로 인쇄하고 인용하고 라인이 NUL 종료된다 (ASCII &amp;times; 00) 바이트 않고있다.</target>
        </trans-unit>
        <trans-unit id="e231e06fa3f3b3606e814466b6e12bf27e65315d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;.gitattributes&lt;/code&gt; file is missing from the work tree, the path in the index is used as a fall-back. During checkout process, &lt;code&gt;.gitattributes&lt;/code&gt; in the index is used and then the file in the working tree is used as a fall-back.</source>
          <target state="translated">때 &lt;code&gt;.gitattributes&lt;/code&gt; 의 파일이 작업 트리에서 누락 된 인덱스의 경로는 가을 백으로 사용됩니다. 체크 아웃 프로세스 중에 인덱스의 &lt;code&gt;.gitattributes&lt;/code&gt; 가 사용되고 작업 트리의 파일이 폴백으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ca6fe469ff13b0a4412dea9bd34db705e00a71db" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;LESS&lt;/code&gt; environment variable is unset, Git sets it to &lt;code&gt;FRX&lt;/code&gt; (if &lt;code&gt;LESS&lt;/code&gt; environment variable is set, Git does not change it at all). If you want to selectively override Git&amp;rsquo;s default setting for &lt;code&gt;LESS&lt;/code&gt;, you can set &lt;code&gt;core.pager&lt;/code&gt; to e.g. &lt;code&gt;less -S&lt;/code&gt;. This will be passed to the shell by Git, which will translate the final command to &lt;code&gt;LESS=FRX less -S&lt;/code&gt;. The environment does not set the &lt;code&gt;S&lt;/code&gt; option but the command line does, instructing less to truncate long lines. Similarly, setting &lt;code&gt;core.pager&lt;/code&gt; to &lt;code&gt;less -+F&lt;/code&gt; will deactivate the &lt;code&gt;F&lt;/code&gt; option specified by the environment from the command-line, deactivating the &quot;quit if one screen&quot; behavior of &lt;code&gt;less&lt;/code&gt;. One can specifically activate some flags for particular commands: for example, setting &lt;code&gt;pager.blame&lt;/code&gt; to &lt;code&gt;less -S&lt;/code&gt; enables line truncation only for &lt;code&gt;git blame&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;LESS&lt;/code&gt; 환경 변수를 설정하고, 힘내로 설정 &lt;code&gt;FRX&lt;/code&gt; (경우 &lt;code&gt;LESS&lt;/code&gt; 의 환경 변수 설정, 힘내 전혀 변경하지 않음). &lt;code&gt;LESS&lt;/code&gt; 에 대한 Git의 기본 설정을 선택적으로 무시 하려면 &lt;code&gt;core.pager&lt;/code&gt; 를 예를 들어 &lt;code&gt;less -S&lt;/code&gt; 로 설정할 수 있습니다 . 이것은 Git에 의해 쉘로 전달되며 최종 명령은 &lt;code&gt;LESS=FRX less -S&lt;/code&gt; 로 변환 됩니다. 환경은 &lt;code&gt;S&lt;/code&gt; 옵션을 설정하지 않지만 명령 행은 긴 행을 자르도록 지시합니다. 마찬가지로, 설정 &lt;code&gt;core.pager&lt;/code&gt; 을 에 &lt;code&gt;less -+F&lt;/code&gt; 비활성화됩니다 &lt;code&gt;F&lt;/code&gt; 를명령 줄에서 환경에 의해 지정된 옵션을 사용하여 &lt;code&gt;less&lt;/code&gt; 의 &quot;quit if one screen&quot;동작을 비활성화합니다 . 특정 명령에 대해 일부 플래그를 구체적으로 활성화 할 수 있습니다. 예를 들어 &lt;code&gt;pager.blame&lt;/code&gt; 을 &lt;code&gt;less -S&lt;/code&gt; 로 설정 하면 &lt;code&gt;git blame&lt;/code&gt; 에 대해서만 줄 잘림이 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="74ad9f83ee4c2323b6a50919a4a444bb844e349c" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;core.fsmonitor&lt;/code&gt; configuration variable is changed, the file system monitor is added to or removed from the index the next time a command reads the index. When &lt;code&gt;--[no-]fsmonitor&lt;/code&gt; are used, the file system monitor is immediately added to or removed from the index.</source>
          <target state="translated">때 &lt;code&gt;core.fsmonitor&lt;/code&gt; 의 구성 변수 변경, 파일 시스템 모니터는 인덱스에서 명령 인덱스를 판독 다음번에 추가되거나 제거된다. 시 &lt;code&gt;--[no-]fsmonitor&lt;/code&gt; 사용되고, 파일 시스템 모니터 즉시 추가 또는 인덱스로부터 제거된다.</target>
        </trans-unit>
        <trans-unit id="a4c9cc7c80e5659747cb4b3bf0914ba1addde698" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable is changed, the untracked cache is added to or removed from the index the next time a command reads the index; while when &lt;code&gt;--[no-|force-]untracked-cache&lt;/code&gt; are used, the untracked cache is immediately added to or removed from the index.</source>
          <target state="translated">때 &lt;code&gt;core.untrackedCache&lt;/code&gt; 의 구성 변수 변경의 추적 된 캐시 인덱스의 명령은 인덱스를 읽어 다음 번에 첨가되거나 제거; 반면 때 &lt;code&gt;--[no-|force-]untracked-cache&lt;/code&gt; 사용하는 상기 추적 된 캐시에 즉시 첨가 또는 인덱스로부터 제거.</target>
        </trans-unit>
        <trans-unit id="a212ca612f0b7b9b082dffe71078dd396d414402" translate="yes" xml:space="preserve">
          <source>When the attribute &lt;code&gt;ident&lt;/code&gt; is set for a path, Git replaces &lt;code&gt;$Id$&lt;/code&gt; in the blob object with &lt;code&gt;$Id:&lt;/code&gt;, followed by the 40-character hexadecimal blob object name, followed by a dollar sign &lt;code&gt;$&lt;/code&gt; upon checkout. Any byte sequence that begins with &lt;code&gt;$Id:&lt;/code&gt; and ends with &lt;code&gt;$&lt;/code&gt; in the worktree file is replaced with &lt;code&gt;$Id$&lt;/code&gt; upon check-in.</source>
          <target state="translated">속성 &lt;code&gt;ident&lt;/code&gt; 가 경로에 대해 설정되면 Git은 blob 객체의 &lt;code&gt;$Id$&lt;/code&gt; 를 &lt;code&gt;$Id:&lt;/code&gt; 바꾸고 , 그 뒤에 40 자 16 진 blob 객체 이름, 체크 아웃시 달러 기호 &lt;code&gt;$&lt;/code&gt; 를 차례로 바꿉니다 . 모든 바이트로 시작 순서 &lt;code&gt;$Id:&lt;/code&gt; 와 끝 &lt;code&gt;$&lt;/code&gt; worktree 파일로 대체됩니다 &lt;code&gt;$Id$&lt;/code&gt; 체크인시.</target>
        </trans-unit>
        <trans-unit id="c5a78c9a8f92224d51a41a84dbc93a853baeb6f6" translate="yes" xml:space="preserve">
          <source>When the browser, specified by options or configuration variables, is not among the supported ones, then the corresponding &lt;code&gt;browser.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; configuration variable will be looked up. If this variable exists then &lt;code&gt;git web--browse&lt;/code&gt; will treat the specified tool as a custom command and will use a shell eval to run the command with the URLs passed as arguments.</source>
          <target state="translated">옵션 또는 구성 변수로 지정된 브라우저가 지원되는 &lt;code&gt;browser.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 되지 않은 경우 해당 browser. &amp;lt;tool&amp;gt; .cmd 구성 변수가 조회됩니다. 이 변수가 있으면 &lt;code&gt;git web--browse&lt;/code&gt; 는 지정된 도구를 사용자 지정 명령으로 취급하고 셸 평가판을 사용하여 인수로 전달 된 URL로 명령을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="fa514f01de77ed627378917f2aa0b40cefa8c9a0" translate="yes" xml:space="preserve">
          <source>When the command enters the interactive mode, it shows the files and directories to be cleaned, and goes into its interactive command loop.</source>
          <target state="translated">명령이 대화식 모드로 들어가면 정리할 파일 및 디렉토리가 표시되고 대화식 명령 루프로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="8e767c7023b00ca52d4fb770ab49ce4dc284f987" translate="yes" xml:space="preserve">
          <source>When the command enters the interactive mode, it shows the output of the &lt;code&gt;status&lt;/code&gt; subcommand, and then goes into its interactive command loop.</source>
          <target state="translated">명령이 대화식 모드로 들어가면 &lt;code&gt;status&lt;/code&gt; 부속 명령 의 출력 이 표시되고 대화식 명령 루프로 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="e95952399796aad65deb415e39c303153d01cdf9" translate="yes" xml:space="preserve">
          <source>When the command is invoked from a subdirectory, show the path of the current directory relative to the top-level directory.</source>
          <target state="translated">하위 디렉토리에서 명령을 호출하면 최상위 디렉토리를 기준으로 현재 디렉토리의 경로를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="45506eccf72696bf6e0287a6eeda327142bb0f41" translate="yes" xml:space="preserve">
          <source>When the command is invoked from a subdirectory, show the path of the top-level directory relative to the current directory (typically a sequence of &quot;../&quot;, or an empty string).</source>
          <target state="translated">하위 디렉토리에서 명령을 호출 할 때 현재 디렉토리 (일반적으로 &quot;../&quot;시퀀스 또는 빈 문자열)를 기준으로 최상위 디렉토리의 경로를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="609d76b7287e730d5e5fcae1b57a1cde4d02d1ae" translate="yes" xml:space="preserve">
          <source>When the command is run without pathspec, it errors out, instead of deinit-ing everything, to prevent mistakes.</source>
          <target state="translated">pathspec없이 명령을 실행하면 실수를 방지하기 위해 모든 것을 초기화하지 않고 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2ebded60d45ed8776b0324d8d2138df90f552a15" translate="yes" xml:space="preserve">
          <source>When the command line does not specify what to push with &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; arguments or &lt;code&gt;--all&lt;/code&gt;, &lt;code&gt;--mirror&lt;/code&gt;, &lt;code&gt;--tags&lt;/code&gt; options, the command finds the default &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; by consulting &lt;code&gt;remote.*.push&lt;/code&gt; configuration, and if it is not found, honors &lt;code&gt;push.default&lt;/code&gt; configuration to decide what to push (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for the meaning of &lt;code&gt;push.default&lt;/code&gt;).</source>
          <target state="translated">명령 행에서 &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; 인수 또는 &lt;code&gt;--all&lt;/code&gt; , &lt;code&gt;--mirror&lt;/code&gt; , &lt;code&gt;--tags&lt;/code&gt; 옵션 으로 푸시 할 항목을 지정하지 않으면 명령은 &lt;code&gt;remote.*.push&lt;/code&gt; 구성 을 참조 하여 기본 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 을 찾습니다 . 찾을 수없는 경우 &lt;code&gt;push.default&lt;/code&gt; 구성을 준수 하여 푸시 대상을 결정합니다 ( &lt;code&gt;push.default&lt;/code&gt; 의 의미는 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4f61ade639e58b8586884fe92cb9eea816606ac2" translate="yes" xml:space="preserve">
          <source>When the command line does not specify where to push with the &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; argument, &lt;code&gt;branch.*.remote&lt;/code&gt; configuration for the current branch is consulted to determine where to push. If the configuration is missing, it defaults to &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">명령 행에서 &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; 인수 로 푸시 할 위치를 지정하지 않으면 푸시 할 위치를 결정하기 위해 현재 분기에 대한 &lt;code&gt;branch.*.remote&lt;/code&gt; 구성을 참조합니다. 구성이 누락되면 기본값은 &lt;code&gt;origin&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4dd963bd8e58b7ff2b11f8f622df35ecbcf28d58" translate="yes" xml:space="preserve">
          <source>When the commit diffs differ, &lt;code&gt;git range-diff&lt;/code&gt; recreates the original diffs' coloring, and adds outer -/+ diff markers with the &lt;strong&gt;background&lt;/strong&gt; being red/green to make it easier to see e.g. when there was a change in what exact lines were added.</source>
          <target state="translated">커밋 차이가 다르면 &lt;code&gt;git range-diff&lt;/code&gt; 는 원래 diff의 채색을 재현하고 &lt;strong&gt;배경&lt;/strong&gt; 이 빨간색 / 녹색 인 외부-/ + diff 마커를 추가하여 예를 들어 정확한 라인이 추가 된 변경 사항이있을 때 더 쉽게 볼 수 있도록합니다. .</target>
        </trans-unit>
        <trans-unit id="3625aba84b870871330cdfd48d8779c4e4badb58" translate="yes" xml:space="preserve">
          <source>When the commit log message begins with &quot;squash! &amp;hellip;​&quot; (or &quot;fixup! &amp;hellip;​&quot;), and there is already a commit in the todo list that matches the same &lt;code&gt;...&lt;/code&gt;, automatically modify the todo list of rebase -i so that the commit marked for squashing comes right after the commit to be modified, and change the action of the moved commit from &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;squash&lt;/code&gt; (or &lt;code&gt;fixup&lt;/code&gt;). A commit matches the &lt;code&gt;...&lt;/code&gt; if the commit subject matches, or if the &lt;code&gt;...&lt;/code&gt; refers to the commit&amp;rsquo;s hash. As a fall-back, partial matches of the commit subject work, too. The recommended way to create fixup/squash commits is by using the &lt;code&gt;--fixup&lt;/code&gt;/&lt;code&gt;--squash&lt;/code&gt; options of &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;.</source>
          <target state="translated">커밋 로그 메시지가 &quot;squash!&amp;hellip;&quot;(또는 &quot;fixup!&amp;hellip;&quot;)로 시작하고 동일한 todo 목록에 이미 &lt;code&gt;...&lt;/code&gt; 같은 커밋이있는 경우 rebase -i의 할 일 목록을 자동으로 수정하십시오. 스쿼시로 표시된 커밋이 수정 된 커밋 직후에 발생하고 이동 된 커밋의 동작을 &lt;code&gt;pick&lt;/code&gt; 에서 &lt;code&gt;squash&lt;/code&gt; (또는 &lt;code&gt;fixup&lt;/code&gt; )로 변경하십시오. 커밋 주제가 일치하거나 &lt;code&gt;...&lt;/code&gt; 가 커밋의 해시를 나타내는 경우 커밋 은 &lt;code&gt;...&lt;/code&gt; 과 일치합니다 . 대체로 커밋 주제의 부분 일치도 작동합니다. 수정 / 스쿼시 커밋을 만드는 권장 방법 은 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 의 &lt;code&gt;--fixup&lt;/code&gt; / &lt;code&gt;--squash&lt;/code&gt; 옵션을 사용하는 것입니다 ..</target>
        </trans-unit>
        <trans-unit id="777196d17b1a10c66d0cd105e5fb66da2363f7b1" translate="yes" xml:space="preserve">
          <source>When the config key &lt;code&gt;extensions.partialclone&lt;/code&gt; is set, it indicates that the repo was created with a partial clone (or later performed a partial fetch) and that the remote may have omitted sending certain unwanted objects. Such a remote is called a &quot;promisor remote&quot; and it promises that all such omitted objects can be fetched from it in the future.</source>
          <target state="translated">config key &lt;code&gt;extensions.partialclone&lt;/code&gt; 을 설정하면 리포지토리가 부분 복제본으로 생성되었거나 나중에 부분 페치를 수행하여 원격이 특정 원하지 않는 개체를 보내는 것을 생략했을 수 있습니다. 이러한 리모컨을 &quot;프로 미저 리모컨&quot;이라고하며, 생략 된 모든 객체를 앞으로 가져올 수 있다고 약속합니다.</target>
        </trans-unit>
        <trans-unit id="ef73607bec133cc1d32aaf64deafc8c72104731d" translate="yes" xml:space="preserve">
          <source>When the config key &lt;code&gt;extensions.preciousObjects&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, objects in the repository MUST NOT be deleted (e.g., by &lt;code&gt;git-prune&lt;/code&gt; or &lt;code&gt;git repack -d&lt;/code&gt;).</source>
          <target state="translated">config key &lt;code&gt;extensions.preciousObjects&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 저장소의 객체를 삭제해서는 안됩니다 (예 : &lt;code&gt;git-prune&lt;/code&gt; 또는 &lt;code&gt;git repack -d&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e23e26ad367e6b915821bbb7b38753fa6fd4c240" translate="yes" xml:space="preserve">
          <source>When the current working directory is below the repository directory print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">현재 작업 디렉토리가 저장소 디렉토리 아래에 있으면 &quot;true&quot;를 인쇄하고, 그렇지 않으면 &quot;false&quot;를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="8a7aa53d7bbe6bfa657a2a1bb84359882384d7fa" translate="yes" xml:space="preserve">
          <source>When the current working directory is inside the work tree of the repository print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">현재 작업 디렉토리가 저장소의 작업 트리 내에있는 경우 &quot;true&quot;를 인쇄하고 그렇지 않으면 &quot;false&quot;를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="e614fb1c074d0b3ebd865c7756d786dc01074ea4" translate="yes" xml:space="preserve">
          <source>When the environment variable &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is set, the program named by it is called to generate diffs, and Git does not use its builtin diff machinery. For a path that is added, removed, or modified, &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called with 7 parameters:</source>
          <target state="translated">환경 변수 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 가 설정되면 이름이 지정된 프로그램이 diff를 생성하기 위해 호출되고 Git은 내장 된 diff 기계를 사용하지 않습니다. 추가, 제거 또는 수정 된 경로의 경우 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 가 7 개의 매개 변수와 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="dd7dc6a4dcd86a8d725c2332772df83ad820f427" translate="yes" xml:space="preserve">
          <source>When the environment variable &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is set, the program named by it is called, instead of the diff invocation described above. For a path that is added, removed, or modified, &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called with 7 parameters:</source>
          <target state="translated">환경 변수 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 가 설정되면 위에서 설명한 diff 호출 대신 이름이 지정된 프로그램이 호출됩니다. 추가, 제거 또는 수정 된 경로의 경우 7 개의 매개 변수를 사용하여 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ec4de571b6827b1e0107c62834d6f8cf9f50bba2" translate="yes" xml:space="preserve">
          <source>When the git-rebase command is run, it will first execute a &quot;pre-rebase&quot; hook if one exists. You can use this hook to do sanity checks and reject the rebase if it isn&amp;rsquo;t appropriate. Please see the template pre-rebase hook script for an example.</source>
          <target state="translated">git-rebase 명령이 실행될 때 &quot;pre-rebase&quot;훅이 있으면 먼저 실행합니다. 이 후크를 사용하여 상태 검사를 수행하고 적절하지 않은 경우 리베이스를 거부 할 수 있습니다. 예제는 템플릿 사전 리베이스 후크 스크립트를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4663df00f4cd516023be3e887d8ecce789e72f00" translate="yes" xml:space="preserve">
          <source>When the history involves criss-cross merges, there can be more than one &lt;code&gt;best&lt;/code&gt; common ancestor for two commits. For example, with this topology:</source>
          <target state="translated">역사 십자 병합을 포함 할 경우, 하나 이상의있을 수 있습니다 &lt;code&gt;best&lt;/code&gt; 두 커밋에 대한 공통 조상. 예를 들어이 토폴로지의 경우</target>
        </trans-unit>
        <trans-unit id="58beafa5cea14c3b99014fb314d938b1ee9fac65" translate="yes" xml:space="preserve">
          <source>When the man viewer, specified by the &lt;code&gt;man.viewer&lt;/code&gt; configuration variables, is not among the supported ones, then the corresponding &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; configuration variable will be looked up. If this variable exists then the specified tool will be treated as a custom command and a shell eval will be used to run the command with the man page passed as arguments.</source>
          <target state="translated">&lt;code&gt;man.viewer&lt;/code&gt; 구성 변수로 지정된 man 뷰어 가 지원되는 변수 중 하나가 아닌 경우 해당 &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 구성 변수가 조회됩니다. 이 변수가 존재하면 지정된 도구는 사용자 정의 명령으로 취급되며 셸 평가는 명령 페이지를 인수로 전달하여 명령을 실행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d01c091e9d01b5baf9f294a1d7b9c823d7d014bc" translate="yes" xml:space="preserve">
          <source>When the output goes to a terminal, it is color-coded by default, just like regular &lt;code&gt;git diff&lt;/code&gt;'s output. In addition, the first line (adding a commit) is green, the last line (deleting a commit) is red, the second line (with a perfect match) is yellow like the commit header of &lt;code&gt;git
show&lt;/code&gt;'s output, and the third line colors the old commit red, the new one green and the rest like &lt;code&gt;git show&lt;/code&gt;'s commit header.</source>
          <target state="translated">출력이 터미널로 이동하면 일반 &lt;code&gt;git diff&lt;/code&gt; 출력 과 마찬가지로 기본적으로 색상이 코딩됩니다 . 또한 첫 번째 줄 (커밋 추가)은 녹색이고 마지막 줄 (커밋 삭제)은 빨간색이며 두 번째 줄 (완벽한 일치)은 &lt;code&gt;git show&lt;/code&gt; 출력 의 커밋 헤더와 같이 노란색 이며 세 번째 줄 라인은 오래된 커밋 빨간색, 새로운 커밋 녹색 및 나머지는 &lt;code&gt;git show&lt;/code&gt; 의 커밋 헤더와 같습니다.</target>
        </trans-unit>
        <trans-unit id="ecf68ce55bda2542529810833e005e7f157f71c2" translate="yes" xml:space="preserve">
          <source>When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally. &lt;code&gt;--no-3way&lt;/code&gt; can be used to override am.threeWay configuration variable. For more information, see am.threeWay in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">패치가 제대로 적용되지 않으면 패치에 적용 할 얼룩의 ID가 기록되고 해당 얼룩을 로컬로 사용할 수있는 경우 3 방향 병합으로 폴백합니다. &lt;code&gt;--no-3way&lt;/code&gt; 를 사용하여 am.threeWay 구성 변수를 대체 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]의&lt;/a&gt; am.threeWay를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="28728fcf386b485f532ec99285643062f0405ba5" translate="yes" xml:space="preserve">
          <source>When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to, and we have those blobs available locally, possibly leaving the conflict markers in the files in the working tree for the user to resolve. This option implies the &lt;code&gt;--index&lt;/code&gt; option, and is incompatible with the &lt;code&gt;--reject&lt;/code&gt; and the &lt;code&gt;--cached&lt;/code&gt; options.</source>
          <target state="translated">패치가 제대로 적용되지 않는 경우 패치에 적용 할 얼룩의 ID를 기록하고 해당 얼룩을 로컬로 사용할 수 있으면 작업 트리의 파일에 충돌 마커가 남을 수 있습니다. 사용자가 해결할 수 있습니다. 이 옵션은 &lt;code&gt;--index&lt;/code&gt; 옵션을 의미하며 &lt;code&gt;--reject&lt;/code&gt; 및 &lt;code&gt;--cached&lt;/code&gt; 옵션 과 호환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bdd1b4760c591dff915e966378bff929405d28b1" translate="yes" xml:space="preserve">
          <source>When the push is complete, outputs one or more &lt;code&gt;ok &amp;lt;dst&amp;gt;&lt;/code&gt; or &lt;code&gt;error &amp;lt;dst&amp;gt; &amp;lt;why&amp;gt;?&lt;/code&gt; lines to indicate success or failure of each pushed ref. The status report output is terminated by a blank line. The option field &amp;lt;why&amp;gt; may be quoted in a C style string if it contains an LF.</source>
          <target state="translated">푸시가 완료되면 하나 이상의 &lt;code&gt;ok &amp;lt;dst&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;error &amp;lt;dst&amp;gt; &amp;lt;why&amp;gt;?&lt;/code&gt; 푸시 된 각 심판의 성공 또는 실패를 나타내는 선. 상태 보고서 출력은 빈 줄로 종료됩니다. 옵션 필드 &amp;lt;why&amp;gt;는 LF를 포함하는 경우 C 스타일 문자열로 인용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c36826b0bb47b2400e28127fc2b6b138c228a63f" translate="yes" xml:space="preserve">
          <source>When the remote branch you want to fetch is known to be rewound and rebased regularly, it is expected that its new tip will not be descendant of its previous tip (as stored in your remote-tracking branch the last time you fetched). You would want to use the &lt;code&gt;+&lt;/code&gt; sign to indicate non-fast-forward updates will be needed for such branches. There is no way to determine or declare that a branch will be made available in a repository with this behavior; the pulling user simply must know this is the expected usage pattern for a branch.</source>
          <target state="translated">가져 오려는 원격 브랜치가 되감기 고 정기적으로 리베이스되는 것으로 알려진 경우, 새로운 팁이 이전 팁의 후손이 아닌 것으로 예상됩니다 (마지막 페치시 원격 추적 브랜치에 저장 됨). &lt;code&gt;+&lt;/code&gt; 기호 를 사용하여 해당 분기에 빨리 감기가 아닌 업데이트가 필요함을 나타냅니다. 이 동작으로 저장소에서 브랜치를 사용할 수 있다고 결정하거나 선언 할 방법이 없습니다. 당기는 사용자는 이것이 브랜치의 예상 사용 패턴임을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c2d02d0fdbdd6b68f91184ab0fd8a5fcfd84e982" translate="yes" xml:space="preserve">
          <source>When the repository is bare print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">리포지토리가 베어 인쇄 된 경우 &quot;true&quot;, 그렇지 않으면 &quot;false&quot;</target>
        </trans-unit>
        <trans-unit id="4881892c9231f2a8cbf0d32abf5995af521026ca" translate="yes" xml:space="preserve">
          <source>When the repository is shallow print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">저장소가 얕게 인쇄되면 &quot;true&quot;이고 그렇지 않으면 &quot;false&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="37826a890a4b64bdd1230276a23bd80630675ca5" translate="yes" xml:space="preserve">
          <source>When the repository named by &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; has the commit at a tip of a ref that is different from the ref you have locally, you can use the &lt;code&gt;&amp;lt;local&amp;gt;:&amp;lt;remote&amp;gt;&lt;/code&gt; syntax, to have its local name, a colon &lt;code&gt;:&lt;/code&gt;, and its remote name.</source>
          <target state="translated">&lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; 이라는 이름의 저장소에 로컬 참조와 다른 참조 끝에 커밋이있는 경우 &lt;code&gt;&amp;lt;local&amp;gt;:&amp;lt;remote&amp;gt;&lt;/code&gt; 구문을 사용하여 로컬 이름 인 콜론 &lt;code&gt;:&lt;/code&gt; , 그리고 그 원격 이름.</target>
        </trans-unit>
        <trans-unit id="a7fe7f8247bda757ca8d697055bcfe0913ae2caf" translate="yes" xml:space="preserve">
          <source>When the repository to clone from is on a local machine, this flag bypasses the normal &quot;Git aware&quot; transport mechanism and clones the repository by making a copy of HEAD and everything under objects and refs directories. The files under &lt;code&gt;.git/objects/&lt;/code&gt; directory are hardlinked to save space when possible.</source>
          <target state="translated">복제 할 저장소가 로컬 시스템에있는 경우이 플래그는 일반적인 &quot;Git aware&quot;전송 메커니즘을 무시하고 오브젝트 및 참조 디렉토리 아래에 HEAD 및 모든 사본을 작성하여 저장소를 복제합니다. &lt;code&gt;.git/objects/&lt;/code&gt; 디렉토리 의 파일 은 가능한 경우 공간을 절약하기 위해 하드 링크되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="87edb2bef2f28c0f63de7720d331d50db0279e94" translate="yes" xml:space="preserve">
          <source>When the repository to clone is on the local machine, instead of using hard links, automatically setup &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; to share the objects with the source repository. The resulting repository starts out without any object of its own.</source>
          <target state="translated">복제 할 리포지토리가 로컬 컴퓨터에있는 경우 하드 링크를 사용하는 대신 소스 리포지토리와 개체를 공유하도록 &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; 를 자동으로 설정 하십시오. 결과 리포지토리는 자체 개체없이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="e18b845f941d21aaf5232c387f67cb23d0a4e759" translate="yes" xml:space="preserve">
          <source>When the result of a &lt;code&gt;git bisect&lt;/code&gt; is a non-merge commit, you should normally be able to discover the problem by examining just that commit. Developers can make this easy by breaking their changes into small self-contained commits. That won&amp;rsquo;t help in the case above, however, because the problem isn&amp;rsquo;t obvious from examination of any single commit; instead, a global view of the development is required. To make matters worse, the change in semantics in the problematic function may be just one small part of the changes in the upper line of development.</source>
          <target state="translated">&lt;code&gt;git bisect&lt;/code&gt; 의 결과가 병합되지 않은 커밋 인 경우 일반적으로 해당 커밋 만 검사하여 문제를 발견 할 수 있습니다. 개발자는 변경 사항을 작은 자체 커밋으로 변경하여이를 쉽게 수행 할 수 있습니다. 그러나 위의 경우에는 도움이되지 않습니다. 단일 커밋을 검사하면 문제가 분명하지 않기 때문입니다. 대신, 개발에 대한 세계적 관점이 필요합니다. 설상가상으로, 문제가있는 함수에서 의미론의 변화는 개발의 상위 라인 변화의 작은 부분 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57dfd8622d0e5d97d5c5344dbdac2c35010a468d" translate="yes" xml:space="preserve">
          <source>When the split index feature is used, shared index files that were not modified since the time this variable specifies will be removed when a new shared index file is created. The value &quot;now&quot; expires all entries immediately, and &quot;never&quot; suppresses expiration altogether. The default value is &quot;2.weeks.ago&quot;. Note that a shared index file is considered modified (for the purpose of expiration) each time a new split-index file is either created based on it or read from it. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">인덱스 분할 기능을 사용하는 경우이 변수가 지정한 시간 이후 수정되지 않은 공유 인덱스 파일은 새 공유 인덱스 파일이 만들어 질 때 제거됩니다. &quot;now&quot;값은 모든 항목을 즉시 만료시키고 &quot;never&quot;는 만료를 완전히 억제합니다. 기본값은 &quot;2.weeks.ago&quot;입니다. 공유 인덱스 파일은 새 분할 인덱스 파일을 기반으로 만들거나 읽을 때마다 (만료 목적으로) 수정 된 것으로 간주됩니다. &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="887ef75c2523fd6b4da84b3a0a714f4995305746" translate="yes" xml:space="preserve">
          <source>When the split index feature is used, this specifies the percent of entries the split index can contain compared to the total number of entries in both the split index and the shared index before a new shared index is written. The value should be between 0 and 100. If the value is 0 then a new shared index is always written, if it is 100 a new shared index is never written. By default the value is 20, so a new shared index is written if the number of entries in the split index would be greater than 20 percent of the total number of entries. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">분할 인덱스 기능을 사용하는 경우 새 공유 인덱스를 작성하기 전에 분할 인덱스와 공유 인덱스의 총 항목 수와 비교할 때 분할 인덱스에 포함 할 수있는 항목의 백분율을 지정합니다. 값은 0과 100 사이 여야합니다. 값이 0이면 새 공유 인덱스가 항상 기록되고 100이면 새 공유 인덱스가 기록되지 않습니다. 기본적으로 값은 20이므로 분할 인덱스의 항목 수가 총 항목 수의 20 %보다 클 경우 새 공유 인덱스가 작성됩니다. &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1631afdb92ffecd0a40ddcd8f40433691ff79d82" translate="yes" xml:space="preserve">
          <source>When the value is &lt;code&gt;interactive&lt;/code&gt; (or just &lt;code&gt;i&lt;/code&gt;), the rebase is run in interactive mode.</source>
          <target state="translated">값이 &lt;code&gt;interactive&lt;/code&gt; (또는 &lt;code&gt;i&lt;/code&gt; 만 )이면 리베이스는 대화식 모드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="249674ff1351f5c865508a34f368a209ce692426" translate="yes" xml:space="preserve">
          <source>When the value is &lt;code&gt;interactive&lt;/code&gt;, the rebase is run in interactive mode.</source>
          <target state="translated">값이 &lt;code&gt;interactive&lt;/code&gt; 이면 rebase는 대화식 모드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2a8620af5de619d02cbdb1290090cf457f4270c6" translate="yes" xml:space="preserve">
          <source>When the working tree is updated, using --recurse-submodules will also recursively reset the working tree of all active submodules according to the commit recorded in the superproject, also setting the submodules' HEAD to be detached at that commit.</source>
          <target state="translated">작업 트리가 업데이트 될 때 --recurse-submodules를 사용하면 수퍼 프로젝트에 기록 된 커밋에 따라 모든 활성 서브 모듈의 작업 트리도 재귀 적으로 재설정되고 해당 커밋에서 분리되도록 서브 모듈의 HEAD를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="bbc30d1504ae5818b5ebed3f68f464e3d8d41b06" translate="yes" xml:space="preserve">
          <source>When there are approximately more than this many loose objects in the repository, &lt;code&gt;git gc --auto&lt;/code&gt; will pack them. Some Porcelain commands use this command to perform a light-weight garbage collection from time to time. The default value is 6700.</source>
          <target state="translated">저장소에 이보다 많은 느슨한 객체가 있으면 &lt;code&gt;git gc --auto&lt;/code&gt; 가이 를 포장합니다. 일부 Porcelain 명령은이 명령을 사용하여 때때로 가벼운 가비지 콜렉션을 수행합니다. 기본값은 6700입니다.</target>
        </trans-unit>
        <trans-unit id="c316674f184677333eb7d2b00fe1f02bf0eda4b8" translate="yes" xml:space="preserve">
          <source>When there are content conflicts, the merge machinery tries to annotate each side&amp;rsquo;s conflict markers with the commits where the content came from. Since the apply backend drops the original information about the rebased commits and their parents (and instead generates new fake commits based off limited information in the generated patches), those commits cannot be identified; instead it has to fall back to a commit summary. Also, when merge.conflictStyle is set to diff3, the apply backend will use &quot;constructed merge base&quot; to label the content from the merge base, and thus provide no information about the merge base commit whatsoever.</source>
          <target state="translated">콘텐츠 충돌이있을 때 병합 기계는 콘텐츠가 발생한 커밋으로 각 측면의 충돌 마커에 주석을 추가하려고합니다. 적용 백엔드는 리 기반 커밋과 그 부모에 대한 원래 정보를 삭제하고 (대신 생성 된 패치의 제한된 정보를 기반으로 새로운 가짜 커밋을 생성 함) 이러한 커밋을 식별 할 수 없습니다. 대신 커밋 요약으로 돌아 가야합니다. 또한 merge.conflictStyle이 diff3으로 설정되면 적용 백엔드는 &quot;구성된 병합 기준&quot;을 사용하여 병합 기준의 콘텐츠에 레이블을 지정하므로 병합 기준 커밋에 대한 정보를 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62fefa7cb364ff9a836bef0837ac15925fecc8f2" translate="yes" xml:space="preserve">
          <source>When there are more than this many packs that are not marked with &lt;code&gt;*.keep&lt;/code&gt; file in the repository, &lt;code&gt;git gc
--auto&lt;/code&gt; consolidates them into one larger pack. The default value is 50. Setting this to 0 disables it. Setting &lt;code&gt;gc.auto&lt;/code&gt; to 0 will also disable this.</source>
          <target state="translated">저장소에 &lt;code&gt;*.keep&lt;/code&gt; 파일 로 표시되지 않은이 팩보다 많은 팩이 있으면 &lt;code&gt;git gc --auto&lt;/code&gt; 는이 팩을 하나의 큰 팩으로 통합합니다. 기본값은 50입니다.이 값을 0으로 설정하면 비활성화됩니다. &lt;code&gt;gc.auto&lt;/code&gt; 를 0으로 설정하면 이 기능도 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="a99bf9777c550eb2f6602e82876314f8cadcb15d" translate="yes" xml:space="preserve">
          <source>When there is only one argument given and it is not &lt;code&gt;--&lt;/code&gt; (e.g. &lt;code&gt;git
checkout abc&lt;/code&gt;), and when the argument is both a valid &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (e.g. a branch &lt;code&gt;abc&lt;/code&gt; exists) and a valid &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; (e.g. a file or a directory whose name is &quot;abc&quot; exists), Git would usually ask you to disambiguate. Because checking out a branch is so common an operation, however, &lt;code&gt;git checkout abc&lt;/code&gt; takes &quot;abc&quot; as a &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; in such a situation. Use &lt;code&gt;git checkout -- &amp;lt;pathspec&amp;gt;&lt;/code&gt; if you want to checkout these paths out of the index.</source>
          <target state="translated">거기에 주어진 단 하나 개의 인수이며이 아닌 경우 &lt;code&gt;--&lt;/code&gt; (예를 들어 &lt;code&gt;git checkout abc&lt;/code&gt; ), 인수는 모두 유효한 경우 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (예 : 분기 &lt;code&gt;abc&lt;/code&gt; 존재하는) 유효한 &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; (예 : 파일 또는 이름이 &quot;abc&quot;인 디렉토리가 존재하는 경우) Git은 일반적으로 명확성을 요구합니다. 분기를 체크 아웃하는 것은 일반적인 작업이므로 &lt;code&gt;git checkout abc&lt;/code&gt; 는 이러한 상황에서 &quot;abc&quot;를 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 로 사용합니다. 인덱스에서 이러한 경로를 체크 &lt;code&gt;git checkout -- &amp;lt;pathspec&amp;gt;&lt;/code&gt; 하려면 git checkout-&amp;lt;pathspec&amp;gt;을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ff1d02c565a22d417998ec283b077273b716d4a" translate="yes" xml:space="preserve">
          <source>When these environment variables are set, the corresponding command-line arguments may not be used.</source>
          <target state="translated">이러한 환경 변수가 설정되면 해당 명령 줄 인수를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="86c4d2dcd046b538b0d9c792061f20bffd3f8c8e" translate="yes" xml:space="preserve">
          <source>When this flag is provided, the pack is read from stdin instead and a copy is then written to &amp;lt;pack-file&amp;gt;. If &amp;lt;pack-file&amp;gt; is not specified, the pack is written to objects/pack/ directory of the current Git repository with a default name determined from the pack content. If &amp;lt;pack-file&amp;gt; is not specified consider using --keep to prevent a race condition between this process and &lt;code&gt;git repack&lt;/code&gt;.</source>
          <target state="translated">이 플래그가 제공되면, 대신 stdin에서 팩을 읽은 다음 &amp;lt;pack-file&amp;gt;에 사본을 씁니다. &amp;lt;pack-file&amp;gt;을 지정하지 않으면 팩은 현재 Git 저장소의 objects / pack / 디렉토리에 팩 컨텐츠에서 결정된 기본 이름으로 기록됩니다. &amp;lt;pack-file&amp;gt;이 지정되지 않은 경우 --keep을 사용하여이 프로세스와 &lt;code&gt;git repack&lt;/code&gt; 사이의 경쟁 조건을 방지하십시오 .</target>
        </trans-unit>
        <trans-unit id="c91915e7d5f6096e68c1652d49f4ac505147354d" translate="yes" xml:space="preserve">
          <source>When this flag is specified, the object names recorded for the paths are not updated. Instead, this option sets/unsets the &quot;assume unchanged&quot; bit for the paths. When the &quot;assume unchanged&quot; bit is on, the user promises not to change the file and allows Git to assume that the working tree file matches what is recorded in the index. If you want to change the working tree file, you need to unset the bit to tell Git. This is sometimes helpful when working with a big project on a filesystem that has very slow lstat(2) system call (e.g. cifs).</source>
          <target state="translated">이 플래그를 지정하면 경로에 대해 기록 된 오브젝트 이름이 업데이트되지 않습니다. 대신이 옵션은 경로에 대해 &quot;변경되지 않은 것으로 가정&quot;비트를 설정 / 설정 해제합니다. &quot;변경되지 않은 것으로 가정&quot;비트가 켜져 있으면, 사용자는 파일을 변경하지 않겠다고 약속하고 Git은 작업 트리 파일이 인덱스에 기록 된 것과 일치한다고 가정 할 수 있습니다. 작업 트리 파일을 변경하려면 Git에 알리기 위해 비트를 설정 해제해야합니다. lstat (2) 시스템 호출이 매우 느린 파일 시스템 (예 : cifs)에서 큰 프로젝트로 작업 할 때 가끔 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b1f75c6b9b1b22670befceda22525699cad697f2" translate="yes" xml:space="preserve">
          <source>When this form of &lt;code&gt;git read-tree&lt;/code&gt; returns successfully, you can see which of the &quot;local changes&quot; that you made were carried forward by running &lt;code&gt;git diff-index --cached $M&lt;/code&gt;. Note that this does not necessarily match what &lt;code&gt;git diff-index --cached $H&lt;/code&gt; would have produced before such a two tree merge. This is because of cases 18 and 19 --- if you already had the changes in $M (e.g. maybe you picked it up via e-mail in a patch form), &lt;code&gt;git diff-index
--cached $H&lt;/code&gt; would have told you about the change before this merge, but it would not show in &lt;code&gt;git diff-index --cached $M&lt;/code&gt; output after the two-tree merge.</source>
          <target state="translated">이 형식의 &lt;code&gt;git read-tree&lt;/code&gt; 가 성공적으로 반환되면 &lt;code&gt;git diff-index --cached $M&lt;/code&gt; 을 실행하여 수행 한 &quot;로컬 변경&quot;중 어느 것이 수행 되었는지 확인할 수 있습니다. 이것은 두 개의 트리 병합 전에 &lt;code&gt;git diff-index --cached $H&lt;/code&gt; 가 생성 한 것과 반드시 ​​일치하지는 않습니다 . 이것은 18 번과 19 번 사건 때문입니다 --- 만약 $ M에 이미 변경이 있었다면 (예를 들어, 패치 형태로 전자 우편을 통해 받아 들일 수 있습니다 ), &lt;code&gt;git diff-index --cached $H&lt;/code&gt; 가 당신에게 말했을 것입니다 이 병합 전에 변경 사항에 대해 설명하지만 2 트리 병합 후 &lt;code&gt;git diff-index --cached $M&lt;/code&gt; 출력 에는 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a7b5d3881356f9c9c7fd25660fd80f9c16873a97" translate="yes" xml:space="preserve">
          <source>When this option is specified, the behavior is as if a special &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; argument were added at the beginning of the command line, where &amp;lt;value&amp;gt; is taken to be the standard output of the specified command with any leading and trailing whitespace trimmed off.</source>
          <target state="translated">이 옵션을 지정 하면 명령 행의 시작 부분에 특수 &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 인수가 추가 된 것처럼 작동 합니다. 여기서 &amp;lt;value&amp;gt;는 지정된 명령의 표준 출력이됩니다. 후행 공백이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="fe0e96d95c4eefa9bfe72917d015cf48a18efcc2" translate="yes" xml:space="preserve">
          <source>When this special attribute is read by &lt;code&gt;git credential&lt;/code&gt;, the value is parsed as a URL and treated as if its constituent parts were read (e.g., &lt;code&gt;url=https://example.com&lt;/code&gt; would behave as if &lt;code&gt;protocol=https&lt;/code&gt; and &lt;code&gt;host=example.com&lt;/code&gt; had been provided). This can help callers avoid parsing URLs themselves.</source>
          <target state="translated">이 특수 속성을 &lt;code&gt;git credential&lt;/code&gt; 에서 읽을 때 값은 URL로 구문 분석되고 구성 부분을 읽은 것처럼 처리됩니다 (예 : &lt;code&gt;url=https://example.com&lt;/code&gt; 은 &lt;code&gt;protocol=https&lt;/code&gt; 및 &lt;code&gt;host=example.com&lt;/code&gt; example.com 처럼 작동합니다 . com 이 제공되었습니다). 이렇게하면 호출자가 URL을 직접 구문 분석하지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de58814133990da5a575ac12a35ef9b3b981ae4a" translate="yes" xml:space="preserve">
          <source>When this special attribute is read by &lt;code&gt;git credential&lt;/code&gt;, the value is parsed as a URL and treated as if its constituent parts were read (e.g., &lt;code&gt;url=https://example.com&lt;/code&gt; would behave as if &lt;code&gt;protocol=https&lt;/code&gt; and &lt;code&gt;host=example.com&lt;/code&gt; had been provided). This can help callers avoid parsing URLs themselves. Note that any components which are missing from the URL (e.g., there is no username in the example above) will be set to empty; if you want to provide a URL and override some attributes, provide the URL attribute first, followed by any overrides.</source>
          <target state="translated">이 특수 속성이 &lt;code&gt;git credential&lt;/code&gt; 에 의해 읽 히면 값은 URL로 구문 분석되어 구성 부분을 읽은 것처럼 처리됩니다 (예 : &lt;code&gt;url=https://example.com&lt;/code&gt; 은 &lt;code&gt;protocol=https&lt;/code&gt; 및 &lt;code&gt;host=example.com&lt;/code&gt; 처럼 작동합니다 . com 이 제공되었습니다). 이렇게하면 발신자가 URL을 구문 분석하지 않아도됩니다. URL에서 누락 된 모든 구성 요소 (예 : 위의 예에서 사용자 이름이 없음)는 비어 있습니다. URL을 제공하고 일부 속성을 재정의하려면 URL 속성을 먼저 제공 한 다음 재정의를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="882eafec7b82da90c1fd3ae7dc7040457d013cf9" translate="yes" xml:space="preserve">
          <source>When trace files are written to a target directory, they will be named according to the last component of the SID (optionally followed by a counter to avoid filename collisions).</source>
          <target state="translated">추적 파일이 대상 디렉토리에 기록되면 SID의 마지막 구성 요소에 따라 이름이 지정됩니다 (선택적으로 파일 이름 충돌을 피하기 위해 카운터가 뒤 따름).</target>
        </trans-unit>
        <trans-unit id="1771ffd8c74f9f0b2e623ff3c52581b28a17469b" translate="yes" xml:space="preserve">
          <source>When tracking multiple directories (using --stdlayout, --branches, or --tags options), git svn will attempt to connect to the root (or highest allowed level) of the Subversion repository. This default allows better tracking of history if entire projects are moved within a repository, but may cause issues on repositories where read access restrictions are in place. Passing &lt;code&gt;--no-minimize-url&lt;/code&gt; will allow git svn to accept URLs as-is without attempting to connect to a higher level directory. This option is off by default when only one URL/branch is tracked (it would do little good).</source>
          <target state="translated">--stdlayout, --branches 또는 --tags 옵션을 사용하여 여러 디렉토리를 추적 할 때 git svn은 Subversion 저장소의 루트 (또는 최고 허용 레벨)에 연결을 시도합니다. 이 기본값은 전체 프로젝트가 저장소 내에서 이동 된 경우 히스토리를 더 잘 추적 할 수 있지만 읽기 액세스 제한이있는 저장소에 문제를 일으킬 수 있습니다. &lt;code&gt;--no-minimize-url&lt;/code&gt; 을 전달 하면 git svn이 상위 디렉토리에 연결하지 않고있는 그대로 URL을 수락 할 수 있습니다. 이 옵션은 하나의 URL / 브랜치 만 추적 할 때 기본적으로 해제되어 있습니다 (아주 효과가 거의 없음).</target>
        </trans-unit>
        <trans-unit id="442a6a05d34f849ad275ea5e7d6f50f5aafe59d9" translate="yes" xml:space="preserve">
          <source>When true, and when reachability bitmaps are enabled, pack-objects will try to send parts of the bitmapped packfile verbatim. This can reduce memory and CPU usage to serve fetches, but might result in sending a slightly larger pack. Defaults to true.</source>
          <target state="translated">true이고 도달 가능성 비트 맵이 활성화되면 pack-objects는 비트 맵 된 packfile의 일부를 그대로 보내려고합니다. 이렇게하면 가져 오기를 제공하기위한 메모리 및 CPU 사용량이 줄어들 수 있지만 약간 더 큰 팩을 보낼 수 있습니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="fce35b3add797f616ba5b3be537b437a03e625f0" translate="yes" xml:space="preserve">
          <source>When true, git will default to using the &lt;code&gt;--sparse&lt;/code&gt; option in &lt;code&gt;git pack-objects&lt;/code&gt; when the &lt;code&gt;--revs&lt;/code&gt; option is present. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. Default is &lt;code&gt;false&lt;/code&gt; unless &lt;code&gt;feature.experimental&lt;/code&gt; is enabled.</source>
          <target state="translated">true 인 경우 &lt;code&gt;--revs&lt;/code&gt; 옵션이 있으면 git은 기본적으로 &lt;code&gt;git pack-objects&lt;/code&gt; 에서 &lt;code&gt;--sparse&lt;/code&gt; 옵션 을 사용합니다 . 이 알고리즘은 새로운 객체를 도입하는 경로에 나타나는 트리 만 걷는다. 이것은 작은 변화를 보내기 위해 팩을 계산할 때 상당한 성능 이점을 가질 수 있습니다. 그러나 포함 된 커밋에 특정 유형의 직접 이름 바꾸기가 포함되어 있으면 추가 객체가 팩 파일에 추가 될 수 있습니다. &lt;code&gt;feature.experimental&lt;/code&gt; 을 사용 하지 않으면 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a46d4189a8b9229b7d91d54cdebfebe81ffd9ae6" translate="yes" xml:space="preserve">
          <source>When true, git will default to using the &lt;code&gt;--sparse&lt;/code&gt; option in &lt;code&gt;git pack-objects&lt;/code&gt; when the &lt;code&gt;--revs&lt;/code&gt; option is present. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">true이면 git은 &lt;code&gt;--revs&lt;/code&gt; 옵션이 있을 때 &lt;code&gt;git pack-objects&lt;/code&gt; 에서 &lt;code&gt;--sparse&lt;/code&gt; 옵션을 기본적으로 사용합니다 . 이 알고리즘은 새 개체를 도입하는 경로에 나타나는 나무 만 걷습니다. 이것은 작은 변화를 보내기 위해 팩을 계산할 때 상당한 성능 이점을 가질 수 있습니다. 그러나 포함 된 커밋에 특정 유형의 직접 이름 변경이 포함 된 경우 추가 개체가 팩 파일에 추가 될 수 있습니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5d73311a3b4a00977d7e2237078b01efb9320bfa" translate="yes" xml:space="preserve">
          <source>When true, git will include a &quot;hash cache&quot; section in the bitmap index (if one is written). This cache can be used to feed git&amp;rsquo;s delta heuristics, potentially leading to better deltas between bitmapped and non-bitmapped objects (e.g., when serving a fetch between an older, bitmapped pack and objects that have been pushed since the last gc). The downside is that it consumes 4 bytes per object of disk space. Defaults to true.</source>
          <target state="translated">true 인 경우 git은 &quot;해시 캐시&quot;섹션을 비트 맵 인덱스에 작성합니다 (작성된 경우). 이 캐시는 git의 델타 휴리스틱을 제공하는 데 사용될 수 있으며, 잠재적으로 비트 맵 및 비트 맵되지 않은 객체 사이의 델타를 향상시킬 수 있습니다 (예 : 이전, 비트 맵 된 팩과 마지막 gc 이후 푸시 된 객체 간의 페치 제공시). 단점은 디스크 공간 객체 당 4 바이트를 소비한다는 것입니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="98f36898b39f3ac14609adb644f7b367554be4b3" translate="yes" xml:space="preserve">
          <source>When true, git will use pack bitmaps (if available) when packing to stdout (e.g., during the server side of a fetch). Defaults to true. You should not generally need to turn this off unless you are debugging pack bitmaps.</source>
          <target state="translated">참이면, git은 stdout으로 패킹 할 때 (예를 들어, 페치의 서버 측에서) 팩 비트 맵 (사용 가능한 경우)을 사용합니다. 기본값은 true입니다. 팩 비트 맵을 디버깅하지 않는 한 일반적으로이 기능을 해제 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3060361b8b64f7f4f15aa5d402b402d65fd1ef21" translate="yes" xml:space="preserve">
          <source>When true, git will write a bitmap index when packing all objects to disk (e.g., when &lt;code&gt;git repack -a&lt;/code&gt; is run). This index can speed up the &quot;counting objects&quot; phase of subsequent packs created for clones and fetches, at the cost of some disk space and extra time spent on the initial repack. This has no effect if multiple packfiles are created. Defaults to true on bare repos, false otherwise.</source>
          <target state="translated">참이면, git은 모든 객체를 디스크에 패킹 할 때 (예를 들어, &lt;code&gt;git repack -a&lt;/code&gt; 가 실행될 때) 비트 맵 인덱스를 씁니다 . 이 인덱스를 사용하면 일부 디스크 공간과 초기 재 포장에 소요되는 추가 시간을 소비하면서 클론 및 페치에 대해 생성 된 후속 팩의 &quot;개체 수 계산&quot;단계를 가속화 할 수 있습니다. 여러 팩 파일이 생성 된 경우에는 효과가 없습니다. 베어 리포 지에서는 기본값이 true이고, 그렇지 않으면 false입니다.</target>
        </trans-unit>
        <trans-unit id="b7b0c56b83a62c5cf7d9e0b77ba1430747588d7a" translate="yes" xml:space="preserve">
          <source>When true, rebase branches on top of the fetched branch, instead of merging the default branch from the default remote when &quot;git pull&quot; is run. See &quot;branch.&amp;lt;name&amp;gt;.rebase&quot; for setting this on a per-branch basis.</source>
          <target state="translated">true 인 경우, &quot;git pull&quot;이 실행될 때 기본 원격에서 기본 분기를 병합하는 대신 가져온 분기 위에 분기를 리베이스하십시오. 분기별로이를 설정하려면 &quot;branch. &amp;lt;name&amp;gt; .rebase&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c15c8ba9ac152f7e581087f6ca67eb8a95961a05" translate="yes" xml:space="preserve">
          <source>When true, rebase the branch &amp;lt;name&amp;gt; on top of the fetched branch, instead of merging the default branch from the default remote when &quot;git pull&quot; is run. See &quot;pull.rebase&quot; for doing this in a non branch-specific manner.</source>
          <target state="translated">true 인 경우 &quot;git pull&quot;이 실행될 때 기본 원격에서 기본 분기를 병합하는 대신 가져온 분기의 맨 위에 &amp;lt;name&amp;gt; 분기를 리베이스하십시오. 비지정 방식으로이를 수행하려면 &quot;pull.rebase&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="32f2ccfcaf97ac2d1b8fdcbcf4ee46e8d18499a7" translate="yes" xml:space="preserve">
          <source>When true, rebase the current branch on top of the upstream branch after fetching. If there is a remote-tracking branch corresponding to the upstream branch and the upstream branch was rebased since last fetched, the rebase uses that information to avoid rebasing non-local changes.</source>
          <target state="translated">참이면 페치 한 후 업스트림 브랜치 위에 현재 브랜치를 리베이스합니다. 업스트림 브랜치에 해당하는 원격 추적 브랜치가 있고 마지막 페치 이후 업스트림 브랜치가 리베이스 된 경우 리베이스는 해당 정보를 사용하여 로컬이 아닌 변경 사항의 재베이스를 피합니다.</target>
        </trans-unit>
        <trans-unit id="e3872f2dbeef66b0c7927df02dbbfa3a35c8d12b" translate="yes" xml:space="preserve">
          <source>When two trees are given, it compares the first tree with the second. When a single commit is given, it compares the commit with its parents. The remaining commits, when given, are used as if they are parents of the first commit.</source>
          <target state="translated">두 개의 나무가 주어지면 첫 번째 나무와 두 번째 나무를 비교합니다. 단일 커밋이 제공되면 해당 커밋을 부모와 비교합니다. 주어진 커밋은 마치 첫 커밋의 부모 인 것처럼 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6b17aa5b71b9d47ea9adc71f193314f65da5b538" translate="yes" xml:space="preserve">
          <source>When two trees are specified, the user is telling &lt;code&gt;git read-tree&lt;/code&gt; the following:</source>
          <target state="translated">두 개의 트리가 지정되면 사용자는 &lt;code&gt;git read-tree&lt;/code&gt; 에게 다음을 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="0b1c4e2bbef526c82867f5bdebb7889317040a32" translate="yes" xml:space="preserve">
          <source>When unpacking a corrupt packfile, the command dies at the first corruption. This flag tells it to keep going and make the best effort to recover as many objects as possible.</source>
          <target state="translated">손상된 팩 파일의 압축을 풀 때 첫 번째 손상시 명령이 종료됩니다. 이 플래그는 계속 진행하고 가능한 많은 오브젝트를 복구하기 위해 최선을 다하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="5a3166bdcd39ee71b5c10c4011020b35e1491541" translate="yes" xml:space="preserve">
          <source>When unspecified, all references, after filtering done with --heads and --tags, are shown. When &amp;lt;refs&amp;gt;&amp;hellip;​ are specified, only references matching the given patterns are displayed.</source>
          <target state="translated">지정하지 않으면 --heads 및 --tags로 필터링 한 후 모든 참조가 표시됩니다. &amp;lt;refs&amp;gt;&amp;hellip;가 지정되면 주어진 패턴과 일치하는 참조 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fa62c673234c7d272766be9489825a6b1fba8b8c" translate="yes" xml:space="preserve">
          <source>When used in conjunction with the untracked cache, it can further improve performance by avoiding the cost of scanning the entire working directory looking for new files.</source>
          <target state="translated">추적되지 않은 캐시와 함께 사용하면 새 파일을 찾는 전체 작업 디렉토리를 스캔하는 비용을 피함으로써 성능을 더욱 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4699c35836688678c5cc37f1963f740eb7581527" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;-B&lt;/code&gt;, omit also the preimage in the deletion part of a delete/create pair.</source>
          <target state="translated">&lt;code&gt;-B&lt;/code&gt; 와 함께 사용되는 경우 삭제 / 작성 쌍의 삭제 부분에서 사전 이미지도 생략하십시오.</target>
        </trans-unit>
        <trans-unit id="81ec7d099c83d3c361cd6013c655cfcd1bc1c8c9" translate="yes" xml:space="preserve">
          <source>When used with -C/-c/--amend options, or when committing after a conflicting cherry-pick, declare that the authorship of the resulting commit now belongs to the committer. This also renews the author timestamp.</source>
          <target state="translated">-C / -c /-amend 옵션과 함께 사용하거나 충돌하는 체리 픽 후 커밋 할 때 결과 커밋의 권한이 이제 커미터에 속한다고 선언합니다. 또한 작성자 타임 스탬프도 갱신됩니다.</target>
        </trans-unit>
        <trans-unit id="b6df5147373d036993fb497c4d7575874db40c5c" translate="yes" xml:space="preserve">
          <source>When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number &lt;code&gt;n&lt;/code&gt; controls this aspect of the -B option (defaults to 50%). &lt;code&gt;-B20%&lt;/code&gt; specifies that a change with addition and deletion compared to 20% or more of the file&amp;rsquo;s size are eligible for being picked up as a possible source of a rename to another file.</source>
          <target state="translated">-M과 함께 사용하면 완전히 다시 작성된 파일도 이름 바꾸기의 소스로 간주되며 (보통 -M은 이름 바꾸기의 소스로 사라진 파일 만 고려함) 숫자 &lt;code&gt;n&lt;/code&gt; 은 -B 옵션의이 측면을 제어합니다. (기본값은 50 %). &lt;code&gt;-B20%&lt;/code&gt; 는 파일 크기의 20 % 이상과 비교하여 추가 및 삭제가있는 변경 사항이 다른 파일로 이름 바꾸기의 가능한 소스로 선택 될 수 있음을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="372d4fbee27ed51979ac65f708d9745903af8bc0" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;--all&lt;/code&gt; print description for all recognized commands. This is the default.</source>
          <target state="translated">인식 된 모든 명령에 대해 &lt;code&gt;--all&lt;/code&gt; print description 과 함께 사용됩니다 . 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="9b2454d94f74e12e4789baf13180d6dd9add197c" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;-ad&lt;/code&gt;, any unreachable objects from existing packs will be appended to the end of the packfile instead of being removed. In addition, any unreachable loose objects will be packed (and their loose counterparts removed).</source>
          <target state="translated">&lt;code&gt;-ad&lt;/code&gt; 와 함께 사용하면 기존 팩에서 도달 할 수없는 모든 객체가 제거되지 않고 팩 파일의 끝에 추가됩니다. 또한 닿을 수없는 느슨한 물체는 포장되어 있으며 느슨한 물체는 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="80b1c638669214a11658afe3022f9a5fd154c307" translate="yes" xml:space="preserve">
          <source>When used with the &lt;code&gt;value-pattern&lt;/code&gt; argument, treat &lt;code&gt;value-pattern&lt;/code&gt; as an exact string instead of a regular expression. This will restrict the name/value pairs that are matched to only those where the value is exactly equal to the &lt;code&gt;value-pattern&lt;/code&gt;.</source>
          <target state="translated">함께 사용하면 &lt;code&gt;value-pattern&lt;/code&gt; 인수, 치료 &lt;code&gt;value-pattern&lt;/code&gt; 정확한 문자열 대신 정규 표현식으로. 이렇게하면 값이 &lt;code&gt;value-pattern&lt;/code&gt; 과 정확히 같은 이름 / 값 쌍에만 일치하는 이름 / 값 쌍이 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="f93c22c6857bec96ca286a73d77a732b313ba7be" translate="yes" xml:space="preserve">
          <source>When using --error-unmatch to expand the user supplied &amp;lt;file&amp;gt; (i.e. path pattern) arguments to paths, pretend that paths which were removed in the index since the named &amp;lt;tree-ish&amp;gt; are still present. Using this option with &lt;code&gt;-s&lt;/code&gt; or &lt;code&gt;-u&lt;/code&gt; options does not make any sense.</source>
          <target state="translated">--error-unmatch를 사용하여 사용자가 제공 한 &amp;lt;file&amp;gt; (예 : 경로 패턴) 인수를 경로로 확장하는 경우 명명 된 &amp;lt;tree-ish&amp;gt; 이후 인덱스에서 제거 된 경로가 여전히 존재합니다. 이 옵션을 &lt;code&gt;-s&lt;/code&gt; 또는 &lt;code&gt;-u&lt;/code&gt; 옵션과 함께 사용하면 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c409615f2beb16e70015d6d6f46a1b549d1fd7f1" translate="yes" xml:space="preserve">
          <source>When using --hash (and not --dereference) the output format is: &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt;</source>
          <target state="translated">--hash를 사용하고 --dereference는 사용하지 않는 경우 출력 형식은 다음과 같습니다. &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4048d2aa35caefecff5d81ef992bce0c4fb7143f" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;--full-history&lt;/code&gt;, Git walks every edge. This will discover the commits &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; and the merge &lt;code&gt;M&lt;/code&gt;, but also will reveal the merge commits &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt;. With parent rewriting, the resulting graph is:</source>
          <target state="translated">&lt;code&gt;--full-history&lt;/code&gt; 를 사용할 때 Git은 모든면에서 다가 갑니다. 이것은 커밋 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 와 병합 &lt;code&gt;M&lt;/code&gt; 을 발견 하지만 병합 커밋 &lt;code&gt;O&lt;/code&gt; 와 &lt;code&gt;P&lt;/code&gt; 도 나타냅니다 . 부모 다시 쓰기를 사용하면 결과 그래프는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="081b8dc63c3bf5b426e1b11153b55d3d12af50bd" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;--get&lt;/code&gt;, and the requested variable is not found, behave as if &amp;lt;value&amp;gt; were the value assigned to the that variable.</source>
          <target state="translated">&lt;code&gt;--get&lt;/code&gt; 을 사용할 때 요청 된 변수를 찾을 수 없으면 &amp;lt;value&amp;gt;가 해당 변수에 지정된 값인 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="a0e35ae72d386768f718c98e1facc75ecb16026b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;git diff&lt;/code&gt; to compare with work tree files, do not consider stat-only change as changed. Instead, silently run &lt;code&gt;git update-index --refresh&lt;/code&gt; to update the cached stat information for paths whose contents in the work tree match the contents in the index. This option defaults to true. Note that this affects only &lt;code&gt;git diff&lt;/code&gt; Porcelain, and not lower level &lt;code&gt;diff&lt;/code&gt; commands such as &lt;code&gt;git diff-files&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git diff&lt;/code&gt; 를 사용하여 작업 트리 파일과 비교할 때 통계 전용 변경을 변경된 것으로 고려하지 마십시오. 대신, &lt;code&gt;git update-index --refresh&lt;/code&gt; 를 자동으로 실행 하여 작업 트리의 내용이 색인의 내용과 일치하는 경로에 대해 캐시 된 통계 정보를 업데이트하십시오. 이 옵션의 기본값은 true입니다. 이것은 &lt;code&gt;git diff&lt;/code&gt; Porcelain 에만 영향을 미치며 &lt;code&gt;git diff-files&lt;/code&gt; 와 같은 하위 수준 &lt;code&gt;diff&lt;/code&gt; 명령 에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b88f8d37a4b8b52b11aa1a9190d81927513fc837" translate="yes" xml:space="preserve">
          <source>When using either the ssh:// or file:// transport, the GIT_PROTOCOL environment variable must be set explicitly to include &quot;version=2&quot;.</source>
          <target state="translated">ssh : // 또는 file : // 전송을 사용하는 경우 GIT_PROTOCOL 환경 변수는 &quot;version = 2&quot;를 포함하도록 명시 적으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0ba437f399f8167203a8f1358d574f4341e76291" translate="yes" xml:space="preserve">
          <source>When using multiple --branches or --tags, &lt;code&gt;git svn&lt;/code&gt; does not automatically handle name collisions (for example, if two branches from different paths have the same name, or if a branch and a tag have the same name). In these cases, use &lt;code&gt;init&lt;/code&gt; to set up your Git repository then, before your first &lt;code&gt;fetch&lt;/code&gt;, edit the $GIT_DIR/config file so that the branches and tags are associated with different name spaces. For example:</source>
          <target state="translated">여러 --branches 또는 --tags를 사용하는 경우 &lt;code&gt;git svn&lt;/code&gt; 은 이름 충돌을 자동으로 처리하지 않습니다 (예 : 서로 다른 경로의 두 분기가 같은 이름을 가지거나 분기와 태그의 이름이 같은 경우). 이 경우 &lt;code&gt;init&lt;/code&gt; 을 사용 하여 Git 리포지토리를 설정 한 다음 첫 번째 &lt;code&gt;fetch&lt;/code&gt; 전에 $ GIT_DIR / config 파일을 편집하여 브랜치와 태그가 다른 네임 스페이스와 연결되도록하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66eede648bb8458831446e45d1bace5161e3e57f" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--simplify-merges&lt;/code&gt; option, the commits &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; disappear from the results. This is because the rewritten second parents of &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; are reachable from their first parents. Those edges are removed and then the commits look like single-parent commits that are TREESAME to their parent. This also happens to the commit &lt;code&gt;N&lt;/code&gt;, resulting in a history view as follows:</source>
          <target state="translated">사용하는 경우 &lt;code&gt;--simplify-merges&lt;/code&gt; 옵션을 커밋 &lt;code&gt;O&lt;/code&gt; 및 &lt;code&gt;P&lt;/code&gt; 는 결과에서 사라집니다. 이는 다시 작성된 &lt;code&gt;O&lt;/code&gt; 및 &lt;code&gt;P&lt;/code&gt; 의 두 번째 부모가 첫 번째 부모에서 도달 할 수 있기 때문 입니다. 이러한 가장자리가 제거되고 커밋은 부모에게 TREESAME 인 단일 부모 커밋처럼 보입니다. 이것은 커밋 &lt;code&gt;N&lt;/code&gt; 에도 발생하여 다음과 같은 히스토리보기가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="bb2aee242441b06254e02f3a0a2e1341fe75fee4" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--verify&lt;/code&gt; flag, the command requires an exact path:</source>
          <target state="translated">&lt;code&gt;--verify&lt;/code&gt; 플래그를 사용하는 경우 명령에 정확한 경로가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="33199341df233e06da35e7d1be5de579f81a31d0" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;refspec&lt;/code&gt; capability, git normally updates the private ref on successful push. This update is disabled when the remote-helper declares the capability &lt;code&gt;no-private-update&lt;/code&gt;.</source>
          <target state="translated">참조 사양 기능을 사용하는 경우 git은 일반적으로 성공적인 &lt;code&gt;refspec&lt;/code&gt; 개인 참조를 업데이트합니다. 원격 도우미가 &lt;code&gt;no-private-update&lt;/code&gt; 기능을 선언하면이 업데이트가 비활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="bea3a627ae5a8f7b20a77e60b7a062e9084db269" translate="yes" xml:space="preserve">
          <source>When using the default mode, &lt;code&gt;N&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt; both have a TREESAME parent, so those edges are walked and the others are ignored. The resulting history graph is:</source>
          <target state="translated">기본 모드를 사용하는 경우 &lt;code&gt;N&lt;/code&gt; 과 &lt;code&gt;R&lt;/code&gt; 은 모두 TREESAME 부모를 가지므로 해당 가장자리는 보행되고 나머지는 무시됩니다. 결과 기록 그래프는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9344e268a1ce18a0fd23fc1ab7349b109ba09f95" translate="yes" xml:space="preserve">
          <source>When using the deprecated &lt;code&gt;[section.subsection]&lt;/code&gt; syntax, changing a value will result in adding a multi-line key instead of a change, if the subsection is given with at least one uppercase character. For example when the config looks like</source>
          <target state="translated">더 이상 사용되지 않는 &lt;code&gt;[section.subsection]&lt;/code&gt; 구문을 사용할 때 하위 섹션에 하나 이상의 대문자가 제공되면 값을 변경하면 변경 대신 여러 줄 키가 추가됩니다. 예를 들어 구성이 다음과 같은 경우</target>
        </trans-unit>
        <trans-unit id="d587eeb587978498a5260d6dbb9ec4ed92ae5139" translate="yes" xml:space="preserve">
          <source>When using the git:// transport, you can request to use protocol v2 by sending &quot;version=2&quot; as an extra parameter:</source>
          <target state="translated">git : // 전송을 사용할 때 &quot;version = 2&quot;를 추가 매개 변수로 보내 프로토콜 v2 사용을 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32ff889e17de28054dd0cab540306ba1d148a08f" translate="yes" xml:space="preserve">
          <source>When using the http:// or https:// transport a client makes a &quot;smart&quot; info/refs request as described in &lt;code&gt;http-protocol.txt&lt;/code&gt; and requests that v2 be used by supplying &quot;version=2&quot; in the &lt;code&gt;Git-Protocol&lt;/code&gt; header.</source>
          <target state="translated">http : // 또는 https : // 전송을 사용하는 경우 클라이언트는 &lt;code&gt;http-protocol.txt&lt;/code&gt; 에 설명 된대로 &quot;스마트&quot;정보 / 참조 요청을하고 &lt;code&gt;Git-Protocol&lt;/code&gt; 에 &quot;version = 2&quot;를 제공하여 v2를 사용하도록 요청합니다. 헤더.</target>
        </trans-unit>
        <trans-unit id="1119c741c1d5ff1dc358a8c521dcf54497e7a91a" translate="yes" xml:space="preserve">
          <source>When we discuss merges we&amp;rsquo;ll also see the special name MERGE_HEAD, which refers to the other branch that we&amp;rsquo;re merging in to the current branch.</source>
          <target state="translated">병합에 대해 논의 할 때 특수 분기 이름 MERGE_HEAD도 볼 수 있는데, 이는 현재 분기에 병합중인 다른 분기를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="26b492dec7c9b7098cc4171f2408a6f7f7e92986" translate="yes" xml:space="preserve">
          <source>When we need to be precise, we will use the word &quot;branch&quot; to mean a line of development, and &quot;branch head&quot; (or just &quot;head&quot;) to mean a reference to the most recent commit on a branch. In the example above, the branch head named &quot;A&quot; is a pointer to one particular commit, but we refer to the line of three commits leading up to that point as all being part of &quot;branch A&quot;.</source>
          <target state="translated">우리가 정확해야 할 때, &quot;branch&quot;라는 단어는 개발 라인을 의미하고 &quot;branch head&quot;(또는 &quot;head&quot;)는 지점에서 가장 최근의 커밋에 대한 참조를 의미합니다. 위의 예에서 &quot;A&quot;라는 분기 헤드는 하나의 특정 커밋에 대한 포인터이지만이 지점까지 이어지는 3 개의 커밋 라인은 모두 &quot;브랜치 A&quot;의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="af865a0e18421a331501b917b6b084d9f08c05af" translate="yes" xml:space="preserve">
          <source>When we want to find out what commits in &lt;code&gt;M&lt;/code&gt; are contaminated with the bug introduced by &lt;code&gt;D&lt;/code&gt; and need fixing, however, we might want to view only the subset of &lt;code&gt;D..M&lt;/code&gt; that are actually descendants of &lt;code&gt;D&lt;/code&gt;, i.e. excluding &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;K&lt;/code&gt;. This is exactly what the &lt;code&gt;--ancestry-path&lt;/code&gt; option does. Applied to the &lt;code&gt;D..M&lt;/code&gt; range, it results in:</source>
          <target state="translated">&lt;code&gt;M&lt;/code&gt; 에서 어떤 커밋 이 &lt;code&gt;D&lt;/code&gt; 에 의해 도입 된 버그로 오염되어 있고 수정이 필요한지 알아 내려면 실제로 &lt;code&gt;D&lt;/code&gt; 의 하위 항목 인 &lt;code&gt;D..M&lt;/code&gt; 의 하위 집합 만 보려고 할 수 있습니다 ( 예 : &lt;code&gt;C&lt;/code&gt; 및 &lt;code&gt;K&lt;/code&gt; 제외) . 이것이 바로 &lt;code&gt;--ancestry-path&lt;/code&gt; 옵션의 기능입니다. &lt;code&gt;D..M&lt;/code&gt; 범위에 적용하면 다음과 같은 결과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bd2b751f52f03b9f39eaea429dccc385cd6f8cb7" translate="yes" xml:space="preserve">
          <source>When writing a script that is expected to handle random user-input, it is a good practice to make it explicit which arguments are which by placing disambiguating &lt;code&gt;--&lt;/code&gt; at appropriate places.</source>
          <target state="translated">임의의 사용자 입력을 처리 할 것으로 예상되는 스크립트를 작성할 때, 그것은 좋은 연습이 인수하는 명확하게하는 배치하여있는이 명시 적으로 만드는 것입니다 &lt;code&gt;--&lt;/code&gt; 적절한 장소에서.</target>
        </trans-unit>
        <trans-unit id="ec9cac719dc2571ad31301b21a571a63039a88c5" translate="yes" xml:space="preserve">
          <source>When writing remote-helpers for decentralized version control systems, it is advised to keep a local copy of the repository to interact with, and to let the private namespace refs point to this local repository, while the refs/remotes namespace is used to track the remote repository.</source>
          <target state="translated">분산 버전 제어 시스템에 대한 원격 헬퍼를 작성할 때, 저장소의 로컬 사본이 상호 작용하고 개인 네임 스페이스 참조가이 로컬 저장소를 가리 키도록하는 반면, refs / remotes 네임 스페이스는 원격 저장소.</target>
        </trans-unit>
        <trans-unit id="20c75e316d5f2bc9ee11a82eb08a64c8e94c8af1" translate="yes" xml:space="preserve">
          <source>When writing, the new value is written to the repository local configuration file by default, and options &lt;code&gt;--system&lt;/code&gt;, &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--worktree&lt;/code&gt;, &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; can be used to tell the command to write to that location (you can say &lt;code&gt;--local&lt;/code&gt; but that is the default).</source>
          <target state="translated">쓸 때 기본적으로 새 값이 저장소 로컬 구성 파일에 기록되고 &lt;code&gt;--system&lt;/code&gt; , &lt;code&gt;--global&lt;/code&gt; , &lt;code&gt;--worktree&lt;/code&gt; , &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; 옵션을 사용하여 명령에 해당 위치에 쓰도록 지시 할 수 있습니다 ( &lt;code&gt;--local&lt;/code&gt; 이라고 말할 수 있지만 이것이 기본값입니다).</target>
        </trans-unit>
        <trans-unit id="cd8a515ddc50bbc57c4721fd114c9828b7d7e56b" translate="yes" xml:space="preserve">
          <source>When you are happy with the state of this change, you can merge it into the &quot;test&quot; branch in preparation to make it public:</source>
          <target state="translated">이 변경 상태에 만족하면 변경 사항을 &quot;테스트&quot;분기로 병합하여 공개 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="778f60f4a64466f8d291144e663a70b4838a03f8" translate="yes" xml:space="preserve">
          <source>When you are in the middle of something, you learn that there are upstream changes that are possibly relevant to what you are doing. When your local changes do not conflict with the changes in the upstream, a simple &lt;code&gt;git pull&lt;/code&gt; will let you move forward.</source>
          <target state="translated">당신이 무언가의 중간에있을 때, 당신은 아마도 당신이하고있는 일과 관련이있는 상류 변화가 있음을 알게됩니다. 로컬 변경 사항이 업스트림 변경 사항과 충돌하지 않으면 간단한 &lt;code&gt;git pull&lt;/code&gt; 을 사용하여 앞으로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6b623b307a4c06027202dc5b8021ae4a369fe95" translate="yes" xml:space="preserve">
          <source>When you are in the middle of something, your boss comes in and demands that you fix something immediately. Traditionally, you would make a commit to a temporary branch to store your changes away, and return to your original branch to make the emergency fix, like this:</source>
          <target state="translated">당신이 무언가의 중간에있을 때, 상사가 와서 즉시 무언가를 고치라고 요구합니다. 일반적으로 변경 사항을 저장하기 위해 임시 지점에 커밋하고 원래 지점으로 돌아가서 다음과 같이 응급 수정을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="5dab203d26aab56f5ab1012e5091a813403ff2db" translate="yes" xml:space="preserve">
          <source>When you are interested in finding the origin for lines 40-60 for file &lt;code&gt;foo&lt;/code&gt;, you can use the &lt;code&gt;-L&lt;/code&gt; option like so (they mean the same thing &amp;mdash; both ask for 21 lines starting at line 40):</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 파일에 대해 40-60 행의 원점을 찾는 데 관심 이있는 경우, &lt;code&gt;-L&lt;/code&gt; 옵션을 사용할 수 있습니다 (동일한 것을 의미합니다. 둘 다 40 행에서 시작하는 21 행을 요청합니다).</target>
        </trans-unit>
        <trans-unit id="709f7df580972f427522b82ef732f913e20c2078" translate="yes" xml:space="preserve">
          <source>When you are not interested in changes older than version v2.6.18, or changes older than 3 weeks, you can use revision range specifiers similar to &lt;code&gt;git rev-list&lt;/code&gt;:</source>
          <target state="translated">버전 v2.6.18 이전의 변경 사항 또는 3 주 이전의 변경 사항에 관심이없는 경우 &lt;code&gt;git rev-list&lt;/code&gt; 와 유사한 개정 범위 지정자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da9f31c43174e26846193d472d4442e982c36d7b" translate="yes" xml:space="preserve">
          <source>When you are working in a small closely knit group, it is not unusual to interact with the same repository over and over again. By defining &lt;code&gt;remote&lt;/code&gt; repository shorthand, you can make it easier:</source>
          <target state="translated">작고 밀접한 그룹에서 작업 할 때 동일한 저장소와 반복해서 상호 작용하는 것은 드문 일이 아닙니다. &lt;code&gt;remote&lt;/code&gt; 저장소를 속기 정의 하면 다음과 같이 더 쉬워 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ac50cc4cb199a994adc57ff3704f94a4fe6fd25" translate="yes" xml:space="preserve">
          <source>When you ask &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; to show the conflicts, it runs a three-way diff between the conflicted merge results in the work tree with stages 2 and 3 to show only hunks whose contents come from both sides, mixed (in other words, when a hunk&amp;rsquo;s merge results come only from stage 2, that part is not conflicting and is not shown. Same for stage 3).</source>
          <target state="translated">&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 에게 충돌을 보여 달라고 요청하면 , 2 단계와 3 단계의 작업 트리에서 충돌 된 병합 결과 사이에 3 방향 차이를 실행하여 내용이 양쪽에서 온 덩어리를 표시합니다 (기타) 즉, 덩어리의 병합 결과가 2 단계에서만 나오면 해당 부분은 충돌하지 않으며 표시되지 않습니다 (3 단계와 동일).</target>
        </trans-unit>
        <trans-unit id="23850e192db360b828b88cc125a57c30022897e8" translate="yes" xml:space="preserve">
          <source>When you perform a squash merge, a merge commit isn&amp;rsquo;t created; instead, the changes from one side are applied as a regular commit to the other side. This means that the merge base for these branches won&amp;rsquo;t have changed, and so when Git goes to perform its next merge, it considers all of the changes that it considered the last time plus the new changes. That means any conflicts may need to be re-resolved. Similarly, anything using the &lt;code&gt;...&lt;/code&gt; notation in &lt;code&gt;git
diff&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt;, or a GUI will result in showing all of the changes since the original merge base.</source>
          <target state="translated">스쿼시 병합을 수행 할 때 병합 커밋이 생성되지 않습니다. 대신 한 쪽의 변경 사항이 다른쪽에 일반 커밋으로 적용됩니다. 즉, 이러한 분기의 병합 기반이 변경되지 않았으므로 Git이 다음 병합을 수행 할 때 마지막으로 고려한 모든 변경 사항과 새로운 변경 사항을 고려합니다. 즉, 충돌을 다시 해결해야 할 수도 있습니다. 마찬가지로 &lt;code&gt;git diff&lt;/code&gt; , &lt;code&gt;git log&lt;/code&gt; 또는 GUI 에서 &lt;code&gt;...&lt;/code&gt; 표기법을 사용 하면 원래 병합 기반 이후의 모든 변경 사항이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3f0add0b9e7571c844c4ae8fb98b59f1c64d874a" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;git checkout &amp;lt;something&amp;gt;&lt;/code&gt; or &lt;code&gt;git switch &amp;lt;something&amp;gt;&lt;/code&gt; and only have one remote, it may implicitly fall back on checking out and tracking e.g. &lt;code&gt;origin/&amp;lt;something&amp;gt;&lt;/code&gt;. This stops working as soon as you have more than one remote with a &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; reference. This setting allows for setting the name of a preferred remote that should always win when it comes to disambiguation. The typical use-case is to set this to &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">당신이 실행하면 &lt;code&gt;git checkout &amp;lt;something&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;git switch &amp;lt;something&amp;gt;&lt;/code&gt; 만 원격 하나를 가지고, 그것은 암시 적으로 체크 아웃하고 예를 들어 추적에 다시 떨어질 수 &lt;code&gt;origin/&amp;lt;something&amp;gt;&lt;/code&gt; . &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; 참조 가있는 리모콘이 둘 이상있는 즉시 작동이 중지됩니다 . 이 설정을 통해 선호하는 리모컨의 이름을 명확하게 지정할 수 있습니다. 일반적인 사용 사례는 이것을 &lt;code&gt;origin&lt;/code&gt; 으로 설정하는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="9f93e702904ad75a7ffcc41597ebc2474895e0b0" translate="yes" xml:space="preserve">
          <source>When you start a 3-way merge with an index file that is already populated, it is assumed that it represents the state of the files in your work tree, and you can even have files with changes unrecorded in the index file. It is further assumed that this state is &quot;derived&quot; from the stage 2 tree. The 3-way merge refuses to run if it finds an entry in the original index file that does not match stage 2.</source>
          <target state="translated">이미 채워진 인덱스 파일과의 3 방향 병합을 시작하면 작업 트리에있는 파일의 상태를 나타내며 인덱스 파일에 변경 내용이 기록되지 않은 파일도있을 수 있습니다. 또한이 상태는 2 단계 트리에서 &quot;유도&quot;된 것으로 가정합니다. 3 단계 병합은 원래 인덱스 파일에서 2 단계와 일치하지 않는 항목을 찾으면 실행을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="6831d00e1f830a484b6c5799e343f596bbc55899" translate="yes" xml:space="preserve">
          <source>When you want to just integrate with the work leading to the commit that happens to be tagged, e.g. synchronizing with an upstream release point, you may not want to make an unnecessary merge commit.</source>
          <target state="translated">업스트림 릴리스 포인트와 동기화하는 등 태그가 붙은 커밋을 일으키는 작업과 통합하려는 경우 불필요한 병합 커밋을 원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f28e5d62e5a87453e903e81e941382b8ac566c1" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready, just run</source>
          <target state="translated">준비가되면 그냥 달려</target>
        </trans-unit>
        <trans-unit id="4aa6b6296b8d97b342099d335ec15bc55634ad41" translate="yes" xml:space="preserve">
          <source>When your topic branch is long-lived, however, your topic branch would end up having many such &quot;Merge from master&quot; commits on it, which would unnecessarily clutter the development history. Readers of the Linux kernel mailing list may remember that Linus complained about such too frequent test merges when a subsystem maintainer asked to pull from a branch full of &quot;useless merges&quot;.</source>
          <target state="translated">그러나 토픽 브랜치가 오래 지속되면 토픽 브랜치에 &quot;마스터에서 병합&quot;커밋이 많이 발생하여 개발 히스토리가 불필요하게 복잡해집니다. 리눅스 커널 메일 링리스트를 읽는 사람들은 서브 시스템 관리자가 &quot;무용 한 병합&quot;으로 가득 찬 지점에서 가져 오기를 요청했을 때 Linus가 너무 빈번한 테스트 병합에 대해 불평했다는 것을 기억할 것입니다.</target>
        </trans-unit>
        <trans-unit id="bd4128428344ae6c28977b2bc5cf00953da1175f" translate="yes" xml:space="preserve">
          <source>When your topic branch modifies an overlapping area that your master branch (or upstream) touched since your topic branch forked from it, you may want to test it with the latest master, even before your topic branch is ready to be pushed upstream:</source>
          <target state="translated">주제 분기가 분기 된 이후 주제 분기 (또는 업스트림)가 터치 한 겹치는 영역을 주제 분기에서 수정하는 경우 주제 분기를 업스트림으로 푸시 할 준비가되기 전에도 최신 마스터로 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f4eaf255ffc69df0530167a4810c74e9370cd43" translate="yes" xml:space="preserve">
          <source>Whenever possible, section headings should clearly describe the task they explain how to do, in language that requires no more knowledge than necessary: for example, &quot;importing patches into a project&quot; rather than &quot;the &lt;code&gt;git am&lt;/code&gt; command&quot;</source>
          <target state="translated">가능할 때마다 섹션 제목에는 필요한 것 이상의 지식이 필요없는 언어로 수행하는 작업을 명확하게 설명해야합니다 (예 : &quot; &lt;code&gt;git am&lt;/code&gt; 명령&quot; 이 아닌 &quot;프로젝트로 패치 가져 오기 &quot;).</target>
        </trans-unit>
        <trans-unit id="11683716a14fb2e59c3ad4d48a607606706a0329" translate="yes" xml:space="preserve">
          <source>Where &quot;oldsha1&quot; is the 40 character hexadecimal value previously stored in &amp;lt;ref&amp;gt;, &quot;newsha1&quot; is the 40 character hexadecimal value of &amp;lt;newvalue&amp;gt; and &quot;committer&quot; is the committer&amp;rsquo;s name, email address and date in the standard Git committer ident format.</source>
          <target state="translated">&quot;oldsha1&quot;은 이전에 &amp;lt;ref&amp;gt;에 저장된 40 자의 16 진수 값이고, &quot;newsha1&quot;은 &amp;lt;newvalue&amp;gt;의 40 자의 16 진수 값이고 &quot;committer&quot;는 표준 Git 커미터 ID 형식의 커미터 이름, 이메일 주소 및 날짜입니다. .</target>
        </trans-unit>
        <trans-unit id="9a6682bd90b10ed7b65387d46ac6e3098ba208ce" translate="yes" xml:space="preserve">
          <source>Where all fields are as described above and &quot;message&quot; is the value supplied to the -m option.</source>
          <target state="translated">모든 필드는 위에서 설명한대로 &quot;message&quot;는 -m 옵션에 제공된 값입니다.</target>
        </trans-unit>
        <trans-unit id="1047cdb3a9504c1e49ba180691c6de133fb29736" translate="yes" xml:space="preserve">
          <source>Where to create the Git repository. If not provided, the last component in the p4 depot path is used to create a new directory.</source>
          <target state="translated">Git 리포지토리를 생성 할 위치 제공되지 않은 경우 p4 저장소 경로의 마지막 구성 요소가 새 디렉토리를 작성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="de8afe671960d7a395defa2e40a80901d96e2485" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;--batch-check='%(objectname) %(objecttype)'&lt;/code&gt; would produce:</source>
          <target state="translated">반면 &lt;code&gt;--batch-check='%(objectname) %(objecttype)'&lt;/code&gt; 은 다음을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="92669e9b8b127c2ba15691914d72dae97b880d0d" translate="yes" xml:space="preserve">
          <source>Whether Git detects directory renames, affecting what happens at merge time to new files added to a directory on one side of history when that directory was renamed on the other side of history. If merge.directoryRenames is set to &quot;false&quot;, directory rename detection is disabled, meaning that such new files will be left behind in the old directory. If set to &quot;true&quot;, directory rename detection is enabled, meaning that such new files will be moved into the new directory. If set to &quot;conflict&quot;, a conflict will be reported for such paths. If merge.renames is false, merge.directoryRenames is ignored and treated as false. Defaults to &quot;conflict&quot;.</source>
          <target state="translated">Git이 디렉토리 이름 바꾸기를 감지하는지 여부는 해당 디렉토리가 히스토리의 다른 쪽에서 이름이 바뀔 때 히스토리 한쪽의 디렉토리에 추가 된 새 파일에 병합시 발생하는 영향에 영향을줍니다. merge.directoryRenames가 &quot;false&quot;로 설정되면 디렉토리 이름 바꾸기 감지가 사용 불가능하게되어 새 파일이 이전 디렉토리에 남게됩니다. &quot;true&quot;로 설정하면 디렉토리 이름 바꾸기 감지가 사용됩니다. 이는 새 파일이 새 디렉토리로 이동 함을 의미합니다. &quot;충돌&quot;로 설정하면 해당 경로에 대한 충돌이보고됩니다. merge.renames가 false이면 merge.directoryRenames가 무시되고 false로 처리됩니다. 기본값은 &quot;충돌&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="6720b94e3bf2c12c61b3c14de0415d18239394a0" translate="yes" xml:space="preserve">
          <source>Whether Git detects renames. If set to &quot;false&quot;, rename detection is disabled. If set to &quot;true&quot;, basic rename detection is enabled. Defaults to the value of diff.renames.</source>
          <target state="translated">Git이 이름 변경을 감지하는지 여부 &quot;false&quot;로 설정하면 이름 바꾸기 감지가 비활성화됩니다. &quot;true&quot;로 설정하면 기본 이름 변경 감지가 사용됩니다. 기본값은 diff.renames입니다.</target>
        </trans-unit>
        <trans-unit id="d1f68ec7a1f81e21d54ab2e76eaccedf11117ff8" translate="yes" xml:space="preserve">
          <source>Whether and how Git detects renames in &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; . If set to &quot;false&quot;, rename detection is disabled. If set to &quot;true&quot;, basic rename detection is enabled. If set to &quot;copies&quot; or &quot;copy&quot;, Git will detect copies, as well. Defaults to the value of diff.renames.</source>
          <target state="translated">Git이 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 및 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 에서 이름 변경을 감지하는지 여부와 방법 . &quot;false&quot;로 설정하면 이름 바꾸기 감지가 비활성화됩니다. &quot;true&quot;로 설정하면 기본 이름 변경 감지가 사용됩니다. &quot;복사본&quot;또는 &quot;복사본&quot;으로 설정되면 Git은 사본도 감지합니다. 기본값은 diff.renames입니다.</target>
        </trans-unit>
        <trans-unit id="cd914284b278d491020fec9d972b776a56df2f14" translate="yes" xml:space="preserve">
          <source>Whether and how Git detects renames. If set to &quot;false&quot;, rename detection is disabled. If set to &quot;true&quot;, basic rename detection is enabled. If set to &quot;copies&quot; or &quot;copy&quot;, Git will detect copies, as well. Defaults to true. Note that this affects only &lt;code&gt;git diff&lt;/code&gt; Porcelain like &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; and &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, and not lower level commands such as &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt;.</source>
          <target state="translated">Git이 이름 변경을 감지하는지 여부와 방법. &quot;false&quot;로 설정하면 이름 바꾸기 감지가 비활성화됩니다. &quot;true&quot;로 설정하면 기본 이름 변경 감지가 사용됩니다. &quot;복사본&quot;또는 &quot;복사본&quot;으로 설정되면 Git은 사본도 감지합니다. 기본값은 true입니다. 이는 &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 및 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 과 같은 &lt;code&gt;git diff&lt;/code&gt; Porcelain 에만 영향을 미치며 &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1]&lt;/a&gt; 와 같은 하위 수준 명령에는 영향을주지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2329b3f81f31d1e7aac7efc37e396ae5ccc9b5fe" translate="yes" xml:space="preserve">
          <source>Whether git should follow HTTP redirects. If set to &lt;code&gt;true&lt;/code&gt;, git will transparently follow any redirect issued by a server it encounters. If set to &lt;code&gt;false&lt;/code&gt;, git will treat all redirects as errors. If set to &lt;code&gt;initial&lt;/code&gt;, git will follow redirects only for the initial request to a remote, but not for subsequent follow-up HTTP requests. Since git uses the redirected URL as the base for the follow-up requests, this is generally sufficient. The default is &lt;code&gt;initial&lt;/code&gt;.</source>
          <target state="translated">git이 HTTP 리디렉션을 따라야하는지 여부입니다. &lt;code&gt;true&lt;/code&gt; 로 설정하면 git은 서버에서 발생한 모든 리디렉션을 투명하게 따릅니다. &lt;code&gt;false&lt;/code&gt; 로 설정하면 git은 모든 리디렉션을 오류로 처리합니다. &lt;code&gt;initial&lt;/code&gt; 으로 설정하면 git은 초기 요청에 대해서만 원격으로 리디렉션하지만 후속 후속 HTTP 요청에는 리디렉션하지 않습니다. git은 후속 요청의 기반으로 리디렉션 된 URL을 사용하기 때문에 일반적으로 충분합니다. 기본값은 &lt;code&gt;initial&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cd0092aedf4252969afafd8803ba8faf98999493" translate="yes" xml:space="preserve">
          <source>Whether that update is allowed without &lt;code&gt;--force&lt;/code&gt; depends on the ref namespace it&amp;rsquo;s being fetched to, the type of object being fetched, and whether the update is considered to be a fast-forward. Generally, the same rules apply for fetching as when pushing, see the &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; section of &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; for what those are. Exceptions to those rules particular to &lt;code&gt;git fetch&lt;/code&gt; are noted below.</source>
          <target state="translated">&lt;code&gt;--force&lt;/code&gt; 없이 업데이트를 허용할지 여부 는 가져 오는 ref 네임 스페이스, 가져 오는 객체의 유형 및 업데이트가 빠른 것으로 간주되는지 여부에 따라 다릅니다. 일반적으로, 푸시 할 때와 같은 규칙이 페치에 적용됩니다. &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 의 &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; 섹션을 참조하십시오 . &lt;code&gt;git fetch&lt;/code&gt; 와 관련된 규칙에 대한 예외 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c31395d6226db0f96527cf13d7284a32596aaef" translate="yes" xml:space="preserve">
          <source>Whether the CVS server interface is enabled for this repository. See &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;.</source>
          <target state="translated">이 저장소에 CVS 서버 인터페이스가 사용 가능한지 여부 &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e99c94b5e67663cef6460c2b09cda34348e975de" translate="yes" xml:space="preserve">
          <source>Whether to enable the grouping of projects by category on the project list page. The category of a project is determined by the &lt;code&gt;$GIT_DIR/category&lt;/code&gt; file or the &lt;code&gt;gitweb.category&lt;/code&gt; variable in each repository&amp;rsquo;s configuration. Disabled by default (set to 0).</source>
          <target state="translated">프로젝트 목록 페이지에서 카테고리별로 프로젝트를 그룹화 할 수 있는지 여부 프로젝트 &lt;code&gt;$GIT_DIR/category&lt;/code&gt; 는 각 저장소 구성 의 $ &lt;code&gt;gitweb.category&lt;/code&gt; / category 파일 또는 gitweb.category 변수에 의해 결정됩니다 . 기본적으로 비활성화되어 있습니다 (0으로 설정).</target>
        </trans-unit>
        <trans-unit id="be60442dc9a2bb750c3ffb3e91f602fa8cf454b7" translate="yes" xml:space="preserve">
          <source>Whether to print the diffstat between ORIG_HEAD and the merge result at the end of the merge. True by default.</source>
          <target state="translated">ORIG_HEAD와 병합 종료시 병합 결과 사이의 diffstat를 인쇄할지 여부. 기본적으로 true입니다.</target>
        </trans-unit>
        <trans-unit id="e6d010b4fa5fb27d92c64dc2f59319c4e77b544c" translate="yes" xml:space="preserve">
          <source>Whether to show a diffstat of what changed upstream since the last rebase. False by default.</source>
          <target state="translated">마지막 리베이스 이후 업스트림에서 변경된 내용의 차이를 표시할지 여부입니다. 기본적으로 False입니다.</target>
        </trans-unit>
        <trans-unit id="2153c59644d7df4b2ed210d8ef453074b1a6c2ac" translate="yes" xml:space="preserve">
          <source>Whether to skip reading settings from the system-wide $(prefix)/etc/gitconfig file. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details.</source>
          <target state="translated">시스템 전체 $ (prefix) / etc / gitconfig 파일에서 설정 읽기를 건너 뛸지 여부입니다. 자세한 내용은 &lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7c8173d7da296bd9c5f5aef35e3d739c8852bc79" translate="yes" xml:space="preserve">
          <source>Whether to skip reading settings from the system-wide &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; file. This environment variable can be used along with &lt;code&gt;$HOME&lt;/code&gt; and &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; to create a predictable environment for a picky script, or you can set it temporarily to avoid using a buggy &lt;code&gt;/etc/gitconfig&lt;/code&gt; file while waiting for someone with sufficient permissions to fix it.</source>
          <target state="translated">시스템 전체 &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; 파일 에서 설정 읽기를 건너 뛸지 여부 입니다. 이 환경 변수를 &lt;code&gt;$HOME&lt;/code&gt; 및 &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; 과 함께 사용 하여 까다로운 스크립트를위한 예측 가능한 환경을 만들거나 버그가있는 &lt;code&gt;/etc/gitconfig&lt;/code&gt; 파일을 사용하지 않고 임시로 설정 하여 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="488ddc0ec5d5c663a8e8059a323ed70db5316b78" translate="yes" xml:space="preserve">
          <source>Whether to use ANSI escape sequences to add color to patches. If this is set to &lt;code&gt;always&lt;/code&gt;, &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;, &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, and &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; will use color for all patches. If it is set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, those commands will only use color when output is to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">패치에 색상을 추가하기 위해 ANSI 이스케이프 시퀀스를 사용할지 여부입니다. 이로 설정하면 &lt;code&gt;always&lt;/code&gt; , &lt;a href=&quot;git-diff&quot;&gt;자식-DIFF는 [1]&lt;/a&gt; , &lt;a href=&quot;git-log&quot;&gt;자식 로그 [1]&lt;/a&gt; , 그리고 &lt;a href=&quot;git-show&quot;&gt;자식 쇼 [1]&lt;/a&gt; 모든 패치의 색상을 사용합니다. &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;auto&lt;/code&gt; 로 설정 되면 해당 명령은 출력이 터미널로 출력 될 때만 색상을 사용합니다. 설정하지 않으면 &lt;code&gt;color.ui&lt;/code&gt; 의 값 이 사용됩니다 ( 기본적으로 &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="21386b2036d855c8d8dd6eb4c84085329fcf2561" translate="yes" xml:space="preserve">
          <source>Whether to use empty blobs as rename source.</source>
          <target state="translated">빈 BLOB을 이름 바꾸기 소스로 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="63ea1a80cc99dbbdec2d362a1b57aa7468c9ed6d" translate="yes" xml:space="preserve">
          <source>Whether to verify the SSL certificate when fetching or pushing over HTTPS. Defaults to true. Can be overridden by the &lt;code&gt;GIT_SSL_NO_VERIFY&lt;/code&gt; environment variable.</source>
          <target state="translated">HTTPS를 가져 오거나 푸시 할 때 SSL 인증서를 확인할지 여부입니다. 기본값은 true입니다. &lt;code&gt;GIT_SSL_NO_VERIFY&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec9fdb5354be84561f27023760593b27a86cd126" translate="yes" xml:space="preserve">
          <source>Which file to place a pattern in depends on how the pattern is meant to be used.</source>
          <target state="translated">패턴을 배치 할 파일은 패턴의 사용 방법에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9342c5a7ca74e113fca6826c098da1e9dea46c59" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose by default when resolving notes conflicts. Must be one of &lt;code&gt;manual&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt;, &lt;code&gt;theirs&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or &lt;code&gt;cat_sort_uniq&lt;/code&gt;. Defaults to &lt;code&gt;manual&lt;/code&gt;. See &quot;NOTES MERGE STRATEGIES&quot; section above for more information on each strategy.</source>
          <target state="translated">메모 충돌을 해결할 때 기본적으로 선택할 병합 전략 중 하나 여야합니다 &lt;code&gt;manual&lt;/code&gt; , &lt;code&gt;ours&lt;/code&gt; , &lt;code&gt;theirs&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; , 또는 &lt;code&gt;cat_sort_uniq&lt;/code&gt; . 기본값은 &lt;code&gt;manual&lt;/code&gt; 입니다. 각 전략에 대한 자세한 내용은 위의 &quot;NOTES MERGE STRATEGIES&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7dd75dabb694bc7182031b6cdb5c605283f3ff3a" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose by default when resolving notes conflicts. Must be one of &lt;code&gt;manual&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt;, &lt;code&gt;theirs&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or &lt;code&gt;cat_sort_uniq&lt;/code&gt;. Defaults to &lt;code&gt;manual&lt;/code&gt;. See &quot;NOTES MERGE STRATEGIES&quot; section of &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt; for more information on each strategy.</source>
          <target state="translated">메모 충돌을 해결할 때 기본적으로 선택할 병합 전략 중 하나 여야합니다 &lt;code&gt;manual&lt;/code&gt; , &lt;code&gt;ours&lt;/code&gt; , &lt;code&gt;theirs&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; , 또는 &lt;code&gt;cat_sort_uniq&lt;/code&gt; . 기본값은 &lt;code&gt;manual&lt;/code&gt; 입니다. 각 전략에 대한 자세한 내용 은 &lt;a href=&quot;git-notes&quot;&gt;git-notes [1]&lt;/a&gt; 의 &quot;NOTES MERGE 전략&quot;섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9bd73c0d97037644e549ed3fed8d2491f5cfc8e0" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose when doing a notes merge into refs/notes/&amp;lt;name&amp;gt;. This overrides the more general &quot;notes.mergeStrategy&quot;. See the &quot;NOTES MERGE STRATEGIES&quot; section above for more information on each available strategy.</source>
          <target state="translated">노트를 수행 할 때 선택할 병합 전략은 refs / notes / &amp;lt;name&amp;gt;에 병합됩니다. 이것은 더 일반적인 &quot;notes.mergeStrategy&quot;를 대체합니다. 사용 가능한 각 전략에 대한 자세한 내용은 위의 &quot;NOTES MERGE STRATEGIES&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f202b61699020bcfa082fe897d7a8560aea486a1" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose when doing a notes merge into refs/notes/&amp;lt;name&amp;gt;. This overrides the more general &quot;notes.mergeStrategy&quot;. See the &quot;NOTES MERGE STRATEGIES&quot; section in &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt; for more information on the available strategies.</source>
          <target state="translated">노트를 수행 할 때 선택할 병합 전략은 refs / notes / &amp;lt;name&amp;gt;에 병합됩니다. 이것은 더 일반적인 &quot;notes.mergeStrategy&quot;를 대체합니다. 사용 가능한 전략에 대한 자세한 내용 은 &lt;a href=&quot;git-notes&quot;&gt;git-notes [1]&lt;/a&gt; 의 &quot;NOTES MERGE STRATEGIES&quot;섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="556a322f94dd1e45943ded0ebea9906e93ca0c80" translate="yes" xml:space="preserve">
          <source>Which ref (or refs, if a glob or specified more than once), in addition to the default set by &lt;code&gt;core.notesRef&lt;/code&gt; or &lt;code&gt;GIT_NOTES_REF&lt;/code&gt;, to read notes from when showing commit messages with the &lt;code&gt;git log&lt;/code&gt; family of commands. This setting can be overridden on the command line or by the &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; environment variable. See &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;core.notesRef&lt;/code&gt; 또는 &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; 에 의해 설정된 기본값 외에 &lt;code&gt;git log&lt;/code&gt; 계열 명령으로 커밋 메시지를 표시 할 때 메모를 읽을 수있는 참조 (또는 glob 또는 두 번 이상 지정된 경우 참조) 이 설정은 명령 행 또는 &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 . &lt;a href=&quot;git-log&quot;&gt;git-log [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="08e8ee8d98ea130471cc368fbf1a571f3d29a34d" translate="yes" xml:space="preserve">
          <source>Which ref to manipulate notes from, instead of &lt;code&gt;refs/notes/commits&lt;/code&gt;. This overrides the &lt;code&gt;core.notesRef&lt;/code&gt; setting.</source>
          <target state="translated">어떤에서 대신 메모를 조작하는 심판 &lt;code&gt;refs/notes/commits&lt;/code&gt; . 이것은 &lt;code&gt;core.notesRef&lt;/code&gt; 설정을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="180171a89f79828ca3aedfa4194b8ff07f802f3f" translate="yes" xml:space="preserve">
          <source>Which refs, in addition to the default set by &lt;code&gt;core.notesRef&lt;/code&gt; or &lt;code&gt;GIT_NOTES_REF&lt;/code&gt;, to read notes from when showing commit messages with the &lt;code&gt;log&lt;/code&gt; family of commands. See &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;core.notesRef&lt;/code&gt; 또는 &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; 에 의해 설정된 기본값 외에 &lt;code&gt;log&lt;/code&gt; 명령 군에 커밋 메시지를 표시 할 때 메모를 읽는 참조 &lt;a href=&quot;git-notes&quot;&gt;git-notes [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4dbbdac6096ee85d080e618f1dfec3eb7804653" translate="yes" xml:space="preserve">
          <source>Which will add the following to a file named &lt;code&gt;.gitconfig&lt;/code&gt; in your home directory:</source>
          <target state="translated">홈 디렉토리의 &lt;code&gt;.gitconfig&lt;/code&gt; 파일에 다음을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="0b383fc769f1bfb4acb136b5be3ea84e9742db33" translate="yes" xml:space="preserve">
          <source>Which would result in:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5efe59371f7c539c77a16fb753d65287a4a1a881" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; is usually used to specify what files are in, you can also specify what files are &lt;code&gt;not&lt;/code&gt; in, using negate patterns. For example, to remove the file &lt;code&gt;unwanted&lt;/code&gt;:</source>
          <target state="translated">하지만 &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; 보통 파일에 무엇을 지정하는 데 사용됩니다, 당신은 또한 파일이 무엇인지를 지정할 수 &lt;code&gt;not&lt;/code&gt; 부정 패턴을 사용하여,에. 예를 들어, 파일을 제거하려면 &lt;code&gt;unwanted&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="133c634c89411bc7bbb73a5aa8f4cda72b5442c2" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; is usually used to specify what files are included, you can also specify what files are &lt;code&gt;not&lt;/code&gt; included, using negative patterns. For example, to remove the file &lt;code&gt;unwanted&lt;/code&gt;:</source>
          <target state="translated">하지만 &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; 일반적으로 파일이 포함되어있는 것을 지정하는 데 사용됩니다, 당신은 또한 파일이 무엇인지를 지정할 수 &lt;code&gt;not&lt;/code&gt; 부정적인 패턴을 사용하여, 포함되어 있습니다. 예를 들어, 파일을 제거하려면 &lt;code&gt;unwanted&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="118bfe73a3b1ef14dd8bb7fedadb7cb55f01bcfb" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;&lt;/code&gt; was about specifying a single commit parent, these three notations also consider its parents. For example you can say &lt;code&gt;HEAD^2^@&lt;/code&gt;, however you cannot say &lt;code&gt;HEAD^@^2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;&lt;/code&gt; 은 단일 커밋 부모를 지정하는 것이 었지만 이 세 가지 표기법은 부모를 고려합니다. 예를 들어 &lt;code&gt;HEAD^2^@&lt;/code&gt; 말할 수 있지만 &lt;code&gt;HEAD^@^2&lt;/code&gt; 말할 수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="eaec58c53324781fb42b4e63ea8a9cb23361a1d5" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git archimport&lt;/code&gt; will try to create sensible branch names for the archives that it imports, it is also possible to specify Git branch names manually. To do so, write a Git branch name after each &amp;lt;archive/branch&amp;gt; parameter, separated by a colon. This way, you can shorten the Arch branch names and convert Arch jargon to Git jargon, for example mapping a &quot;PROJECT--devo--VERSION&quot; branch to &quot;master&quot;.</source>
          <target state="translated">&lt;code&gt;git archimport&lt;/code&gt; 는 가져 오는 아카이브에 대해 적절한 브랜치 이름을 만들려고 하지만 Git 브랜치 이름을 수동으로 지정할 수도 있습니다. 이렇게하려면 각 &amp;lt;archive / branch&amp;gt; 매개 변수 뒤에 콜론으로 구분하여 Git 분기 이름을 작성합니다. 이렇게하면 아치 브랜치 이름을 줄이고 아치 용어를 Git 용어로 변환 할 수 있습니다. 예를 들어 &quot;PROJECT--devo--VERSION&quot;브랜치를 &quot;master&quot;로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="92e92ccd1a34f0875d32051d1b819b76c11daddf" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git archimport&lt;/code&gt; will try to create sensible branch names for the archives that it imports, it is also possible to specify Git branch names manually. To do so, write a Git branch name after each &amp;lt;archive/branch&amp;gt; parameter, separated by a colon. This way, you can shorten the Arch branch names and convert Arch jargon to Git jargon, for example mapping a &quot;PROJECT{litdd}devo{litdd}VERSION&quot; branch to &quot;master&quot;.</source>
          <target state="translated">&lt;code&gt;git archimport&lt;/code&gt; 는 가져 오는 아카이브에 대해 합리적인 지점 이름을 만들려고 시도 하지만 Git 지점 이름을 수동으로 지정할 수도 있습니다. 이렇게하려면 각 &amp;lt;archive / branch&amp;gt; 매개 변수 뒤에 콜론으로 구분하여 Git 브랜치 이름을 작성하십시오. 이런 식으로 아치 분기 이름을 줄이고 아치 전문 용어를 Git 전문 용어로 변환 할 수 있습니다 (예 : &quot;PROJECT {litdd} devo {litdd} VERSION&quot;분기를 &quot;master&quot;에 매핑).</target>
        </trans-unit>
        <trans-unit id="becb5324e2c3fe06edf2ea3e91b298d56c7ab4c0" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git log -G&quot;frotz\(nitfol&quot;&lt;/code&gt; will show this commit, &lt;code&gt;git log
-S&quot;frotz\(nitfol&quot; --pickaxe-regex&lt;/code&gt; will not (because the number of occurrences of that string did not change).</source>
          <target state="translated">하지만 &lt;code&gt;git log -G&quot;frotz\(nitfol&quot;&lt;/code&gt; 이 커밋 표시됩니다, &lt;code&gt;git log -S&quot;frotz\(nitfol&quot; --pickaxe-regex&lt;/code&gt; 하지 않습니다 (해당 문자열의 발생 수) 변경하지 않은 때문이다.</target>
        </trans-unit>
        <trans-unit id="6e3c7753b36510ea58174f6c4603b4398587f401" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git log -G&quot;regexec\(regexp&quot;&lt;/code&gt; will show this commit, &lt;code&gt;git log
-S&quot;regexec\(regexp&quot; --pickaxe-regex&lt;/code&gt; will not (because the number of occurrences of that string did not change).</source>
          <target state="translated">하지만 &lt;code&gt;git log -G&quot;regexec\(regexp&quot;&lt;/code&gt; 이 커밋 표시됩니다 &lt;code&gt;git log -S&quot;regexec\(regexp&quot; --pickaxe-regex&lt;/code&gt; 하지 않습니다 (해당 문자열의 발생 수) 변경하지 않은 때문이다.</target>
        </trans-unit>
        <trans-unit id="9fa3ab181478a04a41a15d625153bef4e8a57c74" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git svn&lt;/code&gt; can track copy history (including branches and tags) for repositories adopting a standard layout, it cannot yet represent merge history that happened inside git back upstream to SVN users. Therefore it is advised that users keep history as linear as possible inside Git to ease compatibility with SVN (see the CAVEATS section below).</source>
          <target state="translated">&lt;code&gt;git svn&lt;/code&gt; 은 표준 레이아웃을 채택한 리포지토리에 대한 복사 기록 (분기 및 태그 포함)을 추적 할 수 있지만 SVN 사용자에게 git backstream에서 발생한 병합 기록을 아직 나타낼 수는 없습니다. 따라서 사용자는 SVN과의 호환성을 쉽게하기 위해 Git 내에서 가능한 한 히스토리를 선형으로 유지하는 것이 좋습니다 (아래의 CAVEATS 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="a541171ff58e87a1f0dd9a2efc98b39d30771db4" translate="yes" xml:space="preserve">
          <source>While Git can store and handle any file of any type, there are some settings that work better than others. In general, we recommend that text files be stored in UTF-8 without a byte-order mark (BOM) with LF (Unix-style) endings. We also recommend the use of UTF-8 (again, without BOM) in commit messages. These are the settings that work best across platforms and with tools such as &lt;code&gt;git diff&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">Git은 모든 유형의 파일을 저장하고 처리 할 수 ​​있지만 다른 것보다 더 잘 작동하는 설정이 있습니다. 일반적으로 텍스트 파일은 LF (Unix 스타일)로 끝나는 바이트 순서 표시 (BOM)없이 UTF-8로 저장하는 것이 좋습니다. 또한 커밋 메시지에서 UTF-8 (BOM없이) 사용을 권장합니다. 이는 &lt;code&gt;git diff&lt;/code&gt; 및 &lt;code&gt;git merge&lt;/code&gt; 와 같은 도구를 사용하여 여러 플랫폼에서 가장 잘 작동하는 설정입니다 .</target>
        </trans-unit>
        <trans-unit id="6dffb65164b8303d8f69a39b7acb7d5c91ede142" translate="yes" xml:space="preserve">
          <source>While Git normally leaves file contents alone, it can be configured to normalize line endings to LF in the repository and, optionally, to convert them to CRLF when files are checked out.</source>
          <target state="translated">Git은 일반적으로 파일 내용 만 남겨두고 저장소에서 줄 끝을 LF로 정규화하고 선택적으로 파일을 체크 아웃 할 때 CRLF로 변환하도록 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28e5e3e789710acfbe64ae88514ac76e33edddf4" translate="yes" xml:space="preserve">
          <source>While a tree represents a particular directory state of a working directory, a commit represents that state in &quot;time&quot;, and explains how to get there.</source>
          <target state="translated">트리는 작업중인 디렉토리의 특정 디렉토리 상태를 나타내는 반면, 커밋은 해당 시간을 &quot;시간&quot;으로 나타내며 도달하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4340adfab1f511dfd0a9b398534e55b63d70f9b2" translate="yes" xml:space="preserve">
          <source>While an &quot;easy case recovery&quot; sometimes appears to be successful even in the hard case, it may have unintended consequences. For example, a commit that was removed via &lt;code&gt;git rebase
      --interactive&lt;/code&gt; will be &lt;strong&gt;resurrected&lt;/strong&gt;!</source>
          <target state="translated">어려운 경우에도 &quot;쉬운 사례 복구&quot;가 성공한 것처럼 보이지만 의도하지 않은 결과가 발생할 수 있습니다. 예를 들어, 커밋 그 제거를 통해 &lt;code&gt;git rebase --interactive&lt;/code&gt; 됩니다 &lt;strong&gt;부활&lt;/strong&gt; !</target>
        </trans-unit>
        <trans-unit id="aeca28e54d758d00b7b9efe81e9021c3ae168604" translate="yes" xml:space="preserve">
          <source>While at it, check the &lt;code&gt;info&lt;/code&gt; and &lt;code&gt;final-commit&lt;/code&gt; files as well. If what is in &lt;code&gt;final-commit&lt;/code&gt; is not exactly what you would want to see in the commit log message, it is very likely that the receiver would end up hand editing the log message when applying your patch. Things like &quot;Hi, this is my first patch.\n&quot; in the patch e-mail should come after the three-dash line that signals the end of the commit message.</source>
          <target state="translated">&lt;code&gt;info&lt;/code&gt; 와 &lt;code&gt;final-commit&lt;/code&gt; 파일도 확인하십시오 . 무엇 경우 &lt;code&gt;final-commit&lt;/code&gt; 당신이 커밋 로그 메시지의, 매우 가능성이 수신기가 당신의 패치를 적용 할 때 로그 메시지를 편집하는 손을 끝낼 것입니다보고 싶은 것이 무엇인지 정확히하지 않습니다. 패치 전자 우편의 &quot;안녕하세요. \ n&quot;과 같은 것은 커밋 메시지의 끝을 알리는 3 개의 대시 줄 다음에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="8ae695a4eabf8fe5dbbd3e5b96e3d4b6e1234599" translate="yes" xml:space="preserve">
          <source>While creating changes is useful, it&amp;rsquo;s even more useful if you can tell later what changed. The most useful command for this is another of the &lt;code&gt;diff&lt;/code&gt; family, namely &lt;code&gt;git diff-tree&lt;/code&gt;.</source>
          <target state="translated">변경 사항을 작성하는 것이 유용하지만 나중에 변경된 내용을 알려줄 수 있으면 더욱 유용합니다. 이것에 가장 유용한 명령은 다른 &lt;code&gt;diff&lt;/code&gt; 패밀리, 즉 &lt;code&gt;git diff-tree&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e66bf2723385d320e1625ad06ac948bff457808d" translate="yes" xml:space="preserve">
          <source>While it is possible to override all attributes, well behaving helpers should refrain from doing so for any attribute other than username and password.</source>
          <target state="translated">모든 속성을 재정의 할 수 있지만, 잘 작동하는 도우미는 사용자 이름과 비밀번호 이외의 속성에 대해 그렇게하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="84a06403fddbfbdfed756ddcbe7e1b6ff85edd7a" translate="yes" xml:space="preserve">
          <source>While one could just alter the configuration settings in the gitweb CGI itself, those changes would be lost upon upgrade. Configuration settings might also be placed into a file in the same directory as the CGI script with the default name &lt;code&gt;gitweb_config.perl&lt;/code&gt; &amp;mdash; allowing one to have multiple gitweb instances with different configurations by the use of symlinks.</source>
          <target state="translated">gitweb CGI 자체의 구성 설정을 변경할 수는 있지만 업그레이드하면 변경 사항이 손실됩니다. 구성 설정은 기본 이름이 &lt;code&gt;gitweb_config.perl&lt;/code&gt; 인 CGI 스크립트와 동일한 디렉토리에있는 파일에 배치 될 수도 있습니다 . 심볼릭 링크를 사용하여 구성이 다른 여러 gitweb 인스턴스를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3129dc27b36b536bbc925e644f78f32bde86376a" translate="yes" xml:space="preserve">
          <source>While parent object ids are provided on the command line, author and committer information is taken from the following environment variables, if set:</source>
          <target state="translated">명령 행에 상위 오브젝트 ID가 제공되지만 작성자 및 커미터 정보는 설정된 경우 다음 환경 변수에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7921bb694427f6298ff631684ef33f9b3436be57" translate="yes" xml:space="preserve">
          <source>While you are in the middle of working on something complicated, you find an unrelated but obvious and trivial bug. You would like to fix it before continuing. You can use &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; to save the current state of your work, and after fixing the bug (or, optionally after doing so on a different branch and then coming back), unstash the work-in-progress changes.</source>
          <target state="translated">복잡한 작업을하는 동안 관련이 없지만 명백하고 사소한 버그가 있습니다. 계속하기 전에 문제를 해결하고 싶습니다. 당신이 사용할 수있는 &lt;a href=&quot;git-stash&quot;&gt;자식-숨긴 [1]&lt;/a&gt; 워크에서 진행중인 변화를 unstash, 그리고 (다시하거나, 선택적으로 다른 지점에 이렇게 후 다음 예정) 버그를 해결 한 후 작업의 현재 상태를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="aa47dd8a2f0ebe83c1c9e1c5b54451eb489a4bd1" translate="yes" xml:space="preserve">
          <source>Whitespace separated fields; any run of whitespace can be used as field separator (rules for Perl&amp;rsquo;s &quot;&lt;code&gt;split(&quot; &quot;, $line)&lt;/code&gt;&quot;).</source>
          <target state="translated">공백으로 구분 된 필드; 모든 공백은 필드 분리 자로 사용할 수 있습니다 (Perl의 &quot; &lt;code&gt;split(&quot; &quot;, $line)&lt;/code&gt; &quot;에 대한 규칙 ).</target>
        </trans-unit>
        <trans-unit id="863aeb0371f511e273bc66c19d53b7877f38ac8a" translate="yes" xml:space="preserve">
          <source>Whitespace-separated list of allowed SMTP-AUTH mechanisms. This setting forces using only the listed mechanisms. Example:</source>
          <target state="translated">허용 된 SMTP-AUTH 메커니즘의 공백으로 구분 된 목록입니다. 이 설정은 나열된 메커니즘 만 사용합니다. 예:</target>
        </trans-unit>
        <trans-unit id="389ff74463b52646838e41646e64e38a902b85eb" translate="yes" xml:space="preserve">
          <source>Why bisecting merge commits can be harder than bisecting linear history</source>
          <target state="translated">이분법 병합 커밋이 이력 선형 기록보다 더 어려운 이유</target>
        </trans-unit>
        <trans-unit id="d83d7d2d8de91edadaae0bc956ce69ac2202b5c1" translate="yes" xml:space="preserve">
          <source>Why do I have a file that&amp;rsquo;s always modified?</source>
          <target state="translated">항상 수정되는 파일이있는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="4ae988a6589a0546387522087a0861a61e3e4225" translate="yes" xml:space="preserve">
          <source>Wildcards in the pattern such as &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; are treated as literal characters.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;?&lt;/code&gt; 와 같은 패턴의 와일드 카드 리터럴 문자로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="af4b569cb0fc1bae5a933e3532b964dc5d61facd" translate="yes" xml:space="preserve">
          <source>Will copy all files listed from the index to the working directory (not overwriting existing files).</source>
          <target state="translated">색인에서 나열된 모든 파일을 작업 디렉토리로 복사합니다 (기존 파일을 덮어 쓰지 않음).</target>
        </trans-unit>
        <trans-unit id="712e5286413fd90307ff92f23e110885525f2bb8" translate="yes" xml:space="preserve">
          <source>Will fail unless you manually run &lt;code&gt;git fetch origin-push&lt;/code&gt;. This method is of course entirely defeated by something that runs &lt;code&gt;git fetch
--all&lt;/code&gt;, in that case you&amp;rsquo;d need to either disable it or do something more tedious like:</source>
          <target state="translated">&lt;code&gt;git fetch origin-push&lt;/code&gt; 를 수동으로 실행하지 않으면 실패합니다 . 이 메소드는 물론 &lt;code&gt;git fetch --all&lt;/code&gt; 을 실행하는 것에 의해 완전히 패배합니다 .이 경우 메소드 를 비활성화하거나 더 지루한 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="bfd8a0b8d0916903c6596ed358a3cc07670d304e" translate="yes" xml:space="preserve">
          <source>Windows-only: allow redirecting the standard input/output/error handles to paths specified by the environment variables. This is particularly useful in multi-threaded applications where the canonical way to pass standard handles via &lt;code&gt;CreateProcess()&lt;/code&gt; is not an option because it would require the handles to be marked inheritable (and consequently &lt;strong&gt;every&lt;/strong&gt; spawned process would inherit them, possibly blocking regular Git operations). The primary intended use case is to use named pipes for communication (e.g. &lt;code&gt;\\.\pipe\my-git-stdin-123&lt;/code&gt;).</source>
          <target state="translated">Windows 전용 : 표준 입력 / 출력 / 오류 핸들을 환경 변수로 지정된 경로로 경로 재 지정할 수 있습니다. 이것은 &lt;code&gt;CreateProcess()&lt;/code&gt; 를 통해 표준 핸들을 전달하는 표준 방법 이 핸들이 상속 가능한 것으로 표시되어야하기 때문에 옵션이 아닌 멀티 스레드 응용 프로그램에서 특히 유용합니다. 결과적으로 생성 된 &lt;strong&gt;모든&lt;/strong&gt; 프로세스가이를 상속하여 정기적 인 Git 작업을 차단할 수 있습니다. ). 기본 사용 사례는 통신에 명명 된 파이프를 사용하는 것입니다 (예 : &lt;code&gt;\\.\pipe\my-git-stdin-123&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9c510c80ca0db551792868481dfce7936d126272" translate="yes" xml:space="preserve">
          <source>Windows-only: comma-separated list of environment variables' names that need to be unset before spawning any other process. Defaults to &lt;code&gt;PERL5LIB&lt;/code&gt; to account for the fact that Git for Windows insists on using its own Perl interpreter.</source>
          <target state="translated">Windows 전용 : 다른 프로세스를 생성하기 전에 설정을 해제해야하는 쉼표로 구분 된 환경 변수 이름 목록입니다. Git for Windows가 자체 Perl 인터프리터를 사용해야한다는 사실을 설명하기 위해 기본값은 &lt;code&gt;PERL5LIB&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e74f053e0d02cafdbd0bbd14c65f9fd314f00d13" translate="yes" xml:space="preserve">
          <source>Windows-only: override whether spawned processes inherit only standard file handles (&lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt;) or all handles. Can be &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Defaults to &lt;code&gt;auto&lt;/code&gt;, which means &lt;code&gt;true&lt;/code&gt; on Windows 7 and later, and &lt;code&gt;false&lt;/code&gt; on older Windows versions.</source>
          <target state="translated">Windows 전용 : 생성 된 프로세스가 표준 파일 핸들 ( &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; 및 &lt;code&gt;stderr&lt;/code&gt; ) 만 상속하는지 아니면 모든 핸들을 상속하는지 여부를 대체하십시오 . &lt;code&gt;auto&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 일 수 있습니다 . 기본값은 &lt;code&gt;auto&lt;/code&gt; 이며, 이는 Windows 7 이상에서는 &lt;code&gt;false&lt;/code&gt; 를, 이전 Windows 버전에서는 false 를 의미 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="949442d2f0c16b026f680dbb7df65e881242333c" translate="yes" xml:space="preserve">
          <source>With --abbrev set to 0, the command can be used to find the closest tagname without any suffix:</source>
          <target state="translated">--abbrev를 0으로 설정하면이 명령을 사용하여 접미사없이 가장 가까운 태그 이름을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a158e0380ec8b734a269ad9d0f52eb5eb98f2274" translate="yes" xml:space="preserve">
          <source>With --all, the command can use branch heads as references, so the output shows the reference path as well:</source>
          <target state="translated">--all을 사용하면 명령에서 분기 헤드를 참조로 사용할 수 있으므로 출력에 참조 경로도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="65ee9a1948ccba3bbf4e1e0783ded1eb1bf032c9" translate="yes" xml:space="preserve">
          <source>With --batch or --batch-check, follow symlinks inside the repository when requesting objects with extended SHA-1 expressions of the form tree-ish:path-in-tree. Instead of providing output about the link itself, provide output about the linked-to object. If a symlink points outside the tree-ish (e.g. a link to /foo or a root-level link to ../foo), the portion of the link which is outside the tree will be printed.</source>
          <target state="translated">--batch 또는 --batch-check를 사용하면 tree-ish : path-in-tree 형식의 확장 된 SHA-1식이있는 객체를 요청할 때 저장소 내부의 심볼릭 링크를 따릅니다. 링크 자체에 대한 출력을 제공하는 대신 링크 된 오브젝트에 대한 출력을 제공하십시오. 심볼릭 링크가 트리 -ish 외부를 가리키는 경우 (예 : / foo에 대한 링크 또는 ../foo에 대한 루트 수준 링크) 트리 외부에있는 링크 부분이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="4f48f3dcfb8092537ede5a515e981d6e213aeb9f" translate="yes" xml:space="preserve">
          <source>With --no-commit perform the merge and stop just before creating a merge commit, to give the user a chance to inspect and further tweak the merge result before committing.</source>
          <target state="translated">--no-commit을 사용하면 병합 커밋을 만들기 직전에 병합을 수행하고 중지하여 사용자가 커밋하기 전에 병합 결과를 검사하고 추가로 조정할 수있는 기회를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3e8c9cc261afe4f0a3a9c88b1d66c9688df929d7" translate="yes" xml:space="preserve">
          <source>With --no-log do not list one-line descriptions from the actual commits being merged.</source>
          <target state="translated">--no-log를 사용하면 병합되는 실제 커밋의 한 줄 설명을 나열하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1adfa5cefd427bf7d3a2a21965629dcaf3c3388" translate="yes" xml:space="preserve">
          <source>With --no-signoff do not add a Signed-off-by line.</source>
          <target state="translated">--no-signoff를 사용하면 Signed-off-by 행을 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="268060b1be32cd8bc70e7e3bb40c821b809c90c3" translate="yes" xml:space="preserve">
          <source>With --no-squash perform the merge and commit the result. This option can be used to override --squash.</source>
          <target state="translated">--no-squash를 사용하면 병합을 수행하고 결과를 커밋합니다. 이 옵션은 --squash를 재정의하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2060c61f3742702f58530c81f5eefb302aeb60c1" translate="yes" xml:space="preserve">
          <source>With --squash, --commit is not allowed, and will fail.</source>
          <target state="translated">--squash를 사용하면 --commit이 허용되지 않으며 실패합니다.</target>
        </trans-unit>
        <trans-unit id="865b225dd999d9769e36118a7e13e933131732f5" translate="yes" xml:space="preserve">
          <source>With -n or --no-stat do not show a diffstat at the end of the merge.</source>
          <target state="translated">-n 또는 --no-stat를 사용하면 병합 끝에 diffstat가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="008f5911b332311009571603d4810039f3b0a542" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--add&lt;/code&gt;, instead of changing existing URLs, new URL is added.</source>
          <target state="translated">&lt;code&gt;--add&lt;/code&gt; 를 사용 하면 기존 URL을 변경하는 대신 새 URL이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6b50c366c66c543504b13b437403fc08b0e99b0f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--add&lt;/code&gt;, instead of replacing the list of currently tracked branches, adds to that list.</source>
          <target state="translated">&lt;code&gt;--add&lt;/code&gt; 를 사용 하면 현재 추적 된 분기 목록을 바꾸지 않고 해당 목록에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b5c6ad97197083d8f93283087955bd70bd89f95f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--all&lt;/code&gt; flag, all refs that exist locally are transferred to the remote side. You cannot specify any &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; if you use this flag.</source>
          <target state="translated">&lt;code&gt;--all&lt;/code&gt; 플래그를 사용하면 로컬로 존재하는 모든 참조가 원격으로 전송됩니다. 이 플래그를 사용하면 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 를 지정할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="487cd0ed38992f1c8c21d61869ab0ba8c9131e91" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--all&lt;/code&gt;, all URLs for the remote will be listed.</source>
          <target state="translated">로 &lt;code&gt;--all&lt;/code&gt; , 원격에 대한 모든 URL이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ea729f224a85b66147f6e662a1c5d14a2abdd751" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--contains&lt;/code&gt;, shows only the branches that contain the named commit (in other words, the branches whose tip commits are descendants of the named commit), &lt;code&gt;--no-contains&lt;/code&gt; inverts it. With &lt;code&gt;--merged&lt;/code&gt;, only branches merged into the named commit (i.e. the branches whose tip commits are reachable from the named commit) will be listed. With &lt;code&gt;--no-merged&lt;/code&gt; only branches not merged into the named commit will be listed. If the &amp;lt;commit&amp;gt; argument is missing it defaults to &lt;code&gt;HEAD&lt;/code&gt; (i.e. the tip of the current branch).</source>
          <target state="translated">&lt;code&gt;--contains&lt;/code&gt; 를 사용하면 명명 된 커밋을 포함하는 분기 (즉, 팁 커밋이 명명 된 커밋의 하위 항목 인 분기 ) 만 표시합니다. &lt;code&gt;--no-contains&lt;/code&gt; 는 반전합니다. 로 &lt;code&gt;--merged&lt;/code&gt; 만 가지라는 커밋에 병합 (즉, 그 끝 커밋 커밋의 이름에서 연결할 수있는 지점)가 표시됩니다. 로 &lt;code&gt;--no-merged&lt;/code&gt; 라는 이름이 나열됩니다 커밋으로 통합뿐만 아니라 지점. &amp;lt;commit&amp;gt; 인수가 없으면 기본값은 &lt;code&gt;HEAD&lt;/code&gt; (즉, 현재 분기의 끝)입니다.</target>
        </trans-unit>
        <trans-unit id="a1afc8d7fd506e98e5a974a8f26c84b23238fb92" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--create-reflog&lt;/code&gt;, update-ref will create a reflog for each ref even if one would not ordinarily be created.</source>
          <target state="translated">&lt;code&gt;--create-reflog&lt;/code&gt; 를 사용하면 update-ref는 일반적으로 작성되지 않더라도 각 참조에 대한 참조를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="7fef88021ca55186dc4070339cc8624e9a30485c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--delete&lt;/code&gt;, instead of changing existing URLs, all URLs matching regex &amp;lt;url&amp;gt; are deleted for remote &amp;lt;name&amp;gt;. Trying to delete all non-push URLs is an error.</source>
          <target state="translated">&lt;code&gt;--delete&lt;/code&gt; 를 사용 하면 기존 URL을 변경하는 대신 원격 &amp;lt;name&amp;gt;에 대해 정규식 &amp;lt;url&amp;gt;과 일치하는 모든 URL이 삭제됩니다. 푸시가 아닌 URL을 모두 삭제하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="30918cb51e4372be35c787127ec3b8958bb72e8d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--dry-run&lt;/code&gt; option, report what branches will be pruned, but do not actually prune them.</source>
          <target state="translated">&lt;code&gt;--dry-run&lt;/code&gt; 옵션을 사용하면 잘라낼 가지를보고하지만 실제로 제거하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4cd9a1b8d31ddff1298b3b28b732552e240fb7a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--dry-run&lt;/code&gt; option, report what branches would be pruned, but do not actually prune them.</source>
          <target state="translated">와 &lt;code&gt;--dry-run&lt;/code&gt; 옵션, 가지 정리 될 수 있지만, 실제로 그들을 제거하지 않는 것을 보고서.</target>
        </trans-unit>
        <trans-unit id="5189cda6779864f8bd2f5726b39c4529ff52ddf8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--ff-only&lt;/code&gt;, resolve the merge as a fast-forward when possible. When not possible, refuse to merge and exit with a non-zero status.</source>
          <target state="translated">&lt;code&gt;--ff-only&lt;/code&gt; 를 사용 하면 가능하면 빨리 병합으로 병합을 해결하십시오. 가능하지 않은 경우 0이 아닌 상태로 병합 및 종료를 거부하십시오.</target>
        </trans-unit>
        <trans-unit id="7e8f4fddd68a3a89ff49906c538a7ca7b5ef9dea" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--ff&lt;/code&gt;, when possible resolve the merge as a fast-forward (only update the branch pointer to match the merged branch; do not create a merge commit). When not possible (when the merged-in history is not a descendant of the current history), create a merge commit.</source>
          <target state="translated">와 &lt;code&gt;--ff&lt;/code&gt; , 가능하면 해결과 병합 빨리 감기 (만 병합 된 지점과 일치하는 지점 포인터를 업데이트, 병합 커밋을 작성하지 않습니다). 가능하지 않은 경우 (병합 된 내역이 현재 내역의 후손이 아닌 경우) 병합 커밋을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1362a77896d8f49d16b2f9c5015389cf3c365072" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--force&lt;/code&gt;, the fast-forward check is disabled for all refs.</source>
          <target state="translated">함께 &lt;code&gt;--force&lt;/code&gt; , 빨리 감기 검사는 모든 심판을 위해 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ba76b155ec3c447a87cfd160419204d256e0f486" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--keep-cr&lt;/code&gt;, call &lt;code&gt;git mailsplit&lt;/code&gt; (see &lt;a href=&quot;git-mailsplit&quot;&gt;git-mailsplit[1]&lt;/a&gt;) with the same option, to prevent it from stripping CR at the end of lines. &lt;code&gt;am.keepcr&lt;/code&gt; configuration variable can be used to specify the default behaviour. &lt;code&gt;--no-keep-cr&lt;/code&gt; is useful to override &lt;code&gt;am.keepcr&lt;/code&gt;.</source>
          <target state="translated">함께 &lt;code&gt;--keep-cr&lt;/code&gt; 호출 &lt;code&gt;git mailsplit&lt;/code&gt; (참조 &lt;a href=&quot;git-mailsplit&quot;&gt;자식-mailsplit을 [1]&lt;/a&gt; 라인의 끝에 CR 박리되는 것을 방지하기 위해, 동일한 옵션). &lt;code&gt;am.keepcr&lt;/code&gt; 구성 변수를 사용하여 기본 동작을 지정할 수 있습니다. &lt;code&gt;--no-keep-cr&lt;/code&gt; 은 &lt;code&gt;am.keepcr&lt;/code&gt; 을 재정의하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="22e7d426b38d094430582cb84fc0432b42834058" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--no-ff&lt;/code&gt;, create a merge commit in all cases, even when the merge could instead be resolved as a fast-forward.</source>
          <target state="translated">로 &lt;code&gt;--no-ff&lt;/code&gt; , 병합 대신 빨리 감기로 해결 될 수있는 경우에도, 병합이 모든 경우에 커밋 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5aa5b8e96804090cb89f3aab6cdc283e2c00d87e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--no-tags&lt;/code&gt; option, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; does not import tags from the remote repository.</source>
          <target state="translated">로 &lt;code&gt;--no-tags&lt;/code&gt; 옵션, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; 원격 저장소에서 수행하지 가져 태그를.</target>
        </trans-unit>
        <trans-unit id="37eed19521c790d78f1c0615d39722d6298a6cc8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--patch&lt;/code&gt;, you can interactively select hunks from the diff between HEAD and the working tree to be stashed. The stash entry is constructed such that its index state is the same as the index state of your repository, and its worktree contains only the changes you selected interactively. The selected changes are then rolled back from your worktree. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">로 &lt;code&gt;--patch&lt;/code&gt; , 대화 형 HEAD와 작업 트리의 DIFF에서 심술쟁이를 선택하는 은닉한다. 숨김 항목은 색인 상태가 저장소의 색인 상태와 동일하도록 구성되며 작업 트리에는 대화식으로 선택한 변경 사항 만 포함됩니다. 선택한 변경 사항이 작업 트리에서 롤백됩니다. &lt;code&gt;--patch&lt;/code&gt; 모드 작동 방법을 알아 보려면 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 의 &quot;대화식 모드&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d4d7e74d0f493c9b38977e43daed9cfd8d04693" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--pretty&lt;/code&gt; format other than &lt;code&gt;oneline&lt;/code&gt; and &lt;code&gt;reference&lt;/code&gt; (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog. The reflog designator in the output may be shown as &lt;code&gt;ref@{Nth}&lt;/code&gt; (where &lt;code&gt;Nth&lt;/code&gt; is the reverse-chronological index in the reflog) or as &lt;code&gt;ref@{timestamp}&lt;/code&gt; (with the timestamp for that entry), depending on a few rules:</source>
          <target state="translated">&lt;code&gt;oneline&lt;/code&gt; 및 &lt;code&gt;reference&lt;/code&gt; 이외의 &lt;code&gt;--pretty&lt;/code&gt; 형식을 사용하면 (명백한 이유로) 출력에 reflog에서 가져온 두 개의 추가 정보 줄이 생깁니다. 출력의 reflog 지정 자는 몇 가지 규칙에 따라 &lt;code&gt;ref@{Nth}&lt;/code&gt; (여기서 &lt;code&gt;Nth&lt;/code&gt; 는 reflog의 역 시간 색인) 또는 &lt;code&gt;ref@{timestamp}&lt;/code&gt; (해당 항목의 타임 스탬프 포함)로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35b7bcaa0d1a12c16e7ebe5749afd0aa0913b69d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--prune&lt;/code&gt; option, run pruning against all the remotes that are updated.</source>
          <target state="translated">&lt;code&gt;--prune&lt;/code&gt; 옵션을 사용하면 업데이트 된 모든 원격 장치에 대해 제거를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="9a993d0e8bfe45705897018a009a33a68fb547fb" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--push&lt;/code&gt;, push URLs are manipulated instead of fetch URLs.</source>
          <target state="translated">&lt;code&gt;--push&lt;/code&gt; 를 사용하면 URL 가져 오기 대신 푸시 URL이 조작됩니다.</target>
        </trans-unit>
        <trans-unit id="d0c8d67cd6d67334176bbc781201963c60a05697" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--push&lt;/code&gt;, push URLs are queried rather than fetch URLs.</source>
          <target state="translated">&lt;code&gt;--push&lt;/code&gt; 를 사용하면 URL을 가져 오는 대신 푸시 URL을 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="a26943d9e66efe8045d055005cf22b61dc280b47" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--stdin&lt;/code&gt;, update-ref reads instructions from standard input and performs all modifications together. Specify commands of the form:</source>
          <target state="translated">&lt;code&gt;--stdin&lt;/code&gt; 을 사용하면 update-ref는 표준 입력에서 명령어를 읽고 모든 수정을 함께 수행합니다. 다음 형식의 명령을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="46644e8c0f7ae9adba68ae4958242044a646f477" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--tags&lt;/code&gt; option, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; imports every tag from the remote repository.</source>
          <target state="translated">&lt;code&gt;--tags&lt;/code&gt; 옵션을 사용하면 &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; 은 원격 저장소에서 모든 태그를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9afd8cc2d67d37867f3891e80c5ed22f0441334c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--topo-order&lt;/code&gt;, they would show 8 6 5 3 7 4 2 1 (or 8 7 4 2 6 5 3 1); some older commits are shown before newer ones in order to avoid showing the commits from two parallel development track mixed together.</source>
          <target state="translated">&lt;code&gt;--topo-order&lt;/code&gt; 를 사용하면 8 6 5 3 7 4 2 1 (또는 8 7 4 2 6 5 3 1)을 표시합니다. 두 개의 병렬 개발 트랙의 커밋이 함께 혼합되어 표시되지 않도록하기 위해 일부 이전 커밋이 최신 커밋보다 먼저 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bbe3bdb143c872f8bc3522bea317a2ad84af9235" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;--auto&lt;/code&gt;, the remote is queried to determine its &lt;code&gt;HEAD&lt;/code&gt;, then the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is set to the same branch. e.g., if the remote &lt;code&gt;HEAD&lt;/code&gt; is pointed at &lt;code&gt;next&lt;/code&gt;, &quot;&lt;code&gt;git remote set-head origin -a&lt;/code&gt;&quot; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/next&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="translated">함께 &lt;code&gt;-a&lt;/code&gt; 또는 &lt;code&gt;--auto&lt;/code&gt; 원격는 그 결정하도록 쿼리 &lt;code&gt;HEAD&lt;/code&gt; 후 기호-REF &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 동일한 지점으로 설정된다. 예를 들어, 원격 &lt;code&gt;HEAD&lt;/code&gt; 가 &lt;code&gt;next&lt;/code&gt; 에 지시 되면 &quot; &lt;code&gt;git remote set-head origin -a&lt;/code&gt; &quot;는 &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; -ref refs / remotes / origin / HEAD 를 &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; 로 설정 합니다. &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; 이미 존재하는 경우에만 작동 합니다. 그렇지 않은 경우 먼저 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="ca79465e71cd43be9bc8a1c0daf2d4aececc9880" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;--auto&lt;/code&gt;, the remote is queried to determine its &lt;code&gt;HEAD&lt;/code&gt;, then the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is set to the same branch. e.g., if the remote &lt;code&gt;HEAD&lt;/code&gt; is pointed at &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;git remote set-head origin -a&lt;/code&gt; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/next&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="translated">함께 &lt;code&gt;-a&lt;/code&gt; 또는 &lt;code&gt;--auto&lt;/code&gt; 원격는 그 결정하도록 쿼리 &lt;code&gt;HEAD&lt;/code&gt; 후 기호-REF &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 동일한 지점으로 설정된다. 예를 들어 원격 &lt;code&gt;HEAD&lt;/code&gt; 가 &lt;code&gt;next&lt;/code&gt; 를 가리키는 경우 &lt;code&gt;git remote set-head origin -a&lt;/code&gt; 는 symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; 를 &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; 로 설정 합니다. 이것은 &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; 가 이미 존재하는 경우에만 작동 합니다. 그렇지 않은 경우 먼저 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="5f69d8ea721996a0e954b69bd77400aaa01f9c55" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-d&lt;/code&gt; flag, it deletes the named &amp;lt;ref&amp;gt; after verifying it still contains &amp;lt;oldvalue&amp;gt;.</source>
          <target state="translated">&lt;code&gt;-d&lt;/code&gt; 플래그를 사용하면 &amp;lt;oldvalue&amp;gt;가 여전히 포함되어 있는지 확인한 후 명명 된 &amp;lt;ref&amp;gt;를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="da9e1b9da40421df76a154165f2b54d479838ea5" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-d&lt;/code&gt; or &lt;code&gt;--delete&lt;/code&gt;, the symbolic ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is deleted.</source>
          <target state="translated">함께 &lt;code&gt;-d&lt;/code&gt; 또는 &lt;code&gt;--delete&lt;/code&gt; , 상징적 심판이 &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="6b0b5064fe468e227911615a2b7fcbafb431eef7" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-f&lt;/code&gt; option, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; is run immediately after the remote information is set up.</source>
          <target state="translated">&lt;code&gt;-f&lt;/code&gt; 옵션을 사용하면 &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; 은 원격 정보가 설정된 직후에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4c11581a6169e0a17084bd502989c1df6d5ff9b6" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-m &amp;lt;master&amp;gt;&lt;/code&gt; option, a symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is set up to point at remote&amp;rsquo;s &lt;code&gt;&amp;lt;master&amp;gt;&lt;/code&gt; branch. See also the set-head command.</source>
          <target state="translated">함께 &lt;code&gt;-m &amp;lt;master&amp;gt;&lt;/code&gt; 옵션 상징적-REF &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 원격의에서 지점으로 설정되어 &lt;code&gt;&amp;lt;master&amp;gt;&lt;/code&gt; 지점입니다. set-head 명령도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="734f06f2f4ad450ab9efcf1cd7537f18bb0a22f5" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-n&lt;/code&gt; option, the remote heads are not queried first with &lt;code&gt;git ls-remote &amp;lt;name&amp;gt;&lt;/code&gt;; cached information is used instead.</source>
          <target state="translated">&lt;code&gt;-n&lt;/code&gt; 옵션을 사용하면 &lt;code&gt;git ls-remote &amp;lt;name&amp;gt;&lt;/code&gt; 으로 원격 헤드를 먼저 쿼리하지 않습니다 . 대신 캐시 된 정보가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dd75e538fb39d452e807a34068040583ee9147bc" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; option, instead of the default glob refspec for the remote to track all branches under the &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/&lt;/code&gt; namespace, a refspec to track only &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is created. You can give more than one &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; to track multiple branches without grabbing all branches.</source>
          <target state="translated">함께 &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; 옵션 대신 아래에있는 모든 지점 추적 할 수있는 원격의 기본 글로브의 refspec의 &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/&lt;/code&gt; 네임 스페이스하는 refspec 만 추적하는 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 가 만들어집니다. 모든 분기를 잡지 않고 여러 분기를 추적하기 위해 둘 이상의 &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; 를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a17d1e0c132aee2d2be1ec1ea02b9a88fab2a36" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, a new trailer will be added, even if some trailers with the same (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair are already in the message.</source>
          <target state="translated">함께 &lt;code&gt;add&lt;/code&gt; 새로운 예고편 같은 일부 트레일러 (&amp;lt;토큰&amp;gt;, &amp;lt;값&amp;gt;) 쌍들이 이미 메시지의 경우에도 추가된다.</target>
        </trans-unit>
        <trans-unit id="bdb99f7baa9796a7b973194e1a5ab4a7e3d82b92" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, a new trailer will be added.</source>
          <target state="translated">로 &lt;code&gt;add&lt;/code&gt; , 새로운 트레일러가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3d04d4d1926f980c37f6ca9761913ed7f096d165" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, create a new branch named &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; starting at &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, and check out &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; into the new working tree. If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is omitted, it defaults to &lt;code&gt;HEAD&lt;/code&gt;. By default, &lt;code&gt;-b&lt;/code&gt; refuses to create a new branch if it already exists. &lt;code&gt;-B&lt;/code&gt; overrides this safeguard, resetting &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">로 &lt;code&gt;add&lt;/code&gt; 라는 새로운 지점 생성 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 에서 시작하는 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; , 체크 아웃 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 새로운 작업 트리에. 경우 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 가 기본값 생략 &lt;code&gt;HEAD&lt;/code&gt; 를 . 기본적으로 &lt;code&gt;-b&lt;/code&gt; 는 이미 존재하는 경우 새 분기 작성을 거부합니다. &lt;code&gt;-B&lt;/code&gt; 는이 보호 장치를 무시하고 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 를 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 로 재설정 합니다.</target>
        </trans-unit>
        <trans-unit id="6b61b0983644b0774834807009f4d278bb642b5a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, create a new branch named &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; starting at &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, and check out &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; into the new working tree. If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is omitted, it defaults to HEAD. By default, &lt;code&gt;-b&lt;/code&gt; refuses to create a new branch if it already exists. &lt;code&gt;-B&lt;/code&gt; overrides this safeguard, resetting &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">로 &lt;code&gt;add&lt;/code&gt; 라는 새로운 지점 생성 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 에서 시작하는 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; , 체크 아웃 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 새로운 작업 트리에. 경우 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; HEAD가 기본값을 생략하기로한다. 기본적으로 &lt;code&gt;-b&lt;/code&gt; 는 이미 존재하는 경우 새 분기 작성을 거부합니다. &lt;code&gt;-B&lt;/code&gt; 는이 보호 기능을 무시하고 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 를 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 로 재설정 합니다.</target>
        </trans-unit>
        <trans-unit id="d424a0ce9af1bab4df82ba9ed9c152743e40b774" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, detach &lt;code&gt;HEAD&lt;/code&gt; in the new working tree. See &quot;DETACHED HEAD&quot; in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;add&lt;/code&gt; 를 사용 하여 새 작업 트리에서 &lt;code&gt;HEAD&lt;/code&gt; 를 분리 합니다. &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]의&lt;/a&gt; &quot;DETACHED HEAD&quot;를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a273ddd960841784db1a589aad98c4feff6c226" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, detach HEAD in the new working tree. See &quot;DETACHED HEAD&quot; in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;add&lt;/code&gt; 를 사용 하여 새 작업 트리에서 HEAD를 분리하십시오. &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]의&lt;/a&gt; &quot;DETACHED HEAD&quot;를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="187a01bfec37522a00b693f68238b703a4e0897c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, suppress feedback messages.</source>
          <target state="translated">&lt;code&gt;add&lt;/code&gt; 를 사용하면 피드백 메시지가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45995ca3706219a58e816f38cd1d9bf0922ce8ca" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;addIfDifferent&lt;/code&gt;, a new trailer will be added only if no trailer with the same (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair is already in the message.</source>
          <target state="translated">함께 &lt;code&gt;addIfDifferent&lt;/code&gt; 새로운 트레일러와 같은 더 트레일러 (&amp;lt;토큰&amp;gt;, &amp;lt;값&amp;gt;) 쌍 메시지 이미없는 경우에만 추가된다.</target>
        </trans-unit>
        <trans-unit id="6e3bd24c09b16e87e69f4ad565a18cc8f733f593" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt;, a new trailer will be added only if no trailer with the same (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair is above or below the line where the new trailer will be added.</source>
          <target state="translated">함께 &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; 새로운 트레일러와 같은 더 트레일러 (&amp;lt;토큰&amp;gt;, &amp;lt;값&amp;gt;) 쌍 새로운 트레일러가 추가 될 라인 위 또는 아래에없는 경우에만 추가된다.</target>
        </trans-unit>
        <trans-unit id="c538516bcb20191b3fc9da51228fff3eefb68cdf" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;doNothing&lt;/code&gt;, nothing will be done.</source>
          <target state="translated">&lt;code&gt;doNothing&lt;/code&gt; 을 사용하면 아무 것도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="91898a3512235050c32c7a99a50c8394d7a8397d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;doNothing&lt;/code&gt;, nothing will be done; that is no new trailer will be added if there is already one with the same &amp;lt;token&amp;gt; in the message.</source>
          <target state="translated">&lt;code&gt;doNothing&lt;/code&gt; 을 사용하면 아무 것도 수행되지 않습니다. 메시지에 &amp;lt;토큰&amp;gt;이 같은 트레일러가 이미 있으면 새 트레일러가 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fafece11b5178185f0dda98fe61f1218eca3ec1e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; (or variants thereof, e.g. with &lt;code&gt;--cover-letter&lt;/code&gt; or using &lt;code&gt;Z..C&lt;/code&gt; instead of &lt;code&gt;-3 C&lt;/code&gt; to specify the range), the base tree information block is shown at the end of the first message the command outputs (either the first patch, or the cover letter), like this:</source>
          <target state="translated">와 &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; (또는 그 변형 예와 &lt;code&gt;--cover-letter&lt;/code&gt; 또는 사용 &lt;code&gt;Z..C&lt;/code&gt; 대신 &lt;code&gt;-3 C&lt;/code&gt; 를 범위 지정),베이스 트리 정보 블록에 나타낸다 다음과 같이 명령이 출력하는 첫 번째 메시지의 끝 (첫 번째 패치 또는 자기 소개서) :</target>
        </trans-unit>
        <trans-unit id="0dbfc249aea522f6a40d4b8be190d1fc0f0eadd8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;list&lt;/code&gt;, output in an easy-to-parse format for scripts. This format will remain stable across Git versions and regardless of user configuration. See below for details.</source>
          <target state="translated">&lt;code&gt;list&lt;/code&gt; 를 사용하면 파싱하기 쉬운 스크립트 형식으로 출력됩니다. 이 형식은 사용자 구성에 관계없이 Git 버전에서 안정적으로 유지됩니다. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="021957faebf0fa8a6ba6fb4276abb6b8c72afba9" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;lock&lt;/code&gt;, an explanation why the working tree is locked.</source>
          <target state="translated">&lt;code&gt;lock&lt;/code&gt; 을 사용 하면 작업 트리가 잠긴 이유를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bbe63cab2529b193584b4f7d1c86ee0207fc9968" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, do not remove anything; just report what it would remove.</source>
          <target state="translated">&lt;code&gt;prune&lt;/code&gt; 사용하면 아무것도 제거하지 마십시오. 제거 할 내용 만보고하면됩니다.</target>
        </trans-unit>
        <trans-unit id="97f5cdb302d7f0a46689004724feb3d1aca29383" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, only expire unused working trees older than &amp;lt;time&amp;gt;.</source>
          <target state="translated">&lt;code&gt;prune&lt;/code&gt; 을 사용하면 &amp;lt;time&amp;gt;보다 오래된 미사용 작업 트리 만 만료됩니다.</target>
        </trans-unit>
        <trans-unit id="fe3d9726d2a7e550ec17d9d6b1b3e9e51367506e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, only expire unused working trees older than &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;prune&lt;/code&gt; 을 사용하면 &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; 보다 오래된 사용되지 않은 작업 트리 만 만료됩니다 .</target>
        </trans-unit>
        <trans-unit id="92ffa86e9306849b846038bae2a07ad322d0f86c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, report all removals.</source>
          <target state="translated">&lt;code&gt;prune&lt;/code&gt; 을 사용하여 모든 제거를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="f6631b122f785beeb20cb0ef884a421b144138ae" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;replace&lt;/code&gt;, an existing trailer with the same &amp;lt;token&amp;gt; will be deleted and the new trailer will be added. The deleted trailer will be the closest one (with the same &amp;lt;token&amp;gt;) to the place where the new one will be added.</source>
          <target state="translated">&lt;code&gt;replace&lt;/code&gt; 를 사용하면 &amp;lt;토큰&amp;gt;과 동일한 기존 예고편이 삭제되고 새 예고편이 추가됩니다. 삭제 된 예고편은 새 예고편이 추가 될 장소와 가장 가까운 예고편 (예 : &amp;lt;토큰&amp;gt;)입니다.</target>
        </trans-unit>
        <trans-unit id="a80ff1485c839f0e248b3acec4853d6b6aaf0d80" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;worktree add &amp;lt;path&amp;gt;&lt;/code&gt;, without &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, instead of creating a new branch from &lt;code&gt;HEAD&lt;/code&gt;, if there exists a tracking branch in exactly one remote matching the basename of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;, base the new branch on the remote-tracking branch, and mark the remote-tracking branch as &quot;upstream&quot; from the new branch.</source>
          <target state="translated">함께 &lt;code&gt;worktree add &amp;lt;path&amp;gt;&lt;/code&gt; 없이 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 대신로부터 새로운 브랜치 생성 &lt;code&gt;HEAD&lt;/code&gt; 를 원격의 기본 이름과 일치하는 정확히 하나의 추적 지점이 존재하는 경우, &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 원격 추적의 새로운 지점,베이스 분기하고 원격 추적 분기를 새 분기의 &quot;업스트림&quot;으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7b787c22358696a7fd63895c838388aed6d7912a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;worktree add &amp;lt;path&amp;gt;&lt;/code&gt;, without &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, instead of creating a new branch from HEAD, if there exists a tracking branch in exactly one remote matching the basename of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;, base the new branch on the remote-tracking branch, and mark the remote-tracking branch as &quot;upstream&quot; from the new branch.</source>
          <target state="translated">함께 &lt;code&gt;worktree add &amp;lt;path&amp;gt;&lt;/code&gt; 없이 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 대신 리모트베이스 이름과 일치하는 정확히 하나의 추적 지점이 존재하는 경우, 선두로부터의 새로운 지점을 만드는 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 원격 추적의 새로운 지점,베이스 원격 추적 분기를 새 분기에서 &quot;업스트림&quot;으로 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="660d18378dc3af084a2ac18df92d87c9aea68c5a" translate="yes" xml:space="preserve">
          <source>With Git bisect it&amp;rsquo;s a breeze: in the best case i can get a ~15 step kernel bisection done in 20-30 minutes, in an automated way. Even with manual help or when bisecting multiple, overlapping bugs, it&amp;rsquo;s rarely more than an hour.</source>
          <target state="translated">Git bisect를 사용하면 산들 바람이납니다. 가장 좋은 경우에는 자동화 된 방식으로 20-30 분 안에 ~ 15 단계 커널 bisection을 수행 할 수 있습니다. 수동 도움말이나 여러 개의 겹치는 버그를 이등분 할 때도 거의 1 시간 이상 걸리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46d101f0f209ac246ff187c45b6b808668e526b7" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;-d&lt;/code&gt; or &lt;code&gt;-D&lt;/code&gt; option, &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; will be deleted. You may specify more than one branch for deletion. If the branch currently has a reflog then the reflog will also be deleted.</source>
          <target state="translated">A를 &lt;code&gt;-d&lt;/code&gt; 또는 &lt;code&gt;-D&lt;/code&gt; 옵션, &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; 삭제됩니다. 삭제할 분기를 둘 이상 지정할 수 있습니다. 분기에 현재 reflog가있는 경우 reflog도 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f74d36fd60998cbf589b7f2b7f7bc156998c0334" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-M&lt;/code&gt; option, &amp;lt;oldbranch&amp;gt; will be renamed to &amp;lt;newbranch&amp;gt;. If &amp;lt;oldbranch&amp;gt; had a corresponding reflog, it is renamed to match &amp;lt;newbranch&amp;gt;, and a reflog entry is created to remember the branch renaming. If &amp;lt;newbranch&amp;gt; exists, -M must be used to force the rename to happen.</source>
          <target state="translated">A를 &lt;code&gt;-m&lt;/code&gt; 또는 &lt;code&gt;-M&lt;/code&gt; 옵션, &amp;lt;oldbranch&amp;gt; 이름이 바뀐에 &amp;lt;newbranch&amp;gt; 일 것이다. &amp;lt;oldbranch&amp;gt;에 해당 reflog가 있으면 이름이 &amp;lt;newbranch&amp;gt;와 일치하도록 이름이 바뀌고 분기 이름 변경을 기억하기 위해 reflog 항목이 작성됩니다. &amp;lt;newbranch&amp;gt;가 존재하면 -M을 사용하여 이름 변경을 강제 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="078f9b93867e54fc6fd5cb6cccb717d173a4bdbb" translate="yes" xml:space="preserve">
          <source>With a small group, developers may just pull changes from each other&amp;rsquo;s repositories without the need for a central maintainer.</source>
          <target state="translated">소규모 그룹에서는 개발자가 중앙 관리자 없이도 서로의 리포지토리에서 변경 사항을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d93af44627c4056a70413d4d1086a466c1eb6057" translate="yes" xml:space="preserve">
          <source>With an optional &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; argument, use the ref to find the notes to display. The ref can specify the full refname when it begins with &lt;code&gt;refs/notes/&lt;/code&gt;; when it begins with &lt;code&gt;notes/&lt;/code&gt;, &lt;code&gt;refs/&lt;/code&gt; and otherwise &lt;code&gt;refs/notes/&lt;/code&gt; is prefixed to form a full name of the ref.</source>
          <target state="translated">선택적 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 인수 와 함께 ref를 사용하여 표시 할 메모를 찾으십시오. ref는 &lt;code&gt;refs/notes/&lt;/code&gt; 시작할 때 전체 refname을 지정할 수 있습니다 . &lt;code&gt;notes/&lt;/code&gt; 시작 하면 &lt;code&gt;refs/&lt;/code&gt; 및 그렇지 않으면 &lt;code&gt;refs/notes/&lt;/code&gt; 가 접두어로 ref의 전체 이름을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="5888510f888416379a4d4b5651fc198f809cb1eb" translate="yes" xml:space="preserve">
          <source>With an optional argument, you can return to a different commit instead:</source>
          <target state="translated">선택적 인수를 사용하면 대신 다른 커밋으로 돌아갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70761b9c0ed85e86f5fe4551851f4fb12dda8ef2" translate="yes" xml:space="preserve">
          <source>With centralized revision control systems this is often accomplished by including every module in one single repository. Developers can check out all modules or only the modules they need to work with. They can even modify files across several modules in a single commit while moving things around or updating APIs and translations.</source>
          <target state="translated">중앙 집중식 개정 제어 시스템을 사용하면 모든 모듈을 하나의 단일 리포지토리에 포함시켜 종종 수행됩니다. 개발자는 모든 모듈 또는 작업해야하는 모듈 만 체크 아웃 할 수 있습니다. API 또는 변환을 이동하거나 업데이트하면서 단일 커밋으로 여러 모듈의 파일을 수정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c6d117a828bd4f381c3ccbd2807a5bac87363d5" translate="yes" xml:space="preserve">
          <source>With most hosting providers that support SSH, a single key pair uniquely identifies a user. Therefore, to use multiple accounts, it&amp;rsquo;s necessary to create a key pair for each account. If you&amp;rsquo;re using a reasonably modern OpenSSH version, you can create a new key pair with something like &lt;code&gt;ssh-keygen -t ed25519 -f ~/.ssh/id_committer&lt;/code&gt;. You can then register the public key (in this case, &lt;code&gt;~/.ssh/id_committer.pub&lt;/code&gt;; note the &lt;code&gt;.pub&lt;/code&gt;) with the hosting provider.</source>
          <target state="translated">SSH를 지원하는 대부분의 호스팅 제공 업체에서는 단일 키 쌍이 사용자를 고유하게 식별합니다. 따라서 여러 계정을 사용하려면 각 계정에 대해 키 쌍을 만들어야합니다. 합리적으로 최신 OpenSSH 버전을 사용하는 경우 &lt;code&gt;ssh-keygen -t ed25519 -f ~/.ssh/id_committer&lt;/code&gt; 와 같은 새 키 쌍을 만들 수 있습니다 . 그런 다음 호스팅 제공 업체에 공개 키 (이 경우 &lt;code&gt;~/.ssh/id_committer.pub&lt;/code&gt; , &lt;code&gt;.pub&lt;/code&gt; 메모 ) 를 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34547cdab6bbebc8d70f8627cf92ce4ed49693c0" translate="yes" xml:space="preserve">
          <source>With no arguments, shows a list of existing remotes. Several subcommands are available to perform operations on the remotes.</source>
          <target state="translated">인수없이 기존 리모컨 목록을 표시합니다. 리모트에서 조작을 수행하기 위해 여러 부속 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d8eac222dcf5b2fb83219646b45ebbea55b5081" translate="yes" xml:space="preserve">
          <source>With no arguments, shows the status of existing submodules. Several subcommands are available to perform operations on the submodules.</source>
          <target state="translated">인수없이 기존 하위 모듈의 상태를 표시합니다. 서브 모듈에 대한 조작을 수행하기 위해 여러 부속 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2955e54fe9fa9b7446c513283cbd98f27b722daf" translate="yes" xml:space="preserve">
          <source>With no arguments, this will:</source>
          <target state="translated">논증없이, 이것은 :</target>
        </trans-unit>
        <trans-unit id="07ab1293ff3b475c814f1fed59da838b442b2582" translate="yes" xml:space="preserve">
          <source>With no options and no COMMAND or GUIDE given, the synopsis of the &lt;code&gt;git&lt;/code&gt; command and a list of the most commonly used Git commands are printed on the standard output.</source>
          <target state="translated">옵션과 COMMAND 또는 GUIDE가 없으면 &lt;code&gt;git&lt;/code&gt; 명령 의 개요 와 가장 일반적으로 사용되는 Git 명령 목록이 표준 출력에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="5afd0acc1bfdb6a1daab0a26aea947b62407909e" translate="yes" xml:space="preserve">
          <source>With something like git.git current tree, I get:</source>
          <target state="translated">git.git 현재 트리와 같은 것으로 다음을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="48292de53da5a3060e12b426e889eefbf2d24e76" translate="yes" xml:space="preserve">
          <source>With that configuration the full path to browse repositories would be:</source>
          <target state="translated">이 구성을 사용하면 리포지토리를 탐색하는 전체 경로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de963656527f9e7a6067d643ee4aa5bfca1b2d08" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--append&lt;/code&gt; option, include all commits that are present in the existing commit-graph file.</source>
          <target state="translated">&lt;code&gt;--append&lt;/code&gt; 옵션을 사용하면 기존 커밋 그래프 파일에있는 모든 커밋을 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="14495f11a1a9217fb75c7d6db611a80cccd6e859" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--branch&lt;/code&gt; option, the command takes a name and checks if it can be used as a valid branch name (e.g. when creating a new branch). But be cautious when using the previous checkout syntax that may refer to a detached HEAD state. The rule &lt;code&gt;git check-ref-format --branch $name&lt;/code&gt; implements may be stricter than what &lt;code&gt;git check-ref-format refs/heads/$name&lt;/code&gt; says (e.g. a dash may appear at the beginning of a ref component, but it is explicitly forbidden at the beginning of a branch name). When run with &lt;code&gt;--branch&lt;/code&gt; option in a repository, the input is first expanded for the &amp;ldquo;previous checkout syntax&amp;rdquo; &lt;code&gt;@{-n}&lt;/code&gt;. For example, &lt;code&gt;@{-1}&lt;/code&gt; is a way to refer the last thing that was checked out using &quot;git switch&quot; or &quot;git checkout&quot; operation. This option should be used by porcelains to accept this syntax anywhere a branch name is expected, so they can act as if you typed the branch name. As an exception note that, the &amp;ldquo;previous checkout operation&amp;rdquo; might result in a commit object name when the N-th last thing checked out was not a branch.</source>
          <target state="translated">으로 &lt;code&gt;--branch&lt;/code&gt; 가 (예를 들어, 새로운 지점을 만들 때) 유효한 지점 이름으로 사용 할 수있는 경우 옵션, 명령은 이름과 검사를합니다. 그러나 분리 된 HEAD 상태를 참조 할 수있는 이전 체크 아웃 구문을 사용할 때는주의하십시오. &lt;code&gt;git check-ref-format --branch $name&lt;/code&gt; 구현 규칙 은 &lt;code&gt;git check-ref-format refs/heads/$name&lt;/code&gt; 보다 엄격 할 수 있습니다 (예 : 대시는 ref 구성 요소의 시작 부분에 나타날 수 있지만 명시 적으로 나타납니다) 지점 이름의 시작 부분에서 금지됨). 저장소에서 &lt;code&gt;--branch&lt;/code&gt; 옵션을 사용하여 실행하면 먼저 &quot;이전 체크 아웃 구문&quot; &lt;code&gt;@{-n}&lt;/code&gt; 대한 입력이 확장됩니다 . 예를 들어, &lt;code&gt;@{-1}&lt;/code&gt; &quot;git switch&quot;또는 &quot;git checkout&quot;조작을 사용하여 마지막으로 체크 아웃 된 것을 참조하는 방법입니다. 이 옵션은 도자기에서 분기 이름이 필요한 곳이면 어디에서나이 구문을 허용하므로 분기 이름을 입력 한 것처럼 작동 할 수 있어야합니다. 예외적으로,&amp;ldquo;이전 체크 아웃 작업&amp;rdquo;으로 인해 마지막으로 체크 아웃 한 N 번째 항목이 분기가 아닌 경우 커밋 개체 이름이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="294719ccdfaa2864ec086fd6924ef46c18c6d01c" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--changed-paths&lt;/code&gt; option, compute and write information about the paths changed between a commit and its first parent. This operation can take a while on large repositories. It provides significant performance gains for getting history of a directory or a file with &lt;code&gt;git log -- &amp;lt;path&amp;gt;&lt;/code&gt;. If this option is given, future commit-graph writes will automatically assume that this option was intended. Use &lt;code&gt;--no-changed-paths&lt;/code&gt; to stop storing this data.</source>
          <target state="translated">와 &lt;code&gt;--changed-paths&lt;/code&gt; 는 A 커밋 사이에서 변화 경로와 최초의 부모에 대한 옵션, 컴퓨팅 및 쓰기 정보를 제공합니다. 이 작업은 큰 저장소에서 다소 시간이 걸릴 수 있습니다. &lt;code&gt;git log -- &amp;lt;path&amp;gt;&lt;/code&gt; 를 사용하여 디렉토리 또는 파일 기록을 가져 오는 데 상당한 성능 향상을 제공합니다 . 이 옵션이 제공되면 향후 커밋 그래프 쓰기는이 옵션이 의도 된 것으로 자동으로 가정합니다. 이 데이터 저장을 중지 하려면 &lt;code&gt;--no-changed-paths&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ac44a38e65d55dddeac740d3be63e38e85fa148" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--max-new-filters=&amp;lt;n&amp;gt;&lt;/code&gt; option, generate at most &lt;code&gt;n&lt;/code&gt; new Bloom filters (if &lt;code&gt;--changed-paths&lt;/code&gt; is specified). If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt;, no limit is enforced. Only commits present in the new layer count against this limit. To retroactively compute Bloom filters over earlier layers, it is advised to use &lt;code&gt;--split=replace&lt;/code&gt;. Overrides the &lt;code&gt;commitGraph.maxNewFilters&lt;/code&gt; configuration.</source>
          <target state="translated">으로 &lt;code&gt;--max-new-filters=&amp;lt;n&amp;gt;&lt;/code&gt; 옵션 많아야 생성 &lt;code&gt;n&lt;/code&gt; (만약 새로운 블룸 필터 &lt;code&gt;--changed-paths&lt;/code&gt; 지정된다). 경우 &lt;code&gt;n&lt;/code&gt; 이 있다 &lt;code&gt;-1&lt;/code&gt; , 제한이 적용되지 않습니다. 새 레이어에있는 커밋 만이 제한에 포함됩니다. 이전 레이어에서 Bloom 필터를 소급하여 계산하려면 &lt;code&gt;--split=replace&lt;/code&gt; 를 사용하는 것이 좋습니다 . &lt;code&gt;commitGraph.maxNewFilters&lt;/code&gt; 구성을 재정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f26f07033bd08bfdb6102afbc60e4bb690a51e35" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--reachable&lt;/code&gt; option, generate the new commit graph by walking commits starting at all refs. (Cannot be combined with &lt;code&gt;--stdin-commits&lt;/code&gt; or &lt;code&gt;--stdin-packs&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;--reachable&lt;/code&gt; 옵션을 사용하면 모든 심판에서 시작되는 커밋을 걸어 새로운 커밋 그래프를 생성합니다. &lt;code&gt;--stdin-commits&lt;/code&gt; 또는 &lt;code&gt;--stdin-packs&lt;/code&gt; 와 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="bced3fa737464959bcb0c4d4992aedaa6293d7b5" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--shallow&lt;/code&gt; option, only check the tip commit-graph file in a chain of split commit-graphs.</source>
          <target state="translated">&lt;code&gt;--shallow&lt;/code&gt; 옵션을 사용하면 분할 커밋 그래프 체인에서 tip commit-graph 파일 만 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="023fb87ae200847a2eb976930adb7f7ff9a576bb" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--split&lt;/code&gt; option, write the commit-graph as a chain of multiple commit-graph files stored in &lt;code&gt;&amp;lt;dir&amp;gt;/info/commit-graphs&lt;/code&gt;. The new commits not already in the commit-graph are added in a new &quot;tip&quot; file. This file is merged with the existing file if the following merge conditions are met:</source>
          <target state="translated">&lt;code&gt;--split&lt;/code&gt; 옵션을 사용하여 commit-graph를 &lt;code&gt;&amp;lt;dir&amp;gt;/info/commit-graphs&lt;/code&gt; 에 저장된 여러 commit-graph 파일의 체인으로 작성하십시오 . commit-graph에 아직없는 새로운 commit은 새로운 &quot;tip&quot;파일에 추가됩니다. 다음 병합 조건이 충족되면이 파일은 기존 파일과 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="6bf69abea1fff62b20072adaab62de0f43e36b76" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--split[=&amp;lt;strategy&amp;gt;]&lt;/code&gt; option, write the commit-graph as a chain of multiple commit-graph files stored in &lt;code&gt;&amp;lt;dir&amp;gt;/info/commit-graphs&lt;/code&gt;. Commit-graph layers are merged based on the strategy and other splitting options. The new commits not already in the commit-graph are added in a new &quot;tip&quot; file. This file is merged with the existing file if the following merge conditions are met:</source>
          <target state="translated">으로 &lt;code&gt;--split[=&amp;lt;strategy&amp;gt;]&lt;/code&gt; 복수의 체인에 저장된 파일 - 그래프 커밋 옵션 커밋 그래프를 작성 &lt;code&gt;&amp;lt;dir&amp;gt;/info/commit-graphs&lt;/code&gt; . 커밋 그래프 레이어는 전략 및 기타 분할 옵션에 따라 병합됩니다. commit-graph에 아직없는 새 커밋은 새 &quot;tip&quot;파일에 추가됩니다. 다음 병합 조건이 충족되는 경우이 파일은 기존 파일과 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="0f402e69b2097f87a53ae26564ee053ba1f630ec" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--stdin-commits&lt;/code&gt; option, generate the new commit graph by walking commits starting at the commits specified in stdin as a list of OIDs in hex, one OID per line. (Cannot be combined with &lt;code&gt;--stdin-packs&lt;/code&gt; or &lt;code&gt;--reachable&lt;/code&gt;.)</source>
          <target state="translated">으로 &lt;code&gt;--stdin-commits&lt;/code&gt; 옵션, 새로운 16 진수의 OID를 목록, 한 줄에 하나의 OID로하여 stdin에 지정된 커밋에서 시작 도보 커밋으로 그래프를 저지 생성합니다. &lt;code&gt;--stdin-packs&lt;/code&gt; 또는 &lt;code&gt;--reachable&lt;/code&gt; 과 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4837cdd22ed59b809de4737c644da886aae1ea19" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--stdin-commits&lt;/code&gt; option, generate the new commit graph by walking commits starting at the commits specified in stdin as a list of OIDs in hex, one OID per line. OIDs that resolve to non-commits (either directly, or by peeling tags) are silently ignored. OIDs that are malformed, or do not exist generate an error. (Cannot be combined with &lt;code&gt;--stdin-packs&lt;/code&gt; or &lt;code&gt;--reachable&lt;/code&gt;.)</source>
          <target state="translated">으로 &lt;code&gt;--stdin-commits&lt;/code&gt; 옵션, 새로운 16 진수의 OID를 목록, 한 줄에 하나의 OID로하여 stdin에 지정된 커밋에서 시작 도보 커밋으로 그래프를 저지 생성합니다. 비 커밋 (직접 또는 필링 태그)로 확인되는 OID는 자동으로 무시됩니다. 형식이 잘못되었거나 존재하지 않는 OID는 오류를 생성합니다. ( &lt;code&gt;--stdin-packs&lt;/code&gt; 또는 &lt;code&gt;--reachable&lt;/code&gt; 과 함께 사용할 수 없습니다 .)</target>
        </trans-unit>
        <trans-unit id="eaf73ef52d157ce1e4ddc4b827c0a6415ea79de1" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--stdin-packs&lt;/code&gt; option, generate the new commit graph by walking objects only in the specified pack-indexes. (Cannot be combined with &lt;code&gt;--stdin-commits&lt;/code&gt; or &lt;code&gt;--reachable&lt;/code&gt;.)</source>
          <target state="translated">으로 &lt;code&gt;--stdin-packs&lt;/code&gt; 옵션, 새로운 도보로 그래프는 지정된 팩 - 인덱스에서 개체를 커밋 생성합니다. &lt;code&gt;--stdin-commits&lt;/code&gt; 또는 &lt;code&gt;--reachable&lt;/code&gt; 과 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="17857b1a19de2786ab177b98550f7755d5958169" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;subsystem&lt;/code&gt; reflog: after &lt;code&gt;git fetch&lt;/code&gt;, the old tip of &lt;code&gt;subsystem&lt;/code&gt; is at &lt;code&gt;subsystem@{1}&lt;/code&gt;. Subsequent fetches will increase the number. (See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt;.)</source>
          <target state="translated">으로 &lt;code&gt;subsystem&lt;/code&gt; reflog : 후 &lt;code&gt;git fetch&lt;/code&gt; 의 이전 팁 &lt;code&gt;subsystem&lt;/code&gt; 에있다 &lt;code&gt;subsystem@{1}&lt;/code&gt; . 이후에 가져 오면 숫자가 증가합니다. ( &lt;a href=&quot;git-reflog&quot;&gt;git-reflog [1]&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="b4f2100600cd65d2bb507aefd40b38b428ed31a7" translate="yes" xml:space="preserve">
          <source>With the example above that would give:</source>
          <target state="translated">위의 예를 통해 다음과 같은 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a003c8ea87ae62c71ced8657b18db066ae621f53" translate="yes" xml:space="preserve">
          <source>With the exception of raw file data (which Git does not interpret) the fast-import input format is text (ASCII) based. This text based format simplifies development and debugging of frontend programs, especially when a higher level language such as Perl, Python or Ruby is being used.</source>
          <target state="translated">원시 파일 데이터 (Git이 해석하지 않는)를 제외하고 빠른 가져 오기 입력 형식은 텍스트 (ASCII)입니다. 이 텍스트 기반 형식은 특히 Perl, Python 또는 Ruby와 같은 고급 언어를 사용하는 경우 프론트 엔드 프로그램의 개발 및 디버깅을 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="832b24adba81a74f8f3c27d1a374c3c9abe6eae9" translate="yes" xml:space="preserve">
          <source>With the latter, you can use the manual viewer of your choice; see &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt; for more information.</source>
          <target state="translated">후자를 사용하면 선택한 수동 뷰어를 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fd552b2cf02d64fea6c3a2fbecdcfeec69fa5199" translate="yes" xml:space="preserve">
          <source>With the right arguments, &lt;code&gt;git diff&lt;/code&gt; can also show us the difference between the working directory and the last commit, or between the index and the last commit:</source>
          <target state="translated">올바른 인수를 사용하면 &lt;code&gt;git diff&lt;/code&gt; 는 작업 디렉토리와 마지막 커밋 또는 인덱스와 마지막 커밋의 차이점을 보여줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6936b3f47f8ae1f272ba09aecb9105ac3f327d8a" translate="yes" xml:space="preserve">
          <source>With the strategies that use 3-way merge (including the default, &lt;code&gt;recursive&lt;/code&gt;), if a change is made on both branches, but later reverted on one of the branches, that change will be present in the merged result; some people find this behavior confusing. It occurs because only the heads and the merge base are considered when performing a merge, not the individual commits. The merge algorithm therefore considers the reverted change as no change at all, and substitutes the changed version instead.</source>
          <target state="translated">3 방향 병합 (기본값, &lt;code&gt;recursive&lt;/code&gt; 포함)을 사용하는 전략을 사용 하면 두 분기 모두에서 변경이 이루어지고 나중에 분기 중 하나에서 복귀 된 경우 해당 변경 사항이 병합 된 결과에 나타납니다. 어떤 사람들은이 행동이 혼란 스럽다고 생각합니다. 개별 커밋이 아닌 병합을 수행 할 때 헤드와 병합 기반 만 고려되기 때문에 발생합니다. 따라서 병합 알고리즘은 되 돌린 변경 사항을 전혀 변경되지 않은 것으로 간주하고 변경된 버전을 대신 사용합니다.</target>
        </trans-unit>
        <trans-unit id="993a54cdc4357f066aea765f4571bf68eff0acc7" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git cherry-pick&lt;/code&gt; will let you edit the commit message prior to committing.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;git cherry-pick&lt;/code&gt; 을 사용하여 커밋하기 전에 커밋 메시지를 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="333853f3b4bc551496449cd51ab3f625f2fd83b5" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git gc&lt;/code&gt; checks whether any housekeeping is required; if not, it exits without performing any work.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;git gc&lt;/code&gt; 는 하우스 키핑이 필요한지 확인합니다. 그렇지 않으면 작업을 수행하지 않고 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="71e625d3b0cf2785820345a3c9b0fc38126ae685" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git revert&lt;/code&gt; will let you edit the commit message prior to committing the revert. This is the default if you run the command from a terminal.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;git revert&lt;/code&gt; 를 사용하여 되돌리기를 커밋하기 전에 커밋 메시지를 편집 할 수 있습니다. 터미널에서 명령을 실행하는 경우 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="c4b763c3b176a1288a147104d8354f56c0e27e09" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git revert&lt;/code&gt; will not start the commit message editor.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;git revert&lt;/code&gt; 는 커밋 메시지 편집기를 시작하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c4fe13a9c7d1e41585a8e2b5418a2b1ca5a28f1" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;merge-recursive&lt;/code&gt; spends a little extra time to avoid mismerges that sometimes occur due to unimportant matching lines (e.g., braces from distinct functions). Use this when the branches to be merged have diverged wildly. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--patience&lt;/code&gt;.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;merge-recursive&lt;/code&gt; 는 중요하지 않은 일치하는 줄 (예 : 고유 함수의 중괄호)로 인해 때때로 발생하는 혼란을 피하기 위해 약간의 추가 시간을 소비합니다. 병합 할 브랜치가 심하게 분기 된 경우이 옵션을 사용하십시오. &lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--patience&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b7fa933690b4dfe40d9dc500f9cfa6ba3897c3d" translate="yes" xml:space="preserve">
          <source>With this option, diff output for a merge commit shows the differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time. Furthermore, it lists only files which were modified from all parents.</source>
          <target state="translated">이 옵션을 사용하면 병합 커밋에 대한 diff 출력은 부모와 결과 사이에 한 번에 하나씩 diff를 표시하는 대신 각 부모와 병합 결과의 차이를 동시에 표시합니다. 또한 모든 상위에서 수정 된 파일 만 나열합니다.</target>
        </trans-unit>
        <trans-unit id="3524864d6b6fccf88decb6caefb79eeb0a8e7c7e" translate="yes" xml:space="preserve">
          <source>With this option, git will replace all refnames, paths, blob contents, commit and tag messages, names, and email addresses in the output with anonymized data. Two instances of the same string will be replaced equivalently (e.g., two commits with the same author will have the same anonymized author in the output, but bear no resemblance to the original author string). The relationship between commits, branches, and tags is retained, as well as the commit timestamps (but the commit messages and refnames bear no resemblance to the originals). The relative makeup of the tree is retained (e.g., if you have a root tree with 10 files and 3 trees, so will the output), but their names and the contents of the files will be replaced.</source>
          <target state="translated">이 옵션을 사용하면 git은 출력의 모든 참조 이름, 경로, 얼룩 내용, 커밋 및 태그 메시지, 이름 및 전자 메일 주소를 익명 데이터로 바꿉니다. 동일한 문자열의 두 인스턴스는 동일하게 대체됩니다 (예 : 동일한 작성자의 두 커밋은 출력에서 ​​동일한 익명의 작성자를 갖지만 원래 작성자 문자열과 유사하지 않음). 커밋, 분기 및 태그 간의 관계는 커밋 타임 스탬프와 함께 유지되지만 커밋 메시지 및 참조 이름은 원본과 유사하지 않습니다. 트리의 상대적 구성은 유지되지만 (예를 들어, 파일이 10 개이고 트리가 3 개인 루트 트리가있는 경우 출력도 마찬가지 임) 파일의 이름과 내용이 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="cbb1ff7744c2585e2c6b4c0275539aaae99818d7" translate="yes" xml:space="preserve">
          <source>With this option, parents that are hidden by grafts are packed nevertheless.</source>
          <target state="translated">그럼에도 불구하고이 옵션을 사용하면 이식편에 의해 숨겨진 부모가 포장됩니다.</target>
        </trans-unit>
        <trans-unit id="64d24b372615e7424e92210d8b3079a3b6d54b46" translate="yes" xml:space="preserve">
          <source>With this option, the command includes the current branch to the list of revs to be shown when it is not given on the command line.</source>
          <target state="translated">이 옵션을 사용하면 명령 행에 표시되지 않을 때 표시 할 rev 목록에 대한 현재 분기가 명령에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a7994938c4128018ec7f46d918cac8d359a1f2eb" translate="yes" xml:space="preserve">
          <source>With this, &lt;code&gt;git show-branch&lt;/code&gt; without extra parameters would show only the primary branches. In addition, if you happen to be on your topic branch, it is shown as well.</source>
          <target state="translated">이를 통해 추가 매개 변수가없는 &lt;code&gt;git show-branch&lt;/code&gt; 는 기본 분기 만 표시합니다. 또한 토픽 브랜치에있을 경우에도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7d389d82d11c207ddbcbb54d477d308b2e5d9f7f" translate="yes" xml:space="preserve">
          <source>With this, Alice can perform the first part of the &quot;pull&quot; operation alone using the &lt;code&gt;git fetch&lt;/code&gt; command without merging them with her own branch, using:</source>
          <target state="translated">이를 통해 Alice는 다음을 사용하여 자체 분기와 병합하지 않고 &lt;code&gt;git fetch&lt;/code&gt; 명령을 사용하여 &quot;풀&quot;작업의 첫 번째 부분 만 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6062bf6506f2ab2b976dee38aa5322c59a129e2f" translate="yes" xml:space="preserve">
          <source>Within a linked working tree, $GIT_DIR is set to point to this private directory (e.g. &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; in the example) and $GIT_COMMON_DIR is set to point back to the main working tree&amp;rsquo;s $GIT_DIR (e.g. &lt;code&gt;/path/main/.git&lt;/code&gt;). These settings are made in a &lt;code&gt;.git&lt;/code&gt; file located at the top directory of the linked working tree.</source>
          <target state="translated">연결된 작업 트리 내에서 $ &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; 개인 디렉토리 (예 : /path/main/.git/worktrees/test-next )를 가리 키도록 설정되고 $ GIT_COMMON_DIR은 기본 작업 트리의 $ GIT_DIR을 다시 가리 키도록 설정됩니다. (예 : &lt;code&gt;/path/main/.git&lt;/code&gt; ). 이러한 설정은 연결된 작업 트리의 최상위 디렉토리 에있는 &lt;code&gt;.git&lt;/code&gt; 파일 에서 이루어집니다 .</target>
        </trans-unit>
        <trans-unit id="28d243903fe73e45525c0f96e48fd5d6abc9c7f9" translate="yes" xml:space="preserve">
          <source>Within a linked working tree, &lt;code&gt;$GIT_DIR&lt;/code&gt; is set to point to this private directory (e.g. &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; in the example) and &lt;code&gt;$GIT_COMMON_DIR&lt;/code&gt; is set to point back to the main working tree&amp;rsquo;s &lt;code&gt;$GIT_DIR&lt;/code&gt; (e.g. &lt;code&gt;/path/main/.git&lt;/code&gt;). These settings are made in a &lt;code&gt;.git&lt;/code&gt; file located at the top directory of the linked working tree.</source>
          <target state="translated">연결된 작업 트리 내에서 &lt;code&gt;$GIT_DIR&lt;/code&gt; &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; 개인 디렉터리 (예 : /path/main/.git/worktrees/test-next ) 를 가리 키도록 설정 되고 &lt;code&gt;$GIT_COMMON_DIR&lt;/code&gt; 은 기본 작업 트리의 &lt;code&gt;$GIT_DIR&lt;/code&gt; GIT_DIR 을 다시 가리 키도록 설정됩니다. (예 : &lt;code&gt;/path/main/.git&lt;/code&gt; ). 이러한 설정은 연결된 작업 트리의 최상위 디렉토리 에있는 &lt;code&gt;.git&lt;/code&gt; 파일 에서 이루어집니다 .</target>
        </trans-unit>
        <trans-unit id="f531335c76344721aaf744205582ff3be68651bd" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;--all&lt;/code&gt; and without any &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt;, the heads that exist both on the local side and on the remote side are updated.</source>
          <target state="translated">않고 &lt;code&gt;--all&lt;/code&gt; 어떤없이 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 로컬 측과 원격 측에 모두 존재하는 헤드가 갱신된다.</target>
        </trans-unit>
        <trans-unit id="af870a4c72e2ec7c668a803b1e745b16df6d1c9d" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;--follow-symlinks&lt;/code&gt;, these would print data about the symlink itself. In the case of &lt;code&gt;HEAD:link&lt;/code&gt;, you would see</source>
          <target state="translated">&lt;code&gt;--follow-symlinks&lt;/code&gt; 가 없으면 심볼릭 링크 자체에 대한 데이터를 인쇄합니다. 의 경우 &lt;code&gt;HEAD:link&lt;/code&gt; , 당신은 볼 것이다</target>
        </trans-unit>
        <trans-unit id="a213d6298e44415b29925050ee6ffa235637e828" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;--force&lt;/code&gt;, the &amp;lt;src&amp;gt; ref is stored at the remote only if &amp;lt;dst&amp;gt; does not exist, or &amp;lt;dst&amp;gt; is a proper subset (i.e. an ancestor) of &amp;lt;src&amp;gt;. This check, known as &quot;fast-forward check&quot;, is performed in order to avoid accidentally overwriting the remote ref and lose other peoples' commits from there.</source>
          <target state="translated">&lt;code&gt;--force&lt;/code&gt; 가 없으면 &amp;lt;src&amp;gt; 참조는 &amp;lt;dst&amp;gt;가 없거나 &amp;lt;dst&amp;gt;가 &amp;lt;src&amp;gt;의 적절한 하위 집합 (즉, 조상) 인 경우에만 원격에 저장됩니다. &quot;빨리 감기 검사&quot;라고하는이 검사는 실수로 원격 참조를 덮어 쓰지 않고 다른 사람들의 커밋을 잃지 않도록하기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="44aa5155d389a8a00fc9a9c0d5c5dc24c0b6b423" translate="yes" xml:space="preserve">
          <source>Without additional configuration, pushes the current branch to the configured upstream (&lt;code&gt;remote.origin.merge&lt;/code&gt; configuration variable) if it has the same name as the current branch, and errors out without pushing otherwise.</source>
          <target state="translated">추가 구성없이 현재 분기와 현재 분기 와 이름이 같은 경우 현재 분기를 구성된 업스트림 ( &lt;code&gt;remote.origin.merge&lt;/code&gt; 구성 변수)으로 푸시하고 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0d4981e0bf66e69e6f534946531426d82d26ec6d" translate="yes" xml:space="preserve">
          <source>Without an optional path parameter, all files and subdirectories of the current working directory are included in the archive. If one or more paths are specified, only these are included.</source>
          <target state="translated">선택적 경로 매개 변수가 없으면 현재 작업 디렉토리의 모든 파일 및 서브 디렉토리가 아카이브에 포함됩니다. 하나 이상의 경로가 지정되면 경로 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0aaf17e36c6d625d7976371bb21725d2cea205e0" translate="yes" xml:space="preserve">
          <source>Without any credential helpers defined, Git will try the following strategies to ask the user for usernames and passwords:</source>
          <target state="translated">자격 증명 도우미가 정의되지 않은 경우 Git은 사용자에게 사용자 이름과 암호를 요청하기 위해 다음 전략을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="6f8c2669a27a9c22abf3f515b27b1a9a5be3b6dc" translate="yes" xml:space="preserve">
          <source>Without disambiguating &lt;code&gt;--&lt;/code&gt;, Git makes a reasonable guess, but errors out and asking you to disambiguate when ambiguous. E.g. if you have a file called HEAD in your work tree, &lt;code&gt;git diff HEAD&lt;/code&gt; is ambiguous, and you have to say either &lt;code&gt;git diff HEAD --&lt;/code&gt; or &lt;code&gt;git diff -- HEAD&lt;/code&gt; to disambiguate.</source>
          <target state="translated">명확하지 않은 &lt;code&gt;--&lt;/code&gt; , Git은 합리적인 추측을했지만, 오류가 발생하여 모호 할 때 명확하게 할 것을 요구합니다. 예를 들어 작업 트리에 HEAD라는 파일이 있으면 &lt;code&gt;git diff HEAD&lt;/code&gt; 가 모호 &lt;code&gt;git diff HEAD --&lt;/code&gt; 또는 &lt;code&gt;git diff -- HEAD&lt;/code&gt; 중 하나 를 명확히해야합니다.</target>
        </trans-unit>
        <trans-unit id="636ef8b24660180a9f9d02cde9f707a809036029" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;-z&lt;/code&gt; option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;-z&lt;/code&gt; 옵션이 없으면 구성 변수 &lt;code&gt;core.quotePath&lt;/code&gt; 에 설명 된대로 &quot;특이하지 않은&quot;문자가있는 경로 이름이 인용됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fbf6695514712c3a8e39b514953f35111f6c3ca8" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;-z&lt;/code&gt; option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). Using &lt;code&gt;-z&lt;/code&gt; the filename is output verbatim and the line is terminated by a NUL byte.</source>
          <target state="translated">&lt;code&gt;-z&lt;/code&gt; 옵션이 없으면 구성 변수 &lt;code&gt;core.quotePath&lt;/code&gt; 에 설명 된대로 &quot;특이하지 않은&quot;문자가있는 경로 이름이 인용됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ). &lt;code&gt;-z&lt;/code&gt; 를 사용 하면 파일 이름이 그대로 출력되고 행이 NUL 바이트로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="94da29d7f90d6f6f16856adba693bd0f5ed5aeb9" translate="yes" xml:space="preserve">
          <source>Without the &lt;em&gt;--more=1&lt;/em&gt; option, &lt;em&gt;git show-branch&lt;/em&gt; would not output the &lt;em&gt;[master^]&lt;/em&gt; commit, as &lt;em&gt;[mybranch]&lt;/em&gt; commit is a common ancestor of both &lt;em&gt;master&lt;/em&gt; and &lt;em&gt;mybranch&lt;/em&gt; tips. Please see &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">&lt;em&gt;--more = 1&lt;/em&gt; 옵션을 사용 하지 않으면 &lt;em&gt;git show-branch&lt;/em&gt; 는 &lt;em&gt;[master ^]&lt;/em&gt; 커밋을 출력하지 않습니다. &lt;em&gt;[mybranch]&lt;/em&gt; 커밋은 &lt;em&gt;마스터&lt;/em&gt; 및 &lt;em&gt;mybranch&lt;/em&gt; 팁 의 공통 조상이기 때문 입니다. 자세한 내용은 &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c29d8269d6df0a76bd7b7031ef1a5a35a844def8" translate="yes" xml:space="preserve">
          <source>Without this flag, &lt;code&gt;git log -p &amp;lt;path&amp;gt;...&lt;/code&gt; shows commits that touch the specified paths, and diffs about the same specified paths. With this, the full diff is shown for commits that touch the specified paths; this means that &quot;&amp;lt;path&amp;gt;&amp;hellip;​&quot; limits only commits, and doesn&amp;rsquo;t limit diff for those commits.</source>
          <target state="translated">이 플래그가 없으면 &lt;code&gt;git log -p &amp;lt;path&amp;gt;...&lt;/code&gt; 는 지정된 경로를 터치하는 커밋을 표시하고 동일한 지정된 경로를 비교합니다. 이를 통해 지정된 경로를 터치하는 커밋에 대한 전체 diff가 표시됩니다. 이것은 &quot;&amp;lt;path&amp;gt;&amp;hellip;&quot;는 커밋 만 제한하고 커밋에 대한 차이점을 제한하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b86cf57585935f6e60cc9059e45208393d99c9a8" translate="yes" xml:space="preserve">
          <source>Without this option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">이 옵션이 없으면 구성 변수 &lt;code&gt;core.quotePath&lt;/code&gt; 에 설명 된대로 &quot;비정상적인&quot;문자가 포함 된 경로 이름이 인용됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8450aafea5471fb336aa6711b707fb955fd65d91" translate="yes" xml:space="preserve">
          <source>Workflow for a third party library</source>
          <target state="translated">써드 파티 라이브러리의 워크 플로우</target>
        </trans-unit>
        <trans-unit id="8dfb0e4b50fd82c5ff8bc5fed81147f5e4aadb05" translate="yes" xml:space="preserve">
          <source>Workflow for an artificially split repo</source>
          <target state="translated">인위적으로 분할 된 저장소에 대한 워크 플로우</target>
        </trans-unit>
        <trans-unit id="825ce9e97dc41179ec167b83be91179b5dacd316" translate="yes" xml:space="preserve">
          <source>Workflows</source>
          <target state="translated">Workflows</target>
        </trans-unit>
        <trans-unit id="72b02433b5041ac5ef6045242ff8d0e2784944a3" translate="yes" xml:space="preserve">
          <source>Working branch; defaults to HEAD.</source>
          <target state="translated">워킹 브랜치; 기본값은 HEAD입니다.</target>
        </trans-unit>
        <trans-unit id="a2b68acce45b31c1701e61880a9ac430bd217ef5" translate="yes" xml:space="preserve">
          <source>Working directory specific configuration file for the main working directory in multiple working directory setup (see &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt;).</source>
          <target state="translated">여러 작업 디렉토리 설정에서 기본 작업 디렉토리에 대한 작업 디렉토리 특정 구성 파일 ( &lt;a href=&quot;git-worktree&quot;&gt;git-worktree [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="29f32a47a3074cae8d2558abdc45a4c7a3f4de27" translate="yes" xml:space="preserve">
          <source>Working directory specific configuration file.</source>
          <target state="translated">작업 디렉토리 특정 구성 파일.</target>
        </trans-unit>
        <trans-unit id="b7010e71f35d363293e1c71cea9eb7b673f227d7" translate="yes" xml:space="preserve">
          <source>Working trees can be identified by path, either relative or absolute.</source>
          <target state="translated">작업 트리는 상대 또는 절대 경로로 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5850a4e043e763eb3c70b51337df764ed12f013" translate="yes" xml:space="preserve">
          <source>Working with others</source>
          <target state="translated">다른 사람들과 함께 일하기</target>
        </trans-unit>
        <trans-unit id="883363a342498bf776fadbacf0d9322246ddce5d" translate="yes" xml:space="preserve">
          <source>Working with others, shared repository style</source>
          <target state="translated">다른 사람과 작업, 공유 저장소 스타일</target>
        </trans-unit>
        <trans-unit id="62159bf12f9108d11431e1d1114bdbbeecf78451" translate="yes" xml:space="preserve">
          <source>Works just like --signature except the signature is read from a file.</source>
          <target state="translated">서명을 파일에서 읽는 것을 제외하고 --signature와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="097006f59137099e2d2ccff414198fea83903044" translate="yes" xml:space="preserve">
          <source>Works just like format.signature except the contents of the file specified by this variable will be used as the signature.</source>
          <target state="translated">이 변수로 지정된 파일의 내용이 서명으로 사용된다는 점을 제외하면 format.signature와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c45647582ec4fc92bdcd3ecd1a16e9638ca339a8" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;git push &amp;lt;remote&amp;gt;&lt;/code&gt;, where &amp;lt;remote&amp;gt; is the current branch&amp;rsquo;s remote (or &lt;code&gt;origin&lt;/code&gt;, if no remote is configured for the current branch).</source>
          <target state="translated">&lt;code&gt;git push &amp;lt;remote&amp;gt;&lt;/code&gt; 와 같이 작동합니다 . 여기서 &amp;lt;remote&amp;gt;는 현재 브랜치의 리모트 (또는 현재 브랜치에 대해 리모트가 구성되어 있지 않은 경우 &lt;code&gt;origin&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="96f0b3b7db8530493b30466426fa80c5c21f66c1" translate="yes" xml:space="preserve">
          <source>Wrap code spawning child processes.</source>
          <target state="translated">코드 생성 하위 프로세스를 랩핑하십시오.</target>
        </trans-unit>
        <trans-unit id="1f9c72af7bca7c9666626fcb471d6065e154c93d" translate="yes" xml:space="preserve">
          <source>Write a MIDX file for the packfiles in an alternate object store.</source>
          <target state="translated">대체 오브젝트 저장소에 팩 파일에 대한 MIDX 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="36b48ab2e331354b7c3cc2f14ff9d8ea9d1001c3" translate="yes" xml:space="preserve">
          <source>Write a MIDX file for the packfiles in the current .git folder.</source>
          <target state="translated">현재 .git 폴더에 팩 파일에 대한 MIDX 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b42a0c66496716fcd8c88f5906d20e5cf08f4975" translate="yes" xml:space="preserve">
          <source>Write a chapter on using plumbing and writing scripts.</source>
          <target state="translated">배관 사용 및 스크립트 작성에 관한 장을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c8e128b9f546fd58c7e614d0f8b8821821084ae1" translate="yes" xml:space="preserve">
          <source>Write a commit-graph after fetching. This overrides the config setting &lt;code&gt;fetch.writeCommitGraph&lt;/code&gt;.</source>
          <target state="translated">페치 후 커밋 그래프를 작성하십시오. 이는 구성 설정 &lt;code&gt;fetch.writeCommitGraph&lt;/code&gt; 를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="e518a1279678087b263b8a6d5d4572c2e8b9dd3b" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file based on the commits found in packfiles.</source>
          <target state="translated">packfiles에있는 커밋을 기반으로 커밋 그래프 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="31a24952f6ac97438fc3f890b7eeabaf5006955a" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file based on the commits found in packfiles. If the config option &lt;code&gt;core.commitGraph&lt;/code&gt; is disabled, then this command will output a warning, then return success without writing a commit-graph file.</source>
          <target state="translated">팩 파일에서 찾은 커밋을 기반으로 커밋 그래프 파일을 작성합니다. &lt;code&gt;core.commitGraph&lt;/code&gt; 구성 옵션 이 비활성화 된 경우이 명령은 경고를 출력 한 다음 커밋 그래프 파일을 작성하지 않고 성공을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a8a7e9f2485bf10bd9980490fdf55b0594e99b5f" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file containing all commits in the current commit-graph file along with those reachable from &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 에서 도달 할 수있는 커밋과 함께 현재 커밋 그래프 파일의 모든 커밋을 포함하는 커밋 그래프 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c34e4cbacab76dc7a95f5e0f46081aab1f59603" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file containing all reachable commits.</source>
          <target state="translated">도달 가능한 모든 커밋을 포함하는 커밋 그래프 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="e1238f6b25cc5d29bebfcc60e794e1647b6dd786" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file for the packed commits in your local &lt;code&gt;.git&lt;/code&gt; directory.</source>
          <target state="translated">압축 된 커밋에 대한 커밋 그래프 파일을 로컬 &lt;code&gt;.git&lt;/code&gt; 디렉토리에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="7ba716e808cc8cf569e10d2453e1761bc59eae40" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file, extending the current commit-graph file using commits in &lt;code&gt;&amp;lt;pack-index&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;pack-index&amp;gt;&lt;/code&gt; 의 커밋을 사용하여 현재 커밋 그래프 파일을 확장하여 커밋 그래프 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="73c3a355bd823c82bb9b3a929df0d2e920a5e648" translate="yes" xml:space="preserve">
          <source>Write a new MIDX file.</source>
          <target state="translated">새로운 MIDX 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b0d7b6d61dd4b6501290a029b72f9ed15f8cc305" translate="yes" xml:space="preserve">
          <source>Write a reachability bitmap index as part of the repack. This only makes sense when used with &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;-A&lt;/code&gt;, as the bitmaps must be able to refer to all reachable objects. This option overrides the setting of &lt;code&gt;repack.writeBitmaps&lt;/code&gt;. This option has no effect if multiple packfiles are created.</source>
          <target state="translated">재 포장의 일부로 도달 가능성 비트 맵 인덱스를 작성하십시오. 비트 맵이 도달 가능한 모든 객체를 참조 할 수 있어야하므로 &lt;code&gt;-a&lt;/code&gt; 또는 &lt;code&gt;-A&lt;/code&gt; 와 함께 사용하는 경우에만 의미가 있습니다. 이 옵션은 &lt;code&gt;repack.writeBitmaps&lt;/code&gt; 설정을 대체합니다 . 이 옵션은 여러 팩 파일이 작성된 경우 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ec591cf31eda36450bc843a926c4fd529f9a0da" translate="yes" xml:space="preserve">
          <source>Write a set of patterns to the sparse-checkout file, as given as a list of arguments following the &lt;code&gt;set&lt;/code&gt; subcommand. Update the working directory to match the new patterns. Enable the core.sparseCheckout config setting if it is not already enabled.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 부속 명령 다음에 인수 목록으로 제공된대로 패턴 세트를 스파 스 체크 아웃 파일에 씁니다 . 새 패턴과 일치하도록 작업 디렉토리를 업데이트하십시오. core.sparseCheckout 구성 설정이 아직 활성화되지 않은 경우 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="041470620f3506e6e154d55da89dd48b2bba6ec8" translate="yes" xml:space="preserve">
          <source>Write and verify Git commit-graph files</source>
          <target state="translated">Git 커밋 그래프 파일 작성 및 확인</target>
        </trans-unit>
        <trans-unit id="fbde21d9f61e2faa3e597fb0c951212436d2d05f" translate="yes" xml:space="preserve">
          <source>Write and verify multi-pack-indexes</source>
          <target state="translated">멀티 팩 인덱스 작성 및 확인</target>
        </trans-unit>
        <trans-unit id="0874d3d36a3af067f281de19e268427b067828a4" translate="yes" xml:space="preserve">
          <source>Write dangling objects into .git/lost-found/commit/ or .git/lost-found/other/, depending on type. If the object is a blob, the contents are written into the file, rather than its object name.</source>
          <target state="translated">매달린 객체를 유형에 따라 .git / lost-found / commit / 또는 .git / lost-found / other /에 씁니다. 오브젝트가 Blob 인 경우 컨텐츠는 오브젝트 이름이 아닌 파일에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d9accbc71f1215e3614372f554930a021fe71b0a" translate="yes" xml:space="preserve">
          <source>Write into pairs of files (.pack and .idx), using &amp;lt;base-name&amp;gt; to determine the name of the created file. When this option is used, the two files in a pair are written in &amp;lt;base-name&amp;gt;-&amp;lt;SHA-1&amp;gt;.{pack,idx} files. &amp;lt;SHA-1&amp;gt; is a hash based on the pack content and is written to the standard output of the command.</source>
          <target state="translated">&amp;lt;base-name&amp;gt;을 사용하여 파일 쌍 (.pack 및 .idx)에 작성하여 작성된 파일의 이름을 판별하십시오. 이 옵션을 사용하면 한 쌍의 두 파일이 &amp;lt;base-name&amp;gt;-&amp;lt;SHA-1&amp;gt;. {pack, idx} 파일에 기록됩니다. &amp;lt;SHA-1&amp;gt;은 팩 내용을 기반으로하는 해시이며 명령의 표준 출력에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="7fe0c30065baa84a0511c3d3081d91c7d606dfea" translate="yes" xml:space="preserve">
          <source>Write or verify a multi-pack-index (MIDX) file.</source>
          <target state="translated">다중 팩 인덱스 (MIDX) 파일을 쓰거나 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e39d29fa27aa3fd795b76126771a3ffa6c08d16a" translate="yes" xml:space="preserve">
          <source>Write responses to &lt;code&gt;get-mark&lt;/code&gt;, &lt;code&gt;cat-blob&lt;/code&gt;, and &lt;code&gt;ls&lt;/code&gt; queries to the file descriptor &amp;lt;fd&amp;gt; instead of &lt;code&gt;stdout&lt;/code&gt;. Allows &lt;code&gt;progress&lt;/code&gt; output intended for the end-user to be separated from other output.</source>
          <target state="translated">&lt;code&gt;stdout&lt;/code&gt; 대신 &lt;code&gt;get-mark&lt;/code&gt; , &lt;code&gt;cat-blob&lt;/code&gt; 및 &lt;code&gt;ls&lt;/code&gt; 쿼리에 대한 응답을 파일 디스크립터 &amp;lt;fd&amp;gt;에 씁니다 . 허용 &lt;code&gt;progress&lt;/code&gt; 최종 사용자를위한 출력은 다른 출력으로부터 분리된다.</target>
        </trans-unit>
        <trans-unit id="e189db14fd9c8dacb74b437fa25a566d7b39760b" translate="yes" xml:space="preserve">
          <source>Write the archive to &amp;lt;file&amp;gt; instead of stdout.</source>
          <target state="translated">아카이브를 stdout 대신 &amp;lt;file&amp;gt;에 씁니다.</target>
        </trans-unit>
        <trans-unit id="7dc7fd5fc893589e612150dc5a94bc95c63f6644" translate="yes" xml:space="preserve">
          <source>Write the generated pack index into the specified file. Without this option the name of pack index file is constructed from the name of packed archive file by replacing .pack with .idx (and the program fails if the name of packed archive does not end with .pack).</source>
          <target state="translated">생성 된 팩 색인을 지정된 파일에 기록하십시오. 이 옵션이 없으면 팩 색인 파일의 이름은 .pack을 .idx로 바꾸어 압축 된 아카이브 파일의 이름으로 구성됩니다 (그리고 압축 된 아카이브 이름이 .pack으로 끝나지 않으면 프로그램이 실패 함).</target>
        </trans-unit>
        <trans-unit id="898b44ae7851f33ec7de0339d5f319ea640d48c2" translate="yes" xml:space="preserve">
          <source>Write the list of remote refs fetched in the &lt;code&gt;FETCH_HEAD&lt;/code&gt; file directly under &lt;code&gt;$GIT_DIR&lt;/code&gt;. This is the default. Passing &lt;code&gt;--no-write-fetch-head&lt;/code&gt; from the command line tells Git not to write the file. Under &lt;code&gt;--dry-run&lt;/code&gt; option, the file is never written.</source>
          <target state="translated">&lt;code&gt;$GIT_DIR&lt;/code&gt; &lt;code&gt;FETCH_HEAD&lt;/code&gt; 바로 아래 FETCH_HEAD 파일 에서 가져온 원격 참조 목록을 작성하십시오 . 이것이 기본값입니다. 명령 줄에서 &lt;code&gt;--no-write-fetch-head&lt;/code&gt; 를 전달하면 Git이 파일을 쓰지 않도록 지시합니다. 아래 &lt;code&gt;--dry-run&lt;/code&gt; 옵션, 파일이 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ee51e3bc5f984d1828334228be7ce34fc987d1e" translate="yes" xml:space="preserve">
          <source>Write the pack contents (what would have been written to .pack file) out to the standard output.</source>
          <target state="translated">팩 내용 (.pack 파일에 기록 된 내용)을 표준 출력에 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="f8fab17bc8f3e5385c26a96bd869170c9b748651" translate="yes" xml:space="preserve">
          <source>Write the resulting index out in the named on-disk format version. Supported versions are 2, 3 and 4. The current default version is 2 or 3, depending on whether extra features are used, such as &lt;code&gt;git add -N&lt;/code&gt;.</source>
          <target state="translated">결과 색인을 명명 된 온 디스크 형식 버전으로 작성하십시오. 지원되는 버전은 2, 3 및 4입니다. 현재 기본 버전은 &lt;code&gt;git add -N&lt;/code&gt; 과 같은 추가 기능 사용 여부에 따라 2 또는 3 입니다.</target>
        </trans-unit>
        <trans-unit id="efedecbf7e9a176a45aaee6d10ad017d653ffad6" translate="yes" xml:space="preserve">
          <source>Write to standard error. Note that if &lt;code&gt;--detach&lt;/code&gt; is specified, the process disconnects from the real standard error, making this destination effectively equivalent to &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">표준 오류에 씁니다. 참고 경우 것으로 &lt;code&gt;--detach&lt;/code&gt; 가 지정되어, 실제 표준 오류에서 프로세스 연결 해제는, 효과적으로 상당이 대상 만드는 &lt;code&gt;none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04570d31869f8fe0ff9437709cb2be3000b6efb7" translate="yes" xml:space="preserve">
          <source>Write to syslog, using the &lt;code&gt;git-daemon&lt;/code&gt; identifier.</source>
          <target state="translated">&lt;code&gt;git-daemon&lt;/code&gt; 식별자를 사용하여 syslog에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="b06c59a883065a2aa7a048f19cdd388e420a56a1" translate="yes" xml:space="preserve">
          <source>Write whatever message you want, and all the lines that start with &lt;code&gt;#&lt;/code&gt; will be pruned out, and the rest will be used as the commit message for the change. If you decide you don&amp;rsquo;t want to commit anything after all at this point (you can continue to edit things and update the index), you can just leave an empty message. Otherwise &lt;code&gt;git commit&lt;/code&gt; will commit the change for you.</source>
          <target state="translated">원하는 메시지를 쓰면 &lt;code&gt;#&lt;/code&gt; 으로 시작하는 모든 줄이 정리되고 나머지는 변경에 대한 커밋 메시지로 사용됩니다. 이 시점에서 아무 것도 커밋하지 않기로 결정한 경우 (계속 편집하고 인덱스를 업데이트 할 수 있음) 빈 메시지를 남길 수 있습니다. 그렇지 않으면 &lt;code&gt;git commit&lt;/code&gt; 이 변경 사항을 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="61b122f3a92e6ba319a161e3ee36a5061ca2ea4c" translate="yes" xml:space="preserve">
          <source>Writes a tree object that represents a subdirectory &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt;. This can be used to write the tree object for a subproject that is in the named subdirectory.</source>
          <target state="translated">&lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt; 서브 디렉토리를 나타내는 트리 오브젝트를 작성합니다 . 이름이 지정된 서브 디렉토리에있는 서브 프로젝트의 트리 오브젝트를 작성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="157114a94f76dd225b6968a998012309617b01fe" translate="yes" xml:space="preserve">
          <source>Writes the commit-id into the filename under $GIT_DIR/refs/&amp;lt;filename&amp;gt; on the local end after the transfer is complete.</source>
          <target state="translated">전송이 완료된 후 로컬 끝에서 $ GIT_DIR / refs / &amp;lt;filename&amp;gt; 아래의 파일 이름에 commit-id를 씁니다.</target>
        </trans-unit>
        <trans-unit id="e02c77bcdadadb66d0f7703e015b6bcd89a6c5e3" translate="yes" xml:space="preserve">
          <source>X: &quot;unknown&quot; change type (most probably a bug, please report it)</source>
          <target state="translated">X : &quot;알 수없는&quot;변경 유형 (아마도 버그 일 것입니다.)</target>
        </trans-unit>
        <trans-unit id="c4701ab33311f5af4d25d032b9d36f7ee2d229e7" translate="yes" xml:space="preserve">
          <source>You &lt;code&gt;must&lt;/code&gt; therefore ensure that the most recent commit of the branch you want to dcommit to is the &lt;code&gt;first&lt;/code&gt; parent of the merge. Chaos will ensue otherwise, especially if the first parent is an older commit on the same SVN branch.</source>
          <target state="translated">당신은 &lt;code&gt;must&lt;/code&gt; , 따라서 가장 최근의 당신에 dcommit 할 브랜치의 커밋되도록하는 것은입니다 &lt;code&gt;first&lt;/code&gt; 병합의 부모입니다. 특히 첫 번째 부모가 같은 SVN 브랜치에서 이전 커밋 인 경우 혼돈이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="33b03e34a8212275c562b3fd47359312e9fb9f26" translate="yes" xml:space="preserve">
          <source>You also could say &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;clean&lt;/code&gt; above as long as the choice is unique.</source>
          <target state="translated">선택이 독특하다면, &lt;code&gt;c&lt;/code&gt; 라고 말 하거나 &lt;code&gt;clean&lt;/code&gt; 말할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3633df0f340d7a5b00e10a65751fa4510ce91fa7" translate="yes" xml:space="preserve">
          <source>You also could say &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;sta&lt;/code&gt; or &lt;code&gt;status&lt;/code&gt; above as long as the choice is unique.</source>
          <target state="translated">선택 사항이 고유 한 한 &lt;code&gt;s&lt;/code&gt; 또는 &lt;code&gt;sta&lt;/code&gt; 또는 &lt;code&gt;status&lt;/code&gt; 를 위와 같이 말할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80dcbb43282a1e399b57f0acd29e7d516598c299" translate="yes" xml:space="preserve">
          <source>You also need to ensure that each repository is &quot;bare&quot; (without a Git index file) for &lt;code&gt;cvs commit&lt;/code&gt; to work. See &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;code&gt;cvs commit&lt;/code&gt; 이 작동하려면 각 리포지토리가 &quot;깃손&quot;(Git 인덱스 파일 없음)인지 확인해야합니다 . &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="63d1d5a88c78a80cfc3950acb2e452ff58df3b69" translate="yes" xml:space="preserve">
          <source>You also should not rewind branches in a submodule beyond commits that were ever recorded in any superproject.</source>
          <target state="translated">또한 수퍼 프로젝트에서 기록 된 커밋 이외의 하위 모듈에서 분기를 되 감지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="9cb8652293d991a8fc334c9f946fb5900f566815" translate="yes" xml:space="preserve">
          <source>You are happily working on something, and find the changes in these files are in good order. You do not want to see them when you run &lt;code&gt;git diff&lt;/code&gt;, because you plan to work on other files and changes with these files are distracting.</source>
          <target state="translated">행복하게 작업하고 있으며 이러한 파일의 변경 사항이 올바른지 확인하십시오. &lt;code&gt;git diff&lt;/code&gt; 를 실행할 때 다른 파일에 대한 작업을 계획하고 이러한 파일에 대한 변경 사항이 산만 해지기 때문에 이를보고 싶지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="48f9e78ec61620aadfc7c1e71bab372f08845a6f" translate="yes" xml:space="preserve">
          <source>You are in the middle of a refactoring session and your boss comes in and demands that you fix something immediately. You might typically use &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; to store your changes away temporarily, however, your working tree is in such a state of disarray (with new, moved, and removed files, and other bits and pieces strewn around) that you don&amp;rsquo;t want to risk disturbing any of it. Instead, you create a temporary linked working tree to make the emergency fix, remove it when done, and then resume your earlier refactoring session.</source>
          <target state="translated">리팩토링 세션 중에 상사가 와서 즉시 무언가를 고치라고 요구합니다. 일반적으로 &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; 를 사용하여 변경 사항을 일시적으로 저장하지만 작업 트리는 (새 파일, 이동 및 제거 된 파일 및 기타 비트와 조각이 흩어져있는) 혼란 상태에 있습니다. 방해 할 위험이 없습니다. 대신 임시 링크 작업 트리를 작성하여 응급 수정을 수행하고 완료되면 제거하고 이전 리팩토링 세션을 재개하십시오.</target>
        </trans-unit>
        <trans-unit id="bb2df2ca18755cbd46a4ed871293669f22530506" translate="yes" xml:space="preserve">
          <source>You are now ready to commit. You can see what is about to be committed using &lt;code&gt;git diff&lt;/code&gt; with the --cached option:</source>
          <target state="translated">이제 커밋 할 준비가되었습니다. --cached 옵션과 함께 &lt;code&gt;git diff&lt;/code&gt; 를 사용하여 커밋하려는 내용을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="074e56336e1be0630703b280d6a3b60899f28a4c" translate="yes" xml:space="preserve">
          <source>You can adjust how pages generated by gitweb look using the variables described below. You can change the site name, add common headers and footers for all pages, and add a description of this gitweb installation on its main page (which is the projects list page), etc.</source>
          <target state="translated">아래 설명 된 변수를 사용하여 gitweb에 의해 생성 된 페이지의 모양을 조정할 수 있습니다. 사이트 이름을 변경하고 모든 페이지에 공통 머리글과 바닥 글을 추가하고 기본 페이지 (프로젝트 목록 페이지)에이 gitweb 설치에 대한 설명을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5130cbe18f25cdc12700266fadc1f554b9c37ce" translate="yes" xml:space="preserve">
          <source>You can also ask git log to show patches:</source>
          <target state="translated">git log에게 패치를 보여달라고 요청할 수도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f5378640dc8884e7695fa8d24ebc61aad94be600" translate="yes" xml:space="preserve">
          <source>You can also check out &lt;code&gt;origin/todo&lt;/code&gt; directly to examine it or write a one-off patch. See &lt;a href=&quot;#detached-head&quot;&gt;detached head&lt;/a&gt;.</source>
          <target state="translated">당신은 또한 확인할 수 있습니다 &lt;code&gt;origin/todo&lt;/code&gt; 을 검사하거나 일회성 패치를 작성하는 직접. &lt;a href=&quot;#detached-head&quot;&gt;분리 된 헤드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7520d8990c9fc0c63fb723451f5a4b04ab5ce6bc" translate="yes" xml:space="preserve">
          <source>You can also control this behavior with the &lt;code&gt;core.whitespace&lt;/code&gt; setting if you don&amp;rsquo;t wish to remove the carriage returns from your line endings.</source>
          <target state="translated">줄 끝에서 캐리지 리턴을 제거하지 않으려면 &lt;code&gt;core.whitespace&lt;/code&gt; 설정 으로이 동작을 제어 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1dba829f7b6e6b2354184e851e59ecadab491f50" translate="yes" xml:space="preserve">
          <source>You can also edit a patch series with an interactive rebase. This is the same as &lt;a href=&quot;#reordering-patch-series&quot;&gt;reordering a patch series using &lt;code&gt;format-patch&lt;/code&gt;&lt;/a&gt;, so use whichever interface you like best.</source>
          <target state="translated">대화식 rebase를 사용하여 패치 시리즈를 편집 할 수도 있습니다. &lt;a href=&quot;#reordering-patch-series&quot;&gt; &lt;code&gt;format-patch&lt;/code&gt; 를&lt;/a&gt; 사용하여 패치 시리즈를 재정렬하는 것과 동일 하므로 가장 선호하는 인터페이스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a56f9e1e04034dbb228cdfc1e0cb38c07a8bcbf1" translate="yes" xml:space="preserve">
          <source>You can also fetch branches from other repositories; so</source>
          <target state="translated">다른 리포지토리에서 분기를 가져올 수도 있습니다. 그래서</target>
        </trans-unit>
        <trans-unit id="bb4e25e283a061b1bebe5a9dd36fbbd03f0e1b4b" translate="yes" xml:space="preserve">
          <source>You can also give &lt;code&gt;git log&lt;/code&gt; a &quot;range&quot; of commits where the first is not necessarily an ancestor of the second; for example, if the tips of the branches &quot;stable&quot; and &quot;master&quot; diverged from a common commit some time ago, then</source>
          <target state="translated">또한 &lt;code&gt;git log&lt;/code&gt; 에 커밋의 &quot;범위&quot;를 줄 수 있습니다 . 첫 번째는 반드시 두 번째의 조상이 아닙니다. 예를 들어 분기 &quot;안정한&quot;및 &quot;마스터&quot;의 팁이 얼마 전에 공통 커밋에서 벗어난 경우</target>
        </trans-unit>
        <trans-unit id="c219057e4d44e965fab9fe1f77892cd8f09c5753" translate="yes" xml:space="preserve">
          <source>You can also give commits names of your own; after running</source>
          <target state="translated">또한 커밋 이름을 지정할 수도 있습니다. 실행 후</target>
        </trans-unit>
        <trans-unit id="ef70822bb0476f59f3e8869ce9a522611ff6cac9" translate="yes" xml:space="preserve">
          <source>You can also just enter your password when prompted. While it is possible to place the password (which must be percent-encoded) in the URL, this is not particularly secure and can lead to accidental exposure of credentials, so it is not recommended.</source>
          <target state="translated">메시지가 표시되면 비밀번호를 입력 할 수도 있습니다. URL에 암호 (백분율 인코딩되어야 함)를 넣을 수는 있지만 이는 특히 안전하지 않으며 실수로 자격 증명이 노출 될 수 있으므로 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cecebc054603ae5ff87afcd3e6caec5420b5c866" translate="yes" xml:space="preserve">
          <source>You can also override locations of gitweb configuration files during runtime by setting the following environment variables: &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt;, &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; and &lt;code&gt;GITWEB_CONFIG&lt;/code&gt; to a non-empty value.</source>
          <target state="translated">&lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt; , &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; 및 &lt;code&gt;GITWEB_CONFIG&lt;/code&gt; 환경 변수를 비어 있지 않은 값 으로 설정하여 런타임 동안 gitweb 구성 파일의 위치를 ​​무시할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c335f539c67224e67ef9ba8bcb55a78f32c2ba64" translate="yes" xml:space="preserve">
          <source>You can also revert an earlier change, for example, the next-to-last:</source>
          <target state="translated">또한 다음 변경 사항과 같은 이전 변경 사항을 되돌릴 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6f0f4e5da7f74f3d7e6aefa5597ca88126ce358" translate="yes" xml:space="preserve">
          <source>You can also run &lt;code&gt;git daemon&lt;/code&gt; as an inetd service; see the &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt; man page for details. (See especially the examples section.)</source>
          <target state="translated">&lt;code&gt;git daemon&lt;/code&gt; 을 inetd 서비스로 실행할 수도 있습니다 . 자세한 내용은 &lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]&lt;/a&gt; 매뉴얼 페이지를 참조하십시오. (특히 예제 섹션을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="f0a51538febea0717277859dfbb5418b689055cc" translate="yes" xml:space="preserve">
          <source>You can also see what references it offers:</source>
          <target state="translated">어떤 참조가 제공되는지 확인할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f06fdd5b89ee465ae510128ba09f10dd8adf5eac" translate="yes" xml:space="preserve">
          <source>You can also skip a range of commits, instead of just one commit, using range notation. For example:</source>
          <target state="translated">범위 표기법을 사용하여 단 하나의 커밋 대신 커밋 범위를 건너 뛸 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="54e517ee1d2086de2439776d35ac41cdff2f30f7" translate="yes" xml:space="preserve">
          <source>You can also track branches from repositories other than the one you cloned from, using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]을&lt;/a&gt; 사용하여 복제 한 저장소 이외의 저장소에서 분기를 추적 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28b63a93050077dfe73e5bbbcd2b4df244cc4f26" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt; to create commits, view changes in the index and the working tree files, and individually select diff hunks for inclusion in the index (by right-clicking on the diff hunk and choosing &quot;Stage Hunk For Commit&quot;).</source>
          <target state="translated">당신은 또한 사용할 수 있습니다 &lt;a href=&quot;git-gui&quot;&gt;자식 - GUI [1]&lt;/a&gt; 은 diff 화물선과 &quot;무대 덩어리에 대한 선택을 마우스 오른쪽 버튼으로 클릭 (인덱스에 포함 DIFF 심술쟁이을 선택 개별적으로 커밋,보기 변경 인덱스와 작업 트리 파일을 생성하고, 범하다&quot;).</target>
        </trans-unit>
        <trans-unit id="2d89b19204028ed2768f0a7d6951c7af3234e547" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; to generate patches for A, B and C, and the identifiers for P, X, Y, Z are appended at the end of the first message.</source>
          <target state="translated">또한 사용할 수있는 &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; A, B 및 C에 대한 패치를 생성하고, P, X, Y, Z에 대한 식별자는 제 메시지의 끝에 추가된다.</target>
        </trans-unit>
        <trans-unit id="2c144befb1f45c546071ce64e48b303dc0e810a7" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;git show&lt;/code&gt; to see any such file:</source>
          <target state="translated">&lt;code&gt;git show&lt;/code&gt; 를 사용 하여 그러한 파일을 볼 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49c3eff4b4dfbb20ea17f1bea994d4ab08b8a178" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;git_commit_non_empty_tree &quot;$@&quot;&lt;/code&gt; instead of &lt;code&gt;git commit-tree &quot;$@&quot;&lt;/code&gt; if you don&amp;rsquo;t wish to keep commits with a single parent and that makes no change to the tree.</source>
          <target state="translated">단일 부모와 커밋을 유지하지 않고 트리를 변경하지 않으려면 &lt;code&gt;git commit-tree &quot;$@&quot;&lt;/code&gt; &lt;code&gt;git_commit_non_empty_tree &quot;$@&quot;&lt;/code&gt; 대신 git_commit_non_empty_tree &quot;$ @&quot; 를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="015df615c0d1b650e7dd0d33e1d03af134ab36e3" translate="yes" xml:space="preserve">
          <source>You can always just jump back to your original &lt;code&gt;master&lt;/code&gt; branch by doing</source>
          <target state="translated">당신은 항상 원래의 &lt;code&gt;master&lt;/code&gt; 브랜치로 돌아갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3173f9b04378ce969d4435b57687de248be9e7d" translate="yes" xml:space="preserve">
          <source>You can always view an old version of a file by just checking out the correct revision first. But sometimes it is more convenient to be able to view an old version of a single file without checking anything out; this command does that:</source>
          <target state="translated">올바른 수정본을 먼저 확인하여 항상 파일의 이전 버전을 볼 수 있습니다. 그러나 때로는 아무것도 확인하지 않고 단일 파일의 이전 버전을 볼 수있는 것이 더 편리합니다. 이 명령은 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ac57e48df46d91546d0b6c2ab36f112078813032" translate="yes" xml:space="preserve">
          <source>You can at any time create a new branch by just picking an arbitrary point in the project history, and just writing the SHA-1 name of that object into a file under &lt;code&gt;.git/refs/heads/&lt;/code&gt;. You can use any filename you want (and indeed, subdirectories), but the convention is that the &quot;normal&quot; branch is called &lt;code&gt;master&lt;/code&gt;. That&amp;rsquo;s just a convention, though, and nothing enforces it.</source>
          <target state="translated">프로젝트 히스토리에서 임의의 지점을 선택하고 해당 오브젝트의 SHA-1 이름을 &lt;code&gt;.git/refs/heads/&lt;/code&gt; 아래의 파일에 작성하여 언제든지 새 브랜치를 작성할 수 있습니다 . 원하는 파일 이름 (및 실제로 서브 디렉토리)을 사용할 수 있지만 &quot;일반&quot;브랜치는 &lt;code&gt;master&lt;/code&gt; 라고 합니다. 그것은 단지 관습 일 뿐이며, 그것을 강요하는 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="28fdfbc805da6922683f26cc12f785c6a111b6ce" translate="yes" xml:space="preserve">
          <source>You can choose to provide the name of a file in &lt;code&gt;$GIT_DIR/branches&lt;/code&gt;. The URL in this file will be used to access the repository. This file should have the following format:</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/branches&lt;/code&gt; 파일 이름을 제공하도록 선택할 수 있습니다 . 이 파일의 URL은 저장소에 액세스하는 데 사용됩니다. 이 파일은 다음 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="184c3e9bbc8e0af36908329654dfda91364d6a99" translate="yes" xml:space="preserve">
          <source>You can choose to provide the name of a file in &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt;. The URL in this file will be used to access the repository. The refspec in this file will be used as default when you do not provide a refspec on the command line. This file should have the following format:</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; 파일 이름을 제공하도록 선택할 수 있습니다 . 이 파일의 URL은 저장소에 액세스하는 데 사용됩니다. 이 파일의 참조 스펙은 명령 행에 참조 스펙을 제공하지 않을 때 기본값으로 사용됩니다. 이 파일은 다음 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a92f2a4a63c6c2d142357d1e5947af0b6de272f3" translate="yes" xml:space="preserve">
          <source>You can choose to provide the name of a remote which you had previously configured using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;, &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; or even by a manual edit to the &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file. The URL of this remote will be used to access the repository. The refspec of this remote will be used by default when you do not provide a refspec on the command line. The entry in the config file would appear like this:</source>
          <target state="translated">&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; , &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 또는 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 파일 을 수동으로 편집 하여 이전에 구성한 리모컨의 이름을 제공하도록 선택할 수 있습니다 . 이 리모트의 URL은 저장소에 액세스하는 데 사용됩니다. 이 리모트의 참조 스펙은 명령 행에 참조 스펙을 제공하지 않을 때 기본적으로 사용됩니다. 구성 파일의 항목은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d377d9322805f2d9d1e87d74e556de9916d572ec" translate="yes" xml:space="preserve">
          <source>You can choose whether you want to trust the index file entirely (using the &lt;code&gt;--cached&lt;/code&gt; flag) or ask the diff logic to show any files that don&amp;rsquo;t match the stat state as being &quot;tentatively changed&quot;. Both of these operations are very useful indeed.</source>
          <target state="translated">&lt;code&gt;--cached&lt;/code&gt; 플래그를 사용하여 인덱스 파일을 완전히 신뢰할지 또는 통계 상태와 일치하지 않는 파일을 &quot;잠정적으로 변경됨&quot;으로 표시하도록 diff 논리에 요청 할지 여부를 선택할 수 있습니다 . 이 두 작업은 실제로 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7c0716128ee4fbd827cb316e0652131c44810ab6" translate="yes" xml:space="preserve">
          <source>You can configure gitweb to only list and allow viewing of the explicitly exported repositories, via &lt;code&gt;$export_ok&lt;/code&gt; variable in gitweb config file; see &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt; manpage. If it evaluates to true, gitweb shows repositories only if this file named by &lt;code&gt;$export_ok&lt;/code&gt; exists in its object database (if directory has the magic file named &lt;code&gt;$export_ok&lt;/code&gt;).</source>
          <target state="translated">gitweb 설정 파일의 &lt;code&gt;$export_ok&lt;/code&gt; 변수를 통해 명시 적으로 내 보낸 리포지토리 만 나열하고 볼 수 있도록 gitweb을 구성 할 수 있습니다 . &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt; 맨 페이지를 참조하십시오 . true로 평가되면 gitweb은 &lt;code&gt;$export_ok&lt;/code&gt; 이름 지정된이 파일이 오브젝트 데이터베이스에 존재하는 경우에만 디렉토리를 표시합니다 (디렉토리에 &lt;code&gt;$export_ok&lt;/code&gt; 라는 매직 파일이있는 경우 ).</target>
        </trans-unit>
        <trans-unit id="03a65df391294815ab470e62357c9e62de1fcfb2" translate="yes" xml:space="preserve">
          <source>You can configure individual repositories shown in gitweb by creating file in the &lt;code&gt;GIT_DIR&lt;/code&gt; of Git repository, or by setting some repo configuration variable (in &lt;code&gt;GIT_DIR/config&lt;/code&gt;, see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">Git 리포지토리 의 &lt;code&gt;GIT_DIR&lt;/code&gt; 에 파일을 만들 거나 일부 repo 구성 변수를 설정 하여 gitweb에 표시되는 개별 리포지토리를 구성 할 수 있습니다 ( &lt;code&gt;GIT_DIR/config&lt;/code&gt; 에서 &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="45321feeff0945f0a2ba053e8ab969c82cc417c8" translate="yes" xml:space="preserve">
          <source>You can configure the database backend with the following configuration variables:</source>
          <target state="translated">다음 구성 변수를 사용하여 데이터베이스 백엔드를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d268b7f609741cf4701b8230b6d95314deb17a7a" translate="yes" xml:space="preserve">
          <source>You can create a new commit that undoes whatever was done by the old commit. This is the correct thing if your mistake has already been made public.</source>
          <target state="translated">이전 커밋이 수행 한 모든 작업을 취소하는 새 커밋을 만들 수 있습니다. 실수가 이미 공개 된 경우 이것이 올바른 것입니다.</target>
        </trans-unit>
        <trans-unit id="d8a9d4babf707e6fca47541eba4fa0b4e8c8edd2" translate="yes" xml:space="preserve">
          <source>You can customize the rules that &lt;code&gt;git diff --word-diff&lt;/code&gt; uses to split words in a line, by specifying an appropriate regular expression in the &quot;diff.*.wordRegex&quot; configuration variable. For example, in TeX a backslash followed by a sequence of letters forms a command, but several such commands can be run together without intervening whitespace. To separate them, use a regular expression in your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">&quot;diff. *. wordRegex&quot;구성 변수에 적절한 정규식을 지정하여 &lt;code&gt;git diff --word-diff&lt;/code&gt; 가 단어를 한 줄로 나누는 데 사용 하는 규칙을 사용자 정의 할 수 있습니다 . 예를 들어, TeX에서 백 슬래시와 일련의 문자는 명령을 구성하지만 공백을 개입시키지 않고 이러한 명령을 함께 실행할 수 있습니다. 이를 분리하려면 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 파일 (또는 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 파일)에서 다음과 같이 정규식을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="38bcfec4c9f80337cd439b12b7afb0a63bb0fcb7" translate="yes" xml:space="preserve">
          <source>You can declare that a filter turns a content that by itself is unusable into a usable content by setting the filter.&amp;lt;driver&amp;gt;.required configuration variable to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">filter. &amp;lt;driver&amp;gt; .required 구성 변수를 &lt;code&gt;true&lt;/code&gt; 로 설정하여 필터가 자체적으로 사용할 수없는 컨텐츠를 사용 가능한 컨텐츠로 변환 함을 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7aeeb9d27bdf323aad4937a225d2c2d1d7d6f4b" translate="yes" xml:space="preserve">
          <source>You can easily create such a branch with Git using interactive rebase.</source>
          <target state="translated">대화식 리베이스를 사용하여 Git으로 이러한 브랜치를 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f7816df4cc860a9cfdb50146ff125e3acb46178" translate="yes" xml:space="preserve">
          <source>You can enforce finer grained permissions using update hooks. See &lt;a href=&quot;https://git-scm.com/docs/howto/update-hook-example&quot;&gt;Controlling access to branches using update hooks&lt;/a&gt;.</source>
          <target state="translated">업데이트 후크를 사용하여보다 세분화 된 권한을 적용 할 수 있습니다. &lt;a href=&quot;https://git-scm.com/docs/howto/update-hook-example&quot;&gt;업데이트 후크를 사용하여 분기에 대한 액세스 제어를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dca6628a0b53b9b002cd44ea35104ed275c53c21" translate="yes" xml:space="preserve">
          <source>You can examine one of those dangling commits with, for example,</source>
          <target state="translated">예를 들어 다음과 같이 매달린 커밋 중 하나를 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4807484ba96d5012055b128c8602211fd418a27a" translate="yes" xml:space="preserve">
          <source>You can examine such index state with &lt;code&gt;git ls-files --unmerged&lt;/code&gt; command. An example:</source>
          <target state="translated">&lt;code&gt;git ls-files --unmerged&lt;/code&gt; 명령을 사용 하여 이러한 인덱스 상태를 검사 할 수 있습니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="b5f066a300ab7fb920ca504e5ef4559d46dabfb5" translate="yes" xml:space="preserve">
          <source>You can examine the data represented in the object database and the index with various helper tools. For every object, you can use &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file[1]&lt;/a&gt; to examine details about the object:</source>
          <target state="translated">다양한 도우미 도구를 사용하여 개체 데이터베이스에 표시된 데이터와 인덱스를 검사 할 수 있습니다. 모든 객체에 대해 &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file [1]&lt;/a&gt; 을 사용하여 객체에 대한 세부 정보를 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd093df539bb25e8d4c6b75d7c53e29317d7deb5" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to the tool by setting the configuration variable &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to kdiff3 by setting &lt;code&gt;difftool.kdiff3.path&lt;/code&gt;. Otherwise, &lt;code&gt;git difftool&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="translated">구성 변수 &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.path&lt;/code&gt; 를 설정하여 도구의 전체 경로를 명시 적으로 제공 할 수 있습니다 . 예를 들어 &lt;code&gt;difftool.kdiff3.path&lt;/code&gt; 를 설정하여 kdiff3의 절대 경로를 구성 할 수 있습니다 . 그렇지 않으면 &lt;code&gt;git difftool&lt;/code&gt; 은 도구가 PATH에서 사용 가능하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="146074b490cdd862abeb41d866c18f9aaa225cf8" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to the tool by setting the configuration variable &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to kdiff3 by setting &lt;code&gt;mergetool.kdiff3.path&lt;/code&gt;. Otherwise, &lt;code&gt;git mergetool&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="translated">구성 변수 &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.path&lt;/code&gt; 를 설정하여 도구의 전체 경로를 명시 적으로 제공 할 수 있습니다 . 예를 들어 &lt;code&gt;mergetool.kdiff3.path&lt;/code&gt; 를 설정하여 kdiff3의 절대 경로를 구성 할 수 있습니다 . 그렇지 않으면 &lt;code&gt;git mergetool&lt;/code&gt; 은 도구가 PATH에서 사용 가능하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="77cbe572067fa57bc4362002e12fc6b7b8a04482" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to your preferred browser by setting the configuration variable &lt;code&gt;browser.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to firefox by setting &lt;code&gt;browser.firefox.path&lt;/code&gt;. Otherwise, &lt;code&gt;git web--browse&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="translated">구성 변수 &lt;code&gt;browser.&amp;lt;tool&amp;gt;.path&lt;/code&gt; 를 설정하여 선호하는 브라우저의 전체 경로를 명시 적으로 제공 할 수 있습니다 . 예를 들어 &lt;code&gt;browser.firefox.path&lt;/code&gt; 를 설정하여 firefox의 절대 경로를 구성 할 수 있습니다 . 그렇지 않으면 &lt;code&gt;git web--browse&lt;/code&gt; 는 도구를 PATH에서 사용할 수 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="1d73514fe413b4199a0b5fc2096f965b3e1620ee" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to your preferred man viewer by setting the configuration variable &lt;code&gt;man.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to konqueror by setting &lt;code&gt;man.konqueror.path&lt;/code&gt;. Otherwise, &lt;code&gt;git help&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="translated">구성 변수 &lt;code&gt;man.&amp;lt;tool&amp;gt;.path&lt;/code&gt; 를 설정하여 원하는 man 뷰어에 대한 전체 경로를 명시 적으로 제공 할 수 있습니다 . 예를 들어, &lt;code&gt;man.konqueror.path&lt;/code&gt; 를 설정하여 konqueror의 절대 경로를 구성 할 수 있습니다 . 그렇지 않으면 &lt;code&gt;git help&lt;/code&gt; 는 도구를 PATH에서 사용할 수 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="11d166169fafafa437c100a2b764012cf5981ced" translate="yes" xml:space="preserve">
          <source>You can focus your efforts to check at a few points (for example rc and beta releases) that all the T test cases pass for all the N configurations. And when some tests don&amp;rsquo;t pass you can use &quot;git bisect&quot; (or better &quot;git bisect run&quot;). So you should perform roughly:</source>
          <target state="translated">모든 T 테스트 사례가 모든 N 구성에 대해 통과하는 몇 가지 지점 (예 : rc 및 베타 릴리스)에서 확인하려는 노력에 집중할 수 있습니다. 그리고 일부 테스트가 통과되지 않으면 &quot;git bisect&quot;(또는 더 나은 &quot;git bisect run&quot;)를 사용할 수 있습니다. 따라서 대략적으로 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="59d0d873078b4f91b40c2ee1e2770f185d430915" translate="yes" xml:space="preserve">
          <source>You can further cut down the number of trials, if you know what part of the tree is involved in the problem you are tracking down, by specifying path parameters when issuing the &lt;code&gt;bisect start&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;bisect start&lt;/code&gt; 명령을 실행할 때 경로 매개 변수를 지정하여 추적 할 문제에 관련된 트리 부분을 알고있는 경우 시행 횟수를 추가로 줄일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5857d2949fb11d516cd50de71765499d023b3f6" translate="yes" xml:space="preserve">
          <source>You can generate diffs between any two versions using &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]을&lt;/a&gt; 사용하여 두 버전간에 차이를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98e4a2c67e91124741c5ae666b50315da705ecdc" translate="yes" xml:space="preserve">
          <source>You can generate the projects list index file using the project_index action (the &lt;code&gt;TXT&lt;/code&gt; link on projects list page) directly from gitweb; see also &quot;Generating projects list using gitweb&quot; section below.</source>
          <target state="translated">gitweb에서 직접 project_index 조치 ( 프로젝트 목록 페이지 의 &lt;code&gt;TXT&lt;/code&gt; 링크)를 사용하여 프로젝트 목록 색인 파일을 생성 할 수 있습니다 . 아래의 &quot;gitweb을 사용하여 프로젝트 목록 생성&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5b042e446e3f9ebd4b31fc02aac55f5c329ead7e" translate="yes" xml:space="preserve">
          <source>You can get a list of all available encodings on your platform with the following command:</source>
          <target state="translated">다음 명령을 사용하여 플랫폼에서 사용 가능한 모든 인코딩 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d921181a0df868b1892f0a3e234a9c29e516883" translate="yes" xml:space="preserve">
          <source>You can get just the old (respectively new) term with &lt;code&gt;git bisect terms
--term-old&lt;/code&gt; or &lt;code&gt;git bisect terms --term-good&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git bisect terms --term-old&lt;/code&gt; 또는 &lt;code&gt;git bisect terms --term-good&lt;/code&gt; 으로 오래된 (각각 새로운) 용어를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41b9643f0720517e2c1772471e0c09d5c46b9644" translate="yes" xml:space="preserve">
          <source>You can give the &lt;code&gt;-m&lt;/code&gt; flag to the command, which would try a three-way merge:</source>
          <target state="translated">명령에 &lt;code&gt;-m&lt;/code&gt; 플래그를 부여하면 3 방향 병합을 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36617ae8104572554e1e13e9574934aea0623eb3" translate="yes" xml:space="preserve">
          <source>You can go back and modify the old commit. You should never do this if you have already made the history public; Git does not normally expect the &quot;history&quot; of a project to change, and cannot correctly perform repeated merges from a branch that has had its history changed.</source>
          <target state="translated">돌아가서 이전 커밋을 수정할 수 있습니다. 이미 역사를 공개 한 경우에는이 작업을 수행해서는 안됩니다. Git은 일반적으로 프로젝트의 &quot;히스토리&quot;가 변경 될 것으로 예상하지 않으며 히스토리가 변경된 지점에서 반복 병합을 올바르게 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="427cec7db1c8d9c41ec669de64df63aacc49a26f" translate="yes" xml:space="preserve">
          <source>You can grow a new branch from any commit. For example, switch to &quot;HEAD~3&quot; and create branch &quot;fixup&quot;:</source>
          <target state="translated">모든 커밋에서 새 브랜치를 성장시킬 수 있습니다. 예를 들어 &quot;HEAD ~ 3&quot;으로 전환하고 &quot;fixup&quot;분기를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="8abddb96169bb94a7080d5c82ed5cac7b229954a" translate="yes" xml:space="preserve">
          <source>You can have a mixture of files show up as &quot;has been updated&quot; and &quot;is still dirty in the working directory&quot; together. You can always tell which file is in which state, since the &quot;has been updated&quot; ones show a valid sha1, and the &quot;not in sync with the index&quot; ones will always have the special all-zero sha1.</source>
          <target state="translated">&quot;업데이트되었습니다&quot;로 표시되고 &quot;작업 디렉토리에서 여전히 더럽습니다&quot;라는 파일 조합을 함께 표시 할 수 있습니다. &quot;갱신 된&quot;파일에는 유효한 sha1이 표시되고 &quot;인덱스와 동기화되지 않은&quot;파일에는 항상 모든 0의 특수 sha1이 있으므로 어떤 파일이 어떤 상태인지 항상 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae3f7bca446e950bd716349b25ee5d05aaee6a26" translate="yes" xml:space="preserve">
          <source>You can include a config file from another by setting the special &lt;code&gt;include.path&lt;/code&gt; (or &lt;code&gt;includeIf.*.path&lt;/code&gt;) variable to the name of the file to be included. The variable takes a pathname as its value, and is subject to tilde expansion. These variables can be given multiple times.</source>
          <target state="translated">특수 &lt;code&gt;include.path&lt;/code&gt; (또는 &lt;code&gt;includeIf.*.path&lt;/code&gt; ) 변수를 포함 할 파일 이름으로 설정하여 다른 구성 파일을 구성 파일에 포함시킬 수 있습니다. 변수는 경로 이름을 값으로 사용하며 물결표 확장이 적용됩니다. 이 변수들은 여러 번 주어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5145f6f36a43ec5e98537ca833d15e8282538fcf" translate="yes" xml:space="preserve">
          <source>You can include a config file from another conditionally by setting a &lt;code&gt;includeIf.&amp;lt;condition&amp;gt;.path&lt;/code&gt; variable to the name of the file to be included.</source>
          <target state="translated">&lt;code&gt;includeIf.&amp;lt;condition&amp;gt;.path&lt;/code&gt; 변수를 포함 할 파일 이름으로 설정하여 다른 조건부에서 구성 파일을 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="509dfc228243cbfccb732c55df31d8f926c42b85" translate="yes" xml:space="preserve">
          <source>You can include other configuration file using read_config_file() subroutine. For example, one might want to put gitweb configuration related to access control for viewing repositories via Gitolite (one of Git repository management tools) in a separate file, e.g. in &lt;code&gt;/etc/gitweb-gitolite.conf&lt;/code&gt;. To include it, put</source>
          <target state="translated">read_config_file () 서브 루틴을 사용하여 다른 구성 파일을 포함 할 수 있습니다. 예를 들어, Gitolite (Git 리포지토리 관리 도구 중 하나)를 통해 리포지토리를보기위한 액세스 제어와 관련된 gitweb 구성을 별도의 파일 (예 : &lt;code&gt;/etc/gitweb-gitolite.conf&lt;/code&gt; ) 에 넣을 수 있습니다. 포함하려면</target>
        </trans-unit>
        <trans-unit id="645452c6d997e8f480a9efb060142f580408b9f7" translate="yes" xml:space="preserve">
          <source>You can make a different change on the master branch:</source>
          <target state="translated">마스터 브랜치에서 다른 변경을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d56811ee77d2943d64ee7741c452578a4d84979" translate="yes" xml:space="preserve">
          <source>You can make interesting things happen to a repository every time you push into it, by setting up &lt;code&gt;hooks&lt;/code&gt; there. See documentation for &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;hooks&lt;/code&gt; 를 설정하여 저장소에 푸시 할 때마다 흥미로운 일을 저장소에 만들 수 있습니다 . &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="31caee42f233cd83de2778af5287eb406c23a1ef" translate="yes" xml:space="preserve">
          <source>You can make sure &lt;code&gt;git show-branch&lt;/code&gt; matches the state before those two &lt;code&gt;git merge&lt;/code&gt; you just did. Then, instead of running two &lt;code&gt;git merge&lt;/code&gt; commands in a row, you would merge these two branch heads (this is known as &lt;code&gt;making an Octopus&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;git show-branch&lt;/code&gt; 가 방금 한 두 &lt;code&gt;git merge&lt;/code&gt; 전에 상태와 일치 하는지 확인할 수 있습니다 . 그런 다음 두 개의 &lt;code&gt;git merge&lt;/code&gt; 명령을 연속 으로 실행하는 대신 이 두 가지 분기 헤드를 병합합니다 (이것은 &lt;code&gt;making an Octopus&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b0c1a53571be700b171dec8a7fa266ccfd88fbe8" translate="yes" xml:space="preserve">
          <source>You can make the appropriate change to your working tree, run &lt;code&gt;git add
&amp;lt;file&amp;gt;&lt;/code&gt; or &lt;code&gt;git rm &amp;lt;file&amp;gt;&lt;/code&gt;, as appropriate, to stage it, and then &lt;code&gt;git
commit --amend&lt;/code&gt;. Your change will be included in the commit, and you&amp;rsquo;ll be prompted to edit the commit message again; if you wish to use the original message verbatim, you can use the &lt;code&gt;--no-edit&lt;/code&gt; option to &lt;code&gt;git
commit&lt;/code&gt; in addition, or just save and quit when your editor opens.</source>
          <target state="translated">작업 트리를 적절하게 변경하고 &lt;code&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;git rm &amp;lt;file&amp;gt;&lt;/code&gt; 을 적절하게 실행하여 스테이징 한 다음 &lt;code&gt;git commit --amend&lt;/code&gt; . 변경 사항이 커밋에 포함되고 커밋 메시지를 다시 편집하라는 메시지가 표시됩니다. 원본 메시지를 그대로 사용하려면 &lt;code&gt;--no-edit&lt;/code&gt; 옵션을 사용하여 추가 로 &lt;code&gt;git commit&lt;/code&gt; 하거나 편집기가 열릴 때 저장하고 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f748b043bbe97de82ec4f7b6a5308c58b703d36" translate="yes" xml:space="preserve">
          <source>You can make the server use the end-of-line conversion attributes to set the &lt;code&gt;-k&lt;/code&gt; modes for files by setting the &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; config variable. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for more information about end-of-line conversion.</source>
          <target state="translated">&lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; 구성 변수를 설정하여 서버가 줄 끝 변환 속성을 사용하여 파일에 대한 &lt;code&gt;-k&lt;/code&gt; 모드 를 설정할 수 있습니다. 참조 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes을 [5]&lt;/a&gt; 끝 (end-of-line) 변환에 대한 자세한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="015443f769a79760c1933372fa244563a6a25aba" translate="yes" xml:space="preserve">
          <source>You can omit having to type return here, by setting the configuration variable &lt;code&gt;interactive.singleKey&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">구성 변수 &lt;code&gt;interactive.singleKey&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하여 여기에 return을 입력하지 않아도됩니다 .</target>
        </trans-unit>
        <trans-unit id="358c29af25eb707e9507c2c41ba2c41fddac22f4" translate="yes" xml:space="preserve">
          <source>You can override these rules either by command-line options or by environment variables. The &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--system&lt;/code&gt; and &lt;code&gt;--worktree&lt;/code&gt; options will limit the file used to the global, system-wide or per-worktree file respectively. The &lt;code&gt;GIT_CONFIG&lt;/code&gt; environment variable has a similar effect, but you can specify any filename you want.</source>
          <target state="translated">명령 행 옵션 또는 환경 변수로 이러한 규칙을 대체 할 수 있습니다. &lt;code&gt;--global&lt;/code&gt; 는 , &lt;code&gt;--system&lt;/code&gt; 및 &lt;code&gt;--worktree&lt;/code&gt; 옵션은 글로벌, 전체 시스템 또는 당 worktree 파일을 각각 사용되는 파일을 제한합니다. &lt;code&gt;GIT_CONFIG&lt;/code&gt; 의 환경 변수도 비슷한 효과를 가지고 있지만, 당신은 당신이 원하는 파일 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9256a8bfff0f4e1e2098927e9ff118ae66b3eab" translate="yes" xml:space="preserve">
          <source>You can perform &quot;git pull&quot;, resolve potential conflicts, and &quot;git push&quot; the result. A &quot;git pull&quot; will create a merge commit C between commits A and B.</source>
          <target state="translated">&quot;git pull&quot;을 수행하고 잠재적 충돌을 해결하고 결과를 &quot;git push&quot;할 수 있습니다. &quot;git pull&quot;은 커밋 A와 B 사이에 병합 커밋 C를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="189a9ed33e189223869b33620d09d0f720bf3fe1" translate="yes" xml:space="preserve">
          <source>You can provide options via the credential.helper configuration variable (this example drops the cache time to 5 minutes):</source>
          <target state="translated">credential.helper 구성 변수를 통해 옵션을 제공 할 수 있습니다 (이 예에서는 캐시 시간을 5 분으로 줄입니다).</target>
        </trans-unit>
        <trans-unit id="82656460f1d1171626ca7a2547e75d0458741fd5" translate="yes" xml:space="preserve">
          <source>You can query/set/replace/unset options with this command. The name is actually the section and the key separated by a dot, and the value will be escaped.</source>
          <target state="translated">이 명령으로 옵션을 쿼리 / 설정 / 바꾸기 / 설정 해제 할 수 있습니다. 이름은 실제로 섹션과 키로 점으로 구분되며 값은 이스케이프됩니다.</target>
        </trans-unit>
        <trans-unit id="10e463ee2669848fa9bb9fc90b4474d38bbf73be" translate="yes" xml:space="preserve">
          <source>You can rejoin two diverging branches of development using &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;:</source>
          <target state="translated">다음을 사용하여 개발의 두 분기 지점에 다시 가입 할 수 &lt;a href=&quot;git-merge&quot;&gt;자식 병합 [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3e4277417393477fbeb632e41395d74e0a0e4169" translate="yes" xml:space="preserve">
          <source>You can repack this private repository whenever you feel like.</source>
          <target state="translated">필요할 때마다이 개인 저장소를 다시 포장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3425cb44f3c2a0393cb24a6806cf1648e47fe578" translate="yes" xml:space="preserve">
          <source>You can repeat steps 2-4 multiple times to break the original code into any number of commits.</source>
          <target state="translated">2-4 단계를 여러 번 반복하여 원래 코드를 여러 커밋으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f016259f2ce9ae7193e573b7fa2135698ca39f54" translate="yes" xml:space="preserve">
          <source>You can rewrite the commit log messages using &lt;code&gt;--msg-filter&lt;/code&gt;. For example, &lt;code&gt;git svn-id&lt;/code&gt; strings in a repository created by &lt;code&gt;git svn&lt;/code&gt; can be removed this way:</source>
          <target state="translated">&lt;code&gt;--msg-filter&lt;/code&gt; 를 사용하여 커밋 로그 메시지를 다시 작성할 수 있습니다 . 예를 들어, &lt;code&gt;git svn-id&lt;/code&gt; 의해 생성 된 스트링 저장소 &lt;code&gt;git svn&lt;/code&gt; 이 방법으로 제거 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="6928e91b0b4a87a6f0188b338ec935fa803e932d" translate="yes" xml:space="preserve">
          <source>You can run &lt;code&gt;git-bundle verify&lt;/code&gt; to see if you can extract from a bundle that was created with a basis:</source>
          <target state="translated">&lt;code&gt;git-bundle verify&lt;/code&gt; 를 실행 하여 기본으로 작성된 번들에서 추출 할 수 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28f57e6715a38d45260ef8d226913fe9d5e46420" translate="yes" xml:space="preserve">
          <source>You can run &lt;code&gt;gitk --all&lt;/code&gt; again to see how the commit ancestry looks like, or run &lt;code&gt;show-branch&lt;/code&gt;, which tells you this.</source>
          <target state="translated">&lt;code&gt;gitk --all&lt;/code&gt; 을 다시 실행 하여 커밋 조상이 어떻게 보이는지 보거나 &lt;code&gt;show-branch&lt;/code&gt; 를 실행하여 이를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee22a2dcf21325c45ae74e5933824496ebc88dee" translate="yes" xml:space="preserve">
          <source>You can save space and make Git faster by moving these loose objects in to a &quot;pack file&quot;, which stores a group of objects in an efficient compressed format; the details of how pack files are formatted can be found in &lt;a href=&quot;pack-format&quot;&gt;pack format&lt;/a&gt;.</source>
          <target state="translated">이 느슨한 객체를 효율적인 압축 형식으로 객체 그룹을 저장하는 &quot;팩 파일&quot;로 이동하여 공간을 절약하고 Git을 더 빠르게 만들 수 있습니다. 팩 파일의 형식 지정 방법에 대한 자세한 내용은 &lt;a href=&quot;pack-format&quot;&gt;팩 형식&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="923ef556c5ea1d367a9ceb952e817561488d6f46" translate="yes" xml:space="preserve">
          <source>You can see easily that the above is a rename.</source>
          <target state="translated">위의 이름이 바뀌 었음을 쉽게 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5724c58e846fc905ad55d8bc9c332033225407c5" translate="yes" xml:space="preserve">
          <source>You can set this to &lt;code&gt;link&lt;/code&gt;, in which case a hardlink followed by a delete of the source are used to make sure that object creation will not overwrite existing objects.</source>
          <target state="translated">이것을 &lt;code&gt;link&lt;/code&gt; 로 설정할 수 있습니다.이 경우 소스를 삭제 한 후 하드 링크를 사용하여 객체 생성시 기존 객체를 덮어 쓰지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="02df8661fe031a54ab42701feedaa37cd7c87875" translate="yes" xml:space="preserve">
          <source>You can setup one single value (single entry/item in this list) at build time by setting the &lt;code&gt;GITWEB_BASE_URL&lt;/code&gt; build-time configuration variable. By default it is set to (), i.e. an empty list. This means that gitweb would not try to create project URL (to fetch) from project name.</source>
          <target state="translated">&lt;code&gt;GITWEB_BASE_URL&lt;/code&gt; 빌드 시간 구성 변수 를 설정하여 빌드시 하나의 단일 값 (이 목록의 단일 항목 / 항목)을 설정할 수 있습니다. 기본적으로 (), 즉 빈 목록으로 설정됩니다. 이것은 gitweb이 프로젝트 이름에서 프로젝트 URL을 가져 오려고 시도하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="af5fba33ca90f8278cecf2701efca5c8b71085ca" translate="yes" xml:space="preserve">
          <source>You can specify a list of allowed directories. If no directories are given, all are allowed. This is an additional restriction, gitcvs access still needs to be enabled by the &lt;code&gt;gitcvs.enabled&lt;/code&gt; config option unless &lt;code&gt;--export-all&lt;/code&gt; was given, too.</source>
          <target state="translated">허용 된 디렉토리 목록을 지정할 수 있습니다. 디렉토리가 제공되지 않으면 모두 허용됩니다. 이것은 추가적인 제한 사항입니다. &lt;code&gt;--export-all&lt;/code&gt; 을 지정 하지 않은 경우 gitcvs 액세스를 &lt;code&gt;gitcvs.enabled&lt;/code&gt; 구성 옵션 으로 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a2f1a86c57fcd513fcca4d9c2bf5f81069f36bf3" translate="yes" xml:space="preserve">
          <source>You can specify extra mail header lines to be added to each message, defaults for the subject prefix and file suffix, number patches when outputting more than one patch, add &quot;To:&quot; or &quot;Cc:&quot; headers, configure attachments, change the patch output directory, and sign off patches with configuration variables.</source>
          <target state="translated">각 메일에 추가 할 추가 메일 헤더 행, 제목 접두사 및 파일 접미사에 대한 기본값, 둘 이상의 패치를 출력 할 때의 패치 수, &quot;To :&quot;또는 &quot;Cc :&quot;헤더 추가, 첨부 파일 구성, 패치 변경 출력 디렉토리 및 구성 변수로 패치를 사인 오프하십시오.</target>
        </trans-unit>
        <trans-unit id="c33dd2cd2261f81cbd0fc492df4e16b1e747c25d" translate="yes" xml:space="preserve">
          <source>You can specify the information shown for each object by using a custom &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt;. The &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; is copied literally to stdout for each object, with placeholders of the form &lt;code&gt;%(atom)&lt;/code&gt; expanded, followed by a newline. The available atoms are:</source>
          <target state="translated">사용자 정의 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 을 사용하여 각 오브젝트에 대해 표시되는 정보를 지정할 수 있습니다 . &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 폼의 자리에, 각 개체에 대한 표준 출력에 그대로 복사된다 &lt;code&gt;%(atom)&lt;/code&gt; 개행 뒤에 확장. 사용 가능한 원자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="50f1e86bfea2179ec0dc9556f31c0b7322253687" translate="yes" xml:space="preserve">
          <source>You can store the files in the repository with Unix line endings and convert them automatically to your platform&amp;rsquo;s line endings. To do that, set the configuration option &lt;code&gt;core.eol&lt;/code&gt; to &lt;code&gt;native&lt;/code&gt; and see the following entry for information about how to configure files as text or binary.</source>
          <target state="translated">Unix 줄 끝을 사용하여 저장소에 파일을 저장하고 자동으로 플랫폼의 줄 끝으로 변환 할 수 있습니다. 이를 수행하려면 &lt;code&gt;core.eol&lt;/code&gt; 구성 옵션 을 &lt;code&gt;native&lt;/code&gt; 으로 설정하고 파일을 텍스트 또는 바이너리로 구성하는 방법에 대한 정보는 다음 항목을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5a94d83b2aa4f52ca10b82e1786cdc28d9f55e56" translate="yes" xml:space="preserve">
          <source>You can tell Git to ignore certain files by creating a file called &lt;code&gt;.gitignore&lt;/code&gt; in the top level of your working directory, with contents such as:</source>
          <target state="translated">작업 디렉토리의 최상위 레벨에 다음과 같은 내용으로 &lt;code&gt;.gitignore&lt;/code&gt; 라는 파일을 작성하여 Git에게 특정 파일을 무시하도록 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="491f06c247008ffc2db5fcd9f930c35d5e25a466" translate="yes" xml:space="preserve">
          <source>You can tell Git to split the Git internal information from the directory that it tracks, but we&amp;rsquo;ll ignore that for now: it&amp;rsquo;s not how normal projects work, and it&amp;rsquo;s really only meant for special uses. So the mental model of &quot;the Git information is always tied directly to the working tree that it describes&quot; may not be technically 100% accurate, but it&amp;rsquo;s a good model for all normal use.</source>
          <target state="translated">Git에게 추적하는 디렉토리에서 Git 내부 정보를 분리하도록 지시 할 수 있지만 현재로서는 무시할 것입니다. 일반적인 프로젝트의 작동 방식이 아니며 실제로는 특수 용도로만 사용됩니다. 따라서 &quot;Git 정보는 항상 작업 트리에 직접 연결되어 있습니다&quot;라는 정신적 모델은 기술적으로 100 % 정확하지는 않지만 모든 정상적인 사용에 적합한 모델입니다.</target>
        </trans-unit>
        <trans-unit id="eba2ddb51d288f0b3a9988b4f1ccbdcde132a1f4" translate="yes" xml:space="preserve">
          <source>You can test whether the filesystem supports that with the &lt;code&gt;--test-untracked-cache&lt;/code&gt; option. The &lt;code&gt;--untracked-cache&lt;/code&gt; option used to implicitly perform that test in older versions of Git, but that&amp;rsquo;s no longer the case.</source>
          <target state="translated">&lt;code&gt;--test-untracked-cache&lt;/code&gt; 옵션 을 사용하여 파일 시스템이이를 지원하는지 테스트 할 수 있습니다 . &lt;code&gt;--untracked-cache&lt;/code&gt; 암시 적으로 사용되는 옵션은 망할 놈의 이전 버전에서이 테스트를 수행하지 않습니다, 그러나 그것은 더 이상 사건.</target>
        </trans-unit>
        <trans-unit id="33337304817f97abbb584fa2c7541a14abb9bfcd" translate="yes" xml:space="preserve">
          <source>You can then fix the conflicts during the rebase. Presumably you have not published your topic other than by mail, so rebasing it is not a problem.</source>
          <target state="translated">그런 다음 리베이스 중에 충돌을 해결할 수 있습니다. 아마 당신은 우편이 아닌 다른 주제를 출판하지 않았기 때문에 문제를 해결하는 것은 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6b74e3d43432e56c49f83bf0e8c1bc1b7ac50b8" translate="yes" xml:space="preserve">
          <source>You can then import these into your mail client and send them by hand. However, if you have a lot to send at once, you may prefer to use the &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt; script to automate the process. Consult the mailing list for your project first to determine their requirements for submitting patches.</source>
          <target state="translated">그런 다음 메일 클라이언트로 가져 와서 직접 보낼 수 있습니다. 그러나 한 번에 보낼 것이 많으면 &lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt; 스크립트를 사용하여 프로세스를 자동화하는 것이 좋습니다. 패치 제출 요구 사항을 확인하려면 먼저 프로젝트의 메일 링리스트를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ad2194dc994cc556c2451e6a9d4c256f90b5afd4" translate="yes" xml:space="preserve">
          <source>You can then transplant the old &lt;code&gt;subsystem..topic&lt;/code&gt; to the new tip by saying (for the reflog case, and assuming you are on &lt;code&gt;topic&lt;/code&gt; already):</source>
          <target state="translated">그런 다음 (reflog 사례의 경우 이미 &lt;code&gt;topic&lt;/code&gt; 에 있다고 가정) 이전 &lt;code&gt;subsystem..topic&lt;/code&gt; ..topic을 새 팁에 이식 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5bb69809c9820257d5f27c5ec379a4130c453d8" translate="yes" xml:space="preserve">
          <source>You can think of this as a set operation. Commits given on the command line form a set of commits that are reachable from any of them, and then commits reachable from any of the ones given with &lt;code&gt;^&lt;/code&gt; in front are subtracted from that set. The remaining commits are what comes out in the command&amp;rsquo;s output. Various other options and paths parameters can be used to further limit the result.</source>
          <target state="translated">이것을 설정된 작업으로 생각할 수 있습니다. 커맨드 라인에 주어진 커밋은 커밋 세트 중 하나에서 도달 할 수 있으며, 앞에 &lt;code&gt;^&lt;/code&gt; 로 주어진 커밋에서 커밋 할 수있는 커밋 은 해당 세트에서 뺍니다. 나머지 커밋은 명령의 출력에서 ​​나오는 것입니다. 다양한 다른 옵션 및 경로 매개 변수를 사용하여 결과를 더 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="497fe81f829587b397446cebabae5d6848f111c9" translate="yes" xml:space="preserve">
          <source>You can think of this as a set operation. Commits reachable from any of the commits given on the command line form a set, and then commits reachable from any of the ones given with &lt;code&gt;^&lt;/code&gt; in front are subtracted from that set. The remaining commits are what comes out in the command&amp;rsquo;s output. Various other options and paths parameters can be used to further limit the result.</source>
          <target state="translated">이것을 세트 작업으로 생각할 수 있습니다. 명령 줄에 지정된 커밋 중 하나에서 도달 할 수있는 커밋이 집합을 형성 한 다음 &lt;code&gt;^&lt;/code&gt; 가 앞에있는 커밋 중 하나에서 도달 할 수있는 커밋 이 해당 집합에서 뺍니다. 나머지 커밋은 명령의 출력에 나오는 것입니다. 다양한 기타 옵션 및 경로 매개 변수를 사용하여 결과를 추가로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eacfd2b96f144de251fd3721b44d6ad9ca988b86" translate="yes" xml:space="preserve">
          <source>You can try running &lt;code&gt;find .git/objects -type f&lt;/code&gt; before and after you run &lt;code&gt;git prune-packed&lt;/code&gt; if you are curious. Also &lt;code&gt;git
count-objects&lt;/code&gt; would tell you how many unpacked objects are in your repository and how much space they are consuming.</source>
          <target state="translated">궁금하다면 &lt;code&gt;git prune-packed&lt;/code&gt; 를 실행하기 전후에 &lt;code&gt;find .git/objects -type f&lt;/code&gt; 를 실행 해보 십시오 . 또한 &lt;code&gt;git count-objects&lt;/code&gt; 는 리포지토리에 압축 해제 된 객체의 수와 사용중인 공간의 양을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="78c0fba98badb6e25ce1949ee53cb8839b8be51a" translate="yes" xml:space="preserve">
          <source>You can update the shared repository with your changes by first committing your changes, and then using the &lt;code&gt;git push&lt;/code&gt; command:</source>
          <target state="translated">먼저 변경 사항을 커밋 한 다음 &lt;code&gt;git push&lt;/code&gt; 명령 을 사용하여 변경 내용으로 공유 리포지토리를 업데이트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe24364fca4da5268b93a1c7c864762589bec5d4" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; to examine the contents of a blob; take, for example, the blob in the entry for &lt;code&gt;COPYING&lt;/code&gt; from the tree above:</source>
          <target state="translated">&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; 을 사용하여 blob의 내용을 검사 할 수 있습니다 . 예를 들어 위의 트리에서 &lt;code&gt;COPYING&lt;/code&gt; 항목의 얼룩을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cdee252fbf6b663369bb36f7a81711483c778043" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;git stash push --keep-index&lt;/code&gt; when you want to make two or more commits out of the changes in the work tree, and you want to test each change before committing:</source>
          <target state="translated">당신이 사용할 수있는 &lt;code&gt;git stash push --keep-index&lt;/code&gt; 사용하면 작업 트리의 변화에서 두 개 이상의 커밋을 할 때, 당신은 커밋하기 전에 각 변경 사항을 테스트하려면 :</target>
        </trans-unit>
        <trans-unit id="b954fc6ff3f193031cbeca4547760f3425491805" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;git stash&lt;/code&gt; to simplify the above, like this:</source>
          <target state="translated">&lt;code&gt;git stash&lt;/code&gt; 를 사용하여 위와 같이 단순화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c482710749f3dcad6cbdc9701b2eb8b0d7f62e6a" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;stable-1&lt;/code&gt; to refer to the commit 1b2e1d63ff.</source>
          <target state="translated">steady &lt;code&gt;stable-1&lt;/code&gt; 을 사용하여 커밋 1b2e1d63ff를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="783e49ef6897108ce62c504df5bb1071160ba897" translate="yes" xml:space="preserve">
          <source>You can use a basis based on time:</source>
          <target state="translated">시간을 기준으로 기준을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dcaab83279bcfe9c2e3dbaa6b4f0d035029ab31" translate="yes" xml:space="preserve">
          <source>You can use a tag that is present in both:</source>
          <target state="translated">두 가지 모두에있는 태그를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0967772702daca79ec55cd9be52c70fe75848751" translate="yes" xml:space="preserve">
          <source>You can use different &lt;code&gt;&amp;lt;action&amp;gt;&lt;/code&gt; values to control this behavior:</source>
          <target state="translated">다른 &lt;code&gt;&amp;lt;action&amp;gt;&lt;/code&gt; 값을 사용하여이 동작을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72733e82f897a2af21fcfc3df3447e66ece75165" translate="yes" xml:space="preserve">
          <source>You can use it as a human-readable bundle replacement (see &lt;a href=&quot;git-bundle&quot;&gt;git-bundle[1]&lt;/a&gt;), or as a format that can be edited before being fed to &lt;code&gt;git fast-import&lt;/code&gt; in order to do history rewrites (an ability relied on by tools like &lt;code&gt;git filter-repo&lt;/code&gt;).</source>
          <target state="translated">사람이 읽을 수있는 번들 대체 ( &lt;a href=&quot;git-bundle&quot;&gt;git-bundle [1]&lt;/a&gt; 참조) 또는 히스토리 다시 쓰기 (도구에 의존하는 기능)를 위해 &lt;code&gt;git fast-import&lt;/code&gt; 로 공급되기 전에 편집 할 수있는 형식으로 사용할 수 있습니다. &lt;code&gt;git filter-repo&lt;/code&gt; 와 같은 ).</target>
        </trans-unit>
        <trans-unit id="6b34e82e0ff80209e7866272f371ddd1420b0f13" translate="yes" xml:space="preserve">
          <source>You can use mod_perl with gitweb. You must install Apache::Registry (for mod_perl 1.x) or ModPerl::Registry (for mod_perl 2.x) to enable this support.</source>
          <target state="translated">gitweb과 함께 mod_perl을 사용할 수 있습니다. 이 지원을 사용하려면 Apache :: Registry (mod_perl 1.x) 또는 ModPerl :: Registry (mod_perl 2.x)를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="625924bfa2e6c050ea9730ca7a0edb6cfce2bfdc" translate="yes" xml:space="preserve">
          <source>You can use notes to add annotations with information that was not available at the time a commit was written.</source>
          <target state="translated">메모를 사용하여 커밋이 작성 될 때 사용할 수 없었던 정보가 포함 된 주석을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bbbcd5b5890880e82d452d584e7cf77013dabac" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@&lt;/code&gt; construct with an empty ref part to get at a reflog entry of the current branch. For example, if you are on branch &lt;code&gt;blabla&lt;/code&gt; then &lt;code&gt;@{1}&lt;/code&gt; means the same as &lt;code&gt;blabla@{1}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; 참조를 빈 참조 부분과 함께 사용 하면 현재 분기의 참조 로그 항목을 얻을 수 있습니다. 당신이 지점에있는 경우 예를 들어, &lt;code&gt;blabla&lt;/code&gt; 다음 &lt;code&gt;@{1}&lt;/code&gt; 과 같은 의미 &lt;code&gt;blabla@{1}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd3a4b2dd2cada66b7023aa9fae3c933422c9fcc" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@{-N}&lt;/code&gt; syntax to refer to the N-th last branch/commit checked out using &quot;git checkout&quot; operation. You may also specify &lt;code&gt;-&lt;/code&gt; which is synonymous to &lt;code&gt;@{-1}&lt;/code&gt;.</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;code&gt;@{-N}&lt;/code&gt; N 번째 마지막 지점을 참조하는 구문을 / &quot;자식 체크 아웃&quot;작업을 사용하여 체크 아웃 커밋. 당신은 또한 지정할 수 있습니다 &lt;code&gt;-&lt;/code&gt; 동의어이다 &lt;code&gt;@{-1}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e21f11f93a4b8bdb963de3cd700b58b5db33242a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@{-N}&lt;/code&gt; syntax to refer to the N-th last branch/commit switched to using &quot;git switch&quot; or &quot;git checkout&quot; operation. You may also specify &lt;code&gt;-&lt;/code&gt; which is synonymous to &lt;code&gt;@{-1}&lt;/code&gt;. This is often used to switch quickly between two branches, or to undo a branch switch by mistake.</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;code&gt;@{-N}&lt;/code&gt; N 번째 마지막 지점을 참조하는 구문을 / &quot;자식 스위치&quot;또는 &quot;자식 체크 아웃&quot;작업을 사용하여 전환 커밋. 당신은 또한 지정할 수 있습니다 &lt;code&gt;-&lt;/code&gt; 동의어이다 &lt;code&gt;@{-1}&lt;/code&gt; . 이것은 종종 두 분기 사이를 빠르게 전환하거나 실수로 분기 스위치를 실행 취소하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="736fc09a09a7b16017fd49ac75e258e953294134" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;gitweb.owner&lt;/code&gt; repository configuration variable to set repository&amp;rsquo;s owner. It is displayed in the project list and summary page.</source>
          <target state="translated">&lt;code&gt;gitweb.owner&lt;/code&gt; 저장소 구성 변수를 사용하여 저장소의 소유자를 설정할 수 있습니다 . 프로젝트 목록 및 요약 페이지에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b3762dc0cf78ebbd7cf935ac045ade59a2e3acbf" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;htpasswd&lt;/code&gt; facility that comes with Apache to make these files, but Apache&amp;rsquo;s MD5 crypt method differs from the one used by most C library&amp;rsquo;s crypt() function, so don&amp;rsquo;t use the -m option.</source>
          <target state="translated">Apache와 함께 제공 되는 &lt;code&gt;htpasswd&lt;/code&gt; 기능을 사용하여 이러한 파일을 만들 수 있지만 Apache의 MD5 암호화 방법은 대부분의 C 라이브러리의 crypt () 함수에서 사용하는 방법과 다르므로 -m 옵션을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="80aa1363be3995d4ec384e59561a0e7a0903c070" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;map&lt;/code&gt; convenience function in this filter, and other convenience functions, too. For example, calling &lt;code&gt;skip_commit &quot;$@&quot;&lt;/code&gt; will leave out the current commit (but not its changes! If you want that, use &lt;code&gt;git rebase&lt;/code&gt; instead).</source>
          <target state="translated">당신이 사용할 수있는 &lt;code&gt;map&lt;/code&gt; 도이 필터 및 기타 편의 기능에 편리한 기능입니다. 예를 들어, &lt;code&gt;skip_commit &quot;$@&quot;&lt;/code&gt; 호출 하면 현재 커밋이 생략됩니다 (그러나 변경 사항은 아닙니다! 원하는 경우 대신 &lt;code&gt;git rebase&lt;/code&gt; 를 사용하십시오).</target>
        </trans-unit>
        <trans-unit id="c32abff787b36e9c877031d224291d8c643f61f1" translate="yes" xml:space="preserve">
          <source>You can use the following files in repository:</source>
          <target state="translated">저장소에서 다음 파일을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6c6eac74692734c5ec1dc3c689d37b0eb0dcea6" translate="yes" xml:space="preserve">
          <source>You can use the number of commits:</source>
          <target state="translated">커밋 수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a928f707b340dd3df65a93fa7f9942c5a65d9b2" translate="yes" xml:space="preserve">
          <source>You can very easily automatically bisect broken builds using something like:</source>
          <target state="translated">다음과 같은 방법으로 깨진 빌드를 매우 쉽게 자동으로 이등분 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77487b0c89edd8fd842e99d65a1b39d2c6b378f5" translate="yes" xml:space="preserve">
          <source>You can work through the conflict with a number of tools:</source>
          <target state="translated">여러 도구와의 충돌을 통해 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="918d78d55a9c451b1a86101242b3194591c9e6cc" translate="yes" xml:space="preserve">
          <source>You can write the mandatory option parameter to an option as a separate word on the command line. That means that all the following uses work:</source>
          <target state="translated">명령 행에서 별도의 단어로 옵션에 필수 옵션 매개 변수를 쓸 수 있습니다. 이는 다음의 모든 용도가 작동 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="03d917937bc98856220155e739ac2f8752cca599" translate="yes" xml:space="preserve">
          <source>You can write your own custom helpers to interface with any system in which you keep credentials.</source>
          <target state="translated">사용자 지정 도우미를 작성하여 자격 증명을 유지하는 모든 시스템과 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7f91f3a076bca347349424f4008dca0a1518c15" translate="yes" xml:space="preserve">
          <source>You can write your own custom helpers to interface with any system in which you keep credentials. See credential.h for details.</source>
          <target state="translated">자격 증명을 유지하는 모든 시스템과 인터페이스 할 사용자 지정 도우미를 작성할 수 있습니다. 자세한 내용은 credential.h를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c06b90a2f16de670e5df5d7464445ae0f28559f2" translate="yes" xml:space="preserve">
          <source>You could be using the &lt;code&gt;objects/info/alternates&lt;/code&gt; or &lt;code&gt;$GIT_ALTERNATE_OBJECT_DIRECTORIES&lt;/code&gt; mechanisms to &lt;code&gt;borrow&lt;/code&gt; objects from other object stores. A repository with this kind of incomplete object store is not suitable to be published for use with dumb transports but otherwise is OK as long as &lt;code&gt;objects/info/alternates&lt;/code&gt; points at the object stores it borrows from.</source>
          <target state="translated">당신은 사용이 될 수 &lt;code&gt;objects/info/alternates&lt;/code&gt; 또는 &lt;code&gt;$GIT_ALTERNATE_OBJECT_DIRECTORIES&lt;/code&gt; 할 수있는 메커니즘을 &lt;code&gt;borrow&lt;/code&gt; 다른 물체 매장에서 오브젝트를. 이러한 종류의 불완전한 객체 저장소가있는 저장소는 벙 어링 전송에 사용하기에 공개하기에 적합하지 않지만 객체 저장소에서 &lt;code&gt;objects/info/alternates&lt;/code&gt; 포인트가 차용하는 한 괜찮 습니다.</target>
        </trans-unit>
        <trans-unit id="e2e5ecc00e320fd7f95c1d7def9e5cd07e7e5d74" translate="yes" xml:space="preserve">
          <source>You could do without using any branches at all, by keeping as many local repositories as you would like to have branches, and merging between them with &lt;em&gt;git pull&lt;/em&gt;, just like you merge between branches. The advantage of this approach is that it lets you keep a set of files for each &lt;code&gt;branch&lt;/code&gt; checked out and you may find it easier to switch back and forth if you juggle multiple lines of development simultaneously. Of course, you will pay the price of more disk usage to hold multiple working trees, but disk space is cheap these days.</source>
          <target state="translated">브랜치를 가지고있는 것처럼 많은 로컬 리포지토리를 유지하고 브랜치간에 병합하는 것처럼 &lt;em&gt;git pull으로&lt;/em&gt; 병합하여 브랜치를 전혀 사용하지 않아도됩니다 . 이 방법의 장점은 각 &lt;code&gt;branch&lt;/code&gt; 에 대해 파일 세트를 체크 아웃 할 수 있으며 여러 개발 라인을 동시에 저글링하는 경우 더 쉽게 전환 할 수 있다는 것입니다. 물론 여러 작업 트리를 보유하기 위해 더 많은 디스크 사용량을 지불해야하지만 요즘에는 디스크 공간이 저렴합니다.</target>
        </trans-unit>
        <trans-unit id="8ff03510fc9dfa2f41199478909f4845fc0f0bb6" translate="yes" xml:space="preserve">
          <source>You could have an incomplete but locally usable repository by creating a shallow clone. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;.</source>
          <target state="translated">얕은 클론을 생성하여 불완전하지만 로컬에서 사용할 수있는 저장소를 가질 수 있습니다. &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f736fa76fc678c4f130db13f45faf6b48f41687a" translate="yes" xml:space="preserve">
          <source>You could just visually inspect the commits since e05db0fd:</source>
          <target state="translated">e05db0fd 이후 커밋을 시각적으로 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d78b2a8d8354041e789d882f2348db69275bdcd" translate="yes" xml:space="preserve">
          <source>You could omit &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;, in which case the command degenerates to &quot;check out the current branch&quot;, which is a glorified no-op with rather expensive side-effects to show only the tracking information, if exists, for the current branch.</source>
          <target state="translated">&lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 를 생략 할 수 있습니다 .이 경우 명령이 &quot;현재 분기를 체크 아웃&quot;하도록 퇴화됩니다.이 분기는 현재 분기에 대한 추적 정보 만있는 경우 비용이 많이 드는 부작용이없는 영광스러운 no-op입니다.</target>
        </trans-unit>
        <trans-unit id="7c5b22847ee058ce78c26cbc63e773fbbc9499cd" translate="yes" xml:space="preserve">
          <source>You create a commit object by giving it the tree that describes the state at the time of the commit, and a list of parents:</source>
          <target state="translated">커밋 객체는 커밋 시점의 상태를 설명하는 트리와 부모 목록을 제공하여 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0fca09140e6ecd8df23b487785db8ea6f6692c80" translate="yes" xml:space="preserve">
          <source>You do not want any end-of-line conversions applied to, nor textual diffs produced for, any binary file you track. You would need to specify e.g.</source>
          <target state="translated">추적하는 이진 파일에 줄 끝 변환을 적용하거나 텍스트 차이를 만들지 않습니다. 당신은 예를 들어 지정해야합니다</target>
        </trans-unit>
        <trans-unit id="3b6ec2c54535f15330b4b3b431cf4481da43a55b" translate="yes" xml:space="preserve">
          <source>You do random edits, without running &lt;code&gt;git update-index&lt;/code&gt;. And then you notice that the tip of your &quot;upstream&quot; tree has advanced since you pulled from him:</source>
          <target state="translated">&lt;code&gt;git update-index&lt;/code&gt; 를 실행하지 않고 무작위 편집을 수행 합니다. 그리고 나서 &quot;상류&quot;트리의 끝이 당신이 그를 뽑아 낸 이후로 진행되었음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96b7f9c5e1f885ad6155a2dabe0351e9e08cd246" translate="yes" xml:space="preserve">
          <source>You do your real work in your working tree that has your primary repository hanging under it as its &lt;code&gt;.git&lt;/code&gt; subdirectory. You &lt;strong&gt;could&lt;/strong&gt; make that repository accessible remotely and ask people to pull from it, but in practice that is not the way things are usually done. A recommended way is to have a public repository, make it reachable by other people, and when the changes you made in your primary working tree are in good shape, update the public repository from it. This is often called &lt;code&gt;pushing&lt;/code&gt;.</source>
          <target state="translated">기본 저장소가 &lt;code&gt;.git&lt;/code&gt; 하위 디렉토리 로 매달려있는 작업 트리에서 실제 작업을 수행합니다 . 당신은 &lt;strong&gt;할 수&lt;/strong&gt; 원격으로 저장소에 접근을하고 그것에서 풀에 사람을 물어하지만, 실제로 일을 주로 수행하는 방법이 아니다 그. 권장되는 방법은 공용 저장소를 갖고 다른 사람들이 접근 할 수있게하고 기본 작업 트리에서 변경 한 내용이 올바른 경우 공용 저장소를 업데이트하는 것입니다. 이것을 종종 &lt;code&gt;pushing&lt;/code&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="0911499c26fd93762ba87b20e89843bed2558fd8" translate="yes" xml:space="preserve">
          <source>You have made some commits, but realize they were premature to be in the &lt;code&gt;master&lt;/code&gt; branch. You want to continue polishing them in a topic branch, so create &lt;code&gt;topic/wip&lt;/code&gt; branch off of the current &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">커밋을했지만 &lt;code&gt;master&lt;/code&gt; 브랜치 에 조기에 참여했음을 알 수 있습니다 . 토픽 브랜치에서 계속 연마하고 싶기 때문에 현재 &lt;code&gt;HEAD&lt;/code&gt; 에서 &lt;code&gt;topic/wip&lt;/code&gt; 브랜치를 생성 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9321ccbae87a4bc4f97065bb17cb67a1a81520be" translate="yes" xml:space="preserve">
          <source>You have now created your first Git repository. Of course, since it&amp;rsquo;s empty, that&amp;rsquo;s not very useful, so let&amp;rsquo;s start populating it with data.</source>
          <target state="translated">이제 첫 번째 Git 저장소를 작성했습니다. 물론 비어 있기 때문에 그다지 유용하지 않으므로 데이터로 채우기를 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="d177c25ea329a8110bbd819e0cb66c6b6619b0d7" translate="yes" xml:space="preserve">
          <source>You have now successfully copied somebody else&amp;rsquo;s (mine) remote repository, and checked it out.</source>
          <target state="translated">이제 다른 사람의 (마인) 원격 저장소를 성공적으로 복사하고 체크 아웃했습니다.</target>
        </trans-unit>
        <trans-unit id="3cc6b09871d23a7d903d56d9d6eb61d9c29d1dd4" translate="yes" xml:space="preserve">
          <source>You have performed no merges into mywork, so it is just a simple linear sequence of patches on top of &lt;code&gt;origin&lt;/code&gt;:</source>
          <target state="translated">그 위에 패치의 순서 선형 단순한, 그래서 당신은 MYWORK에 더 병합을 수행하지 않은 &lt;code&gt;origin&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2f8744f866557cd48a608818edcb46f21bfb3d75" translate="yes" xml:space="preserve">
          <source>You have to run &lt;code&gt;git submodule update&lt;/code&gt; after &lt;code&gt;git pull&lt;/code&gt; if you want to update submodules, too.</source>
          <target state="translated">&lt;code&gt;git submodule update&lt;/code&gt; 하려면 &lt;code&gt;git pull&lt;/code&gt; 후에 git 하위 모듈 업데이트 를 실행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f82b6e7678c4aeade044d41684916154b148e08d" translate="yes" xml:space="preserve">
          <source>You haven&amp;rsquo;t specified any nodes as heads so it won&amp;rsquo;t be possible to differentiate between un-parented commits and root nodes.</source>
          <target state="translated">노드를 헤드로 지정하지 않았으므로 부모없는 커밋과 루트 노드를 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="60617aeef2563268db523c5fdc5a619452e83d26" translate="yes" xml:space="preserve">
          <source>You may also add new content that does not exist in the patch; simply add new lines, each starting with &quot;+&quot;. The addition will appear reverted in the working tree.</source>
          <target state="translated">패치에 존재하지 않는 새 컨텐츠를 추가 할 수도 있습니다. 각각 &quot;+&quot;로 시작하는 새로운 줄을 추가하면됩니다. 작업 트리에서 추가 된 내용이 되돌려 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ef502914f7e8ab4571571ef4343614d654bb655c" translate="yes" xml:space="preserve">
          <source>You may also have third-party helpers installed; search for &lt;code&gt;credential-*&lt;/code&gt; in the output of &lt;code&gt;git help -a&lt;/code&gt;, and consult the documentation of individual helpers. Once you have selected a helper, you can tell Git to use it by putting its name into the credential.helper variable.</source>
          <target state="translated">타사 도우미가 설치되어있을 수도 있습니다. &lt;code&gt;git help -a&lt;/code&gt; 출력에서 &lt;code&gt;credential-*&lt;/code&gt; 를 검색하고 개별 헬퍼의 문서를 참조하십시오. 헬퍼를 선택하면 Git에게 credential.helper 변수에 이름을 넣어서 사용하도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2298abd2d14c4384844acf0edbfaf0baea1ecae" translate="yes" xml:space="preserve">
          <source>You may also include a &lt;code&gt;!&lt;/code&gt; in front of the ref name to negate the entry, explicitly exposing it, even if an earlier entry marked it as hidden. If you have multiple hideRefs values, later entries override earlier ones (and entries in more-specific config files override less-specific ones).</source>
          <target state="translated">당신은 또한 포함 할 수 있습니다 &lt;code&gt;!&lt;/code&gt; ref 이름 앞에는 항목을 무효화하고 이전 항목이 숨겨진 것으로 표시 되더라도 명시 적으로 노출합니다. hideRefs 값이 여러 개인 경우 이후 항목은 이전 항목보다 우선합니다 (보다 구체적인 구성 파일의 항목은 덜 구체적인 값보다 우선 함).</target>
        </trans-unit>
        <trans-unit id="ea31f49a09c0b721c12c5805f99a1757f98a096f" translate="yes" xml:space="preserve">
          <source>You may also use &lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool[1]&lt;/a&gt;, which lets you merge the unmerged files using external tools such as Emacs or kdiff3.</source>
          <target state="translated">당신은 또한 사용할 수 있습니다 &lt;a href=&quot;git-mergetool&quot;&gt;자식 - mergetool [1]&lt;/a&gt; 당신이 이맥스 나 kdiff3과 같은 외부 도구를 사용하여 병합되지 않은 파일을 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9adc4f69fd1939534db6a41ec486285df53ebd63" translate="yes" xml:space="preserve">
          <source>You may execute several commands by either using one instance of &lt;code&gt;--exec&lt;/code&gt; with several commands:</source>
          <target state="translated">여러 개의 명령 과 함께 하나의 &lt;code&gt;--exec&lt;/code&gt; 인스턴스를 사용하여 여러 명령을 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a70c5e0fed390964e6d887a35161883ab1754024" translate="yes" xml:space="preserve">
          <source>You may find this helpful after reverting a topic branch merge, as this option recreates the topic branch with fresh commits so it can be remerged successfully without needing to &quot;revert the reversion&quot; (see the &lt;a href=&quot;https://git-scm.com/docs/howto/revert-a-faulty-merge&quot;&gt;revert-a-faulty-merge How-To&lt;/a&gt; for details).</source>
          <target state="translated">이 옵션은 신선한 커밋과 주제 분기를 재현으로는 &quot;복귀를 되돌릴&quot;할 필요없이 성공적으로 remerged 할 수 있도록, 주제 지점 병합을 되 돌린 후이 도움을 찾을 수 있습니다합니다 (참조 &lt;a href=&quot;https://git-scm.com/docs/howto/revert-a-faulty-merge&quot;&gt;되돌리기-A-결함이 병합 작업 방법&lt;/a&gt; 에 대한을 세부).</target>
        </trans-unit>
        <trans-unit id="08631c52a6efa8d7c45c6edcb816f877829615bc" translate="yes" xml:space="preserve">
          <source>You may force &lt;code&gt;git push&lt;/code&gt; to perform the update anyway by preceding the branch name with a plus sign:</source>
          <target state="translated">분기 이름 앞에 더하기 부호를 붙여서 &lt;code&gt;git push&lt;/code&gt; 가 강제로 업데이트를 수행하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae2bd0ef4c886d9dfce1ee8146a7755d847ffcc2" translate="yes" xml:space="preserve">
          <source>You may often find that during a bisect session you want to have temporary modifications (e.g. s/#define DEBUG 0/#define DEBUG 1/ in a header file, or &quot;revision that does not have this commit needs this patch applied to work around another problem this bisection is not interested in&quot;) applied to the revision being tested.</source>
          <target state="translated">bisect 세션 동안 헤더 파일의 s / # define DEBUG 0 / # define DEBUG 1 / 또는 &quot;이 커밋이없는 수정본에는이 패치가 필요합니다. 이 양분에 관심이없는 또 다른 문제 &quot;) 테스트 할 개정에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="014dba50ebab24a63a38baad57ed8364492c1d37" translate="yes" xml:space="preserve">
          <source>You may override individual configuration parameters when running any git command by using the &lt;code&gt;-c&lt;/code&gt; option. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;-c&lt;/code&gt; 옵션 을 사용하여 git 명령을 실행할 때 개별 구성 매개 변수를 대체 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ac5fdcda86efd0f875c444e1e9c4b64fbcccd8a8" translate="yes" xml:space="preserve">
          <source>You may specify configuration in your .git/config</source>
          <target state="translated">.git / config에서 구성을 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="13fb0fac683620e44c1d9b40bc74efe99d0db2f0" translate="yes" xml:space="preserve">
          <source>You may still choose to publish branches whose history is rewritten, and it may be useful for others to be able to fetch those branches in order to examine or test them, but they should not attempt to pull such branches into their own work.</source>
          <target state="translated">여전히 히스토리가 재 작성된 브랜치를 공개하도록 선택할 수 있으며, 다른 브랜치가 해당 브랜치를 검사하거나 테스트하기 위해 해당 브랜치를 가져 오는 것이 유용 할 수 있지만 해당 브랜치를 자신의 작업으로 가져 오려고 시도해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="eb01db138b0fd8c4f790bf23de91d970f6b3f25c" translate="yes" xml:space="preserve">
          <source>You may want to use &lt;code&gt;sslVerify=false&lt;/code&gt; while troubleshooting, if you suspect that the reason you are having trouble connecting is because the certificate you use at the private server &lt;code&gt;example.com&lt;/code&gt; you are trying to set up (or have set up) may not be verified correctly.</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;code&gt;sslVerify=false&lt;/code&gt; 인증서는 개인 서버에서 사용하기 때문에 당신이 연결에 문제가 발생하는 이유가 의심되는 경우 문제 해결 동안, &lt;code&gt;example.com&lt;/code&gt; 사용자가 설정하려는 (또는 설정 한)하지 않을 수 있습니다 올바르게 확인되었습니다.</target>
        </trans-unit>
        <trans-unit id="594c958b8686511065ebf30dd08d761eb22eafab" translate="yes" xml:space="preserve">
          <source>You might need to instead use: &lt;code&gt;folder = &quot;[Google Mail]/Drafts&quot;&lt;/code&gt; if you get an error that the &quot;Folder doesn&amp;rsquo;t exist&quot;.</source>
          <target state="translated">대신 &quot;폴더가 존재하지 않습니다&quot;라는 오류가 발생하면 &lt;code&gt;folder = &quot;[Google Mail]/Drafts&quot;&lt;/code&gt; 사용해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cb3e9e45a2fe07905a833e4999cf989715a0ad3" translate="yes" xml:space="preserve">
          <source>You might need to instead use: folder = &quot;[Google Mail]/Drafts&quot; if you get an error that the &quot;Folder doesn&amp;rsquo;t exist&quot;.</source>
          <target state="translated">&quot;폴더가 존재하지 않습니다&quot;라는 오류가 발생하면 대신 folder = &quot;[Google Mail] / Drafts&quot;를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce52beb4e545845637d5d5a0a1bc64e60b253c82" translate="yes" xml:space="preserve">
          <source>You might want to build on one of these remote-tracking branches on a branch of your own, just as you would for a tag:</source>
          <target state="translated">태그와 마찬가지로 다음과 같은 원격 추적 분기 중 하나를 자체 분기에 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0620c25fa90dc1aefb86ac91dfbd9e4eb8b29d0" translate="yes" xml:space="preserve">
          <source>You might want to recreate merge commits, e.g. if you have a history like this:</source>
          <target state="translated">예를 들어 다음과 같은 기록이있는 경우 병합 커밋을 다시 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76dbf6258421c615799bec755123a1d09c6ae993" translate="yes" xml:space="preserve">
          <source>You need to push the new tag to a public Git server (see &quot;DISTRIBUTED WORKFLOWS&quot; below). This makes the tag available to others tracking your project. The push could also trigger a post-update hook to perform release-related items such as building release tarballs and preformatted documentation pages.</source>
          <target state="translated">새 태그를 공개 Git 서버에 푸시해야합니다 (아래의 &quot;분산 된 워크 플로&quot;참조). 이를 통해 다른 사람들이 프로젝트를 추적 할 수 있습니다. 이 푸시는 또한 업데이트 후 후크를 트리거하여 릴리스 타르볼 작성 및 사전 형식화 된 문서 페이지와 같은 릴리스 관련 항목을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23c2bb7cb1fc9b6f4a240d36b5b4f0b94079730d" translate="yes" xml:space="preserve">
          <source>You need to set the configuration variable &lt;code&gt;rerere.enabled&lt;/code&gt; in order to enable this command.</source>
          <target state="translated">이 명령을 사용하려면 구성 변수 &lt;code&gt;rerere.enabled&lt;/code&gt; 를 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="beb1062efd31de3a255af22760556d9dc5fafa01" translate="yes" xml:space="preserve">
          <source>You normally only do signed tags for major releases or things like that, while the light-weight tags are useful for any marking you want to do &amp;mdash; any time you decide that you want to remember a certain point, just create a private tag for it, and you have a nice symbolic name for the state at that point.</source>
          <target state="translated">일반적으로 주요 릴리스 또는 이와 유사한 작업에 서명 된 태그 만 수행하는 반면, 경량 태그는 원하는 모든 마킹에 유용합니다. 특정 지점을 기억하기로 결정한 경우 개인 태그를 작성하면됩니다. , 그 시점의 상태에 대한 훌륭한 상징적 이름이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0eafb62c845e9f30a39264ada6b686e1d1ebb7b8" translate="yes" xml:space="preserve">
          <source>You often interact with the same remote repository by regularly and repeatedly fetching from it. In order to keep track of the progress of such a remote repository, &lt;code&gt;git fetch&lt;/code&gt; allows you to configure &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; configuration variables.</source>
          <target state="translated">정기적으로 반복해서 가져 와서 동일한 원격 저장소와 상호 작용하는 경우가 많습니다. 이러한 원격 저장소의 진행 상황을 추적하기 위해 &lt;code&gt;git fetch&lt;/code&gt; 를 사용하면 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 구성 변수 를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b67cab4bffb98d3ad72ff6748f9f8b98887d9f3" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t want to invoke this command directly; it is meant to be used as a credential helper by other parts of Git. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; or &lt;code&gt;EXAMPLES&lt;/code&gt; below.</source>
          <target state="translated">이 명령을 직접 호출하고 싶지 않을 수도 있습니다. Git의 다른 부분에서 자격 증명 도우미로 사용되도록 고안되었습니다. 아래의 &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt; 또는 &lt;code&gt;EXAMPLES&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="467e6fc50e0615f651de6ffbcc6e0f17ecbae432" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t want to invoke this command directly; it is meant to be used as a credential helper by other parts of git. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; or &lt;code&gt;EXAMPLES&lt;/code&gt; below.</source>
          <target state="translated">이 명령을 직접 호출하고 싶지 않을 수도 있습니다. 그것은 git의 다른 부분에서 자격 증명 도우미로 사용하기위한 것입니다. 아래의 &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt; 또는 &lt;code&gt;EXAMPLES&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c924d93ebd8e89f99e14509235b47dec1acfaa5d" translate="yes" xml:space="preserve">
          <source>You read a &quot;tree&quot; file from the object database, and use that to populate (and overwrite&amp;mdash;​don&amp;rsquo;t do this if your index contains any unsaved state that you might want to restore later!) your current index. Normal operation is just</source>
          <target state="translated">객체 데이터베이스에서 &quot;트리&quot;파일을 읽고 현재 인덱스를 인덱스에 저장하고 덮어 쓰십시오. 인덱스에 저장하지 않은 상태가있는 경우이 작업을 수행하지 마십시오! 정상적인 작동은</target>
        </trans-unit>
        <trans-unit id="e01bf60bb2a8e848b7516e87eb6405fb0e476f7b" translate="yes" xml:space="preserve">
          <source>You really filtered all refs: use &lt;code&gt;--tag-name-filter cat -- --all&lt;/code&gt; when calling git-filter-branch.</source>
          <target state="translated">git-filter-branch를 호출 할 때 &lt;code&gt;--tag-name-filter cat -- --all&lt;/code&gt; 사용하여 모든 참조를 실제로 필터링했습니다 .</target>
        </trans-unit>
        <trans-unit id="0cb205f517a67a8e523ed9cfa8681dc8f8d7b0ce" translate="yes" xml:space="preserve">
          <source>You really removed all variants of a filename, if a blob was moved over its lifetime. &lt;code&gt;git log --name-only --follow --all -- filename&lt;/code&gt; can help you find renames.</source>
          <target state="translated">얼룩이 수명 동안 이동 한 경우 파일 이름의 모든 변형을 실제로 제거했습니다. &lt;code&gt;git log --name-only --follow --all -- filename&lt;/code&gt; 은 이름 바꾸기를 찾는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a347f016fee70b8901448b2a81ecd1980ba100a9" translate="yes" xml:space="preserve">
          <source>You see, Git is actually the best tool to find out about the source of Git itself!</source>
          <target state="translated">아시다시피, Git은 실제로 Git 자체의 소스를 찾는 가장 좋은 도구입니다!</target>
        </trans-unit>
        <trans-unit id="2f7c7430f5ab3ddee895946cce58e0edcbc9b3f3" translate="yes" xml:space="preserve">
          <source>You should &lt;strong&gt;never&lt;/strong&gt; do any work of your own on the branches that are created by &lt;code&gt;git cvsimport&lt;/code&gt;. By default initial import will create and populate a &quot;master&quot; branch from the CVS repository&amp;rsquo;s main branch which you&amp;rsquo;re free to work with; after that, you need to &lt;code&gt;git merge&lt;/code&gt; incremental imports, or any CVS branches, yourself. It is advisable to specify a named remote via -r to separate and protect the incoming branches.</source>
          <target state="translated">&lt;code&gt;git cvsimport&lt;/code&gt; 에 의해 생성 된 브랜치에서 어떤 작업도 수행 해서는 &lt;strong&gt;안됩니다&lt;/strong&gt; . 기본적으로 초기 가져 오기는 CVS 저장소의 기본 분기에서 &quot;마스터&quot;분기를 작성하고 채울 수 있습니다. 그런 다음 증분 가져 오기 또는 CVS 분기를 직접 &lt;code&gt;git merge&lt;/code&gt; 해야합니다 . 들어오는 분기를 분리하고 보호하기 위해 -r을 통해 명명 된 원격을 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ac5b50c688e69b32b2a523ca6520323d9259e65e" translate="yes" xml:space="preserve">
          <source>You should consider using &lt;code&gt;dcommit&lt;/code&gt; instead of this command. Commit specified commit or tree objects to SVN. This relies on your imported fetch data being up to date. This makes absolutely no attempts to do patching when committing to SVN, it simply overwrites files with those specified in the tree or commit. All merging is assumed to have taken place independently of &lt;code&gt;git svn&lt;/code&gt; functions.</source>
          <target state="translated">이 명령 대신 &lt;code&gt;dcommit&lt;/code&gt; 사용을 고려해야 합니다. 지정된 커밋 또는 트리 객체를 SVN에 커밋합니다. 가져온 가져 오기 데이터가 최신 상태인지 확인합니다. 이것은 SVN에 커밋 할 때 패치를 시도하지 않으며 트리 또는 커밋에 지정된 파일로 단순히 덮어 씁니다. 모든 병합은 &lt;code&gt;git svn&lt;/code&gt; 함수와 독립적으로 수행 된 것으로 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="f0db0149a7a61b2b34d3de583889773851c606fb" translate="yes" xml:space="preserve">
          <source>You should now compile the checked-out version and test it. If that version works correctly, type</source>
          <target state="translated">이제 체크 아웃 된 버전을 컴파일하고 테스트해야합니다. 해당 버전이 제대로 작동하면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="adc89a3f88e3fe44040e1f3bf11644a95272fcdb" translate="yes" xml:space="preserve">
          <source>You should put your personal name, generally a form using a given name and family name. For example, the current maintainer of Git uses &quot;Junio C Hamano&quot;. This will be the name portion that is stored in every commit you make.</source>
          <target state="translated">일반적으로 주어진 이름과 성을 사용하는 양식 인 개인 이름을 입력해야합니다. 예를 들어 현재 Git 관리자는 &quot;Junio ​​C Hamano&quot;를 사용합니다. 이것은 당신이 만드는 모든 커밋에 저장되는 이름 부분이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="4ce522d2b57e2c5b1484c387e3121e7cf3c762ef" translate="yes" xml:space="preserve">
          <source>You should refrain from abusing this option to sneak substantial changes into a merge commit. Small fixups like bumping release/version name would be acceptable.</source>
          <target state="translated">이 옵션을 남용하여 실질적인 변경 사항을 병합 커밋에 몰래 넣지 마십시오. 충돌 릴리스 / 버전 이름과 같은 작은 수정은 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="de1993c72b3b1ad3dd18c76738408f9f041af6eb" translate="yes" xml:space="preserve">
          <source>You should understand the implications of rewriting history if you amend a commit that has already been published. (See the &quot;RECOVERING FROM UPSTREAM REBASE&quot; section in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.)</source>
          <target state="translated">이미 게시 된 커밋을 수정 한 경우 기록 다시 쓰기의 의미를 이해해야합니다. ( &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]의&lt;/a&gt; &quot;UPSTREAM REBASE 복구&quot;섹션을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="a5048e0c5c1221139fe969fc6db15713d2b83eb5" translate="yes" xml:space="preserve">
          <source>You should understand the implications of using &lt;code&gt;git rebase&lt;/code&gt; on a repository that you share. See also RECOVERING FROM UPSTREAM REBASE below.</source>
          <target state="translated">공유하는 저장소에서 &lt;code&gt;git rebase&lt;/code&gt; 를 사용할 때의 의미를 이해해야합니다 . 아래의 UPSTREAM REBASE에서 복구를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7550fee71eb33261ce4427a0e3743a34c95d7107" translate="yes" xml:space="preserve">
          <source>You should work through &lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt; before reading this tutorial.</source>
          <target state="translated">이 튜토리얼을 읽기 전에 &lt;a href=&quot;gittutorial&quot;&gt;gittutorial [7]을&lt;/a&gt; 통해 작업해야합니다 .</target>
        </trans-unit>
        <trans-unit id="33b464d633d5d3d359d8c081bd1ef24a08ba23d1" translate="yes" xml:space="preserve">
          <source>You then transfer the bundle to the other machine to replace /home/me/tmp/file.bundle, and pull from it.</source>
          <target state="translated">그런 다음 번들을 다른 시스템으로 전송하여 /home/me/tmp/file.bundle을 바꾸고 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="98122f0a874f3f8b610fdbc33b228a3b5afee64a" translate="yes" xml:space="preserve">
          <source>You update your working directory from the index by &quot;checking out&quot; files. This is not a very common operation, since normally you&amp;rsquo;d just keep your files updated, and rather than write to your working directory, you&amp;rsquo;d tell the index files about the changes in your working directory (i.e. &lt;code&gt;git update-index&lt;/code&gt;).</source>
          <target state="translated">파일을 &quot;체크 아웃&quot;하여 색인에서 작업 디렉토리를 업데이트합니다. 일반적으로 파일을 업데이트 한 상태로 유지하고 작업 디렉토리에 쓰지 않고 색인 파일에 작업 디렉토리의 변경 사항 (예 : &lt;code&gt;git update-index&lt;/code&gt; )을 알려주므로 매우 일반적인 작업은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="57134770b9c7f61c90927970f67f3d2eceaa4a12" translate="yes" xml:space="preserve">
          <source>You will continue to do your day-to-day work in your personal repository, but periodically &quot;push&quot; changes from your personal repository into your public repository, allowing other developers to pull from that repository. So the flow of changes, in a situation where there is one other developer with a public repository, looks like this:</source>
          <target state="translated">개인 저장소에서 일상적인 작업을 계속 수행하지만 개인 저장소에서 공용 저장소로 변경 사항을 주기적으로 &quot;밀어 넣어&quot;다른 개발자가 해당 저장소에서 가져올 수 있습니다. 따라서 공용 저장소를 가진 다른 개발자가있는 상황에서 변경 흐름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cee01be09864f7d5b244e4c87ca6f6106e652b44" translate="yes" xml:space="preserve">
          <source>You will need to run &lt;code&gt;git add --renormalize&lt;/code&gt; to have this take effect. Note that if you are making these changes on a project that is used across platforms, you&amp;rsquo;ll probably want to make it in a per-user configuration file or in the one in &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt;, since making it in a &lt;code&gt;.gitattributes&lt;/code&gt; file in the repository will apply to all users of the repository.</source>
          <target state="translated">이를 적용하려면 &lt;code&gt;git add --renormalize&lt;/code&gt; 를 실행해야합니다 . 당신이 플랫폼에서 사용되는 프로젝트에서 이러한 변경하는 경우, 당신은 아마 사용자 별 구성 파일 또는에서 하나를 만들고 싶어거야 주 &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; 그것으로 만들기 때문에 &lt;code&gt;.gitattributes&lt;/code&gt; 저장소의 gitattributes 파일은 저장소의 모든 사용자에게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8876e4496883cded62698bb08d4c1d5f289e1dee" translate="yes" xml:space="preserve">
          <source>You will see both of these things throughout the code.</source>
          <target state="translated">코드 전체에서이 두 가지를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dda56fbfc3230573e73ab526d0f70db698497a1" translate="yes" xml:space="preserve">
          <source>You will see informational messages on dangling objects. They are objects that still exist in the repository but are no longer referenced by any of your branches, and can (and will) be removed after a while with &lt;code&gt;gc&lt;/code&gt;. You can run &lt;code&gt;git fsck --no-dangling&lt;/code&gt; to suppress these messages, and still view real errors.</source>
          <target state="translated">매달려있는 개체에 대한 정보 메시지가 표시됩니다. 그것들은 여전히 ​​저장소에 존재하지만 더 이상 어떤 브랜치에서도 참조하지 않는 객체이며 &lt;code&gt;gc&lt;/code&gt; 로 잠시 후에 제거 할 수 있습니다 . &lt;code&gt;git fsck --no-dangling&lt;/code&gt; 을 실행 하여 이러한 메시지를 억제하고 실제 오류를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2fc4e070409aa778dc2444037511e0ef4801d3d" translate="yes" xml:space="preserve">
          <source>You will see two files, &lt;code&gt;pack-*.pack&lt;/code&gt; and &lt;code&gt;pack-*.idx&lt;/code&gt;, in &lt;code&gt;.git/objects/pack&lt;/code&gt; directory. They are closely related to each other, and if you ever copy them by hand to a different repository for whatever reason, you should make sure you copy them together. The former holds all the data from the objects in the pack, and the latter holds the index for random access.</source>
          <target state="translated">&lt;code&gt;.git/objects/pack&lt;/code&gt; 디렉토리 에 pack- &lt;code&gt;pack-*.pack&lt;/code&gt; 및 &lt;code&gt;pack-*.idx&lt;/code&gt; 파일이 표시됩니다 . 그것들은 서로 밀접하게 관련되어 있으며 어떤 이유로 든 다른 저장소에 직접 복사하는 경우 함께 복사해야합니다. 전자는 팩에있는 개체의 모든 데이터를 보유하고 후자는 임의 액세스를위한 색인을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="266addba668945d927bfdfb63b85369114140000" translate="yes" xml:space="preserve">
          <source>You will still have to tell people by other means, such as mail. (Git provides the &lt;a href=&quot;git-request-pull&quot;&gt;git-request-pull[1]&lt;/a&gt; to send preformatted pull requests to upstream maintainers to simplify this task.)</source>
          <target state="translated">우편과 같은 다른 방법으로 사람들에게 계속 알려야합니다. Git은 &lt;a href=&quot;git-request-pull&quot;&gt;git-request-pull [1]&lt;/a&gt; 을 제공하여이 작업을 단순화하기 위해 사전 형식화 된 풀 요청을 업스트림 관리자에게 보냅니다.</target>
        </trans-unit>
        <trans-unit id="67a2c97a3fe15102ccbc39363d071f9caa744775" translate="yes" xml:space="preserve">
          <source>You would normally use &lt;code&gt;git merge-index&lt;/code&gt; with supplied &lt;code&gt;git merge-one-file&lt;/code&gt; to do this last step. The script updates the files in the working tree as it merges each path and at the end of a successful merge.</source>
          <target state="translated">일반적으로 제공된 &lt;code&gt;git merge-one-file&lt;/code&gt; 과 함께 &lt;code&gt;git merge-index&lt;/code&gt; 를 사용 하여 마지막 단계를 수행합니다. 스크립트는 각 경로를 병합하고 성공적인 병합이 끝날 때 작업 트리의 파일을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="acf5d70c570af359d1fc1b3db4b2e1cb44907ec4" translate="yes" xml:space="preserve">
          <source>You wouldn&amp;rsquo;t need to ever change it in gitweb config file.</source>
          <target state="translated">gitweb 설정 파일에서 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="065eff42d50778a1002dd0b7a890143f4063288e" translate="yes" xml:space="preserve">
          <source>You write your current index file to a &quot;tree&quot; object with the program</source>
          <target state="translated">프로그램을 사용하여 현재 색인 파일을 &quot;트리&quot;객체에 씁니다.</target>
        </trans-unit>
        <trans-unit id="49012e7b5c219e4c44033d7ce0ec88b78d68a780" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve now initialized the working directory&amp;mdash;​you may notice a new directory created, named &quot;.git&quot;.</source>
          <target state="translated">이제 작업 디렉토리를 초기화했습니다. &quot;.git&quot;라는 새 디렉토리가 생성 된 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e4b96aa3f69a0a980be2d48bd9eb2298bc44f3c" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve now made your first real Git commit. And if you&amp;rsquo;re interested in looking at what &lt;code&gt;git commit&lt;/code&gt; really does, feel free to investigate: it&amp;rsquo;s a few very simple shell scripts to generate the helpful (?) commit message headers, and a few one-liners that actually do the commit itself (&lt;code&gt;git commit&lt;/code&gt;).</source>
          <target state="translated">이제 첫 번째 실제 Git 커밋을 만들었습니다. 그리고 &lt;code&gt;git commit&lt;/code&gt; 이 실제로 무엇을하는지 관심이 있다면 , 자유롭게 조사해보십시오. 유용한 (?) commit 메시지 헤더를 생성하는 매우 간단한 쉘 스크립트와 실제로 commit 자체를 수행하는 하나의 라이너 ( &lt;code&gt;git commit&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6fd65e242e5023949f1979a313cb8892375303bf" translate="yes" xml:space="preserve">
          <source>Your &quot;public repository&quot; is now ready to accept your changes. Come back to the machine you have your private repository. From there, run this command:</source>
          <target state="translated">&quot;공개 저장소&quot;가 이제 변경 사항을 승인 할 준비가되었습니다. 개인 저장소가있는 머신으로 돌아 오십시오. 거기에서 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="77f5c1536424041eff5dddce9b9dc699480c5921" translate="yes" xml:space="preserve">
          <source>Your private repository&amp;rsquo;s Git directory is usually &lt;code&gt;.git&lt;/code&gt;, but your public repository is often named after the project name, i.e. &lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt;. Let&amp;rsquo;s create such a public repository for project &lt;code&gt;my-git&lt;/code&gt;. After logging into the remote machine, create an empty directory:</source>
          <target state="translated">개인 저장소의 Git 디렉토리는 일반적으로 &lt;code&gt;.git&lt;/code&gt; 이지만 공용 저장소의 이름은 종종 프로젝트 이름 (예 : &lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt; )으로 지정 됩니다. &lt;code&gt;my-git&lt;/code&gt; 프로젝트를위한 공개 저장소를 만들어 보자 . 원격 머신에 로그인 한 후 빈 디렉토리를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b96e6decf426a8986abe42a514d0d538e2f36071" translate="yes" xml:space="preserve">
          <source>Your work tree is still based on your HEAD ($JC), but you have some edits since. Three-way merge makes sure that you have not added or modified index entries since $JC, and if you haven&amp;rsquo;t, then does the right thing. So with the following sequence:</source>
          <target state="translated">작업 트리는 여전히 HEAD ($ JC)를 기반으로하지만 그 이후로 몇 가지 수정 사항이 있습니다. 3 방향 병합은 $ JC 이후로 색인 항목을 추가하거나 수정하지 않았으며, 그렇지 않은 경우 올바른 작업을 수행합니다. 따라서 다음 순서로 :</target>
        </trans-unit>
        <trans-unit id="8ff2148494456dea5c056275d6718302d7ecd982" translate="yes" xml:space="preserve">
          <source>Zero or more &lt;code&gt;filemodify&lt;/code&gt;, &lt;code&gt;filedelete&lt;/code&gt;, &lt;code&gt;filecopy&lt;/code&gt;, &lt;code&gt;filerename&lt;/code&gt;, &lt;code&gt;filedeleteall&lt;/code&gt; and &lt;code&gt;notemodify&lt;/code&gt; commands may be included to update the contents of the branch prior to creating the commit. These commands may be supplied in any order. However it is recommended that a &lt;code&gt;filedeleteall&lt;/code&gt; command precede all &lt;code&gt;filemodify&lt;/code&gt;, &lt;code&gt;filecopy&lt;/code&gt;, &lt;code&gt;filerename&lt;/code&gt; and &lt;code&gt;notemodify&lt;/code&gt; commands in the same commit, as &lt;code&gt;filedeleteall&lt;/code&gt; wipes the branch clean (see below).</source>
          <target state="translated">커밋을 만들기 전에 분기의 내용을 업데이트하기 위해 0 개 이상의 &lt;code&gt;filemodify&lt;/code&gt; , &lt;code&gt;filedelete&lt;/code&gt; , &lt;code&gt;filecopy&lt;/code&gt; , &lt;code&gt;filerename&lt;/code&gt; , &lt;code&gt;filedeleteall&lt;/code&gt; 및 &lt;code&gt;notemodify&lt;/code&gt; 명령이 포함될 수 있습니다. 이러한 명령은 임의의 순서로 제공 될 수 있습니다. 그러나 &lt;code&gt;filedeleteall&lt;/code&gt; 은 브랜치를 정리하므로 (아래 참조) , 동일한 커밋에서 &lt;code&gt;filedeleteall&lt;/code&gt; 명령이 모든 &lt;code&gt;filemodify&lt;/code&gt; , &lt;code&gt;filecopy&lt;/code&gt; , &lt;code&gt;filerename&lt;/code&gt; 및 &lt;code&gt;notemodify&lt;/code&gt; 명령 앞에 오는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="480b45cead8c71eaa647209c97491be4a36ea289" translate="yes" xml:space="preserve">
          <source>Zero or more protocol options may be entered after the last &lt;code&gt;push&lt;/code&gt; command, before the batch&amp;rsquo;s terminating blank line.</source>
          <target state="translated">일괄 처리 종료 빈 줄 앞에 마지막 &lt;code&gt;push&lt;/code&gt; 명령 후 0 개 이상의 프로토콜 옵션을 입력 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fbdec3db39874b3b5b75476184662777ddc44fd6" translate="yes" xml:space="preserve">
          <source>[&amp;lt;git-rev-list-args&amp;gt;&amp;hellip;​]</source>
          <target state="translated">[&amp;lt;git-rev-list-args&amp;gt;&amp;hellip;​]</target>
        </trans-unit>
        <trans-unit id="b3a075bbccfeeb4bedba2aca4addb159d1acee3d" translate="yes" xml:space="preserve">
          <source>[&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">[&amp;lt;path&amp;gt;&amp;hellip;​]</target>
        </trans-unit>
        <trans-unit id="d31c8b5c3af548ff2d95f4e227ea28f0f9277441" translate="yes" xml:space="preserve">
          <source>[&amp;lt;refname&amp;gt;&amp;hellip;​]</source>
          <target state="translated">[&amp;lt;refname&amp;gt;&amp;hellip;​]</target>
        </trans-unit>
        <trans-unit id="e961d55ee5b355694495464c07c86f7fba23e9a9" translate="yes" xml:space="preserve">
          <source>[--] &amp;lt;path&amp;gt;&amp;hellip;​</source>
          <target state="translated">[-] &amp;lt;경로&amp;gt;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="1eb3d578c1f910d18345d8eb23a781efa2f8d23d" translate="yes" xml:space="preserve">
          <source>[0] &lt;a href=&quot;https://bugs.chromium.org/p/git/issues/detail?id=6&quot;&gt;https://bugs.chromium.org/p/git/issues/detail?id=6&lt;/a&gt; Chromium work item for: Multi-Pack Index (MIDX)</source>
          <target state="translated">[0] &lt;a href=&quot;https://bugs.chromium.org/p/git/issues/detail?id=6&quot;&gt;https://bugs.chromium.org/p/git/issues/detail?id=6&lt;/a&gt; Chromium 작업 항목 : 멀티 팩 인덱스 (MIDX)</target>
        </trans-unit>
        <trans-unit id="25a96ba2d3b7a7d8ee2c18075362c090194ac1d0" translate="yes" xml:space="preserve">
          <source>[1] &lt;a href=&quot;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&quot;&gt;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&lt;/a&gt; An earlier RFC for the multi-pack-index feature</source>
          <target state="translated">[1] &lt;a href=&quot;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&quot;&gt;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&lt;/a&gt; 다중 팩 인덱스 기능을위한 초기 RFC</target>
        </trans-unit>
        <trans-unit id="347fffb72e72a788a9461ff2e246ae61494e14d7" translate="yes" xml:space="preserve">
          <source>[2] &lt;a href=&quot;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&quot;&gt;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&lt;/a&gt; Git Merge 2018 Contributor&amp;rsquo;s summit notes (includes discussion of MIDX)</source>
          <target state="translated">[2] &lt;a href=&quot;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&quot;&gt;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&lt;/a&gt; Git Merge 2018 컨트 리뷰 터의 서밋 노트 (MIDX에 대한 토론 포함)</target>
        </trans-unit>
        <trans-unit id="feea73f842c5a1ec74b307b98128568bae22544a" translate="yes" xml:space="preserve">
          <source>[DEPRECATED: use &lt;code&gt;--rebase-merges&lt;/code&gt; instead] Recreate merge commits instead of flattening the history by replaying commits a merge commit introduces. Merge conflict resolutions or manual amendments to merge commits are not preserved.</source>
          <target state="translated">[DEPRECATED : 대신 &lt;code&gt;--rebase-merges&lt;/code&gt; 사용] 커밋을 도입 한 커밋을 재생하여 히스토리를 병합하는 대신 병합 커밋을 다시 만듭니다. 병합 충돌 해결 또는 커밋 병합에 대한 수동 수정 사항은 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a59f280e0e654176579fad979c6b2390d4560b5d" translate="yes" xml:space="preserve">
          <source>[EXPERIMENTAL] Set to &lt;code&gt;true&lt;/code&gt; to use the experimental built-in implementation of the interactive version of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; instead of the Perl script version. Is &lt;code&gt;false&lt;/code&gt; by default.</source>
          <target state="translated">[EXPERIMENTAL] Perl 스크립트 버전 대신 대화식 버전의 &lt;a href=&quot;git-add&quot;&gt;git-add [1]에&lt;/a&gt; 대해 실험적인 내장 구현을 사용하려면 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 . 가 &lt;code&gt;false&lt;/code&gt; 기본적으로.</target>
        </trans-unit>
        <trans-unit id="f8205d704abeeab8758bae84f0f9eac80a6c4899" translate="yes" xml:space="preserve">
          <source>[NOTE] &lt;code&gt;git rerere&lt;/code&gt; relies on the conflict markers in the file to detect the conflict. If the file already contains lines that look the same as lines with conflict markers, &lt;code&gt;git rerere&lt;/code&gt; may fail to record a conflict resolution. To work around this, the &lt;code&gt;conflict-marker-size&lt;/code&gt; setting in &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; can be used.</source>
          <target state="translated">[참고] &lt;code&gt;git rerere&lt;/code&gt; 는 파일의 충돌 마커를 사용하여 충돌을 감지합니다. 파일에 충돌 표식이있는 줄과 같은 줄이 이미 포함되어 있으면 &lt;code&gt;git rerere&lt;/code&gt; 가 충돌 해결을 기록하지 못할 수 있습니다. 이 문제를 해결하기 위해 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 의 &lt;code&gt;conflict-marker-size&lt;/code&gt; 설정을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac4bc8630c3c03bfd813e3fe5057d1c466974ce5" translate="yes" xml:space="preserve">
          <source>[[[1]]] &lt;a href=&quot;https://www.nist.gov/sites/default/files/documents/director/planning/report02-3.pdf&quot;&gt;&lt;em&gt;The Economic Impacts of Inadequate Infratructure for Software Testing&lt;/em&gt;. Nist Planning Report 02-3&lt;/a&gt;, see Executive Summary and Chapter 8.</source>
          <target state="translated">[[[1]]] &lt;a href=&quot;https://www.nist.gov/sites/default/files/documents/director/planning/report02-3.pdf&quot;&gt;&lt;em&gt;소프트웨어 테스팅에 대한 부적절한 인프라의 경제적 영향&lt;/em&gt; . Nist Planning Report 02-3&lt;/a&gt; 은 Executive Summary 및 8 장을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e5f919a0494a6ccb56ff39496ebf8651f04232d2" translate="yes" xml:space="preserve">
          <source>[[[2]]] &lt;a href=&quot;http://www.oracle.com/technetwork/java/codeconvtoc-136057.html&quot;&gt;&lt;em&gt;Code Conventions for the Java Programming Language&lt;/em&gt;. Sun Microsystems.&lt;/a&gt;</source>
          <target state="translated">[[[2]]] &lt;a href=&quot;http://www.oracle.com/technetwork/java/codeconvtoc-136057.html&quot;&gt;&lt;em&gt;Java 프로그래밍 언어의 코드 규약&lt;/em&gt; . 썬 마이크로 시스템즈.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="de6da26d7d92c3d4bdee11d004d96506e88a1b00" translate="yes" xml:space="preserve">
          <source>[[[3]]] &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_maintenance&quot;&gt;&lt;em&gt;Software maintenance&lt;/em&gt;. Wikipedia.&lt;/a&gt;</source>
          <target state="translated">[[[3]]] &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_maintenance&quot;&gt;&lt;em&gt;소프트웨어 유지 보수&lt;/em&gt; . 위키 백과.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a21dac2771422b1ce396ac7103119df3289ef40d" translate="yes" xml:space="preserve">
          <source>[[[4]]] &lt;a href=&quot;https://lore.kernel.org/git/7vps5xsbwp.fsf_-_@assigned-by-dhcp.cox.net/&quot;&gt;Junio C Hamano. &lt;em&gt;Automated bisect success story&lt;/em&gt;.&lt;/a&gt;</source>
          <target state="translated">[[[4]]] &lt;a href=&quot;https://lore.kernel.org/git/7vps5xsbwp.fsf_-_@assigned-by-dhcp.cox.net/&quot;&gt;Junio ​​C 하마노. &lt;em&gt;자동 이등분 성공 사례&lt;/em&gt; .&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06e39006ce98590e4632510795aafbc71a8d5177" translate="yes" xml:space="preserve">
          <source>[[[5]]] &lt;a href=&quot;https://lwn.net/Articles/317154/&quot;&gt;Christian Couder. &lt;em&gt;Fully automated bisecting with &quot;git bisect run&quot;&lt;/em&gt;. LWN.net.&lt;/a&gt;</source>
          <target state="translated">[[[5]]] &lt;a href=&quot;https://lwn.net/Articles/317154/&quot;&gt;크리스티안 쿠더. &lt;em&gt;&quot;git bisect run&quot;을 사용한 완전 자동화 된 이등분&lt;/em&gt; . LWN.net.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a12b60ab9e79fee2e4613d666532029fdb7e1f4d" translate="yes" xml:space="preserve">
          <source>[[[6]]] &lt;a href=&quot;https://lwn.net/Articles/277872/&quot;&gt;Jonathan Corbet. &lt;em&gt;Bisection divides users and developers&lt;/em&gt;. LWN.net.&lt;/a&gt;</source>
          <target state="translated">[[[6]]] &lt;a href=&quot;https://lwn.net/Articles/277872/&quot;&gt;Jonathan Corbet. &lt;em&gt;Bisection은 사용자와 개발자를 나눕니다&lt;/em&gt; . LWN.net.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb3a1d698c871451809a03759d2052ad730db3fa" translate="yes" xml:space="preserve">
          <source>[[[7]]] &lt;a href=&quot;https://lore.kernel.org/lkml/20071207113734.GA14598@elte.hu/&quot;&gt;Ingo Molnar. &lt;em&gt;Re: BUG 2.6.23-rc3 can&amp;rsquo;t see sd partitions on Alpha&lt;/em&gt;. Linux-kernel mailing list.&lt;/a&gt;</source>
          <target state="translated">[[[7]]] &lt;a href=&quot;https://lore.kernel.org/lkml/20071207113734.GA14598@elte.hu/&quot;&gt;잉고 몰 나르. &lt;em&gt;Re : BUG 2.6.23-rc3는 Alpha에서 sd 파티션을 볼 수 없습니다&lt;/em&gt; . 리눅스 커널 메일 링리스트.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91adb50bf54c20a1b51a7a5bd4f97f72154e309d" translate="yes" xml:space="preserve">
          <source>[[[8]]] &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html&quot;&gt;Junio C Hamano and the git-list. &lt;em&gt;git-bisect(1) Manual Page&lt;/em&gt;. Linux Kernel Archives.&lt;/a&gt;</source>
          <target state="translated">[[[8]]] &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html&quot;&gt;Junio ​​C Hamano와 자식 목록. &lt;em&gt;git-bisect (1) 매뉴얼 페이지&lt;/em&gt; . 리눅스 커널 아카이브.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="62e3bcbb19b635de003c473322577e0da443bd26" translate="yes" xml:space="preserve">
          <source>[[[9]]] &lt;a href=&quot;https://github.com/Ealdwulf/bbchop&quot;&gt;Ealdwulf. &lt;em&gt;bbchop&lt;/em&gt;. GitHub.&lt;/a&gt;</source>
          <target state="translated">[[[9]]] &lt;a href=&quot;https://github.com/Ealdwulf/bbchop&quot;&gt;얼 독프. &lt;em&gt;바비큐&lt;/em&gt; . GitHub.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4720dfbb1b4c30f403e79c3ea73865f0f4c5faef" translate="yes" xml:space="preserve">
          <source>[user@]host.xz:/~[user]/path/to/repo.git/</source>
          <target state="translated">[user@]host.xz:/~[user]/path/to/repo.git/</target>
        </trans-unit>
        <trans-unit id="5995beae7c11faa4cc7064555dea6942a8fa3779" translate="yes" xml:space="preserve">
          <source>[user@]host.xz:path/to/repo.git/</source>
          <target state="translated">[user@]host.xz:path/to/repo.git/</target>
        </trans-unit>
        <trans-unit id="8bc9eff643c5f26b1d25ab8fdf5a5ddc87d11ead" translate="yes" xml:space="preserve">
          <source>\0 line termination on output and do not quote filenames. See OUTPUT FORMAT below for more information.</source>
          <target state="translated">출력시 \ 0 줄 종결이며 파일 이름을 인용하지 않습니다. 자세한 내용은 아래 출력 형식을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d0b23d6e6728ae49ec5909ad48b79671e7245999" translate="yes" xml:space="preserve">
          <source>\0 line termination on output and do not quote filenames. See OUTPUT below for more information.</source>
          <target state="translated">출력시 \ 0 줄 종결이며 파일 이름을 인용하지 않습니다. 자세한 내용은 아래 출력을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ec441d8e621550cb4deb96e2b1ad67311ed0768f" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt; directory that is a &lt;code&gt;bare&lt;/code&gt; repository (i.e. without its own working tree), that is typically used for exchanging histories with others by pushing into it and fetching from it.</source>
          <target state="translated">&lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt; A는 디렉토리 &lt;code&gt;bare&lt;/code&gt; 저장소 (즉, 자신의 작업 트리없이) 일반적으로 그것으로 밀고 그것에서 인출하여 다른 사람들과 역사를 교환하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="ea844fb65222d001b2e2f561d577c3d6a932db4a" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;.git&lt;/code&gt; directory at the root of the working tree;</source>
          <target state="translated">작업 트리의 루트에 있는 &lt;code&gt;.git&lt;/code&gt; 디렉토리;</target>
        </trans-unit>
        <trans-unit id="f0d4bf33608fee8383e25a39f62fec37be3db742" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;lot&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc234069c4e3ee03ef8f7670cb491ed5411b65b6" translate="yes" xml:space="preserve">
          <source>a NUL (only exists if renamed/copied);</source>
          <target state="translated">NUL (이름이 바뀌거나 복사 된 경우에만 존재);</target>
        </trans-unit>
        <trans-unit id="079f5a842faae1ecf0933e998354e66093295bb8" translate="yes" xml:space="preserve">
          <source>a NUL.</source>
          <target state="translated">NUL.</target>
        </trans-unit>
        <trans-unit id="e9278592288a5c5c028d9d1d04c2201af670c4f7" translate="yes" xml:space="preserve">
          <source>a URL like &quot;git://example.org/path/to/repo.git&quot; will be rewritten to &quot;ssh://example.org/path/to/repo.git&quot; for pushes, but pulls will still use the original URL.</source>
          <target state="translated">&quot;git : //example.org/path/to/repo.git&quot;와 같은 URL은 푸시를 위해 &quot;ssh : //example.org/path/to/repo.git&quot;로 다시 쓰여지지만 풀은 여전히 원래 URL.</target>
        </trans-unit>
        <trans-unit id="96a7d2b2a7356a40bc207f3d1e0038c9f743ef8f" translate="yes" xml:space="preserve">
          <source>a URL like &quot;work:repo.git&quot; or like &quot;host.xz:/path/to/repo.git&quot; will be rewritten in any context that takes a URL to be &quot;git://git.host.xz/repo.git&quot;.</source>
          <target state="translated">&quot;work : repo.git&quot;또는 &quot;host.xz : /path/to/repo.git&quot;과 같은 URL은 URL이 &quot;git : //git.host.xz/repo 인 모든 컨텍스트에서 다시 작성됩니다. .git &quot;.</target>
        </trans-unit>
        <trans-unit id="da90a472a42edab28f6103dd507b377a59e39919" translate="yes" xml:space="preserve">
          <source>a colon.</source>
          <target state="translated">결장.</target>
        </trans-unit>
        <trans-unit id="07112c294a121f7cc6ed6654ce50e53f206b098f" translate="yes" xml:space="preserve">
          <source>a comment describing this commit.</source>
          <target state="translated">이 커밋을 설명하는 주석.</target>
        </trans-unit>
        <trans-unit id="6fd45c543fb44740f3ae2218676d1d2f809372d6" translate="yes" xml:space="preserve">
          <source>a committer: The name of the person who actually created the commit, with the date it was done. This may be different from the author, for example, if the author was someone who wrote a patch and emailed it to the person who used it to create the commit.</source>
          <target state="translated">커미터 : 커밋을 실제로 만든 사람의 이름과 날짜를 포함합니다. 예를 들어, 작성자가 패치를 작성하여 커밋을 생성하는 데 사용했던 사람에게 전자 메일을 보낸 사람인 경우에는 작성자와 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="475363380919fa9dad3daaa5151af4a7ecf7fe63" translate="yes" xml:space="preserve">
          <source>a file called &lt;code&gt;HEAD&lt;/code&gt;, that has &lt;code&gt;ref: refs/heads/master&lt;/code&gt; in it. This is similar to a symbolic link and points at &lt;code&gt;refs/heads/master&lt;/code&gt; relative to the &lt;code&gt;HEAD&lt;/code&gt; file.</source>
          <target state="translated">라는 파일 &lt;code&gt;HEAD&lt;/code&gt; 가, &lt;code&gt;ref: refs/heads/master&lt;/code&gt; 그것입니다. 이것은 심볼릭 링크와 유사 하며 &lt;code&gt;HEAD&lt;/code&gt; 파일을 기준으로 &lt;code&gt;refs/heads/master&lt;/code&gt; 를 가리 킵니다 .</target>
        </trans-unit>
        <trans-unit id="956892125b0edbb5f2b693d0431acccf4dd5c1cd" translate="yes" xml:space="preserve">
          <source>a file in the &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/branches&lt;/code&gt; 디렉토리 의 파일 .</target>
        </trans-unit>
        <trans-unit id="7a8f92bb4f6fe9e686ed78d483dc8804c1d0837c" translate="yes" xml:space="preserve">
          <source>a file in the &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; directory, or</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; 디렉토리 의 파일 또는</target>
        </trans-unit>
        <trans-unit id="6fb331171394d95fbb7a35c4b995f2a83f23618c" translate="yes" xml:space="preserve">
          <source>a file that has &lt;code&gt;any&lt;/code&gt; difference what-so-ever in the three trees will stay as separate entries in the index. It&amp;rsquo;s up to &quot;porcelain policy&quot; to determine how to remove the non-0 stages, and insert a merged version.</source>
          <target state="translated">이 파일에 &lt;code&gt;any&lt;/code&gt; 세 개의 나무에서 무엇을 그리 적 차이는 인덱스에 별도의 항목으로 유지됩니다. 0이 아닌 단계를 제거하고 병합 된 버전을 삽입하는 방법은 &quot;도자기 정책&quot;에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcb1d336b0be584d8054e8f7d63b3480aea0ee1d" translate="yes" xml:space="preserve">
          <source>a function called &lt;code&gt;cmd_&amp;lt;bla&amp;gt;&lt;/code&gt;, typically defined in &lt;code&gt;builtin/&amp;lt;bla.c&amp;gt;&lt;/code&gt; (note that older versions of Git used to have it in &lt;code&gt;builtin-&amp;lt;bla&amp;gt;.c&lt;/code&gt; instead), and declared in &lt;code&gt;builtin.h&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cmd_&amp;lt;bla&amp;gt;&lt;/code&gt; 라는 함수는 일반적으로 &lt;code&gt;builtin/&amp;lt;bla.c&amp;gt;&lt;/code&gt; 에 정의되어 있으며 (이전 버전의 Git은 대신 &lt;code&gt;builtin-&amp;lt;bla&amp;gt;.c&lt;/code&gt; 에 사용 했었다는 점에 유의하십시오 ) &lt;code&gt;builtin.h&lt;/code&gt; 에 선언되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d20b77e1575c57d2803f17741070661ffe1f7923" translate="yes" xml:space="preserve">
          <source>a line that begins with &quot;Index: &quot;</source>
          <target state="translated">&quot;Index :&quot;로 시작하는 줄</target>
        </trans-unit>
        <trans-unit id="eac485dbe3dc8258452b85ab1fdc03917425590f" translate="yes" xml:space="preserve">
          <source>a line that begins with &quot;diff -&quot;, or</source>
          <target state="translated">&quot;diff-&quot;로 시작하는 줄 또는</target>
        </trans-unit>
        <trans-unit id="8cb077e79c6b205418cec26b6f4930fe1ae56b3b" translate="yes" xml:space="preserve">
          <source>a newline.</source>
          <target state="translated">개행.</target>
        </trans-unit>
        <trans-unit id="678e3fa85625ddb634df3223f890cd55081ea7cd" translate="yes" xml:space="preserve">
          <source>a raw &lt;code&gt;%&lt;/code&gt;</source>
          <target state="translated">생 &lt;code&gt;%&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6a839de3aabe2c207992e1add851477714b9c5e" translate="yes" xml:space="preserve">
          <source>a remote in the Git configuration file: &lt;code&gt;$GIT_DIR/config&lt;/code&gt;,</source>
          <target state="translated">Git 구성 파일의 원격 : &lt;code&gt;$GIT_DIR/config&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="f9af7071efb1bd7dd22ebf85f05d8810442b8586" translate="yes" xml:space="preserve">
          <source>a space between time and time zone</source>
          <target state="translated">시간대와 시간대</target>
        </trans-unit>
        <trans-unit id="65b604e2f985f7317d6866f6730d409a3832783e" translate="yes" xml:space="preserve">
          <source>a space instead of the &lt;code&gt;T&lt;/code&gt; date/time delimiter</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 날짜 / 시간 분리 문자 대신 공백</target>
        </trans-unit>
        <trans-unit id="5bc00ebd3440c4f401b07128f1c136e115562dd8" translate="yes" xml:space="preserve">
          <source>a space.</source>
          <target state="translated">우주.</target>
        </trans-unit>
        <trans-unit id="97a7ee5f8a960df69981e9527fa176cfdf9705cf" translate="yes" xml:space="preserve">
          <source>a subdirectory called &lt;code&gt;objects&lt;/code&gt;, which will contain all the objects of your project. You should never have any real reason to look at the objects directly, but you might want to know that these objects are what contains all the real &lt;code&gt;data&lt;/code&gt; in your repository.</source>
          <target state="translated">&lt;code&gt;objects&lt;/code&gt; 라는 서브 디렉토리 . 여기에는 프로젝트의 모든 오브젝트가 포함됩니다. 객체를 직접보아야 할 실질적인 이유가 없어야하지만 이러한 객체가 리포지토리의 모든 실제 &lt;code&gt;data&lt;/code&gt; 를 포함하고 있다는 것을 알고 싶을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="045a27e5aab449465c7a517674ebf98a06438921" translate="yes" xml:space="preserve">
          <source>a subdirectory called &lt;code&gt;refs&lt;/code&gt;, which contains references to objects.</source>
          <target state="translated">객체에 대한 참조를 포함하는 &lt;code&gt;refs&lt;/code&gt; 라는 서브 디렉토리</target>
        </trans-unit>
        <trans-unit id="03097f133fc01ec710880af30fddc9a8cd7c34db" translate="yes" xml:space="preserve">
          <source>a tab or a NUL when &lt;code&gt;-z&lt;/code&gt; option is used.</source>
          <target state="translated">&lt;code&gt;-z&lt;/code&gt; 옵션을 사용하는 경우 탭 또는 NUL</target>
        </trans-unit>
        <trans-unit id="9346da07fb77dd97b82dc62a47eb3edc36d2b7a0" translate="yes" xml:space="preserve">
          <source>a tab or a NUL when &lt;code&gt;-z&lt;/code&gt; option is used; only exists for C or R.</source>
          <target state="translated">&lt;code&gt;-z&lt;/code&gt; 옵션이 사용되는 경우 탭 또는 NUL ; C 또는 R에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="c40734bc76bdc997f13a3bade66db88cc0dc137e" translate="yes" xml:space="preserve">
          <source>a tab;</source>
          <target state="translated">탭;</target>
        </trans-unit>
        <trans-unit id="19150edbe2f84d3c01f8f24ddf7de6b06a212def" translate="yes" xml:space="preserve">
          <source>a tree: The SHA-1 name of a tree object (as defined below), representing the contents of a directory at a certain point in time.</source>
          <target state="translated">트리 : 특정 시점의 디렉토리 내용을 나타내는 트리 객체 (아래에 정의 된대로)의 SHA-1 이름.</target>
        </trans-unit>
        <trans-unit id="013edfaa8480f23dc64a9a565714902a0f70e19a" translate="yes" xml:space="preserve">
          <source>a valid head &lt;code&gt;name&lt;/code&gt; (i.e. a &lt;code&gt;refs/heads/&amp;lt;head&amp;gt;&lt;/code&gt; reference).</source>
          <target state="translated">유효한 헤드 &lt;code&gt;name&lt;/code&gt; (예 : 참조 &lt;code&gt;refs/heads/&amp;lt;head&amp;gt;&lt;/code&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="c3796b26d9f35f82d5c7ba0548ce633809586698" translate="yes" xml:space="preserve">
          <source>a valid tag &lt;code&gt;name&lt;/code&gt; (i.e. a &lt;code&gt;refs/tags/&amp;lt;tag&amp;gt;&lt;/code&gt; reference).</source>
          <target state="translated">유효한 태그 &lt;code&gt;name&lt;/code&gt; (예 : &lt;code&gt;refs/tags/&amp;lt;tag&amp;gt;&lt;/code&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="fdbf716e8cd4fd3ff778984618bbe33ffeee814c" translate="yes" xml:space="preserve">
          <source>a) are ancestor of the &quot;bad&quot; commit (including the &quot;bad&quot; commit itself), b) are not ancestor of a &quot;good&quot; commit (excluding the &quot;good&quot; commits).</source>
          <target state="translated">a) &quot;나쁜&quot;커밋의 조상 ( &quot;나쁜&quot;커밋 자체 포함) b) &quot;좋은&quot;커밋의 조상 ( &quot;좋은&quot;커밋 제외)</target>
        </trans-unit>
        <trans-unit id="8682c02d1bc4bfce128a794497013605d86c32b6" translate="yes" xml:space="preserve">
          <source>a) regular use</source>
          <target state="translated">a) 정기적 인 사용</target>
        </trans-unit>
        <trans-unit id="4ff2759bc14568ced83be0be38a4abafea668a32" translate="yes" xml:space="preserve">
          <source>abbreviated commit hash</source>
          <target state="translated">약식 커밋 해시</target>
        </trans-unit>
        <trans-unit id="83baab4c4f5445b3450e34e24f8066fea1ac11f2" translate="yes" xml:space="preserve">
          <source>abbreviated parent hashes</source>
          <target state="translated">약식 부모 해시</target>
        </trans-unit>
        <trans-unit id="33579b1cb5338205dc784843012a5c0a9e8cacae" translate="yes" xml:space="preserve">
          <source>abbreviated tree hash</source>
          <target state="translated">약식 트리 해시</target>
        </trans-unit>
        <trans-unit id="b61646f016483b318b49a910668a966b6ce09ede" translate="yes" xml:space="preserve">
          <source>abort</source>
          <target state="translated">abort</target>
        </trans-unit>
        <trans-unit id="832e60dfe198126ed45442b9d54f0a366515eefc" translate="yes" xml:space="preserve">
          <source>absorbgitdirs</source>
          <target state="translated">absorbgitdirs</target>
        </trans-unit>
        <trans-unit id="f412f21dd1d844e9ed4c1cbd73b06dc725c5d8bd" translate="yes" xml:space="preserve">
          <source>access method (one of &quot;ext&quot; or &quot;pserver&quot;)</source>
          <target state="translated">액세스 방법 ( &quot;ext&quot;또는 &quot;pserver&quot;중 하나)</target>
        </trans-unit>
        <trans-unit id="34eb4c4ef005207e8b8f916b9f1fffacccd6945e" translate="yes" xml:space="preserve">
          <source>action</source>
          <target state="translated">action</target>
        </trans-unit>
        <trans-unit id="326b426f9ac7a96ed6baf62f8838565416d27df8" translate="yes" xml:space="preserve">
          <source>actions</source>
          <target state="translated">actions</target>
        </trans-unit>
        <trans-unit id="58d1bbce297de3c304a9fefc3b483181872a5c6b" translate="yes" xml:space="preserve">
          <source>add</source>
          <target state="translated">add</target>
        </trans-unit>
        <trans-unit id="6d8bcdb6bdc1c6a236c5092142b208eb67008cee" translate="yes" xml:space="preserve">
          <source>add &amp;lt;path&amp;gt; [&amp;lt;commit-ish&amp;gt;]</source>
          <target state="translated">&amp;lt;path&amp;gt; [&amp;lt;commit-ish&amp;gt;] 추가</target>
        </trans-unit>
        <trans-unit id="89052c7d90a34c914815c621a3c8abaf890dfcb5" translate="yes" xml:space="preserve">
          <source>add [-b &amp;lt;branch&amp;gt;] [-f|--force] [--name &amp;lt;name&amp;gt;] [--reference &amp;lt;repository&amp;gt;] [--depth &amp;lt;depth&amp;gt;] [--] &amp;lt;repository&amp;gt; [&amp;lt;path&amp;gt;]</source>
          <target state="translated">추가 [-b &amp;lt;branch&amp;gt;] [-f | --force] [--name &amp;lt;name&amp;gt;] [--reference &amp;lt;repository&amp;gt;] [--depth &amp;lt;depth&amp;gt;] [-] &amp;lt;repository&amp;gt; [&amp;lt;path &amp;gt;]</target>
        </trans-unit>
        <trans-unit id="96b545065b00a5b7501087e2c1e93926449febd5" translate="yes" xml:space="preserve">
          <source>add a missing &lt;code&gt;\n&lt;/code&gt; to the last line if necessary.</source>
          <target state="translated">필요한 경우 누락 된 &lt;code&gt;\n&lt;/code&gt; 을 마지막 줄에 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="90bc127779a3e8fd8565532d33e4a134cd45f11d" translate="yes" xml:space="preserve">
          <source>add everything under the current directory.</source>
          <target state="translated">현재 디렉토리 아래에 모든 것을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="cb81f0f2d76a3c8759a19442b315f5c3a72e8b01" translate="yes" xml:space="preserve">
          <source>add untracked</source>
          <target state="translated">추적되지 않은 추가</target>
        </trans-unit>
        <trans-unit id="c22e3f3bd42e15a0bc002a5cba9cb2e9cb547df3" translate="yes" xml:space="preserve">
          <source>add.ignore-errors (deprecated)</source>
          <target state="translated">add.ignore-errors (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="0d6211d85b6c5ebebd00bc700587b97d87d96f79" translate="yes" xml:space="preserve">
          <source>add.ignoreErrors</source>
          <target state="translated">add.ignoreErrors</target>
        </trans-unit>
        <trans-unit id="47d07ea3a984d5f17b8a52280b424c7e874d91e2" translate="yes" xml:space="preserve">
          <source>add.interactive.useBuiltin</source>
          <target state="translated">add.interactive.useBuiltin</target>
        </trans-unit>
        <trans-unit id="e441bfa1c3e8c860d35d02080c0d58234a3dc31b" translate="yes" xml:space="preserve">
          <source>addEmbeddedRepo</source>
          <target state="translated">addEmbeddedRepo</target>
        </trans-unit>
        <trans-unit id="5fba0af68b4dc6017c79ff69ba4b3844f76b2dc5" translate="yes" xml:space="preserve">
          <source>addEmptyPathspec</source>
          <target state="translated">addEmptyPathspec</target>
        </trans-unit>
        <trans-unit id="a9b80c1de3c9ac007c7c119f277608c2e2a51269" translate="yes" xml:space="preserve">
          <source>addIgnoredFile</source>
          <target state="translated">addIgnoredFile</target>
        </trans-unit>
        <trans-unit id="ceb99972d01848a4af9e45ab5cd53f0d9ea700b4" translate="yes" xml:space="preserve">
          <source>added content</source>
          <target state="translated">추가 된 내용</target>
        </trans-unit>
        <trans-unit id="782f82176de20dd76d4373d2acfc3406073964ff" translate="yes" xml:space="preserve">
          <source>adding context (&quot; &quot;) or removal (&quot;-&quot;) lines</source>
          <target state="translated">컨텍스트 ( &quot;&quot;) 또는 제거 ( &quot;-&quot;) 행 추가</target>
        </trans-unit>
        <trans-unit id="39de4cfc4c6e6827c5f11475b89460e1b545a7f9" translate="yes" xml:space="preserve">
          <source>adds the following to &lt;code&gt;.git/config&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;.git/config&lt;/code&gt; 에 다음을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="f6acb502d3f3dcf967568ec1f1f05756c7001015" translate="yes" xml:space="preserve">
          <source>advice.*</source>
          <target state="translated">advice.*</target>
        </trans-unit>
        <trans-unit id="0608c4054662dd902e1314f7e450e3eaa81c1143" translate="yes" xml:space="preserve">
          <source>agent</source>
          <target state="translated">agent</target>
        </trans-unit>
        <trans-unit id="dc642557f3a1ed15b666c3bf8c010e9d1bceffe0" translate="yes" xml:space="preserve">
          <source>alias.*</source>
          <target state="translated">alias.*</target>
        </trans-unit>
        <trans-unit id="16f3bac085c702b24dd56dd8fdf474c5d21e6639" translate="yes" xml:space="preserve">
          <source>alice and cindy can push into master, only bob can push into doc-update. david is the release manager and is the only person who can create and push version tags.</source>
          <target state="translated">alice와 cindy는 마스터로 푸시 할 수 있으며 bob 만 doc-update로 푸시 할 수 있습니다. david는 릴리스 관리자이며 버전 태그를 작성하고 푸시 할 수있는 유일한 사람입니다.</target>
        </trans-unit>
        <trans-unit id="ae21c64a87f6bb0b8e16e55c48be4cc638d7bd3f" translate="yes" xml:space="preserve">
          <source>align</source>
          <target state="translated">align</target>
        </trans-unit>
        <trans-unit id="d87c448044defb778f33158d8ccf94a20531d600" translate="yes" xml:space="preserve">
          <source>all</source>
          <target state="translated">all</target>
        </trans-unit>
        <trans-unit id="29702e41afdcf565d852a6355913f10360a2f8b0" translate="yes" xml:space="preserve">
          <source>all parent object ids</source>
          <target state="translated">모든 부모 객체 ID</target>
        </trans-unit>
        <trans-unit id="6664a4a284b9aeecc837369fce6272fe3547f795" translate="yes" xml:space="preserve">
          <source>allow-indentation-change</source>
          <target state="translated">allow-indentation-change</target>
        </trans-unit>
        <trans-unit id="890c8ad25c4c255f4dda7bba71ccde4b6eb54f1a" translate="yes" xml:space="preserve">
          <source>allows you to browse any commits from the last 2 weeks of commits that modified files under the &quot;drivers&quot; directory. (Note: you can adjust gitk&amp;rsquo;s fonts by holding down the control key while pressing &quot;-&quot; or &quot;+&quot;.)</source>
          <target state="translated">&quot;drivers&quot;디렉토리에있는 파일을 수정 한 지난 2주의 커밋에서 커밋을 찾아 볼 수 있습니다. (참고 : &quot;-&quot;또는 &quot;+&quot;를 누른 상태에서 제어 키를 누르면 gitk의 글꼴을 조정할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="8733169fb7d8912aa579031eed0a4b26ef5718fe" translate="yes" xml:space="preserve">
          <source>alternate object database</source>
          <target state="translated">대체 객체 데이터베이스</target>
        </trans-unit>
        <trans-unit id="385d97ddc2cf0f165b1e517e2de9a74c662d0d92" translate="yes" xml:space="preserve">
          <source>alternate: absolute path of alternate object databases; may appear multiple times, one line per path. Note that if the path contains non-printable characters, it may be surrounded by double-quotes and contain C-style backslashed escape sequences.</source>
          <target state="translated">대체 : 대체 객체 데이터베이스의 절대 경로. 경로당 한 줄에 여러 번 나타날 수 있습니다. 경로에 인쇄 할 수없는 문자가 포함 된 경우 큰 따옴표로 묶고 C 스타일 백 슬래시 이스케이프 시퀀스를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="459a9aeba984b09598ccfb2133b8ae65d179153d" translate="yes" xml:space="preserve">
          <source>although the full, 40-character SHA-1s would be supplied. If the foreign ref does not yet exist the &lt;code&gt;&amp;lt;remote SHA-1&amp;gt;&lt;/code&gt; will be 40 &lt;code&gt;0&lt;/code&gt;. If a ref is to be deleted, the &lt;code&gt;&amp;lt;local ref&amp;gt;&lt;/code&gt; will be supplied as &lt;code&gt;(delete)&lt;/code&gt; and the &lt;code&gt;&amp;lt;local
SHA-1&amp;gt;&lt;/code&gt; will be 40 &lt;code&gt;0&lt;/code&gt;. If the local commit was specified by something other than a name which could be expanded (such as &lt;code&gt;HEAD~&lt;/code&gt;, or a SHA-1) it will be supplied as it was originally given.</source>
          <target state="translated">전체 40 자 SHA-1이 제공되지만. 외부 참조가 아직 없으면 &lt;code&gt;&amp;lt;remote SHA-1&amp;gt;&lt;/code&gt; 은 40 &lt;code&gt;0&lt;/code&gt; 입니다. 의 Ref 삭제할 경우 &lt;code&gt;&amp;lt;local ref&amp;gt;&lt;/code&gt; 로서 공급된다 &lt;code&gt;(delete)&lt;/code&gt; 하고, &lt;code&gt;&amp;lt;local SHA-1&amp;gt;&lt;/code&gt; 40 것이다 &lt;code&gt;0&lt;/code&gt; . 로컬 커밋이 확장 될 수있는 이름 (예 : &lt;code&gt;HEAD~&lt;/code&gt; 또는 SHA-1) 이외의 이름으로 지정된 경우 원래 커밋 된대로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b16bb5afab4c1802eaeada40ac59f4ec78c01be8" translate="yes" xml:space="preserve">
          <source>always show in columns</source>
          <target state="translated">항상 열에 표시</target>
        </trans-unit>
        <trans-unit id="b0c4ba6a734338f8b0a5e21fcbb05d3afcd198af" translate="yes" xml:space="preserve">
          <source>always shows the difference between the HEAD and the index file&amp;mdash;​this is what you&amp;rsquo;d commit if you created the commit now&amp;mdash;​and that</source>
          <target state="translated">항상 HEAD와 인덱스 파일의 차이점을 보여줍니다. 지금 커밋을 만든 경우 커밋 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="96e8155732e8324ae26f64d4516eb6fe696ac84f" translate="yes" xml:space="preserve">
          <source>am</source>
          <target state="translated">am</target>
        </trans-unit>
        <trans-unit id="400226a3b8758d7d662c424a478d16cceecd29ed" translate="yes" xml:space="preserve">
          <source>am.keepcr</source>
          <target state="translated">am.keepcr</target>
        </trans-unit>
        <trans-unit id="80b11664f9cdc0c4da5b2cf9cbae91e78f24cb5f" translate="yes" xml:space="preserve">
          <source>am.threeWay</source>
          <target state="translated">am.threeWay</target>
        </trans-unit>
        <trans-unit id="d9de89ed653daadc282d17fa341547ccd80f5e0c" translate="yes" xml:space="preserve">
          <source>amWorkDir</source>
          <target state="translated">amWorkDir</target>
        </trans-unit>
        <trans-unit id="b1cc99b811681fb579eeabe4a14a5e1ec1bab455" translate="yes" xml:space="preserve">
          <source>amend the previous commit, adding all your new changes, using your original message.</source>
          <target state="translated">원래 메시지를 사용하여 모든 새 변경 사항을 추가하여 이전 커미트를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="461152b367e8ab9740fb2e9ee2da4d7175e9e2a2" translate="yes" xml:space="preserve">
          <source>an LF or a NUL when &lt;code&gt;-z&lt;/code&gt; option is used, to terminate the record.</source>
          <target state="translated">&lt;code&gt;-z&lt;/code&gt; 옵션을 사용 하는 경우 LF 또는 NUL을 사용하여 레코드를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="75eada615f3da2b986734d58bb672366de760679" translate="yes" xml:space="preserve">
          <source>an author: The name of the person responsible for this change, together with its date.</source>
          <target state="translated">저자 :이 변경을 담당하는 사람의 이름과 날짜.</target>
        </trans-unit>
        <trans-unit id="b441fe44ea3ab3bff759abb792c8a7f4c7974b0c" translate="yes" xml:space="preserve">
          <source>an entry in &lt;code&gt;BUILTIN_OBJECTS&lt;/code&gt; in the &lt;code&gt;Makefile&lt;/code&gt;.</source>
          <target state="translated">의 항목 &lt;code&gt;BUILTIN_OBJECTS&lt;/code&gt; 에서 &lt;code&gt;Makefile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d25597e1ded62863dd59e418a49b42af285a609" translate="yes" xml:space="preserve">
          <source>an entry in the &lt;code&gt;commands[]&lt;/code&gt; array in &lt;code&gt;git.c&lt;/code&gt;, and</source>
          <target state="translated">에 진입 &lt;code&gt;commands[]&lt;/code&gt; 의 배열 &lt;code&gt;git.c&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="5037f82b8aa7002eda9aed7d8c0898525bc2f00d" translate="yes" xml:space="preserve">
          <source>and Git will continue applying the rest of the patches.</source>
          <target state="translated">Git은 나머지 패치를 계속 적용합니다.</target>
        </trans-unit>
        <trans-unit id="b3b2e45f7b37ac14dc28b61e29aee3c419229fda" translate="yes" xml:space="preserve">
          <source>and Git will create the commit for you and continue applying the remaining patches from the mailbox.</source>
          <target state="translated">Git은 커밋을 만들고 메일 함의 나머지 패치를 계속 적용합니다.</target>
        </trans-unit>
        <trans-unit id="7067f391e9f25da3da4a562c780b468101adb659" translate="yes" xml:space="preserve">
          <source>and Git will prompt you for a commit message and then create the new commit. Check to make sure it looks like what you expected with</source>
          <target state="translated">Git은 커밋 메시지를 물어보고 새로운 커밋을 만듭니다. 예상대로 보이는지 확인하십시오</target>
        </trans-unit>
        <trans-unit id="11bda7867b55ea900931dbe2ab8c87a36a0443d9" translate="yes" xml:space="preserve">
          <source>and bundle topic branches still cooking.</source>
          <target state="translated">그리고 여전히 요리하는 주제 분기를 묶습니다.</target>
        </trans-unit>
        <trans-unit id="06675e26cc6f5bedf7b0e9b9d71e33fb64fa4ef8" translate="yes" xml:space="preserve">
          <source>and email them.</source>
          <target state="translated">이메일로 보내주세요.</target>
        </trans-unit>
        <trans-unit id="d5d63b233efdc161b2104f0e091d210beeb2fe60" translate="yes" xml:space="preserve">
          <source>and hack away. The equivalent of &lt;code&gt;cvs update&lt;/code&gt; is</source>
          <target state="translated">해킹. 의 등가 &lt;code&gt;cvs update&lt;/code&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="d4b59596148297f0688711ac4f92721dbc18215b" translate="yes" xml:space="preserve">
          <source>and if it detects that the file &quot;file0&quot; is completely rewritten, it changes it to:</source>
          <target state="translated">&quot;file0&quot;파일이 완전히 다시 작성된 것을 발견하면 다음과 같이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="e1426704be98b9dd3d938c5a6a31b3fe4ee9a995" translate="yes" xml:space="preserve">
          <source>and in fact a lot of the common Git command combinations can be scripted with the &lt;code&gt;git xyz&lt;/code&gt; interfaces. You can learn things by just looking at what the various git scripts do. For example, &lt;code&gt;git reset&lt;/code&gt; used to be the above two lines implemented in &lt;code&gt;git reset&lt;/code&gt;, but some things like &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt; are slightly more complex scripts around the basic Git commands.</source>
          <target state="translated">사실 많은 공통 Git 명령 조합을 &lt;code&gt;git xyz&lt;/code&gt; 인터페이스 로 스크립팅 할 수 있습니다 . 다양한 git 스크립트가하는 일만 살펴보면 사물을 배울 수 있습니다. 예를 들어, &lt;code&gt;git reset&lt;/code&gt; 은 &lt;code&gt;git reset&lt;/code&gt; 에서 구현 된 위의 두 줄 이었지만 &lt;code&gt;git status&lt;/code&gt; 및 &lt;code&gt;git commit&lt;/code&gt; 과 같은 일부 는 기본 Git 명령 주위에 약간 더 복잡한 스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="c2f880dab39040d1bcbb6d73323cfccc9f1141f6" translate="yes" xml:space="preserve">
          <source>and it is assumed unchanged.</source>
          <target state="translated">그리고 변경되지 않은 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6fdb49363e42ba495e98dac786aceef7ea588734" translate="yes" xml:space="preserve">
          <source>and it will be gone. There&amp;rsquo;s no external repository, and there&amp;rsquo;s no history outside the project you created.</source>
          <target state="translated">그리고 사라질 것입니다. 외부 리포지토리가 없으며 생성 한 프로젝트 외부에 기록이 없습니다.</target>
        </trans-unit>
        <trans-unit id="14be792a7fbd836c220980afe820c5835c201a25" translate="yes" xml:space="preserve">
          <source>and it would create the new branch &lt;code&gt;mybranch&lt;/code&gt; at the earlier commit, and check out the state at that time.</source>
          <target state="translated">이전 커밋에서 새 브랜치 &lt;code&gt;mybranch&lt;/code&gt; 를 만들고 그 당시의 상태를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="fb7e74a8bf932246eae1a7c59b5aab5d50647a84" translate="yes" xml:space="preserve">
          <source>and its path_info based equivalent</source>
          <target state="translated">그리고 그것의 path_info 기반의</target>
        </trans-unit>
        <trans-unit id="a6415488fda4ace1ca3739dceaaf3db60a5dafcb" translate="yes" xml:space="preserve">
          <source>and just looked for the sha of the missing object (4b9458b) in that whole thing. It&amp;rsquo;s up to you&amp;mdash;​Git does &lt;strong&gt;have&lt;/strong&gt; a lot of information, it is just missing one particular blob version.</source>
          <target state="translated">그리고 그 모든 것에서 빠진 물건의 샤 (4b9458b)를 찾아 보았습니다. 그것은 않는 당신이 - 힘내에게 달려 &lt;strong&gt;있습니다&lt;/strong&gt; 그것은 단지 하나의 특정 덩어리 버전을 누락 많은 정보를.</target>
        </trans-unit>
        <trans-unit id="eb603cb6e80c68fe39b18e84f04c311f5ab01061" translate="yes" xml:space="preserve">
          <source>and make the shared repository writable by the group.</source>
          <target state="translated">공유 리포지토리를 그룹이 쓰기 가능하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="40981e3225f4d7efce8a1f1ac883a144a32ed884" translate="yes" xml:space="preserve">
          <source>and once you&amp;rsquo;re happy with your manual merge, just do a</source>
          <target state="translated">수동 병합에 만족하면</target>
        </trans-unit>
        <trans-unit id="f6523905096e4cb79385536bede182fe1d21d437" translate="yes" xml:space="preserve">
          <source>and optionally give a branch-name for the remote end as a second argument.</source>
          <target state="translated">선택적으로 원격 엔드의 분기 이름을 두 번째 인수로 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="1f7c0eb7c2d3e76709e99a0799e2c00adb5d4360" translate="yes" xml:space="preserve">
          <source>and running &lt;code&gt;git config section.Subsection.key value2&lt;/code&gt; will result in</source>
          <target state="translated">&lt;code&gt;git config section.Subsection.key value2&lt;/code&gt; 를 실행 하면</target>
        </trans-unit>
        <trans-unit id="b8d13d365846b56f54fcde0e313df5ef17ad9601" translate="yes" xml:space="preserve">
          <source>and see two files:</source>
          <target state="translated">두 파일을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1846440a645e968f28127df0e1b2bcc1010c9293" translate="yes" xml:space="preserve">
          <source>and that is what higher level &lt;code&gt;git merge -s resolve&lt;/code&gt; is implemented with.</source>
          <target state="translated">이것이 상위 레벨 &lt;code&gt;git merge -s resolve&lt;/code&gt; 가 구현되는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dbbcc5be724df383b84cd8c32e02ab45353e6975" translate="yes" xml:space="preserve">
          <source>and the &quot;parent&quot; object refers to the previous commit:</source>
          <target state="translated">&quot;부모&quot;개체는 이전 커밋을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4982e2ffe4444f7d8ccaa2ccbbc307cc4fa3f8c7" translate="yes" xml:space="preserve">
          <source>and the contents of the deleted file fileX is similar enough to the contents of the created file file0, then rename detection merges these filepairs and creates:</source>
          <target state="translated">삭제 된 파일 fileX의 내용은 작성된 파일 file0의 내용과 충분히 유사하며 이름 바꾸기 감지는 이러한 파일 쌍을 병합하여 다음을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="3cf2f14796ecd3906febf042b64b0f6c0a0234bc" translate="yes" xml:space="preserve">
          <source>and the contents of these files is just the compressed data plus a header identifying their length and their type. The type is either a blob, a tree, a commit, or a tag.</source>
          <target state="translated">이 파일의 내용은 압축 된 데이터와 길이 및 유형을 식별하는 헤더입니다. 유형은 BLOB, 트리, 커밋 또는 태그입니다.</target>
        </trans-unit>
        <trans-unit id="97b7ea8f565fdb4b8f72207a4543ec3a6beb2426" translate="yes" xml:space="preserve">
          <source>and the new object name to be stored in the ref.</source>
          <target state="translated">ref에 저장 될 새로운 객체 이름.</target>
        </trans-unit>
        <trans-unit id="06596f8fbe14d561db35acf97529690afeae6531" translate="yes" xml:space="preserve">
          <source>and the result of &lt;code&gt;git merge-base A M&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;. Commit &lt;code&gt;2&lt;/code&gt; is also a common ancestor between &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;M&lt;/code&gt;, but &lt;code&gt;1&lt;/code&gt; is a better common ancestor, because &lt;code&gt;2&lt;/code&gt; is an ancestor of &lt;code&gt;1&lt;/code&gt;. Hence, &lt;code&gt;2&lt;/code&gt; is not a merge base.</source>
          <target state="translated">그리고 &lt;code&gt;git merge-base A M&lt;/code&gt; 의 결과 는 &lt;code&gt;1&lt;/code&gt; 입니다. 커밋 &lt;code&gt;2&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;M&lt;/code&gt; 사이 의 공통 조상 이지만 &lt;code&gt;2&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 의 조상 이므로 &lt;code&gt;1&lt;/code&gt; 은 더 나은 공통 조상 입니다. 따라서 &lt;code&gt;2&lt;/code&gt; 는 병합 기반이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="bf29b3f3be3e9d8f538aa9b7974f9c3a714fd3f2" translate="yes" xml:space="preserve">
          <source>and then annotate the change between the commit and its parents, using &lt;code&gt;commit^!&lt;/code&gt; notation:</source>
          <target state="translated">그리고 &lt;code&gt;commit^!&lt;/code&gt; 사용하여 커밋 과 부모 사이의 변경에 주석을 추가하십시오 . 표기법:</target>
        </trans-unit>
        <trans-unit id="3d8806f072cf60f02c7512a460d821442ce16fa0" translate="yes" xml:space="preserve">
          <source>and then giving the reason for the commit on stdin (either through redirection from a pipe or file, or by just typing it at the tty).</source>
          <target state="translated">stdin에서 커밋 이유를 제공합니다 (파이프 또는 파일에서 리디렉션하거나 tty에 입력하여).</target>
        </trans-unit>
        <trans-unit id="2fd91a322e9e060ddc98865e40de279b845a572c" translate="yes" xml:space="preserve">
          <source>and then he just cut-and-pastes the output commands after verifying that they look OK.</source>
          <target state="translated">그런 다음 출력 명령이 제대로 표시되는지 확인한 후 잘라 내기 및 붙여 넣기를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b658ed87bd1868d8fc441785cf7c93c3c281001b" translate="yes" xml:space="preserve">
          <source>and then moving BFC after BBC and squashing it.</source>
          <target state="translated">BBC 후 BFC를 옮기고 스쿼시했습니다.</target>
        </trans-unit>
        <trans-unit id="339c37a1cbc67af9c8927014dc829b0049bb4b31" translate="yes" xml:space="preserve">
          <source>and then untar the new code in the working tree. Alternately you could &lt;code&gt;rsync&lt;/code&gt; the changes into the working tree.</source>
          <target state="translated">그런 다음 작업 트리에서 새 코드를 풉니 다. 또는 변경 사항을 작업 트리로 재 &lt;code&gt;rsync&lt;/code&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="617666725e1b9f6239b44390652378dd9926ce18" translate="yes" xml:space="preserve">
          <source>and these are evaluated in this order.</source>
          <target state="translated">이것들은이 순서대로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="9adeb030984d30c37dccabf36290b3a5065c7248" translate="yes" xml:space="preserve">
          <source>and they&amp;rsquo;ll be gone. (You should only run &lt;code&gt;git prune&lt;/code&gt; on a quiescent repository&amp;mdash;​it&amp;rsquo;s kind of like doing a filesystem fsck recovery: you don&amp;rsquo;t want to do that while the filesystem is mounted. &lt;code&gt;git prune&lt;/code&gt; is designed not to cause any harm in such cases of concurrent accesses to a repository but you might receive confusing or scary messages.)</source>
          <target state="translated">그리고 그들은 사라질 것이다. (당신은 실행해야 &lt;code&gt;git prune&lt;/code&gt; 하며, 대기가이 종류의 파일 시스템 fsck를 복구하고 등의 repository-에 :. 당신은 파일 시스템이 장착되는 동안 그렇게하고 싶지 않아 &lt;code&gt;git prune&lt;/code&gt; 이러한 경우에 어떤 해를 입힐하지 않도록 설계한다 저장소에 동시에 액세스하지만 혼란 스럽거나 무서운 메시지가 표시 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="cd197c11bb84be1a5bb09ba9b42e3b50427dcfec" translate="yes" xml:space="preserve">
          <source>and this will just output the name of the resulting tree, in this case (if you have done exactly as I&amp;rsquo;ve described) it should be</source>
          <target state="translated">그리고 이것은 결과 트리의 이름을 출력합니다.이 경우 (내가 설명한대로 정확하게 수행 한 경우)</target>
        </trans-unit>
        <trans-unit id="b1af0fa00d023b5f61dc1f79856e5725ea01dd35" translate="yes" xml:space="preserve">
          <source>and thus it is really quite easy to parse for some line- and word-oriented parser (which should be quite natural for most scripting languages).</source>
          <target state="translated">따라서 일부 행 및 단어 지향 파서 (대부분의 스크립팅 언어에는 매우 자연스러운 것)를 파싱하는 것이 실제로 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="66cee198375e167a1653a383c43e2bb725e3ca7a" translate="yes" xml:space="preserve">
          <source>and use the &quot;linus&quot; keyword with &lt;code&gt;git pull&lt;/code&gt; instead of the full URL.</source>
          <target state="translated">전체 URL 대신 &lt;code&gt;git pull&lt;/code&gt; 과 함께 &quot;linus&quot;키워드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d296b286b6d11f02bc95ddc0eea6f99abc87487a" translate="yes" xml:space="preserve">
          <source>and you can now, since you told Git about the previous state of &lt;code&gt;hello&lt;/code&gt;, ask Git what has changed in the tree compared to your old index, using the &lt;code&gt;git diff-files&lt;/code&gt; command:</source>
          <target state="translated">이제 Git에게 이전 &lt;code&gt;hello&lt;/code&gt; 상태에 대해 이야기 했으므로 &lt;code&gt;git diff-files&lt;/code&gt; 명령을 사용하여 Git 에게 기존 인덱스와 비교하여 트리에서 변경된 내용을 물어보십시오 .</target>
        </trans-unit>
        <trans-unit id="c22810b9d38d8e650ac736b5ccfb992ea7f0787f" translate="yes" xml:space="preserve">
          <source>and you have now told Git to track those two files.</source>
          <target state="translated">이제 Git에게이 두 파일을 추적하라고 지시했습니다.</target>
        </trans-unit>
        <trans-unit id="7078b738b08f05f21971cffe5f9577bcab9aaf44" translate="yes" xml:space="preserve">
          <source>and you will end up with an index with all of the &amp;lt;tree1&amp;gt; entries in &quot;stage1&quot;, all of the &amp;lt;tree2&amp;gt; entries in &quot;stage2&quot; and all of the &amp;lt;tree3&amp;gt; entries in &quot;stage3&quot;. When performing a merge of another branch into the current branch, we use the common ancestor tree as &amp;lt;tree1&amp;gt;, the current branch head as &amp;lt;tree2&amp;gt;, and the other branch head as &amp;lt;tree3&amp;gt;.</source>
          <target state="translated">&quot;stage1&quot;의 모든 &amp;lt;tree1&amp;gt; 항목, &quot;stage2&quot;의 모든 &amp;lt;tree2&amp;gt; 항목 및 &quot;stage3&quot;의 모든 &amp;lt;tree3&amp;gt; 항목이있는 색인으로 끝납니다. 다른 분기를 현재 분기로 병합 할 때 공통 조상 트리를 &amp;lt;tree1&amp;gt;로, 현재 분기 헤드를 &amp;lt;tree2&amp;gt;로, 다른 분기 헤드를 &amp;lt;tree3&amp;gt;으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="17b48e857b44d8864349e98c537796214a8362f4" translate="yes" xml:space="preserve">
          <source>and your index file will now be equivalent to the tree that you saved earlier. However, that is only your 'index' file: your working directory contents have not been modified.</source>
          <target state="translated">색인 파일은 이제 이전에 저장 한 트리와 같습니다. 그러나 이는 '인덱스'파일 일뿐입니다. 작업 디렉토리 내용은 수정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="9f158fb3a1f2423d0104e077166f5b26c8204522" translate="yes" xml:space="preserve">
          <source>and your index file will now be equivalent to the tree that you saved earlier. However, that is only your &lt;code&gt;index&lt;/code&gt; file: your working directory contents have not been modified.</source>
          <target state="translated">이제 색인 파일이 이전에 저장 한 트리와 동일합니다. 그러나 이는 &lt;code&gt;index&lt;/code&gt; 파일 일뿐입니다 . 작업 디렉토리 내용은 수정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="f7df7a4e50a38db45b495588bed9a4abd67c32fe" translate="yes" xml:space="preserve">
          <source>and your repository is good again!</source>
          <target state="translated">그리고 당신의 저장소는 다시 좋습니다!</target>
        </trans-unit>
        <trans-unit id="a5230bf3ac1fc697c044aa12dc9e2fb2c6ea3dcf" translate="yes" xml:space="preserve">
          <source>and:</source>
          <target state="translated">and:</target>
        </trans-unit>
        <trans-unit id="86c8af583af4d12d1e63765efb1b3cf2c23eb581" translate="yes" xml:space="preserve">
          <source>any external helpers are named by their protocol (e.g., use &lt;code&gt;hg&lt;/code&gt; to allow the &lt;code&gt;git-remote-hg&lt;/code&gt; helper)</source>
          <target state="translated">모든 외부 헬퍼는 프로토콜에 의해 명명됩니다 (예 : &lt;code&gt;git-remote-hg&lt;/code&gt; 헬퍼 를 허용하기 위해 &lt;code&gt;hg&lt;/code&gt; 사용 )</target>
        </trans-unit>
        <trans-unit id="8fe566b6d0fcd9f8f079b9cbd5dff1c192d0bda1" translate="yes" xml:space="preserve">
          <source>any path matches itself</source>
          <target state="translated">모든 경로가 자체와 일치</target>
        </trans-unit>
        <trans-unit id="951f5c774520ac2d893d49506bb03ddb31fc70a0" translate="yes" xml:space="preserve">
          <source>api index</source>
          <target state="translated">API 인덱스</target>
        </trans-unit>
        <trans-unit id="1ac3324252e6efe491b8f90f3588d4cd0cfc38d7" translate="yes" xml:space="preserve">
          <source>api trace2</source>
          <target state="translated">API 추적 2</target>
        </trans-unit>
        <trans-unit id="37f7547fef4fd60a7d07405e2e68e608cab796d3" translate="yes" xml:space="preserve">
          <source>api-trace2</source>
          <target state="translated">api-trace2</target>
        </trans-unit>
        <trans-unit id="db43bff34c78044870bc6b1ae2aa16902bb1bb8a" translate="yes" xml:space="preserve">
          <source>append</source>
          <target state="translated">append</target>
        </trans-unit>
        <trans-unit id="69f45da1683c501696ebfa086d25192af3807dc6" translate="yes" xml:space="preserve">
          <source>apply</source>
          <target state="translated">apply</target>
        </trans-unit>
        <trans-unit id="0c2fcb1d034ab205423e1d7ec6d29da9bf89a06b" translate="yes" xml:space="preserve">
          <source>apply [--index] [-q|--quiet] [&amp;lt;stash&amp;gt;]</source>
          <target state="translated">[--index] 적용 [-q | --quiet] [&amp;lt;stash&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="41e3e8c05614ede7d2046024aa32acb852d9e90a" translate="yes" xml:space="preserve">
          <source>apply backend: When applying a patch, ignore changes in whitespace in context lines. Unfortunately, this means that if the &quot;old&quot; lines being replaced by the patch differ only in whitespace from the existing file, you will get a merge conflict instead of a successful patch application.</source>
          <target state="translated">백엔드 적용 : 패치를 적용 할 때 컨텍스트 줄의 공백 변경 사항을 무시합니다. 불행히도 이것은 패치로 대체되는 &quot;이전&quot;줄이 기존 파일과 공백 만 다를 경우 성공적인 패치 적용 대신 병합 충돌이 발생 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="03c563ce0a13a71f68c4323807b8df4dc3dd3653" translate="yes" xml:space="preserve">
          <source>apply the change that would be shown by &lt;code&gt;git show topic^&lt;/code&gt;. In this example, the patch does not apply cleanly, so information about the conflict is written to the index and working tree and no new commit results.</source>
          <target state="translated">&lt;code&gt;git show topic^&lt;/code&gt; 될 변경 사항을 적용하십시오 . 이 예에서 패치는 완전히 적용되지 않으므로 충돌에 대한 정보는 색인 및 작업 트리에 기록되며 새로운 커밋 결과는 없습니다.</target>
        </trans-unit>
        <trans-unit id="07666f4e66bd4bf8ab64d3029da991c3b016c0f9" translate="yes" xml:space="preserve">
          <source>apply them, interactively, with your sign-offs.</source>
          <target state="translated">사인 오프와 함께 대화식으로 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="c778c31b66fdb0077c39c1643484bc80e939a6ef" translate="yes" xml:space="preserve">
          <source>apply.ignoreWhitespace</source>
          <target state="translated">apply.ignoreWhitespace</target>
        </trans-unit>
        <trans-unit id="3828727a8ed2b41298eb944c27d30c630bbaecf8" translate="yes" xml:space="preserve">
          <source>apply.whitespace</source>
          <target state="translated">apply.whitespace</target>
        </trans-unit>
        <trans-unit id="e90a34fe73108d3def10c8aa75dd41cf4b8df564" translate="yes" xml:space="preserve">
          <source>applypatch-msg</source>
          <target state="translated">applypatch-msg</target>
        </trans-unit>
        <trans-unit id="6edf8749a5d3dba0628223b6880e8abfb4f10d76" translate="yes" xml:space="preserve">
          <source>araxis</source>
          <target state="translated">araxis</target>
        </trans-unit>
        <trans-unit id="8c4f0e515d3499448f3629d033cf224f688edc27" translate="yes" xml:space="preserve">
          <source>arbitrary shell command that takes a single argument (the sha1 of the commit recorded in the superproject) is executed. When &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; is set to &lt;code&gt;!command&lt;/code&gt;, the remainder after the exclamation mark is the custom command.</source>
          <target state="translated">단일 인수 (수퍼 프로젝트에 기록 된 커밋의 sha1)를 취하는 임의의 쉘 명령이 실행됩니다. 때 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 로 설정되어 &lt;code&gt;!command&lt;/code&gt; , 느낌표 후 나머지는 사용자 정의 명령입니다.</target>
        </trans-unit>
        <trans-unit id="ebfb55f4432b592119a10592e4f26272cc72359e" translate="yes" xml:space="preserve">
          <source>archive</source>
          <target state="translated">archive</target>
        </trans-unit>
        <trans-unit id="02ffa0b70f36225abe68ab3c5392918d20ddbb24" translate="yes" xml:space="preserve">
          <source>are files GIT_EXTERNAL_DIFF can use to read the contents of &amp;lt;old|new&amp;gt;,</source>
          <target state="translated">GIT_EXTERNAL_DIFF가 &amp;lt;old | new&amp;gt;의 내용을 읽는 데 사용할 수있는 파일입니다.</target>
        </trans-unit>
        <trans-unit id="f04207e23f9202de330ee8bdec5f2a1b205be329" translate="yes" xml:space="preserve">
          <source>are incompatible with the following options:</source>
          <target state="translated">다음 옵션과 호환되지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="bf5659661ce871a6788ee6b1bec9770f7f549075" translate="yes" xml:space="preserve">
          <source>are roughly equivalent.</source>
          <target state="translated">대략 동등합니다.</target>
        </trans-unit>
        <trans-unit id="bfc0acfc5f4a94969ee2f529469c80db6f5db191" translate="yes" xml:space="preserve">
          <source>are the 40-hexdigit SHA-1 hashes,</source>
          <target state="translated">40 자리 16 진수 SHA-1 해시입니다.</target>
        </trans-unit>
        <trans-unit id="377a5f0a9c724f4b4e656d090beb28e896803b78" translate="yes" xml:space="preserve">
          <source>are the octal representation of the file modes.</source>
          <target state="translated">파일 모드의 8 진 표현입니다.</target>
        </trans-unit>
        <trans-unit id="536f158f6dfd529865dcb865a97bb16804e34d70" translate="yes" xml:space="preserve">
          <source>arguments</source>
          <target state="translated">arguments</target>
        </trans-unit>
        <trans-unit id="d73d25bb51bc0192ff2858618720527615dee66a" translate="yes" xml:space="preserve">
          <source>arrange &lt;code&gt;git push&lt;/code&gt; to push all local branches to their corresponding branch of the mothership machine.</source>
          <target state="translated">모든 현지 지점을 모선 기계의 해당 지점으로 푸시 하도록 &lt;code&gt;git push&lt;/code&gt; 를 정렬 하십시오.</target>
        </trans-unit>
        <trans-unit id="7dc74bb7dc6b2238e853c884d0d310e31daffb87" translate="yes" xml:space="preserve">
          <source>as long as the shared repository does not have any branches other than &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">공유 리포지토리에 &lt;code&gt;master&lt;/code&gt; 이외의 분기가없는 한 .</target>
        </trans-unit>
        <trans-unit id="cb2841c784dffc3f3e69b38c87cb3ad64f719624" translate="yes" xml:space="preserve">
          <source>as they are probably more user specific than repository specific. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for more information about this.</source>
          <target state="translated">리포지토리에 비해 사용자에 따라 다를 수 있습니다. 이에 대한 자세한 내용은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ec09624f8bf140a91e574552f4201e093095f93f" translate="yes" xml:space="preserve">
          <source>ask each</source>
          <target state="translated">각각 물어보세요</target>
        </trans-unit>
        <trans-unit id="a4da794aacaf85856a7722c9d864566d302089fc" translate="yes" xml:space="preserve">
          <source>at this point the two branches have diverged, with different changes made in each. To merge the changes made in experimental into master, run</source>
          <target state="translated">이 시점에서 두 가지 지점이 각각 다른 변경 사항으로 분기되었습니다. 실험에서 변경 한 내용을 마스터로 병합하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="56cb56551e60df919190b545acc4efd3487df2da" translate="yes" xml:space="preserve">
          <source>at-open-brace &lt;code&gt;@{&lt;/code&gt; is used as a notation to access a reflog entry.</source>
          <target state="translated">at-open-brace &lt;code&gt;@{&lt;/code&gt; 는 참조 로그 항목에 액세스하기위한 표기법으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c6f57180e462a4f1e9de24fbe811cfb2c24a0cf9" translate="yes" xml:space="preserve">
          <source>atom</source>
          <target state="translated">atom</target>
        </trans-unit>
        <trans-unit id="fc88c6b3cc380853de27e44642207df9743ff63d" translate="yes" xml:space="preserve">
          <source>attr</source>
          <target state="translated">attr</target>
        </trans-unit>
        <trans-unit id="c0357eb71b4a8821fe200d8b8eb01baef86fac5a" translate="yes" xml:space="preserve">
          <source>author date (format respects --date= option)</source>
          <target state="translated">작성자 날짜 (형식에 따라 --date = 옵션)</target>
        </trans-unit>
        <trans-unit id="2a06a73ff8fc368a2739a3e178ba7f2389794fbb" translate="yes" xml:space="preserve">
          <source>author date, ISO 8601-like format</source>
          <target state="translated">작성자 날짜, ISO 8601과 같은 형식</target>
        </trans-unit>
        <trans-unit id="242b07f5f5075eaa7fd5b51606a9b4162ff6c885" translate="yes" xml:space="preserve">
          <source>author date, RFC2822 style</source>
          <target state="translated">작성자 날짜, RFC2822 스타일</target>
        </trans-unit>
        <trans-unit id="203f076a8dfae351b5cbfcddc2f39e2529b4ab40" translate="yes" xml:space="preserve">
          <source>author date, UNIX timestamp</source>
          <target state="translated">작성자 날짜, UNIX 타임 스탬프</target>
        </trans-unit>
        <trans-unit id="5b659229f527fa360f4003ca474cb9646e5df53b" translate="yes" xml:space="preserve">
          <source>author date, relative</source>
          <target state="translated">저자 날짜, 상대</target>
        </trans-unit>
        <trans-unit id="d04a676256ca4278418fc83a6c6099b60b59d9c4" translate="yes" xml:space="preserve">
          <source>author date, short format (&lt;code&gt;YYYY-MM-DD&lt;/code&gt;)</source>
          <target state="translated">저자 날짜, 짧은 형식 ( &lt;code&gt;YYYY-MM-DD&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ca050c864ebffd969007968bf223faf21875eae7" translate="yes" xml:space="preserve">
          <source>author date, strict ISO 8601 format</source>
          <target state="translated">작성자 날짜, 엄격한 ISO 8601 형식</target>
        </trans-unit>
        <trans-unit id="7ddbfb879a548122c7fc198acb1c1b2f4c9b9921" translate="yes" xml:space="preserve">
          <source>author email</source>
          <target state="translated">저자 이메일</target>
        </trans-unit>
        <trans-unit id="8edafcfb5bfb68f54b13aeb0dafbb6187a753701" translate="yes" xml:space="preserve">
          <source>author email (respecting .mailmap, see &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; or &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;)</source>
          <target state="translated">작성자 이메일 (.mailmap 존중, &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-blame&quot;&gt;git-blame [1] 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="83daf4aca33631f2eb4acd6a25a656b0af3f5ee2" translate="yes" xml:space="preserve">
          <source>author email local-part (the part before the &lt;code&gt;@&lt;/code&gt; sign)</source>
          <target state="translated">작성자 이메일 로컬 부분 ( &lt;code&gt;@&lt;/code&gt; 기호 앞 부분 )</target>
        </trans-unit>
        <trans-unit id="5d4130a7bcbeec5d4a298b1e471f17266d9c3b2a" translate="yes" xml:space="preserve">
          <source>author local-part (see &lt;code&gt;%al&lt;/code&gt;) respecting .mailmap, see &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; or &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;)</source>
          <target state="translated">.mailmap과 관련하여 local-part ( &lt;code&gt;%al&lt;/code&gt; 참조 )를 작성하십시오 ( &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-blame&quot;&gt;git-blame [1] 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a38923d0b44faf2fd760ba1064fa8cccf3161910" translate="yes" xml:space="preserve">
          <source>author local-part (see &lt;code&gt;%cl&lt;/code&gt;) respecting .mailmap, see &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; or &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;)</source>
          <target state="translated">.mailmap과 관련하여 local-part ( &lt;code&gt;%cl&lt;/code&gt; 참조 )를 작성하십시오 ( &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-blame&quot;&gt;git-blame [1] 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="c377e3db13b17a5dec490aa3f6ac58e35bd02ae8" translate="yes" xml:space="preserve">
          <source>author name</source>
          <target state="translated">저자 이름</target>
        </trans-unit>
        <trans-unit id="bd2cf54c8d8427c36e72436dee6f5edfa55f4e21" translate="yes" xml:space="preserve">
          <source>author name (respecting .mailmap, see &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; or &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;)</source>
          <target state="translated">작성자 이름 (.mailmap 존중, &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-blame&quot;&gt;git-blame [1] 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="aa42d4b548d53eeb1e514e0662eb0b64c3782193" translate="yes" xml:space="preserve">
          <source>author name, email and date</source>
          <target state="translated">저자 이름, 이메일 및 날짜</target>
        </trans-unit>
        <trans-unit id="d00ed3c485ca1a6ad6088b1642369eb27039d0b8" translate="yes" xml:space="preserve">
          <source>author.email</source>
          <target state="translated">author.email</target>
        </trans-unit>
        <trans-unit id="290b3c3f6920221191e3db343ad6fbf3a2f939e8" translate="yes" xml:space="preserve">
          <source>author.name</source>
          <target state="translated">author.name</target>
        </trans-unit>
        <trans-unit id="9c3bb49ffea1144231cbe02d904b8d9018744e9d" translate="yes" xml:space="preserve">
          <source>avatar</source>
          <target state="translated">avatar</target>
        </trans-unit>
        <trans-unit id="0bb01d8924d6b902321a6c09d5c0a45ab1342655" translate="yes" xml:space="preserve">
          <source>b) independent fixup</source>
          <target state="translated">b) 독립 픽스 업</target>
        </trans-unit>
        <trans-unit id="aeca33ec4bf9a7bd6b90cc303f5a8ac32af312c1" translate="yes" xml:space="preserve">
          <source>backport a critical fix.</source>
          <target state="translated">중요한 수정 사항을 백 포트하십시오.</target>
        </trans-unit>
        <trans-unit id="fe676f1ea27d4114d62d0b88a9999860d1c162c1" translate="yes" xml:space="preserve">
          <source>bare repository</source>
          <target state="translated">베어 리포지토리</target>
        </trans-unit>
        <trans-unit id="e95c0d71e5a737bfc209f7013e45e233a7480a96" translate="yes" xml:space="preserve">
          <source>base-name</source>
          <target state="translated">base-name</target>
        </trans-unit>
        <trans-unit id="5b2505039ac5af9e197f5dad04113906a9cf9a2a" translate="yes" xml:space="preserve">
          <source>bc</source>
          <target state="translated">bc</target>
        </trans-unit>
        <trans-unit id="3c2369c6416caa1993808240594282dd4fcb95c1" translate="yes" xml:space="preserve">
          <source>bc3</source>
          <target state="translated">bc3</target>
        </trans-unit>
        <trans-unit id="b7c7d5d4b182d06d7f89fcb3d277474733c67444" translate="yes" xml:space="preserve">
          <source>be quiet if files exist or are not in the index</source>
          <target state="translated">파일이 있거나 색인에없는 경우 조용히</target>
        </trans-unit>
        <trans-unit id="bfa1cf02635b780783c9853aaca57e1c719e79ad" translate="yes" xml:space="preserve">
          <source>because the hostnames differ. Nor would it match &lt;code&gt;foo.example.com&lt;/code&gt;; Git compares hostnames exactly, without considering whether two hosts are part of the same domain. Likewise, a config entry for &lt;code&gt;http://example.com&lt;/code&gt; would not match: Git compares the protocols exactly.</source>
          <target state="translated">호스트 이름이 다르기 때문입니다. &lt;code&gt;foo.example.com&lt;/code&gt; 과도 일치하지 않습니다 . Git은 두 호스트가 동일한 도메인의 일부인지 여부를 고려하지 않고 호스트 이름을 정확하게 비교합니다. 마찬가지로 &lt;code&gt;http://example.com&lt;/code&gt; 의 구성 항목 이 일치하지 않습니다. Git은 프로토콜을 정확하게 비교합니다.</target>
        </trans-unit>
        <trans-unit id="bd766456dd7d080025c5f2a3029a29c2bb5419ef" translate="yes" xml:space="preserve">
          <source>because the hostnames differ. Nor would it match &lt;code&gt;foo.example.com&lt;/code&gt;; Git compares hostnames exactly, without considering whether two hosts are part of the same domain. Likewise, a config entry for &lt;code&gt;http://example.com&lt;/code&gt; would not match: Git compares the protocols exactly. However, you may use wildcards in the domain name and other pattern matching techniques as with the &lt;code&gt;http.&amp;lt;url&amp;gt;.*&lt;/code&gt; options.</source>
          <target state="translated">호스트 이름이 다르기 때문입니다. &lt;code&gt;foo.example.com&lt;/code&gt; 과도 일치하지 않습니다 . Git은 두 호스트가 동일한 도메인의 일부인지 여부를 고려하지 않고 호스트 이름을 정확하게 비교합니다. 마찬가지로 &lt;code&gt;http://example.com&lt;/code&gt; 의 구성 항목은 일치하지 않습니다. Git은 프로토콜을 정확히 비교합니다. 그러나 &lt;code&gt;http.&amp;lt;url&amp;gt;.*&lt;/code&gt; 옵션 에서와 같이 도메인 이름 및 기타 패턴 일치 기술에 와일드 카드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c02ceb78ff4863ee1a75d232c4f53af56b182ec9" translate="yes" xml:space="preserve">
          <source>becomes:</source>
          <target state="translated">becomes:</target>
        </trans-unit>
        <trans-unit id="7e57cfe843145135aee1f4d0d63ceb7842093712" translate="yes" xml:space="preserve">
          <source>binary</source>
          <target state="translated">binary</target>
        </trans-unit>
        <trans-unit id="fc5afa849d013727d8acf30682a03a891f7aca7e" translate="yes" xml:space="preserve">
          <source>bisect</source>
          <target state="translated">bisect</target>
        </trans-unit>
        <trans-unit id="e04a67a1c220ec3759550df9a963521323148d66" translate="yes" xml:space="preserve">
          <source>blame</source>
          <target state="translated">blame</target>
        </trans-unit>
        <trans-unit id="72092ff956b5b07bf4d598501177651a9897b3f1" translate="yes" xml:space="preserve">
          <source>blame.blankBoundary</source>
          <target state="translated">blame.blankBoundary</target>
        </trans-unit>
        <trans-unit id="2862b4a0ea76b67385f8581e3bd4cf75e32e65d0" translate="yes" xml:space="preserve">
          <source>blame.coloring</source>
          <target state="translated">blame.coloring</target>
        </trans-unit>
        <trans-unit id="c55af0af464fc28e395cedf375c27ed38ea08dd7" translate="yes" xml:space="preserve">
          <source>blame.date</source>
          <target state="translated">blame.date</target>
        </trans-unit>
        <trans-unit id="574525f7353221a33787a1a7d1232b7faf51b9bb" translate="yes" xml:space="preserve">
          <source>blame.ignoreRevsFile</source>
          <target state="translated">blame.ignoreRevsFile</target>
        </trans-unit>
        <trans-unit id="8d9e3a327869e356dde043a93aea128672ec4a32" translate="yes" xml:space="preserve">
          <source>blame.markIgnoredLines</source>
          <target state="translated">blame.markIgnoredLines</target>
        </trans-unit>
        <trans-unit id="96c64bfbb0487dbb1fe121cc068a07b1b6f2001d" translate="yes" xml:space="preserve">
          <source>blame.markUnblamables</source>
          <target state="translated">blame.markUnblamables</target>
        </trans-unit>
        <trans-unit id="244ba240ca074db6d0f0d4bb8de34505a6383151" translate="yes" xml:space="preserve">
          <source>blame.showEmail</source>
          <target state="translated">blame.showEmail</target>
        </trans-unit>
        <trans-unit id="f2560ddc149bc689a9eb1559b1e046e4885feda7" translate="yes" xml:space="preserve">
          <source>blame.showRoot</source>
          <target state="translated">blame.showRoot</target>
        </trans-unit>
        <trans-unit id="3bc20f9fcb1740f5d09c92cd6bf8bd32d164c6ae" translate="yes" xml:space="preserve">
          <source>blame_incremental</source>
          <target state="translated">blame_incremental</target>
        </trans-unit>
        <trans-unit id="0fd0bcfb44f83e7d5ac7a8922578276b9af48746" translate="yes" xml:space="preserve">
          <source>blob</source>
          <target state="translated">blob</target>
        </trans-unit>
        <trans-unit id="815675cd53e5196255182a0fd392e03df0fcd193" translate="yes" xml:space="preserve">
          <source>blob object</source>
          <target state="translated">얼룩 개체</target>
        </trans-unit>
        <trans-unit id="751eae742e521df559ef7ed559fa3259d5b09b0d" translate="yes" xml:space="preserve">
          <source>blob_plain</source>
          <target state="translated">blob_plain</target>
        </trans-unit>
        <trans-unit id="c06f874d67ebcdd1994d59e3867ceb303b9b6698" translate="yes" xml:space="preserve">
          <source>blobdiff</source>
          <target state="translated">blobdiff</target>
        </trans-unit>
        <trans-unit id="f7d5b2b95861daea9933ef0a243f733bbc79235e" translate="yes" xml:space="preserve">
          <source>blocks</source>
          <target state="translated">blocks</target>
        </trans-unit>
        <trans-unit id="02083f4579e08a612425c0c1a17ee47add783b94" translate="yes" xml:space="preserve">
          <source>body</source>
          <target state="translated">body</target>
        </trans-unit>
        <trans-unit id="48647474b89fa8f56ed6bda0f8148a17b51b97bd" translate="yes" xml:space="preserve">
          <source>boolean</source>
          <target state="translated">boolean</target>
        </trans-unit>
        <trans-unit id="f6edb368393f0758009b3afd170f648a63e11385" translate="yes" xml:space="preserve">
          <source>both &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; are merge-bases of A and B. Neither one is better than the other (both are &lt;code&gt;best&lt;/code&gt; merge bases). When the &lt;code&gt;--all&lt;/code&gt; option is not given, it is unspecified which best one is output.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;2&lt;/code&gt; 는 모두 A와 B의 병합 기반입니다. 둘 중 어느 것도 다른 것보다 낫습니다 (둘 다 &lt;code&gt;best&lt;/code&gt; 병합 기준입니다). 때 &lt;code&gt;--all&lt;/code&gt; 옵션이 주어지지 않는, 출력에 가장 잘 한 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab885ad5b5ecb443f904caddcf71de38ec2ad4fc" translate="yes" xml:space="preserve">
          <source>both from a symlink following standpoint &lt;strong&gt;and&lt;/strong&gt; an error checking standpoint. The &quot;refs/&quot; rule for symlinks means that symlinks that point to &quot;outside&quot; the tree are safe: they&amp;rsquo;ll be followed for reading but not for writing (so we&amp;rsquo;ll never write through a ref symlink to some other tree, if you have copied a whole archive by creating a symlink tree).</source>
          <target state="translated">다음에 나오는 심볼릭 링크 &lt;strong&gt;와&lt;/strong&gt; 오류 확인 관점에서. 심볼릭 링크에 대한 &quot;refs /&quot;규칙은 트리의 &quot;외부&quot;를 가리키는 심볼릭 링크가 안전하다는 것을 의미합니다. 읽기 전용이지만 쓰기 용이 아닙니다 (따라서 다른 트리에 대한 참조 심볼릭 링크를 통해 쓰지 않습니다) 심볼릭 링크 트리를 만들어 전체 아카이브를 복사했습니다.</target>
        </trans-unit>
        <trans-unit id="10d735e581f1e2505cd69675691925490e447c44" translate="yes" xml:space="preserve">
          <source>branch</source>
          <target state="translated">branch</target>
        </trans-unit>
        <trans-unit id="d9ebdce6e5eb5490d2736b1657cb3bbdff2a24c8" translate="yes" xml:space="preserve">
          <source>branch &amp;lt;branchname&amp;gt; [&amp;lt;stash&amp;gt;]</source>
          <target state="translated">분기 &amp;lt;branchname&amp;gt; [&amp;lt;stash&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="4d89d47c3496bed1c997cfd4749bbb345956b062" translate="yes" xml:space="preserve">
          <source>branch name: refers to the commit at the head of the given branch</source>
          <target state="translated">지점 이름 : 주어진 지점의 머리에서 커밋을 나타냅니다</target>
        </trans-unit>
        <trans-unit id="7cf9cb4f1f0d11974da193a921ad56188af0dbfb" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.description</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.description</target>
        </trans-unit>
        <trans-unit id="c972b8f442dc56f76ff5821861f38f9df9f740a2" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.merge</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.merge</target>
        </trans-unit>
        <trans-unit id="12b705785a619a7af3091b413cd10bc5f913cd36" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.mergeOptions</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.mergeOptions</target>
        </trans-unit>
        <trans-unit id="e3044fee5f265c567fa94779be6a4b05485a2ef5" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.pushRemote</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.pushRemote</target>
        </trans-unit>
        <trans-unit id="089608ebf4ab438938386db74054dd0539e68174" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.rebase</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.rebase</target>
        </trans-unit>
        <trans-unit id="ae2da89c53e9406d5454991c9de79d2701626513" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.remote</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.remote</target>
        </trans-unit>
        <trans-unit id="c1beb4d53b0941d5b69587d5619ae40af0e82fb0" translate="yes" xml:space="preserve">
          <source>branch.autoSetupMerge</source>
          <target state="translated">branch.autoSetupMerge</target>
        </trans-unit>
        <trans-unit id="a348d9eb171112632f68ea4fa0280f35b7af36d9" translate="yes" xml:space="preserve">
          <source>branch.autoSetupRebase</source>
          <target state="translated">branch.autoSetupRebase</target>
        </trans-unit>
        <trans-unit id="c4907ecf78c64eedfc547e343a00efb0d648c80c" translate="yes" xml:space="preserve">
          <source>branch.sort</source>
          <target state="translated">branch.sort</target>
        </trans-unit>
        <trans-unit id="52a9ce4a0d3c21f1c0c5dc576930fbb59ad74018" translate="yes" xml:space="preserve">
          <source>branches</source>
          <target state="translated">branches</target>
        </trans-unit>
        <trans-unit id="ef98362b8a6b0c8cd804b0d227aa1ffeaba89786" translate="yes" xml:space="preserve">
          <source>browser</source>
          <target state="translated">browser</target>
        </trans-unit>
        <trans-unit id="d7b49d5666ac0fe3243cf929f3fbea5d40512cc5" translate="yes" xml:space="preserve">
          <source>browser.&amp;lt;tool&amp;gt;.cmd</source>
          <target state="translated">browser.&amp;lt;tool&amp;gt;.cmd</target>
        </trans-unit>
        <trans-unit id="1afa7a8068dc2826b24730832089e6b8ae806f4d" translate="yes" xml:space="preserve">
          <source>browser.&amp;lt;tool&amp;gt;.path</source>
          <target state="translated">browser.&amp;lt;tool&amp;gt;.path</target>
        </trans-unit>
        <trans-unit id="ce3731defbdc7875cff0c020e900192d6b65542c" translate="yes" xml:space="preserve">
          <source>bugreport</source>
          <target state="translated">bugreport</target>
        </trans-unit>
        <trans-unit id="26a194e96e2873f688a8836d3ee9bd5e7be08547" translate="yes" xml:space="preserve">
          <source>built-in values (some set during build stage),</source>
          <target state="translated">내장 값 (빌드 단계 중 일부 설정)</target>
        </trans-unit>
        <trans-unit id="7581496de8d7f905da83e60fe5216caab582c109" translate="yes" xml:space="preserve">
          <source>bumping format version numbers of individual data files (e.g., index, packfiles, etc). This restricts the incompatibilities only to those files.</source>
          <target state="translated">개별 데이터 파일의 범핑 형식 버전 번호 (예 : 색인, 팩 파일 등). 이렇게하면 비 호환성이 해당 파일로만 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="d59795de8a4d83834e525b589b2bb0c12e4542c1" translate="yes" xml:space="preserve">
          <source>bundle</source>
          <target state="translated">bundle</target>
        </trans-unit>
        <trans-unit id="c8bebbf42f3ec7d29b62f6981d42b56fa9e07016" translate="yes" xml:space="preserve">
          <source>but can be used to amend a merge commit.</source>
          <target state="translated">병합 커밋을 수정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0e9a8eb5c66f16a9e8325bbfe07678355605d3b" translate="yes" xml:space="preserve">
          <source>but if $REV is empty, the commit object name from master will be printed.</source>
          <target state="translated">그러나 $ REV가 비어 있으면 master의 커밋 개체 이름이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="d086642ebaf2071be1a4671ed3801412d03ee7ac" translate="yes" xml:space="preserve">
          <source>but that may become cumbersome, when you have many attributes. Using macro attributes, you can define an attribute that, when set, also sets or unsets a number of other attributes at the same time. The system knows a built-in macro attribute, &lt;code&gt;binary&lt;/code&gt;:</source>
          <target state="translated">하지만 속성이 많을 경우 번거로울 수 있습니다. 매크로 속성을 사용하면 설정시 여러 다른 속성을 동시에 설정 또는 설정 해제하는 속성을 정의 할 수 있습니다. 시스템은 내장 매크로 속성 인 &lt;code&gt;binary&lt;/code&gt; 를 알고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b354ac610248436418f0a768b2a238f599b63512" translate="yes" xml:space="preserve">
          <source>but that may sometimes help you guess which tags might come after the given commit.</source>
          <target state="translated">그러나 때로는 주어진 커밋 후에 어떤 태그가 올지 추측하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="481514e03c29bd6e6c21bcf330cca66f7a8e5e03" translate="yes" xml:space="preserve">
          <source>but the command invocation was &lt;code&gt;git diff-files myfile&lt;/code&gt;, then the junkfile entry would be removed from the list because only &quot;myfile&quot; is under consideration.</source>
          <target state="translated">그러나 명령 호출은 &lt;code&gt;git diff-files myfile&lt;/code&gt; 이며, &quot;myfile&quot;만 고려 중이므로 정크 파일 항목이 목록에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9a4d92b29b4ea9cb527dbdd917995ee8e6390c1d" translate="yes" xml:space="preserve">
          <source>but this time instead of immediately making the commit, let&amp;rsquo;s take an intermediate step, and ask for diffs along the way to keep track of what&amp;rsquo;s happening:</source>
          <target state="translated">그러나 이번에는 커밋을 즉시 수행하는 대신 중간 단계를 수행하고 진행 상황을 추적하기 위해 diffs를 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="4a4c509be280ffc999d52daf10f3af16adbf10ad" translate="yes" xml:space="preserve">
          <source>but to avoid common mistakes with filename globbing etc., the command will not normally add totally new entries or remove old entries, i.e. it will normally just update existing cache entries.</source>
          <target state="translated">그러나 파일 이름 globbing 등과 같은 일반적인 실수를 피하기 위해 명령은 일반적으로 완전히 새로운 항목을 추가하거나 오래된 항목을 제거하지 않습니다. 즉, 일반적으로 기존 캐시 항목을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="0c8f2a0a85b88cfa647434356130399dff07d5d7" translate="yes" xml:space="preserve">
          <source>but with the algorithm used by git bisect we get:</source>
          <target state="translated">그러나 git bisect에서 사용하는 알고리즘으로 다음을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="08885cdf79de4806bc91b025b32f3b00703dcf8c" translate="yes" xml:space="preserve">
          <source>by listing files as arguments to the &lt;code&gt;commit&lt;/code&gt; command (without --interactive or --patch switch), in which case the commit will ignore changes staged in the index, and instead record the current content of the listed files (which must already be known to Git);</source>
          <target state="translated">--interactive 또는 --patch 스위치없이 &lt;code&gt;commit&lt;/code&gt; 명령 에 대한 인수로 파일을 나열 함으로써 커밋은 인덱스에서 단계 화 된 변경 사항을 무시하고 대신 나열된 파일의 현재 내용을 기록합니다 (이미 알고 있어야 함) 힘내);</target>
        </trans-unit>
        <trans-unit id="3836fcf09d79e41b99edac70e256133efc12bff7" translate="yes" xml:space="preserve">
          <source>by moving the &quot;pick 4&quot; line will result in the following history:</source>
          <target state="translated">&quot;pick 4&quot;줄을 이동하면 다음과 같은 기록이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="906ba5e6f6707165a9878468ec60f33a2ff34b96" translate="yes" xml:space="preserve">
          <source>by using &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to incrementally &quot;add&quot; changes to the index before using the &lt;code&gt;commit&lt;/code&gt; command (Note: even modified files must be &quot;added&quot;);</source>
          <target state="translated">하여 &lt;a href=&quot;git-add&quot;&gt;자식 합산 [1]을&lt;/a&gt; 점진적으로 사용하기 전에 인덱스를 변경 &quot;추가&quot; &lt;code&gt;commit&lt;/code&gt; 명령 (참고 :에도 수정 된 파일이 &quot;추가&quot;해야한다);</target>
        </trans-unit>
        <trans-unit id="e48f31443a096bff3238667996c3f171f13b5f0c" translate="yes" xml:space="preserve">
          <source>by using &lt;a href=&quot;git-rm&quot;&gt;git-rm[1]&lt;/a&gt; to remove files from the working tree and the index, again before using the &lt;code&gt;commit&lt;/code&gt; command;</source>
          <target state="translated">사용하여 &lt;a href=&quot;git-rm&quot;&gt;자식-RM [1]을&lt;/a&gt; 작업 트리와 인덱스 파일을 제거하고, 다시는 사용하기 전에 &lt;code&gt;commit&lt;/code&gt; 명령을;</target>
        </trans-unit>
        <trans-unit id="093a3f97e95959ebe22524ee0ce832b0babc748b" translate="yes" xml:space="preserve">
          <source>by using the --interactive or --patch switches with the &lt;code&gt;commit&lt;/code&gt; command to decide one by one which files or hunks should be part of the commit in addition to contents in the index, before finalizing the operation. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate these modes.</source>
          <target state="translated">&lt;code&gt;commit&lt;/code&gt; 명령 과 함께 --interactive 또는 --patch 스위치를 사용 하여 작업을 완료하기 전에 색인의 내용 외에 파일 또는 덩어리가 커밋의 일부 여야하는 파일을 하나씩 결정합니다. 이러한 모드를 작동하는 방법을 알아 보려면 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 의 &quot;대화식 모드&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4834ad1b53b94300bc089b00aaeed76c52aebbcd" translate="yes" xml:space="preserve">
          <source>by using the -a switch with the &lt;code&gt;commit&lt;/code&gt; command to automatically &quot;add&quot; changes from all known files (i.e. all files that are already listed in the index) and to automatically &quot;rm&quot; files in the index that have been removed from the working tree, and then perform the actual commit;</source>
          <target state="translated">&lt;code&gt;commit&lt;/code&gt; 명령 과 함께 -a 스위치를 사용하여 알려진 모든 파일 (예 : 색인에 이미 나열된 모든 파일)의 변경 사항을 자동으로 &quot;추가&quot;하고 작업 트리에서 제거 된 색인의 파일을 자동으로 &quot;rm&quot;로 설정 그런 다음 실제 커밋을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b03592806efabfeeb709f5a70a7c172669b00538" translate="yes" xml:space="preserve">
          <source>cache</source>
          <target state="translated">cache</target>
        </trans-unit>
        <trans-unit id="0c93713c1e43fccf897b7b4f02e822c65d557fdf" translate="yes" xml:space="preserve">
          <source>cached</source>
          <target state="translated">cached</target>
        </trans-unit>
        <trans-unit id="9eafea1e818b36cfe83084dbfcee79ccb268deb8" translate="yes" xml:space="preserve">
          <source>cancel the cherry-pick. In other words, return to the pre-cherry-pick state, preserving any local modifications you had in the working tree.</source>
          <target state="translated">체리 픽을 취소하십시오. 다시 말해, 작업 트리에있는 로컬 수정 사항을 유지하면서 체리 선택 이전 상태로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="21ca164274e6e0b587a5c99674b651b198887373" translate="yes" xml:space="preserve">
          <source>cat-blob</source>
          <target state="translated">cat-blob</target>
        </trans-unit>
        <trans-unit id="1b0b597309b09f88e890e96ee25a4239e209bcc6" translate="yes" xml:space="preserve">
          <source>cat-blob-fd</source>
          <target state="translated">cat-blob-fd</target>
        </trans-unit>
        <trans-unit id="1b860f3f13df1c0a7cb167ae98ab823bd793ef37" translate="yes" xml:space="preserve">
          <source>cat-file</source>
          <target state="translated">cat-file</target>
        </trans-unit>
        <trans-unit id="6bdc4dd4748a2bfb630e761b44a4eee74e5812c1" translate="yes" xml:space="preserve">
          <source>category (or &lt;code&gt;gitweb.category&lt;/code&gt;)</source>
          <target state="translated">카테고리 (또는 &lt;code&gt;gitweb.category&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d027a2f7150c9c1d54212c981331ced097d02521" translate="yes" xml:space="preserve">
          <source>cd_to_toplevel</source>
          <target state="translated">cd_to_toplevel</target>
        </trans-unit>
        <trans-unit id="2cf64e447b84b497b2491b7af072a229eefe2651" translate="yes" xml:space="preserve">
          <source>chain</source>
          <target state="translated">chain</target>
        </trans-unit>
        <trans-unit id="eea15bfc0410c3d01d0daf4a8e336e46da972ca0" translate="yes" xml:space="preserve">
          <source>changeset</source>
          <target state="translated">changeset</target>
        </trans-unit>
        <trans-unit id="60863ff2c00bd434be8f30a313cc6bf530d01628" translate="yes" xml:space="preserve">
          <source>check the branch names in an external repository (if not known).</source>
          <target state="translated">외부 저장소에서 분기 이름을 확인하십시오 (알 수없는 경우).</target>
        </trans-unit>
        <trans-unit id="1f1c087ebd5ee9330247a27b3cb5e1c3309d1b49" translate="yes" xml:space="preserve">
          <source>check-ignore</source>
          <target state="translated">check-ignore</target>
        </trans-unit>
        <trans-unit id="d5491e7e7124a22dd73fa746ba129c59f9dc6d5d" translate="yes" xml:space="preserve">
          <source>checkout</source>
          <target state="translated">checkout</target>
        </trans-unit>
        <trans-unit id="f1d6e05726e233a2ab8de16435d659a28a2e35a7" translate="yes" xml:space="preserve">
          <source>checkout a new branch &lt;code&gt;mine&lt;/code&gt; from master.</source>
          <target state="translated">마스터로부터 새로운 &lt;code&gt;mine&lt;/code&gt; 를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="baa127da3b2e7bb80d470a5c5b3ed484fc3ecffa" translate="yes" xml:space="preserve">
          <source>checkout-index</source>
          <target state="translated">checkout-index</target>
        </trans-unit>
        <trans-unit id="77ccc4847f3f5995981f07a9aaa766d505e363d0" translate="yes" xml:space="preserve">
          <source>checkout.defaultRemote</source>
          <target state="translated">checkout.defaultRemote</target>
        </trans-unit>
        <trans-unit id="dede2b7b3445b7f569a7e102150c9e77ea7be895" translate="yes" xml:space="preserve">
          <source>checkout.guess</source>
          <target state="translated">checkout.guess</target>
        </trans-unit>
        <trans-unit id="7993ca6fc917dfcd7447613538a9f2529705f4e5" translate="yes" xml:space="preserve">
          <source>checkoutAmbiguousRemoteBranchName</source>
          <target state="translated">checkoutAmbiguousRemoteBranchName</target>
        </trans-unit>
        <trans-unit id="9c92181fd5e68d410f28e18265218b8c3a8a1b78" translate="yes" xml:space="preserve">
          <source>checks if the current directory is within the working tree of the repository, and otherwise dies.</source>
          <target state="translated">현재 디렉토리가 저장소의 작업 트리 내에 있는지 확인하고 그렇지 않으면 사망합니다.</target>
        </trans-unit>
        <trans-unit id="2e41d31ec807e404264bdbe4cf0898e0675b3d63" translate="yes" xml:space="preserve">
          <source>checks if the working tree associated with the repository exists, and otherwise dies. Often done before calling cd_to_toplevel, which is impossible to do if there is no working tree.</source>
          <target state="translated">저장소와 연관된 작업 트리가 존재하는지 확인하고 그렇지 않으면 사망합니다. cd_to_toplevel을 호출하기 전에 수행되는 작업 트리가없는 경우에는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="6ce38e1ed1561eb51f91bed4e5b8b42001fa1cda" translate="yes" xml:space="preserve">
          <source>checks out all files in the index. Cannot be used together with explicit filenames.</source>
          <target state="translated">색인의 모든 파일을 체크 아웃합니다. 명시적인 파일 이름과 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b095764396dd7603ab632901ad86334026f5e97f" translate="yes" xml:space="preserve">
          <source>checks out an older version. Continue like this, telling Git at each stage whether the version it gives you is good or bad, and notice that the number of revisions left to test is cut approximately in half each time.</source>
          <target state="translated">이전 버전을 체크 아웃합니다. 이렇게하면 각 단계에서 Git에게 제공하는 버전이 좋은지 나쁜지 알려주고 테스트 할 개정 횟수는 매번 약 절반으로 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="9d48ee970ac151e88a06bd52df27d444e45a115f" translate="yes" xml:space="preserve">
          <source>checks that the working tree and index associated with the repository have no uncommitted changes to tracked files. Otherwise it emits an error message of the form &lt;code&gt;Cannot
&amp;lt;action&amp;gt;: &amp;lt;reason&amp;gt;. &amp;lt;hint&amp;gt;&lt;/code&gt;, and dies. Example:</source>
          <target state="translated">리포지토리와 관련된 작업 트리 및 인덱스에 추적 파일에 대한 커밋되지 않은 변경 사항이 없는지 확인합니다. 그렇지 않으면 &lt;code&gt;Cannot &amp;lt;action&amp;gt;: &amp;lt;reason&amp;gt;. &amp;lt;hint&amp;gt;&lt;/code&gt; 형식의 오류 메시지가 나타납니다 . &amp;lt;힌트&amp;gt; 그리고 죽는다. 예:</target>
        </trans-unit>
        <trans-unit id="fde288e73fa35b620c1d091cd10bc2b4ef783b38" translate="yes" xml:space="preserve">
          <source>cherry-pick</source>
          <target state="translated">cherry-pick</target>
        </trans-unit>
        <trans-unit id="4d3ec7cec131af0636c8c4eb3ed9fad46bbbd8fe" translate="yes" xml:space="preserve">
          <source>cherry-picking</source>
          <target state="translated">cherry-picking</target>
        </trans-unit>
        <trans-unit id="13bb03a5ed8a80118d832f3194a1f24bdfb90600" translate="yes" xml:space="preserve">
          <source>chromium (also supported as chromium-browser)</source>
          <target state="translated">크롬 (크롬 브라우저로도 지원됨)</target>
        </trans-unit>
        <trans-unit id="a1aab85a96cc8931c6cead1715bf9f08fbd159e1" translate="yes" xml:space="preserve">
          <source>citool</source>
          <target state="translated">citool</target>
        </trans-unit>
        <trans-unit id="6a1cec45eaf37b34e1b1d89130d7746fe4006346" translate="yes" xml:space="preserve">
          <source>clean</source>
          <target state="translated">clean</target>
        </trans-unit>
        <trans-unit id="6191f3c6c1156403f2abec74131f05962f1abaa8" translate="yes" xml:space="preserve">
          <source>clean.requireForce</source>
          <target state="translated">clean.requireForce</target>
        </trans-unit>
        <trans-unit id="168cbb2ea52b9e34d271accecfa7d7951e948a99" translate="yes" xml:space="preserve">
          <source>clear</source>
          <target state="translated">clear</target>
        </trans-unit>
        <trans-unit id="5e0072329d5085c5bc5c23c2fa873dd42900958b" translate="yes" xml:space="preserve">
          <source>clone</source>
          <target state="translated">clone</target>
        </trans-unit>
        <trans-unit id="65b7b2d52a3b114f58dca240d43da422bee2212d" translate="yes" xml:space="preserve">
          <source>clone sets these configuration variables by default. It arranges &lt;code&gt;git pull&lt;/code&gt; to fetch and store the branches of mothership machine to local &lt;code&gt;remotes/origin/*&lt;/code&gt; remote-tracking branches.</source>
          <target state="translated">clone은 이러한 구성 변수를 기본적으로 설정합니다. 그것은 모기 기계의 지점을 가져 와서 로컬 &lt;code&gt;remotes/origin/*&lt;/code&gt; 원격 추적 지점에 &lt;code&gt;git pull&lt;/code&gt; 을 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="915d6fb92a6ac08fb7138984ea283c14a9573f89" translate="yes" xml:space="preserve">
          <source>clone.defaultRemoteName</source>
          <target state="translated">clone.defaultRemoteName</target>
        </trans-unit>
        <trans-unit id="b0039cf0af8bf144bcdb5512b615336fbd740a49" translate="yes" xml:space="preserve">
          <source>cloneurl (or multiple-valued &lt;code&gt;gitweb.url&lt;/code&gt;)</source>
          <target state="translated">cloneurl (또는 다중 값 &lt;code&gt;gitweb.url&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ada0de0751f70d1f9286c0a71669d799d3961206" translate="yes" xml:space="preserve">
          <source>codecompare</source>
          <target state="translated">codecompare</target>
        </trans-unit>
        <trans-unit id="d2cff126ddc906e1a4a856fa830eddaf46fcb2f4" translate="yes" xml:space="preserve">
          <source>collapse multiple consecutive empty lines into one empty line</source>
          <target state="translated">연속 된 여러 빈 줄을 빈 줄 하나로 축소</target>
        </trans-unit>
        <trans-unit id="6dd0fe8001145bec4a12d0e22da711c4970d000b" translate="yes" xml:space="preserve">
          <source>color</source>
          <target state="translated">color</target>
        </trans-unit>
        <trans-unit id="a5c6de6e1d6a5426c3f20e289bee4cb63cd9b46d" translate="yes" xml:space="preserve">
          <source>color specification, as described under Values in the &quot;CONFIGURATION FILE&quot; section of &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;. By default, colors are shown only when enabled for log output (by &lt;code&gt;color.diff&lt;/code&gt;, &lt;code&gt;color.ui&lt;/code&gt;, or &lt;code&gt;--color&lt;/code&gt;, and respecting the &lt;code&gt;auto&lt;/code&gt; settings of the former if we are going to a terminal). &lt;code&gt;%C(auto,...)&lt;/code&gt; is accepted as a historical synonym for the default (e.g., &lt;code&gt;%C(auto,red)&lt;/code&gt;). Specifying &lt;code&gt;%C(always,...)&lt;/code&gt; will show the colors even when color is not otherwise enabled (though consider just using &lt;code&gt;--color=always&lt;/code&gt; to enable color for the whole output, including this format and anything else git might color). &lt;code&gt;auto&lt;/code&gt; alone (i.e. &lt;code&gt;%C(auto)&lt;/code&gt;) will turn on auto coloring on the next placeholders until the color is switched again.</source>
          <target state="translated">&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 &quot;CONFIGURATION FILE&quot;섹션에있는 Values에 설명 된대로 컬러 스펙 . 기본적으로 색상은 로그 출력에 대해 활성화 된 경우 ( &lt;code&gt;color.diff&lt;/code&gt; , &lt;code&gt;color.ui&lt;/code&gt; 또는 &lt;code&gt;--color&lt;/code&gt; 에 의해 , 터미널로 갈 경우 전자 의 &lt;code&gt;auto&lt;/code&gt; 설정을 기준으로) 만 표시됩니다. &lt;code&gt;%C(auto,...)&lt;/code&gt; 는 기본값의 히스토리 동의어로 허용됩니다 (예 : &lt;code&gt;%C(auto,red)&lt;/code&gt; ). &lt;code&gt;%C(always,...)&lt;/code&gt; 지정 하면 색상이 다르게 활성화되지 않은 경우에도 색상이 표시됩니다 (단, &lt;code&gt;--color=always&lt;/code&gt; 를 사용하여이 형식 및 git이 색상을 지정할 수있는 모든 항목을 포함하여 전체 출력에 대해 색상을 활성화 하는 것을 고려 하십시오). &lt;code&gt;auto&lt;/code&gt; 단독으로 (즉, &lt;code&gt;%C(auto)&lt;/code&gt; )는 색상이 다시 전환 될 때까지 다음 자리 표시 자에서 자동 색상 표시를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="a4f66bcbf0c2d907db9d73e18998c425a594621e" translate="yes" xml:space="preserve">
          <source>color.advice</source>
          <target state="translated">color.advice</target>
        </trans-unit>
        <trans-unit id="8c847b9d6812ac606092130570e37493e972ad8a" translate="yes" xml:space="preserve">
          <source>color.advice.hint</source>
          <target state="translated">color.advice.hint</target>
        </trans-unit>
        <trans-unit id="46ab34863195debec0a658a6884ce1958a8721f8" translate="yes" xml:space="preserve">
          <source>color.blame.highlightRecent</source>
          <target state="translated">color.blame.highlightRecent</target>
        </trans-unit>
        <trans-unit id="cf152df8d71a4044f40941cffe12b4c5947d84c6" translate="yes" xml:space="preserve">
          <source>color.blame.repeatedLines</source>
          <target state="translated">color.blame.repeatedLines</target>
        </trans-unit>
        <trans-unit id="8ab572aa07e705b6cbb5dc02e6cc07d1c537adb5" translate="yes" xml:space="preserve">
          <source>color.branch</source>
          <target state="translated">color.branch</target>
        </trans-unit>
        <trans-unit id="ca9ef171160b4af8190637b4572026e1b567c98a" translate="yes" xml:space="preserve">
          <source>color.branch.&amp;lt;slot&amp;gt;</source>
          <target state="translated">color.branch.&amp;lt;slot&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ce3eb96e296266263902a69bbdcb71f2305cb04d" translate="yes" xml:space="preserve">
          <source>color.decorate.&amp;lt;slot&amp;gt;</source>
          <target state="translated">color.decorate.&amp;lt;slot&amp;gt;</target>
        </trans-unit>
        <trans-unit id="afd9432dd61dede344700077be0856defef90c96" translate="yes" xml:space="preserve">
          <source>color.diff</source>
          <target state="translated">color.diff</target>
        </trans-unit>
        <trans-unit id="f6c051574f795381da2ac0bc58ffe0019036f226" translate="yes" xml:space="preserve">
          <source>color.diff.&amp;lt;slot&amp;gt;</source>
          <target state="translated">color.diff.&amp;lt;slot&amp;gt;</target>
        </trans-unit>
        <trans-unit id="92611cb178c25cb2a36a185c2d51eb34ec21f182" translate="yes" xml:space="preserve">
          <source>color.grep</source>
          <target state="translated">color.grep</target>
        </trans-unit>
        <trans-unit id="514f2bfe2d4e52955ecf7c8018e222f3399098ca" translate="yes" xml:space="preserve">
          <source>color.grep.&amp;lt;slot&amp;gt;</source>
          <target state="translated">color.grep.&amp;lt;slot&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2a6e9053b32a43b99b387012d73632508c2e585a" translate="yes" xml:space="preserve">
          <source>color.interactive</source>
          <target state="translated">color.interactive</target>
        </trans-unit>
        <trans-unit id="dd02e0dce40f7d7025a402d431583fd14b053a0f" translate="yes" xml:space="preserve">
          <source>color.interactive.&amp;lt;slot&amp;gt;</source>
          <target state="translated">color.interactive.&amp;lt;slot&amp;gt;</target>
        </trans-unit>
        <trans-unit id="51223f4d2a0db29c55b88b1aeefff0292cdf6915" translate="yes" xml:space="preserve">
          <source>color.pager</source>
          <target state="translated">color.pager</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
