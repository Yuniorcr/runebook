<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="6b17aa5b71b9d47ea9adc71f193314f65da5b538" translate="yes" xml:space="preserve">
          <source>When two trees are specified, the user is telling &lt;code&gt;git read-tree&lt;/code&gt; the following:</source>
          <target state="translated">두 개의 트리가 지정되면 사용자는 &lt;code&gt;git read-tree&lt;/code&gt; 에게 다음을 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="0b1c4e2bbef526c82867f5bdebb7889317040a32" translate="yes" xml:space="preserve">
          <source>When unpacking a corrupt packfile, the command dies at the first corruption. This flag tells it to keep going and make the best effort to recover as many objects as possible.</source>
          <target state="translated">손상된 팩 파일의 압축을 풀 때 첫 번째 손상시 명령이 종료됩니다. 이 플래그는 계속 진행하고 가능한 많은 오브젝트를 복구하기 위해 최선을 다하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="5a3166bdcd39ee71b5c10c4011020b35e1491541" translate="yes" xml:space="preserve">
          <source>When unspecified, all references, after filtering done with --heads and --tags, are shown. When &amp;lt;refs&amp;gt;&amp;hellip;​ are specified, only references matching the given patterns are displayed.</source>
          <target state="translated">지정하지 않으면 --heads 및 --tags로 필터링 한 후 모든 참조가 표시됩니다. &amp;lt;refs&amp;gt;&amp;hellip;가 지정되면 주어진 패턴과 일치하는 참조 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fa62c673234c7d272766be9489825a6b1fba8b8c" translate="yes" xml:space="preserve">
          <source>When used in conjunction with the untracked cache, it can further improve performance by avoiding the cost of scanning the entire working directory looking for new files.</source>
          <target state="translated">추적되지 않은 캐시와 함께 사용하면 새 파일을 찾는 전체 작업 디렉토리를 스캔하는 비용을 피함으로써 성능을 더욱 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4699c35836688678c5cc37f1963f740eb7581527" translate="yes" xml:space="preserve">
          <source>When used together with &lt;code&gt;-B&lt;/code&gt;, omit also the preimage in the deletion part of a delete/create pair.</source>
          <target state="translated">&lt;code&gt;-B&lt;/code&gt; 와 함께 사용되는 경우 삭제 / 작성 쌍의 삭제 부분에서 사전 이미지도 생략하십시오.</target>
        </trans-unit>
        <trans-unit id="81ec7d099c83d3c361cd6013c655cfcd1bc1c8c9" translate="yes" xml:space="preserve">
          <source>When used with -C/-c/--amend options, or when committing after a conflicting cherry-pick, declare that the authorship of the resulting commit now belongs to the committer. This also renews the author timestamp.</source>
          <target state="translated">-C / -c /-amend 옵션과 함께 사용하거나 충돌하는 체리 픽 후 커밋 할 때 결과 커밋의 권한이 이제 커미터에 속한다고 선언합니다. 또한 작성자 타임 스탬프도 갱신됩니다.</target>
        </trans-unit>
        <trans-unit id="b6df5147373d036993fb497c4d7575874db40c5c" translate="yes" xml:space="preserve">
          <source>When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number &lt;code&gt;n&lt;/code&gt; controls this aspect of the -B option (defaults to 50%). &lt;code&gt;-B20%&lt;/code&gt; specifies that a change with addition and deletion compared to 20% or more of the file&amp;rsquo;s size are eligible for being picked up as a possible source of a rename to another file.</source>
          <target state="translated">-M과 함께 사용하면 완전히 다시 작성된 파일도 이름 바꾸기의 소스로 간주되며 (보통 -M은 이름 바꾸기의 소스로 사라진 파일 만 고려함) 숫자 &lt;code&gt;n&lt;/code&gt; 은 -B 옵션의이 측면을 제어합니다. (기본값은 50 %). &lt;code&gt;-B20%&lt;/code&gt; 는 파일 크기의 20 % 이상과 비교하여 추가 및 삭제가있는 변경 사항이 다른 파일로 이름 바꾸기의 가능한 소스로 선택 될 수 있음을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="372d4fbee27ed51979ac65f708d9745903af8bc0" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;--all&lt;/code&gt; print description for all recognized commands. This is the default.</source>
          <target state="translated">인식 된 모든 명령에 대해 &lt;code&gt;--all&lt;/code&gt; print description 과 함께 사용됩니다 . 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="9b2454d94f74e12e4789baf13180d6dd9add197c" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;-ad&lt;/code&gt;, any unreachable objects from existing packs will be appended to the end of the packfile instead of being removed. In addition, any unreachable loose objects will be packed (and their loose counterparts removed).</source>
          <target state="translated">&lt;code&gt;-ad&lt;/code&gt; 와 함께 사용하면 기존 팩에서 도달 할 수없는 모든 객체가 제거되지 않고 팩 파일의 끝에 추가됩니다. 또한 닿을 수없는 느슨한 물체는 포장되어 있으며 느슨한 물체는 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="f93c22c6857bec96ca286a73d77a732b313ba7be" translate="yes" xml:space="preserve">
          <source>When using --error-unmatch to expand the user supplied &amp;lt;file&amp;gt; (i.e. path pattern) arguments to paths, pretend that paths which were removed in the index since the named &amp;lt;tree-ish&amp;gt; are still present. Using this option with &lt;code&gt;-s&lt;/code&gt; or &lt;code&gt;-u&lt;/code&gt; options does not make any sense.</source>
          <target state="translated">--error-unmatch를 사용하여 사용자가 제공 한 &amp;lt;file&amp;gt; (예 : 경로 패턴) 인수를 경로로 확장하는 경우 명명 된 &amp;lt;tree-ish&amp;gt; 이후 인덱스에서 제거 된 경로가 여전히 존재합니다. 이 옵션을 &lt;code&gt;-s&lt;/code&gt; 또는 &lt;code&gt;-u&lt;/code&gt; 옵션과 함께 사용하면 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c409615f2beb16e70015d6d6f46a1b549d1fd7f1" translate="yes" xml:space="preserve">
          <source>When using --hash (and not --dereference) the output format is: &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt;</source>
          <target state="translated">--hash를 사용하고 --dereference는 사용하지 않는 경우 출력 형식은 다음과 같습니다. &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4048d2aa35caefecff5d81ef992bce0c4fb7143f" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;--full-history&lt;/code&gt;, Git walks every edge. This will discover the commits &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; and the merge &lt;code&gt;M&lt;/code&gt;, but also will reveal the merge commits &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt;. With parent rewriting, the resulting graph is:</source>
          <target state="translated">&lt;code&gt;--full-history&lt;/code&gt; 를 사용할 때 Git은 모든면에서 다가 갑니다. 이것은 커밋 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 와 병합 &lt;code&gt;M&lt;/code&gt; 을 발견 하지만 병합 커밋 &lt;code&gt;O&lt;/code&gt; 와 &lt;code&gt;P&lt;/code&gt; 도 나타냅니다 . 부모 다시 쓰기를 사용하면 결과 그래프는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="081b8dc63c3bf5b426e1b11153b55d3d12af50bd" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;--get&lt;/code&gt;, and the requested variable is not found, behave as if &amp;lt;value&amp;gt; were the value assigned to the that variable.</source>
          <target state="translated">&lt;code&gt;--get&lt;/code&gt; 을 사용할 때 요청 된 변수를 찾을 수 없으면 &amp;lt;value&amp;gt;가 해당 변수에 지정된 값인 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="a0e35ae72d386768f718c98e1facc75ecb16026b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;git diff&lt;/code&gt; to compare with work tree files, do not consider stat-only change as changed. Instead, silently run &lt;code&gt;git update-index --refresh&lt;/code&gt; to update the cached stat information for paths whose contents in the work tree match the contents in the index. This option defaults to true. Note that this affects only &lt;code&gt;git diff&lt;/code&gt; Porcelain, and not lower level &lt;code&gt;diff&lt;/code&gt; commands such as &lt;code&gt;git diff-files&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git diff&lt;/code&gt; 를 사용하여 작업 트리 파일과 비교할 때 통계 전용 변경을 변경된 것으로 고려하지 마십시오. 대신, &lt;code&gt;git update-index --refresh&lt;/code&gt; 를 자동으로 실행 하여 작업 트리의 내용이 색인의 내용과 일치하는 경로에 대해 캐시 된 통계 정보를 업데이트하십시오. 이 옵션의 기본값은 true입니다. 이것은 &lt;code&gt;git diff&lt;/code&gt; Porcelain 에만 영향을 미치며 &lt;code&gt;git diff-files&lt;/code&gt; 와 같은 하위 수준 &lt;code&gt;diff&lt;/code&gt; 명령 에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b88f8d37a4b8b52b11aa1a9190d81927513fc837" translate="yes" xml:space="preserve">
          <source>When using either the ssh:// or file:// transport, the GIT_PROTOCOL environment variable must be set explicitly to include &quot;version=2&quot;.</source>
          <target state="translated">ssh : // 또는 file : // 전송을 사용하는 경우 GIT_PROTOCOL 환경 변수는 &quot;version = 2&quot;를 포함하도록 명시 적으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0ba437f399f8167203a8f1358d574f4341e76291" translate="yes" xml:space="preserve">
          <source>When using multiple --branches or --tags, &lt;code&gt;git svn&lt;/code&gt; does not automatically handle name collisions (for example, if two branches from different paths have the same name, or if a branch and a tag have the same name). In these cases, use &lt;code&gt;init&lt;/code&gt; to set up your Git repository then, before your first &lt;code&gt;fetch&lt;/code&gt;, edit the $GIT_DIR/config file so that the branches and tags are associated with different name spaces. For example:</source>
          <target state="translated">여러 --branches 또는 --tags를 사용하는 경우 &lt;code&gt;git svn&lt;/code&gt; 은 이름 충돌을 자동으로 처리하지 않습니다 (예 : 서로 다른 경로의 두 분기가 같은 이름을 가지거나 분기와 태그의 이름이 같은 경우). 이 경우 &lt;code&gt;init&lt;/code&gt; 을 사용 하여 Git 리포지토리를 설정 한 다음 첫 번째 &lt;code&gt;fetch&lt;/code&gt; 전에 $ GIT_DIR / config 파일을 편집하여 브랜치와 태그가 다른 네임 스페이스와 연결되도록하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66eede648bb8458831446e45d1bace5161e3e57f" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--simplify-merges&lt;/code&gt; option, the commits &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; disappear from the results. This is because the rewritten second parents of &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; are reachable from their first parents. Those edges are removed and then the commits look like single-parent commits that are TREESAME to their parent. This also happens to the commit &lt;code&gt;N&lt;/code&gt;, resulting in a history view as follows:</source>
          <target state="translated">사용하는 경우 &lt;code&gt;--simplify-merges&lt;/code&gt; 옵션을 커밋 &lt;code&gt;O&lt;/code&gt; 및 &lt;code&gt;P&lt;/code&gt; 는 결과에서 사라집니다. 이는 다시 작성된 &lt;code&gt;O&lt;/code&gt; 및 &lt;code&gt;P&lt;/code&gt; 의 두 번째 부모가 첫 번째 부모에서 도달 할 수 있기 때문 입니다. 이러한 가장자리가 제거되고 커밋은 부모에게 TREESAME 인 단일 부모 커밋처럼 보입니다. 이것은 커밋 &lt;code&gt;N&lt;/code&gt; 에도 발생하여 다음과 같은 히스토리보기가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="bb2aee242441b06254e02f3a0a2e1341fe75fee4" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--verify&lt;/code&gt; flag, the command requires an exact path:</source>
          <target state="translated">&lt;code&gt;--verify&lt;/code&gt; 플래그를 사용하는 경우 명령에 정확한 경로가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="33199341df233e06da35e7d1be5de579f81a31d0" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;refspec&lt;/code&gt; capability, git normally updates the private ref on successful push. This update is disabled when the remote-helper declares the capability &lt;code&gt;no-private-update&lt;/code&gt;.</source>
          <target state="translated">참조 사양 기능을 사용하는 경우 git은 일반적으로 성공적인 &lt;code&gt;refspec&lt;/code&gt; 개인 참조를 업데이트합니다. 원격 도우미가 &lt;code&gt;no-private-update&lt;/code&gt; 기능을 선언하면이 업데이트가 비활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="bea3a627ae5a8f7b20a77e60b7a062e9084db269" translate="yes" xml:space="preserve">
          <source>When using the default mode, &lt;code&gt;N&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt; both have a TREESAME parent, so those edges are walked and the others are ignored. The resulting history graph is:</source>
          <target state="translated">기본 모드를 사용하는 경우 &lt;code&gt;N&lt;/code&gt; 과 &lt;code&gt;R&lt;/code&gt; 은 모두 TREESAME 부모를 가지므로 해당 가장자리는 보행되고 나머지는 무시됩니다. 결과 기록 그래프는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9344e268a1ce18a0fd23fc1ab7349b109ba09f95" translate="yes" xml:space="preserve">
          <source>When using the deprecated &lt;code&gt;[section.subsection]&lt;/code&gt; syntax, changing a value will result in adding a multi-line key instead of a change, if the subsection is given with at least one uppercase character. For example when the config looks like</source>
          <target state="translated">더 이상 사용되지 않는 &lt;code&gt;[section.subsection]&lt;/code&gt; 구문을 사용할 때 하위 섹션에 하나 이상의 대문자가 제공되면 값을 변경하면 변경 대신 여러 줄 키가 추가됩니다. 예를 들어 구성이 다음과 같은 경우</target>
        </trans-unit>
        <trans-unit id="d587eeb587978498a5260d6dbb9ec4ed92ae5139" translate="yes" xml:space="preserve">
          <source>When using the git:// transport, you can request to use protocol v2 by sending &quot;version=2&quot; as an extra parameter:</source>
          <target state="translated">git : // 전송을 사용할 때 &quot;version = 2&quot;를 추가 매개 변수로 보내 프로토콜 v2 사용을 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32ff889e17de28054dd0cab540306ba1d148a08f" translate="yes" xml:space="preserve">
          <source>When using the http:// or https:// transport a client makes a &quot;smart&quot; info/refs request as described in &lt;code&gt;http-protocol.txt&lt;/code&gt; and requests that v2 be used by supplying &quot;version=2&quot; in the &lt;code&gt;Git-Protocol&lt;/code&gt; header.</source>
          <target state="translated">http : // 또는 https : // 전송을 사용하는 경우 클라이언트는 &lt;code&gt;http-protocol.txt&lt;/code&gt; 에 설명 된대로 &quot;스마트&quot;정보 / 참조 요청을하고 &lt;code&gt;Git-Protocol&lt;/code&gt; 에 &quot;version = 2&quot;를 제공하여 v2를 사용하도록 요청합니다. 헤더.</target>
        </trans-unit>
        <trans-unit id="1119c741c1d5ff1dc358a8c521dcf54497e7a91a" translate="yes" xml:space="preserve">
          <source>When we discuss merges we&amp;rsquo;ll also see the special name MERGE_HEAD, which refers to the other branch that we&amp;rsquo;re merging in to the current branch.</source>
          <target state="translated">병합에 대해 논의 할 때 특수 분기 이름 MERGE_HEAD도 볼 수 있는데, 이는 현재 분기에 병합중인 다른 분기를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="26b492dec7c9b7098cc4171f2408a6f7f7e92986" translate="yes" xml:space="preserve">
          <source>When we need to be precise, we will use the word &quot;branch&quot; to mean a line of development, and &quot;branch head&quot; (or just &quot;head&quot;) to mean a reference to the most recent commit on a branch. In the example above, the branch head named &quot;A&quot; is a pointer to one particular commit, but we refer to the line of three commits leading up to that point as all being part of &quot;branch A&quot;.</source>
          <target state="translated">우리가 정확해야 할 때, &quot;branch&quot;라는 단어는 개발 라인을 의미하고 &quot;branch head&quot;(또는 &quot;head&quot;)는 지점에서 가장 최근의 커밋에 대한 참조를 의미합니다. 위의 예에서 &quot;A&quot;라는 분기 헤드는 하나의 특정 커밋에 대한 포인터이지만이 지점까지 이어지는 3 개의 커밋 라인은 모두 &quot;브랜치 A&quot;의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="af865a0e18421a331501b917b6b084d9f08c05af" translate="yes" xml:space="preserve">
          <source>When we want to find out what commits in &lt;code&gt;M&lt;/code&gt; are contaminated with the bug introduced by &lt;code&gt;D&lt;/code&gt; and need fixing, however, we might want to view only the subset of &lt;code&gt;D..M&lt;/code&gt; that are actually descendants of &lt;code&gt;D&lt;/code&gt;, i.e. excluding &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;K&lt;/code&gt;. This is exactly what the &lt;code&gt;--ancestry-path&lt;/code&gt; option does. Applied to the &lt;code&gt;D..M&lt;/code&gt; range, it results in:</source>
          <target state="translated">&lt;code&gt;M&lt;/code&gt; 에서 어떤 커밋 이 &lt;code&gt;D&lt;/code&gt; 에 의해 도입 된 버그로 오염되어 있고 수정이 필요한지 알아 내려면 실제로 &lt;code&gt;D&lt;/code&gt; 의 하위 항목 인 &lt;code&gt;D..M&lt;/code&gt; 의 하위 집합 만 보려고 할 수 있습니다 ( 예 : &lt;code&gt;C&lt;/code&gt; 및 &lt;code&gt;K&lt;/code&gt; 제외) . 이것이 바로 &lt;code&gt;--ancestry-path&lt;/code&gt; 옵션의 기능입니다. &lt;code&gt;D..M&lt;/code&gt; 범위에 적용하면 다음과 같은 결과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bd2b751f52f03b9f39eaea429dccc385cd6f8cb7" translate="yes" xml:space="preserve">
          <source>When writing a script that is expected to handle random user-input, it is a good practice to make it explicit which arguments are which by placing disambiguating &lt;code&gt;--&lt;/code&gt; at appropriate places.</source>
          <target state="translated">임의의 사용자 입력을 처리 할 것으로 예상되는 스크립트를 작성할 때, 그것은 좋은 연습이 인수하는 명확하게하는 배치하여있는이 명시 적으로 만드는 것입니다 &lt;code&gt;--&lt;/code&gt; 적절한 장소에서.</target>
        </trans-unit>
        <trans-unit id="ec9cac719dc2571ad31301b21a571a63039a88c5" translate="yes" xml:space="preserve">
          <source>When writing remote-helpers for decentralized version control systems, it is advised to keep a local copy of the repository to interact with, and to let the private namespace refs point to this local repository, while the refs/remotes namespace is used to track the remote repository.</source>
          <target state="translated">분산 버전 제어 시스템에 대한 원격 헬퍼를 작성할 때, 저장소의 로컬 사본이 상호 작용하고 개인 네임 스페이스 참조가이 로컬 저장소를 가리 키도록하는 반면, refs / remotes 네임 스페이스는 원격 저장소.</target>
        </trans-unit>
        <trans-unit id="20c75e316d5f2bc9ee11a82eb08a64c8e94c8af1" translate="yes" xml:space="preserve">
          <source>When writing, the new value is written to the repository local configuration file by default, and options &lt;code&gt;--system&lt;/code&gt;, &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--worktree&lt;/code&gt;, &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; can be used to tell the command to write to that location (you can say &lt;code&gt;--local&lt;/code&gt; but that is the default).</source>
          <target state="translated">쓸 때 기본적으로 새 값이 저장소 로컬 구성 파일에 기록되고 &lt;code&gt;--system&lt;/code&gt; , &lt;code&gt;--global&lt;/code&gt; , &lt;code&gt;--worktree&lt;/code&gt; , &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; 옵션을 사용하여 명령에 해당 위치에 쓰도록 지시 할 수 있습니다 ( &lt;code&gt;--local&lt;/code&gt; 이라고 말할 수 있지만 이것이 기본값입니다).</target>
        </trans-unit>
        <trans-unit id="cd8a515ddc50bbc57c4721fd114c9828b7d7e56b" translate="yes" xml:space="preserve">
          <source>When you are happy with the state of this change, you can merge it into the &quot;test&quot; branch in preparation to make it public:</source>
          <target state="translated">이 변경 상태에 만족하면 변경 사항을 &quot;테스트&quot;분기로 병합하여 공개 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="778f60f4a64466f8d291144e663a70b4838a03f8" translate="yes" xml:space="preserve">
          <source>When you are in the middle of something, you learn that there are upstream changes that are possibly relevant to what you are doing. When your local changes do not conflict with the changes in the upstream, a simple &lt;code&gt;git pull&lt;/code&gt; will let you move forward.</source>
          <target state="translated">당신이 무언가의 중간에있을 때, 당신은 아마도 당신이하고있는 일과 관련이있는 상류 변화가 있음을 알게됩니다. 로컬 변경 사항이 업스트림 변경 사항과 충돌하지 않으면 간단한 &lt;code&gt;git pull&lt;/code&gt; 을 사용하여 앞으로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6b623b307a4c06027202dc5b8021ae4a369fe95" translate="yes" xml:space="preserve">
          <source>When you are in the middle of something, your boss comes in and demands that you fix something immediately. Traditionally, you would make a commit to a temporary branch to store your changes away, and return to your original branch to make the emergency fix, like this:</source>
          <target state="translated">당신이 무언가의 중간에있을 때, 상사가 와서 즉시 무언가를 고치라고 요구합니다. 일반적으로 변경 사항을 저장하기 위해 임시 지점에 커밋하고 원래 지점으로 돌아가서 다음과 같이 응급 수정을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="5dab203d26aab56f5ab1012e5091a813403ff2db" translate="yes" xml:space="preserve">
          <source>When you are interested in finding the origin for lines 40-60 for file &lt;code&gt;foo&lt;/code&gt;, you can use the &lt;code&gt;-L&lt;/code&gt; option like so (they mean the same thing &amp;mdash; both ask for 21 lines starting at line 40):</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 파일에 대해 40-60 행의 원점을 찾는 데 관심 이있는 경우, &lt;code&gt;-L&lt;/code&gt; 옵션을 사용할 수 있습니다 (동일한 것을 의미합니다. 둘 다 40 행에서 시작하는 21 행을 요청합니다).</target>
        </trans-unit>
        <trans-unit id="709f7df580972f427522b82ef732f913e20c2078" translate="yes" xml:space="preserve">
          <source>When you are not interested in changes older than version v2.6.18, or changes older than 3 weeks, you can use revision range specifiers similar to &lt;code&gt;git rev-list&lt;/code&gt;:</source>
          <target state="translated">버전 v2.6.18 이전의 변경 사항 또는 3 주 이전의 변경 사항에 관심이없는 경우 &lt;code&gt;git rev-list&lt;/code&gt; 와 유사한 개정 범위 지정자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da9f31c43174e26846193d472d4442e982c36d7b" translate="yes" xml:space="preserve">
          <source>When you are working in a small closely knit group, it is not unusual to interact with the same repository over and over again. By defining &lt;code&gt;remote&lt;/code&gt; repository shorthand, you can make it easier:</source>
          <target state="translated">작고 밀접한 그룹에서 작업 할 때 동일한 저장소와 반복해서 상호 작용하는 것은 드문 일이 아닙니다. &lt;code&gt;remote&lt;/code&gt; 저장소를 속기 정의 하면 다음과 같이 더 쉬워 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ac50cc4cb199a994adc57ff3704f94a4fe6fd25" translate="yes" xml:space="preserve">
          <source>When you ask &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; to show the conflicts, it runs a three-way diff between the conflicted merge results in the work tree with stages 2 and 3 to show only hunks whose contents come from both sides, mixed (in other words, when a hunk&amp;rsquo;s merge results come only from stage 2, that part is not conflicting and is not shown. Same for stage 3).</source>
          <target state="translated">&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 에게 충돌을 보여 달라고 요청하면 , 2 단계와 3 단계의 작업 트리에서 충돌 된 병합 결과 사이에 3 방향 차이를 실행하여 내용이 양쪽에서 온 덩어리를 표시합니다 (기타) 즉, 덩어리의 병합 결과가 2 단계에서만 나오면 해당 부분은 충돌하지 않으며 표시되지 않습니다 (3 단계와 동일).</target>
        </trans-unit>
        <trans-unit id="3f0add0b9e7571c844c4ae8fb98b59f1c64d874a" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;git checkout &amp;lt;something&amp;gt;&lt;/code&gt; or &lt;code&gt;git switch &amp;lt;something&amp;gt;&lt;/code&gt; and only have one remote, it may implicitly fall back on checking out and tracking e.g. &lt;code&gt;origin/&amp;lt;something&amp;gt;&lt;/code&gt;. This stops working as soon as you have more than one remote with a &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; reference. This setting allows for setting the name of a preferred remote that should always win when it comes to disambiguation. The typical use-case is to set this to &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">당신이 실행하면 &lt;code&gt;git checkout &amp;lt;something&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;git switch &amp;lt;something&amp;gt;&lt;/code&gt; 만 원격 하나를 가지고, 그것은 암시 적으로 체크 아웃하고 예를 들어 추적에 다시 떨어질 수 &lt;code&gt;origin/&amp;lt;something&amp;gt;&lt;/code&gt; . &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; 참조 가있는 리모콘이 둘 이상있는 즉시 작동이 중지됩니다 . 이 설정을 통해 선호하는 리모컨의 이름을 명확하게 지정할 수 있습니다. 일반적인 사용 사례는 이것을 &lt;code&gt;origin&lt;/code&gt; 으로 설정하는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="9f93e702904ad75a7ffcc41597ebc2474895e0b0" translate="yes" xml:space="preserve">
          <source>When you start a 3-way merge with an index file that is already populated, it is assumed that it represents the state of the files in your work tree, and you can even have files with changes unrecorded in the index file. It is further assumed that this state is &quot;derived&quot; from the stage 2 tree. The 3-way merge refuses to run if it finds an entry in the original index file that does not match stage 2.</source>
          <target state="translated">이미 채워진 인덱스 파일과의 3 방향 병합을 시작하면 작업 트리에있는 파일의 상태를 나타내며 인덱스 파일에 변경 내용이 기록되지 않은 파일도있을 수 있습니다. 또한이 상태는 2 단계 트리에서 &quot;유도&quot;된 것으로 가정합니다. 3 단계 병합은 원래 인덱스 파일에서 2 단계와 일치하지 않는 항목을 찾으면 실행을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="6831d00e1f830a484b6c5799e343f596bbc55899" translate="yes" xml:space="preserve">
          <source>When you want to just integrate with the work leading to the commit that happens to be tagged, e.g. synchronizing with an upstream release point, you may not want to make an unnecessary merge commit.</source>
          <target state="translated">업스트림 릴리스 포인트와 동기화하는 등 태그가 붙은 커밋을 일으키는 작업과 통합하려는 경우 불필요한 병합 커밋을 원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f28e5d62e5a87453e903e81e941382b8ac566c1" translate="yes" xml:space="preserve">
          <source>When you&amp;rsquo;re ready, just run</source>
          <target state="translated">준비가되면 그냥 달려</target>
        </trans-unit>
        <trans-unit id="4aa6b6296b8d97b342099d335ec15bc55634ad41" translate="yes" xml:space="preserve">
          <source>When your topic branch is long-lived, however, your topic branch would end up having many such &quot;Merge from master&quot; commits on it, which would unnecessarily clutter the development history. Readers of the Linux kernel mailing list may remember that Linus complained about such too frequent test merges when a subsystem maintainer asked to pull from a branch full of &quot;useless merges&quot;.</source>
          <target state="translated">그러나 토픽 브랜치가 오래 지속되면 토픽 브랜치에 &quot;마스터에서 병합&quot;커밋이 많이 발생하여 개발 히스토리가 불필요하게 복잡해집니다. 리눅스 커널 메일 링리스트를 읽는 사람들은 서브 시스템 관리자가 &quot;무용 한 병합&quot;으로 가득 찬 지점에서 가져 오기를 요청했을 때 Linus가 너무 빈번한 테스트 병합에 대해 불평했다는 것을 기억할 것입니다.</target>
        </trans-unit>
        <trans-unit id="bd4128428344ae6c28977b2bc5cf00953da1175f" translate="yes" xml:space="preserve">
          <source>When your topic branch modifies an overlapping area that your master branch (or upstream) touched since your topic branch forked from it, you may want to test it with the latest master, even before your topic branch is ready to be pushed upstream:</source>
          <target state="translated">주제 분기가 분기 된 이후 주제 분기 (또는 업스트림)가 터치 한 겹치는 영역을 주제 분기에서 수정하는 경우 주제 분기를 업스트림으로 푸시 할 준비가되기 전에도 최신 마스터로 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f4eaf255ffc69df0530167a4810c74e9370cd43" translate="yes" xml:space="preserve">
          <source>Whenever possible, section headings should clearly describe the task they explain how to do, in language that requires no more knowledge than necessary: for example, &quot;importing patches into a project&quot; rather than &quot;the &lt;code&gt;git am&lt;/code&gt; command&quot;</source>
          <target state="translated">가능할 때마다 섹션 제목에는 필요한 것 이상의 지식이 필요없는 언어로 수행하는 작업을 명확하게 설명해야합니다 (예 : &quot; &lt;code&gt;git am&lt;/code&gt; 명령&quot; 이 아닌 &quot;프로젝트로 패치 가져 오기 &quot;).</target>
        </trans-unit>
        <trans-unit id="11683716a14fb2e59c3ad4d48a607606706a0329" translate="yes" xml:space="preserve">
          <source>Where &quot;oldsha1&quot; is the 40 character hexadecimal value previously stored in &amp;lt;ref&amp;gt;, &quot;newsha1&quot; is the 40 character hexadecimal value of &amp;lt;newvalue&amp;gt; and &quot;committer&quot; is the committer&amp;rsquo;s name, email address and date in the standard Git committer ident format.</source>
          <target state="translated">&quot;oldsha1&quot;은 이전에 &amp;lt;ref&amp;gt;에 저장된 40 자의 16 진수 값이고, &quot;newsha1&quot;은 &amp;lt;newvalue&amp;gt;의 40 자의 16 진수 값이고 &quot;committer&quot;는 표준 Git 커미터 ID 형식의 커미터 이름, 이메일 주소 및 날짜입니다. .</target>
        </trans-unit>
        <trans-unit id="9a6682bd90b10ed7b65387d46ac6e3098ba208ce" translate="yes" xml:space="preserve">
          <source>Where all fields are as described above and &quot;message&quot; is the value supplied to the -m option.</source>
          <target state="translated">모든 필드는 위에서 설명한대로 &quot;message&quot;는 -m 옵션에 제공된 값입니다.</target>
        </trans-unit>
        <trans-unit id="1047cdb3a9504c1e49ba180691c6de133fb29736" translate="yes" xml:space="preserve">
          <source>Where to create the Git repository. If not provided, the last component in the p4 depot path is used to create a new directory.</source>
          <target state="translated">Git 리포지토리를 생성 할 위치 제공되지 않은 경우 p4 저장소 경로의 마지막 구성 요소가 새 디렉토리를 작성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="de8afe671960d7a395defa2e40a80901d96e2485" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;--batch-check='%(objectname) %(objecttype)'&lt;/code&gt; would produce:</source>
          <target state="translated">반면 &lt;code&gt;--batch-check='%(objectname) %(objecttype)'&lt;/code&gt; 은 다음을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="92669e9b8b127c2ba15691914d72dae97b880d0d" translate="yes" xml:space="preserve">
          <source>Whether Git detects directory renames, affecting what happens at merge time to new files added to a directory on one side of history when that directory was renamed on the other side of history. If merge.directoryRenames is set to &quot;false&quot;, directory rename detection is disabled, meaning that such new files will be left behind in the old directory. If set to &quot;true&quot;, directory rename detection is enabled, meaning that such new files will be moved into the new directory. If set to &quot;conflict&quot;, a conflict will be reported for such paths. If merge.renames is false, merge.directoryRenames is ignored and treated as false. Defaults to &quot;conflict&quot;.</source>
          <target state="translated">Git이 디렉토리 이름 바꾸기를 감지하는지 여부는 해당 디렉토리가 히스토리의 다른 쪽에서 이름이 바뀔 때 히스토리 한쪽의 디렉토리에 추가 된 새 파일에 병합시 발생하는 영향에 영향을줍니다. merge.directoryRenames가 &quot;false&quot;로 설정되면 디렉토리 이름 바꾸기 감지가 사용 불가능하게되어 새 파일이 이전 디렉토리에 남게됩니다. &quot;true&quot;로 설정하면 디렉토리 이름 바꾸기 감지가 사용됩니다. 이는 새 파일이 새 디렉토리로 이동 함을 의미합니다. &quot;충돌&quot;로 설정하면 해당 경로에 대한 충돌이보고됩니다. merge.renames가 false이면 merge.directoryRenames가 무시되고 false로 처리됩니다. 기본값은 &quot;충돌&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="6720b94e3bf2c12c61b3c14de0415d18239394a0" translate="yes" xml:space="preserve">
          <source>Whether Git detects renames. If set to &quot;false&quot;, rename detection is disabled. If set to &quot;true&quot;, basic rename detection is enabled. Defaults to the value of diff.renames.</source>
          <target state="translated">Git이 이름 변경을 감지하는지 여부 &quot;false&quot;로 설정하면 이름 바꾸기 감지가 비활성화됩니다. &quot;true&quot;로 설정하면 기본 이름 변경 감지가 사용됩니다. 기본값은 diff.renames입니다.</target>
        </trans-unit>
        <trans-unit id="d1f68ec7a1f81e21d54ab2e76eaccedf11117ff8" translate="yes" xml:space="preserve">
          <source>Whether and how Git detects renames in &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; . If set to &quot;false&quot;, rename detection is disabled. If set to &quot;true&quot;, basic rename detection is enabled. If set to &quot;copies&quot; or &quot;copy&quot;, Git will detect copies, as well. Defaults to the value of diff.renames.</source>
          <target state="translated">Git이 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 및 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 에서 이름 변경을 감지하는지 여부와 방법 . &quot;false&quot;로 설정하면 이름 바꾸기 감지가 비활성화됩니다. &quot;true&quot;로 설정하면 기본 이름 변경 감지가 사용됩니다. &quot;복사본&quot;또는 &quot;복사본&quot;으로 설정되면 Git은 사본도 감지합니다. 기본값은 diff.renames입니다.</target>
        </trans-unit>
        <trans-unit id="cd914284b278d491020fec9d972b776a56df2f14" translate="yes" xml:space="preserve">
          <source>Whether and how Git detects renames. If set to &quot;false&quot;, rename detection is disabled. If set to &quot;true&quot;, basic rename detection is enabled. If set to &quot;copies&quot; or &quot;copy&quot;, Git will detect copies, as well. Defaults to true. Note that this affects only &lt;code&gt;git diff&lt;/code&gt; Porcelain like &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; and &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, and not lower level commands such as &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt;.</source>
          <target state="translated">Git이 이름 변경을 감지하는지 여부와 방법. &quot;false&quot;로 설정하면 이름 바꾸기 감지가 비활성화됩니다. &quot;true&quot;로 설정하면 기본 이름 변경 감지가 사용됩니다. &quot;복사본&quot;또는 &quot;복사본&quot;으로 설정되면 Git은 사본도 감지합니다. 기본값은 true입니다. 이는 &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 및 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 과 같은 &lt;code&gt;git diff&lt;/code&gt; Porcelain 에만 영향을 미치며 &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1]&lt;/a&gt; 와 같은 하위 수준 명령에는 영향을주지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2329b3f81f31d1e7aac7efc37e396ae5ccc9b5fe" translate="yes" xml:space="preserve">
          <source>Whether git should follow HTTP redirects. If set to &lt;code&gt;true&lt;/code&gt;, git will transparently follow any redirect issued by a server it encounters. If set to &lt;code&gt;false&lt;/code&gt;, git will treat all redirects as errors. If set to &lt;code&gt;initial&lt;/code&gt;, git will follow redirects only for the initial request to a remote, but not for subsequent follow-up HTTP requests. Since git uses the redirected URL as the base for the follow-up requests, this is generally sufficient. The default is &lt;code&gt;initial&lt;/code&gt;.</source>
          <target state="translated">git이 HTTP 리디렉션을 따라야하는지 여부입니다. &lt;code&gt;true&lt;/code&gt; 로 설정하면 git은 서버에서 발생한 모든 리디렉션을 투명하게 따릅니다. &lt;code&gt;false&lt;/code&gt; 로 설정하면 git은 모든 리디렉션을 오류로 처리합니다. &lt;code&gt;initial&lt;/code&gt; 으로 설정하면 git은 초기 요청에 대해서만 원격으로 리디렉션하지만 후속 후속 HTTP 요청에는 리디렉션하지 않습니다. git은 후속 요청의 기반으로 리디렉션 된 URL을 사용하기 때문에 일반적으로 충분합니다. 기본값은 &lt;code&gt;initial&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cd0092aedf4252969afafd8803ba8faf98999493" translate="yes" xml:space="preserve">
          <source>Whether that update is allowed without &lt;code&gt;--force&lt;/code&gt; depends on the ref namespace it&amp;rsquo;s being fetched to, the type of object being fetched, and whether the update is considered to be a fast-forward. Generally, the same rules apply for fetching as when pushing, see the &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; section of &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; for what those are. Exceptions to those rules particular to &lt;code&gt;git fetch&lt;/code&gt; are noted below.</source>
          <target state="translated">&lt;code&gt;--force&lt;/code&gt; 없이 업데이트를 허용할지 여부 는 가져 오는 ref 네임 스페이스, 가져 오는 객체의 유형 및 업데이트가 빠른 것으로 간주되는지 여부에 따라 다릅니다. 일반적으로, 푸시 할 때와 같은 규칙이 페치에 적용됩니다. &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 의 &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; 섹션을 참조하십시오 . &lt;code&gt;git fetch&lt;/code&gt; 와 관련된 규칙에 대한 예외 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c31395d6226db0f96527cf13d7284a32596aaef" translate="yes" xml:space="preserve">
          <source>Whether the CVS server interface is enabled for this repository. See &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;.</source>
          <target state="translated">이 저장소에 CVS 서버 인터페이스가 사용 가능한지 여부 &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e99c94b5e67663cef6460c2b09cda34348e975de" translate="yes" xml:space="preserve">
          <source>Whether to enable the grouping of projects by category on the project list page. The category of a project is determined by the &lt;code&gt;$GIT_DIR/category&lt;/code&gt; file or the &lt;code&gt;gitweb.category&lt;/code&gt; variable in each repository&amp;rsquo;s configuration. Disabled by default (set to 0).</source>
          <target state="translated">프로젝트 목록 페이지에서 카테고리별로 프로젝트를 그룹화 할 수 있는지 여부 프로젝트 &lt;code&gt;$GIT_DIR/category&lt;/code&gt; 는 각 저장소 구성 의 $ &lt;code&gt;gitweb.category&lt;/code&gt; / category 파일 또는 gitweb.category 변수에 의해 결정됩니다 . 기본적으로 비활성화되어 있습니다 (0으로 설정).</target>
        </trans-unit>
        <trans-unit id="be60442dc9a2bb750c3ffb3e91f602fa8cf454b7" translate="yes" xml:space="preserve">
          <source>Whether to print the diffstat between ORIG_HEAD and the merge result at the end of the merge. True by default.</source>
          <target state="translated">ORIG_HEAD와 병합 종료시 병합 결과 사이의 diffstat를 인쇄할지 여부. 기본적으로 true입니다.</target>
        </trans-unit>
        <trans-unit id="e6d010b4fa5fb27d92c64dc2f59319c4e77b544c" translate="yes" xml:space="preserve">
          <source>Whether to show a diffstat of what changed upstream since the last rebase. False by default.</source>
          <target state="translated">마지막 리베이스 이후 업스트림에서 변경된 내용의 차이를 표시할지 여부입니다. 기본적으로 False입니다.</target>
        </trans-unit>
        <trans-unit id="2153c59644d7df4b2ed210d8ef453074b1a6c2ac" translate="yes" xml:space="preserve">
          <source>Whether to skip reading settings from the system-wide $(prefix)/etc/gitconfig file. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details.</source>
          <target state="translated">시스템 전체 $ (prefix) / etc / gitconfig 파일에서 설정 읽기를 건너 뛸지 여부입니다. 자세한 내용은 &lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7c8173d7da296bd9c5f5aef35e3d739c8852bc79" translate="yes" xml:space="preserve">
          <source>Whether to skip reading settings from the system-wide &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; file. This environment variable can be used along with &lt;code&gt;$HOME&lt;/code&gt; and &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; to create a predictable environment for a picky script, or you can set it temporarily to avoid using a buggy &lt;code&gt;/etc/gitconfig&lt;/code&gt; file while waiting for someone with sufficient permissions to fix it.</source>
          <target state="translated">시스템 전체 &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; 파일 에서 설정 읽기를 건너 뛸지 여부 입니다. 이 환경 변수를 &lt;code&gt;$HOME&lt;/code&gt; 및 &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; 과 함께 사용 하여 까다로운 스크립트를위한 예측 가능한 환경을 만들거나 버그가있는 &lt;code&gt;/etc/gitconfig&lt;/code&gt; 파일을 사용하지 않고 임시로 설정 하여 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="488ddc0ec5d5c663a8e8059a323ed70db5316b78" translate="yes" xml:space="preserve">
          <source>Whether to use ANSI escape sequences to add color to patches. If this is set to &lt;code&gt;always&lt;/code&gt;, &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;, &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, and &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; will use color for all patches. If it is set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, those commands will only use color when output is to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">패치에 색상을 추가하기 위해 ANSI 이스케이프 시퀀스를 사용할지 여부입니다. 이로 설정하면 &lt;code&gt;always&lt;/code&gt; , &lt;a href=&quot;git-diff&quot;&gt;자식-DIFF는 [1]&lt;/a&gt; , &lt;a href=&quot;git-log&quot;&gt;자식 로그 [1]&lt;/a&gt; , 그리고 &lt;a href=&quot;git-show&quot;&gt;자식 쇼 [1]&lt;/a&gt; 모든 패치의 색상을 사용합니다. &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;auto&lt;/code&gt; 로 설정 되면 해당 명령은 출력이 터미널로 출력 될 때만 색상을 사용합니다. 설정하지 않으면 &lt;code&gt;color.ui&lt;/code&gt; 의 값 이 사용됩니다 ( 기본적으로 &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="21386b2036d855c8d8dd6eb4c84085329fcf2561" translate="yes" xml:space="preserve">
          <source>Whether to use empty blobs as rename source.</source>
          <target state="translated">빈 BLOB을 이름 바꾸기 소스로 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="63ea1a80cc99dbbdec2d362a1b57aa7468c9ed6d" translate="yes" xml:space="preserve">
          <source>Whether to verify the SSL certificate when fetching or pushing over HTTPS. Defaults to true. Can be overridden by the &lt;code&gt;GIT_SSL_NO_VERIFY&lt;/code&gt; environment variable.</source>
          <target state="translated">HTTPS를 가져 오거나 푸시 할 때 SSL 인증서를 확인할지 여부입니다. 기본값은 true입니다. &lt;code&gt;GIT_SSL_NO_VERIFY&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec9fdb5354be84561f27023760593b27a86cd126" translate="yes" xml:space="preserve">
          <source>Which file to place a pattern in depends on how the pattern is meant to be used.</source>
          <target state="translated">패턴을 배치 할 파일은 패턴의 사용 방법에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9342c5a7ca74e113fca6826c098da1e9dea46c59" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose by default when resolving notes conflicts. Must be one of &lt;code&gt;manual&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt;, &lt;code&gt;theirs&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or &lt;code&gt;cat_sort_uniq&lt;/code&gt;. Defaults to &lt;code&gt;manual&lt;/code&gt;. See &quot;NOTES MERGE STRATEGIES&quot; section above for more information on each strategy.</source>
          <target state="translated">메모 충돌을 해결할 때 기본적으로 선택할 병합 전략 중 하나 여야합니다 &lt;code&gt;manual&lt;/code&gt; , &lt;code&gt;ours&lt;/code&gt; , &lt;code&gt;theirs&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; , 또는 &lt;code&gt;cat_sort_uniq&lt;/code&gt; . 기본값은 &lt;code&gt;manual&lt;/code&gt; 입니다. 각 전략에 대한 자세한 내용은 위의 &quot;NOTES MERGE STRATEGIES&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7dd75dabb694bc7182031b6cdb5c605283f3ff3a" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose by default when resolving notes conflicts. Must be one of &lt;code&gt;manual&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt;, &lt;code&gt;theirs&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or &lt;code&gt;cat_sort_uniq&lt;/code&gt;. Defaults to &lt;code&gt;manual&lt;/code&gt;. See &quot;NOTES MERGE STRATEGIES&quot; section of &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt; for more information on each strategy.</source>
          <target state="translated">메모 충돌을 해결할 때 기본적으로 선택할 병합 전략 중 하나 여야합니다 &lt;code&gt;manual&lt;/code&gt; , &lt;code&gt;ours&lt;/code&gt; , &lt;code&gt;theirs&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; , 또는 &lt;code&gt;cat_sort_uniq&lt;/code&gt; . 기본값은 &lt;code&gt;manual&lt;/code&gt; 입니다. 각 전략에 대한 자세한 내용 은 &lt;a href=&quot;git-notes&quot;&gt;git-notes [1]&lt;/a&gt; 의 &quot;NOTES MERGE 전략&quot;섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9bd73c0d97037644e549ed3fed8d2491f5cfc8e0" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose when doing a notes merge into refs/notes/&amp;lt;name&amp;gt;. This overrides the more general &quot;notes.mergeStrategy&quot;. See the &quot;NOTES MERGE STRATEGIES&quot; section above for more information on each available strategy.</source>
          <target state="translated">노트를 수행 할 때 선택할 병합 전략은 refs / notes / &amp;lt;name&amp;gt;에 병합됩니다. 이것은 더 일반적인 &quot;notes.mergeStrategy&quot;를 대체합니다. 사용 가능한 각 전략에 대한 자세한 내용은 위의 &quot;NOTES MERGE STRATEGIES&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f202b61699020bcfa082fe897d7a8560aea486a1" translate="yes" xml:space="preserve">
          <source>Which merge strategy to choose when doing a notes merge into refs/notes/&amp;lt;name&amp;gt;. This overrides the more general &quot;notes.mergeStrategy&quot;. See the &quot;NOTES MERGE STRATEGIES&quot; section in &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt; for more information on the available strategies.</source>
          <target state="translated">노트를 수행 할 때 선택할 병합 전략은 refs / notes / &amp;lt;name&amp;gt;에 병합됩니다. 이것은 더 일반적인 &quot;notes.mergeStrategy&quot;를 대체합니다. 사용 가능한 전략에 대한 자세한 내용 은 &lt;a href=&quot;git-notes&quot;&gt;git-notes [1]&lt;/a&gt; 의 &quot;NOTES MERGE STRATEGIES&quot;섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="556a322f94dd1e45943ded0ebea9906e93ca0c80" translate="yes" xml:space="preserve">
          <source>Which ref (or refs, if a glob or specified more than once), in addition to the default set by &lt;code&gt;core.notesRef&lt;/code&gt; or &lt;code&gt;GIT_NOTES_REF&lt;/code&gt;, to read notes from when showing commit messages with the &lt;code&gt;git log&lt;/code&gt; family of commands. This setting can be overridden on the command line or by the &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; environment variable. See &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;core.notesRef&lt;/code&gt; 또는 &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; 에 의해 설정된 기본값 외에 &lt;code&gt;git log&lt;/code&gt; 계열 명령으로 커밋 메시지를 표시 할 때 메모를 읽을 수있는 참조 (또는 glob 또는 두 번 이상 지정된 경우 참조) 이 설정은 명령 행 또는 &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 . &lt;a href=&quot;git-log&quot;&gt;git-log [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="08e8ee8d98ea130471cc368fbf1a571f3d29a34d" translate="yes" xml:space="preserve">
          <source>Which ref to manipulate notes from, instead of &lt;code&gt;refs/notes/commits&lt;/code&gt;. This overrides the &lt;code&gt;core.notesRef&lt;/code&gt; setting.</source>
          <target state="translated">어떤에서 대신 메모를 조작하는 심판 &lt;code&gt;refs/notes/commits&lt;/code&gt; . 이것은 &lt;code&gt;core.notesRef&lt;/code&gt; 설정을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="180171a89f79828ca3aedfa4194b8ff07f802f3f" translate="yes" xml:space="preserve">
          <source>Which refs, in addition to the default set by &lt;code&gt;core.notesRef&lt;/code&gt; or &lt;code&gt;GIT_NOTES_REF&lt;/code&gt;, to read notes from when showing commit messages with the &lt;code&gt;log&lt;/code&gt; family of commands. See &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;core.notesRef&lt;/code&gt; 또는 &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; 에 의해 설정된 기본값 외에 &lt;code&gt;log&lt;/code&gt; 명령 군에 커밋 메시지를 표시 할 때 메모를 읽는 참조 &lt;a href=&quot;git-notes&quot;&gt;git-notes [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4dbbdac6096ee85d080e618f1dfec3eb7804653" translate="yes" xml:space="preserve">
          <source>Which will add the following to a file named &lt;code&gt;.gitconfig&lt;/code&gt; in your home directory:</source>
          <target state="translated">홈 디렉토리의 &lt;code&gt;.gitconfig&lt;/code&gt; 파일에 다음을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="0b383fc769f1bfb4acb136b5be3ea84e9742db33" translate="yes" xml:space="preserve">
          <source>Which would result in:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5efe59371f7c539c77a16fb753d65287a4a1a881" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; is usually used to specify what files are in, you can also specify what files are &lt;code&gt;not&lt;/code&gt; in, using negate patterns. For example, to remove the file &lt;code&gt;unwanted&lt;/code&gt;:</source>
          <target state="translated">하지만 &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; 보통 파일에 무엇을 지정하는 데 사용됩니다, 당신은 또한 파일이 무엇인지를 지정할 수 &lt;code&gt;not&lt;/code&gt; 부정 패턴을 사용하여,에. 예를 들어, 파일을 제거하려면 &lt;code&gt;unwanted&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="133c634c89411bc7bbb73a5aa8f4cda72b5442c2" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; is usually used to specify what files are included, you can also specify what files are &lt;code&gt;not&lt;/code&gt; included, using negative patterns. For example, to remove the file &lt;code&gt;unwanted&lt;/code&gt;:</source>
          <target state="translated">하지만 &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; 일반적으로 파일이 포함되어있는 것을 지정하는 데 사용됩니다, 당신은 또한 파일이 무엇인지를 지정할 수 &lt;code&gt;not&lt;/code&gt; 부정적인 패턴을 사용하여, 포함되어 있습니다. 예를 들어, 파일을 제거하려면 &lt;code&gt;unwanted&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="118bfe73a3b1ef14dd8bb7fedadb7cb55f01bcfb" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;&lt;/code&gt; was about specifying a single commit parent, these three notations also consider its parents. For example you can say &lt;code&gt;HEAD^2^@&lt;/code&gt;, however you cannot say &lt;code&gt;HEAD^@^2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;&lt;/code&gt; 은 단일 커밋 부모를 지정하는 것이 었지만 이 세 가지 표기법은 부모를 고려합니다. 예를 들어 &lt;code&gt;HEAD^2^@&lt;/code&gt; 말할 수 있지만 &lt;code&gt;HEAD^@^2&lt;/code&gt; 말할 수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="eaec58c53324781fb42b4e63ea8a9cb23361a1d5" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git archimport&lt;/code&gt; will try to create sensible branch names for the archives that it imports, it is also possible to specify Git branch names manually. To do so, write a Git branch name after each &amp;lt;archive/branch&amp;gt; parameter, separated by a colon. This way, you can shorten the Arch branch names and convert Arch jargon to Git jargon, for example mapping a &quot;PROJECT--devo--VERSION&quot; branch to &quot;master&quot;.</source>
          <target state="translated">&lt;code&gt;git archimport&lt;/code&gt; 는 가져 오는 아카이브에 대해 적절한 브랜치 이름을 만들려고 하지만 Git 브랜치 이름을 수동으로 지정할 수도 있습니다. 이렇게하려면 각 &amp;lt;archive / branch&amp;gt; 매개 변수 뒤에 콜론으로 구분하여 Git 분기 이름을 작성합니다. 이렇게하면 아치 브랜치 이름을 줄이고 아치 용어를 Git 용어로 변환 할 수 있습니다. 예를 들어 &quot;PROJECT--devo--VERSION&quot;브랜치를 &quot;master&quot;로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="92e92ccd1a34f0875d32051d1b819b76c11daddf" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git archimport&lt;/code&gt; will try to create sensible branch names for the archives that it imports, it is also possible to specify Git branch names manually. To do so, write a Git branch name after each &amp;lt;archive/branch&amp;gt; parameter, separated by a colon. This way, you can shorten the Arch branch names and convert Arch jargon to Git jargon, for example mapping a &quot;PROJECT{litdd}devo{litdd}VERSION&quot; branch to &quot;master&quot;.</source>
          <target state="translated">&lt;code&gt;git archimport&lt;/code&gt; 는 가져 오는 아카이브에 대해 합리적인 지점 이름을 만들려고 시도 하지만 Git 지점 이름을 수동으로 지정할 수도 있습니다. 이렇게하려면 각 &amp;lt;archive / branch&amp;gt; 매개 변수 뒤에 콜론으로 구분하여 Git 브랜치 이름을 작성하십시오. 이런 식으로 아치 분기 이름을 줄이고 아치 전문 용어를 Git 전문 용어로 변환 할 수 있습니다 (예 : &quot;PROJECT {litdd} devo {litdd} VERSION&quot;분기를 &quot;master&quot;에 매핑).</target>
        </trans-unit>
        <trans-unit id="becb5324e2c3fe06edf2ea3e91b298d56c7ab4c0" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git log -G&quot;frotz\(nitfol&quot;&lt;/code&gt; will show this commit, &lt;code&gt;git log
-S&quot;frotz\(nitfol&quot; --pickaxe-regex&lt;/code&gt; will not (because the number of occurrences of that string did not change).</source>
          <target state="translated">하지만 &lt;code&gt;git log -G&quot;frotz\(nitfol&quot;&lt;/code&gt; 이 커밋 표시됩니다, &lt;code&gt;git log -S&quot;frotz\(nitfol&quot; --pickaxe-regex&lt;/code&gt; 하지 않습니다 (해당 문자열의 발생 수) 변경하지 않은 때문이다.</target>
        </trans-unit>
        <trans-unit id="6e3c7753b36510ea58174f6c4603b4398587f401" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git log -G&quot;regexec\(regexp&quot;&lt;/code&gt; will show this commit, &lt;code&gt;git log
-S&quot;regexec\(regexp&quot; --pickaxe-regex&lt;/code&gt; will not (because the number of occurrences of that string did not change).</source>
          <target state="translated">하지만 &lt;code&gt;git log -G&quot;regexec\(regexp&quot;&lt;/code&gt; 이 커밋 표시됩니다 &lt;code&gt;git log -S&quot;regexec\(regexp&quot; --pickaxe-regex&lt;/code&gt; 하지 않습니다 (해당 문자열의 발생 수) 변경하지 않은 때문이다.</target>
        </trans-unit>
        <trans-unit id="9fa3ab181478a04a41a15d625153bef4e8a57c74" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;git svn&lt;/code&gt; can track copy history (including branches and tags) for repositories adopting a standard layout, it cannot yet represent merge history that happened inside git back upstream to SVN users. Therefore it is advised that users keep history as linear as possible inside Git to ease compatibility with SVN (see the CAVEATS section below).</source>
          <target state="translated">&lt;code&gt;git svn&lt;/code&gt; 은 표준 레이아웃을 채택한 리포지토리에 대한 복사 기록 (분기 및 태그 포함)을 추적 할 수 있지만 SVN 사용자에게 git backstream에서 발생한 병합 기록을 아직 나타낼 수는 없습니다. 따라서 사용자는 SVN과의 호환성을 쉽게하기 위해 Git 내에서 가능한 한 히스토리를 선형으로 유지하는 것이 좋습니다 (아래의 CAVEATS 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="6dffb65164b8303d8f69a39b7acb7d5c91ede142" translate="yes" xml:space="preserve">
          <source>While Git normally leaves file contents alone, it can be configured to normalize line endings to LF in the repository and, optionally, to convert them to CRLF when files are checked out.</source>
          <target state="translated">Git은 일반적으로 파일 내용 만 남겨두고 저장소에서 줄 끝을 LF로 정규화하고 선택적으로 파일을 체크 아웃 할 때 CRLF로 변환하도록 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28e5e3e789710acfbe64ae88514ac76e33edddf4" translate="yes" xml:space="preserve">
          <source>While a tree represents a particular directory state of a working directory, a commit represents that state in &quot;time&quot;, and explains how to get there.</source>
          <target state="translated">트리는 작업중인 디렉토리의 특정 디렉토리 상태를 나타내는 반면, 커밋은 해당 시간을 &quot;시간&quot;으로 나타내며 도달하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4340adfab1f511dfd0a9b398534e55b63d70f9b2" translate="yes" xml:space="preserve">
          <source>While an &quot;easy case recovery&quot; sometimes appears to be successful even in the hard case, it may have unintended consequences. For example, a commit that was removed via &lt;code&gt;git rebase
      --interactive&lt;/code&gt; will be &lt;strong&gt;resurrected&lt;/strong&gt;!</source>
          <target state="translated">어려운 경우에도 &quot;쉬운 사례 복구&quot;가 성공한 것처럼 보이지만 의도하지 않은 결과가 발생할 수 있습니다. 예를 들어, 커밋 그 제거를 통해 &lt;code&gt;git rebase --interactive&lt;/code&gt; 됩니다 &lt;strong&gt;부활&lt;/strong&gt; !</target>
        </trans-unit>
        <trans-unit id="aeca28e54d758d00b7b9efe81e9021c3ae168604" translate="yes" xml:space="preserve">
          <source>While at it, check the &lt;code&gt;info&lt;/code&gt; and &lt;code&gt;final-commit&lt;/code&gt; files as well. If what is in &lt;code&gt;final-commit&lt;/code&gt; is not exactly what you would want to see in the commit log message, it is very likely that the receiver would end up hand editing the log message when applying your patch. Things like &quot;Hi, this is my first patch.\n&quot; in the patch e-mail should come after the three-dash line that signals the end of the commit message.</source>
          <target state="translated">&lt;code&gt;info&lt;/code&gt; 와 &lt;code&gt;final-commit&lt;/code&gt; 파일도 확인하십시오 . 무엇 경우 &lt;code&gt;final-commit&lt;/code&gt; 당신이 커밋 로그 메시지의, 매우 가능성이 수신기가 당신의 패치를 적용 할 때 로그 메시지를 편집하는 손을 끝낼 것입니다보고 싶은 것이 무엇인지 정확히하지 않습니다. 패치 전자 우편의 &quot;안녕하세요. \ n&quot;과 같은 것은 커밋 메시지의 끝을 알리는 3 개의 대시 줄 다음에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="8ae695a4eabf8fe5dbbd3e5b96e3d4b6e1234599" translate="yes" xml:space="preserve">
          <source>While creating changes is useful, it&amp;rsquo;s even more useful if you can tell later what changed. The most useful command for this is another of the &lt;code&gt;diff&lt;/code&gt; family, namely &lt;code&gt;git diff-tree&lt;/code&gt;.</source>
          <target state="translated">변경 사항을 작성하는 것이 유용하지만 나중에 변경된 내용을 알려줄 수 있으면 더욱 유용합니다. 이것에 가장 유용한 명령은 다른 &lt;code&gt;diff&lt;/code&gt; 패밀리, 즉 &lt;code&gt;git diff-tree&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e66bf2723385d320e1625ad06ac948bff457808d" translate="yes" xml:space="preserve">
          <source>While it is possible to override all attributes, well behaving helpers should refrain from doing so for any attribute other than username and password.</source>
          <target state="translated">모든 속성을 재정의 할 수 있지만, 잘 작동하는 도우미는 사용자 이름과 비밀번호 이외의 속성에 대해 그렇게하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="84a06403fddbfbdfed756ddcbe7e1b6ff85edd7a" translate="yes" xml:space="preserve">
          <source>While one could just alter the configuration settings in the gitweb CGI itself, those changes would be lost upon upgrade. Configuration settings might also be placed into a file in the same directory as the CGI script with the default name &lt;code&gt;gitweb_config.perl&lt;/code&gt; &amp;mdash; allowing one to have multiple gitweb instances with different configurations by the use of symlinks.</source>
          <target state="translated">gitweb CGI 자체의 구성 설정을 변경할 수는 있지만 업그레이드하면 변경 사항이 손실됩니다. 구성 설정은 기본 이름이 &lt;code&gt;gitweb_config.perl&lt;/code&gt; 인 CGI 스크립트와 동일한 디렉토리에있는 파일에 배치 될 수도 있습니다 . 심볼릭 링크를 사용하여 구성이 다른 여러 gitweb 인스턴스를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3129dc27b36b536bbc925e644f78f32bde86376a" translate="yes" xml:space="preserve">
          <source>While parent object ids are provided on the command line, author and committer information is taken from the following environment variables, if set:</source>
          <target state="translated">명령 행에 상위 오브젝트 ID가 제공되지만 작성자 및 커미터 정보는 설정된 경우 다음 환경 변수에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7921bb694427f6298ff631684ef33f9b3436be57" translate="yes" xml:space="preserve">
          <source>While you are in the middle of working on something complicated, you find an unrelated but obvious and trivial bug. You would like to fix it before continuing. You can use &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; to save the current state of your work, and after fixing the bug (or, optionally after doing so on a different branch and then coming back), unstash the work-in-progress changes.</source>
          <target state="translated">복잡한 작업을하는 동안 관련이 없지만 명백하고 사소한 버그가 있습니다. 계속하기 전에 문제를 해결하고 싶습니다. 당신이 사용할 수있는 &lt;a href=&quot;git-stash&quot;&gt;자식-숨긴 [1]&lt;/a&gt; 워크에서 진행중인 변화를 unstash, 그리고 (다시하거나, 선택적으로 다른 지점에 이렇게 후 다음 예정) 버그를 해결 한 후 작업의 현재 상태를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="aa47dd8a2f0ebe83c1c9e1c5b54451eb489a4bd1" translate="yes" xml:space="preserve">
          <source>Whitespace separated fields; any run of whitespace can be used as field separator (rules for Perl&amp;rsquo;s &quot;&lt;code&gt;split(&quot; &quot;, $line)&lt;/code&gt;&quot;).</source>
          <target state="translated">공백으로 구분 된 필드; 모든 공백은 필드 분리 자로 사용할 수 있습니다 (Perl의 &quot; &lt;code&gt;split(&quot; &quot;, $line)&lt;/code&gt; &quot;에 대한 규칙 ).</target>
        </trans-unit>
        <trans-unit id="863aeb0371f511e273bc66c19d53b7877f38ac8a" translate="yes" xml:space="preserve">
          <source>Whitespace-separated list of allowed SMTP-AUTH mechanisms. This setting forces using only the listed mechanisms. Example:</source>
          <target state="translated">허용 된 SMTP-AUTH 메커니즘의 공백으로 구분 된 목록입니다. 이 설정은 나열된 메커니즘 만 사용합니다. 예:</target>
        </trans-unit>
        <trans-unit id="389ff74463b52646838e41646e64e38a902b85eb" translate="yes" xml:space="preserve">
          <source>Why bisecting merge commits can be harder than bisecting linear history</source>
          <target state="translated">이분법 병합 커밋이 이력 선형 기록보다 더 어려운 이유</target>
        </trans-unit>
        <trans-unit id="4ae988a6589a0546387522087a0861a61e3e4225" translate="yes" xml:space="preserve">
          <source>Wildcards in the pattern such as &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; are treated as literal characters.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;?&lt;/code&gt; 와 같은 패턴의 와일드 카드 리터럴 문자로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="af4b569cb0fc1bae5a933e3532b964dc5d61facd" translate="yes" xml:space="preserve">
          <source>Will copy all files listed from the index to the working directory (not overwriting existing files).</source>
          <target state="translated">색인에서 나열된 모든 파일을 작업 디렉토리로 복사합니다 (기존 파일을 덮어 쓰지 않음).</target>
        </trans-unit>
        <trans-unit id="712e5286413fd90307ff92f23e110885525f2bb8" translate="yes" xml:space="preserve">
          <source>Will fail unless you manually run &lt;code&gt;git fetch origin-push&lt;/code&gt;. This method is of course entirely defeated by something that runs &lt;code&gt;git fetch
--all&lt;/code&gt;, in that case you&amp;rsquo;d need to either disable it or do something more tedious like:</source>
          <target state="translated">&lt;code&gt;git fetch origin-push&lt;/code&gt; 를 수동으로 실행하지 않으면 실패합니다 . 이 메소드는 물론 &lt;code&gt;git fetch --all&lt;/code&gt; 을 실행하는 것에 의해 완전히 패배합니다 .이 경우 메소드 를 비활성화하거나 더 지루한 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="bfd8a0b8d0916903c6596ed358a3cc07670d304e" translate="yes" xml:space="preserve">
          <source>Windows-only: allow redirecting the standard input/output/error handles to paths specified by the environment variables. This is particularly useful in multi-threaded applications where the canonical way to pass standard handles via &lt;code&gt;CreateProcess()&lt;/code&gt; is not an option because it would require the handles to be marked inheritable (and consequently &lt;strong&gt;every&lt;/strong&gt; spawned process would inherit them, possibly blocking regular Git operations). The primary intended use case is to use named pipes for communication (e.g. &lt;code&gt;\\.\pipe\my-git-stdin-123&lt;/code&gt;).</source>
          <target state="translated">Windows 전용 : 표준 입력 / 출력 / 오류 핸들을 환경 변수로 지정된 경로로 경로 재 지정할 수 있습니다. 이것은 &lt;code&gt;CreateProcess()&lt;/code&gt; 를 통해 표준 핸들을 전달하는 표준 방법 이 핸들이 상속 가능한 것으로 표시되어야하기 때문에 옵션이 아닌 멀티 스레드 응용 프로그램에서 특히 유용합니다. 결과적으로 생성 된 &lt;strong&gt;모든&lt;/strong&gt; 프로세스가이를 상속하여 정기적 인 Git 작업을 차단할 수 있습니다. ). 기본 사용 사례는 통신에 명명 된 파이프를 사용하는 것입니다 (예 : &lt;code&gt;\\.\pipe\my-git-stdin-123&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9c510c80ca0db551792868481dfce7936d126272" translate="yes" xml:space="preserve">
          <source>Windows-only: comma-separated list of environment variables' names that need to be unset before spawning any other process. Defaults to &lt;code&gt;PERL5LIB&lt;/code&gt; to account for the fact that Git for Windows insists on using its own Perl interpreter.</source>
          <target state="translated">Windows 전용 : 다른 프로세스를 생성하기 전에 설정을 해제해야하는 쉼표로 구분 된 환경 변수 이름 목록입니다. Git for Windows가 자체 Perl 인터프리터를 사용해야한다는 사실을 설명하기 위해 기본값은 &lt;code&gt;PERL5LIB&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e74f053e0d02cafdbd0bbd14c65f9fd314f00d13" translate="yes" xml:space="preserve">
          <source>Windows-only: override whether spawned processes inherit only standard file handles (&lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt;) or all handles. Can be &lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. Defaults to &lt;code&gt;auto&lt;/code&gt;, which means &lt;code&gt;true&lt;/code&gt; on Windows 7 and later, and &lt;code&gt;false&lt;/code&gt; on older Windows versions.</source>
          <target state="translated">Windows 전용 : 생성 된 프로세스가 표준 파일 핸들 ( &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; 및 &lt;code&gt;stderr&lt;/code&gt; ) 만 상속하는지 아니면 모든 핸들을 상속하는지 여부를 대체하십시오 . &lt;code&gt;auto&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 일 수 있습니다 . 기본값은 &lt;code&gt;auto&lt;/code&gt; 이며, 이는 Windows 7 이상에서는 &lt;code&gt;false&lt;/code&gt; 를, 이전 Windows 버전에서는 false 를 의미 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="949442d2f0c16b026f680dbb7df65e881242333c" translate="yes" xml:space="preserve">
          <source>With --abbrev set to 0, the command can be used to find the closest tagname without any suffix:</source>
          <target state="translated">--abbrev를 0으로 설정하면이 명령을 사용하여 접미사없이 가장 가까운 태그 이름을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a158e0380ec8b734a269ad9d0f52eb5eb98f2274" translate="yes" xml:space="preserve">
          <source>With --all, the command can use branch heads as references, so the output shows the reference path as well:</source>
          <target state="translated">--all을 사용하면 명령에서 분기 헤드를 참조로 사용할 수 있으므로 출력에 참조 경로도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="65ee9a1948ccba3bbf4e1e0783ded1eb1bf032c9" translate="yes" xml:space="preserve">
          <source>With --batch or --batch-check, follow symlinks inside the repository when requesting objects with extended SHA-1 expressions of the form tree-ish:path-in-tree. Instead of providing output about the link itself, provide output about the linked-to object. If a symlink points outside the tree-ish (e.g. a link to /foo or a root-level link to ../foo), the portion of the link which is outside the tree will be printed.</source>
          <target state="translated">--batch 또는 --batch-check를 사용하면 tree-ish : path-in-tree 형식의 확장 된 SHA-1식이있는 객체를 요청할 때 저장소 내부의 심볼릭 링크를 따릅니다. 링크 자체에 대한 출력을 제공하는 대신 링크 된 오브젝트에 대한 출력을 제공하십시오. 심볼릭 링크가 트리 -ish 외부를 가리키는 경우 (예 : / foo에 대한 링크 또는 ../foo에 대한 루트 수준 링크) 트리 외부에있는 링크 부분이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="4f48f3dcfb8092537ede5a515e981d6e213aeb9f" translate="yes" xml:space="preserve">
          <source>With --no-commit perform the merge and stop just before creating a merge commit, to give the user a chance to inspect and further tweak the merge result before committing.</source>
          <target state="translated">--no-commit을 사용하면 병합 커밋을 만들기 직전에 병합을 수행하고 중지하여 사용자가 커밋하기 전에 병합 결과를 검사하고 추가로 조정할 수있는 기회를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3e8c9cc261afe4f0a3a9c88b1d66c9688df929d7" translate="yes" xml:space="preserve">
          <source>With --no-log do not list one-line descriptions from the actual commits being merged.</source>
          <target state="translated">--no-log를 사용하면 병합되는 실제 커밋의 한 줄 설명을 나열하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1adfa5cefd427bf7d3a2a21965629dcaf3c3388" translate="yes" xml:space="preserve">
          <source>With --no-signoff do not add a Signed-off-by line.</source>
          <target state="translated">--no-signoff를 사용하면 Signed-off-by 행을 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="268060b1be32cd8bc70e7e3bb40c821b809c90c3" translate="yes" xml:space="preserve">
          <source>With --no-squash perform the merge and commit the result. This option can be used to override --squash.</source>
          <target state="translated">--no-squash를 사용하면 병합을 수행하고 결과를 커밋합니다. 이 옵션은 --squash를 재정의하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2060c61f3742702f58530c81f5eefb302aeb60c1" translate="yes" xml:space="preserve">
          <source>With --squash, --commit is not allowed, and will fail.</source>
          <target state="translated">--squash를 사용하면 --commit이 허용되지 않으며 실패합니다.</target>
        </trans-unit>
        <trans-unit id="865b225dd999d9769e36118a7e13e933131732f5" translate="yes" xml:space="preserve">
          <source>With -n or --no-stat do not show a diffstat at the end of the merge.</source>
          <target state="translated">-n 또는 --no-stat를 사용하면 병합 끝에 diffstat가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="008f5911b332311009571603d4810039f3b0a542" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--add&lt;/code&gt;, instead of changing existing URLs, new URL is added.</source>
          <target state="translated">&lt;code&gt;--add&lt;/code&gt; 를 사용 하면 기존 URL을 변경하는 대신 새 URL이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6b50c366c66c543504b13b437403fc08b0e99b0f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--add&lt;/code&gt;, instead of replacing the list of currently tracked branches, adds to that list.</source>
          <target state="translated">&lt;code&gt;--add&lt;/code&gt; 를 사용 하면 현재 추적 된 분기 목록을 바꾸지 않고 해당 목록에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b5c6ad97197083d8f93283087955bd70bd89f95f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--all&lt;/code&gt; flag, all refs that exist locally are transferred to the remote side. You cannot specify any &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; if you use this flag.</source>
          <target state="translated">&lt;code&gt;--all&lt;/code&gt; 플래그를 사용하면 로컬로 존재하는 모든 참조가 원격으로 전송됩니다. 이 플래그를 사용하면 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 를 지정할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="487cd0ed38992f1c8c21d61869ab0ba8c9131e91" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--all&lt;/code&gt;, all URLs for the remote will be listed.</source>
          <target state="translated">로 &lt;code&gt;--all&lt;/code&gt; , 원격에 대한 모든 URL이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ea729f224a85b66147f6e662a1c5d14a2abdd751" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--contains&lt;/code&gt;, shows only the branches that contain the named commit (in other words, the branches whose tip commits are descendants of the named commit), &lt;code&gt;--no-contains&lt;/code&gt; inverts it. With &lt;code&gt;--merged&lt;/code&gt;, only branches merged into the named commit (i.e. the branches whose tip commits are reachable from the named commit) will be listed. With &lt;code&gt;--no-merged&lt;/code&gt; only branches not merged into the named commit will be listed. If the &amp;lt;commit&amp;gt; argument is missing it defaults to &lt;code&gt;HEAD&lt;/code&gt; (i.e. the tip of the current branch).</source>
          <target state="translated">&lt;code&gt;--contains&lt;/code&gt; 를 사용하면 명명 된 커밋을 포함하는 분기 (즉, 팁 커밋이 명명 된 커밋의 하위 항목 인 분기 ) 만 표시합니다. &lt;code&gt;--no-contains&lt;/code&gt; 는 반전합니다. 로 &lt;code&gt;--merged&lt;/code&gt; 만 가지라는 커밋에 병합 (즉, 그 끝 커밋 커밋의 이름에서 연결할 수있는 지점)가 표시됩니다. 로 &lt;code&gt;--no-merged&lt;/code&gt; 라는 이름이 나열됩니다 커밋으로 통합뿐만 아니라 지점. &amp;lt;commit&amp;gt; 인수가 없으면 기본값은 &lt;code&gt;HEAD&lt;/code&gt; (즉, 현재 분기의 끝)입니다.</target>
        </trans-unit>
        <trans-unit id="a1afc8d7fd506e98e5a974a8f26c84b23238fb92" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--create-reflog&lt;/code&gt;, update-ref will create a reflog for each ref even if one would not ordinarily be created.</source>
          <target state="translated">&lt;code&gt;--create-reflog&lt;/code&gt; 를 사용하면 update-ref는 일반적으로 작성되지 않더라도 각 참조에 대한 참조를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="7fef88021ca55186dc4070339cc8624e9a30485c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--delete&lt;/code&gt;, instead of changing existing URLs, all URLs matching regex &amp;lt;url&amp;gt; are deleted for remote &amp;lt;name&amp;gt;. Trying to delete all non-push URLs is an error.</source>
          <target state="translated">&lt;code&gt;--delete&lt;/code&gt; 를 사용 하면 기존 URL을 변경하는 대신 원격 &amp;lt;name&amp;gt;에 대해 정규식 &amp;lt;url&amp;gt;과 일치하는 모든 URL이 삭제됩니다. 푸시가 아닌 URL을 모두 삭제하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="30918cb51e4372be35c787127ec3b8958bb72e8d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--dry-run&lt;/code&gt; option, report what branches will be pruned, but do not actually prune them.</source>
          <target state="translated">&lt;code&gt;--dry-run&lt;/code&gt; 옵션을 사용하면 잘라낼 가지를보고하지만 실제로 제거하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4cd9a1b8d31ddff1298b3b28b732552e240fb7a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--dry-run&lt;/code&gt; option, report what branches would be pruned, but do not actually prune them.</source>
          <target state="translated">와 &lt;code&gt;--dry-run&lt;/code&gt; 옵션, 가지 정리 될 수 있지만, 실제로 그들을 제거하지 않는 것을 보고서.</target>
        </trans-unit>
        <trans-unit id="5189cda6779864f8bd2f5726b39c4529ff52ddf8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--ff-only&lt;/code&gt;, resolve the merge as a fast-forward when possible. When not possible, refuse to merge and exit with a non-zero status.</source>
          <target state="translated">&lt;code&gt;--ff-only&lt;/code&gt; 를 사용 하면 가능하면 빨리 병합으로 병합을 해결하십시오. 가능하지 않은 경우 0이 아닌 상태로 병합 및 종료를 거부하십시오.</target>
        </trans-unit>
        <trans-unit id="7e8f4fddd68a3a89ff49906c538a7ca7b5ef9dea" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--ff&lt;/code&gt;, when possible resolve the merge as a fast-forward (only update the branch pointer to match the merged branch; do not create a merge commit). When not possible (when the merged-in history is not a descendant of the current history), create a merge commit.</source>
          <target state="translated">와 &lt;code&gt;--ff&lt;/code&gt; , 가능하면 해결과 병합 빨리 감기 (만 병합 된 지점과 일치하는 지점 포인터를 업데이트, 병합 커밋을 작성하지 않습니다). 가능하지 않은 경우 (병합 된 내역이 현재 내역의 후손이 아닌 경우) 병합 커밋을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1362a77896d8f49d16b2f9c5015389cf3c365072" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--force&lt;/code&gt;, the fast-forward check is disabled for all refs.</source>
          <target state="translated">함께 &lt;code&gt;--force&lt;/code&gt; , 빨리 감기 검사는 모든 심판을 위해 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ba76b155ec3c447a87cfd160419204d256e0f486" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--keep-cr&lt;/code&gt;, call &lt;code&gt;git mailsplit&lt;/code&gt; (see &lt;a href=&quot;git-mailsplit&quot;&gt;git-mailsplit[1]&lt;/a&gt;) with the same option, to prevent it from stripping CR at the end of lines. &lt;code&gt;am.keepcr&lt;/code&gt; configuration variable can be used to specify the default behaviour. &lt;code&gt;--no-keep-cr&lt;/code&gt; is useful to override &lt;code&gt;am.keepcr&lt;/code&gt;.</source>
          <target state="translated">함께 &lt;code&gt;--keep-cr&lt;/code&gt; 호출 &lt;code&gt;git mailsplit&lt;/code&gt; (참조 &lt;a href=&quot;git-mailsplit&quot;&gt;자식-mailsplit을 [1]&lt;/a&gt; 라인의 끝에 CR 박리되는 것을 방지하기 위해, 동일한 옵션). &lt;code&gt;am.keepcr&lt;/code&gt; 구성 변수를 사용하여 기본 동작을 지정할 수 있습니다. &lt;code&gt;--no-keep-cr&lt;/code&gt; 은 &lt;code&gt;am.keepcr&lt;/code&gt; 을 재정의하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="22e7d426b38d094430582cb84fc0432b42834058" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--no-ff&lt;/code&gt;, create a merge commit in all cases, even when the merge could instead be resolved as a fast-forward.</source>
          <target state="translated">로 &lt;code&gt;--no-ff&lt;/code&gt; , 병합 대신 빨리 감기로 해결 될 수있는 경우에도, 병합이 모든 경우에 커밋 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5aa5b8e96804090cb89f3aab6cdc283e2c00d87e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--no-tags&lt;/code&gt; option, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; does not import tags from the remote repository.</source>
          <target state="translated">로 &lt;code&gt;--no-tags&lt;/code&gt; 옵션, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; 원격 저장소에서 수행하지 가져 태그를.</target>
        </trans-unit>
        <trans-unit id="37eed19521c790d78f1c0615d39722d6298a6cc8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--patch&lt;/code&gt;, you can interactively select hunks from the diff between HEAD and the working tree to be stashed. The stash entry is constructed such that its index state is the same as the index state of your repository, and its worktree contains only the changes you selected interactively. The selected changes are then rolled back from your worktree. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">로 &lt;code&gt;--patch&lt;/code&gt; , 대화 형 HEAD와 작업 트리의 DIFF에서 심술쟁이를 선택하는 은닉한다. 숨김 항목은 색인 상태가 저장소의 색인 상태와 동일하도록 구성되며 작업 트리에는 대화식으로 선택한 변경 사항 만 포함됩니다. 선택한 변경 사항이 작업 트리에서 롤백됩니다. &lt;code&gt;--patch&lt;/code&gt; 모드 작동 방법을 알아 보려면 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 의 &quot;대화식 모드&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d4d7e74d0f493c9b38977e43daed9cfd8d04693" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--pretty&lt;/code&gt; format other than &lt;code&gt;oneline&lt;/code&gt; and &lt;code&gt;reference&lt;/code&gt; (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog. The reflog designator in the output may be shown as &lt;code&gt;ref@{Nth}&lt;/code&gt; (where &lt;code&gt;Nth&lt;/code&gt; is the reverse-chronological index in the reflog) or as &lt;code&gt;ref@{timestamp}&lt;/code&gt; (with the timestamp for that entry), depending on a few rules:</source>
          <target state="translated">&lt;code&gt;oneline&lt;/code&gt; 및 &lt;code&gt;reference&lt;/code&gt; 이외의 &lt;code&gt;--pretty&lt;/code&gt; 형식을 사용하면 (명백한 이유로) 출력에 reflog에서 가져온 두 개의 추가 정보 줄이 생깁니다. 출력의 reflog 지정 자는 몇 가지 규칙에 따라 &lt;code&gt;ref@{Nth}&lt;/code&gt; (여기서 &lt;code&gt;Nth&lt;/code&gt; 는 reflog의 역 시간 색인) 또는 &lt;code&gt;ref@{timestamp}&lt;/code&gt; (해당 항목의 타임 스탬프 포함)로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35b7bcaa0d1a12c16e7ebe5749afd0aa0913b69d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--prune&lt;/code&gt; option, run pruning against all the remotes that are updated.</source>
          <target state="translated">&lt;code&gt;--prune&lt;/code&gt; 옵션을 사용하면 업데이트 된 모든 원격 장치에 대해 제거를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="9a993d0e8bfe45705897018a009a33a68fb547fb" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--push&lt;/code&gt;, push URLs are manipulated instead of fetch URLs.</source>
          <target state="translated">&lt;code&gt;--push&lt;/code&gt; 를 사용하면 URL 가져 오기 대신 푸시 URL이 조작됩니다.</target>
        </trans-unit>
        <trans-unit id="d0c8d67cd6d67334176bbc781201963c60a05697" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--push&lt;/code&gt;, push URLs are queried rather than fetch URLs.</source>
          <target state="translated">&lt;code&gt;--push&lt;/code&gt; 를 사용하면 URL을 가져 오는 대신 푸시 URL을 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="a26943d9e66efe8045d055005cf22b61dc280b47" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--stdin&lt;/code&gt;, update-ref reads instructions from standard input and performs all modifications together. Specify commands of the form:</source>
          <target state="translated">&lt;code&gt;--stdin&lt;/code&gt; 을 사용하면 update-ref는 표준 입력에서 명령어를 읽고 모든 수정을 함께 수행합니다. 다음 형식의 명령을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="46644e8c0f7ae9adba68ae4958242044a646f477" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--tags&lt;/code&gt; option, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; imports every tag from the remote repository.</source>
          <target state="translated">&lt;code&gt;--tags&lt;/code&gt; 옵션을 사용하면 &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; 은 원격 저장소에서 모든 태그를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9afd8cc2d67d37867f3891e80c5ed22f0441334c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--topo-order&lt;/code&gt;, they would show 8 6 5 3 7 4 2 1 (or 8 7 4 2 6 5 3 1); some older commits are shown before newer ones in order to avoid showing the commits from two parallel development track mixed together.</source>
          <target state="translated">&lt;code&gt;--topo-order&lt;/code&gt; 를 사용하면 8 6 5 3 7 4 2 1 (또는 8 7 4 2 6 5 3 1)을 표시합니다. 두 개의 병렬 개발 트랙의 커밋이 함께 혼합되어 표시되지 않도록하기 위해 일부 이전 커밋이 최신 커밋보다 먼저 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bbe3bdb143c872f8bc3522bea317a2ad84af9235" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;--auto&lt;/code&gt;, the remote is queried to determine its &lt;code&gt;HEAD&lt;/code&gt;, then the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is set to the same branch. e.g., if the remote &lt;code&gt;HEAD&lt;/code&gt; is pointed at &lt;code&gt;next&lt;/code&gt;, &quot;&lt;code&gt;git remote set-head origin -a&lt;/code&gt;&quot; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/next&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="translated">함께 &lt;code&gt;-a&lt;/code&gt; 또는 &lt;code&gt;--auto&lt;/code&gt; 원격는 그 결정하도록 쿼리 &lt;code&gt;HEAD&lt;/code&gt; 후 기호-REF &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 동일한 지점으로 설정된다. 예를 들어, 원격 &lt;code&gt;HEAD&lt;/code&gt; 가 &lt;code&gt;next&lt;/code&gt; 에 지시 되면 &quot; &lt;code&gt;git remote set-head origin -a&lt;/code&gt; &quot;는 &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; -ref refs / remotes / origin / HEAD 를 &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; 로 설정 합니다. &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; 이미 존재하는 경우에만 작동 합니다. 그렇지 않은 경우 먼저 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="ca79465e71cd43be9bc8a1c0daf2d4aececc9880" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;--auto&lt;/code&gt;, the remote is queried to determine its &lt;code&gt;HEAD&lt;/code&gt;, then the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is set to the same branch. e.g., if the remote &lt;code&gt;HEAD&lt;/code&gt; is pointed at &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;git remote set-head origin -a&lt;/code&gt; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/next&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="translated">함께 &lt;code&gt;-a&lt;/code&gt; 또는 &lt;code&gt;--auto&lt;/code&gt; 원격는 그 결정하도록 쿼리 &lt;code&gt;HEAD&lt;/code&gt; 후 기호-REF &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 동일한 지점으로 설정된다. 예를 들어 원격 &lt;code&gt;HEAD&lt;/code&gt; 가 &lt;code&gt;next&lt;/code&gt; 를 가리키는 경우 &lt;code&gt;git remote set-head origin -a&lt;/code&gt; 는 symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; 를 &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; 로 설정 합니다. 이것은 &lt;code&gt;refs/remotes/origin/next&lt;/code&gt; 가 이미 존재하는 경우에만 작동 합니다. 그렇지 않은 경우 먼저 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="5f69d8ea721996a0e954b69bd77400aaa01f9c55" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-d&lt;/code&gt; flag, it deletes the named &amp;lt;ref&amp;gt; after verifying it still contains &amp;lt;oldvalue&amp;gt;.</source>
          <target state="translated">&lt;code&gt;-d&lt;/code&gt; 플래그를 사용하면 &amp;lt;oldvalue&amp;gt;가 여전히 포함되어 있는지 확인한 후 명명 된 &amp;lt;ref&amp;gt;를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="da9e1b9da40421df76a154165f2b54d479838ea5" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-d&lt;/code&gt; or &lt;code&gt;--delete&lt;/code&gt;, the symbolic ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is deleted.</source>
          <target state="translated">함께 &lt;code&gt;-d&lt;/code&gt; 또는 &lt;code&gt;--delete&lt;/code&gt; , 상징적 심판이 &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="6b0b5064fe468e227911615a2b7fcbafb431eef7" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-f&lt;/code&gt; option, &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; is run immediately after the remote information is set up.</source>
          <target state="translated">&lt;code&gt;-f&lt;/code&gt; 옵션을 사용하면 &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; 은 원격 정보가 설정된 직후에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4c11581a6169e0a17084bd502989c1df6d5ff9b6" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-m &amp;lt;master&amp;gt;&lt;/code&gt; option, a symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; is set up to point at remote&amp;rsquo;s &lt;code&gt;&amp;lt;master&amp;gt;&lt;/code&gt; branch. See also the set-head command.</source>
          <target state="translated">함께 &lt;code&gt;-m &amp;lt;master&amp;gt;&lt;/code&gt; 옵션 상징적-REF &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 원격의에서 지점으로 설정되어 &lt;code&gt;&amp;lt;master&amp;gt;&lt;/code&gt; 지점입니다. set-head 명령도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="734f06f2f4ad450ab9efcf1cd7537f18bb0a22f5" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-n&lt;/code&gt; option, the remote heads are not queried first with &lt;code&gt;git ls-remote &amp;lt;name&amp;gt;&lt;/code&gt;; cached information is used instead.</source>
          <target state="translated">&lt;code&gt;-n&lt;/code&gt; 옵션을 사용하면 &lt;code&gt;git ls-remote &amp;lt;name&amp;gt;&lt;/code&gt; 으로 원격 헤드를 먼저 쿼리하지 않습니다 . 대신 캐시 된 정보가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dd75e538fb39d452e807a34068040583ee9147bc" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; option, instead of the default glob refspec for the remote to track all branches under the &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/&lt;/code&gt; namespace, a refspec to track only &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is created. You can give more than one &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; to track multiple branches without grabbing all branches.</source>
          <target state="translated">함께 &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; 옵션 대신 아래에있는 모든 지점 추적 할 수있는 원격의 기본 글로브의 refspec의 &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/&lt;/code&gt; 네임 스페이스하는 refspec 만 추적하는 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 가 만들어집니다. 모든 분기를 잡지 않고 여러 분기를 추적하기 위해 둘 이상의 &lt;code&gt;-t &amp;lt;branch&amp;gt;&lt;/code&gt; 를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a17d1e0c132aee2d2be1ec1ea02b9a88fab2a36" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, a new trailer will be added, even if some trailers with the same (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair are already in the message.</source>
          <target state="translated">함께 &lt;code&gt;add&lt;/code&gt; 새로운 예고편 같은 일부 트레일러 (&amp;lt;토큰&amp;gt;, &amp;lt;값&amp;gt;) 쌍들이 이미 메시지의 경우에도 추가된다.</target>
        </trans-unit>
        <trans-unit id="bdb99f7baa9796a7b973194e1a5ab4a7e3d82b92" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, a new trailer will be added.</source>
          <target state="translated">로 &lt;code&gt;add&lt;/code&gt; , 새로운 트레일러가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3d04d4d1926f980c37f6ca9761913ed7f096d165" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, create a new branch named &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; starting at &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, and check out &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; into the new working tree. If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is omitted, it defaults to &lt;code&gt;HEAD&lt;/code&gt;. By default, &lt;code&gt;-b&lt;/code&gt; refuses to create a new branch if it already exists. &lt;code&gt;-B&lt;/code&gt; overrides this safeguard, resetting &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">로 &lt;code&gt;add&lt;/code&gt; 라는 새로운 지점 생성 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 에서 시작하는 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; , 체크 아웃 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 새로운 작업 트리에. 경우 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 가 기본값 생략 &lt;code&gt;HEAD&lt;/code&gt; 를 . 기본적으로 &lt;code&gt;-b&lt;/code&gt; 는 이미 존재하는 경우 새 분기 작성을 거부합니다. &lt;code&gt;-B&lt;/code&gt; 는이 보호 장치를 무시하고 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 를 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 로 재설정 합니다.</target>
        </trans-unit>
        <trans-unit id="6b61b0983644b0774834807009f4d278bb642b5a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, create a new branch named &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; starting at &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, and check out &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; into the new working tree. If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is omitted, it defaults to HEAD. By default, &lt;code&gt;-b&lt;/code&gt; refuses to create a new branch if it already exists. &lt;code&gt;-B&lt;/code&gt; overrides this safeguard, resetting &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">로 &lt;code&gt;add&lt;/code&gt; 라는 새로운 지점 생성 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 에서 시작하는 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; , 체크 아웃 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 새로운 작업 트리에. 경우 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; HEAD가 기본값을 생략하기로한다. 기본적으로 &lt;code&gt;-b&lt;/code&gt; 는 이미 존재하는 경우 새 분기 작성을 거부합니다. &lt;code&gt;-B&lt;/code&gt; 는이 보호 기능을 무시하고 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 를 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 로 재설정 합니다.</target>
        </trans-unit>
        <trans-unit id="d424a0ce9af1bab4df82ba9ed9c152743e40b774" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, detach &lt;code&gt;HEAD&lt;/code&gt; in the new working tree. See &quot;DETACHED HEAD&quot; in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;add&lt;/code&gt; 를 사용 하여 새 작업 트리에서 &lt;code&gt;HEAD&lt;/code&gt; 를 분리 합니다. &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]의&lt;/a&gt; &quot;DETACHED HEAD&quot;를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a273ddd960841784db1a589aad98c4feff6c226" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, detach HEAD in the new working tree. See &quot;DETACHED HEAD&quot; in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;add&lt;/code&gt; 를 사용 하여 새 작업 트리에서 HEAD를 분리하십시오. &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]의&lt;/a&gt; &quot;DETACHED HEAD&quot;를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="187a01bfec37522a00b693f68238b703a4e0897c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;add&lt;/code&gt;, suppress feedback messages.</source>
          <target state="translated">&lt;code&gt;add&lt;/code&gt; 를 사용하면 피드백 메시지가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45995ca3706219a58e816f38cd1d9bf0922ce8ca" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;addIfDifferent&lt;/code&gt;, a new trailer will be added only if no trailer with the same (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair is already in the message.</source>
          <target state="translated">함께 &lt;code&gt;addIfDifferent&lt;/code&gt; 새로운 트레일러와 같은 더 트레일러 (&amp;lt;토큰&amp;gt;, &amp;lt;값&amp;gt;) 쌍 메시지 이미없는 경우에만 추가된다.</target>
        </trans-unit>
        <trans-unit id="6e3bd24c09b16e87e69f4ad565a18cc8f733f593" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt;, a new trailer will be added only if no trailer with the same (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair is above or below the line where the new trailer will be added.</source>
          <target state="translated">함께 &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; 새로운 트레일러와 같은 더 트레일러 (&amp;lt;토큰&amp;gt;, &amp;lt;값&amp;gt;) 쌍 새로운 트레일러가 추가 될 라인 위 또는 아래에없는 경우에만 추가된다.</target>
        </trans-unit>
        <trans-unit id="c538516bcb20191b3fc9da51228fff3eefb68cdf" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;doNothing&lt;/code&gt;, nothing will be done.</source>
          <target state="translated">&lt;code&gt;doNothing&lt;/code&gt; 을 사용하면 아무 것도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="91898a3512235050c32c7a99a50c8394d7a8397d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;doNothing&lt;/code&gt;, nothing will be done; that is no new trailer will be added if there is already one with the same &amp;lt;token&amp;gt; in the message.</source>
          <target state="translated">&lt;code&gt;doNothing&lt;/code&gt; 을 사용하면 아무 것도 수행되지 않습니다. 메시지에 &amp;lt;토큰&amp;gt;이 같은 트레일러가 이미 있으면 새 트레일러가 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fafece11b5178185f0dda98fe61f1218eca3ec1e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; (or variants thereof, e.g. with &lt;code&gt;--cover-letter&lt;/code&gt; or using &lt;code&gt;Z..C&lt;/code&gt; instead of &lt;code&gt;-3 C&lt;/code&gt; to specify the range), the base tree information block is shown at the end of the first message the command outputs (either the first patch, or the cover letter), like this:</source>
          <target state="translated">와 &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; (또는 그 변형 예와 &lt;code&gt;--cover-letter&lt;/code&gt; 또는 사용 &lt;code&gt;Z..C&lt;/code&gt; 대신 &lt;code&gt;-3 C&lt;/code&gt; 를 범위 지정),베이스 트리 정보 블록에 나타낸다 다음과 같이 명령이 출력하는 첫 번째 메시지의 끝 (첫 번째 패치 또는 자기 소개서) :</target>
        </trans-unit>
        <trans-unit id="0dbfc249aea522f6a40d4b8be190d1fc0f0eadd8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;list&lt;/code&gt;, output in an easy-to-parse format for scripts. This format will remain stable across Git versions and regardless of user configuration. See below for details.</source>
          <target state="translated">&lt;code&gt;list&lt;/code&gt; 를 사용하면 파싱하기 쉬운 스크립트 형식으로 출력됩니다. 이 형식은 사용자 구성에 관계없이 Git 버전에서 안정적으로 유지됩니다. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="021957faebf0fa8a6ba6fb4276abb6b8c72afba9" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;lock&lt;/code&gt;, an explanation why the working tree is locked.</source>
          <target state="translated">&lt;code&gt;lock&lt;/code&gt; 을 사용 하면 작업 트리가 잠긴 이유를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bbe63cab2529b193584b4f7d1c86ee0207fc9968" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, do not remove anything; just report what it would remove.</source>
          <target state="translated">&lt;code&gt;prune&lt;/code&gt; 사용하면 아무것도 제거하지 마십시오. 제거 할 내용 만보고하면됩니다.</target>
        </trans-unit>
        <trans-unit id="97f5cdb302d7f0a46689004724feb3d1aca29383" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, only expire unused working trees older than &amp;lt;time&amp;gt;.</source>
          <target state="translated">&lt;code&gt;prune&lt;/code&gt; 을 사용하면 &amp;lt;time&amp;gt;보다 오래된 미사용 작업 트리 만 만료됩니다.</target>
        </trans-unit>
        <trans-unit id="fe3d9726d2a7e550ec17d9d6b1b3e9e51367506e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, only expire unused working trees older than &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;prune&lt;/code&gt; 을 사용하면 &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; 보다 오래된 사용되지 않은 작업 트리 만 만료됩니다 .</target>
        </trans-unit>
        <trans-unit id="92ffa86e9306849b846038bae2a07ad322d0f86c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;prune&lt;/code&gt;, report all removals.</source>
          <target state="translated">&lt;code&gt;prune&lt;/code&gt; 을 사용하여 모든 제거를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="f6631b122f785beeb20cb0ef884a421b144138ae" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;replace&lt;/code&gt;, an existing trailer with the same &amp;lt;token&amp;gt; will be deleted and the new trailer will be added. The deleted trailer will be the closest one (with the same &amp;lt;token&amp;gt;) to the place where the new one will be added.</source>
          <target state="translated">&lt;code&gt;replace&lt;/code&gt; 를 사용하면 &amp;lt;토큰&amp;gt;과 동일한 기존 예고편이 삭제되고 새 예고편이 추가됩니다. 삭제 된 예고편은 새 예고편이 추가 될 장소와 가장 가까운 예고편 (예 : &amp;lt;토큰&amp;gt;)입니다.</target>
        </trans-unit>
        <trans-unit id="a80ff1485c839f0e248b3acec4853d6b6aaf0d80" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;worktree add &amp;lt;path&amp;gt;&lt;/code&gt;, without &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, instead of creating a new branch from &lt;code&gt;HEAD&lt;/code&gt;, if there exists a tracking branch in exactly one remote matching the basename of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;, base the new branch on the remote-tracking branch, and mark the remote-tracking branch as &quot;upstream&quot; from the new branch.</source>
          <target state="translated">함께 &lt;code&gt;worktree add &amp;lt;path&amp;gt;&lt;/code&gt; 없이 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 대신로부터 새로운 브랜치 생성 &lt;code&gt;HEAD&lt;/code&gt; 를 원격의 기본 이름과 일치하는 정확히 하나의 추적 지점이 존재하는 경우, &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 원격 추적의 새로운 지점,베이스 분기하고 원격 추적 분기를 새 분기의 &quot;업스트림&quot;으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7b787c22358696a7fd63895c838388aed6d7912a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;worktree add &amp;lt;path&amp;gt;&lt;/code&gt;, without &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, instead of creating a new branch from HEAD, if there exists a tracking branch in exactly one remote matching the basename of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;, base the new branch on the remote-tracking branch, and mark the remote-tracking branch as &quot;upstream&quot; from the new branch.</source>
          <target state="translated">함께 &lt;code&gt;worktree add &amp;lt;path&amp;gt;&lt;/code&gt; 없이 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 대신 리모트베이스 이름과 일치하는 정확히 하나의 추적 지점이 존재하는 경우, 선두로부터의 새로운 지점을 만드는 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 원격 추적의 새로운 지점,베이스 원격 추적 분기를 새 분기에서 &quot;업스트림&quot;으로 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="660d18378dc3af084a2ac18df92d87c9aea68c5a" translate="yes" xml:space="preserve">
          <source>With Git bisect it&amp;rsquo;s a breeze: in the best case i can get a ~15 step kernel bisection done in 20-30 minutes, in an automated way. Even with manual help or when bisecting multiple, overlapping bugs, it&amp;rsquo;s rarely more than an hour.</source>
          <target state="translated">Git bisect를 사용하면 산들 바람이납니다. 가장 좋은 경우에는 자동화 된 방식으로 20-30 분 안에 ~ 15 단계 커널 bisection을 수행 할 수 있습니다. 수동 도움말이나 여러 개의 겹치는 버그를 이등분 할 때도 거의 1 시간 이상 걸리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46d101f0f209ac246ff187c45b6b808668e526b7" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;-d&lt;/code&gt; or &lt;code&gt;-D&lt;/code&gt; option, &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; will be deleted. You may specify more than one branch for deletion. If the branch currently has a reflog then the reflog will also be deleted.</source>
          <target state="translated">A를 &lt;code&gt;-d&lt;/code&gt; 또는 &lt;code&gt;-D&lt;/code&gt; 옵션, &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; 삭제됩니다. 삭제할 분기를 둘 이상 지정할 수 있습니다. 분기에 현재 reflog가있는 경우 reflog도 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f74d36fd60998cbf589b7f2b7f7bc156998c0334" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-M&lt;/code&gt; option, &amp;lt;oldbranch&amp;gt; will be renamed to &amp;lt;newbranch&amp;gt;. If &amp;lt;oldbranch&amp;gt; had a corresponding reflog, it is renamed to match &amp;lt;newbranch&amp;gt;, and a reflog entry is created to remember the branch renaming. If &amp;lt;newbranch&amp;gt; exists, -M must be used to force the rename to happen.</source>
          <target state="translated">A를 &lt;code&gt;-m&lt;/code&gt; 또는 &lt;code&gt;-M&lt;/code&gt; 옵션, &amp;lt;oldbranch&amp;gt; 이름이 바뀐에 &amp;lt;newbranch&amp;gt; 일 것이다. &amp;lt;oldbranch&amp;gt;에 해당 reflog가 있으면 이름이 &amp;lt;newbranch&amp;gt;와 일치하도록 이름이 바뀌고 분기 이름 변경을 기억하기 위해 reflog 항목이 작성됩니다. &amp;lt;newbranch&amp;gt;가 존재하면 -M을 사용하여 이름 변경을 강제 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="078f9b93867e54fc6fd5cb6cccb717d173a4bdbb" translate="yes" xml:space="preserve">
          <source>With a small group, developers may just pull changes from each other&amp;rsquo;s repositories without the need for a central maintainer.</source>
          <target state="translated">소규모 그룹에서는 개발자가 중앙 관리자 없이도 서로의 리포지토리에서 변경 사항을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d93af44627c4056a70413d4d1086a466c1eb6057" translate="yes" xml:space="preserve">
          <source>With an optional &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; argument, use the ref to find the notes to display. The ref can specify the full refname when it begins with &lt;code&gt;refs/notes/&lt;/code&gt;; when it begins with &lt;code&gt;notes/&lt;/code&gt;, &lt;code&gt;refs/&lt;/code&gt; and otherwise &lt;code&gt;refs/notes/&lt;/code&gt; is prefixed to form a full name of the ref.</source>
          <target state="translated">선택적 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 인수 와 함께 ref를 사용하여 표시 할 메모를 찾으십시오. ref는 &lt;code&gt;refs/notes/&lt;/code&gt; 시작할 때 전체 refname을 지정할 수 있습니다 . &lt;code&gt;notes/&lt;/code&gt; 시작 하면 &lt;code&gt;refs/&lt;/code&gt; 및 그렇지 않으면 &lt;code&gt;refs/notes/&lt;/code&gt; 가 접두어로 ref의 전체 이름을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="5888510f888416379a4d4b5651fc198f809cb1eb" translate="yes" xml:space="preserve">
          <source>With an optional argument, you can return to a different commit instead:</source>
          <target state="translated">선택적 인수를 사용하면 대신 다른 커밋으로 돌아갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70761b9c0ed85e86f5fe4551851f4fb12dda8ef2" translate="yes" xml:space="preserve">
          <source>With centralized revision control systems this is often accomplished by including every module in one single repository. Developers can check out all modules or only the modules they need to work with. They can even modify files across several modules in a single commit while moving things around or updating APIs and translations.</source>
          <target state="translated">중앙 집중식 개정 제어 시스템을 사용하면 모든 모듈을 하나의 단일 리포지토리에 포함시켜 종종 수행됩니다. 개발자는 모든 모듈 또는 작업해야하는 모듈 만 체크 아웃 할 수 있습니다. API 또는 변환을 이동하거나 업데이트하면서 단일 커밋으로 여러 모듈의 파일을 수정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="34547cdab6bbebc8d70f8627cf92ce4ed49693c0" translate="yes" xml:space="preserve">
          <source>With no arguments, shows a list of existing remotes. Several subcommands are available to perform operations on the remotes.</source>
          <target state="translated">인수없이 기존 리모컨 목록을 표시합니다. 리모트에서 조작을 수행하기 위해 여러 부속 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d8eac222dcf5b2fb83219646b45ebbea55b5081" translate="yes" xml:space="preserve">
          <source>With no arguments, shows the status of existing submodules. Several subcommands are available to perform operations on the submodules.</source>
          <target state="translated">인수없이 기존 하위 모듈의 상태를 표시합니다. 서브 모듈에 대한 조작을 수행하기 위해 여러 부속 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2955e54fe9fa9b7446c513283cbd98f27b722daf" translate="yes" xml:space="preserve">
          <source>With no arguments, this will:</source>
          <target state="translated">논증없이, 이것은 :</target>
        </trans-unit>
        <trans-unit id="07ab1293ff3b475c814f1fed59da838b442b2582" translate="yes" xml:space="preserve">
          <source>With no options and no COMMAND or GUIDE given, the synopsis of the &lt;code&gt;git&lt;/code&gt; command and a list of the most commonly used Git commands are printed on the standard output.</source>
          <target state="translated">옵션과 COMMAND 또는 GUIDE가 없으면 &lt;code&gt;git&lt;/code&gt; 명령 의 개요 와 가장 일반적으로 사용되는 Git 명령 목록이 표준 출력에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="5afd0acc1bfdb6a1daab0a26aea947b62407909e" translate="yes" xml:space="preserve">
          <source>With something like git.git current tree, I get:</source>
          <target state="translated">git.git 현재 트리와 같은 것으로 다음을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="48292de53da5a3060e12b426e889eefbf2d24e76" translate="yes" xml:space="preserve">
          <source>With that configuration the full path to browse repositories would be:</source>
          <target state="translated">이 구성을 사용하면 리포지토리를 탐색하는 전체 경로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de963656527f9e7a6067d643ee4aa5bfca1b2d08" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--append&lt;/code&gt; option, include all commits that are present in the existing commit-graph file.</source>
          <target state="translated">&lt;code&gt;--append&lt;/code&gt; 옵션을 사용하면 기존 커밋 그래프 파일에있는 모든 커밋을 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="14495f11a1a9217fb75c7d6db611a80cccd6e859" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--branch&lt;/code&gt; option, the command takes a name and checks if it can be used as a valid branch name (e.g. when creating a new branch). But be cautious when using the previous checkout syntax that may refer to a detached HEAD state. The rule &lt;code&gt;git check-ref-format --branch $name&lt;/code&gt; implements may be stricter than what &lt;code&gt;git check-ref-format refs/heads/$name&lt;/code&gt; says (e.g. a dash may appear at the beginning of a ref component, but it is explicitly forbidden at the beginning of a branch name). When run with &lt;code&gt;--branch&lt;/code&gt; option in a repository, the input is first expanded for the &amp;ldquo;previous checkout syntax&amp;rdquo; &lt;code&gt;@{-n}&lt;/code&gt;. For example, &lt;code&gt;@{-1}&lt;/code&gt; is a way to refer the last thing that was checked out using &quot;git switch&quot; or &quot;git checkout&quot; operation. This option should be used by porcelains to accept this syntax anywhere a branch name is expected, so they can act as if you typed the branch name. As an exception note that, the &amp;ldquo;previous checkout operation&amp;rdquo; might result in a commit object name when the N-th last thing checked out was not a branch.</source>
          <target state="translated">으로 &lt;code&gt;--branch&lt;/code&gt; 가 (예를 들어, 새로운 지점을 만들 때) 유효한 지점 이름으로 사용 할 수있는 경우 옵션, 명령은 이름과 검사를합니다. 그러나 분리 된 HEAD 상태를 참조 할 수있는 이전 체크 아웃 구문을 사용할 때는주의하십시오. &lt;code&gt;git check-ref-format --branch $name&lt;/code&gt; 구현 규칙 은 &lt;code&gt;git check-ref-format refs/heads/$name&lt;/code&gt; 보다 엄격 할 수 있습니다 (예 : 대시는 ref 구성 요소의 시작 부분에 나타날 수 있지만 명시 적으로 나타납니다) 지점 이름의 시작 부분에서 금지됨). 저장소에서 &lt;code&gt;--branch&lt;/code&gt; 옵션을 사용하여 실행하면 먼저 &quot;이전 체크 아웃 구문&quot; &lt;code&gt;@{-n}&lt;/code&gt; 대한 입력이 확장됩니다 . 예를 들어, &lt;code&gt;@{-1}&lt;/code&gt; &quot;git switch&quot;또는 &quot;git checkout&quot;조작을 사용하여 마지막으로 체크 아웃 된 것을 참조하는 방법입니다. 이 옵션은 도자기에서 분기 이름이 필요한 곳이면 어디에서나이 구문을 허용하므로 분기 이름을 입력 한 것처럼 작동 할 수 있어야합니다. 예외적으로,&amp;ldquo;이전 체크 아웃 작업&amp;rdquo;으로 인해 마지막으로 체크 아웃 한 N 번째 항목이 분기가 아닌 경우 커밋 개체 이름이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="294719ccdfaa2864ec086fd6924ef46c18c6d01c" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--changed-paths&lt;/code&gt; option, compute and write information about the paths changed between a commit and its first parent. This operation can take a while on large repositories. It provides significant performance gains for getting history of a directory or a file with &lt;code&gt;git log -- &amp;lt;path&amp;gt;&lt;/code&gt;. If this option is given, future commit-graph writes will automatically assume that this option was intended. Use &lt;code&gt;--no-changed-paths&lt;/code&gt; to stop storing this data.</source>
          <target state="translated">와 &lt;code&gt;--changed-paths&lt;/code&gt; 는 A 커밋 사이에서 변화 경로와 최초의 부모에 대한 옵션, 컴퓨팅 및 쓰기 정보를 제공합니다. 이 작업은 큰 저장소에서 다소 시간이 걸릴 수 있습니다. &lt;code&gt;git log -- &amp;lt;path&amp;gt;&lt;/code&gt; 를 사용하여 디렉토리 또는 파일 기록을 가져 오는 데 상당한 성능 향상을 제공합니다 . 이 옵션이 제공되면 향후 커밋 그래프 쓰기는이 옵션이 의도 된 것으로 자동으로 가정합니다. 이 데이터 저장을 중지 하려면 &lt;code&gt;--no-changed-paths&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ac44a38e65d55dddeac740d3be63e38e85fa148" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--max-new-filters=&amp;lt;n&amp;gt;&lt;/code&gt; option, generate at most &lt;code&gt;n&lt;/code&gt; new Bloom filters (if &lt;code&gt;--changed-paths&lt;/code&gt; is specified). If &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt;, no limit is enforced. Only commits present in the new layer count against this limit. To retroactively compute Bloom filters over earlier layers, it is advised to use &lt;code&gt;--split=replace&lt;/code&gt;. Overrides the &lt;code&gt;commitGraph.maxNewFilters&lt;/code&gt; configuration.</source>
          <target state="translated">으로 &lt;code&gt;--max-new-filters=&amp;lt;n&amp;gt;&lt;/code&gt; 옵션 많아야 생성 &lt;code&gt;n&lt;/code&gt; (만약 새로운 블룸 필터 &lt;code&gt;--changed-paths&lt;/code&gt; 지정된다). 경우 &lt;code&gt;n&lt;/code&gt; 이 있다 &lt;code&gt;-1&lt;/code&gt; , 제한이 적용되지 않습니다. 새 레이어에있는 커밋 만이 제한에 포함됩니다. 이전 레이어에서 Bloom 필터를 소급하여 계산하려면 &lt;code&gt;--split=replace&lt;/code&gt; 를 사용하는 것이 좋습니다 . &lt;code&gt;commitGraph.maxNewFilters&lt;/code&gt; 구성을 재정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f26f07033bd08bfdb6102afbc60e4bb690a51e35" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--reachable&lt;/code&gt; option, generate the new commit graph by walking commits starting at all refs. (Cannot be combined with &lt;code&gt;--stdin-commits&lt;/code&gt; or &lt;code&gt;--stdin-packs&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;--reachable&lt;/code&gt; 옵션을 사용하면 모든 심판에서 시작되는 커밋을 걸어 새로운 커밋 그래프를 생성합니다. &lt;code&gt;--stdin-commits&lt;/code&gt; 또는 &lt;code&gt;--stdin-packs&lt;/code&gt; 와 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="bced3fa737464959bcb0c4d4992aedaa6293d7b5" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--shallow&lt;/code&gt; option, only check the tip commit-graph file in a chain of split commit-graphs.</source>
          <target state="translated">&lt;code&gt;--shallow&lt;/code&gt; 옵션을 사용하면 분할 커밋 그래프 체인에서 tip commit-graph 파일 만 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="023fb87ae200847a2eb976930adb7f7ff9a576bb" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--split&lt;/code&gt; option, write the commit-graph as a chain of multiple commit-graph files stored in &lt;code&gt;&amp;lt;dir&amp;gt;/info/commit-graphs&lt;/code&gt;. The new commits not already in the commit-graph are added in a new &quot;tip&quot; file. This file is merged with the existing file if the following merge conditions are met:</source>
          <target state="translated">&lt;code&gt;--split&lt;/code&gt; 옵션을 사용하여 commit-graph를 &lt;code&gt;&amp;lt;dir&amp;gt;/info/commit-graphs&lt;/code&gt; 에 저장된 여러 commit-graph 파일의 체인으로 작성하십시오 . commit-graph에 아직없는 새로운 commit은 새로운 &quot;tip&quot;파일에 추가됩니다. 다음 병합 조건이 충족되면이 파일은 기존 파일과 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="6bf69abea1fff62b20072adaab62de0f43e36b76" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--split[=&amp;lt;strategy&amp;gt;]&lt;/code&gt; option, write the commit-graph as a chain of multiple commit-graph files stored in &lt;code&gt;&amp;lt;dir&amp;gt;/info/commit-graphs&lt;/code&gt;. Commit-graph layers are merged based on the strategy and other splitting options. The new commits not already in the commit-graph are added in a new &quot;tip&quot; file. This file is merged with the existing file if the following merge conditions are met:</source>
          <target state="translated">으로 &lt;code&gt;--split[=&amp;lt;strategy&amp;gt;]&lt;/code&gt; 복수의 체인에 저장된 파일 - 그래프 커밋 옵션 커밋 그래프를 작성 &lt;code&gt;&amp;lt;dir&amp;gt;/info/commit-graphs&lt;/code&gt; . 커밋 그래프 레이어는 전략 및 기타 분할 옵션에 따라 병합됩니다. commit-graph에 아직없는 새 커밋은 새 &quot;tip&quot;파일에 추가됩니다. 다음 병합 조건이 충족되는 경우이 파일은 기존 파일과 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="0f402e69b2097f87a53ae26564ee053ba1f630ec" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--stdin-commits&lt;/code&gt; option, generate the new commit graph by walking commits starting at the commits specified in stdin as a list of OIDs in hex, one OID per line. (Cannot be combined with &lt;code&gt;--stdin-packs&lt;/code&gt; or &lt;code&gt;--reachable&lt;/code&gt;.)</source>
          <target state="translated">으로 &lt;code&gt;--stdin-commits&lt;/code&gt; 옵션, 새로운 16 진수의 OID를 목록, 한 줄에 하나의 OID로하여 stdin에 지정된 커밋에서 시작 도보 커밋으로 그래프를 저지 생성합니다. &lt;code&gt;--stdin-packs&lt;/code&gt; 또는 &lt;code&gt;--reachable&lt;/code&gt; 과 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4837cdd22ed59b809de4737c644da886aae1ea19" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--stdin-commits&lt;/code&gt; option, generate the new commit graph by walking commits starting at the commits specified in stdin as a list of OIDs in hex, one OID per line. OIDs that resolve to non-commits (either directly, or by peeling tags) are silently ignored. OIDs that are malformed, or do not exist generate an error. (Cannot be combined with &lt;code&gt;--stdin-packs&lt;/code&gt; or &lt;code&gt;--reachable&lt;/code&gt;.)</source>
          <target state="translated">으로 &lt;code&gt;--stdin-commits&lt;/code&gt; 옵션, 새로운 16 진수의 OID를 목록, 한 줄에 하나의 OID로하여 stdin에 지정된 커밋에서 시작 도보 커밋으로 그래프를 저지 생성합니다. 비 커밋 (직접 또는 필링 태그)로 확인되는 OID는 자동으로 무시됩니다. 형식이 잘못되었거나 존재하지 않는 OID는 오류를 생성합니다. ( &lt;code&gt;--stdin-packs&lt;/code&gt; 또는 &lt;code&gt;--reachable&lt;/code&gt; 과 함께 사용할 수 없습니다 .)</target>
        </trans-unit>
        <trans-unit id="eaf73ef52d157ce1e4ddc4b827c0a6415ea79de1" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;--stdin-packs&lt;/code&gt; option, generate the new commit graph by walking objects only in the specified pack-indexes. (Cannot be combined with &lt;code&gt;--stdin-commits&lt;/code&gt; or &lt;code&gt;--reachable&lt;/code&gt;.)</source>
          <target state="translated">으로 &lt;code&gt;--stdin-packs&lt;/code&gt; 옵션, 새로운 도보로 그래프는 지정된 팩 - 인덱스에서 개체를 커밋 생성합니다. &lt;code&gt;--stdin-commits&lt;/code&gt; 또는 &lt;code&gt;--reachable&lt;/code&gt; 과 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="17857b1a19de2786ab177b98550f7755d5958169" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;subsystem&lt;/code&gt; reflog: after &lt;code&gt;git fetch&lt;/code&gt;, the old tip of &lt;code&gt;subsystem&lt;/code&gt; is at &lt;code&gt;subsystem@{1}&lt;/code&gt;. Subsequent fetches will increase the number. (See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt;.)</source>
          <target state="translated">으로 &lt;code&gt;subsystem&lt;/code&gt; reflog : 후 &lt;code&gt;git fetch&lt;/code&gt; 의 이전 팁 &lt;code&gt;subsystem&lt;/code&gt; 에있다 &lt;code&gt;subsystem@{1}&lt;/code&gt; . 이후에 가져 오면 숫자가 증가합니다. ( &lt;a href=&quot;git-reflog&quot;&gt;git-reflog [1]&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="b4f2100600cd65d2bb507aefd40b38b428ed31a7" translate="yes" xml:space="preserve">
          <source>With the example above that would give:</source>
          <target state="translated">위의 예를 통해 다음과 같은 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a003c8ea87ae62c71ced8657b18db066ae621f53" translate="yes" xml:space="preserve">
          <source>With the exception of raw file data (which Git does not interpret) the fast-import input format is text (ASCII) based. This text based format simplifies development and debugging of frontend programs, especially when a higher level language such as Perl, Python or Ruby is being used.</source>
          <target state="translated">원시 파일 데이터 (Git이 해석하지 않는)를 제외하고 빠른 가져 오기 입력 형식은 텍스트 (ASCII)입니다. 이 텍스트 기반 형식은 특히 Perl, Python 또는 Ruby와 같은 고급 언어를 사용하는 경우 프론트 엔드 프로그램의 개발 및 디버깅을 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="832b24adba81a74f8f3c27d1a374c3c9abe6eae9" translate="yes" xml:space="preserve">
          <source>With the latter, you can use the manual viewer of your choice; see &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt; for more information.</source>
          <target state="translated">후자를 사용하면 선택한 수동 뷰어를 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fd552b2cf02d64fea6c3a2fbecdcfeec69fa5199" translate="yes" xml:space="preserve">
          <source>With the right arguments, &lt;code&gt;git diff&lt;/code&gt; can also show us the difference between the working directory and the last commit, or between the index and the last commit:</source>
          <target state="translated">올바른 인수를 사용하면 &lt;code&gt;git diff&lt;/code&gt; 는 작업 디렉토리와 마지막 커밋 또는 인덱스와 마지막 커밋의 차이점을 보여줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6936b3f47f8ae1f272ba09aecb9105ac3f327d8a" translate="yes" xml:space="preserve">
          <source>With the strategies that use 3-way merge (including the default, &lt;code&gt;recursive&lt;/code&gt;), if a change is made on both branches, but later reverted on one of the branches, that change will be present in the merged result; some people find this behavior confusing. It occurs because only the heads and the merge base are considered when performing a merge, not the individual commits. The merge algorithm therefore considers the reverted change as no change at all, and substitutes the changed version instead.</source>
          <target state="translated">3 방향 병합 (기본값, &lt;code&gt;recursive&lt;/code&gt; 포함)을 사용하는 전략을 사용 하면 두 분기 모두에서 변경이 이루어지고 나중에 분기 중 하나에서 복귀 된 경우 해당 변경 사항이 병합 된 결과에 나타납니다. 어떤 사람들은이 행동이 혼란 스럽다고 생각합니다. 개별 커밋이 아닌 병합을 수행 할 때 헤드와 병합 기반 만 고려되기 때문에 발생합니다. 따라서 병합 알고리즘은 되 돌린 변경 사항을 전혀 변경되지 않은 것으로 간주하고 변경된 버전을 대신 사용합니다.</target>
        </trans-unit>
        <trans-unit id="993a54cdc4357f066aea765f4571bf68eff0acc7" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git cherry-pick&lt;/code&gt; will let you edit the commit message prior to committing.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;git cherry-pick&lt;/code&gt; 을 사용하여 커밋하기 전에 커밋 메시지를 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="333853f3b4bc551496449cd51ab3f625f2fd83b5" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git gc&lt;/code&gt; checks whether any housekeeping is required; if not, it exits without performing any work.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;git gc&lt;/code&gt; 는 하우스 키핑이 필요한지 확인합니다. 그렇지 않으면 작업을 수행하지 않고 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="71e625d3b0cf2785820345a3c9b0fc38126ae685" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git revert&lt;/code&gt; will let you edit the commit message prior to committing the revert. This is the default if you run the command from a terminal.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;git revert&lt;/code&gt; 를 사용하여 되돌리기를 커밋하기 전에 커밋 메시지를 편집 할 수 있습니다. 터미널에서 명령을 실행하는 경우 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="c4b763c3b176a1288a147104d8354f56c0e27e09" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;git revert&lt;/code&gt; will not start the commit message editor.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;git revert&lt;/code&gt; 는 커밋 메시지 편집기를 시작하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8c4fe13a9c7d1e41585a8e2b5418a2b1ca5a28f1" translate="yes" xml:space="preserve">
          <source>With this option, &lt;code&gt;merge-recursive&lt;/code&gt; spends a little extra time to avoid mismerges that sometimes occur due to unimportant matching lines (e.g., braces from distinct functions). Use this when the branches to be merged have diverged wildly. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--patience&lt;/code&gt;.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;merge-recursive&lt;/code&gt; 는 중요하지 않은 일치하는 줄 (예 : 고유 함수의 중괄호)로 인해 때때로 발생하는 혼란을 피하기 위해 약간의 추가 시간을 소비합니다. 병합 할 브랜치가 심하게 분기 된 경우이 옵션을 사용하십시오. &lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--patience&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b7fa933690b4dfe40d9dc500f9cfa6ba3897c3d" translate="yes" xml:space="preserve">
          <source>With this option, diff output for a merge commit shows the differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time. Furthermore, it lists only files which were modified from all parents.</source>
          <target state="translated">이 옵션을 사용하면 병합 커밋에 대한 diff 출력은 부모와 결과 사이에 한 번에 하나씩 diff를 표시하는 대신 각 부모와 병합 결과의 차이를 동시에 표시합니다. 또한 모든 상위에서 수정 된 파일 만 나열합니다.</target>
        </trans-unit>
        <trans-unit id="3524864d6b6fccf88decb6caefb79eeb0a8e7c7e" translate="yes" xml:space="preserve">
          <source>With this option, git will replace all refnames, paths, blob contents, commit and tag messages, names, and email addresses in the output with anonymized data. Two instances of the same string will be replaced equivalently (e.g., two commits with the same author will have the same anonymized author in the output, but bear no resemblance to the original author string). The relationship between commits, branches, and tags is retained, as well as the commit timestamps (but the commit messages and refnames bear no resemblance to the originals). The relative makeup of the tree is retained (e.g., if you have a root tree with 10 files and 3 trees, so will the output), but their names and the contents of the files will be replaced.</source>
          <target state="translated">이 옵션을 사용하면 git은 출력의 모든 참조 이름, 경로, 얼룩 내용, 커밋 및 태그 메시지, 이름 및 전자 메일 주소를 익명 데이터로 바꿉니다. 동일한 문자열의 두 인스턴스는 동일하게 대체됩니다 (예 : 동일한 작성자의 두 커밋은 출력에서 ​​동일한 익명의 작성자를 갖지만 원래 작성자 문자열과 유사하지 않음). 커밋, 분기 및 태그 간의 관계는 커밋 타임 스탬프와 함께 유지되지만 커밋 메시지 및 참조 이름은 원본과 유사하지 않습니다. 트리의 상대적 구성은 유지되지만 (예를 들어, 파일이 10 개이고 트리가 3 개인 루트 트리가있는 경우 출력도 마찬가지 임) 파일의 이름과 내용이 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="cbb1ff7744c2585e2c6b4c0275539aaae99818d7" translate="yes" xml:space="preserve">
          <source>With this option, parents that are hidden by grafts are packed nevertheless.</source>
          <target state="translated">그럼에도 불구하고이 옵션을 사용하면 이식편에 의해 숨겨진 부모가 포장됩니다.</target>
        </trans-unit>
        <trans-unit id="64d24b372615e7424e92210d8b3079a3b6d54b46" translate="yes" xml:space="preserve">
          <source>With this option, the command includes the current branch to the list of revs to be shown when it is not given on the command line.</source>
          <target state="translated">이 옵션을 사용하면 명령 행에 표시되지 않을 때 표시 할 rev 목록에 대한 현재 분기가 명령에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a7994938c4128018ec7f46d918cac8d359a1f2eb" translate="yes" xml:space="preserve">
          <source>With this, &lt;code&gt;git show-branch&lt;/code&gt; without extra parameters would show only the primary branches. In addition, if you happen to be on your topic branch, it is shown as well.</source>
          <target state="translated">이를 통해 추가 매개 변수가없는 &lt;code&gt;git show-branch&lt;/code&gt; 는 기본 분기 만 표시합니다. 또한 토픽 브랜치에있을 경우에도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7d389d82d11c207ddbcbb54d477d308b2e5d9f7f" translate="yes" xml:space="preserve">
          <source>With this, Alice can perform the first part of the &quot;pull&quot; operation alone using the &lt;code&gt;git fetch&lt;/code&gt; command without merging them with her own branch, using:</source>
          <target state="translated">이를 통해 Alice는 다음을 사용하여 자체 분기와 병합하지 않고 &lt;code&gt;git fetch&lt;/code&gt; 명령을 사용하여 &quot;풀&quot;작업의 첫 번째 부분 만 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6062bf6506f2ab2b976dee38aa5322c59a129e2f" translate="yes" xml:space="preserve">
          <source>Within a linked working tree, $GIT_DIR is set to point to this private directory (e.g. &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; in the example) and $GIT_COMMON_DIR is set to point back to the main working tree&amp;rsquo;s $GIT_DIR (e.g. &lt;code&gt;/path/main/.git&lt;/code&gt;). These settings are made in a &lt;code&gt;.git&lt;/code&gt; file located at the top directory of the linked working tree.</source>
          <target state="translated">연결된 작업 트리 내에서 $ &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; 개인 디렉토리 (예 : /path/main/.git/worktrees/test-next )를 가리 키도록 설정되고 $ GIT_COMMON_DIR은 기본 작업 트리의 $ GIT_DIR을 다시 가리 키도록 설정됩니다. (예 : &lt;code&gt;/path/main/.git&lt;/code&gt; ). 이러한 설정은 연결된 작업 트리의 최상위 디렉토리 에있는 &lt;code&gt;.git&lt;/code&gt; 파일 에서 이루어집니다 .</target>
        </trans-unit>
        <trans-unit id="28d243903fe73e45525c0f96e48fd5d6abc9c7f9" translate="yes" xml:space="preserve">
          <source>Within a linked working tree, &lt;code&gt;$GIT_DIR&lt;/code&gt; is set to point to this private directory (e.g. &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; in the example) and &lt;code&gt;$GIT_COMMON_DIR&lt;/code&gt; is set to point back to the main working tree&amp;rsquo;s &lt;code&gt;$GIT_DIR&lt;/code&gt; (e.g. &lt;code&gt;/path/main/.git&lt;/code&gt;). These settings are made in a &lt;code&gt;.git&lt;/code&gt; file located at the top directory of the linked working tree.</source>
          <target state="translated">연결된 작업 트리 내에서 &lt;code&gt;$GIT_DIR&lt;/code&gt; &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; 개인 디렉터리 (예 : /path/main/.git/worktrees/test-next ) 를 가리 키도록 설정 되고 &lt;code&gt;$GIT_COMMON_DIR&lt;/code&gt; 은 기본 작업 트리의 &lt;code&gt;$GIT_DIR&lt;/code&gt; GIT_DIR 을 다시 가리 키도록 설정됩니다. (예 : &lt;code&gt;/path/main/.git&lt;/code&gt; ). 이러한 설정은 연결된 작업 트리의 최상위 디렉토리 에있는 &lt;code&gt;.git&lt;/code&gt; 파일 에서 이루어집니다 .</target>
        </trans-unit>
        <trans-unit id="f531335c76344721aaf744205582ff3be68651bd" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;--all&lt;/code&gt; and without any &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt;, the heads that exist both on the local side and on the remote side are updated.</source>
          <target state="translated">않고 &lt;code&gt;--all&lt;/code&gt; 어떤없이 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 로컬 측과 원격 측에 모두 존재하는 헤드가 갱신된다.</target>
        </trans-unit>
        <trans-unit id="af870a4c72e2ec7c668a803b1e745b16df6d1c9d" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;--follow-symlinks&lt;/code&gt;, these would print data about the symlink itself. In the case of &lt;code&gt;HEAD:link&lt;/code&gt;, you would see</source>
          <target state="translated">&lt;code&gt;--follow-symlinks&lt;/code&gt; 가 없으면 심볼릭 링크 자체에 대한 데이터를 인쇄합니다. 의 경우 &lt;code&gt;HEAD:link&lt;/code&gt; , 당신은 볼 것이다</target>
        </trans-unit>
        <trans-unit id="a213d6298e44415b29925050ee6ffa235637e828" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;--force&lt;/code&gt;, the &amp;lt;src&amp;gt; ref is stored at the remote only if &amp;lt;dst&amp;gt; does not exist, or &amp;lt;dst&amp;gt; is a proper subset (i.e. an ancestor) of &amp;lt;src&amp;gt;. This check, known as &quot;fast-forward check&quot;, is performed in order to avoid accidentally overwriting the remote ref and lose other peoples' commits from there.</source>
          <target state="translated">&lt;code&gt;--force&lt;/code&gt; 가 없으면 &amp;lt;src&amp;gt; 참조는 &amp;lt;dst&amp;gt;가 없거나 &amp;lt;dst&amp;gt;가 &amp;lt;src&amp;gt;의 적절한 하위 집합 (즉, 조상) 인 경우에만 원격에 저장됩니다. &quot;빨리 감기 검사&quot;라고하는이 검사는 실수로 원격 참조를 덮어 쓰지 않고 다른 사람들의 커밋을 잃지 않도록하기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="44aa5155d389a8a00fc9a9c0d5c5dc24c0b6b423" translate="yes" xml:space="preserve">
          <source>Without additional configuration, pushes the current branch to the configured upstream (&lt;code&gt;remote.origin.merge&lt;/code&gt; configuration variable) if it has the same name as the current branch, and errors out without pushing otherwise.</source>
          <target state="translated">추가 구성없이 현재 분기와 현재 분기 와 이름이 같은 경우 현재 분기를 구성된 업스트림 ( &lt;code&gt;remote.origin.merge&lt;/code&gt; 구성 변수)으로 푸시하고 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0d4981e0bf66e69e6f534946531426d82d26ec6d" translate="yes" xml:space="preserve">
          <source>Without an optional path parameter, all files and subdirectories of the current working directory are included in the archive. If one or more paths are specified, only these are included.</source>
          <target state="translated">선택적 경로 매개 변수가 없으면 현재 작업 디렉토리의 모든 파일 및 서브 디렉토리가 아카이브에 포함됩니다. 하나 이상의 경로가 지정되면 경로 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0aaf17e36c6d625d7976371bb21725d2cea205e0" translate="yes" xml:space="preserve">
          <source>Without any credential helpers defined, Git will try the following strategies to ask the user for usernames and passwords:</source>
          <target state="translated">자격 증명 도우미가 정의되지 않은 경우 Git은 사용자에게 사용자 이름과 암호를 요청하기 위해 다음 전략을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="6f8c2669a27a9c22abf3f515b27b1a9a5be3b6dc" translate="yes" xml:space="preserve">
          <source>Without disambiguating &lt;code&gt;--&lt;/code&gt;, Git makes a reasonable guess, but errors out and asking you to disambiguate when ambiguous. E.g. if you have a file called HEAD in your work tree, &lt;code&gt;git diff HEAD&lt;/code&gt; is ambiguous, and you have to say either &lt;code&gt;git diff HEAD --&lt;/code&gt; or &lt;code&gt;git diff -- HEAD&lt;/code&gt; to disambiguate.</source>
          <target state="translated">명확하지 않은 &lt;code&gt;--&lt;/code&gt; , Git은 합리적인 추측을했지만, 오류가 발생하여 모호 할 때 명확하게 할 것을 요구합니다. 예를 들어 작업 트리에 HEAD라는 파일이 있으면 &lt;code&gt;git diff HEAD&lt;/code&gt; 가 모호 &lt;code&gt;git diff HEAD --&lt;/code&gt; 또는 &lt;code&gt;git diff -- HEAD&lt;/code&gt; 중 하나 를 명확히해야합니다.</target>
        </trans-unit>
        <trans-unit id="636ef8b24660180a9f9d02cde9f707a809036029" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;-z&lt;/code&gt; option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;-z&lt;/code&gt; 옵션이 없으면 구성 변수 &lt;code&gt;core.quotePath&lt;/code&gt; 에 설명 된대로 &quot;특이하지 않은&quot;문자가있는 경로 이름이 인용됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fbf6695514712c3a8e39b514953f35111f6c3ca8" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;-z&lt;/code&gt; option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). Using &lt;code&gt;-z&lt;/code&gt; the filename is output verbatim and the line is terminated by a NUL byte.</source>
          <target state="translated">&lt;code&gt;-z&lt;/code&gt; 옵션이 없으면 구성 변수 &lt;code&gt;core.quotePath&lt;/code&gt; 에 설명 된대로 &quot;특이하지 않은&quot;문자가있는 경로 이름이 인용됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ). &lt;code&gt;-z&lt;/code&gt; 를 사용 하면 파일 이름이 그대로 출력되고 행이 NUL 바이트로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="94da29d7f90d6f6f16856adba693bd0f5ed5aeb9" translate="yes" xml:space="preserve">
          <source>Without the &lt;em&gt;--more=1&lt;/em&gt; option, &lt;em&gt;git show-branch&lt;/em&gt; would not output the &lt;em&gt;[master^]&lt;/em&gt; commit, as &lt;em&gt;[mybranch]&lt;/em&gt; commit is a common ancestor of both &lt;em&gt;master&lt;/em&gt; and &lt;em&gt;mybranch&lt;/em&gt; tips. Please see &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">&lt;em&gt;--more = 1&lt;/em&gt; 옵션을 사용 하지 않으면 &lt;em&gt;git show-branch&lt;/em&gt; 는 &lt;em&gt;[master ^]&lt;/em&gt; 커밋을 출력하지 않습니다. &lt;em&gt;[mybranch]&lt;/em&gt; 커밋은 &lt;em&gt;마스터&lt;/em&gt; 및 &lt;em&gt;mybranch&lt;/em&gt; 팁 의 공통 조상이기 때문 입니다. 자세한 내용은 &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c29d8269d6df0a76bd7b7031ef1a5a35a844def8" translate="yes" xml:space="preserve">
          <source>Without this flag, &lt;code&gt;git log -p &amp;lt;path&amp;gt;...&lt;/code&gt; shows commits that touch the specified paths, and diffs about the same specified paths. With this, the full diff is shown for commits that touch the specified paths; this means that &quot;&amp;lt;path&amp;gt;&amp;hellip;​&quot; limits only commits, and doesn&amp;rsquo;t limit diff for those commits.</source>
          <target state="translated">이 플래그가 없으면 &lt;code&gt;git log -p &amp;lt;path&amp;gt;...&lt;/code&gt; 는 지정된 경로를 터치하는 커밋을 표시하고 동일한 지정된 경로를 비교합니다. 이를 통해 지정된 경로를 터치하는 커밋에 대한 전체 diff가 표시됩니다. 이것은 &quot;&amp;lt;path&amp;gt;&amp;hellip;&quot;는 커밋 만 제한하고 커밋에 대한 차이점을 제한하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b86cf57585935f6e60cc9059e45208393d99c9a8" translate="yes" xml:space="preserve">
          <source>Without this option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">이 옵션이 없으면 구성 변수 &lt;code&gt;core.quotePath&lt;/code&gt; 에 설명 된대로 &quot;비정상적인&quot;문자가 포함 된 경로 이름이 인용됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8450aafea5471fb336aa6711b707fb955fd65d91" translate="yes" xml:space="preserve">
          <source>Workflow for a third party library</source>
          <target state="translated">써드 파티 라이브러리의 워크 플로우</target>
        </trans-unit>
        <trans-unit id="8dfb0e4b50fd82c5ff8bc5fed81147f5e4aadb05" translate="yes" xml:space="preserve">
          <source>Workflow for an artificially split repo</source>
          <target state="translated">인위적으로 분할 된 저장소에 대한 워크 플로우</target>
        </trans-unit>
        <trans-unit id="825ce9e97dc41179ec167b83be91179b5dacd316" translate="yes" xml:space="preserve">
          <source>Workflows</source>
          <target state="translated">Workflows</target>
        </trans-unit>
        <trans-unit id="72b02433b5041ac5ef6045242ff8d0e2784944a3" translate="yes" xml:space="preserve">
          <source>Working branch; defaults to HEAD.</source>
          <target state="translated">워킹 브랜치; 기본값은 HEAD입니다.</target>
        </trans-unit>
        <trans-unit id="a2b68acce45b31c1701e61880a9ac430bd217ef5" translate="yes" xml:space="preserve">
          <source>Working directory specific configuration file for the main working directory in multiple working directory setup (see &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt;).</source>
          <target state="translated">여러 작업 디렉토리 설정에서 기본 작업 디렉토리에 대한 작업 디렉토리 특정 구성 파일 ( &lt;a href=&quot;git-worktree&quot;&gt;git-worktree [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="29f32a47a3074cae8d2558abdc45a4c7a3f4de27" translate="yes" xml:space="preserve">
          <source>Working directory specific configuration file.</source>
          <target state="translated">작업 디렉토리 특정 구성 파일.</target>
        </trans-unit>
        <trans-unit id="b7010e71f35d363293e1c71cea9eb7b673f227d7" translate="yes" xml:space="preserve">
          <source>Working trees can be identified by path, either relative or absolute.</source>
          <target state="translated">작업 트리는 상대 또는 절대 경로로 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5850a4e043e763eb3c70b51337df764ed12f013" translate="yes" xml:space="preserve">
          <source>Working with others</source>
          <target state="translated">다른 사람들과 함께 일하기</target>
        </trans-unit>
        <trans-unit id="883363a342498bf776fadbacf0d9322246ddce5d" translate="yes" xml:space="preserve">
          <source>Working with others, shared repository style</source>
          <target state="translated">다른 사람과 작업, 공유 저장소 스타일</target>
        </trans-unit>
        <trans-unit id="62159bf12f9108d11431e1d1114bdbbeecf78451" translate="yes" xml:space="preserve">
          <source>Works just like --signature except the signature is read from a file.</source>
          <target state="translated">서명을 파일에서 읽는 것을 제외하고 --signature와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="097006f59137099e2d2ccff414198fea83903044" translate="yes" xml:space="preserve">
          <source>Works just like format.signature except the contents of the file specified by this variable will be used as the signature.</source>
          <target state="translated">이 변수로 지정된 파일의 내용이 서명으로 사용된다는 점을 제외하면 format.signature와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c45647582ec4fc92bdcd3ecd1a16e9638ca339a8" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;git push &amp;lt;remote&amp;gt;&lt;/code&gt;, where &amp;lt;remote&amp;gt; is the current branch&amp;rsquo;s remote (or &lt;code&gt;origin&lt;/code&gt;, if no remote is configured for the current branch).</source>
          <target state="translated">&lt;code&gt;git push &amp;lt;remote&amp;gt;&lt;/code&gt; 와 같이 작동합니다 . 여기서 &amp;lt;remote&amp;gt;는 현재 브랜치의 리모트 (또는 현재 브랜치에 대해 리모트가 구성되어 있지 않은 경우 &lt;code&gt;origin&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="96f0b3b7db8530493b30466426fa80c5c21f66c1" translate="yes" xml:space="preserve">
          <source>Wrap code spawning child processes.</source>
          <target state="translated">코드 생성 하위 프로세스를 랩핑하십시오.</target>
        </trans-unit>
        <trans-unit id="1f9c72af7bca7c9666626fcb471d6065e154c93d" translate="yes" xml:space="preserve">
          <source>Write a MIDX file for the packfiles in an alternate object store.</source>
          <target state="translated">대체 오브젝트 저장소에 팩 파일에 대한 MIDX 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="36b48ab2e331354b7c3cc2f14ff9d8ea9d1001c3" translate="yes" xml:space="preserve">
          <source>Write a MIDX file for the packfiles in the current .git folder.</source>
          <target state="translated">현재 .git 폴더에 팩 파일에 대한 MIDX 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b42a0c66496716fcd8c88f5906d20e5cf08f4975" translate="yes" xml:space="preserve">
          <source>Write a chapter on using plumbing and writing scripts.</source>
          <target state="translated">배관 사용 및 스크립트 작성에 관한 장을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c8e128b9f546fd58c7e614d0f8b8821821084ae1" translate="yes" xml:space="preserve">
          <source>Write a commit-graph after fetching. This overrides the config setting &lt;code&gt;fetch.writeCommitGraph&lt;/code&gt;.</source>
          <target state="translated">페치 후 커밋 그래프를 작성하십시오. 이는 구성 설정 &lt;code&gt;fetch.writeCommitGraph&lt;/code&gt; 를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="e518a1279678087b263b8a6d5d4572c2e8b9dd3b" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file based on the commits found in packfiles.</source>
          <target state="translated">packfiles에있는 커밋을 기반으로 커밋 그래프 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="a8a7e9f2485bf10bd9980490fdf55b0594e99b5f" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file containing all commits in the current commit-graph file along with those reachable from &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 에서 도달 할 수있는 커밋과 함께 현재 커밋 그래프 파일의 모든 커밋을 포함하는 커밋 그래프 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c34e4cbacab76dc7a95f5e0f46081aab1f59603" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file containing all reachable commits.</source>
          <target state="translated">도달 가능한 모든 커밋을 포함하는 커밋 그래프 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="e1238f6b25cc5d29bebfcc60e794e1647b6dd786" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file for the packed commits in your local &lt;code&gt;.git&lt;/code&gt; directory.</source>
          <target state="translated">압축 된 커밋에 대한 커밋 그래프 파일을 로컬 &lt;code&gt;.git&lt;/code&gt; 디렉토리에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="7ba716e808cc8cf569e10d2453e1761bc59eae40" translate="yes" xml:space="preserve">
          <source>Write a commit-graph file, extending the current commit-graph file using commits in &lt;code&gt;&amp;lt;pack-index&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;pack-index&amp;gt;&lt;/code&gt; 의 커밋을 사용하여 현재 커밋 그래프 파일을 확장하여 커밋 그래프 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="73c3a355bd823c82bb9b3a929df0d2e920a5e648" translate="yes" xml:space="preserve">
          <source>Write a new MIDX file.</source>
          <target state="translated">새로운 MIDX 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b0d7b6d61dd4b6501290a029b72f9ed15f8cc305" translate="yes" xml:space="preserve">
          <source>Write a reachability bitmap index as part of the repack. This only makes sense when used with &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;-A&lt;/code&gt;, as the bitmaps must be able to refer to all reachable objects. This option overrides the setting of &lt;code&gt;repack.writeBitmaps&lt;/code&gt;. This option has no effect if multiple packfiles are created.</source>
          <target state="translated">재 포장의 일부로 도달 가능성 비트 맵 인덱스를 작성하십시오. 비트 맵이 도달 가능한 모든 객체를 참조 할 수 있어야하므로 &lt;code&gt;-a&lt;/code&gt; 또는 &lt;code&gt;-A&lt;/code&gt; 와 함께 사용하는 경우에만 의미가 있습니다. 이 옵션은 &lt;code&gt;repack.writeBitmaps&lt;/code&gt; 설정을 대체합니다 . 이 옵션은 여러 팩 파일이 작성된 경우 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ec591cf31eda36450bc843a926c4fd529f9a0da" translate="yes" xml:space="preserve">
          <source>Write a set of patterns to the sparse-checkout file, as given as a list of arguments following the &lt;code&gt;set&lt;/code&gt; subcommand. Update the working directory to match the new patterns. Enable the core.sparseCheckout config setting if it is not already enabled.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 부속 명령 다음에 인수 목록으로 제공된대로 패턴 세트를 스파 스 체크 아웃 파일에 씁니다 . 새 패턴과 일치하도록 작업 디렉토리를 업데이트하십시오. core.sparseCheckout 구성 설정이 아직 활성화되지 않은 경우 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="041470620f3506e6e154d55da89dd48b2bba6ec8" translate="yes" xml:space="preserve">
          <source>Write and verify Git commit-graph files</source>
          <target state="translated">Git 커밋 그래프 파일 작성 및 확인</target>
        </trans-unit>
        <trans-unit id="fbde21d9f61e2faa3e597fb0c951212436d2d05f" translate="yes" xml:space="preserve">
          <source>Write and verify multi-pack-indexes</source>
          <target state="translated">멀티 팩 인덱스 작성 및 확인</target>
        </trans-unit>
        <trans-unit id="0874d3d36a3af067f281de19e268427b067828a4" translate="yes" xml:space="preserve">
          <source>Write dangling objects into .git/lost-found/commit/ or .git/lost-found/other/, depending on type. If the object is a blob, the contents are written into the file, rather than its object name.</source>
          <target state="translated">매달린 객체를 유형에 따라 .git / lost-found / commit / 또는 .git / lost-found / other /에 씁니다. 오브젝트가 Blob 인 경우 컨텐츠는 오브젝트 이름이 아닌 파일에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d9accbc71f1215e3614372f554930a021fe71b0a" translate="yes" xml:space="preserve">
          <source>Write into pairs of files (.pack and .idx), using &amp;lt;base-name&amp;gt; to determine the name of the created file. When this option is used, the two files in a pair are written in &amp;lt;base-name&amp;gt;-&amp;lt;SHA-1&amp;gt;.{pack,idx} files. &amp;lt;SHA-1&amp;gt; is a hash based on the pack content and is written to the standard output of the command.</source>
          <target state="translated">&amp;lt;base-name&amp;gt;을 사용하여 파일 쌍 (.pack 및 .idx)에 작성하여 작성된 파일의 이름을 판별하십시오. 이 옵션을 사용하면 한 쌍의 두 파일이 &amp;lt;base-name&amp;gt;-&amp;lt;SHA-1&amp;gt;. {pack, idx} 파일에 기록됩니다. &amp;lt;SHA-1&amp;gt;은 팩 내용을 기반으로하는 해시이며 명령의 표준 출력에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="7fe0c30065baa84a0511c3d3081d91c7d606dfea" translate="yes" xml:space="preserve">
          <source>Write or verify a multi-pack-index (MIDX) file.</source>
          <target state="translated">다중 팩 인덱스 (MIDX) 파일을 쓰거나 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e39d29fa27aa3fd795b76126771a3ffa6c08d16a" translate="yes" xml:space="preserve">
          <source>Write responses to &lt;code&gt;get-mark&lt;/code&gt;, &lt;code&gt;cat-blob&lt;/code&gt;, and &lt;code&gt;ls&lt;/code&gt; queries to the file descriptor &amp;lt;fd&amp;gt; instead of &lt;code&gt;stdout&lt;/code&gt;. Allows &lt;code&gt;progress&lt;/code&gt; output intended for the end-user to be separated from other output.</source>
          <target state="translated">&lt;code&gt;stdout&lt;/code&gt; 대신 &lt;code&gt;get-mark&lt;/code&gt; , &lt;code&gt;cat-blob&lt;/code&gt; 및 &lt;code&gt;ls&lt;/code&gt; 쿼리에 대한 응답을 파일 디스크립터 &amp;lt;fd&amp;gt;에 씁니다 . 허용 &lt;code&gt;progress&lt;/code&gt; 최종 사용자를위한 출력은 다른 출력으로부터 분리된다.</target>
        </trans-unit>
        <trans-unit id="e189db14fd9c8dacb74b437fa25a566d7b39760b" translate="yes" xml:space="preserve">
          <source>Write the archive to &amp;lt;file&amp;gt; instead of stdout.</source>
          <target state="translated">아카이브를 stdout 대신 &amp;lt;file&amp;gt;에 씁니다.</target>
        </trans-unit>
        <trans-unit id="7dc7fd5fc893589e612150dc5a94bc95c63f6644" translate="yes" xml:space="preserve">
          <source>Write the generated pack index into the specified file. Without this option the name of pack index file is constructed from the name of packed archive file by replacing .pack with .idx (and the program fails if the name of packed archive does not end with .pack).</source>
          <target state="translated">생성 된 팩 색인을 지정된 파일에 기록하십시오. 이 옵션이 없으면 팩 색인 파일의 이름은 .pack을 .idx로 바꾸어 압축 된 아카이브 파일의 이름으로 구성됩니다 (그리고 압축 된 아카이브 이름이 .pack으로 끝나지 않으면 프로그램이 실패 함).</target>
        </trans-unit>
        <trans-unit id="898b44ae7851f33ec7de0339d5f319ea640d48c2" translate="yes" xml:space="preserve">
          <source>Write the list of remote refs fetched in the &lt;code&gt;FETCH_HEAD&lt;/code&gt; file directly under &lt;code&gt;$GIT_DIR&lt;/code&gt;. This is the default. Passing &lt;code&gt;--no-write-fetch-head&lt;/code&gt; from the command line tells Git not to write the file. Under &lt;code&gt;--dry-run&lt;/code&gt; option, the file is never written.</source>
          <target state="translated">&lt;code&gt;$GIT_DIR&lt;/code&gt; &lt;code&gt;FETCH_HEAD&lt;/code&gt; 바로 아래 FETCH_HEAD 파일 에서 가져온 원격 참조 목록을 작성하십시오 . 이것이 기본값입니다. 명령 줄에서 &lt;code&gt;--no-write-fetch-head&lt;/code&gt; 를 전달하면 Git이 파일을 쓰지 않도록 지시합니다. 아래 &lt;code&gt;--dry-run&lt;/code&gt; 옵션, 파일이 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ee51e3bc5f984d1828334228be7ce34fc987d1e" translate="yes" xml:space="preserve">
          <source>Write the pack contents (what would have been written to .pack file) out to the standard output.</source>
          <target state="translated">팩 내용 (.pack 파일에 기록 된 내용)을 표준 출력에 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="f8fab17bc8f3e5385c26a96bd869170c9b748651" translate="yes" xml:space="preserve">
          <source>Write the resulting index out in the named on-disk format version. Supported versions are 2, 3 and 4. The current default version is 2 or 3, depending on whether extra features are used, such as &lt;code&gt;git add -N&lt;/code&gt;.</source>
          <target state="translated">결과 색인을 명명 된 온 디스크 형식 버전으로 작성하십시오. 지원되는 버전은 2, 3 및 4입니다. 현재 기본 버전은 &lt;code&gt;git add -N&lt;/code&gt; 과 같은 추가 기능 사용 여부에 따라 2 또는 3 입니다.</target>
        </trans-unit>
        <trans-unit id="efedecbf7e9a176a45aaee6d10ad017d653ffad6" translate="yes" xml:space="preserve">
          <source>Write to standard error. Note that if &lt;code&gt;--detach&lt;/code&gt; is specified, the process disconnects from the real standard error, making this destination effectively equivalent to &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">표준 오류에 씁니다. 참고 경우 것으로 &lt;code&gt;--detach&lt;/code&gt; 가 지정되어, 실제 표준 오류에서 프로세스 연결 해제는, 효과적으로 상당이 대상 만드는 &lt;code&gt;none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04570d31869f8fe0ff9437709cb2be3000b6efb7" translate="yes" xml:space="preserve">
          <source>Write to syslog, using the &lt;code&gt;git-daemon&lt;/code&gt; identifier.</source>
          <target state="translated">&lt;code&gt;git-daemon&lt;/code&gt; 식별자를 사용하여 syslog에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="b06c59a883065a2aa7a048f19cdd388e420a56a1" translate="yes" xml:space="preserve">
          <source>Write whatever message you want, and all the lines that start with &lt;code&gt;#&lt;/code&gt; will be pruned out, and the rest will be used as the commit message for the change. If you decide you don&amp;rsquo;t want to commit anything after all at this point (you can continue to edit things and update the index), you can just leave an empty message. Otherwise &lt;code&gt;git commit&lt;/code&gt; will commit the change for you.</source>
          <target state="translated">원하는 메시지를 쓰면 &lt;code&gt;#&lt;/code&gt; 으로 시작하는 모든 줄이 정리되고 나머지는 변경에 대한 커밋 메시지로 사용됩니다. 이 시점에서 아무 것도 커밋하지 않기로 결정한 경우 (계속 편집하고 인덱스를 업데이트 할 수 있음) 빈 메시지를 남길 수 있습니다. 그렇지 않으면 &lt;code&gt;git commit&lt;/code&gt; 이 변경 사항을 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="61b122f3a92e6ba319a161e3ee36a5061ca2ea4c" translate="yes" xml:space="preserve">
          <source>Writes a tree object that represents a subdirectory &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt;. This can be used to write the tree object for a subproject that is in the named subdirectory.</source>
          <target state="translated">&lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt; 서브 디렉토리를 나타내는 트리 오브젝트를 작성합니다 . 이름이 지정된 서브 디렉토리에있는 서브 프로젝트의 트리 오브젝트를 작성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="157114a94f76dd225b6968a998012309617b01fe" translate="yes" xml:space="preserve">
          <source>Writes the commit-id into the filename under $GIT_DIR/refs/&amp;lt;filename&amp;gt; on the local end after the transfer is complete.</source>
          <target state="translated">전송이 완료된 후 로컬 끝에서 $ GIT_DIR / refs / &amp;lt;filename&amp;gt; 아래의 파일 이름에 commit-id를 씁니다.</target>
        </trans-unit>
        <trans-unit id="e02c77bcdadadb66d0f7703e015b6bcd89a6c5e3" translate="yes" xml:space="preserve">
          <source>X: &quot;unknown&quot; change type (most probably a bug, please report it)</source>
          <target state="translated">X : &quot;알 수없는&quot;변경 유형 (아마도 버그 일 것입니다.)</target>
        </trans-unit>
        <trans-unit id="c4701ab33311f5af4d25d032b9d36f7ee2d229e7" translate="yes" xml:space="preserve">
          <source>You &lt;code&gt;must&lt;/code&gt; therefore ensure that the most recent commit of the branch you want to dcommit to is the &lt;code&gt;first&lt;/code&gt; parent of the merge. Chaos will ensue otherwise, especially if the first parent is an older commit on the same SVN branch.</source>
          <target state="translated">당신은 &lt;code&gt;must&lt;/code&gt; , 따라서 가장 최근의 당신에 dcommit 할 브랜치의 커밋되도록하는 것은입니다 &lt;code&gt;first&lt;/code&gt; 병합의 부모입니다. 특히 첫 번째 부모가 같은 SVN 브랜치에서 이전 커밋 인 경우 혼돈이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="33b03e34a8212275c562b3fd47359312e9fb9f26" translate="yes" xml:space="preserve">
          <source>You also could say &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;clean&lt;/code&gt; above as long as the choice is unique.</source>
          <target state="translated">선택이 독특하다면, &lt;code&gt;c&lt;/code&gt; 라고 말 하거나 &lt;code&gt;clean&lt;/code&gt; 말할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3633df0f340d7a5b00e10a65751fa4510ce91fa7" translate="yes" xml:space="preserve">
          <source>You also could say &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;sta&lt;/code&gt; or &lt;code&gt;status&lt;/code&gt; above as long as the choice is unique.</source>
          <target state="translated">선택 사항이 고유 한 한 &lt;code&gt;s&lt;/code&gt; 또는 &lt;code&gt;sta&lt;/code&gt; 또는 &lt;code&gt;status&lt;/code&gt; 를 위와 같이 말할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80dcbb43282a1e399b57f0acd29e7d516598c299" translate="yes" xml:space="preserve">
          <source>You also need to ensure that each repository is &quot;bare&quot; (without a Git index file) for &lt;code&gt;cvs commit&lt;/code&gt; to work. See &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;code&gt;cvs commit&lt;/code&gt; 이 작동하려면 각 리포지토리가 &quot;깃손&quot;(Git 인덱스 파일 없음)인지 확인해야합니다 . &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="63d1d5a88c78a80cfc3950acb2e452ff58df3b69" translate="yes" xml:space="preserve">
          <source>You also should not rewind branches in a submodule beyond commits that were ever recorded in any superproject.</source>
          <target state="translated">또한 수퍼 프로젝트에서 기록 된 커밋 이외의 하위 모듈에서 분기를 되 감지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="9cb8652293d991a8fc334c9f946fb5900f566815" translate="yes" xml:space="preserve">
          <source>You are happily working on something, and find the changes in these files are in good order. You do not want to see them when you run &lt;code&gt;git diff&lt;/code&gt;, because you plan to work on other files and changes with these files are distracting.</source>
          <target state="translated">행복하게 작업하고 있으며 이러한 파일의 변경 사항이 올바른지 확인하십시오. &lt;code&gt;git diff&lt;/code&gt; 를 실행할 때 다른 파일에 대한 작업을 계획하고 이러한 파일에 대한 변경 사항이 산만 해지기 때문에 이를보고 싶지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="48f9e78ec61620aadfc7c1e71bab372f08845a6f" translate="yes" xml:space="preserve">
          <source>You are in the middle of a refactoring session and your boss comes in and demands that you fix something immediately. You might typically use &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; to store your changes away temporarily, however, your working tree is in such a state of disarray (with new, moved, and removed files, and other bits and pieces strewn around) that you don&amp;rsquo;t want to risk disturbing any of it. Instead, you create a temporary linked working tree to make the emergency fix, remove it when done, and then resume your earlier refactoring session.</source>
          <target state="translated">리팩토링 세션 중에 상사가 와서 즉시 무언가를 고치라고 요구합니다. 일반적으로 &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; 를 사용하여 변경 사항을 일시적으로 저장하지만 작업 트리는 (새 파일, 이동 및 제거 된 파일 및 기타 비트와 조각이 흩어져있는) 혼란 상태에 있습니다. 방해 할 위험이 없습니다. 대신 임시 링크 작업 트리를 작성하여 응급 수정을 수행하고 완료되면 제거하고 이전 리팩토링 세션을 재개하십시오.</target>
        </trans-unit>
        <trans-unit id="bb2df2ca18755cbd46a4ed871293669f22530506" translate="yes" xml:space="preserve">
          <source>You are now ready to commit. You can see what is about to be committed using &lt;code&gt;git diff&lt;/code&gt; with the --cached option:</source>
          <target state="translated">이제 커밋 할 준비가되었습니다. --cached 옵션과 함께 &lt;code&gt;git diff&lt;/code&gt; 를 사용하여 커밋하려는 내용을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="074e56336e1be0630703b280d6a3b60899f28a4c" translate="yes" xml:space="preserve">
          <source>You can adjust how pages generated by gitweb look using the variables described below. You can change the site name, add common headers and footers for all pages, and add a description of this gitweb installation on its main page (which is the projects list page), etc.</source>
          <target state="translated">아래 설명 된 변수를 사용하여 gitweb에 의해 생성 된 페이지의 모양을 조정할 수 있습니다. 사이트 이름을 변경하고 모든 페이지에 공통 머리글과 바닥 글을 추가하고 기본 페이지 (프로젝트 목록 페이지)에이 gitweb 설치에 대한 설명을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5130cbe18f25cdc12700266fadc1f554b9c37ce" translate="yes" xml:space="preserve">
          <source>You can also ask git log to show patches:</source>
          <target state="translated">git log에게 패치를 보여달라고 요청할 수도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f5378640dc8884e7695fa8d24ebc61aad94be600" translate="yes" xml:space="preserve">
          <source>You can also check out &lt;code&gt;origin/todo&lt;/code&gt; directly to examine it or write a one-off patch. See &lt;a href=&quot;#detached-head&quot;&gt;detached head&lt;/a&gt;.</source>
          <target state="translated">당신은 또한 확인할 수 있습니다 &lt;code&gt;origin/todo&lt;/code&gt; 을 검사하거나 일회성 패치를 작성하는 직접. &lt;a href=&quot;#detached-head&quot;&gt;분리 된 헤드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1dba829f7b6e6b2354184e851e59ecadab491f50" translate="yes" xml:space="preserve">
          <source>You can also edit a patch series with an interactive rebase. This is the same as &lt;a href=&quot;#reordering-patch-series&quot;&gt;reordering a patch series using &lt;code&gt;format-patch&lt;/code&gt;&lt;/a&gt;, so use whichever interface you like best.</source>
          <target state="translated">대화식 rebase를 사용하여 패치 시리즈를 편집 할 수도 있습니다. &lt;a href=&quot;#reordering-patch-series&quot;&gt; &lt;code&gt;format-patch&lt;/code&gt; 를&lt;/a&gt; 사용하여 패치 시리즈를 재정렬하는 것과 동일 하므로 가장 선호하는 인터페이스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a56f9e1e04034dbb228cdfc1e0cb38c07a8bcbf1" translate="yes" xml:space="preserve">
          <source>You can also fetch branches from other repositories; so</source>
          <target state="translated">다른 리포지토리에서 분기를 가져올 수도 있습니다. 그래서</target>
        </trans-unit>
        <trans-unit id="bb4e25e283a061b1bebe5a9dd36fbbd03f0e1b4b" translate="yes" xml:space="preserve">
          <source>You can also give &lt;code&gt;git log&lt;/code&gt; a &quot;range&quot; of commits where the first is not necessarily an ancestor of the second; for example, if the tips of the branches &quot;stable&quot; and &quot;master&quot; diverged from a common commit some time ago, then</source>
          <target state="translated">또한 &lt;code&gt;git log&lt;/code&gt; 에 커밋의 &quot;범위&quot;를 줄 수 있습니다 . 첫 번째는 반드시 두 번째의 조상이 아닙니다. 예를 들어 분기 &quot;안정한&quot;및 &quot;마스터&quot;의 팁이 얼마 전에 공통 커밋에서 벗어난 경우</target>
        </trans-unit>
        <trans-unit id="c219057e4d44e965fab9fe1f77892cd8f09c5753" translate="yes" xml:space="preserve">
          <source>You can also give commits names of your own; after running</source>
          <target state="translated">또한 커밋 이름을 지정할 수도 있습니다. 실행 후</target>
        </trans-unit>
        <trans-unit id="cecebc054603ae5ff87afcd3e6caec5420b5c866" translate="yes" xml:space="preserve">
          <source>You can also override locations of gitweb configuration files during runtime by setting the following environment variables: &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt;, &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; and &lt;code&gt;GITWEB_CONFIG&lt;/code&gt; to a non-empty value.</source>
          <target state="translated">&lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt; , &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; 및 &lt;code&gt;GITWEB_CONFIG&lt;/code&gt; 환경 변수를 비어 있지 않은 값 으로 설정하여 런타임 동안 gitweb 구성 파일의 위치를 ​​무시할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c335f539c67224e67ef9ba8bcb55a78f32c2ba64" translate="yes" xml:space="preserve">
          <source>You can also revert an earlier change, for example, the next-to-last:</source>
          <target state="translated">또한 다음 변경 사항과 같은 이전 변경 사항을 되돌릴 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6f0f4e5da7f74f3d7e6aefa5597ca88126ce358" translate="yes" xml:space="preserve">
          <source>You can also run &lt;code&gt;git daemon&lt;/code&gt; as an inetd service; see the &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt; man page for details. (See especially the examples section.)</source>
          <target state="translated">&lt;code&gt;git daemon&lt;/code&gt; 을 inetd 서비스로 실행할 수도 있습니다 . 자세한 내용은 &lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]&lt;/a&gt; 매뉴얼 페이지를 참조하십시오. (특히 예제 섹션을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="f0a51538febea0717277859dfbb5418b689055cc" translate="yes" xml:space="preserve">
          <source>You can also see what references it offers:</source>
          <target state="translated">어떤 참조가 제공되는지 확인할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f06fdd5b89ee465ae510128ba09f10dd8adf5eac" translate="yes" xml:space="preserve">
          <source>You can also skip a range of commits, instead of just one commit, using range notation. For example:</source>
          <target state="translated">범위 표기법을 사용하여 단 하나의 커밋 대신 커밋 범위를 건너 뛸 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="54e517ee1d2086de2439776d35ac41cdff2f30f7" translate="yes" xml:space="preserve">
          <source>You can also track branches from repositories other than the one you cloned from, using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]을&lt;/a&gt; 사용하여 복제 한 저장소 이외의 저장소에서 분기를 추적 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28b63a93050077dfe73e5bbbcd2b4df244cc4f26" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt; to create commits, view changes in the index and the working tree files, and individually select diff hunks for inclusion in the index (by right-clicking on the diff hunk and choosing &quot;Stage Hunk For Commit&quot;).</source>
          <target state="translated">당신은 또한 사용할 수 있습니다 &lt;a href=&quot;git-gui&quot;&gt;자식 - GUI [1]&lt;/a&gt; 은 diff 화물선과 &quot;무대 덩어리에 대한 선택을 마우스 오른쪽 버튼으로 클릭 (인덱스에 포함 DIFF 심술쟁이을 선택 개별적으로 커밋,보기 변경 인덱스와 작업 트리 파일을 생성하고, 범하다&quot;).</target>
        </trans-unit>
        <trans-unit id="2d89b19204028ed2768f0a7d6951c7af3234e547" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; to generate patches for A, B and C, and the identifiers for P, X, Y, Z are appended at the end of the first message.</source>
          <target state="translated">또한 사용할 수있는 &lt;code&gt;git format-patch --base=P -3 C&lt;/code&gt; A, B 및 C에 대한 패치를 생성하고, P, X, Y, Z에 대한 식별자는 제 메시지의 끝에 추가된다.</target>
        </trans-unit>
        <trans-unit id="2c144befb1f45c546071ce64e48b303dc0e810a7" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;git show&lt;/code&gt; to see any such file:</source>
          <target state="translated">&lt;code&gt;git show&lt;/code&gt; 를 사용 하여 그러한 파일을 볼 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49c3eff4b4dfbb20ea17f1bea994d4ab08b8a178" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;git_commit_non_empty_tree &quot;$@&quot;&lt;/code&gt; instead of &lt;code&gt;git commit-tree &quot;$@&quot;&lt;/code&gt; if you don&amp;rsquo;t wish to keep commits with a single parent and that makes no change to the tree.</source>
          <target state="translated">단일 부모와 커밋을 유지하지 않고 트리를 변경하지 않으려면 &lt;code&gt;git commit-tree &quot;$@&quot;&lt;/code&gt; &lt;code&gt;git_commit_non_empty_tree &quot;$@&quot;&lt;/code&gt; 대신 git_commit_non_empty_tree &quot;$ @&quot; 를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="015df615c0d1b650e7dd0d33e1d03af134ab36e3" translate="yes" xml:space="preserve">
          <source>You can always just jump back to your original &lt;code&gt;master&lt;/code&gt; branch by doing</source>
          <target state="translated">당신은 항상 원래의 &lt;code&gt;master&lt;/code&gt; 브랜치로 돌아갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3173f9b04378ce969d4435b57687de248be9e7d" translate="yes" xml:space="preserve">
          <source>You can always view an old version of a file by just checking out the correct revision first. But sometimes it is more convenient to be able to view an old version of a single file without checking anything out; this command does that:</source>
          <target state="translated">올바른 수정본을 먼저 확인하여 항상 파일의 이전 버전을 볼 수 있습니다. 그러나 때로는 아무것도 확인하지 않고 단일 파일의 이전 버전을 볼 수있는 것이 더 편리합니다. 이 명령은 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ac57e48df46d91546d0b6c2ab36f112078813032" translate="yes" xml:space="preserve">
          <source>You can at any time create a new branch by just picking an arbitrary point in the project history, and just writing the SHA-1 name of that object into a file under &lt;code&gt;.git/refs/heads/&lt;/code&gt;. You can use any filename you want (and indeed, subdirectories), but the convention is that the &quot;normal&quot; branch is called &lt;code&gt;master&lt;/code&gt;. That&amp;rsquo;s just a convention, though, and nothing enforces it.</source>
          <target state="translated">프로젝트 히스토리에서 임의의 지점을 선택하고 해당 오브젝트의 SHA-1 이름을 &lt;code&gt;.git/refs/heads/&lt;/code&gt; 아래의 파일에 작성하여 언제든지 새 브랜치를 작성할 수 있습니다 . 원하는 파일 이름 (및 실제로 서브 디렉토리)을 사용할 수 있지만 &quot;일반&quot;브랜치는 &lt;code&gt;master&lt;/code&gt; 라고 합니다. 그것은 단지 관습 일 뿐이며, 그것을 강요하는 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="28fdfbc805da6922683f26cc12f785c6a111b6ce" translate="yes" xml:space="preserve">
          <source>You can choose to provide the name of a file in &lt;code&gt;$GIT_DIR/branches&lt;/code&gt;. The URL in this file will be used to access the repository. This file should have the following format:</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/branches&lt;/code&gt; 파일 이름을 제공하도록 선택할 수 있습니다 . 이 파일의 URL은 저장소에 액세스하는 데 사용됩니다. 이 파일은 다음 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="184c3e9bbc8e0af36908329654dfda91364d6a99" translate="yes" xml:space="preserve">
          <source>You can choose to provide the name of a file in &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt;. The URL in this file will be used to access the repository. The refspec in this file will be used as default when you do not provide a refspec on the command line. This file should have the following format:</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; 파일 이름을 제공하도록 선택할 수 있습니다 . 이 파일의 URL은 저장소에 액세스하는 데 사용됩니다. 이 파일의 참조 스펙은 명령 행에 참조 스펙을 제공하지 않을 때 기본값으로 사용됩니다. 이 파일은 다음 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a92f2a4a63c6c2d142357d1e5947af0b6de272f3" translate="yes" xml:space="preserve">
          <source>You can choose to provide the name of a remote which you had previously configured using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;, &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; or even by a manual edit to the &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file. The URL of this remote will be used to access the repository. The refspec of this remote will be used by default when you do not provide a refspec on the command line. The entry in the config file would appear like this:</source>
          <target state="translated">&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; , &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 또는 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 파일 을 수동으로 편집 하여 이전에 구성한 리모컨의 이름을 제공하도록 선택할 수 있습니다 . 이 리모트의 URL은 저장소에 액세스하는 데 사용됩니다. 이 리모트의 참조 스펙은 명령 행에 참조 스펙을 제공하지 않을 때 기본적으로 사용됩니다. 구성 파일의 항목은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d377d9322805f2d9d1e87d74e556de9916d572ec" translate="yes" xml:space="preserve">
          <source>You can choose whether you want to trust the index file entirely (using the &lt;code&gt;--cached&lt;/code&gt; flag) or ask the diff logic to show any files that don&amp;rsquo;t match the stat state as being &quot;tentatively changed&quot;. Both of these operations are very useful indeed.</source>
          <target state="translated">&lt;code&gt;--cached&lt;/code&gt; 플래그를 사용하여 인덱스 파일을 완전히 신뢰할지 또는 통계 상태와 일치하지 않는 파일을 &quot;잠정적으로 변경됨&quot;으로 표시하도록 diff 논리에 요청 할지 여부를 선택할 수 있습니다 . 이 두 작업은 실제로 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7c0716128ee4fbd827cb316e0652131c44810ab6" translate="yes" xml:space="preserve">
          <source>You can configure gitweb to only list and allow viewing of the explicitly exported repositories, via &lt;code&gt;$export_ok&lt;/code&gt; variable in gitweb config file; see &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt; manpage. If it evaluates to true, gitweb shows repositories only if this file named by &lt;code&gt;$export_ok&lt;/code&gt; exists in its object database (if directory has the magic file named &lt;code&gt;$export_ok&lt;/code&gt;).</source>
          <target state="translated">gitweb 설정 파일의 &lt;code&gt;$export_ok&lt;/code&gt; 변수를 통해 명시 적으로 내 보낸 리포지토리 만 나열하고 볼 수 있도록 gitweb을 구성 할 수 있습니다 . &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt; 맨 페이지를 참조하십시오 . true로 평가되면 gitweb은 &lt;code&gt;$export_ok&lt;/code&gt; 이름 지정된이 파일이 오브젝트 데이터베이스에 존재하는 경우에만 디렉토리를 표시합니다 (디렉토리에 &lt;code&gt;$export_ok&lt;/code&gt; 라는 매직 파일이있는 경우 ).</target>
        </trans-unit>
        <trans-unit id="03a65df391294815ab470e62357c9e62de1fcfb2" translate="yes" xml:space="preserve">
          <source>You can configure individual repositories shown in gitweb by creating file in the &lt;code&gt;GIT_DIR&lt;/code&gt; of Git repository, or by setting some repo configuration variable (in &lt;code&gt;GIT_DIR/config&lt;/code&gt;, see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">Git 리포지토리 의 &lt;code&gt;GIT_DIR&lt;/code&gt; 에 파일을 만들 거나 일부 repo 구성 변수를 설정 하여 gitweb에 표시되는 개별 리포지토리를 구성 할 수 있습니다 ( &lt;code&gt;GIT_DIR/config&lt;/code&gt; 에서 &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="45321feeff0945f0a2ba053e8ab969c82cc417c8" translate="yes" xml:space="preserve">
          <source>You can configure the database backend with the following configuration variables:</source>
          <target state="translated">다음 구성 변수를 사용하여 데이터베이스 백엔드를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d268b7f609741cf4701b8230b6d95314deb17a7a" translate="yes" xml:space="preserve">
          <source>You can create a new commit that undoes whatever was done by the old commit. This is the correct thing if your mistake has already been made public.</source>
          <target state="translated">이전 커밋이 수행 한 모든 작업을 취소하는 새 커밋을 만들 수 있습니다. 실수가 이미 공개 된 경우 이것이 올바른 것입니다.</target>
        </trans-unit>
        <trans-unit id="d8a9d4babf707e6fca47541eba4fa0b4e8c8edd2" translate="yes" xml:space="preserve">
          <source>You can customize the rules that &lt;code&gt;git diff --word-diff&lt;/code&gt; uses to split words in a line, by specifying an appropriate regular expression in the &quot;diff.*.wordRegex&quot; configuration variable. For example, in TeX a backslash followed by a sequence of letters forms a command, but several such commands can be run together without intervening whitespace. To separate them, use a regular expression in your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">&quot;diff. *. wordRegex&quot;구성 변수에 적절한 정규식을 지정하여 &lt;code&gt;git diff --word-diff&lt;/code&gt; 가 단어를 한 줄로 나누는 데 사용 하는 규칙을 사용자 정의 할 수 있습니다 . 예를 들어, TeX에서 백 슬래시와 일련의 문자는 명령을 구성하지만 공백을 개입시키지 않고 이러한 명령을 함께 실행할 수 있습니다. 이를 분리하려면 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 파일 (또는 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 파일)에서 다음과 같이 정규식을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="38bcfec4c9f80337cd439b12b7afb0a63bb0fcb7" translate="yes" xml:space="preserve">
          <source>You can declare that a filter turns a content that by itself is unusable into a usable content by setting the filter.&amp;lt;driver&amp;gt;.required configuration variable to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">filter. &amp;lt;driver&amp;gt; .required 구성 변수를 &lt;code&gt;true&lt;/code&gt; 로 설정하여 필터가 자체적으로 사용할 수없는 컨텐츠를 사용 가능한 컨텐츠로 변환 함을 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7aeeb9d27bdf323aad4937a225d2c2d1d7d6f4b" translate="yes" xml:space="preserve">
          <source>You can easily create such a branch with Git using interactive rebase.</source>
          <target state="translated">대화식 리베이스를 사용하여 Git으로 이러한 브랜치를 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f7816df4cc860a9cfdb50146ff125e3acb46178" translate="yes" xml:space="preserve">
          <source>You can enforce finer grained permissions using update hooks. See &lt;a href=&quot;https://git-scm.com/docs/howto/update-hook-example&quot;&gt;Controlling access to branches using update hooks&lt;/a&gt;.</source>
          <target state="translated">업데이트 후크를 사용하여보다 세분화 된 권한을 적용 할 수 있습니다. &lt;a href=&quot;https://git-scm.com/docs/howto/update-hook-example&quot;&gt;업데이트 후크를 사용하여 분기에 대한 액세스 제어를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dca6628a0b53b9b002cd44ea35104ed275c53c21" translate="yes" xml:space="preserve">
          <source>You can examine one of those dangling commits with, for example,</source>
          <target state="translated">예를 들어 다음과 같이 매달린 커밋 중 하나를 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4807484ba96d5012055b128c8602211fd418a27a" translate="yes" xml:space="preserve">
          <source>You can examine such index state with &lt;code&gt;git ls-files --unmerged&lt;/code&gt; command. An example:</source>
          <target state="translated">&lt;code&gt;git ls-files --unmerged&lt;/code&gt; 명령을 사용 하여 이러한 인덱스 상태를 검사 할 수 있습니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="b5f066a300ab7fb920ca504e5ef4559d46dabfb5" translate="yes" xml:space="preserve">
          <source>You can examine the data represented in the object database and the index with various helper tools. For every object, you can use &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file[1]&lt;/a&gt; to examine details about the object:</source>
          <target state="translated">다양한 도우미 도구를 사용하여 개체 데이터베이스에 표시된 데이터와 인덱스를 검사 할 수 있습니다. 모든 객체에 대해 &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file [1]&lt;/a&gt; 을 사용하여 객체에 대한 세부 정보를 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd093df539bb25e8d4c6b75d7c53e29317d7deb5" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to the tool by setting the configuration variable &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to kdiff3 by setting &lt;code&gt;difftool.kdiff3.path&lt;/code&gt;. Otherwise, &lt;code&gt;git difftool&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="translated">구성 변수 &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.path&lt;/code&gt; 를 설정하여 도구의 전체 경로를 명시 적으로 제공 할 수 있습니다 . 예를 들어 &lt;code&gt;difftool.kdiff3.path&lt;/code&gt; 를 설정하여 kdiff3의 절대 경로를 구성 할 수 있습니다 . 그렇지 않으면 &lt;code&gt;git difftool&lt;/code&gt; 은 도구가 PATH에서 사용 가능하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="146074b490cdd862abeb41d866c18f9aaa225cf8" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to the tool by setting the configuration variable &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to kdiff3 by setting &lt;code&gt;mergetool.kdiff3.path&lt;/code&gt;. Otherwise, &lt;code&gt;git mergetool&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="translated">구성 변수 &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.path&lt;/code&gt; 를 설정하여 도구의 전체 경로를 명시 적으로 제공 할 수 있습니다 . 예를 들어 &lt;code&gt;mergetool.kdiff3.path&lt;/code&gt; 를 설정하여 kdiff3의 절대 경로를 구성 할 수 있습니다 . 그렇지 않으면 &lt;code&gt;git mergetool&lt;/code&gt; 은 도구가 PATH에서 사용 가능하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="1d73514fe413b4199a0b5fc2096f965b3e1620ee" translate="yes" xml:space="preserve">
          <source>You can explicitly provide a full path to your preferred man viewer by setting the configuration variable &lt;code&gt;man.&amp;lt;tool&amp;gt;.path&lt;/code&gt;. For example, you can configure the absolute path to konqueror by setting &lt;code&gt;man.konqueror.path&lt;/code&gt;. Otherwise, &lt;code&gt;git help&lt;/code&gt; assumes the tool is available in PATH.</source>
          <target state="translated">구성 변수 &lt;code&gt;man.&amp;lt;tool&amp;gt;.path&lt;/code&gt; 를 설정하여 원하는 man 뷰어에 대한 전체 경로를 명시 적으로 제공 할 수 있습니다 . 예를 들어, &lt;code&gt;man.konqueror.path&lt;/code&gt; 를 설정하여 konqueror의 절대 경로를 구성 할 수 있습니다 . 그렇지 않으면 &lt;code&gt;git help&lt;/code&gt; 는 도구를 PATH에서 사용할 수 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="11d166169fafafa437c100a2b764012cf5981ced" translate="yes" xml:space="preserve">
          <source>You can focus your efforts to check at a few points (for example rc and beta releases) that all the T test cases pass for all the N configurations. And when some tests don&amp;rsquo;t pass you can use &quot;git bisect&quot; (or better &quot;git bisect run&quot;). So you should perform roughly:</source>
          <target state="translated">모든 T 테스트 사례가 모든 N 구성에 대해 통과하는 몇 가지 지점 (예 : rc 및 베타 릴리스)에서 확인하려는 노력에 집중할 수 있습니다. 그리고 일부 테스트가 통과되지 않으면 &quot;git bisect&quot;(또는 더 나은 &quot;git bisect run&quot;)를 사용할 수 있습니다. 따라서 대략적으로 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="59d0d873078b4f91b40c2ee1e2770f185d430915" translate="yes" xml:space="preserve">
          <source>You can further cut down the number of trials, if you know what part of the tree is involved in the problem you are tracking down, by specifying path parameters when issuing the &lt;code&gt;bisect start&lt;/code&gt; command:</source>
          <target state="translated">&lt;code&gt;bisect start&lt;/code&gt; 명령을 실행할 때 경로 매개 변수를 지정하여 추적 할 문제에 관련된 트리 부분을 알고있는 경우 시행 횟수를 추가로 줄일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5857d2949fb11d516cd50de71765499d023b3f6" translate="yes" xml:space="preserve">
          <source>You can generate diffs between any two versions using &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]을&lt;/a&gt; 사용하여 두 버전간에 차이를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98e4a2c67e91124741c5ae666b50315da705ecdc" translate="yes" xml:space="preserve">
          <source>You can generate the projects list index file using the project_index action (the &lt;code&gt;TXT&lt;/code&gt; link on projects list page) directly from gitweb; see also &quot;Generating projects list using gitweb&quot; section below.</source>
          <target state="translated">gitweb에서 직접 project_index 조치 ( 프로젝트 목록 페이지 의 &lt;code&gt;TXT&lt;/code&gt; 링크)를 사용하여 프로젝트 목록 색인 파일을 생성 할 수 있습니다 . 아래의 &quot;gitweb을 사용하여 프로젝트 목록 생성&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5b042e446e3f9ebd4b31fc02aac55f5c329ead7e" translate="yes" xml:space="preserve">
          <source>You can get a list of all available encodings on your platform with the following command:</source>
          <target state="translated">다음 명령을 사용하여 플랫폼에서 사용 가능한 모든 인코딩 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d921181a0df868b1892f0a3e234a9c29e516883" translate="yes" xml:space="preserve">
          <source>You can get just the old (respectively new) term with &lt;code&gt;git bisect terms
--term-old&lt;/code&gt; or &lt;code&gt;git bisect terms --term-good&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git bisect terms --term-old&lt;/code&gt; 또는 &lt;code&gt;git bisect terms --term-good&lt;/code&gt; 으로 오래된 (각각 새로운) 용어를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41b9643f0720517e2c1772471e0c09d5c46b9644" translate="yes" xml:space="preserve">
          <source>You can give the &lt;code&gt;-m&lt;/code&gt; flag to the command, which would try a three-way merge:</source>
          <target state="translated">명령에 &lt;code&gt;-m&lt;/code&gt; 플래그를 부여하면 3 방향 병합을 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36617ae8104572554e1e13e9574934aea0623eb3" translate="yes" xml:space="preserve">
          <source>You can go back and modify the old commit. You should never do this if you have already made the history public; Git does not normally expect the &quot;history&quot; of a project to change, and cannot correctly perform repeated merges from a branch that has had its history changed.</source>
          <target state="translated">돌아가서 이전 커밋을 수정할 수 있습니다. 이미 역사를 공개 한 경우에는이 작업을 수행해서는 안됩니다. Git은 일반적으로 프로젝트의 &quot;히스토리&quot;가 변경 될 것으로 예상하지 않으며 히스토리가 변경된 지점에서 반복 병합을 올바르게 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="427cec7db1c8d9c41ec669de64df63aacc49a26f" translate="yes" xml:space="preserve">
          <source>You can grow a new branch from any commit. For example, switch to &quot;HEAD~3&quot; and create branch &quot;fixup&quot;:</source>
          <target state="translated">모든 커밋에서 새 브랜치를 성장시킬 수 있습니다. 예를 들어 &quot;HEAD ~ 3&quot;으로 전환하고 &quot;fixup&quot;분기를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="8abddb96169bb94a7080d5c82ed5cac7b229954a" translate="yes" xml:space="preserve">
          <source>You can have a mixture of files show up as &quot;has been updated&quot; and &quot;is still dirty in the working directory&quot; together. You can always tell which file is in which state, since the &quot;has been updated&quot; ones show a valid sha1, and the &quot;not in sync with the index&quot; ones will always have the special all-zero sha1.</source>
          <target state="translated">&quot;업데이트되었습니다&quot;로 표시되고 &quot;작업 디렉토리에서 여전히 더럽습니다&quot;라는 파일 조합을 함께 표시 할 수 있습니다. &quot;갱신 된&quot;파일에는 유효한 sha1이 표시되고 &quot;인덱스와 동기화되지 않은&quot;파일에는 항상 모든 0의 특수 sha1이 있으므로 어떤 파일이 어떤 상태인지 항상 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae3f7bca446e950bd716349b25ee5d05aaee6a26" translate="yes" xml:space="preserve">
          <source>You can include a config file from another by setting the special &lt;code&gt;include.path&lt;/code&gt; (or &lt;code&gt;includeIf.*.path&lt;/code&gt;) variable to the name of the file to be included. The variable takes a pathname as its value, and is subject to tilde expansion. These variables can be given multiple times.</source>
          <target state="translated">특수 &lt;code&gt;include.path&lt;/code&gt; (또는 &lt;code&gt;includeIf.*.path&lt;/code&gt; ) 변수를 포함 할 파일 이름으로 설정하여 다른 구성 파일을 구성 파일에 포함시킬 수 있습니다. 변수는 경로 이름을 값으로 사용하며 물결표 확장이 적용됩니다. 이 변수들은 여러 번 주어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5145f6f36a43ec5e98537ca833d15e8282538fcf" translate="yes" xml:space="preserve">
          <source>You can include a config file from another conditionally by setting a &lt;code&gt;includeIf.&amp;lt;condition&amp;gt;.path&lt;/code&gt; variable to the name of the file to be included.</source>
          <target state="translated">&lt;code&gt;includeIf.&amp;lt;condition&amp;gt;.path&lt;/code&gt; 변수를 포함 할 파일 이름으로 설정하여 다른 조건부에서 구성 파일을 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="509dfc228243cbfccb732c55df31d8f926c42b85" translate="yes" xml:space="preserve">
          <source>You can include other configuration file using read_config_file() subroutine. For example, one might want to put gitweb configuration related to access control for viewing repositories via Gitolite (one of Git repository management tools) in a separate file, e.g. in &lt;code&gt;/etc/gitweb-gitolite.conf&lt;/code&gt;. To include it, put</source>
          <target state="translated">read_config_file () 서브 루틴을 사용하여 다른 구성 파일을 포함 할 수 있습니다. 예를 들어, Gitolite (Git 리포지토리 관리 도구 중 하나)를 통해 리포지토리를보기위한 액세스 제어와 관련된 gitweb 구성을 별도의 파일 (예 : &lt;code&gt;/etc/gitweb-gitolite.conf&lt;/code&gt; ) 에 넣을 수 있습니다. 포함하려면</target>
        </trans-unit>
        <trans-unit id="645452c6d997e8f480a9efb060142f580408b9f7" translate="yes" xml:space="preserve">
          <source>You can make a different change on the master branch:</source>
          <target state="translated">마스터 브랜치에서 다른 변경을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d56811ee77d2943d64ee7741c452578a4d84979" translate="yes" xml:space="preserve">
          <source>You can make interesting things happen to a repository every time you push into it, by setting up &lt;code&gt;hooks&lt;/code&gt; there. See documentation for &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;hooks&lt;/code&gt; 를 설정하여 저장소에 푸시 할 때마다 흥미로운 일을 저장소에 만들 수 있습니다 . &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="31caee42f233cd83de2778af5287eb406c23a1ef" translate="yes" xml:space="preserve">
          <source>You can make sure &lt;code&gt;git show-branch&lt;/code&gt; matches the state before those two &lt;code&gt;git merge&lt;/code&gt; you just did. Then, instead of running two &lt;code&gt;git merge&lt;/code&gt; commands in a row, you would merge these two branch heads (this is known as &lt;code&gt;making an Octopus&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;git show-branch&lt;/code&gt; 가 방금 한 두 &lt;code&gt;git merge&lt;/code&gt; 전에 상태와 일치 하는지 확인할 수 있습니다 . 그런 다음 두 개의 &lt;code&gt;git merge&lt;/code&gt; 명령을 연속 으로 실행하는 대신 이 두 가지 분기 헤드를 병합합니다 (이것은 &lt;code&gt;making an Octopus&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9f748b043bbe97de82ec4f7b6a5308c58b703d36" translate="yes" xml:space="preserve">
          <source>You can make the server use the end-of-line conversion attributes to set the &lt;code&gt;-k&lt;/code&gt; modes for files by setting the &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; config variable. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for more information about end-of-line conversion.</source>
          <target state="translated">&lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; 구성 변수를 설정하여 서버가 줄 끝 변환 속성을 사용하여 파일에 대한 &lt;code&gt;-k&lt;/code&gt; 모드 를 설정할 수 있습니다. 참조 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes을 [5]&lt;/a&gt; 끝 (end-of-line) 변환에 대한 자세한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="015443f769a79760c1933372fa244563a6a25aba" translate="yes" xml:space="preserve">
          <source>You can omit having to type return here, by setting the configuration variable &lt;code&gt;interactive.singleKey&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">구성 변수 &lt;code&gt;interactive.singleKey&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하여 여기에 return을 입력하지 않아도됩니다 .</target>
        </trans-unit>
        <trans-unit id="358c29af25eb707e9507c2c41ba2c41fddac22f4" translate="yes" xml:space="preserve">
          <source>You can override these rules either by command-line options or by environment variables. The &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--system&lt;/code&gt; and &lt;code&gt;--worktree&lt;/code&gt; options will limit the file used to the global, system-wide or per-worktree file respectively. The &lt;code&gt;GIT_CONFIG&lt;/code&gt; environment variable has a similar effect, but you can specify any filename you want.</source>
          <target state="translated">명령 행 옵션 또는 환경 변수로 이러한 규칙을 대체 할 수 있습니다. &lt;code&gt;--global&lt;/code&gt; 는 , &lt;code&gt;--system&lt;/code&gt; 및 &lt;code&gt;--worktree&lt;/code&gt; 옵션은 글로벌, 전체 시스템 또는 당 worktree 파일을 각각 사용되는 파일을 제한합니다. &lt;code&gt;GIT_CONFIG&lt;/code&gt; 의 환경 변수도 비슷한 효과를 가지고 있지만, 당신은 당신이 원하는 파일 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9256a8bfff0f4e1e2098927e9ff118ae66b3eab" translate="yes" xml:space="preserve">
          <source>You can perform &quot;git pull&quot;, resolve potential conflicts, and &quot;git push&quot; the result. A &quot;git pull&quot; will create a merge commit C between commits A and B.</source>
          <target state="translated">&quot;git pull&quot;을 수행하고 잠재적 충돌을 해결하고 결과를 &quot;git push&quot;할 수 있습니다. &quot;git pull&quot;은 커밋 A와 B 사이에 병합 커밋 C를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="189a9ed33e189223869b33620d09d0f720bf3fe1" translate="yes" xml:space="preserve">
          <source>You can provide options via the credential.helper configuration variable (this example drops the cache time to 5 minutes):</source>
          <target state="translated">credential.helper 구성 변수를 통해 옵션을 제공 할 수 있습니다 (이 예에서는 캐시 시간을 5 분으로 줄입니다).</target>
        </trans-unit>
        <trans-unit id="82656460f1d1171626ca7a2547e75d0458741fd5" translate="yes" xml:space="preserve">
          <source>You can query/set/replace/unset options with this command. The name is actually the section and the key separated by a dot, and the value will be escaped.</source>
          <target state="translated">이 명령으로 옵션을 쿼리 / 설정 / 바꾸기 / 설정 해제 할 수 있습니다. 이름은 실제로 섹션과 키로 점으로 구분되며 값은 이스케이프됩니다.</target>
        </trans-unit>
        <trans-unit id="10e463ee2669848fa9bb9fc90b4474d38bbf73be" translate="yes" xml:space="preserve">
          <source>You can rejoin two diverging branches of development using &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;:</source>
          <target state="translated">다음을 사용하여 개발의 두 분기 지점에 다시 가입 할 수 &lt;a href=&quot;git-merge&quot;&gt;자식 병합 [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="3e4277417393477fbeb632e41395d74e0a0e4169" translate="yes" xml:space="preserve">
          <source>You can repack this private repository whenever you feel like.</source>
          <target state="translated">필요할 때마다이 개인 저장소를 다시 포장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3425cb44f3c2a0393cb24a6806cf1648e47fe578" translate="yes" xml:space="preserve">
          <source>You can repeat steps 2-4 multiple times to break the original code into any number of commits.</source>
          <target state="translated">2-4 단계를 여러 번 반복하여 원래 코드를 여러 커밋으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f016259f2ce9ae7193e573b7fa2135698ca39f54" translate="yes" xml:space="preserve">
          <source>You can rewrite the commit log messages using &lt;code&gt;--msg-filter&lt;/code&gt;. For example, &lt;code&gt;git svn-id&lt;/code&gt; strings in a repository created by &lt;code&gt;git svn&lt;/code&gt; can be removed this way:</source>
          <target state="translated">&lt;code&gt;--msg-filter&lt;/code&gt; 를 사용하여 커밋 로그 메시지를 다시 작성할 수 있습니다 . 예를 들어, &lt;code&gt;git svn-id&lt;/code&gt; 의해 생성 된 스트링 저장소 &lt;code&gt;git svn&lt;/code&gt; 이 방법으로 제거 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="6928e91b0b4a87a6f0188b338ec935fa803e932d" translate="yes" xml:space="preserve">
          <source>You can run &lt;code&gt;git-bundle verify&lt;/code&gt; to see if you can extract from a bundle that was created with a basis:</source>
          <target state="translated">&lt;code&gt;git-bundle verify&lt;/code&gt; 를 실행 하여 기본으로 작성된 번들에서 추출 할 수 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28f57e6715a38d45260ef8d226913fe9d5e46420" translate="yes" xml:space="preserve">
          <source>You can run &lt;code&gt;gitk --all&lt;/code&gt; again to see how the commit ancestry looks like, or run &lt;code&gt;show-branch&lt;/code&gt;, which tells you this.</source>
          <target state="translated">&lt;code&gt;gitk --all&lt;/code&gt; 을 다시 실행 하여 커밋 조상이 어떻게 보이는지 보거나 &lt;code&gt;show-branch&lt;/code&gt; 를 실행하여 이를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee22a2dcf21325c45ae74e5933824496ebc88dee" translate="yes" xml:space="preserve">
          <source>You can save space and make Git faster by moving these loose objects in to a &quot;pack file&quot;, which stores a group of objects in an efficient compressed format; the details of how pack files are formatted can be found in &lt;a href=&quot;pack-format&quot;&gt;pack format&lt;/a&gt;.</source>
          <target state="translated">이 느슨한 객체를 효율적인 압축 형식으로 객체 그룹을 저장하는 &quot;팩 파일&quot;로 이동하여 공간을 절약하고 Git을 더 빠르게 만들 수 있습니다. 팩 파일의 형식 지정 방법에 대한 자세한 내용은 &lt;a href=&quot;pack-format&quot;&gt;팩 형식&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="923ef556c5ea1d367a9ceb952e817561488d6f46" translate="yes" xml:space="preserve">
          <source>You can see easily that the above is a rename.</source>
          <target state="translated">위의 이름이 바뀌 었음을 쉽게 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5724c58e846fc905ad55d8bc9c332033225407c5" translate="yes" xml:space="preserve">
          <source>You can set this to &lt;code&gt;link&lt;/code&gt;, in which case a hardlink followed by a delete of the source are used to make sure that object creation will not overwrite existing objects.</source>
          <target state="translated">이것을 &lt;code&gt;link&lt;/code&gt; 로 설정할 수 있습니다.이 경우 소스를 삭제 한 후 하드 링크를 사용하여 객체 생성시 기존 객체를 덮어 쓰지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="02df8661fe031a54ab42701feedaa37cd7c87875" translate="yes" xml:space="preserve">
          <source>You can setup one single value (single entry/item in this list) at build time by setting the &lt;code&gt;GITWEB_BASE_URL&lt;/code&gt; build-time configuration variable. By default it is set to (), i.e. an empty list. This means that gitweb would not try to create project URL (to fetch) from project name.</source>
          <target state="translated">&lt;code&gt;GITWEB_BASE_URL&lt;/code&gt; 빌드 시간 구성 변수 를 설정하여 빌드시 하나의 단일 값 (이 목록의 단일 항목 / 항목)을 설정할 수 있습니다. 기본적으로 (), 즉 빈 목록으로 설정됩니다. 이것은 gitweb이 프로젝트 이름에서 프로젝트 URL을 가져 오려고 시도하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="af5fba33ca90f8278cecf2701efca5c8b71085ca" translate="yes" xml:space="preserve">
          <source>You can specify a list of allowed directories. If no directories are given, all are allowed. This is an additional restriction, gitcvs access still needs to be enabled by the &lt;code&gt;gitcvs.enabled&lt;/code&gt; config option unless &lt;code&gt;--export-all&lt;/code&gt; was given, too.</source>
          <target state="translated">허용 된 디렉토리 목록을 지정할 수 있습니다. 디렉토리가 제공되지 않으면 모두 허용됩니다. 이것은 추가적인 제한 사항입니다. &lt;code&gt;--export-all&lt;/code&gt; 을 지정 하지 않은 경우 gitcvs 액세스를 &lt;code&gt;gitcvs.enabled&lt;/code&gt; 구성 옵션 으로 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a2f1a86c57fcd513fcca4d9c2bf5f81069f36bf3" translate="yes" xml:space="preserve">
          <source>You can specify extra mail header lines to be added to each message, defaults for the subject prefix and file suffix, number patches when outputting more than one patch, add &quot;To:&quot; or &quot;Cc:&quot; headers, configure attachments, change the patch output directory, and sign off patches with configuration variables.</source>
          <target state="translated">각 메일에 추가 할 추가 메일 헤더 행, 제목 접두사 및 파일 접미사에 대한 기본값, 둘 이상의 패치를 출력 할 때의 패치 수, &quot;To :&quot;또는 &quot;Cc :&quot;헤더 추가, 첨부 파일 구성, 패치 변경 출력 디렉토리 및 구성 변수로 패치를 사인 오프하십시오.</target>
        </trans-unit>
        <trans-unit id="c33dd2cd2261f81cbd0fc492df4e16b1e747c25d" translate="yes" xml:space="preserve">
          <source>You can specify the information shown for each object by using a custom &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt;. The &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; is copied literally to stdout for each object, with placeholders of the form &lt;code&gt;%(atom)&lt;/code&gt; expanded, followed by a newline. The available atoms are:</source>
          <target state="translated">사용자 정의 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 을 사용하여 각 오브젝트에 대해 표시되는 정보를 지정할 수 있습니다 . &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 폼의 자리에, 각 개체에 대한 표준 출력에 그대로 복사된다 &lt;code&gt;%(atom)&lt;/code&gt; 개행 뒤에 확장. 사용 가능한 원자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5a94d83b2aa4f52ca10b82e1786cdc28d9f55e56" translate="yes" xml:space="preserve">
          <source>You can tell Git to ignore certain files by creating a file called &lt;code&gt;.gitignore&lt;/code&gt; in the top level of your working directory, with contents such as:</source>
          <target state="translated">작업 디렉토리의 최상위 레벨에 다음과 같은 내용으로 &lt;code&gt;.gitignore&lt;/code&gt; 라는 파일을 작성하여 Git에게 특정 파일을 무시하도록 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="491f06c247008ffc2db5fcd9f930c35d5e25a466" translate="yes" xml:space="preserve">
          <source>You can tell Git to split the Git internal information from the directory that it tracks, but we&amp;rsquo;ll ignore that for now: it&amp;rsquo;s not how normal projects work, and it&amp;rsquo;s really only meant for special uses. So the mental model of &quot;the Git information is always tied directly to the working tree that it describes&quot; may not be technically 100% accurate, but it&amp;rsquo;s a good model for all normal use.</source>
          <target state="translated">Git에게 추적하는 디렉토리에서 Git 내부 정보를 분리하도록 지시 할 수 있지만 현재로서는 무시할 것입니다. 일반적인 프로젝트의 작동 방식이 아니며 실제로는 특수 용도로만 사용됩니다. 따라서 &quot;Git 정보는 항상 작업 트리에 직접 연결되어 있습니다&quot;라는 정신적 모델은 기술적으로 100 % 정확하지는 않지만 모든 정상적인 사용에 적합한 모델입니다.</target>
        </trans-unit>
        <trans-unit id="eba2ddb51d288f0b3a9988b4f1ccbdcde132a1f4" translate="yes" xml:space="preserve">
          <source>You can test whether the filesystem supports that with the &lt;code&gt;--test-untracked-cache&lt;/code&gt; option. The &lt;code&gt;--untracked-cache&lt;/code&gt; option used to implicitly perform that test in older versions of Git, but that&amp;rsquo;s no longer the case.</source>
          <target state="translated">&lt;code&gt;--test-untracked-cache&lt;/code&gt; 옵션 을 사용하여 파일 시스템이이를 지원하는지 테스트 할 수 있습니다 . &lt;code&gt;--untracked-cache&lt;/code&gt; 암시 적으로 사용되는 옵션은 망할 놈의 이전 버전에서이 테스트를 수행하지 않습니다, 그러나 그것은 더 이상 사건.</target>
        </trans-unit>
        <trans-unit id="33337304817f97abbb584fa2c7541a14abb9bfcd" translate="yes" xml:space="preserve">
          <source>You can then fix the conflicts during the rebase. Presumably you have not published your topic other than by mail, so rebasing it is not a problem.</source>
          <target state="translated">그런 다음 리베이스 중에 충돌을 해결할 수 있습니다. 아마 당신은 우편이 아닌 다른 주제를 출판하지 않았기 때문에 문제를 해결하는 것은 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6b74e3d43432e56c49f83bf0e8c1bc1b7ac50b8" translate="yes" xml:space="preserve">
          <source>You can then import these into your mail client and send them by hand. However, if you have a lot to send at once, you may prefer to use the &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt; script to automate the process. Consult the mailing list for your project first to determine their requirements for submitting patches.</source>
          <target state="translated">그런 다음 메일 클라이언트로 가져 와서 직접 보낼 수 있습니다. 그러나 한 번에 보낼 것이 많으면 &lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt; 스크립트를 사용하여 프로세스를 자동화하는 것이 좋습니다. 패치 제출 요구 사항을 확인하려면 먼저 프로젝트의 메일 링리스트를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ad2194dc994cc556c2451e6a9d4c256f90b5afd4" translate="yes" xml:space="preserve">
          <source>You can then transplant the old &lt;code&gt;subsystem..topic&lt;/code&gt; to the new tip by saying (for the reflog case, and assuming you are on &lt;code&gt;topic&lt;/code&gt; already):</source>
          <target state="translated">그런 다음 (reflog 사례의 경우 이미 &lt;code&gt;topic&lt;/code&gt; 에 있다고 가정) 이전 &lt;code&gt;subsystem..topic&lt;/code&gt; ..topic을 새 팁에 이식 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5bb69809c9820257d5f27c5ec379a4130c453d8" translate="yes" xml:space="preserve">
          <source>You can think of this as a set operation. Commits given on the command line form a set of commits that are reachable from any of them, and then commits reachable from any of the ones given with &lt;code&gt;^&lt;/code&gt; in front are subtracted from that set. The remaining commits are what comes out in the command&amp;rsquo;s output. Various other options and paths parameters can be used to further limit the result.</source>
          <target state="translated">이것을 설정된 작업으로 생각할 수 있습니다. 커맨드 라인에 주어진 커밋은 커밋 세트 중 하나에서 도달 할 수 있으며, 앞에 &lt;code&gt;^&lt;/code&gt; 로 주어진 커밋에서 커밋 할 수있는 커밋 은 해당 세트에서 뺍니다. 나머지 커밋은 명령의 출력에서 ​​나오는 것입니다. 다양한 다른 옵션 및 경로 매개 변수를 사용하여 결과를 더 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="497fe81f829587b397446cebabae5d6848f111c9" translate="yes" xml:space="preserve">
          <source>You can think of this as a set operation. Commits reachable from any of the commits given on the command line form a set, and then commits reachable from any of the ones given with &lt;code&gt;^&lt;/code&gt; in front are subtracted from that set. The remaining commits are what comes out in the command&amp;rsquo;s output. Various other options and paths parameters can be used to further limit the result.</source>
          <target state="translated">이것을 세트 작업으로 생각할 수 있습니다. 명령 줄에 지정된 커밋 중 하나에서 도달 할 수있는 커밋이 집합을 형성 한 다음 &lt;code&gt;^&lt;/code&gt; 가 앞에있는 커밋 중 하나에서 도달 할 수있는 커밋 이 해당 집합에서 뺍니다. 나머지 커밋은 명령의 출력에 나오는 것입니다. 다양한 기타 옵션 및 경로 매개 변수를 사용하여 결과를 추가로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eacfd2b96f144de251fd3721b44d6ad9ca988b86" translate="yes" xml:space="preserve">
          <source>You can try running &lt;code&gt;find .git/objects -type f&lt;/code&gt; before and after you run &lt;code&gt;git prune-packed&lt;/code&gt; if you are curious. Also &lt;code&gt;git
count-objects&lt;/code&gt; would tell you how many unpacked objects are in your repository and how much space they are consuming.</source>
          <target state="translated">궁금하다면 &lt;code&gt;git prune-packed&lt;/code&gt; 를 실행하기 전후에 &lt;code&gt;find .git/objects -type f&lt;/code&gt; 를 실행 해보 십시오 . 또한 &lt;code&gt;git count-objects&lt;/code&gt; 는 리포지토리에 압축 해제 된 객체의 수와 사용중인 공간의 양을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="78c0fba98badb6e25ce1949ee53cb8839b8be51a" translate="yes" xml:space="preserve">
          <source>You can update the shared repository with your changes by first committing your changes, and then using the &lt;code&gt;git push&lt;/code&gt; command:</source>
          <target state="translated">먼저 변경 사항을 커밋 한 다음 &lt;code&gt;git push&lt;/code&gt; 명령 을 사용하여 변경 내용으로 공유 리포지토리를 업데이트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe24364fca4da5268b93a1c7c864762589bec5d4" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; to examine the contents of a blob; take, for example, the blob in the entry for &lt;code&gt;COPYING&lt;/code&gt; from the tree above:</source>
          <target state="translated">&lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; 을 사용하여 blob의 내용을 검사 할 수 있습니다 . 예를 들어 위의 트리에서 &lt;code&gt;COPYING&lt;/code&gt; 항목의 얼룩을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cdee252fbf6b663369bb36f7a81711483c778043" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;git stash push --keep-index&lt;/code&gt; when you want to make two or more commits out of the changes in the work tree, and you want to test each change before committing:</source>
          <target state="translated">당신이 사용할 수있는 &lt;code&gt;git stash push --keep-index&lt;/code&gt; 사용하면 작업 트리의 변화에서 두 개 이상의 커밋을 할 때, 당신은 커밋하기 전에 각 변경 사항을 테스트하려면 :</target>
        </trans-unit>
        <trans-unit id="b954fc6ff3f193031cbeca4547760f3425491805" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;git stash&lt;/code&gt; to simplify the above, like this:</source>
          <target state="translated">&lt;code&gt;git stash&lt;/code&gt; 를 사용하여 위와 같이 단순화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c482710749f3dcad6cbdc9701b2eb8b0d7f62e6a" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;stable-1&lt;/code&gt; to refer to the commit 1b2e1d63ff.</source>
          <target state="translated">steady &lt;code&gt;stable-1&lt;/code&gt; 을 사용하여 커밋 1b2e1d63ff를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="783e49ef6897108ce62c504df5bb1071160ba897" translate="yes" xml:space="preserve">
          <source>You can use a basis based on time:</source>
          <target state="translated">시간을 기준으로 기준을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dcaab83279bcfe9c2e3dbaa6b4f0d035029ab31" translate="yes" xml:space="preserve">
          <source>You can use a tag that is present in both:</source>
          <target state="translated">두 가지 모두에있는 태그를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0967772702daca79ec55cd9be52c70fe75848751" translate="yes" xml:space="preserve">
          <source>You can use different &lt;code&gt;&amp;lt;action&amp;gt;&lt;/code&gt; values to control this behavior:</source>
          <target state="translated">다른 &lt;code&gt;&amp;lt;action&amp;gt;&lt;/code&gt; 값을 사용하여이 동작을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72733e82f897a2af21fcfc3df3447e66ece75165" translate="yes" xml:space="preserve">
          <source>You can use it as a human-readable bundle replacement (see &lt;a href=&quot;git-bundle&quot;&gt;git-bundle[1]&lt;/a&gt;), or as a format that can be edited before being fed to &lt;code&gt;git fast-import&lt;/code&gt; in order to do history rewrites (an ability relied on by tools like &lt;code&gt;git filter-repo&lt;/code&gt;).</source>
          <target state="translated">사람이 읽을 수있는 번들 대체 ( &lt;a href=&quot;git-bundle&quot;&gt;git-bundle [1]&lt;/a&gt; 참조) 또는 히스토리 다시 쓰기 (도구에 의존하는 기능)를 위해 &lt;code&gt;git fast-import&lt;/code&gt; 로 공급되기 전에 편집 할 수있는 형식으로 사용할 수 있습니다. &lt;code&gt;git filter-repo&lt;/code&gt; 와 같은 ).</target>
        </trans-unit>
        <trans-unit id="6b34e82e0ff80209e7866272f371ddd1420b0f13" translate="yes" xml:space="preserve">
          <source>You can use mod_perl with gitweb. You must install Apache::Registry (for mod_perl 1.x) or ModPerl::Registry (for mod_perl 2.x) to enable this support.</source>
          <target state="translated">gitweb과 함께 mod_perl을 사용할 수 있습니다. 이 지원을 사용하려면 Apache :: Registry (mod_perl 1.x) 또는 ModPerl :: Registry (mod_perl 2.x)를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="625924bfa2e6c050ea9730ca7a0edb6cfce2bfdc" translate="yes" xml:space="preserve">
          <source>You can use notes to add annotations with information that was not available at the time a commit was written.</source>
          <target state="translated">메모를 사용하여 커밋이 작성 될 때 사용할 수 없었던 정보가 포함 된 주석을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bbbcd5b5890880e82d452d584e7cf77013dabac" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@&lt;/code&gt; construct with an empty ref part to get at a reflog entry of the current branch. For example, if you are on branch &lt;code&gt;blabla&lt;/code&gt; then &lt;code&gt;@{1}&lt;/code&gt; means the same as &lt;code&gt;blabla@{1}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; 참조를 빈 참조 부분과 함께 사용 하면 현재 분기의 참조 로그 항목을 얻을 수 있습니다. 당신이 지점에있는 경우 예를 들어, &lt;code&gt;blabla&lt;/code&gt; 다음 &lt;code&gt;@{1}&lt;/code&gt; 과 같은 의미 &lt;code&gt;blabla@{1}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd3a4b2dd2cada66b7023aa9fae3c933422c9fcc" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@{-N}&lt;/code&gt; syntax to refer to the N-th last branch/commit checked out using &quot;git checkout&quot; operation. You may also specify &lt;code&gt;-&lt;/code&gt; which is synonymous to &lt;code&gt;@{-1}&lt;/code&gt;.</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;code&gt;@{-N}&lt;/code&gt; N 번째 마지막 지점을 참조하는 구문을 / &quot;자식 체크 아웃&quot;작업을 사용하여 체크 아웃 커밋. 당신은 또한 지정할 수 있습니다 &lt;code&gt;-&lt;/code&gt; 동의어이다 &lt;code&gt;@{-1}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e21f11f93a4b8bdb963de3cd700b58b5db33242a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;@{-N}&lt;/code&gt; syntax to refer to the N-th last branch/commit switched to using &quot;git switch&quot; or &quot;git checkout&quot; operation. You may also specify &lt;code&gt;-&lt;/code&gt; which is synonymous to &lt;code&gt;@{-1}&lt;/code&gt;. This is often used to switch quickly between two branches, or to undo a branch switch by mistake.</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;code&gt;@{-N}&lt;/code&gt; N 번째 마지막 지점을 참조하는 구문을 / &quot;자식 스위치&quot;또는 &quot;자식 체크 아웃&quot;작업을 사용하여 전환 커밋. 당신은 또한 지정할 수 있습니다 &lt;code&gt;-&lt;/code&gt; 동의어이다 &lt;code&gt;@{-1}&lt;/code&gt; . 이것은 종종 두 분기 사이를 빠르게 전환하거나 실수로 분기 스위치를 실행 취소하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="736fc09a09a7b16017fd49ac75e258e953294134" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;gitweb.owner&lt;/code&gt; repository configuration variable to set repository&amp;rsquo;s owner. It is displayed in the project list and summary page.</source>
          <target state="translated">&lt;code&gt;gitweb.owner&lt;/code&gt; 저장소 구성 변수를 사용하여 저장소의 소유자를 설정할 수 있습니다 . 프로젝트 목록 및 요약 페이지에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b3762dc0cf78ebbd7cf935ac045ade59a2e3acbf" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;htpasswd&lt;/code&gt; facility that comes with Apache to make these files, but Apache&amp;rsquo;s MD5 crypt method differs from the one used by most C library&amp;rsquo;s crypt() function, so don&amp;rsquo;t use the -m option.</source>
          <target state="translated">Apache와 함께 제공 되는 &lt;code&gt;htpasswd&lt;/code&gt; 기능을 사용하여 이러한 파일을 만들 수 있지만 Apache의 MD5 암호화 방법은 대부분의 C 라이브러리의 crypt () 함수에서 사용하는 방법과 다르므로 -m 옵션을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="80aa1363be3995d4ec384e59561a0e7a0903c070" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;map&lt;/code&gt; convenience function in this filter, and other convenience functions, too. For example, calling &lt;code&gt;skip_commit &quot;$@&quot;&lt;/code&gt; will leave out the current commit (but not its changes! If you want that, use &lt;code&gt;git rebase&lt;/code&gt; instead).</source>
          <target state="translated">당신이 사용할 수있는 &lt;code&gt;map&lt;/code&gt; 도이 필터 및 기타 편의 기능에 편리한 기능입니다. 예를 들어, &lt;code&gt;skip_commit &quot;$@&quot;&lt;/code&gt; 호출 하면 현재 커밋이 생략됩니다 (그러나 변경 사항은 아닙니다! 원하는 경우 대신 &lt;code&gt;git rebase&lt;/code&gt; 를 사용하십시오).</target>
        </trans-unit>
        <trans-unit id="c32abff787b36e9c877031d224291d8c643f61f1" translate="yes" xml:space="preserve">
          <source>You can use the following files in repository:</source>
          <target state="translated">저장소에서 다음 파일을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6c6eac74692734c5ec1dc3c689d37b0eb0dcea6" translate="yes" xml:space="preserve">
          <source>You can use the number of commits:</source>
          <target state="translated">커밋 수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a928f707b340dd3df65a93fa7f9942c5a65d9b2" translate="yes" xml:space="preserve">
          <source>You can very easily automatically bisect broken builds using something like:</source>
          <target state="translated">다음과 같은 방법으로 깨진 빌드를 매우 쉽게 자동으로 이등분 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77487b0c89edd8fd842e99d65a1b39d2c6b378f5" translate="yes" xml:space="preserve">
          <source>You can work through the conflict with a number of tools:</source>
          <target state="translated">여러 도구와의 충돌을 통해 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="918d78d55a9c451b1a86101242b3194591c9e6cc" translate="yes" xml:space="preserve">
          <source>You can write the mandatory option parameter to an option as a separate word on the command line. That means that all the following uses work:</source>
          <target state="translated">명령 행에서 별도의 단어로 옵션에 필수 옵션 매개 변수를 쓸 수 있습니다. 이는 다음의 모든 용도가 작동 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="03d917937bc98856220155e739ac2f8752cca599" translate="yes" xml:space="preserve">
          <source>You can write your own custom helpers to interface with any system in which you keep credentials.</source>
          <target state="translated">사용자 지정 도우미를 작성하여 자격 증명을 유지하는 모든 시스템과 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7f91f3a076bca347349424f4008dca0a1518c15" translate="yes" xml:space="preserve">
          <source>You can write your own custom helpers to interface with any system in which you keep credentials. See credential.h for details.</source>
          <target state="translated">자격 증명을 유지하는 모든 시스템과 인터페이스 할 사용자 지정 도우미를 작성할 수 있습니다. 자세한 내용은 credential.h를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c06b90a2f16de670e5df5d7464445ae0f28559f2" translate="yes" xml:space="preserve">
          <source>You could be using the &lt;code&gt;objects/info/alternates&lt;/code&gt; or &lt;code&gt;$GIT_ALTERNATE_OBJECT_DIRECTORIES&lt;/code&gt; mechanisms to &lt;code&gt;borrow&lt;/code&gt; objects from other object stores. A repository with this kind of incomplete object store is not suitable to be published for use with dumb transports but otherwise is OK as long as &lt;code&gt;objects/info/alternates&lt;/code&gt; points at the object stores it borrows from.</source>
          <target state="translated">당신은 사용이 될 수 &lt;code&gt;objects/info/alternates&lt;/code&gt; 또는 &lt;code&gt;$GIT_ALTERNATE_OBJECT_DIRECTORIES&lt;/code&gt; 할 수있는 메커니즘을 &lt;code&gt;borrow&lt;/code&gt; 다른 물체 매장에서 오브젝트를. 이러한 종류의 불완전한 객체 저장소가있는 저장소는 벙 어링 전송에 사용하기에 공개하기에 적합하지 않지만 객체 저장소에서 &lt;code&gt;objects/info/alternates&lt;/code&gt; 포인트가 차용하는 한 괜찮 습니다.</target>
        </trans-unit>
        <trans-unit id="e2e5ecc00e320fd7f95c1d7def9e5cd07e7e5d74" translate="yes" xml:space="preserve">
          <source>You could do without using any branches at all, by keeping as many local repositories as you would like to have branches, and merging between them with &lt;em&gt;git pull&lt;/em&gt;, just like you merge between branches. The advantage of this approach is that it lets you keep a set of files for each &lt;code&gt;branch&lt;/code&gt; checked out and you may find it easier to switch back and forth if you juggle multiple lines of development simultaneously. Of course, you will pay the price of more disk usage to hold multiple working trees, but disk space is cheap these days.</source>
          <target state="translated">브랜치를 가지고있는 것처럼 많은 로컬 리포지토리를 유지하고 브랜치간에 병합하는 것처럼 &lt;em&gt;git pull으로&lt;/em&gt; 병합하여 브랜치를 전혀 사용하지 않아도됩니다 . 이 방법의 장점은 각 &lt;code&gt;branch&lt;/code&gt; 에 대해 파일 세트를 체크 아웃 할 수 있으며 여러 개발 라인을 동시에 저글링하는 경우 더 쉽게 전환 할 수 있다는 것입니다. 물론 여러 작업 트리를 보유하기 위해 더 많은 디스크 사용량을 지불해야하지만 요즘에는 디스크 공간이 저렴합니다.</target>
        </trans-unit>
        <trans-unit id="8ff03510fc9dfa2f41199478909f4845fc0f0bb6" translate="yes" xml:space="preserve">
          <source>You could have an incomplete but locally usable repository by creating a shallow clone. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;.</source>
          <target state="translated">얕은 클론을 생성하여 불완전하지만 로컬에서 사용할 수있는 저장소를 가질 수 있습니다. &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f736fa76fc678c4f130db13f45faf6b48f41687a" translate="yes" xml:space="preserve">
          <source>You could just visually inspect the commits since e05db0fd:</source>
          <target state="translated">e05db0fd 이후 커밋을 시각적으로 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d78b2a8d8354041e789d882f2348db69275bdcd" translate="yes" xml:space="preserve">
          <source>You could omit &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;, in which case the command degenerates to &quot;check out the current branch&quot;, which is a glorified no-op with rather expensive side-effects to show only the tracking information, if exists, for the current branch.</source>
          <target state="translated">&lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 를 생략 할 수 있습니다 .이 경우 명령이 &quot;현재 분기를 체크 아웃&quot;하도록 퇴화됩니다.이 분기는 현재 분기에 대한 추적 정보 만있는 경우 비용이 많이 드는 부작용이없는 영광스러운 no-op입니다.</target>
        </trans-unit>
        <trans-unit id="7c5b22847ee058ce78c26cbc63e773fbbc9499cd" translate="yes" xml:space="preserve">
          <source>You create a commit object by giving it the tree that describes the state at the time of the commit, and a list of parents:</source>
          <target state="translated">커밋 객체는 커밋 시점의 상태를 설명하는 트리와 부모 목록을 제공하여 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0fca09140e6ecd8df23b487785db8ea6f6692c80" translate="yes" xml:space="preserve">
          <source>You do not want any end-of-line conversions applied to, nor textual diffs produced for, any binary file you track. You would need to specify e.g.</source>
          <target state="translated">추적하는 이진 파일에 줄 끝 변환을 적용하거나 텍스트 차이를 만들지 않습니다. 당신은 예를 들어 지정해야합니다</target>
        </trans-unit>
        <trans-unit id="3b6ec2c54535f15330b4b3b431cf4481da43a55b" translate="yes" xml:space="preserve">
          <source>You do random edits, without running &lt;code&gt;git update-index&lt;/code&gt;. And then you notice that the tip of your &quot;upstream&quot; tree has advanced since you pulled from him:</source>
          <target state="translated">&lt;code&gt;git update-index&lt;/code&gt; 를 실행하지 않고 무작위 편집을 수행 합니다. 그리고 나서 &quot;상류&quot;트리의 끝이 당신이 그를 뽑아 낸 이후로 진행되었음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96b7f9c5e1f885ad6155a2dabe0351e9e08cd246" translate="yes" xml:space="preserve">
          <source>You do your real work in your working tree that has your primary repository hanging under it as its &lt;code&gt;.git&lt;/code&gt; subdirectory. You &lt;strong&gt;could&lt;/strong&gt; make that repository accessible remotely and ask people to pull from it, but in practice that is not the way things are usually done. A recommended way is to have a public repository, make it reachable by other people, and when the changes you made in your primary working tree are in good shape, update the public repository from it. This is often called &lt;code&gt;pushing&lt;/code&gt;.</source>
          <target state="translated">기본 저장소가 &lt;code&gt;.git&lt;/code&gt; 하위 디렉토리 로 매달려있는 작업 트리에서 실제 작업을 수행합니다 . 당신은 &lt;strong&gt;할 수&lt;/strong&gt; 원격으로 저장소에 접근을하고 그것에서 풀에 사람을 물어하지만, 실제로 일을 주로 수행하는 방법이 아니다 그. 권장되는 방법은 공용 저장소를 갖고 다른 사람들이 접근 할 수있게하고 기본 작업 트리에서 변경 한 내용이 올바른 경우 공용 저장소를 업데이트하는 것입니다. 이것을 종종 &lt;code&gt;pushing&lt;/code&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="0911499c26fd93762ba87b20e89843bed2558fd8" translate="yes" xml:space="preserve">
          <source>You have made some commits, but realize they were premature to be in the &lt;code&gt;master&lt;/code&gt; branch. You want to continue polishing them in a topic branch, so create &lt;code&gt;topic/wip&lt;/code&gt; branch off of the current &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">커밋을했지만 &lt;code&gt;master&lt;/code&gt; 브랜치 에 조기에 참여했음을 알 수 있습니다 . 토픽 브랜치에서 계속 연마하고 싶기 때문에 현재 &lt;code&gt;HEAD&lt;/code&gt; 에서 &lt;code&gt;topic/wip&lt;/code&gt; 브랜치를 생성 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9321ccbae87a4bc4f97065bb17cb67a1a81520be" translate="yes" xml:space="preserve">
          <source>You have now created your first Git repository. Of course, since it&amp;rsquo;s empty, that&amp;rsquo;s not very useful, so let&amp;rsquo;s start populating it with data.</source>
          <target state="translated">이제 첫 번째 Git 저장소를 작성했습니다. 물론 비어 있기 때문에 그다지 유용하지 않으므로 데이터로 채우기를 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="d177c25ea329a8110bbd819e0cb66c6b6619b0d7" translate="yes" xml:space="preserve">
          <source>You have now successfully copied somebody else&amp;rsquo;s (mine) remote repository, and checked it out.</source>
          <target state="translated">이제 다른 사람의 (마인) 원격 저장소를 성공적으로 복사하고 체크 아웃했습니다.</target>
        </trans-unit>
        <trans-unit id="3cc6b09871d23a7d903d56d9d6eb61d9c29d1dd4" translate="yes" xml:space="preserve">
          <source>You have performed no merges into mywork, so it is just a simple linear sequence of patches on top of &lt;code&gt;origin&lt;/code&gt;:</source>
          <target state="translated">그 위에 패치의 순서 선형 단순한, 그래서 당신은 MYWORK에 더 병합을 수행하지 않은 &lt;code&gt;origin&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2f8744f866557cd48a608818edcb46f21bfb3d75" translate="yes" xml:space="preserve">
          <source>You have to run &lt;code&gt;git submodule update&lt;/code&gt; after &lt;code&gt;git pull&lt;/code&gt; if you want to update submodules, too.</source>
          <target state="translated">&lt;code&gt;git submodule update&lt;/code&gt; 하려면 &lt;code&gt;git pull&lt;/code&gt; 후에 git 하위 모듈 업데이트 를 실행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f82b6e7678c4aeade044d41684916154b148e08d" translate="yes" xml:space="preserve">
          <source>You haven&amp;rsquo;t specified any nodes as heads so it won&amp;rsquo;t be possible to differentiate between un-parented commits and root nodes.</source>
          <target state="translated">노드를 헤드로 지정하지 않았으므로 부모없는 커밋과 루트 노드를 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="60617aeef2563268db523c5fdc5a619452e83d26" translate="yes" xml:space="preserve">
          <source>You may also add new content that does not exist in the patch; simply add new lines, each starting with &quot;+&quot;. The addition will appear reverted in the working tree.</source>
          <target state="translated">패치에 존재하지 않는 새 컨텐츠를 추가 할 수도 있습니다. 각각 &quot;+&quot;로 시작하는 새로운 줄을 추가하면됩니다. 작업 트리에서 추가 된 내용이 되돌려 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ef502914f7e8ab4571571ef4343614d654bb655c" translate="yes" xml:space="preserve">
          <source>You may also have third-party helpers installed; search for &lt;code&gt;credential-*&lt;/code&gt; in the output of &lt;code&gt;git help -a&lt;/code&gt;, and consult the documentation of individual helpers. Once you have selected a helper, you can tell Git to use it by putting its name into the credential.helper variable.</source>
          <target state="translated">타사 도우미가 설치되어있을 수도 있습니다. &lt;code&gt;git help -a&lt;/code&gt; 출력에서 &lt;code&gt;credential-*&lt;/code&gt; 를 검색하고 개별 헬퍼의 문서를 참조하십시오. 헬퍼를 선택하면 Git에게 credential.helper 변수에 이름을 넣어서 사용하도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2298abd2d14c4384844acf0edbfaf0baea1ecae" translate="yes" xml:space="preserve">
          <source>You may also include a &lt;code&gt;!&lt;/code&gt; in front of the ref name to negate the entry, explicitly exposing it, even if an earlier entry marked it as hidden. If you have multiple hideRefs values, later entries override earlier ones (and entries in more-specific config files override less-specific ones).</source>
          <target state="translated">당신은 또한 포함 할 수 있습니다 &lt;code&gt;!&lt;/code&gt; ref 이름 앞에는 항목을 무효화하고 이전 항목이 숨겨진 것으로 표시 되더라도 명시 적으로 노출합니다. hideRefs 값이 여러 개인 경우 이후 항목은 이전 항목보다 우선합니다 (보다 구체적인 구성 파일의 항목은 덜 구체적인 값보다 우선 함).</target>
        </trans-unit>
        <trans-unit id="ea31f49a09c0b721c12c5805f99a1757f98a096f" translate="yes" xml:space="preserve">
          <source>You may also use &lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool[1]&lt;/a&gt;, which lets you merge the unmerged files using external tools such as Emacs or kdiff3.</source>
          <target state="translated">당신은 또한 사용할 수 있습니다 &lt;a href=&quot;git-mergetool&quot;&gt;자식 - mergetool [1]&lt;/a&gt; 당신이 이맥스 나 kdiff3과 같은 외부 도구를 사용하여 병합되지 않은 파일을 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9adc4f69fd1939534db6a41ec486285df53ebd63" translate="yes" xml:space="preserve">
          <source>You may execute several commands by either using one instance of &lt;code&gt;--exec&lt;/code&gt; with several commands:</source>
          <target state="translated">여러 개의 명령 과 함께 하나의 &lt;code&gt;--exec&lt;/code&gt; 인스턴스를 사용하여 여러 명령을 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a70c5e0fed390964e6d887a35161883ab1754024" translate="yes" xml:space="preserve">
          <source>You may find this helpful after reverting a topic branch merge, as this option recreates the topic branch with fresh commits so it can be remerged successfully without needing to &quot;revert the reversion&quot; (see the &lt;a href=&quot;https://git-scm.com/docs/howto/revert-a-faulty-merge&quot;&gt;revert-a-faulty-merge How-To&lt;/a&gt; for details).</source>
          <target state="translated">이 옵션은 신선한 커밋과 주제 분기를 재현으로는 &quot;복귀를 되돌릴&quot;할 필요없이 성공적으로 remerged 할 수 있도록, 주제 지점 병합을 되 돌린 후이 도움을 찾을 수 있습니다합니다 (참조 &lt;a href=&quot;https://git-scm.com/docs/howto/revert-a-faulty-merge&quot;&gt;되돌리기-A-결함이 병합 작업 방법&lt;/a&gt; 에 대한을 세부).</target>
        </trans-unit>
        <trans-unit id="08631c52a6efa8d7c45c6edcb816f877829615bc" translate="yes" xml:space="preserve">
          <source>You may force &lt;code&gt;git push&lt;/code&gt; to perform the update anyway by preceding the branch name with a plus sign:</source>
          <target state="translated">분기 이름 앞에 더하기 부호를 붙여서 &lt;code&gt;git push&lt;/code&gt; 가 강제로 업데이트를 수행하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae2bd0ef4c886d9dfce1ee8146a7755d847ffcc2" translate="yes" xml:space="preserve">
          <source>You may often find that during a bisect session you want to have temporary modifications (e.g. s/#define DEBUG 0/#define DEBUG 1/ in a header file, or &quot;revision that does not have this commit needs this patch applied to work around another problem this bisection is not interested in&quot;) applied to the revision being tested.</source>
          <target state="translated">bisect 세션 동안 헤더 파일의 s / # define DEBUG 0 / # define DEBUG 1 / 또는 &quot;이 커밋이없는 수정본에는이 패치가 필요합니다. 이 양분에 관심이없는 또 다른 문제 &quot;) 테스트 할 개정에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="014dba50ebab24a63a38baad57ed8364492c1d37" translate="yes" xml:space="preserve">
          <source>You may override individual configuration parameters when running any git command by using the &lt;code&gt;-c&lt;/code&gt; option. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;-c&lt;/code&gt; 옵션 을 사용하여 git 명령을 실행할 때 개별 구성 매개 변수를 대체 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ac5fdcda86efd0f875c444e1e9c4b64fbcccd8a8" translate="yes" xml:space="preserve">
          <source>You may specify configuration in your .git/config</source>
          <target state="translated">.git / config에서 구성을 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="13fb0fac683620e44c1d9b40bc74efe99d0db2f0" translate="yes" xml:space="preserve">
          <source>You may still choose to publish branches whose history is rewritten, and it may be useful for others to be able to fetch those branches in order to examine or test them, but they should not attempt to pull such branches into their own work.</source>
          <target state="translated">여전히 히스토리가 재 작성된 브랜치를 공개하도록 선택할 수 있으며, 다른 브랜치가 해당 브랜치를 검사하거나 테스트하기 위해 해당 브랜치를 가져 오는 것이 유용 할 수 있지만 해당 브랜치를 자신의 작업으로 가져 오려고 시도해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="eb01db138b0fd8c4f790bf23de91d970f6b3f25c" translate="yes" xml:space="preserve">
          <source>You may want to use &lt;code&gt;sslVerify=false&lt;/code&gt; while troubleshooting, if you suspect that the reason you are having trouble connecting is because the certificate you use at the private server &lt;code&gt;example.com&lt;/code&gt; you are trying to set up (or have set up) may not be verified correctly.</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;code&gt;sslVerify=false&lt;/code&gt; 인증서는 개인 서버에서 사용하기 때문에 당신이 연결에 문제가 발생하는 이유가 의심되는 경우 문제 해결 동안, &lt;code&gt;example.com&lt;/code&gt; 사용자가 설정하려는 (또는 설정 한)하지 않을 수 있습니다 올바르게 확인되었습니다.</target>
        </trans-unit>
        <trans-unit id="594c958b8686511065ebf30dd08d761eb22eafab" translate="yes" xml:space="preserve">
          <source>You might need to instead use: &lt;code&gt;folder = &quot;[Google Mail]/Drafts&quot;&lt;/code&gt; if you get an error that the &quot;Folder doesn&amp;rsquo;t exist&quot;.</source>
          <target state="translated">대신 &quot;폴더가 존재하지 않습니다&quot;라는 오류가 발생하면 &lt;code&gt;folder = &quot;[Google Mail]/Drafts&quot;&lt;/code&gt; 사용해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cb3e9e45a2fe07905a833e4999cf989715a0ad3" translate="yes" xml:space="preserve">
          <source>You might need to instead use: folder = &quot;[Google Mail]/Drafts&quot; if you get an error that the &quot;Folder doesn&amp;rsquo;t exist&quot;.</source>
          <target state="translated">&quot;폴더가 존재하지 않습니다&quot;라는 오류가 발생하면 대신 folder = &quot;[Google Mail] / Drafts&quot;를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce52beb4e545845637d5d5a0a1bc64e60b253c82" translate="yes" xml:space="preserve">
          <source>You might want to build on one of these remote-tracking branches on a branch of your own, just as you would for a tag:</source>
          <target state="translated">태그와 마찬가지로 다음과 같은 원격 추적 분기 중 하나를 자체 분기에 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0620c25fa90dc1aefb86ac91dfbd9e4eb8b29d0" translate="yes" xml:space="preserve">
          <source>You might want to recreate merge commits, e.g. if you have a history like this:</source>
          <target state="translated">예를 들어 다음과 같은 기록이있는 경우 병합 커밋을 다시 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76dbf6258421c615799bec755123a1d09c6ae993" translate="yes" xml:space="preserve">
          <source>You need to push the new tag to a public Git server (see &quot;DISTRIBUTED WORKFLOWS&quot; below). This makes the tag available to others tracking your project. The push could also trigger a post-update hook to perform release-related items such as building release tarballs and preformatted documentation pages.</source>
          <target state="translated">새 태그를 공개 Git 서버에 푸시해야합니다 (아래의 &quot;분산 된 워크 플로&quot;참조). 이를 통해 다른 사람들이 프로젝트를 추적 할 수 있습니다. 이 푸시는 또한 업데이트 후 후크를 트리거하여 릴리스 타르볼 작성 및 사전 형식화 된 문서 페이지와 같은 릴리스 관련 항목을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23c2bb7cb1fc9b6f4a240d36b5b4f0b94079730d" translate="yes" xml:space="preserve">
          <source>You need to set the configuration variable &lt;code&gt;rerere.enabled&lt;/code&gt; in order to enable this command.</source>
          <target state="translated">이 명령을 사용하려면 구성 변수 &lt;code&gt;rerere.enabled&lt;/code&gt; 를 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="beb1062efd31de3a255af22760556d9dc5fafa01" translate="yes" xml:space="preserve">
          <source>You normally only do signed tags for major releases or things like that, while the light-weight tags are useful for any marking you want to do &amp;mdash; any time you decide that you want to remember a certain point, just create a private tag for it, and you have a nice symbolic name for the state at that point.</source>
          <target state="translated">일반적으로 주요 릴리스 또는 이와 유사한 작업에 서명 된 태그 만 수행하는 반면, 경량 태그는 원하는 모든 마킹에 유용합니다. 특정 지점을 기억하기로 결정한 경우 개인 태그를 작성하면됩니다. , 그 시점의 상태에 대한 훌륭한 상징적 이름이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0eafb62c845e9f30a39264ada6b686e1d1ebb7b8" translate="yes" xml:space="preserve">
          <source>You often interact with the same remote repository by regularly and repeatedly fetching from it. In order to keep track of the progress of such a remote repository, &lt;code&gt;git fetch&lt;/code&gt; allows you to configure &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; configuration variables.</source>
          <target state="translated">정기적으로 반복해서 가져 와서 동일한 원격 저장소와 상호 작용하는 경우가 많습니다. 이러한 원격 저장소의 진행 상황을 추적하기 위해 &lt;code&gt;git fetch&lt;/code&gt; 를 사용하면 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 구성 변수 를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b67cab4bffb98d3ad72ff6748f9f8b98887d9f3" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t want to invoke this command directly; it is meant to be used as a credential helper by other parts of Git. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; or &lt;code&gt;EXAMPLES&lt;/code&gt; below.</source>
          <target state="translated">이 명령을 직접 호출하고 싶지 않을 수도 있습니다. Git의 다른 부분에서 자격 증명 도우미로 사용되도록 고안되었습니다. 아래의 &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt; 또는 &lt;code&gt;EXAMPLES&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="467e6fc50e0615f651de6ffbcc6e0f17ecbae432" translate="yes" xml:space="preserve">
          <source>You probably don&amp;rsquo;t want to invoke this command directly; it is meant to be used as a credential helper by other parts of git. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; or &lt;code&gt;EXAMPLES&lt;/code&gt; below.</source>
          <target state="translated">이 명령을 직접 호출하고 싶지 않을 수도 있습니다. 그것은 git의 다른 부분에서 자격 증명 도우미로 사용하기위한 것입니다. 아래의 &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt; 또는 &lt;code&gt;EXAMPLES&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c924d93ebd8e89f99e14509235b47dec1acfaa5d" translate="yes" xml:space="preserve">
          <source>You read a &quot;tree&quot; file from the object database, and use that to populate (and overwrite&amp;mdash;​don&amp;rsquo;t do this if your index contains any unsaved state that you might want to restore later!) your current index. Normal operation is just</source>
          <target state="translated">객체 데이터베이스에서 &quot;트리&quot;파일을 읽고 현재 인덱스를 인덱스에 저장하고 덮어 쓰십시오. 인덱스에 저장하지 않은 상태가있는 경우이 작업을 수행하지 마십시오! 정상적인 작동은</target>
        </trans-unit>
        <trans-unit id="e01bf60bb2a8e848b7516e87eb6405fb0e476f7b" translate="yes" xml:space="preserve">
          <source>You really filtered all refs: use &lt;code&gt;--tag-name-filter cat -- --all&lt;/code&gt; when calling git-filter-branch.</source>
          <target state="translated">git-filter-branch를 호출 할 때 &lt;code&gt;--tag-name-filter cat -- --all&lt;/code&gt; 사용하여 모든 참조를 실제로 필터링했습니다 .</target>
        </trans-unit>
        <trans-unit id="0cb205f517a67a8e523ed9cfa8681dc8f8d7b0ce" translate="yes" xml:space="preserve">
          <source>You really removed all variants of a filename, if a blob was moved over its lifetime. &lt;code&gt;git log --name-only --follow --all -- filename&lt;/code&gt; can help you find renames.</source>
          <target state="translated">얼룩이 수명 동안 이동 한 경우 파일 이름의 모든 변형을 실제로 제거했습니다. &lt;code&gt;git log --name-only --follow --all -- filename&lt;/code&gt; 은 이름 바꾸기를 찾는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a347f016fee70b8901448b2a81ecd1980ba100a9" translate="yes" xml:space="preserve">
          <source>You see, Git is actually the best tool to find out about the source of Git itself!</source>
          <target state="translated">아시다시피, Git은 실제로 Git 자체의 소스를 찾는 가장 좋은 도구입니다!</target>
        </trans-unit>
        <trans-unit id="2f7c7430f5ab3ddee895946cce58e0edcbc9b3f3" translate="yes" xml:space="preserve">
          <source>You should &lt;strong&gt;never&lt;/strong&gt; do any work of your own on the branches that are created by &lt;code&gt;git cvsimport&lt;/code&gt;. By default initial import will create and populate a &quot;master&quot; branch from the CVS repository&amp;rsquo;s main branch which you&amp;rsquo;re free to work with; after that, you need to &lt;code&gt;git merge&lt;/code&gt; incremental imports, or any CVS branches, yourself. It is advisable to specify a named remote via -r to separate and protect the incoming branches.</source>
          <target state="translated">&lt;code&gt;git cvsimport&lt;/code&gt; 에 의해 생성 된 브랜치에서 어떤 작업도 수행 해서는 &lt;strong&gt;안됩니다&lt;/strong&gt; . 기본적으로 초기 가져 오기는 CVS 저장소의 기본 분기에서 &quot;마스터&quot;분기를 작성하고 채울 수 있습니다. 그런 다음 증분 가져 오기 또는 CVS 분기를 직접 &lt;code&gt;git merge&lt;/code&gt; 해야합니다 . 들어오는 분기를 분리하고 보호하기 위해 -r을 통해 명명 된 원격을 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ac5b50c688e69b32b2a523ca6520323d9259e65e" translate="yes" xml:space="preserve">
          <source>You should consider using &lt;code&gt;dcommit&lt;/code&gt; instead of this command. Commit specified commit or tree objects to SVN. This relies on your imported fetch data being up to date. This makes absolutely no attempts to do patching when committing to SVN, it simply overwrites files with those specified in the tree or commit. All merging is assumed to have taken place independently of &lt;code&gt;git svn&lt;/code&gt; functions.</source>
          <target state="translated">이 명령 대신 &lt;code&gt;dcommit&lt;/code&gt; 사용을 고려해야 합니다. 지정된 커밋 또는 트리 객체를 SVN에 커밋합니다. 가져온 가져 오기 데이터가 최신 상태인지 확인합니다. 이것은 SVN에 커밋 할 때 패치를 시도하지 않으며 트리 또는 커밋에 지정된 파일로 단순히 덮어 씁니다. 모든 병합은 &lt;code&gt;git svn&lt;/code&gt; 함수와 독립적으로 수행 된 것으로 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="f0db0149a7a61b2b34d3de583889773851c606fb" translate="yes" xml:space="preserve">
          <source>You should now compile the checked-out version and test it. If that version works correctly, type</source>
          <target state="translated">이제 체크 아웃 된 버전을 컴파일하고 테스트해야합니다. 해당 버전이 제대로 작동하면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="4ce522d2b57e2c5b1484c387e3121e7cf3c762ef" translate="yes" xml:space="preserve">
          <source>You should refrain from abusing this option to sneak substantial changes into a merge commit. Small fixups like bumping release/version name would be acceptable.</source>
          <target state="translated">이 옵션을 남용하여 실질적인 변경 사항을 병합 커밋에 몰래 넣지 마십시오. 충돌 릴리스 / 버전 이름과 같은 작은 수정은 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="de1993c72b3b1ad3dd18c76738408f9f041af6eb" translate="yes" xml:space="preserve">
          <source>You should understand the implications of rewriting history if you amend a commit that has already been published. (See the &quot;RECOVERING FROM UPSTREAM REBASE&quot; section in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.)</source>
          <target state="translated">이미 게시 된 커밋을 수정 한 경우 기록 다시 쓰기의 의미를 이해해야합니다. ( &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]의&lt;/a&gt; &quot;UPSTREAM REBASE 복구&quot;섹션을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="a5048e0c5c1221139fe969fc6db15713d2b83eb5" translate="yes" xml:space="preserve">
          <source>You should understand the implications of using &lt;code&gt;git rebase&lt;/code&gt; on a repository that you share. See also RECOVERING FROM UPSTREAM REBASE below.</source>
          <target state="translated">공유하는 저장소에서 &lt;code&gt;git rebase&lt;/code&gt; 를 사용할 때의 의미를 이해해야합니다 . 아래의 UPSTREAM REBASE에서 복구를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7550fee71eb33261ce4427a0e3743a34c95d7107" translate="yes" xml:space="preserve">
          <source>You should work through &lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt; before reading this tutorial.</source>
          <target state="translated">이 튜토리얼을 읽기 전에 &lt;a href=&quot;gittutorial&quot;&gt;gittutorial [7]을&lt;/a&gt; 통해 작업해야합니다 .</target>
        </trans-unit>
        <trans-unit id="33b464d633d5d3d359d8c081bd1ef24a08ba23d1" translate="yes" xml:space="preserve">
          <source>You then transfer the bundle to the other machine to replace /home/me/tmp/file.bundle, and pull from it.</source>
          <target state="translated">그런 다음 번들을 다른 시스템으로 전송하여 /home/me/tmp/file.bundle을 바꾸고 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="98122f0a874f3f8b610fdbc33b228a3b5afee64a" translate="yes" xml:space="preserve">
          <source>You update your working directory from the index by &quot;checking out&quot; files. This is not a very common operation, since normally you&amp;rsquo;d just keep your files updated, and rather than write to your working directory, you&amp;rsquo;d tell the index files about the changes in your working directory (i.e. &lt;code&gt;git update-index&lt;/code&gt;).</source>
          <target state="translated">파일을 &quot;체크 아웃&quot;하여 색인에서 작업 디렉토리를 업데이트합니다. 일반적으로 파일을 업데이트 한 상태로 유지하고 작업 디렉토리에 쓰지 않고 색인 파일에 작업 디렉토리의 변경 사항 (예 : &lt;code&gt;git update-index&lt;/code&gt; )을 알려주므로 매우 일반적인 작업은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="57134770b9c7f61c90927970f67f3d2eceaa4a12" translate="yes" xml:space="preserve">
          <source>You will continue to do your day-to-day work in your personal repository, but periodically &quot;push&quot; changes from your personal repository into your public repository, allowing other developers to pull from that repository. So the flow of changes, in a situation where there is one other developer with a public repository, looks like this:</source>
          <target state="translated">개인 저장소에서 일상적인 작업을 계속 수행하지만 개인 저장소에서 공용 저장소로 변경 사항을 주기적으로 &quot;밀어 넣어&quot;다른 개발자가 해당 저장소에서 가져올 수 있습니다. 따라서 공용 저장소를 가진 다른 개발자가있는 상황에서 변경 흐름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8876e4496883cded62698bb08d4c1d5f289e1dee" translate="yes" xml:space="preserve">
          <source>You will see both of these things throughout the code.</source>
          <target state="translated">코드 전체에서이 두 가지를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dda56fbfc3230573e73ab526d0f70db698497a1" translate="yes" xml:space="preserve">
          <source>You will see informational messages on dangling objects. They are objects that still exist in the repository but are no longer referenced by any of your branches, and can (and will) be removed after a while with &lt;code&gt;gc&lt;/code&gt;. You can run &lt;code&gt;git fsck --no-dangling&lt;/code&gt; to suppress these messages, and still view real errors.</source>
          <target state="translated">매달려있는 개체에 대한 정보 메시지가 표시됩니다. 그것들은 여전히 ​​저장소에 존재하지만 더 이상 어떤 브랜치에서도 참조하지 않는 객체이며 &lt;code&gt;gc&lt;/code&gt; 로 잠시 후에 제거 할 수 있습니다 . &lt;code&gt;git fsck --no-dangling&lt;/code&gt; 을 실행 하여 이러한 메시지를 억제하고 실제 오류를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2fc4e070409aa778dc2444037511e0ef4801d3d" translate="yes" xml:space="preserve">
          <source>You will see two files, &lt;code&gt;pack-*.pack&lt;/code&gt; and &lt;code&gt;pack-*.idx&lt;/code&gt;, in &lt;code&gt;.git/objects/pack&lt;/code&gt; directory. They are closely related to each other, and if you ever copy them by hand to a different repository for whatever reason, you should make sure you copy them together. The former holds all the data from the objects in the pack, and the latter holds the index for random access.</source>
          <target state="translated">&lt;code&gt;.git/objects/pack&lt;/code&gt; 디렉토리 에 pack- &lt;code&gt;pack-*.pack&lt;/code&gt; 및 &lt;code&gt;pack-*.idx&lt;/code&gt; 파일이 표시됩니다 . 그것들은 서로 밀접하게 관련되어 있으며 어떤 이유로 든 다른 저장소에 직접 복사하는 경우 함께 복사해야합니다. 전자는 팩에있는 개체의 모든 데이터를 보유하고 후자는 임의 액세스를위한 색인을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="266addba668945d927bfdfb63b85369114140000" translate="yes" xml:space="preserve">
          <source>You will still have to tell people by other means, such as mail. (Git provides the &lt;a href=&quot;git-request-pull&quot;&gt;git-request-pull[1]&lt;/a&gt; to send preformatted pull requests to upstream maintainers to simplify this task.)</source>
          <target state="translated">우편과 같은 다른 방법으로 사람들에게 계속 알려야합니다. Git은 &lt;a href=&quot;git-request-pull&quot;&gt;git-request-pull [1]&lt;/a&gt; 을 제공하여이 작업을 단순화하기 위해 사전 형식화 된 풀 요청을 업스트림 관리자에게 보냅니다.</target>
        </trans-unit>
        <trans-unit id="67a2c97a3fe15102ccbc39363d071f9caa744775" translate="yes" xml:space="preserve">
          <source>You would normally use &lt;code&gt;git merge-index&lt;/code&gt; with supplied &lt;code&gt;git merge-one-file&lt;/code&gt; to do this last step. The script updates the files in the working tree as it merges each path and at the end of a successful merge.</source>
          <target state="translated">일반적으로 제공된 &lt;code&gt;git merge-one-file&lt;/code&gt; 과 함께 &lt;code&gt;git merge-index&lt;/code&gt; 를 사용 하여 마지막 단계를 수행합니다. 스크립트는 각 경로를 병합하고 성공적인 병합이 끝날 때 작업 트리의 파일을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="acf5d70c570af359d1fc1b3db4b2e1cb44907ec4" translate="yes" xml:space="preserve">
          <source>You wouldn&amp;rsquo;t need to ever change it in gitweb config file.</source>
          <target state="translated">gitweb 설정 파일에서 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="065eff42d50778a1002dd0b7a890143f4063288e" translate="yes" xml:space="preserve">
          <source>You write your current index file to a &quot;tree&quot; object with the program</source>
          <target state="translated">프로그램을 사용하여 현재 색인 파일을 &quot;트리&quot;객체에 씁니다.</target>
        </trans-unit>
        <trans-unit id="49012e7b5c219e4c44033d7ce0ec88b78d68a780" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve now initialized the working directory&amp;mdash;​you may notice a new directory created, named &quot;.git&quot;.</source>
          <target state="translated">이제 작업 디렉토리를 초기화했습니다. &quot;.git&quot;라는 새 디렉토리가 생성 된 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e4b96aa3f69a0a980be2d48bd9eb2298bc44f3c" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve now made your first real Git commit. And if you&amp;rsquo;re interested in looking at what &lt;code&gt;git commit&lt;/code&gt; really does, feel free to investigate: it&amp;rsquo;s a few very simple shell scripts to generate the helpful (?) commit message headers, and a few one-liners that actually do the commit itself (&lt;code&gt;git commit&lt;/code&gt;).</source>
          <target state="translated">이제 첫 번째 실제 Git 커밋을 만들었습니다. 그리고 &lt;code&gt;git commit&lt;/code&gt; 이 실제로 무엇을하는지 관심이 있다면 , 자유롭게 조사해보십시오. 유용한 (?) commit 메시지 헤더를 생성하는 매우 간단한 쉘 스크립트와 실제로 commit 자체를 수행하는 하나의 라이너 ( &lt;code&gt;git commit&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6fd65e242e5023949f1979a313cb8892375303bf" translate="yes" xml:space="preserve">
          <source>Your &quot;public repository&quot; is now ready to accept your changes. Come back to the machine you have your private repository. From there, run this command:</source>
          <target state="translated">&quot;공개 저장소&quot;가 이제 변경 사항을 승인 할 준비가되었습니다. 개인 저장소가있는 머신으로 돌아 오십시오. 거기에서 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="77f5c1536424041eff5dddce9b9dc699480c5921" translate="yes" xml:space="preserve">
          <source>Your private repository&amp;rsquo;s Git directory is usually &lt;code&gt;.git&lt;/code&gt;, but your public repository is often named after the project name, i.e. &lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt;. Let&amp;rsquo;s create such a public repository for project &lt;code&gt;my-git&lt;/code&gt;. After logging into the remote machine, create an empty directory:</source>
          <target state="translated">개인 저장소의 Git 디렉토리는 일반적으로 &lt;code&gt;.git&lt;/code&gt; 이지만 공용 저장소의 이름은 종종 프로젝트 이름 (예 : &lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt; )으로 지정 됩니다. &lt;code&gt;my-git&lt;/code&gt; 프로젝트를위한 공개 저장소를 만들어 보자 . 원격 머신에 로그인 한 후 빈 디렉토리를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b96e6decf426a8986abe42a514d0d538e2f36071" translate="yes" xml:space="preserve">
          <source>Your work tree is still based on your HEAD ($JC), but you have some edits since. Three-way merge makes sure that you have not added or modified index entries since $JC, and if you haven&amp;rsquo;t, then does the right thing. So with the following sequence:</source>
          <target state="translated">작업 트리는 여전히 HEAD ($ JC)를 기반으로하지만 그 이후로 몇 가지 수정 사항이 있습니다. 3 방향 병합은 $ JC 이후로 색인 항목을 추가하거나 수정하지 않았으며, 그렇지 않은 경우 올바른 작업을 수행합니다. 따라서 다음 순서로 :</target>
        </trans-unit>
        <trans-unit id="8ff2148494456dea5c056275d6718302d7ecd982" translate="yes" xml:space="preserve">
          <source>Zero or more &lt;code&gt;filemodify&lt;/code&gt;, &lt;code&gt;filedelete&lt;/code&gt;, &lt;code&gt;filecopy&lt;/code&gt;, &lt;code&gt;filerename&lt;/code&gt;, &lt;code&gt;filedeleteall&lt;/code&gt; and &lt;code&gt;notemodify&lt;/code&gt; commands may be included to update the contents of the branch prior to creating the commit. These commands may be supplied in any order. However it is recommended that a &lt;code&gt;filedeleteall&lt;/code&gt; command precede all &lt;code&gt;filemodify&lt;/code&gt;, &lt;code&gt;filecopy&lt;/code&gt;, &lt;code&gt;filerename&lt;/code&gt; and &lt;code&gt;notemodify&lt;/code&gt; commands in the same commit, as &lt;code&gt;filedeleteall&lt;/code&gt; wipes the branch clean (see below).</source>
          <target state="translated">커밋을 만들기 전에 분기의 내용을 업데이트하기 위해 0 개 이상의 &lt;code&gt;filemodify&lt;/code&gt; , &lt;code&gt;filedelete&lt;/code&gt; , &lt;code&gt;filecopy&lt;/code&gt; , &lt;code&gt;filerename&lt;/code&gt; , &lt;code&gt;filedeleteall&lt;/code&gt; 및 &lt;code&gt;notemodify&lt;/code&gt; 명령이 포함될 수 있습니다. 이러한 명령은 임의의 순서로 제공 될 수 있습니다. 그러나 &lt;code&gt;filedeleteall&lt;/code&gt; 은 브랜치를 정리하므로 (아래 참조) , 동일한 커밋에서 &lt;code&gt;filedeleteall&lt;/code&gt; 명령이 모든 &lt;code&gt;filemodify&lt;/code&gt; , &lt;code&gt;filecopy&lt;/code&gt; , &lt;code&gt;filerename&lt;/code&gt; 및 &lt;code&gt;notemodify&lt;/code&gt; 명령 앞에 오는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="480b45cead8c71eaa647209c97491be4a36ea289" translate="yes" xml:space="preserve">
          <source>Zero or more protocol options may be entered after the last &lt;code&gt;push&lt;/code&gt; command, before the batch&amp;rsquo;s terminating blank line.</source>
          <target state="translated">일괄 처리 종료 빈 줄 앞에 마지막 &lt;code&gt;push&lt;/code&gt; 명령 후 0 개 이상의 프로토콜 옵션을 입력 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fbdec3db39874b3b5b75476184662777ddc44fd6" translate="yes" xml:space="preserve">
          <source>[&amp;lt;git-rev-list-args&amp;gt;&amp;hellip;​]</source>
          <target state="translated">[&amp;lt;git-rev-list-args&amp;gt;&amp;hellip;​]</target>
        </trans-unit>
        <trans-unit id="b3a075bbccfeeb4bedba2aca4addb159d1acee3d" translate="yes" xml:space="preserve">
          <source>[&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">[&amp;lt;path&amp;gt;&amp;hellip;​]</target>
        </trans-unit>
        <trans-unit id="d31c8b5c3af548ff2d95f4e227ea28f0f9277441" translate="yes" xml:space="preserve">
          <source>[&amp;lt;refname&amp;gt;&amp;hellip;​]</source>
          <target state="translated">[&amp;lt;refname&amp;gt;&amp;hellip;​]</target>
        </trans-unit>
        <trans-unit id="e961d55ee5b355694495464c07c86f7fba23e9a9" translate="yes" xml:space="preserve">
          <source>[--] &amp;lt;path&amp;gt;&amp;hellip;​</source>
          <target state="translated">[-] &amp;lt;경로&amp;gt;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="1eb3d578c1f910d18345d8eb23a781efa2f8d23d" translate="yes" xml:space="preserve">
          <source>[0] &lt;a href=&quot;https://bugs.chromium.org/p/git/issues/detail?id=6&quot;&gt;https://bugs.chromium.org/p/git/issues/detail?id=6&lt;/a&gt; Chromium work item for: Multi-Pack Index (MIDX)</source>
          <target state="translated">[0] &lt;a href=&quot;https://bugs.chromium.org/p/git/issues/detail?id=6&quot;&gt;https://bugs.chromium.org/p/git/issues/detail?id=6&lt;/a&gt; Chromium 작업 항목 : 멀티 팩 인덱스 (MIDX)</target>
        </trans-unit>
        <trans-unit id="25a96ba2d3b7a7d8ee2c18075362c090194ac1d0" translate="yes" xml:space="preserve">
          <source>[1] &lt;a href=&quot;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&quot;&gt;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&lt;/a&gt; An earlier RFC for the multi-pack-index feature</source>
          <target state="translated">[1] &lt;a href=&quot;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&quot;&gt;https://lore.kernel.org/git/20180107181459.222909-1-dstolee@microsoft.com/&lt;/a&gt; 다중 팩 인덱스 기능을위한 초기 RFC</target>
        </trans-unit>
        <trans-unit id="347fffb72e72a788a9461ff2e246ae61494e14d7" translate="yes" xml:space="preserve">
          <source>[2] &lt;a href=&quot;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&quot;&gt;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&lt;/a&gt; Git Merge 2018 Contributor&amp;rsquo;s summit notes (includes discussion of MIDX)</source>
          <target state="translated">[2] &lt;a href=&quot;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&quot;&gt;https://lore.kernel.org/git/alpine.DEB.2.20.1803091557510.23109@alexmv-linux/&lt;/a&gt; Git Merge 2018 컨트 리뷰 터의 서밋 노트 (MIDX에 대한 토론 포함)</target>
        </trans-unit>
        <trans-unit id="feea73f842c5a1ec74b307b98128568bae22544a" translate="yes" xml:space="preserve">
          <source>[DEPRECATED: use &lt;code&gt;--rebase-merges&lt;/code&gt; instead] Recreate merge commits instead of flattening the history by replaying commits a merge commit introduces. Merge conflict resolutions or manual amendments to merge commits are not preserved.</source>
          <target state="translated">[DEPRECATED : 대신 &lt;code&gt;--rebase-merges&lt;/code&gt; 사용] 커밋을 도입 한 커밋을 재생하여 히스토리를 병합하는 대신 병합 커밋을 다시 만듭니다. 병합 충돌 해결 또는 커밋 병합에 대한 수동 수정 사항은 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a59f280e0e654176579fad979c6b2390d4560b5d" translate="yes" xml:space="preserve">
          <source>[EXPERIMENTAL] Set to &lt;code&gt;true&lt;/code&gt; to use the experimental built-in implementation of the interactive version of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; instead of the Perl script version. Is &lt;code&gt;false&lt;/code&gt; by default.</source>
          <target state="translated">[EXPERIMENTAL] Perl 스크립트 버전 대신 대화식 버전의 &lt;a href=&quot;git-add&quot;&gt;git-add [1]에&lt;/a&gt; 대해 실험적인 내장 구현을 사용하려면 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 . 가 &lt;code&gt;false&lt;/code&gt; 기본적으로.</target>
        </trans-unit>
        <trans-unit id="f8205d704abeeab8758bae84f0f9eac80a6c4899" translate="yes" xml:space="preserve">
          <source>[NOTE] &lt;code&gt;git rerere&lt;/code&gt; relies on the conflict markers in the file to detect the conflict. If the file already contains lines that look the same as lines with conflict markers, &lt;code&gt;git rerere&lt;/code&gt; may fail to record a conflict resolution. To work around this, the &lt;code&gt;conflict-marker-size&lt;/code&gt; setting in &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; can be used.</source>
          <target state="translated">[참고] &lt;code&gt;git rerere&lt;/code&gt; 는 파일의 충돌 마커를 사용하여 충돌을 감지합니다. 파일에 충돌 표식이있는 줄과 같은 줄이 이미 포함되어 있으면 &lt;code&gt;git rerere&lt;/code&gt; 가 충돌 해결을 기록하지 못할 수 있습니다. 이 문제를 해결하기 위해 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 의 &lt;code&gt;conflict-marker-size&lt;/code&gt; 설정을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac4bc8630c3c03bfd813e3fe5057d1c466974ce5" translate="yes" xml:space="preserve">
          <source>[[[1]]] &lt;a href=&quot;https://www.nist.gov/sites/default/files/documents/director/planning/report02-3.pdf&quot;&gt;&lt;em&gt;The Economic Impacts of Inadequate Infratructure for Software Testing&lt;/em&gt;. Nist Planning Report 02-3&lt;/a&gt;, see Executive Summary and Chapter 8.</source>
          <target state="translated">[[[1]]] &lt;a href=&quot;https://www.nist.gov/sites/default/files/documents/director/planning/report02-3.pdf&quot;&gt;&lt;em&gt;소프트웨어 테스팅에 대한 부적절한 인프라의 경제적 영향&lt;/em&gt; . Nist Planning Report 02-3&lt;/a&gt; 은 Executive Summary 및 8 장을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e5f919a0494a6ccb56ff39496ebf8651f04232d2" translate="yes" xml:space="preserve">
          <source>[[[2]]] &lt;a href=&quot;http://www.oracle.com/technetwork/java/codeconvtoc-136057.html&quot;&gt;&lt;em&gt;Code Conventions for the Java Programming Language&lt;/em&gt;. Sun Microsystems.&lt;/a&gt;</source>
          <target state="translated">[[[2]]] &lt;a href=&quot;http://www.oracle.com/technetwork/java/codeconvtoc-136057.html&quot;&gt;&lt;em&gt;Java 프로그래밍 언어의 코드 규약&lt;/em&gt; . 썬 마이크로 시스템즈.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="de6da26d7d92c3d4bdee11d004d96506e88a1b00" translate="yes" xml:space="preserve">
          <source>[[[3]]] &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_maintenance&quot;&gt;&lt;em&gt;Software maintenance&lt;/em&gt;. Wikipedia.&lt;/a&gt;</source>
          <target state="translated">[[[3]]] &lt;a href=&quot;https://en.wikipedia.org/wiki/Software_maintenance&quot;&gt;&lt;em&gt;소프트웨어 유지 보수&lt;/em&gt; . 위키 백과.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a21dac2771422b1ce396ac7103119df3289ef40d" translate="yes" xml:space="preserve">
          <source>[[[4]]] &lt;a href=&quot;https://lore.kernel.org/git/7vps5xsbwp.fsf_-_@assigned-by-dhcp.cox.net/&quot;&gt;Junio C Hamano. &lt;em&gt;Automated bisect success story&lt;/em&gt;.&lt;/a&gt;</source>
          <target state="translated">[[[4]]] &lt;a href=&quot;https://lore.kernel.org/git/7vps5xsbwp.fsf_-_@assigned-by-dhcp.cox.net/&quot;&gt;Junio ​​C 하마노. &lt;em&gt;자동 이등분 성공 사례&lt;/em&gt; .&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06e39006ce98590e4632510795aafbc71a8d5177" translate="yes" xml:space="preserve">
          <source>[[[5]]] &lt;a href=&quot;https://lwn.net/Articles/317154/&quot;&gt;Christian Couder. &lt;em&gt;Fully automated bisecting with &quot;git bisect run&quot;&lt;/em&gt;. LWN.net.&lt;/a&gt;</source>
          <target state="translated">[[[5]]] &lt;a href=&quot;https://lwn.net/Articles/317154/&quot;&gt;크리스티안 쿠더. &lt;em&gt;&quot;git bisect run&quot;을 사용한 완전 자동화 된 이등분&lt;/em&gt; . LWN.net.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a12b60ab9e79fee2e4613d666532029fdb7e1f4d" translate="yes" xml:space="preserve">
          <source>[[[6]]] &lt;a href=&quot;https://lwn.net/Articles/277872/&quot;&gt;Jonathan Corbet. &lt;em&gt;Bisection divides users and developers&lt;/em&gt;. LWN.net.&lt;/a&gt;</source>
          <target state="translated">[[[6]]] &lt;a href=&quot;https://lwn.net/Articles/277872/&quot;&gt;Jonathan Corbet. &lt;em&gt;Bisection은 사용자와 개발자를 나눕니다&lt;/em&gt; . LWN.net.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb3a1d698c871451809a03759d2052ad730db3fa" translate="yes" xml:space="preserve">
          <source>[[[7]]] &lt;a href=&quot;https://lore.kernel.org/lkml/20071207113734.GA14598@elte.hu/&quot;&gt;Ingo Molnar. &lt;em&gt;Re: BUG 2.6.23-rc3 can&amp;rsquo;t see sd partitions on Alpha&lt;/em&gt;. Linux-kernel mailing list.&lt;/a&gt;</source>
          <target state="translated">[[[7]]] &lt;a href=&quot;https://lore.kernel.org/lkml/20071207113734.GA14598@elte.hu/&quot;&gt;잉고 몰 나르. &lt;em&gt;Re : BUG 2.6.23-rc3는 Alpha에서 sd 파티션을 볼 수 없습니다&lt;/em&gt; . 리눅스 커널 메일 링리스트.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91adb50bf54c20a1b51a7a5bd4f97f72154e309d" translate="yes" xml:space="preserve">
          <source>[[[8]]] &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html&quot;&gt;Junio C Hamano and the git-list. &lt;em&gt;git-bisect(1) Manual Page&lt;/em&gt;. Linux Kernel Archives.&lt;/a&gt;</source>
          <target state="translated">[[[8]]] &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-bisect.html&quot;&gt;Junio ​​C Hamano와 자식 목록. &lt;em&gt;git-bisect (1) 매뉴얼 페이지&lt;/em&gt; . 리눅스 커널 아카이브.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="62e3bcbb19b635de003c473322577e0da443bd26" translate="yes" xml:space="preserve">
          <source>[[[9]]] &lt;a href=&quot;https://github.com/Ealdwulf/bbchop&quot;&gt;Ealdwulf. &lt;em&gt;bbchop&lt;/em&gt;. GitHub.&lt;/a&gt;</source>
          <target state="translated">[[[9]]] &lt;a href=&quot;https://github.com/Ealdwulf/bbchop&quot;&gt;얼 독프. &lt;em&gt;바비큐&lt;/em&gt; . GitHub.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4720dfbb1b4c30f403e79c3ea73865f0f4c5faef" translate="yes" xml:space="preserve">
          <source>[user@]host.xz:/~[user]/path/to/repo.git/</source>
          <target state="translated">[user@]host.xz:/~[user]/path/to/repo.git/</target>
        </trans-unit>
        <trans-unit id="5995beae7c11faa4cc7064555dea6942a8fa3779" translate="yes" xml:space="preserve">
          <source>[user@]host.xz:path/to/repo.git/</source>
          <target state="translated">[user@]host.xz:path/to/repo.git/</target>
        </trans-unit>
        <trans-unit id="8bc9eff643c5f26b1d25ab8fdf5a5ddc87d11ead" translate="yes" xml:space="preserve">
          <source>\0 line termination on output and do not quote filenames. See OUTPUT FORMAT below for more information.</source>
          <target state="translated">출력시 \ 0 줄 종결이며 파일 이름을 인용하지 않습니다. 자세한 내용은 아래 출력 형식을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d0b23d6e6728ae49ec5909ad48b79671e7245999" translate="yes" xml:space="preserve">
          <source>\0 line termination on output and do not quote filenames. See OUTPUT below for more information.</source>
          <target state="translated">출력시 \ 0 줄 종결이며 파일 이름을 인용하지 않습니다. 자세한 내용은 아래 출력을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ec441d8e621550cb4deb96e2b1ad67311ed0768f" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt; directory that is a &lt;code&gt;bare&lt;/code&gt; repository (i.e. without its own working tree), that is typically used for exchanging histories with others by pushing into it and fetching from it.</source>
          <target state="translated">&lt;code&gt;&amp;lt;project&amp;gt;.git&lt;/code&gt; A는 디렉토리 &lt;code&gt;bare&lt;/code&gt; 저장소 (즉, 자신의 작업 트리없이) 일반적으로 그것으로 밀고 그것에서 인출하여 다른 사람들과 역사를 교환하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="ea844fb65222d001b2e2f561d577c3d6a932db4a" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;.git&lt;/code&gt; directory at the root of the working tree;</source>
          <target state="translated">작업 트리의 루트에 있는 &lt;code&gt;.git&lt;/code&gt; 디렉토리;</target>
        </trans-unit>
        <trans-unit id="f0d4bf33608fee8383e25a39f62fec37be3db742" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;lot&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc234069c4e3ee03ef8f7670cb491ed5411b65b6" translate="yes" xml:space="preserve">
          <source>a NUL (only exists if renamed/copied);</source>
          <target state="translated">NUL (이름이 바뀌거나 복사 된 경우에만 존재);</target>
        </trans-unit>
        <trans-unit id="079f5a842faae1ecf0933e998354e66093295bb8" translate="yes" xml:space="preserve">
          <source>a NUL.</source>
          <target state="translated">NUL.</target>
        </trans-unit>
        <trans-unit id="e9278592288a5c5c028d9d1d04c2201af670c4f7" translate="yes" xml:space="preserve">
          <source>a URL like &quot;git://example.org/path/to/repo.git&quot; will be rewritten to &quot;ssh://example.org/path/to/repo.git&quot; for pushes, but pulls will still use the original URL.</source>
          <target state="translated">&quot;git : //example.org/path/to/repo.git&quot;와 같은 URL은 푸시를 위해 &quot;ssh : //example.org/path/to/repo.git&quot;로 다시 쓰여지지만 풀은 여전히 원래 URL.</target>
        </trans-unit>
        <trans-unit id="96a7d2b2a7356a40bc207f3d1e0038c9f743ef8f" translate="yes" xml:space="preserve">
          <source>a URL like &quot;work:repo.git&quot; or like &quot;host.xz:/path/to/repo.git&quot; will be rewritten in any context that takes a URL to be &quot;git://git.host.xz/repo.git&quot;.</source>
          <target state="translated">&quot;work : repo.git&quot;또는 &quot;host.xz : /path/to/repo.git&quot;과 같은 URL은 URL이 &quot;git : //git.host.xz/repo 인 모든 컨텍스트에서 다시 작성됩니다. .git &quot;.</target>
        </trans-unit>
        <trans-unit id="da90a472a42edab28f6103dd507b377a59e39919" translate="yes" xml:space="preserve">
          <source>a colon.</source>
          <target state="translated">결장.</target>
        </trans-unit>
        <trans-unit id="07112c294a121f7cc6ed6654ce50e53f206b098f" translate="yes" xml:space="preserve">
          <source>a comment describing this commit.</source>
          <target state="translated">이 커밋을 설명하는 주석.</target>
        </trans-unit>
        <trans-unit id="6fd45c543fb44740f3ae2218676d1d2f809372d6" translate="yes" xml:space="preserve">
          <source>a committer: The name of the person who actually created the commit, with the date it was done. This may be different from the author, for example, if the author was someone who wrote a patch and emailed it to the person who used it to create the commit.</source>
          <target state="translated">커미터 : 커밋을 실제로 만든 사람의 이름과 날짜를 포함합니다. 예를 들어, 작성자가 패치를 작성하여 커밋을 생성하는 데 사용했던 사람에게 전자 메일을 보낸 사람인 경우에는 작성자와 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="475363380919fa9dad3daaa5151af4a7ecf7fe63" translate="yes" xml:space="preserve">
          <source>a file called &lt;code&gt;HEAD&lt;/code&gt;, that has &lt;code&gt;ref: refs/heads/master&lt;/code&gt; in it. This is similar to a symbolic link and points at &lt;code&gt;refs/heads/master&lt;/code&gt; relative to the &lt;code&gt;HEAD&lt;/code&gt; file.</source>
          <target state="translated">라는 파일 &lt;code&gt;HEAD&lt;/code&gt; 가, &lt;code&gt;ref: refs/heads/master&lt;/code&gt; 그것입니다. 이것은 심볼릭 링크와 유사 하며 &lt;code&gt;HEAD&lt;/code&gt; 파일을 기준으로 &lt;code&gt;refs/heads/master&lt;/code&gt; 를 가리 킵니다 .</target>
        </trans-unit>
        <trans-unit id="956892125b0edbb5f2b693d0431acccf4dd5c1cd" translate="yes" xml:space="preserve">
          <source>a file in the &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/branches&lt;/code&gt; 디렉토리 의 파일 .</target>
        </trans-unit>
        <trans-unit id="7a8f92bb4f6fe9e686ed78d483dc8804c1d0837c" translate="yes" xml:space="preserve">
          <source>a file in the &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; directory, or</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; 디렉토리 의 파일 또는</target>
        </trans-unit>
        <trans-unit id="6fb331171394d95fbb7a35c4b995f2a83f23618c" translate="yes" xml:space="preserve">
          <source>a file that has &lt;code&gt;any&lt;/code&gt; difference what-so-ever in the three trees will stay as separate entries in the index. It&amp;rsquo;s up to &quot;porcelain policy&quot; to determine how to remove the non-0 stages, and insert a merged version.</source>
          <target state="translated">이 파일에 &lt;code&gt;any&lt;/code&gt; 세 개의 나무에서 무엇을 그리 적 차이는 인덱스에 별도의 항목으로 유지됩니다. 0이 아닌 단계를 제거하고 병합 된 버전을 삽입하는 방법은 &quot;도자기 정책&quot;에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcb1d336b0be584d8054e8f7d63b3480aea0ee1d" translate="yes" xml:space="preserve">
          <source>a function called &lt;code&gt;cmd_&amp;lt;bla&amp;gt;&lt;/code&gt;, typically defined in &lt;code&gt;builtin/&amp;lt;bla.c&amp;gt;&lt;/code&gt; (note that older versions of Git used to have it in &lt;code&gt;builtin-&amp;lt;bla&amp;gt;.c&lt;/code&gt; instead), and declared in &lt;code&gt;builtin.h&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cmd_&amp;lt;bla&amp;gt;&lt;/code&gt; 라는 함수는 일반적으로 &lt;code&gt;builtin/&amp;lt;bla.c&amp;gt;&lt;/code&gt; 에 정의되어 있으며 (이전 버전의 Git은 대신 &lt;code&gt;builtin-&amp;lt;bla&amp;gt;.c&lt;/code&gt; 에 사용 했었다는 점에 유의하십시오 ) &lt;code&gt;builtin.h&lt;/code&gt; 에 선언되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d20b77e1575c57d2803f17741070661ffe1f7923" translate="yes" xml:space="preserve">
          <source>a line that begins with &quot;Index: &quot;</source>
          <target state="translated">&quot;Index :&quot;로 시작하는 줄</target>
        </trans-unit>
        <trans-unit id="eac485dbe3dc8258452b85ab1fdc03917425590f" translate="yes" xml:space="preserve">
          <source>a line that begins with &quot;diff -&quot;, or</source>
          <target state="translated">&quot;diff-&quot;로 시작하는 줄 또는</target>
        </trans-unit>
        <trans-unit id="8cb077e79c6b205418cec26b6f4930fe1ae56b3b" translate="yes" xml:space="preserve">
          <source>a newline.</source>
          <target state="translated">개행.</target>
        </trans-unit>
        <trans-unit id="678e3fa85625ddb634df3223f890cd55081ea7cd" translate="yes" xml:space="preserve">
          <source>a raw &lt;code&gt;%&lt;/code&gt;</source>
          <target state="translated">생 &lt;code&gt;%&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6a839de3aabe2c207992e1add851477714b9c5e" translate="yes" xml:space="preserve">
          <source>a remote in the Git configuration file: &lt;code&gt;$GIT_DIR/config&lt;/code&gt;,</source>
          <target state="translated">Git 구성 파일의 원격 : &lt;code&gt;$GIT_DIR/config&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="f9af7071efb1bd7dd22ebf85f05d8810442b8586" translate="yes" xml:space="preserve">
          <source>a space between time and time zone</source>
          <target state="translated">시간대와 시간대</target>
        </trans-unit>
        <trans-unit id="65b604e2f985f7317d6866f6730d409a3832783e" translate="yes" xml:space="preserve">
          <source>a space instead of the &lt;code&gt;T&lt;/code&gt; date/time delimiter</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 날짜 / 시간 분리 문자 대신 공백</target>
        </trans-unit>
        <trans-unit id="5bc00ebd3440c4f401b07128f1c136e115562dd8" translate="yes" xml:space="preserve">
          <source>a space.</source>
          <target state="translated">우주.</target>
        </trans-unit>
        <trans-unit id="97a7ee5f8a960df69981e9527fa176cfdf9705cf" translate="yes" xml:space="preserve">
          <source>a subdirectory called &lt;code&gt;objects&lt;/code&gt;, which will contain all the objects of your project. You should never have any real reason to look at the objects directly, but you might want to know that these objects are what contains all the real &lt;code&gt;data&lt;/code&gt; in your repository.</source>
          <target state="translated">&lt;code&gt;objects&lt;/code&gt; 라는 서브 디렉토리 . 여기에는 프로젝트의 모든 오브젝트가 포함됩니다. 객체를 직접보아야 할 실질적인 이유가 없어야하지만 이러한 객체가 리포지토리의 모든 실제 &lt;code&gt;data&lt;/code&gt; 를 포함하고 있다는 것을 알고 싶을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="045a27e5aab449465c7a517674ebf98a06438921" translate="yes" xml:space="preserve">
          <source>a subdirectory called &lt;code&gt;refs&lt;/code&gt;, which contains references to objects.</source>
          <target state="translated">객체에 대한 참조를 포함하는 &lt;code&gt;refs&lt;/code&gt; 라는 서브 디렉토리</target>
        </trans-unit>
        <trans-unit id="03097f133fc01ec710880af30fddc9a8cd7c34db" translate="yes" xml:space="preserve">
          <source>a tab or a NUL when &lt;code&gt;-z&lt;/code&gt; option is used.</source>
          <target state="translated">&lt;code&gt;-z&lt;/code&gt; 옵션을 사용하는 경우 탭 또는 NUL</target>
        </trans-unit>
        <trans-unit id="9346da07fb77dd97b82dc62a47eb3edc36d2b7a0" translate="yes" xml:space="preserve">
          <source>a tab or a NUL when &lt;code&gt;-z&lt;/code&gt; option is used; only exists for C or R.</source>
          <target state="translated">&lt;code&gt;-z&lt;/code&gt; 옵션이 사용되는 경우 탭 또는 NUL ; C 또는 R에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="c40734bc76bdc997f13a3bade66db88cc0dc137e" translate="yes" xml:space="preserve">
          <source>a tab;</source>
          <target state="translated">탭;</target>
        </trans-unit>
        <trans-unit id="19150edbe2f84d3c01f8f24ddf7de6b06a212def" translate="yes" xml:space="preserve">
          <source>a tree: The SHA-1 name of a tree object (as defined below), representing the contents of a directory at a certain point in time.</source>
          <target state="translated">트리 : 특정 시점의 디렉토리 내용을 나타내는 트리 객체 (아래에 정의 된대로)의 SHA-1 이름.</target>
        </trans-unit>
        <trans-unit id="013edfaa8480f23dc64a9a565714902a0f70e19a" translate="yes" xml:space="preserve">
          <source>a valid head &lt;code&gt;name&lt;/code&gt; (i.e. a &lt;code&gt;refs/heads/&amp;lt;head&amp;gt;&lt;/code&gt; reference).</source>
          <target state="translated">유효한 헤드 &lt;code&gt;name&lt;/code&gt; (예 : 참조 &lt;code&gt;refs/heads/&amp;lt;head&amp;gt;&lt;/code&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="c3796b26d9f35f82d5c7ba0548ce633809586698" translate="yes" xml:space="preserve">
          <source>a valid tag &lt;code&gt;name&lt;/code&gt; (i.e. a &lt;code&gt;refs/tags/&amp;lt;tag&amp;gt;&lt;/code&gt; reference).</source>
          <target state="translated">유효한 태그 &lt;code&gt;name&lt;/code&gt; (예 : &lt;code&gt;refs/tags/&amp;lt;tag&amp;gt;&lt;/code&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="fdbf716e8cd4fd3ff778984618bbe33ffeee814c" translate="yes" xml:space="preserve">
          <source>a) are ancestor of the &quot;bad&quot; commit (including the &quot;bad&quot; commit itself), b) are not ancestor of a &quot;good&quot; commit (excluding the &quot;good&quot; commits).</source>
          <target state="translated">a) &quot;나쁜&quot;커밋의 조상 ( &quot;나쁜&quot;커밋 자체 포함) b) &quot;좋은&quot;커밋의 조상 ( &quot;좋은&quot;커밋 제외)</target>
        </trans-unit>
        <trans-unit id="8682c02d1bc4bfce128a794497013605d86c32b6" translate="yes" xml:space="preserve">
          <source>a) regular use</source>
          <target state="translated">a) 정기적 인 사용</target>
        </trans-unit>
        <trans-unit id="4ff2759bc14568ced83be0be38a4abafea668a32" translate="yes" xml:space="preserve">
          <source>abbreviated commit hash</source>
          <target state="translated">약식 커밋 해시</target>
        </trans-unit>
        <trans-unit id="83baab4c4f5445b3450e34e24f8066fea1ac11f2" translate="yes" xml:space="preserve">
          <source>abbreviated parent hashes</source>
          <target state="translated">약식 부모 해시</target>
        </trans-unit>
        <trans-unit id="33579b1cb5338205dc784843012a5c0a9e8cacae" translate="yes" xml:space="preserve">
          <source>abbreviated tree hash</source>
          <target state="translated">약식 트리 해시</target>
        </trans-unit>
        <trans-unit id="b61646f016483b318b49a910668a966b6ce09ede" translate="yes" xml:space="preserve">
          <source>abort</source>
          <target state="translated">abort</target>
        </trans-unit>
        <trans-unit id="832e60dfe198126ed45442b9d54f0a366515eefc" translate="yes" xml:space="preserve">
          <source>absorbgitdirs</source>
          <target state="translated">absorbgitdirs</target>
        </trans-unit>
        <trans-unit id="f412f21dd1d844e9ed4c1cbd73b06dc725c5d8bd" translate="yes" xml:space="preserve">
          <source>access method (one of &quot;ext&quot; or &quot;pserver&quot;)</source>
          <target state="translated">액세스 방법 ( &quot;ext&quot;또는 &quot;pserver&quot;중 하나)</target>
        </trans-unit>
        <trans-unit id="34eb4c4ef005207e8b8f916b9f1fffacccd6945e" translate="yes" xml:space="preserve">
          <source>action</source>
          <target state="translated">action</target>
        </trans-unit>
        <trans-unit id="326b426f9ac7a96ed6baf62f8838565416d27df8" translate="yes" xml:space="preserve">
          <source>actions</source>
          <target state="translated">actions</target>
        </trans-unit>
        <trans-unit id="58d1bbce297de3c304a9fefc3b483181872a5c6b" translate="yes" xml:space="preserve">
          <source>add</source>
          <target state="translated">add</target>
        </trans-unit>
        <trans-unit id="6d8bcdb6bdc1c6a236c5092142b208eb67008cee" translate="yes" xml:space="preserve">
          <source>add &amp;lt;path&amp;gt; [&amp;lt;commit-ish&amp;gt;]</source>
          <target state="translated">&amp;lt;path&amp;gt; [&amp;lt;commit-ish&amp;gt;] 추가</target>
        </trans-unit>
        <trans-unit id="89052c7d90a34c914815c621a3c8abaf890dfcb5" translate="yes" xml:space="preserve">
          <source>add [-b &amp;lt;branch&amp;gt;] [-f|--force] [--name &amp;lt;name&amp;gt;] [--reference &amp;lt;repository&amp;gt;] [--depth &amp;lt;depth&amp;gt;] [--] &amp;lt;repository&amp;gt; [&amp;lt;path&amp;gt;]</source>
          <target state="translated">추가 [-b &amp;lt;branch&amp;gt;] [-f | --force] [--name &amp;lt;name&amp;gt;] [--reference &amp;lt;repository&amp;gt;] [--depth &amp;lt;depth&amp;gt;] [-] &amp;lt;repository&amp;gt; [&amp;lt;path &amp;gt;]</target>
        </trans-unit>
        <trans-unit id="96b545065b00a5b7501087e2c1e93926449febd5" translate="yes" xml:space="preserve">
          <source>add a missing &lt;code&gt;\n&lt;/code&gt; to the last line if necessary.</source>
          <target state="translated">필요한 경우 누락 된 &lt;code&gt;\n&lt;/code&gt; 을 마지막 줄에 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="90bc127779a3e8fd8565532d33e4a134cd45f11d" translate="yes" xml:space="preserve">
          <source>add everything under the current directory.</source>
          <target state="translated">현재 디렉토리 아래에 모든 것을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="cb81f0f2d76a3c8759a19442b315f5c3a72e8b01" translate="yes" xml:space="preserve">
          <source>add untracked</source>
          <target state="translated">추적되지 않은 추가</target>
        </trans-unit>
        <trans-unit id="c22e3f3bd42e15a0bc002a5cba9cb2e9cb547df3" translate="yes" xml:space="preserve">
          <source>add.ignore-errors (deprecated)</source>
          <target state="translated">add.ignore-errors (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="0d6211d85b6c5ebebd00bc700587b97d87d96f79" translate="yes" xml:space="preserve">
          <source>add.ignoreErrors</source>
          <target state="translated">add.ignoreErrors</target>
        </trans-unit>
        <trans-unit id="47d07ea3a984d5f17b8a52280b424c7e874d91e2" translate="yes" xml:space="preserve">
          <source>add.interactive.useBuiltin</source>
          <target state="translated">add.interactive.useBuiltin</target>
        </trans-unit>
        <trans-unit id="e441bfa1c3e8c860d35d02080c0d58234a3dc31b" translate="yes" xml:space="preserve">
          <source>addEmbeddedRepo</source>
          <target state="translated">addEmbeddedRepo</target>
        </trans-unit>
        <trans-unit id="5fba0af68b4dc6017c79ff69ba4b3844f76b2dc5" translate="yes" xml:space="preserve">
          <source>addEmptyPathspec</source>
          <target state="translated">addEmptyPathspec</target>
        </trans-unit>
        <trans-unit id="a9b80c1de3c9ac007c7c119f277608c2e2a51269" translate="yes" xml:space="preserve">
          <source>addIgnoredFile</source>
          <target state="translated">addIgnoredFile</target>
        </trans-unit>
        <trans-unit id="ceb99972d01848a4af9e45ab5cd53f0d9ea700b4" translate="yes" xml:space="preserve">
          <source>added content</source>
          <target state="translated">추가 된 내용</target>
        </trans-unit>
        <trans-unit id="782f82176de20dd76d4373d2acfc3406073964ff" translate="yes" xml:space="preserve">
          <source>adding context (&quot; &quot;) or removal (&quot;-&quot;) lines</source>
          <target state="translated">컨텍스트 ( &quot;&quot;) 또는 제거 ( &quot;-&quot;) 행 추가</target>
        </trans-unit>
        <trans-unit id="39de4cfc4c6e6827c5f11475b89460e1b545a7f9" translate="yes" xml:space="preserve">
          <source>adds the following to &lt;code&gt;.git/config&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;.git/config&lt;/code&gt; 에 다음을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="f6acb502d3f3dcf967568ec1f1f05756c7001015" translate="yes" xml:space="preserve">
          <source>advice.*</source>
          <target state="translated">advice.*</target>
        </trans-unit>
        <trans-unit id="0608c4054662dd902e1314f7e450e3eaa81c1143" translate="yes" xml:space="preserve">
          <source>agent</source>
          <target state="translated">agent</target>
        </trans-unit>
        <trans-unit id="dc642557f3a1ed15b666c3bf8c010e9d1bceffe0" translate="yes" xml:space="preserve">
          <source>alias.*</source>
          <target state="translated">alias.*</target>
        </trans-unit>
        <trans-unit id="16f3bac085c702b24dd56dd8fdf474c5d21e6639" translate="yes" xml:space="preserve">
          <source>alice and cindy can push into master, only bob can push into doc-update. david is the release manager and is the only person who can create and push version tags.</source>
          <target state="translated">alice와 cindy는 마스터로 푸시 할 수 있으며 bob 만 doc-update로 푸시 할 수 있습니다. david는 릴리스 관리자이며 버전 태그를 작성하고 푸시 할 수있는 유일한 사람입니다.</target>
        </trans-unit>
        <trans-unit id="ae21c64a87f6bb0b8e16e55c48be4cc638d7bd3f" translate="yes" xml:space="preserve">
          <source>align</source>
          <target state="translated">align</target>
        </trans-unit>
        <trans-unit id="d87c448044defb778f33158d8ccf94a20531d600" translate="yes" xml:space="preserve">
          <source>all</source>
          <target state="translated">all</target>
        </trans-unit>
        <trans-unit id="29702e41afdcf565d852a6355913f10360a2f8b0" translate="yes" xml:space="preserve">
          <source>all parent object ids</source>
          <target state="translated">모든 부모 객체 ID</target>
        </trans-unit>
        <trans-unit id="6664a4a284b9aeecc837369fce6272fe3547f795" translate="yes" xml:space="preserve">
          <source>allow-indentation-change</source>
          <target state="translated">allow-indentation-change</target>
        </trans-unit>
        <trans-unit id="890c8ad25c4c255f4dda7bba71ccde4b6eb54f1a" translate="yes" xml:space="preserve">
          <source>allows you to browse any commits from the last 2 weeks of commits that modified files under the &quot;drivers&quot; directory. (Note: you can adjust gitk&amp;rsquo;s fonts by holding down the control key while pressing &quot;-&quot; or &quot;+&quot;.)</source>
          <target state="translated">&quot;drivers&quot;디렉토리에있는 파일을 수정 한 지난 2주의 커밋에서 커밋을 찾아 볼 수 있습니다. (참고 : &quot;-&quot;또는 &quot;+&quot;를 누른 상태에서 제어 키를 누르면 gitk의 글꼴을 조정할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="8733169fb7d8912aa579031eed0a4b26ef5718fe" translate="yes" xml:space="preserve">
          <source>alternate object database</source>
          <target state="translated">대체 객체 데이터베이스</target>
        </trans-unit>
        <trans-unit id="385d97ddc2cf0f165b1e517e2de9a74c662d0d92" translate="yes" xml:space="preserve">
          <source>alternate: absolute path of alternate object databases; may appear multiple times, one line per path. Note that if the path contains non-printable characters, it may be surrounded by double-quotes and contain C-style backslashed escape sequences.</source>
          <target state="translated">대체 : 대체 객체 데이터베이스의 절대 경로. 경로당 한 줄에 여러 번 나타날 수 있습니다. 경로에 인쇄 할 수없는 문자가 포함 된 경우 큰 따옴표로 묶고 C 스타일 백 슬래시 이스케이프 시퀀스를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="459a9aeba984b09598ccfb2133b8ae65d179153d" translate="yes" xml:space="preserve">
          <source>although the full, 40-character SHA-1s would be supplied. If the foreign ref does not yet exist the &lt;code&gt;&amp;lt;remote SHA-1&amp;gt;&lt;/code&gt; will be 40 &lt;code&gt;0&lt;/code&gt;. If a ref is to be deleted, the &lt;code&gt;&amp;lt;local ref&amp;gt;&lt;/code&gt; will be supplied as &lt;code&gt;(delete)&lt;/code&gt; and the &lt;code&gt;&amp;lt;local
SHA-1&amp;gt;&lt;/code&gt; will be 40 &lt;code&gt;0&lt;/code&gt;. If the local commit was specified by something other than a name which could be expanded (such as &lt;code&gt;HEAD~&lt;/code&gt;, or a SHA-1) it will be supplied as it was originally given.</source>
          <target state="translated">전체 40 자 SHA-1이 제공되지만. 외부 참조가 아직 없으면 &lt;code&gt;&amp;lt;remote SHA-1&amp;gt;&lt;/code&gt; 은 40 &lt;code&gt;0&lt;/code&gt; 입니다. 의 Ref 삭제할 경우 &lt;code&gt;&amp;lt;local ref&amp;gt;&lt;/code&gt; 로서 공급된다 &lt;code&gt;(delete)&lt;/code&gt; 하고, &lt;code&gt;&amp;lt;local SHA-1&amp;gt;&lt;/code&gt; 40 것이다 &lt;code&gt;0&lt;/code&gt; . 로컬 커밋이 확장 될 수있는 이름 (예 : &lt;code&gt;HEAD~&lt;/code&gt; 또는 SHA-1) 이외의 이름으로 지정된 경우 원래 커밋 된대로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b16bb5afab4c1802eaeada40ac59f4ec78c01be8" translate="yes" xml:space="preserve">
          <source>always show in columns</source>
          <target state="translated">항상 열에 표시</target>
        </trans-unit>
        <trans-unit id="b0c4ba6a734338f8b0a5e21fcbb05d3afcd198af" translate="yes" xml:space="preserve">
          <source>always shows the difference between the HEAD and the index file&amp;mdash;​this is what you&amp;rsquo;d commit if you created the commit now&amp;mdash;​and that</source>
          <target state="translated">항상 HEAD와 인덱스 파일의 차이점을 보여줍니다. 지금 커밋을 만든 경우 커밋 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="96e8155732e8324ae26f64d4516eb6fe696ac84f" translate="yes" xml:space="preserve">
          <source>am</source>
          <target state="translated">am</target>
        </trans-unit>
        <trans-unit id="400226a3b8758d7d662c424a478d16cceecd29ed" translate="yes" xml:space="preserve">
          <source>am.keepcr</source>
          <target state="translated">am.keepcr</target>
        </trans-unit>
        <trans-unit id="80b11664f9cdc0c4da5b2cf9cbae91e78f24cb5f" translate="yes" xml:space="preserve">
          <source>am.threeWay</source>
          <target state="translated">am.threeWay</target>
        </trans-unit>
        <trans-unit id="d9de89ed653daadc282d17fa341547ccd80f5e0c" translate="yes" xml:space="preserve">
          <source>amWorkDir</source>
          <target state="translated">amWorkDir</target>
        </trans-unit>
        <trans-unit id="b1cc99b811681fb579eeabe4a14a5e1ec1bab455" translate="yes" xml:space="preserve">
          <source>amend the previous commit, adding all your new changes, using your original message.</source>
          <target state="translated">원래 메시지를 사용하여 모든 새 변경 사항을 추가하여 이전 커미트를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="461152b367e8ab9740fb2e9ee2da4d7175e9e2a2" translate="yes" xml:space="preserve">
          <source>an LF or a NUL when &lt;code&gt;-z&lt;/code&gt; option is used, to terminate the record.</source>
          <target state="translated">&lt;code&gt;-z&lt;/code&gt; 옵션을 사용 하는 경우 LF 또는 NUL을 사용하여 레코드를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="75eada615f3da2b986734d58bb672366de760679" translate="yes" xml:space="preserve">
          <source>an author: The name of the person responsible for this change, together with its date.</source>
          <target state="translated">저자 :이 변경을 담당하는 사람의 이름과 날짜.</target>
        </trans-unit>
        <trans-unit id="b441fe44ea3ab3bff759abb792c8a7f4c7974b0c" translate="yes" xml:space="preserve">
          <source>an entry in &lt;code&gt;BUILTIN_OBJECTS&lt;/code&gt; in the &lt;code&gt;Makefile&lt;/code&gt;.</source>
          <target state="translated">의 항목 &lt;code&gt;BUILTIN_OBJECTS&lt;/code&gt; 에서 &lt;code&gt;Makefile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d25597e1ded62863dd59e418a49b42af285a609" translate="yes" xml:space="preserve">
          <source>an entry in the &lt;code&gt;commands[]&lt;/code&gt; array in &lt;code&gt;git.c&lt;/code&gt;, and</source>
          <target state="translated">에 진입 &lt;code&gt;commands[]&lt;/code&gt; 의 배열 &lt;code&gt;git.c&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="5037f82b8aa7002eda9aed7d8c0898525bc2f00d" translate="yes" xml:space="preserve">
          <source>and Git will continue applying the rest of the patches.</source>
          <target state="translated">Git은 나머지 패치를 계속 적용합니다.</target>
        </trans-unit>
        <trans-unit id="b3b2e45f7b37ac14dc28b61e29aee3c419229fda" translate="yes" xml:space="preserve">
          <source>and Git will create the commit for you and continue applying the remaining patches from the mailbox.</source>
          <target state="translated">Git은 커밋을 만들고 메일 함의 나머지 패치를 계속 적용합니다.</target>
        </trans-unit>
        <trans-unit id="7067f391e9f25da3da4a562c780b468101adb659" translate="yes" xml:space="preserve">
          <source>and Git will prompt you for a commit message and then create the new commit. Check to make sure it looks like what you expected with</source>
          <target state="translated">Git은 커밋 메시지를 물어보고 새로운 커밋을 만듭니다. 예상대로 보이는지 확인하십시오</target>
        </trans-unit>
        <trans-unit id="11bda7867b55ea900931dbe2ab8c87a36a0443d9" translate="yes" xml:space="preserve">
          <source>and bundle topic branches still cooking.</source>
          <target state="translated">그리고 여전히 요리하는 주제 분기를 묶습니다.</target>
        </trans-unit>
        <trans-unit id="06675e26cc6f5bedf7b0e9b9d71e33fb64fa4ef8" translate="yes" xml:space="preserve">
          <source>and email them.</source>
          <target state="translated">이메일로 보내주세요.</target>
        </trans-unit>
        <trans-unit id="d5d63b233efdc161b2104f0e091d210beeb2fe60" translate="yes" xml:space="preserve">
          <source>and hack away. The equivalent of &lt;code&gt;cvs update&lt;/code&gt; is</source>
          <target state="translated">해킹. 의 등가 &lt;code&gt;cvs update&lt;/code&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="d4b59596148297f0688711ac4f92721dbc18215b" translate="yes" xml:space="preserve">
          <source>and if it detects that the file &quot;file0&quot; is completely rewritten, it changes it to:</source>
          <target state="translated">&quot;file0&quot;파일이 완전히 다시 작성된 것을 발견하면 다음과 같이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="e1426704be98b9dd3d938c5a6a31b3fe4ee9a995" translate="yes" xml:space="preserve">
          <source>and in fact a lot of the common Git command combinations can be scripted with the &lt;code&gt;git xyz&lt;/code&gt; interfaces. You can learn things by just looking at what the various git scripts do. For example, &lt;code&gt;git reset&lt;/code&gt; used to be the above two lines implemented in &lt;code&gt;git reset&lt;/code&gt;, but some things like &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt; are slightly more complex scripts around the basic Git commands.</source>
          <target state="translated">사실 많은 공통 Git 명령 조합을 &lt;code&gt;git xyz&lt;/code&gt; 인터페이스 로 스크립팅 할 수 있습니다 . 다양한 git 스크립트가하는 일만 살펴보면 사물을 배울 수 있습니다. 예를 들어, &lt;code&gt;git reset&lt;/code&gt; 은 &lt;code&gt;git reset&lt;/code&gt; 에서 구현 된 위의 두 줄 이었지만 &lt;code&gt;git status&lt;/code&gt; 및 &lt;code&gt;git commit&lt;/code&gt; 과 같은 일부 는 기본 Git 명령 주위에 약간 더 복잡한 스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="c2f880dab39040d1bcbb6d73323cfccc9f1141f6" translate="yes" xml:space="preserve">
          <source>and it is assumed unchanged.</source>
          <target state="translated">그리고 변경되지 않은 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6fdb49363e42ba495e98dac786aceef7ea588734" translate="yes" xml:space="preserve">
          <source>and it will be gone. There&amp;rsquo;s no external repository, and there&amp;rsquo;s no history outside the project you created.</source>
          <target state="translated">그리고 사라질 것입니다. 외부 리포지토리가 없으며 생성 한 프로젝트 외부에 기록이 없습니다.</target>
        </trans-unit>
        <trans-unit id="14be792a7fbd836c220980afe820c5835c201a25" translate="yes" xml:space="preserve">
          <source>and it would create the new branch &lt;code&gt;mybranch&lt;/code&gt; at the earlier commit, and check out the state at that time.</source>
          <target state="translated">이전 커밋에서 새 브랜치 &lt;code&gt;mybranch&lt;/code&gt; 를 만들고 그 당시의 상태를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="fb7e74a8bf932246eae1a7c59b5aab5d50647a84" translate="yes" xml:space="preserve">
          <source>and its path_info based equivalent</source>
          <target state="translated">그리고 그것의 path_info 기반의</target>
        </trans-unit>
        <trans-unit id="a6415488fda4ace1ca3739dceaaf3db60a5dafcb" translate="yes" xml:space="preserve">
          <source>and just looked for the sha of the missing object (4b9458b) in that whole thing. It&amp;rsquo;s up to you&amp;mdash;​Git does &lt;strong&gt;have&lt;/strong&gt; a lot of information, it is just missing one particular blob version.</source>
          <target state="translated">그리고 그 모든 것에서 빠진 물건의 샤 (4b9458b)를 찾아 보았습니다. 그것은 않는 당신이 - 힘내에게 달려 &lt;strong&gt;있습니다&lt;/strong&gt; 그것은 단지 하나의 특정 덩어리 버전을 누락 많은 정보를.</target>
        </trans-unit>
        <trans-unit id="eb603cb6e80c68fe39b18e84f04c311f5ab01061" translate="yes" xml:space="preserve">
          <source>and make the shared repository writable by the group.</source>
          <target state="translated">공유 리포지토리를 그룹이 쓰기 가능하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="40981e3225f4d7efce8a1f1ac883a144a32ed884" translate="yes" xml:space="preserve">
          <source>and once you&amp;rsquo;re happy with your manual merge, just do a</source>
          <target state="translated">수동 병합에 만족하면</target>
        </trans-unit>
        <trans-unit id="f6523905096e4cb79385536bede182fe1d21d437" translate="yes" xml:space="preserve">
          <source>and optionally give a branch-name for the remote end as a second argument.</source>
          <target state="translated">선택적으로 원격 엔드의 분기 이름을 두 번째 인수로 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="1f7c0eb7c2d3e76709e99a0799e2c00adb5d4360" translate="yes" xml:space="preserve">
          <source>and running &lt;code&gt;git config section.Subsection.key value2&lt;/code&gt; will result in</source>
          <target state="translated">&lt;code&gt;git config section.Subsection.key value2&lt;/code&gt; 를 실행 하면</target>
        </trans-unit>
        <trans-unit id="b8d13d365846b56f54fcde0e313df5ef17ad9601" translate="yes" xml:space="preserve">
          <source>and see two files:</source>
          <target state="translated">두 파일을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1846440a645e968f28127df0e1b2bcc1010c9293" translate="yes" xml:space="preserve">
          <source>and that is what higher level &lt;code&gt;git merge -s resolve&lt;/code&gt; is implemented with.</source>
          <target state="translated">이것이 상위 레벨 &lt;code&gt;git merge -s resolve&lt;/code&gt; 가 구현되는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dbbcc5be724df383b84cd8c32e02ab45353e6975" translate="yes" xml:space="preserve">
          <source>and the &quot;parent&quot; object refers to the previous commit:</source>
          <target state="translated">&quot;부모&quot;개체는 이전 커밋을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4982e2ffe4444f7d8ccaa2ccbbc307cc4fa3f8c7" translate="yes" xml:space="preserve">
          <source>and the contents of the deleted file fileX is similar enough to the contents of the created file file0, then rename detection merges these filepairs and creates:</source>
          <target state="translated">삭제 된 파일 fileX의 내용은 작성된 파일 file0의 내용과 충분히 유사하며 이름 바꾸기 감지는 이러한 파일 쌍을 병합하여 다음을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="3cf2f14796ecd3906febf042b64b0f6c0a0234bc" translate="yes" xml:space="preserve">
          <source>and the contents of these files is just the compressed data plus a header identifying their length and their type. The type is either a blob, a tree, a commit, or a tag.</source>
          <target state="translated">이 파일의 내용은 압축 된 데이터와 길이 및 유형을 식별하는 헤더입니다. 유형은 BLOB, 트리, 커밋 또는 태그입니다.</target>
        </trans-unit>
        <trans-unit id="97b7ea8f565fdb4b8f72207a4543ec3a6beb2426" translate="yes" xml:space="preserve">
          <source>and the new object name to be stored in the ref.</source>
          <target state="translated">ref에 저장 될 새로운 객체 이름.</target>
        </trans-unit>
        <trans-unit id="06596f8fbe14d561db35acf97529690afeae6531" translate="yes" xml:space="preserve">
          <source>and the result of &lt;code&gt;git merge-base A M&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;. Commit &lt;code&gt;2&lt;/code&gt; is also a common ancestor between &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;M&lt;/code&gt;, but &lt;code&gt;1&lt;/code&gt; is a better common ancestor, because &lt;code&gt;2&lt;/code&gt; is an ancestor of &lt;code&gt;1&lt;/code&gt;. Hence, &lt;code&gt;2&lt;/code&gt; is not a merge base.</source>
          <target state="translated">그리고 &lt;code&gt;git merge-base A M&lt;/code&gt; 의 결과 는 &lt;code&gt;1&lt;/code&gt; 입니다. 커밋 &lt;code&gt;2&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;M&lt;/code&gt; 사이 의 공통 조상 이지만 &lt;code&gt;2&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 의 조상 이므로 &lt;code&gt;1&lt;/code&gt; 은 더 나은 공통 조상 입니다. 따라서 &lt;code&gt;2&lt;/code&gt; 는 병합 기반이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="bf29b3f3be3e9d8f538aa9b7974f9c3a714fd3f2" translate="yes" xml:space="preserve">
          <source>and then annotate the change between the commit and its parents, using &lt;code&gt;commit^!&lt;/code&gt; notation:</source>
          <target state="translated">그리고 &lt;code&gt;commit^!&lt;/code&gt; 사용하여 커밋 과 부모 사이의 변경에 주석을 추가하십시오 . 표기법:</target>
        </trans-unit>
        <trans-unit id="3d8806f072cf60f02c7512a460d821442ce16fa0" translate="yes" xml:space="preserve">
          <source>and then giving the reason for the commit on stdin (either through redirection from a pipe or file, or by just typing it at the tty).</source>
          <target state="translated">stdin에서 커밋 이유를 제공합니다 (파이프 또는 파일에서 리디렉션하거나 tty에 입력하여).</target>
        </trans-unit>
        <trans-unit id="2fd91a322e9e060ddc98865e40de279b845a572c" translate="yes" xml:space="preserve">
          <source>and then he just cut-and-pastes the output commands after verifying that they look OK.</source>
          <target state="translated">그런 다음 출력 명령이 제대로 표시되는지 확인한 후 잘라 내기 및 붙여 넣기를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b658ed87bd1868d8fc441785cf7c93c3c281001b" translate="yes" xml:space="preserve">
          <source>and then moving BFC after BBC and squashing it.</source>
          <target state="translated">BBC 후 BFC를 옮기고 스쿼시했습니다.</target>
        </trans-unit>
        <trans-unit id="339c37a1cbc67af9c8927014dc829b0049bb4b31" translate="yes" xml:space="preserve">
          <source>and then untar the new code in the working tree. Alternately you could &lt;code&gt;rsync&lt;/code&gt; the changes into the working tree.</source>
          <target state="translated">그런 다음 작업 트리에서 새 코드를 풉니 다. 또는 변경 사항을 작업 트리로 재 &lt;code&gt;rsync&lt;/code&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="617666725e1b9f6239b44390652378dd9926ce18" translate="yes" xml:space="preserve">
          <source>and these are evaluated in this order.</source>
          <target state="translated">이것들은이 순서대로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="9adeb030984d30c37dccabf36290b3a5065c7248" translate="yes" xml:space="preserve">
          <source>and they&amp;rsquo;ll be gone. (You should only run &lt;code&gt;git prune&lt;/code&gt; on a quiescent repository&amp;mdash;​it&amp;rsquo;s kind of like doing a filesystem fsck recovery: you don&amp;rsquo;t want to do that while the filesystem is mounted. &lt;code&gt;git prune&lt;/code&gt; is designed not to cause any harm in such cases of concurrent accesses to a repository but you might receive confusing or scary messages.)</source>
          <target state="translated">그리고 그들은 사라질 것이다. (당신은 실행해야 &lt;code&gt;git prune&lt;/code&gt; 하며, 대기가이 종류의 파일 시스템 fsck를 복구하고 등의 repository-에 :. 당신은 파일 시스템이 장착되는 동안 그렇게하고 싶지 않아 &lt;code&gt;git prune&lt;/code&gt; 이러한 경우에 어떤 해를 입힐하지 않도록 설계한다 저장소에 동시에 액세스하지만 혼란 스럽거나 무서운 메시지가 표시 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="cd197c11bb84be1a5bb09ba9b42e3b50427dcfec" translate="yes" xml:space="preserve">
          <source>and this will just output the name of the resulting tree, in this case (if you have done exactly as I&amp;rsquo;ve described) it should be</source>
          <target state="translated">그리고 이것은 결과 트리의 이름을 출력합니다.이 경우 (내가 설명한대로 정확하게 수행 한 경우)</target>
        </trans-unit>
        <trans-unit id="b1af0fa00d023b5f61dc1f79856e5725ea01dd35" translate="yes" xml:space="preserve">
          <source>and thus it is really quite easy to parse for some line- and word-oriented parser (which should be quite natural for most scripting languages).</source>
          <target state="translated">따라서 일부 행 및 단어 지향 파서 (대부분의 스크립팅 언어에는 매우 자연스러운 것)를 파싱하는 것이 실제로 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="66cee198375e167a1653a383c43e2bb725e3ca7a" translate="yes" xml:space="preserve">
          <source>and use the &quot;linus&quot; keyword with &lt;code&gt;git pull&lt;/code&gt; instead of the full URL.</source>
          <target state="translated">전체 URL 대신 &lt;code&gt;git pull&lt;/code&gt; 과 함께 &quot;linus&quot;키워드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d296b286b6d11f02bc95ddc0eea6f99abc87487a" translate="yes" xml:space="preserve">
          <source>and you can now, since you told Git about the previous state of &lt;code&gt;hello&lt;/code&gt;, ask Git what has changed in the tree compared to your old index, using the &lt;code&gt;git diff-files&lt;/code&gt; command:</source>
          <target state="translated">이제 Git에게 이전 &lt;code&gt;hello&lt;/code&gt; 상태에 대해 이야기 했으므로 &lt;code&gt;git diff-files&lt;/code&gt; 명령을 사용하여 Git 에게 기존 인덱스와 비교하여 트리에서 변경된 내용을 물어보십시오 .</target>
        </trans-unit>
        <trans-unit id="c22810b9d38d8e650ac736b5ccfb992ea7f0787f" translate="yes" xml:space="preserve">
          <source>and you have now told Git to track those two files.</source>
          <target state="translated">이제 Git에게이 두 파일을 추적하라고 지시했습니다.</target>
        </trans-unit>
        <trans-unit id="7078b738b08f05f21971cffe5f9577bcab9aaf44" translate="yes" xml:space="preserve">
          <source>and you will end up with an index with all of the &amp;lt;tree1&amp;gt; entries in &quot;stage1&quot;, all of the &amp;lt;tree2&amp;gt; entries in &quot;stage2&quot; and all of the &amp;lt;tree3&amp;gt; entries in &quot;stage3&quot;. When performing a merge of another branch into the current branch, we use the common ancestor tree as &amp;lt;tree1&amp;gt;, the current branch head as &amp;lt;tree2&amp;gt;, and the other branch head as &amp;lt;tree3&amp;gt;.</source>
          <target state="translated">&quot;stage1&quot;의 모든 &amp;lt;tree1&amp;gt; 항목, &quot;stage2&quot;의 모든 &amp;lt;tree2&amp;gt; 항목 및 &quot;stage3&quot;의 모든 &amp;lt;tree3&amp;gt; 항목이있는 색인으로 끝납니다. 다른 분기를 현재 분기로 병합 할 때 공통 조상 트리를 &amp;lt;tree1&amp;gt;로, 현재 분기 헤드를 &amp;lt;tree2&amp;gt;로, 다른 분기 헤드를 &amp;lt;tree3&amp;gt;으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="17b48e857b44d8864349e98c537796214a8362f4" translate="yes" xml:space="preserve">
          <source>and your index file will now be equivalent to the tree that you saved earlier. However, that is only your 'index' file: your working directory contents have not been modified.</source>
          <target state="translated">색인 파일은 이제 이전에 저장 한 트리와 같습니다. 그러나 이는 '인덱스'파일 일뿐입니다. 작업 디렉토리 내용은 수정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="9f158fb3a1f2423d0104e077166f5b26c8204522" translate="yes" xml:space="preserve">
          <source>and your index file will now be equivalent to the tree that you saved earlier. However, that is only your &lt;code&gt;index&lt;/code&gt; file: your working directory contents have not been modified.</source>
          <target state="translated">이제 색인 파일이 이전에 저장 한 트리와 동일합니다. 그러나 이는 &lt;code&gt;index&lt;/code&gt; 파일 일뿐입니다 . 작업 디렉토리 내용은 수정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="f7df7a4e50a38db45b495588bed9a4abd67c32fe" translate="yes" xml:space="preserve">
          <source>and your repository is good again!</source>
          <target state="translated">그리고 당신의 저장소는 다시 좋습니다!</target>
        </trans-unit>
        <trans-unit id="a5230bf3ac1fc697c044aa12dc9e2fb2c6ea3dcf" translate="yes" xml:space="preserve">
          <source>and:</source>
          <target state="translated">and:</target>
        </trans-unit>
        <trans-unit id="86c8af583af4d12d1e63765efb1b3cf2c23eb581" translate="yes" xml:space="preserve">
          <source>any external helpers are named by their protocol (e.g., use &lt;code&gt;hg&lt;/code&gt; to allow the &lt;code&gt;git-remote-hg&lt;/code&gt; helper)</source>
          <target state="translated">모든 외부 헬퍼는 프로토콜에 의해 명명됩니다 (예 : &lt;code&gt;git-remote-hg&lt;/code&gt; 헬퍼 를 허용하기 위해 &lt;code&gt;hg&lt;/code&gt; 사용 )</target>
        </trans-unit>
        <trans-unit id="8fe566b6d0fcd9f8f079b9cbd5dff1c192d0bda1" translate="yes" xml:space="preserve">
          <source>any path matches itself</source>
          <target state="translated">모든 경로가 자체와 일치</target>
        </trans-unit>
        <trans-unit id="951f5c774520ac2d893d49506bb03ddb31fc70a0" translate="yes" xml:space="preserve">
          <source>api index</source>
          <target state="translated">API 인덱스</target>
        </trans-unit>
        <trans-unit id="1ac3324252e6efe491b8f90f3588d4cd0cfc38d7" translate="yes" xml:space="preserve">
          <source>api trace2</source>
          <target state="translated">API 추적 2</target>
        </trans-unit>
        <trans-unit id="37f7547fef4fd60a7d07405e2e68e608cab796d3" translate="yes" xml:space="preserve">
          <source>api-trace2</source>
          <target state="translated">api-trace2</target>
        </trans-unit>
        <trans-unit id="db43bff34c78044870bc6b1ae2aa16902bb1bb8a" translate="yes" xml:space="preserve">
          <source>append</source>
          <target state="translated">append</target>
        </trans-unit>
        <trans-unit id="69f45da1683c501696ebfa086d25192af3807dc6" translate="yes" xml:space="preserve">
          <source>apply</source>
          <target state="translated">apply</target>
        </trans-unit>
        <trans-unit id="0c2fcb1d034ab205423e1d7ec6d29da9bf89a06b" translate="yes" xml:space="preserve">
          <source>apply [--index] [-q|--quiet] [&amp;lt;stash&amp;gt;]</source>
          <target state="translated">[--index] 적용 [-q | --quiet] [&amp;lt;stash&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="41e3e8c05614ede7d2046024aa32acb852d9e90a" translate="yes" xml:space="preserve">
          <source>apply backend: When applying a patch, ignore changes in whitespace in context lines. Unfortunately, this means that if the &quot;old&quot; lines being replaced by the patch differ only in whitespace from the existing file, you will get a merge conflict instead of a successful patch application.</source>
          <target state="translated">백엔드 적용 : 패치를 적용 할 때 컨텍스트 줄의 공백 변경 사항을 무시합니다. 불행히도 이것은 패치로 대체되는 &quot;이전&quot;줄이 기존 파일과 공백 만 다를 경우 성공적인 패치 적용 대신 병합 충돌이 발생 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="03c563ce0a13a71f68c4323807b8df4dc3dd3653" translate="yes" xml:space="preserve">
          <source>apply the change that would be shown by &lt;code&gt;git show topic^&lt;/code&gt;. In this example, the patch does not apply cleanly, so information about the conflict is written to the index and working tree and no new commit results.</source>
          <target state="translated">&lt;code&gt;git show topic^&lt;/code&gt; 될 변경 사항을 적용하십시오 . 이 예에서 패치는 완전히 적용되지 않으므로 충돌에 대한 정보는 색인 및 작업 트리에 기록되며 새로운 커밋 결과는 없습니다.</target>
        </trans-unit>
        <trans-unit id="07666f4e66bd4bf8ab64d3029da991c3b016c0f9" translate="yes" xml:space="preserve">
          <source>apply them, interactively, with your sign-offs.</source>
          <target state="translated">사인 오프와 함께 대화식으로 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="c778c31b66fdb0077c39c1643484bc80e939a6ef" translate="yes" xml:space="preserve">
          <source>apply.ignoreWhitespace</source>
          <target state="translated">apply.ignoreWhitespace</target>
        </trans-unit>
        <trans-unit id="3828727a8ed2b41298eb944c27d30c630bbaecf8" translate="yes" xml:space="preserve">
          <source>apply.whitespace</source>
          <target state="translated">apply.whitespace</target>
        </trans-unit>
        <trans-unit id="e90a34fe73108d3def10c8aa75dd41cf4b8df564" translate="yes" xml:space="preserve">
          <source>applypatch-msg</source>
          <target state="translated">applypatch-msg</target>
        </trans-unit>
        <trans-unit id="6edf8749a5d3dba0628223b6880e8abfb4f10d76" translate="yes" xml:space="preserve">
          <source>araxis</source>
          <target state="translated">araxis</target>
        </trans-unit>
        <trans-unit id="8c4f0e515d3499448f3629d033cf224f688edc27" translate="yes" xml:space="preserve">
          <source>arbitrary shell command that takes a single argument (the sha1 of the commit recorded in the superproject) is executed. When &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; is set to &lt;code&gt;!command&lt;/code&gt;, the remainder after the exclamation mark is the custom command.</source>
          <target state="translated">단일 인수 (수퍼 프로젝트에 기록 된 커밋의 sha1)를 취하는 임의의 쉘 명령이 실행됩니다. 때 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 로 설정되어 &lt;code&gt;!command&lt;/code&gt; , 느낌표 후 나머지는 사용자 정의 명령입니다.</target>
        </trans-unit>
        <trans-unit id="ebfb55f4432b592119a10592e4f26272cc72359e" translate="yes" xml:space="preserve">
          <source>archive</source>
          <target state="translated">archive</target>
        </trans-unit>
        <trans-unit id="02ffa0b70f36225abe68ab3c5392918d20ddbb24" translate="yes" xml:space="preserve">
          <source>are files GIT_EXTERNAL_DIFF can use to read the contents of &amp;lt;old|new&amp;gt;,</source>
          <target state="translated">GIT_EXTERNAL_DIFF가 &amp;lt;old | new&amp;gt;의 내용을 읽는 데 사용할 수있는 파일입니다.</target>
        </trans-unit>
        <trans-unit id="f04207e23f9202de330ee8bdec5f2a1b205be329" translate="yes" xml:space="preserve">
          <source>are incompatible with the following options:</source>
          <target state="translated">다음 옵션과 호환되지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="bf5659661ce871a6788ee6b1bec9770f7f549075" translate="yes" xml:space="preserve">
          <source>are roughly equivalent.</source>
          <target state="translated">대략 동등합니다.</target>
        </trans-unit>
        <trans-unit id="bfc0acfc5f4a94969ee2f529469c80db6f5db191" translate="yes" xml:space="preserve">
          <source>are the 40-hexdigit SHA-1 hashes,</source>
          <target state="translated">40 자리 16 진수 SHA-1 해시입니다.</target>
        </trans-unit>
        <trans-unit id="377a5f0a9c724f4b4e656d090beb28e896803b78" translate="yes" xml:space="preserve">
          <source>are the octal representation of the file modes.</source>
          <target state="translated">파일 모드의 8 진 표현입니다.</target>
        </trans-unit>
        <trans-unit id="536f158f6dfd529865dcb865a97bb16804e34d70" translate="yes" xml:space="preserve">
          <source>arguments</source>
          <target state="translated">arguments</target>
        </trans-unit>
        <trans-unit id="d73d25bb51bc0192ff2858618720527615dee66a" translate="yes" xml:space="preserve">
          <source>arrange &lt;code&gt;git push&lt;/code&gt; to push all local branches to their corresponding branch of the mothership machine.</source>
          <target state="translated">모든 현지 지점을 모선 기계의 해당 지점으로 푸시 하도록 &lt;code&gt;git push&lt;/code&gt; 를 정렬 하십시오.</target>
        </trans-unit>
        <trans-unit id="7dc74bb7dc6b2238e853c884d0d310e31daffb87" translate="yes" xml:space="preserve">
          <source>as long as the shared repository does not have any branches other than &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">공유 리포지토리에 &lt;code&gt;master&lt;/code&gt; 이외의 분기가없는 한 .</target>
        </trans-unit>
        <trans-unit id="cb2841c784dffc3f3e69b38c87cb3ad64f719624" translate="yes" xml:space="preserve">
          <source>as they are probably more user specific than repository specific. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for more information about this.</source>
          <target state="translated">리포지토리에 비해 사용자에 따라 다를 수 있습니다. 이에 대한 자세한 내용은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ec09624f8bf140a91e574552f4201e093095f93f" translate="yes" xml:space="preserve">
          <source>ask each</source>
          <target state="translated">각각 물어보세요</target>
        </trans-unit>
        <trans-unit id="a4da794aacaf85856a7722c9d864566d302089fc" translate="yes" xml:space="preserve">
          <source>at this point the two branches have diverged, with different changes made in each. To merge the changes made in experimental into master, run</source>
          <target state="translated">이 시점에서 두 가지 지점이 각각 다른 변경 사항으로 분기되었습니다. 실험에서 변경 한 내용을 마스터로 병합하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="56cb56551e60df919190b545acc4efd3487df2da" translate="yes" xml:space="preserve">
          <source>at-open-brace &lt;code&gt;@{&lt;/code&gt; is used as a notation to access a reflog entry.</source>
          <target state="translated">at-open-brace &lt;code&gt;@{&lt;/code&gt; 는 참조 로그 항목에 액세스하기위한 표기법으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c6f57180e462a4f1e9de24fbe811cfb2c24a0cf9" translate="yes" xml:space="preserve">
          <source>atom</source>
          <target state="translated">atom</target>
        </trans-unit>
        <trans-unit id="fc88c6b3cc380853de27e44642207df9743ff63d" translate="yes" xml:space="preserve">
          <source>attr</source>
          <target state="translated">attr</target>
        </trans-unit>
        <trans-unit id="c0357eb71b4a8821fe200d8b8eb01baef86fac5a" translate="yes" xml:space="preserve">
          <source>author date (format respects --date= option)</source>
          <target state="translated">작성자 날짜 (형식에 따라 --date = 옵션)</target>
        </trans-unit>
        <trans-unit id="2a06a73ff8fc368a2739a3e178ba7f2389794fbb" translate="yes" xml:space="preserve">
          <source>author date, ISO 8601-like format</source>
          <target state="translated">작성자 날짜, ISO 8601과 같은 형식</target>
        </trans-unit>
        <trans-unit id="242b07f5f5075eaa7fd5b51606a9b4162ff6c885" translate="yes" xml:space="preserve">
          <source>author date, RFC2822 style</source>
          <target state="translated">작성자 날짜, RFC2822 스타일</target>
        </trans-unit>
        <trans-unit id="203f076a8dfae351b5cbfcddc2f39e2529b4ab40" translate="yes" xml:space="preserve">
          <source>author date, UNIX timestamp</source>
          <target state="translated">작성자 날짜, UNIX 타임 스탬프</target>
        </trans-unit>
        <trans-unit id="5b659229f527fa360f4003ca474cb9646e5df53b" translate="yes" xml:space="preserve">
          <source>author date, relative</source>
          <target state="translated">저자 날짜, 상대</target>
        </trans-unit>
        <trans-unit id="d04a676256ca4278418fc83a6c6099b60b59d9c4" translate="yes" xml:space="preserve">
          <source>author date, short format (&lt;code&gt;YYYY-MM-DD&lt;/code&gt;)</source>
          <target state="translated">저자 날짜, 짧은 형식 ( &lt;code&gt;YYYY-MM-DD&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ca050c864ebffd969007968bf223faf21875eae7" translate="yes" xml:space="preserve">
          <source>author date, strict ISO 8601 format</source>
          <target state="translated">작성자 날짜, 엄격한 ISO 8601 형식</target>
        </trans-unit>
        <trans-unit id="7ddbfb879a548122c7fc198acb1c1b2f4c9b9921" translate="yes" xml:space="preserve">
          <source>author email</source>
          <target state="translated">저자 이메일</target>
        </trans-unit>
        <trans-unit id="8edafcfb5bfb68f54b13aeb0dafbb6187a753701" translate="yes" xml:space="preserve">
          <source>author email (respecting .mailmap, see &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; or &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;)</source>
          <target state="translated">작성자 이메일 (.mailmap 존중, &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-blame&quot;&gt;git-blame [1] 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="83daf4aca33631f2eb4acd6a25a656b0af3f5ee2" translate="yes" xml:space="preserve">
          <source>author email local-part (the part before the &lt;code&gt;@&lt;/code&gt; sign)</source>
          <target state="translated">작성자 이메일 로컬 부분 ( &lt;code&gt;@&lt;/code&gt; 기호 앞 부분 )</target>
        </trans-unit>
        <trans-unit id="5d4130a7bcbeec5d4a298b1e471f17266d9c3b2a" translate="yes" xml:space="preserve">
          <source>author local-part (see &lt;code&gt;%al&lt;/code&gt;) respecting .mailmap, see &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; or &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;)</source>
          <target state="translated">.mailmap과 관련하여 local-part ( &lt;code&gt;%al&lt;/code&gt; 참조 )를 작성하십시오 ( &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-blame&quot;&gt;git-blame [1] 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a38923d0b44faf2fd760ba1064fa8cccf3161910" translate="yes" xml:space="preserve">
          <source>author local-part (see &lt;code&gt;%cl&lt;/code&gt;) respecting .mailmap, see &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; or &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;)</source>
          <target state="translated">.mailmap과 관련하여 local-part ( &lt;code&gt;%cl&lt;/code&gt; 참조 )를 작성하십시오 ( &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-blame&quot;&gt;git-blame [1] 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="c377e3db13b17a5dec490aa3f6ac58e35bd02ae8" translate="yes" xml:space="preserve">
          <source>author name</source>
          <target state="translated">저자 이름</target>
        </trans-unit>
        <trans-unit id="bd2cf54c8d8427c36e72436dee6f5edfa55f4e21" translate="yes" xml:space="preserve">
          <source>author name (respecting .mailmap, see &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; or &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;)</source>
          <target state="translated">작성자 이름 (.mailmap 존중, &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-blame&quot;&gt;git-blame [1] 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="aa42d4b548d53eeb1e514e0662eb0b64c3782193" translate="yes" xml:space="preserve">
          <source>author name, email and date</source>
          <target state="translated">저자 이름, 이메일 및 날짜</target>
        </trans-unit>
        <trans-unit id="d00ed3c485ca1a6ad6088b1642369eb27039d0b8" translate="yes" xml:space="preserve">
          <source>author.email</source>
          <target state="translated">author.email</target>
        </trans-unit>
        <trans-unit id="290b3c3f6920221191e3db343ad6fbf3a2f939e8" translate="yes" xml:space="preserve">
          <source>author.name</source>
          <target state="translated">author.name</target>
        </trans-unit>
        <trans-unit id="9c3bb49ffea1144231cbe02d904b8d9018744e9d" translate="yes" xml:space="preserve">
          <source>avatar</source>
          <target state="translated">avatar</target>
        </trans-unit>
        <trans-unit id="0bb01d8924d6b902321a6c09d5c0a45ab1342655" translate="yes" xml:space="preserve">
          <source>b) independent fixup</source>
          <target state="translated">b) 독립 픽스 업</target>
        </trans-unit>
        <trans-unit id="aeca33ec4bf9a7bd6b90cc303f5a8ac32af312c1" translate="yes" xml:space="preserve">
          <source>backport a critical fix.</source>
          <target state="translated">중요한 수정 사항을 백 포트하십시오.</target>
        </trans-unit>
        <trans-unit id="fe676f1ea27d4114d62d0b88a9999860d1c162c1" translate="yes" xml:space="preserve">
          <source>bare repository</source>
          <target state="translated">베어 리포지토리</target>
        </trans-unit>
        <trans-unit id="e95c0d71e5a737bfc209f7013e45e233a7480a96" translate="yes" xml:space="preserve">
          <source>base-name</source>
          <target state="translated">base-name</target>
        </trans-unit>
        <trans-unit id="5b2505039ac5af9e197f5dad04113906a9cf9a2a" translate="yes" xml:space="preserve">
          <source>bc</source>
          <target state="translated">bc</target>
        </trans-unit>
        <trans-unit id="3c2369c6416caa1993808240594282dd4fcb95c1" translate="yes" xml:space="preserve">
          <source>bc3</source>
          <target state="translated">bc3</target>
        </trans-unit>
        <trans-unit id="b7c7d5d4b182d06d7f89fcb3d277474733c67444" translate="yes" xml:space="preserve">
          <source>be quiet if files exist or are not in the index</source>
          <target state="translated">파일이 있거나 색인에없는 경우 조용히</target>
        </trans-unit>
        <trans-unit id="bfa1cf02635b780783c9853aaca57e1c719e79ad" translate="yes" xml:space="preserve">
          <source>because the hostnames differ. Nor would it match &lt;code&gt;foo.example.com&lt;/code&gt;; Git compares hostnames exactly, without considering whether two hosts are part of the same domain. Likewise, a config entry for &lt;code&gt;http://example.com&lt;/code&gt; would not match: Git compares the protocols exactly.</source>
          <target state="translated">호스트 이름이 다르기 때문입니다. &lt;code&gt;foo.example.com&lt;/code&gt; 과도 일치하지 않습니다 . Git은 두 호스트가 동일한 도메인의 일부인지 여부를 고려하지 않고 호스트 이름을 정확하게 비교합니다. 마찬가지로 &lt;code&gt;http://example.com&lt;/code&gt; 의 구성 항목 이 일치하지 않습니다. Git은 프로토콜을 정확하게 비교합니다.</target>
        </trans-unit>
        <trans-unit id="bd766456dd7d080025c5f2a3029a29c2bb5419ef" translate="yes" xml:space="preserve">
          <source>because the hostnames differ. Nor would it match &lt;code&gt;foo.example.com&lt;/code&gt;; Git compares hostnames exactly, without considering whether two hosts are part of the same domain. Likewise, a config entry for &lt;code&gt;http://example.com&lt;/code&gt; would not match: Git compares the protocols exactly. However, you may use wildcards in the domain name and other pattern matching techniques as with the &lt;code&gt;http.&amp;lt;url&amp;gt;.*&lt;/code&gt; options.</source>
          <target state="translated">호스트 이름이 다르기 때문입니다. &lt;code&gt;foo.example.com&lt;/code&gt; 과도 일치하지 않습니다 . Git은 두 호스트가 동일한 도메인의 일부인지 여부를 고려하지 않고 호스트 이름을 정확하게 비교합니다. 마찬가지로 &lt;code&gt;http://example.com&lt;/code&gt; 의 구성 항목은 일치하지 않습니다. Git은 프로토콜을 정확히 비교합니다. 그러나 &lt;code&gt;http.&amp;lt;url&amp;gt;.*&lt;/code&gt; 옵션 에서와 같이 도메인 이름 및 기타 패턴 일치 기술에 와일드 카드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c02ceb78ff4863ee1a75d232c4f53af56b182ec9" translate="yes" xml:space="preserve">
          <source>becomes:</source>
          <target state="translated">becomes:</target>
        </trans-unit>
        <trans-unit id="7e57cfe843145135aee1f4d0d63ceb7842093712" translate="yes" xml:space="preserve">
          <source>binary</source>
          <target state="translated">binary</target>
        </trans-unit>
        <trans-unit id="fc5afa849d013727d8acf30682a03a891f7aca7e" translate="yes" xml:space="preserve">
          <source>bisect</source>
          <target state="translated">bisect</target>
        </trans-unit>
        <trans-unit id="e04a67a1c220ec3759550df9a963521323148d66" translate="yes" xml:space="preserve">
          <source>blame</source>
          <target state="translated">blame</target>
        </trans-unit>
        <trans-unit id="72092ff956b5b07bf4d598501177651a9897b3f1" translate="yes" xml:space="preserve">
          <source>blame.blankBoundary</source>
          <target state="translated">blame.blankBoundary</target>
        </trans-unit>
        <trans-unit id="2862b4a0ea76b67385f8581e3bd4cf75e32e65d0" translate="yes" xml:space="preserve">
          <source>blame.coloring</source>
          <target state="translated">blame.coloring</target>
        </trans-unit>
        <trans-unit id="c55af0af464fc28e395cedf375c27ed38ea08dd7" translate="yes" xml:space="preserve">
          <source>blame.date</source>
          <target state="translated">blame.date</target>
        </trans-unit>
        <trans-unit id="574525f7353221a33787a1a7d1232b7faf51b9bb" translate="yes" xml:space="preserve">
          <source>blame.ignoreRevsFile</source>
          <target state="translated">blame.ignoreRevsFile</target>
        </trans-unit>
        <trans-unit id="8d9e3a327869e356dde043a93aea128672ec4a32" translate="yes" xml:space="preserve">
          <source>blame.markIgnoredLines</source>
          <target state="translated">blame.markIgnoredLines</target>
        </trans-unit>
        <trans-unit id="96c64bfbb0487dbb1fe121cc068a07b1b6f2001d" translate="yes" xml:space="preserve">
          <source>blame.markUnblamables</source>
          <target state="translated">blame.markUnblamables</target>
        </trans-unit>
        <trans-unit id="244ba240ca074db6d0f0d4bb8de34505a6383151" translate="yes" xml:space="preserve">
          <source>blame.showEmail</source>
          <target state="translated">blame.showEmail</target>
        </trans-unit>
        <trans-unit id="f2560ddc149bc689a9eb1559b1e046e4885feda7" translate="yes" xml:space="preserve">
          <source>blame.showRoot</source>
          <target state="translated">blame.showRoot</target>
        </trans-unit>
        <trans-unit id="3bc20f9fcb1740f5d09c92cd6bf8bd32d164c6ae" translate="yes" xml:space="preserve">
          <source>blame_incremental</source>
          <target state="translated">blame_incremental</target>
        </trans-unit>
        <trans-unit id="0fd0bcfb44f83e7d5ac7a8922578276b9af48746" translate="yes" xml:space="preserve">
          <source>blob</source>
          <target state="translated">blob</target>
        </trans-unit>
        <trans-unit id="815675cd53e5196255182a0fd392e03df0fcd193" translate="yes" xml:space="preserve">
          <source>blob object</source>
          <target state="translated">얼룩 개체</target>
        </trans-unit>
        <trans-unit id="751eae742e521df559ef7ed559fa3259d5b09b0d" translate="yes" xml:space="preserve">
          <source>blob_plain</source>
          <target state="translated">blob_plain</target>
        </trans-unit>
        <trans-unit id="c06f874d67ebcdd1994d59e3867ceb303b9b6698" translate="yes" xml:space="preserve">
          <source>blobdiff</source>
          <target state="translated">blobdiff</target>
        </trans-unit>
        <trans-unit id="f7d5b2b95861daea9933ef0a243f733bbc79235e" translate="yes" xml:space="preserve">
          <source>blocks</source>
          <target state="translated">blocks</target>
        </trans-unit>
        <trans-unit id="02083f4579e08a612425c0c1a17ee47add783b94" translate="yes" xml:space="preserve">
          <source>body</source>
          <target state="translated">body</target>
        </trans-unit>
        <trans-unit id="48647474b89fa8f56ed6bda0f8148a17b51b97bd" translate="yes" xml:space="preserve">
          <source>boolean</source>
          <target state="translated">boolean</target>
        </trans-unit>
        <trans-unit id="f6edb368393f0758009b3afd170f648a63e11385" translate="yes" xml:space="preserve">
          <source>both &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; are merge-bases of A and B. Neither one is better than the other (both are &lt;code&gt;best&lt;/code&gt; merge bases). When the &lt;code&gt;--all&lt;/code&gt; option is not given, it is unspecified which best one is output.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;2&lt;/code&gt; 는 모두 A와 B의 병합 기반입니다. 둘 중 어느 것도 다른 것보다 낫습니다 (둘 다 &lt;code&gt;best&lt;/code&gt; 병합 기준입니다). 때 &lt;code&gt;--all&lt;/code&gt; 옵션이 주어지지 않는, 출력에 가장 잘 한 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab885ad5b5ecb443f904caddcf71de38ec2ad4fc" translate="yes" xml:space="preserve">
          <source>both from a symlink following standpoint &lt;strong&gt;and&lt;/strong&gt; an error checking standpoint. The &quot;refs/&quot; rule for symlinks means that symlinks that point to &quot;outside&quot; the tree are safe: they&amp;rsquo;ll be followed for reading but not for writing (so we&amp;rsquo;ll never write through a ref symlink to some other tree, if you have copied a whole archive by creating a symlink tree).</source>
          <target state="translated">다음에 나오는 심볼릭 링크 &lt;strong&gt;와&lt;/strong&gt; 오류 확인 관점에서. 심볼릭 링크에 대한 &quot;refs /&quot;규칙은 트리의 &quot;외부&quot;를 가리키는 심볼릭 링크가 안전하다는 것을 의미합니다. 읽기 전용이지만 쓰기 용이 아닙니다 (따라서 다른 트리에 대한 참조 심볼릭 링크를 통해 쓰지 않습니다) 심볼릭 링크 트리를 만들어 전체 아카이브를 복사했습니다.</target>
        </trans-unit>
        <trans-unit id="10d735e581f1e2505cd69675691925490e447c44" translate="yes" xml:space="preserve">
          <source>branch</source>
          <target state="translated">branch</target>
        </trans-unit>
        <trans-unit id="d9ebdce6e5eb5490d2736b1657cb3bbdff2a24c8" translate="yes" xml:space="preserve">
          <source>branch &amp;lt;branchname&amp;gt; [&amp;lt;stash&amp;gt;]</source>
          <target state="translated">분기 &amp;lt;branchname&amp;gt; [&amp;lt;stash&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="4d89d47c3496bed1c997cfd4749bbb345956b062" translate="yes" xml:space="preserve">
          <source>branch name: refers to the commit at the head of the given branch</source>
          <target state="translated">지점 이름 : 주어진 지점의 머리에서 커밋을 나타냅니다</target>
        </trans-unit>
        <trans-unit id="7cf9cb4f1f0d11974da193a921ad56188af0dbfb" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.description</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.description</target>
        </trans-unit>
        <trans-unit id="c972b8f442dc56f76ff5821861f38f9df9f740a2" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.merge</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.merge</target>
        </trans-unit>
        <trans-unit id="12b705785a619a7af3091b413cd10bc5f913cd36" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.mergeOptions</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.mergeOptions</target>
        </trans-unit>
        <trans-unit id="e3044fee5f265c567fa94779be6a4b05485a2ef5" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.pushRemote</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.pushRemote</target>
        </trans-unit>
        <trans-unit id="089608ebf4ab438938386db74054dd0539e68174" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.rebase</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.rebase</target>
        </trans-unit>
        <trans-unit id="ae2da89c53e9406d5454991c9de79d2701626513" translate="yes" xml:space="preserve">
          <source>branch.&amp;lt;name&amp;gt;.remote</source>
          <target state="translated">branch.&amp;lt;name&amp;gt;.remote</target>
        </trans-unit>
        <trans-unit id="c1beb4d53b0941d5b69587d5619ae40af0e82fb0" translate="yes" xml:space="preserve">
          <source>branch.autoSetupMerge</source>
          <target state="translated">branch.autoSetupMerge</target>
        </trans-unit>
        <trans-unit id="a348d9eb171112632f68ea4fa0280f35b7af36d9" translate="yes" xml:space="preserve">
          <source>branch.autoSetupRebase</source>
          <target state="translated">branch.autoSetupRebase</target>
        </trans-unit>
        <trans-unit id="c4907ecf78c64eedfc547e343a00efb0d648c80c" translate="yes" xml:space="preserve">
          <source>branch.sort</source>
          <target state="translated">branch.sort</target>
        </trans-unit>
        <trans-unit id="52a9ce4a0d3c21f1c0c5dc576930fbb59ad74018" translate="yes" xml:space="preserve">
          <source>branches</source>
          <target state="translated">branches</target>
        </trans-unit>
        <trans-unit id="ef98362b8a6b0c8cd804b0d227aa1ffeaba89786" translate="yes" xml:space="preserve">
          <source>browser</source>
          <target state="translated">browser</target>
        </trans-unit>
        <trans-unit id="d7b49d5666ac0fe3243cf929f3fbea5d40512cc5" translate="yes" xml:space="preserve">
          <source>browser.&amp;lt;tool&amp;gt;.cmd</source>
          <target state="translated">browser.&amp;lt;tool&amp;gt;.cmd</target>
        </trans-unit>
        <trans-unit id="1afa7a8068dc2826b24730832089e6b8ae806f4d" translate="yes" xml:space="preserve">
          <source>browser.&amp;lt;tool&amp;gt;.path</source>
          <target state="translated">browser.&amp;lt;tool&amp;gt;.path</target>
        </trans-unit>
        <trans-unit id="ce3731defbdc7875cff0c020e900192d6b65542c" translate="yes" xml:space="preserve">
          <source>bugreport</source>
          <target state="translated">bugreport</target>
        </trans-unit>
        <trans-unit id="26a194e96e2873f688a8836d3ee9bd5e7be08547" translate="yes" xml:space="preserve">
          <source>built-in values (some set during build stage),</source>
          <target state="translated">내장 값 (빌드 단계 중 일부 설정)</target>
        </trans-unit>
        <trans-unit id="7581496de8d7f905da83e60fe5216caab582c109" translate="yes" xml:space="preserve">
          <source>bumping format version numbers of individual data files (e.g., index, packfiles, etc). This restricts the incompatibilities only to those files.</source>
          <target state="translated">개별 데이터 파일의 범핑 형식 버전 번호 (예 : 색인, 팩 파일 등). 이렇게하면 비 호환성이 해당 파일로만 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="d59795de8a4d83834e525b589b2bb0c12e4542c1" translate="yes" xml:space="preserve">
          <source>bundle</source>
          <target state="translated">bundle</target>
        </trans-unit>
        <trans-unit id="c8bebbf42f3ec7d29b62f6981d42b56fa9e07016" translate="yes" xml:space="preserve">
          <source>but can be used to amend a merge commit.</source>
          <target state="translated">병합 커밋을 수정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0e9a8eb5c66f16a9e8325bbfe07678355605d3b" translate="yes" xml:space="preserve">
          <source>but if $REV is empty, the commit object name from master will be printed.</source>
          <target state="translated">그러나 $ REV가 비어 있으면 master의 커밋 개체 이름이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="d086642ebaf2071be1a4671ed3801412d03ee7ac" translate="yes" xml:space="preserve">
          <source>but that may become cumbersome, when you have many attributes. Using macro attributes, you can define an attribute that, when set, also sets or unsets a number of other attributes at the same time. The system knows a built-in macro attribute, &lt;code&gt;binary&lt;/code&gt;:</source>
          <target state="translated">하지만 속성이 많을 경우 번거로울 수 있습니다. 매크로 속성을 사용하면 설정시 여러 다른 속성을 동시에 설정 또는 설정 해제하는 속성을 정의 할 수 있습니다. 시스템은 내장 매크로 속성 인 &lt;code&gt;binary&lt;/code&gt; 를 알고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b354ac610248436418f0a768b2a238f599b63512" translate="yes" xml:space="preserve">
          <source>but that may sometimes help you guess which tags might come after the given commit.</source>
          <target state="translated">그러나 때로는 주어진 커밋 후에 어떤 태그가 올지 추측하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="481514e03c29bd6e6c21bcf330cca66f7a8e5e03" translate="yes" xml:space="preserve">
          <source>but the command invocation was &lt;code&gt;git diff-files myfile&lt;/code&gt;, then the junkfile entry would be removed from the list because only &quot;myfile&quot; is under consideration.</source>
          <target state="translated">그러나 명령 호출은 &lt;code&gt;git diff-files myfile&lt;/code&gt; 이며, &quot;myfile&quot;만 고려 중이므로 정크 파일 항목이 목록에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9a4d92b29b4ea9cb527dbdd917995ee8e6390c1d" translate="yes" xml:space="preserve">
          <source>but this time instead of immediately making the commit, let&amp;rsquo;s take an intermediate step, and ask for diffs along the way to keep track of what&amp;rsquo;s happening:</source>
          <target state="translated">그러나 이번에는 커밋을 즉시 수행하는 대신 중간 단계를 수행하고 진행 상황을 추적하기 위해 diffs를 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="4a4c509be280ffc999d52daf10f3af16adbf10ad" translate="yes" xml:space="preserve">
          <source>but to avoid common mistakes with filename globbing etc., the command will not normally add totally new entries or remove old entries, i.e. it will normally just update existing cache entries.</source>
          <target state="translated">그러나 파일 이름 globbing 등과 같은 일반적인 실수를 피하기 위해 명령은 일반적으로 완전히 새로운 항목을 추가하거나 오래된 항목을 제거하지 않습니다. 즉, 일반적으로 기존 캐시 항목을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="0c8f2a0a85b88cfa647434356130399dff07d5d7" translate="yes" xml:space="preserve">
          <source>but with the algorithm used by git bisect we get:</source>
          <target state="translated">그러나 git bisect에서 사용하는 알고리즘으로 다음을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="08885cdf79de4806bc91b025b32f3b00703dcf8c" translate="yes" xml:space="preserve">
          <source>by listing files as arguments to the &lt;code&gt;commit&lt;/code&gt; command (without --interactive or --patch switch), in which case the commit will ignore changes staged in the index, and instead record the current content of the listed files (which must already be known to Git);</source>
          <target state="translated">--interactive 또는 --patch 스위치없이 &lt;code&gt;commit&lt;/code&gt; 명령 에 대한 인수로 파일을 나열 함으로써 커밋은 인덱스에서 단계 화 된 변경 사항을 무시하고 대신 나열된 파일의 현재 내용을 기록합니다 (이미 알고 있어야 함) 힘내);</target>
        </trans-unit>
        <trans-unit id="3836fcf09d79e41b99edac70e256133efc12bff7" translate="yes" xml:space="preserve">
          <source>by moving the &quot;pick 4&quot; line will result in the following history:</source>
          <target state="translated">&quot;pick 4&quot;줄을 이동하면 다음과 같은 기록이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="906ba5e6f6707165a9878468ec60f33a2ff34b96" translate="yes" xml:space="preserve">
          <source>by using &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to incrementally &quot;add&quot; changes to the index before using the &lt;code&gt;commit&lt;/code&gt; command (Note: even modified files must be &quot;added&quot;);</source>
          <target state="translated">하여 &lt;a href=&quot;git-add&quot;&gt;자식 합산 [1]을&lt;/a&gt; 점진적으로 사용하기 전에 인덱스를 변경 &quot;추가&quot; &lt;code&gt;commit&lt;/code&gt; 명령 (참고 :에도 수정 된 파일이 &quot;추가&quot;해야한다);</target>
        </trans-unit>
        <trans-unit id="e48f31443a096bff3238667996c3f171f13b5f0c" translate="yes" xml:space="preserve">
          <source>by using &lt;a href=&quot;git-rm&quot;&gt;git-rm[1]&lt;/a&gt; to remove files from the working tree and the index, again before using the &lt;code&gt;commit&lt;/code&gt; command;</source>
          <target state="translated">사용하여 &lt;a href=&quot;git-rm&quot;&gt;자식-RM [1]을&lt;/a&gt; 작업 트리와 인덱스 파일을 제거하고, 다시는 사용하기 전에 &lt;code&gt;commit&lt;/code&gt; 명령을;</target>
        </trans-unit>
        <trans-unit id="093a3f97e95959ebe22524ee0ce832b0babc748b" translate="yes" xml:space="preserve">
          <source>by using the --interactive or --patch switches with the &lt;code&gt;commit&lt;/code&gt; command to decide one by one which files or hunks should be part of the commit in addition to contents in the index, before finalizing the operation. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate these modes.</source>
          <target state="translated">&lt;code&gt;commit&lt;/code&gt; 명령 과 함께 --interactive 또는 --patch 스위치를 사용 하여 작업을 완료하기 전에 색인의 내용 외에 파일 또는 덩어리가 커밋의 일부 여야하는 파일을 하나씩 결정합니다. 이러한 모드를 작동하는 방법을 알아 보려면 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 의 &quot;대화식 모드&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4834ad1b53b94300bc089b00aaeed76c52aebbcd" translate="yes" xml:space="preserve">
          <source>by using the -a switch with the &lt;code&gt;commit&lt;/code&gt; command to automatically &quot;add&quot; changes from all known files (i.e. all files that are already listed in the index) and to automatically &quot;rm&quot; files in the index that have been removed from the working tree, and then perform the actual commit;</source>
          <target state="translated">&lt;code&gt;commit&lt;/code&gt; 명령 과 함께 -a 스위치를 사용하여 알려진 모든 파일 (예 : 색인에 이미 나열된 모든 파일)의 변경 사항을 자동으로 &quot;추가&quot;하고 작업 트리에서 제거 된 색인의 파일을 자동으로 &quot;rm&quot;로 설정 그런 다음 실제 커밋을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b03592806efabfeeb709f5a70a7c172669b00538" translate="yes" xml:space="preserve">
          <source>cache</source>
          <target state="translated">cache</target>
        </trans-unit>
        <trans-unit id="0c93713c1e43fccf897b7b4f02e822c65d557fdf" translate="yes" xml:space="preserve">
          <source>cached</source>
          <target state="translated">cached</target>
        </trans-unit>
        <trans-unit id="9eafea1e818b36cfe83084dbfcee79ccb268deb8" translate="yes" xml:space="preserve">
          <source>cancel the cherry-pick. In other words, return to the pre-cherry-pick state, preserving any local modifications you had in the working tree.</source>
          <target state="translated">체리 픽을 취소하십시오. 다시 말해, 작업 트리에있는 로컬 수정 사항을 유지하면서 체리 선택 이전 상태로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="21ca164274e6e0b587a5c99674b651b198887373" translate="yes" xml:space="preserve">
          <source>cat-blob</source>
          <target state="translated">cat-blob</target>
        </trans-unit>
        <trans-unit id="1b0b597309b09f88e890e96ee25a4239e209bcc6" translate="yes" xml:space="preserve">
          <source>cat-blob-fd</source>
          <target state="translated">cat-blob-fd</target>
        </trans-unit>
        <trans-unit id="1b860f3f13df1c0a7cb167ae98ab823bd793ef37" translate="yes" xml:space="preserve">
          <source>cat-file</source>
          <target state="translated">cat-file</target>
        </trans-unit>
        <trans-unit id="6bdc4dd4748a2bfb630e761b44a4eee74e5812c1" translate="yes" xml:space="preserve">
          <source>category (or &lt;code&gt;gitweb.category&lt;/code&gt;)</source>
          <target state="translated">카테고리 (또는 &lt;code&gt;gitweb.category&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d027a2f7150c9c1d54212c981331ced097d02521" translate="yes" xml:space="preserve">
          <source>cd_to_toplevel</source>
          <target state="translated">cd_to_toplevel</target>
        </trans-unit>
        <trans-unit id="2cf64e447b84b497b2491b7af072a229eefe2651" translate="yes" xml:space="preserve">
          <source>chain</source>
          <target state="translated">chain</target>
        </trans-unit>
        <trans-unit id="eea15bfc0410c3d01d0daf4a8e336e46da972ca0" translate="yes" xml:space="preserve">
          <source>changeset</source>
          <target state="translated">changeset</target>
        </trans-unit>
        <trans-unit id="60863ff2c00bd434be8f30a313cc6bf530d01628" translate="yes" xml:space="preserve">
          <source>check the branch names in an external repository (if not known).</source>
          <target state="translated">외부 저장소에서 분기 이름을 확인하십시오 (알 수없는 경우).</target>
        </trans-unit>
        <trans-unit id="1f1c087ebd5ee9330247a27b3cb5e1c3309d1b49" translate="yes" xml:space="preserve">
          <source>check-ignore</source>
          <target state="translated">check-ignore</target>
        </trans-unit>
        <trans-unit id="d5491e7e7124a22dd73fa746ba129c59f9dc6d5d" translate="yes" xml:space="preserve">
          <source>checkout</source>
          <target state="translated">checkout</target>
        </trans-unit>
        <trans-unit id="f1d6e05726e233a2ab8de16435d659a28a2e35a7" translate="yes" xml:space="preserve">
          <source>checkout a new branch &lt;code&gt;mine&lt;/code&gt; from master.</source>
          <target state="translated">마스터로부터 새로운 &lt;code&gt;mine&lt;/code&gt; 를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="baa127da3b2e7bb80d470a5c5b3ed484fc3ecffa" translate="yes" xml:space="preserve">
          <source>checkout-index</source>
          <target state="translated">checkout-index</target>
        </trans-unit>
        <trans-unit id="77ccc4847f3f5995981f07a9aaa766d505e363d0" translate="yes" xml:space="preserve">
          <source>checkout.defaultRemote</source>
          <target state="translated">checkout.defaultRemote</target>
        </trans-unit>
        <trans-unit id="7993ca6fc917dfcd7447613538a9f2529705f4e5" translate="yes" xml:space="preserve">
          <source>checkoutAmbiguousRemoteBranchName</source>
          <target state="translated">checkoutAmbiguousRemoteBranchName</target>
        </trans-unit>
        <trans-unit id="9c92181fd5e68d410f28e18265218b8c3a8a1b78" translate="yes" xml:space="preserve">
          <source>checks if the current directory is within the working tree of the repository, and otherwise dies.</source>
          <target state="translated">현재 디렉토리가 저장소의 작업 트리 내에 있는지 확인하고 그렇지 않으면 사망합니다.</target>
        </trans-unit>
        <trans-unit id="2e41d31ec807e404264bdbe4cf0898e0675b3d63" translate="yes" xml:space="preserve">
          <source>checks if the working tree associated with the repository exists, and otherwise dies. Often done before calling cd_to_toplevel, which is impossible to do if there is no working tree.</source>
          <target state="translated">저장소와 연관된 작업 트리가 존재하는지 확인하고 그렇지 않으면 사망합니다. cd_to_toplevel을 호출하기 전에 수행되는 작업 트리가없는 경우에는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="6ce38e1ed1561eb51f91bed4e5b8b42001fa1cda" translate="yes" xml:space="preserve">
          <source>checks out all files in the index. Cannot be used together with explicit filenames.</source>
          <target state="translated">색인의 모든 파일을 체크 아웃합니다. 명시적인 파일 이름과 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b095764396dd7603ab632901ad86334026f5e97f" translate="yes" xml:space="preserve">
          <source>checks out an older version. Continue like this, telling Git at each stage whether the version it gives you is good or bad, and notice that the number of revisions left to test is cut approximately in half each time.</source>
          <target state="translated">이전 버전을 체크 아웃합니다. 이렇게하면 각 단계에서 Git에게 제공하는 버전이 좋은지 나쁜지 알려주고 테스트 할 개정 횟수는 매번 약 절반으로 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="9d48ee970ac151e88a06bd52df27d444e45a115f" translate="yes" xml:space="preserve">
          <source>checks that the working tree and index associated with the repository have no uncommitted changes to tracked files. Otherwise it emits an error message of the form &lt;code&gt;Cannot
&amp;lt;action&amp;gt;: &amp;lt;reason&amp;gt;. &amp;lt;hint&amp;gt;&lt;/code&gt;, and dies. Example:</source>
          <target state="translated">리포지토리와 관련된 작업 트리 및 인덱스에 추적 파일에 대한 커밋되지 않은 변경 사항이 없는지 확인합니다. 그렇지 않으면 &lt;code&gt;Cannot &amp;lt;action&amp;gt;: &amp;lt;reason&amp;gt;. &amp;lt;hint&amp;gt;&lt;/code&gt; 형식의 오류 메시지가 나타납니다 . &amp;lt;힌트&amp;gt; 그리고 죽는다. 예:</target>
        </trans-unit>
        <trans-unit id="fde288e73fa35b620c1d091cd10bc2b4ef783b38" translate="yes" xml:space="preserve">
          <source>cherry-pick</source>
          <target state="translated">cherry-pick</target>
        </trans-unit>
        <trans-unit id="4d3ec7cec131af0636c8c4eb3ed9fad46bbbd8fe" translate="yes" xml:space="preserve">
          <source>cherry-picking</source>
          <target state="translated">cherry-picking</target>
        </trans-unit>
        <trans-unit id="a1aab85a96cc8931c6cead1715bf9f08fbd159e1" translate="yes" xml:space="preserve">
          <source>citool</source>
          <target state="translated">citool</target>
        </trans-unit>
        <trans-unit id="6a1cec45eaf37b34e1b1d89130d7746fe4006346" translate="yes" xml:space="preserve">
          <source>clean</source>
          <target state="translated">clean</target>
        </trans-unit>
        <trans-unit id="6191f3c6c1156403f2abec74131f05962f1abaa8" translate="yes" xml:space="preserve">
          <source>clean.requireForce</source>
          <target state="translated">clean.requireForce</target>
        </trans-unit>
        <trans-unit id="168cbb2ea52b9e34d271accecfa7d7951e948a99" translate="yes" xml:space="preserve">
          <source>clear</source>
          <target state="translated">clear</target>
        </trans-unit>
        <trans-unit id="5e0072329d5085c5bc5c23c2fa873dd42900958b" translate="yes" xml:space="preserve">
          <source>clone</source>
          <target state="translated">clone</target>
        </trans-unit>
        <trans-unit id="65b7b2d52a3b114f58dca240d43da422bee2212d" translate="yes" xml:space="preserve">
          <source>clone sets these configuration variables by default. It arranges &lt;code&gt;git pull&lt;/code&gt; to fetch and store the branches of mothership machine to local &lt;code&gt;remotes/origin/*&lt;/code&gt; remote-tracking branches.</source>
          <target state="translated">clone은 이러한 구성 변수를 기본적으로 설정합니다. 그것은 모기 기계의 지점을 가져 와서 로컬 &lt;code&gt;remotes/origin/*&lt;/code&gt; 원격 추적 지점에 &lt;code&gt;git pull&lt;/code&gt; 을 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="b0039cf0af8bf144bcdb5512b615336fbd740a49" translate="yes" xml:space="preserve">
          <source>cloneurl (or multiple-valued &lt;code&gt;gitweb.url&lt;/code&gt;)</source>
          <target state="translated">cloneurl (또는 다중 값 &lt;code&gt;gitweb.url&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ada0de0751f70d1f9286c0a71669d799d3961206" translate="yes" xml:space="preserve">
          <source>codecompare</source>
          <target state="translated">codecompare</target>
        </trans-unit>
        <trans-unit id="d2cff126ddc906e1a4a856fa830eddaf46fcb2f4" translate="yes" xml:space="preserve">
          <source>collapse multiple consecutive empty lines into one empty line</source>
          <target state="translated">연속 된 여러 빈 줄을 빈 줄 하나로 축소</target>
        </trans-unit>
        <trans-unit id="6dd0fe8001145bec4a12d0e22da711c4970d000b" translate="yes" xml:space="preserve">
          <source>color</source>
          <target state="translated">color</target>
        </trans-unit>
        <trans-unit id="a5c6de6e1d6a5426c3f20e289bee4cb63cd9b46d" translate="yes" xml:space="preserve">
          <source>color specification, as described under Values in the &quot;CONFIGURATION FILE&quot; section of &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;. By default, colors are shown only when enabled for log output (by &lt;code&gt;color.diff&lt;/code&gt;, &lt;code&gt;color.ui&lt;/code&gt;, or &lt;code&gt;--color&lt;/code&gt;, and respecting the &lt;code&gt;auto&lt;/code&gt; settings of the former if we are going to a terminal). &lt;code&gt;%C(auto,...)&lt;/code&gt; is accepted as a historical synonym for the default (e.g., &lt;code&gt;%C(auto,red)&lt;/code&gt;). Specifying &lt;code&gt;%C(always,...)&lt;/code&gt; will show the colors even when color is not otherwise enabled (though consider just using &lt;code&gt;--color=always&lt;/code&gt; to enable color for the whole output, including this format and anything else git might color). &lt;code&gt;auto&lt;/code&gt; alone (i.e. &lt;code&gt;%C(auto)&lt;/code&gt;) will turn on auto coloring on the next placeholders until the color is switched again.</source>
          <target state="translated">&lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 &quot;CONFIGURATION FILE&quot;섹션에있는 Values에 설명 된대로 컬러 스펙 . 기본적으로 색상은 로그 출력에 대해 활성화 된 경우 ( &lt;code&gt;color.diff&lt;/code&gt; , &lt;code&gt;color.ui&lt;/code&gt; 또는 &lt;code&gt;--color&lt;/code&gt; 에 의해 , 터미널로 갈 경우 전자 의 &lt;code&gt;auto&lt;/code&gt; 설정을 기준으로) 만 표시됩니다. &lt;code&gt;%C(auto,...)&lt;/code&gt; 는 기본값의 히스토리 동의어로 허용됩니다 (예 : &lt;code&gt;%C(auto,red)&lt;/code&gt; ). &lt;code&gt;%C(always,...)&lt;/code&gt; 지정 하면 색상이 다르게 활성화되지 않은 경우에도 색상이 표시됩니다 (단, &lt;code&gt;--color=always&lt;/code&gt; 를 사용하여이 형식 및 git이 색상을 지정할 수있는 모든 항목을 포함하여 전체 출력에 대해 색상을 활성화 하는 것을 고려 하십시오). &lt;code&gt;auto&lt;/code&gt; 단독으로 (즉, &lt;code&gt;%C(auto)&lt;/code&gt; )는 색상이 다시 전환 될 때까지 다음 자리 표시 자에서 자동 색상 표시를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="a4f66bcbf0c2d907db9d73e18998c425a594621e" translate="yes" xml:space="preserve">
          <source>color.advice</source>
          <target state="translated">color.advice</target>
        </trans-unit>
        <trans-unit id="8c847b9d6812ac606092130570e37493e972ad8a" translate="yes" xml:space="preserve">
          <source>color.advice.hint</source>
          <target state="translated">color.advice.hint</target>
        </trans-unit>
        <trans-unit id="46ab34863195debec0a658a6884ce1958a8721f8" translate="yes" xml:space="preserve">
          <source>color.blame.highlightRecent</source>
          <target state="translated">color.blame.highlightRecent</target>
        </trans-unit>
        <trans-unit id="cf152df8d71a4044f40941cffe12b4c5947d84c6" translate="yes" xml:space="preserve">
          <source>color.blame.repeatedLines</source>
          <target state="translated">color.blame.repeatedLines</target>
        </trans-unit>
        <trans-unit id="8ab572aa07e705b6cbb5dc02e6cc07d1c537adb5" translate="yes" xml:space="preserve">
          <source>color.branch</source>
          <target state="translated">color.branch</target>
        </trans-unit>
        <trans-unit id="ca9ef171160b4af8190637b4572026e1b567c98a" translate="yes" xml:space="preserve">
          <source>color.branch.&amp;lt;slot&amp;gt;</source>
          <target state="translated">color.branch.&amp;lt;slot&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ce3eb96e296266263902a69bbdcb71f2305cb04d" translate="yes" xml:space="preserve">
          <source>color.decorate.&amp;lt;slot&amp;gt;</source>
          <target state="translated">color.decorate.&amp;lt;slot&amp;gt;</target>
        </trans-unit>
        <trans-unit id="afd9432dd61dede344700077be0856defef90c96" translate="yes" xml:space="preserve">
          <source>color.diff</source>
          <target state="translated">color.diff</target>
        </trans-unit>
        <trans-unit id="f6c051574f795381da2ac0bc58ffe0019036f226" translate="yes" xml:space="preserve">
          <source>color.diff.&amp;lt;slot&amp;gt;</source>
          <target state="translated">color.diff.&amp;lt;slot&amp;gt;</target>
        </trans-unit>
        <trans-unit id="92611cb178c25cb2a36a185c2d51eb34ec21f182" translate="yes" xml:space="preserve">
          <source>color.grep</source>
          <target state="translated">color.grep</target>
        </trans-unit>
        <trans-unit id="514f2bfe2d4e52955ecf7c8018e222f3399098ca" translate="yes" xml:space="preserve">
          <source>color.grep.&amp;lt;slot&amp;gt;</source>
          <target state="translated">color.grep.&amp;lt;slot&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2a6e9053b32a43b99b387012d73632508c2e585a" translate="yes" xml:space="preserve">
          <source>color.interactive</source>
          <target state="translated">color.interactive</target>
        </trans-unit>
        <trans-unit id="dd02e0dce40f7d7025a402d431583fd14b053a0f" translate="yes" xml:space="preserve">
          <source>color.interactive.&amp;lt;slot&amp;gt;</source>
          <target state="translated">color.interactive.&amp;lt;slot&amp;gt;</target>
        </trans-unit>
        <trans-unit id="51223f4d2a0db29c55b88b1aeefff0292cdf6915" translate="yes" xml:space="preserve">
          <source>color.pager</source>
          <target state="translated">color.pager</target>
        </trans-unit>
        <trans-unit id="9b6681d65a863ea874b86fa52e01bfe3a595ea9a" translate="yes" xml:space="preserve">
          <source>color.push</source>
          <target state="translated">color.push</target>
        </trans-unit>
        <trans-unit id="b164c55f58675071e9cc9c95ff7b93fae5239027" translate="yes" xml:space="preserve">
          <source>color.push.error</source>
          <target state="translated">color.push.error</target>
        </trans-unit>
        <trans-unit id="98fcc11a52aacdf315198d4d4e4c73a28e373706" translate="yes" xml:space="preserve">
          <source>color.remote</source>
          <target state="translated">color.remote</target>
        </trans-unit>
        <trans-unit id="728bf4bb2acf8b14851df1659204bac06ad3e826" translate="yes" xml:space="preserve">
          <source>color.remote.&amp;lt;slot&amp;gt;</source>
          <target state="translated">color.remote.&amp;lt;slot&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cec9a5d09364bac15b42aabefa1d59f823f18bfe" translate="yes" xml:space="preserve">
          <source>color.showBranch</source>
          <target state="translated">color.showBranch</target>
        </trans-unit>
        <trans-unit id="5a6ac8de37cf8168f8e5d06954ae5809fe56b89f" translate="yes" xml:space="preserve">
          <source>color.status</source>
          <target state="translated">color.status</target>
        </trans-unit>
        <trans-unit id="76d5d5b91d9c8c6f4146d4786abd38fba73cb8f1" translate="yes" xml:space="preserve">
          <source>color.status.&amp;lt;slot&amp;gt;</source>
          <target state="translated">color.status.&amp;lt;slot&amp;gt;</target>
        </trans-unit>
        <trans-unit id="80d84e4a7a0e5b95050721eadf882873b302ba7e" translate="yes" xml:space="preserve">
          <source>color.transport</source>
          <target state="translated">color.transport</target>
        </trans-unit>
        <trans-unit id="72794fc97d8f3ec7db3dfc403237c35a36aeaacb" translate="yes" xml:space="preserve">
          <source>color.transport.rejected</source>
          <target state="translated">color.transport.rejected</target>
        </trans-unit>
        <trans-unit id="b327cc71473f7b15958c2ca3afbaf48055055624" translate="yes" xml:space="preserve">
          <source>color.ui</source>
          <target state="translated">color.ui</target>
        </trans-unit>
        <trans-unit id="6a3280550b4541e0235c265f15531724dee59cd5" translate="yes" xml:space="preserve">
          <source>column number prefix (when using &lt;code&gt;--column&lt;/code&gt;)</source>
          <target state="translated">열 번호 접두사 ( &lt;code&gt;--column&lt;/code&gt; 사용시 )</target>
        </trans-unit>
        <trans-unit id="c5890d10003df2a43476a1180736e1e1030ff815" translate="yes" xml:space="preserve">
          <source>column.branch</source>
          <target state="translated">column.branch</target>
        </trans-unit>
        <trans-unit id="e8f121be29b911a026f886fc824308ecf7947782" translate="yes" xml:space="preserve">
          <source>column.clean</source>
          <target state="translated">column.clean</target>
        </trans-unit>
        <trans-unit id="33c615ada2e68c61afdfea0f6120b1a5b6c93248" translate="yes" xml:space="preserve">
          <source>column.status</source>
          <target state="translated">column.status</target>
        </trans-unit>
        <trans-unit id="53ce35d568828be63293c7c5d7a6eafbdbfffa49" translate="yes" xml:space="preserve">
          <source>column.tag</source>
          <target state="translated">column.tag</target>
        </trans-unit>
        <trans-unit id="ce07ea7bd627b242f5db709af62203d11c193687" translate="yes" xml:space="preserve">
          <source>column.ui</source>
          <target state="translated">column.ui</target>
        </trans-unit>
        <trans-unit id="c58211681f40d646f5440d87f36886f169b2c9c1" translate="yes" xml:space="preserve">
          <source>combines the changes of README.my and README.upstream since README, tries to merge them and writes the result into README.my.</source>
          <target state="translated">README 이후 README.my 및 README.upstream의 변경 사항을 결합하고 병합하여 결과를 README.my에 씁니다.</target>
        </trans-unit>
        <trans-unit id="4015b57a143aec5156fd1444a017a32137a3fd0f" translate="yes" xml:space="preserve">
          <source>commit</source>
          <target state="translated">commit</target>
        </trans-unit>
        <trans-unit id="a20c1ba85a902224a4242c5fac3cf8823109dde0" translate="yes" xml:space="preserve">
          <source>commit both the fix and the test script (and if needed more tests)</source>
          <target state="translated">수정 사항과 테스트 스크립트를 모두 커밋 (및 추가 테스트가 필요한 경우)</target>
        </trans-unit>
        <trans-unit id="6580b73ccd362d85f009b4182f9b6e3a1a45517f" translate="yes" xml:space="preserve">
          <source>commit everything, as you have tested, with your sign-off.</source>
          <target state="translated">테스트 한대로 사인 오프하여 모든 것을 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="38bf3efcbb1dfb31c6a31456605ce997aa62c82f" translate="yes" xml:space="preserve">
          <source>commit hash</source>
          <target state="translated">커밋 해시</target>
        </trans-unit>
        <trans-unit id="70dc53d067727e567991b5dab66575a545189059" translate="yes" xml:space="preserve">
          <source>commit it</source>
          <target state="translated">커밋</target>
        </trans-unit>
        <trans-unit id="7a11f783dc4b27c4f34550101a10a1fbab125f40" translate="yes" xml:space="preserve">
          <source>commit notes</source>
          <target state="translated">커밋 노트</target>
        </trans-unit>
        <trans-unit id="0f423768892497ee49fd3cb7600685fc4d09048c" translate="yes" xml:space="preserve">
          <source>commit object</source>
          <target state="translated">커밋 객체</target>
        </trans-unit>
        <trans-unit id="5c67584c6aef7f60be2cf36e26f15487e559041f" translate="yes" xml:space="preserve">
          <source>commit that index file as an object.</source>
          <target state="translated">인덱스 파일을 객체로 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="f4ec1cf234ecdc6f98beeaea1274fe5c7f90347c" translate="yes" xml:space="preserve">
          <source>commit-id</source>
          <target state="translated">commit-id</target>
        </trans-unit>
        <trans-unit id="4bd4b8d3421333ea6d9a947b7cd9b2b7570006f8" translate="yes" xml:space="preserve">
          <source>commit-ish (also committish)</source>
          <target state="translated">커밋-또한 (커밋)</target>
        </trans-unit>
        <trans-unit id="372e62e534ba58042964b6d46f900d1269ad921a" translate="yes" xml:space="preserve">
          <source>commit-msg</source>
          <target state="translated">commit-msg</target>
        </trans-unit>
        <trans-unit id="32f7e2c5b9e2776ff3de9e4a4c7b40027ac07e6b" translate="yes" xml:space="preserve">
          <source>commit-tree</source>
          <target state="translated">commit-tree</target>
        </trans-unit>
        <trans-unit id="f7963c5ab805426035c4f355fca23569d4f94fee" translate="yes" xml:space="preserve">
          <source>commit.cleanup</source>
          <target state="translated">commit.cleanup</target>
        </trans-unit>
        <trans-unit id="020eadfa132922a19589b8940de3d55c7ad15b7e" translate="yes" xml:space="preserve">
          <source>commit.gpgSign</source>
          <target state="translated">commit.gpgSign</target>
        </trans-unit>
        <trans-unit id="c1535e56d29950554365b98e35e0a2d2eb47b6f4" translate="yes" xml:space="preserve">
          <source>commit.status</source>
          <target state="translated">commit.status</target>
        </trans-unit>
        <trans-unit id="7e06eb9aa3509a950be20e8801458fb96ccf01b4" translate="yes" xml:space="preserve">
          <source>commit.template</source>
          <target state="translated">commit.template</target>
        </trans-unit>
        <trans-unit id="d26331c03d01ab6a22a800c032ca5206385bdad3" translate="yes" xml:space="preserve">
          <source>commit.verbose</source>
          <target state="translated">commit.verbose</target>
        </trans-unit>
        <trans-unit id="842f694cfa34540e61e4d3e66074dc2583876642" translate="yes" xml:space="preserve">
          <source>commitBeforeMerge</source>
          <target state="translated">commitBeforeMerge</target>
        </trans-unit>
        <trans-unit id="44d39bc019950029d2a2ff7a963a53eb0dae5c30" translate="yes" xml:space="preserve">
          <source>commitGraph.maxNewFilters</source>
          <target state="translated">commitGraph.maxNewFilters</target>
        </trans-unit>
        <trans-unit id="c6e59a77d77689677a93594a362f163573f2fcda" translate="yes" xml:space="preserve">
          <source>commitGraph.readChangedPaths</source>
          <target state="translated">commitGraph.readChangedPaths</target>
        </trans-unit>
        <trans-unit id="11899850251b5eb2e2933d99a09b9473953d4bae" translate="yes" xml:space="preserve">
          <source>commitdiff</source>
          <target state="translated">commitdiff</target>
        </trans-unit>
        <trans-unit id="47c67b823023966d5c5f6d31ef3dde438e9aadd0" translate="yes" xml:space="preserve">
          <source>committer date (format respects --date= option)</source>
          <target state="translated">커미터 날짜 (형식에 따라 --date = 옵션)</target>
        </trans-unit>
        <trans-unit id="b33ebef2805c5fbecc85c249d8af56796e04e86b" translate="yes" xml:space="preserve">
          <source>committer date, ISO 8601-like format</source>
          <target state="translated">커미터 날짜, ISO 8601과 같은 형식</target>
        </trans-unit>
        <trans-unit id="20fac00746eee2b30cbddfb09a32bdcad53536ce" translate="yes" xml:space="preserve">
          <source>committer date, RFC2822 style</source>
          <target state="translated">커미터 날짜, RFC2822 스타일</target>
        </trans-unit>
        <trans-unit id="eaa3fa71f9bbea1fd2e4449f0b787ea2bba704c0" translate="yes" xml:space="preserve">
          <source>committer date, UNIX timestamp</source>
          <target state="translated">커미터 날짜, UNIX 타임 스탬프</target>
        </trans-unit>
        <trans-unit id="e274fed9dd7f0b695abc2963b57577b07be7d3f4" translate="yes" xml:space="preserve">
          <source>committer date, relative</source>
          <target state="translated">커미터 날짜, 상대</target>
        </trans-unit>
        <trans-unit id="9cca7c26cf1623076f47819bbb93ef1c4f5dfa9d" translate="yes" xml:space="preserve">
          <source>committer date, short format (&lt;code&gt;YYYY-MM-DD&lt;/code&gt;)</source>
          <target state="translated">커미터 날짜, 짧은 형식 ( &lt;code&gt;YYYY-MM-DD&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="38c2b1fe5227fe0e97bf53953858478de9bfbf54" translate="yes" xml:space="preserve">
          <source>committer date, strict ISO 8601 format</source>
          <target state="translated">커미터 날짜, 엄격한 ISO 8601 형식</target>
        </trans-unit>
        <trans-unit id="8d1dd1aaeec98cb4c29903139710faa936f162fc" translate="yes" xml:space="preserve">
          <source>committer email</source>
          <target state="translated">커미터 이메일</target>
        </trans-unit>
        <trans-unit id="3a646c1c98a5273e8815f227e2a4ea9e4cde8f76" translate="yes" xml:space="preserve">
          <source>committer email (respecting .mailmap, see &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; or &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;)</source>
          <target state="translated">커미터 이메일 (.mailmap과 관련하여 &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-blame&quot;&gt;git-blame [1] 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="015580d96472da2ef6d8a31aff2978ebd41bee50" translate="yes" xml:space="preserve">
          <source>committer email local-part (the part before the &lt;code&gt;@&lt;/code&gt; sign)</source>
          <target state="translated">커미터 이메일 로컬 부분 ( &lt;code&gt;@&lt;/code&gt; 기호 앞 부분 )</target>
        </trans-unit>
        <trans-unit id="609e3a6e421d4825e34e38a674d27ee78e3ef040" translate="yes" xml:space="preserve">
          <source>committer local-part (see &lt;code&gt;%cl&lt;/code&gt;) respecting .mailmap, see &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; or &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;)</source>
          <target state="translated">.mailmap과 관련된 커미터 로컬 부분 ( &lt;code&gt;%cl&lt;/code&gt; 참조 ), &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-blame&quot;&gt;git-blame [1] 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="2974d417745d222f91fff9082897848e8aea4153" translate="yes" xml:space="preserve">
          <source>committer name</source>
          <target state="translated">커미터 이름</target>
        </trans-unit>
        <trans-unit id="bb221237e1d999483cc86d764075a461647b96a9" translate="yes" xml:space="preserve">
          <source>committer name (respecting .mailmap, see &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; or &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;)</source>
          <target state="translated">커미터 이름 (.mailmap과 관련하여 &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-blame&quot;&gt;git-blame [1] 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="5abd489d572a61c526a8d49b278ebc85d271b5fc" translate="yes" xml:space="preserve">
          <source>committer name and email and the commit time.</source>
          <target state="translated">커미터 이름 및 이메일과 커밋 시간.</target>
        </trans-unit>
        <trans-unit id="1657e420cf0201abacf9cdc3136193554606a781" translate="yes" xml:space="preserve">
          <source>committer.email</source>
          <target state="translated">committer.email</target>
        </trans-unit>
        <trans-unit id="417126b9b708ab67689edbca082dae92d085b8b3" translate="yes" xml:space="preserve">
          <source>committer.name</source>
          <target state="translated">committer.name</target>
        </trans-unit>
        <trans-unit id="94c8c21d08740f5da9eaa38d1f175c592692f0d1" translate="yes" xml:space="preserve">
          <source>common</source>
          <target state="translated">common</target>
        </trans-unit>
        <trans-unit id="f60111fa92796b3aa267dd6bd3296c767d442dae" translate="yes" xml:space="preserve">
          <source>common system-wide configuration file (defaults to &lt;code&gt;/etc/gitweb-common.conf&lt;/code&gt;),</source>
          <target state="translated">공통 시스템 전체 구성 파일 (기본값은 &lt;code&gt;/etc/gitweb-common.conf&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2de94ce58ba8f4292ce3f108fdd961fdc028ec5f" translate="yes" xml:space="preserve">
          <source>commondir</source>
          <target state="translated">commondir</target>
        </trans-unit>
        <trans-unit id="4a865a3883220011a983b6bf7b561ea819ef64df" translate="yes" xml:space="preserve">
          <source>compares a (c)ommit and the (i)ndex;</source>
          <target state="translated">(c) ommit 및 (i) ndex를 비교하고;</target>
        </trans-unit>
        <trans-unit id="b37837e3f8529c64742c38018b1bdcb4dd0b9cfa" translate="yes" xml:space="preserve">
          <source>compares a (c)ommit and the (w)ork tree;</source>
          <target state="translated">(c) ommit와 (w) ork tree를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="75cfb85191fb68e32f895381943a5f43a2293526" translate="yes" xml:space="preserve">
          <source>compares an (o)bject and a (w)ork tree entity;</source>
          <target state="translated">(o) bject와 (w) ork tree 엔티티를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="e1e73207352b3690623d8228d0e4745441f558d2" translate="yes" xml:space="preserve">
          <source>compares the &amp;lt;tree-ish&amp;gt; and the files on the filesystem.</source>
          <target state="translated">&amp;lt;tree-ish&amp;gt;와 파일 시스템의 파일을 비교합니다.</target>
        </trans-unit>
        <trans-unit id="1798907f080fa317b12590de2174f117f4901f72" translate="yes" xml:space="preserve">
          <source>compares the &amp;lt;tree-ish&amp;gt; and the index.</source>
          <target state="translated">&amp;lt;tree-ish&amp;gt;와 인덱스를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="02be68d024d50b1d246f0e832552c33da5fd685a" translate="yes" xml:space="preserve">
          <source>compares the (i)ndex and the (w)ork tree;</source>
          <target state="translated">(i) ndex와 (w) ork tree를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="a20897a0ce7de6a657164250c440919d9fa64d1f" translate="yes" xml:space="preserve">
          <source>compares the index and the files on the filesystem.</source>
          <target state="translated">파일 시스템의 색인과 파일을 비교합니다.</target>
        </trans-unit>
        <trans-unit id="a70f2d21c29dbe161583247fd9fe30a73e793b09" translate="yes" xml:space="preserve">
          <source>compares the trees named by the two arguments.</source>
          <target state="translated">두 개의 인수로 명명 된 나무를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="e83536d8d09abd0f54c435ffc83d5c65aa8a3377" translate="yes" xml:space="preserve">
          <source>compares two non-git things (1) and (2).</source>
          <target state="translated">git이 아닌 것들 (1)과 (2)를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="809948dcfa8a97cd21a12fe2461b3e125556f1f7" translate="yes" xml:space="preserve">
          <source>completion.commands</source>
          <target state="translated">completion.commands</target>
        </trans-unit>
        <trans-unit id="dfba7aade0868074c2861c98e2a9a92f3178a51b" translate="yes" xml:space="preserve">
          <source>config</source>
          <target state="translated">config</target>
        </trans-unit>
        <trans-unit id="4adee727fe2662299c984011920419deadc8fc0b" translate="yes" xml:space="preserve">
          <source>config.worktree</source>
          <target state="translated">config.worktree</target>
        </trans-unit>
        <trans-unit id="45b8d5aa10dc50038a6b05d6c0044f98b5efac43" translate="yes" xml:space="preserve">
          <source>contain an empty directory component (e.g. &lt;code&gt;foo//bar&lt;/code&gt; is invalid),</source>
          <target state="translated">빈 디렉토리 구성 요소를 포함합니다 (예 : &lt;code&gt;foo//bar&lt;/code&gt; 가 유효하지 않음).</target>
        </trans-unit>
        <trans-unit id="4397f461de61e8aae143911e30e46e78f1021881" translate="yes" xml:space="preserve">
          <source>contain the special component &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;..&lt;/code&gt; (e.g. &lt;code&gt;foo/./bar&lt;/code&gt; and &lt;code&gt;foo/../bar&lt;/code&gt; are invalid).</source>
          <target state="translated">특수 구성 요소를 포함합니다 &lt;code&gt;.&lt;/code&gt; 또는 &lt;code&gt;..&lt;/code&gt; (예 : &lt;code&gt;foo/./bar&lt;/code&gt; 및 &lt;code&gt;foo/../bar&lt;/code&gt; 가 유효하지 않음).</target>
        </trans-unit>
        <trans-unit id="7f82eaad3a65c9a817883e0946ba88f718561f76" translate="yes" xml:space="preserve">
          <source>contents:body</source>
          <target state="translated">contents:body</target>
        </trans-unit>
        <trans-unit id="004dd66ad61e821af675cee252b7cf444eeb2d67" translate="yes" xml:space="preserve">
          <source>contents:lines=N</source>
          <target state="translated">contents:lines=N</target>
        </trans-unit>
        <trans-unit id="9572f562015a5752e28b3bebea5fc2361d498ee9" translate="yes" xml:space="preserve">
          <source>contents:signature</source>
          <target state="translated">contents:signature</target>
        </trans-unit>
        <trans-unit id="df79a028903d27b28275b3e0c005205fc18b2272" translate="yes" xml:space="preserve">
          <source>contents:size</source>
          <target state="translated">contents:size</target>
        </trans-unit>
        <trans-unit id="396a924c6f0f2438b86784921e7cb965c470675c" translate="yes" xml:space="preserve">
          <source>contents:subject</source>
          <target state="translated">contents:subject</target>
        </trans-unit>
        <trans-unit id="f84e2e2dadd87384fb55f25886926b777e8378f1" translate="yes" xml:space="preserve">
          <source>copy</source>
          <target state="translated">copy</target>
        </trans-unit>
        <trans-unit id="753880bea3766d101203faa8107d6b67662465f8" translate="yes" xml:space="preserve">
          <source>core Git</source>
          <target state="translated">핵심 힘내</target>
        </trans-unit>
        <trans-unit id="cf2d457e7a43e7426ddc47f76a9a6a7862183c7f" translate="yes" xml:space="preserve">
          <source>core.abbrev</source>
          <target state="translated">core.abbrev</target>
        </trans-unit>
        <trans-unit id="959fa572026ec7a54a390cc12640898021a8d459" translate="yes" xml:space="preserve">
          <source>core.alternateRefsCommand</source>
          <target state="translated">core.alternateRefsCommand</target>
        </trans-unit>
        <trans-unit id="e33e687b217d932d15db39ed3050e1eb6acebe2b" translate="yes" xml:space="preserve">
          <source>core.alternateRefsPrefixes</source>
          <target state="translated">core.alternateRefsPrefixes</target>
        </trans-unit>
        <trans-unit id="8747276de34b700df1f943508c526a7183b4382b" translate="yes" xml:space="preserve">
          <source>core.askPass</source>
          <target state="translated">core.askPass</target>
        </trans-unit>
        <trans-unit id="985f595a65856adf06e0d3727b9aa6d13d9bf0f5" translate="yes" xml:space="preserve">
          <source>core.attributesFile</source>
          <target state="translated">core.attributesFile</target>
        </trans-unit>
        <trans-unit id="49d03e7330b6e6834b0a025eedf65f8789e6990f" translate="yes" xml:space="preserve">
          <source>core.autocrlf</source>
          <target state="translated">core.autocrlf</target>
        </trans-unit>
        <trans-unit id="41aced0e74b0f50ce3a863767e79c3dd95ced461" translate="yes" xml:space="preserve">
          <source>core.bare</source>
          <target state="translated">core.bare</target>
        </trans-unit>
        <trans-unit id="e288a05acad90cd62bdd35f16c2a74d2557da279" translate="yes" xml:space="preserve">
          <source>core.bigFileThreshold</source>
          <target state="translated">core.bigFileThreshold</target>
        </trans-unit>
        <trans-unit id="e40dc171f8c4201fcef997f8636d083827fd949c" translate="yes" xml:space="preserve">
          <source>core.checkRoundtripEncoding</source>
          <target state="translated">core.checkRoundtripEncoding</target>
        </trans-unit>
        <trans-unit id="087127ab1831a336ef5240c21330fb2f36d9a946" translate="yes" xml:space="preserve">
          <source>core.checkStat</source>
          <target state="translated">core.checkStat</target>
        </trans-unit>
        <trans-unit id="1f1aecebe341370b39e0fe9bece7db072d077803" translate="yes" xml:space="preserve">
          <source>core.commentChar</source>
          <target state="translated">core.commentChar</target>
        </trans-unit>
        <trans-unit id="6293d76f079a22e101e9bbf0baf6730ca74b9427" translate="yes" xml:space="preserve">
          <source>core.commitGraph</source>
          <target state="translated">core.commitGraph</target>
        </trans-unit>
        <trans-unit id="e8ce765916fbdaddaa7a32d9823ac3b895946aa3" translate="yes" xml:space="preserve">
          <source>core.compression</source>
          <target state="translated">core.compression</target>
        </trans-unit>
        <trans-unit id="69cec95e6eb16824ff7029c2f93a5f99d71e16aa" translate="yes" xml:space="preserve">
          <source>core.createObject</source>
          <target state="translated">core.createObject</target>
        </trans-unit>
        <trans-unit id="534532c82bb99a6e0bad1813625f951c19e3c12d" translate="yes" xml:space="preserve">
          <source>core.deltaBaseCacheLimit</source>
          <target state="translated">core.deltaBaseCacheLimit</target>
        </trans-unit>
        <trans-unit id="0df34be9da8577613d1baca7046b4ca05d06153b" translate="yes" xml:space="preserve">
          <source>core.editor</source>
          <target state="translated">core.editor</target>
        </trans-unit>
        <trans-unit id="45c390c885689ee572751a71343608f4da4baeb7" translate="yes" xml:space="preserve">
          <source>core.eol</source>
          <target state="translated">core.eol</target>
        </trans-unit>
        <trans-unit id="32132012be16a2aa8a584c5ca4848dab015b488d" translate="yes" xml:space="preserve">
          <source>core.excludesFile</source>
          <target state="translated">core.excludesFile</target>
        </trans-unit>
        <trans-unit id="9b550b8dedcdb6800c0224a979a3661b8d152782" translate="yes" xml:space="preserve">
          <source>core.fileMode</source>
          <target state="translated">core.fileMode</target>
        </trans-unit>
        <trans-unit id="05296f59a987a41149b85944096536bc976f3c93" translate="yes" xml:space="preserve">
          <source>core.filesRefLockTimeout</source>
          <target state="translated">core.filesRefLockTimeout</target>
        </trans-unit>
        <trans-unit id="a4ffde9710c513e0f386df441cf13371496d640f" translate="yes" xml:space="preserve">
          <source>core.fsmonitor</source>
          <target state="translated">core.fsmonitor</target>
        </trans-unit>
        <trans-unit id="b2761238696c7f67eed665d8a1e8214b9e4c0c9c" translate="yes" xml:space="preserve">
          <source>core.fsmonitorHookVersion</source>
          <target state="translated">core.fsmonitorHookVersion</target>
        </trans-unit>
        <trans-unit id="64c886772472a78d6c3811a927de267d4b589a96" translate="yes" xml:space="preserve">
          <source>core.fsyncObjectFiles</source>
          <target state="translated">core.fsyncObjectFiles</target>
        </trans-unit>
        <trans-unit id="a9ced9da30cdcb8a77e1dddcf9ffddef755d646b" translate="yes" xml:space="preserve">
          <source>core.gitProxy</source>
          <target state="translated">core.gitProxy</target>
        </trans-unit>
        <trans-unit id="66ebcf3992ed3efd9fcd27129f808916fddc9e92" translate="yes" xml:space="preserve">
          <source>core.hideDotFiles</source>
          <target state="translated">core.hideDotFiles</target>
        </trans-unit>
        <trans-unit id="ca95d87902e9e0a13b358de2f6c3174a24e741cc" translate="yes" xml:space="preserve">
          <source>core.hooksPath</source>
          <target state="translated">core.hooksPath</target>
        </trans-unit>
        <trans-unit id="3480cdcecea2adb7a9d9c9137541b53446cd2d14" translate="yes" xml:space="preserve">
          <source>core.ignoreCase</source>
          <target state="translated">core.ignoreCase</target>
        </trans-unit>
        <trans-unit id="4d45bf4e4383961083ebc5904242284e51c51b32" translate="yes" xml:space="preserve">
          <source>core.ignoreStat</source>
          <target state="translated">core.ignoreStat</target>
        </trans-unit>
        <trans-unit id="5a4abf6f4fdfa67755a470108e5997c5ba1e60cd" translate="yes" xml:space="preserve">
          <source>core.logAllRefUpdates</source>
          <target state="translated">core.logAllRefUpdates</target>
        </trans-unit>
        <trans-unit id="bf566f6f5a72af0bbdf49e11b4d0ab0a36d4feb4" translate="yes" xml:space="preserve">
          <source>core.looseCompression</source>
          <target state="translated">core.looseCompression</target>
        </trans-unit>
        <trans-unit id="4dc00883effd961e2b3388ee13eda97e227a1f0f" translate="yes" xml:space="preserve">
          <source>core.multiPackIndex</source>
          <target state="translated">core.multiPackIndex</target>
        </trans-unit>
        <trans-unit id="411fa7fa4424e8bc70d80fa2582efc8afa88cede" translate="yes" xml:space="preserve">
          <source>core.notesRef</source>
          <target state="translated">core.notesRef</target>
        </trans-unit>
        <trans-unit id="5ba4b1e12fc45c4ab2cb8689ed7aea827bc7fc35" translate="yes" xml:space="preserve">
          <source>core.packedGitLimit</source>
          <target state="translated">core.packedGitLimit</target>
        </trans-unit>
        <trans-unit id="977d9f503ba50c99fdbf73b0c1e4daec7d1141ee" translate="yes" xml:space="preserve">
          <source>core.packedGitWindowSize</source>
          <target state="translated">core.packedGitWindowSize</target>
        </trans-unit>
        <trans-unit id="542fd696a3aacac0b7dc3a9cdbe129fc8a34021c" translate="yes" xml:space="preserve">
          <source>core.packedRefsTimeout</source>
          <target state="translated">core.packedRefsTimeout</target>
        </trans-unit>
        <trans-unit id="7d09a05b657fb56dce310f9c91322125e34df242" translate="yes" xml:space="preserve">
          <source>core.pager</source>
          <target state="translated">core.pager</target>
        </trans-unit>
        <trans-unit id="2bb8a01b99a9f4829fd68a0a514f72fed85849a2" translate="yes" xml:space="preserve">
          <source>core.precomposeUnicode</source>
          <target state="translated">core.precomposeUnicode</target>
        </trans-unit>
        <trans-unit id="7f7681a0f982fe07fb3e3e0a4a1cbf0ac6578ab6" translate="yes" xml:space="preserve">
          <source>core.preferSymlinkRefs</source>
          <target state="translated">core.preferSymlinkRefs</target>
        </trans-unit>
        <trans-unit id="b40d6114f528e1b12e69abf2bc8c8a1e1e0729a1" translate="yes" xml:space="preserve">
          <source>core.preloadIndex</source>
          <target state="translated">core.preloadIndex</target>
        </trans-unit>
        <trans-unit id="d3884090559963254921436275cc7910424beeaa" translate="yes" xml:space="preserve">
          <source>core.protectHFS</source>
          <target state="translated">core.protectHFS</target>
        </trans-unit>
        <trans-unit id="2b6e49157831a2fd7cc374aed4b8e3fcfe9a65cc" translate="yes" xml:space="preserve">
          <source>core.protectNTFS</source>
          <target state="translated">core.protectNTFS</target>
        </trans-unit>
        <trans-unit id="b7aa334c221baeac993f8dfab5a01de5f55246c5" translate="yes" xml:space="preserve">
          <source>core.quotePath</source>
          <target state="translated">core.quotePath</target>
        </trans-unit>
        <trans-unit id="03339150599c8de471a17c6acbe60398b29d423b" translate="yes" xml:space="preserve">
          <source>core.repositoryFormatVersion</source>
          <target state="translated">core.repositoryFormatVersion</target>
        </trans-unit>
        <trans-unit id="affcdeb4b4ce60fafd53e206d623606a5e5478c1" translate="yes" xml:space="preserve">
          <source>core.restrictinheritedhandles</source>
          <target state="translated">core.restrictinheritedhandles</target>
        </trans-unit>
        <trans-unit id="648cabb503e5fa7696f73461722da70b9f497bb3" translate="yes" xml:space="preserve">
          <source>core.safecrlf</source>
          <target state="translated">core.safecrlf</target>
        </trans-unit>
        <trans-unit id="041606f3c0e6886da1433d0087f69fb92d8084c1" translate="yes" xml:space="preserve">
          <source>core.sharedRepository</source>
          <target state="translated">core.sharedRepository</target>
        </trans-unit>
        <trans-unit id="23ff5bba90ce061198d5e3ffc841a43fbb70cec6" translate="yes" xml:space="preserve">
          <source>core.sparseCheckout</source>
          <target state="translated">core.sparseCheckout</target>
        </trans-unit>
        <trans-unit id="18ca82d3256618e136b9c3dce7e7b8cbe92e10ca" translate="yes" xml:space="preserve">
          <source>core.sparseCheckoutCone</source>
          <target state="translated">core.sparseCheckoutCone</target>
        </trans-unit>
        <trans-unit id="34de7b3533f8a473368f31e9c9d471a47de937d8" translate="yes" xml:space="preserve">
          <source>core.splitIndex</source>
          <target state="translated">core.splitIndex</target>
        </trans-unit>
        <trans-unit id="e93900ed78f99070ecf58770317ad13ec69ebdb9" translate="yes" xml:space="preserve">
          <source>core.sshCommand</source>
          <target state="translated">core.sshCommand</target>
        </trans-unit>
        <trans-unit id="ecef62dcf909d9b3b8008c85744589fe969d6e8c" translate="yes" xml:space="preserve">
          <source>core.symlinks</source>
          <target state="translated">core.symlinks</target>
        </trans-unit>
        <trans-unit id="3543db8c28952b3c897e97d6802bfb4b20a29f0c" translate="yes" xml:space="preserve">
          <source>core.trustctime</source>
          <target state="translated">core.trustctime</target>
        </trans-unit>
        <trans-unit id="e86e3acca3c2b5a8a428d5e913a3c20e6a8702f3" translate="yes" xml:space="preserve">
          <source>core.unsetenvvars</source>
          <target state="translated">core.unsetenvvars</target>
        </trans-unit>
        <trans-unit id="80e48caf217388fbd4f5f02d89e4cbe9ca2c0411" translate="yes" xml:space="preserve">
          <source>core.untrackedCache</source>
          <target state="translated">core.untrackedCache</target>
        </trans-unit>
        <trans-unit id="30eb2028c48e825c8972323ceb5f2720a28cb1a4" translate="yes" xml:space="preserve">
          <source>core.useReplaceRefs</source>
          <target state="translated">core.useReplaceRefs</target>
        </trans-unit>
        <trans-unit id="79f3ab5bc823c093f6caec9ad2bfd91cd1ecc66f" translate="yes" xml:space="preserve">
          <source>core.warnAmbiguousRefs</source>
          <target state="translated">core.warnAmbiguousRefs</target>
        </trans-unit>
        <trans-unit id="8035c328e586f1ddd34491be18e332e06245400a" translate="yes" xml:space="preserve">
          <source>core.whitespace</source>
          <target state="translated">core.whitespace</target>
        </trans-unit>
        <trans-unit id="42d3882207da2f1b2f766aa2038286367d209134" translate="yes" xml:space="preserve">
          <source>core.worktree</source>
          <target state="translated">core.worktree</target>
        </trans-unit>
        <trans-unit id="54e5d8d2fde10ff9ed2d854151648ef7ea276424" translate="yes" xml:space="preserve">
          <source>count-objects</source>
          <target state="translated">count-objects</target>
        </trans-unit>
        <trans-unit id="1f1b8fb0c26d2f97cf91a600eee3651686523a54" translate="yes" xml:space="preserve">
          <source>count: the number of loose objects</source>
          <target state="translated">개수 : 느슨한 개체 수</target>
        </trans-unit>
        <trans-unit id="9b7c68a918b17eb053809b198d7c9abfc142f30a" translate="yes" xml:space="preserve">
          <source>create</source>
          <target state="translated">create</target>
        </trans-unit>
        <trans-unit id="a8a783c8e8d5a2d764d09f23941a70af82a68926" translate="yes" xml:space="preserve">
          <source>create [options] &amp;lt;file&amp;gt; &amp;lt;git-rev-list-args&amp;gt;</source>
          <target state="translated">[옵션] &amp;lt;파일&amp;gt; &amp;lt;git-rev-list-args&amp;gt; 생성</target>
        </trans-unit>
        <trans-unit id="a898c3bab873d4c64f82ded72f74751a576962d7" translate="yes" xml:space="preserve">
          <source>create a new branch &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; referencing &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt;, and check it out.</source>
          <target state="translated">&lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; 를 참조 하는 새 분기 &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; 를 작성 하고 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2ec8a8a26d58d8e3ee0942abe268f42f92be4034" translate="yes" xml:space="preserve">
          <source>create a new branch named &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;, referencing &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt;, which may be specified any way you like, including using a branch name or a tag name.</source>
          <target state="translated">&lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; 를 참조하여 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 라는 새 분기를 작성하십시오 . 분기 이름 또는 태그 이름 사용을 포함하여 원하는 방식으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51140d4c076694cbb659019fe0cefe5beceea402" translate="yes" xml:space="preserve">
          <source>create a new branch named &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;, referencing the same point in history as the current branch.</source>
          <target state="translated">현재 브랜치와 동일한 히스토리 포인트를 참조하여 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 라는 새 브랜치를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="b076b7781ba9692a9725f8363bc2b545e61793ca" translate="yes" xml:space="preserve">
          <source>create a new topic branch.</source>
          <target state="translated">새로운 토픽 브랜치를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="187986ac8c2db8ed95278b39dffb6ad5292dbdbb" translate="yes" xml:space="preserve">
          <source>create a private branch based on a well known (but somewhat behind) tag.</source>
          <target state="translated">잘 알려진 태그를 기반으로 개인 브랜치를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2acb56aff24c2a5c989226a06af1695579ccf6ea" translate="yes" xml:space="preserve">
          <source>create a signed tag.</source>
          <target state="translated">서명 된 태그를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7389c4f321260703fe1b7e54968834b25c9f4479" translate="yes" xml:space="preserve">
          <source>create topic branch as needed and apply, again with sign-offs.</source>
          <target state="translated">필요에 따라 토픽 브랜치를 작성하고 사인 오프와 함께 다시 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="4ecc2ef111c576a677976da0784792e85675361c" translate="yes" xml:space="preserve">
          <source>create_virtual_base</source>
          <target state="translated">create_virtual_base</target>
        </trans-unit>
        <trans-unit id="4ebb9962b36526d09c78d0036ae93adf9be65bb8" translate="yes" xml:space="preserve">
          <source>creates a new branch &lt;code&gt;foo&lt;/code&gt;, which refers to commit &lt;code&gt;f&lt;/code&gt;, and then updates &lt;code&gt;HEAD&lt;/code&gt; to refer to branch &lt;code&gt;foo&lt;/code&gt;. In other words, we&amp;rsquo;ll no longer be in detached &lt;code&gt;HEAD&lt;/code&gt; state after this command.</source>
          <target state="translated">commit &lt;code&gt;f&lt;/code&gt; 를 나타내는 새로운 브랜치 &lt;code&gt;foo&lt;/code&gt; 를 작성해, &lt;code&gt;HEAD&lt;/code&gt; 를 갱신 해 브랜치 &lt;code&gt;foo&lt;/code&gt; 를 참조합니다 . 다시 말해, 이 명령 후에 는 더 이상 &lt;code&gt;HEAD&lt;/code&gt; 상태가 해제 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a2780f5a5ae6b5c97641f872834c2cb4d320d58a" translate="yes" xml:space="preserve">
          <source>creates a new tag &lt;code&gt;foo&lt;/code&gt;, which refers to commit &lt;code&gt;f&lt;/code&gt;, leaving &lt;code&gt;HEAD&lt;/code&gt; detached.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 가 분리 된 상태로 두고 커밋 &lt;code&gt;f&lt;/code&gt; 를 참조 하는 새 태그 &lt;code&gt;foo&lt;/code&gt; 를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="a57e6b47e2a17463754373ddfae9e8d12eafb7f1" translate="yes" xml:space="preserve">
          <source>credential.&amp;lt;url&amp;gt;.*</source>
          <target state="translated">credential.&amp;lt;url&amp;gt;.*</target>
        </trans-unit>
        <trans-unit id="f1a609951f4c2b322a1db183ee7a7012be55b9c5" translate="yes" xml:space="preserve">
          <source>credential.helper</source>
          <target state="translated">credential.helper</target>
        </trans-unit>
        <trans-unit id="bca119ff50602816772dd2a73dfaa6eb8e0f9d85" translate="yes" xml:space="preserve">
          <source>credential.useHttpPath</source>
          <target state="translated">credential.useHttpPath</target>
        </trans-unit>
        <trans-unit id="deb46e03a8fd122d820256e55cd3990b2283558e" translate="yes" xml:space="preserve">
          <source>credential.username</source>
          <target state="translated">credential.username</target>
        </trans-unit>
        <trans-unit id="146c12f7287e0d749211abe1d0e06d591f31ab67" translate="yes" xml:space="preserve">
          <source>credentialCache.ignoreSIGHUP</source>
          <target state="translated">credentialCache.ignoreSIGHUP</target>
        </trans-unit>
        <trans-unit id="5e084be34d9cae64271f7da4c667c3655b7c7e2b" translate="yes" xml:space="preserve">
          <source>custom command</source>
          <target state="translated">맞춤 명령</target>
        </trans-unit>
        <trans-unit id="9ebf0f6534e0ecb2ebc0f3a751992712eb4613ba" translate="yes" xml:space="preserve">
          <source>cvs2git (part of cvs2svn), &lt;code&gt;http://subversion.apache.org/&lt;/code&gt;</source>
          <target state="translated">cvs2git (cvs2svn의 일부), &lt;code&gt;http://subversion.apache.org/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f43e99b19c6164c2e4a665306629741686b4ce5f" translate="yes" xml:space="preserve">
          <source>cvsexportcommit.cvsdir</source>
          <target state="translated">cvsexportcommit.cvsdir</target>
        </trans-unit>
        <trans-unit id="4eb7a17655440a77cf067e6d109036a13dfa5100" translate="yes" xml:space="preserve">
          <source>daemon</source>
          <target state="translated">daemon</target>
        </trans-unit>
        <trans-unit id="e94d5484c16090a3e6a43ed503b6bea30fc975cf" translate="yes" xml:space="preserve">
          <source>dangling &amp;lt;type&amp;gt; &amp;lt;object&amp;gt;</source>
          <target state="translated">매달려있는 &amp;lt;type&amp;gt; &amp;lt;object&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e0c1aa7fe06eb7c60d97afffb45c61c3a246186f" translate="yes" xml:space="preserve">
          <source>dangling object</source>
          <target state="translated">매달려있는 물건</target>
        </trans-unit>
        <trans-unit id="a710350f8f7e9f1cf8e2244f994dbced90cfa77e" translate="yes" xml:space="preserve">
          <source>date-format</source>
          <target state="translated">date-format</target>
        </trans-unit>
        <trans-unit id="7505d64a54e061b7acd54ccd58b49dc43500b635" translate="yes" xml:space="preserve">
          <source>default</source>
          <target state="translated">default</target>
        </trans-unit>
        <trans-unit id="796bbc8375f4407bde99e8ccd19980e271be2818" translate="yes" xml:space="preserve">
          <source>deinit [-f|--force] (--all|[--] &amp;lt;path&amp;gt;&amp;hellip;​)</source>
          <target state="translated">deinit [-f | --force] (--all | [-] &amp;lt;경로&amp;gt;&amp;hellip;)</target>
        </trans-unit>
        <trans-unit id="9485989ff514b5106b7738850fd73c23e8c1e3f7" translate="yes" xml:space="preserve">
          <source>delete</source>
          <target state="translated">delete</target>
        </trans-unit>
        <trans-unit id="1de1d8f7b6ce28448c7c654857cfbcf4eb2a487c" translate="yes" xml:space="preserve">
          <source>delete the branch &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; irrespective of its merged status.</source>
          <target state="translated">병합 된 상태에 관계없이 분기 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 를 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee032bd4cb79a16b41a9cddaa6801aa39ad00d69" translate="yes" xml:space="preserve">
          <source>delete the branch &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;; if the branch is not fully merged in its upstream branch or contained in the current branch, this command will fail with a warning.</source>
          <target state="translated">&lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 분기를 삭제하십시오 . 분기가 업스트림 분기에 완전히 병합되지 않았거나 현재 분기에 포함되어 있지 않으면이 명령이 경고와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="860bd09ca701b7eefc6bffda982580c223ef997b" translate="yes" xml:space="preserve">
          <source>deleting context or removal lines</source>
          <target state="translated">문맥 또는 제거 라인 삭제</target>
        </trans-unit>
        <trans-unit id="c8879b695b81cf545d60b18c91cdfb8806b36522" translate="yes" xml:space="preserve">
          <source>deltabase</source>
          <target state="translated">deltabase</target>
        </trans-unit>
        <trans-unit id="d27e9e35c8b1a62a6240ab9f98d5fced70539520" translate="yes" xml:space="preserve">
          <source>deltawalker</source>
          <target state="translated">deltawalker</target>
        </trans-unit>
        <trans-unit id="dbc3503fab0104483514b05f547b64029db5e57c" translate="yes" xml:space="preserve">
          <source>describe</source>
          <target state="translated">describe</target>
        </trans-unit>
        <trans-unit id="ed59ca2a7cc7e281e5bde10bab226dd9168fa10c" translate="yes" xml:space="preserve">
          <source>description (or &lt;code&gt;gitweb.description&lt;/code&gt;)</source>
          <target state="translated">설명 (또는 &lt;code&gt;gitweb.description&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ac1ce32f2ed519a514236b9d0b38fe3cf2658a8b" translate="yes" xml:space="preserve">
          <source>detached HEAD</source>
          <target state="translated">분리 된 HEAD</target>
        </trans-unit>
        <trans-unit id="75205c21546c14079be2a62786e02d33b07e187b" translate="yes" xml:space="preserve">
          <source>detachedHead</source>
          <target state="translated">detachedHead</target>
        </trans-unit>
        <trans-unit id="8f595011a3953aff6b7fb36fe731811b418b47b0" translate="yes" xml:space="preserve">
          <source>die</source>
          <target state="translated">die</target>
        </trans-unit>
        <trans-unit id="884997f14fc1c1d69600d809d03fc588ba3a30b0" translate="yes" xml:space="preserve">
          <source>die with the usage message.</source>
          <target state="translated">사용법 메시지와 함께 죽습니다.</target>
        </trans-unit>
        <trans-unit id="75a0ee1ba911f2f5199177dfd31808a12511bbdc" translate="yes" xml:space="preserve">
          <source>diff</source>
          <target state="translated">diff</target>
        </trans-unit>
        <trans-unit id="aec63b21c7ff7719699fd2311e4f5955f8100284" translate="yes" xml:space="preserve">
          <source>diff(1), &lt;a href=&quot;git-difftool&quot;&gt;git-difftool[1]&lt;/a&gt;, &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore[7]&lt;/a&gt;, &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;, &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;</source>
          <target state="translated">diff (1), &lt;a href=&quot;git-difftool&quot;&gt;git-difftool [1]&lt;/a&gt; , &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore [7]&lt;/a&gt; , &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; , &lt;a href=&quot;git-apply&quot;&gt;git-apply [1]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f7baf889d118863654abfc71095ed4b73fb9cc08" translate="yes" xml:space="preserve">
          <source>diff(1), &lt;a href=&quot;git-difftool&quot;&gt;git-difftool[1]&lt;/a&gt;, &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore[7]&lt;/a&gt;, &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;, &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;</source>
          <target state="translated">diff (1), &lt;a href=&quot;git-difftool&quot;&gt;git-difftool [1]&lt;/a&gt; , &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore [7]&lt;/a&gt; , &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; , &lt;a href=&quot;git-apply&quot;&gt;git-apply [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="274926922d975d8638e23e8b6937fee0ace1f2ff" translate="yes" xml:space="preserve">
          <source>diff-algorithm=[patience|minimal|histogram|myers]</source>
          <target state="translated">diff-algorithm=[patience|minimal|histogram|myers]</target>
        </trans-unit>
        <trans-unit id="dc444c758109146345f9f5bfd883892188e6a3fc" translate="yes" xml:space="preserve">
          <source>diff-index</source>
          <target state="translated">diff-index</target>
        </trans-unit>
        <trans-unit id="4250edb32c8b97105f57b5a5eab36d48f7b1949b" translate="yes" xml:space="preserve">
          <source>diff.&amp;lt;driver&amp;gt;.binary</source>
          <target state="translated">diff.&amp;lt;driver&amp;gt;.binary</target>
        </trans-unit>
        <trans-unit id="d49144cceb4a510ce4eff54a03fb58d928e50c49" translate="yes" xml:space="preserve">
          <source>diff.&amp;lt;driver&amp;gt;.cachetextconv</source>
          <target state="translated">diff.&amp;lt;driver&amp;gt;.cachetextconv</target>
        </trans-unit>
        <trans-unit id="7ebd2638a9921e5e179343b4427fc869a06f2204" translate="yes" xml:space="preserve">
          <source>diff.&amp;lt;driver&amp;gt;.command</source>
          <target state="translated">diff.&amp;lt;driver&amp;gt;.command</target>
        </trans-unit>
        <trans-unit id="61d06fdfc5aa3502d4b6a108e48a59fce26c6af2" translate="yes" xml:space="preserve">
          <source>diff.&amp;lt;driver&amp;gt;.textconv</source>
          <target state="translated">diff.&amp;lt;driver&amp;gt;.textconv</target>
        </trans-unit>
        <trans-unit id="ead4540609df4e51a37712a575abec00dc7e55b2" translate="yes" xml:space="preserve">
          <source>diff.&amp;lt;driver&amp;gt;.wordRegex</source>
          <target state="translated">diff.&amp;lt;driver&amp;gt;.wordRegex</target>
        </trans-unit>
        <trans-unit id="588167e2d54a806f940bc95d7efb7d86bfb75066" translate="yes" xml:space="preserve">
          <source>diff.&amp;lt;driver&amp;gt;.xfuncname</source>
          <target state="translated">diff.&amp;lt;driver&amp;gt;.xfuncname</target>
        </trans-unit>
        <trans-unit id="1aa3404f7e2e71cad7f5ed988403e8543a3c69da" translate="yes" xml:space="preserve">
          <source>diff.algorithm</source>
          <target state="translated">diff.algorithm</target>
        </trans-unit>
        <trans-unit id="0f8247f3bb857074064263268e6668bc675b886b" translate="yes" xml:space="preserve">
          <source>diff.autoRefreshIndex</source>
          <target state="translated">diff.autoRefreshIndex</target>
        </trans-unit>
        <trans-unit id="bf1e6527ec1ecc87c9aa892e1d248e935b08af96" translate="yes" xml:space="preserve">
          <source>diff.colorMoved</source>
          <target state="translated">diff.colorMoved</target>
        </trans-unit>
        <trans-unit id="17f5cafc5e8e284a925693c37b5e6cf682892ea2" translate="yes" xml:space="preserve">
          <source>diff.colorMovedWS</source>
          <target state="translated">diff.colorMovedWS</target>
        </trans-unit>
        <trans-unit id="be88a0a0926f0ec0095677f97e7ad676290b3606" translate="yes" xml:space="preserve">
          <source>diff.context</source>
          <target state="translated">diff.context</target>
        </trans-unit>
        <trans-unit id="504e46e3b7d5dfac355ed7626600d0b5de3ec8b1" translate="yes" xml:space="preserve">
          <source>diff.dirstat</source>
          <target state="translated">diff.dirstat</target>
        </trans-unit>
        <trans-unit id="f504a39405787fdfe57c004f1eb6cc3e0a445e22" translate="yes" xml:space="preserve">
          <source>diff.external</source>
          <target state="translated">diff.external</target>
        </trans-unit>
        <trans-unit id="724df5839bd28c42c831c8e74afe774a8b74cca2" translate="yes" xml:space="preserve">
          <source>diff.guitool</source>
          <target state="translated">diff.guitool</target>
        </trans-unit>
        <trans-unit id="78a8a530a7ec63e351c3937d0ea3e9c7b5c53bf6" translate="yes" xml:space="preserve">
          <source>diff.ignoreSubmodules</source>
          <target state="translated">diff.ignoreSubmodules</target>
        </trans-unit>
        <trans-unit id="2f87c8a57b25ea0080655c45cbc2964d86105934" translate="yes" xml:space="preserve">
          <source>diff.indentHeuristic</source>
          <target state="translated">diff.indentHeuristic</target>
        </trans-unit>
        <trans-unit id="6725f50766e063a286c387dfae2b760b7179eada" translate="yes" xml:space="preserve">
          <source>diff.interHunkContext</source>
          <target state="translated">diff.interHunkContext</target>
        </trans-unit>
        <trans-unit id="464cb39ab3bdafc5444bd68bf755682212470cc3" translate="yes" xml:space="preserve">
          <source>diff.mnemonicPrefix</source>
          <target state="translated">diff.mnemonicPrefix</target>
        </trans-unit>
        <trans-unit id="cdb032dcff9da1664b3a256e37700fe12cc96893" translate="yes" xml:space="preserve">
          <source>diff.noprefix</source>
          <target state="translated">diff.noprefix</target>
        </trans-unit>
        <trans-unit id="6c317017d113fddeae67f71ba0f6777e2b5871bb" translate="yes" xml:space="preserve">
          <source>diff.orderFile</source>
          <target state="translated">diff.orderFile</target>
        </trans-unit>
        <trans-unit id="a4d75f933b8d2d14f171e5e121ccc6333839f72b" translate="yes" xml:space="preserve">
          <source>diff.relative</source>
          <target state="translated">diff.relative</target>
        </trans-unit>
        <trans-unit id="62b4f867480cadbda91ca883571c3f0f4636ec5e" translate="yes" xml:space="preserve">
          <source>diff.renameLimit</source>
          <target state="translated">diff.renameLimit</target>
        </trans-unit>
        <trans-unit id="288ec59a707ad0e05ddeff32c90f0931bfa1abf6" translate="yes" xml:space="preserve">
          <source>diff.renames</source>
          <target state="translated">diff.renames</target>
        </trans-unit>
        <trans-unit id="ee391988a16ac1f7ecbd358f95c72fc4f48a9afb" translate="yes" xml:space="preserve">
          <source>diff.statGraphWidth</source>
          <target state="translated">diff.statGraphWidth</target>
        </trans-unit>
        <trans-unit id="385c04e351b4e623ba3a9fe788dcf29ec4558e41" translate="yes" xml:space="preserve">
          <source>diff.submodule</source>
          <target state="translated">diff.submodule</target>
        </trans-unit>
        <trans-unit id="afc54bc32125efd47622a9cab44636c5c6e922af" translate="yes" xml:space="preserve">
          <source>diff.suppressBlankEmpty</source>
          <target state="translated">diff.suppressBlankEmpty</target>
        </trans-unit>
        <trans-unit id="c19a767aeb832dda13c39ec76dc85ad7aee82efe" translate="yes" xml:space="preserve">
          <source>diff.tool</source>
          <target state="translated">diff.tool</target>
        </trans-unit>
        <trans-unit id="35dfdde1514e0e8beec0bc8558ccf4666f63c900" translate="yes" xml:space="preserve">
          <source>diff.wordRegex</source>
          <target state="translated">diff.wordRegex</target>
        </trans-unit>
        <trans-unit id="2e6f5f0361c86bf9ad2e357af0ffe5f130cf4d79" translate="yes" xml:space="preserve">
          <source>diff.wsErrorHighlight</source>
          <target state="translated">diff.wsErrorHighlight</target>
        </trans-unit>
        <trans-unit id="c6f1c4ebb1620fc2ac6d14ccb0aadb5ab259dc0c" translate="yes" xml:space="preserve">
          <source>diffcore-break</source>
          <target state="translated">diffcore-break</target>
        </trans-unit>
        <trans-unit id="b028ee38bbcbeeb7238e3bfd063237adeeba443a" translate="yes" xml:space="preserve">
          <source>diffcore-merge-broken</source>
          <target state="translated">diffcore-merge-broken</target>
        </trans-unit>
        <trans-unit id="db71223480c667aaa4574a26ad978574030dda8d" translate="yes" xml:space="preserve">
          <source>diffcore-order</source>
          <target state="translated">diffcore-order</target>
        </trans-unit>
        <trans-unit id="467c165cac1b0ba18ec8b5f79dedd2da85446437" translate="yes" xml:space="preserve">
          <source>diffcore-pickaxe</source>
          <target state="translated">diffcore-pickaxe</target>
        </trans-unit>
        <trans-unit id="6187904d774523191d18782a391f12275e67f3f6" translate="yes" xml:space="preserve">
          <source>diffcore-rename</source>
          <target state="translated">diffcore-rename</target>
        </trans-unit>
        <trans-unit id="f6300b5e173bb665f89b10ef769cbcd18db00e97" translate="yes" xml:space="preserve">
          <source>diffmerge</source>
          <target state="translated">diffmerge</target>
        </trans-unit>
        <trans-unit id="dfc45b9be8469f19a2b40b78d2350e275d971b41" translate="yes" xml:space="preserve">
          <source>difftool</source>
          <target state="translated">difftool</target>
        </trans-unit>
        <trans-unit id="144e9a5ad6d7b5676b4c5767c1e25ae3105559ea" translate="yes" xml:space="preserve">
          <source>difftool.&amp;lt;tool&amp;gt;.cmd</source>
          <target state="translated">difftool.&amp;lt;tool&amp;gt;.cmd</target>
        </trans-unit>
        <trans-unit id="a28c931a5c78d115db5afdc9d340ea605d7adf13" translate="yes" xml:space="preserve">
          <source>difftool.&amp;lt;tool&amp;gt;.path</source>
          <target state="translated">difftool.&amp;lt;tool&amp;gt;.path</target>
        </trans-unit>
        <trans-unit id="44894935c65135499020223eb3dca0286170b476" translate="yes" xml:space="preserve">
          <source>difftool.prompt</source>
          <target state="translated">difftool.prompt</target>
        </trans-unit>
        <trans-unit id="ff525f598fd509121274a14ac2fbfcc4f4088c02" translate="yes" xml:space="preserve">
          <source>difftool.trustExitCode</source>
          <target state="translated">difftool.trustExitCode</target>
        </trans-unit>
        <trans-unit id="68c1822a6b21b21d1582cf96e31c25f769027db0" translate="yes" xml:space="preserve">
          <source>diffuse</source>
          <target state="translated">diffuse</target>
        </trans-unit>
        <trans-unit id="d59e9acd29cb5ef98e7898689890a7079d11aba0" translate="yes" xml:space="preserve">
          <source>dimmed-zebra</source>
          <target state="translated">dimmed-zebra</target>
        </trans-unit>
        <trans-unit id="8d392f56d616a516ceabb82ed8906418bce4647d" translate="yes" xml:space="preserve">
          <source>directory</source>
          <target state="translated">directory</target>
        </trans-unit>
        <trans-unit id="33797be57bc3b248fc5bfafd60af55a61787ce85" translate="yes" xml:space="preserve">
          <source>dirty</source>
          <target state="translated">dirty</target>
        </trans-unit>
        <trans-unit id="9c5133a04600b8ce7520ccf8d3ffb307df06156d" translate="yes" xml:space="preserve">
          <source>display the trailers of the body as interpreted by &lt;a href=&quot;git-interpret-trailers&quot;&gt;git-interpret-trailers[1]&lt;/a&gt;. The &lt;code&gt;trailers&lt;/code&gt; string may be followed by a colon and zero or more comma-separated options:</source>
          <target state="translated">&lt;a href=&quot;git-interpret-trailers&quot;&gt;git-interpret-trailers [1]에&lt;/a&gt; 의해 해석 된대로 몸의 트레일러를 표시하십시오 . &lt;code&gt;trailers&lt;/code&gt; 문자열 콜론과 0 개 이상의 옵션 쉼표로 구분 하였다 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="d36ef8813bcb9b9bf679b7af99e6a1c56b310918" translate="yes" xml:space="preserve">
          <source>displayed as repository owner, preferably full name, or email, or both</source>
          <target state="translated">저장소 소유자, 바람직하게는 전체 이름 또는 이메일 또는 둘 다로 표시</target>
        </trans-unit>
        <trans-unit id="8e6362104fa1f26faa92fbbf61d423a1671922aa" translate="yes" xml:space="preserve">
          <source>do not consider the on-disk file at all</source>
          <target state="translated">온 디스크 파일을 전혀 고려하지 마십시오</target>
        </trans-unit>
        <trans-unit id="e5fd9cfe0e8039111d54b588e77b2bb0cad41c3a" translate="yes" xml:space="preserve">
          <source>done</source>
          <target state="translated">done</target>
        </trans-unit>
        <trans-unit id="8106f0273274bf1355fb25f86c12166c7db5a680" translate="yes" xml:space="preserve">
          <source>drop [-q|--quiet] [&amp;lt;stash&amp;gt;]</source>
          <target state="translated">드롭 [-q | --quiet] [&amp;lt;stash&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="c4d01c9966dec002308719ba67feccf138a76bbf" translate="yes" xml:space="preserve">
          <source>e.g. those using: &lt;code&gt;$ git push/pull ssh://host.xz/pub/scm/project&lt;/code&gt;</source>
          <target state="translated">예 : &lt;code&gt;$ git push/pull ssh://host.xz/pub/scm/project&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="054950f0be331d1dfaea2966ac925611fede3ef2" translate="yes" xml:space="preserve">
          <source>e.g: &lt;code&gt;void trace2_child_start(struct child_process *cmd)&lt;/code&gt;.</source>
          <target state="translated">예 : &lt;code&gt;void trace2_child_start(struct child_process *cmd)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24d5501e7a7d473740d7a940309daf5454362989" translate="yes" xml:space="preserve">
          <source>e.g: &lt;code&gt;void trace2_thread_start(const char *thread_name)&lt;/code&gt;.</source>
          <target state="translated">예 : &lt;code&gt;void trace2_thread_start(const char *thread_name)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e52e25ac96e1d66591fa10b6bb147d974edb8fd9" translate="yes" xml:space="preserve">
          <source>ecmerge</source>
          <target state="translated">ecmerge</target>
        </trans-unit>
        <trans-unit id="9ead47a82a0d25985f22f10651d1f93b3abba317" translate="yes" xml:space="preserve">
          <source>edit</source>
          <target state="translated">edit</target>
        </trans-unit>
        <trans-unit id="f50ee013a90f77e88dab49109ac0f01191487f60" translate="yes" xml:space="preserve">
          <source>either per-instance configuration file (defaults to &lt;code&gt;gitweb_config.perl&lt;/code&gt; in the same directory as the installed gitweb), or if it does not exists then fallback system-wide configuration file (defaults to &lt;code&gt;/etc/gitweb.conf&lt;/code&gt;).</source>
          <target state="translated">인스턴스 별 구성 파일 ( 설치된 gitweb과 동일한 디렉토리의 기본값은 &lt;code&gt;gitweb_config.perl&lt;/code&gt; )이거나 존재하지 않는 경우 시스템 전체 구성 파일 (기본값은 &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="053b84dedd551a21a9522c8b2a33970481edc307" translate="yes" xml:space="preserve">
          <source>emerge</source>
          <target state="translated">emerge</target>
        </trans-unit>
        <trans-unit id="14a9dc09e10179b15beaf94c0aed53904ace0336" translate="yes" xml:space="preserve">
          <source>encoding</source>
          <target state="translated">encoding</target>
        </trans-unit>
        <trans-unit id="57b54923aa1434283222d0eaa56f70e38ad84ac8" translate="yes" xml:space="preserve">
          <source>end with a directory separator (e.g. &lt;code&gt;foo/&lt;/code&gt; is invalid),</source>
          <target state="translated">디렉토리 구분자로 끝납니다 (예 : &lt;code&gt;foo/&lt;/code&gt; 는 유효하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="9de133ff4f5a5221c7e34904f52bc66b8ea1d389" translate="yes" xml:space="preserve">
          <source>eval_gettext</source>
          <target state="translated">eval_gettext</target>
        </trans-unit>
        <trans-unit id="5c37fe1cd392af8581c87c9ebad09ddefde4ca30" translate="yes" xml:space="preserve">
          <source>even after you edit it.</source>
          <target state="translated">편집 한 후에도.</target>
        </trans-unit>
        <trans-unit id="a22dcc09943359cdcbf27e44706eaae877265da0" translate="yes" xml:space="preserve">
          <source>even if you succeed at the map-deletes-for-renames chicanery, you still technically violate backward compatibility because users are allowed to filter files in ways that depend upon topology of commits instead of filtering solely based on file contents or names (though this has not been observed in the wild).</source>
          <target state="translated">Renames에 대한 맵 삭제 삭제 chicanery에서 성공하더라도 사용자는 파일 내용이나 이름을 기준으로 만 필터링하는 대신 커밋 토폴로지에 의존하는 방식으로 파일을 필터링 할 수 있으므로 여전히 이전 버전과의 호환성을 위반합니다. 야생에서는 관찰되지 않았습니다).</target>
        </trans-unit>
        <trans-unit id="61567b5963537d3e4c116e4e243b4d8668030d1a" translate="yes" xml:space="preserve">
          <source>evil merge</source>
          <target state="translated">사악한 병합</target>
        </trans-unit>
        <trans-unit id="1c311d013c6a2d19d11baf9941fcc2b0a7d2d78b" translate="yes" xml:space="preserve">
          <source>examdiff</source>
          <target state="translated">examdiff</target>
        </trans-unit>
        <trans-unit id="f3acce247faff36de39e9ee2f7d244c87ceed765" translate="yes" xml:space="preserve">
          <source>exclude</source>
          <target state="translated">exclude</target>
        </trans-unit>
        <trans-unit id="ab0133e2c5bb9344897f46dbe599f473d2c31692" translate="yes" xml:space="preserve">
          <source>exit after emitting the supplied error message to the standard error stream.</source>
          <target state="translated">제공된 오류 메시지를 표준 오류 스트림으로 보낸 후 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="06be2e47c93881b7e52c1e4e523459cc32ab0586" translate="yes" xml:space="preserve">
          <source>expect dangling commits - potential heads - due to lack of head information</source>
          <target state="translated">헤드 정보가 부족하여 매달린 커밋-잠재적 헤드-예상</target>
        </trans-unit>
        <trans-unit id="20dda04ba85cc1d159e6c80f0473186d495ab0ca" translate="yes" xml:space="preserve">
          <source>expire</source>
          <target state="translated">expire</target>
        </trans-unit>
        <trans-unit id="f7b19a0813089b1f90306d291e49f7515586da63" translate="yes" xml:space="preserve">
          <source>export-ignore</source>
          <target state="translated">export-ignore</target>
        </trans-unit>
        <trans-unit id="c1c2115506d8681f0210e690b02b4309ccb2ee21" translate="yes" xml:space="preserve">
          <source>export-marks</source>
          <target state="translated">export-marks</target>
        </trans-unit>
        <trans-unit id="2ba613856b9cafe749b57a17fef7a035a5812808" translate="yes" xml:space="preserve">
          <source>export-subst</source>
          <target state="translated">export-subst</target>
        </trans-unit>
        <trans-unit id="26a55f8417100d8005c5698cbb7603aee8a068d7" translate="yes" xml:space="preserve">
          <source>extensions.objectFormat</source>
          <target state="translated">extensions.objectFormat</target>
        </trans-unit>
        <trans-unit id="7af7d180ad22fa7d636048be33daa6a7746de1e0" translate="yes" xml:space="preserve">
          <source>extra-branch-refs</source>
          <target state="translated">extra-branch-refs</target>
        </trans-unit>
        <trans-unit id="76cd4aef6e64ad9f67b4b64d624d8aa6b4973edb" translate="yes" xml:space="preserve">
          <source>extract patches from your branch, relative to master,</source>
          <target state="translated">마스터와 관련하여 지점에서 패치를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="7cb6efb98ba5972a9b5090dc2e517fe14d12cb04" translate="yes" xml:space="preserve">
          <source>false</source>
          <target state="translated">false</target>
        </trans-unit>
        <trans-unit id="21402ad97461d38b808636cb78d9cfb77a2900e2" translate="yes" xml:space="preserve">
          <source>fast-forward</source>
          <target state="translated">fast-forward</target>
        </trans-unit>
        <trans-unit id="bf93355b600cea9a1cf6ef1bf6513662965d8af7" translate="yes" xml:space="preserve">
          <source>fast-import</source>
          <target state="translated">fast-import</target>
        </trans-unit>
        <trans-unit id="be8bc29ad5542fc6804e84b6b43ad749090bf42a" translate="yes" xml:space="preserve">
          <source>fast-import accepts several commands to update the current repository and control the current import process. More detailed discussion (with examples) of each command follows later.</source>
          <target state="translated">빠른 가져 오기는 현재 저장소를 업데이트하고 현재 가져 오기 프로세스를 제어하기위한 여러 명령을 승인합니다. 각 명령에 대한 자세한 설명 (예와 함께)은 나중에 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7c20b6055ba0411d2c493a20017542051064924a" translate="yes" xml:space="preserve">
          <source>fast-import automatically moves active branches to inactive status based on a simple least-recently-used algorithm. The LRU chain is updated on each &lt;code&gt;commit&lt;/code&gt; command. The maximum number of active branches can be increased or decreased on the command line with --active-branches=.</source>
          <target state="translated">빠른 가져 오기는 가장 최근에 사용 된 간단한 알고리즘을 기반으로 활성 분기를 자동으로 비활성 상태로 이동합니다. LRU 체인은 각 &lt;code&gt;commit&lt;/code&gt; 명령 에서 업데이트됩니다 . --active-branches =를 사용하여 명령 줄에서 최대 활성 분기 수를 늘리거나 줄일 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
