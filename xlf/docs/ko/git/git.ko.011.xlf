<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="39555b916eeeec115f6735665b5426bf964f4e52" translate="yes" xml:space="preserve">
          <source>This setting can be overridden with the &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; environment variable, which must be a colon separated list of refs or globs.</source>
          <target state="translated">이 설정은 &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; 환경 변수 로 재정의 할 수 있으며 , 환경 변수는 콜론으로 구분 된 참조 또는 글로브 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d17d74e5aa80b06bd416eb43f1c510767efc6dc8" translate="yes" xml:space="preserve">
          <source>This setting defaults to &quot;refs/notes/commits&quot;, and it can be overridden by the &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; environment variable. See &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt;.</source>
          <target state="translated">이 설정은 기본적으로 &quot;refs / notes / commits&quot;이며 &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 . &lt;a href=&quot;git-notes&quot;&gt;git-notes [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="843f7e48b1e3c030c426060d83a399e29388c249" translate="yes" xml:space="preserve">
          <source>This setting forces Git to normalize line endings for this file on checkin and convert them to CRLF when the file is checked out.</source>
          <target state="translated">이 설정은 Git이 체크인시이 파일의 줄 끝을 정규화하고 파일이 체크 아웃 될 때 CRLF로 변환하도록합니다.</target>
        </trans-unit>
        <trans-unit id="8c7bb001c250cfdf4247d252deb09b8b2c2a2839" translate="yes" xml:space="preserve">
          <source>This setting forces Git to normalize line endings to LF on checkin and prevents conversion to CRLF when the file is checked out.</source>
          <target state="translated">이 설정은 Git이 체크인시 줄 끝을 LF로 정규화하고 파일이 체크 아웃 될 때 CRLF 로의 변환을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="886fc853da603148f91948f5793a0d1be70dc28a" translate="yes" xml:space="preserve">
          <source>This setting is automatically guessed by &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; when the repository was created. By default a repository that ends in &quot;/.git&quot; is assumed to be not bare (bare = false), while all other repositories are assumed to be bare (bare = true).</source>
          <target state="translated">이 설정은 리포지토리가 생성 될 때 &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-init&quot;&gt;git-init [1]에&lt;/a&gt; 의해 자동으로 추측됩니다 . 기본적으로 &quot;/.git&quot;로 끝나는 리포지토리는 베어 (bare = false) 인 것으로 가정하고 다른 모든 리포지토리는 베어 (bare = true) 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="a32da40367d476cb817ba2cfa99cb18bc04a7b3a" translate="yes" xml:space="preserve">
          <source>This setting overrides the default of the &lt;code&gt;--cleanup&lt;/code&gt; option in &lt;code&gt;git commit&lt;/code&gt;. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for details. Changing the default can be useful when you always want to keep lines that begin with comment character &lt;code&gt;#&lt;/code&gt; in your log message, in which case you would do &lt;code&gt;git config commit.cleanup whitespace&lt;/code&gt; (note that you will have to remove the help lines that begin with &lt;code&gt;#&lt;/code&gt; in the commit log template yourself, if you do this).</source>
          <target state="translated">이 설정 은 &lt;code&gt;git commit&lt;/code&gt; 의 &lt;code&gt;--cleanup&lt;/code&gt; 옵션 의 기본값보다 우선합니다 . 자세한 내용은 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 을 참조하십시오. 당신은 항상 주석 문자로 시작하는 라인을 유지하려는 경우 기본값을 변경하면 유용 할 수 있습니다 &lt;code&gt;#&lt;/code&gt; 당신이 할 것이 경우 로그 메시지를, &lt;code&gt;git config commit.cleanup whitespace&lt;/code&gt; (주 당신은 시작 도움말 라인을 제거해야 할 것 커밋 로그 템플릿에 &lt;code&gt;#&lt;/code&gt; 을 입력하면됩니다.</target>
        </trans-unit>
        <trans-unit id="e85001143ab4f6109a8db79b80d46592a3792b5e" translate="yes" xml:space="preserve">
          <source>This setting should be set to a comma-separated list of color and date settings, starting and ending with a color, the dates should be set from oldest to newest. The metadata will be colored given the colors if the line was introduced before the given timestamp, overwriting older timestamped colors.</source>
          <target state="translated">이 설정은 쉼표로 구분 된 색상 및 날짜 설정 목록으로 설정해야하며 색상으로 시작하고 끝나는 날짜는 가장 오래된 날짜부터 최신 날짜로 설정해야합니다. 주어진 타임 스탬프 이전에 라인이 도입 된 경우 메타 데이터에 색상이 지정되어 오래된 타임 스탬프 된 색상을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="1b39995bc064271da90ffd3401f4ace36766db6f" translate="yes" xml:space="preserve">
          <source>This setting writes a JSON-based format that is suited for machine interpretation. See &lt;code&gt;GIT_TRACE2&lt;/code&gt; for available trace output options and &lt;a href=&quot;api-trace2&quot;&gt;Trace2 documentation&lt;/a&gt; for full details.</source>
          <target state="translated">이 설정은 기계 해석에 적합한 JSON 기반 형식을 작성합니다. 사용 가능한 추적 출력 옵션 은 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 및 자세한 내용은 &lt;a href=&quot;api-trace2&quot;&gt;Trace2 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d727921c238e28668ffb0dd7e4775077e3d6b368" translate="yes" xml:space="preserve">
          <source>This should be a colon-separated list of absolute paths. If set, it is a list of directories that Git should not chdir up into while looking for a repository directory (useful for excluding slow-loading network directories). It will not exclude the current working directory or a GIT_DIR set on the command line or in the environment. Normally, Git has to read the entries in this list and resolve any symlink that might be present in order to compare them with the current directory. However, if even this access is slow, you can add an empty entry to the list to tell Git that the subsequent entries are not symlinks and needn&amp;rsquo;t be resolved; e.g., &lt;code&gt;GIT_CEILING_DIRECTORIES=/maybe/symlink::/very/slow/non/symlink&lt;/code&gt;.</source>
          <target state="translated">콜론으로 구분 된 절대 경로 목록이어야합니다. 설정된 경우, 리포지토리 디렉토리를 찾는 동안 Git이 chdir하지 않아야하는 디렉토리 목록입니다 (느리게로드되는 네트워크 디렉토리 제외 제외). 현재 작업 디렉토리 또는 명령 행 또는 환경에 설정된 GIT_DIR을 제외하지 않습니다. 일반적으로 Git은이 목록의 항목을 읽고 현재 디렉토리와 비교하기 위해 존재할 수있는 symlink를 해결해야합니다. 그러나이 액세스조차 느리면 빈 항목을 목록에 추가하여 Git에 후속 항목이 심볼릭 링크가 아니므로 해결할 필요가 없음을 알릴 수 있습니다. 예를 들어, &lt;code&gt;GIT_CEILING_DIRECTORIES=/maybe/symlink::/very/slow/non/symlink&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02391ad98329bedcf2ddfbe7ebdef774e4e7cc67" translate="yes" xml:space="preserve">
          <source>This should help you to submit patches inline using KMail.</source>
          <target state="translated">KMail을 사용하여 인라인 패치를 제출하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="dc65a8c75ec971d079e04ac05264e8ee2fb908c8" translate="yes" xml:space="preserve">
          <source>This should make &quot;--pretty=oneline&quot; a whole lot more readable for people using 80-column terminals.</source>
          <target state="translated">이렇게하면 80 열 터미널을 사용하는 사람들이 &quot;--pretty = oneline&quot;을 훨씬 더 읽기 쉽게 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="cda899a68420b48633046b1cef20e4960b467a9e" translate="yes" xml:space="preserve">
          <source>This should make it easy to look up svn log messages when svn users refer to -r/--revision numbers.</source>
          <target state="translated">svn 사용자가 -r /-개정 번호를 참조 할 때 svn 로그 메시지를 쉽게 찾을 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3fce0b9f9a8369808848ec3f066c1735323bb111" translate="yes" xml:space="preserve">
          <source>This should not be confused with the &lt;code&gt;ours&lt;/code&gt; merge strategy, which does not even look at what the other tree contains at all. It discards everything the other tree did, declaring &lt;code&gt;our&lt;/code&gt; history contains all that happened in it.</source>
          <target state="translated">이것은 &lt;code&gt;ours&lt;/code&gt; 병합 전략 과 혼동되어서는 안되며 , 다른 트리가 무엇을 포함하고 있는지조차 보지 못합니다. 그것은 다른 나무가 한 모든 것을 버리고, &lt;code&gt;our&lt;/code&gt; 역사는 그 안에 일어난 모든 것을 포함 한다고 선언 합니다.</target>
        </trans-unit>
        <trans-unit id="70d0ce2d7e7f48cdf303b28228ad271bde0b97ac" translate="yes" xml:space="preserve">
          <source>This shows that our resolved version deleted &quot;Hello world&quot; from the first parent, deleted &quot;Goodbye&quot; from the second parent, and added &quot;Goodbye world&quot;, which was previously absent from both.</source>
          <target state="translated">이는 해결 된 버전이 첫 번째 상위에서 &quot;Hello world&quot;를 삭제하고 두 번째 상위에서 &quot;Goodbye&quot;를 삭제 한 후 이전에 둘 다 없었던 &quot;Goodbye world&quot;를 추가했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e0fbc89a9eb1f686d88b41839c951cd18b86bf5e" translate="yes" xml:space="preserve">
          <source>This shows that you can do without a run script if you write the test on a single line.</source>
          <target state="translated">테스트를 한 줄에 작성하면 실행 스크립트 없이도 할 수 있음이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f580a082428b40358ee35f346bb87b38bbd6e3f8" translate="yes" xml:space="preserve">
          <source>This shows the change between HEAD and index (i.e. what will be committed if you say &lt;code&gt;git commit&lt;/code&gt;), and between index and working tree files (i.e. what you could stage further before &lt;code&gt;git commit&lt;/code&gt; using &lt;code&gt;git add&lt;/code&gt;) for each path. A sample output looks like this:</source>
          <target state="translated">이것은 각 경로에 대한 HEAD와 인덱스 사이의 변경 (즉 , &lt;code&gt;git commit&lt;/code&gt; 이라고하면 커밋 될 것 )과 인덱스와 작업 트리 파일 사이 (즉, &lt;code&gt;git add&lt;/code&gt; 를 사용하여 git &lt;code&gt;git commit&lt;/code&gt; 전에 추가로 스테이징 할 수있는 것 )를 보여줍니다. 샘플 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cdedf9c4235065dcc3b6a065543c259879fefa6b" translate="yes" xml:space="preserve">
          <source>This shows the files and directories to be deleted and issues an &quot;Input ignore patterns&amp;gt;&amp;gt;&quot; prompt. You can input space-separated patterns to exclude files and directories from deletion. E.g. &quot;*.c *.h&quot; will excludes files end with &quot;.c&quot; and &quot;.h&quot; from deletion. When you are satisfied with the filtered result, press ENTER (empty) back to the main menu.</source>
          <target state="translated">삭제 될 파일 및 디렉토리가 표시되고 &quot;Input ignore patterns &amp;gt;&amp;gt;&quot;프롬프트가 표시됩니다. 공백으로 구분 된 패턴을 입력하여 파일 및 디렉토리를 삭제에서 제외 할 수 있습니다. 예를 들어 &quot;* .c * .h&quot;는 &quot;.c&quot;및 &quot;.h&quot;로 끝나는 파일을 삭제에서 제외합니다. 필터링 된 결과가 만족 스러우면 ENTER (빈)를 다시 기본 메뉴로 누르십시오.</target>
        </trans-unit>
        <trans-unit id="d76da1518821bfa115def32fd19d8e8b1e73d979" translate="yes" xml:space="preserve">
          <source>This shows the files and directories to be deleted and issues an &quot;Select items to delete&amp;gt;&amp;gt;&quot; prompt. When the prompt ends with double &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; like this, you can make more than one selection, concatenated with whitespace or comma. Also you can say ranges. E.g. &quot;2-5 7,9&quot; to choose 2,3,4,5,7,9 from the list. If the second number in a range is omitted, all remaining items are selected. E.g. &quot;7-&quot; to choose 7,8,9 from the list. You can say &lt;code&gt;*&lt;/code&gt; to choose everything. Also when you are satisfied with the filtered result, press ENTER (empty) back to the main menu.</source>
          <target state="translated">삭제 될 파일 및 디렉토리가 표시되고 &quot;삭제할 항목 선택 &amp;gt;&amp;gt;&quot;프롬프트가 표시됩니다. 프롬프트가 이와 같이 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 로 끝나는 경우 공백이나 쉼표로 연결된 둘 이상의 선택을 할 수 있습니다. 또한 범위를 말할 수 있습니다. 예를 들어 &quot;2-5 7,9&quot;는 목록에서 2,3,4,5,7,9를 선택합니다. 범위의 두 번째 숫자가 생략되면 나머지 모든 항목이 선택됩니다. 예를 들어 &quot;7-&quot;을 사용하여 목록에서 7,8,9를 선택하십시오. &lt;code&gt;*&lt;/code&gt; 라고 말하면 모든 것을 선택할 수 있습니다 . 필터링 된 결과가 만족 스러우면 ENTER (빈)를 다시 기본 메뉴로 누르십시오.</target>
        </trans-unit>
        <trans-unit id="53f59db63b45945049b0fe262d831991c1cb4a8d" translate="yes" xml:space="preserve">
          <source>This shows the status information and issues an &quot;Update&amp;gt;&amp;gt;&quot; prompt. When the prompt ends with double &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, you can make more than one selection, concatenated with whitespace or comma. Also you can say ranges. E.g. &quot;2-5 7,9&quot; to choose 2,3,4,5,7,9 from the list. If the second number in a range is omitted, all remaining patches are taken. E.g. &quot;7-&quot; to choose 7,8,9 from the list. You can say &lt;code&gt;*&lt;/code&gt; to choose everything.</source>
          <target state="translated">상태 정보가 표시되고 &quot;Update &amp;gt;&amp;gt;&quot;프롬프트가 표시됩니다. 프롬프트가 double &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 으로 끝나면 공백이나 쉼표로 연결된 둘 이상의 선택을 할 수 있습니다. 또한 범위를 말할 수 있습니다. 예를 들어 &quot;2-5 7,9&quot;는 목록에서 2,3,4,5,7,9를 선택합니다. 범위의 두 번째 숫자를 생략하면 나머지 모든 패치가 사용됩니다. 예를 들어 &quot;7-&quot;을 사용하여 목록에서 7,8,9를 선택하십시오. &lt;code&gt;*&lt;/code&gt; 라고 말하면 모든 것을 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="728eb7da1f0f1bff86889f4ac114a7967bd3817f" translate="yes" xml:space="preserve">
          <source>This snapshot is now stored in a temporary staging area which Git calls the &quot;index&quot;. You can permanently store the contents of the index in the repository with &lt;code&gt;git commit&lt;/code&gt;:</source>
          <target state="translated">이 스냅 샷은 이제 Git이 &quot;인덱스&quot;라고하는 임시 준비 영역에 저장됩니다. &lt;code&gt;git commit&lt;/code&gt; 을 사용하여 저장소에 색인의 내용을 영구적으로 저장할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dfa3a419f48a4609a0668c69a143f543612e713a" translate="yes" xml:space="preserve">
          <source>This solution is not 100% bulletproof, in the sense that if some project has a named ref (branch, tag) starting with &lt;code&gt;git/&lt;/code&gt;, then paths such as</source>
          <target state="translated">이 솔루션은 일부 프로젝트에 &lt;code&gt;git/&lt;/code&gt; 시작하는 명명 된 참조 (분기, 태그)가있는 경우 다음과 같은 경로 가 있다는 점에서 100 % 방탄이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="02da975953020f9ebbe3388889e8a8406f05d0c7" translate="yes" xml:space="preserve">
          <source>This step and the next one could be combined into a single step with &quot;checkout -b my2.6.14 v2.6.14&quot;.</source>
          <target state="translated">이 단계와 다음 단계는 &quot;checkout -b my2.6.14 v2.6.14&quot;를 사용하여 단일 단계로 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b0b980e437fd3274de63464aa9184e42833d899" translate="yes" xml:space="preserve">
          <source>This suffix is also accepted when spelled in uppercase, and means the same thing no matter the case.</source>
          <target state="translated">이 접미사는 대문자로 표기 할 때도 사용할 수 있으며 경우에 상관없이 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="01f381d8f83cae139b7e7ff06573574ebdbc8086" translate="yes" xml:space="preserve">
          <source>This supersedes the &lt;a href=&quot;#post-update&quot;&gt;&lt;em&gt;post-update&lt;/em&gt;&lt;/a&gt; hook in that it gets both old and new values of all the refs in addition to their names.</source>
          <target state="translated">이것은 이름뿐만 아니라 모든 심판의 오래된 값과 새로운 값을 모두 얻는다는 점에서 &lt;a href=&quot;#post-update&quot;&gt;&lt;em&gt;업데이트 후&lt;/em&gt;&lt;/a&gt; 후크를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="6339f7da558022ed0ae10f566dd01f30bb047e19" translate="yes" xml:space="preserve">
          <source>This synchronizes your public repository to match the named branch head (i.e. &lt;code&gt;master&lt;/code&gt; in this case) and objects reachable from them in your current repository.</source>
          <target state="translated">그러면 이름이 지정된 브랜치 헤드 ( 이 경우 &lt;code&gt;master&lt;/code&gt; )와 현재 저장소에서 액세스 할 수있는 오브젝트와 일치하도록 공용 저장소가 동기화 됩니다.</target>
        </trans-unit>
        <trans-unit id="0012e2584fc653cc03e6dda35ea11cbdc9f6c1a2" translate="yes" xml:space="preserve">
          <source>This syntax is only recognized if there are no slashes before the first colon. This helps differentiate a local path that contains a colon. For example the local path &lt;code&gt;foo:bar&lt;/code&gt; could be specified as an absolute path or &lt;code&gt;./foo:bar&lt;/code&gt; to avoid being misinterpreted as an ssh url.</source>
          <target state="translated">이 구문은 첫 번째 콜론 앞에 슬래시가없는 경우에만 인식됩니다. 이것은 콜론을 포함하는 로컬 경로를 구별하는 데 도움이됩니다. 예를 들어 로컬 경로 &lt;code&gt;foo:bar&lt;/code&gt; 를 절대 경로로 지정하거나 &lt;code&gt;./foo:bar&lt;/code&gt; 를 지정 하여 ssh url로 잘못 해석되지 않도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f5d9872e03f1e6dd55415fa2249d9c84ea6f738" translate="yes" xml:space="preserve">
          <source>This takes a text file each of whose lines is a shell glob pattern. Filepairs that match a glob pattern on an earlier line in the file are output before ones that match a later line, and filepairs that do not match any glob pattern are output last.</source>
          <target state="translated">이것은 각 줄이 쉘 글로브 패턴 인 텍스트 파일을 가져옵니다. 파일의 이전 행에서 glob 패턴과 일치하는 파일 쌍은 이후 행과 일치하는 파일 쌍보다 먼저 출력되고 glob 패턴과 일치하지 않는 파일 쌍은 마지막으로 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="b169549655fddd825e67d14c1591493d6ac0be03" translate="yes" xml:space="preserve">
          <source>This target is intended to be more of a summary (like GIT_TRACE) and less detailed than the other targets. It ignores thread, region, and data messages, for example.</source>
          <target state="translated">이 목표는 GIT_TRACE와 같은 요약 일뿐 아니라 다른 목표보다 상세하지 않습니다. 예를 들어 스레드, 영역 및 데이터 메시지는 무시합니다.</target>
        </trans-unit>
        <trans-unit id="49bec15344e0cef74269dabec868d060f4c1b07d" translate="yes" xml:space="preserve">
          <source>This tells the bisect process that no commit after &lt;code&gt;v2.5&lt;/code&gt;, up to and including &lt;code&gt;v2.6&lt;/code&gt;, should be tested.</source>
          <target state="translated">이것은 &lt;code&gt;v2.5&lt;/code&gt; 이후의 커밋이 &lt;code&gt;v2.6&lt;/code&gt; 이하의 커밋을 테스트 하지 않아야한다는 bisect 프로세스를 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="1842bab1269e00a8bf77d06ee23570861225cc48" translate="yes" xml:space="preserve">
          <source>This tells the bisect process that the commits between &lt;code&gt;v2.5&lt;/code&gt; and &lt;code&gt;v2.6&lt;/code&gt; (inclusive) should be skipped.</source>
          <target state="translated">이것은 vsect 프로세스에 &lt;code&gt;v2.5&lt;/code&gt; 와 &lt;code&gt;v2.6&lt;/code&gt; 사이의 커밋을 건너 뛰어야한다는 것을 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="fb42c5eea9f7afe3662a07fd6af3c3105ab04e8f" translate="yes" xml:space="preserve">
          <source>This tells you that the immediately following version of the file was &quot;newsha&quot;, and that the immediately preceding version was &quot;oldsha&quot;. You also know the commit messages that went with the change from oldsha to 4b9458b and with the change from 4b9458b to newsha.</source>
          <target state="translated">이것은 파일의 바로 다음 버전은 &quot;newsha&quot;이고 바로 이전 버전은 &quot;oldsha&quot;임을 나타냅니다. 또한 oldsha에서 4b9458b로 변경하고 4b9458b에서 newsha로 변경 한 커밋 메시지도 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f1179423f3ea23a6c9e525ef159db41c1155b6a" translate="yes" xml:space="preserve">
          <source>This transformation is used to detect renames and copies, and is controlled by the -M option (to detect renames) and the -C option (to detect copies as well) to the &lt;code&gt;git diff-*&lt;/code&gt; commands. If the input contained these filepairs:</source>
          <target state="translated">이 변환은 이름 변경 및 사본을 감지하는 데 사용되며 -M 옵션 (이름 변경을 감지) 및 -C 옵션 (사본도 감지)에 의해 &lt;code&gt;git diff-*&lt;/code&gt; 명령으로 제어됩니다. 입력에 이러한 파일 쌍이 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="573190bccf8f2a4ea6fc33eedd23b4b8fc3f90f8" translate="yes" xml:space="preserve">
          <source>This transformation is used to merge filepairs broken by diffcore-break, and not transformed into rename/copy by diffcore-rename, back into a single modification. This always runs when diffcore-break is used.</source>
          <target state="translated">이 변환은 diffcore-break로 분리 된 파일 쌍을 병합하는 데 사용되며 diffcore-rename으로 이름 바꾸기 / 복사로 변환되지 않고 단일 수정으로 다시 변환됩니다. diffcore-break가 사용될 때 항상 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="448726c2164ad1aa28f4d84dcd657bc466764287" translate="yes" xml:space="preserve">
          <source>This transformation limits the set of filepairs to those that change specified strings between the preimage and the postimage in a certain way. -S&amp;lt;block of text&amp;gt; and -G&amp;lt;regular expression&amp;gt; options are used to specify different ways these strings are sought.</source>
          <target state="translated">이 변환은 파일 쌍 세트를 특정 방식으로 사전 이미지와 사후 이미지 사이에 지정된 문자열을 변경하는 파일 쌍으로 제한합니다. -S &amp;lt;텍스트 블록&amp;gt; 및 -G &amp;lt;정규 표현식&amp;gt; 옵션은 이러한 문자열을 찾는 다른 방법을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eb01f7c28a2e42a179d9ca76727e0a7db6bb8dce" translate="yes" xml:space="preserve">
          <source>This transport can be used for both uploading and downloading, and requires you to have a log-in privilege over &lt;code&gt;ssh&lt;/code&gt; to the remote machine. It finds out the set of objects the other side lacks by exchanging the head commits both ends have and transfers (close to) minimum set of objects. It is by far the most efficient way to exchange Git objects between repositories.</source>
          <target state="translated">이 전송은 업로드 및 다운로드에 모두 사용될 수 있으며 원격 시스템에 대한 &lt;code&gt;ssh&lt;/code&gt; 를 통한 로그인 권한이 필요합니다 . 헤드 커밋을 교환하여 다른쪽에없는 개체 집합을 찾은 다음 최소 개체 집합에 가깝게 전송합니다. 리포지토리간에 Git 객체를 교환하는 가장 효율적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="1e93313475dc2966a9b364d25d3e63ddb92cd35d" translate="yes" xml:space="preserve">
          <source>This transport is the same as SSH transport but uses &lt;code&gt;sh&lt;/code&gt; to run both ends on the local machine instead of running other end on the remote machine via &lt;code&gt;ssh&lt;/code&gt;.</source>
          <target state="translated">이 전송은 SSH 전송과 동일하지만 &lt;code&gt;ssh&lt;/code&gt; 를 통해 원격 시스템에서 다른 쪽 끝을 실행하는 대신 &lt;code&gt;sh&lt;/code&gt; 를 사용 하여 로컬 시스템에서 양 끝을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="187c060b77919e40b0db07be6c4444d6bedf0f1f" translate="yes" xml:space="preserve">
          <source>This transport was designed for anonymous downloading. Like SSH transport, it finds out the set of objects the downstream side lacks and transfers (close to) minimum set of objects.</source>
          <target state="translated">이 전송은 익명 다운로드 용으로 설계되었습니다. SSH 전송과 마찬가지로 다운 스트림 측에없는 개체 집합을 찾아 최소 개체 집합에 가깝게 전송합니다.</target>
        </trans-unit>
        <trans-unit id="a843c4941e9eb68216876c91a59842ae7d058faa" translate="yes" xml:space="preserve">
          <source>This tutorial explains how to import a new project into Git, make changes to it, and share changes with other developers.</source>
          <target state="translated">이 튜토리얼에서는 새 프로젝트를 Git으로 가져 와서 변경하고 다른 개발자와 변경 사항을 공유하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="586b98337ae35b657ccc9687b72106b49b3b174b" translate="yes" xml:space="preserve">
          <source>This tutorial explains how to use the &quot;core&quot; Git commands to set up and work with a Git repository.</source>
          <target state="translated">이 튜토리얼에서는 &quot;core&quot;Git 명령을 사용하여 Git 저장소를 설정하고 작업하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4f3b7287fc4739a451de38537fb0637003a134c1" translate="yes" xml:space="preserve">
          <source>This tutorial should be enough to perform basic distributed revision control for your projects. However, to fully understand the depth and power of Git you need to understand two simple ideas on which it is based:</source>
          <target state="translated">이 학습서는 프로젝트에 대한 기본 분산 개정 제어를 수행하기에 충분해야합니다. 그러나 Git의 깊이와 힘을 완전히 이해하려면 그 기반이되는 두 가지 간단한 아이디어를 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="50b7797bad77b49520127714ff8a716873aad978" translate="yes" xml:space="preserve">
          <source>This updates (or creates, as necessary) branches &lt;code&gt;pu&lt;/code&gt; and &lt;code&gt;tmp&lt;/code&gt; in the local repository by fetching from the branches (respectively) &lt;code&gt;pu&lt;/code&gt; and &lt;code&gt;maint&lt;/code&gt; from the remote repository.</source>
          <target state="translated">이는 원격 저장소에서 분기 (각각) &lt;code&gt;pu&lt;/code&gt; 및 &lt;code&gt;maint&lt;/code&gt; 를 가져와 로컬 저장소에서 분기 &lt;code&gt;pu&lt;/code&gt; 및 &lt;code&gt;tmp&lt;/code&gt; 를 업데이트 (또는 필요에 따라 작성 ) 합니다.</target>
        </trans-unit>
        <trans-unit id="3e7d31bbe83aa073e1058fe02ef8026a34345709" translate="yes" xml:space="preserve">
          <source>This updates (or creates, as necessary) branches &lt;code&gt;seen&lt;/code&gt; and &lt;code&gt;tmp&lt;/code&gt; in the local repository by fetching from the branches (respectively) &lt;code&gt;seen&lt;/code&gt; and &lt;code&gt;maint&lt;/code&gt; from the remote repository.</source>
          <target state="translated">이 업데이트 (또는 필요에 따라 생성) 분기 &lt;code&gt;seen&lt;/code&gt; 및 &lt;code&gt;tmp&lt;/code&gt; 지점으로부터 인출하여 로컬 저장소는 (각각) &lt;code&gt;seen&lt;/code&gt; 하고 &lt;code&gt;maint&lt;/code&gt; 원격 저장소.</target>
        </trans-unit>
        <trans-unit id="70ac0b727096d7231e8fdcdd112d1a04551c8ca8" translate="yes" xml:space="preserve">
          <source>This used to be the default, but not since Git 2.0 (&lt;code&gt;simple&lt;/code&gt; is the new default).</source>
          <target state="translated">이것은 기본값이지만 Git 2.0 이후는 아닙니다 ( &lt;code&gt;simple&lt;/code&gt; 것이 새로운 기본값입니다).</target>
        </trans-unit>
        <trans-unit id="fd75f35034e73b98112aaaf4198ee488b9e51804" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;--interactive&lt;/code&gt; machinery internally, but combining it with the &lt;code&gt;--interactive&lt;/code&gt; option explicitly is generally not a good idea unless you know what you are doing (see BUGS below).</source>
          <target state="translated">이것은 &lt;code&gt;--interactive&lt;/code&gt; 기계를 내부적으로 사용하지만 &lt;code&gt;--interactive&lt;/code&gt; 옵션과 명시 적으로 결합하는 것은 자신이 무엇을하고 있는지 알지 않는 한 일반적으로 좋은 생각이 아닙니다 (아래 버그 참조).</target>
        </trans-unit>
        <trans-unit id="665eaff82148d49a545a97a7903a8bf0d3754608" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;--interactive&lt;/code&gt; machinery internally, but it can be run without an explicit &lt;code&gt;--interactive&lt;/code&gt;.</source>
          <target state="translated">내부적으로 &lt;code&gt;--interactive&lt;/code&gt; 기계를 사용 하지만 명시적인 &lt;code&gt;--interactive&lt;/code&gt; 없이 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a59444b879ae5151f30b1cffe08974240ac7bdc" translate="yes" xml:space="preserve">
          <source>This uses the same two-dot range notation we saw earlier with &lt;code&gt;git log&lt;/code&gt;.</source>
          <target state="translated">이것은 이전에 &lt;code&gt;git log&lt;/code&gt; 와 동일한 2 점 범위 표기법을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="94dc29f5a82c88ac8ea06389eebe7535e89a6fb1" translate="yes" xml:space="preserve">
          <source>This value is true by default in a repository that has a working directory associated with it, and false by default in a bare repository.</source>
          <target state="translated">이 값은 연관된 작업 디렉토리가있는 저장소에서 기본적으로 true이고 기본 저장소에서 기본적으로 false입니다.</target>
        </trans-unit>
        <trans-unit id="73a34f84ecc165ae3643b28ecca4c6c41f197412" translate="yes" xml:space="preserve">
          <source>This variable can be used to restrict the permission bits of tar archive entries. The default is 0002, which turns off the world write bit. The special value &quot;user&quot; indicates that the archiving user&amp;rsquo;s umask will be used instead. See umask(2) and &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt;.</source>
          <target state="translated">이 변수는 tar 아카이브 항목의 권한 비트를 제한하는 데 사용할 수 있습니다. 기본값은 0002이며 월드 쓰기 비트를 끕니다. 특수 값 &quot;user&quot;는 보관 사용자의 umask가 대신 사용됨을 나타냅니다. umask (2) 및 &lt;a href=&quot;git-archive&quot;&gt;git-archive [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="63a384d932515032afb2060852ce18cd5598c9ca" translate="yes" xml:space="preserve">
          <source>This variable can be used to restrict the permission bits of tar archive entries. The default is 0002, which turns off the world write bit. The special value &quot;user&quot; indicates that the archiving user&amp;rsquo;s umask will be used instead. See umask(2) for details. If &lt;code&gt;--remote&lt;/code&gt; is used then only the configuration of the remote repository takes effect.</source>
          <target state="translated">이 변수는 tar 아카이브 항목의 권한 비트를 제한하는 데 사용할 수 있습니다. 기본값은 0002이며 월드 쓰기 비트를 끕니다. 특수 값 &quot;user&quot;는 보관 사용자의 umask가 대신 사용됨을 나타냅니다. 자세한 내용은 umask (2)를 참조하십시오. 경우 &lt;code&gt;--remote&lt;/code&gt; 는 다음에 사용되는 원격 저장소의 구성만을 시행한다.</target>
        </trans-unit>
        <trans-unit id="0afce327e7d4311118de1c5dc2faa8fa7a291053" translate="yes" xml:space="preserve">
          <source>This variable controls the event target destination. It may be overridden by the &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; environment variable. The following table shows possible values.</source>
          <target state="translated">이 변수는 이벤트 대상 목적지를 제어합니다. &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; 환경 변수 로 대체 될 수 있습니다 . 다음 표는 가능한 값을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b3073c2a2c3930628fae47eb515e2fe5729910f0" translate="yes" xml:space="preserve">
          <source>This variable controls the normal target destination. It may be overridden by the &lt;code&gt;GIT_TRACE2&lt;/code&gt; environment variable. The following table shows possible values.</source>
          <target state="translated">이 변수는 일반 대상 목적지를 제어합니다. &lt;code&gt;GIT_TRACE2&lt;/code&gt; 환경 변수 로 대체 될 수 있습니다 . 다음 표는 가능한 값을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ab644894061fa15fc115b6d355d07c2965277303" translate="yes" xml:space="preserve">
          <source>This variable controls the performance target destination. It may be overridden by the &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; environment variable. The following table shows possible values.</source>
          <target state="translated">이 변수는 성능 목표 대상을 제어합니다. &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; 환경 변수 로 대체 될 수 있습니다 . 다음 표는 가능한 값을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="53008d90e6aae985c2e7839a77d7b54894ce429e" translate="yes" xml:space="preserve">
          <source>This variable controls the sort ordering of branches when displayed by &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;. Without the &quot;--sort=&amp;lt;value&amp;gt;&quot; option provided, the value of this variable will be used as the default. See &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt; field names for valid values.</source>
          <target state="translated">이 변수는 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]로&lt;/a&gt; 표시 될 때 분기의 정렬 순서를 제어합니다 . &quot;--sort = &amp;lt;value&amp;gt;&quot;옵션을 제공하지 않으면이 변수의 값이 기본값으로 사용됩니다. 유효한 값 은 &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt; 필드 이름을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ea1c7eb75a360c1f9f69915dbc32e427ddfb7ced" translate="yes" xml:space="preserve">
          <source>This variable controls the sort ordering of tags when displayed by &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;. Without the &quot;--sort=&amp;lt;value&amp;gt;&quot; option provided, the value of this variable will be used as the default.</source>
          <target state="translated">이 변수는 &lt;a href=&quot;git-tag&quot;&gt;git-tag [1]로&lt;/a&gt; 표시 될 때 태그의 정렬 순서를 제어합니다 . &quot;--sort = &amp;lt;value&amp;gt;&quot;옵션을 제공하지 않으면이 변수의 값이 기본값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c2680b6925a4a160ca8f3fee892cc23ec9be5f4f" translate="yes" xml:space="preserve">
          <source>This variable determines the default value for variables such as &lt;code&gt;color.diff&lt;/code&gt; and &lt;code&gt;color.grep&lt;/code&gt; that control the use of color per command family. Its scope will expand as more commands learn configuration to set a default for the &lt;code&gt;--color&lt;/code&gt; option. Set it to &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;never&lt;/code&gt; if you prefer Git commands not to use color unless enabled explicitly with some other configuration or the &lt;code&gt;--color&lt;/code&gt; option. Set it to &lt;code&gt;always&lt;/code&gt; if you want all output not intended for machine consumption to use color, to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt; (this is the default since Git 1.8.4) if you want such output to use color when written to the terminal.</source>
          <target state="translated">이 변수 는 명령 패밀리 당 색상 사용을 제어하는 &lt;code&gt;color.diff&lt;/code&gt; 및 &lt;code&gt;color.grep&lt;/code&gt; 와 같은 변수의 기본값을 결정합니다 . &lt;code&gt;--color&lt;/code&gt; 옵션 의 기본값을 설정하기 위해 더 많은 명령이 구성을 배우면 범위가 확장됩니다 . 로 설정하여 &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;never&lt;/code&gt; 당신은 다른 구성이나 명시 적으로 활성화하지 않는 한 망할 놈의 색상을 사용하지 않는 명령을 선호하지 않는 경우 &lt;code&gt;--color&lt;/code&gt; 옵션을 선택합니다. 로 설정하여 &lt;code&gt;always&lt;/code&gt; 모든 출력에 사용하는 색상에 기계 소비를위한 것이 아닙니다하려는 경우 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;auto&lt;/code&gt; (이 망할 놈의 1.8.4 이후 기본값) 터미널에 기록 할 때 사용하는 색상에 같은 출력을 원하는 경우.</target>
        </trans-unit>
        <trans-unit id="2eb6f1e33d90fc7fb4373fa1793932292fbc650d" translate="yes" xml:space="preserve">
          <source>This variable is the same as &lt;code&gt;transfer.hideRefs&lt;/code&gt;, but applies only to &lt;code&gt;receive-pack&lt;/code&gt; (and so affects pushes, but not fetches). An attempt to update or delete a hidden ref by &lt;code&gt;git push&lt;/code&gt; is rejected.</source>
          <target state="translated">이 변수는 &lt;code&gt;transfer.hideRefs&lt;/code&gt; 와 동일 하지만 &lt;code&gt;receive-pack&lt;/code&gt; 에만 적용 되므로 푸시에는 영향을 주지만 페치에는 영향을 미치지 않습니다. &lt;code&gt;git push&lt;/code&gt; 에 의해 숨겨진 참조를 업데이트하거나 삭제하려는 시도 는 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="763a368531eb9d8bc40e93c6334e049f21620c45" translate="yes" xml:space="preserve">
          <source>This variable is the same as &lt;code&gt;transfer.hideRefs&lt;/code&gt;, but applies only to &lt;code&gt;upload-pack&lt;/code&gt; (and so affects only fetches, not pushes). An attempt to fetch a hidden ref by &lt;code&gt;git fetch&lt;/code&gt; will fail. See also &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt;.</source>
          <target state="translated">이 변수는 &lt;code&gt;transfer.hideRefs&lt;/code&gt; 와 동일 하지만 &lt;code&gt;upload-pack&lt;/code&gt; 에만 적용 되므로 푸시는 아닌 페치에만 영향을 미칩니다. &lt;code&gt;git fetch&lt;/code&gt; 에 의해 숨겨진 참조를 가져 오려는 시도 는 실패합니다. &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="75aa35a44ffd767e8a239dc01347d150ce1e39ed" translate="yes" xml:space="preserve">
          <source>This variable matters only when using persistent web environments that serve multiple requests using single gitweb instance, like mod_perl, FastCGI or Plackup.</source>
          <target state="translated">이 변수는 mod_perl, FastCGI 또는 Plackup과 같은 단일 gitweb 인스턴스를 사용하여 여러 요청을 처리하는 영구 웹 환경을 사용하는 경우에만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="c0526214b5c55d639fefd6a92d93b97ec2455930" translate="yes" xml:space="preserve">
          <source>This variable specifies a shell command through which the tar output generated by &lt;code&gt;git archive&lt;/code&gt; should be piped. The command is executed using the shell with the generated tar file on its standard input, and should produce the final output on its standard output. Any compression-level options will be passed to the command (e.g., &quot;-9&quot;). An output file with the same extension as &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; will be use this format if no other format is given.</source>
          <target state="translated">이 변수는 &lt;code&gt;git archive&lt;/code&gt; 에 의해 생성 된 tar 출력 이 파이프되어야 하는 쉘 명령을 지정합니다 . 명령은 표준 입력에서 생성 된 tar 파일과 함께 쉘을 사용하여 실행되며 표준 출력에서 ​​최종 출력을 생성해야합니다. 모든 압축 수준 옵션이 명령에 전달됩니다 (예 : &quot;-9&quot;). 다른 형식을 지정하지 않으면 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 과 동일한 확장자를 가진 출력 파일 이이 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="99ffcf0d1fc58b3934082bac9786637cf3a8cdad" translate="yes" xml:space="preserve">
          <source>This view is similar to &lt;code&gt;shortlog&lt;/code&gt; view.</source>
          <target state="translated">이보기는 &lt;code&gt;shortlog&lt;/code&gt; 보기 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="16ae6576174eeb48325f0bfa3042bcb20d29d417" translate="yes" xml:space="preserve">
          <source>This was not the case in the initial release of this feature in v2.13.0, which only matched the realpath version. Configuration that wants to be compatible with the initial release of this feature needs to either specify only the realpath version, or both versions.</source>
          <target state="translated">v2.13.0에서이 기능의 초기 릴리스에서는 실제 경로 버전과 만 일치하지 않았습니다. 이 기능의 초기 릴리스와 호환 되려는 구성은 실제 경로 버전 만 지정하거나 두 버전을 모두 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7c8d457b197b5558b7abfe068bcd1974205f94ad" translate="yes" xml:space="preserve">
          <source>This was optional in prior versions of git, but now it is the default. You can use &lt;code&gt;--no-utf8&lt;/code&gt; to override this.</source>
          <target state="translated">이전 버전의 git에서는 선택 사항 이었지만 이제는 기본값입니다. &lt;code&gt;--no-utf8&lt;/code&gt; 을 사용 하여이를 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="314df942d006c94c85d3e8c8bfe0a0b8ef8308d1" translate="yes" xml:space="preserve">
          <source>This will again prompt you for a message describing the change, and then record a new version of the project.</source>
          <target state="translated">변경 사항을 설명하는 메시지가 다시 표시되고 새 버전의 프로젝트가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="53cca56aaa41c3093032e1d720cb620b22717e06" translate="yes" xml:space="preserve">
          <source>This will cache the result of running &quot;exif&quot; on each blob indefinitely. If you change the textconv config variable for a diff driver, Git will automatically invalidate the cache entries and re-run the textconv filter. If you want to invalidate the cache manually (e.g., because your version of &quot;exif&quot; was updated and now produces better output), you can remove the cache manually with &lt;code&gt;git update-ref -d refs/notes/textconv/jpg&lt;/code&gt; (where &quot;jpg&quot; is the name of the diff driver, as in the example above).</source>
          <target state="translated">이것은 각 blob에서 &quot;exif&quot;를 실행 한 결과를 무기한 캐시합니다. diff 드라이버의 textconv 구성 변수를 변경하면 Git은 자동으로 캐시 항목을 무효화하고 textconv 필터를 다시 실행합니다. 캐시를 수동으로 무효화하려면 (예 : &quot;exif&quot;버전이 업데이트되어 더 나은 출력을 생성하기 때문에) &lt;code&gt;git update-ref -d refs/notes/textconv/jpg&lt;/code&gt; 를 사용 하여 캐시를 수동으로 제거 할 수 있습니다 (여기서 &quot; jpg &quot;는 위의 예와 같이 diff 드라이버의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3d17cc7dd2b4aac7e00ecd2628dbb99eefd074c7" translate="yes" xml:space="preserve">
          <source>This will cause Git to generate &lt;code&gt;Binary files differ&lt;/code&gt; (or a binary patch, if binary patches are enabled) instead of a regular diff.</source>
          <target state="translated">이로 인해 Git 은 일반 diff 대신 &lt;code&gt;Binary files differ&lt;/code&gt; 을 생성 합니다 (또는 이진 패치가 활성화 된 경우 이진 패치).</target>
        </trans-unit>
        <trans-unit id="dac66330b2bd98fcf90352c4cbeba694c8f4feb3" translate="yes" xml:space="preserve">
          <source>This will check out the currently cached copy of &lt;code&gt;Makefile&lt;/code&gt; into the file &lt;code&gt;.merged-Makefile&lt;/code&gt;.</source>
          <target state="translated">현재 캐시 된 &lt;code&gt;Makefile&lt;/code&gt; 사본을 &lt;code&gt;.merged-Makefile&lt;/code&gt; 파일로 체크 아웃합니다 .</target>
        </trans-unit>
        <trans-unit id="9acb73cd9d17d8ef0d5dfd6af35ea9d0a50c12ab" translate="yes" xml:space="preserve">
          <source>This will create a new commit which undoes the change in HEAD. You will be given a chance to edit the commit message for the new commit.</source>
          <target state="translated">HEAD의 변경을 취소하는 새로운 커밋이 생성됩니다. 새 커밋에 대한 커밋 메시지를 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85437cd96f5cff3dd194d542498fd954d1bf1e01" translate="yes" xml:space="preserve">
          <source>This will define a remote called &quot;origin&quot; in the resulting repository that lets you fetch and pull from the bundle. The $GIT_DIR/config file in R2 will have an entry like this:</source>
          <target state="translated">결과 저장소에서 &quot;origin&quot;이라는 원격을 정의하여 번들에서 가져 와서 가져올 수 있습니다. R2의 $ GIT_DIR / config 파일에는 다음과 같은 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2986121c6e711f05b2ed0ba772dedbd8c66503ff" translate="yes" xml:space="preserve">
          <source>This will error out if $REV is empty or not a valid revision.</source>
          <target state="translated">$ REV가 비어 있거나 유효한 개정이 아닌 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c8b7e8566771f37a03bc25eaec95675ffe82ba31" translate="yes" xml:space="preserve">
          <source>This will export the whole repository and import it into the existing empty repository. Except for reencoding commits that are not in UTF-8, it would be a one-to-one mirror.</source>
          <target state="translated">전체 저장소를 내보내고 기존의 빈 저장소로 가져옵니다. UTF-8이 아닌 커밋을 다시 인코딩하는 것을 제외하고는 일대일 미러입니다.</target>
        </trans-unit>
        <trans-unit id="5f851e29f67384fe2f487309701055635453a02c" translate="yes" xml:space="preserve">
          <source>This will list what commits you must have in order to extract from the bundle and will error out if you do not have them.</source>
          <target state="translated">이것은 번들에서 추출하기 위해 필요한 커밋을 나열하고없는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7ed8616207d4b6e51bdcbe1e7b524863a0139782" translate="yes" xml:space="preserve">
          <source>This will open your editor with a list of steps to be taken to perform your rebase.</source>
          <target state="translated">리베이스를 수행하기 위해 수행 할 단계 목록이있는 편집기가 열립니다.</target>
        </trans-unit>
        <trans-unit id="e9e68cbb3d1c11da9ad7575ebecc630d58996f10" translate="yes" xml:space="preserve">
          <source>This will prompt you for a commit message. You&amp;rsquo;ve now stored the first version of your project in Git.</source>
          <target state="translated">커밋 메시지를 묻는 메시지가 나타납니다. 이제 Git에 프로젝트의 첫 번째 버전을 저장했습니다.</target>
        </trans-unit>
        <trans-unit id="9229da0c83ee0b71f5a22085b5f3b7e07e9ec55a" translate="yes" xml:space="preserve">
          <source>This will remove each of your commits from mywork, temporarily saving them as patches (in a directory named &lt;code&gt;.git/rebase-apply&lt;/code&gt;), update mywork to point at the latest version of origin, then apply each of the saved patches to the new mywork. The result will look like:</source>
          <target state="translated">이렇게하면 커밋이 mywork에서 제거되어 패치 ( &lt;code&gt;.git/rebase-apply&lt;/code&gt; 디렉토리에)로 임시 저장 되고 최신 버전의 원점을 가리 키도록 mywork를 업데이트 한 다음 저장된 각 패치를 새로운 mywork에 적용합니다 . 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c98be5284d00528a6b74a33ba778d044a767668" translate="yes" xml:space="preserve">
          <source>This will result in only b (a and c are cleared).</source>
          <target state="translated">결과적으로 b 만됩니다 (a와 c가 지워짐).</target>
        </trans-unit>
        <trans-unit id="0385ed25689cd3e1167020ff6e8ba549d1603871" translate="yes" xml:space="preserve">
          <source>This will set the property &lt;code&gt;svn:keywords&lt;/code&gt; to &lt;code&gt;FreeBSD=%H&lt;/code&gt; for the file &lt;code&gt;devel/py-tipper/Makefile&lt;/code&gt;.</source>
          <target state="translated">그러면 &lt;code&gt;devel/py-tipper/Makefile&lt;/code&gt; 파일에 대해 &lt;code&gt;svn:keywords&lt;/code&gt; 속성 이 &lt;code&gt;FreeBSD=%H&lt;/code&gt; 로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="61383e31770f578e5ee86310440dccd09a4e5008" translate="yes" xml:space="preserve">
          <source>This will show &quot;refs/heads/master&quot; but also &quot;refs/remote/other-repo/master&quot;, if such references exists.</source>
          <target state="translated">&quot;참조 / 헤드 / 마스터&quot;뿐만 아니라 &quot;참조 / 리모트 / 기타 / 리포 / 마스터&quot;도 표시됩니다 (해당 참조가있는 경우).</target>
        </trans-unit>
        <trans-unit id="23dd2de32c54566f1df1adf9f6794600102b9c2b" translate="yes" xml:space="preserve">
          <source>This will start to clean, and you must confirm one by one in order to delete items. Please note that this action is not as efficient as the above two actions.</source>
          <target state="translated">청소가 시작되고 항목을 삭제하려면 하나씩 확인해야합니다. 이 조치는 위의 두 조치보다 효율적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b7bbd24afc1c6a470a80ef47d5171b33809ea28" translate="yes" xml:space="preserve">
          <source>This works for any of the supported update procedures (&lt;code&gt;--checkout&lt;/code&gt;, &lt;code&gt;--rebase&lt;/code&gt;, etc.). The only change is the source of the target SHA-1. For example, &lt;code&gt;submodule update --remote --merge&lt;/code&gt; will merge upstream submodule changes into the submodules, while &lt;code&gt;submodule update
--merge&lt;/code&gt; will merge superproject gitlink changes into the submodules.</source>
          <target state="translated">지원되는 모든 업데이트 절차 ( &lt;code&gt;--checkout&lt;/code&gt; , &lt;code&gt;--rebase&lt;/code&gt; 등)에 적용됩니다. 유일한 변경 사항은 대상 SHA-1의 소스입니다. 예를 들어, &lt;code&gt;submodule update --remote --merge&lt;/code&gt; 동안, 서브 모듈로 상향 서브 모듈의 변경 내용을 병합 할 &lt;code&gt;submodule update --merge&lt;/code&gt; 서브 모듈에 superproject gitlink 변경을 병합합니다.</target>
        </trans-unit>
        <trans-unit id="5a2ee7840b76b59e3aede30738fb578b292bc5f3" translate="yes" xml:space="preserve">
          <source>This works similarly to &lt;code&gt;svn update&lt;/code&gt; or &lt;code&gt;git pull&lt;/code&gt; except that it preserves linear history with &lt;code&gt;git rebase&lt;/code&gt; instead of &lt;code&gt;git merge&lt;/code&gt; for ease of dcommitting with &lt;code&gt;git svn&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;svn update&lt;/code&gt; 또는 &lt;code&gt;git pull&lt;/code&gt; 과 유사하게 작동 하지만 &lt;code&gt;git svn&lt;/code&gt; 으로 쉽게 커밋 &lt;code&gt;git merge&lt;/code&gt; 있도록 git merge 대신 &lt;code&gt;git rebase&lt;/code&gt; 로 선형 히스토리를 유지한다는 점을 제외하고 .</target>
        </trans-unit>
        <trans-unit id="5bc6c0e59c3e651570d66e12101e9a57040fd659" translate="yes" xml:space="preserve">
          <source>This would leave only one merge commit when your topic branch is finally ready and merged into the master branch. This merge would require you to resolve the conflict, introduced by the commits marked with &lt;code&gt;*&lt;/code&gt;. However, this conflict is often the same conflict you resolved when you created the test merge you blew away. &lt;code&gt;git rerere&lt;/code&gt; helps you resolve this final conflicted merge using the information from your earlier hand resolve.</source>
          <target state="translated">그러면 토픽 브랜치가 준비되고 마스터 브랜치로 병합 될 때 하나의 병합 커밋 만 남게됩니다. 이 병합은 &lt;code&gt;*&lt;/code&gt; 로 표시된 커밋에 의해 도입 된 충돌을 해결해야합니다 . 그러나이 충돌은 종종 테스트 병합을 만들 때 해결 한 충돌과 동일합니다. &lt;code&gt;git rerere&lt;/code&gt; 를 사용하면 이전에 해결 한 정보를 사용하여이 최종 충돌 병합을 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcd6f908de988995d9fff4cafd75d14bc0785c1a" translate="yes" xml:space="preserve">
          <source>This would leave the merge result in &lt;code&gt;hello.c~2&lt;/code&gt; file, along with conflict markers if there are conflicts. After verifying the merge result makes sense, you can tell Git what the final merge result for this file is by:</source>
          <target state="translated">그러면 충돌이있는 경우 병합 결과 가 충돌 마커와 함께 &lt;code&gt;hello.c~2&lt;/code&gt; 파일 에 남습니다 . 병합 결과가 올바른지 확인한 후 Git에이 파일의 최종 병합 결과가 무엇인지 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf5b7c750a4b16617dfd7cff20be48990a9d7985" translate="yes" xml:space="preserve">
          <source>This:</source>
          <target state="translated">This:</target>
        </trans-unit>
        <trans-unit id="ee3cacca7314105556d3050112f523980e59f973" translate="yes" xml:space="preserve">
          <source>Those snapshots aren&amp;rsquo;t necessarily all arranged in a single line from oldest to newest; instead, work may simultaneously proceed along parallel lines of development, called &lt;a href=&quot;#def_branch&quot;&gt;branches&lt;/a&gt;, which may merge and diverge.</source>
          <target state="translated">이러한 스냅 샷이 반드시 가장 오래된 것부터 가장 오래된 것까지 한 줄로 배열 된 것은 아닙니다. 대신, &lt;a href=&quot;#def_branch&quot;&gt;분기&lt;/a&gt; 라고하는 병렬 개발 라인을 따라 작업이 동시에 진행되어 병합 및 분기 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a5a53a50d0fbac4f3a27d9d2d5853146557d940" translate="yes" xml:space="preserve">
          <source>Though not required, it&amp;rsquo;s a good idea to begin the commit message with a single short (less than 50 character) line summarizing the change, followed by a blank line and then a more thorough description. The text up to the first blank line in a commit message is treated as the commit title, and that title is used throughout Git. For example, &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; turns a commit into email, and it uses the title on the Subject line and the rest of the commit in the body.</source>
          <target state="translated">필수 사항은 아니지만 변경 내용을 요약하는 짧은 한 줄 (50 자 미만)로 커밋 메시지를 시작한 다음 빈 줄과 자세한 설명으로 시작하는 것이 좋습니다. 커밋 메시지의 첫 번째 빈 줄까지의 텍스트는 커밋 제목으로 취급되며 해당 제목은 Git 전체에서 사용됩니다. 예를 들어, &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; 은 커밋을 전자 메일로 변환하고 제목 줄의 제목과 본문의 나머지 커밋을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fdd6ea0498f5dbe48e6926bc8c91e77146fa2184" translate="yes" xml:space="preserve">
          <source>Though, according to Wikipedia &lt;a href=&quot;#3&quot;&gt;[3]&lt;/a&gt;:</source>
          <target state="translated">그러나 Wikipedia에 따르면 &lt;a href=&quot;#3&quot;&gt;[3]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="18c9e3ce5bbbf77af11ba41f4d7a7d9b7a1aaa55" translate="yes" xml:space="preserve">
          <source>Thread Events</source>
          <target state="translated">스레드 이벤트</target>
        </trans-unit>
        <trans-unit id="8850eee2783cf53d0af71d524467316d7d06a850" translate="yes" xml:space="preserve">
          <source>Thread messages added to a thread-proc.</source>
          <target state="translated">스레드 메시지가 스레드 프로세스에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="1501e9d814d273ed34cc6b50f1b5e25add4ac049" translate="yes" xml:space="preserve">
          <source>Three other shorthands exist, particularly useful for merge commits, for naming a set that is formed by a commit and its parent commits.</source>
          <target state="translated">커밋과 그 부모 커밋으로 구성된 집합의 이름을 지정하기 위해 특히 병합 커밋에 유용한 세 가지 다른 속기는 존재합니다.</target>
        </trans-unit>
        <trans-unit id="8e23a87c8354d34eb4b513798d76048267e22ae4" translate="yes" xml:space="preserve">
          <source>Three steps:</source>
          <target state="translated">세 단계 :</target>
        </trans-unit>
        <trans-unit id="cf3d01be00b3333c6ca36b4d1bb0a1a1c357a43f" translate="yes" xml:space="preserve">
          <source>Throw-away integration</source>
          <target state="translated">버림받은 통합</target>
        </trans-unit>
        <trans-unit id="c4780f4837eebde8ca1de31df251ef05e2361eb2" translate="yes" xml:space="preserve">
          <source>Thunderbird</source>
          <target state="translated">Thunderbird</target>
        </trans-unit>
        <trans-unit id="d5e84648e0355ba1080675ff57a3c64a03a76a7c" translate="yes" xml:space="preserve">
          <source>Thunderbird in particular is known to be problematic. Thunderbird users may wish to visit this web page for more information: &lt;a href=&quot;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&quot;&gt;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&lt;/a&gt;</source>
          <target state="translated">썬더 버드는 특히 문제가있는 것으로 알려져 있습니다. 썬더 버드 사용자는이 웹 페이지를 방문하여 자세한 정보를 얻을 수 있습니다. &lt;a href=&quot;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&quot;&gt;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da473e9b687406079cfbc2672fddb50595865b5d" translate="yes" xml:space="preserve">
          <source>Thus we see that this tree has one file in it. The SHA-1 hash is a reference to that file&amp;rsquo;s data:</source>
          <target state="translated">따라서이 트리에는 하나의 파일이 있음을 알 수 있습니다. SHA-1 해시는 해당 파일의 데이터에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="309fb29079c2e5019b9d34cb235aee0452735a40" translate="yes" xml:space="preserve">
          <source>Thus you can, e.g., turn a library subdirectory into a repository of its own. Note the &lt;code&gt;--&lt;/code&gt; that separates &lt;code&gt;filter-branch&lt;/code&gt; options from revision options, and the &lt;code&gt;--all&lt;/code&gt; to rewrite all branches and tags.</source>
          <target state="translated">따라서 라이브러리 서브 디렉토리를 자체의 저장소로 전환 할 수 있습니다. 참고 &lt;code&gt;--&lt;/code&gt; 분리형의 것을 &lt;code&gt;filter-branch&lt;/code&gt; 개정 옵션 및에서 옵션을 &lt;code&gt;--all&lt;/code&gt; 은 모든 브랜치와 태그를 다시 작성합니다.</target>
        </trans-unit>
        <trans-unit id="d35ca4f0ad7715e9f69a7f979c2424eb99273503" translate="yes" xml:space="preserve">
          <source>Thus, the following command:</source>
          <target state="translated">따라서 다음 명령은</target>
        </trans-unit>
        <trans-unit id="77cc1ec67e1af48d92e062ee397960be200bdf58" translate="yes" xml:space="preserve">
          <source>Thus, we can provide O(log N) lookup time for any number of packfiles.</source>
          <target state="translated">따라서 여러 팩 파일에 대해 O (log N) 조회 시간을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae19d34e63a0724afdaaeabe3d0fe80af7f9e778" translate="yes" xml:space="preserve">
          <source>Time and date specified by the ISO 8601 standard, for example &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt;. The parser accepts a space instead of the &lt;code&gt;T&lt;/code&gt; character as well.</source>
          <target state="translated">ISO 8601 표준에 의해 지정된 시간과 날짜 (예 &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt; . 파서는 &lt;code&gt;T&lt;/code&gt; 문자 대신 공백을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="3919d9be78625e6edbfd2764a9b0e03204c6c677" translate="yes" xml:space="preserve">
          <source>Time and date specified by the ISO 8601 standard, for example &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt;. The parser accepts a space instead of the &lt;code&gt;T&lt;/code&gt; character as well. Fractional parts of a second will be ignored, for example &lt;code&gt;2005-04-07T22:13:13.019&lt;/code&gt; will be treated as &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt;.</source>
          <target state="translated">예를 들어, ISO 8601 표준에 의해 지정된 시간과 날짜 &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt; . 구문 분석기는 &lt;code&gt;T&lt;/code&gt; 문자 대신 공백을 허용합니다 . 초의 소수 부분은 무시됩니다. 예를 들어 &lt;code&gt;2005-04-07T22:13:13.019&lt;/code&gt; 는 &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt; 으로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="0bac72478f018c225224e8417f521a2dad6209d3" translate="yes" xml:space="preserve">
          <source>Time zone values can be &quot;local&quot; (for local time zone that browser uses), &quot;utc&quot; (what gitweb uses when JavaScript or this feature is disabled), or numerical time zones in the form of &quot;+/-HHMM&quot;, such as &quot;+0200&quot;.</source>
          <target state="translated">시간대 값은 &quot;local&quot;(브라우저가 사용하는 현지 시간대), &quot;utc&quot;(JavaScript 또는이 기능이 비활성화 된 경우 gitweb이 사용하는 것) 또는 &quot;+/- HHMM&quot;형식의 숫자 시간대 일 수 있습니다. &quot;+0200&quot;으로</target>
        </trans-unit>
        <trans-unit id="396a560fd1658574279d941c34737eda5359f4fc" translate="yes" xml:space="preserve">
          <source>Timeout (in seconds) between the moment the connection is established and the client request is received (typically a rather low value, since that should be basically immediate).</source>
          <target state="translated">연결이 설정되는 순간과 클라이언트 요청이 수신되는 시점 사이의 시간 초과 (초) : 일반적으로 즉각적으로 이루어져야하기 때문에 다소 낮은 값입니다.</target>
        </trans-unit>
        <trans-unit id="0ae2f4dfeb0fa0aaf2833b3c271308d2190a4162" translate="yes" xml:space="preserve">
          <source>Timeout (in seconds) for specific client sub-requests. This includes the time it takes for the server to process the sub-request and the time spent waiting for the next client&amp;rsquo;s request.</source>
          <target state="translated">특정 클라이언트 하위 요청에 대한 시간 초과 (초) 여기에는 서버가 하위 요청을 처리하는 데 걸리는 시간과 다음 클라이언트의 요청을 기다리는 데 걸린 시간이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ad6b83abe0aada0e5e6aec8e7e7470429fd4ee37" translate="yes" xml:space="preserve">
          <source>Tips and tricks</source>
          <target state="translated">팁과 요령</target>
        </trans-unit>
        <trans-unit id="d7242682d2f91b131962f45ed3706e536d3cdcc6" translate="yes" xml:space="preserve">
          <source>To &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; more than two &lt;a href=&quot;#def_branch&quot;&gt;branches&lt;/a&gt;.</source>
          <target state="translated">두 &lt;a href=&quot;#def_branch&quot;&gt;개&lt;/a&gt; 이상의 지점 을 &lt;a href=&quot;#def_merge&quot;&gt;병합&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f7305ba472ceab96976009902e7b731f8e52f311" translate="yes" xml:space="preserve">
          <source>To access refs, it&amp;rsquo;s best not to look inside &lt;code&gt;$GIT_DIR&lt;/code&gt; directly. Instead use commands such as &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt; or &lt;a href=&quot;git-update-ref&quot;&gt;git-update-ref[1]&lt;/a&gt; which will handle refs correctly.</source>
          <target state="translated">참조에 액세스하려면 &lt;code&gt;$GIT_DIR&lt;/code&gt; 내부를 직접 보지 않는 것이 가장 좋습니다 . 대신 &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-update-ref&quot;&gt;git-update-ref [1]&lt;/a&gt; 와 같은 명령을 사용하여 참조를 올바르게 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="7c181af3380fe2a4df836df7796a5de6ef8d47c5" translate="yes" xml:space="preserve">
          <source>To access refs, it&amp;rsquo;s best not to look inside GIT_DIR directly. Instead use commands such as &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt; or &lt;a href=&quot;git-update-ref&quot;&gt;git-update-ref[1]&lt;/a&gt; which will handle refs correctly.</source>
          <target state="translated">심판에 액세스하려면 GIT_DIR 내부를 직접 보지 않는 것이 가장 좋습니다. 대신 &lt;a href=&quot;git-update-ref&quot;&gt;ref를&lt;/a&gt; 올바르게 처리하는 &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt; 또는 git-update-ref [1] 과 같은 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bdc5ec95e827bdeffd1f9aab0bef5dd1e05d0443" translate="yes" xml:space="preserve">
          <source>To achieve this, try to split your work into small steps from the very beginning. It is always easier to squash a few commits together than to split one big commit into several. Don&amp;rsquo;t be afraid of making too small or imperfect steps along the way. You can always go back later and edit the commits with &lt;code&gt;git rebase --interactive&lt;/code&gt; before you publish them. You can use &lt;code&gt;git stash push --keep-index&lt;/code&gt; to run the test suite independent of other uncommitted changes; see the EXAMPLES section of &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">이를 위해서는 처음부터 작은 단계로 작업을 분할하십시오. 하나의 큰 커밋을 여러 개의 커밋으로 나누는 것보다 몇 개의 커밋을 함께 스쿼시하는 것이 항상 쉽습니다. 길을 따라 너무 작거나 불완전한 발걸음을 내딛는 것을 두려워하지 마십시오. 커밋 하기 전에 언제든지 &lt;code&gt;git rebase --interactive&lt;/code&gt; 로 커밋을 편집하고 편집 할 수 있습니다. &lt;code&gt;git stash push --keep-index&lt;/code&gt; 를 사용하여 커밋되지 않은 다른 변경과 독립적으로 테스트 스위트를 실행할 수 있습니다 . &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; 의 예제 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0fad63887775e60c970096082173b077cbcda459" translate="yes" xml:space="preserve">
          <source>To actually match only values with an exclamation mark, you have to</source>
          <target state="translated">느낌표가있는 값만 실제로 일치 시키려면</target>
        </trans-unit>
        <trans-unit id="0fea0d3a69770ac7053eba17165f8f811c0d830f" translate="yes" xml:space="preserve">
          <source>To add a new proxy, without altering any of the existing ones, use</source>
          <target state="translated">기존 프록시를 변경하지 않고 새 프록시를 추가하려면</target>
        </trans-unit>
        <trans-unit id="6a37f3f129452efb4608e170beca8c23ff8dc189" translate="yes" xml:space="preserve">
          <source>To aid in debugging frontends fast-import ignores any line that begins with &lt;code&gt;#&lt;/code&gt; (ASCII pound/hash) up to and including the line ending &lt;code&gt;LF&lt;/code&gt;. A comment line may contain any sequence of bytes that does not contain an LF and therefore may be used to include any detailed debugging information that might be specific to the frontend and useful when inspecting a fast-import data stream.</source>
          <target state="translated">프론트 엔드 디버깅을 돕기 위해 빠른 가져 오기는 &lt;code&gt;#&lt;/code&gt; (ASCII 파운드 / 해시)로 시작하는 라인부터 &lt;code&gt;LF&lt;/code&gt; 까지 끝나는 라인을 무시합니다 . 주석 행은 LF를 포함하지 않는 임의의 바이트 시퀀스를 포함 할 수 있으므로 빠른 가져 오기 데이터 스트림을 검사 할 때 프론트 엔드에 고유하고 상세한 디버깅 정보를 포함하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="285359187a2aff04e4ea763b2f3e4bbaf641190b" translate="yes" xml:space="preserve">
          <source>To assist in this, Git also provides the tag object&amp;hellip;​</source>
          <target state="translated">이를 돕기 위해 Git은 태그 객체도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="39ed0e01aa6b6521a62db21f8653937d0b5ccadd" translate="yes" xml:space="preserve">
          <source>To avoid common misconfiguration mistakes, &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt; will abort with a warning if any configuration options for &quot;sendmail&quot; exist. Set this variable to bypass the check.</source>
          <target state="translated">일반적인 잘못된 구성 실수를 방지하기 위해 &lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt; 은 &quot;sendmail&quot;에 대한 구성 옵션이있는 경우 경고와 함께 중단됩니다. 검사를 우회하려면이 변수를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="b0021f1eb05e23f63eb7ccc2f58c52546ee61585" translate="yes" xml:space="preserve">
          <source>To avoid deadlock, such frontends must completely consume any pending output from &lt;code&gt;progress&lt;/code&gt;, &lt;code&gt;ls&lt;/code&gt;, &lt;code&gt;get-mark&lt;/code&gt;, and &lt;code&gt;cat-blob&lt;/code&gt; before performing writes to fast-import that might block.</source>
          <target state="translated">교착 상태를 피하려면 이러한 프론트 엔드 가 차단 될 수있는 빠른 가져 오기에 쓰기를 수행하기 전에 &lt;code&gt;progress&lt;/code&gt; , &lt;code&gt;ls&lt;/code&gt; , &lt;code&gt;get-mark&lt;/code&gt; 및 &lt;code&gt;cat-blob&lt;/code&gt; 에서 보류중인 출력을 완전히 소비해야합니다 .</target>
        </trans-unit>
        <trans-unit id="75e1daad195d404dc835c71216234df4a4676d4e" translate="yes" xml:space="preserve">
          <source>To avoid deleting a shared index file that is still used, its modification time is updated to the current time every time a new split index based on the shared index file is either created or read from.</source>
          <target state="translated">여전히 사용되는 공유 인덱스 파일을 삭제하지 않으려면 공유 인덱스 파일을 기반으로하는 새 분할 인덱스를 만들거나 읽을 때마다 수정 시간이 현재 시간으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="0b95bb4f949904cf33707d2a81be23c345f8e5aa" translate="yes" xml:space="preserve">
          <source>To avoid false positives (e.g. when a patch has been removed, and an unrelated patch has been added between two iterations of the same patch series), the cost matrix is extended to allow for that, by adding fixed-cost entries for wholesale deletes/adds.</source>
          <target state="translated">오 탐지 (예 : 패치가 제거되고 동일한 패치 시리즈의 두 반복간에 관련이없는 패치가 추가 된 경우)를 방지하기 위해 도매 삭제에 고정 비용 항목을 추가하여 비용 매트릭스를 확장 할 수 있습니다. 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0fd573776931ed5e5643654b60eb3896366ed973" translate="yes" xml:space="preserve">
          <source>To avoid interfering with other worktrees, it first enables the &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; setting and makes sure to set the &lt;code&gt;core.sparseCheckout&lt;/code&gt; setting in the worktree-specific config file.</source>
          <target state="translated">다른 작업 트리와의 간섭을 피하기 위해 먼저 &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; 설정을 활성화하고 작업 트리 특정 구성 파일에서 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 설정 을 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3c2082115575958e10a9c1afdaf9ab0c9127b12a" translate="yes" xml:space="preserve">
          <source>To avoid recording unrelated changes in the merge commit, &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt; will also abort if there are any changes registered in the index relative to the &lt;code&gt;HEAD&lt;/code&gt; commit. (Special narrow exceptions to this rule may exist depending on which merge strategy is in use, but generally, the index must match HEAD.)</source>
          <target state="translated">병합 커밋에서 관련없는 변경 사항을 기록하지 않기 위해 &lt;code&gt;HEAD&lt;/code&gt; 커밋과 관련하여 인덱스에 등록 된 변경 사항이있는 경우 &lt;code&gt;git pull&lt;/code&gt; 및 &lt;code&gt;git merge&lt;/code&gt; 도 중단됩니다 . 사용중인 병합 전략에 따라이 규칙에 대한 특별한 좁은 예외가있을 수 있지만 일반적으로 인덱스는 HEAD와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="3066556f3c40d15744968614a5fc8c1e23bf8a7b" translate="yes" xml:space="preserve">
          <source>To avoid typing long email addresses, point this to one or more email aliases files. You must also supply &lt;code&gt;sendemail.aliasFileType&lt;/code&gt;.</source>
          <target state="translated">긴 이메일 주소를 입력하지 않으려면 하나 이상의 이메일 별명 파일을 가리 킵니다. &lt;code&gt;sendemail.aliasFileType&lt;/code&gt; 도 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c4b87fbf313d264308ea989e0e3b9a4c3d776c25" translate="yes" xml:space="preserve">
          <source>To bootstrap the process, you can first create a bundle that does not have any basis. You can use a tag to remember up to what commit you last processed, in order to make it easy to later update the other repository with an incremental bundle:</source>
          <target state="translated">프로세스를 부트 스트랩하려면 먼저 기본이없는 번들을 작성할 수 있습니다. 나중에 증분 번들로 다른 저장소를 쉽게 업데이트 할 수 있도록 태그를 사용하여 마지막으로 처리 한 커밋까지 기억할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d8840568125195e79747db7654d577582e9ce27" translate="yes" xml:space="preserve">
          <source>To change which notes are shown by &lt;code&gt;git log&lt;/code&gt;, see the &quot;notes.displayRef&quot; configuration in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;git log&lt;/code&gt; 로 표시되는 메모를 변경하려면 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 의 &quot;notes.displayRef&quot;구성을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="97883ec3271fcc02269394ee0880b3655a6f452f" translate="yes" xml:space="preserve">
          <source>To check out commit &lt;code&gt;HEAD~3&lt;/code&gt; for temporary inspection or experiment without creating a new branch:</source>
          <target state="translated">새 분기를 만들지 않고 임시 검사 또는 실험을 위해 커밋 &lt;code&gt;HEAD~3&lt;/code&gt; 을 확인하려면 :</target>
        </trans-unit>
        <trans-unit id="d144f3be27bf6711b21fc83fdbf3f1e8ff9fc321" translate="yes" xml:space="preserve">
          <source>To commit a tree you have instantiated with &lt;code&gt;git write-tree&lt;/code&gt;, you&amp;rsquo;d create a &quot;commit&quot; object that refers to that tree and the history behind it&amp;mdash;​most notably the &quot;parent&quot; commits that preceded it in history.</source>
          <target state="translated">&lt;code&gt;git write-tree&lt;/code&gt; 로 인스턴스화 한 트리를 커밋하려면 해당 트리와 그 히스토리를 참조하는 &quot;커밋&quot;객체를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="05e44c536d85ee3801aa2c0d698cefa8d09c4c33" translate="yes" xml:space="preserve">
          <source>To completely remove a submodule, manually delete &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt;.</source>
          <target state="translated">서브 모듈을 완전히 제거하려면 &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; 수동으로 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="27c15a86c7e79c3805e163825e563ceb0da18b5a" translate="yes" xml:space="preserve">
          <source>To control which revisions to show, gitk supports most options applicable to the &lt;code&gt;git rev-list&lt;/code&gt; command. It also supports a few options applicable to the &lt;code&gt;git diff-*&lt;/code&gt; commands to control how the changes each commit introduces are shown. Finally, it supports some gitk-specific options.</source>
          <target state="translated">표시 할 개정을 제어하기 위해 gitk는 &lt;code&gt;git rev-list&lt;/code&gt; 명령에 적용 가능한 대부분의 옵션을 지원합니다 . 또한 &lt;code&gt;git diff-*&lt;/code&gt; 명령에 적용 할 수있는 몇 가지 옵션을 지원하여 각 커밋의 변경 내용 표시 방법을 제어합니다. 마지막으로, 일부 gitk 특정 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="777e371b82028c9765bc912013f44d79febb95a6" translate="yes" xml:space="preserve">
          <source>To cope with such a situation, after the inner &lt;code&gt;git bisect&lt;/code&gt; finds the next revision to test, the script can apply the patch before compiling, run the real test, and afterwards decide if the revision (possibly with the needed patch) passed the test and then rewind the tree to the pristine state. Finally the script should exit with the status of the real test to let the &lt;code&gt;git bisect run&lt;/code&gt; command loop determine the eventual outcome of the bisect session.</source>
          <target state="translated">이러한 상황에 대처하기 위해 내부 &lt;code&gt;git bisect&lt;/code&gt; 가 테스트 할 다음 개정을 찾은 후 스크립트는 컴파일하기 전에 패치를 적용하고 실제 테스트를 실행 한 후 수정 (필요한 패치로 가능)이 테스트를 통과했는지 여부를 결정하고 그런 다음 트리를 원래 상태로 되감습니다. 마지막으로 스크립트는 실제 테스트 상태와 함께 종료되어 &lt;code&gt;git bisect run&lt;/code&gt; 명령 루프가 bisect 세션의 최종 결과를 결정하도록합니다.</target>
        </trans-unit>
        <trans-unit id="8674c1ca562e6ecc34e19d2429ea897e7602bd28" translate="yes" xml:space="preserve">
          <source>To create your own local live copy of such a &quot;raw&quot; Git repository, you&amp;rsquo;d first create your own subdirectory for the project, and then copy the raw repository contents into the &lt;code&gt;.git&lt;/code&gt; directory. For example, to create your own copy of the Git repository, you&amp;rsquo;d do the following</source>
          <target state="translated">이러한 &quot;원시&quot;Git 저장소의 자체 로컬 라이브 사본을 작성하려면 먼저 프로젝트에 대한 자체 서브 디렉토리를 작성한 후 원시 저장소 컨텐츠를 &lt;code&gt;.git&lt;/code&gt; 디렉토리에 복사하십시오 . 예를 들어, Git 리포지토리의 자체 복사본을 만들려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="495be7922d2a293092e6f366efd8045104e01478" translate="yes" xml:space="preserve">
          <source>To define a custom merge driver &lt;code&gt;filfre&lt;/code&gt;, add a section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">사용자 정의 병합 드라이버 &lt;code&gt;filfre&lt;/code&gt; 를 정의하려면 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 파일 (또는 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 파일)에 다음과 같이 섹션을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="369d97c17e3edbb633e139fcbb4d6a1ea94c1201" translate="yes" xml:space="preserve">
          <source>To define an external diff driver &lt;code&gt;jcdiff&lt;/code&gt;, add a section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">외부 diff 드라이버 &lt;code&gt;jcdiff&lt;/code&gt; 를 정의하려면 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 파일 (또는 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 파일)에 다음과 같이 섹션을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="302897a013466c7a33ee45af87c508a98422abd4" translate="yes" xml:space="preserve">
          <source>To delete the entry for renames, do</source>
          <target state="translated">이름을 바꾸려면 해당 항목을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="f31f6b0ae1c80bea942e287ae0ab318c31ede1f4" translate="yes" xml:space="preserve">
          <source>To determine the location of the repository on disk, &lt;code&gt;git http-backend&lt;/code&gt; concatenates the environment variables PATH_INFO, which is set automatically by the web server, and GIT_PROJECT_ROOT, which must be set manually in the web server configuration. If GIT_PROJECT_ROOT is not set, &lt;code&gt;git http-backend&lt;/code&gt; reads PATH_TRANSLATED, which is also set automatically by the web server.</source>
          <target state="translated">디스크에서 저장소의 위치를 ​​판별하기 위해 &lt;code&gt;git http-backend&lt;/code&gt; 는 웹 서버에서 자동으로 설정 한 환경 변수 PATH_INFO와 웹 서버 구성에서 수동으로 설정해야하는 GIT_PROJECT_ROOT를 연결합니다. GIT_PROJECT_ROOT가 설정되어 있지 않은 경우, &lt;code&gt;git http-backend&lt;/code&gt; 는 PATH_TRANSLATED를 읽으며 웹 서버에 의해 자동으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b99f7180a07f9dbb13dde063c76c98dd5e2d7887" translate="yes" xml:space="preserve">
          <source>To disable features that accept parameters (are configurable), you need to set this element to empty list i.e. &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">매개 변수를 허용하는 기능을 비활성화하려면 (구성 가능)이 요소를 빈 목록 (예 : &lt;code&gt;[]&lt;/code&gt; ) 으로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="43f3c91605c9cb6d680c0ea9cf4c1bb2e77b4d9d" translate="yes" xml:space="preserve">
          <source>To disable interactive logins, displaying a greeting instead:</source>
          <target state="translated">대화 형 로그인을 비활성화하려면 인사말을 대신 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="2e78622c40c98dec97477af783b12ba20d12cc1a" translate="yes" xml:space="preserve">
          <source>To display the &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; man page, use &lt;code&gt;git help git&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; 매뉴얼 페이지 를 표시하려면 &lt;code&gt;git help git&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa4dddf358b16e56494c90923230fd025e6f958d" translate="yes" xml:space="preserve">
          <source>To do automatic tag object dereferencing, use the &quot;-d&quot; or &quot;--dereference&quot; flag, so you can do</source>
          <target state="translated">자동 태그 객체 역 참조를 수행하려면 &quot;-d&quot;또는 &quot;--dereference&quot;플래그를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dc05ce874d6baee1eae11d94d6fd56f1e0a6d0ed" translate="yes" xml:space="preserve">
          <source>To do the merge, do</source>
          <target state="translated">병합을 수행하려면</target>
        </trans-unit>
        <trans-unit id="45ed93b09b65e276ec2ef33a1d9d7c3e10d14bfe" translate="yes" xml:space="preserve">
          <source>To do this, the current maintenance branch is copied to another branch named with the previous release version number (e.g. maint-X.Y.(Z-1) where X.Y.Z is the current release).</source>
          <target state="translated">이를 위해 현재 유지 보수 분기가 이전 릴리스 버전 번호로 이름 지정된 다른 분기 (예 : XYZ가 현재 릴리스 인 maint-XY (Z-1))로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="380aa6a091a04ad8bbf89399d1982760e370374e" translate="yes" xml:space="preserve">
          <source>To drop a commit, replace the command &quot;pick&quot; with &quot;drop&quot;, or just delete the matching line.</source>
          <target state="translated">커밋을 삭제하려면 &quot;pick&quot;명령을 &quot;drop&quot;으로 바꾸거나 일치하는 행을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="e05b8854f808624747710c5e1d641ee4dabaf30c" translate="yes" xml:space="preserve">
          <source>To elaborate, &quot;reading&quot; means checking for file existence, reading file attributes or file content. The working directory version may be present or absent. If present, its content may match against the index version or not. Writing is not affected by this bit, content safety is still first priority. Note that Git &lt;code&gt;can&lt;/code&gt; update working directory file, that is marked skip-worktree, if it is safe to do so (i.e. working directory version matches index version)</source>
          <target state="translated">자세히 설명하면 &quot;읽기&quot;는 파일 존재 여부 확인, 파일 속성 또는 파일 내용 읽기를 의미합니다. 작업 디렉토리 버전이 있거나 없을 수 있습니다. 존재하는 경우 해당 컨텐츠가 인덱스 버전과 일치하거나 일치하지 않을 수 있습니다. 쓰기는이 비트의 영향을받지 않으며 콘텐츠 안전이 여전히 최우선 순위입니다. 망할 놈의 것을 참고 &lt;code&gt;can&lt;/code&gt; 안전한 경우, 스킵 - worktree 표시되어 작업 디렉토리의 파일을 업데이트합니다 (즉, 디렉토리 버전을 작업하는 인덱스 버전과 일치)</target>
        </trans-unit>
        <trans-unit id="64ecd7272d648bbcdba5e527a1a80e43cb0705c5" translate="yes" xml:space="preserve">
          <source>To enable &lt;code&gt;git archive --remote&lt;/code&gt; and disable &lt;code&gt;git fetch&lt;/code&gt; against a repository, have the following in the configuration file in the repository (that is the file &lt;code&gt;config&lt;/code&gt; next to &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;refs&lt;/code&gt; and &lt;code&gt;objects&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;git archive --remote&lt;/code&gt; 를 활성화 하고 리포지토리에 대해 &lt;code&gt;git fetch&lt;/code&gt; 를 비활성화 하려면 리포지토리의 구성 파일 ( &lt;code&gt;HEAD&lt;/code&gt; , &lt;code&gt;refs&lt;/code&gt; 및 &lt;code&gt;objects&lt;/code&gt; 옆에 있는 파일 &lt;code&gt;config&lt;/code&gt; 다음 이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="af7d8457fff28a2087e0f74bc51d0468026a9bff" translate="yes" xml:space="preserve">
          <source>To enable a target, set the corresponding environment variable or system or global config value to one of the following:</source>
          <target state="translated">대상을 사용하려면 해당 환경 변수 또는 시스템 또는 전역 구성 값을 다음 중 하나로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="01e6eac26c3bbc386ab13c8cd6a9167801f24836" translate="yes" xml:space="preserve">
          <source>To enable anonymous read access but authenticated write access, require authorization for both the initial ref advertisement (which we detect as a push via the service parameter in the query string), and the receive-pack invocation itself:</source>
          <target state="translated">익명 읽기 액세스와 인증 된 쓰기 액세스를 사용하려면 초기 참조 광고 (조회 문자열에서 서비스 매개 변수를 통한 푸시로 감지) 및 수신 팩 호출 자체에 대한 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9bda367b82f8881561a1128afb27f36988891c35" translate="yes" xml:space="preserve">
          <source>To enable anonymous read access but authenticated write access:</source>
          <target state="translated">익명 읽기 액세스를 허용하지만 인증 된 쓰기 액세스를 활성화하려면</target>
        </trans-unit>
        <trans-unit id="050d5472dcd3f05f019f9a8129d0bb6d5e205df8" translate="yes" xml:space="preserve">
          <source>To enable blame, pickaxe search, and snapshot support (allowing &quot;tar.gz&quot; and &quot;zip&quot; snapshots), while allowing individual projects to turn them off, put the following in your GITWEB_CONFIG file:</source>
          <target state="translated">비난, 곡괭이 검색 및 스냅 샷 지원 ( &quot;tar.gz&quot;및 &quot;zip&quot;스냅 샷 허용)을 활성화하고 개별 프로젝트에서 끌 수 있도록하려면 GITWEB_CONFIG 파일에 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="fa7174e314ce7012972664ac5bcf82d4b390a6d5" translate="yes" xml:space="preserve">
          <source>To enable git-cvsserver access (which should generally have the &lt;code&gt;no-interactive-login&lt;/code&gt; example above as a prerequisite, as creating the git-shell-commands directory allows interactive logins):</source>
          <target state="translated">git-cvsserver 액세스를 활성화하려면 ( git-shell-commands 디렉토리를 만들면 &lt;code&gt;no-interactive-login&lt;/code&gt; 이 가능하므로 일반적으로 위 의 no-interactive-login 예제가 전제 조건으로 있어야 함) :</target>
        </trans-unit>
        <trans-unit id="69aa803d2928631745bb26ea6d720a34de175dd7" translate="yes" xml:space="preserve">
          <source>To enable that additional nice feature, when a bisection is started and when some good commits are not ancestors of the bad commit, we first compute the merge bases between the bad and the good commits and we chose these merge bases as the first commits that will be checked out and tested.</source>
          <target state="translated">추가 멋진 기능을 사용하기 위해, bisection이 시작될 때와 일부 좋은 commit이 bad commit의 조상이 아닌 경우, 먼저 bad와 good commit 사이의 병합 기준을 계산하고 이러한 병합 기준을 첫 번째 확약으로 선택합니다. 체크 아웃하고 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="ba44f6ad0a0230b79b3149aabc029b57fd7f22d9" translate="yes" xml:space="preserve">
          <source>To enable the sparse-checkout feature, run &lt;code&gt;git sparse-checkout init&lt;/code&gt; to initialize a simple sparse-checkout file and enable the &lt;code&gt;core.sparseCheckout&lt;/code&gt; config setting. Then, run &lt;code&gt;git sparse-checkout set&lt;/code&gt; to modify the patterns in the sparse-checkout file.</source>
          <target state="translated">스파 스 체크 아웃 기능을 활성화하려면 &lt;code&gt;git sparse-checkout init&lt;/code&gt; 를 실행 하여 간단한 스파 스 체크 아웃 파일을 초기화하고 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 구성 설정을 활성화하십시오 . 그런 다음 &lt;code&gt;git sparse-checkout set&lt;/code&gt; 를 실행 하여 sparse-checkout 파일의 패턴을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="1318b73efc503f41a06d5d140c646ee25cf7e427" translate="yes" xml:space="preserve">
          <source>To exclude commits reachable from a commit, a prefix &lt;code&gt;^&lt;/code&gt; notation is used. E.g. &lt;code&gt;^r1 r2&lt;/code&gt; means commits reachable from &lt;code&gt;r2&lt;/code&gt; but exclude the ones reachable from &lt;code&gt;r1&lt;/code&gt; (i.e. &lt;code&gt;r1&lt;/code&gt; and its ancestors).</source>
          <target state="translated">커밋에서 도달 가능한 커밋을 제외하기 위해 접두사 &lt;code&gt;^&lt;/code&gt; 표기법이 사용됩니다. 예 &lt;code&gt;^r1 r2&lt;/code&gt; 수단의 커밋에서 도달 &lt;code&gt;r2&lt;/code&gt; 하지만 사람이에서 접근 제외 &lt;code&gt;r1&lt;/code&gt; (즉, &lt;code&gt;r1&lt;/code&gt; 과 그 조상).</target>
        </trans-unit>
        <trans-unit id="a12d809ea9b20c2b561957b059e3fe943cb6e440" translate="yes" xml:space="preserve">
          <source>To find out how the result can be used, just read on in &lt;code&gt;cmd_cat_file()&lt;/code&gt;:</source>
          <target state="translated">결과 사용 방법을 알아 보려면 &lt;code&gt;cmd_cat_file()&lt;/code&gt; 에서 계속 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="338cdf0c3d82152dc96e1eae9cd9922bf736e76c" translate="yes" xml:space="preserve">
          <source>To get a checkout with the Eclipse CVS client:</source>
          <target state="translated">Eclipse CVS 클라이언트로 체크 아웃하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="976f859125db1311d8f82bb8df703ef2ad537fd0" translate="yes" xml:space="preserve">
          <source>To get a reminder of the currently used terms, use</source>
          <target state="translated">현재 사용 된 용어를 상기시키기 위해</target>
        </trans-unit>
        <trans-unit id="68b714c59ff5898ff58433a2938d52aeb27df43e" translate="yes" xml:space="preserve">
          <source>To get started with gitweb, run &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; from a Git repository. This would configure and start your web server, and run web browser pointing to gitweb.</source>
          <target state="translated">gitweb을 시작하려면 Git 리포지토리에서 &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt; 을 실행하십시오 . 이것은 웹 서버를 구성하고 시작하고 gitweb을 가리키는 웹 브라우저를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="bf62a03860b36b4b6a615592146052d88035a5f4" translate="yes" xml:space="preserve">
          <source>To get the &quot;base&quot; for the merge, look up the common parent of two commits:</source>
          <target state="translated">병합의 &quot;기본&quot;을 얻으려면 두 커밋의 공통 부모를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="ec1f343ca45777aa33e95b7222bfb7658aa36062" translate="yes" xml:space="preserve">
          <source>To get the feature/bugfix into an integration branch, simply merge it. If the topic has evolved further in the meantime, merge again. (Note that you do not necessarily have to merge it to the oldest integration branch first. For example, you can first merge a bugfix to &lt;code&gt;next&lt;/code&gt;, give it some testing time, and merge to &lt;code&gt;maint&lt;/code&gt; when you know it is stable.)</source>
          <target state="translated">기능 / 버그 픽스를 통합 브랜치로 가져 오려면 간단히 병합하십시오. 그 동안 주제가 더 발전한 경우 다시 병합하십시오. (가장 오래된 통합 브랜치에 먼저 병합 할 필요는 없습니다. 예를 들어, 먼저 버그 수정을 &lt;code&gt;next&lt;/code&gt; 에 병합하고 , 테스트 시간을 제공하고, 안정적인 것으로 판단되면 &lt;code&gt;maint&lt;/code&gt; 에 병합 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="60ae758b58fc83602f1720fb9cc2f0f4fb30b090" translate="yes" xml:space="preserve">
          <source>To give some hard figures, we used to have an average report-to-fix cycle of 142.6 hours (according to our somewhat weird bug-tracker which just measures wall-clock time). Since we moved to Git, we&amp;rsquo;ve lowered that to 16.2 hours. Primarily because we can stay on top of the bug fixing now, and because everyone&amp;rsquo;s jockeying to get to fix bugs (we&amp;rsquo;re quite proud of how lazy we are to let Git find the bugs for us). Each new release results in ~40% fewer bugs (almost certainly due to how we now feel about writing tests).</source>
          <target state="translated">어려운 수치를 제공하기 위해 평균 시계 수정주기는 ​​142.6 시간이었습니다 (벽 시계 시간을 측정하는 다소 이상한 버그 추적기에 따라). Git으로 옮긴 이후 16.2 시간으로 줄였습니다. 우리는 지금 버그 수정을 계속 할 수 있고 모든 사람들이 버그를 고치려고 애 쓰고 있기 때문에 (Git에서 버그를 찾게하는 것이 얼마나 게으른 지 자랑스럽게 생각합니다). 새로 출시 될 때마다 버그가 약 40 % 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="cc855cb566c405d222e3a3236275bbad376833c3" translate="yes" xml:space="preserve">
          <source>To help with that, &lt;code&gt;range&lt;/code&gt; uses the &lt;code&gt;--dual-color&lt;/code&gt; mode by default. In this mode, the diff of diffs will retain the original diff colors, and prefix the lines with -/+ markers that have their &lt;strong&gt;background&lt;/strong&gt; red or green, to make it more obvious that they describe how the diff itself changed.</source>
          <target state="translated">이를 돕기 위해 &lt;code&gt;range&lt;/code&gt; 는 기본적으로 &lt;code&gt;--dual-color&lt;/code&gt; 모드를 사용합니다 . 이 모드에서 diff diff는 원래 diff 색상을 유지하고 선이 &lt;strong&gt;배경이&lt;/strong&gt; 빨간색 또는 녹색 인 -/ + 마커로 접두어 diff 자체가 어떻게 바뀌 었는지 더 명확하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="096c5d9029f3f58b2af501ec17fb5d42ac0f73fe" translate="yes" xml:space="preserve">
          <source>To illustrate the difference between &lt;code&gt;-S&amp;lt;regex&amp;gt; --pickaxe-regex&lt;/code&gt; and &lt;code&gt;-G&amp;lt;regex&amp;gt;&lt;/code&gt;, consider a commit with the following diff in the same file:</source>
          <target state="translated">차이점을 설명하기 &lt;code&gt;-S&amp;lt;regex&amp;gt; --pickaxe-regex&lt;/code&gt; 과 &lt;code&gt;-G&amp;lt;regex&amp;gt;&lt;/code&gt; A는 동일한 파일에서 다음과 DIFF 커밋 고려해</target>
        </trans-unit>
        <trans-unit id="e67d6de21feaa90def83753eb253a23faea561fa" translate="yes" xml:space="preserve">
          <source>To illustrate, suppose you are in a situation where someone develops a &lt;code&gt;subsystem&lt;/code&gt; branch, and you are working on a &lt;code&gt;topic&lt;/code&gt; that is dependent on this &lt;code&gt;subsystem&lt;/code&gt;. You might end up with a history like the following:</source>
          <target state="translated">예를 들어, 누군가 &lt;code&gt;subsystem&lt;/code&gt; 브랜치를 개발 하고이 &lt;code&gt;subsystem&lt;/code&gt; 종속 된 &lt;code&gt;topic&lt;/code&gt; 에 대해 작업하고 있다고 가정하십시오 . 다음과 같은 기록으로 끝날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a98d25733140cb4450fff563f123b0d4cafeb9f9" translate="yes" xml:space="preserve">
          <source>To interrupt the rebase (just like an &quot;edit&quot; command would do, but without cherry-picking any commit first), use the &quot;break&quot; command.</source>
          <target state="translated">rebase를 중단 시키려면 ( &quot;edit&quot;명령과 같지만 먼저 commit을 선택하지 않고) &quot;break&quot;명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f6408dba3913ebdb903fdfce1d68f1906d3e56f0" translate="yes" xml:space="preserve">
          <source>To look at only non-zero stages, use &lt;code&gt;--unmerged&lt;/code&gt; flag:</source>
          <target state="translated">0이 아닌 단계 만 &lt;code&gt;--unmerged&lt;/code&gt; 플래그를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b273f729e50c3bb1996889c896c925cce764cd8" translate="yes" xml:space="preserve">
          <source>To make it readable, we can tell &lt;code&gt;git diff-files&lt;/code&gt; to output the differences as a patch, using the &lt;code&gt;-p&lt;/code&gt; flag:</source>
          <target state="translated">읽을 수 있도록 &lt;code&gt;-p&lt;/code&gt; 플래그를 사용하여 &lt;code&gt;git diff-files&lt;/code&gt; 가 패치로 차이점을 출력하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fa7b34f2837aaeca157590c3f1e04cfe3400ecb" translate="yes" xml:space="preserve">
          <source>To make referencing the final pathname simpler, you can map each path component; so if you also anonymize &lt;code&gt;subdir&lt;/code&gt; to &lt;code&gt;publicdir&lt;/code&gt;, then the final pathname would be &lt;code&gt;publicdir/bar.c&lt;/code&gt;.</source>
          <target state="translated">최종 경로 이름을 더 간단하게 참조하기 위해 각 경로 구성 요소를 매핑 할 수 있습니다. 따라서 &lt;code&gt;subdir&lt;/code&gt; 을 &lt;code&gt;publicdir&lt;/code&gt; 로 익명화 하면 최종 경로 이름은 &lt;code&gt;publicdir/bar.c&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="5411ef1231b1da2dbabaf49f4348af685832f2f7" translate="yes" xml:space="preserve">
          <source>To move the whole tree into a subdirectory, or remove it from there:</source>
          <target state="translated">전체 트리를 서브 디렉토리로 이동 시키거나 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="9fef1883cb2bb53007927c93e3d8f7431145efad" translate="yes" xml:space="preserve">
          <source>To perform a three-way merge, you start with the two commits you want to merge, find their closest common parent (a third commit), and compare the trees corresponding to these three commits.</source>
          <target state="translated">3 방향 병합을 수행하려면 병합하려는 두 커밋으로 시작하여 가장 가까운 공통 상위 (세 번째 커밋)를 찾은 다음이 세 커밋에 해당하는 트리를 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="a35f3e8a10774da4c0b0f3f87118660d7ef9889e" translate="yes" xml:space="preserve">
          <source>To place a higher stage entry to the index, the path should first be removed by feeding a mode=0 entry for the path, and then feeding necessary input lines in the third format.</source>
          <target state="translated">인덱스에 더 높은 단계 항목을 배치하려면 먼저 경로에 mode = 0 항목을 공급 한 다음 필요한 입력 행을 세 번째 형식으로 공급하여 경로를 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="26b0cbf1bc1090821ae6f59cac15f02ec7f562f8" translate="yes" xml:space="preserve">
          <source>To prepare for working on &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;, switch to it by updating the index and the files in the working tree, and by pointing &lt;code&gt;HEAD&lt;/code&gt; at the branch. Local modifications to the files in the working tree are kept, so that they can be committed to the &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 작업을 준비하려면 작업 트리에서 색인과 파일을 업데이트 하고 분기에서 &lt;code&gt;HEAD&lt;/code&gt; 를 가리켜 서 해당 지점으로 전환하십시오. 작업 트리의 파일에 대한 로컬 수정은 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 에 커밋 될 수 있도록 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="13739c43ac679e23fc4c2d09478ac31e5293cb15" translate="yes" xml:space="preserve">
          <source>To pretend you have a file at path with mode and sha1, say:</source>
          <target state="translated">mode 및 sha1을 사용하여 경로에 파일이 있다고 가정하려면 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="6785e6ba620455f331d4a09eb8363e2600eabf25" translate="yes" xml:space="preserve">
          <source>To prevent a $GIT_DIR/worktrees entry from being pruned (which can be useful in some situations, such as when the entry&amp;rsquo;s working tree is stored on a portable device), use the &lt;code&gt;git worktree lock&lt;/code&gt; command, which adds a file named &lt;code&gt;locked&lt;/code&gt; to the entry&amp;rsquo;s directory. The file contains the reason in plain text. For example, if a linked working tree&amp;rsquo;s &lt;code&gt;.git&lt;/code&gt; file points to &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; then a file named &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; will prevent the &lt;code&gt;test-next&lt;/code&gt; entry from being pruned. See &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; for details.</source>
          <target state="translated">달러 (A $) GIT_DIR을 방지하기 위해 / (예 : 항목의 작업 트리가 휴대용 장치에 저장 될 때와 같은 일부 상황에서 유용 할 수 있습니다) 정리되는 항목, 사용 worktrees &lt;code&gt;git worktree lock&lt;/code&gt; 라는 이름의 파일 추가 명령, &lt;code&gt;locked&lt;/code&gt; 받는 사람을 항목의 디렉토리. 파일에는 이유가 일반 텍스트로 포함되어 있습니다. 링크 된 작업 트리의 예를 들어, &lt;code&gt;.git&lt;/code&gt; 파일 포인트가 &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; 다음라는 파일 &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; 은 방지 할 수 있습니다 &lt;code&gt;test-next&lt;/code&gt; 정리되는 다음 항목. 자세한 내용은 &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="af2e73e27abe3e4382121e1f7c2af8f2dfcf3321" translate="yes" xml:space="preserve">
          <source>To prevent a &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; entry from being pruned (which can be useful in some situations, such as when the entry&amp;rsquo;s working tree is stored on a portable device), use the &lt;code&gt;git worktree lock&lt;/code&gt; command, which adds a file named &lt;code&gt;locked&lt;/code&gt; to the entry&amp;rsquo;s directory. The file contains the reason in plain text. For example, if a linked working tree&amp;rsquo;s &lt;code&gt;.git&lt;/code&gt; file points to &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; then a file named &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; will prevent the &lt;code&gt;test-next&lt;/code&gt; entry from being pruned. See &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; 항목이 정리되는 것을 방지하려면 (항목의 작업 트리가 휴대용 장치에 저장되는 경우와 같은 일부 상황에서 유용 할 수 있음) &lt;code&gt;git worktree lock&lt;/code&gt; 명령을 사용하여 &lt;code&gt;locked&lt;/code&gt; 라는 파일 을 항목의 디렉토리. 파일에는 이유가 일반 텍스트로 포함되어 있습니다. 링크 된 작업 트리의 예를 들어, &lt;code&gt;.git&lt;/code&gt; 파일 포인트가 &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; 다음라는 파일 &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; 은 방지 할 수 있습니다 &lt;code&gt;test-next&lt;/code&gt; 가지 치기에서 다음 항목. 자세한 내용은 &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="46ac404b2baca4d3a659bb0594db0c41828389ed" translate="yes" xml:space="preserve">
          <source>To prevent these unnecessary merge conflicts, Git can be told to run a virtual check-out and check-in of all three stages of a file when resolving a three-way merge by setting the &lt;code&gt;merge.renormalize&lt;/code&gt; configuration variable. This prevents changes caused by check-in conversion from causing spurious merge conflicts when a converted file is merged with an unconverted file.</source>
          <target state="translated">이러한 불필요한 병합 충돌을 방지하기 위해, Git은 &lt;code&gt;merge.renormalize&lt;/code&gt; 구성 변수를 설정하여 3 방향 병합을 해결할 때 파일의 3 단계 모두에서 가상 체크 아웃 및 체크인을 실행하도록 지시 할 수 있습니다 . 이렇게하면 변환 된 파일이 변환되지 않은 파일과 병합 될 때 체크인 변환으로 인한 변경으로 인해 가짜 병합 충돌이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="91d260766aee213709a415223ac206b93100d7d5" translate="yes" xml:space="preserve">
          <source>To prune objects not used by your repository or another that borrows from your repository via its &lt;code&gt;.git/objects/info/alternates&lt;/code&gt;:</source>
          <target state="translated">저장소 또는 &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; 를 통해 저장소에서 빌린 다른 오브젝트에서 사용하지 않는 오브젝트를 제거하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f63f42b98c259e7fd0384dd68939f7fc302c5eb" translate="yes" xml:space="preserve">
          <source>To prune references as part of your normal workflow without needing to remember to run that, set &lt;code&gt;fetch.prune&lt;/code&gt; globally, or &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; per-remote in the config. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">참조를 실행하지 않아도 정상 워크 플로우의 일부로 참조를 제거하려면 구성에서 &lt;code&gt;fetch.prune&lt;/code&gt; 을 전체적으로 설정 하거나 &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; 를 원격으로 설정하십시오. &lt;a href=&quot;git-config&quot;&gt;git-config [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="68bfae2792009c9d944a67bd77b4854e1c8c4d3e" translate="yes" xml:space="preserve">
          <source>To put the loose objects into a pack, just run git repack:</source>
          <target state="translated">느슨한 객체를 팩에 넣으려면 git repack을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8344caf5b982f9b0d4dc99f7ff5aa708ff0b3592" translate="yes" xml:space="preserve">
          <source>To query the value for a given key, do</source>
          <target state="translated">주어진 키의 값을 쿼리하려면</target>
        </trans-unit>
        <trans-unit id="6d7c1598e59e901d58d9b961c14fa449c82ef069" translate="yes" xml:space="preserve">
          <source>To reapply a series of changes from a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; to a different base, and reset the &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt; of that branch to the result.</source>
          <target state="translated">&lt;a href=&quot;#def_branch&quot;&gt;분기&lt;/a&gt; 에서 다른베이스 로 일련의 변경 사항을 다시 적용하고 해당 분기 의 &lt;a href=&quot;#def_head&quot;&gt;헤드&lt;/a&gt; 를 결과로 재설정합니다 .</target>
        </trans-unit>
        <trans-unit id="25388a0bc929e9a0e4d2bb9d4d113e8444bb02a5" translate="yes" xml:space="preserve">
          <source>To remove a file from the index and from the working tree, use</source>
          <target state="translated">색인과 작업 트리에서 파일을 제거하려면</target>
        </trans-unit>
        <trans-unit id="c7850646e909d85f101794190a2e6f7a699e3e90" translate="yes" xml:space="preserve">
          <source>To remove commits authored by &quot;Darl McBribe&quot; from the history:</source>
          <target state="translated">히스토리에서 &quot;Darl McBribe&quot;가 작성한 커밋을 제거하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="65692943c43d72ea453917ea884fccf3994fb56e" translate="yes" xml:space="preserve">
          <source>To remove selection, prefix the input with &lt;code&gt;-&lt;/code&gt; like this:</source>
          <target state="translated">선택을 제거하려면, 입력과 앞에 &lt;code&gt;-&lt;/code&gt; 이 같은를 :</target>
        </trans-unit>
        <trans-unit id="9e91a512899aa79b93af123e6b1768a526248346" translate="yes" xml:space="preserve">
          <source>To repopulate the working directory with all files, use the &lt;code&gt;git sparse-checkout disable&lt;/code&gt; command.</source>
          <target state="translated">모든 파일로 작업 디렉토리를 다시 채우려면 &lt;code&gt;git sparse-checkout disable&lt;/code&gt; 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5c497720a7ab3ae3ef408305ef475289bc14a521" translate="yes" xml:space="preserve">
          <source>To reproduce the entire p4 history in Git, use the &lt;code&gt;@all&lt;/code&gt; modifier on the depot path:</source>
          <target state="translated">Git에서 전체 p4 히스토리를 재현하려면 저장소 경로 에서 &lt;code&gt;@all&lt;/code&gt; 수정자를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d4609928d728916d052df2a3b481b65890e4b16e" translate="yes" xml:space="preserve">
          <source>To require authentication for both reads and writes, use a Location directive around the repository, or one of its parent directories:</source>
          <target state="translated">읽기 및 쓰기 모두에 대한 인증을 요구하려면 저장소 또는 해당 상위 디렉토리 중 하나에 Location 지시문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="10ebfb5ceb771c952eff2c39be3b852f1f654421" translate="yes" xml:space="preserve">
          <source>To require authentication for both reads and writes:</source>
          <target state="translated">읽기와 쓰기 모두에 대한 인증이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="847928f545abee25f9f8e4e2cc396a049af86735" translate="yes" xml:space="preserve">
          <source>To restore a file in the index to match the version in &lt;code&gt;HEAD&lt;/code&gt; (this is the same as using &lt;a href=&quot;git-reset&quot;&gt;git-reset[1]&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 의 버전과 일치하도록 색인의 파일을 복원하려면 ( &lt;a href=&quot;git-reset&quot;&gt;git-reset [1]&lt;/a&gt; 사용과 동일 )</target>
        </trans-unit>
        <trans-unit id="21366b05c441f538e6886570018737e901640e49" translate="yes" xml:space="preserve">
          <source>To restore all files in the current directory</source>
          <target state="translated">현재 디렉토리의 모든 파일을 복원하려면</target>
        </trans-unit>
        <trans-unit id="0ab7e14988a23edeb341648ca7b63377b3dd49d2" translate="yes" xml:space="preserve">
          <source>To restrict rewriting to only part of the history, specify a revision range in addition to the new branch name. The new branch name will point to the top-most revision that a &lt;code&gt;git rev-list&lt;/code&gt; of this range will print.</source>
          <target state="translated">기록의 일부로 만 다시 쓰기를 제한하려면 새 분기 이름 외에 개정 범위를 지정하십시오. 새 분기 이름은 이 범위 의 &lt;code&gt;git rev-list&lt;/code&gt; 가 인쇄 할 최상위 개정을 가리 킵니다 .</target>
        </trans-unit>
        <trans-unit id="4d880d7fd779c619b85e62692eb083b5f59e932e" translate="yes" xml:space="preserve">
          <source>To rewrite commits E,F,G,H, use one of these:</source>
          <target state="translated">커밋 E, F, G, H를 다시 ​​쓰려면 다음 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="47b66273feb1f496168989ebee433bebb314fc85" translate="yes" xml:space="preserve">
          <source>To rewrite only commits D,E,F,G,H, but leave A, B and C alone, use:</source>
          <target state="translated">D, E, F, G, H 만 커밋하고 A, B 및 C는 그대로 두려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8c31d9c011b7c86062de888fb92cc01426b53584" translate="yes" xml:space="preserve">
          <source>To rewrite the repository to look as if &lt;code&gt;foodir/&lt;/code&gt; had been its project root, and discard all other history:</source>
          <target state="translated">&lt;code&gt;foodir/&lt;/code&gt; 가 프로젝트 루트 인 것처럼 보이도록 저장소를 다시 작성하고 다른 모든 히스토리를 삭제하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7c02b2b350476c8c24e25173b62f35a8ad0c0ae3" translate="yes" xml:space="preserve">
          <source>To see how submodule support works, create four example repositories that can be used later as a submodule:</source>
          <target state="translated">하위 모듈 지원 작동 방식을 보려면 나중에 하위 모듈로 사용할 수있는 네 가지 예제 리포지토리를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="700bc56e5656b835e5cd7fa2e5386957dfc66eac" translate="yes" xml:space="preserve">
          <source>To see the currently remaining suspects in &lt;code&gt;gitk&lt;/code&gt;, issue the following command during the bisection process (the subcommand &lt;code&gt;view&lt;/code&gt; can be used as an alternative to &lt;code&gt;visualize&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;gitk&lt;/code&gt; 에서 현재 남아있는 용의자를 보려면 이분법 프로세스 중에 다음 명령을 실행하십시오 (하위 명령 &lt;code&gt;view&lt;/code&gt; 는를 &lt;code&gt;visualize&lt;/code&gt; 하는 대안으로 사용할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="faa509deef7fcd4d518cc2cd2e577046b7eb747b" translate="yes" xml:space="preserve">
          <source>To see whether it has already been merged into the test or release branches, use:</source>
          <target state="translated">테스트 또는 릴리스 브랜치에 이미 병합되었는지 확인하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1e15ca1368deb202f467e491af7bfdb38f930af4" translate="yes" xml:space="preserve">
          <source>To serve gitweb at the same url, use a ScriptAliasMatch to only those URLs that &lt;code&gt;git http-backend&lt;/code&gt; can handle, and forward the rest to gitweb:</source>
          <target state="translated">동일한 URL에서 gitweb을 제공하려면 &lt;code&gt;git http-backend&lt;/code&gt; 가 처리 할 수 있는 URL에만 ScriptAliasMatch를 사용 하고 나머지는 gitweb에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="3b5c2b799f6b39d60aa882699fc88e3eb3a77175" translate="yes" xml:space="preserve">
          <source>To serve multiple repositories from different &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; in a single repository:</source>
          <target state="translated">단일 저장소 에서 다른 &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]의&lt;/a&gt; 여러 저장소를 제공하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="59fa97f902b7761eca14600ff37aff1758dec6bd" translate="yes" xml:space="preserve">
          <source>To set a commit (which typically is at the tip of another history) to be the parent of the current initial commit, in order to paste the other history behind the current history:</source>
          <target state="translated">다른 히스토리를 현재 히스토리 뒤에 붙여 넣기 위해 커미트 (일반적으로 다른 히스토리의 끝에 있음)를 현재 초기 커미트의 상위로 설정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d091c25539483b5c5b3db274eae656a5f768704a" translate="yes" xml:space="preserve">
          <source>To set the date used in future tag objects, set the environment variable GIT_COMMITTER_DATE (see the later discussion of possible values; the most common form is &quot;YYYY-MM-DD HH:MM&quot;).</source>
          <target state="translated">향후 태그 객체에 사용되는 날짜를 설정하려면 환경 변수 GIT_COMMITTER_DATE를 설정하십시오 (가능한 값에 대해서는 나중에 설명합니다. 가장 일반적인 형식은 &quot;YYYY-MM-DD HH : MM&quot;).</target>
        </trans-unit>
        <trans-unit id="0de4847876d8ab04ebb463613f39507d60c3b1a3" translate="yes" xml:space="preserve">
          <source>To set this up, first create your work tree by cloning Linus&amp;rsquo;s public tree:</source>
          <target state="translated">이를 설정하려면 먼저 Linus의 공용 트리를 복제하여 작업 트리를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="6fdb47a7575f286ad7a6b8b651d8470ef2c51c01" translate="yes" xml:space="preserve">
          <source>To set up &lt;code&gt;git daemon&lt;/code&gt; as a regular, non-inetd service that handles repositories for multiple virtual hosts based on their IP addresses, start the daemon like this:</source>
          <target state="translated">&lt;code&gt;git daemon&lt;/code&gt; 을 IP 주소를 기반으로 여러 가상 호스트의 리포지토리를 처리하는 비정규 일반 서비스로 설정하려면 다음 과 같이 데몬을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="cd4e85b93c0b5a71d973a240463742c429d6ce10" translate="yes" xml:space="preserve">
          <source>To set up &lt;code&gt;git daemon&lt;/code&gt; as an inetd service that handles any repository under the whitelisted set of directories, /pub/foo and /pub/bar, place an entry like the following into /etc/inetd all on one line:</source>
          <target state="translated">설정하려면 &lt;code&gt;git daemon&lt;/code&gt; 핸들 디렉토리 / 주점 / foo는의 허용 된 세트에서 모든 저장소 및 / 술집 / 바의 등 /에 다음과 같은 항목을 배치하는 것이 inetd를 서비스로 / 한 줄에 모든 inetd를</target>
        </trans-unit>
        <trans-unit id="d85d4c6ac447e3ea7881a95ee3354b641502c913" translate="yes" xml:space="preserve">
          <source>To set up &lt;code&gt;git daemon&lt;/code&gt; as an inetd service that handles repositories for different virtual hosts, &lt;code&gt;www.example.com&lt;/code&gt; and &lt;code&gt;www.example.org&lt;/code&gt;, place an entry like the following into &lt;code&gt;/etc/inetd&lt;/code&gt; all on one line:</source>
          <target state="translated">다른 가상 호스트 ( &lt;code&gt;www.example.com&lt;/code&gt; 및 &lt;code&gt;www.example.org&lt;/code&gt; )의 저장소를 처리하는 inetd 서비스로 &lt;code&gt;git daemon&lt;/code&gt; 을 설정하려면 &lt;code&gt;/etc/inetd&lt;/code&gt; 에 다음과 같은 항목을 모두 한 줄로 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="6d1dfa06a0b2e0253dac9a23d3e763ff2be4729c" translate="yes" xml:space="preserve">
          <source>To shelve changes instead of submitting, use &lt;code&gt;--shelve&lt;/code&gt; and &lt;code&gt;--update-shelve&lt;/code&gt;:</source>
          <target state="translated">제출하는 대신 변경 사항을 보류하려면 &lt;code&gt;--shelve&lt;/code&gt; 및 &lt;code&gt;--update-shelve&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b19251adc869dd31b98316a2df3ca3e146f58f68" translate="yes" xml:space="preserve">
          <source>To show all references called &quot;master&quot;, whether tags or heads or anything else, and regardless of how deep in the reference naming hierarchy they are, use:</source>
          <target state="translated">태그 또는 헤드 또는 기타 항목에 관계없이 &quot;마스터&quot;라는 모든 참조를 표시하고 참조 명명 계층 구조의 깊이에 관계없이 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="51ec81ccf2337a76aefa897308cd08d96e515614" translate="yes" xml:space="preserve">
          <source>To show only tags, or only proper branch heads, use &quot;--tags&quot; and/or &quot;--heads&quot; respectively (using both means that it shows tags and heads, but not other random references under the refs/ subdirectory).</source>
          <target state="translated">태그 또는 적절한 분기 헤드 만 표시하려면 &quot;--tags&quot;및 / 또는 &quot;--heads&quot;를 각각 사용하십시오 (두 태그를 모두 사용하면 태그 및 헤드가 표시되지만 refs / 하위 디렉토리 아래의 다른 임의 참조는 표시되지 않음).</target>
        </trans-unit>
        <trans-unit id="864f9f1ee17e37f4b3823291b8524eebd5879fc4" translate="yes" xml:space="preserve">
          <source>To show that as an example, let&amp;rsquo;s go back to the git-tutorial repository we used earlier, and create a branch in it. You do that by simply just saying that you want to check out a new branch:</source>
          <target state="translated">이를 예제로 보여주기 위해 앞에서 사용한 git-tutorial repository로 돌아가서 분기를 만듭니다. 새 지점을 확인하고 싶다고 말하면됩니다.</target>
        </trans-unit>
        <trans-unit id="acab411fa1b0a4e2f72e42b537e21a4bc08bf613" translate="yes" xml:space="preserve">
          <source>To simplify the discussion we will suppose that the untestable area is a simple string of commits and that it was created by a breakage introduced by one commit (let&amp;rsquo;s call it BBC for bisect breaking commit) and later fixed by another one (let&amp;rsquo;s call it BFC for bisect fixing commit).</source>
          <target state="translated">논의를 단순화하기 위해 우리는 테스트 할 수없는 영역이 단순한 커밋 문자열이고 한 커밋에 의해 도입 된 손상 (Brisct Break Commit을 위해 BBC라고 함)에서 나중에 다른 하나에 의해 수정되었다고 가정합니다 (BFC라고 함). 이등분 고정 커밋).</target>
        </trans-unit>
        <trans-unit id="975e3a9279c8287bca9f664bbcc61fee7baa93ca" translate="yes" xml:space="preserve">
          <source>To specify a branch other than the current one, use:</source>
          <target state="translated">현재 분기 이외의 분기를 지정하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b6b6e95c2c1acd4004bc280690d73f7c9df3e3b0" translate="yes" xml:space="preserve">
          <source>To specify a namespace, set the &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; environment variable to the namespace. For each ref namespace, Git stores the corresponding refs in a directory under &lt;code&gt;refs/namespaces/&lt;/code&gt;. For example, &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; will store refs under &lt;code&gt;refs/namespaces/foo/&lt;/code&gt;. You can also specify namespaces via the &lt;code&gt;--namespace&lt;/code&gt; option to &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;.</source>
          <target state="translated">네임 스페이스를 지정하려면 &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; 환경 변수를 네임 스페이스로 설정하십시오 . 각 참조 네임 스페이스에 대해 Git은 해당 참조를 &lt;code&gt;refs/namespaces/&lt;/code&gt; 아래의 디렉토리에 저장합니다 . 예를 들어 &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; 는 &lt;code&gt;refs/namespaces/foo/&lt;/code&gt; 아래에 ref 를 저장 합니다. &lt;code&gt;--namespace&lt;/code&gt; 옵션을 통해 &lt;a href=&quot;git&quot;&gt;git [1]에&lt;/a&gt; 네임 스페이스를 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d8e0463dddb070b083bcb1d31f0cd304bcae1a2" translate="yes" xml:space="preserve">
          <source>To specify a single commit or a range of commits, use:</source>
          <target state="translated">단일 커밋 또는 커밋 범위를 지정하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b6bdd73c5af990a9c308cb3582e6683a673000a9" translate="yes" xml:space="preserve">
          <source>To stop tracking a file that is currently tracked, use &lt;code&gt;git rm --cached&lt;/code&gt;.</source>
          <target state="translated">현재 추적되는 파일 추적을 중지하려면 &lt;code&gt;git rm --cached&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5aabd990937e7026d6c235ccca8da7a1bd54429f" translate="yes" xml:space="preserve">
          <source>To submit all changes that are in the current Git branch but not in the &lt;code&gt;p4/master&lt;/code&gt; branch, use:</source>
          <target state="translated">현재 Git 브랜치에 있지만 &lt;code&gt;p4/master&lt;/code&gt; 브랜치에는 없는 모든 변경 사항을 제출하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4d37523ff8334f7ae27e64b17d4088a430f024d8" translate="yes" xml:space="preserve">
          <source>To submit patches using GMail&amp;rsquo;s IMAP interface, first, edit your ~/.gitconfig to specify your account settings:</source>
          <target state="translated">GMail의 IMAP 인터페이스를 사용하여 패치를 제출하려면 먼저 ~ / .gitconfig를 편집하여 계정 설정을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="3829362b0206f78fb7e35755e5364f47036b822a" translate="yes" xml:space="preserve">
          <source>To support virtual hosting, an interpolated path template can be used to dynamically construct alternate paths. The template supports %H for the target hostname as supplied by the client but converted to all lowercase, %CH for the canonical hostname, %IP for the server&amp;rsquo;s IP address, %P for the port number, and %D for the absolute path of the named repository. After interpolation, the path is validated against the directory whitelist.</source>
          <target state="translated">가상 호스팅을 지원하기 위해 보간 경로 템플릿을 사용하여 대체 경로를 동적으로 구성 할 수 있습니다. 템플릿은 클라이언트가 제공 한 대상 호스트 이름에 대해 % H를 지원하지만 모든 소문자, 표준 호스트 이름에 대한 % CH, 서버의 IP 주소에 대한 % IP, 포트 번호에 대한 % P 및 절대 경로에 대한 % D로 변환됩니다. 명명 된 저장소 보간 후, 경로는 디렉토리 화이트리스트에 대해 검증됩니다.</target>
        </trans-unit>
        <trans-unit id="5c5bebcfb262219afa24ad57e1be9ff8017de145" translate="yes" xml:space="preserve">
          <source>To switch back to the previous branch before we switched to mytopic (i.e. &quot;master&quot; branch):</source>
          <target state="translated">mytopic (예 : &quot;마스터&quot;지점)으로 전환하기 전에 이전 지점으로 다시 전환하려면</target>
        </trans-unit>
        <trans-unit id="f604bfa9fc2a5e3a8b43aed4c26f0a58bfbd1e14" translate="yes" xml:space="preserve">
          <source>To tell Git that yes, you really do realize that certain files no longer exist, or that new files should be added, you should use the &lt;code&gt;--remove&lt;/code&gt; and &lt;code&gt;--add&lt;/code&gt; flags respectively.</source>
          <target state="translated">Git에게 특정 파일이 더 이상 존재하지 않거나 새로운 파일을 추가해야한다는 것을 실제로 인식하려면 &lt;code&gt;--remove&lt;/code&gt; 및 &lt;code&gt;--add&lt;/code&gt; 플래그를 각각 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f3c508cb95e621506ae6e931b2fdadcaba14a047" translate="yes" xml:space="preserve">
          <source>To test the interaction of several topics, merge them into a throw-away branch. You must never base any work on such a branch!</source>
          <target state="translated">여러 주제의 상호 작용을 테스트하려면 해당 주제를 폐기 지점으로 병합하십시오. 그러한 지점에 어떤 작업도하지 말아야합니다!</target>
        </trans-unit>
        <trans-unit id="ded44bb687bc8a448accbaa8cf09bc1b10b3ff71" translate="yes" xml:space="preserve">
          <source>To that end, it first finds pairs of commits from both commit ranges that correspond with each other. Two commits are said to correspond when the diff between their patches (i.e. the author information, the commit message and the commit diff) is reasonably small compared to the patches' size. See ``Algorithm`` below for details.</source>
          <target state="translated">이를 위해 먼저 서로 일치하는 두 커밋 범위에서 커밋 쌍을 찾습니다. 패치 사이의 차이 (즉, 작성자 정보, 커밋 메시지 및 커밋 차이)가 패치 크기에 비해 상당히 작을 때 두 개의 커밋이 해당한다고합니다. 자세한 내용은 아래의``알고리즘 ''을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="28b9a65cbb97d3af18835efd06d4d171278e0508" translate="yes" xml:space="preserve">
          <source>To throw away part of the development, i.e. to assign the &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt; to an earlier &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt;.</source>
          <target state="translated">개발의 일부를 버리는 것, 즉 &lt;a href=&quot;#def_head&quot;&gt;헤드&lt;/a&gt; 를 이전 &lt;a href=&quot;#def_revision&quot;&gt;개정판&lt;/a&gt; 에 할당 하는 것 .</target>
        </trans-unit>
        <trans-unit id="f2857b34f71a88c7afeb725363e4097e2e44ff45" translate="yes" xml:space="preserve">
          <source>To top it all off, even when users finally find working commands, they naturally want to share them. But they may be unaware that their repo didn&amp;rsquo;t have some special cases that someone else&amp;rsquo;s does. So, when someone else with a different repository runs the same commands, they get hit by the problems above. Or, the user just runs commands that really were vetted for special cases, but they run it on a different OS where it doesn&amp;rsquo;t work, as noted above.</source>
          <target state="translated">무엇보다도 사용자가 최종적으로 작업 명령을 찾더라도 자연스럽게 공유하기를 원합니다. 그러나 그들은 그들의 저장소에 다른 사람이하는 특별한 경우가 없다는 것을 알지 못할 수도 있습니다. 따라서 다른 리포지토리를 가진 다른 사람이 동일한 명령을 실행하면 위의 문제가 발생합니다. 또는 사용자는 특별한 경우에 실제로 심사 된 명령 만 실행하지만 위에서 언급 한대로 작동하지 않는 다른 OS에서 실행합니다.</target>
        </trans-unit>
        <trans-unit id="c4d2ca21938c992db0b3b75cacfc935366e6629e" translate="yes" xml:space="preserve">
          <source>To update and refresh only the files already checked out</source>
          <target state="translated">이미 체크 아웃 한 파일 만 업데이트하고 새로 고치려면</target>
        </trans-unit>
        <trans-unit id="a8c26a487a2f6627cb1ef2fcc7d8934daa7b62d0" translate="yes" xml:space="preserve">
          <source>To update and refresh only the files already checked out:</source>
          <target state="translated">이미 체크 아웃 한 파일 만 업데이트하고 새로 고치려면</target>
        </trans-unit>
        <trans-unit id="ec65c1043e980aa5b1f1a444793e6e405a4b07fd" translate="yes" xml:space="preserve">
          <source>To update the index with the contents of a new or modified file, use</source>
          <target state="translated">새 파일 또는 수정 된 파일의 내용으로 색인을 업데이트하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="693fe77a3dea0f3b3cf2c4a884d12237d7043db5" translate="yes" xml:space="preserve">
          <source>To update the resulting mine.git repository, you can fetch or pull after replacing the bundle stored at /home/me/tmp/file.bundle with incremental updates.</source>
          <target state="translated">결과로 생성 된 mine.git 저장소를 업데이트하려면 /home/me/tmp/file.bundle에 저장된 번들을 증분 업데이트로 교체 한 후 가져 오거나 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7804c7379482ba8df4ffa8604001ea71fae1937a" translate="yes" xml:space="preserve">
          <source>To use &quot;old&quot; and &quot;new&quot; instead of &quot;good&quot; and bad, you must run &lt;code&gt;git
bisect start&lt;/code&gt; without commits as argument and then run the following commands to add the commits:</source>
          <target state="translated">&quot;good&quot;과 bad 대신 &quot;old&quot;와 &quot;new&quot;를 사용하려면 커밋없이 &lt;code&gt;git bisect start&lt;/code&gt; 를 인수로 실행 한 후 다음 명령을 실행하여 커밋을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="288cf0a04f95ab8d9b3cedc9a80bcb75e1eb91a6" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;git send-email&lt;/code&gt; to send your patches through the GMail SMTP server, edit ~/.gitconfig to specify your account settings:</source>
          <target state="translated">&lt;code&gt;git send-email&lt;/code&gt; 을 사용 하여 GMail SMTP 서버를 통해 패치를 보내려면 ~ / .gitconfig를 편집하여 계정 설정을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="b24b5140a04c50c5ab1f6a8bf4b67a65e4b08446" translate="yes" xml:space="preserve">
          <source>To use a helper, you must first select one to use. Git currently includes the following helpers:</source>
          <target state="translated">도우미를 사용하려면 먼저 사용할 도우미를 선택해야합니다. 힘내는 현재 다음과 같은 도우미를 포함합니다 :</target>
        </trans-unit>
        <trans-unit id="36cbbd22949ca6f21f378ad7a2a2aecbfc17d31c" translate="yes" xml:space="preserve">
          <source>To use the tool, &lt;code&gt;imap.folder&lt;/code&gt; and either &lt;code&gt;imap.tunnel&lt;/code&gt; or &lt;code&gt;imap.host&lt;/code&gt; must be set to appropriate values.</source>
          <target state="translated">도구를 사용하려면 &lt;code&gt;imap.folder&lt;/code&gt; 와 &lt;code&gt;imap.tunnel&lt;/code&gt; 또는 &lt;code&gt;imap.host&lt;/code&gt; 를 적절한 값으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="00e4f18d69f51ffe1eea42af728cb3d7bb0059ec" translate="yes" xml:space="preserve">
          <source>To use the tool, imap.folder and either imap.tunnel or imap.host must be set to appropriate values.</source>
          <target state="translated">도구를 사용하려면 imap.folder 및 imap.tunnel 또는 imap.host가 적절한 값으로 설정되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8b51a494019812910be0a147154b59e9ef1b84fa" translate="yes" xml:space="preserve">
          <source>To use this mode effectively, you have to make sure &lt;code&gt;all&lt;/code&gt; the branches you would push out are ready to be pushed out before running &lt;code&gt;git push&lt;/code&gt;, as the whole point of this mode is to allow you to push all of the branches in one go. If you usually finish work on only one branch and push out the result, while other branches are unfinished, this mode is not for you. Also this mode is not suitable for pushing into a shared central repository, as other people may add new branches there, or update the tip of existing branches outside your control.</source>
          <target state="translated">이 모드를 효과적으로 사용하려면 &lt;code&gt;git push&lt;/code&gt; 를 실행하기 전에 푸시하려는 &lt;code&gt;all&lt;/code&gt; 분기를 푸시 할 준비가 되었는지 확인해야 합니다 . 이 모드의 핵심은 모든 분기를 한 번에 푸시 할 수 있기 때문입니다. 일반적으로 한 지점에서만 작업을 마치고 결과를 내보내는 반면 다른 지점은 완료되지 않은 경우이 모드는 적합하지 않습니다. 또한이 모드는 다른 사람이 새 분기를 추가하거나 기존 분기의 끝을 제어 할 수 없으므로 공유 중앙 저장소로 푸시하는 데 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0db2ead5af506998515a70d6693b9cc78c43968a" translate="yes" xml:space="preserve">
          <source>To verify that &lt;code&gt;master&lt;/code&gt; is indeed a superset of &lt;code&gt;maint&lt;/code&gt;, use git log:</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; 가 실제로 &lt;code&gt;maint&lt;/code&gt; 의 상위 집합인지 확인하려면 git log를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="25e07c07376edb7f994c3289d03610c1335d5288" translate="yes" xml:space="preserve">
          <source>Todo list</source>
          <target state="translated">할 일 목록</target>
        </trans-unit>
        <trans-unit id="feb6706843b17024c0f5d36ae4a2773f9f7a9d9e" translate="yes" xml:space="preserve">
          <source>Toggle the &quot;sparse&quot; algorithm to determine which objects to include in the pack, when combined with the &quot;--revs&quot; option. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. If this option is not included, it defaults to the value of &lt;code&gt;pack.useSparse&lt;/code&gt;, which is true unless otherwise specified.</source>
          <target state="translated">&quot;--revs&quot;옵션과 함께 사용하면 &quot;sparse&quot;알고리즘을 전환하여 팩에 포함 할 개체를 결정합니다. 이 알고리즘은 새 개체를 도입하는 경로에 나타나는 나무 만 걷습니다. 이것은 작은 변화를 보내기 위해 팩을 계산할 때 상당한 성능 이점을 가질 수 있습니다. 그러나 포함 된 커밋에 특정 유형의 직접 이름 변경이 포함 된 경우 추가 개체가 팩 파일에 추가 될 수 있습니다. 이 옵션이 포함되지 않은 경우 기본값은 &lt;code&gt;pack.useSparse&lt;/code&gt; 이며, 달리 지정하지 않는 한 true입니다.</target>
        </trans-unit>
        <trans-unit id="44e89f12173f1b11f3c33dfcf393dbeb53d74231" translate="yes" xml:space="preserve">
          <source>Toggle the pre-push hook (see &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;). The default is --verify, giving the hook a chance to prevent the push. With --no-verify, the hook is bypassed completely.</source>
          <target state="translated">프리 푸시 후크를 토글합니다 ( &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 참조 ). 기본값은 --verify이며 후크는 푸시를 방지 할 수 있습니다. --no-verify를 사용하면 후크가 완전히 바이 패스됩니다.</target>
        </trans-unit>
        <trans-unit id="e69b3ac557eee7192f98b057069c2f145301ef39" translate="yes" xml:space="preserve">
          <source>Topic branches</source>
          <target state="translated">토픽 브랜치</target>
        </trans-unit>
        <trans-unit id="99011a3381da15bff0042576b0bb55bb6ae9ffd0" translate="yes" xml:space="preserve">
          <source>TortoiseCVS</source>
          <target state="translated">TortoiseCVS</target>
        </trans-unit>
        <trans-unit id="9732ce69da01051c0a62cf40cfeb5063ebcf5c22" translate="yes" xml:space="preserve">
          <source>Trace the evolution of the line range given by &quot;&amp;lt;start&amp;gt;,&amp;lt;end&amp;gt;&quot; (or the function name regex &amp;lt;funcname&amp;gt;) within the &amp;lt;file&amp;gt;. You may not give any pathspec limiters. This is currently limited to a walk starting from a single revision, i.e., you may only give zero or one positive revision arguments, and &amp;lt;start&amp;gt; and &amp;lt;end&amp;gt; (or &amp;lt;funcname&amp;gt;) must exist in the starting revision. You can specify this option more than once. Implies &lt;code&gt;--patch&lt;/code&gt;. Patch output can be suppressed using &lt;code&gt;--no-patch&lt;/code&gt;, but other diff formats (namely &lt;code&gt;--raw&lt;/code&gt;, &lt;code&gt;--numstat&lt;/code&gt;, &lt;code&gt;--shortstat&lt;/code&gt;, &lt;code&gt;--dirstat&lt;/code&gt;, &lt;code&gt;--summary&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt;, &lt;code&gt;--name-status&lt;/code&gt;, &lt;code&gt;--check&lt;/code&gt;) are not currently implemented.</source>
          <target state="translated">&amp;lt;file&amp;gt; 내에서 &quot;&amp;lt;start&amp;gt;, &amp;lt;end&amp;gt;&quot;(또는 함수 이름 regex &amp;lt;funcname&amp;gt;)로 지정된 행 범위의 진화를 추적하십시오. 경로 스펙 리미터를 제공 할 수 없습니다. 현재는 단일 개정에서 시작하여 도보로 제한됩니다. 즉, 0 또는 하나의 긍정적 개정 인수 만 제공 할 수 있으며 &amp;lt;start&amp;gt; 및 &amp;lt;end&amp;gt; (또는 &amp;lt;funcname&amp;gt;)가 시작 개정에 있어야합니다. 이 옵션을 두 번 이상 지정할 수 있습니다. &lt;code&gt;--patch&lt;/code&gt; 를 의미 합니다. &lt;code&gt;--no-patch&lt;/code&gt; 를 사용하여 패치 출력을 억제 할 수 있지만 다른 diff 형식 (즉 &lt;code&gt;--raw&lt;/code&gt; , &lt;code&gt;--numstat&lt;/code&gt; , &lt;code&gt;--shortstat&lt;/code&gt; , &lt;code&gt;--dirstat&lt;/code&gt; , &lt;code&gt;--summary&lt;/code&gt; , &lt;code&gt;--name-only&lt;/code&gt; , &lt;code&gt;--name-status&lt;/code&gt; , &lt;code&gt;--check&lt;/code&gt; )은 현재 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="324f1031e6064bf946ba7ad7de400c92a706ee71" translate="yes" xml:space="preserve">
          <source>Trace2 api</source>
          <target state="translated">Trace2 API</target>
        </trans-unit>
        <trans-unit id="f39bab439a6977ac76a84295e79b079d44b7d908" translate="yes" xml:space="preserve">
          <source>Trace2 config settings are only read from the system and global config files; repository local and worktree config files and &lt;code&gt;-c&lt;/code&gt; command line arguments are not respected.</source>
          <target state="translated">Trace2 구성 설정은 시스템 및 전역 구성 파일에서만 읽습니다. 저장소 로컬 및 작업 트리 구성 파일과 &lt;code&gt;-c&lt;/code&gt; 명령 행 인수는 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34f4d5fb2d35b898a8c6180c70ae5079360dafe0" translate="yes" xml:space="preserve">
          <source>Trace2 defines the following set of Trace2 Targets. Format details are given in a later section.</source>
          <target state="translated">Trace2는 다음과 같은 Trace2 대상 집합을 정의합니다. 형식 세부 사항은 다음 섹션에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="9cffe01770c87380a0c500c2ba4c5fe9919c83ec" translate="yes" xml:space="preserve">
          <source>Trace2 instrumentation throughout the Git code base sends Trace2 messages to the enabled Trace2 Targets. Targets transform these messages content into purpose-specific formats and write events to their data streams. In this manner, the Trace2 API can drive many different types of analysis.</source>
          <target state="translated">Git 코드베이스 전체의 Trace2 계측은 Trace2 메시지를 활성화 된 Trace2 대상으로 보냅니다. 대상은 이러한 메시지 컨텐츠를 목적 별 형식으로 변환하고 이벤트를 데이터 스트림에 씁니다. 이러한 방식으로 Trace2 API는 다양한 유형의 분석을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78edf21cb8a1d6593bdb09f0d046c88dfeb5c5d1" translate="yes" xml:space="preserve">
          <source>Trace2 is controlled using &lt;code&gt;trace2.*&lt;/code&gt; config values in the system and global config files and &lt;code&gt;GIT_TRACE2*&lt;/code&gt; environment variables. Trace2 does not read from repo local or worktree config files or respect &lt;code&gt;-c&lt;/code&gt; command line config settings.</source>
          <target state="translated">Trace2는 시스템 및 전역 구성 파일의 &lt;code&gt;trace2.*&lt;/code&gt; 구성 값과 &lt;code&gt;GIT_TRACE2*&lt;/code&gt; 환경 변수를 사용하여 제어됩니다 . Trace2는 repo 로컬 또는 작업 트리 구성 파일에서 읽지 않거나 &lt;code&gt;-c&lt;/code&gt; 명령 줄 구성 설정을 준수하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="952dc6d60a810a50f48d84409a5ca3162f18abfc" translate="yes" xml:space="preserve">
          <source>Trace2 is controlled using &lt;code&gt;trace2.&lt;/code&gt; config values in the system and global config files and &lt;code&gt;GIT_TRACE2&lt;/code&gt; environment variables. Trace2 does not read from repo local or worktree config files or respect &lt;code&gt;-c&lt;/code&gt; command line config settings.</source>
          <target state="translated">Trace2는 &lt;code&gt;trace2.&lt;/code&gt; 사용하여 제어됩니다 . 시스템 및 전역 구성 파일의 구성 값과 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 환경 변수. Trace2는 repo 로컬 또는 워크 트리 구성 파일에서 읽지 않거나 &lt;code&gt;-c&lt;/code&gt; 명령 행 구성 설정을 존중하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="20f68aac372bbc56e3b5b3e96aea0079529bedb9" translate="yes" xml:space="preserve">
          <source>Trace2 regions are similar to the existing trace_performance_enter() and trace_performance_leave() routines, but are thread safe and maintain per-thread stacks of timers.</source>
          <target state="translated">Trace2 영역은 기존 trace_performance_enter () 및 trace_performance_leave () 루틴과 유사하지만 스레드 안전하고 스레드 별 타이머 스택을 유지 관리합니다.</target>
        </trans-unit>
        <trans-unit id="8bded73626b8544423d59c1c5a0c1bfb684cb12e" translate="yes" xml:space="preserve">
          <source>Trace2 target formats</source>
          <target state="translated">Trace2 대상 형식</target>
        </trans-unit>
        <trans-unit id="e4cb4d4e7e519744d1375eb303304baebc567ae9" translate="yes" xml:space="preserve">
          <source>Trace2 targets</source>
          <target state="translated">Trace2 대상</target>
        </trans-unit>
        <trans-unit id="a0cfb1f78b98054b282b0aab138d8ea25f2c82bd" translate="yes" xml:space="preserve">
          <source>Tracking and contributing to an entire Subversion-managed project (complete with a trunk, tags and branches):</source>
          <target state="translated">전체 Subversion 관리 프로젝트 추적 및 기여 (트렁크, 태그 및 브랜치로 완료) :</target>
        </trans-unit>
        <trans-unit id="847895b0cdb93b975e4c930f95d66dabeb1e64d2" translate="yes" xml:space="preserve">
          <source>Tracking and contributing to the trunk of a Subversion-managed project (ignoring tags and branches):</source>
          <target state="translated">Subversion 관리 프로젝트의 트렁크 추적 및 기여 (태그 및 분기 무시) :</target>
        </trans-unit>
        <trans-unit id="667c19a45142471c0c20cc605b683a6a3152afb1" translate="yes" xml:space="preserve">
          <source>Traditionally, tips of branches and tags (collectively known as &lt;code&gt;refs&lt;/code&gt;) were stored one file per ref in a (sub)directory under &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; directory. While many branch tips tend to be updated often, most tags and some branch tips are never updated. When a repository has hundreds or thousands of tags, this one-file-per-ref format both wastes storage and hurts performance.</source>
          <target state="translated">전통적으로 브랜치 및 태그 (통칭하여 &lt;code&gt;refs&lt;/code&gt; )의 팁은 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 디렉토리 아래의 (하위) 디렉토리에 ref 당 하나의 파일로 저장되었습니다 . 많은 분기 팁이 자주 업데이트되는 경향이 있지만 대부분의 태그 및 일부 분기 팁은 업데이트되지 않습니다. 리포지토리에 수백 또는 수천 개의 태그가있는 경우이 참조 당 하나의 파일 형식은 스토리지를 낭비하고 성능을 저하시킵니다.</target>
        </trans-unit>
        <trans-unit id="a5cf7db57e9cf074478d171148671cc677faf56a" translate="yes" xml:space="preserve">
          <source>Trailing spaces are ignored unless they are quoted with backslash (&quot;&lt;code&gt;\&lt;/code&gt;&quot;).</source>
          <target state="translated">후행 공백은 백 슬래시 ( &quot; &lt;code&gt;\&lt;/code&gt; &quot;) 로 인용하지 않으면 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="18baa50eee1aac68104e16bd4ad94c661cde3869" translate="yes" xml:space="preserve">
          <source>Transfer size: In its current form Git requires the whole working tree present. It does not allow partial trees to be transferred in fetch or clone. If the project you work on consists of multiple repositories tied together as submodules in a superproject, you can avoid fetching the working trees of the repositories you are not interested in.</source>
          <target state="translated">전송 크기 : 현재 형태로 Git에는 전체 작업 트리가 필요합니다. 부분 트리를 페치 또는 복제로 전송할 수 없습니다. 작업중인 프로젝트가 수퍼 프로젝트에서 하위 모듈로 묶여있는 여러 저장소로 구성된 경우 관심없는 저장소의 작업 트리를 가져 오는 것을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdf6a912dffd18ed6042052fce8610d96ce56a71" translate="yes" xml:space="preserve">
          <source>Transform stdin by substituting all the 40-character SHA-1 hexes (say $hex) with &quot;$hex ($rev_name)&quot;. When used with --name-only, substitute with &quot;$rev_name&quot;, omitting $hex altogether. Intended for the scripter&amp;rsquo;s use.</source>
          <target state="translated">모든 40 자 SHA-1 헥스 (예 : $ hex)를 &quot;$ hex ($ rev_name)&quot;로 대체하여 stdin을 변환하십시오. --name-only와 함께 사용하는 경우 $ hex를 생략하고 &quot;$ rev_name&quot;으로 대체하십시오. 스크립터의 사용을 목적으로합니다.</target>
        </trans-unit>
        <trans-unit id="fc873c381aea0c960eb3ebd47773defb66d7e124" translate="yes" xml:space="preserve">
          <source>Transmit &amp;lt;string&amp;gt; as a push option. As the push option must not contain LF or NUL characters, the string is not encoded.</source>
          <target state="translated">&amp;lt;string&amp;gt;을 푸시 옵션으로 전송하십시오. push 옵션은 LF 또는 NUL 문자를 포함하지 않아야하므로 문자열이 인코딩되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32bd61986aca00f68612950bbcdb4915d3d0e846" translate="yes" xml:space="preserve">
          <source>Transmit the given string to the server when communicating using protocol version 2. The given string must not contain a NUL or LF character. The server&amp;rsquo;s handling of server options, including unknown ones, is server-specific. When multiple &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; are given, they are all sent to the other side in the order listed on the command line.</source>
          <target state="translated">프로토콜 버전 2를 사용하여 통신 할 때 지정된 문자열을 서버로 전송하십시오. 주어진 문자열에는 NUL 또는 LF 문자가 포함되어서는 안됩니다. 알 수없는 옵션을 포함하여 서버의 서버 옵션 처리는 서버마다 다릅니다. 여러 개의 &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; 이 제공되면 모두 명령 줄에 나열된 순서대로 다른쪽으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="39635a03df29b9789e505a1038590e24ea96c9e9" translate="yes" xml:space="preserve">
          <source>Transmit the given string to the server when communicating using protocol version 2. The given string must not contain a NUL or LF character. When multiple &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; are given, they are all sent to the other side in the order listed on the command line.</source>
          <target state="translated">프로토콜 버전 2를 사용하여 통신 할 때 지정된 문자열을 서버로 전송하십시오. 주어진 문자열에는 NUL 또는 LF 문자가 포함되어서는 안됩니다. 여러 개의 &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; 이 제공되면 모두 명령 줄에 나열된 순서대로 다른쪽으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="2995fbcc2c84443582483713456b482a39b63e37" translate="yes" xml:space="preserve">
          <source>Transmit the given string to the server, which passes them to the pre-receive as well as the post-receive hook. The given string must not contain a NUL or LF character. When multiple &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; are given, they are all sent to the other side in the order listed on the command line. When no &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; is given from the command line, the values of configuration variable &lt;code&gt;push.pushOption&lt;/code&gt; are used instead.</source>
          <target state="translated">주어진 문자열을 서버로 전송하여 수신 후 후크뿐만 아니라 수신 후 후크로 전달합니다. 주어진 문자열은 NUL 또는 LF 문자를 포함해서는 안됩니다. 여러 개의 &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; 이 제공되면 모두 명령 행에 나열된 순서대로 다른쪽으로 전송됩니다. 어떠한 경우 &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; 커맨드 라인에서 제공되지 않는 구성 변수의 값 &lt;code&gt;push.pushOption&lt;/code&gt; 가 대신 사용된다.</target>
        </trans-unit>
        <trans-unit id="9960fbc3363c91bebbbc4dae3127f4935a1a22d6" translate="yes" xml:space="preserve">
          <source>Treat all files as text.</source>
          <target state="translated">모든 파일을 텍스트로 취급하십시오.</target>
        </trans-unit>
        <trans-unit id="a08e9c61e543dccc4a24afe7a10c95737cbb1ca7" translate="yes" xml:space="preserve">
          <source>Treat pathspecs literally (i.e. no globbing, no pathspec magic). This is equivalent to setting the &lt;code&gt;GIT_LITERAL_PATHSPECS&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">경로 스펙을 문자 그대로 처리하십시오 (예 : 글 로빙, 경로 스펙 마법 없음). 이것은 &lt;code&gt;GIT_LITERAL_PATHSPECS&lt;/code&gt; 환경 변수를 &lt;code&gt;1&lt;/code&gt; 로 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8024445062b4bb90b2e84a4da6e0bb207f37b5f4" translate="yes" xml:space="preserve">
          <source>Treat the &amp;lt;string&amp;gt; given to &lt;code&gt;-S&lt;/code&gt; as an extended POSIX regular expression to match.</source>
          <target state="translated">&lt;code&gt;-S&lt;/code&gt; 에 제공된 &amp;lt;string&amp;gt;을 확장 POSIX 정규식으로 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="72315ec1092243bb561e5b4697869abb3601099e" translate="yes" xml:space="preserve">
          <source>Treat the repository as a bare repository. If GIT_DIR environment is not set, it is set to the current working directory.</source>
          <target state="translated">저장소를 Bare 저장소로 취급하십시오. GIT_DIR 환경이 설정되지 않은 경우 현재 작업 디렉토리로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1dad3a3b77cbf00bf58d87ee853af6d3cddb344a" translate="yes" xml:space="preserve">
          <source>Treat the revision argument as a &amp;lt;revision range&amp;gt;, even if it is just a single commit (that would normally be treated as a &amp;lt;since&amp;gt;). Note that root commits included in the specified range are always formatted as creation patches, independently of this flag.</source>
          <target state="translated">개정 인수는 단일 커밋 일지라도 (보통 &amp;lt;since&amp;gt;로 취급 될지라도) &amp;lt;revision range&amp;gt;로 취급하십시오. 지정된 범위에 포함 된 루트 커밋은이 플래그와 관계없이 항상 생성 패치로 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="aa88eae97d6ad1936bc41000081122649aee8d74" translate="yes" xml:space="preserve">
          <source>Treats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge. Whitespace changes mixed with other changes to a line are not ignored. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;-b&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, &lt;code&gt;--ignore-space-at-eol&lt;/code&gt;, and &lt;code&gt;--ignore-cr-at-eol&lt;/code&gt;.</source>
          <target state="translated">3 방향 병합을 위해 표시된 유형의 공백 변경이있는 행을 변경되지 않은 것으로 취급합니다. 행에 대한 다른 변경 사항과 혼합 된 공백 변경 사항은 무시되지 않습니다. 참고 &lt;a href=&quot;git-diff&quot;&gt;자식 DIFF-[1] &lt;/a&gt; &lt;code&gt;-b&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;--ignore-space-at-eol&lt;/code&gt; 및 &lt;code&gt;--ignore-cr-at-eol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ddd0e484558c1f8e50a8fe3c2dc7499225a9297" translate="yes" xml:space="preserve">
          <source>Tree Object</source>
          <target state="translated">트리 객체</target>
        </trans-unit>
        <trans-unit id="bce93b7f9d4c3064a3f582b574710500d7e5efb5" translate="yes" xml:space="preserve">
          <source>Tree and blob objects outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; will be treated the same way as if they were inside &lt;code&gt;refs/tags/*&lt;/code&gt;, any update of them will be rejected.</source>
          <target state="translated">&lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 외부의 Tree 및 blob 객체 는 &lt;code&gt;refs/tags/*&lt;/code&gt; 내부와 동일한 방식으로 처리되며 모든 업데이트는 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="faed43d5018a65bdda1021ea817b81efdd882a1f" translate="yes" xml:space="preserve">
          <source>Tree objects as well as tag objects not pointing at commits, cannot be described. When describing blobs, the lightweight tags pointing at blobs are ignored, but the blob is still described as &amp;lt;committ-ish&amp;gt;:&amp;lt;path&amp;gt; despite the lightweight tag being favorable.</source>
          <target state="translated">커밋을 가리 키지 않는 태그 객체뿐만 아니라 트리 객체도 설명 할 수 없습니다. 블롭을 기술 할 때, 블롭을 가리키는 경량 태그는 무시되지만, 경량 태그가 유리하지만 블롭은 여전히 ​​&amp;lt;committ-ish&amp;gt; : &amp;lt;path&amp;gt;로 기술된다.</target>
        </trans-unit>
        <trans-unit id="d94a666a1561928de12071aa36f46464acd70f54" translate="yes" xml:space="preserve">
          <source>Tree to checkout from (when paths are given). If not specified, the index will be used.</source>
          <target state="translated">체크 아웃 할 트리 (경로가 제공 될 때). 지정하지 않으면 인덱스가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fef8232d1c67b8b3403ba454c8ae3c965dc5fb72" translate="yes" xml:space="preserve">
          <source>Trees (aka directories) use just 12 bytes of memory on top of the memory required for their entries (see &amp;ldquo;per active file&amp;rdquo; below). The cost of a tree is virtually 0, as its overhead amortizes out over the individual file entries.</source>
          <target state="translated">트리 (일명 디렉토리)는 항목에 필요한 메모리 위에 12 바이트의 메모리 만 사용합니다 (아래의 &quot;활성 파일 당&quot;참조). 오버 헤드가 개별 파일 항목을 넘어 서기 때문에 트리의 비용은 거의 0입니다.</target>
        </trans-unit>
        <trans-unit id="2bb80d7d00c0395ecaf93c5dc9cd657c191b576d" translate="yes" xml:space="preserve">
          <source>Tries to reinstate not only the working tree&amp;rsquo;s changes, but also the index&amp;rsquo;s ones. However, this can fail, when you have conflicts (which are stored in the index, where you therefore can no longer apply the changes as they were originally).</source>
          <target state="translated">작업 트리의 변경 사항뿐만 아니라 인덱스의 변경 사항도 복원하려고합니다. 그러나 충돌이 발생하면 실패 할 수 있습니다 (인덱스에 저장되어 더 이상 변경 사항을 원래 그대로 적용 할 수 없음).</target>
        </trans-unit>
        <trans-unit id="8797468d6463e4f71332170d9f50ca7fd321cc3a" translate="yes" xml:space="preserve">
          <source>Trivial merges are done by &lt;code&gt;git read-tree&lt;/code&gt; itself. Only conflicting paths will be in unmerged state when &lt;code&gt;git read-tree&lt;/code&gt; returns.</source>
          <target state="translated">사소한 병합은 &lt;code&gt;git read-tree&lt;/code&gt; 자체에 의해 수행됩니다 . &lt;code&gt;git read-tree&lt;/code&gt; 가 반환 되면 충돌하는 경로 만 병합되지 않은 상태가됩니다 .</target>
        </trans-unit>
        <trans-unit id="c14d8e783a9f521d30b73eb971eac8f82acc62a0" translate="yes" xml:space="preserve">
          <source>True merge</source>
          <target state="translated">진정한 병합</target>
        </trans-unit>
        <trans-unit id="33a579ffc0dccbff15be01734ea4138ea4e7635c" translate="yes" xml:space="preserve">
          <source>Trust</source>
          <target state="translated">Trust</target>
        </trans-unit>
        <trans-unit id="df8a0e781552ee165e12d7086194c5f37262dc36" translate="yes" xml:space="preserve">
          <source>Try to speed up the traversal using the pack bitmap index (if one is available). Note that when traversing with &lt;code&gt;--objects&lt;/code&gt;, trees and blobs will not have their associated path printed.</source>
          <target state="translated">팩 비트 맵 인덱스 (사용 가능한 경우)를 사용하여 순회 속도를 높이십시오. &lt;code&gt;--objects&lt;/code&gt; 로 순회 할 때 나무와 얼룩에는 연관된 경로가 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db494399fc91d335ea933090c261cf51f7615da6" translate="yes" xml:space="preserve">
          <source>Try to update from the upstream resulted in a lot of conflicts; you were not ready to spend a lot of time merging right now, so you decide to do that later.</source>
          <target state="translated">업스트림에서 업데이트하려고하면 많은 충돌이 발생했습니다. 지금 병합하는 데 많은 시간을 할애 할 준비가되지 않았으므로 나중에 그렇게하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="3a12d2b4901990f4e580a360ff850809fe3f67b9" translate="yes" xml:space="preserve">
          <source>Turn off any previous &lt;code&gt;--filter=&lt;/code&gt; argument.</source>
          <target state="translated">이전 &lt;code&gt;--filter=&lt;/code&gt; 인수를 끄십시오 .</target>
        </trans-unit>
        <trans-unit id="34771065d121fc03fac8d38d540e254893826329" translate="yes" xml:space="preserve">
          <source>Turn off branch colors, even when the configuration file gives the default to color output. Same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">구성 파일이 기본값으로 컬러 출력을 제공하더라도 분기 컬러를 끕니다. &lt;code&gt;--color=never&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="6d9cbb32ce6c68e264cdb30b91e954cf183958d3" translate="yes" xml:space="preserve">
          <source>Turn off colored diff. It is the same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">컬러 차이를 끄십시오. &lt;code&gt;--color=never&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3d9b2354f095eeb41acddbf4f3d69d4ac5775813" translate="yes" xml:space="preserve">
          <source>Turn off colored diff. This can be used to override configuration settings. It is the same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">컬러 차이를 끄십시오. 구성 설정을 재정의하는 데 사용할 수 있습니다. &lt;code&gt;--color=never&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8ad464ef4a6c59cdcb2319e829113b9b9a0202fe" translate="yes" xml:space="preserve">
          <source>Turn off colored output, even when the configuration file gives the default to color output. Same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">구성 파일이 기본값을 컬러 출력으로 설정하더라도 컬러 출력을 끕니다. &lt;code&gt;--color=never&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="a3a997309d5fb6a6ca30f0f6201f278a284d8e1e" translate="yes" xml:space="preserve">
          <source>Turn off match highlighting, even when the configuration file gives the default to color output. Same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">구성 파일이 기본값으로 컬러 출력을 제공하더라도 일치 강조 표시를 끕니다. &lt;code&gt;--color=never&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="d4fab0f230de92fdcff08739247b39013a4dcf91" translate="yes" xml:space="preserve">
          <source>Turn off move detection. This can be used to override configuration settings. It is the same as &lt;code&gt;--color-moved=no&lt;/code&gt;.</source>
          <target state="translated">움직임 감지를 끕니다. 구성 설정을 재정의하는 데 사용할 수 있습니다. 그것과 동일 &lt;code&gt;--color-moved=no&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0eb0b106db412297afc722cb22850ad8fd89466" translate="yes" xml:space="preserve">
          <source>Turn off rename detection, even when the configuration file gives the default to do so.</source>
          <target state="translated">구성 파일이 기본값을 제공하더라도 이름 바꾸기 감지 기능을 끄십시오.</target>
        </trans-unit>
        <trans-unit id="4e867193eda90e02a99d5e3b2d3aff016424ee32" translate="yes" xml:space="preserve">
          <source>Turn off rename detection. This overrides the &lt;code&gt;merge.renames&lt;/code&gt; configuration variable. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--no-renames&lt;/code&gt;.</source>
          <target state="translated">이름 변경 감지 기능을 해제하십시오. 이는 &lt;code&gt;merge.renames&lt;/code&gt; 구성 변수를 대체합니다 . &lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--no-renames&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29eb4a9a74bb1156273caaa264fc85825c0572ef" translate="yes" xml:space="preserve">
          <source>Turn on rename detection, optionally setting the similarity threshold. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--find-renames&lt;/code&gt;.</source>
          <target state="translated">이름 변경 감지를 켜고 선택적으로 유사성 임계 값을 설정하십시오. &lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--find-renames&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a279dbfc86c680add56c7a5993ef6023dec20637" translate="yes" xml:space="preserve">
          <source>Turn on rename detection, optionally setting the similarity threshold. This is the default. This overrides the &lt;code&gt;merge.renames&lt;/code&gt; configuration variable. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--find-renames&lt;/code&gt;.</source>
          <target state="translated">이름 변경 감지를 켜고 선택적으로 유사성 임계 값을 설정하십시오. 이것이 기본값입니다. 이는 &lt;code&gt;merge.renames&lt;/code&gt; 구성 변수를 대체합니다 . &lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--find-renames&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9d077a66918e3017c929a4d5ef75e05f491a825" translate="yes" xml:space="preserve">
          <source>Turn on/off rename detection regardless of user configuration. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--no-renames&lt;/code&gt;.</source>
          <target state="translated">사용자 구성에 관계없이 이름 바꾸기 감지를 켜거나 끕니다. &lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--no-renames&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff597cb2e8f500da1bb43f369ea55f0017801fbc" translate="yes" xml:space="preserve">
          <source>Turn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal.</source>
          <target state="translated">진행 상황을 명시 적으로 켜거나 끕니다. 어느 것도 지정하지 않으면 표준 오류가 터미널에 연결된 경우 진행률이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b63e204e5b5bb236923126ba202fed353f8079ec" translate="yes" xml:space="preserve">
          <source>Turn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal. Note that not all merge strategies may support progress reporting.</source>
          <target state="translated">진행 상황을 명시 적으로 켜거나 끕니다. 어느 것도 지정하지 않으면 표준 오류가 터미널에 연결된 경우 진행률이 표시됩니다. 모든 병합 전략이 진행률보고를 지원하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae22b8d4ecb731b706e41a653df929373ee8e8e0" translate="yes" xml:space="preserve">
          <source>Turns off any previous &lt;code&gt;--filter=&lt;/code&gt; argument.</source>
          <target state="translated">이전 &lt;code&gt;--filter=&lt;/code&gt; 인수를 끕니다 .</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="954e9a2594b4d5687b25c9c1a8357bca3253b18f" translate="yes" xml:space="preserve">
          <source>Tweaking diff output</source>
          <target state="translated">diff 출력 조정</target>
        </trans-unit>
        <trans-unit id="aef2d842e6b781b12f96bc62f4ab607c12e12218" translate="yes" xml:space="preserve">
          <source>Two Tree Merge</source>
          <target state="translated">두 트리 병합</target>
        </trans-unit>
        <trans-unit id="6bda5442e87e811366b94ce6966009ecac6ac5dc" translate="yes" xml:space="preserve">
          <source>Two consecutive asterisks (&quot;&lt;code&gt;**&lt;/code&gt;&quot;) in patterns matched against full pathname may have special meaning:</source>
          <target state="translated">전체 경로 이름과 일치하는 패턴에서 두 개의 연속 별표 ( &quot; &lt;code&gt;**&lt;/code&gt; &quot;)는 특별한 의미를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e187ca5222f2f1c9a298321896225faf75c5697a" translate="yes" xml:space="preserve">
          <source>Two consecutive asterisks (&amp;ldquo;**&amp;rdquo;) in patterns matched against full pathname may have special meaning:</source>
          <target state="translated">전체 경로 이름과 일치하는 패턴에서 두 개의 연속 별표 (&amp;ldquo;**&amp;rdquo;)는 특별한 의미를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fce699584c34eaef39ec9c341ad51961e194a419" translate="yes" xml:space="preserve">
          <source>Two special values are supported: &lt;code&gt;off&lt;/code&gt; will simply close the corresponding standard handle, and if &lt;code&gt;GIT_REDIRECT_STDERR&lt;/code&gt; is &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;, standard error will be redirected to the same handle as standard output.</source>
          <target state="translated">두 가지 특수 값이 지원됩니다. &lt;code&gt;off&lt;/code&gt; 는 해당 표준 핸들을 닫고 &lt;code&gt;GIT_REDIRECT_STDERR&lt;/code&gt; 이 &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt; 이면 표준 오류는 표준 출력과 동일한 핸들로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="34a739d621f3038babff4f0f681d077135e77a75" translate="yes" xml:space="preserve">
          <source>Two things are interesting here:</source>
          <target state="translated">두 가지 흥미로운 점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ced48512ad4d3cb13ca20b7cb1f2f8e4abd0bc9d" translate="yes" xml:space="preserve">
          <source>Tying it all together</source>
          <target state="translated">모두 함께 묶어</target>
        </trans-unit>
        <trans-unit id="3a87a5a93967e0c0facb5bdbedab0a6936494920" translate="yes" xml:space="preserve">
          <source>Type 5 is reserved for future expansion. Type 0 is invalid.</source>
          <target state="translated">유형 5는 향후 확장을 위해 예약되어 있습니다. 유형 0이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8e8d3184972cec12ef3bd94d7eec7947cbe4b53" translate="yes" xml:space="preserve">
          <source>Typical gitweb config files will only change starting (default) time zone, and leave other elements at their default values:</source>
          <target state="translated">일반적인 gitweb 설정 파일은 시작 (기본) 시간대 만 변경하고 다른 요소는 기본값으로 둡니다.</target>
        </trans-unit>
        <trans-unit id="3aa25a3911a2da2f000729dbc451ee040fee4a66" translate="yes" xml:space="preserve">
          <source>Typical usage is something like:</source>
          <target state="translated">일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db1f5b1028dc570d4bb8caccd45a45601a38210c" translate="yes" xml:space="preserve">
          <source>Typical use of git credential</source>
          <target state="translated">git 자격 증명의 일반적인 사용</target>
        </trans-unit>
        <trans-unit id="d63a8a509d39725ec5fc85189ba54ffbab2dd0bb" translate="yes" xml:space="preserve">
          <source>Typically it will be placed in a MUA&amp;rsquo;s drafts folder, edited to add timely commentary that should not go in the changelog after the three dashes, and then sent as a message whose body, in our example, starts with &quot;arch/arm config files were&amp;hellip;​&quot;. On the receiving end, readers can save interesting patches in a UNIX mailbox and apply them with &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;.</source>
          <target state="translated">일반적으로 MUA의 임시 보관함 폴더에 배치되고 세 개의 대시 후에 변경 로그에 포함되지 않아야하는 적절한 주석을 추가하도록 편집 된 다음 본문에서 &quot;arch / arm 구성 파일은 다음과 같이 시작됩니다. &amp;hellip; &quot;. 수신 측에서 독자는 흥미로운 패치를 UNIX 메일함에 저장하고 &lt;a href=&quot;git-am&quot;&gt;git-am [1]으로&lt;/a&gt; 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b51965ce078cc4b0d9ecb0a1b113a383a8700dc" translate="yes" xml:space="preserve">
          <source>Typically such a variable may look like this:</source>
          <target state="translated">일반적으로 이러한 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f47be9cc1e7fcec80fcc7e52dcbd486a27d2ee2" translate="yes" xml:space="preserve">
          <source>Typically this is run with a script calling Git&amp;rsquo;s imitation of the &lt;code&gt;merge&lt;/code&gt; command from the RCS package.</source>
          <target state="translated">일반적으로 이것은 RCS 패키지에서 &lt;code&gt;merge&lt;/code&gt; 명령 에 대한 Git의 모방을 호출하는 스크립트로 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="e4333d902cedfd0d4739277fdec621b3f9f09422" translate="yes" xml:space="preserve">
          <source>Typically this matches the real type of &amp;lt;object&amp;gt; but asking for a type that can trivially be dereferenced from the given &amp;lt;object&amp;gt; is also permitted. An example is to ask for a &quot;tree&quot; with &amp;lt;object&amp;gt; being a commit object that contains it, or to ask for a &quot;blob&quot; with &amp;lt;object&amp;gt; being a tag object that points at it.</source>
          <target state="translated">일반적으로 이것은 &amp;lt;object&amp;gt;의 실제 유형과 일치하지만 주어진 &amp;lt;object&amp;gt;에서 사소하게 역 참조 될 수있는 유형을 요구하는 것도 허용됩니다. 예를 들어 &amp;lt;object&amp;gt;가 포함 된 커밋 객체 인 &quot;tree&quot;를 요청하거나 &amp;lt;object&amp;gt;가이를 가리키는 태그 객체 인 &quot;blob&quot;를 요청하는 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b016c5601edd059fd8dc12bb8d8426b6525fff2" translate="yes" xml:space="preserve">
          <source>Typically you would first remove all tracked files from the working tree using this command:</source>
          <target state="translated">일반적으로 다음 명령을 사용하여 작업 트리에서 추적 된 모든 파일을 먼저 제거합니다.</target>
        </trans-unit>
        <trans-unit id="3a2ee6ee14f11a86e1818d26c21e9493d38718f1" translate="yes" xml:space="preserve">
          <source>Typically, parallel recursive and multi-remote fetches will be faster. By default fetches are performed sequentially, not in parallel.</source>
          <target state="translated">일반적으로 병렬 재귀 및 다중 원격 반입이 더 빠릅니다. 기본적으로 페치는 병렬이 아닌 순차적으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="94e92e77c127b9c8a314ec2c48c4916e008c6404" translate="yes" xml:space="preserve">
          <source>Typically, this is invoked as &lt;code&gt;git read-tree -m $H $M&lt;/code&gt;, where $H is the head commit of the current repository, and $M is the head of a foreign tree, which is simply ahead of $H (i.e. we are in a fast-forward situation).</source>
          <target state="translated">일반적으로 이것은 &lt;code&gt;git read-tree -m $H $M&lt;/code&gt; 으로 호출됩니다 . 여기서 $ H는 현재 저장소의 헤드 커밋이고 $ M은 외부 트리의 헤드입니다. 빠른 상황에 처해 있습니다).</target>
        </trans-unit>
        <trans-unit id="0ada5827188094ef6e82c28e45e078ca96f54ca4" translate="yes" xml:space="preserve">
          <source>U: file is unmerged (you must complete the merge before it can be committed)</source>
          <target state="translated">U : 파일이 병합 해제되었습니다 (커밋하기 전에 병합을 완료해야합니다)</target>
        </trans-unit>
        <trans-unit id="1a7a0d0dd35212ae4c8c4c873315c6e7e9351f3b" translate="yes" xml:space="preserve">
          <source>URI and label (title) for the Git logo link (or your site logo, if you chose to use different logo image). By default, these both refer to Git homepage, &lt;a href=&quot;https://git-scm.com&quot;&gt;https://git-scm.com&lt;/a&gt;; in the past, they pointed to Git documentation at &lt;a href=&quot;https://www.kernel.org&quot;&gt;https://www.kernel.org&lt;/a&gt;.</source>
          <target state="translated">Git 로고 링크 (또는 다른 로고 이미지를 사용하기로 선택한 경우 사이트 로고)의 URI 및 레이블 (제목). 기본적으로 이들은 둘 다 Git 홈페이지 &lt;a href=&quot;https://git-scm.com&quot;&gt;https://git-scm.com을 참조합니다&lt;/a&gt; . 과거에는 &lt;a href=&quot;https://www.kernel.org&quot;&gt;https://www.kernel.org의&lt;/a&gt; Git 문서를 가리 켰습니다 .</target>
        </trans-unit>
        <trans-unit id="8561702ffd22bbb5ccd1a81c9c8d8cc77f16fa7e" translate="yes" xml:space="preserve">
          <source>Un-sets the previously set type specifier (if one was previously set). This option requests that &lt;code&gt;git config&lt;/code&gt; not canonicalize the retrieved variable. &lt;code&gt;--no-type&lt;/code&gt; has no effect without &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; or &lt;code&gt;--&amp;lt;type&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이전에 설정 한 유형 지정자를 설정 해제합니다 (이전에 설정 한 경우). 이 옵션은 &lt;code&gt;git config&lt;/code&gt; 가 검색된 변수를 정규화 할 수 없도록 요청 합니다. &lt;code&gt;--no-type&lt;/code&gt; 은 &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;--&amp;lt;type&amp;gt;&lt;/code&gt; 없이는 효과가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="911839695653d988872929c95814b8902e300040" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;--pretty=oneline&lt;/code&gt;, the commit message is prefixed with this information on the same line. This option cannot be combined with &lt;code&gt;--reverse&lt;/code&gt;. See also &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt;.</source>
          <target state="translated">아래 &lt;code&gt;--pretty=oneline&lt;/code&gt; 의 메시지가 같은 줄에이 정보로 시작됩니다 커밋합니다. 이 옵션은 &lt;code&gt;--reverse&lt;/code&gt; 와 함께 사용할 수 없습니다 . &lt;a href=&quot;git-reflog&quot;&gt;git-reflog [1]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="64ba59969ba5a36d002d9a189101c624fcf7d3cc" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;--pretty=reference&lt;/code&gt;, this information will not be shown at all.</source>
          <target state="translated">아래 &lt;code&gt;--pretty=reference&lt;/code&gt; 이 정보는 전혀 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c73a6e04cc57ad10ee4ae7284f559a5ae2a53d36" translate="yes" xml:space="preserve">
          <source>Under certain circumstances, some versions of &lt;code&gt;diff&lt;/code&gt; do not correctly detect a missing new-line at the end of the file. As a result, patches created by such &lt;code&gt;diff&lt;/code&gt; programs do not record incomplete lines correctly. This option adds support for applying such patches by working around this bug.</source>
          <target state="translated">특정 상황에서 일부 버전의 &lt;code&gt;diff&lt;/code&gt; 는 파일 끝에서 누락 된 줄 바꿈을 올바르게 감지하지 못합니다. 결과적으로 이러한 &lt;code&gt;diff&lt;/code&gt; 프로그램으로 작성된 패치는 불완전한 행을 올바르게 기록하지 않습니다. 이 옵션은이 버그를 해결하여 이러한 패치 적용에 대한 지원을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="67a27dbf5548d05ac63e85bd8b4c875d8f48c102" translate="yes" xml:space="preserve">
          <source>Understanding History: Commits</source>
          <target state="translated">역사 이해 : 커밋</target>
        </trans-unit>
        <trans-unit id="9334dba95d5dfb2042093dd9adbddea5f77c5eb4" translate="yes" xml:space="preserve">
          <source>Understanding history: History diagrams</source>
          <target state="translated">히스토리 이해 : 히스토리 다이어그램</target>
        </trans-unit>
        <trans-unit id="85bd1a7ea75afef7e0417cd2bf9d9f3cf13e5e08" translate="yes" xml:space="preserve">
          <source>Understanding history: What is a branch?</source>
          <target state="translated">역사 이해 : 지사는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6d61d96a492f996316f1e84e66cbfde933315e2c" translate="yes" xml:space="preserve">
          <source>Understanding history: commits, parents, and reachability</source>
          <target state="translated">역사 이해 : 커밋, 부모 및 접근성</target>
        </trans-unit>
        <trans-unit id="afa47a28efb9d6631a7be02ac359bed5256995ce" translate="yes" xml:space="preserve">
          <source>Undo a commit and redo</source>
          <target state="translated">커밋 실행 취소 및 다시 실행</target>
        </trans-unit>
        <trans-unit id="61cb90c052dfcd0fda883c6029d1d0fc0a0f4685" translate="yes" xml:space="preserve">
          <source>Undo a commit, making it a topic branch</source>
          <target state="translated">커밋을 취소하여 주제 분기로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="93d74feb000c815128d68a09c83733db43b69c15" translate="yes" xml:space="preserve">
          <source>Undo a merge or pull</source>
          <target state="translated">병합 취소 또는 풀</target>
        </trans-unit>
        <trans-unit id="4728c70cd06347b5f285fb3e7887387303b3968e" translate="yes" xml:space="preserve">
          <source>Undo a merge or pull inside a dirty working tree</source>
          <target state="translated">병합 작업을 취소하거나 더러운 작업 트리 내부로 가져 오기</target>
        </trans-unit>
        <trans-unit id="27b7abb5b90b7a2e8f00eaf74b6df8323ba7d926" translate="yes" xml:space="preserve">
          <source>Undo add</source>
          <target state="translated">추가 취소</target>
        </trans-unit>
        <trans-unit id="ca677a11d37ffdca5231911a194cc2fcdffc5a26" translate="yes" xml:space="preserve">
          <source>Undo commits permanently</source>
          <target state="translated">영구적으로 커밋 취소</target>
        </trans-unit>
        <trans-unit id="4180759bca2f04cde0ec69611cb0e0ec1cfe7139" translate="yes" xml:space="preserve">
          <source>Undoes the effects of &lt;code&gt;fetch&lt;/code&gt; back to the specified revision. This allows you to re-&lt;code&gt;fetch&lt;/code&gt; an SVN revision. Normally the contents of an SVN revision should never change and &lt;code&gt;reset&lt;/code&gt; should not be necessary. However, if SVN permissions change, or if you alter your --ignore-paths option, a &lt;code&gt;fetch&lt;/code&gt; may fail with &quot;not found in commit&quot; (file not previously visible) or &quot;checksum mismatch&quot; (missed a modification). If the problem file cannot be ignored forever (with --ignore-paths) the only way to repair the repo is to use &lt;code&gt;reset&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 의 효과를 지정된 개정으로 되돌 립니다. SVN 개정판 을 다시 &lt;code&gt;fetch&lt;/code&gt; 수 있습니다 . 일반적으로 SVN 개정판의 내용은 변경 되지 않으며 &lt;code&gt;reset&lt;/code&gt; 할 필요가 없습니다. 그러나 SVN 권한이 변경되거나 --ignore-paths 옵션을 변경 하면 &quot;커밋에서 찾을 수 없음&quot;(이전에 표시되지 않은 파일) 또는 &quot;체크섬 불일치&quot;(수정이 누락 됨)와 함께 &lt;code&gt;fetch&lt;/code&gt; 가 실패 할 수 있습니다. 문제 파일을 --ignore-paths로 영원히 무시할 수없는 경우 repo를 복구하는 유일한 방법은 &lt;code&gt;reset&lt;/code&gt; 을 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="ac1f58f831611819b4114b80dd55e3ce540d5b23" translate="yes" xml:space="preserve">
          <source>Undoing a merge</source>
          <target state="translated">병합 취소</target>
        </trans-unit>
        <trans-unit id="f552d5a5802e3df6273c784214def9840b82f594" translate="yes" xml:space="preserve">
          <source>Unfortunately this system becomes inefficient once a project has a lot of objects. Try this on an old project:</source>
          <target state="translated">불행히도이 시스템은 프로젝트에 많은 객체가 있으면 비효율적입니다. 오래된 프로젝트에서 이것을 시도하십시오 :</target>
        </trans-unit>
        <trans-unit id="c7deb06b3e42a38e2b00598939aa39f8d24897bd" translate="yes" xml:space="preserve">
          <source>Unfortunately, the desired effect of cleaning up text files with mixed line endings and the undesired effect of corrupting binary files cannot be distinguished. In both cases CRLFs are removed in an irreversible way. For text files this is the right thing to do because CRLFs are line endings, while for binary files converting CRLFs corrupts data.</source>
          <target state="translated">불행하게도, 줄 끝이 혼합 된 텍스트 파일을 정리하는 원하는 효과와 이진 파일을 손상시키는 원하지 않는 효과는 구분할 수 없습니다. 두 경우 모두 CRLF는 되돌릴 수없는 방식으로 제거됩니다. 텍스트 파일의 경우 CRLF가 줄 끝이므로 이진 파일의 경우 CRLF를 변환하면 데이터가 손상되므로이 작업을 수행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6da1ce58d3a6c34c76807dc44593d7cd8c6563b6" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;--text&lt;/code&gt; is supplied patches of binary files without a textconv filter will be ignored.</source>
          <target state="translated">&lt;code&gt;--text&lt;/code&gt; 가 제공 되지 않으면 textconv 필터가없는 이진 파일의 패치는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="54cbf98b314812a07f65f95ae77e8608ddf0b26f" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-f&lt;/code&gt; is given, the &lt;code&gt;replace&lt;/code&gt; reference must not yet exist.</source>
          <target state="translated">&lt;code&gt;-f&lt;/code&gt; 를 지정 하지 않으면 &lt;code&gt;replace&lt;/code&gt; 참조가 아직 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="ec0a9816e3fe8947b4bfff6f5914c3288bed6fc9" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-f&lt;/code&gt; is given, the named tag must not yet exist.</source>
          <target state="translated">&lt;code&gt;-f&lt;/code&gt; 를 지정 하지 않으면 이름 지정된 태그가 아직 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="7824ccb45f3d7be1fd07def25712792fbdf3f009" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;git blame&lt;/code&gt; and &lt;code&gt;git annotate&lt;/code&gt; in older versions of git, the extent of the annotation can be limited to both line ranges and revision ranges. The &lt;code&gt;-L&lt;/code&gt; option, which limits annotation to a range of lines, may be specified multiple times.</source>
          <target state="translated">이전 버전의 git에서 &lt;code&gt;git blame&lt;/code&gt; 및 &lt;code&gt;git annotate&lt;/code&gt; 와 달리 주석 의 범위는 선 범위와 개정 범위로 제한 될 수 있습니다. 주석을 여러 줄로 제한 하는 &lt;code&gt;-L&lt;/code&gt; 옵션은 여러 번 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fa5e3a4c28161d2ef67ee80d5624341cfa56be1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;git diff-files&lt;/code&gt;, which showed the difference between the index file and the working tree, &lt;code&gt;git diff-index&lt;/code&gt; shows the differences between a committed &lt;strong&gt;tree&lt;/strong&gt; and either the index file or the working tree. In other words, &lt;code&gt;git diff-index&lt;/code&gt; wants a tree to be diffed against, and before we did the commit, we couldn&amp;rsquo;t do that, because we didn&amp;rsquo;t have anything to diff against.</source>
          <target state="translated">인덱스 파일과 작업 트리의 차이점을 보여준 &lt;code&gt;git diff-files&lt;/code&gt; 와 달리 git diff- &lt;code&gt;git diff-index&lt;/code&gt; 는 커밋 된 &lt;strong&gt;트리&lt;/strong&gt; 와 인덱스 파일 또는 작업 트리 의 차이점을 보여줍니다 . 다시 말해, &lt;code&gt;git diff-index&lt;/code&gt; 는 트리를 비교 하기를 원하며 커밋을 수행하기 전에 비교할 수있는 항목이 없기 때문에이를 수행 할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="a75073ebd9356a7219cb30b4bb866c17ce8b906c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;gitk&lt;/code&gt;, &lt;code&gt;git gui&lt;/code&gt; focuses on commit generation and single file annotation and does not show project history. It does however supply menu actions to start a &lt;code&gt;gitk&lt;/code&gt; session from within &lt;code&gt;git gui&lt;/code&gt;.</source>
          <target state="translated">달리 &lt;code&gt;gitk&lt;/code&gt; 이 , &lt;code&gt;git gui&lt;/code&gt; 생성 및 단일 파일 주석을 커밋에 초점을 맞추고 프로젝트의 역사를 표시하지 않습니다. 그러나 &lt;code&gt;git gui&lt;/code&gt; 내에서 &lt;code&gt;gitk&lt;/code&gt; 세션 을 시작하기위한 메뉴 조치를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="cd17281830ac5a9aa50c0d768481eabf04240182" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;raw&lt;/code&gt; format above, the time zone/UTC offset information contained in an RFC 2822 date string is used to adjust the date value to UTC prior to storage. Therefore it is important that this information be as accurate as possible.</source>
          <target state="translated">위 의 &lt;code&gt;raw&lt;/code&gt; 형식 과 달리 RFC 2822 날짜 문자열에 포함 된 시간대 / UTC 오프셋 정보는 날짜 값을 저장하기 전에 UTC로 조정하는 데 사용됩니다. 따라서이 정보는 최대한 정확해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9ebe23208a4d3f51d6690b78b04b40646f8e2f1" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;rfc2822&lt;/code&gt; format, this format is very strict. Any variation in formatting will cause fast-import to reject the value, and some sanity checks on the numeric values may also be performed.</source>
          <target state="translated">&lt;code&gt;rfc2822&lt;/code&gt; 형식 과 달리이 형식은 매우 엄격합니다. 형식이 변경되면 빠른 가져 오기가 값을 거부하고 숫자 값에 대한 일부 온 전성 검사도 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="422977ffd462a03a6cbce65db58b07001eb2214f" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;rfc2822&lt;/code&gt; format, this format is very strict. Any variation in formatting will cause fast-import to reject the value.</source>
          <target state="translated">&lt;code&gt;rfc2822&lt;/code&gt; 형식 과 달리이 형식은 매우 엄격합니다. 서식이 다양하면 빠른 가져 오기에서 값을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="a5e8af576412d2facd9f39a0996da0da165c42ee" translate="yes" xml:space="preserve">
          <source>Unlike the Porcelain format, the filename information is always given and terminates the entry:</source>
          <target state="translated">Porcelain 형식과 달리 파일 이름 정보는 항상 제공되며 항목을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="b603b31236d9df1a4442c23c62ea6317f2525837" translate="yes" xml:space="preserve">
          <source>Unlike the longhand form, when Alice fetches from Bob using a remote repository shorthand set up with &lt;code&gt;git remote&lt;/code&gt;, what was fetched is stored in a remote-tracking branch, in this case &lt;code&gt;bob/master&lt;/code&gt;. So after this:</source>
          <target state="translated">Longhand 형식과 달리 Alice가 &lt;code&gt;git remote&lt;/code&gt; 로 설정된 원격 저장소 단축을 사용하여 Bob에서 가져 오면 가져온 항목이 원격 추적 분기 (이 경우 &lt;code&gt;bob/master&lt;/code&gt; )에 저장 됩니다. 그래서이 후 :</target>
        </trans-unit>
        <trans-unit id="cc8e9909209a90f3a790bc3005980e8527de79e5" translate="yes" xml:space="preserve">
          <source>Unlike the traditional &lt;code&gt;unified&lt;/code&gt; diff format, which shows two files A and B with a single column that has &lt;code&gt;-&lt;/code&gt; (minus &amp;mdash; appears in A but removed in B), &lt;code&gt;+&lt;/code&gt; (plus &amp;mdash; missing in A but added to B), or &lt;code&gt;&quot; &quot;&lt;/code&gt; (space &amp;mdash; unchanged) prefix, this format compares two or more files file1, file2,&amp;hellip;​ with one file X, and shows how X differs from each of fileN. One column for each of fileN is prepended to the output line to note how X&amp;rsquo;s line is different from it.</source>
          <target state="translated">기존과는 달리 &lt;code&gt;unified&lt;/code&gt; 이 하나의 컬럼은 diff 형식, 쇼 두 개의 파일 A와 B &lt;code&gt;-&lt;/code&gt; (빼기 - A의 표시되지만 B에서 제거) &lt;code&gt;+&lt;/code&gt; - (플러스에서 누락하지만 B에 추가), 또는 &lt;code&gt;&quot; &quot;&lt;/code&gt; ( 공백 &amp;mdash; 변경되지 않은) 접두사 인이 형식은 둘 이상의 파일 file1, file2,&amp;hellip;를 하나의 파일 X와 비교하고 X가 각 파일 N과 어떻게 다른지 보여줍니다. 각각의 fileN에 대해 하나의 열이 출력 행 앞에 추가되어 X의 행이 어떻게 다른지 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71233552f2a4fc77054593fac1f6899dd0308229" translate="yes" xml:space="preserve">
          <source>Unlike variables like &lt;code&gt;color.ui&lt;/code&gt; and &lt;code&gt;core.editor&lt;/code&gt; the &lt;code&gt;receive.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; and &lt;code&gt;fetch.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; variables will not fall back on the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; configuration if they aren&amp;rsquo;t set. To uniformly configure the same fsck settings in different circumstances all three of them they must all set to the same values.</source>
          <target state="translated">같은 변수와 달리 &lt;code&gt;color.ui&lt;/code&gt; 및 &lt;code&gt;core.editor&lt;/code&gt; &lt;code&gt;receive.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 와 &lt;code&gt;fetch.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 변수는 다시 떨어지지 않을 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 구성 그들은하지 않은 경우 세트. 서로 다른 환경에서 동일한 fsck 설정을 균일하게 구성하려면 세 가지 설정을 모두 동일한 값으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="00ee5ed7b48c819f6f323dbe1b9a72aef5a0c864" translate="yes" xml:space="preserve">
          <source>Unlike variables like &lt;code&gt;color.ui&lt;/code&gt; and &lt;code&gt;core.editor&lt;/code&gt; the &lt;code&gt;receive.fsck.skipList&lt;/code&gt; and &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; variables will not fall back on the &lt;code&gt;fsck.skipList&lt;/code&gt; configuration if they aren&amp;rsquo;t set. To uniformly configure the same fsck settings in different circumstances all three of them they must all set to the same values.</source>
          <target state="translated">같은 변수와 달리 &lt;code&gt;color.ui&lt;/code&gt; 및 &lt;code&gt;core.editor&lt;/code&gt; &lt;code&gt;receive.fsck.skipList&lt;/code&gt; 및 &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; 변수는 다시 떨어지지 않을 &lt;code&gt;fsck.skipList&lt;/code&gt; 의 사람들이 설정되지 않은 경우 구성. 서로 다른 환경에서 동일한 fsck 설정을 균일하게 구성하려면 세 가지 설정을 모두 동일한 값으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8a3dffb4c65d7a1f27e907ef2a919885d1125ac9" translate="yes" xml:space="preserve">
          <source>Unlike when pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, any updates outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; will be accepted without &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;), whether that&amp;rsquo;s swapping e.g. a tree object for a blob, or a commit for another commit that&amp;rsquo;s doesn&amp;rsquo;t have the previous commit as an ancestor etc.</source>
          <target state="translated">&lt;a href=&quot;git-push&quot;&gt;git-push [1]으로 푸시&lt;/a&gt; 할 때와 달리 &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 외부의 업데이트 는 refspec (또는 &lt;code&gt;--force&lt;/code&gt; ) 에서 &lt;code&gt;+&lt;/code&gt; 없이 허용됩니다 . 또는 이전 커밋이 조상으로 포함되지 않은 다른 커밋에 대한 커밋</target>
        </trans-unit>
        <trans-unit id="2f2516ccb262ba2dda1eeb5218e911868837ce78" translate="yes" xml:space="preserve">
          <source>Unlike when pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, there is no configuration which&amp;rsquo;ll amend these rules, and nothing like a &lt;code&gt;pre-fetch&lt;/code&gt; hook analogous to the &lt;code&gt;pre-receive&lt;/code&gt; hook.</source>
          <target state="translated">&lt;a href=&quot;git-push&quot;&gt;git-push [1]로 푸시&lt;/a&gt; 할 때와 달리 , 이러한 규칙을 수정하는 구성은 없으며, &lt;code&gt;pre-receive&lt;/code&gt; 후크와 유사한 &lt;code&gt;pre-fetch&lt;/code&gt; 후크 와 같은 것은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fb79f423670171900d7e94880e8d45907e9f995c" translate="yes" xml:space="preserve">
          <source>Unlock a working tree, allowing it to be pruned, moved or deleted.</source>
          <target state="translated">가지 치기, 이동 또는 삭제를 위해 작업중인 트리를 잠금 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="b00eee8b49227caba98e5d68033660ff6076ebcc" translate="yes" xml:space="preserve">
          <source>Unmerged entries have the following format; the first character is a &quot;u&quot; to distinguish from ordinary changed entries.</source>
          <target state="translated">병합되지 않은 항목의 형식은 다음과 같습니다. 첫 번째 문자는 일반적인 변경 항목과 구별하기위한 &quot;u&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="2c99cc569343579b221cd64026ecc62bb1c21d7b" translate="yes" xml:space="preserve">
          <source>Unpack objects from a packed archive</source>
          <target state="translated">압축 아카이브에서 객체 압축 풀기</target>
        </trans-unit>
        <trans-unit id="42e2a268d032a6abb00d4cbd80feaa1ecd7a75d6" translate="yes" xml:space="preserve">
          <source>Unreachable tags, commits, and trees will also be accessed to find the tips of dangling segments of history. Use &lt;code&gt;--no-dangling&lt;/code&gt; if you don&amp;rsquo;t care about this output and want to speed it up further.</source>
          <target state="translated">도달 할 수없는 태그, 커밋 및 트리도 액세스하여 기록 세그먼트에 매달려있는 팁을 찾습니다. 이 출력에 신경 쓰지 않고 속도를 높이려면 &lt;code&gt;--no-dangling&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8a4efd1d470fc3c5ede97084c82a35b9804122a" translate="yes" xml:space="preserve">
          <source>Unregister the given submodules, i.e. remove the whole &lt;code&gt;submodule.$name&lt;/code&gt; section from .git/config together with their work tree. Further calls to &lt;code&gt;git submodule update&lt;/code&gt;, &lt;code&gt;git submodule foreach&lt;/code&gt; and &lt;code&gt;git submodule sync&lt;/code&gt; will skip any unregistered submodules until they are initialized again, so use this command if you don&amp;rsquo;t want to have a local checkout of the submodule in your working tree anymore.</source>
          <target state="translated">주어진 서브 모듈의 등록을 해제하십시오 &lt;code&gt;submodule.$name&lt;/code&gt; 즉, 작업 트리와 함께 .git / config에서 전체 서브 모듈. $ name 섹션을 제거하십시오 . &lt;code&gt;git submodule update&lt;/code&gt; , &lt;code&gt;git submodule foreach&lt;/code&gt; 및 &lt;code&gt;git submodule sync&lt;/code&gt; 에 대한 추가 호출 은 다시 초기화 될 때까지 등록되지 않은 서브 모듈을 건너 뛰므로 더 이상 작업 트리에서 서브 모듈의 로컬 체크 아웃을 원하지 않으면이 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1431f68f359f8699975be39dca08302c67d68d9e" translate="yes" xml:space="preserve">
          <source>Unset</source>
          <target state="translated">Unset</target>
        </trans-unit>
        <trans-unit id="8ff954e80b42b18d3d0fcda602d94db1e46da2d4" translate="yes" xml:space="preserve">
          <source>Unsetting the &lt;code&gt;text&lt;/code&gt; attribute on a path tells Git not to attempt any end-of-line conversion upon checkin or checkout.</source>
          <target state="translated">경로 에서 &lt;code&gt;text&lt;/code&gt; 속성을 설정 해제하면 체크인 또는 체크 아웃시 줄 끝 변환을 시도하지 않도록 Git에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="7f84947907454dd0cb412d2a8e5d5e3b9c2382f0" translate="yes" xml:space="preserve">
          <source>Unsetting the variable, or setting it to empty, &quot;0&quot; or &quot;false&quot; (case insensitive) disables trace messages.</source>
          <target state="translated">변수를 설정 해제하거나 비어있는 &quot;0&quot;또는 &quot;false&quot;(대소 문자 구분)로 설정하면 추적 메시지가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c176eff9c64fa28a4b6af1aa296cc1394bbf7a80" translate="yes" xml:space="preserve">
          <source>Unshelve</source>
          <target state="translated">Unshelve</target>
        </trans-unit>
        <trans-unit id="9fde2b36ff30053ad23e6a695929873244cc0367" translate="yes" xml:space="preserve">
          <source>Unshelve options</source>
          <target state="translated">옵션 해제</target>
        </trans-unit>
        <trans-unit id="004e593b6690fb3d48f4f5a86eac1cd13b5b2234" translate="yes" xml:space="preserve">
          <source>Unshelving will take a shelved P4 changelist, and produce the equivalent git commit in the branch refs/remotes/p4-unshelved/&amp;lt;changelist&amp;gt;.</source>
          <target state="translated">Unshelving은 쉘프 P4 변경 목록을 가져와 분기 refs / remotes / p4-unshelved / &amp;lt;changelist&amp;gt;에서 동등한 git commit을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a6e7eb706e115cdaf88206be37eb67b232d007bc" translate="yes" xml:space="preserve">
          <source>Unspecified</source>
          <target state="translated">Unspecified</target>
        </trans-unit>
        <trans-unit id="78f88266b367e8b6e086054e91f1ebc89e168d16" translate="yes" xml:space="preserve">
          <source>Until Git version 2.20, and unlike when pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, any updates to &lt;code&gt;refs/tags/*&lt;/code&gt; would be accepted without &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;). When fetching, we promiscuously considered all tag updates from a remote to be forced fetches. Since Git version 2.20, fetching to update &lt;code&gt;refs/tags/*&lt;/code&gt; works the same way as when pushing. I.e. any updates will be rejected without &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;).</source>
          <target state="translated">Git 버전 2.20까지, &lt;a href=&quot;git-push&quot;&gt;git-push [1]로 푸시&lt;/a&gt; 할 때와 달리 &lt;code&gt;refs/tags/*&lt;/code&gt; 에 대한 모든 업데이트 는 refspec (또는 &lt;code&gt;--force&lt;/code&gt; ) 에서 &lt;code&gt;+&lt;/code&gt; 없이 허용됩니다 . 페치 할 때, 원격에서 모든 태그 업데이트를 강제 페치로 간주했습니다. Git 버전 2.20부터 &lt;code&gt;refs/tags/*&lt;/code&gt; 를 업데이트하기 위해 가져 오는 것은 푸시 할 때와 같은 방식으로 작동합니다. 즉 , refspec (또는 &lt;code&gt;--force&lt;/code&gt; ) 에서 &lt;code&gt;+&lt;/code&gt; 없이 업데이트가 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="9514c500d61430538679eec9081979b274172cf9" translate="yes" xml:space="preserve">
          <source>Untracked cache</source>
          <target state="translated">추적되지 않은 캐시</target>
        </trans-unit>
        <trans-unit id="614ce4ff1bf92552970ab54ff766006d0da693f9" translate="yes" xml:space="preserve">
          <source>Untracked items have the following format:</source>
          <target state="translated">추적되지 않은 항목의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1eade895e693b4111455eda06a87af1097cf4d6c" translate="yes" xml:space="preserve">
          <source>Untyped &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt;, e.g. the contents of a file.</source>
          <target state="translated">형식화되지 않은 &lt;a href=&quot;#def_object&quot;&gt;객체&lt;/a&gt; (예 : 파일의 내용)</target>
        </trans-unit>
        <trans-unit id="7b839a219907b09268c047c522a03961e96bd78b" translate="yes" xml:space="preserve">
          <source>Unused configuration variable. Used in Git versions 2.20 and 2.21 as an escape hatch to enable the legacy shellscript implementation of rebase. Now the built-in rewrite of it in C is always used. Setting this will emit a warning, to alert any remaining users that setting this now does nothing.</source>
          <target state="translated">사용하지 않은 구성 변수. Git 버전 2.20 및 2.21에서 이스케이프 해치로 사용되어 레거시 셸 스크립트 rebase 구현을 가능하게합니다. 이제 C에서 내장 재 작성이 항상 사용됩니다. 이를 설정하면 나머지 사용자에게 지금 설정해도 아무 것도 수행하지 않는다는 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="315fc3f07f41b1c3600ceb87f6a9f32b85f1da70" translate="yes" xml:space="preserve">
          <source>Unused configuration variable. Used in Git versions 2.22 to 2.26 as an escape hatch to enable the legacy shellscript implementation of stash. Now the built-in rewrite of it in C is always used. Setting this will emit a warning, to alert any remaining users that setting this now does nothing.</source>
          <target state="translated">사용되지 않는 구성 변수입니다. Git 버전 2.22 ~ 2.26에서 이스케이프 해치로 사용되어 기존 쉘 스크립트의 숨김 구현을 활성화합니다. 이제 C로 내장 된 재 작성이 항상 사용됩니다. 이를 설정하면 경고가 발생하여 나머지 사용자에게이 설정은 아무 효과가 없음을 알립니다.</target>
        </trans-unit>
        <trans-unit id="ca31b4c795dcb03444e6d0c037dbcd47081c70a9" translate="yes" xml:space="preserve">
          <source>Update affected files from CVS repository before attempting export.</source>
          <target state="translated">내보내기를 시도하기 전에 CVS 저장소에서 영향을받는 파일을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="82e59b151c004802a1fa23ba3e75a68d14df0e2a" translate="yes" xml:space="preserve">
          <source>Update an existing shelved changelist with this commit. Implies --shelve. Repeat for multiple shelved changelists.</source>
          <target state="translated">이 커밋으로 기존 선반 변경 목록을 업데이트하십시오. --shelve를 의미합니다. 여러 개의 보류 된 변경 목록에 대해 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="5433caf2e572561b5bb38ff5e69b0263d08b90aa" translate="yes" xml:space="preserve">
          <source>Update and examine branches from the repository you cloned from:</source>
          <target state="translated">복제 한 저장소에서 분기를 업데이트하고 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="381f15e94e347f076ef71f417ee29b782a6dcc4d" translate="yes" xml:space="preserve">
          <source>Update auxiliary info file to help dumb servers</source>
          <target state="translated">바보 서버를 돕기 위해 보조 정보 파일 업데이트</target>
        </trans-unit>
        <trans-unit id="d94aecddb1a2d3c03afb4a7cf4e1bb3a0123c2c6" translate="yes" xml:space="preserve">
          <source>Update hook</source>
          <target state="translated">후크 업데이트</target>
        </trans-unit>
        <trans-unit id="e5f960e3f28d7d7ea59f8750682a356ae18535be" translate="yes" xml:space="preserve">
          <source>Update remote refs along with associated objects</source>
          <target state="translated">관련 객체와 함께 원격 참조 업데이트</target>
        </trans-unit>
        <trans-unit id="ee3315ea0cbb49ab6105a89db0964480184c3ce9" translate="yes" xml:space="preserve">
          <source>Update the Git repository with recent changes from p4, rebasing your work on top:</source>
          <target state="translated">p4의 최근 변경 사항으로 Git 리포지토리를 업데이트하고 작업 내용을 다시 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="5937294218e2d7b95b7b77414b52c326239ca8d5" translate="yes" xml:space="preserve">
          <source>Update the index by adding new files that are unknown to the index and files modified in the working tree, but ignore files that have been removed from the working tree. This option is a no-op when no &amp;lt;pathspec&amp;gt; is used.</source>
          <target state="translated">색인에 알려지지 않은 새 파일과 작업 트리에서 수정 된 파일을 추가하여 색인을 업데이트하지만 작업 트리에서 제거 된 파일은 무시하십시오. &amp;lt;pathspec&amp;gt;이 사용되지 않으면이 옵션은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94df66721f1bfd4990972c3f5f4a0d6b61f59f9e" translate="yes" xml:space="preserve">
          <source>Update the index just where it already has an entry matching &amp;lt;pathspec&amp;gt;. This removes as well as modifies index entries to match the working tree, but adds no new files.</source>
          <target state="translated">&amp;lt;pathspec&amp;gt;과 일치하는 항목이 이미있는 색인을 업데이트하십시오. 이렇게하면 작업 트리와 일치하도록 색인 항목이 제거 될뿐만 아니라 수정되지만 새 파일은 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03d173e098621e3730258998672da85e88b347b1" translate="yes" xml:space="preserve">
          <source>Update the index not only where the working tree has a file matching &amp;lt;pathspec&amp;gt; but also where the index already has an entry. This adds, modifies, and removes index entries to match the working tree.</source>
          <target state="translated">작업 트리에 &amp;lt;pathspec&amp;gt;과 일치하는 파일이있는 색인뿐만 아니라 색인에 이미 항목이있는 색인도 업데이트하십시오. 작업 트리와 일치하도록 인덱스 항목을 추가, 수정 및 제거합니다.</target>
        </trans-unit>
        <trans-unit id="1a6e291eaaa3e731de98429f7fb37fdac90f0a22" translate="yes" xml:space="preserve">
          <source>Update the object name stored in a ref safely</source>
          <target state="translated">참조에 저장된 객체 이름을 안전하게 업데이트</target>
        </trans-unit>
        <trans-unit id="00f0c8a1eac4ed2966a7d563ef87a6387d365dcf" translate="yes" xml:space="preserve">
          <source>Update the origin repository&amp;rsquo;s master branch with the dev branch, allowing non-fast-forward updates. &lt;strong&gt;This can leave unreferenced commits dangling in the origin repository.&lt;/strong&gt; Consider the following situation, where a fast-forward is not possible:</source>
          <target state="translated">원본 저장소의 마스터 분기를 dev 분기로 업데이트하여 빨리 감기가 아닌 업데이트를 허용합니다. &lt;strong&gt;이렇게하면 참조 리포지토리가 오리진 저장소에 매달려 있습니다. &lt;/strong&gt;빨리 감기가 불가능한 다음 상황을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b73d3968359117cfd051c2e81a709d1d9e1579b7" translate="yes" xml:space="preserve">
          <source>Update the reference to the value of the top reflog entry (i.e. &amp;lt;ref&amp;gt;@{0}) if the previous top entry was pruned. (This option is ignored for symbolic references.)</source>
          <target state="translated">이전 맨 위 항목이 제거 된 경우 맨 위 참조 항목 (예 : &amp;lt;ref&amp;gt; @ {0})의 값에 대한 참조를 업데이트하십시오. (이 옵션은 기호 참조의 경우 무시됩니다.)</target>
        </trans-unit>
        <trans-unit id="d7c08d3ae4fbcbbf6a3dc89cdba309659a4395bc" translate="yes" xml:space="preserve">
          <source>Update the reflog for &amp;lt;name&amp;gt; with &amp;lt;reason&amp;gt;. This is valid only when creating or updating a symbolic ref.</source>
          <target state="translated">&amp;lt;이름&amp;gt;에 대한 reflog를 &amp;lt;이유&amp;gt;로 업데이트하십시오. 이것은 기호 참조를 작성하거나 업데이트 할 때만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="d053e75e709458eca9f01e5c8910658ea18a25cf" translate="yes" xml:space="preserve">
          <source>Update the registered submodules to match what the superproject expects by cloning missing submodules, fetching missing commits in submodules and updating the working tree of the submodules. The &quot;updating&quot; can be done in several ways depending on command line options and the value of &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; configuration variable. The command line option takes precedence over the configuration variable. If neither is given, a &lt;code&gt;checkout&lt;/code&gt; is performed. The &lt;code&gt;update&lt;/code&gt; procedures supported both from the command line as well as through the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; configuration are:</source>
          <target state="translated">누락 된 서브 모듈을 복제하고, 서브 모듈에서 누락 된 커밋을 가져오고, 서브 모듈의 작업 트리를 업데이트하여 수퍼 프로젝트가 기대하는 것과 일치하도록 등록 된 서브 모듈을 업데이트하십시오. &quot;업데이트&quot;는 명령 행 옵션 및 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 구성 변수 의 값에 따라 여러 가지 방법으로 수행 할 수 있습니다 . 명령 행 옵션이 구성 변수보다 우선합니다. 둘 다 주어지지 않으면 &lt;code&gt;checkout&lt;/code&gt; 이 수행됩니다. &lt;code&gt;update&lt;/code&gt; 절차는 명령 줄에서뿐만 아니라 통해 모두 지원 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 구성은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="9a189cb9ecf6f808972788504f5218556d75488e" translate="yes" xml:space="preserve">
          <source>Update the remote-tracking branches for the repository you cloned from, then merge one of them into your current branch:</source>
          <target state="translated">복제 한 저장소의 원격 추적 분기를 업데이트 한 후 그 중 하나를 현재 분기로 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="b4a6a66956cae4a12a849cae6094fa1d9187d293" translate="yes" xml:space="preserve">
          <source>Update the remote-tracking branches:</source>
          <target state="translated">원격 추적 분기를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="6d5daf3e771e4022d14d6727e49c69b93e7e63af" translate="yes" xml:space="preserve">
          <source>Update the sparse-checkout file to include additional patterns. By default, these patterns are read from the command-line arguments, but they can be read from stdin using the &lt;code&gt;--stdin&lt;/code&gt; option. When &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; is enabled, the given patterns are interpreted as directory names as in the &lt;code&gt;set&lt;/code&gt; subcommand.</source>
          <target state="translated">추가 패턴을 포함하도록 스파 스 체크 아웃 파일을 업데이트하십시오. 기본적으로 이러한 패턴은 명령 줄 인수에서 읽지 만 &lt;code&gt;--stdin&lt;/code&gt; 을 사용하여 stdin에서 읽을 수 있습니다. 옵션을 . 때 &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; 가 활성화되어, 주어진 패턴은 같이 디렉토리 이름으로 해석됩니다 &lt;code&gt;set&lt;/code&gt; 하위 명령.</target>
        </trans-unit>
        <trans-unit id="f68dff1cbdca38d9a97763a1d9fd849e951b6a1b" translate="yes" xml:space="preserve">
          <source>Updates files in the working tree to match the version in the index or the specified tree. If no pathspec was given, &lt;code&gt;git checkout&lt;/code&gt; will also update &lt;code&gt;HEAD&lt;/code&gt; to set the specified branch as the current branch.</source>
          <target state="translated">작업 트리의 파일을 색인 또는 지정된 트리의 버전과 일치하도록 업데이트합니다. pathspec을 지정하지 않으면 &lt;code&gt;git checkout&lt;/code&gt; 은 &lt;code&gt;HEAD&lt;/code&gt; 를 업데이트 하여 지정된 분기를 현재 분기로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="091bf3e8c6fb28b8688a9117ac018615896df561" translate="yes" xml:space="preserve">
          <source>Updates remote refs using local refs, while sending objects necessary to complete the given refs.</source>
          <target state="translated">주어진 심판을 완료하는 데 필요한 객체를 보내는 동안 로컬 심판을 사용하여 원격 심판을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="91ca9b60db53a2ebedea4c579e08371ec4025869" translate="yes" xml:space="preserve">
          <source>Updating A with the resulting merge commit will fast-forward and your push will be accepted.</source>
          <target state="translated">병합 커밋 결과로 A를 업데이트하면 빨리 진행되고 푸시가 수락됩니다.</target>
        </trans-unit>
        <trans-unit id="b1b31935884de26d68d690781ac1ec814b3bc924" translate="yes" xml:space="preserve">
          <source>Updating a repository with git fetch</source>
          <target state="translated">git fetch로 리포지토리 업데이트</target>
        </trans-unit>
        <trans-unit id="c2ed1ab77aee7c3aaed70bc448641d662955a12f" translate="yes" xml:space="preserve">
          <source>Updating existing tests that assume GIT_TRACE format messages.</source>
          <target state="translated">GIT_TRACE 형식 메시지를 가정하는 기존 테스트를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="c5ded60beb1b0eb17cab63a8e09a8acd2261286e" translate="yes" xml:space="preserve">
          <source>Updating the index did something else too: it created a &lt;code&gt;.git/index&lt;/code&gt; file. This is the index that describes your current working tree, and something you should be very aware of. Again, you normally never worry about the index file itself, but you should be aware of the fact that you have not actually really &quot;checked in&quot; your files into Git so far, you&amp;rsquo;ve only &lt;strong&gt;told&lt;/strong&gt; Git about them.</source>
          <target state="translated">인덱스를 업데이트하면 다른 일이 발생했습니다. &lt;code&gt;.git/index&lt;/code&gt; 파일을 만들었습니다 . 이것은 현재 작업 트리를 설명하는 색인이며 매우 알고 있어야합니다. 다시 말하지만, 당신은 일반적으로 인덱스 파일 자체에 대해 걱정하지 않습니다,하지만 당신은 당신이 실제로 정말 힘내에 파일 지금까지, 당신은 단지 한 &quot;체크&quot;는 사실을 알고 있어야 &lt;strong&gt;했다&lt;/strong&gt; 그들에 대해 힘내.</target>
        </trans-unit>
        <trans-unit id="583381e5edf6e3ab467919c38286667f0916979d" translate="yes" xml:space="preserve">
          <source>Upon completion, &amp;lt;branch&amp;gt; will be the current branch.</source>
          <target state="translated">완료되면 &amp;lt;branch&amp;gt;가 현재 분기가됩니다.</target>
        </trans-unit>
        <trans-unit id="c956664b8da61af6d0e1bf33a6e1ff75cbe45ad1" translate="yes" xml:space="preserve">
          <source>Upon seeing an invalid object name in the input, pretend as if the bad input was not given.</source>
          <target state="translated">입력에서 유효하지 않은 오브젝트 이름을 볼 때 잘못된 입력이 제공되지 않은 것처럼 가장하십시오.</target>
        </trans-unit>
        <trans-unit id="d725441fc805b8226e9417fb2c8cf53ac8d791d5" translate="yes" xml:space="preserve">
          <source>Upstream branch to compare against. May be any valid commit, not just an existing branch name. Defaults to the configured upstream for the current branch.</source>
          <target state="translated">비교할 업스트림 브랜치 기존 브랜치 이름뿐만 아니라 유효한 커밋 일 수도 있습니다. 현재 분기에 대해 구성된 업스트림이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="f5808323e4ba717fc383cb75e63b6cf3a4e857e7" translate="yes" xml:space="preserve">
          <source>Upstream branch to search for equivalent commits. Defaults to the upstream branch of HEAD.</source>
          <target state="translated">동등한 커밋을 검색하는 업스트림 브랜치 HEAD의 업스트림 분기로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="309bc26d3c4c2649258f95c7069216bb2a7ac5f4" translate="yes" xml:space="preserve">
          <source>Upstream location from which commits are identified to submit to p4. By default, this is the most recent p4 commit reachable from &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">p4에 제출할 확약이 식별되는 업스트림 위치. 기본적으로 이것은 &lt;code&gt;HEAD&lt;/code&gt; 에서 도달 할 수있는 가장 최근의 p4 커밋 입니다.</target>
        </trans-unit>
        <trans-unit id="df28f1403e8348eae4829434034d1a95e5fe659d" translate="yes" xml:space="preserve">
          <source>Url translation</source>
          <target state="translated">URL 번역</target>
        </trans-unit>
        <trans-unit id="7ae770d8c2db91584c78e413662ced65719f53ca" translate="yes" xml:space="preserve">
          <source>Usage of this flag will probably be rare, since you can get rid of commits that start empty by just firing up an interactive rebase and removing the lines corresponding to the commits you don&amp;rsquo;t want. This flag exists as a convenient shortcut, such as for cases where external tools generate many empty commits and you want them all removed.</source>
          <target state="translated">이 플래그를 사용하는 경우는 드뭅니다. 대화 형 리베이스를 실행하고 원하지 않는 커밋에 해당하는 줄을 제거하여 비어있는 커밋을 제거 할 수 있기 때문입니다. 이 플래그는 외부 도구가 많은 빈 커밋을 생성하고 모두 제거하려는 경우와 같이 편리한 바로 가기로 존재합니다.</target>
        </trans-unit>
        <trans-unit id="f51159e5f3b0adbeed98e188d040286280a5320b" translate="yes" xml:space="preserve">
          <source>Usage text</source>
          <target state="translated">사용법 텍스트</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="6039144c2dc6586b6f3f0cb7423bcc0b3de0d0c1" translate="yes" xml:space="preserve">
          <source>Use &quot;patience diff&quot; algorithm when generating patches.</source>
          <target state="translated">패치를 생성 할 때 &quot;환자 차이&quot;알고리즘을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1712fa1f1e6f89a27b7d3117ed39073a3258971d" translate="yes" xml:space="preserve">
          <source>Use &amp;lt;dir&amp;gt; to store the resulting files, instead of the current working directory.</source>
          <target state="translated">현재 작업 디렉토리 대신 &amp;lt;dir&amp;gt;을 사용하여 결과 파일을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="89ed1ad2d65d4e1af42e685a9ee22c739e5d2c9b" translate="yes" xml:space="preserve">
          <source>Use &amp;lt;message&amp;gt; instead of the branch names for the first line of the log message. For use with &lt;code&gt;--log&lt;/code&gt;.</source>
          <target state="translated">로그 메시지의 첫 번째 줄에 분기 이름 대신 &amp;lt;message&amp;gt;를 사용하십시오. &lt;code&gt;--log&lt;/code&gt; 와 함께 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8e6c324c4e7440184ef28eb2f6fc1fca5a4a325" translate="yes" xml:space="preserve">
          <source>Use &amp;lt;regex&amp;gt; to decide what a word is, instead of considering runs of non-whitespace to be a word. Also implies &lt;code&gt;--word-diff&lt;/code&gt; unless it was already enabled.</source>
          <target state="translated">공백이 아닌 단어를 단어로 간주하는 대신 &amp;lt;regex&amp;gt;를 사용하여 단어가 무엇인지 결정하십시오. 또한 이미 활성화되어 있지 않은 경우 &lt;code&gt;--word-diff&lt;/code&gt; 를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="f70b8a97f949594b729b07efce2ca59a63023925" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;!&lt;/code&gt; to not make the corresponding negated long option available.</source>
          <target state="translated">사용 &lt;code&gt;!&lt;/code&gt; 해당 부정 긴 옵션을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f7924a219e6794d45a36b15b2c44738227b795ff" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; to set the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; explicitly. e.g., &quot;git remote set-head origin master&quot; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/master&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="translated">사용 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 기호-REF 설정 &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 명시 적으로. 예를 들어, &quot;git remote set-head origin master&quot;는 symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; 를 &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; 로 설정 합니다. &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; 이미 존재하는 경우에만 작동 합니다. 그렇지 않은 경우 먼저 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="e726751622c7eadb004a31b60b5fa1e9cc1fbf90" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; to set the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; explicitly. e.g., &lt;code&gt;git
remote set-head origin master&lt;/code&gt; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/master&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="translated">사용 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 기호-REF 설정 &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 명시 적으로. 예를 들어, &lt;code&gt;git remote set-head origin master&lt;/code&gt; 는 symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; 를 &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; 로 설정합니다. 합니다. 이것은 &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; 가 이미 존재하는 경우에만 작동 합니다. 그렇지 않은 경우 먼저 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="d950943422ee3b93275d1e4b1e510463e5b432e0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; to contact a running cache daemon (or start a new cache daemon if one is not started). Defaults to &lt;code&gt;$XDG_CACHE_HOME/git/credential/socket&lt;/code&gt; unless &lt;code&gt;~/.git-credential-cache/&lt;/code&gt; exists in which case &lt;code&gt;~/.git-credential-cache/socket&lt;/code&gt; is used instead. If your home directory is on a network-mounted filesystem, you may need to change this to a local filesystem. You must specify an absolute path.</source>
          <target state="translated">&lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 를 사용 하여 실행중인 캐시 디먼에 접속하십시오 (또는 시작되지 않은 경우 새 캐시 디먼을 시작하십시오). &lt;code&gt;~/.git-credential-cache/&lt;/code&gt; 가 없으면 &lt;code&gt;~/.git-credential-cache/socket&lt;/code&gt; 이 대신 사용 되지 않는 한 기본값은 &lt;code&gt;$XDG_CACHE_HOME/git/credential/socket&lt;/code&gt; 입니다. 홈 디렉토리가 네트워크 마운트 파일 시스템에있는 경우이를 로컬 파일 시스템으로 변경해야합니다. 절대 경로를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="faabe60607ec900b5e4ad4f074b4870d8f9c10c6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; to lookup and store credentials. The file will have its filesystem permissions set to prevent other users on the system from reading it, but will not be encrypted or otherwise protected. If not specified, credentials will be searched for from &lt;code&gt;~/.git-credentials&lt;/code&gt; and &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt;, and credentials will be written to &lt;code&gt;~/.git-credentials&lt;/code&gt; if it exists, or &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt; if it exists and the former does not. See also &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt;.</source>
          <target state="translated">자격 증명을 조회하고 저장 하려면 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 를 사용하십시오 . 파일의 파일 시스템 권한은 시스템의 다른 사용자가 읽을 수 없도록 설정되어 있지만 암호화되거나 보호되지는 않습니다. 지정하지 않으면 &lt;code&gt;~/.git-credentials&lt;/code&gt; 및 &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt; 에서 신임 정보가 검색되고 &lt;code&gt;~/.git-credentials&lt;/code&gt; ( 존재하는 경우) 또는 &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt; 존재하는 경우)에 신임 정보 가 기록됩니다. 전자는 그렇지 않습니다. &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aadb92eae500ef695bbe6a445720ce25246dd04e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;*&lt;/code&gt; to mean that this option should not be listed in the usage generated for the &lt;code&gt;-h&lt;/code&gt; argument. It&amp;rsquo;s shown for &lt;code&gt;--help-all&lt;/code&gt; as documented in &lt;a href=&quot;gitcli&quot;&gt;gitcli[7]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 를 사용 하여이 옵션이 &lt;code&gt;-h&lt;/code&gt; 인수에 대해 생성 된 사용법에 나열되어서는 안됨을 의미합니다 . &lt;a href=&quot;gitcli&quot;&gt;gitcli [7]에&lt;/a&gt; 설명 된대로 &lt;code&gt;--help-all&lt;/code&gt; 에 대해 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="3bbcee2a044e9c08185b38acb1e1c57ceea88054" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;--no-guess&lt;/code&gt; to disable this.</source>
          <target state="translated">이를 비활성화 하려면 &lt;code&gt;--no-guess&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6deefc2a8fa6667ca14a90dee15faf81b1f0546a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;-o master&lt;/code&gt; for continuing an import that was initially done by the old cvs2git tool.</source>
          <target state="translated">이전 cvs2git 도구에서 처음 수행 한 가져 오기를 계속 하려면 &lt;code&gt;-o master&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a4527eec708654a210ce88433047c8e573fb91f2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;-r&lt;/code&gt; together with &lt;code&gt;-d&lt;/code&gt; to delete remote-tracking branches. Note, that it only makes sense to delete remote-tracking branches if they no longer exist in the remote repository or if &lt;code&gt;git fetch&lt;/code&gt; was configured not to fetch them again. See also the &lt;code&gt;prune&lt;/code&gt; subcommand of &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt; for a way to clean up all obsolete remote-tracking branches.</source>
          <target state="translated">원격 추적 분기를 삭제 하려면 &lt;code&gt;-r&lt;/code&gt; 을 &lt;code&gt;-d&lt;/code&gt; 와 함께 사용하십시오 . 원격 추적 분기가 더 이상 원격 저장소에 존재하지 않거나 &lt;code&gt;git fetch&lt;/code&gt; 가 다시 가져 오지 않도록 구성된 경우에만 원격 추적 분기를 삭제하는 것이 좋습니다 . 더 이상 사용되지 않는 모든 원격 추적 분기를 정리하는 방법 은 &lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; 의 &lt;code&gt;prune&lt;/code&gt; 하위 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb7d25cab29167524de808a8da669505756898ee" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;=&lt;/code&gt; if the option takes an argument.</source>
          <target state="translated">옵션에 인수가 있으면 &lt;code&gt;=&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d247642d4c8609f74c2030daa3d24c7c82d2e46d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;?&lt;/code&gt; to mean that the option takes an optional argument. You probably want to use the &lt;code&gt;--stuck-long&lt;/code&gt; mode to be able to unambiguously parse the optional argument.</source>
          <target state="translated">사용 &lt;code&gt;?&lt;/code&gt; 옵션이 옵션 인수를 취한다는 것을 의미합니다. &lt;code&gt;--stuck-long&lt;/code&gt; 모드 를 사용 하여 선택적 인수를 명확하게 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7929eb6fd77d1ea35c9c481fc89518eafcc1cd45" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git bisect&lt;/code&gt; to get a short usage description, and &lt;code&gt;git bisect
help&lt;/code&gt; or &lt;code&gt;git bisect -h&lt;/code&gt; to get a long usage description.</source>
          <target state="translated">&lt;code&gt;git bisect&lt;/code&gt; 를 사용 하여 짧은 사용법 설명을 얻고 &lt;code&gt;git bisect help&lt;/code&gt; 또는 &lt;code&gt;git bisect -h&lt;/code&gt; 를 사용하여 긴 사용법 설명을 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="599c65a25784af23c9351ba6f4874c534a65a263" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git cherry origin&lt;/code&gt; to see which ones of your patches were accepted, and/or use &lt;code&gt;git rebase origin&lt;/code&gt; to port your unmerged changes forward to the updated upstream.</source>
          <target state="translated">&lt;code&gt;git cherry origin&lt;/code&gt; 을 사용 하여 어떤 패치가 수락되었는지 확인하거나 &lt;code&gt;git rebase origin&lt;/code&gt; 을 사용 하여 병합되지 않은 변경 사항을 업데이트 된 업스트림으로 포팅하십시오.</target>
        </trans-unit>
        <trans-unit id="f1986201248cbf297f2fb86d6f520b30d057ce7d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; or &lt;code&gt;git remote update&lt;/code&gt; to stay up to date.</source>
          <target state="translated">사용은 &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; 이나 &lt;code&gt;git remote update&lt;/code&gt; 최신 상태로 유지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="252ef42d37b56d31d5e5dc2525ae974052dfca91" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git format-patch origin&lt;/code&gt; to prepare patches for e-mail submission to your upstream and send it out. Go back to step 2. and continue.</source>
          <target state="translated">&lt;code&gt;git format-patch origin&lt;/code&gt; 을 사용 하여 전자 메일을 업스트림에 제출할 패치를 준비한 후 발송하십시오. 2 단계로 돌아가서 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="cd30f3ed950161de3f8267d9a18953af3c02784f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git mergetool&lt;/code&gt; to run one of several merge utilities to resolve merge conflicts. It is typically run after &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git mergetool&lt;/code&gt; 을 사용 하여 여러 병합 유틸리티 중 하나를 실행하여 병합 충돌을 해결하십시오. 일반적으로 &lt;code&gt;git merge&lt;/code&gt; 후에 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="6b298c06fc405635f29d06efdf0f42592d8075f2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git rev-parse&lt;/code&gt; in option parsing mode (see PARSEOPT section below).</source>
          <target state="translated">옵션 구문 분석 모드에서 &lt;code&gt;git rev-parse&lt;/code&gt; 를 사용 하십시오 (아래 PARSEOPT 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="7c9820d48befbd19730095f238fb8a15824823ad" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git rev-parse&lt;/code&gt; in shell quoting mode (see SQ-QUOTE section below). In contrast to the &lt;code&gt;--sq&lt;/code&gt; option below, this mode does only quoting. Nothing else is done to command input.</source>
          <target state="translated">쉘 인용 모드에서 &lt;code&gt;git rev-parse&lt;/code&gt; 를 사용하십시오 (아래 SQ-QUOTE 섹션 참조). 아래 의 &lt;code&gt;--sq&lt;/code&gt; 옵션과 달리이 모드는 인용 만합니다 . 입력을 명령하기위한 다른 작업은 없습니다.</target>
        </trans-unit>
        <trans-unit id="4c4d44083fa5e2a6971987cf935297be30994f4c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stash&lt;/code&gt; when you want to record the current state of the working directory and the index, but want to go back to a clean working directory. The command saves your local modifications away and reverts the working directory to match the &lt;code&gt;HEAD&lt;/code&gt; commit.</source>
          <target state="translated">작업 디렉토리 및 색인의 현재 상태를 기록하지만 깨끗한 작업 디렉토리로 돌아가려면 &lt;code&gt;git stash&lt;/code&gt; 를 사용하십시오 . 이 명령은 로컬 수정 사항을 저장하고 &lt;code&gt;HEAD&lt;/code&gt; 커밋 과 일치하도록 작업 디렉토리를 되돌 립니다.</target>
        </trans-unit>
        <trans-unit id="41c11f9d8154a7d9c49ff48bc15e09cdeb4a9a5c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stripspace --strip-comments&lt;/code&gt; to obtain:</source>
          <target state="translated">사용 &lt;code&gt;git stripspace --strip-comments&lt;/code&gt; 얻을 :</target>
        </trans-unit>
        <trans-unit id="141b00818c5025cc15ff515d81283fc5705a8a4e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stripspace&lt;/code&gt; with no arguments to obtain:</source>
          <target state="translated">인수없이 &lt;code&gt;git stripspace&lt;/code&gt; 를 사용 하여 다음을 확보하십시오.</target>
        </trans-unit>
        <trans-unit id="ae0479a18945009a7ebac30bdfceaa72c61a99c4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ident&lt;/code&gt; in the &lt;code&gt;From:&lt;/code&gt; header of each commit email. If the author ident of the commit is not textually identical to the provided &lt;code&gt;ident&lt;/code&gt;, place a &lt;code&gt;From:&lt;/code&gt; header in the body of the message with the original author. If no &lt;code&gt;ident&lt;/code&gt; is given, use the committer ident.</source>
          <target state="translated">각 커밋 이메일 의 &lt;code&gt;From:&lt;/code&gt; 헤더에 &lt;code&gt;ident&lt;/code&gt; 를 사용하십시오 . 커밋의 작성자 ID가 제공된 &lt;code&gt;ident&lt;/code&gt; 와 텍스트 적으로 동일하지 않은 경우 원래 작성자와 함께 메시지 본문에 &lt;code&gt;From:&lt;/code&gt; 헤더를 배치하십시오. &lt;code&gt;ident&lt;/code&gt; 가 없으면 커미터 아이디를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8fb68f530aa46816206d7ea34908da4d297edef3" translate="yes" xml:space="preserve">
          <source>Use IPv4 addresses only, ignoring IPv6 addresses.</source>
          <target state="translated">IPv6 주소는 무시하고 IPv4 주소 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d89ac89f76f16a68a863b0d9f578ffd1a558d6b0" translate="yes" xml:space="preserve">
          <source>Use IPv6 addresses only, ignoring IPv4 addresses.</source>
          <target state="translated">IPv4 주소는 무시하고 IPv6 주소 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="23206ddfb8d01b68973d7bd9cccf799f208e3657" translate="yes" xml:space="preserve">
          <source>Use Message &amp;rarr; Insert file&amp;hellip;​ and insert the patch.</source>
          <target state="translated">메시지 &amp;rarr; 파일 삽입&amp;hellip;을 사용하고 패치를 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="1b7e380bb9ef947a64359e01f17ce54cd3bdece1" translate="yes" xml:space="preserve">
          <source>Use One Mark Per Commit</source>
          <target state="translated">커밋 당 하나의 마크 사용</target>
        </trans-unit>
        <trans-unit id="c24268aab2b43d4e294643c8fbcbd60d377e139b" translate="yes" xml:space="preserve">
          <source>Use POSIX extended/basic regexp for patterns. Default is to use basic regexp.</source>
          <target state="translated">패턴에 POSIX 확장 / 기본 정규식을 사용하십시오. 기본은 기본 정규 표현식을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="36e96e4a2fd002679f3b794b4968539810c5c2eb" translate="yes" xml:space="preserve">
          <source>Use Perl-compatible regular expressions for patterns.</source>
          <target state="translated">패턴에 Perl 호환 정규식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fd46ce4ee0de88bb1a4ebb0e0c6375d24c2fb065" translate="yes" xml:space="preserve">
          <source>Use SO_REUSEADDR when binding the listening socket. This allows the server to restart without waiting for old connections to time out.</source>
          <target state="translated">청취 소켓을 바인딩 할 때 SO_REUSEADDR을 사용하십시오. 따라서 이전 연결 시간이 초과 될 때까지 기다리지 않고 서버를 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f351ffbdfc957393f82f6653e37778e19987b350" translate="yes" xml:space="preserve">
          <source>Use Tag Fixup Branches</source>
          <target state="translated">태그 수정 지점 사용</target>
        </trans-unit>
        <trans-unit id="41019858ddf6bd113a2b54361af9c75b6d741367" translate="yes" xml:space="preserve">
          <source>Use \0 as the delimiter for pathnames in the output, and print them verbatim. Without this option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable core.quotePath (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">출력에서 경로 이름에 대한 구분 기호로 \ 0을 사용하고 그대로 인쇄합니다. 이 옵션이 없으면 &quot;비정상적인&quot;문자가있는 경로 이름은 구성 변수 core.quotePath에 대해 설명 된대로 인용됩니다 (참조 :&lt;a href=&quot;git-config&quot;&gt; git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="67640e675158aa473b8a69cc0cdb46fb8ed7283f" translate="yes" xml:space="preserve">
          <source>Use a &quot;stable&quot; sum of hashes as the patch ID. With this option:</source>
          <target state="translated">패치 ID로 &quot;안정한&quot;해시 합계를 사용하십시오. 이 옵션을 사용하면</target>
        </trans-unit>
        <trans-unit id="0ec5feaf620cc0230519584645c952a1ae99d83c" translate="yes" xml:space="preserve">
          <source>Use a client spec to find the list of interesting files in p4. See the &quot;CLIENT SPEC&quot; section below.</source>
          <target state="translated">클라이언트 사양을 사용하여 p4에서 흥미로운 파일 목록을 찾으십시오. 아래의 &quot;CLIENT SPEC&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cf410607b4d646fae6b37dffcb3f37fcc481f52b" translate="yes" xml:space="preserve">
          <source>Use a mergetool. &lt;code&gt;git mergetool&lt;/code&gt; to launch a graphical mergetool which will work you through the merge.</source>
          <target state="translated">mergetool을 사용하십시오. &lt;code&gt;git mergetool&lt;/code&gt; 을 사용하면 병합을 통해 그래픽 병합 도구를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7589df3d820308df2c8a838829de10cfbcf2077" translate="yes" xml:space="preserve">
          <source>Use a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a &lt;code&gt;+&lt;/code&gt;/&lt;code&gt;-&lt;/code&gt;/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde &lt;code&gt;~&lt;/code&gt; on a line of its own.</source>
          <target state="translated">스크립트 사용을 위해 특수한 라인 기반 형식을 사용하십시오. 추가 / 제거 / 변경되지 않은 런은 줄의 시작 부분에 &lt;code&gt;+&lt;/code&gt; / &lt;code&gt;-&lt;/code&gt; /``문자로 시작하여 줄 끝까지 확장되는 일반적인 통합 diff 형식으로 인쇄됩니다 . 입력 의 줄 바꿈은 자체 줄에 물결표 ( &lt;code&gt;~&lt;/code&gt; ) 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="77b024aefcbc37a1627539595d18a928f0842816" translate="yes" xml:space="preserve">
          <source>Use a tarball as a starting point for a new repository.</source>
          <target state="translated">tarball을 새 저장소의 시작점으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="afac3b09febbe243aa11caf12f594c7284e7bf23" translate="yes" xml:space="preserve">
          <source>Use an &quot;unstable&quot; hash as the patch ID. With this option, the result produced is compatible with the patch-id value produced by git 1.9 and older. Users with pre-existing databases storing patch-ids produced by git 1.9 and older (who do not deal with reordered patches) may want to use this option.</source>
          <target state="translated">&quot;불안정한&quot;해시를 패치 ID로 사용하십시오. 이 옵션을 사용하면 생성 된 결과가 git 1.9 이상에서 생성 된 patch-id 값과 호환됩니다. git 1.9 이상에서 생성 된 패치 ID를 저장하는 기존 데이터베이스를 가진 사용자 (재주문 된 패치를 처리하지 않는)는이 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef4088fc09156b38070cb26da8281dc7bfd8c504" translate="yes" xml:space="preserve">
          <source>Use an atomic transaction for updating the refs. If any of the refs fails to update then the entire push will fail without changing any refs.</source>
          <target state="translated">심판을 업데이트하기 위해 원 자성 트랜잭션을 사용하십시오. 심판이 업데이트에 실패하면 심판을 변경하지 않고 전체 푸시가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="049c3e05f1b188c69413c7549059c67376f76ed1" translate="yes" xml:space="preserve">
          <source>Use an atomic transaction on the remote side if available. Either all refs are updated, or on error, no refs are updated. If the server does not support atomic pushes the push will fail.</source>
          <target state="translated">가능한 경우 원격 측에서 원자 트랜잭션을 사용하십시오. 모든 심판이 업데이트되거나 오류가 발생하면 심판이 업데이트되지 않습니다. 서버가 원자 푸시를 지원하지 않으면 푸시가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="402b0ecf5212c8d413a7923b4b251cf4b803a260" translate="yes" xml:space="preserve">
          <source>Use applying strategies to rebase (calling &lt;code&gt;git-am&lt;/code&gt; internally). This option may become a no-op in the future once the merge backend handles everything the apply one does.</source>
          <target state="translated">전략을 적용하여 리베이스 (호출 &lt;code&gt;git-am&lt;/code&gt; 내부적으로 git-am ). 이 옵션은 병합 백엔드가 적용되는 모든 작업을 처리하면 나중에 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e55fb404106de44576d9bc731a7fb4baf9a6337c" translate="yes" xml:space="preserve">
          <source>Use binary search to find the commit that introduced a bug</source>
          <target state="translated">이진 검색을 사용하여 버그가 발생한 커밋 찾기</target>
        </trans-unit>
        <trans-unit id="78ee9b127501691d305b39cc3fc13fc74a1d22a1" translate="yes" xml:space="preserve">
          <source>Use customized color for &lt;code&gt;git add --interactive&lt;/code&gt; and &lt;code&gt;git clean --interactive&lt;/code&gt; output. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; may be &lt;code&gt;prompt&lt;/code&gt;, &lt;code&gt;header&lt;/code&gt;, &lt;code&gt;help&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;, for four distinct types of normal output from interactive commands.</source>
          <target state="translated">&lt;code&gt;git add --interactive&lt;/code&gt; 및 &lt;code&gt;git clean --interactive&lt;/code&gt; 출력에 사용자 정의 색상을 사용하십시오 . &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 은 대화식 명령의 네 가지 고유 한 유형의 일반 출력에 대해 &lt;code&gt;prompt&lt;/code&gt; , &lt;code&gt;header&lt;/code&gt; , &lt;code&gt;help&lt;/code&gt; 또는 &lt;code&gt;error&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf3aeb7f00c3d69ade01b5cc321078d4f50948ae" translate="yes" xml:space="preserve">
          <source>Use customized color for &lt;code&gt;git log --decorate&lt;/code&gt; output. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;branch&lt;/code&gt;, &lt;code&gt;remoteBranch&lt;/code&gt;, &lt;code&gt;tag&lt;/code&gt;, &lt;code&gt;stash&lt;/code&gt; or &lt;code&gt;HEAD&lt;/code&gt; for local branches, remote-tracking branches, tags, stash and HEAD, respectively and &lt;code&gt;grafted&lt;/code&gt; for grafted commits.</source>
          <target state="translated">&lt;code&gt;git log --decorate&lt;/code&gt; 출력에 사용자 정의 색상을 사용하십시오 . &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 중 하나 &lt;code&gt;branch&lt;/code&gt; , &lt;code&gt;remoteBranch&lt;/code&gt; , &lt;code&gt;tag&lt;/code&gt; , &lt;code&gt;stash&lt;/code&gt; 또는 &lt;code&gt;HEAD&lt;/code&gt; 분기 태그 숨기고 HEAD 각각 원격 추적 로컬 브랜치에 대한 &lt;code&gt;grafted&lt;/code&gt; 그래프트 커밋한다.</target>
        </trans-unit>
        <trans-unit id="29ecef38edab0e1998d46583be9558cf2a562eff" translate="yes" xml:space="preserve">
          <source>Use customized color for branch coloration. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;current&lt;/code&gt; (the current branch), &lt;code&gt;local&lt;/code&gt; (a local branch), &lt;code&gt;remote&lt;/code&gt; (a remote-tracking branch in refs/remotes/), &lt;code&gt;upstream&lt;/code&gt; (upstream tracking branch), &lt;code&gt;plain&lt;/code&gt; (other refs).</source>
          <target state="translated">브랜치 착색에 사용자 정의 색상을 사용하십시오. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 은 &lt;code&gt;current&lt;/code&gt; (현재 분기), &lt;code&gt;local&lt;/code&gt; (로컬 분기), &lt;code&gt;remote&lt;/code&gt; (참조 / 원격 /의 원격 추적 분기), &lt;code&gt;upstream&lt;/code&gt; (업스트림 추적 분기), &lt;code&gt;plain&lt;/code&gt; (기타 참조) 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="fcdeebdb47ef8466da45d806c0dccf091f4447a0" translate="yes" xml:space="preserve">
          <source>Use customized color for diff colorization. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; specifies which part of the patch to use the specified color, and is one of &lt;code&gt;context&lt;/code&gt; (context text - &lt;code&gt;plain&lt;/code&gt; is a historical synonym), &lt;code&gt;meta&lt;/code&gt; (metainformation), &lt;code&gt;frag&lt;/code&gt; (hunk header), &lt;code&gt;func&lt;/code&gt; (function in hunk header), &lt;code&gt;old&lt;/code&gt; (removed lines), &lt;code&gt;new&lt;/code&gt; (added lines), &lt;code&gt;commit&lt;/code&gt; (commit headers), &lt;code&gt;whitespace&lt;/code&gt; (highlighting whitespace errors), &lt;code&gt;oldMoved&lt;/code&gt; (deleted lines), &lt;code&gt;newMoved&lt;/code&gt; (added lines), &lt;code&gt;oldMovedDimmed&lt;/code&gt;, &lt;code&gt;oldMovedAlternative&lt;/code&gt;, &lt;code&gt;oldMovedAlternativeDimmed&lt;/code&gt;, &lt;code&gt;newMovedDimmed&lt;/code&gt;, &lt;code&gt;newMovedAlternative&lt;/code&gt;&lt;code&gt;newMovedAlternativeDimmed&lt;/code&gt; (See the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; setting of &lt;code&gt;--color-moved&lt;/code&gt; in &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; for details), &lt;code&gt;contextDimmed&lt;/code&gt;, &lt;code&gt;oldDimmed&lt;/code&gt;, &lt;code&gt;newDimmed&lt;/code&gt;, &lt;code&gt;contextBold&lt;/code&gt;, &lt;code&gt;oldBold&lt;/code&gt;, and &lt;code&gt;newBold&lt;/code&gt; (see &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff[1]&lt;/a&gt; for details).</source>
          <target state="translated">diff 착색을 위해 맞춤형 색상을 사용하십시오. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 은 패치에서 지정된 색상을 사용할 부분을 지정하며 &lt;code&gt;context&lt;/code&gt; (컨텍스트 텍스트- &lt;code&gt;plain&lt;/code&gt; 은 역사적 동의어 임), &lt;code&gt;meta&lt;/code&gt; (제조), &lt;code&gt;frag&lt;/code&gt; (행크 헤더), &lt;code&gt;func&lt;/code&gt; (행크 헤더의 함수) 중 하나입니다. &lt;code&gt;old&lt;/code&gt; (제거 된 줄), &lt;code&gt;new&lt;/code&gt; (추가 된 줄), &lt;code&gt;commit&lt;/code&gt; (커밋 헤더), &lt;code&gt;whitespace&lt;/code&gt; (공백 공백 오류), &lt;code&gt;oldMoved&lt;/code&gt; (삭제 된 줄), &lt;code&gt;newMoved&lt;/code&gt; (추가 된 줄), &lt;code&gt;oldMovedDimmed&lt;/code&gt; , &lt;code&gt;oldMovedAlternative&lt;/code&gt; , &lt;code&gt;oldMovedAlternativeDimmed&lt;/code&gt; , &lt;code&gt;newMovedDimmed&lt;/code&gt; , &lt;code&gt;newMovedAlternative&lt;/code&gt; &lt;code&gt;newMovedAlternativeDimmed&lt;/code&gt; (자세한 내용은 &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 에서 &lt;code&gt;--color-moved&lt;/code&gt; 의 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 설정 참조), &lt;code&gt;contextDimmed&lt;/code&gt; , &lt;code&gt;oldDimmed&lt;/code&gt; , &lt;code&gt;newDimmed&lt;/code&gt; , &lt;code&gt;contextBold&lt;/code&gt; , &lt;code&gt;oldBold&lt;/code&gt; 및 &lt;code&gt;newBold&lt;/code&gt; ( &lt;a href=&quot;git-range-diff&quot;&gt;git-range&lt;/a&gt; 참조 ) 1] 자세한 내용을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="799532fe06b09693cab5782f0c7b74d1305d2cb1" translate="yes" xml:space="preserve">
          <source>Use customized color for each remote keyword. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; may be &lt;code&gt;hint&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, &lt;code&gt;success&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt; which match the corresponding keyword.</source>
          <target state="translated">각 원격 키워드에 맞춤 색상을 사용하십시오. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 은 해당 키워드와 일치하는 &lt;code&gt;hint&lt;/code&gt; , &lt;code&gt;warning&lt;/code&gt; , &lt;code&gt;success&lt;/code&gt; 또는 &lt;code&gt;error&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8363e3bb3b19269f1bec63465f050d08c7400a8" translate="yes" xml:space="preserve">
          <source>Use customized color for grep colorization. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; specifies which part of the line to use the specified color, and is one of</source>
          <target state="translated">grep 착색을 위해 사용자 정의 색상을 사용하십시오. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 은 지정된 색상을 사용할 줄 부분을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="3d940f7a54cc13b6b8a420b163ce2b7e4ccedf38" translate="yes" xml:space="preserve">
          <source>Use customized color for hints.</source>
          <target state="translated">힌트에 사용자 정의 색상을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a7bc0186c1d40a59aee910eedb6524484cbce3a0" translate="yes" xml:space="preserve">
          <source>Use customized color for push errors.</source>
          <target state="translated">푸시 오류에는 사용자 정의 색상을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="efd1e4b094e6a540e69b42772ae161651f4648a2" translate="yes" xml:space="preserve">
          <source>Use customized color for status colorization. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;header&lt;/code&gt; (the header text of the status message), &lt;code&gt;added&lt;/code&gt; or &lt;code&gt;updated&lt;/code&gt; (files which are added but not committed), &lt;code&gt;changed&lt;/code&gt; (files which are changed but not added in the index), &lt;code&gt;untracked&lt;/code&gt; (files which are not tracked by Git), &lt;code&gt;branch&lt;/code&gt; (the current branch), &lt;code&gt;nobranch&lt;/code&gt; (the color the &lt;code&gt;no branch&lt;/code&gt; warning is shown in, defaulting to red), &lt;code&gt;localBranch&lt;/code&gt; or &lt;code&gt;remoteBranch&lt;/code&gt; (the local and remote branch names, respectively, when branch and tracking information is displayed in the status short-format), or &lt;code&gt;unmerged&lt;/code&gt; (files which have unmerged changes).</source>
          <target state="translated">상태 색상 지정에 사용자 정의 색상을 사용하십시오. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 은 &lt;code&gt;header&lt;/code&gt; (상태 메시지의 헤더 텍스트), &lt;code&gt;added&lt;/code&gt; 또는 &lt;code&gt;updated&lt;/code&gt; (추가되었지만 커밋되지 않은 파일 ), &lt;code&gt;changed&lt;/code&gt; (인덱스에서 변경되었지만 추가되지 않은 파일 ), &lt;code&gt;untracked&lt;/code&gt; 되지 않은 파일 중 하나입니다. 힘내)에 의해 추적 &lt;code&gt;branch&lt;/code&gt; (현 지사) &lt;code&gt;nobranch&lt;/code&gt; (상기 컬러 &lt;code&gt;no branch&lt;/code&gt; 경고에 도시되며, 적색에 디폴트) &lt;code&gt;localBranch&lt;/code&gt; 또는 &lt;code&gt;remoteBranch&lt;/code&gt; 분기 및 추적 정보가 표시된다 (각각의 로컬 및 원격 지점 이름, 상태 짧은 형식) 또는 &lt;code&gt;unmerged&lt;/code&gt; (변경되지 않은 변경 사항이있는 파일).</target>
        </trans-unit>
        <trans-unit id="42006ecfd08deb9b3ff0a3f1d7240d8f715710f3" translate="yes" xml:space="preserve">
          <source>Use customized color when a push was rejected.</source>
          <target state="translated">푸시가 거부되면 사용자 정의 색상을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7714f2243f3ecb7a0c915a75f0d9677bee5cfddf" translate="yes" xml:space="preserve">
          <source>Use fixed strings for patterns (don&amp;rsquo;t interpret pattern as a regex).</source>
          <target state="translated">패턴에 고정 문자열을 사용하십시오 (패턴을 정규식으로 해석하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="be83392780575c9c0f338875e4ab41fca7ad0580" translate="yes" xml:space="preserve">
          <source>Use given directory for the location of Git objects. We check &lt;code&gt;&amp;lt;dir&amp;gt;/packs/multi-pack-index&lt;/code&gt; for the current MIDX file, and &lt;code&gt;&amp;lt;dir&amp;gt;/packs&lt;/code&gt; for the pack-files to index.</source>
          <target state="translated">Git 객체의 위치에 지정된 디렉토리를 사용하십시오. 우리는 확인 &lt;code&gt;&amp;lt;dir&amp;gt;/packs/multi-pack-index&lt;/code&gt; 현재 MIDX 파일 및 &lt;code&gt;&amp;lt;dir&amp;gt;/packs&lt;/code&gt; 인덱스 팩 - 파일.</target>
        </trans-unit>
        <trans-unit id="58e0e6d68f2b1086e2f61cc3ccf9bb473fce2cb1" translate="yes" xml:space="preserve">
          <source>Use given directory for the location of packfiles and commit-graph file. This parameter exists to specify the location of an alternate that only has the objects directory, not a full &lt;code&gt;.git&lt;/code&gt; directory. The commit-graph file is expected to be in the &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; directory and the packfiles are expected to be in &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt;.</source>
          <target state="translated">packfile 및 commit-graph 파일의 위치에 지정된 디렉토리를 사용하십시오. 이 매개 변수는 전체 &lt;code&gt;.git&lt;/code&gt; 디렉토리가 아닌 objects 디렉토리 만있는 대체의 위치를 ​​지정하기 위해 존재합니다 . 커밋 그래프 파일은 &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; 디렉토리에 있고 packfiles는 &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt; 에 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="034b8d3eb2bf376cba5a544572cc51a019ffd1af" translate="yes" xml:space="preserve">
          <source>Use given directory for the location of packfiles and commit-graph file. This parameter exists to specify the location of an alternate that only has the objects directory, not a full &lt;code&gt;.git&lt;/code&gt; directory. The commit-graph file is expected to be in the &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; directory and the packfiles are expected to be in &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt;. If the directory could not be made into an absolute path, or does not match any known object directory, &lt;code&gt;git commit-graph ...&lt;/code&gt; will exit with non-zero status.</source>
          <target state="translated">packfiles 및 commit-graph 파일의 위치에 지정된 디렉토리를 사용하십시오. 이 매개 변수는 전체 &lt;code&gt;.git&lt;/code&gt; 디렉토리가 아닌 objects 디렉토리 만있는 대체 위치를 지정하기 위해 존재합니다 . commit-graph 파일은 &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; 디렉토리에 있고 packfile은 &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt; 에 있어야 합니다. 디렉터리를 절대 경로로 만들 수 없거나 알려진 개체 디렉터리와 일치하지 않는 경우 &lt;code&gt;git commit-graph ...&lt;/code&gt; 는 0이 아닌 상태로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="9e22ac3ec044552fceb6f971a8409c3fc735d918" translate="yes" xml:space="preserve">
          <source>Use gmail as the smtp server</source>
          <target state="translated">Gmail을 SMTP 서버로 사용</target>
        </trans-unit>
        <trans-unit id="243e0ec42451f8d223cf0a086b6e0d020fe017bc" translate="yes" xml:space="preserve">
          <source>Use hash &lt;code&gt;#&lt;/code&gt; for comments that are either on their own line, or after the email address.</source>
          <target state="translated">자체 줄에 있거나 전자 메일 주소 뒤에있는 주석 에는 해시 &lt;code&gt;#&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe4290ca9cf2dcf165b3911c20fcc8115cf36b09" translate="yes" xml:space="preserve">
          <source>Use libcurl to communicate with the IMAP server, unless tunneling into it. Ignored if Git was built without the USE_CURL_FOR_IMAP_SEND option set.</source>
          <target state="translated">터널링하지 않는 한 libcurl을 사용하여 IMAP 서버와 통신하십시오. USE_CURL_FOR_IMAP_SEND 옵션을 설정하지 않고 Git을 빌드 한 경우 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b43e2a7c9e04ff83908291bc454ceb95c66f26d2" translate="yes" xml:space="preserve">
          <source>Use mailmap file to map author and committer names and email addresses to canonical real names and email addresses. See &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt;.</source>
          <target state="translated">메일 맵 파일을 사용하여 작성자 및 커미터 이름 및 이메일 주소를 표준 실제 이름 및 이메일 주소에 맵핑하십시오. &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="869311b9e64386ec94c4224dbda98ca212bcb863" translate="yes" xml:space="preserve">
          <source>Use merging strategies to rebase. When the recursive (default) merge strategy is used, this allows rebase to be aware of renames on the upstream side.</source>
          <target state="translated">합병 전략을 사용하여 리베이스하십시오. 재귀 (기본) 병합 전략을 사용하면 업스트림 측에서 이름을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07cf71eed9a3b36f45bcc6fde8a3af9707bd0146" translate="yes" xml:space="preserve">
          <source>Use merging strategies to rebase. When the recursive (default) merge strategy is used, this allows rebase to be aware of renames on the upstream side. This is the default.</source>
          <target state="translated">병합 전략을 사용하여 리베이스하십시오. 재귀 적 (기본) 병합 전략을 사용하면 리베이스가 업스트림 측의 이름 변경을 인식 할 수 있습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="504dd078aaf1ec972f6af826bbe142e1450759fa" translate="yes" xml:space="preserve">
          <source>Use of &quot;topic branches&quot; solves these problems. The name is pretty self explanatory, with a caveat that comes from the &quot;merge upwards&quot; rule above:</source>
          <target state="translated">&quot;주제 분기&quot;를 사용하면 이러한 문제가 해결됩니다. 이름은 위의 &quot;위로 병합&quot;규칙에서 비롯된 경고와 함께 매우 자명 한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="2997460999cadfc1fcc5d52315d53b3d5efcd07d" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;dcommit&lt;/code&gt; is preferred to &lt;code&gt;set-tree&lt;/code&gt; (below).</source>
          <target state="translated">&lt;code&gt;set-tree&lt;/code&gt; (아래) 보다 &lt;code&gt;dcommit&lt;/code&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6b08c4843a60fcea417d6fa6b7562621b3124054" translate="yes" xml:space="preserve">
          <source>Use of this utility is encouraged in favor of directly accessing files under the &lt;code&gt;.git&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;.git&lt;/code&gt; 디렉토리 에있는 파일에 직접 액세스하기 위해이 유틸리티를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="3a96544176d9c64bcdfe76616987380a83e4f896" translate="yes" xml:space="preserve">
          <source>Use permissions reported by umask(2). The default, when &lt;code&gt;--shared&lt;/code&gt; is not specified.</source>
          <target state="translated">umask (2)에 의해보고 된 권한을 사용하십시오. &lt;code&gt;--shared&lt;/code&gt; 가 지정되지 않은 경우 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="7b2e5a64a2bb1a5fbe6304abee401e1d3f35a8f4" translate="yes" xml:space="preserve">
          <source>Use reflog to find a better common ancestor between &amp;lt;upstream&amp;gt; and &amp;lt;branch&amp;gt; when calculating which commits have been introduced by &amp;lt;branch&amp;gt;.</source>
          <target state="translated">&amp;lt;branch&amp;gt;에 의해 어떤 커밋이 도입되었는지 계산할 때 reflog를 사용하여 &amp;lt;upstream&amp;gt;과 &amp;lt;branch&amp;gt; 사이에 더 나은 공통 조상을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="b40e39ff3f77007104d997879dd735023a9dca06" translate="yes" xml:space="preserve">
          <source>Use revisions from revs-file instead of calling &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt; 을 호출하는 대신 revs-file의 개정판을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="efb298546ca010c6e357a2c3cc79d1b86fb2f356" translate="yes" xml:space="preserve">
          <source>Use the &quot;sparse&quot; algorithm to determine which objects to include in the pack, when combined with the &quot;--revs&quot; option. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames.</source>
          <target state="translated">&quot;--pars&quot;옵션과 결합 될 때 팩에 포함 할 오브젝트를 결정하려면 &quot;스파 스&quot;알고리즘을 사용하십시오. 이 알고리즘은 새로운 객체를 도입하는 경로에 나타나는 트리 만 걷는다. 이것은 작은 변화를 보내기 위해 팩을 계산할 때 상당한 성능 이점을 가질 수 있습니다. 그러나 포함 된 커밋에 특정 유형의 직접 이름 바꾸기가 포함되어 있으면 추가 객체가 팩 파일에 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0755f10a2fd51824d1737b45b49a4642d66873f8" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--in-place&lt;/code&gt; option to edit a message file in place:</source>
          <target state="translated">&lt;code&gt;--in-place&lt;/code&gt; 옵션을 사용하여 메시지 파일을 적절 하게 편집하십시오.</target>
        </trans-unit>
        <trans-unit id="55e7e1126d3aa0a5c8bf2360dfcd495bb1107882" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute only if you cannot store a file in UTF-8 encoding and if you want Git to be able to process the content as text.</source>
          <target state="translated">사용 &lt;code&gt;working-tree-encoding&lt;/code&gt; 이 UTF-8 인코딩으로 파일을 저장할 수없는 경우에만 속성을 원하는 경우 힘내 텍스트로 내용을 처리 할 수 있도록.</target>
        </trans-unit>
        <trans-unit id="b5ec705c3f1e9d70bd95302efbf5732684172042" translate="yes" xml:space="preserve">
          <source>Use the branch detection algorithm to find new paths in p4. It is documented below in &quot;BRANCH DETECTION&quot;.</source>
          <target state="translated">p4에서 새 경로를 찾으려면 분기 감지 알고리즘을 사용하십시오. 아래의 &quot;브랜치 감지&quot;에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="33ac56041ae34da6b3682a94d8a665913a47636a" translate="yes" xml:space="preserve">
          <source>Use the credential (e.g., access the URL with the username and password from step (2)), and see if it&amp;rsquo;s accepted.</source>
          <target state="translated">자격 증명을 사용합니다 (예 : 2 단계의 사용자 이름과 비밀번호로 URL에 액세스).</target>
        </trans-unit>
        <trans-unit id="4cfefdd524d37cf0c1fedc168c903048fc636bbd" translate="yes" xml:space="preserve">
          <source>Use the customized color for the part of git-blame output that is repeated meta information per line (such as commit id, author name, date and timezone). Defaults to cyan.</source>
          <target state="translated">커밋 ID, 작성자 이름, 날짜 및 시간대와 같이 줄당 메타 정보가 반복되는 git-blame 출력 부분에 사용자 정의 된 색상을 사용하십시오. 기본적으로 청록색입니다.</target>
        </trans-unit>
        <trans-unit id="a024bae6c0f6ae8fa68e77c95e0c4f95100aa970" translate="yes" xml:space="preserve">
          <source>Use the diff tool specified by &amp;lt;tool&amp;gt;. Valid values include emerge, kompare, meld, and vimdiff. Run &lt;code&gt;git difftool --tool-help&lt;/code&gt; for the list of valid &amp;lt;tool&amp;gt; settings.</source>
          <target state="translated">&amp;lt;tool&amp;gt;에 지정된 diff 도구를 사용하십시오. 유효한 값은 emerge, kompare, meld 및 vimdiff입니다. 유효한 &amp;lt;tool&amp;gt; 설정 목록을 보려면 &lt;code&gt;git difftool --tool-help&lt;/code&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="161588bc8b76efbad18d428ccf6e2f5e459908d1" translate="yes" xml:space="preserve">
          <source>Use the fast patchset import strategy. This can be significantly faster for large trees, but cannot handle directory renames or permissions changes. The default strategy is slow and safe.</source>
          <target state="translated">빠른 패치 세트 가져 오기 전략을 사용하십시오. 이는 큰 트리의 경우 훨씬 빠를 수 있지만 디렉토리 이름 변경 또는 권한 변경은 처리 할 수 ​​없습니다. 기본 전략은 느리고 안전합니다.</target>
        </trans-unit>
        <trans-unit id="89541b63bc820ad5c76ea37101a62452ee62e61c" translate="yes" xml:space="preserve">
          <source>Use the following attributes if your &lt;code&gt;*.ps1&lt;/code&gt; files are UTF-16 little endian encoded without BOM and you want Git to use Windows line endings in the working directory (use &lt;code&gt;UTF-16LE-BOM&lt;/code&gt; instead of &lt;code&gt;UTF-16LE&lt;/code&gt; if you want UTF-16 little endian with BOM). Please note, it is highly recommended to explicitly define the line endings with &lt;code&gt;eol&lt;/code&gt; if the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute is used to avoid ambiguity.</source>
          <target state="translated">귀하의 경우 다음과 같은 속성을 사용하여 &lt;code&gt;*.ps1&lt;/code&gt; 입니다 (사용 파일이 BOM없이 인코딩 UTF-16 리틀 엔디안이고, 당신이 망할 놈의 작업 디렉토리에서 윈도우 라인 엔딩을 사용하려면 &lt;code&gt;UTF-16LE-BOM&lt;/code&gt; 대신 &lt;code&gt;UTF-16LE&lt;/code&gt; 을 당신은 UTF-16를 원하는 경우 BOM이있는 리틀 엔디 언). &lt;code&gt;working-tree-encoding&lt;/code&gt; 속성을 사용하여 모호성을 피하는 경우 &lt;code&gt;eol&lt;/code&gt; 로 줄 끝을 명시 적으로 정의하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e5c2f58b6a6ebc713504e60181f4f0dd37da2d6d" translate="yes" xml:space="preserve">
          <source>Use the given &amp;lt;msg&amp;gt; as the commit message. If multiple &lt;code&gt;-m&lt;/code&gt; options are given, their values are concatenated as separate paragraphs.</source>
          <target state="translated">주어진 &amp;lt;msg&amp;gt;를 커밋 메시지로 사용하십시오. 여러 개의 &lt;code&gt;-m&lt;/code&gt; 옵션이 제공되면 해당 값은 별도의 단락으로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="be3b9715415e0357d3d87d01aa8f812c871fb1e1" translate="yes" xml:space="preserve">
          <source>Use the given &lt;code&gt;msg&lt;/code&gt; as the commit message. This option disables the &lt;code&gt;--edit&lt;/code&gt; option.</source>
          <target state="translated">주어진 &lt;code&gt;msg&lt;/code&gt; 를 커밋 메시지로 사용하십시오 . 이 옵션은 &lt;code&gt;--edit&lt;/code&gt; 옵션을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="43103d879018fa15a44cefa9b3baec705e25165c" translate="yes" xml:space="preserve">
          <source>Use the given config file instead of the one specified by GIT_CONFIG.</source>
          <target state="translated">GIT_CONFIG가 지정한 설정 파일 대신 지정된 설정 파일을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6d07104b51b424f44cb0346a9ac8f4116b0f06d7" translate="yes" xml:space="preserve">
          <source>Use the given exclude pattern in addition to the standard ignore rules (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;).</source>
          <target state="translated">표준 무시 규칙 외에도 주어진 제외 패턴을 사용하십시오 ( &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9a12bbd112f0b48f03fdbbbb0b9c68268bedd960" translate="yes" xml:space="preserve">
          <source>Use the given merge strategy. If there is no &lt;code&gt;-s&lt;/code&gt; option &lt;code&gt;git merge-recursive&lt;/code&gt; is used instead. This implies --merge.</source>
          <target state="translated">주어진 병합 전략을 사용하십시오. &lt;code&gt;-s&lt;/code&gt; 옵션 이 없으면 &lt;code&gt;git merge-recursive&lt;/code&gt; 가 대신 사용됩니다. 이것은 --merge를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="aad779cdebc63bc4b25eb19e46a7b214101b70ea" translate="yes" xml:space="preserve">
          <source>Use the given merge strategy. Should only be used once. See the MERGE STRATEGIES section in &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; for details.</source>
          <target state="translated">주어진 병합 전략을 사용하십시오. 한 번만 사용해야합니다. 자세한 내용은 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt; 의 MERGE STRATEGIES 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0d697cccd6049781089822f14d706ae91b43a781" translate="yes" xml:space="preserve">
          <source>Use the given merge strategy; can be supplied more than once to specify them in the order they should be tried. If there is no &lt;code&gt;-s&lt;/code&gt; option, a built-in list of strategies is used instead (&lt;code&gt;git merge-recursive&lt;/code&gt; when merging a single head, &lt;code&gt;git merge-octopus&lt;/code&gt; otherwise).</source>
          <target state="translated">주어진 병합 전략을 사용하십시오. 시도해야하는 순서대로 지정하기 위해 두 번 이상 제공 될 수 있습니다. &lt;code&gt;-s&lt;/code&gt; 옵션 이없는 경우 기본 제공 전략 목록이 대신 사용됩니다 ( 단일 헤드를 병합 할 때는 &lt;code&gt;git merge-recursive&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;git merge-octopus&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e15a6801b533c61848133f0481a1499ec359e784" translate="yes" xml:space="preserve">
          <source>Use the given note message (instead of prompting). If multiple &lt;code&gt;-m&lt;/code&gt; options are given, their values are concatenated as separate paragraphs. Lines starting with &lt;code&gt;#&lt;/code&gt; and empty lines other than a single line between paragraphs will be stripped out.</source>
          <target state="translated">프롬프트 대신 지정된 메모 메시지를 사용하십시오. 여러 개의 &lt;code&gt;-m&lt;/code&gt; 옵션이 제공되면 해당 값은 별도의 단락으로 연결됩니다. &lt;code&gt;#&lt;/code&gt; 으로 시작하고 단락 사이의 한 줄 이외의 빈 줄은 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="2301e57be484e5bf3374c6061960726be52acd3f" translate="yes" xml:space="preserve">
          <source>Use the given tag message (instead of prompting). If multiple &lt;code&gt;-m&lt;/code&gt; options are given, their values are concatenated as separate paragraphs. Implies &lt;code&gt;-a&lt;/code&gt; if none of &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, or &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; is given.</source>
          <target state="translated">프롬프트 대신 지정된 태그 메시지를 사용하십시오. 여러 개의 &lt;code&gt;-m&lt;/code&gt; 옵션이 제공되면 해당 값은 별도의 단락으로 연결됩니다. &lt;code&gt;-a&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; 또는 &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; 가 없으면 &lt;code&gt;-a&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="52a6c166f490dbb0be0d25b65f46015f7e67e623" translate="yes" xml:space="preserve">
          <source>Use the interactive patch selection interface to chose which changes to commit. See &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; for details.</source>
          <target state="translated">대화식 패치 선택 인터페이스를 사용하여 커밋 할 변경 사항을 선택하십시오. 자세한 내용은 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7db128e87ada4e1ec3f3340d8431acfc429f3677" translate="yes" xml:space="preserve">
          <source>Use the merge resolution program specified by &amp;lt;tool&amp;gt;. Valid values include emerge, gvimdiff, kdiff3, meld, vimdiff, and tortoisemerge. Run &lt;code&gt;git mergetool --tool-help&lt;/code&gt; for the list of valid &amp;lt;tool&amp;gt; settings.</source>
          <target state="translated">&amp;lt;tool&amp;gt;에서 지정한 병합 해결 프로그램을 사용하십시오. 유효한 값은 emerge, gvimdiff, kdiff3, meld, vimdiff 및 tortoisemerge입니다. 유효한 &amp;lt;tool&amp;gt; 설정 목록을 보려면 &lt;code&gt;git mergetool --tool-help&lt;/code&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="047156e36b9d6e8b2155d32a029545b1b026f10e" translate="yes" xml:space="preserve">
          <source>Use the multi-pack-index file to track multiple packfiles using a single index. See &lt;a href=&quot;multi-pack-index&quot;&gt;the multi-pack-index design document&lt;/a&gt;.</source>
          <target state="translated">다중 팩 색인 파일을 사용하여 단일 색인을 사용하여 여러 팩 파일을 추적하십시오. &lt;a href=&quot;multi-pack-index&quot;&gt;다중 팩 인덱스 디자인 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f14443aa07cf034aa00129ee21b4f7df2be49255" translate="yes" xml:space="preserve">
          <source>Use the partial clone feature and request that the server sends a subset of reachable objects according to a given object filter. When using &lt;code&gt;--filter&lt;/code&gt;, the supplied &lt;code&gt;&amp;lt;filter-spec&amp;gt;&lt;/code&gt; is used for the partial clone filter. For example, &lt;code&gt;--filter=blob:none&lt;/code&gt; will filter out all blobs (file contents) until needed by Git. Also, &lt;code&gt;--filter=blob:limit=&amp;lt;size&amp;gt;&lt;/code&gt; will filter out all blobs of size at least &lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;. For more details on filter specifications, see the &lt;code&gt;--filter&lt;/code&gt; option in &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;.</source>
          <target state="translated">부분 복제 기능을 사용하고 서버가 주어진 개체 필터에 따라 도달 가능한 개체의 하위 집합을 보내도록 요청합니다. &lt;code&gt;--filter&lt;/code&gt; 를 사용할 때 제공된 &lt;code&gt;&amp;lt;filter-spec&amp;gt;&lt;/code&gt; 이 부분 복제 필터에 사용됩니다. 예를 들어 &lt;code&gt;--filter=blob:none&lt;/code&gt; 은 Git에서 필요할 때까지 모든 blob (파일 콘텐츠)을 필터링합니다. 또한 &lt;code&gt;--filter=blob:limit=&amp;lt;size&amp;gt;&lt;/code&gt; 적어도 크기의 모든 얼룩을 걸러 &lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt; . 필터 사양에 대한 자세한 내용은의 &lt;code&gt;--filter&lt;/code&gt; 옵션을 참조하십시오.&lt;a href=&quot;git-rev-list&quot;&gt; git-rev-list [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6bac5b4ccbcc396e691c8ba8f2af89d4f60c9270" translate="yes" xml:space="preserve">
          <source>Use the same output mode as &lt;a href=&quot;git-annotate&quot;&gt;git-annotate[1]&lt;/a&gt; (Default: off).</source>
          <target state="translated">&lt;a href=&quot;git-annotate&quot;&gt;git-annotate [1]&lt;/a&gt; 과 동일한 출력 모드를 사용하십시오 (기본값 : off).</target>
        </trans-unit>
        <trans-unit id="0ed67a2ecd3a9ee96ae4cd7dcb45f48a2cf84bf4" translate="yes" xml:space="preserve">
          <source>Use the selected commit message without launching an editor. For example, &lt;code&gt;git commit --amend --no-edit&lt;/code&gt; amends a commit without changing its commit message.</source>
          <target state="translated">편집기를 시작하지 않고 선택된 커밋 메시지를 사용하십시오. 예를 들어, &lt;code&gt;git commit --amend --no-edit&lt;/code&gt; 는 커밋 메시지를 변경하지 않고 커밋을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="8e65c034e7da87d64be153e02b39a8529bd16f67" translate="yes" xml:space="preserve">
          <source>Use the source ref that matches &lt;code&gt;master&lt;/code&gt; (e.g. &lt;code&gt;refs/heads/master&lt;/code&gt;) to update the ref that matches &lt;code&gt;satellite/master&lt;/code&gt; (most probably &lt;code&gt;refs/remotes/satellite/master&lt;/code&gt;) in the &lt;code&gt;mothership&lt;/code&gt; repository; do the same for &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;satellite/dev&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; 와 일치하는 소스 참조 (예 : &lt;code&gt;refs/heads/master&lt;/code&gt; )를 사용 하여 &lt;code&gt;mothership&lt;/code&gt; 저장소의 &lt;code&gt;satellite/master&lt;/code&gt; (대부분 &lt;code&gt;refs/remotes/satellite/master&lt;/code&gt; ) 와 일치하는 참조를 업데이트하십시오 . &lt;code&gt;dev&lt;/code&gt; 및 &lt;code&gt;satellite/dev&lt;/code&gt; 에 대해 동일한 작업을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="82b93c6560af27195da14e70510e2b3d8651c3b7" translate="yes" xml:space="preserve">
          <source>Use the specified HTTP protocol version when communicating with a server. If you want to force the default. The available and default version depend on libcurl. Actually the possible values of this option are:</source>
          <target state="translated">서버와 통신 할 때 지정된 HTTP 프로토콜 버전을 사용하십시오. 기본값을 적용하려는 경우. 사용 가능한 기본 버전은 libcurl에 따라 다릅니다. 실제로이 옵션의 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85fede53ff0add46d3665dfda925d3c1db752a7f" translate="yes" xml:space="preserve">
          <source>Use the specified HTTP protocol version when communicating with a server. If you want to force the default. The available and default version depend on libcurl. Currently the possible values of this option are:</source>
          <target state="translated">서버와 통신 할 때 지정된 HTTP 프로토콜 버전을 사용하십시오. 기본값을 강제하려는 경우. 사용 가능한 기본 버전은 libcurl에 따라 다릅니다. 현재이 옵션의 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="becfdaabcf538340d904ac918eb155dd5d16c802" translate="yes" xml:space="preserve">
          <source>Use the specified URL to connect to the destination Subversion repository. This is useful in cases where the source SVN repository is read-only. This option overrides configuration property &lt;code&gt;commiturl&lt;/code&gt;.</source>
          <target state="translated">지정된 URL을 사용하여 대상 Subversion 저장소에 연결하십시오. 소스 SVN 저장소가 읽기 전용 인 경우에 유용합니다. 이 옵션은 구성 특성 &lt;code&gt;commiturl&lt;/code&gt; 을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="eded6790141cbbb141d77bfcf5fc351397828538" translate="yes" xml:space="preserve">
          <source>Use the specified name for the initial branch in the newly created repository. If not specified, fall back to the default name: &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">새로 생성 된 저장소의 초기 브랜치에 지정된 이름을 사용합니다. 지정되지 않은 경우 기본 이름 인 &lt;code&gt;master&lt;/code&gt; 로 돌아가십시오 .</target>
        </trans-unit>
        <trans-unit id="9e057e9e47493412f91dea4102ac0984cb71bdeb" translate="yes" xml:space="preserve">
          <source>Use the value of the &lt;code&gt;core.whitespace&lt;/code&gt; configuration variable to decide what to notice as error.</source>
          <target state="translated">&lt;code&gt;core.whitespace&lt;/code&gt; 구성 변수 의 값을 사용하여 오류로 주목할 사항을 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="810f8c03feb9550dd6740190f543dbb37624e241" translate="yes" xml:space="preserve">
          <source>Use this custom program instead of &quot;&lt;code&gt;gpg&lt;/code&gt;&quot; found on &lt;code&gt;$PATH&lt;/code&gt; when making or verifying a PGP signature. The program must support the same command-line interface as GPG, namely, to verify a detached signature, &quot;&lt;code&gt;gpg --verify $signature - &amp;lt;$file&lt;/code&gt;&quot; is run, and the program is expected to signal a good signature by exiting with code 0, and to generate an ASCII-armored detached signature, the standard input of &quot;&lt;code&gt;gpg -bsau $key&lt;/code&gt;&quot; is fed with the contents to be signed, and the program is expected to send the result to its standard output.</source>
          <target state="translated">PGP 서명을 만들거나 확인할 때 &lt;code&gt;$PATH&lt;/code&gt; 에있는 &quot; &lt;code&gt;gpg&lt;/code&gt; &quot; 대신이 사용자 지정 프로그램을 사용하십시오 . 프로그램은 분리 된 서명 &quot; &lt;code&gt;gpg --verify $signature - &amp;lt;$file&lt;/code&gt; &quot;이 실행 되는지 확인하기 위해 GPG와 동일한 명령 행 인터페이스를 지원해야 하며 프로그램은 코드로 종료하여 올바른 서명을 신호해야합니다 0으로 ASCII-armored 분리 된 서명을 생성하기 위해 &quot; &lt;code&gt;gpg -bsau $key&lt;/code&gt; &quot; 의 표준 입력에 서명 할 내용이 제공되며 프로그램은 결과를 표준 출력으로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="a644dabd3c4c5e288aecaab3da05ddb8c7da086c" translate="yes" xml:space="preserve">
          <source>Use this for compatibility with old-style branch names used by earlier versions of &lt;code&gt;git archimport&lt;/code&gt;. Old-style branch names were category--branch, whereas new-style branch names are archive,category--branch--version. In both cases, names given on the command-line will override the automatically-generated ones.</source>
          <target state="translated">이전 버전의 &lt;code&gt;git archimport&lt;/code&gt; 에서 사용 된 이전 스타일 브랜치 이름과의 호환성을 위해 이것을 사용하십시오 . 이전 스타일 브랜치 이름은 카테고리-브랜치 인 반면 새 스타일 브랜치 이름은 아카이브, 카테고리-브랜치-버전입니다. 두 경우 모두 명령 줄에 지정된 이름이 자동으로 생성 된 이름보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="ad85fb495e355ea9ee99bf9caef60d6a5acc4df9" translate="yes" xml:space="preserve">
          <source>Use this for compatibility with old-style branch names used by earlier versions of &lt;code&gt;git archimport&lt;/code&gt;. Old-style branch names were category{litdd}branch, whereas new-style branch names are archive,category{litdd}branch{litdd}version. In both cases, names given on the command-line will override the automatically-generated ones.</source>
          <target state="translated">이전 버전의 &lt;code&gt;git archimport&lt;/code&gt; 에서 사용하는 구식 분기 이름과의 호환성을 위해 이것을 사용하십시오 . 구식 지사 이름은 category {litdd} 지점 인 반면, 새 스타일 지사 이름은 archive, category {litdd} 지점 {litdd} 버전입니다. 두 경우 모두 명령 줄에 지정된 이름은 자동으로 생성 된 이름보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="f09efb8456c99114df5272977533145bfda3715e" translate="yes" xml:space="preserve">
          <source>Use this option to integrate changes from the upstream subproject with your submodule&amp;rsquo;s current HEAD. Alternatively, you can run &lt;code&gt;git pull&lt;/code&gt; from the submodule, which is equivalent except for the remote branch name: &lt;code&gt;update --remote&lt;/code&gt; uses the default upstream repository and &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt;, while &lt;code&gt;git pull&lt;/code&gt; uses the submodule&amp;rsquo;s &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;. Prefer &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; if you want to distribute the default upstream branch with the superproject and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; if you want a more native feel while working in the submodule itself.</source>
          <target state="translated">업스트림 서브 프로젝트의 변경 사항을 서브 모듈의 현재 HEAD와 통합하려면이 옵션을 사용하십시오. 양자 택일로, 당신은 실행할 수 있습니다 &lt;code&gt;git pull&lt;/code&gt; 원격 지점 이름을 제외하고 동일합니다 서브 모듈에서 : &lt;code&gt;update --remote&lt;/code&gt; 사용하는 기본 업스트림 저장소와 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; , 동안 &lt;code&gt;git pull&lt;/code&gt; 서브 모듈의 사용 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; . 선호 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; 당신이 superproject와 함께 기본 상류 지점을 배포 할 경우 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 서브 모듈 자체에서 작업하는 동안 좀 더 네이티브 느낌을 원하는 경우.</target>
        </trans-unit>
        <trans-unit id="205f9bc458a5cacd665ee1af1eac8a989bc13811" translate="yes" xml:space="preserve">
          <source>Use this option to set the namespace where the original commits will be stored. The default value is &lt;code&gt;refs/original&lt;/code&gt;.</source>
          <target state="translated">원래 커밋이 저장 될 네임 스페이스를 설정하려면이 옵션을 사용하십시오. 기본값은 &lt;code&gt;refs/original&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="978a87da673ee3d6baf57006a070d2ceaf2e0a29" translate="yes" xml:space="preserve">
          <source>Use this option to set the path to the temporary directory used for rewriting. When applying a tree filter, the command needs to temporarily check out the tree to some directory, which may consume considerable space in case of large projects. By default it does this in the &lt;code&gt;.git-rewrite/&lt;/code&gt; directory but you can override that choice by this parameter.</source>
          <target state="translated">다시 쓰기에 사용되는 임시 디렉토리의 경로를 설정하려면이 옵션을 사용하십시오. 트리 필터를 적용 할 때 명령은 트리를 일부 디렉토리로 일시적으로 체크 아웃해야하므로 대규모 프로젝트의 경우 상당한 공간을 소비 할 수 있습니다. 기본적으로 &lt;code&gt;.git-rewrite/&lt;/code&gt; 디렉토리에서이를 수행하지만이 매개 변수로 해당 선택을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dad6966beac366ffc5d985e757265d090b93f5a" translate="yes" xml:space="preserve">
          <source>Use this option to unstage and remove paths only from the index. Working tree files, whether modified or not, will be left alone.</source>
          <target state="translated">인덱스에서만 경로를 스테이지 해제하고 제거하려면이 옵션을 사용하십시오. 작업 트리 파일은 수정 여부에 관계없이 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="22e3468b42fc7b02294ecbf3cdd521f378eedf7b" translate="yes" xml:space="preserve">
          <source>Use this to customize the program used for the signing format you chose. (see &lt;code&gt;gpg.program&lt;/code&gt; and &lt;code&gt;gpg.format&lt;/code&gt;) &lt;code&gt;gpg.program&lt;/code&gt; can still be used as a legacy synonym for &lt;code&gt;gpg.openpgp.program&lt;/code&gt;. The default value for &lt;code&gt;gpg.x509.program&lt;/code&gt; is &quot;gpgsm&quot;.</source>
          <target state="translated">이를 사용하여 선택한 서명 형식에 사용되는 프로그램을 사용자 정의하십시오. (참조 &lt;code&gt;gpg.program&lt;/code&gt; 및 &lt;code&gt;gpg.format&lt;/code&gt; 를 ) &lt;code&gt;gpg.program&lt;/code&gt; 는 여전히위한 기존의 동의어로 사용할 수 있습니다 &lt;code&gt;gpg.openpgp.program&lt;/code&gt; . &lt;code&gt;gpg.x509.program&lt;/code&gt; 의 기본값 은 &quot;gpgsm&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="2c0ec0febb1ffdfb71fd1faf1bdd4ef5cebdb7eb" translate="yes" xml:space="preserve">
          <source>Use this to specify the path to &lt;code&gt;git-upload-pack&lt;/code&gt; on the remote side, if is not found on your $PATH. Installations of sshd ignores the user&amp;rsquo;s environment setup scripts for login shells (e.g. .bash_profile) and your privately installed git may not be found on the system default $PATH. Another workaround suggested is to set up your $PATH in &quot;.bashrc&quot;, but this flag is for people who do not want to pay the overhead for non-interactive shells by having a lean .bashrc file (they set most of the things up in .bash_profile).</source>
          <target state="translated">$ PATH에 없으면 원격 측에서 &lt;code&gt;git-upload-pack&lt;/code&gt; 의 경로를 지정하려면 이것을 사용하십시오 . sshd를 설치하면 로그인 셸에 대한 사용자 환경 설정 스크립트 (예 : .bash_profile)가 무시되고 개인적으로 설치된 git이 시스템 기본 $ PATH에 없을 수 있습니다. 제안 된 또 다른 해결 방법은 &quot;.bashrc&quot;에 $ PATH를 설정하는 것이지만이 플래그는 .bashrc 파일을 기울여서 비 대화식 쉘의 오버 헤드를 지불하지 않으려는 사람들을위한 것입니다. .bash_profile에서).</target>
        </trans-unit>
        <trans-unit id="1f3cdffd9311e81ebd0ee41b41de344f546bb6a2" translate="yes" xml:space="preserve">
          <source>Used DBI driver. You can specify any available driver for this here, but it might not work. cvsserver is tested with &lt;code&gt;DBD::SQLite&lt;/code&gt;, reported to work with &lt;code&gt;DBD::Pg&lt;/code&gt;, and reported &lt;strong&gt;not&lt;/strong&gt; to work with &lt;code&gt;DBD::mysql&lt;/code&gt;. Please regard this as an experimental feature. May not contain colons (&lt;code&gt;:&lt;/code&gt;). Default: &lt;code&gt;SQLite&lt;/code&gt;</source>
          <target state="translated">사용 된 DBI 드라이버. 여기에 사용 가능한 드라이버를 지정할 수 있지만 작동하지 않을 수 있습니다. cvsserver는 &lt;code&gt;DBD::SQLite&lt;/code&gt; 로 테스트되었으며 DBD :: &lt;code&gt;DBD::Pg&lt;/code&gt; 와 함께 작동하는 것으로보고 되었으며 &lt;code&gt;DBD::mysql&lt;/code&gt; 과는 작동 &lt;strong&gt;하지 않는&lt;/strong&gt; 것으로보고 되었습니다 . 이것을 실험적인 기능으로 생각하십시오. 콜론이 포함되어 있지 않을 수도 있습니다 ( &lt;code&gt;:&lt;/code&gt; ). 디폴트 : &lt;code&gt;SQLite&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e96c8aa1d6db1322edc422d5cc1ffbd12e71daed" translate="yes" xml:space="preserve">
          <source>Used Perl DBI driver. You can specify any available driver for this here, but it might not work. git-cvsserver is tested with &lt;code&gt;DBD::SQLite&lt;/code&gt;, reported to work with &lt;code&gt;DBD::Pg&lt;/code&gt;, and reported &lt;strong&gt;not&lt;/strong&gt; to work with &lt;code&gt;DBD::mysql&lt;/code&gt;. Experimental feature. May not contain double colons (&lt;code&gt;:&lt;/code&gt;). Default: &lt;code&gt;SQLite&lt;/code&gt;. See &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;.</source>
          <target state="translated">Perl DBI 드라이버를 사용했습니다. 여기에 사용 가능한 드라이버를 지정할 수 있지만 작동하지 않을 수 있습니다. git-cvsserver는 &lt;code&gt;DBD::SQLite&lt;/code&gt; 로 테스트되었으며 DBD &lt;code&gt;DBD::Pg&lt;/code&gt; 와 함께 작동하는 것으로보고 되었으며 &lt;code&gt;DBD::mysql&lt;/code&gt; 과는 작동 &lt;strong&gt;하지 않는&lt;/strong&gt; 것으로보고 되었습니다 . 실험적인 특징. 이중 콜론이 포함되어 있지 않을 수도 있습니다 ( &lt;code&gt;:&lt;/code&gt; ). 기본 : &lt;code&gt;SQLite&lt;/code&gt; 는 . &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3dcc5e110a8886980641614ba00244bbf70eb3c6" translate="yes" xml:space="preserve">
          <source>Used as %(if)&amp;hellip;​%(then)&amp;hellip;​%(end) or %(if)&amp;hellip;​%(then)&amp;hellip;​%(else)&amp;hellip;​%(end). If there is an atom with value or string literal after the %(if) then everything after the %(then) is printed, else if the %(else) atom is used, then everything after %(else) is printed. We ignore space when evaluating the string before %(then), this is useful when we use the %(HEAD) atom which prints either &quot;*&quot; or &quot; &quot; and we want to apply the &lt;code&gt;if&lt;/code&gt; condition only on the &lt;code&gt;HEAD&lt;/code&gt; ref. Append &quot;:equals=&amp;lt;string&amp;gt;&quot; or &quot;:notequals=&amp;lt;string&amp;gt;&quot; to compare the value between the %(if:&amp;hellip;​) and %(then) atoms with the given string.</source>
          <target state="translated">% (if)&amp;hellip; % (then)&amp;hellip; % (end) 또는 % (if)&amp;hellip; % (then)&amp;hellip; % (else)&amp;hellip; % (end)로 사용됩니다. % (if) 뒤에 값 또는 문자열 리터럴이있는 원자가있는 경우 % (then) 뒤의 모든 것이 인쇄되고, 그렇지 않으면 % (else) 원자가 사용되면 % (else) 뒤의 모든 것이 인쇄됩니다. % (then) 이전의 문자열을 평가할 때 공간을 무시합니다. 이는 &quot;*&quot;또는 &quot;&quot;를 인쇄하는 % (HEAD) 원자를 사용할 때 유용 하며 &lt;code&gt;HEAD&lt;/code&gt; 참조 에만 &lt;code&gt;if&lt;/code&gt; 조건 을 적용하려고합니다 . &quot;: equals = &amp;lt;string&amp;gt;&quot;또는 &quot;: notequals = &amp;lt;string&amp;gt;&quot;을 추가하여 주어진 문자열과 % (if :&amp;hellip;) 및 % (then) 원자 사이의 값을 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="88972a7007de9e429d28d6bad7487052b23f9b65" translate="yes" xml:space="preserve">
          <source>Used to check that a bundle file is valid and will apply cleanly to the current repository. This includes checks on the bundle format itself as well as checking that the prerequisite commits exist and are fully linked in the current repository. &lt;code&gt;git bundle&lt;/code&gt; prints a list of missing commits, if any, and exits with a non-zero status.</source>
          <target state="translated">번들 파일이 유효하고 현재 저장소에 올바르게 적용되는지 확인하는 데 사용됩니다. 여기에는 번들 형식 자체에 대한 점검과 전제 조건 확약이 존재하며 현재 저장소에 완전히 링크되어 있는지 점검하는 것이 포함됩니다. &lt;code&gt;git bundle&lt;/code&gt; 은 누락 된 커밋 목록을 인쇄하고 0이 아닌 상태로 종료합니다.</target>
        </trans-unit>
        <trans-unit id="a81dfbb4b6756f63bb43c72d54c78dd02ef851d4" translate="yes" xml:space="preserve">
          <source>Used to create a bundle named &lt;code&gt;file&lt;/code&gt;. This requires the &lt;code&gt;&amp;lt;git-rev-list-args&amp;gt;&lt;/code&gt; arguments to define the bundle contents. &lt;code&gt;options&lt;/code&gt; contains the options specific to the &lt;code&gt;git bundle create&lt;/code&gt; subcommand.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 이라는 번들을 작성하는 데 사용 됩니다 . 번들 내용을 정의 하려면 &lt;code&gt;&amp;lt;git-rev-list-args&amp;gt;&lt;/code&gt; 인수가 필요합니다. &lt;code&gt;options&lt;/code&gt; 에는 &lt;code&gt;git bundle create&lt;/code&gt; 하위 명령과 관련된 옵션이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe127bac2ab0b61ffb60c0284f3741224c9951e1" translate="yes" xml:space="preserve">
          <source>Used to enforce or disable certificate revocation checks in cURL when http.sslBackend is set to &quot;schannel&quot;. Defaults to &lt;code&gt;true&lt;/code&gt; if unset. Only necessary to disable this if Git consistently errors and the message is about checking the revocation status of a certificate. This option is ignored if cURL lacks support for setting the relevant SSL option at runtime.</source>
          <target state="translated">http.sslBackend가 &quot;schannel&quot;로 설정된 경우 cURL에서 인증서 해지 확인을 시행 또는 비활성화하는 데 사용됩니다. 설정하지 않으면 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. Git에서 지속적으로 오류가 발생하고 메시지가 인증서의 해지 상태를 확인하는 것에 관한 경우에만이를 비활성화해야합니다. cURL에 런타임시 관련 SSL 옵션 설정 지원이 부족한 경우이 옵션은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="526891fe0801e3a16c20e50ecde492e75d4f6490" translate="yes" xml:space="preserve">
          <source>Used to set the maximum load that we will still respond to gitweb queries. If the server load exceeds this value then gitweb will return &quot;503 Service Unavailable&quot; error. The server load is taken to be 0 if gitweb cannot determine its value. Currently it works only on Linux, where it uses &lt;code&gt;/proc/loadavg&lt;/code&gt;; the load there is the number of active tasks on the system &amp;mdash; processes that are actually running &amp;mdash; averaged over the last minute.</source>
          <target state="translated">여전히 gitweb 쿼리에 응답 할 최대로드를 설정하는 데 사용됩니다. 서버로드가이 값을 초과하면 gitweb은 &quot;503 Service Unavailable&quot;오류를 반환합니다. gitweb이 그 값을 결정할 수 없으면 서버로드는 0이됩니다. 현재는 &lt;code&gt;/proc/loadavg&lt;/code&gt; 를 사용하는 Linux에서만 작동합니다 . 시스템에서 수행중인 작업 (실제로 실행중인 프로세스)의 수는 마지막 1 분 동안 평균입니다.</target>
        </trans-unit>
        <trans-unit id="184dba4369820f49a823e624aa006f74d3fc96ef" translate="yes" xml:space="preserve">
          <source>Used with --remote to specify the path to the &lt;code&gt;git-upload-archive&lt;/code&gt; on the remote side.</source>
          <target state="translated">원격 에서 &lt;code&gt;git-upload-archive&lt;/code&gt; 의 경로를 지정하기 위해 --remote와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a985abb59dca2d23760f5b7ff00e7d00f2d0f353" translate="yes" xml:space="preserve">
          <source>Used with &lt;code&gt;--range-diff&lt;/code&gt;, tweak the heuristic which matches up commits between the previous and current series of patches by adjusting the creation/deletion cost fudge factor. See &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff[1]&lt;/a&gt;) for details.</source>
          <target state="translated">&lt;code&gt;--range-diff&lt;/code&gt; 와 함께 사용 하면 생성 / 삭제 비용 퍼지 팩터를 조정하여 이전 및 현재 일련의 패치 사이의 커밋을 일치시키는 휴리스틱을 조정합니다. 자세한 내용은 &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff [1]&lt;/a&gt; )를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9777df5e2d0f3ca27a559e53074b9f39896040e8" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;fetch&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 명령 과 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ea99fa3d480e34606197cb808cc4a18c1d6b1306" translate="yes" xml:space="preserve">
          <source>User Manual</source>
          <target state="translated">사용자 매뉴얼</target>
        </trans-unit>
        <trans-unit id="3d338fa6790366b9708dc60a5019a8d98f73c4b3" translate="yes" xml:space="preserve">
          <source>User configuration and preferences are stored at:</source>
          <target state="translated">사용자 구성 및 환경 설정은 다음 위치에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="ba3e3bfcde6395de2671f768450f02d32f692aba" translate="yes" xml:space="preserve">
          <source>User name (e.g., &lt;code&gt;user&lt;/code&gt; in &lt;code&gt;https://user@example.com/repo.git&lt;/code&gt;). If the config key has a user name it must match the user name in the URL exactly. If the config key does not have a user name, that config key will match a URL with any user name (including none), but at a lower precedence than a config key with a user name.</source>
          <target state="translated">사용자 이름 (예를 들어, &lt;code&gt;user&lt;/code&gt; 의 &lt;code&gt;https://user@example.com/repo.git&lt;/code&gt; ). 구성 키에 사용자 이름이 있으면 URL의 사용자 이름과 정확히 일치해야합니다. 구성 키에 사용자 이름이없는 경우 해당 구성 키는 사용자 이름이있는 URL (없음 포함)과 일치하지만 사용자 이름이있는 구성 키보다 우선 순위가 낮습니다.</target>
        </trans-unit>
        <trans-unit id="9eabd3862d3bc88b6d20553afdc4c28a880bd15a" translate="yes" xml:space="preserve">
          <source>User specified as an option to all p4 commands, with &lt;code&gt;-u &amp;lt;user&amp;gt;&lt;/code&gt;. The environment variable &lt;code&gt;P4USER&lt;/code&gt; can be used instead.</source>
          <target state="translated">&lt;code&gt;-u &amp;lt;user&amp;gt;&lt;/code&gt; 와 함께 모든 p4 명령에 대한 옵션으로 사용자가 지정되었습니다 . 환경 변수 &lt;code&gt;P4USER&lt;/code&gt; 를 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3129c28f60cb352aa378d9055c2dee4b71cd917d" translate="yes" xml:space="preserve">
          <source>User-specific configuration file. Also called &quot;global&quot; configuration file.</source>
          <target state="translated">사용자 별 구성 파일 &quot;글로벌&quot;구성 파일이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="53b3f2b51348a1a5a4076e004425d0d150df3f8e" translate="yes" xml:space="preserve">
          <source>User-specific credentials file.</source>
          <target state="translated">사용자 별 자격 증명 파일.</target>
        </trans-unit>
        <trans-unit id="fbb3c5af6a1b800cb6bfa442ae5c6ae5ee1a4454" translate="yes" xml:space="preserve">
          <source>Username for SMTP-AUTH. Default is the value of &lt;code&gt;sendemail.smtpUser&lt;/code&gt;; if a username is not specified (with &lt;code&gt;--smtp-user&lt;/code&gt; or &lt;code&gt;sendemail.smtpUser&lt;/code&gt;), then authentication is not attempted.</source>
          <target state="translated">SMTP-AUTH의 사용자 이름 기본값은 &lt;code&gt;sendemail.smtpUser&lt;/code&gt; 의 값입니다 . &lt;code&gt;--smtp-user&lt;/code&gt; 또는 &lt;code&gt;sendemail.smtpUser&lt;/code&gt; 로 사용자 이름을 지정 하지 않으면 인증을 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd5ba62269befa999225c8d360ebd4fd64f50001" translate="yes" xml:space="preserve">
          <source>Users may select an automated merge strategy from among the following using either -s/--strategy option or configuring notes.mergeStrategy accordingly:</source>
          <target state="translated">사용자는 -s /-strategy 옵션을 사용하거나 이에 따라 notes.mergeStrategy를 사용하여 다음 중에서 자동 병합 전략을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="312954bd3f459a8154fbfda7b5edb71c57c929c2" translate="yes" xml:space="preserve">
          <source>Users migrating from CVS may also want to read &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">CVS에서 마이그레이션하는 사용자는 &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt; 을 읽을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bdfc1b01541d0790675419ccbb86b2582c7e882c" translate="yes" xml:space="preserve">
          <source>Users often try to use the assume-unchanged and skip-worktree bits to tell Git to ignore changes to files that are tracked. This does not work as expected, since Git may still check working tree files against the index when performing certain operations. In general, Git does not provide a way to ignore changes to tracked files, so alternate solutions are recommended.</source>
          <target state="translated">사용자는 종종 변경되지 않은 가정 및 워크 트리 건너 뛰기 비트를 사용하여 추적되는 파일의 변경 사항을 무시하도록 Git에 지시합니다. Git은 특정 작업을 수행 할 때 인덱스에 대해 작업 트리 파일을 계속 확인할 수 있으므로 예상대로 작동하지 않습니다. 일반적으로 Git은 추적 된 파일의 변경 사항을 무시하는 방법을 제공하지 않으므로 대체 솔루션이 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="d2fd200f233551c846ddc52433b7473972ba45cd" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;assume unchanged&amp;rdquo; bit</source>
          <target state="translated">&quot;변경되지 않은 가정&quot;비트 사용</target>
        </trans-unit>
        <trans-unit id="db59534f65c86c428a7a540c110ff1130d39acfc" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;git add -A&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;git add -A&amp;rdquo;사용</target>
        </trans-unit>
        <trans-unit id="3f756864c1cac8254338a14f16b7888b4cd11774" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;git commit -a&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;git commit -a&amp;rdquo;사용</target>
        </trans-unit>
        <trans-unit id="1ad6e2bdca2ef33d6f60d1165c40af77488df73e" translate="yes" xml:space="preserve">
          <source>Using --cacheinfo or --info-only</source>
          <target state="translated">--cacheinfo 또는 --info-only 사용</target>
        </trans-unit>
        <trans-unit id="63a49bc3316ec7fe7ab1c50a106ab3c187422a12" translate="yes" xml:space="preserve">
          <source>Using --index-info</source>
          <target state="translated">--index-info 사용</target>
        </trans-unit>
        <trans-unit id="9465002aca9e596e405478c595d6ec82ecf19f4d" translate="yes" xml:space="preserve">
          <source>Using --recurse-submodules can only fetch new commits in already checked out submodules right now. When e.g. upstream added a new submodule in the just fetched commits of the superproject the submodule itself cannot be fetched, making it impossible to check out that submodule later without having to do a fetch again. This is expected to be fixed in a future Git version.</source>
          <target state="translated">--recurse-submodules를 사용하면 이미 체크 아웃 된 하위 모듈에서만 새 커밋을 가져올 수 있습니다. 예를 들어 업스트림이 수퍼 프로젝트의 페치 된 커밋에 새로운 서브 모듈을 추가했을 때 서브 모듈 자체를 페치 할 수 없으므로 나중에 페치를 다시 수행 할 필요없이 서브 모듈을 체크 아웃 할 수 없습니다. 향후 Git 버전에서 수정 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="9ba2b3bf5dd0ae3395bffc9a6bf30c85dfb19a1b" translate="yes" xml:space="preserve">
          <source>Using --recurse-submodules will update the content of all active submodules according to the commit recorded in the superproject by calling read-tree recursively, also setting the submodules' HEAD to be detached at that commit.</source>
          <target state="translated">--recurse-submodules를 사용하면 read-tree를 재귀 적으로 호출하여 수퍼 프로젝트에 기록 된 커밋에 따라 모든 활성 서브 모듈의 내용을 업데이트하고 해당 커밋에서 분리되도록 서브 모듈의 HEAD를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="3b6c4766d3d128d670a5d5adf42fc526da676a66" translate="yes" xml:space="preserve">
          <source>Using --recurse-submodules will update the content of all initialized submodules according to the commit recorded in the superproject by calling read-tree recursively, also setting the submodules HEAD to be detached at that commit.</source>
          <target state="translated">--recurse-submodules를 사용하면 읽기 트리를 재귀 적으로 호출하여 수퍼 프로젝트에 기록 된 커밋에 따라 초기화 된 모든 하위 모듈의 내용을 업데이트하고 해당 커밋에서 하위 모듈 HEAD를 분리하도록 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8315f077dd8f5ad49468aff013d2df68acafcb5e" translate="yes" xml:space="preserve">
          <source>Using --refresh</source>
          <target state="translated">--refresh 사용</target>
        </trans-unit>
        <trans-unit id="0565ce691b52b5953c2fb97dfb806a2f764f48e2" translate="yes" xml:space="preserve">
          <source>Using --temp or --stage=all</source>
          <target state="translated">--temp 또는 --stage = all 사용</target>
        </trans-unit>
        <trans-unit id="509888a40362653e71adbbdc6d4e59bc0d3d4ce4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--index-filter&lt;/code&gt; with &lt;code&gt;git rm&lt;/code&gt; yields a significantly faster version. Like with using &lt;code&gt;rm filename&lt;/code&gt;, &lt;code&gt;git rm --cached filename&lt;/code&gt; will fail if the file is absent from the tree of a commit. If you want to &quot;completely forget&quot; a file, it does not matter when it entered history, so we also add &lt;code&gt;--ignore-unmatch&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;git rm&lt;/code&gt; 과 함께 &lt;code&gt;--index-filter&lt;/code&gt; 를 사용하면 버전이 훨씬 빨라집니다. 사용과 같이 &lt;code&gt;rm filename&lt;/code&gt; , &lt;code&gt;git rm --cached filename&lt;/code&gt; 파일이 커밋의 트리에서 존재하지 않는 경우 실패합니다. 파일을 &quot;완전히 잊어 버리려면&quot;파일이 언제 기록되는지는 중요하지 않으므로 &lt;code&gt;--ignore-unmatch&lt;/code&gt; 도 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="802dbfe4495f98c59f087035f936edebe365e8d7" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all active submodules according to the commit recorded in the superproject. If local modifications in a submodule would be overwritten the checkout will fail unless &lt;code&gt;-f&lt;/code&gt; is used. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, submodules working trees will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodule.</source>
          <target state="translated">&lt;code&gt;--recurse-submodules&lt;/code&gt; 를 사용 하면 수퍼 프로젝트에 기록 된 커밋에 따라 모든 활성 하위 모듈의 내용이 업데이트됩니다. 하위 모듈의 로컬 수정 사항을 덮어 쓰면 &lt;code&gt;-f&lt;/code&gt; 를 사용 하지 않으면 체크 아웃이 실패 합니다. 아무것도 사용하지 않으면 (또는 &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ), 하위 모듈 작업 트리가 업데이트되지 않습니다. &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt; 처럼 서브 모듈의 &lt;code&gt;HEAD&lt;/code&gt; 를 분리 합니다.</target>
        </trans-unit>
        <trans-unit id="bf5da0d2a32c5b7048069200ef431cff7653b1d4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all active submodules according to the commit recorded in the superproject. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, submodules working trees will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodules.</source>
          <target state="translated">&lt;code&gt;--recurse-submodules&lt;/code&gt; 를 사용 하면 수퍼 프로젝트에 기록 된 커밋에 따라 모든 활성 하위 모듈의 내용이 업데이트됩니다. 아무것도 사용하지 않으면 (또는 &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ), 하위 모듈 작업 트리가 업데이트되지 않습니다. &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt; 처럼 서브 모듈의 &lt;code&gt;HEAD&lt;/code&gt; 를 분리 합니다.</target>
        </trans-unit>
        <trans-unit id="47e7ecf39552b28db7a0c771cb5239db7d4a81af" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all initialized submodules according to the commit recorded in the superproject. If local modifications in a submodule would be overwritten the checkout will fail unless &lt;code&gt;-f&lt;/code&gt; is used. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, the work trees of submodules will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodule.</source>
          <target state="translated">&lt;code&gt;--recurse-submodules&lt;/code&gt; 를 사용 하면 수퍼 프로젝트에 기록 된 커밋에 따라 초기화 된 모든 하위 모듈의 내용이 업데이트됩니다. 서브 모듈의 로컬 수정 사항을 겹쳐 쓰면 &lt;code&gt;-f&lt;/code&gt; 를 사용 하지 않으면 체크 아웃에 실패 합니다. 아무것도 사용하지 않으면 (또는 &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ) 하위 모듈 의 작업 트리가 업데이트되지 않습니다. 마찬가지로 &lt;a href=&quot;git-submodule&quot;&gt;자식 - 서브 모듈 [1]&lt;/a&gt; , 이는 분리한다 &lt;code&gt;HEAD&lt;/code&gt; 서브 모듈의이.</target>
        </trans-unit>
        <trans-unit id="87e05fa35b92ebd2beac592a4000f99e52c8fa99" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all initialized submodules according to the commit recorded in the superproject. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, the work trees of submodules will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodules.</source>
          <target state="translated">&lt;code&gt;--recurse-submodules&lt;/code&gt; 를 사용 하면 수퍼 프로젝트에 기록 된 커밋에 따라 초기화 된 모든 하위 모듈의 내용이 업데이트됩니다. 아무것도 사용하지 않으면 (또는 &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ) 하위 모듈 의 작업 트리가 업데이트되지 않습니다. 마찬가지로 &lt;a href=&quot;git-submodule&quot;&gt;자식 - 서브 모듈 [1]&lt;/a&gt; , 이는 분리한다 &lt;code&gt;HEAD&lt;/code&gt; 서브 모듈의이.</target>
        </trans-unit>
        <trans-unit id="131907fc18369579f75831dbffd3a45262caaa68" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-a&lt;/code&gt; would conflate &amp;lt;remote&amp;gt; with any local branches you happen to have been prefixed with the same &amp;lt;remote&amp;gt; pattern.</source>
          <target state="translated">&lt;code&gt;-a&lt;/code&gt; 를 사용하면 &amp;lt;remote&amp;gt;와 접두사가 같은 로컬 분기와 &amp;lt;remote&amp;gt;가 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="bc196497d8f80228e3ec0969c92ba077224b9158" translate="yes" xml:space="preserve">
          <source>Using &lt;em&gt;git checkout-index&lt;/em&gt; to &quot;export an entire tree&quot;</source>
          <target state="translated">&lt;em&gt;git checkout-index&lt;/em&gt; 를 사용 하여 &quot;전체 트리 내보내기&quot;</target>
        </trans-unit>
        <trans-unit id="bb5a1594f36aa9f526f3a0391e9aecb18bcb1ed6" translate="yes" xml:space="preserve">
          <source>Using Gmail&amp;rsquo;s IMAP interface:</source>
          <target state="translated">Gmail의 IMAP 인터페이스 사용 :</target>
        </trans-unit>
        <trans-unit id="f145740948f023493614f8cb28fc352a33b08d80" translate="yes" xml:space="preserve">
          <source>Using a limit</source>
          <target state="translated">한도 사용</target>
        </trans-unit>
        <trans-unit id="0d18e7415acaf5bf1693b96116e4340271619597" translate="yes" xml:space="preserve">
          <source>Using another project while maintaining independent history. Submodules allow you to contain the working tree of another project within your own working tree while keeping the history of both projects separate. Also, since submodules are fixed to an arbitrary version, the other project can be independently developed without affecting the superproject, allowing the superproject project to fix itself to new versions only when desired.</source>
          <target state="translated">독립 이력을 유지하면서 다른 프로젝트를 사용합니다. 서브 모듈을 사용하면 자신의 작업 트리 내에 다른 프로젝트의 작업 트리를 포함시키면서 두 프로젝트의 기록을 별도로 유지할 수 있습니다. 또한, 서브 모듈은 임의의 버전으로 고정되어 있기 때문에, 다른 프로젝트는 수퍼 프로젝트에 영향을주지 않고 독립적으로 개발 될 수 있으며, 수퍼 프로젝트 프로젝트는 원하는 경우에만 새 버전으로 고정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03266ad998c58f3651e774794904a59499884e04" translate="yes" xml:space="preserve">
          <source>Using complex scripts</source>
          <target state="translated">복잡한 스크립트 사용</target>
        </trans-unit>
        <trans-unit id="9a4e17fa716627d801ba04248e7c13675c63f6bf" translate="yes" xml:space="preserve">
          <source>Using direct mode with SSL:</source>
          <target state="translated">SSL과 함께 직접 모드 사용 :</target>
        </trans-unit>
        <trans-unit id="80be60b71aa62e009a5472e7b71ecca69fb605f2" translate="yes" xml:space="preserve">
          <source>Using direct mode:</source>
          <target state="translated">직접 모드 사용 :</target>
        </trans-unit>
        <trans-unit id="1c1bc19943239ea53498134ee5024657c6f7482f" translate="yes" xml:space="preserve">
          <source>Using git for collaboration</source>
          <target state="translated">협업을 위해 git 사용</target>
        </trans-unit>
        <trans-unit id="e742dd237e897f0c09d1168ed38eeca1316d409b" translate="yes" xml:space="preserve">
          <source>Using interactive rebases</source>
          <target state="translated">대화식 리베이스 사용</target>
        </trans-unit>
        <trans-unit id="16c9cb76d4ea0981714eee54828fc3305174e2d5" translate="yes" xml:space="preserve">
          <source>Using macro attributes</source>
          <target state="translated">매크로 속성 사용</target>
        </trans-unit>
        <trans-unit id="0bcad514939a1a512d30defc1dd83a6988408bd1" translate="yes" xml:space="preserve">
          <source>Using more options generally further limits the output (e.g. &lt;code&gt;--since=&amp;lt;date1&amp;gt;&lt;/code&gt; limits to commits newer than &lt;code&gt;&amp;lt;date1&amp;gt;&lt;/code&gt;, and using it with &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; further limits to commits whose log message has a line that matches &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;), unless otherwise noted.</source>
          <target state="translated">일반적으로 상기 기준 출력 (예를 들면 더 많은 옵션을 사용 &lt;code&gt;--since=&amp;lt;date1&amp;gt;&lt;/code&gt; 보다 최신 커밋에 제한 &lt;code&gt;&amp;lt;date1&amp;gt;&lt;/code&gt; 과 함께 사용 &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; 그 로그 메시지 커밋을 더욱 제한하는 라인과 일치를 갖는 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 달리 명시되지 않는 한 pattern&amp;gt; ).</target>
        </trans-unit>
        <trans-unit id="aab9e25047cbd960c71a3d6743c695a0fbcee99d" translate="yes" xml:space="preserve">
          <source>Using refspecs explicitly:</source>
          <target state="translated">Refspec을 명시 적으로 사용하기 :</target>
        </trans-unit>
        <trans-unit id="e240eb205361a2a50754a2cbbad5230917e3c8f6" translate="yes" xml:space="preserve">
          <source>Using test suites and git bisect together</source>
          <target state="translated">테스트 스위트와 git bisect를 함께 사용</target>
        </trans-unit>
        <trans-unit id="8fdfb0e1e33426ffa586ab6e967bc34118a45d25" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;--submodule=log&lt;/code&gt; option with &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; will provide that information too.</source>
          <target state="translated">&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 와 함께 &lt;code&gt;--submodule=log&lt;/code&gt; 옵션을 사용하면 해당 정보도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d42f8d8f39d5c1ce54e65e242137998175012054" translate="yes" xml:space="preserve">
          <source>Using these options, &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; will act similar to the more specialized family of commit log tools: &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt;</source>
          <target state="translated">이 옵션을 사용하면 &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt; 은보다 전문화 된 커밋 로그 도구 제품군 인 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; 및 &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]와 유사하게 작동합니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a34d360db274a11502bc402ef7758f2bc5adf11b" translate="yes" xml:space="preserve">
          <source>Using this helper will store your passwords unencrypted on disk, protected only by filesystem permissions. If this is not an acceptable security tradeoff, try &lt;a href=&quot;git-credential-cache&quot;&gt;git-credential-cache[1]&lt;/a&gt;, or find a helper that integrates with secure storage provided by your operating system.</source>
          <target state="translated">이 도우미를 사용하면 암호가 디스크에 암호화되지 않고 파일 시스템 권한으로 만 보호됩니다. 이것이 허용 가능한 보안 상충 관계가 아닌 경우 &lt;a href=&quot;git-credential-cache&quot;&gt;git-credential-cache [1]을&lt;/a&gt; 시도 하거나 운영 체제에서 제공하는 보안 스토리지와 통합되는 헬퍼를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="86d0ca06bdb5a3aacec696a9b10115a302a90ea4" translate="yes" xml:space="preserve">
          <source>Using this hook, it is easy to generate mails describing the updates to the repository. This example script sends one mail message per ref listing the commits pushed to the repository, and logs the push certificates of signed pushes with good signatures to a logger service:</source>
          <target state="translated">이 후크를 사용하면 저장소의 업데이트를 설명하는 메일을 쉽게 생성 할 수 있습니다. 이 예제 스크립트는 ref 당 하나의 메일 메시지를 저장소로 푸시 된 커밋을 나열하고 서명이있는 푸시의 푸시 인증서를 로거 서비스에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="7ae98ad0643543d139a0ccded2d96be6c57e816c" translate="yes" xml:space="preserve">
          <source>Using this option for any other purpose (don&amp;rsquo;t ask) is very strongly discouraged.</source>
          <target state="translated">다른 목적으로 사용하지 않는 것이 좋습니다 (권장하지 않음).</target>
        </trans-unit>
        <trans-unit id="ebe89d9e15d8a582f6b4a48c6c03d60cf9c673f1" translate="yes" xml:space="preserve">
          <source>Using tunnel mode:</source>
          <target state="translated">터널 모드 사용 :</target>
        </trans-unit>
        <trans-unit id="f17a1449e9ed80dcff59f550977b6693d42b10bf" translate="yes" xml:space="preserve">
          <source>Usual 3-way file level merge for text files. Conflicted regions are marked with conflict markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=======&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. The version from your branch appears before the &lt;code&gt;=======&lt;/code&gt; marker, and the version from the merged branch appears after the &lt;code&gt;=======&lt;/code&gt; marker.</source>
          <target state="translated">텍스트 파일에 대한 일반적인 3 방향 파일 수준 병합. 충돌 영역에는 충돌 마커 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;=======&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 가 표시됩니다 . 지점의 버전은 &lt;code&gt;=======&lt;/code&gt; 마커 앞에 나타나고 병합 된 지점의 버전은 &lt;code&gt;=======&lt;/code&gt; 마커 뒤에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="6cb51fab051882aaba81e0715d7acfa80e2ce09c" translate="yes" xml:space="preserve">
          <source>Usually &lt;code&gt;git gc&lt;/code&gt; runs very quickly while providing good disk space utilization and performance. This option will cause &lt;code&gt;git gc&lt;/code&gt; to more aggressively optimize the repository at the expense of taking much more time. The effects of this optimization are mostly persistent. See the &quot;AGGRESSIVE&quot; section below for details.</source>
          <target state="translated">일반적으로 &lt;code&gt;git gc&lt;/code&gt; 는 디스크 공간 활용도 및 성능을 향상시키면서 매우 빠르게 실행됩니다. 이 옵션을 사용하면 &lt;code&gt;git gc&lt;/code&gt; 가 훨씬 더 많은 시간을 소비하면서 저장소를보다 적극적으로 최적화합니다. 이 최적화의 효과는 대부분 영구적입니다. 자세한 내용은 아래의 &quot;AGGRESSIVE&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="da9e2cbf852524ee1edb371514af799c05f82c93" translate="yes" xml:space="preserve">
          <source>Usually a merge requires the index file as well as the files in the working tree to be up to date with the current head commit, in order not to lose local changes. This flag disables the check with the working tree and is meant to be used when creating a merge of trees that are not directly related to the current working tree status into a temporary index file.</source>
          <target state="translated">일반적으로 병합을 수행하면 로컬 변경 사항을 잃지 않도록 작업 트리의 파일과 색인 파일이 현재 헤드 커밋으로 최신 상태 여야합니다. 이 플래그는 작업 트리에서 검사를 비활성화하며 현재 작업 트리 상태와 직접 관련이없는 트리를 임시 인덱스 파일로 병합 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="27214bb5573e76f1f8a1f21396536681c10927d6" translate="yes" xml:space="preserve">
          <source>Usually a three-way merge by &lt;code&gt;git read-tree&lt;/code&gt; resolves the merge for really trivial cases and leaves other cases unresolved in the index, so that porcelains can implement different merge policies. This flag makes the command resolve a few more cases internally:</source>
          <target state="translated">일반적으로 &lt;code&gt;git read-tree&lt;/code&gt; 에 의한 3 방향 병합은 사소한 경우에 대한 병합을 해결하고 색인에서 다른 경우는 해결되지 않은 상태로 두므로 도자기는 다른 병합 정책을 구현할 수 있습니다. 이 플래그는 명령이 내부적으로 몇 가지 경우를 더 해결하도록합니다.</target>
        </trans-unit>
        <trans-unit id="1a018c180f83561166ef04fc1c1b049dd7bef5e3" translate="yes" xml:space="preserve">
          <source>Usually given &quot;&amp;lt;feature&amp;gt;&quot; is configurable via the &lt;code&gt;gitweb.&amp;lt;feature&amp;gt;&lt;/code&gt; config variable in the per-repository Git configuration file.</source>
          <target state="translated">일반적으로 &quot;&amp;lt;feature&amp;gt;&quot;는 저장소 별 Git 구성 파일 의 &lt;code&gt;gitweb.&amp;lt;feature&amp;gt;&lt;/code&gt; 구성 변수를 통해 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06bd62b74600c2b58fc5390378d7102461c2b477" translate="yes" xml:space="preserve">
          <source>Usually it is easier to configure any desired options through your personal &lt;code&gt;.ssh/config&lt;/code&gt; file. Please consult your ssh documentation for further details.</source>
          <target state="translated">일반적으로 개인 &lt;code&gt;.ssh/config&lt;/code&gt; 파일 을 통해 원하는 옵션을 구성하는 것이 더 쉽습니다 . 자세한 내용은 ssh 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e92c22e35ceb9b2c8da5295a992718e30d5c9f60" translate="yes" xml:space="preserve">
          <source>Usually recording a commit that has the exact same tree as its sole parent commit is a mistake, and the command prevents you from making such a commit. This option bypasses the safety, and is primarily for use by foreign SCM interface scripts.</source>
          <target state="translated">일반적으로 유일한 상위 커밋과 정확히 동일한 트리를 가진 커밋을 기록하는 것은 실수이며 명령으로 인해 그러한 커밋을 할 수 없습니다. 이 옵션은 안전을 우회하며 주로 외부 SCM 인터페이스 스크립트에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8ce3f0d516dc2a9d67b8e4ba143055eaf7bab452" translate="yes" xml:space="preserve">
          <source>Usually the command automatically creates a sequence of commits. This flag applies the changes necessary to cherry-pick each named commit to your working tree and the index, without making any commit. In addition, when this option is used, your index does not have to match the HEAD commit. The cherry-pick is done against the beginning state of your index.</source>
          <target state="translated">일반적으로이 명령은 일련의 커밋을 자동으로 만듭니다. 이 플래그는 커밋하지 않고 명명 된 각 커밋을 작업 트리 및 인덱스에 체리 픽 픽킹하는 데 필요한 변경 사항을 적용합니다. 또한이 옵션을 사용하면 인덱스가 HEAD 커밋과 일치하지 않아도됩니다. 체리 픽은 인덱스의 시작 상태에 대해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="55875ee1e78ad1cfc5a25d1e098bc17781327203" translate="yes" xml:space="preserve">
          <source>Usually the command automatically creates some commits with commit log messages stating which commits were reverted. This flag applies the changes necessary to revert the named commits to your working tree and the index, but does not make the commits. In addition, when this option is used, your index does not have to match the HEAD commit. The revert is done against the beginning state of your index.</source>
          <target state="translated">일반적으로 명령은 어떤 커밋이 되돌려 졌는지를 나타내는 커밋 로그 메시지와 함께 일부 커밋을 자동으로 만듭니다. 이 플래그는 명명 된 커밋을 작업 트리와 인덱스로 되 돌리는 데 필요한 변경 사항을 적용하지만 커밋은하지 않습니다. 또한이 옵션을 사용하면 인덱스가 HEAD 커밋과 일치하지 않아도됩니다. 복귀는 색인의 시작 상태에 대해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="51d5f6e8faedb5ef4d1204f14e2f7ab2d7b77eaf" translate="yes" xml:space="preserve">
          <source>Usually the command stops output upon showing the commit that is the common ancestor of all the branches. This flag tells the command to go &amp;lt;n&amp;gt; more common commits beyond that. When &amp;lt;n&amp;gt; is negative, display only the &amp;lt;reference&amp;gt;s given, without showing the commit ancestry tree.</source>
          <target state="translated">일반적으로 명령은 모든 분기의 공통 조상 인 커밋을 표시하면 출력을 중지합니다. 이 플래그는 명령이 그보다 더 일반적인 커밋을 &amp;lt;n&amp;gt; 가도록 지시합니다. &amp;lt;n&amp;gt;이 음수이면, 커밋 상위 트리를 표시하지 않고 주어진 &amp;lt;reference&amp;gt; 만 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="29097abe7ecd686605680556737a55dc5b7468af" translate="yes" xml:space="preserve">
          <source>Usually the object names are output in SHA-1 form (with possible &lt;code&gt;^&lt;/code&gt; prefix); this option makes them output in a form as close to the original input as possible.</source>
          <target state="translated">일반적으로 개체 이름은 SHA-1 형식 ( &lt;code&gt;^&lt;/code&gt; 접두사 포함) 으로 출력됩니다 . 이 옵션은 가능한 한 원래 입력에 가까운 형태로 출력합니다.</target>
        </trans-unit>
        <trans-unit id="576f849692364345fa924f476c3413707294c315" translate="yes" xml:space="preserve">
          <source>Usually the output is made one line per flag and parameter. This option makes output a single line, properly quoted for consumption by shell. Useful when you expect your parameter to contain whitespaces and newlines (e.g. when using pickaxe &lt;code&gt;-S&lt;/code&gt; with &lt;code&gt;git diff-*&lt;/code&gt;). In contrast to the &lt;code&gt;--sq-quote&lt;/code&gt; option, the command input is still interpreted as usual.</source>
          <target state="translated">일반적으로 출력은 플래그와 매개 변수 당 한 줄로 만들어집니다. 이 옵션은 출력을 단일 행으로 만들고 셸에서 사용하기에 적합하게 인용합니다. 매개 변수에 공백과 줄 바꿈이 포함될 것으로 예상 할 때 유용합니다 (예 : &lt;code&gt;git diff-*&lt;/code&gt; 와 함께 pickaxe &lt;code&gt;-S&lt;/code&gt; 를 사용하는 경우 ). 받는 반면 &lt;code&gt;--sq-quote&lt;/code&gt; 옵션, 명령 입력은 여전히 평소와 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="52303fe63fddea8a07d49fe1df917ff950ba6541" translate="yes" xml:space="preserve">
          <source>Usually the program removes email cruft from the Subject: header line to extract the title line for the commit log message. This option prevents this munging, and is most useful when used to read back &lt;code&gt;git format-patch -k&lt;/code&gt; output.</source>
          <target state="translated">일반적으로 프로그램은 Subject : 헤더 행에서 전자 메일 크루프를 제거하여 커밋 로그 메시지의 제목 줄을 추출합니다. 이 옵션은 이러한 뭉침 현상을 방지하며 &lt;code&gt;git format-patch -k&lt;/code&gt; 출력을 다시 읽을 때 가장 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="12904fba6e8c31d350b5463557502fba670802b3" translate="yes" xml:space="preserve">
          <source>Usually you cannot cherry-pick a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows cherry-pick to replay the change relative to the specified parent.</source>
          <target state="translated">일반적으로 병합의 어느 쪽이 메인 라인으로 간주되어야하는지 모르기 때문에 병합을 체리 픽픽으로 선택할 수 없습니다. 이 옵션은 메인 라인의 부모 번호 (1부터 시작)를 지정하고 체리 픽이 지정된 부모에 대한 변경을 재생할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="8ec09d5ac366ce3cd2a5e3c6c67d0b4fe311e4bf" translate="yes" xml:space="preserve">
          <source>Usually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.</source>
          <target state="translated">일반적으로 병합의 어느 쪽이 메인 라인으로 간주되어야하는지 모르기 때문에 병합을 되돌릴 수 없습니다. 이 옵션은 메인 라인의 상위 번호 (1부터 시작)를 지정하고 지정된 상위를 기준으로 변경 사항을 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6969d1a350dfc3fafb277e2e6995e5ac7a289ac5" translate="yes" xml:space="preserve">
          <source>Usually you should not need to change (adjust) any of configuration variables described below; they should be automatically set by gitweb to correct value.</source>
          <target state="translated">일반적으로 아래 설명 된 구성 변수를 변경 (조정) 할 필요는 없습니다. 그들은 gitweb에 의해 자동으로 설정되어 값을 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b172c85defacdb686b541793ef9e8aeee0cdf60e" translate="yes" xml:space="preserve">
          <source>Usually you would want to use &lt;code&gt;git fetch&lt;/code&gt;, which is a higher level wrapper of this command, instead.</source>
          <target state="translated">일반적 으로이 명령의 상위 레벨 래퍼 인 &lt;code&gt;git fetch&lt;/code&gt; 를 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="bec645de31c299cb10f93b6253e1e1669a5f0a31" translate="yes" xml:space="preserve">
          <source>Usually you would want to use &lt;code&gt;git push&lt;/code&gt;, which is a higher-level wrapper of this command, instead. See &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">일반적으로 대신이 명령의 상위 레벨 래퍼 인 &lt;code&gt;git push&lt;/code&gt; 를 사용하려고합니다 . &lt;a href=&quot;git-push&quot;&gt;git-push [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5982263578e4f00875c00a40da810fe92911cebc" translate="yes" xml:space="preserve">
          <source>Usually, &quot;git push&quot; refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it.</source>
          <target state="translated">일반적으로 &quot;git push&quot;는 덮어 쓰기에 사용 된 로컬 참조의 조상이 아닌 원격 참조 업데이트를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="f8497b6ab754b20f8d36f9efb8dfea581706bc5d" translate="yes" xml:space="preserve">
          <source>Usually, dangling blobs and trees aren&amp;rsquo;t very interesting. They&amp;rsquo;re almost always the result of either being a half-way mergebase (the blob will often even have the conflict markers from a merge in it, if you have had conflicting merges that you fixed up by hand), or simply because you interrupted a &lt;code&gt;git fetch&lt;/code&gt; with ^C or something like that, leaving &lt;code&gt;some&lt;/code&gt; of the new objects in the object database, but just dangling and useless.</source>
          <target state="translated">일반적으로 매달린 얼룩과 나무는 그리 흥미롭지 않습니다. 그것들은 거의 항상 반쯤 머지베이스 (혼합 된 머지가 있었다면 블롭이 머지에서 머티리얼에서 충돌 마커를 가질 수도 있음)이거나 단순히 중단했기 때문에 발생합니다. ^ C와 같은 &lt;code&gt;git fetch&lt;/code&gt; 는 객체 데이터베이스에 새로운 객체 &lt;code&gt;some&lt;/code&gt; 를 남겨두고 매달려 있지만 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ebecb811fcb50ea2c9e80ad196b73df5b02ee5fc" translate="yes" xml:space="preserve">
          <source>Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. Also, when &lt;code&gt;--force-with-lease&lt;/code&gt; option is used, the command refuses to update a remote ref whose current value does not match what is expected.</source>
          <target state="translated">일반적으로이 명령은 덮어 쓰기에 사용 된 로컬 참조의 조상이 아닌 원격 참조 업데이트를 거부합니다. 또한 &lt;code&gt;--force-with-lease&lt;/code&gt; 옵션을 사용하는 경우 명령은 현재 값이 예상 한 값과 일치하지 않는 원격 참조 업데이트를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="1039e5d0aca0474d85bb0cc56a14c21769cd56ed" translate="yes" xml:space="preserve">
          <source>Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. This flag disables the check. What this means is that the remote repository can lose commits; use it with care.</source>
          <target state="translated">일반적으로이 명령은 덮어 쓰기에 사용 된 로컬 참조의 조상이 아닌 원격 참조 업데이트를 거부합니다. 이 플래그는 검사를 비활성화합니다. 이것이 의미하는 것은 원격 저장소가 커밋을 잃을 수 있다는 것입니다. 조심해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b573cab97a4c7ff4e65c78f089627a289eeb14b6" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt;'s include:</source>
          <target state="translated">유효한 &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f441e23dc9e42a84676feea9743dbd62f2c9b12" translate="yes" xml:space="preserve">
          <source>Valid object types are:</source>
          <target state="translated">유효한 객체 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b5bd1c32c0119d43f13ecb3f634510bb032afd7" translate="yes" xml:space="preserve">
          <source>Validate packed Git archive files</source>
          <target state="translated">압축 된 Git 아카이브 파일 검증</target>
        </trans-unit>
        <trans-unit id="c95efe4a20b3c90ba09bca423cb347dacda4f997" translate="yes" xml:space="preserve">
          <source>Validates the GPG signature created by &lt;code&gt;git commit -S&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git commit -S&lt;/code&gt; 로 작성된 GPG 서명을 검증합니다 .</target>
        </trans-unit>
        <trans-unit id="ee833db09826b15f6656c228fc09101a4d262c96" translate="yes" xml:space="preserve">
          <source>Validates the gpg signature created by &lt;code&gt;git tag&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git tag&lt;/code&gt; 에 의해 생성 된 gpg 서명을 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="38ecbfb58a1b4075db82e349628396bb680485d8" translate="yes" xml:space="preserve">
          <source>Values for other tools can be used if there is a corresponding &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; configuration entry (see below).</source>
          <target state="translated">해당 &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 구성 항목 이있는 경우 다른 도구의 값을 사용할 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="4590af9796b7774b94529a47844bbbd8cd70381f" translate="yes" xml:space="preserve">
          <source>Values obtained in later configuration files override values obtained earlier in the above sequence.</source>
          <target state="translated">이후 구성 파일에서 얻은 값은 위 순서에서 이전에 얻은 값보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="42a2c91c112ab20fb86d229e79049c16aac8f47b" translate="yes" xml:space="preserve">
          <source>Values of many variables are treated as a simple string, but there are variables that take values of specific types and there are rules as to how to spell them.</source>
          <target state="translated">많은 변수의 값은 간단한 문자열로 취급되지만 특정 유형의 값을 취하는 변수가 있으며 철자를 철자하는 방법에 대한 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="af6a117cf9cae5d8127a5c83e908e26e4094605c" translate="yes" xml:space="preserve">
          <source>Variable substitution</source>
          <target state="translated">변수 치환</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="36ae09eeb0daa8ef3fa73e86b507f064c6f1150e" translate="yes" xml:space="preserve">
          <source>Various Git commands use the following environment variables:</source>
          <target state="translated">다양한 Git 명령은 다음 환경 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c808db304a88e67e4d99602bde96a3fd73a86c36" translate="yes" xml:space="preserve">
          <source>Various aspects of gitweb&amp;rsquo;s behavior can be controlled through the configuration file &lt;code&gt;gitweb_config.perl&lt;/code&gt; or &lt;code&gt;/etc/gitweb.conf&lt;/code&gt;. See the &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt; for details.</source>
          <target state="translated">gitweb 동작의 다양한 측면은 구성 파일 &lt;code&gt;gitweb_config.perl&lt;/code&gt; 또는 &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; 를 통해 제어 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="514c3adc237433a43f04caf698ef6f51638f8f03" translate="yes" xml:space="preserve">
          <source>Various commands read from the configuration file and adjust their operation accordingly. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for a list and more details about the configuration mechanism.</source>
          <target state="translated">구성 파일에서 다양한 명령을 읽고 그에 따라 작업을 조정합니다. 구성 메커니즘에 대한 자세한 내용과 목록 은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9d741cda072f8e825584f9d44fb913d01a1b3645" translate="yes" xml:space="preserve">
          <source>Various values from structured fields in referenced objects can be used to interpolate into the resulting output, or as sort keys.</source>
          <target state="translated">참조 된 객체의 구조화 된 필드의 다양한 값을 사용하여 결과 출력에 보간하거나 정렬 키로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e52597805b02b27bbf6fa8afb053d38cd1cf9a2" translate="yes" xml:space="preserve">
          <source>Various ways to check your working tree</source>
          <target state="translated">작업 트리를 확인하는 다양한 방법</target>
        </trans-unit>
        <trans-unit id="8a8830ff167eaa3505bc00fdd4111ea514743436" translate="yes" xml:space="preserve">
          <source>Verbose output.</source>
          <target state="translated">자세한 출력.</target>
        </trans-unit>
        <trans-unit id="5e80e8afa8277ee05efe0825f2f72b290ab38b7f" translate="yes" xml:space="preserve">
          <source>Verbose.</source>
          <target state="translated">Verbose.</target>
        </trans-unit>
        <trans-unit id="1eee329978eae57e0140879a7cb5a19a8e448f4c" translate="yes" xml:space="preserve">
          <source>Verbosely display information about the searching strategy being employed to standard error. The tag name will still be printed to standard out.</source>
          <target state="translated">표준 오류에 사용되는 검색 전략에 대한 정보를 자세하게 표시합니다. 태그 이름은 여전히 ​​표준 출력으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="17eca013b0d71c76732d4067f559197bffc5dc5a" translate="yes" xml:space="preserve">
          <source>Verbosity: let &lt;code&gt;cvsimport&lt;/code&gt; report what it is doing.</source>
          <target state="translated">자세한 정보 : &lt;code&gt;cvsimport&lt;/code&gt; 가 수행중인 작업을보고 하도록 합니다.</target>
        </trans-unit>
        <trans-unit id="43241483b8c2e2b351480246076bc9d9d3aeeb38" translate="yes" xml:space="preserve">
          <source>Verifies the connectivity and validity of the objects in the database</source>
          <target state="translated">데이터베이스에서 객체의 연결성과 유효성을 확인합니다</target>
        </trans-unit>
        <trans-unit id="083f6e6fa7581860cb22a12637eec790f2c234d9" translate="yes" xml:space="preserve">
          <source>Verifies the connectivity and validity of the objects in the database.</source>
          <target state="translated">데이터베이스에서 오브젝트의 연결성과 유효성을 검증합니다.</target>
        </trans-unit>
        <trans-unit id="6f20b572e11a287b2200fc3c18b3124b41ee5e40" translate="yes" xml:space="preserve">
          <source>Verify &amp;lt;ref&amp;gt; against &amp;lt;oldvalue&amp;gt; but do not change it. If &amp;lt;oldvalue&amp;gt; is zero or missing, the ref must not exist.</source>
          <target state="translated">&amp;lt;oldvalue&amp;gt;에 대해 &amp;lt;ref&amp;gt;를 확인하되 변경하지 마십시오. &amp;lt;oldvalue&amp;gt;가 0이거나 누락 된 경우 참조가 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="121ce6e2fb35359b4c456b6cab91a3389a1154d2" translate="yes" xml:space="preserve">
          <source>Verify &amp;lt;ref&amp;gt; against &amp;lt;oldvalue&amp;gt; but do not change it. If &amp;lt;oldvalue&amp;gt; zero or missing, the ref must not exist.</source>
          <target state="translated">&amp;lt;oldvalue&amp;gt;에 대해 &amp;lt;ref&amp;gt;를 확인하지만 변경하지 마십시오. &amp;lt;oldvalue&amp;gt;가 0이거나 누락 된 경우 심판이 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="f2a6ea4dcf4e13700439c2c62eb9c887c3645654" translate="yes" xml:space="preserve">
          <source>Verify that everything reachable from target is fetched. Used after an earlier fetch is interrupted.</source>
          <target state="translated">대상에서 도달 가능한 모든 항목을 가져 왔는지 확인하십시오. 이전 반입이 중단 된 후 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dc19dfe6277cd8889c0ce32fc30714a767c456fd" translate="yes" xml:space="preserve">
          <source>Verify that exactly one parameter is provided, and that it can be turned into a raw 20-byte SHA-1 that can be used to access the object database. If so, emit it to the standard output; otherwise, error out.</source>
          <target state="translated">정확히 하나의 매개 변수가 제공되고 오브젝트 데이터베이스에 액세스하는 데 사용할 수있는 원시 20 바이트 SHA-1로 변환 될 수 있는지 확인하십시오. 그렇다면 표준 출력으로 방출하십시오. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e921c65f691e2b371e3e29dc398bb292612d2860" translate="yes" xml:space="preserve">
          <source>Verify that the tip commit of the side branch being merged is signed with a valid key, i.e. a key that has a valid uid: in the default trust model, this means the signing key has been signed by a trusted key. If the tip commit of the side branch is not signed with a valid key, the merge is aborted.</source>
          <target state="translated">병합되는 사이드 브랜치의 팁 커밋이 유효한 키, 즉 유효한 uid가있는 키로 서명되었는지 확인하십시오. 기본 신뢰 모델에서 이는 서명 키가 신뢰할 수있는 키로 서명되었음을 의미합니다. 사이드 브랜치의 팁 커밋이 유효한 키로 서명되지 않은 경우 병합이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="baf3600caf9cbc675ef33fe6c51f69bd006b47ea" translate="yes" xml:space="preserve">
          <source>Verify the GPG signature of the given tag names.</source>
          <target state="translated">주어진 태그 이름의 GPG 서명을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2977304de3538ddff5d274481548280fa86926b6" translate="yes" xml:space="preserve">
          <source>Verify the MIDX file for the packfiles in the current .git folder.</source>
          <target state="translated">현재 .git 폴더에서 팩 파일에 대한 MIDX 파일을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="593811a1bcc6cbc445bcfa7fdf52e4a760c41784" translate="yes" xml:space="preserve">
          <source>Verify the contents of the MIDX file.</source>
          <target state="translated">MIDX 파일의 내용을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="63de76d12bfde7fe2c14402fe2f03160cc3a7318" translate="yes" xml:space="preserve">
          <source>Version 1 porcelain format is similar to the short format, but is guaranteed not to change in a backwards-incompatible way between Git versions or based on user configuration. This makes it ideal for parsing by scripts. The description of the short format above also describes the porcelain format, with a few exceptions:</source>
          <target state="translated">버전 1 도자기 형식은 짧은 형식과 유사하지만 Git 버전간에 또는 사용자 구성에 따라 이전 버전과 호환되지 않는 방식으로 변경되지 않습니다. 따라서 스크립트로 구문 분석하는 데 이상적입니다. 위의 짧은 형식에 대한 설명은 몇 가지 예외를 제외하고 도자기 형식에 대해서도 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1bb30898712789d3819631e4bb7ad8cf32d20671" translate="yes" xml:space="preserve">
          <source>Version 1 takes two arguments, a version (1) and the time in elapsed nanoseconds since midnight, January 1, 1970.</source>
          <target state="translated">버전 1은 버전 (1)과 1970 년 1 월 1 일 자정 이후 경과 된 시간 (나노초)이라는 두 개의 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="33e409adcd5a97d5085c0477fcb4b42dc9a034a9" translate="yes" xml:space="preserve">
          <source>Version 2 format adds more detailed information about the state of the worktree and changed items. Version 2 also defines an extensible set of easy to parse optional headers.</source>
          <target state="translated">버전 2 형식은 작업 트리 상태 및 변경된 항목에 대한 자세한 정보를 추가합니다. 버전 2는 확장 가능한 파싱 옵션 헤더 세트도 정의합니다.</target>
        </trans-unit>
        <trans-unit id="2b8063c91f48f5daba279d42a4965f292b8198dd" translate="yes" xml:space="preserve">
          <source>Version 2 pack-*.idx files support packs larger than 4 gib, and</source>
          <target state="translated">버전 2 pack-*. idx 파일은 4 gib보다 큰 팩을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="76b6cb1496a78fff149bd68b719a91ca0d69c9df" translate="yes" xml:space="preserve">
          <source>Version 2 takes two arguments, a version (2) and a token that is used for identifying changes since the token. For watchman this would be a clock id. This version must output to stdout the new token followed by a NUL before the list of files.</source>
          <target state="translated">버전 2는 버전 (2)과 토큰 이후 변경 사항을 식별하는 데 사용되는 토큰이라는 두 개의 인수를 사용합니다. 파수꾼의 경우 이것은 시계 ID입니다. 이 버전은 파일 목록 앞에 NUL이 뒤 따르는 새 토큰을 stdout으로 출력해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a28a75eceea6b3fb1730e69daff64901cead811" translate="yes" xml:space="preserve">
          <source>Version 4 performs a simple pathname compression that reduces index size by 30%-50% on large repositories, which results in faster load time. Version 4 is relatively young (first released in 1.8.0 in October 2012). Other Git implementations such as JGit and libgit2 may not support it yet.</source>
          <target state="translated">버전 4는 간단한 경로 이름 압축을 수행하여 큰 저장소에서 색인 크기를 30 % -50 % 줄이므로로드 시간이 단축됩니다. 버전 4는 비교적 젊습니다 (2012 년 10 월 1.8.0에 처음 릴리스 됨). JGit 및 libgit2와 같은 다른 Git 구현은 아직 지원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b61ffa7c699cf77c98fcf76236048d42ca5d233" translate="yes" xml:space="preserve">
          <source>Version &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">버전 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fc1164df4f366b4e06ce848f94e3799671648de" translate="yes" xml:space="preserve">
          <source>Version &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">버전 &lt;code&gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26980b77b1e7ef480646032aebce78732551db11" translate="yes" xml:space="preserve">
          <source>Versions of Git older than 1.7.7 don&amp;rsquo;t know about the &lt;code&gt;tar.gz&lt;/code&gt; format, you&amp;rsquo;ll need to use gzip explicitly:</source>
          <target state="translated">1.7.7 이전의 Git 버전은 &lt;code&gt;tar.gz&lt;/code&gt; 형식을 알지 못하므로 gzip을 명시 적으로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="48cda44638e8ce2f3c6e764951e4cd137e88bacc" translate="yes" xml:space="preserve">
          <source>Via the alternates mechanism, a &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; can inherit part of its &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt; from another object database, which is called an &quot;alternate&quot;.</source>
          <target state="translated">대체 메커니즘을 통해 &lt;a href=&quot;#def_repository&quot;&gt;저장소&lt;/a&gt; 는 &quot;대체&quot;라고하는 다른 오브젝트 데이터베이스에서 &lt;a href=&quot;#def_object_database&quot;&gt;오브젝트 데이터베이스의&lt;/a&gt; 일부를 상속 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d75bfce3768015c62af9c4bd29fd7cad894764e0" translate="yes" xml:space="preserve">
          <source>Viewing everything that was changed in a revision, and step through revisions one at a time, viewing the history of the repository.</source>
          <target state="translated">개정판에서 변경된 모든 내용을보고 한 번에 하나씩 개정판을 통해 저장소의 히스토리를보십시오.</target>
        </trans-unit>
        <trans-unit id="8e797001d4524362e7db8f18210266901eb28403" translate="yes" xml:space="preserve">
          <source>Viewing files in GUI tools</source>
          <target state="translated">GUI 도구에서 파일보기</target>
        </trans-unit>
        <trans-unit id="05c33ea7de1cccd62a72042e46bec3b3d340cf9f" translate="yes" xml:space="preserve">
          <source>Viewing multiple Git repositories with common root.</source>
          <target state="translated">공통 루트로 여러 Git 리포지토리보기</target>
        </trans-unit>
        <trans-unit id="1439a80405107c5dd4ca129513bf97eb92ca8c3f" translate="yes" xml:space="preserve">
          <source>Viewing old file versions</source>
          <target state="translated">이전 파일 버전보기</target>
        </trans-unit>
        <trans-unit id="cba1ab24737b9af4081eae74baa579853869959f" translate="yes" xml:space="preserve">
          <source>Viewing project history</source>
          <target state="translated">프로젝트 히스토리보기</target>
        </trans-unit>
        <trans-unit id="48e788f7b4905bc5801452134707bb74e1fddd3c" translate="yes" xml:space="preserve">
          <source>Viewing the blame/annotation details of any file (if enabled).</source>
          <target state="translated">모든 파일의 책임 / 주석 세부 정보보기 (활성화 된 경우).</target>
        </trans-unit>
        <trans-unit id="afd57038f9956faea3beadae2f663a8f18e1dd6a" translate="yes" xml:space="preserve">
          <source>Viewing the contents of files in the repository at any revision.</source>
          <target state="translated">개정판에서 저장소의 파일 내용보기</target>
        </trans-unit>
        <trans-unit id="79e8c237bcc343324671ba4de89f13c4632b7437" translate="yes" xml:space="preserve">
          <source>Viewing the revision log of branches, history of files and directories, see what was changed when, by who.</source>
          <target state="translated">분기의 개정 로그, 파일 및 디렉토리 기록을보고 누가 언제 변경했는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5d3b4279714ad2970a30b9dfdfce1d9cde0d271d" translate="yes" xml:space="preserve">
          <source>Voila.</source>
          <target state="translated">Voila.</target>
        </trans-unit>
        <trans-unit id="f7dda342bfe7129409283096bf9eae6889a3617d" translate="yes" xml:space="preserve">
          <source>Waiting $&amp;lt;int&amp;gt; seconds before reconnecting to SMTP server. Used together with --batch-size option. Defaults to the &lt;code&gt;sendemail.smtpReloginDelay&lt;/code&gt; configuration variable.</source>
          <target state="translated">SMTP 서버에 다시 연결하기 전에 $ &amp;lt;int&amp;gt; 초 동안 대기 중입니다. --batch-size 옵션과 함께 사용됩니다. &lt;code&gt;sendemail.smtpReloginDelay&lt;/code&gt; 구성 변수가 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="6abfc589b188840a4520edd8282e2221d54aed84" translate="yes" xml:space="preserve">
          <source>Walk history forward instead of backward. Instead of showing the revision in which a line appeared, this shows the last revision in which a line has existed. This requires a range of revision like START..END where the path to blame exists in START. &lt;code&gt;git blame --reverse START&lt;/code&gt; is taken as &lt;code&gt;git blame
--reverse START..HEAD&lt;/code&gt; for convenience.</source>
          <target state="translated">뒤로가 아니라 앞으로 걸어가십시오. 선이 나타난 개정을 표시하는 대신 선이 존재하는 마지막 개정을 표시합니다. 이것은 비난의 경로가 START에 존재하는 START..END와 같은 범위의 수정이 필요합니다. &lt;code&gt;git blame --reverse START&lt;/code&gt; 는 편의상 &lt;code&gt;git blame --reverse START..HEAD&lt;/code&gt; 로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="246770a4db6a59723366cd008c0806351012631a" translate="yes" xml:space="preserve">
          <source>Walk through the patches in the series and warn if we cannot find all of the necessary information to commit a patch. At the time of this writing only missing author information is warned about.</source>
          <target state="translated">시리즈의 패치를 살펴보고 패치를 커밋하는 데 필요한 정보를 모두 찾을 수없는 경우 경고합니다. 이 글을 쓰는 시점에는 누락 된 저자 정보 만 경고됩니다.</target>
        </trans-unit>
        <trans-unit id="8741434725596a0a6dcba1ea6ce0540165fbeb38" translate="yes" xml:space="preserve">
          <source>Warn if changes introduce conflict markers or whitespace errors. What are considered whitespace errors is controlled by &lt;code&gt;core.whitespace&lt;/code&gt; configuration. By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors. Exits with non-zero status if problems are found. Not compatible with --exit-code.</source>
          <target state="translated">변경으로 인해 충돌 마커 또는 공백 오류가 발생하면 경고합니다. 공백 오류로 간주되는 것은 &lt;code&gt;core.whitespace&lt;/code&gt; 구성에 의해 제어됩니다 . 기본적으로 후행 공백 (공백만으로 구성되는 줄 포함)과 줄의 처음 들여 쓰기 안에 탭 문자 바로 뒤에 오는 공백 문자는 공백 오류로 간주됩니다. 문제가 발견되면 0이 아닌 상태로 종료합니다. --exit-code와 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0219dea42624b30174e17cfd1bb37d7d1a042a1" translate="yes" xml:space="preserve">
          <source>Warn of patches that contain lines longer than 998 characters unless a suitable transfer encoding (&lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;base64&lt;/code&gt;, or &lt;code&gt;quoted-printable&lt;/code&gt;) is used; this is due to SMTP limits as described by &lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;http://www.ietf.org/rfc/rfc5322.txt&lt;/a&gt;.</source>
          <target state="translated">적절한 전송 인코딩 ( &lt;code&gt;auto&lt;/code&gt; , &lt;code&gt;base64&lt;/code&gt; 또는 &lt;code&gt;quoted-printable&lt;/code&gt; )을 사용 하지 않는 한 998자를 초과하는 행이 포함 된 패치에 대해 경고합니다 . 이는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;http://www.ietf.org/rfc/rfc5322.txt에&lt;/a&gt; 설명 된 SMTP 제한으로 인한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="d9a62a2598117c2be58c53a722de6576cd225a89" translate="yes" xml:space="preserve">
          <source>Warnings are printed on the standard error output for any explicitly unsupported constructs, and any other lines that are not recognized by the parser.</source>
          <target state="translated">명시 적으로 지원되지 않는 구성 및 구문 분석기가 인식하지 못하는 다른 행에 대해서는 표준 오류 출력에 경고가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="54490e8680807566a4db5e14166b54af9ee18d68" translate="yes" xml:space="preserve">
          <source>We already saw in &lt;a href=&quot;#understanding-commits&quot;&gt;Understanding History: Commits&lt;/a&gt; that all commits are stored under a 40-digit &quot;object name&quot;. In fact, all the information needed to represent the history of a project is stored in objects with such names. In each case the name is calculated by taking the SHA-1 hash of the contents of the object. The SHA-1 hash is a cryptographic hash function. What that means to us is that it is impossible to find two different objects with the same name. This has a number of advantages; among others:</source>
          <target state="translated">우리는 이미 &lt;a href=&quot;#understanding-commits&quot;&gt;이력 이해 : 커밋&lt;/a&gt; 에서 모든 커밋이 40 자리 &quot;객체 이름&quot;으로 저장되어 있음을 보았습니다 . 실제로 프로젝트 히스토리를 나타내는 데 필요한 모든 정보는 해당 이름을 가진 오브젝트에 저장됩니다. 각각의 경우에 이름은 객체 내용의 SHA-1 해시를 사용하여 계산됩니다. SHA-1 해시는 암호화 해시 기능입니다. 그것이 우리에게 의미하는 것은 같은 이름을 가진 두 개의 다른 물체를 찾는 것이 불가능하다는 것입니다. 여기에는 여러 가지 장점이 있습니다. 다른 것들 중에서 :</target>
        </trans-unit>
        <trans-unit id="d6fd523936a98d1231393ad2931c9779a4d79b0e" translate="yes" xml:space="preserve">
          <source>We are looking for a &quot;best&quot; explanation of the new series in terms of the old one. We can represent an &quot;explanation&quot; as an edge in the graph:</source>
          <target state="translated">우리는 이전 시리즈와 관련하여 새로운 시리즈에 대한 &quot;최상의&quot;설명을 찾고 있습니다. 그래프에서 &quot;설명&quot;을 모서리로 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b940c15e60e8d5e30f8f0dd6fb317eefa03a3c7" translate="yes" xml:space="preserve">
          <source>We assume that GITWEB_CONFIG has its default Makefile value, namely &lt;code&gt;gitweb_config.perl&lt;/code&gt;. Put the following in &lt;code&gt;gitweb_make_index.perl&lt;/code&gt; file:</source>
          <target state="translated">우리는 GITWEB_CONFIG는 기본 메이크 값, 즉이 있다고 가정 &lt;code&gt;gitweb_config.perl&lt;/code&gt; 을 . &lt;code&gt;gitweb_make_index.perl&lt;/code&gt; 파일에 다음을 입력 하십시오.</target>
        </trans-unit>
        <trans-unit id="860f449f084465687d5f3065e9dcdf4471fe0c53" translate="yes" xml:space="preserve">
          <source>We assume the following in /etc/services</source>
          <target state="translated">/ etc / services에서 다음을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e666201c4a3affd420bf339541f1e66f556269f5" translate="yes" xml:space="preserve">
          <source>We assume you have already created a Git repository for your project, possibly created from scratch or from a tarball (see &lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt;), or imported from an already existing CVS repository (see the next section).</source>
          <target state="translated">프로젝트를 위해 Git 저장소를 이미 작성했거나 처음부터 또는 tarball ( &lt;a href=&quot;gittutorial&quot;&gt;gittutorial [7]&lt;/a&gt; 참조 )로 작성했거나 기존 CVS 저장소에서 가져온 것으로 가정합니다 (다음 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="a35a2d4ac8af99272cba8ca44431c44847ef0735" translate="yes" xml:space="preserve">
          <source>We can also create a tag to refer to a particular commit; after running</source>
          <target state="translated">특정 커밋을 나타내는 태그를 만들 수도 있습니다. 실행 후</target>
        </trans-unit>
        <trans-unit id="ec584a188dcd2e25a99263b54f2feb909dc57e99" translate="yes" xml:space="preserve">
          <source>We can ask Git about this particular object with the &lt;code&gt;cat-file&lt;/code&gt; command. Don&amp;rsquo;t copy the 40 hex digits from this example but use those from your own version. Note that you can shorten it to only a few characters to save yourself typing all 40 hex digits:</source>
          <target state="translated">&lt;code&gt;cat-file&lt;/code&gt; 명령으로 Git에게이 특정 객체에 대해 물어볼 수 있습니다 . 이 예에서 40 자리 16 진수를 복사하지 말고 사용자 고유 버전의 숫자를 사용하십시오. 40 자릿수를 모두 입력하면 자신을 저장하기 위해 몇 자로 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d0c7ad92eed63e4b86ed7fcdbe0a2af116dc20a" translate="yes" xml:space="preserve">
          <source>We can further investigate the time spent scanning for untracked files.</source>
          <target state="translated">추적되지 않은 파일을 검색하는 데 걸린 시간을 추가로 조사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14c5f91f2f30d67e424b3d8fa6177783e08a84fd" translate="yes" xml:space="preserve">
          <source>We can get just the branch-head names, and remove &lt;code&gt;master&lt;/code&gt;, with the help of the standard utilities cut and grep:</source>
          <target state="translated">표준 유틸리티 cut 및 grep을 사용 하여 브랜치 헤드 이름 만 가져오고 &lt;code&gt;master&lt;/code&gt; 를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a00f6027326a1e03d87c7714c37d6396c5fc0f07" translate="yes" xml:space="preserve">
          <source>We can get this using the following command:</source>
          <target state="translated">다음 명령을 사용하여이를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="308213d749ac73498be48acb36aa505b62d477c8" translate="yes" xml:space="preserve">
          <source>We can give this name to &lt;code&gt;git show&lt;/code&gt; to see the details about this commit.</source>
          <target state="translated">이 커밋에 대한 세부 사항을보기 위해이 이름을 &lt;code&gt;git show&lt;/code&gt; 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="164a7b582707458e7c29a45bdd3cb932a29b3ca1" translate="yes" xml:space="preserve">
          <source>We can list all the heads in this repository with &lt;a href=&quot;git-show-ref&quot;&gt;git-show-ref[1]&lt;/a&gt;:</source>
          <target state="translated">이 저장소의 모든 헤드를 &lt;a href=&quot;git-show-ref&quot;&gt;git-show-ref [1]로&lt;/a&gt; 나열 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3342879e047ae36a38db13969064b38d54ccc902" translate="yes" xml:space="preserve">
          <source>We divide Git into high level (&quot;porcelain&quot;) commands and low level (&quot;plumbing&quot;) commands.</source>
          <target state="translated">Git을 상위 레벨 ( &quot;porcelain&quot;) 명령과 하위 레벨 ( &quot;plumbing&quot;) 명령으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="011f9d254149abd4e25f111f5f8f2bc847e7e4cc" translate="yes" xml:space="preserve">
          <source>We explain how to do this in the following sections.</source>
          <target state="translated">다음 섹션에서이를 수행하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4822ab43c46db1b5802e2f53899245649e4398bd" translate="yes" xml:space="preserve">
          <source>We formulate a set of &lt;code&gt;rules&lt;/code&gt; for quick reference, while the prose tries to motivate each of them. Do not always take them literally; you should value good reasons for your actions higher than manpages such as this one.</source>
          <target state="translated">우리는 빠른 참조를 위해 일련의 &lt;code&gt;rules&lt;/code&gt; 을 구성하는 반면, 산문은 각각의 규칙 에 동기를 부여하려고 시도합니다. 항상 문자 그대로 받아들이지 마십시오. 이 같은 맨 페이지보다 높은 작업을 수행해야하는 적절한 이유를 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="27af85d69b0e1da45afccff7b9c2331995331c55" translate="yes" xml:space="preserve">
          <source>We found that most commits on the graph may give quite a lot of information when they are tested. And the commits that will not on average give a lot of information are the one near the good and bad commits.</source>
          <target state="translated">그래프에 대한 대부분의 커밋은 테스트 할 때 많은 정보를 제공 할 수 있음을 발견했습니다. 그리고 평균적으로 많은 정보를 제공하지 않는 커밋은 좋은 커밋과 나쁜 커밋에 가까운 것입니다.</target>
        </trans-unit>
        <trans-unit id="319c4fde5f53d3ebfff60d2ca81633ff5c5e7332" translate="yes" xml:space="preserve">
          <source>We have already seen &lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;how to keep remote-tracking branches up to date&lt;/a&gt; with &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;, and how to merge two branches. So you can merge in changes from the original repository&amp;rsquo;s master branch with:</source>
          <target state="translated">우리는 이미 본 &lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;최신 지점을 원격 추적 유지하는 방법&lt;/a&gt; 과 &lt;a href=&quot;git-fetch&quot;&gt;[1] 자식 페치&lt;/a&gt; 및 방법 두 가지를 병합 할 수 있습니다. 따라서 원본 리포지토리의 마스터 브랜치에서 변경 사항을 다음과 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9313b2be3fe8f9ef5431fd57e740ed2c389d7c2c" translate="yes" xml:space="preserve">
          <source>We have already seen how branches work previously, with &quot;fun and work&quot; example using two branches. The idea is the same if there are more than two branches. Let&amp;rsquo;s say you started out from &quot;master&quot; head, and have some new code in the &quot;master&quot; branch, and two independent fixes in the &quot;commit-fix&quot; and &quot;diff-fix&quot; branches:</source>
          <target state="translated">우리는 이미 두 가지를 사용하는 &quot;재미와 일&quot;예제와 함께 가지가 이전에 어떻게 작동하는지 보았습니다. 가지가 두 개 이상인 경우에도 같은 생각입니다. &quot;마스터&quot;헤드에서 시작하여 &quot;마스터&quot;분기에 새로운 코드가 있고 &quot;커밋 수정&quot;및 &quot;diff-fix&quot;분기에 두 개의 독립적 인 수정이 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="1170354586d8db2806a89632eb01397ff1d5b39a" translate="yes" xml:space="preserve">
          <source>We have seen several ways of naming commits already:</source>
          <target state="translated">커밋의 이름을 지정하는 몇 가지 방법이 이미 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea2d131015439270646c4d9deb94b3238eec4d65" translate="yes" xml:space="preserve">
          <source>We have seen that regressions are an important problem, and that &quot;git bisect&quot; has nice features that complement very well practices and other tools, especially test suites, that are generally used to fight regressions. But it might be needed to change some work-flows and (bad) habits to get the most out of it.</source>
          <target state="translated">우리는 회귀가 중요한 문제이며 &quot;git bisect&quot;는 일반적으로 회귀와 싸우는 데 사용되는 다른 도구, 특히 테스트 스위트를 보완하는 훌륭한 기능을 가지고 있음을 알았습니다. 그러나 그것을 최대한 활용하기 위해 일부 작업 흐름과 (나쁜) 습관을 변경해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="58d71328c844eab6bb246a8885f29a926cbaf29b" translate="yes" xml:space="preserve">
          <source>We have seen that test suites and git bisect are very powerful when used together. It can be even more powerful if you can combine them with other systems.</source>
          <target state="translated">우리는 테스트 스위트와 git bisect가 함께 사용될 때 매우 강력하다는 것을 알았습니다. 다른 시스템과 결합 할 수 있다면 더욱 강력해질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dc1429b571e4014b12f464201faf90142f01343" translate="yes" xml:space="preserve">
          <source>We ignore all SVN properties except svn:executable. Any unhandled properties are logged to $GIT_DIR/svn/&amp;lt;refname&amp;gt;/unhandled.log</source>
          <target state="translated">svn : executable을 제외한 모든 SVN 속성은 무시합니다. 처리되지 않은 속성은 $ GIT_DIR / svn / &amp;lt;refname&amp;gt; /unhandled.log에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="5e0e70c2a550cebe0f64341bc25aba4f82846837" translate="yes" xml:space="preserve">
          <source>We said this tutorial shows what plumbing does to help you cope with the porcelain that isn&amp;rsquo;t flushing, but we so far did not talk about how the merge really works. If you are following this tutorial the first time, I&amp;rsquo;d suggest to skip to &quot;Publishing your work&quot; section and come back here later.</source>
          <target state="translated">이 튜토리얼에서는 플러싱되지 않은 도자기에 대처하기 위해 배관이 무엇을하는지 보여 주지만 지금까지 병합이 실제로 어떻게 작동하는지에 대해서는 이야기하지 않았습니다. 이 튜토리얼을 처음 수행하는 경우 &quot;작업 게시&quot;섹션으로 건너 뛰고 나중에 다시 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="038e0426e816e440e5c183b0ccfae9faca0c65b5" translate="yes" xml:space="preserve">
          <source>We saw above that &lt;code&gt;origin&lt;/code&gt; is just a shortcut to refer to the repository that you originally cloned from. This information is stored in Git configuration variables, which you can see using &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;:</source>
          <target state="translated">위에서 본 &lt;code&gt;origin&lt;/code&gt; 은 원래 복제 한 저장소를 나타내는 바로 가기 일뿐입니다. 이 정보는 Git 구성 변수에 저장되며 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 사용하여 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="789eeb5f51968bf21d9746b92623ca08838d8bcb" translate="yes" xml:space="preserve">
          <source>We saw earlier that &quot;git bisect skip&quot; is now using a PRNG to try to avoid areas in the commit graph where commits are untestable. The problem is that sometimes the first bad commit will be in an untestable area.</source>
          <target state="translated">&quot;git bisect skip&quot;은 이제 커밋을 테스트 할 수없는 커밋 그래프의 영역을 피하기 위해 PRNG를 사용하고 있음을 알았습니다. 문제는 때때로 첫 번째 잘못된 커밋이 테스트 할 수없는 영역에 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e6f53989efc34bb4d6e54dcd09f15943b6a8a36c" translate="yes" xml:space="preserve">
          <source>We saw in &lt;a href=&quot;#conflict-resolution&quot;&gt;Getting conflict-resolution help during a merge&lt;/a&gt; that during a merge the index can store multiple versions of a single file (called &quot;stages&quot;). The third column in the &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files[1]&lt;/a&gt; output above is the stage number, and will take on values other than 0 for files with merge conflicts.</source>
          <target state="translated">&lt;a href=&quot;#conflict-resolution&quot;&gt;병합 중 충돌 해결 도움말 얻기&lt;/a&gt; 에서 병합 중 색인이 단일 파일의 여러 버전 ( &quot;스테이지&quot;)을 저장할 수 있다는 것을 알았습니다 . 위의 &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files [1]&lt;/a&gt; 출력 에서 세 번째 열 은 스테이지 번호이며 병합 충돌이있는 파일의 경우 0 이외의 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d5d682276e6a6d081a241de022b4ded4aef9c418" translate="yes" xml:space="preserve">
          <source>We saw in &lt;a href=&quot;#fixing-a-mistake-by-rewriting-history&quot;&gt;Fixing a mistake by rewriting history&lt;/a&gt; that you can replace the most recent commit using</source>
          <target state="translated">가장 최근의 커밋을 대체 할 수있는 &lt;a href=&quot;#fixing-a-mistake-by-rewriting-history&quot;&gt;기록&lt;/a&gt; 을 다시 작성하여 실수 를 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="aafdc07c8e0d9b297fcdd505608f380ef754ed45" translate="yes" xml:space="preserve">
          <source>We saw in part one of the tutorial that commits have names like this. It turns out that every object in the Git history is stored under a 40-digit hex name. That name is the SHA-1 hash of the object&amp;rsquo;s contents; among other things, this ensures that Git will never store the same data twice (since identical data is given an identical SHA-1 name), and that the contents of a Git object will never change (since that would change the object&amp;rsquo;s name as well). The 7 char hex strings here are simply the abbreviation of such 40 character long strings. Abbreviations can be used everywhere where the 40 character strings can be used, so long as they are unambiguous.</source>
          <target state="translated">우리는 튜토리얼의 한 부분에서 커밋이 이와 같은 이름을 갖는 것을 보았습니다. Git 히스토리의 모든 객체는 40 자리 16 진수 이름으로 저장됩니다. 그 이름은 객체 내용의 SHA-1 해시입니다. 무엇보다도 이것은 Git이 동일한 데이터를 두 번 저장하지 않도록하고 (동일한 데이터에 동일한 SHA-1 이름이 주어지기 때문에) Git 객체의 내용이 절대로 변경되지 않도록합니다 (오브젝트의 이름도 변경하기 때문에) ). 여기서 7 자리 16 진수 문자열은 단순히 40 자 길이의 약어입니다. 40 개의 문자열을 사용할 수있는 곳이라면 어디에서나 약어를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09c046487d09b436218fe11aa8c1087251442281" translate="yes" xml:space="preserve">
          <source>We separate the porcelain commands into the main commands and some ancillary user utilities.</source>
          <target state="translated">우리는 도자기 명령을 기본 명령과 일부 보조 사용자 유틸리티로 분리합니다.</target>
        </trans-unit>
        <trans-unit id="f2e875357a5ce85901234308b841a3138ebd851b" translate="yes" xml:space="preserve">
          <source>We should point out that &quot;habitually&quot; (regularly for no real reason) merging an integration branch into your topics &amp;mdash; and by extension, merging anything upstream into anything downstream on a regular basis &amp;mdash; is frowned upon:</source>
          <target state="translated">우리는 통합 지점을 당신의 주제에 합병시키는 &quot;거의&quot;(일반적으로 아무 이유없이) 정기적으로 다운 스트림에 상류의 것을 합병시키는 것을 다음과 같이 눈살을 찌푸리게합니다.</target>
        </trans-unit>
        <trans-unit id="3b0c2056ade966758c96efbd333ad03c787ca3ac" translate="yes" xml:space="preserve">
          <source>We start with one specialized tool that is useful for finding the commit that introduced a bug into a project.</source>
          <target state="translated">프로젝트에 버그를 도입 한 커밋을 찾는 데 유용한 하나의 특수 도구로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="3bb7fbe62fd9b3fa1a7f67f6a431251fe7b02079" translate="yes" xml:space="preserve">
          <source>We start with the most important, the &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt; and the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">가장 중요한 &lt;a href=&quot;#def_object_database&quot;&gt;객체 데이터베이스&lt;/a&gt; 와 &lt;a href=&quot;#def_index&quot;&gt;index로 시작&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="fa1acdd625946113b786a5983b045431892f2e96" translate="yes" xml:space="preserve">
          <source>We supposed in the previous examples that the &quot;good&quot; commits were ancestors of the &quot;bad&quot; commit. But this is not a requirement of &quot;git bisect&quot;.</source>
          <target state="translated">앞의 예에서 &quot;좋은&quot;커밋은 &quot;나쁜&quot;커밋의 조상이라고 가정했습니다. 그러나 이것은 &quot;git bisect&quot;의 요구 사항은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="09e675bfb62532c536d372645ebddf19b07c5684" translate="yes" xml:space="preserve">
          <source>We want to make &lt;code&gt;topic&lt;/code&gt; forked from branch &lt;code&gt;master&lt;/code&gt;; for example, because the functionality on which &lt;code&gt;topic&lt;/code&gt; depends was merged into the more stable &lt;code&gt;master&lt;/code&gt; branch. We want our tree to look like this:</source>
          <target state="translated">우리는 브랜치 &lt;code&gt;master&lt;/code&gt; 로부터 &lt;code&gt;topic&lt;/code&gt; 를 분기 시키려고합니다 . 예를 들어, &lt;code&gt;topic&lt;/code&gt; 의존 하는 기능 이보다 안정적인 &lt;code&gt;master&lt;/code&gt; 브랜치 로 병합 되었기 때문 입니다. 우리는 나무가 다음과 같이 보이기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="0fa006b18282abd83f954d3423dfd83f70f68c0d" translate="yes" xml:space="preserve">
          <source>We will introduce some tools that can help you do this, explain how to use them, and then explain some of the problems that can arise because you are rewriting history.</source>
          <target state="translated">이 작업을 수행하는 데 도움이되는 몇 가지 도구를 소개하고 사용 방법을 설명한 다음 기록을 다시 작성하여 발생할 수있는 몇 가지 문제에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e34d86d215639adac5ecaa74d7f70d803a2ef9de" translate="yes" xml:space="preserve">
          <source>We will sometimes represent Git history using diagrams like the one below. Commits are shown as &quot;o&quot;, and the links between them with lines drawn with - / and \. Time goes left to right:</source>
          <target state="translated">때때로 아래와 같은 다이어그램을 사용하여 Git 히스토리를 표현할 것입니다. 커밋은 &quot;o&quot;로 표시되고-/ 및 \로 그려진 선으로 링크가 연결됩니다. 시간은 왼쪽에서 오른쪽으로갑니다.</target>
        </trans-unit>
        <trans-unit id="ab9fd84ced67b4e6059fb12091ba4144199c5397" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll assume that the problem is a single missing or corrupted blob, which is sometimes a solvable problem. (Recovering missing trees and especially commits is &lt;strong&gt;much&lt;/strong&gt; harder).</source>
          <target state="translated">우리는 문제가 하나의 누락되거나 손상된 얼룩이라고 가정하며 때로는 해결할 수있는 문제입니다. 누락 된 트리 및 특히 커밋을 복구하는 것이 &lt;strong&gt;훨씬&lt;/strong&gt; 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="2aa7b1ec194976812ce4b6b3f7e0ba34eba549a8" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll keep this simple and stupid, so we&amp;rsquo;ll start off with populating a few trivial files just to get a feel for it.</source>
          <target state="translated">우리는 이것을 간단하고 어리석게 유지할 것이므로, 간단한 파일을 채우는 것으로 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="2d4db37414a68811cd95f44af4830929ada62273" translate="yes" xml:space="preserve">
          <source>Webserver configuration</source>
          <target state="translated">웹 서버 구성</target>
        </trans-unit>
        <trans-unit id="c0f36d74c982d11ffbdfaa17b6ab39308ec52a2f" translate="yes" xml:space="preserve">
          <source>Webserver configuration with multiple projects' root</source>
          <target state="translated">여러 프로젝트 루트가있는 웹 서버 구성</target>
        </trans-unit>
        <trans-unit id="ef6d4f2b2672206d0b50ce512c5b9cc1369fe95f" translate="yes" xml:space="preserve">
          <source>What an alias file in each format looks like can be found in the documentation of the email program of the same name. The differences and limitations from the standard formats are described below:</source>
          <target state="translated">각 형식의 별명 파일은 동일한 이름의 이메일 프로그램 문서에서 찾을 수 있습니다. 표준 형식과의 차이점과 제한 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fa6325f935566c907b8b84855ddf6b390a1827e3" translate="yes" xml:space="preserve">
          <source>What are the 7 digits of hex that Git responded to the commit with?</source>
          <target state="translated">Git이 커밋에 응답 한 16 진수의 7 자리 숫자는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="5fb651419665147da76edfca56099f33ccd0e645" translate="yes" xml:space="preserve">
          <source>What does this mean?</source>
          <target state="translated">이것은 무엇을 의미 하는가?</target>
        </trans-unit>
        <trans-unit id="b77fdbd3385bc488b50aa891b5b4c124304a8f69" translate="yes" xml:space="preserve">
          <source>What is interesting too is that end users that are reporting bugs (or QA people that reproduced a bug) have access to the environment where the bug happens. So they can often more easily reproduce a regression. And if they can bisect, then more information will be extracted from the environment where the bug happens, which means that it will be easier to understand and then fix the bug.</source>
          <target state="translated">흥미로운 점은 버그를보고하는 최종 사용자 (또는 버그를 재현 한 QA 담당자)가 버그가 발생한 환경에 액세스 할 수 있다는 것입니다. 따라서 회귀를보다 쉽게 ​​재현 할 수 있습니다. 그리고 이등분 할 수 있다면 버그가 발생한 환경에서 더 많은 정보가 추출되므로 버그를 이해하고 수정하기가 더 쉬워 질 것입니다.</target>
        </trans-unit>
        <trans-unit id="549056214cd4b23720c4559829b5b36cc5cf6d0c" translate="yes" xml:space="preserve">
          <source>What next?</source>
          <target state="translated">다음은?</target>
        </trans-unit>
        <trans-unit id="fe77441e9cc191fb4a5181d6f98e51e7bf6ce4ab" translate="yes" xml:space="preserve">
          <source>What people don&amp;rsquo;t get is that this is a situation where the &quot;end node principle&quot; applies. When you have limited resources (here: developers) you don&amp;rsquo;t push the bulk of the burden upon them. Instead you push things out to the resource you have a lot of, the end nodes (here: users), so that the situation actually scales.</source>
          <target state="translated">사람들이 얻지 못하는 것은 이것이 &quot;엔드 노드 원칙&quot;이 적용되는 상황이라는 것입니다. 리소스가 제한되어있는 경우 (여기 : 개발자) 해당 리소스에 대한 많은 부담을주지 않습니다. 대신 상황을 실제로 확장 할 수 있도록 많은 최종 노드 (여기서는 사용자)가있는 리소스로 작업을 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="e4950cd435094a3f200db11a5c1b540d80d04769" translate="yes" xml:space="preserve">
          <source>What should you do when you tag a wrong commit and you would want to re-tag?</source>
          <target state="translated">잘못된 커밋에 태그를 지정하고 다시 태그를 지정하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="049920ec0574fb80b08ccee259e5814b007cd44c" translate="yes" xml:space="preserve">
          <source>What the -p option produces is slightly different from the traditional diff format:</source>
          <target state="translated">-p 옵션이 생성하는 내용은 기존의 diff 형식과 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e27b60d4391d6c41de480e30a2d0df50a6723ae8" translate="yes" xml:space="preserve">
          <source>What to do when a push fails</source>
          <target state="translated">푸시 실패시 수행 할 작업</target>
        </trans-unit>
        <trans-unit id="42a1dbf4390cedcf2f183fba444335bae8d5ae11" translate="yes" xml:space="preserve">
          <source>What you chose are then highlighted with &lt;code&gt;*&lt;/code&gt;, like this:</source>
          <target state="translated">선택한 내용은 다음과 같이 &lt;code&gt;*&lt;/code&gt; 로 강조 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="e11a716b5dc9d27d9966b39b2c63b32b4c67e627" translate="yes" xml:space="preserve">
          <source>When &amp;lt;rev&amp;gt; is not specified, the command annotates the changes starting backwards from the working tree copy. This flag makes the command pretend as if the working tree copy has the contents of the named file (specify &lt;code&gt;-&lt;/code&gt; to make the command read from the standard input).</source>
          <target state="translated">&amp;lt;rev&amp;gt;를 지정하지 않으면 명령은 작업 트리 사본에서 거꾸로 시작하여 변경 사항에 주석을 달 수 있습니다. 이 플래그는 작업 트리 사본에 명명 된 파일의 내용이있는 것처럼 명령을 가장합니다 (지정 &lt;code&gt;-&lt;/code&gt; 표준 입력에서 명령을 읽도록 지정 ).</target>
        </trans-unit>
        <trans-unit id="df8212af8d2323e7260f5fa3c4bc0bbc714643ff" translate="yes" xml:space="preserve">
          <source>When --fork-point is active, &lt;code&gt;fork_point&lt;/code&gt; will be used instead of &amp;lt;upstream&amp;gt; to calculate the set of commits to rebase, where &lt;code&gt;fork_point&lt;/code&gt; is the result of &lt;code&gt;git merge-base --fork-point &amp;lt;upstream&amp;gt;
&amp;lt;branch&amp;gt;&lt;/code&gt; command (see &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base[1]&lt;/a&gt;). If &lt;code&gt;fork_point&lt;/code&gt; ends up being empty, the &amp;lt;upstream&amp;gt; will be used as a fallback.</source>
          <target state="translated">--fork-point가 활성화되면 &amp;lt;upstream&amp;gt; 대신 &lt;code&gt;fork_point&lt;/code&gt; 를 사용하여 rebase에 대한 커밋 세트를 계산합니다. 여기서 &lt;code&gt;fork_point&lt;/code&gt; 는 &lt;code&gt;git merge-base --fork-point &amp;lt;upstream&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt; 명령의 결과입니다 ( 참조 &lt;a href=&quot;git-merge-base&quot;&gt;이눔 병합 계를 [1]&lt;/a&gt; ). 경우 &lt;code&gt;fork_point&lt;/code&gt; 끝까지 비어있는,의 &amp;lt;상류&amp;gt;는 대체해서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0b903c4e9a3738f389f65549fe23dcd21fd8909d" translate="yes" xml:space="preserve">
          <source>When --graph is not used, all history branches are flattened which can make it hard to see that the two consecutive commits do not belong to a linear branch. This option puts a barrier in between them in that case. If &lt;code&gt;&amp;lt;barrier&amp;gt;&lt;/code&gt; is specified, it is the string that will be shown instead of the default one.</source>
          <target state="translated">--graph를 사용하지 않으면 모든 히스토리 브랜치가 평평 해져 두 개의 연속 커밋이 선형 브랜치에 속하지 않음을 알기가 어렵습니다. 이 경우이 옵션을 사용하면 그 사이에 장벽이 생깁니다. 경우 &lt;code&gt;&amp;lt;barrier&amp;gt;&lt;/code&gt; 지정, 대신 기본 하나의 표시 될 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="24ff3c267435a7dcecd3166ed52f8210a7c7f0de" translate="yes" xml:space="preserve">
          <source>When --stdout is specified then progress report is displayed during the object count and compression phases but inhibited during the write-out phase. The reason is that in some cases the output stream is directly linked to another command which may wish to display progress status of its own as it processes incoming pack data. This flag is like --progress except that it forces progress report for the write-out phase as well even if --stdout is used.</source>
          <target state="translated">--stdout을 지정하면 객체 수 및 압축 단계에서 진행률 보고서가 표시되지만 쓰기 단계에서는 금지됩니다. 그 이유는 출력 스트림이 다른 명령에 직접 연결되어 들어오는 팩 데이터를 처리 할 때 자체의 진행 상태를 표시하고자 할 수 있기 때문입니다. 이 플래그는 --stdout을 사용하더라도 쓰기 단계에 대한 진행률 보고서를 강제한다는 점을 제외하면 --progress와 같습니다.</target>
        </trans-unit>
        <trans-unit id="d3e80ca53bd7d57db503ac84208eff0dbe6d901f" translate="yes" xml:space="preserve">
          <source>When -k is not in effect, all leading strings bracketed with &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; pairs are stripped. This option limits the stripping to only the pairs whose bracketed string contains the word &quot;PATCH&quot;.</source>
          <target state="translated">-k가 적용되지 않으면 &lt;code&gt;[&lt;/code&gt; 및 &lt;code&gt;]&lt;/code&gt; 쌍으로 묶인 모든 선행 문자열 이 제거됩니다. 이 옵션은 괄호로 묶인 문자열에 &quot;PATCH&quot;라는 단어가 포함 된 쌍으로 만 스트립을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="882475218cb0a9fc17e76a3d4266386adec5dd71" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;$@&quot;&lt;/code&gt; is &lt;code&gt;-h&lt;/code&gt; or &lt;code&gt;--help&lt;/code&gt; in the above example, the following usage text would be shown:</source>
          <target state="translated">때 &lt;code&gt;&quot;$@&quot;&lt;/code&gt; 입니다 &lt;code&gt;-h&lt;/code&gt; 또는 &lt;code&gt;--help&lt;/code&gt; 위의 예에서, 다음 사용 텍스트가 표시 될 것입니다 :</target>
        </trans-unit>
        <trans-unit id="d78a0cbb0812363470a0c64a4a94d40dd1da90bb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--batch-all-objects&lt;/code&gt; is in use, visit objects in an order which may be more efficient for accessing the object contents than hash order. The exact details of the order are unspecified, but if you do not require a specific order, this should generally result in faster output, especially with &lt;code&gt;--batch&lt;/code&gt;. Note that &lt;code&gt;cat-file&lt;/code&gt; will still show each object only once, even if it is stored multiple times in the repository.</source>
          <target state="translated">때 &lt;code&gt;--batch-all-objects&lt;/code&gt; 사용하고, 방문은 해시 위해보다 객체의 내용을 액세스하기위한보다 효율적으로 할 수 순서로 객체. 주문의 정확한 세부 사항은 지정되어 있지 않지만 특정 주문이 필요하지 않은 경우 일반적으로 특히 &lt;code&gt;--batch&lt;/code&gt; 를 사용 하여 더 빠른 출력을 얻을 수 있습니다. 참고 &lt;code&gt;cat-file&lt;/code&gt; 이 저장소에 여러 번 저장되어있는 경우에도, 여전히 한 번만 각 개체를 보여줄 것이다.</target>
        </trans-unit>
        <trans-unit id="95919047a579b82415a0ddd6c6f601bfbb7dc80f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--check&lt;/code&gt; is in effect, or when applying the patch (which is the default when none of the options that disables it is in effect), make sure the patch is applicable to what the current index file records. If the file to be patched in the working tree is not up to date, it is flagged as an error. This flag also causes the index file to be updated.</source>
          <target state="translated">때 &lt;code&gt;--check&lt;/code&gt; 가 유효하거나 패치를 적용 할 때, (기본값 인이 유효 비활성화하는 옵션 중 어느 것도 경우)도하지 않습니다 확인 패치는 무엇 현재 인덱스 파일 레코드에 적용 할 수있다. 작업 트리에 패치 할 파일이 최신이 아닌 경우 오류로 플래그가 지정됩니다. 이 플래그는 또한 색인 파일이 갱신되도록합니다.</target>
        </trans-unit>
        <trans-unit id="526cf7ed548b3415806841ff6b0e065a944a8f5e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--compose&lt;/code&gt; is used, git send-email will use the From, Subject, and In-Reply-To headers specified in the message. If the body of the message (what you type after the headers and a blank line) only contains blank (or Git: prefixed) lines, the summary won&amp;rsquo;t be sent, but From, Subject, and In-Reply-To headers will be used unless they are removed.</source>
          <target state="translated">때 &lt;code&gt;--compose&lt;/code&gt; 가 사용되며, 자식 전송 - 이메일을 조건으로,부터를 사용하고,에서가-회신에 메시지에 지정된 헤더. 메시지 본문 (머리글과 빈 줄 다음에 입력 한 내용)에 빈 (또는 Git : 접두사) 줄만 포함 된 경우 요약이 전송되지 않지만 From, Subject 및 In-Reply-To 헤더는 제거하지 않으면 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="46dc43993fdd7156fca21e87a205fc0f333f2d9a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--cone&lt;/code&gt; is provided, the &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; setting is also set, allowing for better performance with a limited set of patterns (see &lt;code&gt;CONE PATTERN SET&lt;/code&gt; below).</source>
          <target state="translated">때 &lt;code&gt;--cone&lt;/code&gt; 가 제공되면, &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; 의 설정은 패턴 (참조 제한된와 더 나은 성능을 위해 수 있도록 설정되어 &lt;code&gt;CONE PATTERN SET&lt;/code&gt; 아래 참조).</target>
        </trans-unit>
        <trans-unit id="ac6d168ca5e25a70ab78d5a850025a2ad07d998b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--exclude&lt;/code&gt; and &lt;code&gt;--include&lt;/code&gt; patterns are used, they are examined in the order they appear on the command line, and the first match determines if a patch to each path is used. A patch to a path that does not match any include/exclude pattern is used by default if there is no include pattern on the command line, and ignored if there is any include pattern.</source>
          <target state="translated">경우 &lt;code&gt;--exclude&lt;/code&gt; 및 &lt;code&gt;--include&lt;/code&gt; 패턴이 사용되며, 그들이 명령 행에 나타나는 순서대로 시험하고, 각 경로에 대한 패치가 이용되는 경우 첫 번째 일치를 판단한다. 포함 / 제외 패턴과 일치하지 않는 경로에 대한 패치는 명령 행에 포함 패턴이없는 경우 기본적으로 사용되며 포함 패턴이 있으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="febfb7b902fc970c3396f3068a5c66e59c7ec8ea" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--notes&lt;/code&gt; is in effect, the message from the notes is matched as if it were part of the log message.</source>
          <target state="translated">때 &lt;code&gt;--notes&lt;/code&gt; 이 적용되는, 노트에서 메시지가 로그 메시지의 일부인 것처럼 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b84c74a91c715b3bf1b4e927529a07a15aed9721" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--numstat&lt;/code&gt; has been given, do not munge pathnames, but use a NUL-terminated machine-readable format.</source>
          <target state="translated">때 &lt;code&gt;--numstat&lt;/code&gt; 이 주어졌다,하지로 찾으면 경로 이름을하지만, NUL 종료 시스템에서 읽을 수있는 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d371e700585c518084c33d84fef0af43b13c3439" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--raw&lt;/code&gt;, &lt;code&gt;--numstat&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt; or &lt;code&gt;--name-status&lt;/code&gt; has been given, do not munge pathnames and use NULs as output field terminators.</source>
          <target state="translated">때 &lt;code&gt;--raw&lt;/code&gt; , &lt;code&gt;--numstat&lt;/code&gt; , &lt;code&gt;--name-only&lt;/code&gt; 또는 &lt;code&gt;--name-status&lt;/code&gt; 주어졌다, 출력 필드 터미네이터로하지로 찾으면 경로 이름과 사용 NUL을 해.</target>
        </trans-unit>
        <trans-unit id="e163d548a1a886a531d60736c2ba3e851388a10a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--root&lt;/code&gt; is specified the initial commit will be shown as a big creation event. This is equivalent to a diff against the NULL tree.</source>
          <target state="translated">때 &lt;code&gt;--root&lt;/code&gt; 이 초기 커밋 지정되어 큰 생성 이벤트로 표시됩니다. 이것은 NULL 트리에 대한 diff와 같습니다.</target>
        </trans-unit>
        <trans-unit id="8183759ad974b12070a46362dbaa27565534e645" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--show-pulls&lt;/code&gt; is paired with &lt;code&gt;--simplify-merges&lt;/code&gt;, the graph includes all of the necessary information:</source>
          <target state="translated">경우 &lt;code&gt;--show-pulls&lt;/code&gt; 페어링되어 &lt;code&gt;--simplify-merges&lt;/code&gt; 그래프 필요한 모든 정보를 포함한다 :</target>
        </trans-unit>
        <trans-unit id="5b88ba2b22685842fbd9b8b75fb2959da8ea9e8b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--stdin&lt;/code&gt; is specified, the command does not take &amp;lt;tree-ish&amp;gt; arguments from the command line. Instead, it reads lines containing either two &amp;lt;tree&amp;gt;, one &amp;lt;commit&amp;gt;, or a list of &amp;lt;commit&amp;gt; from its standard input. (Use a single space as separator.)</source>
          <target state="translated">때 &lt;code&gt;--stdin&lt;/code&gt; 옵션이 지정되면, 명령은 명령 줄에서 &amp;lt;트리 틱&amp;gt; 인수를 고려하지 않습니다. 대신 표준 입력에서 두 개의 &amp;lt;tree&amp;gt;, 하나의 &amp;lt;commit&amp;gt; 또는 &amp;lt;commit&amp;gt; 목록을 포함하는 행을 읽습니다. (단일 공백을 구분 기호로 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="c23ac888d8fe422c1532e2aed10782043e7c6859" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--temp&lt;/code&gt; is used (or implied by &lt;code&gt;--stage=all&lt;/code&gt;) &lt;code&gt;git checkout-index&lt;/code&gt; will create a temporary file for each index entry being checked out. The index will not be updated with stat information. These options can be useful if the caller needs all stages of all unmerged entries so that the unmerged files can be processed by an external merge tool.</source>
          <target state="translated">때 &lt;code&gt;--temp&lt;/code&gt; 이 사용 (또는 묵시적으로 &lt;code&gt;--stage=all&lt;/code&gt; ) &lt;code&gt;git checkout-index&lt;/code&gt; 각 인덱스 항목의 존재에 대한 임시 파일을 만듭니다 체크 아웃. 인덱스는 통계 정보로 업데이트되지 않습니다. 이러한 옵션은 호출자가 병합되지 않은 모든 항목의 모든 단계를 필요로하여 병합되지 않은 파일을 외부 병합 도구로 처리 할 수있는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5c97ac9560dda79ead627bde39274f79b6e5dd8a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-S&lt;/code&gt; or &lt;code&gt;-G&lt;/code&gt; are used without &lt;code&gt;--pickaxe-all&lt;/code&gt;, only filepairs that match their respective criterion are kept in the output. When &lt;code&gt;--pickaxe-all&lt;/code&gt; is used, if even one filepair matches their respective criterion in a changeset, the entire changeset is kept. This behavior is designed to make reviewing changes in the context of the whole changeset easier.</source>
          <target state="translated">경우 &lt;code&gt;-S&lt;/code&gt; 또는 &lt;code&gt;-G&lt;/code&gt; 이 없이 사용 &lt;code&gt;--pickaxe-all&lt;/code&gt; , 각각의 기준에 맞는 단지 filepairs 출력으로 유지된다. 경우 &lt;code&gt;--pickaxe-all&lt;/code&gt; 사용 되더라도 하나 filepair가 변경 집합에서 각 기준과 일치하는 경우, 전체 변경 집합이 보존된다. 이 동작은 전체 변경 집합의 컨텍스트에서 변경 사항을 쉽게 검토 할 수 있도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="b7230470efbcbdb8b4c76cdcdcf3272fde68030f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-S&lt;/code&gt; or &lt;code&gt;-G&lt;/code&gt; finds a change, show all the changes in that changeset, not just the files that contain the change in &amp;lt;string&amp;gt;.</source>
          <target state="translated">때 &lt;code&gt;-S&lt;/code&gt; 또는 &lt;code&gt;-G&lt;/code&gt; 이 변화를 발견, 그 변경 집합의 모든 변경, &amp;lt;문자열&amp;gt;의 변화를 포함 할뿐만 아니라 파일을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b52ce403c26e2631158c50ee6bd3c17065ed82dc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-u&lt;/code&gt; option is not used, untracked files and directories are shown (i.e. the same as specifying &lt;code&gt;normal&lt;/code&gt;), to help you avoid forgetting to add newly created files. Because it takes extra work to find untracked files in the filesystem, this mode may take some time in a large working tree. Consider enabling untracked cache and split index if supported (see &lt;code&gt;git update-index --untracked-cache&lt;/code&gt; and &lt;code&gt;git update-index
--split-index&lt;/code&gt;), Otherwise you can use &lt;code&gt;no&lt;/code&gt; to have &lt;code&gt;git status&lt;/code&gt; return more quickly without showing untracked files.</source>
          <target state="translated">때 &lt;code&gt;-u&lt;/code&gt; 옵션을 사용하지, 비 추적 파일 및 디렉토리 (지정하는 것과 즉, 같은 표시됩니다 &lt;code&gt;normal&lt;/code&gt; 이 새로 생성 된 파일을 추가 할 잊는 피할 수 있도록,). 파일 시스템에서 추적되지 않은 파일을 찾으려면 추가 작업이 필요하므로이 모드는 큰 작업 트리에서 시간이 걸릴 수 있습니다. 지원되는 경우 추적되지 않은 캐시 및 분할 인덱스를 활성화하는 것이 &lt;code&gt;git update-index --untracked-cache&lt;/code&gt; ( git update-index --untracked-cache 및 &lt;code&gt;git update-index --split-index&lt;/code&gt; ). 그렇지 않으면 추적되지 않은 파일을 표시하지 않고 &lt;code&gt;git status&lt;/code&gt; 더 빨리 반환 하도록 &lt;code&gt;no&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97c7c816e31485397947c4cd78f79e742f80ec39" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-z&lt;/code&gt; output option is in effect, the output is formatted this way:</source>
          <target state="translated">때 &lt;code&gt;-z&lt;/code&gt; 출력 옵션이 적용되는 출력이 방법을 포맷 :</target>
        </trans-unit>
        <trans-unit id="2bf71954fc8fac90c9030e3b9b1232971580d22a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;FETCH_HEAD&lt;/code&gt; (and no other commit) is specified, the branches recorded in the &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; file by the previous invocation of &lt;code&gt;git fetch&lt;/code&gt; for merging are merged to the current branch.</source>
          <target state="translated">때 &lt;code&gt;FETCH_HEAD&lt;/code&gt; (그리고 다른 커밋하지)가 지정되면, 기록 가지 &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; 의 이전 호출에 의해 파일 &lt;code&gt;git fetch&lt;/code&gt; 현재 브랜치에 병합 병합.</target>
        </trans-unit>
        <trans-unit id="30aaf2e9dd06a0335c5f1cb4c0791345a6730170" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; is enabled, the input list is considered a list of directories instead of sparse-checkout patterns. The command writes patterns to the sparse-checkout file to include all files contained in those directories (recursively) as well as files that are siblings of ancestor directories. The input format matches the output of &lt;code&gt;git ls-tree --name-only&lt;/code&gt;. This includes interpreting pathnames that begin with a double quote (&quot;) as C-style quoted strings.</source>
          <target state="translated">때 &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; 가 활성화되어, 입력리스트 대신 스파 스 체크 아웃 패턴의 디렉토리 목록 간주됩니다. 이 명령은 스파 스 체크 아웃 파일에 패턴을 작성하여 해당 디렉토리에 포함 된 모든 파일 (재귀 적으로)과 상위 디렉토리의 형제 파일을 포함합니다. 입력 형식은 &lt;code&gt;git ls-tree --name-only&lt;/code&gt; 의 출력과 일치합니다 . 여기에는 큰 따옴표 ( &quot;)로 시작하는 경로 이름을 C 스타일의 인용 문자열로 해석하는 것이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a79eb2995cdbf5e2d0a3c4b4e62d970b5798ea30" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; is enabled, the config file &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; is read after &lt;code&gt;.git/config&lt;/code&gt; is.</source>
          <target state="translated">때 &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; 가 활성화되어, 설정 파일 &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; 후에 읽어 &lt;code&gt;.git/config&lt;/code&gt; 에 있다.</target>
        </trans-unit>
        <trans-unit id="093107f57324ea8ddf834562dc5da735634ce1c2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fetch.fsckObjects&lt;/code&gt; or &lt;code&gt;receive.fsckObjects&lt;/code&gt; are not set, the value of this variable is used instead. Defaults to false.</source>
          <target state="translated">경우 &lt;code&gt;fetch.fsckObjects&lt;/code&gt; 또는 &lt;code&gt;receive.fsckObjects&lt;/code&gt; 가 설정되지 않은 경우,이 변수의 값이 대신 사용된다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="f0f4e4ab298d72d3ce878991ffe1cd2532ffab74" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fetch.unpackLimit&lt;/code&gt; or &lt;code&gt;receive.unpackLimit&lt;/code&gt; are not set, the value of this variable is used instead. The default value is 100.</source>
          <target state="translated">경우 &lt;code&gt;fetch.unpackLimit&lt;/code&gt; 또는 &lt;code&gt;receive.unpackLimit&lt;/code&gt; 가 설정되지 않은 경우,이 변수의 값이 대신 사용된다. 기본값은 100입니다.</target>
        </trans-unit>
        <trans-unit id="0f43e1a31ad9e45784cdafec68b8141e1a628402" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; is set, errors can be switched to warnings and vice versa by configuring the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; setting where the &lt;code&gt;&amp;lt;msg-id&amp;gt;&lt;/code&gt; is the fsck message ID and the value is one of &lt;code&gt;error&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt;. For convenience, fsck prefixes the error/warning with the message ID, e.g. &quot;missingEmail: invalid author/committer line - missing email&quot; means that setting &lt;code&gt;fsck.missingEmail = ignore&lt;/code&gt; will hide that issue.</source>
          <target state="translated">경우 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 설정 오류는 마찬가지 구성하여 경고 및 부사로 전환 될 수 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 설정 여기서 &lt;code&gt;&amp;lt;msg-id&amp;gt;&lt;/code&gt; fsck를 메시지 ID이고, 값 중 하나 인 &lt;code&gt;error&lt;/code&gt; , &lt;code&gt;warn&lt;/code&gt; 또는 &lt;code&gt;ignore&lt;/code&gt; . 편의상 fsck는 오류 / 경고에 메시지 ID가 접두어로 붙습니다. 예를 들어 &quot;missingEmail : 잘못된 작성자 / 커미터 라인-이메일 누락&quot;은 &lt;code&gt;fsck.missingEmail = ignore&lt;/code&gt; 를 설정 하면 해당 문제가 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="ce3f108ee8253a42ecb067bc1a011bcbcd3ad290" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git apply&lt;/code&gt; is used as a &quot;better GNU patch&quot;, the user can pass the &lt;code&gt;--unsafe-paths&lt;/code&gt; option to override this safety check. This option has no effect when &lt;code&gt;--index&lt;/code&gt; or &lt;code&gt;--cached&lt;/code&gt; is in use.</source>
          <target state="translated">때 &lt;code&gt;git apply&lt;/code&gt; 는 &quot;더 나은 GNU 패치&quot;로 사용하는 경우, 사용자는 통과 할 수 &lt;code&gt;--unsafe-paths&lt;/code&gt; 이 안전 점검을 무시하는 옵션을 선택합니다. &lt;code&gt;--index&lt;/code&gt; 또는 &lt;code&gt;--cached&lt;/code&gt; 를 사용중인 경우이 옵션은 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="dea5ce8f581717a21d1ee89e4952655599f11488" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git difftool&lt;/code&gt; is invoked with this tool (either through the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;--tool&lt;/code&gt; option or the &lt;code&gt;diff.tool&lt;/code&gt; configuration variable) the configured command line will be invoked with the following variables available: &lt;code&gt;$LOCAL&lt;/code&gt; is set to the name of the temporary file containing the contents of the diff pre-image and &lt;code&gt;$REMOTE&lt;/code&gt; is set to the name of the temporary file containing the contents of the diff post-image. &lt;code&gt;$MERGED&lt;/code&gt; is the name of the file which is being compared. &lt;code&gt;$BASE&lt;/code&gt; is provided for compatibility with custom merge tool commands and has the same value as &lt;code&gt;$MERGED&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git difftool&lt;/code&gt; 이이 도구로 호출 되면 ( &lt;code&gt;-t&lt;/code&gt; 또는 &lt;code&gt;--tool&lt;/code&gt; 옵션 또는 &lt;code&gt;diff.tool&lt;/code&gt; 구성 변수를 통해) 다음 명령을 사용하여 구성된 명령 행이 호출됩니다. &lt;code&gt;$LOCAL&lt;/code&gt; 은 임시 이름으로 설정됩니다. diff pre-image의 내용이 포함 된 파일 및 &lt;code&gt;$REMOTE&lt;/code&gt; 는 diff post-image의 내용이 포함 된 임시 파일의 이름으로 설정됩니다. &lt;code&gt;$MERGED&lt;/code&gt; 는 비교중인 파일의 이름입니다. &lt;code&gt;$BASE&lt;/code&gt; 는 사용자 정의 병합 도구 명령과의 호환성을 위해 제공되며 &lt;code&gt;$MERGED&lt;/code&gt; 와 동일한 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="02bc7953c8eb819402a97fdb05db86103d3e94f0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is run with explicit branches and/or tags to fetch on the command line, e.g. &lt;code&gt;git fetch origin master&lt;/code&gt;, the &amp;lt;refspec&amp;gt;s given on the command line determine what are to be fetched (e.g. &lt;code&gt;master&lt;/code&gt; in the example, which is a short-hand for &lt;code&gt;master:&lt;/code&gt;, which in turn means &quot;fetch the &lt;code&gt;master&lt;/code&gt; branch but I do not explicitly say what remote-tracking branch to update with it from the command line&quot;), and the example command will fetch &lt;code&gt;only&lt;/code&gt; the &lt;code&gt;master&lt;/code&gt; branch. The &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values determine which remote-tracking branch, if any, is updated. When used in this way, the &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values do not have any effect in deciding &lt;code&gt;what&lt;/code&gt; gets fetched (i.e. the values are not used as refspecs when the command-line lists refspecs); they are only used to decide &lt;code&gt;where&lt;/code&gt; the refs that are fetched are stored by acting as a mapping.</source>
          <target state="translated">때 &lt;code&gt;git fetch&lt;/code&gt; , 명령 행에서 가져 오기 위해 명시 적 지점 및 / 또는 태그 실행 예를 들어 &lt;code&gt;git fetch origin master&lt;/code&gt; 의 &amp;lt;refspec&amp;gt;의 (가져온 것으로 예를 들어 어떤 결정 명령 행에 주어진 &lt;code&gt;master&lt;/code&gt; 인 예에서 에 대한 간략 &lt;code&gt;master:&lt;/code&gt; 회전 수단 &quot;페치, &lt;code&gt;master&lt;/code&gt; ) 지점을하지만 명시 적으로 명령 줄에서 그것으로 업데이 트에 지점을 원격 추적 무슨 말을하지 않습니다&quot;하고 예제 명령은 가져옵니다 &lt;code&gt;only&lt;/code&gt; &lt;code&gt;master&lt;/code&gt; 분기를. &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 값이 갱신되어있는 경우, 분기 원격 추적 결정. 이런 식으로 사용하면 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 가져올 값 을 결정 &lt;code&gt;what&lt;/code&gt; 데 값이 영향을 미치지 않습니다 (즉, 명령 행이 참조 스펙을 나열 할 때 값이 참조 스펙으로 사용되지 않음). 페치 된 참조가 맵핑 역할을 수행하여 저장되는 &lt;code&gt;where&lt;/code&gt; 를 결정 하는 데에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d3bb27ea8d5739147518646e08d478432b5ac353" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is run without specifying what branches and/or tags to fetch on the command line, e.g. &lt;code&gt;git fetch origin&lt;/code&gt; or &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values are used as the refspecs&amp;mdash;​they specify which refs to fetch and which local refs to update. The example above will fetch all branches that exist in the &lt;code&gt;origin&lt;/code&gt; (i.e. any ref that matches the left-hand side of the value, &lt;code&gt;refs/heads/*&lt;/code&gt;) and update the corresponding remote-tracking branches in the &lt;code&gt;refs/remotes/origin/*&lt;/code&gt; hierarchy.</source>
          <target state="translated">때 &lt;code&gt;git fetch&lt;/code&gt; 지점 및 / 또는 태그 예를 들어, 명령 행에서 가져 오기 위해 무엇을 지정하지 않고 실행 &lt;code&gt;git fetch origin&lt;/code&gt; 또는 &lt;code&gt;git fetch&lt;/code&gt; , &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 값들이 인출 할 심판 지정 refspecs-로 사용되며, 업데이트 할 로컬 참조 위의 예제는 &lt;code&gt;origin&lt;/code&gt; 존재하는 모든 브랜치 (즉, 값의 왼쪽과 일치하는 &lt;code&gt;refs/heads/*&lt;/code&gt; )를 가져오고 &lt;code&gt;refs/remotes/origin/*&lt;/code&gt; 에서 해당 원격 추적 브랜치를 업데이트합니다. 계층.</target>
        </trans-unit>
        <trans-unit id="6bfc306f6ccec6cbac00c82d44f7befe47671739" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is used with &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec it may refuse to update the local branch as discussed in the &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; part below. This option overrides that check.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 를 &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec 과 함께 사용 하면 아래 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 부분 에서 설명한대로 로컬 분기 업데이트를 거부 할 수 있습니다. 이 옵션은 해당 검사를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="b8a0a18f13c1248a211519fc4b6c3ee775403075" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is used with &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec it may refuse to update the local branch as discussed in the &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; part of the &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; documentation. This option overrides that check.</source>
          <target state="translated">경우 &lt;code&gt;git fetch&lt;/code&gt; 에 사용되는 &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec는 논의 된 것처럼 로컬 브랜치를 업데이트 거부 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 의 일부 &lt;a href=&quot;git-fetch&quot;&gt;자식 페치 [1]&lt;/a&gt; 문서. 이 옵션은 해당 검사를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="946d45913d1a6d20975808ddb9f4de7a3a592055" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git gc&lt;/code&gt; is run, it calls &lt;code&gt;git worktree prune --expire 3.months.ago&lt;/code&gt;. This config variable can be used to set a different grace period. The value &quot;now&quot; may be used to disable the grace period and prune &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; immediately, or &quot;never&quot; may be used to suppress pruning.</source>
          <target state="translated">&lt;code&gt;git gc&lt;/code&gt; 가 실행될 때 git &lt;code&gt;git worktree prune --expire 3.months.ago&lt;/code&gt; 호출합니다 . 이 구성 변수를 사용하여 다른 유예 기간을 설정할 수 있습니다. &quot;now&quot;값은 유예 기간을 비활성화하고 &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; 즉시 프룬 (prune)하거나 &quot;never&quot;를 사용하여 프 루닝을 억제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdaf9b565f5bc5effacd5e94ca1e6e23df9c9f7a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git gc&lt;/code&gt; is run, it will call &lt;code&gt;prune --expire 2.weeks.ago&lt;/code&gt;. Override the grace period with this config variable. The value &quot;now&quot; may be used to disable this grace period and always prune unreachable objects immediately, or &quot;never&quot; may be used to suppress pruning. This feature helps prevent corruption when &lt;code&gt;git gc&lt;/code&gt; runs concurrently with another process writing to the repository; see the &quot;NOTES&quot; section of &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.</source>
          <target state="translated">때 &lt;code&gt;git gc&lt;/code&gt; 실행되고, 그것은 호출 &lt;code&gt;prune --expire 2.weeks.ago&lt;/code&gt; . 이 구성 변수로 유예 기간을 재정의하십시오. &quot;now&quot;값은이 유예 기간을 비활성화하고 항상 도달 할 수없는 개체를 즉시 제거하거나 &quot;never&quot;를 사용하여 제거를 억제 할 수 있습니다. 이 기능은 &lt;code&gt;git gc&lt;/code&gt; 가 저장소에 쓰는 다른 프로세스와 동시에 실행될 때 손상을 방지 합니다. &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt; 의 &quot;NOTES&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9771ab35f0db8c62ffb81b026ac116ab479df958" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git mergetool&lt;/code&gt; is invoked with this tool (either through the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;--tool&lt;/code&gt; option or the &lt;code&gt;merge.tool&lt;/code&gt; configuration variable) the configured command line will be invoked with &lt;code&gt;$BASE&lt;/code&gt; set to the name of a temporary file containing the common base for the merge, if available; &lt;code&gt;$LOCAL&lt;/code&gt; set to the name of a temporary file containing the contents of the file on the current branch; &lt;code&gt;$REMOTE&lt;/code&gt; set to the name of a temporary file containing the contents of the file to be merged, and &lt;code&gt;$MERGED&lt;/code&gt; set to the name of the file to which the merge tool should write the result of the merge resolution.</source>
          <target state="translated">때 &lt;code&gt;git mergetool&lt;/code&gt; (스루 중 하나를이 도구를 호출 &lt;code&gt;-t&lt;/code&gt; 또는 &lt;code&gt;--tool&lt;/code&gt; 옵션 또는 &lt;code&gt;merge.tool&lt;/code&gt; 에 구성된 명령 줄이 호출됩니다 구성 변수) &lt;code&gt;$BASE&lt;/code&gt; 공통 기반을 포함하는 임시 파일의 이름으로 설정 가능한 경우 병합; &lt;code&gt;$LOCAL&lt;/code&gt; 은 현재 분기의 파일 내용을 포함하는 임시 파일 이름으로 설정됩니다. &lt;code&gt;$REMOTE&lt;/code&gt; 는 병합 될 파일의 ​​내용을 포함하는 임시 파일 이름으로 설정 되고 &lt;code&gt;$MERGED&lt;/code&gt; 는 병합 도구가 병합 분석 결과를 작성해야하는 파일 이름으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8d649c2a1b515f828b380ed0228639a9abf6f2e7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git-difftool&lt;/code&gt; is invoked with the &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--gui&lt;/code&gt; option the default diff tool will be read from the configured &lt;code&gt;diff.guitool&lt;/code&gt; variable instead of &lt;code&gt;diff.tool&lt;/code&gt;. The &lt;code&gt;--no-gui&lt;/code&gt; option can be used to override this setting. If &lt;code&gt;diff.guitool&lt;/code&gt; is not set, we will fallback in the order of &lt;code&gt;merge.guitool&lt;/code&gt;, &lt;code&gt;diff.tool&lt;/code&gt;, &lt;code&gt;merge.tool&lt;/code&gt; until a tool is found.</source>
          <target state="translated">때 &lt;code&gt;git-difftool&lt;/code&gt; 를 호출 &lt;code&gt;-g&lt;/code&gt; 또는 &lt;code&gt;--gui&lt;/code&gt; 옵션 기본은 diff 도구는 구성에서 읽을 수 있습니다 &lt;code&gt;diff.guitool&lt;/code&gt; 의 변수 대신 &lt;code&gt;diff.tool&lt;/code&gt; . &lt;code&gt;--no-gui&lt;/code&gt; 옵션이 설정을 대체 할 수 있습니다. 경우 &lt;code&gt;diff.guitool&lt;/code&gt; 가 설정되어 있지 않은, 우리의 순서로 폴백합니다 &lt;code&gt;merge.guitool&lt;/code&gt; , &lt;code&gt;diff.tool&lt;/code&gt; , &lt;code&gt;merge.tool&lt;/code&gt; 도구가 발견 될 때까지.</target>
        </trans-unit>
        <trans-unit id="dab1778e78eece39a70fe4959b77fef05af95366" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git-mergetool&lt;/code&gt; is invoked with the &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--gui&lt;/code&gt; option the default merge tool will be read from the configured &lt;code&gt;merge.guitool&lt;/code&gt; variable instead of &lt;code&gt;merge.tool&lt;/code&gt;. If &lt;code&gt;merge.guitool&lt;/code&gt; is not set, we will fallback to the tool configured under &lt;code&gt;merge.tool&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;git-mergetool&lt;/code&gt; 를 호출 &lt;code&gt;-g&lt;/code&gt; 또는 &lt;code&gt;--gui&lt;/code&gt; 옵션 기본 병합 도구는 구성에서 읽을 수 있습니다 &lt;code&gt;merge.guitool&lt;/code&gt; 의 변수 대신 &lt;code&gt;merge.tool&lt;/code&gt; . 경우 &lt;code&gt;merge.guitool&lt;/code&gt; 가 설정되어 있지 않은, 우리는에서 구성 도구로 폴백합니다 &lt;code&gt;merge.tool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55d1f905322639499a3e0c7d64b920e915841fa1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;group&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), the repository is made shareable between several users in a group (making sure all the files and objects are group-writable). When &lt;code&gt;all&lt;/code&gt; (or &lt;code&gt;world&lt;/code&gt; or &lt;code&gt;everybody&lt;/code&gt;), the repository will be readable by all users, additionally to being group-shareable. When &lt;code&gt;umask&lt;/code&gt; (or &lt;code&gt;false&lt;/code&gt;), Git will use permissions reported by umask(2). When &lt;code&gt;0xxx&lt;/code&gt;, where &lt;code&gt;0xxx&lt;/code&gt; is an octal number, files in the repository will have this mode value. &lt;code&gt;0xxx&lt;/code&gt; will override user&amp;rsquo;s umask value (whereas the other options will only override requested parts of the user&amp;rsquo;s umask value). Examples: &lt;code&gt;0660&lt;/code&gt; will make the repo read/write-able for the owner and group, but inaccessible to others (equivalent to &lt;code&gt;group&lt;/code&gt; unless umask is e.g. &lt;code&gt;0022&lt;/code&gt;). &lt;code&gt;0640&lt;/code&gt; is a repository that is group-readable but not group-writable. See &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt;. False by default.</source>
          <target state="translated">때 &lt;code&gt;group&lt;/code&gt; (또는 &lt;code&gt;true&lt;/code&gt; ), 저장소가 그룹에 여러 사용자간에 공유한다 (파일 및 객체 그룹 쓸 수 있는지 모든 제작). 때 &lt;code&gt;all&lt;/code&gt; (또는 &lt;code&gt;world&lt;/code&gt; 또는 &lt;code&gt;everybody&lt;/code&gt; ), 저장소에 추가 그룹 공유되기 위해서는, 모든 사용자가 읽을 수 있습니다. 때 &lt;code&gt;umask&lt;/code&gt; (또는 &lt;code&gt;false&lt;/code&gt; ), 힘내 권한을 사용의 umask (2)에 의해보고했다. 때 &lt;code&gt;0xxx&lt;/code&gt; 여기서 &lt;code&gt;0xxx&lt;/code&gt; 는 8 진수이며, 저장소에있는 파일이 모드의 값을 갖게됩니다. &lt;code&gt;0xxx&lt;/code&gt; 는 사용자의 umask 값을 대체합니다 (다른 옵션은 사용자의 umask 값의 요청 된 부분 만 대체합니다). 예 : &lt;code&gt;0660&lt;/code&gt; repo는 소유자와 그룹에 대해 읽기 / 쓰기가 가능하지만 다른 사람은 액세스 할 수 없습니다 ( umask가 예를 들어 &lt;code&gt;0022&lt;/code&gt; 가 아닌 경우 &lt;code&gt;group&lt;/code&gt; 과 동일 함 ). &lt;code&gt;0640&lt;/code&gt; 은 그룹에서 읽을 수 있지만 그룹에서 쓸 수없는 저장소입니다. &lt;a href=&quot;git-init&quot;&gt;git-init [1]을&lt;/a&gt; 참조하십시오 . 기본적으로 False입니다.</target>
        </trans-unit>
        <trans-unit id="0c640b1443fdc376fb0e05e5b19871e0f70bfa75" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;interactive&lt;/code&gt;, enable the interactive mode of rebase.</source>
          <target state="translated">때 &lt;code&gt;interactive&lt;/code&gt; , REBASE의 대화 형 모드를 가능하게한다.</target>
        </trans-unit>
        <trans-unit id="0e5d1d0d5309f291d73a19a6f71347b59d761978" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;konqueror&lt;/code&gt; is specified in the &lt;code&gt;man.viewer&lt;/code&gt; configuration variable, we launch &lt;code&gt;kfmclient&lt;/code&gt; to try to open the man page on an already opened konqueror in a new tab if possible.</source>
          <target state="translated">&lt;code&gt;konqueror&lt;/code&gt; 가 &lt;code&gt;man.viewer&lt;/code&gt; 구성 변수에 지정 되면 &lt;code&gt;kfmclient&lt;/code&gt; 를 시작 하여 가능한 경우 이미 열린 konqueror의 매뉴얼 페이지를 새 탭에서 열려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="162b4f89725e01e084b1d2a9bb66f41a211da6f6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;matching&lt;/code&gt; mode is specified, paths that explicitly match an ignored pattern are shown. If a directory matches an ignore pattern, then it is shown, but not paths contained in the ignored directory. If a directory does not match an ignore pattern, but all contents are ignored, then the directory is not shown, but all contents are shown.</source>
          <target state="translated">때 &lt;code&gt;matching&lt;/code&gt; 모드를 지정, 명시 적으로 무시 패턴과 일치하는 경로가 표시됩니다. 디렉토리가 무시 패턴과 일치하면 무시 된 디렉토리에 포함 된 경로는 표시되지 않습니다. 디렉토리가 무시 패턴과 일치하지 않지만 모든 내용이 무시되는 경우 디렉토리는 표시되지 않지만 모든 내용이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7ee4878df1abaf60b54059eba9faa52c16598786" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;merges&lt;/code&gt; (or just &lt;code&gt;m&lt;/code&gt;), pass the &lt;code&gt;--rebase-merges&lt;/code&gt; option to &lt;code&gt;git rebase&lt;/code&gt; so that the local merge commits are included in the rebase (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">&lt;code&gt;merges&lt;/code&gt; (또는 &lt;code&gt;m&lt;/code&gt; ) 할 때 로컬 병합 커밋이 rebase에 포함되도록 &lt;code&gt;--rebase-merges&lt;/code&gt; 옵션을 &lt;code&gt;git rebase&lt;/code&gt; 에 전달 합니다 (자세한 내용은 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="239b51beb1f8c13233881b0568518d58e269df96" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;merges&lt;/code&gt;, pass the &lt;code&gt;--rebase-merges&lt;/code&gt; option to &lt;code&gt;git rebase&lt;/code&gt; so that the local merge commits are included in the rebase (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">하면 &lt;code&gt;merges&lt;/code&gt; , 통과 &lt;code&gt;--rebase-merges&lt;/code&gt; 하는 옵션이 &lt;code&gt;git rebase&lt;/code&gt; 로컬 병합 커밋이 REBASE에 포함되는 정도 (참조 &lt;a href=&quot;git-rebase&quot;&gt;자식-REBASE [1]&lt;/a&gt; 세부 사항 참조).</target>
        </trans-unit>
        <trans-unit id="26887709475bb99a484f3550dfcf66463a02ff1c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;preserve&lt;/code&gt; (deprecated in favor of &lt;code&gt;merges&lt;/code&gt;), also pass &lt;code&gt;--preserve-merges&lt;/code&gt; along to &lt;code&gt;git rebase&lt;/code&gt; so that locally committed merge commits will not be flattened by running &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;preserve&lt;/code&gt; (찬성되지 &lt;code&gt;merges&lt;/code&gt; )도 통과 &lt;code&gt;--preserve-merges&lt;/code&gt; 에 따라 &lt;code&gt;git rebase&lt;/code&gt; 이 로컬 커밋 병합 커밋을 실행하여 평평되지 않도록 &lt;code&gt;git pull&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1aa5ac29106f7e567cb177a446057fe6893dfb3c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;preserve&lt;/code&gt; (or just &lt;code&gt;p&lt;/code&gt;, deprecated in favor of &lt;code&gt;merges&lt;/code&gt;), also pass &lt;code&gt;--preserve-merges&lt;/code&gt; along to &lt;code&gt;git rebase&lt;/code&gt; so that locally committed merge commits will not be flattened by running &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;preserve&lt;/code&gt; (또는 &lt;code&gt;p&lt;/code&gt; 에 찬성되지 않는, &lt;code&gt;merges&lt;/code&gt; )도 통과 &lt;code&gt;--preserve-merges&lt;/code&gt; 에 따라 &lt;code&gt;git rebase&lt;/code&gt; 이 로컬 커밋 병합 커밋을 실행하여 평평되지 않도록 &lt;code&gt;git pull&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c040d756e251986ff4d930aa40402b774da81b76" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;preserveUser&lt;/code&gt; is true, &lt;code&gt;git p4&lt;/code&gt; normally dies if it cannot find an author in the p4 user map. This setting submits the change regardless.</source>
          <target state="translated">때 &lt;code&gt;preserveUser&lt;/code&gt; 는 사실, &lt;code&gt;git p4&lt;/code&gt; 그것이 P4 사용자 맵에서 저자를 찾을 수없는 경우 일반적으로 죽는다. 이 설정은 관계없이 변경 사항을 제출합니다.</target>
        </trans-unit>
        <trans-unit id="f1cb457481e4cab2531cdb48fb2ed70a72c47f80" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;receive-pack&lt;/code&gt; takes in objects, they are placed into a temporary &quot;quarantine&quot; directory within the &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; directory and migrated into the main object store only after the &lt;code&gt;pre-receive&lt;/code&gt; hook has completed. If the push fails before then, the temporary directory is removed entirely.</source>
          <target state="translated">&lt;code&gt;receive-pack&lt;/code&gt; 이 오브젝트를 가져 오면 &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; 디렉토리 내의 임시 &quot;검역&quot;디렉토리에 배치되고 &lt;code&gt;pre-receive&lt;/code&gt; 후크가 완료된 후에 만 주 오브젝트 저장소로 마이그레이션됩니다 . 그 전에 푸시가 실패하면 임시 디렉토리가 완전히 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="13eed45e8cb127a4420b06f0b52f497c696b7d45" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text&lt;/code&gt; is set to &quot;auto&quot;, the path is marked for automatic end-of-line conversion. If Git decides that the content is text, its line endings are converted to LF on checkin. When the file has been committed with CRLF, no conversion is done.</source>
          <target state="translated">&lt;code&gt;text&lt;/code&gt; 가 &quot;자동&quot;으로 설정 되면 경로가 자동 줄 끝 변환으로 표시됩니다. Git이 내용이 텍스트라고 결정하면 체크인시 줄 끝이 LF로 변환됩니다. 파일이 CRLF로 커밋되면 변환이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2bb8610f0d3f51c94aca7dd51e3603814301750d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text=auto&lt;/code&gt; conversion is enabled in a cross-platform project using push and pull to a central repository the text files containing CRLFs should be normalized.</source>
          <target state="translated">때 &lt;code&gt;text=auto&lt;/code&gt; 변환이 중앙 저장소에있는 CRLF를 포함하는 텍스트 파일을 푸시와 풀을 사용하여 크로스 플랫폼 프로젝트에서 사용 가능 정상화해야한다.</target>
        </trans-unit>
        <trans-unit id="f1b569ad0a0d3f731d90377a830d25de99487fad" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;upload-pack&lt;/code&gt; has started &lt;code&gt;pack-objects&lt;/code&gt;, there may be a quiet period while &lt;code&gt;pack-objects&lt;/code&gt; prepares the pack. Normally it would output progress information, but if &lt;code&gt;--quiet&lt;/code&gt; was used for the fetch, &lt;code&gt;pack-objects&lt;/code&gt; will output nothing at all until the pack data begins. Some clients and networks may consider the server to be hung and give up. Setting this option instructs &lt;code&gt;upload-pack&lt;/code&gt; to send an empty keepalive packet every &lt;code&gt;uploadpack.keepAlive&lt;/code&gt; seconds. Setting this option to 0 disables keepalive packets entirely. The default is 5 seconds.</source>
          <target state="translated">때 &lt;code&gt;upload-pack&lt;/code&gt; 시작 &lt;code&gt;pack-objects&lt;/code&gt; 하면서, 조용한 기간이있을 수 있습니다 &lt;code&gt;pack-objects&lt;/code&gt; 팩을 준비합니다. 일반적으로는 출력 진행 정보는 것이지만, 경우에 &lt;code&gt;--quiet&lt;/code&gt; 이 사용 된이 인출 &lt;code&gt;pack-objects&lt;/code&gt; 것이다 팩 데이터까지 모두에서 출력 아무것도 시작하지 않습니다. 일부 클라이언트와 네트워크는 서버가 중단 된 것으로 간주 할 수 있습니다. 이 옵션을 설정하면 &lt;code&gt;upload-pack&lt;/code&gt; 이 &lt;code&gt;uploadpack.keepAlive&lt;/code&gt; 초 마다 빈 keepalive 패킷을 보내도록 지시 합니다. 이 옵션을 0으로 설정하면 keepalive 패킷이 완전히 비활성화됩니다. 기본값은 5 초입니다.</target>
        </trans-unit>
        <trans-unit id="09ea8c9e4617731ed2a0cdf40185d39ec477e171" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; is in effect, allow &lt;code&gt;upload-pack&lt;/code&gt; to accept a fetch request that asks for an object at the tip of a hidden ref (by default, such a request is rejected). See also &lt;code&gt;uploadpack.hideRefs&lt;/code&gt;. Even if this is false, a client may be able to steal objects via the techniques described in the &quot;SECURITY&quot; section of the &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; man page; it&amp;rsquo;s best to keep private data in a separate repository.</source>
          <target state="translated">때 &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; 가 적용되는 허용 &lt;code&gt;upload-pack&lt;/code&gt; 숨겨진 심판의 끝에서 개체에 대해 묻는 가져 오기 요청을 수락 (기본적으로, 이러한 요청이 거부됩니다). &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; 도 참조하십시오 . 이것이 거짓이더라도 클라이언트는 &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]&lt;/a&gt; 매뉴얼 페이지 의 &quot;보안&quot;섹션에 설명 된 기술을 통해 객체를 훔칠 수 있습니다 . 개인 데이터를 별도의 저장소에 보관하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5f953a201b0ae4d35f35034718b3114ef928787f" translate="yes" xml:space="preserve">
          <source>When Git doesn&amp;rsquo;t know how to handle a certain transport protocol, it attempts to use the &lt;code&gt;remote-&amp;lt;transport&amp;gt;&lt;/code&gt; remote helper, if one exists. To explicitly request a remote helper, the following syntax may be used:</source>
          <target state="translated">Git이 특정 전송 프로토콜을 처리하는 방법을 모르면 &lt;code&gt;remote-&amp;lt;transport&amp;gt;&lt;/code&gt; 원격 도우미 (있는 경우) 를 사용하려고 시도 합니다. 원격 헬퍼를 명시 적으로 요청하기 위해 다음 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf58a154a8f8fa8889640812d376b7964ce7bef2" translate="yes" xml:space="preserve">
          <source>When Git encounters a URL of the form &lt;code&gt;&amp;lt;transport&amp;gt;://&amp;lt;address&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt; is a protocol that it cannot handle natively, it automatically invokes &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; with the full URL as the second argument. If such a URL is encountered directly on the command line, the first argument is the same as the second, and if it is encountered in a configured remote, the first argument is the name of that remote.</source>
          <target state="translated">힘내 형식의 URL 발견하면 &lt;code&gt;&amp;lt;transport&amp;gt;://&amp;lt;address&amp;gt;&lt;/code&gt; 여기서 &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt; 입니다 그것은 기본적으로, 자동으로 발동 할 처리 할 수없는 프로토콜 &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; 두 번째 인수로 전체 URL과 함께. 이러한 URL이 명령 행에서 직접 발견되면 첫 번째 인수는 두 번째 인수와 동일하며 구성된 리모트에서 발견되는 경우 첫 번째 인수는 해당 리모트의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="27018e5bb4c8622ebcfed2f81b80284203c3bc2f" translate="yes" xml:space="preserve">
          <source>When Git encounters the first file that needs to be cleaned or smudged, it starts the filter and performs the handshake. In the handshake, the welcome message sent by Git is &quot;git-filter-client&quot;, only version 2 is supported, and the supported capabilities are &quot;clean&quot;, &quot;smudge&quot;, and &quot;delay&quot;.</source>
          <target state="translated">Git은 청소 또는 얼룩이 필요한 첫 번째 파일을 발견하면 필터를 시작하고 핸드 셰이크를 수행합니다. 핸드 셰이크에서 Git이 보낸 환영 메시지는 &quot;git-filter-client&quot;이고 버전 2 만 지원되며 지원되는 기능은 &quot;clean&quot;, &quot;smudge&quot;및 &quot;delay&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="f51f886a7edb2e397d8670010685e9d17fb9bc09" translate="yes" xml:space="preserve">
          <source>When Git needs authentication for a particular URL context, credential-store will consider that context a pattern to match against each entry in the credentials file. If the protocol, hostname, and username (if we already have one) match, then the password is returned to Git. See the discussion of configuration in &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for more information.</source>
          <target state="translated">Git이 특정 URL 컨텍스트에 대한 인증이 필요한 경우 credential-store는 해당 컨텍스트를 자격 증명 파일의 각 항목과 일치하는 패턴으로 간주합니다. 프로토콜, 호스트 이름 및 사용자 이름 (이미있는 경우)이 일치하면 암호가 Git으로 반환됩니다. 자세한 정보 는 &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt; 의 구성에 대한 설명 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fbdc4494c8c569621bd35073fd02055c267f7e54" translate="yes" xml:space="preserve">
          <source>When Git needs to show you a diff for the path with &lt;code&gt;diff&lt;/code&gt; attribute set to &lt;code&gt;jcdiff&lt;/code&gt;, it calls the command you specified with the above configuration, i.e. &lt;code&gt;j-c-diff&lt;/code&gt;, with 7 parameters, just like &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; program is called. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details.</source>
          <target state="translated">Git에 &lt;code&gt;diff&lt;/code&gt; 속성이 &lt;code&gt;jcdiff&lt;/code&gt; 로 설정된 경로에 대한 diff를 표시 해야하는 경우 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 프로그램이 호출되는 것처럼 7 개의 매개 변수를 사용하여 위 구성 (예 : &lt;code&gt;j-c-diff&lt;/code&gt; )으로 지정한 명령을 호출합니다 . 자세한 내용은 &lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bb3065603615c6a64dfcb623c10f42c6b9e417fa" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;git push --signed&lt;/code&gt; sent a push certificate with a &quot;nonce&quot; that was issued by a receive-pack serving the same repository within this many seconds, export the &quot;nonce&quot; found in the certificate to &lt;code&gt;GIT_PUSH_CERT_NONCE&lt;/code&gt; to the hooks (instead of what the receive-pack asked the sending side to include). This may allow writing checks in &lt;code&gt;pre-receive&lt;/code&gt; and &lt;code&gt;post-receive&lt;/code&gt; a bit easier. Instead of checking &lt;code&gt;GIT_PUSH_CERT_NONCE_SLOP&lt;/code&gt; environment variable that records by how many seconds the nonce is stale to decide if they want to accept the certificate, they only can check &lt;code&gt;GIT_PUSH_CERT_NONCE_STATUS&lt;/code&gt; is &lt;code&gt;OK&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;git push --signed&lt;/code&gt; a로 발행 된 &quot;넌스&quot;로 푸시 인증서를 보내이 많은 초 이내에 같은 저장소를 제공하는 팩을 수신에 인증서에있는 &quot;비표&quot;수출 &lt;code&gt;GIT_PUSH_CERT_NONCE&lt;/code&gt; (대신 후크를 수신 팩이 송신 측에 요청한 내용). 이 수표 쓰기 허용 할 수 있습니다 &lt;code&gt;pre-receive&lt;/code&gt; 및 &lt;code&gt;post-receive&lt;/code&gt; 좀 더 쉽게. nonce가 인증서를 수락할지 여부를 결정하기 위해 부실한 시간 (초)을 기록하는 &lt;code&gt;GIT_PUSH_CERT_NONCE_SLOP&lt;/code&gt; 환경 변수를 확인하는 대신 &lt;code&gt;GIT_PUSH_CERT_NONCE_STATUS&lt;/code&gt; 가 &lt;code&gt;OK&lt;/code&gt; 인지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f34a76491c47ddfcf2959dd6944574eeda479afa" translate="yes" xml:space="preserve">
          <source>When a command has finished, and the client has received the entire response from the server, a client can either request that another command be executed or can terminate the connection. A client may optionally send an empty request consisting of just a flush-pkt to indicate that no more requests will be made.</source>
          <target state="translated">명령이 완료되고 클라이언트가 서버로부터 전체 응답을 받으면 클라이언트는 다른 명령의 실행을 요청하거나 연결을 종료 할 수 있습니다. 클라이언트는 선택적으로 더 이상 요청이 없다는 것을 나타 내기 위해 flush-pkt로만 구성된 빈 요청을 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98e606d10b24cc0c03b08a4efd9e014e2a7d092f" translate="yes" xml:space="preserve">
          <source>When a commit is created in this state, the branch is updated to refer to the new commit. Specifically, &lt;code&gt;git commit&lt;/code&gt; creates a new commit &lt;code&gt;d&lt;/code&gt;, whose parent is commit &lt;code&gt;c&lt;/code&gt;, and then updates branch &lt;code&gt;master&lt;/code&gt; to refer to new commit &lt;code&gt;d&lt;/code&gt;. &lt;code&gt;HEAD&lt;/code&gt; still refers to branch &lt;code&gt;master&lt;/code&gt; and so indirectly now refers to commit &lt;code&gt;d&lt;/code&gt;:</source>
          <target state="translated">이 상태에서 커밋이 생성되면 새 커밋을 참조하도록 분기가 업데이트됩니다. 특히, &lt;code&gt;git commit&lt;/code&gt; 새로운 커밋 생성 &lt;code&gt;d&lt;/code&gt; 부모가 저지하고, &lt;code&gt;c&lt;/code&gt; 다음 지점 업데이트 &lt;code&gt;master&lt;/code&gt; 새로운 확정 참조 &lt;code&gt;d&lt;/code&gt; . &lt;code&gt;HEAD&lt;/code&gt; 는 여전히 브랜치 &lt;code&gt;master&lt;/code&gt; 를 참조하므로 간접적으로 커밋 &lt;code&gt;d&lt;/code&gt; 를 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="b5e6d106b45c449ef3f9978fa7e9a2c319abd6d7" translate="yes" xml:space="preserve">
          <source>When a conflict occurs while rebasing, rebase stops and asks the user to resolve. Since the user may need to make notable changes while resolving conflicts, after conflicts are resolved and the user has run &lt;code&gt;git rebase --continue&lt;/code&gt;, the rebase should open an editor and ask the user to update the commit message. The merge backend does this, while the apply backend blindly applies the original commit message.</source>
          <target state="translated">리베이스 중에 충돌이 발생하면 리베이스가 중지되고 사용자에게 해결을 요청합니다. 사용자가 충돌을 해결하는 동안 눈에 띄는 변경을해야 할 수 있으므로 충돌이 해결되고 사용자가 &lt;code&gt;git rebase --continue&lt;/code&gt; 를 실행 한 후 rebase는 편집기를 열고 사용자에게 커밋 메시지를 업데이트하도록 요청해야합니다. 병합 백엔드는이를 수행하는 반면 적용 백엔드는 원래 커밋 메시지를 맹목적으로 적용합니다.</target>
        </trans-unit>
        <trans-unit id="a1d656a10ad8d92cd23d5675fa9c3ba2b92a8d6f" translate="yes" xml:space="preserve">
          <source>When a curl trace is enabled (see &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; above), do not dump data (that is, only dump info lines and headers).</source>
          <target state="translated">컬 추적이 활성화되면 ( 위의 &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; 참조) 데이터를 덤프하지 마십시오 (즉, 정보 행 및 헤더 만 덤프).</target>
        </trans-unit>
        <trans-unit id="855748d09cda03242c615ed9f83d928cff4dd252" translate="yes" xml:space="preserve">
          <source>When a fetch mirror is created with &lt;code&gt;--mirror=fetch&lt;/code&gt;, the refs will not be stored in the &lt;code&gt;refs/remotes/&lt;/code&gt; namespace, but rather everything in &lt;code&gt;refs/&lt;/code&gt; on the remote will be directly mirrored into &lt;code&gt;refs/&lt;/code&gt; in the local repository. This option only makes sense in bare repositories, because a fetch would overwrite any local commits.</source>
          <target state="translated">&lt;code&gt;--mirror=fetch&lt;/code&gt; 를 사용하여 페치 미러를 만들면 참조 는 &lt;code&gt;refs/remotes/&lt;/code&gt; 네임 스페이스에 저장되지 않지만 원격의 &lt;code&gt;refs/&lt;/code&gt; 에있는 모든 것은 로컬 리포지토리의 &lt;code&gt;refs/&lt;/code&gt; 에 직접 미러링됩니다 . 페치는 로컬 커밋을 덮어 쓰기 때문에이 옵션은 베어 리포지토리에서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="747511f053f093bdd8637c2efa65029ba86d5e79" translate="yes" xml:space="preserve">
          <source>When a git process is a (direct or indirect) child of another git process, it inherits Trace2 context information. This allows the child to print the command hierarchy. This example shows gc as child[3] of fetch. When the gc process reports its name as &quot;gc&quot;, it also reports the hierarchy as &quot;fetch/gc&quot;. (In this example, trace2 messages from the child process is indented for clarity.)</source>
          <target state="translated">자식 프로세스가 다른 자식 프로세스의 (직접 또는 간접) 자식 인 경우 Trace2 컨텍스트 정보를 상속합니다. 이를 통해 자식은 명령 계층을 인쇄 할 수 있습니다. 이 예는 gc를 fetch의 child [3]으로 표시합니다. gc 프로세스가 이름을 &quot;gc&quot;로보고하면 계층 구조도 &quot;fetch / gc&quot;로보고합니다. (이 예에서, 하위 프로세스의 trace2 메시지는 명확성을 위해 들여 쓰기됩니다.)</target>
        </trans-unit>
        <trans-unit id="dcc866e382263d0b053b9eb6226d8321d2b6f3a3" translate="yes" xml:space="preserve">
          <source>When a helper is executed, it will have one &quot;operation&quot; argument appended to its command line, which is one of:</source>
          <target state="translated">도우미가 실행되면 명령 줄에 다음 중 하나 인 &quot;operation&quot;인수가 하나 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="79294381fcaa0a0dccaa2b41ac29dc7daa74e3f5" translate="yes" xml:space="preserve">
          <source>When a local branch is started off a remote-tracking branch, Git sets up the branch (specifically the &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; configuration entries) so that &lt;code&gt;git pull&lt;/code&gt; will appropriately merge from the remote-tracking branch. This behavior may be changed via the global &lt;code&gt;branch.autoSetupMerge&lt;/code&gt; configuration flag. That setting can be overridden by using the &lt;code&gt;--track&lt;/code&gt; and &lt;code&gt;--no-track&lt;/code&gt; options, and changed later using &lt;code&gt;git branch --set-upstream-to&lt;/code&gt;.</source>
          <target state="translated">로컬 분기가 원격 추적 분기에서 시작되면 Git은 분기 (특히 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 및 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 구성 항목)를 설정하여 &lt;code&gt;git pull&lt;/code&gt; 이 원격에서 적절히 병합되도록합니다. 추적 지점. 이 동작은 global &lt;code&gt;branch.autoSetupMerge&lt;/code&gt; 구성 플래그 를 통해 변경 될 수 있습니다 . 이 설정은 &lt;code&gt;--track&lt;/code&gt; 및 &lt;code&gt;--no-track&lt;/code&gt; 옵션 을 사용하여 무시 하고 나중에 &lt;code&gt;git branch --set-upstream-to&lt;/code&gt; 를 사용하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbb99a5451930fe8366dedb022737c46385ca3a6" translate="yes" xml:space="preserve">
          <source>When a merge commit is included by &lt;code&gt;--show-pulls&lt;/code&gt;, the merge is treated as if it &quot;pulled&quot; the change from another branch. When using &lt;code&gt;--show-pulls&lt;/code&gt; on this example (and no other options) the resulting graph is:</source>
          <target state="translated">병합 커밋이 &lt;code&gt;--show-pulls&lt;/code&gt; 에 포함 된 경우 병합은 다른 분기에서 변경 사항을 &quot;끌어온&quot;것처럼 처리됩니다. 이 예제 (다른 옵션 없음)에서 &lt;code&gt;--show-pulls&lt;/code&gt; 를 사용 하면 결과 그래프는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e12783acd89ac9262429bc89fcf85d9b95e88c1" translate="yes" xml:space="preserve">
          <source>When a merge conflict happens during switching branches with the &lt;code&gt;-m&lt;/code&gt; option, you would see something like this:</source>
          <target state="translated">&lt;code&gt;-m&lt;/code&gt; 옵션을 사용하여 분기를 전환하는 동안 병합 충돌이 발생 하면 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8b8f6236a48634fd451e67557b1ed432c992a4a6" translate="yes" xml:space="preserve">
          <source>When a merge conflict happens, the index entries for conflicting paths are left unmerged, and you need to resolve the conflicts and mark the resolved paths with &lt;code&gt;git add&lt;/code&gt; (or &lt;code&gt;git rm&lt;/code&gt; if the merge should result in deletion of the path).</source>
          <target state="translated">병합 충돌이 발생하면 충돌하는 경로에 대한 색인 항목이 병합되지 않은 상태로 유지되며 충돌을 해결하고 해결 된 경로를 &lt;code&gt;git add&lt;/code&gt; (또는 병합으로 인해 경로가 삭제되어야하는 경우 &lt;code&gt;git rm&lt;/code&gt; )로 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="054b9e9957838ff74728498487ffff5f26346d88" translate="yes" xml:space="preserve">
          <source>When a merge isn&amp;rsquo;t resolved automatically, Git leaves the index and the working tree in a special state that gives you all the information you need to help resolve the merge.</source>
          <target state="translated">병합이 자동으로 해결되지 않으면 Git은 색인과 작업 트리를 병합 상태를 유지하는 데 필요한 모든 정보를 제공하는 특수 상태로 둡니다.</target>
        </trans-unit>
        <trans-unit id="1d6b6e4ed4a39cb92155b19d26f3a8478b8d6d5c" translate="yes" xml:space="preserve">
          <source>When a new branch is created with &lt;code&gt;git branch&lt;/code&gt;, &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt; that tracks another branch, this variable tells Git to set up pull to rebase instead of merge (see &quot;branch.&amp;lt;name&amp;gt;.rebase&quot;). When &lt;code&gt;never&lt;/code&gt;, rebase is never automatically set to true. When &lt;code&gt;local&lt;/code&gt;, rebase is set to true for tracked branches of other local branches. When &lt;code&gt;remote&lt;/code&gt;, rebase is set to true for tracked branches of remote-tracking branches. When &lt;code&gt;always&lt;/code&gt;, rebase will be set to true for all tracking branches. See &quot;branch.autoSetupMerge&quot; for details on how to set up a branch to track another branch. This option defaults to never.</source>
          <target state="translated">다른 브랜치를 추적 하는 &lt;code&gt;git branch&lt;/code&gt; , &lt;code&gt;git switch&lt;/code&gt; 또는 &lt;code&gt;git checkout&lt;/code&gt; 으로 새 브랜치를 만들면이 변수는 Git에게 병합 대신 rebase로 pull을 설정하도록 지시합니다 ( &quot;branch. &amp;lt;name&amp;gt; .rebase&quot;참조). &lt;code&gt;never&lt;/code&gt; 일 때 rebase는 자동으로 true로 설정되지 않습니다. 때 &lt;code&gt;local&lt;/code&gt; , REBASE 다른 지역 지점의 추적 지점에 대해 true로 설정됩니다. 때 &lt;code&gt;remote&lt;/code&gt; , REBASE 원격 추적 브랜치의 추적 지점에 대해 true로 설정됩니다. 때 &lt;code&gt;always&lt;/code&gt; , REBASE 모든 추적 지점 true로 설정됩니다. 다른 지점을 추적하도록 지점을 설정하는 방법에 대한 자세한 내용은 &quot;branch.autoSetupMerge&quot;를 참조하십시오. 이 옵션의 기본값은 never입니다.</target>
        </trans-unit>
        <trans-unit id="ed0adff8e63a6741e1694d5ebc304264bd392424" translate="yes" xml:space="preserve">
          <source>When a patch failure occurs, &amp;lt;msg&amp;gt; will be printed to the screen before exiting. This overrides the standard message informing you to use &lt;code&gt;--continue&lt;/code&gt; or &lt;code&gt;--skip&lt;/code&gt; to handle the failure. This is solely for internal use between &lt;code&gt;git rebase&lt;/code&gt; and &lt;code&gt;git am&lt;/code&gt;.</source>
          <target state="translated">패치 실패가 발생하면 종료하기 전에 &amp;lt;msg&amp;gt;가 화면에 인쇄됩니다. 이는 &lt;code&gt;--continue&lt;/code&gt; 또는 &lt;code&gt;--skip&lt;/code&gt; 을 사용하여 실패를 처리 하라는 표준 메시지를 무시합니다 . 이것은 &lt;code&gt;git rebase&lt;/code&gt; 와 &lt;code&gt;git am&lt;/code&gt; 사이의 내부 용 입니다.</target>
        </trans-unit>
        <trans-unit id="d5b066fa036c4bb98c79472fbdf38de3d119f100" translate="yes" xml:space="preserve">
          <source>When a patch is part of an ongoing discussion, the patch generated by &lt;code&gt;git format-patch&lt;/code&gt; can be tweaked to take advantage of the &lt;code&gt;git am --scissors&lt;/code&gt; feature. After your response to the discussion comes a line that consists solely of &quot;&lt;code&gt;-- &amp;gt;8 --&lt;/code&gt;&quot; (scissors and perforation), followed by the patch with unnecessary header fields removed:</source>
          <target state="translated">패치가 진행중인 토론의 일부인 경우 &lt;code&gt;git format-patch&lt;/code&gt; 에 의해 생성 된 패치 를 조정하여 &lt;code&gt;git am --scissors&lt;/code&gt; 기능 을 활용할 수 있습니다 . 토론에 대한 응답이 끝나면 &quot; &lt;code&gt;-- &amp;gt;8 --&lt;/code&gt; &quot;(가위 및 천공)으로 구성되고 불필요한 헤더 필드가 제거 된 패치가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="f3cb24e54c9837370739d06bd25b8c911a05ee6b" translate="yes" xml:space="preserve">
          <source>When a path is in the &quot;unmerged&quot; state, running &lt;code&gt;git update-index&lt;/code&gt; for that path tells Git to mark the path resolved.</source>
          <target state="translated">경로가 &quot;머지되지 않은&quot;상태 인 경우 해당 경로에 대해 &lt;code&gt;git update-index&lt;/code&gt; 를 실행 하면 Git에 경로가 해결되었음을 표시하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="f8965008f9824bf8da0b033710c2d7ac1f3f6568" translate="yes" xml:space="preserve">
          <source>When a pure mode change is encountered (which has no index information), the information is read from the current index instead.</source>
          <target state="translated">순수 모드 변경이 발생하면 (인덱스 정보가 없음) 대신 현재 인덱스에서 정보를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="ef4651b07e5b8cb97cb93de85df1d7e556426d24" translate="yes" xml:space="preserve">
          <source>When a push mirror is created with &lt;code&gt;--mirror=push&lt;/code&gt;, then &lt;code&gt;git push&lt;/code&gt; will always behave as if &lt;code&gt;--mirror&lt;/code&gt; was passed.</source>
          <target state="translated">와 푸시 미러가 생성 될 때 &lt;code&gt;--mirror=push&lt;/code&gt; , 다음 &lt;code&gt;git push&lt;/code&gt; 것처럼 항상 작동합니다 &lt;code&gt;--mirror&lt;/code&gt; 이 통과되었다.</target>
        </trans-unit>
        <trans-unit id="deb13d30f8ba66c920f6495f36b99921916b0fbc" translate="yes" xml:space="preserve">
          <source>When a rebase required merge conflicts to be resolved, compare the changes introduced by the rebase directly afterwards using:</source>
          <target state="translated">리베이스에서 병합 충돌을 해결해야하는 경우 다음을 사용하여 리베이스에서 직접 도입 된 변경 사항을 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="350766930233515327656bc7b70b13214a7aa33c" translate="yes" xml:space="preserve">
          <source>When a ref is updated, reflog entries are created to keep track of the reason why the ref was updated (which is typically the name of the high-level command that updated the ref), in addition to the old and new values of the ref. A scripted Porcelain command can use set_reflog_action helper function in &lt;code&gt;git-sh-setup&lt;/code&gt; to set its name to this variable when it is invoked as the top level command by the end user, to be recorded in the body of the reflog.</source>
          <target state="translated">ref가 업데이트되면 ref의 이전 값과 새로운 값 외에 ref가 업데이트 된 이유 (일반적으로 ref를 업데이트 한 상위 명령 이름)를 추적하기 위해 reflog 항목이 작성됩니다. . 스크립트 된 Porcelain 명령은 &lt;code&gt;git-sh-setup&lt;/code&gt; 의 set_reflog_action 헬퍼 함수를 ​​사용 하여 최종 사용자가 최상위 레벨 명령으로 호출 할 때이 변수로 이름을 설정 하여 참조 로그 본문에 기록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a564cf0d83332d2cd6fd3ac884cec9942b078c7" translate="yes" xml:space="preserve">
          <source>When a repository is synchronized via &lt;code&gt;git push&lt;/code&gt; and &lt;code&gt;git pull&lt;/code&gt; objects packed in the source repository are usually stored unpacked in the destination. While this allows you to use different packing strategies on both ends, it also means you may need to repack both repositories every once in a while.</source>
          <target state="translated">소스 리포지토리에 압축 된 &lt;code&gt;git push&lt;/code&gt; 및 &lt;code&gt;git pull&lt;/code&gt; 객체 를 통해 리포지토리가 동기화되면 일반적으로 대상에 압축을 푼 상태로 저장됩니다. 이렇게하면 양쪽에서 서로 다른 포장 전략을 사용할 수 있지만 두 저장소를 한 번에 한 번씩 다시 포장해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="89c3a76b400f69bc409951d41f44580e1ce5b550" translate="yes" xml:space="preserve">
          <source>When a scripting language specific quoting is in effect, everything between a top-level opening atom and its matching %(end) is evaluated according to the semantics of the opening atom and only its result from the top-level is quoted.</source>
          <target state="translated">스크립팅 언어 별 인용이 유효 할 때 최상위 레벨 오프닝 원자와 일치하는 % (end) 사이의 모든 것이 오프닝 원자의 의미론에 따라 평가되며 최상위 레벨의 결과 만 인용됩니다.</target>
        </trans-unit>
        <trans-unit id="1d0d6b410e7d083b396401fa9485dd3214d89132" translate="yes" xml:space="preserve">
          <source>When a variable is said to take a boolean value, many synonyms are accepted for &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;; these are all case-insensitive.</source>
          <target state="translated">변수가 부울 값을 사용한다고 말하면 많은 동의어가 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 에 대해 허용됩니다 . 이것들은 모두 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="085e4eddfd9be8c4f3b576466769939a6475604e" translate="yes" xml:space="preserve">
          <source>When accepting a new code drop for a vendor branch, you probably want to record both the removal of paths and additions of new paths as well as modifications of existing paths.</source>
          <target state="translated">공급 업체 지점에 대한 새 코드 삭제를 승인 할 때 경로 제거 및 새 경로 추가 및 기존 경로 수정을 모두 기록하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98d4ec1ab85d43886cf359223c5c65ec41aa50b0" translate="yes" xml:space="preserve">
          <source>When accepting a signed push (see &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;), the signed push certificate is stored in a blob and an environment variable &lt;code&gt;GIT_PUSH_CERT&lt;/code&gt; can be consulted for its object name. See the description of &lt;code&gt;post-receive&lt;/code&gt; hook for an example. In addition, the certificate is verified using GPG and the result is exported with the following environment variables:</source>
          <target state="translated">서명 된 푸시를 수락하면 ( &lt;a href=&quot;git-push&quot;&gt;git-push [1] 참조&lt;/a&gt; ) 서명 된 푸시 인증서는 BLOB에 저장되고 해당 객체 이름에 대해 환경 변수 &lt;code&gt;GIT_PUSH_CERT&lt;/code&gt; 를 참조 할 수 있습니다. 예는 &lt;code&gt;post-receive&lt;/code&gt; 후크에 대한 설명을 참조하십시오 . 또한 인증서는 GPG를 사용하여 확인되며 결과는 다음 환경 변수와 함께 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="5d78f94855bee5654824b328b5c74fbbbf68d2ce" translate="yes" xml:space="preserve">
          <source>When acquiring credentials, consider the &quot;path&quot; component of an http or https URL to be important. Defaults to false. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for more information.</source>
          <target state="translated">신임 정보를 획득 할 때 http 또는 https URL의 &quot;경로&quot;구성 요소가 중요하다고 생각하십시오. 기본값은 false입니다. 자세한 내용은 &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="36125e3b1dadcf8415f427875bfbe6e3edb592ec" translate="yes" xml:space="preserve">
          <source>When adding notes to an object that already has notes, overwrite the existing notes (instead of aborting).</source>
          <target state="translated">이미 메모가있는 개체에 메모를 추가 할 때 중단 대신 기존 메모를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="31a6893d1f507cb4bce24b6631d6f67bbe0ca8c3" translate="yes" xml:space="preserve">
          <source>When advertising tips of available history from an alternate, use the shell to execute the specified command instead of &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;. The first argument is the absolute path of the alternate. Output must contain one hex object id per line (i.e., the same as produced by &lt;code&gt;git for-each-ref
--format='%(objectname)'&lt;/code&gt;).</source>
          <target state="translated">대체에서 사용 가능한 히스토리 팁을 광고 할 때 &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt; 대신 쉘을 사용하여 지정된 명령을 실행하십시오 . 첫 번째 인수는 대체의 절대 경로입니다. 출력은 라인 당 하나의 16 진 오브젝트 ID를 포함해야합니다 (즉, &lt;code&gt;git for-each-ref --format='%(objectname)'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="aee562f05eaa47b0988f9365fa4403a675334ce1" translate="yes" xml:space="preserve">
          <source>When an argument can be misunderstood as either a revision or a path, they can be disambiguated by placing &lt;code&gt;--&lt;/code&gt; between them. E.g. &lt;code&gt;git diff -- HEAD&lt;/code&gt; is, &quot;I have a file called HEAD in my work tree. Please show changes between the version I staged in the index and what I have in the work tree for that file&quot;, not &quot;show difference between the HEAD commit and the work tree as a whole&quot;. You can say &lt;code&gt;git diff HEAD --&lt;/code&gt; to ask for the latter.</source>
          <target state="translated">인수가 개정이나 경로 중 하나로 오해 할 수있을 때, 그들은 배치하여 명확화 할 수있다 &lt;code&gt;--&lt;/code&gt; 그들 사이. 예를 들어 &lt;code&gt;git diff -- HEAD&lt;/code&gt; 는 &quot;작업 트리에 HEAD라는 파일이 있습니다. 색인에서 준비한 버전과 해당 파일의 작업 트리에있는 버전 간의 변경 사항을 표시하십시오&quot;라는 차이점이 아니라 HEAD 커밋 및 작업 트리 전체 &quot; &lt;code&gt;git diff HEAD --&lt;/code&gt; 라고 말하면 후자를 요청할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ed1e316e9f06aa8f0fbb451acc5e5dd1d53d618" translate="yes" xml:space="preserve">
          <source>When an argument may be understood either as a reference or as a file name, choose to understand it as a format-patch argument (&lt;code&gt;--format-patch&lt;/code&gt;) or as a file name (&lt;code&gt;--no-format-patch&lt;/code&gt;). By default, when such a conflict occurs, git send-email will fail.</source>
          <target state="translated">인수가 참조 또는 파일 이름으로 이해 될 수있는 경우, 인수를 format-patch 인수 ( &lt;code&gt;--format-patch&lt;/code&gt; ) 또는 파일 이름 ( &lt;code&gt;--no-format-patch&lt;/code&gt; ) 으로 이해하도록 선택하십시오 . 기본적으로 이러한 충돌이 발생하면 git send-email이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="daa45faaafc93f57dcfa6219226fd8a2224c7353" translate="yes" xml:space="preserve">
          <source>When an interactive command (such as &lt;code&gt;git add --patch&lt;/code&gt;) shows a colorized diff, git will pipe the diff through the shell command defined by this configuration variable. The command may mark up the diff further for human consumption, provided that it retains a one-to-one correspondence with the lines in the original diff. Defaults to disabled (no filtering).</source>
          <target state="translated">대화식 명령 (예 : &lt;code&gt;git add --patch&lt;/code&gt; )에 색상 화 된 diff가 표시되면 git은이 구성 변수로 정의 된 쉘 명령을 통해 diff를 파이프합니다. 이 명령은 원래 diff의 라인과 일대일로 대응되는 경우 diff를 사람이 소비 할 수 있도록 추가로 마크 업할 수 있습니다. 기본값은 비활성화 (필터링 없음)입니다.</target>
        </trans-unit>
        <trans-unit id="66bd09d84d7f728fe64b22afe9c1d5b02faccf2f" translate="yes" xml:space="preserve">
          <source>When an optional Git branch name (or a Git commit object name) is specified as an argument, the subcommand works on the specified branch, not on the current branch.</source>
          <target state="translated">선택적 Git 브랜치 이름 (또는 Git 커밋 오브젝트 이름)이 인수로 지정되면 부속 명령은 현재 브랜치가 아닌 지정된 브랜치에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="54600ca959ccb5286a6125f852754e8a441f6246" translate="yes" xml:space="preserve">
          <source>When an update changes a branch (or more in general, a ref) that used to point at commit A to point at another commit B, it is called a fast-forward update if and only if B is a descendant of A.</source>
          <target state="translated">업데이트가 커밋 A를 가리키고 다른 커밋 B를 가리킬 때 사용 된 분기 (또는 일반적으로 ref)를 변경하면 B가 A의 자손 인 경우에만 업데이트를 빨리 감기라고합니다.</target>
        </trans-unit>
        <trans-unit id="b999dfcfa57d71ee62dbc42f4d8a0527e63491d1" translate="yes" xml:space="preserve">
          <source>When applying a patch, detect a new or modified line that has whitespace errors. What are considered whitespace errors is controlled by &lt;code&gt;core.whitespace&lt;/code&gt; configuration. By default, trailing whitespaces (including lines that solely consist of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors.</source>
          <target state="translated">패치를 적용 할 때 공백 오류가있는 새 줄이나 수정 된 줄을 찾으십시오. 공백 오류로 간주되는 것은 &lt;code&gt;core.whitespace&lt;/code&gt; 구성에 의해 제어됩니다 . 기본적으로 후행 공백 (공백만으로 구성되는 줄 포함)과 줄의 처음 들여 쓰기 안에 탭 문자가 뒤에 오는 공백 문자는 공백 오류로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b3581e25b4edfc3eae85f688560f931e31414d31" translate="yes" xml:space="preserve">
          <source>When applying a patch, ignore additions made by the patch. This can be used to extract the common part between two files by first running &lt;code&gt;diff&lt;/code&gt; on them and applying the result with this option, which would apply the deletion part but not the addition part.</source>
          <target state="translated">패치를 적용 할 때 패치가 추가 한 내용은 무시하십시오. 이 파일을 사용하여 먼저 &lt;code&gt;diff&lt;/code&gt; 를 실행 하고이 옵션으로 결과를 적용하여 두 파일 사이의 공통 부분을 추출하는 데 사용할 수 있습니다. 이 옵션은 삭제 부분을 적용하지만 추가 부분은 적용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6bf2c606b0bf760a50dfcc2e9e2a1dfc6d6ce1b9" translate="yes" xml:space="preserve">
          <source>When applying a patch, ignore changes in whitespace in context lines if necessary. Context lines will preserve their whitespace, and they will not undergo whitespace fixing regardless of the value of the &lt;code&gt;--whitespace&lt;/code&gt; option. New lines will still be fixed, though.</source>
          <target state="translated">패치를 적용 할 때 필요한 경우 컨텍스트 행에서 공백의 변경 사항을 무시하십시오. 상황에 맞는 줄은 공백을 유지하며 &lt;code&gt;--whitespace&lt;/code&gt; 옵션 의 값에 관계없이 공백을 수정하지 않습니다 . 그러나 새로운 줄은 여전히 ​​수정 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="588f408b6e1e0374e87fb8fe5ff6e5cd0dca42b8" translate="yes" xml:space="preserve">
          <source>When applying the patch only to the working tree, mark new files to be added to the index later (see &lt;code&gt;--intent-to-add&lt;/code&gt; option in &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;). This option is ignored unless running in a Git repository and &lt;code&gt;--index&lt;/code&gt; is not specified. Note that &lt;code&gt;--index&lt;/code&gt; could be implied by other options such as &lt;code&gt;--cached&lt;/code&gt; or &lt;code&gt;--3way&lt;/code&gt;.</source>
          <target state="translated">작업 트리에만 패치를 적용하는 경우 나중에 색인에 추가 할 새 파일을 표시하십시오 ( &lt;a href=&quot;git-add&quot;&gt;git-add [1]의 &lt;/a&gt; &lt;code&gt;--intent-to-add&lt;/code&gt; 옵션 참조 ). Git 리포지토리에서 실행 중이고 &lt;code&gt;--index&lt;/code&gt; 를 지정 하지 않으면이 옵션은 무시 됩니다. 참고 &lt;code&gt;--index&lt;/code&gt; 이 같은 다른 옵션을 암시 할 수 &lt;code&gt;--cached&lt;/code&gt; 또는 &lt;code&gt;--3way&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59fa333bf5332a3a74a0fa1b62097787ae41682d" translate="yes" xml:space="preserve">
          <source>When asking to &lt;code&gt;abort&lt;/code&gt; (which is the default), this program will die when encountering a signed tag. With &lt;code&gt;strip&lt;/code&gt;, the tags will silently be made unsigned, with &lt;code&gt;warn-strip&lt;/code&gt; they will be made unsigned but a warning will be displayed, with &lt;code&gt;verbatim&lt;/code&gt;, they will be silently exported and with &lt;code&gt;warn&lt;/code&gt;, they will be exported, but you will see a warning.</source>
          <target state="translated">&lt;code&gt;abort&lt;/code&gt; 요청하면 (기본값) 서명 된 태그가 발생하면이 프로그램이 종료됩니다. 함께 &lt;code&gt;strip&lt;/code&gt; 과 태그가 자동으로 서명되지 않은 될 것이다 &lt;code&gt;warn-strip&lt;/code&gt; 과, 그들이 서명하게되지만 경고가 표시됩니다 &lt;code&gt;verbatim&lt;/code&gt; , 그들은 자동으로 내 보냅니다과 함께 &lt;code&gt;warn&lt;/code&gt; , 그들은 내보낼 것이다, 그러나 경고가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="a094fa226ab8da9ad05df22ffe9e8c64cbd9aea9" translate="yes" xml:space="preserve">
          <source>When asking to &lt;code&gt;abort&lt;/code&gt; (which is the default), this program will die when encountering such a tag. With &lt;code&gt;drop&lt;/code&gt; it will omit such tags from the output. With &lt;code&gt;rewrite&lt;/code&gt;, if the tagged object is a commit, it will rewrite the tag to tag an ancestor commit (via parent rewriting; see &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;abort&lt;/code&gt; 요청할 때 (기본값)이 태그가 있으면이 프로그램이 종료됩니다. &lt;code&gt;drop&lt;/code&gt; 을 사용 하면 출력에서 ​​해당 태그를 생략합니다. 로 &lt;code&gt;rewrite&lt;/code&gt; 태깅 된 물체가있는 경우, A는 커밋이 조상 커밋 태그 태그 재기록한다 (재기록 부모를 통해, 참조 &lt;a href=&quot;git-rev-list&quot;&gt;자식-REV-목록 [1]&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="034f3e54dc418fd0aaba391926e4cdc6f9338cc5" translate="yes" xml:space="preserve">
          <source>When called with &lt;code&gt;--incremental&lt;/code&gt; option, the command outputs the result as it is built. The output generally will talk about lines touched by more recent commits first (i.e. the lines will be annotated out of order) and is meant to be used by interactive viewers.</source>
          <target state="translated">&lt;code&gt;--incremental&lt;/code&gt; 옵션 과 함께 호출 하면 명령이 빌드 될 때 결과를 출력합니다. 출력은 일반적으로 가장 최근의 커밋에 의해 먼저 터치 된 라인에 대해 이야기합니다 (즉, 라인에 순서가 주석 처리되지 않음). 인터랙티브 뷰어가 사용합니다.</target>
        </trans-unit>
        <trans-unit id="37ed40c0b9c191bc52be1eea56e95c21c8c30c92" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, check out stage #2 (&lt;code&gt;ours&lt;/code&gt;) or #3 (&lt;code&gt;theirs&lt;/code&gt;) for unmerged paths.</source>
          <target state="translated">인덱스에서 경로를 조사한 결과에 의하면,이 스테이지 # 2 (체크 아웃 &lt;code&gt;ours&lt;/code&gt; ) 또는 # 3 ( &lt;code&gt;theirs&lt;/code&gt; 병합 경로에 대한 참조).</target>
        </trans-unit>
        <trans-unit id="b2d7eb083886da1526ca38a6780f9e98825df5e6" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, do not fail upon unmerged entries; instead, unmerged entries are ignored.</source>
          <target state="translated">색인에서 경로를 체크 아웃 할 때 병합되지 않은 항목에 실패하지 마십시오. 대신 병합되지 않은 항목은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="87b021689017efd0b4fbe642f48fde6408f7cde4" translate="yes" xml:space="preserve">
          <source>When checking out paths from the index, this option lets you recreate the conflicted merge in the specified paths.</source>
          <target state="translated">인덱스에서 경로를 체크 아웃 할 때이 옵션을 사용하면 지정된 경로에서 충돌 병합을 다시 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44968c91f62b2f1c7eb77848556b128eac9d4512" translate="yes" xml:space="preserve">
          <source>When cloning an SVN repository, if none of the options for describing the repository layout is used (--trunk, --tags, --branches, --stdlayout), &lt;code&gt;git svn clone&lt;/code&gt; will create a Git repository with completely linear history, where branches and tags appear as separate directories in the working copy. While this is the easiest way to get a copy of a complete repository, for projects with many branches it will lead to a working copy many times larger than just the trunk. Thus for projects using the standard directory structure (trunk/branches/tags), it is recommended to clone with option &lt;code&gt;--stdlayout&lt;/code&gt;. If the project uses a non-standard structure, and/or if branches and tags are not required, it is easiest to only clone one directory (typically trunk), without giving any repository layout options. If the full history with branches and tags is required, the options &lt;code&gt;--trunk&lt;/code&gt; / &lt;code&gt;--branches&lt;/code&gt; / &lt;code&gt;--tags&lt;/code&gt; must be used.</source>
          <target state="translated">SVN 저장소를 복제 할 때 저장소 레이아웃을 설명하는 옵션이 사용되지 않으면 (--trunk, --tags, --branches, --stdlayout) &lt;code&gt;git svn clone&lt;/code&gt; 은 완전히 선형적인 히스토리가있는 Git 저장소를 작성합니다. 분기 및 태그는 작업 복사본에서 별도의 디렉토리로 나타납니다. 이것이 완전한 저장소의 사본을 얻는 가장 쉬운 방법이지만 분기가 많은 프로젝트의 경우 트렁크보다 몇 배 더 큰 작업 사본으로 이어질 것입니다. 따라서 표준 디렉토리 구조 (트렁크 / 분기 / 태그)를 사용하는 프로젝트의 경우 &lt;code&gt;--stdlayout&lt;/code&gt; 옵션을 사용하여 복제하는 것이 좋습니다.. 프로젝트가 비표준 구조를 사용하거나 분기 및 태그가 필요하지 않은 경우 저장소 레이아웃 옵션을 제공하지 않고 하나의 디렉토리 (일반적으로 트렁크) 만 복제하는 것이 가장 쉽습니다. 브랜치와 태그와 전체 역사는이 필요한 경우, 옵션은 &lt;code&gt;--trunk&lt;/code&gt; / &lt;code&gt;--branches&lt;/code&gt; / &lt;code&gt;--tags&lt;/code&gt; 가 사용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="cf5bdc8ee9de0e891bd2e2ffd6ad5374a27fb398" translate="yes" xml:space="preserve">
          <source>When cloning or pulling a repository containing submodules the submodules will not be checked out by default; You can instruct &lt;code&gt;clone&lt;/code&gt; to recurse into submodules. The &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; subcommands of &lt;code&gt;git submodule&lt;/code&gt; will maintain submodules checked out and at an appropriate revision in your working tree. Alternatively you can set &lt;code&gt;submodule.recurse&lt;/code&gt; to have &lt;code&gt;checkout&lt;/code&gt; recursing into submodules.</source>
          <target state="translated">서브 모듈을 포함하는 저장소를 복제하거나 가져올 때 서브 모듈은 기본적으로 체크 아웃되지 않습니다. &lt;code&gt;clone&lt;/code&gt; 가 하위 모듈로 재귀 하도록 지시 할 수 있습니다 . &lt;code&gt;git submodule&lt;/code&gt; 의 &lt;code&gt;init&lt;/code&gt; 및 &lt;code&gt;update&lt;/code&gt; 하위 명령은 하위 트리를 체크 아웃 한 상태로 작업 트리에서 적절히 수정합니다. 또는 &lt;code&gt;submodule.recurse&lt;/code&gt; 를 설정 하여 &lt;code&gt;checkout&lt;/code&gt; 서브 모듈 로 되풀이되도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2bdda0ba49ff183f8b76fb42fb3146b89e404d42" translate="yes" xml:space="preserve">
          <source>When cloning or pulling a repository containing submodules the submodules will not be checked out by default; you can instruct &lt;code&gt;clone&lt;/code&gt; to recurse into submodules. The &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; subcommands of &lt;code&gt;git submodule&lt;/code&gt; will maintain submodules checked out and at an appropriate revision in your working tree. Alternatively you can set &lt;code&gt;submodule.recurse&lt;/code&gt; to have &lt;code&gt;checkout&lt;/code&gt; recursing into submodules (note that &lt;code&gt;submodule.recurse&lt;/code&gt; also affects other Git commands, see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for a complete list).</source>
          <target state="translated">하위 모듈을 포함하는 저장소를 복제하거나 가져올 때 하위 모듈은 기본적으로 체크 아웃되지 않습니다. &lt;code&gt;clone&lt;/code&gt; 에게 하위 모듈로 재귀 하도록 지시 할 수 있습니다 . &lt;code&gt;git submodule&lt;/code&gt; 의 &lt;code&gt;init&lt;/code&gt; 및 &lt;code&gt;update&lt;/code&gt; 하위 명령은 하위 모듈을 체크 아웃하고 작업 트리의 적절한 개정판으로 유지합니다. 또는 &lt;code&gt;submodule.recurse&lt;/code&gt; 를 설정 하여 &lt;code&gt;checkout&lt;/code&gt; 하위 모듈 로 반복되도록 할 수 있습니다 ( &lt;code&gt;submodule.recurse&lt;/code&gt; 는 다른 Git 명령에도 영향을줍니다 . 전체 목록 은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e96f700dec6ecf67635f001fe97af20a3a1af7ba" translate="yes" xml:space="preserve">
          <source>When combining multiple &lt;code&gt;--contains&lt;/code&gt; and &lt;code&gt;--no-contains&lt;/code&gt; filters, only references that contain at least one of the &lt;code&gt;--contains&lt;/code&gt; commits and contain none of the &lt;code&gt;--no-contains&lt;/code&gt; commits are shown.</source>
          <target state="translated">여러 &lt;code&gt;--contains&lt;/code&gt; 및 &lt;code&gt;--no-contains&lt;/code&gt; 필터를 결합 할 때 &lt;code&gt;--contains&lt;/code&gt; 커밋 중 하나 이상을 포함 하고 &lt;code&gt;--no-contains&lt;/code&gt; 커밋을 포함하지 않는 참조 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3693ecef45adf0e594fc21eeb7dc1180a98b303e" translate="yes" xml:space="preserve">
          <source>When combining multiple &lt;code&gt;--merged&lt;/code&gt; and &lt;code&gt;--no-merged&lt;/code&gt; filters, only references that are reachable from at least one of the &lt;code&gt;--merged&lt;/code&gt; commits and from none of the &lt;code&gt;--no-merged&lt;/code&gt; commits are shown.</source>
          <target state="translated">여러 개의 &lt;code&gt;--merged&lt;/code&gt; 및 &lt;code&gt;--no-merged&lt;/code&gt; 필터를 결합 할 때 &lt;code&gt;--merged&lt;/code&gt; 커밋 중 하나 이상에서 도달 할 수 있고 &lt;code&gt;--no-merged&lt;/code&gt; 커밋 중 하나에서도 도달 할 수있는 참조 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f6f5e261fa8e1325a05e77f0fa02cd4e804a016b" translate="yes" xml:space="preserve">
          <source>When committing fixups, consider using &lt;code&gt;merge&lt;/code&gt; to connect the commit(s) which are supplying file revisions to the fixup branch. Doing so will allow tools such as &lt;code&gt;git blame&lt;/code&gt; to track through the real commit history and properly annotate the source files.</source>
          <target state="translated">수정 사항을 커미트 할 때 &lt;code&gt;merge&lt;/code&gt; 을 사용하여 파일 개정판을 제공하는 커미트를 수정 사항 브랜치에 연결하십시오. 그렇게하면 &lt;code&gt;git blame&lt;/code&gt; 과 같은 도구 가 실제 커밋 기록을 추적하고 소스 파일에 주석을 달 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="187746ad8497cb1dac2dfe493269450955422d85" translate="yes" xml:space="preserve">
          <source>When committing to svn from Git (as part of &lt;code&gt;set-tree&lt;/code&gt; or &lt;code&gt;dcommit&lt;/code&gt; operations), if the existing log message doesn&amp;rsquo;t already have a &lt;code&gt;From:&lt;/code&gt; or &lt;code&gt;Signed-off-by:&lt;/code&gt; line, append a &lt;code&gt;From:&lt;/code&gt; line based on the Git commit&amp;rsquo;s author string. If you use this, then &lt;code&gt;--use-log-author&lt;/code&gt; will retrieve a valid author string for all commits.</source>
          <target state="translated">&lt;code&gt;set-tree&lt;/code&gt; 또는 &lt;code&gt;dcommit&lt;/code&gt; 작업의 일부로 Git에서 svn을 커밋 할 때 기존 로그 메시지에 &lt;code&gt;From:&lt;/code&gt; 또는 &lt;code&gt;Signed-off-by:&lt;/code&gt; 행 이없는 경우 Git 커밋을 기반으로 &lt;code&gt;From:&lt;/code&gt; 행을 추가하십시오 . 저자 문자열. 이것을 사용하면 &lt;code&gt;--use-log-author&lt;/code&gt; 는 모든 커밋에 대해 유효한 작성자 문자열을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="df4d9e8de337675930b7c7d126c3cbfdb0d919e8" translate="yes" xml:space="preserve">
          <source>When common porcelain operations that create objects are run, they will check whether the repository has grown substantially since the last maintenance, and if so run &lt;code&gt;git gc&lt;/code&gt; automatically. See &lt;code&gt;gc.auto&lt;/code&gt; below for how to disable this behavior.</source>
          <target state="translated">객체를 생성하는 일반적인 도자기 작업이 실행될 때 리포지토리가 마지막 유지 관리 이후 실질적으로 커 졌는지 확인하고 &lt;code&gt;git gc&lt;/code&gt; 를 자동으로 실행 합니다. 이 동작을 비활성화하는 방법은 아래 &lt;code&gt;gc.auto&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5cef5cc19d56f034a0850f6ce0dc6add0c966a70" translate="yes" xml:space="preserve">
          <source>When comparing two trees, the ID of both trees (separated by a space and terminated by a newline) is printed before the difference. When comparing commits, the ID of the first (or only) commit, followed by a newline, is printed.</source>
          <target state="translated">두 트리를 비교할 때 두 트리의 ID (공백으로 구분되고 줄 바꾸기로 종료 됨)가 차이 전에 인쇄됩니다. 커밋을 비교할 때 첫 번째 (또는 유일한) 커밋의 ID와 그 뒤에 줄 바꿈이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="fe249445673b1134855083e0c3b366c4aeeb2c8e" translate="yes" xml:space="preserve">
          <source>When converting a value to its canonical form using the &lt;code&gt;--type=bool&lt;/code&gt; type specifier, &lt;code&gt;git config&lt;/code&gt; will ensure that the output is &quot;true&quot; or &quot;false&quot; (spelled in lowercase).</source>
          <target state="translated">&lt;code&gt;--type=bool&lt;/code&gt; 유형 지정자를 사용하여 값을 표준 형식으로 변환 할 때 &lt;code&gt;git config&lt;/code&gt; 는 출력이 &quot;true&quot;또는 &quot;false&quot;(소문자로 표시)인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5800d8777d6f116b967a3c4b503079e04a8dd27b" translate="yes" xml:space="preserve">
          <source>When copying a remote repository, you&amp;rsquo;ll want to at a minimum update the index cache when you do this, and especially with other peoples' repositories you often want to make sure that the index cache is in some known state (you don&amp;rsquo;t know &lt;strong&gt;what&lt;/strong&gt; they&amp;rsquo;ve done and not yet checked in), so usually you&amp;rsquo;ll precede the &lt;code&gt;git update-index&lt;/code&gt; with a</source>
          <target state="translated">원격 리포지토리를 복사 할 때는 인덱스 캐시를 최소한 업데이트해야하며, 특히 다른 사람의 리포지토리를 사용하는 경우 인덱스 캐시가 알려진 상태에 있는지 확인하려고합니다. 그들이 &lt;strong&gt;무엇&lt;/strong&gt; 을했고 아직 체크인하지 않았 &lt;strong&gt;는지&lt;/strong&gt; 알기 때문에 일반적으로 &lt;code&gt;git update-index&lt;/code&gt; 앞에 a</target>
        </trans-unit>
        <trans-unit id="a0c9c076efebd050282e8220820bf37e469a5914" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite (see the &quot;notes.rewrite.&amp;lt;command&amp;gt;&quot; option), determines what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. Defaults to &lt;code&gt;concatenate&lt;/code&gt;.</source>
          <target state="translated">다시 쓰는 동안 메모를 복사 할 때 ( &quot;notes.rewrite. &amp;lt;command&amp;gt;&quot;옵션 참조) 대상 커밋에 이미 메모가있는 경우 수행 할 작업을 결정합니다. &lt;code&gt;overwrite&lt;/code&gt; , &lt;code&gt;concatenate&lt;/code&gt; , &lt;code&gt;cat_sort_uniq&lt;/code&gt; 또는 &lt;code&gt;ignore&lt;/code&gt; 중 하나 여야합니다 . &lt;code&gt;concatenate&lt;/code&gt; 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="f2daf889c63a8ae3ef0bd84b9e0a7bae3186ea5d" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied. May be a glob, in which case notes in all matching refs will be copied. You may also specify this configuration several times.</source>
          <target state="translated">다시 쓰는 동안 메모를 복사 할 때 메모를 복사해야하는 정규화 된 참조를 지정합니다. glob 일 수 있으며,이 경우 일치하는 모든 참조의 메모가 복사됩니다. 이 구성을 여러 번 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c445d369a5c50740a59f3ad28697ace644e2811e" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, specifies the (fully qualified) ref whose notes should be copied. The ref may be a glob, in which case notes in all matching refs will be copied. You may also specify this configuration several times.</source>
          <target state="translated">다시 쓰는 동안 메모를 복사 할 때 메모를 복사해야하는 정규화 된 참조를 지정합니다. 심판은 글로브 일 수 있으며,이 경우 일치하는 모든 심판의 노트가 복사됩니다. 이 구성을 여러 번 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1243aaab79ff33e7a2d49c8eb8b4f16703a1c016" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. Defaults to &lt;code&gt;concatenate&lt;/code&gt;.</source>
          <target state="translated">다시 쓰는 동안 메모를 복사 할 때 대상 커밋에 이미 메모가있는 경우 수행 할 작업입니다. &lt;code&gt;overwrite&lt;/code&gt; , &lt;code&gt;concatenate&lt;/code&gt; , &lt;code&gt;cat_sort_uniq&lt;/code&gt; 또는 &lt;code&gt;ignore&lt;/code&gt; 중 하나 여야합니다 . &lt;code&gt;concatenate&lt;/code&gt; 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="fb6ea94e62e06bb5ee870300111df0d9f630f320" translate="yes" xml:space="preserve">
          <source>When copying notes during a rewrite, what to do if the target commit already has a note. Must be one of &lt;code&gt;overwrite&lt;/code&gt;, &lt;code&gt;concatenate&lt;/code&gt;, &lt;code&gt;cat_sort_uniq&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;. This overrides the &lt;code&gt;core.rewriteMode&lt;/code&gt; setting.</source>
          <target state="translated">다시 쓰는 동안 메모를 복사 할 때 대상 커밋에 이미 메모가있는 경우 수행 할 작업입니다. &lt;code&gt;overwrite&lt;/code&gt; , &lt;code&gt;concatenate&lt;/code&gt; , &lt;code&gt;cat_sort_uniq&lt;/code&gt; 또는 &lt;code&gt;ignore&lt;/code&gt; 중 하나 여야합니다 . 이것은 &lt;code&gt;core.rewriteMode&lt;/code&gt; 설정을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="fa7e030aba2e9a9a4e5882753f19d2b4a66b4e16" translate="yes" xml:space="preserve">
          <source>When creating a new branch, if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a branch, mark it as &quot;upstream&quot; from the new branch. This is the default if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a remote-tracking branch. See &quot;--track&quot; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">새 분기를 만들 때 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 가 분기 인 경우 새 분기에서 &quot;업스트림&quot;으로 표시하십시오. &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 가 원격 추적 분기 인 경우 이것이 기본값 입니다. 자세한 내용은 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]의&lt;/a&gt; &quot;--track&quot; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4e04dc75cba18b40521f918d2128a9cc7f50298f" translate="yes" xml:space="preserve">
          <source>When creating a new branch, if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a branch, mark it as &quot;upstream&quot; from the new branch. This is the default if &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a remote-tracking branch. See &lt;code&gt;--track&lt;/code&gt; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">새 브랜치를 만들 때 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 가 브랜치이면 새 브랜치에서 &quot;업스트림&quot;으로 표시합니다. &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 가 원격 추적 분기 인 경우 이것이 기본값 입니다. 자세한 내용 은 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]의 &lt;/a&gt; &lt;code&gt;--track&lt;/code&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="54d8049451fa958ada38921d90347d3ee7c4d771" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &quot;upstream&quot; configuration. &lt;code&gt;-c&lt;/code&gt; is implied. See &lt;code&gt;--track&lt;/code&gt; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">새 브랜치를 생성 할 때 &quot;업스트림&quot;구성을 설정하십시오. &lt;code&gt;-c&lt;/code&gt; 가 암시됩니다. 자세한 내용 은 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]의 &lt;/a&gt; &lt;code&gt;--track&lt;/code&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="fc590aa31fec73c4296b9f428640a84b6d3e91a7" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &quot;upstream&quot; configuration. See &quot;--track&quot; in &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">새 브랜치를 생성 할 때 &quot;업스트림&quot;구성을 설정하십시오. 자세한 내용은 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]의&lt;/a&gt; &quot;--track&quot; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="67211ea9327a11f7c102d4d6622e44707e57316e" translate="yes" xml:space="preserve">
          <source>When creating a new branch, set up &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; configuration entries to mark the start-point branch as &quot;upstream&quot; from the new branch. This configuration will tell git to show the relationship between the two branches in &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git branch -v&lt;/code&gt;. Furthermore, it directs &lt;code&gt;git pull&lt;/code&gt; without arguments to pull from the upstream when the new branch is checked out.</source>
          <target state="translated">새 분기를 만들 때는 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 및 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 구성 항목을 설정하여 새 분기에서 시작 지점을 &quot;업스트림&quot;으로 표시하십시오. 이 설정은 git에게 &lt;code&gt;git status&lt;/code&gt; 와 &lt;code&gt;git branch -v&lt;/code&gt; 의 두 브랜치 사이의 관계를 보여줄 것을 지시합니다 . 또한 새로운 분기가 체크 아웃 될 때 인수없이 &lt;code&gt;git pull&lt;/code&gt; 이 업스트림에서 끌어 오도록 지시 합니다.</target>
        </trans-unit>
        <trans-unit id="30421c6d8900807173aa121649f943a72b9b4dbe" translate="yes" xml:space="preserve">
          <source>When creating a packed archive in a repository that has existing packs, the command reuses existing deltas. This sometimes results in a slightly suboptimal pack. This flag tells the command not to reuse existing deltas but compute them from scratch.</source>
          <target state="translated">기존 팩이있는 저장소에서 묶음 아카이브를 작성할 때 명령은 기존 델타를 재사용합니다. 이로 인해 때때로 약간 차선책이됩니다. 이 플래그는 명령에 기존 델타를 재사용하지 말고 처음부터 계산하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="40641904740525d3a46d2f53ea1f042429403d62" translate="yes" xml:space="preserve">
          <source>When creating files, prepend &amp;lt;string&amp;gt; (usually a directory including a trailing /)</source>
          <target state="translated">파일을 만들 때 &amp;lt;string&amp;gt;을 추가하십시오 (일반적으로 후행 /를 포함하는 디렉토리)</target>
        </trans-unit>
        <trans-unit id="55d2573d14b31c180f96244b6210a62251fe4b79" translate="yes" xml:space="preserve">
          <source>When dealing with &lt;code&gt;git diff-tree&lt;/code&gt; output, it takes advantage of the fact that the patch is prefixed with the object name of the commit, and outputs two 40-byte hexadecimal strings. The first string is the patch ID, and the second string is the commit ID. This can be used to make a mapping from patch ID to commit ID.</source>
          <target state="translated">&lt;code&gt;git diff-tree&lt;/code&gt; 출력을 다룰 때 , 패치는 커밋의 객체 이름으로 접두사가 붙고 2 개의 40 바이트 16 진 문자열을 출력한다는 사실을 이용합니다. 첫 번째 문자열은 패치 ID이고 두 번째 문자열은 커밋 ID입니다. 패치 ID에서 커밋 ID로 매핑하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d776ef3252048cd13183a8501d7c0015731386cd" translate="yes" xml:space="preserve">
          <source>When deciding what attributes are assigned to a path, Git consults &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; file (which has the highest precedence), &lt;code&gt;.gitattributes&lt;/code&gt; file in the same directory as the path in question, and its parent directories up to the toplevel of the work tree (the further the directory that contains &lt;code&gt;.gitattributes&lt;/code&gt; is from the path in question, the lower its precedence). Finally global and system-wide files are considered (they have the lowest precedence).</source>
          <target state="translated">경로에 할당 할 속성을 결정할 때 Git은 &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; 파일 (가장 높은 우선 순위), 해당 경로와 동일한 디렉토리에있는 &lt;code&gt;.gitattributes&lt;/code&gt; 파일 및 상위 디렉토리까지 상위 디렉토리를 참조합니다. 작업 트리 ( &lt;code&gt;.gitattributes&lt;/code&gt; 를 포함하는 디렉토리가 멀면 문제의 경로에서 멀어 질수록 우선 순위가 낮습니다). 마지막으로 전역 및 시스템 전체 파일이 고려됩니다 (가장 낮은 우선 순위를 가짐).</target>
        </trans-unit>
        <trans-unit id="be47e73cae5925c270f0353e0b448f44fba38688" translate="yes" xml:space="preserve">
          <source>When deinitialized or deleted (see below), the submodule&amp;rsquo;s Git directory is automatically moved to &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; of the superproject.</source>
          <target state="translated">초기화가 해제되거나 삭제되면 (아래 참조) 서브 모듈의 Git 디렉토리는 자동으로 수퍼 &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; 으로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="d6198e5c096df70165a4ba7282b14c9062838d85" translate="yes" xml:space="preserve">
          <source>When displaying names of reachable objects, in addition to the SHA-1 also display a name that describes &lt;strong&gt;how&lt;/strong&gt; they are reachable, compatible with &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;, e.g. &lt;code&gt;HEAD@{1234567890}~25^2:src/&lt;/code&gt;.</source>
          <target state="translated">도달 가능한 객체의 이름을 표시 할 때 SHA-1 외에도 &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt; 과 호환되는 &lt;strong&gt;방법 (&lt;/strong&gt; 예 : &lt;code&gt;HEAD@{1234567890}~25^2:src/&lt;/code&gt; 을 설명 &lt;strong&gt;하는&lt;/strong&gt; 이름도 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="39ccc422d97039f55d5b75b982904e65809f0ab0" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in a porcelain-ready format. See &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; for details. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">드라이-런을 수행 할 때는 출력을 도자기 준비 형식으로 제공하십시오. 자세한 내용은 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 를 참조하십시오. &lt;code&gt;--dry-run&lt;/code&gt; 을 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="91fdf83cd4cf2351c13b94fc0d59dcd9a51c5b73" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in the long-format. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">드라 이런을 수행 할 때는 출력을 긴 형식으로 제공하십시오. &lt;code&gt;--dry-run&lt;/code&gt; 을 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="7320eee3c7f6d76666dfe697952518d827846a03" translate="yes" xml:space="preserve">
          <source>When doing a dry-run, give the output in the short-format. See &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; for details. Implies &lt;code&gt;--dry-run&lt;/code&gt;.</source>
          <target state="translated">드라 이런을 수행 할 때는 짧은 형식으로 출력하십시오. 자세한 내용은 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 를 참조하십시오. &lt;code&gt;--dry-run&lt;/code&gt; 을 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="9aa102d4a4b04252e6d4b5a0080dce309ef777d4" translate="yes" xml:space="preserve">
          <source>When doing a repository conversion, use a unique mark per commit (&lt;code&gt;mark :&amp;lt;n&amp;gt;&lt;/code&gt;) and supply the --export-marks option on the command line. fast-import will dump a file which lists every mark and the Git object SHA-1 that corresponds to it. If the frontend can tie the marks back to the source repository, it is easy to verify the accuracy and completeness of the import by comparing each Git commit to the corresponding source revision.</source>
          <target state="translated">저장소 변환을 수행 할 때 고유 한 커밋 당 표시 ( &lt;code&gt;mark :&amp;lt;n&amp;gt;&lt;/code&gt; )를 사용하고 명령 행에 --export-marks 옵션을 제공하십시오. fast-import는 모든 마크와 이에 해당하는 Git 객체 SHA-1을 나열하는 파일을 덤프합니다. 프론트 엔드가 마크를 소스 리포지토리에 다시 연결할 수있는 경우 각 Git 커밋을 해당 소스 개정과 비교하여 가져 오기의 정확성과 완전성을 쉽게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f397bf185a0b1be7403f8c718221517e54d79b2" translate="yes" xml:space="preserve">
          <source>When editing the commit message, start the editor with the contents in the given file. The &lt;code&gt;commit.template&lt;/code&gt; configuration variable is often used to give this option implicitly to the command. This mechanism can be used by projects that want to guide participants with some hints on what to write in the message in what order. If the user exits the editor without editing the message, the commit is aborted. This has no effect when a message is given by other means, e.g. with the &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; options.</source>
          <target state="translated">커밋 메시지를 편집 할 때 주어진 파일의 내용으로 편집기를 시작하십시오. &lt;code&gt;commit.template&lt;/code&gt; 의 구성 변수는 종종 명령에 암시 적으로이 옵션을 제공하는 데 사용됩니다. 이 메커니즘은 메시지에 어떤 순서로 작성해야하는지에 대한 힌트를 참가자에게 안내하려는 프로젝트에서 사용할 수 있습니다. 사용자가 메시지를 편집하지 않고 편집기를 종료하면 커밋이 중단됩니다. 메시지가 다른 수단 (예 : &lt;code&gt;-m&lt;/code&gt; 또는 &lt;code&gt;-F&lt;/code&gt; 옵션 )으로 제공되는 경우에는 효과가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7835173f74e58e15c8891f5a3e0b3af743fd1c66" translate="yes" xml:space="preserve">
          <source>When editing, provide the raw object contents rather than pretty-printed ones. Currently this only affects trees, which will be shown in their binary form. This is harder to work with, but can help when repairing a tree that is so corrupted it cannot be pretty-printed. Note that you may need to configure your editor to cleanly read and write binary data.</source>
          <target state="translated">편집 할 때 예쁘게 인쇄 된 것이 아니라 원시 객체 내용을 제공하십시오. 현재 이것은 나무에만 영향을 미치며 이진 형식으로 표시됩니다. 이것은 작업하기가 어렵지만 너무 손상된 나무를 고칠 때는 꽤 인쇄 할 수 없습니다. 이진 데이터를 깨끗하게 읽고 쓰도록 편집기를 구성해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce47e94310de9fcb0d82c1f052bbcc38f3a11f76" translate="yes" xml:space="preserve">
          <source>When enabled, the default &lt;code&gt;post-update&lt;/code&gt; hook runs &lt;code&gt;git update-server-info&lt;/code&gt; to keep the information used by dumb transports (e.g., HTTP) up to date. If you are publishing a Git repository that is accessible via HTTP, you should probably enable this hook.</source>
          <target state="translated">활성화 된 경우 기본 &lt;code&gt;post-update&lt;/code&gt; 후크는 &lt;code&gt;git update-server-info&lt;/code&gt; 를 실행 하여 바보 전송 (예 : HTTP)에서 사용하는 정보를 최신 상태로 유지합니다. HTTP를 통해 액세스 할 수있는 Git 저장소를 공개하는 경우이 후크를 사용 가능하게해야합니다.</target>
        </trans-unit>
        <trans-unit id="a529b1482d7666548417edb1d901df1240194350" translate="yes" xml:space="preserve">
          <source>When encountering a non-ASCII message or subject that does not declare its encoding, add headers/quoting to indicate it is encoded in &amp;lt;encoding&amp;gt;. Default is the value of the &lt;code&gt;sendemail.assume8bitEncoding&lt;/code&gt;; if that is unspecified, this will be prompted for if any non-ASCII files are encountered.</source>
          <target state="translated">비 ASCII 메시지 또는 인코딩을 선언하지 않은 제목이 나타나면 &amp;lt;encoding&amp;gt;으로 인코딩되었음을 나타내는 헤더 / 인용 부호를 추가하십시오. 기본값은 &lt;code&gt;sendemail.assume8bitEncoding&lt;/code&gt; 의 값입니다 . 지정되지 않은 경우 비 ASCII 파일이 있는지 묻는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c331bd8bb74634e4f18684aaa53f36ba8f8cf37d" translate="yes" xml:space="preserve">
          <source>When erasing credentials, matching credentials will be erased from all files.</source>
          <target state="translated">자격 증명을 지우면 일치하는 자격 증명이 모든 파일에서 지워집니다.</target>
        </trans-unit>
        <trans-unit id="74e58a3904b06fc63c005d33dc33b553098868b7" translate="yes" xml:space="preserve">
          <source>When extensions.worktreeConfig is enabled, the config file &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; is read after &lt;code&gt;.git/config&lt;/code&gt; is.</source>
          <target state="translated">extensions.worktreeConfig가 활성화되면 &lt;code&gt;.git/config&lt;/code&gt; 가 실행 된 후 구성 파일 &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; 를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="3a73371934954e7de3c00c5b21339d1552e97b06" translate="yes" xml:space="preserve">
          <source>When false, merge the current branch into the upstream branch.</source>
          <target state="translated">false 인 경우 현재 분기를 업스트림 분기로 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="d5dfb7a500ca38e6f311c3fe54f4fbaf71bc47ce" translate="yes" xml:space="preserve">
          <source>When fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of &lt;code&gt;remote.*.fetch&lt;/code&gt; configuration variables for the remote repository. Providing an empty &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; to the &lt;code&gt;--refmap&lt;/code&gt; option causes Git to ignore the configured refspecs and rely entirely on the refspecs supplied as command-line arguments. See section on &quot;Configured Remote-tracking Branches&quot; for details.</source>
          <target state="translated">명령 줄에 나열된 참조를 &lt;code&gt;remote.*.fetch&lt;/code&gt; 때 원격 저장소에 대한 remote. *. fetch 구성 변수 값 대신 지정된 참조 사양 (두 번 이상 제공 가능)을 사용하여 참조를 원격 추적 분기에 매핑 합니다. &lt;code&gt;--refmap&lt;/code&gt; 옵션에 빈 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 을 제공 하면 Git은 구성된 refspec 을 무시하고 명령 줄 인수로 제공된 refspec에 전적으로 의존합니다. 자세한 내용은 &quot;구성된 원격 추적 분기&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c8afe72df4116adf55dd615031acfafbceae0ec5" translate="yes" xml:space="preserve">
          <source>When fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of &lt;code&gt;remote.*.fetch&lt;/code&gt; configuration variables for the remote repository. See section on &quot;Configured Remote-tracking Branches&quot; for details.</source>
          <target state="translated">명령 행에 나열된 참조를 페치 할 때, 지정된 refspec (두 번 이상 제공 가능)을 사용 하여 원격 저장소에 대한 &lt;code&gt;remote.*.fetch&lt;/code&gt; 구성 변수 값 대신 참조를 원격 추적 분기에 맵핑하십시오 . 자세한 내용은 &quot;구성된 원격 추적 분기&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f131c02a4584603f0de6ca46a404ddf3258dbf13" translate="yes" xml:space="preserve">
          <source>When files are modified outside of Git, the user will need to stage the modified files explicitly (e.g. see &lt;code&gt;Examples&lt;/code&gt; section in &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;). Git will not normally detect changes to those files.</source>
          <target state="translated">Git 외부에서 파일을 수정하는 경우 사용자는 수정 된 파일을 명시 적으로 스테이징해야합니다 (예 : &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]의 &lt;/a&gt; &lt;code&gt;Examples&lt;/code&gt; 섹션 참조 ). Git은 일반적으로 해당 파일의 변경 사항을 감지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e95f7718835508fa2f714691dae7615b5ccee03a" translate="yes" xml:space="preserve">
          <source>When filtering history with &lt;code&gt;&amp;lt;path&amp;gt;&amp;hellip;​&lt;/code&gt;, does not prune some history. (See &quot;History simplification&quot; in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for a more detailed explanation.)</source>
          <target state="translated">와 역사를 필터링 할 때 &lt;code&gt;&amp;lt;path&amp;gt;&amp;hellip;​&lt;/code&gt; , 어떤 역사를 제거하지 않습니다. ( 자세한 설명 은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]의&lt;/a&gt; &quot;히스토리 단순화&quot;를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="18f94df4064f0faddb37415d13a088dd57356563" translate="yes" xml:space="preserve">
          <source>When first created, objects are stored in individual files, but for efficiency may later be compressed together into &quot;pack files&quot;.</source>
          <target state="translated">처음 생성 할 때 개체는 개별 파일에 저장되지만 효율성을 위해 나중에 &quot;팩 파일&quot;로 압축 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ce1186a221491da0c957498f84e962314b0f4f4" translate="yes" xml:space="preserve">
          <source>When given a range of commits to display (e.g. &lt;code&gt;commit1..commit2&lt;/code&gt; or &lt;code&gt;commit2 ^commit1&lt;/code&gt;), only display commits that exist directly on the ancestry chain between the &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt;, i.e. commits that are both descendants of &lt;code&gt;commit1&lt;/code&gt;, and ancestors of &lt;code&gt;commit2&lt;/code&gt;.</source>
          <target state="translated">(예를 들어 디스플레이 커밋의 범위를 특정하면 &lt;code&gt;commit1..commit2&lt;/code&gt; 또는 &lt;code&gt;commit2 ^commit1&lt;/code&gt; )만을 사이 조상 체인에 직접 존재 커밋 표시 &lt;code&gt;commit1&lt;/code&gt; 및 &lt;code&gt;commit2&lt;/code&gt; 의 자손들 모두, 즉, 커밋 &lt;code&gt;commit1&lt;/code&gt; , 그리고 조상 &lt;code&gt;commit2&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="e006844e32fc3d063be827d3911798e9ae2b69bd" translate="yes" xml:space="preserve">
          <source>When given a range of commits to display (e.g. &lt;code&gt;commit1..commit2&lt;/code&gt; or &lt;code&gt;commit2 ^commit1&lt;/code&gt;), only display commits that exist directly on the ancestry chain between the &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt;, i.e. commits that are both descendants of &lt;code&gt;commit1&lt;/code&gt;, and ancestors of &lt;code&gt;commit2&lt;/code&gt;. (See &quot;History simplification&quot; in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for a more detailed explanation.)</source>
          <target state="translated">(예를 들어 디스플레이 커밋의 범위를 특정하면 &lt;code&gt;commit1..commit2&lt;/code&gt; 또는 &lt;code&gt;commit2 ^commit1&lt;/code&gt; )만을 사이 조상 체인에 직접 존재 커밋 표시 &lt;code&gt;commit1&lt;/code&gt; 및 &lt;code&gt;commit2&lt;/code&gt; 의 자손들 모두, 즉, 커밋 &lt;code&gt;commit1&lt;/code&gt; , 그리고 조상 &lt;code&gt;commit2&lt;/code&gt; 를 . ( 자세한 설명 은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]의&lt;/a&gt; &quot;히스토리 단순화&quot;를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="8281565ed0f01821dd04f5b4f8a282147fc8eb15" translate="yes" xml:space="preserve">
          <source>When given a two-part name section.key, the value for section.&amp;lt;url&amp;gt;.key whose &amp;lt;url&amp;gt; part matches the best to the given URL is returned (if no such key exists, the value for section.key is used as a fallback). When given just the section as name, do so for all the keys in the section and list them. Returns error code 1 if no value is found.</source>
          <target state="translated">두 부분으로 된 section.key라는 이름이 주어지면 &amp;lt;url&amp;gt; 부분이 주어진 URL과 가장 일치하는 section. &amp;lt;url&amp;gt; .key의 값이 반환됩니다 (해당 키가 없으면 section.key의 값이 사용됨). 대체로). 섹션으로 만 이름이 지정되면 섹션의 모든 키에 대해 그렇게하고 나열하십시오. 값이 없으면 오류 코드 1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f88bacf945cb9e0553c03a8ac1d906d306ca24eb" translate="yes" xml:space="preserve">
          <source>When given an SVN revision number of the form &lt;code&gt;rN&lt;/code&gt;, returns the corresponding Git commit hash (this can optionally be followed by a tree-ish to specify which branch should be searched). When given a tree-ish, returns the corresponding SVN revision number.</source>
          <target state="translated">&lt;code&gt;rN&lt;/code&gt; 형식의 SVN 개정 번호 가 제공되면 해당 Git 커밋 해시를 반환합니다 (선택적으로 검색 할 브랜치를 지정하기 위해 트리를 따를 수 있음). 트리가 주어지면 해당 SVN 개정 번호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a96423d691859ec79cd98b29f7765677feb267ba" translate="yes" xml:space="preserve">
          <source>When given, and the repository to clone from is accessed via ssh, this specifies a non-default path for the command run on the other end.</source>
          <target state="translated">지정된 경우 복제 할 저장소에 ssh를 통해 액세스하면 다른 쪽에서 실행되는 명령의 기본 경로가 아닌 경로를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d1fb59a7ba9cbb456b044d488d1684f86345d108" translate="yes" xml:space="preserve">
          <source>When given, and the repository to fetch from is handled by &lt;code&gt;git fetch-pack&lt;/code&gt;, &lt;code&gt;--exec=&amp;lt;upload-pack&amp;gt;&lt;/code&gt; is passed to the command to specify non-default path for the command run on the other end.</source>
          <target state="translated">주어진 저장소에서 가져올 저장소가 &lt;code&gt;git fetch-pack&lt;/code&gt; 에 의해 처리 되면 &lt;code&gt;--exec=&amp;lt;upload-pack&amp;gt;&lt;/code&gt; 이 명령으로 전달되어 다른 쪽에서 실행되는 명령의 기본 경로가 아닌 경로를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="347806ba4d643d64e35fb6159f6ca9df9bd36627" translate="yes" xml:space="preserve">
          <source>When giving multiple pattern expressions combined with &lt;code&gt;--or&lt;/code&gt;, this flag is specified to limit the match to files that have lines to match all of them.</source>
          <target state="translated">&lt;code&gt;--or&lt;/code&gt; 와 결합 된 여러 패턴 표현식을 제공 할 때이 플래그는 모두 일치하는 행이있는 파일로 일치를 제한하도록 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="a0b6fe15df65f2d5daa97101d52d41abe4f1ad3a" translate="yes" xml:space="preserve">
          <source>When grepping the object store (with &lt;code&gt;--cached&lt;/code&gt; or giving tree objects), running with multiple threads might perform slower than single threaded if &lt;code&gt;--textconv&lt;/code&gt; is given and there&amp;rsquo;re too many text conversions. So if you experience low performance in this case, it might be desirable to use &lt;code&gt;--threads=1&lt;/code&gt;.</source>
          <target state="translated">객체 저장소를 탐색 할 때 ( &lt;code&gt;--cached&lt;/code&gt; 또는 트리 객체 제공) &lt;code&gt;--textconv&lt;/code&gt; 가 제공되고 텍스트 변환이 너무 많으면 다중 스레드로 실행하는 것이 단일 스레드보다 느리게 수행 될 수 있습니다 . 따라서이 경우 성능이 저하되는 경우 &lt;code&gt;--threads=1&lt;/code&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4aea2178dff194f0c4c01be5fd5d2a4667a09068" translate="yes" xml:space="preserve">
          <source>When he&amp;rsquo;s ready, he tells Alice to pull changes from the repository at /home/bob/myrepo. She does this with:</source>
          <target state="translated">준비가되면 / home / bob / myrepo의 저장소에서 변경 사항을 가져 오도록 Alice에게 지시합니다. 그녀는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="66bba6f8c73ac5f72ec362ac6e58a5210f96d2e5" translate="yes" xml:space="preserve">
          <source>When importing a renamed file or directory, simply delete the old name(s) and modify the new name(s) during the corresponding commit. Git performs rename detection after-the-fact, rather than explicitly during a commit.</source>
          <target state="translated">이름이 바뀐 파일이나 디렉토리를 가져올 때는 해당 커밋 중에 이전 이름을 삭제하고 새 이름을 수정하면됩니다. Git은 커밋하는 동안 명시 적으로 수행하지 않고 이름 변경 감지를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="547b791fe6e4a112ecfb6e63c2e9ee0d26e77b05" translate="yes" xml:space="preserve">
          <source>When in cone mode, the &lt;code&gt;git sparse-checkout set&lt;/code&gt; subcommand takes a list of directories instead of a list of sparse-checkout patterns. In this mode, the command &lt;code&gt;git sparse-checkout set A/B/C&lt;/code&gt; sets the directory &lt;code&gt;A/B/C&lt;/code&gt; as a recursive pattern, the directories &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;A/B&lt;/code&gt; are added as parent patterns. The resulting sparse-checkout file is now</source>
          <target state="translated">cone 모드에서 &lt;code&gt;git sparse-checkout set&lt;/code&gt; 하위 명령은 스파 스 체크 아웃 패턴 목록 대신 디렉토리 목록을 사용합니다. 이 모드에서 &lt;code&gt;git sparse-checkout set A/B/C&lt;/code&gt; 명령 은 디렉터리 &lt;code&gt;A/B/C&lt;/code&gt; 를 재귀 패턴으로 설정하고 디렉터리 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;A/B&lt;/code&gt; 는 부모 패턴으로 추가됩니다. 결과 스파 스 체크 아웃 파일은 이제</target>
        </trans-unit>
        <trans-unit id="3cdd5299d04b153fd0e295904b9e12eec6b499c8" translate="yes" xml:space="preserve">
          <source>When in list mode, show sha1 and commit subject line for each head, along with relationship to upstream branch (if any). If given twice, print the path of the linked worktree (if any) and the name of the upstream branch, as well (see also &lt;code&gt;git remote show &amp;lt;remote&amp;gt;&lt;/code&gt;). Note that the current worktree&amp;rsquo;s HEAD will not have its path printed (it will always be your current directory).</source>
          <target state="translated">리스트 모드에있을 때, 업스트림 브랜치 (있는 경우)와의 관계와 함께 sha1을 표시하고 각 헤드의 제목 줄을 커밋하십시오. 두 번 주어진 경우, 연결된 작업 트리의 경로 (있는 경우)와 업스트림 분기의 이름도 인쇄하십시오 ( &lt;code&gt;git remote show &amp;lt;remote&amp;gt;&lt;/code&gt; 참조 ). 현재 작업 트리의 HEAD에는 경로가 인쇄되지 않습니다 (항상 현재 디렉토리 임).</target>
        </trans-unit>
        <trans-unit id="df3e42ff48559b3d46a4606cc43ea02a4d5742e5" translate="yes" xml:space="preserve">
          <source>When informative errors are turned on, git-daemon will report more verbose errors to the client, differentiating conditions like &quot;no such repository&quot; from &quot;repository not exported&quot;. This is more convenient for clients, but may leak information about the existence of unexported repositories. When informative errors are not enabled, all errors report &quot;access denied&quot; to the client. The default is --no-informative-errors.</source>
          <target state="translated">유익한 오류가 설정되면 git-daemon은 클라이언트에 더 자세한 오류를보고하여 &quot;이러한 저장소 없음&quot;과 같은 조건을 &quot;저장소가 내보내지지 않음&quot;과 구별합니다. 이는 클라이언트에게는 더 편리하지만 내 보내지 않은 리포지토리의 존재에 대한 정보가 유출 될 수 있습니다. 정보 오류가 활성화되지 않은 경우 모든 오류는 클라이언트에 &quot;액세스 거부&quot;를보고합니다. 기본값은 --no-informative-errors입니다.</target>
        </trans-unit>
        <trans-unit id="882f7c25abfabdf5a0527656f301ec49c21b72e8" translate="yes" xml:space="preserve">
          <source>When initializing submodules, a &lt;code&gt;.gitmodules&lt;/code&gt; file in the top-level directory of the containing repository is used to find the url of each submodule. This file should be formatted in the same way as &lt;code&gt;$GIT_DIR/config&lt;/code&gt;. The key to each submodule url is &quot;submodule.$name.url&quot;. See &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; for details.</source>
          <target state="translated">하위 모듈을 초기화 할 때 포함 저장소의 최상위 디렉토리에 있는 &lt;code&gt;.gitmodules&lt;/code&gt; 파일이 각 하위 모듈의 URL을 찾는 데 사용됩니다. 이 파일은 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 와 같은 방식으로 포맷되어야합니다 . 각 하위 모듈 URL의 키는 &quot;submodule. $ name.url&quot;입니다. 자세한 내용은 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="854c3f2001a62b8064a99a360e1e32072b64ad8e" translate="yes" xml:space="preserve">
          <source>When initially invoking &lt;code&gt;git am&lt;/code&gt;, you give it the names of the mailboxes to process. Upon seeing the first patch that does not apply, it aborts in the middle. You can recover from this in one of two ways:</source>
          <target state="translated">처음으로 &lt;code&gt;git am&lt;/code&gt; 을 호출 할 때 처리 할 메일 함의 이름을 지정하십시오. 적용되지 않는 첫 번째 패치를 보면 중간에 중단됩니다. 다음 두 가지 방법 중 하나로이를 복구 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae919810620b188b4a098cb2c7010981f59eb2a8" translate="yes" xml:space="preserve">
          <source>When invoking a custom merge tool, Git uses a set of temporary files to pass to the tool. If the tool returns an error and this variable is set to &lt;code&gt;true&lt;/code&gt;, then these temporary files will be preserved, otherwise they will be removed after the tool has exited. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">사용자 정의 병합 도구를 호출 할 때 Git은 임시 파일 세트를 사용하여 도구에 전달합니다. 도구가 오류를 리턴하고이 변수가 &lt;code&gt;true&lt;/code&gt; 로 설정된 경우 이러한 임시 파일은 보존되며 그렇지 않으면 도구가 종료 된 후에 제거됩니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b149cf0c1c59f45e7d020f119cab62bcf88ef5e" translate="yes" xml:space="preserve">
          <source>When it comes to editing that commit, execute &lt;code&gt;git reset HEAD^&lt;/code&gt;. The effect is that the HEAD is rewound by one, and the index follows suit. However, the working tree stays the same.</source>
          <target state="translated">커밋을 편집 할 때 &lt;code&gt;git reset HEAD^&lt;/code&gt; 실행하십시오 . 그 결과 HEAD가 1 개씩 되 감겨지고 인덱스가 적합합니다. 그러나 작업 트리는 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="54d95c16d8a8ecd15ca228486caba0d9b645aa97" translate="yes" xml:space="preserve">
          <source>When it is not obvious how to apply a change, the following happens:</source>
          <target state="translated">변경 사항을 적용하는 방법이 확실하지 않은 경우 다음이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="42b78027e34d66bfdfc08d7cf571f024832571b4" translate="yes" xml:space="preserve">
          <source>When it is not obvious how to reconcile the changes, the following happens:</source>
          <target state="translated">변경 사항을 조정하는 방법이 명확하지 않은 경우 다음이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ac3a9525cba718f2ba4c34b577914369145b2d3f" translate="yes" xml:space="preserve">
          <source>When listing references from an alternate, list only references that begin with the given prefix. Prefixes match as if they were given as arguments to &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;. To list multiple prefixes, separate them with whitespace. If &lt;code&gt;core.alternateRefsCommand&lt;/code&gt; is set, setting &lt;code&gt;core.alternateRefsPrefixes&lt;/code&gt; has no effect.</source>
          <target state="translated">대체의 참조를 나열 할 때는 주어진 접두사로 시작하는 참조 만 나열하십시오. 접두사는 마치 &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]에&lt;/a&gt; 인수로 주어진 것처럼 일치 합니다. 접두사를 여러 개 나열하려면 접두사를 공백으로 구분하십시오. 경우 &lt;code&gt;core.alternateRefsCommand&lt;/code&gt; 가 설정되어, 설정 &lt;code&gt;core.alternateRefsPrefixes&lt;/code&gt; 하는 것은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9485b24ac5fd9e24de580d1b4ae98203a381daa8" translate="yes" xml:space="preserve">
          <source>When listing, use the specified &amp;lt;format&amp;gt;, which can be one of &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt;. When omitted, the format defaults to &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">나열 할 때 지정된 &amp;lt;format&amp;gt;을 사용하십시오 . &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;medium&lt;/code&gt; 및 &lt;code&gt;long&lt;/code&gt; 중 하나 일 수 있습니다 . 생략하면 형식은 기본적으로 &lt;code&gt;short&lt;/code&gt; 로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="0de171dd2f5efd6969d6cc172c7d84e26d4bf231" translate="yes" xml:space="preserve">
          <source>When loosening unreachable objects, do not bother loosening any objects older than &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt;. This can be used to optimize out the write of any objects that would be immediately pruned by a follow-up &lt;code&gt;git prune&lt;/code&gt;.</source>
          <target state="translated">도달 할 수없는 객체를 풀 &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; 보다 오래된 객체를 풀지 마십시오 . 이것은 후속 &lt;code&gt;git prune&lt;/code&gt; 에 의해 즉시 제거 될 오브젝트의 쓰기를 최적화하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ecd3bb7ffbd4f19e0c8d754d499b7e6453c84ef" translate="yes" xml:space="preserve">
          <source>When merging an annotated (and possibly signed) tag, Git always creates a merge commit even if a fast-forward merge is possible, and the commit message template is prepared with the tag message. Additionally, if the tag is signed, the signature check is reported as a comment in the message template. See also &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;.</source>
          <target state="translated">주석이 달린 (및 서명 될 수있는) 태그를 병합 할 때 Git은 빨리 감기 병합이 가능하더라도 항상 병합 커밋을 생성하고 커밋 메시지 템플릿은 태그 메시지와 함께 준비됩니다. 또한 태그에 서명 한 경우 서명 확인이 메시지 템플릿에 주석으로보고됩니다. &lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe18117100b1e7049979d08b3604c39a0ff0f463" translate="yes" xml:space="preserve">
          <source>When merging notes, be more verbose. When pruning notes, report all object names whose notes are removed.</source>
          <target state="translated">메모를 병합 할 때 더 자세하게 설명하십시오. 노트를 제거 할 때 노트가 제거 된 모든 오브젝트 이름을보고하십시오.</target>
        </trans-unit>
        <trans-unit id="2a6ffb56c555f1836377a0b4eb9f01a6db423b92" translate="yes" xml:space="preserve">
          <source>When merging notes, operate quietly.</source>
          <target state="translated">음표를 병합 할 때는 조용히 조작하십시오.</target>
        </trans-unit>
        <trans-unit id="452e3643271eefd0a90ad1d2e336613f571129ec" translate="yes" xml:space="preserve">
          <source>When merging notes, resolve notes conflicts using the given strategy. The following strategies are recognized: &quot;manual&quot; (default), &quot;ours&quot;, &quot;theirs&quot;, &quot;union&quot; and &quot;cat_sort_uniq&quot;. This option overrides the &quot;notes.mergeStrategy&quot; configuration setting. See the &quot;NOTES MERGE STRATEGIES&quot; section below for more information on each notes merge strategy.</source>
          <target state="translated">메모를 병합 할 때 주어진 전략을 사용하여 메모 충돌을 해결하십시오. &quot;수동&quot;(기본값), &quot;우리&quot;, &quot;그들의&quot;, &quot;연합&quot;및 &quot;cat_sort_uniq&quot;전략이 인식됩니다. 이 옵션은 &quot;notes.mergeStrategy&quot;구성 설정을 대체합니다. 각 노트 병합 전략에 대한 자세한 내용은 아래의 &quot;노트 병합 전략&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a1f0170f40742ebfd5d162ab78a6fe6f60fbd4e1" translate="yes" xml:space="preserve">
          <source>When missing or is set to &lt;code&gt;default&lt;/code&gt;, many fields in the stat structure are checked to detect if a file has been modified since Git looked at it. When this configuration variable is set to &lt;code&gt;minimal&lt;/code&gt;, sub-second part of mtime and ctime, the uid and gid of the owner of the file, the inode number (and the device number, if Git was compiled to use it), are excluded from the check among these fields, leaving only the whole-second part of mtime (and ctime, if &lt;code&gt;core.trustCtime&lt;/code&gt; is set) and the filesize to be checked.</source>
          <target state="translated">누락되거나 &lt;code&gt;default&lt;/code&gt; 설정되면 Git을 검토 한 후 파일이 수정되었는지 여부를 감지하기 위해 통계 구조의 많은 필드가 검사됩니다. 이 구성 변수로 설정하면 &lt;code&gt;minimal&lt;/code&gt; 에 mtime 및 ctime을 상기 UID의 서브 번째 부분과 파일 아이 노드 번호의 소유자 gid가 (및 장치 번호 힘내 사용하도록 컴파일 된 경우)에서 제외 mtime의 전체 초 부분 ( &lt;code&gt;core.trustCtime&lt;/code&gt; 이 설정되어있는 경우 ctime) 만 남겨두고 파일 크기를 검사하도록 두 필드를 점검하십시오.</target>
        </trans-unit>
        <trans-unit id="0689b4b76e007bf9e9f69e1368a4eed9e3d9055a" translate="yes" xml:space="preserve">
          <source>When more than one pattern matches the path, a later line overrides an earlier line. This overriding is done per attribute.</source>
          <target state="translated">둘 이상의 패턴이 경로와 일치하면 나중 라인이 이전 라인보다 우선합니다. 이 재정의는 속성마다 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7de11bcf0fc6f31a9913abfce53b7b83c6075119" translate="yes" xml:space="preserve">
          <source>When moved lines are colored using e.g. the &lt;code&gt;diff.colorMoved&lt;/code&gt; setting, this option controls the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; how spaces are treated for details of valid modes see &lt;code&gt;--color-moved-ws&lt;/code&gt; in &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;.</source>
          <target state="translated">이동 된 선은 예를 들면 컬러를 사용하는 경우 &lt;code&gt;diff.colorMoved&lt;/code&gt; 의 설정이 옵션 제어 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 스페이스를 유효 모드의 세부 사항을 처리하는 방법을 알 &lt;code&gt;--color-moved-ws&lt;/code&gt; 의 &lt;a href=&quot;git-diff&quot;&gt;자식 DIFF-[1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="52b8058d0bfbbff70a9ce60ad478453479b9a747" translate="yes" xml:space="preserve">
          <source>When multiple patches are output, the subject prefix will instead be &quot;[PATCH n/m] &quot;. To force 1/1 to be added for a single patch, use &lt;code&gt;-n&lt;/code&gt;. To omit patch numbers from the subject, use &lt;code&gt;-N&lt;/code&gt;.</source>
          <target state="translated">여러 패치가 출력되면 제목 접두사가 &quot;[PATCH n / m]&quot;이됩니다. 단일 패치에 1/1을 강제로 추가하려면 &lt;code&gt;-n&lt;/code&gt; 을 사용하십시오 . 주제에서 패치 번호를 생략하려면 &lt;code&gt;-N&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1cdd3c7b73eb4476790691d3f8180aaaecc09ec" translate="yes" xml:space="preserve">
          <source>When multiple working trees are used, most of files in $GIT_DIR are per-worktree with a few known exceptions. All files under &lt;code&gt;common&lt;/code&gt; however will be shared between all working trees.</source>
          <target state="translated">여러 작업 트리가 사용되는 경우 $ GIT_DIR에있는 대부분의 파일은 몇 가지 알려진 예외를 제외하고 작업 트리 별입니다. 그러나 &lt;code&gt;common&lt;/code&gt; 모든 파일 은 모든 작업 트리간에 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="dea6d60865820d20f017799a5c24231f89c30494" translate="yes" xml:space="preserve">
          <source>When neither the command-line nor the configuration specify what to push, the default behavior is used, which corresponds to the &lt;code&gt;simple&lt;/code&gt; value for &lt;code&gt;push.default&lt;/code&gt;: the current branch is pushed to the corresponding upstream branch, but as a safety measure, the push is aborted if the upstream branch does not have the same name as the local one.</source>
          <target state="translated">명령 줄이나 구성에서 푸시 대상을 지정하지 않으면 push에 대한 &lt;code&gt;simple&lt;/code&gt; 값에 해당하는 기본 동작이 사용됩니다. &lt;code&gt;push.default&lt;/code&gt; : 현재 분기는 해당 업스트림 분기로 푸시되지만 안전 측정으로는 푸시 업스트림 분기의 이름이 로컬 분기와 같지 않으면 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="60de604c8e6be170ca14a17caf3d8c66cf8e4c1f" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; is given, &lt;code&gt;stash@{0}&lt;/code&gt; is assumed, otherwise &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; must be a reference of the form &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 가 제공 되지 않으면 &lt;code&gt;stash@{0}&lt;/code&gt; 이 가정되고, 그렇지 않으면 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 는 &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt; 형식의 참조 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="1cb728a038f1c7e17113ec68844d5bac04accdd7" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; argument is given from the command line, &lt;code&gt;git push&lt;/code&gt; behaves as if each &amp;lt;value&amp;gt; of this variable is given as &lt;code&gt;--push-option=&amp;lt;value&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">어떠한 경우 &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; 인수는 명령 라인에서 제공되지 않는, &lt;code&gt;git push&lt;/code&gt; 동작합니다이 변수들 각각 &amp;lt;값&amp;gt;로 주어진 것처럼 &lt;code&gt;--push-option=&amp;lt;value&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a166fc08fc71ee0e3d700a37b70f8845fb53d565" translate="yes" xml:space="preserve">
          <source>When no &lt;code&gt;--whitespace&lt;/code&gt; flag is given from the command line, this configuration item is used as the default.</source>
          <target state="translated">명령 행에서 &lt;code&gt;--whitespace&lt;/code&gt; 플래그가 제공 되지 않으면 이 구성 항목이 기본값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b29755631cf67968424c24b41012b3c14a5bc20f" translate="yes" xml:space="preserve">
          <source>When no refspec was given on the command line, then &lt;code&gt;git pull&lt;/code&gt; uses the refspec from the configuration or &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt;. In such cases, the following rules apply:</source>
          <target state="translated">명령 행에 refspec이 지정되지 않은 경우 &lt;code&gt;git pull&lt;/code&gt; 은 구성 또는 &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; 의 refspec을 사용합니다 . 이러한 경우 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="feee7e6efffd7b04e5558aa779c91bc6a7b795bd" translate="yes" xml:space="preserve">
          <source>When no remote is specified (via -r) the &lt;code&gt;HEAD&lt;/code&gt; branch from CVS is imported to the &lt;code&gt;origin&lt;/code&gt; branch within the Git repository, as &lt;code&gt;HEAD&lt;/code&gt; already has a special meaning for Git. When a remote is specified the &lt;code&gt;HEAD&lt;/code&gt; branch is named remotes/&amp;lt;remote&amp;gt;/master mirroring &lt;code&gt;git clone&lt;/code&gt; behaviour. Use this option if you want to import into a different branch.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 가 이미 Git에 특별한 의미를 가지고 있기 때문에 -r을 통해 원격이 지정되지 않은 경우 (-r을 통해) CVS 의 &lt;code&gt;HEAD&lt;/code&gt; 분기 가 Git 리포지토리 의 &lt;code&gt;origin&lt;/code&gt; 분기로 가져옵니다 . 리모트가 지정되면 &lt;code&gt;HEAD&lt;/code&gt; 브랜치의 이름은 remotes / &amp;lt;remote&amp;gt; / master mirroring &lt;code&gt;git clone&lt;/code&gt; behavior로 지정됩니다. 다른 지점으로 가져 오려면이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ac03f302c1aadb048fb52d65d000d2a5006af96e" translate="yes" xml:space="preserve">
          <source>When no remote is specified, by default the &lt;code&gt;origin&lt;/code&gt; remote will be used, unless there&amp;rsquo;s an upstream branch configured for the current branch.</source>
          <target state="translated">원격이 지정 되지 않은 경우 현재 분기에 대해 업스트림 분기가 구성되어 있지 않으면 기본적으로 &lt;code&gt;origin&lt;/code&gt; 원격이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d52e3dbbfef371828cf1a5d65a8a3d7860fbbc07" translate="yes" xml:space="preserve">
          <source>When on branch &amp;lt;name&amp;gt;, it overrides &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; for pushing. It also overrides &lt;code&gt;remote.pushDefault&lt;/code&gt; for pushing from branch &amp;lt;name&amp;gt;. When you pull from one place (e.g. your upstream) and push to another place (e.g. your own publishing repository), you would want to set &lt;code&gt;remote.pushDefault&lt;/code&gt; to specify the remote to push to for all branches, and use this option to override it for a specific branch.</source>
          <target state="translated">분기 &amp;lt;name&amp;gt;에 있으면 밀어 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 위해 branch. &amp;lt;name&amp;gt; .remote 를 재정의 합니다. 또한 &amp;lt;name&amp;gt; 분기에서 푸시하기 위해 &lt;code&gt;remote.pushDefault&lt;/code&gt; 를 재정의 합니다. 한 장소 (예 : 업스트림)에서 다른 장소 (예 : 자체 게시 저장소) 로 푸시 할 때 &lt;code&gt;remote.pushDefault&lt;/code&gt; 를 설정하여 모든 브랜치에 대해 푸시 할 원격을 지정하고이 옵션을 사용하여이를 재정의하려는 경우 특정 지점의 경우</target>
        </trans-unit>
        <trans-unit id="2c5d62eaf7dc4c0abb09284bfc14bacce3f382aa" translate="yes" xml:space="preserve">
          <source>When on branch &amp;lt;name&amp;gt;, it tells &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; which remote to fetch from/push to. The remote to push to may be overridden with &lt;code&gt;remote.pushDefault&lt;/code&gt; (for all branches). The remote to push to, for the current branch, may be further overridden by &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt;. If no remote is configured, or if you are not on any branch, it defaults to &lt;code&gt;origin&lt;/code&gt; for fetching and &lt;code&gt;remote.pushDefault&lt;/code&gt; for pushing. Additionally, &lt;code&gt;.&lt;/code&gt; (a period) is the current local repository (a dot-repository), see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;'s final note below.</source>
          <target state="translated">분기 &amp;lt;name&amp;gt;에있을 때 &lt;code&gt;git fetch&lt;/code&gt; 및 &lt;code&gt;git push&lt;/code&gt; 에게 어느 원격에서 가져 오거나 푸시 할지 알려줍니다 . 푸시 할 리모컨은 &lt;code&gt;remote.pushDefault&lt;/code&gt; (모든 분기에 대해) 로 재정의 될 수 있습니다 . 현재 브랜치에 대해 푸시 할 리모트는 &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; 로 추가로 대체 될 수 있습니다 . 원격이 구성되어 있지 않거나 브랜치에 있지 않은 경우 기본적으로 페치의 &lt;code&gt;origin&lt;/code&gt; 이되고 푸시의 경우 &lt;code&gt;remote.pushDefault&lt;/code&gt; 가됩니다. 또한 &lt;code&gt;.&lt;/code&gt; (마침표)는 현재 로컬 저장소 (도트 저장소)입니다. 아래의 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 의 마지막 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="99875f2b6ac5843dc20c0934eb9cdf10f7711c8e" translate="yes" xml:space="preserve">
          <source>When one of these flags is specified, the object name recorded for the paths are not updated. Instead, these options set and unset the &quot;fsmonitor valid&quot; bit for the paths. See section &quot;File System Monitor&quot; below for more information.</source>
          <target state="translated">이러한 플래그 중 하나가 지정되면 경로에 대해 기록 된 오브젝트 이름이 업데이트되지 않습니다. 대신,이 옵션은 경로에 대한 &quot;fsmonitor valid&quot;비트를 설정 및 설정 해제합니다. 자세한 내용은 아래의 &quot;파일 시스템 모니터&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="095b3a1631077463d64190b5c04e9903f37eec26" translate="yes" xml:space="preserve">
          <source>When one of these flags is specified, the object name recorded for the paths are not updated. Instead, these options set and unset the &quot;skip-worktree&quot; bit for the paths. See section &quot;Skip-worktree bit&quot; below for more information.</source>
          <target state="translated">이러한 플래그 중 하나가 지정되면 경로에 대해 기록 된 오브젝트 이름이 업데이트되지 않습니다. 대신,이 옵션은 경로에 대한 &quot;skip-worktree&quot;비트를 설정 및 설정 해제합니다. 자세한 내용은 아래의 &quot;건너 뛰기 작업 비트&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6e8f4e10b13b6ff83d83df5063d58c36d64a87b8" translate="yes" xml:space="preserve">
          <source>When one or more &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; are specified explicitly (whether on the command line or via &lt;code&gt;--stdin&lt;/code&gt;), it can be either a single pattern, or a pair of such pattern separated by a colon &quot;:&quot; (this means that a ref name cannot have a colon in it). A single pattern &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is just a shorthand for &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">하나 이상의 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 가 명시 적으로 지정되면 (명령 행 또는 &lt;code&gt;--stdin&lt;/code&gt; 을 통해 ) 콜론 &quot;:&quot;으로 구분 된 단일 패턴 또는 이러한 패턴 쌍일 수 있습니다 (이는 ref 이름은 콜론을 가질 수 없습니다). 단일 패턴 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 은 &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt; 의 약어입니다 .</target>
        </trans-unit>
        <trans-unit id="9a9b16c534806b7638cc46892a28dd173752ed8c" translate="yes" xml:space="preserve">
          <source>When packing a blob fast-import always attempts to deltify against the last blob written. Unless specifically arranged for by the frontend, this will probably not be a prior version of the same file, so the generated delta will not be the smallest possible. The resulting packfile will be compressed, but will not be optimal.</source>
          <target state="translated">Blob 빠른 가져 오기를 패킹 할 때는 항상 마지막으로 작성된 Blob에 대해 deltify를 시도합니다. 프런트 엔드에서 특별히 지정하지 않는 한이 파일은 동일한 파일의 이전 버전이 아닐 수 있으므로 생성 된 델타가 가장 작을 수는 없습니다. 결과 팩 파일은 압축되지만 최적은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="76e4bf1d99930055a44aa05818b2c065730f60bb" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--ignore-paths&lt;/code&gt;.</source>
          <target state="translated">에 전달하면 &lt;code&gt;init&lt;/code&gt; 또는 &lt;code&gt;clone&lt;/code&gt; 이 정규 표현식은 설정 키로 유지됩니다. &lt;code&gt;--ignore-paths&lt;/code&gt; 에 대한 설명은 &lt;code&gt;fetch&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6a3308486ea0114e28423fc585e726bdfefa0d3" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--ignore-refs&lt;/code&gt;.</source>
          <target state="translated">에 전달하면 &lt;code&gt;init&lt;/code&gt; 또는 &lt;code&gt;clone&lt;/code&gt; 이 정규 표현식은 설정 키로 유지됩니다. &lt;code&gt;--ignore-refs&lt;/code&gt; 에 대한 설명은 &lt;code&gt;fetch&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="247954c989ece2f916f72b869f8bb1eb7f01f09e" translate="yes" xml:space="preserve">
          <source>When passed to &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; this regular expression will be preserved as a config key. See &lt;code&gt;fetch&lt;/code&gt; for a description of &lt;code&gt;--include-paths&lt;/code&gt;.</source>
          <target state="translated">에 전달하면 &lt;code&gt;init&lt;/code&gt; 또는 &lt;code&gt;clone&lt;/code&gt; 이 정규 표현식은 설정 키로 유지됩니다. &lt;code&gt;--include-paths&lt;/code&gt; 에 대한 설명은 &lt;code&gt;fetch&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="701b3c119f368819101d8af88b842359e5cb7ac8" translate="yes" xml:space="preserve">
          <source>When paths are given, show them (note that this isn&amp;rsquo;t really raw pathnames, but rather a list of patterns to match). Otherwise implicitly uses the root level of the tree as the sole path argument.</source>
          <target state="translated">경로가 주어지면 표시하십시오 (이것은 실제로 원시 경로 이름이 아니라 일치하는 패턴 목록입니다). 그렇지 않으면 트리의 루트 레벨을 단독 경로 인수로 내재적으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a12bc3537fe67daac72917848a655d5078c91711" translate="yes" xml:space="preserve">
          <source>When pathspec is given on the command line, commit the contents of the files that match the pathspec without recording the changes already added to the index. The contents of these files are also staged for the next commit on top of what have been staged before.</source>
          <target state="translated">명령 행에 pathspec이 지정되면 색인에 이미 추가 된 변경 사항을 기록하지 않고 pathspec과 일치하는 파일의 컨텐츠를 커미트하십시오. 이 파일의 내용은 이전에 준비된 것 외에 다음 커밋을 위해 준비됩니다.</target>
        </trans-unit>
        <trans-unit id="1a6dc462ca36ebe8779cf750259e000c162a076a" translate="yes" xml:space="preserve">
          <source>When pathspec is given to &lt;code&gt;git stash push&lt;/code&gt;, the new stash entry records the modified states only for the files that match the pathspec. The index entries and working tree files are then rolled back to the state in HEAD only for these files, too, leaving files that do not match the pathspec intact.</source>
          <target state="translated">pathspec이 &lt;code&gt;git stash push&lt;/code&gt; 에 제공되면 새 숨김 항목은 pathspec과 일치하는 파일에 대해서만 수정 된 상태를 기록합니다. 그런 다음 인덱스 항목과 작업 트리 파일은 이러한 파일에 대해서만 HEAD의 상태로 롤백되므로 pathspec과 일치하지 않는 파일은 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="20284d20320c7f9cdd342728ed75cf98e12a1b6c" translate="yes" xml:space="preserve">
          <source>When possible, &lt;code&gt;pack-objects&lt;/code&gt; tries to reuse existing on-disk deltas to avoid having to search for new ones on the fly. This is an important optimization for serving fetches, because it means the server can avoid inflating most objects at all and just send the bytes directly from disk. This optimization can&amp;rsquo;t work when an object is stored as a delta against a base which the receiver does not have (and which we are not already sending). In that case the server &quot;breaks&quot; the delta and has to find a new one, which has a high CPU cost. Therefore it&amp;rsquo;s important for performance that the set of objects in on-disk delta relationships match what a client would fetch.</source>
          <target state="translated">가능하면 &lt;code&gt;pack-objects&lt;/code&gt; 는 기존 온 디스크 델타를 재사용하려고 시도하여 새로운 델타를 즉시 검색하지 않아도됩니다. 이는 서버가 대부분의 객체를 전혀 팽창시키지 않고 바이트를 디스크에서 직접 보낼 수 있기 때문에 가져 오기를 제공하는 데 중요한 최적화입니다. 이 최적화는 객체가 수신자가 가지고 있지 않은 (그리고 아직 보내지 않은)베이스에 대한 델타로 저장 될 때 작동하지 않습니다. 이 경우 서버는 델타를 &quot;중단&quot;하고 CPU 비용이 높은 새로운 델타를 찾아야합니다. 따라서 디스크상의 델타 관계에있는 오브젝트 세트가 클라이언트가 가져 오는 것과 일치하는 것이 성능에 중요합니다.</target>
        </trans-unit>
        <trans-unit id="a5d1e2c9c76493f4d0a607592b15388eabc93e4e" translate="yes" xml:space="preserve">
          <source>When present, it will also copy the value of &lt;code&gt;submodule.$name.update&lt;/code&gt;. This command does not alter existing information in .git/config. You can then customize the submodule clone URLs in .git/config for your local setup and proceed to &lt;code&gt;git submodule update&lt;/code&gt;; you can also just use &lt;code&gt;git submodule update --init&lt;/code&gt; without the explicit &lt;code&gt;init&lt;/code&gt; step if you do not intend to customize any submodule locations.</source>
          <target state="translated">존재하는 경우 &lt;code&gt;submodule.$name.update&lt;/code&gt; 의 값도 복사합니다 . 이 명령은 .git / config의 기존 정보를 변경하지 않습니다. 그런 다음 로컬 설정을 위해 .git / config에서 하위 모듈 복제 URL을 사용자 정의하고 &lt;code&gt;git submodule update&lt;/code&gt; 진행할 수 있습니다 . 하위 모듈 위치를 사용자 정의하지 않으려는 경우 명시적인 &lt;code&gt;init&lt;/code&gt; 단계 없이 &lt;code&gt;git submodule update --init&lt;/code&gt; 을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb5aacfd35a68a879acea2ba6edf150f79c935f9" translate="yes" xml:space="preserve">
          <source>When pushing to a remote that is different from the remote you normally pull from, work as &lt;code&gt;current&lt;/code&gt;. This is the safest option and is suited for beginners.</source>
          <target state="translated">일반적으로 당기는 리모컨과 다른 리모컨으로 밀 때 &lt;code&gt;current&lt;/code&gt; 작동하십시오 . 이것은 가장 안전한 옵션이며 초보자에게 적합합니다.</target>
        </trans-unit>
        <trans-unit id="f99e4f9643f5e033d51557f2aab4b69c000e9e23" translate="yes" xml:space="preserve">
          <source>When pushing, request the remote server to update refs in a single atomic transaction. If successful, all refs will be updated, or none will. If the remote side does not support this capability, the push will fail.</source>
          <target state="translated">푸시 할 때 원격 서버에 단일 원자 트랜잭션에서 참조를 업데이트하도록 요청하십시오. 성공하면 모든 심판이 업데이트되거나 아무도 없습니다. 원격 측이이 기능을 지원하지 않으면 푸시가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="24e8d08f5bcd393fd98db303b5bfff38ae149335" translate="yes" xml:space="preserve">
          <source>When reading the &lt;code&gt;core.repositoryformatversion&lt;/code&gt; variable, a git implementation which supports version 1 MUST also read any configuration keys found in the &lt;code&gt;extensions&lt;/code&gt; section of the configuration file.</source>
          <target state="translated">&lt;code&gt;core.repositoryformatversion&lt;/code&gt; 변수를 읽을 때 버전 1을 지원하는 git 구현 은 구성 파일 의 &lt;code&gt;extensions&lt;/code&gt; 섹션에있는 구성 키도 읽어야 합니다.</target>
        </trans-unit>
        <trans-unit id="d49438aa2f88cdc57a3b7001a0406b8491bbad55" translate="yes" xml:space="preserve">
          <source>When reading trailers, there can be whitespaces after the token, the separator and the value. There can also be whitespaces inside the token and the value. The value may be split over multiple lines with each subsequent line starting with whitespace, like the &quot;folding&quot; in RFC 822.</source>
          <target state="translated">트레일러를 읽을 때 토큰, 구분 기호 및 값 뒤에 공백이있을 수 있습니다. 토큰 내부에 공백과 값이있을 수도 있습니다. RFC 822의 &quot;접기&quot;와 같이 공백으로 시작하는 각 후속 줄을 사용하여 값을 여러 줄로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c808cfa1e01223bf6f90ceb1edbec20a1b9b3321" translate="yes" xml:space="preserve">
          <source>When reading, the values are read from the system, global and repository local configuration files by default, and options &lt;code&gt;--system&lt;/code&gt;, &lt;code&gt;--global&lt;/code&gt;, &lt;code&gt;--local&lt;/code&gt;, &lt;code&gt;--worktree&lt;/code&gt; and &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; can be used to tell the command to read from only that location (see &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt;).</source>
          <target state="translated">읽을 때 기본적으로 시스템, 글로벌 및 저장소 로컬 구성 파일에서 값을 읽으며 &lt;code&gt;--system&lt;/code&gt; , &lt;code&gt;--global&lt;/code&gt; , &lt;code&gt;--local&lt;/code&gt; , &lt;code&gt;--worktree&lt;/code&gt; 및 &lt;code&gt;--file &amp;lt;filename&amp;gt;&lt;/code&gt; 옵션 을 사용하여 해당 위치에서만 읽을 수있는 명령입니다 ( &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="35058e27fd0502a5cbd6b1225fdbfa49a5b7004d" translate="yes" xml:space="preserve">
          <source>When recording the commit, append a line that says &quot;(cherry picked from commit &amp;hellip;​)&quot; to the original commit message in order to indicate which commit this change was cherry-picked from. This is done only for cherry picks without conflicts. Do not use this option if you are cherry-picking from your private branch because the information is useless to the recipient. If on the other hand you are cherry-picking between two publicly visible branches (e.g. backporting a fix to a maintenance branch for an older release from a development branch), adding this information can be useful.</source>
          <target state="translated">커밋을 기록 할 때이 변경이 체리에서 선택된 커밋을 나타 내기 위해 원래 커밋 메시지에 &quot;(체리에서 커밋 &amp;hellip;&amp;hellip;)&quot;이라는 줄을 추가하십시오. 이것은 충돌없이 체리 픽에만 적용됩니다. 정보는 수신자에게 쓸모가 없으므로 개인 지점에서 체리 픽을 선택하는 경우이 옵션을 사용하지 마십시오. 반면에 공개적으로 보이는 두 가지 사이에서 체리 픽을 선택하는 경우 (예 : 개발 브랜치에서 이전 릴리스의 유지 보수 브랜치로 수정을 백 포트하는 경우)이 정보를 추가하면 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccaf8e1c6e304870dc79f0b6ba9e209459375c19" translate="yes" xml:space="preserve">
          <source>When recording your own work, the contents of modified files in your working tree are temporarily stored to a staging area called the &quot;index&quot; with &lt;code&gt;git add&lt;/code&gt;. A file can be reverted back, only in the index but not in the working tree, to that of the last commit with &lt;code&gt;git restore --staged &amp;lt;file&amp;gt;&lt;/code&gt;, which effectively reverts &lt;code&gt;git add&lt;/code&gt; and prevents the changes to this file from participating in the next commit. After building the state to be committed incrementally with these commands, &lt;code&gt;git commit&lt;/code&gt; (without any pathname parameter) is used to record what has been staged so far. This is the most basic form of the command. An example:</source>
          <target state="translated">자신의 작업을 기록 할 때 작업 트리에서 수정 된 파일의 내용은 &lt;code&gt;git add&lt;/code&gt; 를 사용하여 &quot;index&quot;라는 준비 영역에 임시 저장됩니다 . 파일은 작업 트리가 아닌 인덱스에서만 &lt;code&gt;git restore --staged &amp;lt;file&amp;gt;&lt;/code&gt; 을 사용하는 마지막 커밋의 파일 로 되돌릴 수 &lt;code&gt;git add&lt;/code&gt; . 다음 커밋. 이러한 명령으로 상태를 점진적으로 커밋하도록 빌드 한 후 &lt;code&gt;git commit&lt;/code&gt; (경로 매개 변수 없음)은 지금까지 준비된 내용을 기록하는 데 사용됩니다. 이것이 가장 기본적인 형태의 명령입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="35cd60207a202ee3a283a2d8b2047b148806b6b3" translate="yes" xml:space="preserve">
          <source>When remote and local branch are both named &quot;test&quot;:</source>
          <target state="translated">원격 및 로컬 지점의 이름이 &quot;test&quot;인 경우 :</target>
        </trans-unit>
        <trans-unit id="2eefb86cce90a60f5ab07db6487aa99da3ba4333" translate="yes" xml:space="preserve">
          <source>When rename/copy is involved, &lt;code&gt;file1&lt;/code&gt; and &lt;code&gt;file2&lt;/code&gt; show the name of the source file of the rename/copy and the name of the file that rename/copy produces, respectively.</source>
          <target state="translated">이름 바꾸기 / 복사가 관련된 경우, &lt;code&gt;file1&lt;/code&gt; 및 &lt;code&gt;file2&lt;/code&gt; 는 이름 바꾸기 / 복사의 소스 파일 이름과 이름 바꾸기 / 복사에 의해 생성 된 파일 이름을 각각 표시합니다.</target>
        </trans-unit>
        <trans-unit id="3475b12f6b8e32c3a9c4f496f5f906d95460d63d" translate="yes" xml:space="preserve">
          <source>When repacking with delta islands the delta window tends to get clogged with candidates that are forbidden by the config. Repacking with a big --window helps (and doesn&amp;rsquo;t take as long as it otherwise might because we can reject some object pairs based on islands before doing any computation on the content).</source>
          <target state="translated">델타 아일랜드로 리 패킹 할 때 델타 창은 구성에서 금지 된 후보로 막히는 경향이 있습니다. 큰 창으로 재 포장하면 도움이됩니다 (내용에 대한 계산을 수행하기 전에 섬을 기반으로 일부 객체 쌍을 거부 할 수 있기 때문에 시간이 오래 걸리지 않습니다).</target>
        </trans-unit>
        <trans-unit id="9f9b14ed67913870e54606a7e4140c245c13e689" translate="yes" xml:space="preserve">
          <source>When restoring files in the working tree from the index, use stage #2 (&lt;code&gt;ours&lt;/code&gt;) or #3 (&lt;code&gt;theirs&lt;/code&gt;) for unmerged paths.</source>
          <target state="translated">작업 트리의 파일을 인덱스에서 복원 할 때 병합되지 않은 경로에 스테이지 # 2 ( &lt;code&gt;ours&lt;/code&gt; ) 또는 # 3 ( &lt;code&gt;theirs&lt;/code&gt; )을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f350add778942f50c4b0b2f8798762ec9d6fc205" translate="yes" xml:space="preserve">
          <source>When restoring files on the working tree from the index, do not abort the operation if there are unmerged entries and neither &lt;code&gt;--ours&lt;/code&gt;, &lt;code&gt;--theirs&lt;/code&gt;, &lt;code&gt;--merge&lt;/code&gt; or &lt;code&gt;--conflict&lt;/code&gt; is specified. Unmerged paths on the working tree are left alone.</source>
          <target state="translated">인덱스에서 작업 트리에서 파일을 복원 할 때이 병합되지 않은 항목과도있는 경우 작업을 중단하지 &lt;code&gt;--ours&lt;/code&gt; , &lt;code&gt;--theirs&lt;/code&gt; , &lt;code&gt;--merge&lt;/code&gt; 또는 &lt;code&gt;--conflict&lt;/code&gt; 이 지정됩니다. 작업 트리의 병합되지 않은 경로는 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="84ac309392e16a1f3dcc1a792805de1c5dea7161" translate="yes" xml:space="preserve">
          <source>When restoring files on the working tree from the index, recreate the conflicted merge in the unmerged paths.</source>
          <target state="translated">작업 트리의 파일을 인덱스에서 복원 할 때 병합되지 않은 경로에서 충돌이 발생한 병합을 다시 만듭니다.</target>
        </trans-unit>
        <trans-unit id="273a9228c51e5936f4d142f339102a2bbdd8c3b8" translate="yes" xml:space="preserve">
          <source>When retrieving svn commits into Git (as part of &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, or &lt;code&gt;dcommit&lt;/code&gt; operations), look for the first &lt;code&gt;From:&lt;/code&gt; or &lt;code&gt;Signed-off-by:&lt;/code&gt; line in the log message and use that as the author string.</source>
          <target state="translated">svn 커밋을 Git으로 가져올 때 ( &lt;code&gt;fetch&lt;/code&gt; , &lt;code&gt;rebase&lt;/code&gt; 또는 &lt;code&gt;dcommit&lt;/code&gt; 작업의 일부로 ) 로그 메시지에서 첫 번째 &lt;code&gt;From:&lt;/code&gt; 또는 &lt;code&gt;Signed-off-by:&lt;/code&gt; 행을 찾아 저자 문자열로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="78d119701beb340fc1dce20129de3c1bebaf8055" translate="yes" xml:space="preserve">
          <source>When revision range specifiers are used to limit the annotation, lines that have not changed since the range boundary (either the commit v2.6.18 or the most recent commit that is more than 3 weeks old in the above example) are blamed for that range boundary commit.</source>
          <target state="translated">수정 범위 지정자를 사용하여 주석을 제한하는 경우, 범위 경계 이후에 변경되지 않은 행 (커밋 v2.6.18 또는 위의 예에서 3 주 이상 지난 최신 커밋)이 해당 범위 경계에 대한 책임이 있습니다. 범하다.</target>
        </trans-unit>
        <trans-unit id="802f2e7848870b44ce9f04fb441477cd05447e6c" translate="yes" xml:space="preserve">
          <source>When rewriting commits with &amp;lt;command&amp;gt; (currently &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;) and this variable is set to &lt;code&gt;true&lt;/code&gt;, Git automatically copies your notes from the original to the rewritten commit. Defaults to &lt;code&gt;true&lt;/code&gt;, but see &quot;notes.rewriteRef&quot; below.</source>
          <target state="translated">&amp;lt;command&amp;gt; (현재 &lt;code&gt;amend&lt;/code&gt; 또는 &lt;code&gt;rebase&lt;/code&gt; )로 커밋을 다시 작성 하고이 변수가 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 Git은 자동으로 노트를 원래의 커밋으로 다시 복사합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 이지만 아래의 &quot;notes.rewriteRef&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b9c5c034bfc575d885230ecf217359276486be76" translate="yes" xml:space="preserve">
          <source>When rewriting commits with &amp;lt;command&amp;gt; (currently &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;), if this variable is &lt;code&gt;false&lt;/code&gt;, git will not copy notes from the original to the rewritten commit. Defaults to &lt;code&gt;true&lt;/code&gt;. See also &quot;&lt;code&gt;notes.rewriteRef&lt;/code&gt;&quot; below.</source>
          <target state="translated">&amp;lt;command&amp;gt; (현재 &lt;code&gt;amend&lt;/code&gt; 또는 &lt;code&gt;rebase&lt;/code&gt; )로 커밋을 다시 쓸 때이 변수가 &lt;code&gt;false&lt;/code&gt; 인 경우 git은 원본에서 다시 쓴 커밋으로 노트를 복사하지 않습니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. 아래의 &quot; &lt;code&gt;notes.rewriteRef&lt;/code&gt; &quot; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0528b909a801bc351dbefd46a3e339150f63bb9d" translate="yes" xml:space="preserve">
          <source>When rewriting commits, which notes to copy from the original to the rewritten commit. Must be a colon-delimited list of refs or globs.</source>
          <target state="translated">커밋을 다시 쓸 때 원본에서 다시 쓴 커밋으로 복사 할 노트입니다. 콜론으로 구분 된 심판 또는 글로브 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="777967b1b1cbeac1b786b4e659ef472d75c08474" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a &amp;lt;path&amp;gt; as an argument.</source>
          <target state="translated">프로젝트의 서브 디렉토리에서 실행될 때 디렉토리 외부의 변경 사항을 제외하고이 옵션을 사용하여 디렉토리와 관련된 경로 이름을 표시하도록 지시 할 수 있습니다. 하위 디렉토리에 있지 않은 경우 (예 : Bare Repository) &amp;lt;path&amp;gt;를 인수로 지정하여 출력을 기준으로하는 하위 디렉토리의 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1526deda1d1c171ba9bb8aedb499ef46fa3558ac" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option. When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a &amp;lt;path&amp;gt; as an argument. &lt;code&gt;--no-relative&lt;/code&gt; can be used to countermand both &lt;code&gt;diff.relative&lt;/code&gt; config option and previous &lt;code&gt;--relative&lt;/code&gt;.</source>
          <target state="translated">프로젝트의 하위 디렉토리에서 실행할 때이 옵션을 사용하여 디렉토리 외부의 변경 사항을 제외하고 관련 경로 이름을 표시하도록 지시 할 수 있습니다. 하위 디렉토리 (예 : 베어 저장소)에 있지 않은 경우 &amp;lt;path&amp;gt;를 인수로 제공하여 출력을 상대적으로 만들 하위 디렉토리의 이름을 지정할 수 있습니다. &lt;code&gt;--no-relative&lt;/code&gt; 는 &lt;code&gt;diff.relative&lt;/code&gt; 구성 옵션과 이전 &lt;code&gt;--relative&lt;/code&gt; 를 모두 대응하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c27ca634a7183f46a280e82c3af06c829ca10b89" translate="yes" xml:space="preserve">
          <source>When run from a subdirectory, the command usually outputs paths relative to the current directory. This option forces paths to be output relative to the project top directory.</source>
          <target state="translated">하위 디렉토리에서 실행할 때 명령은 일반적으로 현재 디렉토리에 상대적인 경로를 출력합니다. 이 옵션은 프로젝트 최상위 디렉토리를 기준으로 경로를 강제로 출력합니다.</target>
        </trans-unit>
        <trans-unit id="ed0ff11c4a5dd052209fd6d888b93db83b1003f1" translate="yes" xml:space="preserve">
          <source>When run in a directory that does not have &quot;.git&quot; repository directory, Git tries to find such a directory in the parent directories to find the top of the working tree, but by default it does not cross filesystem boundaries. This environment variable can be set to true to tell Git not to stop at filesystem boundaries. Like &lt;code&gt;GIT_CEILING_DIRECTORIES&lt;/code&gt;, this will not affect an explicit repository directory set via &lt;code&gt;GIT_DIR&lt;/code&gt; or on the command line.</source>
          <target state="translated">&quot;.git&quot;저장소 디렉토리가없는 디렉토리에서 실행될 때, Git은 부모 디렉토리에서 이러한 디렉토리를 찾아 작업 트리의 최상위를 찾으려고하지만 기본적으로 파일 시스템 경계를 넘지 않습니다. 이 환경 변수는 Git에게 파일 시스템 경계에서 멈추지 말도록 true로 설정할 수 있습니다. 마찬가지로 &lt;code&gt;GIT_CEILING_DIRECTORIES&lt;/code&gt; ,이를 통해 명시 적 저장소 디렉토리 설정에 영향을주지 않습니다 &lt;code&gt;GIT_DIR&lt;/code&gt; 또는 명령 줄을.</target>
        </trans-unit>
        <trans-unit id="9ce1b9e20fc14e8e8925879039b8daf3d52acd6a" translate="yes" xml:space="preserve">
          <source>When running the command with &lt;code&gt;-u&lt;/code&gt; and &lt;code&gt;-m&lt;/code&gt; options, the merge result may need to overwrite paths that are not tracked in the current branch. The command usually refuses to proceed with the merge to avoid losing such a path. However this safety valve sometimes gets in the way. For example, it often happens that the other branch added a file that used to be a generated file in your branch, and the safety valve triggers when you try to switch to that branch after you ran &lt;code&gt;make&lt;/code&gt; but before running &lt;code&gt;make clean&lt;/code&gt; to remove the generated file. This option tells the command to read per-directory exclude file (usually &lt;code&gt;.gitignore&lt;/code&gt;) and allows such an untracked but explicitly ignored file to be overwritten.</source>
          <target state="translated">&lt;code&gt;-u&lt;/code&gt; 및 &lt;code&gt;-m&lt;/code&gt; 옵션 과 함께 명령을 실행할 때 병합 결과는 현재 분기에서 추적되지 않은 경로를 덮어 써야 할 수 있습니다. 명령은 일반적으로 이러한 경로를 잃지 않도록 병합을 진행하지 않습니다. 그러나이 안전 밸브는 때때로 방해가됩니다. 예를 들어, 종종 그 지점에 스위치하려고 할 때 실행 한 후 다른 지점이 지점에서 생성 된 파일로 사용하는 파일 및 안전 밸브 트리거를 추가 한 일이 &lt;code&gt;make&lt;/code&gt; 하지만 실행하기 전에 &lt;code&gt;make clean&lt;/code&gt; 제거하기 위해 생성 된 파일. 이 옵션은 명령이 디렉토리 별 제외 파일 (일반적으로 &lt;code&gt;.gitignore&lt;/code&gt; ) 을 읽도록 지시하고 추적되지 않지만 명시 적으로 무시 된 파일을 덮어 쓸 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="df426fd8f20937aff52c156a03a07b3202618140" translate="yes" xml:space="preserve">
          <source>When sending a patch this way, most often you are sending your own patch, so in addition to the &quot;&lt;code&gt;From $SHA1 $magic_timestamp&lt;/code&gt;&quot; marker you should omit &lt;code&gt;From:&lt;/code&gt; and &lt;code&gt;Date:&lt;/code&gt; lines from the patch file. The patch title is likely to be different from the subject of the discussion the patch is in response to, so it is likely that you would want to keep the Subject: line, like the example above.</source>
          <target state="translated">이런 방식으로 패치를 보낼 때 가장 자주 패치를 보내므로 &quot; &lt;code&gt;From $SHA1 $magic_timestamp&lt;/code&gt; &quot;마커 외에도 패치 파일에서 &lt;code&gt;From:&lt;/code&gt; 및 &lt;code&gt;Date:&lt;/code&gt; 행을 생략해야 합니다. 패치 제목은 패치에 대한 토론의 주제와 다를 수 있으므로 위의 예와 같이 Subject : 행을 유지하고 싶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85b26b0293721642a3d3ba409cae09a21a570f47" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;always&lt;/code&gt;, always highlight matches. When &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;), never. When set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, use color only when the output is written to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">&lt;code&gt;always&lt;/code&gt; 로 설정하면 항상 일치 항목을 강조 표시하십시오. &lt;code&gt;false&lt;/code&gt; 때 (또는 &lt;code&gt;never&lt;/code&gt; ) 절대로 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;auto&lt;/code&gt; 로 설정되면 출력이 터미널에 쓰여질 때만 색상을 사용하십시오. 설정하지 않으면 &lt;code&gt;color.ui&lt;/code&gt; 의 값 이 사용됩니다 ( 기본적으로 &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dfd0a45591bf4cdb6d73f4e9b16cc039b04690be" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;always&lt;/code&gt;, always use colors for interactive prompts and displays (such as those used by &quot;git-add --interactive&quot; and &quot;git-clean --interactive&quot;). When false (or &lt;code&gt;never&lt;/code&gt;), never. When set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt;, use colors only when the output is to the terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">&lt;code&gt;always&lt;/code&gt; 로 설정되면 대화 형 프롬프트 및 디스플레이에 항상 색상을 사용하십시오 (예 : &quot;git-add --interactive&quot;및 &quot;git-clean --interactive&quot;에 사용되는 색상). 거짓 일 때 (또는 &lt;code&gt;never&lt;/code&gt; ) 절대로 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;auto&lt;/code&gt; 로 설정되면 출력이 터미널에있을 때만 색상을 사용하십시오. 설정하지 않으면 &lt;code&gt;color.ui&lt;/code&gt; 의 값 이 사용됩니다 ( 기본적으로 &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9ba7d00c9f4d532d2b9486b8c87259ed84e278f3" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;change&lt;/code&gt;, tells &lt;code&gt;git apply&lt;/code&gt; to ignore changes in whitespace, in the same way as the &lt;code&gt;--ignore-space-change&lt;/code&gt; option. When set to one of: no, none, never, false tells &lt;code&gt;git apply&lt;/code&gt; to respect all whitespace differences. See &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;change&lt;/code&gt; 로 설정 하면 &lt;code&gt;--ignore-space-change&lt;/code&gt; 옵션 과 같은 방식으로 &lt;code&gt;git apply&lt;/code&gt; 가 공백 변경을 무시하도록 지시 합니다. no, none, never 중 하나로 설정되면 &lt;code&gt;git apply&lt;/code&gt; 모든 공백 차이를 존중하도록 git에 지시 합니다. &lt;a href=&quot;git-apply&quot;&gt;git-apply [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d6e4c3c7b2c6d56efae11b1e0ed0dcb5ce2357b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;merges&lt;/code&gt;, rebase using &lt;code&gt;git rebase --rebase-merges&lt;/code&gt; so that the local merge commits are included in the rebase (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">로 설정하면 &lt;code&gt;merges&lt;/code&gt; 사용 리베이스 &lt;code&gt;git rebase --rebase-merges&lt;/code&gt; 그래서 로컬 병합 커밋이 REBASE에 포함되어 있는지 (참조 &lt;a href=&quot;git-rebase&quot;&gt;자식-REBASE [1]&lt;/a&gt; 세부 사항 참조).</target>
        </trans-unit>
        <trans-unit id="3726def44fed6d7863a8f10abeef80361e6f2701" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;preserve&lt;/code&gt; (deprecated in favor of &lt;code&gt;merges&lt;/code&gt;), rebase with the &lt;code&gt;--preserve-merges&lt;/code&gt; option passed to &lt;code&gt;git rebase&lt;/code&gt; so that locally created merge commits will not be flattened.</source>
          <target state="translated">&lt;code&gt;preserve&lt;/code&gt; 하도록 설정하면 ( &lt;code&gt;merges&lt;/code&gt; 를 위해 더 이상 사용되지 않음 ) &lt;code&gt;--preserve-merges&lt;/code&gt; 옵션을 사용하여 &lt;code&gt;git rebase&lt;/code&gt; 를 git rebase로 전달하면 로컬로 생성 된 병합 커밋이 병합되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14ded32327ec4343589fd7082ddc1f7fdc8962f6" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;git reset&lt;/code&gt; will default to the &lt;code&gt;--quiet&lt;/code&gt; option.</source>
          <target state="translated">true로 설정하면 &lt;code&gt;git reset&lt;/code&gt; 은 &lt;code&gt;--quiet&lt;/code&gt; 옵션 으로 기본 설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="01f095efe30e9d32fee48e094d88f96d4eba1bad" translate="yes" xml:space="preserve">
          <source>When set to true, &lt;code&gt;git-rerere&lt;/code&gt; updates the index with the resulting contents after it cleanly resolves conflicts using previously recorded resolution. Defaults to false.</source>
          <target state="translated">true로 설정하면 &lt;code&gt;git-rerere&lt;/code&gt; 는 이전에 기록 된 해상도를 사용하여 충돌을 완전히 해결 한 후 결과 내용으로 색인을 업데이트합니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="e2cc234f1ab166d2852bd6878a576806a19d5021" translate="yes" xml:space="preserve">
          <source>When set to true, a clone of this submodule will be performed as a shallow clone (with a history depth of 1) unless the user explicitly asks for a non-shallow clone.</source>
          <target state="translated">true로 설정되면 사용자가 명시 적으로 얕은 클론을 요청하지 않는 한이 서브 모듈의 복제는 얕은 복제본 (이력 깊이가 1 인)으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6b72e60e4df8bc4b62a55c38ddf1b7b574998e6d" translate="yes" xml:space="preserve">
          <source>When set to true, automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run merge on a dirty worktree. However, use with care: the final stash application after a successful merge might result in non-trivial conflicts. This option can be overridden by the &lt;code&gt;--no-autostash&lt;/code&gt; and &lt;code&gt;--autostash&lt;/code&gt; options of &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;. Defaults to false.</source>
          <target state="translated">true로 설정하면 작업이 시작되기 전에 자동으로 임시 숨김 항목을 만들고 작업이 끝난 후에 적용합니다. 이는 더티 워크 트리에서 병합을 실행할 수 있음을 의미합니다. 그러나주의해서 사용하십시오. 성공적인 병합 후 최종 숨김 애플리케이션은 사소한 충돌을 초래할 수 있습니다. 이 옵션 은 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt; 의 &lt;code&gt;--no-autostash&lt;/code&gt; 및 &lt;code&gt;--autostash&lt;/code&gt; 옵션 으로 재정의 할 수 있습니다 . 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="c92df8026c7e3a5d595e452302b48399c0fa7807" translate="yes" xml:space="preserve">
          <source>When set to true, automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run rebase on a dirty worktree. However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts. This option can be overridden by the &lt;code&gt;--no-autostash&lt;/code&gt; and &lt;code&gt;--autostash&lt;/code&gt; options of &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;. Defaults to false.</source>
          <target state="translated">true로 설정하면 작업이 시작되기 전에 임시 숨김 항목을 자동으로 생성하고 작업이 끝난 후에 적용합니다. 이는 더티 작업 트리에서 리베이스를 실행할 수 있음을 의미합니다. 그러나주의해서 사용하십시오. 리베이스에 성공한 후 최종 숨김 응용 프로그램은 사소한 충돌을 일으킬 수 있습니다. 이 옵션 은 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; 의 &lt;code&gt;--no-autostash&lt;/code&gt; 및 &lt;code&gt;--autostash&lt;/code&gt; 옵션 으로 재정의 할 수 있습니다 . 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="454e58d95a3a4a743aeef0859eac2b9c78e6f07a" translate="yes" xml:space="preserve">
          <source>When set to true, fetching from this remote by default will also remove any local tags that no longer exist on the remote if pruning is activated in general via &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt;, &lt;code&gt;fetch.prune&lt;/code&gt; or &lt;code&gt;--prune&lt;/code&gt;. Overrides &lt;code&gt;fetch.pruneTags&lt;/code&gt; settings, if any.</source>
          <target state="translated">true로 설정하면 기본적으로이 원격에서 가져 오면 정리가 일반적으로 &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; , &lt;code&gt;fetch.prune&lt;/code&gt; 또는 &lt;code&gt;--prune&lt;/code&gt; 을 통해 활성화되면 원격에 더 이상 존재하지 않는 로컬 태그도 제거됩니다 . &lt;code&gt;fetch.pruneTags&lt;/code&gt; 설정을 재정의 합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="2f08cdfbf2bbbb5ba49961d7515ae4f7f92a166e" translate="yes" xml:space="preserve">
          <source>When set to true, fetching from this remote by default will also remove any remote-tracking references that no longer exist on the remote (as if the &lt;code&gt;--prune&lt;/code&gt; option was given on the command line). Overrides &lt;code&gt;fetch.prune&lt;/code&gt; settings, if any.</source>
          <target state="translated">true로 설정하면 기본적으로이 원격 장치에서 가져 오면 원격에 더 이상 존재하지 않는 원격 추적 참조도 제거됩니다 ( &lt;code&gt;--prune&lt;/code&gt; 옵션이 명령 줄에 지정된 것처럼 ). &lt;code&gt;fetch.prune&lt;/code&gt; 설정을 재정의 합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="5739477a3b9489a88899be9378f898520709209f" translate="yes" xml:space="preserve">
          <source>When set to true, git-receive-pack will advertise the push options capability to its clients. False by default.</source>
          <target state="translated">true로 설정하면 git-receive-pack은 푸시 옵션 기능을 클라이언트에게 알립니다. 기본적으로 False입니다.</target>
        </trans-unit>
        <trans-unit id="af12eb66ec26d00e256f0fbfcc7125aeb108aa2e" translate="yes" xml:space="preserve">
          <source>When set to true, this remote will be used to fetch promisor objects.</source>
          <target state="translated">true로 설정하면이 리모콘을 사용하여 약속 개체를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="384788e82f8977bea09d8463e5bbfca26ec8a699" translate="yes" xml:space="preserve">
          <source>When set, the fetch or receive will abort in the case of a malformed object or a link to a nonexistent object. In addition, various other issues are checked for, including legacy issues (see &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt;), and potential security issues like the existence of a &lt;code&gt;.GIT&lt;/code&gt; directory or a malicious &lt;code&gt;.gitmodules&lt;/code&gt; file (see the release notes for v2.2.1 and v2.17.1 for details). Other sanity and security checks may be added in future releases.</source>
          <target state="translated">설정하면 잘못된 오브젝트 또는 존재하지 않는 오브젝트에 대한 링크의 경우 페치 또는 수신이 중단됩니다. 또한, 다양한 다른 문제는 기존의 문제 (참조를 포함하여 검사하는 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; ), 그리고의 존재와 같은 잠재적 인 보안 문제 &lt;code&gt;.GIT&lt;/code&gt; 의 디렉토리 또는 악의적 인 &lt;code&gt;.gitmodules&lt;/code&gt; 의 파일 (v2의 릴리스 노트를 참조하십시오. 자세한 내용은 2.1 및 v2.17.1을 참조하십시오. 다음 릴리스에서는 다른 무결성 및 보안 검사가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51a9809b150b3fa600feb6c1ea57e78e8de9e787" translate="yes" xml:space="preserve">
          <source>When showing &lt;code&gt;short&lt;/code&gt; or &lt;code&gt;porcelain&lt;/code&gt; status output, print the filename verbatim and terminate the entries with NUL, instead of LF. If no format is given, implies the &lt;code&gt;--porcelain&lt;/code&gt; output format. Without the &lt;code&gt;-z&lt;/code&gt; option, filenames with &quot;unusual&quot; characters are quoted as explained for the configuration variable &lt;code&gt;core.quotePath&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">도시 때 &lt;code&gt;short&lt;/code&gt; 이나 &lt;code&gt;porcelain&lt;/code&gt; 상태 출력을, LF 대신에, 축어 파일명 인쇄 NUL과 같이 종료. 형식이 지정되지 않으면 &lt;code&gt;--porcelain&lt;/code&gt; 출력 형식을 나타냅니다. &lt;code&gt;-z&lt;/code&gt; 옵션이 없으면 구성 변수 &lt;code&gt;core.quotePath&lt;/code&gt; 에 설명 된대로 &quot;특이하지 않은&quot;문자가 포함 된 파일 이름이 인용됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="43f2e6f1690661b84f31283fe1b400a9df885029" translate="yes" xml:space="preserve">
          <source>When showing a change that involves a rename or a copy, &lt;code&gt;--stat&lt;/code&gt; output formats the pathnames compactly by combining common prefix and suffix of the pathnames. For example, a change that moves &lt;code&gt;arch/i386/Makefile&lt;/code&gt; to &lt;code&gt;arch/x86/Makefile&lt;/code&gt; while modifying 4 lines will be shown like this:</source>
          <target state="translated">이름 바꾸기 또는 사본과 관련된 변경 사항을 표시 할 때 &lt;code&gt;--stat&lt;/code&gt; 출력은 경로 이름의 공통 접두사와 접미사를 결합하여 경로 이름을 압축합니다. 예를 들어, 4 줄을 수정하는 동안 &lt;code&gt;arch/i386/Makefile&lt;/code&gt; 을 &lt;code&gt;arch/x86/Makefile&lt;/code&gt; 로 이동하는 변경 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5d4332d6cfe825bd00a3bfef76e9ffde728a5dde" translate="yes" xml:space="preserve">
          <source>When showing commit messages, also show notes which are stored in the given ref. The ref must be fully qualified. If the given ref does not exist, it is not an error but means that no notes should be printed.</source>
          <target state="translated">커밋 메시지를 표시 할 때 주어진 참조에 저장된 메모도 표시하십시오. 심판은 정규화되어야합니다. 주어진 심판이 존재하지 않는다면, 그것은 오류가 아니지만 노트가 인쇄되지 않아야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="43020b05da28d5245a5572e708a459c7bb4d40bf" translate="yes" xml:space="preserve">
          <source>When showing object names, prefix them with &lt;code&gt;^&lt;/code&gt; and strip &lt;code&gt;^&lt;/code&gt; prefix from the object names that already have one.</source>
          <target state="translated">개체 이름을 표시 할 때, 그들을 앞에 &lt;code&gt;^&lt;/code&gt; 스트립 &lt;code&gt;^&lt;/code&gt; 개체 이름에서 접두어 이미 하나를 가지고 그.</target>
        </trans-unit>
        <trans-unit id="bf158ec030a04af48fd84ff99f4cdef61dbc802c" translate="yes" xml:space="preserve">
          <source>When showing the value of &amp;lt;name&amp;gt; as a symbolic ref, try to shorten the value, e.g. from &lt;code&gt;refs/heads/master&lt;/code&gt; to &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">&amp;lt;name&amp;gt;의 값을 기호 참조로 표시 할 때 값을 줄이십시오 (예 : &lt;code&gt;refs/heads/master&lt;/code&gt; 에서 &lt;code&gt;master&lt;/code&gt; 로) .</target>
        </trans-unit>
        <trans-unit id="d07871fea9de7a0886062f3dfa8bbc506d97b667" translate="yes" xml:space="preserve">
          <source>When shown by &lt;code&gt;git diff-tree -c&lt;/code&gt;, it compares the parents of a merge commit with the merge result (i.e. file1..fileN are the parents). When shown by &lt;code&gt;git diff-files -c&lt;/code&gt;, it compares the two unresolved merge parents with the working tree file (i.e. file1 is stage 2 aka &quot;our version&quot;, file2 is stage 3 aka &quot;their version&quot;).</source>
          <target state="translated">&lt;code&gt;git diff-tree -c&lt;/code&gt; 로 표시되면 병합 커밋의 부모를 병합 결과와 비교합니다 (즉, file1..fileN은 부모입니다). &lt;code&gt;git diff-files -c&lt;/code&gt; 로 표시되면 해결되지 않은 두 병합 부모를 작업 트리 파일과 비교합니다 (즉, file1은 &quot;우리 버전&quot;이라는 2 단계, file2는 &quot;그들의 버전&quot;이라고합니다).</target>
        </trans-unit>
        <trans-unit id="aea42e2933202e5e3d5f69076d6bebeb378dfcd9" translate="yes" xml:space="preserve">
          <source>When some commits have been skipped (using &quot;git bisect skip&quot;), then the bisection algorithm is the same for step 1) to 3). But then we use roughly the following steps:</source>
          <target state="translated">일부 커밋을 건너 뛴 경우 ( &quot;git bisect skip&quot;사용) 이분법 알고리즘은 1 단계에서 동일 함) ~ 3). 그러나 우리는 대략 다음 단계를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4192528671a22eca45fcad6bb5614a7ec165a5d4" translate="yes" xml:space="preserve">
          <source>When specified one or more times, &lt;code&gt;-L&lt;/code&gt; restricts annotation to the requested lines.</source>
          <target state="translated">한 번 이상 지정된 경우 &lt;code&gt;-L&lt;/code&gt; 은 주석을 요청 된 행으로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="75acd7ee44b0e77c6b233d3615dca447d4cfdc8c" translate="yes" xml:space="preserve">
          <source>When specifying the -v option the format used is:</source>
          <target state="translated">-v 옵션을 지정할 때 사용되는 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0550af8039db48de114d18431bb7375cee83b91b" translate="yes" xml:space="preserve">
          <source>When switching branches with &lt;code&gt;--merge&lt;/code&gt;, staged changes may be lost.</source>
          <target state="translated">&lt;code&gt;--merge&lt;/code&gt; 로 분기를 전환하면 단계적 변경 사항이 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f4fa4b7e00510c39cb24519dad3b49f07cff89d" translate="yes" xml:space="preserve">
          <source>When switching branches, if you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch.</source>
          <target state="translated">분기를 전환 할 때 현재 분기와 전환중인 분기간에 다른 하나 이상의 파일을 로컬로 수정 한 경우 명령은 컨텍스트에서 수정 사항을 보존하기 위해 분기 전환을 거부합니다. 그러나이 옵션을 사용하면 현재 분기, 작업 트리 내용 및 새 분기간에 3 방향 병합이 수행되고 새 분기에있게됩니다.</target>
        </trans-unit>
        <trans-unit id="7b0d58bb9103d272bfd260e85d337e6780ed225d" translate="yes" xml:space="preserve">
          <source>When switching branches, proceed even if the index or the working tree differs from &lt;code&gt;HEAD&lt;/code&gt;. This is used to throw away local changes.</source>
          <target state="translated">분기를 전환 할 때 색인 또는 작업 트리가 &lt;code&gt;HEAD&lt;/code&gt; 와 다른 경우에도 진행하십시오 . 로컬 변경 사항을 버리는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c0e1144ec53aca779c8724f81a0ba0a804f51a81" translate="yes" xml:space="preserve">
          <source>When the &quot;-C&quot; option is used, the original contents of modified files, and deleted files (and also unmodified files, if the &quot;--find-copies-harder&quot; option is used) are considered as candidates of the source files in rename/copy operation. If the input were like these filepairs, that talk about a modified file fileY and a newly created file file0:</source>
          <target state="translated">&quot;-C&quot;옵션을 사용하면 수정 된 파일의 원래 내용과 삭제 된 파일 (및 &quot;--find-copies-harder&quot;옵션을 사용하는 경우 수정되지 않은 파일)도 소스 파일의 후보로 간주됩니다. 이름 바꾸기 / 복사 작업. 입력이 이러한 파일 쌍과 같으면 수정 된 파일 fileY와 새로 작성된 파일 file0에 대해 이야기합니다.</target>
        </trans-unit>
        <trans-unit id="f6565c60ff0e235a6b049473d40ff8e72074a702" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; argument is a branch name, the &lt;code&gt;--detach&lt;/code&gt; option can be used to detach &lt;code&gt;HEAD&lt;/code&gt; at the tip of the branch (&lt;code&gt;git checkout
&amp;lt;branch&amp;gt;&lt;/code&gt; would check out that branch without detaching &lt;code&gt;HEAD&lt;/code&gt;).</source>
          <target state="translated">때 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 인수가 지점 이름의 &lt;code&gt;--detach&lt;/code&gt; 옵션을 분리하는 데 사용할 수 있습니다 &lt;code&gt;HEAD&lt;/code&gt; 분기의 끝에서 ( &lt;code&gt;git checkout &amp;lt;branch&amp;gt;&lt;/code&gt; 분리하지 않고 해당 분기 체크 아웃 할 &lt;code&gt;HEAD&lt;/code&gt; 를 ).</target>
        </trans-unit>
        <trans-unit id="588cf4af82a088b4d8241fca9de08188511b35c3" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--aggressive&lt;/code&gt; option is supplied, &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt; will be invoked with the &lt;code&gt;-f&lt;/code&gt; flag, which in turn will pass &lt;code&gt;--no-reuse-delta&lt;/code&gt; to &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;. This will throw away any existing deltas and re-compute them, at the expense of spending much more time on the repacking.</source>
          <target state="translated">때 &lt;code&gt;--aggressive&lt;/code&gt; 옵션이 제공되며, &lt;a href=&quot;git-repack&quot;&gt;자식 - 재 포장 [1]&lt;/a&gt; 호출한다 &lt;code&gt;-f&lt;/code&gt; 차례로 통과 할 플래그 &lt;code&gt;--no-reuse-delta&lt;/code&gt; 로 &lt;a href=&quot;git-pack-objects&quot;&gt;자식 팩 - 오브젝트 [1]&lt;/a&gt; . 이렇게하면 기존 델타를 버리고 재 포장에 훨씬 더 많은 시간을 소비하면서 재 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36c732582138b85601314513444f94ba223454f7" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--auto-merge&lt;/code&gt; is given, meld will merge all non-conflicting parts automatically, highlight the conflicting parts and wait for user decision. Setting &lt;code&gt;mergetool.meld.useAutoMerge&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; tells Git to unconditionally use the &lt;code&gt;--auto-merge&lt;/code&gt; option with &lt;code&gt;meld&lt;/code&gt;. Setting this value to &lt;code&gt;auto&lt;/code&gt; makes git detect whether &lt;code&gt;--auto-merge&lt;/code&gt; is supported and will only use &lt;code&gt;--auto-merge&lt;/code&gt; when available. A value of &lt;code&gt;false&lt;/code&gt; avoids using &lt;code&gt;--auto-merge&lt;/code&gt; altogether, and is the default value.</source>
          <target state="translated">때 &lt;code&gt;--auto-merge&lt;/code&gt; 주어, MELD는 자동으로 모든 충돌하지 않는 부분을 병합 충돌하는 부분을 강조 표시하고 사용자의 결정을 기다립니다. &lt;code&gt;mergetool.meld.useAutoMerge&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하면 Git 이 &lt;code&gt;meld&lt;/code&gt; 와 함께 &lt;code&gt;--auto-merge&lt;/code&gt; 옵션 을 무조건 사용하도록 지시 합니다. 이 값을 &lt;code&gt;auto&lt;/code&gt; 로 설정 하면 git이 &lt;code&gt;--auto-merge&lt;/code&gt; 가 지원 되는지 여부를 감지 하고 사용 가능한 경우 &lt;code&gt;--auto-merge&lt;/code&gt; 만 사용 합니다. &lt;code&gt;false&lt;/code&gt; 값은 &lt;code&gt;--auto-merge&lt;/code&gt; 를 함께 사용하지 않도록 하며 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="82879b1b4c41ea78abef977470f6f223214f239a" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--stdin&lt;/code&gt; option is provided, the patterns are read from standard in as a newline-delimited list instead of from the arguments.</source>
          <target state="translated">때 &lt;code&gt;--stdin&lt;/code&gt; 옵션 옵션이 제공되면, 패턴의 개행 문자로 분리 된 목록으로 대신 인수에서 표준에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="0e72b560677fc7dbf879d4b64bab949efbe4ffc6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;-l&lt;/code&gt; option is used, format changes to</source>
          <target state="translated">때 &lt;code&gt;-l&lt;/code&gt; 옵션을 사용, 형식으로 변경</target>
        </trans-unit>
        <trans-unit id="2d7535050bbd171bed81a20302444843893d883d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;-z&lt;/code&gt; option is given, pathnames are printed as is and without any quoting and lines are terminated with a NUL (ASCII 0x00) byte.</source>
          <target state="translated">때 &lt;code&gt;-z&lt;/code&gt; 옵션이 주어, 경로 이름은 그대로 인쇄하고 인용하고 라인이 NUL 종료된다 (ASCII &amp;times; 00) 바이트 않고있다.</target>
        </trans-unit>
        <trans-unit id="e231e06fa3f3b3606e814466b6e12bf27e65315d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;.gitattributes&lt;/code&gt; file is missing from the work tree, the path in the index is used as a fall-back. During checkout process, &lt;code&gt;.gitattributes&lt;/code&gt; in the index is used and then the file in the working tree is used as a fall-back.</source>
          <target state="translated">때 &lt;code&gt;.gitattributes&lt;/code&gt; 의 파일이 작업 트리에서 누락 된 인덱스의 경로는 가을 백으로 사용됩니다. 체크 아웃 프로세스 중에 인덱스의 &lt;code&gt;.gitattributes&lt;/code&gt; 가 사용되고 작업 트리의 파일이 폴백으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ca6fe469ff13b0a4412dea9bd34db705e00a71db" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;LESS&lt;/code&gt; environment variable is unset, Git sets it to &lt;code&gt;FRX&lt;/code&gt; (if &lt;code&gt;LESS&lt;/code&gt; environment variable is set, Git does not change it at all). If you want to selectively override Git&amp;rsquo;s default setting for &lt;code&gt;LESS&lt;/code&gt;, you can set &lt;code&gt;core.pager&lt;/code&gt; to e.g. &lt;code&gt;less -S&lt;/code&gt;. This will be passed to the shell by Git, which will translate the final command to &lt;code&gt;LESS=FRX less -S&lt;/code&gt;. The environment does not set the &lt;code&gt;S&lt;/code&gt; option but the command line does, instructing less to truncate long lines. Similarly, setting &lt;code&gt;core.pager&lt;/code&gt; to &lt;code&gt;less -+F&lt;/code&gt; will deactivate the &lt;code&gt;F&lt;/code&gt; option specified by the environment from the command-line, deactivating the &quot;quit if one screen&quot; behavior of &lt;code&gt;less&lt;/code&gt;. One can specifically activate some flags for particular commands: for example, setting &lt;code&gt;pager.blame&lt;/code&gt; to &lt;code&gt;less -S&lt;/code&gt; enables line truncation only for &lt;code&gt;git blame&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;LESS&lt;/code&gt; 환경 변수를 설정하고, 힘내로 설정 &lt;code&gt;FRX&lt;/code&gt; (경우 &lt;code&gt;LESS&lt;/code&gt; 의 환경 변수 설정, 힘내 전혀 변경하지 않음). &lt;code&gt;LESS&lt;/code&gt; 에 대한 Git의 기본 설정을 선택적으로 무시 하려면 &lt;code&gt;core.pager&lt;/code&gt; 를 예를 들어 &lt;code&gt;less -S&lt;/code&gt; 로 설정할 수 있습니다 . 이것은 Git에 의해 쉘로 전달되며 최종 명령은 &lt;code&gt;LESS=FRX less -S&lt;/code&gt; 로 변환 됩니다. 환경은 &lt;code&gt;S&lt;/code&gt; 옵션을 설정하지 않지만 명령 행은 긴 행을 자르도록 지시합니다. 마찬가지로, 설정 &lt;code&gt;core.pager&lt;/code&gt; 을 에 &lt;code&gt;less -+F&lt;/code&gt; 비활성화됩니다 &lt;code&gt;F&lt;/code&gt; 를명령 줄에서 환경에 의해 지정된 옵션을 사용하여 &lt;code&gt;less&lt;/code&gt; 의 &quot;quit if one screen&quot;동작을 비활성화합니다 . 특정 명령에 대해 일부 플래그를 구체적으로 활성화 할 수 있습니다. 예를 들어 &lt;code&gt;pager.blame&lt;/code&gt; 을 &lt;code&gt;less -S&lt;/code&gt; 로 설정 하면 &lt;code&gt;git blame&lt;/code&gt; 에 대해서만 줄 잘림이 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="74ad9f83ee4c2323b6a50919a4a444bb844e349c" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;core.fsmonitor&lt;/code&gt; configuration variable is changed, the file system monitor is added to or removed from the index the next time a command reads the index. When &lt;code&gt;--[no-]fsmonitor&lt;/code&gt; are used, the file system monitor is immediately added to or removed from the index.</source>
          <target state="translated">때 &lt;code&gt;core.fsmonitor&lt;/code&gt; 의 구성 변수 변경, 파일 시스템 모니터는 인덱스에서 명령 인덱스를 판독 다음번에 추가되거나 제거된다. 시 &lt;code&gt;--[no-]fsmonitor&lt;/code&gt; 사용되고, 파일 시스템 모니터 즉시 추가 또는 인덱스로부터 제거된다.</target>
        </trans-unit>
        <trans-unit id="a4c9cc7c80e5659747cb4b3bf0914ba1addde698" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable is changed, the untracked cache is added to or removed from the index the next time a command reads the index; while when &lt;code&gt;--[no-|force-]untracked-cache&lt;/code&gt; are used, the untracked cache is immediately added to or removed from the index.</source>
          <target state="translated">때 &lt;code&gt;core.untrackedCache&lt;/code&gt; 의 구성 변수 변경의 추적 된 캐시 인덱스의 명령은 인덱스를 읽어 다음 번에 첨가되거나 제거; 반면 때 &lt;code&gt;--[no-|force-]untracked-cache&lt;/code&gt; 사용하는 상기 추적 된 캐시에 즉시 첨가 또는 인덱스로부터 제거.</target>
        </trans-unit>
        <trans-unit id="a212ca612f0b7b9b082dffe71078dd396d414402" translate="yes" xml:space="preserve">
          <source>When the attribute &lt;code&gt;ident&lt;/code&gt; is set for a path, Git replaces &lt;code&gt;$Id$&lt;/code&gt; in the blob object with &lt;code&gt;$Id:&lt;/code&gt;, followed by the 40-character hexadecimal blob object name, followed by a dollar sign &lt;code&gt;$&lt;/code&gt; upon checkout. Any byte sequence that begins with &lt;code&gt;$Id:&lt;/code&gt; and ends with &lt;code&gt;$&lt;/code&gt; in the worktree file is replaced with &lt;code&gt;$Id$&lt;/code&gt; upon check-in.</source>
          <target state="translated">속성 &lt;code&gt;ident&lt;/code&gt; 가 경로에 대해 설정되면 Git은 blob 객체의 &lt;code&gt;$Id$&lt;/code&gt; 를 &lt;code&gt;$Id:&lt;/code&gt; 바꾸고 , 그 뒤에 40 자 16 진 blob 객체 이름, 체크 아웃시 달러 기호 &lt;code&gt;$&lt;/code&gt; 를 차례로 바꿉니다 . 모든 바이트로 시작 순서 &lt;code&gt;$Id:&lt;/code&gt; 와 끝 &lt;code&gt;$&lt;/code&gt; worktree 파일로 대체됩니다 &lt;code&gt;$Id$&lt;/code&gt; 체크인시.</target>
        </trans-unit>
        <trans-unit id="fa514f01de77ed627378917f2aa0b40cefa8c9a0" translate="yes" xml:space="preserve">
          <source>When the command enters the interactive mode, it shows the files and directories to be cleaned, and goes into its interactive command loop.</source>
          <target state="translated">명령이 대화식 모드로 들어가면 정리할 파일 및 디렉토리가 표시되고 대화식 명령 루프로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="8e767c7023b00ca52d4fb770ab49ce4dc284f987" translate="yes" xml:space="preserve">
          <source>When the command enters the interactive mode, it shows the output of the &lt;code&gt;status&lt;/code&gt; subcommand, and then goes into its interactive command loop.</source>
          <target state="translated">명령이 대화식 모드로 들어가면 &lt;code&gt;status&lt;/code&gt; 부속 명령 의 출력 이 표시되고 대화식 명령 루프로 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="e95952399796aad65deb415e39c303153d01cdf9" translate="yes" xml:space="preserve">
          <source>When the command is invoked from a subdirectory, show the path of the current directory relative to the top-level directory.</source>
          <target state="translated">하위 디렉토리에서 명령을 호출하면 최상위 디렉토리를 기준으로 현재 디렉토리의 경로를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="45506eccf72696bf6e0287a6eeda327142bb0f41" translate="yes" xml:space="preserve">
          <source>When the command is invoked from a subdirectory, show the path of the top-level directory relative to the current directory (typically a sequence of &quot;../&quot;, or an empty string).</source>
          <target state="translated">하위 디렉토리에서 명령을 호출 할 때 현재 디렉토리 (일반적으로 &quot;../&quot;시퀀스 또는 빈 문자열)를 기준으로 최상위 디렉토리의 경로를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="609d76b7287e730d5e5fcae1b57a1cde4d02d1ae" translate="yes" xml:space="preserve">
          <source>When the command is run without pathspec, it errors out, instead of deinit-ing everything, to prevent mistakes.</source>
          <target state="translated">pathspec없이 명령을 실행하면 실수를 방지하기 위해 모든 것을 초기화하지 않고 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2ebded60d45ed8776b0324d8d2138df90f552a15" translate="yes" xml:space="preserve">
          <source>When the command line does not specify what to push with &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; arguments or &lt;code&gt;--all&lt;/code&gt;, &lt;code&gt;--mirror&lt;/code&gt;, &lt;code&gt;--tags&lt;/code&gt; options, the command finds the default &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; by consulting &lt;code&gt;remote.*.push&lt;/code&gt; configuration, and if it is not found, honors &lt;code&gt;push.default&lt;/code&gt; configuration to decide what to push (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for the meaning of &lt;code&gt;push.default&lt;/code&gt;).</source>
          <target state="translated">명령 행에서 &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; 인수 또는 &lt;code&gt;--all&lt;/code&gt; , &lt;code&gt;--mirror&lt;/code&gt; , &lt;code&gt;--tags&lt;/code&gt; 옵션 으로 푸시 할 항목을 지정하지 않으면 명령은 &lt;code&gt;remote.*.push&lt;/code&gt; 구성 을 참조 하여 기본 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 을 찾습니다 . 찾을 수없는 경우 &lt;code&gt;push.default&lt;/code&gt; 구성을 준수 하여 푸시 대상을 결정합니다 ( &lt;code&gt;push.default&lt;/code&gt; 의 의미는 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4f61ade639e58b8586884fe92cb9eea816606ac2" translate="yes" xml:space="preserve">
          <source>When the command line does not specify where to push with the &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; argument, &lt;code&gt;branch.*.remote&lt;/code&gt; configuration for the current branch is consulted to determine where to push. If the configuration is missing, it defaults to &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">명령 행에서 &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; 인수 로 푸시 할 위치를 지정하지 않으면 푸시 할 위치를 결정하기 위해 현재 분기에 대한 &lt;code&gt;branch.*.remote&lt;/code&gt; 구성을 참조합니다. 구성이 누락되면 기본값은 &lt;code&gt;origin&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4dd963bd8e58b7ff2b11f8f622df35ecbcf28d58" translate="yes" xml:space="preserve">
          <source>When the commit diffs differ, &lt;code&gt;git range-diff&lt;/code&gt; recreates the original diffs' coloring, and adds outer -/+ diff markers with the &lt;strong&gt;background&lt;/strong&gt; being red/green to make it easier to see e.g. when there was a change in what exact lines were added.</source>
          <target state="translated">커밋 차이가 다르면 &lt;code&gt;git range-diff&lt;/code&gt; 는 원래 diff의 채색을 재현하고 &lt;strong&gt;배경&lt;/strong&gt; 이 빨간색 / 녹색 인 외부-/ + diff 마커를 추가하여 예를 들어 정확한 라인이 추가 된 변경 사항이있을 때 더 쉽게 볼 수 있도록합니다. .</target>
        </trans-unit>
        <trans-unit id="3625aba84b870871330cdfd48d8779c4e4badb58" translate="yes" xml:space="preserve">
          <source>When the commit log message begins with &quot;squash! &amp;hellip;​&quot; (or &quot;fixup! &amp;hellip;​&quot;), and there is already a commit in the todo list that matches the same &lt;code&gt;...&lt;/code&gt;, automatically modify the todo list of rebase -i so that the commit marked for squashing comes right after the commit to be modified, and change the action of the moved commit from &lt;code&gt;pick&lt;/code&gt; to &lt;code&gt;squash&lt;/code&gt; (or &lt;code&gt;fixup&lt;/code&gt;). A commit matches the &lt;code&gt;...&lt;/code&gt; if the commit subject matches, or if the &lt;code&gt;...&lt;/code&gt; refers to the commit&amp;rsquo;s hash. As a fall-back, partial matches of the commit subject work, too. The recommended way to create fixup/squash commits is by using the &lt;code&gt;--fixup&lt;/code&gt;/&lt;code&gt;--squash&lt;/code&gt; options of &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;.</source>
          <target state="translated">커밋 로그 메시지가 &quot;squash!&amp;hellip;&quot;(또는 &quot;fixup!&amp;hellip;&quot;)로 시작하고 동일한 todo 목록에 이미 &lt;code&gt;...&lt;/code&gt; 같은 커밋이있는 경우 rebase -i의 할 일 목록을 자동으로 수정하십시오. 스쿼시로 표시된 커밋이 수정 된 커밋 직후에 발생하고 이동 된 커밋의 동작을 &lt;code&gt;pick&lt;/code&gt; 에서 &lt;code&gt;squash&lt;/code&gt; (또는 &lt;code&gt;fixup&lt;/code&gt; )로 변경하십시오. 커밋 주제가 일치하거나 &lt;code&gt;...&lt;/code&gt; 가 커밋의 해시를 나타내는 경우 커밋 은 &lt;code&gt;...&lt;/code&gt; 과 일치합니다 . 대체로 커밋 주제의 부분 일치도 작동합니다. 수정 / 스쿼시 커밋을 만드는 권장 방법 은 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 의 &lt;code&gt;--fixup&lt;/code&gt; / &lt;code&gt;--squash&lt;/code&gt; 옵션을 사용하는 것입니다 ..</target>
        </trans-unit>
        <trans-unit id="777196d17b1a10c66d0cd105e5fb66da2363f7b1" translate="yes" xml:space="preserve">
          <source>When the config key &lt;code&gt;extensions.partialclone&lt;/code&gt; is set, it indicates that the repo was created with a partial clone (or later performed a partial fetch) and that the remote may have omitted sending certain unwanted objects. Such a remote is called a &quot;promisor remote&quot; and it promises that all such omitted objects can be fetched from it in the future.</source>
          <target state="translated">config key &lt;code&gt;extensions.partialclone&lt;/code&gt; 을 설정하면 리포지토리가 부분 복제본으로 생성되었거나 나중에 부분 페치를 수행하여 원격이 특정 원하지 않는 개체를 보내는 것을 생략했을 수 있습니다. 이러한 리모컨을 &quot;프로 미저 리모컨&quot;이라고하며, 생략 된 모든 객체를 앞으로 가져올 수 있다고 약속합니다.</target>
        </trans-unit>
        <trans-unit id="ef73607bec133cc1d32aaf64deafc8c72104731d" translate="yes" xml:space="preserve">
          <source>When the config key &lt;code&gt;extensions.preciousObjects&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, objects in the repository MUST NOT be deleted (e.g., by &lt;code&gt;git-prune&lt;/code&gt; or &lt;code&gt;git repack -d&lt;/code&gt;).</source>
          <target state="translated">config key &lt;code&gt;extensions.preciousObjects&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 저장소의 객체를 삭제해서는 안됩니다 (예 : &lt;code&gt;git-prune&lt;/code&gt; 또는 &lt;code&gt;git repack -d&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e23e26ad367e6b915821bbb7b38753fa6fd4c240" translate="yes" xml:space="preserve">
          <source>When the current working directory is below the repository directory print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">현재 작업 디렉토리가 저장소 디렉토리 아래에 있으면 &quot;true&quot;를 인쇄하고, 그렇지 않으면 &quot;false&quot;를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="8a7aa53d7bbe6bfa657a2a1bb84359882384d7fa" translate="yes" xml:space="preserve">
          <source>When the current working directory is inside the work tree of the repository print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">현재 작업 디렉토리가 저장소의 작업 트리 내에있는 경우 &quot;true&quot;를 인쇄하고 그렇지 않으면 &quot;false&quot;를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="e614fb1c074d0b3ebd865c7756d786dc01074ea4" translate="yes" xml:space="preserve">
          <source>When the environment variable &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is set, the program named by it is called to generate diffs, and Git does not use its builtin diff machinery. For a path that is added, removed, or modified, &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called with 7 parameters:</source>
          <target state="translated">환경 변수 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 가 설정되면 이름이 지정된 프로그램이 diff를 생성하기 위해 호출되고 Git은 내장 된 diff 기계를 사용하지 않습니다. 추가, 제거 또는 수정 된 경로의 경우 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 가 7 개의 매개 변수와 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="dd7dc6a4dcd86a8d725c2332772df83ad820f427" translate="yes" xml:space="preserve">
          <source>When the environment variable &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is set, the program named by it is called, instead of the diff invocation described above. For a path that is added, removed, or modified, &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called with 7 parameters:</source>
          <target state="translated">환경 변수 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 가 설정되면 위에서 설명한 diff 호출 대신 이름이 지정된 프로그램이 호출됩니다. 추가, 제거 또는 수정 된 경로의 경우 7 개의 매개 변수를 사용하여 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ec4de571b6827b1e0107c62834d6f8cf9f50bba2" translate="yes" xml:space="preserve">
          <source>When the git-rebase command is run, it will first execute a &quot;pre-rebase&quot; hook if one exists. You can use this hook to do sanity checks and reject the rebase if it isn&amp;rsquo;t appropriate. Please see the template pre-rebase hook script for an example.</source>
          <target state="translated">git-rebase 명령이 실행될 때 &quot;pre-rebase&quot;훅이 있으면 먼저 실행합니다. 이 후크를 사용하여 상태 검사를 수행하고 적절하지 않은 경우 리베이스를 거부 할 수 있습니다. 예제는 템플릿 사전 리베이스 후크 스크립트를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4663df00f4cd516023be3e887d8ecce789e72f00" translate="yes" xml:space="preserve">
          <source>When the history involves criss-cross merges, there can be more than one &lt;code&gt;best&lt;/code&gt; common ancestor for two commits. For example, with this topology:</source>
          <target state="translated">역사 십자 병합을 포함 할 경우, 하나 이상의있을 수 있습니다 &lt;code&gt;best&lt;/code&gt; 두 커밋에 대한 공통 조상. 예를 들어이 토폴로지의 경우</target>
        </trans-unit>
        <trans-unit id="58beafa5cea14c3b99014fb314d938b1ee9fac65" translate="yes" xml:space="preserve">
          <source>When the man viewer, specified by the &lt;code&gt;man.viewer&lt;/code&gt; configuration variables, is not among the supported ones, then the corresponding &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; configuration variable will be looked up. If this variable exists then the specified tool will be treated as a custom command and a shell eval will be used to run the command with the man page passed as arguments.</source>
          <target state="translated">&lt;code&gt;man.viewer&lt;/code&gt; 구성 변수로 지정된 man 뷰어 가 지원되는 변수 중 하나가 아닌 경우 해당 &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 구성 변수가 조회됩니다. 이 변수가 존재하면 지정된 도구는 사용자 정의 명령으로 취급되며 셸 평가는 명령 페이지를 인수로 전달하여 명령을 실행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d01c091e9d01b5baf9f294a1d7b9c823d7d014bc" translate="yes" xml:space="preserve">
          <source>When the output goes to a terminal, it is color-coded by default, just like regular &lt;code&gt;git diff&lt;/code&gt;'s output. In addition, the first line (adding a commit) is green, the last line (deleting a commit) is red, the second line (with a perfect match) is yellow like the commit header of &lt;code&gt;git
show&lt;/code&gt;'s output, and the third line colors the old commit red, the new one green and the rest like &lt;code&gt;git show&lt;/code&gt;'s commit header.</source>
          <target state="translated">출력이 터미널로 이동하면 일반 &lt;code&gt;git diff&lt;/code&gt; 출력 과 마찬가지로 기본적으로 색상이 코딩됩니다 . 또한 첫 번째 줄 (커밋 추가)은 녹색이고 마지막 줄 (커밋 삭제)은 빨간색이며 두 번째 줄 (완벽한 일치)은 &lt;code&gt;git show&lt;/code&gt; 출력 의 커밋 헤더와 같이 노란색 이며 세 번째 줄 라인은 오래된 커밋 빨간색, 새로운 커밋 녹색 및 나머지는 &lt;code&gt;git show&lt;/code&gt; 의 커밋 헤더와 같습니다.</target>
        </trans-unit>
        <trans-unit id="ecf68ce55bda2542529810833e005e7f157f71c2" translate="yes" xml:space="preserve">
          <source>When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally. &lt;code&gt;--no-3way&lt;/code&gt; can be used to override am.threeWay configuration variable. For more information, see am.threeWay in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">패치가 제대로 적용되지 않으면 패치에 적용 할 얼룩의 ID가 기록되고 해당 얼룩을 로컬로 사용할 수있는 경우 3 방향 병합으로 폴백합니다. &lt;code&gt;--no-3way&lt;/code&gt; 를 사용하여 am.threeWay 구성 변수를 대체 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]의&lt;/a&gt; am.threeWay를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="28728fcf386b485f532ec99285643062f0405ba5" translate="yes" xml:space="preserve">
          <source>When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to, and we have those blobs available locally, possibly leaving the conflict markers in the files in the working tree for the user to resolve. This option implies the &lt;code&gt;--index&lt;/code&gt; option, and is incompatible with the &lt;code&gt;--reject&lt;/code&gt; and the &lt;code&gt;--cached&lt;/code&gt; options.</source>
          <target state="translated">패치가 제대로 적용되지 않는 경우 패치에 적용 할 얼룩의 ID를 기록하고 해당 얼룩을 로컬로 사용할 수 있으면 작업 트리의 파일에 충돌 마커가 남을 수 있습니다. 사용자가 해결할 수 있습니다. 이 옵션은 &lt;code&gt;--index&lt;/code&gt; 옵션을 의미하며 &lt;code&gt;--reject&lt;/code&gt; 및 &lt;code&gt;--cached&lt;/code&gt; 옵션 과 호환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bdd1b4760c591dff915e966378bff929405d28b1" translate="yes" xml:space="preserve">
          <source>When the push is complete, outputs one or more &lt;code&gt;ok &amp;lt;dst&amp;gt;&lt;/code&gt; or &lt;code&gt;error &amp;lt;dst&amp;gt; &amp;lt;why&amp;gt;?&lt;/code&gt; lines to indicate success or failure of each pushed ref. The status report output is terminated by a blank line. The option field &amp;lt;why&amp;gt; may be quoted in a C style string if it contains an LF.</source>
          <target state="translated">푸시가 완료되면 하나 이상의 &lt;code&gt;ok &amp;lt;dst&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;error &amp;lt;dst&amp;gt; &amp;lt;why&amp;gt;?&lt;/code&gt; 푸시 된 각 심판의 성공 또는 실패를 나타내는 선. 상태 보고서 출력은 빈 줄로 종료됩니다. 옵션 필드 &amp;lt;why&amp;gt;는 LF를 포함하는 경우 C 스타일 문자열로 인용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c36826b0bb47b2400e28127fc2b6b138c228a63f" translate="yes" xml:space="preserve">
          <source>When the remote branch you want to fetch is known to be rewound and rebased regularly, it is expected that its new tip will not be descendant of its previous tip (as stored in your remote-tracking branch the last time you fetched). You would want to use the &lt;code&gt;+&lt;/code&gt; sign to indicate non-fast-forward updates will be needed for such branches. There is no way to determine or declare that a branch will be made available in a repository with this behavior; the pulling user simply must know this is the expected usage pattern for a branch.</source>
          <target state="translated">가져 오려는 원격 브랜치가 되감기 고 정기적으로 리베이스되는 것으로 알려진 경우, 새로운 팁이 이전 팁의 후손이 아닌 것으로 예상됩니다 (마지막 페치시 원격 추적 브랜치에 저장 됨). &lt;code&gt;+&lt;/code&gt; 기호 를 사용하여 해당 분기에 빨리 감기가 아닌 업데이트가 필요함을 나타냅니다. 이 동작으로 저장소에서 브랜치를 사용할 수 있다고 결정하거나 선언 할 방법이 없습니다. 당기는 사용자는 이것이 브랜치의 예상 사용 패턴임을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c2d02d0fdbdd6b68f91184ab0fd8a5fcfd84e982" translate="yes" xml:space="preserve">
          <source>When the repository is bare print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">리포지토리가 베어 인쇄 된 경우 &quot;true&quot;, 그렇지 않으면 &quot;false&quot;</target>
        </trans-unit>
        <trans-unit id="4881892c9231f2a8cbf0d32abf5995af521026ca" translate="yes" xml:space="preserve">
          <source>When the repository is shallow print &quot;true&quot;, otherwise &quot;false&quot;.</source>
          <target state="translated">저장소가 얕게 인쇄되면 &quot;true&quot;이고 그렇지 않으면 &quot;false&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="37826a890a4b64bdd1230276a23bd80630675ca5" translate="yes" xml:space="preserve">
          <source>When the repository named by &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; has the commit at a tip of a ref that is different from the ref you have locally, you can use the &lt;code&gt;&amp;lt;local&amp;gt;:&amp;lt;remote&amp;gt;&lt;/code&gt; syntax, to have its local name, a colon &lt;code&gt;:&lt;/code&gt;, and its remote name.</source>
          <target state="translated">&lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; 이라는 이름의 저장소에 로컬 참조와 다른 참조 끝에 커밋이있는 경우 &lt;code&gt;&amp;lt;local&amp;gt;:&amp;lt;remote&amp;gt;&lt;/code&gt; 구문을 사용하여 로컬 이름 인 콜론 &lt;code&gt;:&lt;/code&gt; , 그리고 그 원격 이름.</target>
        </trans-unit>
        <trans-unit id="a7fe7f8247bda757ca8d697055bcfe0913ae2caf" translate="yes" xml:space="preserve">
          <source>When the repository to clone from is on a local machine, this flag bypasses the normal &quot;Git aware&quot; transport mechanism and clones the repository by making a copy of HEAD and everything under objects and refs directories. The files under &lt;code&gt;.git/objects/&lt;/code&gt; directory are hardlinked to save space when possible.</source>
          <target state="translated">복제 할 저장소가 로컬 시스템에있는 경우이 플래그는 일반적인 &quot;Git aware&quot;전송 메커니즘을 무시하고 오브젝트 및 참조 디렉토리 아래에 HEAD 및 모든 사본을 작성하여 저장소를 복제합니다. &lt;code&gt;.git/objects/&lt;/code&gt; 디렉토리 의 파일 은 가능한 경우 공간을 절약하기 위해 하드 링크되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="87edb2bef2f28c0f63de7720d331d50db0279e94" translate="yes" xml:space="preserve">
          <source>When the repository to clone is on the local machine, instead of using hard links, automatically setup &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; to share the objects with the source repository. The resulting repository starts out without any object of its own.</source>
          <target state="translated">복제 할 리포지토리가 로컬 컴퓨터에있는 경우 하드 링크를 사용하는 대신 소스 리포지토리와 개체를 공유하도록 &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; 를 자동으로 설정 하십시오. 결과 리포지토리는 자체 개체없이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="e18b845f941d21aaf5232c387f67cb23d0a4e759" translate="yes" xml:space="preserve">
          <source>When the result of a &lt;code&gt;git bisect&lt;/code&gt; is a non-merge commit, you should normally be able to discover the problem by examining just that commit. Developers can make this easy by breaking their changes into small self-contained commits. That won&amp;rsquo;t help in the case above, however, because the problem isn&amp;rsquo;t obvious from examination of any single commit; instead, a global view of the development is required. To make matters worse, the change in semantics in the problematic function may be just one small part of the changes in the upper line of development.</source>
          <target state="translated">&lt;code&gt;git bisect&lt;/code&gt; 의 결과가 병합되지 않은 커밋 인 경우 일반적으로 해당 커밋 만 검사하여 문제를 발견 할 수 있습니다. 개발자는 변경 사항을 작은 자체 커밋으로 변경하여이를 쉽게 수행 할 수 있습니다. 그러나 위의 경우에는 도움이되지 않습니다. 단일 커밋을 검사하면 문제가 분명하지 않기 때문입니다. 대신, 개발에 대한 세계적 관점이 필요합니다. 설상가상으로, 문제가있는 함수에서 의미론의 변화는 개발의 상위 라인 변화의 작은 부분 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57dfd8622d0e5d97d5c5344dbdac2c35010a468d" translate="yes" xml:space="preserve">
          <source>When the split index feature is used, shared index files that were not modified since the time this variable specifies will be removed when a new shared index file is created. The value &quot;now&quot; expires all entries immediately, and &quot;never&quot; suppresses expiration altogether. The default value is &quot;2.weeks.ago&quot;. Note that a shared index file is considered modified (for the purpose of expiration) each time a new split-index file is either created based on it or read from it. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">인덱스 분할 기능을 사용하는 경우이 변수가 지정한 시간 이후 수정되지 않은 공유 인덱스 파일은 새 공유 인덱스 파일이 만들어 질 때 제거됩니다. &quot;now&quot;값은 모든 항목을 즉시 만료시키고 &quot;never&quot;는 만료를 완전히 억제합니다. 기본값은 &quot;2.weeks.ago&quot;입니다. 공유 인덱스 파일은 새 분할 인덱스 파일을 기반으로 만들거나 읽을 때마다 (만료 목적으로) 수정 된 것으로 간주됩니다. &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="887ef75c2523fd6b4da84b3a0a714f4995305746" translate="yes" xml:space="preserve">
          <source>When the split index feature is used, this specifies the percent of entries the split index can contain compared to the total number of entries in both the split index and the shared index before a new shared index is written. The value should be between 0 and 100. If the value is 0 then a new shared index is always written, if it is 100 a new shared index is never written. By default the value is 20, so a new shared index is written if the number of entries in the split index would be greater than 20 percent of the total number of entries. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">분할 인덱스 기능을 사용하는 경우 새 공유 인덱스를 작성하기 전에 분할 인덱스와 공유 인덱스의 총 항목 수와 비교할 때 분할 인덱스에 포함 할 수있는 항목의 백분율을 지정합니다. 값은 0과 100 사이 여야합니다. 값이 0이면 새 공유 인덱스가 항상 기록되고 100이면 새 공유 인덱스가 기록되지 않습니다. 기본적으로 값은 20이므로 분할 인덱스의 항목 수가 총 항목 수의 20 %보다 클 경우 새 공유 인덱스가 작성됩니다. &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1631afdb92ffecd0a40ddcd8f40433691ff79d82" translate="yes" xml:space="preserve">
          <source>When the value is &lt;code&gt;interactive&lt;/code&gt; (or just &lt;code&gt;i&lt;/code&gt;), the rebase is run in interactive mode.</source>
          <target state="translated">값이 &lt;code&gt;interactive&lt;/code&gt; (또는 &lt;code&gt;i&lt;/code&gt; 만 )이면 리베이스는 대화식 모드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="249674ff1351f5c865508a34f368a209ce692426" translate="yes" xml:space="preserve">
          <source>When the value is &lt;code&gt;interactive&lt;/code&gt;, the rebase is run in interactive mode.</source>
          <target state="translated">값이 &lt;code&gt;interactive&lt;/code&gt; 이면 rebase는 대화식 모드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2a8620af5de619d02cbdb1290090cf457f4270c6" translate="yes" xml:space="preserve">
          <source>When the working tree is updated, using --recurse-submodules will also recursively reset the working tree of all active submodules according to the commit recorded in the superproject, also setting the submodules' HEAD to be detached at that commit.</source>
          <target state="translated">작업 트리가 업데이트 될 때 --recurse-submodules를 사용하면 수퍼 프로젝트에 기록 된 커밋에 따라 모든 활성 서브 모듈의 작업 트리도 재귀 적으로 재설정되고 해당 커밋에서 분리되도록 서브 모듈의 HEAD를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="bbc30d1504ae5818b5ebed3f68f464e3d8d41b06" translate="yes" xml:space="preserve">
          <source>When there are approximately more than this many loose objects in the repository, &lt;code&gt;git gc --auto&lt;/code&gt; will pack them. Some Porcelain commands use this command to perform a light-weight garbage collection from time to time. The default value is 6700.</source>
          <target state="translated">저장소에 이보다 많은 느슨한 객체가 있으면 &lt;code&gt;git gc --auto&lt;/code&gt; 가이 를 포장합니다. 일부 Porcelain 명령은이 명령을 사용하여 때때로 가벼운 가비지 콜렉션을 수행합니다. 기본값은 6700입니다.</target>
        </trans-unit>
        <trans-unit id="c316674f184677333eb7d2b00fe1f02bf0eda4b8" translate="yes" xml:space="preserve">
          <source>When there are content conflicts, the merge machinery tries to annotate each side&amp;rsquo;s conflict markers with the commits where the content came from. Since the apply backend drops the original information about the rebased commits and their parents (and instead generates new fake commits based off limited information in the generated patches), those commits cannot be identified; instead it has to fall back to a commit summary. Also, when merge.conflictStyle is set to diff3, the apply backend will use &quot;constructed merge base&quot; to label the content from the merge base, and thus provide no information about the merge base commit whatsoever.</source>
          <target state="translated">콘텐츠 충돌이있을 때 병합 기계는 콘텐츠가 발생한 커밋으로 각 측면의 충돌 마커에 주석을 추가하려고합니다. 적용 백엔드는 리 기반 커밋과 그 부모에 대한 원래 정보를 삭제하고 (대신 생성 된 패치의 제한된 정보를 기반으로 새로운 가짜 커밋을 생성 함) 이러한 커밋을 식별 할 수 없습니다. 대신 커밋 요약으로 돌아 가야합니다. 또한 merge.conflictStyle이 diff3으로 설정되면 적용 백엔드는 &quot;구성된 병합 기준&quot;을 사용하여 병합 기준의 콘텐츠에 레이블을 지정하므로 병합 기준 커밋에 대한 정보를 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62fefa7cb364ff9a836bef0837ac15925fecc8f2" translate="yes" xml:space="preserve">
          <source>When there are more than this many packs that are not marked with &lt;code&gt;*.keep&lt;/code&gt; file in the repository, &lt;code&gt;git gc
--auto&lt;/code&gt; consolidates them into one larger pack. The default value is 50. Setting this to 0 disables it. Setting &lt;code&gt;gc.auto&lt;/code&gt; to 0 will also disable this.</source>
          <target state="translated">저장소에 &lt;code&gt;*.keep&lt;/code&gt; 파일 로 표시되지 않은이 팩보다 많은 팩이 있으면 &lt;code&gt;git gc --auto&lt;/code&gt; 는이 팩을 하나의 큰 팩으로 통합합니다. 기본값은 50입니다.이 값을 0으로 설정하면 비활성화됩니다. &lt;code&gt;gc.auto&lt;/code&gt; 를 0으로 설정하면 이 기능도 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="a99bf9777c550eb2f6602e82876314f8cadcb15d" translate="yes" xml:space="preserve">
          <source>When there is only one argument given and it is not &lt;code&gt;--&lt;/code&gt; (e.g. &lt;code&gt;git
checkout abc&lt;/code&gt;), and when the argument is both a valid &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (e.g. a branch &lt;code&gt;abc&lt;/code&gt; exists) and a valid &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; (e.g. a file or a directory whose name is &quot;abc&quot; exists), Git would usually ask you to disambiguate. Because checking out a branch is so common an operation, however, &lt;code&gt;git checkout abc&lt;/code&gt; takes &quot;abc&quot; as a &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; in such a situation. Use &lt;code&gt;git checkout -- &amp;lt;pathspec&amp;gt;&lt;/code&gt; if you want to checkout these paths out of the index.</source>
          <target state="translated">거기에 주어진 단 하나 개의 인수이며이 아닌 경우 &lt;code&gt;--&lt;/code&gt; (예를 들어 &lt;code&gt;git checkout abc&lt;/code&gt; ), 인수는 모두 유효한 경우 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (예 : 분기 &lt;code&gt;abc&lt;/code&gt; 존재하는) 유효한 &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; (예 : 파일 또는 이름이 &quot;abc&quot;인 디렉토리가 존재하는 경우) Git은 일반적으로 명확성을 요구합니다. 분기를 체크 아웃하는 것은 일반적인 작업이므로 &lt;code&gt;git checkout abc&lt;/code&gt; 는 이러한 상황에서 &quot;abc&quot;를 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 로 사용합니다. 인덱스에서 이러한 경로를 체크 &lt;code&gt;git checkout -- &amp;lt;pathspec&amp;gt;&lt;/code&gt; 하려면 git checkout-&amp;lt;pathspec&amp;gt;을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ff1d02c565a22d417998ec283b077273b716d4a" translate="yes" xml:space="preserve">
          <source>When these environment variables are set, the corresponding command-line arguments may not be used.</source>
          <target state="translated">이러한 환경 변수가 설정되면 해당 명령 줄 인수를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="86c4d2dcd046b538b0d9c792061f20bffd3f8c8e" translate="yes" xml:space="preserve">
          <source>When this flag is provided, the pack is read from stdin instead and a copy is then written to &amp;lt;pack-file&amp;gt;. If &amp;lt;pack-file&amp;gt; is not specified, the pack is written to objects/pack/ directory of the current Git repository with a default name determined from the pack content. If &amp;lt;pack-file&amp;gt; is not specified consider using --keep to prevent a race condition between this process and &lt;code&gt;git repack&lt;/code&gt;.</source>
          <target state="translated">이 플래그가 제공되면, 대신 stdin에서 팩을 읽은 다음 &amp;lt;pack-file&amp;gt;에 사본을 씁니다. &amp;lt;pack-file&amp;gt;을 지정하지 않으면 팩은 현재 Git 저장소의 objects / pack / 디렉토리에 팩 컨텐츠에서 결정된 기본 이름으로 기록됩니다. &amp;lt;pack-file&amp;gt;이 지정되지 않은 경우 --keep을 사용하여이 프로세스와 &lt;code&gt;git repack&lt;/code&gt; 사이의 경쟁 조건을 방지하십시오 .</target>
        </trans-unit>
        <trans-unit id="c91915e7d5f6096e68c1652d49f4ac505147354d" translate="yes" xml:space="preserve">
          <source>When this flag is specified, the object names recorded for the paths are not updated. Instead, this option sets/unsets the &quot;assume unchanged&quot; bit for the paths. When the &quot;assume unchanged&quot; bit is on, the user promises not to change the file and allows Git to assume that the working tree file matches what is recorded in the index. If you want to change the working tree file, you need to unset the bit to tell Git. This is sometimes helpful when working with a big project on a filesystem that has very slow lstat(2) system call (e.g. cifs).</source>
          <target state="translated">이 플래그를 지정하면 경로에 대해 기록 된 오브젝트 이름이 업데이트되지 않습니다. 대신이 옵션은 경로에 대해 &quot;변경되지 않은 것으로 가정&quot;비트를 설정 / 설정 해제합니다. &quot;변경되지 않은 것으로 가정&quot;비트가 켜져 있으면, 사용자는 파일을 변경하지 않겠다고 약속하고 Git은 작업 트리 파일이 인덱스에 기록 된 것과 일치한다고 가정 할 수 있습니다. 작업 트리 파일을 변경하려면 Git에 알리기 위해 비트를 설정 해제해야합니다. lstat (2) 시스템 호출이 매우 느린 파일 시스템 (예 : cifs)에서 큰 프로젝트로 작업 할 때 가끔 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b1f75c6b9b1b22670befceda22525699cad697f2" translate="yes" xml:space="preserve">
          <source>When this form of &lt;code&gt;git read-tree&lt;/code&gt; returns successfully, you can see which of the &quot;local changes&quot; that you made were carried forward by running &lt;code&gt;git diff-index --cached $M&lt;/code&gt;. Note that this does not necessarily match what &lt;code&gt;git diff-index --cached $H&lt;/code&gt; would have produced before such a two tree merge. This is because of cases 18 and 19 --- if you already had the changes in $M (e.g. maybe you picked it up via e-mail in a patch form), &lt;code&gt;git diff-index
--cached $H&lt;/code&gt; would have told you about the change before this merge, but it would not show in &lt;code&gt;git diff-index --cached $M&lt;/code&gt; output after the two-tree merge.</source>
          <target state="translated">이 형식의 &lt;code&gt;git read-tree&lt;/code&gt; 가 성공적으로 반환되면 &lt;code&gt;git diff-index --cached $M&lt;/code&gt; 을 실행하여 수행 한 &quot;로컬 변경&quot;중 어느 것이 수행 되었는지 확인할 수 있습니다. 이것은 두 개의 트리 병합 전에 &lt;code&gt;git diff-index --cached $H&lt;/code&gt; 가 생성 한 것과 반드시 ​​일치하지는 않습니다 . 이것은 18 번과 19 번 사건 때문입니다 --- 만약 $ M에 이미 변경이 있었다면 (예를 들어, 패치 형태로 전자 우편을 통해 받아 들일 수 있습니다 ), &lt;code&gt;git diff-index --cached $H&lt;/code&gt; 가 당신에게 말했을 것입니다 이 병합 전에 변경 사항에 대해 설명하지만 2 트리 병합 후 &lt;code&gt;git diff-index --cached $M&lt;/code&gt; 출력 에는 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a7b5d3881356f9c9c7fd25660fd80f9c16873a97" translate="yes" xml:space="preserve">
          <source>When this option is specified, the behavior is as if a special &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; argument were added at the beginning of the command line, where &amp;lt;value&amp;gt; is taken to be the standard output of the specified command with any leading and trailing whitespace trimmed off.</source>
          <target state="translated">이 옵션을 지정 하면 명령 행의 시작 부분에 특수 &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 인수가 추가 된 것처럼 작동 합니다. 여기서 &amp;lt;value&amp;gt;는 지정된 명령의 표준 출력이됩니다. 후행 공백이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="fe0e96d95c4eefa9bfe72917d015cf48a18efcc2" translate="yes" xml:space="preserve">
          <source>When this special attribute is read by &lt;code&gt;git credential&lt;/code&gt;, the value is parsed as a URL and treated as if its constituent parts were read (e.g., &lt;code&gt;url=https://example.com&lt;/code&gt; would behave as if &lt;code&gt;protocol=https&lt;/code&gt; and &lt;code&gt;host=example.com&lt;/code&gt; had been provided). This can help callers avoid parsing URLs themselves.</source>
          <target state="translated">이 특수 속성을 &lt;code&gt;git credential&lt;/code&gt; 에서 읽을 때 값은 URL로 구문 분석되고 구성 부분을 읽은 것처럼 처리됩니다 (예 : &lt;code&gt;url=https://example.com&lt;/code&gt; 은 &lt;code&gt;protocol=https&lt;/code&gt; 및 &lt;code&gt;host=example.com&lt;/code&gt; example.com 처럼 작동합니다 . com 이 제공되었습니다). 이렇게하면 호출자가 URL을 직접 구문 분석하지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de58814133990da5a575ac12a35ef9b3b981ae4a" translate="yes" xml:space="preserve">
          <source>When this special attribute is read by &lt;code&gt;git credential&lt;/code&gt;, the value is parsed as a URL and treated as if its constituent parts were read (e.g., &lt;code&gt;url=https://example.com&lt;/code&gt; would behave as if &lt;code&gt;protocol=https&lt;/code&gt; and &lt;code&gt;host=example.com&lt;/code&gt; had been provided). This can help callers avoid parsing URLs themselves. Note that any components which are missing from the URL (e.g., there is no username in the example above) will be set to empty; if you want to provide a URL and override some attributes, provide the URL attribute first, followed by any overrides.</source>
          <target state="translated">이 특수 속성이 &lt;code&gt;git credential&lt;/code&gt; 에 의해 읽 히면 값은 URL로 구문 분석되어 구성 부분을 읽은 것처럼 처리됩니다 (예 : &lt;code&gt;url=https://example.com&lt;/code&gt; 은 &lt;code&gt;protocol=https&lt;/code&gt; 및 &lt;code&gt;host=example.com&lt;/code&gt; 처럼 작동합니다 . com 이 제공되었습니다). 이렇게하면 발신자가 URL을 구문 분석하지 않아도됩니다. URL에서 누락 된 모든 구성 요소 (예 : 위의 예에서 사용자 이름이 없음)는 비어 있습니다. URL을 제공하고 일부 속성을 재정의하려면 URL 속성을 먼저 제공 한 다음 재정의를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="882eafec7b82da90c1fd3ae7dc7040457d013cf9" translate="yes" xml:space="preserve">
          <source>When trace files are written to a target directory, they will be named according to the last component of the SID (optionally followed by a counter to avoid filename collisions).</source>
          <target state="translated">추적 파일이 대상 디렉토리에 기록되면 SID의 마지막 구성 요소에 따라 이름이 지정됩니다 (선택적으로 파일 이름 충돌을 피하기 위해 카운터가 뒤 따름).</target>
        </trans-unit>
        <trans-unit id="1771ffd8c74f9f0b2e623ff3c52581b28a17469b" translate="yes" xml:space="preserve">
          <source>When tracking multiple directories (using --stdlayout, --branches, or --tags options), git svn will attempt to connect to the root (or highest allowed level) of the Subversion repository. This default allows better tracking of history if entire projects are moved within a repository, but may cause issues on repositories where read access restrictions are in place. Passing &lt;code&gt;--no-minimize-url&lt;/code&gt; will allow git svn to accept URLs as-is without attempting to connect to a higher level directory. This option is off by default when only one URL/branch is tracked (it would do little good).</source>
          <target state="translated">--stdlayout, --branches 또는 --tags 옵션을 사용하여 여러 디렉토리를 추적 할 때 git svn은 Subversion 저장소의 루트 (또는 최고 허용 레벨)에 연결을 시도합니다. 이 기본값은 전체 프로젝트가 저장소 내에서 이동 된 경우 히스토리를 더 잘 추적 할 수 있지만 읽기 액세스 제한이있는 저장소에 문제를 일으킬 수 있습니다. &lt;code&gt;--no-minimize-url&lt;/code&gt; 을 전달 하면 git svn이 상위 디렉토리에 연결하지 않고있는 그대로 URL을 수락 할 수 있습니다. 이 옵션은 하나의 URL / 브랜치 만 추적 할 때 기본적으로 해제되어 있습니다 (아주 효과가 거의 없음).</target>
        </trans-unit>
        <trans-unit id="442a6a05d34f849ad275ea5e7d6f50f5aafe59d9" translate="yes" xml:space="preserve">
          <source>When true, and when reachability bitmaps are enabled, pack-objects will try to send parts of the bitmapped packfile verbatim. This can reduce memory and CPU usage to serve fetches, but might result in sending a slightly larger pack. Defaults to true.</source>
          <target state="translated">true이고 도달 가능성 비트 맵이 활성화되면 pack-objects는 비트 맵 된 packfile의 일부를 그대로 보내려고합니다. 이렇게하면 가져 오기를 제공하기위한 메모리 및 CPU 사용량이 줄어들 수 있지만 약간 더 큰 팩을 보낼 수 있습니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="fce35b3add797f616ba5b3be537b437a03e625f0" translate="yes" xml:space="preserve">
          <source>When true, git will default to using the &lt;code&gt;--sparse&lt;/code&gt; option in &lt;code&gt;git pack-objects&lt;/code&gt; when the &lt;code&gt;--revs&lt;/code&gt; option is present. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. Default is &lt;code&gt;false&lt;/code&gt; unless &lt;code&gt;feature.experimental&lt;/code&gt; is enabled.</source>
          <target state="translated">true 인 경우 &lt;code&gt;--revs&lt;/code&gt; 옵션이 있으면 git은 기본적으로 &lt;code&gt;git pack-objects&lt;/code&gt; 에서 &lt;code&gt;--sparse&lt;/code&gt; 옵션 을 사용합니다 . 이 알고리즘은 새로운 객체를 도입하는 경로에 나타나는 트리 만 걷는다. 이것은 작은 변화를 보내기 위해 팩을 계산할 때 상당한 성능 이점을 가질 수 있습니다. 그러나 포함 된 커밋에 특정 유형의 직접 이름 바꾸기가 포함되어 있으면 추가 객체가 팩 파일에 추가 될 수 있습니다. &lt;code&gt;feature.experimental&lt;/code&gt; 을 사용 하지 않으면 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a46d4189a8b9229b7d91d54cdebfebe81ffd9ae6" translate="yes" xml:space="preserve">
          <source>When true, git will default to using the &lt;code&gt;--sparse&lt;/code&gt; option in &lt;code&gt;git pack-objects&lt;/code&gt; when the &lt;code&gt;--revs&lt;/code&gt; option is present. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. Default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">true이면 git은 &lt;code&gt;--revs&lt;/code&gt; 옵션이 있을 때 &lt;code&gt;git pack-objects&lt;/code&gt; 에서 &lt;code&gt;--sparse&lt;/code&gt; 옵션을 기본적으로 사용합니다 . 이 알고리즘은 새 개체를 도입하는 경로에 나타나는 나무 만 걷습니다. 이것은 작은 변화를 보내기 위해 팩을 계산할 때 상당한 성능 이점을 가질 수 있습니다. 그러나 포함 된 커밋에 특정 유형의 직접 이름 변경이 포함 된 경우 추가 개체가 팩 파일에 추가 될 수 있습니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5d73311a3b4a00977d7e2237078b01efb9320bfa" translate="yes" xml:space="preserve">
          <source>When true, git will include a &quot;hash cache&quot; section in the bitmap index (if one is written). This cache can be used to feed git&amp;rsquo;s delta heuristics, potentially leading to better deltas between bitmapped and non-bitmapped objects (e.g., when serving a fetch between an older, bitmapped pack and objects that have been pushed since the last gc). The downside is that it consumes 4 bytes per object of disk space. Defaults to true.</source>
          <target state="translated">true 인 경우 git은 &quot;해시 캐시&quot;섹션을 비트 맵 인덱스에 작성합니다 (작성된 경우). 이 캐시는 git의 델타 휴리스틱을 제공하는 데 사용될 수 있으며, 잠재적으로 비트 맵 및 비트 맵되지 않은 객체 사이의 델타를 향상시킬 수 있습니다 (예 : 이전, 비트 맵 된 팩과 마지막 gc 이후 푸시 된 객체 간의 페치 제공시). 단점은 디스크 공간 객체 당 4 바이트를 소비한다는 것입니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="98f36898b39f3ac14609adb644f7b367554be4b3" translate="yes" xml:space="preserve">
          <source>When true, git will use pack bitmaps (if available) when packing to stdout (e.g., during the server side of a fetch). Defaults to true. You should not generally need to turn this off unless you are debugging pack bitmaps.</source>
          <target state="translated">참이면, git은 stdout으로 패킹 할 때 (예를 들어, 페치의 서버 측에서) 팩 비트 맵 (사용 가능한 경우)을 사용합니다. 기본값은 true입니다. 팩 비트 맵을 디버깅하지 않는 한 일반적으로이 기능을 해제 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3060361b8b64f7f4f15aa5d402b402d65fd1ef21" translate="yes" xml:space="preserve">
          <source>When true, git will write a bitmap index when packing all objects to disk (e.g., when &lt;code&gt;git repack -a&lt;/code&gt; is run). This index can speed up the &quot;counting objects&quot; phase of subsequent packs created for clones and fetches, at the cost of some disk space and extra time spent on the initial repack. This has no effect if multiple packfiles are created. Defaults to true on bare repos, false otherwise.</source>
          <target state="translated">참이면, git은 모든 객체를 디스크에 패킹 할 때 (예를 들어, &lt;code&gt;git repack -a&lt;/code&gt; 가 실행될 때) 비트 맵 인덱스를 씁니다 . 이 인덱스를 사용하면 일부 디스크 공간과 초기 재 포장에 소요되는 추가 시간을 소비하면서 클론 및 페치에 대해 생성 된 후속 팩의 &quot;개체 수 계산&quot;단계를 가속화 할 수 있습니다. 여러 팩 파일이 생성 된 경우에는 효과가 없습니다. 베어 리포 지에서는 기본값이 true이고, 그렇지 않으면 false입니다.</target>
        </trans-unit>
        <trans-unit id="b7b0c56b83a62c5cf7d9e0b77ba1430747588d7a" translate="yes" xml:space="preserve">
          <source>When true, rebase branches on top of the fetched branch, instead of merging the default branch from the default remote when &quot;git pull&quot; is run. See &quot;branch.&amp;lt;name&amp;gt;.rebase&quot; for setting this on a per-branch basis.</source>
          <target state="translated">true 인 경우, &quot;git pull&quot;이 실행될 때 기본 원격에서 기본 분기를 병합하는 대신 가져온 분기 위에 분기를 리베이스하십시오. 분기별로이를 설정하려면 &quot;branch. &amp;lt;name&amp;gt; .rebase&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c15c8ba9ac152f7e581087f6ca67eb8a95961a05" translate="yes" xml:space="preserve">
          <source>When true, rebase the branch &amp;lt;name&amp;gt; on top of the fetched branch, instead of merging the default branch from the default remote when &quot;git pull&quot; is run. See &quot;pull.rebase&quot; for doing this in a non branch-specific manner.</source>
          <target state="translated">true 인 경우 &quot;git pull&quot;이 실행될 때 기본 원격에서 기본 분기를 병합하는 대신 가져온 분기의 맨 위에 &amp;lt;name&amp;gt; 분기를 리베이스하십시오. 비지정 방식으로이를 수행하려면 &quot;pull.rebase&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="32f2ccfcaf97ac2d1b8fdcbcf4ee46e8d18499a7" translate="yes" xml:space="preserve">
          <source>When true, rebase the current branch on top of the upstream branch after fetching. If there is a remote-tracking branch corresponding to the upstream branch and the upstream branch was rebased since last fetched, the rebase uses that information to avoid rebasing non-local changes.</source>
          <target state="translated">참이면 페치 한 후 업스트림 브랜치 위에 현재 브랜치를 리베이스합니다. 업스트림 브랜치에 해당하는 원격 추적 브랜치가 있고 마지막 페치 이후 업스트림 브랜치가 리베이스 된 경우 리베이스는 해당 정보를 사용하여 로컬이 아닌 변경 사항의 재베이스를 피합니다.</target>
        </trans-unit>
        <trans-unit id="e3872f2dbeef66b0c7927df02dbbfa3a35c8d12b" translate="yes" xml:space="preserve">
          <source>When two trees are given, it compares the first tree with the second. When a single commit is given, it compares the commit with its parents. The remaining commits, when given, are used as if they are parents of the first commit.</source>
          <target state="translated">두 개의 나무가 주어지면 첫 번째 나무와 두 번째 나무를 비교합니다. 단일 커밋이 제공되면 해당 커밋을 부모와 비교합니다. 주어진 커밋은 마치 첫 커밋의 부모 인 것처럼 사용됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
