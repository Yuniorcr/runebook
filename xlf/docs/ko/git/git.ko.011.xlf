<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="c2dfec9fbb580524d9c87ce7e3303a7b47cc295d" translate="yes" xml:space="preserve">
          <source>This is passed to both underlying git-fetch to squelch reporting of during transfer, and underlying git-merge to squelch output during merging.</source>
          <target state="translated">이것은 전송하는 동안 기본 git-fetch to squelch보고와 병합하는 동안 기본 git-merge to squelch 출력으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="3d17e8f742373c8bbf1871e58142a3d3c4b1c09b" translate="yes" xml:space="preserve">
          <source>This is per-repository enhancement / version of global prefix-based &lt;code&gt;@git_base_url_list&lt;/code&gt; gitweb configuration variable (see &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt;).</source>
          <target state="translated">전역 접두사 기반 &lt;code&gt;@git_base_url_list&lt;/code&gt; gitweb 구성 변수 의 저장소 별 향상 / 버전입니다 ( &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a7bcc6783fe2c533eb40b84879a83d32f4d95dc9" translate="yes" xml:space="preserve">
          <source>This is similar to --symbolic, but it omits input that are not refs (i.e. branch or tag names; or more explicitly disambiguating &quot;heads/master&quot; form, when you want to name the &quot;master&quot; branch when there is an unfortunately named tag &quot;master&quot;), and show them as full refnames (e.g. &quot;refs/heads/master&quot;).</source>
          <target state="translated">이것은 --symbolic과 비슷하지만 참조가 아닌 입력 (예 : 분기 또는 태그 이름) 또는 불행히도 명명 된 &quot;마스터&quot;분기의 이름을 지정하려는 경우 더 명확하게 &quot;헤드 / 마스터&quot;양식을 명시 적으로 생략합니다. 태그를 &quot;마스터&quot;로 지정하고 전체 참조 이름으로 표시합니다 (예 : &quot;refs / heads / master&quot;).</target>
        </trans-unit>
        <trans-unit id="4cae7dda407705febf1be1d8f0d77956238a429a" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;info/grafts&lt;/code&gt; but is internally used and maintained by shallow clone mechanism. See &lt;code&gt;--depth&lt;/code&gt; option to &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; and &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;. This file is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/shallow&quot; will be used instead.</source>
          <target state="translated">이것은 &lt;code&gt;info/grafts&lt;/code&gt; 와 비슷 하지만 내부적으로 얕은 복제 메커니즘에 의해 사용되고 유지됩니다. &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 및 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]에 대한 &lt;/a&gt; &lt;code&gt;--depth&lt;/code&gt; 옵션을 참조하십시오 . $ GIT_COMMON_DIR이 설정되고 대신 &quot;$ GIT_COMMON_DIR / shallow&quot;가 사용되면이 파일은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="44c5e44a5b0e8e88feba4a9ab4b3411e28cf0521" translate="yes" xml:space="preserve">
          <source>This is similar to the previous mode, but lets you use the interactive interface to show the &quot;diff&quot; output and choose which hunks to use in the result. See below for the description of &lt;code&gt;--patch&lt;/code&gt; option.</source>
          <target state="translated">이것은 이전 모드와 비슷하지만 대화식 인터페이스를 사용하여 &quot;diff&quot;출력을 표시하고 결과에 사용할 덩어리를 선택할 수 있습니다. &lt;code&gt;--patch&lt;/code&gt; 옵션 에 대한 설명은 아래를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d4677f97f18bb53a7088b838331f1fec5e57df8" translate="yes" xml:space="preserve">
          <source>This is synonymous to the earlier form (without the &quot;..&quot;) for viewing the changes between two arbitrary &amp;lt;commit&amp;gt;. If &amp;lt;commit&amp;gt; on one side is omitted, it will have the same effect as using HEAD instead.</source>
          <target state="translated">이것은 두 임의의 &amp;lt;commit&amp;gt; 사이의 변경 사항을보기위한 이전 양식 ( &quot;..&quot;없음)과 동의어입니다. 한쪽에서 &amp;lt;commit&amp;gt;을 생략하면 대신 HEAD를 사용하는 것과 동일한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="53111542e6130a3092130c1b278f62eb8bf4f3d5" translate="yes" xml:space="preserve">
          <source>This is synonymous to the earlier form (without the &lt;code&gt;..&lt;/code&gt;) for viewing the changes between two arbitrary &amp;lt;commit&amp;gt;. If &amp;lt;commit&amp;gt; on one side is omitted, it will have the same effect as using HEAD instead.</source>
          <target state="translated">이것은 두 임의의 &amp;lt;commit&amp;gt; 사이의 변경 사항을보기위한 이전 양식 ( &lt;code&gt;..&lt;/code&gt; 없음 ) 과 동의어 입니다. 한쪽에서 &amp;lt;commit&amp;gt;을 생략하면 대신 HEAD를 사용하는 것과 동일한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4054020991b3f63ee43241d99b871a192e5f7888" translate="yes" xml:space="preserve">
          <source>This is synonymous to the previous form. If &amp;lt;commit&amp;gt; on one side is omitted, it will have the same effect as using HEAD instead.</source>
          <target state="translated">이것은 이전 양식과 동의어입니다. 한쪽의 &amp;lt;commit&amp;gt;을 생략하면 대신 HEAD를 사용하는 것과 동일한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="75478eb48b06b2098532610f52369c54c5a35766" translate="yes" xml:space="preserve">
          <source>This is the Git native format and is &lt;code&gt;&amp;lt;time&amp;gt; SP &amp;lt;offutc&amp;gt;&lt;/code&gt;. It is also fast-import&amp;rsquo;s default format, if --date-format was not specified.</source>
          <target state="translated">이것은 Git 기본 형식이며 &lt;code&gt;&amp;lt;time&amp;gt; SP &amp;lt;offutc&amp;gt;&lt;/code&gt; 입니다. --date-format이 지정되지 않은 경우 빠른 가져 오기의 기본 형식이기도합니다.</target>
        </trans-unit>
        <trans-unit id="6bd79ba5c8340a61cc49527317aae865e2230698" translate="yes" xml:space="preserve">
          <source>This is the filter for performing the commit. If this filter is specified, it will be called instead of the &lt;code&gt;git commit-tree&lt;/code&gt; command, with arguments of the form &quot;&amp;lt;TREE_ID&amp;gt; [(-p &amp;lt;PARENT_COMMIT_ID&amp;gt;)&amp;hellip;​]&quot; and the log message on stdin. The commit id is expected on stdout.</source>
          <target state="translated">커밋을 수행하기위한 필터입니다. 이 필터가 지정되면 &quot;&amp;lt;TREE_ID&amp;gt; [(-p &amp;lt;PARENT_COMMIT_ID&amp;gt;)&amp;hellip;]] 형식의 인수와 stdin의 로그 메시지와 함께 &lt;code&gt;git commit-tree&lt;/code&gt; 명령 대신 필터가 호출됩니다 . 커밋 ID는 stdout에서 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="ab02ed108f018595c9832dcfce47c6a593278667" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting tag names. When passed, it will be called for every tag ref that points to a rewritten object (or to a tag object which points to a rewritten object). The original tag name is passed via standard input, and the new tag name is expected on standard output.</source>
          <target state="translated">태그 이름을 다시 쓰는 필터입니다. 전달되면 다시 작성된 객체를 가리키는 모든 태그 참조 또는 다시 작성된 객체를 가리키는 태그 객체에 대해 호출됩니다. 원래 태그 이름은 표준 입력을 통해 전달되며 새 태그 이름은 표준 출력에 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="ec46b5cef98509f43f653471ea24de2e709b0b36" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the commit messages. The argument is evaluated in the shell with the original commit message on standard input; its standard output is used as the new commit message.</source>
          <target state="translated">커밋 메시지를 다시 쓰기위한 필터입니다. 인수는 표준 입력에서 원래 커밋 메시지와 함께 쉘에서 평가됩니다. 표준 출력은 새로운 커밋 메시지로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="baaf77805fbcb910ae11f451b39d9e38daaa6669" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the commit&amp;rsquo;s parent list. It will receive the parent string on stdin and shall output the new parent string on stdout. The parent string is in the format described in &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt;: empty for the initial commit, &quot;-p parent&quot; for a normal commit and &quot;-p parent1 -p parent2 -p parent3 &amp;hellip;​&quot; for a merge commit.</source>
          <target state="translated">커밋의 상위 목록을 다시 작성하기위한 필터입니다. stdin에서 상위 문자열을 수신하고 stdout에서 새 상위 문자열을 출력해야합니다. 부모 문자열은 &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree [1]에&lt;/a&gt; 설명 된 형식으로되어 있습니다 : 초기 커밋의 경우 비어 있고, 일반 커밋의 경우 &quot;-p parent&quot;, 병합의 경우 &quot;-p parent1 -p parent2 -p parent3&amp;hellip; 범하다.</target>
        </trans-unit>
        <trans-unit id="ed6796eee1e84719fc79503aec05a2585b0a98ee" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the index. It is similar to the tree filter but does not check out the tree, which makes it much faster. Frequently used with &lt;code&gt;git rm --cached
--ignore-unmatch ...&lt;/code&gt;, see EXAMPLES below. For hairy cases, see &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">인덱스를 다시 쓰기위한 필터입니다. 트리 필터와 비슷하지만 트리를 체크 아웃하지 않으므로 훨씬 빠릅니다. &lt;code&gt;git rm --cached --ignore-unmatch ...&lt;/code&gt; 와 함께 자주 사용되며 , 아래 예를 참조하십시오. 털이 많은 경우 &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="84464b13412e29584cb64fc663c003212ddd470c" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the tree and its contents. The argument is evaluated in shell with the working directory set to the root of the checked out tree. The new tree is then used as-is (new files are auto-added, disappeared files are auto-removed - neither .gitignore files nor any other ignore rules &lt;strong&gt;HAVE ANY EFFECT&lt;/strong&gt;!).</source>
          <target state="translated">트리와 그 내용을 다시 작성하기위한 필터입니다. 인수는 작업 디렉토리가 체크 아웃 된 트리의 루트로 설정된 쉘에서 평가됩니다. 그런 다음 새 트리는 그대로 사용됩니다 (새 파일은 자동으로 추가되고 사라진 파일은 자동으로 제거됩니다. .gitignore 파일이나 다른 무시 규칙에는 &lt;strong&gt;영향이 없습니다&lt;/strong&gt; !).</target>
        </trans-unit>
        <trans-unit id="ac6e8f6a01875184858c8585102e8f6aa273aee7" translate="yes" xml:space="preserve">
          <source>This is the format defined by the initial version of git, including but not limited to the format of the repository directory, the repository configuration file, and the object and ref storage. Specifying the complete behavior of git is beyond the scope of this document.</source>
          <target state="translated">이것은 리포지토리 디렉토리, 리포지토리 구성 파일 및 객체 및 참조 스토리지의 형식을 포함하여 git의 초기 버전에 의해 정의 된 형식입니다. git의 완전한 동작을 지정하는 것은이 문서의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="53064adeec7c86c12f0de7129be2018180dbdde8" translate="yes" xml:space="preserve">
          <source>This is the instruction format to copy a byte range from the source object. It encodes the offset to copy from and the number of bytes to copy. Offset and size are in little-endian order.</source>
          <target state="translated">소스 객체에서 바이트 범위를 복사하기위한 명령어 형식입니다. 복사 할 오프셋과 복사 할 바이트 수를 인코딩합니다. 오프셋과 크기는 리틀 엔디안 순서입니다.</target>
        </trans-unit>
        <trans-unit id="7c56810b4cb2a212f096564a869dc50ed111eb3c" translate="yes" xml:space="preserve">
          <source>This is the instruction reserved for future expansion.</source>
          <target state="translated">이것은 향후 확장을 위해 예약 된 명령입니다.</target>
        </trans-unit>
        <trans-unit id="2ac15a186ae4c1add6605d649b034295db99bef1" translate="yes" xml:space="preserve">
          <source>This is the instruction to construct target object without the base object. The following data is appended to the target object. The first seven bits of the first octet determines the size of data in bytes. The size must be non-zero.</source>
          <target state="translated">기본 오브젝트없이 대상 오브젝트를 구성하는 지시 사항입니다. 다음 데이터가 대상 개체에 추가됩니다. 첫 번째 옥텟의 처음 7 비트는 바이트 단위의 데이터 크기를 결정합니다. 크기는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="109ca8035c1b87bb820c08a28a9de7b34fde1bb6" translate="yes" xml:space="preserve">
          <source>This is the opposite of &lt;code&gt;ours&lt;/code&gt;; note that, unlike &lt;code&gt;ours&lt;/code&gt;, there is no &lt;code&gt;theirs&lt;/code&gt; merge strategy to confuse this merge option with.</source>
          <target state="translated">이것은 &lt;code&gt;ours&lt;/code&gt; 의 반대입니다 . 달리 점에 유의 &lt;code&gt;ours&lt;/code&gt; , 더이없는 &lt;code&gt;theirs&lt;/code&gt; 이 병합 옵션을 혼동하는 병합 전략.</target>
        </trans-unit>
        <trans-unit id="a470bc42a7932d13fef06a087064186d12eef547" translate="yes" xml:space="preserve">
          <source>This is the preferred method.</source>
          <target state="translated">이것이 선호되는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d5ae5cf60359e7831f40d915d7567f63dc115a19" translate="yes" xml:space="preserve">
          <source>This is the same &lt;code&gt;git read-tree&lt;/code&gt; command we have already seen, but it takes three trees, unlike previous examples. This reads the contents of each tree into different &lt;code&gt;stage&lt;/code&gt; in the index file (the first tree goes to stage 1, the second to stage 2, etc.). After reading three trees into three stages, the paths that are the same in all three stages are &lt;code&gt;collapsed&lt;/code&gt; into stage 0. Also paths that are the same in two of three stages are collapsed into stage 0, taking the SHA-1 from either stage 2 or stage 3, whichever is different from stage 1 (i.e. only one side changed from the common ancestor).</source>
          <target state="translated">이것은 우리가 이미 본 것과 동일한 &lt;code&gt;git read-tree&lt;/code&gt; 명령이지만, 이전 예제와 달리 3 개의 트리가 필요합니다. 인덱스 파일에서 각 트리의 내용을 다른 &lt;code&gt;stage&lt;/code&gt; 로 읽습니다 (첫 번째 트리는 1 단계로, 두 번째는 2 단계로 이동합니다). 세 개의 나무를 세 단계로 읽은 후 세 단계 모두에서 동일한 경로가 단계 0 으로 &lt;code&gt;collapsed&lt;/code&gt; 됩니다. 또한 세 단계 중 두 단계에서 동일한 경로가 단계 0으로 축소되어 두 단계 중 하나에서 SHA-1이 사용됩니다. 또는 1 단계와 다른 단계 3 (즉, 한쪽 만 공통 조상에서 변경됨).</target>
        </trans-unit>
        <trans-unit id="d9a78198f4c718b4aad0f141375d5823cd8e39e3" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;gitdir&lt;/code&gt; except that matching is done case-insensitively (e.g. on case-insensitive file systems)</source>
          <target state="translated">이것은 동일 &lt;code&gt;gitdir&lt;/code&gt; 그 일치를 제외하고 완료를 대문자와 소문자를 구별하지 않고로 (예를 들어, 대소 문자를 구분 파일 시스템)입니다</target>
        </trans-unit>
        <trans-unit id="6d8ef8c3ff85a1d3362ff60dea809d4867db08e2" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;raw&lt;/code&gt; except that no sanity checks on the numeric epoch and local offset are performed. This can be useful when trying to filter or import an existing history with e.g. bogus timezone values.</source>
          <target state="translated">이것은 숫자 epoch 및 로컬 오프셋에 대한 온 전성 검사가 수행되지 않는다는 점을 제외하면 &lt;code&gt;raw&lt;/code&gt; 와 동일 합니다. 이는 가짜 시간대 값과 같은 기존 기록을 필터링하거나 가져 오려고 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d8eaa3e252f616f4794342341d2f4ec065a52c7" translate="yes" xml:space="preserve">
          <source>This is the standard email format as described by RFC 2822.</source>
          <target state="translated">RFC 2822에 설명 된 표준 전자 메일 형식입니다.</target>
        </trans-unit>
        <trans-unit id="b1825adadaae31865a7ba56f02eeaa58bb1a595e" translate="yes" xml:space="preserve">
          <source>This is the standard helper program to use with &lt;code&gt;git merge-index&lt;/code&gt; to resolve a merge after the trivial merge done with &lt;code&gt;git read-tree -m&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git read-tree -m&lt;/code&gt; 으로 사소한 병합 후 병합을 해결하기 위해 &lt;code&gt;git merge-index&lt;/code&gt; 와 함께 사용하는 표준 도우미 프로그램 입니다.</target>
        </trans-unit>
        <trans-unit id="f4605ef17a6ae238fb7ad1359ce2fc3809a170d2" translate="yes" xml:space="preserve">
          <source>This is the state of the index file and the working file after &lt;code&gt;git merge&lt;/code&gt; returns control back to you, leaving the conflicting merge for you to resolve. Notice that the path &lt;code&gt;hello&lt;/code&gt; is still unmerged, and what you see with &lt;code&gt;git diff&lt;/code&gt; at this point is differences since stage 2 (i.e. your version).</source>
          <target state="translated">이것은 &lt;code&gt;git merge&lt;/code&gt; 가 제어권을 다시 돌려 준 후 인덱스 파일과 작업 파일의 상태입니다 . &lt;code&gt;hello&lt;/code&gt; 라는 경로 는 아직 병합되지 않았으며이 시점에서 &lt;code&gt;git diff&lt;/code&gt; 로 보는 것은 2 단계 이후의 차이점 (예 : 버전)입니다.</target>
        </trans-unit>
        <trans-unit id="885013fc19184ff3f87757857452f6badc7e664c" translate="yes" xml:space="preserve">
          <source>This is to emulate &lt;code&gt;git fetch&lt;/code&gt; run on the &lt;code&gt;mothership&lt;/code&gt; using &lt;code&gt;git
push&lt;/code&gt; that is run in the opposite direction in order to integrate the work done on &lt;code&gt;satellite&lt;/code&gt;, and is often necessary when you can only make connection in one way (i.e. satellite can ssh into mothership but mothership cannot initiate connection to satellite because the latter is behind a firewall or does not run sshd).</source>
          <target state="translated">이것은 &lt;code&gt;satellite&lt;/code&gt; 에서 수행 된 작업을 통합하기 위해 반대 방향으로 실행되는 &lt;code&gt;git push&lt;/code&gt; 를 사용 하여 &lt;code&gt;mothership&lt;/code&gt; 에서 &lt;code&gt;git fetch&lt;/code&gt; run 을 에뮬레이트 하는 것이며 , 한 가지 방식으로 만 연결할 수있는 경우 (예 : 위성이 모선으로 ssh 수 있음) 그러나 후자는 방화벽 뒤에 있거나 sshd를 실행하지 않기 때문에 모선은 위성에 연결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a0fbffa526980249cc459b3697ae082d2fb16d12" translate="yes" xml:space="preserve">
          <source>This is to view the changes between two arbitrary &amp;lt;commit&amp;gt;.</source>
          <target state="translated">이것은 임의의 두 &amp;lt;commit&amp;gt; 사이의 변경 사항을 보는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2ccd3734f230a6bccf87e0841ef19acfd1763ec7" translate="yes" xml:space="preserve">
          <source>This is used if &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; does not resolve the correct &lt;code&gt;-kb&lt;/code&gt; mode to use. If true, all unresolved files are sent to the client in mode &lt;code&gt;-kb&lt;/code&gt;. This causes the client to treat them as binary files, which suppresses any newline munging it otherwise might do. Alternatively, if it is set to &quot;guess&quot;, then the contents of the file are examined to decide if it is binary, similar to &lt;code&gt;core.autocrlf&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; 이 올바른 &lt;code&gt;-kb&lt;/code&gt; 모드를 사용할 수없는 경우 에 사용됩니다. true 인 경우, 해결되지 않은 모든 파일이 &lt;code&gt;-kb&lt;/code&gt; 모드에서 클라이언트로 전송됩니다 . 이로 인해 클라이언트는이 파일을 이진 파일로 취급하므로 줄 바꿈이 발생하지 않게 할 수 있습니다. 또는 &quot;추측&quot;으로 설정된 경우 파일의 내용을 검사하여 &lt;code&gt;core.autocrlf&lt;/code&gt; 와 유사하게 이진 파일인지 판별 합니다.</target>
        </trans-unit>
        <trans-unit id="414b7e001678a67515e35206eca5b23ff617a9b6" translate="yes" xml:space="preserve">
          <source>This is used to avoid unnecessary false hits when &lt;code&gt;git diff-files&lt;/code&gt; is run after &lt;code&gt;git read-tree&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git read-tree&lt;/code&gt; 이후에 git &lt;code&gt;git diff-files&lt;/code&gt; 이 실행될 때 불필요한 오타를 피하기 위해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1756049aad8be96bbdbe029ae5b31f810c9534b0" translate="yes" xml:space="preserve">
          <source>This is used to imply --all-progress whenever progress display is activated. Unlike --all-progress this flag doesn&amp;rsquo;t actually force any progress display by itself.</source>
          <target state="translated">진행률 표시가 활성화 될 때마다 --all-progress를 암시하는 데 사용됩니다. --all-progress와 달리이 플래그는 실제로 진행률 표시를 강제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa389947911fb92b7cae5947eac62679e5095362" translate="yes" xml:space="preserve">
          <source>This is used to reorder the filepairs according to the user&amp;rsquo;s (or project&amp;rsquo;s) taste, and is controlled by the -O option to the &lt;code&gt;git diff-*&lt;/code&gt; commands.</source>
          <target state="translated">이는 사용자 (또는 프로젝트의 취향)에 따라 파일 쌍을 재정렬하는 데 사용되며 &lt;code&gt;git diff-*&lt;/code&gt; 명령 의 -O 옵션에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="e4698ff07eb1e8e63a5c87a4e409437aeb77e0b4" translate="yes" xml:space="preserve">
          <source>This is useful because it makes it easy to choose a good commit to test when you want to avoid to test some of them for some reason (they may not compile for example).</source>
          <target state="translated">어떤 이유로 테스트하지 않기를 원할 때 테스트하기 위해 좋은 커밋을 쉽게 선택할 수 있기 때문에 유용합니다 (예 : 컴파일되지 않을 수 있음).</target>
        </trans-unit>
        <trans-unit id="8b37ac2c46d9c49011957ba8051eb182f97c074f" translate="yes" xml:space="preserve">
          <source>This is useful if F and G were flawed in some way, or should not be part of topicA. Note that the argument to --onto and the &amp;lt;upstream&amp;gt; parameter can be any valid commit-ish.</source>
          <target state="translated">이는 F와 G에 어떤 방식으로 결함이 있거나 주제 A의 일부가 아니어야하는 경우에 유용합니다. --onto 및 &amp;lt;upstream&amp;gt; 매개 변수에 대한 인수는 유효한 commit-ish 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5add7a300e88f092e0ef1b21363222f3ece44ad7" translate="yes" xml:space="preserve">
          <source>This is useful if remote side is git:// server accessed over some tunnel.</source>
          <target state="translated">이것은 원격 쪽이 일부 터널을 통해 액세스되는 git : // 서버 인 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d562e00428aacff2db14167eb0ecbc7ee7ea6370" translate="yes" xml:space="preserve">
          <source>This is useful if the branch on which you ran &lt;code&gt;git stash push&lt;/code&gt; has changed enough that &lt;code&gt;git stash apply&lt;/code&gt; fails due to conflicts. Since the stash entry is applied on top of the commit that was HEAD at the time &lt;code&gt;git stash&lt;/code&gt; was run, it restores the originally stashed state with no conflicts.</source>
          <target state="translated">이것은 &lt;code&gt;git stash push&lt;/code&gt; 를 실행 한 브랜치 가 충돌로 인해 &lt;code&gt;git stash apply&lt;/code&gt; 가 실패 할 정도로 충분히 변경된 경우에 유용합니다 . &lt;code&gt;git stash&lt;/code&gt; 가 실행될 때 HEAD였던 커밋 위에 stash 항목이 적용 되므로 충돌없이 원래의 stashed 상태를 복원합니다.</target>
        </trans-unit>
        <trans-unit id="30fcffaf45041b08cc97af9d1fa76a9ba0b33fa3" translate="yes" xml:space="preserve">
          <source>This is useful if you want to begin your message in a discussion thread with comments and suggestions on the message you are responding to, and to conclude it with a patch submission, separating the discussion and the beginning of the proposed commit log message with a scissors line.</source>
          <target state="translated">이것은 응답중인 메시지에 대한 의견과 제안으로 토론 스레드에서 메시지를 시작하고 패치 제출로 토론을 마무리하고 토론과 제안 된 커밋 로그 메시지의 시작을 가위로 분리하려는 경우에 유용합니다. 선.</target>
        </trans-unit>
        <trans-unit id="f93051fa336df47ab5f519702120e3efac9cd277" translate="yes" xml:space="preserve">
          <source>This is useful on systems where lstat() calls are very slow, such as CIFS/Microsoft Windows.</source>
          <target state="translated">CIFS / Microsoft Windows와 같이 lstat () 호출이 매우 느린 시스템에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6b9439a13a0f6c5a19da94d77f92d4a1ee7e5be6" translate="yes" xml:space="preserve">
          <source>This is useful when cherry-picking more than one commits' effect to your index in a row.</source>
          <target state="translated">이것은 인덱스에서 하나 이상의 커밋 효과를 연속적으로 선택하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ccb566ca825959d19feaead9d9434de1315351a7" translate="yes" xml:space="preserve">
          <source>This is useful when reverting more than one commits' effect to your index in a row.</source>
          <target state="translated">이것은 하나 이상의 커밋 효과를 인덱스의 인덱스로 되돌릴 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a6b3b2938023c6383383af34a5efd6428edcf530" translate="yes" xml:space="preserve">
          <source>This is useful when topicB does not depend on topicA.</source>
          <target state="translated">topicB가 topicA에 의존하지 않는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="804a7dc8302db74d34102cb378738f0047ef1777" translate="yes" xml:space="preserve">
          <source>This is usually not what an end user wants to run directly. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; instead.</source>
          <target state="translated">이것은 일반적으로 최종 사용자가 직접 실행하려는 것이 아닙니다. 대신 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="81deedcd021f1608f9f91f70a15e2349e22a39d7" translate="yes" xml:space="preserve">
          <source>This is what &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; generates. Most headers and MIME formatting are ignored.</source>
          <target state="translated">이것이 &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]가&lt;/a&gt; 생성하는 것입니다. 대부분의 헤더와 MIME 형식은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ca6a5c0a1684e36bc50c3e68cfccb9e6ebf59a4b" translate="yes" xml:space="preserve">
          <source>This is what causes Git to track the remote&amp;rsquo;s branches; you may modify or delete these configuration options by editing &lt;code&gt;.git/config&lt;/code&gt; with a text editor. (See the &quot;CONFIGURATION FILE&quot; section of &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details.)</source>
          <target state="translated">이것이 Git이 리모콘의 분기를 추적하게하는 원인입니다. 텍스트 편집기로 &lt;code&gt;.git/config&lt;/code&gt; 를 편집하여 이러한 구성 옵션을 수정하거나 삭제할 수 있습니다 . (자세한 내용은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 &quot;CONFIGURATION FILE&quot;섹션 을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="e49010e0ec73f433e7f19c2db7cbfd7081066732" translate="yes" xml:space="preserve">
          <source>This is why it is a bad idea to just chose the next best unskipped bisection commit when the first one has been skipped.</source>
          <target state="translated">그렇기 때문에 첫 번째 건너 뛰기를 건너 뛰었을 때 다음으로 최고의 건너 뛰기 이분법 커밋을 선택하는 것이 나쁜 생각입니다.</target>
        </trans-unit>
        <trans-unit id="b49b41d6b66c63a0b41c3cd8eb53b02ecb1e28e6" translate="yes" xml:space="preserve">
          <source>This leaves a copy of &lt;code&gt;next&lt;/code&gt; temporarily in FETCH_HEAD, and updates the remote-tracking branch &lt;code&gt;origin/next&lt;/code&gt;. The same can be done by invoking fetch and merge:</source>
          <target state="translated">이렇게하면 FETCH_HEAD에 일시적 으로 &lt;code&gt;next&lt;/code&gt; 복사본이 남고 원격 추적 분기 &lt;code&gt;origin/next&lt;/code&gt; 를 업데이트합니다 . 가져 오기 및 병합을 호출하여 동일한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51722bee7db4c41cee14b92ba092db0dce132718" translate="yes" xml:space="preserve">
          <source>This leaves a copy of &lt;code&gt;next&lt;/code&gt; temporarily in FETCH_HEAD, but does not update any remote-tracking branches. Using remote-tracking branches, the same can be done by invoking fetch and merge:</source>
          <target state="translated">그러면 FETCH_HEAD 에 &lt;code&gt;next&lt;/code&gt; 복사본이 임시로 남지만 원격 추적 분기는 업데이트되지 않습니다. 원격 추적 분기를 사용하면 가져 오기 및 병합을 호출하여 동일한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d3c273456c213d2f0eef245650834ea18d26a16" translate="yes" xml:space="preserve">
          <source>This lets you choose one path out of a &lt;code&gt;status&lt;/code&gt; like selection. After choosing the path, it presents the diff between the index and the working tree file and asks you if you want to stage the change of each hunk. You can select one of the following options and type return:</source>
          <target state="translated">이를 통해 선택 과 같은 &lt;code&gt;status&lt;/code&gt; 하나의 경로를 선택할 수 있습니다 . 경로를 선택한 후 인덱스와 작업 트리 파일 사이의 차이점을 표시하고 각 덩어리의 변경을 스테이징 할 것인지 묻습니다. 다음 옵션 중 하나를 선택하고 return을 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="060b46ed6fd409fbf360157d2f3c13ff3dcd2220" translate="yes" xml:space="preserve">
          <source>This lets you quit without do cleaning.</source>
          <target state="translated">이렇게하면 청소하지 않고 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa41c7db3702739cc1b230bda0b83b675d7b2671" translate="yes" xml:space="preserve">
          <source>This lets you review what will be committed (i.e. between HEAD and index).</source>
          <target state="translated">이를 통해 커밋 할 내용 (예 : HEAD와 인덱스)을 검토 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca3fd0a1256c2900c49910f1d037599eb216d4ff" translate="yes" xml:space="preserve">
          <source>This list should contain the URI of gitweb&amp;rsquo;s standard stylesheet. The default URI of gitweb stylesheet can be set at build time using the &lt;code&gt;GITWEB_CSS&lt;/code&gt; makefile variable. Its default value is &lt;code&gt;static/gitweb.css&lt;/code&gt; (or &lt;code&gt;static/gitweb.min.css&lt;/code&gt; if the &lt;code&gt;CSSMIN&lt;/code&gt; variable is defined, i.e. if CSS minifier is used during build).</source>
          <target state="translated">이리스트는 gitweb 표준 스타일 시트의 URI를 포함해야합니다. gitweb 스타일 시트의 기본 URI는 &lt;code&gt;GITWEB_CSS&lt;/code&gt; makefile 변수를 사용하여 빌드시 설정할 수 있습니다 . 기본값은 &lt;code&gt;static/gitweb.css&lt;/code&gt; (또는 &lt;code&gt;CSSMIN&lt;/code&gt; 변수가 정의 된 경우, 즉 빌드 중에 CSS 축소 &lt;code&gt;static/gitweb.min.css&lt;/code&gt; 경우 static / gitweb.min.css )입니다.</target>
        </trans-unit>
        <trans-unit id="87db555786bcad0bd342abfeced795a76cdcb852" translate="yes" xml:space="preserve">
          <source>This lists the commits reachable from the previous version of the &lt;code&gt;master&lt;/code&gt; branch head. This syntax can be used with any Git command that accepts a commit, not just with &lt;code&gt;git log&lt;/code&gt;. Some other examples:</source>
          <target state="translated">이것은 이전 버전의 &lt;code&gt;master&lt;/code&gt; 브랜치 헤드 에서 도달 할 수있는 커밋을 나열합니다 . 이 구문은 &lt;code&gt;git log&lt;/code&gt; 뿐만 아니라 커밋을 수락하는 모든 Git 명령과 함께 사용할 수 있습니다 . 다른 예 :</target>
        </trans-unit>
        <trans-unit id="9d19ff56a7106ea2437dd5210773dc60fd2828eb" translate="yes" xml:space="preserve">
          <source>This looks up the &amp;lt;file&amp;gt;(s) in the index and, if there are any merge entries, passes the SHA-1 hash for those files as arguments 1, 2, 3 (empty argument if no file), and &amp;lt;file&amp;gt; as argument 4. File modes for the three files are passed as arguments 5, 6 and 7.</source>
          <target state="translated">인덱스에서 &amp;lt;파일&amp;gt;을 찾고 병합 항목이있는 경우 해당 파일의 SHA-1 해시를 인수 1, 2, 3 (파일이없는 경우 빈 인수) 및 &amp;lt;파일&amp;gt;로 전달합니다. 세 파일의 파일 모드는 인수 5, 6 및 7로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="6790f45ac4b6ed7e77775e3a5dfba68fc876105d" translate="yes" xml:space="preserve">
          <source>This makes a commit that records the modification to &lt;code&gt;Makefile&lt;/code&gt;. The changes staged for &lt;code&gt;hello.c&lt;/code&gt; and &lt;code&gt;hello.h&lt;/code&gt; are not included in the resulting commit. However, their changes are not lost &amp;mdash; they are still staged and merely held back. After the above sequence, if you do:</source>
          <target state="translated">이렇게하면 수정 사항을 &lt;code&gt;Makefile&lt;/code&gt; 에 기록하는 커미트가 작성 됩니다. &lt;code&gt;hello.c&lt;/code&gt; 및 &lt;code&gt;hello.h&lt;/code&gt; 에 대해 준비된 변경 사항 은 결과 커밋에 포함되지 않습니다. 그러나 변경 사항이 손실되지는 않습니다. 여전히 단계적이며 보류됩니다. 위의 순서 후에 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c23316330a20f8d3e00d74e273bc6ee3d02efbd7" translate="yes" xml:space="preserve">
          <source>This makes a new branch called &lt;code&gt;other&lt;/code&gt; from &lt;code&gt;master~5..master&lt;/code&gt; (i.e. if &lt;code&gt;master&lt;/code&gt; has linear history, it will take the last 5 commits).</source>
          <target state="translated">이것은 &lt;code&gt;master~5..master&lt;/code&gt; 에서 &lt;code&gt;other&lt;/code&gt; 라는 새로운 브랜치를 만듭니다 (즉, &lt;code&gt;master&lt;/code&gt; 에 선형 히스토리가있는 경우 마지막 5 개의 커밋이 필요함 ).</target>
        </trans-unit>
        <trans-unit id="b0ade35fb815795f98a8b6354752858acd9e1cfa" translate="yes" xml:space="preserve">
          <source>This makes sure that only the key/value pair for kernel.org is replaced.</source>
          <target state="translated">이를 통해 kernel.org의 키 / 값 쌍만 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="2d726c732ca5f310160366fecc16a8d1ede4f94c" translate="yes" xml:space="preserve">
          <source>This manual describes the convention used throughout Git CLI.</source>
          <target state="translated">이 매뉴얼은 Git CLI 전체에서 사용되는 규칙을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="40982f6c18ca56554ec412b18ace4f012d6c51fa" translate="yes" xml:space="preserve">
          <source>This manual is designed to be readable by someone with basic UNIX command-line skills, but no previous knowledge of Git.</source>
          <target state="translated">이 매뉴얼은 기본 UNIX 명령 줄 기술을 가지고 있지만 Git에 대한 사전 지식이없는 사람이 읽을 수 있도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="1b4c4400f56ace6af78ca50c928fe7f5cfe13be6" translate="yes" xml:space="preserve">
          <source>This manual page describes only the most frequently used options.</source>
          <target state="translated">이 매뉴얼 페이지는 가장 자주 사용되는 옵션에 대해서만 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c74c8f67468f674a4bbb6cadbdb326520214aafb" translate="yes" xml:space="preserve">
          <source>This manual page describes only the most frequently used options. See &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; for a complete list.</source>
          <target state="translated">이 매뉴얼 페이지는 가장 자주 사용되는 옵션에 대해서만 설명합니다. 전체 목록 은 &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="78fbc8bf0be13ddc4f9bce27ee4dc19783022a2b" translate="yes" xml:space="preserve">
          <source>This means &quot;show everything that is reachable from either one, but exclude anything that is reachable from both of them&quot;.</source>
          <target state="translated">이것은 &quot;둘 중 하나에서 도달 할 수있는 모든 것을 표시하지만 둘 다에서 도달 할 수있는 것은 제외&quot;를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9f4c07f14694007bf95dcdb96bbfc3991db01ef3" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;git reset &amp;lt;pathspec&amp;gt;&lt;/code&gt; is the opposite of &lt;code&gt;git add
&amp;lt;pathspec&amp;gt;&lt;/code&gt;. This command is equivalent to &lt;code&gt;git restore [--source=&amp;lt;tree-ish&amp;gt;] --staged &amp;lt;pathspec&amp;gt;...&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git reset &amp;lt;pathspec&amp;gt;&lt;/code&gt; 이 &lt;code&gt;git add &amp;lt;pathspec&amp;gt;&lt;/code&gt; 과 반대되는 것을 의미합니다 . 이 명령은 &lt;code&gt;git restore [--source=&amp;lt;tree-ish&amp;gt;] --staged &amp;lt;pathspec&amp;gt;...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="138908f8222de2b4daf75b57b97dc896b1845167" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;git reset -p&lt;/code&gt; is the opposite of &lt;code&gt;git add -p&lt;/code&gt;, i.e. you can use it to selectively reset hunks. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">즉, &lt;code&gt;git reset -p&lt;/code&gt; 는 &lt;code&gt;git add -p&lt;/code&gt; 와 반대입니다 . 즉,이를 사용하여 덩어리를 선택적으로 재설정 할 수 있습니다. &lt;code&gt;--patch&lt;/code&gt; 모드 작동 방법을 알아 보려면 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 의 &quot;대화식 모드&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c231d7cedbd657513f91f60869397c2bef2f37d" translate="yes" xml:space="preserve">
          <source>This means that it is often &quot;cheaper&quot; if QA people or end users can do it.</source>
          <target state="translated">이는 품질 보증 담당자 나 최종 사용자가 할 수 있다면 종종 &quot;더 저렴&quot;하다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0ff1dc064f7e1f4d0872498ac05a21ade168adc9" translate="yes" xml:space="preserve">
          <source>This means that test suites are good to prevent some bugs from being committed and they are also quite good to tell you that you have some bugs. But they are not so good to tell you where some bugs have been introduced. To tell you that efficiently, git bisect is needed.</source>
          <target state="translated">즉, 테스트 스위트는 일부 버그가 커밋되는 것을 방지하고 버그가 있음을 알려주는 것도 좋습니다. 그러나 버그가 어디에서 발생했는지 알려주는 것은 좋지 않습니다. 효율적으로 말하면 git bisect가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="388b9571e5f1264e3be3a08ce2827efedebdef31" translate="yes" xml:space="preserve">
          <source>This means that the best bisection commits are the commits where the following function is maximum:</source>
          <target state="translated">이는 최상의 bisection 커밋이 다음 함수가 최대 인 커밋임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="597961da0012b9cd684792dccd1c7471e5687e9f" translate="yes" xml:space="preserve">
          <source>This means that the trimmed &amp;lt;token&amp;gt; and &amp;lt;value&amp;gt; will be separated by &lt;code&gt;': '&lt;/code&gt; (one colon followed by one space).</source>
          <target state="translated">이것은 잘린 &amp;lt;token&amp;gt;과 &amp;lt;value&amp;gt;가 &lt;code&gt;': '&lt;/code&gt; (한 콜론 뒤에 하나의 공백) 으로 분리됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="38ea5711a664516b71bd0eeea932fd8ac8d7c412" translate="yes" xml:space="preserve">
          <source>This means that we get rid of the uninteresting commits in the DAG.</source>
          <target state="translated">이것은 우리가 DAG에서 흥미없는 커밋을 제거한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2454a8b57cbe01726a67b284a671cd468ecfe3a7" translate="yes" xml:space="preserve">
          <source>This means that you can do</source>
          <target state="translated">이것은 당신이 할 수 있음을 의미</target>
        </trans-unit>
        <trans-unit id="4bfb7f09c9f4811c3630d40fb2caf5f3310e564e" translate="yes" xml:space="preserve">
          <source>This means that you can use &lt;code&gt;git checkout -p&lt;/code&gt; to selectively discard edits from your current working tree. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">이것은 &lt;code&gt;git checkout -p&lt;/code&gt; 를 사용 하여 현재 작업 트리에서 편집 내용을 선택적으로 버릴 수 있음을 의미합니다 . &lt;code&gt;--patch&lt;/code&gt; 모드 작동 방법을 알아 보려면 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 의 &quot;대화식 모드&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2db1fd51873ef2a0afca87fc61387f5a8891e2a5" translate="yes" xml:space="preserve">
          <source>This merges the changes from Bob&amp;rsquo;s &quot;master&quot; branch into Alice&amp;rsquo;s current branch. If Alice has made her own changes in the meantime, then she may need to manually fix any conflicts.</source>
          <target state="translated">이것은 Bob의 &quot;마스터&quot;브랜치에서 Alice의 현재 브랜치로 변경 사항을 병합합니다. Alice가 그 동안 자체적으로 변경 한 경우 충돌을 수동으로 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cff3569519105ed116111cf73b4d626e89a75fc2" translate="yes" xml:space="preserve">
          <source>This merges the file listing in the directory cache index with the actual working directory list, and shows different combinations of the two.</source>
          <target state="translated">그러면 디렉토리 캐시 색인의 파일 목록이 실제 작업 디렉토리 목록과 병합되고이 둘의 다른 조합이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e550f0e6cba8953c27a9638529775caa0627f8ed" translate="yes" xml:space="preserve">
          <source>This might not be what you expect, i.e. you want to prune remote &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;, but also explicitly fetch tags from it, so when you fetch from it you delete all your local tags, most of which may not have come from the &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; remote in the first place.</source>
          <target state="translated">이것은 예상 한 것이 아닐 수도 있습니다. 예를 들어, 원격 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 을 프룬하고 명시 적으로 태그를 페치하려고합니다. 페치 할 때 로컬 태그를 모두 삭제하면 대부분 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 에서 비롯되었을 수 있습니다. &amp;gt; 처음에 원격.</target>
        </trans-unit>
        <trans-unit id="c165a1bf0e23a30271149315bd9959512cec8cbc" translate="yes" xml:space="preserve">
          <source>This mode differs from the default in one point: always follow all parents of a merge, even if it is TREESAME to one of them. Even if more than one side of the merge has commits that are included, this does not imply that the merge itself is! In the example, we get</source>
          <target state="translated">이 모드는 한 가지 점에서 기본값과 다릅니다. 병합 중 하나 인 경우에도 항상 병합의 모든 부모를 따르십시오. 병합의 둘 이상의 측면에 포함 된 커밋이 있더라도 병합 자체가 있음을 의미하지는 않습니다! 이 예에서 우리는</target>
        </trans-unit>
        <trans-unit id="06118fd3f101fa40f7bcb707d4305013c9a74e7d" translate="yes" xml:space="preserve">
          <source>This mode has become the default in Git 2.0.</source>
          <target state="translated">이 모드는 Git 2.0에서 기본값이되었습니다.</target>
        </trans-unit>
        <trans-unit id="9c35450959e8c97cb733c60205966cdb68e529c7" translate="yes" xml:space="preserve">
          <source>This mode is designed for repositories with very large indexes, and aims at reducing the time it takes to repeatedly write these indexes.</source>
          <target state="translated">이 모드는 인덱스가 매우 큰 리포지토리 용으로 설계되었으며 이러한 인덱스를 반복적으로 작성하는 데 걸리는 시간을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="660380648a3de0733323135a33a60c0126cae6f8" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;export&lt;/code&gt; capability, instructing Git to dump the internal marks table to &amp;lt;file&amp;gt; when complete. For details, read up on &lt;code&gt;--export-marks=&amp;lt;file&amp;gt;&lt;/code&gt; in &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export[1]&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;export&lt;/code&gt; 기능을 수정하여 Git에게 내부 마크 테이블을 &amp;lt;file&amp;gt;에 덤프하도록 지시합니다. 자세한 내용 은 &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export [1]의 &lt;/a&gt; &lt;code&gt;--export-marks=&amp;lt;file&amp;gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="59a5d5693433000c28979c8002984ee295ddd735" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;export&lt;/code&gt; capability, instructing Git to load the marks specified in &amp;lt;file&amp;gt; before processing any input. For details, read up on &lt;code&gt;--import-marks=&amp;lt;file&amp;gt;&lt;/code&gt; in &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export[1]&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;export&lt;/code&gt; 기능을 수정하여 Git에게 입력을 처리하기 전에 &amp;lt;file&amp;gt;에 지정된 마크를로드하도록 지시합니다. 자세한 내용 은 &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export [1]&lt;/a&gt; 에서 &lt;code&gt;--import-marks=&amp;lt;file&amp;gt;&lt;/code&gt; 을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="29cca50076d9ab0c1672949be9f5cf285333ce65" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;export&lt;/code&gt; capability, instructing Git to pass &lt;code&gt;--signed-tags=verbatim&lt;/code&gt; to &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export[1]&lt;/a&gt;. In the absence of this capability, Git will use &lt;code&gt;--signed-tags=warn-strip&lt;/code&gt;.</source>
          <target state="translated">이것은 Git에게 &lt;code&gt;--signed-tags=verbatim&lt;/code&gt; 을 &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export [1]&lt;/a&gt; 로 전달하도록 지시 하는 &lt;code&gt;export&lt;/code&gt; 기능을 수정합니다 . 이 기능이 없으면 Git은 &lt;code&gt;--signed-tags=warn-strip&lt;/code&gt; 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="1cd76e4b36f80f26235450d81c7340212de49a9e" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;import&lt;/code&gt; capability. The fast-import commands &lt;code&gt;cat-blob&lt;/code&gt; and &lt;code&gt;ls&lt;/code&gt; can be used by remote-helpers to retrieve information about blobs and trees that already exist in fast-import&amp;rsquo;s memory. This requires a channel from fast-import to the remote-helper. If it is advertised in addition to &quot;import&quot;, Git establishes a pipe from fast-import to the remote-helper&amp;rsquo;s stdin. It follows that Git and fast-import are both connected to the remote-helper&amp;rsquo;s stdin. Because Git can send multiple commands to the remote-helper it is required that helpers that use &lt;code&gt;bidi-import&lt;/code&gt; buffer all &lt;code&gt;import&lt;/code&gt; commands of a batch before sending data to fast-import. This is to prevent mixing commands and fast-import responses on the helper&amp;rsquo;s stdin.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 기능 이 수정되었습니다 . &lt;code&gt;cat-blob&lt;/code&gt; 및 &lt;code&gt;ls&lt;/code&gt; 빠른 가져 오기 명령 은 원격 도우미가 빠른 가져 오기의 메모리에 이미 존재하는 Blob 및 트리에 대한 정보를 검색하는 데 사용할 수 있습니다. 빠른 가져 오기에서 원격 헬퍼로의 채널이 필요합니다. &quot;가져 오기&quot;와 함께 광고되면 Git은 빠른 가져 오기에서 원격 헬퍼의 stdin으로 파이프를 설정합니다. Git과 fast-import는 모두 원격 헬퍼의 stdin에 연결되어 있습니다. Git은 원격 도우미에 여러 명령을 보낼 수 있기 때문에 &lt;code&gt;bidi-import&lt;/code&gt; 버퍼 를 사용하는 도우미는 모두 &lt;code&gt;import&lt;/code&gt; 오기 가 필요합니다빠른 가져 오기로 데이터를 보내기 전에 배치 명령. 이것은 헬퍼의 stdin에서 믹싱 명령과 빠른 가져 오기 응답을 방지하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="18b230f7b58b67f5f52143b1696b5514cecb3bd1" translate="yes" xml:space="preserve">
          <source>This operation is safe even if Alice has uncommitted local changes. The range notation &quot;HEAD..FETCH_HEAD&quot; means &quot;show everything that is reachable from the FETCH_HEAD but exclude anything that is reachable from HEAD&quot;. Alice already knows everything that leads to her current state (HEAD), and reviews what Bob has in his state (FETCH_HEAD) that she has not seen with this command.</source>
          <target state="translated">Alice가 커밋되지 않은 로컬 변경 사항을 가지고 있어도이 작업은 안전합니다. 범위 표기법 &quot;HEAD..FETCH_HEAD&quot;는 &quot;FETCH_HEAD에서 도달 할 수 있지만 HEAD에서 도달 할 수있는 것은 제외&quot;를 의미합니다. Alice는 현재 상태 (HEAD)로 이어지는 모든 것을 이미 알고 있으며 Bob이이 명령으로 보지 못한 상태 (FETCH_HEAD)에있는 것을 검토합니다.</target>
        </trans-unit>
        <trans-unit id="4d6058894e90e81912f089323abaddf6ff7286d2" translate="yes" xml:space="preserve">
          <source>This option affects options that expect path name like &lt;code&gt;--git-dir&lt;/code&gt; and &lt;code&gt;--work-tree&lt;/code&gt; in that their interpretations of the path names would be made relative to the working directory caused by the &lt;code&gt;-C&lt;/code&gt; option. For example the following invocations are equivalent:</source>
          <target state="translated">이 옵션은 경로 이름 에 대한 해석이 &lt;code&gt;-C&lt;/code&gt; 옵션 에 의해 발생하는 작업 디렉토리를 기준으로 이루어 &lt;code&gt;--git-dir&lt;/code&gt; 및 &lt;code&gt;--work-tree&lt;/code&gt; 와 같은 경로 이름이 필요한 옵션에 영향을줍니다 . 예를 들어 다음 호출은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="2b42f3dc9742d00737d912066dfd2008f4af0874" translate="yes" xml:space="preserve">
          <source>This option allows you to say that you expect the history you are updating is what you rebased and want to replace. If the remote ref still points at the commit you specified, you can be sure that no other people did anything to the ref. It is like taking a &quot;lease&quot; on the ref without explicitly locking it, and the remote ref is updated only if the &quot;lease&quot; is still valid.</source>
          <target state="translated">이 옵션을 사용하면 업데이트중인 기록이 다시 기반으로하고 교체하려는 것으로 예상 할 수 있습니다. 원격 심판이 여전히 지정한 커밋을 가리키는 경우 다른 사람이 심판에게 아무것도하지 않았 음을 확신 할 수 있습니다. 그것은 명시 적으로 그것을 잠그지 않고 심판에 &quot;임대&quot;를 취하는 것과 같으며, 원격 심판은 &quot;임대&quot;가 여전히 유효한 경우에만 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="a3080455c3c310acd65dd25e9f3c439906791e33" translate="yes" xml:space="preserve">
          <source>This option bypasses the pre-commit and commit-msg hooks. See also &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 사전 커미트 및 commit-msg 후크를 무시합니다. &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae0cb95b3299088da58c88ea10fd24e68d20bac1" translate="yes" xml:space="preserve">
          <source>This option bypasses the pre-merge and commit-msg hooks. See also &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 pre-merge 및 commit-msg 후크를 무시합니다. &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="22c10b3b137f37c4d219034c9b73126392cd066c" translate="yes" xml:space="preserve">
          <source>This option bypasses the pre-rebase hook. See also &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 사전 재 연결 후크를 무시합니다. &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e7eb09891c6b3b929ffed676724fa916ce9b73e" translate="yes" xml:space="preserve">
          <source>This option can be either set to a boolean value or to &lt;code&gt;on-demand&lt;/code&gt;. Setting it to a boolean changes the behavior of fetch and pull to unconditionally recurse into submodules when set to true or to not recurse at all when set to false. When set to &lt;code&gt;on-demand&lt;/code&gt; (the default value), fetch and pull will only recurse into a populated submodule when its superproject retrieves a commit that updates the submodule&amp;rsquo;s reference.</source>
          <target state="translated">이 옵션은 부울 값 또는 &lt;code&gt;on-demand&lt;/code&gt; 설정할 수 있습니다 . 이를 부울로 설정하면 페치 및 풀 동작이 변경되어 true로 설정 될 때 서브 모듈로 무조건 재귀로 돌아가거나 false로 설정 될 때 전혀 재귀하지 않습니다. 시에 설정 &lt;code&gt;on-demand&lt;/code&gt; (기본값), 가져 오기 및 풀은 같이 Recurse 채워진 서브 모듈로의 superproject가 검색 할 때이 서브 모듈의 참조가 갱신 사항을 확정합니다.</target>
        </trans-unit>
        <trans-unit id="5d7a21f2665910c78fd7ff132552ce53899e84c0" translate="yes" xml:space="preserve">
          <source>This option can be used along with &lt;code&gt;--bisect-vars&lt;/code&gt;, in this case, after all the sorted commit objects, there will be the same text as if &lt;code&gt;--bisect-vars&lt;/code&gt; had been used alone.</source>
          <target state="translated">이 옵션은 &lt;code&gt;--bisect-vars&lt;/code&gt; 와 함께 사용할 수 있습니다 .이 경우 정렬 된 모든 커밋 객체 후에 &lt;code&gt;--bisect-vars&lt;/code&gt; 가 단독으로 사용 된 것과 동일한 텍스트가 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="93ff5c11faab29c493dcd0eb330b2a514a09e43b" translate="yes" xml:space="preserve">
          <source>This option can be used several times to provide several detection regexes.</source>
          <target state="translated">이 옵션은 여러 번 탐지 정규식을 제공하기 위해 여러 번 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9be17765d99ef763e2665079651c5e7b4e1ceec" translate="yes" xml:space="preserve">
          <source>This option can be used to control recursive fetching of this submodule. If this option is also present in the submodules entry in .git/config of the superproject, the setting there will override the one found in .gitmodules. Both settings can be overridden on the command line by using the &quot;--[no-]recurse-submodules&quot; option to &quot;git fetch&quot; and &quot;git pull&quot;.</source>
          <target state="translated">이 옵션은이 서브 모듈의 재귀 페치를 제어하는 ​​데 사용할 수 있습니다. 이 옵션이 수퍼 프로젝트의 .git / config에있는 서브 모듈 항목에도있는 경우, 설정은 .gitmodules에있는 설정보다 우선합니다. 명령 행에서 &quot;-[no-] recurse-submodules&quot;옵션을 사용하여 &quot;git fetch&quot;및 &quot;git pull&quot;을 사용하여 두 설정을 모두 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4813ba4c4b012e94932c2c7e77e5d37eb750ee7d" translate="yes" xml:space="preserve">
          <source>This option can be used to control recursive fetching of this submodule. It can be overridden by using the --[no-]recurse-submodules command-line option to &quot;git fetch&quot; and &quot;git pull&quot;. This setting will override that from in the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file.</source>
          <target state="translated">이 옵션은이 서브 모듈의 재귀 페치를 제어하는 ​​데 사용할 수 있습니다. -[no-] recurse-submodules 명령 줄 옵션을 사용하여 &quot;git fetch&quot;및 &quot;git pull&quot;을 재정의 할 수 있습니다. 이 설정은 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 파일의 설정을 무시 합니다.</target>
        </trans-unit>
        <trans-unit id="dc1c2b92ebab0226490f8de8ccd94e6df6f7955b" translate="yes" xml:space="preserve">
          <source>This option can be used to separate command-line options from the list of files, (useful when filenames might be mistaken for command-line options).</source>
          <target state="translated">이 옵션을 사용하면 파일 목록과 명령 줄 옵션을 구분할 수 있습니다 (파일 이름이 명령 줄 옵션으로 잘못 알려진 경우에 유용합니다).</target>
        </trans-unit>
        <trans-unit id="792e2c6acea003d2f54070521de0f6b1fb530a29" translate="yes" xml:space="preserve">
          <source>This option can be used to specify a shell command that will be called to automatically add or modify a trailer with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">이 옵션은 지정된 &amp;lt;토큰&amp;gt;으로 트레일러를 자동으로 추가하거나 수정하기 위해 호출 될 쉘 명령을 지정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3870831de784b5f9a3b27254aee6ab6f7a036b72" translate="yes" xml:space="preserve">
          <source>This option can only be used for one-shot imports as &lt;code&gt;git svn&lt;/code&gt; will not be able to fetch again without metadata. Additionally, if you lose your &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; files, &lt;code&gt;git svn&lt;/code&gt; will not be able to rebuild them.</source>
          <target state="translated">&lt;code&gt;git svn&lt;/code&gt; 은 메타 데이터없이 다시 가져올 수 없으므로이 옵션은 원샷 가져 오기에만 사용할 수 있습니다 . 또한 &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; 파일 을 잃어 버리면 &lt;code&gt;git svn&lt;/code&gt; 에서 파일 을 다시 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7745929fdc4d071dfa2f069450065a35fb03a357" translate="yes" xml:space="preserve">
          <source>This option can only be used together with --dry-run. By using this option the user can check if any of the given files would be ignored, no matter if they are already present in the work tree or not.</source>
          <target state="translated">이 옵션은 --dry-run과 함께 만 사용할 수 있습니다. 이 옵션을 사용하면 사용자는 파일이 이미 작업 트리에 있는지 여부에 관계없이 주어진 파일이 무시되는지 여부를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cd2090b6cd931e9fb6990b800f11805da77a460" translate="yes" xml:space="preserve">
          <source>This option cannot (currently) be used unless &lt;code&gt;--batch&lt;/code&gt; or &lt;code&gt;--batch-check&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;--batch&lt;/code&gt; 또는 &lt;code&gt;--batch-check&lt;/code&gt; 를 사용하지 않으면이 옵션을 현재 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0bf834f696ae0c2ea43d0e8666eab0cbfdcf28f1" translate="yes" xml:space="preserve">
          <source>This option cannot be used with --stdin.</source>
          <target state="translated">이 옵션은 --stdin과 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bae4bbd32a33e184bd257e0ab24166cfba6c0a7d" translate="yes" xml:space="preserve">
          <source>This option changes the size of the buffer that Git uses when pushing data to a remote over HTTP or HTTPS. If the data is larger than this size, libcurl, which handles the HTTP support for Git, will use chunked transfer encoding since it isn&amp;rsquo;t known ahead of time what the size of the pushed data will be.</source>
          <target state="translated">이 옵션은 HTTP 또는 HTTPS를 통해 데이터를 원격으로 푸시 할 때 Git에서 사용하는 버퍼의 크기를 변경합니다. 데이터가이 크기보다 크면 Git에 대한 HTTP 지원을 처리하는 libcurl은 푸시 된 데이터의 크기를 미리 알 수 없기 때문에 청크 전송 인코딩을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="882762ef26e2279478bc78603a1e7faf56dec8c3" translate="yes" xml:space="preserve">
          <source>This option controls if and under what conditions new commits of populated submodules should be fetched too. It can be used as a boolean option to completely disable recursion when set to &lt;code&gt;no&lt;/code&gt; or to unconditionally recurse into all populated submodules when set to &lt;code&gt;yes&lt;/code&gt;, which is the default when this option is used without any value. Use &lt;code&gt;on-demand&lt;/code&gt; to only recurse into a populated submodule when the superproject retrieves a commit that updates the submodule&amp;rsquo;s reference to a commit that isn&amp;rsquo;t already in the local submodule clone.</source>
          <target state="translated">이 옵션은 채워진 하위 모듈의 새 커밋도 가져와야하는 조건과 조건을 제어합니다. &lt;code&gt;no&lt;/code&gt; 로 설정되면 재귀를 완전히 비활성화 하거나 &lt;code&gt;yes&lt;/code&gt; 로 설정하면 채워진 모든 하위 모듈에 무조건 재귀를 수행하기 위해 부울 옵션으로 사용할 수 있습니다. 이 옵션은 값없이 사용되는 경우의 기본값입니다. 수퍼 프로젝트가 서브 모듈의 참조를 이미 로컬 서브 모듈 클론에없는 커밋으로 업데이트하는 커밋을 검색 할 때 &lt;code&gt;on-demand&lt;/code&gt; 서브 모듈로만 재귀를 보내려면 온 디맨드 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="402f84a0bd330441925cd57436b80c9379eb3ea0" translate="yes" xml:space="preserve">
          <source>This option controls if and under what conditions new commits of populated submodules should be fetched too. It can be used as a boolean option to completely disable recursion when set to &lt;code&gt;no&lt;/code&gt; or to unconditionally recurse into all populated submodules when set to &lt;code&gt;yes&lt;/code&gt;, which is the default when this option is used without any value. Use &lt;code&gt;on-demand&lt;/code&gt; to only recurse into a populated submodule when the superproject retrieves a commit that updates the submodule&amp;rsquo;s reference to a commit that isn&amp;rsquo;t already in the local submodule clone. By default, &lt;code&gt;on-demand&lt;/code&gt; is used, unless &lt;code&gt;fetch.recurseSubmodules&lt;/code&gt; is set (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">이 옵션은 채워진 하위 모듈의 새 커밋도 가져와야하는지 여부와 조건을 제어합니다. &lt;code&gt;no&lt;/code&gt; 로 설정하면 재귀를 완전히 비활성화 하거나 ,이 옵션이 값없이 사용되는 경우 기본값 인 &lt;code&gt;yes&lt;/code&gt; 로 설정하면 채워진 모든 하위 모듈로 무조건 재귀 하는 부울 옵션으로 사용할 수 있습니다 . 수퍼 프로젝트가 로컬 서브 모듈 복제본에 아직없는 커밋에 대한 서브 모듈의 참조를 업데이트하는 커밋을 검색 할 때만 &lt;code&gt;on-demand&lt;/code&gt; 을 사용 하여 채워진 서브 모듈로 재귀합니다. &lt;code&gt;fetch.recurseSubmodules&lt;/code&gt; 가 설정되어 있지 않으면 기본적으로 &lt;code&gt;on-demand&lt;/code&gt; 가 사용 됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="69bffdffaf64305a520ea61fd7a4110a4c5bf981" translate="yes" xml:space="preserve">
          <source>This option controls if new commits of all populated submodules should be fetched and updated, too (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;).</source>
          <target state="translated">이 옵션은 채워진 모든 하위 모듈의 새 커밋을 가져 와서 업데이트할지 여부를 제어합니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 및 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8666b4e7aa19effada757acd8dc6a366796aecc5" translate="yes" xml:space="preserve">
          <source>This option controls if new commits of populated submodules should be fetched, and if the working trees of active submodules should be updated, too (see &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;, &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;).</source>
          <target state="translated">이 옵션은 채워진 하위 모듈의 새 커밋을 가져와야하는지, 활성 하위 모듈의 작업 트리도 업데이트해야하는지 여부를 제어합니다 ( &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; , &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 및 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="99e48667fde8ec2632838629a22c3bc7308b3012" translate="yes" xml:space="preserve">
          <source>This option controls whether &lt;code&gt;git fetch&lt;/code&gt; (and the underlying fetch in &lt;code&gt;git pull&lt;/code&gt;) will recursively fetch into populated submodules. This option can be set either to a boolean value or to &lt;code&gt;on-demand&lt;/code&gt;. Setting it to a boolean changes the behavior of fetch and pull to recurse unconditionally into submodules when set to true or to not recurse at all when set to false. When set to &lt;code&gt;on-demand&lt;/code&gt;, fetch and pull will only recurse into a populated submodule when its superproject retrieves a commit that updates the submodule&amp;rsquo;s reference. Defaults to &lt;code&gt;on-demand&lt;/code&gt;, or to the value of &lt;code&gt;submodule.recurse&lt;/code&gt; if set.</source>
          <target state="translated">이 옵션은 &lt;code&gt;git fetch&lt;/code&gt; (및 &lt;code&gt;git pull&lt;/code&gt; 의 기본 가져 오기 )가 채워진 하위 모듈로 재귀 적으로 가져올 지 여부를 제어합니다 . 이 옵션은 부울 값 또는 &lt;code&gt;on-demand&lt;/code&gt; 로 설정할 수 있습니다 . 부울로 설정하면 fetch 및 pull의 동작이 true로 설정되면 무조건 하위 모듈로 재귀하거나 false로 설정하면 전혀 재귀하지 않습니다. &lt;code&gt;on-demand&lt;/code&gt; 로 설정되면 수퍼 프로젝트가 하위 모듈의 참조를 업데이트하는 커밋을 검색 할 때만 채워진 하위 모듈로 가져 오기 및 가져 오기가 반복됩니다. 기본값은 &lt;code&gt;on-demand&lt;/code&gt; 또는 설정된 경우 &lt;code&gt;submodule.recurse&lt;/code&gt; 값입니다 .</target>
        </trans-unit>
        <trans-unit id="30828ff428cc76245c5c17e5cbd61f4d3413d1c5" translate="yes" xml:space="preserve">
          <source>This option determines how the commit message will be cleaned up before being passed on to the commit machinery. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more details. In particular, if the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is given a value of &lt;code&gt;scissors&lt;/code&gt;, scissors will be appended to &lt;code&gt;MERGE_MSG&lt;/code&gt; before being passed on in the case of a conflict.</source>
          <target state="translated">이 옵션은 커미트 기계로 전달되기 전에 커미트 메시지를 정리하는 방법을 결정합니다. 자세한 내용은 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 을 참조하십시오. 특히 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 에 &lt;code&gt;scissors&lt;/code&gt; 값을 지정 하면 충돌시 가위가 전달되기 전에 &lt;code&gt;MERGE_MSG&lt;/code&gt; 에 가위가 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="286a93d0042817a6190102b1bfcb5df866579bac" translate="yes" xml:space="preserve">
          <source>This option determines how the merge message will be cleaned up before committing. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more details. In addition, if the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is given a value of &lt;code&gt;scissors&lt;/code&gt;, scissors will be appended to &lt;code&gt;MERGE_MSG&lt;/code&gt; before being passed on to the commit machinery in the case of a merge conflict.</source>
          <target state="translated">이 옵션은 커밋하기 전에 병합 메시지를 정리하는 방법을 결정합니다. 자세한 내용은 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 을 참조하십시오. 또한 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 값에 &lt;code&gt;scissors&lt;/code&gt; 가 지정 되면 병합 충돌시 커밋 기계로 전달되기 전에 가위가 &lt;code&gt;MERGE_MSG&lt;/code&gt; 에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="4d1960d5d8472d2a194e5ec10acd8959326f748a" translate="yes" xml:space="preserve">
          <source>This option determines how the supplied commit message should be cleaned up before committing. The &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; can be &lt;code&gt;strip&lt;/code&gt;, &lt;code&gt;whitespace&lt;/code&gt;, &lt;code&gt;verbatim&lt;/code&gt;, &lt;code&gt;scissors&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 커밋하기 전에 제공된 커밋 메시지를 정리하는 방법을 결정합니다. &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 가 될 수 &lt;code&gt;strip&lt;/code&gt; , &lt;code&gt;whitespace&lt;/code&gt; , &lt;code&gt;verbatim&lt;/code&gt; , &lt;code&gt;scissors&lt;/code&gt; 또는 &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5dab8a93409f72b36d8b46ab64625d688725721" translate="yes" xml:space="preserve">
          <source>This option does not (currently) work correctly when an object in the index is specified (e.g. &lt;code&gt;:link&lt;/code&gt; instead of &lt;code&gt;HEAD:link&lt;/code&gt;) rather than one in the tree.</source>
          <target state="translated">이 옵션은 인덱스의 객체 가 트리에서 하나가 아닌 (예 &lt;code&gt;:link&lt;/code&gt; &lt;code&gt;HEAD:link&lt;/code&gt; 대신 : link ) 지정된 경우 (현재) 올바르게 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4255d9341f980babd777e06e825f8c27e78f42e4" translate="yes" xml:space="preserve">
          <source>This option enables a check that verifies if the tip of the remote-tracking ref is reachable from one of the &quot;reflog&quot; entries of the local branch based in it for a rewrite. The check ensures that any updates from the remote have been incorporated locally by rejecting the forced update if that is not the case.</source>
          <target state="translated">이 옵션은 원격 추적 참조의 팁이 재 작성을 위해이를 기반으로하는 로컬 분기의 &quot;reflog&quot;항목 중 하나에서 도달 할 수 있는지 확인하는 검사를 활성화합니다. 이 검사는 원격 업데이트가 그렇지 않은 경우 강제 업데이트를 거부하여 로컬로 통합되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d9ea124fbd7a15594b4c6836d821b0c2d1f565c3" translate="yes" xml:space="preserve">
          <source>This option forces conflicting hunks to be auto-resolved cleanly by favoring &lt;code&gt;our&lt;/code&gt; version. Changes from the other tree that do not conflict with our side are reflected in the merge result. For a binary file, the entire contents are taken from our side.</source>
          <target state="translated">심술쟁이 충돌이 옵션의 힘은 자동 해결 선호에 의해 깨끗하게 할 수 &lt;code&gt;our&lt;/code&gt; 버전. 우리 측과 충돌하지 않는 다른 트리의 변경 사항은 병합 결과에 반영됩니다. 바이너리 파일의 경우 전체 내용이 우리 측에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="03e43ead906b5a3ebd0febb15138c0f0fef70180" translate="yes" xml:space="preserve">
          <source>This option identifies the file status with the following tags (followed by a space) at the start of each line:</source>
          <target state="translated">이 옵션은 각 줄의 시작 부분에 다음 태그 (공백이 옴)로 파일 상태를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="11f1817b2bcb9580d82cb7eff477a970ee3352b6" translate="yes" xml:space="preserve">
          <source>This option is NOT recommended as it makes it difficult to track down old references to SVN revision numbers in existing documentation, bug reports, and archives. If you plan to eventually migrate from SVN to Git and are certain about dropping SVN history, consider &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo&lt;/a&gt; instead. filter-repo also allows reformatting of metadata for ease-of-reading and rewriting authorship info for non-&quot;svn.authorsFile&quot; users.</source>
          <target state="translated">이 옵션은 기존 문서, 버그 보고서 및 아카이브에서 SVN 개정 번호에 대한 이전 참조를 추적하기 어렵 기 때문에 권장되지 않습니다. SVN에서 Git으로 마이그레이션하고 SVN 히스토리 삭제가 확실하다면 &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo&lt;/a&gt; 를 고려하십시오 . filter-repo를 사용하면 &quot;svn.authorsFile&quot;이 아닌 사용자의 저작 정보를 쉽게 읽고 다시 쓸 수 있도록 메타 데이터를 다시 포맷 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78790ec840bc0471b6e620b0edc9dccd8cb32215" translate="yes" xml:space="preserve">
          <source>This option is a more advanced form of &lt;code&gt;subtree&lt;/code&gt; strategy, where the strategy makes a guess on how two trees must be shifted to match with each other when merging. Instead, the specified path is prefixed (or stripped from the beginning) to make the shape of two trees to match.</source>
          <target state="translated">이 옵션은보다 발전된 형태의 &lt;code&gt;subtree&lt;/code&gt; 전략으로, 병합시 두 트리를 서로 일치시키기 위해 전략을 전환해야합니다. 대신 지정된 경로에 접두사를 두거나 처음부터 제거하여 두 나무의 모양을 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="7e1a0662099548eacf19f027d973ae52cc900bb4" translate="yes" xml:space="preserve">
          <source>This option is deprecated in favour of &lt;code&gt;git stash push&lt;/code&gt;. It differs from &quot;stash push&quot; in that it cannot take pathspec. Instead, all non-option arguments are concatenated to form the stash message.</source>
          <target state="translated">이 옵션은 &lt;code&gt;git stash push&lt;/code&gt; 대신 더 이상 사용되지 않습니다 . pathspec을 사용할 수 없다는 점에서 &quot;stash push&quot;와 다릅니다. 대신 옵션이 아닌 모든 인수가 연결되어 숨김 메시지를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="4caf0764823caa06aa3cb192d447e797c84f9905" translate="yes" xml:space="preserve">
          <source>This option is deprecated in favour of &lt;code&gt;git stash push&lt;/code&gt;. It differs from &quot;stash push&quot; in that it cannot take pathspecs. Instead, all non-option arguments are concatenated to form the stash message.</source>
          <target state="translated">이 옵션은 &lt;code&gt;git stash push&lt;/code&gt; 대신 사용되지 않습니다 . 경로 스펙을 사용할 수 없다는 점에서 &quot;스 태쉬 푸시&quot;와 다릅니다. 대신 옵션이 아닌 모든 인수가 연결되어 숨김 메시지를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="c02fef4ae69460732c7c3bd405bb6c17f43ad119" translate="yes" xml:space="preserve">
          <source>This option is equivalent to the &amp;lt;repository&amp;gt; argument. If both are specified, the command-line argument takes precedence.</source>
          <target state="translated">이 옵션은 &amp;lt;repository&amp;gt; 인수와 동일합니다. 둘 다 지정되면 명령 줄 인수가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="b7fdcf9707bc99b530bc435f0d474fdd1738b42d" translate="yes" xml:space="preserve">
          <source>This option is implicitly supplied if any other list-like option such as &lt;code&gt;--contains&lt;/code&gt; is provided. See the documentation for each of those options for details.</source>
          <target state="translated">&lt;code&gt;--contains&lt;/code&gt; 와 같은 다른 목록과 같은 옵션이 제공되면이 옵션이 내재적으로 제공 됩니다. 자세한 내용은 해당 옵션 각각에 대한 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="710c94d6943c052c3ce9d72b355d1824bacce0cd" translate="yes" xml:space="preserve">
          <source>This option is only applicable in non-verbose mode.</source>
          <target state="translated">이 옵션은 상세하지 않은 모드에서만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4cc49fd28601407189cb758fe5a41d5aaf8777ac" translate="yes" xml:space="preserve">
          <source>This option is only applicable when listing tags without annotation lines.</source>
          <target state="translated">이 옵션은 주석 행이없는 태그를 나열 할 때만 적용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="ac28aa5e8f93911465d1aaa74ae4db50de2f286b" translate="yes" xml:space="preserve">
          <source>This option is only relevant if we are tracking branches (using one of the repository layout options --trunk, --tags, --branches, --stdlayout). For each tracked branch, try to find out where its revision was copied from, and set a suitable parent in the first Git commit for the branch. This is especially helpful when we&amp;rsquo;re tracking a directory that has been moved around within the repository. If this feature is disabled, the branches created by &lt;code&gt;git svn&lt;/code&gt; will all be linear and not share any history, meaning that there will be no information on where branches were branched off or merged. However, following long/convoluted histories can take a long time, so disabling this feature may speed up the cloning process. This feature is enabled by default, use --no-follow-parent to disable it.</source>
          <target state="translated">이 옵션은 저장소 레이아웃 옵션 --trunk, --tags, --branches, --stdlayout 중 하나를 사용하여 분기를 추적하는 경우에만 관련이 있습니다. 추적 된 각 브랜치에 대해 해당 리비전이 어디에서 복사되었는지 확인하고 브랜치의 첫 번째 Git 커밋에서 적합한 부모를 설정하십시오. 이는 저장소 내에서 이동 한 디렉토리를 추적 할 때 특히 유용합니다. 이 기능이 비활성화되면 &lt;code&gt;git svn&lt;/code&gt; 에 의해 생성 된 분기 는 모두 선형이며 기록을 공유하지 않으므로 분기가 분기되거나 병합 된 위치에 대한 정보가 없습니다. 그러나 길거나 복잡한 기록을 따르면 시간이 오래 걸릴 수 있으므로이 기능을 비활성화하면 복제 프로세스 속도가 빨라질 수 있습니다. 이 기능은 기본적으로 활성화되어 있습니다. --no-follow-parent를 사용하여 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="e12fdc170000781ad1c58dbca132db57e3472f94" translate="yes" xml:space="preserve">
          <source>This option is only used by Mac OS implementation of Git. When core.precomposeUnicode=true, Git reverts the unicode decomposition of filenames done by Mac OS. This is useful when sharing a repository between Mac OS and Linux or Windows. (Git for Windows 1.7.10 or higher is needed, or Git under cygwin 1.7). When false, file names are handled fully transparent by Git, which is backward compatible with older versions of Git.</source>
          <target state="translated">이 옵션은 Git의 Mac OS 구현에서만 사용됩니다. core.precomposeUnicode = true 인 경우 Git은 Mac OS에서 수행 한 파일 이름의 유니 코드 분해를 되돌립니다. 이것은 Mac OS와 Linux 또는 Windows간에 저장소를 공유 할 때 유용합니다. (Windows 1.7.10 이상의 Git 또는 cygwin 1.7의 Git이 필요합니다). False 인 경우 파일 이름은 Git에서 완전히 투명하게 처리되며 이전 버전의 Git과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="f6656985205e20f496a0b3074744f80ac096af4d" translate="yes" xml:space="preserve">
          <source>This option is only valid for &lt;code&gt;apply&lt;/code&gt;, &lt;code&gt;branch&lt;/code&gt;, &lt;code&gt;drop&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;show&lt;/code&gt; commands.</source>
          <target state="translated">이 옵션은 &lt;code&gt;apply&lt;/code&gt; , &lt;code&gt;branch&lt;/code&gt; , &lt;code&gt;drop&lt;/code&gt; , &lt;code&gt;pop&lt;/code&gt; , &lt;code&gt;show&lt;/code&gt; 명령 에만 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="ec6b30f54355307a9689dd1f0d561ef40fa56b3b" translate="yes" xml:space="preserve">
          <source>This option is only valid for &lt;code&gt;apply&lt;/code&gt;, &lt;code&gt;drop&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;save&lt;/code&gt;, &lt;code&gt;store&lt;/code&gt; commands.</source>
          <target state="translated">이 옵션은 &lt;code&gt;apply&lt;/code&gt; , &lt;code&gt;drop&lt;/code&gt; , &lt;code&gt;pop&lt;/code&gt; , &lt;code&gt;push&lt;/code&gt; , &lt;code&gt;save&lt;/code&gt; , &lt;code&gt;store&lt;/code&gt; 명령 에만 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="ca1fe023113c04188594b141d1e29c7346f8a146" translate="yes" xml:space="preserve">
          <source>This option is only valid for &lt;code&gt;pop&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; commands.</source>
          <target state="translated">이 옵션은 &lt;code&gt;pop&lt;/code&gt; 및 &lt;code&gt;apply&lt;/code&gt; 명령 에만 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="14a31933c42436b9e91daec147e769ddb8e06d57" translate="yes" xml:space="preserve">
          <source>This option is only valid for &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;save&lt;/code&gt; commands.</source>
          <target state="translated">이 옵션은 &lt;code&gt;push&lt;/code&gt; 및 &lt;code&gt;save&lt;/code&gt; 명령 에만 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="1938ed399d7f045d62945a278113dd2db5e4506d" translate="yes" xml:space="preserve">
          <source>This option is only valid for &lt;code&gt;push&lt;/code&gt; command.</source>
          <target state="translated">이 옵션은 &lt;code&gt;push&lt;/code&gt; 명령 에만 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="488a5b3855b8742f267f0b39339ad03e677bc10e" translate="yes" xml:space="preserve">
          <source>This option is only valid for add and update commands. Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal.</source>
          <target state="translated">이 옵션은 추가 및 업데이트 명령에만 유효합니다. -q를 지정하지 않으면 표준 오류 스트림이 터미널에 연결될 때 기본적으로 진행 상태가보고됩니다. 이 플래그는 표준 오류 스트림이 터미널로 보내지지 않더라도 진행 상태를 강제합니다.</target>
        </trans-unit>
        <trans-unit id="564be2665790d0ee7a744865d472382d1cf20497" translate="yes" xml:space="preserve">
          <source>This option is only valid for add and update commands. These commands sometimes need to clone a remote repository. In this case, this option will be passed to the &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; command.</source>
          <target state="translated">이 옵션은 추가 및 업데이트 명령에만 유효합니다. 이 명령은 때때로 원격 저장소를 복제해야합니다. 이 경우이 옵션은 &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 명령 으로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="1175e1719609394666bffaa81ec16b8052e4a6b8" translate="yes" xml:space="preserve">
          <source>This option is only valid for add, deinit and update commands. When running add, allow adding an otherwise ignored submodule path. When running deinit the submodule working trees will be removed even if they contain local changes. When running update (only effective with the checkout procedure), throw away local changes in submodules when switching to a different commit; and always run a checkout operation in the submodule, even if the commit listed in the index of the containing repository matches the commit checked out in the submodule.</source>
          <target state="translated">이 옵션은 add, deinit 및 update 명령에만 유효합니다. add를 실행할 때 다르게 무시되는 서브 모듈 경로를 추가하십시오. deinit를 실행하면 서브 모듈 작업 트리가 로컬 변경 사항을 포함하더라도 제거됩니다. 업데이트를 실행할 때 (체크 아웃 절차에서만 유효) 다른 커밋으로 전환 할 때 하위 모듈에서 로컬 변경 사항을 버립니다. 포함 저장소의 색인에 나열된 커밋이 서브 모듈에서 체크 아웃 된 커밋과 일치하더라도 항상 서브 모듈에서 체크 아웃 조작을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="2de8d442aa39a274aaa4b758d62aa7d0adb622e3" translate="yes" xml:space="preserve">
          <source>This option is only valid for foreach, update, status and sync commands. Traverse submodules recursively. The operation is performed not only in the submodules of the current repo, but also in any nested submodules inside those submodules (and so on).</source>
          <target state="translated">이 옵션은 foreach, update, status 및 sync 명령에만 유효합니다. 서브 모듈을 재귀 적으로 트래버스합니다. 작업은 현재 리포지토리의 하위 모듈뿐만 아니라 해당 하위 모듈 내부의 중첩 된 하위 모듈 등에서도 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="d01c54f91ad08eb6d9511d7549b500d6b89b1500" translate="yes" xml:space="preserve">
          <source>This option is only valid for status and summary commands. These commands typically use the commit found in the submodule HEAD, but with this option, the commit stored in the index is used instead.</source>
          <target state="translated">이 옵션은 상태 및 요약 명령에만 유효합니다. 이러한 명령은 일반적으로 하위 모듈 HEAD에있는 커밋을 사용하지만이 옵션을 사용하면 인덱스에 저장된 커밋이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7ba21174d5319ba108a98df185e2c79d000e199b" translate="yes" xml:space="preserve">
          <source>This option is only valid for the add command. It sets the submodule&amp;rsquo;s name to the given string instead of defaulting to its path. The name must be valid as a directory name and may not end with a &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 add 명령에만 유효합니다. 서브 모듈의 이름을 기본 경로로 지정하지 않고 주어진 문자열로 설정합니다. 이름은 디렉토리 이름으로 유효해야하며 &lt;code&gt;/&lt;/code&gt; 로 끝나지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="87ff71824f0ae07bd73763f995cf49d0ad4b94cd" translate="yes" xml:space="preserve">
          <source>This option is only valid for the deinit command. Unregister all submodules in the working tree.</source>
          <target state="translated">이 옵션은 deinit 명령에만 유효합니다. 작업 트리에서 모든 하위 모듈을 등록 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="f24783ef5194da88d7aca04af04dd4876a0ce3ed" translate="yes" xml:space="preserve">
          <source>This option is only valid for the summary command. Limit the summary size (number of commits shown in total). Giving 0 will disable the summary; a negative number means unlimited (the default). This limit only applies to modified submodules. The size is always limited to 1 for added/deleted/typechanged submodules.</source>
          <target state="translated">이 옵션은 summary 명령에만 유효합니다. 요약 크기 (전체 커밋 수)를 제한하십시오. 0을 주면 요약이 비활성화됩니다. 음수는 무제한을 의미합니다 (기본값). 이 제한은 수정 된 하위 모듈에만 적용됩니다. 추가 / 삭제 / 유형 변경 하위 모듈의 경우 크기는 항상 1로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="ba7d2b303205764476dea6127f5143ab027381fd" translate="yes" xml:space="preserve">
          <source>This option is only valid for the summary command. This command compares the commit in the index with that in the submodule HEAD when this option is used.</source>
          <target state="translated">이 옵션은 요약 명령에만 유효합니다. 이 명령은이 옵션이 사용될 때 인덱스의 커밋을 서브 모듈 HEAD의 커밋과 비교합니다.</target>
        </trans-unit>
        <trans-unit id="0329e613a2d579c43cf813e4dcb872eed327d20c" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Checkout the commit recorded in the superproject on a detached HEAD in the submodule. This is the default behavior, the main use of this option is to override &lt;code&gt;submodule.$name.update&lt;/code&gt; when set to a value other than &lt;code&gt;checkout&lt;/code&gt;. If the key &lt;code&gt;submodule.$name.update&lt;/code&gt; is either not explicitly set or set to &lt;code&gt;checkout&lt;/code&gt;, this option is implicit.</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. 서브 모듈에서 분리 된 HEAD에서 수퍼 프로젝트에 기록 된 커밋을 확인하십시오. 이것이 기본 동작이며,이 옵션의 주요 용도는 &lt;code&gt;checkout&lt;/code&gt; 이외의 값으로 설정 될 때 &lt;code&gt;submodule.$name.update&lt;/code&gt; 를 대체 하는 것 입니다. 키 &lt;code&gt;submodule.$name.update&lt;/code&gt; 가 명시 적으로 설정되거나 &lt;code&gt;checkout&lt;/code&gt; 으로 설정되지 않은 경우이 옵션은 내재적입니다.</target>
        </trans-unit>
        <trans-unit id="7988d8bd0ba82c9f133c5f7cc525c2236228f253" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Clone new submodules in parallel with as many jobs. Defaults to the &lt;code&gt;submodule.fetchJobs&lt;/code&gt; option.</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. 많은 서브 작업과 동시에 새로운 서브 모듈을 복제하십시오. &lt;code&gt;submodule.fetchJobs&lt;/code&gt; 옵션이 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="d378f847e736854044b7df06d860154da6a30cd4" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Clone only one branch during update: HEAD or one specified by --branch.</source>
          <target state="translated">이 옵션은 업데이트 명령에만 유효합니다. 업데이트 중에 HEAD 또는 --branch로 지정된 분기 하나만 복제합니다.</target>
        </trans-unit>
        <trans-unit id="de5e49243a4037b1b14e7038956130dc87de6d4f" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Don&amp;rsquo;t fetch new objects from the remote site.</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. 원격 사이트에서 새 객체를 가져 오지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f13e740e91a73f0a2574eefa11fc263894a39d8c" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Initialize all submodules for which &quot;git submodule init&quot; has not been called so far before updating.</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. &quot;git submodule init&quot;가 지금까지 호출되지 않은 모든 서브 모듈을 업데이트하기 전에 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="78bb9a5b0867074719f5c17324b183ac216eed4e" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Instead of using the superproject&amp;rsquo;s recorded SHA-1 to update the submodule, use the status of the submodule&amp;rsquo;s remote-tracking branch. The remote used is branch&amp;rsquo;s remote (&lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt;), defaulting to &lt;code&gt;origin&lt;/code&gt;. The remote branch used defaults to &lt;code&gt;master&lt;/code&gt;, but the branch name may be overridden by setting the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; option in either &lt;code&gt;.gitmodules&lt;/code&gt; or &lt;code&gt;.git/config&lt;/code&gt; (with &lt;code&gt;.git/config&lt;/code&gt; taking precedence).</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. 수퍼 프로젝트의 기록 된 SHA-1을 사용하여 서브 모듈을 업데이트하는 대신 서브 모듈의 원격 추적 브랜치 상태를 사용하십시오. 사용 된 원격은 분기의 원격 ( &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; )이며 기본값은 &lt;code&gt;origin&lt;/code&gt; 입니다. 원격 분기에 기본값을 사용하는 &lt;code&gt;master&lt;/code&gt; 하지만, 지점 이름이 설정에 의해 오버라이드 (override) 할 수있다 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; 옵션 중 하나에 &lt;code&gt;.gitmodules&lt;/code&gt; 또는 &lt;code&gt;.git/config&lt;/code&gt; 에 (와 &lt;code&gt;.git/config&lt;/code&gt; 에 복용 우선 순위).</target>
        </trans-unit>
        <trans-unit id="71febe80653ad4c9e80be61d4ea3dbe9011e0741" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Instead of using the superproject&amp;rsquo;s recorded SHA-1 to update the submodule, use the status of the submodule&amp;rsquo;s remote-tracking branch. The remote used is branch&amp;rsquo;s remote (&lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt;), defaulting to &lt;code&gt;origin&lt;/code&gt;. The remote branch used defaults to the remote &lt;code&gt;HEAD&lt;/code&gt;, but the branch name may be overridden by setting the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; option in either &lt;code&gt;.gitmodules&lt;/code&gt; or &lt;code&gt;.git/config&lt;/code&gt; (with &lt;code&gt;.git/config&lt;/code&gt; taking precedence).</source>
          <target state="translated">이 옵션은 업데이트 명령에만 유효합니다. 슈퍼 프로젝트의 기록 된 SHA-1을 사용하여 서브 모듈을 업데이트하는 대신 서브 모듈의 원격 추적 분기 상태를 사용하십시오. 사용되는 원격은 분기의 원격 ( &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; )이며 기본값은 &lt;code&gt;origin&lt;/code&gt; 입니다. 원격 브랜치는 원격으로 기본값을 사용 &lt;code&gt;HEAD&lt;/code&gt; 하지만, 지점 이름이 설정에 의해 오버라이드 (override) 할 수있다 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; 옵션 중 하나에 &lt;code&gt;.gitmodules&lt;/code&gt; 또는 &lt;code&gt;.git/config&lt;/code&gt; 에 (와 &lt;code&gt;.git/config&lt;/code&gt; 에 복용 우선 순위).</target>
        </trans-unit>
        <trans-unit id="c3d36d21960733622c3c4d0c9b1d02dde186ab4d" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Merge the commit recorded in the superproject into the current branch of the submodule. If this option is given, the submodule&amp;rsquo;s HEAD will not be detached. If a merge failure prevents this process, you will have to resolve the resulting conflicts within the submodule with the usual conflict resolution tools. If the key &lt;code&gt;submodule.$name.update&lt;/code&gt; is set to &lt;code&gt;merge&lt;/code&gt;, this option is implicit.</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. 수퍼 프로젝트에 기록 된 커밋을 서브 모듈의 현재 브랜치에 병합하십시오. 이 옵션을 지정하면 서브 모듈의 HEAD가 분리되지 않습니다. 병합 실패로 인해이 프로세스가 중단되면 일반적인 충돌 해결 도구를 사용하여 하위 모듈 내에서 발생하는 충돌을 해결해야합니다. 키 &lt;code&gt;submodule.$name.update&lt;/code&gt; 가 &lt;code&gt;merge&lt;/code&gt; 로 설정된 경우이 옵션은 내재적입니다.</target>
        </trans-unit>
        <trans-unit id="24320b0a3d3cc55ac6e67c5111e4d5b2024f7768" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Rebase the current branch onto the commit recorded in the superproject. If this option is given, the submodule&amp;rsquo;s HEAD will not be detached. If a merge failure prevents this process, you will have to resolve these failures with &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;. If the key &lt;code&gt;submodule.$name.update&lt;/code&gt; is set to &lt;code&gt;rebase&lt;/code&gt;, this option is implicit.</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. 현재 브랜치를 수퍼 프로젝트에 기록 된 커밋으로 리베이스하십시오. 이 옵션을 지정하면 서브 모듈의 HEAD가 분리되지 않습니다. 병합 실패가이 프로세스를 방해하면 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]로&lt;/a&gt; 이러한 실패를 해결해야합니다 . 키 &lt;code&gt;submodule.$name.update&lt;/code&gt; 가 &lt;code&gt;rebase&lt;/code&gt; 로 설정된 경우이 옵션은 내재적입니다.</target>
        </trans-unit>
        <trans-unit id="7010a654e778ac0c1da27a5e658bfb8f3af2d2b7" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. The initial clone of a submodule will use the recommended &lt;code&gt;submodule.&amp;lt;name&amp;gt;.shallow&lt;/code&gt; as provided by the &lt;code&gt;.gitmodules&lt;/code&gt; file by default. To ignore the suggestions use &lt;code&gt;--no-recommend-shallow&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. 서브 모듈의 초기 복제는 권장 사용 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.shallow&lt;/code&gt; 에 의해 규정 된 &lt;code&gt;.gitmodules&lt;/code&gt; 에 기본적으로 파일. 제안을 무시하려면 &lt;code&gt;--no-recommend-shallow&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6d7b3753dd95003bf8a5d9061fa7c1fb4ce2aaa" translate="yes" xml:space="preserve">
          <source>This option is only valid when &quot;--rebase&quot; is used.</source>
          <target state="translated">이 옵션은 &quot;--rebase&quot;가 사용될 때만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="98847da95477508a8a5d1e566e92d9a686be8a10" translate="yes" xml:space="preserve">
          <source>This option is particularly useful in avoiding false positives when a merged branch contained broken or non-buildable commits, but the merge itself was OK.</source>
          <target state="translated">이 옵션은 병합 된 분기에 깨지거나 빌드 할 수없는 커밋이 포함되어 있지만 병합 자체는 정상일 때 오탐을 방지하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f287cb1cbdf50b2a99b97c922a7a8e625bb0e374" translate="yes" xml:space="preserve">
          <source>This option is passed through to &lt;code&gt;git pack-objects&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;git pack-objects&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="4fbc055bad10c535a2fe42cbab527b95ac43fb4e" translate="yes" xml:space="preserve">
          <source>This option is primarily to help users who are used to older versions of Git, whose &quot;git add &amp;lt;pathspec&amp;gt;&amp;hellip;​&quot; was a synonym for &quot;git add --no-all &amp;lt;pathspec&amp;gt;&amp;hellip;​&quot;, i.e. ignored removed files.</source>
          <target state="translated">이 옵션은 주로 &quot;git add &amp;lt;pathspec&amp;gt;&amp;hellip;&quot;과 같은 이전 버전의 Git에 익숙한 사용자가 &quot;git add --no-all &amp;lt;pathspec&amp;gt;&amp;hellip;&quot;과 동의어 인 경우, 즉 제거 된 파일을 무시하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="b78fb9017b343dcaa9f7e76e34c0b6aead88f71f" translate="yes" xml:space="preserve">
          <source>This option is similar to &lt;code&gt;--topo-order&lt;/code&gt; in the sense that no parent comes before all of its children, but otherwise commits are ordered according to their commit date.</source>
          <target state="translated">이 옵션은 부모가 모든 자식보다 먼저 나오지 않는다는 점에서 &lt;code&gt;--topo-order&lt;/code&gt; 와 비슷 하지만 커밋은 커밋 날짜에 따라 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="45355afb761a7570eab836899016e010dbbaff37" translate="yes" xml:space="preserve">
          <source>This option is used internally to temporarily provide a non-negative default value for the --recurse-submodules option. All other methods of configuring fetch&amp;rsquo;s submodule recursion (such as settings in &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; and &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) override this option, as does specifying --[no-]recurse-submodules directly.</source>
          <target state="translated">이 옵션은 내부적으로 --recurse-submodules 옵션에 음이 아닌 기본값을 제공하기 위해 사용됩니다. 페치의 하위 모듈 재귀를 구성하는 다른 모든 방법 (예 : &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 및 &lt;a href=&quot;git-config&quot;&gt;git-config [1]의 설정&lt;/a&gt; )은-[no-] recurse-submodules를 직접 지정하는 것처럼이 옵션을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="37e6c888c3b366c4018908c683d3076036665dbd" translate="yes" xml:space="preserve">
          <source>This option is useful in the case where one is developing a feature on top of an upstream branch. While the feature is being worked on, the upstream branch may advance and it may not be the best idea to keep rebasing on top of the upstream but to keep the base commit as-is.</source>
          <target state="translated">이 옵션은 업스트림 브랜치에서 기능을 개발중인 경우에 유용합니다. 이 기능이 작동하는 동안 업스트림 브랜치는 진행될 수 있으며 업스트림 상단에 계속 기반을 두는 것이 아니라 기본 커밋을 그대로 유지하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="df85f593fd6f7620dd8216482ba39599038d6eaa" translate="yes" xml:space="preserve">
          <source>This option is valid for add and update commands. Create a &lt;code&gt;shallow&lt;/code&gt; clone with a history truncated to the specified number of revisions. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;</source>
          <target state="translated">이 옵션은 추가 및 업데이트 명령에 유효합니다. 지정된 수의 개정판으로 기록이 잘린 &lt;code&gt;shallow&lt;/code&gt; 복제본을 만듭니다 . &lt;a href=&quot;git-clone&quot;&gt;자식 클론&lt;/a&gt; 참조 [1]</target>
        </trans-unit>
        <trans-unit id="ebd5b9556122446be4baef760f1327190ef9a1e0" translate="yes" xml:space="preserve">
          <source>This option makes it possible to choose what action will be performed when there is already at least one trailer with the same &amp;lt;token&amp;gt; in the message.</source>
          <target state="translated">이 옵션을 사용하면 메시지에 &amp;lt;토큰&amp;gt;이 동일한 트레일러가 이미 하나 이상있을 때 수행 할 작업을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccc070d377579e85f01a8bc02ef61c868f5331ee" translate="yes" xml:space="preserve">
          <source>This option makes it possible to choose what action will be performed when there is not yet any trailer with the same &amp;lt;token&amp;gt; in the message.</source>
          <target state="translated">이 옵션을 사용하면 메시지에 &amp;lt;토큰&amp;gt;이 같은 예고편이 아직 없을 때 수행 할 작업을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f87ac9b403a45c29acabaf374d53994925318884" translate="yes" xml:space="preserve">
          <source>This option may be given up to three times, and specifies labels to be used in place of the corresponding file names in conflict reports. That is, &lt;code&gt;git merge-file -L x -L y -L z a b c&lt;/code&gt; generates output that looks like it came from files x, y and z instead of from files a, b and c.</source>
          <target state="translated">이 옵션은 최대 3 번까지 주어질 수 있으며 충돌 보고서에서 해당 파일 이름 대신 사용할 레이블을 지정합니다. 즉, &lt;code&gt;git merge-file -L x -L y -L z a b c&lt;/code&gt; 는 파일 a, b 및 c가 아닌 파일 x, y 및 z에서 나온 것처럼 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e631233708c2bfee4790b72e1f69b49f86a6c1ad" translate="yes" xml:space="preserve">
          <source>This option may be specified more than once.</source>
          <target state="translated">이 옵션은 두 번 이상 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad4bbf67e7b293924d5786bf652c9c00512dbaee" translate="yes" xml:space="preserve">
          <source>This option may be specified more than once; if so, Git will report commits reachable from any of the given commits.</source>
          <target state="translated">이 옵션은 두 번 이상 지정할 수 있습니다. 그렇다면 Git은 주어진 커밋에서 도달 가능한 커밋을보고합니다.</target>
        </trans-unit>
        <trans-unit id="02516672facfbf5a7b264eba6cd92c5455d92d79" translate="yes" xml:space="preserve">
          <source>This option may be specified multiple times.</source>
          <target state="translated">이 옵션은 여러 번 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b397b665066a62a5850aaf1e8487dea9e6d48e99" translate="yes" xml:space="preserve">
          <source>This option may be useful if you have CVS revision numbers stored in commit messages, bug-tracking systems, email archives, and the like.</source>
          <target state="translated">이 옵션은 커밋 메시지, 버그 추적 시스템, 전자 메일 아카이브 등에 CVS 개정 번호가 저장된 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f0fddd7193d3e6d239ce8fc4bc7fc077dbf4105" translate="yes" xml:space="preserve">
          <source>This option may be useful when the test you would perform in each step does not require a checked out tree.</source>
          <target state="translated">이 옵션은 각 단계에서 수행 할 테스트에 체크 아웃 된 트리가 필요하지 않을 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17ca02a4d5f28c7e8971b8d1a382a0b6bcfa0d17" translate="yes" xml:space="preserve">
          <source>This option overrides this restriction if the current value of the remote ref is the expected value. &quot;git push&quot; fails otherwise.</source>
          <target state="translated">원격 참조의 현재 값이 예상 값인 경우이 옵션은이 제한을 무시합니다. 그렇지 않으면 &quot;git push&quot;가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="8d166b9e59f19f7598d41e509f594cbcbd0ac7f1" translate="yes" xml:space="preserve">
          <source>This option provides an additional limit on top of &lt;code&gt;--window&lt;/code&gt;; the window size will dynamically scale down so as to not take up more than &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; bytes in memory. This is useful in repositories with a mix of large and small objects to not run out of memory with a large window, but still be able to take advantage of the large window for the smaller objects. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. &lt;code&gt;--window-memory=0&lt;/code&gt; makes memory usage unlimited. The default is taken from the &lt;code&gt;pack.windowMemory&lt;/code&gt; configuration variable.</source>
          <target state="translated">이 옵션은 &lt;code&gt;--window&lt;/code&gt; 위에 추가 제한을 제공합니다 . 메모리에서 &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; 바이트 이상을 차지하지 않도록 창 크기가 동적으로 축소됩니다 . 이 기능은 큰 개체와 작은 개체가 혼합 된 리포지토리에서 큰 창이있는 메모리가 부족하지 않지만 작은 개체의 경우 큰 창을 활용할 수 있습니다. 크기는 &quot;k&quot;, &quot;m&quot;또는 &quot;g&quot;로 접미사를 붙일 수 있습니다. &lt;code&gt;--window-memory=0&lt;/code&gt; 은 메모리 사용량을 무제한으로 만듭니다. 기본값은 &lt;code&gt;pack.windowMemory&lt;/code&gt; 구성 변수 에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="b37ac455915a6998f49ecb85f682ef29dfba0c63" translate="yes" xml:space="preserve">
          <source>This option provides an additional limit on top of &lt;code&gt;--window&lt;/code&gt;; the window size will dynamically scale down so as to not take up more than &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; bytes in memory. This is useful in repositories with a mix of large and small objects to not run out of memory with a large window, but still be able to take advantage of the large window for the smaller objects. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. &lt;code&gt;--window-memory=0&lt;/code&gt; makes memory usage unlimited. The default is taken from the &lt;code&gt;pack.windowMemory&lt;/code&gt; configuration variable. Note that the actual memory usage will be the limit multiplied by the number of threads used by &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;--window&lt;/code&gt; 위에 추가 제한을 제공합니다 . 메모리에서 &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; 바이트 이상을 차지하지 않도록 창 크기가 동적으로 축소됩니다 . 이 기능은 큰 개체와 작은 개체가 혼합 된 리포지토리에서 큰 창이있는 메모리가 부족하지 않지만 작은 개체의 경우 큰 창을 활용할 수 있습니다. 크기는 &quot;k&quot;, &quot;m&quot;또는 &quot;g&quot;로 접미사를 붙일 수 있습니다. &lt;code&gt;--window-memory=0&lt;/code&gt; 은 메모리 사용량을 무제한으로 만듭니다. 기본값은 &lt;code&gt;pack.windowMemory&lt;/code&gt; 구성 변수 에서 가져옵니다 . 실제 메모리 사용량은 &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]에&lt;/a&gt; 사용 된 스레드 수를 곱한 한도 입니다.</target>
        </trans-unit>
        <trans-unit id="16a6b7273f3cccefcfa42e33a667c568aaee0875" translate="yes" xml:space="preserve">
          <source>This option sets how the tag message is cleaned up. The &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; can be one of &lt;code&gt;verbatim&lt;/code&gt;, &lt;code&gt;whitespace&lt;/code&gt; and &lt;code&gt;strip&lt;/code&gt;. The &lt;code&gt;strip&lt;/code&gt; mode is default. The &lt;code&gt;verbatim&lt;/code&gt; mode does not change message at all, &lt;code&gt;whitespace&lt;/code&gt; removes just leading/trailing whitespace lines and &lt;code&gt;strip&lt;/code&gt; removes both whitespace and commentary.</source>
          <target state="translated">이 옵션은 태그 메시지를 정리하는 방법을 설정합니다. &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 중 하나가 될 수 &lt;code&gt;verbatim&lt;/code&gt; , &lt;code&gt;whitespace&lt;/code&gt; 및 &lt;code&gt;strip&lt;/code&gt; . &lt;code&gt;strip&lt;/code&gt; 모드는 기본값입니다. &lt;code&gt;verbatim&lt;/code&gt; 모드는 전혀 메시지를 변경하지 않는 &lt;code&gt;whitespace&lt;/code&gt; 단지 / 주요 라인과 공백을 후행 제거합니다 &lt;code&gt;strip&lt;/code&gt; 공백과 해설을 모두 제거합니다.</target>
        </trans-unit>
        <trans-unit id="1c04622cab5eac3fe5e20d1c189be97d2000ad23" translate="yes" xml:space="preserve">
          <source>This option takes the same values as the &lt;code&gt;trailer.ifexists&lt;/code&gt; configuration variable and it overrides what is specified by that option for trailers with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">이 옵션은 같은 값을 사용 &lt;code&gt;trailer.ifexists&lt;/code&gt; 의 구성 변수는 지정된 &amp;lt;토큰&amp;gt;와 트레일러에 대한 해당 옵션에 의해 지정됩니다 무엇보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="de59f6641e33166f78c75c60b985eacdf1d2a0ea" translate="yes" xml:space="preserve">
          <source>This option takes the same values as the &lt;code&gt;trailer.ifmissing&lt;/code&gt; configuration variable and it overrides what is specified by that option for trailers with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;trailer.ifmissing&lt;/code&gt; 구성 변수와 동일한 값을 사용하며 지정된 &amp;lt;token&amp;gt;을 가진 트레일러에 대해 해당 옵션으로 지정된 값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="6b156d8c8a67e1eaa9c71b8c4e454e308c17c450" translate="yes" xml:space="preserve">
          <source>This option takes the same values as the &lt;code&gt;trailer.where&lt;/code&gt; configuration variable and it overrides what is specified by that option for trailers with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;trailer.where&lt;/code&gt; 구성 변수와 동일한 값을 가지며 지정된 &amp;lt;token&amp;gt;을 가진 트레일러에 대해 해당 옵션으로 지정된 값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="7df9ff293572a5c1527bce59783d9544419daa5b" translate="yes" xml:space="preserve">
          <source>This option tells where a new trailer will be added.</source>
          <target state="translated">이 옵션은 새 트레일러가 추가 될 위치를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="b36c69b0196d300061790058cdc0665affb9915e" translate="yes" xml:space="preserve">
          <source>This option tells which characters are recognized as trailer separators. By default only &lt;code&gt;:&lt;/code&gt; is recognized as a trailer separator, except that &lt;code&gt;=&lt;/code&gt; is always accepted on the command line for compatibility with other git commands.</source>
          <target state="translated">이 옵션은 트레일러 구분 기호로 인식되는 문자를 알려줍니다. 기본적으로 &lt;code&gt;:&lt;/code&gt; 트레일러 구분 기호로 인식됩니다. 단, 다른 git 명령과의 호환성을 위해 명령 줄에서 &lt;code&gt;=&lt;/code&gt; 가 항상 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d89b4c86a97ff8d1caa3cc84d59173003c0040dc" translate="yes" xml:space="preserve">
          <source>This option will cause fast-export to issue a &quot;deleteall&quot; directive for each commit followed by a full list of all files in the commit (as opposed to just listing the files which are different from the commit&amp;rsquo;s first parent).</source>
          <target state="translated">이 옵션은 빠른 내보내기로 인해 각 커밋에 대해 &quot;deleteall&quot;지시문을 발행하고 커밋의 첫 번째 상위와 다른 파일을 나열하는 대신 커밋에있는 모든 파일의 전체 목록을 발행합니다.</target>
        </trans-unit>
        <trans-unit id="f143abcfc92e5721db51d7183ec9951b417133b6" translate="yes" xml:space="preserve">
          <source>This option will cause git-svn to attempt to automatically populate the svn:mergeinfo property in the SVN repository when possible. Currently, this can only be done when dcommitting non-fast-forward merges where all parents but the first have already been pushed into SVN.</source>
          <target state="translated">이 옵션은 git-svn이 가능한 경우 SVN 저장소에서 svn : mergeinfo 속성을 자동으로 채우도록 시도합니다. 현재 이것은 첫 번째 부모를 제외한 모든 부모가 이미 SVN으로 푸시 된 비 빨리 감기 병합을 dcommitting 할 때만 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06697c041d5aacbd598da12e9917cf43b1b799c5" translate="yes" xml:space="preserve">
          <source>This option will cause the mapping from old to new objects to be loaded from named branch upon startup and saved as a new commit to that branch upon exit, enabling incremental of large trees. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; does not exist it will be created.</source>
          <target state="translated">이 옵션을 사용하면 시작시 기존 오브젝트에서 새 오브젝트로의 맵핑이 명명 된 브랜치에서로드되고 종료시 해당 브랜치에 새 커밋으로 저장되어 큰 트리를 증분시킬 수 있습니다. 경우 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 존재하지 않는 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="dac1adaa75a920f5808dd15e4e9468c4b8319529" translate="yes" xml:space="preserve">
          <source>This output format is compatible with what &lt;code&gt;--index-info --stdin&lt;/code&gt; of &lt;code&gt;git update-index&lt;/code&gt; expects.</source>
          <target state="translated">이 출력 형식은 &lt;code&gt;git update-index&lt;/code&gt; 의 &lt;code&gt;--index-info --stdin&lt;/code&gt; 이 기대 하는 것과 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="9b61a138f7f673e2e13a43bac58e20e6d27091cc" translate="yes" xml:space="preserve">
          <source>This outputs all the commit objects between the included and excluded commits, ordered by their distance to the included and excluded commits. Refs in &lt;code&gt;refs/bisect/&lt;/code&gt; are not used. The farthest from them is displayed first. (This is the only one displayed by &lt;code&gt;--bisect&lt;/code&gt;.)</source>
          <target state="translated">포함 및 제외 커밋까지의 거리 순서대로 포함 및 제외 커밋 사이의 모든 커밋 개체를 출력합니다. &lt;code&gt;refs/bisect/&lt;/code&gt; 참조는 사용되지 않습니다. 가장 먼 곳이 먼저 표시됩니다. &lt;code&gt;--bisect&lt;/code&gt; 에 의해 표시되는 유일한 항목 입니다.</target>
        </trans-unit>
        <trans-unit id="c6b16b352aa83127a9d9220754dcd31555c3879e" translate="yes" xml:space="preserve">
          <source>This outputs something like this (the actual commit object names would be different)</source>
          <target state="translated">이것은 다음과 같이 출력됩니다 (실제 커밋 객체 이름은 다를 수 있습니다)</target>
        </trans-unit>
        <trans-unit id="05fcf2a461c52cf42967559d01dbd73ffe108135" translate="yes" xml:space="preserve">
          <source>This overrides a previous &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--gui&lt;/code&gt; setting and reads the default merge tool will be read from the configured &lt;code&gt;merge.tool&lt;/code&gt; variable.</source>
          <target state="translated">이는 이전 &lt;code&gt;-g&lt;/code&gt; 또는 &lt;code&gt;--gui&lt;/code&gt; 설정을 무시 하고 구성된 &lt;code&gt;merge.tool&lt;/code&gt; 변수 에서 기본 병합 도구를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="cf7619d964802ced013b07a7c34a4262a7e0e3f4" translate="yes" xml:space="preserve">
          <source>This page can be displayed with &lt;code&gt;git help help&lt;/code&gt; or &lt;code&gt;git help --help&lt;/code&gt;</source>
          <target state="translated">이 페이지는 &lt;code&gt;git help help&lt;/code&gt; 또는 &lt;code&gt;git help --help&lt;/code&gt; 와 함께 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d990ef47ac594dcb10bc55890ec7a6963b3ffaed" translate="yes" xml:space="preserve">
          <source>This particular format is supplied as it&amp;rsquo;s short to implement and may be useful to a process that wants to create a new commit right now, without needing to use a working directory or &lt;code&gt;git update-index&lt;/code&gt;.</source>
          <target state="translated">이 특정 형식은 구현하기가 짧기 때문에 제공되며 작업 디렉토리 또는 &lt;code&gt;git update-index&lt;/code&gt; 를 사용할 필요없이 지금 새로운 커밋을 생성하려는 프로세스에 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ace4cf0777df858ca1c6440d5cccb2ed6637934" translate="yes" xml:space="preserve">
          <source>This prints the name of a commit they are both based on. You should now look up the tree objects of those commits, which you can easily do with</source>
          <target state="translated">커밋 이름을 출력합니다. 이제 커밋의 트리 객체를 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="65ce33f2a6f411ae54de75d77a4a5c5e2663fba3" translate="yes" xml:space="preserve">
          <source>This program computes which packs in your repository are redundant. The output is suitable for piping to &lt;code&gt;xargs rm&lt;/code&gt; if you are in the root of the repository.</source>
          <target state="translated">이 프로그램은 리포지토리의 어떤 팩이 중복되는지 계산합니다. 저장소의 루트에있는 경우 출력은 &lt;code&gt;xargs rm&lt;/code&gt; 으로 파이핑하는 데 적합 합니다.</target>
        </trans-unit>
        <trans-unit id="9dec60739fdc5804a4abedc6cf66847493211890" translate="yes" xml:space="preserve">
          <source>This program dumps the given revisions in a form suitable to be piped into &lt;code&gt;git fast-import&lt;/code&gt;.</source>
          <target state="translated">이 프로그램은 주어진 개정판을 &lt;code&gt;git fast-import&lt;/code&gt; 로 파이프하기에 적합한 형식으로 덤프합니다 .</target>
        </trans-unit>
        <trans-unit id="21943cdf9cd81593906492b86163eaa305da0be9" translate="yes" xml:space="preserve">
          <source>This program is usually not what the end user wants to run directly. Most end users want to use one of the existing frontend programs, which parses a specific type of foreign source and feeds the contents stored there to &lt;code&gt;git fast-import&lt;/code&gt;.</source>
          <target state="translated">이 프로그램은 일반적으로 최종 사용자가 직접 실행하려는 것이 아닙니다. 대부분의 최종 사용자는 기존 프론트 엔드 프로그램 중 하나를 사용하려고합니다.이 프로그램은 특정 유형의 외부 소스를 구문 분석하고 거기에 저장된 컨텐츠를 &lt;code&gt;git fast-import&lt;/code&gt; 에 공급 합니다.</target>
        </trans-unit>
        <trans-unit id="17acfb3fc2cc80c07ee41f3eeadca000eefd6ee0" translate="yes" xml:space="preserve">
          <source>This program searches the &lt;code&gt;$GIT_OBJECT_DIRECTORY&lt;/code&gt; for all objects that currently exist in a pack file as well as the independent object directories.</source>
          <target state="translated">이 프로그램은 &lt;code&gt;$GIT_OBJECT_DIRECTORY&lt;/code&gt; 에서 현재 팩 파일에 존재하는 모든 오브젝트와 독립 오브젝트 디렉토리를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="a85a25d731117b0f9fdffb50b50cd41a205c14dd" translate="yes" xml:space="preserve">
          <source>This public repository could further be mirrored, and that is how Git repositories at &lt;code&gt;kernel.org&lt;/code&gt; are managed.</source>
          <target state="translated">이 퍼블릭 리포지토리는 추가로 미러링 될 수 있으며, 이것이 &lt;code&gt;kernel.org&lt;/code&gt; 의 Git 리포지토리 가 관리되는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="3f74cf126c451b6a68e67763c97a8253f485453b" translate="yes" xml:space="preserve">
          <source>This puts a Git archive of the named CVS module in the directory &amp;lt;destination&amp;gt;, which will be created if necessary.</source>
          <target state="translated">그러면 이름이 지정된 CVS 모듈의 Git 아카이브가 &amp;lt;destination&amp;gt; 디렉토리에 저장되며 필요한 경우 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="8831ce4f64ae931ef68e9c4eb0b8a48320fea478" translate="yes" xml:space="preserve">
          <source>This rebase can be performed using the &lt;code&gt;--rebase-merges&lt;/code&gt; option. It will generate a todo list looking like this:</source>
          <target state="translated">이 rebase는 &lt;code&gt;--rebase-merges&lt;/code&gt; 옵션을 사용하여 수행 할 수 있습니다 . 다음과 같은 할 일 목록을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5e2dd779ca9f11c05d6bae58c7d8a031f404dc72" translate="yes" xml:space="preserve">
          <source>This ref is unchanged since the last import or fetch, although the helper cannot necessarily determine what value that produced.</source>
          <target state="translated">헬퍼가 생성 한 값을 반드시 결정할 수는 없지만 마지막 가져 오기 또는 가져 오기 이후이 참조는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e48a6f59fc5d06bf39a026582c3a2674a30ee86" translate="yes" xml:space="preserve">
          <source>This remote helper is transparently used by Git when you use commands such as &quot;git fetch &amp;lt;URL&amp;gt;&quot;, &quot;git clone &amp;lt;URL&amp;gt;&quot;, , &quot;git push &amp;lt;URL&amp;gt;&quot; or &quot;git remote add &amp;lt;nick&amp;gt; &amp;lt;URL&amp;gt;&quot;, where &amp;lt;URL&amp;gt; begins with &lt;code&gt;ext::&lt;/code&gt;. Examples:</source>
          <target state="translated">이 원격 헬퍼는 &quot;git fetch &amp;lt;URL&amp;gt;&quot;, &quot;git clone &amp;lt;URL&amp;gt;&quot;,, &quot;git push &amp;lt;URL&amp;gt;&quot;또는 &quot;git remote add &amp;lt;nick&amp;gt; &amp;lt;URL&amp;gt;&quot;과 같은 명령을 사용할 때 Git에서 투명하게 사용됩니다. &amp;lt;URL&amp;gt;은 &lt;code&gt;ext::&lt;/code&gt; 시작합니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="76e69f76fb018209940d2bd178b055119cc99cef" translate="yes" xml:space="preserve">
          <source>This remote helper uses the specified &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; to connect to a remote Git server.</source>
          <target state="translated">이 원격 헬퍼는 지정된 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 를 사용하여 원격 Git 서버에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="08f3058ad626936f077bcdb5101be9917b27eae0" translate="yes" xml:space="preserve">
          <source>This removes the &lt;code&gt;WIP&lt;/code&gt; commit from the commit history, and sets your working tree to the state just before you made that snapshot.</source>
          <target state="translated">커밋 기록에서 &lt;code&gt;WIP&lt;/code&gt; 커밋을 제거하고 작업 트리를 해당 스냅 샷을 만들기 직전의 상태로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6cde691b95501235edce70baf30f3d475a6f05af" translate="yes" xml:space="preserve">
          <source>This removes the file from the index while keeping it in the working directory.</source>
          <target state="translated">작업 디렉토리에 파일을 유지하면서 색인에서 파일을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="f2e99bc05d5874bb5e940e93689126e6c4aa347e" translate="yes" xml:space="preserve">
          <source>This resolves any number of heads, but the resulting tree of the merge is always that of the current branch head, effectively ignoring all changes from all other branches. It is meant to be used to supersede old development history of side branches. Note that this is different from the -Xours option to the &lt;code&gt;recursive&lt;/code&gt; merge strategy.</source>
          <target state="translated">이렇게하면 헤드 수를 확인할 수 있지만 병합의 결과 트리는 항상 현재 분기 헤드의 트리이므로 다른 모든 분기의 모든 변경 사항을 효과적으로 무시합니다. 사이드 브랜치의 오래된 개발 히스토리를 대체하는 데 사용됩니다. 이것은 -Xours 옵션과 &lt;code&gt;recursive&lt;/code&gt; 병합 전략 과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="053dd73bd0ed92de95c5b132a1b4a0308f96cd04" translate="yes" xml:space="preserve">
          <source>This resolves cases with more than two heads, but refuses to do a complex merge that needs manual resolution. It is primarily meant to be used for bundling topic branch heads together. This is the default merge strategy when pulling or merging more than one branch.</source>
          <target state="translated">이렇게하면 두 개 이상의 헤드가있는 케이스는 해결되지만 수동 해결이 필요한 복잡한 병합을 거부합니다. 주로 토픽 브랜치 헤드를 묶는 데 사용됩니다. 하나 이상의 브랜치를 가져 오거나 병합 할 때의 기본 병합 전략입니다.</target>
        </trans-unit>
        <trans-unit id="e1337ea8d65ee53d09143c99f1f587dd31c2d238" translate="yes" xml:space="preserve">
          <source>This results in:</source>
          <target state="translated">결과 :</target>
        </trans-unit>
        <trans-unit id="a3acfff86d0ac3c7e1c1af7dc1decad57125efa5" translate="yes" xml:space="preserve">
          <source>This runs &lt;code&gt;git fsck --unreachable&lt;/code&gt; using all the refs available in &lt;code&gt;refs/&lt;/code&gt;, optionally with additional set of objects specified on the command line, and prunes all unpacked objects unreachable from any of these head objects from the object database. In addition, it prunes the unpacked objects that are also found in packs by running &lt;code&gt;git prune-packed&lt;/code&gt;. It also removes entries from .git/shallow that are not reachable by any ref.</source>
          <target state="translated">이 명령은 &lt;code&gt;refs/&lt;/code&gt; 에서 사용 가능한 모든 &lt;code&gt;git fsck --unreachable&lt;/code&gt; 를 선택적으로 사용하여 git fsck --unreachable 을 실행 하고 , 선택적으로 명령 행에 지정된 추가 오브젝트 세트를 사용하여 오브젝트 데이터베이스에서 이러한 헤드 오브젝트에서 도달 할 수없는 모든 압축 해제 된 오브젝트를 프룬합니다. 또한 &lt;code&gt;git prune-packed&lt;/code&gt; 를 실행하여 팩에있는 압축 해제 된 객체를 제거 합니다. 또한 .git / shallow에서 참조에 도달 할 수없는 항목을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="66bb2cd044765c7338efb3b55d3b51e463e22970" translate="yes" xml:space="preserve">
          <source>This runs a virtual check-out and check-in of all three stages of a file when resolving a three-way merge. This option is meant to be used when merging branches with different clean filters or end-of-line normalization rules. See &quot;Merging branches with differing checkin/checkout attributes&quot; in &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">이렇게하면 3 방향 병합을 해결할 때 파일의 3 단계 모두에 대한 가상 체크 아웃 및 체크인이 실행됩니다. 이 옵션은 다른 클린 필터 또는 라인 끝 정규화 규칙을 사용하여 분기를 병합 할 때 사용됩니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]의&lt;/a&gt; &quot;체크인 / 체크 아웃 속성이 다른 분기 병합&quot; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d37cfee1983b15d675f4e1a4163b8c978a492421" translate="yes" xml:space="preserve">
          <source>This says &quot;include everything in root, but nothing two levels below root.&quot;</source>
          <target state="translated">이것은 &quot;모든 것을 루트에 포함하지만 루트 아래 두 수준 아래는 포함하지 않습니다.&quot;라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="b3bd580b61f2b6d754a6c049f07ff919549d1439" translate="yes" xml:space="preserve">
          <source>This says &quot;include everything in root, but nothing two levels below root.&quot; If we then add the folder &lt;code&gt;A/B/C&lt;/code&gt; as a recursive pattern, the folders &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;A/B&lt;/code&gt; are added as parent patterns. The resulting sparse-checkout file is now</source>
          <target state="translated">&quot;루트에는 모든 것을 포함하지만 루트 아래에 두 레벨은 포함되지 않습니다.&quot; 그런 다음 폴더 &lt;code&gt;A/B/C&lt;/code&gt; 를 재귀 패턴으로 추가하면 폴더 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;A/B&lt;/code&gt; 가 상위 패턴으로 추가됩니다. 결과 스파 스 체크 아웃 파일은 이제</target>
        </trans-unit>
        <trans-unit id="9f2fcd6a73ae4ce542d08fc5e7f799314e8e80fc" translate="yes" xml:space="preserve">
          <source>This script can be passed to &quot;git bisect run&quot; to find the commit that introduced a performance regression:</source>
          <target state="translated">이 스크립트는 &quot;git bisect run&quot;으로 전달되어 성능 회귀를 도입 한 커밋을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72c86095923977328df35910b245e776428b840b" translate="yes" xml:space="preserve">
          <source>This script is included in various scripts to supply routines to parse files under $GIT_DIR/remotes/ and $GIT_DIR/branches/ and configuration variables that are related to fetching, pulling and pushing.</source>
          <target state="translated">이 스크립트는 다양한 스크립트에 포함되어 $ GIT_DIR / remotes / 및 $ GIT_DIR / branches /에서 파일을 구문 분석하는 루틴과 페치, 풀 및 푸시와 관련된 구성 변수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0b782a6ea862c68f93c66ef721d84ace33a5ac1d" translate="yes" xml:space="preserve">
          <source>This script tries, as much as possible, to display the URLs and FILEs that are passed as arguments, as HTML pages in new tabs on an already opened web browser.</source>
          <target state="translated">이 스크립트는 이미 열려있는 웹 브라우저의 새 탭에 HTML 페이지로 인수로 전달 된 URL과 파일을 가능한 한 많이 표시하려고합니다.</target>
        </trans-unit>
        <trans-unit id="a405ee4e7ff4cc67a738558081388543481850c0" translate="yes" xml:space="preserve">
          <source>This section can also be used by those who respond to &lt;code&gt;git
request-pull&lt;/code&gt; or pull-request on GitHub (www.github.com) to integrate the work of others into their history. A sub-area lieutenant for a repository will act both as a participant and as an integrator.</source>
          <target state="translated">이 섹션은 또한 GitHub (www.github.com)에서 &lt;code&gt;git request-pull&lt;/code&gt; 또는 pull-request에 응답하는 사람들이 다른 사람의 작업을 역사에 통합 할 수 있습니다. 리포지토리의 하위 영역 중위는 참가자 및 통합 자 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="53af582e47690e9820cb012bdcbccf97b8def7d3" translate="yes" xml:space="preserve">
          <source>This section explains how to configure some common webservers to run gitweb. In all cases, &lt;code&gt;/path/to/gitweb&lt;/code&gt; in the examples is the directory you ran installed gitweb in, and contains &lt;code&gt;gitweb_config.perl&lt;/code&gt;.</source>
          <target state="translated">이 섹션에서는 gitweb을 실행하기 위해 일반적인 웹 서버를 구성하는 방법에 대해 설명합니다. 모든 예 에서, 예제의 &lt;code&gt;/path/to/gitweb&lt;/code&gt; 은 gitweb을 설치 한 디렉토리이며 &lt;code&gt;gitweb_config.perl&lt;/code&gt; 을 포함 합니다 .</target>
        </trans-unit>
        <trans-unit id="79c0f1f15a38eae1b5cc2a5e381bfbc844ef9486" translate="yes" xml:space="preserve">
          <source>This section is only included if a packfile section is also included in the response.</source>
          <target state="translated">이 섹션은 팩 파일 섹션이 응답에 포함 된 경우에만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f3cd5eb5a3885e012dabb05171cc566728c1791b" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git archive --remote&lt;/code&gt;. It is disabled by default, but a repository can enable it by setting &lt;code&gt;daemon.uploadarch&lt;/code&gt; configuration item to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git archive --remote&lt;/code&gt; 를 제공합니다 . 기본적으로 비활성화되어 있지만 저장소는 &lt;code&gt;daemon.uploadarch&lt;/code&gt; 구성 항목을 &lt;code&gt;true&lt;/code&gt; 로 설정하여 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1fc9be9532fca80163bd11748e3553d0b5b85a4" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git fetch-pack&lt;/code&gt; and &lt;code&gt;git ls-remote&lt;/code&gt; clients. It is enabled by default, but a repository can disable it by setting &lt;code&gt;daemon.uploadpack&lt;/code&gt; configuration item to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git fetch-pack&lt;/code&gt; 및 &lt;code&gt;git ls-remote&lt;/code&gt; 클라이언트를 제공합니다. 기본적으로 사용 가능하지만 저장소는 &lt;code&gt;daemon.uploadpack&lt;/code&gt; 구성 항목을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 사용 불가능하게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce507c3877f92fc6c1de609ca683d1e2a4e1b26f" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git fetch-pack&lt;/code&gt; and &lt;code&gt;git ls-remote&lt;/code&gt; clients. It is enabled by default, but a repository can disable it by setting this configuration item to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git fetch-pack&lt;/code&gt; 및 &lt;code&gt;git ls-remote&lt;/code&gt; 클라이언트를 제공합니다. 기본적으로 사용 가능하지만 저장소는이 구성 항목을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 사용 불가능하게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f25bae0e6df9b1b4a76a588d485b17d422e56c18" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git send-pack&lt;/code&gt; clients, allowing anonymous push. It is disabled by default, as there is &lt;code&gt;no&lt;/code&gt; authentication in the protocol (in other words, anybody can push anything into the repository, including removal of refs). This is solely meant for a closed LAN setting where everybody is friendly. This service can be enabled by setting &lt;code&gt;daemon.receivepack&lt;/code&gt; configuration item to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git send-pack&lt;/code&gt; 클라이언트를 제공하여 익명 푸시를 허용합니다. 프로토콜에 인증 이 &lt;code&gt;no&lt;/code&gt; 기본적으로 비활성화되어 있습니다. 즉, 심판 제거를 포함하여 모든 것을 저장소에 푸시 할 수 있습니다. 이것은 모두가 친숙한 닫힌 LAN 설정만을위한 것입니다. &lt;code&gt;daemon.receivepack&lt;/code&gt; 구성 항목을 &lt;code&gt;true&lt;/code&gt; 로 설정 하여이 서비스를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b2859849402fde4d51ffe73c129c97d00cb6083" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git send-pack&lt;/code&gt; clients, allowing push. It is disabled by default for anonymous users, and enabled by default for users authenticated by the web server. It can be disabled by setting this item to &lt;code&gt;false&lt;/code&gt;, or enabled for all users, including anonymous users, by setting it to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git send-pack&lt;/code&gt; 클라이언트에 서비스를 제공 하여 푸시를 허용합니다. 익명 사용자의 경우 기본적으로 비활성화되어 있으며 웹 서버에서 인증 된 사용자의 경우 기본적으로 활성화되어 있습니다. 이 항목을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 비활성화 하거나 익명 사용자를 포함한 모든 사용자가 &lt;code&gt;true&lt;/code&gt; 로 설정하여 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d789007e515492a9cc42830b12a07ff1db6d084" translate="yes" xml:space="preserve">
          <source>This serves Git clients older than version 1.6.6 that are unable to use the upload pack service. When enabled, clients are able to read any file within the repository, including objects that are no longer reachable from a branch but are still present. It is enabled by default, but a repository can disable it by setting this configuration item to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">업로드 팩 서비스를 사용할 수없는 버전 1.6.6 이전의 Git 클라이언트에 서비스를 제공합니다. 사용 가능한 경우 클라이언트는 더 이상 지점에서 도달 할 수 없지만 여전히 존재하는 오브젝트를 포함하여 저장소 내의 모든 파일을 읽을 수 있습니다. 기본적으로 사용 가능하지만 저장소는이 구성 항목을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 사용 불가능하게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5456200c93d8963943eca093573a9d8938a4ea5f" translate="yes" xml:space="preserve">
          <source>This sets GIT_SVN_ID (instead of using the environment). This allows the user to override the default refname to fetch from when tracking a single URL. The &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;dcommit&lt;/code&gt; commands no longer require this switch as an argument.</source>
          <target state="translated">환경을 사용하는 대신 GIT_SVN_ID를 설정합니다. 이를 통해 사용자는 단일 URL을 추적 할 때 가져올 기본 참조 이름을 재정의 할 수 있습니다. &lt;code&gt;log&lt;/code&gt; 및 &lt;code&gt;dcommit&lt;/code&gt; 명령은 더 이상 인수로이 스위치를 필요로하지 않는다.</target>
        </trans-unit>
        <trans-unit id="acb244d7aa46a820614aa10decb4464bc8ecabb6" translate="yes" xml:space="preserve">
          <source>This setting can be disabled by the &lt;code&gt;--no-notes&lt;/code&gt; option, overridden by the &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; environment variable, and overridden by the &lt;code&gt;--notes=&amp;lt;ref&amp;gt;&lt;/code&gt; option.</source>
          <target state="translated">이 설정은 &lt;code&gt;--no-notes&lt;/code&gt; 옵션 으로 비활성화 하고 &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; 환경 변수로 재정의하고 &lt;code&gt;--notes=&amp;lt;ref&amp;gt;&lt;/code&gt; 옵션으로 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8f435ef26eec94bd5c23846a74c0f4d57a87c8f" translate="yes" xml:space="preserve">
          <source>This setting can be overridden by passing the &lt;code&gt;--strategy&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;--strategy&lt;/code&gt; 옵션 을 전달하면이 설정을 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d273f23cd160340c4f9b3fbc5a088c0fc2c32be" translate="yes" xml:space="preserve">
          <source>This setting can be overridden by the &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; environment variable.</source>
          <target state="translated">이 설정은 &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; 환경 변수 로 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b28435a905552ea063d5203034696b428fdc0b87" translate="yes" xml:space="preserve">
          <source>This setting can be overridden with the &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; environment variable, which must be a colon separated list of refs or globs.</source>
          <target state="translated">이 설정은 &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; 환경 변수 로 재정의 할 수 있습니다.이 변수는 콜론으로 구분 된 참조 또는 글로브 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="45473aa6b3903d5487aab6b473bcf528e266cdec" translate="yes" xml:space="preserve">
          <source>This setting can be overridden with the &lt;code&gt;GIT_NOTES_REWRITE_MODE&lt;/code&gt; environment variable.</source>
          <target state="translated">이 설정은 &lt;code&gt;GIT_NOTES_REWRITE_MODE&lt;/code&gt; 환경 변수 로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39555b916eeeec115f6735665b5426bf964f4e52" translate="yes" xml:space="preserve">
          <source>This setting can be overridden with the &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; environment variable, which must be a colon separated list of refs or globs.</source>
          <target state="translated">이 설정은 &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; 환경 변수 로 재정의 할 수 있으며 , 환경 변수는 콜론으로 구분 된 참조 또는 글로브 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d17d74e5aa80b06bd416eb43f1c510767efc6dc8" translate="yes" xml:space="preserve">
          <source>This setting defaults to &quot;refs/notes/commits&quot;, and it can be overridden by the &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; environment variable. See &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt;.</source>
          <target state="translated">이 설정은 기본적으로 &quot;refs / notes / commits&quot;이며 &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 . &lt;a href=&quot;git-notes&quot;&gt;git-notes [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="843f7e48b1e3c030c426060d83a399e29388c249" translate="yes" xml:space="preserve">
          <source>This setting forces Git to normalize line endings for this file on checkin and convert them to CRLF when the file is checked out.</source>
          <target state="translated">이 설정은 Git이 체크인시이 파일의 줄 끝을 정규화하고 파일이 체크 아웃 될 때 CRLF로 변환하도록합니다.</target>
        </trans-unit>
        <trans-unit id="8c7bb001c250cfdf4247d252deb09b8b2c2a2839" translate="yes" xml:space="preserve">
          <source>This setting forces Git to normalize line endings to LF on checkin and prevents conversion to CRLF when the file is checked out.</source>
          <target state="translated">이 설정은 Git이 체크인시 줄 끝을 LF로 정규화하고 파일이 체크 아웃 될 때 CRLF 로의 변환을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="886fc853da603148f91948f5793a0d1be70dc28a" translate="yes" xml:space="preserve">
          <source>This setting is automatically guessed by &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; when the repository was created. By default a repository that ends in &quot;/.git&quot; is assumed to be not bare (bare = false), while all other repositories are assumed to be bare (bare = true).</source>
          <target state="translated">이 설정은 리포지토리가 생성 될 때 &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-init&quot;&gt;git-init [1]에&lt;/a&gt; 의해 자동으로 추측됩니다 . 기본적으로 &quot;/.git&quot;로 끝나는 리포지토리는 베어 (bare = false) 인 것으로 가정하고 다른 모든 리포지토리는 베어 (bare = true) 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="a32da40367d476cb817ba2cfa99cb18bc04a7b3a" translate="yes" xml:space="preserve">
          <source>This setting overrides the default of the &lt;code&gt;--cleanup&lt;/code&gt; option in &lt;code&gt;git commit&lt;/code&gt;. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for details. Changing the default can be useful when you always want to keep lines that begin with comment character &lt;code&gt;#&lt;/code&gt; in your log message, in which case you would do &lt;code&gt;git config commit.cleanup whitespace&lt;/code&gt; (note that you will have to remove the help lines that begin with &lt;code&gt;#&lt;/code&gt; in the commit log template yourself, if you do this).</source>
          <target state="translated">이 설정 은 &lt;code&gt;git commit&lt;/code&gt; 의 &lt;code&gt;--cleanup&lt;/code&gt; 옵션 의 기본값보다 우선합니다 . 자세한 내용은 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 을 참조하십시오. 당신은 항상 주석 문자로 시작하는 라인을 유지하려는 경우 기본값을 변경하면 유용 할 수 있습니다 &lt;code&gt;#&lt;/code&gt; 당신이 할 것이 경우 로그 메시지를, &lt;code&gt;git config commit.cleanup whitespace&lt;/code&gt; (주 당신은 시작 도움말 라인을 제거해야 할 것 커밋 로그 템플릿에 &lt;code&gt;#&lt;/code&gt; 을 입력하면됩니다.</target>
        </trans-unit>
        <trans-unit id="e85001143ab4f6109a8db79b80d46592a3792b5e" translate="yes" xml:space="preserve">
          <source>This setting should be set to a comma-separated list of color and date settings, starting and ending with a color, the dates should be set from oldest to newest. The metadata will be colored given the colors if the line was introduced before the given timestamp, overwriting older timestamped colors.</source>
          <target state="translated">이 설정은 쉼표로 구분 된 색상 및 날짜 설정 목록으로 설정해야하며 색상으로 시작하고 끝나는 날짜는 가장 오래된 날짜부터 최신 날짜로 설정해야합니다. 주어진 타임 스탬프 이전에 라인이 도입 된 경우 메타 데이터에 색상이 지정되어 오래된 타임 스탬프 된 색상을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="1b39995bc064271da90ffd3401f4ace36766db6f" translate="yes" xml:space="preserve">
          <source>This setting writes a JSON-based format that is suited for machine interpretation. See &lt;code&gt;GIT_TRACE2&lt;/code&gt; for available trace output options and &lt;a href=&quot;api-trace2&quot;&gt;Trace2 documentation&lt;/a&gt; for full details.</source>
          <target state="translated">이 설정은 기계 해석에 적합한 JSON 기반 형식을 작성합니다. 사용 가능한 추적 출력 옵션 은 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 및 자세한 내용은 &lt;a href=&quot;api-trace2&quot;&gt;Trace2 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d727921c238e28668ffb0dd7e4775077e3d6b368" translate="yes" xml:space="preserve">
          <source>This should be a colon-separated list of absolute paths. If set, it is a list of directories that Git should not chdir up into while looking for a repository directory (useful for excluding slow-loading network directories). It will not exclude the current working directory or a GIT_DIR set on the command line or in the environment. Normally, Git has to read the entries in this list and resolve any symlink that might be present in order to compare them with the current directory. However, if even this access is slow, you can add an empty entry to the list to tell Git that the subsequent entries are not symlinks and needn&amp;rsquo;t be resolved; e.g., &lt;code&gt;GIT_CEILING_DIRECTORIES=/maybe/symlink::/very/slow/non/symlink&lt;/code&gt;.</source>
          <target state="translated">콜론으로 구분 된 절대 경로 목록이어야합니다. 설정된 경우, 리포지토리 디렉토리를 찾는 동안 Git이 chdir하지 않아야하는 디렉토리 목록입니다 (느리게로드되는 네트워크 디렉토리 제외 제외). 현재 작업 디렉토리 또는 명령 행 또는 환경에 설정된 GIT_DIR을 제외하지 않습니다. 일반적으로 Git은이 목록의 항목을 읽고 현재 디렉토리와 비교하기 위해 존재할 수있는 symlink를 해결해야합니다. 그러나이 액세스조차 느리면 빈 항목을 목록에 추가하여 Git에 후속 항목이 심볼릭 링크가 아니므로 해결할 필요가 없음을 알릴 수 있습니다. 예를 들어, &lt;code&gt;GIT_CEILING_DIRECTORIES=/maybe/symlink::/very/slow/non/symlink&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02391ad98329bedcf2ddfbe7ebdef774e4e7cc67" translate="yes" xml:space="preserve">
          <source>This should help you to submit patches inline using KMail.</source>
          <target state="translated">KMail을 사용하여 인라인 패치를 제출하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="dc65a8c75ec971d079e04ac05264e8ee2fb908c8" translate="yes" xml:space="preserve">
          <source>This should make &quot;--pretty=oneline&quot; a whole lot more readable for people using 80-column terminals.</source>
          <target state="translated">이렇게하면 80 열 터미널을 사용하는 사람들이 &quot;--pretty = oneline&quot;을 훨씬 더 읽기 쉽게 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="cda899a68420b48633046b1cef20e4960b467a9e" translate="yes" xml:space="preserve">
          <source>This should make it easy to look up svn log messages when svn users refer to -r/--revision numbers.</source>
          <target state="translated">svn 사용자가 -r /-개정 번호를 참조 할 때 svn 로그 메시지를 쉽게 찾을 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3fce0b9f9a8369808848ec3f066c1735323bb111" translate="yes" xml:space="preserve">
          <source>This should not be confused with the &lt;code&gt;ours&lt;/code&gt; merge strategy, which does not even look at what the other tree contains at all. It discards everything the other tree did, declaring &lt;code&gt;our&lt;/code&gt; history contains all that happened in it.</source>
          <target state="translated">이것은 &lt;code&gt;ours&lt;/code&gt; 병합 전략 과 혼동되어서는 안되며 , 다른 트리가 무엇을 포함하고 있는지조차 보지 못합니다. 그것은 다른 나무가 한 모든 것을 버리고, &lt;code&gt;our&lt;/code&gt; 역사는 그 안에 일어난 모든 것을 포함 한다고 선언 합니다.</target>
        </trans-unit>
        <trans-unit id="70d0ce2d7e7f48cdf303b28228ad271bde0b97ac" translate="yes" xml:space="preserve">
          <source>This shows that our resolved version deleted &quot;Hello world&quot; from the first parent, deleted &quot;Goodbye&quot; from the second parent, and added &quot;Goodbye world&quot;, which was previously absent from both.</source>
          <target state="translated">이는 해결 된 버전이 첫 번째 상위에서 &quot;Hello world&quot;를 삭제하고 두 번째 상위에서 &quot;Goodbye&quot;를 삭제 한 후 이전에 둘 다 없었던 &quot;Goodbye world&quot;를 추가했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e0fbc89a9eb1f686d88b41839c951cd18b86bf5e" translate="yes" xml:space="preserve">
          <source>This shows that you can do without a run script if you write the test on a single line.</source>
          <target state="translated">테스트를 한 줄에 작성하면 실행 스크립트 없이도 할 수 있음이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f580a082428b40358ee35f346bb87b38bbd6e3f8" translate="yes" xml:space="preserve">
          <source>This shows the change between HEAD and index (i.e. what will be committed if you say &lt;code&gt;git commit&lt;/code&gt;), and between index and working tree files (i.e. what you could stage further before &lt;code&gt;git commit&lt;/code&gt; using &lt;code&gt;git add&lt;/code&gt;) for each path. A sample output looks like this:</source>
          <target state="translated">이것은 각 경로에 대한 HEAD와 인덱스 사이의 변경 (즉 , &lt;code&gt;git commit&lt;/code&gt; 이라고하면 커밋 될 것 )과 인덱스와 작업 트리 파일 사이 (즉, &lt;code&gt;git add&lt;/code&gt; 를 사용하여 git &lt;code&gt;git commit&lt;/code&gt; 전에 추가로 스테이징 할 수있는 것 )를 보여줍니다. 샘플 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cdedf9c4235065dcc3b6a065543c259879fefa6b" translate="yes" xml:space="preserve">
          <source>This shows the files and directories to be deleted and issues an &quot;Input ignore patterns&amp;gt;&amp;gt;&quot; prompt. You can input space-separated patterns to exclude files and directories from deletion. E.g. &quot;*.c *.h&quot; will excludes files end with &quot;.c&quot; and &quot;.h&quot; from deletion. When you are satisfied with the filtered result, press ENTER (empty) back to the main menu.</source>
          <target state="translated">삭제 될 파일 및 디렉토리가 표시되고 &quot;Input ignore patterns &amp;gt;&amp;gt;&quot;프롬프트가 표시됩니다. 공백으로 구분 된 패턴을 입력하여 파일 및 디렉토리를 삭제에서 제외 할 수 있습니다. 예를 들어 &quot;* .c * .h&quot;는 &quot;.c&quot;및 &quot;.h&quot;로 끝나는 파일을 삭제에서 제외합니다. 필터링 된 결과가 만족 스러우면 ENTER (빈)를 다시 기본 메뉴로 누르십시오.</target>
        </trans-unit>
        <trans-unit id="d76da1518821bfa115def32fd19d8e8b1e73d979" translate="yes" xml:space="preserve">
          <source>This shows the files and directories to be deleted and issues an &quot;Select items to delete&amp;gt;&amp;gt;&quot; prompt. When the prompt ends with double &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; like this, you can make more than one selection, concatenated with whitespace or comma. Also you can say ranges. E.g. &quot;2-5 7,9&quot; to choose 2,3,4,5,7,9 from the list. If the second number in a range is omitted, all remaining items are selected. E.g. &quot;7-&quot; to choose 7,8,9 from the list. You can say &lt;code&gt;*&lt;/code&gt; to choose everything. Also when you are satisfied with the filtered result, press ENTER (empty) back to the main menu.</source>
          <target state="translated">삭제 될 파일 및 디렉토리가 표시되고 &quot;삭제할 항목 선택 &amp;gt;&amp;gt;&quot;프롬프트가 표시됩니다. 프롬프트가 이와 같이 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 로 끝나는 경우 공백이나 쉼표로 연결된 둘 이상의 선택을 할 수 있습니다. 또한 범위를 말할 수 있습니다. 예를 들어 &quot;2-5 7,9&quot;는 목록에서 2,3,4,5,7,9를 선택합니다. 범위의 두 번째 숫자가 생략되면 나머지 모든 항목이 선택됩니다. 예를 들어 &quot;7-&quot;을 사용하여 목록에서 7,8,9를 선택하십시오. &lt;code&gt;*&lt;/code&gt; 라고 말하면 모든 것을 선택할 수 있습니다 . 필터링 된 결과가 만족 스러우면 ENTER (빈)를 다시 기본 메뉴로 누르십시오.</target>
        </trans-unit>
        <trans-unit id="53f59db63b45945049b0fe262d831991c1cb4a8d" translate="yes" xml:space="preserve">
          <source>This shows the status information and issues an &quot;Update&amp;gt;&amp;gt;&quot; prompt. When the prompt ends with double &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, you can make more than one selection, concatenated with whitespace or comma. Also you can say ranges. E.g. &quot;2-5 7,9&quot; to choose 2,3,4,5,7,9 from the list. If the second number in a range is omitted, all remaining patches are taken. E.g. &quot;7-&quot; to choose 7,8,9 from the list. You can say &lt;code&gt;*&lt;/code&gt; to choose everything.</source>
          <target state="translated">상태 정보가 표시되고 &quot;Update &amp;gt;&amp;gt;&quot;프롬프트가 표시됩니다. 프롬프트가 double &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 으로 끝나면 공백이나 쉼표로 연결된 둘 이상의 선택을 할 수 있습니다. 또한 범위를 말할 수 있습니다. 예를 들어 &quot;2-5 7,9&quot;는 목록에서 2,3,4,5,7,9를 선택합니다. 범위의 두 번째 숫자를 생략하면 나머지 모든 패치가 사용됩니다. 예를 들어 &quot;7-&quot;을 사용하여 목록에서 7,8,9를 선택하십시오. &lt;code&gt;*&lt;/code&gt; 라고 말하면 모든 것을 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="728eb7da1f0f1bff86889f4ac114a7967bd3817f" translate="yes" xml:space="preserve">
          <source>This snapshot is now stored in a temporary staging area which Git calls the &quot;index&quot;. You can permanently store the contents of the index in the repository with &lt;code&gt;git commit&lt;/code&gt;:</source>
          <target state="translated">이 스냅 샷은 이제 Git이 &quot;인덱스&quot;라고하는 임시 준비 영역에 저장됩니다. &lt;code&gt;git commit&lt;/code&gt; 을 사용하여 저장소에 색인의 내용을 영구적으로 저장할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dfa3a419f48a4609a0668c69a143f543612e713a" translate="yes" xml:space="preserve">
          <source>This solution is not 100% bulletproof, in the sense that if some project has a named ref (branch, tag) starting with &lt;code&gt;git/&lt;/code&gt;, then paths such as</source>
          <target state="translated">이 솔루션은 일부 프로젝트에 &lt;code&gt;git/&lt;/code&gt; 시작하는 명명 된 참조 (분기, 태그)가있는 경우 다음과 같은 경로 가 있다는 점에서 100 % 방탄이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="02da975953020f9ebbe3388889e8a8406f05d0c7" translate="yes" xml:space="preserve">
          <source>This step and the next one could be combined into a single step with &quot;checkout -b my2.6.14 v2.6.14&quot;.</source>
          <target state="translated">이 단계와 다음 단계는 &quot;checkout -b my2.6.14 v2.6.14&quot;를 사용하여 단일 단계로 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8693cc187fd5fbc9d2b5824a59520cb3030a07eb" translate="yes" xml:space="preserve">
          <source>This string config option provides a way to specify one of a few recommended schedules for background maintenance. This only affects which tasks are run during &lt;code&gt;git maintenance run --schedule=X&lt;/code&gt; commands, provided no &lt;code&gt;--task=&amp;lt;task&amp;gt;&lt;/code&gt; arguments are provided. Further, if a &lt;code&gt;maintenance.&amp;lt;task&amp;gt;.schedule&lt;/code&gt; config value is set, then that value is used instead of the one provided by &lt;code&gt;maintenance.strategy&lt;/code&gt;. The possible strategy strings are:</source>
          <target state="translated">이 문자열 구성 옵션은 백그라운드 유지 관리를위한 몇 가지 권장 일정 중 하나를 지정하는 방법을 제공합니다. 이는 &lt;code&gt;--task=&amp;lt;task&amp;gt;&lt;/code&gt; 인수가 제공 되지 않은 경우 &lt;code&gt;git maintenance run --schedule=X&lt;/code&gt; 명령 중에 실행되는 작업에만 영향을줍니다 . 또한 &lt;code&gt;maintenance.&amp;lt;task&amp;gt;.schedule&lt;/code&gt; 구성 값이 설정된 경우 &lt;code&gt;maintenance.strategy&lt;/code&gt; 에서 제공하는 값 대신 해당 값이 사용됩니다 . 가능한 전략 문자열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b0b980e437fd3274de63464aa9184e42833d899" translate="yes" xml:space="preserve">
          <source>This suffix is also accepted when spelled in uppercase, and means the same thing no matter the case.</source>
          <target state="translated">이 접미사는 대문자로 표기 할 때도 사용할 수 있으며 경우에 상관없이 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="01f381d8f83cae139b7e7ff06573574ebdbc8086" translate="yes" xml:space="preserve">
          <source>This supersedes the &lt;a href=&quot;#post-update&quot;&gt;&lt;em&gt;post-update&lt;/em&gt;&lt;/a&gt; hook in that it gets both old and new values of all the refs in addition to their names.</source>
          <target state="translated">이것은 이름뿐만 아니라 모든 심판의 오래된 값과 새로운 값을 모두 얻는다는 점에서 &lt;a href=&quot;#post-update&quot;&gt;&lt;em&gt;업데이트 후&lt;/em&gt;&lt;/a&gt; 후크를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="6339f7da558022ed0ae10f566dd01f30bb047e19" translate="yes" xml:space="preserve">
          <source>This synchronizes your public repository to match the named branch head (i.e. &lt;code&gt;master&lt;/code&gt; in this case) and objects reachable from them in your current repository.</source>
          <target state="translated">그러면 이름이 지정된 브랜치 헤드 ( 이 경우 &lt;code&gt;master&lt;/code&gt; )와 현재 저장소에서 액세스 할 수있는 오브젝트와 일치하도록 공용 저장소가 동기화 됩니다.</target>
        </trans-unit>
        <trans-unit id="0012e2584fc653cc03e6dda35ea11cbdc9f6c1a2" translate="yes" xml:space="preserve">
          <source>This syntax is only recognized if there are no slashes before the first colon. This helps differentiate a local path that contains a colon. For example the local path &lt;code&gt;foo:bar&lt;/code&gt; could be specified as an absolute path or &lt;code&gt;./foo:bar&lt;/code&gt; to avoid being misinterpreted as an ssh url.</source>
          <target state="translated">이 구문은 첫 번째 콜론 앞에 슬래시가없는 경우에만 인식됩니다. 이것은 콜론을 포함하는 로컬 경로를 구별하는 데 도움이됩니다. 예를 들어 로컬 경로 &lt;code&gt;foo:bar&lt;/code&gt; 를 절대 경로로 지정하거나 &lt;code&gt;./foo:bar&lt;/code&gt; 를 지정 하여 ssh url로 잘못 해석되지 않도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f5d9872e03f1e6dd55415fa2249d9c84ea6f738" translate="yes" xml:space="preserve">
          <source>This takes a text file each of whose lines is a shell glob pattern. Filepairs that match a glob pattern on an earlier line in the file are output before ones that match a later line, and filepairs that do not match any glob pattern are output last.</source>
          <target state="translated">이것은 각 줄이 쉘 글로브 패턴 인 텍스트 파일을 가져옵니다. 파일의 이전 행에서 glob 패턴과 일치하는 파일 쌍은 이후 행과 일치하는 파일 쌍보다 먼저 출력되고 glob 패턴과 일치하지 않는 파일 쌍은 마지막으로 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="b169549655fddd825e67d14c1591493d6ac0be03" translate="yes" xml:space="preserve">
          <source>This target is intended to be more of a summary (like GIT_TRACE) and less detailed than the other targets. It ignores thread, region, and data messages, for example.</source>
          <target state="translated">이 목표는 GIT_TRACE와 같은 요약 일뿐 아니라 다른 목표보다 상세하지 않습니다. 예를 들어 스레드, 영역 및 데이터 메시지는 무시합니다.</target>
        </trans-unit>
        <trans-unit id="49bec15344e0cef74269dabec868d060f4c1b07d" translate="yes" xml:space="preserve">
          <source>This tells the bisect process that no commit after &lt;code&gt;v2.5&lt;/code&gt;, up to and including &lt;code&gt;v2.6&lt;/code&gt;, should be tested.</source>
          <target state="translated">이것은 &lt;code&gt;v2.5&lt;/code&gt; 이후의 커밋이 &lt;code&gt;v2.6&lt;/code&gt; 이하의 커밋을 테스트 하지 않아야한다는 bisect 프로세스를 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="1842bab1269e00a8bf77d06ee23570861225cc48" translate="yes" xml:space="preserve">
          <source>This tells the bisect process that the commits between &lt;code&gt;v2.5&lt;/code&gt; and &lt;code&gt;v2.6&lt;/code&gt; (inclusive) should be skipped.</source>
          <target state="translated">이것은 vsect 프로세스에 &lt;code&gt;v2.5&lt;/code&gt; 와 &lt;code&gt;v2.6&lt;/code&gt; 사이의 커밋을 건너 뛰어야한다는 것을 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="fb42c5eea9f7afe3662a07fd6af3c3105ab04e8f" translate="yes" xml:space="preserve">
          <source>This tells you that the immediately following version of the file was &quot;newsha&quot;, and that the immediately preceding version was &quot;oldsha&quot;. You also know the commit messages that went with the change from oldsha to 4b9458b and with the change from 4b9458b to newsha.</source>
          <target state="translated">이것은 파일의 바로 다음 버전은 &quot;newsha&quot;이고 바로 이전 버전은 &quot;oldsha&quot;임을 나타냅니다. 또한 oldsha에서 4b9458b로 변경하고 4b9458b에서 newsha로 변경 한 커밋 메시지도 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="055a35e65dbf599ed555247ef03e1960ff509b55" translate="yes" xml:space="preserve">
          <source>This tool is invoked via the typical Git setup process, which means that in some cases, it might not be able to launch - for example, if a relevant config file is unreadable. In this kind of scenario, it may be helpful to manually gather the kind of information listed above when manually asking for help.</source>
          <target state="translated">이 도구는 일반적인 Git 설정 프로세스를 통해 호출됩니다. 즉, 관련 구성 파일을 읽을 수없는 경우와 같이 경우에 따라 시작하지 못할 수도 있습니다. 이러한 종류의 시나리오에서는 수동으로 도움을 요청할 때 위에 나열된 종류의 정보를 수동으로 수집하는 것이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f1179423f3ea23a6c9e525ef159db41c1155b6a" translate="yes" xml:space="preserve">
          <source>This transformation is used to detect renames and copies, and is controlled by the -M option (to detect renames) and the -C option (to detect copies as well) to the &lt;code&gt;git diff-*&lt;/code&gt; commands. If the input contained these filepairs:</source>
          <target state="translated">이 변환은 이름 변경 및 사본을 감지하는 데 사용되며 -M 옵션 (이름 변경을 감지) 및 -C 옵션 (사본도 감지)에 의해 &lt;code&gt;git diff-*&lt;/code&gt; 명령으로 제어됩니다. 입력에 이러한 파일 쌍이 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="573190bccf8f2a4ea6fc33eedd23b4b8fc3f90f8" translate="yes" xml:space="preserve">
          <source>This transformation is used to merge filepairs broken by diffcore-break, and not transformed into rename/copy by diffcore-rename, back into a single modification. This always runs when diffcore-break is used.</source>
          <target state="translated">이 변환은 diffcore-break로 분리 된 파일 쌍을 병합하는 데 사용되며 diffcore-rename으로 이름 바꾸기 / 복사로 변환되지 않고 단일 수정으로 다시 변환됩니다. diffcore-break가 사용될 때 항상 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="448726c2164ad1aa28f4d84dcd657bc466764287" translate="yes" xml:space="preserve">
          <source>This transformation limits the set of filepairs to those that change specified strings between the preimage and the postimage in a certain way. -S&amp;lt;block of text&amp;gt; and -G&amp;lt;regular expression&amp;gt; options are used to specify different ways these strings are sought.</source>
          <target state="translated">이 변환은 파일 쌍 세트를 특정 방식으로 사전 이미지와 사후 이미지 사이에 지정된 문자열을 변경하는 파일 쌍으로 제한합니다. -S &amp;lt;텍스트 블록&amp;gt; 및 -G &amp;lt;정규 표현식&amp;gt; 옵션은 이러한 문자열을 찾는 다른 방법을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eb01f7c28a2e42a179d9ca76727e0a7db6bb8dce" translate="yes" xml:space="preserve">
          <source>This transport can be used for both uploading and downloading, and requires you to have a log-in privilege over &lt;code&gt;ssh&lt;/code&gt; to the remote machine. It finds out the set of objects the other side lacks by exchanging the head commits both ends have and transfers (close to) minimum set of objects. It is by far the most efficient way to exchange Git objects between repositories.</source>
          <target state="translated">이 전송은 업로드 및 다운로드에 모두 사용될 수 있으며 원격 시스템에 대한 &lt;code&gt;ssh&lt;/code&gt; 를 통한 로그인 권한이 필요합니다 . 헤드 커밋을 교환하여 다른쪽에없는 개체 집합을 찾은 다음 최소 개체 집합에 가깝게 전송합니다. 리포지토리간에 Git 객체를 교환하는 가장 효율적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="1e93313475dc2966a9b364d25d3e63ddb92cd35d" translate="yes" xml:space="preserve">
          <source>This transport is the same as SSH transport but uses &lt;code&gt;sh&lt;/code&gt; to run both ends on the local machine instead of running other end on the remote machine via &lt;code&gt;ssh&lt;/code&gt;.</source>
          <target state="translated">이 전송은 SSH 전송과 동일하지만 &lt;code&gt;ssh&lt;/code&gt; 를 통해 원격 시스템에서 다른 쪽 끝을 실행하는 대신 &lt;code&gt;sh&lt;/code&gt; 를 사용 하여 로컬 시스템에서 양 끝을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="187c060b77919e40b0db07be6c4444d6bedf0f1f" translate="yes" xml:space="preserve">
          <source>This transport was designed for anonymous downloading. Like SSH transport, it finds out the set of objects the downstream side lacks and transfers (close to) minimum set of objects.</source>
          <target state="translated">이 전송은 익명 다운로드 용으로 설계되었습니다. SSH 전송과 마찬가지로 다운 스트림 측에없는 개체 집합을 찾아 최소 개체 집합에 가깝게 전송합니다.</target>
        </trans-unit>
        <trans-unit id="a843c4941e9eb68216876c91a59842ae7d058faa" translate="yes" xml:space="preserve">
          <source>This tutorial explains how to import a new project into Git, make changes to it, and share changes with other developers.</source>
          <target state="translated">이 튜토리얼에서는 새 프로젝트를 Git으로 가져 와서 변경하고 다른 개발자와 변경 사항을 공유하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="586b98337ae35b657ccc9687b72106b49b3b174b" translate="yes" xml:space="preserve">
          <source>This tutorial explains how to use the &quot;core&quot; Git commands to set up and work with a Git repository.</source>
          <target state="translated">이 튜토리얼에서는 &quot;core&quot;Git 명령을 사용하여 Git 저장소를 설정하고 작업하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4f3b7287fc4739a451de38537fb0637003a134c1" translate="yes" xml:space="preserve">
          <source>This tutorial should be enough to perform basic distributed revision control for your projects. However, to fully understand the depth and power of Git you need to understand two simple ideas on which it is based:</source>
          <target state="translated">이 학습서는 프로젝트에 대한 기본 분산 개정 제어를 수행하기에 충분해야합니다. 그러나 Git의 깊이와 힘을 완전히 이해하려면 그 기반이되는 두 가지 간단한 아이디어를 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="50b7797bad77b49520127714ff8a716873aad978" translate="yes" xml:space="preserve">
          <source>This updates (or creates, as necessary) branches &lt;code&gt;pu&lt;/code&gt; and &lt;code&gt;tmp&lt;/code&gt; in the local repository by fetching from the branches (respectively) &lt;code&gt;pu&lt;/code&gt; and &lt;code&gt;maint&lt;/code&gt; from the remote repository.</source>
          <target state="translated">이는 원격 저장소에서 분기 (각각) &lt;code&gt;pu&lt;/code&gt; 및 &lt;code&gt;maint&lt;/code&gt; 를 가져와 로컬 저장소에서 분기 &lt;code&gt;pu&lt;/code&gt; 및 &lt;code&gt;tmp&lt;/code&gt; 를 업데이트 (또는 필요에 따라 작성 ) 합니다.</target>
        </trans-unit>
        <trans-unit id="3e7d31bbe83aa073e1058fe02ef8026a34345709" translate="yes" xml:space="preserve">
          <source>This updates (or creates, as necessary) branches &lt;code&gt;seen&lt;/code&gt; and &lt;code&gt;tmp&lt;/code&gt; in the local repository by fetching from the branches (respectively) &lt;code&gt;seen&lt;/code&gt; and &lt;code&gt;maint&lt;/code&gt; from the remote repository.</source>
          <target state="translated">이 업데이트 (또는 필요에 따라 생성) 분기 &lt;code&gt;seen&lt;/code&gt; 및 &lt;code&gt;tmp&lt;/code&gt; 지점으로부터 인출하여 로컬 저장소는 (각각) &lt;code&gt;seen&lt;/code&gt; 하고 &lt;code&gt;maint&lt;/code&gt; 원격 저장소.</target>
        </trans-unit>
        <trans-unit id="70ac0b727096d7231e8fdcdd112d1a04551c8ca8" translate="yes" xml:space="preserve">
          <source>This used to be the default, but not since Git 2.0 (&lt;code&gt;simple&lt;/code&gt; is the new default).</source>
          <target state="translated">이것은 기본값이지만 Git 2.0 이후는 아닙니다 ( &lt;code&gt;simple&lt;/code&gt; 것이 새로운 기본값입니다).</target>
        </trans-unit>
        <trans-unit id="fd75f35034e73b98112aaaf4198ee488b9e51804" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;--interactive&lt;/code&gt; machinery internally, but combining it with the &lt;code&gt;--interactive&lt;/code&gt; option explicitly is generally not a good idea unless you know what you are doing (see BUGS below).</source>
          <target state="translated">이것은 &lt;code&gt;--interactive&lt;/code&gt; 기계를 내부적으로 사용하지만 &lt;code&gt;--interactive&lt;/code&gt; 옵션과 명시 적으로 결합하는 것은 자신이 무엇을하고 있는지 알지 않는 한 일반적으로 좋은 생각이 아닙니다 (아래 버그 참조).</target>
        </trans-unit>
        <trans-unit id="665eaff82148d49a545a97a7903a8bf0d3754608" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;--interactive&lt;/code&gt; machinery internally, but it can be run without an explicit &lt;code&gt;--interactive&lt;/code&gt;.</source>
          <target state="translated">내부적으로 &lt;code&gt;--interactive&lt;/code&gt; 기계를 사용 하지만 명시적인 &lt;code&gt;--interactive&lt;/code&gt; 없이 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a59444b879ae5151f30b1cffe08974240ac7bdc" translate="yes" xml:space="preserve">
          <source>This uses the same two-dot range notation we saw earlier with &lt;code&gt;git log&lt;/code&gt;.</source>
          <target state="translated">이것은 이전에 &lt;code&gt;git log&lt;/code&gt; 와 동일한 2 점 범위 표기법을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="94dc29f5a82c88ac8ea06389eebe7535e89a6fb1" translate="yes" xml:space="preserve">
          <source>This value is true by default in a repository that has a working directory associated with it, and false by default in a bare repository.</source>
          <target state="translated">이 값은 연관된 작업 디렉토리가있는 저장소에서 기본적으로 true이고 기본 저장소에서 기본적으로 false입니다.</target>
        </trans-unit>
        <trans-unit id="73a34f84ecc165ae3643b28ecca4c6c41f197412" translate="yes" xml:space="preserve">
          <source>This variable can be used to restrict the permission bits of tar archive entries. The default is 0002, which turns off the world write bit. The special value &quot;user&quot; indicates that the archiving user&amp;rsquo;s umask will be used instead. See umask(2) and &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt;.</source>
          <target state="translated">이 변수는 tar 아카이브 항목의 권한 비트를 제한하는 데 사용할 수 있습니다. 기본값은 0002이며 월드 쓰기 비트를 끕니다. 특수 값 &quot;user&quot;는 보관 사용자의 umask가 대신 사용됨을 나타냅니다. umask (2) 및 &lt;a href=&quot;git-archive&quot;&gt;git-archive [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="63a384d932515032afb2060852ce18cd5598c9ca" translate="yes" xml:space="preserve">
          <source>This variable can be used to restrict the permission bits of tar archive entries. The default is 0002, which turns off the world write bit. The special value &quot;user&quot; indicates that the archiving user&amp;rsquo;s umask will be used instead. See umask(2) for details. If &lt;code&gt;--remote&lt;/code&gt; is used then only the configuration of the remote repository takes effect.</source>
          <target state="translated">이 변수는 tar 아카이브 항목의 권한 비트를 제한하는 데 사용할 수 있습니다. 기본값은 0002이며 월드 쓰기 비트를 끕니다. 특수 값 &quot;user&quot;는 보관 사용자의 umask가 대신 사용됨을 나타냅니다. 자세한 내용은 umask (2)를 참조하십시오. 경우 &lt;code&gt;--remote&lt;/code&gt; 는 다음에 사용되는 원격 저장소의 구성만을 시행한다.</target>
        </trans-unit>
        <trans-unit id="0afce327e7d4311118de1c5dc2faa8fa7a291053" translate="yes" xml:space="preserve">
          <source>This variable controls the event target destination. It may be overridden by the &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; environment variable. The following table shows possible values.</source>
          <target state="translated">이 변수는 이벤트 대상 목적지를 제어합니다. &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; 환경 변수 로 대체 될 수 있습니다 . 다음 표는 가능한 값을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b3073c2a2c3930628fae47eb515e2fe5729910f0" translate="yes" xml:space="preserve">
          <source>This variable controls the normal target destination. It may be overridden by the &lt;code&gt;GIT_TRACE2&lt;/code&gt; environment variable. The following table shows possible values.</source>
          <target state="translated">이 변수는 일반 대상 목적지를 제어합니다. &lt;code&gt;GIT_TRACE2&lt;/code&gt; 환경 변수 로 대체 될 수 있습니다 . 다음 표는 가능한 값을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ab644894061fa15fc115b6d355d07c2965277303" translate="yes" xml:space="preserve">
          <source>This variable controls the performance target destination. It may be overridden by the &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; environment variable. The following table shows possible values.</source>
          <target state="translated">이 변수는 성능 목표 대상을 제어합니다. &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; 환경 변수 로 대체 될 수 있습니다 . 다음 표는 가능한 값을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="53008d90e6aae985c2e7839a77d7b54894ce429e" translate="yes" xml:space="preserve">
          <source>This variable controls the sort ordering of branches when displayed by &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;. Without the &quot;--sort=&amp;lt;value&amp;gt;&quot; option provided, the value of this variable will be used as the default. See &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt; field names for valid values.</source>
          <target state="translated">이 변수는 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]로&lt;/a&gt; 표시 될 때 분기의 정렬 순서를 제어합니다 . &quot;--sort = &amp;lt;value&amp;gt;&quot;옵션을 제공하지 않으면이 변수의 값이 기본값으로 사용됩니다. 유효한 값 은 &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt; 필드 이름을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ea1c7eb75a360c1f9f69915dbc32e427ddfb7ced" translate="yes" xml:space="preserve">
          <source>This variable controls the sort ordering of tags when displayed by &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;. Without the &quot;--sort=&amp;lt;value&amp;gt;&quot; option provided, the value of this variable will be used as the default.</source>
          <target state="translated">이 변수는 &lt;a href=&quot;git-tag&quot;&gt;git-tag [1]로&lt;/a&gt; 표시 될 때 태그의 정렬 순서를 제어합니다 . &quot;--sort = &amp;lt;value&amp;gt;&quot;옵션을 제공하지 않으면이 변수의 값이 기본값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c2680b6925a4a160ca8f3fee892cc23ec9be5f4f" translate="yes" xml:space="preserve">
          <source>This variable determines the default value for variables such as &lt;code&gt;color.diff&lt;/code&gt; and &lt;code&gt;color.grep&lt;/code&gt; that control the use of color per command family. Its scope will expand as more commands learn configuration to set a default for the &lt;code&gt;--color&lt;/code&gt; option. Set it to &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;never&lt;/code&gt; if you prefer Git commands not to use color unless enabled explicitly with some other configuration or the &lt;code&gt;--color&lt;/code&gt; option. Set it to &lt;code&gt;always&lt;/code&gt; if you want all output not intended for machine consumption to use color, to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt; (this is the default since Git 1.8.4) if you want such output to use color when written to the terminal.</source>
          <target state="translated">이 변수 는 명령 패밀리 당 색상 사용을 제어하는 &lt;code&gt;color.diff&lt;/code&gt; 및 &lt;code&gt;color.grep&lt;/code&gt; 와 같은 변수의 기본값을 결정합니다 . &lt;code&gt;--color&lt;/code&gt; 옵션 의 기본값을 설정하기 위해 더 많은 명령이 구성을 배우면 범위가 확장됩니다 . 로 설정하여 &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;never&lt;/code&gt; 당신은 다른 구성이나 명시 적으로 활성화하지 않는 한 망할 놈의 색상을 사용하지 않는 명령을 선호하지 않는 경우 &lt;code&gt;--color&lt;/code&gt; 옵션을 선택합니다. 로 설정하여 &lt;code&gt;always&lt;/code&gt; 모든 출력에 사용하는 색상에 기계 소비를위한 것이 아닙니다하려는 경우 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;auto&lt;/code&gt; (이 망할 놈의 1.8.4 이후 기본값) 터미널에 기록 할 때 사용하는 색상에 같은 출력을 원하는 경우.</target>
        </trans-unit>
        <trans-unit id="2eb6f1e33d90fc7fb4373fa1793932292fbc650d" translate="yes" xml:space="preserve">
          <source>This variable is the same as &lt;code&gt;transfer.hideRefs&lt;/code&gt;, but applies only to &lt;code&gt;receive-pack&lt;/code&gt; (and so affects pushes, but not fetches). An attempt to update or delete a hidden ref by &lt;code&gt;git push&lt;/code&gt; is rejected.</source>
          <target state="translated">이 변수는 &lt;code&gt;transfer.hideRefs&lt;/code&gt; 와 동일 하지만 &lt;code&gt;receive-pack&lt;/code&gt; 에만 적용 되므로 푸시에는 영향을 주지만 페치에는 영향을 미치지 않습니다. &lt;code&gt;git push&lt;/code&gt; 에 의해 숨겨진 참조를 업데이트하거나 삭제하려는 시도 는 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="763a368531eb9d8bc40e93c6334e049f21620c45" translate="yes" xml:space="preserve">
          <source>This variable is the same as &lt;code&gt;transfer.hideRefs&lt;/code&gt;, but applies only to &lt;code&gt;upload-pack&lt;/code&gt; (and so affects only fetches, not pushes). An attempt to fetch a hidden ref by &lt;code&gt;git fetch&lt;/code&gt; will fail. See also &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt;.</source>
          <target state="translated">이 변수는 &lt;code&gt;transfer.hideRefs&lt;/code&gt; 와 동일 하지만 &lt;code&gt;upload-pack&lt;/code&gt; 에만 적용 되므로 푸시는 아닌 페치에만 영향을 미칩니다. &lt;code&gt;git fetch&lt;/code&gt; 에 의해 숨겨진 참조를 가져 오려는 시도 는 실패합니다. &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="75aa35a44ffd767e8a239dc01347d150ce1e39ed" translate="yes" xml:space="preserve">
          <source>This variable matters only when using persistent web environments that serve multiple requests using single gitweb instance, like mod_perl, FastCGI or Plackup.</source>
          <target state="translated">이 변수는 mod_perl, FastCGI 또는 Plackup과 같은 단일 gitweb 인스턴스를 사용하여 여러 요청을 처리하는 영구 웹 환경을 사용하는 경우에만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="c0526214b5c55d639fefd6a92d93b97ec2455930" translate="yes" xml:space="preserve">
          <source>This variable specifies a shell command through which the tar output generated by &lt;code&gt;git archive&lt;/code&gt; should be piped. The command is executed using the shell with the generated tar file on its standard input, and should produce the final output on its standard output. Any compression-level options will be passed to the command (e.g., &quot;-9&quot;). An output file with the same extension as &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; will be use this format if no other format is given.</source>
          <target state="translated">이 변수는 &lt;code&gt;git archive&lt;/code&gt; 에 의해 생성 된 tar 출력 이 파이프되어야 하는 쉘 명령을 지정합니다 . 명령은 표준 입력에서 생성 된 tar 파일과 함께 쉘을 사용하여 실행되며 표준 출력에서 ​​최종 출력을 생성해야합니다. 모든 압축 수준 옵션이 명령에 전달됩니다 (예 : &quot;-9&quot;). 다른 형식을 지정하지 않으면 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 과 동일한 확장자를 가진 출력 파일 이이 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="99ffcf0d1fc58b3934082bac9786637cf3a8cdad" translate="yes" xml:space="preserve">
          <source>This view is similar to &lt;code&gt;shortlog&lt;/code&gt; view.</source>
          <target state="translated">이보기는 &lt;code&gt;shortlog&lt;/code&gt; 보기 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="16ae6576174eeb48325f0bfa3042bcb20d29d417" translate="yes" xml:space="preserve">
          <source>This was not the case in the initial release of this feature in v2.13.0, which only matched the realpath version. Configuration that wants to be compatible with the initial release of this feature needs to either specify only the realpath version, or both versions.</source>
          <target state="translated">v2.13.0에서이 기능의 초기 릴리스에서는 실제 경로 버전과 만 일치하지 않았습니다. 이 기능의 초기 릴리스와 호환 되려는 구성은 실제 경로 버전 만 지정하거나 두 버전을 모두 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7c8d457b197b5558b7abfe068bcd1974205f94ad" translate="yes" xml:space="preserve">
          <source>This was optional in prior versions of git, but now it is the default. You can use &lt;code&gt;--no-utf8&lt;/code&gt; to override this.</source>
          <target state="translated">이전 버전의 git에서는 선택 사항 이었지만 이제는 기본값입니다. &lt;code&gt;--no-utf8&lt;/code&gt; 을 사용 하여이를 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="314df942d006c94c85d3e8c8bfe0a0b8ef8308d1" translate="yes" xml:space="preserve">
          <source>This will again prompt you for a message describing the change, and then record a new version of the project.</source>
          <target state="translated">변경 사항을 설명하는 메시지가 다시 표시되고 새 버전의 프로젝트가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="53cca56aaa41c3093032e1d720cb620b22717e06" translate="yes" xml:space="preserve">
          <source>This will cache the result of running &quot;exif&quot; on each blob indefinitely. If you change the textconv config variable for a diff driver, Git will automatically invalidate the cache entries and re-run the textconv filter. If you want to invalidate the cache manually (e.g., because your version of &quot;exif&quot; was updated and now produces better output), you can remove the cache manually with &lt;code&gt;git update-ref -d refs/notes/textconv/jpg&lt;/code&gt; (where &quot;jpg&quot; is the name of the diff driver, as in the example above).</source>
          <target state="translated">이것은 각 blob에서 &quot;exif&quot;를 실행 한 결과를 무기한 캐시합니다. diff 드라이버의 textconv 구성 변수를 변경하면 Git은 자동으로 캐시 항목을 무효화하고 textconv 필터를 다시 실행합니다. 캐시를 수동으로 무효화하려면 (예 : &quot;exif&quot;버전이 업데이트되어 더 나은 출력을 생성하기 때문에) &lt;code&gt;git update-ref -d refs/notes/textconv/jpg&lt;/code&gt; 를 사용 하여 캐시를 수동으로 제거 할 수 있습니다 (여기서 &quot; jpg &quot;는 위의 예와 같이 diff 드라이버의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3d17cc7dd2b4aac7e00ecd2628dbb99eefd074c7" translate="yes" xml:space="preserve">
          <source>This will cause Git to generate &lt;code&gt;Binary files differ&lt;/code&gt; (or a binary patch, if binary patches are enabled) instead of a regular diff.</source>
          <target state="translated">이로 인해 Git 은 일반 diff 대신 &lt;code&gt;Binary files differ&lt;/code&gt; 을 생성 합니다 (또는 이진 패치가 활성화 된 경우 이진 패치).</target>
        </trans-unit>
        <trans-unit id="dac66330b2bd98fcf90352c4cbeba694c8f4feb3" translate="yes" xml:space="preserve">
          <source>This will check out the currently cached copy of &lt;code&gt;Makefile&lt;/code&gt; into the file &lt;code&gt;.merged-Makefile&lt;/code&gt;.</source>
          <target state="translated">현재 캐시 된 &lt;code&gt;Makefile&lt;/code&gt; 사본을 &lt;code&gt;.merged-Makefile&lt;/code&gt; 파일로 체크 아웃합니다 .</target>
        </trans-unit>
        <trans-unit id="9acb73cd9d17d8ef0d5dfd6af35ea9d0a50c12ab" translate="yes" xml:space="preserve">
          <source>This will create a new commit which undoes the change in HEAD. You will be given a chance to edit the commit message for the new commit.</source>
          <target state="translated">HEAD의 변경을 취소하는 새로운 커밋이 생성됩니다. 새 커밋에 대한 커밋 메시지를 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85437cd96f5cff3dd194d542498fd954d1bf1e01" translate="yes" xml:space="preserve">
          <source>This will define a remote called &quot;origin&quot; in the resulting repository that lets you fetch and pull from the bundle. The $GIT_DIR/config file in R2 will have an entry like this:</source>
          <target state="translated">결과 저장소에서 &quot;origin&quot;이라는 원격을 정의하여 번들에서 가져 와서 가져올 수 있습니다. R2의 $ GIT_DIR / config 파일에는 다음과 같은 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2986121c6e711f05b2ed0ba772dedbd8c66503ff" translate="yes" xml:space="preserve">
          <source>This will error out if $REV is empty or not a valid revision.</source>
          <target state="translated">$ REV가 비어 있거나 유효한 개정이 아닌 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c8b7e8566771f37a03bc25eaec95675ffe82ba31" translate="yes" xml:space="preserve">
          <source>This will export the whole repository and import it into the existing empty repository. Except for reencoding commits that are not in UTF-8, it would be a one-to-one mirror.</source>
          <target state="translated">전체 저장소를 내보내고 기존의 빈 저장소로 가져옵니다. UTF-8이 아닌 커밋을 다시 인코딩하는 것을 제외하고는 일대일 미러입니다.</target>
        </trans-unit>
        <trans-unit id="5f851e29f67384fe2f487309701055635453a02c" translate="yes" xml:space="preserve">
          <source>This will list what commits you must have in order to extract from the bundle and will error out if you do not have them.</source>
          <target state="translated">이것은 번들에서 추출하기 위해 필요한 커밋을 나열하고없는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7ed8616207d4b6e51bdcbe1e7b524863a0139782" translate="yes" xml:space="preserve">
          <source>This will open your editor with a list of steps to be taken to perform your rebase.</source>
          <target state="translated">리베이스를 수행하기 위해 수행 할 단계 목록이있는 편집기가 열립니다.</target>
        </trans-unit>
        <trans-unit id="e9e68cbb3d1c11da9ad7575ebecc630d58996f10" translate="yes" xml:space="preserve">
          <source>This will prompt you for a commit message. You&amp;rsquo;ve now stored the first version of your project in Git.</source>
          <target state="translated">커밋 메시지를 묻는 메시지가 나타납니다. 이제 Git에 프로젝트의 첫 번째 버전을 저장했습니다.</target>
        </trans-unit>
        <trans-unit id="9229da0c83ee0b71f5a22085b5f3b7e07e9ec55a" translate="yes" xml:space="preserve">
          <source>This will remove each of your commits from mywork, temporarily saving them as patches (in a directory named &lt;code&gt;.git/rebase-apply&lt;/code&gt;), update mywork to point at the latest version of origin, then apply each of the saved patches to the new mywork. The result will look like:</source>
          <target state="translated">이렇게하면 커밋이 mywork에서 제거되어 패치 ( &lt;code&gt;.git/rebase-apply&lt;/code&gt; 디렉토리에)로 임시 저장 되고 최신 버전의 원점을 가리 키도록 mywork를 업데이트 한 다음 저장된 각 패치를 새로운 mywork에 적용합니다 . 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c98be5284d00528a6b74a33ba778d044a767668" translate="yes" xml:space="preserve">
          <source>This will result in only b (a and c are cleared).</source>
          <target state="translated">결과적으로 b 만됩니다 (a와 c가 지워짐).</target>
        </trans-unit>
        <trans-unit id="6c3d93fc8322db7b61293784540f1a03e7fd486e" translate="yes" xml:space="preserve">
          <source>This will run &lt;code&gt;git -C &amp;lt;repo&amp;gt; maintenance run&lt;/code&gt; for each value &lt;code&gt;&amp;lt;repo&amp;gt;&lt;/code&gt; in the multi-valued config variable &lt;code&gt;maintenance.repo&lt;/code&gt;.</source>
          <target state="translated">그러면 다중 값 구성 변수 &lt;code&gt;maintenance.repo&lt;/code&gt; 의 각 값 &lt;code&gt;&amp;lt;repo&amp;gt;&lt;/code&gt; 에 대해 &lt;code&gt;git -C &amp;lt;repo&amp;gt; maintenance run&lt;/code&gt; 됩니다 .</target>
        </trans-unit>
        <trans-unit id="0385ed25689cd3e1167020ff6e8ba549d1603871" translate="yes" xml:space="preserve">
          <source>This will set the property &lt;code&gt;svn:keywords&lt;/code&gt; to &lt;code&gt;FreeBSD=%H&lt;/code&gt; for the file &lt;code&gt;devel/py-tipper/Makefile&lt;/code&gt;.</source>
          <target state="translated">그러면 &lt;code&gt;devel/py-tipper/Makefile&lt;/code&gt; 파일에 대해 &lt;code&gt;svn:keywords&lt;/code&gt; 속성 이 &lt;code&gt;FreeBSD=%H&lt;/code&gt; 로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="61383e31770f578e5ee86310440dccd09a4e5008" translate="yes" xml:space="preserve">
          <source>This will show &quot;refs/heads/master&quot; but also &quot;refs/remote/other-repo/master&quot;, if such references exists.</source>
          <target state="translated">&quot;참조 / 헤드 / 마스터&quot;뿐만 아니라 &quot;참조 / 리모트 / 기타 / 리포 / 마스터&quot;도 표시됩니다 (해당 참조가있는 경우).</target>
        </trans-unit>
        <trans-unit id="23dd2de32c54566f1df1adf9f6794600102b9c2b" translate="yes" xml:space="preserve">
          <source>This will start to clean, and you must confirm one by one in order to delete items. Please note that this action is not as efficient as the above two actions.</source>
          <target state="translated">청소가 시작되고 항목을 삭제하려면 하나씩 확인해야합니다. 이 조치는 위의 두 조치보다 효율적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b7bbd24afc1c6a470a80ef47d5171b33809ea28" translate="yes" xml:space="preserve">
          <source>This works for any of the supported update procedures (&lt;code&gt;--checkout&lt;/code&gt;, &lt;code&gt;--rebase&lt;/code&gt;, etc.). The only change is the source of the target SHA-1. For example, &lt;code&gt;submodule update --remote --merge&lt;/code&gt; will merge upstream submodule changes into the submodules, while &lt;code&gt;submodule update
--merge&lt;/code&gt; will merge superproject gitlink changes into the submodules.</source>
          <target state="translated">지원되는 모든 업데이트 절차 ( &lt;code&gt;--checkout&lt;/code&gt; , &lt;code&gt;--rebase&lt;/code&gt; 등)에 적용됩니다. 유일한 변경 사항은 대상 SHA-1의 소스입니다. 예를 들어, &lt;code&gt;submodule update --remote --merge&lt;/code&gt; 동안, 서브 모듈로 상향 서브 모듈의 변경 내용을 병합 할 &lt;code&gt;submodule update --merge&lt;/code&gt; 서브 모듈에 superproject gitlink 변경을 병합합니다.</target>
        </trans-unit>
        <trans-unit id="5a2ee7840b76b59e3aede30738fb578b292bc5f3" translate="yes" xml:space="preserve">
          <source>This works similarly to &lt;code&gt;svn update&lt;/code&gt; or &lt;code&gt;git pull&lt;/code&gt; except that it preserves linear history with &lt;code&gt;git rebase&lt;/code&gt; instead of &lt;code&gt;git merge&lt;/code&gt; for ease of dcommitting with &lt;code&gt;git svn&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;svn update&lt;/code&gt; 또는 &lt;code&gt;git pull&lt;/code&gt; 과 유사하게 작동 하지만 &lt;code&gt;git svn&lt;/code&gt; 으로 쉽게 커밋 &lt;code&gt;git merge&lt;/code&gt; 있도록 git merge 대신 &lt;code&gt;git rebase&lt;/code&gt; 로 선형 히스토리를 유지한다는 점을 제외하고 .</target>
        </trans-unit>
        <trans-unit id="5bc6c0e59c3e651570d66e12101e9a57040fd659" translate="yes" xml:space="preserve">
          <source>This would leave only one merge commit when your topic branch is finally ready and merged into the master branch. This merge would require you to resolve the conflict, introduced by the commits marked with &lt;code&gt;*&lt;/code&gt;. However, this conflict is often the same conflict you resolved when you created the test merge you blew away. &lt;code&gt;git rerere&lt;/code&gt; helps you resolve this final conflicted merge using the information from your earlier hand resolve.</source>
          <target state="translated">그러면 토픽 브랜치가 준비되고 마스터 브랜치로 병합 될 때 하나의 병합 커밋 만 남게됩니다. 이 병합은 &lt;code&gt;*&lt;/code&gt; 로 표시된 커밋에 의해 도입 된 충돌을 해결해야합니다 . 그러나이 충돌은 종종 테스트 병합을 만들 때 해결 한 충돌과 동일합니다. &lt;code&gt;git rerere&lt;/code&gt; 를 사용하면 이전에 해결 한 정보를 사용하여이 최종 충돌 병합을 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcd6f908de988995d9fff4cafd75d14bc0785c1a" translate="yes" xml:space="preserve">
          <source>This would leave the merge result in &lt;code&gt;hello.c~2&lt;/code&gt; file, along with conflict markers if there are conflicts. After verifying the merge result makes sense, you can tell Git what the final merge result for this file is by:</source>
          <target state="translated">그러면 충돌이있는 경우 병합 결과 가 충돌 마커와 함께 &lt;code&gt;hello.c~2&lt;/code&gt; 파일 에 남습니다 . 병합 결과가 올바른지 확인한 후 Git에이 파일의 최종 병합 결과가 무엇인지 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf5b7c750a4b16617dfd7cff20be48990a9d7985" translate="yes" xml:space="preserve">
          <source>This:</source>
          <target state="translated">This:</target>
        </trans-unit>
        <trans-unit id="ee3cacca7314105556d3050112f523980e59f973" translate="yes" xml:space="preserve">
          <source>Those snapshots aren&amp;rsquo;t necessarily all arranged in a single line from oldest to newest; instead, work may simultaneously proceed along parallel lines of development, called &lt;a href=&quot;#def_branch&quot;&gt;branches&lt;/a&gt;, which may merge and diverge.</source>
          <target state="translated">이러한 스냅 샷이 반드시 가장 오래된 것부터 가장 오래된 것까지 한 줄로 배열 된 것은 아닙니다. 대신, &lt;a href=&quot;#def_branch&quot;&gt;분기&lt;/a&gt; 라고하는 병렬 개발 라인을 따라 작업이 동시에 진행되어 병합 및 분기 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a5a53a50d0fbac4f3a27d9d2d5853146557d940" translate="yes" xml:space="preserve">
          <source>Though not required, it&amp;rsquo;s a good idea to begin the commit message with a single short (less than 50 character) line summarizing the change, followed by a blank line and then a more thorough description. The text up to the first blank line in a commit message is treated as the commit title, and that title is used throughout Git. For example, &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; turns a commit into email, and it uses the title on the Subject line and the rest of the commit in the body.</source>
          <target state="translated">필수 사항은 아니지만 변경 내용을 요약하는 짧은 한 줄 (50 자 미만)로 커밋 메시지를 시작한 다음 빈 줄과 자세한 설명으로 시작하는 것이 좋습니다. 커밋 메시지의 첫 번째 빈 줄까지의 텍스트는 커밋 제목으로 취급되며 해당 제목은 Git 전체에서 사용됩니다. 예를 들어, &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; 은 커밋을 전자 메일로 변환하고 제목 줄의 제목과 본문의 나머지 커밋을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fdd6ea0498f5dbe48e6926bc8c91e77146fa2184" translate="yes" xml:space="preserve">
          <source>Though, according to Wikipedia &lt;a href=&quot;#3&quot;&gt;[3]&lt;/a&gt;:</source>
          <target state="translated">그러나 Wikipedia에 따르면 &lt;a href=&quot;#3&quot;&gt;[3]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="18c9e3ce5bbbf77af11ba41f4d7a7d9b7a1aaa55" translate="yes" xml:space="preserve">
          <source>Thread Events</source>
          <target state="translated">스레드 이벤트</target>
        </trans-unit>
        <trans-unit id="8850eee2783cf53d0af71d524467316d7d06a850" translate="yes" xml:space="preserve">
          <source>Thread messages added to a thread-proc.</source>
          <target state="translated">스레드 메시지가 스레드 프로세스에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="1501e9d814d273ed34cc6b50f1b5e25add4ac049" translate="yes" xml:space="preserve">
          <source>Three other shorthands exist, particularly useful for merge commits, for naming a set that is formed by a commit and its parent commits.</source>
          <target state="translated">커밋과 그 부모 커밋으로 구성된 집합의 이름을 지정하기 위해 특히 병합 커밋에 유용한 세 가지 다른 속기는 존재합니다.</target>
        </trans-unit>
        <trans-unit id="8e23a87c8354d34eb4b513798d76048267e22ae4" translate="yes" xml:space="preserve">
          <source>Three steps:</source>
          <target state="translated">세 단계 :</target>
        </trans-unit>
        <trans-unit id="cf3d01be00b3333c6ca36b4d1bb0a1a1c357a43f" translate="yes" xml:space="preserve">
          <source>Throw-away integration</source>
          <target state="translated">버림받은 통합</target>
        </trans-unit>
        <trans-unit id="c4780f4837eebde8ca1de31df251ef05e2361eb2" translate="yes" xml:space="preserve">
          <source>Thunderbird</source>
          <target state="translated">Thunderbird</target>
        </trans-unit>
        <trans-unit id="d5e84648e0355ba1080675ff57a3c64a03a76a7c" translate="yes" xml:space="preserve">
          <source>Thunderbird in particular is known to be problematic. Thunderbird users may wish to visit this web page for more information: &lt;a href=&quot;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&quot;&gt;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&lt;/a&gt;</source>
          <target state="translated">썬더 버드는 특히 문제가있는 것으로 알려져 있습니다. 썬더 버드 사용자는이 웹 페이지를 방문하여 자세한 정보를 얻을 수 있습니다. &lt;a href=&quot;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&quot;&gt;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da473e9b687406079cfbc2672fddb50595865b5d" translate="yes" xml:space="preserve">
          <source>Thus we see that this tree has one file in it. The SHA-1 hash is a reference to that file&amp;rsquo;s data:</source>
          <target state="translated">따라서이 트리에는 하나의 파일이 있음을 알 수 있습니다. SHA-1 해시는 해당 파일의 데이터에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="309fb29079c2e5019b9d34cb235aee0452735a40" translate="yes" xml:space="preserve">
          <source>Thus you can, e.g., turn a library subdirectory into a repository of its own. Note the &lt;code&gt;--&lt;/code&gt; that separates &lt;code&gt;filter-branch&lt;/code&gt; options from revision options, and the &lt;code&gt;--all&lt;/code&gt; to rewrite all branches and tags.</source>
          <target state="translated">따라서 라이브러리 서브 디렉토리를 자체의 저장소로 전환 할 수 있습니다. 참고 &lt;code&gt;--&lt;/code&gt; 분리형의 것을 &lt;code&gt;filter-branch&lt;/code&gt; 개정 옵션 및에서 옵션을 &lt;code&gt;--all&lt;/code&gt; 은 모든 브랜치와 태그를 다시 작성합니다.</target>
        </trans-unit>
        <trans-unit id="d35ca4f0ad7715e9f69a7f979c2424eb99273503" translate="yes" xml:space="preserve">
          <source>Thus, the following command:</source>
          <target state="translated">따라서 다음 명령은</target>
        </trans-unit>
        <trans-unit id="77cc1ec67e1af48d92e062ee397960be200bdf58" translate="yes" xml:space="preserve">
          <source>Thus, we can provide O(log N) lookup time for any number of packfiles.</source>
          <target state="translated">따라서 여러 팩 파일에 대해 O (log N) 조회 시간을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae19d34e63a0724afdaaeabe3d0fe80af7f9e778" translate="yes" xml:space="preserve">
          <source>Time and date specified by the ISO 8601 standard, for example &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt;. The parser accepts a space instead of the &lt;code&gt;T&lt;/code&gt; character as well.</source>
          <target state="translated">ISO 8601 표준에 의해 지정된 시간과 날짜 (예 &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt; . 파서는 &lt;code&gt;T&lt;/code&gt; 문자 대신 공백을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="3919d9be78625e6edbfd2764a9b0e03204c6c677" translate="yes" xml:space="preserve">
          <source>Time and date specified by the ISO 8601 standard, for example &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt;. The parser accepts a space instead of the &lt;code&gt;T&lt;/code&gt; character as well. Fractional parts of a second will be ignored, for example &lt;code&gt;2005-04-07T22:13:13.019&lt;/code&gt; will be treated as &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt;.</source>
          <target state="translated">예를 들어, ISO 8601 표준에 의해 지정된 시간과 날짜 &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt; . 구문 분석기는 &lt;code&gt;T&lt;/code&gt; 문자 대신 공백을 허용합니다 . 초의 소수 부분은 무시됩니다. 예를 들어 &lt;code&gt;2005-04-07T22:13:13.019&lt;/code&gt; 는 &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt; 으로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="0bac72478f018c225224e8417f521a2dad6209d3" translate="yes" xml:space="preserve">
          <source>Time zone values can be &quot;local&quot; (for local time zone that browser uses), &quot;utc&quot; (what gitweb uses when JavaScript or this feature is disabled), or numerical time zones in the form of &quot;+/-HHMM&quot;, such as &quot;+0200&quot;.</source>
          <target state="translated">시간대 값은 &quot;local&quot;(브라우저가 사용하는 현지 시간대), &quot;utc&quot;(JavaScript 또는이 기능이 비활성화 된 경우 gitweb이 사용하는 것) 또는 &quot;+/- HHMM&quot;형식의 숫자 시간대 일 수 있습니다. &quot;+0200&quot;으로</target>
        </trans-unit>
        <trans-unit id="396a560fd1658574279d941c34737eda5359f4fc" translate="yes" xml:space="preserve">
          <source>Timeout (in seconds) between the moment the connection is established and the client request is received (typically a rather low value, since that should be basically immediate).</source>
          <target state="translated">연결이 설정되는 순간과 클라이언트 요청이 수신되는 시점 사이의 시간 초과 (초) : 일반적으로 즉각적으로 이루어져야하기 때문에 다소 낮은 값입니다.</target>
        </trans-unit>
        <trans-unit id="0ae2f4dfeb0fa0aaf2833b3c271308d2190a4162" translate="yes" xml:space="preserve">
          <source>Timeout (in seconds) for specific client sub-requests. This includes the time it takes for the server to process the sub-request and the time spent waiting for the next client&amp;rsquo;s request.</source>
          <target state="translated">특정 클라이언트 하위 요청에 대한 시간 초과 (초) 여기에는 서버가 하위 요청을 처리하는 데 걸리는 시간과 다음 클라이언트의 요청을 기다리는 데 걸린 시간이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ad6b83abe0aada0e5e6aec8e7e7470429fd4ee37" translate="yes" xml:space="preserve">
          <source>Tips and tricks</source>
          <target state="translated">팁과 요령</target>
        </trans-unit>
        <trans-unit id="d7242682d2f91b131962f45ed3706e536d3cdcc6" translate="yes" xml:space="preserve">
          <source>To &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; more than two &lt;a href=&quot;#def_branch&quot;&gt;branches&lt;/a&gt;.</source>
          <target state="translated">두 &lt;a href=&quot;#def_branch&quot;&gt;개&lt;/a&gt; 이상의 지점 을 &lt;a href=&quot;#def_merge&quot;&gt;병합&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f7305ba472ceab96976009902e7b731f8e52f311" translate="yes" xml:space="preserve">
          <source>To access refs, it&amp;rsquo;s best not to look inside &lt;code&gt;$GIT_DIR&lt;/code&gt; directly. Instead use commands such as &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt; or &lt;a href=&quot;git-update-ref&quot;&gt;git-update-ref[1]&lt;/a&gt; which will handle refs correctly.</source>
          <target state="translated">참조에 액세스하려면 &lt;code&gt;$GIT_DIR&lt;/code&gt; 내부를 직접 보지 않는 것이 가장 좋습니다 . 대신 &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-update-ref&quot;&gt;git-update-ref [1]&lt;/a&gt; 와 같은 명령을 사용하여 참조를 올바르게 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="7c181af3380fe2a4df836df7796a5de6ef8d47c5" translate="yes" xml:space="preserve">
          <source>To access refs, it&amp;rsquo;s best not to look inside GIT_DIR directly. Instead use commands such as &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt; or &lt;a href=&quot;git-update-ref&quot;&gt;git-update-ref[1]&lt;/a&gt; which will handle refs correctly.</source>
          <target state="translated">심판에 액세스하려면 GIT_DIR 내부를 직접 보지 않는 것이 가장 좋습니다. 대신 &lt;a href=&quot;git-update-ref&quot;&gt;ref를&lt;/a&gt; 올바르게 처리하는 &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt; 또는 git-update-ref [1] 과 같은 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bdc5ec95e827bdeffd1f9aab0bef5dd1e05d0443" translate="yes" xml:space="preserve">
          <source>To achieve this, try to split your work into small steps from the very beginning. It is always easier to squash a few commits together than to split one big commit into several. Don&amp;rsquo;t be afraid of making too small or imperfect steps along the way. You can always go back later and edit the commits with &lt;code&gt;git rebase --interactive&lt;/code&gt; before you publish them. You can use &lt;code&gt;git stash push --keep-index&lt;/code&gt; to run the test suite independent of other uncommitted changes; see the EXAMPLES section of &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">이를 위해서는 처음부터 작은 단계로 작업을 분할하십시오. 하나의 큰 커밋을 여러 개의 커밋으로 나누는 것보다 몇 개의 커밋을 함께 스쿼시하는 것이 항상 쉽습니다. 길을 따라 너무 작거나 불완전한 발걸음을 내딛는 것을 두려워하지 마십시오. 커밋 하기 전에 언제든지 &lt;code&gt;git rebase --interactive&lt;/code&gt; 로 커밋을 편집하고 편집 할 수 있습니다. &lt;code&gt;git stash push --keep-index&lt;/code&gt; 를 사용하여 커밋되지 않은 다른 변경과 독립적으로 테스트 스위트를 실행할 수 있습니다 . &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; 의 예제 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0fad63887775e60c970096082173b077cbcda459" translate="yes" xml:space="preserve">
          <source>To actually match only values with an exclamation mark, you have to</source>
          <target state="translated">느낌표가있는 값만 실제로 일치 시키려면</target>
        </trans-unit>
        <trans-unit id="0fea0d3a69770ac7053eba17165f8f811c0d830f" translate="yes" xml:space="preserve">
          <source>To add a new proxy, without altering any of the existing ones, use</source>
          <target state="translated">기존 프록시를 변경하지 않고 새 프록시를 추가하려면</target>
        </trans-unit>
        <trans-unit id="6a37f3f129452efb4608e170beca8c23ff8dc189" translate="yes" xml:space="preserve">
          <source>To aid in debugging frontends fast-import ignores any line that begins with &lt;code&gt;#&lt;/code&gt; (ASCII pound/hash) up to and including the line ending &lt;code&gt;LF&lt;/code&gt;. A comment line may contain any sequence of bytes that does not contain an LF and therefore may be used to include any detailed debugging information that might be specific to the frontend and useful when inspecting a fast-import data stream.</source>
          <target state="translated">프론트 엔드 디버깅을 돕기 위해 빠른 가져 오기는 &lt;code&gt;#&lt;/code&gt; (ASCII 파운드 / 해시)로 시작하는 라인부터 &lt;code&gt;LF&lt;/code&gt; 까지 끝나는 라인을 무시합니다 . 주석 행은 LF를 포함하지 않는 임의의 바이트 시퀀스를 포함 할 수 있으므로 빠른 가져 오기 데이터 스트림을 검사 할 때 프론트 엔드에 고유하고 상세한 디버깅 정보를 포함하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="285359187a2aff04e4ea763b2f3e4bbaf641190b" translate="yes" xml:space="preserve">
          <source>To assist in this, Git also provides the tag object&amp;hellip;​</source>
          <target state="translated">이를 돕기 위해 Git은 태그 객체도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="39ed0e01aa6b6521a62db21f8653937d0b5ccadd" translate="yes" xml:space="preserve">
          <source>To avoid common misconfiguration mistakes, &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt; will abort with a warning if any configuration options for &quot;sendmail&quot; exist. Set this variable to bypass the check.</source>
          <target state="translated">일반적인 잘못된 구성 실수를 방지하기 위해 &lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt; 은 &quot;sendmail&quot;에 대한 구성 옵션이있는 경우 경고와 함께 중단됩니다. 검사를 우회하려면이 변수를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="b0021f1eb05e23f63eb7ccc2f58c52546ee61585" translate="yes" xml:space="preserve">
          <source>To avoid deadlock, such frontends must completely consume any pending output from &lt;code&gt;progress&lt;/code&gt;, &lt;code&gt;ls&lt;/code&gt;, &lt;code&gt;get-mark&lt;/code&gt;, and &lt;code&gt;cat-blob&lt;/code&gt; before performing writes to fast-import that might block.</source>
          <target state="translated">교착 상태를 피하려면 이러한 프론트 엔드 가 차단 될 수있는 빠른 가져 오기에 쓰기를 수행하기 전에 &lt;code&gt;progress&lt;/code&gt; , &lt;code&gt;ls&lt;/code&gt; , &lt;code&gt;get-mark&lt;/code&gt; 및 &lt;code&gt;cat-blob&lt;/code&gt; 에서 보류중인 출력을 완전히 소비해야합니다 .</target>
        </trans-unit>
        <trans-unit id="75e1daad195d404dc835c71216234df4a4676d4e" translate="yes" xml:space="preserve">
          <source>To avoid deleting a shared index file that is still used, its modification time is updated to the current time every time a new split index based on the shared index file is either created or read from.</source>
          <target state="translated">여전히 사용되는 공유 인덱스 파일을 삭제하지 않으려면 공유 인덱스 파일을 기반으로하는 새 분할 인덱스를 만들거나 읽을 때마다 수정 시간이 현재 시간으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="0b95bb4f949904cf33707d2a81be23c345f8e5aa" translate="yes" xml:space="preserve">
          <source>To avoid false positives (e.g. when a patch has been removed, and an unrelated patch has been added between two iterations of the same patch series), the cost matrix is extended to allow for that, by adding fixed-cost entries for wholesale deletes/adds.</source>
          <target state="translated">오 탐지 (예 : 패치가 제거되고 동일한 패치 시리즈의 두 반복간에 관련이없는 패치가 추가 된 경우)를 방지하기 위해 도매 삭제에 고정 비용 항목을 추가하여 비용 매트릭스를 확장 할 수 있습니다. 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0fd573776931ed5e5643654b60eb3896366ed973" translate="yes" xml:space="preserve">
          <source>To avoid interfering with other worktrees, it first enables the &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; setting and makes sure to set the &lt;code&gt;core.sparseCheckout&lt;/code&gt; setting in the worktree-specific config file.</source>
          <target state="translated">다른 작업 트리와의 간섭을 피하기 위해 먼저 &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; 설정을 활성화하고 작업 트리 특정 구성 파일에서 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 설정 을 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3c2082115575958e10a9c1afdaf9ab0c9127b12a" translate="yes" xml:space="preserve">
          <source>To avoid recording unrelated changes in the merge commit, &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt; will also abort if there are any changes registered in the index relative to the &lt;code&gt;HEAD&lt;/code&gt; commit. (Special narrow exceptions to this rule may exist depending on which merge strategy is in use, but generally, the index must match HEAD.)</source>
          <target state="translated">병합 커밋에서 관련없는 변경 사항을 기록하지 않기 위해 &lt;code&gt;HEAD&lt;/code&gt; 커밋과 관련하여 인덱스에 등록 된 변경 사항이있는 경우 &lt;code&gt;git pull&lt;/code&gt; 및 &lt;code&gt;git merge&lt;/code&gt; 도 중단됩니다 . 사용중인 병합 전략에 따라이 규칙에 대한 특별한 좁은 예외가있을 수 있지만 일반적으로 인덱스는 HEAD와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="3066556f3c40d15744968614a5fc8c1e23bf8a7b" translate="yes" xml:space="preserve">
          <source>To avoid typing long email addresses, point this to one or more email aliases files. You must also supply &lt;code&gt;sendemail.aliasFileType&lt;/code&gt;.</source>
          <target state="translated">긴 이메일 주소를 입력하지 않으려면 하나 이상의 이메일 별명 파일을 가리 킵니다. &lt;code&gt;sendemail.aliasFileType&lt;/code&gt; 도 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c4b87fbf313d264308ea989e0e3b9a4c3d776c25" translate="yes" xml:space="preserve">
          <source>To bootstrap the process, you can first create a bundle that does not have any basis. You can use a tag to remember up to what commit you last processed, in order to make it easy to later update the other repository with an incremental bundle:</source>
          <target state="translated">프로세스를 부트 스트랩하려면 먼저 기본이없는 번들을 작성할 수 있습니다. 나중에 증분 번들로 다른 저장소를 쉽게 업데이트 할 수 있도록 태그를 사용하여 마지막으로 처리 한 커밋까지 기억할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d8840568125195e79747db7654d577582e9ce27" translate="yes" xml:space="preserve">
          <source>To change which notes are shown by &lt;code&gt;git log&lt;/code&gt;, see the &quot;notes.displayRef&quot; configuration in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;git log&lt;/code&gt; 로 표시되는 메모를 변경하려면 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 의 &quot;notes.displayRef&quot;구성을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="97883ec3271fcc02269394ee0880b3655a6f452f" translate="yes" xml:space="preserve">
          <source>To check out commit &lt;code&gt;HEAD~3&lt;/code&gt; for temporary inspection or experiment without creating a new branch:</source>
          <target state="translated">새 분기를 만들지 않고 임시 검사 또는 실험을 위해 커밋 &lt;code&gt;HEAD~3&lt;/code&gt; 을 확인하려면 :</target>
        </trans-unit>
        <trans-unit id="d144f3be27bf6711b21fc83fdbf3f1e8ff9fc321" translate="yes" xml:space="preserve">
          <source>To commit a tree you have instantiated with &lt;code&gt;git write-tree&lt;/code&gt;, you&amp;rsquo;d create a &quot;commit&quot; object that refers to that tree and the history behind it&amp;mdash;​most notably the &quot;parent&quot; commits that preceded it in history.</source>
          <target state="translated">&lt;code&gt;git write-tree&lt;/code&gt; 로 인스턴스화 한 트리를 커밋하려면 해당 트리와 그 히스토리를 참조하는 &quot;커밋&quot;객체를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="05e44c536d85ee3801aa2c0d698cefa8d09c4c33" translate="yes" xml:space="preserve">
          <source>To completely remove a submodule, manually delete &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt;.</source>
          <target state="translated">서브 모듈을 완전히 제거하려면 &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; 수동으로 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="27c15a86c7e79c3805e163825e563ceb0da18b5a" translate="yes" xml:space="preserve">
          <source>To control which revisions to show, gitk supports most options applicable to the &lt;code&gt;git rev-list&lt;/code&gt; command. It also supports a few options applicable to the &lt;code&gt;git diff-*&lt;/code&gt; commands to control how the changes each commit introduces are shown. Finally, it supports some gitk-specific options.</source>
          <target state="translated">표시 할 개정을 제어하기 위해 gitk는 &lt;code&gt;git rev-list&lt;/code&gt; 명령에 적용 가능한 대부분의 옵션을 지원합니다 . 또한 &lt;code&gt;git diff-*&lt;/code&gt; 명령에 적용 할 수있는 몇 가지 옵션을 지원하여 각 커밋의 변경 내용 표시 방법을 제어합니다. 마지막으로, 일부 gitk 특정 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="777e371b82028c9765bc912013f44d79febb95a6" translate="yes" xml:space="preserve">
          <source>To cope with such a situation, after the inner &lt;code&gt;git bisect&lt;/code&gt; finds the next revision to test, the script can apply the patch before compiling, run the real test, and afterwards decide if the revision (possibly with the needed patch) passed the test and then rewind the tree to the pristine state. Finally the script should exit with the status of the real test to let the &lt;code&gt;git bisect run&lt;/code&gt; command loop determine the eventual outcome of the bisect session.</source>
          <target state="translated">이러한 상황에 대처하기 위해 내부 &lt;code&gt;git bisect&lt;/code&gt; 가 테스트 할 다음 개정을 찾은 후 스크립트는 컴파일하기 전에 패치를 적용하고 실제 테스트를 실행 한 후 수정 (필요한 패치로 가능)이 테스트를 통과했는지 여부를 결정하고 그런 다음 트리를 원래 상태로 되감습니다. 마지막으로 스크립트는 실제 테스트 상태와 함께 종료되어 &lt;code&gt;git bisect run&lt;/code&gt; 명령 루프가 bisect 세션의 최종 결과를 결정하도록합니다.</target>
        </trans-unit>
        <trans-unit id="8674c1ca562e6ecc34e19d2429ea897e7602bd28" translate="yes" xml:space="preserve">
          <source>To create your own local live copy of such a &quot;raw&quot; Git repository, you&amp;rsquo;d first create your own subdirectory for the project, and then copy the raw repository contents into the &lt;code&gt;.git&lt;/code&gt; directory. For example, to create your own copy of the Git repository, you&amp;rsquo;d do the following</source>
          <target state="translated">이러한 &quot;원시&quot;Git 저장소의 자체 로컬 라이브 사본을 작성하려면 먼저 프로젝트에 대한 자체 서브 디렉토리를 작성한 후 원시 저장소 컨텐츠를 &lt;code&gt;.git&lt;/code&gt; 디렉토리에 복사하십시오 . 예를 들어, Git 리포지토리의 자체 복사본을 만들려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="495be7922d2a293092e6f366efd8045104e01478" translate="yes" xml:space="preserve">
          <source>To define a custom merge driver &lt;code&gt;filfre&lt;/code&gt;, add a section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">사용자 정의 병합 드라이버 &lt;code&gt;filfre&lt;/code&gt; 를 정의하려면 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 파일 (또는 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 파일)에 다음과 같이 섹션을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="369d97c17e3edbb633e139fcbb4d6a1ea94c1201" translate="yes" xml:space="preserve">
          <source>To define an external diff driver &lt;code&gt;jcdiff&lt;/code&gt;, add a section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">외부 diff 드라이버 &lt;code&gt;jcdiff&lt;/code&gt; 를 정의하려면 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 파일 (또는 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 파일)에 다음과 같이 섹션을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="302897a013466c7a33ee45af87c508a98422abd4" translate="yes" xml:space="preserve">
          <source>To delete the entry for renames, do</source>
          <target state="translated">이름을 바꾸려면 해당 항목을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="f31f6b0ae1c80bea942e287ae0ab318c31ede1f4" translate="yes" xml:space="preserve">
          <source>To determine the location of the repository on disk, &lt;code&gt;git http-backend&lt;/code&gt; concatenates the environment variables PATH_INFO, which is set automatically by the web server, and GIT_PROJECT_ROOT, which must be set manually in the web server configuration. If GIT_PROJECT_ROOT is not set, &lt;code&gt;git http-backend&lt;/code&gt; reads PATH_TRANSLATED, which is also set automatically by the web server.</source>
          <target state="translated">디스크에서 저장소의 위치를 ​​판별하기 위해 &lt;code&gt;git http-backend&lt;/code&gt; 는 웹 서버에서 자동으로 설정 한 환경 변수 PATH_INFO와 웹 서버 구성에서 수동으로 설정해야하는 GIT_PROJECT_ROOT를 연결합니다. GIT_PROJECT_ROOT가 설정되어 있지 않은 경우, &lt;code&gt;git http-backend&lt;/code&gt; 는 PATH_TRANSLATED를 읽으며 웹 서버에 의해 자동으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b99f7180a07f9dbb13dde063c76c98dd5e2d7887" translate="yes" xml:space="preserve">
          <source>To disable features that accept parameters (are configurable), you need to set this element to empty list i.e. &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">매개 변수를 허용하는 기능을 비활성화하려면 (구성 가능)이 요소를 빈 목록 (예 : &lt;code&gt;[]&lt;/code&gt; ) 으로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="43f3c91605c9cb6d680c0ea9cf4c1bb2e77b4d9d" translate="yes" xml:space="preserve">
          <source>To disable interactive logins, displaying a greeting instead:</source>
          <target state="translated">대화 형 로그인을 비활성화하려면 인사말을 대신 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="2e78622c40c98dec97477af783b12ba20d12cc1a" translate="yes" xml:space="preserve">
          <source>To display the &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; man page, use &lt;code&gt;git help git&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; 매뉴얼 페이지 를 표시하려면 &lt;code&gt;git help git&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa4dddf358b16e56494c90923230fd025e6f958d" translate="yes" xml:space="preserve">
          <source>To do automatic tag object dereferencing, use the &quot;-d&quot; or &quot;--dereference&quot; flag, so you can do</source>
          <target state="translated">자동 태그 객체 역 참조를 수행하려면 &quot;-d&quot;또는 &quot;--dereference&quot;플래그를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1e8ea8767cf483c97d6a2e7fcf2209ed742ecdf8" translate="yes" xml:space="preserve">
          <source>To do so, you can specify a &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; pattern with the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute. For example, the following pattern sets all C files to use UTF-16LE-BOM, which is a common encoding on Windows:</source>
          <target state="translated">이를 위해 &lt;code&gt;working-tree-encoding&lt;/code&gt; 속성을 사용하여 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 패턴을 지정할 수 있습니다 . 예를 들어 다음 패턴은 Windows에서 공통 인코딩 인 UTF-16LE-BOM을 사용하도록 모든 C 파일을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="dc05ce874d6baee1eae11d94d6fd56f1e0a6d0ed" translate="yes" xml:space="preserve">
          <source>To do the merge, do</source>
          <target state="translated">병합을 수행하려면</target>
        </trans-unit>
        <trans-unit id="45ed93b09b65e276ec2ef33a1d9d7c3e10d14bfe" translate="yes" xml:space="preserve">
          <source>To do this, the current maintenance branch is copied to another branch named with the previous release version number (e.g. maint-X.Y.(Z-1) where X.Y.Z is the current release).</source>
          <target state="translated">이를 위해 현재 유지 보수 분기가 이전 릴리스 버전 번호로 이름 지정된 다른 분기 (예 : XYZ가 현재 릴리스 인 maint-XY (Z-1))로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="380aa6a091a04ad8bbf89399d1982760e370374e" translate="yes" xml:space="preserve">
          <source>To drop a commit, replace the command &quot;pick&quot; with &quot;drop&quot;, or just delete the matching line.</source>
          <target state="translated">커밋을 삭제하려면 &quot;pick&quot;명령을 &quot;drop&quot;으로 바꾸거나 일치하는 행을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="e05b8854f808624747710c5e1d641ee4dabaf30c" translate="yes" xml:space="preserve">
          <source>To elaborate, &quot;reading&quot; means checking for file existence, reading file attributes or file content. The working directory version may be present or absent. If present, its content may match against the index version or not. Writing is not affected by this bit, content safety is still first priority. Note that Git &lt;code&gt;can&lt;/code&gt; update working directory file, that is marked skip-worktree, if it is safe to do so (i.e. working directory version matches index version)</source>
          <target state="translated">자세히 설명하면 &quot;읽기&quot;는 파일 존재 여부 확인, 파일 속성 또는 파일 내용 읽기를 의미합니다. 작업 디렉토리 버전이 있거나 없을 수 있습니다. 존재하는 경우 해당 컨텐츠가 인덱스 버전과 일치하거나 일치하지 않을 수 있습니다. 쓰기는이 비트의 영향을받지 않으며 콘텐츠 안전이 여전히 최우선 순위입니다. 망할 놈의 것을 참고 &lt;code&gt;can&lt;/code&gt; 안전한 경우, 스킵 - worktree 표시되어 작업 디렉토리의 파일을 업데이트합니다 (즉, 디렉토리 버전을 작업하는 인덱스 버전과 일치)</target>
        </trans-unit>
        <trans-unit id="64ecd7272d648bbcdba5e527a1a80e43cb0705c5" translate="yes" xml:space="preserve">
          <source>To enable &lt;code&gt;git archive --remote&lt;/code&gt; and disable &lt;code&gt;git fetch&lt;/code&gt; against a repository, have the following in the configuration file in the repository (that is the file &lt;code&gt;config&lt;/code&gt; next to &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;refs&lt;/code&gt; and &lt;code&gt;objects&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;git archive --remote&lt;/code&gt; 를 활성화 하고 리포지토리에 대해 &lt;code&gt;git fetch&lt;/code&gt; 를 비활성화 하려면 리포지토리의 구성 파일 ( &lt;code&gt;HEAD&lt;/code&gt; , &lt;code&gt;refs&lt;/code&gt; 및 &lt;code&gt;objects&lt;/code&gt; 옆에 있는 파일 &lt;code&gt;config&lt;/code&gt; 다음 이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="af7d8457fff28a2087e0f74bc51d0468026a9bff" translate="yes" xml:space="preserve">
          <source>To enable a target, set the corresponding environment variable or system or global config value to one of the following:</source>
          <target state="translated">대상을 사용하려면 해당 환경 변수 또는 시스템 또는 전역 구성 값을 다음 중 하나로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="01e6eac26c3bbc386ab13c8cd6a9167801f24836" translate="yes" xml:space="preserve">
          <source>To enable anonymous read access but authenticated write access, require authorization for both the initial ref advertisement (which we detect as a push via the service parameter in the query string), and the receive-pack invocation itself:</source>
          <target state="translated">익명 읽기 액세스와 인증 된 쓰기 액세스를 사용하려면 초기 참조 광고 (조회 문자열에서 서비스 매개 변수를 통한 푸시로 감지) 및 수신 팩 호출 자체에 대한 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9bda367b82f8881561a1128afb27f36988891c35" translate="yes" xml:space="preserve">
          <source>To enable anonymous read access but authenticated write access:</source>
          <target state="translated">익명 읽기 액세스를 허용하지만 인증 된 쓰기 액세스를 활성화하려면</target>
        </trans-unit>
        <trans-unit id="050d5472dcd3f05f019f9a8129d0bb6d5e205df8" translate="yes" xml:space="preserve">
          <source>To enable blame, pickaxe search, and snapshot support (allowing &quot;tar.gz&quot; and &quot;zip&quot; snapshots), while allowing individual projects to turn them off, put the following in your GITWEB_CONFIG file:</source>
          <target state="translated">비난, 곡괭이 검색 및 스냅 샷 지원 ( &quot;tar.gz&quot;및 &quot;zip&quot;스냅 샷 허용)을 활성화하고 개별 프로젝트에서 끌 수 있도록하려면 GITWEB_CONFIG 파일에 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="fa7174e314ce7012972664ac5bcf82d4b390a6d5" translate="yes" xml:space="preserve">
          <source>To enable git-cvsserver access (which should generally have the &lt;code&gt;no-interactive-login&lt;/code&gt; example above as a prerequisite, as creating the git-shell-commands directory allows interactive logins):</source>
          <target state="translated">git-cvsserver 액세스를 활성화하려면 ( git-shell-commands 디렉토리를 만들면 &lt;code&gt;no-interactive-login&lt;/code&gt; 이 가능하므로 일반적으로 위 의 no-interactive-login 예제가 전제 조건으로 있어야 함) :</target>
        </trans-unit>
        <trans-unit id="69aa803d2928631745bb26ea6d720a34de175dd7" translate="yes" xml:space="preserve">
          <source>To enable that additional nice feature, when a bisection is started and when some good commits are not ancestors of the bad commit, we first compute the merge bases between the bad and the good commits and we chose these merge bases as the first commits that will be checked out and tested.</source>
          <target state="translated">추가 멋진 기능을 사용하기 위해, bisection이 시작될 때와 일부 좋은 commit이 bad commit의 조상이 아닌 경우, 먼저 bad와 good commit 사이의 병합 기준을 계산하고 이러한 병합 기준을 첫 번째 확약으로 선택합니다. 체크 아웃하고 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="ba44f6ad0a0230b79b3149aabc029b57fd7f22d9" translate="yes" xml:space="preserve">
          <source>To enable the sparse-checkout feature, run &lt;code&gt;git sparse-checkout init&lt;/code&gt; to initialize a simple sparse-checkout file and enable the &lt;code&gt;core.sparseCheckout&lt;/code&gt; config setting. Then, run &lt;code&gt;git sparse-checkout set&lt;/code&gt; to modify the patterns in the sparse-checkout file.</source>
          <target state="translated">스파 스 체크 아웃 기능을 활성화하려면 &lt;code&gt;git sparse-checkout init&lt;/code&gt; 를 실행 하여 간단한 스파 스 체크 아웃 파일을 초기화하고 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 구성 설정을 활성화하십시오 . 그런 다음 &lt;code&gt;git sparse-checkout set&lt;/code&gt; 를 실행 하여 sparse-checkout 파일의 패턴을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="1318b73efc503f41a06d5d140c646ee25cf7e427" translate="yes" xml:space="preserve">
          <source>To exclude commits reachable from a commit, a prefix &lt;code&gt;^&lt;/code&gt; notation is used. E.g. &lt;code&gt;^r1 r2&lt;/code&gt; means commits reachable from &lt;code&gt;r2&lt;/code&gt; but exclude the ones reachable from &lt;code&gt;r1&lt;/code&gt; (i.e. &lt;code&gt;r1&lt;/code&gt; and its ancestors).</source>
          <target state="translated">커밋에서 도달 가능한 커밋을 제외하기 위해 접두사 &lt;code&gt;^&lt;/code&gt; 표기법이 사용됩니다. 예 &lt;code&gt;^r1 r2&lt;/code&gt; 수단의 커밋에서 도달 &lt;code&gt;r2&lt;/code&gt; 하지만 사람이에서 접근 제외 &lt;code&gt;r1&lt;/code&gt; (즉, &lt;code&gt;r1&lt;/code&gt; 과 그 조상).</target>
        </trans-unit>
        <trans-unit id="a12d809ea9b20c2b561957b059e3fe943cb6e440" translate="yes" xml:space="preserve">
          <source>To find out how the result can be used, just read on in &lt;code&gt;cmd_cat_file()&lt;/code&gt;:</source>
          <target state="translated">결과 사용 방법을 알아 보려면 &lt;code&gt;cmd_cat_file()&lt;/code&gt; 에서 계속 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="338cdf0c3d82152dc96e1eae9cd9922bf736e76c" translate="yes" xml:space="preserve">
          <source>To get a checkout with the Eclipse CVS client:</source>
          <target state="translated">Eclipse CVS 클라이언트로 체크 아웃하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="976f859125db1311d8f82bb8df703ef2ad537fd0" translate="yes" xml:space="preserve">
          <source>To get a reminder of the currently used terms, use</source>
          <target state="translated">현재 사용 된 용어를 상기시키기 위해</target>
        </trans-unit>
        <trans-unit id="68b714c59ff5898ff58433a2938d52aeb27df43e" translate="yes" xml:space="preserve">
          <source>To get started with gitweb, run &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; from a Git repository. This would configure and start your web server, and run web browser pointing to gitweb.</source>
          <target state="translated">gitweb을 시작하려면 Git 리포지토리에서 &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt; 을 실행하십시오 . 이것은 웹 서버를 구성하고 시작하고 gitweb을 가리키는 웹 브라우저를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="bf62a03860b36b4b6a615592146052d88035a5f4" translate="yes" xml:space="preserve">
          <source>To get the &quot;base&quot; for the merge, look up the common parent of two commits:</source>
          <target state="translated">병합의 &quot;기본&quot;을 얻으려면 두 커밋의 공통 부모를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="ec1f343ca45777aa33e95b7222bfb7658aa36062" translate="yes" xml:space="preserve">
          <source>To get the feature/bugfix into an integration branch, simply merge it. If the topic has evolved further in the meantime, merge again. (Note that you do not necessarily have to merge it to the oldest integration branch first. For example, you can first merge a bugfix to &lt;code&gt;next&lt;/code&gt;, give it some testing time, and merge to &lt;code&gt;maint&lt;/code&gt; when you know it is stable.)</source>
          <target state="translated">기능 / 버그 픽스를 통합 브랜치로 가져 오려면 간단히 병합하십시오. 그 동안 주제가 더 발전한 경우 다시 병합하십시오. (가장 오래된 통합 브랜치에 먼저 병합 할 필요는 없습니다. 예를 들어, 먼저 버그 수정을 &lt;code&gt;next&lt;/code&gt; 에 병합하고 , 테스트 시간을 제공하고, 안정적인 것으로 판단되면 &lt;code&gt;maint&lt;/code&gt; 에 병합 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="60ae758b58fc83602f1720fb9cc2f0f4fb30b090" translate="yes" xml:space="preserve">
          <source>To give some hard figures, we used to have an average report-to-fix cycle of 142.6 hours (according to our somewhat weird bug-tracker which just measures wall-clock time). Since we moved to Git, we&amp;rsquo;ve lowered that to 16.2 hours. Primarily because we can stay on top of the bug fixing now, and because everyone&amp;rsquo;s jockeying to get to fix bugs (we&amp;rsquo;re quite proud of how lazy we are to let Git find the bugs for us). Each new release results in ~40% fewer bugs (almost certainly due to how we now feel about writing tests).</source>
          <target state="translated">어려운 수치를 제공하기 위해 평균 시계 수정주기는 ​​142.6 시간이었습니다 (벽 시계 시간을 측정하는 다소 이상한 버그 추적기에 따라). Git으로 옮긴 이후 16.2 시간으로 줄였습니다. 우리는 지금 버그 수정을 계속 할 수 있고 모든 사람들이 버그를 고치려고 애 쓰고 있기 때문에 (Git에서 버그를 찾게하는 것이 얼마나 게으른 지 자랑스럽게 생각합니다). 새로 출시 될 때마다 버그가 약 40 % 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="cc855cb566c405d222e3a3236275bbad376833c3" translate="yes" xml:space="preserve">
          <source>To help with that, &lt;code&gt;range&lt;/code&gt; uses the &lt;code&gt;--dual-color&lt;/code&gt; mode by default. In this mode, the diff of diffs will retain the original diff colors, and prefix the lines with -/+ markers that have their &lt;strong&gt;background&lt;/strong&gt; red or green, to make it more obvious that they describe how the diff itself changed.</source>
          <target state="translated">이를 돕기 위해 &lt;code&gt;range&lt;/code&gt; 는 기본적으로 &lt;code&gt;--dual-color&lt;/code&gt; 모드를 사용합니다 . 이 모드에서 diff diff는 원래 diff 색상을 유지하고 선이 &lt;strong&gt;배경이&lt;/strong&gt; 빨간색 또는 녹색 인 -/ + 마커로 접두어 diff 자체가 어떻게 바뀌 었는지 더 명확하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="096c5d9029f3f58b2af501ec17fb5d42ac0f73fe" translate="yes" xml:space="preserve">
          <source>To illustrate the difference between &lt;code&gt;-S&amp;lt;regex&amp;gt; --pickaxe-regex&lt;/code&gt; and &lt;code&gt;-G&amp;lt;regex&amp;gt;&lt;/code&gt;, consider a commit with the following diff in the same file:</source>
          <target state="translated">차이점을 설명하기 &lt;code&gt;-S&amp;lt;regex&amp;gt; --pickaxe-regex&lt;/code&gt; 과 &lt;code&gt;-G&amp;lt;regex&amp;gt;&lt;/code&gt; A는 동일한 파일에서 다음과 DIFF 커밋 고려해</target>
        </trans-unit>
        <trans-unit id="e67d6de21feaa90def83753eb253a23faea561fa" translate="yes" xml:space="preserve">
          <source>To illustrate, suppose you are in a situation where someone develops a &lt;code&gt;subsystem&lt;/code&gt; branch, and you are working on a &lt;code&gt;topic&lt;/code&gt; that is dependent on this &lt;code&gt;subsystem&lt;/code&gt;. You might end up with a history like the following:</source>
          <target state="translated">예를 들어, 누군가 &lt;code&gt;subsystem&lt;/code&gt; 브랜치를 개발 하고이 &lt;code&gt;subsystem&lt;/code&gt; 종속 된 &lt;code&gt;topic&lt;/code&gt; 에 대해 작업하고 있다고 가정하십시오 . 다음과 같은 기록으로 끝날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a98d25733140cb4450fff563f123b0d4cafeb9f9" translate="yes" xml:space="preserve">
          <source>To interrupt the rebase (just like an &quot;edit&quot; command would do, but without cherry-picking any commit first), use the &quot;break&quot; command.</source>
          <target state="translated">rebase를 중단 시키려면 ( &quot;edit&quot;명령과 같지만 먼저 commit을 선택하지 않고) &quot;break&quot;명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f6408dba3913ebdb903fdfce1d68f1906d3e56f0" translate="yes" xml:space="preserve">
          <source>To look at only non-zero stages, use &lt;code&gt;--unmerged&lt;/code&gt; flag:</source>
          <target state="translated">0이 아닌 단계 만 &lt;code&gt;--unmerged&lt;/code&gt; 플래그를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b273f729e50c3bb1996889c896c925cce764cd8" translate="yes" xml:space="preserve">
          <source>To make it readable, we can tell &lt;code&gt;git diff-files&lt;/code&gt; to output the differences as a patch, using the &lt;code&gt;-p&lt;/code&gt; flag:</source>
          <target state="translated">읽을 수 있도록 &lt;code&gt;-p&lt;/code&gt; 플래그를 사용하여 &lt;code&gt;git diff-files&lt;/code&gt; 가 패치로 차이점을 출력하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fa7b34f2837aaeca157590c3f1e04cfe3400ecb" translate="yes" xml:space="preserve">
          <source>To make referencing the final pathname simpler, you can map each path component; so if you also anonymize &lt;code&gt;subdir&lt;/code&gt; to &lt;code&gt;publicdir&lt;/code&gt;, then the final pathname would be &lt;code&gt;publicdir/bar.c&lt;/code&gt;.</source>
          <target state="translated">최종 경로 이름을 더 간단하게 참조하기 위해 각 경로 구성 요소를 매핑 할 수 있습니다. 따라서 &lt;code&gt;subdir&lt;/code&gt; 을 &lt;code&gt;publicdir&lt;/code&gt; 로 익명화 하면 최종 경로 이름은 &lt;code&gt;publicdir/bar.c&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="5411ef1231b1da2dbabaf49f4348af685832f2f7" translate="yes" xml:space="preserve">
          <source>To move the whole tree into a subdirectory, or remove it from there:</source>
          <target state="translated">전체 트리를 서브 디렉토리로 이동 시키거나 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="9fef1883cb2bb53007927c93e3d8f7431145efad" translate="yes" xml:space="preserve">
          <source>To perform a three-way merge, you start with the two commits you want to merge, find their closest common parent (a third commit), and compare the trees corresponding to these three commits.</source>
          <target state="translated">3 방향 병합을 수행하려면 병합하려는 두 커밋으로 시작하여 가장 가까운 공통 상위 (세 번째 커밋)를 찾은 다음이 세 커밋에 해당하는 트리를 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="a35f3e8a10774da4c0b0f3f87118660d7ef9889e" translate="yes" xml:space="preserve">
          <source>To place a higher stage entry to the index, the path should first be removed by feeding a mode=0 entry for the path, and then feeding necessary input lines in the third format.</source>
          <target state="translated">인덱스에 더 높은 단계 항목을 배치하려면 먼저 경로에 mode = 0 항목을 공급 한 다음 필요한 입력 행을 세 번째 형식으로 공급하여 경로를 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="26b0cbf1bc1090821ae6f59cac15f02ec7f562f8" translate="yes" xml:space="preserve">
          <source>To prepare for working on &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;, switch to it by updating the index and the files in the working tree, and by pointing &lt;code&gt;HEAD&lt;/code&gt; at the branch. Local modifications to the files in the working tree are kept, so that they can be committed to the &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 작업을 준비하려면 작업 트리에서 색인과 파일을 업데이트 하고 분기에서 &lt;code&gt;HEAD&lt;/code&gt; 를 가리켜 서 해당 지점으로 전환하십시오. 작업 트리의 파일에 대한 로컬 수정은 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 에 커밋 될 수 있도록 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="13739c43ac679e23fc4c2d09478ac31e5293cb15" translate="yes" xml:space="preserve">
          <source>To pretend you have a file at path with mode and sha1, say:</source>
          <target state="translated">mode 및 sha1을 사용하여 경로에 파일이 있다고 가정하려면 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="6785e6ba620455f331d4a09eb8363e2600eabf25" translate="yes" xml:space="preserve">
          <source>To prevent a $GIT_DIR/worktrees entry from being pruned (which can be useful in some situations, such as when the entry&amp;rsquo;s working tree is stored on a portable device), use the &lt;code&gt;git worktree lock&lt;/code&gt; command, which adds a file named &lt;code&gt;locked&lt;/code&gt; to the entry&amp;rsquo;s directory. The file contains the reason in plain text. For example, if a linked working tree&amp;rsquo;s &lt;code&gt;.git&lt;/code&gt; file points to &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; then a file named &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; will prevent the &lt;code&gt;test-next&lt;/code&gt; entry from being pruned. See &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; for details.</source>
          <target state="translated">달러 (A $) GIT_DIR을 방지하기 위해 / (예 : 항목의 작업 트리가 휴대용 장치에 저장 될 때와 같은 일부 상황에서 유용 할 수 있습니다) 정리되는 항목, 사용 worktrees &lt;code&gt;git worktree lock&lt;/code&gt; 라는 이름의 파일 추가 명령, &lt;code&gt;locked&lt;/code&gt; 받는 사람을 항목의 디렉토리. 파일에는 이유가 일반 텍스트로 포함되어 있습니다. 링크 된 작업 트리의 예를 들어, &lt;code&gt;.git&lt;/code&gt; 파일 포인트가 &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; 다음라는 파일 &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; 은 방지 할 수 있습니다 &lt;code&gt;test-next&lt;/code&gt; 정리되는 다음 항목. 자세한 내용은 &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="af2e73e27abe3e4382121e1f7c2af8f2dfcf3321" translate="yes" xml:space="preserve">
          <source>To prevent a &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; entry from being pruned (which can be useful in some situations, such as when the entry&amp;rsquo;s working tree is stored on a portable device), use the &lt;code&gt;git worktree lock&lt;/code&gt; command, which adds a file named &lt;code&gt;locked&lt;/code&gt; to the entry&amp;rsquo;s directory. The file contains the reason in plain text. For example, if a linked working tree&amp;rsquo;s &lt;code&gt;.git&lt;/code&gt; file points to &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; then a file named &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; will prevent the &lt;code&gt;test-next&lt;/code&gt; entry from being pruned. See &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; 항목이 정리되는 것을 방지하려면 (항목의 작업 트리가 휴대용 장치에 저장되는 경우와 같은 일부 상황에서 유용 할 수 있음) &lt;code&gt;git worktree lock&lt;/code&gt; 명령을 사용하여 &lt;code&gt;locked&lt;/code&gt; 라는 파일 을 항목의 디렉토리. 파일에는 이유가 일반 텍스트로 포함되어 있습니다. 링크 된 작업 트리의 예를 들어, &lt;code&gt;.git&lt;/code&gt; 파일 포인트가 &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; 다음라는 파일 &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; 은 방지 할 수 있습니다 &lt;code&gt;test-next&lt;/code&gt; 가지 치기에서 다음 항목. 자세한 내용은 &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="46ac404b2baca4d3a659bb0594db0c41828389ed" translate="yes" xml:space="preserve">
          <source>To prevent these unnecessary merge conflicts, Git can be told to run a virtual check-out and check-in of all three stages of a file when resolving a three-way merge by setting the &lt;code&gt;merge.renormalize&lt;/code&gt; configuration variable. This prevents changes caused by check-in conversion from causing spurious merge conflicts when a converted file is merged with an unconverted file.</source>
          <target state="translated">이러한 불필요한 병합 충돌을 방지하기 위해, Git은 &lt;code&gt;merge.renormalize&lt;/code&gt; 구성 변수를 설정하여 3 방향 병합을 해결할 때 파일의 3 단계 모두에서 가상 체크 아웃 및 체크인을 실행하도록 지시 할 수 있습니다 . 이렇게하면 변환 된 파일이 변환되지 않은 파일과 병합 될 때 체크인 변환으로 인한 변경으로 인해 가짜 병합 충돌이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="91d260766aee213709a415223ac206b93100d7d5" translate="yes" xml:space="preserve">
          <source>To prune objects not used by your repository or another that borrows from your repository via its &lt;code&gt;.git/objects/info/alternates&lt;/code&gt;:</source>
          <target state="translated">저장소 또는 &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; 를 통해 저장소에서 빌린 다른 오브젝트에서 사용하지 않는 오브젝트를 제거하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f63f42b98c259e7fd0384dd68939f7fc302c5eb" translate="yes" xml:space="preserve">
          <source>To prune references as part of your normal workflow without needing to remember to run that, set &lt;code&gt;fetch.prune&lt;/code&gt; globally, or &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; per-remote in the config. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">참조를 실행하지 않아도 정상 워크 플로우의 일부로 참조를 제거하려면 구성에서 &lt;code&gt;fetch.prune&lt;/code&gt; 을 전체적으로 설정 하거나 &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; 를 원격으로 설정하십시오. &lt;a href=&quot;git-config&quot;&gt;git-config [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="68bfae2792009c9d944a67bd77b4854e1c8c4d3e" translate="yes" xml:space="preserve">
          <source>To put the loose objects into a pack, just run git repack:</source>
          <target state="translated">느슨한 객체를 팩에 넣으려면 git repack을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8344caf5b982f9b0d4dc99f7ff5aa708ff0b3592" translate="yes" xml:space="preserve">
          <source>To query the value for a given key, do</source>
          <target state="translated">주어진 키의 값을 쿼리하려면</target>
        </trans-unit>
        <trans-unit id="6d7c1598e59e901d58d9b961c14fa449c82ef069" translate="yes" xml:space="preserve">
          <source>To reapply a series of changes from a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; to a different base, and reset the &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt; of that branch to the result.</source>
          <target state="translated">&lt;a href=&quot;#def_branch&quot;&gt;분기&lt;/a&gt; 에서 다른베이스 로 일련의 변경 사항을 다시 적용하고 해당 분기 의 &lt;a href=&quot;#def_head&quot;&gt;헤드&lt;/a&gt; 를 결과로 재설정합니다 .</target>
        </trans-unit>
        <trans-unit id="25388a0bc929e9a0e4d2bb9d4d113e8444bb02a5" translate="yes" xml:space="preserve">
          <source>To remove a file from the index and from the working tree, use</source>
          <target state="translated">색인과 작업 트리에서 파일을 제거하려면</target>
        </trans-unit>
        <trans-unit id="c7850646e909d85f101794190a2e6f7a699e3e90" translate="yes" xml:space="preserve">
          <source>To remove commits authored by &quot;Darl McBribe&quot; from the history:</source>
          <target state="translated">히스토리에서 &quot;Darl McBribe&quot;가 작성한 커밋을 제거하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="65692943c43d72ea453917ea884fccf3994fb56e" translate="yes" xml:space="preserve">
          <source>To remove selection, prefix the input with &lt;code&gt;-&lt;/code&gt; like this:</source>
          <target state="translated">선택을 제거하려면, 입력과 앞에 &lt;code&gt;-&lt;/code&gt; 이 같은를 :</target>
        </trans-unit>
        <trans-unit id="9e91a512899aa79b93af123e6b1768a526248346" translate="yes" xml:space="preserve">
          <source>To repopulate the working directory with all files, use the &lt;code&gt;git sparse-checkout disable&lt;/code&gt; command.</source>
          <target state="translated">모든 파일로 작업 디렉토리를 다시 채우려면 &lt;code&gt;git sparse-checkout disable&lt;/code&gt; 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5c497720a7ab3ae3ef408305ef475289bc14a521" translate="yes" xml:space="preserve">
          <source>To reproduce the entire p4 history in Git, use the &lt;code&gt;@all&lt;/code&gt; modifier on the depot path:</source>
          <target state="translated">Git에서 전체 p4 히스토리를 재현하려면 저장소 경로 에서 &lt;code&gt;@all&lt;/code&gt; 수정자를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d4609928d728916d052df2a3b481b65890e4b16e" translate="yes" xml:space="preserve">
          <source>To require authentication for both reads and writes, use a Location directive around the repository, or one of its parent directories:</source>
          <target state="translated">읽기 및 쓰기 모두에 대한 인증을 요구하려면 저장소 또는 해당 상위 디렉토리 중 하나에 Location 지시문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="10ebfb5ceb771c952eff2c39be3b852f1f654421" translate="yes" xml:space="preserve">
          <source>To require authentication for both reads and writes:</source>
          <target state="translated">읽기와 쓰기 모두에 대한 인증이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="847928f545abee25f9f8e4e2cc396a049af86735" translate="yes" xml:space="preserve">
          <source>To restore a file in the index to match the version in &lt;code&gt;HEAD&lt;/code&gt; (this is the same as using &lt;a href=&quot;git-reset&quot;&gt;git-reset[1]&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 의 버전과 일치하도록 색인의 파일을 복원하려면 ( &lt;a href=&quot;git-reset&quot;&gt;git-reset [1]&lt;/a&gt; 사용과 동일 )</target>
        </trans-unit>
        <trans-unit id="21366b05c441f538e6886570018737e901640e49" translate="yes" xml:space="preserve">
          <source>To restore all files in the current directory</source>
          <target state="translated">현재 디렉토리의 모든 파일을 복원하려면</target>
        </trans-unit>
        <trans-unit id="0ab7e14988a23edeb341648ca7b63377b3dd49d2" translate="yes" xml:space="preserve">
          <source>To restrict rewriting to only part of the history, specify a revision range in addition to the new branch name. The new branch name will point to the top-most revision that a &lt;code&gt;git rev-list&lt;/code&gt; of this range will print.</source>
          <target state="translated">기록의 일부로 만 다시 쓰기를 제한하려면 새 분기 이름 외에 개정 범위를 지정하십시오. 새 분기 이름은 이 범위 의 &lt;code&gt;git rev-list&lt;/code&gt; 가 인쇄 할 최상위 개정을 가리 킵니다 .</target>
        </trans-unit>
        <trans-unit id="4d880d7fd779c619b85e62692eb083b5f59e932e" translate="yes" xml:space="preserve">
          <source>To rewrite commits E,F,G,H, use one of these:</source>
          <target state="translated">커밋 E, F, G, H를 다시 ​​쓰려면 다음 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="47b66273feb1f496168989ebee433bebb314fc85" translate="yes" xml:space="preserve">
          <source>To rewrite only commits D,E,F,G,H, but leave A, B and C alone, use:</source>
          <target state="translated">D, E, F, G, H 만 커밋하고 A, B 및 C는 그대로 두려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8c31d9c011b7c86062de888fb92cc01426b53584" translate="yes" xml:space="preserve">
          <source>To rewrite the repository to look as if &lt;code&gt;foodir/&lt;/code&gt; had been its project root, and discard all other history:</source>
          <target state="translated">&lt;code&gt;foodir/&lt;/code&gt; 가 프로젝트 루트 인 것처럼 보이도록 저장소를 다시 작성하고 다른 모든 히스토리를 삭제하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7c02b2b350476c8c24e25173b62f35a8ad0c0ae3" translate="yes" xml:space="preserve">
          <source>To see how submodule support works, create four example repositories that can be used later as a submodule:</source>
          <target state="translated">하위 모듈 지원 작동 방식을 보려면 나중에 하위 모듈로 사용할 수있는 네 가지 예제 리포지토리를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="700bc56e5656b835e5cd7fa2e5386957dfc66eac" translate="yes" xml:space="preserve">
          <source>To see the currently remaining suspects in &lt;code&gt;gitk&lt;/code&gt;, issue the following command during the bisection process (the subcommand &lt;code&gt;view&lt;/code&gt; can be used as an alternative to &lt;code&gt;visualize&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;gitk&lt;/code&gt; 에서 현재 남아있는 용의자를 보려면 이분법 프로세스 중에 다음 명령을 실행하십시오 (하위 명령 &lt;code&gt;view&lt;/code&gt; 는를 &lt;code&gt;visualize&lt;/code&gt; 하는 대안으로 사용할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="faa509deef7fcd4d518cc2cd2e577046b7eb747b" translate="yes" xml:space="preserve">
          <source>To see whether it has already been merged into the test or release branches, use:</source>
          <target state="translated">테스트 또는 릴리스 브랜치에 이미 병합되었는지 확인하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1e15ca1368deb202f467e491af7bfdb38f930af4" translate="yes" xml:space="preserve">
          <source>To serve gitweb at the same url, use a ScriptAliasMatch to only those URLs that &lt;code&gt;git http-backend&lt;/code&gt; can handle, and forward the rest to gitweb:</source>
          <target state="translated">동일한 URL에서 gitweb을 제공하려면 &lt;code&gt;git http-backend&lt;/code&gt; 가 처리 할 수 있는 URL에만 ScriptAliasMatch를 사용 하고 나머지는 gitweb에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="3b5c2b799f6b39d60aa882699fc88e3eb3a77175" translate="yes" xml:space="preserve">
          <source>To serve multiple repositories from different &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; in a single repository:</source>
          <target state="translated">단일 저장소 에서 다른 &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]의&lt;/a&gt; 여러 저장소를 제공하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="59fa97f902b7761eca14600ff37aff1758dec6bd" translate="yes" xml:space="preserve">
          <source>To set a commit (which typically is at the tip of another history) to be the parent of the current initial commit, in order to paste the other history behind the current history:</source>
          <target state="translated">다른 히스토리를 현재 히스토리 뒤에 붙여 넣기 위해 커미트 (일반적으로 다른 히스토리의 끝에 있음)를 현재 초기 커미트의 상위로 설정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d091c25539483b5c5b3db274eae656a5f768704a" translate="yes" xml:space="preserve">
          <source>To set the date used in future tag objects, set the environment variable GIT_COMMITTER_DATE (see the later discussion of possible values; the most common form is &quot;YYYY-MM-DD HH:MM&quot;).</source>
          <target state="translated">향후 태그 객체에 사용되는 날짜를 설정하려면 환경 변수 GIT_COMMITTER_DATE를 설정하십시오 (가능한 값에 대해서는 나중에 설명합니다. 가장 일반적인 형식은 &quot;YYYY-MM-DD HH : MM&quot;).</target>
        </trans-unit>
        <trans-unit id="0de4847876d8ab04ebb463613f39507d60c3b1a3" translate="yes" xml:space="preserve">
          <source>To set this up, first create your work tree by cloning Linus&amp;rsquo;s public tree:</source>
          <target state="translated">이를 설정하려면 먼저 Linus의 공용 트리를 복제하여 작업 트리를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="6fdb47a7575f286ad7a6b8b651d8470ef2c51c01" translate="yes" xml:space="preserve">
          <source>To set up &lt;code&gt;git daemon&lt;/code&gt; as a regular, non-inetd service that handles repositories for multiple virtual hosts based on their IP addresses, start the daemon like this:</source>
          <target state="translated">&lt;code&gt;git daemon&lt;/code&gt; 을 IP 주소를 기반으로 여러 가상 호스트의 리포지토리를 처리하는 비정규 일반 서비스로 설정하려면 다음 과 같이 데몬을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="cd4e85b93c0b5a71d973a240463742c429d6ce10" translate="yes" xml:space="preserve">
          <source>To set up &lt;code&gt;git daemon&lt;/code&gt; as an inetd service that handles any repository under the whitelisted set of directories, /pub/foo and /pub/bar, place an entry like the following into /etc/inetd all on one line:</source>
          <target state="translated">설정하려면 &lt;code&gt;git daemon&lt;/code&gt; 핸들 디렉토리 / 주점 / foo는의 허용 된 세트에서 모든 저장소 및 / 술집 / 바의 등 /에 다음과 같은 항목을 배치하는 것이 inetd를 서비스로 / 한 줄에 모든 inetd를</target>
        </trans-unit>
        <trans-unit id="d85d4c6ac447e3ea7881a95ee3354b641502c913" translate="yes" xml:space="preserve">
          <source>To set up &lt;code&gt;git daemon&lt;/code&gt; as an inetd service that handles repositories for different virtual hosts, &lt;code&gt;www.example.com&lt;/code&gt; and &lt;code&gt;www.example.org&lt;/code&gt;, place an entry like the following into &lt;code&gt;/etc/inetd&lt;/code&gt; all on one line:</source>
          <target state="translated">다른 가상 호스트 ( &lt;code&gt;www.example.com&lt;/code&gt; 및 &lt;code&gt;www.example.org&lt;/code&gt; )의 저장소를 처리하는 inetd 서비스로 &lt;code&gt;git daemon&lt;/code&gt; 을 설정하려면 &lt;code&gt;/etc/inetd&lt;/code&gt; 에 다음과 같은 항목을 모두 한 줄로 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="6d1dfa06a0b2e0253dac9a23d3e763ff2be4729c" translate="yes" xml:space="preserve">
          <source>To shelve changes instead of submitting, use &lt;code&gt;--shelve&lt;/code&gt; and &lt;code&gt;--update-shelve&lt;/code&gt;:</source>
          <target state="translated">제출하는 대신 변경 사항을 보류하려면 &lt;code&gt;--shelve&lt;/code&gt; 및 &lt;code&gt;--update-shelve&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b19251adc869dd31b98316a2df3ca3e146f58f68" translate="yes" xml:space="preserve">
          <source>To show all references called &quot;master&quot;, whether tags or heads or anything else, and regardless of how deep in the reference naming hierarchy they are, use:</source>
          <target state="translated">태그 또는 헤드 또는 기타 항목에 관계없이 &quot;마스터&quot;라는 모든 참조를 표시하고 참조 명명 계층 구조의 깊이에 관계없이 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="51ec81ccf2337a76aefa897308cd08d96e515614" translate="yes" xml:space="preserve">
          <source>To show only tags, or only proper branch heads, use &quot;--tags&quot; and/or &quot;--heads&quot; respectively (using both means that it shows tags and heads, but not other random references under the refs/ subdirectory).</source>
          <target state="translated">태그 또는 적절한 분기 헤드 만 표시하려면 &quot;--tags&quot;및 / 또는 &quot;--heads&quot;를 각각 사용하십시오 (두 태그를 모두 사용하면 태그 및 헤드가 표시되지만 refs / 하위 디렉토리 아래의 다른 임의 참조는 표시되지 않음).</target>
        </trans-unit>
        <trans-unit id="864f9f1ee17e37f4b3823291b8524eebd5879fc4" translate="yes" xml:space="preserve">
          <source>To show that as an example, let&amp;rsquo;s go back to the git-tutorial repository we used earlier, and create a branch in it. You do that by simply just saying that you want to check out a new branch:</source>
          <target state="translated">이를 예제로 보여주기 위해 앞에서 사용한 git-tutorial repository로 돌아가서 분기를 만듭니다. 새 지점을 확인하고 싶다고 말하면됩니다.</target>
        </trans-unit>
        <trans-unit id="acab411fa1b0a4e2f72e42b537e21a4bc08bf613" translate="yes" xml:space="preserve">
          <source>To simplify the discussion we will suppose that the untestable area is a simple string of commits and that it was created by a breakage introduced by one commit (let&amp;rsquo;s call it BBC for bisect breaking commit) and later fixed by another one (let&amp;rsquo;s call it BFC for bisect fixing commit).</source>
          <target state="translated">논의를 단순화하기 위해 우리는 테스트 할 수없는 영역이 단순한 커밋 문자열이고 한 커밋에 의해 도입 된 손상 (Brisct Break Commit을 위해 BBC라고 함)에서 나중에 다른 하나에 의해 수정되었다고 가정합니다 (BFC라고 함). 이등분 고정 커밋).</target>
        </trans-unit>
        <trans-unit id="975e3a9279c8287bca9f664bbcc61fee7baa93ca" translate="yes" xml:space="preserve">
          <source>To specify a branch other than the current one, use:</source>
          <target state="translated">현재 분기 이외의 분기를 지정하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b6b6e95c2c1acd4004bc280690d73f7c9df3e3b0" translate="yes" xml:space="preserve">
          <source>To specify a namespace, set the &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; environment variable to the namespace. For each ref namespace, Git stores the corresponding refs in a directory under &lt;code&gt;refs/namespaces/&lt;/code&gt;. For example, &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; will store refs under &lt;code&gt;refs/namespaces/foo/&lt;/code&gt;. You can also specify namespaces via the &lt;code&gt;--namespace&lt;/code&gt; option to &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;.</source>
          <target state="translated">네임 스페이스를 지정하려면 &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; 환경 변수를 네임 스페이스로 설정하십시오 . 각 참조 네임 스페이스에 대해 Git은 해당 참조를 &lt;code&gt;refs/namespaces/&lt;/code&gt; 아래의 디렉토리에 저장합니다 . 예를 들어 &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; 는 &lt;code&gt;refs/namespaces/foo/&lt;/code&gt; 아래에 ref 를 저장 합니다. &lt;code&gt;--namespace&lt;/code&gt; 옵션을 통해 &lt;a href=&quot;git&quot;&gt;git [1]에&lt;/a&gt; 네임 스페이스를 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d8e0463dddb070b083bcb1d31f0cd304bcae1a2" translate="yes" xml:space="preserve">
          <source>To specify a single commit or a range of commits, use:</source>
          <target state="translated">단일 커밋 또는 커밋 범위를 지정하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b6bdd73c5af990a9c308cb3582e6683a673000a9" translate="yes" xml:space="preserve">
          <source>To stop tracking a file that is currently tracked, use &lt;code&gt;git rm --cached&lt;/code&gt;.</source>
          <target state="translated">현재 추적되는 파일 추적을 중지하려면 &lt;code&gt;git rm --cached&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5aabd990937e7026d6c235ccca8da7a1bd54429f" translate="yes" xml:space="preserve">
          <source>To submit all changes that are in the current Git branch but not in the &lt;code&gt;p4/master&lt;/code&gt; branch, use:</source>
          <target state="translated">현재 Git 브랜치에 있지만 &lt;code&gt;p4/master&lt;/code&gt; 브랜치에는 없는 모든 변경 사항을 제출하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4d37523ff8334f7ae27e64b17d4088a430f024d8" translate="yes" xml:space="preserve">
          <source>To submit patches using GMail&amp;rsquo;s IMAP interface, first, edit your ~/.gitconfig to specify your account settings:</source>
          <target state="translated">GMail의 IMAP 인터페이스를 사용하여 패치를 제출하려면 먼저 ~ / .gitconfig를 편집하여 계정 설정을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="3829362b0206f78fb7e35755e5364f47036b822a" translate="yes" xml:space="preserve">
          <source>To support virtual hosting, an interpolated path template can be used to dynamically construct alternate paths. The template supports %H for the target hostname as supplied by the client but converted to all lowercase, %CH for the canonical hostname, %IP for the server&amp;rsquo;s IP address, %P for the port number, and %D for the absolute path of the named repository. After interpolation, the path is validated against the directory whitelist.</source>
          <target state="translated">가상 호스팅을 지원하기 위해 보간 경로 템플릿을 사용하여 대체 경로를 동적으로 구성 할 수 있습니다. 템플릿은 클라이언트가 제공 한 대상 호스트 이름에 대해 % H를 지원하지만 모든 소문자, 표준 호스트 이름에 대한 % CH, 서버의 IP 주소에 대한 % IP, 포트 번호에 대한 % P 및 절대 경로에 대한 % D로 변환됩니다. 명명 된 저장소 보간 후, 경로는 디렉토리 화이트리스트에 대해 검증됩니다.</target>
        </trans-unit>
        <trans-unit id="5c5bebcfb262219afa24ad57e1be9ff8017de145" translate="yes" xml:space="preserve">
          <source>To switch back to the previous branch before we switched to mytopic (i.e. &quot;master&quot; branch):</source>
          <target state="translated">mytopic (예 : &quot;마스터&quot;지점)으로 전환하기 전에 이전 지점으로 다시 전환하려면</target>
        </trans-unit>
        <trans-unit id="f604bfa9fc2a5e3a8b43aed4c26f0a58bfbd1e14" translate="yes" xml:space="preserve">
          <source>To tell Git that yes, you really do realize that certain files no longer exist, or that new files should be added, you should use the &lt;code&gt;--remove&lt;/code&gt; and &lt;code&gt;--add&lt;/code&gt; flags respectively.</source>
          <target state="translated">Git에게 특정 파일이 더 이상 존재하지 않거나 새로운 파일을 추가해야한다는 것을 실제로 인식하려면 &lt;code&gt;--remove&lt;/code&gt; 및 &lt;code&gt;--add&lt;/code&gt; 플래그를 각각 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f3c508cb95e621506ae6e931b2fdadcaba14a047" translate="yes" xml:space="preserve">
          <source>To test the interaction of several topics, merge them into a throw-away branch. You must never base any work on such a branch!</source>
          <target state="translated">여러 주제의 상호 작용을 테스트하려면 해당 주제를 폐기 지점으로 병합하십시오. 그러한 지점에 어떤 작업도하지 말아야합니다!</target>
        </trans-unit>
        <trans-unit id="ded44bb687bc8a448accbaa8cf09bc1b10b3ff71" translate="yes" xml:space="preserve">
          <source>To that end, it first finds pairs of commits from both commit ranges that correspond with each other. Two commits are said to correspond when the diff between their patches (i.e. the author information, the commit message and the commit diff) is reasonably small compared to the patches' size. See ``Algorithm`` below for details.</source>
          <target state="translated">이를 위해 먼저 서로 일치하는 두 커밋 범위에서 커밋 쌍을 찾습니다. 패치 사이의 차이 (즉, 작성자 정보, 커밋 메시지 및 커밋 차이)가 패치 크기에 비해 상당히 작을 때 두 개의 커밋이 해당한다고합니다. 자세한 내용은 아래의``알고리즘 ''을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="28b9a65cbb97d3af18835efd06d4d171278e0508" translate="yes" xml:space="preserve">
          <source>To throw away part of the development, i.e. to assign the &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt; to an earlier &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt;.</source>
          <target state="translated">개발의 일부를 버리는 것, 즉 &lt;a href=&quot;#def_head&quot;&gt;헤드&lt;/a&gt; 를 이전 &lt;a href=&quot;#def_revision&quot;&gt;개정판&lt;/a&gt; 에 할당 하는 것 .</target>
        </trans-unit>
        <trans-unit id="f2857b34f71a88c7afeb725363e4097e2e44ff45" translate="yes" xml:space="preserve">
          <source>To top it all off, even when users finally find working commands, they naturally want to share them. But they may be unaware that their repo didn&amp;rsquo;t have some special cases that someone else&amp;rsquo;s does. So, when someone else with a different repository runs the same commands, they get hit by the problems above. Or, the user just runs commands that really were vetted for special cases, but they run it on a different OS where it doesn&amp;rsquo;t work, as noted above.</source>
          <target state="translated">무엇보다도 사용자가 최종적으로 작업 명령을 찾더라도 자연스럽게 공유하기를 원합니다. 그러나 그들은 그들의 저장소에 다른 사람이하는 특별한 경우가 없다는 것을 알지 못할 수도 있습니다. 따라서 다른 리포지토리를 가진 다른 사람이 동일한 명령을 실행하면 위의 문제가 발생합니다. 또는 사용자는 특별한 경우에 실제로 심사 된 명령 만 실행하지만 위에서 언급 한대로 작동하지 않는 다른 OS에서 실행합니다.</target>
        </trans-unit>
        <trans-unit id="c4d2ca21938c992db0b3b75cacfc935366e6629e" translate="yes" xml:space="preserve">
          <source>To update and refresh only the files already checked out</source>
          <target state="translated">이미 체크 아웃 한 파일 만 업데이트하고 새로 고치려면</target>
        </trans-unit>
        <trans-unit id="a8c26a487a2f6627cb1ef2fcc7d8934daa7b62d0" translate="yes" xml:space="preserve">
          <source>To update and refresh only the files already checked out:</source>
          <target state="translated">이미 체크 아웃 한 파일 만 업데이트하고 새로 고치려면</target>
        </trans-unit>
        <trans-unit id="ec65c1043e980aa5b1f1a444793e6e405a4b07fd" translate="yes" xml:space="preserve">
          <source>To update the index with the contents of a new or modified file, use</source>
          <target state="translated">새 파일 또는 수정 된 파일의 내용으로 색인을 업데이트하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="693fe77a3dea0f3b3cf2c4a884d12237d7043db5" translate="yes" xml:space="preserve">
          <source>To update the resulting mine.git repository, you can fetch or pull after replacing the bundle stored at /home/me/tmp/file.bundle with incremental updates.</source>
          <target state="translated">결과로 생성 된 mine.git 저장소를 업데이트하려면 /home/me/tmp/file.bundle에 저장된 번들을 증분 업데이트로 교체 한 후 가져 오거나 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7804c7379482ba8df4ffa8604001ea71fae1937a" translate="yes" xml:space="preserve">
          <source>To use &quot;old&quot; and &quot;new&quot; instead of &quot;good&quot; and bad, you must run &lt;code&gt;git
bisect start&lt;/code&gt; without commits as argument and then run the following commands to add the commits:</source>
          <target state="translated">&quot;good&quot;과 bad 대신 &quot;old&quot;와 &quot;new&quot;를 사용하려면 커밋없이 &lt;code&gt;git bisect start&lt;/code&gt; 를 인수로 실행 한 후 다음 명령을 실행하여 커밋을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="288cf0a04f95ab8d9b3cedc9a80bcb75e1eb91a6" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;git send-email&lt;/code&gt; to send your patches through the GMail SMTP server, edit ~/.gitconfig to specify your account settings:</source>
          <target state="translated">&lt;code&gt;git send-email&lt;/code&gt; 을 사용 하여 GMail SMTP 서버를 통해 패치를 보내려면 ~ / .gitconfig를 편집하여 계정 설정을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="b24b5140a04c50c5ab1f6a8bf4b67a65e4b08446" translate="yes" xml:space="preserve">
          <source>To use a helper, you must first select one to use. Git currently includes the following helpers:</source>
          <target state="translated">도우미를 사용하려면 먼저 사용할 도우미를 선택해야합니다. 힘내는 현재 다음과 같은 도우미를 포함합니다 :</target>
        </trans-unit>
        <trans-unit id="36cbbd22949ca6f21f378ad7a2a2aecbfc17d31c" translate="yes" xml:space="preserve">
          <source>To use the tool, &lt;code&gt;imap.folder&lt;/code&gt; and either &lt;code&gt;imap.tunnel&lt;/code&gt; or &lt;code&gt;imap.host&lt;/code&gt; must be set to appropriate values.</source>
          <target state="translated">도구를 사용하려면 &lt;code&gt;imap.folder&lt;/code&gt; 와 &lt;code&gt;imap.tunnel&lt;/code&gt; 또는 &lt;code&gt;imap.host&lt;/code&gt; 를 적절한 값으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="00e4f18d69f51ffe1eea42af728cb3d7bb0059ec" translate="yes" xml:space="preserve">
          <source>To use the tool, imap.folder and either imap.tunnel or imap.host must be set to appropriate values.</source>
          <target state="translated">도구를 사용하려면 imap.folder 및 imap.tunnel 또는 imap.host가 적절한 값으로 설정되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8b51a494019812910be0a147154b59e9ef1b84fa" translate="yes" xml:space="preserve">
          <source>To use this mode effectively, you have to make sure &lt;code&gt;all&lt;/code&gt; the branches you would push out are ready to be pushed out before running &lt;code&gt;git push&lt;/code&gt;, as the whole point of this mode is to allow you to push all of the branches in one go. If you usually finish work on only one branch and push out the result, while other branches are unfinished, this mode is not for you. Also this mode is not suitable for pushing into a shared central repository, as other people may add new branches there, or update the tip of existing branches outside your control.</source>
          <target state="translated">이 모드를 효과적으로 사용하려면 &lt;code&gt;git push&lt;/code&gt; 를 실행하기 전에 푸시하려는 &lt;code&gt;all&lt;/code&gt; 분기를 푸시 할 준비가 되었는지 확인해야 합니다 . 이 모드의 핵심은 모든 분기를 한 번에 푸시 할 수 있기 때문입니다. 일반적으로 한 지점에서만 작업을 마치고 결과를 내보내는 반면 다른 지점은 완료되지 않은 경우이 모드는 적합하지 않습니다. 또한이 모드는 다른 사람이 새 분기를 추가하거나 기존 분기의 끝을 제어 할 수 없으므로 공유 중앙 저장소로 푸시하는 데 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0db2ead5af506998515a70d6693b9cc78c43968a" translate="yes" xml:space="preserve">
          <source>To verify that &lt;code&gt;master&lt;/code&gt; is indeed a superset of &lt;code&gt;maint&lt;/code&gt;, use git log:</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; 가 실제로 &lt;code&gt;maint&lt;/code&gt; 의 상위 집합인지 확인하려면 git log를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="25e07c07376edb7f994c3289d03610c1335d5288" translate="yes" xml:space="preserve">
          <source>Todo list</source>
          <target state="translated">할 일 목록</target>
        </trans-unit>
        <trans-unit id="feb6706843b17024c0f5d36ae4a2773f9f7a9d9e" translate="yes" xml:space="preserve">
          <source>Toggle the &quot;sparse&quot; algorithm to determine which objects to include in the pack, when combined with the &quot;--revs&quot; option. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. If this option is not included, it defaults to the value of &lt;code&gt;pack.useSparse&lt;/code&gt;, which is true unless otherwise specified.</source>
          <target state="translated">&quot;--revs&quot;옵션과 함께 사용하면 &quot;sparse&quot;알고리즘을 전환하여 팩에 포함 할 개체를 결정합니다. 이 알고리즘은 새 개체를 도입하는 경로에 나타나는 나무 만 걷습니다. 이것은 작은 변화를 보내기 위해 팩을 계산할 때 상당한 성능 이점을 가질 수 있습니다. 그러나 포함 된 커밋에 특정 유형의 직접 이름 변경이 포함 된 경우 추가 개체가 팩 파일에 추가 될 수 있습니다. 이 옵션이 포함되지 않은 경우 기본값은 &lt;code&gt;pack.useSparse&lt;/code&gt; 이며, 달리 지정하지 않는 한 true입니다.</target>
        </trans-unit>
        <trans-unit id="44e89f12173f1b11f3c33dfcf393dbeb53d74231" translate="yes" xml:space="preserve">
          <source>Toggle the pre-push hook (see &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;). The default is --verify, giving the hook a chance to prevent the push. With --no-verify, the hook is bypassed completely.</source>
          <target state="translated">프리 푸시 후크를 토글합니다 ( &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 참조 ). 기본값은 --verify이며 후크는 푸시를 방지 할 수 있습니다. --no-verify를 사용하면 후크가 완전히 바이 패스됩니다.</target>
        </trans-unit>
        <trans-unit id="e69b3ac557eee7192f98b057069c2f145301ef39" translate="yes" xml:space="preserve">
          <source>Topic branches</source>
          <target state="translated">토픽 브랜치</target>
        </trans-unit>
        <trans-unit id="99011a3381da15bff0042576b0bb55bb6ae9ffd0" translate="yes" xml:space="preserve">
          <source>TortoiseCVS</source>
          <target state="translated">TortoiseCVS</target>
        </trans-unit>
        <trans-unit id="9732ce69da01051c0a62cf40cfeb5063ebcf5c22" translate="yes" xml:space="preserve">
          <source>Trace the evolution of the line range given by &quot;&amp;lt;start&amp;gt;,&amp;lt;end&amp;gt;&quot; (or the function name regex &amp;lt;funcname&amp;gt;) within the &amp;lt;file&amp;gt;. You may not give any pathspec limiters. This is currently limited to a walk starting from a single revision, i.e., you may only give zero or one positive revision arguments, and &amp;lt;start&amp;gt; and &amp;lt;end&amp;gt; (or &amp;lt;funcname&amp;gt;) must exist in the starting revision. You can specify this option more than once. Implies &lt;code&gt;--patch&lt;/code&gt;. Patch output can be suppressed using &lt;code&gt;--no-patch&lt;/code&gt;, but other diff formats (namely &lt;code&gt;--raw&lt;/code&gt;, &lt;code&gt;--numstat&lt;/code&gt;, &lt;code&gt;--shortstat&lt;/code&gt;, &lt;code&gt;--dirstat&lt;/code&gt;, &lt;code&gt;--summary&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt;, &lt;code&gt;--name-status&lt;/code&gt;, &lt;code&gt;--check&lt;/code&gt;) are not currently implemented.</source>
          <target state="translated">&amp;lt;file&amp;gt; 내에서 &quot;&amp;lt;start&amp;gt;, &amp;lt;end&amp;gt;&quot;(또는 함수 이름 regex &amp;lt;funcname&amp;gt;)로 지정된 행 범위의 진화를 추적하십시오. 경로 스펙 리미터를 제공 할 수 없습니다. 현재는 단일 개정에서 시작하여 도보로 제한됩니다. 즉, 0 또는 하나의 긍정적 개정 인수 만 제공 할 수 있으며 &amp;lt;start&amp;gt; 및 &amp;lt;end&amp;gt; (또는 &amp;lt;funcname&amp;gt;)가 시작 개정에 있어야합니다. 이 옵션을 두 번 이상 지정할 수 있습니다. &lt;code&gt;--patch&lt;/code&gt; 를 의미 합니다. &lt;code&gt;--no-patch&lt;/code&gt; 를 사용하여 패치 출력을 억제 할 수 있지만 다른 diff 형식 (즉 &lt;code&gt;--raw&lt;/code&gt; , &lt;code&gt;--numstat&lt;/code&gt; , &lt;code&gt;--shortstat&lt;/code&gt; , &lt;code&gt;--dirstat&lt;/code&gt; , &lt;code&gt;--summary&lt;/code&gt; , &lt;code&gt;--name-only&lt;/code&gt; , &lt;code&gt;--name-status&lt;/code&gt; , &lt;code&gt;--check&lt;/code&gt; )은 현재 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b64ac9752a19150bbcc2229db77526c8ecf78f4e" translate="yes" xml:space="preserve">
          <source>Trace the evolution of the line range given by &lt;code&gt;&amp;lt;start&amp;gt;,&amp;lt;end&amp;gt;&lt;/code&gt;, or by the function name regex &lt;code&gt;&amp;lt;funcname&amp;gt;&lt;/code&gt;, within the &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt;. You may not give any pathspec limiters. This is currently limited to a walk starting from a single revision, i.e., you may only give zero or one positive revision arguments, and &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; (or &lt;code&gt;&amp;lt;funcname&amp;gt;&lt;/code&gt;) must exist in the starting revision. You can specify this option more than once. Implies &lt;code&gt;--patch&lt;/code&gt;. Patch output can be suppressed using &lt;code&gt;--no-patch&lt;/code&gt;, but other diff formats (namely &lt;code&gt;--raw&lt;/code&gt;, &lt;code&gt;--numstat&lt;/code&gt;, &lt;code&gt;--shortstat&lt;/code&gt;, &lt;code&gt;--dirstat&lt;/code&gt;, &lt;code&gt;--summary&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt;, &lt;code&gt;--name-status&lt;/code&gt;, &lt;code&gt;--check&lt;/code&gt;) are not currently implemented.</source>
          <target state="translated">&lt;code&gt;&amp;lt;start&amp;gt;,&amp;lt;end&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; 내에서 함수 이름 regex &lt;code&gt;&amp;lt;funcname&amp;gt;&lt;/code&gt; 에 의해 지정된 줄 범위의 진화를 추적합니다 . pathspec 제한자를 제공 할 수 없습니다. 이것은 현재 단일 개정에서 시작하는 걷기로 제한됩니다. 즉, 0 개 또는 1 개의 긍정적 인 개정 인수 만 제공 할 수 있으며 &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; (또는 &lt;code&gt;&amp;lt;funcname&amp;gt;&lt;/code&gt; )는 시작 개정에 있어야합니다. 이 옵션을 두 번 이상 지정할 수 있습니다. &lt;code&gt;--patch&lt;/code&gt; 를 의미 합니다. 패치 출력을 이용하여 억제 될 수있다 &lt;code&gt;--no-patch&lt;/code&gt; 있지만 DIFF 다른 형식 (즉 &lt;code&gt;--raw&lt;/code&gt; , &lt;code&gt;--numstat&lt;/code&gt; , &lt;code&gt;--shortstat&lt;/code&gt; , &lt;code&gt;--dirstat&lt;/code&gt; , &lt;code&gt;--summary&lt;/code&gt; , &lt;code&gt;--name-only&lt;/code&gt; , &lt;code&gt;--name-status&lt;/code&gt; , &lt;code&gt;--check&lt;/code&gt; )는 현재 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="324f1031e6064bf946ba7ad7de400c92a706ee71" translate="yes" xml:space="preserve">
          <source>Trace2 api</source>
          <target state="translated">Trace2 API</target>
        </trans-unit>
        <trans-unit id="f39bab439a6977ac76a84295e79b079d44b7d908" translate="yes" xml:space="preserve">
          <source>Trace2 config settings are only read from the system and global config files; repository local and worktree config files and &lt;code&gt;-c&lt;/code&gt; command line arguments are not respected.</source>
          <target state="translated">Trace2 구성 설정은 시스템 및 전역 구성 파일에서만 읽습니다. 저장소 로컬 및 작업 트리 구성 파일과 &lt;code&gt;-c&lt;/code&gt; 명령 행 인수는 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34f4d5fb2d35b898a8c6180c70ae5079360dafe0" translate="yes" xml:space="preserve">
          <source>Trace2 defines the following set of Trace2 Targets. Format details are given in a later section.</source>
          <target state="translated">Trace2는 다음과 같은 Trace2 대상 집합을 정의합니다. 형식 세부 사항은 다음 섹션에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="9cffe01770c87380a0c500c2ba4c5fe9919c83ec" translate="yes" xml:space="preserve">
          <source>Trace2 instrumentation throughout the Git code base sends Trace2 messages to the enabled Trace2 Targets. Targets transform these messages content into purpose-specific formats and write events to their data streams. In this manner, the Trace2 API can drive many different types of analysis.</source>
          <target state="translated">Git 코드베이스 전체의 Trace2 계측은 Trace2 메시지를 활성화 된 Trace2 대상으로 보냅니다. 대상은 이러한 메시지 컨텐츠를 목적 별 형식으로 변환하고 이벤트를 데이터 스트림에 씁니다. 이러한 방식으로 Trace2 API는 다양한 유형의 분석을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78edf21cb8a1d6593bdb09f0d046c88dfeb5c5d1" translate="yes" xml:space="preserve">
          <source>Trace2 is controlled using &lt;code&gt;trace2.*&lt;/code&gt; config values in the system and global config files and &lt;code&gt;GIT_TRACE2*&lt;/code&gt; environment variables. Trace2 does not read from repo local or worktree config files or respect &lt;code&gt;-c&lt;/code&gt; command line config settings.</source>
          <target state="translated">Trace2는 시스템 및 전역 구성 파일의 &lt;code&gt;trace2.*&lt;/code&gt; 구성 값과 &lt;code&gt;GIT_TRACE2*&lt;/code&gt; 환경 변수를 사용하여 제어됩니다 . Trace2는 repo 로컬 또는 작업 트리 구성 파일에서 읽지 않거나 &lt;code&gt;-c&lt;/code&gt; 명령 줄 구성 설정을 준수하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="952dc6d60a810a50f48d84409a5ca3162f18abfc" translate="yes" xml:space="preserve">
          <source>Trace2 is controlled using &lt;code&gt;trace2.&lt;/code&gt; config values in the system and global config files and &lt;code&gt;GIT_TRACE2&lt;/code&gt; environment variables. Trace2 does not read from repo local or worktree config files or respect &lt;code&gt;-c&lt;/code&gt; command line config settings.</source>
          <target state="translated">Trace2는 &lt;code&gt;trace2.&lt;/code&gt; 사용하여 제어됩니다 . 시스템 및 전역 구성 파일의 구성 값과 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 환경 변수. Trace2는 repo 로컬 또는 워크 트리 구성 파일에서 읽지 않거나 &lt;code&gt;-c&lt;/code&gt; 명령 행 구성 설정을 존중하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="20f68aac372bbc56e3b5b3e96aea0079529bedb9" translate="yes" xml:space="preserve">
          <source>Trace2 regions are similar to the existing trace_performance_enter() and trace_performance_leave() routines, but are thread safe and maintain per-thread stacks of timers.</source>
          <target state="translated">Trace2 영역은 기존 trace_performance_enter () 및 trace_performance_leave () 루틴과 유사하지만 스레드 안전하고 스레드 별 타이머 스택을 유지 관리합니다.</target>
        </trans-unit>
        <trans-unit id="8bded73626b8544423d59c1c5a0c1bfb684cb12e" translate="yes" xml:space="preserve">
          <source>Trace2 target formats</source>
          <target state="translated">Trace2 대상 형식</target>
        </trans-unit>
        <trans-unit id="e4cb4d4e7e519744d1375eb303304baebc567ae9" translate="yes" xml:space="preserve">
          <source>Trace2 targets</source>
          <target state="translated">Trace2 대상</target>
        </trans-unit>
        <trans-unit id="a0cfb1f78b98054b282b0aab138d8ea25f2c82bd" translate="yes" xml:space="preserve">
          <source>Tracking and contributing to an entire Subversion-managed project (complete with a trunk, tags and branches):</source>
          <target state="translated">전체 Subversion 관리 프로젝트 추적 및 기여 (트렁크, 태그 및 브랜치로 완료) :</target>
        </trans-unit>
        <trans-unit id="847895b0cdb93b975e4c930f95d66dabeb1e64d2" translate="yes" xml:space="preserve">
          <source>Tracking and contributing to the trunk of a Subversion-managed project (ignoring tags and branches):</source>
          <target state="translated">Subversion 관리 프로젝트의 트렁크 추적 및 기여 (태그 및 분기 무시) :</target>
        </trans-unit>
        <trans-unit id="667c19a45142471c0c20cc605b683a6a3152afb1" translate="yes" xml:space="preserve">
          <source>Traditionally, tips of branches and tags (collectively known as &lt;code&gt;refs&lt;/code&gt;) were stored one file per ref in a (sub)directory under &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; directory. While many branch tips tend to be updated often, most tags and some branch tips are never updated. When a repository has hundreds or thousands of tags, this one-file-per-ref format both wastes storage and hurts performance.</source>
          <target state="translated">전통적으로 브랜치 및 태그 (통칭하여 &lt;code&gt;refs&lt;/code&gt; )의 팁은 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 디렉토리 아래의 (하위) 디렉토리에 ref 당 하나의 파일로 저장되었습니다 . 많은 분기 팁이 자주 업데이트되는 경향이 있지만 대부분의 태그 및 일부 분기 팁은 업데이트되지 않습니다. 리포지토리에 수백 또는 수천 개의 태그가있는 경우이 참조 당 하나의 파일 형식은 스토리지를 낭비하고 성능을 저하시킵니다.</target>
        </trans-unit>
        <trans-unit id="a5cf7db57e9cf074478d171148671cc677faf56a" translate="yes" xml:space="preserve">
          <source>Trailing spaces are ignored unless they are quoted with backslash (&quot;&lt;code&gt;\&lt;/code&gt;&quot;).</source>
          <target state="translated">후행 공백은 백 슬래시 ( &quot; &lt;code&gt;\&lt;/code&gt; &quot;) 로 인용하지 않으면 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="18baa50eee1aac68104e16bd4ad94c661cde3869" translate="yes" xml:space="preserve">
          <source>Transfer size: In its current form Git requires the whole working tree present. It does not allow partial trees to be transferred in fetch or clone. If the project you work on consists of multiple repositories tied together as submodules in a superproject, you can avoid fetching the working trees of the repositories you are not interested in.</source>
          <target state="translated">전송 크기 : 현재 형태로 Git에는 전체 작업 트리가 필요합니다. 부분 트리를 페치 또는 복제로 전송할 수 없습니다. 작업중인 프로젝트가 수퍼 프로젝트에서 하위 모듈로 묶여있는 여러 저장소로 구성된 경우 관심없는 저장소의 작업 트리를 가져 오는 것을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdf6a912dffd18ed6042052fce8610d96ce56a71" translate="yes" xml:space="preserve">
          <source>Transform stdin by substituting all the 40-character SHA-1 hexes (say $hex) with &quot;$hex ($rev_name)&quot;. When used with --name-only, substitute with &quot;$rev_name&quot;, omitting $hex altogether. Intended for the scripter&amp;rsquo;s use.</source>
          <target state="translated">모든 40 자 SHA-1 헥스 (예 : $ hex)를 &quot;$ hex ($ rev_name)&quot;로 대체하여 stdin을 변환하십시오. --name-only와 함께 사용하는 경우 $ hex를 생략하고 &quot;$ rev_name&quot;으로 대체하십시오. 스크립터의 사용을 목적으로합니다.</target>
        </trans-unit>
        <trans-unit id="fc873c381aea0c960eb3ebd47773defb66d7e124" translate="yes" xml:space="preserve">
          <source>Transmit &amp;lt;string&amp;gt; as a push option. As the push option must not contain LF or NUL characters, the string is not encoded.</source>
          <target state="translated">&amp;lt;string&amp;gt;을 푸시 옵션으로 전송하십시오. push 옵션은 LF 또는 NUL 문자를 포함하지 않아야하므로 문자열이 인코딩되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32bd61986aca00f68612950bbcdb4915d3d0e846" translate="yes" xml:space="preserve">
          <source>Transmit the given string to the server when communicating using protocol version 2. The given string must not contain a NUL or LF character. The server&amp;rsquo;s handling of server options, including unknown ones, is server-specific. When multiple &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; are given, they are all sent to the other side in the order listed on the command line.</source>
          <target state="translated">프로토콜 버전 2를 사용하여 통신 할 때 지정된 문자열을 서버로 전송하십시오. 주어진 문자열에는 NUL 또는 LF 문자가 포함되어서는 안됩니다. 알 수없는 옵션을 포함하여 서버의 서버 옵션 처리는 서버마다 다릅니다. 여러 개의 &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; 이 제공되면 모두 명령 줄에 나열된 순서대로 다른쪽으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="39635a03df29b9789e505a1038590e24ea96c9e9" translate="yes" xml:space="preserve">
          <source>Transmit the given string to the server when communicating using protocol version 2. The given string must not contain a NUL or LF character. When multiple &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; are given, they are all sent to the other side in the order listed on the command line.</source>
          <target state="translated">프로토콜 버전 2를 사용하여 통신 할 때 지정된 문자열을 서버로 전송하십시오. 주어진 문자열에는 NUL 또는 LF 문자가 포함되어서는 안됩니다. 여러 개의 &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; 이 제공되면 모두 명령 줄에 나열된 순서대로 다른쪽으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="2995fbcc2c84443582483713456b482a39b63e37" translate="yes" xml:space="preserve">
          <source>Transmit the given string to the server, which passes them to the pre-receive as well as the post-receive hook. The given string must not contain a NUL or LF character. When multiple &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; are given, they are all sent to the other side in the order listed on the command line. When no &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; is given from the command line, the values of configuration variable &lt;code&gt;push.pushOption&lt;/code&gt; are used instead.</source>
          <target state="translated">주어진 문자열을 서버로 전송하여 수신 후 후크뿐만 아니라 수신 후 후크로 전달합니다. 주어진 문자열은 NUL 또는 LF 문자를 포함해서는 안됩니다. 여러 개의 &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; 이 제공되면 모두 명령 행에 나열된 순서대로 다른쪽으로 전송됩니다. 어떠한 경우 &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; 커맨드 라인에서 제공되지 않는 구성 변수의 값 &lt;code&gt;push.pushOption&lt;/code&gt; 가 대신 사용된다.</target>
        </trans-unit>
        <trans-unit id="9960fbc3363c91bebbbc4dae3127f4935a1a22d6" translate="yes" xml:space="preserve">
          <source>Treat all files as text.</source>
          <target state="translated">모든 파일을 텍스트로 취급하십시오.</target>
        </trans-unit>
        <trans-unit id="a08e9c61e543dccc4a24afe7a10c95737cbb1ca7" translate="yes" xml:space="preserve">
          <source>Treat pathspecs literally (i.e. no globbing, no pathspec magic). This is equivalent to setting the &lt;code&gt;GIT_LITERAL_PATHSPECS&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">경로 스펙을 문자 그대로 처리하십시오 (예 : 글 로빙, 경로 스펙 마법 없음). 이것은 &lt;code&gt;GIT_LITERAL_PATHSPECS&lt;/code&gt; 환경 변수를 &lt;code&gt;1&lt;/code&gt; 로 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8024445062b4bb90b2e84a4da6e0bb207f37b5f4" translate="yes" xml:space="preserve">
          <source>Treat the &amp;lt;string&amp;gt; given to &lt;code&gt;-S&lt;/code&gt; as an extended POSIX regular expression to match.</source>
          <target state="translated">&lt;code&gt;-S&lt;/code&gt; 에 제공된 &amp;lt;string&amp;gt;을 확장 POSIX 정규식으로 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="72315ec1092243bb561e5b4697869abb3601099e" translate="yes" xml:space="preserve">
          <source>Treat the repository as a bare repository. If GIT_DIR environment is not set, it is set to the current working directory.</source>
          <target state="translated">저장소를 Bare 저장소로 취급하십시오. GIT_DIR 환경이 설정되지 않은 경우 현재 작업 디렉토리로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1dad3a3b77cbf00bf58d87ee853af6d3cddb344a" translate="yes" xml:space="preserve">
          <source>Treat the revision argument as a &amp;lt;revision range&amp;gt;, even if it is just a single commit (that would normally be treated as a &amp;lt;since&amp;gt;). Note that root commits included in the specified range are always formatted as creation patches, independently of this flag.</source>
          <target state="translated">개정 인수는 단일 커밋 일지라도 (보통 &amp;lt;since&amp;gt;로 취급 될지라도) &amp;lt;revision range&amp;gt;로 취급하십시오. 지정된 범위에 포함 된 루트 커밋은이 플래그와 관계없이 항상 생성 패치로 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="aa88eae97d6ad1936bc41000081122649aee8d74" translate="yes" xml:space="preserve">
          <source>Treats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge. Whitespace changes mixed with other changes to a line are not ignored. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;-b&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, &lt;code&gt;--ignore-space-at-eol&lt;/code&gt;, and &lt;code&gt;--ignore-cr-at-eol&lt;/code&gt;.</source>
          <target state="translated">3 방향 병합을 위해 표시된 유형의 공백 변경이있는 행을 변경되지 않은 것으로 취급합니다. 행에 대한 다른 변경 사항과 혼합 된 공백 변경 사항은 무시되지 않습니다. 참고 &lt;a href=&quot;git-diff&quot;&gt;자식 DIFF-[1] &lt;/a&gt; &lt;code&gt;-b&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;--ignore-space-at-eol&lt;/code&gt; 및 &lt;code&gt;--ignore-cr-at-eol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ddd0e484558c1f8e50a8fe3c2dc7499225a9297" translate="yes" xml:space="preserve">
          <source>Tree Object</source>
          <target state="translated">트리 객체</target>
        </trans-unit>
        <trans-unit id="bce93b7f9d4c3064a3f582b574710500d7e5efb5" translate="yes" xml:space="preserve">
          <source>Tree and blob objects outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; will be treated the same way as if they were inside &lt;code&gt;refs/tags/*&lt;/code&gt;, any update of them will be rejected.</source>
          <target state="translated">&lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 외부의 Tree 및 blob 객체 는 &lt;code&gt;refs/tags/*&lt;/code&gt; 내부와 동일한 방식으로 처리되며 모든 업데이트는 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="faed43d5018a65bdda1021ea817b81efdd882a1f" translate="yes" xml:space="preserve">
          <source>Tree objects as well as tag objects not pointing at commits, cannot be described. When describing blobs, the lightweight tags pointing at blobs are ignored, but the blob is still described as &amp;lt;committ-ish&amp;gt;:&amp;lt;path&amp;gt; despite the lightweight tag being favorable.</source>
          <target state="translated">커밋을 가리 키지 않는 태그 객체뿐만 아니라 트리 객체도 설명 할 수 없습니다. 블롭을 기술 할 때, 블롭을 가리키는 경량 태그는 무시되지만, 경량 태그가 유리하지만 블롭은 여전히 ​​&amp;lt;committ-ish&amp;gt; : &amp;lt;path&amp;gt;로 기술된다.</target>
        </trans-unit>
        <trans-unit id="d94a666a1561928de12071aa36f46464acd70f54" translate="yes" xml:space="preserve">
          <source>Tree to checkout from (when paths are given). If not specified, the index will be used.</source>
          <target state="translated">체크 아웃 할 트리 (경로가 제공 될 때). 지정하지 않으면 인덱스가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fef8232d1c67b8b3403ba454c8ae3c965dc5fb72" translate="yes" xml:space="preserve">
          <source>Trees (aka directories) use just 12 bytes of memory on top of the memory required for their entries (see &amp;ldquo;per active file&amp;rdquo; below). The cost of a tree is virtually 0, as its overhead amortizes out over the individual file entries.</source>
          <target state="translated">트리 (일명 디렉토리)는 항목에 필요한 메모리 위에 12 바이트의 메모리 만 사용합니다 (아래의 &quot;활성 파일 당&quot;참조). 오버 헤드가 개별 파일 항목을 넘어 서기 때문에 트리의 비용은 거의 0입니다.</target>
        </trans-unit>
        <trans-unit id="2bb80d7d00c0395ecaf93c5dc9cd657c191b576d" translate="yes" xml:space="preserve">
          <source>Tries to reinstate not only the working tree&amp;rsquo;s changes, but also the index&amp;rsquo;s ones. However, this can fail, when you have conflicts (which are stored in the index, where you therefore can no longer apply the changes as they were originally).</source>
          <target state="translated">작업 트리의 변경 사항뿐만 아니라 인덱스의 변경 사항도 복원하려고합니다. 그러나 충돌이 발생하면 실패 할 수 있습니다 (인덱스에 저장되어 더 이상 변경 사항을 원래 그대로 적용 할 수 없음).</target>
        </trans-unit>
        <trans-unit id="8797468d6463e4f71332170d9f50ca7fd321cc3a" translate="yes" xml:space="preserve">
          <source>Trivial merges are done by &lt;code&gt;git read-tree&lt;/code&gt; itself. Only conflicting paths will be in unmerged state when &lt;code&gt;git read-tree&lt;/code&gt; returns.</source>
          <target state="translated">사소한 병합은 &lt;code&gt;git read-tree&lt;/code&gt; 자체에 의해 수행됩니다 . &lt;code&gt;git read-tree&lt;/code&gt; 가 반환 되면 충돌하는 경로 만 병합되지 않은 상태가됩니다 .</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="c14d8e783a9f521d30b73eb971eac8f82acc62a0" translate="yes" xml:space="preserve">
          <source>True merge</source>
          <target state="translated">진정한 병합</target>
        </trans-unit>
        <trans-unit id="33a579ffc0dccbff15be01734ea4138ea4e7635c" translate="yes" xml:space="preserve">
          <source>Trust</source>
          <target state="translated">Trust</target>
        </trans-unit>
        <trans-unit id="df8a0e781552ee165e12d7086194c5f37262dc36" translate="yes" xml:space="preserve">
          <source>Try to speed up the traversal using the pack bitmap index (if one is available). Note that when traversing with &lt;code&gt;--objects&lt;/code&gt;, trees and blobs will not have their associated path printed.</source>
          <target state="translated">팩 비트 맵 인덱스 (사용 가능한 경우)를 사용하여 순회 속도를 높이십시오. &lt;code&gt;--objects&lt;/code&gt; 로 순회 할 때 나무와 얼룩에는 연관된 경로가 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db494399fc91d335ea933090c261cf51f7615da6" translate="yes" xml:space="preserve">
          <source>Try to update from the upstream resulted in a lot of conflicts; you were not ready to spend a lot of time merging right now, so you decide to do that later.</source>
          <target state="translated">업스트림에서 업데이트하려고하면 많은 충돌이 발생했습니다. 지금 병합하는 데 많은 시간을 할애 할 준비가되지 않았으므로 나중에 그렇게하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="3a12d2b4901990f4e580a360ff850809fe3f67b9" translate="yes" xml:space="preserve">
          <source>Turn off any previous &lt;code&gt;--filter=&lt;/code&gt; argument.</source>
          <target state="translated">이전 &lt;code&gt;--filter=&lt;/code&gt; 인수를 끄십시오 .</target>
        </trans-unit>
        <trans-unit id="34771065d121fc03fac8d38d540e254893826329" translate="yes" xml:space="preserve">
          <source>Turn off branch colors, even when the configuration file gives the default to color output. Same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">구성 파일이 기본값으로 컬러 출력을 제공하더라도 분기 컬러를 끕니다. &lt;code&gt;--color=never&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="6d9cbb32ce6c68e264cdb30b91e954cf183958d3" translate="yes" xml:space="preserve">
          <source>Turn off colored diff. It is the same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">컬러 차이를 끄십시오. &lt;code&gt;--color=never&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3d9b2354f095eeb41acddbf4f3d69d4ac5775813" translate="yes" xml:space="preserve">
          <source>Turn off colored diff. This can be used to override configuration settings. It is the same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">컬러 차이를 끄십시오. 구성 설정을 재정의하는 데 사용할 수 있습니다. &lt;code&gt;--color=never&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8ad464ef4a6c59cdcb2319e829113b9b9a0202fe" translate="yes" xml:space="preserve">
          <source>Turn off colored output, even when the configuration file gives the default to color output. Same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">구성 파일이 기본값을 컬러 출력으로 설정하더라도 컬러 출력을 끕니다. &lt;code&gt;--color=never&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="a3a997309d5fb6a6ca30f0f6201f278a284d8e1e" translate="yes" xml:space="preserve">
          <source>Turn off match highlighting, even when the configuration file gives the default to color output. Same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">구성 파일이 기본값으로 컬러 출력을 제공하더라도 일치 강조 표시를 끕니다. &lt;code&gt;--color=never&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="d4fab0f230de92fdcff08739247b39013a4dcf91" translate="yes" xml:space="preserve">
          <source>Turn off move detection. This can be used to override configuration settings. It is the same as &lt;code&gt;--color-moved=no&lt;/code&gt;.</source>
          <target state="translated">움직임 감지를 끕니다. 구성 설정을 재정의하는 데 사용할 수 있습니다. 그것과 동일 &lt;code&gt;--color-moved=no&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0eb0b106db412297afc722cb22850ad8fd89466" translate="yes" xml:space="preserve">
          <source>Turn off rename detection, even when the configuration file gives the default to do so.</source>
          <target state="translated">구성 파일이 기본값을 제공하더라도 이름 바꾸기 감지 기능을 끄십시오.</target>
        </trans-unit>
        <trans-unit id="4e867193eda90e02a99d5e3b2d3aff016424ee32" translate="yes" xml:space="preserve">
          <source>Turn off rename detection. This overrides the &lt;code&gt;merge.renames&lt;/code&gt; configuration variable. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--no-renames&lt;/code&gt;.</source>
          <target state="translated">이름 변경 감지 기능을 해제하십시오. 이는 &lt;code&gt;merge.renames&lt;/code&gt; 구성 변수를 대체합니다 . &lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--no-renames&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29eb4a9a74bb1156273caaa264fc85825c0572ef" translate="yes" xml:space="preserve">
          <source>Turn on rename detection, optionally setting the similarity threshold. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--find-renames&lt;/code&gt;.</source>
          <target state="translated">이름 변경 감지를 켜고 선택적으로 유사성 임계 값을 설정하십시오. &lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--find-renames&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a279dbfc86c680add56c7a5993ef6023dec20637" translate="yes" xml:space="preserve">
          <source>Turn on rename detection, optionally setting the similarity threshold. This is the default. This overrides the &lt;code&gt;merge.renames&lt;/code&gt; configuration variable. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--find-renames&lt;/code&gt;.</source>
          <target state="translated">이름 변경 감지를 켜고 선택적으로 유사성 임계 값을 설정하십시오. 이것이 기본값입니다. 이는 &lt;code&gt;merge.renames&lt;/code&gt; 구성 변수를 대체합니다 . &lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--find-renames&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9d077a66918e3017c929a4d5ef75e05f491a825" translate="yes" xml:space="preserve">
          <source>Turn on/off rename detection regardless of user configuration. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--no-renames&lt;/code&gt;.</source>
          <target state="translated">사용자 구성에 관계없이 이름 바꾸기 감지를 켜거나 끕니다. &lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--no-renames&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff597cb2e8f500da1bb43f369ea55f0017801fbc" translate="yes" xml:space="preserve">
          <source>Turn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal.</source>
          <target state="translated">진행 상황을 명시 적으로 켜거나 끕니다. 어느 것도 지정하지 않으면 표준 오류가 터미널에 연결된 경우 진행률이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b63e204e5b5bb236923126ba202fed353f8079ec" translate="yes" xml:space="preserve">
          <source>Turn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal. Note that not all merge strategies may support progress reporting.</source>
          <target state="translated">진행 상황을 명시 적으로 켜거나 끕니다. 어느 것도 지정하지 않으면 표준 오류가 터미널에 연결된 경우 진행률이 표시됩니다. 모든 병합 전략이 진행률보고를 지원하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae22b8d4ecb731b706e41a653df929373ee8e8e0" translate="yes" xml:space="preserve">
          <source>Turns off any previous &lt;code&gt;--filter=&lt;/code&gt; argument.</source>
          <target state="translated">이전 &lt;code&gt;--filter=&lt;/code&gt; 인수를 끕니다 .</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="954e9a2594b4d5687b25c9c1a8357bca3253b18f" translate="yes" xml:space="preserve">
          <source>Tweaking diff output</source>
          <target state="translated">diff 출력 조정</target>
        </trans-unit>
        <trans-unit id="aef2d842e6b781b12f96bc62f4ab607c12e12218" translate="yes" xml:space="preserve">
          <source>Two Tree Merge</source>
          <target state="translated">두 트리 병합</target>
        </trans-unit>
        <trans-unit id="6bda5442e87e811366b94ce6966009ecac6ac5dc" translate="yes" xml:space="preserve">
          <source>Two consecutive asterisks (&quot;&lt;code&gt;**&lt;/code&gt;&quot;) in patterns matched against full pathname may have special meaning:</source>
          <target state="translated">전체 경로 이름과 일치하는 패턴에서 두 개의 연속 별표 ( &quot; &lt;code&gt;**&lt;/code&gt; &quot;)는 특별한 의미를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e187ca5222f2f1c9a298321896225faf75c5697a" translate="yes" xml:space="preserve">
          <source>Two consecutive asterisks (&amp;ldquo;**&amp;rdquo;) in patterns matched against full pathname may have special meaning:</source>
          <target state="translated">전체 경로 이름과 일치하는 패턴에서 두 개의 연속 별표 (&amp;ldquo;**&amp;rdquo;)는 특별한 의미를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fce699584c34eaef39ec9c341ad51961e194a419" translate="yes" xml:space="preserve">
          <source>Two special values are supported: &lt;code&gt;off&lt;/code&gt; will simply close the corresponding standard handle, and if &lt;code&gt;GIT_REDIRECT_STDERR&lt;/code&gt; is &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;, standard error will be redirected to the same handle as standard output.</source>
          <target state="translated">두 가지 특수 값이 지원됩니다. &lt;code&gt;off&lt;/code&gt; 는 해당 표준 핸들을 닫고 &lt;code&gt;GIT_REDIRECT_STDERR&lt;/code&gt; 이 &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt; 이면 표준 오류는 표준 출력과 동일한 핸들로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="34a739d621f3038babff4f0f681d077135e77a75" translate="yes" xml:space="preserve">
          <source>Two things are interesting here:</source>
          <target state="translated">두 가지 흥미로운 점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ced48512ad4d3cb13ca20b7cb1f2f8e4abd0bc9d" translate="yes" xml:space="preserve">
          <source>Tying it all together</source>
          <target state="translated">모두 함께 묶어</target>
        </trans-unit>
        <trans-unit id="3a87a5a93967e0c0facb5bdbedab0a6936494920" translate="yes" xml:space="preserve">
          <source>Type 5 is reserved for future expansion. Type 0 is invalid.</source>
          <target state="translated">유형 5는 향후 확장을 위해 예약되어 있습니다. 유형 0이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8e8d3184972cec12ef3bd94d7eec7947cbe4b53" translate="yes" xml:space="preserve">
          <source>Typical gitweb config files will only change starting (default) time zone, and leave other elements at their default values:</source>
          <target state="translated">일반적인 gitweb 설정 파일은 시작 (기본) 시간대 만 변경하고 다른 요소는 기본값으로 둡니다.</target>
        </trans-unit>
        <trans-unit id="3aa25a3911a2da2f000729dbc451ee040fee4a66" translate="yes" xml:space="preserve">
          <source>Typical usage is something like:</source>
          <target state="translated">일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db1f5b1028dc570d4bb8caccd45a45601a38210c" translate="yes" xml:space="preserve">
          <source>Typical use of git credential</source>
          <target state="translated">git 자격 증명의 일반적인 사용</target>
        </trans-unit>
        <trans-unit id="d63a8a509d39725ec5fc85189ba54ffbab2dd0bb" translate="yes" xml:space="preserve">
          <source>Typically it will be placed in a MUA&amp;rsquo;s drafts folder, edited to add timely commentary that should not go in the changelog after the three dashes, and then sent as a message whose body, in our example, starts with &quot;arch/arm config files were&amp;hellip;​&quot;. On the receiving end, readers can save interesting patches in a UNIX mailbox and apply them with &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;.</source>
          <target state="translated">일반적으로 MUA의 임시 보관함 폴더에 배치되고 세 개의 대시 후에 변경 로그에 포함되지 않아야하는 적절한 주석을 추가하도록 편집 된 다음 본문에서 &quot;arch / arm 구성 파일은 다음과 같이 시작됩니다. &amp;hellip; &quot;. 수신 측에서 독자는 흥미로운 패치를 UNIX 메일함에 저장하고 &lt;a href=&quot;git-am&quot;&gt;git-am [1]으로&lt;/a&gt; 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b51965ce078cc4b0d9ecb0a1b113a383a8700dc" translate="yes" xml:space="preserve">
          <source>Typically such a variable may look like this:</source>
          <target state="translated">일반적으로 이러한 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f47be9cc1e7fcec80fcc7e52dcbd486a27d2ee2" translate="yes" xml:space="preserve">
          <source>Typically this is run with a script calling Git&amp;rsquo;s imitation of the &lt;code&gt;merge&lt;/code&gt; command from the RCS package.</source>
          <target state="translated">일반적으로 이것은 RCS 패키지에서 &lt;code&gt;merge&lt;/code&gt; 명령 에 대한 Git의 모방을 호출하는 스크립트로 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="e4333d902cedfd0d4739277fdec621b3f9f09422" translate="yes" xml:space="preserve">
          <source>Typically this matches the real type of &amp;lt;object&amp;gt; but asking for a type that can trivially be dereferenced from the given &amp;lt;object&amp;gt; is also permitted. An example is to ask for a &quot;tree&quot; with &amp;lt;object&amp;gt; being a commit object that contains it, or to ask for a &quot;blob&quot; with &amp;lt;object&amp;gt; being a tag object that points at it.</source>
          <target state="translated">일반적으로 이것은 &amp;lt;object&amp;gt;의 실제 유형과 일치하지만 주어진 &amp;lt;object&amp;gt;에서 사소하게 역 참조 될 수있는 유형을 요구하는 것도 허용됩니다. 예를 들어 &amp;lt;object&amp;gt;가 포함 된 커밋 객체 인 &quot;tree&quot;를 요청하거나 &amp;lt;object&amp;gt;가이를 가리키는 태그 객체 인 &quot;blob&quot;를 요청하는 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b016c5601edd059fd8dc12bb8d8426b6525fff2" translate="yes" xml:space="preserve">
          <source>Typically you would first remove all tracked files from the working tree using this command:</source>
          <target state="translated">일반적으로 다음 명령을 사용하여 작업 트리에서 추적 된 모든 파일을 먼저 제거합니다.</target>
        </trans-unit>
        <trans-unit id="3a2ee6ee14f11a86e1818d26c21e9493d38718f1" translate="yes" xml:space="preserve">
          <source>Typically, parallel recursive and multi-remote fetches will be faster. By default fetches are performed sequentially, not in parallel.</source>
          <target state="translated">일반적으로 병렬 재귀 및 다중 원격 반입이 더 빠릅니다. 기본적으로 페치는 병렬이 아닌 순차적으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="94e92e77c127b9c8a314ec2c48c4916e008c6404" translate="yes" xml:space="preserve">
          <source>Typically, this is invoked as &lt;code&gt;git read-tree -m $H $M&lt;/code&gt;, where $H is the head commit of the current repository, and $M is the head of a foreign tree, which is simply ahead of $H (i.e. we are in a fast-forward situation).</source>
          <target state="translated">일반적으로 이것은 &lt;code&gt;git read-tree -m $H $M&lt;/code&gt; 으로 호출됩니다 . 여기서 $ H는 현재 저장소의 헤드 커밋이고 $ M은 외부 트리의 헤드입니다. 빠른 상황에 처해 있습니다).</target>
        </trans-unit>
        <trans-unit id="0ada5827188094ef6e82c28e45e078ca96f54ca4" translate="yes" xml:space="preserve">
          <source>U: file is unmerged (you must complete the merge before it can be committed)</source>
          <target state="translated">U : 파일이 병합 해제되었습니다 (커밋하기 전에 병합을 완료해야합니다)</target>
        </trans-unit>
        <trans-unit id="1a7a0d0dd35212ae4c8c4c873315c6e7e9351f3b" translate="yes" xml:space="preserve">
          <source>URI and label (title) for the Git logo link (or your site logo, if you chose to use different logo image). By default, these both refer to Git homepage, &lt;a href=&quot;https://git-scm.com&quot;&gt;https://git-scm.com&lt;/a&gt;; in the past, they pointed to Git documentation at &lt;a href=&quot;https://www.kernel.org&quot;&gt;https://www.kernel.org&lt;/a&gt;.</source>
          <target state="translated">Git 로고 링크 (또는 다른 로고 이미지를 사용하기로 선택한 경우 사이트 로고)의 URI 및 레이블 (제목). 기본적으로 이들은 둘 다 Git 홈페이지 &lt;a href=&quot;https://git-scm.com&quot;&gt;https://git-scm.com을 참조합니다&lt;/a&gt; . 과거에는 &lt;a href=&quot;https://www.kernel.org&quot;&gt;https://www.kernel.org의&lt;/a&gt; Git 문서를 가리 켰습니다 .</target>
        </trans-unit>
        <trans-unit id="8561702ffd22bbb5ccd1a81c9c8d8cc77f16fa7e" translate="yes" xml:space="preserve">
          <source>Un-sets the previously set type specifier (if one was previously set). This option requests that &lt;code&gt;git config&lt;/code&gt; not canonicalize the retrieved variable. &lt;code&gt;--no-type&lt;/code&gt; has no effect without &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; or &lt;code&gt;--&amp;lt;type&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이전에 설정 한 유형 지정자를 설정 해제합니다 (이전에 설정 한 경우). 이 옵션은 &lt;code&gt;git config&lt;/code&gt; 가 검색된 변수를 정규화 할 수 없도록 요청 합니다. &lt;code&gt;--no-type&lt;/code&gt; 은 &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;--&amp;lt;type&amp;gt;&lt;/code&gt; 없이는 효과가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="911839695653d988872929c95814b8902e300040" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;--pretty=oneline&lt;/code&gt;, the commit message is prefixed with this information on the same line. This option cannot be combined with &lt;code&gt;--reverse&lt;/code&gt;. See also &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt;.</source>
          <target state="translated">아래 &lt;code&gt;--pretty=oneline&lt;/code&gt; 의 메시지가 같은 줄에이 정보로 시작됩니다 커밋합니다. 이 옵션은 &lt;code&gt;--reverse&lt;/code&gt; 와 함께 사용할 수 없습니다 . &lt;a href=&quot;git-reflog&quot;&gt;git-reflog [1]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="64ba59969ba5a36d002d9a189101c624fcf7d3cc" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;--pretty=reference&lt;/code&gt;, this information will not be shown at all.</source>
          <target state="translated">아래 &lt;code&gt;--pretty=reference&lt;/code&gt; 이 정보는 전혀 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c73a6e04cc57ad10ee4ae7284f559a5ae2a53d36" translate="yes" xml:space="preserve">
          <source>Under certain circumstances, some versions of &lt;code&gt;diff&lt;/code&gt; do not correctly detect a missing new-line at the end of the file. As a result, patches created by such &lt;code&gt;diff&lt;/code&gt; programs do not record incomplete lines correctly. This option adds support for applying such patches by working around this bug.</source>
          <target state="translated">특정 상황에서 일부 버전의 &lt;code&gt;diff&lt;/code&gt; 는 파일 끝에서 누락 된 줄 바꿈을 올바르게 감지하지 못합니다. 결과적으로 이러한 &lt;code&gt;diff&lt;/code&gt; 프로그램으로 작성된 패치는 불완전한 행을 올바르게 기록하지 않습니다. 이 옵션은이 버그를 해결하여 이러한 패치 적용에 대한 지원을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="67a27dbf5548d05ac63e85bd8b4c875d8f48c102" translate="yes" xml:space="preserve">
          <source>Understanding History: Commits</source>
          <target state="translated">역사 이해 : 커밋</target>
        </trans-unit>
        <trans-unit id="9334dba95d5dfb2042093dd9adbddea5f77c5eb4" translate="yes" xml:space="preserve">
          <source>Understanding history: History diagrams</source>
          <target state="translated">히스토리 이해 : 히스토리 다이어그램</target>
        </trans-unit>
        <trans-unit id="85bd1a7ea75afef7e0417cd2bf9d9f3cf13e5e08" translate="yes" xml:space="preserve">
          <source>Understanding history: What is a branch?</source>
          <target state="translated">역사 이해 : 지사는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6d61d96a492f996316f1e84e66cbfde933315e2c" translate="yes" xml:space="preserve">
          <source>Understanding history: commits, parents, and reachability</source>
          <target state="translated">역사 이해 : 커밋, 부모 및 접근성</target>
        </trans-unit>
        <trans-unit id="afa47a28efb9d6631a7be02ac359bed5256995ce" translate="yes" xml:space="preserve">
          <source>Undo a commit and redo</source>
          <target state="translated">커밋 실행 취소 및 다시 실행</target>
        </trans-unit>
        <trans-unit id="61cb90c052dfcd0fda883c6029d1d0fc0a0f4685" translate="yes" xml:space="preserve">
          <source>Undo a commit, making it a topic branch</source>
          <target state="translated">커밋을 취소하여 주제 분기로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="93d74feb000c815128d68a09c83733db43b69c15" translate="yes" xml:space="preserve">
          <source>Undo a merge or pull</source>
          <target state="translated">병합 취소 또는 풀</target>
        </trans-unit>
        <trans-unit id="4728c70cd06347b5f285fb3e7887387303b3968e" translate="yes" xml:space="preserve">
          <source>Undo a merge or pull inside a dirty working tree</source>
          <target state="translated">병합 작업을 취소하거나 더러운 작업 트리 내부로 가져 오기</target>
        </trans-unit>
        <trans-unit id="27b7abb5b90b7a2e8f00eaf74b6df8323ba7d926" translate="yes" xml:space="preserve">
          <source>Undo add</source>
          <target state="translated">추가 취소</target>
        </trans-unit>
        <trans-unit id="ca677a11d37ffdca5231911a194cc2fcdffc5a26" translate="yes" xml:space="preserve">
          <source>Undo commits permanently</source>
          <target state="translated">영구적으로 커밋 취소</target>
        </trans-unit>
        <trans-unit id="4180759bca2f04cde0ec69611cb0e0ec1cfe7139" translate="yes" xml:space="preserve">
          <source>Undoes the effects of &lt;code&gt;fetch&lt;/code&gt; back to the specified revision. This allows you to re-&lt;code&gt;fetch&lt;/code&gt; an SVN revision. Normally the contents of an SVN revision should never change and &lt;code&gt;reset&lt;/code&gt; should not be necessary. However, if SVN permissions change, or if you alter your --ignore-paths option, a &lt;code&gt;fetch&lt;/code&gt; may fail with &quot;not found in commit&quot; (file not previously visible) or &quot;checksum mismatch&quot; (missed a modification). If the problem file cannot be ignored forever (with --ignore-paths) the only way to repair the repo is to use &lt;code&gt;reset&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 의 효과를 지정된 개정으로 되돌 립니다. SVN 개정판 을 다시 &lt;code&gt;fetch&lt;/code&gt; 수 있습니다 . 일반적으로 SVN 개정판의 내용은 변경 되지 않으며 &lt;code&gt;reset&lt;/code&gt; 할 필요가 없습니다. 그러나 SVN 권한이 변경되거나 --ignore-paths 옵션을 변경 하면 &quot;커밋에서 찾을 수 없음&quot;(이전에 표시되지 않은 파일) 또는 &quot;체크섬 불일치&quot;(수정이 누락 됨)와 함께 &lt;code&gt;fetch&lt;/code&gt; 가 실패 할 수 있습니다. 문제 파일을 --ignore-paths로 영원히 무시할 수없는 경우 repo를 복구하는 유일한 방법은 &lt;code&gt;reset&lt;/code&gt; 을 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="ac1f58f831611819b4114b80dd55e3ce540d5b23" translate="yes" xml:space="preserve">
          <source>Undoing a merge</source>
          <target state="translated">병합 취소</target>
        </trans-unit>
        <trans-unit id="f552d5a5802e3df6273c784214def9840b82f594" translate="yes" xml:space="preserve">
          <source>Unfortunately this system becomes inefficient once a project has a lot of objects. Try this on an old project:</source>
          <target state="translated">불행히도이 시스템은 프로젝트에 많은 객체가 있으면 비효율적입니다. 오래된 프로젝트에서 이것을 시도하십시오 :</target>
        </trans-unit>
        <trans-unit id="c7deb06b3e42a38e2b00598939aa39f8d24897bd" translate="yes" xml:space="preserve">
          <source>Unfortunately, the desired effect of cleaning up text files with mixed line endings and the undesired effect of corrupting binary files cannot be distinguished. In both cases CRLFs are removed in an irreversible way. For text files this is the right thing to do because CRLFs are line endings, while for binary files converting CRLFs corrupts data.</source>
          <target state="translated">불행하게도, 줄 끝이 혼합 된 텍스트 파일을 정리하는 원하는 효과와 이진 파일을 손상시키는 원하지 않는 효과는 구분할 수 없습니다. 두 경우 모두 CRLF는 되돌릴 수없는 방식으로 제거됩니다. 텍스트 파일의 경우 CRLF가 줄 끝이므로 이진 파일의 경우 CRLF를 변환하면 데이터가 손상되므로이 작업을 수행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6da1ce58d3a6c34c76807dc44593d7cd8c6563b6" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;--text&lt;/code&gt; is supplied patches of binary files without a textconv filter will be ignored.</source>
          <target state="translated">&lt;code&gt;--text&lt;/code&gt; 가 제공 되지 않으면 textconv 필터가없는 이진 파일의 패치는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="54cbf98b314812a07f65f95ae77e8608ddf0b26f" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-f&lt;/code&gt; is given, the &lt;code&gt;replace&lt;/code&gt; reference must not yet exist.</source>
          <target state="translated">&lt;code&gt;-f&lt;/code&gt; 를 지정 하지 않으면 &lt;code&gt;replace&lt;/code&gt; 참조가 아직 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="ec0a9816e3fe8947b4bfff6f5914c3288bed6fc9" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-f&lt;/code&gt; is given, the named tag must not yet exist.</source>
          <target state="translated">&lt;code&gt;-f&lt;/code&gt; 를 지정 하지 않으면 이름 지정된 태그가 아직 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="7824ccb45f3d7be1fd07def25712792fbdf3f009" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;git blame&lt;/code&gt; and &lt;code&gt;git annotate&lt;/code&gt; in older versions of git, the extent of the annotation can be limited to both line ranges and revision ranges. The &lt;code&gt;-L&lt;/code&gt; option, which limits annotation to a range of lines, may be specified multiple times.</source>
          <target state="translated">이전 버전의 git에서 &lt;code&gt;git blame&lt;/code&gt; 및 &lt;code&gt;git annotate&lt;/code&gt; 와 달리 주석 의 범위는 선 범위와 개정 범위로 제한 될 수 있습니다. 주석을 여러 줄로 제한 하는 &lt;code&gt;-L&lt;/code&gt; 옵션은 여러 번 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fa5e3a4c28161d2ef67ee80d5624341cfa56be1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;git diff-files&lt;/code&gt;, which showed the difference between the index file and the working tree, &lt;code&gt;git diff-index&lt;/code&gt; shows the differences between a committed &lt;strong&gt;tree&lt;/strong&gt; and either the index file or the working tree. In other words, &lt;code&gt;git diff-index&lt;/code&gt; wants a tree to be diffed against, and before we did the commit, we couldn&amp;rsquo;t do that, because we didn&amp;rsquo;t have anything to diff against.</source>
          <target state="translated">인덱스 파일과 작업 트리의 차이점을 보여준 &lt;code&gt;git diff-files&lt;/code&gt; 와 달리 git diff- &lt;code&gt;git diff-index&lt;/code&gt; 는 커밋 된 &lt;strong&gt;트리&lt;/strong&gt; 와 인덱스 파일 또는 작업 트리 의 차이점을 보여줍니다 . 다시 말해, &lt;code&gt;git diff-index&lt;/code&gt; 는 트리를 비교 하기를 원하며 커밋을 수행하기 전에 비교할 수있는 항목이 없기 때문에이를 수행 할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="a75073ebd9356a7219cb30b4bb866c17ce8b906c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;gitk&lt;/code&gt;, &lt;code&gt;git gui&lt;/code&gt; focuses on commit generation and single file annotation and does not show project history. It does however supply menu actions to start a &lt;code&gt;gitk&lt;/code&gt; session from within &lt;code&gt;git gui&lt;/code&gt;.</source>
          <target state="translated">달리 &lt;code&gt;gitk&lt;/code&gt; 이 , &lt;code&gt;git gui&lt;/code&gt; 생성 및 단일 파일 주석을 커밋에 초점을 맞추고 프로젝트의 역사를 표시하지 않습니다. 그러나 &lt;code&gt;git gui&lt;/code&gt; 내에서 &lt;code&gt;gitk&lt;/code&gt; 세션 을 시작하기위한 메뉴 조치를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="cd17281830ac5a9aa50c0d768481eabf04240182" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;raw&lt;/code&gt; format above, the time zone/UTC offset information contained in an RFC 2822 date string is used to adjust the date value to UTC prior to storage. Therefore it is important that this information be as accurate as possible.</source>
          <target state="translated">위 의 &lt;code&gt;raw&lt;/code&gt; 형식 과 달리 RFC 2822 날짜 문자열에 포함 된 시간대 / UTC 오프셋 정보는 날짜 값을 저장하기 전에 UTC로 조정하는 데 사용됩니다. 따라서이 정보는 최대한 정확해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9ebe23208a4d3f51d6690b78b04b40646f8e2f1" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;rfc2822&lt;/code&gt; format, this format is very strict. Any variation in formatting will cause fast-import to reject the value, and some sanity checks on the numeric values may also be performed.</source>
          <target state="translated">&lt;code&gt;rfc2822&lt;/code&gt; 형식 과 달리이 형식은 매우 엄격합니다. 형식이 변경되면 빠른 가져 오기가 값을 거부하고 숫자 값에 대한 일부 온 전성 검사도 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="422977ffd462a03a6cbce65db58b07001eb2214f" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;rfc2822&lt;/code&gt; format, this format is very strict. Any variation in formatting will cause fast-import to reject the value.</source>
          <target state="translated">&lt;code&gt;rfc2822&lt;/code&gt; 형식 과 달리이 형식은 매우 엄격합니다. 서식이 다양하면 빠른 가져 오기에서 값을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="a5e8af576412d2facd9f39a0996da0da165c42ee" translate="yes" xml:space="preserve">
          <source>Unlike the Porcelain format, the filename information is always given and terminates the entry:</source>
          <target state="translated">Porcelain 형식과 달리 파일 이름 정보는 항상 제공되며 항목을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="b603b31236d9df1a4442c23c62ea6317f2525837" translate="yes" xml:space="preserve">
          <source>Unlike the longhand form, when Alice fetches from Bob using a remote repository shorthand set up with &lt;code&gt;git remote&lt;/code&gt;, what was fetched is stored in a remote-tracking branch, in this case &lt;code&gt;bob/master&lt;/code&gt;. So after this:</source>
          <target state="translated">Longhand 형식과 달리 Alice가 &lt;code&gt;git remote&lt;/code&gt; 로 설정된 원격 저장소 단축을 사용하여 Bob에서 가져 오면 가져온 항목이 원격 추적 분기 (이 경우 &lt;code&gt;bob/master&lt;/code&gt; )에 저장 됩니다. 그래서이 후 :</target>
        </trans-unit>
        <trans-unit id="cc8e9909209a90f3a790bc3005980e8527de79e5" translate="yes" xml:space="preserve">
          <source>Unlike the traditional &lt;code&gt;unified&lt;/code&gt; diff format, which shows two files A and B with a single column that has &lt;code&gt;-&lt;/code&gt; (minus &amp;mdash; appears in A but removed in B), &lt;code&gt;+&lt;/code&gt; (plus &amp;mdash; missing in A but added to B), or &lt;code&gt;&quot; &quot;&lt;/code&gt; (space &amp;mdash; unchanged) prefix, this format compares two or more files file1, file2,&amp;hellip;​ with one file X, and shows how X differs from each of fileN. One column for each of fileN is prepended to the output line to note how X&amp;rsquo;s line is different from it.</source>
          <target state="translated">기존과는 달리 &lt;code&gt;unified&lt;/code&gt; 이 하나의 컬럼은 diff 형식, 쇼 두 개의 파일 A와 B &lt;code&gt;-&lt;/code&gt; (빼기 - A의 표시되지만 B에서 제거) &lt;code&gt;+&lt;/code&gt; - (플러스에서 누락하지만 B에 추가), 또는 &lt;code&gt;&quot; &quot;&lt;/code&gt; ( 공백 &amp;mdash; 변경되지 않은) 접두사 인이 형식은 둘 이상의 파일 file1, file2,&amp;hellip;를 하나의 파일 X와 비교하고 X가 각 파일 N과 어떻게 다른지 보여줍니다. 각각의 fileN에 대해 하나의 열이 출력 행 앞에 추가되어 X의 행이 어떻게 다른지 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71233552f2a4fc77054593fac1f6899dd0308229" translate="yes" xml:space="preserve">
          <source>Unlike variables like &lt;code&gt;color.ui&lt;/code&gt; and &lt;code&gt;core.editor&lt;/code&gt; the &lt;code&gt;receive.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; and &lt;code&gt;fetch.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; variables will not fall back on the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; configuration if they aren&amp;rsquo;t set. To uniformly configure the same fsck settings in different circumstances all three of them they must all set to the same values.</source>
          <target state="translated">같은 변수와 달리 &lt;code&gt;color.ui&lt;/code&gt; 및 &lt;code&gt;core.editor&lt;/code&gt; &lt;code&gt;receive.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 와 &lt;code&gt;fetch.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 변수는 다시 떨어지지 않을 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 구성 그들은하지 않은 경우 세트. 서로 다른 환경에서 동일한 fsck 설정을 균일하게 구성하려면 세 가지 설정을 모두 동일한 값으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="00ee5ed7b48c819f6f323dbe1b9a72aef5a0c864" translate="yes" xml:space="preserve">
          <source>Unlike variables like &lt;code&gt;color.ui&lt;/code&gt; and &lt;code&gt;core.editor&lt;/code&gt; the &lt;code&gt;receive.fsck.skipList&lt;/code&gt; and &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; variables will not fall back on the &lt;code&gt;fsck.skipList&lt;/code&gt; configuration if they aren&amp;rsquo;t set. To uniformly configure the same fsck settings in different circumstances all three of them they must all set to the same values.</source>
          <target state="translated">같은 변수와 달리 &lt;code&gt;color.ui&lt;/code&gt; 및 &lt;code&gt;core.editor&lt;/code&gt; &lt;code&gt;receive.fsck.skipList&lt;/code&gt; 및 &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; 변수는 다시 떨어지지 않을 &lt;code&gt;fsck.skipList&lt;/code&gt; 의 사람들이 설정되지 않은 경우 구성. 서로 다른 환경에서 동일한 fsck 설정을 균일하게 구성하려면 세 가지 설정을 모두 동일한 값으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8a3dffb4c65d7a1f27e907ef2a919885d1125ac9" translate="yes" xml:space="preserve">
          <source>Unlike when pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, any updates outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; will be accepted without &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;), whether that&amp;rsquo;s swapping e.g. a tree object for a blob, or a commit for another commit that&amp;rsquo;s doesn&amp;rsquo;t have the previous commit as an ancestor etc.</source>
          <target state="translated">&lt;a href=&quot;git-push&quot;&gt;git-push [1]으로 푸시&lt;/a&gt; 할 때와 달리 &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 외부의 업데이트 는 refspec (또는 &lt;code&gt;--force&lt;/code&gt; ) 에서 &lt;code&gt;+&lt;/code&gt; 없이 허용됩니다 . 또는 이전 커밋이 조상으로 포함되지 않은 다른 커밋에 대한 커밋</target>
        </trans-unit>
        <trans-unit id="2f2516ccb262ba2dda1eeb5218e911868837ce78" translate="yes" xml:space="preserve">
          <source>Unlike when pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, there is no configuration which&amp;rsquo;ll amend these rules, and nothing like a &lt;code&gt;pre-fetch&lt;/code&gt; hook analogous to the &lt;code&gt;pre-receive&lt;/code&gt; hook.</source>
          <target state="translated">&lt;a href=&quot;git-push&quot;&gt;git-push [1]로 푸시&lt;/a&gt; 할 때와 달리 , 이러한 규칙을 수정하는 구성은 없으며, &lt;code&gt;pre-receive&lt;/code&gt; 후크와 유사한 &lt;code&gt;pre-fetch&lt;/code&gt; 후크 와 같은 것은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fb79f423670171900d7e94880e8d45907e9f995c" translate="yes" xml:space="preserve">
          <source>Unlock a working tree, allowing it to be pruned, moved or deleted.</source>
          <target state="translated">가지 치기, 이동 또는 삭제를 위해 작업중인 트리를 잠금 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="b00eee8b49227caba98e5d68033660ff6076ebcc" translate="yes" xml:space="preserve">
          <source>Unmerged entries have the following format; the first character is a &quot;u&quot; to distinguish from ordinary changed entries.</source>
          <target state="translated">병합되지 않은 항목의 형식은 다음과 같습니다. 첫 번째 문자는 일반적인 변경 항목과 구별하기위한 &quot;u&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="2c99cc569343579b221cd64026ecc62bb1c21d7b" translate="yes" xml:space="preserve">
          <source>Unpack objects from a packed archive</source>
          <target state="translated">압축 아카이브에서 객체 압축 풀기</target>
        </trans-unit>
        <trans-unit id="42e2a268d032a6abb00d4cbd80feaa1ecd7a75d6" translate="yes" xml:space="preserve">
          <source>Unreachable tags, commits, and trees will also be accessed to find the tips of dangling segments of history. Use &lt;code&gt;--no-dangling&lt;/code&gt; if you don&amp;rsquo;t care about this output and want to speed it up further.</source>
          <target state="translated">도달 할 수없는 태그, 커밋 및 트리도 액세스하여 기록 세그먼트에 매달려있는 팁을 찾습니다. 이 출력에 신경 쓰지 않고 속도를 높이려면 &lt;code&gt;--no-dangling&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8a4efd1d470fc3c5ede97084c82a35b9804122a" translate="yes" xml:space="preserve">
          <source>Unregister the given submodules, i.e. remove the whole &lt;code&gt;submodule.$name&lt;/code&gt; section from .git/config together with their work tree. Further calls to &lt;code&gt;git submodule update&lt;/code&gt;, &lt;code&gt;git submodule foreach&lt;/code&gt; and &lt;code&gt;git submodule sync&lt;/code&gt; will skip any unregistered submodules until they are initialized again, so use this command if you don&amp;rsquo;t want to have a local checkout of the submodule in your working tree anymore.</source>
          <target state="translated">주어진 서브 모듈의 등록을 해제하십시오 &lt;code&gt;submodule.$name&lt;/code&gt; 즉, 작업 트리와 함께 .git / config에서 전체 서브 모듈. $ name 섹션을 제거하십시오 . &lt;code&gt;git submodule update&lt;/code&gt; , &lt;code&gt;git submodule foreach&lt;/code&gt; 및 &lt;code&gt;git submodule sync&lt;/code&gt; 에 대한 추가 호출 은 다시 초기화 될 때까지 등록되지 않은 서브 모듈을 건너 뛰므로 더 이상 작업 트리에서 서브 모듈의 로컬 체크 아웃을 원하지 않으면이 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1431f68f359f8699975be39dca08302c67d68d9e" translate="yes" xml:space="preserve">
          <source>Unset</source>
          <target state="translated">Unset</target>
        </trans-unit>
        <trans-unit id="8ff954e80b42b18d3d0fcda602d94db1e46da2d4" translate="yes" xml:space="preserve">
          <source>Unsetting the &lt;code&gt;text&lt;/code&gt; attribute on a path tells Git not to attempt any end-of-line conversion upon checkin or checkout.</source>
          <target state="translated">경로 에서 &lt;code&gt;text&lt;/code&gt; 속성을 설정 해제하면 체크인 또는 체크 아웃시 줄 끝 변환을 시도하지 않도록 Git에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="7f84947907454dd0cb412d2a8e5d5e3b9c2382f0" translate="yes" xml:space="preserve">
          <source>Unsetting the variable, or setting it to empty, &quot;0&quot; or &quot;false&quot; (case insensitive) disables trace messages.</source>
          <target state="translated">변수를 설정 해제하거나 비어있는 &quot;0&quot;또는 &quot;false&quot;(대소 문자 구분)로 설정하면 추적 메시지가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c176eff9c64fa28a4b6af1aa296cc1394bbf7a80" translate="yes" xml:space="preserve">
          <source>Unshelve</source>
          <target state="translated">Unshelve</target>
        </trans-unit>
        <trans-unit id="9fde2b36ff30053ad23e6a695929873244cc0367" translate="yes" xml:space="preserve">
          <source>Unshelve options</source>
          <target state="translated">옵션 해제</target>
        </trans-unit>
        <trans-unit id="004e593b6690fb3d48f4f5a86eac1cd13b5b2234" translate="yes" xml:space="preserve">
          <source>Unshelving will take a shelved P4 changelist, and produce the equivalent git commit in the branch refs/remotes/p4-unshelved/&amp;lt;changelist&amp;gt;.</source>
          <target state="translated">Unshelving은 쉘프 P4 변경 목록을 가져와 분기 refs / remotes / p4-unshelved / &amp;lt;changelist&amp;gt;에서 동등한 git commit을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a6e7eb706e115cdaf88206be37eb67b232d007bc" translate="yes" xml:space="preserve">
          <source>Unspecified</source>
          <target state="translated">Unspecified</target>
        </trans-unit>
        <trans-unit id="78f88266b367e8b6e086054e91f1ebc89e168d16" translate="yes" xml:space="preserve">
          <source>Until Git version 2.20, and unlike when pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, any updates to &lt;code&gt;refs/tags/*&lt;/code&gt; would be accepted without &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;). When fetching, we promiscuously considered all tag updates from a remote to be forced fetches. Since Git version 2.20, fetching to update &lt;code&gt;refs/tags/*&lt;/code&gt; works the same way as when pushing. I.e. any updates will be rejected without &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;).</source>
          <target state="translated">Git 버전 2.20까지, &lt;a href=&quot;git-push&quot;&gt;git-push [1]로 푸시&lt;/a&gt; 할 때와 달리 &lt;code&gt;refs/tags/*&lt;/code&gt; 에 대한 모든 업데이트 는 refspec (또는 &lt;code&gt;--force&lt;/code&gt; ) 에서 &lt;code&gt;+&lt;/code&gt; 없이 허용됩니다 . 페치 할 때, 원격에서 모든 태그 업데이트를 강제 페치로 간주했습니다. Git 버전 2.20부터 &lt;code&gt;refs/tags/*&lt;/code&gt; 를 업데이트하기 위해 가져 오는 것은 푸시 할 때와 같은 방식으로 작동합니다. 즉 , refspec (또는 &lt;code&gt;--force&lt;/code&gt; ) 에서 &lt;code&gt;+&lt;/code&gt; 없이 업데이트가 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="9514c500d61430538679eec9081979b274172cf9" translate="yes" xml:space="preserve">
          <source>Untracked cache</source>
          <target state="translated">추적되지 않은 캐시</target>
        </trans-unit>
        <trans-unit id="614ce4ff1bf92552970ab54ff766006d0da693f9" translate="yes" xml:space="preserve">
          <source>Untracked items have the following format:</source>
          <target state="translated">추적되지 않은 항목의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1eade895e693b4111455eda06a87af1097cf4d6c" translate="yes" xml:space="preserve">
          <source>Untyped &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt;, e.g. the contents of a file.</source>
          <target state="translated">형식화되지 않은 &lt;a href=&quot;#def_object&quot;&gt;객체&lt;/a&gt; (예 : 파일의 내용)</target>
        </trans-unit>
        <trans-unit id="7b839a219907b09268c047c522a03961e96bd78b" translate="yes" xml:space="preserve">
          <source>Unused configuration variable. Used in Git versions 2.20 and 2.21 as an escape hatch to enable the legacy shellscript implementation of rebase. Now the built-in rewrite of it in C is always used. Setting this will emit a warning, to alert any remaining users that setting this now does nothing.</source>
          <target state="translated">사용하지 않은 구성 변수. Git 버전 2.20 및 2.21에서 이스케이프 해치로 사용되어 레거시 셸 스크립트 rebase 구현을 가능하게합니다. 이제 C에서 내장 재 작성이 항상 사용됩니다. 이를 설정하면 나머지 사용자에게 지금 설정해도 아무 것도 수행하지 않는다는 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="315fc3f07f41b1c3600ceb87f6a9f32b85f1da70" translate="yes" xml:space="preserve">
          <source>Unused configuration variable. Used in Git versions 2.22 to 2.26 as an escape hatch to enable the legacy shellscript implementation of stash. Now the built-in rewrite of it in C is always used. Setting this will emit a warning, to alert any remaining users that setting this now does nothing.</source>
          <target state="translated">사용되지 않는 구성 변수입니다. Git 버전 2.22 ~ 2.26에서 이스케이프 해치로 사용되어 기존 쉘 스크립트의 숨김 구현을 활성화합니다. 이제 C로 내장 된 재 작성이 항상 사용됩니다. 이를 설정하면 경고가 발생하여 나머지 사용자에게이 설정은 아무 효과가 없음을 알립니다.</target>
        </trans-unit>
        <trans-unit id="ca31b4c795dcb03444e6d0c037dbcd47081c70a9" translate="yes" xml:space="preserve">
          <source>Update affected files from CVS repository before attempting export.</source>
          <target state="translated">내보내기를 시도하기 전에 CVS 저장소에서 영향을받는 파일을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="82e59b151c004802a1fa23ba3e75a68d14df0e2a" translate="yes" xml:space="preserve">
          <source>Update an existing shelved changelist with this commit. Implies --shelve. Repeat for multiple shelved changelists.</source>
          <target state="translated">이 커밋으로 기존 선반 변경 목록을 업데이트하십시오. --shelve를 의미합니다. 여러 개의 보류 된 변경 목록에 대해 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="5433caf2e572561b5bb38ff5e69b0263d08b90aa" translate="yes" xml:space="preserve">
          <source>Update and examine branches from the repository you cloned from:</source>
          <target state="translated">복제 한 저장소에서 분기를 업데이트하고 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="381f15e94e347f076ef71f417ee29b782a6dcc4d" translate="yes" xml:space="preserve">
          <source>Update auxiliary info file to help dumb servers</source>
          <target state="translated">바보 서버를 돕기 위해 보조 정보 파일 업데이트</target>
        </trans-unit>
        <trans-unit id="d94aecddb1a2d3c03afb4a7cf4e1bb3a0123c2c6" translate="yes" xml:space="preserve">
          <source>Update hook</source>
          <target state="translated">후크 업데이트</target>
        </trans-unit>
        <trans-unit id="e5f960e3f28d7d7ea59f8750682a356ae18535be" translate="yes" xml:space="preserve">
          <source>Update remote refs along with associated objects</source>
          <target state="translated">관련 객체와 함께 원격 참조 업데이트</target>
        </trans-unit>
        <trans-unit id="ee3315ea0cbb49ab6105a89db0964480184c3ce9" translate="yes" xml:space="preserve">
          <source>Update the Git repository with recent changes from p4, rebasing your work on top:</source>
          <target state="translated">p4의 최근 변경 사항으로 Git 리포지토리를 업데이트하고 작업 내용을 다시 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="5937294218e2d7b95b7b77414b52c326239ca8d5" translate="yes" xml:space="preserve">
          <source>Update the index by adding new files that are unknown to the index and files modified in the working tree, but ignore files that have been removed from the working tree. This option is a no-op when no &amp;lt;pathspec&amp;gt; is used.</source>
          <target state="translated">색인에 알려지지 않은 새 파일과 작업 트리에서 수정 된 파일을 추가하여 색인을 업데이트하지만 작업 트리에서 제거 된 파일은 무시하십시오. &amp;lt;pathspec&amp;gt;이 사용되지 않으면이 옵션은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94df66721f1bfd4990972c3f5f4a0d6b61f59f9e" translate="yes" xml:space="preserve">
          <source>Update the index just where it already has an entry matching &amp;lt;pathspec&amp;gt;. This removes as well as modifies index entries to match the working tree, but adds no new files.</source>
          <target state="translated">&amp;lt;pathspec&amp;gt;과 일치하는 항목이 이미있는 색인을 업데이트하십시오. 이렇게하면 작업 트리와 일치하도록 색인 항목이 제거 될뿐만 아니라 수정되지만 새 파일은 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03d173e098621e3730258998672da85e88b347b1" translate="yes" xml:space="preserve">
          <source>Update the index not only where the working tree has a file matching &amp;lt;pathspec&amp;gt; but also where the index already has an entry. This adds, modifies, and removes index entries to match the working tree.</source>
          <target state="translated">작업 트리에 &amp;lt;pathspec&amp;gt;과 일치하는 파일이있는 색인뿐만 아니라 색인에 이미 항목이있는 색인도 업데이트하십시오. 작업 트리와 일치하도록 인덱스 항목을 추가, 수정 및 제거합니다.</target>
        </trans-unit>
        <trans-unit id="1a6e291eaaa3e731de98429f7fb37fdac90f0a22" translate="yes" xml:space="preserve">
          <source>Update the object name stored in a ref safely</source>
          <target state="translated">참조에 저장된 객체 이름을 안전하게 업데이트</target>
        </trans-unit>
        <trans-unit id="00f0c8a1eac4ed2966a7d563ef87a6387d365dcf" translate="yes" xml:space="preserve">
          <source>Update the origin repository&amp;rsquo;s master branch with the dev branch, allowing non-fast-forward updates. &lt;strong&gt;This can leave unreferenced commits dangling in the origin repository.&lt;/strong&gt; Consider the following situation, where a fast-forward is not possible:</source>
          <target state="translated">원본 저장소의 마스터 분기를 dev 분기로 업데이트하여 빨리 감기가 아닌 업데이트를 허용합니다. &lt;strong&gt;이렇게하면 참조 리포지토리가 오리진 저장소에 매달려 있습니다. &lt;/strong&gt;빨리 감기가 불가능한 다음 상황을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b73d3968359117cfd051c2e81a709d1d9e1579b7" translate="yes" xml:space="preserve">
          <source>Update the reference to the value of the top reflog entry (i.e. &amp;lt;ref&amp;gt;@{0}) if the previous top entry was pruned. (This option is ignored for symbolic references.)</source>
          <target state="translated">이전 맨 위 항목이 제거 된 경우 맨 위 참조 항목 (예 : &amp;lt;ref&amp;gt; @ {0})의 값에 대한 참조를 업데이트하십시오. (이 옵션은 기호 참조의 경우 무시됩니다.)</target>
        </trans-unit>
        <trans-unit id="d7c08d3ae4fbcbbf6a3dc89cdba309659a4395bc" translate="yes" xml:space="preserve">
          <source>Update the reflog for &amp;lt;name&amp;gt; with &amp;lt;reason&amp;gt;. This is valid only when creating or updating a symbolic ref.</source>
          <target state="translated">&amp;lt;이름&amp;gt;에 대한 reflog를 &amp;lt;이유&amp;gt;로 업데이트하십시오. 이것은 기호 참조를 작성하거나 업데이트 할 때만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="d053e75e709458eca9f01e5c8910658ea18a25cf" translate="yes" xml:space="preserve">
          <source>Update the registered submodules to match what the superproject expects by cloning missing submodules, fetching missing commits in submodules and updating the working tree of the submodules. The &quot;updating&quot; can be done in several ways depending on command line options and the value of &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; configuration variable. The command line option takes precedence over the configuration variable. If neither is given, a &lt;code&gt;checkout&lt;/code&gt; is performed. The &lt;code&gt;update&lt;/code&gt; procedures supported both from the command line as well as through the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; configuration are:</source>
          <target state="translated">누락 된 서브 모듈을 복제하고, 서브 모듈에서 누락 된 커밋을 가져오고, 서브 모듈의 작업 트리를 업데이트하여 수퍼 프로젝트가 기대하는 것과 일치하도록 등록 된 서브 모듈을 업데이트하십시오. &quot;업데이트&quot;는 명령 행 옵션 및 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 구성 변수 의 값에 따라 여러 가지 방법으로 수행 할 수 있습니다 . 명령 행 옵션이 구성 변수보다 우선합니다. 둘 다 주어지지 않으면 &lt;code&gt;checkout&lt;/code&gt; 이 수행됩니다. &lt;code&gt;update&lt;/code&gt; 절차는 명령 줄에서뿐만 아니라 통해 모두 지원 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 구성은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="9a189cb9ecf6f808972788504f5218556d75488e" translate="yes" xml:space="preserve">
          <source>Update the remote-tracking branches for the repository you cloned from, then merge one of them into your current branch:</source>
          <target state="translated">복제 한 저장소의 원격 추적 분기를 업데이트 한 후 그 중 하나를 현재 분기로 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="b4a6a66956cae4a12a849cae6094fa1d9187d293" translate="yes" xml:space="preserve">
          <source>Update the remote-tracking branches:</source>
          <target state="translated">원격 추적 분기를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="6d5daf3e771e4022d14d6727e49c69b93e7e63af" translate="yes" xml:space="preserve">
          <source>Update the sparse-checkout file to include additional patterns. By default, these patterns are read from the command-line arguments, but they can be read from stdin using the &lt;code&gt;--stdin&lt;/code&gt; option. When &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; is enabled, the given patterns are interpreted as directory names as in the &lt;code&gt;set&lt;/code&gt; subcommand.</source>
          <target state="translated">추가 패턴을 포함하도록 스파 스 체크 아웃 파일을 업데이트하십시오. 기본적으로 이러한 패턴은 명령 줄 인수에서 읽지 만 &lt;code&gt;--stdin&lt;/code&gt; 을 사용하여 stdin에서 읽을 수 있습니다. 옵션을 . 때 &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; 가 활성화되어, 주어진 패턴은 같이 디렉토리 이름으로 해석됩니다 &lt;code&gt;set&lt;/code&gt; 하위 명령.</target>
        </trans-unit>
        <trans-unit id="f68dff1cbdca38d9a97763a1d9fd849e951b6a1b" translate="yes" xml:space="preserve">
          <source>Updates files in the working tree to match the version in the index or the specified tree. If no pathspec was given, &lt;code&gt;git checkout&lt;/code&gt; will also update &lt;code&gt;HEAD&lt;/code&gt; to set the specified branch as the current branch.</source>
          <target state="translated">작업 트리의 파일을 색인 또는 지정된 트리의 버전과 일치하도록 업데이트합니다. pathspec을 지정하지 않으면 &lt;code&gt;git checkout&lt;/code&gt; 은 &lt;code&gt;HEAD&lt;/code&gt; 를 업데이트 하여 지정된 분기를 현재 분기로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="091bf3e8c6fb28b8688a9117ac018615896df561" translate="yes" xml:space="preserve">
          <source>Updates remote refs using local refs, while sending objects necessary to complete the given refs.</source>
          <target state="translated">주어진 심판을 완료하는 데 필요한 객체를 보내는 동안 로컬 심판을 사용하여 원격 심판을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="91ca9b60db53a2ebedea4c579e08371ec4025869" translate="yes" xml:space="preserve">
          <source>Updating A with the resulting merge commit will fast-forward and your push will be accepted.</source>
          <target state="translated">병합 커밋 결과로 A를 업데이트하면 빨리 진행되고 푸시가 수락됩니다.</target>
        </trans-unit>
        <trans-unit id="b1b31935884de26d68d690781ac1ec814b3bc924" translate="yes" xml:space="preserve">
          <source>Updating a repository with git fetch</source>
          <target state="translated">git fetch로 리포지토리 업데이트</target>
        </trans-unit>
        <trans-unit id="c2ed1ab77aee7c3aaed70bc448641d662955a12f" translate="yes" xml:space="preserve">
          <source>Updating existing tests that assume GIT_TRACE format messages.</source>
          <target state="translated">GIT_TRACE 형식 메시지를 가정하는 기존 테스트를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="c5ded60beb1b0eb17cab63a8e09a8acd2261286e" translate="yes" xml:space="preserve">
          <source>Updating the index did something else too: it created a &lt;code&gt;.git/index&lt;/code&gt; file. This is the index that describes your current working tree, and something you should be very aware of. Again, you normally never worry about the index file itself, but you should be aware of the fact that you have not actually really &quot;checked in&quot; your files into Git so far, you&amp;rsquo;ve only &lt;strong&gt;told&lt;/strong&gt; Git about them.</source>
          <target state="translated">인덱스를 업데이트하면 다른 일이 발생했습니다. &lt;code&gt;.git/index&lt;/code&gt; 파일을 만들었습니다 . 이것은 현재 작업 트리를 설명하는 색인이며 매우 알고 있어야합니다. 다시 말하지만, 당신은 일반적으로 인덱스 파일 자체에 대해 걱정하지 않습니다,하지만 당신은 당신이 실제로 정말 힘내에 파일 지금까지, 당신은 단지 한 &quot;체크&quot;는 사실을 알고 있어야 &lt;strong&gt;했다&lt;/strong&gt; 그들에 대해 힘내.</target>
        </trans-unit>
        <trans-unit id="583381e5edf6e3ab467919c38286667f0916979d" translate="yes" xml:space="preserve">
          <source>Upon completion, &amp;lt;branch&amp;gt; will be the current branch.</source>
          <target state="translated">완료되면 &amp;lt;branch&amp;gt;가 현재 분기가됩니다.</target>
        </trans-unit>
        <trans-unit id="c956664b8da61af6d0e1bf33a6e1ff75cbe45ad1" translate="yes" xml:space="preserve">
          <source>Upon seeing an invalid object name in the input, pretend as if the bad input was not given.</source>
          <target state="translated">입력에서 유효하지 않은 오브젝트 이름을 볼 때 잘못된 입력이 제공되지 않은 것처럼 가장하십시오.</target>
        </trans-unit>
        <trans-unit id="d725441fc805b8226e9417fb2c8cf53ac8d791d5" translate="yes" xml:space="preserve">
          <source>Upstream branch to compare against. May be any valid commit, not just an existing branch name. Defaults to the configured upstream for the current branch.</source>
          <target state="translated">비교할 업스트림 브랜치 기존 브랜치 이름뿐만 아니라 유효한 커밋 일 수도 있습니다. 현재 분기에 대해 구성된 업스트림이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="f5808323e4ba717fc383cb75e63b6cf3a4e857e7" translate="yes" xml:space="preserve">
          <source>Upstream branch to search for equivalent commits. Defaults to the upstream branch of HEAD.</source>
          <target state="translated">동등한 커밋을 검색하는 업스트림 브랜치 HEAD의 업스트림 분기로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="309bc26d3c4c2649258f95c7069216bb2a7ac5f4" translate="yes" xml:space="preserve">
          <source>Upstream location from which commits are identified to submit to p4. By default, this is the most recent p4 commit reachable from &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">p4에 제출할 확약이 식별되는 업스트림 위치. 기본적으로 이것은 &lt;code&gt;HEAD&lt;/code&gt; 에서 도달 할 수있는 가장 최근의 p4 커밋 입니다.</target>
        </trans-unit>
        <trans-unit id="df28f1403e8348eae4829434034d1a95e5fe659d" translate="yes" xml:space="preserve">
          <source>Url translation</source>
          <target state="translated">URL 번역</target>
        </trans-unit>
        <trans-unit id="7ae770d8c2db91584c78e413662ced65719f53ca" translate="yes" xml:space="preserve">
          <source>Usage of this flag will probably be rare, since you can get rid of commits that start empty by just firing up an interactive rebase and removing the lines corresponding to the commits you don&amp;rsquo;t want. This flag exists as a convenient shortcut, such as for cases where external tools generate many empty commits and you want them all removed.</source>
          <target state="translated">이 플래그를 사용하는 경우는 드뭅니다. 대화 형 리베이스를 실행하고 원하지 않는 커밋에 해당하는 줄을 제거하여 비어있는 커밋을 제거 할 수 있기 때문입니다. 이 플래그는 외부 도구가 많은 빈 커밋을 생성하고 모두 제거하려는 경우와 같이 편리한 바로 가기로 존재합니다.</target>
        </trans-unit>
        <trans-unit id="f51159e5f3b0adbeed98e188d040286280a5320b" translate="yes" xml:space="preserve">
          <source>Usage text</source>
          <target state="translated">사용법 텍스트</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="6039144c2dc6586b6f3f0cb7423bcc0b3de0d0c1" translate="yes" xml:space="preserve">
          <source>Use &quot;patience diff&quot; algorithm when generating patches.</source>
          <target state="translated">패치를 생성 할 때 &quot;환자 차이&quot;알고리즘을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1712fa1f1e6f89a27b7d3117ed39073a3258971d" translate="yes" xml:space="preserve">
          <source>Use &amp;lt;dir&amp;gt; to store the resulting files, instead of the current working directory.</source>
          <target state="translated">현재 작업 디렉토리 대신 &amp;lt;dir&amp;gt;을 사용하여 결과 파일을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="89ed1ad2d65d4e1af42e685a9ee22c739e5d2c9b" translate="yes" xml:space="preserve">
          <source>Use &amp;lt;message&amp;gt; instead of the branch names for the first line of the log message. For use with &lt;code&gt;--log&lt;/code&gt;.</source>
          <target state="translated">로그 메시지의 첫 번째 줄에 분기 이름 대신 &amp;lt;message&amp;gt;를 사용하십시오. &lt;code&gt;--log&lt;/code&gt; 와 함께 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8e6c324c4e7440184ef28eb2f6fc1fca5a4a325" translate="yes" xml:space="preserve">
          <source>Use &amp;lt;regex&amp;gt; to decide what a word is, instead of considering runs of non-whitespace to be a word. Also implies &lt;code&gt;--word-diff&lt;/code&gt; unless it was already enabled.</source>
          <target state="translated">공백이 아닌 단어를 단어로 간주하는 대신 &amp;lt;regex&amp;gt;를 사용하여 단어가 무엇인지 결정하십시오. 또한 이미 활성화되어 있지 않은 경우 &lt;code&gt;--word-diff&lt;/code&gt; 를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="f70b8a97f949594b729b07efce2ca59a63023925" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;!&lt;/code&gt; to not make the corresponding negated long option available.</source>
          <target state="translated">사용 &lt;code&gt;!&lt;/code&gt; 해당 부정 긴 옵션을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f7924a219e6794d45a36b15b2c44738227b795ff" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; to set the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; explicitly. e.g., &quot;git remote set-head origin master&quot; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/master&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="translated">사용 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 기호-REF 설정 &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 명시 적으로. 예를 들어, &quot;git remote set-head origin master&quot;는 symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; 를 &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; 로 설정 합니다. &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; 이미 존재하는 경우에만 작동 합니다. 그렇지 않은 경우 먼저 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="e726751622c7eadb004a31b60b5fa1e9cc1fbf90" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; to set the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; explicitly. e.g., &lt;code&gt;git
remote set-head origin master&lt;/code&gt; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/master&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="translated">사용 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 기호-REF 설정 &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 명시 적으로. 예를 들어, &lt;code&gt;git remote set-head origin master&lt;/code&gt; 는 symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; 를 &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; 로 설정합니다. 합니다. 이것은 &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; 가 이미 존재하는 경우에만 작동 합니다. 그렇지 않은 경우 먼저 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="d950943422ee3b93275d1e4b1e510463e5b432e0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; to contact a running cache daemon (or start a new cache daemon if one is not started). Defaults to &lt;code&gt;$XDG_CACHE_HOME/git/credential/socket&lt;/code&gt; unless &lt;code&gt;~/.git-credential-cache/&lt;/code&gt; exists in which case &lt;code&gt;~/.git-credential-cache/socket&lt;/code&gt; is used instead. If your home directory is on a network-mounted filesystem, you may need to change this to a local filesystem. You must specify an absolute path.</source>
          <target state="translated">&lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 를 사용 하여 실행중인 캐시 디먼에 접속하십시오 (또는 시작되지 않은 경우 새 캐시 디먼을 시작하십시오). &lt;code&gt;~/.git-credential-cache/&lt;/code&gt; 가 없으면 &lt;code&gt;~/.git-credential-cache/socket&lt;/code&gt; 이 대신 사용 되지 않는 한 기본값은 &lt;code&gt;$XDG_CACHE_HOME/git/credential/socket&lt;/code&gt; 입니다. 홈 디렉토리가 네트워크 마운트 파일 시스템에있는 경우이를 로컬 파일 시스템으로 변경해야합니다. 절대 경로를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="faabe60607ec900b5e4ad4f074b4870d8f9c10c6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; to lookup and store credentials. The file will have its filesystem permissions set to prevent other users on the system from reading it, but will not be encrypted or otherwise protected. If not specified, credentials will be searched for from &lt;code&gt;~/.git-credentials&lt;/code&gt; and &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt;, and credentials will be written to &lt;code&gt;~/.git-credentials&lt;/code&gt; if it exists, or &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt; if it exists and the former does not. See also &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt;.</source>
          <target state="translated">자격 증명을 조회하고 저장 하려면 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 를 사용하십시오 . 파일의 파일 시스템 권한은 시스템의 다른 사용자가 읽을 수 없도록 설정되어 있지만 암호화되거나 보호되지는 않습니다. 지정하지 않으면 &lt;code&gt;~/.git-credentials&lt;/code&gt; 및 &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt; 에서 신임 정보가 검색되고 &lt;code&gt;~/.git-credentials&lt;/code&gt; ( 존재하는 경우) 또는 &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt; 존재하는 경우)에 신임 정보 가 기록됩니다. 전자는 그렇지 않습니다. &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aadb92eae500ef695bbe6a445720ce25246dd04e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;*&lt;/code&gt; to mean that this option should not be listed in the usage generated for the &lt;code&gt;-h&lt;/code&gt; argument. It&amp;rsquo;s shown for &lt;code&gt;--help-all&lt;/code&gt; as documented in &lt;a href=&quot;gitcli&quot;&gt;gitcli[7]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 를 사용 하여이 옵션이 &lt;code&gt;-h&lt;/code&gt; 인수에 대해 생성 된 사용법에 나열되어서는 안됨을 의미합니다 . &lt;a href=&quot;gitcli&quot;&gt;gitcli [7]에&lt;/a&gt; 설명 된대로 &lt;code&gt;--help-all&lt;/code&gt; 에 대해 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="3bbcee2a044e9c08185b38acb1e1c57ceea88054" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;--no-guess&lt;/code&gt; to disable this.</source>
          <target state="translated">이를 비활성화 하려면 &lt;code&gt;--no-guess&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6deefc2a8fa6667ca14a90dee15faf81b1f0546a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;-o master&lt;/code&gt; for continuing an import that was initially done by the old cvs2git tool.</source>
          <target state="translated">이전 cvs2git 도구에서 처음 수행 한 가져 오기를 계속 하려면 &lt;code&gt;-o master&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a4527eec708654a210ce88433047c8e573fb91f2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;-r&lt;/code&gt; together with &lt;code&gt;-d&lt;/code&gt; to delete remote-tracking branches. Note, that it only makes sense to delete remote-tracking branches if they no longer exist in the remote repository or if &lt;code&gt;git fetch&lt;/code&gt; was configured not to fetch them again. See also the &lt;code&gt;prune&lt;/code&gt; subcommand of &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt; for a way to clean up all obsolete remote-tracking branches.</source>
          <target state="translated">원격 추적 분기를 삭제 하려면 &lt;code&gt;-r&lt;/code&gt; 을 &lt;code&gt;-d&lt;/code&gt; 와 함께 사용하십시오 . 원격 추적 분기가 더 이상 원격 저장소에 존재하지 않거나 &lt;code&gt;git fetch&lt;/code&gt; 가 다시 가져 오지 않도록 구성된 경우에만 원격 추적 분기를 삭제하는 것이 좋습니다 . 더 이상 사용되지 않는 모든 원격 추적 분기를 정리하는 방법 은 &lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; 의 &lt;code&gt;prune&lt;/code&gt; 하위 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb7d25cab29167524de808a8da669505756898ee" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;=&lt;/code&gt; if the option takes an argument.</source>
          <target state="translated">옵션에 인수가 있으면 &lt;code&gt;=&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d247642d4c8609f74c2030daa3d24c7c82d2e46d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;?&lt;/code&gt; to mean that the option takes an optional argument. You probably want to use the &lt;code&gt;--stuck-long&lt;/code&gt; mode to be able to unambiguously parse the optional argument.</source>
          <target state="translated">사용 &lt;code&gt;?&lt;/code&gt; 옵션이 옵션 인수를 취한다는 것을 의미합니다. &lt;code&gt;--stuck-long&lt;/code&gt; 모드 를 사용 하여 선택적 인수를 명확하게 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7929eb6fd77d1ea35c9c481fc89518eafcc1cd45" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git bisect&lt;/code&gt; to get a short usage description, and &lt;code&gt;git bisect
help&lt;/code&gt; or &lt;code&gt;git bisect -h&lt;/code&gt; to get a long usage description.</source>
          <target state="translated">&lt;code&gt;git bisect&lt;/code&gt; 를 사용 하여 짧은 사용법 설명을 얻고 &lt;code&gt;git bisect help&lt;/code&gt; 또는 &lt;code&gt;git bisect -h&lt;/code&gt; 를 사용하여 긴 사용법 설명을 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="599c65a25784af23c9351ba6f4874c534a65a263" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git cherry origin&lt;/code&gt; to see which ones of your patches were accepted, and/or use &lt;code&gt;git rebase origin&lt;/code&gt; to port your unmerged changes forward to the updated upstream.</source>
          <target state="translated">&lt;code&gt;git cherry origin&lt;/code&gt; 을 사용 하여 어떤 패치가 수락되었는지 확인하거나 &lt;code&gt;git rebase origin&lt;/code&gt; 을 사용 하여 병합되지 않은 변경 사항을 업데이트 된 업스트림으로 포팅하십시오.</target>
        </trans-unit>
        <trans-unit id="f1986201248cbf297f2fb86d6f520b30d057ce7d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; or &lt;code&gt;git remote update&lt;/code&gt; to stay up to date.</source>
          <target state="translated">사용은 &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; 이나 &lt;code&gt;git remote update&lt;/code&gt; 최신 상태로 유지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="252ef42d37b56d31d5e5dc2525ae974052dfca91" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git format-patch origin&lt;/code&gt; to prepare patches for e-mail submission to your upstream and send it out. Go back to step 2. and continue.</source>
          <target state="translated">&lt;code&gt;git format-patch origin&lt;/code&gt; 을 사용 하여 전자 메일을 업스트림에 제출할 패치를 준비한 후 발송하십시오. 2 단계로 돌아가서 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="cd30f3ed950161de3f8267d9a18953af3c02784f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git mergetool&lt;/code&gt; to run one of several merge utilities to resolve merge conflicts. It is typically run after &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git mergetool&lt;/code&gt; 을 사용 하여 여러 병합 유틸리티 중 하나를 실행하여 병합 충돌을 해결하십시오. 일반적으로 &lt;code&gt;git merge&lt;/code&gt; 후에 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="6b298c06fc405635f29d06efdf0f42592d8075f2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git rev-parse&lt;/code&gt; in option parsing mode (see PARSEOPT section below).</source>
          <target state="translated">옵션 구문 분석 모드에서 &lt;code&gt;git rev-parse&lt;/code&gt; 를 사용 하십시오 (아래 PARSEOPT 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="7c9820d48befbd19730095f238fb8a15824823ad" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git rev-parse&lt;/code&gt; in shell quoting mode (see SQ-QUOTE section below). In contrast to the &lt;code&gt;--sq&lt;/code&gt; option below, this mode does only quoting. Nothing else is done to command input.</source>
          <target state="translated">쉘 인용 모드에서 &lt;code&gt;git rev-parse&lt;/code&gt; 를 사용하십시오 (아래 SQ-QUOTE 섹션 참조). 아래 의 &lt;code&gt;--sq&lt;/code&gt; 옵션과 달리이 모드는 인용 만합니다 . 입력을 명령하기위한 다른 작업은 없습니다.</target>
        </trans-unit>
        <trans-unit id="4c4d44083fa5e2a6971987cf935297be30994f4c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stash&lt;/code&gt; when you want to record the current state of the working directory and the index, but want to go back to a clean working directory. The command saves your local modifications away and reverts the working directory to match the &lt;code&gt;HEAD&lt;/code&gt; commit.</source>
          <target state="translated">작업 디렉토리 및 색인의 현재 상태를 기록하지만 깨끗한 작업 디렉토리로 돌아가려면 &lt;code&gt;git stash&lt;/code&gt; 를 사용하십시오 . 이 명령은 로컬 수정 사항을 저장하고 &lt;code&gt;HEAD&lt;/code&gt; 커밋 과 일치하도록 작업 디렉토리를 되돌 립니다.</target>
        </trans-unit>
        <trans-unit id="41c11f9d8154a7d9c49ff48bc15e09cdeb4a9a5c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stripspace --strip-comments&lt;/code&gt; to obtain:</source>
          <target state="translated">사용 &lt;code&gt;git stripspace --strip-comments&lt;/code&gt; 얻을 :</target>
        </trans-unit>
        <trans-unit id="141b00818c5025cc15ff515d81283fc5705a8a4e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stripspace&lt;/code&gt; with no arguments to obtain:</source>
          <target state="translated">인수없이 &lt;code&gt;git stripspace&lt;/code&gt; 를 사용 하여 다음을 확보하십시오.</target>
        </trans-unit>
        <trans-unit id="ae0479a18945009a7ebac30bdfceaa72c61a99c4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ident&lt;/code&gt; in the &lt;code&gt;From:&lt;/code&gt; header of each commit email. If the author ident of the commit is not textually identical to the provided &lt;code&gt;ident&lt;/code&gt;, place a &lt;code&gt;From:&lt;/code&gt; header in the body of the message with the original author. If no &lt;code&gt;ident&lt;/code&gt; is given, use the committer ident.</source>
          <target state="translated">각 커밋 이메일 의 &lt;code&gt;From:&lt;/code&gt; 헤더에 &lt;code&gt;ident&lt;/code&gt; 를 사용하십시오 . 커밋의 작성자 ID가 제공된 &lt;code&gt;ident&lt;/code&gt; 와 텍스트 적으로 동일하지 않은 경우 원래 작성자와 함께 메시지 본문에 &lt;code&gt;From:&lt;/code&gt; 헤더를 배치하십시오. &lt;code&gt;ident&lt;/code&gt; 가 없으면 커미터 아이디를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8fb68f530aa46816206d7ea34908da4d297edef3" translate="yes" xml:space="preserve">
          <source>Use IPv4 addresses only, ignoring IPv6 addresses.</source>
          <target state="translated">IPv6 주소는 무시하고 IPv4 주소 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d89ac89f76f16a68a863b0d9f578ffd1a558d6b0" translate="yes" xml:space="preserve">
          <source>Use IPv6 addresses only, ignoring IPv4 addresses.</source>
          <target state="translated">IPv4 주소는 무시하고 IPv6 주소 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="23206ddfb8d01b68973d7bd9cccf799f208e3657" translate="yes" xml:space="preserve">
          <source>Use Message &amp;rarr; Insert file&amp;hellip;​ and insert the patch.</source>
          <target state="translated">메시지 &amp;rarr; 파일 삽입&amp;hellip;을 사용하고 패치를 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="1b7e380bb9ef947a64359e01f17ce54cd3bdece1" translate="yes" xml:space="preserve">
          <source>Use One Mark Per Commit</source>
          <target state="translated">커밋 당 하나의 마크 사용</target>
        </trans-unit>
        <trans-unit id="c24268aab2b43d4e294643c8fbcbd60d377e139b" translate="yes" xml:space="preserve">
          <source>Use POSIX extended/basic regexp for patterns. Default is to use basic regexp.</source>
          <target state="translated">패턴에 POSIX 확장 / 기본 정규식을 사용하십시오. 기본은 기본 정규 표현식을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="36e96e4a2fd002679f3b794b4968539810c5c2eb" translate="yes" xml:space="preserve">
          <source>Use Perl-compatible regular expressions for patterns.</source>
          <target state="translated">패턴에 Perl 호환 정규식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fd46ce4ee0de88bb1a4ebb0e0c6375d24c2fb065" translate="yes" xml:space="preserve">
          <source>Use SO_REUSEADDR when binding the listening socket. This allows the server to restart without waiting for old connections to time out.</source>
          <target state="translated">청취 소켓을 바인딩 할 때 SO_REUSEADDR을 사용하십시오. 따라서 이전 연결 시간이 초과 될 때까지 기다리지 않고 서버를 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f351ffbdfc957393f82f6653e37778e19987b350" translate="yes" xml:space="preserve">
          <source>Use Tag Fixup Branches</source>
          <target state="translated">태그 수정 지점 사용</target>
        </trans-unit>
        <trans-unit id="41019858ddf6bd113a2b54361af9c75b6d741367" translate="yes" xml:space="preserve">
          <source>Use \0 as the delimiter for pathnames in the output, and print them verbatim. Without this option, pathnames with &quot;unusual&quot; characters are quoted as explained for the configuration variable core.quotePath (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">출력에서 경로 이름에 대한 구분 기호로 \ 0을 사용하고 그대로 인쇄합니다. 이 옵션이 없으면 &quot;비정상적인&quot;문자가있는 경로 이름은 구성 변수 core.quotePath에 대해 설명 된대로 인용됩니다 (참조 :&lt;a href=&quot;git-config&quot;&gt; git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="67640e675158aa473b8a69cc0cdb46fb8ed7283f" translate="yes" xml:space="preserve">
          <source>Use a &quot;stable&quot; sum of hashes as the patch ID. With this option:</source>
          <target state="translated">패치 ID로 &quot;안정한&quot;해시 합계를 사용하십시오. 이 옵션을 사용하면</target>
        </trans-unit>
        <trans-unit id="0ec5feaf620cc0230519584645c952a1ae99d83c" translate="yes" xml:space="preserve">
          <source>Use a client spec to find the list of interesting files in p4. See the &quot;CLIENT SPEC&quot; section below.</source>
          <target state="translated">클라이언트 사양을 사용하여 p4에서 흥미로운 파일 목록을 찾으십시오. 아래의 &quot;CLIENT SPEC&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cf410607b4d646fae6b37dffcb3f37fcc481f52b" translate="yes" xml:space="preserve">
          <source>Use a mergetool. &lt;code&gt;git mergetool&lt;/code&gt; to launch a graphical mergetool which will work you through the merge.</source>
          <target state="translated">mergetool을 사용하십시오. &lt;code&gt;git mergetool&lt;/code&gt; 을 사용하면 병합을 통해 그래픽 병합 도구를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7589df3d820308df2c8a838829de10cfbcf2077" translate="yes" xml:space="preserve">
          <source>Use a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a &lt;code&gt;+&lt;/code&gt;/&lt;code&gt;-&lt;/code&gt;/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde &lt;code&gt;~&lt;/code&gt; on a line of its own.</source>
          <target state="translated">스크립트 사용을 위해 특수한 라인 기반 형식을 사용하십시오. 추가 / 제거 / 변경되지 않은 런은 줄의 시작 부분에 &lt;code&gt;+&lt;/code&gt; / &lt;code&gt;-&lt;/code&gt; /``문자로 시작하여 줄 끝까지 확장되는 일반적인 통합 diff 형식으로 인쇄됩니다 . 입력 의 줄 바꿈은 자체 줄에 물결표 ( &lt;code&gt;~&lt;/code&gt; ) 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="77b024aefcbc37a1627539595d18a928f0842816" translate="yes" xml:space="preserve">
          <source>Use a tarball as a starting point for a new repository.</source>
          <target state="translated">tarball을 새 저장소의 시작점으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="afac3b09febbe243aa11caf12f594c7284e7bf23" translate="yes" xml:space="preserve">
          <source>Use an &quot;unstable&quot; hash as the patch ID. With this option, the result produced is compatible with the patch-id value produced by git 1.9 and older. Users with pre-existing databases storing patch-ids produced by git 1.9 and older (who do not deal with reordered patches) may want to use this option.</source>
          <target state="translated">&quot;불안정한&quot;해시를 패치 ID로 사용하십시오. 이 옵션을 사용하면 생성 된 결과가 git 1.9 이상에서 생성 된 patch-id 값과 호환됩니다. git 1.9 이상에서 생성 된 패치 ID를 저장하는 기존 데이터베이스를 가진 사용자 (재주문 된 패치를 처리하지 않는)는이 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef4088fc09156b38070cb26da8281dc7bfd8c504" translate="yes" xml:space="preserve">
          <source>Use an atomic transaction for updating the refs. If any of the refs fails to update then the entire push will fail without changing any refs.</source>
          <target state="translated">심판을 업데이트하기 위해 원 자성 트랜잭션을 사용하십시오. 심판이 업데이트에 실패하면 심판을 변경하지 않고 전체 푸시가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="049c3e05f1b188c69413c7549059c67376f76ed1" translate="yes" xml:space="preserve">
          <source>Use an atomic transaction on the remote side if available. Either all refs are updated, or on error, no refs are updated. If the server does not support atomic pushes the push will fail.</source>
          <target state="translated">가능한 경우 원격 측에서 원자 트랜잭션을 사용하십시오. 모든 심판이 업데이트되거나 오류가 발생하면 심판이 업데이트되지 않습니다. 서버가 원자 푸시를 지원하지 않으면 푸시가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="402b0ecf5212c8d413a7923b4b251cf4b803a260" translate="yes" xml:space="preserve">
          <source>Use applying strategies to rebase (calling &lt;code&gt;git-am&lt;/code&gt; internally). This option may become a no-op in the future once the merge backend handles everything the apply one does.</source>
          <target state="translated">전략을 적용하여 리베이스 (호출 &lt;code&gt;git-am&lt;/code&gt; 내부적으로 git-am ). 이 옵션은 병합 백엔드가 적용되는 모든 작업을 처리하면 나중에 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e55fb404106de44576d9bc731a7fb4baf9a6337c" translate="yes" xml:space="preserve">
          <source>Use binary search to find the commit that introduced a bug</source>
          <target state="translated">이진 검색을 사용하여 버그가 발생한 커밋 찾기</target>
        </trans-unit>
        <trans-unit id="78ee9b127501691d305b39cc3fc13fc74a1d22a1" translate="yes" xml:space="preserve">
          <source>Use customized color for &lt;code&gt;git add --interactive&lt;/code&gt; and &lt;code&gt;git clean --interactive&lt;/code&gt; output. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; may be &lt;code&gt;prompt&lt;/code&gt;, &lt;code&gt;header&lt;/code&gt;, &lt;code&gt;help&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;, for four distinct types of normal output from interactive commands.</source>
          <target state="translated">&lt;code&gt;git add --interactive&lt;/code&gt; 및 &lt;code&gt;git clean --interactive&lt;/code&gt; 출력에 사용자 정의 색상을 사용하십시오 . &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 은 대화식 명령의 네 가지 고유 한 유형의 일반 출력에 대해 &lt;code&gt;prompt&lt;/code&gt; , &lt;code&gt;header&lt;/code&gt; , &lt;code&gt;help&lt;/code&gt; 또는 &lt;code&gt;error&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf3aeb7f00c3d69ade01b5cc321078d4f50948ae" translate="yes" xml:space="preserve">
          <source>Use customized color for &lt;code&gt;git log --decorate&lt;/code&gt; output. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;branch&lt;/code&gt;, &lt;code&gt;remoteBranch&lt;/code&gt;, &lt;code&gt;tag&lt;/code&gt;, &lt;code&gt;stash&lt;/code&gt; or &lt;code&gt;HEAD&lt;/code&gt; for local branches, remote-tracking branches, tags, stash and HEAD, respectively and &lt;code&gt;grafted&lt;/code&gt; for grafted commits.</source>
          <target state="translated">&lt;code&gt;git log --decorate&lt;/code&gt; 출력에 사용자 정의 색상을 사용하십시오 . &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 중 하나 &lt;code&gt;branch&lt;/code&gt; , &lt;code&gt;remoteBranch&lt;/code&gt; , &lt;code&gt;tag&lt;/code&gt; , &lt;code&gt;stash&lt;/code&gt; 또는 &lt;code&gt;HEAD&lt;/code&gt; 분기 태그 숨기고 HEAD 각각 원격 추적 로컬 브랜치에 대한 &lt;code&gt;grafted&lt;/code&gt; 그래프트 커밋한다.</target>
        </trans-unit>
        <trans-unit id="29ecef38edab0e1998d46583be9558cf2a562eff" translate="yes" xml:space="preserve">
          <source>Use customized color for branch coloration. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;current&lt;/code&gt; (the current branch), &lt;code&gt;local&lt;/code&gt; (a local branch), &lt;code&gt;remote&lt;/code&gt; (a remote-tracking branch in refs/remotes/), &lt;code&gt;upstream&lt;/code&gt; (upstream tracking branch), &lt;code&gt;plain&lt;/code&gt; (other refs).</source>
          <target state="translated">브랜치 착색에 사용자 정의 색상을 사용하십시오. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 은 &lt;code&gt;current&lt;/code&gt; (현재 분기), &lt;code&gt;local&lt;/code&gt; (로컬 분기), &lt;code&gt;remote&lt;/code&gt; (참조 / 원격 /의 원격 추적 분기), &lt;code&gt;upstream&lt;/code&gt; (업스트림 추적 분기), &lt;code&gt;plain&lt;/code&gt; (기타 참조) 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="fcdeebdb47ef8466da45d806c0dccf091f4447a0" translate="yes" xml:space="preserve">
          <source>Use customized color for diff colorization. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; specifies which part of the patch to use the specified color, and is one of &lt;code&gt;context&lt;/code&gt; (context text - &lt;code&gt;plain&lt;/code&gt; is a historical synonym), &lt;code&gt;meta&lt;/code&gt; (metainformation), &lt;code&gt;frag&lt;/code&gt; (hunk header), &lt;code&gt;func&lt;/code&gt; (function in hunk header), &lt;code&gt;old&lt;/code&gt; (removed lines), &lt;code&gt;new&lt;/code&gt; (added lines), &lt;code&gt;commit&lt;/code&gt; (commit headers), &lt;code&gt;whitespace&lt;/code&gt; (highlighting whitespace errors), &lt;code&gt;oldMoved&lt;/code&gt; (deleted lines), &lt;code&gt;newMoved&lt;/code&gt; (added lines), &lt;code&gt;oldMovedDimmed&lt;/code&gt;, &lt;code&gt;oldMovedAlternative&lt;/code&gt;, &lt;code&gt;oldMovedAlternativeDimmed&lt;/code&gt;, &lt;code&gt;newMovedDimmed&lt;/code&gt;, &lt;code&gt;newMovedAlternative&lt;/code&gt;&lt;code&gt;newMovedAlternativeDimmed&lt;/code&gt; (See the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; setting of &lt;code&gt;--color-moved&lt;/code&gt; in &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; for details), &lt;code&gt;contextDimmed&lt;/code&gt;, &lt;code&gt;oldDimmed&lt;/code&gt;, &lt;code&gt;newDimmed&lt;/code&gt;, &lt;code&gt;contextBold&lt;/code&gt;, &lt;code&gt;oldBold&lt;/code&gt;, and &lt;code&gt;newBold&lt;/code&gt; (see &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff[1]&lt;/a&gt; for details).</source>
          <target state="translated">diff 착색을 위해 맞춤형 색상을 사용하십시오. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 은 패치에서 지정된 색상을 사용할 부분을 지정하며 &lt;code&gt;context&lt;/code&gt; (컨텍스트 텍스트- &lt;code&gt;plain&lt;/code&gt; 은 역사적 동의어 임), &lt;code&gt;meta&lt;/code&gt; (제조), &lt;code&gt;frag&lt;/code&gt; (행크 헤더), &lt;code&gt;func&lt;/code&gt; (행크 헤더의 함수) 중 하나입니다. &lt;code&gt;old&lt;/code&gt; (제거 된 줄), &lt;code&gt;new&lt;/code&gt; (추가 된 줄), &lt;code&gt;commit&lt;/code&gt; (커밋 헤더), &lt;code&gt;whitespace&lt;/code&gt; (공백 공백 오류), &lt;code&gt;oldMoved&lt;/code&gt; (삭제 된 줄), &lt;code&gt;newMoved&lt;/code&gt; (추가 된 줄), &lt;code&gt;oldMovedDimmed&lt;/code&gt; , &lt;code&gt;oldMovedAlternative&lt;/code&gt; , &lt;code&gt;oldMovedAlternativeDimmed&lt;/code&gt; , &lt;code&gt;newMovedDimmed&lt;/code&gt; , &lt;code&gt;newMovedAlternative&lt;/code&gt; &lt;code&gt;newMovedAlternativeDimmed&lt;/code&gt; (자세한 내용은 &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 에서 &lt;code&gt;--color-moved&lt;/code&gt; 의 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 설정 참조), &lt;code&gt;contextDimmed&lt;/code&gt; , &lt;code&gt;oldDimmed&lt;/code&gt; , &lt;code&gt;newDimmed&lt;/code&gt; , &lt;code&gt;contextBold&lt;/code&gt; , &lt;code&gt;oldBold&lt;/code&gt; 및 &lt;code&gt;newBold&lt;/code&gt; ( &lt;a href=&quot;git-range-diff&quot;&gt;git-range&lt;/a&gt; 참조 ) 1] 자세한 내용을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="799532fe06b09693cab5782f0c7b74d1305d2cb1" translate="yes" xml:space="preserve">
          <source>Use customized color for each remote keyword. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; may be &lt;code&gt;hint&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, &lt;code&gt;success&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt; which match the corresponding keyword.</source>
          <target state="translated">각 원격 키워드에 맞춤 색상을 사용하십시오. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 은 해당 키워드와 일치하는 &lt;code&gt;hint&lt;/code&gt; , &lt;code&gt;warning&lt;/code&gt; , &lt;code&gt;success&lt;/code&gt; 또는 &lt;code&gt;error&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8363e3bb3b19269f1bec63465f050d08c7400a8" translate="yes" xml:space="preserve">
          <source>Use customized color for grep colorization. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; specifies which part of the line to use the specified color, and is one of</source>
          <target state="translated">grep 착색을 위해 사용자 정의 색상을 사용하십시오. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 은 지정된 색상을 사용할 줄 부분을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="3d940f7a54cc13b6b8a420b163ce2b7e4ccedf38" translate="yes" xml:space="preserve">
          <source>Use customized color for hints.</source>
          <target state="translated">힌트에 사용자 정의 색상을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a7bc0186c1d40a59aee910eedb6524484cbce3a0" translate="yes" xml:space="preserve">
          <source>Use customized color for push errors.</source>
          <target state="translated">푸시 오류에는 사용자 정의 색상을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="efd1e4b094e6a540e69b42772ae161651f4648a2" translate="yes" xml:space="preserve">
          <source>Use customized color for status colorization. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;header&lt;/code&gt; (the header text of the status message), &lt;code&gt;added&lt;/code&gt; or &lt;code&gt;updated&lt;/code&gt; (files which are added but not committed), &lt;code&gt;changed&lt;/code&gt; (files which are changed but not added in the index), &lt;code&gt;untracked&lt;/code&gt; (files which are not tracked by Git), &lt;code&gt;branch&lt;/code&gt; (the current branch), &lt;code&gt;nobranch&lt;/code&gt; (the color the &lt;code&gt;no branch&lt;/code&gt; warning is shown in, defaulting to red), &lt;code&gt;localBranch&lt;/code&gt; or &lt;code&gt;remoteBranch&lt;/code&gt; (the local and remote branch names, respectively, when branch and tracking information is displayed in the status short-format), or &lt;code&gt;unmerged&lt;/code&gt; (files which have unmerged changes).</source>
          <target state="translated">상태 색상 지정에 사용자 정의 색상을 사용하십시오. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 은 &lt;code&gt;header&lt;/code&gt; (상태 메시지의 헤더 텍스트), &lt;code&gt;added&lt;/code&gt; 또는 &lt;code&gt;updated&lt;/code&gt; (추가되었지만 커밋되지 않은 파일 ), &lt;code&gt;changed&lt;/code&gt; (인덱스에서 변경되었지만 추가되지 않은 파일 ), &lt;code&gt;untracked&lt;/code&gt; 되지 않은 파일 중 하나입니다. 힘내)에 의해 추적 &lt;code&gt;branch&lt;/code&gt; (현 지사) &lt;code&gt;nobranch&lt;/code&gt; (상기 컬러 &lt;code&gt;no branch&lt;/code&gt; 경고에 도시되며, 적색에 디폴트) &lt;code&gt;localBranch&lt;/code&gt; 또는 &lt;code&gt;remoteBranch&lt;/code&gt; 분기 및 추적 정보가 표시된다 (각각의 로컬 및 원격 지점 이름, 상태 짧은 형식) 또는 &lt;code&gt;unmerged&lt;/code&gt; (변경되지 않은 변경 사항이있는 파일).</target>
        </trans-unit>
        <trans-unit id="42006ecfd08deb9b3ff0a3f1d7240d8f715710f3" translate="yes" xml:space="preserve">
          <source>Use customized color when a push was rejected.</source>
          <target state="translated">푸시가 거부되면 사용자 정의 색상을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7714f2243f3ecb7a0c915a75f0d9677bee5cfddf" translate="yes" xml:space="preserve">
          <source>Use fixed strings for patterns (don&amp;rsquo;t interpret pattern as a regex).</source>
          <target state="translated">패턴에 고정 문자열을 사용하십시오 (패턴을 정규식으로 해석하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="be83392780575c9c0f338875e4ab41fca7ad0580" translate="yes" xml:space="preserve">
          <source>Use given directory for the location of Git objects. We check &lt;code&gt;&amp;lt;dir&amp;gt;/packs/multi-pack-index&lt;/code&gt; for the current MIDX file, and &lt;code&gt;&amp;lt;dir&amp;gt;/packs&lt;/code&gt; for the pack-files to index.</source>
          <target state="translated">Git 객체의 위치에 지정된 디렉토리를 사용하십시오. 우리는 확인 &lt;code&gt;&amp;lt;dir&amp;gt;/packs/multi-pack-index&lt;/code&gt; 현재 MIDX 파일 및 &lt;code&gt;&amp;lt;dir&amp;gt;/packs&lt;/code&gt; 인덱스 팩 - 파일.</target>
        </trans-unit>
        <trans-unit id="58e0e6d68f2b1086e2f61cc3ccf9bb473fce2cb1" translate="yes" xml:space="preserve">
          <source>Use given directory for the location of packfiles and commit-graph file. This parameter exists to specify the location of an alternate that only has the objects directory, not a full &lt;code&gt;.git&lt;/code&gt; directory. The commit-graph file is expected to be in the &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; directory and the packfiles are expected to be in &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt;.</source>
          <target state="translated">packfile 및 commit-graph 파일의 위치에 지정된 디렉토리를 사용하십시오. 이 매개 변수는 전체 &lt;code&gt;.git&lt;/code&gt; 디렉토리가 아닌 objects 디렉토리 만있는 대체의 위치를 ​​지정하기 위해 존재합니다 . 커밋 그래프 파일은 &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; 디렉토리에 있고 packfiles는 &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt; 에 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="034b8d3eb2bf376cba5a544572cc51a019ffd1af" translate="yes" xml:space="preserve">
          <source>Use given directory for the location of packfiles and commit-graph file. This parameter exists to specify the location of an alternate that only has the objects directory, not a full &lt;code&gt;.git&lt;/code&gt; directory. The commit-graph file is expected to be in the &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; directory and the packfiles are expected to be in &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt;. If the directory could not be made into an absolute path, or does not match any known object directory, &lt;code&gt;git commit-graph ...&lt;/code&gt; will exit with non-zero status.</source>
          <target state="translated">packfiles 및 commit-graph 파일의 위치에 지정된 디렉토리를 사용하십시오. 이 매개 변수는 전체 &lt;code&gt;.git&lt;/code&gt; 디렉토리가 아닌 objects 디렉토리 만있는 대체 위치를 지정하기 위해 존재합니다 . commit-graph 파일은 &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; 디렉토리에 있고 packfile은 &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt; 에 있어야 합니다. 디렉터리를 절대 경로로 만들 수 없거나 알려진 개체 디렉터리와 일치하지 않는 경우 &lt;code&gt;git commit-graph ...&lt;/code&gt; 는 0이 아닌 상태로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="9e22ac3ec044552fceb6f971a8409c3fc735d918" translate="yes" xml:space="preserve">
          <source>Use gmail as the smtp server</source>
          <target state="translated">Gmail을 SMTP 서버로 사용</target>
        </trans-unit>
        <trans-unit id="243e0ec42451f8d223cf0a086b6e0d020fe017bc" translate="yes" xml:space="preserve">
          <source>Use hash &lt;code&gt;#&lt;/code&gt; for comments that are either on their own line, or after the email address.</source>
          <target state="translated">자체 줄에 있거나 전자 메일 주소 뒤에있는 주석 에는 해시 &lt;code&gt;#&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe4290ca9cf2dcf165b3911c20fcc8115cf36b09" translate="yes" xml:space="preserve">
          <source>Use libcurl to communicate with the IMAP server, unless tunneling into it. Ignored if Git was built without the USE_CURL_FOR_IMAP_SEND option set.</source>
          <target state="translated">터널링하지 않는 한 libcurl을 사용하여 IMAP 서버와 통신하십시오. USE_CURL_FOR_IMAP_SEND 옵션을 설정하지 않고 Git을 빌드 한 경우 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b43e2a7c9e04ff83908291bc454ceb95c66f26d2" translate="yes" xml:space="preserve">
          <source>Use mailmap file to map author and committer names and email addresses to canonical real names and email addresses. See &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt;.</source>
          <target state="translated">메일 맵 파일을 사용하여 작성자 및 커미터 이름 및 이메일 주소를 표준 실제 이름 및 이메일 주소에 맵핑하십시오. &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="869311b9e64386ec94c4224dbda98ca212bcb863" translate="yes" xml:space="preserve">
          <source>Use merging strategies to rebase. When the recursive (default) merge strategy is used, this allows rebase to be aware of renames on the upstream side.</source>
          <target state="translated">합병 전략을 사용하여 리베이스하십시오. 재귀 (기본) 병합 전략을 사용하면 업스트림 측에서 이름을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07cf71eed9a3b36f45bcc6fde8a3af9707bd0146" translate="yes" xml:space="preserve">
          <source>Use merging strategies to rebase. When the recursive (default) merge strategy is used, this allows rebase to be aware of renames on the upstream side. This is the default.</source>
          <target state="translated">병합 전략을 사용하여 리베이스하십시오. 재귀 적 (기본) 병합 전략을 사용하면 리베이스가 업스트림 측의 이름 변경을 인식 할 수 있습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="504dd078aaf1ec972f6af826bbe142e1450759fa" translate="yes" xml:space="preserve">
          <source>Use of &quot;topic branches&quot; solves these problems. The name is pretty self explanatory, with a caveat that comes from the &quot;merge upwards&quot; rule above:</source>
          <target state="translated">&quot;주제 분기&quot;를 사용하면 이러한 문제가 해결됩니다. 이름은 위의 &quot;위로 병합&quot;규칙에서 비롯된 경고와 함께 매우 자명 한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="2997460999cadfc1fcc5d52315d53b3d5efcd07d" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;dcommit&lt;/code&gt; is preferred to &lt;code&gt;set-tree&lt;/code&gt; (below).</source>
          <target state="translated">&lt;code&gt;set-tree&lt;/code&gt; (아래) 보다 &lt;code&gt;dcommit&lt;/code&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6b08c4843a60fcea417d6fa6b7562621b3124054" translate="yes" xml:space="preserve">
          <source>Use of this utility is encouraged in favor of directly accessing files under the &lt;code&gt;.git&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;.git&lt;/code&gt; 디렉토리 에있는 파일에 직접 액세스하기 위해이 유틸리티를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="3a96544176d9c64bcdfe76616987380a83e4f896" translate="yes" xml:space="preserve">
          <source>Use permissions reported by umask(2). The default, when &lt;code&gt;--shared&lt;/code&gt; is not specified.</source>
          <target state="translated">umask (2)에 의해보고 된 권한을 사용하십시오. &lt;code&gt;--shared&lt;/code&gt; 가 지정되지 않은 경우 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="7b2e5a64a2bb1a5fbe6304abee401e1d3f35a8f4" translate="yes" xml:space="preserve">
          <source>Use reflog to find a better common ancestor between &amp;lt;upstream&amp;gt; and &amp;lt;branch&amp;gt; when calculating which commits have been introduced by &amp;lt;branch&amp;gt;.</source>
          <target state="translated">&amp;lt;branch&amp;gt;에 의해 어떤 커밋이 도입되었는지 계산할 때 reflog를 사용하여 &amp;lt;upstream&amp;gt;과 &amp;lt;branch&amp;gt; 사이에 더 나은 공통 조상을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="b40e39ff3f77007104d997879dd735023a9dca06" translate="yes" xml:space="preserve">
          <source>Use revisions from revs-file instead of calling &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt; 을 호출하는 대신 revs-file의 개정판을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="efb298546ca010c6e357a2c3cc79d1b86fb2f356" translate="yes" xml:space="preserve">
          <source>Use the &quot;sparse&quot; algorithm to determine which objects to include in the pack, when combined with the &quot;--revs&quot; option. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames.</source>
          <target state="translated">&quot;--pars&quot;옵션과 결합 될 때 팩에 포함 할 오브젝트를 결정하려면 &quot;스파 스&quot;알고리즘을 사용하십시오. 이 알고리즘은 새로운 객체를 도입하는 경로에 나타나는 트리 만 걷는다. 이것은 작은 변화를 보내기 위해 팩을 계산할 때 상당한 성능 이점을 가질 수 있습니다. 그러나 포함 된 커밋에 특정 유형의 직접 이름 바꾸기가 포함되어 있으면 추가 객체가 팩 파일에 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0755f10a2fd51824d1737b45b49a4642d66873f8" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--in-place&lt;/code&gt; option to edit a message file in place:</source>
          <target state="translated">&lt;code&gt;--in-place&lt;/code&gt; 옵션을 사용하여 메시지 파일을 적절 하게 편집하십시오.</target>
        </trans-unit>
        <trans-unit id="55e7e1126d3aa0a5c8bf2360dfcd495bb1107882" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute only if you cannot store a file in UTF-8 encoding and if you want Git to be able to process the content as text.</source>
          <target state="translated">사용 &lt;code&gt;working-tree-encoding&lt;/code&gt; 이 UTF-8 인코딩으로 파일을 저장할 수없는 경우에만 속성을 원하는 경우 힘내 텍스트로 내용을 처리 할 수 있도록.</target>
        </trans-unit>
        <trans-unit id="b5ec705c3f1e9d70bd95302efbf5732684172042" translate="yes" xml:space="preserve">
          <source>Use the branch detection algorithm to find new paths in p4. It is documented below in &quot;BRANCH DETECTION&quot;.</source>
          <target state="translated">p4에서 새 경로를 찾으려면 분기 감지 알고리즘을 사용하십시오. 아래의 &quot;브랜치 감지&quot;에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="33ac56041ae34da6b3682a94d8a665913a47636a" translate="yes" xml:space="preserve">
          <source>Use the credential (e.g., access the URL with the username and password from step (2)), and see if it&amp;rsquo;s accepted.</source>
          <target state="translated">자격 증명을 사용합니다 (예 : 2 단계의 사용자 이름과 비밀번호로 URL에 액세스).</target>
        </trans-unit>
        <trans-unit id="4cfefdd524d37cf0c1fedc168c903048fc636bbd" translate="yes" xml:space="preserve">
          <source>Use the customized color for the part of git-blame output that is repeated meta information per line (such as commit id, author name, date and timezone). Defaults to cyan.</source>
          <target state="translated">커밋 ID, 작성자 이름, 날짜 및 시간대와 같이 줄당 메타 정보가 반복되는 git-blame 출력 부분에 사용자 정의 된 색상을 사용하십시오. 기본적으로 청록색입니다.</target>
        </trans-unit>
        <trans-unit id="a024bae6c0f6ae8fa68e77c95e0c4f95100aa970" translate="yes" xml:space="preserve">
          <source>Use the diff tool specified by &amp;lt;tool&amp;gt;. Valid values include emerge, kompare, meld, and vimdiff. Run &lt;code&gt;git difftool --tool-help&lt;/code&gt; for the list of valid &amp;lt;tool&amp;gt; settings.</source>
          <target state="translated">&amp;lt;tool&amp;gt;에 지정된 diff 도구를 사용하십시오. 유효한 값은 emerge, kompare, meld 및 vimdiff입니다. 유효한 &amp;lt;tool&amp;gt; 설정 목록을 보려면 &lt;code&gt;git difftool --tool-help&lt;/code&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="161588bc8b76efbad18d428ccf6e2f5e459908d1" translate="yes" xml:space="preserve">
          <source>Use the fast patchset import strategy. This can be significantly faster for large trees, but cannot handle directory renames or permissions changes. The default strategy is slow and safe.</source>
          <target state="translated">빠른 패치 세트 가져 오기 전략을 사용하십시오. 이는 큰 트리의 경우 훨씬 빠를 수 있지만 디렉토리 이름 변경 또는 권한 변경은 처리 할 수 ​​없습니다. 기본 전략은 느리고 안전합니다.</target>
        </trans-unit>
        <trans-unit id="89541b63bc820ad5c76ea37101a62452ee62e61c" translate="yes" xml:space="preserve">
          <source>Use the following attributes if your &lt;code&gt;*.ps1&lt;/code&gt; files are UTF-16 little endian encoded without BOM and you want Git to use Windows line endings in the working directory (use &lt;code&gt;UTF-16LE-BOM&lt;/code&gt; instead of &lt;code&gt;UTF-16LE&lt;/code&gt; if you want UTF-16 little endian with BOM). Please note, it is highly recommended to explicitly define the line endings with &lt;code&gt;eol&lt;/code&gt; if the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute is used to avoid ambiguity.</source>
          <target state="translated">귀하의 경우 다음과 같은 속성을 사용하여 &lt;code&gt;*.ps1&lt;/code&gt; 입니다 (사용 파일이 BOM없이 인코딩 UTF-16 리틀 엔디안이고, 당신이 망할 놈의 작업 디렉토리에서 윈도우 라인 엔딩을 사용하려면 &lt;code&gt;UTF-16LE-BOM&lt;/code&gt; 대신 &lt;code&gt;UTF-16LE&lt;/code&gt; 을 당신은 UTF-16를 원하는 경우 BOM이있는 리틀 엔디 언). &lt;code&gt;working-tree-encoding&lt;/code&gt; 속성을 사용하여 모호성을 피하는 경우 &lt;code&gt;eol&lt;/code&gt; 로 줄 끝을 명시 적으로 정의하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e5c2f58b6a6ebc713504e60181f4f0dd37da2d6d" translate="yes" xml:space="preserve">
          <source>Use the given &amp;lt;msg&amp;gt; as the commit message. If multiple &lt;code&gt;-m&lt;/code&gt; options are given, their values are concatenated as separate paragraphs.</source>
          <target state="translated">주어진 &amp;lt;msg&amp;gt;를 커밋 메시지로 사용하십시오. 여러 개의 &lt;code&gt;-m&lt;/code&gt; 옵션이 제공되면 해당 값은 별도의 단락으로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="be3b9715415e0357d3d87d01aa8f812c871fb1e1" translate="yes" xml:space="preserve">
          <source>Use the given &lt;code&gt;msg&lt;/code&gt; as the commit message. This option disables the &lt;code&gt;--edit&lt;/code&gt; option.</source>
          <target state="translated">주어진 &lt;code&gt;msg&lt;/code&gt; 를 커밋 메시지로 사용하십시오 . 이 옵션은 &lt;code&gt;--edit&lt;/code&gt; 옵션을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="43103d879018fa15a44cefa9b3baec705e25165c" translate="yes" xml:space="preserve">
          <source>Use the given config file instead of the one specified by GIT_CONFIG.</source>
          <target state="translated">GIT_CONFIG가 지정한 설정 파일 대신 지정된 설정 파일을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1af0579593d71707be713f8eac06f59e9d72c0da" translate="yes" xml:space="preserve">
          <source>Use the given config variable as a multi-valued list storing absolute path names. Iterate on that list of paths to run the given arguments.</source>
          <target state="translated">주어진 구성 변수를 절대 경로 이름을 저장하는 다중 값 목록으로 사용하십시오. 주어진 인수를 실행하기 위해 경로 목록을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="6d07104b51b424f44cb0346a9ac8f4116b0f06d7" translate="yes" xml:space="preserve">
          <source>Use the given exclude pattern in addition to the standard ignore rules (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;).</source>
          <target state="translated">표준 무시 규칙 외에도 주어진 제외 패턴을 사용하십시오 ( &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9a12bbd112f0b48f03fdbbbb0b9c68268bedd960" translate="yes" xml:space="preserve">
          <source>Use the given merge strategy. If there is no &lt;code&gt;-s&lt;/code&gt; option &lt;code&gt;git merge-recursive&lt;/code&gt; is used instead. This implies --merge.</source>
          <target state="translated">주어진 병합 전략을 사용하십시오. &lt;code&gt;-s&lt;/code&gt; 옵션 이 없으면 &lt;code&gt;git merge-recursive&lt;/code&gt; 가 대신 사용됩니다. 이것은 --merge를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="aad779cdebc63bc4b25eb19e46a7b214101b70ea" translate="yes" xml:space="preserve">
          <source>Use the given merge strategy. Should only be used once. See the MERGE STRATEGIES section in &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; for details.</source>
          <target state="translated">주어진 병합 전략을 사용하십시오. 한 번만 사용해야합니다. 자세한 내용은 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt; 의 MERGE STRATEGIES 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0d697cccd6049781089822f14d706ae91b43a781" translate="yes" xml:space="preserve">
          <source>Use the given merge strategy; can be supplied more than once to specify them in the order they should be tried. If there is no &lt;code&gt;-s&lt;/code&gt; option, a built-in list of strategies is used instead (&lt;code&gt;git merge-recursive&lt;/code&gt; when merging a single head, &lt;code&gt;git merge-octopus&lt;/code&gt; otherwise).</source>
          <target state="translated">주어진 병합 전략을 사용하십시오. 시도해야하는 순서대로 지정하기 위해 두 번 이상 제공 될 수 있습니다. &lt;code&gt;-s&lt;/code&gt; 옵션 이없는 경우 기본 제공 전략 목록이 대신 사용됩니다 ( 단일 헤드를 병합 할 때는 &lt;code&gt;git merge-recursive&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;git merge-octopus&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e15a6801b533c61848133f0481a1499ec359e784" translate="yes" xml:space="preserve">
          <source>Use the given note message (instead of prompting). If multiple &lt;code&gt;-m&lt;/code&gt; options are given, their values are concatenated as separate paragraphs. Lines starting with &lt;code&gt;#&lt;/code&gt; and empty lines other than a single line between paragraphs will be stripped out.</source>
          <target state="translated">프롬프트 대신 지정된 메모 메시지를 사용하십시오. 여러 개의 &lt;code&gt;-m&lt;/code&gt; 옵션이 제공되면 해당 값은 별도의 단락으로 연결됩니다. &lt;code&gt;#&lt;/code&gt; 으로 시작하고 단락 사이의 한 줄 이외의 빈 줄은 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="2301e57be484e5bf3374c6061960726be52acd3f" translate="yes" xml:space="preserve">
          <source>Use the given tag message (instead of prompting). If multiple &lt;code&gt;-m&lt;/code&gt; options are given, their values are concatenated as separate paragraphs. Implies &lt;code&gt;-a&lt;/code&gt; if none of &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, or &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; is given.</source>
          <target state="translated">프롬프트 대신 지정된 태그 메시지를 사용하십시오. 여러 개의 &lt;code&gt;-m&lt;/code&gt; 옵션이 제공되면 해당 값은 별도의 단락으로 연결됩니다. &lt;code&gt;-a&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; 또는 &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; 가 없으면 &lt;code&gt;-a&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="52a6c166f490dbb0be0d25b65f46015f7e67e623" translate="yes" xml:space="preserve">
          <source>Use the interactive patch selection interface to chose which changes to commit. See &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; for details.</source>
          <target state="translated">대화식 패치 선택 인터페이스를 사용하여 커밋 할 변경 사항을 선택하십시오. 자세한 내용은 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7db128e87ada4e1ec3f3340d8431acfc429f3677" translate="yes" xml:space="preserve">
          <source>Use the merge resolution program specified by &amp;lt;tool&amp;gt;. Valid values include emerge, gvimdiff, kdiff3, meld, vimdiff, and tortoisemerge. Run &lt;code&gt;git mergetool --tool-help&lt;/code&gt; for the list of valid &amp;lt;tool&amp;gt; settings.</source>
          <target state="translated">&amp;lt;tool&amp;gt;에서 지정한 병합 해결 프로그램을 사용하십시오. 유효한 값은 emerge, gvimdiff, kdiff3, meld, vimdiff 및 tortoisemerge입니다. 유효한 &amp;lt;tool&amp;gt; 설정 목록을 보려면 &lt;code&gt;git mergetool --tool-help&lt;/code&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="dcec4916e7483efe626c7c3cca0d933ec3eb9b91" translate="yes" xml:space="preserve">
          <source>Use the multi-pack-index file to track multiple packfiles using a single index. See &lt;a href=&quot;git-multi-pack-index&quot;&gt;git-multi-pack-index[1]&lt;/a&gt; for more information. Defaults to true.</source>
          <target state="translated">다중 팩 인덱스 파일을 사용하여 단일 인덱스를 사용하여 여러 팩 파일을 추적합니다. 자세한 내용은 &lt;a href=&quot;git-multi-pack-index&quot;&gt;git-multi-pack-index [1]&lt;/a&gt; 을 참조하세요. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="047156e36b9d6e8b2155d32a029545b1b026f10e" translate="yes" xml:space="preserve">
          <source>Use the multi-pack-index file to track multiple packfiles using a single index. See &lt;a href=&quot;multi-pack-index&quot;&gt;the multi-pack-index design document&lt;/a&gt;.</source>
          <target state="translated">다중 팩 색인 파일을 사용하여 단일 색인을 사용하여 여러 팩 파일을 추적하십시오. &lt;a href=&quot;multi-pack-index&quot;&gt;다중 팩 인덱스 디자인 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f14443aa07cf034aa00129ee21b4f7df2be49255" translate="yes" xml:space="preserve">
          <source>Use the partial clone feature and request that the server sends a subset of reachable objects according to a given object filter. When using &lt;code&gt;--filter&lt;/code&gt;, the supplied &lt;code&gt;&amp;lt;filter-spec&amp;gt;&lt;/code&gt; is used for the partial clone filter. For example, &lt;code&gt;--filter=blob:none&lt;/code&gt; will filter out all blobs (file contents) until needed by Git. Also, &lt;code&gt;--filter=blob:limit=&amp;lt;size&amp;gt;&lt;/code&gt; will filter out all blobs of size at least &lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt;. For more details on filter specifications, see the &lt;code&gt;--filter&lt;/code&gt; option in &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;.</source>
          <target state="translated">부분 복제 기능을 사용하고 서버가 주어진 개체 필터에 따라 도달 가능한 개체의 하위 집합을 보내도록 요청합니다. &lt;code&gt;--filter&lt;/code&gt; 를 사용할 때 제공된 &lt;code&gt;&amp;lt;filter-spec&amp;gt;&lt;/code&gt; 이 부분 복제 필터에 사용됩니다. 예를 들어 &lt;code&gt;--filter=blob:none&lt;/code&gt; 은 Git에서 필요할 때까지 모든 blob (파일 콘텐츠)을 필터링합니다. 또한 &lt;code&gt;--filter=blob:limit=&amp;lt;size&amp;gt;&lt;/code&gt; 적어도 크기의 모든 얼룩을 걸러 &lt;code&gt;&amp;lt;size&amp;gt;&lt;/code&gt; . 필터 사양에 대한 자세한 내용은의 &lt;code&gt;--filter&lt;/code&gt; 옵션을 참조하십시오.&lt;a href=&quot;git-rev-list&quot;&gt; git-rev-list [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6bac5b4ccbcc396e691c8ba8f2af89d4f60c9270" translate="yes" xml:space="preserve">
          <source>Use the same output mode as &lt;a href=&quot;git-annotate&quot;&gt;git-annotate[1]&lt;/a&gt; (Default: off).</source>
          <target state="translated">&lt;a href=&quot;git-annotate&quot;&gt;git-annotate [1]&lt;/a&gt; 과 동일한 출력 모드를 사용하십시오 (기본값 : off).</target>
        </trans-unit>
        <trans-unit id="0ed67a2ecd3a9ee96ae4cd7dcb45f48a2cf84bf4" translate="yes" xml:space="preserve">
          <source>Use the selected commit message without launching an editor. For example, &lt;code&gt;git commit --amend --no-edit&lt;/code&gt; amends a commit without changing its commit message.</source>
          <target state="translated">편집기를 시작하지 않고 선택된 커밋 메시지를 사용하십시오. 예를 들어, &lt;code&gt;git commit --amend --no-edit&lt;/code&gt; 는 커밋 메시지를 변경하지 않고 커밋을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="8e65c034e7da87d64be153e02b39a8529bd16f67" translate="yes" xml:space="preserve">
          <source>Use the source ref that matches &lt;code&gt;master&lt;/code&gt; (e.g. &lt;code&gt;refs/heads/master&lt;/code&gt;) to update the ref that matches &lt;code&gt;satellite/master&lt;/code&gt; (most probably &lt;code&gt;refs/remotes/satellite/master&lt;/code&gt;) in the &lt;code&gt;mothership&lt;/code&gt; repository; do the same for &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;satellite/dev&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; 와 일치하는 소스 참조 (예 : &lt;code&gt;refs/heads/master&lt;/code&gt; )를 사용 하여 &lt;code&gt;mothership&lt;/code&gt; 저장소의 &lt;code&gt;satellite/master&lt;/code&gt; (대부분 &lt;code&gt;refs/remotes/satellite/master&lt;/code&gt; ) 와 일치하는 참조를 업데이트하십시오 . &lt;code&gt;dev&lt;/code&gt; 및 &lt;code&gt;satellite/dev&lt;/code&gt; 에 대해 동일한 작업을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="82b93c6560af27195da14e70510e2b3d8651c3b7" translate="yes" xml:space="preserve">
          <source>Use the specified HTTP protocol version when communicating with a server. If you want to force the default. The available and default version depend on libcurl. Actually the possible values of this option are:</source>
          <target state="translated">서버와 통신 할 때 지정된 HTTP 프로토콜 버전을 사용하십시오. 기본값을 적용하려는 경우. 사용 가능한 기본 버전은 libcurl에 따라 다릅니다. 실제로이 옵션의 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85fede53ff0add46d3665dfda925d3c1db752a7f" translate="yes" xml:space="preserve">
          <source>Use the specified HTTP protocol version when communicating with a server. If you want to force the default. The available and default version depend on libcurl. Currently the possible values of this option are:</source>
          <target state="translated">서버와 통신 할 때 지정된 HTTP 프로토콜 버전을 사용하십시오. 기본값을 강제하려는 경우. 사용 가능한 기본 버전은 libcurl에 따라 다릅니다. 현재이 옵션의 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="becfdaabcf538340d904ac918eb155dd5d16c802" translate="yes" xml:space="preserve">
          <source>Use the specified URL to connect to the destination Subversion repository. This is useful in cases where the source SVN repository is read-only. This option overrides configuration property &lt;code&gt;commiturl&lt;/code&gt;.</source>
          <target state="translated">지정된 URL을 사용하여 대상 Subversion 저장소에 연결하십시오. 소스 SVN 저장소가 읽기 전용 인 경우에 유용합니다. 이 옵션은 구성 특성 &lt;code&gt;commiturl&lt;/code&gt; 을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="47ea3d46f75adaf5916e50431ef8bbea6e57dfd6" translate="yes" xml:space="preserve">
          <source>Use the specified browser. It must be in the list of supported browsers.</source>
          <target state="translated">지정된 브라우저를 사용하십시오. 지원되는 브라우저 목록에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2c9d0a1d0fa5a2da07f63db4c5b77e59ec9169b0" translate="yes" xml:space="preserve">
          <source>Use the specified name for the initial branch in the newly created repository. If not specified, fall back to the default name (currently &lt;code&gt;master&lt;/code&gt;, but this is subject to change in the future; the name can be customized via the &lt;code&gt;init.defaultBranch&lt;/code&gt; configuration variable).</source>
          <target state="translated">새로 생성 된 저장소의 초기 브랜치에 지정된 이름을 사용합니다. 지정되지 않은 경우 기본 이름 (현재 &lt;code&gt;master&lt;/code&gt; 이지만 나중에 변경 될 수 있습니다. 이름은 &lt;code&gt;init.defaultBranch&lt;/code&gt; 구성 변수 를 통해 사용자 정의 할 수 있음)으로 대체하십시오 .</target>
        </trans-unit>
        <trans-unit id="eded6790141cbbb141d77bfcf5fc351397828538" translate="yes" xml:space="preserve">
          <source>Use the specified name for the initial branch in the newly created repository. If not specified, fall back to the default name: &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">새로 생성 된 저장소의 초기 브랜치에 지정된 이름을 사용합니다. 지정되지 않은 경우 기본 이름 인 &lt;code&gt;master&lt;/code&gt; 로 돌아가십시오 .</target>
        </trans-unit>
        <trans-unit id="9e057e9e47493412f91dea4102ac0984cb71bdeb" translate="yes" xml:space="preserve">
          <source>Use the value of the &lt;code&gt;core.whitespace&lt;/code&gt; configuration variable to decide what to notice as error.</source>
          <target state="translated">&lt;code&gt;core.whitespace&lt;/code&gt; 구성 변수 의 값을 사용하여 오류로 주목할 사항을 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="810f8c03feb9550dd6740190f543dbb37624e241" translate="yes" xml:space="preserve">
          <source>Use this custom program instead of &quot;&lt;code&gt;gpg&lt;/code&gt;&quot; found on &lt;code&gt;$PATH&lt;/code&gt; when making or verifying a PGP signature. The program must support the same command-line interface as GPG, namely, to verify a detached signature, &quot;&lt;code&gt;gpg --verify $signature - &amp;lt;$file&lt;/code&gt;&quot; is run, and the program is expected to signal a good signature by exiting with code 0, and to generate an ASCII-armored detached signature, the standard input of &quot;&lt;code&gt;gpg -bsau $key&lt;/code&gt;&quot; is fed with the contents to be signed, and the program is expected to send the result to its standard output.</source>
          <target state="translated">PGP 서명을 만들거나 확인할 때 &lt;code&gt;$PATH&lt;/code&gt; 에있는 &quot; &lt;code&gt;gpg&lt;/code&gt; &quot; 대신이 사용자 지정 프로그램을 사용하십시오 . 프로그램은 분리 된 서명 &quot; &lt;code&gt;gpg --verify $signature - &amp;lt;$file&lt;/code&gt; &quot;이 실행 되는지 확인하기 위해 GPG와 동일한 명령 행 인터페이스를 지원해야 하며 프로그램은 코드로 종료하여 올바른 서명을 신호해야합니다 0으로 ASCII-armored 분리 된 서명을 생성하기 위해 &quot; &lt;code&gt;gpg -bsau $key&lt;/code&gt; &quot; 의 표준 입력에 서명 할 내용이 제공되며 프로그램은 결과를 표준 출력으로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="a644dabd3c4c5e288aecaab3da05ddb8c7da086c" translate="yes" xml:space="preserve">
          <source>Use this for compatibility with old-style branch names used by earlier versions of &lt;code&gt;git archimport&lt;/code&gt;. Old-style branch names were category--branch, whereas new-style branch names are archive,category--branch--version. In both cases, names given on the command-line will override the automatically-generated ones.</source>
          <target state="translated">이전 버전의 &lt;code&gt;git archimport&lt;/code&gt; 에서 사용 된 이전 스타일 브랜치 이름과의 호환성을 위해 이것을 사용하십시오 . 이전 스타일 브랜치 이름은 카테고리-브랜치 인 반면 새 스타일 브랜치 이름은 아카이브, 카테고리-브랜치-버전입니다. 두 경우 모두 명령 줄에 지정된 이름이 자동으로 생성 된 이름보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="ad85fb495e355ea9ee99bf9caef60d6a5acc4df9" translate="yes" xml:space="preserve">
          <source>Use this for compatibility with old-style branch names used by earlier versions of &lt;code&gt;git archimport&lt;/code&gt;. Old-style branch names were category{litdd}branch, whereas new-style branch names are archive,category{litdd}branch{litdd}version. In both cases, names given on the command-line will override the automatically-generated ones.</source>
          <target state="translated">이전 버전의 &lt;code&gt;git archimport&lt;/code&gt; 에서 사용하는 구식 분기 이름과의 호환성을 위해 이것을 사용하십시오 . 구식 지사 이름은 category {litdd} 지점 인 반면, 새 스타일 지사 이름은 archive, category {litdd} 지점 {litdd} 버전입니다. 두 경우 모두 명령 줄에 지정된 이름은 자동으로 생성 된 이름보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="f09efb8456c99114df5272977533145bfda3715e" translate="yes" xml:space="preserve">
          <source>Use this option to integrate changes from the upstream subproject with your submodule&amp;rsquo;s current HEAD. Alternatively, you can run &lt;code&gt;git pull&lt;/code&gt; from the submodule, which is equivalent except for the remote branch name: &lt;code&gt;update --remote&lt;/code&gt; uses the default upstream repository and &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt;, while &lt;code&gt;git pull&lt;/code&gt; uses the submodule&amp;rsquo;s &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;. Prefer &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; if you want to distribute the default upstream branch with the superproject and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; if you want a more native feel while working in the submodule itself.</source>
          <target state="translated">업스트림 서브 프로젝트의 변경 사항을 서브 모듈의 현재 HEAD와 통합하려면이 옵션을 사용하십시오. 양자 택일로, 당신은 실행할 수 있습니다 &lt;code&gt;git pull&lt;/code&gt; 원격 지점 이름을 제외하고 동일합니다 서브 모듈에서 : &lt;code&gt;update --remote&lt;/code&gt; 사용하는 기본 업스트림 저장소와 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; , 동안 &lt;code&gt;git pull&lt;/code&gt; 서브 모듈의 사용 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; . 선호 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; 당신이 superproject와 함께 기본 상류 지점을 배포 할 경우 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 서브 모듈 자체에서 작업하는 동안 좀 더 네이티브 느낌을 원하는 경우.</target>
        </trans-unit>
        <trans-unit id="205f9bc458a5cacd665ee1af1eac8a989bc13811" translate="yes" xml:space="preserve">
          <source>Use this option to set the namespace where the original commits will be stored. The default value is &lt;code&gt;refs/original&lt;/code&gt;.</source>
          <target state="translated">원래 커밋이 저장 될 네임 스페이스를 설정하려면이 옵션을 사용하십시오. 기본값은 &lt;code&gt;refs/original&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="978a87da673ee3d6baf57006a070d2ceaf2e0a29" translate="yes" xml:space="preserve">
          <source>Use this option to set the path to the temporary directory used for rewriting. When applying a tree filter, the command needs to temporarily check out the tree to some directory, which may consume considerable space in case of large projects. By default it does this in the &lt;code&gt;.git-rewrite/&lt;/code&gt; directory but you can override that choice by this parameter.</source>
          <target state="translated">다시 쓰기에 사용되는 임시 디렉토리의 경로를 설정하려면이 옵션을 사용하십시오. 트리 필터를 적용 할 때 명령은 트리를 일부 디렉토리로 일시적으로 체크 아웃해야하므로 대규모 프로젝트의 경우 상당한 공간을 소비 할 수 있습니다. 기본적으로 &lt;code&gt;.git-rewrite/&lt;/code&gt; 디렉토리에서이를 수행하지만이 매개 변수로 해당 선택을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dad6966beac366ffc5d985e757265d090b93f5a" translate="yes" xml:space="preserve">
          <source>Use this option to unstage and remove paths only from the index. Working tree files, whether modified or not, will be left alone.</source>
          <target state="translated">인덱스에서만 경로를 스테이지 해제하고 제거하려면이 옵션을 사용하십시오. 작업 트리 파일은 수정 여부에 관계없이 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="22e3468b42fc7b02294ecbf3cdd521f378eedf7b" translate="yes" xml:space="preserve">
          <source>Use this to customize the program used for the signing format you chose. (see &lt;code&gt;gpg.program&lt;/code&gt; and &lt;code&gt;gpg.format&lt;/code&gt;) &lt;code&gt;gpg.program&lt;/code&gt; can still be used as a legacy synonym for &lt;code&gt;gpg.openpgp.program&lt;/code&gt;. The default value for &lt;code&gt;gpg.x509.program&lt;/code&gt; is &quot;gpgsm&quot;.</source>
          <target state="translated">이를 사용하여 선택한 서명 형식에 사용되는 프로그램을 사용자 정의하십시오. (참조 &lt;code&gt;gpg.program&lt;/code&gt; 및 &lt;code&gt;gpg.format&lt;/code&gt; 를 ) &lt;code&gt;gpg.program&lt;/code&gt; 는 여전히위한 기존의 동의어로 사용할 수 있습니다 &lt;code&gt;gpg.openpgp.program&lt;/code&gt; . &lt;code&gt;gpg.x509.program&lt;/code&gt; 의 기본값 은 &quot;gpgsm&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="2c0ec0febb1ffdfb71fd1faf1bdd4ef5cebdb7eb" translate="yes" xml:space="preserve">
          <source>Use this to specify the path to &lt;code&gt;git-upload-pack&lt;/code&gt; on the remote side, if is not found on your $PATH. Installations of sshd ignores the user&amp;rsquo;s environment setup scripts for login shells (e.g. .bash_profile) and your privately installed git may not be found on the system default $PATH. Another workaround suggested is to set up your $PATH in &quot;.bashrc&quot;, but this flag is for people who do not want to pay the overhead for non-interactive shells by having a lean .bashrc file (they set most of the things up in .bash_profile).</source>
          <target state="translated">$ PATH에 없으면 원격 측에서 &lt;code&gt;git-upload-pack&lt;/code&gt; 의 경로를 지정하려면 이것을 사용하십시오 . sshd를 설치하면 로그인 셸에 대한 사용자 환경 설정 스크립트 (예 : .bash_profile)가 무시되고 개인적으로 설치된 git이 시스템 기본 $ PATH에 없을 수 있습니다. 제안 된 또 다른 해결 방법은 &quot;.bashrc&quot;에 $ PATH를 설정하는 것이지만이 플래그는 .bashrc 파일을 기울여서 비 대화식 쉘의 오버 헤드를 지불하지 않으려는 사람들을위한 것입니다. .bash_profile에서).</target>
        </trans-unit>
        <trans-unit id="1f3cdffd9311e81ebd0ee41b41de344f546bb6a2" translate="yes" xml:space="preserve">
          <source>Used DBI driver. You can specify any available driver for this here, but it might not work. cvsserver is tested with &lt;code&gt;DBD::SQLite&lt;/code&gt;, reported to work with &lt;code&gt;DBD::Pg&lt;/code&gt;, and reported &lt;strong&gt;not&lt;/strong&gt; to work with &lt;code&gt;DBD::mysql&lt;/code&gt;. Please regard this as an experimental feature. May not contain colons (&lt;code&gt;:&lt;/code&gt;). Default: &lt;code&gt;SQLite&lt;/code&gt;</source>
          <target state="translated">사용 된 DBI 드라이버. 여기에 사용 가능한 드라이버를 지정할 수 있지만 작동하지 않을 수 있습니다. cvsserver는 &lt;code&gt;DBD::SQLite&lt;/code&gt; 로 테스트되었으며 DBD :: &lt;code&gt;DBD::Pg&lt;/code&gt; 와 함께 작동하는 것으로보고 되었으며 &lt;code&gt;DBD::mysql&lt;/code&gt; 과는 작동 &lt;strong&gt;하지 않는&lt;/strong&gt; 것으로보고 되었습니다 . 이것을 실험적인 기능으로 생각하십시오. 콜론이 포함되어 있지 않을 수도 있습니다 ( &lt;code&gt;:&lt;/code&gt; ). 디폴트 : &lt;code&gt;SQLite&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e96c8aa1d6db1322edc422d5cc1ffbd12e71daed" translate="yes" xml:space="preserve">
          <source>Used Perl DBI driver. You can specify any available driver for this here, but it might not work. git-cvsserver is tested with &lt;code&gt;DBD::SQLite&lt;/code&gt;, reported to work with &lt;code&gt;DBD::Pg&lt;/code&gt;, and reported &lt;strong&gt;not&lt;/strong&gt; to work with &lt;code&gt;DBD::mysql&lt;/code&gt;. Experimental feature. May not contain double colons (&lt;code&gt;:&lt;/code&gt;). Default: &lt;code&gt;SQLite&lt;/code&gt;. See &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;.</source>
          <target state="translated">Perl DBI 드라이버를 사용했습니다. 여기에 사용 가능한 드라이버를 지정할 수 있지만 작동하지 않을 수 있습니다. git-cvsserver는 &lt;code&gt;DBD::SQLite&lt;/code&gt; 로 테스트되었으며 DBD &lt;code&gt;DBD::Pg&lt;/code&gt; 와 함께 작동하는 것으로보고 되었으며 &lt;code&gt;DBD::mysql&lt;/code&gt; 과는 작동 &lt;strong&gt;하지 않는&lt;/strong&gt; 것으로보고 되었습니다 . 실험적인 특징. 이중 콜론이 포함되어 있지 않을 수도 있습니다 ( &lt;code&gt;:&lt;/code&gt; ). 기본 : &lt;code&gt;SQLite&lt;/code&gt; 는 . &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3dcc5e110a8886980641614ba00244bbf70eb3c6" translate="yes" xml:space="preserve">
          <source>Used as %(if)&amp;hellip;​%(then)&amp;hellip;​%(end) or %(if)&amp;hellip;​%(then)&amp;hellip;​%(else)&amp;hellip;​%(end). If there is an atom with value or string literal after the %(if) then everything after the %(then) is printed, else if the %(else) atom is used, then everything after %(else) is printed. We ignore space when evaluating the string before %(then), this is useful when we use the %(HEAD) atom which prints either &quot;*&quot; or &quot; &quot; and we want to apply the &lt;code&gt;if&lt;/code&gt; condition only on the &lt;code&gt;HEAD&lt;/code&gt; ref. Append &quot;:equals=&amp;lt;string&amp;gt;&quot; or &quot;:notequals=&amp;lt;string&amp;gt;&quot; to compare the value between the %(if:&amp;hellip;​) and %(then) atoms with the given string.</source>
          <target state="translated">% (if)&amp;hellip; % (then)&amp;hellip; % (end) 또는 % (if)&amp;hellip; % (then)&amp;hellip; % (else)&amp;hellip; % (end)로 사용됩니다. % (if) 뒤에 값 또는 문자열 리터럴이있는 원자가있는 경우 % (then) 뒤의 모든 것이 인쇄되고, 그렇지 않으면 % (else) 원자가 사용되면 % (else) 뒤의 모든 것이 인쇄됩니다. % (then) 이전의 문자열을 평가할 때 공간을 무시합니다. 이는 &quot;*&quot;또는 &quot;&quot;를 인쇄하는 % (HEAD) 원자를 사용할 때 유용 하며 &lt;code&gt;HEAD&lt;/code&gt; 참조 에만 &lt;code&gt;if&lt;/code&gt; 조건 을 적용하려고합니다 . &quot;: equals = &amp;lt;string&amp;gt;&quot;또는 &quot;: notequals = &amp;lt;string&amp;gt;&quot;을 추가하여 주어진 문자열과 % (if :&amp;hellip;) 및 % (then) 원자 사이의 값을 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="88972a7007de9e429d28d6bad7487052b23f9b65" translate="yes" xml:space="preserve">
          <source>Used to check that a bundle file is valid and will apply cleanly to the current repository. This includes checks on the bundle format itself as well as checking that the prerequisite commits exist and are fully linked in the current repository. &lt;code&gt;git bundle&lt;/code&gt; prints a list of missing commits, if any, and exits with a non-zero status.</source>
          <target state="translated">번들 파일이 유효하고 현재 저장소에 올바르게 적용되는지 확인하는 데 사용됩니다. 여기에는 번들 형식 자체에 대한 점검과 전제 조건 확약이 존재하며 현재 저장소에 완전히 링크되어 있는지 점검하는 것이 포함됩니다. &lt;code&gt;git bundle&lt;/code&gt; 은 누락 된 커밋 목록을 인쇄하고 0이 아닌 상태로 종료합니다.</target>
        </trans-unit>
        <trans-unit id="a81dfbb4b6756f63bb43c72d54c78dd02ef851d4" translate="yes" xml:space="preserve">
          <source>Used to create a bundle named &lt;code&gt;file&lt;/code&gt;. This requires the &lt;code&gt;&amp;lt;git-rev-list-args&amp;gt;&lt;/code&gt; arguments to define the bundle contents. &lt;code&gt;options&lt;/code&gt; contains the options specific to the &lt;code&gt;git bundle create&lt;/code&gt; subcommand.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 이라는 번들을 작성하는 데 사용 됩니다 . 번들 내용을 정의 하려면 &lt;code&gt;&amp;lt;git-rev-list-args&amp;gt;&lt;/code&gt; 인수가 필요합니다. &lt;code&gt;options&lt;/code&gt; 에는 &lt;code&gt;git bundle create&lt;/code&gt; 하위 명령과 관련된 옵션이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe127bac2ab0b61ffb60c0284f3741224c9951e1" translate="yes" xml:space="preserve">
          <source>Used to enforce or disable certificate revocation checks in cURL when http.sslBackend is set to &quot;schannel&quot;. Defaults to &lt;code&gt;true&lt;/code&gt; if unset. Only necessary to disable this if Git consistently errors and the message is about checking the revocation status of a certificate. This option is ignored if cURL lacks support for setting the relevant SSL option at runtime.</source>
          <target state="translated">http.sslBackend가 &quot;schannel&quot;로 설정된 경우 cURL에서 인증서 해지 확인을 시행 또는 비활성화하는 데 사용됩니다. 설정하지 않으면 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. Git에서 지속적으로 오류가 발생하고 메시지가 인증서의 해지 상태를 확인하는 것에 관한 경우에만이를 비활성화해야합니다. cURL에 런타임시 관련 SSL 옵션 설정 지원이 부족한 경우이 옵션은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="526891fe0801e3a16c20e50ecde492e75d4f6490" translate="yes" xml:space="preserve">
          <source>Used to set the maximum load that we will still respond to gitweb queries. If the server load exceeds this value then gitweb will return &quot;503 Service Unavailable&quot; error. The server load is taken to be 0 if gitweb cannot determine its value. Currently it works only on Linux, where it uses &lt;code&gt;/proc/loadavg&lt;/code&gt;; the load there is the number of active tasks on the system &amp;mdash; processes that are actually running &amp;mdash; averaged over the last minute.</source>
          <target state="translated">여전히 gitweb 쿼리에 응답 할 최대로드를 설정하는 데 사용됩니다. 서버로드가이 값을 초과하면 gitweb은 &quot;503 Service Unavailable&quot;오류를 반환합니다. gitweb이 그 값을 결정할 수 없으면 서버로드는 0이됩니다. 현재는 &lt;code&gt;/proc/loadavg&lt;/code&gt; 를 사용하는 Linux에서만 작동합니다 . 시스템에서 수행중인 작업 (실제로 실행중인 프로세스)의 수는 마지막 1 분 동안 평균입니다.</target>
        </trans-unit>
        <trans-unit id="184dba4369820f49a823e624aa006f74d3fc96ef" translate="yes" xml:space="preserve">
          <source>Used with --remote to specify the path to the &lt;code&gt;git-upload-archive&lt;/code&gt; on the remote side.</source>
          <target state="translated">원격 에서 &lt;code&gt;git-upload-archive&lt;/code&gt; 의 경로를 지정하기 위해 --remote와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a985abb59dca2d23760f5b7ff00e7d00f2d0f353" translate="yes" xml:space="preserve">
          <source>Used with &lt;code&gt;--range-diff&lt;/code&gt;, tweak the heuristic which matches up commits between the previous and current series of patches by adjusting the creation/deletion cost fudge factor. See &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff[1]&lt;/a&gt;) for details.</source>
          <target state="translated">&lt;code&gt;--range-diff&lt;/code&gt; 와 함께 사용 하면 생성 / 삭제 비용 퍼지 팩터를 조정하여 이전 및 현재 일련의 패치 사이의 커밋을 일치시키는 휴리스틱을 조정합니다. 자세한 내용은 &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff [1]&lt;/a&gt; )를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9777df5e2d0f3ca27a559e53074b9f39896040e8" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;fetch&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 명령 과 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ea99fa3d480e34606197cb808cc4a18c1d6b1306" translate="yes" xml:space="preserve">
          <source>User Manual</source>
          <target state="translated">사용자 매뉴얼</target>
        </trans-unit>
        <trans-unit id="3d338fa6790366b9708dc60a5019a8d98f73c4b3" translate="yes" xml:space="preserve">
          <source>User configuration and preferences are stored at:</source>
          <target state="translated">사용자 구성 및 환경 설정은 다음 위치에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="ba3e3bfcde6395de2671f768450f02d32f692aba" translate="yes" xml:space="preserve">
          <source>User name (e.g., &lt;code&gt;user&lt;/code&gt; in &lt;code&gt;https://user@example.com/repo.git&lt;/code&gt;). If the config key has a user name it must match the user name in the URL exactly. If the config key does not have a user name, that config key will match a URL with any user name (including none), but at a lower precedence than a config key with a user name.</source>
          <target state="translated">사용자 이름 (예를 들어, &lt;code&gt;user&lt;/code&gt; 의 &lt;code&gt;https://user@example.com/repo.git&lt;/code&gt; ). 구성 키에 사용자 이름이 있으면 URL의 사용자 이름과 정확히 일치해야합니다. 구성 키에 사용자 이름이없는 경우 해당 구성 키는 사용자 이름이있는 URL (없음 포함)과 일치하지만 사용자 이름이있는 구성 키보다 우선 순위가 낮습니다.</target>
        </trans-unit>
        <trans-unit id="9eabd3862d3bc88b6d20553afdc4c28a880bd15a" translate="yes" xml:space="preserve">
          <source>User specified as an option to all p4 commands, with &lt;code&gt;-u &amp;lt;user&amp;gt;&lt;/code&gt;. The environment variable &lt;code&gt;P4USER&lt;/code&gt; can be used instead.</source>
          <target state="translated">&lt;code&gt;-u &amp;lt;user&amp;gt;&lt;/code&gt; 와 함께 모든 p4 명령에 대한 옵션으로 사용자가 지정되었습니다 . 환경 변수 &lt;code&gt;P4USER&lt;/code&gt; 를 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3129c28f60cb352aa378d9055c2dee4b71cd917d" translate="yes" xml:space="preserve">
          <source>User-specific configuration file. Also called &quot;global&quot; configuration file.</source>
          <target state="translated">사용자 별 구성 파일 &quot;글로벌&quot;구성 파일이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="53b3f2b51348a1a5a4076e004425d0d150df3f8e" translate="yes" xml:space="preserve">
          <source>User-specific credentials file.</source>
          <target state="translated">사용자 별 자격 증명 파일.</target>
        </trans-unit>
        <trans-unit id="fbb3c5af6a1b800cb6bfa442ae5c6ae5ee1a4454" translate="yes" xml:space="preserve">
          <source>Username for SMTP-AUTH. Default is the value of &lt;code&gt;sendemail.smtpUser&lt;/code&gt;; if a username is not specified (with &lt;code&gt;--smtp-user&lt;/code&gt; or &lt;code&gt;sendemail.smtpUser&lt;/code&gt;), then authentication is not attempted.</source>
          <target state="translated">SMTP-AUTH의 사용자 이름 기본값은 &lt;code&gt;sendemail.smtpUser&lt;/code&gt; 의 값입니다 . &lt;code&gt;--smtp-user&lt;/code&gt; 또는 &lt;code&gt;sendemail.smtpUser&lt;/code&gt; 로 사용자 이름을 지정 하지 않으면 인증을 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="74498c0e6117d06ee988164e48dd06849a2a00fa" translate="yes" xml:space="preserve">
          <source>Users may find some cases where scheduled maintenance tasks do not run as frequently as intended. Each &lt;code&gt;git maintenance run&lt;/code&gt; command takes a lock on the repository&amp;rsquo;s object database, and this prevents other concurrent &lt;code&gt;git maintenance run&lt;/code&gt; commands from running on the same repository. Without this safeguard, competing processes could leave the repository in an unpredictable state.</source>
          <target state="translated">사용자는 예약 된 유지 관리 작업이 의도 한만큼 자주 실행되지 않는 경우를 발견 할 수 있습니다. 각 &lt;code&gt;git maintenance run&lt;/code&gt; 명령은 리포지토리의 개체 데이터베이스를 잠그므로 다른 동시 &lt;code&gt;git maintenance run&lt;/code&gt; 명령이 동일한 저장소에서 실행되는 것을 방지 합니다. 이러한 보호 장치가 없으면 경쟁 프로세스가 저장소를 예측할 수없는 상태로 남겨 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd5ba62269befa999225c8d360ebd4fd64f50001" translate="yes" xml:space="preserve">
          <source>Users may select an automated merge strategy from among the following using either -s/--strategy option or configuring notes.mergeStrategy accordingly:</source>
          <target state="translated">사용자는 -s /-strategy 옵션을 사용하거나 이에 따라 notes.mergeStrategy를 사용하여 다음 중에서 자동 병합 전략을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="312954bd3f459a8154fbfda7b5edb71c57c929c2" translate="yes" xml:space="preserve">
          <source>Users migrating from CVS may also want to read &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">CVS에서 마이그레이션하는 사용자는 &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt; 을 읽을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bdfc1b01541d0790675419ccbb86b2582c7e882c" translate="yes" xml:space="preserve">
          <source>Users often try to use the assume-unchanged and skip-worktree bits to tell Git to ignore changes to files that are tracked. This does not work as expected, since Git may still check working tree files against the index when performing certain operations. In general, Git does not provide a way to ignore changes to tracked files, so alternate solutions are recommended.</source>
          <target state="translated">사용자는 종종 변경되지 않은 가정 및 워크 트리 건너 뛰기 비트를 사용하여 추적되는 파일의 변경 사항을 무시하도록 Git에 지시합니다. Git은 특정 작업을 수행 할 때 인덱스에 대해 작업 트리 파일을 계속 확인할 수 있으므로 예상대로 작동하지 않습니다. 일반적으로 Git은 추적 된 파일의 변경 사항을 무시하는 방법을 제공하지 않으므로 대체 솔루션이 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="d2fd200f233551c846ddc52433b7473972ba45cd" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;assume unchanged&amp;rdquo; bit</source>
          <target state="translated">&quot;변경되지 않은 가정&quot;비트 사용</target>
        </trans-unit>
        <trans-unit id="db59534f65c86c428a7a540c110ff1130d39acfc" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;git add -A&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;git add -A&amp;rdquo;사용</target>
        </trans-unit>
        <trans-unit id="3f756864c1cac8254338a14f16b7888b4cd11774" translate="yes" xml:space="preserve">
          <source>Using &amp;ldquo;git commit -a&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;git commit -a&amp;rdquo;사용</target>
        </trans-unit>
        <trans-unit id="1ad6e2bdca2ef33d6f60d1165c40af77488df73e" translate="yes" xml:space="preserve">
          <source>Using --cacheinfo or --info-only</source>
          <target state="translated">--cacheinfo 또는 --info-only 사용</target>
        </trans-unit>
        <trans-unit id="63a49bc3316ec7fe7ab1c50a106ab3c187422a12" translate="yes" xml:space="preserve">
          <source>Using --index-info</source>
          <target state="translated">--index-info 사용</target>
        </trans-unit>
        <trans-unit id="9465002aca9e596e405478c595d6ec82ecf19f4d" translate="yes" xml:space="preserve">
          <source>Using --recurse-submodules can only fetch new commits in already checked out submodules right now. When e.g. upstream added a new submodule in the just fetched commits of the superproject the submodule itself cannot be fetched, making it impossible to check out that submodule later without having to do a fetch again. This is expected to be fixed in a future Git version.</source>
          <target state="translated">--recurse-submodules를 사용하면 이미 체크 아웃 된 하위 모듈에서만 새 커밋을 가져올 수 있습니다. 예를 들어 업스트림이 수퍼 프로젝트의 페치 된 커밋에 새로운 서브 모듈을 추가했을 때 서브 모듈 자체를 페치 할 수 없으므로 나중에 페치를 다시 수행 할 필요없이 서브 모듈을 체크 아웃 할 수 없습니다. 향후 Git 버전에서 수정 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="9ba2b3bf5dd0ae3395bffc9a6bf30c85dfb19a1b" translate="yes" xml:space="preserve">
          <source>Using --recurse-submodules will update the content of all active submodules according to the commit recorded in the superproject by calling read-tree recursively, also setting the submodules' HEAD to be detached at that commit.</source>
          <target state="translated">--recurse-submodules를 사용하면 read-tree를 재귀 적으로 호출하여 수퍼 프로젝트에 기록 된 커밋에 따라 모든 활성 서브 모듈의 내용을 업데이트하고 해당 커밋에서 분리되도록 서브 모듈의 HEAD를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="3b6c4766d3d128d670a5d5adf42fc526da676a66" translate="yes" xml:space="preserve">
          <source>Using --recurse-submodules will update the content of all initialized submodules according to the commit recorded in the superproject by calling read-tree recursively, also setting the submodules HEAD to be detached at that commit.</source>
          <target state="translated">--recurse-submodules를 사용하면 읽기 트리를 재귀 적으로 호출하여 수퍼 프로젝트에 기록 된 커밋에 따라 초기화 된 모든 하위 모듈의 내용을 업데이트하고 해당 커밋에서 하위 모듈 HEAD를 분리하도록 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8315f077dd8f5ad49468aff013d2df68acafcb5e" translate="yes" xml:space="preserve">
          <source>Using --refresh</source>
          <target state="translated">--refresh 사용</target>
        </trans-unit>
        <trans-unit id="0565ce691b52b5953c2fb97dfb806a2f764f48e2" translate="yes" xml:space="preserve">
          <source>Using --temp or --stage=all</source>
          <target state="translated">--temp 또는 --stage = all 사용</target>
        </trans-unit>
        <trans-unit id="509888a40362653e71adbbdc6d4e59bc0d3d4ce4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--index-filter&lt;/code&gt; with &lt;code&gt;git rm&lt;/code&gt; yields a significantly faster version. Like with using &lt;code&gt;rm filename&lt;/code&gt;, &lt;code&gt;git rm --cached filename&lt;/code&gt; will fail if the file is absent from the tree of a commit. If you want to &quot;completely forget&quot; a file, it does not matter when it entered history, so we also add &lt;code&gt;--ignore-unmatch&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;git rm&lt;/code&gt; 과 함께 &lt;code&gt;--index-filter&lt;/code&gt; 를 사용하면 버전이 훨씬 빨라집니다. 사용과 같이 &lt;code&gt;rm filename&lt;/code&gt; , &lt;code&gt;git rm --cached filename&lt;/code&gt; 파일이 커밋의 트리에서 존재하지 않는 경우 실패합니다. 파일을 &quot;완전히 잊어 버리려면&quot;파일이 언제 기록되는지는 중요하지 않으므로 &lt;code&gt;--ignore-unmatch&lt;/code&gt; 도 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="802dbfe4495f98c59f087035f936edebe365e8d7" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all active submodules according to the commit recorded in the superproject. If local modifications in a submodule would be overwritten the checkout will fail unless &lt;code&gt;-f&lt;/code&gt; is used. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, submodules working trees will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodule.</source>
          <target state="translated">&lt;code&gt;--recurse-submodules&lt;/code&gt; 를 사용 하면 수퍼 프로젝트에 기록 된 커밋에 따라 모든 활성 하위 모듈의 내용이 업데이트됩니다. 하위 모듈의 로컬 수정 사항을 덮어 쓰면 &lt;code&gt;-f&lt;/code&gt; 를 사용 하지 않으면 체크 아웃이 실패 합니다. 아무것도 사용하지 않으면 (또는 &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ), 하위 모듈 작업 트리가 업데이트되지 않습니다. &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt; 처럼 서브 모듈의 &lt;code&gt;HEAD&lt;/code&gt; 를 분리 합니다.</target>
        </trans-unit>
        <trans-unit id="bf5da0d2a32c5b7048069200ef431cff7653b1d4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all active submodules according to the commit recorded in the superproject. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, submodules working trees will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodules.</source>
          <target state="translated">&lt;code&gt;--recurse-submodules&lt;/code&gt; 를 사용 하면 수퍼 프로젝트에 기록 된 커밋에 따라 모든 활성 하위 모듈의 내용이 업데이트됩니다. 아무것도 사용하지 않으면 (또는 &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ), 하위 모듈 작업 트리가 업데이트되지 않습니다. &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt; 처럼 서브 모듈의 &lt;code&gt;HEAD&lt;/code&gt; 를 분리 합니다.</target>
        </trans-unit>
        <trans-unit id="47e7ecf39552b28db7a0c771cb5239db7d4a81af" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all initialized submodules according to the commit recorded in the superproject. If local modifications in a submodule would be overwritten the checkout will fail unless &lt;code&gt;-f&lt;/code&gt; is used. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, the work trees of submodules will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodule.</source>
          <target state="translated">&lt;code&gt;--recurse-submodules&lt;/code&gt; 를 사용 하면 수퍼 프로젝트에 기록 된 커밋에 따라 초기화 된 모든 하위 모듈의 내용이 업데이트됩니다. 서브 모듈의 로컬 수정 사항을 겹쳐 쓰면 &lt;code&gt;-f&lt;/code&gt; 를 사용 하지 않으면 체크 아웃에 실패 합니다. 아무것도 사용하지 않으면 (또는 &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ) 하위 모듈 의 작업 트리가 업데이트되지 않습니다. 마찬가지로 &lt;a href=&quot;git-submodule&quot;&gt;자식 - 서브 모듈 [1]&lt;/a&gt; , 이는 분리한다 &lt;code&gt;HEAD&lt;/code&gt; 서브 모듈의이.</target>
        </trans-unit>
        <trans-unit id="87e05fa35b92ebd2beac592a4000f99e52c8fa99" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--recurse-submodules&lt;/code&gt; will update the content of all initialized submodules according to the commit recorded in the superproject. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, the work trees of submodules will not be updated. Just like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodules.</source>
          <target state="translated">&lt;code&gt;--recurse-submodules&lt;/code&gt; 를 사용 하면 수퍼 프로젝트에 기록 된 커밋에 따라 초기화 된 모든 하위 모듈의 내용이 업데이트됩니다. 아무것도 사용하지 않으면 (또는 &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ) 하위 모듈 의 작업 트리가 업데이트되지 않습니다. 마찬가지로 &lt;a href=&quot;git-submodule&quot;&gt;자식 - 서브 모듈 [1]&lt;/a&gt; , 이는 분리한다 &lt;code&gt;HEAD&lt;/code&gt; 서브 모듈의이.</target>
        </trans-unit>
        <trans-unit id="131907fc18369579f75831dbffd3a45262caaa68" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-a&lt;/code&gt; would conflate &amp;lt;remote&amp;gt; with any local branches you happen to have been prefixed with the same &amp;lt;remote&amp;gt; pattern.</source>
          <target state="translated">&lt;code&gt;-a&lt;/code&gt; 를 사용하면 &amp;lt;remote&amp;gt;와 접두사가 같은 로컬 분기와 &amp;lt;remote&amp;gt;가 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="bc196497d8f80228e3ec0969c92ba077224b9158" translate="yes" xml:space="preserve">
          <source>Using &lt;em&gt;git checkout-index&lt;/em&gt; to &quot;export an entire tree&quot;</source>
          <target state="translated">&lt;em&gt;git checkout-index&lt;/em&gt; 를 사용 하여 &quot;전체 트리 내보내기&quot;</target>
        </trans-unit>
        <trans-unit id="bb5a1594f36aa9f526f3a0391e9aecb18bcb1ed6" translate="yes" xml:space="preserve">
          <source>Using Gmail&amp;rsquo;s IMAP interface:</source>
          <target state="translated">Gmail의 IMAP 인터페이스 사용 :</target>
        </trans-unit>
        <trans-unit id="f145740948f023493614f8cb28fc352a33b08d80" translate="yes" xml:space="preserve">
          <source>Using a limit</source>
          <target state="translated">한도 사용</target>
        </trans-unit>
        <trans-unit id="0d18e7415acaf5bf1693b96116e4340271619597" translate="yes" xml:space="preserve">
          <source>Using another project while maintaining independent history. Submodules allow you to contain the working tree of another project within your own working tree while keeping the history of both projects separate. Also, since submodules are fixed to an arbitrary version, the other project can be independently developed without affecting the superproject, allowing the superproject project to fix itself to new versions only when desired.</source>
          <target state="translated">독립 이력을 유지하면서 다른 프로젝트를 사용합니다. 서브 모듈을 사용하면 자신의 작업 트리 내에 다른 프로젝트의 작업 트리를 포함시키면서 두 프로젝트의 기록을 별도로 유지할 수 있습니다. 또한, 서브 모듈은 임의의 버전으로 고정되어 있기 때문에, 다른 프로젝트는 수퍼 프로젝트에 영향을주지 않고 독립적으로 개발 될 수 있으며, 수퍼 프로젝트 프로젝트는 원하는 경우에만 새 버전으로 고정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03266ad998c58f3651e774794904a59499884e04" translate="yes" xml:space="preserve">
          <source>Using complex scripts</source>
          <target state="translated">복잡한 스크립트 사용</target>
        </trans-unit>
        <trans-unit id="9a4e17fa716627d801ba04248e7c13675c63f6bf" translate="yes" xml:space="preserve">
          <source>Using direct mode with SSL:</source>
          <target state="translated">SSL과 함께 직접 모드 사용 :</target>
        </trans-unit>
        <trans-unit id="80be60b71aa62e009a5472e7b71ecca69fb605f2" translate="yes" xml:space="preserve">
          <source>Using direct mode:</source>
          <target state="translated">직접 모드 사용 :</target>
        </trans-unit>
        <trans-unit id="1c1bc19943239ea53498134ee5024657c6f7482f" translate="yes" xml:space="preserve">
          <source>Using git for collaboration</source>
          <target state="translated">협업을 위해 git 사용</target>
        </trans-unit>
        <trans-unit id="e742dd237e897f0c09d1168ed38eeca1316d409b" translate="yes" xml:space="preserve">
          <source>Using interactive rebases</source>
          <target state="translated">대화식 리베이스 사용</target>
        </trans-unit>
        <trans-unit id="16c9cb76d4ea0981714eee54828fc3305174e2d5" translate="yes" xml:space="preserve">
          <source>Using macro attributes</source>
          <target state="translated">매크로 속성 사용</target>
        </trans-unit>
        <trans-unit id="0bcad514939a1a512d30defc1dd83a6988408bd1" translate="yes" xml:space="preserve">
          <source>Using more options generally further limits the output (e.g. &lt;code&gt;--since=&amp;lt;date1&amp;gt;&lt;/code&gt; limits to commits newer than &lt;code&gt;&amp;lt;date1&amp;gt;&lt;/code&gt;, and using it with &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; further limits to commits whose log message has a line that matches &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;), unless otherwise noted.</source>
          <target state="translated">일반적으로 상기 기준 출력 (예를 들면 더 많은 옵션을 사용 &lt;code&gt;--since=&amp;lt;date1&amp;gt;&lt;/code&gt; 보다 최신 커밋에 제한 &lt;code&gt;&amp;lt;date1&amp;gt;&lt;/code&gt; 과 함께 사용 &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; 그 로그 메시지 커밋을 더욱 제한하는 라인과 일치를 갖는 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 달리 명시되지 않는 한 pattern&amp;gt; ).</target>
        </trans-unit>
        <trans-unit id="aab9e25047cbd960c71a3d6743c695a0fbcee99d" translate="yes" xml:space="preserve">
          <source>Using refspecs explicitly:</source>
          <target state="translated">Refspec을 명시 적으로 사용하기 :</target>
        </trans-unit>
        <trans-unit id="e240eb205361a2a50754a2cbbad5230917e3c8f6" translate="yes" xml:space="preserve">
          <source>Using test suites and git bisect together</source>
          <target state="translated">테스트 스위트와 git bisect를 함께 사용</target>
        </trans-unit>
        <trans-unit id="8fdfb0e1e33426ffa586ab6e967bc34118a45d25" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;--submodule=log&lt;/code&gt; option with &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; will provide that information too.</source>
          <target state="translated">&lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 와 함께 &lt;code&gt;--submodule=log&lt;/code&gt; 옵션을 사용하면 해당 정보도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d42f8d8f39d5c1ce54e65e242137998175012054" translate="yes" xml:space="preserve">
          <source>Using these options, &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; will act similar to the more specialized family of commit log tools: &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt;</source>
          <target state="translated">이 옵션을 사용하면 &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt; 은보다 전문화 된 커밋 로그 도구 제품군 인 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; 및 &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]와 유사하게 작동합니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a34d360db274a11502bc402ef7758f2bc5adf11b" translate="yes" xml:space="preserve">
          <source>Using this helper will store your passwords unencrypted on disk, protected only by filesystem permissions. If this is not an acceptable security tradeoff, try &lt;a href=&quot;git-credential-cache&quot;&gt;git-credential-cache[1]&lt;/a&gt;, or find a helper that integrates with secure storage provided by your operating system.</source>
          <target state="translated">이 도우미를 사용하면 암호가 디스크에 암호화되지 않고 파일 시스템 권한으로 만 보호됩니다. 이것이 허용 가능한 보안 상충 관계가 아닌 경우 &lt;a href=&quot;git-credential-cache&quot;&gt;git-credential-cache [1]을&lt;/a&gt; 시도 하거나 운영 체제에서 제공하는 보안 스토리지와 통합되는 헬퍼를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="86d0ca06bdb5a3aacec696a9b10115a302a90ea4" translate="yes" xml:space="preserve">
          <source>Using this hook, it is easy to generate mails describing the updates to the repository. This example script sends one mail message per ref listing the commits pushed to the repository, and logs the push certificates of signed pushes with good signatures to a logger service:</source>
          <target state="translated">이 후크를 사용하면 저장소의 업데이트를 설명하는 메일을 쉽게 생성 할 수 있습니다. 이 예제 스크립트는 ref 당 하나의 메일 메시지를 저장소로 푸시 된 커밋을 나열하고 서명이있는 푸시의 푸시 인증서를 로거 서비스에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="7ae98ad0643543d139a0ccded2d96be6c57e816c" translate="yes" xml:space="preserve">
          <source>Using this option for any other purpose (don&amp;rsquo;t ask) is very strongly discouraged.</source>
          <target state="translated">다른 목적으로 사용하지 않는 것이 좋습니다 (권장하지 않음).</target>
        </trans-unit>
        <trans-unit id="ebe89d9e15d8a582f6b4a48c6c03d60cf9c673f1" translate="yes" xml:space="preserve">
          <source>Using tunnel mode:</source>
          <target state="translated">터널 모드 사용 :</target>
        </trans-unit>
        <trans-unit id="f17a1449e9ed80dcff59f550977b6693d42b10bf" translate="yes" xml:space="preserve">
          <source>Usual 3-way file level merge for text files. Conflicted regions are marked with conflict markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=======&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. The version from your branch appears before the &lt;code&gt;=======&lt;/code&gt; marker, and the version from the merged branch appears after the &lt;code&gt;=======&lt;/code&gt; marker.</source>
          <target state="translated">텍스트 파일에 대한 일반적인 3 방향 파일 수준 병합. 충돌 영역에는 충돌 마커 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;=======&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 가 표시됩니다 . 지점의 버전은 &lt;code&gt;=======&lt;/code&gt; 마커 앞에 나타나고 병합 된 지점의 버전은 &lt;code&gt;=======&lt;/code&gt; 마커 뒤에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="6cb51fab051882aaba81e0715d7acfa80e2ce09c" translate="yes" xml:space="preserve">
          <source>Usually &lt;code&gt;git gc&lt;/code&gt; runs very quickly while providing good disk space utilization and performance. This option will cause &lt;code&gt;git gc&lt;/code&gt; to more aggressively optimize the repository at the expense of taking much more time. The effects of this optimization are mostly persistent. See the &quot;AGGRESSIVE&quot; section below for details.</source>
          <target state="translated">일반적으로 &lt;code&gt;git gc&lt;/code&gt; 는 디스크 공간 활용도 및 성능을 향상시키면서 매우 빠르게 실행됩니다. 이 옵션을 사용하면 &lt;code&gt;git gc&lt;/code&gt; 가 훨씬 더 많은 시간을 소비하면서 저장소를보다 적극적으로 최적화합니다. 이 최적화의 효과는 대부분 영구적입니다. 자세한 내용은 아래의 &quot;AGGRESSIVE&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="da9e2cbf852524ee1edb371514af799c05f82c93" translate="yes" xml:space="preserve">
          <source>Usually a merge requires the index file as well as the files in the working tree to be up to date with the current head commit, in order not to lose local changes. This flag disables the check with the working tree and is meant to be used when creating a merge of trees that are not directly related to the current working tree status into a temporary index file.</source>
          <target state="translated">일반적으로 병합을 수행하면 로컬 변경 사항을 잃지 않도록 작업 트리의 파일과 색인 파일이 현재 헤드 커밋으로 최신 상태 여야합니다. 이 플래그는 작업 트리에서 검사를 비활성화하며 현재 작업 트리 상태와 직접 관련이없는 트리를 임시 인덱스 파일로 병합 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="27214bb5573e76f1f8a1f21396536681c10927d6" translate="yes" xml:space="preserve">
          <source>Usually a three-way merge by &lt;code&gt;git read-tree&lt;/code&gt; resolves the merge for really trivial cases and leaves other cases unresolved in the index, so that porcelains can implement different merge policies. This flag makes the command resolve a few more cases internally:</source>
          <target state="translated">일반적으로 &lt;code&gt;git read-tree&lt;/code&gt; 에 의한 3 방향 병합은 사소한 경우에 대한 병합을 해결하고 색인에서 다른 경우는 해결되지 않은 상태로 두므로 도자기는 다른 병합 정책을 구현할 수 있습니다. 이 플래그는 명령이 내부적으로 몇 가지 경우를 더 해결하도록합니다.</target>
        </trans-unit>
        <trans-unit id="1a018c180f83561166ef04fc1c1b049dd7bef5e3" translate="yes" xml:space="preserve">
          <source>Usually given &quot;&amp;lt;feature&amp;gt;&quot; is configurable via the &lt;code&gt;gitweb.&amp;lt;feature&amp;gt;&lt;/code&gt; config variable in the per-repository Git configuration file.</source>
          <target state="translated">일반적으로 &quot;&amp;lt;feature&amp;gt;&quot;는 저장소 별 Git 구성 파일 의 &lt;code&gt;gitweb.&amp;lt;feature&amp;gt;&lt;/code&gt; 구성 변수를 통해 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06bd62b74600c2b58fc5390378d7102461c2b477" translate="yes" xml:space="preserve">
          <source>Usually it is easier to configure any desired options through your personal &lt;code&gt;.ssh/config&lt;/code&gt; file. Please consult your ssh documentation for further details.</source>
          <target state="translated">일반적으로 개인 &lt;code&gt;.ssh/config&lt;/code&gt; 파일 을 통해 원하는 옵션을 구성하는 것이 더 쉽습니다 . 자세한 내용은 ssh 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e92c22e35ceb9b2c8da5295a992718e30d5c9f60" translate="yes" xml:space="preserve">
          <source>Usually recording a commit that has the exact same tree as its sole parent commit is a mistake, and the command prevents you from making such a commit. This option bypasses the safety, and is primarily for use by foreign SCM interface scripts.</source>
          <target state="translated">일반적으로 유일한 상위 커밋과 정확히 동일한 트리를 가진 커밋을 기록하는 것은 실수이며 명령으로 인해 그러한 커밋을 할 수 없습니다. 이 옵션은 안전을 우회하며 주로 외부 SCM 인터페이스 스크립트에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8ce3f0d516dc2a9d67b8e4ba143055eaf7bab452" translate="yes" xml:space="preserve">
          <source>Usually the command automatically creates a sequence of commits. This flag applies the changes necessary to cherry-pick each named commit to your working tree and the index, without making any commit. In addition, when this option is used, your index does not have to match the HEAD commit. The cherry-pick is done against the beginning state of your index.</source>
          <target state="translated">일반적으로이 명령은 일련의 커밋을 자동으로 만듭니다. 이 플래그는 커밋하지 않고 명명 된 각 커밋을 작업 트리 및 인덱스에 체리 픽 픽킹하는 데 필요한 변경 사항을 적용합니다. 또한이 옵션을 사용하면 인덱스가 HEAD 커밋과 일치하지 않아도됩니다. 체리 픽은 인덱스의 시작 상태에 대해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="55875ee1e78ad1cfc5a25d1e098bc17781327203" translate="yes" xml:space="preserve">
          <source>Usually the command automatically creates some commits with commit log messages stating which commits were reverted. This flag applies the changes necessary to revert the named commits to your working tree and the index, but does not make the commits. In addition, when this option is used, your index does not have to match the HEAD commit. The revert is done against the beginning state of your index.</source>
          <target state="translated">일반적으로 명령은 어떤 커밋이 되돌려 졌는지를 나타내는 커밋 로그 메시지와 함께 일부 커밋을 자동으로 만듭니다. 이 플래그는 명명 된 커밋을 작업 트리와 인덱스로 되 돌리는 데 필요한 변경 사항을 적용하지만 커밋은하지 않습니다. 또한이 옵션을 사용하면 인덱스가 HEAD 커밋과 일치하지 않아도됩니다. 복귀는 색인의 시작 상태에 대해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="51d5f6e8faedb5ef4d1204f14e2f7ab2d7b77eaf" translate="yes" xml:space="preserve">
          <source>Usually the command stops output upon showing the commit that is the common ancestor of all the branches. This flag tells the command to go &amp;lt;n&amp;gt; more common commits beyond that. When &amp;lt;n&amp;gt; is negative, display only the &amp;lt;reference&amp;gt;s given, without showing the commit ancestry tree.</source>
          <target state="translated">일반적으로 명령은 모든 분기의 공통 조상 인 커밋을 표시하면 출력을 중지합니다. 이 플래그는 명령이 그보다 더 일반적인 커밋을 &amp;lt;n&amp;gt; 가도록 지시합니다. &amp;lt;n&amp;gt;이 음수이면, 커밋 상위 트리를 표시하지 않고 주어진 &amp;lt;reference&amp;gt; 만 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="972a81bf641e40fbeef4b825d75473d102daada5" translate="yes" xml:space="preserve">
          <source>Usually the easiest way to distinguish between these accounts is to use the username in the URL. For example, if you have the accounts &lt;code&gt;author&lt;/code&gt; and &lt;code&gt;committer&lt;/code&gt; on &lt;code&gt;git.example.org&lt;/code&gt;, you can use the URLs &lt;a href=&quot;https://author@git.example.org/org1/project1.git&quot;&gt;https://author@git.example.org/org1/project1.git&lt;/a&gt; and &lt;a href=&quot;https://committer@git.example.org/org2/project2.git&quot;&gt;https://committer@git.example.org/org2/project2.git&lt;/a&gt;. This way, when you use a credential helper, it will automatically try to look up the correct credentials for your account. If you already have a remote set up, you can change the URL with something like &lt;code&gt;git remote set-url
origin https://author@git.example.org/org1/project1.git&lt;/code&gt; (see &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt; for details).</source>
          <target state="translated">일반적으로 이러한 계정을 구별하는 가장 쉬운 방법은 URL에 사용자 이름을 사용하는 것입니다. 예를 들어 &lt;code&gt;git.example.org&lt;/code&gt; 에 계정 &lt;code&gt;author&lt;/code&gt; 및 &lt;code&gt;committer&lt;/code&gt; 가있는 경우 URL &lt;a href=&quot;https://author@git.example.org/org1/project1.git&quot;&gt;https : //author@git.example.org/org1/project1.git&lt;/a&gt; 및 &lt;a href=&quot;https://committer@git.example.org/org2/project2.git&quot;&gt;https : //committer@git.example을&lt;/a&gt; 사용할 수 있습니다 . .org / org2 / project2.git . 이렇게하면 자격 증명 도우미를 사용할 때 자동으로 계정에 대한 올바른 자격 증명을 찾으려고 시도합니다. 이미 원격 설정이있는 경우 &lt;code&gt;git remote set-url origin https://author@git.example.org/org1/project1.git&lt;/code&gt; 와 같은 URL로 변경할 수 있습니다 (자세한 내용은 &lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; 참조). ).</target>
        </trans-unit>
        <trans-unit id="29097abe7ecd686605680556737a55dc5b7468af" translate="yes" xml:space="preserve">
          <source>Usually the object names are output in SHA-1 form (with possible &lt;code&gt;^&lt;/code&gt; prefix); this option makes them output in a form as close to the original input as possible.</source>
          <target state="translated">일반적으로 개체 이름은 SHA-1 형식 ( &lt;code&gt;^&lt;/code&gt; 접두사 포함) 으로 출력됩니다 . 이 옵션은 가능한 한 원래 입력에 가까운 형태로 출력합니다.</target>
        </trans-unit>
        <trans-unit id="576f849692364345fa924f476c3413707294c315" translate="yes" xml:space="preserve">
          <source>Usually the output is made one line per flag and parameter. This option makes output a single line, properly quoted for consumption by shell. Useful when you expect your parameter to contain whitespaces and newlines (e.g. when using pickaxe &lt;code&gt;-S&lt;/code&gt; with &lt;code&gt;git diff-*&lt;/code&gt;). In contrast to the &lt;code&gt;--sq-quote&lt;/code&gt; option, the command input is still interpreted as usual.</source>
          <target state="translated">일반적으로 출력은 플래그와 매개 변수 당 한 줄로 만들어집니다. 이 옵션은 출력을 단일 행으로 만들고 셸에서 사용하기에 적합하게 인용합니다. 매개 변수에 공백과 줄 바꿈이 포함될 것으로 예상 할 때 유용합니다 (예 : &lt;code&gt;git diff-*&lt;/code&gt; 와 함께 pickaxe &lt;code&gt;-S&lt;/code&gt; 를 사용하는 경우 ). 받는 반면 &lt;code&gt;--sq-quote&lt;/code&gt; 옵션, 명령 입력은 여전히 평소와 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="52303fe63fddea8a07d49fe1df917ff950ba6541" translate="yes" xml:space="preserve">
          <source>Usually the program removes email cruft from the Subject: header line to extract the title line for the commit log message. This option prevents this munging, and is most useful when used to read back &lt;code&gt;git format-patch -k&lt;/code&gt; output.</source>
          <target state="translated">일반적으로 프로그램은 Subject : 헤더 행에서 전자 메일 크루프를 제거하여 커밋 로그 메시지의 제목 줄을 추출합니다. 이 옵션은 이러한 뭉침 현상을 방지하며 &lt;code&gt;git format-patch -k&lt;/code&gt; 출력을 다시 읽을 때 가장 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="12904fba6e8c31d350b5463557502fba670802b3" translate="yes" xml:space="preserve">
          <source>Usually you cannot cherry-pick a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows cherry-pick to replay the change relative to the specified parent.</source>
          <target state="translated">일반적으로 병합의 어느 쪽이 메인 라인으로 간주되어야하는지 모르기 때문에 병합을 체리 픽픽으로 선택할 수 없습니다. 이 옵션은 메인 라인의 부모 번호 (1부터 시작)를 지정하고 체리 픽이 지정된 부모에 대한 변경을 재생할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="8ec09d5ac366ce3cd2a5e3c6c67d0b4fe311e4bf" translate="yes" xml:space="preserve">
          <source>Usually you cannot revert a merge because you do not know which side of the merge should be considered the mainline. This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.</source>
          <target state="translated">일반적으로 병합의 어느 쪽이 메인 라인으로 간주되어야하는지 모르기 때문에 병합을 되돌릴 수 없습니다. 이 옵션은 메인 라인의 상위 번호 (1부터 시작)를 지정하고 지정된 상위를 기준으로 변경 사항을 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6969d1a350dfc3fafb277e2e6995e5ac7a289ac5" translate="yes" xml:space="preserve">
          <source>Usually you should not need to change (adjust) any of configuration variables described below; they should be automatically set by gitweb to correct value.</source>
          <target state="translated">일반적으로 아래 설명 된 구성 변수를 변경 (조정) 할 필요는 없습니다. 그들은 gitweb에 의해 자동으로 설정되어 값을 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b172c85defacdb686b541793ef9e8aeee0cdf60e" translate="yes" xml:space="preserve">
          <source>Usually you would want to use &lt;code&gt;git fetch&lt;/code&gt;, which is a higher level wrapper of this command, instead.</source>
          <target state="translated">일반적 으로이 명령의 상위 레벨 래퍼 인 &lt;code&gt;git fetch&lt;/code&gt; 를 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="bec645de31c299cb10f93b6253e1e1669a5f0a31" translate="yes" xml:space="preserve">
          <source>Usually you would want to use &lt;code&gt;git push&lt;/code&gt;, which is a higher-level wrapper of this command, instead. See &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">일반적으로 대신이 명령의 상위 레벨 래퍼 인 &lt;code&gt;git push&lt;/code&gt; 를 사용하려고합니다 . &lt;a href=&quot;git-push&quot;&gt;git-push [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5982263578e4f00875c00a40da810fe92911cebc" translate="yes" xml:space="preserve">
          <source>Usually, &quot;git push&quot; refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it.</source>
          <target state="translated">일반적으로 &quot;git push&quot;는 덮어 쓰기에 사용 된 로컬 참조의 조상이 아닌 원격 참조 업데이트를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="f8497b6ab754b20f8d36f9efb8dfea581706bc5d" translate="yes" xml:space="preserve">
          <source>Usually, dangling blobs and trees aren&amp;rsquo;t very interesting. They&amp;rsquo;re almost always the result of either being a half-way mergebase (the blob will often even have the conflict markers from a merge in it, if you have had conflicting merges that you fixed up by hand), or simply because you interrupted a &lt;code&gt;git fetch&lt;/code&gt; with ^C or something like that, leaving &lt;code&gt;some&lt;/code&gt; of the new objects in the object database, but just dangling and useless.</source>
          <target state="translated">일반적으로 매달린 얼룩과 나무는 그리 흥미롭지 않습니다. 그것들은 거의 항상 반쯤 머지베이스 (혼합 된 머지가 있었다면 블롭이 머지에서 머티리얼에서 충돌 마커를 가질 수도 있음)이거나 단순히 중단했기 때문에 발생합니다. ^ C와 같은 &lt;code&gt;git fetch&lt;/code&gt; 는 객체 데이터베이스에 새로운 객체 &lt;code&gt;some&lt;/code&gt; 를 남겨두고 매달려 있지만 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6811a338c6e88fac2f36caab99cbe1bb3018067b" translate="yes" xml:space="preserve">
          <source>Usually, if the password or token is invalid, Git will erase it and prompt for a new one. However, there are times when this doesn&amp;rsquo;t always happen. To change the password or token, you can erase the existing credentials and then Git will prompt for new ones. To erase credentials, use a syntax like the following (substituting your username and the hostname):</source>
          <target state="translated">일반적으로 암호 또는 토큰이 유효하지 않은 경우 Git은 암호 또는 토큰을 지우고 새 암호를 요구합니다. 그러나 이것이 항상 발생하지 않는 경우가 있습니다. 암호 또는 토큰을 변경하려면 기존 자격 증명을 지우면 Git에서 새 자격 증명을 요구합니다. 자격 증명을 지우려면 다음과 같은 구문을 사용하십시오 (사용자 이름 및 호스트 이름 대체).</target>
        </trans-unit>
        <trans-unit id="ebecb811fcb50ea2c9e80ad196b73df5b02ee5fc" translate="yes" xml:space="preserve">
          <source>Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. Also, when &lt;code&gt;--force-with-lease&lt;/code&gt; option is used, the command refuses to update a remote ref whose current value does not match what is expected.</source>
          <target state="translated">일반적으로이 명령은 덮어 쓰기에 사용 된 로컬 참조의 조상이 아닌 원격 참조 업데이트를 거부합니다. 또한 &lt;code&gt;--force-with-lease&lt;/code&gt; 옵션을 사용하는 경우 명령은 현재 값이 예상 한 값과 일치하지 않는 원격 참조 업데이트를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="1039e5d0aca0474d85bb0cc56a14c21769cd56ed" translate="yes" xml:space="preserve">
          <source>Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. This flag disables the check. What this means is that the remote repository can lose commits; use it with care.</source>
          <target state="translated">일반적으로이 명령은 덮어 쓰기에 사용 된 로컬 참조의 조상이 아닌 원격 참조 업데이트를 거부합니다. 이 플래그는 검사를 비활성화합니다. 이것이 의미하는 것은 원격 저장소가 커밋을 잃을 수 있다는 것입니다. 조심해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b573cab97a4c7ff4e65c78f089627a289eeb14b6" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt;'s include:</source>
          <target state="translated">유효한 &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f441e23dc9e42a84676feea9743dbd62f2c9b12" translate="yes" xml:space="preserve">
          <source>Valid object types are:</source>
          <target state="translated">유효한 객체 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b5bd1c32c0119d43f13ecb3f634510bb032afd7" translate="yes" xml:space="preserve">
          <source>Validate packed Git archive files</source>
          <target state="translated">압축 된 Git 아카이브 파일 검증</target>
        </trans-unit>
        <trans-unit id="c95efe4a20b3c90ba09bca423cb347dacda4f997" translate="yes" xml:space="preserve">
          <source>Validates the GPG signature created by &lt;code&gt;git commit -S&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git commit -S&lt;/code&gt; 로 작성된 GPG 서명을 검증합니다 .</target>
        </trans-unit>
        <trans-unit id="ee833db09826b15f6656c228fc09101a4d262c96" translate="yes" xml:space="preserve">
          <source>Validates the gpg signature created by &lt;code&gt;git tag&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git tag&lt;/code&gt; 에 의해 생성 된 gpg 서명을 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="38ecbfb58a1b4075db82e349628396bb680485d8" translate="yes" xml:space="preserve">
          <source>Values for other tools can be used if there is a corresponding &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; configuration entry (see below).</source>
          <target state="translated">해당 &lt;code&gt;man.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 구성 항목 이있는 경우 다른 도구의 값을 사용할 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="4590af9796b7774b94529a47844bbbd8cd70381f" translate="yes" xml:space="preserve">
          <source>Values obtained in later configuration files override values obtained earlier in the above sequence.</source>
          <target state="translated">이후 구성 파일에서 얻은 값은 위 순서에서 이전에 얻은 값보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="42a2c91c112ab20fb86d229e79049c16aac8f47b" translate="yes" xml:space="preserve">
          <source>Values of many variables are treated as a simple string, but there are variables that take values of specific types and there are rules as to how to spell them.</source>
          <target state="translated">많은 변수의 값은 간단한 문자열로 취급되지만 특정 유형의 값을 취하는 변수가 있으며 철자를 철자하는 방법에 대한 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="af6a117cf9cae5d8127a5c83e908e26e4094605c" translate="yes" xml:space="preserve">
          <source>Variable substitution</source>
          <target state="translated">변수 치환</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="36ae09eeb0daa8ef3fa73e86b507f064c6f1150e" translate="yes" xml:space="preserve">
          <source>Various Git commands use the following environment variables:</source>
          <target state="translated">다양한 Git 명령은 다음 환경 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c808db304a88e67e4d99602bde96a3fd73a86c36" translate="yes" xml:space="preserve">
          <source>Various aspects of gitweb&amp;rsquo;s behavior can be controlled through the configuration file &lt;code&gt;gitweb_config.perl&lt;/code&gt; or &lt;code&gt;/etc/gitweb.conf&lt;/code&gt;. See the &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt; for details.</source>
          <target state="translated">gitweb 동작의 다양한 측면은 구성 파일 &lt;code&gt;gitweb_config.perl&lt;/code&gt; 또는 &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; 를 통해 제어 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="514c3adc237433a43f04caf698ef6f51638f8f03" translate="yes" xml:space="preserve">
          <source>Various commands read from the configuration file and adjust their operation accordingly. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for a list and more details about the configuration mechanism.</source>
          <target state="translated">구성 파일에서 다양한 명령을 읽고 그에 따라 작업을 조정합니다. 구성 메커니즘에 대한 자세한 내용과 목록 은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9d741cda072f8e825584f9d44fb913d01a1b3645" translate="yes" xml:space="preserve">
          <source>Various values from structured fields in referenced objects can be used to interpolate into the resulting output, or as sort keys.</source>
          <target state="translated">참조 된 객체의 구조화 된 필드의 다양한 값을 사용하여 결과 출력에 보간하거나 정렬 키로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e52597805b02b27bbf6fa8afb053d38cd1cf9a2" translate="yes" xml:space="preserve">
          <source>Various ways to check your working tree</source>
          <target state="translated">작업 트리를 확인하는 다양한 방법</target>
        </trans-unit>
        <trans-unit id="8a8830ff167eaa3505bc00fdd4111ea514743436" translate="yes" xml:space="preserve">
          <source>Verbose output.</source>
          <target state="translated">자세한 출력.</target>
        </trans-unit>
        <trans-unit id="5e80e8afa8277ee05efe0825f2f72b290ab38b7f" translate="yes" xml:space="preserve">
          <source>Verbose.</source>
          <target state="translated">Verbose.</target>
        </trans-unit>
        <trans-unit id="1eee329978eae57e0140879a7cb5a19a8e448f4c" translate="yes" xml:space="preserve">
          <source>Verbosely display information about the searching strategy being employed to standard error. The tag name will still be printed to standard out.</source>
          <target state="translated">표준 오류에 사용되는 검색 전략에 대한 정보를 자세하게 표시합니다. 태그 이름은 여전히 ​​표준 출력으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="17eca013b0d71c76732d4067f559197bffc5dc5a" translate="yes" xml:space="preserve">
          <source>Verbosity: let &lt;code&gt;cvsimport&lt;/code&gt; report what it is doing.</source>
          <target state="translated">자세한 정보 : &lt;code&gt;cvsimport&lt;/code&gt; 가 수행중인 작업을보고 하도록 합니다.</target>
        </trans-unit>
        <trans-unit id="43241483b8c2e2b351480246076bc9d9d3aeeb38" translate="yes" xml:space="preserve">
          <source>Verifies the connectivity and validity of the objects in the database</source>
          <target state="translated">데이터베이스에서 객체의 연결성과 유효성을 확인합니다</target>
        </trans-unit>
        <trans-unit id="083f6e6fa7581860cb22a12637eec790f2c234d9" translate="yes" xml:space="preserve">
          <source>Verifies the connectivity and validity of the objects in the database.</source>
          <target state="translated">데이터베이스에서 오브젝트의 연결성과 유효성을 검증합니다.</target>
        </trans-unit>
        <trans-unit id="6f20b572e11a287b2200fc3c18b3124b41ee5e40" translate="yes" xml:space="preserve">
          <source>Verify &amp;lt;ref&amp;gt; against &amp;lt;oldvalue&amp;gt; but do not change it. If &amp;lt;oldvalue&amp;gt; is zero or missing, the ref must not exist.</source>
          <target state="translated">&amp;lt;oldvalue&amp;gt;에 대해 &amp;lt;ref&amp;gt;를 확인하되 변경하지 마십시오. &amp;lt;oldvalue&amp;gt;가 0이거나 누락 된 경우 참조가 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="121ce6e2fb35359b4c456b6cab91a3389a1154d2" translate="yes" xml:space="preserve">
          <source>Verify &amp;lt;ref&amp;gt; against &amp;lt;oldvalue&amp;gt; but do not change it. If &amp;lt;oldvalue&amp;gt; zero or missing, the ref must not exist.</source>
          <target state="translated">&amp;lt;oldvalue&amp;gt;에 대해 &amp;lt;ref&amp;gt;를 확인하지만 변경하지 마십시오. &amp;lt;oldvalue&amp;gt;가 0이거나 누락 된 경우 심판이 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="f2a6ea4dcf4e13700439c2c62eb9c887c3645654" translate="yes" xml:space="preserve">
          <source>Verify that everything reachable from target is fetched. Used after an earlier fetch is interrupted.</source>
          <target state="translated">대상에서 도달 가능한 모든 항목을 가져 왔는지 확인하십시오. 이전 반입이 중단 된 후 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dc19dfe6277cd8889c0ce32fc30714a767c456fd" translate="yes" xml:space="preserve">
          <source>Verify that exactly one parameter is provided, and that it can be turned into a raw 20-byte SHA-1 that can be used to access the object database. If so, emit it to the standard output; otherwise, error out.</source>
          <target state="translated">정확히 하나의 매개 변수가 제공되고 오브젝트 데이터베이스에 액세스하는 데 사용할 수있는 원시 20 바이트 SHA-1로 변환 될 수 있는지 확인하십시오. 그렇다면 표준 출력으로 방출하십시오. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e921c65f691e2b371e3e29dc398bb292612d2860" translate="yes" xml:space="preserve">
          <source>Verify that the tip commit of the side branch being merged is signed with a valid key, i.e. a key that has a valid uid: in the default trust model, this means the signing key has been signed by a trusted key. If the tip commit of the side branch is not signed with a valid key, the merge is aborted.</source>
          <target state="translated">병합되는 사이드 브랜치의 팁 커밋이 유효한 키, 즉 유효한 uid가있는 키로 서명되었는지 확인하십시오. 기본 신뢰 모델에서 이는 서명 키가 신뢰할 수있는 키로 서명되었음을 의미합니다. 사이드 브랜치의 팁 커밋이 유효한 키로 서명되지 않은 경우 병합이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="baf3600caf9cbc675ef33fe6c51f69bd006b47ea" translate="yes" xml:space="preserve">
          <source>Verify the GPG signature of the given tag names.</source>
          <target state="translated">주어진 태그 이름의 GPG 서명을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2977304de3538ddff5d274481548280fa86926b6" translate="yes" xml:space="preserve">
          <source>Verify the MIDX file for the packfiles in the current .git folder.</source>
          <target state="translated">현재 .git 폴더에서 팩 파일에 대한 MIDX 파일을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="593811a1bcc6cbc445bcfa7fdf52e4a760c41784" translate="yes" xml:space="preserve">
          <source>Verify the contents of the MIDX file.</source>
          <target state="translated">MIDX 파일의 내용을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="63de76d12bfde7fe2c14402fe2f03160cc3a7318" translate="yes" xml:space="preserve">
          <source>Version 1 porcelain format is similar to the short format, but is guaranteed not to change in a backwards-incompatible way between Git versions or based on user configuration. This makes it ideal for parsing by scripts. The description of the short format above also describes the porcelain format, with a few exceptions:</source>
          <target state="translated">버전 1 도자기 형식은 짧은 형식과 유사하지만 Git 버전간에 또는 사용자 구성에 따라 이전 버전과 호환되지 않는 방식으로 변경되지 않습니다. 따라서 스크립트로 구문 분석하는 데 이상적입니다. 위의 짧은 형식에 대한 설명은 몇 가지 예외를 제외하고 도자기 형식에 대해서도 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1bb30898712789d3819631e4bb7ad8cf32d20671" translate="yes" xml:space="preserve">
          <source>Version 1 takes two arguments, a version (1) and the time in elapsed nanoseconds since midnight, January 1, 1970.</source>
          <target state="translated">버전 1은 버전 (1)과 1970 년 1 월 1 일 자정 이후 경과 된 시간 (나노초)이라는 두 개의 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="33e409adcd5a97d5085c0477fcb4b42dc9a034a9" translate="yes" xml:space="preserve">
          <source>Version 2 format adds more detailed information about the state of the worktree and changed items. Version 2 also defines an extensible set of easy to parse optional headers.</source>
          <target state="translated">버전 2 형식은 작업 트리 상태 및 변경된 항목에 대한 자세한 정보를 추가합니다. 버전 2는 확장 가능한 파싱 옵션 헤더 세트도 정의합니다.</target>
        </trans-unit>
        <trans-unit id="2b8063c91f48f5daba279d42a4965f292b8198dd" translate="yes" xml:space="preserve">
          <source>Version 2 pack-*.idx files support packs larger than 4 gib, and</source>
          <target state="translated">버전 2 pack-*. idx 파일은 4 gib보다 큰 팩을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="76b6cb1496a78fff149bd68b719a91ca0d69c9df" translate="yes" xml:space="preserve">
          <source>Version 2 takes two arguments, a version (2) and a token that is used for identifying changes since the token. For watchman this would be a clock id. This version must output to stdout the new token followed by a NUL before the list of files.</source>
          <target state="translated">버전 2는 버전 (2)과 토큰 이후 변경 사항을 식별하는 데 사용되는 토큰이라는 두 개의 인수를 사용합니다. 파수꾼의 경우 이것은 시계 ID입니다. 이 버전은 파일 목록 앞에 NUL이 뒤 따르는 새 토큰을 stdout으로 출력해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a28a75eceea6b3fb1730e69daff64901cead811" translate="yes" xml:space="preserve">
          <source>Version 4 performs a simple pathname compression that reduces index size by 30%-50% on large repositories, which results in faster load time. Version 4 is relatively young (first released in 1.8.0 in October 2012). Other Git implementations such as JGit and libgit2 may not support it yet.</source>
          <target state="translated">버전 4는 간단한 경로 이름 압축을 수행하여 큰 저장소에서 색인 크기를 30 % -50 % 줄이므로로드 시간이 단축됩니다. 버전 4는 비교적 젊습니다 (2012 년 10 월 1.8.0에 처음 릴리스 됨). JGit 및 libgit2와 같은 다른 Git 구현은 아직 지원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b61ffa7c699cf77c98fcf76236048d42ca5d233" translate="yes" xml:space="preserve">
          <source>Version &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">버전 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fc1164df4f366b4e06ce848f94e3799671648de" translate="yes" xml:space="preserve">
          <source>Version &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">버전 &lt;code&gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26980b77b1e7ef480646032aebce78732551db11" translate="yes" xml:space="preserve">
          <source>Versions of Git older than 1.7.7 don&amp;rsquo;t know about the &lt;code&gt;tar.gz&lt;/code&gt; format, you&amp;rsquo;ll need to use gzip explicitly:</source>
          <target state="translated">1.7.7 이전의 Git 버전은 &lt;code&gt;tar.gz&lt;/code&gt; 형식을 알지 못하므로 gzip을 명시 적으로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="48cda44638e8ce2f3c6e764951e4cd137e88bacc" translate="yes" xml:space="preserve">
          <source>Via the alternates mechanism, a &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; can inherit part of its &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt; from another object database, which is called an &quot;alternate&quot;.</source>
          <target state="translated">대체 메커니즘을 통해 &lt;a href=&quot;#def_repository&quot;&gt;저장소&lt;/a&gt; 는 &quot;대체&quot;라고하는 다른 오브젝트 데이터베이스에서 &lt;a href=&quot;#def_object_database&quot;&gt;오브젝트 데이터베이스의&lt;/a&gt; 일부를 상속 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d75bfce3768015c62af9c4bd29fd7cad894764e0" translate="yes" xml:space="preserve">
          <source>Viewing everything that was changed in a revision, and step through revisions one at a time, viewing the history of the repository.</source>
          <target state="translated">개정판에서 변경된 모든 내용을보고 한 번에 하나씩 개정판을 통해 저장소의 히스토리를보십시오.</target>
        </trans-unit>
        <trans-unit id="8e797001d4524362e7db8f18210266901eb28403" translate="yes" xml:space="preserve">
          <source>Viewing files in GUI tools</source>
          <target state="translated">GUI 도구에서 파일보기</target>
        </trans-unit>
        <trans-unit id="05c33ea7de1cccd62a72042e46bec3b3d340cf9f" translate="yes" xml:space="preserve">
          <source>Viewing multiple Git repositories with common root.</source>
          <target state="translated">공통 루트로 여러 Git 리포지토리보기</target>
        </trans-unit>
        <trans-unit id="1439a80405107c5dd4ca129513bf97eb92ca8c3f" translate="yes" xml:space="preserve">
          <source>Viewing old file versions</source>
          <target state="translated">이전 파일 버전보기</target>
        </trans-unit>
        <trans-unit id="cba1ab24737b9af4081eae74baa579853869959f" translate="yes" xml:space="preserve">
          <source>Viewing project history</source>
          <target state="translated">프로젝트 히스토리보기</target>
        </trans-unit>
        <trans-unit id="48e788f7b4905bc5801452134707bb74e1fddd3c" translate="yes" xml:space="preserve">
          <source>Viewing the blame/annotation details of any file (if enabled).</source>
          <target state="translated">모든 파일의 책임 / 주석 세부 정보보기 (활성화 된 경우).</target>
        </trans-unit>
        <trans-unit id="afd57038f9956faea3beadae2f663a8f18e1dd6a" translate="yes" xml:space="preserve">
          <source>Viewing the contents of files in the repository at any revision.</source>
          <target state="translated">개정판에서 저장소의 파일 내용보기</target>
        </trans-unit>
        <trans-unit id="79e8c237bcc343324671ba4de89f13c4632b7437" translate="yes" xml:space="preserve">
          <source>Viewing the revision log of branches, history of files and directories, see what was changed when, by who.</source>
          <target state="translated">분기의 개정 로그, 파일 및 디렉토리 기록을보고 누가 언제 변경했는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5d3b4279714ad2970a30b9dfdfce1d9cde0d271d" translate="yes" xml:space="preserve">
          <source>Voila.</source>
          <target state="translated">Voila.</target>
        </trans-unit>
        <trans-unit id="f7dda342bfe7129409283096bf9eae6889a3617d" translate="yes" xml:space="preserve">
          <source>Waiting $&amp;lt;int&amp;gt; seconds before reconnecting to SMTP server. Used together with --batch-size option. Defaults to the &lt;code&gt;sendemail.smtpReloginDelay&lt;/code&gt; configuration variable.</source>
          <target state="translated">SMTP 서버에 다시 연결하기 전에 $ &amp;lt;int&amp;gt; 초 동안 대기 중입니다. --batch-size 옵션과 함께 사용됩니다. &lt;code&gt;sendemail.smtpReloginDelay&lt;/code&gt; 구성 변수가 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="6abfc589b188840a4520edd8282e2221d54aed84" translate="yes" xml:space="preserve">
          <source>Walk history forward instead of backward. Instead of showing the revision in which a line appeared, this shows the last revision in which a line has existed. This requires a range of revision like START..END where the path to blame exists in START. &lt;code&gt;git blame --reverse START&lt;/code&gt; is taken as &lt;code&gt;git blame
--reverse START..HEAD&lt;/code&gt; for convenience.</source>
          <target state="translated">뒤로가 아니라 앞으로 걸어가십시오. 선이 나타난 개정을 표시하는 대신 선이 존재하는 마지막 개정을 표시합니다. 이것은 비난의 경로가 START에 존재하는 START..END와 같은 범위의 수정이 필요합니다. &lt;code&gt;git blame --reverse START&lt;/code&gt; 는 편의상 &lt;code&gt;git blame --reverse START..HEAD&lt;/code&gt; 로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="246770a4db6a59723366cd008c0806351012631a" translate="yes" xml:space="preserve">
          <source>Walk through the patches in the series and warn if we cannot find all of the necessary information to commit a patch. At the time of this writing only missing author information is warned about.</source>
          <target state="translated">시리즈의 패치를 살펴보고 패치를 커밋하는 데 필요한 정보를 모두 찾을 수없는 경우 경고합니다. 이 글을 쓰는 시점에는 누락 된 저자 정보 만 경고됩니다.</target>
        </trans-unit>
        <trans-unit id="8741434725596a0a6dcba1ea6ce0540165fbeb38" translate="yes" xml:space="preserve">
          <source>Warn if changes introduce conflict markers or whitespace errors. What are considered whitespace errors is controlled by &lt;code&gt;core.whitespace&lt;/code&gt; configuration. By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors. Exits with non-zero status if problems are found. Not compatible with --exit-code.</source>
          <target state="translated">변경으로 인해 충돌 마커 또는 공백 오류가 발생하면 경고합니다. 공백 오류로 간주되는 것은 &lt;code&gt;core.whitespace&lt;/code&gt; 구성에 의해 제어됩니다 . 기본적으로 후행 공백 (공백만으로 구성되는 줄 포함)과 줄의 처음 들여 쓰기 안에 탭 문자 바로 뒤에 오는 공백 문자는 공백 오류로 간주됩니다. 문제가 발견되면 0이 아닌 상태로 종료합니다. --exit-code와 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0219dea42624b30174e17cfd1bb37d7d1a042a1" translate="yes" xml:space="preserve">
          <source>Warn of patches that contain lines longer than 998 characters unless a suitable transfer encoding (&lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;base64&lt;/code&gt;, or &lt;code&gt;quoted-printable&lt;/code&gt;) is used; this is due to SMTP limits as described by &lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;http://www.ietf.org/rfc/rfc5322.txt&lt;/a&gt;.</source>
          <target state="translated">적절한 전송 인코딩 ( &lt;code&gt;auto&lt;/code&gt; , &lt;code&gt;base64&lt;/code&gt; 또는 &lt;code&gt;quoted-printable&lt;/code&gt; )을 사용 하지 않는 한 998자를 초과하는 행이 포함 된 패치에 대해 경고합니다 . 이는 &lt;a href=&quot;http://www.ietf.org/rfc/rfc5322.txt&quot;&gt;http://www.ietf.org/rfc/rfc5322.txt에&lt;/a&gt; 설명 된 SMTP 제한으로 인한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="d9a62a2598117c2be58c53a722de6576cd225a89" translate="yes" xml:space="preserve">
          <source>Warnings are printed on the standard error output for any explicitly unsupported constructs, and any other lines that are not recognized by the parser.</source>
          <target state="translated">명시 적으로 지원되지 않는 구성 및 구문 분석기가 인식하지 못하는 다른 행에 대해서는 표준 오류 출력에 경고가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="54490e8680807566a4db5e14166b54af9ee18d68" translate="yes" xml:space="preserve">
          <source>We already saw in &lt;a href=&quot;#understanding-commits&quot;&gt;Understanding History: Commits&lt;/a&gt; that all commits are stored under a 40-digit &quot;object name&quot;. In fact, all the information needed to represent the history of a project is stored in objects with such names. In each case the name is calculated by taking the SHA-1 hash of the contents of the object. The SHA-1 hash is a cryptographic hash function. What that means to us is that it is impossible to find two different objects with the same name. This has a number of advantages; among others:</source>
          <target state="translated">우리는 이미 &lt;a href=&quot;#understanding-commits&quot;&gt;이력 이해 : 커밋&lt;/a&gt; 에서 모든 커밋이 40 자리 &quot;객체 이름&quot;으로 저장되어 있음을 보았습니다 . 실제로 프로젝트 히스토리를 나타내는 데 필요한 모든 정보는 해당 이름을 가진 오브젝트에 저장됩니다. 각각의 경우에 이름은 객체 내용의 SHA-1 해시를 사용하여 계산됩니다. SHA-1 해시는 암호화 해시 기능입니다. 그것이 우리에게 의미하는 것은 같은 이름을 가진 두 개의 다른 물체를 찾는 것이 불가능하다는 것입니다. 여기에는 여러 가지 장점이 있습니다. 다른 것들 중에서 :</target>
        </trans-unit>
        <trans-unit id="e79afdd75f0417fa823f7b20619c450850fb2c27" translate="yes" xml:space="preserve">
          <source>We also recommend setting a &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; file to explicitly mark which files are text and which are binary. If you want Git to guess, you can set the attribute &lt;code&gt;text=auto&lt;/code&gt;. For example, the following might be appropriate in some projects:</source>
          <target state="translated">또한 어떤 파일이 텍스트이고 어떤 파일이 바이너리인지 명시 적으로 표시하도록 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 파일을 설정하는 것이 좋습니다 . Git이 추측하도록하려면 &lt;code&gt;text=auto&lt;/code&gt; 속성을 설정할 수 있습니다 . 예를 들어 일부 프로젝트에서는 다음이 적절할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6fd523936a98d1231393ad2931c9779a4d79b0e" translate="yes" xml:space="preserve">
          <source>We are looking for a &quot;best&quot; explanation of the new series in terms of the old one. We can represent an &quot;explanation&quot; as an edge in the graph:</source>
          <target state="translated">우리는 이전 시리즈와 관련하여 새로운 시리즈에 대한 &quot;최상의&quot;설명을 찾고 있습니다. 그래프에서 &quot;설명&quot;을 모서리로 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b940c15e60e8d5e30f8f0dd6fb317eefa03a3c7" translate="yes" xml:space="preserve">
          <source>We assume that GITWEB_CONFIG has its default Makefile value, namely &lt;code&gt;gitweb_config.perl&lt;/code&gt;. Put the following in &lt;code&gt;gitweb_make_index.perl&lt;/code&gt; file:</source>
          <target state="translated">우리는 GITWEB_CONFIG는 기본 메이크 값, 즉이 있다고 가정 &lt;code&gt;gitweb_config.perl&lt;/code&gt; 을 . &lt;code&gt;gitweb_make_index.perl&lt;/code&gt; 파일에 다음을 입력 하십시오.</target>
        </trans-unit>
        <trans-unit id="860f449f084465687d5f3065e9dcdf4471fe0c53" translate="yes" xml:space="preserve">
          <source>We assume the following in /etc/services</source>
          <target state="translated">/ etc / services에서 다음을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e666201c4a3affd420bf339541f1e66f556269f5" translate="yes" xml:space="preserve">
          <source>We assume you have already created a Git repository for your project, possibly created from scratch or from a tarball (see &lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt;), or imported from an already existing CVS repository (see the next section).</source>
          <target state="translated">프로젝트를 위해 Git 저장소를 이미 작성했거나 처음부터 또는 tarball ( &lt;a href=&quot;gittutorial&quot;&gt;gittutorial [7]&lt;/a&gt; 참조 )로 작성했거나 기존 CVS 저장소에서 가져온 것으로 가정합니다 (다음 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="a35a2d4ac8af99272cba8ca44431c44847ef0735" translate="yes" xml:space="preserve">
          <source>We can also create a tag to refer to a particular commit; after running</source>
          <target state="translated">특정 커밋을 나타내는 태그를 만들 수도 있습니다. 실행 후</target>
        </trans-unit>
        <trans-unit id="ec584a188dcd2e25a99263b54f2feb909dc57e99" translate="yes" xml:space="preserve">
          <source>We can ask Git about this particular object with the &lt;code&gt;cat-file&lt;/code&gt; command. Don&amp;rsquo;t copy the 40 hex digits from this example but use those from your own version. Note that you can shorten it to only a few characters to save yourself typing all 40 hex digits:</source>
          <target state="translated">&lt;code&gt;cat-file&lt;/code&gt; 명령으로 Git에게이 특정 객체에 대해 물어볼 수 있습니다 . 이 예에서 40 자리 16 진수를 복사하지 말고 사용자 고유 버전의 숫자를 사용하십시오. 40 자릿수를 모두 입력하면 자신을 저장하기 위해 몇 자로 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d0c7ad92eed63e4b86ed7fcdbe0a2af116dc20a" translate="yes" xml:space="preserve">
          <source>We can further investigate the time spent scanning for untracked files.</source>
          <target state="translated">추적되지 않은 파일을 검색하는 데 걸린 시간을 추가로 조사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14c5f91f2f30d67e424b3d8fa6177783e08a84fd" translate="yes" xml:space="preserve">
          <source>We can get just the branch-head names, and remove &lt;code&gt;master&lt;/code&gt;, with the help of the standard utilities cut and grep:</source>
          <target state="translated">표준 유틸리티 cut 및 grep을 사용 하여 브랜치 헤드 이름 만 가져오고 &lt;code&gt;master&lt;/code&gt; 를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a00f6027326a1e03d87c7714c37d6396c5fc0f07" translate="yes" xml:space="preserve">
          <source>We can get this using the following command:</source>
          <target state="translated">다음 명령을 사용하여이를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="308213d749ac73498be48acb36aa505b62d477c8" translate="yes" xml:space="preserve">
          <source>We can give this name to &lt;code&gt;git show&lt;/code&gt; to see the details about this commit.</source>
          <target state="translated">이 커밋에 대한 세부 사항을보기 위해이 이름을 &lt;code&gt;git show&lt;/code&gt; 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="164a7b582707458e7c29a45bdd3cb932a29b3ca1" translate="yes" xml:space="preserve">
          <source>We can list all the heads in this repository with &lt;a href=&quot;git-show-ref&quot;&gt;git-show-ref[1]&lt;/a&gt;:</source>
          <target state="translated">이 저장소의 모든 헤드를 &lt;a href=&quot;git-show-ref&quot;&gt;git-show-ref [1]로&lt;/a&gt; 나열 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3342879e047ae36a38db13969064b38d54ccc902" translate="yes" xml:space="preserve">
          <source>We divide Git into high level (&quot;porcelain&quot;) commands and low level (&quot;plumbing&quot;) commands.</source>
          <target state="translated">Git을 상위 레벨 ( &quot;porcelain&quot;) 명령과 하위 레벨 ( &quot;plumbing&quot;) 명령으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="011f9d254149abd4e25f111f5f8f2bc847e7e4cc" translate="yes" xml:space="preserve">
          <source>We explain how to do this in the following sections.</source>
          <target state="translated">다음 섹션에서이를 수행하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4822ab43c46db1b5802e2f53899245649e4398bd" translate="yes" xml:space="preserve">
          <source>We formulate a set of &lt;code&gt;rules&lt;/code&gt; for quick reference, while the prose tries to motivate each of them. Do not always take them literally; you should value good reasons for your actions higher than manpages such as this one.</source>
          <target state="translated">우리는 빠른 참조를 위해 일련의 &lt;code&gt;rules&lt;/code&gt; 을 구성하는 반면, 산문은 각각의 규칙 에 동기를 부여하려고 시도합니다. 항상 문자 그대로 받아들이지 마십시오. 이 같은 맨 페이지보다 높은 작업을 수행해야하는 적절한 이유를 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="27af85d69b0e1da45afccff7b9c2331995331c55" translate="yes" xml:space="preserve">
          <source>We found that most commits on the graph may give quite a lot of information when they are tested. And the commits that will not on average give a lot of information are the one near the good and bad commits.</source>
          <target state="translated">그래프에 대한 대부분의 커밋은 테스트 할 때 많은 정보를 제공 할 수 있음을 발견했습니다. 그리고 평균적으로 많은 정보를 제공하지 않는 커밋은 좋은 커밋과 나쁜 커밋에 가까운 것입니다.</target>
        </trans-unit>
        <trans-unit id="319c4fde5f53d3ebfff60d2ca81633ff5c5e7332" translate="yes" xml:space="preserve">
          <source>We have already seen &lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;how to keep remote-tracking branches up to date&lt;/a&gt; with &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;, and how to merge two branches. So you can merge in changes from the original repository&amp;rsquo;s master branch with:</source>
          <target state="translated">우리는 이미 본 &lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;최신 지점을 원격 추적 유지하는 방법&lt;/a&gt; 과 &lt;a href=&quot;git-fetch&quot;&gt;[1] 자식 페치&lt;/a&gt; 및 방법 두 가지를 병합 할 수 있습니다. 따라서 원본 리포지토리의 마스터 브랜치에서 변경 사항을 다음과 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9313b2be3fe8f9ef5431fd57e740ed2c389d7c2c" translate="yes" xml:space="preserve">
          <source>We have already seen how branches work previously, with &quot;fun and work&quot; example using two branches. The idea is the same if there are more than two branches. Let&amp;rsquo;s say you started out from &quot;master&quot; head, and have some new code in the &quot;master&quot; branch, and two independent fixes in the &quot;commit-fix&quot; and &quot;diff-fix&quot; branches:</source>
          <target state="translated">우리는 이미 두 가지를 사용하는 &quot;재미와 일&quot;예제와 함께 가지가 이전에 어떻게 작동하는지 보았습니다. 가지가 두 개 이상인 경우에도 같은 생각입니다. &quot;마스터&quot;헤드에서 시작하여 &quot;마스터&quot;분기에 새로운 코드가 있고 &quot;커밋 수정&quot;및 &quot;diff-fix&quot;분기에 두 개의 독립적 인 수정이 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="1170354586d8db2806a89632eb01397ff1d5b39a" translate="yes" xml:space="preserve">
          <source>We have seen several ways of naming commits already:</source>
          <target state="translated">커밋의 이름을 지정하는 몇 가지 방법이 이미 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea2d131015439270646c4d9deb94b3238eec4d65" translate="yes" xml:space="preserve">
          <source>We have seen that regressions are an important problem, and that &quot;git bisect&quot; has nice features that complement very well practices and other tools, especially test suites, that are generally used to fight regressions. But it might be needed to change some work-flows and (bad) habits to get the most out of it.</source>
          <target state="translated">우리는 회귀가 중요한 문제이며 &quot;git bisect&quot;는 일반적으로 회귀와 싸우는 데 사용되는 다른 도구, 특히 테스트 스위트를 보완하는 훌륭한 기능을 가지고 있음을 알았습니다. 그러나 그것을 최대한 활용하기 위해 일부 작업 흐름과 (나쁜) 습관을 변경해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="58d71328c844eab6bb246a8885f29a926cbaf29b" translate="yes" xml:space="preserve">
          <source>We have seen that test suites and git bisect are very powerful when used together. It can be even more powerful if you can combine them with other systems.</source>
          <target state="translated">우리는 테스트 스위트와 git bisect가 함께 사용될 때 매우 강력하다는 것을 알았습니다. 다른 시스템과 결합 할 수 있다면 더욱 강력해질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dc1429b571e4014b12f464201faf90142f01343" translate="yes" xml:space="preserve">
          <source>We ignore all SVN properties except svn:executable. Any unhandled properties are logged to $GIT_DIR/svn/&amp;lt;refname&amp;gt;/unhandled.log</source>
          <target state="translated">svn : executable을 제외한 모든 SVN 속성은 무시합니다. 처리되지 않은 속성은 $ GIT_DIR / svn / &amp;lt;refname&amp;gt; /unhandled.log에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="5e0e70c2a550cebe0f64341bc25aba4f82846837" translate="yes" xml:space="preserve">
          <source>We said this tutorial shows what plumbing does to help you cope with the porcelain that isn&amp;rsquo;t flushing, but we so far did not talk about how the merge really works. If you are following this tutorial the first time, I&amp;rsquo;d suggest to skip to &quot;Publishing your work&quot; section and come back here later.</source>
          <target state="translated">이 튜토리얼에서는 플러싱되지 않은 도자기에 대처하기 위해 배관이 무엇을하는지 보여 주지만 지금까지 병합이 실제로 어떻게 작동하는지에 대해서는 이야기하지 않았습니다. 이 튜토리얼을 처음 수행하는 경우 &quot;작업 게시&quot;섹션으로 건너 뛰고 나중에 다시 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="038e0426e816e440e5c183b0ccfae9faca0c65b5" translate="yes" xml:space="preserve">
          <source>We saw above that &lt;code&gt;origin&lt;/code&gt; is just a shortcut to refer to the repository that you originally cloned from. This information is stored in Git configuration variables, which you can see using &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;:</source>
          <target state="translated">위에서 본 &lt;code&gt;origin&lt;/code&gt; 은 원래 복제 한 저장소를 나타내는 바로 가기 일뿐입니다. 이 정보는 Git 구성 변수에 저장되며 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 사용하여 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="789eeb5f51968bf21d9746b92623ca08838d8bcb" translate="yes" xml:space="preserve">
          <source>We saw earlier that &quot;git bisect skip&quot; is now using a PRNG to try to avoid areas in the commit graph where commits are untestable. The problem is that sometimes the first bad commit will be in an untestable area.</source>
          <target state="translated">&quot;git bisect skip&quot;은 이제 커밋을 테스트 할 수없는 커밋 그래프의 영역을 피하기 위해 PRNG를 사용하고 있음을 알았습니다. 문제는 때때로 첫 번째 잘못된 커밋이 테스트 할 수없는 영역에 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e6f53989efc34bb4d6e54dcd09f15943b6a8a36c" translate="yes" xml:space="preserve">
          <source>We saw in &lt;a href=&quot;#conflict-resolution&quot;&gt;Getting conflict-resolution help during a merge&lt;/a&gt; that during a merge the index can store multiple versions of a single file (called &quot;stages&quot;). The third column in the &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files[1]&lt;/a&gt; output above is the stage number, and will take on values other than 0 for files with merge conflicts.</source>
          <target state="translated">&lt;a href=&quot;#conflict-resolution&quot;&gt;병합 중 충돌 해결 도움말 얻기&lt;/a&gt; 에서 병합 중 색인이 단일 파일의 여러 버전 ( &quot;스테이지&quot;)을 저장할 수 있다는 것을 알았습니다 . 위의 &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files [1]&lt;/a&gt; 출력 에서 세 번째 열 은 스테이지 번호이며 병합 충돌이있는 파일의 경우 0 이외의 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d5d682276e6a6d081a241de022b4ded4aef9c418" translate="yes" xml:space="preserve">
          <source>We saw in &lt;a href=&quot;#fixing-a-mistake-by-rewriting-history&quot;&gt;Fixing a mistake by rewriting history&lt;/a&gt; that you can replace the most recent commit using</source>
          <target state="translated">가장 최근의 커밋을 대체 할 수있는 &lt;a href=&quot;#fixing-a-mistake-by-rewriting-history&quot;&gt;기록&lt;/a&gt; 을 다시 작성하여 실수 를 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="aafdc07c8e0d9b297fcdd505608f380ef754ed45" translate="yes" xml:space="preserve">
          <source>We saw in part one of the tutorial that commits have names like this. It turns out that every object in the Git history is stored under a 40-digit hex name. That name is the SHA-1 hash of the object&amp;rsquo;s contents; among other things, this ensures that Git will never store the same data twice (since identical data is given an identical SHA-1 name), and that the contents of a Git object will never change (since that would change the object&amp;rsquo;s name as well). The 7 char hex strings here are simply the abbreviation of such 40 character long strings. Abbreviations can be used everywhere where the 40 character strings can be used, so long as they are unambiguous.</source>
          <target state="translated">우리는 튜토리얼의 한 부분에서 커밋이 이와 같은 이름을 갖는 것을 보았습니다. Git 히스토리의 모든 객체는 40 자리 16 진수 이름으로 저장됩니다. 그 이름은 객체 내용의 SHA-1 해시입니다. 무엇보다도 이것은 Git이 동일한 데이터를 두 번 저장하지 않도록하고 (동일한 데이터에 동일한 SHA-1 이름이 주어지기 때문에) Git 객체의 내용이 절대로 변경되지 않도록합니다 (오브젝트의 이름도 변경하기 때문에) ). 여기서 7 자리 16 진수 문자열은 단순히 40 자 길이의 약어입니다. 40 개의 문자열을 사용할 수있는 곳이라면 어디에서나 약어를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09c046487d09b436218fe11aa8c1087251442281" translate="yes" xml:space="preserve">
          <source>We separate the porcelain commands into the main commands and some ancillary user utilities.</source>
          <target state="translated">우리는 도자기 명령을 기본 명령과 일부 보조 사용자 유틸리티로 분리합니다.</target>
        </trans-unit>
        <trans-unit id="f2e875357a5ce85901234308b841a3138ebd851b" translate="yes" xml:space="preserve">
          <source>We should point out that &quot;habitually&quot; (regularly for no real reason) merging an integration branch into your topics &amp;mdash; and by extension, merging anything upstream into anything downstream on a regular basis &amp;mdash; is frowned upon:</source>
          <target state="translated">우리는 통합 지점을 당신의 주제에 합병시키는 &quot;거의&quot;(일반적으로 아무 이유없이) 정기적으로 다운 스트림에 상류의 것을 합병시키는 것을 다음과 같이 눈살을 찌푸리게합니다.</target>
        </trans-unit>
        <trans-unit id="3b0c2056ade966758c96efbd333ad03c787ca3ac" translate="yes" xml:space="preserve">
          <source>We start with one specialized tool that is useful for finding the commit that introduced a bug into a project.</source>
          <target state="translated">프로젝트에 버그를 도입 한 커밋을 찾는 데 유용한 하나의 특수 도구로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="3bb7fbe62fd9b3fa1a7f67f6a431251fe7b02079" translate="yes" xml:space="preserve">
          <source>We start with the most important, the &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt; and the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">가장 중요한 &lt;a href=&quot;#def_object_database&quot;&gt;객체 데이터베이스&lt;/a&gt; 와 &lt;a href=&quot;#def_index&quot;&gt;index로 시작&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="fa1acdd625946113b786a5983b045431892f2e96" translate="yes" xml:space="preserve">
          <source>We supposed in the previous examples that the &quot;good&quot; commits were ancestors of the &quot;bad&quot; commit. But this is not a requirement of &quot;git bisect&quot;.</source>
          <target state="translated">앞의 예에서 &quot;좋은&quot;커밋은 &quot;나쁜&quot;커밋의 조상이라고 가정했습니다. 그러나 이것은 &quot;git bisect&quot;의 요구 사항은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="09e675bfb62532c536d372645ebddf19b07c5684" translate="yes" xml:space="preserve">
          <source>We want to make &lt;code&gt;topic&lt;/code&gt; forked from branch &lt;code&gt;master&lt;/code&gt;; for example, because the functionality on which &lt;code&gt;topic&lt;/code&gt; depends was merged into the more stable &lt;code&gt;master&lt;/code&gt; branch. We want our tree to look like this:</source>
          <target state="translated">우리는 브랜치 &lt;code&gt;master&lt;/code&gt; 로부터 &lt;code&gt;topic&lt;/code&gt; 를 분기 시키려고합니다 . 예를 들어, &lt;code&gt;topic&lt;/code&gt; 의존 하는 기능 이보다 안정적인 &lt;code&gt;master&lt;/code&gt; 브랜치 로 병합 되었기 때문 입니다. 우리는 나무가 다음과 같이 보이기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="0fa006b18282abd83f954d3423dfd83f70f68c0d" translate="yes" xml:space="preserve">
          <source>We will introduce some tools that can help you do this, explain how to use them, and then explain some of the problems that can arise because you are rewriting history.</source>
          <target state="translated">이 작업을 수행하는 데 도움이되는 몇 가지 도구를 소개하고 사용 방법을 설명한 다음 기록을 다시 작성하여 발생할 수있는 몇 가지 문제에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e34d86d215639adac5ecaa74d7f70d803a2ef9de" translate="yes" xml:space="preserve">
          <source>We will sometimes represent Git history using diagrams like the one below. Commits are shown as &quot;o&quot;, and the links between them with lines drawn with - / and \. Time goes left to right:</source>
          <target state="translated">때때로 아래와 같은 다이어그램을 사용하여 Git 히스토리를 표현할 것입니다. 커밋은 &quot;o&quot;로 표시되고-/ 및 \로 그려진 선으로 링크가 연결됩니다. 시간은 왼쪽에서 오른쪽으로갑니다.</target>
        </trans-unit>
        <trans-unit id="ab9fd84ced67b4e6059fb12091ba4144199c5397" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll assume that the problem is a single missing or corrupted blob, which is sometimes a solvable problem. (Recovering missing trees and especially commits is &lt;strong&gt;much&lt;/strong&gt; harder).</source>
          <target state="translated">우리는 문제가 하나의 누락되거나 손상된 얼룩이라고 가정하며 때로는 해결할 수있는 문제입니다. 누락 된 트리 및 특히 커밋을 복구하는 것이 &lt;strong&gt;훨씬&lt;/strong&gt; 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="2aa7b1ec194976812ce4b6b3f7e0ba34eba549a8" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll keep this simple and stupid, so we&amp;rsquo;ll start off with populating a few trivial files just to get a feel for it.</source>
          <target state="translated">우리는 이것을 간단하고 어리석게 유지할 것이므로, 간단한 파일을 채우는 것으로 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="2d4db37414a68811cd95f44af4830929ada62273" translate="yes" xml:space="preserve">
          <source>Webserver configuration</source>
          <target state="translated">웹 서버 구성</target>
        </trans-unit>
        <trans-unit id="c0f36d74c982d11ffbdfaa17b6ab39308ec52a2f" translate="yes" xml:space="preserve">
          <source>Webserver configuration with multiple projects' root</source>
          <target state="translated">여러 프로젝트 루트가있는 웹 서버 구성</target>
        </trans-unit>
        <trans-unit id="ef6d4f2b2672206d0b50ce512c5b9cc1369fe95f" translate="yes" xml:space="preserve">
          <source>What an alias file in each format looks like can be found in the documentation of the email program of the same name. The differences and limitations from the standard formats are described below:</source>
          <target state="translated">각 형식의 별명 파일은 동일한 이름의 이메일 프로그램 문서에서 찾을 수 있습니다. 표준 형식과의 차이점과 제한 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fa6325f935566c907b8b84855ddf6b390a1827e3" translate="yes" xml:space="preserve">
          <source>What are the 7 digits of hex that Git responded to the commit with?</source>
          <target state="translated">Git이 커밋에 응답 한 16 진수의 7 자리 숫자는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="1fd975aafde95925b137d84d61ec01ca393e6fe1" translate="yes" xml:space="preserve">
          <source>What does &lt;code&gt;http.postBuffer&lt;/code&gt; really do?</source>
          <target state="translated">&lt;code&gt;http.postBuffer&lt;/code&gt; 는 실제로 무엇을 합니까?</target>
        </trans-unit>
        <trans-unit id="5fb651419665147da76edfca56099f33ccd0e645" translate="yes" xml:space="preserve">
          <source>What does this mean?</source>
          <target state="translated">이것은 무엇을 의미 하는가?</target>
        </trans-unit>
        <trans-unit id="b77fdbd3385bc488b50aa891b5b4c124304a8f69" translate="yes" xml:space="preserve">
          <source>What is interesting too is that end users that are reporting bugs (or QA people that reproduced a bug) have access to the environment where the bug happens. So they can often more easily reproduce a regression. And if they can bisect, then more information will be extracted from the environment where the bug happens, which means that it will be easier to understand and then fix the bug.</source>
          <target state="translated">흥미로운 점은 버그를보고하는 최종 사용자 (또는 버그를 재현 한 QA 담당자)가 버그가 발생한 환경에 액세스 할 수 있다는 것입니다. 따라서 회귀를보다 쉽게 ​​재현 할 수 있습니다. 그리고 이등분 할 수 있다면 버그가 발생한 환경에서 더 많은 정보가 추출되므로 버그를 이해하고 수정하기가 더 쉬워 질 것입니다.</target>
        </trans-unit>
        <trans-unit id="90fc9e2a4fe1cfe396d558392d2a0a41db650977" translate="yes" xml:space="preserve">
          <source>What kinds of problems can occur when merging long-lived branches with squash merges?</source>
          <target state="translated">오래 지속되는 분기를 스쿼시 병합과 병합 할 때 어떤 종류의 문제가 발생할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="549056214cd4b23720c4559829b5b36cc5cf6d0c" translate="yes" xml:space="preserve">
          <source>What next?</source>
          <target state="translated">다음은?</target>
        </trans-unit>
        <trans-unit id="fe77441e9cc191fb4a5181d6f98e51e7bf6ce4ab" translate="yes" xml:space="preserve">
          <source>What people don&amp;rsquo;t get is that this is a situation where the &quot;end node principle&quot; applies. When you have limited resources (here: developers) you don&amp;rsquo;t push the bulk of the burden upon them. Instead you push things out to the resource you have a lot of, the end nodes (here: users), so that the situation actually scales.</source>
          <target state="translated">사람들이 얻지 못하는 것은 이것이 &quot;엔드 노드 원칙&quot;이 적용되는 상황이라는 것입니다. 리소스가 제한되어있는 경우 (여기 : 개발자) 해당 리소스에 대한 많은 부담을주지 않습니다. 대신 상황을 실제로 확장 할 수 있도록 많은 최종 노드 (여기서는 사용자)가있는 리소스로 작업을 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="4adfddfda3ea247cced4c30354a360a26072f719" translate="yes" xml:space="preserve">
          <source>What should I put in &lt;code&gt;user.name&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;user.name&lt;/code&gt; 에 무엇을 넣어야 합니까?</target>
        </trans-unit>
        <trans-unit id="e4950cd435094a3f200db11a5c1b540d80d04769" translate="yes" xml:space="preserve">
          <source>What should you do when you tag a wrong commit and you would want to re-tag?</source>
          <target state="translated">잘못된 커밋에 태그를 지정하고 다시 태그를 지정하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="049920ec0574fb80b08ccee259e5814b007cd44c" translate="yes" xml:space="preserve">
          <source>What the -p option produces is slightly different from the traditional diff format:</source>
          <target state="translated">-p 옵션이 생성하는 내용은 기존의 diff 형식과 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e27b60d4391d6c41de480e30a2d0df50a6723ae8" translate="yes" xml:space="preserve">
          <source>What to do when a push fails</source>
          <target state="translated">푸시 실패시 수행 할 작업</target>
        </trans-unit>
        <trans-unit id="42a1dbf4390cedcf2f183fba444335bae8d5ae11" translate="yes" xml:space="preserve">
          <source>What you chose are then highlighted with &lt;code&gt;*&lt;/code&gt;, like this:</source>
          <target state="translated">선택한 내용은 다음과 같이 &lt;code&gt;*&lt;/code&gt; 로 강조 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="3ef265c44655b5cf934f7913a368fdf3c53af8a9" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s the recommended way to store files in Git?</source>
          <target state="translated">Git에 파일을 저장하는 권장 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e11a716b5dc9d27d9966b39b2c63b32b4c67e627" translate="yes" xml:space="preserve">
          <source>When &amp;lt;rev&amp;gt; is not specified, the command annotates the changes starting backwards from the working tree copy. This flag makes the command pretend as if the working tree copy has the contents of the named file (specify &lt;code&gt;-&lt;/code&gt; to make the command read from the standard input).</source>
          <target state="translated">&amp;lt;rev&amp;gt;를 지정하지 않으면 명령은 작업 트리 사본에서 거꾸로 시작하여 변경 사항에 주석을 달 수 있습니다. 이 플래그는 작업 트리 사본에 명명 된 파일의 내용이있는 것처럼 명령을 가장합니다 (지정 &lt;code&gt;-&lt;/code&gt; 표준 입력에서 명령을 읽도록 지정 ).</target>
        </trans-unit>
        <trans-unit id="df8212af8d2323e7260f5fa3c4bc0bbc714643ff" translate="yes" xml:space="preserve">
          <source>When --fork-point is active, &lt;code&gt;fork_point&lt;/code&gt; will be used instead of &amp;lt;upstream&amp;gt; to calculate the set of commits to rebase, where &lt;code&gt;fork_point&lt;/code&gt; is the result of &lt;code&gt;git merge-base --fork-point &amp;lt;upstream&amp;gt;
&amp;lt;branch&amp;gt;&lt;/code&gt; command (see &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base[1]&lt;/a&gt;). If &lt;code&gt;fork_point&lt;/code&gt; ends up being empty, the &amp;lt;upstream&amp;gt; will be used as a fallback.</source>
          <target state="translated">--fork-point가 활성화되면 &amp;lt;upstream&amp;gt; 대신 &lt;code&gt;fork_point&lt;/code&gt; 를 사용하여 rebase에 대한 커밋 세트를 계산합니다. 여기서 &lt;code&gt;fork_point&lt;/code&gt; 는 &lt;code&gt;git merge-base --fork-point &amp;lt;upstream&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt; 명령의 결과입니다 ( 참조 &lt;a href=&quot;git-merge-base&quot;&gt;이눔 병합 계를 [1]&lt;/a&gt; ). 경우 &lt;code&gt;fork_point&lt;/code&gt; 끝까지 비어있는,의 &amp;lt;상류&amp;gt;는 대체해서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0b903c4e9a3738f389f65549fe23dcd21fd8909d" translate="yes" xml:space="preserve">
          <source>When --graph is not used, all history branches are flattened which can make it hard to see that the two consecutive commits do not belong to a linear branch. This option puts a barrier in between them in that case. If &lt;code&gt;&amp;lt;barrier&amp;gt;&lt;/code&gt; is specified, it is the string that will be shown instead of the default one.</source>
          <target state="translated">--graph를 사용하지 않으면 모든 히스토리 브랜치가 평평 해져 두 개의 연속 커밋이 선형 브랜치에 속하지 않음을 알기가 어렵습니다. 이 경우이 옵션을 사용하면 그 사이에 장벽이 생깁니다. 경우 &lt;code&gt;&amp;lt;barrier&amp;gt;&lt;/code&gt; 지정, 대신 기본 하나의 표시 될 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="24ff3c267435a7dcecd3166ed52f8210a7c7f0de" translate="yes" xml:space="preserve">
          <source>When --stdout is specified then progress report is displayed during the object count and compression phases but inhibited during the write-out phase. The reason is that in some cases the output stream is directly linked to another command which may wish to display progress status of its own as it processes incoming pack data. This flag is like --progress except that it forces progress report for the write-out phase as well even if --stdout is used.</source>
          <target state="translated">--stdout을 지정하면 객체 수 및 압축 단계에서 진행률 보고서가 표시되지만 쓰기 단계에서는 금지됩니다. 그 이유는 출력 스트림이 다른 명령에 직접 연결되어 들어오는 팩 데이터를 처리 할 때 자체의 진행 상태를 표시하고자 할 수 있기 때문입니다. 이 플래그는 --stdout을 사용하더라도 쓰기 단계에 대한 진행률 보고서를 강제한다는 점을 제외하면 --progress와 같습니다.</target>
        </trans-unit>
        <trans-unit id="d3e80ca53bd7d57db503ac84208eff0dbe6d901f" translate="yes" xml:space="preserve">
          <source>When -k is not in effect, all leading strings bracketed with &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; pairs are stripped. This option limits the stripping to only the pairs whose bracketed string contains the word &quot;PATCH&quot;.</source>
          <target state="translated">-k가 적용되지 않으면 &lt;code&gt;[&lt;/code&gt; 및 &lt;code&gt;]&lt;/code&gt; 쌍으로 묶인 모든 선행 문자열 이 제거됩니다. 이 옵션은 괄호로 묶인 문자열에 &quot;PATCH&quot;라는 단어가 포함 된 쌍으로 만 스트립을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="882475218cb0a9fc17e76a3d4266386adec5dd71" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;$@&quot;&lt;/code&gt; is &lt;code&gt;-h&lt;/code&gt; or &lt;code&gt;--help&lt;/code&gt; in the above example, the following usage text would be shown:</source>
          <target state="translated">때 &lt;code&gt;&quot;$@&quot;&lt;/code&gt; 입니다 &lt;code&gt;-h&lt;/code&gt; 또는 &lt;code&gt;--help&lt;/code&gt; 위의 예에서, 다음 사용 텍스트가 표시 될 것입니다 :</target>
        </trans-unit>
        <trans-unit id="d78a0cbb0812363470a0c64a4a94d40dd1da90bb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--batch-all-objects&lt;/code&gt; is in use, visit objects in an order which may be more efficient for accessing the object contents than hash order. The exact details of the order are unspecified, but if you do not require a specific order, this should generally result in faster output, especially with &lt;code&gt;--batch&lt;/code&gt;. Note that &lt;code&gt;cat-file&lt;/code&gt; will still show each object only once, even if it is stored multiple times in the repository.</source>
          <target state="translated">때 &lt;code&gt;--batch-all-objects&lt;/code&gt; 사용하고, 방문은 해시 위해보다 객체의 내용을 액세스하기위한보다 효율적으로 할 수 순서로 객체. 주문의 정확한 세부 사항은 지정되어 있지 않지만 특정 주문이 필요하지 않은 경우 일반적으로 특히 &lt;code&gt;--batch&lt;/code&gt; 를 사용 하여 더 빠른 출력을 얻을 수 있습니다. 참고 &lt;code&gt;cat-file&lt;/code&gt; 이 저장소에 여러 번 저장되어있는 경우에도, 여전히 한 번만 각 개체를 보여줄 것이다.</target>
        </trans-unit>
        <trans-unit id="95919047a579b82415a0ddd6c6f601bfbb7dc80f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--check&lt;/code&gt; is in effect, or when applying the patch (which is the default when none of the options that disables it is in effect), make sure the patch is applicable to what the current index file records. If the file to be patched in the working tree is not up to date, it is flagged as an error. This flag also causes the index file to be updated.</source>
          <target state="translated">때 &lt;code&gt;--check&lt;/code&gt; 가 유효하거나 패치를 적용 할 때, (기본값 인이 유효 비활성화하는 옵션 중 어느 것도 경우)도하지 않습니다 확인 패치는 무엇 현재 인덱스 파일 레코드에 적용 할 수있다. 작업 트리에 패치 할 파일이 최신이 아닌 경우 오류로 플래그가 지정됩니다. 이 플래그는 또한 색인 파일이 갱신되도록합니다.</target>
        </trans-unit>
        <trans-unit id="526cf7ed548b3415806841ff6b0e065a944a8f5e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--compose&lt;/code&gt; is used, git send-email will use the From, Subject, and In-Reply-To headers specified in the message. If the body of the message (what you type after the headers and a blank line) only contains blank (or Git: prefixed) lines, the summary won&amp;rsquo;t be sent, but From, Subject, and In-Reply-To headers will be used unless they are removed.</source>
          <target state="translated">때 &lt;code&gt;--compose&lt;/code&gt; 가 사용되며, 자식 전송 - 이메일을 조건으로,부터를 사용하고,에서가-회신에 메시지에 지정된 헤더. 메시지 본문 (머리글과 빈 줄 다음에 입력 한 내용)에 빈 (또는 Git : 접두사) 줄만 포함 된 경우 요약이 전송되지 않지만 From, Subject 및 In-Reply-To 헤더는 제거하지 않으면 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="46dc43993fdd7156fca21e87a205fc0f333f2d9a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--cone&lt;/code&gt; is provided, the &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; setting is also set, allowing for better performance with a limited set of patterns (see &lt;code&gt;CONE PATTERN SET&lt;/code&gt; below).</source>
          <target state="translated">때 &lt;code&gt;--cone&lt;/code&gt; 가 제공되면, &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; 의 설정은 패턴 (참조 제한된와 더 나은 성능을 위해 수 있도록 설정되어 &lt;code&gt;CONE PATTERN SET&lt;/code&gt; 아래 참조).</target>
        </trans-unit>
        <trans-unit id="ac6d168ca5e25a70ab78d5a850025a2ad07d998b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--exclude&lt;/code&gt; and &lt;code&gt;--include&lt;/code&gt; patterns are used, they are examined in the order they appear on the command line, and the first match determines if a patch to each path is used. A patch to a path that does not match any include/exclude pattern is used by default if there is no include pattern on the command line, and ignored if there is any include pattern.</source>
          <target state="translated">경우 &lt;code&gt;--exclude&lt;/code&gt; 및 &lt;code&gt;--include&lt;/code&gt; 패턴이 사용되며, 그들이 명령 행에 나타나는 순서대로 시험하고, 각 경로에 대한 패치가 이용되는 경우 첫 번째 일치를 판단한다. 포함 / 제외 패턴과 일치하지 않는 경로에 대한 패치는 명령 행에 포함 패턴이없는 경우 기본적으로 사용되며 포함 패턴이 있으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="febfb7b902fc970c3396f3068a5c66e59c7ec8ea" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--notes&lt;/code&gt; is in effect, the message from the notes is matched as if it were part of the log message.</source>
          <target state="translated">때 &lt;code&gt;--notes&lt;/code&gt; 이 적용되는, 노트에서 메시지가 로그 메시지의 일부인 것처럼 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b84c74a91c715b3bf1b4e927529a07a15aed9721" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--numstat&lt;/code&gt; has been given, do not munge pathnames, but use a NUL-terminated machine-readable format.</source>
          <target state="translated">때 &lt;code&gt;--numstat&lt;/code&gt; 이 주어졌다,하지로 찾으면 경로 이름을하지만, NUL 종료 시스템에서 읽을 수있는 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d371e700585c518084c33d84fef0af43b13c3439" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--raw&lt;/code&gt;, &lt;code&gt;--numstat&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt; or &lt;code&gt;--name-status&lt;/code&gt; has been given, do not munge pathnames and use NULs as output field terminators.</source>
          <target state="translated">때 &lt;code&gt;--raw&lt;/code&gt; , &lt;code&gt;--numstat&lt;/code&gt; , &lt;code&gt;--name-only&lt;/code&gt; 또는 &lt;code&gt;--name-status&lt;/code&gt; 주어졌다, 출력 필드 터미네이터로하지로 찾으면 경로 이름과 사용 NUL을 해.</target>
        </trans-unit>
        <trans-unit id="e163d548a1a886a531d60736c2ba3e851388a10a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--root&lt;/code&gt; is specified the initial commit will be shown as a big creation event. This is equivalent to a diff against the NULL tree.</source>
          <target state="translated">때 &lt;code&gt;--root&lt;/code&gt; 이 초기 커밋 지정되어 큰 생성 이벤트로 표시됩니다. 이것은 NULL 트리에 대한 diff와 같습니다.</target>
        </trans-unit>
        <trans-unit id="8183759ad974b12070a46362dbaa27565534e645" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--show-pulls&lt;/code&gt; is paired with &lt;code&gt;--simplify-merges&lt;/code&gt;, the graph includes all of the necessary information:</source>
          <target state="translated">경우 &lt;code&gt;--show-pulls&lt;/code&gt; 페어링되어 &lt;code&gt;--simplify-merges&lt;/code&gt; 그래프 필요한 모든 정보를 포함한다 :</target>
        </trans-unit>
        <trans-unit id="5b88ba2b22685842fbd9b8b75fb2959da8ea9e8b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--stdin&lt;/code&gt; is specified, the command does not take &amp;lt;tree-ish&amp;gt; arguments from the command line. Instead, it reads lines containing either two &amp;lt;tree&amp;gt;, one &amp;lt;commit&amp;gt;, or a list of &amp;lt;commit&amp;gt; from its standard input. (Use a single space as separator.)</source>
          <target state="translated">때 &lt;code&gt;--stdin&lt;/code&gt; 옵션이 지정되면, 명령은 명령 줄에서 &amp;lt;트리 틱&amp;gt; 인수를 고려하지 않습니다. 대신 표준 입력에서 두 개의 &amp;lt;tree&amp;gt;, 하나의 &amp;lt;commit&amp;gt; 또는 &amp;lt;commit&amp;gt; 목록을 포함하는 행을 읽습니다. (단일 공백을 구분 기호로 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="c23ac888d8fe422c1532e2aed10782043e7c6859" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;--temp&lt;/code&gt; is used (or implied by &lt;code&gt;--stage=all&lt;/code&gt;) &lt;code&gt;git checkout-index&lt;/code&gt; will create a temporary file for each index entry being checked out. The index will not be updated with stat information. These options can be useful if the caller needs all stages of all unmerged entries so that the unmerged files can be processed by an external merge tool.</source>
          <target state="translated">때 &lt;code&gt;--temp&lt;/code&gt; 이 사용 (또는 묵시적으로 &lt;code&gt;--stage=all&lt;/code&gt; ) &lt;code&gt;git checkout-index&lt;/code&gt; 각 인덱스 항목의 존재에 대한 임시 파일을 만듭니다 체크 아웃. 인덱스는 통계 정보로 업데이트되지 않습니다. 이러한 옵션은 호출자가 병합되지 않은 모든 항목의 모든 단계를 필요로하여 병합되지 않은 파일을 외부 병합 도구로 처리 할 수있는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5c97ac9560dda79ead627bde39274f79b6e5dd8a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-S&lt;/code&gt; or &lt;code&gt;-G&lt;/code&gt; are used without &lt;code&gt;--pickaxe-all&lt;/code&gt;, only filepairs that match their respective criterion are kept in the output. When &lt;code&gt;--pickaxe-all&lt;/code&gt; is used, if even one filepair matches their respective criterion in a changeset, the entire changeset is kept. This behavior is designed to make reviewing changes in the context of the whole changeset easier.</source>
          <target state="translated">경우 &lt;code&gt;-S&lt;/code&gt; 또는 &lt;code&gt;-G&lt;/code&gt; 이 없이 사용 &lt;code&gt;--pickaxe-all&lt;/code&gt; , 각각의 기준에 맞는 단지 filepairs 출력으로 유지된다. 경우 &lt;code&gt;--pickaxe-all&lt;/code&gt; 사용 되더라도 하나 filepair가 변경 집합에서 각 기준과 일치하는 경우, 전체 변경 집합이 보존된다. 이 동작은 전체 변경 집합의 컨텍스트에서 변경 사항을 쉽게 검토 할 수 있도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="b7230470efbcbdb8b4c76cdcdcf3272fde68030f" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-S&lt;/code&gt; or &lt;code&gt;-G&lt;/code&gt; finds a change, show all the changes in that changeset, not just the files that contain the change in &amp;lt;string&amp;gt;.</source>
          <target state="translated">때 &lt;code&gt;-S&lt;/code&gt; 또는 &lt;code&gt;-G&lt;/code&gt; 이 변화를 발견, 그 변경 집합의 모든 변경, &amp;lt;문자열&amp;gt;의 변화를 포함 할뿐만 아니라 파일을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b52ce403c26e2631158c50ee6bd3c17065ed82dc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-u&lt;/code&gt; option is not used, untracked files and directories are shown (i.e. the same as specifying &lt;code&gt;normal&lt;/code&gt;), to help you avoid forgetting to add newly created files. Because it takes extra work to find untracked files in the filesystem, this mode may take some time in a large working tree. Consider enabling untracked cache and split index if supported (see &lt;code&gt;git update-index --untracked-cache&lt;/code&gt; and &lt;code&gt;git update-index
--split-index&lt;/code&gt;), Otherwise you can use &lt;code&gt;no&lt;/code&gt; to have &lt;code&gt;git status&lt;/code&gt; return more quickly without showing untracked files.</source>
          <target state="translated">때 &lt;code&gt;-u&lt;/code&gt; 옵션을 사용하지, 비 추적 파일 및 디렉토리 (지정하는 것과 즉, 같은 표시됩니다 &lt;code&gt;normal&lt;/code&gt; 이 새로 생성 된 파일을 추가 할 잊는 피할 수 있도록,). 파일 시스템에서 추적되지 않은 파일을 찾으려면 추가 작업이 필요하므로이 모드는 큰 작업 트리에서 시간이 걸릴 수 있습니다. 지원되는 경우 추적되지 않은 캐시 및 분할 인덱스를 활성화하는 것이 &lt;code&gt;git update-index --untracked-cache&lt;/code&gt; ( git update-index --untracked-cache 및 &lt;code&gt;git update-index --split-index&lt;/code&gt; ). 그렇지 않으면 추적되지 않은 파일을 표시하지 않고 &lt;code&gt;git status&lt;/code&gt; 더 빨리 반환 하도록 &lt;code&gt;no&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97c7c816e31485397947c4cd78f79e742f80ec39" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;-z&lt;/code&gt; output option is in effect, the output is formatted this way:</source>
          <target state="translated">때 &lt;code&gt;-z&lt;/code&gt; 출력 옵션이 적용되는 출력이 방법을 포맷 :</target>
        </trans-unit>
        <trans-unit id="2bf71954fc8fac90c9030e3b9b1232971580d22a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;FETCH_HEAD&lt;/code&gt; (and no other commit) is specified, the branches recorded in the &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; file by the previous invocation of &lt;code&gt;git fetch&lt;/code&gt; for merging are merged to the current branch.</source>
          <target state="translated">때 &lt;code&gt;FETCH_HEAD&lt;/code&gt; (그리고 다른 커밋하지)가 지정되면, 기록 가지 &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; 의 이전 호출에 의해 파일 &lt;code&gt;git fetch&lt;/code&gt; 현재 브랜치에 병합 병합.</target>
        </trans-unit>
        <trans-unit id="30aaf2e9dd06a0335c5f1cb4c0791345a6730170" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; is enabled, the input list is considered a list of directories instead of sparse-checkout patterns. The command writes patterns to the sparse-checkout file to include all files contained in those directories (recursively) as well as files that are siblings of ancestor directories. The input format matches the output of &lt;code&gt;git ls-tree --name-only&lt;/code&gt;. This includes interpreting pathnames that begin with a double quote (&quot;) as C-style quoted strings.</source>
          <target state="translated">때 &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; 가 활성화되어, 입력리스트 대신 스파 스 체크 아웃 패턴의 디렉토리 목록 간주됩니다. 이 명령은 스파 스 체크 아웃 파일에 패턴을 작성하여 해당 디렉토리에 포함 된 모든 파일 (재귀 적으로)과 상위 디렉토리의 형제 파일을 포함합니다. 입력 형식은 &lt;code&gt;git ls-tree --name-only&lt;/code&gt; 의 출력과 일치합니다 . 여기에는 큰 따옴표 ( &quot;)로 시작하는 경로 이름을 C 스타일의 인용 문자열로 해석하는 것이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a79eb2995cdbf5e2d0a3c4b4e62d970b5798ea30" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; is enabled, the config file &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; is read after &lt;code&gt;.git/config&lt;/code&gt; is.</source>
          <target state="translated">때 &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; 가 활성화되어, 설정 파일 &lt;code&gt;.git/worktrees/&amp;lt;id&amp;gt;/config.worktree&lt;/code&gt; 후에 읽어 &lt;code&gt;.git/config&lt;/code&gt; 에 있다.</target>
        </trans-unit>
        <trans-unit id="093107f57324ea8ddf834562dc5da735634ce1c2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fetch.fsckObjects&lt;/code&gt; or &lt;code&gt;receive.fsckObjects&lt;/code&gt; are not set, the value of this variable is used instead. Defaults to false.</source>
          <target state="translated">경우 &lt;code&gt;fetch.fsckObjects&lt;/code&gt; 또는 &lt;code&gt;receive.fsckObjects&lt;/code&gt; 가 설정되지 않은 경우,이 변수의 값이 대신 사용된다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="f0f4e4ab298d72d3ce878991ffe1cd2532ffab74" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fetch.unpackLimit&lt;/code&gt; or &lt;code&gt;receive.unpackLimit&lt;/code&gt; are not set, the value of this variable is used instead. The default value is 100.</source>
          <target state="translated">경우 &lt;code&gt;fetch.unpackLimit&lt;/code&gt; 또는 &lt;code&gt;receive.unpackLimit&lt;/code&gt; 가 설정되지 않은 경우,이 변수의 값이 대신 사용된다. 기본값은 100입니다.</target>
        </trans-unit>
        <trans-unit id="0f43e1a31ad9e45784cdafec68b8141e1a628402" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; is set, errors can be switched to warnings and vice versa by configuring the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; setting where the &lt;code&gt;&amp;lt;msg-id&amp;gt;&lt;/code&gt; is the fsck message ID and the value is one of &lt;code&gt;error&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt;. For convenience, fsck prefixes the error/warning with the message ID, e.g. &quot;missingEmail: invalid author/committer line - missing email&quot; means that setting &lt;code&gt;fsck.missingEmail = ignore&lt;/code&gt; will hide that issue.</source>
          <target state="translated">경우 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 설정 오류는 마찬가지 구성하여 경고 및 부사로 전환 될 수 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 설정 여기서 &lt;code&gt;&amp;lt;msg-id&amp;gt;&lt;/code&gt; fsck를 메시지 ID이고, 값 중 하나 인 &lt;code&gt;error&lt;/code&gt; , &lt;code&gt;warn&lt;/code&gt; 또는 &lt;code&gt;ignore&lt;/code&gt; . 편의상 fsck는 오류 / 경고에 메시지 ID가 접두어로 붙습니다. 예를 들어 &quot;missingEmail : 잘못된 작성자 / 커미터 라인-이메일 누락&quot;은 &lt;code&gt;fsck.missingEmail = ignore&lt;/code&gt; 를 설정 하면 해당 문제가 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="ce3f108ee8253a42ecb067bc1a011bcbcd3ad290" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git apply&lt;/code&gt; is used as a &quot;better GNU patch&quot;, the user can pass the &lt;code&gt;--unsafe-paths&lt;/code&gt; option to override this safety check. This option has no effect when &lt;code&gt;--index&lt;/code&gt; or &lt;code&gt;--cached&lt;/code&gt; is in use.</source>
          <target state="translated">때 &lt;code&gt;git apply&lt;/code&gt; 는 &quot;더 나은 GNU 패치&quot;로 사용하는 경우, 사용자는 통과 할 수 &lt;code&gt;--unsafe-paths&lt;/code&gt; 이 안전 점검을 무시하는 옵션을 선택합니다. &lt;code&gt;--index&lt;/code&gt; 또는 &lt;code&gt;--cached&lt;/code&gt; 를 사용중인 경우이 옵션은 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="dea5ce8f581717a21d1ee89e4952655599f11488" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git difftool&lt;/code&gt; is invoked with this tool (either through the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;--tool&lt;/code&gt; option or the &lt;code&gt;diff.tool&lt;/code&gt; configuration variable) the configured command line will be invoked with the following variables available: &lt;code&gt;$LOCAL&lt;/code&gt; is set to the name of the temporary file containing the contents of the diff pre-image and &lt;code&gt;$REMOTE&lt;/code&gt; is set to the name of the temporary file containing the contents of the diff post-image. &lt;code&gt;$MERGED&lt;/code&gt; is the name of the file which is being compared. &lt;code&gt;$BASE&lt;/code&gt; is provided for compatibility with custom merge tool commands and has the same value as &lt;code&gt;$MERGED&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git difftool&lt;/code&gt; 이이 도구로 호출 되면 ( &lt;code&gt;-t&lt;/code&gt; 또는 &lt;code&gt;--tool&lt;/code&gt; 옵션 또는 &lt;code&gt;diff.tool&lt;/code&gt; 구성 변수를 통해) 다음 명령을 사용하여 구성된 명령 행이 호출됩니다. &lt;code&gt;$LOCAL&lt;/code&gt; 은 임시 이름으로 설정됩니다. diff pre-image의 내용이 포함 된 파일 및 &lt;code&gt;$REMOTE&lt;/code&gt; 는 diff post-image의 내용이 포함 된 임시 파일의 이름으로 설정됩니다. &lt;code&gt;$MERGED&lt;/code&gt; 는 비교중인 파일의 이름입니다. &lt;code&gt;$BASE&lt;/code&gt; 는 사용자 정의 병합 도구 명령과의 호환성을 위해 제공되며 &lt;code&gt;$MERGED&lt;/code&gt; 와 동일한 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="02bc7953c8eb819402a97fdb05db86103d3e94f0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is run with explicit branches and/or tags to fetch on the command line, e.g. &lt;code&gt;git fetch origin master&lt;/code&gt;, the &amp;lt;refspec&amp;gt;s given on the command line determine what are to be fetched (e.g. &lt;code&gt;master&lt;/code&gt; in the example, which is a short-hand for &lt;code&gt;master:&lt;/code&gt;, which in turn means &quot;fetch the &lt;code&gt;master&lt;/code&gt; branch but I do not explicitly say what remote-tracking branch to update with it from the command line&quot;), and the example command will fetch &lt;code&gt;only&lt;/code&gt; the &lt;code&gt;master&lt;/code&gt; branch. The &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values determine which remote-tracking branch, if any, is updated. When used in this way, the &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values do not have any effect in deciding &lt;code&gt;what&lt;/code&gt; gets fetched (i.e. the values are not used as refspecs when the command-line lists refspecs); they are only used to decide &lt;code&gt;where&lt;/code&gt; the refs that are fetched are stored by acting as a mapping.</source>
          <target state="translated">때 &lt;code&gt;git fetch&lt;/code&gt; , 명령 행에서 가져 오기 위해 명시 적 지점 및 / 또는 태그 실행 예를 들어 &lt;code&gt;git fetch origin master&lt;/code&gt; 의 &amp;lt;refspec&amp;gt;의 (가져온 것으로 예를 들어 어떤 결정 명령 행에 주어진 &lt;code&gt;master&lt;/code&gt; 인 예에서 에 대한 간략 &lt;code&gt;master:&lt;/code&gt; 회전 수단 &quot;페치, &lt;code&gt;master&lt;/code&gt; ) 지점을하지만 명시 적으로 명령 줄에서 그것으로 업데이 트에 지점을 원격 추적 무슨 말을하지 않습니다&quot;하고 예제 명령은 가져옵니다 &lt;code&gt;only&lt;/code&gt; &lt;code&gt;master&lt;/code&gt; 분기를. &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 값이 갱신되어있는 경우, 분기 원격 추적 결정. 이런 식으로 사용하면 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 가져올 값 을 결정 &lt;code&gt;what&lt;/code&gt; 데 값이 영향을 미치지 않습니다 (즉, 명령 행이 참조 스펙을 나열 할 때 값이 참조 스펙으로 사용되지 않음). 페치 된 참조가 맵핑 역할을 수행하여 저장되는 &lt;code&gt;where&lt;/code&gt; 를 결정 하는 데에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d3bb27ea8d5739147518646e08d478432b5ac353" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is run without specifying what branches and/or tags to fetch on the command line, e.g. &lt;code&gt;git fetch origin&lt;/code&gt; or &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values are used as the refspecs&amp;mdash;​they specify which refs to fetch and which local refs to update. The example above will fetch all branches that exist in the &lt;code&gt;origin&lt;/code&gt; (i.e. any ref that matches the left-hand side of the value, &lt;code&gt;refs/heads/*&lt;/code&gt;) and update the corresponding remote-tracking branches in the &lt;code&gt;refs/remotes/origin/*&lt;/code&gt; hierarchy.</source>
          <target state="translated">때 &lt;code&gt;git fetch&lt;/code&gt; 지점 및 / 또는 태그 예를 들어, 명령 행에서 가져 오기 위해 무엇을 지정하지 않고 실행 &lt;code&gt;git fetch origin&lt;/code&gt; 또는 &lt;code&gt;git fetch&lt;/code&gt; , &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 값들이 인출 할 심판 지정 refspecs-로 사용되며, 업데이트 할 로컬 참조 위의 예제는 &lt;code&gt;origin&lt;/code&gt; 존재하는 모든 브랜치 (즉, 값의 왼쪽과 일치하는 &lt;code&gt;refs/heads/*&lt;/code&gt; )를 가져오고 &lt;code&gt;refs/remotes/origin/*&lt;/code&gt; 에서 해당 원격 추적 브랜치를 업데이트합니다. 계층.</target>
        </trans-unit>
        <trans-unit id="6bfc306f6ccec6cbac00c82d44f7befe47671739" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is used with &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec it may refuse to update the local branch as discussed in the &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; part below. This option overrides that check.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 를 &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec 과 함께 사용 하면 아래 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 부분 에서 설명한대로 로컬 분기 업데이트를 거부 할 수 있습니다. 이 옵션은 해당 검사를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="b8a0a18f13c1248a211519fc4b6c3ee775403075" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git fetch&lt;/code&gt; is used with &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec it may refuse to update the local branch as discussed in the &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; part of the &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; documentation. This option overrides that check.</source>
          <target state="translated">경우 &lt;code&gt;git fetch&lt;/code&gt; 에 사용되는 &lt;code&gt;&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; refspec는 논의 된 것처럼 로컬 브랜치를 업데이트 거부 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 의 일부 &lt;a href=&quot;git-fetch&quot;&gt;자식 페치 [1]&lt;/a&gt; 문서. 이 옵션은 해당 검사를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="946d45913d1a6d20975808ddb9f4de7a3a592055" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git gc&lt;/code&gt; is run, it calls &lt;code&gt;git worktree prune --expire 3.months.ago&lt;/code&gt;. This config variable can be used to set a different grace period. The value &quot;now&quot; may be used to disable the grace period and prune &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; immediately, or &quot;never&quot; may be used to suppress pruning.</source>
          <target state="translated">&lt;code&gt;git gc&lt;/code&gt; 가 실행될 때 git &lt;code&gt;git worktree prune --expire 3.months.ago&lt;/code&gt; 호출합니다 . 이 구성 변수를 사용하여 다른 유예 기간을 설정할 수 있습니다. &quot;now&quot;값은 유예 기간을 비활성화하고 &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; 즉시 프룬 (prune)하거나 &quot;never&quot;를 사용하여 프 루닝을 억제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdaf9b565f5bc5effacd5e94ca1e6e23df9c9f7a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git gc&lt;/code&gt; is run, it will call &lt;code&gt;prune --expire 2.weeks.ago&lt;/code&gt;. Override the grace period with this config variable. The value &quot;now&quot; may be used to disable this grace period and always prune unreachable objects immediately, or &quot;never&quot; may be used to suppress pruning. This feature helps prevent corruption when &lt;code&gt;git gc&lt;/code&gt; runs concurrently with another process writing to the repository; see the &quot;NOTES&quot; section of &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.</source>
          <target state="translated">때 &lt;code&gt;git gc&lt;/code&gt; 실행되고, 그것은 호출 &lt;code&gt;prune --expire 2.weeks.ago&lt;/code&gt; . 이 구성 변수로 유예 기간을 재정의하십시오. &quot;now&quot;값은이 유예 기간을 비활성화하고 항상 도달 할 수없는 개체를 즉시 제거하거나 &quot;never&quot;를 사용하여 제거를 억제 할 수 있습니다. 이 기능은 &lt;code&gt;git gc&lt;/code&gt; 가 저장소에 쓰는 다른 프로세스와 동시에 실행될 때 손상을 방지 합니다. &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt; 의 &quot;NOTES&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9771ab35f0db8c62ffb81b026ac116ab479df958" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git mergetool&lt;/code&gt; is invoked with this tool (either through the &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;--tool&lt;/code&gt; option or the &lt;code&gt;merge.tool&lt;/code&gt; configuration variable) the configured command line will be invoked with &lt;code&gt;$BASE&lt;/code&gt; set to the name of a temporary file containing the common base for the merge, if available; &lt;code&gt;$LOCAL&lt;/code&gt; set to the name of a temporary file containing the contents of the file on the current branch; &lt;code&gt;$REMOTE&lt;/code&gt; set to the name of a temporary file containing the contents of the file to be merged, and &lt;code&gt;$MERGED&lt;/code&gt; set to the name of the file to which the merge tool should write the result of the merge resolution.</source>
          <target state="translated">때 &lt;code&gt;git mergetool&lt;/code&gt; (스루 중 하나를이 도구를 호출 &lt;code&gt;-t&lt;/code&gt; 또는 &lt;code&gt;--tool&lt;/code&gt; 옵션 또는 &lt;code&gt;merge.tool&lt;/code&gt; 에 구성된 명령 줄이 호출됩니다 구성 변수) &lt;code&gt;$BASE&lt;/code&gt; 공통 기반을 포함하는 임시 파일의 이름으로 설정 가능한 경우 병합; &lt;code&gt;$LOCAL&lt;/code&gt; 은 현재 분기의 파일 내용을 포함하는 임시 파일 이름으로 설정됩니다. &lt;code&gt;$REMOTE&lt;/code&gt; 는 병합 될 파일의 ​​내용을 포함하는 임시 파일 이름으로 설정 되고 &lt;code&gt;$MERGED&lt;/code&gt; 는 병합 도구가 병합 분석 결과를 작성해야하는 파일 이름으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8d649c2a1b515f828b380ed0228639a9abf6f2e7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git-difftool&lt;/code&gt; is invoked with the &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--gui&lt;/code&gt; option the default diff tool will be read from the configured &lt;code&gt;diff.guitool&lt;/code&gt; variable instead of &lt;code&gt;diff.tool&lt;/code&gt;. The &lt;code&gt;--no-gui&lt;/code&gt; option can be used to override this setting. If &lt;code&gt;diff.guitool&lt;/code&gt; is not set, we will fallback in the order of &lt;code&gt;merge.guitool&lt;/code&gt;, &lt;code&gt;diff.tool&lt;/code&gt;, &lt;code&gt;merge.tool&lt;/code&gt; until a tool is found.</source>
          <target state="translated">때 &lt;code&gt;git-difftool&lt;/code&gt; 를 호출 &lt;code&gt;-g&lt;/code&gt; 또는 &lt;code&gt;--gui&lt;/code&gt; 옵션 기본은 diff 도구는 구성에서 읽을 수 있습니다 &lt;code&gt;diff.guitool&lt;/code&gt; 의 변수 대신 &lt;code&gt;diff.tool&lt;/code&gt; . &lt;code&gt;--no-gui&lt;/code&gt; 옵션이 설정을 대체 할 수 있습니다. 경우 &lt;code&gt;diff.guitool&lt;/code&gt; 가 설정되어 있지 않은, 우리의 순서로 폴백합니다 &lt;code&gt;merge.guitool&lt;/code&gt; , &lt;code&gt;diff.tool&lt;/code&gt; , &lt;code&gt;merge.tool&lt;/code&gt; 도구가 발견 될 때까지.</target>
        </trans-unit>
        <trans-unit id="dab1778e78eece39a70fe4959b77fef05af95366" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git-mergetool&lt;/code&gt; is invoked with the &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--gui&lt;/code&gt; option the default merge tool will be read from the configured &lt;code&gt;merge.guitool&lt;/code&gt; variable instead of &lt;code&gt;merge.tool&lt;/code&gt;. If &lt;code&gt;merge.guitool&lt;/code&gt; is not set, we will fallback to the tool configured under &lt;code&gt;merge.tool&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;git-mergetool&lt;/code&gt; 를 호출 &lt;code&gt;-g&lt;/code&gt; 또는 &lt;code&gt;--gui&lt;/code&gt; 옵션 기본 병합 도구는 구성에서 읽을 수 있습니다 &lt;code&gt;merge.guitool&lt;/code&gt; 의 변수 대신 &lt;code&gt;merge.tool&lt;/code&gt; . 경우 &lt;code&gt;merge.guitool&lt;/code&gt; 가 설정되어 있지 않은, 우리는에서 구성 도구로 폴백합니다 &lt;code&gt;merge.tool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55d1f905322639499a3e0c7d64b920e915841fa1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;group&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), the repository is made shareable between several users in a group (making sure all the files and objects are group-writable). When &lt;code&gt;all&lt;/code&gt; (or &lt;code&gt;world&lt;/code&gt; or &lt;code&gt;everybody&lt;/code&gt;), the repository will be readable by all users, additionally to being group-shareable. When &lt;code&gt;umask&lt;/code&gt; (or &lt;code&gt;false&lt;/code&gt;), Git will use permissions reported by umask(2). When &lt;code&gt;0xxx&lt;/code&gt;, where &lt;code&gt;0xxx&lt;/code&gt; is an octal number, files in the repository will have this mode value. &lt;code&gt;0xxx&lt;/code&gt; will override user&amp;rsquo;s umask value (whereas the other options will only override requested parts of the user&amp;rsquo;s umask value). Examples: &lt;code&gt;0660&lt;/code&gt; will make the repo read/write-able for the owner and group, but inaccessible to others (equivalent to &lt;code&gt;group&lt;/code&gt; unless umask is e.g. &lt;code&gt;0022&lt;/code&gt;). &lt;code&gt;0640&lt;/code&gt; is a repository that is group-readable but not group-writable. See &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt;. False by default.</source>
          <target state="translated">때 &lt;code&gt;group&lt;/code&gt; (또는 &lt;code&gt;true&lt;/code&gt; ), 저장소가 그룹에 여러 사용자간에 공유한다 (파일 및 객체 그룹 쓸 수 있는지 모든 제작). 때 &lt;code&gt;all&lt;/code&gt; (또는 &lt;code&gt;world&lt;/code&gt; 또는 &lt;code&gt;everybody&lt;/code&gt; ), 저장소에 추가 그룹 공유되기 위해서는, 모든 사용자가 읽을 수 있습니다. 때 &lt;code&gt;umask&lt;/code&gt; (또는 &lt;code&gt;false&lt;/code&gt; ), 힘내 권한을 사용의 umask (2)에 의해보고했다. 때 &lt;code&gt;0xxx&lt;/code&gt; 여기서 &lt;code&gt;0xxx&lt;/code&gt; 는 8 진수이며, 저장소에있는 파일이 모드의 값을 갖게됩니다. &lt;code&gt;0xxx&lt;/code&gt; 는 사용자의 umask 값을 대체합니다 (다른 옵션은 사용자의 umask 값의 요청 된 부분 만 대체합니다). 예 : &lt;code&gt;0660&lt;/code&gt; repo는 소유자와 그룹에 대해 읽기 / 쓰기가 가능하지만 다른 사람은 액세스 할 수 없습니다 ( umask가 예를 들어 &lt;code&gt;0022&lt;/code&gt; 가 아닌 경우 &lt;code&gt;group&lt;/code&gt; 과 동일 함 ). &lt;code&gt;0640&lt;/code&gt; 은 그룹에서 읽을 수 있지만 그룹에서 쓸 수없는 저장소입니다. &lt;a href=&quot;git-init&quot;&gt;git-init [1]을&lt;/a&gt; 참조하십시오 . 기본적으로 False입니다.</target>
        </trans-unit>
        <trans-unit id="0c640b1443fdc376fb0e05e5b19871e0f70bfa75" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;interactive&lt;/code&gt;, enable the interactive mode of rebase.</source>
          <target state="translated">때 &lt;code&gt;interactive&lt;/code&gt; , REBASE의 대화 형 모드를 가능하게한다.</target>
        </trans-unit>
        <trans-unit id="fe63008459e29ff8faa8d062c0d12daf6ea858b2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;konqueror&lt;/code&gt; is specified by a command-line option or a configuration variable, we launch &lt;code&gt;kfmclient&lt;/code&gt; to try to open the HTML man page on an already opened konqueror in a new tab if possible.</source>
          <target state="translated">&lt;code&gt;konqueror&lt;/code&gt; 가 명령 행 옵션 또는 구성 변수에 의해 지정 되면 &lt;code&gt;kfmclient&lt;/code&gt; 를 실행하여 가능한 경우 새 탭에서 이미 열린 konqueror의 HTML man 페이지를 열려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="0e5d1d0d5309f291d73a19a6f71347b59d761978" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;konqueror&lt;/code&gt; is specified in the &lt;code&gt;man.viewer&lt;/code&gt; configuration variable, we launch &lt;code&gt;kfmclient&lt;/code&gt; to try to open the man page on an already opened konqueror in a new tab if possible.</source>
          <target state="translated">&lt;code&gt;konqueror&lt;/code&gt; 가 &lt;code&gt;man.viewer&lt;/code&gt; 구성 변수에 지정 되면 &lt;code&gt;kfmclient&lt;/code&gt; 를 시작 하여 가능한 경우 이미 열린 konqueror의 매뉴얼 페이지를 새 탭에서 열려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="162b4f89725e01e084b1d2a9bb66f41a211da6f6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;matching&lt;/code&gt; mode is specified, paths that explicitly match an ignored pattern are shown. If a directory matches an ignore pattern, then it is shown, but not paths contained in the ignored directory. If a directory does not match an ignore pattern, but all contents are ignored, then the directory is not shown, but all contents are shown.</source>
          <target state="translated">때 &lt;code&gt;matching&lt;/code&gt; 모드를 지정, 명시 적으로 무시 패턴과 일치하는 경로가 표시됩니다. 디렉토리가 무시 패턴과 일치하면 무시 된 디렉토리에 포함 된 경로는 표시되지 않습니다. 디렉토리가 무시 패턴과 일치하지 않지만 모든 내용이 무시되는 경우 디렉토리는 표시되지 않지만 모든 내용이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7ee4878df1abaf60b54059eba9faa52c16598786" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;merges&lt;/code&gt; (or just &lt;code&gt;m&lt;/code&gt;), pass the &lt;code&gt;--rebase-merges&lt;/code&gt; option to &lt;code&gt;git rebase&lt;/code&gt; so that the local merge commits are included in the rebase (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">&lt;code&gt;merges&lt;/code&gt; (또는 &lt;code&gt;m&lt;/code&gt; ) 할 때 로컬 병합 커밋이 rebase에 포함되도록 &lt;code&gt;--rebase-merges&lt;/code&gt; 옵션을 &lt;code&gt;git rebase&lt;/code&gt; 에 전달 합니다 (자세한 내용은 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="239b51beb1f8c13233881b0568518d58e269df96" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;merges&lt;/code&gt;, pass the &lt;code&gt;--rebase-merges&lt;/code&gt; option to &lt;code&gt;git rebase&lt;/code&gt; so that the local merge commits are included in the rebase (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">하면 &lt;code&gt;merges&lt;/code&gt; , 통과 &lt;code&gt;--rebase-merges&lt;/code&gt; 하는 옵션이 &lt;code&gt;git rebase&lt;/code&gt; 로컬 병합 커밋이 REBASE에 포함되는 정도 (참조 &lt;a href=&quot;git-rebase&quot;&gt;자식-REBASE [1]&lt;/a&gt; 세부 사항 참조).</target>
        </trans-unit>
        <trans-unit id="26887709475bb99a484f3550dfcf66463a02ff1c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;preserve&lt;/code&gt; (deprecated in favor of &lt;code&gt;merges&lt;/code&gt;), also pass &lt;code&gt;--preserve-merges&lt;/code&gt; along to &lt;code&gt;git rebase&lt;/code&gt; so that locally committed merge commits will not be flattened by running &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;preserve&lt;/code&gt; (찬성되지 &lt;code&gt;merges&lt;/code&gt; )도 통과 &lt;code&gt;--preserve-merges&lt;/code&gt; 에 따라 &lt;code&gt;git rebase&lt;/code&gt; 이 로컬 커밋 병합 커밋을 실행하여 평평되지 않도록 &lt;code&gt;git pull&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1aa5ac29106f7e567cb177a446057fe6893dfb3c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;preserve&lt;/code&gt; (or just &lt;code&gt;p&lt;/code&gt;, deprecated in favor of &lt;code&gt;merges&lt;/code&gt;), also pass &lt;code&gt;--preserve-merges&lt;/code&gt; along to &lt;code&gt;git rebase&lt;/code&gt; so that locally committed merge commits will not be flattened by running &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;preserve&lt;/code&gt; (또는 &lt;code&gt;p&lt;/code&gt; 에 찬성되지 않는, &lt;code&gt;merges&lt;/code&gt; )도 통과 &lt;code&gt;--preserve-merges&lt;/code&gt; 에 따라 &lt;code&gt;git rebase&lt;/code&gt; 이 로컬 커밋 병합 커밋을 실행하여 평평되지 않도록 &lt;code&gt;git pull&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c040d756e251986ff4d930aa40402b774da81b76" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;preserveUser&lt;/code&gt; is true, &lt;code&gt;git p4&lt;/code&gt; normally dies if it cannot find an author in the p4 user map. This setting submits the change regardless.</source>
          <target state="translated">때 &lt;code&gt;preserveUser&lt;/code&gt; 는 사실, &lt;code&gt;git p4&lt;/code&gt; 그것이 P4 사용자 맵에서 저자를 찾을 수없는 경우 일반적으로 죽는다. 이 설정은 관계없이 변경 사항을 제출합니다.</target>
        </trans-unit>
        <trans-unit id="f1cb457481e4cab2531cdb48fb2ed70a72c47f80" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;receive-pack&lt;/code&gt; takes in objects, they are placed into a temporary &quot;quarantine&quot; directory within the &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; directory and migrated into the main object store only after the &lt;code&gt;pre-receive&lt;/code&gt; hook has completed. If the push fails before then, the temporary directory is removed entirely.</source>
          <target state="translated">&lt;code&gt;receive-pack&lt;/code&gt; 이 오브젝트를 가져 오면 &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; 디렉토리 내의 임시 &quot;검역&quot;디렉토리에 배치되고 &lt;code&gt;pre-receive&lt;/code&gt; 후크가 완료된 후에 만 주 오브젝트 저장소로 마이그레이션됩니다 . 그 전에 푸시가 실패하면 임시 디렉토리가 완전히 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="13eed45e8cb127a4420b06f0b52f497c696b7d45" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text&lt;/code&gt; is set to &quot;auto&quot;, the path is marked for automatic end-of-line conversion. If Git decides that the content is text, its line endings are converted to LF on checkin. When the file has been committed with CRLF, no conversion is done.</source>
          <target state="translated">&lt;code&gt;text&lt;/code&gt; 가 &quot;자동&quot;으로 설정 되면 경로가 자동 줄 끝 변환으로 표시됩니다. Git이 내용이 텍스트라고 결정하면 체크인시 줄 끝이 LF로 변환됩니다. 파일이 CRLF로 커밋되면 변환이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2bb8610f0d3f51c94aca7dd51e3603814301750d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text=auto&lt;/code&gt; conversion is enabled in a cross-platform project using push and pull to a central repository the text files containing CRLFs should be normalized.</source>
          <target state="translated">때 &lt;code&gt;text=auto&lt;/code&gt; 변환이 중앙 저장소에있는 CRLF를 포함하는 텍스트 파일을 푸시와 풀을 사용하여 크로스 플랫폼 프로젝트에서 사용 가능 정상화해야한다.</target>
        </trans-unit>
        <trans-unit id="f1b569ad0a0d3f731d90377a830d25de99487fad" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;upload-pack&lt;/code&gt; has started &lt;code&gt;pack-objects&lt;/code&gt;, there may be a quiet period while &lt;code&gt;pack-objects&lt;/code&gt; prepares the pack. Normally it would output progress information, but if &lt;code&gt;--quiet&lt;/code&gt; was used for the fetch, &lt;code&gt;pack-objects&lt;/code&gt; will output nothing at all until the pack data begins. Some clients and networks may consider the server to be hung and give up. Setting this option instructs &lt;code&gt;upload-pack&lt;/code&gt; to send an empty keepalive packet every &lt;code&gt;uploadpack.keepAlive&lt;/code&gt; seconds. Setting this option to 0 disables keepalive packets entirely. The default is 5 seconds.</source>
          <target state="translated">때 &lt;code&gt;upload-pack&lt;/code&gt; 시작 &lt;code&gt;pack-objects&lt;/code&gt; 하면서, 조용한 기간이있을 수 있습니다 &lt;code&gt;pack-objects&lt;/code&gt; 팩을 준비합니다. 일반적으로는 출력 진행 정보는 것이지만, 경우에 &lt;code&gt;--quiet&lt;/code&gt; 이 사용 된이 인출 &lt;code&gt;pack-objects&lt;/code&gt; 것이다 팩 데이터까지 모두에서 출력 아무것도 시작하지 않습니다. 일부 클라이언트와 네트워크는 서버가 중단 된 것으로 간주 할 수 있습니다. 이 옵션을 설정하면 &lt;code&gt;upload-pack&lt;/code&gt; 이 &lt;code&gt;uploadpack.keepAlive&lt;/code&gt; 초 마다 빈 keepalive 패킷을 보내도록 지시 합니다. 이 옵션을 0으로 설정하면 keepalive 패킷이 완전히 비활성화됩니다. 기본값은 5 초입니다.</target>
        </trans-unit>
        <trans-unit id="09ea8c9e4617731ed2a0cdf40185d39ec477e171" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; is in effect, allow &lt;code&gt;upload-pack&lt;/code&gt; to accept a fetch request that asks for an object at the tip of a hidden ref (by default, such a request is rejected). See also &lt;code&gt;uploadpack.hideRefs&lt;/code&gt;. Even if this is false, a client may be able to steal objects via the techniques described in the &quot;SECURITY&quot; section of the &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; man page; it&amp;rsquo;s best to keep private data in a separate repository.</source>
          <target state="translated">때 &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; 가 적용되는 허용 &lt;code&gt;upload-pack&lt;/code&gt; 숨겨진 심판의 끝에서 개체에 대해 묻는 가져 오기 요청을 수락 (기본적으로, 이러한 요청이 거부됩니다). &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; 도 참조하십시오 . 이것이 거짓이더라도 클라이언트는 &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]&lt;/a&gt; 매뉴얼 페이지 의 &quot;보안&quot;섹션에 설명 된 기술을 통해 객체를 훔칠 수 있습니다 . 개인 데이터를 별도의 저장소에 보관하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="450f4babea27d38a629ee9743ca7ffcb90a8c4de" translate="yes" xml:space="preserve">
          <source>When Git does a normal merge between two branches, it considers exactly three points: the two branches and a third commit, called the &lt;code&gt;merge base&lt;/code&gt;, which is usually the common ancestor of the commits. The result of the merge is the sum of the changes between the merge base and each head. When you merge two branches with a regular merge commit, this results in a new commit which will end up as a merge base when they&amp;rsquo;re merged again, because there is now a new common ancestor. Git doesn&amp;rsquo;t have to consider changes that occurred before the merge base, so you don&amp;rsquo;t have to re-resolve any conflicts you resolved before.</source>
          <target state="translated">Git은 두 브랜치 사이에 일반적인 병합을 수행 할 때 정확히 세 지점을 고려합니다. 두 개의 브랜치와 일반적으로 커밋의 공통 조상 인 &lt;code&gt;merge base&lt;/code&gt; 라고하는 세 번째 커밋입니다. 병합의 결과는 병합 기준과 각 헤드 간의 변경 합계입니다. 일반 병합 커밋으로 두 브랜치를 병합하면 이제 새 공통 조상이 있기 때문에 다시 병합 될 때 병합 기반으로 끝나는 새 커밋이 발생합니다. Git은 병합 기반 이전에 발생한 변경 사항을 고려할 필요가 없으므로 이전에 해결 한 충돌을 다시 해결할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5f953a201b0ae4d35f35034718b3114ef928787f" translate="yes" xml:space="preserve">
          <source>When Git doesn&amp;rsquo;t know how to handle a certain transport protocol, it attempts to use the &lt;code&gt;remote-&amp;lt;transport&amp;gt;&lt;/code&gt; remote helper, if one exists. To explicitly request a remote helper, the following syntax may be used:</source>
          <target state="translated">Git이 특정 전송 프로토콜을 처리하는 방법을 모르면 &lt;code&gt;remote-&amp;lt;transport&amp;gt;&lt;/code&gt; 원격 도우미 (있는 경우) 를 사용하려고 시도 합니다. 원격 헬퍼를 명시 적으로 요청하기 위해 다음 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf58a154a8f8fa8889640812d376b7964ce7bef2" translate="yes" xml:space="preserve">
          <source>When Git encounters a URL of the form &lt;code&gt;&amp;lt;transport&amp;gt;://&amp;lt;address&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt; is a protocol that it cannot handle natively, it automatically invokes &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; with the full URL as the second argument. If such a URL is encountered directly on the command line, the first argument is the same as the second, and if it is encountered in a configured remote, the first argument is the name of that remote.</source>
          <target state="translated">힘내 형식의 URL 발견하면 &lt;code&gt;&amp;lt;transport&amp;gt;://&amp;lt;address&amp;gt;&lt;/code&gt; 여기서 &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt; 입니다 그것은 기본적으로, 자동으로 발동 할 처리 할 수없는 프로토콜 &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; 두 번째 인수로 전체 URL과 함께. 이러한 URL이 명령 행에서 직접 발견되면 첫 번째 인수는 두 번째 인수와 동일하며 구성된 리모트에서 발견되는 경우 첫 번째 인수는 해당 리모트의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="27018e5bb4c8622ebcfed2f81b80284203c3bc2f" translate="yes" xml:space="preserve">
          <source>When Git encounters the first file that needs to be cleaned or smudged, it starts the filter and performs the handshake. In the handshake, the welcome message sent by Git is &quot;git-filter-client&quot;, only version 2 is supported, and the supported capabilities are &quot;clean&quot;, &quot;smudge&quot;, and &quot;delay&quot;.</source>
          <target state="translated">Git은 청소 또는 얼룩이 필요한 첫 번째 파일을 발견하면 필터를 시작하고 핸드 셰이크를 수행합니다. 핸드 셰이크에서 Git이 보낸 환영 메시지는 &quot;git-filter-client&quot;이고 버전 2 만 지원되며 지원되는 기능은 &quot;clean&quot;, &quot;smudge&quot;및 &quot;delay&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="f51f886a7edb2e397d8670010685e9d17fb9bc09" translate="yes" xml:space="preserve">
          <source>When Git needs authentication for a particular URL context, credential-store will consider that context a pattern to match against each entry in the credentials file. If the protocol, hostname, and username (if we already have one) match, then the password is returned to Git. See the discussion of configuration in &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for more information.</source>
          <target state="translated">Git이 특정 URL 컨텍스트에 대한 인증이 필요한 경우 credential-store는 해당 컨텍스트를 자격 증명 파일의 각 항목과 일치하는 패턴으로 간주합니다. 프로토콜, 호스트 이름 및 사용자 이름 (이미있는 경우)이 일치하면 암호가 Git으로 반환됩니다. 자세한 정보 는 &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt; 의 구성에 대한 설명 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fbdc4494c8c569621bd35073fd02055c267f7e54" translate="yes" xml:space="preserve">
          <source>When Git needs to show you a diff for the path with &lt;code&gt;diff&lt;/code&gt; attribute set to &lt;code&gt;jcdiff&lt;/code&gt;, it calls the command you specified with the above configuration, i.e. &lt;code&gt;j-c-diff&lt;/code&gt;, with 7 parameters, just like &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; program is called. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details.</source>
          <target state="translated">Git에 &lt;code&gt;diff&lt;/code&gt; 속성이 &lt;code&gt;jcdiff&lt;/code&gt; 로 설정된 경로에 대한 diff를 표시 해야하는 경우 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 프로그램이 호출되는 것처럼 7 개의 매개 변수를 사용하여 위 구성 (예 : &lt;code&gt;j-c-diff&lt;/code&gt; )으로 지정한 명령을 호출합니다 . 자세한 내용은 &lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bb3065603615c6a64dfcb623c10f42c6b9e417fa" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;git push --signed&lt;/code&gt; sent a push certificate with a &quot;nonce&quot; that was issued by a receive-pack serving the same repository within this many seconds, export the &quot;nonce&quot; found in the certificate to &lt;code&gt;GIT_PUSH_CERT_NONCE&lt;/code&gt; to the hooks (instead of what the receive-pack asked the sending side to include). This may allow writing checks in &lt;code&gt;pre-receive&lt;/code&gt; and &lt;code&gt;post-receive&lt;/code&gt; a bit easier. Instead of checking &lt;code&gt;GIT_PUSH_CERT_NONCE_SLOP&lt;/code&gt; environment variable that records by how many seconds the nonce is stale to decide if they want to accept the certificate, they only can check &lt;code&gt;GIT_PUSH_CERT_NONCE_STATUS&lt;/code&gt; is &lt;code&gt;OK&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;git push --signed&lt;/code&gt; a로 발행 된 &quot;넌스&quot;로 푸시 인증서를 보내이 많은 초 이내에 같은 저장소를 제공하는 팩을 수신에 인증서에있는 &quot;비표&quot;수출 &lt;code&gt;GIT_PUSH_CERT_NONCE&lt;/code&gt; (대신 후크를 수신 팩이 송신 측에 요청한 내용). 이 수표 쓰기 허용 할 수 있습니다 &lt;code&gt;pre-receive&lt;/code&gt; 및 &lt;code&gt;post-receive&lt;/code&gt; 좀 더 쉽게. nonce가 인증서를 수락할지 여부를 결정하기 위해 부실한 시간 (초)을 기록하는 &lt;code&gt;GIT_PUSH_CERT_NONCE_SLOP&lt;/code&gt; 환경 변수를 확인하는 대신 &lt;code&gt;GIT_PUSH_CERT_NONCE_STATUS&lt;/code&gt; 가 &lt;code&gt;OK&lt;/code&gt; 인지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f34a76491c47ddfcf2959dd6944574eeda479afa" translate="yes" xml:space="preserve">
          <source>When a command has finished, and the client has received the entire response from the server, a client can either request that another command be executed or can terminate the connection. A client may optionally send an empty request consisting of just a flush-pkt to indicate that no more requests will be made.</source>
          <target state="translated">명령이 완료되고 클라이언트가 서버로부터 전체 응답을 받으면 클라이언트는 다른 명령의 실행을 요청하거나 연결을 종료 할 수 있습니다. 클라이언트는 선택적으로 더 이상 요청이 없다는 것을 나타 내기 위해 flush-pkt로만 구성된 빈 요청을 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98e606d10b24cc0c03b08a4efd9e014e2a7d092f" translate="yes" xml:space="preserve">
          <source>When a commit is created in this state, the branch is updated to refer to the new commit. Specifically, &lt;code&gt;git commit&lt;/code&gt; creates a new commit &lt;code&gt;d&lt;/code&gt;, whose parent is commit &lt;code&gt;c&lt;/code&gt;, and then updates branch &lt;code&gt;master&lt;/code&gt; to refer to new commit &lt;code&gt;d&lt;/code&gt;. &lt;code&gt;HEAD&lt;/code&gt; still refers to branch &lt;code&gt;master&lt;/code&gt; and so indirectly now refers to commit &lt;code&gt;d&lt;/code&gt;:</source>
          <target state="translated">이 상태에서 커밋이 생성되면 새 커밋을 참조하도록 분기가 업데이트됩니다. 특히, &lt;code&gt;git commit&lt;/code&gt; 새로운 커밋 생성 &lt;code&gt;d&lt;/code&gt; 부모가 저지하고, &lt;code&gt;c&lt;/code&gt; 다음 지점 업데이트 &lt;code&gt;master&lt;/code&gt; 새로운 확정 참조 &lt;code&gt;d&lt;/code&gt; . &lt;code&gt;HEAD&lt;/code&gt; 는 여전히 브랜치 &lt;code&gt;master&lt;/code&gt; 를 참조하므로 간접적으로 커밋 &lt;code&gt;d&lt;/code&gt; 를 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="b5e6d106b45c449ef3f9978fa7e9a2c319abd6d7" translate="yes" xml:space="preserve">
          <source>When a conflict occurs while rebasing, rebase stops and asks the user to resolve. Since the user may need to make notable changes while resolving conflicts, after conflicts are resolved and the user has run &lt;code&gt;git rebase --continue&lt;/code&gt;, the rebase should open an editor and ask the user to update the commit message. The merge backend does this, while the apply backend blindly applies the original commit message.</source>
          <target state="translated">리베이스 중에 충돌이 발생하면 리베이스가 중지되고 사용자에게 해결을 요청합니다. 사용자가 충돌을 해결하는 동안 눈에 띄는 변경을해야 할 수 있으므로 충돌이 해결되고 사용자가 &lt;code&gt;git rebase --continue&lt;/code&gt; 를 실행 한 후 rebase는 편집기를 열고 사용자에게 커밋 메시지를 업데이트하도록 요청해야합니다. 병합 백엔드는이를 수행하는 반면 적용 백엔드는 원래 커밋 메시지를 맹목적으로 적용합니다.</target>
        </trans-unit>
        <trans-unit id="a1d656a10ad8d92cd23d5675fa9c3ba2b92a8d6f" translate="yes" xml:space="preserve">
          <source>When a curl trace is enabled (see &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; above), do not dump data (that is, only dump info lines and headers).</source>
          <target state="translated">컬 추적이 활성화되면 ( 위의 &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; 참조) 데이터를 덤프하지 마십시오 (즉, 정보 행 및 헤더 만 덤프).</target>
        </trans-unit>
        <trans-unit id="855748d09cda03242c615ed9f83d928cff4dd252" translate="yes" xml:space="preserve">
          <source>When a fetch mirror is created with &lt;code&gt;--mirror=fetch&lt;/code&gt;, the refs will not be stored in the &lt;code&gt;refs/remotes/&lt;/code&gt; namespace, but rather everything in &lt;code&gt;refs/&lt;/code&gt; on the remote will be directly mirrored into &lt;code&gt;refs/&lt;/code&gt; in the local repository. This option only makes sense in bare repositories, because a fetch would overwrite any local commits.</source>
          <target state="translated">&lt;code&gt;--mirror=fetch&lt;/code&gt; 를 사용하여 페치 미러를 만들면 참조 는 &lt;code&gt;refs/remotes/&lt;/code&gt; 네임 스페이스에 저장되지 않지만 원격의 &lt;code&gt;refs/&lt;/code&gt; 에있는 모든 것은 로컬 리포지토리의 &lt;code&gt;refs/&lt;/code&gt; 에 직접 미러링됩니다 . 페치는 로컬 커밋을 덮어 쓰기 때문에이 옵션은 베어 리포지토리에서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="747511f053f093bdd8637c2efa65029ba86d5e79" translate="yes" xml:space="preserve">
          <source>When a git process is a (direct or indirect) child of another git process, it inherits Trace2 context information. This allows the child to print the command hierarchy. This example shows gc as child[3] of fetch. When the gc process reports its name as &quot;gc&quot;, it also reports the hierarchy as &quot;fetch/gc&quot;. (In this example, trace2 messages from the child process is indented for clarity.)</source>
          <target state="translated">자식 프로세스가 다른 자식 프로세스의 (직접 또는 간접) 자식 인 경우 Trace2 컨텍스트 정보를 상속합니다. 이를 통해 자식은 명령 계층을 인쇄 할 수 있습니다. 이 예는 gc를 fetch의 child [3]으로 표시합니다. gc 프로세스가 이름을 &quot;gc&quot;로보고하면 계층 구조도 &quot;fetch / gc&quot;로보고합니다. (이 예에서, 하위 프로세스의 trace2 메시지는 명확성을 위해 들여 쓰기됩니다.)</target>
        </trans-unit>
        <trans-unit id="dcc866e382263d0b053b9eb6226d8321d2b6f3a3" translate="yes" xml:space="preserve">
          <source>When a helper is executed, it will have one &quot;operation&quot; argument appended to its command line, which is one of:</source>
          <target state="translated">도우미가 실행되면 명령 줄에 다음 중 하나 인 &quot;operation&quot;인수가 하나 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="79294381fcaa0a0dccaa2b41ac29dc7daa74e3f5" translate="yes" xml:space="preserve">
          <source>When a local branch is started off a remote-tracking branch, Git sets up the branch (specifically the &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; configuration entries) so that &lt;code&gt;git pull&lt;/code&gt; will appropriately merge from the remote-tracking branch. This behavior may be changed via the global &lt;code&gt;branch.autoSetupMerge&lt;/code&gt; configuration flag. That setting can be overridden by using the &lt;code&gt;--track&lt;/code&gt; and &lt;code&gt;--no-track&lt;/code&gt; options, and changed later using &lt;code&gt;git branch --set-upstream-to&lt;/code&gt;.</source>
          <target state="translated">로컬 분기가 원격 추적 분기에서 시작되면 Git은 분기 (특히 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 및 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 구성 항목)를 설정하여 &lt;code&gt;git pull&lt;/code&gt; 이 원격에서 적절히 병합되도록합니다. 추적 지점. 이 동작은 global &lt;code&gt;branch.autoSetupMerge&lt;/code&gt; 구성 플래그 를 통해 변경 될 수 있습니다 . 이 설정은 &lt;code&gt;--track&lt;/code&gt; 및 &lt;code&gt;--no-track&lt;/code&gt; 옵션 을 사용하여 무시 하고 나중에 &lt;code&gt;git branch --set-upstream-to&lt;/code&gt; 를 사용하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbb99a5451930fe8366dedb022737c46385ca3a6" translate="yes" xml:space="preserve">
          <source>When a merge commit is included by &lt;code&gt;--show-pulls&lt;/code&gt;, the merge is treated as if it &quot;pulled&quot; the change from another branch. When using &lt;code&gt;--show-pulls&lt;/code&gt; on this example (and no other options) the resulting graph is:</source>
          <target state="translated">병합 커밋이 &lt;code&gt;--show-pulls&lt;/code&gt; 에 포함 된 경우 병합은 다른 분기에서 변경 사항을 &quot;끌어온&quot;것처럼 처리됩니다. 이 예제 (다른 옵션 없음)에서 &lt;code&gt;--show-pulls&lt;/code&gt; 를 사용 하면 결과 그래프는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e12783acd89ac9262429bc89fcf85d9b95e88c1" translate="yes" xml:space="preserve">
          <source>When a merge conflict happens during switching branches with the &lt;code&gt;-m&lt;/code&gt; option, you would see something like this:</source>
          <target state="translated">&lt;code&gt;-m&lt;/code&gt; 옵션을 사용하여 분기를 전환하는 동안 병합 충돌이 발생 하면 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8b8f6236a48634fd451e67557b1ed432c992a4a6" translate="yes" xml:space="preserve">
          <source>When a merge conflict happens, the index entries for conflicting paths are left unmerged, and you need to resolve the conflicts and mark the resolved paths with &lt;code&gt;git add&lt;/code&gt; (or &lt;code&gt;git rm&lt;/code&gt; if the merge should result in deletion of the path).</source>
          <target state="translated">병합 충돌이 발생하면 충돌하는 경로에 대한 색인 항목이 병합되지 않은 상태로 유지되며 충돌을 해결하고 해결 된 경로를 &lt;code&gt;git add&lt;/code&gt; (또는 병합으로 인해 경로가 삭제되어야하는 경우 &lt;code&gt;git rm&lt;/code&gt; )로 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="054b9e9957838ff74728498487ffff5f26346d88" translate="yes" xml:space="preserve">
          <source>When a merge isn&amp;rsquo;t resolved automatically, Git leaves the index and the working tree in a special state that gives you all the information you need to help resolve the merge.</source>
          <target state="translated">병합이 자동으로 해결되지 않으면 Git은 색인과 작업 트리를 병합 상태를 유지하는 데 필요한 모든 정보를 제공하는 특수 상태로 둡니다.</target>
        </trans-unit>
        <trans-unit id="1d6b6e4ed4a39cb92155b19d26f3a8478b8d6d5c" translate="yes" xml:space="preserve">
          <source>When a new branch is created with &lt;code&gt;git branch&lt;/code&gt;, &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt; that tracks another branch, this variable tells Git to set up pull to rebase instead of merge (see &quot;branch.&amp;lt;name&amp;gt;.rebase&quot;). When &lt;code&gt;never&lt;/code&gt;, rebase is never automatically set to true. When &lt;code&gt;local&lt;/code&gt;, rebase is set to true for tracked branches of other local branches. When &lt;code&gt;remote&lt;/code&gt;, rebase is set to true for tracked branches of remote-tracking branches. When &lt;code&gt;always&lt;/code&gt;, rebase will be set to true for all tracking branches. See &quot;branch.autoSetupMerge&quot; for details on how to set up a branch to track another branch. This option defaults to never.</source>
          <target state="translated">다른 브랜치를 추적 하는 &lt;code&gt;git branch&lt;/code&gt; , &lt;code&gt;git switch&lt;/code&gt; 또는 &lt;code&gt;git checkout&lt;/code&gt; 으로 새 브랜치를 만들면이 변수는 Git에게 병합 대신 rebase로 pull을 설정하도록 지시합니다 ( &quot;branch. &amp;lt;name&amp;gt; .rebase&quot;참조). &lt;code&gt;never&lt;/code&gt; 일 때 rebase는 자동으로 true로 설정되지 않습니다. 때 &lt;code&gt;local&lt;/code&gt; , REBASE 다른 지역 지점의 추적 지점에 대해 true로 설정됩니다. 때 &lt;code&gt;remote&lt;/code&gt; , REBASE 원격 추적 브랜치의 추적 지점에 대해 true로 설정됩니다. 때 &lt;code&gt;always&lt;/code&gt; , REBASE 모든 추적 지점 true로 설정됩니다. 다른 지점을 추적하도록 지점을 설정하는 방법에 대한 자세한 내용은 &quot;branch.autoSetupMerge&quot;를 참조하십시오. 이 옵션의 기본값은 never입니다.</target>
        </trans-unit>
        <trans-unit id="ed0adff8e63a6741e1694d5ebc304264bd392424" translate="yes" xml:space="preserve">
          <source>When a patch failure occurs, &amp;lt;msg&amp;gt; will be printed to the screen before exiting. This overrides the standard message informing you to use &lt;code&gt;--continue&lt;/code&gt; or &lt;code&gt;--skip&lt;/code&gt; to handle the failure. This is solely for internal use between &lt;code&gt;git rebase&lt;/code&gt; and &lt;code&gt;git am&lt;/code&gt;.</source>
          <target state="translated">패치 실패가 발생하면 종료하기 전에 &amp;lt;msg&amp;gt;가 화면에 인쇄됩니다. 이는 &lt;code&gt;--continue&lt;/code&gt; 또는 &lt;code&gt;--skip&lt;/code&gt; 을 사용하여 실패를 처리 하라는 표준 메시지를 무시합니다 . 이것은 &lt;code&gt;git rebase&lt;/code&gt; 와 &lt;code&gt;git am&lt;/code&gt; 사이의 내부 용 입니다.</target>
        </trans-unit>
        <trans-unit id="d5b066fa036c4bb98c79472fbdf38de3d119f100" translate="yes" xml:space="preserve">
          <source>When a patch is part of an ongoing discussion, the patch generated by &lt;code&gt;git format-patch&lt;/code&gt; can be tweaked to take advantage of the &lt;code&gt;git am --scissors&lt;/code&gt; feature. After your response to the discussion comes a line that consists solely of &quot;&lt;code&gt;-- &amp;gt;8 --&lt;/code&gt;&quot; (scissors and perforation), followed by the patch with unnecessary header fields removed:</source>
          <target state="translated">패치가 진행중인 토론의 일부인 경우 &lt;code&gt;git format-patch&lt;/code&gt; 에 의해 생성 된 패치 를 조정하여 &lt;code&gt;git am --scissors&lt;/code&gt; 기능 을 활용할 수 있습니다 . 토론에 대한 응답이 끝나면 &quot; &lt;code&gt;-- &amp;gt;8 --&lt;/code&gt; &quot;(가위 및 천공)으로 구성되고 불필요한 헤더 필드가 제거 된 패치가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="f3cb24e54c9837370739d06bd25b8c911a05ee6b" translate="yes" xml:space="preserve">
          <source>When a path is in the &quot;unmerged&quot; state, running &lt;code&gt;git update-index&lt;/code&gt; for that path tells Git to mark the path resolved.</source>
          <target state="translated">경로가 &quot;머지되지 않은&quot;상태 인 경우 해당 경로에 대해 &lt;code&gt;git update-index&lt;/code&gt; 를 실행 하면 Git에 경로가 해결되었음을 표시하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="f8965008f9824bf8da0b033710c2d7ac1f3f6568" translate="yes" xml:space="preserve">
          <source>When a pure mode change is encountered (which has no index information), the information is read from the current index instead.</source>
          <target state="translated">순수 모드 변경이 발생하면 (인덱스 정보가 없음) 대신 현재 인덱스에서 정보를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="ef4651b07e5b8cb97cb93de85df1d7e556426d24" translate="yes" xml:space="preserve">
          <source>When a push mirror is created with &lt;code&gt;--mirror=push&lt;/code&gt;, then &lt;code&gt;git push&lt;/code&gt; will always behave as if &lt;code&gt;--mirror&lt;/code&gt; was passed.</source>
          <target state="translated">와 푸시 미러가 생성 될 때 &lt;code&gt;--mirror=push&lt;/code&gt; , 다음 &lt;code&gt;git push&lt;/code&gt; 것처럼 항상 작동합니다 &lt;code&gt;--mirror&lt;/code&gt; 이 통과되었다.</target>
        </trans-unit>
        <trans-unit id="deb13d30f8ba66c920f6495f36b99921916b0fbc" translate="yes" xml:space="preserve">
          <source>When a rebase required merge conflicts to be resolved, compare the changes introduced by the rebase directly afterwards using:</source>
          <target state="translated">리베이스에서 병합 충돌을 해결해야하는 경우 다음을 사용하여 리베이스에서 직접 도입 된 변경 사항을 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="350766930233515327656bc7b70b13214a7aa33c" translate="yes" xml:space="preserve">
          <source>When a ref is updated, reflog entries are created to keep track of the reason why the ref was updated (which is typically the name of the high-level command that updated the ref), in addition to the old and new values of the ref. A scripted Porcelain command can use set_reflog_action helper function in &lt;code&gt;git-sh-setup&lt;/code&gt; to set its name to this variable when it is invoked as the top level command by the end user, to be recorded in the body of the reflog.</source>
          <target state="translated">ref가 업데이트되면 ref의 이전 값과 새로운 값 외에 ref가 업데이트 된 이유 (일반적으로 ref를 업데이트 한 상위 명령 이름)를 추적하기 위해 reflog 항목이 작성됩니다. . 스크립트 된 Porcelain 명령은 &lt;code&gt;git-sh-setup&lt;/code&gt; 의 set_reflog_action 헬퍼 함수를 ​​사용 하여 최종 사용자가 최상위 레벨 명령으로 호출 할 때이 변수로 이름을 설정 하여 참조 로그 본문에 기록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a564cf0d83332d2cd6fd3ac884cec9942b078c7" translate="yes" xml:space="preserve">
          <source>When a repository is synchronized via &lt;code&gt;git push&lt;/code&gt; and &lt;code&gt;git pull&lt;/code&gt; objects packed in the source repository are usually stored unpacked in the destination. While this allows you to use different packing strategies on both ends, it also means you may need to repack both repositories every once in a while.</source>
          <target state="translated">소스 리포지토리에 압축 된 &lt;code&gt;git push&lt;/code&gt; 및 &lt;code&gt;git pull&lt;/code&gt; 객체 를 통해 리포지토리가 동기화되면 일반적으로 대상에 압축을 푼 상태로 저장됩니다. 이렇게하면 양쪽에서 서로 다른 포장 전략을 사용할 수 있지만 두 저장소를 한 번에 한 번씩 다시 포장해야 할 수도 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
