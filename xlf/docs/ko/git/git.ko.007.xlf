<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="9f1df172d790d81927bf10eb32b7a53862fd94a5" translate="yes" xml:space="preserve">
          <source>Interrupted workflow</source>
          <target state="translated">중단 된 워크 플로우</target>
        </trans-unit>
        <trans-unit id="b566252f7afe805214a7771e6b2a586b4e458c82" translate="yes" xml:space="preserve">
          <source>Introduction to &quot;git bisect&quot;</source>
          <target state="translated">&quot;git bisect&quot;소개</target>
        </trans-unit>
        <trans-unit id="273a20c96a580af6e0e1fc6c4491680cd6e13de6" translate="yes" xml:space="preserve">
          <source>Intuitiveness is not the goal here. Repeatability is. The reason for the &quot;no arguments means no work&quot; behavior is that from scripts you are supposed to be able to do:</source>
          <target state="translated">직관적 인 목표는 여기에 없습니다. 반복성은 &quot;인수 없음&quot;은 작동하지 않는 동작의 이유는 스크립트에서 수행 할 수 있어야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="6a9b44369c96eafd66d755034e5ce80488ad8832" translate="yes" xml:space="preserve">
          <source>Invocation</source>
          <target state="translated">Invocation</target>
        </trans-unit>
        <trans-unit id="1d5f124f7b2f261867ec41e2c056658bb6e88c34" translate="yes" xml:space="preserve">
          <source>Invoke a text editor (see GIT_EDITOR in &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt;) to edit an introductory message for the patch series.</source>
          <target state="translated">텍스트 편집기 ( &lt;a href=&quot;git-var&quot;&gt;git-var [1]의&lt;/a&gt; GIT_EDITOR 참조)를 호출 하여 패치 시리즈에 대한 소개 메시지를 편집하십시오.</target>
        </trans-unit>
        <trans-unit id="9ba2ef7b89376be98d487b046c212677da3221b4" translate="yes" xml:space="preserve">
          <source>Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The &lt;code&gt;--no-edit&lt;/code&gt; option can be used to accept the auto-generated message (this is generally discouraged).</source>
          <target state="translated">성공적인 자동 병합을 커미트하기 전에 편집기를 호출하여 자동 생성 된 병합 메시지를 추가로 편집하여 사용자가 병합을 설명하고 정당화 할 수 있습니다. &lt;code&gt;--no-edit&lt;/code&gt; 옵션 (이것은 일반적으로 권장하지 않습니다) 자동 생성 된 메시지를 수락 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a978683542367bbc42f0a41dd9d11a4a00c553d9" translate="yes" xml:space="preserve">
          <source>Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The &lt;code&gt;--no-edit&lt;/code&gt; option can be used to accept the auto-generated message (this is generally discouraged). The &lt;code&gt;--edit&lt;/code&gt; (or &lt;code&gt;-e&lt;/code&gt;) option is still useful if you are giving a draft message with the &lt;code&gt;-m&lt;/code&gt; option from the command line and want to edit it in the editor.</source>
          <target state="translated">성공적인 자동 병합을 커미트하기 전에 편집기를 호출하여 자동 생성 된 병합 메시지를 추가로 편집하여 사용자가 병합을 설명하고 정당화 할 수 있습니다. &lt;code&gt;--no-edit&lt;/code&gt; 옵션 (이것은 일반적으로 권장하지 않습니다) 자동 생성 된 메시지를 수락 할 수 있습니다. &lt;code&gt;--edit&lt;/code&gt; (또는 &lt;code&gt;-e&lt;/code&gt; 당신이 가진 초안 메시지를주는 경우) 옵션은 여전히 유용 &lt;code&gt;-m&lt;/code&gt; 명령 행에서 옵션을하고 편집기에서 편집을하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="ab51558f752b86c08b9c277e1cd35bd4f5da28bc" translate="yes" xml:space="preserve">
          <source>Invoke the sendemail-validate hook if present (see &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;).</source>
          <target state="translated">있는 경우 sendemail-validate 후크를 호출하십시오 ( &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6307458f7efb25e5d4237ad7a4e972e464f2ab54" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git archive --remote&lt;/code&gt; and sends a generated archive to the other end over the Git protocol.</source>
          <target state="translated">&lt;code&gt;git archive --remote&lt;/code&gt; 에 의해 호출되며 생성 된 아카이브를 Git 프로토콜을 통해 다른 쪽 끝으로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="4591feb10dd06f62e310d9c287cf3f981ce9babf" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git fetch-pack&lt;/code&gt;, learns what objects the other side is missing, and sends them after packing.</source>
          <target state="translated">&lt;code&gt;git fetch-pack&lt;/code&gt; 에 의해 호출되어 다른 쪽에서 누락 된 객체를 파악하고 패킹 후 보냅니다.</target>
        </trans-unit>
        <trans-unit id="a7f91dd525c007f2b681e8a032a0618f9a34ea1c" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git send-pack&lt;/code&gt; and updates the repository with the information fed from the remote end.</source>
          <target state="translated">&lt;code&gt;git send-pack&lt;/code&gt; 에 의해 호출되며 원격 엔드에서 제공된 정보로 저장소를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="d65563f7b9f547034dceec39b8ac04f9c683c150" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;git-receive-pack&lt;/code&gt; on a possibly remote repository, and updates it from the current repository, sending named refs.</source>
          <target state="translated">원격 저장소에서 &lt;code&gt;git-receive-pack&lt;/code&gt; 을 호출 하고 이름이 지정된 ref를 전송하여 현재 저장소에서 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="b53ca0a7337f2511de77389036559a87c502bc3d" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;git-upload-pack&lt;/code&gt; on a possibly remote repository and asks it to send objects missing from this repository, to update the named heads. The list of commits available locally is found out by scanning the local refs/ hierarchy and sent to &lt;code&gt;git-upload-pack&lt;/code&gt; running on the other end.</source>
          <target state="translated">원격 저장소에서 &lt;code&gt;git-upload-pack&lt;/code&gt; 을 호출 하고이 저장소에서 누락 된 객체를 보내 이름 지정된 헤드를 업데이트하도록 요청합니다. 로컬에서 사용 가능한 커밋 목록은 로컬 refs / 계층 구조를 스캔하여 찾아서 다른 쪽 끝에서 실행되는 &lt;code&gt;git-upload-pack&lt;/code&gt; 으로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="a31ffeaabebc608f725ad5aea0019f330d8c2ea7" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;git add -e&lt;/code&gt; or selecting &lt;code&gt;e&lt;/code&gt; from the interactive hunk selector will open a patch in your editor; after the editor exits, the result is applied to the index. You are free to make arbitrary changes to the patch, but note that some changes may have confusing results, or even result in a patch that cannot be applied. If you want to abort the operation entirely (i.e., stage nothing new in the index), simply delete all lines of the patch. The list below describes some common things you may see in a patch, and which editing operations make sense on them.</source>
          <target state="translated">&lt;code&gt;git add -e&lt;/code&gt; 를 호출 하거나 대화식 덩어리 선택기에서 &lt;code&gt;e&lt;/code&gt; 를 선택하면 편집기에서 패치가 열립니다. 편집기가 종료되면 결과가 색인에 적용됩니다. 패치를 임의로 변경할 수는 있지만 일부 변경 사항으로 인해 혼동되는 결과가 발생하거나 적용 할 수없는 패치가 발생할 수 있습니다. 작업을 완전히 중단하려면 (즉, 색인에서 새로운 것을 스테이징하지 않으려면) 패치의 모든 줄을 삭제하십시오. 아래 목록은 패치에서 볼 수있는 몇 가지 일반적인 사항과 그에 적합한 편집 작업에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7eda501750cd6c5e49ea1b4fd74542b592feab87" translate="yes" xml:space="preserve">
          <source>Involving QA people and if possible end users</source>
          <target state="translated">품질 보증 담당자 및 가능한 경우 최종 사용자</target>
        </trans-unit>
        <trans-unit id="4ddb9cd693a2e162ef85f6fbfe4abc845111ebb9" translate="yes" xml:space="preserve">
          <source>Is a synonym for &lt;code&gt;zebra&lt;/code&gt;. This may change to a more sensible mode in the future.</source>
          <target state="translated">&lt;code&gt;zebra&lt;/code&gt; 의 동의어입니다 . 앞으로 더 합리적인 모드로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f13daaae3d7fc7ba5d15c4ccfc54188d83d267e" translate="yes" xml:space="preserve">
          <source>Is used as suggested name when creating new branches using the &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]을&lt;/a&gt; 사용하여 새 분기를 만들 때 제안 된 이름으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6f3229278b909458bc76fcc500cf44677191a296" translate="yes" xml:space="preserve">
          <source>Islands are configured via the &lt;code&gt;pack.island&lt;/code&gt; option, which can be specified multiple times. Each value is a left-anchored regular expressions matching refnames. For example:</source>
          <target state="translated">아일랜드는 &lt;code&gt;pack.island&lt;/code&gt; 옵션을 통해 구성되며 여러 번 지정할 수 있습니다. 각 값은 참조 이름과 일치하는 왼쪽 고정식입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30ce4cb25faae86427d8ac22e8f50a0a74f3f393" translate="yes" xml:space="preserve">
          <source>Issues</source>
          <target state="translated">Issues</target>
        </trans-unit>
        <trans-unit id="0120e142d77ed0c1102a3548e5e6ca12ae1c469b" translate="yes" xml:space="preserve">
          <source>Issues which are security relevant should be disclosed privately to the Git Security mailing list &amp;lt;&lt;a href=&quot;mailto:git-security@googlegroups.com&quot;&gt;git-security@googlegroups.com&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">보안 관련 문제는 Git 보안 메일 링리스트 &amp;lt; &lt;a href=&quot;mailto:git-security@googlegroups.com&quot;&gt;git-security@googlegroups.com&lt;/a&gt; &amp;gt;에 비공개로 공개해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7e6ca0d89968d14a4a145a03ebcf512ab164b2cf" translate="yes" xml:space="preserve">
          <source>Issuing a &lt;code&gt;filedeleteall&lt;/code&gt; followed by the needed &lt;code&gt;filemodify&lt;/code&gt; commands to set the correct content will produce the same results as sending only the needed &lt;code&gt;filemodify&lt;/code&gt; and &lt;code&gt;filedelete&lt;/code&gt; commands. The &lt;code&gt;filedeleteall&lt;/code&gt; approach may however require fast-import to use slightly more memory per active branch (less than 1 MiB for even most large projects); so frontends that can easily obtain only the affected paths for a commit are encouraged to do so.</source>
          <target state="translated">올바른 컨텐츠를 설정 하기 위해 &lt;code&gt;filedeleteall&lt;/code&gt; 다음에 필요한 &lt;code&gt;filemodify&lt;/code&gt; 명령을 발행 하면 필요한 &lt;code&gt;filemodify&lt;/code&gt; 및 &lt;code&gt;filedelete&lt;/code&gt; 명령 만 보내는 것과 동일한 결과가 생성됩니다 . 그러나 &lt;code&gt;filedeleteall&lt;/code&gt; 접근 방식은 활성 브랜치 당 약간 더 많은 메모리를 사용하기 위해 빠른 가져 오기가 필요할 수 있습니다 (대규모 프로젝트의 경우 1MiB 미만). 따라서 커밋에 영향을받는 경로 만 쉽게 얻을 수있는 프런트 엔드가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="bdf45bc4332be1bec5eceb55b9547e5441cbefc8" translate="yes" xml:space="preserve">
          <source>It adds the submodule&amp;rsquo;s clone path to the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file and adds this file to the index, ready to be committed.</source>
          <target state="translated">서브 모듈의 클론 경로를 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 파일에 추가하고이 파일을 인덱스에 추가하여 커밋 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c81521fe76c33a9e0c12152a7126a3168cdc6bc" translate="yes" xml:space="preserve">
          <source>It adds the submodule&amp;rsquo;s current commit ID to the index, ready to be committed.</source>
          <target state="translated">서브 모듈의 현재 커밋 ID를 인덱스에 추가하여 커밋 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d31bfc2387ea73611500553c1004cb0667d4f160" translate="yes" xml:space="preserve">
          <source>It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number &lt;code&gt;m&lt;/code&gt; controls this aspect of the -B option (defaults to 60%). &lt;code&gt;-B/70%&lt;/code&gt; specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).</source>
          <target state="translated">그것은 일련의 삭제 및 삽입이 아니라 텍스트와 문맥 상 텍스트로 일치하는 아주 적은 행과 함께 파일을 완전히 다시 작성하는 변경에 영향을 미칩니다. 새로운 모든 것을 한 번만 삽입하면 숫자 &lt;code&gt;m&lt;/code&gt; 은 -B 옵션의이 측면을 제어합니다 (기본값은 60 %). &lt;code&gt;-B/70%&lt;/code&gt; 는 Git이 원본을 30 % 미만으로 유지하여 결과를 총 재 작성으로 간주하도록 지정합니다 (그렇지 않으면 결과 패치는 컨텍스트 라인과 함께 일련의 삭제 및 삽입이됩니다).</target>
        </trans-unit>
        <trans-unit id="3769038328418f1b146bfedf460a0d4ea1eab91b" translate="yes" xml:space="preserve">
          <source>It also allows a &quot;ref&quot; file to be a symbolic pointer to another ref file by starting with the four-byte header sequence of &quot;ref:&quot;.</source>
          <target state="translated">또한 &quot;ref :&quot;의 4 바이트 헤더 시퀀스로 시작하여 &quot;ref&quot;파일이 다른 ref 파일에 대한 기호 포인터가되도록합니다.</target>
        </trans-unit>
        <trans-unit id="c1a8e562ae70e23b9286b736cb60f8fd411f796d" translate="yes" xml:space="preserve">
          <source>It can also be useful in scripts passed to &quot;git bisect run&quot; to &quot;exit 255&quot; if some very abnormal situation is detected.</source>
          <target state="translated">매우 비정상적인 상황이 감지되면 &quot;git bisect run&quot;으로 전달 된 스크립트에서 &quot;255를 종료&quot;하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79b5b9aab5919bae0a6145dab082f1d19cd80f67" translate="yes" xml:space="preserve">
          <source>It can be cumbersome to input the same credentials over and over. Git provides two methods to reduce this annoyance:</source>
          <target state="translated">동일한 자격 증명을 반복해서 입력하는 것은 번거로울 수 있습니다. 힘내는이 성가심을 줄이기 위해 두 가지 방법을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="4e1aaed29365e5e25e94340f3a0f563a3458fb95" translate="yes" xml:space="preserve">
          <source>It can be used to inspect the current working tree and refuse to make a commit if it does not pass certain test.</source>
          <target state="translated">현재 작업 트리를 검사하고 특정 테스트를 통과하지 못하면 커밋을 거부하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15367977bf1bc97e62677f2311accebdf50497b6" translate="yes" xml:space="preserve">
          <source>It can efficiently represent information about merge conflicts between different tree objects, allowing each pathname to be associated with sufficient information about the trees involved that you can create a three-way merge between them.</source>
          <target state="translated">서로 다른 트리 개체 간의 병합 충돌에 대한 정보를 효율적으로 나타낼 수 있으므로 각 경로 이름을 트리 간 병합을 만들 수있는 관련 트리에 대한 충분한 정보와 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61f59429096395b0e09a9585119ef97dbe0f3099" translate="yes" xml:space="preserve">
          <source>It cannot show more than 29 branches and commits at a time.</source>
          <target state="translated">한 번에 29 개 이상의 분기 및 커밋을 표시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="84908290c2ad8351819557b635db90afccbc35f1" translate="yes" xml:space="preserve">
          <source>It clones the submodule from &lt;code&gt;&amp;lt;repo&amp;gt;&lt;/code&gt; to the given &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; under the current directory and by default checks out the master branch.</source>
          <target state="translated">하위 디렉토리 를 &lt;code&gt;&amp;lt;repo&amp;gt;&lt;/code&gt; 에서 현재 디렉토리 아래의 지정된 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 로 복제하고 기본적으로 마스터 분기를 체크 아웃합니다.</target>
        </trans-unit>
        <trans-unit id="d2f2a22f8382dea93b62981d5e21e0c74a8c6b46" translate="yes" xml:space="preserve">
          <source>It could also be used to log the old..new status. However, it does not know the entire set of branches, so it would end up firing one e-mail per ref when used naively, though. The &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;post-receive&lt;/em&gt;&lt;/a&gt; hook is more suited to that.</source>
          <target state="translated">old..new 상태를 기록하는 데 사용될 수도 있습니다. 그러나 전체 브랜치 세트를 알지 못하므로 순진하게 사용될 때 참조 당 하나의 이메일을 발행하게됩니다. 는 &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;이후 수신&lt;/em&gt;&lt;/a&gt; 후크가 더 적합하다.</target>
        </trans-unit>
        <trans-unit id="784deb932c786d53caa1d9cefe7cd05964d957b0" translate="yes" xml:space="preserve">
          <source>It defaults to &lt;code&gt;blue,12 month ago,white,1 month ago,red&lt;/code&gt;, which colors everything older than one year blue, recent changes between one month and one year old are kept white, and lines introduced within the last month are colored red.</source>
          <target state="translated">1 년보다 오래된 모든 것을 채색 하는 &lt;code&gt;blue,12 month ago,white,1 month ago,red&lt;/code&gt; 기본 설정되며 , 1 개월과 1 년 사이의 최근 변경 사항은 흰색으로 유지되고 지난 달에 도입 된 선은 빨간색으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="91de163844ee67c93c1b1c843cc5bef0832c9f25" translate="yes" xml:space="preserve">
          <source>It does its best to do the safe thing, it will check that the files are unchanged and up to date in the CVS checkout, and it will not autocommit by default.</source>
          <target state="translated">안전한 작업을 수행하는 것이 가장 좋으며 CVS 체크 아웃에서 파일이 변경되지 않고 최신 상태인지 확인하며 기본적으로 자동 커밋되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="92564150ed02a0207f639f4b1e8f897270e7157d" translate="yes" xml:space="preserve">
          <source>It does this by storing some additional data for each entry (such as the last modified time). This data is not displayed above, and is not stored in the created tree object, but it can be used to determine quickly which files in the working directory differ from what was stored in the index, and thus save Git from having to read all of the data from such files to look for changes.</source>
          <target state="translated">각 항목에 대한 추가 데이터 (예 : 마지막 수정 시간)를 저장하여이를 수행합니다. 이 데이터는 위에 표시되지 않고 작성된 트리 오브젝트에 저장되지 않지만 작업 디렉토리의 파일이 색인에 저장된 파일과 다른 파일을 신속하게 판별하여 Git을 모두 읽지 않아도되도록하는 데 사용할 수 있습니다. 변경 사항을 찾기 위해 해당 파일의 데이터</target>
        </trans-unit>
        <trans-unit id="af8ba1869bb0a79ae9cea38b1af5617b9069dca1" translate="yes" xml:space="preserve">
          <source>It enables git to work together with a file system monitor (see the &quot;fsmonitor-watchman&quot; section of &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;) that can inform it as to what files have been modified. This enables git to avoid having to lstat() every file to find modified files.</source>
          <target state="translated">git은 파일 시스템 모니터 ( &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 의 &quot;fsmonitor-watchman&quot;섹션 참조)와 함께 작동 하여 어떤 파일이 수정되었는지 알 수 있습니다. 이를 통해 git은 수정 된 파일을 찾기 위해 모든 파일을 lstat ()하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="af9f31199487ba705eebc5dd4bc13449d71955c8" translate="yes" xml:space="preserve">
          <source>It expects to be dealing with one project only. If it sees branches that have different roots, it will refuse to run. In that case, edit your &amp;lt;archive/branch&amp;gt; parameters to define clearly the scope of the import.</source>
          <target state="translated">하나의 프로젝트 만 처리 할 것으로 예상됩니다. 뿌리가 다른 가지가 보이면 달리기를 거부합니다. 이 경우 &amp;lt;archive / branch&amp;gt; 매개 변수를 편집하여 가져 오기 범위를 명확하게 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="d015f51d5305572fa694969daaad327b702a39d6" translate="yes" xml:space="preserve">
          <source>It helps to divide these functions into groups for discussion purposes.</source>
          <target state="translated">토론 목적으로 이러한 기능을 그룹으로 나누는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="cf8815ec8cef4d3d8f9a8adf49f25148a4887929" translate="yes" xml:space="preserve">
          <source>It is &lt;code&gt;&amp;lt;unix timestamp&amp;gt; &amp;lt;time zone offset&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;unix
timestamp&amp;gt;&lt;/code&gt; is the number of seconds since the UNIX epoch. &lt;code&gt;&amp;lt;time zone offset&amp;gt;&lt;/code&gt; is a positive or negative offset from UTC. For example CET (which is 1 hour ahead of UTC) is &lt;code&gt;+0100&lt;/code&gt;.</source>
          <target state="translated">그것은 인 &lt;code&gt;&amp;lt;unix timestamp&amp;gt; &amp;lt;time zone offset&amp;gt;&lt;/code&gt; 여기서 &lt;code&gt;&amp;lt;unix timestamp&amp;gt;&lt;/code&gt; 유닉스 에포크 초이다. &lt;code&gt;&amp;lt;time zone offset&amp;gt;&lt;/code&gt; 은 UTC의 양수 또는 음수 오프셋입니다. 예를 들어 CET (UTC보다 1 시간 &lt;code&gt;+0100&lt;/code&gt; )은 +0100 입니다.</target>
        </trans-unit>
        <trans-unit id="3f4ae55d14bc9f41dc555ac55a4684de8bea2c17" translate="yes" xml:space="preserve">
          <source>It is OK to include files which have not actually changed. All changes including newly-created and deleted files should be included. When files are renamed, both the old and the new name should be included.</source>
          <target state="translated">실제로 변경되지 않은 파일을 포함해도됩니다. 새로 생성되고 삭제 된 파일을 포함한 모든 변경 사항이 포함되어야합니다. 파일 이름이 바뀌면 이전 이름과 새 이름이 모두 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="854a36265382bec82daa5a74f777ff212834a549" translate="yes" xml:space="preserve">
          <source>It is a good idea to introduce yourself to Git with your name and public email address before doing any operation. The easiest way to do so is:</source>
          <target state="translated">작업을 수행하기 전에 이름과 공개 이메일 주소로 Git에 자신을 소개하는 것이 좋습니다. 가장 쉬운 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0dc733d75bf5327e08cfc3134be1a3042cbb2515" translate="yes" xml:space="preserve">
          <source>It is a rough equivalent for:</source>
          <target state="translated">대략적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="95c229774b9b51315840e554d56265719cd8be5c" translate="yes" xml:space="preserve">
          <source>It is also a good idea when using any VCS to have only one small logical change in each commit.</source>
          <target state="translated">또한 VCS를 사용하여 각 커밋마다 하나의 작은 논리적 변경 만 가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6c5a3acbba80472c3128c6339cb1639b4bd8a27a" translate="yes" xml:space="preserve">
          <source>It is also permitted for a notes ref to point directly to a tree object, in which case the history of the notes can be read with &lt;code&gt;git log -p -g &amp;lt;refname&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">노트 참조가 트리 객체를 직접 가리킬 수도 있습니다.이 경우 노트의 히스토리를 &lt;code&gt;git log -p -g &amp;lt;refname&amp;gt;&lt;/code&gt; 으로 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df38f390855a08aaa74243c50bf2cb099b03fbb3" translate="yes" xml:space="preserve">
          <source>It is also possible for perpetually modified files to occur on any platform if a smudge or clean filter is in use on your system but a file was previously committed without running the smudge or clean filter. To fix this, run the following on an otherwise clean working tree:</source>
          <target state="translated">시스템에서 얼룩 또는 정리 필터를 사용하고 있지만 이전에 얼룩 또는 정리 필터를 실행하지 않고 파일을 커밋 한 경우 모든 플랫폼에서 영구적으로 수정 된 파일이 발생할 수도 있습니다. 이 문제를 해결하려면 깨끗한 작업 트리에서 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="b16dc4f2558875d3f67cc118d8aee343695acae5" translate="yes" xml:space="preserve">
          <source>It is also possible to fetch a subset of branches or tags by using a comma-separated list of names within braces. For example:</source>
          <target state="translated">중괄호 안에 쉼표로 구분 된 이름 목록을 사용하여 분기 또는 태그의 하위 집합을 가져올 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="12b7523072e662c296ea1a80ba59ec7ed5fcb7e4" translate="yes" xml:space="preserve">
          <source>It is also possible to introduce completely new merge commits from scratch by adding a command of the form &lt;code&gt;merge &amp;lt;merge-head&amp;gt;&lt;/code&gt;. This form will generate a tentative commit message and always open an editor to let the user edit it. This can be useful e.g. when a topic branch turns out to address more than a single concern and wants to be split into two or even more topic branches. Consider this todo list:</source>
          <target state="translated">&lt;code&gt;merge &amp;lt;merge-head&amp;gt;&lt;/code&gt; 형식의 명령을 추가하여 완전히 새로운 병합 커밋을 처음부터 도입 할 수도 있습니다 . 이 양식은 임시 커밋 메시지를 생성하고 사용자가 편집 할 수 있도록 항상 편집기를 엽니 다. 예를 들어 주제 분기가 하나 이상의 관심사를 해결하고 둘 이상의 주제 분기로 분할하려는 경우에 유용 할 수 있습니다. 이 할 일 목록을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e8d4e8a65d3b558ba4900bdd06798676f68d11ad" translate="yes" xml:space="preserve">
          <source>It is also possible to provide true CVS access to a Git repository, so that developers can still use CVS; see &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt; for details.</source>
          <target state="translated">개발자가 여전히 CVS를 사용할 수 있도록 Git 저장소에 대한 진정한 CVS 액세스를 제공 할 수도 있습니다. 자세한 내용은 &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3fcb2e34d6c27144258c45911fcc9298afaeeefa" translate="yes" xml:space="preserve">
          <source>It is also possible to replace commits further back in the history, but this is an advanced topic to be left for &lt;a href=&quot;#cleaning-up-history&quot;&gt;another chapter&lt;/a&gt;.</source>
          <target state="translated">히스토리에서 커밋을 다시 대체하는 것도 가능하지만 이것은 &lt;a href=&quot;#cleaning-up-history&quot;&gt;다른 장에서&lt;/a&gt; 남겨 두어야 할 고급 주제 입니다.</target>
        </trans-unit>
        <trans-unit id="14665d6ab0c5fa19cd26aec534fecd5dda3c4692" translate="yes" xml:space="preserve">
          <source>It is also run after &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;, unless the &lt;code&gt;--no-checkout&lt;/code&gt; (&lt;code&gt;-n&lt;/code&gt;) option is used. The first parameter given to the hook is the null-ref, the second the ref of the new HEAD and the flag is always 1. Likewise for &lt;code&gt;git worktree add&lt;/code&gt; unless &lt;code&gt;--no-checkout&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;--no-checkout&lt;/code&gt; ( &lt;code&gt;-n&lt;/code&gt; ) 옵션을 사용 하지 않으면 &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 후에 실행 됩니다. 후크에 제공된 첫 번째 매개 변수는 널 참조이고, 두 번째는 새 HEAD의 참조이며 플래그는 항상 1 입니다. &lt;code&gt;--no-checkout&lt;/code&gt; 이 사용 되지 않는 한 &lt;code&gt;git worktree add&lt;/code&gt; 의 경우와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="2bf0b4701dd5a8615d5c5a4270f19ec18f43aa49" translate="yes" xml:space="preserve">
          <source>It is an error if &amp;lt;dst&amp;gt; matches more than one remote refs.</source>
          <target state="translated">&amp;lt;dst&amp;gt;가 둘 이상의 원격 참조와 일치하면 오류입니다.</target>
        </trans-unit>
        <trans-unit id="47ed8fd8a6ccf512f8dd41b7de1bb50b3d494692" translate="yes" xml:space="preserve">
          <source>It is an error if &amp;lt;src&amp;gt; does not match exactly one of the local refs.</source>
          <target state="translated">&amp;lt;src&amp;gt;가 로컬 참조 중 하나와 정확히 일치하지 않으면 오류입니다.</target>
        </trans-unit>
        <trans-unit id="08551e573ca80a9130c1ec33d2456a204ee6a838" translate="yes" xml:space="preserve">
          <source>It is an error to specify a ref that does not pass &quot;git check-ref-format&quot; scrutiny. Duplicated values are filtered.</source>
          <target state="translated">&quot;git check-ref-format&quot;검사를 통과하지 않은 참조를 지정하는 것은 오류입니다. 중복 된 값이 필터링됩니다.</target>
        </trans-unit>
        <trans-unit id="91dc5c05cc945b2e35d03a4d25f4568585356b02" translate="yes" xml:space="preserve">
          <source>It is assumed that any handshaking procedures have already been completed (such as sending service request for git://) before this helper is started.</source>
          <target state="translated">이 헬퍼가 시작되기 전에 핸드 셰이 킹 절차 (git : //에 대한 서비스 요청 전송 등)가 이미 완료된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="7a3002fc7973dbc26474a90f4bdcb162301b4e67" translate="yes" xml:space="preserve">
          <source>It is currently only possible to recreate the merge commits using the &lt;code&gt;recursive&lt;/code&gt; merge strategy; Different merge strategies can be used only via explicit &lt;code&gt;exec git merge -s &amp;lt;strategy&amp;gt; [...]&lt;/code&gt; commands.</source>
          <target state="translated">현재 &lt;code&gt;recursive&lt;/code&gt; 병합 전략을 사용하여 병합 커밋을 다시 만들 수만 있습니다 . 다른 병합 전략은 명시 적 &lt;code&gt;exec git merge -s &amp;lt;strategy&amp;gt; [...]&lt;/code&gt; 명령을 통해서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd70cf0a22a7ad38ee60197dd400f891cf0d57a3" translate="yes" xml:space="preserve">
          <source>It is expected that the content of the commit object you created while following the example above generates a different SHA-1 hash than the one shown above because the commit object records the time when it was created and the name of the person performing the commit.</source>
          <target state="translated">커밋 개체는 생성 된 시간과 커밋을 수행하는 사람의 이름을 기록하기 때문에 위의 예를 따르는 동안 생성 한 커밋 개체의 내용은 위에 표시된 것과 다른 SHA-1 해시를 생성 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="f78a88555b80a7cb6f279e6cf8551b4ade125a2a" translate="yes" xml:space="preserve">
          <source>It is followed by one or more extended header lines (this example shows a merge with two parents):</source>
          <target state="translated">그 뒤에 하나 이상의 확장 된 헤더 행이옵니다 (이 예에서는 두 부모와의 병합을 보여줍니다).</target>
        </trans-unit>
        <trans-unit id="4d181ca929d0bcae1d19e843f3c648e99a609d36" translate="yes" xml:space="preserve">
          <source>It is followed by one or more extended header lines:</source>
          <target state="translated">그 뒤에 하나 이상의 확장 된 헤더 행이옵니다.</target>
        </trans-unit>
        <trans-unit id="a6770fb3a63d614ebdc42bea002a81ec83ae2568" translate="yes" xml:space="preserve">
          <source>It is followed by two-line from-file/to-file header</source>
          <target state="translated">그 다음에 2 줄 From 파일 / to 파일 헤더가옵니다.</target>
        </trans-unit>
        <trans-unit id="31bbdf9a81fa3062a8106d3f0d5511057b4a5222" translate="yes" xml:space="preserve">
          <source>It is highly functional. However, not all methods are implemented, and for those methods that are implemented, not all switches are implemented.</source>
          <target state="translated">매우 기능적입니다. 그러나 모든 방법이 구현 된 것은 아니며 구현 된 방법에 대해 모든 스위치가 구현되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="13209c7d424e2b65e2d35ccb5123d7d58e26c1e7" translate="yes" xml:space="preserve">
          <source>It is important to realize that at this point nothing refers to commit &lt;code&gt;f&lt;/code&gt;. Eventually commit &lt;code&gt;f&lt;/code&gt; (and by extension commit &lt;code&gt;e&lt;/code&gt;) will be deleted by the routine Git garbage collection process, unless we create a reference before that happens. If we have not yet moved away from commit &lt;code&gt;f&lt;/code&gt;, any of these will create a reference to it:</source>
          <target state="translated">이 시점에서 아무것도 커밋 &lt;code&gt;f&lt;/code&gt; 를 의미하지 않는다는 것을 인식하는 것이 중요합니다 . 결과적으로 커밋 &lt;code&gt;f&lt;/code&gt; (및 확장 커밋 &lt;code&gt;e&lt;/code&gt; )는 발생하기 전에 참조를 만들지 않는 한 일상적인 Git 가비지 수집 프로세스에 의해 삭제됩니다. commit &lt;code&gt;f&lt;/code&gt; 에서 멀어지지 않았다면 , 이것들에 대한 참조가 생성 될 것입니다 :</target>
        </trans-unit>
        <trans-unit id="15e77b99d56294dd4d998fab1260c89fc2b1f677" translate="yes" xml:space="preserve">
          <source>It is likely that you will be pulling from the same remote repository from time to time. As a short hand, you can store the remote repository URL in the local repository&amp;rsquo;s config file like this:</source>
          <target state="translated">때때로 동일한 원격 저장소에서 가져 오는 것 같습니다. 간단히 말해서 다음과 같이 원격 저장소 URL을 로컬 저장소의 구성 파일에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e468ce82ca7a37df3e0ccb7eddd0ee514020b622" translate="yes" xml:space="preserve">
          <source>It is likely that you will be working on more than one thing at a time. It is easy to manage those more-or-less independent tasks using branches with Git.</source>
          <target state="translated">한 번에 둘 이상의 작업을 수행 할 수 있습니다. Git이있는 브랜치를 사용하여 독립적 인 작업을 쉽게 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="cdfac588afc71ee687618e7ec3bc2f824e200606" translate="yes" xml:space="preserve">
          <source>It is not always easy for new developers to find their way through Git&amp;rsquo;s source code. This section gives you a little guidance to show where to start.</source>
          <target state="translated">새로운 개발자가 Git의 소스 코드를 통해 길을 찾는 것이 항상 쉬운 것은 아닙니다. 이 섹션에서는 어디서부터 시작해야하는지에 대한 간단한 지침을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="deded1cb8baf6033568ee8de4cb9cb55818cb450" translate="yes" xml:space="preserve">
          <source>It is not recommended to use this feature if you intend to export changes back to CVS again later with &lt;code&gt;git cvsexportcommit&lt;/code&gt;.</source>
          <target state="translated">나중에 &lt;code&gt;git cvsexportcommit&lt;/code&gt; 을 사용하여 변경 사항을 CVS로 다시 내보내려면이 기능을 사용하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="598d612724092a05c80fc92ca656e4e685e7e227" translate="yes" xml:space="preserve">
          <source>It is obviously a good idea not to have commits with changes that knowingly break things, even if some other commits later fix the breakage.</source>
          <target state="translated">다른 커밋이 나중에 파손을 수정하더라도 고의로 문제를 해결하는 변경 사항을 커밋하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8402ec5252190f6132c0772d2b1eafbec27785df" translate="yes" xml:space="preserve">
          <source>It is possible that a merge failure will prevent this process from being completely automatic. You will have to resolve any such merge failure and run &lt;code&gt;git rebase --continue&lt;/code&gt;. Another option is to bypass the commit that caused the merge failure with &lt;code&gt;git rebase --skip&lt;/code&gt;. To check out the original &amp;lt;branch&amp;gt; and remove the .git/rebase-apply working files, use the command &lt;code&gt;git rebase --abort&lt;/code&gt; instead.</source>
          <target state="translated">병합 실패로 인해이 프로세스가 완전히 자동으로 진행되지 않을 수 있습니다. 이러한 병합 실패를 해결하고 &lt;code&gt;git rebase --continue&lt;/code&gt; 을 실행해야합니다 . 또 다른 옵션은 &lt;code&gt;git rebase --skip&lt;/code&gt; 로 병합 실패를 일으킨 커밋을 무시하는 것 입니다. 원본 &amp;lt;branch&amp;gt;를 확인하고 .git / rebase-apply 작업 파일을 제거하려면 대신 &lt;code&gt;git rebase --abort&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ea7f2913c3e95cfd4ae5ff1f6d8aecb190ef204" translate="yes" xml:space="preserve">
          <source>It is possible to construct these old form repositories manually.</source>
          <target state="translated">이러한 이전 양식 저장소를 수동으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="548453998a9c855739e7eb9ec21e0581e0ed374b" translate="yes" xml:space="preserve">
          <source>It is possible to disable use of replacement references for any command using the &lt;code&gt;--no-replace-objects&lt;/code&gt; option just after &lt;code&gt;git&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git&lt;/code&gt; 바로 뒤에 &lt;code&gt;--no-replace-objects&lt;/code&gt; 옵션을 사용하여 명령에 대한 대체 참조 사용을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c06956dd566d0990dc7bdbc85eb39fd34edd8452" translate="yes" xml:space="preserve">
          <source>It is preceded with a &quot;git diff&quot; header that looks like this:</source>
          <target state="translated">다음과 같은 &quot;git diff&quot;헤더가 앞에옵니다 :</target>
        </trans-unit>
        <trans-unit id="fae83443f259566d0e3ea169c2bee02ad7796585" translate="yes" xml:space="preserve">
          <source>It is preceded with a &quot;git diff&quot; header, that looks like this (when the &lt;code&gt;-c&lt;/code&gt; option is used):</source>
          <target state="translated">&quot;git diff&quot;헤더가 앞에옵니다. ( &lt;code&gt;-c&lt;/code&gt; 옵션을 사용하는 경우) :</target>
        </trans-unit>
        <trans-unit id="41c2e2ee7c9260a90ac9d47c12dc86595dc670c7" translate="yes" xml:space="preserve">
          <source>It is purely performance optimization, originally intended for MacOS X, where recursive directory traversal is slow. Gitweb follows symbolic links, but it detects cycles, ignoring any duplicate files and directories.</source>
          <target state="translated">재귀 적 디렉토리 탐색 속도가 느린 MacOS X를위한 순수한 성능 최적화입니다. Gitweb은 심볼릭 링크를 따르지만 중복 파일과 디렉토리는 무시하고주기를 감지합니다.</target>
        </trans-unit>
        <trans-unit id="bcd29e9bb49344b0e527480d5a1209557826cefc" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; always be encoded using UTF-8.</source>
          <target state="translated">&lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 는 항상 UTF-8을 사용하여 인코딩하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="987c2f12e083069e2c3c6529da1c2b8427b5d901" translate="yes" xml:space="preserve">
          <source>It is safer if both &lt;code&gt;test.sh&lt;/code&gt; and &lt;code&gt;check_test_case.sh&lt;/code&gt; are outside the repository to prevent interactions between the bisect, make and test processes and the scripts.</source>
          <target state="translated">bisect, make 및 test 프로세스와 스크립트 간의 상호 작용을 방지하기 위해 &lt;code&gt;test.sh&lt;/code&gt; 와 &lt;code&gt;check_test_case.sh&lt;/code&gt; 가 모두 저장소 외부에있는 것이 더 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="07dbd897b2b790cda3e0cd6c93a27be05c0967a5" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to be able to checkout a commit that is not at the tip of any named branch, or even to create a new commit that is not referenced by a named branch. Let&amp;rsquo;s look at what happens when we checkout commit &lt;code&gt;b&lt;/code&gt; (here we show two ways this may be done):</source>
          <target state="translated">명명 된 분기의 끝에없는 커밋을 체크 아웃하거나 명명 된 분기에서 참조하지 않는 새 커밋을 만드는 것이 유용한 경우가 있습니다. 커밋 &lt;code&gt;b&lt;/code&gt; 를 체크 아웃 할 때 어떤 일이 발생하는지 살펴 보자 (여기서는 두 가지 방법이있다).</target>
        </trans-unit>
        <trans-unit id="19dd47dcbbf16a9cccaac6e901efe1eb6d41c6b4" translate="yes" xml:space="preserve">
          <source>It is still your responsibility to make sure that the email message sent by your email program meets the standards of your project. Many projects do not like patches to be attached. Some mail agents will transform patches (e.g. wrap lines, send them as format=flowed) in ways that make them fail. You will get angry flames ridiculing you if you don&amp;rsquo;t check this.</source>
          <target state="translated">이메일 프로그램에서 보낸 이메일 메시지가 프로젝트 표준을 충족하는지 확인하는 것은 여전히 ​​귀하의 책임입니다. 많은 프로젝트는 패치를 첨부하는 것을 좋아하지 않습니다. 일부 메일 에이전트는 패치를 변환 (예 : 줄 바꿈, 형식 = 흐름으로 전송)하여 실패하게 만듭니다. 이것을 확인하지 않으면 화염이 날 것입니다.</target>
        </trans-unit>
        <trans-unit id="446989de9f552ff7a375d76851b391396cb21747" translate="yes" xml:space="preserve">
          <source>It is unlikely that you would have any conflicts here &amp;hellip;​ but you might if you spent a while on this step and had also pulled new versions from upstream.</source>
          <target state="translated">여기서 충돌이 발생하지는 않지만 ...이 단계에서 잠시 시간을 보내고 업스트림에서 새 버전을 가져 왔을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d35217f8f6c81e1e684634a0bdd90859d19f06a" translate="yes" xml:space="preserve">
          <source>It is up to the user to ensure that no In-Reply-To header already exists when &lt;code&gt;git send-email&lt;/code&gt; is asked to add it (especially note that &lt;code&gt;git format-patch&lt;/code&gt; can be configured to do the threading itself). Failure to do so may not produce the expected result in the recipient&amp;rsquo;s MUA.</source>
          <target state="translated">&lt;code&gt;git send-email&lt;/code&gt; 에 헤더 를 추가하라는 요청 이있을 때 In-Reply-To 헤더가 없는지 확인하는 것은 사용자의 몫입니다 (특히 &lt;code&gt;git format-patch&lt;/code&gt; 는 스레딩 자체를 수행하도록 구성 될 수 있음). 그렇지 않으면 수신자의 MUA에서 예상되는 결과를 얻지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28ab82f4261b972bffcbd084fca6120764f529fe" translate="yes" xml:space="preserve">
          <source>It is useful when you&amp;rsquo;re looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into &lt;code&gt;-S&lt;/code&gt;, and keep going until you get the very first version of the block.</source>
          <target state="translated">구조체와 같은 정확한 코드 블록을 찾고 처음 시작한 이후 해당 블록의 히스토리를 알고 싶을 때 유용합니다.이 기능을 반복적으로 사용하여 사전 이미지의 흥미로운 블록을 &lt;code&gt;-S&lt;/code&gt; 이고 블록의 첫 번째 버전을 얻을 때까지 계속 진행하십시오.</target>
        </trans-unit>
        <trans-unit id="212ba732375c1f9e18ce6b37fe943bc0a79e8a67" translate="yes" xml:space="preserve">
          <source>It is very important that the basis used be held by the destination. It is okay to err on the side of caution, causing the bundle file to contain objects already in the destination, as these are ignored when unpacking at the destination.</source>
          <target state="translated">사용 된 기준이 목적지에 의해 유지되는 것이 매우 중요합니다. 번들 파일에 대상에 이미있는 오브젝트가 포함되어 있으므로 대상 측에서 압축을 풀 때 무시되므로 번들을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f89d35d0ac276c4d31876791b9f069b985ca50ec" translate="yes" xml:space="preserve">
          <source>It may well be that among networking people, they may want to exchange the tags internal to their group, but in that workflow they are most likely tracking each other&amp;rsquo;s progress by having remote-tracking branches. Again, the heuristic to automatically follow such tags is a good thing.</source>
          <target state="translated">네트워킹 사람들 사이에서 그룹 내부의 태그를 교환하고 싶을 수도 있지만, 워크 플로에서 원격 추적 지점을 통해 서로의 진행 상황을 추적 할 가능성이 높습니다. 다시 말하지만, 이러한 태그를 자동으로 따르는 휴리스틱은 좋은 것입니다.</target>
        </trans-unit>
        <trans-unit id="b30dde80280e412c885fe09e1718d04b65bebbd4" translate="yes" xml:space="preserve">
          <source>It must be readable in order, from beginning to end, by someone intelligent with a basic grasp of the UNIX command line, but without any special knowledge of Git. If necessary, any other prerequisites should be specifically mentioned as they arise.</source>
          <target state="translated">유닉스 명령 줄에 대한 기본적인 지식이 있지만 Git에 대한 특별한 지식이없는 사람이 처음부터 끝까지 읽을 수 있어야한다. 필요한 경우, 다른 전제 조건을 구체적으로 언급해야합니다.</target>
        </trans-unit>
        <trans-unit id="105999ab02cc181d3d21d02fda72679e92aee0b2" translate="yes" xml:space="preserve">
          <source>It should be stressed that this hierarchy is purely &lt;strong&gt;informal&lt;/strong&gt;. There is nothing fundamental in Git that enforces the &quot;chain of patch flow&quot; this hierarchy implies. You do not have to pull from only one remote repository.</source>
          <target state="translated">이 계층은 순수하게 &lt;strong&gt;비공식적&lt;/strong&gt; 이라는 점을 강조해야합니다 . Git에는이 계층 구조가 의미하는 &quot;패치 흐름 체인&quot;을 적용하는 기본 사항이 없습니다. 하나의 원격 저장소 만 가져올 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7beffad8901e95a09a82e88d22525a3cad3065d8" translate="yes" xml:space="preserve">
          <source>It shows that foo.png has differences from HEAD (but that is binary so line count cannot be shown) and there is no difference between indexed copy and the working tree version (if the working tree version were also different, &lt;code&gt;binary&lt;/code&gt; would have been shown in place of &lt;code&gt;nothing&lt;/code&gt;). The other file, git-add--interactive.perl, has 403 lines added and 35 lines deleted if you commit what is in the index, but working tree file has further modifications (one addition and one deletion).</source>
          <target state="translated">foo.png가 HEAD와 차이가 있음을 보여줍니다 (하지만 바이너리이므로 라인 수를 표시 할 수 없음). 인덱싱 된 복사본과 작업 트리 버전간에 차이가 없습니다 (작업 트리 버전도 다르면 &lt;code&gt;binary&lt;/code&gt; 가 표시되었을 것입니다). &lt;code&gt;nothing&lt;/code&gt; 대신 ). 다른 파일 인 git-add--interactive.perl에는 인덱스에있는 내용을 커밋하면 403 줄이 추가되고 35 줄이 삭제되지만 작업 트리 파일에는 추가 수정 사항이 있습니다 (하나는 추가되고 하나는 삭제됨).</target>
        </trans-unit>
        <trans-unit id="593ae3fc1288babccd02a202f40d492d26634f5a" translate="yes" xml:space="preserve">
          <source>It shows that foo.png has differences from HEAD (but that is binary so line count cannot be shown) and there is no difference between indexed copy and the working tree version (if the working tree version were also different, &lt;code&gt;binary&lt;/code&gt; would have been shown in place of &lt;code&gt;nothing&lt;/code&gt;). The other file, git-add{litdd}interactive.perl, has 403 lines added and 35 lines deleted if you commit what is in the index, but working tree file has further modifications (one addition and one deletion).</source>
          <target state="translated">그것은 foo.png가 HEAD와 차이가 있지만 (이진수이므로 줄 수를 표시 할 수 없음) 색인화 된 사본과 작업 트리 버전 사이에는 차이가 없습니다 (작업 트리 버전도 다르면 &lt;code&gt;binary&lt;/code&gt; 되었을 것입니다) &lt;code&gt;nothing&lt;/code&gt; 대신 ). 색인에있는 내용을 커밋하면 다른 파일 인 git-add {litdd} interactive.perl에 403 줄이 추가되고 35 줄이 삭제되지만 작업 트리 파일에는 추가 수정 (한 번의 추가 및 한 번의 삭제)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f22531fd9489cd1b4496c81c3454037c20af1a5" translate="yes" xml:space="preserve">
          <source>It takes a variable number of parameters, each of which is the name of ref that was actually updated.</source>
          <target state="translated">가변 개수의 매개 변수를 사용하며 각 매개 변수는 실제로 업데이트 된 ref의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8d1640303505dff202eb78d383641a82298beff2" translate="yes" xml:space="preserve">
          <source>It takes on the standard input the specification of the options to parse and understand, and echoes on the standard output a string suitable for &lt;code&gt;sh(1)&lt;/code&gt;&lt;code&gt;eval&lt;/code&gt; to replace the arguments with normalized ones. In case of error, it outputs usage on the standard error stream, and exits with code 129.</source>
          <target state="translated">표준 입력에서 구문 분석 및 이해하는 옵션의 스펙을 취하고 표준 출력 에서 인수를 정규화 된 인수로 대체 하기 위해 &lt;code&gt;sh(1)&lt;/code&gt; &lt;code&gt;eval&lt;/code&gt; 에 적합한 문자열을 에코 합니다. 오류가 발생하면 표준 오류 스트림에서 사용량을 출력하고 코드 129로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="9fc9d0adb73a5f351f66393e06f90ebbcd611062" translate="yes" xml:space="preserve">
          <source>It takes one to three parameters. The first is the name of the file that contains the commit log message. The second is the source of the commit message, and can be: &lt;code&gt;message&lt;/code&gt; (if a &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; option was given); &lt;code&gt;template&lt;/code&gt; (if a &lt;code&gt;-t&lt;/code&gt; option was given or the configuration option &lt;code&gt;commit.template&lt;/code&gt; is set); &lt;code&gt;merge&lt;/code&gt; (if the commit is a merge or a &lt;code&gt;.git/MERGE_MSG&lt;/code&gt; file exists); &lt;code&gt;squash&lt;/code&gt; (if a &lt;code&gt;.git/SQUASH_MSG&lt;/code&gt; file exists); or &lt;code&gt;commit&lt;/code&gt;, followed by a commit SHA-1 (if a &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt; or &lt;code&gt;--amend&lt;/code&gt; option was given).</source>
          <target state="translated">1 ~ 3 개의 매개 변수가 필요합니다. 첫 번째는 커밋 로그 메시지가 포함 된 파일 이름입니다. 두 번째는 커밋 메시지의 소스이며 다음과 같습니다. &lt;code&gt;message&lt;/code&gt; ( &lt;code&gt;-m&lt;/code&gt; 또는 &lt;code&gt;-F&lt;/code&gt; 옵션이 제공된 경우); &lt;code&gt;template&lt;/code&gt; ( &lt;code&gt;-t&lt;/code&gt; 옵션이 제공되었거나 구성 옵션 &lt;code&gt;commit.template&lt;/code&gt; 이 설정된 경우); &lt;code&gt;merge&lt;/code&gt; (커밋이 병합이거나 &lt;code&gt;.git/MERGE_MSG&lt;/code&gt; 파일이있는 경우); &lt;code&gt;squash&lt;/code&gt; ( &lt;code&gt;.git/SQUASH_MSG&lt;/code&gt; 파일이있는 경우); 또는 &lt;code&gt;commit&lt;/code&gt; 다음에 commit SHA-1 ( &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; 또는 &lt;code&gt;--amend&lt;/code&gt; 인 경우) 옵션이 제공되었습니다).</target>
        </trans-unit>
        <trans-unit id="ee62cbb1781a10ccff3a10f01577042e41951364" translate="yes" xml:space="preserve">
          <source>It tells you that it did an &quot;Automatic merge&quot;, which failed due to conflicts in &lt;code&gt;hello&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hello&lt;/code&gt; 의 충돌로 인해 실패한 &quot;자동 병합&quot;을 수행했음을 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="31dbee78e4c488ce29554dd490d874937eb736b5" translate="yes" xml:space="preserve">
          <source>It used to be that the command defaulted to do &lt;code&gt;-x&lt;/code&gt; described above, and &lt;code&gt;-r&lt;/code&gt; was to disable it. Now the default is not to do &lt;code&gt;-x&lt;/code&gt; so this option is a no-op.</source>
          <target state="translated">이전에는 명령이 위에서 설명한 &lt;code&gt;-x&lt;/code&gt; 를 기본 으로 사용했으며 &lt;code&gt;-r&lt;/code&gt; 은 명령을 비활성화했습니다. 이제 기본값은 &lt;code&gt;-x&lt;/code&gt; 를 수행하지 않으므로이 옵션은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5579126502958d7cf2a79d1e6eb0f1ab9f1fb74" translate="yes" xml:space="preserve">
          <source>It uses &lt;code&gt;showbranch.default&lt;/code&gt; multi-valued configuration items if no &amp;lt;rev&amp;gt; or &amp;lt;glob&amp;gt; is given on the command line.</source>
          <target state="translated">그것은 사용 &lt;code&gt;showbranch.default&lt;/code&gt; 더 &amp;lt;REV&amp;gt; 또는 &amp;lt;글로브&amp;gt;이 명령 행에 주어지지 않으면 다치 구성 항목.</target>
        </trans-unit>
        <trans-unit id="c599d3ca0dc61039dd83109e0beef002f0abd196" translate="yes" xml:space="preserve">
          <source>It verifies that the directory has the magic file &quot;git-daemon-export-ok&quot;, and it will refuse to export any Git directory that hasn&amp;rsquo;t explicitly been marked for export this way (unless the &lt;code&gt;--export-all&lt;/code&gt; parameter is specified). If you pass some directory paths as &lt;code&gt;git daemon&lt;/code&gt; arguments, you can further restrict the offers to a whitelist comprising of those.</source>
          <target state="translated">디렉토리에 매직 파일 &quot;git-daemon-export-ok&quot;가 있는지 확인하고 &lt;code&gt;--export-all&lt;/code&gt; 매개 변수를 지정 하지 않는 한 명시 적으로 내보내기 용으로 표시되지 않은 Git 디렉토리의 내보내기를 거부 합니다. ). 일부 디렉토리 경로를 &lt;code&gt;git daemon&lt;/code&gt; 인수 로 전달 하면 해당 오퍼를 추가로 화이트리스트로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fd1b09d35c94e426d7de9278697f8281d2f9b0b" translate="yes" xml:space="preserve">
          <source>It verifies that the directory has the magic file &quot;git-daemon-export-ok&quot;, and it will refuse to export any Git directory that hasn&amp;rsquo;t explicitly been marked for export this way (unless the &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; environmental variable is set).</source>
          <target state="translated">디렉토리에 매직 파일 &quot;git-daemon-export-ok&quot;가 &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; 하고 GIT_HTTP_EXPORT_ALL 환경 변수가 설정 되지 않은 경우 명시 적으로 내 보내지 않은 Git 디렉토리의 내보내기를 거부합니다 .</target>
        </trans-unit>
        <trans-unit id="6a949f37aaca4177eee5df32a3761a98f4054a56" translate="yes" xml:space="preserve">
          <source>It was a tool of absolute last resort. I&amp;rsquo;d rather spend days looking at printk output than do a manual &lt;code&gt;patch bisection&lt;/code&gt;.</source>
          <target state="translated">절대 최후의 수단이었습니다. 수동 &lt;code&gt;patch bisection&lt;/code&gt; 보다 printk 출력을 보는 데 며칠을 보내고 싶습니다 .</target>
        </trans-unit>
        <trans-unit id="839ea1dcb179bd0fd1a734d84c9b044b60c7a423" translate="yes" xml:space="preserve">
          <source>It will be useful to have a Git repository to experiment with as you read this manual.</source>
          <target state="translated">이 매뉴얼을 읽을 때 Git 저장소를 시험해 보는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a1e588b366d6eee7b2a111ab040de25b982fdb3f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible for a push to fail in this way when other people have the right to push to the same repository. In that case, the correct solution is to retry the push after first updating your work: either by a pull, or by a fetch followed by a rebase; see the &lt;a href=&quot;#setting-up-a-shared-repository&quot;&gt;next section&lt;/a&gt; and &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt; for more.</source>
          <target state="translated">다른 사람이 동일한 저장소에 푸시 할 권한이있는 경우 이러한 방식으로 푸시가 실패 할 수도 있습니다. 이 경우 올바른 해결책은 작업을 처음 업데이트 한 후 푸시를 다시 시도하는 것입니다. 풀 (pull) 또는 페치 (fetch) 및 리베이스 (rebase); 자세한 내용은 &lt;a href=&quot;#setting-up-a-shared-repository&quot;&gt;다음 섹션&lt;/a&gt; 과 &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fb4f6e12e9b3bc515593c3c6f58a010f2584b187" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s best to remove one of the files such that you only have one file. You can do this with commands like the following (assuming two files &lt;code&gt;AFile.txt&lt;/code&gt; and &lt;code&gt;afile.txt&lt;/code&gt;) on an otherwise clean working tree:</source>
          <target state="translated">파일이 하나만 있도록 파일 중 하나를 제거하는 것이 가장 좋습니다. 그렇지 않으면 깨끗한 작업 트리 에서 다음과 같은 명령을 사용하여이 작업을 수행 할 수 있습니다 (두 파일 &lt;code&gt;AFile.txt&lt;/code&gt; 및 &lt;code&gt;afile.txt&lt;/code&gt; 라고 가정 ).</target>
        </trans-unit>
        <trans-unit id="68ec6258a88fcfa8b2ee5adddb372d62ea174c2e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common to try to use &lt;code&gt;pre-commit&lt;/code&gt; hooks (or, for commit messages, &lt;code&gt;commit-msg&lt;/code&gt; hooks) to check these things, which is great if you&amp;rsquo;re working as a solo developer and want the tooling to help you. However, using hooks on a developer machine is not effective as a policy control because a user can bypass these hooks with &lt;code&gt;--no-verify&lt;/code&gt; without being noticed (among various other ways). Git assumes that the user is in control of their local repositories and doesn&amp;rsquo;t try to prevent this or tattle on the user.</source>
          <target state="translated">이러한 사항을 확인 하기 위해 &lt;code&gt;pre-commit&lt;/code&gt; 후크 (또는 커밋 메시지의 경우 &lt;code&gt;commit-msg&lt;/code&gt; 후크)를 사용하는 것이 일반적입니다. 이는 단독 개발자로 작업 중이고 도구가 도움이되기를 원하는 경우에 좋습니다. 그러나 개발자 컴퓨터에서 후크를 사용하는 것은 사용자 가 눈에 &lt;code&gt;--no-verify&lt;/code&gt; 않고 --no-verify를 사용 하여 이러한 후크를 우회 할 수 있기 때문에 정책 제어로 효과적이지 않습니다 . Git은 사용자가 로컬 리포지토리를 제어하고 있다고 가정하고이를 방지하거나 사용자를 괴롭히지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8e637a625c72275676a912327970832afbb1fc7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s especially instructive to look at &quot;commit&quot; objects, since those tend to be small and fairly self-explanatory. In particular, if you follow the convention of having the top commit name in &lt;code&gt;.git/HEAD&lt;/code&gt;, you can do</source>
          <target state="translated">&quot;커밋&quot;객체는 작고 상당히 설명적인 경향이 있기 때문에 &quot;커밋&quot;객체를 보는 것이 특히 유익합니다. 특히 &lt;code&gt;.git/HEAD&lt;/code&gt; 에서 최상위 커밋 이름을 갖는 규칙을 따르는 경우 다음을 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ebca6c1346b961bb4e2f8a08e1112a09cf4c4143" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s far too easy to accidentally mix up old and new history. It&amp;rsquo;s still possible with any tool, but git-filter-branch almost invites it. If lucky, the only downside is users getting frustrated that they don&amp;rsquo;t know how to shrink their repo and remove the old stuff. If unlucky, they merge old and new history and end up with multiple &quot;copies&quot; of each commit, some of which have unwanted or sensitive files and others which don&amp;rsquo;t. This comes about in multiple different ways:</source>
          <target state="translated">실수로 오래된 것과 새로운 역사를 섞는 것은 너무 쉽습니다. 어떤 도구로도 가능하지만 git-filter-branch가 거의 초대합니다. 운이 좋으면 유일한 단점은 사용자가 레포를 축소하고 오래된 것을 제거하는 방법을 모른다는 좌절감을 느끼는 것입니다. 운이 좋지 않으면 구약과 새 기록을 병합하고 각 커밋의 여러 &quot;복사본&quot;으로 끝나며, 그 중 일부는 원하지 않거나 민감한 파일이 있고 그렇지 않은 파일도 있습니다. 이것은 여러 가지 방법으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7fb3124f269af4d6382e41b308c15a44d9e7c09f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not safe to run &lt;code&gt;git submodule update&lt;/code&gt; if you&amp;rsquo;ve made and committed changes within a submodule without checking out a branch first. They will be silently overwritten:</source>
          <target state="translated">분기를 먼저 체크 아웃하지 않고 서브 모듈 내에서 변경을 수행하고 커밋 한 경우 &lt;code&gt;git submodule update&lt;/code&gt; 를 실행하는 것은 안전하지 않습니다 . 그들은 자동으로 덮어 쓰기됩니다 :</target>
        </trans-unit>
        <trans-unit id="199b24a07e7c4f542f5c9b6cd233e68c58c149e6" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to push any type of object to any namespace outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt;. In the case of tags and commits, these will be treated as if they were the commits inside &lt;code&gt;refs/heads/*&lt;/code&gt; for the purposes of whether the update is allowed.</source>
          <target state="translated">모든 유형의 객체를 &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 외부의 네임 스페이스로 푸시 할 수 있습니다 . 태그와 커밋의 경우 업데이트 허용 여부를 위해 &lt;code&gt;refs/heads/*&lt;/code&gt; 내부의 커밋 인 것처럼 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="cd25bf8e6a6252931a48d686e2c25ca4a7c9f16e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s probably not worth it to use this option on a given repository without running tailored performance benchmarks on it. It takes a lot more time, and the resulting space/delta optimization may or may not be worth it. Not using this at all is the right trade-off for most users and their repositories.</source>
          <target state="translated">맞춤형 성능 벤치 마크를 실행하지 않고 주어진 저장소에서이 옵션을 사용하는 것은 가치가 없습니다. 시간이 더 많이 걸리며 결과적으로 공간 / 델타 최적화는 그만한 가치가있을 수도 있고 그렇지 않을 수도 있습니다. 이것을 전혀 사용하지 않는 것은 대부분의 사용자와 그 저장소에 대한 올바른 균형입니다.</target>
        </trans-unit>
        <trans-unit id="6c2d9fe7b4d73e7c5f324adf6070448f4f753fb5" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s reasonable to e.g. configure &lt;code&gt;fetch.pruneTags=true&lt;/code&gt; in &lt;code&gt;~/.gitconfig&lt;/code&gt; to have tags pruned whenever &lt;code&gt;git fetch --prune&lt;/code&gt; is run, without making every invocation of &lt;code&gt;git fetch&lt;/code&gt; without &lt;code&gt;--prune&lt;/code&gt; an error.</source>
          <target state="translated">예를 들어 &lt;code&gt;~/.gitconfig&lt;/code&gt; 에서 &lt;code&gt;fetch.pruneTags=true&lt;/code&gt; 를 구성 하여 &lt;code&gt;git fetch --prune&lt;/code&gt; 이 실행될 때마다 태그 를 &lt;code&gt;--prune&lt;/code&gt; 오류 를 제거 하지 않고 &lt;code&gt;git fetch&lt;/code&gt; 를 호출 하지 않아도 됩니다.</target>
        </trans-unit>
        <trans-unit id="bb5eba09f5b7ed44896e1f2e304b6636d8012774" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s tempting to try to use certain features of &lt;code&gt;git update-index&lt;/code&gt;, namely the assume-unchanged and skip-worktree bits, but these don&amp;rsquo;t work properly for this purpose and shouldn&amp;rsquo;t be used this way.</source>
          <target state="translated">&lt;code&gt;git update-index&lt;/code&gt; 의 특정 기능 , 즉 변경되지 않은 가정 및 작업 트리 건너 뛰기 비트 를 사용하려고 시도하고 싶지만 이러한 용도로는 제대로 작동하지 않으므로 이러한 방식으로 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b2ec8a66f406e3cd9a737fd2597d771efa24775d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s usually much more common that you merge with somebody else than merging with your own branches, so it&amp;rsquo;s worth pointing out that Git makes that very easy too, and in fact, it&amp;rsquo;s not that different from doing a &lt;code&gt;git merge&lt;/code&gt;. In fact, a remote merge ends up being nothing more than &quot;fetch the work from a remote repository into a temporary tag&quot; followed by a &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">일반적으로 자신의 브랜치와 병합하는 것 이외의 다른 사람과 병합하는 것이 훨씬 일반적이므로 Git을 사용하면 매우 쉽게 수행 할 수 있으며 실제로 &lt;code&gt;git merge&lt;/code&gt; 를 수행하는 것과 크게 다르지 않습니다 . 실제로, 원격 병합은 &quot;원격 저장소에서 작업을 임시 태그로 가져 오기&quot;다음에 &lt;code&gt;git merge&lt;/code&gt; 에 지나지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="09aeea995eee0f7341283401be15ea3abb990fd5" translate="yes" xml:space="preserve">
          <source>Iterate over all refs that match &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; and show them according to the given &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt;, after sorting them according to the given set of &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; is given, stop after showing that many refs. The interpolated values in &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; can optionally be quoted as string literals in the specified host language allowing their direct evaluation in that language.</source>
          <target state="translated">&lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 과 일치하는 모든 참조를 반복 하고 주어진 &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt; 세트에 따라 정렬 한 후 주어진 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 에 따라 표시합니다 . 경우 &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; 주어, 많은 심판을 표시 한 후 중지합니다. &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 의 보간 된 값 은 지정된 호스트 언어에서 문자열 리터럴로 선택적으로 인용하여 해당 언어로 직접 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddf6f030820afdde653bed6b6ae7f0e48144f06d" translate="yes" xml:space="preserve">
          <source>Join two or more development histories together</source>
          <target state="translated">둘 이상의 개발 히스토리에 참여</target>
        </trans-unit>
        <trans-unit id="045fff3a75d61e019edb089792c9fca9353d7073" translate="yes" xml:space="preserve">
          <source>Just as the filesystem &lt;code&gt;.&lt;/code&gt; (period) refers to the current directory, using a &lt;code&gt;.&lt;/code&gt; as a repository name in Git (a dot-repository) is a relative path and means your current repository.</source>
          <target state="translated">파일 시스템과 같습니다 &lt;code&gt;.&lt;/code&gt; (마침표)는를 사용하여 현재 디렉토리를 나타냅니다 &lt;code&gt;.&lt;/code&gt; Git의 저장소 이름으로 (점 저장소)는 상대 경로이며 현재 저장소를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="dec0baabf794bebc3957d3bc4ac6d462cd46c778" translate="yes" xml:space="preserve">
          <source>Just doing &lt;code&gt;git checkout-index&lt;/code&gt; does nothing. You probably meant &lt;code&gt;git checkout-index -a&lt;/code&gt;. And if you want to force it, you want &lt;code&gt;git checkout-index -f -a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git checkout-index&lt;/code&gt; 만하면 아무것도하지 않습니다. 아마도 &lt;code&gt;git checkout-index -a&lt;/code&gt; 을 의미했을 것입니다 . 그리고 그것을 강제하고 싶다면 &lt;code&gt;git checkout-index -f -a&lt;/code&gt; 원합니다 .</target>
        </trans-unit>
        <trans-unit id="af0df6a1820c3268e00c2212c3d633096817d6ad" translate="yes" xml:space="preserve">
          <source>Just in case you are doing something exotic, it should be noted that all of the &amp;lt;commit&amp;gt; in the above description, except in the &lt;code&gt;--merge-base&lt;/code&gt; case and in the last two forms that use &lt;code&gt;..&lt;/code&gt; notations, can be any &amp;lt;tree&amp;gt;.</source>
          <target state="translated">이색적인 작업을 수행하는 경우를 대비하여 &lt;code&gt;--merge-base&lt;/code&gt; 케이스와 &lt;code&gt;..&lt;/code&gt; 표기법 을 사용하는 마지막 두 가지 형식을 제외하고 위 설명의 모든 &amp;lt;commit&amp;gt;은 모든 &amp;lt; 트리&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="4909a5e9d012cc77cb3f33966c75c24bd556a2c1" translate="yes" xml:space="preserve">
          <source>Just in case you are doing something exotic, it should be noted that all of the &amp;lt;commit&amp;gt; in the above description, except in the last two forms that use &quot;..&quot; notations, can be any &amp;lt;tree&amp;gt;.</source>
          <target state="translated">당신이 이국적인 것을하고있는 경우를 위해서, &quot;..&quot;표기법을 사용하는 마지막 두 형태를 제외하고는 위의 설명에서 모든 &amp;lt;commit&amp;gt;은 모든 &amp;lt;tree&amp;gt;가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4be9ee55a1cb0649bc08a5f7fcba1609e56fcabe" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;push&lt;/code&gt;, a batch sequence of one or more &lt;code&gt;import&lt;/code&gt; is terminated with a blank line. For each batch of &lt;code&gt;import&lt;/code&gt;, the remote helper should produce a fast-import stream terminated by a &lt;code&gt;done&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; 와 마찬가지로 하나 이상의 &lt;code&gt;import&lt;/code&gt; 의 일괄 처리 시퀀스 는 빈 줄로 종료됩니다. 각 &lt;code&gt;import&lt;/code&gt; 배치에 대해 원격 헬퍼는 &lt;code&gt;done&lt;/code&gt; 명령으로 종료 된 빠른 가져 오기 스트림을 생성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="586f68de6dc69eba27bb1d4e9d9bb6d0f56b4317" translate="yes" xml:space="preserve">
          <source>Just make sure to disable line wrapping in the email client (GMail&amp;rsquo;s web interface will wrap lines no matter what, so you need to use a real IMAP client).</source>
          <target state="translated">이메일 클라이언트에서 줄 바꿈 기능을 비활성화하십시오 (Gmail의 웹 인터페이스는 내용에 상관없이 줄 바꿈하므로 실제 IMAP 클라이언트를 사용해야합니다).</target>
        </trans-unit>
        <trans-unit id="40ff32435dadcaf90c9ed938f5946c67e774e649" translate="yes" xml:space="preserve">
          <source>Just make sure to disable line wrapping in the email client (Gmail&amp;rsquo;s web interface will wrap lines no matter what, so you need to use a real IMAP client).</source>
          <target state="translated">이메일 클라이언트에서 줄 바꿈을 사용하지 않도록 설정하세요 (Gmail의 웹 인터페이스는 어떤 경우에도 줄 바꿈하므로 실제 IMAP 클라이언트를 사용해야합니다).</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="b97e8895c584b11a83b65d2dacb8c53b7178dd19" translate="yes" xml:space="preserve">
          <source>KMail</source>
          <target state="translated">KMail</target>
        </trans-unit>
        <trans-unit id="2341c447151da84825db8427aea972cadd7288d2" translate="yes" xml:space="preserve">
          <source>Keep a list of repositories you work with regularly:</source>
          <target state="translated">정기적으로 작업하는 리포지토리 목록을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="2367d7104c669108a5a4faee96aaf23e4129a768" translate="yes" xml:space="preserve">
          <source>Keep changes in working tree while discarding some previous commits</source>
          <target state="translated">이전 커밋을 삭제하면서 작업 트리의 변경 사항을 유지하십시오</target>
        </trans-unit>
        <trans-unit id="efc112fed108eb2af53bef134295307559c52881" translate="yes" xml:space="preserve">
          <source>Keep downloaded pack.</source>
          <target state="translated">다운로드 한 팩을 보관하십시오.</target>
        </trans-unit>
        <trans-unit id="9b356018df37cea79789cf69374ce84ecae93c35" translate="yes" xml:space="preserve">
          <source>Keep in mind that the &lt;code&gt;*&lt;/code&gt; (asterisk) wildcard of the local ref (right of the &lt;code&gt;:&lt;/code&gt;) &lt;strong&gt;must&lt;/strong&gt; be the farthest right path component; however the remote wildcard may be anywhere as long as it&amp;rsquo;s an independent path component (surrounded by &lt;code&gt;/&lt;/code&gt; or EOL). This type of configuration is not automatically created by &lt;code&gt;init&lt;/code&gt; and should be manually entered with a text-editor or using &lt;code&gt;git config&lt;/code&gt;.</source>
          <target state="translated">로컬 참조 의 &lt;code&gt;*&lt;/code&gt; (별표) 와일드 카드 ( &lt;code&gt;:&lt;/code&gt; 의 오른쪽 ) &lt;strong&gt;는&lt;/strong&gt; 가장 먼 경로 구성 요소 &lt;strong&gt;여야합니다&lt;/strong&gt; . 그러나 원격 와일드 카드는 독립 경로 구성 요소 ( &lt;code&gt;/&lt;/code&gt; 또는 EOL로 둘러 싸인) 인 경우 어디에나있을 수 있습니다 . 이 유형의 구성은 &lt;code&gt;init&lt;/code&gt; 에 의해 자동으로 작성되지 않으며 텍스트 편집기 또는 &lt;code&gt;git config&lt;/code&gt; 를 사용하여 수동으로 입력해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f28d8482458ad8eaca4da9ce6d9f18435a267b61" translate="yes" xml:space="preserve">
          <source>Keep repeating the process: compile the tree, test it, and depending on whether it is good or bad run &lt;code&gt;git bisect good&lt;/code&gt; or &lt;code&gt;git bisect bad&lt;/code&gt; to ask for the next commit that needs testing.</source>
          <target state="translated">프로세스를 계속 반복하십시오 : 트리를 컴파일하고 테스트 한 다음 테스트가 필요한 다음 커밋을 요청하기에 &lt;code&gt;git bisect good&lt;/code&gt; 또는 &lt;code&gt;git bisect bad&lt;/code&gt; 좋은지 나쁜지 에 따라 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="4faf21022722c230f52c5287ce302764467e820e" translate="yes" xml:space="preserve">
          <source>Keep the commits that do not change anything from its parents in the result.</source>
          <target state="translated">결과에서 부모로부터 아무것도 변경하지 않는 커밋을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="ea4937dada87f98e69877594a5bd03ebc5a4fc74" translate="yes" xml:space="preserve">
          <source>Keep the current index contents, and read the contents of the named tree-ish under the directory at &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt;. The command will refuse to overwrite entries that already existed in the original index file.</source>
          <target state="translated">현재 색인 컨텐츠를 유지하고 &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt; 의 디렉토리에서 명명 된 tree-ish의 컨텐츠를 읽으십시오 . 명령은 원래 색인 파일에 이미 존재하는 항목을 겹쳐 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d737c66ea055bf55ed844d15e52460a96096a67f" translate="yes" xml:space="preserve">
          <source>Keep the version from your branch in the work tree, but leave the path in the conflicted state for the user to sort out.</source>
          <target state="translated">작업 트리에서 분기의 버전을 유지하되 경로를 충돌 상태로 유지하여 사용자가 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="f9e507eaf43dc998f773c565be5cccbd49c418b4" translate="yes" xml:space="preserve">
          <source>Keep the working tree locked after creation. This is the equivalent of &lt;code&gt;git worktree lock&lt;/code&gt; after &lt;code&gt;git worktree add&lt;/code&gt;, but without a race condition.</source>
          <target state="translated">생성 후 작업 트리를 잠근 상태로 유지하십시오. 이것은 &lt;code&gt;git worktree add&lt;/code&gt; 후 git worktree &lt;code&gt;git worktree lock&lt;/code&gt; 과 동일 하지만 경쟁 조건이 없습니다.</target>
        </trans-unit>
        <trans-unit id="95e57eb6304d53fb35eb7b893fc3d7458db2c90c" translate="yes" xml:space="preserve">
          <source>Keep the working tree locked after creation. This is the equivalent of &lt;code&gt;git worktree lock&lt;/code&gt; after &lt;code&gt;git worktree add&lt;/code&gt;, but without race condition.</source>
          <target state="translated">작성 후 작업 트리를 잠근 상태로 유지하십시오. 이것은 &lt;code&gt;git worktree add&lt;/code&gt; 후 git worktree &lt;code&gt;git worktree lock&lt;/code&gt; 과 동일 하지만 경쟁 조건이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b288ae9d082d21fcccb8cbea92de9e2fd90c35f9" translate="yes" xml:space="preserve">
          <source>Keep unreachable objects in loose form. This implies &lt;code&gt;--revs&lt;/code&gt;.</source>
          <target state="translated">손이 닿지 않는 물건은 느슨한 형태로 보관하십시오. 이것은 &lt;code&gt;--revs&lt;/code&gt; 를 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="5fef7648dce54325886b4bd2e05123b8e3f3ba8b" translate="yes" xml:space="preserve">
          <source>Keep working in your primary repository. Your changes include modifications of your own, patches you receive via e-mails, and merges resulting from pulling the &quot;public&quot; repositories of your &quot;project lead&quot; and possibly your &quot;sub-subsystem maintainers&quot;.</source>
          <target state="translated">기본 저장소에서 계속 작업하십시오. 변경 사항에는 자신의 수정 사항, 전자 메일을 통해받는 패치 및 &quot;프로젝트 리드&quot;의 &quot;공용&quot;리포지토리 및 &quot;하위 서브 시스템 유지 관리자&quot;를 가져 와서 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="ca6eb7beb12ef44a32102578e1d606b2be688242" translate="yes" xml:space="preserve">
          <source>Keep working in your primary repository. Your changes include modifications of your own, patches you receive via e-mails, and merges resulting from pulling the &quot;public&quot; repositories of your &quot;subsystem maintainers&quot;.</source>
          <target state="translated">기본 저장소에서 계속 작업하십시오. 변경 사항에는 자신의 수정 사항, 전자 메일을 통해받는 패치 및 &quot;하위 시스템 관리자&quot;의 &quot;공용&quot;리포지토리를 가져 와서 병합되는 내용이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="04e2360cc7b28c2ccb26642bb98ceb0fcbba2f5a" translate="yes" xml:space="preserve">
          <source>Keeping a patch series up to date using git rebase</source>
          <target state="translated">git rebase를 사용하여 패치 시리즈를 최신 상태로 유지</target>
        </trans-unit>
        <trans-unit id="b81b785228a23fa6b75a5abffb474819b40a8136" translate="yes" xml:space="preserve">
          <source>Kill keywords: will extract files with &lt;code&gt;-kk&lt;/code&gt; from the CVS archive to avoid noisy changesets. Highly recommended, but off by default to preserve compatibility with early imported trees.</source>
          <target state="translated">키워드 삭제 : 노이즈가 많은 변경 세트를 피하기 위해 CVS 아카이브에서 &lt;code&gt;-kk&lt;/code&gt; 를 사용하여 파일을 추출합니다 . 초기 가져 오기 트리와의 호환성을 유지하려면 강력히 권장하지만 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="02658e782a0ecc008f0ca6ffc2a20f7bdbee96d7" translate="yes" xml:space="preserve">
          <source>Label for the &quot;home link&quot; at the top of all pages, leading to &lt;code&gt;$home_link&lt;/code&gt; (usually the main gitweb page, which contains the projects list). It is used as the first component of gitweb&amp;rsquo;s &quot;breadcrumb trail&quot;: &lt;code&gt;&amp;lt;home link&amp;gt; / &amp;lt;project&amp;gt; / &amp;lt;action&amp;gt;&lt;/code&gt;. Can be set at build time using the &lt;code&gt;GITWEB_HOME_LINK_STR&lt;/code&gt; variable. By default it is set to &quot;projects&quot;, as this link leads to the list of projects. Another popular choice is to set it to the name of site. Note that it is treated as raw HTML so it should not be set from untrusted sources.</source>
          <target state="translated">모든 페이지의 상단에있는 &quot;홈 링크&quot;에 대한 레이블로 &lt;code&gt;$home_link&lt;/code&gt; (일반적으로 프로젝트 목록을 포함하는 기본 gitweb 페이지)로 연결됩니다. gitweb의 &quot;breadcrumb trail&quot;의 첫 번째 구성 요소로 사용됩니다 : &lt;code&gt;&amp;lt;home link&amp;gt; / &amp;lt;project&amp;gt; / &amp;lt;action&amp;gt;&lt;/code&gt; . 빌드시 &lt;code&gt;GITWEB_HOME_LINK_STR&lt;/code&gt; 변수를 사용하여 설정할 수 있습니다 . 이 링크는 프로젝트 목록으로 연결되므로 기본적으로 &quot;프로젝트&quot;로 설정됩니다. 또 다른 인기있는 선택은 사이트 이름으로 설정하는 것입니다. 원시 HTML로 취급되므로 신뢰할 수없는 소스에서 설정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f135ec40c7a65e232b6284c7eadaae14bc4ec8e7" translate="yes" xml:space="preserve">
          <source>Labelling of conflicts markers</source>
          <target state="translated">충돌 마커의 라벨링</target>
        </trans-unit>
        <trans-unit id="19b52717c24503e82535f1da97544e03ef42f759" translate="yes" xml:space="preserve">
          <source>Large projects are often composed of smaller, self-contained modules. For example, an embedded Linux distribution&amp;rsquo;s source tree would include every piece of software in the distribution with some local modifications; a movie player might need to build against a specific, known-working version of a decompression library; several independent programs might all share the same build scripts.</source>
          <target state="translated">대규모 프로젝트는 종종 작은 독립형 모듈로 구성됩니다. 예를 들어, 임베디드 Linux 배포판의 소스 트리에는 일부 로컬 수정 사항이 포함 된 배포판의 모든 소프트웨어가 포함됩니다. 영화 플레이어는 작동하는 특정 버전의 압축 해제 라이브러리에 대해 빌드해야합니다. 여러 독립 프로그램이 모두 동일한 빌드 스크립트를 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eebf4c31734b36e391dbec8f9bdc861cf73858fc" translate="yes" xml:space="preserve">
          <source>Later, Bob can update his repo with Alice&amp;rsquo;s latest changes using</source>
          <target state="translated">나중에 Bob은 Alice의 최신 변경 사항을 사용하여 자신의 저장소를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b67e320eff785b446a82207f60f64bae4d9398b2" translate="yes" xml:space="preserve">
          <source>Later, you can see whether your changes have been applied by saying (still on &lt;code&gt;topic&lt;/code&gt;):</source>
          <target state="translated">나중에 ( &lt;code&gt;topic&lt;/code&gt; )를 말하여 변경 사항이 적용되었는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c480c6f24e2582817904a3ca717bfe059eaf9ba" translate="yes" xml:space="preserve">
          <source>Leading &lt;code&gt;Re:&lt;/code&gt;, &lt;code&gt;re:&lt;/code&gt;, and &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">선행 &lt;code&gt;Re:&lt;/code&gt; , &lt;code&gt;re:&lt;/code&gt; , 및 &lt;code&gt;:&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cba31f4e857a58fc5d56324b4f5b7ba501d5431" translate="yes" xml:space="preserve">
          <source>Leading and trailing whitespace are ignored.</source>
          <target state="translated">선행 및 후행 공백은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9400d93a0e4bf560ae2ff2a8521028a1c12485de" translate="yes" xml:space="preserve">
          <source>Leading and trailing whitespace.</source>
          <target state="translated">선행 및 후행 공백.</target>
        </trans-unit>
        <trans-unit id="b0ca289dea1d9e545043917d0313a90afe03b7b2" translate="yes" xml:space="preserve">
          <source>Leading bracketed strings (between &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;, usually &lt;code&gt;[PATCH]&lt;/code&gt;).</source>
          <target state="translated">선행 대괄호 문자열 ( &lt;code&gt;[&lt;/code&gt; 와 &lt;code&gt;]&lt;/code&gt; 사이 , 일반적으로 &lt;code&gt;[PATCH]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7f2cfa3cf0fb13a4db7434c1da2b8c70142683de" translate="yes" xml:space="preserve">
          <source>Leaving this value at the default size is fine unless you know that either the remote server or a proxy in the middle doesn&amp;rsquo;t support HTTP/1.1 (which introduced the chunked transfer encoding) or is known to be broken with chunked data. This is often (erroneously) suggested as a solution for generic push problems, but since almost every server and proxy supports at least HTTP/1.1, raising this value usually doesn&amp;rsquo;t solve most push problems. A server or proxy that didn&amp;rsquo;t correctly support HTTP/1.1 and chunked transfer encoding wouldn&amp;rsquo;t be that useful on the Internet today, since it would break lots of traffic.</source>
          <target state="translated">원격 서버 또는 중간에있는 프록시가 HTTP / 1.1 (청크 된 전송 인코딩을 도입 함)을 지원하지 않거나 청크 된 데이터로 손상되는 것으로 알려진 경우가 아니면이 값을 기본 크기로 두는 것이 좋습니다. 이것은 일반적인 푸시 문제에 대한 해결책으로 종종 (잘못) 제안되지만 거의 모든 서버와 프록시가 최소한 HTTP / 1.1을 지원하기 때문에이 값을 올리는 것은 대부분의 푸시 문제를 해결하지 못합니다. HTTP / 1.1 및 청크 전송 인코딩을 올바르게 지원하지 않는 서버 또는 프록시는 많은 트래픽을 차단하기 때문에 오늘날 인터넷에서 그다지 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5fae931542a3559bb8c0d5b861a24e60a1ac67c" translate="yes" xml:space="preserve">
          <source>Left-, middle-, or right-align the content between %(align:&amp;hellip;​) and %(end). The &quot;align:&quot; is followed by &lt;code&gt;width=&amp;lt;width&amp;gt;&lt;/code&gt; and &lt;code&gt;position=&amp;lt;position&amp;gt;&lt;/code&gt; in any order separated by a comma, where the &lt;code&gt;&amp;lt;position&amp;gt;&lt;/code&gt; is either left, right or middle, default being left and &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; is the total length of the content with alignment. For brevity, the &quot;width=&quot; and/or &quot;position=&quot; prefixes may be omitted, and bare &amp;lt;width&amp;gt; and &amp;lt;position&amp;gt; used instead. For instance, &lt;code&gt;%(align:&amp;lt;width&amp;gt;,&amp;lt;position&amp;gt;)&lt;/code&gt;. If the contents length is more than the width then no alignment is performed. If used with &lt;code&gt;--quote&lt;/code&gt; everything in between %(align:&amp;hellip;​) and %(end) is quoted, but if nested then only the topmost level performs quoting.</source>
          <target state="translated">% (align :&amp;hellip;)와 % (end) 사이에서 내용을 왼쪽, 중간 또는 오른쪽으로 맞 춥니 다. &quot;align :&quot;뒤에는 쉼표로 구분 된 순서대로 &lt;code&gt;width=&amp;lt;width&amp;gt;&lt;/code&gt; 및 &lt;code&gt;position=&amp;lt;position&amp;gt;&lt;/code&gt; 이옵니다. 여기서 &lt;code&gt;&amp;lt;position&amp;gt;&lt;/code&gt; 은 왼쪽, 오른쪽 또는 중간이며 기본값은 왼쪽이고 &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; 는 총계입니다. 정렬 내용의 길이. 간결하게하기 위해 &quot;width =&quot;및 / 또는 &quot;position =&quot;접두사는 생략하고 대신 &amp;lt;width&amp;gt; 및 &amp;lt;position&amp;gt;을 사용할 수 있습니다. 예를 들어 &lt;code&gt;%(align:&amp;lt;width&amp;gt;,&amp;lt;position&amp;gt;)&lt;/code&gt; 입니다. 내용 길이가 너비보다 크면 정렬이 수행되지 않습니다. % (align :&amp;hellip;))와 % (end) 사이의 모든 것을 &lt;code&gt;--quote&lt;/code&gt; 와 함께 사용하면 ,그러나 중첩 된 경우 최상위 레벨 만 인용을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4913da5c2a93f28cfca5df10654d75686a764062" translate="yes" xml:space="preserve">
          <source>Legacy alias for &lt;code&gt;--smtp-encryption ssl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--smtp-encryption ssl&lt;/code&gt; 의 레거시 별명 .</target>
        </trans-unit>
        <trans-unit id="8c79d7d578b1dfedd061424fe06d7bbd7bf7860a" translate="yes" xml:space="preserve">
          <source>Legacy monitoring operations are not supported (edit, watch and related). Exports and tagging (tags and branches) are not supported at this stage.</source>
          <target state="translated">레거시 모니터링 작업은 지원되지 않습니다 (편집, 감시 및 관련). 이 단계에서는 내보내기 및 태그 지정 (태그 및 분기)이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="efdb524a0ef0e2256e12ca50686b4d8bc222c208" translate="yes" xml:space="preserve">
          <source>Lesson three is: study the code. Really, it is the best way to learn about the organization of Git (after you know the basic concepts).</source>
          <target state="translated">세 번째 교훈은 코드를 연구하는 것입니다. 실제로 Git의 조직에 대해 배우는 가장 좋은 방법입니다 (기본 개념을 알고 난 후에).</target>
        </trans-unit>
        <trans-unit id="893b35eb2ef36c307a5615060033f2510cf02d9b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s also suppose that we have a cleaned up graph like one after step 1) in the bisection algorithm above. This means that we can measure the information we get in terms of number of commit we can remove from the graph..</source>
          <target state="translated">또한 위의 이분법 알고리즘에서 1) 단계 이후와 같이 정리 된 그래프가 있다고 가정 해 봅시다. 즉, 그래프에서 제거 할 수있는 커밋 수와 관련하여 얻은 정보를 측정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8d0e17bfd7a63329a6082665d278b7fb499b0b6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s skip over the obvious details; the only really interesting part here is the call to &lt;code&gt;get_sha1()&lt;/code&gt;. It tries to interpret &lt;code&gt;argv[2]&lt;/code&gt; as an object name, and if it refers to an object which is present in the current repository, it writes the resulting SHA-1 into the variable &lt;code&gt;sha1&lt;/code&gt;.</source>
          <target state="translated">명백한 세부 사항을 건너 뛰십시오. 여기서 정말로 흥미로운 부분은 &lt;code&gt;get_sha1()&lt;/code&gt; 호출 입니다. &lt;code&gt;argv[2]&lt;/code&gt; 를 객체 이름으로 해석하려고 시도 하고 현재 저장소에있는 객체를 참조하면 결과 SHA-1을 변수 &lt;code&gt;sha1&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="cc9abf37f1be76cb29eb48ded27f1fe2938a8b22" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start a new project and create a small amount of history:</source>
          <target state="translated">새 프로젝트를 시작하고 적은 역사를 만들어 봅시다 :</target>
        </trans-unit>
        <trans-unit id="f0d62f9783a955198cc607ca11b36e935a346c02" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the following graph as an example:</source>
          <target state="translated">다음 그래프를 예로 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="1c0b60e2ec5a47fbbf8d5055a8c4fd552a20bdbd" translate="yes" xml:space="preserve">
          <source>Lets you rewrite Git revision history by rewriting the branches mentioned in the &amp;lt;rev-list options&amp;gt;, applying custom filters on each revision. Those filters can modify each tree (e.g. removing a file or running a perl rewrite on all files) or information about each commit. Otherwise, all information (including original commit times or merge information) will be preserved.</source>
          <target state="translated">&amp;lt;rev-list options&amp;gt;에 언급 된 브랜치를 다시 작성하여 각 개정판에 사용자 정의 필터를 적용하여 Git 개정 내역을 다시 작성할 수 있습니다. 이러한 필터는 각 트리 (예 : 파일 제거 또는 모든 파일에서 perl 다시 쓰기 실행) 또는 각 커밋에 대한 정보를 수정할 수 있습니다. 그렇지 않으면 모든 정보 (원래 커밋 시간 또는 병합 정보 포함)가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="8a762e028503c19597a52f977263fd61a8df56e0" translate="yes" xml:space="preserve">
          <source>Lighttpd</source>
          <target state="translated">Lighttpd</target>
        </trans-unit>
        <trans-unit id="c20b9e30add4d8fcb9e944c3a79357b0eb58faf9" translate="yes" xml:space="preserve">
          <source>Like --allow-empty this command is primarily for use by foreign SCM interface scripts. It allows you to create a commit with an empty commit message without using plumbing commands like &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt;.</source>
          <target state="translated">--allow-empty와 같이이 명령은 주로 외부 SCM 인터페이스 스크립트에서 사용됩니다. &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree [1]&lt;/a&gt; 과 같은 배관 명령을 사용하지 않고 빈 커밋 메시지로 커밋을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f6f49e5a6f1778648e9730643fd43474f2dbc13" translate="yes" xml:space="preserve">
          <source>Like --get-all, but interprets the name as a regular expression and writes out the key names. Regular expression matching is currently case-sensitive and done against a canonicalized version of the key in which section and variable names are lowercased, but subsection names are not.</source>
          <target state="translated">--get-all과 비슷하지만 이름을 정규식으로 해석하고 키 이름을 씁니다. 정규식 일치는 현재 대소 문자를 구분하며 섹션 및 변수 이름이 소문자로 된 하위 키 이름의 정규화 된 키에 대해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="f93e6625e77c19d6664d2e45faf25a33780dbe37" translate="yes" xml:space="preserve">
          <source>Like --import-marks but instead of erroring out, silently skips the file if it does not exist.</source>
          <target state="translated">--import-marks와 비슷하지만 오류가 아닌 파일이 없으면 자동으로 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="0eda32196b28e34b5200ae38915b28d72ba0802b" translate="yes" xml:space="preserve">
          <source>Like --import-marks except in two respects: first, only one &quot;feature import-marks&quot; or &quot;feature import-marks-if-exists&quot; command is allowed per stream; second, an --import-marks= or --import-marks-if-exists command-line option overrides any of these &quot;feature&quot; commands in the stream; third, &quot;feature import-marks-if-exists&quot; like a corresponding command-line option silently skips a nonexistent file.</source>
          <target state="translated">두 가지 측면을 제외하고 --import-marks와 유사합니다. 첫째, 스트림 당 하나의 &quot;feature import-marks&quot;또는 &quot;feature import-marks-if-exists&quot;명령 만 허용됩니다. 둘째, --import-marks = 또는 --import-marks-if-exists 명령 줄 옵션은 스트림에서 이러한 &quot;기능&quot;명령을 무시합니다. 셋째, 해당 명령 줄 옵션과 같은 &quot;기능 가져 오기 표시가있는 경우&quot;는 존재하지 않는 파일을 자동으로 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="ea166a12e166b75ad46458f975797a03647dc62d" translate="yes" xml:space="preserve">
          <source>Like --keep create a .keep file before moving the index into its final destination, but rather than creating an empty file place &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; followed by an LF into the .keep file. The &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; message can later be searched for within all .keep files to locate any which have outlived their usefulness.</source>
          <target state="translated">--keep과 같이 색인을 최종 대상으로 이동하기 전에 .keep 파일을 작성하십시오. 빈 파일 위치 &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; 를 작성하고 LF를 .keep 파일에 작성하지 마십시오. &lt;code&gt;&amp;lt;msg&amp;gt;&lt;/code&gt; 메시지는 나중에 모든 .keep 파일을 자신의 유용성을 지났다 한 어느 하나를 찾는 내에서 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da58772c0d323657b31dd0d6c68daa01b72022dc" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--cherry-pick&lt;/code&gt; (see below) but mark equivalent commits with &lt;code&gt;=&lt;/code&gt; rather than omitting them, and inequivalent ones with &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;--cherry-pick&lt;/code&gt; (아래 참조)하지만 동등한 커밋 표시 &lt;code&gt;=&lt;/code&gt; 보다는를 생략하고와 inequivalent 사람 &lt;code&gt;+&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="18b014ee75198b1ce501d5b1546fe06cd49ddd23" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--git-dir&lt;/code&gt;, but its output is always the canonicalized absolute path.</source>
          <target state="translated">마찬가지로 &lt;code&gt;--git-dir&lt;/code&gt; , 그러나 그것의 출력은 항상 정규화 절대 경로입니다.</target>
        </trans-unit>
        <trans-unit id="af1d4315bb510027eb7e61b588f2b477e26e55d4" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;--refresh&lt;/code&gt;, but checks stat information unconditionally, without regard to the &quot;assume unchanged&quot; setting.</source>
          <target state="translated">&lt;code&gt;--refresh&lt;/code&gt; 와 유사 하지만 &quot;변경되지 않은 것으로 가정&quot;설정과 상관없이 무조건 통계 정보를 검사합니다.</target>
        </trans-unit>
        <trans-unit id="649d7b810a2269259a3e3571033e0da598ccd04e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;-C&lt;/code&gt;, but with &lt;code&gt;-c&lt;/code&gt; the editor is invoked, so that the user can further edit the commit message.</source>
          <target state="translated">마찬가지로 &lt;code&gt;-C&lt;/code&gt; 는 하지만, 함께 &lt;code&gt;-c&lt;/code&gt; 편집기를 호출, 사용자는 더 편집이 커밋 메시지를 수 있도록있다.</target>
        </trans-unit>
        <trans-unit id="72f500fc1c4bd05ad014fbedf9cd9b9fb51f168b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;-C&lt;/code&gt;, but with &lt;code&gt;-c&lt;/code&gt; the editor is invoked, so that the user can further edit the note message.</source>
          <target state="translated">마찬가지로 &lt;code&gt;-C&lt;/code&gt; 만에 &lt;code&gt;-c&lt;/code&gt; 편집기를 호출하므로 사용자가 할 수있는 더 편집 노트 메시지가.</target>
        </trans-unit>
        <trans-unit id="f749f3d3ddfe6600b3752ee19e4bd9b6731f362f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;email&lt;/code&gt;, but lines in the commit message starting with &quot;From &quot; (preceded by zero or more &quot;&amp;gt;&quot;) are quoted with &quot;&amp;gt;&quot; so they aren&amp;rsquo;t confused as starting a new commit.</source>
          <target state="translated">마찬가지로 &lt;code&gt;email&lt;/code&gt; 그들은 새로운 커밋을 시작으로 혼동되지 않도록에, 그러나 선은 &quot;&amp;gt;&quot; &quot;에서&quot;(0 개 이상의 선행 &quot;&amp;gt;&quot;)으로 인용으로 시작하는 메시지를 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="5f2734a31de3aa99c55dc536f672e3afeacd6e67" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; this variable has corresponding &lt;code&gt;receive.fsck.skipList&lt;/code&gt; and &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; variants.</source>
          <target state="translated">마찬가지로 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 이 변수 대응있다 &lt;code&gt;receive.fsck.skipList&lt;/code&gt; 및 &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; 은 변종.</target>
        </trans-unit>
        <trans-unit id="8f4973bf138d30d1fbff518822c72869393d6ab3" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;git push&lt;/code&gt; or &lt;code&gt;git fetch&lt;/code&gt;, imports handled by fast-import are safe to run alongside parallel &lt;code&gt;git repack -a -d&lt;/code&gt; or &lt;code&gt;git gc&lt;/code&gt; invocations, or any other Git operation (including &lt;code&gt;git prune&lt;/code&gt;, as loose objects are never used by fast-import).</source>
          <target state="translated">마찬가지로 &lt;code&gt;git push&lt;/code&gt; 또는 &lt;code&gt;git fetch&lt;/code&gt; 빠른 가져 오기에 의해 처리 수입, 병렬 함께 실행하는 데 안전 &lt;code&gt;git repack -a -d&lt;/code&gt; 또는 &lt;code&gt;git gc&lt;/code&gt; 호출, 또는 포함한 다른 힘내 작업 ( &lt;code&gt;git prune&lt;/code&gt; , 느슨한 객체에 의해 사용되지 않습니다로 빠르게 가져 오기 ).</target>
        </trans-unit>
        <trans-unit id="c7a0caab42cb430b8f7eb62e2b9ee91196438e5f" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;git rebase&lt;/code&gt;; this requires that the working tree be clean and have no uncommitted changes.</source>
          <target state="translated">&lt;code&gt;git rebase&lt;/code&gt; 처럼 ; 작업 트리가 깨끗하고 커밋되지 않은 변경 사항이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="94b902a35ff412729993e3558dc74f40d9a138f0" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;mailmap.file&lt;/code&gt;, but consider the value as a reference to a blob in the repository. If both &lt;code&gt;mailmap.file&lt;/code&gt; and &lt;code&gt;mailmap.blob&lt;/code&gt; are given, both are parsed, with entries from &lt;code&gt;mailmap.file&lt;/code&gt; taking precedence. In a bare repository, this defaults to &lt;code&gt;HEAD:.mailmap&lt;/code&gt;. In a non-bare repository, it defaults to empty.</source>
          <target state="translated">&lt;code&gt;mailmap.file&lt;/code&gt; 과 비슷 하지만 값을 저장소의 blob에 대한 참조로 고려하십시오. 두 경우 &lt;code&gt;mailmap.file&lt;/code&gt; 및 &lt;code&gt;mailmap.blob&lt;/code&gt; 이 주어진다, 모두의 항목으로, 구문 분석 &lt;code&gt;mailmap.file&lt;/code&gt; 복용 우선 순위. Bare 저장소에서 기본값은 &lt;code&gt;HEAD:.mailmap&lt;/code&gt; 입니다. Bare 이외의 저장소에서는 기본적으로 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5b79d6b46ed0bad865e7c66642f5df5197bbc3e" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;pop&lt;/code&gt;, but do not remove the state from the stash list. Unlike &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; may be any commit that looks like a commit created by &lt;code&gt;stash push&lt;/code&gt; or &lt;code&gt;stash create&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;pop&lt;/code&gt; 하지만, 숨김 목록에서 상태를 제거하지 마십시오. 달리 &lt;code&gt;pop&lt;/code&gt; , &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; A를 만든 커밋 원하는 그 모습을 저지 할 수있다 &lt;code&gt;stash push&lt;/code&gt; 또는 &lt;code&gt;stash create&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b42cf6e877b403442b6c5e230e0a3121abfa79f2" translate="yes" xml:space="preserve">
          <source>Like get, but returns all values for a multi-valued key.</source>
          <target state="translated">get과 같지만 다중 값 키의 모든 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="73701f369b01fba26e9d0bb68ef652b62a8e8ce1" translate="yes" xml:space="preserve">
          <source>Like host.example:foo/repo, but use /home/foo/.ssh/somekey as keypair and user as user on remote side. This avoids needing to edit .ssh/config.</source>
          <target state="translated">host.example : foo / repo와 유사하지만 /home/foo/.ssh/somekey를 키 쌍으로, 사용자를 원격 측에서 사용자로 사용하십시오. 이렇게하면 .ssh / config를 편집 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6a22ef6226883a7823ee7468ab3e5221cd1b0fcc" translate="yes" xml:space="preserve">
          <source>Like many programs that switch user id, the daemon does not reset environment variables such as &lt;code&gt;$HOME&lt;/code&gt; when it runs git programs, e.g. &lt;code&gt;upload-pack&lt;/code&gt; and &lt;code&gt;receive-pack&lt;/code&gt;. When using this option, you may also want to set and export &lt;code&gt;HOME&lt;/code&gt; to point at the home directory of &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; before starting the daemon, and make sure any Git configuration files in that directory are readable by &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">사용자 ID를 전환하는 많은 프로그램과 마찬가지로 데몬은 git 프로그램을 실행할 때 &lt;code&gt;$HOME&lt;/code&gt; 과 같은 환경 변수를 재설정하지 않습니다 ( 예 : &lt;code&gt;upload-pack&lt;/code&gt; 및 &lt;code&gt;receive-pack&lt;/code&gt; ) . 이 옵션을 사용하는 경우, 당신은 또한 세트 내보낼 수 있습니다 &lt;code&gt;HOME&lt;/code&gt; 의 홈 디렉토리에서 점에 &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; 데몬을 시작하기 전에, 있는지 그 디렉토리에있는 망할 놈의 구성 파일을 읽을 수 있습니다 있도록 &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="955d6409ae367c03bad138119c6bf959eda46b3c" translate="yes" xml:space="preserve">
          <source>Likewise, when the &lt;code&gt;LV&lt;/code&gt; environment variable is unset, Git sets it to &lt;code&gt;-c&lt;/code&gt;. You can override this setting by exporting &lt;code&gt;LV&lt;/code&gt; with another value or setting &lt;code&gt;core.pager&lt;/code&gt; to &lt;code&gt;lv +c&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;LV&lt;/code&gt; 환경 변수가 설정되어 있지 않으면 Git은 &lt;code&gt;-c&lt;/code&gt; 로 설정합니다 . &lt;code&gt;LV&lt;/code&gt; 를 다른 값 으로 내보내 거나 &lt;code&gt;core.pager&lt;/code&gt; 를 &lt;code&gt;lv +c&lt;/code&gt; 설정 하여이 설정을 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da647d41a556bd9f858a9fb821a95fe4fa6d0849" translate="yes" xml:space="preserve">
          <source>Limit commits to the ones touching files in the given paths. Note, to avoid ambiguity with respect to revision names use &quot;--&quot; to separate the paths from any preceding options.</source>
          <target state="translated">주어진 경로에서 파일을 터치하는 커밋을 제한합니다. 개정판 이름과 관련하여 모호성을 피하려면 &quot;-&quot;를 사용하여 이전 옵션과 경로를 구분하십시오.</target>
        </trans-unit>
        <trans-unit id="a8f6287e3aa57458fad3449d202e28c228d6d460" translate="yes" xml:space="preserve">
          <source>Limit diff output to named subtrees.</source>
          <target state="translated">diff 출력을 명명 된 하위 트리로 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="73ea1d1481ae126a39e8d8a25424a40b0120067c" translate="yes" xml:space="preserve">
          <source>Limit fetching to ancestor-chains not longer than n. &lt;code&gt;git-upload-pack&lt;/code&gt; treats the special depth 2147483647 as infinite even if there is an ancestor-chain that long.</source>
          <target state="translated">가져 오기를 n 이하의 조상 체인으로 제한하십시오. &lt;code&gt;git-upload-pack&lt;/code&gt; 은 조상 체인이 길더라도 특수 깊이 2147483647을 무한대로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="3548328e70b776f579a206b5e26f3a2cdd3bf54c" translate="yes" xml:space="preserve">
          <source>Limit fetching to the specified number of commits from the tip of each remote branch history. If fetching to a &lt;code&gt;shallow&lt;/code&gt; repository created by &lt;code&gt;git clone&lt;/code&gt; with &lt;code&gt;--depth=&amp;lt;depth&amp;gt;&lt;/code&gt; option (see &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;), deepen or shorten the history to the specified number of commits. Tags for the deepened commits are not fetched.</source>
          <target state="translated">각 원격 브랜치 히스토리의 끝에서 지정된 커밋 수로 페치를 제한합니다. &lt;code&gt;--depth=&amp;lt;depth&amp;gt;&lt;/code&gt; 옵션 ( &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 참조)을 사용 하여 &lt;code&gt;git clone&lt;/code&gt; 으로 작성된 &lt;code&gt;shallow&lt;/code&gt; 저장소로 페치하는 경우 , 지정된 커밋 수만큼 히스토리를 깊게하거나 줄이십시오. 강화 된 커밋에 대한 태그는 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="406e704b5fa6637d1092aef900d6bea100f59424" translate="yes" xml:space="preserve">
          <source>Limit output to the one commit object which is roughly halfway between included and excluded commits. Note that the bad bisection ref &lt;code&gt;refs/bisect/bad&lt;/code&gt; is added to the included commits (if it exists) and the good bisection refs &lt;code&gt;refs/bisect/good-*&lt;/code&gt; are added to the excluded commits (if they exist). Thus, supposing there are no refs in &lt;code&gt;refs/bisect/&lt;/code&gt;, if</source>
          <target state="translated">포함 된 커밋과 제외 된 커밋 사이의 중간 정도 인 하나의 커밋 객체로 출력을 제한합니다. 불량 biref &lt;code&gt;refs/bisect/bad&lt;/code&gt; 가 포함 된 커밋에 추가되고 (존재하는 경우) good bisection refs &lt;code&gt;refs/bisect/good-*&lt;/code&gt; 가 제외 된 커밋에 추가됩니다 (존재하는 경우). 따라서 &lt;code&gt;refs/bisect/&lt;/code&gt; 에 참조가 없다고 가정 하면</target>
        </trans-unit>
        <trans-unit id="2b149769f0e9e62c7755e40f7d9c9b100ff198f3" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones that match all given &lt;code&gt;--grep&lt;/code&gt;, instead of ones that match at least one.</source>
          <target state="translated">커밋 출력을 하나 이상의 일치하는 것이 아니라 지정된 모든 &lt;code&gt;--grep&lt;/code&gt; 와 일치하는 것으로 제한하십시오 .</target>
        </trans-unit>
        <trans-unit id="119c553a83e823fd710ae4f2da2e455c4cb090b7" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with author/committer header lines that match the specified pattern (regular expression). With more than one &lt;code&gt;--author=&amp;lt;pattern&amp;gt;&lt;/code&gt;, commits whose author matches any of the given patterns are chosen (similarly for multiple &lt;code&gt;--committer=&amp;lt;pattern&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">커밋 출력을 지정된 패턴 (정규 표현식)과 일치하는 작성자 / 커미터 헤더 행이있는 커밋으로 제한합니다. 이상 하나 &lt;code&gt;--author=&amp;lt;pattern&amp;gt;&lt;/code&gt; , 그 저자 커밋은 주어진 패턴 중 일치 선택된다 (마찬가지로 여러 대 &lt;code&gt;--committer=&amp;lt;pattern&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dd1c85bc38b39ba5aff2bee57d4deea0c60fd712" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with log message that do not match the pattern specified with &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">커밋 출력을 &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; 에 지정된 패턴과 일치하지 않는 로그 메시지가있는 것으로 제한합니다 .</target>
        </trans-unit>
        <trans-unit id="bd9eadb3ad8dfb9ffb371dc1589fe6576ab540f4" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with log message that matches the specified pattern (regular expression). With more than one &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt;, commits whose message matches any of the given patterns are chosen (but see &lt;code&gt;--all-match&lt;/code&gt;).</source>
          <target state="translated">커밋 출력을 지정된 패턴 (정규 표현식)과 일치하는 로그 메시지가있는 것으로 제한합니다. 둘 이상의 &lt;code&gt;--grep=&amp;lt;pattern&amp;gt;&lt;/code&gt; 을 사용하면 지정된 패턴과 일치하는 메시지가 선택된 커밋이 선택됩니다 (그러나 &lt;code&gt;--all-match&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d1b86714045e4612b85a2fa8cf22123bd3513cb6" translate="yes" xml:space="preserve">
          <source>Limit the commits output to ones with reflog entries that match the specified pattern (regular expression). With more than one &lt;code&gt;--grep-reflog&lt;/code&gt;, commits whose reflog message matches any of the given patterns are chosen. It is an error to use this option unless &lt;code&gt;--walk-reflogs&lt;/code&gt; is in use.</source>
          <target state="translated">커밋 출력을 지정된 패턴 (정규 표현식)과 일치하는 reflog 항목이있는 출력으로 제한합니다. 하나 이상의 &lt;code&gt;--grep-reflog&lt;/code&gt; 를 사용하면 지정된 패턴과 일치하는 reflog 메시지를 가진 커밋이 선택됩니다. &lt;code&gt;--walk-reflogs&lt;/code&gt; 를 사용하지 않으면이 옵션을 사용하는 것은 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="2b5d877818bdb0956a66e366504390cf3fe65b29" translate="yes" xml:space="preserve">
          <source>Limit the commits output to specified time range.</source>
          <target state="translated">커밋 출력을 지정된 시간 범위로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="d8dbf5f629bd3296e9ab1177de95e69729e1d54b" translate="yes" xml:space="preserve">
          <source>Limit the displayed commits to those directly on the ancestry chain between the &amp;ldquo;from&amp;rdquo; and &amp;ldquo;to&amp;rdquo; commits in the given commit range. I.e. only display commits that are ancestor of the &amp;ldquo;to&amp;rdquo; commit and descendants of the &amp;ldquo;from&amp;rdquo; commit.</source>
          <target state="translated">표시된 커밋은 주어진 커밋 범위에서 &quot;시작&quot;과 &quot;끝&quot;커밋 사이의 상위 체인에있는 커밋으로 제한합니다. 즉, &quot;to&quot;커밋의 조상이자 &quot;from&quot;커밋의 자손 인 커밋 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ed8c2d4ed1408e7d7da83719bcf77ad7b5896ff9" translate="yes" xml:space="preserve">
          <source>Limit the number of commits imported. Workaround for cases where cvsimport leaks memory.</source>
          <target state="translated">가져온 커밋 수를 제한하십시오. cvsimport가 메모리를 누출하는 경우의 해결 방법.</target>
        </trans-unit>
        <trans-unit id="1adada65b7a03da88bf0748c36055d961c64b07a" translate="yes" xml:space="preserve">
          <source>Limit the number of commits to output.</source>
          <target state="translated">출력 커밋 수를 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="38e02fe4379a543b3e47180cba4d6468bec3e601" translate="yes" xml:space="preserve">
          <source>Limit the revisions to show. This can be either a single revision meaning show from the given revision and back, or it can be a range in the form &quot;&lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt;..&lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt;&quot; to show all revisions between &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; and back to &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt;. Note, more advanced revision selection can be applied. For a more complete list of ways to spell object names, see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">표시 할 수정을 제한하십시오. 이것은 다시 주어진 수요일 수정에서 단일 수요일 수정 의미 표시가 될 수 있거나,이 형태의 범위 일 수있다 &quot; &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; .. &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; &quot;사이의 모든 수정 보여 &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; 위로 및 &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; . 보다 고급 버전 선택을 적용 할 수 있습니다. 객체 이름을 철자하는 방법에 대한 전체 목록은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="674ff0df4160db3404d979762630ae612e98f156" translate="yes" xml:space="preserve">
          <source>Limit the width of the graph part in --stat output. If set, applies to all commands generating --stat output except format-patch.</source>
          <target state="translated">--stat 출력에서 ​​그래프 부분의 너비를 제한하십시오. 설정하면 format-patch를 제외한 --stat 출력을 생성하는 모든 명령에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="29e45322508b52ceb051971d532eab460b3dc7d7" translate="yes" xml:space="preserve">
          <source>Limit to &quot;refs/heads&quot; and &quot;refs/tags&quot;, respectively. These options are not mutually exclusive; when given both, references stored in &quot;refs/heads&quot; and &quot;refs/tags&quot; are displayed.</source>
          <target state="translated">&quot;refs / heads&quot;및 &quot;refs / tags&quot;로 각각 제한합니다. 이러한 옵션은 상호 배타적이지 않습니다. 둘 다 지정하면 &quot;refs / heads&quot;및 &quot;refs / tags&quot;에 저장된 참조가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="66b9fb961da3804ca95085a20ace37a86529e6f7" translate="yes" xml:space="preserve">
          <source>Limit to only refs/heads and refs/tags, respectively. These options are &lt;code&gt;not&lt;/code&gt; mutually exclusive; when given both, references stored in refs/heads and refs/tags are displayed.</source>
          <target state="translated">심판 / 헤드 및 심판 / 태그로 각각 제한합니다. 이러한 옵션은 상호 배타적이지 &lt;code&gt;not&lt;/code&gt; . 둘 다 주어지면 참조 / 헤드 및 참조 / 태그에 저장된 참조가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cce06ee642a7b80587fe58f4572571b699424f46" translate="yes" xml:space="preserve">
          <source>Limit to only refs/heads and refs/tags, respectively. These options are &lt;code&gt;not&lt;/code&gt; mutually exclusive; when given both, references stored in refs/heads and refs/tags are displayed. Note that &lt;code&gt;git ls-remote -h&lt;/code&gt; used without anything else on the command line gives help, consistent with other git subcommands.</source>
          <target state="translated">각각 refs / heads 및 refs / tags로 제한됩니다. 이러한 옵션은 상호 배타적이지 &lt;code&gt;not&lt;/code&gt; . 둘 다 주어지면 참조 / 헤드 및 참조 / 태그에 저장된 참조가 표시됩니다. 참고 &lt;code&gt;git ls-remote -h&lt;/code&gt; 명령 행에서 아무것도없이 사용이 다른 자식 하위 명령과 일치 도움을 준다.</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="e8bb22d887f5d59400be2b36a39e61d714bda7bc" translate="yes" xml:space="preserve">
          <source>Limiting the diff output</source>
          <target state="translated">diff 출력 제한</target>
        </trans-unit>
        <trans-unit id="b7748eb338af2086cdad1f6af364c3481df64676" translate="yes" xml:space="preserve">
          <source>Limits the number of commits to show to 3.</source>
          <target state="translated">표시 할 커밋 수를 3으로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="efd756293dbb86969a7022bf4157b3145d6076f3" translate="yes" xml:space="preserve">
          <source>Limits the paths affected by the operation.</source>
          <target state="translated">작업의 영향을받는 경로를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="8375cb461aa1ace8d2ffdda18edb87b333f2f4d1" translate="yes" xml:space="preserve">
          <source>Line numbers count from 1.</source>
          <target state="translated">줄 번호는 1부터 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="3d9326a0fc6538daba3b0f3096cf5c416812b52b" translate="yes" xml:space="preserve">
          <source>Lines starting with a hash (&quot;&lt;code&gt;#&lt;/code&gt;&quot;) are ignored, so they can be used for comments. Add a backslash (&quot;&lt;code&gt;\&lt;/code&gt;&quot;) to the beginning of the pattern if it starts with a hash.</source>
          <target state="translated">해시 ( &quot; &lt;code&gt;#&lt;/code&gt; &quot;)로 시작하는 줄 은 무시되므로 주석에 사용할 수 있습니다. 패턴이 해시로 시작하는 경우 백 슬래시 ( &quot; &lt;code&gt;\&lt;/code&gt; &quot;)를 패턴의 시작 부분에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8e28fd820953d60830c4b1106307e2e0b6872452" translate="yes" xml:space="preserve">
          <source>Linewrap the output by wrapping each line at &lt;code&gt;width&lt;/code&gt;. The first line of each entry is indented by &lt;code&gt;indent1&lt;/code&gt; spaces, and the second and subsequent lines are indented by &lt;code&gt;indent2&lt;/code&gt; spaces. &lt;code&gt;width&lt;/code&gt;, &lt;code&gt;indent1&lt;/code&gt;, and &lt;code&gt;indent2&lt;/code&gt; default to 76, 6 and 9 respectively.</source>
          <target state="translated">각 줄을 &lt;code&gt;width&lt;/code&gt; 로 감싸서 출력을 줄 바꿈하십시오 . 각 항목의 첫 번째 줄은 &lt;code&gt;indent1&lt;/code&gt; 공백으로 들여 쓰기되고 두 번째 및 후속 줄은 &lt;code&gt;indent2&lt;/code&gt; 공백 만큼 들여 쓰기됩니다 . &lt;code&gt;width&lt;/code&gt; , &lt;code&gt;indent1&lt;/code&gt; 및 &lt;code&gt;indent2&lt;/code&gt; 의 기본값은 각각 76, 6 및 9입니다.</target>
        </trans-unit>
        <trans-unit id="1d1f6a47e210ac264339f2e30472d9fdf4025a54" translate="yes" xml:space="preserve">
          <source>Links and their targets</source>
          <target state="translated">링크와 목표</target>
        </trans-unit>
        <trans-unit id="7177342122325630102d4a83723d13417535ac19" translate="yes" xml:space="preserve">
          <source>Linus Torvalds originally designed Git to be a user space file system, i.e. the infrastructure to hold files and directories. That ensured the efficiency and speed of Git.</source>
          <target state="translated">Linus Torvalds는 원래 Git을 사용자 공간 파일 시스템, 즉 파일과 디렉토리를 보유하는 인프라로 설계했습니다. 이는 Git의 효율성과 속도를 보장했습니다.</target>
        </trans-unit>
        <trans-unit id="9f9879c2ed0b6b8dfd5d9b1ecb4faa0c5584d26d" translate="yes" xml:space="preserve">
          <source>Linus Torvalds, for example, makes new kernel releases by tagging them, then running:</source>
          <target state="translated">예를 들어, Linus Torvalds는 새로운 커널 릴리스를 태깅 한 다음 실행하여 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c215fd74e10e91e4728dc7ef559cf830d21a3457" translate="yes" xml:space="preserve">
          <source>Linus&amp;rsquo;s tree will be stored in the remote-tracking branch named origin/master, and can be updated using &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;; you can track other public trees using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt; to set up a &quot;remote&quot; and &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; to keep them up to date; see &lt;a href=&quot;#repositories-and-branches&quot;&gt;Repositories and Branches&lt;/a&gt;.</source>
          <target state="translated">Linus의 트리는 origin / master라는 원격 추적 브랜치에 저장되며 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; ; &lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; 을 사용하여 &quot;remote&quot;를 설정하고 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 을 사용하여 다른 공용 트리를 추적 하여 최신 상태로 유지할 수 있습니다. &lt;a href=&quot;#repositories-and-branches&quot;&gt;리포지토리 및 분기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a79bad3bb798b3bdc01c2a7bbb2df04a2b261bb" translate="yes" xml:space="preserve">
          <source>List (array reference) of feature parameters (if there are any), used also to toggle (enable or disable) given feature.</source>
          <target state="translated">기능 매개 변수 (있는 경우)의 목록 (배열 참조). 또한 주어진 기능을 토글 (활성화 또는 비활성화)하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7ee03188f58cdb7509c4f88e1a300f564da6d9fa" translate="yes" xml:space="preserve">
          <source>List all attributes that are associated with the specified paths. If this option is used, then &lt;code&gt;unspecified&lt;/code&gt; attributes will not be included in the output.</source>
          <target state="translated">지정된 경로와 연관된 모든 속성을 나열하십시오. 이 옵션을 사용하면 &lt;code&gt;unspecified&lt;/code&gt; 속성이 출력에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="250839942391006b259bdb87bdef885727a6f6a9" translate="yes" xml:space="preserve">
          <source>List all available configuration variables. This is a short summary of the list in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 모든 구성 변수를 나열하십시오. 이것은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 목록에 대한 간단한 요약입니다 .</target>
        </trans-unit>
        <trans-unit id="12ac07106316dd6381b9d3b75b7cd7d028c9fa93" translate="yes" xml:space="preserve">
          <source>List all commits reachable from all refs</source>
          <target state="translated">모든 심판에서 도달 할 수있는 모든 커밋을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="dca598d76b2fd502e68ee09810f65324e1da32ae" translate="yes" xml:space="preserve">
          <source>List all tags (lightweight and annotated) in given repository.</source>
          <target state="translated">주어진 저장소에있는 모든 태그 (경량 및 주석이있는)를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="df1447e22cac81b01f2aee49d9517212423de9a9" translate="yes" xml:space="preserve">
          <source>List all variables set in config file, along with their values.</source>
          <target state="translated">구성 파일에 설정된 모든 변수와 해당 값을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="aa1b92c795a51cb41c1ee54087151d51eda95116" translate="yes" xml:space="preserve">
          <source>List both remote-tracking branches and local branches. Combine with &lt;code&gt;--list&lt;/code&gt; to match optional pattern(s).</source>
          <target state="translated">원격 추적 지점과 로컬 지점을 모두 나열하십시오. 선택적 패턴을 일치 시키려면 &lt;code&gt;--list&lt;/code&gt; 와 결합하십시오 .</target>
        </trans-unit>
        <trans-unit id="670ea777adabe92ea2a21ddec9e8062878d9ce68" translate="yes" xml:space="preserve">
          <source>List branches. With optional &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt;, e.g. &lt;code&gt;git
branch --list 'maint-*'&lt;/code&gt;, list only the branches that match the pattern(s).</source>
          <target state="translated">지점을 나열하십시오. 선택적 &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt; 을 사용 하여 (예 : &lt;code&gt;git branch --list 'maint-*'&lt;/code&gt; ) 패턴과 일치하는 분기 만 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="ecd6ee4f3b1cdf8c4e62426b401b6921926e6641" translate="yes" xml:space="preserve">
          <source>List commands by group. This is an internal/experimental option and may change or be removed in the future. Supported groups are: builtins, parseopt (builtin commands that use parse-options), main (all commands in libexec directory), others (all other commands in &lt;code&gt;$PATH&lt;/code&gt; that have git- prefix), list-&amp;lt;category&amp;gt; (see categories in command-list.txt), nohelpers (exclude helper commands), alias and config (retrieve command list from config variable completion.commands)</source>
          <target state="translated">그룹별로 명령을 나열하십시오. 이는 내부 / 실험 옵션이며 향후 변경되거나 제거 될 수 있습니다. 지원되는 그룹은 내장, parseopt (구문 분석 옵션을 사용하는 내장 명령), main (libexec 디렉토리의 모든 명령), 기타 ( git 접두어가 있는 &lt;code&gt;$PATH&lt;/code&gt; 다른 모든 명령 ), list- &amp;lt;category&amp;gt; (카테고리의 범주 참조)입니다. command-list.txt), nohelpers (헬퍼 명령 제외), 별명 및 config (구성 변수 완성에서 명령 목록 검색)</target>
        </trans-unit>
        <trans-unit id="238ed7681a7fd585fe1d585aba4d3e4521202ffa" translate="yes" xml:space="preserve">
          <source>List commits that are reachable by following the &lt;code&gt;parent&lt;/code&gt; links from the given commit(s), but exclude commits that are reachable from the one(s) given with a &lt;code&gt;^&lt;/code&gt; in front of them. The output is given in reverse chronological order by default.</source>
          <target state="translated">주어진 커밋에서 &lt;code&gt;parent&lt;/code&gt; 링크를 따라 도달 할 수있는 커밋을 나열 하지만 앞에 &lt;code&gt;^&lt;/code&gt; 가 있는 커밋은 제외 합니다. 출력은 기본적으로 역순으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4360f3a3310a6afc913d6c5b075b5763b91121d3" translate="yes" xml:space="preserve">
          <source>List details of each working tree. The main working tree is listed first, followed by each of the linked working trees. The output details include whether the working tree is bare, the revision currently checked out, and the branch currently checked out (or &quot;detached HEAD&quot; if none).</source>
          <target state="translated">각 작업 트리의 세부 사항을 나열하십시오. 기본 작업 트리가 먼저 나열되고 그 뒤에 연결된 각 작업 트리가 나열됩니다. 출력 세부 사항에는 작업 트리가 베어 있는지 여부, 현재 체크 아웃 된 개정 및 현재 체크 아웃 된 분기 (또는없는 경우 &quot;분리 된 HEAD&quot;)가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f8cd82f860b84646c498bf5c68b11bdf176a80b7" translate="yes" xml:space="preserve">
          <source>List details of each working tree. The main working tree is listed first, followed by each of the linked working trees. The output details include whether the working tree is bare, the revision currently checked out, the branch currently checked out (or &quot;detached HEAD&quot; if none), and &quot;locked&quot; if the worktree is locked.</source>
          <target state="translated">각 작업 트리의 세부 사항을 나열하십시오. 기본 작업 트리가 먼저 나열되고 그 뒤에 연결된 각 작업 트리가 나열됩니다. 출력 세부 사항에는 작업 트리가 베어 있는지 여부, 현재 체크 아웃 된 개정, 현재 체크 아웃 된 분기 (또는없는 경우 &quot;분리 된 HEAD&quot;) 및 작업 트리가 잠겨있는 경우 &quot;잠김&quot;이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="adfacb775267bd93896cdbdf525c103ac26c16d4" translate="yes" xml:space="preserve">
          <source>List details of each worktree. The main worktree is listed first, followed by each of the linked worktrees. The output details include if the worktree is bare, the revision currently checked out, and the branch currently checked out (or &lt;code&gt;detached HEAD&lt;/code&gt; if none).</source>
          <target state="translated">각 작업 트리의 세부 사항을 나열하십시오. 기본 작업 트리가 먼저 나열된 다음 연결된 각 작업 트리가 나열됩니다. 출력 세부 사항에는 작업 트리가없는 경우, 현재 체크 아웃 한 개정 및 현재 체크 아웃 된 분기 (또는 없는 경우 &lt;code&gt;detached HEAD&lt;/code&gt; )가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1481dab663abae987b5437270fc0152b6258984f" translate="yes" xml:space="preserve">
          <source>List of Git base URLs. These URLs are used to generate URLs describing from where to fetch a project, which are shown on project summary page. The full fetch URL is &quot;&lt;code&gt;$git_base_url/$project&lt;/code&gt;&quot;, for each element of this list. You can set up multiple base URLs (for example one for &lt;code&gt;git://&lt;/code&gt; protocol, and one for &lt;code&gt;http://&lt;/code&gt; protocol).</source>
          <target state="translated">Git 기본 URL 목록. 이 URL은 프로젝트 요약 페이지에 표시되는 프로젝트를 가져올 위치를 설명하는 URL을 생성하는 데 사용됩니다. 전체 가져 오기 URL 은이 목록의 각 요소에 대해 &quot; &lt;code&gt;$git_base_url/$project&lt;/code&gt; &quot;입니다. 여러 개의 기본 URL을 설정할 수 있습니다 (예 &lt;code&gt;git://&lt;/code&gt; 프로토콜 용 URL 및 &lt;code&gt;http://&lt;/code&gt; 프로토콜 용 URL ).</target>
        </trans-unit>
        <trans-unit id="e9453e698a4a15232ec2c038afd4c298aede850c" translate="yes" xml:space="preserve">
          <source>List of URIs of stylesheets (relative to the base URI of a page). You might specify more than one stylesheet, for example to use &quot;gitweb.css&quot; as base with site specific modifications in a separate stylesheet to make it easier to upgrade gitweb. For example, you can add a &lt;code&gt;site&lt;/code&gt; stylesheet by putting</source>
          <target state="translated">스타일 시트의 URI 목록 (페이지의 기본 URI에 상대적). 예를 들어 gitweb을 쉽게 업그레이드 할 수 있도록 별도의 스타일 시트에서 사이트 특정 수정 사항이있는 &quot;gitweb.css&quot;를 기본으로 사용하도록 둘 이상의 스타일 시트를 지정할 수 있습니다. 예를 들어 &lt;code&gt;site&lt;/code&gt; 스타일 시트를 추가하여</target>
        </trans-unit>
        <trans-unit id="d9ab3387c39e123d7aac2edb253dcdba7080f753" translate="yes" xml:space="preserve">
          <source>List of additional directories under &quot;refs&quot; which are going to be used as branch refs. For example if you have a gerrit setup where all branches under refs/heads/ are official, push-after-review ones and branches under refs/sandbox/, refs/wip and refs/other are user ones where permissions are much wider, then you might want to set this variable as follows:</source>
          <target state="translated">분기 참조로 사용될 &quot;refs&quot;아래의 추가 디렉토리 목록 예를 들어 refs / heads / 아래의 모든 브랜치가 공식적인 gerrit 설정을 사용하는 경우 refs / sandbox /, refs / wip 및 refs / other 아래의 브랜치가 검토 후 푸시 및 refs / other는 권한이 훨씬 넓은 사용자입니다. 이 변수를 다음과 같이 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c919f43c88ec5761218ece7f29ac150fc5c1298f" translate="yes" xml:space="preserve">
          <source>List of branches to be imported when branch detection is enabled. Each entry should be a pair of branch names separated by a colon (:). This example declares that both branchA and branchB were created from main:</source>
          <target state="translated">분기 감지가 활성화 될 때 가져올 분기 목록입니다. 각 항목은 콜론 (:)으로 구분 된 분기 이름 쌍이어야합니다. 이 예제는 branchA와 branchB가 모두 main에서 생성되었음을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="3d6057539fc43b4e5580b21aa940b705e61341be" translate="yes" xml:space="preserve">
          <source>List of p4 labels to ignore. This is built automatically as unimportable labels are discovered.</source>
          <target state="translated">무시할 p4 레이블 목록입니다. 가져올 수없는 레이블이 발견되면 자동으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="ed979d0137e2b09484f09056901ac3efce874117" translate="yes" xml:space="preserve">
          <source>List only commits on the respective side of a symmetric difference, i.e. only those which would be marked &lt;code&gt;&amp;lt;&lt;/code&gt; resp. &lt;code&gt;&amp;gt;&lt;/code&gt; by &lt;code&gt;--left-right&lt;/code&gt;.</source>
          <target state="translated">List는 대칭 적 차이의 각면, 즉 &lt;code&gt;&amp;lt;&lt;/code&gt; resp 로 표시된 것만 커밋 합니다. &lt;code&gt;&amp;gt;&lt;/code&gt; by &lt;code&gt;--left-right&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db38d2130aa4774e0a5e01e813cbe87b286b5c58" translate="yes" xml:space="preserve">
          <source>List only filenames (instead of the &quot;long&quot; output), one per line.</source>
          <target state="translated">한 줄에 하나씩 &quot;긴&quot;출력 대신 파일 이름 만 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="ca0ba00456e1892ce61ce3c77aa65cb5194d4e6c" translate="yes" xml:space="preserve">
          <source>List or delete (if used with -d) the remote-tracking branches. Combine with &lt;code&gt;--list&lt;/code&gt; to match the optional pattern(s).</source>
          <target state="translated">원격 추적 분기를 나열하거나 삭제합니다 (-d와 함께 사용하는 경우). &lt;code&gt;--list&lt;/code&gt; 와 결합 하여 선택적 패턴을 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="22eb51b821276ed4742fd46da8d914f3eb506ca1" translate="yes" xml:space="preserve">
          <source>List output format</source>
          <target state="translated">리스트 출력 형식</target>
        </trans-unit>
        <trans-unit id="961866b18d2006e9e2f1c57af615530c0dcb0176" translate="yes" xml:space="preserve">
          <source>List references in a local repository</source>
          <target state="translated">로컬 저장소의 참조 목록</target>
        </trans-unit>
        <trans-unit id="7a309b311eeb5429dbbc4c270383e0c9240ea7dd" translate="yes" xml:space="preserve">
          <source>List references in a remote repository</source>
          <target state="translated">원격 저장소에서 참조 목록</target>
        </trans-unit>
        <trans-unit id="c3c4b04779710ca49a121ec3b626bb207fe0cc86" translate="yes" xml:space="preserve">
          <source>List replace refs for objects that match the given pattern (or all if no pattern is given). Typing &quot;git replace&quot; without arguments, also lists all replace refs.</source>
          <target state="translated">주어진 패턴과 일치하는 (또는 패턴이없는 경우 모두) 객체의 대체 참조를 나열합니다. 인수없이 &quot;git replace&quot;를 입력하면 모든 교체 참조가 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="dd864736379915e26071e39557a37c9a699c5cd9" translate="yes" xml:space="preserve">
          <source>List some tags in a table with unequal column widths:</source>
          <target state="translated">열 너비가 다른 테이블에 일부 태그를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="c3a7e0023c585da8fc00add926f4e7fe3e4bed2d" translate="yes" xml:space="preserve">
          <source>List tags. With optional &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt;, e.g. &lt;code&gt;git tag --list
'v-*'&lt;/code&gt;, list only the tags that match the pattern(s).</source>
          <target state="translated">태그를 나열하십시오. 선택적 &lt;code&gt;&amp;lt;pattern&amp;gt;...&lt;/code&gt; (예 : &lt;code&gt;git tag --list 'v-*'&lt;/code&gt; )을 사용하면 패턴과 일치하는 태그 만 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="42f93b25d56793afc3463e924a37b81b3e45f73d" translate="yes" xml:space="preserve">
          <source>List the GIT_* environment variables that are local to the repository (e.g. GIT_DIR or GIT_WORK_TREE, but not GIT_EDITOR). Only the names of the variables are listed, not their value, even if they are set.</source>
          <target state="translated">저장소에 로컬 인 GIT_ * 환경 변수를 나열하십시오 (예 : GIT_DIR 또는 GIT_WORK_TREE이지만 GIT_EDITOR는 아님). 변수 이름이 설정되어 있어도 값이 아닌 변수 이름 만 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="dc410162c15e0c2fc959648b2d515436ff66231c" translate="yes" xml:space="preserve">
          <source>List the contents of a tree object</source>
          <target state="translated">트리 객체의 내용을 나열합니다</target>
        </trans-unit>
        <trans-unit id="c77a61ab930b102983b7633429f2e1c89c8a648a" translate="yes" xml:space="preserve">
          <source>List the notes object for a given object. If no object is given, show a list of all note objects and the objects they annotate (in the format &quot;&amp;lt;note object&amp;gt; &amp;lt;annotated object&amp;gt;&quot;). This is the default subcommand if no subcommand is given.</source>
          <target state="translated">주어진 객체에 대한 노트 객체를 나열합니다. 개체가 제공되지 않으면 모든 메모 개체와 메모를 추가 한 개체의 목록을 표시하십시오 ( &quot;&amp;lt;note object&amp;gt; &amp;lt;annotated object&amp;gt;&quot;형식). 부속 명령이없는 경우 이것이 디폴트 부속 명령입니다.</target>
        </trans-unit>
        <trans-unit id="160440cac4234691b237108179766c8ac388a3dd" translate="yes" xml:space="preserve">
          <source>List the stash entries that you currently have. Each &lt;code&gt;stash entry&lt;/code&gt; is listed with its name (e.g. &lt;code&gt;stash@{0}&lt;/code&gt; is the latest entry, &lt;code&gt;stash@{1}&lt;/code&gt; is the one before, etc.), the name of the branch that was current when the entry was made, and a short description of the commit the entry was based on.</source>
          <target state="translated">현재 가지고있는 숨김 항목을 나열하십시오. 각 &lt;code&gt;stash entry&lt;/code&gt; 은 이름으로 나열됩니다 (예 : &lt;code&gt;stash@{0}&lt;/code&gt; 은 최신 항목, &lt;code&gt;stash@{1}&lt;/code&gt; 은 이전 항목 등), 항목을 만들 때 현재 사용한 지점의 이름 및 항목이 기반으로 한 커밋에 대한 간단한 설명.</target>
        </trans-unit>
        <trans-unit id="0928a18c981cee8dd1bbd962ad11b79b09b49f73" translate="yes" xml:space="preserve">
          <source>List, create, or delete branches</source>
          <target state="translated">분기 나열, 생성 또는 삭제</target>
        </trans-unit>
        <trans-unit id="7d888e358c6ef40ec2a0a8a674979b45cd6d1cf4" translate="yes" xml:space="preserve">
          <source>Listed below are options that control the formatting of diff output. Some of them are specific to &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;, however other diff options may be given. See &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt; for more options.</source>
          <target state="translated">아래는 diff 출력의 형식을 제어하는 ​​옵션입니다. 그중 일부는 &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt; 에만 적용 되지만 다른 diff 옵션이 제공 될 수 있습니다. 더 많은 옵션 은 &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3248fa00aea630b8bbaf0b4709f9f26882639bdc" translate="yes" xml:space="preserve">
          <source>Listen on a specific IP address or hostname. IP addresses can be either an IPv4 address or an IPv6 address if supported. If IPv6 is not supported, then --listen=hostname is also not supported and --listen must be given an IPv4 address. Can be given more than once. Incompatible with &lt;code&gt;--inetd&lt;/code&gt; option.</source>
          <target state="translated">특정 IP 주소 또는 호스트 이름을 듣습니다. 지원되는 경우 IP 주소는 IPv4 주소 또는 IPv6 주소 일 수 있습니다. IPv6이 지원되지 않으면 --listen = hostname도 지원되지 않으며 --listen에 IPv4 주소가 제공되어야합니다. 두 번 이상 제공 될 수 있습니다. &lt;code&gt;--inetd&lt;/code&gt; 옵션 과 호환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4f53ff7586b49256325ec58801bfe143f18e21e3" translate="yes" xml:space="preserve">
          <source>Listen on an alternative port. Incompatible with &lt;code&gt;--inetd&lt;/code&gt; option.</source>
          <target state="translated">대체 포트에서 청취하십시오. &lt;code&gt;--inetd&lt;/code&gt; 옵션 과 호환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3e35805a9773260286dfbc09d02caaf5994dc0ce" translate="yes" xml:space="preserve">
          <source>Listing a single attribute:</source>
          <target state="translated">단일 속성 나열 :</target>
        </trans-unit>
        <trans-unit id="69751d90f1fec1736a7673316bf3b759c5271c7d" translate="yes" xml:space="preserve">
          <source>Listing all attributes for a file:</source>
          <target state="translated">파일의 모든 속성 나열 :</target>
        </trans-unit>
        <trans-unit id="e231fe1cc3d8844bfddb76169e22179c8767ce9e" translate="yes" xml:space="preserve">
          <source>Listing an attribute for multiple files:</source>
          <target state="translated">여러 파일에 대한 속성 나열 :</target>
        </trans-unit>
        <trans-unit id="d1d9eec0e1bd38bd76cb67feb04b08b5d78c11bd" translate="yes" xml:space="preserve">
          <source>Listing branches from a specific remote</source>
          <target state="translated">특정 리모콘에서 분기 나열</target>
        </trans-unit>
        <trans-unit id="14162152c45d26fb9527c9f0660bef886294e5bf" translate="yes" xml:space="preserve">
          <source>Listing multiple attributes for a file:</source>
          <target state="translated">파일에 대한 여러 속성 나열 :</target>
        </trans-unit>
        <trans-unit id="540f872616da666be00fd2f7f78a7ae984c11b9a" translate="yes" xml:space="preserve">
          <source>Lists all local or all remote-tracking branches in given repository.</source>
          <target state="translated">지정된 저장소의 모든 로컬 또는 모든 원격 추적 분기를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="b5500d120a9a13cb3af42448653e0cde10752de4" translate="yes" xml:space="preserve">
          <source>Lists commit objects in reverse chronological order</source>
          <target state="translated">커밋 객체를 시간순으로 나열</target>
        </trans-unit>
        <trans-unit id="6385084e9b2c3e78376900259ba28376e3a28618" translate="yes" xml:space="preserve">
          <source>Lists the available Git repositories. This is the default command if no repository is specified in the URL.</source>
          <target state="translated">사용 가능한 Git 리포지토리를 나열합니다. URL에 저장소가 지정되지 않은 경우 이것이 기본 명령입니다.</target>
        </trans-unit>
        <trans-unit id="9438685d87876d6c82356bf9b864c1c6136c1266" translate="yes" xml:space="preserve">
          <source>Lists the capabilities of the helper, one per line, ending with a blank line. Each capability may be preceded with &lt;code&gt;*&lt;/code&gt;, which marks them mandatory for Git versions using the remote helper to understand. Any unknown mandatory capability is a fatal error.</source>
          <target state="translated">빈 줄로 끝나는 도우미의 기능을 한 줄에 하나씩 나열합니다. 각 기능 앞에 &lt;code&gt;*&lt;/code&gt; 가있을 수 있으며 , 원격 헬퍼를 사용하여 Git 버전에 필수임을 표시합니다. 알려지지 않은 필수 기능은 치명적인 오류입니다.</target>
        </trans-unit>
        <trans-unit id="8c594a1bf48edecf6065890a7f89cc7fa404495f" translate="yes" xml:space="preserve">
          <source>Lists the contents of a given tree object, like what &quot;/bin/ls -a&quot; does in the current working directory. Note that:</source>
          <target state="translated">현재 작업 디렉토리에서 &quot;/ bin / ls -a&quot;가 수행하는 것과 같이 주어진 트리 오브젝트의 내용을 나열합니다. 참고 :</target>
        </trans-unit>
        <trans-unit id="9cc5eb61d77cd46774cb42ac22301b7d413d58c5" translate="yes" xml:space="preserve">
          <source>Lists the properties stored in the Subversion repository about a given file or directory. Use -r/--revision to refer to a specific Subversion revision.</source>
          <target state="translated">지정된 파일 또는 디렉토리에 대한 Subversion 저장소에 저장된 특성을 나열합니다. 특정 Subversion 개정판을 참조하려면 -r /-revision을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="11c5aa2ca7f7c3e091142bb69f047bf1ca338d7f" translate="yes" xml:space="preserve">
          <source>Lists the references defined in the bundle. If followed by a list of references, only references matching those given are printed out.</source>
          <target state="translated">번들에 정의 된 참조를 나열합니다. 그 뒤에 참조 목록이 있으면 주어진 참조와 일치하는 참조 만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="ce5afcadd9730c2206b4e08d09ffc836dddfab54" translate="yes" xml:space="preserve">
          <source>Lists the refs, one per line, in the format &quot;&amp;lt;value&amp;gt; &amp;lt;name&amp;gt; [&amp;lt;attr&amp;gt; &amp;hellip;​]&quot;. The value may be a hex sha1 hash, &quot;@&amp;lt;dest&amp;gt;&quot; for a symref, &quot;:&amp;lt;keyword&amp;gt; &amp;lt;value&amp;gt;&quot; for a key-value pair, or &quot;?&quot; to indicate that the helper could not get the value of the ref. A space-separated list of attributes follows the name; unrecognized attributes are ignored. The list ends with a blank line.</source>
          <target state="translated">&quot;&amp;lt;value&amp;gt; &amp;lt;name&amp;gt; [&amp;lt;attr&amp;gt;&amp;hellip;]&quot;형식으로 한 줄에 하나씩 참조를 나열합니다. 값은 16 진수 sha1 해시, symref의 경우 &quot;@ &amp;lt;dest&amp;gt;&quot;, 키-값 쌍의 경우 &quot;: &amp;lt;keyword&amp;gt; &amp;lt;value&amp;gt;&quot;또는 &quot;?&quot;일 수 있습니다. 도우미가 ref 값을 가져올 수 없음을 나타냅니다. 이름 뒤에는 공백으로 구분 된 속성 목록이 있습니다. 인식 할 수없는 속성은 무시됩니다. 목록은 빈 줄로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="cb27642bee7df675e576f1467eabd36ebf236a0c" translate="yes" xml:space="preserve">
          <source>Lists the refs, one per line, in the format &quot;&amp;lt;value&amp;gt; &amp;lt;name&amp;gt; [&amp;lt;attr&amp;gt; &amp;hellip;​]&quot;. The value may be a hex sha1 hash, &quot;@&amp;lt;dest&amp;gt;&quot; for a symref, or &quot;?&quot; to indicate that the helper could not get the value of the ref. A space-separated list of attributes follows the name; unrecognized attributes are ignored. The list ends with a blank line.</source>
          <target state="translated">&quot;&amp;lt;값&amp;gt; &amp;lt;이름&amp;gt; [&amp;lt;attr&amp;gt;&amp;hellip;]&quot;형식으로 한 줄에 하나씩 참조를 나열합니다. 값은 16 진 sha1 해시, &quot;@ &amp;lt;dest&amp;gt;&quot;, 또는 symref 또는 &quot;?&quot;일 수 있습니다. 도우미가 심판의 가치를 얻을 수 없음을 나타냅니다. 공백으로 구분 된 속성 목록은 이름 뒤에옵니다. 인식 할 수없는 속성은 무시됩니다. 목록은 빈 줄로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="8cf165480241df10f979b6b7157595e5407c755f" translate="yes" xml:space="preserve">
          <source>Literal percent sign.</source>
          <target state="translated">리터럴 퍼센트 부호.</target>
        </trans-unit>
        <trans-unit id="c9b025ce8a30fb92786ef26cc44501e09df585de" translate="yes" xml:space="preserve">
          <source>Literal space in command or argument.</source>
          <target state="translated">명령 또는 인수의 리터럴 공간.</target>
        </trans-unit>
        <trans-unit id="3e47004eca06847317d03882ea01098236feca24" translate="yes" xml:space="preserve">
          <source>Loads annotations as described above and automatically scrolls the view to center on line &lt;code&gt;100&lt;/code&gt;.</source>
          <target state="translated">위에서 설명한대로 주석을로드하고 선 &lt;code&gt;100&lt;/code&gt; 을 중심으로보기를 자동으로 스크롤합니다 .</target>
        </trans-unit>
        <trans-unit id="f638d2718f9a7fa3228a4c22ea27ab0cb7ce0ed8" translate="yes" xml:space="preserve">
          <source>Local directory</source>
          <target state="translated">로컬 디렉토리</target>
        </trans-unit>
        <trans-unit id="83cd95e5e26d810cf34fa10fd02190221225a995" translate="yes" xml:space="preserve">
          <source>Locate a good region of the object graph in a damaged repository</source>
          <target state="translated">손상된 저장소에서 오브젝트 그래프의 올바른 영역을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="c6b89ef8cfe5b4e0d5f71a9018f7c23272508e1d" translate="yes" xml:space="preserve">
          <source>Location of repositories</source>
          <target state="translated">리포지토리의 위치</target>
        </trans-unit>
        <trans-unit id="a8464429b3dd8a54d4c3a8d0aaf7809c3b93d077" translate="yes" xml:space="preserve">
          <source>Locations of Marks Files</source>
          <target state="translated">마크 파일의 위치</target>
        </trans-unit>
        <trans-unit id="747742f75a08750185466d70d49a66f609262970" translate="yes" xml:space="preserve">
          <source>Locations of the common system-wide configuration file, the fallback system-wide configuration file and the per-instance configuration file are defined at compile time using build-time Makefile configuration variables, respectively &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt;, &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; and &lt;code&gt;GITWEB_CONFIG&lt;/code&gt;.</source>
          <target state="translated">공통 시스템 전체 구성 파일, 대체 시스템 전체 구성 파일 및 인스턴스 별 구성 파일의 위치는 각각 빌드 타임 Makefile 구성 변수 &lt;code&gt;GITWEB_CONFIG_COMMON&lt;/code&gt; , &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; 및 &lt;code&gt;GITWEB_CONFIG&lt;/code&gt; 를 사용하여 컴파일 타임에 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff8e7c6671e74ff8d9e440b7a275b6b3047a92bf" translate="yes" xml:space="preserve">
          <source>Log details about the incoming connections and requested files.</source>
          <target state="translated">들어오는 연결 및 요청 된 파일에 대한 세부 정보를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="c1bbca864796e717c6563546ee8bb0273fbae9ac" translate="yes" xml:space="preserve">
          <source>Logging updates</source>
          <target state="translated">업데이트 로깅</target>
        </trans-unit>
        <trans-unit id="e76f4d6fb1700b21a7cf7fc7a62d7a34c7014ae2" translate="yes" xml:space="preserve">
          <source>Long Running Filter Process</source>
          <target state="translated">장기 필터 프로세스</target>
        </trans-unit>
        <trans-unit id="555712d9829e6328a9b7d5ec70facbda745fb9b3" translate="yes" xml:space="preserve">
          <source>Look at the diffs from each branch. &lt;code&gt;git log --merge -p &amp;lt;path&amp;gt;&lt;/code&gt; will show diffs first for the &lt;code&gt;HEAD&lt;/code&gt; version and then the &lt;code&gt;MERGE_HEAD&lt;/code&gt; version.</source>
          <target state="translated">각 지점의 diff를보십시오. &lt;code&gt;git log --merge -p &amp;lt;path&amp;gt;&lt;/code&gt; 는 &lt;code&gt;HEAD&lt;/code&gt; 버전에 대한 diff를 먼저 표시 한 다음 &lt;code&gt;MERGE_HEAD&lt;/code&gt; 버전을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a326ab540e0d9536d53dbc94d57cb0c25e24d9a1" translate="yes" xml:space="preserve">
          <source>Look at the diffs. &lt;code&gt;git diff&lt;/code&gt; will show a three-way diff, highlighting changes from both the &lt;code&gt;HEAD&lt;/code&gt; and &lt;code&gt;MERGE_HEAD&lt;/code&gt; versions.</source>
          <target state="translated">차이점을보세요. &lt;code&gt;git diff&lt;/code&gt; 는 &lt;code&gt;HEAD&lt;/code&gt; 및 &lt;code&gt;MERGE_HEAD&lt;/code&gt; 버전 의 변경 사항을 강조 표시하는 3 방향 diff를 표시 합니다.</target>
        </trans-unit>
        <trans-unit id="f8c63749f2ae2fa24fa7ef48c360ef59f66a1f48" translate="yes" xml:space="preserve">
          <source>Look at the originals. &lt;code&gt;git show :1:filename&lt;/code&gt; shows the common ancestor, &lt;code&gt;git show :2:filename&lt;/code&gt; shows the &lt;code&gt;HEAD&lt;/code&gt; version, and &lt;code&gt;git show :3:filename&lt;/code&gt; shows the &lt;code&gt;MERGE_HEAD&lt;/code&gt; version.</source>
          <target state="translated">원본을보십시오. &lt;code&gt;git show :1:filename&lt;/code&gt; 은 공통 조상을, &lt;code&gt;git show :2:filename&lt;/code&gt; 은 &lt;code&gt;HEAD&lt;/code&gt; 버전을, &lt;code&gt;git show :3:filename&lt;/code&gt; 은 &lt;code&gt;MERGE_HEAD&lt;/code&gt; 버전을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="6a423d84e076a3272fdc685127299ea63ea761ac" translate="yes" xml:space="preserve">
          <source>Look for a fix instead of a regression in the code</source>
          <target state="translated">코드에서 회귀 대신 수정 사항을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="4ab23275475ac09a44d78ac861e7af3c95082023" translate="yes" xml:space="preserve">
          <source>Look for attributes in .gitattributes files in the working tree as well (see &lt;a href=&quot;#ATTRIBUTES&quot;&gt;ATTRIBUTES&lt;/a&gt;).</source>
          <target state="translated">작업 트리의 .gitattributes 파일에서도 속성을 찾으십시오 ( &lt;a href=&quot;#ATTRIBUTES&quot;&gt;ATTRIBUTES&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5e41023ffb67a9b868c13a5cdc624ea0d794092d" translate="yes" xml:space="preserve">
          <source>Look for differences that change the number of occurrences of the specified object. Similar to &lt;code&gt;-S&lt;/code&gt;, just the argument is different in that it doesn&amp;rsquo;t search for a specific string but for a specific object id.</source>
          <target state="translated">지정된 오브젝트의 발생 횟수를 변경하는 차이점을 찾으십시오. &lt;code&gt;-S&lt;/code&gt; 와 유사하게 , 특정 문자열을 검색하지 않고 특정 객체 ID를 검색한다는 점에서 인수 만 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a838d092d782360d96378f1e4ff8a0b5fffd060f" translate="yes" xml:space="preserve">
          <source>Look for differences that change the number of occurrences of the specified string (i.e. addition/deletion) in a file. Intended for the scripter&amp;rsquo;s use.</source>
          <target state="translated">파일에서 지정된 문자열 (예 : 추가 / 삭제)의 발생 횟수를 변경하는 차이점을 찾으십시오. 스크립터의 사용을 목적으로합니다.</target>
        </trans-unit>
        <trans-unit id="b8df136f2384d637ef409fc2baddd2b9dce73992" translate="yes" xml:space="preserve">
          <source>Look for differences whose patch text contains added/removed lines that match &amp;lt;regex&amp;gt;.</source>
          <target state="translated">패치 텍스트에 &amp;lt;regex&amp;gt;와 일치하는 추가 / 제거 된 행이 포함 된 차이점을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="4cef9adbc5be0f5f01b5c2739071b69091cb4a32" translate="yes" xml:space="preserve">
          <source>Look for specified patterns in the tracked files in the work tree, blobs registered in the index file, or blobs in given tree objects. Patterns are lists of one or more search expressions separated by newline characters. An empty string as search expression matches all lines.</source>
          <target state="translated">작업 트리의 추적 된 파일, 색인 파일에 등록 된 얼룩 또는 지정된 트리 개체의 얼룩에서 지정된 패턴을 찾으십시오. 패턴은 개행 문자로 구분 된 하나 이상의 검색 표현식 목록입니다. 검색 표현식으로 빈 문자열은 모든 행과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="07448c29252081320f670b2265de0e9cba50a292" translate="yes" xml:space="preserve">
          <source>Look up layout mode using configuration variable column.&amp;lt;name&amp;gt; and column.ui.</source>
          <target state="translated">구성 변수 column. &amp;lt;name&amp;gt; 및 column.ui를 사용하여 레이아웃 모드를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="b62eefc27e1aeffa75b2d4761547bc2b8bc497bd" translate="yes" xml:space="preserve">
          <source>Looks at the current index and checks to see if merges or updates are needed by checking stat() information.</source>
          <target state="translated">현재 인덱스를보고 stat () 정보를 확인하여 병합 또는 업데이트가 필요한지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="4b7876b6a8ad520457ce71bfe745148e3c567edb" translate="yes" xml:space="preserve">
          <source>Looks for &lt;code&gt;solution&lt;/code&gt;, excluding files in &lt;code&gt;Documentation&lt;/code&gt;.</source>
          <target state="translated">를 검색 &lt;code&gt;solution&lt;/code&gt; 의 파일 제외, &lt;code&gt;Documentation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f3233017974f60253fdf12d744b51a535433787" translate="yes" xml:space="preserve">
          <source>Looks for &lt;code&gt;time_t&lt;/code&gt; in all tracked .c and .h files in the working directory and its subdirectories.</source>
          <target state="translated">찾습니다 &lt;code&gt;time_t&lt;/code&gt; 작업 디렉토리 및 하위 디렉토리의 모든 추적 된이 .c 및 .H 파일.</target>
        </trans-unit>
        <trans-unit id="558837c842e106c2ed3e4e9a131c3a7442c122b9" translate="yes" xml:space="preserve">
          <source>Looks for a line that has &lt;code&gt;#define&lt;/code&gt; and either &lt;code&gt;MAX_PATH&lt;/code&gt; or &lt;code&gt;PATH_MAX&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;#define&lt;/code&gt; 과 &lt;code&gt;MAX_PATH&lt;/code&gt; 또는 &lt;code&gt;PATH_MAX&lt;/code&gt; 가있는 줄을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="432adcaf916374b14ccc5f4491d7cd8a1e3d3e44" translate="yes" xml:space="preserve">
          <source>Looks for a line that has &lt;code&gt;NODE&lt;/code&gt; or &lt;code&gt;Unexpected&lt;/code&gt; in files that have lines that match both.</source>
          <target state="translated">둘 다 일치하는 줄이있는 파일에서 &lt;code&gt;NODE&lt;/code&gt; 또는 &lt;code&gt;Unexpected&lt;/code&gt; 줄이있는 줄을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="b11d66d44e8db145700e0edb6375620b652f740a" translate="yes" xml:space="preserve">
          <source>Low-level commands (plumbing)</source>
          <target state="translated">저수준 명령 (배관)</target>
        </trans-unit>
        <trans-unit id="0ffc3dae4e51a700bf1ca804b93845e0102810f8" translate="yes" xml:space="preserve">
          <source>Low-level git operations</source>
          <target state="translated">저수준 git 연산</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="5d487fc78e43a0306fd5f718aec828744ee6e786" translate="yes" xml:space="preserve">
          <source>M: modification of the contents or mode of a file</source>
          <target state="translated">M : 파일 내용 또는 모드 수정</target>
        </trans-unit>
        <trans-unit id="0f48f030cf13414eeafe91359c3c62bf97314f35" translate="yes" xml:space="preserve">
          <source>Magic Options</source>
          <target state="translated">매직 옵션</target>
        </trans-unit>
        <trans-unit id="7d828d176880cf3ec5ec8010d93f54010eebda7b" translate="yes" xml:space="preserve">
          <source>Maildir splitting relies upon filenames being sorted to output patches in the correct order.</source>
          <target state="translated">Maildir 분할은 올바른 순서로 패치를 출력하기 위해 파일 이름을 정렬하는 데 의존합니다.</target>
        </trans-unit>
        <trans-unit id="57a6217babf3a984d54a72505b0f2a4f3e1be542" translate="yes" xml:space="preserve">
          <source>Main porcelain commands</source>
          <target state="translated">주요 도자기 명령</target>
        </trans-unit>
        <trans-unit id="46b62a0f964fab2f018eee342e7b4db44adbc685" translate="yes" xml:space="preserve">
          <source>Maintaining topic branches for a Linux subsystem maintainer</source>
          <target state="translated">Linux 서브 시스템 관리자의 토픽 브랜치 유지</target>
        </trans-unit>
        <trans-unit id="52f0f393e457cb924c234a7254a4daec3a0cbf32" translate="yes" xml:space="preserve">
          <source>Maintenance branch management after a feature release</source>
          <target state="translated">기능 릴리스 후 유지 관리 지점 관리</target>
        </trans-unit>
        <trans-unit id="319909b05c9210e6ff8b8a19f69dc9189ee2cca4" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;git gc --auto&lt;/code&gt; return immediately and run in background if the system supports it. Default is true.</source>
          <target state="translated">확인 &lt;code&gt;git gc --auto&lt;/code&gt; 즉시 실행 백그라운드에서 시스템 지원이 경우 수익을. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="77c42361d50b9bdea29b692160b9eae95cceb52e" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;git show-ref&lt;/code&gt; act as a filter that reads refs from stdin of the form &quot;&lt;code&gt;^(?:&amp;lt;anything&amp;gt;\s)?&amp;lt;refname&amp;gt;(?:\^{})?$&lt;/code&gt;&quot; and performs the following actions on each: (1) strip &quot;^{}&quot; at the end of line if any; (2) ignore if pattern is provided and does not head-match refname; (3) warn if refname is not a well-formed refname and skip; (4) ignore if refname is a ref that exists in the local repository; (5) otherwise output the line.</source>
          <target state="translated">확인 &lt;code&gt;git show-ref&lt;/code&gt; 형태의 stdin에서 심판을 읽는 필터의 역할을 &quot; &lt;code&gt;^(?:&amp;lt;anything&amp;gt;\s)?&amp;lt;refname&amp;gt;(?:\^{})?$&lt;/code&gt; &quot;각과 수행 다음 작업 : (1) 줄 끝에서 &quot;^ {}&quot;을 제거합니다 (있는 경우). (2) 패턴이 제공되고 refname과 일치하지 않는 경우 무시합니다. (3) refname이 올바른 형식의 refname이 아닌 경우 경고하고 건너 뜁니다. (4) refname이 로컬 저장소에 존재하는 ref이면 무시하십시오. (5) 그렇지 않으면 라인을 출력하십시오.</target>
        </trans-unit>
        <trans-unit id="51befbcaeb5eba297db1a634b8802a7f0078cead" translate="yes" xml:space="preserve">
          <source>Make &lt;code&gt;git svn&lt;/code&gt; less verbose. Specify a second time to make it even less verbose.</source>
          <target state="translated">&lt;code&gt;git svn&lt;/code&gt; 을 덜 장황하게 만드십시오 . 덜 장황하게하려면 두 번째 시간을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="2da3bd3f8069e8e437af583aecc3a384c81edd34" translate="yes" xml:space="preserve">
          <source>Make a &lt;code&gt;bare&lt;/code&gt; Git repository. That is, instead of creating &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; and placing the administrative files in &lt;code&gt;&amp;lt;directory&amp;gt;/.git&lt;/code&gt;, make the &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; itself the &lt;code&gt;$GIT_DIR&lt;/code&gt;. This obviously implies the &lt;code&gt;--no-checkout&lt;/code&gt; because there is nowhere to check out the working tree. Also the branch heads at the remote are copied directly to corresponding local branch heads, without mapping them to &lt;code&gt;refs/remotes/origin/&lt;/code&gt;. When this option is used, neither remote-tracking branches nor the related configuration variables are created.</source>
          <target state="translated">&lt;code&gt;bare&lt;/code&gt; Git 리포지토리를 만듭니다 . 즉, &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; 를 작성 하고 관리 파일을 &lt;code&gt;&amp;lt;directory&amp;gt;/.git&lt;/code&gt; 에 배치하는 대신 &lt;code&gt;&amp;lt;directory&amp;gt;&lt;/code&gt; 자체를 &lt;code&gt;$GIT_DIR&lt;/code&gt; 만드십시오 . 이것은 작업 트리를 확인할 곳이 없기 때문에 분명히 &lt;code&gt;--no-checkout&lt;/code&gt; 을 의미합니다 . 또한 리모컨의 분기 헤드는 &lt;code&gt;refs/remotes/origin/&lt;/code&gt; 매핑하지 않고 해당 로컬 분기 헤드로 직접 복사됩니다 . 이 옵션을 사용하면 원격 추적 분기 나 관련 구성 변수가 만들어지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ca024f41825508ff37398849dd7bbbd184e78e6" translate="yes" xml:space="preserve">
          <source>Make a GPG-signed tag, using the default e-mail address&amp;rsquo;s key. The default behavior of tag GPG-signing is controlled by &lt;code&gt;tag.gpgSign&lt;/code&gt; configuration variable if it exists, or disabled otherwise. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">기본 이메일 주소의 키를 사용하여 GPG 서명 태그를 만듭니다. 태그 GPG 서명의 기본 동작은 &lt;code&gt;tag.gpgSign&lt;/code&gt; 구성 변수 (있는 경우)에 의해 제어 되거나 그렇지 않으면 비활성화됩니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5a6f6bd2dfbdab5f143e86ea9155fad4e43a30c" translate="yes" xml:space="preserve">
          <source>Make a GPG-signed tag, using the given key.</source>
          <target state="translated">주어진 키를 사용하여 GPG 서명 태그를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="99f2296af5452e1eec1986dbc7a0151a5ba6b1fc" translate="yes" xml:space="preserve">
          <source>Make a commit by taking the updated working tree contents of the paths specified on the command line, disregarding any contents that have been staged for other paths. This is the default mode of operation of &lt;code&gt;git commit&lt;/code&gt; if any paths are given on the command line, in which case this option can be omitted. If this option is specified together with &lt;code&gt;--amend&lt;/code&gt;, then no paths need to be specified, which can be used to amend the last commit without committing changes that have already been staged. If used together with &lt;code&gt;--allow-empty&lt;/code&gt; paths are also not required, and an empty commit will be created.</source>
          <target state="translated">다른 경로에 대해 준비된 내용을 무시하고 명령 행에 지정된 경로의 업데이트 된 작업 트리 내용을 가져 와서 커밋하십시오. 명령 행에 경로가 지정된 경우 &lt;code&gt;git commit&lt;/code&gt; 의 기본 작동 모드입니다 .이 경우이 옵션을 생략 할 수 있습니다. 이 옵션을 &lt;code&gt;--amend&lt;/code&gt; 과 함께 지정하면 경로를 지정할 필요가 없으므로 이미 준비된 변경 사항을 커밋하지 않고 마지막 커밋을 수정하는 데 사용할 수 있습니다. &lt;code&gt;--allow-empty&lt;/code&gt; 경로 와 함께 사용 하면 빈 커밋이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2e9bf6a1a9ac175346438fe9d4c19601601a0ebd" translate="yes" xml:space="preserve">
          <source>Make a list of the commits which are about to be rebased. Let the user edit that list before rebasing. This mode can also be used to split commits (see SPLITTING COMMITS below).</source>
          <target state="translated">리베이스 될 커밋 목록을 만듭니다. 리베이스하기 전에 사용자가 해당 목록을 편집하도록합니다. 이 모드는 커밋을 분할하는 데에도 사용할 수 있습니다 (아래의 커밋 분할 참조).</target>
        </trans-unit>
        <trans-unit id="f382849103310ffba0e3d31128dfababfd915957" translate="yes" xml:space="preserve">
          <source>Make a local clone that borrows from the current directory, without checking things out:</source>
          <target state="translated">확인하지 않고 현재 디렉토리에서 빌려 오는 로컬 복제본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d7a3e91b3667d18f363db6d6cc32c0afec1ed1d5" translate="yes" xml:space="preserve">
          <source>Make a side branch for every topic (feature, bugfix, &amp;hellip;​). Fork it off at the oldest integration branch that you will eventually want to merge it into.</source>
          <target state="translated">모든 주제 (기능, 버그 수정, ...)에 대한 사이드 브랜치를 만듭니다. 가장 오래된 통합 브랜치에서 결국 통합하려는 경우이를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="89db797c5d89c53349b8d88ec549bb720f48d1f7" translate="yes" xml:space="preserve">
          <source>Make an unsigned, annotated tag object</source>
          <target state="translated">부호없는 주석이 달린 태그 객체 만들기</target>
        </trans-unit>
        <trans-unit id="f88ecf2f4eb0c5509c792cd2c61ea44a524baf96" translate="yes" xml:space="preserve">
          <source>Make corrections to working tree files.</source>
          <target state="translated">작업 트리 파일을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="79ee7beb56d7493ce335c85dd0a8333674bff17b" translate="yes" xml:space="preserve">
          <source>Make git-send-email less verbose. One line per email should be all that is output.</source>
          <target state="translated">git-send-email을 덜 장황하게 만드십시오. 이메일 당 한 줄만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="ff429cc18c1dac972928cb3da6e4d06bbfe2d8ec" translate="yes" xml:space="preserve">
          <source>Make one commit and return to the shell when it is complete. This command returns a non-zero exit code if the window was closed in any way other than by making a commit.</source>
          <target state="translated">하나의 커밋을 만들고 완료되면 셸로 돌아갑니다. 이 명령은 커밋을 수행하는 것 이외의 방법으로 창이 닫힌 경우 0이 아닌 종료 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="31ca9c9bf3eab94aff99250728fe74f77977b844" translate="yes" xml:space="preserve">
          <source>Make sure Git knows who to blame:</source>
          <target state="translated">Git이 비난 할 사람을 알고 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="cf12b54cc8063982ae2c9b96588de4f236c9e743" translate="yes" xml:space="preserve">
          <source>Make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If the value is &lt;code&gt;check&lt;/code&gt; then Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing, the push will be aborted and exit with non-zero status. If the value is &lt;code&gt;on-demand&lt;/code&gt; then all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If the value is &lt;code&gt;no&lt;/code&gt; then default behavior of ignoring submodules when pushing is retained. You may override this configuration at time of push by specifying &lt;code&gt;--recurse-submodules=check|on-demand|no&lt;/code&gt;.</source>
          <target state="translated">푸시 할 개정에 사용 된 모든 서브 모듈 커밋이 원격 추적 브랜치에서 사용 가능한지 확인하십시오. 값이 &lt;code&gt;check&lt;/code&gt; 되면 Git은 푸시 할 개정에서 변경된 모든 서브 모듈 커밋이 서브 모듈의 하나 이상의 리모트에서 사용 가능한지 검증합니다. 커밋이 누락되면 푸시가 중단되고 0이 아닌 상태로 종료됩니다. 값이 &lt;code&gt;on-demand&lt;/code&gt; 이면 푸시 될 개정에서 변경된 모든 서브 모듈이 푸시됩니다. 요청시 필요한 모든 수정 사항을 푸시 할 수없는 경우 중단되고 0이 아닌 상태로 종료됩니다. 값이 &lt;code&gt;no&lt;/code&gt; 밀어 넣을 때 하위 모듈을 무시하는 기본 동작이 유지됩니다. 푸시시이 구성을 무시하여 다음을 지정할 수 있습니다 &lt;code&gt;--recurse-submodules=check|on-demand|no&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e58089d4f2b4b0ca2024cc65ec03ed1d72bcb40" translate="yes" xml:space="preserve">
          <source>Make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If the value is &lt;code&gt;check&lt;/code&gt; then Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing, the push will be aborted and exit with non-zero status. If the value is &lt;code&gt;on-demand&lt;/code&gt; then all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If the value is &lt;code&gt;no&lt;/code&gt; then default behavior of ignoring submodules when pushing is retained. You may override this configuration at time of push by specifying &lt;code&gt;--recurse-submodules=check|on-demand|no&lt;/code&gt;. If not set, &lt;code&gt;no&lt;/code&gt; is used by default, unless &lt;code&gt;submodule.recurse&lt;/code&gt; is set (in which case a &lt;code&gt;true&lt;/code&gt; value means &lt;code&gt;on-demand&lt;/code&gt;).</source>
          <target state="translated">푸시 할 개정에 사용되는 모든 하위 모듈 커밋이 원격 추적 분기에서 사용 가능한지 확인합니다. 값이 &lt;code&gt;check&lt;/code&gt; 이면 Git은 푸시 할 개정판에서 변경된 모든 하위 모듈 커밋이 하위 모듈의 하나 이상의 원격에서 사용 가능한지 확인합니다. 커밋이 누락 된 경우 푸시가 중단되고 0이 아닌 상태로 종료됩니다. 값이 &lt;code&gt;on-demand&lt;/code&gt; 이면 푸시 할 개정에서 변경된 모든 하위 모듈이 푸시됩니다. 온 디맨드가 필요한 모든 수정을 푸시 할 수없는 경우에도 중단되고 0이 아닌 상태로 종료됩니다. 값이 &lt;code&gt;no&lt;/code&gt; 이면 푸시 할 때 하위 모듈을 무시하는 기본 동작이 유지됩니다. 푸시 할 때이 구성을 재정의 할 수 있습니다. &lt;code&gt;--recurse-submodules=check|on-demand|no&lt;/code&gt; . 설정 하지 않은 경우 &lt;code&gt;submodule.recurse&lt;/code&gt; 가 설정 되지 않는 한 기본적으로 &lt;code&gt;no&lt;/code&gt; 가 사용됩니다 (이 경우 &lt;code&gt;true&lt;/code&gt; 값은 &lt;code&gt;on-demand&lt;/code&gt; 를 의미 함 ).</target>
        </trans-unit>
        <trans-unit id="70b6629c434b51e7d9186d1fc6fe97c1a3725440" translate="yes" xml:space="preserve">
          <source>Make sure committers have a umask of at most 027, so that the directories they create are writable and searchable by other group members.</source>
          <target state="translated">커미터가 최대 027의 umask를 가지도록하여, 작성된 디렉토리가 다른 그룹 구성원이 쓰기 가능하고 검색 할 수 있도록하십시오.</target>
        </trans-unit>
        <trans-unit id="4b35196a3d616941ad0c8a125c3a9f25e1bdc376" translate="yes" xml:space="preserve">
          <source>Make sure this directory is available for others you want your changes to be pulled via the transport of your choice. Also you need to make sure that you have the &lt;code&gt;git-receive-pack&lt;/code&gt; program on the &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">선택한 전송을 통해 변경 사항을 가져 오려는 다른 사용자가이 디렉토리를 사용할 수 있는지 확인하십시오. 또한 &lt;code&gt;$PATH&lt;/code&gt; 에 &lt;code&gt;git-receive-pack&lt;/code&gt; 프로그램 이 있는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6631b9ca24ae751d7ee25163002526a066325c25" translate="yes" xml:space="preserve">
          <source>Make the first mail (or all the mails with &lt;code&gt;--no-thread&lt;/code&gt;) appear as a reply to the given &amp;lt;message id&amp;gt;, which avoids breaking threads to provide a new patch series.</source>
          <target state="translated">첫 번째 메일 (또는 &lt;code&gt;--no-thread&lt;/code&gt; 가 있는 모든 메일 )이 지정된 &amp;lt;message id&amp;gt;에 대한 응답으로 나타나게하여 스레드를 끊어 새로운 패치 시리즈를 제공하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="5a1ce0ecb5c94a2505e8bfd1950281f48170d98f" translate="yes" xml:space="preserve">
          <source>Make the first mail (or all the mails with &lt;code&gt;--no-thread&lt;/code&gt;) appear as a reply to the given Message-Id, which avoids breaking threads to provide a new patch series. The second and subsequent emails will be sent as replies according to the &lt;code&gt;--[no-]chain-reply-to&lt;/code&gt; setting.</source>
          <target state="translated">첫 번째 메일 (또는 &lt;code&gt;--no-thread&lt;/code&gt; 가 있는 모든 메일 )이 지정된 Message-Id에 대한 응답으로 나타나게하여 스레드를 끊어 새로운 패치 시리즈를 제공하지 않도록합니다. 두 번째 이후 이메일은 &lt;code&gt;--[no-]chain-reply-to&lt;/code&gt; 설정 에 따라 답장으로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="b064d6e8766baf86355fa160624701d28d48e0eb" translate="yes" xml:space="preserve">
          <source>Make the program exit with codes similar to diff(1). That is, it exits with 1 if there were differences and 0 means no differences.</source>
          <target state="translated">diff (1)와 유사한 코드로 프로그램을 종료하십시오. 즉, 차이가 있으면 1로 종료하고 0은 차이가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="033698ff1d93839c9dc26bb7039e879974408d51" translate="yes" xml:space="preserve">
          <source>Make the repository group-writable, (and g+sx, since the git group may be not the primary group of all users). This is used to loosen the permissions of an otherwise safe umask(2) value. Note that the umask still applies to the other permission bits (e.g. if umask is &lt;code&gt;0022&lt;/code&gt;, using &lt;code&gt;group&lt;/code&gt; will not remove read privileges from other (non-group) users). See &lt;code&gt;0xxx&lt;/code&gt; for how to exactly specify the repository permissions.</source>
          <target state="translated">저장소를 그룹 쓰기 가능으로 설정하십시오 (git 그룹은 모든 사용자의 기본 그룹이 아니기 때문에 g + sx). 이것은 안전한 umask (2) 값의 권한을 완화하는 데 사용됩니다. umask는 여전히 다른 권한 비트에 적용됩니다 (예 : umask가 &lt;code&gt;0022&lt;/code&gt; 인 경우 &lt;code&gt;group&lt;/code&gt; 을 사용하면 그룹 이 아닌 다른 사용자의 읽기 권한이 제거되지 않음). 저장소 권한을 정확하게 지정하는 방법 은 &lt;code&gt;0xxx&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="daa563a54f59f3d95749377d0e4af4c611fecd18" translate="yes" xml:space="preserve">
          <source>Making a change</source>
          <target state="translated">변경</target>
        </trans-unit>
        <trans-unit id="9aef7fbf27451a8c36fe7bf7a109aea9540e01ca" translate="yes" xml:space="preserve">
          <source>Making changes</source>
          <target state="translated">변경</target>
        </trans-unit>
        <trans-unit id="992a7beb5615876037da9b0e5b4a3e7c21af51d8" translate="yes" xml:space="preserve">
          <source>Making some changes to the working directory using your favorite editor.</source>
          <target state="translated">선호하는 편집기를 사용하여 작업 디렉토리를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="bf4919466a0f70dfd02acc3627e75ad16a05f620" translate="yes" xml:space="preserve">
          <source>Manage multiple working trees</source>
          <target state="translated">여러 작업 트리 관리</target>
        </trans-unit>
        <trans-unit id="6ec4a25401fa228522c7be97da233480069758e8" translate="yes" xml:space="preserve">
          <source>Manage multiple working trees attached to the same repository.</source>
          <target state="translated">동일한 저장소에 연결된 여러 작업 트리를 관리하십시오.</target>
        </trans-unit>
        <trans-unit id="5f089a6eb7f251a9a2fe0a3f833141f8db37c3ff" translate="yes" xml:space="preserve">
          <source>Manage reflog information</source>
          <target state="translated">Reflog 정보 관리</target>
        </trans-unit>
        <trans-unit id="021ab6f7ef8793b1b816ea4bdd5e727ce06994e0" translate="yes" xml:space="preserve">
          <source>Manage set of tracked repositories</source>
          <target state="translated">추적 된 리포지토리 집합 관리</target>
        </trans-unit>
        <trans-unit id="65f908ba554d3d8c75571c008e2b6e59e8585d63" translate="yes" xml:space="preserve">
          <source>Manage the serialized commit-graph file.</source>
          <target state="translated">직렬화 된 커밋 그래프 파일을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="4a3e0eed31d02104159aa0bed6d5acb0e05768b8" translate="yes" xml:space="preserve">
          <source>Manage the set of repositories (&quot;remotes&quot;) whose branches you track.</source>
          <target state="translated">분기를 추적하는 리포지토리 세트 ( &quot;원격&quot;)를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="3507e0027b822825db37aad1b6a1e0779dcd0d96" translate="yes" xml:space="preserve">
          <source>Managing branches</source>
          <target state="translated">지점 관리</target>
        </trans-unit>
        <trans-unit id="279735249dbe3dcc024592a529bd9cb39b1b8496" translate="yes" xml:space="preserve">
          <source>Manipulate the notes tree in &amp;lt;ref&amp;gt;. This overrides &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; and the &quot;core.notesRef&quot; configuration. The ref specifies the full refname when it begins with &lt;code&gt;refs/notes/&lt;/code&gt;; when it begins with &lt;code&gt;notes/&lt;/code&gt;, &lt;code&gt;refs/&lt;/code&gt; and otherwise &lt;code&gt;refs/notes/&lt;/code&gt; is prefixed to form a full name of the ref.</source>
          <target state="translated">&amp;lt;ref&amp;gt;에서 노트 트리를 조작하십시오. 이는 &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; 및 &quot;core.notesRef&quot;구성을 대체 합니다. ref는 &lt;code&gt;refs/notes/&lt;/code&gt; 시작할 때 전체 참조 이름을 지정합니다 . &lt;code&gt;notes/&lt;/code&gt; 시작 하면 &lt;code&gt;refs/&lt;/code&gt; 및 그렇지 않으면 &lt;code&gt;refs/notes/&lt;/code&gt; 가 접두어로 ref의 전체 이름을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="ad0e6ab545d99b4fca1e842f2d64e34b5bf6ca91" translate="yes" xml:space="preserve">
          <source>Manipulating branches</source>
          <target state="translated">가지 조작</target>
        </trans-unit>
        <trans-unit id="e163593ceb018ccfe91e5474069f8880c01bf32f" translate="yes" xml:space="preserve">
          <source>Manipulation commands</source>
          <target state="translated">조작 명령</target>
        </trans-unit>
        <trans-unit id="a4c79f29e9d9d5fa1534359d2910523c3bd41716" translate="yes" xml:space="preserve">
          <source>Manipulators:</source>
          <target state="translated">Manipulators:</target>
        </trans-unit>
        <trans-unit id="2d6fc489721f7990b3e0a46d8dbd0fae7613420d" translate="yes" xml:space="preserve">
          <source>Many (most?) public remote repositories will not contain any of the checked out files or even an index file, and will &lt;strong&gt;only&lt;/strong&gt; contain the actual core Git files. Such a repository usually doesn&amp;rsquo;t even have the &lt;code&gt;.git&lt;/code&gt; subdirectory, but has all the Git files directly in the repository.</source>
          <target state="translated">많은 (대부분?) 공용 원격 저장소에는 체크 아웃 된 파일이나 색인 파일이 &lt;strong&gt;없으며&lt;/strong&gt; 실제 코어 Git 파일 &lt;strong&gt;만&lt;/strong&gt; 포함 됩니다 . 이러한 저장소에는 일반적으로 &lt;code&gt;.git&lt;/code&gt; 하위 디렉토리가 없지만 모든 Git 파일이 저장소에 직접 있습니다.</target>
        </trans-unit>
        <trans-unit id="23a4d8d6b8951ee492fd478361a461e34445c192" translate="yes" xml:space="preserve">
          <source>Many Git commands also take sets of commits, which can be specified in a number of ways. Here are some examples with &lt;code&gt;git log&lt;/code&gt;:</source>
          <target state="translated">많은 Git 명령은 여러 가지 방법으로 지정할 수있는 커밋 세트를 사용합니다. &lt;code&gt;git log&lt;/code&gt; 를 사용한 몇 가지 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="cb5f624f4f524730b1dad471a4cc62df1265c105" translate="yes" xml:space="preserve">
          <source>Many Git commands take revision parameters as arguments. Depending on the command, they denote a specific commit or, for commands which walk the revision graph (such as &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;), all commits which are reachable from that commit. For commands that walk the revision graph one can also specify a range of revisions explicitly.</source>
          <target state="translated">많은 Git 명령은 수정 매개 변수를 인수로 사용합니다. 명령에 따라 특정 커밋 또는 수정 그래프를 걷는 명령 (예 : &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; )에 대해 해당 커밋에서 도달 할 수있는 모든 커밋을 나타냅니다. 수정본 그래프를 걷는 명령의 경우 수정본 범위를 명시 적으로 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8eadff7d5c23284bf3e40779cca1324c9880e38b" translate="yes" xml:space="preserve">
          <source>Many Git porcelainish commands take mixture of flags (i.e. parameters that begin with a dash &lt;code&gt;-&lt;/code&gt;) and parameters meant for the underlying &lt;code&gt;git rev-list&lt;/code&gt; command they use internally and flags and parameters for the other commands they use downstream of &lt;code&gt;git rev-list&lt;/code&gt;. This command is used to distinguish between them.</source>
          <target state="translated">많은 힘내 porcelainish 명령 (즉, 대시로 시작 매개 변수 플래그의 혼합물을 &lt;code&gt;-&lt;/code&gt; 그리고 기본 의미 매개 변수) &lt;code&gt;git rev-list&lt;/code&gt; 가 하류 사용하는 다른 명령에 대한가 내부적으로 사용하는 명령 및 플래그 및 매개 변수 &lt;code&gt;git rev-list&lt;/code&gt; . 이 명령은 이들을 구별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="07f9a7fabb84ff55c93b5220c84bc1016373588c" translate="yes" xml:space="preserve">
          <source>Many command-line options can be provided as part of the fast-import stream itself by using the &lt;code&gt;feature&lt;/code&gt; or &lt;code&gt;option&lt;/code&gt; commands. However, some of these options are unsafe (e.g., allowing fast-import to access the filesystem outside of the repository). These options are disabled by default, but can be allowed by providing this option on the command line. This currently impacts only the &lt;code&gt;export-marks&lt;/code&gt;, &lt;code&gt;import-marks&lt;/code&gt;, and &lt;code&gt;import-marks-if-exists&lt;/code&gt; feature commands.</source>
          <target state="translated">&lt;code&gt;feature&lt;/code&gt; 또는 &lt;code&gt;option&lt;/code&gt; 명령 을 사용하여 빠른 가져 오기 스트림 자체의 일부로 많은 명령 줄 옵션을 제공 할 수 있습니다 . 그러나 이러한 옵션 중 일부는 안전하지 않습니다 (예 : 빠른 가져 오기를 통해 저장소 외부의 파일 시스템에 액세스 할 수 있도록 허용). 이러한 옵션은 기본적으로 비활성화되어 있지만 명령 줄에서이 옵션을 제공하여 허용 할 수 있습니다. 이는 현재 &lt;code&gt;export-marks&lt;/code&gt; , &lt;code&gt;import-marks&lt;/code&gt; 및 &lt;code&gt;import-marks-if-exists&lt;/code&gt; 기능 명령 에만 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="b810424b3fea997d54a1c6f50a7ffa7b2bdf31cc" translate="yes" xml:space="preserve">
          <source>Many commands allow wildcards in paths, but you need to protect them from getting globbed by the shell. These two mean different things:</source>
          <target state="translated">많은 명령은 경로에서 와일드 카드를 허용하지만 쉘에 의해 붙 잡히지 않도록 보호해야합니다. 이 두 가지는 다른 의미입니다.</target>
        </trans-unit>
        <trans-unit id="f769735173b4b17536b3bddf331e35fc94c1f6c2" translate="yes" xml:space="preserve">
          <source>Many commands take revisions (most often &quot;commits&quot;, but sometimes &quot;tree-ish&quot;, depending on the context and command) and paths as their arguments. Here are the rules:</source>
          <target state="translated">많은 명령은 수정 (대부분 &quot;커밋&quot;이지만 컨텍스트 및 명령에 따라 &quot;트리-쉬&quot;) 및 경로를 인수로 사용합니다. 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="51a04d163df59d3e4e585f46784dd69c625e4feb" translate="yes" xml:space="preserve">
          <source>Many commands that can work on files in the working tree and/or in the index can take &lt;code&gt;--cached&lt;/code&gt; and/or &lt;code&gt;--index&lt;/code&gt; options. Sometimes people incorrectly think that, because the index was originally called cache, these two are synonyms. They are &lt;strong&gt;not&lt;/strong&gt; &amp;mdash; these two options mean very different things.</source>
          <target state="translated">작업 트리 및 / 또는 인덱스의 파일에서 작동 할 수있는 많은 명령은 &lt;code&gt;--cached&lt;/code&gt; 및 / 또는 &lt;code&gt;--index&lt;/code&gt; 옵션을 사용할 수 있습니다. 때때로 사람들은 색인이 원래 캐시라고했기 때문에이 두 가지는 동의어라고 잘못 생각합니다. 그들은는 &lt;strong&gt;없습니다&lt;/strong&gt; -이 두 옵션은 매우 다른 것을 의미한다.</target>
        </trans-unit>
        <trans-unit id="41a419d79cd72b9d54b27ecee9672655c35e91cc" translate="yes" xml:space="preserve">
          <source>Many gitweb features can be enabled (or disabled) and configured using the &lt;code&gt;%feature&lt;/code&gt; hash. Names of gitweb features are keys of this hash.</source>
          <target state="translated">&lt;code&gt;%feature&lt;/code&gt; 해시를 사용하여 많은 gitweb 기능을 활성화 (또는 비활성화) 할 수 있습니다 . gitweb 기능의 이름은이 해시의 키입니다.</target>
        </trans-unit>
        <trans-unit id="919a2ac82af6ff1bc82b2171d1abca264db10f6e" translate="yes" xml:space="preserve">
          <source>Many installations of sshd do not invoke your shell as the login shell when you directly run programs; what this means is that if your login shell is &lt;em&gt;bash&lt;/em&gt;, only &lt;code&gt;.bashrc&lt;/code&gt; is read and not &lt;code&gt;.bash_profile&lt;/code&gt;. As a workaround, make sure &lt;code&gt;.bashrc&lt;/code&gt; sets up &lt;code&gt;$PATH&lt;/code&gt; so that you can run &lt;em&gt;git-receive-pack&lt;/em&gt; program.</source>
          <target state="translated">많은 sshd 설치는 프로그램을 직접 실행할 때 쉘을 로그인 쉘로 호출하지 않습니다. 이것은 로그인 쉘이 &lt;em&gt;bash&lt;/em&gt; 이면 &lt;code&gt;.bashrc&lt;/code&gt; 만 읽히고 &lt;code&gt;.bash_profile&lt;/code&gt; 이 아니라는 것을 의미합니다 . 해결 방법으로 &lt;code&gt;.bashrc&lt;/code&gt; 가 &lt;code&gt;$PATH&lt;/code&gt; 설정하여 &lt;em&gt;git-receive-pack&lt;/em&gt; 프로그램을 실행할 수 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="b683891958210e2ee979b3e8c7ad10f12997dda2" translate="yes" xml:space="preserve">
          <source>Many mailers if not set up properly will corrupt whitespace. Here are two common types of corruption:</source>
          <target state="translated">제대로 설정하지 않으면 많은 메일러가 공백을 손상시킵니다. 두 가지 일반적인 유형의 손상이 있습니다.</target>
        </trans-unit>
        <trans-unit id="193dde6b7f3a20700543ed6450f24935f7b33dfa" translate="yes" xml:space="preserve">
          <source>Many of the higher-level commands were originally implemented as shell scripts using a smaller core of low-level Git commands. These can still be useful when doing unusual things with Git, or just as a way to understand its inner workings.</source>
          <target state="translated">많은 상위 레벨 명령은 원래 더 작은 코어의 하위 레벨 Git 명령을 사용하여 쉘 스크립트로 구현되었습니다. 이것들은 Git으로 비정상적인 일을 할 때 또는 내부 작업을 이해하는 방법으로 여전히 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d6c28c55f8170d273c49f3e427a981c665cf6ea" translate="yes" xml:space="preserve">
          <source>Many operations in Git depend on your filesystem to have an efficient &lt;code&gt;lstat(2)&lt;/code&gt; implementation, so that &lt;code&gt;st_mtime&lt;/code&gt; information for working tree files can be cheaply checked to see if the file contents have changed from the version recorded in the index file. Unfortunately, some filesystems have inefficient &lt;code&gt;lstat(2)&lt;/code&gt;. If your filesystem is one of them, you can set &quot;assume unchanged&quot; bit to paths you have not changed to cause Git not to do this check. Note that setting this bit on a path does not mean Git will check the contents of the file to see if it has changed &amp;mdash; it makes Git to omit any checking and assume it has &lt;strong&gt;not&lt;/strong&gt; changed. When you make changes to working tree files, you have to explicitly tell Git about it by dropping &quot;assume unchanged&quot; bit, either before or after you modify them.</source>
          <target state="translated">Git의 많은 작업은 효율적인 &lt;code&gt;lstat(2)&lt;/code&gt; 구현 을 위해 파일 시스템에 의존하므로 작업 트리 파일에 대한 &lt;code&gt;st_mtime&lt;/code&gt; 정보를 저렴하게 검사하여 파일 내용이 인덱스 파일에 기록 된 버전에서 변경되었는지 확인할 수 있습니다. 불행하게도 일부 파일 시스템에는 비효율적 인 &lt;code&gt;lstat(2)&lt;/code&gt; 있습니다. 파일 시스템이 그 중 하나 인 경우 &quot;변경되지 않은 것으로 가정&quot;비트를 변경하지 않은 경로로 설정하여 Git이이 검사를 수행하지 않도록 할 수 있습니다. 경로에서이 비트를 설정한다고해서 Git이 파일의 내용을 검사하여 파일이 변경되었는지 확인한다는 의미는 아닙니다. Git이 검사를 생략하고 &lt;strong&gt;그렇지 않은&lt;/strong&gt; 것으로 가정합니다.&lt;strong&gt;&lt;/strong&gt;변경되었습니다. 작업 트리 파일을 변경할 때는 수정하기 전이나 후에 &quot;변경되지 않은 것으로 가정&quot;비트를 삭제하여 Git에 명시 적으로 알려 주어야합니다.</target>
        </trans-unit>
        <trans-unit id="a799d1cceae5d3b6566df7c502b0ed31229cf195" translate="yes" xml:space="preserve">
          <source>Many revision control systems provide an &lt;code&gt;add&lt;/code&gt; command that tells the system to start tracking changes to a new file. Git&amp;rsquo;s &lt;code&gt;add&lt;/code&gt; command does something simpler and more powerful: &lt;code&gt;git add&lt;/code&gt; is used both for new and newly modified files, and in both cases it takes a snapshot of the given files and stages that content in the index, ready for inclusion in the next commit.</source>
          <target state="translated">많은 개정 제어 시스템 은 시스템에 새 파일의 변경 내용 추적을 시작하도록 지시 하는 &lt;code&gt;add&lt;/code&gt; 명령을 제공 합니다. Git의 &lt;code&gt;add&lt;/code&gt; 명령은보다 간단하고 강력한 기능을 수행합니다. &lt;code&gt;git add&lt;/code&gt; 는 새로 수정 된 파일과 새로 수정 된 파일 모두에 사용되며, 두 경우 모두 주어진 파일의 스냅 샷을 생성하여 인덱스에있는 컨텐츠를 준비하여 다음 커밋에 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4ad3aa56684a237b2a48778413d62e45b68868b" translate="yes" xml:space="preserve">
          <source>Many tags. Will create a tag for every commit, reflecting the commit name in the Arch repository.</source>
          <target state="translated">많은 태그. Arch 저장소의 커밋 이름을 반영하여 모든 커밋에 대한 태그를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6b4939f173ca46ae5e70f2a578215c85acafb3ce" translate="yes" xml:space="preserve">
          <source>Many thanks to Ingo Molnar for giving me very useful information that appears in this paper, for commenting on this paper, for his suggestions to improve &quot;git bisect&quot; and for evangelizing &quot;git bisect&quot; on the linux kernel mailing lists.</source>
          <target state="translated">이 백서에 나오는 매우 유용한 정보를 제공하고이 논문에 대한 의견을 제시하고 &quot;git bisect&quot;를 개선하기위한 그의 제안과 Linux 커널 메일 링리스트에서 &quot;git bisect&quot;를 복음화 해 주신 Ingo Molnar에게 많은 감사를드립니다.</target>
        </trans-unit>
        <trans-unit id="5bd4feea472ac1f81e9eed337015c1647da376b9" translate="yes" xml:space="preserve">
          <source>Many thanks to Junio Hamano for his help in reviewing this paper, for reviewing the patches I sent to the Git mailing list, for discussing some ideas and helping me improve them, for improving &quot;git bisect&quot; a lot and for his awesome work in maintaining and developing Git.</source>
          <target state="translated">이 논문을 검토하고, Git 메일 링리스트에 보낸 패치를 검토하고, 일부 아이디어를 논의하고, 개선하는 데 도움이되고, &quot;git bisect&quot;를 많이 개선하고, 유지 관리에있어 훌륭한 작업을 해준 Junio ​​Hamano에게 많은 감사를드립니다. 그리고 힘내 개발.</target>
        </trans-unit>
        <trans-unit id="a308e878405ccac0452dc3a943e6c4f471d0d0f3" translate="yes" xml:space="preserve">
          <source>Many thanks to Linus Torvalds for inventing, developing and evangelizing &quot;git bisect&quot;, Git and Linux.</source>
          <target state="translated">&quot;git bisect&quot;, Git 및 Linux를 발명, 개발 및 복음화 한 Linus Torvalds에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="64e052904657c30a32be467111b38e2db70890d3" translate="yes" xml:space="preserve">
          <source>Many thanks to the Linux-Kongress program committee for choosing the author to given a talk and for publishing this paper.</source>
          <target state="translated">연설을 할 작가를 선택하고이 논문을 발표 한 Linux-Kongress 프로그램위원회에 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="a813e2d801820a3507d225cfe410c73c1e3814a5" translate="yes" xml:space="preserve">
          <source>Many thanks to the many other great people who helped one way or another when I worked on Git, especially to Andreas Ericsson, Johannes Schindelin, H. Peter Anvin, Daniel Barkalow, Bill Lear, John Hawley, Shawn O. Pierce, Jeff King, Sam Vilain, Jon Seymour.</source>
          <target state="translated">Git에서 일할 때 도움을 준 많은 위대한 사람들, 특히 Andreas Ericsson, Johannes Schindelin, H. Peter Anvin, Daniel Barkalow, Bill Lear, John Hawley, Shawn O. Pierce, Jeff King, 샘 빌린, 존 시모어</target>
        </trans-unit>
        <trans-unit id="970bd5edbccf4926f346f36ced29b782ff134b0f" translate="yes" xml:space="preserve">
          <source>Many things can then be done very naturally:</source>
          <target state="translated">그러면 많은 것들이 매우 자연스럽게 이루어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08ed471839ae0d35cbf114cdc8b4fb025451ea78" translate="yes" xml:space="preserve">
          <source>Map a P4 user to a name and email address in Git. Use a string with the following format to create a mapping:</source>
          <target state="translated">P4 사용자를 Git의 이름과 이메일 주소에 매핑하십시오. 다음 형식의 문자열을 사용하여 맵핑을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="84e3b6902de1ae94c28d951dff280df12bc818fa" translate="yes" xml:space="preserve">
          <source>Mapping authors</source>
          <target state="translated">지도 제작자</target>
        </trans-unit>
        <trans-unit id="ecca08ad6644372b493b29196801e0262451ee0a" translate="yes" xml:space="preserve">
          <source>Mapping between Subversion revision numbers and Git commit names. In a repository where the noMetadata option is not set, this can be rebuilt from the git-svn-id: lines that are at the end of every commit (see the &lt;code&gt;svn.noMetadata&lt;/code&gt; section above for details).</source>
          <target state="translated">Subversion 개정 번호와 Git 커밋 이름 간의 매핑 noMetadata 옵션이 설정되지 않은 저장소에서는 모든 커밋 끝에있는 git-svn-id : 행에서이를 다시 작성할 수 있습니다 (자세한 내용은 위 의 &lt;code&gt;svn.noMetadata&lt;/code&gt; 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="f80c6e32aadbd525747e2562fb58002684c64ae1" translate="yes" xml:space="preserve">
          <source>Mark lines that were changed by an ignored revision that we attributed to another commit with a &lt;code&gt;?&lt;/code&gt; in the output of &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;.</source>
          <target state="translated">무시 된 개정으로 변경 한 마크 라인은 &lt;code&gt;?&lt;/code&gt; &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; 의 출력에서 .</target>
        </trans-unit>
        <trans-unit id="e0a93a83bc77d4e299bb423ede0b0e7523360c05" translate="yes" xml:space="preserve">
          <source>Mark lines that were changed by an ignored revision that we could not attribute to another commit with a &lt;code&gt;*&lt;/code&gt; in the output of &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; 출력에서 &lt;code&gt;*&lt;/code&gt; 를 사용하여 다른 커밋에 속할 수없는 무시 된 개정으로 변경된 행을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="ffa04a5e9e510ce8e8a9af22652c96cb5f2a2455" translate="yes" xml:space="preserve">
          <source>Mark the commit you want to split with the action &quot;edit&quot;.</source>
          <target state="translated">&quot;edit&quot;조치로 분할하려는 커밋을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="9ad05336158823a7d5e9d2740631e3ed3e7b77cc" translate="yes" xml:space="preserve">
          <source>Mark the series as the &amp;lt;n&amp;gt;-th iteration of the topic. The output filenames have &lt;code&gt;v&amp;lt;n&amp;gt;&lt;/code&gt; prepended to them, and the subject prefix (&quot;PATCH&quot; by default, but configurable via the &lt;code&gt;--subject-prefix&lt;/code&gt; option) has ` v&amp;lt;n&amp;gt;` appended to it. E.g. &lt;code&gt;--reroll-count=4&lt;/code&gt; may produce &lt;code&gt;v4-0001-add-makefile.patch&lt;/code&gt; file that has &quot;Subject: [PATCH v4 1/20] Add makefile&quot; in it.</source>
          <target state="translated">시리즈를 주제의 &amp;lt;n&amp;gt; 번째 반복으로 표시하십시오. 출력 파일 이름 앞에는 &lt;code&gt;v&amp;lt;n&amp;gt;&lt;/code&gt; 붙고 제목 접두사 (기본적으로 &quot;PATCH&quot;이지만 &lt;code&gt;--subject-prefix&lt;/code&gt; 옵션을 통해 구성 가능 )에`v &amp;lt;n&amp;gt;`이 추가됩니다. 예를 들어 &lt;code&gt;--reroll-count=4&lt;/code&gt; 는 &quot;Subject : [PATCH v4 1/20] Makefile 추가&quot;가 포함 된 &lt;code&gt;v4-0001-add-makefile.patch&lt;/code&gt; 파일을 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eb02cc756d5e31341021dd6b9e08120c18cfff12" translate="yes" xml:space="preserve">
          <source>Mark which side of a symmetric difference a commit is reachable from. Commits from the left side are prefixed with &lt;code&gt;&amp;lt;&lt;/code&gt; and those from the right with &lt;code&gt;&amp;gt;&lt;/code&gt;. If combined with &lt;code&gt;--boundary&lt;/code&gt;, those commits are prefixed with &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">커밋에 도달 할 수있는 대칭 차이의 측면을 표시하십시오. 왼쪽에서 커밋은 접두어 &lt;code&gt;&amp;lt;&lt;/code&gt; 및 오른쪽 것과 &lt;code&gt;&amp;gt;&lt;/code&gt; . &lt;code&gt;--boundary&lt;/code&gt; 와 결합하면 해당 커밋 앞에 &lt;code&gt;-&lt;/code&gt; 가 붙습니다 .</target>
        </trans-unit>
        <trans-unit id="6cf65e398a783b020004a05bc4b12965bd321675" translate="yes" xml:space="preserve">
          <source>Mark which side of a symmetric difference a commit is reachable from. Commits from the left side are prefixed with a &lt;code&gt;&amp;lt;&lt;/code&gt; symbol and those from the right with a &lt;code&gt;&amp;gt;&lt;/code&gt; symbol.</source>
          <target state="translated">커밋에 도달 할 수있는 대칭 차이의 측면을 표시하십시오. 왼쪽에서 커밋은 &lt;code&gt;&amp;lt;&lt;/code&gt; 기호 로 시작하고 오른쪽에서 커밋은 &lt;code&gt;&amp;gt;&lt;/code&gt; 기호로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d120d1dcfa9af04a37a29923ad102f9ac75edbe0" translate="yes" xml:space="preserve">
          <source>Marking files as binary</source>
          <target state="translated">파일을 이진으로 표시</target>
        </trans-unit>
        <trans-unit id="3549e52dba075c1ca63de7856965a26fd121848f" translate="yes" xml:space="preserve">
          <source>Marks are stored in a sparse array, using 1 pointer (4 bytes or 8 bytes, depending on pointer size) per mark. Although the array is sparse, frontends are still strongly encouraged to use marks between 1 and n, where n is the total number of marks required for this import.</source>
          <target state="translated">마크는 마크 당 1 개의 포인터 (포인터 크기에 따라 4 바이트 또는 8 바이트)를 사용하여 희소 배열에 저장됩니다. 배열이 희소하지만 프런트 엔드는 여전히 1과 n 사이의 마크를 사용하는 것이 좋습니다. 여기서 n은이 가져 오기에 필요한 총 마크 수입니다.</target>
        </trans-unit>
        <trans-unit id="c020b534de76a3110681e8b3a1131c198a04e4dd" translate="yes" xml:space="preserve">
          <source>Marks must be declared (via &lt;code&gt;mark&lt;/code&gt;) before they can be used.</source>
          <target state="translated">마크를 사용하려면 마크를 통해 ( &lt;code&gt;mark&lt;/code&gt; 를 통해 ) 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e23875af098ed58ac7ddbf626ebbfd55b3530c2d" translate="yes" xml:space="preserve">
          <source>Marks the end of the stream. This command is optional unless the &lt;code&gt;done&lt;/code&gt; feature was requested using the &lt;code&gt;--done&lt;/code&gt; command-line option or &lt;code&gt;feature done&lt;/code&gt; command.</source>
          <target state="translated">스트림의 끝을 표시합니다. &lt;code&gt;--done&lt;/code&gt; 명령 줄 옵션 또는 &lt;code&gt;feature done&lt;/code&gt; 명령을 사용하여 &lt;code&gt;done&lt;/code&gt; 기능을 요청 하지 않은 경우이 명령은 선택 사항 입니다.</target>
        </trans-unit>
        <trans-unit id="6dd5e3d7525f7c72ed149669f4682e8cf2613e2e" translate="yes" xml:space="preserve">
          <source>Match paths exactly (i.e. don&amp;rsquo;t allow &quot;/foo/repo&quot; when the real path is &quot;/foo/repo.git&quot; or &quot;/foo/repo/.git&quot;) and don&amp;rsquo;t do user-relative paths. &lt;code&gt;git daemon&lt;/code&gt; will refuse to start when this option is enabled and no whitelist is specified.</source>
          <target state="translated">실제 경로가 &quot;/foo/repo.git&quot;또는 &quot;/foo/repo/.git&quot;인 경우 &quot;/ foo / repo&quot;를 허용하지 않고 경로를 정확하게 일치시키고 사용자 기준 경로를 수행하지 마십시오. 이 옵션이 활성화되고 화이트리스트가 지정되지 않으면 &lt;code&gt;git daemon&lt;/code&gt; 은 시작을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="1c5cb990d5ea569aee72e359a127ac5dd4a253ea" translate="yes" xml:space="preserve">
          <source>Match the pattern only at word boundary (either begin at the beginning of a line, or preceded by a non-word character; end at the end of a line or followed by a non-word character).</source>
          <target state="translated">단어 경계에서만 패턴을 일치시킵니다 (줄의 시작에서 시작하거나 단어가 아닌 문자가 앞에옵니다. 줄의 끝에서 끝나거나 단어가 아닌 문자가옵니다).</target>
        </trans-unit>
        <trans-unit id="ca182a2e7bbbd5ec9c62eec976529a0aa078540e" translate="yes" xml:space="preserve">
          <source>Match the regular expression limiting patterns without regard to letter case.</source>
          <target state="translated">대소 문자와 상관없이 정규 표현식 제한 패턴을 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="1452c4b1c4eed7c80174fb8c82a8ed6f95d98c4d" translate="yes" xml:space="preserve">
          <source>Maximum delta depth, for blob and tree deltification. Default is 50.</source>
          <target state="translated">얼룩 및 나무 껍질 제거를위한 최대 델타 깊이. 기본값은 50입니다.</target>
        </trans-unit>
        <trans-unit id="384f40abc20254795ab29a564353f53402412c1e" translate="yes" xml:space="preserve">
          <source>Maximum number of branches to maintain active at once. See &amp;ldquo;Memory Utilization&amp;rdquo; below for details. Default is 5.</source>
          <target state="translated">한 번에 활성을 유지할 최대 분기 수입니다. 자세한 내용은 아래의 &quot;메모리 사용률&quot;을 참조하십시오. 기본값은 5입니다.</target>
        </trans-unit>
        <trans-unit id="0a8681cfb7605cda2b80805ca7e930924afc3f52" translate="yes" xml:space="preserve">
          <source>Maximum number of bytes per thread to reserve for caching base objects that may be referenced by multiple deltified objects. By storing the entire decompressed base objects in a cache Git is able to avoid unpacking and decompressing frequently used base objects multiple times.</source>
          <target state="translated">여러 deltified 개체에서 참조 할 수있는 기본 개체를 캐싱하기 위해 예약 할 스레드 당 최대 바이트 수입니다. 압축 해제 된 전체 기본 개체를 캐시에 저장함으로써 Git은 자주 사용되는 기본 개체의 압축을 여러 번 풀고 압축을 푸는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ba691ad2489c6a98bfddfb725c399a5433235ec" translate="yes" xml:space="preserve">
          <source>Maximum number of bytes to map simultaneously into memory from pack files. If Git needs to access more than this many bytes at once to complete an operation it will unmap existing regions to reclaim virtual address space within the process.</source>
          <target state="translated">팩 파일에서 메모리에 동시에 맵핑 할 최대 바이트 수입니다. Git이 작업을 완료하기 위해 한 번에이 바이트 이상에 액세스해야하는 경우 프로세스 내에서 가상 주소 공간을 확보하기 위해 기존 영역을 매핑 해제합니다.</target>
        </trans-unit>
        <trans-unit id="015780ae5eaf5a16460a6c6f6a47f9fd68665f6e" translate="yes" xml:space="preserve">
          <source>Maximum number of bytes to reserve for caching base objects that may be referenced by multiple deltified objects. By storing the entire decompressed base objects in a cache Git is able to avoid unpacking and decompressing frequently used base objects multiple times.</source>
          <target state="translated">여러 deltified 객체가 참조 할 수있는 기본 객체를 캐싱하기 위해 예약 할 최대 바이트 수입니다. 압축 해제 된 기본 객체 전체를 캐시에 저장함으로써 Git은 자주 사용하는 기본 객체를 여러 번 풀고 압축 해제하는 것을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9639a9871e3fa301072f34b62bd6d8d1df5dfde8" translate="yes" xml:space="preserve">
          <source>Maximum number of concurrent clients, defaults to 32. Set it to zero for no limit.</source>
          <target state="translated">최대 동시 클라이언트 수, 기본값은 32입니다. 제한없이 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="3fca64028c3b9d66663fb33bbabf381bdeaeb020" translate="yes" xml:space="preserve">
          <source>Maximum size in bytes of the buffer used by smart HTTP transports when POSTing data to the remote system. For requests larger than this buffer size, HTTP/1.1 and Transfer-Encoding: chunked is used to avoid creating a massive pack file locally. Default is 1 MiB, which is sufficient for most requests.</source>
          <target state="translated">원격 시스템에 데이터를 POST 할 때 스마트 HTTP 전송에 사용되는 버퍼의 최대 크기 (바이트)입니다. 이 버퍼 크기보다 큰 요청의 경우 HTTP / 1.1 및 Transfer-Encoding : chunked는 대규모 팩 파일을 로컬로 작성하지 않도록하기 위해 사용됩니다. 기본값은 1MiB이며 대부분의 요청에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="d63005f2c2b8f8c3239933e10d80e78d75fee39e" translate="yes" xml:space="preserve">
          <source>Maximum size of a blob that fast-import will attempt to create a delta for, expressed in bytes. The default is 512m (512 MiB). Some importers may wish to lower this on systems with constrained memory.</source>
          <target state="translated">빠른 가져 오기에서 바이트 단위로 표현 된 델타를 만들려고 시도하는 Blob의 최대 크기입니다. 기본값은 512m (512MiB)입니다. 일부 수입 업체는 메모리가 제한된 시스템에서이 값을 낮추기를 원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3dd84835c1a4e2de21619e12a6eaaff0c2d1fd8" translate="yes" xml:space="preserve">
          <source>Maximum size of each output pack file. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. The minimum size allowed is limited to 1 MiB. If specified, multiple packfiles may be created, which also prevents the creation of a bitmap index. The default is unlimited, unless the config variable &lt;code&gt;pack.packSizeLimit&lt;/code&gt; is set.</source>
          <target state="translated">각 출력 팩 파일의 최대 크기 크기는 &quot;k&quot;, &quot;m&quot;또는 &quot;g&quot;로 접미사를 붙일 수 있습니다. 허용되는 최소 크기는 1MiB로 제한됩니다. 지정된 경우 여러 팩 파일이 만들어져 비트 맵 인덱스가 만들어지지 않을 수도 있습니다. 구성 변수 &lt;code&gt;pack.packSizeLimit&lt;/code&gt; 가 설정되어 있지 않으면 기본값은 무제한 입니다.</target>
        </trans-unit>
        <trans-unit id="b8685db9c67d15fcb99750ad6a0c6f6dc3e27c92" translate="yes" xml:space="preserve">
          <source>Maximum size of each output packfile. The default is unlimited.</source>
          <target state="translated">각 출력 팩 파일의 최대 크기 기본값은 무제한입니다.</target>
        </trans-unit>
        <trans-unit id="ecff084a0c01e319db62c5b088c7a98c5cc26a2a" translate="yes" xml:space="preserve">
          <source>May be an unabbreviated ref name or a glob and may be specified multiple times. A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored.</source>
          <target state="translated">축약되지 않은 참조 이름 또는 glob 일 수 있으며 여러 번 지정할 수 있습니다. 존재하지 않는 심판에 대해서는 경고가 표시되지만 어떤 심판과도 일치하지 않는 글롭은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="706c83c32d28c2f1cb1aaafc37be7356f71e7631" translate="yes" xml:space="preserve">
          <source>May be set to a boolean value, or the string &lt;code&gt;if-asked&lt;/code&gt;. A true value causes all pushes to be GPG signed, as if &lt;code&gt;--signed&lt;/code&gt; is passed to &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;. The string &lt;code&gt;if-asked&lt;/code&gt; causes pushes to be signed if the server supports it, as if &lt;code&gt;--signed=if-asked&lt;/code&gt; is passed to &lt;code&gt;git push&lt;/code&gt;. A false value may override a value from a lower-priority config file. An explicit command-line flag always overrides this config option.</source>
          <target state="translated">부울 값 또는 문자열 &lt;code&gt;if-asked&lt;/code&gt; 로 설정 될 수 있습니다 . true 값은 &lt;code&gt;--signed&lt;/code&gt; 가 &lt;a href=&quot;git-push&quot;&gt;git-push [1]로&lt;/a&gt; 전달되는 것처럼 모든 푸시가 GPG 서명되도록합니다 . &lt;code&gt;if-asked&lt;/code&gt; 문자열 은 &lt;code&gt;--signed=if-asked&lt;/code&gt; 가 &lt;code&gt;git push&lt;/code&gt; 로 전달되는 것처럼 서버가 지원하는 경우 푸시에 서명을합니다 . 잘못된 값은 우선 순위가 낮은 구성 파일의 값보다 우선합니다. 명시적인 명령 줄 플래그는 항상이 구성 옵션을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="8555af2d5095b661ce8d37e9e0375fb4c8ea77d6" translate="yes" xml:space="preserve">
          <source>May be used to make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If &lt;code&gt;check&lt;/code&gt; is used Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing the push will be aborted and exit with non-zero status. If &lt;code&gt;on-demand&lt;/code&gt; is used all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If &lt;code&gt;only&lt;/code&gt; is used all submodules will be recursively pushed while the superproject is left unpushed. A value of &lt;code&gt;no&lt;/code&gt; or using &lt;code&gt;--no-recurse-submodules&lt;/code&gt; can be used to override the push.recurseSubmodules configuration variable when no submodule recursion is required.</source>
          <target state="translated">푸시 할 개정에 사용 된 모든 서브 모듈 커밋이 원격 추적 브랜치에서 사용 가능한지 확인하는 데 사용될 수 있습니다. 경우 &lt;code&gt;check&lt;/code&gt; 사용 힘내 밀어하기 위해 수정 변경하는 모든 서브 모듈 커밋 원격 서브 모듈 중 적어도 하나에 사용할 수 있는지 확인합니다. 커밋이 누락되면 푸시가 중단되고 0이 아닌 상태로 종료됩니다. 경우 &lt;code&gt;on-demand&lt;/code&gt; 추진한다 추진되는 수정 변경하는 모든 서브 모듈을 사용한다. 요청시 필요한 모든 수정 사항을 푸시 할 수없는 경우 중단되고 0이 아닌 상태로 종료됩니다. 경우 &lt;code&gt;only&lt;/code&gt; 사용되는 superproject이 unpushed 남아있는 동안 모든 서브 모듈은 재귀 적으로 추진 될 것입니다. &lt;code&gt;--no-recurse-submodules&lt;/code&gt; 를 사용하거나 사용 &lt;code&gt;no&lt;/code&gt; 값 하위 모듈 재귀가 필요하지 않은 경우 push.recurseSubmodules 구성 변수를 재정의하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8be2a61b9ad007dcdaebc339c9660a293e37ceee" translate="yes" xml:space="preserve">
          <source>Mbox file to split. If not given, the mbox is read from the standard input.</source>
          <target state="translated">분할 할 Mbox 파일. 지정하지 않으면 표준 입력에서 mbox를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="1ce7743133ea15a3c11834ae295610d6b0aca98e" translate="yes" xml:space="preserve">
          <source>Memory utilization</source>
          <target state="translated">메모리 활용</target>
        </trans-unit>
        <trans-unit id="94804378bc64156caa1411beabf938d0cc1f334a" translate="yes" xml:space="preserve">
          <source>Merge a topic branch into the current branch, which resulted in a fast-forward.</source>
          <target state="translated">토픽 브랜치를 현재 브랜치로 병합하면 빨리 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="aa4cb5d8e33b071846e0985dfd9e8a73b7ff3b77" translate="yes" xml:space="preserve">
          <source>Merge branch &lt;code&gt;maint&lt;/code&gt; into the current branch, but do not make a new commit automatically:</source>
          <target state="translated">분기 &lt;code&gt;maint&lt;/code&gt; 을 현재 분기로 병합 하지만 자동으로 새 커밋을 만들지 마십시오.</target>
        </trans-unit>
        <trans-unit id="36c2108053218bb1c9bd1daf5d80ef9e2b56153b" translate="yes" xml:space="preserve">
          <source>Merge branch &lt;code&gt;obsolete&lt;/code&gt; into the current branch, using &lt;code&gt;ours&lt;/code&gt; merge strategy:</source>
          <target state="translated">병합 지점 &lt;code&gt;obsolete&lt;/code&gt; 사용하여 현재 지점에, &lt;code&gt;ours&lt;/code&gt; 병합 전략 :</target>
        </trans-unit>
        <trans-unit id="2340cae4ab971b09adab3732a6eccbc0f94439af" translate="yes" xml:space="preserve">
          <source>Merge branches &lt;code&gt;fixes&lt;/code&gt; and &lt;code&gt;enhancements&lt;/code&gt; on top of the current branch, making an octopus merge:</source>
          <target state="translated">현재 브랜치 위에 브랜치 &lt;code&gt;fixes&lt;/code&gt; 및 &lt;code&gt;enhancements&lt;/code&gt; 을 병합하여 문어를 병합합니다.</target>
        </trans-unit>
        <trans-unit id="3b3fe151c69070e113efe45497e8fbe34f98eda0" translate="yes" xml:space="preserve">
          <source>Merge into the current branch the remote branch &lt;code&gt;next&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; 현재 브랜치를 원격 브랜치로 병합하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5d9976d41384cd800a73252d5887846f7995334" translate="yes" xml:space="preserve">
          <source>Merge one patch into CVS</source>
          <target state="translated">하나의 패치를 CVS에 병합</target>
        </trans-unit>
        <trans-unit id="ebf628d17763f2d1db5244a9d541825468f6e3f2" translate="yes" xml:space="preserve">
          <source>Merge one patch into CVS (-c and -w options). The working directory is within the Git Repo</source>
          <target state="translated">하나의 패치를 CVS에 병합합니다 (-c 및 -w 옵션). 작업 디렉토리는 Git Repo 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="374bc1e6ce1c863c36094e824049bd53454731f0" translate="yes" xml:space="preserve">
          <source>Merge pending patches into CVS automatically &amp;mdash; only if you really know what you are doing</source>
          <target state="translated">보류중인 패치를 CVS에 자동으로 병합 &amp;ndash; 실제로 수행중인 작업을 알고있는 경우에만</target>
        </trans-unit>
        <trans-unit id="1ecf516cb34751fcee31d345dc521d62850b1084" translate="yes" xml:space="preserve">
          <source>Merge strategies</source>
          <target state="translated">전략 병합</target>
        </trans-unit>
        <trans-unit id="6455bb1c3dd50961d850d4ec4f8b22adf354885c" translate="yes" xml:space="preserve">
          <source>Merge the given notes ref into the current notes ref. This will try to merge the changes made by the given notes ref (called &quot;remote&quot;) since the merge-base (if any) into the current notes ref (called &quot;local&quot;).</source>
          <target state="translated">주어진 노트 참조를 현재 노트 참조로 병합합니다. 이렇게하면 병합 기반 (있는 경우) 이후의 지정된 음표 참조 ( &quot;원격&quot;)의 변경 사항을 현재 음표 참조 ( &quot;로컬&quot;)로 병합하려고합니다.</target>
        </trans-unit>
        <trans-unit id="06a4a977ae422fbb370e91879e13703bae28bf9d" translate="yes" xml:space="preserve">
          <source>Merge tracking</source>
          <target state="translated">병합 병합</target>
        </trans-unit>
        <trans-unit id="af8c9dbb2cf6a08b436fada56eb16ee91017d8ce" translate="yes" xml:space="preserve">
          <source>Merge workflow</source>
          <target state="translated">워크 플로우 병합</target>
        </trans-unit>
        <trans-unit id="01d28a50eda177ec75942bb24c131250cdadabfb" translate="yes" xml:space="preserve">
          <source>Merges</source>
          <target state="translated">Merges</target>
        </trans-unit>
        <trans-unit id="c4dada76f0f6e7dcbd827c4ba6bada46b3c6714c" translate="yes" xml:space="preserve">
          <source>Merges (to be discussed later), as well as operations such as &lt;code&gt;git reset&lt;/code&gt;, which change the currently checked-out commit, generally set ORIG_HEAD to the value HEAD had before the current operation.</source>
          <target state="translated">현재 체크 아웃 된 커밋을 변경하는 &lt;code&gt;git reset&lt;/code&gt; 과 같은 작업과 병합 (나중에 설명)은 일반적으로 ORIG_HEAD를 현재 작업 이전의 HEAD 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="376269fe69e269c1639bc7c223893145d88653cf" translate="yes" xml:space="preserve">
          <source>Merges are always included. However, their parent list is rewritten: Along each parent, prune away commits that are not included themselves. This results in</source>
          <target state="translated">병합은 항상 포함됩니다. 그러나 부모 목록이 다시 작성됩니다. 각 부모와 함께 포함되지 않은 커밋을 정리하십시오. 결과</target>
        </trans-unit>
        <trans-unit id="6da92828bff93237c525d505f61963005fa8aa9b" translate="yes" xml:space="preserve">
          <source>Merges can be also made simpler by using smaller branches or by using many topic branches instead of only long version related branches.</source>
          <target state="translated">더 작은 브랜치를 사용하거나 긴 버전 관련 브랜치 대신 많은 토픽 브랜치를 사용하여 병합을 더 단순하게 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="18462046f484e3565df5821cdce8eadab95f1224" translate="yes" xml:space="preserve">
          <source>Merges have many advantages, so we try to solve as many problems as possible with merges alone. Cherry-picking is still occasionally useful; see &quot;Merging upwards&quot; below for an example.</source>
          <target state="translated">병합에는 많은 장점이 있으므로 병합만으로 가능한 많은 문제를 해결하려고합니다. 체리 따기는 여전히 유용합니다. 예는 아래의 &quot;위로 병합&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="40de0d4de887a374168bf79e72c7aa0fa4594d6e" translate="yes" xml:space="preserve">
          <source>Merging</source>
          <target state="translated">Merging</target>
        </trans-unit>
        <trans-unit id="31c92682cbfd6598c97a2306d8a83a0e953592eb" translate="yes" xml:space="preserve">
          <source>Merging and rebasing</source>
          <target state="translated">병합 및 리베이스</target>
        </trans-unit>
        <trans-unit id="f2204607f23628214b6d42add29d21c7f2e29b95" translate="yes" xml:space="preserve">
          <source>Merging branches with differing checkin/checkout attributes</source>
          <target state="translated">체크인 / 체크 아웃 속성이 다른 브랜치 병합</target>
        </trans-unit>
        <trans-unit id="c535f2db054f922c7b696495f8b89a913e2a11c4" translate="yes" xml:space="preserve">
          <source>Merging external work</source>
          <target state="translated">외부 작업 병합</target>
        </trans-unit>
        <trans-unit id="603157d894d36cb77fbe21d75b0d20a12dc01779" translate="yes" xml:space="preserve">
          <source>Merging inside a &lt;a href=&quot;#def_shallow_clone&quot;&gt;shallow clone&lt;/a&gt; will work as long as a merge base is in the recent history. Otherwise, it will be like merging unrelated histories and may have to result in huge conflicts. This limitation may make such a repository unsuitable to be used in merge based workflows.</source>
          <target state="translated">&lt;a href=&quot;#def_shallow_clone&quot;&gt;얕은 복제본&lt;/a&gt; 내부의 병합 은 병합 기록이 최근 기록에있는 한 작동합니다. 그렇지 않으면 관련이없는 기록을 병합하는 것과 같으며 큰 충돌이 발생할 수 있습니다. 이러한 제한으로 인해 이러한 리포지토리가 병합 기반 워크 플로에 사용하기에 적합하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab26fbd41a8ed9c39ebd7d129433578a03343e81" translate="yes" xml:space="preserve">
          <source>Merging multiple trees</source>
          <target state="translated">여러 트리 병합</target>
        </trans-unit>
        <trans-unit id="f73ac93115d3cdadc50aebe7fa9b08f89899740b" translate="yes" xml:space="preserve">
          <source>Merging multiple trees, continued</source>
          <target state="translated">여러 개의 나무를 병합하여 계속</target>
        </trans-unit>
        <trans-unit id="98b404243306169adb88696dc4ad2165a137c1ac" translate="yes" xml:space="preserve">
          <source>Merging tag</source>
          <target state="translated">태그 병합</target>
        </trans-unit>
        <trans-unit id="1af53d3a2af732fec14191525698059a5e40b8d4" translate="yes" xml:space="preserve">
          <source>Merging two branches</source>
          <target state="translated">두 가지 병합</target>
        </trans-unit>
        <trans-unit id="6153c9c2afc2b444427af54ff710f1f84e9dda45" translate="yes" xml:space="preserve">
          <source>Merging upwards</source>
          <target state="translated">위쪽으로 병합</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="ede02150d3611f561b342e50cd978f7d1c7b1d2a" translate="yes" xml:space="preserve">
          <source>Miscellaneous capabilities</source>
          <target state="translated">기타 기능</target>
        </trans-unit>
        <trans-unit id="5b0739f48e82ea34788c95cbd8a03adab72795db" translate="yes" xml:space="preserve">
          <source>Miscellaneous differences</source>
          <target state="translated">기타 차이점</target>
        </trans-unit>
        <trans-unit id="68e2e957e53389b060cb16e85d086c46b6c88151" translate="yes" xml:space="preserve">
          <source>Missing From or In-Reply-To headers will be prompted for.</source>
          <target state="translated">From 또는 In-Reply-To 헤더가 프롬프트됩니다.</target>
        </trans-unit>
        <trans-unit id="00b61542d0211972bc61982931e3e8c50577c383" translate="yes" xml:space="preserve">
          <source>Modified content is represented by &quot;-&quot; lines (removing the old content) followed by &quot;+&quot; lines (adding the replacement content). You can prevent staging the modification by converting &quot;-&quot; lines to &quot; &quot;, and removing &quot;+&quot; lines. Beware that modifying only half of the pair is likely to introduce confusing changes to the index.</source>
          <target state="translated">수정 된 내용은 &quot;-&quot;줄 (이전 내용 제거)과 &quot;+&quot;줄 (대체 내용 추가)로 표시됩니다. &quot;-&quot;행을 &quot;&quot;로 변환하고 &quot;+&quot;행을 제거하면 수정 사항이 스테이징되지 않도록 할 수 있습니다. 쌍의 절반 만 수정하면 색인이 혼동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e5a153f7d9724480c99f8d43544411a606a03ba" translate="yes" xml:space="preserve">
          <source>Modifies the index or directory cache. Each file mentioned is updated into the index and any &lt;code&gt;unmerged&lt;/code&gt; or &lt;code&gt;needs updating&lt;/code&gt; state is cleared.</source>
          <target state="translated">색인 또는 디렉토리 캐시를 수정합니다. 언급 된 각 파일은 색인으로 업데이트되며 &lt;code&gt;unmerged&lt;/code&gt; 또는 &lt;code&gt;needs updating&lt;/code&gt; 가 필요한 상태는 지워집니다.</target>
        </trans-unit>
        <trans-unit id="f87d4010c94238df04ebfd441b3a0111f33d7a25" translate="yes" xml:space="preserve">
          <source>Modify behavior of the next command naming a &amp;lt;ref&amp;gt;. The only valid option is &lt;code&gt;no-deref&lt;/code&gt; to avoid dereferencing a symbolic ref.</source>
          <target state="translated">&amp;lt;ref&amp;gt;를 명명하는 다음 명령의 동작을 수정하십시오. 유일하게 유효한 옵션은 상징적 참조를 역 참조하는 것을 피하기 위해 &lt;code&gt;no-deref&lt;/code&gt; 하다.</target>
        </trans-unit>
        <trans-unit id="eeb79095663bd56bf370bd2096cd4a5ecc99b3a1" translate="yes" xml:space="preserve">
          <source>Modify some files, then add their updated contents to the index:</source>
          <target state="translated">일부 파일을 수정 한 다음 업데이트 된 내용을 색인에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="19db1a3cc38a1c275e20ba3eb14f5761050f2bac" translate="yes" xml:space="preserve">
          <source>Modifying the index is easy:</source>
          <target state="translated">색인을 수정하는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="3d6095a82dcd262f6e6b119640e8d9b20bcf7da2" translate="yes" xml:space="preserve">
          <source>More detail on the following is available from the &lt;a href=&quot;user-manual#git-concepts&quot;&gt;Git concepts chapter of the user-manual&lt;/a&gt; and &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial[7]&lt;/a&gt;.</source>
          <target state="translated">다음에 대한 자세한 내용 &lt;a href=&quot;user-manual#git-concepts&quot;&gt;은 사용자 매뉴얼&lt;/a&gt; 및 &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial [7]&lt;/a&gt; 의 Git 개념 장 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06099ebf3c1fb2d228710b5b862871e1eab3c063" translate="yes" xml:space="preserve">
          <source>More generally, a branch that is created from a remote-tracking branch will pull by default from that branch. See the descriptions of the &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; options in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;, and the discussion of the &lt;code&gt;--track&lt;/code&gt; option in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;, to learn how to control these defaults.</source>
          <target state="translated">더 일반적으로, 원격 추적 분기에서 작성된 분기는 기본적으로 해당 분기에서 가져옵니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 및 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 옵션에 대한 설명과 &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; 의 &lt;code&gt;--track&lt;/code&gt; 옵션에 대한 설명을 참조하십시오. 이 기본값을 제어하십시오.</target>
        </trans-unit>
        <trans-unit id="415ceff2cb011b2c5375c0d469dab2cba200eaed" translate="yes" xml:space="preserve">
          <source>More generally, among the two commits to compute the merge base from, one is specified by the first commit argument on the command line; the other commit is a (possibly hypothetical) commit that is a merge across all the remaining commits on the command line.</source>
          <target state="translated">보다 일반적으로, 병합 기반을 계산하는 두 커밋 중 하나는 명령 행의 첫 번째 커밋 인수에 의해 지정됩니다. 다른 커밋은 명령 줄의 나머지 모든 커밋에 대한 병합 인 (아마도 가상적인) 커밋입니다.</target>
        </trans-unit>
        <trans-unit id="816cda5b46035bd1542e1775969151ec4a09cada" translate="yes" xml:space="preserve">
          <source>More importantly, it allows the update of a ref file to follow these symbolic pointers, whether they are symlinks or these &quot;regular file symbolic refs&quot;. It follows &lt;strong&gt;real&lt;/strong&gt; symlinks only if they start with &quot;refs/&quot;: otherwise it will just try to read them and update them as a regular file (i.e. it will allow the filesystem to follow them, but will overwrite such a symlink to somewhere else with a regular filename).</source>
          <target state="translated">더 중요한 것은 심볼 파일이 심볼릭 링크이든 &quot;일반 파일 심볼 레퍼런스&quot;이든 관계없이 ref 파일의 업데이트가 이러한 심볼릭 포인터를 따를 수 있다는 것입니다. &quot;refs /&quot;로 시작하는 경우에만 &lt;strong&gt;실제&lt;/strong&gt; 심볼릭 링크를 따릅니다 . 그렇지 않으면 파일을 읽고 일반 파일로 업데이트합니다 (예 : 파일 시스템이 파일 시스템을 따를 수 있도록 허용하지만 이러한 심볼릭 링크를 다른 곳으로 덮어 쓰기) 일반 파일 이름).</target>
        </trans-unit>
        <trans-unit id="2be26ffe68463b96abc5601cef9bdbafbf2f631d" translate="yes" xml:space="preserve">
          <source>More interestingly, you can also give &lt;code&gt;git diff-tree&lt;/code&gt; the &lt;code&gt;--pretty&lt;/code&gt; flag, which tells it to also show the commit message and author and date of the commit, and you can tell it to show a whole series of diffs. Alternatively, you can tell it to be &quot;silent&quot;, and not show the diffs at all, but just show the actual commit message.</source>
          <target state="translated">더 흥미롭게도, &lt;code&gt;git diff-tree&lt;/code&gt; 에 &lt;code&gt;--pretty&lt;/code&gt; 플래그를 지정하면 커밋 메시지와 커밋의 작성자 및 날짜를 ​​표시하고 전체 diff를 표시하도록 지시 할 수 있습니다. 또는 &quot;자동&quot;이라고 말하고 diff를 전혀 표시하지 않고 실제 커밋 메시지 만 표시하면됩니다.</target>
        </trans-unit>
        <trans-unit id="854ef0fd2eba012b7c2e6ecb33388db153e60f9a" translate="yes" xml:space="preserve">
          <source>More on recovery from repository corruption. See: &lt;a href=&quot;https://lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/&quot;&gt;https://lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/&lt;/a&gt;&lt;a href=&quot;https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@woody.linux-foundation.org/&quot;&gt;https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@woody.linux-foundation.org/&lt;/a&gt;</source>
          <target state="translated">저장소 손상 복구에 대한 추가 정보. 참조 : &lt;a href=&quot;https://lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/&quot;&gt;https://lore.kernel.org/git/Pine.LNX.4.64.0702272039540.12485@woody.linux-foundation.org/ &lt;/a&gt;&lt;a href=&quot;https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@woody.linux-foundation.org/&quot;&gt;https://lore.kernel.org/git/Pine.LNX.4.64.0702141033400.3604@ woody.linux-foundation.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1784c94f3b7a373b03c0ae45229574de43eee20" translate="yes" xml:space="preserve">
          <source>More precisely, &lt;code&gt;git pull&lt;/code&gt; runs &lt;code&gt;git fetch&lt;/code&gt; with the given parameters and calls &lt;code&gt;git merge&lt;/code&gt; to merge the retrieved branch heads into the current branch. With &lt;code&gt;--rebase&lt;/code&gt;, it runs &lt;code&gt;git rebase&lt;/code&gt; instead of &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">보다 정확하게는 &lt;code&gt;git pull&lt;/code&gt; 은 주어진 매개 변수로 &lt;code&gt;git fetch&lt;/code&gt; 를 실행 하고 &lt;code&gt;git merge&lt;/code&gt; 를 호출 하여 검색 된 분기 헤드를 현재 분기로 병합합니다. &lt;code&gt;--rebase&lt;/code&gt; 를 사용하면 &lt;code&gt;git merge&lt;/code&gt; 대신 &lt;code&gt;git rebase&lt;/code&gt; 를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="17f51f170751975b2cc4764665c6e712fb67447f" translate="yes" xml:space="preserve">
          <source>Most CVS command arguments that read CVS tags or revision numbers (typically -r) work, and also support any git refspec (tag, branch, commit ID, etc). However, CVS revision numbers for non-default branches are not well emulated, and cvs log does not show tags or branches at all. (Non-main-branch CVS revision numbers superficially resemble CVS revision numbers, but they actually encode a git commit ID directly, rather than represent the number of revisions since the branch point.)</source>
          <target state="translated">CVS 태그 또는 개정 번호 (일반적으로 -r)를 읽는 대부분의 CVS 명령 인수는 작동하며 모든 git refspec (태그, 분기, 커밋 ID 등)도 지원합니다. 그러나 기본이 아닌 분기에 대한 CVS 개정 번호는 제대로 에뮬레이션되지 않으며 cvs 로그에는 태그 또는 분기가 전혀 표시되지 않습니다. (메인 브랜치가 아닌 CVS 개정 번호는 피상적으로 CVS 개정 번호와 비슷하지만 실제로 지점 지점 이후의 개정 수를 나타 내기보다는 git commit ID를 직접 인코딩합니다.)</target>
        </trans-unit>
        <trans-unit id="880f481ef12ec663b5ff4186eb50766022add75f" translate="yes" xml:space="preserve">
          <source>Most bottlenecks appear to be in foreign source data access (the source just cannot extract revisions fast enough) or disk IO (fast-import writes as fast as the disk will take the data). Imports will run faster if the source data is stored on a different drive than the destination Git repository (due to less IO contention).</source>
          <target state="translated">대부분의 병목 현상은 외부 소스 데이터 액세스 (소스는 수정본을 충분히 빨리 추출 할 수 없음) 또는 디스크 IO (디스크가 데이터를 가져 오는만큼 빠른 가져 오기 쓰기)에있는 것으로 보입니다. 소스 데이터가 대상 Git 저장소와 다른 드라이브에 저장된 경우 (IO 경합이 적기 때문에) 가져 오기가 더 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b1a743b45e6efbd5b49b8c3c8d73ad9b477276e1" translate="yes" xml:space="preserve">
          <source>Most commits have only one parent, but it is also common for a commit to have multiple parents. In that case the commit represents a merge, with the parent references pointing to the heads of the merged branches.</source>
          <target state="translated">대부분의 커밋에는 부모가 하나 뿐이지 만 커밋이 여러 부모를 갖는 것도 일반적입니다. 이 경우 커밋은 병합을 나타내며 부모 참조는 병합 된 분기의 머리를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="6e0466db6c595523512aab889a71c0ecc693c19a" translate="yes" xml:space="preserve">
          <source>Most hosting providers use a single SSH account for pushing; that is, all users push to the &lt;code&gt;git&lt;/code&gt; account (e.g., &lt;code&gt;git@git.example.org&lt;/code&gt;). If that&amp;rsquo;s the case for your provider, you can set up multiple aliases in SSH to make it clear which key pair to use. For example, you could write something like the following in &lt;code&gt;~/.ssh/config&lt;/code&gt;, substituting the proper private key file:</source>
          <target state="translated">대부분의 호스팅 제공 업체는 푸시를 위해 단일 SSH 계정을 사용합니다. 즉, 모든 사용자가 &lt;code&gt;git&lt;/code&gt; 계정 (예 : &lt;code&gt;git@git.example.org&lt;/code&gt; )으로 푸시합니다 . 제공 업체의 경우라면 SSH에서 여러 별칭을 설정하여 사용할 키 쌍을 명확하게 할 수 있습니다. 예를 들어 &lt;code&gt;~/.ssh/config&lt;/code&gt; 에 다음과 같이 작성 하여 적절한 개인 키 파일을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d50eced4caaa6d0cca3ee6a1e2e2e07d0d5849b" translate="yes" xml:space="preserve">
          <source>Most importantly, merging works at the branch level, while cherry-picking works at the commit level. This means that a merge can carry over the changes from 1, 10, or 1000 commits with equal ease, which in turn means the workflow scales much better to a large number of contributors (and contributions). Merges are also easier to understand because a merge commit is a &quot;promise&quot; that all changes from all its parents are now included.</source>
          <target state="translated">가장 중요한 것은 병합은 지점 수준에서 작동하지만 체리 피킹은 커밋 수준에서 작동합니다. 이는 병합이 1, 10 또는 1000 커밋의 변경 사항을 똑같이 쉽게 처리 할 수 ​​있음을 의미하며, 이는 워크 플로가 많은 기여자 (및 기여)로 훨씬 더 잘 확장됨을 의미합니다. 병합 커밋은 이제 모든 부모의 모든 변경 사항이 포함 된 &quot;약속&quot;이므로 병합도 이해하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="2e130c2e2dd2a16594642aa625e1fc3c4df26608" translate="yes" xml:space="preserve">
          <source>Most of features are configured via &lt;code&gt;%feature&lt;/code&gt; hash; however some of extra gitweb features can be turned on and configured using variables described below. This list beside configuration variables that control how gitweb looks does contain variables configuring administrative side of gitweb (e.g. cross-site scripting prevention; admittedly this as side effect affects how &quot;summary&quot; pages look like, or load limiting).</source>
          <target state="translated">대부분의 기능은 &lt;code&gt;%feature&lt;/code&gt; 해시 를 통해 구성됩니다 . 그러나 추가 gitweb 기능 중 일부는 아래 설명 된 변수를 사용하여 설정하고 구성 할 수 있습니다. gitweb의 모양을 제어하는 ​​구성 변수 옆의이 목록에는 gitweb의 관리 측면을 구성하는 변수가 포함되어 있습니다 (예 : 사이트 간 스크립팅 방지, 부작용으로 &quot;요약&quot;페이지의 모양 또는로드 제한에 영향을 미침).</target>
        </trans-unit>
        <trans-unit id="12c479c9b5f1b05779ca1427f8469c4d0c8e41b4" translate="yes" xml:space="preserve">
          <source>Most of what &lt;code&gt;git rev-list&lt;/code&gt; did is contained in &lt;code&gt;revision.c&lt;/code&gt; and &lt;code&gt;revision.h&lt;/code&gt;. It wraps the options in a struct named &lt;code&gt;rev_info&lt;/code&gt;, which controls how and what revisions are walked, and more.</source>
          <target state="translated">무엇 대부분의 &lt;code&gt;git rev-list&lt;/code&gt; 에 포함 않았다 &lt;code&gt;revision.c&lt;/code&gt; 및 &lt;code&gt;revision.h&lt;/code&gt; . &lt;code&gt;rev_info&lt;/code&gt; 라는 구조체의 옵션을 래핑하여 걷는 방법과 수정 방법 등을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="9ceb817bd0e340cfd6e3a665612ec974c7873cd6" translate="yes" xml:space="preserve">
          <source>Most operations that add an object to the database update the modification time of the object if it is already present so that #1 applies.</source>
          <target state="translated">데이터베이스에 객체를 추가하는 대부분의 작업은 객체가 이미 존재하는 경우 # 1이 적용되도록 객체의 수정 시간을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="ed4a3f36c4746567049b5d83d49f91438e7cd1fa" translate="yes" xml:space="preserve">
          <source>Most projects also use &lt;a href=&quot;#def_tag&quot;&gt;tags&lt;/a&gt;. Tags, like heads, are references into the project&amp;rsquo;s history, and can be listed using the &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; command:</source>
          <target state="translated">대부분의 프로젝트는 &lt;a href=&quot;#def_tag&quot;&gt;태그&lt;/a&gt; 도 사용 합니다 . 헤드와 같이 태그는 프로젝트 히스토리에 대한 참조이며 &lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt; 명령을 사용하여 나열 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e9a1bc6364ad2c889e7f09c69628c8251c67662" translate="yes" xml:space="preserve">
          <source>Most projects with multiple contributors (such as the Linux kernel, or Git itself) have frequent merges, and &lt;code&gt;gitk&lt;/code&gt; does a better job of visualizing their history. For example,</source>
          <target state="translated">Linux 커널 또는 Git 자체와 같이 여러 제공자가있는 대부분의 프로젝트는 자주 병합되며 &lt;code&gt;gitk&lt;/code&gt; 는 히스토리를 더 잘 시각화합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="b110af03cd46bd74e1684a2cb53fb12fe52de561" translate="yes" xml:space="preserve">
          <source>Mostly a synonym to &lt;a href=&quot;#def_shallow_repository&quot;&gt;shallow repository&lt;/a&gt; but the phrase makes it more explicit that it was created by running &lt;code&gt;git clone --depth=&amp;hellip;​&lt;/code&gt; command.</source>
          <target state="translated">대부분에 동의어 &lt;a href=&quot;#def_shallow_repository&quot;&gt;얕은 저장소&lt;/a&gt; 하지만 구문이 실행에 의해 만들어진 좀 더 명시적인 것을 만들어 &lt;code&gt;git clone --depth=&amp;hellip;​&lt;/code&gt; 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0a0252ca3dca0dd6561eccb6a1ba0495bf433801" translate="yes" xml:space="preserve">
          <source>Mostly a synonym to &lt;a href=&quot;#def_shallow_repository&quot;&gt;shallow repository&lt;/a&gt; but the phrase makes it more explicit that it was created by running &lt;code&gt;git clone --depth=...&lt;/code&gt; command.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#def_shallow_repository&quot;&gt;얕은 저장소&lt;/a&gt; 와 동의어 이지만 문구는 &lt;code&gt;git clone --depth=...&lt;/code&gt; 명령 을 실행하여 생성되었다는 것을 더 명확하게 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="3a5117e8beb61f9ec394ef9854333d01751bcf99" translate="yes" xml:space="preserve">
          <source>Mounting one repository inside another</source>
          <target state="translated">한 저장소를 다른 저장소에 마운트</target>
        </trans-unit>
        <trans-unit id="9dfd3ade6b1a6694324bf4f4adc30f26dd2cc430" translate="yes" xml:space="preserve">
          <source>Move a working tree to a new location. Note that the main working tree or linked working trees containing submodules cannot be moved with this command. (The &lt;code&gt;git worktree repair&lt;/code&gt; command, however, can reestablish the connection with linked working trees if you move the main working tree manually.)</source>
          <target state="translated">작업 트리를 새 위치로 이동합니다. 주 작업 트리 또는 하위 모듈을 포함하는 링크 된 작업 트리는이 명령으로 이동할 수 없습니다. (그러나 &lt;code&gt;git worktree repair&lt;/code&gt; 명령은 주 작업 트리를 수동으로 이동하면 연결된 작업 트리와의 연결을 다시 설정할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="437db9b7f03fcf9c59c19e8599b81a4181786550" translate="yes" xml:space="preserve">
          <source>Move a working tree to a new location. Note that the main working tree or linked working trees containing submodules cannot be moved.</source>
          <target state="translated">작업 트리를 새 위치로 이동하십시오. 하위 작업 모듈을 포함하는 기본 작업 트리 또는 연결된 작업 트리는 이동할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="00451deb449902283a1a1b09ee616f563047050b" translate="yes" xml:space="preserve">
          <source>Move objects and refs by archive</source>
          <target state="translated">아카이브별로 객체 및 참조 이동</target>
        </trans-unit>
        <trans-unit id="0a2aa584391bc2ed097c1ace071233493faa0978" translate="yes" xml:space="preserve">
          <source>Move or rename a file, a directory, or a symlink</source>
          <target state="translated">파일, 디렉토리 또는 심볼릭 링크 이동 또는 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="4bc0abe3ae87a3007e76abb67d150957939b61b8" translate="yes" xml:space="preserve">
          <source>Move or rename a file, directory or symlink.</source>
          <target state="translated">파일, 디렉토리 또는 심볼릭 링크를 이동하거나 이름을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="24cb8f062e449dc4167b50460e2e7341fe4e0aa6" translate="yes" xml:space="preserve">
          <source>Move/rename a branch and the corresponding reflog.</source>
          <target state="translated">분기 및 해당 참조 로그를 이동 / 이름 바꾸기하십시오.</target>
        </trans-unit>
        <trans-unit id="86a2fcc8fa8d4ad8c3c46b9d3e5182feb14f1b60" translate="yes" xml:space="preserve">
          <source>Moved lines are not highlighted.</source>
          <target state="translated">이동 한 줄은 강조 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e5cbd47a10df638d21a9258d79ed6bd371f01027" translate="yes" xml:space="preserve">
          <source>Moved lines of code are colored differently. It can be changed by the &lt;code&gt;diff.colorMoved&lt;/code&gt; configuration setting. The &amp;lt;mode&amp;gt; defaults to &lt;code&gt;no&lt;/code&gt; if the option is not given and to &lt;code&gt;zebra&lt;/code&gt; if the option with no mode is given. The mode must be one of:</source>
          <target state="translated">이동 한 코드 줄은 다르게 색상이 지정됩니다. &lt;code&gt;diff.colorMoved&lt;/code&gt; 구성 설정 으로 변경할 수 있습니다 . 옵션이 제공되지 않으면 &amp;lt;mode&amp;gt;는 기본적으로 &lt;code&gt;no&lt;/code&gt; 로 설정되고 모드 가없는 옵션이 제공 되면 &lt;code&gt;zebra&lt;/code&gt; 로 설정 됩니다. 모드는 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="b99084289befcccb3b6f25bb5a902159aaa2283b" translate="yes" xml:space="preserve">
          <source>Moved lines of code are colored differently. The &amp;lt;mode&amp;gt; defaults to &lt;code&gt;no&lt;/code&gt; if the option is not given and to &lt;code&gt;zebra&lt;/code&gt; if the option with no mode is given. The mode must be one of:</source>
          <target state="translated">이동 한 코드 줄은 다르게 색상이 지정됩니다. 옵션이 제공되지 않으면 &amp;lt;mode&amp;gt;는 기본적으로 &lt;code&gt;no&lt;/code&gt; 로 설정되고 모드 가없는 옵션이 제공 되면 &lt;code&gt;zebra&lt;/code&gt; 로 설정 됩니다. 모드는 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="b9c1e9c13eb039f68657e5a15bbd12085ba143c2" translate="yes" xml:space="preserve">
          <source>Moving a submodule using a gitfile (which means they were cloned with a Git version 1.7.8 or newer) will update the gitfile and core.worktree setting to make the submodule work in the new location. It also will attempt to update the submodule.&amp;lt;name&amp;gt;.path setting in the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file and stage that file (unless -n is used).</source>
          <target state="translated">gitfile을 사용하여 하위 모듈을 이동하면 (즉, Git 버전 1.7.8 이상으로 복제되었음을 의미) 하위 모듈이 새 위치에서 작동하도록 gitfile 및 core.worktree 설정이 업데이트됩니다. 또한 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 파일 에서 submodule. &amp;lt;name&amp;gt; .path 설정을 업데이트하고 해당 파일을 스테이징합니다 (-n을 사용하지 않는 경우).</target>
        </trans-unit>
        <trans-unit id="64f4589d8b3cd6346365a117e7caa3c7d877c770" translate="yes" xml:space="preserve">
          <source>Mua-specific hints</source>
          <target state="translated">Mua 관련 힌트</target>
        </trans-unit>
        <trans-unit id="c811c6583f834ffbc46d39586b81b1cb3e49b3e5" translate="yes" xml:space="preserve">
          <source>Multi-pack-index (midx) files have the following format:</source>
          <target state="translated">멀티 팩 인덱스 (midx) 파일의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="53148ea4bd03c54715064a8f67e0cc8cc140f85c" translate="yes" xml:space="preserve">
          <source>Multiple --notes options can be combined to control which notes are being displayed. Examples: &quot;--notes=foo&quot; will show only notes from &quot;refs/notes/foo&quot;; &quot;--notes=foo --notes&quot; will show both notes from &quot;refs/notes/foo&quot; and from the default notes ref(s).</source>
          <target state="translated">여러 노트 옵션을 결합하여 표시되는 노트를 제어 할 수 있습니다. 예 : &quot;--notes = foo&quot;는 &quot;refs / notes / foo&quot;의 노트 만 표시합니다. &quot;--notes = foo --notes&quot;는 &quot;refs / notes / foo&quot;및 기본 메모 ref (s)의 메모를 모두 표시합니다.</target>
        </trans-unit>
        <trans-unit id="63667e9cd419f9751274dd2f16bda1512b373262" translate="yes" xml:space="preserve">
          <source>Multiple &lt;code&gt;--filter=&lt;/code&gt; flags can be specified to combine filters. Only objects which are accepted by every filter are included.</source>
          <target state="translated">필터를 결합하기 위해 여러 &lt;code&gt;--filter=&lt;/code&gt; 플래그를 지정할 수 있습니다. 모든 필터에서 허용되는 객체 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="dc96f8ef1ccc109ff4dae28503fa1d96c62fb1de" translate="yes" xml:space="preserve">
          <source>Multiple checkout in general is still experimental, and the support for submodules is incomplete. It is NOT recommended to make multiple checkouts of a superproject.</source>
          <target state="translated">일반적으로 다중 체크 아웃은 아직 실험 중이며 하위 모듈에 대한 지원이 불완전합니다. 수퍼 프로젝트를 여러 번 체크 아웃하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5a07b93df04fb253e2e899a192e36f3454a882cd" translate="yes" xml:space="preserve">
          <source>Multiple fetch, branches, and tags keys are supported:</source>
          <target state="translated">여러 페치, 분기 및 태그 키가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="279d7da4653c2486ef148e9e285812a9ab391b1e" translate="yes" xml:space="preserve">
          <source>Multiple lines can be added to an option by using the &lt;code&gt;--add&lt;/code&gt; option. If you want to update or unset an option which can occur on multiple lines, a &lt;code&gt;value-pattern&lt;/code&gt; (which is an extended regular expression, unless the &lt;code&gt;--fixed-value&lt;/code&gt; option is given) needs to be given. Only the existing values that match the pattern are updated or unset. If you want to handle the lines that do &lt;strong&gt;not&lt;/strong&gt; match the pattern, just prepend a single exclamation mark in front (see also &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt;), but note that this only works when the &lt;code&gt;--fixed-value&lt;/code&gt; option is not in use.</source>
          <target state="translated">&lt;code&gt;--add&lt;/code&gt; 옵션 을 사용하여 옵션에 여러 줄을 추가 할 수 있습니다 . 여러 행에서 발생할 수있는 옵션을 업데이트하거나 설정 해제하려면 &lt;code&gt;value-pattern&lt;/code&gt; ( &lt;code&gt;--fixed-value&lt;/code&gt; 옵션이 제공 되지 않는 한 확장 정규식 )이 제공되어야합니다. 패턴과 일치하는 기존 값만 업데이트되거나 설정 해제됩니다. 패턴과 일치 하지 &lt;strong&gt;않는&lt;/strong&gt; 줄을 처리하려면 앞에 느낌표를 하나만 추가하세요 ( &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; 참조 ).하지만 &lt;code&gt;--fixed-value&lt;/code&gt; 옵션을 사용하지 않을 때만 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="b46275ca6ba0af124488d22d1e877279bfe2e6c0" translate="yes" xml:space="preserve">
          <source>Multiple lines can be added to an option by using the &lt;code&gt;--add&lt;/code&gt; option. If you want to update or unset an option which can occur on multiple lines, a POSIX regexp &lt;code&gt;value_regex&lt;/code&gt; needs to be given. Only the existing values that match the regexp are updated or unset. If you want to handle the lines that do &lt;strong&gt;not&lt;/strong&gt; match the regex, just prepend a single exclamation mark in front (see also &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;--add&lt;/code&gt; 옵션 을 사용하여 옵션에 여러 줄을 추가 할 수 있습니다 . 여러 줄에서 발생할 수있는 옵션을 업데이트하거나 설정 해제하려면 POSIX regexp &lt;code&gt;value_regex&lt;/code&gt; 를 지정 해야합니다. 정규 표현식과 일치하는 기존 값만 업데이트되거나 설정 해제됩니다. 정규식과 일치 하지 &lt;strong&gt;않는&lt;/strong&gt; 행을 처리하려면 앞에 느낌표를 하나 추가하십시오 ( &lt;a href=&quot;#EXAMPLES&quot;&gt;예제&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="77c43675935243a813626f8da7cb046544167112" translate="yes" xml:space="preserve">
          <source>Multiple tags on the same revision are not imported.</source>
          <target state="translated">동일한 개정판의 여러 태그를 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f2beb5df6d3d8f2a372e3411ba76c2a81700ed4b" translate="yes" xml:space="preserve">
          <source>Multiple values may be given to the &lt;code&gt;man.viewer&lt;/code&gt; configuration variable. Their corresponding programs will be tried in the order listed in the configuration file.</source>
          <target state="translated">&lt;code&gt;man.viewer&lt;/code&gt; 구성 변수 에는 여러 값이 제공 될 수 있습니다 . 해당 프로그램은 구성 파일에 나열된 순서대로 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="ee6ae3f9558f190018d900b972ec0dd86c3ef0ee" translate="yes" xml:space="preserve">
          <source>Munging the diff output</source>
          <target state="translated">diff 출력 조정</target>
        </trans-unit>
        <trans-unit id="31284f7dc1d9489b6ba33462518d05bce29455ee" translate="yes" xml:space="preserve">
          <source>Must be a blob id</source>
          <target state="translated">BLOB ID 여야합니다</target>
        </trans-unit>
        <trans-unit id="bab4c6d734b3b13c2268e7fc81c79c9b99eef1dd" translate="yes" xml:space="preserve">
          <source>NORMAL Format</source>
          <target state="translated">일반 형식</target>
        </trans-unit>
        <trans-unit id="4b5d099fcd6efcc01a4251de7ab2ddb7c47dd96b" translate="yes" xml:space="preserve">
          <source>NOTE! &lt;code&gt;git checkout-index&lt;/code&gt; normally refuses to overwrite old files, so if you have an old version of the tree already checked out, you will need to use the &lt;code&gt;-f&lt;/code&gt; flag ('before' the &lt;code&gt;-a&lt;/code&gt; flag or the filename) to 'force' the checkout.</source>
          <target state="translated">노트! &lt;code&gt;git checkout-index&lt;/code&gt; 는 일반적으로 오래된 파일을 덮어 쓰지 않기 때문에 이미 체크 아웃 된 트리 버전이있는 경우 &lt;code&gt;-f&lt;/code&gt; 플래그 ( ' &lt;code&gt;-a&lt;/code&gt; 플래그 또는 파일 이름 앞' )를 'force' 로 사용해야합니다. 결제.</target>
        </trans-unit>
        <trans-unit id="85ffa1dd083241144d9fbe2b1d63ba53159cc3e5" translate="yes" xml:space="preserve">
          <source>NOTE! &lt;code&gt;git checkout-index&lt;/code&gt; normally refuses to overwrite old files, so if you have an old version of the tree already checked out, you will need to use the &lt;code&gt;-f&lt;/code&gt; flag (&lt;code&gt;before&lt;/code&gt; the &lt;code&gt;-a&lt;/code&gt; flag or the filename) to &lt;code&gt;force&lt;/code&gt; the checkout.</source>
          <target state="translated">노트! &lt;code&gt;git checkout-index&lt;/code&gt; 일반적으로 당신이 나무 이미 체크 아웃의 이전 버전이 그렇다면, 이전 파일을 덮어 쓰기를 거부, 당신은 사용해야합니다 &lt;code&gt;-f&lt;/code&gt; (플래그를 &lt;code&gt;before&lt;/code&gt; &lt;code&gt;-a&lt;/code&gt; 하는 플래그 또는 파일 이름) &lt;code&gt;force&lt;/code&gt; 체크 아웃을.</target>
        </trans-unit>
        <trans-unit id="1264e842b1d5e884b1bcd9c56e546555c80966fe" translate="yes" xml:space="preserve">
          <source>NOTE! A &lt;code&gt;--remove&lt;/code&gt; flag does 'not' mean that subsequent filenames will necessarily be removed: if the files still exist in your directory structure, the index will be updated with their new status, not removed. The only thing &lt;code&gt;--remove&lt;/code&gt; means is that update-index will be considering a removed file to be a valid thing, and if the file really does not exist any more, it will update the index accordingly.</source>
          <target state="translated">노트! &lt;code&gt;--remove&lt;/code&gt; 플래그는 '하지'않는 이후의 파일 이름은 반드시 제거 될 것을 의미 : 파일이 여전히 디렉토리 구조에 존재하는 경우, 인덱스가되지 제거 그들의 새로운 상태로 업데이트됩니다. 유일한 &lt;code&gt;--remove&lt;/code&gt; 는 update-index가 제거 된 파일을 유효한 것으로 간주하고 파일이 더 이상 존재하지 않으면 그에 따라 인덱스를 업데이트한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="14b973ba3566912be86ce74a38691b683bb1cd64" translate="yes" xml:space="preserve">
          <source>NOTE! A &lt;code&gt;--remove&lt;/code&gt; flag does &lt;code&gt;not&lt;/code&gt; mean that subsequent filenames will necessarily be removed: if the files still exist in your directory structure, the index will be updated with their new status, not removed. The only thing &lt;code&gt;--remove&lt;/code&gt; means is that update-index will be considering a removed file to be a valid thing, and if the file really does not exist any more, it will update the index accordingly.</source>
          <target state="translated">노트! &lt;code&gt;--remove&lt;/code&gt; 플래그는 않습니다 &lt;code&gt;not&lt;/code&gt; 파일이 여전히 디렉토리 구조에 존재하는 경우, 인덱스가 제거되지 않은 새로운 상태로 업데이트됩니다 이후의 파일 이름은 반드시 제거됩니다 것을 의미한다. 유일한 &lt;code&gt;--remove&lt;/code&gt; 수단이 업데이트되는 인덱스가 유효한 일이 될 수있는 제거 된 파일을 고려한다, 그리고 파일이 정말 더 이상 존재하지 않는 경우, 그에 따라 인덱스를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="cab1b18ac6c645752b07db74b58a821d43db7033" translate="yes" xml:space="preserve">
          <source>Name for the new branch.</source>
          <target state="translated">새 지점의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ae3aefe579fe0e7749a842bc31610ab7a07dfe4c" translate="yes" xml:space="preserve">
          <source>Name of a HTML file which, if it exists, is included on the gitweb projects overview page (&quot;projects_list&quot; view). Relative to the directory containing the gitweb.cgi script. Default value can be adjusted during build time using &lt;code&gt;GITWEB_HOMETEXT&lt;/code&gt; variable. By default set to &lt;code&gt;indextext.html&lt;/code&gt;.</source>
          <target state="translated">존재하는 경우 gitweb 프로젝트 개요 페이지 ( &quot;projects_list&quot;보기)에 포함 된 HTML 파일의 이름입니다. gitweb.cgi 스크립트가 포함 된 디렉토리와 관련이 있습니다. 빌드 시간 동안 &lt;code&gt;GITWEB_HOMETEXT&lt;/code&gt; 변수를 사용하여 기본값을 조정할 수 있습니다 . 기본적으로 &lt;code&gt;indextext.html&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b26ce2bab88403572eb261078ddb7db93d3d704e" translate="yes" xml:space="preserve">
          <source>Name of a file with HTML to be included at the bottom of each page. Relative to the directory containing the &lt;code&gt;gitweb.cgi&lt;/code&gt; script. Can be set using &lt;code&gt;GITWEB_SITE_FOOTER&lt;/code&gt; at build time. No default value.</source>
          <target state="translated">각 페이지 하단에 HTML이 포함 된 파일 이름입니다. &lt;code&gt;gitweb.cgi&lt;/code&gt; 스크립트가 포함 된 디렉토리와 관련이 있습니다. 빌드시 &lt;code&gt;GITWEB_SITE_FOOTER&lt;/code&gt; 를 사용하여 설정할 수 있습니다 . 기본값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb37057e9d095a173db9c241ef8419b86a202d02" translate="yes" xml:space="preserve">
          <source>Name of a file with HTML to be included at the top of each page. Relative to the directory containing the &lt;code&gt;gitweb.cgi&lt;/code&gt; script. Can be set using &lt;code&gt;GITWEB_SITE_HEADER&lt;/code&gt; at build time. No default value.</source>
          <target state="translated">각 페이지 상단에 HTML이 포함 된 파일의 이름입니다. &lt;code&gt;gitweb.cgi&lt;/code&gt; 스크립트가 포함 된 디렉토리와 관련이 있습니다. 빌드시 &lt;code&gt;GITWEB_SITE_HEADER&lt;/code&gt; 를 사용하여 설정할 수 있습니다 . 기본값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="389075bf1328d95e30f257d38d278dd3a0c94121" translate="yes" xml:space="preserve">
          <source>Name of a plain text file listing projects, or a name of directory to be scanned for projects.</source>
          <target state="translated">프로젝트를 나열하는 일반 텍스트 파일 이름 또는 프로젝트를 스캔 할 디렉토리 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c0afa4635407444ed041e335278cc30cd2a11b14" translate="yes" xml:space="preserve">
          <source>Name of the SSL backend to use (e.g. &quot;openssl&quot; or &quot;schannel&quot;). This option is ignored if cURL lacks support for choosing the SSL backend at runtime.</source>
          <target state="translated">사용할 SSL 백엔드의 이름 (예 : &quot;openssl&quot;또는 &quot;schannel&quot;) cURL에 런타임시 SSL 백엔드 선택에 대한 지원이없는 경우이 옵션은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4d338fcbbcef71a5bde9a77e37abcbca835f1d4a" translate="yes" xml:space="preserve">
          <source>Name of the user running &lt;code&gt;git-cvsserver&lt;/code&gt;. If no name can be determined, the numeric uid is used.</source>
          <target state="translated">&lt;code&gt;git-cvsserver&lt;/code&gt; 를 실행하는 사용자의 이름입니다 . 이름을 확인할 수 없으면 숫자 uid가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="33a3a9f4baab999f10555d77c61fc17ad7a2e690" translate="yes" xml:space="preserve">
          <source>Name of your site or organization, to appear in page titles. Set it to something descriptive for clearer bookmarks etc. If this variable is not set or is, then gitweb uses the value of the &lt;code&gt;SERVER_NAME&lt;/code&gt;&lt;code&gt;CGI&lt;/code&gt; environment variable, setting site name to &quot;$SERVER_NAME Git&quot;, or &quot;Untitled Git&quot; if this variable is not set (e.g. if running gitweb as standalone script).</source>
          <target state="translated">페이지 제목에 표시 할 사이트 또는 조직의 이름입니다. 이 변수를 설정하지 않았거나 설정하지 않은 경우 gitweb은 &lt;code&gt;SERVER_NAME&lt;/code&gt; &lt;code&gt;CGI&lt;/code&gt; 환경 변수 의 값을 사용하여 사이트 이름을 &quot;$ SERVER_NAME Git&quot;또는이 변수가 &quot;Untitled Git&quot;인 경우 &quot;Untitled Git&quot;으로 설정합니다 설정되지 않음 (예 : gitweb을 독립형 스크립트로 실행하는 경우).</target>
        </trans-unit>
        <trans-unit id="ac84f0f88b7824faf06c4b53397972bcd09b01be" translate="yes" xml:space="preserve">
          <source>Name output in &lt;code&gt;[PATCH n/m]&lt;/code&gt; format, even with a single patch.</source>
          <target state="translated">단일 패치로도 &lt;code&gt;[PATCH n/m]&lt;/code&gt; 형식으로 이름 출력 .</target>
        </trans-unit>
        <trans-unit id="ffd008dca3705155e76303827e2a4d3059068c9a" translate="yes" xml:space="preserve">
          <source>Name output in &lt;code&gt;[PATCH]&lt;/code&gt; format.</source>
          <target state="translated">이름은 &lt;code&gt;[PATCH]&lt;/code&gt; 형식으로 출력 됩니다.</target>
        </trans-unit>
        <trans-unit id="fe45d9f50e3991235a5aaf79d20ba4e50638c193" translate="yes" xml:space="preserve">
          <source>Named file in &lt;code&gt;$GIT_DIR/branches&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/branches&lt;/code&gt; 에 이름이 지정된 파일</target>
        </trans-unit>
        <trans-unit id="e694d096f60594b306ed977a1cb3bf7e40731642" translate="yes" xml:space="preserve">
          <source>Named file in &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; 이름이 지정된 파일</target>
        </trans-unit>
        <trans-unit id="4d0059ee6bf7ca65460797daae6395c800b562c5" translate="yes" xml:space="preserve">
          <source>Named pointers called refs mark interesting points in history. A ref may contain the SHA-1 name of an object or the name of another ref. Refs with names beginning &lt;code&gt;ref/head/&lt;/code&gt; contain the SHA-1 name of the most recent commit (or &quot;head&quot;) of a branch under development. SHA-1 names of tags of interest are stored under &lt;code&gt;ref/tags/&lt;/code&gt;. A special ref named &lt;code&gt;HEAD&lt;/code&gt; contains the name of the currently checked-out branch.</source>
          <target state="translated">refs라는 이름의 포인터는 역사에서 흥미로운 점을 표시합니다. 심판은 개체의 SHA-1 이름이나 다른 심판의 이름을 포함 할 수 있습니다. 이름이 &lt;code&gt;ref/head/&lt;/code&gt; 시작하는 Ref 는 개발중인 브랜치의 가장 최근 커밋 (또는 &quot;head&quot;)의 SHA-1 이름을 포함합니다. 관심있는 태그의 SHA-1 이름은 &lt;code&gt;ref/tags/&lt;/code&gt; 저장됩니다 . &lt;code&gt;HEAD&lt;/code&gt; 라는 특수 참조 에는 현재 체크 아웃 된 분기의 이름이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="afc8b12ea961269025f67734b3112ac3163fa044" translate="yes" xml:space="preserve">
          <source>Named remote in configuration file</source>
          <target state="translated">구성 파일에서 명명 된 원격</target>
        </trans-unit>
        <trans-unit id="60da66dd4d339a94ae12e8c7a620ab333cdfa554" translate="yes" xml:space="preserve">
          <source>Names a low-level merge driver to be used when performing an internal merge between common ancestors. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">공통 조상간에 내부 병합을 수행 할 때 사용할 하위 수준 병합 드라이버의 이름을 지정합니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7238264e2238da432cea4cee3e4e4ec456281760" translate="yes" xml:space="preserve">
          <source>Naming branches, tags, and other references</source>
          <target state="translated">이름 지정 분기, 태그 및 기타 참조</target>
        </trans-unit>
        <trans-unit id="a8a795a40591e9038f52c089f34245ee06ab71bc" translate="yes" xml:space="preserve">
          <source>Naming commits</source>
          <target state="translated">명명 커밋</target>
        </trans-unit>
        <trans-unit id="7b635b48de06412b114cd8e91f1912aac5470b03" translate="yes" xml:space="preserve">
          <source>Nearly proper rewriting of tag objects is supported. If the tag has a message attached, a new tag object will be created with the same message, author, and timestamp. If the tag has a signature attached, the signature will be stripped. It is by definition impossible to preserve signatures. The reason this is &quot;nearly&quot; proper, is because ideally if the tag did not change (points to the same object, has the same name, etc.) it should retain any signature. That is not the case, signatures will always be removed, buyer beware. There is also no support for changing the author or timestamp (or the tag message for that matter). Tags which point to other tags will be rewritten to point to the underlying commit.</source>
          <target state="translated">태그 객체의 거의 적절한 재 작성이 지원됩니다. 태그에 메시지가 첨부되어 있으면 동일한 메시지, 작성자 및 타임 스탬프를 사용하여 새 태그 객체가 생성됩니다. 태그에 서명이 첨부되어 있으면 서명이 제거됩니다. 서명을 보존하는 것은 정의상 불가능합니다. 이것이 &quot;거의&quot;적절한 이유는 태그가 변경되지 않은 경우 (같은 객체를 가리 키거나 동일한 이름을 갖는 등) 이상적으로 서명을 유지해야하기 때문입니다. 사실은 아닙니다. 서명은 항상 제거되며 구매자는주의해야합니다. 또한 작성자 나 타임 스탬프 (또는 해당 문제에 대한 태그 메시지)를 변경할 수 없습니다. 다른 태그를 가리키는 태그는 기본 커밋을 가리 키도록 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="ec8ce921b28e9d3cf6cf20eaf08287c17f378d35" translate="yes" xml:space="preserve">
          <source>Negating options</source>
          <target state="translated">부정 옵션</target>
        </trans-unit>
        <trans-unit id="781db1e57c260d141571a81cbcc3db723749ad7f" translate="yes" xml:space="preserve">
          <source>Nevertheless, the code at C is broken, because the callers added on the lower line of development have not been converted to the new semantics introduced on the upper line of development. So if all you know is that D is bad, that Z is good, and that &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt; identifies C as the culprit, how will you figure out that the problem is due to this change in semantics?</source>
          <target state="translated">그럼에도 불구하고, 개발 라인에 추가 된 호출자가 개발 라인에 도입 된 새로운 시맨틱으로 변환되지 않았기 때문에 C의 코드가 손상되었습니다. 따라서 D가 나쁘고 Z가 좋고 &lt;a href=&quot;git-bisect&quot;&gt;git-bisect [1]가&lt;/a&gt; C를 범인으로 식별 한다는 사실 만 아는 경우, 이러한 의미의 변화로 인해 문제가 발생한다는 것을 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a6160e254f396c410b853d5ee2bc722e35ccb61c" translate="yes" xml:space="preserve">
          <source>Nevertheless, this is a common practice for people that need a simple way to publish a work-in-progress patch series, and it is an acceptable compromise as long as you warn other developers that this is how you intend to manage the branch.</source>
          <target state="translated">그럼에도 불구하고, 이는 진행중인 작업 패치 시리즈를 게시하는 간단한 방법이 필요한 사람들에게 일반적인 관행이며, 다른 개발자에게 이것이 지점 관리 방법이라고 경고하는 한 수용 가능한 타협입니다.</target>
        </trans-unit>
        <trans-unit id="208a508aabbf19798034826f77ed481ec28e90cc" translate="yes" xml:space="preserve">
          <source>New features:</source>
          <target state="translated">새로운 기능 :</target>
        </trans-unit>
        <trans-unit id="c191eda851b2a021b1ece3943d51bb10c7c6e4eb" translate="yes" xml:space="preserve">
          <source>New marks are created automatically. Existing marks can be moved to another object simply by reusing the same &lt;code&gt;&amp;lt;idnum&amp;gt;&lt;/code&gt; in another &lt;code&gt;mark&lt;/code&gt; command.</source>
          <target state="translated">새로운 마크가 자동으로 생성됩니다. 다른 &lt;code&gt;mark&lt;/code&gt; 명령 에서 동일한 &lt;code&gt;&amp;lt;idnum&amp;gt;&lt;/code&gt; 을 재사용하여 기존 마크를 다른 객체로 옮길 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34f293962e034aa3adab30d6ce7bb006c129576e" translate="yes" xml:space="preserve">
          <source>New objects written by fast-import are not available immediately. Most fast-import commands have no visible effect until the next checkpoint (or completion). The frontend can send commands to fill fast-import&amp;rsquo;s input pipe without worrying about how quickly they will take effect, which improves performance by simplifying scheduling.</source>
          <target state="translated">빠른 가져 오기로 작성된 새 개체는 즉시 사용할 수 없습니다. 대부분의 빠른 가져 오기 명령은 다음 검사 점 (또는 완료)까지 눈에 띄는 효과가 없습니다. 프론트 엔드는 명령이 전송되는 데 걸리는 시간에 대한 걱정없이 빠른 가져 오기의 입력 파이프를 채우도록 명령을 보낼 수 있으며, 이는 스케줄링을 단순화하여 성능을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="bd5d84635e8045ac3e97cdc31b8e7c57fb2006ba" translate="yes" xml:space="preserve">
          <source>New remote-tracking branches will be stored under the shorthand name that you gave &lt;code&gt;git remote add&lt;/code&gt;, in this case &lt;code&gt;staging&lt;/code&gt;:</source>
          <target state="translated">새로운 원격 추적 브랜치는 &lt;code&gt;git remote add&lt;/code&gt; 으로 지정한 축약 이름으로 저장됩니다 ( 이 경우 &lt;code&gt;staging&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="408210d4e2e7bc9a95a98e6b1bf8a3bd1ff14459" translate="yes" xml:space="preserve">
          <source>New users are encouraged to use &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; instead. The &lt;code&gt;whatchanged&lt;/code&gt; command is essentially the same as &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; but defaults to show the raw format diff output and to skip merges.</source>
          <target state="translated">새로운 사용자는 대신 &lt;a href=&quot;git-log&quot;&gt;git-log [1]를&lt;/a&gt; 사용하는 것이 좋습니다. &lt;code&gt;whatchanged&lt;/code&gt; 명령은 본질적으로 동일하다 &lt;a href=&quot;git-log&quot;&gt;자식 로그 [1]&lt;/a&gt; RAW 형식 DIFF 출력을 표시하고 병합 건너하지만 기본적.</target>
        </trans-unit>
        <trans-unit id="04e09d741912def77b41c31c7fd7bada0af8f8f2" translate="yes" xml:space="preserve">
          <source>Newer &lt;code&gt;git diff&lt;/code&gt; output has embedded &lt;code&gt;index information&lt;/code&gt; for each blob to help identify the original version that the patch applies to. When this flag is given, and if the original versions of the blobs are available locally, builds a temporary index containing those blobs.</source>
          <target state="translated">최신 &lt;code&gt;git diff&lt;/code&gt; 출력에는 패치가 적용되는 원래 버전을 식별하는 데 도움이되도록 각 Blob에 대한 &lt;code&gt;index information&lt;/code&gt; 가 포함 되어 있습니다. 이 플래그가 제공되고 원래 버전의 Blob을 로컬에서 사용할 수있는 경우 해당 Blob을 포함하는 임시 인덱스를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="7f94af506f4cd517718453425d685ea35e84d4c7" translate="yes" xml:space="preserve">
          <source>Newly created objects are initially created in a file named after the object&amp;rsquo;s SHA-1 hash (stored in &lt;code&gt;.git/objects&lt;/code&gt;).</source>
          <target state="translated">새로 작성된 오브젝트는 처음에 오브젝트의 SHA-1 해시 ( &lt;code&gt;.git/objects&lt;/code&gt; 에 저장 됨)의 이름을 가진 파일로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="5efdf7f0d1fca004c74269609acfa25723d86160" translate="yes" xml:space="preserve">
          <source>Next step: get familiar with the object naming. Read &lt;a href=&quot;#naming-commits&quot;&gt;Naming commits&lt;/a&gt;. There are quite a few ways to name an object (and not only revisions!). All of these are handled in &lt;code&gt;sha1_name.c&lt;/code&gt;. Just have a quick look at the function &lt;code&gt;get_sha1()&lt;/code&gt;. A lot of the special handling is done by functions like &lt;code&gt;get_sha1_basic()&lt;/code&gt; or the likes.</source>
          <target state="translated">다음 단계 : 객체 이름 지정에 익숙해 지십시오. &lt;a href=&quot;#naming-commits&quot;&gt;명명 커밋을&lt;/a&gt; 읽습니다 . 객체의 이름을 지정하는 방법에는 여러 가지가 있습니다 (개정뿐만 아니라!). 이 모든 것은 &lt;code&gt;sha1_name.c&lt;/code&gt; 에서 처리됩니다 . &lt;code&gt;get_sha1()&lt;/code&gt; 함수를 간단히 살펴보십시오 . &lt;code&gt;get_sha1_basic()&lt;/code&gt; 또는 이와 유사한 기능으로 많은 특수 처리가 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="11fc14203dd0f4441645a9c34d5dd022905f56e4" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="translated">다음 단계</target>
        </trans-unit>
        <trans-unit id="817a91571b93a177740989ad9e63a1941cffb303" translate="yes" xml:space="preserve">
          <source>Next time, after seeing the same conflicted automerge, running &lt;code&gt;git rerere&lt;/code&gt; will perform a three-way merge between the earlier conflicted automerge, the earlier manual resolution, and the current conflicted automerge. If this three-way merge resolves cleanly, the result is written out to your working tree file, so you do not have to manually resolve it. Note that &lt;code&gt;git rerere&lt;/code&gt; leaves the index file alone, so you still need to do the final sanity checks with &lt;code&gt;git diff&lt;/code&gt; (or &lt;code&gt;git diff -c&lt;/code&gt;) and &lt;code&gt;git add&lt;/code&gt; when you are satisfied.</source>
          <target state="translated">다음에 동일한 충돌 자동 병합 을 확인한 후 &lt;code&gt;git rerere&lt;/code&gt; 를 실행하면 이전 충돌 자동 병합, 이전 수동 해결 방법 및 현재 충돌 자동 병합간에 3 방향 병합이 수행됩니다. 이 3 방향 병합이 제대로 해결되면 작업 트리 파일에 결과가 기록되므로 수동으로 해결할 필요가 없습니다. 참고 &lt;code&gt;git rerere&lt;/code&gt; 당신은 여전히 함께 최종 정신 검사를 할 필요가 잎 혼자 인덱스 파일, 그래서 &lt;code&gt;git diff&lt;/code&gt; (또는 &lt;code&gt;git diff -c&lt;/code&gt; )과 &lt;code&gt;git add&lt;/code&gt; 당신이 만족하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="74ccc5b41472ca3ff8486dd211ddfe0cae9246c3" translate="yes" xml:space="preserve">
          <source>Next, commit the changes stored in the index. The &lt;code&gt;-c&lt;/code&gt; option specifies to pre-populate the commit message from the original message that you started with in the first commit. This is helpful to avoid retyping it. The &lt;code&gt;HEAD@{1}&lt;/code&gt; is a special notation for the commit that &lt;code&gt;HEAD&lt;/code&gt; used to be at prior to the original reset commit (1 change ago). See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt; for more details. You may also use any other valid commit reference.</source>
          <target state="translated">다음으로, 색인에 저장된 변경 사항을 커미트하십시오. &lt;code&gt;-c&lt;/code&gt; 옵션 지정은 당신이 먼저 커밋에서 시작하는 원본 메시지에서 커밋 메시지를 미리 채울 수 있습니다. 이것은 다시 입력하지 않도록하는 데 도움이됩니다. &lt;code&gt;HEAD@{1}&lt;/code&gt; (가) 커밋위한 특별한 표기법 &lt;code&gt;HEAD&lt;/code&gt; 는 원래 리셋 이전에 (1 변경 전) 커밋에 사용. 자세한 내용은 &lt;a href=&quot;git-reflog&quot;&gt;git-reflog [1]&lt;/a&gt; 를 참조하십시오. 다른 유효한 커밋 참조를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d481150e66b12915d203137377672c89781fe045" translate="yes" xml:space="preserve">
          <source>Next, copy &lt;code&gt;proj.git&lt;/code&gt; to the server where you plan to host the public repository. You can use scp, rsync, or whatever is most convenient.</source>
          <target state="translated">다음으로 공개 저장소를 호스트 할 서버에 &lt;code&gt;proj.git&lt;/code&gt; 을 복사 하십시오 . scp, rsync 또는 가장 편리한 것을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04e0b9feb1c4a494995ed09ad261d2d4e9ce11c5" translate="yes" xml:space="preserve">
          <source>Next, give every team member read/write access to this repository. One easy way to do this is to give all the team members ssh access to the machine where the repository is hosted. If you don&amp;rsquo;t want to give them a full shell on the machine, there is a restricted shell which only allows users to do Git pushes and pulls; see &lt;a href=&quot;git-shell&quot;&gt;git-shell[1]&lt;/a&gt;.</source>
          <target state="translated">그런 다음 모든 팀 구성원에게이 저장소에 대한 읽기 / 쓰기 액세스 권한을 부여하십시오. 이를 수행하는 한 가지 쉬운 방법은 모든 팀 구성원에게 저장소가 호스팅되는 머신에 대한 ssh 액세스 권한을 부여하는 것입니다. 머신에 전체 쉘을 제공하지 않으려면 사용자가 Git 밀고 당기는 것만 허용하는 제한된 쉘이 있습니다. 참조 &lt;a href=&quot;git-shell&quot;&gt;자식 쉘 [1]가&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="28d55d870524553fca2220c18e5b9bb0de3dcbdb" translate="yes" xml:space="preserve">
          <source>Next, tell Git to take a snapshot of the contents of all files under the current directory (note the &lt;code&gt;.&lt;/code&gt;), with &lt;code&gt;git add&lt;/code&gt;:</source>
          <target state="translated">다음으로,합니다 (참고 현재 디렉토리 아래있는 모든 파일 내용의 스냅 샷을 망할 놈의 말 &lt;code&gt;.&lt;/code&gt; 로) &lt;code&gt;git add&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="596419ac8ea3393898cb55dbbde5c3613a819bd1" translate="yes" xml:space="preserve">
          <source>Next, we interactively select diff hunks to add using the &lt;code&gt;git add -p&lt;/code&gt; facility. This will ask you about each diff hunk in sequence and you can use simple commands such as &quot;yes, include this&quot;, &quot;No don&amp;rsquo;t include this&quot; or even the very powerful &quot;edit&quot; facility.</source>
          <target state="translated">다음으로, &lt;code&gt;git add -p&lt;/code&gt; 기능을 사용하여 추가 할 diff hunk를 대화식으로 선택 합니다. 이렇게하면 각 diff hunk에 대해 순서대로 물어볼 수 있으며 &quot;yes, include include&quot;, &quot;No not include this&quot;또는 매우 강력한 &quot;edit&quot;기능과 같은 간단한 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8951da293ad0f99492d7f4956f721a58ac3b7ff1" translate="yes" xml:space="preserve">
          <source>No checkout of HEAD is performed after the clone is complete.</source>
          <target state="translated">복제가 완료된 후 HEAD 체크 아웃이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cfeba19b6e040607769791cbfbefd83c894b180c" translate="yes" xml:space="preserve">
          <source>No modifications to submodules are ignored, all of committed differences, and modifications to tracked and untracked files are shown. This is the default option.</source>
          <target state="translated">서브 모듈에 대한 수정은 무시되지 않고 커밋 된 모든 차이점과 추적 및 추적되지 않은 파일에 대한 수정이 표시됩니다. 이것이 기본 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="e2a67085604f2eb59fb72fa11fe30ca6d6e00a34" translate="yes" xml:space="preserve">
          <source>No other changes are made. In particular, the local modifications you had before you started merge will stay the same and the index entries for them stay as they were, i.e. matching &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">다른 변경 사항은 없습니다. 특히, 병합을 시작하기 전에 수행 한 로컬 수정 사항은 동일하게 유지되고 해당 항목의 색인 항목은 그대로 유지됩니다 (예 : &lt;code&gt;HEAD&lt;/code&gt; 일치) .</target>
        </trans-unit>
        <trans-unit id="de8a6fbc5b9c2db6f89c1e3ad733992686a5d62a" translate="yes" xml:space="preserve">
          <source>No other kinds of lines (e.g. empty lines or comment lines) are allowed in the file, even though some may be silently ignored. Do not view or edit the file with editors.</source>
          <target state="translated">파일에 다른 종류의 줄 (예 : 빈 줄 또는 주석 줄)은 허용되지 않습니다. 일부는 자동으로 무시 될 수 있습니다. 편집기로 파일을 보거나 편집하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c967d0b967e1e36091e8958a5454d9ea9951dded" translate="yes" xml:space="preserve">
          <source>No other modifications are made.</source>
          <target state="translated">다른 수정은 없습니다.</target>
        </trans-unit>
        <trans-unit id="57658df76cf3f4fecaffea0a60cae0068e21e278" translate="yes" xml:space="preserve">
          <source>No patch introduces a regression: after applying any initial part of the series, the resulting project still compiles and works, and has no bugs that it didn&amp;rsquo;t have before.</source>
          <target state="translated">어떤 패치도 회귀를 소개하지 않습니다. 시리즈의 초기 부분을 적용한 후에도 결과 프로젝트는 여전히 컴파일되고 작동하며 이전에는 없었던 버그가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0d39633312554b0ea8cb734d680c4698c57a7afd" translate="yes" xml:space="preserve">
          <source>No pattern matches the path, and nothing says if the path has or does not have the attribute, the attribute for the path is said to be Unspecified.</source>
          <target state="translated">경로와 일치하는 패턴이 없으며 경로에 속성이 있거나없는 경우 경로에 대한 속성이 지정되지 않은 것으로 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="772b72b88edec66167df810a58edde895140fe67" translate="yes" xml:space="preserve">
          <source>No promises are made about the interface, or that this program won&amp;rsquo;t disappear without warning in the next version of Git. Don&amp;rsquo;t use it.</source>
          <target state="translated">인터페이스에 대한 약속은 없으며이 프로그램은 다음 버전의 Git에서 경고없이 사라지지 않을 것입니다. 그것을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c90ed1cbdf989952fffa921b682ee1beb354558a" translate="yes" xml:space="preserve">
          <source>No special setup is needed for SSH access, other than having Git tools in the PATH. If you have clients that do not accept the CVS_SERVER environment variable, you can rename &lt;code&gt;git-cvsserver&lt;/code&gt; to &lt;code&gt;cvs&lt;/code&gt;.</source>
          <target state="translated">PATH에 Git 도구를 사용하는 것 외에 SSH 액세스에는 특별한 설정이 필요하지 않습니다. CVS_SERVER 환경 변수를 허용하지 않는 클라이언트가있는 경우 &lt;code&gt;git-cvsserver&lt;/code&gt; 의 이름 을 &lt;code&gt;cvs&lt;/code&gt; 로 바꿀 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8302d8fa548b77adf094708d453bfd512d86a1e" translate="yes" xml:space="preserve">
          <source>No-op. Rebasing commits with an empty message used to fail and this option would override that behavior, allowing commits with empty messages to be rebased. Now commits with an empty message do not cause rebasing to halt.</source>
          <target state="translated">안돼. 실패하는 데 사용되는 빈 메시지로 커밋을 리베이스하면이 옵션이 해당 동작을 재정 의하여 빈 메시지가있는 커밋을 리베이스 할 수 있습니다. 이제 빈 메시지로 커밋해도 리베이스가 중단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5febeaff9fb6579d7fb9744e50b3994bde6d8e3" translate="yes" xml:space="preserve">
          <source>Non-ascii filenames can be silently removed despite being in a desired directory. Keeping only wanted paths is often done using pipelines like &lt;code&gt;git ls-files | grep -v ^WANTED_DIR/ | xargs git rm&lt;/code&gt;. ls-files will only quote filenames if needed, so folks may not notice that one of the files didn&amp;rsquo;t match the regex (at least not until it&amp;rsquo;s much too late). Yes, someone who knows about core.quotePath can avoid this (unless they have other special characters like \t, \n, or &quot;), and people who use ls-files -z with something other than grep can avoid this, but that doesn&amp;rsquo;t mean they will.</source>
          <target state="translated">ASCII가 아닌 파일 이름은 원하는 디렉토리에 있더라도 자동으로 제거 할 수 있습니다. 원하는 경로 만 유지하는 것은 종종 &lt;code&gt;git ls-files | grep -v ^WANTED_DIR/ | xargs git rm&lt;/code&gt; . ls-files는 필요한 경우 파일 이름 만 인용하므로 사람들은 파일 중 하나가 정규식과 일치하지 않는다는 것을 눈치 채지 못할 수 있습니다 (적어도 너무 늦을 때까지는 아님). 예. core.quotePath에 대해 알고있는 사람은 이것을 피할 수 있습니다 (\ t, \ n 또는 &quot;와 같은 다른 특수 문자가없는 한), grep 이외의 다른 것과 함께 ls-files -z를 사용하는 사람들은 이것을 피할 수 있지만 그렇다는 뜻은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e2858812ab58a3c85b7437528709a46037dcfba6" translate="yes" xml:space="preserve">
          <source>Non-cached mode</source>
          <target state="translated">캐시되지 않은 모드</target>
        </trans-unit>
        <trans-unit id="28592521357265f4a182551c4308e7cea911b93e" translate="yes" xml:space="preserve">
          <source>Non-empty context lines that have one extra whitespace at the beginning.</source>
          <target state="translated">처음에 하나의 추가 공백이있는 비어 있지 않은 컨텍스트 라인.</target>
        </trans-unit>
        <trans-unit id="54b4652d3bd254c89ec712af1b81619180dc7f11" translate="yes" xml:space="preserve">
          <source>None of the provided paths are ignored.</source>
          <target state="translated">제공된 경로는 무시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53d641d85a09ede95cefeac02aadaca1a7fcd396" translate="yes" xml:space="preserve">
          <source>Normalize &lt;code&gt;refname&lt;/code&gt; by removing any leading slash (&lt;code&gt;/&lt;/code&gt;) characters and collapsing runs of adjacent slashes between name components into a single slash. If the normalized refname is valid then print it to standard output and exit with a status of 0, otherwise exit with a non-zero status. (&lt;code&gt;--print&lt;/code&gt; is a deprecated way to spell &lt;code&gt;--normalize&lt;/code&gt;.)</source>
          <target state="translated">표준화 &lt;code&gt;refname&lt;/code&gt; 선행 슬래시 (제거하여 &lt;code&gt;/&lt;/code&gt; ) 문자를 단일 슬래시로 이름 구성 요소 사이의 인접 슬래시의 실행을 무너. 정규화 된 참조 이름이 유효한 경우 표준 출력으로 인쇄하고 상태 0으로 종료하고, 그렇지 않으면 0이 아닌 상태로 종료하십시오. ( &lt;code&gt;--print&lt;/code&gt; 는 &lt;code&gt;--normalize&lt;/code&gt; 철자를 사용하는 더 이상 사용되지 않는 방법 입니다.)</target>
        </trans-unit>
        <trans-unit id="cd7a46a34b030b4fa7a1f4c298bb470454f5bdc6" translate="yes" xml:space="preserve">
          <source>Normally &lt;code&gt;git write-tree&lt;/code&gt; ensures that the objects referenced by the directory exist in the object database. This option disables this check.</source>
          <target state="translated">일반적으로 &lt;code&gt;git write-tree&lt;/code&gt; 는 디렉토리가 참조하는 객체가 객체 데이터베이스에 존재하도록합니다. 이 옵션은이 검사를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="88fcf17b3fc3a47614adb1a8f9a3b0161d3a2185" translate="yes" xml:space="preserve">
          <source>Normally a &quot;commit&quot; has one parent: the previous state of the tree before a certain change was made. However, sometimes it can have two or more parent commits, in which case we call it a &quot;merge&quot;, due to the fact that such a commit brings together (&quot;merges&quot;) two or more previous states represented by other commits.</source>
          <target state="translated">일반적으로 &quot;커밋&quot;에는 하나의 부모가 있습니다 : 특정 변경 이전의 트리 상태. 그러나 때로는 두 개 이상의 부모 커밋이있을 수 있습니다. 이러한 커밋은 다른 커밋으로 표시된 두 개 이상의 이전 상태를 하나로 묶기 때문에 &quot;병합&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="a69474e938cf33a616aeca615fe9997480c7c945" translate="yes" xml:space="preserve">
          <source>Normally a commit would identify a new &quot;HEAD&quot; state, and while Git doesn&amp;rsquo;t care where you save the note about that state, in practice we tend to just write the result to the file that is pointed at by &lt;code&gt;.git/HEAD&lt;/code&gt;, so that we can always see what the last committed state was.</source>
          <target state="translated">일반적으로 커밋은 새로운 &quot;HEAD&quot;상태를 식별하고 Git은 해당 상태에 대한 메모를 저장하는 위치를 신경 쓰지 않지만 실제로는 결과를 &lt;code&gt;.git/HEAD&lt;/code&gt; 가 가리키는 파일에 쓰는 경향이 있습니다 . 우리는 항상 마지막 커밋 된 상태를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de60fcb388acbd1518bd224ad2216b3a990124fa" translate="yes" xml:space="preserve">
          <source>Normally batch output is flushed after each object is output, so that a process can interactively read and write from &lt;code&gt;cat-file&lt;/code&gt;. With this option, the output uses normal stdio buffering; this is much more efficient when invoking &lt;code&gt;--batch-check&lt;/code&gt; on a large number of objects.</source>
          <target state="translated">일반적으로 배치 출력은 각 객체가 출력 된 후 플러시되므로 프로세스가 대화식으로 &lt;code&gt;cat-file&lt;/code&gt; 에서 읽고 쓸 수 있습니다 . 이 옵션을 사용하면 출력에 일반 stdio 버퍼링이 사용됩니다. 이것은 많은 수의 객체 를 &lt;code&gt;--batch-check&lt;/code&gt; 할 때 훨씬 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="38e091b35be2fc0762233a3d599b506f3b643fb1" translate="yes" xml:space="preserve">
          <source>Normally commits are only added to a project, never taken away or replaced. Git is designed with this assumption, and violating it will cause Git&amp;rsquo;s merge machinery (for example) to do the wrong thing.</source>
          <target state="translated">일반적으로 커밋은 프로젝트에만 추가되며 절대 제거되거나 교체되지 않습니다. Git은 이러한 가정으로 설계되었으며이를 위반하면 Git의 병합 기계 (예 : 잘못된 기계)가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9122c3565585fe79768943dc25f1cf167ffbd58d" translate="yes" xml:space="preserve">
          <source>Normally the &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; stores the name of a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;, and commands that operate on the history HEAD represents operate on the history leading to the tip of the branch the HEAD points at. However, Git also allows you to &lt;a href=&quot;#def_checkout&quot;&gt;check out&lt;/a&gt; an arbitrary &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; that isn&amp;rsquo;t necessarily the tip of any particular branch. The HEAD in such a state is called &quot;detached&quot;.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; 는 &lt;a href=&quot;#def_branch&quot;&gt;분기&lt;/a&gt; 의 이름을 저장하고 히스토리에서 작동하는 명령 HEAD는 HEAD가 가리키는 분기의 끝으로 이어지는 히스토리에서 작동합니다. 그러나 Git을 사용하면 특정 분기의 팁이 아닌 임의의 &lt;a href=&quot;#def_commit&quot;&gt;커밋&lt;/a&gt; 을 &lt;a href=&quot;#def_checkout&quot;&gt;확인할&lt;/a&gt; 수도 있습니다 . 이러한 상태의 HEAD를 &quot;분리&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="cc5f74671cf296af564ff0627cbd1c153eed7819" translate="yes" xml:space="preserve">
          <source>Normally the branch merged in is the HEAD of the remote repository, but the choice is determined by the branch.&amp;lt;name&amp;gt;.remote and branch.&amp;lt;name&amp;gt;.merge options; see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details.</source>
          <target state="translated">일반적으로 병합 된 분기는 원격 저장소의 HEAD이지만 선택은 branch. &amp;lt;name&amp;gt; .remote 및 branch. &amp;lt;name&amp;gt; .merge 옵션에 의해 결정됩니다. 자세한 내용은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f22467859cfedb6f904df5424dcd9afb82c226b1" translate="yes" xml:space="preserve">
          <source>Normally whenever a branch head in a public repository is modified, it is modified to point to a descendant of the commit that it pointed to before. By forcing a push in this situation, you break that convention. (See &lt;a href=&quot;#problems-With-rewriting-history&quot;&gt;Problems with rewriting history&lt;/a&gt;.)</source>
          <target state="translated">일반적으로 공용 저장소의 분기 헤드가 수정 될 때마다 이전에 지정한 커밋의 하위 항목을 가리 키도록 수정됩니다. 이 상황을 강요하면 해당 규칙을 위반하게됩니다. &lt;a href=&quot;#problems-With-rewriting-history&quot;&gt;히스토리 재 작성 문제점을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="43244e83cbae6a59cf653d315de1a56015589247" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;git rerere&lt;/code&gt; is run without arguments or user-intervention. However, it has several commands that allow it to interact with its working state.</source>
          <target state="translated">일반적으로 &lt;code&gt;git rerere&lt;/code&gt; 는 인수 나 사용자 개입없이 실행됩니다. 그러나 작업 상태와 상호 작용할 수있는 몇 가지 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7d70adae9e248dcbf5927b7eeba22fdf79a73fb" translate="yes" xml:space="preserve">
          <source>Normally, only files unknown to Git are removed, but if the &lt;code&gt;-x&lt;/code&gt; option is specified, ignored files are also removed. This can, for example, be useful to remove all build products.</source>
          <target state="translated">일반적으로 Git에 알려지지 않은 파일 만 제거되지만 &lt;code&gt;-x&lt;/code&gt; 옵션을 지정하면 무시 된 파일도 제거됩니다. 예를 들어 모든 빌드 제품을 제거하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea1a90319260338e8b5ddefd985427f3690ce910" translate="yes" xml:space="preserve">
          <source>Normally, the &quot;git svn clone&quot; and &quot;git svn rebase&quot; commands attempt to recreate empty directories that are in the Subversion repository. If this option is set to &quot;false&quot;, then empty directories will only be created if the &quot;git svn mkdirs&quot; command is run explicitly. If unset, &lt;code&gt;git svn&lt;/code&gt; assumes this option to be &quot;true&quot;.</source>
          <target state="translated">일반적으로 &quot;git svn clone&quot;및 &quot;git svn rebase&quot;명령은 Subversion 저장소에있는 빈 디렉토리를 다시 작성하려고 시도합니다. 이 옵션을 &quot;false&quot;로 설정하면 &quot;git svn mkdirs&quot;명령이 명시 적으로 실행되는 경우에만 빈 디렉토리가 작성됩니다. 설정하지 않으면 &lt;code&gt;git svn&lt;/code&gt; 은이 옵션을 &quot;true&quot;로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="cbab35b86acdc7c387af4e06856d3dc90a27828f" translate="yes" xml:space="preserve">
          <source>Normally, the &quot;name&quot; field contains the canonical name of the command. When a canonical name is not available, one of these special values are used:</source>
          <target state="translated">일반적으로 &quot;이름&quot;필드에는 명령의 정식 이름이 포함됩니다. 정식 이름을 사용할 수없는 경우 다음 특수 값 중 하나가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a72159c3df537e6c1eeaac201666cb67a55dea2c" translate="yes" xml:space="preserve">
          <source>Normally, the first commit in an SVN branch consists of a copy operation. &lt;code&gt;git svn&lt;/code&gt; will read this commit to get the SVN revision the branch was created from. It will then try to find the Git commit that corresponds to this SVN revision, and use that as the parent of the branch. However, it is possible that there is no suitable Git commit to serve as parent. This will happen, among other reasons, if the SVN branch is a copy of a revision that was not fetched by &lt;code&gt;git svn&lt;/code&gt; (e.g. because it is an old revision that was skipped with &lt;code&gt;--revision&lt;/code&gt;), or if in SVN a directory was copied that is not tracked by &lt;code&gt;git svn&lt;/code&gt; (such as a branch that is not tracked at all, or a subdirectory of a tracked branch). In these cases, &lt;code&gt;git svn&lt;/code&gt; will still create a Git branch, but instead of using an existing Git commit as the parent of the branch, it will read the SVN history of the directory the branch was copied from and create appropriate Git commits. This is indicated by the message &quot;Initializing parent: &amp;lt;branchname&amp;gt;&quot;.</source>
          <target state="translated">일반적으로 SVN 분기의 첫 번째 커밋은 복사 작업으로 구성됩니다. &lt;code&gt;git svn&lt;/code&gt; 은이 커밋을 읽어 분기가 작성된 SVN 개정을 가져옵니다. 그런 다음이 SVN 개정에 해당하는 Git 커밋을 찾아이를 브랜치의 부모로 사용합니다. 그러나 부모 역할을 수행하기에 적합한 Git 커밋이 없을 수 있습니다. SVN 브랜치가 &lt;code&gt;git svn&lt;/code&gt; 에 의해 페치되지 않은 리비전의 사본 인 경우 (예 : &lt;code&gt;--revision&lt;/code&gt; 으로 건너 뛴 이전 리비전이기 때문에 ) SVN에서 디렉토리가 복사 된 경우 이러한 상황이 발생합니다. 그것은 &lt;code&gt;git svn&lt;/code&gt; 에 의해 추적되지 않습니다 (예 : 전혀 추적되지 않는 분기 또는 추적 된 분기의 하위 디렉토리). 이 경우 &lt;code&gt;git svn&lt;/code&gt; 여전히 Git 브랜치를 생성하지만 기존 Git 커밋을 브랜치의 부모로 사용하는 대신 브랜치가 복사 된 디렉토리의 SVN 히스토리를 읽고 적절한 Git 커밋을 생성합니다. &quot;초기화 부모 : &amp;lt;branchname&amp;gt;&quot;메시지로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4d54b3aadfbad6c493d83bcb2428d0cb9e46992e" translate="yes" xml:space="preserve">
          <source>Normally, when no &amp;lt;path&amp;gt; is specified, git clean will not recurse into untracked directories to avoid removing too much. Specify -d to have it recurse into such directories as well. If any paths are specified, -d is irrelevant; all untracked files matching the specified paths (with exceptions for nested git directories mentioned under &lt;code&gt;--force&lt;/code&gt;) will be removed.</source>
          <target state="translated">일반적으로 &amp;lt;path&amp;gt;를 지정하지 않으면 git clean은 너무 많은 제거를 피하기 위해 추적되지 않은 디렉토리로 재귀하지 않습니다. 그러한 디렉토리로도 재귀 시키려면 -d를 지정하십시오. 경로가 지정되면 -d는 관련이 없습니다. 지정된 경로와 일치하는 추적되지 않은 모든 파일 ( &lt;code&gt;--force&lt;/code&gt; 에 언급 된 중첩 된 git 디렉토리 제외 )이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="429c7c6d611a6b06377c7694b2f456c87ba75047" translate="yes" xml:space="preserve">
          <source>Not all pattern types support patterns containing \0. Git will error out if a given pattern type can&amp;rsquo;t support such a pattern. The &lt;code&gt;--perl-regexp&lt;/code&gt; pattern type when compiled against the PCRE v2 backend has the widest support for these types of patterns.</source>
          <target state="translated">모든 패턴 유형이 \ 0을 포함하는 패턴을 지원하지는 않습니다. 주어진 패턴 유형이 그러한 패턴을 지원할 수 없으면 Git은 오류가 발생합니다. &lt;code&gt;--perl-regexp&lt;/code&gt; PCRE v2를 백엔드에 대해 컴파일 된 패턴 유형 패턴의 이러한 유형에 대한 폭 넓은 지원을하고있다.</target>
        </trans-unit>
        <trans-unit id="fc85aa9ed9f2a57ce72e656178cf6fe66c794d02" translate="yes" xml:space="preserve">
          <source>Not all values are equally unambiguous:</source>
          <target state="translated">모든 값이 동일하게 모호한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8394b0fb9c23c1116919b0832addc200fe1387df" translate="yes" xml:space="preserve">
          <source>Not to worry. It left the (trivial) conflict in &lt;code&gt;hello&lt;/code&gt; in the same form you should already be well used to if you&amp;rsquo;ve ever used CVS, so let&amp;rsquo;s just open &lt;code&gt;hello&lt;/code&gt; in our editor (whatever that may be), and fix it up somehow. I&amp;rsquo;d suggest just making it so that &lt;code&gt;hello&lt;/code&gt; contains all four lines:</source>
          <target state="translated">걱정할 필요 없어요. CVS를 사용한 적이 있다면 이미 익숙해 져야 할 것과 같은 형태 로 &lt;code&gt;hello&lt;/code&gt; 의 (사소한) 충돌을 남겼 으므로 에디터에서 &lt;code&gt;hello&lt;/code&gt; 를 열어서 어떻게 든 수정하십시오. &lt;code&gt;hello&lt;/code&gt; 에 네 줄이 모두 포함 되도록 만드는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="b7ed8e5f5bf09b0c843d3af582307ddfb588c4c6" translate="yes" xml:space="preserve">
          <source>Note about fast-forwards</source>
          <target state="translated">빨리 감기에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="318ccd302e94c5b26153ff4314826ba81af60a67" translate="yes" xml:space="preserve">
          <source>Note about git config --global</source>
          <target state="translated">git config --global에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="7da8f06b5e46e2bca162125caa0438ca1631ce6d" translate="yes" xml:space="preserve">
          <source>Note about git-config --global</source>
          <target state="translated">git-config --global에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="a858b9b8c7722185661603839f0881f8c7f88318" translate="yes" xml:space="preserve">
          <source>Note about konqueror</source>
          <target state="translated">Konqueror에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="01b5dd07775875ee6aa9a8a3da76365c637f9b1a" translate="yes" xml:space="preserve">
          <source>Note also that multiple copies of an object may be present in the object database; in this case, it is undefined which copy&amp;rsquo;s size or delta base will be reported.</source>
          <target state="translated">또한 개체 데이터베이스에 개체의 여러 복사본이있을 수 있습니다. 이 경우 어떤 사본의 크기 또는 델타베이스가보고 될지는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e92cbc9ca374ec932eab116752367c5739918c53" translate="yes" xml:space="preserve">
          <source>Note for Git users, that it is equivalent as keeping only the commit given by:</source>
          <target state="translated">Git 사용자에게는 다음과 같은 커밋 만 유지하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9cd066f98a94620416bd40171030f2cd3deb4780" translate="yes" xml:space="preserve">
          <source>Note how the rule to only follow the TREESAME parent, if one is available, removed &lt;code&gt;B&lt;/code&gt; from consideration entirely. &lt;code&gt;C&lt;/code&gt; was considered via &lt;code&gt;N&lt;/code&gt;, but is TREESAME. Root commits are compared to an empty tree, so &lt;code&gt;I&lt;/code&gt; is !TREESAME.</source>
          <target state="translated">사용 가능한 경우 TREESAME 상위 만 따르는 규칙이 &lt;code&gt;B&lt;/code&gt; 를 완전히 고려 하지 않은 방법에 유의하십시오 . &lt;code&gt;C&lt;/code&gt; 는 &lt;code&gt;N&lt;/code&gt; 을 통해 고려 되었지만 TREESAME입니다. 그래서 루트 커밋은 빈 나무에 비교 &lt;code&gt;I&lt;/code&gt; ! TREESAME입니다.</target>
        </trans-unit>
        <trans-unit id="8bfd2da46a110f046c6975fde1a8b82933cacdc7" translate="yes" xml:space="preserve">
          <source>Note how there is no need for an entry for &lt;code&gt;&amp;lt;jane@laptop.(none)&amp;gt;&lt;/code&gt;, because the real name of that author is already correct.</source>
          <target state="translated">해당 저자의 실제 이름이 이미 정확하기 때문에 &lt;code&gt;&amp;lt;jane@laptop.(none)&amp;gt;&lt;/code&gt; 에 대한 항목이 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a357a7dbcbc2a41b2d3445e7cfb8ae38a48bfe09" translate="yes" xml:space="preserve">
          <source>Note in the example that we set up a triangular workflow, where we pull from one location and push to another. In a non-triangular workflow, &lt;code&gt;@{push}&lt;/code&gt; is the same as &lt;code&gt;@{upstream}&lt;/code&gt;, and there is no need for it.</source>
          <target state="translated">이 예에서는 삼각형 워크 플로를 설정하여 한 위치에서 다른 위치로 밀고갑니다. 비 삼각형 워크 플로에서 &lt;code&gt;@{push}&lt;/code&gt; 는 &lt;code&gt;@{upstream}&lt;/code&gt; 과 동일하므로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01660f89f7c458ce6428d6e0df0b322692b74596" translate="yes" xml:space="preserve">
          <source>Note that &quot;%f&quot; is the name of the path that is being worked on. Depending on the version that is being filtered, the corresponding file on disk may not exist, or may have different contents. So, smudge and clean commands should not try to access the file on disk, but only act as filters on the content provided to them on standard input.</source>
          <target state="translated">&quot;% f&quot;는 작업중인 경로의 이름입니다. 필터링되는 버전에 따라 디스크에 해당 파일이 없거나 내용이 다를 수 있습니다. 따라서 얼룩 및 정리 명령은 디스크의 파일에 액세스하려고 시도하지 말고 표준 입력에서 제공된 컨텐츠에 대한 필터 역할 만합니다.</target>
        </trans-unit>
        <trans-unit id="014f6a8d43d7b297d024fa501c939621bed28154" translate="yes" xml:space="preserve">
          <source>Note that &quot;../&quot; is not special and will match literally, which is unlikely what you want.</source>
          <target state="translated">&quot;../&quot;는 특별하지 않으며 문자 그대로 일치하므로 원하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8b91ded5c4fad4671b25fb8bfeab09bc89a0acef" translate="yes" xml:space="preserve">
          <source>Note that (3) is a historical artefact and will be ignored if the (1) and (2) specify that the submodule is not active. In other words, if we have a &lt;code&gt;submodule.&amp;lt;name&amp;gt;.active&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt; or if the submodule&amp;rsquo;s path is excluded in the pathspec in &lt;code&gt;submodule.active&lt;/code&gt;, the url doesn&amp;rsquo;t matter whether it is present or not. This is illustrated in the example that follows.</source>
          <target state="translated">(3)은 역사적인 아티팩트이며 (1)과 (2)가 서브 모듈이 활성화되지 않았다고 지정하면 무시됩니다. 즉, &lt;code&gt;submodule.&amp;lt;name&amp;gt;.active&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 로 설정되어 있거나 submodule.active의 경로 스펙에서 &lt;code&gt;submodule.active&lt;/code&gt; 모듈의 경로가 제외 된 경우 URL의 존재 여부에 관계없이 URL이 중요하지 않습니다. 다음에 나오는 예에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fec9940a0e0728d1bf92151624eb87584d6019f" translate="yes" xml:space="preserve">
          <source>Note that --more, --list, --independent and --merge-base options are mutually exclusive.</source>
          <target state="translated">--more, --list, --independent 및 --merge-base 옵션은 상호 배타적입니다.</target>
        </trans-unit>
        <trans-unit id="9b9a74f48dd77c7cda36904d8ae57495c22af6f7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;--force&lt;/code&gt; applies to all the refs that are pushed, hence using it with &lt;code&gt;push.default&lt;/code&gt; set to &lt;code&gt;matching&lt;/code&gt; or with multiple push destinations configured with &lt;code&gt;remote.*.push&lt;/code&gt; may overwrite refs other than the current branch (including local refs that are strictly behind their remote counterpart). To force a push to only one branch, use a &lt;code&gt;+&lt;/code&gt; in front of the refspec to push (e.g &lt;code&gt;git push
origin +master&lt;/code&gt; to force a push to the &lt;code&gt;master&lt;/code&gt; branch). See the &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; section above for details.</source>
          <target state="translated">&lt;code&gt;--force&lt;/code&gt; 는 푸시 된 모든 참조에 적용되므로 &lt;code&gt;push.default&lt;/code&gt; 를 &lt;code&gt;matching&lt;/code&gt; 설정 하거나 &lt;code&gt;remote.*.push&lt;/code&gt; 구성된 여러 푸시 대상과 함께 사용하면 * .push 는 현재 분기 (예 : 로컬 참조 포함) 이외의 참조를 덮어 쓸 수 있습니다 . 그들의 원격 상대방 뒤에 엄격히). 하나의 브랜치로만 푸시하려면 참조 스펙 앞의 &lt;code&gt;+&lt;/code&gt; 를 사용 하여 푸시합니다 (예 : &lt;code&gt;git push origin +master&lt;/code&gt; 는 &lt;code&gt;master&lt;/code&gt; 브랜치 를 강제로 푸시합니다 ). 자세한 내용은 위 의 &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f71426a1d6dfa55d8e5b4bb3bb7ddab1eba41559" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;--patch&lt;/code&gt; can accept no pathspec and will prompt to restore all modified paths.</source>
          <target state="translated">참고 &lt;code&gt;--patch&lt;/code&gt; 가 더 pathspec을 받아 들일 수 없으며 수정 된 모든 경로를 복원하라는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="788dab85e40bdd496cc4b3d8bdc2f5695fd79580" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;combined diff&lt;/code&gt; lists only files which were modified from all parents.</source>
          <target state="translated">참고 그 &lt;code&gt;combined diff&lt;/code&gt; 모든 부모로부터 수정 된 목록 파일 만.</target>
        </trans-unit>
        <trans-unit id="e64bae554ef50a53010f144d204d2601ed2388af" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;git --help ...&lt;/code&gt; is identical to &lt;code&gt;git help ...&lt;/code&gt; because the former is internally converted into the latter.</source>
          <target state="translated">참고 것을 &lt;code&gt;git --help ...&lt;/code&gt; 동일하다 &lt;code&gt;git help ...&lt;/code&gt; 전자는 내부적으로 후자로 변환되기 때문이다.</target>
        </trans-unit>
        <trans-unit id="0f050e4f28b585b64021f162ba65306d71b16a1c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;git add&lt;/code&gt; always adds just the current contents of a file to the index; further changes to the same file will be ignored unless you run &lt;code&gt;git add&lt;/code&gt; on the file again.</source>
          <target state="translated">참고 &lt;code&gt;git add&lt;/code&gt; 항상 인덱스에 파일의 바로 현재 내용을 추가합니다; 파일에서 &lt;code&gt;git add&lt;/code&gt; 를 다시 실행하지 않으면 동일한 파일에 대한 추가 변경 사항은 무시 됩니다.</target>
        </trans-unit>
        <trans-unit id="a75d3b6c972faf4b238fb20e64f0ae5ba4c5e6f0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;git diff-tree&lt;/code&gt; can use the tree encapsulated in a commit object.</source>
          <target state="translated">참고 &lt;code&gt;git diff-tree&lt;/code&gt; 커밋 객체에 캡슐화 트리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c22023840a6edf8cbd10c5905bf1fe0b2598253c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;trailers&lt;/code&gt; do not follow and are not intended to follow many rules for RFC 822 headers. For example they do not follow the encoding rules and probably many other rules.</source>
          <target state="translated">참고 &lt;code&gt;trailers&lt;/code&gt; 따르지 않는 및 RFC 822 헤더에 대한 많은 규칙을 따라야하는 것은 아니다. 예를 들어 인코딩 규칙과 다른 많은 규칙을 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99d4b644b5be625d6423f4cb1035eccb3ada0dfe" translate="yes" xml:space="preserve">
          <source>Note that Git at the core level treats path names simply as sequences of non-NUL bytes, there are no path name encoding conversions (except on Mac and Windows). Therefore, using non-ASCII path names will mostly work even on platforms and file systems that use legacy extended ASCII encodings. However, repositories created on such systems will not work properly on UTF-8-based systems (e.g. Linux, Mac, Windows) and vice versa. Additionally, many Git-based tools simply assume path names to be UTF-8 and will fail to display other encodings correctly.</source>
          <target state="translated">코어 수준의 Git은 경로 이름을 NUL이 아닌 바이트 시퀀스로 취급하므로 경로 이름 인코딩 변환은 없습니다 (Mac 및 Windows 제외). 따라서 비 ASCII 경로 이름을 사용하면 레거시 확장 ASCII 인코딩을 사용하는 플랫폼 및 파일 시스템에서도 대부분 작동합니다. 그러나 이러한 시스템에서 작성된 저장소는 UTF-8 기반 시스템 (예 : Linux, Mac, Windows)에서 제대로 작동하지 않으며 그 반대도 마찬가지입니다. 또한 많은 Git 기반 도구는 단순히 경로 이름을 UTF-8로 가정하고 다른 인코딩을 올바르게 표시하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="9883f1d7503e774a80aca1b5641976f5b274bd93" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;filerename&lt;/code&gt; is the same as a &lt;code&gt;filecopy&lt;/code&gt; followed by a &lt;code&gt;filedelete&lt;/code&gt; of the source location. There is a slight performance advantage to using &lt;code&gt;filerename&lt;/code&gt;, but the advantage is so small that it is never worth trying to convert a delete/add pair in source material into a rename for fast-import. This &lt;code&gt;filerename&lt;/code&gt; command is provided just to simplify frontends that already have rename information and don&amp;rsquo;t want bother with decomposing it into a &lt;code&gt;filecopy&lt;/code&gt; followed by a &lt;code&gt;filedelete&lt;/code&gt;.</source>
          <target state="translated">유의 &lt;code&gt;filerename&lt;/code&gt; 는 A와 동일 &lt;code&gt;filecopy&lt;/code&gt; 가 a로 하였다 &lt;code&gt;filedelete&lt;/code&gt; 소스 위치. &lt;code&gt;filerename&lt;/code&gt; 을 사용하면 약간의 성능 이점이 있지만 이점은 너무 작아서 소스 자료의 삭제 / 추가 쌍을 빠른 가져 오기를 위해 이름 바꾸기로 변환하려고 시도 할 가치가 없습니다. 이 &lt;code&gt;filerename&lt;/code&gt; 명령은 이미 이름 변경 정보가 있고이를 &lt;code&gt;filecopy&lt;/code&gt; 로 분해 한 다음 &lt;code&gt;filedelete&lt;/code&gt; 로 방해하지 않는 프런트 엔드를 단순화하기 위해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="0f7296e0d288c1c6e4ca2a5e972f6c90872dfac0" translate="yes" xml:space="preserve">
          <source>Note that a commit does not itself contain any information about what actually changed; all changes are calculated by comparing the contents of the tree referred to by this commit with the trees associated with its parents. In particular, Git does not attempt to record file renames explicitly, though it can identify cases where the existence of the same file data at changing paths suggests a rename. (See, for example, the &lt;code&gt;-M&lt;/code&gt; option to &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;).</source>
          <target state="translated">커밋 자체에는 실제로 변경된 사항에 대한 정보가 포함되어 있지 않습니다. 모든 커밋은이 커밋이 참조하는 트리의 내용을 부모와 관련된 트리와 비교하여 계산됩니다. 특히, Git은 파일 이름 변경을 명시 적으로 기록하려고 시도하지 않지만 경로 변경시 동일한 파일 데이터가 존재하여 이름이 변경되는 경우를 식별 할 수 있습니다. 예를 들어, &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]에&lt;/a&gt; 대한 &lt;code&gt;-M&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54977b94f7c8617e07e8f365a31b9faa2fc062c5" translate="yes" xml:space="preserve">
          <source>Note that a more compact instruction does not change offset and size encoding. For example, if only offset2 is omitted like below, offset3 still contains bits 16-23. It does not become offset2 and contains bits 8-15 even if it&amp;rsquo;s right next to offset1.</source>
          <target state="translated">보다 간결한 명령어는 오프셋 및 크기 인코딩을 변경하지 않습니다. 예를 들어, 아래와 같이 offset2 만 생략해도 offset3에는 여전히 16-23 비트가 포함됩니다. offset1 바로 옆에 있어도 offset2가되지 않고 비트 8-15를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="2599b1548726c0979f146506e9008608bae9db4a" translate="yes" xml:space="preserve">
          <source>Note that a rebase merge works by replaying each commit from the working branch on top of the &amp;lt;upstream&amp;gt; branch. Because of this, when a merge conflict happens, the side reported as &lt;code&gt;ours&lt;/code&gt; is the so-far rebased series, starting with &amp;lt;upstream&amp;gt;, and &lt;code&gt;theirs&lt;/code&gt; is the working branch. In other words, the sides are swapped.</source>
          <target state="translated">리베이스 병합은 &amp;lt;upstream&amp;gt; 분기의 맨 위에있는 작업 분기에서 각 커밋을 재생하여 작동합니다. 병합 충돌이 발생하는 경우와 같이이 때문에, 측면은보고 &lt;code&gt;ours&lt;/code&gt; &amp;lt;업스트림&amp;gt;을 시작으로 이제까지의 리베이스 시리즈, 그리고 &lt;code&gt;theirs&lt;/code&gt; 작업 지점입니다. 다시 말해, 측면이 서로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="8523c23f527cd324df8d4075c34f666be6f6f3b7" translate="yes" xml:space="preserve">
          <source>Note that all forms other than &lt;code&gt;--force-with-lease=&amp;lt;refname&amp;gt;:&amp;lt;expect&amp;gt;&lt;/code&gt; that specifies the expected current value of the ref explicitly are still experimental and their semantics may change as we gain experience with this feature.</source>
          <target state="translated">참조 의 예상 현재 값을 명시 적으로 지정하는 &lt;code&gt;--force-with-lease=&amp;lt;refname&amp;gt;:&amp;lt;expect&amp;gt;&lt;/code&gt; 이외의 모든 형식 은 여전히 ​​실험적이며이 기능에 대한 경험을 쌓으면 의미가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c01852cae3ff7462ff1404dd165465e299075b3" translate="yes" xml:space="preserve">
          <source>Note that all these configuration variables should probably be set using the &lt;code&gt;--global&lt;/code&gt; flag, for example like this:</source>
          <target state="translated">이러한 모든 구성 변수는 &lt;code&gt;--global&lt;/code&gt; 플래그를 사용하여 설정해야 합니다 (예 : 다음과 같이).</target>
        </trans-unit>
        <trans-unit id="11bfa085b8a4e40f2da0245c59f1751f600a1ada" translate="yes" xml:space="preserve">
          <source>Note that any of the &lt;code&gt;refs/*&lt;/code&gt; cases above may come either from the &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; directory or from the &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; file. While the ref name encoding is unspecified, UTF-8 is preferred as some output processing may assume ref names in UTF-8.</source>
          <target state="translated">위 의 &lt;code&gt;refs/*&lt;/code&gt; 사례는 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 디렉토리 또는 &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; 파일에서 올 수 있습니다. 참조 이름 인코딩은 지정되지 않지만 일부 출력 처리는 참조 이름을 UTF-8로 가정 할 수 있으므로 UTF-8이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="508d8a380e829238fc278b6ce7f900eddc6afba3" translate="yes" xml:space="preserve">
          <source>Note that any protocol restrictions will be applied to the rewritten URL. If the rewrite changes the URL to use a custom protocol or remote helper, you may need to adjust the &lt;code&gt;protocol.*.allow&lt;/code&gt; config to permit the request. In particular, protocols you expect to use for submodules must be set to &lt;code&gt;always&lt;/code&gt; rather than the default of &lt;code&gt;user&lt;/code&gt;. See the description of &lt;code&gt;protocol.allow&lt;/code&gt; above.</source>
          <target state="translated">다시 작성된 URL에는 모든 프로토콜 제한 사항이 적용됩니다. 다시 쓰기가 사용자 지정 프로토콜 또는 원격 도우미를 사용하도록 URL을 변경하는 경우 요청을 허용 &lt;code&gt;protocol.*.allow&lt;/code&gt; 을 조정해야 합니다. *. allow 구성. 특히, 서브 모듈에 사용할 프로토콜 은 기본값 &lt;code&gt;user&lt;/code&gt; 가 아닌 &lt;code&gt;always&lt;/code&gt; 설정해야합니다 . 위 의 &lt;code&gt;protocol.allow&lt;/code&gt; 에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85755e8e95f86917d98f865efeaea006efa16988" translate="yes" xml:space="preserve">
          <source>Note that any tree or blob object can be examined using &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; with the &amp;lt;revision&amp;gt;:&amp;lt;path&amp;gt; syntax. This can sometimes be useful for browsing the contents of a tree that is not currently checked out.</source>
          <target state="translated">&amp;lt;revision&amp;gt; : &amp;lt;path&amp;gt; 구문과 함께 &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; 을 사용하여 모든 트리 또는 BLOB 객체를 검사 할 수 있습니다 . 이것은 현재 체크 아웃되지 않은 트리의 내용을 탐색 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbb379f0a0fd79434d80db46f9a2b53054c72c7c" translate="yes" xml:space="preserve">
          <source>Note that attributes are by default taken from the &lt;code&gt;.gitattributes&lt;/code&gt; files in the tree that is being archived. If you want to tweak the way the output is generated after the fact (e.g. you committed without adding an appropriate export-ignore in its &lt;code&gt;.gitattributes&lt;/code&gt;), adjust the checked out &lt;code&gt;.gitattributes&lt;/code&gt; file as necessary and use &lt;code&gt;--worktree-attributes&lt;/code&gt; option. Alternatively you can keep necessary attributes that should apply while archiving any tree in your &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; file.</source>
          <target state="translated">속성은 기본적 으로 아카이브중인 트리 의 &lt;code&gt;.gitattributes&lt;/code&gt; 파일에서 가져옵니다 . 사실 이후에 출력이 생성되는 방식을 조정하려면 (예 : &lt;code&gt;.gitattributes&lt;/code&gt; 에 적절한 내보내기 무시를 추가하지 않고 커밋 한 경우 ) 필요에 따라 체크 아웃 된 &lt;code&gt;.gitattributes&lt;/code&gt; 파일을 조정하고 &lt;code&gt;--worktree-attributes&lt;/code&gt; 옵션을 사용하십시오. 또는 &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; 파일 에서 트리를 아카이브하는 동안 적용해야하는 필요한 속성을 유지할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cff58353f0553493321de729107a5ed939f5819e" translate="yes" xml:space="preserve">
          <source>Note that changing the compression level will not automatically recompress all existing objects. You can force recompression by passing the -F option to &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;.</source>
          <target state="translated">압축 수준을 변경해도 기존의 모든 객체가 자동으로 다시 압축되는 것은 아닙니다. -F 옵션을 &lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt; 에 전달하여 강제로 다시 압축 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64e3311b0fc4c31b0c8a5b69594b7b0fffce6672" translate="yes" xml:space="preserve">
          <source>Note that commands that operate on the history of the current branch (e.g. &lt;code&gt;git commit&lt;/code&gt; to build a new history on top of it) still work while the HEAD is detached. They update the HEAD to point at the tip of the updated history without affecting any branch. Commands that update or inquire information &lt;code&gt;about&lt;/code&gt; the current branch (e.g. &lt;code&gt;git
branch --set-upstream-to&lt;/code&gt; that sets what remote-tracking branch the current branch integrates with) obviously do not work, as there is no (real) current branch to ask about in this state.</source>
          <target state="translated">HEAD가 분리되어있는 동안 현재 분기의 히스토리 (예 : 새 히스토리를 빌드하기위한 &lt;code&gt;git commit&lt;/code&gt; )에서 작동하는 명령은 계속 작동합니다. 그들은 분기에 영향을 미치지 않고 업데이트 된 히스토리의 끝을 가리 키도록 HEAD를 업데이트합니다. 요청할 현재 지점이 없으므로 현재 지점 &lt;code&gt;about&lt;/code&gt; 정보를 업데이트하거나 조회하는 명령 (예 : 현재 지점과 통합 된 원격 추적 지점을 설정하는 &lt;code&gt;git branch --set-upstream-to&lt;/code&gt; )은 작동하지 않습니다. 이 상태에서.</target>
        </trans-unit>
        <trans-unit id="ca37287a6d2fcb3a044758adb2f9a6569545f92f" translate="yes" xml:space="preserve">
          <source>Note that commits that do not include the trailer will not be counted. Likewise, commits with multiple trailers (e.g., multiple signoffs) may be counted more than once (but only once per unique trailer value in that commit).</source>
          <target state="translated">예고편이 포함되지 않은 커밋은 계산되지 않습니다. 마찬가지로 여러 트레일러가있는 커밋 (예 : 다중 사인 오프)은 두 번 이상 계산 될 수 있습니다 (하지만 해당 커밋의 고유 한 트레일러 값당 한 번만).</target>
        </trans-unit>
        <trans-unit id="021097bf28be68716f4d1858bb9538ff20243dc2" translate="yes" xml:space="preserve">
          <source>Note that commits which start empty are kept (unless --no-keep-empty is specified), and commits which are clean cherry-picks (as determined by &lt;code&gt;git log --cherry-mark ...&lt;/code&gt;) are detected and dropped as a preliminary step (unless --reapply-cherry-picks is passed).</source>
          <target state="translated">비어있는 것으로 시작하는 커밋은 유지되고 (--no-keep-empty가 지정되지 않은 경우), 깨끗한 체리 픽 ( &lt;code&gt;git log --cherry-mark ...&lt;/code&gt; 에 의해 결정됨) 인 커밋 이 감지되고 삭제됩니다. 예비 단계 (--reapply-cherry-picks가 전달되지 않는 한).</target>
        </trans-unit>
        <trans-unit id="c16e502657efa32285522830eee76fe68f8a2daa" translate="yes" xml:space="preserve">
          <source>Note that despite the name of the first mode, color is used to highlight the changed parts in all modes if enabled.</source>
          <target state="translated">첫 번째 모드의 이름에도 불구하고 색상은 활성화 된 경우 모든 모드에서 변경된 부분을 강조 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="53b666711e62d15ce074196074eb30f8dac41460" translate="yes" xml:space="preserve">
          <source>Note that diff options passed to the command affect how the primary product of &lt;code&gt;format-patch&lt;/code&gt; is generated, and they are not passed to the underlying &lt;code&gt;range-diff&lt;/code&gt; machinery used to generate the cover-letter material (this may change in the future).</source>
          <target state="translated">명령에 전달 된 diff 옵션은 &lt;code&gt;format-patch&lt;/code&gt; 의 1 차 제품 이 생성되는 방법에 영향을 미치며 , 커버 레터 자료를 생성하는 데 사용 되는 기본 &lt;code&gt;range-diff&lt;/code&gt; 기계로 전달되지 않습니다 (향후 변경 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="e0e05126bbcc50063c2790c39405469ee70a21a8" translate="yes" xml:space="preserve">
          <source>Note that during &lt;code&gt;git rebase&lt;/code&gt; and &lt;code&gt;git pull --rebase&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt; and &lt;code&gt;theirs&lt;/code&gt; may appear swapped. See the explanation of the same options in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; for details.</source>
          <target state="translated">시 유의 &lt;code&gt;git rebase&lt;/code&gt; 와 &lt;code&gt;git pull --rebase&lt;/code&gt; , &lt;code&gt;ours&lt;/code&gt; 하고 &lt;code&gt;theirs&lt;/code&gt; 교환 나타날 수 있습니다. 자세한 내용은 &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; 에서 동일한 옵션에 대한 설명을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="1af7aa20d72debc79fb9171e27e72669f87bd742" translate="yes" xml:space="preserve">
          <source>Note that during &lt;code&gt;git rebase&lt;/code&gt; and &lt;code&gt;git pull --rebase&lt;/code&gt;, &lt;code&gt;ours&lt;/code&gt; and &lt;code&gt;theirs&lt;/code&gt; may appear swapped; &lt;code&gt;--ours&lt;/code&gt; gives the version from the branch the changes are rebased onto, while &lt;code&gt;--theirs&lt;/code&gt; gives the version from the branch that holds your work that is being rebased.</source>
          <target state="translated">참고 그 동안 &lt;code&gt;git rebase&lt;/code&gt; 와 &lt;code&gt;git pull --rebase&lt;/code&gt; , &lt;code&gt;ours&lt;/code&gt; 와 &lt;code&gt;theirs&lt;/code&gt; 교환 나타날 수 있습니다; &lt;code&gt;--ours&lt;/code&gt; 는 변경 사항이 기반으로 하는 지점의 버전을 제공하는 반면, &lt;code&gt;--theirs&lt;/code&gt; 는 기반이되는 작업을 보유한 지점의 버전을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c0c3e4b221eecb8ab2fd8007bde41fbeccbc289b" translate="yes" xml:space="preserve">
          <source>Note that earlier implementation left a broken pair as a separate creation and deletion patches. This was an unnecessary hack and the latest implementation always merges all the broken pairs back into modifications, but the resulting patch output is formatted differently for easier review in case of such a complete rewrite by showing the entire contents of old version prefixed with &lt;code&gt;-&lt;/code&gt;, followed by the entire contents of new version prefixed with &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">이전 구현에서는 깨진 쌍이 별도의 작성 및 삭제 패치로 남았습니다. 이것은 불필요한 해킹했다 최신 구현은 항상 모든 깨진 쌍 수정에 다시 병합 있지만 결과 패치 출력이 접두사 이전 버전의 전체 내용을 보여줌으로써 이러한 완전히 재 작성의 경우 쉽게 검토를 위해 다른 포맷 &lt;code&gt;-&lt;/code&gt; , 다음을 접두사 새 버전의 전체 내용에 의해 &lt;code&gt;+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e94eb3093be7f837a0c2027288d60b6c3b52e2c" translate="yes" xml:space="preserve">
          <source>Note that earlier versions of this command did not complain and produced incorrect results if you gave these options.</source>
          <target state="translated">이 명령의 이전 버전은 이러한 옵션을 제공 한 경우 불평하지 않고 잘못된 결과를 생성했습니다.</target>
        </trans-unit>
        <trans-unit id="5d58dd5b84f29e01b510ca03eab20796ad3c7cbe" translate="yes" xml:space="preserve">
          <source>Note that extra commits can be shown to give a meaningful history.</source>
          <target state="translated">의미있는 기록을 제공하기 위해 추가 커밋이 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d8bcfac8a1a61a9e4be4013c3b0af7c68e4f7e1" translate="yes" xml:space="preserve">
          <source>Note that fast-forward updates do not create a merge commit and therefore there is no way to stop those merges with --no-commit. Thus, if you want to ensure your branch is not changed or updated by the merge command, use --no-ff with --no-commit.</source>
          <target state="translated">빨리 감기 업데이트는 병합 커밋을 만들지 않으므로 --no-commit으로 병합을 중지 할 수있는 방법이 없습니다. 따라서 merge 명령으로 분기를 변경하거나 업데이트하지 않으려면 --no-ff를 --no-commit과 함께 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f0d1c52e1eb6b4521a19e733ce553d5995206cf5" translate="yes" xml:space="preserve">
          <source>Note that fast-import automatically switches packfiles when the current packfile reaches --max-pack-size, or 4 GiB, whichever limit is smaller. During an automatic packfile switch fast-import does not update the branch refs, tags or marks.</source>
          <target state="translated">현재 팩 파일이 --max-pack-size 또는 4GiB (둘 중 더 작은 값)에 도달하면 빠른 가져 오기에서 팩 파일을 자동으로 전환합니다. 자동 팩 파일 전환 중에 빠른 가져 오기는 분기 참조, 태그 또는 마크를 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6615d1d4a8cbe8f9f5da36594407e26f3b365d70" translate="yes" xml:space="preserve">
          <source>Note that git log starts with the most recent commit and works backwards through the parents; however, since Git history can contain multiple independent lines of development, the particular order that commits are listed in may be somewhat arbitrary.</source>
          <target state="translated">자식 로그는 가장 최근의 커밋으로 시작하여 부모를 통해 거꾸로 작동합니다. 그러나 Git 히스토리에는 여러 개의 독립적 인 개발 라인이 포함될 수 있으므로 커밋이 나열되는 특정 순서는 다소 임의적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6e44338fe1bf08aabf78cd81639eb77b1309fea" translate="yes" xml:space="preserve">
          <source>Note that git pull always merges into the current branch, regardless of what else is given on the command line.</source>
          <target state="translated">git pull은 명령 줄에 무엇이 다른지에 관계없이 항상 현재 분기로 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="bcdb8efaa60d12b40472e9e7be3ed7ef20fcfd01" translate="yes" xml:space="preserve">
          <source>Note that git-svn keeps track of the highest revision in which a branch or tag has appeared. If the subset of branches or tags is changed after fetching, then $GIT_DIR/svn/.metadata must be manually edited to remove (or reset) branches-maxRev and/or tags-maxRev as appropriate.</source>
          <target state="translated">git-svn은 브랜치 또는 태그가 나타난 가장 높은 버전을 추적합니다. 페치 후 브랜치 또는 태그의 서브 세트가 변경되면, 적절하게 branch-maxRev 및 / 또는 tags-maxRev를 제거 (또는 재설정)하기 위해 $ GIT_DIR / svn / .metadata를 수동으로 편집해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d6b14c8954c11ebf9dc491ca128004d883ac7cd" translate="yes" xml:space="preserve">
          <source>Note that he doesn&amp;rsquo;t need to give the path to Alice&amp;rsquo;s repository; when Bob cloned Alice&amp;rsquo;s repository, Git stored the location of her repository in the repository configuration, and that location is used for pulls:</source>
          <target state="translated">Alice의 저장소에 경로를 제공 할 필요는 없습니다. Bob이 Alice의 리포지토리를 복제 할 때 Git은 리포지토리 구성에 리포지토리의 위치를 ​​저장했으며 해당 위치는 풀에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d033887586c63461935e98a544790f02b6895719" translate="yes" xml:space="preserve">
          <source>Note that if no extensions are specified in the config file, then &lt;code&gt;core.repositoryformatversion&lt;/code&gt; SHOULD be set to &lt;code&gt;0&lt;/code&gt; (setting it to &lt;code&gt;1&lt;/code&gt; provides no benefit, and makes the repository incompatible with older implementations of git).</source>
          <target state="translated">구성 파일에 확장명이 지정되어 있지 않으면 &lt;code&gt;core.repositoryformatversion&lt;/code&gt; 을 &lt;code&gt;0&lt;/code&gt; 으로 설정해야합니다 ( &lt;code&gt;1&lt;/code&gt; 로 설정하면 아무런 이점이 없으며 리포지토리가 이전의 git 구현과 호환되지 않음).</target>
        </trans-unit>
        <trans-unit id="855e515073658cd86a49dd1065464c65266acbcf" translate="yes" xml:space="preserve">
          <source>Note that if the &lt;code&gt;bidi-import&lt;/code&gt; capability is used the complete batch sequence has to be buffered before starting to send data to fast-import to prevent mixing of commands and fast-import responses on the helper&amp;rsquo;s stdin.</source>
          <target state="translated">경우주의 &lt;code&gt;bidi-import&lt;/code&gt; 기능을 사용하는 전체 배치 순서가있다는 도우미의 표준 입력에서 명령과 빠른 가져 오기 응답의 혼합을 방지하기 위해 빠른 가져 오기에 데이터를 전송을 시작하기 전에 버퍼링합니다.</target>
        </trans-unit>
        <trans-unit id="b689c65aa31e82a2dbc37c89c0ac3187b41716e6" translate="yes" xml:space="preserve">
          <source>Note that if the current branch head was your only reference to a particular point in history, then resetting that branch may leave you with no way to find the history it used to point to; so use this command carefully.</source>
          <target state="translated">현재 지사 헤드가 내역의 특정 지점에 대한 유일한 참조 인 경우 해당 지사를 재설정하면 이전에 지정한 내역을 찾을 수있는 방법이 없을 수 있습니다. 이 명령을주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e6c226fbc041b7aed3f8d988d110ae660c99fecc" translate="yes" xml:space="preserve">
          <source>Note that if the number of kept packs is more than gc.autoPackLimit, this configuration variable is ignored, all packs except the base pack will be repacked. After this the number of packs should go below gc.autoPackLimit and gc.bigPackThreshold should be respected again.</source>
          <target state="translated">유지 된 팩 수가 gc.autoPackLimit보다 많은 경우이 구성 변수는 무시되고 기본 팩을 제외한 모든 팩이 다시 포장됩니다. 그런 다음 팩 수가 gc.autoPackLimit 아래로 내려 가고 gc.bigPackThreshold를 다시 존중해야합니다.</target>
        </trans-unit>
        <trans-unit id="876a2eaaf30082c69c38a89b274fd268226ca0ba" translate="yes" xml:space="preserve">
          <source>Note that if you also want to skip the first commit of the range you would issue the command:</source>
          <target state="translated">범위의 첫 번째 커밋을 건너 뛰려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="56435425656273c2a6900d84ec2f6b2bfe4a637a" translate="yes" xml:space="preserve">
          <source>Note that if you are verifying a name from an untrusted source, it is wise to use &lt;code&gt;--end-of-options&lt;/code&gt; so that the name argument is not mistaken for another option.</source>
          <target state="translated">신뢰할 수없는 소스에서 이름을 확인하는 경우 이름 인수가 다른 옵션으로 오인되지 않도록 &lt;code&gt;--end-of-options&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="24a094d13c9af525346a8eec9bbd2cdea3f73c32" translate="yes" xml:space="preserve">
          <source>Note that in all cases, the editor value will be passed to the shell, so any arguments containing spaces should be appropriately quoted. Additionally, if your editor normally detaches from the terminal when invoked, you should specify it with an argument that makes it not do that, or else Git will not see any changes. An example of a configuration addressing both of these issues on Windows would be the configuration &lt;code&gt;&quot;C:\Program Files\Vim\gvim.exe&quot; --nofork&lt;/code&gt;, which quotes the filename with spaces and specifies the &lt;code&gt;--nofork&lt;/code&gt; option to avoid backgrounding the process.</source>
          <target state="translated">모든 경우에 편집기 값은 셸로 전달되므로 공백이 포함 된 인수는 적절하게 인용되어야합니다. 또한 편집기가 호출 될 때 일반적으로 터미널에서 분리되는 경우이를 수행하지 않는 인수로 지정해야합니다. 그렇지 않으면 Git에서 변경 사항을 볼 수 없습니다. Windows에서 이러한 문제를 모두 해결 구성의 예는 구성 될 &lt;code&gt;&quot;C:\Program Files\Vim\gvim.exe&quot; --nofork&lt;/code&gt; , 공간과 지정와 파일 이름을 인용 &lt;code&gt;--nofork&lt;/code&gt; 의 를 배경 처리하지 않도록하는 옵션을 방법.</target>
        </trans-unit>
        <trans-unit id="102fd7adeeb68915f128c7eebf4ae04f1c363d22" translate="yes" xml:space="preserve">
          <source>Note that in general, Alice would want her local changes committed before initiating this &quot;pull&quot;. If Bob&amp;rsquo;s work conflicts with what Alice did since their histories forked, Alice will use her working tree and the index to resolve conflicts, and existing local changes will interfere with the conflict resolution process (Git will still perform the fetch but will refuse to merge --- Alice will have to get rid of her local changes in some way and pull again when this happens).</source>
          <target state="translated">일반적으로 Alice는이 &quot;풀 (pull)&quot;을 시작하기 전에 로컬 변경 사항을 커밋하려고합니다. Bob의 작업이 내역을 포크 한 이후 Alice가 수행 한 작업과 충돌하는 경우 Alice는 작업 트리와 색인을 사용하여 충돌을 해결하며 기존의 로컬 변경 사항이 충돌 해결 프로세스를 방해합니다 (Git은 여전히 ​​페치를 수행하지만 병합을 거부 함- -Alice는 어떤 방식 으로든 로컬 변경 사항을 제거하고 이러한 상황이 발생하면 다시 당겨야합니다.</target>
        </trans-unit>
        <trans-unit id="51fccf4fe2d201a349cf25a2b82190079f387e94" translate="yes" xml:space="preserve">
          <source>Note that in older documentation you may see the index called the &quot;current directory cache&quot; or just the &quot;cache&quot;. It has three important properties:</source>
          <target state="translated">이전 문서에는 &quot;현재 디렉토리 캐시&quot;또는 &quot;캐시&quot;라는 색인이 표시 될 수 있습니다. 세 가지 중요한 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="86ef833f0b802486b88e99a2562a2a2a3eec1f68" translate="yes" xml:space="preserve">
          <source>Note that in this file, the exception for &lt;code&gt;core.bare&lt;/code&gt; and &lt;code&gt;core.worktree&lt;/code&gt; is gone. If they exist in &lt;code&gt;$GIT_DIR/config&lt;/code&gt;, you must move them to the &lt;code&gt;config.worktree&lt;/code&gt; of the main working tree. You may also take this opportunity to review and move other configuration that you do not want to share to all working trees:</source>
          <target state="translated">이 파일에서 &lt;code&gt;core.bare&lt;/code&gt; 및 &lt;code&gt;core.worktree&lt;/code&gt; 에 대한 예외 가 사라졌습니다. &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 존재하는 경우 기본 작업 트리 의 &lt;code&gt;config.worktree&lt;/code&gt; 로 이동해야합니다 . 이 기회에 모든 작업 트리에 공유하지 않을 다른 구성을 검토하고 이동할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="33bb6a06b88e89af07ea98fc22445ba64a91b75d" translate="yes" xml:space="preserve">
          <source>Note that in this file, the exception for &lt;code&gt;core.bare&lt;/code&gt; and &lt;code&gt;core.worktree&lt;/code&gt; is gone. If you have them in $GIT_DIR/config before, you must move them to the &lt;code&gt;config.worktree&lt;/code&gt; of the main working tree. You may also take this opportunity to review and move other configuration that you do not want to share to all working trees:</source>
          <target state="translated">이 파일에서 &lt;code&gt;core.bare&lt;/code&gt; 및 &lt;code&gt;core.worktree&lt;/code&gt; 에 대한 예외 는 사라졌습니다. 이전에 $ GIT_DIR / config 에있는 경우 기본 작업 트리 의 &lt;code&gt;config.worktree&lt;/code&gt; 로 이동해야합니다 . 이 기회를 이용하여 모든 작업 트리에 공유하고 싶지 않은 다른 구성을 검토하고 이동할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="22d9723cd6f0838bff4c15676f064d8d67f92e00" translate="yes" xml:space="preserve">
          <source>Note that increasing this value will increase the memory used on every relevant push that Git does over HTTP or HTTPS, since the entire buffer is allocated regardless of whether or not it is all used. Thus, it&amp;rsquo;s best to leave it at the default unless you are sure you need a different value.</source>
          <target state="translated">이 값을 늘리면 전체 버퍼가 모두 사용되었는지 여부에 관계없이 전체 버퍼가 할당되므로 Git이 HTTP 또는 HTTPS를 통해 수행하는 모든 관련 푸시에 사용되는 메모리가 증가합니다. 따라서 다른 값이 필요하다고 확신하지 않는 한 기본값으로 두는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f62684e2b0c86eaa1fac93a58127ba986d09144a" translate="yes" xml:space="preserve">
          <source>Note that it is currently &lt;strong&gt;always&lt;/strong&gt; an array reference, even if feature doesn&amp;rsquo;t accept any configuration parameters, and 'default' is used only to turn it on or off. In such case you turn feature on by setting this element to &lt;code&gt;[1]&lt;/code&gt;, and torn it off by setting it to &lt;code&gt;[0]&lt;/code&gt;. See also the passage about the &quot;blame&quot; feature in the &quot;Examples&quot; section.</source>
          <target state="translated">기능이 구성 매개 변수를 허용하지 않더라도 현재 &lt;strong&gt;항상&lt;/strong&gt; 배열 참조이며 'default'는 켜거나 끄는 데만 사용됩니다. 이 경우이 요소를 &lt;code&gt;[1]&lt;/code&gt; 로 설정하여 기능을 설정하고 &lt;code&gt;[0]&lt;/code&gt; 으로 설정하여 해제하십시오 . &quot;예제&quot;섹션의 &quot;비난&quot;기능에 대한 구절도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c6d71837c5b2acf93d8b7a746fdb13a8f313316a" translate="yes" xml:space="preserve">
          <source>Note that it is possible for refname to not have sha1-new when this hook runs. This can easily occur if another user modifies the ref after it was updated by &lt;code&gt;git-receive-pack&lt;/code&gt;, but before the hook was able to evaluate it. It is recommended that hooks rely on sha1-new rather than the current value of refname.</source>
          <target state="translated">이 후크가 실행될 때 참조 이름에 sha1-new가 없을 수 있습니다. 다른 사용자가 &lt;code&gt;git-receive-pack&lt;/code&gt; 에 의해 업데이트 된 후 , 후크가 평가하기 전에 참조를 수정하면 쉽게 발생할 수 있습니다 . 후크는 현재 refname 값이 아닌 sha1-new를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="288f25c901caafda3b52f9e96d7bc31178f41bbc" translate="yes" xml:space="preserve">
          <source>Note that merge commits may have more than one parent:</source>
          <target state="translated">병합 커밋에는 둘 이상의 부모가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7a71f0bea03e654472a727d94dd31231e4320a4" translate="yes" xml:space="preserve">
          <source>Note that multiple helpers may be defined. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for details and examples.</source>
          <target state="translated">여러 도우미를 정의 할 수 있습니다. 자세한 내용과 예는 &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b4bd4c01bcc139c9e086b4c697c46e8ed5645dbb" translate="yes" xml:space="preserve">
          <source>Note that namespaces which include a &lt;code&gt;/&lt;/code&gt; will expand to a hierarchy of namespaces; for example, &lt;code&gt;GIT_NAMESPACE=foo/bar&lt;/code&gt; will store refs under &lt;code&gt;refs/namespaces/foo/refs/namespaces/bar/&lt;/code&gt;. This makes paths in &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; behave hierarchically, so that cloning with &lt;code&gt;GIT_NAMESPACE=foo/bar&lt;/code&gt; produces the same result as cloning with &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; and cloning from that repo with &lt;code&gt;GIT_NAMESPACE=bar&lt;/code&gt;. It also avoids ambiguity with strange namespace paths such as &lt;code&gt;foo/refs/heads/&lt;/code&gt;, which could otherwise generate directory/file conflicts within the &lt;code&gt;refs&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; 를 포함하는 네임 스페이스는 네임 스페이스의 계층 구조로 확장됩니다. 예를 들어, &lt;code&gt;GIT_NAMESPACE=foo/bar&lt;/code&gt; 는 &lt;code&gt;refs/namespaces/foo/refs/namespaces/bar/&lt;/code&gt; 아래에 ref 를 저장 합니다. 이렇게하면 &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; 의 경로가 계층 적으로 작동하므로 &lt;code&gt;GIT_NAMESPACE=foo/bar&lt;/code&gt; 를 사용한 복제는 &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; 를 사용한 복제 및 &lt;code&gt;GIT_NAMESPACE=bar&lt;/code&gt; 를 사용 하여 해당 리포지토리 에서 복제하는 것과 동일한 결과를 생성합니다 . 또한 &lt;code&gt;foo/refs/heads/&lt;/code&gt; 와 같은 이상한 네임 스페이스 경로에 대한 모호함을 피합니다. 그렇지 않으면 &lt;code&gt;refs&lt;/code&gt; 디렉토리 내에서 디렉토리 / 파일 충돌이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5960cd2f6a18c56540790aa3e8525ad5bfd7623b" translate="yes" xml:space="preserve">
          <source>Note that no attempts whatsoever are made to validate the encoding.</source>
          <target state="translated">인코딩의 유효성을 검사하려는 시도는 없습니다.</target>
        </trans-unit>
        <trans-unit id="a90bb6c9021795be1cb1c05d155b4badc4462ac4" translate="yes" xml:space="preserve">
          <source>Note that not all diffs can feature all types. For instance, diffs from the index to the working tree can never have Added entries (because the set of paths included in the diff is limited by what is in the index). Similarly, copied and renamed entries cannot appear if detection for those types is disabled.</source>
          <target state="translated">모든 diff가 모든 유형을 특징으로하는 것은 아닙니다. 예를 들어, 인덱스에서 작업 트리로의 diff는 추가 된 항목을 가질 수 없습니다 (diff에 포함 된 경로 세트가 인덱스에있는 경로에 의해 제한되기 때문에). 마찬가지로 해당 유형에 대한 검색이 비활성화 된 경우 복사 및 이름이 바뀐 항목을 표시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b214bd38041e6a3ecd59f0a8d74547fecd3e66a2" translate="yes" xml:space="preserve">
          <source>Note that omitting the &lt;code&gt;=&lt;/code&gt; in &lt;code&gt;git -c foo.bar ...&lt;/code&gt; is allowed and sets &lt;code&gt;foo.bar&lt;/code&gt; to the boolean true value (just like &lt;code&gt;[foo]bar&lt;/code&gt; would in a config file). Including the equals but with an empty value (like &lt;code&gt;git -c
foo.bar= ...&lt;/code&gt;) sets &lt;code&gt;foo.bar&lt;/code&gt; to the empty string which &lt;code&gt;git config
--type=bool&lt;/code&gt; will convert to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">생략 유의 &lt;code&gt;=&lt;/code&gt; 에서 &lt;code&gt;git -c foo.bar ...&lt;/code&gt; 허용 세트된다 &lt;code&gt;foo.bar&lt;/code&gt; 에 부울 참 값 (단지 추천 &lt;code&gt;[foo]bar&lt;/code&gt; 설정 파일에서와). equals를 포함하지만 빈 값 ( &lt;code&gt;git -c foo.bar= ...&lt;/code&gt; ) 을 포함하면 &lt;code&gt;foo.bar&lt;/code&gt; 를 빈 문자열로 &lt;code&gt;git config --type=bool&lt;/code&gt; 합니다. git config --type = bool 은 &lt;code&gt;false&lt;/code&gt; 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="1650f0c21da45bf27c2f0a10dc06aba9ed69b7fe" translate="yes" xml:space="preserve">
          <source>Note that paths and refnames are split into tokens at slash boundaries. The command above would anonymize &lt;code&gt;subdir/secret.c&lt;/code&gt; as something like &lt;code&gt;path123/bar.c&lt;/code&gt;; you could then search for &lt;code&gt;bar.c&lt;/code&gt; in the anonymized repository to determine the final pathname.</source>
          <target state="translated">경로와 참조 이름은 슬래시 경계에서 토큰으로 분할됩니다. 위의 명령은 &lt;code&gt;subdir/secret.c&lt;/code&gt; 를 &lt;code&gt;path123/bar.c&lt;/code&gt; 와 같이 익명화합니다 . 그런 다음 익명화 된 저장소에서 &lt;code&gt;bar.c&lt;/code&gt; 를 검색 하여 최종 경로 이름을 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d893e89ed900e1f0840df95a39350717d32e84c" translate="yes" xml:space="preserve">
          <source>Note that per repository configuration can be set in &lt;code&gt;$GIT_DIR/cloneurl&lt;/code&gt; file, or as values of multi-value &lt;code&gt;gitweb.url&lt;/code&gt; configuration variable in project config. Per-repository configuration takes precedence over value composed from &lt;code&gt;@git_base_url_list&lt;/code&gt; elements and project name.</source>
          <target state="translated">저장소 당 구성은 &lt;code&gt;$GIT_DIR/cloneurl&lt;/code&gt; 파일에서 설정하거나 프로젝트 구성에서 다중 값 &lt;code&gt;gitweb.url&lt;/code&gt; 구성 변수의 값으로 설정할 수 있습니다. 저장소 별 구성은 &lt;code&gt;@git_base_url_list&lt;/code&gt; 요소 및 프로젝트 이름 으로 구성된 값보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="882882a5ca6dfe25f69ac7554d444a260301cac9" translate="yes" xml:space="preserve">
          <source>Note that raising this limit is only effective for disabling chunked transfer encoding and therefore should be used only where the remote server or a proxy only supports HTTP/1.0 or is noncompliant with the HTTP standard. Raising this is not, in general, an effective solution for most push problems, but can increase memory consumption significantly since the entire buffer is allocated even for small pushes.</source>
          <target state="translated">이 제한을 높이는 것은 청크 전송 인코딩을 비활성화하는 경우에만 효과적이므로 원격 서버 또는 프록시가 HTTP / 1.0 만 지원하거나 HTTP 표준을 준수하지 않는 경우에만 사용해야합니다. 일반적으로이 값을 높이는 것은 대부분의 푸시 문제에 대한 효과적인 솔루션은 아니지만 작은 푸시에도 전체 버퍼가 할당되기 때문에 메모리 사용량을 크게 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fccadef8ff02c3c7b5e8091c077ff771f4d090ed" translate="yes" xml:space="preserve">
          <source>Note that rule 3 disallows many cases that do not have any privacy implications. These rules are subject to change in future versions of git, and the server accessed by &lt;code&gt;git archive --remote&lt;/code&gt; may or may not follow these exact rules.</source>
          <target state="translated">규칙 3은 개인 정보 보호에 영향을 미치지 않는 많은 경우를 허용하지 않습니다. 이 규칙은 향후 버전의 git에서 변경 될 수 있으며 &lt;code&gt;git archive --remote&lt;/code&gt; 로 액세스하는 서버 는 이러한 정확한 규칙을 따르거나 따르지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b2cd45b5672bcfb50850c37a2d3873eae0b00dc" translate="yes" xml:space="preserve">
          <source>Note that running &lt;code&gt;git repack&lt;/code&gt; without the &lt;code&gt;--local&lt;/code&gt; option in a repository cloned with &lt;code&gt;--shared&lt;/code&gt; will copy objects from the source repository into a pack in the cloned repository, removing the disk space savings of &lt;code&gt;clone --shared&lt;/code&gt;. It is safe, however, to run &lt;code&gt;git gc&lt;/code&gt;, which uses the &lt;code&gt;--local&lt;/code&gt; option by default.</source>
          <target state="translated">&lt;code&gt;--shared&lt;/code&gt; 로 복제 된 저장소에서 &lt;code&gt;--local&lt;/code&gt; 옵션 없이 &lt;code&gt;git repack&lt;/code&gt; 을 실행 하면 소스 저장소의 오브젝트가 복제 된 저장소의 팩으로 복사되어 &lt;code&gt;clone --shared&lt;/code&gt; 의 디스크 공간 절약이 제거 됩니다. 그러나 기본적으로 &lt;code&gt;--local&lt;/code&gt; 옵션 을 사용하는 &lt;code&gt;git gc&lt;/code&gt; 를 실행하는 것이 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="140dadc93eb0ab3b9abb37d56f2b3ec8284a753b" translate="yes" xml:space="preserve">
          <source>Note that since this operation is very I/O expensive, it might be a good idea to redirect the temporary directory off-disk with the &lt;code&gt;-d&lt;/code&gt; option, e.g. on tmpfs. Reportedly the speedup is very noticeable.</source>
          <target state="translated">이 작업은 I / O 비용이 많이 들기 때문에 &lt;code&gt;-d&lt;/code&gt; 옵션을 사용하여 임시 디렉토리를 디스크 외부로 리디렉션하는 것이 좋습니다 ( 예 : tmpfs). 보도에 따르면 속도가 매우 눈에.니다.</target>
        </trans-unit>
        <trans-unit id="406b2d499d377ca290ed5b4924c72cd2cd51a43f" translate="yes" xml:space="preserve">
          <source>Note that some configuration can be controlled on per-repository rather than gitweb-wide basis: see &quot;Per-repository gitweb configuration&quot; subsection on &lt;a href=&quot;gitweb&quot;&gt;gitweb[1]&lt;/a&gt; manpage.</source>
          <target state="translated">일부 구성은 gitweb 전체가 아닌 저장소별로 제어 할 수 있습니다. &lt;a href=&quot;gitweb&quot;&gt;gitweb [1]&lt;/a&gt; 맨 페이지의 &quot;리포지토리 당 gitweb 구성&quot;하위 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ebdc2effe725ce03b669fc182e42bedc757b01ae" translate="yes" xml:space="preserve">
          <source>Note that some subcommand (e.g. &lt;code&gt;git grep&lt;/code&gt;) may behave differently when there are things on the command line other than &lt;code&gt;-h&lt;/code&gt;, but &lt;code&gt;git
subcmd -h&lt;/code&gt; without anything else on the command line is meant to consistently give the usage.</source>
          <target state="translated">일부 하위 명령 (예를 들어 있습니다 &lt;code&gt;git grep&lt;/code&gt; ) 상황이 아닌 명령 행에있을 때 다르게 동작 할 수 있습니다 &lt;code&gt;-h&lt;/code&gt; 하지만, &lt;code&gt;git subcmd -h&lt;/code&gt; 명령 행에서 아무것도없이 지속적으로 사용을 제공하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="dd6bdc1118aa11562877a299d06f5353533bbf79" translate="yes" xml:space="preserve">
          <source>Note that specifying a protocol is mandatory and if the URL doesn&amp;rsquo;t specify a hostname (e.g., &quot;cert:///path/to/file&quot;) the credential will contain a hostname attribute whose value is an empty string.</source>
          <target state="translated">프로토콜을 지정하는 것은 필수이며 URL이 호스트 이름 (예 : &quot;cert : /// path / to / file&quot;)을 지정하지 않으면 자격 증명에 값이 빈 문자열 인 호스트 이름 속성이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0d8f5c59efaf04f91fb17771a5f9956f75377d81" translate="yes" xml:space="preserve">
          <source>Note that terminology has changed since that revision. For example, the README in that revision uses the word &quot;changeset&quot; to describe what we now call a &lt;a href=&quot;#def_commit_object&quot;&gt;commit&lt;/a&gt;.</source>
          <target state="translated">해당 개정 이후로 용어가 변경되었습니다. 예를 들어,이 개정판의 README는 &quot;changeset&quot;이라는 단어를 사용하여 현재 &lt;a href=&quot;#def_commit_object&quot;&gt;commit&lt;/a&gt; 이라고하는 것을 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="9142b2dfed27b980836bfa3cd8737a30cbbd1e38" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;name&lt;/code&gt; forms of these variables conventionally refer to some form of a personal name. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; and the environment variables section of &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for more information on these settings and the &lt;code&gt;credential.username&lt;/code&gt; option if you&amp;rsquo;re looking for authentication credentials instead.</source>
          <target state="translated">이러한 변수 의 &lt;code&gt;name&lt;/code&gt; 형식은 일반적으로 개인 이름의 일부 형식을 참조합니다. 이러한 설정에 대한 자세한 내용 은 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 및 &lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; 의 환경 변수 섹션 을 참조하고 대신 인증 자격 증명을 찾는 경우 &lt;code&gt;credential.username&lt;/code&gt; 옵션 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1162a2144d0b881d5670bbd9b0805334b2b73beb" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;t_rel&lt;/code&gt; field contains the observed run time in seconds for the child process (starting before the fork/exec/spawn and stopping after the waitpid() and includes OS process creation overhead). So this time will be slightly larger than the atexit time reported by the child process itself.</source>
          <target state="translated">점을 유의 &lt;code&gt;t_rel&lt;/code&gt; 의 필드는 자식 프로세스 초 관찰 런타임 포함 (포크 / 간부 / 산란되기 전에 시작 및 정지를 waitpid를 후 () 및 OS 프로세스 생성 오버 헤드를 포함한다). 따라서이 시간은 자식 프로세스 자체에서보고 한 수렴 시간보다 약간 더 큽니다.</target>
        </trans-unit>
        <trans-unit id="b7757b33b688da6e41f6e15271bd961d7647767a" translate="yes" xml:space="preserve">
          <source>Note that the SVN URL of the commiturl config key includes the SVN branch. If you rather want to set the commit URL for an entire SVN repository use svn-remote.&amp;lt;name&amp;gt;.pushurl instead.</source>
          <target state="translated">commiturl 구성 키의 SVN URL에는 SVN 분기가 포함됩니다. 전체 SVN 저장소에 커밋 URL을 설정하려면 대신 svn-remote. &amp;lt;name&amp;gt; .pushurl을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cb5d63c2ce1d70a7eb8e0b6357957166a5a229f7" translate="yes" xml:space="preserve">
          <source>Note that the asterisk &lt;code&gt;*&lt;/code&gt; is quoted from the shell in this example; this lets Git, and not the shell, expand the pathnames of files and subdirectories under the &lt;code&gt;Documentation/&lt;/code&gt; directory.</source>
          <target state="translated">이 예에서 별표 &lt;code&gt;*&lt;/code&gt; 는 셸에서 인용됩니다. 이를 통해 쉘이 아닌 Git이 &lt;code&gt;Documentation/&lt;/code&gt; 디렉토리 아래에있는 파일 및 하위 디렉토리의 경로 이름을 확장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce32bdb056375627c69f9422ed26926b9107752d" translate="yes" xml:space="preserve">
          <source>Note that the asterisk &lt;code&gt;*&lt;/code&gt; is quoted from the shell in this example; this lets the command include the files from subdirectories of &lt;code&gt;Documentation/&lt;/code&gt; directory.</source>
          <target state="translated">이 예에서 별표 &lt;code&gt;*&lt;/code&gt; 는 셸에서 인용됩니다. 그러면 명령에 &lt;code&gt;Documentation/&lt;/code&gt; 디렉토리의 하위 디렉토리에있는 파일이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="8938c6c44864ae040ef79f140140b8a3da4caab5" translate="yes" xml:space="preserve">
          <source>Note that the commit message will already be filled in for you with some information about the merge. Normally you can just use this default message unchanged, but you may add additional commentary of your own if desired.</source>
          <target state="translated">커밋 메시지는 병합에 대한 정보로 이미 채워져 있습니다. 일반적으로이 기본 메시지를 변경하지 않고 사용할 수 있지만 원하는 경우 자신 만의 주석을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="131272668a67eaa5ac9294087a9ff4488c82c210" translate="yes" xml:space="preserve">
          <source>Note that the example that we will use is really a toy example, we will be looking for the first commit that has a version like &quot;2.6.26-something&quot;, that is the commit that has a &quot;SUBLEVEL = 26&quot; line in the top level Makefile. This is a toy example because there are better ways to find this commit with Git than using &quot;git bisect&quot; (for example &quot;git blame&quot; or &quot;git log -S&amp;lt;string&amp;gt;&quot;).</source>
          <target state="translated">우리가 사용할 예제는 실제로 장난감 예제이며, &quot;2.6.26-something&quot;과 같은 버전을 가진 첫 번째 커밋, 즉 &quot;SUBLEVEL = 26&quot;줄이있는 커밋을 찾을 것입니다. 최상위 Makefile. &quot;git bisect&quot;(예 : &quot;git blame&quot;또는 &quot;git log -S &amp;lt;string&amp;gt;&quot;)를 사용하는 것보다 Git으로이 커밋을 찾는 더 좋은 방법이 있기 때문에 장난감 예제입니다.</target>
        </trans-unit>
        <trans-unit id="5e386156a3e0996458a30d74f4a22474e7420343" translate="yes" xml:space="preserve">
          <source>Note that the files all have mode 644 or 755: Git actually only pays attention to the executable bit.</source>
          <target state="translated">파일은 모두 모드 644 또는 755를 갖습니다. Git은 실제로 실행 비트에만주의를 기울입니다.</target>
        </trans-unit>
        <trans-unit id="d2e57a867612d1ae307185458bab810ae89e20a5" translate="yes" xml:space="preserve">
          <source>Note that the first word of an alias does not necessarily have to be a command. It can be a command-line option that will be passed into the invocation of &lt;code&gt;git&lt;/code&gt;. In particular, this is useful when used with &lt;code&gt;-c&lt;/code&gt; to pass in one-time configurations or &lt;code&gt;-p&lt;/code&gt; to force pagination. For example, &lt;code&gt;loud-rebase = -c commit.verbose=true rebase&lt;/code&gt; can be defined such that running &lt;code&gt;git loud-rebase&lt;/code&gt; would be equivalent to &lt;code&gt;git -c commit.verbose=true rebase&lt;/code&gt;. Also, &lt;code&gt;ps = -p status&lt;/code&gt; would be a helpful alias since &lt;code&gt;git ps&lt;/code&gt; would paginate the output of &lt;code&gt;git status&lt;/code&gt; where the original command does not.</source>
          <target state="translated">별칭의 첫 단어가 반드시 명령 일 필요는 없습니다. &lt;code&gt;git&lt;/code&gt; 호출로 전달되는 명령 행 옵션 일 수 있습니다 . 특히 &lt;code&gt;-c&lt;/code&gt; 와 함께 사용하여 일회성 구성을 전달하거나 &lt;code&gt;-p&lt;/code&gt; 를 사용하여 페이지 매김을 강제 할 때 유용합니다 . 예를 들어, &lt;code&gt;loud-rebase = -c commit.verbose=true rebase&lt;/code&gt; 는 &lt;code&gt;git loud-rebase&lt;/code&gt; 실행 이 &lt;code&gt;git -c commit.verbose=true rebase&lt;/code&gt; 와 같도록 정의 될 수 있습니다 . 또한 &lt;code&gt;ps = -p status&lt;/code&gt; 는 &lt;code&gt;git ps&lt;/code&gt; 가 원래 명령이 아닌 &lt;code&gt;git status&lt;/code&gt; 의 출력을 페이지 매김하기 때문에 유용한 별칭 입니다.</target>
        </trans-unit>
        <trans-unit id="650b87912cfe39dc5747fbba67473a3822f86ab9" translate="yes" xml:space="preserve">
          <source>Note that the form &lt;code&gt;--filter=sparse:path=&amp;lt;path&amp;gt;&lt;/code&gt; that wants to read from an arbitrary path on the filesystem has been dropped for security reasons.</source>
          <target state="translated">형태주의 &lt;code&gt;--filter=sparse:path=&amp;lt;path&amp;gt;&lt;/code&gt; 파일 시스템에 임의의 경로에서 읽고 싶은 보안상의 이유로 삭제되었습니다.</target>
        </trans-unit>
        <trans-unit id="d8075e043d9a3ca9826ff1989c66c1905d9648ca" translate="yes" xml:space="preserve">
          <source>Note that the grafts mechanism is outdated and can lead to problems transferring objects between repositories; see &lt;a href=&quot;git-replace&quot;&gt;git-replace[1]&lt;/a&gt; for a more flexible and robust system to do the same thing.</source>
          <target state="translated">이식 메커니즘은 구식이며 리포지토리간에 개체를 전송하는 데 문제가 발생할 수 있습니다. 보다 유연하고 강력한 시스템으로 동일한 작업을 수행하려면 &lt;a href=&quot;git-replace&quot;&gt;git-replace [1]&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b0bdd8828d416a94597b15ce8aefc2c0b976fde" translate="yes" xml:space="preserve">
          <source>Note that the last point clashes with the other two: a topic that has been merged elsewhere should not be rebased. See the section on RECOVERING FROM UPSTREAM REBASE in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.</source>
          <target state="translated">마지막 지점은 다른 두 지점과 충돌합니다. 다른 곳에서 병합 된 주제는 리베이스하지 않아야합니다. &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]의&lt;/a&gt; UPSTREAM REBASE 복구 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd4901c4d1f08f37f3106399dbc26a76568f48fe" translate="yes" xml:space="preserve">
          <source>Note that the leading character does not have to be a dot; for example, you can use &lt;code&gt;--suffix=-patch&lt;/code&gt; to get &lt;code&gt;0001-description-of-my-change-patch&lt;/code&gt;.</source>
          <target state="translated">선행 문자는 점일 필요는 없습니다. 예를 들어 &lt;code&gt;--suffix=-patch&lt;/code&gt; 를 사용하면 &lt;code&gt;0001-description-of-my-change-patch&lt;/code&gt; 를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="833f1e85ef857dfcde43c87fdacaaa1075b0d6b3" translate="yes" xml:space="preserve">
          <source>Note that the maintainer(s) may impose restrictions, such as &quot;Signed-off-by&quot; requirements, that all commits/patches submitted for inclusion must adhere to. Consult your project&amp;rsquo;s documentation for more information.</source>
          <target state="translated">관리자는 &quot;서명&quot;요구 사항과 같이 제한을 위해 제출 된 모든 커밋 / 패치가 준수되어야한다는 제한을 부과 할 수 있습니다. 자세한 내용은 프로젝트 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="50f092ab1e91fa0de2c9ed05785c4a967888dc6a" translate="yes" xml:space="preserve">
          <source>Note that the name &quot;origin&quot; is just the name that Git uses by default to refer to the repository that you cloned from.</source>
          <target state="translated">&quot;origin&quot;이라는 이름은 Git이 기본적으로 복제 한 리포지토리를 나타내는 데 사용하는 이름입니다.</target>
        </trans-unit>
        <trans-unit id="22728656f144a546aef50a70cd21a26fce3a8c1d" translate="yes" xml:space="preserve">
          <source>Note that the patch is always used as-is without charset conversion, even with this flag.</source>
          <target state="translated">이 플래그를 사용하더라도 패치는 항상 문자 세트 변환없이있는 그대로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9bea9d7e3f1393135579965b1439ff9a7baaf238" translate="yes" xml:space="preserve">
          <source>Note that the push URL and the fetch URL, even though they can be set differently, must still refer to the same place. What you pushed to the push URL should be what you would see if you immediately fetched from the fetch URL. If you are trying to fetch from one place (e.g. your upstream) and push to another (e.g. your publishing repository), use two separate remotes.</source>
          <target state="translated">푸시 URL과 페치 URL은 다르게 설정할 수 있지만 여전히 동일한 위치를 참조해야합니다. 푸시 URL로 푸시 한 것은 가져 오기 URL에서 즉시 가져 왔을 때 표시되는 것이어야합니다. 한 곳 (예 : 업스트림)에서 가져오고 다른 곳 (예 : 게시 저장소)으로 가져 오려면 별도의 리모콘 두 개를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f8efe69c6940942131795b6ce6c48d7e64d9560b" translate="yes" xml:space="preserve">
          <source>Note that the reflog history is very different from normal Git history. While normal history is shared by every repository that works on the same project, the reflog history is not shared: it tells you only about how the branches in your local repository have changed over time.</source>
          <target state="translated">reflog 기록은 일반 Git 기록과 매우 다릅니다. 일반 히스토리는 동일한 프로젝트에서 작동하는 모든 저장소에서 공유되지만 reflog 히스토리는 공유되지 않습니다. 로컬 저장소의 브랜치가 시간이 지남에 따라 어떻게 변경되었는지에 대해서만 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="9a9c3b4049e20efd5a28033d7014008a8c2ac264" translate="yes" xml:space="preserve">
          <source>Note that the script (&lt;code&gt;my_script&lt;/code&gt; in the above example) should exit with code 0 if the current source code is good/old, and exit with a code between 1 and 127 (inclusive), except 125, if the current source code is bad/new.</source>
          <target state="translated">현재 소스 코드가 양호 / 이전 인 경우 스크립트 ( 위의 예에서 &lt;code&gt;my_script&lt;/code&gt; )는 코드 0으로 종료하고 현재 소스 코드가 불량 / 새로운.</target>
        </trans-unit>
        <trans-unit id="5586aefc0f8bd69c9dcf3cf3294d72d0db17f0fc" translate="yes" xml:space="preserve">
          <source>Note that the second point is true even across machines. You can duplicate a remote Git repository with &lt;strong&gt;any&lt;/strong&gt; regular copy mechanism, be it &lt;code&gt;scp&lt;/code&gt;, &lt;code&gt;rsync&lt;/code&gt; or &lt;code&gt;wget&lt;/code&gt;.</source>
          <target state="translated">두 번째 요점은 여러 시스템에서도 마찬가지입니다. &lt;code&gt;scp&lt;/code&gt; , &lt;code&gt;rsync&lt;/code&gt; 또는 &lt;code&gt;wget&lt;/code&gt; 과 &lt;strong&gt;같은&lt;/strong&gt; 일반적인 복사 메커니즘을 사용하여 원격 Git 저장소를 복제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e9e6bb5468c99a3a334f80fab3dbb52fc16223c6" translate="yes" xml:space="preserve">
          <source>Note that the session-id of the child process is not available to the current/spawning process, so the child&amp;rsquo;s PID is reported here as a hint for post-processing. (But it is only a hint because the child process may be a shell script which doesn&amp;rsquo;t have a session-id.)</source>
          <target state="translated">자식 프로세스의 session-id는 현재 / 스폰 닝 프로세스에서 사용할 수 없으므로 여기에서 자식 PID가 후 처리를위한 힌트로보고됩니다. (그러나 자식 프로세스는 session-id가없는 쉘 스크립트 일 수 있기 때문에 힌트 일뿐입니다.)</target>
        </trans-unit>
        <trans-unit id="e98f559f39ce7645bbbb14c50cc4f9c4dc239749" translate="yes" xml:space="preserve">
          <source>Note that the sizes of objects on disk are reported accurately, but care should be taken in drawing conclusions about which refs or objects are responsible for disk usage. The size of a packed non-delta object may be much larger than the size of objects which delta against it, but the choice of which object is the base and which is the delta is arbitrary and is subject to change during a repack.</source>
          <target state="translated">디스크의 객체 크기는 정확하게보고되지만 디스크 사용을 담당하는 참조 또는 객체에 대한 결론을 도출 할 때는주의를 기울여야합니다. 패킹 된 비 델타 객체의 크기는 델타에 대해 델타 인 객체의 크기보다 훨씬 클 수 있지만, 어느 객체가 기본이고 델타인지에 대한 선택은 임의적이며 재 포장 중에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47fc7cad6a527b522ab5e266e3e278a07a579735" translate="yes" xml:space="preserve">
          <source>Note that the suffix you get if you type these commands today may be longer than what Linus saw above when he ran these commands, as your Git repository may have new commits whose object names begin with 975b that did not exist back then, and &quot;-g975b&quot; suffix alone may not be sufficient to disambiguate these commits.</source>
          <target state="translated">Git 리포지토리에 개체 이름이 975b로 시작하는 새 커밋이있을 수 있으므로 &quot;-이 명령을 입력하면 오늘이 명령을 입력 할 때 접미사가 길어질 수 있습니다. g975b &quot;접미사만으로는 이러한 커밋을 명확히하기에 충분하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7eeba5803dc504042af48f9504a175baa6f39016" translate="yes" xml:space="preserve">
          <source>Note that the target of a &lt;code&gt;push&lt;/code&gt; is normally a &lt;a href=&quot;#def_bare_repository&quot;&gt;bare&lt;/a&gt; repository. You can also push to a repository that has a checked-out working tree, but a push to update the currently checked-out branch is denied by default to prevent confusion. See the description of the receive.denyCurrentBranch option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; 대상 은 일반적으로 &lt;a href=&quot;#def_bare_repository&quot;&gt;베어&lt;/a&gt; 리포지토리입니다. 체크 아웃 된 작업 트리가있는 저장소로 푸시 할 수도 있지만 혼란을 방지하기 위해 현재 체크 아웃 된 분기를 업데이트하기위한 푸시는 기본적으로 거부됩니다. 자세한 내용은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 receive.denyCurrentBranch 옵션에 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="110e365a18d2e41e53b11ff50c7bbd9d01eae2f0" translate="yes" xml:space="preserve">
          <source>Note that the two techniques outlined above (exporting via &lt;a href=&quot;#exporting-via-http&quot;&gt;http&lt;/a&gt; or &lt;a href=&quot;#exporting-via-git&quot;&gt;git&lt;/a&gt;) allow other maintainers to fetch your latest changes, but they do not allow write access, which you will need to update the public repository with the latest changes created in your private repository.</source>
          <target state="translated">위에서 설명한 두 가지 기술 ( &lt;a href=&quot;#exporting-via-http&quot;&gt;http&lt;/a&gt; 또는 &lt;a href=&quot;#exporting-via-git&quot;&gt;git을&lt;/a&gt; 통해 내보내기 )을 사용하면 다른 관리자가 최신 변경 사항을 가져올 수 있지만 쓰기 액세스는 허용하지 않으므로 개인 저장소에서 작성된 최신 변경 사항으로 공용 저장소를 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="ae8ea7d3546a16ede3faa6039563fb0d737e4467" translate="yes" xml:space="preserve">
          <source>Note that the version which &lt;code&gt;git bisect&lt;/code&gt; checks out for you at each point is just a suggestion, and you&amp;rsquo;re free to try a different version if you think it would be a good idea. For example, occasionally you may land on a commit that broke something unrelated; run</source>
          <target state="translated">&lt;code&gt;git bisect&lt;/code&gt; 가 각 시점에서 당신을 위해 체크 아웃 하는 버전 은 단지 제안 일 뿐이며, 좋은 생각이라고 생각되면 다른 버전을 자유롭게 시도 할 수 있습니다. 예를 들어, 때로는 관련이없는 것을 저지른 커밋에 착륙 할 수 있습니다. 운영</target>
        </trans-unit>
        <trans-unit id="1000c60b0f402f5d9e4c69088fd79818a06e5e98" translate="yes" xml:space="preserve">
          <source>Note that there are two ways to checkout a particular branch. As described elsewhere on this page, the &quot;module&quot; parameter of cvs checkout is interpreted as a branch name, and it becomes the main branch. It remains the main branch for a given sandbox even if you temporarily make another branch sticky with cvs update -r. Alternatively, the -r argument can indicate some other branch to actually checkout, even though the module is still the &quot;main&quot; branch. Tradeoffs (as currently implemented): Each new &quot;module&quot; creates a new database on disk with a history for the given module, and after the database is created, operations against that main branch are fast. Or alternatively, -r doesn&amp;rsquo;t take any extra disk space, but may be significantly slower for many operations, like cvs update.</source>
          <target state="translated">특정 지점을 체크 아웃하는 방법에는 두 가지가 있습니다. 이 페이지의 다른 곳에서 설명한 것처럼 cvs checkout의 &quot;module&quot;매개 변수는 분기 이름으로 해석되어 기본 분기가됩니다. cvs update -r로 다른 브랜치를 일시적으로 고정하더라도 주어진 샌드 박스의 기본 브랜치로 유지됩니다. 또는 -r 인수는 모듈이 여전히 &quot;기본&quot;분기 인 경우에도 실제로 체크 아웃 할 다른 분기를 나타낼 수 있습니다. 절충 (현재 구현 된대로) : 각각의 새 &quot;모듈&quot;은 주어진 모듈에 대한 기록을 사용하여 디스크에 새 데이터베이스를 작성하고 데이터베이스가 작성된 후 해당 주요 지점에 대한 조작이 빠릅니다. 또는 -r은 추가 디스크 공간을 차지하지 않지만 cvs 업데이트와 같은 많은 작업에서 상당히 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fe39a3f8a6c98b987fad41f0865478fee4d146d" translate="yes" xml:space="preserve">
          <source>Note that these are applied before commit ordering and formatting options, such as &lt;code&gt;--reverse&lt;/code&gt;.</source>
          <target state="translated">이 명령은 &lt;code&gt;--reverse&lt;/code&gt; 와 같은 커밋 순서 및 형식 지정 옵션 전에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="33723cad0621665104eb7762cf8f60a246a13517" translate="yes" xml:space="preserve">
          <source>Note that these configuration variables should probably be set using the &lt;code&gt;--global&lt;/code&gt; flag, for example like this:</source>
          <target state="translated">이러한 구성 변수는 다음 과 같이 &lt;code&gt;--global&lt;/code&gt; 플래그를 사용하여 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ccb8cdc33c08512e4436bbf3b8db5bc9921ae58d" translate="yes" xml:space="preserve">
          <source>Note that this affects all diff-based output types, e.g. those produced by &lt;code&gt;--stat&lt;/code&gt;, etc.</source>
          <target state="translated">이는 &lt;code&gt;--stat&lt;/code&gt; 등에서 생성 된 것과 같은 모든 diff 기반 출력 유형에 영향을 미칩니다 .</target>
        </trans-unit>
        <trans-unit id="0691624d8498eccd40578875388b7f8bab2a7b6c" translate="yes" xml:space="preserve">
          <source>Note that this applies only to accessing the repository&amp;rsquo;s disk contents directly. An older client which understands only format &lt;code&gt;0&lt;/code&gt; may still connect via &lt;code&gt;git://&lt;/code&gt; to a repository using format &lt;code&gt;1&lt;/code&gt;, as long as the server process understands format &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">이는 리포지토리의 디스크 내용에 직접 액세스하는 경우에만 적용됩니다. 서버 프로세스가 형식 &lt;code&gt;1&lt;/code&gt; 을 이해하는 한 형식 &lt;code&gt;0&lt;/code&gt; 만 이해하는 이전 클라이언트 는 여전히 형식 &lt;code&gt;1&lt;/code&gt; 을 사용하여 &lt;code&gt;git://&lt;/code&gt; 를 통해 저장소에 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3528bf60e5e55bcec2b34b4efbb66a2e2ad0ca9" translate="yes" xml:space="preserve">
          <source>Note that this assumes that none of the blobs and commit messages referenced by that revision range contains the string &lt;code&gt;refs/heads/master&lt;/code&gt;.</source>
          <target state="translated">이는 해당 개정 범위에서 참조하는 Blob 및 커밋 메시지에 문자열 &lt;code&gt;refs/heads/master&lt;/code&gt; 가 포함되지 않는다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="b2c1b09dd03782a35574f4220ce1860b1a59abed" translate="yes" xml:space="preserve">
          <source>Note that this configuration variable is ignored if it is seen in the repository-level config (this is a safety measure against fetching from untrusted repositories).</source>
          <target state="translated">이 구성 변수는 리포지토리 수준 구성에서 볼 경우 무시됩니다 (신뢰할 수없는 리포지토리에서 가져 오는 것에 대한 안전 측정).</target>
        </trans-unit>
        <trans-unit id="8243e24ce26ee48638bea5b267bba5916eee07a8" translate="yes" xml:space="preserve">
          <source>Note that this is currently only implemented for the client side of clones and fetches.</source>
          <target state="translated">이것은 현재 클론 및 페치의 클라이언트 측에 대해서만 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="7278e2ca069b871494710e49f702957a299741e8" translate="yes" xml:space="preserve">
          <source>Note that this is the old file data; so the object that Git named in its response to the initial tree was a tree with a snapshot of the directory state that was recorded by the first commit.</source>
          <target state="translated">이것은 이전 파일 데이터입니다. 따라서 Git이 초기 트리에 대한 응답으로 명명 한 객체는 첫 번째 커밋에 의해 기록 된 디렉토리 상태의 스냅 샷이있는 트리였습니다.</target>
        </trans-unit>
        <trans-unit id="8524e2a4579b70a19e36821a3f8f1b43bac12c4a" translate="yes" xml:space="preserve">
          <source>Note that this list is non-comprehensive and not necessarily complete. For command-specific variables, you will find a more detailed description in the appropriate manual page.</source>
          <target state="translated">이 목록은 포괄적이지 않으며 반드시 완전하지는 않습니다. 명령 별 변수에 대해서는 해당 매뉴얼 페이지에서 자세한 설명을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a06dd344c0e0f4252ac8d0d18c1815e7f413d617" translate="yes" xml:space="preserve">
          <source>Note that this may contain embedded LF or CRLF characters that are not escaped, so the event may spill across multiple lines.</source>
          <target state="translated">이스케이프 처리되지 않은 LF 또는 CRLF 문자가 포함되어있을 수 있으므로 이벤트가 여러 줄에 걸쳐 유출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="954610f540e4dda45ac67b28e742adb370b9dd1c" translate="yes" xml:space="preserve">
          <source>Note that this may mean that multiple Git commits are created for a single SVN revision.</source>
          <target state="translated">이는 단일 SVN 개정에 대해 여러 개의 Git 커밋이 생성되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="69a24fcf6b082a94d6b3e16af2197fed496268e4" translate="yes" xml:space="preserve">
          <source>Note that this option is only useful if you are actually sending the emails and want to identify yourself as the sender, but retain the original author (and &lt;code&gt;git am&lt;/code&gt; will correctly pick up the in-body header). Note also that &lt;code&gt;git send-email&lt;/code&gt; already handles this transformation for you, and this option should not be used if you are feeding the result to &lt;code&gt;git send-email&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 실제로 전자 메일을 전송하고 자신을 보낸 사람으로 식별하려고하지만 원래 작성자를 유지하려는 경우에만 유용합니다 ( &lt;code&gt;git am&lt;/code&gt; 은 본문 내 헤더를 올바르게 선택합니다). 또한 &lt;code&gt;git send-email&lt;/code&gt; 은 이미이 변환을 처리 &lt;code&gt;git send-email&lt;/code&gt; 결과를 git send-email에 제공하는 경우이 옵션을 사용하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="d0a34c500aa8e9fdf22f16d59ae03a1a8711ff64" translate="yes" xml:space="preserve">
          <source>Note that this option uses the no overlay mode by default (see also &lt;code&gt;--overlay&lt;/code&gt;), and currently doesn&amp;rsquo;t support overlay mode.</source>
          <target state="translated">이 옵션은 기본적으로 오버레이 없음 모드를 사용하고 ( &lt;code&gt;--overlay&lt;/code&gt; 참조 ) 현재 오버레이 모드를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4360f69bfd218e96ff125f09b08b60281e46fca" translate="yes" xml:space="preserve">
          <source>Note that this setting should only be set by &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; or &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;. Trying to change it after initialization will not work and will produce hard-to-diagnose issues.</source>
          <target state="translated">이 설정은 &lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 로만 설정해야합니다 . 초기화 후 변경을 시도하면 작동하지 않으며 진단하기 어려운 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e3aa2cd05420cf442d246cf6450d49e1768c842c" translate="yes" xml:space="preserve">
          <source>Note that this variable is honored even when set in a configuration file in a &quot;.git&quot; subdirectory of a directory and its value differs from the latter directory (e.g. &quot;/path/to/.git/config&quot; has core.worktree set to &quot;/different/path&quot;), which is most likely a misconfiguration. Running Git commands in the &quot;/path/to&quot; directory will still use &quot;/different/path&quot; as the root of the work tree and can cause confusion unless you know what you are doing (e.g. you are creating a read-only snapshot of the same index to a location different from the repository&amp;rsquo;s usual working tree).</source>
          <target state="translated">이 변수는 디렉토리의 &quot;.git&quot;하위 디렉토리에있는 구성 파일에 설정되어 있고 그 값이 후자의 디렉토리와 다른 경우에도 적용됩니다 (예 : &quot;/path/to/.git/config&quot;는 core.worktree가 &quot;/ different / path&quot;)로 잘못 구성되었을 가능성이 큽니다. &quot;/ path / to&quot;디렉토리에서 Git 명령을 실행하면 여전히 &quot;/ different / path&quot;가 작업 트리의 루트로 사용되며 수행중인 작업을 알지 못하는 경우 (예 : 읽기 전용 스냅 샷을 작성하는 경우) 혼란이 발생할 수 있습니다. 저장소의 일반적인 작업 트리와 다른 위치에 대한 동일한 색인).</target>
        </trans-unit>
        <trans-unit id="f66853802a66e4aff14a38d5843516f4164ff5ba" translate="yes" xml:space="preserve">
          <source>Note that this will create the new branch, but it will not switch the working tree to it; use &quot;git switch &amp;lt;newbranch&amp;gt;&quot; to switch to the new branch.</source>
          <target state="translated">이렇게하면 새 분기가 만들어 지지만 작업 트리는 전환되지 않습니다. &quot;git switch &amp;lt;newbranch&amp;gt;&quot;를 사용하여 새 분기로 전환하십시오.</target>
        </trans-unit>
        <trans-unit id="f6e42ae8cab92e791d65bf753cdda97ba478a01b" translate="yes" xml:space="preserve">
          <source>Note that unless one of &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;--cc&lt;/code&gt;, or &lt;code&gt;-m&lt;/code&gt; is given, merge commits will never show a diff, even if a diff format like &lt;code&gt;--patch&lt;/code&gt; is selected, nor will they match search options like &lt;code&gt;-S&lt;/code&gt;. The exception is when &lt;code&gt;--first-parent&lt;/code&gt; is in use, in which merges are treated like normal single-parent commits (this can be overridden by providing a combined-diff option or with &lt;code&gt;--no-diff-merges&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;--cc&lt;/code&gt; 또는 &lt;code&gt;-m&lt;/code&gt; 중 하나를 지정하지 않으면 병합 커밋은 &lt;code&gt;--patch&lt;/code&gt; 와 같은 diff 형식 이 선택 되어도 diff를 표시 하지 않으며 &lt;code&gt;-S&lt;/code&gt; 와 같은 검색 옵션과 일치하지 않습니다 . 예외는 &lt;code&gt;--first-parent&lt;/code&gt; 가 사용되는 경우입니다. 병합은 일반 단일 부모 커밋처럼 처리됩니다 (이는 결합 된 차이 옵션을 제공하거나 &lt;code&gt;--no-diff-merges&lt;/code&gt; 를 사용 하여 재정의 할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="48c8adea213e6ac01f80c59a6b72ca8bc5d0c4be" translate="yes" xml:space="preserve">
          <source>Note that unreachable, packed objects will remain. If this is not desired, see &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;.</source>
          <target state="translated">도달 할 수없는 포장 된 개체는 그대로 유지됩니다. 이것이 바람직하지 않은 경우 &lt;a href=&quot;git-repack&quot;&gt;git-repack [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9c873a19166627d45cbe06c1e92f0fc64675a0f" translate="yes" xml:space="preserve">
          <source>Note that users fetching over dumb protocols will have to fetch the whole new pack in order to get any contained object, no matter how many other objects in that pack they already have locally.</source>
          <target state="translated">벙어리 프로토콜을 통해 가져 오는 사용자는 이미 로컬에있는 팩의 다른 개체 수에 관계없이 포함 된 개체를 가져 오기 위해 완전히 새로운 팩을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="511b177ad0f4f309a1f22f8d5a0729bb57a27072" translate="yes" xml:space="preserve">
          <source>Note that we deliberately chose not to re-code the commit log message when a commit is made to force UTF-8 at the commit object level, because re-coding to UTF-8 is not necessarily a reversible operation.</source>
          <target state="translated">UTF-8 로의 재 코딩이 반드시 가역적 인 조작은 아니기 때문에, 확약이 커밋이 커밋 객체 레벨에서 UTF-8을 강제로 수행 할 때 커밋 로그 메시지를 다시 코딩하지 않기로 선택했다는 점에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="352feed71993cca2768c0de80ab4efdfef627645" translate="yes" xml:space="preserve">
          <source>Note that we pick a single island for each regex to go into, using &quot;last one wins&quot; ordering (which allows repo-specific config to take precedence over user-wide config, and so forth).</source>
          <target state="translated">&quot;마지막 승리&quot;순서를 사용하여 각 정규식에 대해 단일 아일랜드를 선택합니다 (이 경우 특정 리포지토리 구성이 사용자 전체 구성보다 우선합니다).</target>
        </trans-unit>
        <trans-unit id="0f413678af329d8b352f68927252d8a326f2b212" translate="yes" xml:space="preserve">
          <source>Note that when matching against a tree object, attributes are still obtained from working tree, not from the given tree object.</source>
          <target state="translated">트리 객체와 일치하는 경우 속성은 주어진 트리 객체가 아닌 작업 트리에서 여전히 얻습니다.</target>
        </trans-unit>
        <trans-unit id="6f16ff14e66ecdeaed0888755a04ec80e3903de7" translate="yes" xml:space="preserve">
          <source>Note that when providing a &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;, you must use &lt;code&gt;--list&lt;/code&gt;; otherwise the command may be interpreted as branch creation.</source>
          <target state="translated">&lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 을 제공 할 때는 &lt;code&gt;--list&lt;/code&gt; 를 사용해야합니다 . 그렇지 않으면 명령이 분기 작성으로 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e31fbecbd095ab339f753f545ee8ad3cdcfd7be" translate="yes" xml:space="preserve">
          <source>Note that when you&amp;rsquo;ve moved or copied a Git repository, your Git index file (which caches various information, notably some of the &quot;stat&quot; information for the files involved) will likely need to be refreshed. So after you do a &lt;code&gt;cp -a&lt;/code&gt; to create a new copy, you&amp;rsquo;ll want to do</source>
          <target state="translated">Git 리포지토리를 이동하거나 복사하면 Git 인덱스 파일 (여러 파일, 특히 관련된 파일에 대한 &quot;stat&quot;정보 중 일부를 캐시 함)을 새로 고쳐야 할 수도 있습니다. 따라서 &lt;code&gt;cp -a&lt;/code&gt; 를 수행하여 새 복사본을 만든 후에는</target>
        </trans-unit>
        <trans-unit id="b6e7add23d70ae9c79a92003e95b0646493f7240" translate="yes" xml:space="preserve">
          <source>Note that without &lt;code&gt;--full-history&lt;/code&gt;, this still simplifies merges: if one of the parents is TREESAME, we follow only that one, so the other sides of the merge are never walked.</source>
          <target state="translated">&lt;code&gt;--full-history&lt;/code&gt; 가 없으면 여전히 병합을 단순화합니다. 부모 중 하나가 TREESAME 인 경우 그 중 하나만 따르므로 병합의 다른 쪽은 걸어 가지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26c6b6e45f05961054f9762544f517daa6e3a44f" translate="yes" xml:space="preserve">
          <source>Note that without parent rewriting, it is not really possible to talk about the parent/child relationships between the commits, so we show them disconnected.</source>
          <target state="translated">부모가 다시 작성하지 않으면 커밋 사이의 부모 / 자식 관계에 대해 이야기 할 수 없으므로 연결이 끊어진 것으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="40996350a13d178ee15ae3215e9ae292d6702c1c" translate="yes" xml:space="preserve">
          <source>Note that you can get more information on a packfile by calling &lt;a href=&quot;git-verify-pack&quot;&gt;git-verify-pack[1]&lt;/a&gt;. However, as this command considers only the index file itself, it&amp;rsquo;s both faster and more flexible.</source>
          <target state="translated">&lt;a href=&quot;git-verify-pack&quot;&gt;git-verify-pack [1]&lt;/a&gt; 을 호출하여 팩 파일에 대한 자세한 정보를 얻을 수 있습니다 . 그러나이 명령은 인덱스 파일 자체 만 고려하므로 더 빠르고 유연합니다.</target>
        </trans-unit>
        <trans-unit id="191247c1388c3f45dfe82bf6b2f0384fea86edc8" translate="yes" xml:space="preserve">
          <source>Note that you cannot generally put &lt;code&gt;git for-each-ref&lt;/code&gt; directly into the config value, as it does not take a repository path as an argument (but you can wrap the command above in a shell script).</source>
          <target state="translated">저장소 경로를 인수로 사용하지 않기 때문에 일반적으로 &lt;code&gt;git for-each-ref&lt;/code&gt; 를 구성 값에 직접 넣을 수는 없습니다 (그러나 쉘 스크립트에서 위 명령을 래핑 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="0fb44a035d4df6f6306133b267ae1546e220d2ba" translate="yes" xml:space="preserve">
          <source>Note that you should not do Octopus just because you can. An octopus is a valid thing to do and often makes it easier to view the commit history if you are merging more than two independent changes at the same time. However, if you have merge conflicts with any of the branches you are merging in and need to hand resolve, that is an indication that the development happened in those branches were not independent after all, and you should merge two at a time, documenting how you resolved the conflicts, and the reason why you preferred changes made in one side over the other. Otherwise it would make the project history harder to follow, not easier.</source>
          <target state="translated">당신이 할 수 있기 때문에 문어를해서는 안됩니다. 문어는 유효한 일이며 동시에 두 개 이상의 독립적 인 변경 사항을 병합하는 경우 커밋 기록을보다 쉽게 ​​볼 수 있습니다. 그러나 병합하려는 지점 중 하나와 병합 충돌이 발생하여 직접 해결해야하는 경우 이는 해당 지점에서 개발이 전혀 독립적이지 않았 음을 나타내며, 한 번에 두 개씩 병합해야합니다. 갈등을 해결하고 한 쪽에서 다른 쪽보다 변경을 선호하는 이유. 그렇지 않으면 프로젝트 히스토리를 따르기가 더 어려워지고 쉽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="482be6a864fbdcc5f9a936e9708b6d9c3eb14ff5" translate="yes" xml:space="preserve">
          <source>Note the addition of the &lt;code&gt;+&lt;/code&gt; sign. Alternatively, you can use the &lt;code&gt;-f&lt;/code&gt; flag to force the remote update, as in:</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 부호 가 추가되었습니다 . 또는 다음과 같이 &lt;code&gt;-f&lt;/code&gt; 플래그를 사용 하여 원격 업데이트를 강제 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c14d9654c43dfc38c5ce0e390578cf211f8eb175" translate="yes" xml:space="preserve">
          <source>Note the addition of the &lt;code&gt;+&lt;/code&gt; sign. Alternatively, you can use the &lt;code&gt;-f&lt;/code&gt; flag to force updates of all the fetched branches, as in:</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 부호 가 추가되었습니다 . 또는 &lt;code&gt;-f&lt;/code&gt; 플래그를 사용하여 다음 과 같이 페치 된 모든 분기를 강제로 업데이트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2261964ad436001973909975a060cb501a98c780" translate="yes" xml:space="preserve">
          <source>Note the last point. Do &lt;code&gt;not&lt;/code&gt; use &lt;code&gt;git pull&lt;/code&gt; unless you actually want to merge the remote branch.</source>
          <target state="translated">마지막 사항에 유의하십시오. 실제로 원격 브랜치를 병합 하지 &lt;code&gt;not&lt;/code&gt; 려면 &lt;code&gt;git pull&lt;/code&gt; 을 사용 하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="b5d534f9876445dbbed162e13c3b9e1bade912b4" translate="yes" xml:space="preserve">
          <source>Note the major differences in &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;P&lt;/code&gt;, and &lt;code&gt;Q&lt;/code&gt; over &lt;code&gt;--full-history&lt;/code&gt;:</source>
          <target state="translated">주요 차이점 참고 &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;P&lt;/code&gt; 및 &lt;code&gt;Q&lt;/code&gt; 위에 &lt;code&gt;--full-history&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="592ed4ba86d62c504859114fd8d03df0827a06fa" translate="yes" xml:space="preserve">
          <source>Note the quotes around &lt;code&gt;*.c&lt;/code&gt;. The file &lt;code&gt;hello.c&lt;/code&gt; will also be checked out, even though it is no longer in the working tree, because the file globbing is used to match entries in the index (not in the working tree by the shell).</source>
          <target state="translated">&lt;code&gt;*.c&lt;/code&gt; 주위의 따옴표를 참고하십시오 . &lt;code&gt;hello.c&lt;/code&gt; 파일 은 더 이상 작업 트리에 없지만 파일 글 로빙이 색인의 항목 (쉘의 작업 트리가 아님)과 일치하는 데 사용되므로 체크 아웃됩니다.</target>
        </trans-unit>
        <trans-unit id="d840183324e7e2c4b1d9b149ae89bf837a67da9c" translate="yes" xml:space="preserve">
          <source>Note the quotes around &lt;code&gt;*.c&lt;/code&gt;. The file &lt;code&gt;hello.c&lt;/code&gt; will also be restored, even though it is no longer in the working tree, because the file globbing is used to match entries in the index (not in the working tree by the shell).</source>
          <target state="translated">&lt;code&gt;*.c&lt;/code&gt; 주위의 따옴표를 참고하십시오 . &lt;code&gt;hello.c&lt;/code&gt; 파일 은 더 이상 작업 트리에 있지 않더라도 복원됩니다 (파일 글 로빙은 색인의 항목 (쉘의 작업 트리가 아님)와 일치하는 데 사용되기 때문에).</target>
        </trans-unit>
        <trans-unit id="86811ec658abf1645177c2f89c78cd1610e7ea04" translate="yes" xml:space="preserve">
          <source>Note what happens to the different &lt;code&gt;git diff-*&lt;/code&gt; versions here. After we&amp;rsquo;ve updated &lt;code&gt;hello&lt;/code&gt; in the index, &lt;code&gt;git diff-files -p&lt;/code&gt; now shows no differences, but &lt;code&gt;git diff-index -p HEAD&lt;/code&gt; still &lt;strong&gt;does&lt;/strong&gt; show that the current state is different from the state we committed. In fact, now &lt;code&gt;git diff-index&lt;/code&gt; shows the same difference whether we use the &lt;code&gt;--cached&lt;/code&gt; flag or not, since now the index is coherent with the working tree.</source>
          <target state="translated">여기 에서 다른 &lt;code&gt;git diff-*&lt;/code&gt; 버전에 어떤 영향이 있는지 확인 하십시오. 우리가 업데이트 한 후 &lt;code&gt;hello&lt;/code&gt; 인덱스에, &lt;code&gt;git diff-files -p&lt;/code&gt; 지금은 차이를 보여줍니다 만, &lt;code&gt;git diff-index -p HEAD&lt;/code&gt; 여전히 &lt;strong&gt;않는&lt;/strong&gt; 현재 상태는 우리가 최선을 다하고 상태에서 다른 것을 보여. 사실, &lt;code&gt;git diff-index&lt;/code&gt; 는 &lt;code&gt;--cached&lt;/code&gt; 플래그를 사용하든 그렇지 않든 동일한 차이를 보여줍니다. 이제 색인은 작업 트리와 일관성이 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c96f5bf9205aae211cb148d5f8bcf4fb9ebed15b" translate="yes" xml:space="preserve">
          <source>Note, by the way, that lots of commands take a tree as an argument. But as we can see above, a tree can be referred to in many different ways&amp;mdash;​by the SHA-1 name for that tree, by the name of a commit that refers to the tree, by the name of a branch whose head refers to that tree, etc.--and most such commands can accept any of these names.</source>
          <target state="translated">그런데 많은 명령이 트리를 인수로 사용합니다. 그러나 위에서 볼 수 있듯이, 트리는 여러 가지 방식으로, 그 트리의 SHA-1 이름, 트리를 나타내는 커밋 이름, 머리가 참조하는 브랜치 이름으로 나타낼 수 있습니다. 그 트리 등을 비롯한 대부분의 명령은 이러한 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba28d9bd22f696c9f9b774765c5cbeba6fcd1342" translate="yes" xml:space="preserve">
          <source>Note, for the reasons stated above usage of context-free patches is discouraged.</source>
          <target state="translated">위에서 언급 한 이유로 컨텍스트가없는 패치는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="22eddd855ac86c24360d06b5276ff8c7e192d879" translate="yes" xml:space="preserve">
          <source>Note, this safety check does not mean that a checkout will generate a file identical to the original file for a different setting of &lt;code&gt;core.eol&lt;/code&gt; and &lt;code&gt;core.autocrlf&lt;/code&gt;, but only for the current one. For example, a text file with &lt;code&gt;LF&lt;/code&gt; would be accepted with &lt;code&gt;core.eol=lf&lt;/code&gt; and could later be checked out with &lt;code&gt;core.eol=crlf&lt;/code&gt;, in which case the resulting file would contain &lt;code&gt;CRLF&lt;/code&gt;, although the original file contained &lt;code&gt;LF&lt;/code&gt;. However, in both work trees the line endings would be consistent, that is either all &lt;code&gt;LF&lt;/code&gt; or all &lt;code&gt;CRLF&lt;/code&gt;, but never mixed. A file with mixed line endings would be reported by the &lt;code&gt;core.safecrlf&lt;/code&gt; mechanism.</source>
          <target state="translated">이 안전 점검은 체크 아웃이 다른 설정의 &lt;code&gt;core.eol&lt;/code&gt; 및 &lt;code&gt;core.autocrlf&lt;/code&gt; 에 대해 원본 파일과 동일한 파일을 생성 하지만 현재 파일에 대해서만 생성한다는 것을 의미하지는 않습니다 . 예를 들어, &lt;code&gt;LF&lt;/code&gt; 가 있는 텍스트 파일은 &lt;code&gt;core.eol=lf&lt;/code&gt; 로 승인되고 나중에 &lt;code&gt;core.eol=crlf&lt;/code&gt; 로 체크 아웃 될 수 있습니다 .이 경우 결과 파일에는 &lt;code&gt;CRLF&lt;/code&gt; 가 포함 되지만 원본 파일에는 &lt;code&gt;LF&lt;/code&gt; 가 포함 됩니다. 그러나 두 작업 트리에서 줄 끝은 모두 일치합니다. 즉, 모든 &lt;code&gt;LF&lt;/code&gt; 또는 모든 &lt;code&gt;CRLF&lt;/code&gt; 이지만 혼합되지는 않습니다. 줄 끝이 혼합 된 파일은 &lt;code&gt;core.safecrlf&lt;/code&gt; 에서 보고합니다. 기구.</target>
        </trans-unit>
        <trans-unit id="955b317bd13857ee21eddce08c9664927a950a2e" translate="yes" xml:space="preserve">
          <source>Note. A single level of backslashes are eaten by the configuration file parser, so you would need to double the backslashes; the pattern above picks a line that begins with a backslash, and zero or more occurrences of &lt;code&gt;sub&lt;/code&gt; followed by &lt;code&gt;section&lt;/code&gt; followed by open brace, to the end of line.</source>
          <target state="translated">노트. 구성 파일 구문 분석기는 단일 레벨의 백 슬래시를 사용하므로 백 슬래시를 두 배로 늘려야합니다. 위의 패턴은 백 슬래시로 시작하는 라인을 선택하고, 줄 의 끝까지 0 개 이상의 &lt;code&gt;sub&lt;/code&gt; 와 그 뒤에 &lt;code&gt;section&lt;/code&gt; , open brace를 차례로 선택합니다.</target>
        </trans-unit>
        <trans-unit id="c3a8d5b6840faaf677f5d3f6a79125e45b041b0b" translate="yes" xml:space="preserve">
          <source>Note. When the &quot;-C&quot; option is used with &lt;code&gt;--find-copies-harder&lt;/code&gt; option, &lt;code&gt;git diff-*&lt;/code&gt; commands feed unmodified filepairs to diffcore mechanism as well as modified ones. This lets the copy detector consider unmodified files as copy source candidates at the expense of making it slower. Without &lt;code&gt;--find-copies-harder&lt;/code&gt;, &lt;code&gt;git diff-*&lt;/code&gt; commands can detect copies only if the file that was copied happened to have been modified in the same changeset.</source>
          <target state="translated">노트. &quot;-C&quot;옵션을 &lt;code&gt;--find-copies-harder&lt;/code&gt; 옵션 과 함께 사용 하면 &lt;code&gt;git diff-*&lt;/code&gt; diff- * 명령은 수정되지 않은 파일 쌍을 수정 된 파일 쌍뿐만 아니라 diffcore 메커니즘에 공급합니다. 이를 통해 복사 검출기는 수정되지 않은 파일을 복사 소스 후보로 간주하여 속도를 늦출 수 있습니다. 없이 &lt;code&gt;--find-copies-harder&lt;/code&gt; , &lt;code&gt;git diff-*&lt;/code&gt; 명령 사본을 감지 할 수있는 복사 된 파일이 같은 변경 집합에서 수정 된 일어난 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="9ed1ac27dff5378ed96f590f4322050a04cabf6d" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;git revert&lt;/code&gt; is used to record some new commits to reverse the effect of some earlier commits (often only a faulty one). If you want to throw away all uncommitted changes in your working directory, you should see &lt;a href=&quot;git-reset&quot;&gt;git-reset[1]&lt;/a&gt;, particularly the &lt;code&gt;--hard&lt;/code&gt; option. If you want to extract specific files as they were in another commit, you should see &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt;, specifically the &lt;code&gt;--source&lt;/code&gt; option. Take care with these alternatives as both will discard uncommitted changes in your working directory.</source>
          <target state="translated">참고 : &lt;code&gt;git revert&lt;/code&gt; 는 일부 새로운 커밋을 기록하여 이전 커밋의 효과를 되 돌리는 데 사용됩니다 (종종 결함이있는 것). 작업 디렉토리에서 커밋되지 않은 모든 변경 사항을 제거하려면 &lt;a href=&quot;git-reset&quot;&gt;git-reset [1]&lt;/a&gt; , 특히 &lt;code&gt;--hard&lt;/code&gt; 옵션이 표시되어야합니다. 다른 커밋에서 특정 파일을 추출하려면 &lt;a href=&quot;git-restore&quot;&gt;git-restore [1]&lt;/a&gt; , 특히 &lt;code&gt;--source&lt;/code&gt; 옵션이 표시되어야합니다. 둘 다 작업 디렉토리에서 커밋되지 않은 변경 사항을 삭제하므로 이러한 대안을주의하십시오.</target>
        </trans-unit>
        <trans-unit id="6007883f602581f1393822506c41cbfbfd02c805" translate="yes" xml:space="preserve">
          <source>Note: A thin pack violates the packed archive format by omitting required objects and is thus unusable by Git without making it self-contained. Use &lt;code&gt;git index-pack --fix-thin&lt;/code&gt; (see &lt;a href=&quot;git-index-pack&quot;&gt;git-index-pack[1]&lt;/a&gt;) to restore the self-contained property.</source>
          <target state="translated">참고 : 씬 팩은 필요한 객체를 생략하여 압축 된 아카이브 형식을 위반하므로 Git에서 자체 포함하지 않고 사용할 수 없습니다. 사용 &lt;code&gt;git index-pack --fix-thin&lt;/code&gt; (참조 &lt;a href=&quot;git-index-pack&quot;&gt;자식 인덱스 팩 [1]&lt;/a&gt; )을 자체 포함 된 속성을 복원합니다.</target>
        </trans-unit>
        <trans-unit id="1f8f5701942fbb7ebefa9dee3f4f37f4528c7cfd" translate="yes" xml:space="preserve">
          <source>Note: Make sure you quote the result when passing it to &lt;code&gt;eval&lt;/code&gt;. See below for an example.</source>
          <target state="translated">참고 : 결과를 &lt;code&gt;eval&lt;/code&gt; 로 전달할 때 인용하십시오 . 예는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b0f0e4e61a2bb004cf3ec68d5169e8ba972a47ee" translate="yes" xml:space="preserve">
          <source>Note: Newer CVS versions (&amp;gt;= 1.12.11) also support specifying CVS_SERVER directly in CVSROOT like</source>
          <target state="translated">참고 : 최신 CVS 버전 (&amp;gt; = 1.12.11)은 CVSROOT에서 직접 CVS_SERVER 지정을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b833243d544e1089f2767ea8843cab2eed5526b2" translate="yes" xml:space="preserve">
          <source>Note: Porcelain commands such as &lt;code&gt;git gc&lt;/code&gt; (see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;), &lt;code&gt;git repack&lt;/code&gt; (see &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;) pass this option by default in modern Git when they put objects in your repository into pack files. So does &lt;code&gt;git bundle&lt;/code&gt; (see &lt;a href=&quot;git-bundle&quot;&gt;git-bundle[1]&lt;/a&gt;) when it creates a bundle.</source>
          <target state="translated">참고 : &lt;code&gt;git gc&lt;/code&gt; ( &lt;a href=&quot;git-gc&quot;&gt;git-gc [1] 참조&lt;/a&gt; ), &lt;code&gt;git repack&lt;/code&gt; ( &lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt; 참조 ) 과 같은 도자기 명령 은 저장소의 객체를 팩 파일에 넣을 때 현대 Git에서 기본적 으로이 옵션을 전달합니다. &lt;code&gt;git bundle&lt;/code&gt; ( &lt;a href=&quot;git-bundle&quot;&gt;git-bundle [1]&lt;/a&gt; 참조)도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="7a04bc9af081bc88d648e6675a2308737bd31c23" translate="yes" xml:space="preserve">
          <source>Note: Some inetd servers let you specify the name of the executable independently of the value of argv[0] (i.e. the name the program assumes it was executed with). In this case the correct line in /etc/inetd.conf looks like</source>
          <target state="translated">참고 : 일부 inetd 서버에서는 argv [0]의 값과 독립적으로 실행 파일 이름을 지정할 수 있습니다 (예 : 프로그램에서 실행 된 이름). 이 경우 /etc/inetd.conf의 올바른 줄은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="722ccad077353010f3a3bf5b634c417679782a2c" translate="yes" xml:space="preserve">
          <source>Note: Whenever the clean filter is changed, the repo should be renormalized: $ git add --renormalize .</source>
          <target state="translated">참고 : 클린 필터가 변경 될 때마다 리포지토리를 다시 정규화해야합니다 : $ git add --renormalize.</target>
        </trans-unit>
        <trans-unit id="e979029bca285fbda95b190d7e0a6ad42b034f7b" translate="yes" xml:space="preserve">
          <source>Note: the first command (&lt;code&gt;label onto&lt;/code&gt;) labels the revision onto which the commits are rebased; The name &lt;code&gt;onto&lt;/code&gt; is just a convention, as a nod to the &lt;code&gt;--onto&lt;/code&gt; option.</source>
          <target state="translated">참고 : 첫 번째 명령 ( &lt;code&gt;label onto&lt;/code&gt; on)은 커밋이 기반으로하는 개정판에 레이블을 지정합니다. 이름 &lt;code&gt;onto&lt;/code&gt; 받는 고개를 끄덕로, 단지 관례 &lt;code&gt;--onto&lt;/code&gt; 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="c1bc321618eb470344ec0a0359d287ae90474ae5" translate="yes" xml:space="preserve">
          <source>Note: the following core Perl modules that may be installed with your distribution of Perl are required: MIME::Base64, MIME::QuotedPrint, Net::Domain and Net::SMTP. These additional Perl modules are also required: Authen::SASL and Mail::Address.</source>
          <target state="translated">참고 : Perl 배포와 함께 설치할 수있는 핵심 Perl 모듈 인 MIME :: Base64, MIME :: QuotedPrint, Net :: Domain 및 Net :: SMTP가 필요합니다. 이 추가 Perl 모듈도 필요합니다 : Authen :: SASL 및 Mail :: Address.</target>
        </trans-unit>
        <trans-unit id="9ca0395056bb808a73d2de7297fac7a555e73c25" translate="yes" xml:space="preserve">
          <source>Note: you can specify the default pretty format in the repository configuration (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">참고 : 저장소 구성에서 기본 pretty 형식을 지정할 수 있습니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="399df4ce8f932f9b96c0fdefbfc88e37bceafef0" translate="yes" xml:space="preserve">
          <source>Note: you need to ensure each user that is going to invoke &lt;code&gt;git-cvsserver&lt;/code&gt; has write access to the log file and to the database (see &lt;a href=&quot;#dbbackend&quot;&gt;Database Backend&lt;/a&gt;. If you want to offer write access over SSH, the users of course also need write access to the Git repository itself.</source>
          <target state="translated">참고 : &lt;code&gt;git-cvsserver&lt;/code&gt; 를 호출하려는 각 사용자가 로그 파일 및 데이터베이스에 대한 쓰기 액세스 권한을 가지고 있는지 확인해야 합니다 ( &lt;a href=&quot;#dbbackend&quot;&gt;데이터베이스 백엔드&lt;/a&gt; 참조) . SSH를 통한 쓰기 액세스를 제공하려면 물론 사용자도 쓰기 액세스 권한이 필요합니다. Git 저장소 자체에.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="803fb7d2ab5d83b44291b7856ec7ac09a4ad4990" translate="yes" xml:space="preserve">
          <source>Notes can also be added to patches prepared with &lt;code&gt;git format-patch&lt;/code&gt; by using the &lt;code&gt;--notes&lt;/code&gt; option. Such notes are added as a patch commentary after a three dash separator line.</source>
          <target state="translated">&lt;code&gt;--notes&lt;/code&gt; 옵션 을 사용하여 &lt;code&gt;git format-patch&lt;/code&gt; 로 준비된 패치에 메모를 추가 할 수도 있습니다 . 이러한 노트는 3 개의 대시 구분선 뒤에 패치 주석으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="680f18d9848c14869bd7dca451d5f596480f4677" translate="yes" xml:space="preserve">
          <source>Notes merge strategies</source>
          <target state="translated">메모 병합 전략</target>
        </trans-unit>
        <trans-unit id="abd4e292c73314f22de94f0e2806350a1ebe4452" translate="yes" xml:space="preserve">
          <source>Notes on frequently confused options</source>
          <target state="translated">자주 혼동되는 옵션에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="2ae531e195e6eb05828dc645d74752ea4fda83e4" translate="yes" xml:space="preserve">
          <source>Notes on threads</source>
          <target state="translated">스레드에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="f5aa58376045f00b2abde3758c9ee9232861fade" translate="yes" xml:space="preserve">
          <source>Notes ref to read and manipulate instead of &lt;code&gt;refs/notes/commits&lt;/code&gt;. Must be an unabbreviated ref name. This setting can be overridden through the environment and command line.</source>
          <target state="translated">메모는 &lt;code&gt;refs/notes/commits&lt;/code&gt; 대신 읽고 조작하는 것을 말합니다 . 축약되지 않은 참조 이름이어야합니다. 이 설정은 환경과 명령 줄을 통해 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27c7345a105341e9d7ed2a9f6b06c674d31c0796" translate="yes" xml:space="preserve">
          <source>Notice all types of potential whitespace errors known to Git. The tab width is taken from the value of the &lt;code&gt;core.whitespace&lt;/code&gt; configuration variable.</source>
          <target state="translated">Git에 알려진 모든 유형의 잠재적 공백 오류를 확인하십시오. 탭 너비는 &lt;code&gt;core.whitespace&lt;/code&gt; 구성 변수 의 값에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="b1fa74b0ca5d38d82ab602be416ab241bc186864" translate="yes" xml:space="preserve">
          <source>Notice that regardless of which checkout command we use, &lt;code&gt;HEAD&lt;/code&gt; now refers directly to commit &lt;code&gt;b&lt;/code&gt;. This is known as being in detached &lt;code&gt;HEAD&lt;/code&gt; state. It means simply that &lt;code&gt;HEAD&lt;/code&gt; refers to a specific commit, as opposed to referring to a named branch. Let&amp;rsquo;s see what happens when we create a commit:</source>
          <target state="translated">어떤 체크 아웃 명령을 사용하든 &lt;code&gt;HEAD&lt;/code&gt; 는 이제 commit &lt;code&gt;b&lt;/code&gt; 를 직접 참조합니다 . &lt;code&gt;HEAD&lt;/code&gt; 상태 가 분리 된 것으로 알려져 있습니다. 단순히 &lt;code&gt;HEAD&lt;/code&gt; 가 명명 된 브랜치를 참조하는 것과 달리 특정 커밋을 참조한다는 것을 의미합니다. 커밋을 만들 때 어떤 일이 발생하는지 봅시다 :</target>
        </trans-unit>
        <trans-unit id="394d5767b4ce0798e4d7b91dc89c97c41a6b7f18" translate="yes" xml:space="preserve">
          <source>Notice that since &lt;code&gt;M&lt;/code&gt; is reachable from &lt;code&gt;R&lt;/code&gt;, the edge from &lt;code&gt;N&lt;/code&gt; to &lt;code&gt;M&lt;/code&gt; was simplified away. However, &lt;code&gt;N&lt;/code&gt; still appears in the history as an important commit because it &quot;pulled&quot; the change &lt;code&gt;R&lt;/code&gt; into the main branch.</source>
          <target state="translated">&lt;code&gt;M&lt;/code&gt; 은 &lt;code&gt;R&lt;/code&gt; 에서 도달 할 수 있으므로 &lt;code&gt;N&lt;/code&gt; 에서 &lt;code&gt;M&lt;/code&gt; 까지의 간선 이 단순화되었습니다. 그러나 &lt;code&gt;N&lt;/code&gt; 은 변경 &lt;code&gt;R&lt;/code&gt; 을 메인 브랜치로 &quot;끌어 오기&quot;때문에 여전히 역사에서 중요한 커밋으로 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="223ae08c12689ce4cda40425ac912a2b7bc15955" translate="yes" xml:space="preserve">
          <source>Notify the helper this is a clone request (i.e. the current repository is guaranteed empty).</source>
          <target state="translated">헬퍼에게 이것이 복제 요청임을 알립니다 (즉, 현재 저장소는 비어 있음).</target>
        </trans-unit>
        <trans-unit id="4abfc187ad76ac88063d3dc9dd98a5854ac68fcf" translate="yes" xml:space="preserve">
          <source>Now add the changes to the index that you want to have in the first commit. You can use &lt;code&gt;git add&lt;/code&gt; (possibly interactively) or &lt;code&gt;git gui&lt;/code&gt; (or both) to do that.</source>
          <target state="translated">이제 첫 번째 커밋에서 갖고 싶은 인덱스에 변경 사항을 추가하십시오. 당신이 사용할 수있는 &lt;code&gt;git add&lt;/code&gt; (아마도 대화 형) 또는 &lt;code&gt;git gui&lt;/code&gt; 그렇게 (모두 이상).</target>
        </trans-unit>
        <trans-unit id="f89d262ba51a934099d56714cbb679d531203dd2" translate="yes" xml:space="preserve">
          <source>Now clone the superproject:</source>
          <target state="translated">이제 superproject를 복제하십시오.</target>
        </trans-unit>
        <trans-unit id="ba793c9ae00cb4d237b36de220bcaff0d64b7a28" translate="yes" xml:space="preserve">
          <source>Now create the branches in which you are going to work; these start out at the current tip of origin/master branch, and should be set up (using the &lt;code&gt;--track&lt;/code&gt; option to &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;) to merge changes in from Linus by default.</source>
          <target state="translated">이제 작업 할 브랜치를 작성하십시오. 이것들은 현재 원점 / 마스터 브랜치의 끝에서 시작 하며 기본적으로 Linus에서 변경 사항을 병합 하도록 설정해야합니다 ( &lt;code&gt;--track&lt;/code&gt; 옵션을 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; 으로 설정).</target>
        </trans-unit>
        <trans-unit id="b3aa6a5493fd6ad1a98101f846b1686abf42b2c1" translate="yes" xml:space="preserve">
          <source>Now create the superproject and add all the submodules:</source>
          <target state="translated">이제 superproject를 만들고 모든 서브 모듈을 추가하십시오 :</target>
        </trans-unit>
        <trans-unit id="aec2ee2ebf7f0a1017c29bcb872a25ae6bf7b23d" translate="yes" xml:space="preserve">
          <source>Now is a good point to take a break to let this information sink in.</source>
          <target state="translated">이제이 정보가 침투 할 수 있도록 휴식을 취하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8125d3bd8f5c390de8746d2ef58ce50b7de72c0b" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s suppose that commit J is bad and commit G is good and that we apply the bisection algorithm like it has been previously described.</source>
          <target state="translated">커밋 J가 나쁘고 커밋 G가 좋으며 이전에 설명한 것처럼 이분법 알고리즘을 적용한다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="880aeec71bcb81a6f397f1be442543fc2e21cab4" translate="yes" xml:space="preserve">
          <source>Now suppose that Joe wants his middle name initial used, and Jane prefers her family name fully spelled out. A proper &lt;code&gt;.mailmap&lt;/code&gt; file would look like:</source>
          <target state="translated">이제 Joe가 중간 이름을 처음 사용하기를 원하고 Jane이 가족 이름을 완전히 입력 한 것을 선호한다고 가정합니다. 적절한 &lt;code&gt;.mailmap&lt;/code&gt; 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e7c06961fbf7a9468c5f87e472b9bdf95e1fa5a" translate="yes" xml:space="preserve">
          <source>Now to apply some patches from the community. Think of a short snappy name for a branch to hold this patch (or related group of patches), and create a new branch from a recent stable tag of Linus&amp;rsquo;s branch. Picking a stable base for your branch will: 1) help you: by avoiding inclusion of unrelated and perhaps lightly tested changes 2) help future bug hunters that use &lt;code&gt;git bisect&lt;/code&gt; to find problems</source>
          <target state="translated">이제 커뮤니티의 패치를 적용하겠습니다. 이 패치 (또는 관련 패치 그룹)를 보유 할 지점의 짧은 이름을 생각하고 최근 Linus 지점의 안정적인 태그에서 새 지점을 만듭니다. 지사에 안정적인 기반을 고르면 1) 도움이 될 것 : 관련이없고 약간 테스트 된 변경 사항을 포함하지 않음 2) &lt;code&gt;git bisect&lt;/code&gt; 를 사용 하여 문제를 찾는 미래의 버그 사냥꾼을 도울 것</target>
        </trans-unit>
        <trans-unit id="31a13e21421ef92e8ef4a0a89bea77231f7d36fb" translate="yes" xml:space="preserve">
          <source>Now use &lt;code&gt;git submodule update&lt;/code&gt; to clone the repositories and check out the commits specified in the superproject:</source>
          <target state="translated">이제 &lt;code&gt;git submodule update&lt;/code&gt; 를 사용 하여 저장소를 복제하고 수퍼 프로젝트에 지정된 커밋을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="93f7a0302cd464e3e88673ccf5b8a8b034507a50" translate="yes" xml:space="preserve">
          <source>Now we are ready to experiment with the merge by hand.</source>
          <target state="translated">이제 손으로 병합을 실험 할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="0479e792f6adb8abb7cacffe33ca0f7a5b48ab2f" translate="yes" xml:space="preserve">
          <source>Now we will suppose that there is only one &quot;first bad commit&quot;. This means that all its descendants are &quot;bad&quot; and all the other commits are &quot;good&quot;. And we will suppose that all commits have an equal probability of being good or bad, or of being the first bad commit, so knowing the state of c commits gives always the same amount of information wherever these c commits are on the graph and whatever c is. (So we suppose that these commits being for example on a branch or near a good or a bad commit does not give more or less information).</source>
          <target state="translated">이제 &quot;첫 번째 나쁜 커밋&quot;이 하나만 있다고 가정하겠습니다. 이것은 모든 자손이 &quot;나쁜&quot;것이고 다른 모든 커밋은 &quot;좋은&quot;것을 의미합니다. 그리고 우리는 모든 커밋이 좋거나 나쁘거나 첫 번째 커밋이 될 확률이 같다고 가정합니다. 따라서 c 커밋 상태를 알면 이러한 c 커밋이 그래프의 어디에 있든지 c 입니다. 따라서 우리는 이러한 커밋이 예를 들어 지점에서 또는 양호 또는 불량 커밋 근처에서 정보를 제공하지 않는다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="16cb16561e679da512d88420e76326b5c722ec8f" translate="yes" xml:space="preserve">
          <source>Now when the background process runs &lt;code&gt;git fetch origin&lt;/code&gt; the references on &lt;code&gt;origin-push&lt;/code&gt; won&amp;rsquo;t be updated, and thus commands like:</source>
          <target state="translated">이제 백그라운드 프로세스가 &lt;code&gt;git fetch origin&lt;/code&gt; 을 실행 하면 &lt;code&gt;origin-push&lt;/code&gt; 의 참조 가 업데이트되지 않으므로 다음과 같은 명령이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3ecf9739a1d0abf420c43be7ddca1b7fc46c48f7" translate="yes" xml:space="preserve">
          <source>Now you apply the patch(es), run some tests, and commit the change(s). If the patch is a multi-part series, then you should apply each as a separate commit to this branch.</source>
          <target state="translated">이제 패치를 적용하고 테스트를 실행 한 후 변경 사항을 커밋합니다. 패치가 여러 부분으로 구성된 시리즈 인 경우이 분기에 각각 별도의 커밋으로 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac8b110d69f8df7d9503ad0a18549a8731f4daf9" translate="yes" xml:space="preserve">
          <source>Now you are wiser, because you know that it happened 940 revisions before v0.99.</source>
          <target state="translated">v0.99 이전의 940 개정판이 발생 했으므로 더 현명합니다.</target>
        </trans-unit>
        <trans-unit id="54796c29834d872153c55921bf00540d7c6165a5" translate="yes" xml:space="preserve">
          <source>Now you can proceed with the creation of the feature release. Apply a tag to the tip of &lt;code&gt;master&lt;/code&gt; indicating the release version:</source>
          <target state="translated">이제 기능 릴리스 작성을 진행할 수 있습니다. 릴리스 버전을 나타내는 태그를 &lt;code&gt;master&lt;/code&gt; 팁에 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d60447094204d4dec9840c772eacade572f28205" translate="yes" xml:space="preserve">
          <source>Now you know that blob 4b9458b3 is missing, and that the tree 2d9263c6 points to it. If you could find just one copy of that missing blob object, possibly in some other repository, you could move it into &lt;code&gt;.git/objects/4b/9458b3&amp;hellip;​&lt;/code&gt; and be done. Suppose you can&amp;rsquo;t. You can still examine the tree that pointed to it with &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt;, which might output something like:</source>
          <target state="translated">이제 blob 4b9458b3이 누락되었으며 2d9263c6 트리가이를 가리 킵니다. 당신이없는 Blob 오브젝트의 한 복사본을 찾을 수 있다면, 아마도 다른 저장소에서, 당신이로 이동할 수있는 &lt;code&gt;.git/objects/4b/9458b3&amp;hellip;​&lt;/code&gt; 그리고는 할 수. 할 수 없다고 가정하십시오. &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree [1] 사용&lt;/a&gt; 하여 트리를 가리키는 트리를 여전히 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27bdc85bfa21b19b41e38ad33e104e7c138a6d4d" translate="yes" xml:space="preserve">
          <source>Now you know that blob 4b9458b3 is missing, and that the tree 2d9263c6 points to it. If you could find just one copy of that missing blob object, possibly in some other repository, you could move it into &lt;code&gt;.git/objects/4b/9458b3...&lt;/code&gt; and be done. Suppose you can&amp;rsquo;t. You can still examine the tree that pointed to it with &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt;, which might output something like:</source>
          <target state="translated">이제 blob 4b9458b3이 누락되었으며 트리 2d9263c6이이를 가리 킵니다. 누락 된 blob 개체의 복사본 하나만 다른 저장소에서 찾을 수 있다면 &lt;code&gt;.git/objects/4b/9458b3...&lt;/code&gt; 로 이동하여 완료 할 수 있습니다. 당신이 할 수 없다고 가정하십시오. &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree [1]&lt;/a&gt; 을 사용하여 가리키는 트리를 계속 검사 할 수 있으며 다음과 같은 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c93b9bdc902ddf8466cfefc51dc1f28429545152" translate="yes" xml:space="preserve">
          <source>Now you&amp;rsquo;ve split out many of the changes into their own commits, and might no longer use the patch mode of &lt;code&gt;git add&lt;/code&gt;, in order to select all remaining uncommitted changes.</source>
          <target state="translated">이제 많은 변경 사항을 자체 커밋으로 나누었으며 커밋 되지 않은 나머지 변경 사항을 모두 선택하기 위해 더 이상 &lt;code&gt;git add&lt;/code&gt; 패치 모드를 사용하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="69b6ae43249b3d4c8e61d7b20084413cd49e5e3e" translate="yes" xml:space="preserve">
          <source>Now, for the meat:</source>
          <target state="translated">이제 고기를 위해 :</target>
        </trans-unit>
        <trans-unit id="4449e60d3fdd6703a4970ef116187e4c17d80dc4" translate="yes" xml:space="preserve">
          <source>Now, in this case we&amp;rsquo;ve intentionally created a situation where the merge will need to be fixed up by hand, though, so Git will do as much of it as it can automatically (which in this case is just merge the &lt;code&gt;example&lt;/code&gt; file, which had no differences in the &lt;code&gt;mybranch&lt;/code&gt; branch), and say:</source>
          <target state="translated">이제이 경우 의도적으로 병합을 수동으로 수정해야하는 상황을 만들었으므로 Git은 자동으로 최대한 많은 작업을 수행합니다 (이 경우 &lt;code&gt;example&lt;/code&gt; 파일을 병합하기 만하면 됩니다). &lt;code&gt;mybranch&lt;/code&gt; 브랜치 에는 아무런 차이가 없었습니다 ).</target>
        </trans-unit>
        <trans-unit id="93036e7630aadf8fab80b9b1079ffb3d1ea1e18f" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s pretend you are the one who did all the work in &lt;code&gt;mybranch&lt;/code&gt;, and the fruit of your hard work has finally been merged to the &lt;code&gt;master&lt;/code&gt; branch. Let&amp;rsquo;s go back to &lt;code&gt;mybranch&lt;/code&gt;, and run &lt;code&gt;git merge&lt;/code&gt; to get the &quot;upstream changes&quot; back to your branch.</source>
          <target state="translated">이제, 당신이 &lt;code&gt;mybranch&lt;/code&gt; 에서 모든 일을 한 사람이라고 가정 해 봅시다 . 그리고 당신의 노력의 결과가 마침내 &lt;code&gt;master&lt;/code&gt; 지부에 합병되었습니다 . &lt;code&gt;mybranch&lt;/code&gt; 로 돌아가서 &lt;code&gt;git merge&lt;/code&gt; 를 실행 하여 &quot;업스트림 변경 사항&quot;을 브랜치로 다시 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="7c23965b9cba90dec960d959f0eea85b60ea2b28" translate="yes" xml:space="preserve">
          <source>Now, since we&amp;rsquo;ve updated &lt;code&gt;hello&lt;/code&gt; in the index, we can commit the new version. We could do it by writing the tree by hand again, and committing the tree (this time we&amp;rsquo;d have to use the &lt;code&gt;-p HEAD&lt;/code&gt; flag to tell commit that the HEAD was the &lt;strong&gt;parent&lt;/strong&gt; of the new commit, and that this wasn&amp;rsquo;t an initial commit any more), but you&amp;rsquo;ve done that once already, so let&amp;rsquo;s just use the helpful script this time:</source>
          <target state="translated">이제 색인에서 &lt;code&gt;hello&lt;/code&gt; 를 업데이트 했으므로 새 버전을 커밋 할 수 있습니다. 우리는 트리를 손으로 다시 작성하고 트리를 커밋함으로써 할 수 있습니다. (이번에 는 HEAD가 새로운 커밋 의 &lt;strong&gt;부모&lt;/strong&gt; 임을 알리기 위해 &lt;code&gt;-p HEAD&lt;/code&gt; 플래그를 사용해야합니다. 더 이상 초기 커밋)하지만 ​​이미 한 번 완료 했으므로 이번에는 유용한 스크립트를 사용하십시오.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dfab069f398c1bff7a8b8aa3dadd95d2ce84088a" translate="yes" xml:space="preserve">
          <source>Now, to make it a bit more interesting, let&amp;rsquo;s assume that somebody else does some work in the original branch, and simulate that by going back to the master branch, and editing the same file differently there:</source>
          <target state="translated">이제 좀 더 흥미롭게하기 위해 다른 누군가가 원래 분기에서 일부 작업을 수행한다고 가정하고 마스터 분기로 돌아가서 동일한 파일을 다르게 편집하여이를 시뮬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="83bf1df5f5028baeb9804ff8b012e2bfb43363e7" translate="yes" xml:space="preserve">
          <source>Now, we want to go to the next stage in Git, which is to take the files that Git knows about in the index, and commit them as a real tree. We do that in two phases: creating a &lt;code&gt;tree&lt;/code&gt; object, and committing that &lt;code&gt;tree&lt;/code&gt; object as a &lt;code&gt;commit&lt;/code&gt; object together with an explanation of what the tree was all about, along with information of how we came to that state.</source>
          <target state="translated">이제 Git의 다음 단계로 가려고합니다. Git이 인덱스에서 알고있는 파일을 가져 와서 실제 트리로 커밋하는 것입니다. 우리는 두 단계로 &lt;code&gt;tree&lt;/code&gt; 객체를 생성 하고 그 &lt;code&gt;tree&lt;/code&gt; 객체를 &lt;code&gt;commit&lt;/code&gt; 객체 로 커밋 하고 트리가 무엇인지에 대한 설명과 그 상태에 도달 한 방법에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4b50314ab323fb71cb3292dbd2b0326c17673414" translate="yes" xml:space="preserve">
          <source>Now, you will get the rewritten history saved in HEAD.</source>
          <target state="translated">이제 다시 작성된 이력을 HEAD에 저장하게됩니다.</target>
        </trans-unit>
        <trans-unit id="575836ebc8e262c11aa86a9dd4e0c52f7d072bcd" translate="yes" xml:space="preserve">
          <source>Now, you&amp;rsquo;ve got two branches, and you decide that you want to merge the work done. Before we do that, let&amp;rsquo;s introduce a cool graphical tool that helps you view what&amp;rsquo;s going on:</source>
          <target state="translated">이제 두 개의 브랜치가 있고 작업을 병합하기로 결정했습니다. 그렇게하기 전에 진행 상황을 확인하는 데 도움이되는 멋진 그래픽 도구를 소개하겠습니다.</target>
        </trans-unit>
        <trans-unit id="910f1e558e60364937a941e26d7def6b701f836e" translate="yes" xml:space="preserve">
          <source>Nowadays though gitweb should create HTML base tag when needed (to set base URI for relative links), so it should work automatically.</source>
          <target state="translated">요즘 gitweb은 필요할 때 HTML 기본 태그를 만들어야하지만 (상대 링크의 기본 URI를 설정하기 위해) 자동으로 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="9a11d4479b92e7b2c9a9fc979b41f6f7eb2a1edf" translate="yes" xml:space="preserve">
          <source>Nowadays, &lt;code&gt;git log&lt;/code&gt; is a builtin, which means that it is &lt;code&gt;contained&lt;/code&gt; in the command &lt;code&gt;git&lt;/code&gt;. The source side of a builtin is</source>
          <target state="translated">요즘 &lt;code&gt;git log&lt;/code&gt; 는 빌트인이므로 &lt;code&gt;git&lt;/code&gt; 명령에 &lt;code&gt;contained&lt;/code&gt; 되어 있습니다. 내장의 소스 측은</target>
        </trans-unit>
        <trans-unit id="33e31083ab9551e7141ee8a3ee7a0a4d045c20a2" translate="yes" xml:space="preserve">
          <source>Number of bytes of a pack file to map into memory in a single mapping operation. Larger window sizes may allow your system to process a smaller number of large pack files more quickly. Smaller window sizes will negatively affect performance due to increased calls to the operating system&amp;rsquo;s memory manager, but may improve performance when accessing a large number of large pack files.</source>
          <target state="translated">단일 맵핑 조작에서 메모리에 맵핑 할 팩 파일의 바이트 수입니다. 창 크기가 클수록 시스템에서 더 적은 수의 큰 팩 파일을 더 빠르게 처리 할 수 ​​있습니다. 창 크기가 작 으면 운영 체제의 메모리 관리자에 대한 호출 증가로 인해 성능에 부정적인 영향을 주지만 많은 수의 큰 팩 파일에 액세스 할 때 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="782270330831f0728fbf1b39424dcd7ac04c3bcf" translate="yes" xml:space="preserve">
          <source>Number of grep worker threads to use. If unset (or set to 0), 8 threads are used by default (for now).</source>
          <target state="translated">사용할 grep worker 스레드 수 설정 해제 (또는 0으로 설정)하면 기본적으로 8 개의 스레드가 사용됩니다 (현재).</target>
        </trans-unit>
        <trans-unit id="07386a7e3f4686f698d276d122f56af1a564e2f6" translate="yes" xml:space="preserve">
          <source>Number of grep worker threads to use. If unset (or set to 0), Git will use as many threads as the number of logical cores available.</source>
          <target state="translated">사용할 grep 작업자 스레드 수입니다. 설정하지 않으면 (또는 0으로 설정) Git은 사용 가능한 논리적 코어 수만큼 스레드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b3f7cd4c72eff1cd06e6ea960c75592f7883408d" translate="yes" xml:space="preserve">
          <source>Number of grep worker threads to use. See &lt;code&gt;grep.threads&lt;/code&gt; in &lt;a href=&quot;git-grep&quot;&gt;git-grep[1]&lt;/a&gt; for more information.</source>
          <target state="translated">사용할 grep worker 스레드 수 자세한 내용 은 &lt;a href=&quot;git-grep&quot;&gt;git-grep [1]의 &lt;/a&gt; &lt;code&gt;grep.threads&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="340883bf973e4a0a0a15928c3b44200ef6d0edac" translate="yes" xml:space="preserve">
          <source>Number of grep worker threads to use. See &lt;code&gt;grep.threads&lt;/code&gt; in &lt;code&gt;CONFIGURATION&lt;/code&gt; for more information.</source>
          <target state="translated">사용할 grep worker 스레드 수 자세한 내용 은 &lt;code&gt;CONFIGURATION&lt;/code&gt; 의 &lt;code&gt;grep.threads&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4a06461d5cac364fcad71d6e428b30d7321d874b" translate="yes" xml:space="preserve">
          <source>Number of messages to be sent per connection, after that a relogin will happen. If the value is 0 or undefined, send all messages in one connection. See also the &lt;code&gt;--batch-size&lt;/code&gt; option of &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt;.</source>
          <target state="translated">재 로그인이 발생한 후 연결 당 전송 될 메시지 수입니다. 값이 0이거나 정의되지 않은 경우 한 번의 연결로 모든 메시지를 보내십시오. &lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt; 의 &lt;code&gt;--batch-size&lt;/code&gt; 옵션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="263d5a12c4d7938e6b1945ed2d424a531e8ffd37" translate="yes" xml:space="preserve">
          <source>Number of parallel children to be used for all forms of fetching.</source>
          <target state="translated">모든 형태의 페칭에 사용될 병렬 자식 수입니다.</target>
        </trans-unit>
        <trans-unit id="5f124a70076360d6cdb202a3452dac6608d9c87a" translate="yes" xml:space="preserve">
          <source>Number of seconds to cache credentials (default: 900).</source>
          <target state="translated">자격 증명을 캐시하는 시간 (초)입니다 (기본값 : 900).</target>
        </trans-unit>
        <trans-unit id="0600a433ee142590b5ed0795ec15517899403cc1" translate="yes" xml:space="preserve">
          <source>OBJ_BLOB (3)</source>
          <target state="translated">OBJ_BLOB (3)</target>
        </trans-unit>
        <trans-unit id="20a9deedd57091e656a9ceb8afe723fea4c8ae28" translate="yes" xml:space="preserve">
          <source>OBJ_COMMIT (1)</source>
          <target state="translated">OBJ_COMMIT (1)</target>
        </trans-unit>
        <trans-unit id="33b36795cfe9033fd325f2c4f57ccf4bbcdb1c8c" translate="yes" xml:space="preserve">
          <source>OBJ_OFS_DELTA (6)</source>
          <target state="translated">OBJ_OFS_DELTA (6)</target>
        </trans-unit>
        <trans-unit id="ad63d6a2f7a5f774df4b60dc52ffc40dc66ab330" translate="yes" xml:space="preserve">
          <source>OBJ_REF_DELTA (7)</source>
          <target state="translated">OBJ_REF_DELTA (7)</target>
        </trans-unit>
        <trans-unit id="bf0dce0da3b6ff387e755df6e790a1cac5898dd7" translate="yes" xml:space="preserve">
          <source>OBJ_TAG (4)</source>
          <target state="translated">OBJ_TAG (4)</target>
        </trans-unit>
        <trans-unit id="2f77abc6705f39815a181a261b98c26e748660a6" translate="yes" xml:space="preserve">
          <source>OBJ_TREE (2)</source>
          <target state="translated">OBJ_TREE (2)</target>
        </trans-unit>
        <trans-unit id="bcb75e6bd3e418ec921606a22f47e84ce889c09d" translate="yes" xml:space="preserve">
          <source>OK, still with me? To give us an example to look at, let&amp;rsquo;s go back to the earlier repository with &quot;hello&quot; and &quot;example&quot; file, and bring ourselves back to the pre-merge state:</source>
          <target state="translated">그래, 아직도 나와? 살펴볼 예제를 제공하기 위해 &quot;hello&quot;및 &quot;example&quot;파일을 사용하여 이전 저장소로 돌아가서 병합 전 상태로 돌아가 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="6477da6d91ea639e6e30c40f69d7500177d55603" translate="yes" xml:space="preserve">
          <source>OK, this all sounds like a collection of totally nonsensical rules, but it&amp;rsquo;s actually exactly what you want in order to do a fast merge. The different stages represent the &quot;result tree&quot; (stage 0, aka &quot;merged&quot;), the original tree (stage 1, aka &quot;orig&quot;), and the two trees you are trying to merge (stage 2 and 3 respectively).</source>
          <target state="translated">자, 이것은 모두 무의미한 규칙 모음처럼 들리지만 실제로 빠른 병합을 수행하기 위해 실제로 원하는 것입니다. 서로 다른 단계는 &quot;결과 트리&quot;(단계 0, 일명 &quot;병합&quot;), 원래 트리 (단계 1, 일명 &quot;원래&quot;) 및 병합하려는 두 나무 (각각 2 단계 및 3 단계)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="30c34ea4528b5e99d721b2ada273c08402f70a1d" translate="yes" xml:space="preserve">
          <source>Object Traversal</source>
          <target state="translated">객체 순회</target>
        </trans-unit>
        <trans-unit id="e07348665c9e3f452362a58c36e1f55665279269" translate="yes" xml:space="preserve">
          <source>Object access and manipulation</source>
          <target state="translated">객체 접근 및 조작</target>
        </trans-unit>
        <trans-unit id="d963c54afefdbe29bbc1f0380d42869afd8a753b" translate="yes" xml:space="preserve">
          <source>Object size identified by &amp;lt;object&amp;gt; is given in bytes, and right-justified with minimum width of 7 characters. Object size is given only for blobs (file) entries; for other entries &lt;code&gt;-&lt;/code&gt; character is used in place of size.</source>
          <target state="translated">&amp;lt;object&amp;gt;로 식별 된 객체 크기는 바이트 단위로 제공되며 최소 너비는 7 자입니다. 오브젝트 크기는 Blob (파일) 항목에 대해서만 제공됩니다. 다른 항목에 대해 &lt;code&gt;-&lt;/code&gt; 문자 크기 대신에 사용된다.</target>
        </trans-unit>
        <trans-unit id="5a755e02f9fddc8d9863cff303858fc5c0963f4b" translate="yes" xml:space="preserve">
          <source>Object storage format</source>
          <target state="translated">객체 저장 형식</target>
        </trans-unit>
        <trans-unit id="4410a56144704dcadb0adeabc1f66b086332a778" translate="yes" xml:space="preserve">
          <source>Object store associated with this repository. Usually an object store is self sufficient (i.e. all the objects that are referred to by an object found in it are also found in it), but there are a few ways to violate it.</source>
          <target state="translated">이 저장소와 연관된 오브젝트 저장소 일반적으로 오브젝트 저장소는 충분하지만 (즉, 오브젝트에있는 오브젝트가 참조하는 모든 오브젝트도 해당 오브젝트에 있습니다),이를 위반하는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="66c888d10ab6a46198fcec7325df97ad7688050e" translate="yes" xml:space="preserve">
          <source>Object types</source>
          <target state="translated">객체 유형</target>
        </trans-unit>
        <trans-unit id="397880af9235fafbc028a684c78f613458679a72" translate="yes" xml:space="preserve">
          <source>Objects that already exist in the repository will &lt;strong&gt;not&lt;/strong&gt; be unpacked from the packfile. Therefore, nothing will be unpacked if you use this command on a packfile that exists within the target repository.</source>
          <target state="translated">저장소에 이미 존재하는 오브젝트 는 팩 파일에서 압축 해제 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 따라서 대상 리포지토리 내에있는 팩 파일에서이 명령을 사용하면 압축이 풀리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f90e1faea66f4ee07afc15b9cfbe6b37aebe1076" translate="yes" xml:space="preserve">
          <source>Objects unreachable from the refs in packs named with --unpacked= option are added to the resulting pack, in addition to the reachable objects that are not in packs marked with *.keep files. This implies &lt;code&gt;--revs&lt;/code&gt;.</source>
          <target state="translated">--unpacked = 옵션으로 이름이 지정된 팩의 참조에서 도달 할 수없는 객체는 * .keep 파일로 표시된 팩에없는 도달 가능한 객체 외에 결과 팩에 추가됩니다. 이것은 &lt;code&gt;--revs&lt;/code&gt; 를 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="c4b47085e458e48bb4b0605ca6d2f6a3cc7755c2" translate="yes" xml:space="preserve">
          <source>Obsolete for: &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt;.</source>
          <target state="translated">사용되지 않습니다 : &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d42a49317326d6b79f20beebf76935d065ccac7f" translate="yes" xml:space="preserve">
          <source>Obviously, endless variations are possible; for example, to see all commits reachable from some head but not from any tag in the repository:</source>
          <target state="translated">분명히 끝없는 변형이 가능합니다. 예를 들어 리포지토리의 태그가 아닌 일부 헤드에서 도달 가능한 모든 커밋을 보려면</target>
        </trans-unit>
        <trans-unit id="80e98962116f1f595b28a3f430e4b1f9c4dbde82" translate="yes" xml:space="preserve">
          <source>Occasionally, the maintainer may get merge conflicts when they try to pull changes from downstream. In this case, they can ask downstream to do the merge and resolve the conflicts themselves (perhaps they will know better how to resolve them). It is one of the rare cases where downstream &lt;code&gt;should&lt;/code&gt; merge from upstream.</source>
          <target state="translated">때때로, 관리자는 다운 스트림에서 변경 사항을 가져 오려고 할 때 병합 충돌이 발생할 수 있습니다. 이 경우 다운 스트림에서 병합을 수행하고 충돌 자체를 해결하도록 요청할 수 있습니다 (아마도 충돌 해결 방법을 더 잘 알고있을 것입니다). 다운 스트림 &lt;code&gt;should&lt;/code&gt; 업스트림에서 병합 되어야 하는 드문 경우 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="7c4df738049a7589e8637595f08e890f6ad9d98e" translate="yes" xml:space="preserve">
          <source>Of course some kind of software is developed, then used during some time without being improved on much, and then finally thrown away. In this case, of course, regressions may not be a big problem. But on the other hand, there is a lot of big software that is continually developed and maintained during years or even tens of years by a lot of people. And as there are often many people who depend (sometimes critically) on such software, regressions are a really big problem.</source>
          <target state="translated">물론 어떤 종류의 소프트웨어가 개발되어 일정 기간 동안 많이 개선되지 않고 사용 된 다음 마침내 버려집니다. 물론이 경우에는 회귀가 큰 문제가되지 않을 수 있습니다. 그러나 다른 한편으로, 많은 사람들에 의해 수십 년 또는 수십 년 동안 지속적으로 개발되고 유지되는 많은 큰 소프트웨어가 있습니다. 이러한 소프트웨어에 의존하는 사람들이 종종 있기 때문에 회귀는 정말 큰 문제입니다.</target>
        </trans-unit>
        <trans-unit id="19fce424b8331b64c65b8a6acafb03304b015bfc" translate="yes" xml:space="preserve">
          <source>Of course the &quot;bad&quot; commit cannot be an ancestor of a &quot;good&quot; commit, because the ancestors of the good commits are supposed to be &quot;good&quot;. And all the &quot;good&quot; commits must be related to the bad commit. They cannot be on a branch that has no link with the branch of the &quot;bad&quot; commit. But it is possible for a good commit to be related to a bad commit and yet not be neither one of its ancestor nor one of its descendants.</source>
          <target state="translated">물론 &quot;나쁜&quot;커밋은 &quot;좋은&quot;커밋의 조상이 될 수 없습니다. 좋은 커밋의 조상은 &quot;좋은&quot;것으로 간주되기 때문입니다. 그리고 모든 &quot;좋은&quot;커밋은 나쁜 커밋과 관련이 있어야합니다. &quot;나쁜&quot;커밋의 분기와 연결되지 않은 분기에는있을 수 없습니다. 그러나 좋은 커밋은 나쁜 커밋과 관련이있을 수 있지만 아직 그 조상이나 후손이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7c78c10d5c75907a546f96553e9802bb23f4c982" translate="yes" xml:space="preserve">
          <source>Of course, there may be more than one answer&amp;mdash;​if the history branched after commit e05db0fd, then there could be multiple &quot;earliest&quot; tagged releases.</source>
          <target state="translated">물론 커밋 e05db0fd 이후 히스토리가 분기 된 경우 여러 개의 &quot;초기&quot;태그가 지정된 릴리스가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc73231ef0df798acd7604c5e90f5ea460992bab" translate="yes" xml:space="preserve">
          <source>Often people use &lt;code&gt;git pull&lt;/code&gt; without giving any parameter. Traditionally, this has been equivalent to saying &lt;code&gt;git pull
origin&lt;/code&gt;. However, when configuration &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; is present while on branch &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;, that value is used instead of &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="translated">종종 사람들은 매개 변수를 지정하지 않고 &lt;code&gt;git pull&lt;/code&gt; 을 사용 합니다. 전통적으로 이것은 &lt;code&gt;git pull origin&lt;/code&gt; 을 말하는 것과 같습니다 . 구성 그러나 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 지점에 존재하는 동안에 인 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; , 그 값이 대신 사용된다 &lt;code&gt;origin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="813c6a487fc92be3bf23c6677bbfade25d37be89" translate="yes" xml:space="preserve">
          <source>Often the current branch head is an ancestor of the named commit. This is the most common case especially when invoked from &lt;code&gt;git pull&lt;/code&gt;: you are tracking an upstream repository, you have committed no local changes, and now you want to update to a newer upstream revision. In this case, a new commit is not needed to store the combined history; instead, the &lt;code&gt;HEAD&lt;/code&gt; (along with the index) is updated to point at the named commit, without creating an extra merge commit.</source>
          <target state="translated">종종 현재 브랜치 헤드는 명명 된 커밋의 조상입니다. 이것은 특히 &lt;code&gt;git pull&lt;/code&gt; 에서 호출 될 때 가장 일반적인 경우입니다 . 업스트림 리포지토리를 추적하고 로컬 변경 사항을 커밋하지 않았으므로 이제 새로운 업스트림 버전으로 업데이트하려고합니다. 이 경우 결합 된 히스토리를 저장하기 위해 새로운 커밋이 필요하지 않습니다. 대신 &lt;code&gt;HEAD&lt;/code&gt; (인덱스와 함께)는 추가 병합 커밋을 만들지 않고 명명 된 커밋을 가리 키도록 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="bc22c639538c04ca7d5608268e4dc9b34f324581" translate="yes" xml:space="preserve">
          <source>Often the overview of the change is useful to get a feel of each step</source>
          <target state="translated">종종 변화의 개요는 각 단계의 느낌을 얻는 데 유용합니다</target>
        </trans-unit>
        <trans-unit id="a0ef5be0d5f74372c2549cc7906cdb110a910654" translate="yes" xml:space="preserve">
          <source>Often, &quot;please pull&quot; messages on the mailing list just provide two pieces of information: a repo URL and a branch name; this is designed to be easily cut&amp;amp;pasted at the end of a &lt;code&gt;git fetch&lt;/code&gt; command line:</source>
          <target state="translated">종종 메일 링리스트에있는 &quot;Please pull&quot;메시지는 repo URL과 branch name; 이것은 &lt;code&gt;git fetch&lt;/code&gt; 명령 줄 의 끝에서 쉽게 잘라내어 붙여 넣을 수 있도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b90f5f996d698883902ffd1dba32d6eea369ef9a" translate="yes" xml:space="preserve">
          <source>Older documentation written before the packed-refs mechanism was introduced may still say things like &quot;.git/refs/heads/&amp;lt;branch&amp;gt; file exists&quot; when it means &quot;branch &amp;lt;branch&amp;gt; exists&quot;.</source>
          <target state="translated">압축 참조 메커니즘이 도입되기 전에 작성된 이전 문서는 &quot;branch &amp;lt;branch&amp;gt; 존재&quot;를 의미 할 때 &quot;.git / refs / heads / &amp;lt;branch&amp;gt; 파일이 있음&quot;과 같은 내용을 계속 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a148aab8f38b980de65dd5f412fc336ae5d855f6" translate="yes" xml:space="preserve">
          <source>Older scripts may depend on the historical behaviour of not allowing the user to edit the merge log message. They will see an editor opened when they run &lt;code&gt;git merge&lt;/code&gt;. To make it easier to adjust such scripts to the updated behaviour, the environment variable &lt;code&gt;GIT_MERGE_AUTOEDIT&lt;/code&gt; can be set to &lt;code&gt;no&lt;/code&gt; at the beginning of them.</source>
          <target state="translated">이전 스크립트는 사용자가 병합 로그 메시지를 편집 할 수 없도록하는 이전 동작에 따라 달라질 수 있습니다. &lt;code&gt;git merge&lt;/code&gt; 를 실행할 때 편집기가 열린 것을 볼 수 있습니다 . 이러한 스크립트를 업데이트 된 동작에보다 쉽게 ​​조정하기 위해 시작시 환경 변수 &lt;code&gt;GIT_MERGE_AUTOEDIT&lt;/code&gt; 를 &lt;code&gt;no&lt;/code&gt; 로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a027c8ab6aede7960dbe3d141d016ee3e6589ef" translate="yes" xml:space="preserve">
          <source>Older versions of &lt;code&gt;meld&lt;/code&gt; do not support the &lt;code&gt;--output&lt;/code&gt; option. Git will attempt to detect whether &lt;code&gt;meld&lt;/code&gt; supports &lt;code&gt;--output&lt;/code&gt; by inspecting the output of &lt;code&gt;meld --help&lt;/code&gt;. Configuring &lt;code&gt;mergetool.meld.hasOutput&lt;/code&gt; will make Git skip these checks and use the configured value instead. Setting &lt;code&gt;mergetool.meld.hasOutput&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; tells Git to unconditionally use the &lt;code&gt;--output&lt;/code&gt; option, and &lt;code&gt;false&lt;/code&gt; avoids using &lt;code&gt;--output&lt;/code&gt;.</source>
          <target state="translated">이전 버전의 &lt;code&gt;meld&lt;/code&gt; 는 &lt;code&gt;--output&lt;/code&gt; 옵션을 지원하지 않습니다 . Git은 &lt;code&gt;meld --help&lt;/code&gt; 의 출력을 검사하여 &lt;code&gt;meld&lt;/code&gt; 가 &lt;code&gt;--output&lt;/code&gt; 을 지원 하는지 여부를 감지하려고 시도합니다 . &lt;code&gt;mergetool.meld.hasOutput&lt;/code&gt; 을 구성 하면 Git이 이러한 검사를 건너 뛰고 구성된 값을 대신 사용합니다. &lt;code&gt;mergetool.meld.hasOutput&lt;/code&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 Git에 무조건 &lt;code&gt;--output&lt;/code&gt; 옵션을 사용 하고 &lt;code&gt;false&lt;/code&gt; 는 &lt;code&gt;--output&lt;/code&gt; 사용을 피 합니다.</target>
        </trans-unit>
        <trans-unit id="8511fe9d48b84ff3883d162d35ccd3dcba224454" translate="yes" xml:space="preserve">
          <source>Older versions of Git (before 2.20) documented that the object names list should be sorted. This was never a requirement, the object names could appear in any order, but when reading the list we tracked whether the list was sorted for the purposes of an internal binary search implementation, which could save itself some work with an already sorted list. Unless you had a humongous list there was no reason to go out of your way to pre-sort the list. After Git version 2.20 a hash implementation is used instead, so there&amp;rsquo;s now no reason to pre-sort the list.</source>
          <target state="translated">이전 버전의 Git (2.20 이전)에서는 객체 이름 목록을 정렬해야한다고 설명했습니다. 이것은 요구 사항이 아니며 객체 이름이 어떤 순서로나 나타날 수 있지만 목록을 읽을 때 내부 이진 검색 구현을 위해 목록이 정렬되었는지 추적하여 이미 정렬 된 목록으로 일부 작업을 저장할 수 있습니다. 당신이 엄청난 목록을 가지고 있지 않은 한, 목록을 미리 정렬하는 길을 벗어날 이유가 없었습니다. Git 버전 2.20 이후에는 해시 구현이 대신 사용되므로 이제 목록을 사전 정렬 할 이유가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c51aaa3680fede028efcceee261b4919c277f552" translate="yes" xml:space="preserve">
          <source>Omit any commit that introduces the same change as another commit on the &amp;ldquo;other side&amp;rdquo; when the set of commits are limited with symmetric difference.</source>
          <target state="translated">일련의 커밋이 대칭 적 차이로 제한 될 때&amp;ldquo;다른 쪽&amp;rdquo;의 다른 커밋과 동일한 변경을 일으키는 커밋은 생략하십시오.</target>
        </trans-unit>
        <trans-unit id="e35d3ce0c9ea9ff6d661fcb1cbc8e08ffef97df6" translate="yes" xml:space="preserve">
          <source>Omit diff output for unmerged entries and just show &quot;Unmerged&quot;. Can be used only when comparing the working tree with the index.</source>
          <target state="translated">병합되지 않은 항목에 대해서는 diff 출력을 생략하고 &quot;Unmerged&quot;만 표시하십시오. 작업 트리를 인덱스와 비교할 때만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3138b0b10501de06a44e08d0de4b10a83646644b" translate="yes" xml:space="preserve">
          <source>Omit objects that are known to be in the promisor remote. (This option has the purpose of operating only on locally created objects, so that when we repack, we still maintain a distinction between locally created objects [without .promisor] and objects from the promisor remote [with .promisor].) This is used with partial clone.</source>
          <target state="translated">Promisor Remote에있는 것으로 알려진 개체는 생략하십시오. (이 옵션은 로컬로 생성 된 객체에서만 작동하는 목적을 가지고 있으므로 리 패킹 할 때 로컬로 생성 된 객체 (.promisor없이)와 Promisor Remote의 객체 (.promisor)로 구별을 유지합니다.) 부분 복제.</target>
        </trans-unit>
        <trans-unit id="fcfe3e3e988e33991f3ebb33b70ee9c58a79e5d0" translate="yes" xml:space="preserve">
          <source>Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and &lt;code&gt;/dev/null&lt;/code&gt;. The resulting patch is not meant to be applied with &lt;code&gt;patch&lt;/code&gt; or &lt;code&gt;git apply&lt;/code&gt;; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option.</source>
          <target state="translated">삭제를 위해 사전 이미지를 생략하십시오. 즉, 사전 이미지와 &lt;code&gt;/dev/null&lt;/code&gt; 사이의 diff는 제외하고 헤더 만 인쇄하십시오 . 결과 패치는 &lt;code&gt;patch&lt;/code&gt; 또는 &lt;code&gt;git apply&lt;/code&gt; 와 함께 적용되지 않습니다 . 이것은 변경 후 텍스트를 검토하는 데 집중하려는 사람들에게만 해당됩니다. 또한 출력에는 이러한 패치를 수동으로도 적용 할 수있는 충분한 정보가 없으므로 옵션 이름이 분명합니다.</target>
        </trans-unit>
        <trans-unit id="2c239b325c52048ed0e0df682e63161da794c522" translate="yes" xml:space="preserve">
          <source>Omitting &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; detaches &lt;code&gt;HEAD&lt;/code&gt; at the tip of the current branch.</source>
          <target state="translated">&lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 를 생략 하면 현재 분기의 끝에서 &lt;code&gt;HEAD&lt;/code&gt; 가 분리 됩니다.</target>
        </trans-unit>
        <trans-unit id="6f08ea1a85b441d7cdb4b9da4840e51d4a63074c" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;from&lt;/code&gt; command in the first commit of a new branch will cause fast-import to create that commit with no ancestor. This tends to be desired only for the initial commit of a project. If the frontend creates all files from scratch when making a new branch, a &lt;code&gt;merge&lt;/code&gt; command may be used instead of &lt;code&gt;from&lt;/code&gt; to start the commit with an empty tree. Omitting the &lt;code&gt;from&lt;/code&gt; command on existing branches is usually desired, as the current commit on that branch is automatically assumed to be the first ancestor of the new commit.</source>
          <target state="translated">새 브랜치를 처음 커밋 할 때 &lt;code&gt;from&lt;/code&gt; 명령을 생략하면 조상없이 해당 커밋을 빠르게 가져올 수 있습니다. 이것은 프로젝트의 초기 커밋에만 요구되는 경향이 있습니다. 새로운 지점을 만들 때 프론트 엔드 처음부터 모든 파일을 생성한다면, &lt;code&gt;merge&lt;/code&gt; 명령을 대신 사용할 수 있습니다 &lt;code&gt;from&lt;/code&gt; (가) 빈 트리 커밋 시작합니다. 해당 분기의 현재 커밋이 자동으로 새 커밋의 첫 번째 조상으로 간주되므로 기존 분기 &lt;code&gt;from&lt;/code&gt; 명령을 생략하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2e6ae0a1101e66bbdd1aff8c2583b81c23208b83" translate="yes" xml:space="preserve">
          <source>On Automatic following</source>
          <target state="translated">자동 팔로 잉</target>
        </trans-unit>
        <trans-unit id="82b4aa90bf6690a7ed8e3558248667b070567fb7" translate="yes" xml:space="preserve">
          <source>On Backdating Tags</source>
          <target state="translated">태그 업데이트 중</target>
        </trans-unit>
        <trans-unit id="52c1ff7f8dbe6e1f6639547a437fb78c51994ab9" translate="yes" xml:space="preserve">
          <source>On Re-tagging</source>
          <target state="translated">태그 추가시</target>
        </trans-unit>
        <trans-unit id="a3e5a575b7ca5dced5a48ec2289cb57e77edaa64" translate="yes" xml:space="preserve">
          <source>On an inefficient filesystem with &lt;code&gt;core.ignorestat&lt;/code&gt; set</source>
          <target state="translated">&lt;code&gt;core.ignorestat&lt;/code&gt; 가 설정된 비효율적 인 파일 시스템에서</target>
        </trans-unit>
        <trans-unit id="3fc5d80f58915bdd0c5c8219fc8fa34ba2d1e212" translate="yes" xml:space="preserve">
          <source>On any other error, the exit status may be any other non-zero value.</source>
          <target state="translated">다른 오류에서 종료 상태는 0이 아닌 다른 값일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccf984a0700972bcd62e51c87e569c1158e56007" translate="yes" xml:space="preserve">
          <source>On large repositories, Git depends on compression to keep the history information from taking up too much space on disk or in memory. Some Git commands may automatically run &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;, so you don&amp;rsquo;t have to worry about running it manually. However, compressing a large repository may take a while, so you may want to call &lt;code&gt;gc&lt;/code&gt; explicitly to avoid automatic compression kicking in when it is not convenient.</source>
          <target state="translated">큰 리포지토리에서 Git은 기록 정보가 디스크 나 메모리에서 너무 많은 공간을 차지하지 않도록 압축에 의존합니다. 일부 Git 명령은 자동으로 &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]을&lt;/a&gt; 실행할 수 있으므로 수동으로 실행할 필요가 없습니다. 그러나 큰 저장소를 압축하는 데 시간이 오래 걸릴 수 있으므로 편리하지 않을 때 자동 압축이 시작되지 않도록 &lt;code&gt;gc&lt;/code&gt; 를 명시 적으로 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4d8aed3bf55796608219c0adac254008695a3f9" translate="yes" xml:space="preserve">
          <source>On some file system/operating system combinations, this is unreliable. Set this config setting to &lt;code&gt;rename&lt;/code&gt; there; However, This will remove the check that makes sure that existing object files will not get overwritten.</source>
          <target state="translated">일부 파일 시스템 / 운영 체제 조합에서는 신뢰할 수 없습니다. 이 구성 설정을 &lt;code&gt;rename&lt;/code&gt; 하여 이름 을 바꿉니다 . 그러나 이렇게하면 기존 개체 파일을 덮어 쓰지 않는 확인이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="5895edccc183158d9e3740d2cebb6ada4fc33444" translate="yes" xml:space="preserve">
          <source>On submit, re-author changes to reflect the Git author, regardless of who invokes &lt;code&gt;git p4 submit&lt;/code&gt;.</source>
          <target state="translated">제출시 &lt;code&gt;git p4 submit&lt;/code&gt; 를 호출 한 사람에 관계없이 Git 작성자를 반영하도록 변경 사항을 다시 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="625dc8e72565a5aa6c893e4054fd5a7bd4cd4c77" translate="yes" xml:space="preserve">
          <source>On success, the command returns the exit code 0.</source>
          <target state="translated">성공하면 명령이 종료 코드 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="55bf26a2244670497728b53622880350724b3943" translate="yes" xml:space="preserve">
          <source>On success, the exit status is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">성공하면 종료 상태는 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="990e4d4ec388fa2b56426ae37da6b01c179599b8" translate="yes" xml:space="preserve">
          <source>On success, the exit status is &lt;code&gt;0&lt;/code&gt;. If the filter can&amp;rsquo;t find any commits to rewrite, the exit status is &lt;code&gt;2&lt;/code&gt;. On any other error, the exit status may be any other non-zero value.</source>
          <target state="translated">성공하면 종료 상태는 &lt;code&gt;0&lt;/code&gt; 입니다. 필터가 다시 쓰기 커밋을 찾을 수 없으면 종료 상태는 &lt;code&gt;2&lt;/code&gt; 입니다. 다른 오류에서 종료 상태는 0이 아닌 다른 값일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b26f7834b511fe2fcda898a4f6a6ea24bf02deb" translate="yes" xml:space="preserve">
          <source>On the filesystem, a submodule usually (but not always - see FORMS below) consists of (i) a Git directory located under the &lt;code&gt;$GIT_DIR/modules/&lt;/code&gt; directory of its superproject, (ii) a working directory inside the superproject&amp;rsquo;s working directory, and a &lt;code&gt;.git&lt;/code&gt; file at the root of the submodule&amp;rsquo;s working directory pointing to (i).</source>
          <target state="translated">파일 시스템에서 하위 모듈은 일반적으로 (항상 그런 것은 아니지만 아래의 FORMS 참조) (i) 수퍼 프로젝트 의 &lt;code&gt;$GIT_DIR/modules/&lt;/code&gt; 디렉토리 아래에있는 Git 디렉토리 , (ii) 수퍼 프로젝트의 작업 디렉토리 내부의 작업 디렉토리 및 (i)를 가리키는 서브 모듈 작업 디렉토리의 루트에 있는 &lt;code&gt;.git&lt;/code&gt; 파일</target>
        </trans-unit>
        <trans-unit id="4db9025909f7f5bf5e13acbeaf805aa54cd01729" translate="yes" xml:space="preserve">
          <source>On the other hand if you do this often, then it can be worth having scripts to avoid too much typing.</source>
          <target state="translated">반면에 자주이 작업을 수행하면 너무 많은 입력을 피하기 위해 스크립트를 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="683649c177c2041eda8a2d9bcca87e40a04a531c" translate="yes" xml:space="preserve">
          <source>On the other hand, if instead of merging at C you had rebased the history between Z to B on top of A, you would have gotten this linear history:</source>
          <target state="translated">반면에 C에서 병합하는 대신 A의 상단에서 Z 사이의 기록을 다시 기반으로 한 경우 다음 선형 기록을 얻었을 것입니다.</target>
        </trans-unit>
        <trans-unit id="0322f18dd0193743bffa03c418d12c6fe0b24261" translate="yes" xml:space="preserve">
          <source>On the other hand, if you are fetching because you would want a one-shot merge from somebody else, you typically do not want to get tags from there. This happens more often for people near the toplevel but not limited to them. Mere mortals when pulling from each other do not necessarily want to automatically get private anchor point tags from the other person.</source>
          <target state="translated">반면에 다른 사람으로부터 원샷 병합을 원하기 때문에 가져 오는 경우 일반적으로 거기에서 태그를 가져오고 싶지 않습니다. 이것은 최상위에 가까운 사람들에게 더 자주 발생하지만 그들에 국한되지는 않습니다. 서로를 끌어낼 때 단순한 필사자가 반드시 다른 사람으로부터 개인 앵커 포인트 태그를 자동으로 얻고 싶지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff26b6c1b15a595913b474bb862db9261a722064" translate="yes" xml:space="preserve">
          <source>On the other hand, when &lt;code&gt;git gc&lt;/code&gt; runs concurrently with another process, there is a risk of it deleting an object that the other process is using but hasn&amp;rsquo;t created a reference to. This may just cause the other process to fail or may corrupt the repository if the other process later adds a reference to the deleted object. Git has two features that significantly mitigate this problem:</source>
          <target state="translated">반면에 &lt;code&gt;git gc&lt;/code&gt; 가 다른 프로세스와 동시에 실행될 때 다른 프로세스가 사용하고 있지만 참조를 만들지 않은 객체를 삭제할 위험이 있습니다. 다른 프로세스가 나중에 삭제 된 개체에 대한 참조를 추가하면 다른 프로세스가 실패하거나 리포지토리가 손상 될 수 있습니다. Git에는이 문제를 크게 완화시키는 두 가지 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cc6a0108c9ca30d35fc16f0e158699698e2687d" translate="yes" xml:space="preserve">
          <source>On the plus side, distributed revision control systems can much better integrate with external sources. In a centralized model, a single arbitrary snapshot of the external project is exported from its own revision control and then imported into the local revision control on a vendor branch. All the history is hidden. With distributed revision control you can clone the entire external history and much more easily follow development and re-merge local changes.</source>
          <target state="translated">또한, 분산 개정 제어 시스템은 외부 소스와 훨씬 잘 통합 될 수 있습니다. 중앙 집중식 모델에서 외부 프로젝트의 임의의 단일 스냅 샷은 자체 개정 제어에서 내 보낸 다음 공급 업체 지점의 로컬 개정 제어로 가져옵니다. 모든 역사는 숨겨져 있습니다. 분산 개정 제어를 사용하면 전체 외부 히스토리를 복제하고 개발을 훨씬 쉽게 따르고 로컬 변경 사항을 다시 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90597c320571938c2a30a9ec587f181632e3da9c" translate="yes" xml:space="preserve">
          <source>On the receiving side, failing fsckObjects will make those objects unreachable, see &quot;QUARANTINE ENVIRONMENT&quot; in &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt;. On the fetch side, malformed objects will instead be left unreferenced in the repository.</source>
          <target state="translated">수신 측에서 fsckObjects가 실패하면 해당 오브젝트에 도달 할 수 없게됩니다. &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]의&lt;/a&gt; &quot;QUARANTINE ENVIRONMENT&quot;를 참조하십시오 . 반입 측에서는 잘못된 형식의 객체가 리포지토리에서 참조되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0cb32cbc06583a961d1463cba3f54ceac091ac9b" translate="yes" xml:space="preserve">
          <source>Once a patch completes the great cycle (moving from test to release, then pulled by Linus, and finally coming back into your local &lt;code&gt;origin/master&lt;/code&gt; branch), the branch for this change is no longer needed. You detect this when the output from:</source>
          <target state="translated">패치가 큰주기를 완료하면 (테스트에서 릴리스로 이동 한 다음 Linus가 가져 와서 최종적으로 로컬 &lt;code&gt;origin/master&lt;/code&gt; 브랜치로 돌아옴)이 변경에 대한 브랜치는 더 이상 필요하지 않습니다. 다음에서 출력 할 때이를 감지합니다.</target>
        </trans-unit>
        <trans-unit id="b9ebb68ceda33b5f55394a76815abe93f554d5a0" translate="yes" xml:space="preserve">
          <source>Once again, check to verify that you&amp;rsquo;ve included what you want to. You may also wish to verify that git diff doesn&amp;rsquo;t show any remaining changes to be committed later.</source>
          <target state="translated">다시 한 번, 원하는 것을 포함했는지 확인하십시오. git diff가 나중에 커밋 할 나머지 변경 사항을 표시하지 않는지 확인할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="90e05562a65001025b0b72d96c6a4e4b947387b5" translate="yes" xml:space="preserve">
          <source>Once housekeeping is triggered by exceeding the limits of configuration options such as &lt;code&gt;gc.auto&lt;/code&gt; and &lt;code&gt;gc.autoPackLimit&lt;/code&gt;, all other housekeeping tasks (e.g. rerere, working trees, reflog&amp;hellip;​) will be performed as well.</source>
          <target state="translated">&lt;code&gt;gc.auto&lt;/code&gt; 및 &lt;code&gt;gc.autoPackLimit&lt;/code&gt; 와 같은 구성 옵션의 한계를 초과하여 하우스 키핑이 시작되면 다른 모든 하우스 키핑 작업 (예 : rerere, working tree, reflog&amp;hellip;)도 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e4fac50f608beca9583acae6e66b5b839bc7af82" translate="yes" xml:space="preserve">
          <source>Once satisfied with the hunks you want to include, you should verify what has been prepared for the first commit by using &lt;code&gt;git diff --cached&lt;/code&gt;. This shows all the changes that have been moved into the index and are about to be committed.</source>
          <target state="translated">포함하려는 덩어리에 만족하면 &lt;code&gt;git diff --cached&lt;/code&gt; 를 사용하여 첫 번째 커밋을 위해 준비된 내용을 확인해야합니다 . 인덱스로 이동되어 커밋 될 모든 변경 사항이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3dd9fb6970c316fd22de16c64bf93a0699f63f8d" translate="yes" xml:space="preserve">
          <source>Once the commits are ready to be sent, run the following command:</source>
          <target state="translated">커밋을 전송할 준비가되면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="40868be271f12676d4171e28016f98d26c82d485" translate="yes" xml:space="preserve">
          <source>Once the index has been created, the hash that goes into the name of the pack/idx file is printed to stdout. If --stdin was also used then this is prefixed by either &quot;pack\t&quot;, or &quot;keep\t&quot; if a new .keep file was successfully created. This is useful to remove a .keep file used as a lock to prevent the race with &lt;code&gt;git repack&lt;/code&gt; mentioned above.</source>
          <target state="translated">색인이 생성되면 pack / idx 파일의 이름에 들어가는 해시가 stdout에 인쇄됩니다. --stdin도 사용 된 경우 &quot;pack \ t&quot;또는 새 .keep 파일이 성공적으로 생성 된 경우 &quot;keep \ t&quot;가 앞에 붙습니다. 이것은 위에서 언급 한 &lt;code&gt;git repack&lt;/code&gt; 으로 레이스를 방지하기 위해 잠금으로 사용되는 .keep 파일을 제거하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="bc0e79bf062114aed97a847d2dbf78bde74bcedc" translate="yes" xml:space="preserve">
          <source>Once the index has been created, the list of object names is sorted and the SHA-1 hash of that list is printed to stdout. If --stdin was also used then this is prefixed by either &quot;pack\t&quot;, or &quot;keep\t&quot; if a new .keep file was successfully created. This is useful to remove a .keep file used as a lock to prevent the race with &lt;code&gt;git repack&lt;/code&gt; mentioned above.</source>
          <target state="translated">색인이 작성되면 오브젝트 이름 목록이 정렬되고 해당 목록의 SHA-1 해시가 stdout에 인쇄됩니다. --stdin도 사용 된 경우 새 .keep 파일이 성공적으로 작성된 경우 접두어는 &quot;pack \ t&quot;또는 &quot;keep \ t&quot;입니다. 이것은 위에서 언급 한 &lt;code&gt;git repack&lt;/code&gt; 과의 경쟁을 막기 위해 잠금 장치로 사용되는 .keep 파일을 제거하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="267c8839170c35911e5505454167dce43ef8461e" translate="yes" xml:space="preserve">
          <source>Once the index is updated with the results of the conflict resolution, instead of creating a new commit, just run</source>
          <target state="translated">충돌을 해결 한 결과로 인덱스가 업데이트되면 새로운 커밋을 생성하는 대신 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="dce83a819a58902526be63ab88beb478ade1a830" translate="yes" xml:space="preserve">
          <source>Once tracking a Subversion repository (with any of the above methods), the Git repository can be updated from Subversion by the &lt;code&gt;fetch&lt;/code&gt; command and Subversion updated from Git by the &lt;code&gt;dcommit&lt;/code&gt; command.</source>
          <target state="translated">Subversion 저장소 (위의 방법 중 하나를 사용하여)를 추적하면 &lt;code&gt;fetch&lt;/code&gt; 명령으로 Git 저장소를 Subversion에서 업데이트하고 &lt;code&gt;dcommit&lt;/code&gt; 명령으로 Git 에서 Subversion을 업데이트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7c323cf6aca82334469eb4ac31bb75f493bfcb2" translate="yes" xml:space="preserve">
          <source>Once you fetch from the remote repository, you &lt;code&gt;merge&lt;/code&gt; that with your current branch.</source>
          <target state="translated">원격 저장소에서 가져 오면이를 현재 브랜치와 &lt;code&gt;merge&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="196d7a30344d61fce15a29277d1febbefab63366" translate="yes" xml:space="preserve">
          <source>Once you have packed objects, you do not need to leave the unpacked objects that are contained in the pack file anymore.</source>
          <target state="translated">팩형 오브젝트를 포장 한 후에는 팩 파일에 포함 된 언 팩형 오브젝트를 더 이상 그대로 둘 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="19419c3fb2ffef21b9b034f5ca5d579751e9cffb" translate="yes" xml:space="preserve">
          <source>Once you have specified at least one bad and one good commit, &lt;code&gt;git
bisect&lt;/code&gt; selects a commit in the middle of that range of history, checks it out, and outputs something similar to the following:</source>
          <target state="translated">하나 이상의 잘못된 커밋과 하나의 좋은 커밋을 지정하면 &lt;code&gt;git bisect&lt;/code&gt; 는 해당 히스토리 범위의 중간에서 커밋을 선택하고 체크 아웃하고 다음과 유사한 것을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="a222e7e00ea22df97bc019f6fbda7d4a739d08f0" translate="yes" xml:space="preserve">
          <source>Once you know the three trees you are going to merge (the one &quot;original&quot; tree, aka the common tree, and the two &quot;result&quot; trees, aka the branches you want to merge), you do a &quot;merge&quot; read into the index. This will complain if it has to throw away your old index contents, so you should make sure that you&amp;rsquo;ve committed those&amp;mdash;​in fact you would normally always do a merge against your last commit (which should thus match what you have in your current index anyway).</source>
          <target state="translated">병합 할 3 개의 나무 (하나의 &quot;원래&quot;나무, 일명 공통 트리 및 2 개의 &quot;결과&quot;나무, 병합하려는 가지)를 알고 나면 &quot;병합&quot;을 읽습니다. 인덱스. 이렇게하면 오래된 인덱스 내용을 버려야 할 경우 불만을 제기 할 수 있으므로 커밋했는지 확인해야합니다. 사실 일반적으로 항상 마지막 커밋에 대해 병합을 수행해야합니다. 어쨌든 현재 색인).</target>
        </trans-unit>
        <trans-unit id="2f6bdbc854c9f4a06850e81f40a40893a853f873" translate="yes" xml:space="preserve">
          <source>Once your commits are ready to be sent to the mailing list, run the following commands:</source>
          <target state="translated">커밋을 메일 링리스트로 보낼 준비가되면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="1e3411b288c5ece442ec5affcc9ccff7867288ff" translate="yes" xml:space="preserve">
          <source>One can also modify context lines by staging them for removal (by converting &quot; &quot; to &quot;-&quot;) and adding a &quot;+&quot; line with the new content. Similarly, one can modify &quot;+&quot; lines for existing additions or modifications. In all cases, the new modification will appear reverted in the working tree.</source>
          <target state="translated">또한 &quot;&quot;를 &quot;-&quot;로 변환하여 제거 할 컨텍스트 줄을 준비하고 새 내용에 &quot;+&quot;줄을 추가하여 컨텍스트 줄을 수정할 수도 있습니다. 마찬가지로 기존 추가 또는 수정을 위해 &quot;+&quot;줄을 수정할 수 있습니다. 모든 경우에 새 수정 사항이 작업 트리에서 되돌려 나타납니다.</target>
        </trans-unit>
        <trans-unit id="cefda8701820e17ff3e5c1f9d74674c9ba3ca4b0" translate="yes" xml:space="preserve">
          <source>One feature worth pointing out is the three-way merge, which can help if you get conflicts: &lt;code&gt;git am -3&lt;/code&gt; will use index information contained in patches to figure out the merge base. See &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; for other options.</source>
          <target state="translated">지적해야 할 기능 중 하나는 3 방향 병합인데, 충돌이 발생할 경우 도움이됩니다. &lt;code&gt;git am -3&lt;/code&gt; 은 패치에 포함 된 색인 정보를 사용하여 병합 기반을 파악합니다. 다른 옵션 은 &lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="91b115a828fd51fba09fc11d7213ae15c1c47544" translate="yes" xml:space="preserve">
          <source>One important aspect of Git is its distributed nature, which largely means there is no inherent &quot;upstream&quot; or &quot;downstream&quot; in the system. On the face of it, the above example might seem to indicate that the tag namespace is owned by the upper echelon of people and that tags only flow downwards, but that is not the case. It only shows that the usage pattern determines who are interested in whose tags.</source>
          <target state="translated">Git의 중요한 특징 중 하나는 분산 특성으로, 시스템에 고유 한 &quot;업스트림&quot;또는 &quot;다운 스트림&quot;이 없음을 의미합니다. 위의 예에서, 태그 네임 스페이스는 사람들의 상위 계층이 소유하고 태그는 아래쪽으로 만 흐르지 만 그렇지는 않다는 것을 나타낼 수 있습니다. 사용 패턴에 따라 태그에 관심이있는 사람이 결정된다는 것만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="04ced8b13491984476dfed877ea62bd96c9df7a6" translate="yes" xml:space="preserve">
          <source>One major difference between &lt;code&gt;git submodule update&lt;/code&gt; and &lt;code&gt;git submodule add&lt;/code&gt; is that &lt;code&gt;git submodule update&lt;/code&gt; checks out a specific commit, rather than the tip of a branch. It&amp;rsquo;s like checking out a tag: the head is detached, so you&amp;rsquo;re not working on a branch.</source>
          <target state="translated">커다란 차이 중 하나 &lt;code&gt;git submodule update&lt;/code&gt; 와 &lt;code&gt;git submodule add&lt;/code&gt; 있다는 것입니다 &lt;code&gt;git submodule update&lt;/code&gt; 특정 밖으로 검사 오히려 나뭇 가지의 끝보다 커밋합니다. 태그를 확인하는 것과 같습니다. 헤드가 분리되어 분기에서 작업하고 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d6438f7bb62b577ed24501432d3010343f7c06f" translate="yes" xml:space="preserve">
          <source>One nice about &quot;git bisect&quot; is that it is not only a developer tool. It can effectively be used by QA people or even end users (if they have access to the source code or if they can get access to all the builds).</source>
          <target state="translated">&quot;git bisect&quot;의 장점 중 하나는 개발자 도구가 아니라는 것입니다. QA 직원이나 최종 사용자가 소스 코드에 액세스 할 수 있거나 모든 빌드에 액세스 할 수있는 경우 효과적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="142f19dfe765b1c5ce574050578fa3bc8f7c4c07" translate="yes" xml:space="preserve">
          <source>One note: the special &lt;code&gt;master&lt;/code&gt; head is the default branch, which is why the &lt;code&gt;.git/HEAD&lt;/code&gt; file was created points to it even if it doesn&amp;rsquo;t yet exist. Basically, the &lt;code&gt;HEAD&lt;/code&gt; link is supposed to always point to the branch you are working on right now, and you always start out expecting to work on the &lt;code&gt;master&lt;/code&gt; branch.</source>
          <target state="translated">한 가지 참고 사항 : 특수 &lt;code&gt;master&lt;/code&gt; 헤드가 기본 분기이므로 &lt;code&gt;.git/HEAD&lt;/code&gt; 파일이 아직 생성되지 않은 경우에도 .git / HEAD 파일이 만들어졌습니다. 기본적으로 &lt;code&gt;HEAD&lt;/code&gt; 링크는 항상 현재 작업중인 지점을 가리키고 있으며 항상 &lt;code&gt;master&lt;/code&gt; 지점 에서 작업하기를 기대합니다 .</target>
        </trans-unit>
        <trans-unit id="29a0c8f350324f991b248dd3aa593e11f5862130" translate="yes" xml:space="preserve">
          <source>One obvious improvement to this algorithm would be to look for a commit that has an associated value near the one of the best bisection commit, and that is on another branch, before using the PRNG. Because if such a commit exists, then it is not very likely to be untestable too, so it will probably give more information than a nearly randomly chosen one.</source>
          <target state="translated">이 알고리즘의 명백한 개선점 중 하나는 PRNG를 사용하기 전에 가장 좋은 2 분할 커밋 중 하나에 관련 값이 있고 다른 분기에있는 커밋을 찾는 것입니다. 그러한 커밋이 존재하면 테스트 할 수 없을 가능성이 높기 때문에 거의 임의로 선택된 것보다 더 많은 정보를 제공 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="e1159b72c8727d654a00df87bb5a62e68448d486" translate="yes" xml:space="preserve">
          <source>One of the following transports can be used to name the repository to download from:</source>
          <target state="translated">다음 전송 중 하나를 사용하여 다운로드 할 저장소의 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2e9320213d36179f9f718d529b707eca70ac72d" translate="yes" xml:space="preserve">
          <source>One of the ideas of having a branch is that you do some (possibly experimental) work in it, and eventually merge it back to the main branch. So assuming you created the above &lt;code&gt;mybranch&lt;/code&gt; that started out being the same as the original &lt;code&gt;master&lt;/code&gt; branch, let&amp;rsquo;s make sure we&amp;rsquo;re in that branch, and do some work there.</source>
          <target state="translated">브랜치를 갖는 아이디어 중 하나는 (아마도 실험적인) 작업을 수행하고 결국 메인 브랜치로 다시 병합한다는 것입니다. 원래 &lt;code&gt;master&lt;/code&gt; 브랜치 와 동일한 것으로 시작 하는 위의 &lt;code&gt;mybranch&lt;/code&gt; 를 만들었다 고 가정하면 해당 브랜치에 있는지 확인하고 거기서 작업하십시오.</target>
        </trans-unit>
        <trans-unit id="07b5c446feb269c31391e3ec2cd0376191f84e84" translate="yes" xml:space="preserve">
          <source>One of the identifiers &quot;&lt;a href=&quot;#def_commit_object&quot;&gt;commit&lt;/a&gt;&quot;, &quot;&lt;a href=&quot;#def_tree_object&quot;&gt;tree&lt;/a&gt;&quot;, &quot;&lt;a href=&quot;#def_tag_object&quot;&gt;tag&lt;/a&gt;&quot; or &quot;&lt;a href=&quot;#def_blob_object&quot;&gt;blob&lt;/a&gt;&quot; describing the type of an &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_object&quot;&gt;개체&lt;/a&gt; 유형을 나타내는 식별자 &quot; &lt;a href=&quot;#def_commit_object&quot;&gt;commit&lt;/a&gt; &quot;, &quot; &lt;a href=&quot;#def_tree_object&quot;&gt;tree&lt;/a&gt; &quot;, &quot; &lt;a href=&quot;#def_tag_object&quot;&gt;tag&lt;/a&gt; &quot;또는 &quot; &lt;a href=&quot;#def_blob_object&quot;&gt;blob&lt;/a&gt; &quot;중 하나 입니다.</target>
        </trans-unit>
        <trans-unit id="4cfd499f1faa2bf47281b08252a27709dbf65c31" translate="yes" xml:space="preserve">
          <source>One or more of the options below may be used to determine the files shown:</source>
          <target state="translated">아래의 옵션 중 하나 이상을 사용하여 표시된 파일을 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fdc57e5472e4e105b70357796e6b6c7c9687799" translate="yes" xml:space="preserve">
          <source>One or more of the provided paths is ignored.</source>
          <target state="translated">제공된 경로 중 하나 이상이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="fa8d672b6bbfcb201a67403df350a9a5a712d006" translate="yes" xml:space="preserve">
          <source>One phase in branch detection involves looking at p4 branches to find new ones to import. By default, all branches are inspected. This option limits the search to just those owned by the single user named in the variable.</source>
          <target state="translated">분기 감지의 한 단계는 p4 분기를보고 가져올 새 분기를 찾는 것입니다. 기본적으로 모든 분기가 검사됩니다. 이 옵션은 변수에 이름이 지정된 단일 사용자가 소유 한 것으로 만 검색을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="11468bd4c23009003db390c522332f7c3d2a8eae" translate="yes" xml:space="preserve">
          <source>One problem with &quot;git replace&quot; is that currently it stores all the replacements refs in &quot;refs/replace/&quot;, but it would be perhaps better if the replacement refs that are useful only for bisecting would be in &quot;refs/replace/bisect/&quot;. This way the replacement refs could be used only for bisecting, while other refs directly in &quot;refs/replace/&quot; would be used nearly all the time.</source>
          <target state="translated">&quot;git replace&quot;의 한 가지 문제점은 현재 모든 대체 참조를 &quot;refs / replace /&quot;에 저장하지만 bisecting에만 유용한 교체 참조가 &quot;refs / replace / bisect / &quot;. 이 방법으로 교체 심판은 이등분에만 사용될 수 있지만 &quot;refs / replace /&quot;에 직접있는 다른 심판은 거의 항상 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d1e2a86cedb580a377c28acdbf81410bf88bf79b" translate="yes" xml:space="preserve">
          <source>One record (for project / repository) per line; does not support line continuation (newline escaping).</source>
          <target state="translated">라인 당 하나의 레코드 (프로젝트 / 저장소); 줄 연속 (줄 바꿈 이스케이프)을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e018f50410d5f4a4feb43d8b0ec18d17af4444c" translate="yes" xml:space="preserve">
          <source>One such software is the Linux kernel. And if we look at the Linux kernel, we can see that a lot of time and effort is spent to fight regressions. The release cycle start with a 2 weeks long merge window. Then the first release candidate (rc) version is tagged. And after that about 7 or 8 more rc versions will appear with around one week between each of them, before the final release.</source>
          <target state="translated">그러한 소프트웨어 중 하나는 Linux 커널입니다. 그리고 리눅스 커널을 살펴보면 회귀와 싸우는 데 많은 시간과 노력이 소비되고 있음을 알 수 있습니다. 릴리스주기는 2 주 길이의 병합 창으로 시작됩니다. 그런 다음 첫 번째 릴리스 후보 (rc) 버전이 태그됩니다. 그리고 그 이후에는 최종 릴리스 이전에 약 7 주에서 8 주 정도 더 많은 rc 버전이 각각 1 주일 정도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bdac2081c61d66c365f2d2f97739c2e3f666a74e" translate="yes" xml:space="preserve">
          <source>One usage scenario is to run unit tests in the hook.</source>
          <target state="translated">하나의 사용 시나리오는 후크에서 단위 테스트를 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f9e9013eccf2a70e5a5f30b1ea62b3495fc5c835" translate="yes" xml:space="preserve">
          <source>One use of the content filtering is to massage the content into a shape that is more convenient for the platform, filesystem, and the user to use. For this mode of operation, the key phrase here is &quot;more convenient&quot; and not &quot;turning something unusable into usable&quot;. In other words, the intent is that if someone unsets the filter driver definition, or does not have the appropriate filter program, the project should still be usable.</source>
          <target state="translated">컨텐츠 필터링의 한 가지 용도는 컨텐츠를 플랫폼, 파일 시스템 및 사용자가 사용하기에 더 편리한 형태로 마사지하는 것입니다. 이 작동 모드에서 여기서 핵심 문구는 &quot;더 편리&quot;하며 &quot;사용할 수없는 것을 사용할 수 없게 만드는&quot;것이 아닙니다. 다시 말해, 누군가 필터 드라이버 정의를 설정 해제하거나 적절한 필터 프로그램이없는 경우에도 프로젝트를 계속 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="bf346c4d1c8b72f5f128424640398ae0ca4f5b99" translate="yes" xml:space="preserve">
          <source>One way to test if your MUA is set up correctly is:</source>
          <target state="translated">MUA가 올바르게 설정되었는지 테스트하는 한 가지 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2d149b07bfc5760abe904c522d47cdc6ed806f7c" translate="yes" xml:space="preserve">
          <source>Only allow &lt;code&gt;--filter=tree:&amp;lt;n&amp;gt;&lt;/code&gt; when &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; is no more than the value of &lt;code&gt;uploadpackfilter.tree.maxDepth&lt;/code&gt;. If set, this also implies &lt;code&gt;uploadpackfilter.tree.allow=true&lt;/code&gt;, unless this configuration variable had already been set. Has no effect if unset.</source>
          <target state="translated">&lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; 이 &lt;code&gt;uploadpackfilter.tree.maxDepth&lt;/code&gt; 의 값보다 크지 않은 경우 &lt;code&gt;--filter=tree:&amp;lt;n&amp;gt;&lt;/code&gt; 만 허용 하십시오 . 설정된 경우,이 구성 변수가 이미 설정되지 않은 경우 &lt;code&gt;uploadpackfilter.tree.allow=true&lt;/code&gt; 를 의미 합니다. 설정하지 않으면 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b7da7d48889d5c708679796bf76623241882d879" translate="yes" xml:space="preserve">
          <source>Only allow viewing of repositories also shown on the overview page. This for example makes &lt;code&gt;$export_ok&lt;/code&gt; file decide if repository is available and not only if it is shown. If &lt;code&gt;$projects_list&lt;/code&gt; points to file with list of project, only those repositories listed would be available for gitweb. Can be set during building gitweb via &lt;code&gt;GITWEB_STRICT_EXPORT&lt;/code&gt;. By default this variable is not set, which means that you can directly access those repositories that are hidden from projects list page (e.g. the are not listed in the $projects_list file).</source>
          <target state="translated">개요 페이지에도 표시된 리포지토리 만 볼 수 있습니다. 예를 들어 &lt;code&gt;$export_ok&lt;/code&gt; 파일은 리포지토리가 사용 가능한지 여부를 결정합니다. &lt;code&gt;$projects_list&lt;/code&gt; 가 프로젝트 목록이있는 파일을 가리키는 경우 , 나열된 리포지토리 만 gitweb에 사용할 수 있습니다. &lt;code&gt;GITWEB_STRICT_EXPORT&lt;/code&gt; 를 통해 gitweb을 빌드하는 동안 설정할 수 있습니다 . 기본적으로이 변수는 설정되어 있지 않습니다. 즉, 프로젝트 목록 페이지에서 숨겨진 저장소 (예 : $ projects_list 파일에 나열되지 않은 저장소)에 직접 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9db6957ecdccb26c443588b379fe63817da234e" translate="yes" xml:space="preserve">
          <source>Only anonymous access is provided by pserve by default. To commit you will have to create pserver accounts, simply add a gitcvs.authdb setting in the config file of the repositories you want the cvsserver to allow writes to, for example:</source>
          <target state="translated">pserve는 기본적으로 익명 액세스 만 제공합니다. 커밋하려면 pserver 계정을 만들어야하는데, cvsserver가 쓰기를 허용 할 리포지토리의 구성 파일에 gitcvs.authdb 설정을 추가하면됩니다.</target>
        </trans-unit>
        <trans-unit id="f8de1f9ddde9f99ee756c31ae048d708dda7832c" translate="yes" xml:space="preserve">
          <source>Only bind the web server to the local IP (127.0.0.1).</source>
          <target state="translated">웹 서버를 로컬 IP (127.0.0.1)에만 바인딩하십시오.</target>
        </trans-unit>
        <trans-unit id="914060d4007bba68d0e5b57a08eb8520cbc0281b" translate="yes" xml:space="preserve">
          <source>Only consider tags matching the given &lt;code&gt;glob(7)&lt;/code&gt; pattern, excluding the &quot;refs/tags/&quot; prefix. If used with &lt;code&gt;--all&lt;/code&gt;, it also considers local branches and remote-tracking references matching the pattern, excluding respectively &quot;refs/heads/&quot; and &quot;refs/remotes/&quot; prefix; references of other types are never considered. If given multiple times, a list of patterns will be accumulated, and tags matching any of the patterns will be considered. Use &lt;code&gt;--no-match&lt;/code&gt; to clear and reset the list of patterns.</source>
          <target state="translated">&quot;refs / tags /&quot;접두사를 제외 하고 주어진 &lt;code&gt;glob(7)&lt;/code&gt; 패턴과 일치하는 태그 만 고려하십시오 . &lt;code&gt;--all&lt;/code&gt; 과 함께 사용하는 경우 각각 &quot;refs / heads /&quot;및 &quot;refs / remotes /&quot;접두사를 제외하고 패턴과 일치하는 로컬 분기 및 원격 추적 참조도 고려합니다. 다른 유형의 참조는 고려되지 않습니다. 여러 번 주어진 경우 패턴 목록이 누적되고 패턴과 일치하는 태그가 고려됩니다. 패턴 목록을 지우고 재설정 하려면 &lt;code&gt;--no-match&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="941066ff4f5ea2a1056ac361a36573c125ff04f2" translate="yes" xml:space="preserve">
          <source>Only create a packed archive if it would contain at least one object.</source>
          <target state="translated">압축 된 아카이브에 하나 이상의 오브젝트가 포함 된 경우에만 압축 아카이브를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="83ca14f8cd2c9566aaa74ad9a438e0a15bc783b9" translate="yes" xml:space="preserve">
          <source>Only expire loose objects older than &amp;lt;time&amp;gt;.</source>
          <target state="translated">&amp;lt;time&amp;gt;보다 오래된 느슨한 객체 만 만료합니다.</target>
        </trans-unit>
        <trans-unit id="d50becec82fb156672fd24c1ecb55cefe6d9b0c0" translate="yes" xml:space="preserve">
          <source>Only list branches of the given object.</source>
          <target state="translated">주어진 객체의 가지만 나열합니다.</target>
        </trans-unit>
        <trans-unit id="ae8314faed018be3007d334a54cd4f7b3bde067a" translate="yes" xml:space="preserve">
          <source>Only list branches which contain the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">지정된 커밋이 포함 된 분기 만 나열합니다 (지정하지 않은 경우 HEAD). &lt;code&gt;--list&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="b39fcb7ccfd206d2a11b5cac77f876ebbcdc59a6" translate="yes" xml:space="preserve">
          <source>Only list branches which don&amp;rsquo;t contain the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">지정된 커밋을 포함하지 않는 분기 만 나열합니다 (지정하지 않은 경우 HEAD). &lt;code&gt;--list&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="5d91bc93b24e96b92cd74b3016507c8892f02d8e" translate="yes" xml:space="preserve">
          <source>Only list branches whose tips are not reachable from the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;, incompatible with &lt;code&gt;--merged&lt;/code&gt;.</source>
          <target state="translated">지정된 커밋에서 팁에 도달 할 수없는 분기 만 나열합니다 (지정하지 않은 경우 HEAD). &lt;code&gt;--merged&lt;/code&gt; 와 호환되지 않는 &lt;code&gt;--list&lt;/code&gt; 를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="7f18c194fbea0e6a25127dd2c0242348888bebb8" translate="yes" xml:space="preserve">
          <source>Only list branches whose tips are not reachable from the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">지정된 커밋에서 팁에 도달 할 수없는 분기 만 나열합니다 (지정되지 않은 경우 HEAD). &lt;code&gt;--list&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="368e1f5311ab357c6579dd2598d3554e5f69ab7b" translate="yes" xml:space="preserve">
          <source>Only list branches whose tips are reachable from the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;, incompatible with &lt;code&gt;--no-merged&lt;/code&gt;.</source>
          <target state="translated">지정된 커밋에서 팁에 도달 할 수있는 분기 만 나열합니다 (지정하지 않은 경우 HEAD). &lt;code&gt;--no-merged&lt;/code&gt; 와 호환되지 않는 &lt;code&gt;--list&lt;/code&gt; 를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="8e8c13c3ac0a7b1c9d8836463a5f79c31b1444a5" translate="yes" xml:space="preserve">
          <source>Only list branches whose tips are reachable from the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">지정된 커밋에서 팁에 도달 할 수있는 분기 만 나열합니다 (지정되지 않은 경우 HEAD). &lt;code&gt;--list&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="dc004fe98c7c853edcd721c4a4743bbe17dc0ceb" translate="yes" xml:space="preserve">
          <source>Only list refs which contain the specified commit (HEAD if not specified).</source>
          <target state="translated">지정된 커밋을 포함하는 참조 만 나열합니다 (지정하지 않은 경우 HEAD).</target>
        </trans-unit>
        <trans-unit id="53301ab6d13e8c23069a84dba2acf3daf5a67784" translate="yes" xml:space="preserve">
          <source>Only list refs which don&amp;rsquo;t contain the specified commit (HEAD if not specified).</source>
          <target state="translated">지정된 커밋을 포함하지 않는 참조 만 나열합니다 (지정하지 않은 경우 HEAD).</target>
        </trans-unit>
        <trans-unit id="13917fddfb76486aac0b6b32382a8222d7ef7129" translate="yes" xml:space="preserve">
          <source>Only list refs which points at the given object.</source>
          <target state="translated">주어진 객체를 가리키는 참조 만 나열합니다.</target>
        </trans-unit>
        <trans-unit id="d63446ed3ed439dd64fa48118858d7dc8f885568" translate="yes" xml:space="preserve">
          <source>Only list refs whose tips are not reachable from the specified commit (HEAD if not specified), incompatible with &lt;code&gt;--merged&lt;/code&gt;.</source>
          <target state="translated">지정된 커밋 (팁이 지정되지 않은 경우 HEAD)에서 팁에 도달 할 수없고 &lt;code&gt;--merged&lt;/code&gt; 와 호환되지 않는 참조 만 나열하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3045719971c55f87c34a7fd746215fdcca5bdb6" translate="yes" xml:space="preserve">
          <source>Only list refs whose tips are not reachable from the specified commit (HEAD if not specified).</source>
          <target state="translated">지정된 커밋에서 팁에 도달 할 수없는 참조 만 나열합니다 (지정되지 않은 경우 HEAD).</target>
        </trans-unit>
        <trans-unit id="b4d24af2a09941026de883e7412997a62ab6d500" translate="yes" xml:space="preserve">
          <source>Only list refs whose tips are reachable from the specified commit (HEAD if not specified), incompatible with &lt;code&gt;--no-merged&lt;/code&gt;.</source>
          <target state="translated">지정된 커밋 (팁이 지정되지 않은 경우 HEAD)에서 팁에 도달 할 수 있고 &lt;code&gt;--no-merged&lt;/code&gt; 와 호환되지 않는 참조 만 나열합니다 .</target>
        </trans-unit>
        <trans-unit id="ba8f796a110a2bce3b3362030f4149e3e571d92d" translate="yes" xml:space="preserve">
          <source>Only list refs whose tips are reachable from the specified commit (HEAD if not specified).</source>
          <target state="translated">지정된 커밋에서 팁에 도달 할 수있는 참조 만 나열합니다 (지정되지 않은 경우 HEAD).</target>
        </trans-unit>
        <trans-unit id="817a4e30ee524e4266621c0a4648ab3909ffeed4" translate="yes" xml:space="preserve">
          <source>Only list tags of the given object (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">지정된 객체의 태그 만 나열합니다 (지정하지 않은 경우 HEAD). &lt;code&gt;--list&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="83f1d08e3476b4b0f43eedc9885a23e56ff396f3" translate="yes" xml:space="preserve">
          <source>Only list tags which contain the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">지정된 커밋이 포함 된 태그 만 나열합니다 (지정하지 않은 경우 HEAD). &lt;code&gt;--list&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="4bae480f98a8915919a61381cb993558ff75823a" translate="yes" xml:space="preserve">
          <source>Only list tags which don&amp;rsquo;t contain the specified commit (HEAD if not specified). Implies &lt;code&gt;--list&lt;/code&gt;.</source>
          <target state="translated">지정된 커밋을 포함하지 않는 태그 만 나열합니다 (지정하지 않은 경우 HEAD). &lt;code&gt;--list&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="db9714bdab86b2c5263129a27ca40bb06f5dcdf2" translate="yes" xml:space="preserve">
          <source>Only list tags whose commits are not reachable from the specified commit (&lt;code&gt;HEAD&lt;/code&gt; if not specified), incompatible with &lt;code&gt;--merged&lt;/code&gt;.</source>
          <target state="translated">지정된 커밋 (커밋 되지 않은 경우 &lt;code&gt;HEAD&lt;/code&gt; ) 에서 커밋에 도달 할 수 없고 &lt;code&gt;--merged&lt;/code&gt; 와 호환되지 않는 태그 만 나열합니다 .</target>
        </trans-unit>
        <trans-unit id="0941b6737a5c9cc5d8d6c699e027514c86f27e53" translate="yes" xml:space="preserve">
          <source>Only list tags whose commits are not reachable from the specified commit (&lt;code&gt;HEAD&lt;/code&gt; if not specified).</source>
          <target state="translated">지정된 커밋에서 커밋에 도달 할 수없는 태그 만 나열합니다 ( 지정되지 않은 경우 &lt;code&gt;HEAD&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1c62aa2054943bc2c5749c5693c2757ab8e53449" translate="yes" xml:space="preserve">
          <source>Only list tags whose commits are reachable from the specified commit (&lt;code&gt;HEAD&lt;/code&gt; if not specified), incompatible with &lt;code&gt;--no-merged&lt;/code&gt;.</source>
          <target state="translated">지정된 커밋 (커밋 되지 않은 경우 &lt;code&gt;HEAD&lt;/code&gt; ) 에서 커밋에 도달 할 수 있고 &lt;code&gt;--no-merged&lt;/code&gt; 와 호환되지 않는 태그 만 나열합니다 .</target>
        </trans-unit>
        <trans-unit id="bc01884094a83344ad50773c56388f9731a753fa" translate="yes" xml:space="preserve">
          <source>Only list tags whose commits are reachable from the specified commit (&lt;code&gt;HEAD&lt;/code&gt; if not specified).</source>
          <target state="translated">지정된 커밋에서 커밋에 도달 할 수있는 태그 만 나열합니다 ( 지정되지 않은 경우 &lt;code&gt;HEAD&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b0cdb0cde0c40de0beaaced5d658f2a7018630fe" translate="yes" xml:space="preserve">
          <source>Only look at the history which touches the given subdirectory. The result will contain that directory (and only that) as its project root. Implies &lt;a href=&quot;#Remap_to_ancestor&quot;&gt;Remap to ancestor&lt;/a&gt;.</source>
          <target state="translated">주어진 서브 디렉토리를 터치하는 히스토리 만보십시오. 결과는 해당 디렉토리 (그리고 그 디렉토리 만)를 프로젝트 루트로 포함합니다. &lt;a href=&quot;#Remap_to_ancestor&quot;&gt;조상에 다시 매핑을&lt;/a&gt; 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="2bbdf47a64eee45ee95696813788d11863c01152" translate="yes" xml:space="preserve">
          <source>Only meaningful in &lt;code&gt;--parseopt&lt;/code&gt; mode. Lets the option parser stop at the first non-option argument. This can be used to parse sub-commands that take options themselves.</source>
          <target state="translated">&lt;code&gt;--parseopt&lt;/code&gt; 모드 에서만 의미가 있습니다. 옵션 파서가 옵션이 아닌 첫 번째 인수에서 중지되도록합니다. 옵션 자체를 취하는 하위 명령을 구문 분석하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8057f98f6fd66c86adb34f091c531e316f7ca42" translate="yes" xml:space="preserve">
          <source>Only meaningful in &lt;code&gt;--parseopt&lt;/code&gt; mode. Output the options in their long form if available, and with their arguments stuck.</source>
          <target state="translated">&lt;code&gt;--parseopt&lt;/code&gt; 모드 에서만 의미가 있습니다. 가능한 경우 옵션을 긴 형식으로 출력하고 인수가 멈춘 상태로 출력하십시오.</target>
        </trans-unit>
        <trans-unit id="6000fe90599266e72e627572d6cdbc969916ee02" translate="yes" xml:space="preserve">
          <source>Only meaningful in &lt;code&gt;--parseopt&lt;/code&gt; mode. Tells the option parser to echo out the first &lt;code&gt;--&lt;/code&gt; met instead of skipping it.</source>
          <target state="translated">&lt;code&gt;--parseopt&lt;/code&gt; 모드 에서만 의미가 있습니다. 첫 번째 밖으로 에코 옵션 파서를 알려줍니다 &lt;code&gt;--&lt;/code&gt; 대신을 건너 뛰는의 만족을.</target>
        </trans-unit>
        <trans-unit id="fd3f5d99fba63ca8e5d281298074650f7e9548b0" translate="yes" xml:space="preserve">
          <source>Only meaningful in &lt;code&gt;--verify&lt;/code&gt; mode. Do not output an error message if the first argument is not a valid object name; instead exit with non-zero status silently. SHA-1s for valid object names are printed to stdout on success.</source>
          <target state="translated">&lt;code&gt;--verify&lt;/code&gt; 모드 에서만 의미가 있습니다. 첫 번째 인수가 유효한 오브젝트 이름이 아닌 경우 오류 메시지를 출력하지 마십시오. 대신 0이 아닌 상태로 자동 종료하십시오. 유효한 오브젝트 이름에 대한 SHA-1은 성공시 stdout으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="94590902338d0f64df58223a7c9238b6579f4aae" translate="yes" xml:space="preserve">
          <source>Only meaningful with &lt;code&gt;--pathspec-from-file&lt;/code&gt;. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes).</source>
          <target state="translated">&lt;code&gt;--pathspec-from-file&lt;/code&gt; 에서만 의미가 있습니다 . Pathspec 요소는 NUL 문자로 구분되며 다른 모든 문자는 문자 그대로 사용됩니다 (줄 바꾸기 및 따옴표 포함).</target>
        </trans-unit>
        <trans-unit id="0ecebefb0a1162c42954005e600970eacea40ab1" translate="yes" xml:space="preserve">
          <source>Only meaningful with &lt;code&gt;--stdin&lt;/code&gt; or &lt;code&gt;--index-info&lt;/code&gt;; paths are separated with NUL character instead of LF.</source>
          <target state="translated">&lt;code&gt;--stdin&lt;/code&gt; 또는 &lt;code&gt;--index-info&lt;/code&gt; 에서만 의미가 있습니다 . 경로는 LF 대신 NUL 문자로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="6ad4315a7f6c11660aa6c643c4b95eaab7a8d728" translate="yes" xml:space="preserve">
          <source>Only meaningful with &lt;code&gt;--stdin&lt;/code&gt;; paths are separated with NUL character instead of LF.</source>
          <target state="translated">&lt;code&gt;--stdin&lt;/code&gt; 에서만 의미가 있습니다 . 경로는 LF 대신 NUL 문자로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="2ebb91d27792ee23446f1d49f12e2e8cf850fef7" translate="yes" xml:space="preserve">
          <source>Only necessary if --compose is also set. If --compose is not set, this will be prompted for.</source>
          <target state="translated">--compose도 설정 한 경우에만 필요합니다. --compose가 설정되어 있지 않으면 프롬프트가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3a2cfa8e4dfa7576e427c217c4a335798a141827" translate="yes" xml:space="preserve">
          <source>Only one parameter should be set to &quot;1&quot; when the hook runs. The hook running passing &quot;1&quot;, &quot;1&quot; should not be possible.</source>
          <target state="translated">후크가 실행될 때 하나의 매개 변수 만 &quot;1&quot;로 설정해야합니다. &quot;1&quot;, &quot;1&quot;을 (를) 통과하는 후크가 작동하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="bf7e12b67481a70907ee19a1cd34bdb9c2cfbcbb" translate="yes" xml:space="preserve">
          <source>Only output exact matches (a tag directly references the supplied commit). This is a synonym for --candidates=0.</source>
          <target state="translated">출력 정확히 일치 만 제공합니다 (태그는 제공된 커밋을 직접 참조합니다). 이것은 --candidates = 0의 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="16dbfb260245eaec3998212f13b1a52e2d286e0a" translate="yes" xml:space="preserve">
          <source>Only p4 labels matching this regular expression will be exported. The default value is &lt;code&gt;[a-zA-Z0-9_\-.]+$&lt;/code&gt;.</source>
          <target state="translated">이 정규식과 일치하는 p4 레이블 만 내보내집니다. 기본값은 &lt;code&gt;[a-zA-Z0-9_\-.]+$&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eeb8bb30ea7ba21536e78e1ff49007a02268174b" translate="yes" xml:space="preserve">
          <source>Only p4 labels matching this regular expression will be imported. The default value is &lt;code&gt;[a-zA-Z0-9_\-.]+$&lt;/code&gt;.</source>
          <target state="translated">이 정규식과 일치하는 p4 레이블 만 가져옵니다. 기본값은 &lt;code&gt;[a-zA-Z0-9_\-.]+$&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e2fdb861f4cc24f6e2448e8ab0d3c248ec24997f" translate="yes" xml:space="preserve">
          <source>Only perform tests on the working directory to make sure untracked cache can be used. You have to manually enable untracked cache using &lt;code&gt;--untracked-cache&lt;/code&gt; or &lt;code&gt;--force-untracked-cache&lt;/code&gt; or the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable afterwards if you really want to use it. If a test fails the exit code is 1 and a message explains what is not working as needed, otherwise the exit code is 0 and OK is printed.</source>
          <target state="translated">추적되지 않은 캐시를 사용할 수 있도록 작업 디렉토리에서만 테스트를 수행하십시오. 수동으로 사용하여 추적 된 캐시를 활성화해야 &lt;code&gt;--untracked-cache&lt;/code&gt; 또는 &lt;code&gt;--force-untracked-cache&lt;/code&gt; 또는 &lt;code&gt;core.untrackedCache&lt;/code&gt; 의 당신이 정말로 그것을 사용하려는 경우 나중에 구성 변수를. 테스트가 실패하면 종료 코드는 1이고 필요에 따라 작동하지 않는 것을 설명하는 메시지가 표시되고, 그렇지 않으면 종료 코드는 0이고 확인이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="9b88e48a96d98ad3b76de8b5d274db692fc6b29c" translate="yes" xml:space="preserve">
          <source>Only print error and warning messages; all other output will be suppressed.</source>
          <target state="translated">오류 및 경고 메시지 만 인쇄하십시오. 다른 모든 출력은 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="3791d8648f923430d0795b4e9f5031ac211bf7f1" translate="yes" xml:space="preserve">
          <source>Only print error messages.</source>
          <target state="translated">오류 메시지 만 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="affbeb73b1dd267a08167d9ea74afe477ad3529f" translate="yes" xml:space="preserve">
          <source>Only show the SHA-1 hash, not the reference name. When combined with --dereference the dereferenced tag will still be shown after the SHA-1.</source>
          <target state="translated">참조 이름이 아닌 SHA-1 해시 만 표시하십시오. --dereference와 함께 사용하면 역 참조 된 태그는 여전히 SHA-1 뒤에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="74a12c610ac9d71beb7074574ccb847224f9f712" translate="yes" xml:space="preserve">
          <source>Only show the given commits, but do not traverse their ancestors. This has no effect if a range is specified. If the argument &lt;code&gt;unsorted&lt;/code&gt; is given, the commits are shown in the order they were given on the command line. Otherwise (if &lt;code&gt;sorted&lt;/code&gt; or no argument was given), the commits are shown in reverse chronological order by commit time. Cannot be combined with &lt;code&gt;--graph&lt;/code&gt;.</source>
          <target state="translated">주어진 커밋 만 보여 주지만 조상을 가로 지르지 마십시오. 범위가 지정된 경우에는 효과가 없습니다. &lt;code&gt;unsorted&lt;/code&gt; 인수 가 제공되면, 커미트는 명령 행에 제공된 순서대로 표시됩니다. 그렇지 않으면 ( &lt;code&gt;sorted&lt;/code&gt; 되거나 인수가 제공되지 않은 경우 ) 커밋은 커밋 시간에 따라 역순으로 표시됩니다. &lt;code&gt;--graph&lt;/code&gt; 와 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6ed956e65db38a49fac1dac50248e7edb1c43fb7" translate="yes" xml:space="preserve">
          <source>Only submodules using a gitfile (which means they were cloned with a Git version 1.7.8 or newer) will be removed from the work tree, as their repository lives inside the .git directory of the superproject. If a submodule (or one of those nested inside it) still uses a .git directory, &lt;code&gt;git rm&lt;/code&gt; will move the submodules git directory into the superprojects git directory to protect the submodule&amp;rsquo;s history. If it exists the submodule.&amp;lt;name&amp;gt; section in the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file will also be removed and that file will be staged (unless --cached or -n are used).</source>
          <target state="translated">gitfile을 사용하는 하위 모듈 (Git 버전 1.7.8 이상으로 복제 된 것을 의미) 만 리포지토리가 수퍼 프로젝트의 .git 디렉토리에 있으므로 작업 트리에서 제거됩니다. 서브 모듈 (또는 그 안에 중첩 된 서브 모듈 중 하나)이 여전히 .git 디렉토리를 사용하는 경우, &lt;code&gt;git rm&lt;/code&gt; 은 서브 모듈 git 디렉토리를 수퍼 프로젝트 git 디렉토리로 이동시켜 서브 모듈의 히스토리를 보호합니다. 그것이 존재한다면 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 파일 의 submodule. &amp;lt;name&amp;gt; 섹션 도 제거되고 해당 파일이 준비됩니다 (--cached 또는 -n을 사용하지 않는 한).</target>
        </trans-unit>
        <trans-unit id="f3b6918bb732fd2722633a305233dd0ec34bff15" translate="yes" xml:space="preserve">
          <source>Only takes effect for dates shown in human-readable format, such as when using &lt;code&gt;--pretty&lt;/code&gt;. &lt;code&gt;log.date&lt;/code&gt; config variable sets a default value for the log command&amp;rsquo;s &lt;code&gt;--date&lt;/code&gt; option. By default, dates are shown in the original time zone (either committer&amp;rsquo;s or author&amp;rsquo;s). If &lt;code&gt;-local&lt;/code&gt; is appended to the format (e.g., &lt;code&gt;iso-local&lt;/code&gt;), the user&amp;rsquo;s local time zone is used instead.</source>
          <target state="translated">&lt;code&gt;--pretty&lt;/code&gt; 를 사용할 때와 같이 사람이 읽을 수있는 형식으로 표시된 날짜에만 적용됩니다 . &lt;code&gt;log.date&lt;/code&gt; 구성 변수는 log 명령의 &lt;code&gt;--date&lt;/code&gt; 옵션에 대한 기본값을 설정합니다 . 기본적으로 날짜는 원래 시간대 (커미터 또는 작성자)에 표시됩니다. &lt;code&gt;-local&lt;/code&gt; 이 형식에 추가 되면 (예 : &lt;code&gt;iso-local&lt;/code&gt; ) 사용자의 현지 시간대가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="28227446e42814d459bad1017137f194a3d411bf" translate="yes" xml:space="preserve">
          <source>Only the initial ref advertisement is output, and the program exits immediately. This fits with the HTTP GET request model, where no request content is received but a response must be produced.</source>
          <target state="translated">초기 심판 광고 만 출력되고 프로그램이 즉시 종료됩니다. 이는 요청 컨텐츠가 수신되지 않지만 응답을 생성해야하는 HTTP GET 요청 모델에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="d70e32ee66c9f176a2ec41ee4464e248b98de054" translate="yes" xml:space="preserve">
          <source>Only the rev_map and refs/remotes/git-svn are changed (see &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; in the FILES section below for details). Follow &lt;code&gt;reset&lt;/code&gt; with a &lt;code&gt;fetch&lt;/code&gt; and then &lt;code&gt;git reset&lt;/code&gt; or &lt;code&gt;git rebase&lt;/code&gt; to move local branches onto the new tree.</source>
          <target state="translated">rev_map 및 refs / remotes / git-svn 만 변경됩니다 (자세한 내용은 아래 FILES 섹션에서 &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; 참조). 에 따라 &lt;code&gt;reset&lt;/code&gt; A를 &lt;code&gt;fetch&lt;/code&gt; 다음 &lt;code&gt;git reset&lt;/code&gt; 또는 &lt;code&gt;git rebase&lt;/code&gt; 새로운 트리로 이동하는 현지 지점.</target>
        </trans-unit>
        <trans-unit id="32e7b8a674c1b57420afbf6e783864cc587eae94" translate="yes" xml:space="preserve">
          <source>Only the selected commits are shown, plus some to have a meaningful history.</source>
          <target state="translated">선택한 커밋 만 표시되고 일부는 의미있는 기록을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="5988bcb17bfff8bdefbf4f11c653c30a84ac354c" translate="yes" xml:space="preserve">
          <source>Only untracked files in submodules will be ignored. Committed differences and modifications to tracked files will show up.</source>
          <target state="translated">하위 모듈에서 추적되지 않은 파일 만 무시됩니다. 추적 된 파일에 대한 확약 된 차이점 및 수정 사항이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a35d5f8b7ffccc1327ae3b4b170fadaf17be62a8" translate="yes" xml:space="preserve">
          <source>Only update and add files to the working directory, but don&amp;rsquo;t delete them, similar to how 'cp -R' would update the contents in the destination directory. This is the default mode in a &lt;a href=&quot;#def_checkout&quot;&gt;checkout&lt;/a&gt; when checking out files from the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; or a &lt;a href=&quot;#def_tree-ish&quot;&gt;tree-ish&lt;/a&gt;. In contrast, no-overlay mode also deletes tracked files not present in the source, similar to 'rsync --delete'.</source>
          <target state="translated">'cp -R'이 대상 디렉토리의 내용을 업데이트하는 방법과 유사하게 작업 디렉토리에만 파일을 업데이트하고 추가하지만 삭제하지 마십시오. &lt;a href=&quot;#def_index&quot;&gt;인덱스&lt;/a&gt; 또는 &lt;a href=&quot;#def_tree-ish&quot;&gt;tree-ish&lt;/a&gt; 에서 파일을 &lt;a href=&quot;#def_checkout&quot;&gt;체크 아웃&lt;/a&gt; 할 때 체크 아웃 의 기본 모드입니다 . 반대로 오버레이 없음 모드는 'rsync --delete'와 마찬가지로 소스에없는 추적 된 파일도 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="a09a6feef23c1bf8bf8489c07fa754b0e3467e64" translate="yes" xml:space="preserve">
          <source>Only update and add files to the working directory, but don&amp;rsquo;t delete them, similar to how &lt;code&gt;cp -R&lt;/code&gt; would update the contents in the destination directory. This is the default mode in a &lt;a href=&quot;#def_checkout&quot;&gt;checkout&lt;/a&gt; when checking out files from the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; or a &lt;a href=&quot;#def_tree-ish&quot;&gt;tree-ish&lt;/a&gt;. In contrast, no-overlay mode also deletes tracked files not present in the source, similar to &lt;code&gt;rsync --delete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cp -R&lt;/code&gt; 이 대상 디렉토리의 내용을 업데이트하는 방법과 유사하게 작업 디렉토리에만 파일을 업데이트하고 추가하지만 삭제하지 마십시오 . &lt;a href=&quot;#def_index&quot;&gt;인덱스&lt;/a&gt; 또는 &lt;a href=&quot;#def_tree-ish&quot;&gt;tree-ish&lt;/a&gt; 에서 파일을 &lt;a href=&quot;#def_checkout&quot;&gt;체크 아웃&lt;/a&gt; 할 때 체크 아웃 의 기본 모드입니다 . 반대로 오버레이 없음 모드는 &lt;code&gt;rsync --delete&lt;/code&gt; 와 유사하게 소스에없는 추적 된 파일도 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="cd6ac5160ec46e3d1df2371d183d50a5e06ffdbe" translate="yes" xml:space="preserve">
          <source>Only use refs whose names match a given shell pattern. The pattern can be one of branch name, tag name or fully qualified ref name. If given multiple times, use refs whose names match any of the given shell patterns. Use &lt;code&gt;--no-refs&lt;/code&gt; to clear any previous ref patterns given.</source>
          <target state="translated">주어진 쉘 패턴과 이름이 일치하는 심판 만 사용하십시오. 패턴은 브랜치 이름, 태그 이름 또는 정규화 된 참조 이름 중 하나 일 수 있습니다. 여러 번 주어진 경우, 주어진 쉘 패턴과 이름이 일치하는 심판을 사용하십시오. 주어진 이전 참조 패턴을 지우려면 &lt;code&gt;--no-refs&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d533153e7612cafa4bc7b83b50dd3abb697af0e" translate="yes" xml:space="preserve">
          <source>Only used with the &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;set-tree&lt;/code&gt; and &lt;code&gt;commit-diff&lt;/code&gt; commands.</source>
          <target state="translated">&lt;code&gt;dcommit&lt;/code&gt; , &lt;code&gt;set-tree&lt;/code&gt; 및 &lt;code&gt;commit-diff&lt;/code&gt; 명령 에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="901e1e4a237282bb48e582bb5bf0599881cd0084" translate="yes" xml:space="preserve">
          <source>Only used with the &lt;code&gt;init&lt;/code&gt; command. These are passed directly to &lt;code&gt;git init&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; 명령 에서만 사용됩니다 . 이것들은 &lt;code&gt;git init&lt;/code&gt; 에 직접 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="f5e61001de0ada8f2eb5dc9bbc0a16644112482b" translate="yes" xml:space="preserve">
          <source>Only used with the &lt;code&gt;set-tree&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;set-tree&lt;/code&gt; 명령 에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e227b5617ca7c2b377054ab1d12644a8cc591504" translate="yes" xml:space="preserve">
          <source>Only useful with &lt;code&gt;--filter=&lt;/code&gt;; prints a list of the objects omitted by the filter. Object IDs are prefixed with a &amp;ldquo;~&amp;rdquo; character.</source>
          <target state="translated">&lt;code&gt;--filter=&lt;/code&gt; 에서만 유용합니다 . 필터에서 생략 된 개체 목록을 인쇄합니다. 개체 ID 앞에는 &quot;~&quot;문자가 붙습니다.</target>
        </trans-unit>
        <trans-unit id="c898c5ecedbff05a6572c10f50d4d5872a590271" translate="yes" xml:space="preserve">
          <source>Only useful with &lt;code&gt;--objects&lt;/code&gt;; does not print the names of the object IDs that are found. This inverts &lt;code&gt;--object-names&lt;/code&gt;. This flag allows the output to be more easily parsed by commands such as &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;--objects&lt;/code&gt; 에만 유용합니다 . 발견 된 오브젝트 ID의 이름을 인쇄하지 않습니다. 이것은 &lt;code&gt;--object-names&lt;/code&gt; 를 뒤집습니다 . 이 플래그를 사용하면 &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file [1]&lt;/a&gt; 과 같은 명령으로 출력을보다 쉽게 ​​구문 분석 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbbf115261d96b04c5005e948b7d150b4779f83e" translate="yes" xml:space="preserve">
          <source>Only useful with &lt;code&gt;--objects&lt;/code&gt;; print the names of the object IDs that are found. This is the default behavior.</source>
          <target state="translated">&lt;code&gt;--objects&lt;/code&gt; 에만 유용합니다 . 발견 된 오브젝트 ID의 이름을 인쇄하십시오. 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="96aa4c0ed29b4ff25b67f82110d672c478c9f0a4" translate="yes" xml:space="preserve">
          <source>Only useful with &lt;code&gt;--objects&lt;/code&gt;; print the object IDs that are not in packs.</source>
          <target state="translated">&lt;code&gt;--objects&lt;/code&gt; 에만 유용합니다 . 팩에없는 오브젝트 ID를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="395c9938b3e2e6eaf4d1417f6499451782d5fa84" translate="yes" xml:space="preserve">
          <source>Only useful with one of the &lt;code&gt;--objects*&lt;/code&gt;; omits objects (usually blobs) from the list of printed objects. The &lt;code&gt;&amp;lt;filter-spec&amp;gt;&lt;/code&gt; may be one of the following:</source>
          <target state="translated">&lt;code&gt;--objects*&lt;/code&gt; 중 하나에서만 유용합니다 . 인쇄 된 객체 목록에서 객체 (일반적으로 얼룩)를 생략합니다. &lt;code&gt;&amp;lt;filter-spec&amp;gt;&lt;/code&gt; 다음 중 하나 일 수있다 :</target>
        </trans-unit>
        <trans-unit id="c55263ee2e693cf4a68e8c688a3aeedef8c016f1" translate="yes" xml:space="preserve">
          <source>Only valid setting is &quot;--unified=??&quot; or &quot;-u??&quot; to set the number of context lines shown when a unified diff is created. This takes precedence over any &quot;-U&quot; or &quot;--unified&quot; option value passed on the Git diff command line.</source>
          <target state="translated">유효한 설정 만 &quot;--unified = ??&quot;입니다. 또는 &quot;-u ??&quot; 통합 diff가 생성 될 때 표시되는 컨텍스트 라인 수를 설정합니다. 이것은 Git diff 명령 행에 전달 된 &quot;-U&quot;또는 &quot;--unified&quot;옵션 값보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="77fb8a535dafe4973135cbd89eaf06e8f07b4529" translate="yes" xml:space="preserve">
          <source>Only works if the changes (patch IDs based on the diff contents) on &lt;code&gt;subsystem&lt;/code&gt; are literally the same before and after the rebase &lt;code&gt;subsystem&lt;/code&gt; did.</source>
          <target state="translated">&lt;code&gt;subsystem&lt;/code&gt; 의 변경 사항 (diff 내용을 기반으로 한 패치 ID) 이 rebase &lt;code&gt;subsystem&lt;/code&gt; 이전과 이후에 문자 그대로 동일한 경우에만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="5a64b44f8d7042d0b4832141c36a7e5d8d6c4434" translate="yes" xml:space="preserve">
          <source>Oops. That wasn&amp;rsquo;t very readable. It just spit out its own internal version of a &lt;code&gt;diff&lt;/code&gt;, but that internal version really just tells you that it has noticed that &quot;hello&quot; has been modified, and that the old object contents it had have been replaced with something else.</source>
          <target state="translated">죄송합니다. 읽기 쉽지 않았습니다. 그것은 단지 &lt;code&gt;diff&lt;/code&gt; 의 내부 버전을 내뱉었 지 만 , 그 내부 버전은 실제로 &quot;hello&quot;가 수정되었으며 이전 객체 내용이 다른 것으로 대체되었음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e55d62611877e337f8aa065fb0b3d20e9fe0e5a" translate="yes" xml:space="preserve">
          <source>Open a compose window and click the external editor icon.</source>
          <target state="translated">작성 창을 열고 외부 편집기 아이콘을 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="db4ff8c108e7b94773be0de613a7b629cb1df8fa" translate="yes" xml:space="preserve">
          <source>Open an editor and edit the text to explain what the branch is for, to be used by various other commands (e.g. &lt;code&gt;format-patch&lt;/code&gt;, &lt;code&gt;request-pull&lt;/code&gt;, and &lt;code&gt;merge&lt;/code&gt; (if enabled)). Multi-line explanations may be used.</source>
          <target state="translated">편집기를 열고 텍스트를 편집하여 분기가 무엇인지 설명하고 다양한 다른 명령 (예 : &lt;code&gt;format-patch&lt;/code&gt; , &lt;code&gt;request-pull&lt;/code&gt; 및 &lt;code&gt;merge&lt;/code&gt; (활성화 된 경우))에 사용됩니다. 여러 줄 설명이 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="577c09c011d74bfddaa145d1c3817d3d9900cb19" translate="yes" xml:space="preserve">
          <source>Open the diff vs. the index in an editor and let the user edit it. After the editor was closed, adjust the hunk headers and apply the patch to the index.</source>
          <target state="translated">편집기에서 diff vs. index를 열고 사용자가 편집 할 수있게하십시오. 에디터가 닫힌 후, 헝크 헤더를 조정하고 패치를 인덱스에 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="1e40bc8b6fc685aae183dd5f07e4256cd3e46abe" translate="yes" xml:space="preserve">
          <source>Open the matching files in the pager (not the output of &lt;code&gt;grep&lt;/code&gt;). If the pager happens to be &quot;less&quot; or &quot;vi&quot;, and the user specified only one pattern, the first file is positioned at the first match automatically. The &lt;code&gt;pager&lt;/code&gt; argument is optional; if specified, it must be stuck to the option without a space. If &lt;code&gt;pager&lt;/code&gt; is unspecified, the default pager will be used (see &lt;code&gt;core.pager&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">호출기에서 일치하는 파일을여십시오 ( &lt;code&gt;grep&lt;/code&gt; 의 출력이 아님). 호출기가 &quot;less&quot;또는 &quot;vi&quot;인 경우 사용자가 하나의 패턴 만 지정한 경우 첫 번째 파일은 첫 번째 일치 항목에 자동으로 배치됩니다. &lt;code&gt;pager&lt;/code&gt; 인수는 선택 사항입니다; 지정된 경우 공백없이 옵션을 사용해야합니다. 경우 &lt;code&gt;pager&lt;/code&gt; 지정되어 있지 않은 기본 호출기 (참고 사용될 &lt;code&gt;core.pager&lt;/code&gt; 을 에 &lt;a href=&quot;git-config&quot;&gt;자식-구성 [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8ab75f225f79420c5b860ca24bd40f7491c784f1" translate="yes" xml:space="preserve">
          <source>Opens an editor to modify the specified config file; either &lt;code&gt;--system&lt;/code&gt;, &lt;code&gt;--global&lt;/code&gt;, or repository (default).</source>
          <target state="translated">지정된 구성 파일을 수정하기 위해 편집기를 엽니 다. 하나 &lt;code&gt;--system&lt;/code&gt; , &lt;code&gt;--global&lt;/code&gt; , 또는 저장소 (기본값).</target>
        </trans-unit>
        <trans-unit id="869e0439c9b6be4fa4547f64fcc46a677445443d" translate="yes" xml:space="preserve">
          <source>Operate quietly. Implies --no-progress.</source>
          <target state="translated">조용히 작동하십시오. --no-progress를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="976297b1ff380abe9b067b3a1569ff64fe97ece7" translate="yes" xml:space="preserve">
          <source>Operate quietly. Progress is not reported to the standard error stream.</source>
          <target state="translated">조용히 작동하십시오. 진행률은 표준 오류 스트림에보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="09f22e6b29a644f35840ab8527beed58937c2452" translate="yes" xml:space="preserve">
          <source>Operating modes</source>
          <target state="translated">작동 모드</target>
        </trans-unit>
        <trans-unit id="b5ddf3c63568d76ebc23d453be7fdb731eb8db1b" translate="yes" xml:space="preserve">
          <source>Operation Modes</source>
          <target state="translated">작동 모드</target>
        </trans-unit>
        <trans-unit id="7196d0b4f156df0cb7286af7737967727f46300d" translate="yes" xml:space="preserve">
          <source>Operation modes</source>
          <target state="translated">작동 모드</target>
        </trans-unit>
        <trans-unit id="1bc69d57cbb59ff5bdbc63f455c23bce178e5e54" translate="yes" xml:space="preserve">
          <source>Operations supported</source>
          <target state="translated">지원되는 작업</target>
        </trans-unit>
        <trans-unit id="573db325843d7fd90adea414c1ffec090ab48249" translate="yes" xml:space="preserve">
          <source>Optimize a pack that will be provided to a client with a shallow repository. This option, combined with --thin, can result in a smaller pack at the cost of speed.</source>
          <target state="translated">얕은 저장소가있는 클라이언트에 제공 될 팩을 최적화하십시오. 이 옵션을 --thin과 함께 사용하면 속도를 낮추면서 더 작은 팩을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4679da9817f2d593d1926870257534b31ee86cfa" translate="yes" xml:space="preserve">
          <source>Option commands must be the first commands on the input (not counting feature commands), to give an option command after any non-option command is an error.</source>
          <target state="translated">옵션 명령이 아닌 오류가 발생한 후 옵션 명령을 제공하려면 옵션 명령이 입력의 첫 번째 명령 (기능 명령을 세지 않음)이어야합니다.</target>
        </trans-unit>
        <trans-unit id="da44303dd559700c5ce39d2667eb27c2885407ef" translate="yes" xml:space="preserve">
          <source>Optional &amp;lt;path&amp;gt; arguments limit which submodules will be initialized. If no path is specified and submodule.active has been configured, submodules configured to be active will be initialized, otherwise all submodules are initialized.</source>
          <target state="translated">선택적 &amp;lt;path&amp;gt; 인수는 초기화 할 서브 모듈을 제한합니다. 경로를 지정하지 않고 submodule.active를 구성한 경우 활성화되도록 구성된 하위 모듈이 초기화되고 그렇지 않으면 모든 하위 모듈이 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="e95e402b64c3c594a37117914c5cb87d814b2b44" translate="yes" xml:space="preserve">
          <source>Optional modifiers can be provided in the beginning of the value to filter commands for specific actions: create (a), modify (m), delete (d). A &lt;code&gt;!&lt;/code&gt; can be included in the modifiers to negate the reference prefix entry. E.g.:</source>
          <target state="translated">특정 작업 (생성 (a), 수정 (m), 삭제 (d))에 대한 명령을 필터링하기 위해 값 시작 부분에 선택적 수정자를 제공 할 수 있습니다. A &lt;code&gt;!&lt;/code&gt; 참조 접두사 항목을 부정하기 위해 수정 자에 포함될 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="be215efb6b35fec1e17ea79655a45bba1595ca40" translate="yes" xml:space="preserve">
          <source>Optionally a new branch could be created with either &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt;, automatically from a remote branch of same name (see &lt;code&gt;--guess&lt;/code&gt;), or detach the working tree from any branch with &lt;code&gt;--detach&lt;/code&gt;, along with switching.</source>
          <target state="translated">선택적으로, 새로운 지점이 어느로 생성 될 수 &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; 자동 동일한 이름의 원격 지점에서 (참조 &lt;code&gt;--guess&lt;/code&gt; ) 또는 어떤 지점에서 작업 트리 분리 &lt;code&gt;--detach&lt;/code&gt; 스위칭과 함께.</target>
        </trans-unit>
        <trans-unit id="d773dc6382eb3328de30b1c7224e0be840082992" translate="yes" xml:space="preserve">
          <source>Optionally may output a &lt;code&gt;lock &amp;lt;file&amp;gt;&lt;/code&gt; line indicating the full path of a file under &lt;code&gt;$GIT_DIR/objects/pack&lt;/code&gt; which is keeping a pack until refs can be suitably updated. The path must end with &lt;code&gt;.keep&lt;/code&gt;. This is a mechanism to name a &amp;lt;pack,idx,keep&amp;gt; tuple by giving only the keep component. The kept pack will not be deleted by a concurrent repack, even though its objects may not be referenced until the fetch completes. The &lt;code&gt;.keep&lt;/code&gt; file will be deleted at the conclusion of the fetch.</source>
          <target state="translated">선택적 으로 &lt;code&gt;$GIT_DIR/objects/pack&lt;/code&gt; 아래에있는 파일의 전체 경로를 나타내는 &lt;code&gt;lock &amp;lt;file&amp;gt;&lt;/code&gt; 행을 출력 할 수 있으며, 참조를 적절히 업데이트 할 수있을 때까지 팩 을 유지합니다. 경로는 &lt;code&gt;.keep&lt;/code&gt; 으로 끝나야 합니다. 이것은 유지 구성 요소 만 제공하여 &amp;lt;pack, idx, keep&amp;gt; 튜플의 이름을 지정하는 메커니즘입니다. 페치가 완료 될 때까지 오브젝트를 참조 할 수없는 경우에도 보존 된 팩은 동시 리팩에 의해 삭제되지 않습니다. &lt;code&gt;.keep&lt;/code&gt; 의 파일은 가져 오기의 결론에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="66770b44a484bf62b3beb74f057263164da82747" translate="yes" xml:space="preserve">
          <source>Optionally with -m:</source>
          <target state="translated">선택적으로 -m과 함께 :</target>
        </trans-unit>
        <trans-unit id="3e5a4f0fcbf7c88862ec022584d8faedebb202bf" translate="yes" xml:space="preserve">
          <source>Optionally, a &amp;lt;ref&amp;gt; parameter can be prefixed with a plus &lt;code&gt;+&lt;/code&gt; sign to disable the fast-forward check only on that ref.</source>
          <target state="translated">선택적으로 &amp;lt;ref&amp;gt; 매개 변수 앞에 더하기 &lt;code&gt;+&lt;/code&gt; 부호를 붙여 해당 참조에서만 빨리 감기 검사를 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ad18880dec3737f40f1be35d71296de89bc6175" translate="yes" xml:space="preserve">
          <source>Optionally, it can merge a tree into the index, perform a fast-forward (i.e. 2-way) merge, or a 3-way merge, with the &lt;code&gt;-m&lt;/code&gt; flag. When used with &lt;code&gt;-m&lt;/code&gt;, the &lt;code&gt;-u&lt;/code&gt; flag causes it to also update the files in the work tree with the result of the merge.</source>
          <target state="translated">선택적으로, 트리를 인덱스로 병합하고, &lt;code&gt;-m&lt;/code&gt; 플래그를 사용하여 빨리 감기 (즉, 2 방향) 병합 또는 3 방향 병합을 수행 할 수 있습니다. &lt;code&gt;-m&lt;/code&gt; 과 함께 사용 하면 &lt;code&gt;-u&lt;/code&gt; 플래그는 병합 결과로 작업 트리의 파일도 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="c844411e7897e1475e2bbc7e1cd47d6ca3b70b75" translate="yes" xml:space="preserve">
          <source>Options for --parseopt</source>
          <target state="translated">--parseopt 옵션</target>
        </trans-unit>
        <trans-unit id="9c25d7f1531501faea711b1933ac2734dd8f1324" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;delete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; 옵션</target>
        </trans-unit>
        <trans-unit id="7eec6c07b2d8ff28d282e8d3918c0430dfd638ff" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;expire&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;expire&lt;/code&gt; 옵션</target>
        </trans-unit>
        <trans-unit id="e73b9df34672d383e318c543fe1ed5467baa2316" translate="yes" xml:space="preserve">
          <source>Options for &lt;code&gt;show&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;show&lt;/code&gt; 옵션</target>
        </trans-unit>
        <trans-unit id="fcc02e852676cd8c1162b2b42e5759f86fcae990" translate="yes" xml:space="preserve">
          <source>Options for Files</source>
          <target state="translated">파일 옵션</target>
        </trans-unit>
        <trans-unit id="fd6ce8b428a235dff74127968e45c8e950a3e68b" translate="yes" xml:space="preserve">
          <source>Options for Filtering</source>
          <target state="translated">필터링 옵션</target>
        </trans-unit>
        <trans-unit id="f0e43560a9524e814096613f5d3adbb780ab9547" translate="yes" xml:space="preserve">
          <source>Options for Frontends</source>
          <target state="translated">프론트 엔드 옵션</target>
        </trans-unit>
        <trans-unit id="6de07b5e7d3355f1ee784587e4e9b9310ce89167" translate="yes" xml:space="preserve">
          <source>Options for Objects</source>
          <target state="translated">객체 옵션</target>
        </trans-unit>
        <trans-unit id="7bba8ce1354b61b02f672f2468b0b0f0c600077c" translate="yes" xml:space="preserve">
          <source>Options for Output</source>
          <target state="translated">출력 옵션</target>
        </trans-unit>
        <trans-unit id="b8bceb2d83c081f4f5d71559b2d0f07edc9ee034" translate="yes" xml:space="preserve">
          <source>Options for a credential context can be configured either in &lt;code&gt;credential.*&lt;/code&gt; (which applies to all credentials), or &lt;code&gt;credential.&amp;lt;url&amp;gt;.*&lt;/code&gt;, where &amp;lt;url&amp;gt; matches the context as described above.</source>
          <target state="translated">자격 증명 컨텍스트에 대한 옵션은 &lt;code&gt;credential.*&lt;/code&gt; (모든 자격 증명에 적용됨) 또는 &lt;code&gt;credential.&amp;lt;url&amp;gt;.*&lt;/code&gt; 에서 구성 할 수 있습니다 . 여기서 &amp;lt;url&amp;gt;은 위에서 설명한 컨텍스트와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="99e5139a65bfab6cb84777a431cb5c7403976793" translate="yes" xml:space="preserve">
          <source>Options related to fetching</source>
          <target state="translated">가져 오기 관련 옵션</target>
        </trans-unit>
        <trans-unit id="d96532d12a36cc4bb8cc0dcd0b87def47cb21823" translate="yes" xml:space="preserve">
          <source>Options related to merging</source>
          <target state="translated">병합 관련 옵션</target>
        </trans-unit>
        <trans-unit id="d2ce95980d5d4dcb8790725834688357cc504679" translate="yes" xml:space="preserve">
          <source>Options with long option names can be negated by prefixing &lt;code&gt;--no-&lt;/code&gt;. For example, &lt;code&gt;git branch&lt;/code&gt; has the option &lt;code&gt;--track&lt;/code&gt; which is &lt;code&gt;on&lt;/code&gt; by default. You can use &lt;code&gt;--no-track&lt;/code&gt; to override that behaviour. The same goes for &lt;code&gt;--color&lt;/code&gt; and &lt;code&gt;--no-color&lt;/code&gt;.</source>
          <target state="translated">접두어 &lt;code&gt;--no-&lt;/code&gt; 를 사용하여 옵션 이름이 긴 옵션은 무시할 수 있습니다 . 예를 들어, &lt;code&gt;git branch&lt;/code&gt; 에는 &lt;code&gt;--track&lt;/code&gt; 옵션 이 &lt;code&gt;on&lt;/code&gt; 기본적으로 켜져 있습니다. &lt;code&gt;--no-track&lt;/code&gt; 을 사용 하여 해당 동작을 재정의 할 수 있습니다. &lt;code&gt;--color&lt;/code&gt; 및 &lt;code&gt;--no-color&lt;/code&gt; 도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="28e5f716aa8e690cf7323a0d5515626aac785807" translate="yes" xml:space="preserve">
          <source>Or if you are looking for the commit that fixed a bug, you might use</source>
          <target state="translated">또는 버그를 수정 한 커밋을 찾고 있다면</target>
        </trans-unit>
        <trans-unit id="9bcee5b07c3eb51996fe06466cb572259d48e74e" translate="yes" xml:space="preserve">
          <source>Or if you want more control, you can inspect the current state using for example &quot;git bisect visualize&quot;. It will launch gitk (or &quot;git log&quot; if the &lt;code&gt;DISPLAY&lt;/code&gt; environment variable is not set) to help you find a better bisection point.</source>
          <target state="translated">또는 더 많은 제어를 원하면 &quot;git bisect visualize&quot;를 사용하여 현재 상태를 검사 할 수 있습니다. 더 나은이 분점을 찾는 데 도움이되도록 gitk (또는 &lt;code&gt;DISPLAY&lt;/code&gt; 환경 변수가 설정되지 않은 경우 &quot;git log&quot; )를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="ee046ba1657a42f0c8096ff30555d679415a486a" translate="yes" xml:space="preserve">
          <source>Or you could recall that the &lt;code&gt;&amp;hellip;​&lt;/code&gt; operator selects all commits reachable from either one reference or the other but not both; so</source>
          <target state="translated">아니면 리콜 할 수 &lt;code&gt;&amp;hellip;​&lt;/code&gt; 모든 커밋이 중 하나의 참조 또는 다른 있지만 둘 모두에서 접근 운영자가 선택; 그래서</target>
        </trans-unit>
        <trans-unit id="9af1a9bbcb80d3a49080e3a67d92d5ab7f0cace1" translate="yes" xml:space="preserve">
          <source>Or you could recall that the &lt;code&gt;...&lt;/code&gt; operator selects all commits reachable from either one reference or the other but not both; so</source>
          <target state="translated">또는 &lt;code&gt;...&lt;/code&gt; 연산자가 하나의 참조 또는 다른 참조에서 도달 할 수있는 모든 커밋을 선택하지만 둘다는 아닙니다. 그래서</target>
        </trans-unit>
        <trans-unit id="d85642c3d553b535f4731e23589126805881407c" translate="yes" xml:space="preserve">
          <source>Or, if you&amp;rsquo;ve already committed the merge that you want to throw away,</source>
          <target state="translated">또는 버리고 싶은 병합을 이미 커밋 한 경우</target>
        </trans-unit>
        <trans-unit id="7ec7c556c34b1673fc7046a255bf7eb40c6a1622" translate="yes" xml:space="preserve">
          <source>Or, prepare and create the commit in one step:</source>
          <target state="translated">또는 한 단계로 커밋을 준비하고 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6d9770079506b18bb9154a95e976f54ab47a2b44" translate="yes" xml:space="preserve">
          <source>Ordinary changed entries have the following format:</source>
          <target state="translated">일반적으로 변경된 항목의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="789d55cf79d409acbcc0305ff19dbfa36d82a93d" translate="yes" xml:space="preserve">
          <source>Ordinary commits are only included if they are !TREESAME (though this can be changed, see &lt;code&gt;--sparse&lt;/code&gt; below).</source>
          <target state="translated">일반 커밋은! TREESAME 인 경우에만 포함됩니다 (이는 변경할 수 있지만 아래의 &lt;code&gt;--sparse&lt;/code&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="3b945495727bab8a02c63542fdf26a485a2839f4" translate="yes" xml:space="preserve">
          <source>Original (version 1) pack-*.idx files have the following format:</source>
          <target state="translated">원본 (버전 1) pack-*. idx 파일의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd07568ac3f8fe8b9f1ca323e6aea33ce69f4d0c" translate="yes" xml:space="preserve">
          <source>Originally, &lt;code&gt;git svn&lt;/code&gt; recommended that developers pulled or merged from the &lt;code&gt;git svn&lt;/code&gt; branch. This was because the author favored &lt;code&gt;git svn set-tree B&lt;/code&gt; to commit a single head rather than the &lt;code&gt;git svn set-tree A..B&lt;/code&gt; notation to commit multiple commits. Use of &lt;code&gt;git pull&lt;/code&gt; or &lt;code&gt;git merge&lt;/code&gt; with &lt;code&gt;git svn set-tree A..B&lt;/code&gt; will cause non-linear history to be flattened when committing into SVN and this can lead to merge commits unexpectedly reversing previous commits in SVN.</source>
          <target state="translated">원래 &lt;code&gt;git svn&lt;/code&gt; 은 개발자가 &lt;code&gt;git svn&lt;/code&gt; 브랜치를 가져 오거나 병합 할 것을 권장했습니다 . 저자 가 여러 커밋을 커밋하기 위해 &lt;code&gt;git svn set-tree B&lt;/code&gt; 대신 &lt;code&gt;git svn set-tree A..B&lt;/code&gt; 표기법 대신 단일 헤드를 커밋하는 것을 선호했기 때문 입니다. 이용 &lt;code&gt;git pull&lt;/code&gt; 또는 &lt;code&gt;git merge&lt;/code&gt; 와 &lt;code&gt;git svn set-tree A..B&lt;/code&gt; SVN에 커밋 할 때 비선형 역사는 평평하게되도록하고이 병합 커밋이 예기치 않게 SVN에서 이전 커밋을 반전으로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="14bc34cb5d8d9f5a1986c4b4ced74a089ed31e83" translate="yes" xml:space="preserve">
          <source>Other &amp;lt;rev&amp;gt;^ Parent Shorthand Notations</source>
          <target state="translated">다른 &amp;lt;rev&amp;gt; ^ 부모 속기 표기법</target>
        </trans-unit>
        <trans-unit id="a3c040aeed88ddd482d5dec178bd5bb0b940738f" translate="yes" xml:space="preserve">
          <source>Other Items</source>
          <target state="translated">다른 물건들</target>
        </trans-unit>
        <trans-unit id="9cb6f2fb01dfa81e12bc1e11f0e7b676e54669fd" translate="yes" xml:space="preserve">
          <source>Other Options</source>
          <target state="translated">다른 옵션</target>
        </trans-unit>
        <trans-unit id="b66b145fc26fc91268f852efc133debcedca1335" translate="yes" xml:space="preserve">
          <source>Other ambiguity resolutions might be added in the future, but for now any other cases will error out with an error indicating what we tried, and depending on the &lt;code&gt;advice.pushUnqualifiedRefname&lt;/code&gt; configuration (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) suggest what refs/ namespace you may have wanted to push to.</source>
          <target state="translated">나중에 다른 모호한 해결 방법이 추가 될 수 있지만 지금은 다른 시도가 시도한 내용을 나타내는 오류와 함께 &lt;code&gt;advice.pushUnqualifiedRefname&lt;/code&gt; 을 제공합니다 .pushUnqualifiedRefname 구성 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ) 제안 / 네임 스페이스 제안 추진하고 싶었을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d7c9916d5a97cfdd8b058afc3d1bac1c0a81b1f" translate="yes" xml:space="preserve">
          <source>Other arbitrary characters can also be encoded. For instance, &lt;code&gt;combine:tree:3+blob:none&lt;/code&gt; and &lt;code&gt;combine:tree%3A3+blob%3Anone&lt;/code&gt; are equivalent.</source>
          <target state="translated">다른 임의의 문자도 인코딩 할 수 있습니다. 예를 들어, &lt;code&gt;combine:tree:3+blob:none&lt;/code&gt; 과 &lt;code&gt;combine:tree%3A3+blob%3Anone&lt;/code&gt; 은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fca088ce123c6c3692799642c2a4b46b5050ca1e" translate="yes" xml:space="preserve">
          <source>Other consecutive asterisks are considered invalid.</source>
          <target state="translated">다른 연속적인 별표는 유효하지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="060f4f2bc2ee9b99f69af6360a0055db64443a39" translate="yes" xml:space="preserve">
          <source>Other consecutive asterisks are considered regular asterisks and will match according to the previous rules.</source>
          <target state="translated">다른 별표는 일반 별표로 간주되며 이전 규칙에 따라 일치합니다.</target>
        </trans-unit>
        <trans-unit id="3c7b99f717eee9f16429ca9a79551f060c8f8236" translate="yes" xml:space="preserve">
          <source>Other diff formats</source>
          <target state="translated">다른 diff 형식</target>
        </trans-unit>
        <trans-unit id="81458045196e38ce4846b13cecf95d14abe58433" translate="yes" xml:space="preserve">
          <source>Other git-related tools may and do use their own variables. When inventing new variables for use in your own tool, make sure their names do not conflict with those that are used by Git itself and other popular tools, and describe them in your documentation.</source>
          <target state="translated">다른 자식 관련 도구는 자체 변수를 사용할 수 있습니다. 자체 도구에서 사용할 새 변수를 발명 할 때 해당 변수 이름이 Git 자체 및 기타 널리 사용되는 도구에서 사용되는 변수와 충돌하지 않도록하고 설명서에 설명하십시오.</target>
        </trans-unit>
        <trans-unit id="97855915001e4fe7ef5deb1c023c4697931e633c" translate="yes" xml:space="preserve">
          <source>Other options are available to control how the manual page is displayed. See &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt; for more information, because &lt;code&gt;git --help ...&lt;/code&gt; is converted internally into &lt;code&gt;git
help ...&lt;/code&gt;.</source>
          <target state="translated">매뉴얼 페이지가 표시되는 방법을 제어하기 위해 다른 옵션을 사용할 수 있습니다. &lt;code&gt;git --help ...&lt;/code&gt; 는 내부적으로 &lt;code&gt;git help ...&lt;/code&gt; 로 변환 되므로 자세한 내용 은 &lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9c8373137a028157f66c53c01b431d29c570146" translate="yes" xml:space="preserve">
          <source>Other tools</source>
          <target state="translated">다른 도구들</target>
        </trans-unit>
        <trans-unit id="89cbbb5c1b80969d7050a561dcd36c87c0241792" translate="yes" xml:space="preserve">
          <source>Other tools to fight regressions</source>
          <target state="translated">회귀와 싸우는 다른 도구</target>
        </trans-unit>
        <trans-unit id="15219db000aadb43433107a930098d54a12a2bf5" translate="yes" xml:space="preserve">
          <source>Other types of dangling objects (blobs and trees) are also possible, and dangling objects can arise in other situations.</source>
          <target state="translated">다른 유형의 매달린 물체 (블롭과 나무)도 가능하며 매달린 물체는 다른 상황에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8ad1c87f168347a129392343ff35eecf4e32d0a" translate="yes" xml:space="preserve">
          <source>Other variables</source>
          <target state="translated">다른 변수들</target>
        </trans-unit>
        <trans-unit id="dd705eff4c453915d022538452adca45ea549424" translate="yes" xml:space="preserve">
          <source>Other ways</source>
          <target state="translated">다른 방법들</target>
        </trans-unit>
        <trans-unit id="cf96d288cbee7ebb53d0ff80a9f63e5beaf8b0b4" translate="yes" xml:space="preserve">
          <source>Otherwise the remote branch of the first refspec is merged.</source>
          <target state="translated">그렇지 않으면 첫 번째 참조 사양의 원격 분기가 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="32a9647b920b895ad400011726c72473bb775600" translate="yes" xml:space="preserve">
          <source>Otherwise, a tag reference that points directly at the given object (i.e., a lightweight tag) is created.</source>
          <target state="translated">그렇지 않으면 주어진 객체를 직접 가리키는 태그 참조 (즉, 가벼운 태그)가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4b4eb603a71c26301f006805965a2bb224fe1a8d" translate="yes" xml:space="preserve">
          <source>Otherwise, all you need to do is start &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt;; it will listen on port 9418. By default, it will allow access to any directory that looks like a Git directory and contains the magic file git-daemon-export-ok. Passing some directory paths as &lt;code&gt;git daemon&lt;/code&gt; arguments will further restrict the exports to those paths.</source>
          <target state="translated">그렇지 않으면 시작해야 할 것은 start &lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]&lt;/a&gt; ; 포트 9418에서 수신 대기합니다. 기본적으로 Git 디렉토리처럼 보이고 매직 파일 git-daemon-export-ok가 포함 된 모든 디렉토리에 액세스 할 수 있습니다. 일부 디렉토리 경로를 &lt;code&gt;git daemon&lt;/code&gt; 인수 로 전달 하면 내보내기가 해당 경로로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="83933e66c19657c277855328b7212d55be330b69" translate="yes" xml:space="preserve">
          <source>Otherwise, if the &lt;code&gt;SSH_ASKPASS&lt;/code&gt; environment variable is set, its value is used as above.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;SSH_ASKPASS&lt;/code&gt; 환경 변수가 설정되면 해당 값이 위와 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="06aca3f538987dd4baec5bd30c2c8ddce8b7736e" translate="yes" xml:space="preserve">
          <source>Otherwise, if the &lt;code&gt;core.askPass&lt;/code&gt; configuration variable is set, its value is used as above.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;core.askPass&lt;/code&gt; 구성 변수가 설정되면 해당 값이 위와 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3a26962584221262caf565e9653ff026d1f2d21a" translate="yes" xml:space="preserve">
          <source>Otherwise, if the helper string begins with an absolute path, the verbatim helper string becomes the command.</source>
          <target state="translated">그렇지 않고 도우미 문자열이 절대 경로로 시작하면 축어 도우미 문자열이 명령이됩니다.</target>
        </trans-unit>
        <trans-unit id="4215362e197715214628992e14b639b7a98dbd7a" translate="yes" xml:space="preserve">
          <source>Otherwise, show the index format.</source>
          <target state="translated">그렇지 않으면 색인 형식을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="1bddd3a0b4a752779f115c3518d3c2b277475b51" translate="yes" xml:space="preserve">
          <source>Otherwise, success is indicated the Unix way, i.e. by simply exiting with a zero exit status.</source>
          <target state="translated">그렇지 않으면 성공은 유닉스 방식으로 표시됩니다. 즉, 단순히 종료 상태 0으로 종료합니다.</target>
        </trans-unit>
        <trans-unit id="adf9fb3bc458cf17571d90a6a9fffeaa1b715a6a" translate="yes" xml:space="preserve">
          <source>Otherwise, the merge proceeds in the usual way.</source>
          <target state="translated">그렇지 않으면 일반적인 방법으로 병합이 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="682c927c4310cf70e63b7011c8ec332cb5444742" translate="yes" xml:space="preserve">
          <source>Otherwise, the string &quot;git credential-&quot; is prepended to the helper string, and the result becomes the command.</source>
          <target state="translated">그렇지 않으면 &quot;git credential-&quot;문자열이 도우미 문자열 앞에 추가되고 결과가 명령이됩니다.</target>
        </trans-unit>
        <trans-unit id="0d438a86f2545e54eff98d96612fdf5bccb833ed" translate="yes" xml:space="preserve">
          <source>Otherwise, the topic that was merged to suddenly contains more than a single (well-separated) change. The many resulting small merges will greatly clutter up history. Anyone who later investigates the history of a file will have to find out whether that merge affected the topic in development. An upstream might even inadvertently be merged into a &quot;more stable&quot; branch. And so on.</source>
          <target state="translated">그렇지 않으면 병합 된 주제에 갑자기 단일 (잘 분리 된) 변경 사항이 포함됩니다. 결과로 발생하는 많은 소규모 합병은 역사를 크게 어지럽 힙니다. 나중에 파일 히스토리를 조사하는 사람은 병합이 개발 주제에 영향을 주는지 여부를 찾아야합니다. 업스트림은 실수로 &quot;보다 안정적인&quot;브랜치로 병합 될 수도 있습니다. 등등.</target>
        </trans-unit>
        <trans-unit id="9aea25a9a0905a830a51359c1723b329df787dff" translate="yes" xml:space="preserve">
          <source>Otherwise, the user is prompted on the terminal.</source>
          <target state="translated">그렇지 않으면 터미널에 사용자에게 프롬프트가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="38c6fc8779b3b84c1e5bc6184edd3674dd536e89" translate="yes" xml:space="preserve">
          <source>Otherwise, this command applies the arguments passed using the &lt;code&gt;--trailer&lt;/code&gt; option, if any, to the commit message part of each input file. The result is emitted on the standard output.</source>
          <target state="translated">그렇지 않으면이 명령은 &lt;code&gt;--trailer&lt;/code&gt; 옵션을 사용하여 전달 된 인수 를 각 입력 파일의 커밋 메시지 부분에 적용합니다. 결과는 표준 출력에서 ​​방출됩니다.</target>
        </trans-unit>
        <trans-unit id="7befa93bf7555efa6c53836dd2ebb58604474c19" translate="yes" xml:space="preserve">
          <source>Otherwise, you need more information. How do you tell which version of the file has been lost?</source>
          <target state="translated">그렇지 않으면 추가 정보가 필요합니다. 어떤 버전의 파일이 손실되었는지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="bfba9983f4010a4e13ddf1f4da6c4d9462a74630" translate="yes" xml:space="preserve">
          <source>Output &quot;connectivity-ok&quot; if the received pack is self-contained and connected.</source>
          <target state="translated">수신 된 팩이 자체 포함되어 있고 연결된 경우 &quot;connectivity-ok&quot;를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="14d787baf83270b720015688dc1b0d825f139765" translate="yes" xml:space="preserve">
          <source>Output \0 instead of the character that normally follows a file name.</source>
          <target state="translated">일반적으로 파일 이름 뒤에 오는 문자 대신 \ 0을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="02b83bf95635a4c88bd0634054e0b05541ae55d4" translate="yes" xml:space="preserve">
          <source>Output a condensed summary of extended header information such as creations, renames and mode changes.</source>
          <target state="translated">생성, 이름 변경 및 모드 변경과 같은 확장 된 헤더 정보의 요약 요약을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="6dbea2796f7c2da05dc872fbc20cb3b286f106fd" translate="yes" xml:space="preserve">
          <source>Output a condensed summary of extended header information such as file creations or deletions (&quot;new&quot; or &quot;gone&quot;, optionally &quot;+l&quot; if it&amp;rsquo;s a symlink) and mode changes (&quot;+x&quot; or &quot;-x&quot; for adding or removing executable bit respectively) in diffstat. The information is put between the filename part and the graph part. Implies &lt;code&gt;--stat&lt;/code&gt;.</source>
          <target state="translated">파일 생성 또는 삭제 ( &quot;new&quot;또는 &quot;gone&quot;, 선택적으로 symlink 인 경우 &quot;+ l&quot;) 및 추가 또는 제거를위한 모드 변경 ( &quot;+ x&quot;또는 &quot;-x&quot;)과 같은 확장 된 헤더 정보 요약 요약 출력 diffstat에서 각각 실행 비트). 정보는 파일 이름 부분과 그래프 부분 사이에 있습니다. &lt;code&gt;--stat&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="86b8e4f6e5044ecf1fc221aacfd89b826aa45a4b" translate="yes" xml:space="preserve">
          <source>Output all merge bases for the commits, instead of just one.</source>
          <target state="translated">커밋에 대한 모든 병합 기반을 하나 대신 출력하십시오.</target>
        </trans-unit>
        <trans-unit id="c4fd496863f1ea4adcfb9e1e5209189d8bcbae5b" translate="yes" xml:space="preserve">
          <source>Output an all-zero hash in each patch&amp;rsquo;s From header instead of the hash of the commit.</source>
          <target state="translated">커밋의 해시 대신 각 패치의 From 헤더에 모두 0의 해시를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="646a42919af7ad3c76023f798af12df793449561" translate="yes" xml:space="preserve">
          <source>Output diff in reverse.</source>
          <target state="translated">반대로 diff를 출력하십시오.</target>
        </trans-unit>
        <trans-unit id="973b33dc2cc053fd8a3739d3b278f90232b34e64" translate="yes" xml:space="preserve">
          <source>Output excluded boundary commits. Boundary commits are prefixed with &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">제외 된 경계 커밋 출력. 경계 커밋 앞에 &lt;code&gt;-&lt;/code&gt; 가 붙습니다 .</target>
        </trans-unit>
        <trans-unit id="c3872ebaf63738dccf26222059fb06a34ea9a53d" translate="yes" xml:space="preserve">
          <source>Output file names will be a simple number sequence without the default first line of the commit appended.</source>
          <target state="translated">출력 파일 이름은 커밋의 기본 첫 줄이 추가되지 않은 간단한 숫자 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="c03f08a8f205e4568e916e3cfaa50c6a48749706" translate="yes" xml:space="preserve">
          <source>Output format</source>
          <target state="translated">출력 형식</target>
        </trans-unit>
        <trans-unit id="d018168db6adc860beb206930bf9272bcf4432cb" translate="yes" xml:space="preserve">
          <source>Output from &lt;code&gt;git describe&lt;/code&gt;; i.e. a closest tag, optionally followed by a dash and a number of commits, followed by a dash, a &lt;code&gt;g&lt;/code&gt;, and an abbreviated object name.</source>
          <target state="translated">&lt;code&gt;git describe&lt;/code&gt; 출력 설명 ; 즉, 가장 가까운 태그, 선택적으로 대시와 여러 커밋, 대시, &lt;code&gt;g&lt;/code&gt; 및 축약 된 객체 이름이 뒤 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="57be6fd315ed7958a6a11b416634cb9af54c1202" translate="yes" xml:space="preserve">
          <source>Output information on each ref</source>
          <target state="translated">각 심판에 대한 출력 정보</target>
        </trans-unit>
        <trans-unit id="a471d58e2fcbf4f373e5dd800df97d7ecddc4b2a" translate="yes" xml:space="preserve">
          <source>Output only the last line of the &lt;code&gt;--stat&lt;/code&gt; format containing total number of modified files, as well as number of added and deleted lines.</source>
          <target state="translated">총 수정 된 파일 수와 추가 및 삭제 된 행 수를 포함 하는 &lt;code&gt;--stat&lt;/code&gt; 형식 의 마지막 행만 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="09afa8b7712ce7db5d67e850045b13df59d4e1ae" translate="yes" xml:space="preserve">
          <source>Output only the names of config variables for &lt;code&gt;--list&lt;/code&gt; or &lt;code&gt;--get-regexp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--list&lt;/code&gt; 또는 &lt;code&gt;--get-regexp&lt;/code&gt; 에 대한 구성 변수 이름 만 출력하십시오 .</target>
        </trans-unit>
        <trans-unit id="86aa1f4dbf3c69df52c4dcdcb3513ddaac888349" translate="yes" xml:space="preserve">
          <source>Output only the trailers, not any other parts of the input.</source>
          <target state="translated">입력의 다른 부분이 아닌 트레일러 만 출력하십시오.</target>
        </trans-unit>
        <trans-unit id="db37f07e7f23e51cc792b3b6ff625f7fbb6a099c" translate="yes" xml:space="preserve">
          <source>Output only trailers that exist in the input; do not add any from the command-line or by following configured &lt;code&gt;trailer.*&lt;/code&gt; rules.</source>
          <target state="translated">입력에 존재하는 트레일러 만 출력합니다. 명령 줄이나 구성한 &lt;code&gt;trailer.*&lt;/code&gt; 규칙 에 따라 추가하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="9f94a54620a30e7ce03e12a657369e604dddd0ea" translate="yes" xml:space="preserve">
          <source>Output stability</source>
          <target state="translated">출력 안정성</target>
        </trans-unit>
        <trans-unit id="eec068e91917644b4f85137aa6730536687188c8" translate="yes" xml:space="preserve">
          <source>Output the commits chosen to be shown (see Commit Limiting section above) in reverse order. Cannot be combined with &lt;code&gt;--walk-reflogs&lt;/code&gt;.</source>
          <target state="translated">표시되도록 선택된 커밋을 역순으로 출력합니다 (위의 커밋 제한 섹션 참조). &lt;code&gt;--walk-reflogs&lt;/code&gt; 와 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b5f16fa854dad4b03b2649c62b3407ce506ca41f" translate="yes" xml:space="preserve">
          <source>Output the distribution of relative amount of changes for each sub-directory. The behavior of &lt;code&gt;--dirstat&lt;/code&gt; can be customized by passing it a comma separated list of parameters. The defaults are controlled by the &lt;code&gt;diff.dirstat&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). The following parameters are available:</source>
          <target state="translated">각 하위 디렉토리에 대한 상대적 변경 량의 분포를 출력합니다. &lt;code&gt;--dirstat&lt;/code&gt; 의 동작은 쉼표로 구분 된 매개 변수 목록을 전달하여 사용자 정의 할 수 있습니다. 기본값은 &lt;code&gt;diff.dirstat&lt;/code&gt; 구성 변수에 의해 제어됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ). 다음과 같은 파라미터를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f44ba9d91e7de35dadf965ce7b9f83b740777703" translate="yes" xml:space="preserve">
          <source>Output to a specific file instead of stdout.</source>
          <target state="translated">stdout 대신 특정 파일로 출력합니다.</target>
        </trans-unit>
        <trans-unit id="1374322e99ee5a882a272ee284ec9ea86e209683" translate="yes" xml:space="preserve">
          <source>Output uses the same format as &lt;code&gt;git cat-file --batch&lt;/code&gt;:</source>
          <target state="translated">출력은 &lt;code&gt;git cat-file --batch&lt;/code&gt; 와 동일한 형식을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="50880c18d623e2367f83a87791b3da910b72fa81" translate="yes" xml:space="preserve">
          <source>Output uses the same format as &lt;code&gt;git ls-tree &amp;lt;tree&amp;gt; -- &amp;lt;path&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">출력은 &lt;code&gt;git ls-tree &amp;lt;tree&amp;gt; -- &amp;lt;path&amp;gt;&lt;/code&gt; 와 동일한 형식을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="12aec147318e848c7d54969418eb1ab7603e65c0" translate="yes" xml:space="preserve">
          <source>Outputs some statistics to stderr. Has a small performance penalty.</source>
          <target state="translated">일부 통계를 stderr에 출력합니다. 성능 저하가 적습니다.</target>
        </trans-unit>
        <trans-unit id="bb044abda9deb6fdc3e0634ed0f85ce258bcc5dc" translate="yes" xml:space="preserve">
          <source>Outputs the SHA1 of every commit in &lt;code&gt;&amp;lt;limit&amp;gt;..&amp;lt;head&amp;gt;&lt;/code&gt;, prefixed with &lt;code&gt;-&lt;/code&gt; for commits that have an equivalent in &amp;lt;upstream&amp;gt;, and &lt;code&gt;+&lt;/code&gt; for commits that do not.</source>
          <target state="translated">모든의 SHA1이 커밋 출력 &lt;code&gt;&amp;lt;limit&amp;gt;..&amp;lt;head&amp;gt;&lt;/code&gt; , 접두사 &lt;code&gt;-&lt;/code&gt; &amp;lt;업스트림&amp;gt;에 해당하는이 커밋을 위해, 그리고 &lt;code&gt;+&lt;/code&gt; 하지 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="27115802f1c296a1dfb4ce768084e3e086e70c8c" translate="yes" xml:space="preserve">
          <source>Override &lt;code&gt;tag.gpgSign&lt;/code&gt; configuration variable that is set to force each and every tag to be signed.</source>
          <target state="translated">각각의 모든 태그에 서명하도록 설정된 &lt;code&gt;tag.gpgSign&lt;/code&gt; 구성 변수를 재정의 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f98c38feba04de33a87daf02cddb4bc0af45f925" translate="yes" xml:space="preserve">
          <source>Override earlier --rebase.</source>
          <target state="translated">이전 --rebase를 재정의하십시오.</target>
        </trans-unit>
        <trans-unit id="bf7cdfd38925dba890e8c6c44d76b710ca912a26" translate="yes" xml:space="preserve">
          <source>Override the HTTP proxy, normally configured using the &lt;code&gt;http_proxy&lt;/code&gt;, &lt;code&gt;https_proxy&lt;/code&gt;, and &lt;code&gt;all_proxy&lt;/code&gt; environment variables (see &lt;code&gt;curl(1)&lt;/code&gt;). In addition to the syntax understood by curl, it is possible to specify a proxy string with a user name but no password, in which case git will attempt to acquire one in the same way it does for other credentials. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for more information. The syntax thus is &lt;code&gt;[protocol://][user[:password]@]proxyhost[:port]&lt;/code&gt;. This can be overridden on a per-remote basis; see remote.&amp;lt;name&amp;gt;.proxy</source>
          <target state="translated">일반적으로 &lt;code&gt;http_proxy&lt;/code&gt; , &lt;code&gt;https_proxy&lt;/code&gt; 및 &lt;code&gt;all_proxy&lt;/code&gt; 환경 변수를 사용하여 구성된 HTTP 프록시를 대체 하십시오 ( &lt;code&gt;curl(1)&lt;/code&gt; 참조 ). curl이 이해하는 구문 외에도 사용자 이름은 있지만 암호는없는 프록시 문자열을 지정할 수 있습니다.이 경우 git은 다른 자격 증명과 동일한 방식으로 문자열을 획득하려고 시도합니다. 자세한 내용은 &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt; 를 참조하십시오. 따라서 구문은 &lt;code&gt;[protocol://][user[:password]@]proxyhost[:port]&lt;/code&gt; 입니다. 원격으로이를 무시할 수 있습니다. remote. &amp;lt;name&amp;gt; .proxy를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca2a7d0ade908f47d0a242141742817435033d82" translate="yes" xml:space="preserve">
          <source>Override the author date used in the commit.</source>
          <target state="translated">커밋에 사용 된 작성자 날짜를 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="afbb46ef37a88110fa3c814b4440b9bab3c588ca" translate="yes" xml:space="preserve">
          <source>Override the commit author. Specify an explicit author using the standard &lt;code&gt;A U Thor &amp;lt;author@example.com&amp;gt;&lt;/code&gt; format. Otherwise &amp;lt;author&amp;gt; is assumed to be a pattern and is used to search for an existing commit by that author (i.e. rev-list --all -i --author=&amp;lt;author&amp;gt;); the commit author is then copied from the first such commit found.</source>
          <target state="translated">커밋 작성자를 재정의합니다. 표준 &lt;code&gt;A U Thor &amp;lt;author@example.com&amp;gt;&lt;/code&gt; 형식을 사용하여 명시 적 작성자를 지정하십시오 . 그렇지 않으면 &amp;lt;author&amp;gt;는 패턴으로 간주되며 해당 작성자가 기존 커밋을 검색하는 데 사용됩니다 (예 : rev-list --all -i --author = &amp;lt;author&amp;gt;). 그런 다음 커밋 작성자는 처음 발견 된 커밋에서 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="e3aa6564c96bc2c1fa2d64bc52314ce125c2e1b2" translate="yes" xml:space="preserve">
          <source>Override the default help format used by &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;. Values &lt;code&gt;man&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;web&lt;/code&gt; and &lt;code&gt;html&lt;/code&gt; are supported. &lt;code&gt;man&lt;/code&gt; is the default. &lt;code&gt;web&lt;/code&gt; and &lt;code&gt;html&lt;/code&gt; are the same.</source>
          <target state="translated">&lt;a href=&quot;git-help&quot;&gt;git-help [1]에서&lt;/a&gt; 사용하는 기본 도움말 형식을 재정의하십시오 . 값 &lt;code&gt;man&lt;/code&gt; , &lt;code&gt;info&lt;/code&gt; , &lt;code&gt;web&lt;/code&gt; 및 &lt;code&gt;html&lt;/code&gt; 지원됩니다. &lt;code&gt;man&lt;/code&gt; 이 기본값입니다. &lt;code&gt;web&lt;/code&gt; 과 &lt;code&gt;html&lt;/code&gt; 은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="90af133b98db5fc195076e23392ec3cd67c3e89c" translate="yes" xml:space="preserve">
          <source>Override the default tempdir.</source>
          <target state="translated">기본 tempdir을 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="5b51681506c224a8c47f1343a9ecd64433151e38" translate="yes" xml:space="preserve">
          <source>Override the executable bit of the added files. The executable bit is only changed in the index, the files on disk are left unchanged.</source>
          <target state="translated">추가 된 파일의 실행 비트를 무시하십시오. 실행 비트는 인덱스에서만 변경되고 디스크의 파일은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2478241e90c06d40d8344e2c734cc9e34ffd0d73" translate="yes" xml:space="preserve">
          <source>Override the path for the given tool that may be used to browse HTML help (see &lt;code&gt;-w&lt;/code&gt; option in &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;) or a working repository in gitweb (see &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;).</source>
          <target state="translated">HTML 도움말 ( &lt;a href=&quot;git-help&quot;&gt;git-help [1]의 &lt;/a&gt; &lt;code&gt;-w&lt;/code&gt; 옵션 참조 ) 또는 gitweb의 작업 저장소 ( &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt; 참조) 를 탐색하는 데 사용할 수있는 지정된 도구의 경로를 대체하십시오 .</target>
        </trans-unit>
        <trans-unit id="eeb1b59c781a411c8a2ade9041a0a224d6888a83" translate="yes" xml:space="preserve">
          <source>Override the path for the given tool that may be used to display help in the &lt;code&gt;man&lt;/code&gt; format. See &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;man&lt;/code&gt; 형식으로 도움말을 표시하는 데 사용될 수있는 주어진 도구의 경로를 대체하십시오 . &lt;a href=&quot;git-help&quot;&gt;git-help [1]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="adf75a51b2ad5d1ae80303fa7c85676af23cae71" translate="yes" xml:space="preserve">
          <source>Override the path for the given tool. This is useful in case your tool is not in the PATH.</source>
          <target state="translated">주어진 도구의 경로를 무시하십시오. 도구가 PATH에없는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d7b3947bcc6a75423b4dad1a16da833c821be77f" translate="yes" xml:space="preserve">
          <source>Override the up-to-date check.</source>
          <target state="translated">최신 확인을 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="4f22a960f4dfa712696d5fbbb0afb1a8a1360ea3" translate="yes" xml:space="preserve">
          <source>Overrides a previous &lt;code&gt;--no-walk&lt;/code&gt;.</source>
          <target state="translated">이전 &lt;code&gt;--no-walk&lt;/code&gt; 를 재정의합니다 .</target>
        </trans-unit>
        <trans-unit id="dcd0bd07179d4dab7adf6735a6d8e2d1ef6bb9e3" translate="yes" xml:space="preserve">
          <source>Overwrite the contents of the files that match the pathspec. When the &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (most often a commit) is not given, overwrite working tree with the contents in the index. When the &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; is given, overwrite both the index and the working tree with the contents at the &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">pathspec과 일치하는 파일의 내용을 덮어 씁니다. 때 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (가장 자주 커밋) 인덱스의 내용으로, 덮어 쓰기 작업 트리를 부여하지 않습니다. 때 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 주어진다, 인덱스 및 상기 내용으로 작업 트리를 모두 덮어 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdd66a641be22e4e3d7b30653f72f1e5443e834b" translate="yes" xml:space="preserve">
          <source>P4 does not have the same concept of a branch as Git. Instead, p4 organizes its content as a directory tree, where by convention different logical branches are in different locations in the tree. The &lt;code&gt;p4 branch&lt;/code&gt; command is used to maintain mappings between different areas in the tree, and indicate related content. &lt;code&gt;git p4&lt;/code&gt; can use these mappings to determine branch relationships.</source>
          <target state="translated">P4는 Git과 같은 브랜치 개념이 없습니다. 대신 p4는 내용을 디렉토리 트리로 구성합니다. 여기서 규칙에 따라 다른 논리적 분기가 트리의 다른 위치에 있습니다. &lt;code&gt;p4 branch&lt;/code&gt; 명령은 트리에서 서로 다른 영역 간의 매핑을 유지하는 데 사용하고, 관련 콘텐츠를 표시합니다. &lt;code&gt;git p4&lt;/code&gt; 는 이러한 매핑을 사용하여 분기 관계를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c377e9687b993a1d0b2786f798f75e99668d5825" translate="yes" xml:space="preserve">
          <source>P4 repositories can be added to an existing Git repository using &lt;code&gt;git p4 sync&lt;/code&gt; too:</source>
          <target state="translated">&lt;code&gt;git p4 sync&lt;/code&gt; 를 사용하여 P4 리포지토리를 기존 Git 리포지토리에 추가 할 수 있습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
