<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="7f65f9810b42bc29820c9b18c26064984a955e8e" translate="yes" xml:space="preserve">
          <source>As with the case to record your own changes, you can use &lt;code&gt;-a&lt;/code&gt; option to save typing. One difference is that during a merge resolution, you cannot use &lt;code&gt;git commit&lt;/code&gt; with pathnames to alter the order the changes are committed, because the merge should be recorded as a single commit. In fact, the command refuses to run when given pathnames (but see &lt;code&gt;-i&lt;/code&gt; option).</source>
          <target state="translated">자신의 변경 사항을 기록하는 경우와 마찬가지로 &lt;code&gt;-a&lt;/code&gt; 옵션을 사용하여 입력 내용을 저장할 수 있습니다 . 한 가지 차이점은 병합이 해결되는 동안 병합이 단일 커밋으로 기록되어야하므로 경로 이름과 함께 &lt;code&gt;git commit&lt;/code&gt; 을 사용 하여 변경 사항이 커밋 된 순서를 변경할 수 없다는 것 입니다. 실제로는 경로 이름이 주어지면 명령 실행을 거부합니다 (그러나 &lt;code&gt;-i&lt;/code&gt; 옵션 참조 ).</target>
        </trans-unit>
        <trans-unit id="b22aaf02415c185eaf98c36bda4bb6f6375b4276" translate="yes" xml:space="preserve">
          <source>As yet another alternative, the &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt; command lists the commits reachable from its arguments with a display on the left-hand side that indicates which arguments that commit is reachable from. So, if you run something like</source>
          <target state="translated">또 다른 대안으로, &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt; 명령은 인수에서 도달 할 수있는 커밋을 왼쪽에 표시하여 커밋에 도달 할 수있는 인수를 표시합니다. 그래서, 당신이 같은 것을 실행하면</target>
        </trans-unit>
        <trans-unit id="ab55ac3413eea0cf585d324d891a90eb1c44a9c7" translate="yes" xml:space="preserve">
          <source>As you can see, a commit is defined by:</source>
          <target state="translated">보시다시피 커밋은 다음에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="6777c5e47b1bbdf59716ff3b0a0a681c16313dcb" translate="yes" xml:space="preserve">
          <source>As you can see, a commit shows who made the latest change, what they did, and why.</source>
          <target state="translated">보시다시피, 커밋은 누가 최근에 변경 한 사항, 수행 한 작업 및 이유를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a0f1d03e1580f855020045fffe8e5647f3b9c420" translate="yes" xml:space="preserve">
          <source>As you can see, a tree object contains a list of entries, each with a mode, object type, SHA-1 name, and name, sorted by name. It represents the contents of a single directory tree.</source>
          <target state="translated">보시다시피 트리 개체에는 각 모드, 개체 유형, SHA-1 이름 및 이름을 가진 항목 목록이 이름별로 정렬되어 있습니다. 단일 디렉토리 트리의 내용을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ec8afd8db14f6b2c4703101087783a19cada8ee5" translate="yes" xml:space="preserve">
          <source>As you can see, this tells us which branch we&amp;rsquo;re currently on, and it tells us this by naming a file under the .git directory, which itself contains a SHA-1 name referring to a commit object, which we can examine with cat-file:</source>
          <target state="translated">보시다시피, 이것은 현재 어떤 브랜치를 알려줍니다. 그리고 커밋 객체를 참조하는 SHA-1 이름을 포함하는 .git 디렉토리 아래에 파일의 이름을 지정하여 알려줍니다. 고양이 파일 :</target>
        </trans-unit>
        <trans-unit id="7345319011443769ac795138deb4faa77176b52c" translate="yes" xml:space="preserve">
          <source>Ask git-credential to give us a username and password for this description. This is done by running &lt;code&gt;git credential fill&lt;/code&gt;, feeding the description from step (1) to its standard input. The complete credential description (including the credential per se, i.e. the login and password) will be produced on standard output, like:</source>
          <target state="translated">git-credential에이 설명에 대한 사용자 이름과 비밀번호를 요청하십시오. 이것은 &lt;code&gt;git credential fill&lt;/code&gt; 을 실행 하여 단계 (1)의 설명을 표준 입력에 제공하여 수행됩니다. 자격 증명 자체 (즉, 자격 증명 자체, 즉 로그인 및 암호 포함)는 다음과 같은 표준 출력으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="353866df360a6151213ae26714b0b27ee93959c9" translate="yes" xml:space="preserve">
          <source>Ask the user to confirm that a patch set should actually be sent to SVN. For each patch, one may answer &quot;yes&quot; (accept this patch), &quot;no&quot; (discard this patch), &quot;all&quot; (accept all patches), or &quot;quit&quot;.</source>
          <target state="translated">사용자에게 패치 세트가 실제로 SVN으로 전송되어야하는지 확인하도록 요청하십시오. 각 패치에 대해 &quot;예&quot;(이 패치를 수락 함), &quot;아니오&quot;(이 패치를 폐기 함), &quot;모두&quot;(모든 패치를 수락 함) 또는 &quot;종료&quot;라고 대답 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74885a8f797e3dd4d74ed362a01fa5f6e719e159" translate="yes" xml:space="preserve">
          <source>Associating multiple Arch branches to one Git branch is possible; the result will make the most sense only if no commits are made to the first branch, after the second branch is created. Still, this is useful to convert Arch repositories that had been rotated periodically.</source>
          <target state="translated">여러 아치 브랜치를 하나의 Git 브랜치에 연결하는 것이 가능합니다. 결과는 두 번째 브랜치가 생성 된 후 첫 번째 브랜치에 대한 커밋이없는 경우에만 가장 의미가 있습니다. 그래도 주기적으로 회전 한 아치 리포지토리를 변환하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3fae130157899ed03a40dd2250aa34f89aff67c5" translate="yes" xml:space="preserve">
          <source>Assume the following history exists and the current branch is &quot;&lt;code&gt;master&lt;/code&gt;&quot;:</source>
          <target state="translated">다음 히스토리가 존재하고 현재 분기가 &quot; &lt;code&gt;master&lt;/code&gt; &quot;라고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="faa8cbaa5281b0af933b5133552cbab39bea906e" translate="yes" xml:space="preserve">
          <source>Assume the following history exists and the current branch is &quot;topic&quot;:</source>
          <target state="translated">다음 히스토리가 존재하고 현재 분기가 &quot;주제&quot;라고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="3cd2aff8a20d9db05868ff5d3b79174e0521391d" translate="yes" xml:space="preserve">
          <source>Assume the output looks like this:</source>
          <target state="translated">출력이 다음과 같다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="97613cb38d31b0bbed31ce68ca2dcace37e030ff" translate="yes" xml:space="preserve">
          <source>Assume you have a tarball project.tar.gz with your initial work. You can place it under Git revision control as follows.</source>
          <target state="translated">초기 작업에 tarball project.tar.gz가 있다고 가정하십시오. 다음과 같이 Git 개정 관리에 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="679231bf1096aa234d1b1628f62bacea198b2922" translate="yes" xml:space="preserve">
          <source>Assume you have local changes in &quot;master&quot;, but you need to refetch &quot;r2&quot;.</source>
          <target state="translated">&quot;master&quot;에 로컬 변경 사항이 있지만 &quot;r2&quot;를 다시 가져와야한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="be7f011565f1c258dd11dc44833bb09a98dcf45f" translate="yes" xml:space="preserve">
          <source>Assume you want to transfer the history from a repository R1 on machine A to another repository R2 on machine B. For whatever reason, direct connection between A and B is not allowed, but we can move data from A to B via some mechanism (CD, email, etc.). We want to update R2 with development made on the branch master in R1.</source>
          <target state="translated">머신 A의 저장소 R1에서 머신 B의 다른 저장소 R2로 히스토리를 전송한다고 가정하십시오. 어떤 이유로 든 A와 B 간의 직접 연결은 허용되지 않지만 일부 메커니즘 (CD를 통해 A에서 B로 데이터를 이동할 수 있음) , 이메일 등). R1의 브랜치 마스터에서 개발 한 R2를 업데이트하려고합니다.</target>
        </trans-unit>
        <trans-unit id="2183deafca588db3e5f3e1c7cf0d56a53d10c987" translate="yes" xml:space="preserve">
          <source>Assume your existing repo is at /home/alice/myproject. Create a new &quot;bare&quot; repository (a repository without a working tree) and fetch your project into it:</source>
          <target state="translated">기존 리포지토리가 / home / alice / myproject에 있다고 가정합니다. 새 &quot;베어&quot;저장소 (작업 트리가없는 저장소)를 작성하고 프로젝트를 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="28e522eb4dcb1a9410bd8273e0683d16ad9d1887" translate="yes" xml:space="preserve">
          <source>Assume your personal repository is in the directory &lt;code&gt;~/proj&lt;/code&gt;. We first create a new clone of the repository and tell &lt;code&gt;git daemon&lt;/code&gt; that it is meant to be public:</source>
          <target state="translated">개인 저장소가 &lt;code&gt;~/proj&lt;/code&gt; 디렉토리에 있다고 가정하십시오 . 먼저 저장소의 새 복제본을 만들고 &lt;code&gt;git daemon&lt;/code&gt; 에게 공개되어야 함을 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="2f08c00864cc26377518c6e9b880162905e8d349" translate="yes" xml:space="preserve">
          <source>Assuming that gitweb is installed to &lt;code&gt;/var/www/perl&lt;/code&gt;, the following Apache configuration (for mod_perl 2.x) is suitable.</source>
          <target state="translated">gitweb이 &lt;code&gt;/var/www/perl&lt;/code&gt; 에 설치되어 있다고 가정하면 다음 Apache 구성 (mod_perl 2.x의 경우)이 적합합니다.</target>
        </trans-unit>
        <trans-unit id="f21b72294adb0bdfa94f142e28bd7e66d94e6e2e" translate="yes" xml:space="preserve">
          <source>Assuming the submodule has a Git directory at &lt;code&gt;$GIT_DIR/modules/foo/&lt;/code&gt; and a working directory at &lt;code&gt;path/to/bar/&lt;/code&gt;, the superproject tracks the submodule via a &lt;code&gt;gitlink&lt;/code&gt; entry in the tree at &lt;code&gt;path/to/bar&lt;/code&gt; and an entry in its &lt;code&gt;.gitmodules&lt;/code&gt; file (see &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;) of the form &lt;code&gt;submodule.foo.path = path/to/bar&lt;/code&gt;.</source>
          <target state="translated">서브 모듈을 가정에서 힘내 디렉토리가 &lt;code&gt;$GIT_DIR/modules/foo/&lt;/code&gt; 과에서 작업 디렉토리 &lt;code&gt;path/to/bar/&lt;/code&gt; 의 superproject이를 통해 서브 모듈 추적 &lt;code&gt;gitlink&lt;/code&gt; 의 에서 트리에서 항목 &lt;code&gt;path/to/bar&lt;/code&gt; 과에 항목을 그 &lt;code&gt;.gitmodules&lt;/code&gt; 의 파일 (참조 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; ) 형식의 &lt;code&gt;submodule.foo.path = path/to/bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60da90e959e19c4160d1646a608d2bc5b787c602" translate="yes" xml:space="preserve">
          <source>Assuming you are using the merge approach discussed above, when you are releasing your project you will need to do some additional branch management work.</source>
          <target state="translated">위에서 설명한 병합 방법을 사용한다고 가정하면 프로젝트를 릴리스 할 때 몇 가지 추가 지점 관리 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="1388e5cd4892a287239160f51404821c63ca478d" translate="yes" xml:space="preserve">
          <source>At any point you can view the history of your changes using</source>
          <target state="translated">언제라도 다음을 사용하여 변경 기록을 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e40d41f48140a6f9c8ed7743f53a14cc49f4d4d6" translate="yes" xml:space="preserve">
          <source>At any point you may use the &lt;code&gt;--abort&lt;/code&gt; option to abort this process and return mywork to the state it had before you started the rebase:</source>
          <target state="translated">언제든지 &lt;code&gt;--abort&lt;/code&gt; 옵션을 사용 하여이 프로세스를 중단하고 rebase를 시작하기 전의 상태로 mywork 을 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21e6c111ed6dea301f6219c21f04088d951095f1" translate="yes" xml:space="preserve">
          <source>At any time, we can create a new commit using &lt;code&gt;git commit&lt;/code&gt; (without the &quot;-a&quot; option), and verify that the state committed only includes the changes stored in the index file, not the additional change that is still only in our working tree:</source>
          <target state="translated">언제든지, 우리는 &lt;code&gt;git commit&lt;/code&gt; commit을 사용하여 (-a 옵션없이) 새로운 커밋을 생성 할 수 있으며 커밋 된 상태가 인덱스 파일에 저장된 변경 사항 만 포함하는지 확인하십시오. 나무:</target>
        </trans-unit>
        <trans-unit id="c62227c162304e2658e4b654489602aed406e046" translate="yes" xml:space="preserve">
          <source>At the beginning, the content of the index will be identical to that of the HEAD. The command &lt;code&gt;git diff --cached&lt;/code&gt;, which shows the difference between the HEAD and the index, should therefore produce no output at that point.</source>
          <target state="translated">처음에는 색인의 내용이 HEAD의 내용과 동일합니다. 따라서 HEAD와 인덱스의 차이를 표시하는 &lt;code&gt;git diff --cached&lt;/code&gt; 명령 은 해당 시점에서 출력을 생성하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="8edc58a934b3ed21297a24f7c0434615621064c8" translate="yes" xml:space="preserve">
          <source>At this point the index file still has all the WIP changes you committed as &lt;code&gt;snapshot WIP&lt;/code&gt;. This updates the index to show your WIP files as uncommitted.</source>
          <target state="translated">이 시점에서 색인 파일에는 여전히 &lt;code&gt;snapshot WIP&lt;/code&gt; 로 커밋 한 모든 WIP 변경 사항이 있습니다 . 그러면 색인이 업데이트되어 WIP 파일이 커밋되지 않은 것으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6fb30ce8f93c559deaf24b4ad05d6dda3c1a1ac8" translate="yes" xml:space="preserve">
          <source>At this point there are basically 2 ways to drive the search. It can be driven manually by the user or it can be driven automatically by a script or a command.</source>
          <target state="translated">이 시점에서 기본적으로 검색을 수행하는 두 가지 방법이 있습니다. 사용자가 수동으로 구동하거나 스크립트 또는 명령으로 자동으로 구동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73d7e84e91592f3766bf21a35fce90d676b02b60" translate="yes" xml:space="preserve">
          <source>At this point we can see what the commit does, check it out (if it&amp;rsquo;s not already checked out) or tinker with it, for example:</source>
          <target state="translated">이 시점에서 커밋이 수행하는 작업을 확인하거나, 체크 아웃 (아직 체크 아웃되지 않은 경우) 확인하거나 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9821aa659e4d6623e87210d9f79f8fb8048ff5ce" translate="yes" xml:space="preserve">
          <source>At this point you could delete the experimental branch with</source>
          <target state="translated">이 시점에서 다음을 사용하여 실험 분기를 삭제할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9f18a8a14c3813ef07a4e4179ae90618a19f07d0" translate="yes" xml:space="preserve">
          <source>At this point you should know everything necessary to read the man pages for any of the git commands; one good place to start would be with the commands mentioned in &lt;a href=&quot;giteveryday&quot;&gt;giteveryday[7]&lt;/a&gt;. You should be able to find any unknown jargon in &lt;a href=&quot;gitglossary&quot;&gt;gitglossary[7]&lt;/a&gt;.</source>
          <target state="translated">이 시점에서 git 명령에 대한 매뉴얼 페이지를 읽는 데 필요한 모든 것을 알아야합니다. 시작하기 좋은 곳은 &lt;a href=&quot;giteveryday&quot;&gt;giteveryday [7]에&lt;/a&gt; 언급 된 명령을 사용하는 것 입니다. &lt;a href=&quot;gitglossary&quot;&gt;gitglossary [7]&lt;/a&gt; 에서 알 수없는 전문 용어를 찾을 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="870751f448af1f37fa82b626c9d940e8d540a997" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;git diff&lt;/code&gt; shows the changes cleanly merged as in the previous example, as well as the changes in the conflicted files. Edit and resolve the conflict and mark it resolved with &lt;code&gt;git add&lt;/code&gt; as usual:</source>
          <target state="translated">이 시점에서 &lt;code&gt;git diff&lt;/code&gt; 는 이전 예제와 같이 완전히 병합 된 변경 사항과 충돌 된 파일의 변경 사항을 보여줍니다. 충돌을 편집하고 해결하고 평소 와 같이 &lt;code&gt;git add&lt;/code&gt; 로 해결 표시하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c8e0f856e1b344e50a8f9f6370e6aeaf4be3455" translate="yes" xml:space="preserve">
          <source>At this point, you could use &lt;code&gt;pull&lt;/code&gt; to merge your changes back in; the result would create a new merge commit, like this:</source>
          <target state="translated">이 시점에서 &lt;code&gt;pull&lt;/code&gt; 을 사용 하여 변경 사항을 다시 병합 할 수 있습니다 . 결과는 다음과 같이 새 병합 커밋을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0cd76265a60d161772d69d7db5cee25c535ce122" translate="yes" xml:space="preserve">
          <source>At this time, the &lt;code&gt;merge&lt;/code&gt; command will &lt;strong&gt;always&lt;/strong&gt; use the &lt;code&gt;recursive&lt;/code&gt; merge strategy for regular merges, and &lt;code&gt;octopus&lt;/code&gt; for octopus merges, with no way to choose a different one. To work around this, an &lt;code&gt;exec&lt;/code&gt; command can be used to call &lt;code&gt;git merge&lt;/code&gt; explicitly, using the fact that the labels are worktree-local refs (the ref &lt;code&gt;refs/rewritten/onto&lt;/code&gt; would correspond to the label &lt;code&gt;onto&lt;/code&gt;, for example).</source>
          <target state="translated">이 때, &lt;code&gt;merge&lt;/code&gt; 명령을 것입니다 &lt;strong&gt;항상&lt;/strong&gt; 사용 &lt;code&gt;recursive&lt;/code&gt; 병합 규칙 병합에 대한 전략 및 &lt;code&gt;octopus&lt;/code&gt; 다른 하나를 선택 할 수있는 방법으로, 문어 병합에 대한합니다. 이 문제를 해결하기 위해, &lt;code&gt;exec&lt;/code&gt; 명령을 호출하는 데 사용할 수 &lt;code&gt;git merge&lt;/code&gt; 레이블이 worktree 로컬 심판이 있다는 사실을 사용하여 명시 적으로 (심판의 &lt;code&gt;refs/rewritten/onto&lt;/code&gt; 레이블에 해당하는 것 &lt;code&gt;onto&lt;/code&gt; 예를 들어,).</target>
        </trans-unit>
        <trans-unit id="c05aeaaa9fcd28f51dfdd6a6420e663787cde8e1" translate="yes" xml:space="preserve">
          <source>Attempt authentication without seeking a username or password. This can be used to attempt GSS-Negotiate authentication without specifying a username in the URL, as libcurl normally requires a username for authentication.</source>
          <target state="translated">사용자 이름이나 비밀번호를 찾지 않고 인증을 시도하십시오. libcurl은 일반적으로 인증을 위해 사용자 이름을 필요로하기 때문에 URL에 사용자 이름을 지정하지 않고 GSS 협상 협상을 시도하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7ef94beb2ddaab144a55b166c213b4001e85f5a" translate="yes" xml:space="preserve">
          <source>Attempt to auto-register archives at &lt;code&gt;http://mirrors.sourcecontrol.net&lt;/code&gt; This is particularly useful with the -D option.</source>
          <target state="translated">&lt;code&gt;http://mirrors.sourcecontrol.net&lt;/code&gt; 에서 아카이브 자동 등록 시도 -D 옵션과 함께 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7d9e2779fbfa7bc1835b11ad0c4ebabfce18ac06" translate="yes" xml:space="preserve">
          <source>Attempt to detect merges based on the commit message with a custom regex. It can be used with &lt;code&gt;-m&lt;/code&gt; to enable the default regexes as well. You must escape forward slashes.</source>
          <target state="translated">커밋 메시지를 기반으로 사용자 지정 정규식을 사용하여 병합을 감지하려고합니다. &lt;code&gt;-m&lt;/code&gt; 과 함께 사용하여 기본 정규 표현식도 활성화 할 수 있습니다 . 슬래시를 이스케이프해야합니다.</target>
        </trans-unit>
        <trans-unit id="b8801ab881aa4eb66128b4665e3908eb4d237716" translate="yes" xml:space="preserve">
          <source>Attempt to detect merges based on the commit message. This option will enable default regexes that try to capture the source branch name from the commit message.</source>
          <target state="translated">커밋 메시지를 기반으로 병합을 감지하려고합니다. 이 옵션은 커밋 메시지에서 소스 분기 이름을 캡처하려고하는 기본 정규 표현식을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="8811bcf98c754b208d76412300be8b3f7a7a0962" translate="yes" xml:space="preserve">
          <source>Attempt to use AUTH SSL/TLS and encrypted data transfers when connecting via regular FTP protocol. This might be needed if the FTP server requires it for security reasons or you wish to connect securely whenever remote FTP server supports it. Default is false since it might trigger certificate verification errors on misconfigured servers.</source>
          <target state="translated">일반 FTP 프로토콜을 통해 연결할 때 AUTH SSL / TLS 및 암호화 된 데이터 전송을 사용하십시오. 보안상의 이유로 FTP 서버에 필요하거나 원격 FTP 서버가 지원할 때마다 안전하게 연결하려는 경우에 필요할 수 있습니다. 잘못 구성된 서버에서 인증서 확인 오류를 유발할 수 있으므로 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="653466560b06acd7928eb1dabc7b9fa724a015d3" translate="yes" xml:space="preserve">
          <source>Attempts to recreate empty directories that core Git cannot track based on information in $GIT_DIR/svn/&amp;lt;refname&amp;gt;/unhandled.log files. Empty directories are automatically recreated when using &quot;git svn clone&quot; and &quot;git svn rebase&quot;, so &quot;mkdirs&quot; is intended for use after commands like &quot;git checkout&quot; or &quot;git reset&quot;. (See the svn-remote.&amp;lt;name&amp;gt;.automkdirs config file option for more information.)</source>
          <target state="translated">핵심 Git이 $ GIT_DIR / svn / &amp;lt;refname&amp;gt; /unhandled.log 파일의 정보를 기반으로 추적 할 수없는 빈 디렉토리를 다시 작성하려고합니다. &quot;git svn clone&quot;및 &quot;git svn rebase&quot;를 사용하면 빈 디렉토리가 자동으로 다시 만들어 지므로 &quot;mkdirs&quot;는 &quot;git checkout&quot;또는 &quot;git reset&quot;과 같은 명령 뒤에 사용됩니다. (자세한 내용은 svn-remote. &amp;lt;name&amp;gt; .automkdirs 구성 파일 옵션을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="6945a05135c86ba329a2113c1a6c328943460d7a" translate="yes" xml:space="preserve">
          <source>Augment the output of all queried config options with the origin type (file, standard input, blob, command line) and the actual origin (config file path, ref, or blob id if applicable).</source>
          <target state="translated">원본 유형 (파일, 표준 입력, 얼룩, 명령 줄) 및 실제 원본 (해당되는 경우 구성 파일 경로, 참조 또는 얼룩 ID)을 사용하여 쿼리 된 모든 구성 옵션의 출력을 보강하십시오.</target>
        </trans-unit>
        <trans-unit id="d01bdb4337dbc4feb334d71a4ce4b2957ce12b06" translate="yes" xml:space="preserve">
          <source>Author and committer information is taken from the following environment variables, if set:</source>
          <target state="translated">작성자 및 커미터 정보는 설정된 경우 다음 환경 변수에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d2a52548bd0852b99153ddd79a1f550f70674c7d" translate="yes" xml:space="preserve">
          <source>Authors</source>
          <target state="translated">Authors</target>
        </trans-unit>
        <trans-unit id="3a3b18a78fb302a466d9706ed638e25ca72e2b20" translate="yes" xml:space="preserve">
          <source>Automatically bisect a broken build between v1.2 and HEAD:</source>
          <target state="translated">v1.2와 HEAD간에 깨진 빌드를 자동으로 이등분합니다.</target>
        </trans-unit>
        <trans-unit id="b961e5ffc1b4a2335ddafbf9005a05ec9394a9ac" translate="yes" xml:space="preserve">
          <source>Automatically bisect a broken test case:</source>
          <target state="translated">깨진 테스트 케이스를 자동으로 이등분합니다.</target>
        </trans-unit>
        <trans-unit id="efbd5b3ba20268a44c57d801ed284c730cc6da62" translate="yes" xml:space="preserve">
          <source>Automatically bisect a test failure between origin and HEAD:</source>
          <target state="translated">원점과 HEAD 사이의 테스트 실패를 자동으로 이등분합니다.</target>
        </trans-unit>
        <trans-unit id="305f7f7499890d95ab081f6ff6a94a43fd8f7472" translate="yes" xml:space="preserve">
          <source>Automatically bisect with temporary modifications (hot-fix):</source>
          <target state="translated">임시 수정 (핫픽스)으로 자동 이등분 :</target>
        </trans-unit>
        <trans-unit id="f3ce497b64c12f23e2601126336fc2efac214445" translate="yes" xml:space="preserve">
          <source>Automatically correct and execute mistyped commands after waiting for the given number of deciseconds (0.1 sec). If more than one command can be deduced from the entered text, nothing will be executed. If the value of this option is negative, the corrected command will be executed immediately. If the value is 0 - the command will be just shown but not executed. This is the default.</source>
          <target state="translated">주어진 수초 (0.1 초) 동안 기다린 후 잘못 입력 된 명령을 자동으로 수정하고 실행합니다. 입력 한 텍스트에서 둘 이상의 명령을 추론 할 수있는 경우 아무것도 실행되지 않습니다. 이 옵션의 값이 음수이면 수정 된 명령이 즉시 실행됩니다. 값이 0이면 명령이 표시되지만 실행되지는 않습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="c95bbf7a5ca8016973d83b1a1be57b0354ee0b3c" translate="yes" xml:space="preserve">
          <source>Automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run rebase on a dirty worktree. However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts.</source>
          <target state="translated">작업이 시작되기 전에 임시 숨김 항목을 자동으로 생성하고 작업이 끝난 후에 적용하십시오. 이는 더티 작업 트리에서 리베이스를 실행할 수 있음을 의미합니다. 그러나주의해서 사용하십시오. 리베이스에 성공한 후 마지막 숨김 응용 프로그램은 사소한 충돌을 초래할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdfa0a080ceaba7371e2c4f216b1a9549ed01683" translate="yes" xml:space="preserve">
          <source>Automatically create a temporary stash entry before the operation begins, and apply it after the operation ends. This means that you can run the operation on a dirty worktree. However, use with care: the final stash application after a successful merge might result in non-trivial conflicts.</source>
          <target state="translated">작업이 시작되기 전에 임시 숨김 항목을 자동으로 생성하고 작업이 종료 된 후에 적용합니다. 이는 더티 워크 트리에서 작업을 실행할 수 있음을 의미합니다. 그러나주의해서 사용하십시오. 성공적인 병합 후 최종 숨김 애플리케이션은 사소한 충돌을 초래할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="172ed809f35e71e5eeb8f45359fa6e87d4adb464" translate="yes" xml:space="preserve">
          <source>Automatically enter the &lt;code&gt;Amend Last Commit&lt;/code&gt; mode of the interface.</source>
          <target state="translated">인터페이스의 &lt;code&gt;Amend Last Commit&lt;/code&gt; 모드로 자동 전환합니다.</target>
        </trans-unit>
        <trans-unit id="ea4a15096a50442dde0b46a87fa45d92f2d785b9" translate="yes" xml:space="preserve">
          <source>Automatically reschedule &lt;code&gt;exec&lt;/code&gt; commands that failed. This only makes sense in interactive mode (or when an &lt;code&gt;--exec&lt;/code&gt; option was provided).</source>
          <target state="translated">실패한 &lt;code&gt;exec&lt;/code&gt; 명령을 자동으로 다시 예약 합니다. 이것은 대화식 모드 (또는 &lt;code&gt;--exec&lt;/code&gt; 옵션이 제공된 경우) 에서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="49d8a969b318bfe4bd71c313d20f34515eed00b4" translate="yes" xml:space="preserve">
          <source>Automatically reschedule &lt;code&gt;exec&lt;/code&gt; commands that failed. This only makes sense in interactive mode (or when an &lt;code&gt;--exec&lt;/code&gt; option was provided). This is the same as specifying the &lt;code&gt;--reschedule-failed-exec&lt;/code&gt; option.</source>
          <target state="translated">실패한 &lt;code&gt;exec&lt;/code&gt; 명령을 자동으로 다시 예약 합니다. 이것은 대화식 모드 (또는 &lt;code&gt;--exec&lt;/code&gt; 옵션이 제공된 경우) 에서만 의미가 있습니다. &lt;code&gt;--reschedule-failed-exec&lt;/code&gt; 옵션 을 지정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d8ac3fef9b72ebf093fec8697b2ecc321af38b99" translate="yes" xml:space="preserve">
          <source>Automating</source>
          <target state="translated">Automating</target>
        </trans-unit>
        <trans-unit id="91b5703f47ead0e97d542b1a3caaad3f90e51a85" translate="yes" xml:space="preserve">
          <source>Avatar support. When this feature is enabled, views such as &quot;shortlog&quot; or &quot;commit&quot; will display an avatar associated with the email of each committer and author.</source>
          <target state="translated">아바타 지원. 이 기능이 활성화되면 &quot;단축&quot;또는 &quot;커밋&quot;과 같은보기에 각 커미터 및 작성자의 이메일과 관련된 아바타가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c6d2705a42ecaf3f83b93f2bb10c67222bc9051b" translate="yes" xml:space="preserve">
          <source>Avoid using these constructs, or do so with extreme caution.</source>
          <target state="translated">이러한 구성을 사용하지 않거나 매우주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="58d07623af97c330a561d59f75b429cfa3bf0d0e" translate="yes" xml:space="preserve">
          <source>Avoiding bug prone merges</source>
          <target state="translated">버그가 발생하기 쉬운 병합 방지</target>
        </trans-unit>
        <trans-unit id="e75c3f820aba1b207ca074d2c527699299d0d6c8" translate="yes" xml:space="preserve">
          <source>Avoiding repetition</source>
          <target state="translated">반복 피하기</target>
        </trans-unit>
        <trans-unit id="8c9b7d07bde7114458252fe7c7c79eff561fa5a3" translate="yes" xml:space="preserve">
          <source>Avoiding testing a commit</source>
          <target state="translated">커밋 테스트 피하기</target>
        </trans-unit>
        <trans-unit id="b6679b7397715a4a559a3f90cd5da98012c5192b" translate="yes" xml:space="preserve">
          <source>Avoiding untestable commits</source>
          <target state="translated">테스트 할 수없는 커밋 방지</target>
        </trans-unit>
        <trans-unit id="c06045f474b6de45fbcfae00e6444b3eed002fd3" translate="yes" xml:space="preserve">
          <source>BBChop is like &lt;code&gt;git bisect&lt;/code&gt; (or equivalent), but works when your bug is intermittent. That is, it works in the presence of false negatives (when a version happens to work this time even though it contains the bug). It assumes that there are no false positives (in principle, the same approach would work, but adding it may be non-trivial).</source>
          <target state="translated">BBChop은 &lt;code&gt;git bisect&lt;/code&gt; 와 비슷 하지만 버그가 간헐적 일 때 작동합니다. 즉, 오탐 (false negative)이있을 때 작동합니다 (버그가 포함되어 있어도 이번에는 버전이 작동 할 때). 그것은 오 탐지가 없다고 가정합니다 (원칙적으로 동일한 접근 방식이 효과가 있지만 추가하는 것이 쉽지 않을 수도 있습니다).</target>
        </trans-unit>
        <trans-unit id="58da1ac28249462c67af1a7a678bbb84e64c5732" translate="yes" xml:space="preserve">
          <source>Back in the compose window: add whatever other text you wish to the message, complete the addressing and subject fields, and press send.</source>
          <target state="translated">편지 쓰기 창으로 돌아 가기 : 메시지에 원하는 다른 텍스트를 추가하고 주소 및 제목 필드를 완성한 다음 보내기를 누릅니다.</target>
        </trans-unit>
        <trans-unit id="0e4c8fb0c7c0f01878ae288a3240d6945abd9968" translate="yes" xml:space="preserve">
          <source>Back when this document was originally written, many porcelain commands were shell scripts. For simplicity, it still uses them as examples to illustrate how plumbing is fit together to form the porcelain commands. The source tree includes some of these scripts in contrib/examples/ for reference. Although these are not implemented as shell scripts anymore, the description of what the plumbing layer commands do is still valid.</source>
          <target state="translated">이 문서가 처음 쓰여졌을 때, 많은 도자기 명령은 쉘 스크립트였습니다. 간단하게하기 위해, 이들은 여전히 ​​배관을 함께 사용하여 도자기 명령을 구성하는 방법을 설명하기위한 예제로 사용합니다. 소스 트리에는 참조를 위해 contrib / examples /에 이러한 스크립트 중 일부가 포함되어 있습니다. 이것들이 더 이상 쉘 스크립트로 구현되지는 않지만 배관 계층 명령의 기능에 대한 설명은 여전히 ​​유효합니다.</target>
        </trans-unit>
        <trans-unit id="3cd5a2617e84a99ed87281238ca40ff62c45eb00" translate="yes" xml:space="preserve">
          <source>Backend extra options</source>
          <target state="translated">백엔드 추가 옵션</target>
        </trans-unit>
        <trans-unit id="68cec68bccaee9cd80346d9802ee1e4fe905591f" translate="yes" xml:space="preserve">
          <source>Backend for fast Git data importers</source>
          <target state="translated">빠른 Git 데이터 가져 오기를위한 백엔드</target>
        </trans-unit>
        <trans-unit id="332ccbbf6a93a641f5828315e15dfb5ba3534887" translate="yes" xml:space="preserve">
          <source>Background refresh</source>
          <target state="translated">백그라운드 새로 고침</target>
        </trans-unit>
        <trans-unit id="3768e81347249432d7250e290eff2b7dcfb031aa" translate="yes" xml:space="preserve">
          <source>Backwards compatibility with &lt;code&gt;crlf&lt;/code&gt; attribute</source>
          <target state="translated">&lt;code&gt;crlf&lt;/code&gt; 속성 과의 호환성</target>
        </trans-unit>
        <trans-unit id="0f4f796a2c073cee4b5657a9746bebeb8b591e9a" translate="yes" xml:space="preserve">
          <source>Base URL for relative URLs in pages generated by gitweb, (e.g. &lt;code&gt;$logo&lt;/code&gt;, &lt;code&gt;$favicon&lt;/code&gt;, &lt;code&gt;@stylesheets&lt;/code&gt; if they are relative URLs), needed and used &lt;code&gt;&amp;lt;base href=&quot;$base_url&quot;&amp;gt;&lt;/code&gt; only for URLs with nonempty PATH_INFO. Usually gitweb sets its value correctly, and there is no need to set this variable, e.g. to $my_uri or &quot;/&quot;. See &lt;code&gt;$per_request_config&lt;/code&gt; if you need to override it anyway.</source>
          <target state="translated">gitweb에 의해 생성 된 페이지의 상대 URL에 대한 기본 URL (예 : &lt;code&gt;$logo&lt;/code&gt; , &lt;code&gt;$favicon&lt;/code&gt; , &lt;code&gt;@stylesheets&lt;/code&gt; 가 상대 URL 인 경우)은 &lt;code&gt;&amp;lt;base href=&quot;$base_url&quot;&amp;gt;&lt;/code&gt; 필요하며 비어 있지 않은 PATH_INFO가있는 URL에만 사용됩니다. 일반적으로 gitweb은 그 값을 올바르게 설정하며이 변수를 $ my_uri 또는 &quot;/&quot;로 설정할 필요가 없습니다. 재정의해야 할 경우 &lt;code&gt;$per_request_config&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="097ac79311bf794decc7505841440135a2fcc1ec" translate="yes" xml:space="preserve">
          <source>Base tree information</source>
          <target state="translated">기본 트리 정보</target>
        </trans-unit>
        <trans-unit id="41acf5ab02f1a6facad6c843b7f1be13be76b889" translate="yes" xml:space="preserve">
          <source>Basic Command Messages</source>
          <target state="translated">기본 명령 메시지</target>
        </trans-unit>
        <trans-unit id="32df76cf3cbd146d03819bb90c4b2e01188b5795" translate="yes" xml:space="preserve">
          <source>Basic Snapshotting</source>
          <target state="translated">기본 스냅 샷</target>
        </trans-unit>
        <trans-unit id="8f3df0ee4c430ab18f213f1998c456e450457574" translate="yes" xml:space="preserve">
          <source>Basic bisect commands: start, bad, good</source>
          <target state="translated">기본 이등분 명령 : 시작, 불량, 양호</target>
        </trans-unit>
        <trans-unit id="4c8d5fdc5db9950cf7bea592d196bad4f803b3fb" translate="yes" xml:space="preserve">
          <source>Basic examples</source>
          <target state="translated">기본 예</target>
        </trans-unit>
        <trans-unit id="8edc4390b3f014a72c7bad2082d4af28321b0a0d" translate="yes" xml:space="preserve">
          <source>Basically, the initial version of &lt;code&gt;git log&lt;/code&gt; was a shell script:</source>
          <target state="translated">기본적으로 &lt;code&gt;git log&lt;/code&gt; 의 초기 버전은 쉘 스크립트였습니다.</target>
        </trans-unit>
        <trans-unit id="434712fddf7623f4187c1faf83b1bb6fa207c805" translate="yes" xml:space="preserve">
          <source>Batch output</source>
          <target state="translated">배치 출력</target>
        </trans-unit>
        <trans-unit id="09375d82ef48456f50bfb9b6b51c1eb3256d2719" translate="yes" xml:space="preserve">
          <source>Be a little more verbose and show remote url after name. NOTE: This must be placed between &lt;code&gt;remote&lt;/code&gt; and &lt;code&gt;subcommand&lt;/code&gt;.</source>
          <target state="translated">조금 더 자세하게 설명하고 이름 뒤에 원격 URL을 표시하십시오. 참고 : 이것은 &lt;code&gt;remote&lt;/code&gt; 와 &lt;code&gt;subcommand&lt;/code&gt; 사이에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="05ae4f9773fc15757112e4e005a53743a8b9b6cb" translate="yes" xml:space="preserve">
          <source>Be a little more verbose and show remote url after name. NOTE: This must be placed between &lt;code&gt;remote&lt;/code&gt; and subcommand.</source>
          <target state="translated">좀 더 자세히 설명하고 이름 뒤에 원격 URL을 표시합니다. 참고 : 이것은 &lt;code&gt;remote&lt;/code&gt; 명령과 하위 명령 사이에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="8c658e70993b255c8802b7997e9b78d1f1aa3285" translate="yes" xml:space="preserve">
          <source>Be aware that commits that the old version of example/master pointed at may be lost, as we saw in the previous section.</source>
          <target state="translated">이전 섹션에서 보았 듯이 이전 버전의 예제 / 마스터가 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1a69fc5e5785e6c85861e4893e3a9a94deb0c9c" translate="yes" xml:space="preserve">
          <source>Be careful with that last command: in addition to losing any changes in the working directory, it will also remove all later commits from this branch. If this branch is the only branch containing those commits, they will be lost. Also, don&amp;rsquo;t use &lt;code&gt;git reset&lt;/code&gt; on a publicly-visible branch that other developers pull from, as it will force needless merges on other developers to clean up the history. If you need to undo changes that you have pushed, use &lt;code&gt;git revert&lt;/code&gt; instead.</source>
          <target state="translated">마지막 명령에주의하십시오 : 작업 디렉토리의 변경 사항을 잃을뿐만 아니라이 분기에서 이후의 모든 커밋도 제거됩니다. 이 브랜치가 해당 커밋을 포함하는 유일한 브랜치 인 경우 손실됩니다. 또한 다른 개발자가 가져 오는 공개적으로 볼 수있는 분기에서 &lt;code&gt;git reset&lt;/code&gt; 을 사용하지 마십시오. 다른 개발자와의 불필요한 병합으로 기록을 정리할 수 있습니다. 푸시 한 변경 사항을 취소해야하는 경우 대신 &lt;code&gt;git revert&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a106ab03cbfb468582a31c86875853bbaafe530d" translate="yes" xml:space="preserve">
          <source>Be chatty.</source>
          <target state="translated">대화하기</target>
        </trans-unit>
        <trans-unit id="0226bfbddcb9791bd20d59aa488cf4bfb67ab797" translate="yes" xml:space="preserve">
          <source>Be more quiet when creating or deleting a branch, suppressing non-error messages.</source>
          <target state="translated">오류가 아닌 메시지를 표시하지 않고 분기를 만들거나 삭제할 때 더 조용하십시오.</target>
        </trans-unit>
        <trans-unit id="925261c1087472fc24273a6f0433e6dab581a46e" translate="yes" xml:space="preserve">
          <source>Be pedantic (paranoid) when applying patches. Invokes patch with --fuzz=0</source>
          <target state="translated">패치를 적용 할 때 pedantic (편집증)하십시오. --fuzz = 0으로 패치를 호출합니다</target>
        </trans-unit>
        <trans-unit id="5a76ff079f12b1a74eb9b1c43645e96dd86361c1" translate="yes" xml:space="preserve">
          <source>Be quiet, only report errors, but not the files that are successfully removed.</source>
          <target state="translated">조용히하고 오류 만보고하지만 성공적으로 제거 된 파일은보고하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3b0a3e777f7a9dd999ab064af69bac80ddbc5083" translate="yes" xml:space="preserve">
          <source>Be quiet, only report errors. The default behavior is set by the &lt;code&gt;reset.quiet&lt;/code&gt; config option. &lt;code&gt;--quiet&lt;/code&gt; and &lt;code&gt;--no-quiet&lt;/code&gt; will override the default behavior.</source>
          <target state="translated">조용히하고 오류 만보고하십시오. 기본 동작은 &lt;code&gt;reset.quiet&lt;/code&gt; 구성 옵션에 의해 설정됩니다 . &lt;code&gt;--quiet&lt;/code&gt; 및 &lt;code&gt;--no-quiet&lt;/code&gt; 은 기본 동작을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="4f313b181847f334463e2b9b9cfece6969bdba71" translate="yes" xml:space="preserve">
          <source>Be quiet.</source>
          <target state="translated">조용히 해.</target>
        </trans-unit>
        <trans-unit id="57fac52c9e565c186d12f20b18e356a6357e3a35" translate="yes" xml:space="preserve">
          <source>Be quiet. Implies --no-stat.</source>
          <target state="translated">조용히 해. --no-stat를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="35516ed1ed9df26f7366465685509e0334c0b48a" translate="yes" xml:space="preserve">
          <source>Be quiet. Only print error messages.</source>
          <target state="translated">조용히 해. 오류 메시지 만 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="89978c5e1540e90f998db2cd0eadcb073170d060" translate="yes" xml:space="preserve">
          <source>Be verbose about what is going on, including progress status.</source>
          <target state="translated">진행 상황을 포함하여 진행중인 일에 대해 자세하게 설명하십시오.</target>
        </trans-unit>
        <trans-unit id="4e80f48c004a90076351b14f311e5f6e4c744c6f" translate="yes" xml:space="preserve">
          <source>Be verbose.</source>
          <target state="translated">장황하다.</target>
        </trans-unit>
        <trans-unit id="e38a34eb197b14381b23c4e10c689eabe1fdd749" translate="yes" xml:space="preserve">
          <source>Be verbose. Implies --stat.</source>
          <target state="translated">장황하다. --stat를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d448b8a2b9d0f1627827f1dfcde2eef631321fa0" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;--&lt;/code&gt; disambiguates revisions and paths in some commands, it cannot be used for those commands to separate options and revisions. You can use &lt;code&gt;--end-of-options&lt;/code&gt; for this (it also works for commands that do not distinguish between revisions in paths, in which case it is simply an alias for &lt;code&gt;--&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; 일부 명령에서 개정 및 경로를 명확하게 하기 때문에 해당 명령에서 옵션과 개정을 분리하는 데 사용할 수 없습니다. 이를 위해 &lt;code&gt;--end-of-options&lt;/code&gt; 를 사용할 수 있습니다 (경로의 개정판을 구분하지 않는 명령에서도 작동합니다.이 경우 단순히 &lt;code&gt;--&lt;/code&gt; 의 별칭 임).</target>
        </trans-unit>
        <trans-unit id="ed27c3aa81ab7c3b7b68607b6265fd75466941ef" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;git rebase&lt;/code&gt; replays each commit from the working branch on top of the &amp;lt;upstream&amp;gt; branch using the given strategy, using the &lt;code&gt;ours&lt;/code&gt; strategy simply empties all patches from the &amp;lt;branch&amp;gt;, which makes little sense.</source>
          <target state="translated">&lt;code&gt;git rebase&lt;/code&gt; 는 주어진 전략을 사용하여 &amp;lt;upstream&amp;gt; 브랜치의 작업 브랜치에서 각 커밋을 재생 하기 때문에 &lt;code&gt;ours&lt;/code&gt; 전략을 사용 하면 &amp;lt;branch&amp;gt;의 모든 패치가 비워집니다.</target>
        </trans-unit>
        <trans-unit id="611de3be2abb35df567ae0fa30747c7d8e2e7993" translate="yes" xml:space="preserve">
          <source>Because importing commits from other Git repositories is much faster than importing them from p4, a mechanism exists to find p4 changes first in Git remotes. If branches exist under &lt;code&gt;refs/remote/origin/p4&lt;/code&gt;, those will be fetched and used when syncing from p4. This variable can be set to &lt;code&gt;false&lt;/code&gt; to disable this behavior.</source>
          <target state="translated">다른 Git 리포지토리에서 커밋을 가져 오는 것이 p4에서 가져 오는 것보다 훨씬 빠르기 때문에 Git 원격에서 p4 변경 사항을 먼저 찾는 메커니즘이 있습니다. 분기가 &lt;code&gt;refs/remote/origin/p4&lt;/code&gt; 아래에있는 경우 p4 에서 동기화 할 때 해당 분기를 가져 와서 사용합니다. 이 변수를 &lt;code&gt;false&lt;/code&gt; 로 설정하여이 동작을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b27b448c938b73dbdadc78ef0ba4dafccd89967" translate="yes" xml:space="preserve">
          <source>Because of this rule, version bumps should be kept to an absolute minimum. Instead, we generally prefer these strategies:</source>
          <target state="translated">이 규칙으로 인해 버전 범프는 최소로 유지되어야합니다. 대신 일반적으로 다음 전략을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="9d9f1c640b4582c4a49afdb8c70b2833e5da2875" translate="yes" xml:space="preserve">
          <source>Because text conversion can be slow, especially when doing a large number of them with &lt;code&gt;git log -p&lt;/code&gt;, Git provides a mechanism to cache the output and use it in future diffs. To enable caching, set the &quot;cachetextconv&quot; variable in your diff driver&amp;rsquo;s config. For example:</source>
          <target state="translated">&lt;code&gt;git log -p&lt;/code&gt; 로 많은 수의 텍스트를 수행 할 때 텍스트 변환이 느려질 수 있으므로 Git은 출력을 캐시하고 향후 diff에서 사용할 수있는 메커니즘을 제공합니다. 캐싱을 사용하려면 diff 드라이버 구성에서 &quot;cachetextconv&quot;변수를 설정하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0cc6b3eb8dba093f368da6924e1615ce67ee83a2" translate="yes" xml:space="preserve">
          <source>Because this example lets the shell expand the asterisk (i.e. you are listing the files explicitly), it does not consider &lt;code&gt;subdir/git-foo.sh&lt;/code&gt;.</source>
          <target state="translated">이 예제에서는 쉘이 별표를 확장 할 수있게하므로 (즉, 파일을 명시 적으로 나열하고 있음) &lt;code&gt;subdir/git-foo.sh&lt;/code&gt; 를 고려하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6959f8959917da0048164f701d2c1653881d1c94" translate="yes" xml:space="preserve">
          <source>Because this example lets the shell expand the asterisk (i.e. you are listing the files explicitly), it does not remove &lt;code&gt;subdir/git-foo.sh&lt;/code&gt;.</source>
          <target state="translated">이 예제는 쉘이 별표를 확장 할 수있게하므로 (즉, 파일을 명시 적으로 나열하고 있음) &lt;code&gt;subdir/git-foo.sh&lt;/code&gt; 를 제거하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="19c5affce108c66b3b01079a5ffc874aa2199c4e" translate="yes" xml:space="preserve">
          <source>Because you&amp;rsquo;re asking for raw output, you&amp;rsquo;ll now get something like</source>
          <target state="translated">원시 출력을 요구하기 때문에 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="6c83aee082a9b203ae0a8b1d789ef54ecb5119e2" translate="yes" xml:space="preserve">
          <source>Because your branch did not contain anything more than what had already been merged into the &lt;code&gt;master&lt;/code&gt; branch, the merge operation did not actually do a merge. Instead, it just updated the top of the tree of your branch to that of the &lt;code&gt;master&lt;/code&gt; branch. This is often called &lt;code&gt;fast-forward&lt;/code&gt; merge.</source>
          <target state="translated">브랜치에 이미 &lt;code&gt;master&lt;/code&gt; 브랜치 에 병합 된 것보다 많은 것이 포함되어 있지 않기 때문에 병합 작업은 실제로 병합을 수행하지 않았습니다. 대신 지점의 트리 상단을 &lt;code&gt;master&lt;/code&gt; 지점 의 트리로 업데이트했습니다 . 이를 종종 &lt;code&gt;fast-forward&lt;/code&gt; 병합 이라고 합니다.</target>
        </trans-unit>
        <trans-unit id="870bf9816d9b0c5ffd88b816d5bee6377c654145" translate="yes" xml:space="preserve">
          <source>Before 2.17, the untracked cache had a bug where replacing a directory with a symlink to another directory could cause it to incorrectly show files tracked by git as untracked. See the &quot;status: add a failing test showing a core.untrackedCache bug&quot; commit to git.git. A workaround for that is (and this might work for other undiscovered bugs in the future):</source>
          <target state="translated">2.17 이전에는 추적되지 않은 캐시에 디렉토리를 다른 디렉토리에 대한 심볼릭 링크로 바꾸면 git에 의해 추적 된 파일이 추적되지 않은 것으로 잘못 표시 될 수 있습니다. git.git에 대한 &quot;상태 : core.untrackedCache 버그를 보여주는 실패한 테스트 추가&quot;커밋을 참조하십시오. 이에 대한 해결 방법은 다음과 같습니다 (이는 나중에 발견되지 않은 다른 버그에 대해서도 작동 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="201415c3562a156d29edac8b78dcea637cbede90" translate="yes" xml:space="preserve">
          <source>Before Git invokes a hook, it changes its working directory to either $GIT_DIR in a bare repository or the root of the working tree in a non-bare repository. An exception are hooks triggered during a push (&lt;code&gt;pre-receive&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;post-receive&lt;/code&gt;, &lt;code&gt;post-update&lt;/code&gt;, &lt;code&gt;push-to-checkout&lt;/code&gt;) which are always executed in $GIT_DIR.</source>
          <target state="translated">Git이 후크를 호출하기 전에 베어 리포지토리의 작업 디렉토리를 베어 리포지토리의 작업 트리 루트 또는 $ GIT_DIR로 변경합니다. 예외는 항상 $ GIT_DIR에서 실행 되는 푸시 ( &lt;code&gt;pre-receive&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; , &lt;code&gt;post-receive&lt;/code&gt; , &lt;code&gt;post-update&lt;/code&gt; , &lt;code&gt;push-to-checkout&lt;/code&gt; ) 중에 트리거되는 후크 입니다.</target>
        </trans-unit>
        <trans-unit id="5cb683352fd365c05d1a2f3a901dc43ac75f481f" translate="yes" xml:space="preserve">
          <source>Before Git v2.0, the default prefix was &quot;&quot; (no prefix). This meant that SVN-tracking refs were put at &quot;refs/remotes/*&quot;, which is incompatible with how Git&amp;rsquo;s own remote-tracking refs are organized. If you still want the old default, you can get it by passing &lt;code&gt;--prefix &quot;&quot;&lt;/code&gt; on the command line (&lt;code&gt;--prefix=&quot;&quot;&lt;/code&gt; may not work if your Perl&amp;rsquo;s Getopt::Long is &amp;lt; v2.37).</source>
          <target state="translated">Git v2.0 이전에는 기본 접두사가 &quot;&quot;(접두사 없음)였습니다. 이것은 SVN 추적 참조가 &quot;refs / remotes / *&quot;에 놓 였음을 의미하며, 이는 Git의 원격 추적 참조 구성 방법과 호환되지 않습니다. 여전히 이전 기본값을 원한다면 명령 줄에 &lt;code&gt;--prefix &quot;&quot;&lt;/code&gt; 를 전달하여 얻을 수 있습니다 ( Perl의 Getopt :: Long이 &amp;lt;v2.37 인 경우 &lt;code&gt;--prefix=&quot;&quot;&lt;/code&gt; 가 작동하지 않을 수 있음).</target>
        </trans-unit>
        <trans-unit id="c9087c912c36612c549b23a216e2ca49dd6b41fb" translate="yes" xml:space="preserve">
          <source>Before any patches are applied, ORIG_HEAD is set to the tip of the current branch. This is useful if you have problems with multiple commits, like running &lt;code&gt;git am&lt;/code&gt; on the wrong branch or an error in the commits that is more easily fixed by changing the mailbox (e.g. errors in the &quot;From:&quot; lines).</source>
          <target state="translated">패치가 적용되기 전에 ORIG_HEAD는 현재 분기의 끝으로 설정됩니다. 이 방법은 잘못된 분기 에서 &lt;code&gt;git am&lt;/code&gt; 을 실행 하거나 사서함을 변경하여보다 쉽게 ​​수정되는 커밋 오류 (예 : &quot;보낸 사람 :&quot;줄의 오류) 와 같이 여러 커밋에 문제가있는 경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="21c90195abdd4404631a1dbe99e365dc5749da75" translate="yes" xml:space="preserve">
          <source>Before any ref is updated, if $GIT_DIR/hooks/pre-receive file exists and is executable, it will be invoked once with no parameters. The standard input of the hook will be one line per ref to be updated:</source>
          <target state="translated">참조가 업데이트되기 전에 $ GIT_DIR / hooks / pre-receive 파일이 존재하고 실행 가능한 경우 매개 변수없이 한 번만 호출됩니다. 후크의 표준 입력은 업데이트 할 참조 당 한 줄입니다.</target>
        </trans-unit>
        <trans-unit id="add64b4c118b3f9ba1a8f5777c12299edaee08fe" translate="yes" xml:space="preserve">
          <source>Before applying outside changes, you should get your own work in good shape and committed locally, so it will not be clobbered if there are conflicts. See also &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;. &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt; will stop without doing anything when local uncommitted changes overlap with files that &lt;code&gt;git pull&lt;/code&gt;/&lt;code&gt;git merge&lt;/code&gt; may need to update.</source>
          <target state="translated">외부 변경 사항을 적용하기 전에 자신의 작업을 잘 작성하고 로컬에서 커밋해야하므로 충돌이 있어도 문제가 해결되지 않습니다. &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; 도 참조하십시오 . 커밋되지 않은 로컬 변경 사항이 &lt;code&gt;git pull&lt;/code&gt; / &lt;code&gt;git merge&lt;/code&gt; 가 업데이트해야 할 파일과 겹치면 &lt;code&gt;git pull&lt;/code&gt; 및 &lt;code&gt;git merge&lt;/code&gt; 가 아무런 작업을 수행하지 않고 중지 됩니다.</target>
        </trans-unit>
        <trans-unit id="5b4786a5cabe8cc8e9d6176c7a8f4c8ac1126f56" translate="yes" xml:space="preserve">
          <source>Before creating any commits, you should introduce yourself to Git. The easiest way to do so is to use &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;:</source>
          <target state="translated">커밋을 만들기 전에 Git을 소개해야합니다. 가장 쉬운 방법은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]을 사용하는 것입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fda40fac347bfbef9972589a0b7125a0c0bcff59" translate="yes" xml:space="preserve">
          <source>Before discussing another option, &lt;code&gt;--show-pulls&lt;/code&gt;, we need to create a new example history.</source>
          <target state="translated">다른 옵션 &lt;code&gt;--show-pulls&lt;/code&gt; 에 대해 논의하기 전에 새로운 예제 기록을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="0407957d0e82cce71a4172b7606149052dc8e0c6" translate="yes" xml:space="preserve">
          <source>Before each ref is updated, if $GIT_DIR/hooks/update file exists and is executable, it is invoked once per ref, with three parameters:</source>
          <target state="translated">각 참조가 업데이트되기 전에 $ GIT_DIR / hooks / update 파일이 존재하고 실행 가능한 경우, 세 개의 매개 변수와 함께 참조 당 한 번 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="19ac0c97c048cb907215a798a4fb3cdaff4d9a6f" translate="yes" xml:space="preserve">
          <source>Before fetching, remove any local tags that no longer exist on the remote if &lt;code&gt;--prune&lt;/code&gt; is enabled. This option should be used more carefully, unlike &lt;code&gt;--prune&lt;/code&gt; it will remove any local references (local tags) that have been created. This option is a shorthand for providing the explicit tag refspec along with &lt;code&gt;--prune&lt;/code&gt;, see the discussion about that in its documentation.</source>
          <target state="translated">가져 오기 전에 &lt;code&gt;--prune&lt;/code&gt; 이 활성화 된 경우 원격에 더 이상 존재하지 않는 로컬 태그를 제거하십시오 . 이 옵션은 &lt;code&gt;--prune&lt;/code&gt; 과 달리보다 신중하게 사용해야하며, 생성 된 모든 로컬 참조 (로컬 태그)를 제거합니다. 이 옵션은 &lt;code&gt;--prune&lt;/code&gt; 과 함께 명시 적 태그 참조 스펙 을 제공하기위한 약식입니다 . 설명서에서 이에 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8e73bf59416129baf4984229453394f0315b226d" translate="yes" xml:space="preserve">
          <source>Before fetching, remove any remote-tracking references that no longer exist on the remote. Tags are not subject to pruning if they are fetched only because of the default tag auto-following or due to a --tags option. However, if tags are fetched due to an explicit refspec (either on the command line or in the remote configuration, for example if the remote was cloned with the --mirror option), then they are also subject to pruning. Supplying &lt;code&gt;--prune-tags&lt;/code&gt; is a shorthand for providing the tag refspec.</source>
          <target state="translated">가져 오기 전에 원격에 더 이상 존재하지 않는 원격 추적 참조를 제거하십시오. 태그는 기본 태그 자동 추적 또는 --tags 옵션으로 인해 가져 오는 경우에만 제거되지 않습니다. 그러나 명령 행 또는 원격 구성 (예 : 원격이 --mirror 옵션으로 복제 된 경우)에서 명시 적 참조 스펙으로 인해 태그가 페치되면 태그도 제거 될 수 있습니다. 공급 &lt;code&gt;--prune-tags&lt;/code&gt; 태그 refspec를 제공하기위한 속기이다.</target>
        </trans-unit>
        <trans-unit id="0a0fe23adf5213b01d47b6f6f762c51483096baa" translate="yes" xml:space="preserve">
          <source>Before making a commit out of staged contents so far, stage the contents of paths given on the command line as well. This is usually not what you want unless you are concluding a conflicted merge.</source>
          <target state="translated">지금까지 준비된 내용을 커밋하기 전에 명령 줄에 지정된 경로의 내용도 준비하십시오. 충돌 병합을 마치지 않으면 일반적으로 원하는 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c77aea15ac35dd0f59cc96b6055cd1857904fd59" translate="yes" xml:space="preserve">
          <source>Before moving the index into its final destination create an empty .keep file for the associated pack file. This option is usually necessary with --stdin to prevent a simultaneous &lt;code&gt;git repack&lt;/code&gt; process from deleting the newly constructed pack and index before refs can be updated to use objects contained in the pack.</source>
          <target state="translated">색인을 최종 대상으로 이동하기 전에 연관된 팩 파일에 대해 빈 .keep 파일을 작성하십시오. 이 옵션은 일반적으로 팩에 포함 된 객체를 사용하도록 참조를 업데이트하기 전에 동시 &lt;code&gt;git repack&lt;/code&gt; 프로세스가 새로 생성 된 팩 및 인덱스를 삭제 하지 못하도록 --stdin과 함께 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="1684b3761b33822ae0ce64e85db5417e09a004a4" translate="yes" xml:space="preserve">
          <source>Before opening a compose window, use Edit&amp;rarr;Account Settings to uncheck the &quot;Compose messages in HTML format&quot; setting in the &quot;Composition &amp;amp; Addressing&quot; panel of the account to be used to send the patch.</source>
          <target state="translated">작성 창을 열기 전에 편집 &amp;rarr; 계정 설정을 사용하여 패치를 보내는 데 사용할 계정의 &quot;구성 및 주소 지정&quot;패널에서 &quot;HTML 형식의 메시지 작성&quot;설정을 선택 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="4236fe92cbd33fabad183244090db7c652c48ab2" translate="yes" xml:space="preserve">
          <source>Before processing any input, load the marks specified in &amp;lt;file&amp;gt;. The input file must exist, must be readable, and must use the same format as produced by --export-marks.</source>
          <target state="translated">입력을 처리하기 전에 &amp;lt;file&amp;gt;에 지정된 표시를로드하십시오. 입력 파일이 존재하고 읽을 수 있어야하며 --export-marks에서 생성 한 것과 동일한 형식을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="293840b5790c8dfe363015950d52920cf320165c" translate="yes" xml:space="preserve">
          <source>Before processing any input, load the marks specified in &amp;lt;file&amp;gt;. The input file must exist, must be readable, and must use the same format as produced by --export-marks. Multiple options may be supplied to import more than one set of marks. If a mark is defined to different values, the last file wins.</source>
          <target state="translated">입력을 처리하기 전에 &amp;lt;file&amp;gt;에 지정된 표시를로드하십시오. 입력 파일이 존재하고 읽을 수 있어야하며 --export-marks에서 생성 한 것과 동일한 형식을 사용해야합니다. 둘 이상의 마크 세트를 가져 오기 위해 여러 옵션이 제공 될 수 있습니다. 마크가 다른 값으로 정의되면 마지막 파일이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="6ec1c5712ad3f679b2da84284672de74a981a5d9" translate="yes" xml:space="preserve">
          <source>Before sourcing it, your script should set up a few variables; &lt;code&gt;USAGE&lt;/code&gt; (and &lt;code&gt;LONG_USAGE&lt;/code&gt;, if any) is used to define message given by &lt;code&gt;usage()&lt;/code&gt; shell function. &lt;code&gt;SUBDIRECTORY_OK&lt;/code&gt; can be set if the script can run from a subdirectory of the working tree (some commands do not).</source>
          <target state="translated">소싱하기 전에 스크립트는 몇 가지 변수를 설정해야합니다. &lt;code&gt;USAGE&lt;/code&gt; (및 &lt;code&gt;LONG_USAGE&lt;/code&gt; 라면)는 &lt;code&gt;usage()&lt;/code&gt; 쉘 함수에 의해 주어진 메시지를 정의하는데 사용됩니다 . 작업 트리의 하위 디렉토리에서 스크립트를 실행할 수있는 경우 &lt;code&gt;SUBDIRECTORY_OK&lt;/code&gt; 를 설정할 수 있습니다 (일부 명령은 그렇지 않음).</target>
        </trans-unit>
        <trans-unit id="c54227fb5e450fcf91fd096bb9f0a84e555b6148" translate="yes" xml:space="preserve">
          <source>Before starting rebase, stash local modifications away (see &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;) if needed, and apply the stash entry when done. &lt;code&gt;--no-autostash&lt;/code&gt; is useful to override the &lt;code&gt;rebase.autoStash&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">리베이스를 시작하기 전에 필요한 경우 로컬 수정을 숨기고 ( &lt;a href=&quot;git-stash&quot;&gt;git-stash [1] 참조&lt;/a&gt; ) 완료되면 숨김 항목을 적용하십시오. &lt;code&gt;--no-autostash&lt;/code&gt; 는 &lt;code&gt;rebase.autoStash&lt;/code&gt; 구성 변수 를 재정의하는 데 유용 합니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="20a98eb8f5ae5eb6921d2e55163fa9540eded227" translate="yes" xml:space="preserve">
          <source>Before starting, verify that there is corruption, and figure out where it is with &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt;; this may be time-consuming.</source>
          <target state="translated">시작하기 전에 손상이 있는지 확인하고 &lt;a href=&quot;git-fsck&quot;&gt;git-fsck [1]&lt;/a&gt; ; 시간이 오래 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="197ebbc21bdf962ed1c382324d4f3dcec04005ba" translate="yes" xml:space="preserve">
          <source>Before the colon may be anything that names a commit, and after it may be any path to a file tracked by Git.</source>
          <target state="translated">콜론 앞에는 커밋의 이름이 지정 될 수 있으며, 그 뒤에는 Git이 추적하는 파일의 경로가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b4c2c97b5d492d26987ff45d09af0bb0c545781" translate="yes" xml:space="preserve">
          <source>Behave as if &lt;code&gt;git rev-parse&lt;/code&gt; was invoked from the &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; subdirectory of the working tree. Any relative filenames are resolved as if they are prefixed by &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; and will be printed in that form.</source>
          <target state="translated">작업 트리 의 &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; 하위 디렉토리 에서 &lt;code&gt;git rev-parse&lt;/code&gt; 가 호출 된 것처럼 작동합니다. 상대 파일 이름은 &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; 로 시작하는 것처럼 확인 되며 해당 형식으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="d02e70ae5f9ffc8904b317a23e079b2151794572" translate="yes" xml:space="preserve">
          <source>Behave as normal citool, but instead of making a commit simply terminate with a zero exit code. It still checks that the index does not contain any unmerged entries, so you can use it as a GUI version of &lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool[1]&lt;/a&gt;</source>
          <target state="translated">일반적인 citool처럼 동작하지만 커밋을 만드는 대신 종료 코드 0으로 종료하면됩니다. 인덱스에 병합되지 않은 항목이 포함되어 있지 않은지 여전히 확인 &lt;a href=&quot;git-mergetool&quot;&gt;하므로 git-mergetool&lt;/a&gt; 의 GUI 버전으로 사용할 수 있습니다 [1]</target>
        </trans-unit>
        <trans-unit id="1e338425ed36637ba6fc8582364ec79dbafaa8d3" translate="yes" xml:space="preserve">
          <source>Behavioral differences</source>
          <target state="translated">행동 차이</target>
        </trans-unit>
        <trans-unit id="f0f0d8dfa2a076d1fea883054912f530ebc927c2" translate="yes" xml:space="preserve">
          <source>Besides blobs, trees, and commits, the only remaining type of object is a &quot;tag&quot;, which we won&amp;rsquo;t discuss here; refer to &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; for details.</source>
          <target state="translated">얼룩, 나무 및 커밋 외에도 남아있는 유일한 유형의 개체는 &quot;태그&quot;이며 여기서는 설명하지 않습니다. 자세한 내용은 &lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6077f120aaceb5046721fb58c100f8432db9b449" translate="yes" xml:space="preserve">
          <source>Besides specifying a range of commits that should be listed using the special notations explained in the description, additional commit limiting may be applied.</source>
          <target state="translated">설명에 설명 된 특수 표기법을 사용하여 나열해야하는 커밋 범위를 지정하는 것 외에도 추가 커밋 제한이 적용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d284c47fc77be8e46a6b104d3f25aff12fd50b7" translate="yes" xml:space="preserve">
          <source>Best bisecting practices</source>
          <target state="translated">최상의 이등분 관행</target>
        </trans-unit>
        <trans-unit id="6bc3ae89d4cbb3ba42878fb25652862ae42aa5fe" translate="yes" xml:space="preserve">
          <source>Beware that the default for &lt;code&gt;git send-email&lt;/code&gt; is to thread emails itself. If you want &lt;code&gt;git format-patch&lt;/code&gt; to take care of threading, you will want to ensure that threading is disabled for &lt;code&gt;git send-email&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git send-email&lt;/code&gt; 의 기본값은 이메일 자체를 스레드하는 것입니다. 당신이 원하는 경우 &lt;code&gt;git format-patch&lt;/code&gt; 스레딩 돌봐, 당신은 스레딩가 비활성화되어 있는지 확인하는 것이 좋습니다 &lt;code&gt;git send-email&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="945fefcb0d1953c9bddf033fe3e99288cf86cd4d" translate="yes" xml:space="preserve">
          <source>Bidirectional operation between a Subversion repository and Git</source>
          <target state="translated">Subversion 저장소와 Git 간의 양방향 작업</target>
        </trans-unit>
        <trans-unit id="6f22ed9717123d2ce9d3d667f975fb97ec48ef54" translate="yes" xml:space="preserve">
          <source>Binary files are searched as well.</source>
          <target state="translated">이진 파일도 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="8e08702a04bb0e3631c0db1c03ac41d9b78e02c9" translate="yes" xml:space="preserve">
          <source>Bisect log and bisect replay</source>
          <target state="translated">이등분 로그 및 이등분 재생</target>
        </trans-unit>
        <trans-unit id="caafd94a0cc48f8af98290661863ae3463dcd188" translate="yes" xml:space="preserve">
          <source>Bisect reset</source>
          <target state="translated">이등분 재설정</target>
        </trans-unit>
        <trans-unit id="cfe9732e61ea56b98e10d88f828ff42f6e52d08e" translate="yes" xml:space="preserve">
          <source>Bisect run</source>
          <target state="translated">이등분 달리기</target>
        </trans-unit>
        <trans-unit id="e7eb00dc48d63079c3871fc0a679fc1160511d2f" translate="yes" xml:space="preserve">
          <source>Bisect skip</source>
          <target state="translated">이등분 건너 뛰기</target>
        </trans-unit>
        <trans-unit id="5887bb0558b5608c8166ca0492b459bf81b4ac9e" translate="yes" xml:space="preserve">
          <source>Bisect visualize/view</source>
          <target state="translated">Bisect 시각화 /보기</target>
        </trans-unit>
        <trans-unit id="5adebf631a26d512accb5dd4088829dcb8650be4" translate="yes" xml:space="preserve">
          <source>Bisecting between Z and D* would hit a single culprit commit Y*, and understanding why Y* was broken would probably be easier.</source>
          <target state="translated">Z와 D * 사이의 이등분은 단일 범인 커밋 Y *에 영향을 미치며, Y *가 왜 깨 졌는지 이해하는 것이 더 쉬울 것입니다.</target>
        </trans-unit>
        <trans-unit id="e52337c43cc4b33ac0d524be43e0ee7aabfe896f" translate="yes" xml:space="preserve">
          <source>Bisecting build failures</source>
          <target state="translated">이등분 빌드 실패</target>
        </trans-unit>
        <trans-unit id="247595ab20eacd2b287d2671e0cd44ffe5d63f96" translate="yes" xml:space="preserve">
          <source>Bisecting sporadic bugs</source>
          <target state="translated">산발적 인 버그의 이등분</target>
        </trans-unit>
        <trans-unit id="c849a8d6d5f17f13126d2a3ffa47e78949cbd571" translate="yes" xml:space="preserve">
          <source>Bisection Helpers</source>
          <target state="translated">이분법 도우미</target>
        </trans-unit>
        <trans-unit id="81ab75db6833dc6c35d461635f7c0fa8e4339b5c" translate="yes" xml:space="preserve">
          <source>Bisection algorithm</source>
          <target state="translated">이분법 알고리즘</target>
        </trans-unit>
        <trans-unit id="1073b9bc85c670179e7dcf4cfd5cd0b022c46d78" translate="yes" xml:space="preserve">
          <source>Bisection algorithm debugging</source>
          <target state="translated">이분법 알고리즘 디버깅</target>
        </trans-unit>
        <trans-unit id="2146a76855ff13537405bb4dc1d3e621b6d2530e" translate="yes" xml:space="preserve">
          <source>Bisection algorithm discussed</source>
          <target state="translated">이분법 알고리즘 논의</target>
        </trans-unit>
        <trans-unit id="3e65a55a7b3fcaab5f39381d806f63fcab2ecabb" translate="yes" xml:space="preserve">
          <source>BitKeeper/cvsps speak for &quot;&lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt;&quot;. Since Git does not store changes, but states, it really does not make sense to use the term &quot;changesets&quot; with Git.</source>
          <target state="translated">BitKeeper / cvsp는 &quot; &lt;a href=&quot;#def_commit&quot;&gt;커밋&lt;/a&gt; &quot;을 말합니다. Git은 변경 사항을 저장하지 않지만 상태를 나타내므로 Git과 함께 &quot;changesets&quot;라는 용어를 사용하는 것은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="57bd2a9f31bd11a6f563b358aadd2a286592b86a" translate="yes" xml:space="preserve">
          <source>Blank lines are ignored, and lines that don&amp;rsquo;t match this specification are used as option group headers (start the line with a space to create such lines on purpose).</source>
          <target state="translated">빈 줄은 무시되고이 사양과 일치하지 않는 줄은 옵션 그룹 헤더로 사용됩니다 (공백으로 시작하여 의도적으로 이러한 줄을 만듭니다).</target>
        </trans-unit>
        <trans-unit id="5327cbfdb1bf8f5a47bca233a1bde391d44b215a" translate="yes" xml:space="preserve">
          <source>Blank lines are ignored, so they can be used as separators for readability.</source>
          <target state="translated">빈 줄은 무시되므로 가독성을 위해 구분 기호로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7077b7354ef7afaa6b1de41b77813742be4c707" translate="yes" xml:space="preserve">
          <source>Blob Object</source>
          <target state="translated">블롭 객체</target>
        </trans-unit>
        <trans-unit id="f04feb5337017d625e39e5a69c692bf6273fb704" translate="yes" xml:space="preserve">
          <source>Blocks of moved text are detected as in &lt;code&gt;blocks&lt;/code&gt; mode. The blocks are painted using either the &lt;code&gt;color.diff.{old,new}Moved&lt;/code&gt; color or &lt;code&gt;color.diff.{old,new}MovedAlternative&lt;/code&gt;. The change between the two colors indicates that a new block was detected.</source>
          <target state="translated">이동 한 텍스트 블록은 &lt;code&gt;blocks&lt;/code&gt; 모드 에서와 같이 감지 됩니다. 블록은 &lt;code&gt;color.diff.{old,new}Moved&lt;/code&gt; 색상 또는 &lt;code&gt;color.diff.{old,new}MovedAlternative&lt;/code&gt; 를 사용하여 페인팅 됩니다. 두 색상 사이의 변화는 새로운 블록이 감지되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f42755e1f80735be0fde7ac7e2cbeb956df2c96e" translate="yes" xml:space="preserve">
          <source>Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the &lt;code&gt;color.diff.{old,new}Moved&lt;/code&gt; color. Adjacent blocks cannot be told apart.</source>
          <target state="translated">20 자 이상의 영숫자로 이동 한 텍스트 블록이 탐욕스럽게 감지됩니다. 감지 된 블록은 &lt;code&gt;color.diff.{old,new}Moved&lt;/code&gt; 색상을 사용하여 페인팅됩니다 . 인접한 블록은 구분할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="66547f4a0e63cd4ad00756855db6ddba1142e4d3" translate="yes" xml:space="preserve">
          <source>Bob begins with:</source>
          <target state="translated">밥은 다음과 같이 시작합니다.</target>
        </trans-unit>
        <trans-unit id="bcf42567e6f70a4579bf8687eb5f4e62c5870c89" translate="yes" xml:space="preserve">
          <source>Bob then makes some changes and commits them:</source>
          <target state="translated">그런 다음 Bob은 몇 가지 사항을 변경하고 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="d0685c88b15694d30796d8493ed6c8ce3e6b4b74" translate="yes" xml:space="preserve">
          <source>Boolean false literals are &lt;code&gt;no&lt;/code&gt;, &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt; and the empty string.</source>
          <target state="translated">부울 false 리터럴은 &lt;code&gt;no&lt;/code&gt; , &lt;code&gt;off&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; 및 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="c8e93181a2c2334cd611c796a9d2346e913aadda" translate="yes" xml:space="preserve">
          <source>Boolean true literals are &lt;code&gt;yes&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;1&lt;/code&gt;. Also, a variable defined without &lt;code&gt;= &amp;lt;value&amp;gt;&lt;/code&gt; is taken as true.</source>
          <target state="translated">부울 true 리터럴은 &lt;code&gt;yes&lt;/code&gt; , &lt;code&gt;on&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;1&lt;/code&gt; 입니다. 또한 &lt;code&gt;= &amp;lt;value&amp;gt;&lt;/code&gt; 없이 정의 된 변수 는 true로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f03ce708ae8563bbe292f147105bcbebd35fdd1f" translate="yes" xml:space="preserve">
          <source>Boolean value indicating if the submodule is of interest to git commands. This config option takes precedence over the submodule.active config option. See &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt; for details.</source>
          <target state="translated">서브 모듈이 git 명령에 관심이 있는지를 나타내는 부울 값. 이 구성 옵션은 submodule.active 구성 옵션보다 우선합니다. 자세한 내용은 &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules [7]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="40de397dbe4a181644b13a510b500ba0dfa90dc8" translate="yes" xml:space="preserve">
          <source>Boolean variable which defines if large files are automatically pushed to a server.</source>
          <target state="translated">큰 파일을 서버로 자동 푸시할지 여부를 정의하는 부울 변수입니다.</target>
        </trans-unit>
        <trans-unit id="edb8137a3de82e7f1ab7c05bad252ac0da09a46a" translate="yes" xml:space="preserve">
          <source>Boolean. When true &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;filename&lt;/code&gt;, and &lt;code&gt;line&lt;/code&gt; fields are omitted from PERF output. May be overridden by the &lt;code&gt;GIT_TRACE2_PERF_BRIEF&lt;/code&gt; environment variable. Defaults to false.</source>
          <target state="translated">부울. 실제 &lt;code&gt;time&lt;/code&gt; 경우 &lt;code&gt;filename&lt;/code&gt; 및 &lt;code&gt;line&lt;/code&gt; 필드는 PERF 출력에서 ​​생략됩니다. &lt;code&gt;GIT_TRACE2_PERF_BRIEF&lt;/code&gt; 환경 변수 로 대체 될 수 있습니다 . 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="e7da8527471f3ea2c3faf910dfb4b6accdd8c262" translate="yes" xml:space="preserve">
          <source>Boolean. When true &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;filename&lt;/code&gt;, and &lt;code&gt;line&lt;/code&gt; fields are omitted from event output. May be overridden by the &lt;code&gt;GIT_TRACE2_EVENT_BRIEF&lt;/code&gt; environment variable. Defaults to false.</source>
          <target state="translated">부울. 실제 &lt;code&gt;time&lt;/code&gt; 경우 &lt;code&gt;filename&lt;/code&gt; 및 &lt;code&gt;line&lt;/code&gt; 필드가 이벤트 출력에서 ​​생략됩니다. &lt;code&gt;GIT_TRACE2_EVENT_BRIEF&lt;/code&gt; 환경 변수 로 대체 될 수 있습니다 . 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="d6cb13ebbd3c085c01cd755d0c697831e337b51f" translate="yes" xml:space="preserve">
          <source>Boolean. When true &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;filename&lt;/code&gt;, and &lt;code&gt;line&lt;/code&gt; fields are omitted from normal output. May be overridden by the &lt;code&gt;GIT_TRACE2_BRIEF&lt;/code&gt; environment variable. Defaults to false.</source>
          <target state="translated">부울. 실제 &lt;code&gt;time&lt;/code&gt; 경우 &lt;code&gt;filename&lt;/code&gt; 및 &lt;code&gt;line&lt;/code&gt; 필드는 일반 출력에서 ​​생략됩니다. &lt;code&gt;GIT_TRACE2_BRIEF&lt;/code&gt; 환경 변수 로 대체 될 수 있습니다 . 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="2c3dcfd71724f2fb257997b8beb70ed9ac8363b1" translate="yes" xml:space="preserve">
          <source>Boolean. When true Git will print error messages when a trace target destination cannot be opened for writing. By default, these errors are suppressed and tracing is silently disabled. May be overridden by the &lt;code&gt;GIT_TRACE2_DST_DEBUG&lt;/code&gt; environment variable.</source>
          <target state="translated">부울. true 인 경우 추적 대상 대상을 쓰기 위해 열 수없는 경우 Git에서 오류 메시지를 인쇄합니다. 기본적으로 이러한 오류는 억제되고 추적은 자동으로 비활성화됩니다. &lt;code&gt;GIT_TRACE2_DST_DEBUG&lt;/code&gt; 환경 변수 로 대체 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5522e55cd06bc09c2f312c8e91e3e9369d6fed7" translate="yes" xml:space="preserve">
          <source>Borrow the objects from reference repositories specified with the &lt;code&gt;--reference&lt;/code&gt; options only to reduce network transfer, and stop borrowing from them after a clone is made by making necessary local copies of borrowed objects. This option can also be used when cloning locally from a repository that already borrows objects from another repository&amp;mdash;​the new repository will borrow objects from the same repository, and this option can be used to stop the borrowing.</source>
          <target state="translated">&lt;code&gt;--reference&lt;/code&gt; 옵션으로 지정된 참조 리포지토리에서 개체를 빌려 네트워크 전송을 줄이고, 빌린 개체의 필요한 로컬 복사본을 만들어 복제 한 후에는 빌린 것을 중지합니다. 이 옵션은 이미 다른 리포지토리에서 개체를 빌린 리포지토리에서 로컬로 복제 할 때도 사용할 수 있습니다. 새 리포지토리는 동일한 리포지토리에서 개체를 빌리 며이 옵션을 사용하여 빌리기를 중지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5694355a4e9f21af75bfd457be1c695646467936" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;--cacheinfo&lt;/code&gt; and &lt;code&gt;--info-only&lt;/code&gt; behave similarly: the index is updated but the object database isn&amp;rsquo;t. &lt;code&gt;--cacheinfo&lt;/code&gt; is useful when the object is in the database but the file isn&amp;rsquo;t available locally. &lt;code&gt;--info-only&lt;/code&gt; is useful when the file is available, but you do not wish to update the object database.</source>
          <target state="translated">두 &lt;code&gt;--cacheinfo&lt;/code&gt; 및 &lt;code&gt;--info-only&lt;/code&gt; 유사하게 동작 : 인덱스를 업데이트하지만 객체 데이터베이스가 없습니다. &lt;code&gt;--cacheinfo&lt;/code&gt; 는 객체가 데이터베이스에 있지만 파일을 로컬에서 사용할 수없는 경우에 유용합니다. &lt;code&gt;--info-only&lt;/code&gt; 는 파일을 사용할 수있는 경우 에 유용하지만 객체 데이터베이스를 업데이트하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="210e82ac599d9d8944e3c5eb9d03d4a4abcf7207" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;plink&lt;/code&gt; and &lt;code&gt;alink&lt;/code&gt; point outside the tree, so they would respectively print:</source>
          <target state="translated">&lt;code&gt;plink&lt;/code&gt; 와 &lt;code&gt;alink&lt;/code&gt; 는 모두 트리 외부를 가리 키므로 각각 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="9a953a9b4782d5c56832edbe239c8ec4aaa470f8" translate="yes" xml:space="preserve">
          <source>Both fixes are tested well, and at this point, you want to merge in both of them. You could merge in &lt;code&gt;diff-fix&lt;/code&gt; first and then &lt;code&gt;commit-fix&lt;/code&gt; next, like this:</source>
          <target state="translated">두 수정 프로그램은 모두 잘 테스트되었으며이 시점에서 둘 다 병합하려고합니다. 다음과 같이 &lt;code&gt;diff-fix&lt;/code&gt; 를 먼저 병합 한 다음 &lt;code&gt;commit-fix&lt;/code&gt; 를 다음에 병합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9af6db9f29dd4e151f33497260a5a0b8ba4e0513" translate="yes" xml:space="preserve">
          <source>Both ofs-delta and ref-delta store the &quot;delta&quot; to be applied to another object (called &lt;code&gt;base object&lt;/code&gt;) to reconstruct the object. The difference between them is, ref-delta directly encodes 20-byte base object name. If the base object is in the same pack, ofs-delta encodes the offset of the base object in the pack instead.</source>
          <target state="translated">of-delta와 ref-delta는 모두 &lt;code&gt;base object&lt;/code&gt; 를 재구성 하기 위해 다른 객체 ( 기본 객체 라고 함)에 적용 할 &quot;델타&quot;를 저장 합니다. 차이점은 ref-delta는 20 바이트 기본 객체 이름을 직접 인코딩한다는 것입니다. 기본 개체가 같은 팩에 있으면 ofs-delta는 팩에서 기본 개체의 오프셋을 대신 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="70067b173cdeaaf22d52d43a160f5295eccba4fc" translate="yes" xml:space="preserve">
          <source>Both ofs-delta and ref-delta store the &quot;delta&quot; to be applied to another object (called &lt;code&gt;base object&lt;/code&gt;) to reconstruct the object. The difference between them is, ref-delta directly encodes base object name. If the base object is in the same pack, ofs-delta encodes the offset of the base object in the pack instead.</source>
          <target state="translated">ofs-delta와 ref-delta는 모두 &lt;code&gt;base object&lt;/code&gt; 를 재구성 하기 위해 다른 객체 ( 기본 객체 라고 함)에 적용 할 &quot;델타&quot;를 저장 합니다. 차이점은 ref-delta가 기본 개체 이름을 직접 인코딩한다는 것입니다. 기본 개체가 동일한 팩에있는 경우 ofs-delta는 대신 팩에있는 기본 개체의 오프셋을 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="b68fc1d55d49e0827f78d9949a9c5a2eecaf05eb" translate="yes" xml:space="preserve">
          <source>Both settings can be overridden on the command line by using the &quot;--ignore-submodules&quot; option. The &lt;code&gt;git submodule&lt;/code&gt; commands are not affected by this setting.</source>
          <target state="translated">&quot;--ignore-submodules&quot;옵션을 사용하여 명령 행에서 두 설정을 모두 무시할 수 있습니다. &lt;code&gt;git submodule&lt;/code&gt; 명령이 설정의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2bb1e035fa86f5b4222d3ab1eb33c1658eed9a23" translate="yes" xml:space="preserve">
          <source>Both standard output and standard error output are forwarded to &lt;code&gt;git send-pack&lt;/code&gt; on the other end, so you can simply &lt;code&gt;echo&lt;/code&gt; messages for the user.</source>
          <target state="translated">표준 출력 및 표준 오류 출력은 다른 쪽 끝의 &lt;code&gt;git send-pack&lt;/code&gt; 으로 전달 되므로 사용자에게 메시지를 간단히 &lt;code&gt;echo&lt;/code&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c76084a5f517b3242aa149971fbcce3ceb62c61" translate="yes" xml:space="preserve">
          <source>Both the &amp;lt;eolinfo&amp;gt; in the index (&quot;i/&amp;lt;eolinfo&amp;gt;&quot;) and in the working tree (&quot;w/&amp;lt;eolinfo&amp;gt;&quot;) are shown for regular files, followed by the (&quot;attr/&amp;lt;eolattr&amp;gt;&quot;).</source>
          <target state="translated">색인 ( &quot;i / &amp;lt;eolinfo&amp;gt;&quot;) 및 작업 트리 ( &quot;w / &amp;lt;eolinfo&amp;gt;&quot;)의 &amp;lt;eolinfo&amp;gt;는 모두 일반 파일에 대해 표시되고 그 뒤에 ( &quot;attr / &amp;lt;eolattr&amp;gt;&quot;)가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c634179a023801afb75e60cfb7d88f35c1e83a21" translate="yes" xml:space="preserve">
          <source>Both the symlink &amp;amp; realpath versions of paths will be matched outside of &lt;code&gt;$GIT_DIR&lt;/code&gt;. E.g. if ~/git is a symlink to /mnt/storage/git, both &lt;code&gt;gitdir:~/git&lt;/code&gt; and &lt;code&gt;gitdir:/mnt/storage/git&lt;/code&gt; will match.</source>
          <target state="translated">경로의 심볼릭 링크와 리얼 패스 버전은 &lt;code&gt;$GIT_DIR&lt;/code&gt; 외부에서 일치 합니다. 예를 들어 ~ / git이 / mnt / storage / git에 대한 심볼릭 링크 인 경우 &lt;code&gt;gitdir:~/git&lt;/code&gt; 와 &lt;code&gt;gitdir:/mnt/storage/git&lt;/code&gt; 가 모두 일치합니다.</target>
        </trans-unit>
        <trans-unit id="fb26b800dd56fd61a55a4281547b9e60ac65a113" translate="yes" xml:space="preserve">
          <source>Branch Headers</source>
          <target state="translated">분기 헤더</target>
        </trans-unit>
        <trans-unit id="6e15a503d2a4c17b67a8c3c7f34c58a07a49a276" translate="yes" xml:space="preserve">
          <source>Branch description, can be edited with &lt;code&gt;git branch --edit-description&lt;/code&gt;. Branch description is automatically added in the format-patch cover letter or request-pull summary.</source>
          <target state="translated">분기 설명은 &lt;code&gt;git branch --edit-description&lt;/code&gt; 으로 편집 할 수 있습니다 . 지점 설명은 형식-패치 표지 또는 요청-풀 요약에 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5bec4527e15afa13a84c736e3c723988984e6324" translate="yes" xml:space="preserve">
          <source>Branch detection</source>
          <target state="translated">분기 감지</target>
        </trans-unit>
        <trans-unit id="f63ceca75fd06c6b871dea1a79cac70839c63882" translate="yes" xml:space="preserve">
          <source>Branch management for a release</source>
          <target state="translated">릴리스를위한 지점 관리</target>
        </trans-unit>
        <trans-unit id="50637014a89740451f5074b5c0e9645bb5f5e1e3" translate="yes" xml:space="preserve">
          <source>Branch management for next and pu after a feature release</source>
          <target state="translated">기능 릴리스 후 다음 및 PU에 대한 지점 관리</target>
        </trans-unit>
        <trans-unit id="847b5d9af115c8e50f1c00175c8525563c7e932f" translate="yes" xml:space="preserve">
          <source>Branch management for next and seen after a feature release</source>
          <target state="translated">다음을위한 지점 관리 및 기능 출시 후 확인</target>
        </trans-unit>
        <trans-unit id="cbca9c5458a752e67c3b22c7754c8dd03612ff9c" translate="yes" xml:space="preserve">
          <source>Branch of repository to add as submodule. The name of the branch is recorded as &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; in &lt;code&gt;.gitmodules&lt;/code&gt; for &lt;code&gt;update --remote&lt;/code&gt;. A special value of &lt;code&gt;.&lt;/code&gt; is used to indicate that the name of the branch in the submodule should be the same name as the current branch in the current repository. If the option is not specified, it defaults to &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">하위 모듈로 추가 할 저장소의 분기입니다. 지점의 이름으로 기록되어 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; 에서 &lt;code&gt;.gitmodules&lt;/code&gt; 에 대한 &lt;code&gt;update --remote&lt;/code&gt; . 의 특별한 가치 &lt;code&gt;.&lt;/code&gt; 하위 모듈의 분기 이름이 현재 저장소의 현재 분기 이름과 같아야 함을 나타내는 데 사용됩니다. 이 옵션을 지정하지 않으면 기본값은 &lt;code&gt;master&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b69ea5570ecde693b275ccf40b6be842c78a8726" translate="yes" xml:space="preserve">
          <source>Branch of repository to add as submodule. The name of the branch is recorded as &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; in &lt;code&gt;.gitmodules&lt;/code&gt; for &lt;code&gt;update --remote&lt;/code&gt;. A special value of &lt;code&gt;.&lt;/code&gt; is used to indicate that the name of the branch in the submodule should be the same name as the current branch in the current repository. If the option is not specified, it defaults to the remote &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">하위 모듈로 추가 할 저장소의 분기입니다. 지점의 이름으로 기록되어 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; 에서 &lt;code&gt;.gitmodules&lt;/code&gt; 에 대한 &lt;code&gt;update --remote&lt;/code&gt; . 특수 값 &lt;code&gt;.&lt;/code&gt; 서브 모듈에있는 브랜치의 이름이 현재 저장소의 현재 브랜치와 같은 이름이어야 함을 나타내는 데 사용됩니다. 옵션이 지정되지 않은 경우 기본값은 원격 &lt;code&gt;HEAD&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e3db6088987588160d14194fc92edec728f16ab3" translate="yes" xml:space="preserve">
          <source>Branch off of a specific tag.</source>
          <target state="translated">특정 태그에서 분기합니다.</target>
        </trans-unit>
        <trans-unit id="a41d6fc58b77cd15fdc95f9b8068f3bedb454bc6" translate="yes" xml:space="preserve">
          <source>Branch to checkout; if it refers to a branch (i.e., a name that, when prepended with &quot;refs/heads/&quot;, is a valid ref), then that branch is checked out. Otherwise, if it refers to a valid commit, your &lt;code&gt;HEAD&lt;/code&gt; becomes &quot;detached&quot; and you are no longer on any branch (see below for details).</source>
          <target state="translated">체크 아웃 할 지점; 분기를 참조하는 경우 (즉, &quot;refs / heads /&quot;가 앞에 붙을 때 유효한 참조 인 이름) 해당 분기가 체크 아웃됩니다. 그렇지 않으면 유효한 커밋을 참조하면 &lt;code&gt;HEAD&lt;/code&gt; 가 &quot;분리&quot;되고 더 이상 지점에 있지 않습니다 (자세한 내용은 아래 참조).</target>
        </trans-unit>
        <trans-unit id="8b21526e9a7ba9f6110db09d1bb17e93bbda77fa" translate="yes" xml:space="preserve">
          <source>Branch to switch to.</source>
          <target state="translated">전환 할 지점입니다.</target>
        </trans-unit>
        <trans-unit id="79cd2f09f7574ee3c255526cc9dfc53740a35d6b" translate="yes" xml:space="preserve">
          <source>Branch updates can be forced with --force, but it&amp;rsquo;s recommended that this only be used on an otherwise quiet repository. Using --force is not necessary for an initial import into an empty repository.</source>
          <target state="translated">분기 업데이트는 --force를 사용하여 강제 할 수 있지만 다른 조용한 저장소에서만 사용하는 것이 좋습니다. 빈 저장소로 초기 가져 오기에는 --force를 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e985dfb396afc27ce07bbb1b298aa21e35e0ea0d" translate="yes" xml:space="preserve">
          <source>Branches are cheap and easy, so this is a good way to try something out.</source>
          <target state="translated">지점은 저렴하고 쉬우므로 시도해 볼 수있는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="879b754d99bf64defbd79d89d51b97c6e52dfbf4" translate="yes" xml:space="preserve">
          <source>Branches are classified as active and inactive. The memory usage of the two classes is significantly different.</source>
          <target state="translated">지점은 활성 및 비활성으로 분류됩니다. 두 클래스의 메모리 사용량은 크게 다릅니다.</target>
        </trans-unit>
        <trans-unit id="19038dfa38a59c4f1be05e3d92e0f1bca8b5557f" translate="yes" xml:space="preserve">
          <source>Branches in Git are really nothing more than pointers into the Git object database from within the &lt;code&gt;.git/refs/&lt;/code&gt; subdirectory, and as we already discussed, the &lt;code&gt;HEAD&lt;/code&gt; branch is nothing but a symlink to one of these object pointers.</source>
          <target state="translated">Git의 브랜치는 실제로 &lt;code&gt;.git/refs/&lt;/code&gt; 서브 디렉토리 내에서 Git 오브젝트 데이터베이스에 대한 포인터에 지나지 않으며 &lt;code&gt;HEAD&lt;/code&gt; 브랜치는 이러한 오브젝트 포인터 중 하나에 대한 심볼릭 링크 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="125404877d39f029f0e27e0fb84f104c52bd667b" translate="yes" xml:space="preserve">
          <source>Branches on which no commits have been made are not imported.</source>
          <target state="translated">커밋이 수행되지 않은 지점은 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="415a16be057cec5701bb9e0fd3bff5400f270979" translate="yes" xml:space="preserve">
          <source>Branches, remote-tracking branches, and tags are all references to commits. All references are named with a slash-separated path name starting with &lt;code&gt;refs&lt;/code&gt;; the names we&amp;rsquo;ve been using so far are actually shorthand:</source>
          <target state="translated">브랜치, 원격 추적 브랜치 및 태그는 모두 커밋에 대한 참조입니다. 모든 참조는 &lt;code&gt;refs&lt;/code&gt; 로 시작하는 슬래시로 구분 된 경로 이름으로 이름이 지정됩니다 . 지금까지 사용했던 이름은 실제로는 속기입니다.</target>
        </trans-unit>
        <trans-unit id="b3d9b26ec0345692adbda512336186fddd0ce297" translate="yes" xml:space="preserve">
          <source>Branching and Merging</source>
          <target state="translated">분기 및 병합</target>
        </trans-unit>
        <trans-unit id="15e01902c81d07c3b90042ff2531422b8b3d1b86" translate="yes" xml:space="preserve">
          <source>Break complete rewrite changes into pairs of delete and create. This serves two purposes:</source>
          <target state="translated">완전한 다시 쓰기 변경 사항을 삭제 및 작성 쌍으로 나눕니다. 이것은 두 가지 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="672fc0738ea8c1007bcaceee5284378a52766797" translate="yes" xml:space="preserve">
          <source>Browse the &lt;code&gt;modules&lt;/code&gt; available. It will give you a list of the heads in the repository. You will not be able to browse the tree from there. Only the heads.</source>
          <target state="translated">사용 가능한 &lt;code&gt;modules&lt;/code&gt; 찾아보십시오 . 리포지토리의 헤드 목록을 제공합니다. 거기에서 트리를 탐색 할 수 없습니다. 머리 만</target>
        </trans-unit>
        <trans-unit id="abb2e552cc2091e364809101c300cc4143caaa39" translate="yes" xml:space="preserve">
          <source>Browsing every revision of the repository.</source>
          <target state="translated">리포지토리의 모든 개정을 찾아 봅니다.</target>
        </trans-unit>
        <trans-unit id="f92f422e95f0fd94e3584d36660177eaf6c3a90d" translate="yes" xml:space="preserve">
          <source>Browsing revisions</source>
          <target state="translated">찾아보기 수정</target>
        </trans-unit>
        <trans-unit id="6d55509876929eae63b680c2015c0e8dcd714d8d" translate="yes" xml:space="preserve">
          <source>Buffering happens as documented under the &lt;code&gt;GIT_FLUSH&lt;/code&gt; option in &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;. The caller is responsible for avoiding deadlocks caused by overfilling an input buffer or reading from an empty output buffer.</source>
          <target state="translated">버퍼링 은 &lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; 의 &lt;code&gt;GIT_FLUSH&lt;/code&gt; 옵션에 설명되어 있습니다. 호출자는 입력 버퍼를 가득 채우거나 빈 출력 버퍼를 읽음으로써 발생하는 교착 상태를 피할 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="30410812dc9752c13886986132ffab9500651b55" translate="yes" xml:space="preserve">
          <source>Bugs in the implementation of overlap mappings exist. If multiple depot paths map through overlays to the same location in the repository, &lt;code&gt;git p4&lt;/code&gt; can choose the wrong one. This is hard to solve without dedicating a client spec just for &lt;code&gt;git p4&lt;/code&gt;.</source>
          <target state="translated">오버랩 매핑 구현에 버그가 있습니다. 여러 저장소 경로가 오버레이를 통해 저장소의 동일한 위치에 맵핑되면 &lt;code&gt;git p4&lt;/code&gt; 가 잘못된 경로를 선택할 수 있습니다. 이것은 &lt;code&gt;git p4&lt;/code&gt; 전용 클라이언트 사양을 지정하지 않고 해결하기가 어렵습니다 .</target>
        </trans-unit>
        <trans-unit id="8c875875a4eba5d2b4104ba5b53fe3484e74b27e" translate="yes" xml:space="preserve">
          <source>Build a tree-object from ls-tree formatted text</source>
          <target state="translated">ls-tree 형식의 텍스트에서 나무 개체 만들기</target>
        </trans-unit>
        <trans-unit id="043dc36933914b47740e7f5065ce440656dbe0ca" translate="yes" xml:space="preserve">
          <source>Build pack index file for an existing packed archive</source>
          <target state="translated">기존 압축 아카이브에 대한 빌드 팩 색인 파일</target>
        </trans-unit>
        <trans-unit id="8dd0ad60c49a72540d98588b5b0558fd314e85ee" translate="yes" xml:space="preserve">
          <source>Built-in 3-way merge driver is used to merge the contents in a way similar to &lt;code&gt;merge&lt;/code&gt; command of &lt;code&gt;RCS&lt;/code&gt; suite. This is suitable for ordinary text files.</source>
          <target state="translated">내장 3 웨이 병합 드라이버는 &lt;code&gt;RCS&lt;/code&gt; 제품군의 &lt;code&gt;merge&lt;/code&gt; 명령 과 유사한 방식으로 내용을 병합하는 데 사용됩니다 . 일반 텍스트 파일에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="0829c07e98ca5098038c31cb2a5b51c3902a8814" translate="yes" xml:space="preserve">
          <source>Built-in merge drivers</source>
          <target state="translated">내장 된 병합 드라이버</target>
        </trans-unit>
        <trans-unit id="fe507ac4ab5d31826c1b03d804bf3ff265bad65b" translate="yes" xml:space="preserve">
          <source>Bundling your work together</source>
          <target state="translated">함께 작업 묶기</target>
        </trans-unit>
        <trans-unit id="25fde7a2ceaafceba047201a41d303d6c07bd23d" translate="yes" xml:space="preserve">
          <source>But BBChop is independent of any VCS and it would be easier for Git users to have something integrated in Git.</source>
          <target state="translated">그러나 BBChop은 어떤 VCS 와도 독립적이며 Git 사용자가 Git에 통합하는 것이 더 쉬울 것입니다.</target>
        </trans-unit>
        <trans-unit id="f7eefc5fb4183d567fceb246626226ef9afb8bf2" translate="yes" xml:space="preserve">
          <source>But Ingo Molnar and H. Peter Anvin (another well known linux kernel developer) both complained that sometimes the best bisection points all happened to be in an area where all the commits are untestable. And in this case the user was asked to test many untestable commits, which could be very inefficient.</source>
          <target state="translated">그러나 Ingo Molnar와 H. Peter Anvin (또 다른 잘 알려진 리눅스 커널 개발자)은 때때로 모든 최고의 커밋을 테스트 할 수없는 영역에있는 최고의 이등 점이 있다고 불평했습니다. 이 경우 사용자에게는 테스트 할 수없는 많은 커밋을 테스트하라는 요청을 받았으며 이는 매우 비효율적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74140d3773084e209fc43c63f870a2ce5abd4ea1" translate="yes" xml:space="preserve">
          <source>But if you have pushed things out (or others could just read your repository directly), then others will have already seen the old tag. In that case you can do one of two things:</source>
          <target state="translated">그러나 당신이 물건을 밀어 내면 (또는 다른 사람들이 저장소를 직접 읽을 수 있음) 다른 사람들은 이미 이전 태그를 보았을 것입니다. 이 경우 다음 두 가지 중 하나를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66013f3cefed95fb73f834fded3820e6a1071c28" translate="yes" xml:space="preserve">
          <source>But if you try to push, you will attempt to update the branch (that now points at A) with commit B. This does &lt;code&gt;not&lt;/code&gt; fast-forward. If you did so, the changes introduced by commit A will be lost, because everybody will now start building on top of B.</source>
          <target state="translated">그러나 푸시하려고하면 커밋 B로 분기 (현재 A를 가리킴)를 업데이트하려고 시도합니다. 이것은 빨리 진행 되지 &lt;code&gt;not&lt;/code&gt; . 그렇게하면 커밋 A가 도입 한 변경 사항이 손실됩니다. 모든 사람이 이제 B 위에 구축하기 시작하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="fd8e45cbd58877735e25105978c0aca9791da6ee" translate="yes" xml:space="preserve">
          <source>But in some repository setups, you may have several related but separate groups of ref tips, with clients tending to fetch those groups independently. For example, imagine that you are hosting several &quot;forks&quot; of a repository in a single shared object store, and letting clients view them as separate repositories through &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; or separate repos using the alternates mechanism. A naive repack may find that the optimal delta for an object is against a base that is only found in another fork. But when a client fetches, they will not have the base object, and we&amp;rsquo;ll have to find a new delta on the fly.</source>
          <target state="translated">그러나 일부 리포지토리 설정에서는 클라이언트가 해당 그룹을 독립적으로 가져 오는 경향이있는 여러 관련 있지만 별도의 참조 팁 그룹이있을 수 있습니다. 예를 들어 단일 공유 객체 저장소에 여러 &quot;포크&quot;저장소를 호스팅하고 있으며 클라이언트가 &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; 를 통해 별도의 저장소로 보거나 대체 메커니즘을 사용하여 별도의 저장소로 볼 수 있다고 가정 해보십시오 . 순진한 재 포장은 물체에 대한 최적의 델타가 다른 포크에서만 발견되는 받침대에 대한 것임을 알 수 있습니다. 그러나 클라이언트가 가져 오면 기본 개체가 없으므로 즉시 새로운 델타를 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="a02a23b585c823168e0aade261aba54b02ee9df4" translate="yes" xml:space="preserve">
          <source>But now we can do</source>
          <target state="translated">그러나 지금 우리는 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d83b34d996269d86f487bc1b1bf210759565be26" translate="yes" xml:space="preserve">
          <source>But the above ways to work around untestable areas are a little bit clunky. Using special branches is nice because these branches can be shared by developers like usual branches, but the risk is that people will get many such branches. And it disrupts the normal &quot;git bisect&quot; work-flow. So, if you want to use &quot;git bisect run&quot; completely automatically, you have to add special code in your script to restart bisection in the special branches.</source>
          <target state="translated">그러나 테스트 할 수없는 영역을 해결하는 위의 방법은 약간 어수선합니다. 특별한 브랜치를 사용하는 것은이 브랜치를 일반적인 브랜치와 같이 개발자가 공유 할 수 있기 때문에 좋지만, 사람들은 그러한 브랜치를 많이 얻을 위험이 있습니다. 그리고 일반적인 &quot;git bisect&quot;워크 플로우를 방해합니다. 따라서 &quot;git bisect run&quot;을 완전히 자동으로 사용하려면 스크립트에 특수 코드를 추가하여 특수 분기에서 이등분을 다시 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="d51bf10c62a548cc7f488f7d7c601612ef19bfbf" translate="yes" xml:space="preserve">
          <source>But there are other ways to refer to commits. You can use any initial part of the name that is long enough to uniquely identify the commit:</source>
          <target state="translated">그러나 커밋을 참조하는 다른 방법이 있습니다. 커밋을 고유하게 식별하기에 충분한 이름의 초기 부분을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cbb3ccd9eb2da169028fcad03ea4127b40731fc" translate="yes" xml:space="preserve">
          <source>But this is wrong because at step 1) a) we keep only the ancestors of the bad commit. So we get more information when a commit is marked as &quot;bad&quot;, because we also know that the ancestors of the previous &quot;bad&quot; commit that are not ancestors of the new &quot;bad&quot; commit are not the first bad commit. We don&amp;rsquo;t know if they are good or bad, but we know that they are not the first bad commit because they are not ancestor of the new &quot;bad&quot; commit.</source>
          <target state="translated">그러나 이것은 1) 단계에서 a) 잘못된 커밋의 조상 만 유지하기 때문에 잘못되었습니다. 따라서 커밋이 &quot;나쁜&quot;로 표시되면 더 많은 정보를 얻을 수 있습니다. 새로운 &quot;나쁜&quot;커밋의 조상이 아닌 이전 &quot;나쁜&quot;커밋의 조상이 첫 번째 나쁜 커밋이 아니라는 것도 알고 있기 때문입니다. 우리는 그들이 좋은지 나쁜지 모르지만 새로운 &quot;나쁜&quot;커밋의 조상이 아니기 때문에 첫 번째 나쁜 커밋이 아니라는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9cd8c15ffc7ac156f5f412fb85c3db80183014e" translate="yes" xml:space="preserve">
          <source>But we can guess that improving on existing software is very costly because you have to watch out for regressions. At least this would make the above studies consistent among themselves.</source>
          <target state="translated">그러나 회귀를 조심해야하기 때문에 기존 소프트웨어를 개선하는 데 비용이 많이 드는 것으로 추측 할 수 있습니다. 적어도 이것은 위의 연구가 그들 사이에서 일관되게 만들 것입니다.</target>
        </trans-unit>
        <trans-unit id="01400b0b75aa93032834530c59a576c885a202c7" translate="yes" xml:space="preserve">
          <source>But what happens if the first bad commit is &quot;B&quot; and if it has been fixed in the &quot;main&quot; branch by commit &quot;F&quot;?</source>
          <target state="translated">그러나 첫 번째 잘못된 커밋이 &quot;B&quot;이고 &quot;main&quot;분기에서 커밋 &quot;F&quot;에 의해 수정 된 경우 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="2333cc37236068d07ee88795051fd2e9ba955821" translate="yes" xml:space="preserve">
          <source>But you can use &lt;code&gt;reset --keep&lt;/code&gt; to remove the unwanted commit after you switched to &lt;code&gt;branch2&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;branch2&lt;/code&gt; 로 전환 한 후 &lt;code&gt;reset --keep&lt;/code&gt; 을 사용 하여 원하지 않는 커밋을 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d0b3a86464faedd1c461b3e2ac63fc4ba06661b" translate="yes" xml:space="preserve">
          <source>But you decided that the topic branch is not ready for public consumption yet. &quot;pull&quot; or &quot;merge&quot; always leaves the original tip of the current branch in &lt;code&gt;ORIG_HEAD&lt;/code&gt;, so resetting hard to it brings your index file and the working tree back to that state, and resets the tip of the branch to that commit.</source>
          <target state="translated">그러나 토픽 브랜치는 아직 공공 소비 준비가되지 않았다고 결정했습니다. &quot;pull&quot;또는 &quot;merge&quot;는 항상 현재 분기의 원래 팁을 &lt;code&gt;ORIG_HEAD&lt;/code&gt; 에 남겨두고 , 재설정하면 인덱스 파일과 작업 트리를 다시 해당 상태로 되돌리고 분기의 팁을 해당 커밋으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="ec1fc17da64a933cb8c9dafb08caa5e756b65a2b" translate="yes" xml:space="preserve">
          <source>By adding a glob that matches the names of integration branches to this multi-valued configuration variable, the default merge message computed for merges into these integration branches will omit &quot;into &amp;lt;branch name&amp;gt;&quot; from its title.</source>
          <target state="translated">이 다중 값 구성 변수에 통합 분기의 이름과 일치하는 glob을 추가하면 이러한 통합 분기로의 병합을 위해 계산 된 기본 병합 메시지의 제목에서 &quot;into &amp;lt;branch name&amp;gt;&quot;이 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="c58a4c0205c696c7f9950dee21d8c3e1a3d8c1de" translate="yes" xml:space="preserve">
          <source>By default (or if &lt;code&gt;--no-reapply-cherry-picks&lt;/code&gt; is given), these commits will be automatically dropped. Because this necessitates reading all upstream commits, this can be expensive in repos with a large number of upstream commits that need to be read.</source>
          <target state="translated">기본적으로 (또는 &lt;code&gt;--no-reapply-cherry-picks&lt;/code&gt; 가 제공된 경우) 이러한 커밋은 자동으로 삭제됩니다. 이것은 모든 업스트림 커밋을 읽어야하기 때문에 읽어야하는 업스트림 커밋이 많은 저장소에서 비용이 많이들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18ba832b59818b9d406aeb54ba66e145b5697021" translate="yes" xml:space="preserve">
          <source>By default (without --all or --tags) &lt;code&gt;git describe&lt;/code&gt; only shows annotated tags. For more information about creating annotated tags see the -a and -s options to &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;.</source>
          <target state="translated">기본적으로 (--all 또는 --tags없이) &lt;code&gt;git describe&lt;/code&gt; 는 주석이 달린 태그 만 표시합니다. 주석이 달린 태그를 만드는 방법에 대한 자세한 내용은 &lt;a href=&quot;git-tag&quot;&gt;git-tag [1]에&lt;/a&gt; 대한 -a 및 -s 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2aacef9af72c222fb1b6acf47a0fa851e92d4733" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;git fetch&lt;/code&gt; refuses to update the head which corresponds to the current branch. This flag disables the check. This is purely for the internal use for &lt;code&gt;git pull&lt;/code&gt; to communicate with &lt;code&gt;git fetch&lt;/code&gt;, and unless you are implementing your own Porcelain you are not supposed to use it.</source>
          <target state="translated">기본적으로 &lt;code&gt;git fetch&lt;/code&gt; 는 현재 브랜치에 해당하는 헤드 업데이트를 거부합니다. 이 플래그는 검사를 비활성화합니다. 이것은 &lt;code&gt;git pull&lt;/code&gt; 이 &lt;code&gt;git fetch&lt;/code&gt; 와 통신 하기 위해 내부적으로 사용하기위한 것이며 , 자신의 Porcelain을 구현하지 않는 한 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="1d408902dc303f6c00a1b0f596a5c28e377e82f7" translate="yes" xml:space="preserve">
          <source>By default Git will look for your hooks in the &lt;code&gt;$GIT_DIR/hooks&lt;/code&gt; directory. Set this to different path, e.g. &lt;code&gt;/etc/git/hooks&lt;/code&gt;, and Git will try to find your hooks in that directory, e.g. &lt;code&gt;/etc/git/hooks/pre-receive&lt;/code&gt; instead of in &lt;code&gt;$GIT_DIR/hooks/pre-receive&lt;/code&gt;.</source>
          <target state="translated">기본적으로 Git은 &lt;code&gt;$GIT_DIR/hooks&lt;/code&gt; 디렉토리 에서 후크를 찾습니다 . 이것을 다른 경로 (예 : &lt;code&gt;/etc/git/hooks&lt;/code&gt; )로 설정 하면 Git은 해당 디렉토리 에서 &lt;code&gt;$GIT_DIR/hooks/pre-receive&lt;/code&gt; 대신 &lt;code&gt;/etc/git/hooks/pre-receive&lt;/code&gt; 와 같은 후크를 찾으려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="2707cacda66e328227d997bd98a14207b5d80af5" translate="yes" xml:space="preserve">
          <source>By default a &amp;lt;ref&amp;gt; not starting with refs/ is treated as the name of a remote-tracking branch (under refs/remotes/). This behavior can be modified using the --import-local option.</source>
          <target state="translated">기본적으로 refs /로 시작하지 않는 &amp;lt;ref&amp;gt;는 원격 추적 분기의 이름으로 간주됩니다 (refs / remotes / 아래). 이 동작은 --import-local 옵션을 사용하여 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fda6ea140eac0d5f03c38d0b89c06bf6c01dbaa" translate="yes" xml:space="preserve">
          <source>By default all Git repositories under &lt;code&gt;$projectroot&lt;/code&gt; are visible and available to gitweb. The list of projects is generated by default by scanning the &lt;code&gt;$projectroot&lt;/code&gt; directory for Git repositories (for object databases to be more exact; gitweb is not interested in a working area, and is best suited to showing &quot;bare&quot; repositories).</source>
          <target state="translated">기본적으로 &lt;code&gt;$projectroot&lt;/code&gt; 아래의 모든 Git 리포지토리 가 표시되며 gitweb에서 사용할 수 있습니다. 프로젝트 목록은 기본적으로 Git 저장소에 대한 &lt;code&gt;$projectroot&lt;/code&gt; 디렉토리를 스캔하여 생성됩니다 (객체 데이터베이스가 더 정확하도록하려면 gitweb은 작업 영역에 관심이 없으며 &quot;베어&quot;저장소를 표시하는 데 가장 적합합니다).</target>
        </trans-unit>
        <trans-unit id="7d4dbfd64b78e6eb7460def3863c1e38e1d55fa2" translate="yes" xml:space="preserve">
          <source>By default all Git repositories under &lt;code&gt;$projectroot&lt;/code&gt; are visible and available to gitweb. You can however configure how gitweb controls access to repositories.</source>
          <target state="translated">기본적으로 &lt;code&gt;$projectroot&lt;/code&gt; 아래의 모든 Git 리포지토리 가 표시되며 gitweb에서 사용할 수 있습니다. 그러나 gitweb이 리포지토리에 대한 액세스를 제어하는 ​​방법을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b749c474f0e8be473f5227adae69d6b82e99699" translate="yes" xml:space="preserve">
          <source>By default entries added by &quot;git add -N&quot; appear as an existing empty file in &quot;git diff&quot; and a new file in &quot;git diff --cached&quot;. This option makes the entry appear as a new file in &quot;git diff&quot; and non-existent in &quot;git diff --cached&quot;. This option could be reverted with &lt;code&gt;--ita-visible-in-index&lt;/code&gt;. Both options are experimental and could be removed in future.</source>
          <target state="translated">기본적으로 &quot;git add -N&quot;에 의해 추가 된 항목은 &quot;git diff&quot;에 기존의 빈 파일이고 &quot;git diff --cached&quot;에 새 파일로 나타납니다. 이 옵션은 항목을 &quot;git diff&quot;에 새 파일로 표시하고 &quot;git diff --cached&quot;에 존재하지 않는 항목으로 만듭니다. 이 옵션은 &lt;code&gt;--ita-visible-in-index&lt;/code&gt; 로 되돌릴 수 있습니다 . 두 옵션 모두 실험적이며 향후 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f92479038911d91ec691ca1995b6f59bbf4d3495" translate="yes" xml:space="preserve">
          <source>By default it uses SQLite databases in the Git directory, named &lt;code&gt;gitcvs.&amp;lt;module_name&amp;gt;.sqlite&lt;/code&gt;. Note that the SQLite backend creates temporary files in the same directory as the database file on write so it might not be enough to grant the users using &lt;code&gt;git-cvsserver&lt;/code&gt; write access to the database file without granting them write access to the directory, too.</source>
          <target state="translated">기본적으로 Git 디렉토리에서 &lt;code&gt;gitcvs.&amp;lt;module_name&amp;gt;.sqlite&lt;/code&gt; 라는 SQLite 데이터베이스를 사용합니다 . SQLite 백엔드는 쓰기시 데이터베이스 파일과 동일한 디렉토리에 임시 파일을 작성하므로 &lt;code&gt;git-cvsserver&lt;/code&gt; 를 사용하는 사용자에게 디렉토리에 대한 쓰기 권한을 부여하지 않고 데이터베이스 파일에 대한 액세스 권한을 부여하는 것만으로는 충분하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6b06e8b566ecf1a19a23c408ec4ad0c91c68502" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;man&lt;/code&gt; program will be used to display the manual page, but the &lt;code&gt;man.viewer&lt;/code&gt; configuration variable may be used to choose other display programs (see below).</source>
          <target state="translated">기본적으로 &lt;code&gt;man&lt;/code&gt; 프로그램은 매뉴얼 페이지를 표시하는 데 사용되지만 &lt;code&gt;man.viewer&lt;/code&gt; 구성 변수는 다른 디스플레이 프로그램을 선택하는 데 사용될 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="2e5b50ac3c7c5c555c2ca84f458ac39569a0ee21" translate="yes" xml:space="preserve">
          <source>By default the command records the date from the e-mail message as the commit author date, and uses the time of commit creation as the committer date. This allows the user to lie about the author date by using the same value as the committer date.</source>
          <target state="translated">기본적으로 명령은 전자 우편 메시지의 날짜를 커미트 작성자 날짜로 기록하고 커미트 작성 시간을 커미터 날짜로 사용합니다. 이를 통해 사용자는 커미터 날짜와 동일한 값을 사용하여 작성자 날짜에 대해 거짓말을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb47d162dbfc8bcd3a02f766bf35ff994d86e7f7" translate="yes" xml:space="preserve">
          <source>By default the command records the date from the e-mail message as the commit author date, and uses the time of commit creation as the committer date. This allows the user to lie about the committer date by using the same value as the author date.</source>
          <target state="translated">기본적으로 명령은 전자 우편 메시지의 날짜를 커미트 작성자 날짜로 기록하고 커미트 작성 시간을 커미터 날짜로 사용합니다. 이를 통해 사용자는 작성자 날짜와 동일한 값을 사용하여 커미터 날짜에 대해 거짓말을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6aeb14014b871b17a9d4f0da107bb610e5ea0157" translate="yes" xml:space="preserve">
          <source>By default the command shows all refs that match &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;. This option makes it stop after showing that many refs.</source>
          <target state="translated">기본적으로이 명령은 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 과 일치하는 모든 참조를 표시합니다 . 이 옵션은 많은 심판을 보여준 후에 멈추게합니다.</target>
        </trans-unit>
        <trans-unit id="7d63d3915d070cca4c5d36e324ecb4a7f6a0679f" translate="yes" xml:space="preserve">
          <source>By default the command will try to detect the patch format automatically. This option allows the user to bypass the automatic detection and specify the patch format that the patch(es) should be interpreted as. Valid formats are mbox, mboxrd, stgit, stgit-series and hg.</source>
          <target state="translated">기본적으로 명령은 패치 형식을 자동으로 감지하려고 시도합니다. 이 옵션을 통해 사용자는 자동 감지를 무시하고 패치를 해석해야하는 패치 형식을 지정할 수 있습니다. 유효한 형식은 mbox, mboxrd, stgit, stgit-series 및 hg입니다.</target>
        </trans-unit>
        <trans-unit id="ee6799585dabe2a3016ffbe61452694b948c3ff6" translate="yes" xml:space="preserve">
          <source>By default the hooks directory is &lt;code&gt;$GIT_DIR/hooks&lt;/code&gt;, but that can be changed via the &lt;code&gt;core.hooksPath&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">기본적으로 hooks 디렉토리는 &lt;code&gt;$GIT_DIR/hooks&lt;/code&gt; 이지만 &lt;code&gt;core.hooksPath&lt;/code&gt; 구성 변수 를 통해 변경할 수 있습니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1e420d062677a0d01238cac1bc0b0f93a32eaab8" translate="yes" xml:space="preserve">
          <source>By default the new trailer will appear at the end of all the existing trailers. If there is no existing trailer, the new trailer will appear after the commit message part of the output, and, if there is no line with only spaces at the end of the commit message part, one blank line will be added before the new trailer.</source>
          <target state="translated">기본적으로 새 예고편은 모든 기존 예고편 끝에 나타납니다. 기존 예고편이 없으면 출력의 커밋 메시지 부분 다음에 새 예고편이 표시되고 커밋 메시지 부분 끝에 공백 만있는 줄이 없으면 새 예고편 앞에 하나의 빈 줄이 추가됩니다. .</target>
        </trans-unit>
        <trans-unit id="64ba0ec6c1bed38e21fc7f4f4a0aef9c8ebe7286" translate="yes" xml:space="preserve">
          <source>By default the server leaves the &lt;code&gt;-k&lt;/code&gt; mode blank for all files, which causes the CVS client to treat them as a text files, subject to end-of-line conversion on some platforms.</source>
          <target state="translated">기본적으로 서버 는 모든 파일에 대해 &lt;code&gt;-k&lt;/code&gt; 모드를 비워 두므로 CVS 클라이언트는 파일을 텍스트 파일로 취급하므로 일부 플랫폼에서는 행 끝 변환이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="54dcb4758211c9d2e362cc73ee7a92ca62d914ac" translate="yes" xml:space="preserve">
          <source>By default this file controls only which projects are &lt;strong&gt;visible&lt;/strong&gt; on projects list page (note that entries that do not point to correctly recognized Git repositories won&amp;rsquo;t be displayed by gitweb). Even if a project is not visible on projects list page, you can view it nevertheless by hand-crafting a gitweb URL. By setting &lt;code&gt;$strict_export&lt;/code&gt; configuration variable (see &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt;) to true value you can allow viewing only of repositories also shown on the overview page (i.e. only projects explicitly listed in projects list file will be accessible).</source>
          <target state="translated">기본적으로이 파일은 프로젝트 목록 페이지에서 &lt;strong&gt;볼 수&lt;/strong&gt; 있는 프로젝트 만 제어합니다 (Git 리포지토리를 올바르게 인식하지 못하는 항목은 gitweb에 표시되지 않음). 프로젝트가 프로젝트 목록 페이지에 표시되지 않더라도 gitweb URL을 직접 만들어서 볼 수 있습니다. 설정하여 &lt;code&gt;$strict_export&lt;/code&gt; 구성 변수를 (참조 &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf을 [5]&lt;/a&gt; ) 만도 개요 페이지 (명시 적으로 액세스 할 수 있습니다 프로젝트 목록 파일에 나열된 즉, 단지 프로젝트)에 표시 저장소로 볼 수 있습니다 진정한 가치에.</target>
        </trans-unit>
        <trans-unit id="eff6e029914fd799d6a59537c15d9f46e8d635a6" translate="yes" xml:space="preserve">
          <source>By default when &lt;code&gt;--all&lt;/code&gt; is specified, reflogs from all working trees are processed. This option limits the processing to reflogs from the current working tree only.</source>
          <target state="translated">때 기본적으로 &lt;code&gt;--all&lt;/code&gt; 가 지정된 모든 작업 나무에서 reflogs 처리됩니다. 이 옵션은 현재 작업 트리에서만 재 처리하도록 처리를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="898aa5511bdcc79b6cc36a9d8f0c7e7e9ffc1277" translate="yes" xml:space="preserve">
          <source>By default when fetching from a shallow repository, &lt;code&gt;git fetch&lt;/code&gt; refuses refs that require updating .git/shallow. This option updates .git/shallow and accept such refs.</source>
          <target state="translated">얕은 저장소에서 &lt;code&gt;git fetch&lt;/code&gt; 때 기본적으로 git fetch 는 .git / shallow를 업데이트해야하는 심판을 거부합니다. 이 옵션은 .git / shallow를 업데이트하고 그러한 참조를 승인합니다.</target>
        </trans-unit>
        <trans-unit id="8a946900900b0969e5566670798dfa0b25059b02" translate="yes" xml:space="preserve">
          <source>By default, &quot;updateInstead&quot; will refuse the push if the working tree or the index have any difference from the HEAD, but the &lt;code&gt;push-to-checkout&lt;/code&gt; hook can be used to customize this. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">기본적으로 &quot;updateInstead&quot;는 작업 트리 또는 인덱스가 HEAD와 다른 경우 푸시를 거부하지만 &lt;code&gt;push-to-checkout&lt;/code&gt; 후크를 사용하여이를 사용자 정의 할 수 있습니다. &lt;a href=&quot;githooks&quot;&gt;githooks [5]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ccc06ea9e45b9e60a670cf461c22563d24643639" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt; creates packs that use delta-base offset. If you need to share your repository with Git older than version 1.4.4, either directly or via a dumb protocol such as http, then you need to set this option to &quot;false&quot; and repack. Access from old Git versions over the native protocol are unaffected by this option.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt; 은 델타-베이스 오프셋을 사용하는 팩을 만듭니다. 직접 또는 http와 같은 멍청한 프로토콜을 통해 1.4.4 이전의 Git과 저장소를 공유해야하는 경우이 옵션을 &quot;false&quot;로 설정하고 다시 압축해야합니다. 기본 프로토콜을 통한 이전 Git 버전의 액세스는이 옵션의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="207b9ec4a7354c6cbc08217ef08c22e3683c8d13" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; show files which are not currently tracked by Git. Directories which contain only untracked files, are shown with the directory name only. Showing untracked files means that Git needs to lstat() all the files in the whole repository, which might be slow on some systems. So, this variable controls how the commands displays the untracked files. Possible values are:</source>
          <target state="translated">기본적으로 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 및 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 은 현재 Git에서 추적하지 않는 파일을 표시합니다. 추적되지 않은 파일 만 포함 된 디렉토리는 디렉토리 이름으로 만 표시됩니다. 추적되지 않은 파일을 표시한다는 것은 Git이 전체 저장소에있는 모든 파일을 lstat ()해야한다는 것을 의미하며 일부 시스템에서는 느릴 수 있습니다. 따라서이 변수는 명령이 추적되지 않은 파일을 표시하는 방법을 제어합니다. 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0594913527635a38d7d1da1f58cf2049e0d81ae9" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; shows paths relative to the current directory. Setting this variable to &lt;code&gt;false&lt;/code&gt; shows paths relative to the repository root (this was the default for Git prior to v1.5.4).</source>
          <target state="translated">기본적으로 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 은 현재 디렉토리에 상대적인 경로를 보여줍니다. 이 변수를 &lt;code&gt;false&lt;/code&gt; 로 설정 하면 리포지토리 루트와 관련된 경로가 표시됩니다 (v1.5.4 이전의 Git에 대한 기본값).</target>
        </trans-unit>
        <trans-unit id="93044cb17b41f6ff0ab9ae102eca02ce8d5cdb16" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;add&lt;/code&gt; checks out &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, however, &lt;code&gt;--no-checkout&lt;/code&gt; can be used to suppress checkout in order to make customizations, such as configuring sparse-checkout. See &quot;Sparse checkout&quot; in &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree[1]&lt;/a&gt;.</source>
          <target state="translated">기본적으로, &lt;code&gt;add&lt;/code&gt; 검사를 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 그러나 &lt;code&gt;--no-checkout&lt;/code&gt; 이러한 희소 계산대 구성과 같은 지정을 확인하기 위해 결제 억제하는데 사용될 수있다. &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree [1]의&lt;/a&gt; &quot;스파 스 체크 아웃&quot;을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6911782a1bf788b96e52d6283b9603906afd385" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;add&lt;/code&gt; refuses to create a new working tree when &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a branch name and is already checked out by another working tree, or if &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; is already assigned to some working tree but is missing (for instance, if &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; was deleted manually). This option overrides these safeguards. To add a missing but locked working tree path, specify &lt;code&gt;--force&lt;/code&gt; twice.</source>
          <target state="translated">기본적으로 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 가 분기 이름이고 다른 작업 트리에서 이미 체크 아웃했거나 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 가 일부 작업 트리에 할당되었지만 누락 된 경우 &lt;code&gt;add&lt;/code&gt; 는 새 작업 트리 만들기를 거부합니다 (예 : &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 가 수동으로 삭제 된 경우 ). 이 옵션은 이러한 보호 수단을 무시합니다. 누락되었지만 잠긴 작업 트리 경로를 추가하려면 &lt;code&gt;--force&lt;/code&gt; 를 두 번 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6808cb2e8497f1a21da404e6487ab0df6e47fd0" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git add&lt;/code&gt; will warn when adding an embedded repository to the index without using &lt;code&gt;git submodule add&lt;/code&gt; to create an entry in &lt;code&gt;.gitmodules&lt;/code&gt;. This option will suppress the warning (e.g., if you are manually performing operations on submodules).</source>
          <target state="translated">기본적으로 &lt;code&gt;git add&lt;/code&gt; 는 &lt;code&gt;git submodule add&lt;/code&gt; 를 사용하여 &lt;code&gt;.gitmodules&lt;/code&gt; 에 항목을 만들지 않고 인덱스에 임베디드 리포지토리를 추가 할 때 경고합니다 . 이 옵션은 경고를 표시하지 않습니다 (예 : 서브 모듈에서 수동으로 작업을 수행하는 경우).</target>
        </trans-unit>
        <trans-unit id="9f7a911ab745fcc1ecc2d75cf5b4666d5616a0f2" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git am&lt;/code&gt; will fail if the patch does not apply cleanly. When set to true, this setting tells &lt;code&gt;git am&lt;/code&gt; to fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally (equivalent to giving the &lt;code&gt;--3way&lt;/code&gt; option from the command line). Defaults to &lt;code&gt;false&lt;/code&gt;. See &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;.</source>
          <target state="translated">패치가 제대로 적용되지 않으면 기본적으로 &lt;code&gt;git am&lt;/code&gt; 이 실패합니다. true로 설정하면이 설정은 패치가 적용해야 할 얼룩의 ID를 기록하고 해당 얼룩을 로컬에서 사용할 수있는 경우 &lt;code&gt;git am&lt;/code&gt; 에게 3 방향 병합으로 &lt;code&gt;--3way&lt;/code&gt; 하도록 지시 합니다. 명령 행). 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. &lt;a href=&quot;git-am&quot;&gt;git-am [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="04d5b79eb2c1cc00ec23b84308367755078f2519" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git apply&lt;/code&gt; expects that the patch being applied is a unified diff with at least one line of context. This provides good safety measures, but breaks down when applying a diff generated with &lt;code&gt;--unified=0&lt;/code&gt;. To bypass these checks use &lt;code&gt;--unidiff-zero&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;git apply&lt;/code&gt; 는 적용 되는 패치가 최소한 한 줄의 컨텍스트를 가진 통합 된 diff 일 것으로 예상합니다. 이것은 좋은 안전 조치를 제공하지만 &lt;code&gt;--unified=0&lt;/code&gt; 으로 생성 된 diff를 적용 할 때 분류됩니다 . 이러한 검사를 무시하려면 &lt;code&gt;--unidiff-zero&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc5e77409adaefd524775157d3aa209b06e80ef9" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git diff-tree --stdin&lt;/code&gt; does not show differences for merge commits. With this flag, it shows differences to that commit from all of its parents. See also &lt;code&gt;-c&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;git diff-tree --stdin&lt;/code&gt; 은 병합 커밋의 차이점을 보여주지 않습니다. 이 플래그를 사용하면 모든 부모의 커밋과의 차이점을 보여줍니다. &lt;code&gt;-c&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="44f438a687f3c8843b562164d423119ef0393e39" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git diff-tree --stdin&lt;/code&gt; shows differences, either in machine-readable form (without &lt;code&gt;-p&lt;/code&gt;) or in patch form (with &lt;code&gt;-p&lt;/code&gt;). This output can be suppressed. It is only useful with &lt;code&gt;-v&lt;/code&gt; flag.</source>
          <target state="translated">기본적으로, &lt;code&gt;git diff-tree --stdin&lt;/code&gt; 보여줍니다 차이, 중 기계 판독 형태 (없이 &lt;code&gt;-p&lt;/code&gt; ) 또는 (와 패치 형태로 &lt;code&gt;-p&lt;/code&gt; ). 이 출력을 억제 할 수 있습니다. &lt;code&gt;-v&lt;/code&gt; 플래그 에만 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="40ac50c3f37c319af999ce66ed951594dd739e7b" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git log&lt;/code&gt; does not generate any diff output. The options below can be used to show the changes made by each commit.</source>
          <target state="translated">기본적으로 &lt;code&gt;git log&lt;/code&gt; 는 diff 출력을 생성하지 않습니다. 아래 옵션을 사용하여 각 커밋의 변경 사항을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41ecfd2369ab83f2851da4837d8f55ae828a688b" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git merge&lt;/code&gt; command refuses to merge histories that do not share a common ancestor. This option can be used to override this safety when merging histories of two projects that started their lives independently. As that is a very rare occasion, no configuration variable to enable this by default exists and will not be added.</source>
          <target state="translated">기본적으로 &lt;code&gt;git merge&lt;/code&gt; 명령은 공통 조상을 공유하지 않는 기록을 병합하지 않습니다. 이 옵션은 독립적으로 생활을 시작한 두 프로젝트의 기록을 병합 할 때이 안전을 무시하는 데 사용할 수 있습니다. 매우 드문 경우이므로 기본적으로이를 활성화하는 구성 변수가 없으며 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c206e08a568b5af4b242b43f3b62e41c9c2a00a0" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git status&lt;/code&gt; will automatically refresh the index, updating the cached stat information from the working tree and writing out the result. Writing out the updated index is an optimization that isn&amp;rsquo;t strictly necessary (&lt;code&gt;status&lt;/code&gt; computes the values for itself, but writing them out is just to save subsequent programs from repeating our computation). When &lt;code&gt;status&lt;/code&gt; is run in the background, the lock held during the write may conflict with other simultaneous processes, causing them to fail. Scripts running &lt;code&gt;status&lt;/code&gt; in the background should consider using &lt;code&gt;git --no-optional-locks status&lt;/code&gt; (see &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for details).</source>
          <target state="translated">기본적으로 &lt;code&gt;git status&lt;/code&gt; 는 인덱스를 자동으로 새로 고쳐서 작업 트리에서 캐시 된 통계 정보를 업데이트하고 결과를 기록합니다. 업데이트 된 인덱스를 작성하는 것은 엄격하게 필요하지 않은 최적화입니다 ( &lt;code&gt;status&lt;/code&gt; 는 자체적으로 값을 계산하지만이를 작성하는 것은 후속 프로그램이 계산을 반복하지 않도록 저장하는 것입니다). 백그라운드에서 &lt;code&gt;status&lt;/code&gt; 가 실행 되면 쓰기 중에 보유 된 잠금이 다른 동시 프로세스와 충돌하여 실패 할 수 있습니다. 백그라운드 에서 &lt;code&gt;status&lt;/code&gt; 를 실행하는 스크립트 는 &lt;code&gt;git --no-optional-locks status&lt;/code&gt; 사용을 고려해야 합니다 (자세한 내용은 &lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="0166a80c7cb65bd63925a576fc16b6b5666a6f97" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;git tag&lt;/code&gt; in sign-with-default mode (-s) will use your committer identity (of the form &lt;code&gt;Your Name &amp;lt;your@email.address&amp;gt;&lt;/code&gt;) to find a key. If you want to use a different default key, you can specify it in the repository configuration as follows:</source>
          <target state="translated">기본적 으로 sign-with-default 모드 (-s)의 &lt;code&gt;git tag&lt;/code&gt; 는 커미터 ID ( &lt;code&gt;Your Name &amp;lt;your@email.address&amp;gt;&lt;/code&gt; 형식 )를 사용하여 키를 찾습니다. 다른 기본 키를 사용하려면 리포지토리 구성에서 다음과 같이 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab2e2876fa31ec281a3a2c1b794b7dec91ae3790" translate="yes" xml:space="preserve">
          <source>By default, Git determines the command line arguments to use based on the basename of the configured SSH command (configured using the environment variable &lt;code&gt;GIT_SSH&lt;/code&gt; or &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; or the config setting &lt;code&gt;core.sshCommand&lt;/code&gt;). If the basename is unrecognized, Git will attempt to detect support of OpenSSH options by first invoking the configured SSH command with the &lt;code&gt;-G&lt;/code&gt; (print configuration) option and will subsequently use OpenSSH options (if that is successful) or no options besides the host and remote command (if it fails).</source>
          <target state="translated">기본적으로 Git은 구성된 SSH 명령의 기본 이름 (환경 변수 &lt;code&gt;GIT_SSH&lt;/code&gt; 또는 &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; 또는 구성 설정 &lt;code&gt;core.sshCommand&lt;/code&gt; 를 사용하여 구성됨)을 기반으로 사용할 명령 줄 인수를 결정합니다 . 기본 이름을 인식하지 못하면 Git은 먼저 &lt;code&gt;-G&lt;/code&gt; (인쇄 구성) 옵션으로 구성된 SSH 명령을 호출하여 OpenSSH 옵션에 대한 지원을 감지 한 다음 OpenSSH 옵션 (성공한 경우)을 사용하거나 호스트 및 원격 명령 (실패한 경우)</target>
        </trans-unit>
        <trans-unit id="b85b0c2bab173615caaf4bbe66c1c28d30e786cc" translate="yes" xml:space="preserve">
          <source>By default, Git does not consider the &quot;path&quot; component of an http URL to be worth matching via external helpers. This means that a credential stored for &lt;code&gt;https://example.com/foo.git&lt;/code&gt; will also be used for &lt;code&gt;https://example.com/bar.git&lt;/code&gt;. If you do want to distinguish these cases, set this option to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">기본적으로 Git은 http URL의 &quot;path&quot;구성 요소가 외부 헬퍼를 통해 일치하는 것으로 간주되지 않습니다. 자격은 저장이 수단 &lt;code&gt;https://example.com/foo.git&lt;/code&gt; 는 또한 사용됩니다 &lt;code&gt;https://example.com/bar.git&lt;/code&gt; . 이러한 경우를 구별하려면이 옵션을 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="ffe1eaf4d1c9cc64df80a6b16dfbf1fa771b52c9" translate="yes" xml:space="preserve">
          <source>By default, Git does not create an extra merge commit when merging a commit that is a descendant of the current commit. Instead, the tip of the current branch is fast-forwarded. When set to &lt;code&gt;false&lt;/code&gt;, this variable tells Git to create an extra merge commit in such a case (equivalent to giving the &lt;code&gt;--no-ff&lt;/code&gt; option from the command line). When set to &lt;code&gt;only&lt;/code&gt;, only such fast-forward merges are allowed (equivalent to giving the &lt;code&gt;--ff-only&lt;/code&gt; option from the command line).</source>
          <target state="translated">기본적으로 Git은 현재 커밋의 자손 인 커밋을 병합 할 때 추가 병합 커밋을 만들지 않습니다. 대신, 현재 분기의 끝이 빨리 감 깁니다. &lt;code&gt;false&lt;/code&gt; 로 설정하면 이 변수는 Git에게 이러한 경우 추가 병합 커밋을 만들도록 지시 합니다 (명령 줄에서 &lt;code&gt;--no-ff&lt;/code&gt; 옵션 을 제공하는 것과 동일 ). &lt;code&gt;only&lt;/code&gt; 로 설정하면 이러한 빨리 감기 병합 만 허용됩니다 ( 명령 줄에서 &lt;code&gt;--ff-only&lt;/code&gt; 옵션 을 제공하는 것과 동일 ).</target>
        </trans-unit>
        <trans-unit id="32c0486f322ae0e4678fa0824298d7c086e9ee4f" translate="yes" xml:space="preserve">
          <source>By default, Git does not create an extra merge commit when merging a commit that is a descendant of the current commit. Instead, the tip of the current branch is fast-forwarded. When set to &lt;code&gt;false&lt;/code&gt;, this variable tells Git to create an extra merge commit in such a case (equivalent to giving the &lt;code&gt;--no-ff&lt;/code&gt; option from the command line). When set to &lt;code&gt;only&lt;/code&gt;, only such fast-forward merges are allowed (equivalent to giving the &lt;code&gt;--ff-only&lt;/code&gt; option from the command line). This setting overrides &lt;code&gt;merge.ff&lt;/code&gt; when pulling.</source>
          <target state="translated">기본적으로 Git은 현재 커밋의 자손 인 커밋을 병합 할 때 추가 병합 커밋을 만들지 않습니다. 대신, 현재 분기의 끝이 빨리 감 깁니다. &lt;code&gt;false&lt;/code&gt; 로 설정하면 이 변수는 Git에게 이러한 경우 추가 병합 커밋을 만들도록 지시 합니다 (명령 줄에서 &lt;code&gt;--no-ff&lt;/code&gt; 옵션 을 제공하는 것과 동일 ). &lt;code&gt;only&lt;/code&gt; 로 설정하면 이러한 빨리 감기 병합 만 허용됩니다 ( 명령 줄에서 &lt;code&gt;--ff-only&lt;/code&gt; 옵션 을 제공하는 것과 동일 ). 이 설정은 &lt;code&gt;merge.ff&lt;/code&gt; 때 merge.ff 보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="e39ec591fb076f73ed5744e6cef724be12b06bb7" translate="yes" xml:space="preserve">
          <source>By default, Git uses the same style as the one used by the &quot;merge&quot; program from the RCS suite to present such a conflicted hunk, like this:</source>
          <target state="translated">기본적으로 Git은 RCS 제품군의 &quot;병합&quot;프로그램에서 사용하는 것과 동일한 스타일을 사용하여 다음과 같이 충돌 된 덩어리를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="632bd7b7934c758c995d70fcf0643a53a17ef93c" translate="yes" xml:space="preserve">
          <source>By default, Git will report, to the server, commits reachable from all local refs to find common commits in an attempt to reduce the size of the to-be-received packfile. If specified, Git will only report commits reachable from the given tips. This is useful to speed up fetches when the user knows which local ref is likely to have commits in common with the upstream ref being fetched.</source>
          <target state="translated">기본적으로 Git은 수신 할 팩 파일의 크기를 줄이려는 시도에서 공통 커밋을 찾기 위해 모든 로컬 참조에서 도달 가능한 커밋을 서버에보고합니다. 지정된 경우 Git은 주어진 팁에서 도달 가능한 커밋 만보고합니다. 이것은 업스트림 참조가 페치되는 공통 커밋이있는 로컬 참조를 사용자가 알면 가져 오기 속도를 높이는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ec00d75621e8cccd0e732ba6afc6d14548cb8a4e" translate="yes" xml:space="preserve">
          <source>By default, Thunderbird will both wrap emails as well as flag them as being &lt;code&gt;format=flowed&lt;/code&gt;, both of which will make the resulting email unusable by Git.</source>
          <target state="translated">기본적으로 Thunderbird는 이메일을 랩핑하고 &lt;code&gt;format=flowed&lt;/code&gt; 로 플래그를 지정 하여 Git에서 결과 이메일을 사용할 수 없게합니다.</target>
        </trans-unit>
        <trans-unit id="cb931511b378f47ed0453a8a3e156978cca15ca4" translate="yes" xml:space="preserve">
          <source>By default, a &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;token&amp;gt;:&amp;lt;value&amp;gt;&lt;/code&gt; argument given using &lt;code&gt;--trailer&lt;/code&gt; will be appended after the existing trailers only if the last trailer has a different (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair (or if there is no existing trailer). The &amp;lt;token&amp;gt; and &amp;lt;value&amp;gt; parts will be trimmed to remove starting and trailing whitespace, and the resulting trimmed &amp;lt;token&amp;gt; and &amp;lt;value&amp;gt; will appear in the message like this:</source>
          <target state="translated">기본적으로 &lt;code&gt;--trailer&lt;/code&gt; 를 사용하여 제공된 &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;token&amp;gt;:&amp;lt;value&amp;gt;&lt;/code&gt; 인수 는 마지막 트레일러에 다른 (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) 쌍이있는 경우에만 기존 트레일러 뒤에 추가됩니다. (또는 기존 트레일러가없는 경우). 시작 및 후행 공백을 제거하기 위해 &amp;lt;토큰&amp;gt; 및 &amp;lt;값&amp;gt; 부분이 잘리고 결과적으로 잘린 &amp;lt;토큰&amp;gt; 및 &amp;lt;값&amp;gt;이 메시지에 다음과 같이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="434e3c7441379e0ab27bf268d6dee72f73412814" translate="yes" xml:space="preserve">
          <source>By default, a patch that affects outside the working area (either a Git controlled working tree, or the current working directory when &quot;git apply&quot; is used as a replacement of GNU patch) is rejected as a mistake (or a mischief).</source>
          <target state="translated">기본적으로 작업 영역 외부에 영향을 미치는 패치 (Git 제어 작업 트리 또는 &quot;git apply&quot;가 GNU 패치의 대체로 사용되는 경우 현재 작업 디렉토리)는 실수 (또는 장난)로 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="ea0000563105721871c07339b879614c007bc152" translate="yes" xml:space="preserve">
          <source>By default, a rebase will simply drop merge commits from the todo list, and put the rebased commits into a single, linear branch. With &lt;code&gt;--rebase-merges&lt;/code&gt;, the rebase will instead try to preserve the branching structure within the commits that are to be rebased, by recreating the merge commits. Any resolved merge conflicts or manual amendments in these merge commits will have to be resolved/re-applied manually.</source>
          <target state="translated">기본적으로 rebase는 단순히 todo 목록에서 merge commit을 삭제하고 rebased commit을 단일 선형 브랜치에 넣습니다. 함께 &lt;code&gt;--rebase-merges&lt;/code&gt; 의 REBASE 대신 병합 커밋을 다시 만들어,으로 업데이트 할 수있는 커밋 내에서 분기 구조를 유지하려고합니다. 이러한 병합 커밋에서 해결 된 병합 충돌 또는 수동 수정 사항은 수동으로 해결 / 다시 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="92f108d472fe60a4c0a9d93474bd0154c5c0a9e2" translate="yes" xml:space="preserve">
          <source>By default, all working trees will be examined by the following options when there are more than one (see &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt;): &lt;code&gt;--all&lt;/code&gt;, &lt;code&gt;--reflog&lt;/code&gt; and &lt;code&gt;--indexed-objects&lt;/code&gt;. This option forces them to examine the current working tree only.</source>
          <target state="translated">기본적으로 모든 작업 트리는 둘 이상의 옵션이있을 때 ( &lt;a href=&quot;git-worktree&quot;&gt;git-worktree [1] 참조&lt;/a&gt; ) &lt;code&gt;--all&lt;/code&gt; , &lt;code&gt;--reflog&lt;/code&gt; 및 &lt;code&gt;--indexed-objects&lt;/code&gt; 옵션으로 검사합니다 . 이 옵션은 현재 작업 트리 만 검사하도록합니다.</target>
        </trans-unit>
        <trans-unit id="1feea061cb833e84202a29cce6b0929662b79ff4" translate="yes" xml:space="preserve">
          <source>By default, any branch can be used as the source for a &lt;code&gt;git p4 submit&lt;/code&gt; operation. This configuration variable, if set, permits only the named branches to be used as submit sources. Branch names must be the short names (no &quot;refs/heads/&quot;), and should be separated by commas (&quot;,&quot;), with no spaces.</source>
          <target state="translated">기본적으로 모든 브랜치는 &lt;code&gt;git p4 submit&lt;/code&gt; 작업 의 소스로 사용할 수 있습니다 . 이 구성 변수를 설정하면 이름 지정된 분기 만 제출 소스로 사용할 수 있습니다. 지점 이름은 짧은 이름 ( &quot;refs / heads /&quot;없음)이어야하며 공백없이 쉼표 ( &quot;,&quot;)로 구분해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb82df8bc2b9bbd18ae6db77878aee5f1360ef3d" translate="yes" xml:space="preserve">
          <source>By default, any of the given pathnames which match an ignore pattern will be output, one per line. If no pattern matches a given path, nothing will be output for that path; this means that path will not be ignored.</source>
          <target state="translated">기본적으로 무시 패턴과 일치하는 지정된 경로 이름이 한 줄에 하나씩 출력됩니다. 주어진 경로와 일치하는 패턴이 없으면 해당 경로에 대해 아무것도 출력되지 않습니다. 이는 경로가 무시되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9840f412411908e4167e9b89fe91af90f41421dd" translate="yes" xml:space="preserve">
          <source>By default, any tag that points into the histories being fetched is also fetched; the effect is to fetch tags that point at branches that you are interested in. This default behavior can be changed by using the --tags or --no-tags options or by configuring remote.&amp;lt;name&amp;gt;.tagOpt. By using a refspec that fetches tags explicitly, you can fetch tags that do not point into branches you are interested in as well.</source>
          <target state="translated">기본적으로 페치되는 히스토리를 가리키는 모든 태그도 페치됩니다. 효과는 원하는 분기를 가리키는 태그를 가져 오는 것입니다.이 기본 동작은 --tags 또는 --no-tags 옵션을 사용하거나 remote. &amp;lt;name&amp;gt; .tagOpt를 구성하여 변경할 수 있습니다. 태그를 명시 적으로 가져 오는 참조 스펙을 사용하면 관심있는 분기를 가리 키지 않는 태그를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="859edf72ede027900910837f2758e52dd7b73b08" translate="yes" xml:space="preserve">
          <source>By default, cherry-picking a commit with an empty message will fail. This option overrides that behavior, allowing commits with empty messages to be cherry picked.</source>
          <target state="translated">기본적으로 빈 메시지와 함께 커밋을 선택하면 실패합니다. 이 옵션은 해당 동작을 대체하여 빈 메시지가있는 커밋을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="c2ea9611dc2821c1e170c93c6a453dad2dd69c2d" translate="yes" xml:space="preserve">
          <source>By default, cherry-picking an empty commit will fail, indicating that an explicit invocation of &lt;code&gt;git commit
--allow-empty&lt;/code&gt; is required. This option overrides that behavior, allowing empty commits to be preserved automatically in a cherry-pick. Note that when &quot;--ff&quot; is in effect, empty commits that meet the &quot;fast-forward&quot; requirement will be kept even without this option. Note also, that use of this option only keeps commits that were initially empty (i.e. the commit recorded the same tree as its parent). Commits which are made empty due to a previous commit are dropped. To force the inclusion of those commits use &lt;code&gt;--keep-redundant-commits&lt;/code&gt;.</source>
          <target state="translated">기본적으로 빈 커밋을 체리 피킹하면 &lt;code&gt;git commit --allow-empty&lt;/code&gt; 명시 적으로 호출해야 함을 나타냅니다 . 이 옵션은 해당 동작을 재정 의하여 빈 커밋이 체리 픽에서 자동으로 유지되도록합니다. &quot;--ff&quot;가 유효하면 &quot;앞으로 빨리 감기&quot;요구 사항을 충족하는 빈 커밋이이 옵션 없이도 유지됩니다. 또한이 옵션을 사용하면 처음에는 비어 있던 커밋 만 유지됩니다 (즉, 커밋은 부모와 동일한 트리를 기록했습니다). 이전 커밋으로 인해 비어있는 커밋은 삭제됩니다. 이러한 커밋을 강제로 포함 시키려면 &lt;code&gt;--keep-redundant-commits&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="99709c182dff4928785c30a9c26112a6276f34d2" translate="yes" xml:space="preserve">
          <source>By default, each output file is numbered sequentially from 1, and uses the first line of the commit message (massaged for pathname safety) as the filename. With the &lt;code&gt;--numbered-files&lt;/code&gt; option, the output file names will only be numbers, without the first line of the commit appended. The names of the output files are printed to standard output, unless the &lt;code&gt;--stdout&lt;/code&gt; option is specified.</source>
          <target state="translated">기본적으로 각 출력 파일은 1부터 순차적으로 번호가 매겨지며 커밋 메시지의 첫 번째 행 (경로 이름 안전을 위해 정리)을 파일 이름으로 사용합니다. 으로 &lt;code&gt;--numbered-files&lt;/code&gt; 옵션, 출력 파일 이름에는 추가 커밋의 첫 번째 줄없이, 숫자가 될 것입니다. &lt;code&gt;--stdout&lt;/code&gt; 옵션을 지정 하지 않으면 출력 파일 이름이 표준 출력으로 인쇄 됩니다.</target>
        </trans-unit>
        <trans-unit id="3d27fcf4c77eeb925cb728d43582e85b263ea253" translate="yes" xml:space="preserve">
          <source>By default, files recorded in the index but not checked out are reported as deleted. This flag makes &lt;code&gt;git diff-index&lt;/code&gt; say that all non-checked-out files are up to date.</source>
          <target state="translated">기본적으로 색인에 기록되었지만 체크 아웃되지 않은 파일은 삭제 된 것으로보고됩니다. 이 플래그는 &lt;code&gt;git diff-index&lt;/code&gt; 가 체크 아웃되지 않은 모든 파일이 최신 상태임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="96d263210b58deac758523391a09d64f715778b1" translate="yes" xml:space="preserve">
          <source>By default, git checks if a branch is force-updated during fetch. Pass --no-show-forced-updates or set fetch.showForcedUpdates to false to skip this check for performance reasons. If used during &lt;code&gt;git-pull&lt;/code&gt; the --ff-only option will still check for forced updates before attempting a fast-forward update. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">기본적으로 git은 가져 오는 동안 분기가 강제 업데이트되는지 확인합니다. 성능상의 이유로이 검사를 건너 뛰려면 --no-show-forced-updates를 전달하거나 fetch.showForcedUpdates를 false로 설정하십시오. &lt;code&gt;git-pull&lt;/code&gt; 중에 사용 되면 --ff-only 옵션은 빨리 감기를 시도하기 전에 강제 업데이트를 확인합니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bcd22a0eaa98a42d194f3bb1ae51915a7ffdb1a6" translate="yes" xml:space="preserve">
          <source>By default, git checks if a branch is force-updated during fetch. This can be disabled through fetch.showForcedUpdates, but the --show-forced-updates option guarantees this check occurs. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">기본적으로 git은 가져 오는 동안 분기가 강제 업데이트되는지 확인합니다. fetch.showForcedUpdates를 통해 비활성화 할 수 있지만 --show-forced-updates 옵션을 사용하면이 검사가 수행됩니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd1e0c76aa334eb061df6d08bfae08afe6a12c47" translate="yes" xml:space="preserve">
          <source>By default, git-receive-pack will advertise the atomic push capability to its clients. If you don&amp;rsquo;t want to advertise this capability, set this variable to false.</source>
          <target state="translated">기본적으로 git-receive-pack은 원자 푸시 기능을 클라이언트에게 알립니다. 이 기능을 알리지 않으려면이 변수를 false로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="1a975a4b5c6ec62cbf8bcd46f9c353ac381aea16" translate="yes" xml:space="preserve">
          <source>By default, git-receive-pack will run &quot;git-gc --auto&quot; after receiving data from git-push and updating refs. You can stop it by setting this variable to false.</source>
          <target state="translated">기본적으로 git-receive-pack은 git-push로부터 데이터를 수신하고 참조를 업데이트 한 후 &quot;git-gc --auto&quot;를 실행합니다. 이 변수를 false로 설정하여 중지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b0b6ce94f774ad8adadd56d738f2417c24f77c0" translate="yes" xml:space="preserve">
          <source>By default, if &lt;code&gt;--staged&lt;/code&gt; is given, the contents are restored from &lt;code&gt;HEAD&lt;/code&gt;, otherwise from the index. Use &lt;code&gt;--source&lt;/code&gt; to restore from a different commit.</source>
          <target state="translated">기본적으로 &lt;code&gt;--staged&lt;/code&gt; 가 제공되면 콘텐츠가 &lt;code&gt;HEAD&lt;/code&gt; 에서 복원되고 그렇지 않으면 인덱스에서 복원됩니다 . &lt;code&gt;--source&lt;/code&gt; 를 사용 하여 다른 커밋에서 복원합니다.</target>
        </trans-unit>
        <trans-unit id="a70c8c423de4cae10f96eacc568cc485314e2875" translate="yes" xml:space="preserve">
          <source>By default, notes are saved to and read from &lt;code&gt;refs/notes/commits&lt;/code&gt;, but this default can be overridden. See the OPTIONS, CONFIGURATION, and ENVIRONMENT sections below. If this ref does not exist, it will be quietly created when it is first needed to store a note.</source>
          <target state="translated">기본적으로 메모는 &lt;code&gt;refs/notes/commits&lt;/code&gt; 에 저장되고 읽혀 지지만이 기본값은 무시 될 수 있습니다. 아래의 옵션, 구성 및 환경 섹션을 참조하십시오. 이 참조가 존재하지 않으면 처음 메모를 저장해야 할 때 자동으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="7db5a2446c4341c306923f095d2e7f8486b88ca6" translate="yes" xml:space="preserve">
          <source>By default, only &lt;code&gt;upload-pack&lt;/code&gt; service is enabled, which serves &lt;code&gt;git fetch-pack&lt;/code&gt; and &lt;code&gt;git ls-remote&lt;/code&gt; clients, which are invoked from &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt;, and &lt;code&gt;git clone&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;git fetch&lt;/code&gt; , &lt;code&gt;git pull&lt;/code&gt; 및 &lt;code&gt;git clone&lt;/code&gt; 에서 호출되는 git fetch &lt;code&gt;git fetch-pack&lt;/code&gt; 및 &lt;code&gt;git ls-remote&lt;/code&gt; 클라이언트에 서비스를 제공하는 &lt;code&gt;upload-pack&lt;/code&gt; 서비스 만 사용 됩니다 .</target>
        </trans-unit>
        <trans-unit id="d1846d634d738a19049ad205d84e7a2d6c7d9843" translate="yes" xml:space="preserve">
          <source>By default, only tags on fetched branches are imported (see &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;).</source>
          <target state="translated">기본적으로 페치 된 브랜치의 태그 만 가져옵니다 ( &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="330929bfac5b0158d7117057a21f395479839e07" translate="yes" xml:space="preserve">
          <source>By default, only the &lt;code&gt;upload-pack&lt;/code&gt; service is enabled, which serves &lt;code&gt;git fetch-pack&lt;/code&gt; and &lt;code&gt;git ls-remote&lt;/code&gt; clients, which are invoked from &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt;, and &lt;code&gt;git clone&lt;/code&gt;. If the client is authenticated, the &lt;code&gt;receive-pack&lt;/code&gt; service is enabled, which serves &lt;code&gt;git send-pack&lt;/code&gt; clients, which is invoked from &lt;code&gt;git push&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;git fetch&lt;/code&gt; , &lt;code&gt;git pull&lt;/code&gt; 및 &lt;code&gt;git clone&lt;/code&gt; 에서 호출되는 git fetch &lt;code&gt;git fetch-pack&lt;/code&gt; 및 &lt;code&gt;git ls-remote&lt;/code&gt; 클라이언트에 서비스를 제공 하는 &lt;code&gt;upload-pack&lt;/code&gt; 서비스 만 사용 됩니다 . 클라이언트가 인증되면 &lt;code&gt;receive-pack&lt;/code&gt; 서비스가 활성화 되어 &lt;code&gt;git push&lt;/code&gt; 에서 호출되는 &lt;code&gt;git send-pack&lt;/code&gt; 클라이언트 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="0265af70a38c5e98df8aec91888bb8ebd90e0b3b" translate="yes" xml:space="preserve">
          <source>By default, or when &lt;code&gt;no-rebase-cousins&lt;/code&gt; was specified, commits which do not have &lt;code&gt;&amp;lt;upstream&amp;gt;&lt;/code&gt; as direct ancestor will keep their original branch point, i.e. commits that would be excluded by &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;'s &lt;code&gt;--ancestry-path&lt;/code&gt; option will keep their original ancestry by default. If the &lt;code&gt;rebase-cousins&lt;/code&gt; mode is turned on, such commits are instead rebased onto &lt;code&gt;&amp;lt;upstream&amp;gt;&lt;/code&gt; (or &lt;code&gt;&amp;lt;onto&amp;gt;&lt;/code&gt;, if specified).</source>
          <target state="translated">기본적으로 또는 &lt;code&gt;no-rebase-cousins&lt;/code&gt; 가 지정되지 않은 경우 직접 &lt;code&gt;--ancestry-path&lt;/code&gt; 으로 &lt;code&gt;&amp;lt;upstream&amp;gt;&lt;/code&gt; 이없는 커밋 은 원래 분기 지점, 즉 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 의 --ancestry-에 의해 제외되는 커밋을 유지합니다. 경로 옵션은 기본적으로 원래 조상을 유지합니다. &lt;code&gt;rebase-cousins&lt;/code&gt; 모드가 켜져 있으면 이러한 커밋은 대신 &lt;code&gt;&amp;lt;upstream&amp;gt;&lt;/code&gt; (또는 지정된 경우 &lt;code&gt;&amp;lt;onto&amp;gt;&lt;/code&gt; )을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="37d300d0f44033465a93b6aee94bab48b54dbf53" translate="yes" xml:space="preserve">
          <source>By default, p4 branches are stored in &lt;code&gt;refs/remotes/p4/&lt;/code&gt;, where they will be treated as remote-tracking branches by &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; and other commands. This option instead puts p4 branches in &lt;code&gt;refs/heads/p4/&lt;/code&gt;. Note that future sync operations must specify &lt;code&gt;--import-local&lt;/code&gt; as well so that they can find the p4 branches in refs/heads.</source>
          <target state="translated">기본적으로 p4 브랜치는 &lt;code&gt;refs/remotes/p4/&lt;/code&gt; 저장 되며 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; 및 기타 명령에 의해 원격 추적 브랜치로 취급됩니다 . 이 옵션은 대신 p4 브랜치를 &lt;code&gt;refs/heads/p4/&lt;/code&gt; 에 넣습니다 . 향후 동기화 작업은 참조 / 헤드에서 p4 분기를 찾을 수 있도록 &lt;code&gt;--import-local&lt;/code&gt; 도 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="52600650ec12082f5a2bcdafd01bd7a6322055cf" translate="yes" xml:space="preserve">
          <source>By default, rebasing commits with an empty message will fail. This option overrides that behavior, allowing commits with empty messages to be rebased.</source>
          <target state="translated">기본적으로 빈 메시지로 확약 재 확보는 실패합니다. 이 옵션은 해당 동작을 대체하여 빈 메시지가있는 커밋을 리베이스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aab8804804be7a1049e7aa89e2807caa0461793c" translate="yes" xml:space="preserve">
          <source>By default, running a command such as &lt;code&gt;git fast-export
master~5..master&lt;/code&gt; will not include the commit master~5 and will make master~4 no longer have master~5 as a parent (though both the old master~4 and new master~4 will have all the same files). Use --reference-excluded-parents to instead have the stream refer to commits in the excluded range of history by their sha1sum. Note that the resulting stream can only be used by a repository which already contains the necessary parent commits.</source>
          <target state="translated">기본적으로 &lt;code&gt;git fast-export master~5..master&lt;/code&gt; 와 같은 명령을 실행 하면 commit master ~ 5가 포함되지 않으며 master ~ 4가 더 이상 master ~ 5를 부모로 가지지 않습니다 (이전 master ~ 4와 새 마스터 ~ 4는 모두 동일한 파일을 갖습니다). 스트림이 sha1sum에 의해 제외 된 히스토리 범위에서 커미트를 참조하도록하려면 --reference-excluded-parents를 사용하십시오. 결과 스트림은 필요한 상위 커밋이 이미 포함 된 저장소에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d83beffd98b552e4707fcc4f203041336c446345" translate="yes" xml:space="preserve">
          <source>By default, shows the tags, heads, and remote refs.</source>
          <target state="translated">기본적으로 태그, 헤드 및 원격 참조를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9534d3a85e2055ad7b75dcf81f0ec911d150730a" translate="yes" xml:space="preserve">
          <source>By default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e. &lt;code&gt;medium&lt;/code&gt;, which is the default, &lt;code&gt;full&lt;/code&gt;, and &lt;code&gt;fuller&lt;/code&gt;).</source>
          <target state="translated">기본적으로 탭은 로그 메시지를 4 개의 공백으로 들여 쓰는 예쁜 형식으로 확장됩니다 (즉, &lt;code&gt;medium&lt;/code&gt; , default, &lt;code&gt;full&lt;/code&gt; 및 &lt;code&gt;fuller&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f8c576d24c20a06a3fa3293a553efd1880bf67bd" translate="yes" xml:space="preserve">
          <source>By default, tags that point at objects that are downloaded from the remote repository are fetched and stored locally. This option disables this automatic tag following. The default behavior for a remote may be specified with the remote.&amp;lt;name&amp;gt;.tagOpt setting. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">기본적으로 원격 저장소에서 다운로드 한 객체를 가리키는 태그는 가져 와서 로컬에 저장됩니다. 이 옵션은이 자동 태그 추적을 비활성화합니다. 리모컨의 기본 동작은 remote. &amp;lt;name&amp;gt; .tagOpt 설정으로 지정할 수 있습니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ffdb9a1efc1700312a38f928a2009acf370d9974" translate="yes" xml:space="preserve">
          <source>By default, the branches and their commits are shown in reverse chronological order. This option makes them appear in topological order (i.e., descendant commits are shown before their parents).</source>
          <target state="translated">기본적으로 브랜치와 커밋은 역순으로 표시됩니다. 이 옵션을 사용하면 토폴로지 순서대로 표시됩니다 (즉, 하위 커밋은 부모에게 표시됩니다).</target>
        </trans-unit>
        <trans-unit id="7d6c7baaf0bf9e427c6cfd338efdec2fba7e7759" translate="yes" xml:space="preserve">
          <source>By default, the command outputs warning messages but applies the patch. When &lt;code&gt;git-apply&lt;/code&gt; is used for statistics and not applying a patch, it defaults to &lt;code&gt;nowarn&lt;/code&gt;.</source>
          <target state="translated">기본적으로이 명령은 경고 메시지를 출력하지만 패치를 적용합니다. 때 &lt;code&gt;git-apply&lt;/code&gt; 패치, 그것을 기본값 적용 통계가 아니라 사용 &lt;code&gt;nowarn&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="a611e350871da16559e274274576dfaf4df893f3" translate="yes" xml:space="preserve">
          <source>By default, the command passes &lt;code&gt;--delta-base-offset&lt;/code&gt; option to &lt;code&gt;git pack-objects&lt;/code&gt;; this typically results in slightly smaller packs, but the generated packs are incompatible with versions of Git older than version 1.4.4. If you need to share your repository with such ancient Git versions, either directly or via the dumb http protocol, then you need to set the configuration variable &lt;code&gt;repack.UseDeltaBaseOffset&lt;/code&gt; to &quot;false&quot; and repack. Access from old Git versions over the native protocol is unaffected by this option as the conversion is performed on the fly as needed in that case.</source>
          <target state="translated">기본적 &lt;code&gt;--delta-base-offset&lt;/code&gt; 명령은 --delta-base-offset 옵션을 &lt;code&gt;git pack-objects&lt;/code&gt; 에 전달합니다 . 이로 인해 일반적으로 팩이 약간 작아 지지만 생성 된 팩은 버전 1.4.4 이전의 Git 버전과 호환되지 않습니다. 직접 또는 dumb http 프로토콜을 통해 이러한 고대 Git 버전과 저장소를 공유해야하는 경우 구성 변수 &lt;code&gt;repack.UseDeltaBaseOffset&lt;/code&gt; 을 &quot;false&quot;로 설정하고 다시 포장해야합니다. 기본 프로토콜을 통한 이전 Git 버전의 액세스는이 경우 필요에 따라 즉시 변환이 수행되므로이 ​​옵션의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f861a2e54471285f5e27b71719f8d0cdb51509e" translate="yes" xml:space="preserve">
          <source>By default, the command shows the filename for each match. &lt;code&gt;-h&lt;/code&gt; option is used to suppress this output. &lt;code&gt;-H&lt;/code&gt; is there for completeness and does not do anything except it overrides &lt;code&gt;-h&lt;/code&gt; given earlier on the command line.</source>
          <target state="translated">기본적으로이 명령은 각 일치에 대한 파일 이름을 표시합니다. &lt;code&gt;-h&lt;/code&gt; 옵션은이 출력을 억제하는 데 사용됩니다. &lt;code&gt;-H&lt;/code&gt; 는 완전성을 위해 존재 하며 명령 행에서 이전에 제공된 &lt;code&gt;-h&lt;/code&gt; 를 대체하는 것을 제외하고는 아무것도하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="13a9b6e24e13c9eb4f96f597a6a5cd1c71b0690a" translate="yes" xml:space="preserve">
          <source>By default, the commands above can be executed only with the &lt;code&gt;-c&lt;/code&gt; option; the shell is not interactive.</source>
          <target state="translated">기본적으로 위의 명령은 &lt;code&gt;-c&lt;/code&gt; 옵션으로 만 실행할 수 있습니다 . 쉘은 대화식이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="96284dfd9f407661b68729a78fcd24af10b360fa" translate="yes" xml:space="preserve">
          <source>By default, the commits are shown in reverse chronological order.</source>
          <target state="translated">기본적으로 커밋은 역순으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="41e61e3f14f2f076835cbd248b96763ec755aaf1" translate="yes" xml:space="preserve">
          <source>By default, the configuration flag &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; is enabled in shared repositories, so that you cannot force a non fast-forwarding push into it.</source>
          <target state="translated">기본적으로 구성 저장소 &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; 는 공유 저장소에서 사용 가능하므로 빨리 감기되지 않은 푸시를 푸시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="96f5a0af42c4430da235fb8eb151d52244069b6f" translate="yes" xml:space="preserve">
          <source>By default, the notes shown are from the notes refs listed in the &lt;code&gt;core.notesRef&lt;/code&gt; and &lt;code&gt;notes.displayRef&lt;/code&gt; variables (or corresponding environment overrides). See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for more details.</source>
          <target state="translated">기본적으로 표시된 메모는 &lt;code&gt;core.notesRef&lt;/code&gt; 및 &lt;code&gt;notes.displayRef&lt;/code&gt; 변수 (또는 해당 환경 대체)에 나열된 메모 참조의 것입니다. 자세한 내용은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="720f82840fb154598c30c373c9317d22846223a4" translate="yes" xml:space="preserve">
          <source>By default, the output omits merges that are reachable from only one tip being shown. This option makes them visible.</source>
          <target state="translated">기본적으로 출력은 하나의 팁만 표시 할 수있는 병합을 생략합니다. 이 옵션을 사용하면 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5af8b38407e84c0cf68e927bffe60812fcb3c4e9" translate="yes" xml:space="preserve">
          <source>By default, the repository &quot;config&quot; file is shared across all working trees. If the config variables &lt;code&gt;core.bare&lt;/code&gt; or &lt;code&gt;core.worktree&lt;/code&gt; are already present in the config file, they will be applied to the main working trees only.</source>
          <target state="translated">기본적으로 저장소 &quot;config&quot;파일은 모든 작업 트리에서 공유됩니다. 구성 변수 &lt;code&gt;core.bare&lt;/code&gt; 또는 &lt;code&gt;core.worktree&lt;/code&gt; 가 이미 구성 파일에있는 경우 기본 작업 트리에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1d794a43930ea258acdc77025c8009e643f727f7" translate="yes" xml:space="preserve">
          <source>By default, the repository &lt;code&gt;config&lt;/code&gt; file is shared across all working trees. If the config variables &lt;code&gt;core.bare&lt;/code&gt; or &lt;code&gt;core.worktree&lt;/code&gt; are already present in the config file, they will be applied to the main working trees only.</source>
          <target state="translated">기본적으로 저장소 &lt;code&gt;config&lt;/code&gt; 파일은 모든 작업 트리에서 공유됩니다. 구성 변수 &lt;code&gt;core.bare&lt;/code&gt; 또는 &lt;code&gt;core.worktree&lt;/code&gt; 가 이미 구성 파일에있는 경우 기본 작업 트리에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="973434bf7e817a557d276186c33c139503bc7733" translate="yes" xml:space="preserve">
          <source>By default, the restore sources for working tree and the index are the index and &lt;code&gt;HEAD&lt;/code&gt; respectively. &lt;code&gt;--source&lt;/code&gt; could be used to specify a commit as the restore source.</source>
          <target state="translated">기본적으로 작업 트리 및 인덱스의 복원 소스는 각각 인덱스와 &lt;code&gt;HEAD&lt;/code&gt; 입니다. &lt;code&gt;--source&lt;/code&gt; 를 사용하여 커밋을 복원 소스로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6198a2f3a4209e82ce868cd683f2d31abc69a314" translate="yes" xml:space="preserve">
          <source>By default, the sparse-checkout file uses the same syntax as &lt;code&gt;.gitignore&lt;/code&gt; files.</source>
          <target state="translated">기본적으로 스파 스 체크 아웃 파일은 &lt;code&gt;.gitignore&lt;/code&gt; 파일 과 동일한 구문을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="22a25d0b8a2e5ce87fbc59e939918c48f09b2958" translate="yes" xml:space="preserve">
          <source>By default, the subject of a single patch is &quot;[PATCH] &quot; followed by the concatenation of lines from the commit message up to the first blank line (see the DISCUSSION section of &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;).</source>
          <target state="translated">기본적으로 단일 패치의 주제는 &quot;[PATCH]&quot;다음에 커밋 메시지에서 첫 번째 빈 줄까지의 행 연결입니다 ( &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 의 DISCUSSION 섹션 참조 ).</target>
        </trans-unit>
        <trans-unit id="9704a5c766445678507f7af7f587edd379d84cf0" translate="yes" xml:space="preserve">
          <source>By default, this uses the same built-in 3-way merge driver as is the case when the &lt;code&gt;merge&lt;/code&gt; attribute is set. However, the &lt;code&gt;merge.default&lt;/code&gt; configuration variable can name different merge driver to be used with paths for which the &lt;code&gt;merge&lt;/code&gt; attribute is unspecified.</source>
          <target state="translated">기본적으로 &lt;code&gt;merge&lt;/code&gt; 속성이 설정된 경우와 동일한 내장 3 방향 병합 드라이버를 사용합니다. 그러나 &lt;code&gt;merge.default&lt;/code&gt; 구성 변수는 &lt;code&gt;merge&lt;/code&gt; 속성이 지정되지 않은 경로와 함께 사용할 다른 병합 드라이버의 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb719865937ac64c446567c5ed40eaa328116bc6" translate="yes" xml:space="preserve">
          <source>By default, this will return your tree to the commit that was checked out before &lt;code&gt;git bisect start&lt;/code&gt;. (A new &lt;code&gt;git bisect start&lt;/code&gt; will also do that, as it cleans up the old bisection state.)</source>
          <target state="translated">기본적으로 이것은 &lt;code&gt;git bisect start&lt;/code&gt; 전에 체크 아웃 된 커밋으로 트리를 반환합니다 . (새로운 &lt;code&gt;git bisect start&lt;/code&gt; 는 이전 bisection 상태를 정리하기 때문에 그렇게 할 것입니다.)</target>
        </trans-unit>
        <trans-unit id="d0131180d6acb72b151d5763656b5ee5ec67d9f6" translate="yes" xml:space="preserve">
          <source>By default, tracked files are not shown at all since they are not subject to exclude rules; but see &amp;lsquo;--no-index&amp;rsquo;.</source>
          <target state="translated">기본적으로 추적 된 파일은 규칙을 배제하지 않기 때문에 전혀 표시되지 않습니다. 그러나 '-인덱스 없음'을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="055c65bfcac14882dd3e00e849a98c92a82c1b80" translate="yes" xml:space="preserve">
          <source>By default, when a file &lt;code&gt;path&lt;/code&gt; exists in the index, &lt;code&gt;git update-index&lt;/code&gt; refuses an attempt to add &lt;code&gt;path/file&lt;/code&gt;. Similarly if a file &lt;code&gt;path/file&lt;/code&gt; exists, a file &lt;code&gt;path&lt;/code&gt; cannot be added. With --replace flag, existing entries that conflict with the entry being added are automatically removed with warning messages.</source>
          <target state="translated">기본적으로 파일 &lt;code&gt;path&lt;/code&gt; 가 인덱스에 존재하면 &lt;code&gt;git update-index&lt;/code&gt; 는 &lt;code&gt;path/file&lt;/code&gt; 추가 시도를 거부 합니다 . 마찬가지로 파일 &lt;code&gt;path/file&lt;/code&gt; 이 존재하면 파일 &lt;code&gt;path&lt;/code&gt; 를 추가 할 수 없습니다. --replace 플래그를 사용하면 추가되는 항목과 충돌하는 기존 항목이 경고 메시지와 함께 자동으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="299147d01326bdbf4534148e9d9d3fd6c07e2d71" translate="yes" xml:space="preserve">
          <source>By default, when running &lt;code&gt;git sparse-checkout init&lt;/code&gt;, the root directory is added as a parent pattern. At this point, the sparse-checkout file contains the following patterns:</source>
          <target state="translated">기본적으로 &lt;code&gt;git sparse-checkout init&lt;/code&gt; 를 실행 하면 루트 디렉토리가 상위 패턴으로 추가됩니다. 이때 스파 스 체크 아웃 파일에는 다음 패턴이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="783945c123405237e5678d472e74b9fc2e2ebcbd" translate="yes" xml:space="preserve">
          <source>By default, when tracing is activated, Git redacts the values of cookies, the &quot;Authorization:&quot; header, and the &quot;Proxy-Authorization:&quot; header. Set this variable to &lt;code&gt;0&lt;/code&gt; to prevent this redaction.</source>
          <target state="translated">기본적으로 추적이 활성화되면 Git은 쿠키, &quot;Authorization :&quot;헤더 및 &quot;Proxy-Authorization :&quot;헤더의 값을 수정합니다. 이 수정을 방지 하려면이 변수를 &lt;code&gt;0&lt;/code&gt; 으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="93102cd6e4e7e1fd617df0a6116a6e8dabe44d67" translate="yes" xml:space="preserve">
          <source>By design, Git treats data trusted to it with caution. However, even in the absence of bugs in Git itself, it is still possible that hardware or operating system errors could corrupt data.</source>
          <target state="translated">설계 상 Git은 신뢰할 수있는 데이터를주의해서 취급합니다. 그러나 Git 자체에 버그가없는 경우에도 하드웨어 또는 운영 체제 오류가 데이터를 손상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0405b4cdacdc12c8e141d09b19a221661400dcb6" translate="yes" xml:space="preserve">
          <source>By examining &lt;code&gt;t/.gitattributes&lt;/code&gt; (which is in the same directory as the path in question), Git finds that the first line matches. &lt;code&gt;merge&lt;/code&gt; attribute is set. It also finds that the second line matches, and attributes &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; are unset.</source>
          <target state="translated">검사하여 &lt;code&gt;t/.gitattributes&lt;/code&gt; 를 (해당 경로로 같은 디렉토리에있는), 힘내는 첫 번째 줄의 일치를 찾습니다. &lt;code&gt;merge&lt;/code&gt; 속성이 설정되었습니다. 또한 두 번째 줄이 일치하고 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 속성 이 설정되지 않은 것을 발견합니다 .</target>
        </trans-unit>
        <trans-unit id="6019b6edc3f8183a9650b814f1e96d2397d6c92e" translate="yes" xml:space="preserve">
          <source>By now, you know what the index is (and find the corresponding data structures in &lt;code&gt;cache.h&lt;/code&gt;), and that there are just a couple of object types (blobs, trees, commits and tags) which inherit their common structure from &lt;code&gt;struct object&lt;/code&gt;, which is their first member (and thus, you can cast e.g. &lt;code&gt;(struct object *)commit&lt;/code&gt; to achieve the &lt;code&gt;same&lt;/code&gt; as &lt;code&gt;&amp;amp;commit&amp;rarr;object&lt;/code&gt;, i.e. get at the object name and flags).</source>
          <target state="translated">이제 인덱스가 무엇인지 (그리고 &lt;code&gt;cache.h&lt;/code&gt; 에서 해당 데이터 구조를 찾으십시오 ), &lt;code&gt;struct object&lt;/code&gt; 에서 공통 구조를 상속하는 몇 가지 객체 유형 (블롭, 트리, 커밋 및 태그)이 있음을 알고 있습니다 . 이것은 첫 번째 멤버이므로 (예를 들어 &lt;code&gt;(struct object *)commit&lt;/code&gt; 을 캐스팅 하여 &lt;code&gt;&amp;amp;commit&amp;rarr;object&lt;/code&gt; &lt;code&gt;same&lt;/code&gt; 하게 달성 할 수 있습니다 ( 예 : 객체 이름과 플래그를 얻음).</target>
        </trans-unit>
        <trans-unit id="a2527de53eca60aedafd214cc771f0facd3ab5eb" translate="yes" xml:space="preserve">
          <source>By now, you know what the index is (and find the corresponding data structures in &lt;code&gt;cache.h&lt;/code&gt;), and that there are just a couple of object types (blobs, trees, commits and tags) which inherit their common structure from &lt;code&gt;struct object&lt;/code&gt;, which is their first member (and thus, you can cast e.g. &lt;code&gt;(struct object *)commit&lt;/code&gt; to achieve the &lt;code&gt;same&lt;/code&gt; as &lt;code&gt;&amp;amp;commit-&amp;gt;object&lt;/code&gt;, i.e. get at the object name and flags).</source>
          <target state="translated">이제 인덱스가 무엇인지 (그리고 &lt;code&gt;cache.h&lt;/code&gt; 에서 해당 데이터 구조를 찾습니다 ), &lt;code&gt;struct object&lt;/code&gt; 에서 공통 구조를 상속하는 몇 가지 객체 유형 (블롭, 트리, 커밋 및 태그) 만 있음을 알고 있습니다 . 이것은 첫 번째 멤버입니다 (따라서 예를 들어 &lt;code&gt;(struct object *)commit&lt;/code&gt; 을 캐스팅 하여 &lt;code&gt;&amp;amp;commit-&amp;gt;object&lt;/code&gt; commit- &amp;gt; object &lt;code&gt;same&lt;/code&gt; 하게 달성 할 수 있습니다. 즉, 객체 이름 및 플래그를 가져옵니다).</target>
        </trans-unit>
        <trans-unit id="7fc0a0343ad2fdcba9cb4eccfe4e06a4bbef7383" translate="yes" xml:space="preserve">
          <source>By replacing the command &quot;pick&quot; with the command &quot;edit&quot;, you can tell &lt;code&gt;git rebase&lt;/code&gt; to stop after applying that commit, so that you can edit the files and/or the commit message, amend the commit, and continue rebasing.</source>
          <target state="translated">&quot;pick&quot;명령을 &quot;edit&quot;명령으로 대체하면 커밋을 적용한 후 &lt;code&gt;git rebase&lt;/code&gt; 에게 중지하도록 지시하여 파일 및 / 또는 커밋 메시지를 편집하고 커밋을 수정 한 후 리베이스를 계속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38723ef3d6552eb371410d9afcccdbb440b0f54e" translate="yes" xml:space="preserve">
          <source>By setting this variable to a string, &lt;code&gt;git receive-pack&lt;/code&gt; will accept a &lt;code&gt;git push --signed&lt;/code&gt; and verifies it by using a &quot;nonce&quot; protected by HMAC using this string as a secret key.</source>
          <target state="translated">이 변수를 문자열로 설정하면 &lt;code&gt;git receive-pack&lt;/code&gt; 은 &lt;code&gt;git push --signed&lt;/code&gt; 를 받아들이고이 문자열을 비밀 키로 사용하여 HMAC로 보호되는 &quot;nonce&quot;를 사용하여 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b0ec84a28e8863d61bfe49155bbc56f1b080a18a" translate="yes" xml:space="preserve">
          <source>By specifying &lt;code&gt;base&lt;/code&gt; as the limit, you can avoid listing commits between &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;topic&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 를 제한으로 지정 하면 &lt;code&gt;base&lt;/code&gt; 와 &lt;code&gt;topic&lt;/code&gt; 사이에 커밋이 나열되는 것을 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bac0dcb4a691d6bbb7adf78bc3225e969e991ed2" translate="yes" xml:space="preserve">
          <source>By specifying a single suffix in this variable, any tagname containing that suffix will appear before the corresponding main release. E.g. if the variable is set to &quot;-rc&quot;, then all &quot;1.0-rcX&quot; tags will appear before &quot;1.0&quot;. If specified multiple times, once per suffix, then the order of suffixes in the configuration will determine the sorting order of tagnames with those suffixes. E.g. if &quot;-pre&quot; appears before &quot;-rc&quot; in the configuration, then all &quot;1.0-preX&quot; tags will be listed before any &quot;1.0-rcX&quot; tags. The placement of the main release tag relative to tags with various suffixes can be determined by specifying the empty suffix among those other suffixes. E.g. if the suffixes &quot;-rc&quot;, &quot;&quot;, &quot;-ck&quot; and &quot;-bfs&quot; appear in the configuration in this order, then all &quot;v4.8-rcX&quot; tags are listed first, followed by &quot;v4.8&quot;, then &quot;v4.8-ckX&quot; and finally &quot;v4.8-bfsX&quot;.</source>
          <target state="translated">이 변수에 단일 접미사를 지정하면 해당 접미사가 포함 된 태그 이름이 해당 주 릴리스 전에 나타납니다. 예를 들어 변수가 &quot;-rc&quot;로 설정되면 모든 &quot;1.0-rcX&quot;태그가 &quot;1.0&quot;앞에 나타납니다. 접미사마다 한 번씩 여러 번 지정된 경우 구성에서 접미사 순서에 따라 해당 접미사와 함께 태그 이름의 정렬 순서가 결정됩니다. 예를 들어, 구성에서 &quot;-pre&quot;가 &quot;-rc&quot;앞에 나타나면 모든 &quot;1.0-preX&quot;태그가 &quot;1.0-rcX&quot;태그 앞에 나열됩니다. 다양한 접미사가있는 태그를 기준으로 주 릴리스 태그의 배치는 다른 접미사 중에서 빈 접미사를 지정하여 확인할 수 있습니다. 예를 들어 접미사 &quot;-rc&quot;, &quot;&quot;, &quot;-ck&quot;및 &quot;-bfs&quot;이 순서대로 구성에 나타나면 모든 &quot;v4.8-rcX&quot;태그가 먼저 나열되고 &quot;v4.8&quot;, &quot;v4.8-ckX&quot;및 &quot;v4.8-bfsX&quot;가 차례로 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="73d10606466530ea834324e2af3cd4f5fdf3b7ef" translate="yes" xml:space="preserve">
          <source>By using &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; arguments, e.g., path limiters, you can limit the set of revisions which get rewritten. However, positive refs on the command line are distinguished: we don&amp;rsquo;t let them be excluded by such limiters. For this purpose, they are instead rewritten to point at the nearest ancestor that was not excluded.</source>
          <target state="translated">사용하여 &lt;a href=&quot;git-rev-list&quot;&gt;자식-REV-목록 [1]&lt;/a&gt; 인수는, 예를 들어, 경로 리미터, 당신은 다시 얻을 개정의 집합을 제한 할 수 있습니다. 그러나 명령 행에 대한 긍정적 인 참조는 구별됩니다. 이러한 제한에 의해 제외되지 않습니다. 이를 위해, 대신 제외되지 않은 가장 가까운 조상을 가리 키도록 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="2fbc7b3eb43b76b2746e664c28cb9ad054eb9a86" translate="yes" xml:space="preserve">
          <source>Bypass the post-rewrite hook.</source>
          <target state="translated">다시 쓰기 후 후크를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="2b7976aa8c8ee62577557b0faf6cd45c7d87d599" translate="yes" xml:space="preserve">
          <source>C: copy of a file into a new one</source>
          <target state="translated">C : 파일을 새 파일로 복사</target>
        </trans-unit>
        <trans-unit id="8cb2e80198d1a22ece7b2150ad287e7b39ba33cd" translate="yes" xml:space="preserve">
          <source>CHUNK DATA:</source>
          <target state="translated">청크 데이터 :</target>
        </trans-unit>
        <trans-unit id="9da2b59eccc71e5c2791bd9f721e6de7f9e4a527" translate="yes" xml:space="preserve">
          <source>CHUNK LOOKUP:</source>
          <target state="translated">청크 룩업 :</target>
        </trans-unit>
        <trans-unit id="025c408a5504f0e808d096b14c696e6a19ee3cbf" translate="yes" xml:space="preserve">
          <source>CONTENT_TYPE</source>
          <target state="translated">CONTENT_TYPE</target>
        </trans-unit>
        <trans-unit id="45649b220c5ae097eced7a136897aeb49a47599c" translate="yes" xml:space="preserve">
          <source>CRLF Line Ending Conversions</source>
          <target state="translated">CRLF 줄 끝 변환</target>
        </trans-unit>
        <trans-unit id="4d982ea44c2ace64324fd7fbacbc4c4d91f3e200" translate="yes" xml:space="preserve">
          <source>CRLF conversion bears a slight chance of corrupting data. When it is enabled, Git will convert CRLF to LF during commit and LF to CRLF during checkout. A file that contains a mixture of LF and CRLF before the commit cannot be recreated by Git. For text files this is the right thing to do: it corrects line endings such that we have only LF line endings in the repository. But for binary files that are accidentally classified as text the conversion can corrupt data.</source>
          <target state="translated">CRLF 변환은 데이터를 약간 손상시킬 수 있습니다. 활성화되면 Git은 커밋 중에 CRLF를 LF로 변환하고 체크 아웃 중에 LF를 CRLF로 변환합니다. 커밋 전에 LF와 CRLF가 혼합 된 파일은 Git에서 다시 만들 수 없습니다. 텍스트 파일의 경우 이것이 올바른 일입니다. 저장소에 LF 줄 끝만 있도록 줄 끝을 수정합니다. 그러나 실수로 텍스트로 분류 된 이진 파일의 경우 변환시 데이터가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2dadeb076c332a230cd3f419ccce73fc473e9b1" translate="yes" xml:space="preserve">
          <source>CVS 1.11.17 on MacOSX (from Fink package)</source>
          <target state="translated">MacOSX의 CVS 1.11.17 (Fink 패키지)</target>
        </trans-unit>
        <trans-unit id="31ba0d2766dea7911d9b0133542d1dae7c40d21b" translate="yes" xml:space="preserve">
          <source>CVS 1.12.9 on Debian</source>
          <target state="translated">데비안의 CVS 1.12.9</target>
        </trans-unit>
        <trans-unit id="c10230da83b7ef151899f83d727ffc465e699ce7" translate="yes" xml:space="preserve">
          <source>CVS by default uses the Unix username when writing its commit logs. Using this option and an author-conv-file maps the name recorded in CVS to author name, e-mail and optional time zone:</source>
          <target state="translated">CVS는 커밋 로그를 작성할 때 기본적으로 Unix 사용자 이름을 사용합니다. 이 옵션과 author-conv-file을 사용하면 CVS에 기록 된 이름을 저자 이름, 전자 메일 및 선택적 시간대에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="edcdc296b2872a295927e706b64b0873d75bd7e8" translate="yes" xml:space="preserve">
          <source>CVS clients cannot tag, branch or perform Git merges.</source>
          <target state="translated">CVS 클라이언트는 Git 병합을 태그 지정, 분기 또는 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="98b46c65d5bf63821f6ce6bd595bdc32473d951c" translate="yes" xml:space="preserve">
          <source>CVS module/Git head name</source>
          <target state="translated">CVS 모듈 / Git 헤드 이름</target>
        </trans-unit>
        <trans-unit id="49adb1e8c5b17953ca229c40061a8d1bb5bb8b5e" translate="yes" xml:space="preserve">
          <source>CVS users are accustomed to giving a group of developers commit access to a common repository. As we&amp;rsquo;ve seen, this is also possible with Git. However, the distributed nature of Git allows other development models, and you may want to first consider whether one of them might be a better fit for your project.</source>
          <target state="translated">CVS 사용자는 개발자 그룹이 공통 리포지토리에 액세스 할 수 있도록하는 데 익숙합니다. 우리가 보았 듯이 이것은 Git에서도 가능하다. 그러나 Git의 분산 특성으로 인해 다른 개발 모델을 사용할 수 있으므로 먼저 모델 중 하나가 프로젝트에 더 적합한 지 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aed153eb92fac6b914dbc191a216beb300201f66" translate="yes" xml:space="preserve">
          <source>CVS-style shared repository.</source>
          <target state="translated">CVS 스타일 공유 저장소</target>
        </trans-unit>
        <trans-unit id="f52ad32f29f6847c4f98f4be5fc01986743d4aae" translate="yes" xml:space="preserve">
          <source>Cache credentials in memory for a short period of time. See &lt;a href=&quot;git-credential-cache&quot;&gt;git-credential-cache[1]&lt;/a&gt; for details.</source>
          <target state="translated">짧은 기간 동안 메모리에 자격 증명을 캐시합니다. 자세한 내용은 &lt;a href=&quot;git-credential-cache&quot;&gt;git-credential-cache [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="68d01495331ef3ec55abb430492aa431fb98900b" translate="yes" xml:space="preserve">
          <source>Cached mode</source>
          <target state="translated">캐시 모드</target>
        </trans-unit>
        <trans-unit id="bc41c881675379eb55dc52ac754cd0a47e293c0b" translate="yes" xml:space="preserve">
          <source>Caching. Textconv caching can speed up repeated diffs, such as those you might trigger by running &lt;code&gt;git log -p&lt;/code&gt;.</source>
          <target state="translated">캐싱. Textconv 캐싱은 &lt;code&gt;git log -p&lt;/code&gt; 를 실행하여 트리거 할 수있는 반복 diff의 속도를 높일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3bd71fe43527e264035373707bb05e34bacabd4" translate="yes" xml:space="preserve">
          <source>Call the corresponding server-side command to support the client&amp;rsquo;s &lt;code&gt;git push&lt;/code&gt;, &lt;code&gt;git fetch&lt;/code&gt;, or &lt;code&gt;git archive --remote&lt;/code&gt; request.</source>
          <target state="translated">해당 서버 측 명령을 호출하여 클라이언트의 &lt;code&gt;git push&lt;/code&gt; , &lt;code&gt;git fetch&lt;/code&gt; 또는 &lt;code&gt;git archive --remote&lt;/code&gt; 요청을 지원하십시오.</target>
        </trans-unit>
        <trans-unit id="3907fb8eaa84bdb8f3cc45ad006023c90615ad1f" translate="yes" xml:space="preserve">
          <source>Can attempt to connect to &lt;code&gt;git receive-pack&lt;/code&gt; (for pushing), &lt;code&gt;git upload-pack&lt;/code&gt;, etc for communication using git&amp;rsquo;s native packfile protocol. This requires a bidirectional, full-duplex connection.</source>
          <target state="translated">git의 기본 packfile 프로토콜을 사용하여 통신 하기 위해 &lt;code&gt;git receive-pack&lt;/code&gt; (밀어 넣기), &lt;code&gt;git upload-pack&lt;/code&gt; 등에 연결할 수 있습니다. 이를 위해서는 양방향 전이중 연결이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0c6fd80a7557d1e5d2aaff98df3b675a4f3e3e9e" translate="yes" xml:space="preserve">
          <source>Can be overridden by the &lt;code&gt;GIT_PROXY_COMMAND&lt;/code&gt; environment variable (which always applies universally, without the special &quot;for&quot; handling).</source>
          <target state="translated">&lt;code&gt;GIT_PROXY_COMMAND&lt;/code&gt; 환경 변수 (특별한 &quot;for&quot;처리없이 항상 보편적으로 적용됨) 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f39962decf24e67df63f769ebf7a91027019ae1" translate="yes" xml:space="preserve">
          <source>Can be overridden by the &lt;code&gt;GIT_SSL_CIPHER_LIST&lt;/code&gt; environment variable. To force git to use libcurl&amp;rsquo;s default cipher list and ignore any explicit http.sslCipherList option, set &lt;code&gt;GIT_SSL_CIPHER_LIST&lt;/code&gt; to the empty string.</source>
          <target state="translated">&lt;code&gt;GIT_SSL_CIPHER_LIST&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 . git이 libcurl의 기본 암호 목록을 사용하도록하고 명시적인 http.sslCipherList 옵션을 무시 하려면 &lt;code&gt;GIT_SSL_CIPHER_LIST&lt;/code&gt; 를 빈 문자열로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="29d57ff400cc012cacf16bd510a83a1f80c69dcf" translate="yes" xml:space="preserve">
          <source>Can be overridden by the &lt;code&gt;GIT_SSL_VERSION&lt;/code&gt; environment variable. To force git to use libcurl&amp;rsquo;s default ssl version and ignore any explicit http.sslversion option, set &lt;code&gt;GIT_SSL_VERSION&lt;/code&gt; to the empty string.</source>
          <target state="translated">&lt;code&gt;GIT_SSL_VERSION&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 . git이 libcurl의 기본 SSL 버전을 사용하도록하고 명시적인 http.sslversion 옵션을 무시 하려면 &lt;code&gt;GIT_SSL_VERSION&lt;/code&gt; 을 빈 문자열로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="8710d5603018e270e9135bc9b07e18583e6e40b7" translate="yes" xml:space="preserve">
          <source>Can be overridden with the &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; 환경 변수 로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3ab6f60ab10fc57456b8912494e28284fd290bc" translate="yes" xml:space="preserve">
          <source>Can be set using the &lt;code&gt;GITWEB_SITENAME&lt;/code&gt; at build time. Unset by default.</source>
          <target state="translated">빌드시 &lt;code&gt;GITWEB_SITENAME&lt;/code&gt; 을 사용하여 설정할 수 있습니다 . 기본적으로 설정 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="217827b02c2eeb06477e279b6b6efc5d7d10ed39" translate="yes" xml:space="preserve">
          <source>Can be used in conjunction with &lt;code&gt;--single-branch&lt;/code&gt; to clone and maintain a branch with no references other than a single cloned branch. This is useful e.g. to maintain minimal clones of the default branch of some repository for search indexing.</source>
          <target state="translated">단일 단일 분기 이외의 참조가없는 &lt;code&gt;--single-branch&lt;/code&gt; 를 복제하고 유지하기 위해 --single-branch 와 함께 사용할 수 있습니다 . 예를 들어 검색 인덱싱을 위해 일부 리포지토리의 기본 분기에 대한 최소 복제본을 유지 관리하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a9691ee782e933498eb75769eeec906fc37e3a47" translate="yes" xml:space="preserve">
          <source>Can discover remote refs and output objects reachable from them as a stream in fast-import format.</source>
          <target state="translated">빠른 참조 형식의 스트림으로 원격 참조 및 출력 객체에 도달 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90035edf92bee77fbf7fe329bbc961839dc96080" translate="yes" xml:space="preserve">
          <source>Can discover remote refs and push local commits and the history leading up to them to new or existing remote refs.</source>
          <target state="translated">원격 심판을 발견하고 로컬 커밋과 이력을 가져 오는 기록을 신규 또는 기존 원격 심판으로 푸시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="138c5e6b546882127de4e82d6394ea6b4a6a09ca" translate="yes" xml:space="preserve">
          <source>Can discover remote refs and push specified objects from a fast-import stream to remote refs.</source>
          <target state="translated">원격 참조를 발견하고 지정된 객체를 빠른 가져 오기 스트림에서 원격 참조로 푸시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4530b46452bf0ddccff90b10194b6dc8dee0aff" translate="yes" xml:space="preserve">
          <source>Can discover remote refs and transfer objects reachable from them to the local object store.</source>
          <target state="translated">원격 참조를 발견하고 도달 할 수있는 오브젝트를 로컬 오브젝트 저장소로 전송할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7decaa19c2a5956f9383448e881b3336964a5bef" translate="yes" xml:space="preserve">
          <source>Can guarantee that when a clone is requested, the received pack is self contained and is connected.</source>
          <target state="translated">복제가 요청 될 때 수신 된 팩은 자체 포함되어 있고 연결되어 있음을 보장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7ebace43478348d6004d061ea665f140df1bb53" translate="yes" xml:space="preserve">
          <source>Can try to connect to &lt;code&gt;git upload-pack&lt;/code&gt; (for fetching), &lt;code&gt;git receive-pack&lt;/code&gt;, etc for communication using the Git&amp;rsquo;s native packfile protocol. This requires a bidirectional, full-duplex connection.</source>
          <target state="translated">Git의 기본 팩 파일 프로토콜을 사용하여 통신 하기 위해 &lt;code&gt;git upload-pack&lt;/code&gt; (fetching), &lt;code&gt;git receive-pack&lt;/code&gt; 등에 연결할 수 있습니다. 이를 위해서는 양방향 전이중 연결이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4cb14361f0a5ad881a24c94d8c006e5f643d8a87" translate="yes" xml:space="preserve">
          <source>Cancel the operation and return to the pre-sequence state.</source>
          <target state="translated">작업을 취소하고 사전 시퀀스 상태로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="ca09c54bff74a82bae543ebe259f7452ee8c5293" translate="yes" xml:space="preserve">
          <source>Capabilities</source>
          <target state="translated">Capabilities</target>
        </trans-unit>
        <trans-unit id="20243c460d0e899aa2ea919e5a33ddf3fc3c28ee" translate="yes" xml:space="preserve">
          <source>Capabilities for Fetching</source>
          <target state="translated">가져 오기 기능</target>
        </trans-unit>
        <trans-unit id="2cf429aa6c517aac8e25fa8619402627623a5d1f" translate="yes" xml:space="preserve">
          <source>Capabilities for Pushing</source>
          <target state="translated">추진 능력</target>
        </trans-unit>
        <trans-unit id="a02cd245f4a5359f48f45e974d4d2aeb3f737ec2" translate="yes" xml:space="preserve">
          <source>Capability advertisement</source>
          <target state="translated">기능성 광고</target>
        </trans-unit>
        <trans-unit id="fbb741f1d3fe925738bd52e124aa5bcdfaec72b5" translate="yes" xml:space="preserve">
          <source>Case 3 is slightly tricky and needs explanation. The result from this rule logically should be to remove the path if the user staged the removal of the path and then switching to a new branch. That however will prevent the initial checkout from happening, so the rule is modified to use M (new tree) only when the content of the index is empty. Otherwise the removal of the path is kept as long as $H and $M are the same.</source>
          <target state="translated">사례 3은 약간 까다 롭고 설명이 필요합니다. 이 규칙의 결과는 사용자가 경로 제거를 준비한 다음 새 분기로 전환하는 경우 경로를 논리적으로 제거해야합니다. 그러나 초기 체크 아웃이 발생하지 않으므로 인덱스 내용이 비어있는 경우에만 M (새 트리)을 사용하도록 규칙이 수정됩니다. 그렇지 않으면 $ H와 $ M이 동일한 한 경로 제거가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="e09c27f67e4fbebb877a3f28eee7f79c8bd9d162" translate="yes" xml:space="preserve">
          <source>Case insensitive match.</source>
          <target state="translated">대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ba6868684fb15f285ba371e8f8692f5e6c1b769" translate="yes" xml:space="preserve">
          <source>Cause the logical variables to be listed. In addition, all the variables of the Git configuration file .git/config are listed as well. (However, the configuration variables listing functionality is deprecated in favor of &lt;code&gt;git config -l&lt;/code&gt;.)</source>
          <target state="translated">논리 변수가 나열되도록합니다. 또한 Git 구성 파일 .git / config의 모든 변수도 나열됩니다. (그러나 &lt;code&gt;git config -l&lt;/code&gt; 대신 구성 변수를 나열하는 구성 변수는 더 이상 사용되지 않습니다 .)</target>
        </trans-unit>
        <trans-unit id="b783ff5188b18ab4ca3191c5116581bc5ecb01a2" translate="yes" xml:space="preserve">
          <source>Causes fast-import to echo the entire line to its own standard output. This command is optional and is not needed to perform an import.</source>
          <target state="translated">빠른 가져 오기로 전체 라인을 자체 표준 출력으로 에코합니다. 이 명령은 선택 사항이며 가져 오기를 수행하는 데 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12b02e08644454fc1547d338b5de4943ef66f77b" translate="yes" xml:space="preserve">
          <source>Causes fast-import to print a blob in &lt;code&gt;cat-file --batch&lt;/code&gt; format to the file descriptor set with &lt;code&gt;--cat-blob-fd&lt;/code&gt; or &lt;code&gt;stdout&lt;/code&gt; if unspecified.</source>
          <target state="translated">&lt;code&gt;cat-file --batch&lt;/code&gt; 형식의 &lt;code&gt;--cat-blob-fd&lt;/code&gt; 지정하지 않으면 --cat-blob-fd 또는 &lt;code&gt;stdout&lt;/code&gt; 을 사용하여 파일 디스크립터 세트에 BLOB를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="b8e75699b5276c39faaefd045a6a5b904b73ada6" translate="yes" xml:space="preserve">
          <source>Causes fast-import to print a blob to a file descriptor previously arranged with the &lt;code&gt;--cat-blob-fd&lt;/code&gt; argument. The command otherwise has no impact on the current import; its main purpose is to retrieve blobs that may be in fast-import&amp;rsquo;s memory but not accessible from the target repository.</source>
          <target state="translated">&lt;code&gt;--cat-blob-fd&lt;/code&gt; 인수로 이전에 배열 된 파일 디스크립터에 Blob을 빠른 가져 오기로 인쇄합니다 . 그렇지 않으면 명령은 현재 가져 오기에 영향을 미치지 않습니다. 주요 목적은 빠른 가져 오기 메모리에 있지만 대상 리포지토리에서 액세스 할 수없는 블롭을 검색하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ec5756843c97a7c2f1df63914ede6a2099f489a" translate="yes" xml:space="preserve">
          <source>Causes fast-import to print a line describing a directory entry in &lt;code&gt;ls-tree&lt;/code&gt; format to the file descriptor set with &lt;code&gt;--cat-blob-fd&lt;/code&gt; or &lt;code&gt;stdout&lt;/code&gt; if unspecified.</source>
          <target state="translated">&lt;code&gt;ls-tree&lt;/code&gt; 형식 의 디렉토리 항목을 설명하는 행 을 &lt;code&gt;--cat-blob-fd&lt;/code&gt; 또는 &lt;code&gt;stdout&lt;/code&gt; ( 지정되지 않은 경우)으로 설정 한 파일 디스크립터 에 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="886958bd2ea3f9b4ef6490b2b36e023c05b21b29" translate="yes" xml:space="preserve">
          <source>Causes fast-import to print the SHA-1 corresponding to a mark to stdout or to the file descriptor previously arranged with the &lt;code&gt;--cat-blob-fd&lt;/code&gt; argument. The command otherwise has no impact on the current import; its purpose is to retrieve SHA-1s that later commits might want to refer to in their commit messages.</source>
          <target state="translated">stdout 또는 &lt;code&gt;--cat-blob-fd&lt;/code&gt; 인수로 이전에 배열 된 파일 디스크립터에 해당하는 SHA-1을 빠른 가져 오기로 인쇄합니다 . 그렇지 않으면 명령은 현재 가져 오기에 영향을 미치지 않습니다. 그 목적은 나중에 커밋이 커밋 메시지에서 참조하려는 SHA-1을 검색하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a62399ea6471f58f0ac3e20d903be4ac533d6d4e" translate="yes" xml:space="preserve">
          <source>Causes fast-import to print the SHA-1 corresponding to a mark to the file descriptor set with &lt;code&gt;--cat-blob-fd&lt;/code&gt;, or &lt;code&gt;stdout&lt;/code&gt; if unspecified.</source>
          <target state="translated">&lt;code&gt;--cat-blob-fd&lt;/code&gt; 를 사용하여 파일 디스크립터 세트에 마크에 해당하는 SHA-1을 인쇄 하거나 , 지정되지 않은 경우 &lt;code&gt;stdout&lt;/code&gt; 을 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="b482598ddd71627c6a7b2ff32a0b59803f8fd34f" translate="yes" xml:space="preserve">
          <source>Causes fast-import to print the entire &lt;code&gt;progress&lt;/code&gt; line unmodified to its standard output channel (file descriptor 1) when the command is processed from the input stream. The command otherwise has no impact on the current import, or on any of fast-import&amp;rsquo;s internal state.</source>
          <target state="translated">명령이 입력 스트림에서 처리 될 때 전체 가져 오기 행이 표준 출력 채널 (파일 설명자 1)로 수정되지 않은 전체 &lt;code&gt;progress&lt;/code&gt; 행 을 인쇄합니다 . 그렇지 않으면 명령은 현재 가져 오기 또는 빠른 가져 오기의 내부 상태에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55a89527100d7affacb785a535913eceec75eda6" translate="yes" xml:space="preserve">
          <source>Caution</source>
          <target state="translated">Caution</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="62c56e9140b73b971227c6e095597a6888ab6f0b" translate="yes" xml:space="preserve">
          <source>Certain operations by Git can be influenced by assigning particular attributes to a path. Currently, the following operations are attributes-aware.</source>
          <target state="translated">특정 속성을 경로에 할당하면 Git의 특정 작업에 영향을 줄 수 있습니다. 현재 다음 작업은 속성을 인식합니다.</target>
        </trans-unit>
        <trans-unit id="ce89ebfc7c6f30e38c61f750189a14aac995df3f" translate="yes" xml:space="preserve">
          <source>Change daemon&amp;rsquo;s uid and gid before entering the service loop. When only &lt;code&gt;--user&lt;/code&gt; is given without &lt;code&gt;--group&lt;/code&gt;, the primary group ID for the user is used. The values of the option are given to &lt;code&gt;getpwnam(3)&lt;/code&gt; and &lt;code&gt;getgrnam(3)&lt;/code&gt; and numeric IDs are not supported.</source>
          <target state="translated">서비스 루프에 들어가기 전에 데몬의 uid와 gid를 변경하십시오. &lt;code&gt;--group&lt;/code&gt; 없이 &lt;code&gt;--user&lt;/code&gt; 만 제공 하면 사용자의 기본 그룹 ID가 사용됩니다. 옵션 값은 &lt;code&gt;getpwnam(3)&lt;/code&gt; 및 &lt;code&gt;getgrnam(3)&lt;/code&gt; 되며 숫자 ID는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8d5e6dcdbe26b10de586e21b98816e7aa3c05a4" translate="yes" xml:space="preserve">
          <source>Change output color. Followed by &lt;code&gt;:&amp;lt;colorname&amp;gt;&lt;/code&gt;, where color names are described under Values in the &quot;CONFIGURATION FILE&quot; section of &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;. For example, &lt;code&gt;%(color:bold red)&lt;/code&gt;.</source>
          <target state="translated">출력 색상을 변경하십시오. 뒤에 &lt;code&gt;:&amp;lt;colorname&amp;gt;&lt;/code&gt; 이 있습니다 . 여기서 색상 이름은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 &quot;CONFIGURATION FILE&quot;섹션에있는 값에 설명되어 있습니다. 예를 들어 &lt;code&gt;%(color:bold red)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4e718f5f36cc4b622f94d06a68422a543373288f" translate="yes" xml:space="preserve">
          <source>Changed Tracked Entries</source>
          <target state="translated">변경된 추적 항목</target>
        </trans-unit>
        <trans-unit id="a838ac0a12d74a72136f3630d86af0c9b1c990e6" translate="yes" xml:space="preserve">
          <source>Changes URLs for the remote. Sets first URL for remote &amp;lt;name&amp;gt; that matches regex &amp;lt;oldurl&amp;gt; (first URL if no &amp;lt;oldurl&amp;gt; is given) to &amp;lt;newurl&amp;gt;. If &amp;lt;oldurl&amp;gt; doesn&amp;rsquo;t match any URL, an error occurs and nothing is changed.</source>
          <target state="translated">리모컨의 URL을 변경합니다. 정규식 &amp;lt;oldurl&amp;gt;과 일치하는 원격 &amp;lt;name&amp;gt;의 첫 번째 URL (&amp;lt;oldurl&amp;gt;이 제공되지 않은 경우 첫 번째 URL)을 &amp;lt;newurl&amp;gt;로 설정합니다. &amp;lt;oldurl&amp;gt;이 URL과 일치하지 않으면 오류가 발생하고 아무것도 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f81b14c458a3f96e356b0db1d9a8184d3aa46df" translate="yes" xml:space="preserve">
          <source>Changes between the index and your last commit; what you would be committing if you run &quot;git commit&quot; without &quot;-a&quot; option.</source>
          <target state="translated">인덱스와 마지막 커밋 사이의 변경; &quot;-a&quot;옵션없이 &quot;git commit&quot;을 실행하면 커밋 할 내용</target>
        </trans-unit>
        <trans-unit id="c2b554b2b0f0318db4bfdd8caad455aa5f11a835" translate="yes" xml:space="preserve">
          <source>Changes between the tips of the topic and the master branches.</source>
          <target state="translated">주제의 팁과 마스터 브랜치 간 변경.</target>
        </trans-unit>
        <trans-unit id="bb16f58635d0a49bf7d13f03eb1b1023bc073b68" translate="yes" xml:space="preserve">
          <source>Changes in the working tree not yet staged for the next commit.</source>
          <target state="translated">작업 트리의 변경 사항은 다음 커밋을 위해 아직 준비되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="7ac9e8718cf2c5d1390484c758626a70c63f62f2" translate="yes" xml:space="preserve">
          <source>Changes in the working tree since your last commit; what you would be committing if you run &quot;git commit -a&quot;</source>
          <target state="translated">마지막 커밋 이후 작업 트리의 변경 &quot;git commit -a&quot;를 실행하면 커밋 할 내용</target>
        </trans-unit>
        <trans-unit id="959e8030a92b92d7979097ada92148067be55d31" translate="yes" xml:space="preserve">
          <source>Changes that occurred on the master branch since when the topic branch was started off it.</source>
          <target state="translated">토픽 브랜치가 시작된 이후 마스터 브랜치에서 발생한 변경 사항.</target>
        </trans-unit>
        <trans-unit id="dcc9e0a603da36a49c01908e321b093eae90c8fa" translate="yes" xml:space="preserve">
          <source>Changes the list of branches tracked by the named remote. This can be used to track a subset of the available remote branches after the initial setup for a remote.</source>
          <target state="translated">명명 된 리모컨으로 추적되는 분기 목록을 변경합니다. 이는 원격 초기 설정 후 사용 가능한 원격 분기의 하위 세트를 추적하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bccb8c649445d0e9e5ceb6a829109a7f170728f" translate="yes" xml:space="preserve">
          <source>Changes the verbosity of messages displayed by the helper. A value of 0 for &amp;lt;n&amp;gt; means that processes operate quietly, and the helper produces only error output. 1 is the default level of verbosity, and higher values of &amp;lt;n&amp;gt; correspond to the number of -v flags passed on the command line.</source>
          <target state="translated">헬퍼가 표시하는 메시지의 상세 정도를 변경합니다. &amp;lt;n&amp;gt;의 값이 0이면 프로세스가 조용히 작동하고 도우미가 오류 출력 만 생성 함을 의미합니다. 1은 기본 상세 레벨이며 &amp;lt;n&amp;gt;의 높은 값은 명령 행에 전달 된 -v 플래그의 수에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="dd3116927a9e7dd7238b571d53ce2cf77fe23ee1" translate="yes" xml:space="preserve">
          <source>Changesets from p4 are imported using Git fast-import.</source>
          <target state="translated">p4의 변경 세트는 Git 빠른 가져 오기를 사용하여 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cab94268d38355d76ce36a45e9bc285de9460c51" translate="yes" xml:space="preserve">
          <source>Changing gitweb&amp;rsquo;s behavior</source>
          <target state="translated">gitweb의 동작 변경</target>
        </trans-unit>
        <trans-unit id="1e7847382a16c8079c307e0f617f25cfce7cb965" translate="yes" xml:space="preserve">
          <source>Changing gitweb&amp;rsquo;s look</source>
          <target state="translated">gitweb의 모양 변경</target>
        </trans-unit>
        <trans-unit id="5812a54bc86041329c11b2c54c0ad4f0c8785223" translate="yes" xml:space="preserve">
          <source>Character encoding the commit messages are converted to when running &lt;code&gt;git log&lt;/code&gt; and friends.</source>
          <target state="translated">커밋 메시지를 인코딩하는 문자는 &lt;code&gt;git log&lt;/code&gt; 및 friends를 실행할 때 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="1ae63f6ea8b36d3c621f3c26e7c68c400e2fdc6f" translate="yes" xml:space="preserve">
          <source>Character encoding the commit messages are stored in; Git itself does not care per se, but this information is necessary e.g. when importing commits from emails or in the gitk graphical history browser (and possibly at other places in the future or in other porcelains). See e.g. &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo[1]&lt;/a&gt;. Defaults to &lt;code&gt;utf-8&lt;/code&gt;.</source>
          <target state="translated">커밋 메시지를 인코딩하는 문자가 저장됩니다. Git 자체는 그 자체로 중요하지 않지만,이 정보는 전자 메일이나 gitk 그래픽 히스토리 브라우저에서 (그리고 미래의 다른 곳이나 다른 도자기에서) 커밋을 가져올 때 필요합니다. 예를 들어 &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo [1]을&lt;/a&gt; 참조하십시오 . 기본값은 &lt;code&gt;utf-8&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0d76545473270b409d5ad4bb0d1fe44d81e97f58" translate="yes" xml:space="preserve">
          <source>Check for corruption:</source>
          <target state="translated">손상 여부 확인 :</target>
        </trans-unit>
        <trans-unit id="b7d8cdc518631e2251ad5f880bdb559475d2d3c6" translate="yes" xml:space="preserve">
          <source>Check if &amp;lt;path&amp;gt; is a valid repository or a gitfile that points at a valid repository, and print the location of the repository. If &amp;lt;path&amp;gt; is a gitfile then the resolved path to the real repository is printed.</source>
          <target state="translated">&amp;lt;path&amp;gt;가 유효한 저장소인지 또는 유효한 저장소를 가리키는 gitfile인지 확인하고 저장소의 위치를 ​​인쇄하십시오. &amp;lt;path&amp;gt;가 gitfile이면 실제 리포지토리에 대한 확인 된 경로가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="e60019605e61c29f438d2140b618df2fa7a2cf81" translate="yes" xml:space="preserve">
          <source>Check if the command would error out, without updating the index or the files in the working tree for real.</source>
          <target state="translated">작업 트리의 색인 또는 파일을 실제로 업데이트하지 않고 명령이 오류가 발생했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="03d22f18e900d425734c737c0518f14811d19a56" translate="yes" xml:space="preserve">
          <source>Check if the first &amp;lt;commit&amp;gt; is an ancestor of the second &amp;lt;commit&amp;gt;, and exit with status 0 if true, or with status 1 if not. Errors are signaled by a non-zero status that is not 1.</source>
          <target state="translated">첫 번째 &amp;lt;commit&amp;gt;이 두 번째 &amp;lt;commit&amp;gt;의 조상인지 확인하고 true이면 상태 0으로, 그렇지 않으면 상태 1로 종료하십시오. 오류는 1이 아닌 0이 아닌 상태로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="83e838c1d2166b2d88caf18328aef0c7567d558a" translate="yes" xml:space="preserve">
          <source>Check not just objects in GIT_OBJECT_DIRECTORY ($GIT_DIR/objects), but also the ones found in alternate object pools listed in GIT_ALTERNATE_OBJECT_DIRECTORIES or $GIT_DIR/objects/info/alternates, and in packed Git archives found in $GIT_DIR/objects/pack and corresponding pack subdirectories in alternate object pools. This is now default; you can turn it off with --no-full.</source>
          <target state="translated">GIT_OBJECT_DIRECTORY ($ GIT_DIR / objects)의 객체뿐만 아니라 GIT_ALTERNATE_OBJECT_DIRECTORIES 또는 $ GIT_DIR / objects / info / alternates에 나열된 대체 객체 풀과 $ GIT_DIR / objects / pack 및 해당 Git 아카이브에있는 대체 객체 풀에있는 객체도 확인하십시오. 서브 디렉토리를 대체 오브젝트 풀에 팩하십시오. 이것이 기본값입니다. --no-full로 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e79b0680caa2ca1906fd2adf6eaff8974f4a2257" translate="yes" xml:space="preserve">
          <source>Check only the connectivity of reachable objects, making sure that any objects referenced by a reachable tag, commit, or tree is present. This speeds up the operation by avoiding reading blobs entirely (though it does still check that referenced blobs exist). This will detect corruption in commits and trees, but not do any semantic checks (e.g., for format errors). Corruption in blob objects will not be detected at all.</source>
          <target state="translated">도달 가능한 태그, 커밋 또는 트리에서 참조하는 객체가 있는지 확인하여 도달 가능한 객체의 연결 만 확인하십시오. 이렇게하면 Blob을 완전히 읽지 않아도 작업 속도가 빨라집니다 (여전히 참조 된 Blob이 있는지 확인하더라도). 커밋과 트리의 손상을 감지하지만 의미 검사 (예 : 형식 오류)는 수행하지 않습니다. 얼룩 개체의 손상이 전혀 감지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1059c6a2d1e02e3f2100e501993e9695ffee2a93" translate="yes" xml:space="preserve">
          <source>Check that the change you made is no longer visible, since it was made on the experimental branch and you&amp;rsquo;re back on the master branch.</source>
          <target state="translated">변경 사항이 실험 브랜치에서 이루어졌으며 마스터 브랜치로 돌아 왔기 때문에 변경 사항이 더 이상 표시되지 않는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="283494db1332f5a5bdeebb22027e88d6ecd9fccd" translate="yes" xml:space="preserve">
          <source>Check the GPG signature of commits</source>
          <target state="translated">커밋의 GPG 서명 확인</target>
        </trans-unit>
        <trans-unit id="9942c8361d672deabca4bf9b4378db88e5831693" translate="yes" xml:space="preserve">
          <source>Check the GPG signature of tags</source>
          <target state="translated">태그의 GPG 서명 확인</target>
        </trans-unit>
        <trans-unit id="06577cf94f38a79b885fc18bdd8c2be1bcd96e2b" translate="yes" xml:space="preserve">
          <source>Check the validity of a signed commit object by passing the signature to &lt;code&gt;gpg --verify&lt;/code&gt; and show the output.</source>
          <target state="translated">서명을 &lt;code&gt;gpg --verify&lt;/code&gt; 에 전달하여 서명 된 커밋 객체의 유효성을 확인하고 출력을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="73422e6d03195802a17e28660f8c31a3d87204d7" translate="yes" xml:space="preserve">
          <source>Check whether two branches point at the same history</source>
          <target state="translated">두 지점이 동일한 이력을 가리키는 지 확인</target>
        </trans-unit>
        <trans-unit id="7a3ffea957d19415bf259687b6fc87b1ce4c0522" translate="yes" xml:space="preserve">
          <source>Check your xinetd(8) documentation and setup, this is from a Fedora system. Others might be different.</source>
          <target state="translated">xinetd (8) 문서와 설정을 확인하십시오. 이것은 Fedora 시스템에서 제공 한 것입니다. 다른 것들은 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6515762734c69625b8244e79b73529d8fd67b97e" translate="yes" xml:space="preserve">
          <source>Checking for patch corruption</source>
          <target state="translated">패치 손상 점검</target>
        </trans-unit>
        <trans-unit id="c722b668af2290a67a3950339daf5303bf70266c" translate="yes" xml:space="preserve">
          <source>Checking merge bases</source>
          <target state="translated">병합 기반 확인</target>
        </trans-unit>
        <trans-unit id="fa7ccb17065ab13f50e5f4aa48f888b7f36943e2" translate="yes" xml:space="preserve">
          <source>Checking out an old version of a file</source>
          <target state="translated">이전 버전의 파일 확인</target>
        </trans-unit>
        <trans-unit id="4285903ce1710560050a0803b330dcd049bfbfef" translate="yes" xml:space="preserve">
          <source>Checking the repository for corruption</source>
          <target state="translated">저장소의 손상 점검</target>
        </trans-unit>
        <trans-unit id="2ac84684aef52ff693250170ef43a76e48af3284" translate="yes" xml:space="preserve">
          <source>Checking whitespace errors</source>
          <target state="translated">공백 오류 확인</target>
        </trans-unit>
        <trans-unit id="527933c1f680ec617db3dd975f754535f385100b" translate="yes" xml:space="preserve">
          <source>Checking-out and checking-in</source>
          <target state="translated">체크 아웃 및 체크인</target>
        </trans-unit>
        <trans-unit id="49265102fbdeaea303ebc0238044241c00c923d0" translate="yes" xml:space="preserve">
          <source>Checklist for shrinking a repository</source>
          <target state="translated">리포지토리 축소를위한 검사 목록</target>
        </trans-unit>
        <trans-unit id="ce166f9433a0a0acaace5836679192e776275599" translate="yes" xml:space="preserve">
          <source>Checks if a given &lt;code&gt;refname&lt;/code&gt; is acceptable, and exits with a non-zero status if it is not.</source>
          <target state="translated">주어진 &lt;code&gt;refname&lt;/code&gt; 이 허용 가능한지 점검하고, 그렇지 않으면 0이 아닌 상태로 종료합니다.</target>
        </trans-unit>
        <trans-unit id="3e78b611c92e074aefd3477b078d67a70bbe5ddb" translate="yes" xml:space="preserve">
          <source>Checksums and object ids</source>
          <target state="translated">체크섬 및 개체 ID</target>
        </trans-unit>
        <trans-unit id="d8021a065c8c671df3a58cb63e7469b8167a446a" translate="yes" xml:space="preserve">
          <source>Child Process Messages</source>
          <target state="translated">자식 프로세스 메시지</target>
        </trans-unit>
        <trans-unit id="5091e72502f618e2b372fcb37e80054927942ac3" translate="yes" xml:space="preserve">
          <source>Child Processes</source>
          <target state="translated">자식 프로세스</target>
        </trans-unit>
        <trans-unit id="c8895429bfc3ae045740a98bd7892c21d37107b3" translate="yes" xml:space="preserve">
          <source>Choose a diff algorithm. The variants are as follows:</source>
          <target state="translated">diff 알고리즘을 선택하십시오. 변형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="59db2d4b9fea86d4c731a426cb932a15c94c9596" translate="yes" xml:space="preserve">
          <source>Choosing textconv versus external diff</source>
          <target state="translated">textconv와 외부 diff 선택</target>
        </trans-unit>
        <trans-unit id="613b7dff145eefd66d417456a88da290b004ada8" translate="yes" xml:space="preserve">
          <source>Chunk header format is modified to prevent people from accidentally feeding it to &lt;code&gt;patch -p1&lt;/code&gt;. Combined diff format was created for review of merge commit changes, and was not meant to be applied. The change is similar to the change in the extended &lt;code&gt;index&lt;/code&gt; header:</source>
          <target state="translated">청크 헤더 형식은 사람들이 실수로이를 &lt;code&gt;patch -p1&lt;/code&gt; 공급하지 못하도록 수정되었습니다 . 병합 커밋 변경 사항을 검토하기 위해 결합 된 diff 형식이 만들어 졌으므로 적용되지 않았습니다. 변경 사항은 확장 &lt;code&gt;index&lt;/code&gt; 헤더 의 변경 사항과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="42dcbc11ebcca8013128e188e07a667fd189817d" translate="yes" xml:space="preserve">
          <source>Cleans the working tree by recursively removing files that are not under version control, starting from the current directory.</source>
          <target state="translated">현재 디렉토리에서 시작하여 버전 제어를받지 않는 파일을 재귀 적으로 제거하여 작업 트리를 정리합니다.</target>
        </trans-unit>
        <trans-unit id="f2d831c9f71cd3ff7b3b6c7c49408fcedc1e2e96" translate="yes" xml:space="preserve">
          <source>Cleanup unnecessary files and optimize the local repository</source>
          <target state="translated">불필요한 파일 정리 및 로컬 저장소 최적화</target>
        </trans-unit>
        <trans-unit id="94f8adfaa49f4f08c745b4d0d2c62d9ba66072a5" translate="yes" xml:space="preserve">
          <source>Clearly this work-flow uses the virtuous circle between test suites and &quot;git bisect&quot;. In fact it makes it the standard procedure to deal with regression.</source>
          <target state="translated">분명히이 워크 플로우는 테스트 스위트와 &quot;git bisect&quot;사이의 선순환을 사용합니다. 사실 그것은 회귀를 다루는 표준 절차입니다.</target>
        </trans-unit>
        <trans-unit id="119db12fc152f2f55488f08da986c3c46bdf64a9" translate="yes" xml:space="preserve">
          <source>Clears any list of &quot;To:&quot;, &quot;Cc:&quot;, &quot;Bcc:&quot; addresses previously set via config.</source>
          <target state="translated">이전에 config를 통해 설정 한 &quot;To :&quot;, &quot;Cc :&quot;, &quot;Bcc :&quot;주소 목록을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="cf4a0e26c9f93f0530be9fa71dab1af1cbaa231f" translate="yes" xml:space="preserve">
          <source>Clears the previously read value of &lt;code&gt;sendemail.identity&lt;/code&gt; set via config, if any.</source>
          <target state="translated">config를 통해 설정된 &lt;code&gt;sendemail.identity&lt;/code&gt; 의 이전에 읽은 값을 지 웁니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="90944cef36d3464ed0283d5129626cf4ab8fc85b" translate="yes" xml:space="preserve">
          <source>Click on New Mail.</source>
          <target state="translated">새 메일을 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="89585875df151078ae7b77d81e2bd1b067e7d065" translate="yes" xml:space="preserve">
          <source>Client spec</source>
          <target state="translated">클라이언트 사양</target>
        </trans-unit>
        <trans-unit id="55e7359e50be70477f290b070978067b2a01b4d1" translate="yes" xml:space="preserve">
          <source>Client specified as an option to all p4 commands, with &lt;code&gt;-c &amp;lt;client&amp;gt;&lt;/code&gt;, including the client spec.</source>
          <target state="translated">클라이언트 는 클라이언트 사양을 포함하여 &lt;code&gt;-c &amp;lt;client&amp;gt;&lt;/code&gt; 와 함께 모든 p4 명령에 대한 옵션으로 지정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="80c2bc0ea4027c7a64da85db4dd1237d395876ca" translate="yes" xml:space="preserve">
          <source>Clients known to work</source>
          <target state="translated">작동하는 것으로 알려진 고객</target>
        </trans-unit>
        <trans-unit id="74d55b5e93bc1fa20e1ae7e006b74220ee6a2f8c" translate="yes" xml:space="preserve">
          <source>Clients may &lt;code&gt;not&lt;/code&gt; use other sha1 expressions, even if the end result is reachable. E.g., neither a relative commit like &lt;code&gt;master^&lt;/code&gt; nor a literal sha1 like &lt;code&gt;abcd1234&lt;/code&gt; is allowed, even if the result is reachable from the refs.</source>
          <target state="translated">최종 결과에 도달하더라도 클라이언트는 다른 sha1 표현식을 사용할 수 &lt;code&gt;not&lt;/code&gt; . 예를 들어 결과가 refs에 도달하더라도 &lt;code&gt;master^&lt;/code&gt; 와 같은 상대 커밋 이나 &lt;code&gt;abcd1234&lt;/code&gt; 와 같은 리터럴 sha1 은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c33076e8c658be1dfe63e1df1ac676b47602d66" translate="yes" xml:space="preserve">
          <source>Clients may request a commit or tree that is pointed to directly by a ref. E.g., &lt;code&gt;git archive --remote=origin v1.0&lt;/code&gt;.</source>
          <target state="translated">클라이언트는 심판이 직접 지적한 커밋 또는 트리를 요청할 수 있습니다. 예를 들어, &lt;code&gt;git archive --remote=origin v1.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cbed12af7936ed3ad4075cea19b034f51ea55c2c" translate="yes" xml:space="preserve">
          <source>Clients may request a sub-tree within a commit or tree using the &lt;code&gt;ref:path&lt;/code&gt; syntax. E.g., &lt;code&gt;git archive --remote=origin v1.0:Documentation&lt;/code&gt;.</source>
          <target state="translated">클라이언트는 &lt;code&gt;ref:path&lt;/code&gt; 구문을 사용하여 커밋 또는 트리 내의 하위 트리를 요청할 수 있습니다 . 예를 들어, &lt;code&gt;git archive --remote=origin v1.0:Documentation&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9839e8d4aa3c14e4b54e191e51eb2179e4fdaa19" translate="yes" xml:space="preserve">
          <source>Clients should now be able to check out the project. Use the CVS &lt;code&gt;module&lt;/code&gt; name to indicate what Git &lt;code&gt;head&lt;/code&gt; you want to check out. This also sets the name of your newly checked-out directory, unless you tell it otherwise with &lt;code&gt;-d &amp;lt;dir_name&amp;gt;&lt;/code&gt;. For example, this checks out &lt;code&gt;master&lt;/code&gt; branch to the &lt;code&gt;project-master&lt;/code&gt; directory:</source>
          <target state="translated">클라이언트는 이제 프로젝트를 확인할 수 있습니다. CVS &lt;code&gt;module&lt;/code&gt; 이름을 사용하여 체크 아웃하려는 Git &lt;code&gt;head&lt;/code&gt; 를 표시 하십시오. &lt;code&gt;-d &amp;lt;dir_name&amp;gt;&lt;/code&gt; 으로 달리 지정하지 않는 한 새로 체크 아웃 한 디렉토리의 이름도 설정합니다 . 예를 들어, &lt;code&gt;master&lt;/code&gt; 브랜치를 &lt;code&gt;project-master&lt;/code&gt; 디렉토리 로 체크 아웃합니다 .</target>
        </trans-unit>
        <trans-unit id="d8cdb573350de78596e4852bc9cacfc94e8d17ed" translate="yes" xml:space="preserve">
          <source>Clone</source>
          <target state="translated">Clone</target>
        </trans-unit>
        <trans-unit id="d69c0c434d503834765604d22b28037bee413bfc" translate="yes" xml:space="preserve">
          <source>Clone a repository into a new directory</source>
          <target state="translated">저장소를 새 디렉토리에 복제</target>
        </trans-unit>
        <trans-unit id="8b7342cb68e63a734e787beefc74dd4c8bf74d08" translate="yes" xml:space="preserve">
          <source>Clone a repository:</source>
          <target state="translated">저장소를 복제하십시오.</target>
        </trans-unit>
        <trans-unit id="e3bdbcd4fc3a4b615a5be68aca4686a1e8d61dd3" translate="yes" xml:space="preserve">
          <source>Clone and sync variables</source>
          <target state="translated">변수 복제 및 동기화</target>
        </trans-unit>
        <trans-unit id="fc5a57d2c10be47f020b40eb294f6e546edcb1fb" translate="yes" xml:space="preserve">
          <source>Clone from upstream while borrowing from an existing local directory:</source>
          <target state="translated">기존 로컬 디렉토리에서 빌리는 동안 업스트림에서 복제하십시오.</target>
        </trans-unit>
        <trans-unit id="31427bc4154831dc13e03739efd0e5c8ceee16ff" translate="yes" xml:space="preserve">
          <source>Clone from upstream:</source>
          <target state="translated">업스트림에서 복제 :</target>
        </trans-unit>
        <trans-unit id="40d0639c1781d7a9c100ef0a6d2c0dcfcc6b282c" translate="yes" xml:space="preserve">
          <source>Clone it with &lt;code&gt;git clone file:///path/to/repo&lt;/code&gt;. The clone will not have the removed objects. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;. (Note that cloning with a plain path just hardlinks everything!)</source>
          <target state="translated">와 복제를 &lt;code&gt;git clone file:///path/to/repo&lt;/code&gt; . 클론에는 제거 된 객체가 없습니다. &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]을&lt;/a&gt; 참조하십시오 . (일반 경로를 사용한 복제는 모든 것을 단단하게 연결합니다!)</target>
        </trans-unit>
        <trans-unit id="25701c0360e9d04455f2222c02f2b66094990098" translate="yes" xml:space="preserve">
          <source>Clone only the history leading to the tip of a single branch, either specified by the &lt;code&gt;--branch&lt;/code&gt; option or the primary branch remote&amp;rsquo;s &lt;code&gt;HEAD&lt;/code&gt; points at. Further fetches into the resulting repository will only update the remote-tracking branch for the branch this option was used for the initial cloning. If the HEAD at the remote did not point at any branch when &lt;code&gt;--single-branch&lt;/code&gt; clone was made, no remote-tracking branch is created.</source>
          <target state="translated">&lt;code&gt;--branch&lt;/code&gt; 옵션 또는 1 차 분기 리모트의 &lt;code&gt;HEAD&lt;/code&gt; 가 지정한 단일 분기의 끝으로 이어지는 히스토리 만 복제하십시오 . 결과 리포지토리에 추가로 가져 오면이 옵션이 초기 복제에 사용 된 분기에 대한 원격 추적 분기 만 업데이트됩니다. &lt;code&gt;--single-branch&lt;/code&gt; clone을 만들 때 원격의 HEAD가 분기를 가리 키지 않으면 원격 추적 분기가 만들어지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a471e90dac3e294ddb7787043d7eb11c0e7a242" translate="yes" xml:space="preserve">
          <source>Clone options</source>
          <target state="translated">복제 옵션</target>
        </trans-unit>
        <trans-unit id="0befa381e0a34bfc395f53162eefbad3dae21f70" translate="yes" xml:space="preserve">
          <source>Clone the upstream and work on it. Feed changes to upstream.</source>
          <target state="translated">업스트림을 복제하고 작업하십시오. 업스트림으로 변경 사항을 피드하십시오.</target>
        </trans-unit>
        <trans-unit id="4b6b25b2b84758722a0670042a124566ce1d193f" translate="yes" xml:space="preserve">
          <source>Clones a repository into a newly created directory, creates remote-tracking branches for each branch in the cloned repository (visible using &lt;code&gt;git branch --remotes&lt;/code&gt;), and creates and checks out an initial branch that is forked from the cloned repository&amp;rsquo;s currently active branch.</source>
          <target state="translated">저장소를 새로 작성된 디렉토리로 복제하고, 복제 된 저장소의 각 분기에 대한 원격 추적 분기를 작성하고 ( &lt;code&gt;git branch --remotes&lt;/code&gt; 를 사용하여 표시 ) 복제 된 저장소의 현재 활성 분기에서 분기 된 초기 분기를 작성하고 체크 아웃합니다.</target>
        </trans-unit>
        <trans-unit id="df1a2527d982b2181fc5936a0c039535ce1accdb" translate="yes" xml:space="preserve">
          <source>Cloning or syncing does not require a p4 client; file contents are collected using &lt;code&gt;p4 print&lt;/code&gt;.</source>
          <target state="translated">복제 또는 동기화에는 p4 클라이언트가 필요하지 않습니다. 파일 내용은 &lt;code&gt;p4 print&lt;/code&gt; 를 사용하여 수집됩니다 .</target>
        </trans-unit>
        <trans-unit id="53e412082749509777418e5cdc87503adeb4bf14" translate="yes" xml:space="preserve">
          <source>Collect and show committer identities instead of authors.</source>
          <target state="translated">저자 대신 커미터 신원을 수집하고 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="752dedb02a973d0d43ace0dca55082bee051171e" translate="yes" xml:space="preserve">
          <source>Collect information for user to file a bug report</source>
          <target state="translated">사용자가 버그 신고를 할 수 있도록 정보 수집</target>
        </trans-unit>
        <trans-unit id="fccaafaced7e706bc2bd06241362e04977c0cd36" translate="yes" xml:space="preserve">
          <source>Colon-delimited list of refs or globs indicating which refs, in addition to the default from &lt;code&gt;core.notesRef&lt;/code&gt; or &lt;code&gt;GIT_NOTES_REF&lt;/code&gt;, to read notes from when showing commit messages. This overrides the &lt;code&gt;notes.displayRef&lt;/code&gt; setting.</source>
          <target state="translated">&lt;code&gt;core.notesRef&lt;/code&gt; 또는 &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; 의 기본값 외에도 커밋 메시지를 표시 할 때 노트를 읽을 참조를 나타내는 콜론으로 구분 된 참조 또는 글롭 목록 . 이것은 &lt;code&gt;notes.displayRef&lt;/code&gt; 설정을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="b13a61ccbe64b645a15179edff14e97b6ecd8c00" translate="yes" xml:space="preserve">
          <source>Color branches to highlight current, local, and remote-tracking branches. The value must be always (the default), never, or auto.</source>
          <target state="translated">현재, 로컬 및 원격 추적 분기를 강조 표시하는 색상 분기. 값은 항상 (기본값), 절대 또는 자동이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b15070a1530d4c810f05017f7f35501b365479b6" translate="yes" xml:space="preserve">
          <source>Color the status sign (one of these: &lt;code&gt;*&lt;/code&gt;&lt;code&gt;!&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;) of each commit corresponding to the branch it&amp;rsquo;s in. The value must be always (the default), never, or auto.</source>
          <target state="translated">해당 분기에 해당하는 각 커밋 의 상태 표시 (이 중 하나 : &lt;code&gt;*&lt;/code&gt; &lt;code&gt;!&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; )에 색상을 지정하십시오 . 값은 항상 (기본값), 절대 또는 자동이어야합니다.</target>
        </trans-unit>
        <trans-unit id="51d8265f4f18e755692a71f862affd712731021e" translate="yes" xml:space="preserve">
          <source>Colors may also be given as numbers between 0 and 255; these use ANSI 256-color mode (but note that not all terminals may support this). If your terminal supports it, you may also specify 24-bit RGB values as hex, like &lt;code&gt;#ff0ab3&lt;/code&gt;.</source>
          <target state="translated">색상은 0에서 255 사이의 숫자로 제공 될 수도 있습니다. 이것들은 ANSI 256- 컬러 모드를 사용합니다 (그러나 모든 터미널이이를 지원하지는 않습니다). 터미널에서 지원하는 경우 &lt;code&gt;#ff0ab3&lt;/code&gt; 과 같이 24 비트 RGB 값을 16 진수로 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39ae0d23566f06a8646ef3abdd586851a9e465cd" translate="yes" xml:space="preserve">
          <source>Combined diff format</source>
          <target state="translated">결합 된 diff 형식</target>
        </trans-unit>
        <trans-unit id="5bb60f78b33e9a4f091db8f97f338043390512bd" translate="yes" xml:space="preserve">
          <source>Combining test suites, git bisect and other systems together</source>
          <target state="translated">테스트 스위트, git bisect 및 기타 시스템을 결합</target>
        </trans-unit>
        <trans-unit id="4a4a4bb517ec5013313be130afe65f9c77f0eaea" translate="yes" xml:space="preserve">
          <source>Coming from a system such as Perforce or Subversion this should be quite simple, as the fast-import mark can also be the Perforce changeset number or the Subversion revision number.</source>
          <target state="translated">빠른 가져 오기 마크는 Perforce 변경 세트 번호 또는 Subversion 개정 번호 일 수 있기 때문에 Perforce 또는 Subversion과 같은 시스템에서 제공되는 것은 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="b894fab4f168cef475b1c68a083475614077b1e5" translate="yes" xml:space="preserve">
          <source>Coming up with the correct shell snippet to do the filtering you want is sometimes difficult unless you&amp;rsquo;re just doing a trivial modification such as deleting a couple files. Unfortunately, people often learn if the snippet is right or wrong by trying it out, but the rightness or wrongness can vary depending on special circumstances (spaces in filenames, non-ascii filenames, funny author names or emails, invalid timezones, presence of grafts or replace objects, etc.), meaning they may have to wait a long time, hit an error, then restart. The performance of git-filter-branch is so bad that this cycle is painful, reducing the time available to carefully re-check (to say nothing about what it does to the patience of the person doing the rewrite even if they do technically have more time available). This problem is extra compounded because errors from broken filters may not be shown for a long time and/or get lost in a sea of output. Even worse, broken filters often just result in silent incorrect rewrites.</source>
          <target state="translated">몇 가지 파일을 삭제하는 등 사소한 수정을하지 않으면 원하는 필터링을 수행하기 위해 올바른 셸 스 니펫을 만드는 것이 어려운 경우가 있습니다. 불행하게도, 사람들은 종종 스 니펫을 사용해 보아도 옳고 그름인지를 알지만, 옳고 그름은 특수한 상황 (파일 이름, ASCII가 아닌 파일 이름, 재미있는 저자 이름 또는 이메일, 유효하지 않은 시간대, 이식편의 존재 여부)에 따라 다를 수 있습니다 또는 객체 등을 교체하십시오.) 즉, 오래 기다려야하고 오류가 발생한 다음 다시 시작해야 할 수도 있습니다. git-filter-branch의 성능이 너무 나빠서이주기가 고통스럽기 때문에 신중하게 다시 확인하는 데 걸리는 시간이 줄어 듭니다 (기술적으로 더 많은 것을 가지고 있더라도 다시 작성하는 사람의 인내심에 대해 아무런 조치를 취하지 않음) 가능한 시간).깨진 필터로 인한 오류가 오랫동안 표시되지 않거나 출력 바다에서 손실 될 수 있기 때문에이 문제는 더욱 복잡해집니다. 더 나쁜 것은, 깨진 필터는 종종 자동으로 잘못된 재기록을 초래하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8fb52c1564722a1fe5f6cf4e3d44bce48182e716" translate="yes" xml:space="preserve">
          <source>Command Detail Messages</source>
          <target state="translated">명령 세부 사항 메시지</target>
        </trans-unit>
        <trans-unit id="f7e08456d089a047ccd465ae00e5bf2544bfdac7" translate="yes" xml:space="preserve">
          <source>Command Details</source>
          <target state="translated">명령 세부 사항</target>
        </trans-unit>
        <trans-unit id="84cf71d717103c00cc33f4f16f173970104ae46e" translate="yes" xml:space="preserve">
          <source>Command aliases for the &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; command wrapper - e.g. after defining &lt;code&gt;alias.last = cat-file commit HEAD&lt;/code&gt;, the invocation &lt;code&gt;git last&lt;/code&gt; is equivalent to &lt;code&gt;git cat-file commit HEAD&lt;/code&gt;. To avoid confusion and troubles with script usage, aliases that hide existing Git commands are ignored. Arguments are split by spaces, the usual shell quoting and escaping is supported. A quote pair or a backslash can be used to quote them.</source>
          <target state="translated">&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; 명령 래퍼 의 명령 별명 -예를 들어 &lt;code&gt;alias.last = cat-file commit HEAD&lt;/code&gt; 정의한 후 호출 &lt;code&gt;git last&lt;/code&gt; 는 &lt;code&gt;git cat-file commit HEAD&lt;/code&gt; 와 같습니다 . 혼동과 스크립트 사용 문제를 피하기 위해 기존 Git 명령을 숨기는 별칭은 무시됩니다. 인수는 공백으로 나뉘며 일반적인 쉘 인용 및 이스케이프가 지원됩니다. 따옴표 쌍이나 백 슬래시를 사용하여 따옴표를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb334d175dc8351e4e643438be75bf5083df9523" translate="yes" xml:space="preserve">
          <source>Command and arguments are separated by an unescaped space.</source>
          <target state="translated">명령과 인수는 이스케이프되지 않은 공백으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="bd186454b9919f30925b251fcf7e4e52ca77972c" translate="yes" xml:space="preserve">
          <source>Command request</source>
          <target state="translated">명령 요청</target>
        </trans-unit>
        <trans-unit id="fa701362a88f56992e33094194fa924ccdfa36dc" translate="yes" xml:space="preserve">
          <source>Command to be run each time gitk has to determine the revision range to show. The command is expected to print on its standard output a list of additional revisions to be shown, one per line. Use this instead of explicitly specifying a &lt;code&gt;&amp;lt;revision range&amp;gt;&lt;/code&gt; if the set of commits to show may vary between refreshes.</source>
          <target state="translated">gitk가 보여줄 개정 범위를 결정할 때마다 실행될 명령. 이 명령은 표준 출력에 한 줄에 하나씩 표시 될 추가 개정 목록을 인쇄해야합니다. 표시 할 커밋 세트가 새로 고침마다 다를 수있는 경우 &lt;code&gt;&amp;lt;revision range&amp;gt;&lt;/code&gt; 를 명시 적으로 지정하는 대신 이것을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d073f0ac32697a8093342645a8234491e985e6ff" translate="yes" xml:space="preserve">
          <source>Command used to setup a tunnel to the IMAP server through which commands will be piped instead of using a direct network connection to the server. Required when imap.host is not set.</source>
          <target state="translated">서버에 직접 네트워크 연결을 사용하는 대신 명령이 파이프되는 IMAP 서버에 터널을 설정하는 데 사용되는 명령입니다. imap.host가 설정되지 않은 경우 필수입니다.</target>
        </trans-unit>
        <trans-unit id="5fbae08a3e549b8259aa734268f8fc50962c7173" translate="yes" xml:space="preserve">
          <source>Command-line interface conventions</source>
          <target state="translated">명령 줄 인터페이스 규칙</target>
        </trans-unit>
        <trans-unit id="45e5f3f72e961cb70134ba35f7a27a9620e515f7" translate="yes" xml:space="preserve">
          <source>Commands</source>
          <target state="translated">Commands</target>
        </trans-unit>
        <trans-unit id="5415f180d40029f0ddfc48b35f157e8ad10f48bc" translate="yes" xml:space="preserve">
          <source>Commands are given by the caller on the helper&amp;rsquo;s standard input, one per line.</source>
          <target state="translated">명령은 도우미의 표준 입력에서 한 줄에 하나씩 호출자가 제공합니다.</target>
        </trans-unit>
        <trans-unit id="03880aa7f8436e082afca33e516cbcd9355d3554" translate="yes" xml:space="preserve">
          <source>Commands such as &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;tag&lt;/code&gt; that let you edit messages by launching an editor use the value of this variable when it is set, and the environment variable &lt;code&gt;GIT_EDITOR&lt;/code&gt; is not set. See &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt;.</source>
          <target state="translated">편집기를 실행하여 메시지를 편집 할 수있게하는 &lt;code&gt;commit&lt;/code&gt; 및 &lt;code&gt;tag&lt;/code&gt; 와 같은 명령 은이 변수가 설정되어 있고 환경 변수 &lt;code&gt;GIT_EDITOR&lt;/code&gt; 가 설정되어 있지 않을 때이 변수의 값을 사용합니다 . &lt;a href=&quot;git-var&quot;&gt;git-var [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0abcd0747bb8576b597002ab49f39285f1f4ef29" translate="yes" xml:space="preserve">
          <source>Commands such as &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;tag&lt;/code&gt; that let you edit messages consider a line that begins with this character commented, and removes them after the editor returns (default &lt;code&gt;#&lt;/code&gt;).</source>
          <target state="translated">메시지를 편집 할 수있는 &lt;code&gt;commit&lt;/code&gt; 및 &lt;code&gt;tag&lt;/code&gt; 와 같은 명령 은이 문자가 주석으로 시작되는 행을 고려하여 편집기가 리턴 된 후에이를 제거합니다 (기본값 &lt;code&gt;#&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6030cf68b2071379f06ab06312828ccb10c46868" translate="yes" xml:space="preserve">
          <source>Commands that output paths (e.g. &lt;code&gt;ls-files&lt;/code&gt;, &lt;code&gt;diff&lt;/code&gt;), will quote &quot;unusual&quot; characters in the pathname by enclosing the pathname in double-quotes and escaping those characters with backslashes in the same way C escapes control characters (e.g. &lt;code&gt;\t&lt;/code&gt; for TAB, &lt;code&gt;\n&lt;/code&gt; for LF, &lt;code&gt;\\&lt;/code&gt; for backslash) or bytes with values larger than 0x80 (e.g. octal &lt;code&gt;\302\265&lt;/code&gt; for &quot;micro&quot; in UTF-8). If this variable is set to false, bytes higher than 0x80 are not considered &quot;unusual&quot; any more. Double-quotes, backslash and control characters are always escaped regardless of the setting of this variable. A simple space character is not considered &quot;unusual&quot;. Many commands can output pathnames completely verbatim using the &lt;code&gt;-z&lt;/code&gt; option. The default value is true.</source>
          <target state="translated">경로를 출력하는 명령 (예 : &lt;code&gt;ls-files&lt;/code&gt; , &lt;code&gt;diff&lt;/code&gt; )은 경로 이름을 큰 따옴표로 묶고 C가 제어 문자를 이스케이프하는 것과 같은 방식으로 백 슬래시로 해당 문자를 이스케이프하여 경로 이름에 &quot;비정상적인&quot;문자를 인용합니다 (예 : TAB의 경우 &lt;code&gt;\t&lt;/code&gt; , LF의 경우 &lt;code&gt;\n&lt;/code&gt; , 백 슬래시의 경우 &lt;code&gt;\\&lt;/code&gt; ) 또는 0x80보다 큰 값을 가진 바이트 (예 : UTF-8의 &quot;마이크로&quot;의 경우 8 진 &lt;code&gt;\302\265&lt;/code&gt; ). 이 변수를 false로 설정하면 0x80보다 높은 바이트는 더 이상 &quot;비정상적인&quot;것으로 간주되지 않습니다. 큰 따옴표, 백 슬래시 및 제어 문자는이 변수의 설정에 관계없이 항상 이스케이프됩니다. 단순한 공백 문자는 &quot;비정상적인&quot;것으로 간주되지 않습니다.많은 명령은 다음을 사용하여 경로 이름을 완전하게 출력 할 수 있습니다. &lt;code&gt;-z&lt;/code&gt; 옵션. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="240a8b9ba4498383936942814599bad7b6fd9115" translate="yes" xml:space="preserve">
          <source>Commands that support the enhanced option parser accepts unique prefix of a long option as if it is fully spelled out, but use this with a caution. For example, &lt;code&gt;git commit --amen&lt;/code&gt; behaves as if you typed &lt;code&gt;git commit --amend&lt;/code&gt;, but that is true only until a later version of Git introduces another option that shares the same prefix, e.g. &lt;code&gt;git commit --amenity&lt;/code&gt; option.</source>
          <target state="translated">확장 옵션 구문 분석기를 지원하는 명령은 완전히 철자 된 것처럼 긴 옵션의 고유 접 두부를 허용하지만주의해서 사용하십시오. 예를 들어, &lt;code&gt;git commit --amen&lt;/code&gt; 은 &lt;code&gt;git commit --amend&lt;/code&gt; 를 입력 한 것처럼 동작 하지만, 이후 버전의 Git이 동일한 접두사를 공유하는 다른 옵션 (예 : &lt;code&gt;git commit --amenity&lt;/code&gt; 옵션)을 도입 할 때까지만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="40539e4d461e31ee218fa661fb2b14e246e5b1ba" translate="yes" xml:space="preserve">
          <source>Commands that support the enhanced option parser allow you to aggregate short options. This means that you can for example use &lt;code&gt;git rm -rf&lt;/code&gt; or &lt;code&gt;git clean -fdx&lt;/code&gt;.</source>
          <target state="translated">고급 옵션 파서를 지원하는 명령을 사용하면 짧은 옵션을 집계 할 수 있습니다. 이것은 예를 들어 &lt;code&gt;git rm -rf&lt;/code&gt; 또는 &lt;code&gt;git clean -fdx&lt;/code&gt; 를 사용할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="d3f5763bea669fa755ce44d52b210df9afaf62df" translate="yes" xml:space="preserve">
          <source>Commands which have the enhanced option parser activated all understand a couple of magic command-line options:</source>
          <target state="translated">향상된 옵션 파서가 활성화 된 명령은 모두 몇 가지 매직 명령 줄 옵션을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="1164e5e23a09019a23028b34e0716555534c7c84" translate="yes" xml:space="preserve">
          <source>Comment lines appearing within the &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; part of &lt;code&gt;data&lt;/code&gt; commands are always taken to be part of the body of the data and are therefore never ignored by fast-import. This makes it safe to import any file/message content whose lines might start with &lt;code&gt;#&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 명령 의 &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; 부분에 나타나는 주석 행 은 항상 데이터 본문의 일부로 간주되므로 빠른 가져 오기에서 무시되지 않습니다. 이렇게하면 행이 &lt;code&gt;#&lt;/code&gt; 으로 시작할 수있는 파일 / 메시지 내용을 안전하게 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a91a1b2d9c14de30d84e97a50ebe0d84ec870d0d" translate="yes" xml:space="preserve">
          <source>Commit Exclusions</source>
          <target state="translated">제외 제외</target>
        </trans-unit>
        <trans-unit id="d05672f731c8973c38856897c1597b273795a8b8" translate="yes" xml:space="preserve">
          <source>Commit Formatting</source>
          <target state="translated">커밋 서식</target>
        </trans-unit>
        <trans-unit id="dd5ce850ad942688eb2a5bc300a25747c87232f5" translate="yes" xml:space="preserve">
          <source>Commit Limiting</source>
          <target state="translated">커밋 제한</target>
        </trans-unit>
        <trans-unit id="b518afb06183e6dd261846ce6b7c3883dfb90753" translate="yes" xml:space="preserve">
          <source>Commit Object</source>
          <target state="translated">커밋 개체</target>
        </trans-unit>
        <trans-unit id="d0a18b5ae3a3d7dd2d18ac07312a3fb851663f8e" translate="yes" xml:space="preserve">
          <source>Commit Ordering</source>
          <target state="translated">주문 커밋</target>
        </trans-unit>
        <trans-unit id="56db2f16b9009b18c00586ca09141e3f326e2939" translate="yes" xml:space="preserve">
          <source>Commit Rewording</source>
          <target state="translated">단어 변경 커밋</target>
        </trans-unit>
        <trans-unit id="71e9094af761c78deb267d59e41cd349f42db60f" translate="yes" xml:space="preserve">
          <source>Commit all reference updates queued for the transaction, ending the transaction.</source>
          <target state="translated">트랜잭션을 위해 대기중인 모든 참조 업데이트를 커밋하고 트랜잭션을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="cf42eef97d741d8fac1d744839ed812ca253ade6" translate="yes" xml:space="preserve">
          <source>Commit automatically if the patch applied cleanly. It will not commit if any hunks fail to apply or there were other problems.</source>
          <target state="translated">패치가 깨끗하게 적용되면 자동으로 커밋하십시오. 덩어리가 적용되지 않거나 다른 문제가 있으면 커밋되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6fc46793322e7555ef7eec902c3baf2d380d288" translate="yes" xml:space="preserve">
          <source>Commit each diff from the current branch directly to the SVN repository, and then rebase or reset (depending on whether or not there is a diff between SVN and head). This will create a revision in SVN for each commit in Git.</source>
          <target state="translated">현재 분기에서 각 diff를 SVN 저장소로 직접 커밋 한 다음 SVN과 헤드간에 차이가 있는지 여부에 따라 리베이스 또는 재설정합니다. 이것은 Git의 각 커밋에 대해 SVN의 개정을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="32d864cf4da09ae0ccb717144326eeb4d87e8ec8" translate="yes" xml:space="preserve">
          <source>Commit information</source>
          <target state="translated">커밋 정보</target>
        </trans-unit>
        <trans-unit id="cdf751d893db0a24e80b369d44da2bfa908750cb" translate="yes" xml:space="preserve">
          <source>Commit log messages are typically encoded in UTF-8, but other extended ASCII encodings are also supported. This includes ISO-8859-x, CP125x and many others, but &lt;code&gt;not&lt;/code&gt; UTF-16/32, EBCDIC and CJK multi-byte encodings (GBK, Shift-JIS, Big5, EUC-x, CP9xx etc.).</source>
          <target state="translated">커밋 로그 메시지는 일반적으로 UTF-8로 인코딩되지만 다른 확장 ASCII 인코딩도 지원됩니다. 이는 ISO-8859-X, CP125x 외 다수 있지만 포함 &lt;code&gt;not&lt;/code&gt; UTF-32분의 16, EBCDIC 및 CJK 멀티 바이트 인코딩 (GBK, 시프트 JIS-,의 Big5, EUC-X CP9xx 등).</target>
        </trans-unit>
        <trans-unit id="a8ef9cdaba51b8bab239b7175f652bb22d7bc77a" translate="yes" xml:space="preserve">
          <source>Commit messages (even if they are all UTF-8) by default become corrupted due to not being updated &amp;mdash; any references to other commit hashes in commit messages will now refer to no-longer-extant commits.</source>
          <target state="translated">커밋 메시지 (모든 UTF-8 인 경우에도)는 기본적으로 업데이트되지 않아 손상됩니다. 커밋 메시지의 다른 커밋 해시에 대한 참조는 이제 더 이상 확장되지 않은 커밋을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a0d43ade6a679ebd3be023e33c0ed655845a2385" translate="yes" xml:space="preserve">
          <source>Commit notes are blobs containing extra information about an object (usually information to supplement a commit&amp;rsquo;s message). These blobs are taken from notes refs. A notes ref is usually a branch which contains &quot;files&quot; whose paths are the object names for the objects they describe, with some directory separators included for performance reasons &lt;sup&gt;[&lt;a href=&quot;#_footnote_1&quot; id=&quot;_footnoteref_1&quot;&gt;1&lt;/a&gt;]&lt;/sup&gt;.</source>
          <target state="translated">커밋 노트는 객체에 대한 추가 정보 (보통 커밋 메시지를 보완하기위한 정보)를 포함하는 얼룩입니다. 이 얼룩은 노트 참조에서 가져옵니다. 노트 참조는 일반적으로 경로가 설명하는 오브젝트의 오브젝트 이름 인 &quot;파일&quot;을 포함하는 브랜치이며, 성능상의 이유로 일부 디렉토리 구분 기호가 포함되어 있습니다 &lt;sup&gt;[ &lt;a href=&quot;#_footnote_1&quot; id=&quot;_footnoteref_1&quot;&gt;1&lt;/a&gt; ]&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="217104e18a0c907f96ea2b24a19144c9ed0cdcc1" translate="yes" xml:space="preserve">
          <source>Commit notes are blobs containing extra information about an object (usually information to supplement a commit&amp;rsquo;s message). These blobs are taken from notes refs. A notes ref is usually a branch which contains &quot;files&quot; whose paths are the object names for the objects they describe, with some directory separators included for performance reasons &lt;sup&gt;[&lt;a href=&quot;#_footnotedef_1&quot; id=&quot;_footnoteref_1&quot;&gt;1&lt;/a&gt;]&lt;/sup&gt;.</source>
          <target state="translated">커밋 노트는 개체에 대한 추가 정보 (일반적으로 커밋 메시지를 보완하기위한 정보)를 포함하는 Blob입니다. 이러한 blob은 메모 참조에서 가져옵니다. notes ref는 일반적으로 경로가 설명하는 객체의 객체 이름 인 &quot;파일&quot;을 포함하는 분기이며 성능상의 이유로 일부 디렉토리 구분 기호가 포함되어 있습니다 &lt;sup&gt;[ &lt;a href=&quot;#_footnotedef_1&quot; id=&quot;_footnoteref_1&quot;&gt;1&lt;/a&gt; ]&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="340dec00f8e27e530fc4429d17a96a5706fe14b1" translate="yes" xml:space="preserve">
          <source>Commit objects created with the above setting record the value of &lt;code&gt;i18n.commitEncoding&lt;/code&gt; in its &lt;code&gt;encoding&lt;/code&gt; header. This is to help other people who look at them later. Lack of this header implies that the commit log message is encoded in UTF-8.</source>
          <target state="translated">위 설정으로 생성 된 커밋 개체 는 &lt;code&gt;encoding&lt;/code&gt; 헤더 에 &lt;code&gt;i18n.commitEncoding&lt;/code&gt; 값을 기록합니다 . 이것은 나중에 그들을 보는 다른 사람들을 돕기위한 것입니다. 이 헤더가 없다는 것은 커밋 로그 메시지가 UTF-8로 인코딩되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3e636bd205abbae562ddd3b2c8e7ad0ad71d57b9" translate="yes" xml:space="preserve">
          <source>Commit the now-current index with whatever commit message is appropriate now.</source>
          <target state="translated">현재 적절한 커밋 메시지로 현재 인덱스를 커밋하십시오.</target>
        </trans-unit>
        <trans-unit id="0d30e12bd35c1bbb537786b722f71f7710203505" translate="yes" xml:space="preserve">
          <source>Commit the superproject:</source>
          <target state="translated">슈퍼 프로젝트를 커밋하십시오 :</target>
        </trans-unit>
        <trans-unit id="c2ba6e6758d4e077ba6384de032e88b129ac1452" translate="yes" xml:space="preserve">
          <source>Commit to end at (defaults to HEAD). This names the commit at the tip of the history you are asking to be pulled.</source>
          <target state="translated">에 종료하기로 약속합니다 (기본값은 HEAD). 이것은 끌어 오기를 요청한 히스토리 끝에 커밋의 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="5d83b220e2a717b4332302a14b01dfcf38b82250" translate="yes" xml:space="preserve">
          <source>Commit to start at. This names a commit that is already in the upstream history.</source>
          <target state="translated">시작할 것을 약속합니다. 이것은 이미 업스트림 히스토리에있는 커밋의 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="58a3fb0fa9151eaf5eb44aad642ac139bbd8d0a3" translate="yes" xml:space="preserve">
          <source>Commit to this SVN URL (the full path). This is intended to allow existing &lt;code&gt;git svn&lt;/code&gt; repositories created with one transport method (e.g. &lt;code&gt;svn://&lt;/code&gt; or &lt;code&gt;http://&lt;/code&gt; for anonymous read) to be reused if a user is later given access to an alternate transport method (e.g. &lt;code&gt;svn+ssh://&lt;/code&gt; or &lt;code&gt;https://&lt;/code&gt;) for commit.</source>
          <target state="translated">이 SVN URL (전체 경로)로 커밋합니다. 이는 사용자에게 나중에 다른 전송 방법 (예 : &lt;code&gt;svn+ssh://&lt;/code&gt; 대한 액세스 권한이 부여 된 경우 하나의 전송 방법 (예 : &lt;code&gt;svn://&lt;/code&gt; 또는 익명 읽기의 경우 &lt;code&gt;http://&lt;/code&gt; )으로 작성된 기존 &lt;code&gt;git svn&lt;/code&gt; 저장소 를 재사용 할 수 있도록하기위한 것입니다 . 커밋의 &lt;code&gt;https://&lt;/code&gt; // 또는 https : // )</target>
        </trans-unit>
        <trans-unit id="5d95f392f7b327e450a5cff3a7d0d778dd7bb17a" translate="yes" xml:space="preserve">
          <source>Commit-ish object names to describe. Defaults to HEAD if omitted.</source>
          <target state="translated">설명 할 개체 이름을 커밋하십시오. 생략하면 기본값은 HEAD입니다.</target>
        </trans-unit>
        <trans-unit id="806d7e617bf08278640b3918df6eb314e00c91ba" translate="yes" xml:space="preserve">
          <source>Commits A and B would no longer belong to a branch with a symbolic name, and so would be unreachable. As such, these commits would be removed by a &lt;code&gt;git gc&lt;/code&gt; command on the origin repository.</source>
          <target state="translated">커밋 A와 B는 더 이상 상징적 인 이름을 가진 지점에 속하지 않으므로 도달 할 수 없습니다. 따라서 이러한 커밋은 원본 리포지토리 의 &lt;code&gt;git gc&lt;/code&gt; 명령으로 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="cd34e82ef88e8c2479cf92c1c7e01e1f9402380d" translate="yes" xml:space="preserve">
          <source>Commits are included if they are not TREESAME to any parent (though this can be changed, see &lt;code&gt;--sparse&lt;/code&gt; below). If the commit was a merge, and it was TREESAME to one parent, follow only that parent. (Even if there are several TREESAME parents, follow only one of them.) Otherwise, follow all parents.</source>
          <target state="translated">커밋은 부모에게 TREESAME이 아닌 경우 포함됩니다 (변경 될 수는 있지만 아래의 &lt;code&gt;--sparse&lt;/code&gt; 참조). 커밋이 병합이고 한 부모에게 TREESAME 인 경우 해당 부모 만 따르십시오. (TREESAME 부모가 여러 명 있어도 부모 중 한 명만 따르십시오.) 그렇지 않으면 모든 부모를 따르십시오.</target>
        </trans-unit>
        <trans-unit id="639abedb72340eed90c014868e55014692d325d7" translate="yes" xml:space="preserve">
          <source>Commits modifying the given &amp;lt;paths&amp;gt; are selected.</source>
          <target state="translated">주어진 &amp;lt;paths&amp;gt;를 수정하는 커밋이 선택되었습니다.</target>
        </trans-unit>
        <trans-unit id="e092c6ca44bf3dcd26785c6425ee818e873ea1fd" translate="yes" xml:space="preserve">
          <source>Commits that are referred by some branch or tag are selected.</source>
          <target state="translated">일부 브랜치 또는 태그가 참조하는 커밋이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="6d094219b19302ca10342a1d1eec0568558c2bd8" translate="yes" xml:space="preserve">
          <source>Commits that are walked are included if they are not TREESAME to any parent.</source>
          <target state="translated">보행 된 커밋은 부모에게 TREESAME이 아닌 경우 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ef7e9aac4d19855b4ef3c8efc0ae0f7c81184b39" translate="yes" xml:space="preserve">
          <source>Commits the diff of two tree-ish arguments from the command-line. This command does not rely on being inside a &lt;code&gt;git svn
init&lt;/code&gt;-ed repository. This command takes three arguments, (a) the original tree to diff against, (b) the new tree result, (c) the URL of the target Subversion repository. The final argument (URL) may be omitted if you are working from a &lt;code&gt;git svn&lt;/code&gt;-aware repository (that has been &lt;code&gt;init&lt;/code&gt;-ed with &lt;code&gt;git svn&lt;/code&gt;). The -r&amp;lt;revision&amp;gt; option is required for this.</source>
          <target state="translated">명령 행에서 두 개의 트리 인수의 차이를 커밋합니다. 이 명령은 &lt;code&gt;git svn init&lt;/code&gt; -ed 저장소 내부에 의존하지 않습니다 . 이 명령은 (a) 비교할 원래 트리, (b) 새 트리 결과, (c) 대상 Subversion 저장소의 URL의 세 가지 인수를 사용합니다. 당신이에서 작업하는 경우 최종 인수 (URL)를 생략 할 수있다 &lt;code&gt;git svn&lt;/code&gt; - 인식 저장소 (즉되었습니다 &lt;code&gt;init&lt;/code&gt; -ed와 &lt;code&gt;git svn&lt;/code&gt; ). 이를 위해서는 -r &amp;lt;revision&amp;gt; 옵션이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="958e7e955e68b84d191b41f660f0af907a1a26e7" translate="yes" xml:space="preserve">
          <source>Commits to cherry-pick. For a more complete list of ways to spell commits, see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;. Sets of commits can be passed but no traversal is done by default, as if the &lt;code&gt;--no-walk&lt;/code&gt; option was specified, see &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;. Note that specifying a range will feed all &amp;lt;commit&amp;gt;&amp;hellip;​ arguments to a single revision walk (see a later example that uses &lt;code&gt;maint master..next&lt;/code&gt;).</source>
          <target state="translated">체리 픽을 약속합니다. 커밋 철자법에 대한 전체 목록은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]를&lt;/a&gt; 참조하십시오 . &lt;code&gt;--no-walk&lt;/code&gt; 옵션이 지정된 것처럼 커밋 세트는 전달할 수 있지만 기본적으로 순회는 수행되지 않습니다 ( &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1] 참조)&lt;/a&gt; . 범위를 지정하면 모든 &amp;lt;commit&amp;gt;&amp;hellip; 인수가 단일 개정 워크에 제공됩니다 ( &lt;code&gt;maint master..next&lt;/code&gt; 를 사용하는 이후 예제 참조 ).</target>
        </trans-unit>
        <trans-unit id="dbab89c03eabe421a0f756d1774250a10ff8a483" translate="yes" xml:space="preserve">
          <source>Commits to revert. For a more complete list of ways to spell commit names, see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;. Sets of commits can also be given but no traversal is done by default, see &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; and its &lt;code&gt;--no-walk&lt;/code&gt; option.</source>
          <target state="translated">되돌릴 것을 약속합니다. 커밋 이름을 철자하는 방법에 대한 전체 목록은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]를&lt;/a&gt; 참조하십시오 . 커밋 세트도 제공 할 수 있지만 기본적으로 순회는 수행되지 않습니다. &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt; 및 해당 &lt;code&gt;--no-walk&lt;/code&gt; 옵션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="49656a8c34bd2a56ea7b1c4c19ee41def8e375e6" translate="yes" xml:space="preserve">
          <source>Commits, usually other branch heads, to merge into our branch. Specifying more than one commit will create a merge with more than two parents (affectionately called an Octopus merge).</source>
          <target state="translated">일반적으로 다른 지사 헤드를 지사로 통합합니다. 둘 이상의 커밋을 지정하면 둘 이상의 부모와 합병이 이루어집니다 (아마도 Octopus 병합이라고 함).</target>
        </trans-unit>
        <trans-unit id="c73e3ca2125dd6b66724a23fd1d9404dae439c7b" translate="yes" xml:space="preserve">
          <source>Committing everything directly on the integration branches leads to many problems: Bad commits cannot be undone, so they must be reverted one by one, which creates confusing histories and further error potential when you forget to revert part of a group of changes. Working in parallel mixes up the changes, creating further confusion.</source>
          <target state="translated">통합 브랜치에서 모든 것을 직접 커밋하면 많은 문제가 발생합니다. 잘못된 커밋은 취소 할 수 없으므로 하나씩 되돌려 야하므로 변경 내역 그룹의 일부를 되 돌리는 것을 잊었을 때 혼란스러운 기록과 추가 오류 가능성이 발생합니다. 병렬 작업은 변경 사항을 혼합하여 더 혼란을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="fe3255bd451d3471e881939414843a91c1360c6e" translate="yes" xml:space="preserve">
          <source>Committing git state</source>
          <target state="translated">자식 상태 커밋</target>
        </trans-unit>
        <trans-unit id="429882fbdbb00bcd134816d89830eb4242096534" translate="yes" xml:space="preserve">
          <source>Common Git shell script setup code</source>
          <target state="translated">일반적인 Git 쉘 스크립트 설정 코드</target>
        </trans-unit>
        <trans-unit id="8a9ecfa5494a6336bbbe04b6056604a3b2505855" translate="yes" xml:space="preserve">
          <source>Common Key/Value Pairs</source>
          <target state="translated">공통 키 / 값 쌍</target>
        </trans-unit>
        <trans-unit id="1af5706ae88f10b9ead3cfff1d78f59757380eca" translate="yes" xml:space="preserve">
          <source>Common diff options</source>
          <target state="translated">일반적인 diff 옵션</target>
        </trans-unit>
        <trans-unit id="17cfc9441a242e68c384e9b5b8cf9a0e4a24fffd" translate="yes" xml:space="preserve">
          <source>Common unit suffixes of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, or &lt;code&gt;g&lt;/code&gt; are supported.</source>
          <target state="translated">&lt;code&gt;k&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; 또는 &lt;code&gt;g&lt;/code&gt; 의 공통 단위 접미사 가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="2d454855d2445672da925706dc840080c654c187" translate="yes" xml:space="preserve">
          <source>Compare a tree to the working tree or index</source>
          <target state="translated">트리를 작업 트리 또는 인덱스와 비교</target>
        </trans-unit>
        <trans-unit id="b052eee7a70522f76de64441f0532b8b978732a8" translate="yes" xml:space="preserve">
          <source>Compare the commits specified by the two ranges, where &lt;code&gt;&amp;lt;range1&amp;gt;&lt;/code&gt; is considered an older version of &lt;code&gt;&amp;lt;range2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">두 범위로 지정된 커밋을 비교하십시오. 여기서 &lt;code&gt;&amp;lt;range1&amp;gt;&lt;/code&gt; 은 &lt;code&gt;&amp;lt;range2&amp;gt;&lt;/code&gt; 의 이전 버전으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="cbedfc6f6fea6e33a27f5f1a33053dbff1a37614" translate="yes" xml:space="preserve">
          <source>Compare the version before the last commit and the last commit.</source>
          <target state="translated">마지막 커밋과 마지막 커밋 이전의 버전을 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="108964900757319250c09d41bf5206fee17fbebf" translate="yes" xml:space="preserve">
          <source>Compare the working tree with the &quot;base&quot; version (stage #1), &quot;our branch&quot; (stage #2) or &quot;their branch&quot; (stage #3). The index contains these stages only for unmerged entries i.e. while resolving conflicts. See &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree[1]&lt;/a&gt; section &quot;3-Way Merge&quot; for detailed information.</source>
          <target state="translated">작업 트리를 &quot;기본&quot;버전 ​​(1 단계), &quot;우리 지점&quot;(2 단계) 또는 &quot;그들의 지점&quot;(3 단계)과 비교하십시오. 색인에는 병합되지 않은 항목 (예 : 충돌 해결)에 대해서만이 단계가 포함됩니다. 자세한 내용은 &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree [1]&lt;/a&gt; 섹션 &quot;3-Way Merge&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="417383ec38892ec59642ec5eded68ccdbddd54d0" translate="yes" xml:space="preserve">
          <source>Compare to &lt;code&gt;--full-history&lt;/code&gt; without rewriting above. Note that &lt;code&gt;E&lt;/code&gt; was pruned away because it is TREESAME, but the parent list of P was rewritten to contain &lt;code&gt;E&lt;/code&gt;'s parent &lt;code&gt;I&lt;/code&gt;. The same happened for &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt;, and &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt; and &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">위의 내용을 다시 쓰지 않고 &lt;code&gt;--full-history&lt;/code&gt; 와 비교하십시오 . 참고 &lt;code&gt;E&lt;/code&gt; 가 이 TREESAME 때문에 멀리 정리했지만, P의 부모 목록을 포함하도록 다시 작성되었다 &lt;code&gt;E&lt;/code&gt; 의 부모에게 &lt;code&gt;I&lt;/code&gt; 를 . &lt;code&gt;C&lt;/code&gt; 와 &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;Y&lt;/code&gt; 와 &lt;code&gt;Q&lt;/code&gt; 에 대해서도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="4186f0f14c1670feb8e3a98bffba021e85440c5e" translate="yes" xml:space="preserve">
          <source>Compare two commit ranges (e.g. two versions of a branch)</source>
          <target state="translated">두 커밋 범위 비교 (예 : 두 가지 버전의 브랜치)</target>
        </trans-unit>
        <trans-unit id="efcf6f2f0a57938476e9e49afce7ef20662e5045" translate="yes" xml:space="preserve">
          <source>Compares files in the working tree and the index</source>
          <target state="translated">작업 트리의 파일과 색인을 비교</target>
        </trans-unit>
        <trans-unit id="b51a5025d034c563fd7e4cf2f1781edb403c8a61" translate="yes" xml:space="preserve">
          <source>Compares the content and mode of blobs found via two tree objects</source>
          <target state="translated">두 개의 트리 객체를 통해 발견 된 블롭의 내용과 모드를 비교합니다</target>
        </trans-unit>
        <trans-unit id="4bed9c3374f6538cd59dc69ff688ff3c6921c3b0" translate="yes" xml:space="preserve">
          <source>Compares the content and mode of the blobs found in a tree object with the corresponding tracked files in the working tree, or with the corresponding paths in the index. When &amp;lt;path&amp;gt; arguments are present, compares only paths matching those patterns. Otherwise all tracked files are compared.</source>
          <target state="translated">트리 개체에서 찾은 블로 브의 내용과 모드를 작업 트리의 해당 추적 파일 또는 인덱스의 해당 경로와 비교합니다. &amp;lt;path&amp;gt; 인수가 있으면 해당 패턴과 일치하는 경로 만 비교합니다. 그렇지 않으면 모든 추적 된 파일이 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="37c34b145e3b8ab67ff7b61ff3d11d3a3ac26e63" translate="yes" xml:space="preserve">
          <source>Compares the content and mode of the blobs found via two tree objects.</source>
          <target state="translated">두 트리 개체를 통해 찾은 블롭의 내용과 모드를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="7bbeb5d1d5d86904df9d33155d8ac31a0ac700db" translate="yes" xml:space="preserve">
          <source>Compares the files in the working tree and the index. When paths are specified, compares only those named paths. Otherwise all entries in the index are compared. The output format is the same as for &lt;code&gt;git diff-index&lt;/code&gt; and &lt;code&gt;git diff-tree&lt;/code&gt;.</source>
          <target state="translated">작업 트리의 파일과 색인을 비교합니다. 경로가 지정되면 이름이 지정된 경로 만 비교합니다. 그렇지 않으면 색인의 모든 항목이 비교됩니다. 출력 형식은 &lt;code&gt;git diff-index&lt;/code&gt; 및 &lt;code&gt;git diff-tree&lt;/code&gt; 와 동일 합니다 .</target>
        </trans-unit>
        <trans-unit id="f362db0c69868c1d491d62f5976e73dedfebf2ca" translate="yes" xml:space="preserve">
          <source>Comparing blobs or trees that have been replaced with those that replace them will not work properly. And using &lt;code&gt;git reset --hard&lt;/code&gt; to go back to a replaced commit will move the branch to the replacement commit instead of the replaced commit.</source>
          <target state="translated">교체 된 블롭 또는 트리를 교체 한 블롭 또는 트리를 비교하면 제대로 작동하지 않습니다. 그리고 &lt;code&gt;git reset --hard&lt;/code&gt; 를 사용하여 교체 된 커밋으로 돌아 가면 분기가 교체 된 커밋 대신 교체 커밋으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="e0150129e57bff1f18c9fdecdc5f6497b9177eb2" translate="yes" xml:space="preserve">
          <source>Comparing branches</source>
          <target state="translated">가지 비교</target>
        </trans-unit>
        <trans-unit id="275ba455480c0eb203a002756ce88295e425384f" translate="yes" xml:space="preserve">
          <source>Comparing with arbitrary commits</source>
          <target state="translated">임의 커밋과 비교</target>
        </trans-unit>
        <trans-unit id="0623cdc962e5b3ec3734b834b479126f0b30d78b" translate="yes" xml:space="preserve">
          <source>Complete list of all commands</source>
          <target state="translated">모든 명령의 전체 목록</target>
        </trans-unit>
        <trans-unit id="09a81cc081fc6614431d0059db9771c7f435cba4" translate="yes" xml:space="preserve">
          <source>Components which are missing from the URL (e.g., there is no username in the example above) will be left unset.</source>
          <target state="translated">URL에서 누락 된 구성 요소 (예 : 위의 예에 사용자 이름이 없음)는 설정되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="678bc9ada07c728ccee1f48de02cb28152653f42" translate="yes" xml:space="preserve">
          <source>Composing</source>
          <target state="translated">Composing</target>
        </trans-unit>
        <trans-unit id="3a4b462b90ad947c014f566102a2e5a0dd92671e" translate="yes" xml:space="preserve">
          <source>Comprehensive reference documentation is available through the man pages, or &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt; command. For example, for the command &lt;code&gt;git clone &amp;lt;repo&amp;gt;&lt;/code&gt;, you can either use:</source>
          <target state="translated">종합적인 참조 문서는 매뉴얼 페이지 또는 &lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt; 명령을 통해 제공됩니다. 예를 들어, &lt;code&gt;git clone &amp;lt;repo&amp;gt;&lt;/code&gt; 명령의 경우 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90ae7930698f6a9514e277afc75b1efe24fb78ff" translate="yes" xml:space="preserve">
          <source>Compress $GIT_DIR/svn/&amp;lt;refname&amp;gt;/unhandled.log files and remove $GIT_DIR/svn/&amp;lt;refname&amp;gt;/index files.</source>
          <target state="translated">$ GIT_DIR / svn / &amp;lt;refname&amp;gt; /unhandled.log 파일을 압축하고 $ GIT_DIR / svn / &amp;lt;refname&amp;gt; / index 파일을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="af5758a107c963e9444cff5454d146835b9b660b" translate="yes" xml:space="preserve">
          <source>Compute object ID and optionally creates a blob from a file</source>
          <target state="translated">객체 ID를 계산하고 선택적으로 파일에서 얼룩을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="01c4a7d17645c800690175029629fd7aeb958298" translate="yes" xml:space="preserve">
          <source>Compute the best common ancestors of all supplied commits, in preparation for an n-way merge. This mimics the behavior of &lt;code&gt;git show-branch --merge-base&lt;/code&gt;.</source>
          <target state="translated">n-way 병합을 준비하면서 제공된 모든 커밋의 가장 일반적인 공통 조상을 계산하십시오. 이것은 &lt;code&gt;git show-branch --merge-base&lt;/code&gt; 의 동작을 모방합니다 .</target>
        </trans-unit>
        <trans-unit id="9bde35c0f2dc15b67baddfc39466c5eba5799786" translate="yes" xml:space="preserve">
          <source>Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file. In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.</source>
          <target state="translated">소스에서 제거되었거나 대상에 추가 된 행을 계산하여 dirstat 번호를 계산하십시오. 이것은 파일 내에서 순수 코드 이동량을 무시합니다. 즉, 파일에서 줄을 다시 정렬하는 것은 다른 변경만큼 계산되지 않습니다. 매개 변수가 제공되지 않은 경우의 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="d5135b971c817889635eeca2e7a1431f33e06f37" translate="yes" xml:space="preserve">
          <source>Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest &lt;code&gt;--dirstat&lt;/code&gt; behavior, since it does not have to look at the file contents at all.</source>
          <target state="translated">변경된 파일 수를 세어 dirstat 수를 계산하십시오. 변경된 각 파일은 dirstat 분석에서 동일하게 계산됩니다. 파일 내용을 전혀 볼 필요가 없기 때문에 계산 상 가장 저렴한 &lt;code&gt;--dirstat&lt;/code&gt; 동작입니다.</target>
        </trans-unit>
        <trans-unit id="3058cd552896436a63e7fe6f202c943042969930" translate="yes" xml:space="preserve">
          <source>Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive &lt;code&gt;--dirstat&lt;/code&gt; behavior than the &lt;code&gt;changes&lt;/code&gt; behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other &lt;code&gt;--*stat&lt;/code&gt; options.</source>
          <target state="translated">정기적 인 라인 기반 diff 분석을 수행하고 제거 / 추가 된 라인 수를 합하여 dirstat 번호를 계산합니다. (이진 파일의 경우, 이진 파일에는 자연스러운 개념의 줄이 없기 때문에 대신 64 바이트 청크를 계산하십시오). &lt;code&gt;changes&lt;/code&gt; 동작보다 비용이 많이 드는 &lt;code&gt;--dirstat&lt;/code&gt; 동작 이지만 파일 내에서 재정렬 된 행을 다른 변경만큼 계산합니다. 결과 출력은 다른 &lt;code&gt;--*stat&lt;/code&gt; 옵션 에서 얻은 것과 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="6a0b0a16b974bf1fed36c439dfbdefde29d32d7c" translate="yes" xml:space="preserve">
          <source>Compute unique ID for a patch</source>
          <target state="translated">패치의 고유 ID 계산</target>
        </trans-unit>
        <trans-unit id="8998103614864fe1630f3c6a0063c614dbc4eadb" translate="yes" xml:space="preserve">
          <source>Computes the object ID value for an object with specified type with the contents of the named file (which can be outside of the work tree), and optionally writes the resulting object into the object database. Reports its object ID to its standard output. When &amp;lt;type&amp;gt; is not specified, it defaults to &quot;blob&quot;.</source>
          <target state="translated">명명 된 파일의 내용 (작업 트리 외부에있을 수 있음)으로 지정된 유형의 오브젝트에 대한 오브젝트 ID 값을 계산하고 선택적으로 결과 오브젝트를 오브젝트 데이터베이스에 씁니다. 객체 ID를 표준 출력에보고합니다. &amp;lt;type&amp;gt;을 지정하지 않으면 기본값은 &quot;blob&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="937949a3d933696c9d4185384073018afe774033" translate="yes" xml:space="preserve">
          <source>Concatenates the contents of said Makefiles in the head of the branch &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">브랜치 &lt;code&gt;master&lt;/code&gt; 의 헤드에 상기 Makefile의 내용을 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="7d484eb61cfd5469110c2312d1ec91512fe53e6a" translate="yes" xml:space="preserve">
          <source>Conceptually there are only four object types: commit, tree, tag and blob. However to save space, an object could be stored as a &quot;delta&quot; of another &quot;base&quot; object. These representations are assigned new types ofs-delta and ref-delta, which is only valid in a pack file.</source>
          <target state="translated">개념적으로 commit, tree, tag 및 blob의 네 가지 객체 유형이 있습니다. 그러나 공간을 절약하기 위해 객체를 다른 &quot;기본&quot;객체의 &quot;델타&quot;로 저장할 수 있습니다. 이러한 표현에는 새로운 유형의 s-delta 및 ref-delta가 지정되며, 이는 팩 파일에서만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="f9ce6c77a92950f557622abcc328a5c52bc5ce16" translate="yes" xml:space="preserve">
          <source>Conceptually, &lt;code&gt;git write-tree&lt;/code&gt; sync()s the current index contents into a set of tree files. In order to have that match what is actually in your directory right now, you need to have done a &lt;code&gt;git update-index&lt;/code&gt; phase before you did the &lt;code&gt;git write-tree&lt;/code&gt;.</source>
          <target state="translated">개념적으로 &lt;code&gt;git write-tree&lt;/code&gt; sync ()는 현재 색인 내용을 일련의 트리 파일로 동기화합니다. 현재 디렉토리에 실제로있는 것과 일치 하려면 &lt;code&gt;git write-tree&lt;/code&gt; 수행 하기 전에 &lt;code&gt;git update-index&lt;/code&gt; 단계를 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9ca3e3f6198d8db66027f645ef57e4ac30e9a37f" translate="yes" xml:space="preserve">
          <source>Conceptually, the feature enters at an unstable branch (usually &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;pu&lt;/code&gt;), and &quot;graduates&quot; to &lt;code&gt;master&lt;/code&gt; for the next release once it is considered stable enough.</source>
          <target state="translated">개념적으로,이 기능은 불안정한 지점 (보통 &lt;code&gt;next&lt;/code&gt; 또는 &lt;code&gt;pu&lt;/code&gt; )에 들어가고 , &quot;안보&quot; 는 충분히 안정된 것으로 판단되면 다음 릴리스 를 &lt;code&gt;master&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f6ef470943762cee844729c89f18b4378eb7782a" translate="yes" xml:space="preserve">
          <source>Conceptually, the feature enters at an unstable branch (usually &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;seen&lt;/code&gt;), and &quot;graduates&quot; to &lt;code&gt;master&lt;/code&gt; for the next release once it is considered stable enough.</source>
          <target state="translated">개념적으로이 기능은 불안정한 브랜치 (일반적으로 &lt;code&gt;next&lt;/code&gt; 또는 &lt;code&gt;seen&lt;/code&gt; )에 들어가고 충분히 안정된 것으로 간주되면 다음 릴리스 를 위해 &lt;code&gt;master&lt;/code&gt; 하기 위해 &quot;졸업&quot;합니다 .</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="c144db8f4732a9347031a1b40f149e52d91f565f" translate="yes" xml:space="preserve">
          <source>Concrete example</source>
          <target state="translated">구체적인 예</target>
        </trans-unit>
        <trans-unit id="1805d25f90c97785232c09de6be3d92c9bae4482" translate="yes" xml:space="preserve">
          <source>Conditional includes</source>
          <target state="translated">조건부 포함</target>
        </trans-unit>
        <trans-unit id="1eca678ae2103e84056e13fabe651ada3207805a" translate="yes" xml:space="preserve">
          <source>Cone pattern set</source>
          <target state="translated">콘 패턴 세트</target>
        </trans-unit>
        <trans-unit id="eb7272ff2c451e4d56ff0b5035c89e6773552a2b" translate="yes" xml:space="preserve">
          <source>Config file-only options</source>
          <target state="translated">구성 파일 전용 옵션</target>
        </trans-unit>
        <trans-unit id="422fb4b2c323c56fc618406ee76b1fefb87edd1b" translate="yes" xml:space="preserve">
          <source>Config variables</source>
          <target state="translated">구성 변수</target>
        </trans-unit>
        <trans-unit id="754164850f38c1ecdaf6b8ed894cb192bc36c5f4" translate="yes" xml:space="preserve">
          <source>Configuration</source>
          <target state="translated">Configuration</target>
        </trans-unit>
        <trans-unit id="acdba8395423767de730ee1b75436df3a0ebc87e" translate="yes" xml:space="preserve">
          <source>Configuration file</source>
          <target state="translated">구성 파일</target>
        </trans-unit>
        <trans-unit id="70c34b77eccd45b690bac76f834e5695507ca571" translate="yes" xml:space="preserve">
          <source>Configuration mechanism</source>
          <target state="translated">구성 메커니즘</target>
        </trans-unit>
        <trans-unit id="f4d40d6c54ed064cd5675e2b020be36dc38807c6" translate="yes" xml:space="preserve">
          <source>Configuration options</source>
          <target state="translated">구성 옵션</target>
        </trans-unit>
        <trans-unit id="38b23d1375544f4a68ea9228188041f47459e054" translate="yes" xml:space="preserve">
          <source>Configuration variables</source>
          <target state="translated">구성 변수</target>
        </trans-unit>
        <trans-unit id="8a66ea31ab3d6b079e67d729ad34365bb857146f" translate="yes" xml:space="preserve">
          <source>Configure a &quot;tar.xz&quot; format for making LZMA-compressed tarfiles. You can use it specifying &lt;code&gt;--format=tar.xz&lt;/code&gt;, or by creating an output file like &lt;code&gt;-o foo.tar.xz&lt;/code&gt;.</source>
          <target state="translated">LZMA 압축 tarfile을 만들기 위해 &quot;tar.xz&quot;형식을 구성하십시오. &lt;code&gt;--format=tar.xz&lt;/code&gt; 를 지정 하거나 &lt;code&gt;-o foo.tar.xz&lt;/code&gt; 와 같은 출력 파일을 작성하여 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6a6815a7f24dfffdb1d929dd323aaec05a9ab47" translate="yes" xml:space="preserve">
          <source>Configure a &lt;code&gt;fix&lt;/code&gt; trailer with a key that contains a &lt;code&gt;#&lt;/code&gt; and no space after this character, and show how it works:</source>
          <target state="translated">이 문자 다음에 공백이없는 &lt;code&gt;#&lt;/code&gt; 을 포함하는 키로 &lt;code&gt;fix&lt;/code&gt; 트레일러를 구성하고 작동 방식을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="ce90c0bc932e5f1df9b68ee7ec6c0da58d747ea5" translate="yes" xml:space="preserve">
          <source>Configure a &lt;code&gt;see&lt;/code&gt; trailer with a command to show the subject of a commit that is related, and show how it works:</source>
          <target state="translated">관련 커밋의 주제를 표시하고 작동 방식을 표시하는 명령으로 &lt;code&gt;see&lt;/code&gt; trailer를 구성 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9ccaafdcef74174cf7734bdb6a6d7caabe83888" translate="yes" xml:space="preserve">
          <source>Configure a &lt;code&gt;sign&lt;/code&gt; trailer with a &lt;code&gt;Signed-off-by&lt;/code&gt; key, and then add two of these trailers to a message:</source>
          <target state="translated">&lt;code&gt;Signed-off-by&lt;/code&gt; 키를 사용 하여 &lt;code&gt;sign&lt;/code&gt; 트레일러를 구성한 다음이 트레일러 중 두 개를 메시지에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e0f5abc21cdfc10087712a4df06b45d6f1ed9b35" translate="yes" xml:space="preserve">
          <source>Configure a &lt;code&gt;sign&lt;/code&gt; trailer with a command to automatically add a 'Signed-off-by: ' with the author information only if there is no 'Signed-off-by: ' already, and show how it works:</source>
          <target state="translated">'Signed-off-by ::'가없는 경우에만 작성자 정보와 함께 'Signed-off-by ::'를 자동으로 추가하도록 명령으로 &lt;code&gt;sign&lt;/code&gt; 트레일러를 구성하고 작동 방식을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="f50c440d2f6f9060cd052adb1632feec1a0c614d" translate="yes" xml:space="preserve">
          <source>Configure a commit template with some trailers with empty values (using sed to show and keep the trailing spaces at the end of the trailers), then configure a commit-msg hook that uses &lt;code&gt;git interpret-trailers&lt;/code&gt; to remove trailers with empty values and to add a &lt;code&gt;git-version&lt;/code&gt; trailer:</source>
          <target state="translated">빈 값을 가진 일부 트레일러로 커밋 템플릿을 구성하고 (예 : sed를 사용하여 트레일러 끝에 후행 공백을 표시하고 유지) 빈 값을 가진 &lt;code&gt;git interpret-trailers&lt;/code&gt; 를 제거하고 추가하기 위해 git 해석 트레일러 를 사용하는 commit-msg 후크를 구성 합니다. &lt;code&gt;git-version&lt;/code&gt; 트레일러 :</target>
        </trans-unit>
        <trans-unit id="3f6c615a6da0f7262f6f2dbcc08ecf276b931a9e" translate="yes" xml:space="preserve">
          <source>Configure your general composition window to not wrap.</source>
          <target state="translated">랩핑하지 않도록 일반 컴포지션 창을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="3551290f2193aa1e636343f0cbcbc633f639f8c4" translate="yes" xml:space="preserve">
          <source>Configure your mail server composition as plain text: Edit&amp;hellip;​Account Settings&amp;hellip;​Composition &amp;amp; Addressing, uncheck &quot;Compose Messages in HTML&quot;.</source>
          <target state="translated">메일 서버 구성을 일반 텍스트로 구성하십시오 : 편집&amp;hellip; 계정 설정&amp;hellip; 구성 및 주소 지정에서 &quot;HTML에서 메시지 작성&quot;을 선택 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="3e29b2ee31b493715ce39183ea79ba9aca718b3b" translate="yes" xml:space="preserve">
          <source>Configured remote-tracking branches</source>
          <target state="translated">구성된 원격 추적 지점</target>
        </trans-unit>
        <trans-unit id="4976060b350e89ec5dfdb2a1c1950efb45f52bc3" translate="yes" xml:space="preserve">
          <source>Configuring database backend</source>
          <target state="translated">데이터베이스 백엔드 구성</target>
        </trans-unit>
        <trans-unit id="c983b7934801a3688ed66b5498ab09519448fc97" translate="yes" xml:space="preserve">
          <source>Configuring gitweb features</source>
          <target state="translated">gitweb 기능 구성</target>
        </trans-unit>
        <trans-unit id="40e0a19569f8f1844d5a471098cc89ca36d5ca64" translate="yes" xml:space="preserve">
          <source>Configuring remote-tracking branches</source>
          <target state="translated">원격 추적 분기 구성</target>
        </trans-unit>
        <trans-unit id="9e40cad468539cb8231b63b11fdb5df741e2d14b" translate="yes" xml:space="preserve">
          <source>Confirm just before sending:</source>
          <target state="translated">보내기 직전에 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ecda02ba517320c0b15d176b3e447e83063fff66" translate="yes" xml:space="preserve">
          <source>Conflict markers are left in the problematic files, and after you resolve the conflicts manually, you can update the index with the contents and run Git commit, as you normally would when creating a new file.</source>
          <target state="translated">충돌 마커는 문제가있는 파일에 남아 있으며 충돌을 수동으로 해결 한 후에는 일반적으로 새 파일을 만들 때와 같이 내용으로 인덱스를 업데이트하고 Git 커밋을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b82d334ed6758888e34c8a34df72370a5d90993b" translate="yes" xml:space="preserve">
          <source>Conflicts can occur when applying a commit to p4. When this happens, the default behavior (&quot;ask&quot;) is to prompt whether to skip this commit and continue, or quit. This option can be used to bypass the prompt, causing conflicting commits to be automatically skipped, or to quit trying to apply commits, without prompting.</source>
          <target state="translated">p4에 커밋을 적용 할 때 충돌이 발생할 수 있습니다. 이 경우 기본 동작 ( &quot;ask&quot;)은이 커밋을 건너 뛰고 계속할 것인지 종료 할 것인지 묻는 메시지를 표시합니다. 이 옵션을 사용하면 프롬프트를 무시하고 충돌하는 커밋을 자동으로 건너 뛰거나 프롬프트없이 커밋 적용을 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9246582c40c7034c419d5e149871effa77f01da" translate="yes" xml:space="preserve">
          <source>Connects to given service. Standard input and standard output of helper are connected to specified service (git prefix is included in service name so e.g. fetching uses &lt;code&gt;git-upload-pack&lt;/code&gt; as service) on remote side. Valid replies to this command are empty line (connection established), &lt;code&gt;fallback&lt;/code&gt; (no smart transport support, fall back to dumb transports) and just exiting with error message printed (can&amp;rsquo;t connect, don&amp;rsquo;t bother trying to fall back). After line feed terminating the positive (empty) response, the output of service starts. After the connection ends, the remote helper exits.</source>
          <target state="translated">주어진 서비스에 연결합니다. 헬퍼의 표준 입력 및 표준 출력은 원격 에서 지정된 서비스에 연결됩니다 (git 접두사가 서비스 이름에 포함되어 있으므로 가져 오기는 &lt;code&gt;git-upload-pack&lt;/code&gt; 을 서비스로 사용합니다). 이 명령에 대한 올바른 회신은 빈 줄 (연결 설정), &lt;code&gt;fallback&lt;/code&gt; (스마트 전송 지원 없음, 벙어리 전송으로 폴백 ) 및 오류 메시지가 인쇄 된 상태로 종료 됨 (연결할 수없고 폴백하지 않음)입니다. 라인 피드가 양 (빈) 응답을 종료 한 후 서비스 출력이 시작됩니다. 연결이 끝나면 원격 헬퍼가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="ab69689298b341c622fdf07baf6d7935162cc21e" translate="yes" xml:space="preserve">
          <source>Consider &lt;code&gt;.gitattributes&lt;/code&gt; in the index only, ignoring the working tree.</source>
          <target state="translated">작업 트리를 무시하고 인덱스에만 &lt;code&gt;.gitattributes&lt;/code&gt; 를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e9b2aca01cec344e42ddb2f6c4d43d446641ec6" translate="yes" xml:space="preserve">
          <source>Consider any object recorded in the index also as a head node for an unreachability trace.</source>
          <target state="translated">연결할 수없는 추적을 위해 헤드 노드로 색인에 기록 된 모든 오브젝트를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="5dd8963c37ba70016cc97181d1437d9d279837cb" translate="yes" xml:space="preserve">
          <source>Consider only commits that are enough to explain how the files that match the specified paths came to be.</source>
          <target state="translated">지정된 경로와 일치하는 파일이 어떻게 만들어 졌는지 설명하기에 충분한 커밋 만 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ba0254d514d0f2ca6e4ebd12fd91b2a48fa85b1d" translate="yes" xml:space="preserve">
          <source>Consider the following .gitmodules file:</source>
          <target state="translated">다음 .gitmodules 파일을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="8a3a2dda249f0930d1314682106ca1561464766d" translate="yes" xml:space="preserve">
          <source>Consider the limiting patterns to be Perl-compatible regular expressions.</source>
          <target state="translated">제한 패턴이 Perl 호환 정규식이라고 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="d3cbcdfc580ee16544a677fdcaea7364f6ffede7" translate="yes" xml:space="preserve">
          <source>Consider the limiting patterns to be basic regular expressions; this is the default.</source>
          <target state="translated">제한 패턴을 기본 정규식으로 간주하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="cc80930760a8dae17ccff09b94b94b8c2a73e3d6" translate="yes" xml:space="preserve">
          <source>Consider the limiting patterns to be extended regular expressions instead of the default basic regular expressions.</source>
          <target state="translated">제한 패턴을 기본 기본 정규식 대신 확장 정규식으로 간주하십시오.</target>
        </trans-unit>
        <trans-unit id="0bd0c2e95b3ce3558e3f029a387e02dcaec9fc10" translate="yes" xml:space="preserve">
          <source>Consider the limiting patterns to be fixed strings (don&amp;rsquo;t interpret pattern as a regular expression).</source>
          <target state="translated">제한 패턴을 고정 문자열로 간주하십시오 (패턴을 정규식으로 해석하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="ce08a982fc80bf880f9e5e7fbbc19290d0e13642" translate="yes" xml:space="preserve">
          <source>Consider this history:</source>
          <target state="translated">이 역사를 고려하십시오 :</target>
        </trans-unit>
        <trans-unit id="6e0518d23c6b434e11a17284519d985d575f8d5b" translate="yes" xml:space="preserve">
          <source>Considers adding content from all git-*.sh scripts:</source>
          <target state="translated">모든 git-*. sh 스크립트에서 컨텐츠를 추가하는 것을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="aa183b32e2469308bcac751961ddf4f45522d312" translate="yes" xml:space="preserve">
          <source>Construct a commit message for use with &lt;code&gt;rebase --autosquash&lt;/code&gt;. The commit message subject line is taken from the specified commit with a prefix of &quot;squash! &quot;. Can be used with additional commit message options (&lt;code&gt;-m&lt;/code&gt;/&lt;code&gt;-c&lt;/code&gt;/&lt;code&gt;-C&lt;/code&gt;/&lt;code&gt;-F&lt;/code&gt;). See &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;rebase --autosquash&lt;/code&gt; 와 함께 사용할 커밋 메시지를 구성합니다 . 커밋 메시지 제목 줄은 &quot;squash!&quot;접두사가있는 지정된 커밋에서 가져옵니다. 추가 커밋 메시지 옵션 ( &lt;code&gt;-m&lt;/code&gt; / &lt;code&gt;-c&lt;/code&gt; / &lt;code&gt;-C&lt;/code&gt; / &lt;code&gt;-F&lt;/code&gt; ) 과 함께 사용할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="613af883ed6da1442ba9d47b0f082fab42f334c7" translate="yes" xml:space="preserve">
          <source>Construct a commit message for use with &lt;code&gt;rebase --autosquash&lt;/code&gt;. The commit message will be the subject line from the specified commit with a prefix of &quot;fixup! &quot;. See &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;rebase --autosquash&lt;/code&gt; 와 함께 사용할 커밋 메시지를 구성합니다 . 커밋 메시지는 접두사가 &quot;fixup!&quot;인 지정된 커밋의 제목 줄입니다. 자세한 내용은 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="26410cb72d41a741e69a55d63cb8badf7f0b0bd2" translate="yes" xml:space="preserve">
          <source>Contains administrative data for linked working trees. Each subdirectory contains the working tree-related part of a linked working tree. This directory is ignored if $GIT_COMMON_DIR is set, in which case &quot;$GIT_COMMON_DIR/worktrees&quot; will be used instead.</source>
          <target state="translated">연결된 작업 트리에 대한 관리 데이터를 포함합니다. 각 하위 디렉토리에는 연결된 작업 트리의 작업 트리 관련 부분이 포함됩니다. $ GIT_COMMON_DIR이 설정된 경우이 디렉토리는 무시되며,이 경우 &quot;$ GIT_COMMON_DIR / worktrees&quot;가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="926bb57bf277ea775a3bccb0602b810a03d08da9" translate="yes" xml:space="preserve">
          <source>Contains the git-repositories of the submodules.</source>
          <target state="translated">서브 모듈의 자식 저장소를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="2017a3b0e62c7744478a46c444d4d27cb868b22a" translate="yes" xml:space="preserve">
          <source>Content which does not differ between the index and working tree may be shown on context lines, beginning with a &quot; &quot; (space). You can stage context lines for removal by converting the space to a &quot;-&quot;. The resulting working tree file will appear to re-add the content.</source>
          <target state="translated">인덱스와 작업 트리간에 차이가없는 내용은 &quot;&quot;(공백)으로 시작하는 컨텍스트 행에 표시 될 수 있습니다. 공백을 &quot;-&quot;로 변환하여 제거 할 컨텍스트 라인을 스테이징 할 수 있습니다. 결과 작업 트리 파일이 내용을 다시 추가하는 것으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="cc11b3a28fa30ae6d3d3ad1438824cbd5224ba5c" translate="yes" xml:space="preserve">
          <source>Context</source>
          <target state="translated">Context</target>
        </trans-unit>
        <trans-unit id="475c13751eb255f66e4aec9a66a81a56d379a598" translate="yes" xml:space="preserve">
          <source>Continue listing the history of a file beyond renames (works only for a single file).</source>
          <target state="translated">이름 변경을 넘어 파일 히스토리를 계속 나열하십시오 (단일 파일에만 작동).</target>
        </trans-unit>
        <trans-unit id="4798719de8c426782f7160e2b872b0281bb19c57" translate="yes" xml:space="preserve">
          <source>Continue the operation in progress using the information in &lt;code&gt;.git/sequencer&lt;/code&gt;. Can be used to continue after resolving conflicts in a failed cherry-pick or revert.</source>
          <target state="translated">&lt;code&gt;.git/sequencer&lt;/code&gt; 의 정보를 사용하여 진행중인 작업을 계속하십시오 . 실패한 체리 픽 또는 복귀에서 충돌을 해결 한 후 계속하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75e8c6f43c030fe85b04f600a5aefef84d4215ca" translate="yes" xml:space="preserve">
          <source>Continue the rebase with &lt;code&gt;git rebase --continue&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git rebase --continue&lt;/code&gt; 로 rebase를 계속하십시오 .</target>
        </trans-unit>
        <trans-unit id="fbb3e402bf66bc40e025c029cebd9e3786831d84" translate="yes" xml:space="preserve">
          <source>Continuing with our test-project, let&amp;rsquo;s modify file.txt again:</source>
          <target state="translated">테스트 프로젝트를 계속 진행하면서 file.txt를 다시 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="6f930d8a34d56a441268a0623f0c037df7494b75" translate="yes" xml:space="preserve">
          <source>Control GSSAPI credential delegation. The delegation is disabled by default in libcurl since version 7.21.7. Set parameter to tell the server what it is allowed to delegate when it comes to user credentials. Used with GSS/kerberos. Possible values are:</source>
          <target state="translated">GSSAPI 자격 증명 위임을 제어합니다. 위임은 버전 7.21.7 이후 libcurl에서 기본적으로 사용되지 않습니다. 사용자 신임 정보와 관련하여 서버에게 위임 할 수있는 것을 서버에 알리려면 매개 변수를 설정하십시오. GSS / kerberos와 함께 사용됩니다. 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="732c632643ca337cd77cc6d082dfc0d1c8e3c9e5" translate="yes" xml:space="preserve">
          <source>Control how information about the commits in the local repository is sent when negotiating the contents of the packfile to be sent by the server. Set to &quot;skipping&quot; to use an algorithm that skips commits in an effort to converge faster, but may result in a larger-than-necessary packfile; The default is &quot;default&quot; which instructs Git to use the default algorithm that never skips commits (unless the server has acknowledged it or one of its descendants). If &lt;code&gt;feature.experimental&lt;/code&gt; is enabled, then this setting defaults to &quot;skipping&quot;. Unknown values will cause &lt;code&gt;git fetch&lt;/code&gt; to error out.</source>
          <target state="translated">서버가 보낼 팩 파일의 내용을 협상 할 때 로컬 저장소의 커밋에 대한 정보를 보내는 방법을 제어하십시오. 더 빨리 수렴하기 위해 커밋을 건너 뛰지 만 필요한 팩 파일보다 큰 파일을 생성하는 알고리즘을 사용하려면 &quot;건너 뛰기&quot;로 설정하십시오. 기본값은 &quot;default&quot;이며, 서버가 커밋을 건너 뛰지 않는 기본 알고리즘을 사용하도록 Git에 지시합니다 (서버에서 해당 하위 항목 또는 하위 항목을 확인하지 않은 경우). 경우 &lt;code&gt;feature.experimental&lt;/code&gt; 은 &quot;건너 뛰기&quot;를,이 설정의 기본값을 사용할 수 있습니다. 알 수없는 값은 &lt;code&gt;git fetch&lt;/code&gt; 가 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="8ae71e6ee5d07ac322bf2300466d8fa2871661c2" translate="yes" xml:space="preserve">
          <source>Control how information about the commits in the local repository is sent when negotiating the contents of the packfile to be sent by the server. Set to &quot;skipping&quot; to use an algorithm that skips commits in an effort to converge faster, but may result in a larger-than-necessary packfile; or set to &quot;noop&quot; to not send any information at all, which will almost certainly result in a larger-than-necessary packfile, but will skip the negotiation step. The default is &quot;default&quot; which instructs Git to use the default algorithm that never skips commits (unless the server has acknowledged it or one of its descendants). If &lt;code&gt;feature.experimental&lt;/code&gt; is enabled, then this setting defaults to &quot;skipping&quot;. Unknown values will cause &lt;code&gt;git fetch&lt;/code&gt; to error out.</source>
          <target state="translated">서버에서 보낼 팩 파일의 내용을 협상 할 때 로컬 저장소의 커밋에 대한 정보를 보내는 방법을 제어합니다. 수렴 속도를 높이기 위해 커밋을 건너 뛰는 알고리즘을 사용하려면 &quot;skipping&quot;으로 설정하지만 필요한 것보다 더 큰 packfile이 생성 될 수 있습니다. 또는 정보를 전혀 보내지 않으려면 &quot;noop&quot;로 설정하면 거의 확실하게 필요한 것보다 큰 팩 파일이 생성되지만 협상 단계는 건너 뜁니다. 기본값은 &quot;default&quot;로 Git이 커밋을 건너 뛰지 않는 기본 알고리즘을 사용하도록 지시합니다 (서버가 커밋 또는 하위 항목 중 하나를 승인하지 않은 경우). 경우 &lt;code&gt;feature.experimental&lt;/code&gt; 은 &quot;건너 뛰기&quot;를,이 설정의 기본값을 사용할 수 있습니다. 알 수없는 값으로 인해 &lt;code&gt;git fetch&lt;/code&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aa2d757e789e92329feff3e9e393ffe1cf9826bc" translate="yes" xml:space="preserve">
          <source>Control how ref update status is printed. Valid values are &lt;code&gt;full&lt;/code&gt; and &lt;code&gt;compact&lt;/code&gt;. Default value is &lt;code&gt;full&lt;/code&gt;. See section OUTPUT in &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; for detail.</source>
          <target state="translated">심판 업데이트 상태 인쇄 방법을 제어합니다. 유효한 값은 &lt;code&gt;full&lt;/code&gt; 하고 &lt;code&gt;compact&lt;/code&gt; 합니다. 기본값은 &lt;code&gt;full&lt;/code&gt; 입니다. 자세한 내용은 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]의&lt;/a&gt; OUTPUT 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e05cd92bb18e6dbe129763361ebf98f054218bc" translate="yes" xml:space="preserve">
          <source>Control the order in which files appear in the output. This overrides the &lt;code&gt;diff.orderFile&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). To cancel &lt;code&gt;diff.orderFile&lt;/code&gt;, use &lt;code&gt;-O/dev/null&lt;/code&gt;.</source>
          <target state="translated">출력에 파일이 나타나는 순서를 제어하십시오. 이것은 &lt;code&gt;diff.orderFile&lt;/code&gt; 구성 변수를 대체합니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ). 취소하려면 &lt;code&gt;diff.orderFile&lt;/code&gt; 사용 &lt;code&gt;-O/dev/null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95cfa5bd9ed3c9eff692bd91fe02de0af906819b" translate="yes" xml:space="preserve">
          <source>Controlling access to Git repositories</source>
          <target state="translated">Git 리포지토리에 대한 액세스 제어</target>
        </trans-unit>
        <trans-unit id="302680d7e637a6c4d28c5bc8380af3a8487a3fd0" translate="yes" xml:space="preserve">
          <source>Controlling the daemon</source>
          <target state="translated">데몬 제어</target>
        </trans-unit>
        <trans-unit id="5f8b43605d2bc36ca036762a54d85472bbaf393e" translate="yes" xml:space="preserve">
          <source>Controls addition of &lt;code&gt;In-Reply-To&lt;/code&gt; and &lt;code&gt;References&lt;/code&gt; headers to make the second and subsequent mails appear as replies to the first. Also controls generation of the &lt;code&gt;Message-Id&lt;/code&gt; header to reference.</source>
          <target state="translated">&lt;code&gt;In-Reply-To&lt;/code&gt; 및 &lt;code&gt;References&lt;/code&gt; 헤더 추가를 제어 하여 두 번째 및 후속 메일이 첫 번째 메일에 대한 회신으로 표시되도록합니다. 참조 할 &lt;code&gt;Message-Id&lt;/code&gt; 헤더 의 생성도 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="2d73e883baf4d5a02fe3808167b349dacd41e248" translate="yes" xml:space="preserve">
          <source>Controls the amount of output shown by the recursive merge strategy. Level 0 outputs nothing except a final error message if conflicts were detected. Level 1 outputs only conflicts, 2 outputs conflicts and file changes. Level 5 and above outputs debugging information. The default is level 2. Can be overridden by the &lt;code&gt;GIT_MERGE_VERBOSITY&lt;/code&gt; environment variable.</source>
          <target state="translated">재귀 병합 전략으로 표시되는 출력량을 제어합니다. 충돌이 감지되면 레벨 0은 최종 오류 메시지를 제외하고 아무것도 출력하지 않습니다. 레벨 1은 충돌 만, 2는 충돌 및 파일 변경을 출력합니다. 레벨 5 이상은 디버깅 정보를 출력합니다. 기본값은 2 입니다. &lt;code&gt;GIT_MERGE_VERBOSITY&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d76ea066512503130cc69199cf2d62634818fae1" translate="yes" xml:space="preserve">
          <source>Controls whether one-level refnames are accepted (i.e., refnames that do not contain multiple &lt;code&gt;/&lt;/code&gt;-separated components). The default is &lt;code&gt;--no-allow-onelevel&lt;/code&gt;.</source>
          <target state="translated">한 수준의 참조 이름을 허용할지 여부를 제어합니다 (즉, 여러 개의 &lt;code&gt;/&lt;/code&gt; 로 분리 된 구성 요소를 포함하지 않는 참조 이름). 기본값은 &lt;code&gt;--no-allow-onelevel&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="65d9a75f19717f80d02990ede6313f9c8dc92c2a" translate="yes" xml:space="preserve">
          <source>Controls which diff tool is used by &lt;a href=&quot;git-difftool&quot;&gt;git-difftool[1]&lt;/a&gt; when the -g/--gui flag is specified. This variable overrides the value configured in &lt;code&gt;merge.guitool&lt;/code&gt;. The list below shows the valid built-in values. Any other value is treated as a custom diff tool and requires that a corresponding difftool.&amp;lt;guitool&amp;gt;.cmd variable is defined.</source>
          <target state="translated">-g /-gui 플래그가 지정 될 때 &lt;a href=&quot;git-difftool&quot;&gt;git-difftool [1]에서&lt;/a&gt; 사용할 diff 도구를 제어 합니다. 이 변수는 &lt;code&gt;merge.guitool&lt;/code&gt; 에 구성된 값을 대체합니다 . 아래 목록은 유효한 내장 값을 보여줍니다. 다른 값은 사용자 정의 diff 도구로 취급되며 해당 difftool. &amp;lt;guitool&amp;gt; .cmd 변수가 정의되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="866c417f86e708b803c2ccd6543f9e30d5664def" translate="yes" xml:space="preserve">
          <source>Controls which diff tool is used by &lt;a href=&quot;git-difftool&quot;&gt;git-difftool[1]&lt;/a&gt;. This variable overrides the value configured in &lt;code&gt;merge.tool&lt;/code&gt;. The list below shows the valid built-in values. Any other value is treated as a custom diff tool and requires that a corresponding difftool.&amp;lt;tool&amp;gt;.cmd variable is defined.</source>
          <target state="translated">&lt;a href=&quot;git-difftool&quot;&gt;git-difftool [1]&lt;/a&gt; 이 사용하는 diff 도구를 제어 합니다. 이 변수는 &lt;code&gt;merge.tool&lt;/code&gt; 에 구성된 값을 대체합니다 . 아래 목록은 유효한 내장 값을 보여줍니다. 다른 값은 사용자 정의 diff 도구로 취급되며 해당 difftool. &amp;lt;tool&amp;gt; .cmd 변수가 정의되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5cb013e070a3b4cddc50474dc321b1da7ea13759" translate="yes" xml:space="preserve">
          <source>Controls which merge tool is used by &lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool[1]&lt;/a&gt; when the -g/--gui flag is specified. The list below shows the valid built-in values. Any other value is treated as a custom merge tool and requires that a corresponding mergetool.&amp;lt;guitool&amp;gt;.cmd variable is defined.</source>
          <target state="translated">-g /-gui 플래그가 지정 될 때 &lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool [1]&lt;/a&gt; 이 사용할 병합 도구를 제어 합니다. 아래 목록은 유효한 내장 값을 보여줍니다. 다른 값은 사용자 정의 병합 도구로 취급되며 해당 mergetool. &amp;lt;guitool&amp;gt; .cmd 변수가 정의되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="18ee15c4e31cbcbd84b87172e325dafb065adff0" translate="yes" xml:space="preserve">
          <source>Controls which merge tool is used by &lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool[1]&lt;/a&gt;. The list below shows the valid built-in values. Any other value is treated as a custom merge tool and requires that a corresponding mergetool.&amp;lt;tool&amp;gt;.cmd variable is defined.</source>
          <target state="translated">&lt;a href=&quot;git-mergetool&quot;&gt;git-mergetool [1]&lt;/a&gt; 이 사용하는 병합 도구를 제어 합니다. 아래 목록은 유효한 내장 값을 보여줍니다. 다른 값은 사용자 정의 병합 도구로 취급되며 해당 mergetool. &amp;lt;tool&amp;gt; .cmd 변수가 정의되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="474792f82dd9247329dbb1b3dcfbbed1c865f4c2" translate="yes" xml:space="preserve">
          <source>Controls which parts of the cover letter will be automatically populated using the branch&amp;rsquo;s description.</source>
          <target state="translated">분기의 설명을 사용하여 표지의 어떤 부분을 자동으로 채울지 제어합니다.</target>
        </trans-unit>
        <trans-unit id="c3102343a37aa52f6a069dc8bc5f12c9420d06d2" translate="yes" xml:space="preserve">
          <source>Conventions for public functions and macros</source>
          <target state="translated">공공 기능 및 매크로에 대한 규칙</target>
        </trans-unit>
        <trans-unit id="24ce25558484789421068a0f3fdf9552add6eb44" translate="yes" xml:space="preserve">
          <source>Conversely, text files that Git does not detect can have normalization enabled manually.</source>
          <target state="translated">반대로 Git이 감지하지 못하는 텍스트 파일은 정규화를 수동으로 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e49f6aaa8529aed7e4294b528b8e93971284c07e" translate="yes" xml:space="preserve">
          <source>Convert raw file data into a blob, for future use in a &lt;code&gt;commit&lt;/code&gt; command. This command is optional and is not needed to perform an import.</source>
          <target state="translated">나중에 &lt;code&gt;commit&lt;/code&gt; 명령 에서 사용할 수 있도록 원시 파일 데이터를 Blob으로 변환 이 명령은 선택 사항이며 가져 오기를 수행하는 데 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="93865ee1f19358443956a81b8175d73f301958b3" translate="yes" xml:space="preserve">
          <source>Convert token &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; in the anonymized output. If &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; is omitted, map &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; to itself (i.e., do not anonymize it). See the section on &lt;code&gt;ANONYMIZING&lt;/code&gt; below.</source>
          <target state="translated">익명화 된 출력에서 &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; 토큰 을 &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; 로 변환합니다. 경우 &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; 생략,지도 &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; 자체 (예를 익명화하지 않음)에. 아래의 &lt;code&gt;ANONYMIZING&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="30c15e3645b0a2e6438456f892ca0f7bb2ab425e" translate="yes" xml:space="preserve">
          <source>Convert underscores in tag and branch names to dots.</source>
          <target state="translated">태그 및 분기 이름의 밑줄을 점으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="717ec262f5a03d7fab61894de5327ed8b2dce9d6" translate="yes" xml:space="preserve">
          <source>Copy a branch and the corresponding reflog.</source>
          <target state="translated">분기와 해당 참조 로그를 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="d010ed84eae444d5db43ea15cd0c22cd88feae0f" translate="yes" xml:space="preserve">
          <source>Copy files from the index to the working tree</source>
          <target state="translated">색인에서 작업 트리로 파일 복사</target>
        </trans-unit>
        <trans-unit id="c76ee4ad9dd156a08ecfefcfcb1c22de051a4c57" translate="yes" xml:space="preserve">
          <source>Copy over the packed files from &quot;project lead&quot; public repository to your public repository, unless the &quot;project lead&quot; repository lives on the same machine as yours. In the latter case, you can use &lt;code&gt;objects/info/alternates&lt;/code&gt; file to point at the repository you are borrowing from.</source>
          <target state="translated">&quot;프로젝트 리드&quot;저장소가 사용자와 동일한 시스템에 있지 않으면 &quot;프로젝트 리드&quot;공용 저장소에서 공용 저장소로 압축 파일을 복사하십시오. 후자의 경우 &lt;code&gt;objects/info/alternates&lt;/code&gt; 파일을 사용하여 빌린 저장소를 가리킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8b3dca28c0ddf8873f77c43f29755622d908cce" translate="yes" xml:space="preserve">
          <source>Copy the Message-ID header at the end of the commit message. This is useful in order to associate commits with mailing list discussions.</source>
          <target state="translated">커밋 메시지의 끝에 Message-ID 헤더를 복사하십시오. 커밋을 메일 링리스트 토론과 연관시키는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5a3f70a82898c2a8456ad61672927bc441665238" translate="yes" xml:space="preserve">
          <source>Copy the modified files to a temporary location and perform a directory diff on them. This mode never prompts before launching the diff tool.</source>
          <target state="translated">수정 된 파일을 임시 위치에 복사하고 디렉토리 차이를 수행하십시오. 이 모드는 diff 도구를 시작하기 전에 묻지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c190e9af114c74dc1cae547f652783f706162e52" translate="yes" xml:space="preserve">
          <source>Copy the notes for the first object onto the second object (defaults to HEAD). Abort if the second object already has notes, or if the first object has none (use -f to overwrite existing notes to the second object). This subcommand is equivalent to: &lt;code&gt;git notes add [-f] -C $(git notes list &amp;lt;from-object&amp;gt;) &amp;lt;to-object&amp;gt;&lt;/code&gt;</source>
          <target state="translated">첫 번째 오브젝트의 메모를 두 번째 오브젝트에 복사하십시오 (기본값은 HEAD). 두 번째 개체에 이미 메모가 있거나 첫 번째 개체에 메모가 없으면 중단합니다 (기존 메모를 두 번째 개체에 덮어 쓰려면 -f를 사용하십시오). 이 부속 명령은 다음과 같습니다. &lt;code&gt;git notes add [-f] -C $(git notes list &amp;lt;from-object&amp;gt;) &amp;lt;to-object&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f67d1ba5e94aaa446c4cd38a50c12bd9c63d60dc" translate="yes" xml:space="preserve">
          <source>Copying repositories</source>
          <target state="translated">리포지토리 복사</target>
        </trans-unit>
        <trans-unit id="36e54cbb8f2eeebb702575f30e1a34b2297f308c" translate="yes" xml:space="preserve">
          <source>Core git executable to use. By default set to &lt;code&gt;$GIT_BINDIR/git&lt;/code&gt;, which in turn is by default set to &lt;code&gt;$(bindir)/git&lt;/code&gt;. If you use Git installed from a binary package, you should usually set this to &quot;/usr/bin/git&quot;. This can just be &quot;git&quot; if your web server has a sensible PATH; from security point of view it is better to use absolute path to git binary. If you have multiple Git versions installed it can be used to choose which one to use. Must be (correctly) set for gitweb to be able to work.</source>
          <target state="translated">사용할 핵심 git 실행 파일. 기본적으로 &lt;code&gt;$GIT_BINDIR/git&lt;/code&gt; 으로 설정되며, 기본적으로 &lt;code&gt;$(bindir)/git&lt;/code&gt; 으로 설정됩니다 . 바이너리 꾸러미에서 설치된 Git을 사용한다면, 보통 &quot;/ usr / bin / git&quot;로 설정해야합니다. 웹 서버에 적절한 PATH가있는 경우 &quot;git&quot;일 수 있습니다. 보안 관점에서 git binary의 절대 경로를 사용하는 것이 좋습니다. 여러 개의 Git 버전이 설치되어 있으면 사용할 버전을 선택할 수 있습니다. gitweb이 작동하려면 (올바르게) 설정되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="85a8806cd8d64571a9c2262e310bf038f08a1274" translate="yes" xml:space="preserve">
          <source>Count changes in a child directory for the parent directory as well. Note that when using &lt;code&gt;cumulative&lt;/code&gt;, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the &lt;code&gt;noncumulative&lt;/code&gt; parameter.</source>
          <target state="translated">부모 디렉터리에 대한 자식 디렉터리의 변경 사항도 계산합니다. &lt;code&gt;cumulative&lt;/code&gt; 를 사용할 때보 고 된 백분율의 합계가 100 %를 초과 할 수 있습니다. 기본 ( &lt;code&gt;noncumulative&lt;/code&gt; ) 동작은 비누 적 매개 변수 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="492f2e2be05a1aa8d8af437be99e7dacb8d4f9d0" translate="yes" xml:space="preserve">
          <source>Count unpacked number of objects and their disk consumption</source>
          <target state="translated">압축을 푼 개체 수와 디스크 소비량 계산</target>
        </trans-unit>
        <trans-unit id="763b234fba543bb2523cf09d67150c10446b45b7" translate="yes" xml:space="preserve">
          <source>Countermand &lt;code&gt;commit.gpgSign&lt;/code&gt; configuration variable that is set to force each and every commit to be signed.</source>
          <target state="translated">Countermand &lt;code&gt;commit.gpgSign&lt;/code&gt; 구성 변수는 각각의 모든 커밋이 강제로 서명되도록 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6096cddc00ec928df60a796e3d4cfb0bb68acdbe" translate="yes" xml:space="preserve">
          <source>Counting the number of commits on a branch</source>
          <target state="translated">지점의 커밋 수 계산</target>
        </trans-unit>
        <trans-unit id="5c28a68396ec48f8ddfeca624f27118d20e2f2ea" translate="yes" xml:space="preserve">
          <source>Crash reports</source>
          <target state="translated">충돌 보고서</target>
        </trans-unit>
        <trans-unit id="97b6cc167e6a90cd26177184d37208b481756eef" translate="yes" xml:space="preserve">
          <source>Create &amp;lt;ref&amp;gt; with &amp;lt;newvalue&amp;gt; after verifying it does not exist. The given &amp;lt;newvalue&amp;gt; may not be zero.</source>
          <target state="translated">존재하지 않는지 확인한 후 &amp;lt;newvalue&amp;gt;로 &amp;lt;ref&amp;gt;를 작성하십시오. 주어진 &amp;lt;newvalue&amp;gt;는 0이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="821a77e6f90a06fed7c0ea5afb5c7aa03a8e4a48" translate="yes" xml:space="preserve">
          <source>Create &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; and checkout &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; into it. The new working directory is linked to the current repository, sharing everything except working directory specific files such as &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt;, etc. As a convenience, &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; may be a bare &quot;&lt;code&gt;-&lt;/code&gt;&quot;, which is synonymous with &lt;code&gt;@{-1}&lt;/code&gt;.</source>
          <target state="translated">만들기 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 체크 아웃을 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 그것으로. 새 작업 디렉토리는 현재 저장소에 연결되어 &lt;code&gt;HEAD&lt;/code&gt; , &lt;code&gt;index&lt;/code&gt; 등과 같은 작업 디렉토리 특정 파일을 제외한 모든 것을 공유 합니다. 편의상 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 는 &lt;code&gt;@{-1}&lt;/code&gt; 와 동의어 인 베어 &quot; &lt;code&gt;-&lt;/code&gt; &quot;일 수 있습니다. 1} .</target>
        </trans-unit>
        <trans-unit id="5d3e6679c48a19f8a3804fc16c43252c9d4a1106" translate="yes" xml:space="preserve">
          <source>Create &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; and checkout &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; into it. The new working directory is linked to the current repository, sharing everything except working directory specific files such as HEAD, index, etc. &lt;code&gt;-&lt;/code&gt; may also be specified as &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;; it is synonymous with &lt;code&gt;@{-1}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 를 작성 하고 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 를 체크 아웃 하십시오. 새로운 작업 디렉토리는 등 HEAD, 인덱스 등의 디렉토리의 특정 파일을 작업 제외한 모든 공유, 현재 저장소에 연결되어 &lt;code&gt;-&lt;/code&gt; 로도 지정 될 수있다 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; ; &lt;code&gt;@{-1}&lt;/code&gt; 과 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="918c3c2a066586184896c329601a42f88338b5c6" translate="yes" xml:space="preserve">
          <source>Create a &quot;thin&quot; pack by omitting the common objects between a sender and a receiver in order to reduce network transfer. This option only makes sense in conjunction with --stdout.</source>
          <target state="translated">네트워크 전송을 줄이려면 발신자와 수신자간에 공통 개체를 생략하여 &quot;씬&quot;팩을 만드십시오. 이 옵션은 --stdout과 함께 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec9cb277fe09464e753dba1a9c058b6a9566ff6f" translate="yes" xml:space="preserve">
          <source>Create a /path/to/my/codebase/.git directory.</source>
          <target state="translated">/path/to/my/codebase/.git 디렉토리를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c0a6d61d3fd0fcaf6c684be3f4ae17d7a1fadcb9" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;shallow&lt;/code&gt; clone with a history truncated to the specified number of commits. Implies &lt;code&gt;--single-branch&lt;/code&gt; unless &lt;code&gt;--no-single-branch&lt;/code&gt; is given to fetch the histories near the tips of all branches. If you want to clone submodules shallowly, also pass &lt;code&gt;--shallow-submodules&lt;/code&gt;.</source>
          <target state="translated">지정된 커밋 수만큼 잘라낸 기록을 사용 하여 &lt;code&gt;shallow&lt;/code&gt; 복제본을 만듭니다 . &lt;code&gt;--no-single-branch&lt;/code&gt; 가 모든 브랜치의 팁 근처에서 히스토리를 가져 오기 위해 제공 되지 않는 한 &lt;code&gt;--single-branch&lt;/code&gt; 를 의미 합니다. 하위 모듈을 얕게 복제하려면 &lt;code&gt;--shallow-submodules&lt;/code&gt; 도 전달 하십시오 .</target>
        </trans-unit>
        <trans-unit id="efb2e81b939b9a77d43ecb93b07dc1f2ed7276af" translate="yes" xml:space="preserve">
          <source>Create a Zip archive that contains the contents of the latest commit on the current branch. Note that the output format is inferred by the extension of the output file.</source>
          <target state="translated">현재 브랜치에서 최신 커밋 내용을 포함하는 Zip 아카이브를 만듭니다. 출력 형식은 출력 파일의 확장자로 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="98ed6a63ab53ebc7b5cb53eddb5b05ee6e17c097" translate="yes" xml:space="preserve">
          <source>Create a bare repository to publish your changes to the public:</source>
          <target state="translated">변경 사항을 공개적으로 공개 할 Bare 저장소를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="8ecd6ae5a1546c899c5e4d339f3b41e08bfa5878" translate="yes" xml:space="preserve">
          <source>Create a bare repository. If &lt;code&gt;GIT_DIR&lt;/code&gt; environment is not set, it is set to the current working directory.</source>
          <target state="translated">Bare 저장소를 작성하십시오. &lt;code&gt;GIT_DIR&lt;/code&gt; 환경이 설정되지 않은 경우 현재 작업 디렉토리로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8d2657b83c3c9eabb4154adbe14301af394e1de8" translate="yes" xml:space="preserve">
          <source>Create a branch in the SVN repository.</source>
          <target state="translated">SVN 저장소에 분기를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="9535ca3b3bba3d55a9a78d2e5a327a9df5b9b7ac" translate="yes" xml:space="preserve">
          <source>Create a compressed tarball for v1.4.0 release, but without a global extended pax header.</source>
          <target state="translated">v1.4.0 릴리스의 압축 된 tarball을 작성하지만 글로벌 확장 pax 헤더는 없습니다.</target>
        </trans-unit>
        <trans-unit id="b5319dfc6eb9dc4a079ba2789cc4bdb586f57276" translate="yes" xml:space="preserve">
          <source>Create a compressed tarball for v1.4.0 release.</source>
          <target state="translated">v1.4.0 릴리스의 압축 된 tarball을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="faa66e3a606f56a97105d3be717d6c143b22dab2" translate="yes" xml:space="preserve">
          <source>Create a graft commit. A new commit is created with the same content as &amp;lt;commit&amp;gt; except that its parents will be [&amp;lt;parent&amp;gt;&amp;hellip;​] instead of &amp;lt;commit&amp;gt;'s parents. A replacement ref is then created to replace &amp;lt;commit&amp;gt; with the newly created commit. Use &lt;code&gt;--convert-graft-file&lt;/code&gt; to convert a &lt;code&gt;$GIT_DIR/info/grafts&lt;/code&gt; file and use replace refs instead.</source>
          <target state="translated">이식 커밋을 만듭니다. 부모가 &amp;lt;commit&amp;gt;의 부모 대신 [&amp;lt;parent&amp;gt;&amp;hellip;]가된다는 점을 제외하고는 &amp;lt;commit&amp;gt;과 동일한 내용으로 새 커밋이 만들어집니다. 그런 다음 &amp;lt;commit&amp;gt;을 새로 작성된 커밋으로 대체하기위한 대체 참조가 작성됩니다. &lt;code&gt;--convert-graft-file&lt;/code&gt; 을 사용 하여 &lt;code&gt;$GIT_DIR/info/grafts&lt;/code&gt; 파일 을 변환하고 replace refs를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="571580d25d73e20010dd7b861b6579499c2d2548" translate="yes" xml:space="preserve">
          <source>Create a new &lt;code&gt;orphan&lt;/code&gt; branch, named &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt;. All tracked files are removed.</source>
          <target state="translated">&lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 라는 새 &lt;code&gt;orphan&lt;/code&gt; 브랜치를 만듭니다 . 추적 된 모든 파일이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="4e15c57fd9f8556efdaf616337a8d6e6219013e8" translate="yes" xml:space="preserve">
          <source>Create a new &lt;code&gt;orphan&lt;/code&gt; branch, named &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt;, started from &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; and switch to it. The first commit made on this new branch will have no parents and it will be the root of a new history totally disconnected from all the other branches and commits.</source>
          <target state="translated">&lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; 에서 시작하여 &amp;lt; &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; 라는 새 &lt;code&gt;orphan&lt;/code&gt; 브랜치를 작성 하고 전환하십시오. 이 새로운 브랜치에서 첫 커밋은 부모가 없으며 다른 모든 브랜치와 커밋에서 완전히 분리 된 새로운 역사의 근원이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="74397bf89a3d7366727db29fa6dec88cf03174e1" translate="yes" xml:space="preserve">
          <source>Create a new Git repository from an existing p4 repository using &lt;code&gt;git p4 clone&lt;/code&gt;, giving it one or more p4 depot paths. Incorporate new commits from p4 changes with &lt;code&gt;git p4 sync&lt;/code&gt;. The &lt;code&gt;sync&lt;/code&gt; command is also used to include new branches from other p4 depot paths. Submit Git changes back to p4 using &lt;code&gt;git p4 submit&lt;/code&gt;. The command &lt;code&gt;git p4 rebase&lt;/code&gt; does a sync plus rebases the current branch onto the updated p4 remote branch.</source>
          <target state="translated">&lt;code&gt;git p4 clone&lt;/code&gt; 을 사용하여 기존 p4 저장소에서 새 Git 저장소를 작성하여 하나 이상의 p4 저장소 경로를 제공하십시오. &lt;code&gt;git p4 sync&lt;/code&gt; 로 p4 변경 사항에서 새로운 커밋을 통합하십시오 . &lt;code&gt;sync&lt;/code&gt; 명령은 다른 P4 저장소 경로에서 새로운 가지를 포함하는 데 사용됩니다. &lt;code&gt;git p4 submit&lt;/code&gt; 을 사용하여 Git 변경 사항을 p4로 다시 제출하십시오 . &lt;code&gt;git p4 rebase&lt;/code&gt; 명령 은 동기화를 수행하고 현재 분기를 업데이트 된 p4 원격 분기로 리베이스 합니다.</target>
        </trans-unit>
        <trans-unit id="32283e2eb1bd521d20f1290e2eaa64ee550622d7" translate="yes" xml:space="preserve">
          <source>Create a new branch head pointing to one of these versions and check it out using &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt;:</source>
          <target state="translated">이 버전 중 하나를 가리키는 새 분기 헤드를 만들고 &lt;a href=&quot;git-switch&quot;&gt;git-switch [1]을&lt;/a&gt; 사용하여 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="4de51286c04f5ea0c9795b4b604e6322cb3596eb" translate="yes" xml:space="preserve">
          <source>Create a new branch named &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; starting at &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; before switching to the branch. This is a convenient shortcut for:</source>
          <target state="translated">분기로 전환하기 전에 &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; 에서 시작하여 이름이 &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 인 새 분기를 만듭니다 . 다음과 같은 편리한 단축키입니다.</target>
        </trans-unit>
        <trans-unit id="adb753b3b1e8742e8dfb04c8a3bbb9df0384a74c" translate="yes" xml:space="preserve">
          <source>Create a new branch named &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; and start it at &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt;; see &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; 라는 새 분기를 작성하고 &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; 에서 시작하십시오 . 자세한 내용은 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f67db00a28beeae8e81324408bce6703c7ea6026" translate="yes" xml:space="preserve">
          <source>Create a new commit containing the current contents of the index and the given log message describing the changes. The new commit is a direct child of HEAD, usually the tip of the current branch, and the branch is updated to point to it (unless no branch is associated with the working tree, in which case HEAD is &quot;detached&quot; as described in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;).</source>
          <target state="translated">색인의 현재 내용과 변경 사항을 설명하는 주어진 로그 메시지를 포함하는 새 커미트를 작성하십시오. 새로운 커밋은 HEAD의 직접적인 자식이며, 일반적으로 현재 브랜치의 끝이며, 브랜치는 지점을 가리 키도록 업데이트됩니다 (지점이 작업 트리와 연관되어 있지 않은 경우, &lt;a href=&quot;git-checkout&quot;&gt;git에&lt;/a&gt; 설명 된대로 HEAD가 &quot;분리&quot;됨) -checkout [1] ).</target>
        </trans-unit>
        <trans-unit id="775d2ff1f35d4b43a574ee93495db02f2d8cbc5e" translate="yes" xml:space="preserve">
          <source>Create a new commit object</source>
          <target state="translated">새로운 커밋 객체 생성</target>
        </trans-unit>
        <trans-unit id="ed82c0a774a3c01694b195d2170f6d11389fd2c2" translate="yes" xml:space="preserve">
          <source>Create a new location. See the notes below for details on how to choose the right protocol.</source>
          <target state="translated">새로운 위치를 만듭니다. 올바른 프로토콜을 선택하는 방법에 대한 자세한 내용은 아래 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6b44ae75f523438b3f2cff76c3ac2f27de583720" translate="yes" xml:space="preserve">
          <source>Create a new pack-file containing objects in small pack-files referenced by the multi-pack-index. If the size given by the &lt;code&gt;--batch-size=&amp;lt;size&amp;gt;&lt;/code&gt; argument is zero, then create a pack containing all objects referenced by the multi-pack-index. For a non-zero batch size, Select the pack-files by examining packs from oldest-to-newest, computing the &quot;expected size&quot; by counting the number of objects in the pack referenced by the multi-pack-index, then divide by the total number of objects in the pack and multiply by the pack size. We select packs with expected size below the batch size until the set of packs have total expected size at least the batch size, or all pack-files are considered. If only one pack-file is selected, then do nothing. If a new pack-file is created, rewrite the multi-pack-index to reference the new pack-file. A later run of &lt;code&gt;git multi-pack-index expire&lt;/code&gt; will delete the pack-files that were part of this batch.</source>
          <target state="translated">멀티 팩 인덱스가 참조하는 작은 팩 파일의 객체를 포함하는 새 팩 파일을 만듭니다. &lt;code&gt;--batch-size=&amp;lt;size&amp;gt;&lt;/code&gt; 로 주어진 크기인수가 0이면 멀티 팩 인덱스가 참조하는 모든 객체를 포함하는 팩을 만듭니다. 0이 아닌 배치 크기의 경우 가장 오래된 것부터 최신 순서까지의 팩을 검사하여 팩 파일을 선택하고 멀티 팩 인덱스가 참조하는 팩의 개체 수를 계산하여 &quot;예상 크기&quot;를 계산 한 다음 다음으로 나눕니다. 팩의 총 개체 수에 팩 크기를 곱합니다. 팩 세트가 적어도 배치 크기 이상의 총 예상 크기를 갖거나 모든 팩 파일이 고려 될 때까지 예상 크기가 배치 크기보다 작은 팩을 선택합니다. 하나의 팩 파일 만 선택한 경우 아무 작업도 수행하지 않습니다. 새 팩 파일이 생성되면 새 팩 파일을 참조하도록 멀티 팩 인덱스를 다시 작성합니다. 나중에 &lt;code&gt;git multi-pack-index expire&lt;/code&gt; 를 실행 하면이 배치의 일부였던 팩 파일이 삭제 됩니다 .</target>
        </trans-unit>
        <trans-unit id="8524608a0d692976af91ac05836567c4a22e40c7" translate="yes" xml:space="preserve">
          <source>Create a new pack-file containing objects in small pack-files referenced by the multi-pack-index. If the size given by the &lt;code&gt;--batch-size=&amp;lt;size&amp;gt;&lt;/code&gt; argument is zero, then create a pack containing all objects referenced by the multi-pack-index. For a non-zero batch size, Select the pack-files by examining packs from oldest-to-newest, computing the &quot;expected size&quot; by counting the number of objects in the pack referenced by the multi-pack-index, then divide by the total number of objects in the pack and multiply by the pack size. We select packs with expected size below the batch size until the set of packs have total expected size at least the batch size. If the total size does not reach the batch size, then do nothing. If a new pack- file is created, rewrite the multi-pack-index to reference the new pack-file. A later run of &lt;code&gt;git multi-pack-index expire&lt;/code&gt; will delete the pack-files that were part of this batch.</source>
          <target state="translated">다중 팩 색인이 참조하는 작은 팩 파일의 오브젝트를 포함하는 새 팩 파일을 작성하십시오. &lt;code&gt;--batch-size=&amp;lt;size&amp;gt;&lt;/code&gt; 에 의해 주어진 크기가argument가 0이면 multi-pack-index가 참조하는 모든 객체를 포함하는 팩을 만듭니다. 0이 아닌 배치 크기의 경우 가장 오래된 것부터 가장 작은 것까지 팩을 검사하여 팩 파일을 선택하고 멀티 팩 인덱스가 참조하는 팩의 객체 수를 세어 &quot;예상 크기&quot;를 계산 한 다음 팩의 총 객체 수와 팩 크기를 곱합니다. 팩 세트의 총 예상 크기가 최소 배치 크기가 될 때까지 배치 크기 아래의 예상 크기를 가진 팩을 선택합니다. 총 크기가 배치 크기에 도달하지 않으면 아무것도하지 마십시오. 새 팩 파일이 작성되면 새 팩 파일을 참조하도록 다중 팩 색인을 다시 작성하십시오. 나중에 &lt;code&gt;git multi-pack-index expire&lt;/code&gt; 를 실행 하면이 배치의 일부인 팩 파일이 삭제 됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c41169f0fcbee00370950fd445a3c201d3fc72d" translate="yes" xml:space="preserve">
          <source>Create a packed archive of objects</source>
          <target state="translated">압축 된 객체 아카이브 생성</target>
        </trans-unit>
        <trans-unit id="aeccdf3a7f8e818b38876ba10e91ea37e1459401" translate="yes" xml:space="preserve">
          <source>Create a placeholder file in the local Git repository for each empty directory fetched from Subversion. This includes directories that become empty by removing all entries in the Subversion repository (but not the directory itself). The placeholder files are also tracked and removed when no longer necessary.</source>
          <target state="translated">Subversion에서 가져온 빈 디렉토리마다 로컬 Git 저장소에 플레이스 홀더 파일을 작성하십시오. 여기에는 Subversion 저장소의 모든 항목을 제거하여 비어있는 디렉토리가 포함됩니다 (디렉토리 자체는 아님). 자리 표시 자 파일도 더 이상 필요하지 않은 경우 추적 및 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b0b2f30f73f128bf11ff805dcea18e4929006e9b" translate="yes" xml:space="preserve">
          <source>Create a reflog for the tag. To globally enable reflogs for tags, see &lt;code&gt;core.logAllRefUpdates&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;. The negated form &lt;code&gt;--no-create-reflog&lt;/code&gt; only overrides an earlier &lt;code&gt;--create-reflog&lt;/code&gt;, but currently does not negate the setting of &lt;code&gt;core.logAllRefUpdates&lt;/code&gt;.</source>
          <target state="translated">태그에 대한 Reflog를 작성하십시오. 태그에 대해 reflog를 전체적으로 활성화하려면 &lt;a href=&quot;git-config&quot;&gt;git-config [1]의 &lt;/a&gt; &lt;code&gt;core.logAllRefUpdates&lt;/code&gt; 를 참조하십시오 . 부정 된 양식 인 &lt;code&gt;--no-create-reflog&lt;/code&gt; 는 이전의 &lt;code&gt;--create-reflog&lt;/code&gt; -reflog 만 무시 하지만 현재 &lt;code&gt;core.logAllRefUpdates&lt;/code&gt; 의 설정은 무효화하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1c95e8dd01a1c19533d3be2260c095f09f00ed3d" translate="yes" xml:space="preserve">
          <source>Create a shallow clone with a history after the specified time.</source>
          <target state="translated">지정된 시간 이후에 내역이있는 얕은 클론을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="81a994e450296531fc46153834310318c564b7aa" translate="yes" xml:space="preserve">
          <source>Create a shallow clone with a history, excluding commits reachable from a specified remote branch or tag. This option can be specified multiple times.</source>
          <target state="translated">지정된 원격 브랜치 또는 태그에서 도달 할 수있는 커밋을 제외하고 기록이있는 단순 복제본을 만듭니다. 이 옵션은 여러 번 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="543a21269e742ae7ebc9058bf397ba34f632562d" translate="yes" xml:space="preserve">
          <source>Create a stash entry (which is a regular commit object) and return its object name, without storing it anywhere in the ref namespace. This is intended to be useful for scripts. It is probably not the command you want to use; see &quot;push&quot; above.</source>
          <target state="translated">일반 커밋 객체 인 숨김 항목을 만들고 ref 네임 스페이스의 아무 곳에도 저장하지 않고 객체 이름을 반환합니다. 스크립트에 유용합니다. 사용하려는 명령이 아닐 수도 있습니다. 위의 &quot;푸시&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b36a0ee3d907a9108a54a206fff8047195a2242d" translate="yes" xml:space="preserve">
          <source>Create a tag by using the tags_subdir instead of the branches_subdir specified during git svn init.</source>
          <target state="translated">git svn init 중에 지정된 branches_subdir 대신 tags_subdir을 사용하여 태그를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="d1e89b6bf885576f5776e13a6adbdccbb0c64b51" translate="yes" xml:space="preserve">
          <source>Create a tag in the SVN repository. This is a shorthand for &lt;code&gt;branch -t&lt;/code&gt;.</source>
          <target state="translated">SVN 저장소에 태그를 작성하십시오. 이것은 &lt;code&gt;branch -t&lt;/code&gt; 의 속기입니다 .</target>
        </trans-unit>
        <trans-unit id="f83eaaff0df7b915922dc3a5427d0b2485d874b0" translate="yes" xml:space="preserve">
          <source>Create a tar archive that contains the contents of the latest commit on the current branch, and extract it in the &lt;code&gt;/var/tmp/junk&lt;/code&gt; directory.</source>
          <target state="translated">현재 분기에서 최신 커밋의 내용이 포함 된 tar 아카이브를 작성하고 &lt;code&gt;/var/tmp/junk&lt;/code&gt; 디렉토리 에서 추출하십시오 .</target>
        </trans-unit>
        <trans-unit id="79432159892c99c66a4b92db80f46b317928f9e7" translate="yes" xml:space="preserve">
          <source>Create a topic branch and develop.</source>
          <target state="translated">토픽 브랜치를 작성하고 개발하십시오.</target>
        </trans-unit>
        <trans-unit id="3c6e23e4bafb619b381ac21bdc202b4da275dceb" translate="yes" xml:space="preserve">
          <source>Create a tree object from the current index</source>
          <target state="translated">현재 인덱스에서 트리 객체 생성</target>
        </trans-unit>
        <trans-unit id="199cc87a17f205a9debb1daf10f2cfd04f927e64" translate="yes" xml:space="preserve">
          <source>Create an archive of files from a named tree</source>
          <target state="translated">명명 된 트리에서 파일 아카이브 생성</target>
        </trans-unit>
        <trans-unit id="11842098ab38c4b23c00972df92c03d934dd00f4" translate="yes" xml:space="preserve">
          <source>Create an empty Git repository or reinitialize an existing one</source>
          <target state="translated">빈 Git 저장소를 만들거나 기존 저장소를 다시 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="4bf9b028076fc8c72d20bdece3ec7191ce92cd0a" translate="yes" xml:space="preserve">
          <source>Create and switch to a new branch at the same time:</source>
          <target state="translated">새 브랜치를 작성하고 동시에 전환하십시오.</target>
        </trans-unit>
        <trans-unit id="e2fd9501d48be0c26b22e7150b7353eff7148f41" translate="yes" xml:space="preserve">
          <source>Create multipart/mixed attachment, the first part of which is the commit message and the patch itself in the second part, with &lt;code&gt;Content-Disposition: attachment&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Content-Disposition: attachment&lt;/code&gt; 하여 첫 번째 부분이 커밋 메시지이고 두 번째 부분의 패치 자체 인 멀티 파트 / 혼합 첨부 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="09cc7488a79d34bbf5d70e088375c60a2a44d3fc" translate="yes" xml:space="preserve">
          <source>Create multipart/mixed attachment, the first part of which is the commit message and the patch itself in the second part, with &lt;code&gt;Content-Disposition: inline&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Content-Disposition: inline&lt;/code&gt; 하여 첫 번째 부분이 커밋 메시지이고 두 번째 부분의 패치 자체 인 멀티 파트 / 혼합 첨부 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="1fbaabd2de6436a9809de570bfef7e43943388cb" translate="yes" xml:space="preserve">
          <source>Create or update a branch with a new commit, recording one logical change to the project.</source>
          <target state="translated">새로운 커밋으로 브랜치를 생성하거나 업데이트하여 프로젝트에 하나의 논리적 변경을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="b926e4f1bd2c9ddbabaf20296d6e0bdae2102d0d" translate="yes" xml:space="preserve">
          <source>Create parent folders. This parameter is equivalent to the parameter --parents on svn cp commands and is useful for non-standard repository layouts.</source>
          <target state="translated">부모 폴더를 만듭니다. 이 매개 변수는 svn cp 명령의 --parents 매개 변수와 동일하며 비표준 저장소 레이아웃에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="008d223ce25dddb7eb7d24c361668074bbed6dad" translate="yes" xml:space="preserve">
          <source>Create the branch &lt;code&gt;experimental&lt;/code&gt; in the &lt;code&gt;origin&lt;/code&gt; repository by copying the current &lt;code&gt;master&lt;/code&gt; branch. This form is only needed to create a new branch or tag in the remote repository when the local name and the remote name are different; otherwise, the ref name on its own will work.</source>
          <target state="translated">현재 &lt;code&gt;master&lt;/code&gt; 브랜치를 복사하여 &lt;code&gt;origin&lt;/code&gt; 저장소 에서 브랜치 &lt;code&gt;experimental&lt;/code&gt; 을 작성하십시오 . 이 양식은 로컬 이름과 원격 이름이 다른 경우 원격 저장소에서 새 분기 또는 태그를 작성하는 데만 필요합니다. 그렇지 않으면 심판 이름 자체가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="157f2dfeff99612ce2fdbdc6f8123dc09aa74a0b" translate="yes" xml:space="preserve">
          <source>Create the branch&amp;rsquo;s reflog. This activates recording of all changes made to the branch ref, enabling use of date based sha1 expressions such as &quot;&amp;lt;branchname&amp;gt;@{yesterday}&quot;. Note that in non-bare repositories, reflogs are usually enabled by default by the &lt;code&gt;core.logAllRefUpdates&lt;/code&gt; config option. The negated form &lt;code&gt;--no-create-reflog&lt;/code&gt; only overrides an earlier &lt;code&gt;--create-reflog&lt;/code&gt;, but currently does not negate the setting of &lt;code&gt;core.logAllRefUpdates&lt;/code&gt;.</source>
          <target state="translated">지점의 참조 로그를 작성하십시오. 이렇게하면 분기 참조에 대한 모든 변경 사항이 기록되어 &quot;&amp;lt;branchname&amp;gt; @ {yesterday}&quot;와 같은 날짜 기반 sha1 식을 사용할 수 있습니다. 베어링되지 않은 리포지토리에서 일반적으로 reflog는 &lt;code&gt;core.logAllRefUpdates&lt;/code&gt; 구성 옵션에 의해 기본적으로 활성화됩니다 . 부정 된 양식 인 &lt;code&gt;--no-create-reflog&lt;/code&gt; 는 이전의 &lt;code&gt;--create-reflog&lt;/code&gt; -reflog 만 무시 하지만 현재 &lt;code&gt;core.logAllRefUpdates&lt;/code&gt; 의 설정은 무효화하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6e2b0a6de869fa2e1ebef49223a669515c01db9f" translate="yes" xml:space="preserve">
          <source>Create the new branch&amp;rsquo;s reflog; see &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">새 분기의 reflog를 작성하십시오. 자세한 내용은 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="770931923d2f84baa80a7c6281d4bb0c7e7ff5dc" translate="yes" xml:space="preserve">
          <source>Create, list, delete or verify a tag object signed with GPG</source>
          <target state="translated">GPG로 서명 된 태그 객체 생성, 나열, 삭제 또는 확인</target>
        </trans-unit>
        <trans-unit id="884d013fa41e619bec3679b144edae3781c7f0c5" translate="yes" xml:space="preserve">
          <source>Create, list, delete refs to replace objects</source>
          <target state="translated">객체를 대체하기 위해 참조 생성, 나열, 삭제</target>
        </trans-unit>
        <trans-unit id="b126e5a5d6c912b3969ba9d70dcd92e7124db848" translate="yes" xml:space="preserve">
          <source>Creates (or recreates) the named branch, optionally starting from a specific revision. The reset command allows a frontend to issue a new &lt;code&gt;from&lt;/code&gt; command for an existing branch, or to create a new branch from an existing commit without creating a new commit.</source>
          <target state="translated">선택적으로 특정 개정에서 시작하여 명명 된 분기를 작성 (또는 재 작성)합니다. reset 명령을 사용하면 프런트 엔드에서 기존 분기에 대해 새 &lt;code&gt;from&lt;/code&gt; 명령을 실행하거나 새 커밋을 만들지 않고 기존 커밋에서 새 분기를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="999e99d0bbec6ceb96391dfde9cf6cc8fcd81661" translate="yes" xml:space="preserve">
          <source>Creates a file holding the contents of the blob specified by sha1. It returns the name of the temporary file in the following format: .merge_file_XXXXX</source>
          <target state="translated">sha1에 의해 지정된 blob의 내용을 보유하는 파일을 작성합니다. .merge_file_XXXXX 형식으로 임시 파일 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="09d3cd201fc386ccac2ad9f5c22bafbf8bdbb2f4" translate="yes" xml:space="preserve">
          <source>Creates a local branch, &lt;code&gt;master&lt;/code&gt; from this remote and checks it out.</source>
          <target state="translated">이 원격지에서 로컬 분기, &lt;code&gt;master&lt;/code&gt; 를 작성하고 체크 아웃합니다.</target>
        </trans-unit>
        <trans-unit id="7f64654581811c2b404b1b8dce4e1e1130a9678f" translate="yes" xml:space="preserve">
          <source>Creates a new branch or updates an existing branch by creating a new commit and updating the branch to point at the newly created commit.</source>
          <target state="translated">새 커밋을 만들고 새로 만든 커밋을 가리 키도록 분기를 업데이트하여 새 분기를 만들거나 기존 분기를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="1d59a731f68874f36286c257dc8063d7c2d003c5" translate="yes" xml:space="preserve">
          <source>Creates a new commit object based on the provided tree object and emits the new commit object id on stdout. The log message is read from the standard input, unless &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; options are given.</source>
          <target state="translated">제공된 트리 오브젝트를 기반으로 새 커미트 오브젝트를 작성하고 stdout에서 새 커미트 오브젝트 ID를 생성합니다. &lt;code&gt;-m&lt;/code&gt; 또는 &lt;code&gt;-F&lt;/code&gt; 옵션이 제공 되지 않으면 표준 입력에서 로그 메시지를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="47450bdc6c156b7e9d8dff8eb5153c36f0034363" translate="yes" xml:space="preserve">
          <source>Creates a tag object</source>
          <target state="translated">태그 객체를 생성합니다</target>
        </trans-unit>
        <trans-unit id="befea765dea04bdbe90515b52ec037d05fcd654f" translate="yes" xml:space="preserve">
          <source>Creates a temporary file with a blob&amp;rsquo;s contents</source>
          <target state="translated">얼룩의 내용으로 임시 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="352027cd4f1050e7a8d58f4759fd4887117240f0" translate="yes" xml:space="preserve">
          <source>Creates a tree object using the current index. The name of the new tree object is printed to standard output.</source>
          <target state="translated">현재 인덱스를 사용하여 트리 개체를 만듭니다. 새 트리 개체의 이름이 표준 출력으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="7652dba54710524ad06e288b0394d9ec8f781534" translate="yes" xml:space="preserve">
          <source>Creates an annotated tag object from an existing commit or branch. Lightweight tags are not supported by this command, as they are not recommended for recording meaningful points in time.</source>
          <target state="translated">기존 커밋 또는 분기에서 주석이 달린 태그 객체를 만듭니다. 경량 태그는 의미있는 시점을 기록하는 데 권장되지 않으므로이 명령에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94955619715d4d7ab1e29b4a0777170b742991c7" translate="yes" xml:space="preserve">
          <source>Creates an annotated tag referring to a specific commit. To create lightweight (non-annotated) tags see the &lt;code&gt;reset&lt;/code&gt; command below.</source>
          <target state="translated">특정 커밋을 참조하는 주석이 달린 태그를 만듭니다. 가벼운 (주석이없는) 태그를 만들려면 아래 의 &lt;code&gt;reset&lt;/code&gt; 명령을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1c5caa9b586b6725b423618f01dee45981d01339" translate="yes" xml:space="preserve">
          <source>Creates an archive of the specified format containing the tree structure for the named tree, and writes it out to the standard output. If &amp;lt;prefix&amp;gt; is specified it is prepended to the filenames in the archive.</source>
          <target state="translated">명명 된 트리의 트리 구조를 포함하는 지정된 형식의 아카이브를 작성하여 표준 출력에 기록합니다. &amp;lt;prefix&amp;gt;를 지정하면 아카이브의 파일 이름 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="902be57432c35cdc5fd0ebc974090ec5fe10886f" translate="yes" xml:space="preserve">
          <source>Creates an empty Git repository in a subdirectory called &lt;code&gt;project&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;project&lt;/code&gt; 라는 서브 디렉토리에 빈 Git 저장소를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="d5bd8f97656dc6346e6c11ca45adb1cb8cf3739a" translate="yes" xml:space="preserve">
          <source>Creates and checks out a new branch named &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; starting from the commit at which the &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; was originally created, applies the changes recorded in &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; to the new working tree and index. If that succeeds, and &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; is a reference of the form &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt;, it then drops the &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">만들고라는 새 브랜치를 체크 아웃 &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; (가) (가)있는 커밋에서 시작하는 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 처음에 만들에 기록 변경 적용 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 새로운 작업 트리와 인덱스를. 성공하고 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 가 &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt; 형식의 참조 인 경우 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 를 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="cdbbe8fe0fb510b54456d0e5f7552d0ff50cdb17" translate="yes" xml:space="preserve">
          <source>Creates and checks out a new branch named &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; starting from the commit at which the &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; was originally created, applies the changes recorded in &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; to the new working tree and index. If that succeeds, and &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; is a reference of the form &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt;, it then drops the &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt;. When no &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; is given, applies the latest one.</source>
          <target state="translated">만들고라는 새 브랜치를 체크 아웃 &lt;code&gt;&amp;lt;branchname&amp;gt;&lt;/code&gt; (가) (가)있는 커밋에서 시작하는 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 처음에 만들에 기록 변경 적용 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 새로운 작업 트리와 인덱스를. 성공하고 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 가 &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt; 형식의 참조 인 경우 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 를 삭제합니다 . &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 가 제공 되지 않으면 최신 항목을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="817de4fcd985997655ed18eb9db24df013f605f3" translate="yes" xml:space="preserve">
          <source>Creates graft commits for all entries in &lt;code&gt;$GIT_DIR/info/grafts&lt;/code&gt; and deletes that file upon success. The purpose is to help users with transitioning off of the now-deprecated graft file.</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/info/grafts&lt;/code&gt; 모든 항목에 대한 이식 커밋을 생성 하고 성공하면 해당 파일을 삭제합니다. 이제는 더 이상 사용되지 않는 이식 파일에서 전환하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="dffa1bc89fe4773c581e2bab0e59b1fe8148dfd2" translate="yes" xml:space="preserve">
          <source>Creates the branch &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; and start it at &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt;; if it already exists, then reset it to &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt;. This is equivalent to running &quot;git branch&quot; with &quot;-f&quot;; see &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; 분기를 작성 하고 &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; 에서 시작하십시오 . 이미 존재하는 경우 &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; 로 재설정하십시오 . 이것은 &quot;-f&quot;로 &quot;git branch&quot;를 실행하는 것과 같습니다. 자세한 내용은 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="051c90bf7349afef9519ebfd754be98e47ed9dee" translate="yes" xml:space="preserve">
          <source>Creating a branch in such a configuration requires disambiguating which location to use using the -d or --destination flag:</source>
          <target state="translated">이러한 구성에서 분기를 작성하려면 -d 또는 --destination 플래그를 사용하여 사용할 위치를 명확하게 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e6bedfd34ce489d63a7de42dd785dfdc0700c1e9" translate="yes" xml:space="preserve">
          <source>Creating a changelog and tarball for a software release</source>
          <target state="translated">소프트웨어 릴리스에 대한 변경 로그 및 tarball 작성</target>
        </trans-unit>
        <trans-unit id="c40a17b4008177323999b06c207c30d124e6c258" translate="yes" xml:space="preserve">
          <source>Creating a git repository</source>
          <target state="translated">자식 저장소 만들기</target>
        </trans-unit>
        <trans-unit id="040db03d97cbb631e8d9e6687acd4b2ef2582aa9" translate="yes" xml:space="preserve">
          <source>Creating a new Git repository couldn&amp;rsquo;t be easier: all Git repositories start out empty, and the only thing you need to do is find yourself a subdirectory that you want to use as a working tree - either an empty one for a totally new project, or an existing working tree that you want to import into Git.</source>
          <target state="translated">새로운 Git 리포지토리를 만드는 것은 더 쉬울 수 없습니다. 모든 Git 리포지토리가 비어 있기 시작하면 필요한 것은 자신이 작업 트리로 사용할 하위 디렉토리를 찾는 것입니다. 완전히 새로운 프로젝트를위한 빈 디렉토리입니다. 또는 Git으로 가져 오려는 기존 작업 트리입니다.</target>
        </trans-unit>
        <trans-unit id="00e49b6089f98df76d1261d9c963ee126709d119" translate="yes" xml:space="preserve">
          <source>Creating a new branch</source>
          <target state="translated">새로운 지점 만들기</target>
        </trans-unit>
        <trans-unit id="c39cd6567c9d07f33e0b16412b2e647902776ceb" translate="yes" xml:space="preserve">
          <source>Creating a new commit takes three steps:</source>
          <target state="translated">새 커밋을 만들려면 다음 세 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="8ab78a3735f73dea4916eb1431c8608a2d083ad2" translate="yes" xml:space="preserve">
          <source>Creating a new commit that reverts an earlier change is very easy; just pass the &lt;a href=&quot;git-revert&quot;&gt;git-revert[1]&lt;/a&gt; command a reference to the bad commit; for example, to revert the most recent commit:</source>
          <target state="translated">이전 변경 사항을 되 돌리는 새로운 커밋을 만드는 것은 매우 쉽습니다. 잘못된 커밋에 대한 참조를 &lt;a href=&quot;git-revert&quot;&gt;git-revert [1]&lt;/a&gt; 명령에 전달하면됩니다 . 예를 들어 가장 최근의 커밋을 되돌리려면</target>
        </trans-unit>
        <trans-unit id="324b268505a0bd944ee2d5d30c8a3d50fc28d90f" translate="yes" xml:space="preserve">
          <source>Creating a new repository</source>
          <target state="translated">새로운 저장소 만들기</target>
        </trans-unit>
        <trans-unit id="36dbdbb03a117f7df33bdb409d5809a8b5ea5e6e" translate="yes" xml:space="preserve">
          <source>Creating a new repository from scratch is very easy:</source>
          <target state="translated">처음부터 새 저장소를 작성하는 것은 매우 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="88eec46a3edc17fddca4fd44d28bb64f8780df72" translate="yes" xml:space="preserve">
          <source>Creating a tree object is trivial, and is done with &lt;code&gt;git write-tree&lt;/code&gt;. There are no options or other input: &lt;code&gt;git write-tree&lt;/code&gt; will take the current index state, and write an object that describes that whole index. In other words, we&amp;rsquo;re now tying together all the different filenames with their contents (and their permissions), and we&amp;rsquo;re creating the equivalent of a Git &quot;directory&quot; object:</source>
          <target state="translated">트리 객체 생성은 간단하며 &lt;code&gt;git write-tree&lt;/code&gt; 로 수행됩니다 . 옵션이나 다른 입력은 없습니다 : &lt;code&gt;git write-tree&lt;/code&gt; 는 현재 인덱스 상태를 취하고 전체 인덱스를 설명하는 객체를 작성합니다. 다시 말해, 우리는 이제 모든 다른 파일 이름을 내용과 권한으로 묶고 있으며 Git &quot;directory&quot;객체와 동등한 것을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="719e91bca781d7da4469d32275de7f00e97366b0" translate="yes" xml:space="preserve">
          <source>Creating an archive</source>
          <target state="translated">아카이브 만들기</target>
        </trans-unit>
        <trans-unit id="57d940de5ca0935e018fd03ec556851a3258029c" translate="yes" xml:space="preserve">
          <source>Creating good commit messages</source>
          <target state="translated">좋은 커밋 메시지 만들기</target>
        </trans-unit>
        <trans-unit id="d793460efe87481af6fc2a69bf4007ae5b376697" translate="yes" xml:space="preserve">
          <source>Creating replacement objects</source>
          <target state="translated">대체 객체 만들기</target>
        </trans-unit>
        <trans-unit id="ab3dc2ecc52838a3e77a21918b25403d09705634" translate="yes" xml:space="preserve">
          <source>Creating tags</source>
          <target state="translated">태그 생성</target>
        </trans-unit>
        <trans-unit id="b0acbd1aa53ddfa814233d47e25a83dac45b77c7" translate="yes" xml:space="preserve">
          <source>Creating the commit using the content you told Git about in step 2.</source>
          <target state="translated">2 단계에서 Git에 알려준 내용을 사용하여 커밋 만들기</target>
        </trans-unit>
        <trans-unit id="4d969b5791f8a038b7f947a6c2bb33127dd04018" translate="yes" xml:space="preserve">
          <source>Creating the perfect patch series</source>
          <target state="translated">완벽한 패치 시리즈 만들기</target>
        </trans-unit>
        <trans-unit id="a2955539fd234d4e940b20d8a9e91ef656e850f2" translate="yes" xml:space="preserve">
          <source>Creating, deleting, and modifying branches is quick and easy; here&amp;rsquo;s a summary of the commands:</source>
          <target state="translated">분기 작성, 삭제 및 수정은 빠르고 쉽습니다. 다음은 명령에 대한 요약입니다.</target>
        </trans-unit>
        <trans-unit id="3c7835c41262e0651be74f2c3160cc75a963df48" translate="yes" xml:space="preserve">
          <source>Credential contexts</source>
          <target state="translated">자격 증명 컨텍스트</target>
        </trans-unit>
        <trans-unit id="e937ff4d2bc216cfc4de72aa94ecda9f1b6485b0" translate="yes" xml:space="preserve">
          <source>Credential helpers are programs executed by Git to fetch or save credentials from and to long-term storage (where &quot;long-term&quot; is simply longer than a single Git process; e.g., credentials may be stored in-memory for a few minutes, or indefinitely on disk).</source>
          <target state="translated">자격 증명 도우미는 장기 저장소에서 자격 증명을 가져 오거나 저장하기 위해 Git에서 실행하는 프로그램입니다 ( &quot;장기&quot;는 단일 Git 프로세스보다 간단합니다. 예를 들어 자격 증명이 몇 분 동안 메모리에 저장 될 수 있음). 디스크에 무기한).</target>
        </trans-unit>
        <trans-unit id="458543c678ae3dd16b97b21c03b00e9eaaddd45b" translate="yes" xml:space="preserve">
          <source>Credential helpers to cache or store passwords, or to interact with a system password wallet or keychain.</source>
          <target state="translated">자격 증명 도우미는 암호를 캐시 또는 저장하거나 시스템 암호 지갑 또는 키 체인과 상호 작용합니다.</target>
        </trans-unit>
        <trans-unit id="2fe8ef32f03f0033712fed8d5429cd4799dc6471" translate="yes" xml:space="preserve">
          <source>Credential helpers, on the other hand, are external programs from which Git can request both usernames and passwords; they typically interface with secure storage provided by the OS or other programs.</source>
          <target state="translated">반면 자격 증명 도우미는 Git이 사용자 이름과 암호를 모두 요청할 수있는 외부 프로그램입니다. 일반적으로 OS 또는 다른 프로그램에서 제공하는 보안 저장소와 인터페이스합니다.</target>
        </trans-unit>
        <trans-unit id="d62300d6222786cbbaa983d6e9106aadd99d8d3d" translate="yes" xml:space="preserve">
          <source>Credential storage will by default write to the first existing file in the list. If none of these files exist, &lt;code&gt;~/.git-credentials&lt;/code&gt; will be created and written to.</source>
          <target state="translated">자격 증명 저장소는 기본적으로 목록의 첫 번째 기존 파일에 씁니다. 이러한 파일이 존재하지 않으면 &lt;code&gt;~/.git-credentials&lt;/code&gt; 가 작성되어 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="cdcc78e86a10c02802811b9eb8dc2446a5f35189" translate="yes" xml:space="preserve">
          <source>Currently a dummy fall-through function implemented as a wrapper around &lt;code&gt;printf(1)&lt;/code&gt; with variables expanded by the &lt;a href=&quot;git-sh-i18n--envsubst&quot;&gt;git-sh-i18n--envsubst[1]&lt;/a&gt; helper. Will be replaced by a real gettext implementation in a later version.</source>
          <target state="translated">현재 &lt;a href=&quot;git-sh-i18n--envsubst&quot;&gt;git-sh-i18n--envsubst [1]&lt;/a&gt; 도우미에 의해 확장 된 변수를 사용하여 &lt;code&gt;printf(1)&lt;/code&gt; 주위의 래퍼로 구현 된 더미 폴 스루 함수 입니다. 이후 버전에서 실제 gettext 구현으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="70e47cc9d61ac64c248d54da47cefec3c90e34c9" translate="yes" xml:space="preserve">
          <source>Currently a dummy fall-through function implemented as a wrapper around &lt;code&gt;printf(1)&lt;/code&gt; with variables expanded by the git-sh-i18n{litdd}envsubst[1] helper. Will be replaced by a real gettext implementation in a later version.</source>
          <target state="translated">현재 git-sh-i18n {litdd} envsubst [1] 도우미에 의해 확장 된 변수를 사용하여 &lt;code&gt;printf(1)&lt;/code&gt; 주위에 래퍼로 ​​구현 된 더미 폴 스루 함수입니다. 이후 버전에서는 실제 gettext 구현으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="87c8476a8fe8246e9cc89649a2d435a7d613617a" translate="yes" xml:space="preserve">
          <source>Currently a dummy fall-through function implemented as a wrapper around &lt;code&gt;printf(1)&lt;/code&gt;. Will be replaced by a real gettext implementation in a later version.</source>
          <target state="translated">현재 더미 폴 스루 함수는 &lt;code&gt;printf(1)&lt;/code&gt; 주위에 래퍼로 ​​구현되었습니다 . 이후 버전에서는 실제 gettext 구현으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="d0a323c8531b99ccfcb3b5693dd52db2df3f23ff" translate="yes" xml:space="preserve">
          <source>Currently available providers are &lt;strong&gt;&quot;gravatar&quot;&lt;/strong&gt; and &lt;strong&gt;&quot;picon&quot;&lt;/strong&gt;. Only one provider at a time can be selected (&lt;code&gt;default&lt;/code&gt; is one element list). If an unknown provider is specified, the feature is disabled. &lt;strong&gt;Note&lt;/strong&gt; that some providers might require extra Perl packages to be installed; see &lt;code&gt;gitweb/INSTALL&lt;/code&gt; for more details.</source>
          <target state="translated">현재 사용 가능한 제공자는 &lt;strong&gt;&quot;gravatar&quot;&lt;/strong&gt; 및 &lt;strong&gt;&quot;picon&quot;&lt;/strong&gt; 입니다. 한 번에 하나의 공급자 만 선택할 수 있습니다 ( &lt;code&gt;default&lt;/code&gt; 은 하나의 요소 목록 임). 알 수없는 공급자를 지정하면 기능이 비활성화됩니다. &lt;strong&gt;참고&lt;/strong&gt; 일부 공급자가 설치 될 별도의 펄 패키지가 필요할 수 있음; 자세한 내용은 &lt;code&gt;gitweb/INSTALL&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="717fdd8a8fe2000b9c0c629f6c5d467ecf014cfe" translate="yes" xml:space="preserve">
          <source>Currently for internal use only. Set a prefix which gives a path from above a repository down to its root. One use is to give submodules context about the superproject that invoked it.</source>
          <target state="translated">현재 내부 전용입니다. 저장소 위에서 루트까지 경로를 제공하는 접 두부를 설정하십시오. 한 가지 용도는 서브 모듈에 호출 한 수퍼 프로젝트에 대한 컨텍스트를 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="44c98bf149dc1ad4ae7705ea185729a070e4f82e" translate="yes" xml:space="preserve">
          <source>Currently recognized fields are:</source>
          <target state="translated">현재 인식되는 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="96e2ac5c1dd546ca41ecd7f60aa78cd7c4c66ca3" translate="yes" xml:space="preserve">
          <source>Currently the command updates the following files. Please see &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; for description of what they are for:</source>
          <target state="translated">현재이 명령은 다음 파일을 업데이트합니다. 그것들에 대한 설명 은 &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt; 를 참조하십시오 :</target>
        </trans-unit>
        <trans-unit id="58cad17f651d6b9e5474187d9de4ce3c98aebe87" translate="yes" xml:space="preserve">
          <source>Currently this is used by &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt; and &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; when &lt;code&gt;git checkout &amp;lt;something&amp;gt;&lt;/code&gt; or &lt;code&gt;git switch &amp;lt;something&amp;gt;&lt;/code&gt; will checkout the &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; branch on another remote, and by &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt; when &lt;code&gt;git worktree add&lt;/code&gt; refers to a remote branch. This setting might be used for other checkout-like commands or functionality in the future.</source>
          <target state="translated">현재 이것은 &lt;code&gt;git checkout &amp;lt;something&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;git switch &amp;lt;something&amp;gt;&lt;/code&gt; 이 다른 원격 에서 &lt;code&gt;&amp;lt;something&amp;gt;&lt;/code&gt; 분기를 체크 아웃 할 때 &lt;a href=&quot;git-switch&quot;&gt;git-switch [1]&lt;/a&gt; 및 &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]에&lt;/a&gt; 의해 사용되고 &lt;a href=&quot;git-worktree&quot;&gt;git-worktree [1]에 의해 사용&lt;/a&gt; 됩니다. &lt;code&gt;git worktree add&lt;/code&gt; 는 원격 브랜치를 나타냅니다. 이 설정은 향후 다른 체크 아웃과 같은 명령 또는 기능에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c5b7b525cb2eea52baefaf69e3b28ebe43a1b5d" translate="yes" xml:space="preserve">
          <source>Currently, this is always &quot;r1&quot; for the main repository. This field is in anticipation of in-proc submodules in the future.</source>
          <target state="translated">현재 이것은 기본 저장소에 대해 항상 &quot;r1&quot;입니다. 이 필드는 향후 in-proc 서브 모듈을 예상하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="071b814c810acef4a305418b7617eb91825385c2" translate="yes" xml:space="preserve">
          <source>Custom helpers</source>
          <target state="translated">맞춤 도우미</target>
        </trans-unit>
        <trans-unit id="441c592e043641e18ffb271284d516b14fe37bc0" translate="yes" xml:space="preserve">
          <source>Custom macro attributes can be defined only in top-level gitattributes files (&lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt;, the &lt;code&gt;.gitattributes&lt;/code&gt; file at the top level of the working tree, or the global or system-wide gitattributes files), not in &lt;code&gt;.gitattributes&lt;/code&gt; files in working tree subdirectories. The built-in macro attribute &quot;binary&quot; is equivalent to:</source>
          <target state="translated">사용자 지정 매크로 속성은 최상위 파일 (gitattributes에서만 정의 할 수 있습니다 &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; 의 &lt;code&gt;.gitattributes&lt;/code&gt; 의 하지에서 작업 트리의 최상위 레벨에서 파일 또는 글로벌 또는 시스템 전체 gitattributes 파일), &lt;code&gt;.gitattributes&lt;/code&gt; 의 파일을 작업 트리 하위 디렉토리에서. 내장 매크로 속성 &quot;binary&quot;는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e39087b89619b8882da1dce388a569a8e549573" translate="yes" xml:space="preserve">
          <source>Customizing word diff</source>
          <target state="translated">단어 차이 사용자 정의</target>
        </trans-unit>
        <trans-unit id="a28effa0c8276898e045b96b9d1ba0f760229cf5" translate="yes" xml:space="preserve">
          <source>Cute name for &lt;a href=&quot;#def_core_git&quot;&gt;core Git&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_core_git&quot;&gt;핵심 Git의&lt;/a&gt; 귀여운 이름 .</target>
        </trans-unit>
        <trans-unit id="7033e3578a96d1e9400e567b4c0c23cd21d2c6e2" translate="yes" xml:space="preserve">
          <source>Cute name for programs and program suites depending on &lt;a href=&quot;#def_core_git&quot;&gt;core Git&lt;/a&gt;, presenting a high level access to core Git. Porcelains expose more of a &lt;a href=&quot;#def_SCM&quot;&gt;SCM&lt;/a&gt; interface than the &lt;a href=&quot;#def_plumbing&quot;&gt;plumbing&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_core_git&quot;&gt;코어 Git&lt;/a&gt; 에 따라 프로그램 및 프로그램 스위트의 귀여운 이름으로 코어 Git 에 대한 높은 수준의 액세스를 제공합니다. 도자기 는 &lt;a href=&quot;#def_plumbing&quot;&gt;배관&lt;/a&gt; 보다 &lt;a href=&quot;#def_SCM&quot;&gt;SCM&lt;/a&gt; 인터페이스를 더 많이 노출 합니다 .</target>
        </trans-unit>
        <trans-unit id="c276dc0072d6e81f335296db56eec5a1bdc2bed9" translate="yes" xml:space="preserve">
          <source>Cutting down bisection by giving more parameters to bisect start</source>
          <target state="translated">이등분 시작에 더 많은 매개 변수를 제공하여이 분절 절단</target>
        </trans-unit>
        <trans-unit id="9e78b27ca0bc764cd94adfc012f3ea2c4c32e8ff" translate="yes" xml:space="preserve">
          <source>D: deletion of a file</source>
          <target state="translated">D : 파일 삭제</target>
        </trans-unit>
        <trans-unit id="4ecdb0fd037d3dafe4f4e2a354bcfe9ed6b3a537" translate="yes" xml:space="preserve">
          <source>DAG</source>
          <target state="translated">DAG</target>
        </trans-unit>
        <trans-unit id="5a7759c99cc9f0c4d7897147bc310328ba1b2ac4" translate="yes" xml:space="preserve">
          <source>Dangling objects</source>
          <target state="translated">매달린 물체</target>
        </trans-unit>
        <trans-unit id="d8788504c151968602d8ccc8fc1d2150b059a336" translate="yes" xml:space="preserve">
          <source>Data Messages</source>
          <target state="translated">데이터 메시지</target>
        </trans-unit>
        <trans-unit id="4b1f2d8717c44b631b95852544cce5392a548364" translate="yes" xml:space="preserve">
          <source>Data events are tagged with the active thread name. They are used to report the per-thread parameters.</source>
          <target state="translated">데이터 이벤트는 활성 스레드 이름으로 태그됩니다. 스레드 별 매개 변수를보고하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4bee01a9236d0c6bfb9a9c78d868c75e8d0aa93e" translate="yes" xml:space="preserve">
          <source>Data messages added to a region.</source>
          <target state="translated">지역에 추가 된 데이터 메시지.</target>
        </trans-unit>
        <trans-unit id="e5169e0ca17e29bbdf784cf8e268aafa8934e51d" translate="yes" xml:space="preserve">
          <source>Data written to stdin of the specified &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; is assumed to be sent to a git:// server, git-upload-pack, git-receive-pack or git-upload-archive (depending on situation), and data read from stdout of &amp;lt;command&amp;gt; is assumed to be received from the same service.</source>
          <target state="translated">지정된 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 의 stdin에 기록 된 데이터 는 git : // 서버, git-upload-pack, git-receive-pack 또는 git-upload-archive (상황에 따라 다름) 및 다음에서 읽은 데이터로 전송 된 것으로 가정합니다. &amp;lt;command&amp;gt;의 stdout은 동일한 서비스에서 수신 된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ce4b9abd8c39b6edc1077cdc5fbd525d6784cc17" translate="yes" xml:space="preserve">
          <source>Database backend</source>
          <target state="translated">데이터베이스 백엔드</target>
        </trans-unit>
        <trans-unit id="88e3b202bead5498b3c26df9a24b06dbb71997e1" translate="yes" xml:space="preserve">
          <source>Database name. The exact meaning depends on the selected database driver, for SQLite this is a filename. Supports variable substitution (see below). May not contain semicolons (&lt;code&gt;;&lt;/code&gt;). Default: &lt;code&gt;%Ggitcvs.%m.sqlite&lt;/code&gt;</source>
          <target state="translated">데이터베이스 이름. 정확한 의미는 선택한 데이터베이스 드라이버에 따라 다릅니다. SQLite의 경우 파일 이름입니다. 변수 대체를 지원합니다 (아래 참조). 세미콜론 ( &lt;code&gt;;&lt;/code&gt; )을 포함 할 수 없습니다 . 기본값 : &lt;code&gt;%Ggitcvs.%m.sqlite&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec7281a9f03369f6fca87bc704dcd61eb8d42fc2" translate="yes" xml:space="preserve">
          <source>Database password. Only useful if setting &lt;code&gt;dbDriver&lt;/code&gt;, since SQLite has no concept of database passwords.</source>
          <target state="translated">데이터베이스 비밀번호. SQLite에는 데이터베이스 비밀번호 개념이 없으므로 &lt;code&gt;dbDriver&lt;/code&gt; 를 설정하는 경우에만 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="6cb047cae02c9bba7b0e3391be2c746d7c4c4487" translate="yes" xml:space="preserve">
          <source>Database table name prefix. Prepended to the names of any database tables used, allowing a single database to be used for several repositories. Supports variable substitution (see &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt; for details). Any non-alphabetic characters will be replaced with underscores.</source>
          <target state="translated">데이터베이스 테이블 이름 접 두부 사용 된 데이터베이스 테이블 이름 앞에 추가하여 단일 데이터베이스를 여러 저장소에 사용할 수 있습니다. 변수 대체를 지원합니다 (자세한 내용은 &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt; 참조). 알파벳이 아닌 문자는 밑줄로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="ba01b17d3115051f1a477d09b8cec632c83f89d1" translate="yes" xml:space="preserve">
          <source>Database table name prefix. Supports variable substitution (see below). Any non-alphabetic characters will be replaced with underscores.</source>
          <target state="translated">데이터베이스 테이블 이름 접 두부 변수 대체를 지원합니다 (아래 참조). 알파벳이 아닌 문자는 밑줄로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="a13030629fc1c33a937c268b335dcb627627128f" translate="yes" xml:space="preserve">
          <source>Database used by git-cvsserver to cache revision information derived from the Git repository. The exact meaning depends on the used database driver, for SQLite (which is the default driver) this is a filename. Supports variable substitution (see &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt; for details). May not contain semicolons (&lt;code&gt;;&lt;/code&gt;). Default: &lt;code&gt;%Ggitcvs.%m.sqlite&lt;/code&gt;</source>
          <target state="translated">git-cvsserver에서 Git 리포지토리에서 파생 된 개정 정보를 캐시하는 데 사용되는 데이터베이스. 정확한 의미는 사용 된 데이터베이스 드라이버에 따라 다르며 SQLite (기본 드라이버)의 경우 파일 이름입니다. 변수 대체를 지원합니다 (자세한 내용은 &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt; 참조). 세미콜론 ( &lt;code&gt;;&lt;/code&gt; )을 포함 할 수 없습니다 . 기본값 : &lt;code&gt;%Ggitcvs.%m.sqlite&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb3915ed16cfcd6e4965fc92e19dfdb3f354cb3d" translate="yes" xml:space="preserve">
          <source>Database user and password. Only useful if setting &lt;code&gt;gitcvs.dbDriver&lt;/code&gt;, since SQLite has no concept of database users and/or passwords. &lt;code&gt;gitcvs.dbUser&lt;/code&gt; supports variable substitution (see &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt; for details).</source>
          <target state="translated">데이터베이스 사용자 및 비밀번호 SQLite에는 데이터베이스 사용자 및 / 또는 비밀번호 개념이 없으므로 &lt;code&gt;gitcvs.dbDriver&lt;/code&gt; 를 설정하는 경우에만 유용 합니다. &lt;code&gt;gitcvs.dbUser&lt;/code&gt; 는 변수 대체를 지원합니다 (자세한 내용은 &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="161446d05bce5c35b9bb58271e5e12dbad31f437" translate="yes" xml:space="preserve">
          <source>Database user. Only useful if setting &lt;code&gt;dbDriver&lt;/code&gt;, since SQLite has no concept of database users. Supports variable substitution (see below).</source>
          <target state="translated">데이터베이스 사용자. SQLite에는 데이터베이스 사용자 개념이 없으므로 &lt;code&gt;dbDriver&lt;/code&gt; 를 설정하는 경우에만 유용 합니다. 변수 대체를 지원합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="3fcd7b7ae338d342a7674f84f0c1f730e65ba9c0" translate="yes" xml:space="preserve">
          <source>Date Formats</source>
          <target state="translated">날짜 형식</target>
        </trans-unit>
        <trans-unit id="adf2309d1c810bb87f6dbfe62284445270cc7ea8" translate="yes" xml:space="preserve">
          <source>Date formats</source>
          <target state="translated">날짜 형식</target>
        </trans-unit>
        <trans-unit id="8dd9c41bb94ad9101ba89e79d1af605fb457f638" translate="yes" xml:space="preserve">
          <source>Debug gitignore / exclude files</source>
          <target state="translated">gitignore 디버그 / 파일 제외</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="49a655454d59f6253c27bfd18c23a18e1916a070" translate="yes" xml:space="preserve">
          <source>Debugging would be easier if the fallback configuration file (&lt;code&gt;/etc/gitweb.conf&lt;/code&gt;) and environment variable to override its location (&lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt;) had names reflecting their &quot;fallback&quot; role. The current names are kept to avoid breaking working setups.</source>
          <target state="translated">폴백 구성 파일 ( &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; ) 및 해당 위치를 대체하는 환경 변수 ( &lt;code&gt;GITWEB_CONFIG_SYSTEM&lt;/code&gt; )에 이름이 &quot;폴백&quot;역할을 나타내는 이름을 가진 경우 디버깅이 더 쉬울 것 입니다. 현재 설정은 작업 설정이 중단되지 않도록 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="25623d3d6597110b3dc53adcb06a990460c0bdc2" translate="yes" xml:space="preserve">
          <source>Decide not to merge. The only clean-ups you need are to reset the index file to the &lt;code&gt;HEAD&lt;/code&gt; commit to reverse 2. and to clean up working tree changes made by 2. and 3.; &lt;code&gt;git merge --abort&lt;/code&gt; can be used for this.</source>
          <target state="translated">병합하지 않기로 결정하십시오. 필요한 정리 작업은 인덱스 파일을 &lt;code&gt;HEAD&lt;/code&gt; 커밋 으로 재설정하여 2를 반대로하고 2와 3으로 작업 트리 변경 사항을 정리하는 것입니다. &lt;code&gt;git merge --abort&lt;/code&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="461dd8f77b9a26481c7b52783d8ce19864c00a87" translate="yes" xml:space="preserve">
          <source>Deepen or shorten the history of a shallow repository to exclude commits reachable from a specified remote branch or tag. This option can be specified multiple times.</source>
          <target state="translated">지정된 원격 브랜치 또는 태그에서 도달 할 수있는 커밋을 제외하기 위해 얕은 리포지토리의 기록을 깊게하거나 줄입니다. 이 옵션은 여러 번 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc0ba6fe75550f8aa46ad04018df5509f99a82b6" translate="yes" xml:space="preserve">
          <source>Deepen or shorten the history of a shallow repository to include all reachable commits after &amp;lt;date&amp;gt;.</source>
          <target state="translated">&amp;lt;date&amp;gt; 이후에 도달 가능한 모든 커밋을 포함하도록 얕은 리포지토리의 기록을 깊게하거나 줄입니다.</target>
        </trans-unit>
        <trans-unit id="b85c21ce1c36df4fd97d8d980d2975325f47caee" translate="yes" xml:space="preserve">
          <source>Deepens the history of a shallow repository based on time.</source>
          <target state="translated">시간을 기준으로 얕은 저장소의 기록을 심화시킵니다.</target>
        </trans-unit>
        <trans-unit id="0b2ab70fb2f23273e2c8d92c10b43dfc891dac12" translate="yes" xml:space="preserve">
          <source>Deepens the history of a shallow repository excluding ref. Multiple options add up.</source>
          <target state="translated">심판을 제외한 얕은 저장소의 역사를 심화시킵니다. 여러 옵션이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="e87814f404c8c230e2c89d6eeca5b7883036cc70" translate="yes" xml:space="preserve">
          <source>Deepens the history of a shallow repository relative to current boundary. Only valid when used with &quot;option depth&quot;.</source>
          <target state="translated">현재 경계를 기준으로 얕은 저장소의 기록을 깊게합니다. &quot;옵션 깊이&quot;와 함께 사용하는 경우에만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="919906ebf6455d2b9a3b4a65ed3f4d4732631f26" translate="yes" xml:space="preserve">
          <source>Deepens the history of a shallow repository.</source>
          <target state="translated">얕은 저장소의 역사를 심화시킵니다.</target>
        </trans-unit>
        <trans-unit id="3a0a0372c4178042ae74a7b526723e3fc6d8263f" translate="yes" xml:space="preserve">
          <source>Deeper technical details are often marked as Notes, which you can skip on your first reading.</source>
          <target state="translated">더 자세한 기술 정보는 종종 노트로 표시되며, 처음 읽을 때는 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4f869ad0eb5d764449c5b4f72c2193187ec9d1f" translate="yes" xml:space="preserve">
          <source>Default backend to use for rebasing. Possible choices are &lt;code&gt;apply&lt;/code&gt; or &lt;code&gt;merge&lt;/code&gt;. In the future, if the merge backend gains all remaining capabilities of the apply backend, this setting may become unused.</source>
          <target state="translated">리베이스에 사용할 기본 백엔드입니다. 가능한 선택 사항은 &lt;code&gt;apply&lt;/code&gt; 또는 &lt;code&gt;merge&lt;/code&gt; 입니다. 앞으로 병합 백엔드가 적용 백엔드의 나머지 모든 기능을 확보하면이 설정이 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d20e487318f9399c04b2a3d79bfe7af0545b07ad" translate="yes" xml:space="preserve">
          <source>Default behavior is to replace at most one line. This replaces all lines matching the key (and optionally the value_regex).</source>
          <target state="translated">기본 동작은 최대 한 줄을 바꾸는 것입니다. 키와 일치하는 모든 행 (및 선택적으로 value_regex)이 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="749b51b1c09b9f840f85503ac08122dc83ca64a1" translate="yes" xml:space="preserve">
          <source>Default behaviour</source>
          <target state="translated">기본 행동</target>
        </trans-unit>
        <trans-unit id="169920c54a1f81ff4c7f4ea2f9bc3ec52999c692" translate="yes" xml:space="preserve">
          <source>Default category for projects for which none is specified. If this is set to the empty string, such projects will remain uncategorized and listed at the top, above categorized projects. Used only if project categories are enabled, which means if &lt;code&gt;$projects_list_group_categories&lt;/code&gt; is true. By default set to &quot;&quot; (empty string).</source>
          <target state="translated">지정되지 않은 프로젝트의 기본 카테고리. 이 문자열을 빈 문자열로 설정하면 해당 프로젝트는 분류되지 않은 상태로 분류 된 프로젝트의 맨 위에 표시됩니다. 프로젝트 카테고리가 사용 가능한 경우에만 사용되며, 이는 &lt;code&gt;$projects_list_group_categories&lt;/code&gt; 가 true 인 경우를 의미 합니다. 기본적으로 &quot;&quot;(빈 문자열)로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9a7724b74acb9022ccf2c23f91703070df10d1ad" translate="yes" xml:space="preserve">
          <source>Default charset for text files. If this is not set, the web server configuration will be used. Unset by default.</source>
          <target state="translated">텍스트 파일의 기본 문자셋. 설정하지 않으면 웹 서버 구성이 사용됩니다. 기본적으로 설정 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f158e700b844e38a0dc931109afe37923be30e86" translate="yes" xml:space="preserve">
          <source>Default for the &lt;code&gt;--format&lt;/code&gt; option. (See &lt;code&gt;Pretty Formats&lt;/code&gt; above.) Defaults to &lt;code&gt;medium&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--format&lt;/code&gt; 옵션의 기본값입니다 . 자세한 내용은 위의 &lt;code&gt;Pretty Formats&lt;/code&gt; 참조하십시오 . 기본값은 &lt;code&gt;medium&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="218b9a84e8b1c5c4d3bddc9fdedc0acd32221314" translate="yes" xml:space="preserve">
          <source>Default format for human-readable dates. (Compare the &lt;code&gt;--date&lt;/code&gt; option.) Defaults to &quot;default&quot;, which means to write dates like &lt;code&gt;Sat May 8 19:35:34 2010 -0500&lt;/code&gt;.</source>
          <target state="translated">사람이 읽을 수있는 날짜의 기본 형식입니다. ( &lt;code&gt;--date&lt;/code&gt; 옵션을 비교하십시오 .) 기본값은 &quot;default&quot;이며, 이는 &lt;code&gt;Sat May 8 19:35:34 2010 -0500&lt;/code&gt; 과 같은 날짜를 쓰는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="ba0eb309e5345eec5c3b84841217719e93588d00" translate="yes" xml:space="preserve">
          <source>Default is 1 MiB if NO_MMAP was set at compile time, otherwise 32 MiB on 32 bit platforms and 1 GiB on 64 bit platforms. This should be reasonable for all users/operating systems. You probably do not need to adjust this value.</source>
          <target state="translated">컴파일시 NO_MMAP이 설정된 경우 기본값은 1MiB이고, 그렇지 않으면 32 비트 플랫폼에서는 32MiB, 64 비트 플랫폼에서는 1GiB입니다. 이는 모든 사용자 / 운영 체제에 적합해야합니다. 이 값을 조정할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="d9147e34112ee790abb9f9db27d98b411473bac1" translate="yes" xml:space="preserve">
          <source>Default is 256 MiB on 32 bit platforms and 32 TiB (effectively unlimited) on 64 bit platforms. This should be reasonable for all users/operating systems, except on the largest projects. You probably do not need to adjust this value.</source>
          <target state="translated">32 비트 플랫폼에서는 기본값이 256MiB이고 64 비트 플랫폼에서는 32TiB (실제로 무제한)입니다. 가장 큰 프로젝트를 제외하고 모든 사용자 / 운영 체제에 적합해야합니다. 이 값을 조정할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="4e49064ea050150a0f08182ce6ea67e133f00a9b" translate="yes" xml:space="preserve">
          <source>Default is 512 MiB on all platforms. This should be reasonable for most projects as source code and other text files can still be delta compressed, but larger binary media files won&amp;rsquo;t be.</source>
          <target state="translated">모든 플랫폼에서 기본값은 512MiB입니다. 소스 코드 및 기타 텍스트 파일은 여전히 ​​델타 압축 될 수 있지만 더 큰 이진 미디어 파일은 그렇지 않으므로 대부분의 프로젝트에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="dda4dcbc7195d800c473af9dc2bffe5e2a28d17c" translate="yes" xml:space="preserve">
          <source>Default is 96 MiB on all platforms. This should be reasonable for all users/operating systems, except on the largest projects. You probably do not need to adjust this value.</source>
          <target state="translated">모든 플랫폼에서 기본값은 96MiB입니다. 가장 큰 프로젝트를 제외하고 모든 사용자 / 운영 체제에 적합해야합니다. 이 값을 조정할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="41aaa0897fbd85df874ab9d046a41b0b5b6fcbb7" translate="yes" xml:space="preserve">
          <source>Default is the value of &lt;code&gt;sendemail.confirm&lt;/code&gt; configuration value; if that is unspecified, default to &lt;code&gt;auto&lt;/code&gt; unless any of the suppress options have been specified, in which case default to &lt;code&gt;compose&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;sendemail.confirm&lt;/code&gt; 구성 값입니다. 지정 하지 않은 경우, 억제 옵션 이 지정되지 않은 경우 기본값은 &lt;code&gt;auto&lt;/code&gt; 이며,이 경우 기본값은 &lt;code&gt;compose&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3569c1c552117db58dc989b670cc81e2f0b5eea8" translate="yes" xml:space="preserve">
          <source>Default is the value of &lt;code&gt;sendemail.suppresscc&lt;/code&gt; configuration value; if that is unspecified, default to &lt;code&gt;self&lt;/code&gt; if --suppress-from is specified, as well as &lt;code&gt;body&lt;/code&gt; if --no-signed-off-cc is specified.</source>
          <target state="translated">기본값은 &lt;code&gt;sendemail.suppresscc&lt;/code&gt; 구성 값입니다. 지정하지 않은 경우 --suppress-from을 지정하면 기본값은 &lt;code&gt;self&lt;/code&gt; 이고 --no-signed-off-cc를 지정하면 &lt;code&gt;body&lt;/code&gt; 은 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="3d9cf7354837a1e6f3330509773c724888f83eee" translate="yes" xml:space="preserve">
          <source>Default is the value of &lt;code&gt;sendemail.validate&lt;/code&gt;; if this is not set, default to &lt;code&gt;--validate&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;sendemail.validate&lt;/code&gt; 값입니다 . 이것이 설정되지 않은 경우 기본값은 &lt;code&gt;--validate&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="56e75db08a7bfbfa3cf0e2da2dfaa6006039a1d9" translate="yes" xml:space="preserve">
          <source>Default is the value of the &lt;code&gt;sendemail.transferEncoding&lt;/code&gt; configuration value; if that is unspecified, default to &lt;code&gt;auto&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;sendemail.transferEncoding&lt;/code&gt; 구성 값입니다. 지정되지 않은 경우 기본값은 &lt;code&gt;auto&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="64e9c61ef316384afc27b43382c7032d837b6c45" translate="yes" xml:space="preserve">
          <source>Default mimetype for the blob_plain (raw) view, if mimetype checking doesn&amp;rsquo;t result in some other type; by default &quot;text/plain&quot;. Gitweb guesses mimetype of a file to display based on extension of its filename, using &lt;code&gt;$mimetypes_file&lt;/code&gt; (if set and file exists) and &lt;code&gt;/etc/mime.types&lt;/code&gt; files (see &lt;strong&gt;mime.types&lt;/strong&gt;(5) manpage; only filename extension rules are supported by gitweb).</source>
          <target state="translated">mimetype 검사로 인해 다른 유형이 아닌 경우 blob_plain (원시)보기의 기본 mimetype; 기본적으로 &quot;text / plain&quot;입니다. Gitweb은 &lt;code&gt;$mimetypes_file&lt;/code&gt; (설정 및 파일이있는 경우) 및 &lt;code&gt;/etc/mime.types&lt;/code&gt; 파일을 사용하여 파일 이름의 확장자에 따라 표시 할 파일의 mimetype을 추측 합니다 ( &lt;strong&gt;mime.types&lt;/strong&gt; (5) 맨 페이지 참조; 파일 이름 확장자 규칙 만 지원합니다) gitweb).</target>
        </trans-unit>
        <trans-unit id="a652e3e440b54f22526cd10c4e33c94f21d2c36b" translate="yes" xml:space="preserve">
          <source>Default mode</source>
          <target state="translated">기본 모드</target>
        </trans-unit>
        <trans-unit id="acfd9cc6edb5212a1b417bbccf2370d2aa946d1d" translate="yes" xml:space="preserve">
          <source>Default value is &quot;project&quot;. Unknown value means unsorted.</source>
          <target state="translated">기본값은 &quot;프로젝트&quot;입니다. 알 수없는 값은 정렬되지 않은 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d13eeb854d667ceefdf012fc9e848fc81153988f" translate="yes" xml:space="preserve">
          <source>Default value of ordering of projects on projects list page, which means the ordering used if you don&amp;rsquo;t explicitly sort projects list (if there is no &quot;o&quot; CGI query parameter in the URL). Valid values are &quot;none&quot; (unsorted), &quot;project&quot; (projects are by project name, i.e. path to repository relative to &lt;code&gt;$projectroot&lt;/code&gt;), &quot;descr&quot; (project description), &quot;owner&quot;, and &quot;age&quot; (by date of most current commit).</source>
          <target state="translated">프로젝트 목록 페이지에서 프로젝트 순서의 기본값. 이는 프로젝트 목록을 명시 적으로 정렬하지 않은 경우 (URL에 &quot;o&quot;CGI 쿼리 매개 변수가없는 경우) 사용되는 순서를 의미합니다. 유효한 값은 &quot;없음&quot;(정렬되지 않음), &quot;프로젝트&quot;(프로젝트는 프로젝트 이름, 즉 &lt;code&gt;$projectroot&lt;/code&gt; 상대적인 저장소 경로 ), &quot;descr&quot;(프로젝트 설명), &quot;소유자&quot;및 &quot;연령&quot;(일자 기준)입니다. 최신 커밋).</target>
        </trans-unit>
        <trans-unit id="8ac357056e8ed36929d1a15c1654ca84f035985a" translate="yes" xml:space="preserve">
          <source>Default values for &amp;lt;repository&amp;gt; and &amp;lt;branch&amp;gt; are read from the &quot;remote&quot; and &quot;merge&quot; configuration for the current branch as set by &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;&lt;code&gt;--track&lt;/code&gt;.</source>
          <target state="translated">&amp;lt;repository&amp;gt; 및 &amp;lt;branch&amp;gt;의 기본값은 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1] &lt;/a&gt; &lt;code&gt;--track&lt;/code&gt; 에 의해 설정된 현재 분기의 &quot;원격&quot;및 &quot;병합&quot;구성에서 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="83771af0d9e990cfd4209b40879c5dd720b86a4b" translate="yes" xml:space="preserve">
          <source>Defaults to false.</source>
          <target state="translated">기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="6daf684c4aa7d6effe6c46260cf795487441628a" translate="yes" xml:space="preserve">
          <source>Defaults to false. If this is set to a non zero number or true (identical to -1 or an unlimited number), the submodule summary will be enabled and a summary of commits for modified submodules will be shown (see --summary-limit option of &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;). Please note that the summary output command will be suppressed for all submodules when &lt;code&gt;diff.ignoreSubmodules&lt;/code&gt; is set to &lt;code&gt;all&lt;/code&gt; or only for those submodules where &lt;code&gt;submodule.&amp;lt;name&amp;gt;.ignore=all&lt;/code&gt;. The only exception to that rule is that status and commit will show staged submodule changes. To also view the summary for ignored submodules you can either use the --ignore-submodules=dirty command-line option or the &lt;code&gt;git submodule summary&lt;/code&gt; command, which shows a similar output but does not honor these settings.</source>
          <target state="translated">기본값은 false입니다. 이것이 0이 아닌 숫자 또는 true로 설정되면 (-1 또는 무제한과 동일) 서브 모듈 요약이 활성화되고 수정 된 서브 모듈에 대한 커밋 요약이 표시됩니다 ( &lt;a href=&quot;git-submodule&quot;&gt;git-의&lt;/a&gt; --summary-limit 옵션 참조) 하위 모듈 [1] ). &lt;code&gt;diff.ignoreSubmodules&lt;/code&gt; 가 &lt;code&gt;all&lt;/code&gt; 또는 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.ignore=all&lt;/code&gt; 인 서브 모듈에 대해서만 설정 되면 모든 서브 모듈에 대해 요약 출력 명령이 억제 됩니다 . 해당 규칙의 유일한 예외는 상태 및 커밋이 단계별 하위 모듈 변경 사항을 표시한다는 것입니다. 무시 된 하위 모듈에 대한 요약을 보려면 --ignore-submodules = dirty 명령 줄 옵션 또는 &lt;code&gt;git submodule summary&lt;/code&gt; 명령은 유사한 출력을 표시하지만 이러한 설정을 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c1010884442d5e06536e1ee0f4d961539164dc8e" translate="yes" xml:space="preserve">
          <source>Defines a URL from which the submodule repository can be cloned. This may be either an absolute URL ready to be passed to &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or (if it begins with ./ or ../) a location relative to the superproject&amp;rsquo;s origin repository.</source>
          <target state="translated">서브 모듈 저장소를 복제 할 수있는 URL을 정의합니다. 이 URL은 &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]에&lt;/a&gt; 전달 될 수있는 절대 URL 이거나 수퍼 프로젝트의 원본 저장소에 상대적인 위치 (./ 또는 ../로 시작하는 경우) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7eec12b7977eefefa22fa2534e2c96073288e53c" translate="yes" xml:space="preserve">
          <source>Defines a human-readable name for a custom low-level merge driver. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">사용자 지정 저수준 병합 드라이버의 사람이 읽을 수있는 이름을 정의합니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e3e9ca6f11c09da4d43e81ad293147f43b5584aa" translate="yes" xml:space="preserve">
          <source>Defines how wide the commit message window is in the &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;. &quot;75&quot; is the default.</source>
          <target state="translated">커밋 메시지 윈도우의 넓이를 &lt;a href=&quot;git-gui&quot;&gt;git-gui [1]에 정의&lt;/a&gt; 합니다. &quot;75&quot;가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="8f256827cbc850fb3bdad834aa2364767d096745" translate="yes" xml:space="preserve">
          <source>Defines the action &lt;code&gt;git push&lt;/code&gt; should take if no refspec is explicitly given. Different values are well-suited for specific workflows; for instance, in a purely central workflow (i.e. the fetch source is equal to the push destination), &lt;code&gt;upstream&lt;/code&gt; is probably what you want. Possible values are:</source>
          <target state="translated">참조 스펙이 명시 적으로 지정되지 않은 경우 &lt;code&gt;git push&lt;/code&gt; 가 수행 할 조치를 정의합니다 . 특정 워크 플로에 다른 값이 적합합니다. 예를 들어 순전히 중앙 워크 플로 (예 : 가져 오기 소스가 푸시 대상과 동일)에서 &lt;code&gt;upstream&lt;/code&gt; 이 원하는 것일 수 있습니다. 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fa5a260857f4dcd659067f9cae013659cbddf760" translate="yes" xml:space="preserve">
          <source>Defines the action &lt;code&gt;git push&lt;/code&gt; should take if no refspec is given (whether from the command-line, config, or elsewhere). Different values are well-suited for specific workflows; for instance, in a purely central workflow (i.e. the fetch source is equal to the push destination), &lt;code&gt;upstream&lt;/code&gt; is probably what you want. Possible values are:</source>
          <target state="translated">refspec이 제공되지 않은 경우 &lt;code&gt;git push&lt;/code&gt; 가 수행해야하는 작업을 정의합니다 (명령 줄, 구성 또는 다른 곳에서). 특정 워크 플로에는 다른 값이 적합합니다. 예를 들어 순전히 중앙 워크 플로 (즉, 가져 오기 소스가 푸시 대상과 동일 함)에서 &lt;code&gt;upstream&lt;/code&gt; 은 아마도 원하는 것일 수 있습니다. 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4188e24ee4c51e0130a50e687a2164cdec0105c9" translate="yes" xml:space="preserve">
          <source>Defines the command that implements a custom low-level merge driver. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">사용자 지정 하위 수준 병합 드라이버를 구현하는 명령을 정의합니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="70c9d97cb193a6213d042cd9cd1b6638dde57f03" translate="yes" xml:space="preserve">
          <source>Defines the default update procedure for the named submodule, i.e. how the submodule is updated by &quot;git submodule update&quot; command in the superproject. This is only used by &lt;code&gt;git
submodule init&lt;/code&gt; to initialize the configuration variable of the same name. Allowed values here are &lt;code&gt;checkout&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt; or &lt;code&gt;none&lt;/code&gt;. See description of &lt;code&gt;update&lt;/code&gt; command in &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; for their meaning. For security reasons, the &lt;code&gt;!command&lt;/code&gt; form is not accepted here.</source>
          <target state="translated">명명 된 하위 모듈의 기본 업데이트 절차, 즉 수퍼 프로젝트에서 &quot;git submodule update&quot;명령으로 하위 모듈을 업데이트하는 방법을 정의합니다. 이것은 같은 이름의 구성 변수를 초기화하기 위해 &lt;code&gt;git submodule init&lt;/code&gt; 에서만 사용됩니다 . 여기서 허용되는 값은 &lt;code&gt;checkout&lt;/code&gt; , &lt;code&gt;rebase&lt;/code&gt; , &lt;code&gt;merge&lt;/code&gt; 또는 &lt;code&gt;none&lt;/code&gt; 입니다. 의미에 대해서는 &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt; 의 &lt;code&gt;update&lt;/code&gt; 명령 설명을 참조하십시오 . 보안상의 이유로 &lt;code&gt;!command&lt;/code&gt; 양식은 여기에서 승인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90471e779c375b0a1c4452c6d06b08a0b6dc6757" translate="yes" xml:space="preserve">
          <source>Defines the path, relative to the top-level directory of the Git working tree, where the submodule is expected to be checked out. The path name must not end with a &lt;code&gt;/&lt;/code&gt;. All submodule paths must be unique within the .gitmodules file.</source>
          <target state="translated">서브 모듈이 체크 아웃 될 것으로 예상되는 Git 작업 트리의 최상위 디렉토리에 상대적인 경로를 정의합니다. 경로 이름은 &lt;code&gt;/&lt;/code&gt; 로 끝나서는 안됩니다 . 모든 하위 모듈 경로는 .gitmodules 파일 내에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4ca29387dcb9b04d487429eaa7be9fc96326e7a" translate="yes" xml:space="preserve">
          <source>Defines under what circumstances &quot;git status&quot; and the diff family show a submodule as modified. The following values are supported:</source>
          <target state="translated">어떤 상황에서 &quot;git status&quot;를 정의하고 diff 패밀리는 서브 모듈이 수정 된 것으로 표시합니다. 다음과 같은 값이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7943cfcce8d9f75d29b4fa34e3b6ac1f1de5b3ae" translate="yes" xml:space="preserve">
          <source>Defines under what circumstances &quot;git status&quot; and the diff family show a submodule as modified. When set to &quot;all&quot;, it will never be considered modified (but it will nonetheless show up in the output of status and commit when it has been staged), &quot;dirty&quot; will ignore all changes to the submodules work tree and takes only differences between the HEAD of the submodule and the commit recorded in the superproject into account. &quot;untracked&quot; will additionally let submodules with modified tracked files in their work tree show up. Using &quot;none&quot; (the default when this option is not set) also shows submodules that have untracked files in their work tree as changed. This setting overrides any setting made in .gitmodules for this submodule, both settings can be overridden on the command line by using the &quot;--ignore-submodules&quot; option. The &lt;code&gt;git submodule&lt;/code&gt; commands are not affected by this setting.</source>
          <target state="translated">어떤 상황에서 &quot;git status&quot;를 정의하고 diff 패밀리는 서브 모듈이 수정 된 것으로 표시합니다. &quot;all&quot;로 설정하면 수정 된 것으로 간주되지 않습니다 (그러나 상태 출력에 표시되고 준비되었을 때 커밋 됨). &quot;dirty&quot;는 서브 모듈 작업 트리의 모든 변경 사항을 무시하고 차이점 만 취합니다. 서브 모듈의 HEAD와 수퍼 프로젝트에 기록 된 커밋 사이를 고려합니다. &quot;트래킹되지 않음&quot;은 작업 트리에서 수정 된 추적 파일이있는 하위 모듈을 추가로 표시합니다. &quot;없음&quot;(이 옵션이 설정되지 않은 경우 기본값)을 사용하면 작업 트리에 추적되지 않은 파일이 변경된 하위 모듈도 표시됩니다. 이 설정은이 하위 모듈에 대한 .gitmodules의 모든 설정을 무시하며, 두 설정 모두 &quot;--ignore-submodules &quot;옵션. &lt;code&gt;git submodule&lt;/code&gt; 명령은이 설정의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1fef4851ecba56a95f304dccae2b919c9e6d073" translate="yes" xml:space="preserve">
          <source>Defines which attributes to assign to a path, similar to per-directory &lt;code&gt;.gitattributes&lt;/code&gt; files. See also: &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;.</source>
          <target state="translated">디렉토리 &lt;code&gt;.gitattributes&lt;/code&gt; 파일 과 유사하게 경로에 할당 할 속성을 정의합니다 . &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7011f57e8da17dd35f52484933047dc4fb201acb" translate="yes" xml:space="preserve">
          <source>Defines, together with branch.&amp;lt;name&amp;gt;.remote, the upstream branch for the given branch. It tells &lt;code&gt;git fetch&lt;/code&gt;/&lt;code&gt;git pull&lt;/code&gt;/&lt;code&gt;git rebase&lt;/code&gt; which branch to merge and can also affect &lt;code&gt;git push&lt;/code&gt; (see push.default). When in branch &amp;lt;name&amp;gt;, it tells &lt;code&gt;git fetch&lt;/code&gt; the default refspec to be marked for merging in FETCH_HEAD. The value is handled like the remote part of a refspec, and must match a ref which is fetched from the remote given by &quot;branch.&amp;lt;name&amp;gt;.remote&quot;. The merge information is used by &lt;code&gt;git pull&lt;/code&gt; (which at first calls &lt;code&gt;git fetch&lt;/code&gt;) to lookup the default branch for merging. Without this option, &lt;code&gt;git pull&lt;/code&gt; defaults to merge the first refspec fetched. Specify multiple values to get an octopus merge. If you wish to setup &lt;code&gt;git pull&lt;/code&gt; so that it merges into &amp;lt;name&amp;gt; from another branch in the local repository, you can point branch.&amp;lt;name&amp;gt;.merge to the desired branch, and use the relative path setting &lt;code&gt;.&lt;/code&gt; (a period) for branch.&amp;lt;name&amp;gt;.remote.</source>
          <target state="translated">지정된 분기의 업스트림 분기 인 branch. &amp;lt;name&amp;gt; .remote와 함께 정의합니다. 그것은 알 수 &lt;code&gt;git fetch&lt;/code&gt; / &lt;code&gt;git pull&lt;/code&gt; / &lt;code&gt;git rebase&lt;/code&gt; 수도 영향을 병합에 지점과 &lt;code&gt;git push&lt;/code&gt; (push.default 참조). 분기 &amp;lt;name&amp;gt;에있을 때 &lt;code&gt;git fetch&lt;/code&gt; 에게 FETCH_HEAD에서 병합되도록 표시 할 기본 참조 스펙을 알려줍니다 . 이 값은 참조 스펙의 원격 부분처럼 처리되며 &quot;branch. &amp;lt;name&amp;gt; .remote&quot;에 의해 제공된 원격에서 가져온 참조와 일치해야합니다. 병합 정보는 &lt;code&gt;git pull&lt;/code&gt; (처음에는 &lt;code&gt;git fetch&lt;/code&gt; 호출 )에서 병합을위한 기본 분기를 조회하는 데 사용됩니다 . 이 옵션이 없으면 &lt;code&gt;git pull&lt;/code&gt; 페치 된 첫 번째 참조 스펙을 병합하도록 기본 설정됩니다. 문어 병합을 얻으려면 여러 값을 지정하십시오. 로컬 저장소의 다른 브랜치에서 &amp;lt;name&amp;gt;으로 병합되도록 &lt;code&gt;git pull&lt;/code&gt; 을 설정 하려면 branch. &amp;lt;name&amp;gt; .merge를 원하는 브랜치를 가리키고 상대 경로 설정을 사용할 수 있습니다 &lt;code&gt;.&lt;/code&gt; 분기의 &amp;lt;기간&amp;gt;. 원격.</target>
        </trans-unit>
        <trans-unit id="f11af95383d16d6bd1e7925886e81b428b4cbfea" translate="yes" xml:space="preserve">
          <source>Defining a custom hunk-header</source>
          <target state="translated">커스텀 덩어리 헤더 정의하기</target>
        </trans-unit>
        <trans-unit id="ca3594ffd9ab11c72c2e8d78b4c8b59973682e4f" translate="yes" xml:space="preserve">
          <source>Defining a custom merge driver</source>
          <target state="translated">사용자 정의 병합 드라이버 정의</target>
        </trans-unit>
        <trans-unit id="9708d6426545c2cece09aff33765fae2b095ca8b" translate="yes" xml:space="preserve">
          <source>Defining an external diff driver</source>
          <target state="translated">외부 diff 드라이버 정의</target>
        </trans-unit>
        <trans-unit id="eeff7bb1e3fba8a2873ef88f8308472b5d5082ff" translate="yes" xml:space="preserve">
          <source>Defining attributes per path</source>
          <target state="translated">경로 별 속성 정의</target>
        </trans-unit>
        <trans-unit id="c0c022d1a19819ea36656f34517c46cf40cc0616" translate="yes" xml:space="preserve">
          <source>Defining macro attributes</source>
          <target state="translated">매크로 속성 정의</target>
        </trans-unit>
        <trans-unit id="6bc10970bef0d1a497b62db2ecbaba494c65fd0f" translate="yes" xml:space="preserve">
          <source>Defining submodule properties</source>
          <target state="translated">하위 모듈 속성 정의</target>
        </trans-unit>
        <trans-unit id="b40047a3b93162ae49d16e0fd58c1fcd8942970b" translate="yes" xml:space="preserve">
          <source>Deinitialized submodule: A &lt;code&gt;gitlink&lt;/code&gt;, and a &lt;code&gt;.gitmodules&lt;/code&gt; entry, but no submodule working directory. The submodule&amp;rsquo;s Git directory may be there as after deinitializing the Git directory is kept around. The directory which is supposed to be the working directory is empty instead.</source>
          <target state="translated">Deinitialized 서브 모듈, &amp;bull;의 &lt;code&gt;gitlink&lt;/code&gt; 및 &lt;code&gt;.gitmodules&lt;/code&gt; 의 항목,하지만 서브 모듈 작업 디렉토리. 서브 모듈의 Git 디렉토리는 Git 디렉토리를 초기화 해제 한 후 그대로 유지 될 수 있습니다. 작업 디렉토리로되어있는 디렉토리가 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4c200bb0d1f7ba2b7c3e166470a4cb39be0daab" translate="yes" xml:space="preserve">
          <source>Delay</source>
          <target state="translated">Delay</target>
        </trans-unit>
        <trans-unit id="ce169dc044a35b855e4edb1b1a97682afa804f83" translate="yes" xml:space="preserve">
          <source>Delete &amp;lt;ref&amp;gt; after verifying it exists with &amp;lt;oldvalue&amp;gt;, if given. If given, &amp;lt;oldvalue&amp;gt; may not be zero.</source>
          <target state="translated">제공된 경우 &amp;lt;oldvalue&amp;gt;와 함께 존재하는지 확인한 후 &amp;lt;ref&amp;gt;를 삭제하십시오. 주어진 경우, &amp;lt;oldvalue&amp;gt;는 0이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a38bab2ae9dd8b2cb4a0dc3ff8ff31445d9e605" translate="yes" xml:space="preserve">
          <source>Delete a branch. The branch must be fully merged in its upstream branch, or in &lt;code&gt;HEAD&lt;/code&gt; if no upstream was set with &lt;code&gt;--track&lt;/code&gt; or &lt;code&gt;--set-upstream-to&lt;/code&gt;.</source>
          <target state="translated">지점을 삭제하십시오. &lt;code&gt;--track&lt;/code&gt; 또는 &lt;code&gt;--set-upstream-to&lt;/code&gt; 로 설정된 업스트림이없는 경우 브랜치는 업스트림 브랜치 또는 &lt;code&gt;HEAD&lt;/code&gt; 에 완전히 병합해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e9f3df8cb2d062f0173b4dadd305c9e0eadc7f1f" translate="yes" xml:space="preserve">
          <source>Delete an unneeded branch</source>
          <target state="translated">불필요한 지점 삭제</target>
        </trans-unit>
        <trans-unit id="3627df6f5c316b48c9a0e828b45ee4b23f9a149d" translate="yes" xml:space="preserve">
          <source>Delete existing replace refs for the given objects.</source>
          <target state="translated">주어진 객체에 대한 기존 교체 참조를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="6b8d128c004ee953175f88ab766106d4cfa01d06" translate="yes" xml:space="preserve">
          <source>Delete existing tags with the given names.</source>
          <target state="translated">이름이 지정된 기존 태그를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="ec34ecd3e43b7835223d180bb5b62d7a1f50ff85" translate="yes" xml:space="preserve">
          <source>Delete the &quot;test&quot; branch even if the &quot;master&quot; branch (or whichever branch is currently checked out) does not have all commits from the test branch.</source>
          <target state="translated">&quot;마스터&quot;브랜치 (또는 현재 체크 아웃 한 브랜치)에 테스트 브랜치의 커밋이 모두없는 경우에도 &quot;테스트&quot;브랜치를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="5060fa25753a50b8acf6be2071a5d6f5afc4acd3" translate="yes" xml:space="preserve">
          <source>Delete the pack-files that are tracked by the MIDX file, but have no objects referenced by the MIDX. Rewrite the MIDX file afterward to remove all references to these pack-files.</source>
          <target state="translated">MIDX 파일에서 추적하지만 MIDX에서 참조하는 오브젝트가없는 팩 파일을 삭제하십시오. 이 팩 파일에 대한 모든 참조를 제거하려면 나중에 MIDX 파일을 다시 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="34a0e7fb9687c81637f401d26cc5a141535336e8" translate="yes" xml:space="preserve">
          <source>Delete the remote-tracking branches &quot;todo&quot;, &quot;html&quot; and &quot;man&quot;. The next &lt;code&gt;fetch&lt;/code&gt; or &lt;code&gt;pull&lt;/code&gt; will create them again unless you configure them not to. See &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">원격 추적 분기 &quot;todo&quot;, &quot;html&quot;및 &quot;man&quot;을 삭제하십시오. 다음 &lt;code&gt;fetch&lt;/code&gt; 또는 &lt;code&gt;pull&lt;/code&gt; 은 구성하지 않으면 다시 작성합니다. &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="48060c17f13289e334a3727f4f1de95de800b004" translate="yes" xml:space="preserve">
          <source>Delete the symbolic ref &amp;lt;name&amp;gt;.</source>
          <target state="translated">기호 참조 &amp;lt;name&amp;gt;을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="0b8a7c3943e03f2a2e8f697e98962af3bfbc2534" translate="yes" xml:space="preserve">
          <source>Deleted submodule: A submodule can be deleted by running &lt;code&gt;git rm &amp;lt;submodule path&amp;gt; &amp;amp;&amp;amp; git commit&lt;/code&gt;. This can be undone using &lt;code&gt;git revert&lt;/code&gt;.</source>
          <target state="translated">삭제 된 서브 모듈 : &lt;code&gt;git rm &amp;lt;submodule path&amp;gt; &amp;amp;&amp;amp; git commit&lt;/code&gt; 을 실행하여 서브 모듈을 삭제할 수 있습니다 . &lt;code&gt;git revert&lt;/code&gt; 사용하여 취소 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bbae550cd78e8e22873a526e5dae0892e13b85e4" translate="yes" xml:space="preserve">
          <source>Deletes stale references associated with &amp;lt;name&amp;gt;. By default, stale remote-tracking branches under &amp;lt;name&amp;gt; are deleted, but depending on global configuration and the configuration of the remote we might even prune local tags that haven&amp;rsquo;t been pushed there. Equivalent to &lt;code&gt;git
fetch --prune &amp;lt;name&amp;gt;&lt;/code&gt;, except that no new references will be fetched.</source>
          <target state="translated">&amp;lt;name&amp;gt;과 관련된 오래된 참조를 삭제합니다. 기본적으로 &amp;lt;name&amp;gt; 아래의 오래된 원격 추적 분기는 삭제되지만 전역 구성 및 원격 구성에 따라 푸시되지 않은 로컬 태그를 제거 할 수도 있습니다. 새로운 참조가 페치되지 않는다는 점을 제외하고 &lt;code&gt;git fetch --prune &amp;lt;name&amp;gt;&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="24d8888ac9265ebf12b5751431da3b3a66a3bc35" translate="yes" xml:space="preserve">
          <source>Delimited format</source>
          <target state="translated">구분 된 형식</target>
        </trans-unit>
        <trans-unit id="b2cf66f0df0d42ad5ab4aaeb19f2b65bda3f8e44" translate="yes" xml:space="preserve">
          <source>Delta compression will not be attempted for blobs for paths with the attribute &lt;code&gt;delta&lt;/code&gt; set to false.</source>
          <target state="translated">&lt;code&gt;delta&lt;/code&gt; 속성 이 false로 설정된 경로의 블롭에 대해서는 델타 압축을 시도하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="06d8459b781df550338ff8874296d04e07653551" translate="yes" xml:space="preserve">
          <source>Delta islands</source>
          <target state="translated">델타 섬</target>
        </trans-unit>
        <trans-unit id="1c00a92357090dcc2a4a087a5faeaa3dd4ef60a6" translate="yes" xml:space="preserve">
          <source>Delta islands solve this problem by allowing you to group your refs into distinct &quot;islands&quot;. Pack-objects computes which objects are reachable from which islands, and refuses to make a delta from an object &lt;code&gt;A&lt;/code&gt; against a base which is not present in all of &lt;code&gt;A&lt;/code&gt;'s islands. This results in slightly larger packs (because we miss some delta opportunities), but guarantees that a fetch of one island will not have to recompute deltas on the fly due to crossing island boundaries.</source>
          <target state="translated">델타 아일랜드는 심판을 별개의 &quot;섬&quot;으로 그룹화하여이 문제를 해결합니다. Pack-objects는 어느 섬에서 어느 객체에 도달 할 수 있는지 계산 하고 모든 &lt;code&gt;A&lt;/code&gt; 섬에 존재하지 않는베이스에 대해 객체 &lt;code&gt;A&lt;/code&gt; 에서 델타를 만드는 것을 거부합니다 . 결과적으로 델타 기회가 누락 되었기 때문에 팩이 약간 더 커지지 만 한 섬을 가져 오면 섬 경계를 건너서 델타를 즉시 다시 계산할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="89e6ba5af92c1476da557467d420cb383ed75bc2" translate="yes" xml:space="preserve">
          <source>Deltified representation</source>
          <target state="translated">철저한 표현</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="fcd6a0d5490f96a9ee2d3abff638da71da537fbf" translate="yes" xml:space="preserve">
          <source>Depending on the operation, git will use one of the following refspecs, if you don&amp;rsquo;t provide one on the command line. &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is the name of this file in &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; and &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; defaults to &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">작업에 따라 git은 명령 줄에 하나를 제공하지 않으면 다음 참조 중 하나를 사용합니다. &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 는 &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; 에있는이 파일의 이름 이며 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 의 기본값은 &lt;code&gt;master&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ea16e3702c686bd547a284907194ee7b4ffac191" translate="yes" xml:space="preserve">
          <source>Depot path syntax</source>
          <target state="translated">저장소 경로 구문</target>
        </trans-unit>
        <trans-unit id="1983f893b78285086fe35838f9f2f81d38d4d745" translate="yes" xml:space="preserve">
          <source>Deprecated alias for &lt;code&gt;sendemail.signedoffbycc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sendemail.signedoffbycc&lt;/code&gt; 에 대한 사용되지 않는 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="05b4a62238617bb5a4be973f552dc324fff173a4" translate="yes" xml:space="preserve">
          <source>Deprecated alias for &lt;code&gt;sendemail.smtpEncryption = ssl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sendemail.smtpEncryption = ssl&lt;/code&gt; 대해 사용되지 않는 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="a4db2bebc38aa1316eeea066286d1da6378d7b28" translate="yes" xml:space="preserve">
          <source>Deprecated alias for &lt;code&gt;versionsort.suffix&lt;/code&gt;. Ignored if &lt;code&gt;versionsort.suffix&lt;/code&gt; is set.</source>
          <target state="translated">&lt;code&gt;versionsort.suffix&lt;/code&gt; 에 대해 사용되지 않는 별칭입니다 . &lt;code&gt;versionsort.suffix&lt;/code&gt; 가 설정되어 있으면 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="d156ce209204264f931768dbe9676b2798b77199" translate="yes" xml:space="preserve">
          <source>Deprecated synonym for &lt;code&gt;find-renames=&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;find-renames=&amp;lt;n&amp;gt;&lt;/code&gt; 에 대한 더 이상 사용되지 않는 동의어 .</target>
        </trans-unit>
        <trans-unit id="f08e2766ccb54250d4b3556b2590b15bf5d66a82" translate="yes" xml:space="preserve">
          <source>Dereference tags into object IDs as well. They will be shown with &quot;^{}&quot; appended.</source>
          <target state="translated">태그를 객체 ID로 역 참조합니다. &quot;^ {}&quot;이 (가) 추가되어 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="19ab5a2b07f917835d2a43707ceb85ed7b98a04e" translate="yes" xml:space="preserve">
          <source>Describe the patterns in the sparse-checkout file.</source>
          <target state="translated">스파 스 체크 아웃 파일의 패턴을 설명하십시오.</target>
        </trans-unit>
        <trans-unit id="3adaea2f7c94d999c480c31a9d97431cd4a29972" translate="yes" xml:space="preserve">
          <source>Describe the state of the working tree. When the working tree matches HEAD, the output is the same as &quot;git describe HEAD&quot;. If the working tree has local modification &quot;-dirty&quot; is appended to it. If a repository is corrupt and Git cannot determine if there is local modification, Git will error out, unless &amp;lsquo;--broken&amp;rsquo; is given, which appends the suffix &quot;-broken&quot; instead.</source>
          <target state="translated">작업 트리의 상태를 설명하십시오. 작업 트리가 HEAD와 일치하면 출력은 &quot;git describe HEAD&quot;와 동일합니다. 작업 트리에 로컬 수정이 있으면 &quot;-dirty&quot;가 추가됩니다. 리포지토리가 손상되어 Git에서 로컬 수정이 있는지 확인할 수없는 경우 '--broken'을 지정하지 않으면 Git에서 오류가 발생하여 접미사 &quot;-broken&quot;이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="d6cee108138bd9a1ce855b1d73c719745374ce44" translate="yes" xml:space="preserve">
          <source>Design details</source>
          <target state="translated">디자인 세부 사항</target>
        </trans-unit>
        <trans-unit id="7e2d8329f700e85ec6f60947dd853588b3fee1c7" translate="yes" xml:space="preserve">
          <source>Designed with http and stateless-rpc in mind. With clear flush semantics the http remote helper can simply act as a proxy</source>
          <target state="translated">http 및 stateless-rpc를 염두에두고 설계되었습니다. 명확한 플러시 의미를 사용하여 http 원격 도우미는 단순히 프록시 역할을 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a30dd6eb385d802e85851897aa84247984d6f5fe" translate="yes" xml:space="preserve">
          <source>Detach from the shell. Implies --syslog.</source>
          <target state="translated">껍질에서 분리하십시오. --syslog를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e5497c96dfd8b989db42ae40a552822ac0beda8b" translate="yes" xml:space="preserve">
          <source>Detached head</source>
          <target state="translated">분리 헤드</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="67aa19cf55a723bbb26944cac78345fab055b208" translate="yes" xml:space="preserve">
          <source>Detect copies as well as renames. See also &lt;code&gt;--find-copies-harder&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is specified, it has the same meaning as for &lt;code&gt;-M&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">사본을 감지하고 이름을 바꿉니다. &lt;code&gt;--find-copies-harder&lt;/code&gt; 도 참조하십시오 . 경우 &lt;code&gt;n&lt;/code&gt; 을 지정하고, 그와 동일한 의미를 갖는다 &lt;code&gt;-M&amp;lt;n&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01c2501577dd3675d86bed17ffb08591c732fcb7" translate="yes" xml:space="preserve">
          <source>Detect copies harder. See &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;. A boolean.</source>
          <target state="translated">사본을 더 세게 감지합니다. &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]을&lt;/a&gt; 참조하십시오 . 참이나 거짓.</target>
        </trans-unit>
        <trans-unit id="1b3059b4d74c2df5e3146bf7b20891041e88ba9a" translate="yes" xml:space="preserve">
          <source>Detect copies. See &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;. This can be true, false, or a score as expected by &lt;code&gt;git diff -C&lt;/code&gt;.</source>
          <target state="translated">사본을 감지합니다. &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]을&lt;/a&gt; 참조하십시오 . &lt;code&gt;git diff -C&lt;/code&gt; 에서 예상 한대로 true, false 또는 점수가 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1070111ce881d033aa11a2603f524ec35d0cf5af" translate="yes" xml:space="preserve">
          <source>Detect moved or copied lines within a file. When a commit moves or copies a block of lines (e.g. the original file has A and then B, and the commit changes it to B and then A), the traditional &lt;code&gt;blame&lt;/code&gt; algorithm notices only half of the movement and typically blames the lines that were moved up (i.e. B) to the parent and assigns blame to the lines that were moved down (i.e. A) to the child commit. With this option, both groups of lines are blamed on the parent by running extra passes of inspection.</source>
          <target state="translated">파일 내에서 이동하거나 복사 된 행을 감지합니다. 커밋이 행 블록을 이동하거나 복사하면 (예 : 원본 파일에 A와 B가 있고 커밋이 B와 A로 변경됨) 기존의 &lt;code&gt;blame&lt;/code&gt; 알고리즘은 이동의 절반 만 감지하고 일반적으로 있던 라인을 비난합니다. 부모에게 위로 이동 (즉 B)하고 자식 커밋으로 아래로 이동 된 라인 (예 : A)에 책임을 할당합니다. 이 옵션을 사용하면 추가 검사 패스를 실행하여 두 줄 그룹이 모두 부모에게 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b96566ef127f8d019345c2f29a72c790e874b75" translate="yes" xml:space="preserve">
          <source>Detect renames. If &lt;code&gt;n&lt;/code&gt; is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file&amp;rsquo;s size). For example, &lt;code&gt;-M90%&lt;/code&gt; means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn&amp;rsquo;t changed. Without a &lt;code&gt;%&lt;/code&gt; sign, the number is to be read as a fraction, with a decimal point before it. I.e., &lt;code&gt;-M5&lt;/code&gt; becomes 0.5, and is thus the same as &lt;code&gt;-M50%&lt;/code&gt;. Similarly, &lt;code&gt;-M05&lt;/code&gt; is the same as &lt;code&gt;-M5%&lt;/code&gt;. To limit detection to exact renames, use &lt;code&gt;-M100%&lt;/code&gt;. The default similarity index is 50%.</source>
          <target state="translated">이름 바꾸기를 감지하십시오. 경우 &lt;code&gt;n&lt;/code&gt; 을 지정, 그것은 유사성 지수 임계 값 (파일의 크기에 비해 추가 / 삭제의 예 양)입니다. 예를 들어, &lt;code&gt;-M90%&lt;/code&gt; 는 파일의 90 % 이상이 변경되지 않은 경우 Git이 삭제 / 추가 쌍을 이름 바꾸기로 간주해야 함을 의미합니다. &lt;code&gt;%&lt;/code&gt; 부호가 없으면 숫자는 소수점 앞에 소수점을 사용하여 분수로 읽습니다. 즉, &lt;code&gt;-M5&lt;/code&gt; 는 0.5가되므로 &lt;code&gt;-M50%&lt;/code&gt; 와 같습니다 . 마찬가지로 &lt;code&gt;-M05&lt;/code&gt; 는 -M5 &lt;code&gt;-M5%&lt;/code&gt; 와 동일 합니다. 정확한 이름 변경으로 탐지를 제한하려면 &lt;code&gt;-M100%&lt;/code&gt; 사용 하십시오 . 기본 유사성 지수는 50 %입니다.</target>
        </trans-unit>
        <trans-unit id="6d7e84e2caa06e6a8098c62271376428c6e7bd4b" translate="yes" xml:space="preserve">
          <source>Detect renames. See &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;. Renames will be represented in p4 using explicit &lt;code&gt;move&lt;/code&gt; operations. There is no corresponding option to detect copies, but there are variables for both moves and copies.</source>
          <target state="translated">이름 바꾸기를 감지하십시오. &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]을&lt;/a&gt; 참조하십시오 . 이름은 명시 적 &lt;code&gt;move&lt;/code&gt; 조작을 사용하여 p4로 표시됩니다 . 사본을 감지하는 해당 옵션은 없지만 이동 및 사본에 대한 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ffd73e1a52e577bf08689eed36f6c4de2377e40" translate="yes" xml:space="preserve">
          <source>Detect renames. See &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;. This can be true, false, or a score as expected by &lt;code&gt;git diff -M&lt;/code&gt;.</source>
          <target state="translated">이름 바꾸기를 감지하십시오. &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]을&lt;/a&gt; 참조하십시오 . &lt;code&gt;git diff -M&lt;/code&gt; 에서 예상 한대로 true, false 또는 점수가 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4eef9174ad5648c91981effc420fca59fc15dfb0" translate="yes" xml:space="preserve">
          <source>Determine the reference name to use for a new branch:</source>
          <target state="translated">새 분기에 사용할 참조 이름을 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="2fd1f63eeed6a134512b420d9c8a0d335169ab6d" translate="yes" xml:space="preserve">
          <source>Determine whether there are commits in &lt;code&gt;&amp;lt;head&amp;gt;..&amp;lt;upstream&amp;gt;&lt;/code&gt; that are equivalent to those in the range &lt;code&gt;&amp;lt;limit&amp;gt;..&amp;lt;head&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;limit&amp;gt;..&amp;lt;head&amp;gt;&lt;/code&gt; 범위의 커밋이 &lt;code&gt;&amp;lt;head&amp;gt;..&amp;lt;upstream&amp;gt;&lt;/code&gt; 에 있는지 판별하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3dd19e2791ee2ded730804490298d3d980bfa4d" translate="yes" xml:space="preserve">
          <source>Determines if &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt; should trust the file modification timestamp or not. By default the timestamps are not trusted.</source>
          <target state="translated">&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt; 이 파일 수정 타임 스탬프를 신뢰 할지 여부를 결정합니다 . 기본적으로 타임 스탬프는 신뢰되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e154fe8e767c839e2059b235fd308381f6d8cea3" translate="yes" xml:space="preserve">
          <source>Determines if &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt; shows untracked files in the file list. The default is &quot;true&quot;.</source>
          <target state="translated">&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]이&lt;/a&gt; 추적되지 않은 파일을 파일 목록에 표시 할지 여부를 결정 합니다. 기본값은 &quot;true&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="3f3ff5df4fcb4c5f3c82bb56b168b10367f53dcc" translate="yes" xml:space="preserve">
          <source>Determines if new branches created with &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt; should default to tracking remote branches with matching names or not. Default: &quot;false&quot;.</source>
          <target state="translated">&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]로&lt;/a&gt; 생성 된 새 브랜치 가 기본적으로 이름이 일치하는 원격 브랜치를 추적해야하는지 여부를 결정합니다 . 기본값 : &quot;거짓&quot;</target>
        </trans-unit>
        <trans-unit id="2f06095b37712166bde39a43d96d1f0785678946" translate="yes" xml:space="preserve">
          <source>Determines what to do about the untracked cache feature of the index. It will be kept, if this variable is unset or set to &lt;code&gt;keep&lt;/code&gt;. It will automatically be added if set to &lt;code&gt;true&lt;/code&gt;. And it will automatically be removed, if set to &lt;code&gt;false&lt;/code&gt;. Before setting it to &lt;code&gt;true&lt;/code&gt;, you should check that mtime is working properly on your system. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;. &lt;code&gt;keep&lt;/code&gt; by default, unless &lt;code&gt;feature.manyFiles&lt;/code&gt; is enabled which sets this setting to &lt;code&gt;true&lt;/code&gt; by default.</source>
          <target state="translated">인덱스의 추적되지 않은 캐시 기능에 대해 수행 할 작업을 결정합니다. 이 변수가 설정되지 않았거나 &lt;code&gt;keep&lt;/code&gt; 으로 설정되어 있으면 유지 됩니다. &lt;code&gt;true&lt;/code&gt; 로 설정하면 자동으로 추가됩니다 . 그리고 &lt;code&gt;false&lt;/code&gt; 로 설정하면 자동으로 제거됩니다 . &lt;code&gt;true&lt;/code&gt; 로 설정하기 전에 시스템에서 mtime이 올바르게 작동하는지 확인해야합니다. &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]를&lt;/a&gt; 참조하십시오 . &lt;code&gt;feature.manyFiles&lt;/code&gt; 가 활성화되어 있지 않으면 기본적으로 &lt;code&gt;keep&lt;/code&gt; 되며이 설정 은 기본적 으로 &lt;code&gt;true&lt;/code&gt; 로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="64ca3fdabc3574a39df154eb5758766a9b3dabde" translate="yes" xml:space="preserve">
          <source>Developing against a shared repository</source>
          <target state="translated">공유 저장소에 대한 개발</target>
        </trans-unit>
        <trans-unit id="4359a6a8e374a18f2b4c156842b9c3a0fec4c744" translate="yes" xml:space="preserve">
          <source>Developing with git</source>
          <target state="translated">자식으로 개발</target>
        </trans-unit>
        <trans-unit id="a7a451f70e401e1b204facb3a3e4f97e68c2b291" translate="yes" xml:space="preserve">
          <source>Development cost</source>
          <target state="translated">개발 비용</target>
        </trans-unit>
        <trans-unit id="a2efcf35d137bb5a7503ecfbad3617a7e3a45807" translate="yes" xml:space="preserve">
          <source>Die if the pack contains broken links. For internal use only.</source>
          <target state="translated">팩에 깨진 링크가 있으면 죽습니다. 내부 전용.</target>
        </trans-unit>
        <trans-unit id="c1ab34d973a0a532c231ce665c73c7ea8acc0a78" translate="yes" xml:space="preserve">
          <source>Die if the pack contains broken objects. For internal use only.</source>
          <target state="translated">팩에 깨진 물건이 들어 있으면 죽습니다. 내부 전용.</target>
        </trans-unit>
        <trans-unit id="d986c34724963dfe3d695e6191fc573a97f2025e" translate="yes" xml:space="preserve">
          <source>Die with error code != 0 when a reference is undefined, instead of printing &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">오류 코드 다이! 기준이 정의되어 있지 = 0 대신 인쇄 &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78795c9d90cdad9316079a8696dae908d814a635" translate="yes" xml:space="preserve">
          <source>Die, if the pack contains broken objects or links.</source>
          <target state="translated">팩에 깨진 물건이나 링크가 있으면 죽습니다.</target>
        </trans-unit>
        <trans-unit id="98ae64918b361ad15c4c43eb611e71c996a3c9bc" translate="yes" xml:space="preserve">
          <source>Die, if the pack is larger than &amp;lt;size&amp;gt;.</source>
          <target state="translated">팩이 &amp;lt;size&amp;gt;보다 큰 경우 죽습니다.</target>
        </trans-unit>
        <trans-unit id="cd98a991a043eaea48f8e37b61339dac2bfa9ec4" translate="yes" xml:space="preserve">
          <source>Diff Formatting</source>
          <target state="translated">차이 형식</target>
        </trans-unit>
        <trans-unit id="de7932e0191749b8b9963fe2d05250ad20e02e5f" translate="yes" xml:space="preserve">
          <source>Diff against the &quot;base&quot; version, &quot;our branch&quot; or &quot;their branch&quot; respectively. With these options, diffs for merged entries are not shown.</source>
          <target state="translated">&quot;기본&quot;버전, &quot;우리 지점&quot;또는 &quot;그들의 지점&quot;과 각각 다릅니다. 이 옵션을 사용하면 병합 된 항목의 차이가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d39943b940373b977991e15fc719e23de47c6ceb" translate="yes" xml:space="preserve">
          <source>Diff format for merges</source>
          <target state="translated">병합을위한 Diff 형식</target>
        </trans-unit>
        <trans-unit id="3df1676524ddf0754323048bbcc379e44af54c67" translate="yes" xml:space="preserve">
          <source>Diff formatting</source>
          <target state="translated">Diff 형식</target>
        </trans-unit>
        <trans-unit id="654f69ec27f8d4e0f2ecb2d08ba20e4caaa5cbd4" translate="yes" xml:space="preserve">
          <source>Diff is shown using the specified diff driver. Each driver may specify one or more options, as described in the following section. The options for the diff driver &quot;foo&quot; are defined by the configuration variables in the &quot;diff.foo&quot; section of the Git config file.</source>
          <target state="translated">지정된 diff 드라이버를 사용하여 Diff가 표시됩니다. 각 드라이버는 다음 섹션에서 설명하는 것처럼 하나 이상의 옵션을 지정할 수 있습니다. diff 드라이버 &quot;foo&quot;에 대한 옵션은 Git 구성 파일의 &quot;diff.foo&quot;섹션에있는 구성 변수에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e9752af49676495496d54c49d4451c932889ab3e" translate="yes" xml:space="preserve">
          <source>Diffcore-break: for splitting up complete rewrites</source>
          <target state="translated">Diffcore-break : 전체 재 작성 분할</target>
        </trans-unit>
        <trans-unit id="f8cbeab8828f936b2faf8e2c773445ac763403ab" translate="yes" xml:space="preserve">
          <source>Diffcore-merge-broken: for putting complete rewrites back together</source>
          <target state="translated">Diffcore-Merge-broken : 전체 다시 쓰기를 다시 합치기</target>
        </trans-unit>
        <trans-unit id="037fc9af4089dca681837ff54ffb59e13b625177" translate="yes" xml:space="preserve">
          <source>Diffcore-order: for sorting the output based on filenames</source>
          <target state="translated">Diffcore-order : 파일 이름을 기준으로 출력 정렬</target>
        </trans-unit>
        <trans-unit id="93ec538cb6f31f250a629fbfef107579093c9275" translate="yes" xml:space="preserve">
          <source>Diffcore-pickaxe: for detecting addition/deletion of specified string</source>
          <target state="translated">Diffcore-pickaxe : 지정된 문자열의 추가 / 삭제 감지</target>
        </trans-unit>
        <trans-unit id="be51b7621711d155d6251fd428e07de999420e36" translate="yes" xml:space="preserve">
          <source>Diffcore-rename: for detecting renames and copies</source>
          <target state="translated">Diffcore-rename : 이름 변경 및 복사본 감지</target>
        </trans-unit>
        <trans-unit id="339450e1f1c9c473dd2ab70ee2a31028e8f96d6e" translate="yes" xml:space="preserve">
          <source>Directed acyclic graph. The &lt;a href=&quot;#def_commit_object&quot;&gt;commit objects&lt;/a&gt; form a directed acyclic graph, because they have parents (directed), and the graph of commit objects is acyclic (there is no &lt;a href=&quot;#def_chain&quot;&gt;chain&lt;/a&gt; which begins and ends with the same &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt;).</source>
          <target state="translated">방향성 비순환 그래프. 는 &lt;a href=&quot;#def_commit_object&quot;&gt;객체가 커밋&lt;/a&gt; (전혀 없다가 부모 (지시)가 있기 때문에, 방향성 비순환 그래프 (directed acyclic graph)를 형성하고, 물체 커밋의 그래프가 비순환 &lt;a href=&quot;#def_chain&quot;&gt;체인&lt;/a&gt; 동일한 시작 및 종료 &lt;a href=&quot;#def_object&quot;&gt;오브젝트&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c625315e724838d98d1c1aabd8894d579826b898" translate="yes" xml:space="preserve">
          <source>Directly insert the specified info into the index. For backward compatibility, you can also give these three arguments as three separate parameters, but new users are encouraged to use a single-parameter form.</source>
          <target state="translated">지정된 정보를 색인에 직접 삽입하십시오. 이전 버전과의 호환성을 위해이 세 가지 인수를 세 개의 개별 매개 변수로 제공 할 수도 있지만 새 사용자는 단일 매개 변수 형식을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9885bf10483d3b24cb6bcd826a7eb7299ae266e3" translate="yes" xml:space="preserve">
          <source>Directory in which to place the individual messages.</source>
          <target state="translated">개별 메시지를 배치 할 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="bdcdfee6c90a03fd94f3c634dadb758ff39de642" translate="yes" xml:space="preserve">
          <source>Directory rename detection</source>
          <target state="translated">디렉토리 이름 변경 감지</target>
        </trans-unit>
        <trans-unit id="aa2b3e6516957862f26d56361af6f4de78735eee" translate="yes" xml:space="preserve">
          <source>Directory rename detection works with the merge backend to provide you warnings in such cases.</source>
          <target state="translated">디렉토리 이름 변경 감지는 병합 백엔드와 함께 작동하여 이러한 경우 경고를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0c0e7bc3f2d3ebf022d4ca57e3f30fa5aada7044" translate="yes" xml:space="preserve">
          <source>Directory rename heuristics are enabled in the merge and interactive backends. Due to the lack of accurate tree information, directory rename detection is disabled in the am backend.</source>
          <target state="translated">디렉토리 이름 바꾸기 휴리스틱은 병합 및 대화식 백엔드에서 활성화됩니다. 정확한 트리 정보가 없기 때문에 am 백엔드에서 디렉토리 이름 바꾸기 감지가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="8016592b1dadffa6a4ff10aa4ea912d754ba679a" translate="yes" xml:space="preserve">
          <source>Disable SMTP authentication. Short hand for &lt;code&gt;--smtp-auth=none&lt;/code&gt;</source>
          <target state="translated">SMTP 인증을 비활성화하십시오. &lt;code&gt;--smtp-auth=none&lt;/code&gt; 에 대한 짧은 손</target>
        </trans-unit>
        <trans-unit id="8effb38233ed8f993bad8ba7def3e4c7198d5381" translate="yes" xml:space="preserve">
          <source>Disable all charset re-coding of the metadata.</source>
          <target state="translated">메타 데이터의 모든 문자셋 재 코딩을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="bff793fc9150fa9cc2d296006f1d7ecf24724c75" translate="yes" xml:space="preserve">
          <source>Disable all logging.</source>
          <target state="translated">모든 로깅을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="6a02367b3dfa3269f43aabd8b369dc39498517bc" translate="yes" xml:space="preserve">
          <source>Disable all output of the program. Implies &lt;code&gt;--exit-code&lt;/code&gt;.</source>
          <target state="translated">프로그램의 모든 출력을 비활성화하십시오. &lt;code&gt;--exit-code&lt;/code&gt; 를 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="d72da5aaef63acc8729bbf0d8f490956106bf35b" translate="yes" xml:space="preserve">
          <source>Disable output of diffs for merge commits (default). Useful to override &lt;code&gt;-m&lt;/code&gt;, &lt;code&gt;-c&lt;/code&gt;, or &lt;code&gt;--cc&lt;/code&gt;.</source>
          <target state="translated">병합 커밋에 대한 diff 출력을 비활성화합니다 (기본값). &lt;code&gt;-m&lt;/code&gt; , &lt;code&gt;-c&lt;/code&gt; 또는 &lt;code&gt;--cc&lt;/code&gt; 를 재정의하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="65ffdeb8d93ba1775007aefed8ede380f65dc5fc" translate="yes" xml:space="preserve">
          <source>Disable recursive fetching of submodules (this has the same effect as using the &lt;code&gt;--recurse-submodules=no&lt;/code&gt; option).</source>
          <target state="translated">하위 모듈의 재귀 적 페칭을 비활성화합니다 ( &lt;code&gt;--recurse-submodules=no&lt;/code&gt; 옵션 을 사용하는 것과 동일한 효과 ).</target>
        </trans-unit>
        <trans-unit id="9197fea967c3dddcae2815fd5c61af7013500ac4" translate="yes" xml:space="preserve">
          <source>Disable sparse checkout support even if &lt;code&gt;core.sparseCheckout&lt;/code&gt; is true.</source>
          <target state="translated">&lt;code&gt;core.sparseCheckout&lt;/code&gt; 이 true 인 경우에도 스파 스 체크 아웃 지원을 비활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="90bc67ccb52fc4f00ea5bb7d3ea677b5d866b7a3" translate="yes" xml:space="preserve">
          <source>Disable the &lt;code&gt;core.sparseCheckout&lt;/code&gt; config setting, and restore the working directory to include all files. Leaves the sparse-checkout file intact so a later &lt;code&gt;git sparse-checkout init&lt;/code&gt; command may return the working directory to the same state.</source>
          <target state="translated">&lt;code&gt;core.sparseCheckout&lt;/code&gt; 구성 설정을 비활성화하고 모든 파일을 포함하도록 작업 디렉토리를 복원하십시오. 나중에 &lt;code&gt;git sparse-checkout init&lt;/code&gt; 명령이 작업 디렉토리를 동일한 상태로 되돌릴 수 있도록 스파 스 체크 아웃 파일을 그대로 둡니다 .</target>
        </trans-unit>
        <trans-unit id="850c7ae0114510cb68dad1845148d77f171826d0" translate="yes" xml:space="preserve">
          <source>Disable the automatic rebase after all commits have been successfully submitted. Can also be set with git-p4.disableRebase.</source>
          <target state="translated">모든 커밋이 성공적으로 제출 된 후 자동 리베이스를 비활성화합니다. git-p4.disableRebase로 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="70abb355de69ea1d7f24feac052795b5a3ce287a" translate="yes" xml:space="preserve">
          <source>Disable the automatic sync of p4/master from Perforce after commits have been submitted. Implies --disable-rebase. Can also be set with git-p4.disableP4Sync. Sync with origin/master still goes ahead if possible.</source>
          <target state="translated">커밋이 제출 된 후 Perforce에서 p4 / master의 자동 동기화를 비활성화합니다. --disable-rebase를 의미합니다. git-p4.disableP4Sync로 설정할 수도 있습니다. 가능하면 출발지 / 마스터와 동기화가 계속 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="81f65186f299582e8d75d06c846cd0089af76798" translate="yes" xml:space="preserve">
          <source>Disable the creation of an attachment, overriding the configuration setting.</source>
          <target state="translated">구성 설정을 대체하여 첨부 파일 작성을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="bf4cee356cf7010ff2baed05e8bfe18333a1862b" translate="yes" xml:space="preserve">
          <source>Disable the indent heuristic.</source>
          <target state="translated">들여 쓰기 휴리스틱을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="ca23a42f95c7adc909029c511091f97b9f4f227c" translate="yes" xml:space="preserve">
          <source>Disable the output shown by --stats, making fast-import usually be silent when it is successful. However, if the import stream has directives intended to show user output (e.g. &lt;code&gt;progress&lt;/code&gt; directives), the corresponding messages will still be shown.</source>
          <target state="translated">--stats로 표시되는 출력을 비활성화하여 빠른 가져 오기가 성공하면 일반적으로 자동 처리됩니다. 그러나 가져 오기 스트림에 사용자 출력을 표시하기위한 지시문 (예 : &lt;code&gt;progress&lt;/code&gt; 지시문)이있는 경우 해당 메시지가 계속 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="10ad29909e3f37bb2f27c987f74a4679173f8135" translate="yes" xml:space="preserve">
          <source>Disable the use of format=flowed: Edit..Preferences..Advanced..Config Editor. Search for &quot;mailnews.send_plaintext_flowed&quot;. Toggle it to make sure it is set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">format = flowed : Edit..Preferences..Advanced..Config Editor 사용을 비활성화하십시오. &quot;mailnews.send_plaintext_flowed&quot;를 검색하십시오. &lt;code&gt;false&lt;/code&gt; 로 설정되도록 전환하십시오 .</target>
        </trans-unit>
        <trans-unit id="858dc1d60e7e85d31f91783e5cf3256c04a8098e" translate="yes" xml:space="preserve">
          <source>Disable word diff again.</source>
          <target state="translated">단어 diff를 다시 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="52c6bf677e030bd9b9c77d01d12b29e894c5d472" translate="yes" xml:space="preserve">
          <source>Disables the &lt;code&gt;renormalize&lt;/code&gt; option. This overrides the &lt;code&gt;merge.renormalize&lt;/code&gt; configuration variable.</source>
          <target state="translated">&lt;code&gt;renormalize&lt;/code&gt; 옵션을 비활성화합니다 . 이는 &lt;code&gt;merge.renormalize&lt;/code&gt; 구성 변수를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="493a0332cb486f682d77bc8e837afda65d0ed478" translate="yes" xml:space="preserve">
          <source>Disallow external diff drivers.</source>
          <target state="translated">외부 diff 드라이버를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ede3a1ef0a8990ff80cb58919eb8be7140b4f5fa" translate="yes" xml:space="preserve">
          <source>Discard the specified revision as well, keeping the nearest parent instead.</source>
          <target state="translated">가장 가까운 부모를 유지하면서 지정된 개정판도 폐기하십시오.</target>
        </trans-unit>
        <trans-unit id="8fb937b602b4f2ef21c7fab00ac15de3b3ba49ea" translate="yes" xml:space="preserve">
          <source>Discussion</source>
          <target state="translated">Discussion</target>
        </trans-unit>
        <trans-unit id="f1c3b4b6756e9452cf8283101c3b08d9ce1ba40d" translate="yes" xml:space="preserve">
          <source>Discussion on fork-point mode</source>
          <target state="translated">포크 포인트 모드에 대한 토론</target>
        </trans-unit>
        <trans-unit id="cb8eae11c31d8b3c1e7747fe036d2ab3b1d1b780" translate="yes" xml:space="preserve">
          <source>Display branch listing in columns. See configuration variable column.branch for option syntax.&lt;code&gt;--column&lt;/code&gt; and &lt;code&gt;--no-column&lt;/code&gt; without options are equivalent to &lt;code&gt;always&lt;/code&gt; and &lt;code&gt;never&lt;/code&gt; respectively.</source>
          <target state="translated">분기 목록을 열로 표시하십시오. 옵션 구문은 구성 변수 column.branch를 참조하십시오. 옵션이없는 &lt;code&gt;--column&lt;/code&gt; 및 &lt;code&gt;--no-column&lt;/code&gt; 은 &lt;code&gt;always&lt;/code&gt; 및 &lt;code&gt;never&lt;/code&gt; 와 각각 같습니다.</target>
        </trans-unit>
        <trans-unit id="25deb208645941865b584087b241dc58f16bb18f" translate="yes" xml:space="preserve">
          <source>Display data in columns</source>
          <target state="translated">열에 데이터 표시</target>
        </trans-unit>
        <trans-unit id="00fa8df96d22edc1ad7e63a08b37f36b16a61d74" translate="yes" xml:space="preserve">
          <source>Display diffs for the current state of the resolution. It is useful for tracking what has changed while the user is resolving conflicts. Additional arguments are passed directly to the system &lt;code&gt;diff&lt;/code&gt; command installed in PATH.</source>
          <target state="translated">해상도의 현재 상태에 대한 차이를 표시합니다. 사용자가 충돌을 해결하는 동안 변경된 사항을 추적하는 데 유용합니다. 추가 인수는 PATH에 설치된 시스템 &lt;code&gt;diff&lt;/code&gt; 명령으로 직접 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="a0cdcc7c7b07a8e4a90c3d5151fd195fb7223cf9" translate="yes" xml:space="preserve">
          <source>Display gitattributes information</source>
          <target state="translated">gitattributes 정보 표시</target>
        </trans-unit>
        <trans-unit id="941f2ea6c160e300fb40d6a55431420274d37d56" translate="yes" xml:space="preserve">
          <source>Display help information about Git</source>
          <target state="translated">Git에 대한 도움말 정보 표시</target>
        </trans-unit>
        <trans-unit id="5a9a3798add08be0e1f47ed8edfc2983b20e1a95" translate="yes" xml:space="preserve">
          <source>Display manual page for the command in the &lt;code&gt;info&lt;/code&gt; format. The &lt;code&gt;info&lt;/code&gt; program will be used for that purpose.</source>
          <target state="translated">&lt;code&gt;info&lt;/code&gt; 형식 의 명령에 대한 매뉴얼 페이지를 표시하십시오 . &lt;code&gt;info&lt;/code&gt; 프로그램은 그 목적을 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e1ec38994d3bd8f0be2469bcb050567ebcdb5526" translate="yes" xml:space="preserve">
          <source>Display manual page for the command in the &lt;code&gt;man&lt;/code&gt; format. This option may be used to override a value set in the &lt;code&gt;help.format&lt;/code&gt; configuration variable.</source>
          <target state="translated">&lt;code&gt;man&lt;/code&gt; 형식 의 명령에 대한 매뉴얼 페이지를 표시하십시오 . 이 옵션은 &lt;code&gt;help.format&lt;/code&gt; 구성 변수에 설정된 값을 대체하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92ffa56daac223805fbe702e38ef997d8109fbdd" translate="yes" xml:space="preserve">
          <source>Display manual page for the command in the &lt;code&gt;web&lt;/code&gt; (HTML) format. A web browser will be used for that purpose.</source>
          <target state="translated">명령에 대한 매뉴얼 페이지를 &lt;code&gt;web&lt;/code&gt; (HTML) 형식으로 표시하십시오. 이를 위해 웹 브라우저가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3b82a6e6a357a0bf9773d3a79c96ba1e61e31cb" translate="yes" xml:space="preserve">
          <source>Display or do not display detailed ahead/behind counts for the branch relative to its upstream branch. Defaults to true.</source>
          <target state="translated">업스트림 브랜치를 기준으로 브랜치에 대한 자세한 앞 / 뒤 카운트를 표시하거나 표시하지 않습니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="f65810bba6d242e31829fe1b50da76b80381c4b9" translate="yes" xml:space="preserve">
          <source>Display some basic statistics about the objects fast-import has created, the packfiles they were stored into, and the memory used by fast-import during this run. Showing this output is currently the default, but can be disabled with --quiet.</source>
          <target state="translated">빠른 가져 오기에서 생성 한 객체, 저장된 팩 파일 및이 실행 중에 빠른 가져 오기에 사용 된 메모리에 대한 몇 가지 기본 통계를 표시합니다. 이 출력을 표시하는 것이 현재 기본값이지만 --quiet로 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64158f1a0a1ec112852f04c5185015874a0e4c81" translate="yes" xml:space="preserve">
          <source>Display specific annotated tag (tag object).</source>
          <target state="translated">주석이 달린 특정 태그 (태그 객체)를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c6c2de616f34899ad73b615717fbe54f7ad5df4c" translate="yes" xml:space="preserve">
          <source>Display tag listing in columns. See configuration variable column.tag for option syntax.&lt;code&gt;--column&lt;/code&gt; and &lt;code&gt;--no-column&lt;/code&gt; without options are equivalent to &lt;code&gt;always&lt;/code&gt; and &lt;code&gt;never&lt;/code&gt; respectively.</source>
          <target state="translated">열에 태그 목록을 표시합니다. 옵션 구문은 구성 변수 column.tag를 참조하십시오. 옵션이없는 &lt;code&gt;--column&lt;/code&gt; 및 &lt;code&gt;--no-column&lt;/code&gt; 은 &lt;code&gt;always&lt;/code&gt; 및 &lt;code&gt;never&lt;/code&gt; 와 각각 같습니다.</target>
        </trans-unit>
        <trans-unit id="1a3622cde828191996e0ecf195f03d03b3ec44d7" translate="yes" xml:space="preserve">
          <source>Display the currently running version of &lt;code&gt;git gui&lt;/code&gt;.</source>
          <target state="translated">현재 실행중인 &lt;code&gt;git gui&lt;/code&gt; 버전을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="93da4437ffd9aa5715f14a3f0dacdb3439b3cf81" translate="yes" xml:space="preserve">
          <source>Display the full sha1s in the output listing rather than abbreviating them.</source>
          <target state="translated">출력 목록에 전체 sha1을 축약하지 않고 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="9f1c97cf9d8e74c2fc80265ab817ac9d7b832aa6" translate="yes" xml:space="preserve">
          <source>Display untracked files in columns. See configuration variable column.status for option syntax.&lt;code&gt;--column&lt;/code&gt; and &lt;code&gt;--no-column&lt;/code&gt; without options are equivalent to &lt;code&gt;always&lt;/code&gt; and &lt;code&gt;never&lt;/code&gt; respectively.</source>
          <target state="translated">추적되지 않은 파일을 열에 표시합니다. 옵션 구문은 구성 변수 column.status를 참조하십시오. 옵션이없는 &lt;code&gt;--column&lt;/code&gt; 및 &lt;code&gt;--no-column&lt;/code&gt; 은 &lt;code&gt;always&lt;/code&gt; 및 &lt;code&gt;never&lt;/code&gt; 와 각각 같습니다.</target>
        </trans-unit>
        <trans-unit id="7092e241896d60ac87e32bb3193290cccc38af84" translate="yes" xml:space="preserve">
          <source>Display usage.</source>
          <target state="translated">사용법을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7079ee902153dd291ddf916bbe088b722407f696" translate="yes" xml:space="preserve">
          <source>Displays changes in a repository or a selected set of commits. This includes visualizing the commit graph, showing information related to each commit, and the files in the trees of each revision.</source>
          <target state="translated">저장소 또는 선택된 커밋 세트의 변경 사항을 표시합니다. 여기에는 커밋 그래프 시각화, 각 커밋과 관련된 정보 및 각 개정판의 트리에있는 파일 표시가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="298c129f2e50c144c7e71d42c00becc8dea6a583" translate="yes" xml:space="preserve">
          <source>Displays paths that have differences between the index file and the current HEAD commit, paths that have differences between the working tree and the index file, and paths in the working tree that are not tracked by Git (and are not ignored by &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;). The first are what you &lt;code&gt;would&lt;/code&gt; commit by running &lt;code&gt;git commit&lt;/code&gt;; the second and third are what you &lt;code&gt;could&lt;/code&gt; commit by running &lt;code&gt;git add&lt;/code&gt; before running &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">인덱스 파일과 현재 HEAD 커밋간에 차이가있는 경로, 작업 트리와 인덱스 파일 사이에 차이가있는 경로 및 Git에서 추적하지 않는 작업 트리의 경로를 표시합니다 ( &lt;a href=&quot;gitignore&quot;&gt;gitignore에서&lt;/a&gt; 무시되지 않음 [5] ). 첫 번째는 &lt;code&gt;git commit&lt;/code&gt; 을 실행하여 커밋하는 &lt;code&gt;would&lt;/code&gt; . 두 번째와 세 번째는 당신이 무엇을 &lt;code&gt;could&lt;/code&gt; 실행하여 커밋 &lt;code&gt;git add&lt;/code&gt; 실행하기 전에 &lt;code&gt;git commit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a629570fab6639c414ba6b626507dad99fc801af" translate="yes" xml:space="preserve">
          <source>Displays references available in a local repository along with the associated commit IDs. Results can be filtered using a pattern and tags can be dereferenced into object IDs. Additionally, it can be used to test whether a particular ref exists.</source>
          <target state="translated">연관된 커밋 ID와 함께 로컬 저장소에서 사용 가능한 참조를 표시합니다. 패턴을 사용하여 결과를 필터링하고 태그를 객체 ID로 역 참조 할 수 있습니다. 또한 특정 심판이 존재하는지 테스트하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="552e170818d4ff73bae847a17956173c4cb34b11" translate="yes" xml:space="preserve">
          <source>Displays references available in a remote repository along with the associated commit IDs.</source>
          <target state="translated">연관된 커밋 ID와 함께 원격 저장소에서 사용 가능한 참조를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="96528dc0170b433d5bf734338e53f84118e8892f" translate="yes" xml:space="preserve">
          <source>Displays summary about given repository. This is the default command if no action is specified in URL, and only repository is specified.</source>
          <target state="translated">지정된 저장소에 대한 요약을 표시합니다. URL에 조치가 지정되지 않고 저장소 만 지정된 경우 이것이 기본 명령입니다.</target>
        </trans-unit>
        <trans-unit id="a0bdba2bfb43b133e65f6e75b6b8767f5a655c4d" translate="yes" xml:space="preserve">
          <source>Distributed workflows</source>
          <target state="translated">분산 워크 플로우</target>
        </trans-unit>
        <trans-unit id="862f8a0b24f2fede02b5c7614fea634d5e3205d5" translate="yes" xml:space="preserve">
          <source>Do everything except actually send the emails.</source>
          <target state="translated">실제로 이메일을 보내는 것을 제외한 모든 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c0cf7c46b6d09d46245bbf190b286bb681387914" translate="yes" xml:space="preserve">
          <source>Do everything except actually send the updates.</source>
          <target state="translated">실제로 업데이트 보내기를 제외한 모든 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="2391ab0a15e29de8c553f138bc9a5e5e1eff2f5d" translate="yes" xml:space="preserve">
          <source>Do not GPG-sign commit, to countermand a &lt;code&gt;--gpg-sign&lt;/code&gt; option given earlier on the command line.</source>
          <target state="translated">명령 행에서 이전에 제공된 &lt;code&gt;--gpg-sign&lt;/code&gt; 옵션 을 방지하기 위해 GPG-sign commit을 수행하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="e60712f9f236c24928017c46a4121b75b37250b5" translate="yes" xml:space="preserve">
          <source>Do not actually prune any entries; just show what would have been pruned.</source>
          <target state="translated">실제로 항목을 제거하지 마십시오. 정리 된 내용 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c1e5372fe0faa123824db425165ec2fea2793861" translate="yes" xml:space="preserve">
          <source>Do not add the Message-ID header to the commit message. &lt;code&gt;no-message-id&lt;/code&gt; is useful to override &lt;code&gt;am.messageid&lt;/code&gt;.</source>
          <target state="translated">커밋 메시지에 Message-ID 헤더를 추가하지 마십시오. &lt;code&gt;no-message-id&lt;/code&gt; 는 &lt;code&gt;am.messageid&lt;/code&gt; 를 재정의하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="57e3f3ba3ed0b684d610d78f35decbf2d82cbdb0" translate="yes" xml:space="preserve">
          <source>Do not assume that the remote repository is complete in its current state, and verify all objects in the entire local ref&amp;rsquo;s history exist in the remote repository.</source>
          <target state="translated">원격 저장소가 현재 상태에서 완료되었다고 가정하지 말고 전체 로컬 참조 히스토리의 모든 오브젝트가 원격 저장소에 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="90fec1270ba2d2b20ae4223418ef68e2bfdd8b58" translate="yes" xml:space="preserve">
          <source>Do not change the message at all.</source>
          <target state="translated">메시지를 전혀 바꾸지 마십시오.</target>
        </trans-unit>
        <trans-unit id="08226113a8a9e7f80d0cdebc9507aad8bbcea024" translate="yes" xml:space="preserve">
          <source>Do not checkout the new working tree at each iteration of the bisection process. Instead just update a special reference named &lt;code&gt;BISECT_HEAD&lt;/code&gt; to make it point to the commit that should be tested.</source>
          <target state="translated">이분법 프로세스가 반복 될 때마다 새 작업 트리를 체크 아웃하지 마십시오. 대신 테스트해야 할 커밋을 가리 키도록 &lt;code&gt;BISECT_HEAD&lt;/code&gt; 라는 특수 참조를 업데이트하십시오 .</target>
        </trans-unit>
        <trans-unit id="032bbf4a51cb5f8b4c87bc5a87ccbf7ce7d9972e" translate="yes" xml:space="preserve">
          <source>Do not complain about a failed merge program (a merge program failure usually indicates conflicts during the merge). This is for porcelains which might want to emit custom messages.</source>
          <target state="translated">실패한 병합 프로그램에 대해 불평하지 마십시오 (병합 프로그램 실패는 일반적으로 병합 중 충돌을 나타냄). 맞춤 메시지를 내보내려는 도자기를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="828652d2b0b568421d6c7e9bbf13386dea23e106" translate="yes" xml:space="preserve">
          <source>Do not consider commits that are referenced only by an entry in a reflog to be reachable. This option is meant only to search for commits that used to be in a ref, but now aren&amp;rsquo;t, but are still in that corresponding reflog.</source>
          <target state="translated">참조 로그의 항목에 의해서만 참조되는 커밋은 도달 가능한 것으로 간주하지 마십시오. 이 옵션은 참조에 있었지만 현재는 아니지만 해당 참조에있는 커밋을 검색하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="e869fbf733c283b771007d82b91f9b0969cfb747" translate="yes" xml:space="preserve">
          <source>Do not consider it an error to request removing notes from an object that does not have notes attached to it.</source>
          <target state="translated">메모가 첨부되지 않은 개체에서 메모를 제거하도록 요청하는 것은 오류라고 생각하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1ecb147f602b4581f87540a29b063aa61604b712" translate="yes" xml:space="preserve">
          <source>Do not consider tags matching the given &lt;code&gt;glob(7)&lt;/code&gt; pattern, excluding the &quot;refs/tags/&quot; prefix. If used with &lt;code&gt;--all&lt;/code&gt;, it also does not consider local branches and remote-tracking references matching the pattern, excluding respectively &quot;refs/heads/&quot; and &quot;refs/remotes/&quot; prefix; references of other types are never considered. If given multiple times, a list of patterns will be accumulated and tags matching any of the patterns will be excluded. When combined with --match a tag will be considered when it matches at least one --match pattern and does not match any of the --exclude patterns. Use &lt;code&gt;--no-exclude&lt;/code&gt; to clear and reset the list of patterns.</source>
          <target state="translated">&quot;refs / tags /&quot;접두사를 제외하고 주어진 &lt;code&gt;glob(7)&lt;/code&gt; 패턴과 일치하는 태그를 고려하지 마십시오 . &lt;code&gt;--all&lt;/code&gt; 과 함께 사용하는 경우 각각 &quot;refs / heads /&quot;및 &quot;refs / remotes /&quot;접두사를 제외하고 패턴과 일치하는 로컬 분기 및 원격 추적 참조를 고려하지 않습니다. 다른 유형의 참조는 고려되지 않습니다. 여러 번 제공하면 패턴 목록이 누적되고 패턴과 일치하는 태그는 제외됩니다. --match와 결합하면 태그가 하나 이상의 --match 패턴과 일치하고 --exclude 패턴과 일치하지 않을 때 태그가 고려됩니다. 패턴 목록을 지우고 재설정 하려면 &lt;code&gt;--no-exclude&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="037f30ef5e84974359cf44c16519221f2879783e" translate="yes" xml:space="preserve">
          <source>Do not create a commit, but show a list of paths that are to be committed, paths with local changes that will be left uncommitted and paths that are untracked.</source>
          <target state="translated">커밋을 만들지 말고 커밋 할 경로, 커밋되지 않은 로컬 변경 사항이있는 경로 및 추적되지 않은 경로 목록을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="8cc46cc75e4001540bdd6b36d05862e218e46c47" translate="yes" xml:space="preserve">
          <source>Do not create objects in the object database for all &amp;lt;file&amp;gt; arguments that follow this flag; just insert their object IDs into the index.</source>
          <target state="translated">이 플래그 뒤에 오는 모든 &amp;lt;file&amp;gt; 인수에 대해 오브젝트를 오브젝트 데이터베이스에 작성하지 마십시오. 객체 ID를 색인에 삽입하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="7cb5295efb5286a379b8d83e6238db5f1ea1b2fa" translate="yes" xml:space="preserve">
          <source>Do not fetch remotely; only run &lt;code&gt;git rebase&lt;/code&gt; against the last fetched commit from the upstream SVN.</source>
          <target state="translated">원격으로 가져 오지 마십시오. 업스트림 SVN에서 마지막으로 가져온 커밋에 대해서만 &lt;code&gt;git rebase&lt;/code&gt; 를 실행 하십시오.</target>
        </trans-unit>
        <trans-unit id="97bf9439cf9070cedb99b3389632fc0fbbcf9edf" translate="yes" xml:space="preserve">
          <source>Do not honor textconv filter settings. This is the default.</source>
          <target state="translated">textconv 필터 설정을 사용하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="642b94f1b0f16f8086c6d9b3c2a88d58a07a371f" translate="yes" xml:space="preserve">
          <source>Do not ignore whitespace when performing move detection.</source>
          <target state="translated">이동 감지를 수행 할 때 공백을 무시하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="59383a29c043832ab98b518f841a638207c2a6f4" translate="yes" xml:space="preserve">
          <source>Do not ignore whitespace when performing move detection. This can be used to override configuration settings. It is the same as &lt;code&gt;--color-moved-ws=no&lt;/code&gt;.</source>
          <target state="translated">이동 감지를 수행 할 때 공백을 무시하지 마십시오. 구성 설정을 재정의하는 데 사용할 수 있습니다. &lt;code&gt;--color-moved-ws=no&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="f9b8ad508a1efad0691851330497788c20711761" translate="yes" xml:space="preserve">
          <source>Do not include a patch that matches a commit in &amp;lt;until&amp;gt;..&amp;lt;since&amp;gt;. This will examine all patches reachable from &amp;lt;since&amp;gt; but not from &amp;lt;until&amp;gt; and compare them with the patches being generated, and any patch that matches is ignored.</source>
          <target state="translated">&amp;lt;until&amp;gt; .. &amp;lt;since&amp;gt;에 커밋과 일치하는 패치를 포함하지 마십시오. 이것은 &amp;lt;since&amp;gt;에서 도달 할 수 있지만 &amp;lt;until&amp;gt;에서는 도달 할 수없는 모든 패치를 검사하고 생성 된 패치와 비교하며 일치하는 모든 패치는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="06c89fdde45df9764a8423e7bd3a2334bae4fdd3" translate="yes" xml:space="preserve">
          <source>Do not include refs matching &lt;code&gt;&amp;lt;glob-pattern&amp;gt;&lt;/code&gt; that the next &lt;code&gt;--all&lt;/code&gt;, &lt;code&gt;--branches&lt;/code&gt;, &lt;code&gt;--tags&lt;/code&gt;, &lt;code&gt;--remotes&lt;/code&gt;, or &lt;code&gt;--glob&lt;/code&gt; would otherwise consider. Repetitions of this option accumulate exclusion patterns up to the next &lt;code&gt;--all&lt;/code&gt;, &lt;code&gt;--branches&lt;/code&gt;, &lt;code&gt;--tags&lt;/code&gt;, &lt;code&gt;--remotes&lt;/code&gt;, or &lt;code&gt;--glob&lt;/code&gt; option (other options or arguments do not clear accumulated patterns).</source>
          <target state="translated">일치 심판 포함하지 마십시오 &lt;code&gt;&amp;lt;glob-pattern&amp;gt;&lt;/code&gt; 다음 것을 &lt;code&gt;--all&lt;/code&gt; 은 , &lt;code&gt;--branches&lt;/code&gt; , &lt;code&gt;--tags&lt;/code&gt; , &lt;code&gt;--remotes&lt;/code&gt; , 또는 &lt;code&gt;--glob&lt;/code&gt; 는 달리 고려할 것입니다. 다음까지이 옵션 축적 제외 패턴의 반복 &lt;code&gt;--all&lt;/code&gt; 은 , &lt;code&gt;--branches&lt;/code&gt; , &lt;code&gt;--tags&lt;/code&gt; , &lt;code&gt;--remotes&lt;/code&gt; , 또는 &lt;code&gt;--glob&lt;/code&gt; 옵션 (다른 옵션이나 인수는 축적 된 패턴을 취소하지 않음).</target>
        </trans-unit>
        <trans-unit id="56a32ccb3c1f1c18304a762968ab21163044c5c3" translate="yes" xml:space="preserve">
          <source>Do not include the output of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; in the commit message template when using an editor to prepare the default commit message.</source>
          <target state="translated">편집기를 사용하여 기본 커밋 메시지를 준비 할 때 커밋 메시지 템플릿 에 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 의 출력을 포함시키지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="6b5bd4195c1d74a2912285d2c4eb0c2dba4c1afa" translate="yes" xml:space="preserve">
          <source>Do not interpret any more arguments as options.</source>
          <target state="translated">더 이상 인수를 옵션으로 해석하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e5da1b4ac510b79eb35b9d691f72663928bb7698" translate="yes" xml:space="preserve">
          <source>Do not invoke &lt;code&gt;git unpack-objects&lt;/code&gt; on received data, but create a single packfile out of it instead, and store it in the object database. If provided twice then the pack is locked against repacking.</source>
          <target state="translated">수신 된 데이터에 대해 &lt;code&gt;git unpack-objects&lt;/code&gt; 를 호출하지 말고 대신 단일 팩 파일을 작성하여 오브젝트 데이터베이스에 저장하십시오. 두 번 제공된 경우 팩이 다시 포장되지 않도록 잠급니다.</target>
        </trans-unit>
        <trans-unit id="beae705e0d7e9c4e2c66edfac5f5628c8ca8684b" translate="yes" xml:space="preserve">
          <source>Do not issue an error message if the &amp;lt;name&amp;gt; is not a symbolic ref but a detached HEAD; instead exit with non-zero status silently.</source>
          <target state="translated">&amp;lt;name&amp;gt;이 기호 참조가 아니라 분리 된 HEAD 인 경우 오류 메시지를 발행하지 마십시오. 대신 0이 아닌 상태로 자동 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="25d9eebc562b1a06ce597634bc396c0323e9fb5d" translate="yes" xml:space="preserve">
          <source>Do not keep commits that start empty before the rebase (i.e. that do not change anything from its parent) in the result. The default is to keep commits which start empty, since creating such commits requires passing the --allow-empty override flag to &lt;code&gt;git commit&lt;/code&gt;, signifying that a user is very intentionally creating such a commit and thus wants to keep it.</source>
          <target state="translated">결과에서 rebase 이전에 시작하는 커밋 (즉, 부모에서 아무것도 변경하지 않음)을 비워 두지 마십시오. 기본값은 빈 커밋을 유지하는 것입니다. 그러한 커밋을 만들려면 --allow-empty 재정의 플래그를 &lt;code&gt;git commit&lt;/code&gt; 에 전달해야합니다 . 이는 사용자가 매우 의도적으로 커밋을 생성하고 있으므로이를 유지하고자 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d96f65c98da537beaa0a86a4d3aea2125b47b691" translate="yes" xml:space="preserve">
          <source>Do not limit the listing to the current working directory. Implies --full-name.</source>
          <target state="translated">목록을 현재 작업 디렉토리로 제한하지 마십시오. --full-name을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0ec876803cf466a9324414e97bc9d68e8edc56a9" translate="yes" xml:space="preserve">
          <source>Do not list empty directories. Has no effect without --directory.</source>
          <target state="translated">빈 디렉토리를 나열하지 마십시오. --directory 없이는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="96b8b2c721697c15e0778ab602142e2343cf1855" translate="yes" xml:space="preserve">
          <source>Do not list one-line descriptions from the actual commits being merged.</source>
          <target state="translated">병합되는 실제 커밋의 한 줄 설명은 나열하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="50c8933f0d365d96e0aba5401a78a6eff6e0fcc0" translate="yes" xml:space="preserve">
          <source>Do not merge to downstream except with a good reason: upstream API changes affect your branch; your branch no longer merges to upstream cleanly; etc.</source>
          <target state="translated">정당한 이유를 제외하고는 다운 스트림으로 병합하지 마십시오. 업스트림 API 변경은 브랜치에 영향을줍니다. 귀하의 지점은 더 이상 깨끗하게 업스트림으로 병합되지 않습니다. 기타</target>
        </trans-unit>
        <trans-unit id="20453559ed97130ebcc8684bdfc96d4e211050a6" translate="yes" xml:space="preserve">
          <source>Do not notice anything as error.</source>
          <target state="translated">오류로 아무것도 눈치 채지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6c8215f8ad086bc4c804beee0595714130addff4" translate="yes" xml:space="preserve">
          <source>Do not output contents of changes in binary files, instead display a notice that those files changed. Patches generated using this option cannot be applied properly, but they are still useful for code review.</source>
          <target state="translated">이진 파일의 변경 내용을 출력하지 말고 해당 파일이 변경되었다는 알림을 표시하십시오. 이 옵션을 사용하여 생성 된 패치는 올바르게 적용 할 수 없지만 여전히 코드 검토에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2523ea10fe468312c71da3f45d33ec2f934186fc" translate="yes" xml:space="preserve">
          <source>Do not output flag parameters.</source>
          <target state="translated">플래그 매개 변수를 출력하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="97d9ab4b88ae45778b7b3d001e321ad0dc14c371" translate="yes" xml:space="preserve">
          <source>Do not output flags and parameters meant for &lt;code&gt;git rev-list&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;git rev-list&lt;/code&gt; 명령에 사용 되는 플래그 및 매개 변수를 출력하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="f763f44ab0f0b262c4086b5b655e472e8e1fbc54" translate="yes" xml:space="preserve">
          <source>Do not output flags and parameters not meant for &lt;code&gt;git rev-list&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;git rev-list&lt;/code&gt; 명령에 사용 되지 않는 플래그 및 매개 변수를 출력하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="08b6c73b9a5b9ae8b10db84ed02aa9ff12c3dacb" translate="yes" xml:space="preserve">
          <source>Do not output matched lines; instead, exit with status 0 when there is a match and with non-zero status when there isn&amp;rsquo;t.</source>
          <target state="translated">일치하는 줄을 출력하지 마십시오. 대신 일치하는 경우 상태 0으로, 종료되지 않은 경우 0이 아닌 상태로 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="ee712c84633a2927c1551bcb0103dc0873b40235" translate="yes" xml:space="preserve">
          <source>Do not output non-flag parameters.</source>
          <target state="translated">비 플래그 매개 변수를 출력하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="803c0ba19a9790046951938b8c5d1389018a1cc7" translate="yes" xml:space="preserve">
          <source>Do not pay attention to ignored files specified via the &lt;code&gt;.gitignore&lt;/code&gt; mechanism. Only useful when searching files in the current directory with &lt;code&gt;--no-index&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.gitignore&lt;/code&gt; 메커니즘을 통해 지정된 무시 된 파일에주의를 기울이지 마십시오 . &lt;code&gt;--no-index&lt;/code&gt; 를 사용하여 현재 디렉토리에서 파일을 검색 할 때만 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="ac83dbcf3d4693958a0fe122034c7cc31b273fa9" translate="yes" xml:space="preserve">
          <source>Do not perform optional operations that require locks. This is equivalent to setting the &lt;code&gt;GIT_OPTIONAL_LOCKS&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">잠금이 필요한 선택적 작업을 수행하지 마십시오. 이것은 &lt;code&gt;GIT_OPTIONAL_LOCKS&lt;/code&gt; 를 &lt;code&gt;0&lt;/code&gt; 으로 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3857914d38ac6fc1cf3a0581728d470a65e02771" translate="yes" xml:space="preserve">
          <source>Do not pipe Git output into a pager.</source>
          <target state="translated">Git 출력을 호출기로 파이프하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d083af3d8a98a88b0736219c9a712ace923e74ce" translate="yes" xml:space="preserve">
          <source>Do not print any progress information.</source>
          <target state="translated">진행 정보를 인쇄하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4f306796a802facf6a3ec8eb763307ebdfcd6b65" translate="yes" xml:space="preserve">
          <source>Do not print any results to stdout. When combined with &lt;code&gt;--verify&lt;/code&gt; this can be used to silently check if a reference exists.</source>
          <target state="translated">stdout에 결과를 인쇄하지 마십시오. &lt;code&gt;--verify&lt;/code&gt; 와 함께 사용하면 참조가 있는지 자동으로 확인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d36888af86796f130618636768f7e10c682f8ef3" translate="yes" xml:space="preserve">
          <source>Do not print commits with more than one parent. This is exactly the same as &lt;code&gt;--max-parents=1&lt;/code&gt;.</source>
          <target state="translated">둘 이상의 부모와 함께 커밋을 인쇄하지 마십시오. 이것은 &lt;code&gt;--max-parents=1&lt;/code&gt; 과 정확히 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ca4c10c14f4ba2f9f3e2f89755711c5fc9a52157" translate="yes" xml:space="preserve">
          <source>Do not print remote URL to stderr.</source>
          <target state="translated">원격 URL을 stderr에 인쇄하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="808049e7ffec5b6e655b6a9d9ae72d8ecb3de856" translate="yes" xml:space="preserve">
          <source>Do not print the names of the generated files to standard output.</source>
          <target state="translated">생성 된 파일 이름을 표준 출력으로 인쇄하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bc87e43a7d98a5c7571b51e67897a36a4ca8ab2b" translate="yes" xml:space="preserve">
          <source>Do not prompt before launching a diff tool.</source>
          <target state="translated">diff 도구를 시작하기 전에 확인하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2138cd0cdb77e09db32e703a72fd51381cd4185f" translate="yes" xml:space="preserve">
          <source>Do not prune any loose objects.</source>
          <target state="translated">느슨한 물체를 가지 치기하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4ab3f3b957170dab775cfb00bbc8606872c3ea09" translate="yes" xml:space="preserve">
          <source>Do not rebase the tree against p4/master following a submit.</source>
          <target state="translated">제출 후 p4 / master에 대해 트리를 리베이스하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ee64f5e74349135c206f878ac8dae99d11617c4a" translate="yes" xml:space="preserve">
          <source>Do not remove &lt;code&gt;\r&lt;/code&gt; from lines ending with &lt;code&gt;\r\n&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\r\n&lt;/code&gt; 끝나는 줄에서 &lt;code&gt;\r&lt;/code&gt; 을 제거하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="5f6ac36312ee3d608ed232e28cf93ff206d0103e" translate="yes" xml:space="preserve">
          <source>Do not remove anything; just report the object names whose notes would be removed.</source>
          <target state="translated">아무것도 제거하지 마십시오. 메모가 제거 될 개체 이름 만보고하면됩니다.</target>
        </trans-unit>
        <trans-unit id="e1b8d19002620396e3e17ca0d394f58c32270c15" translate="yes" xml:space="preserve">
          <source>Do not remove anything; just report what it would remove.</source>
          <target state="translated">아무것도 제거하지 마십시오. 제거 할 내용 만보고하면됩니다.</target>
        </trans-unit>
        <trans-unit id="04f9e0c42631154ae3b06c4af5993cc618a97379" translate="yes" xml:space="preserve">
          <source>Do not remove skip-worktree (AKA &quot;index-only&quot;) entries even when the &lt;code&gt;--remove&lt;/code&gt; option was specified.</source>
          <target state="translated">&lt;code&gt;--remove&lt;/code&gt; 옵션이 지정된 경우에도 skip-worktree (일명 &quot;인덱스 전용&quot;) 항목을 제거하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="4b9504bc1ba7b31d1b6d4966504b5b4e06f71072" translate="yes" xml:space="preserve">
          <source>Do not report commits up to (and including) limit.</source>
          <target state="translated">커밋을 한계까지보고하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="01c55be9743ceb727e1460223caf6f63698fc951" translate="yes" xml:space="preserve">
          <source>Do not set up &quot;upstream&quot; configuration, even if the &lt;code&gt;branch.autoSetupMerge&lt;/code&gt; configuration variable is true.</source>
          <target state="translated">&lt;code&gt;branch.autoSetupMerge&lt;/code&gt; 구성 변수가 true 인 경우에도 &quot;업스트림&quot;구성을 설정하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="1128ceb9ee850f084ee9c90bbc32c35e1a0677f6" translate="yes" xml:space="preserve">
          <source>Do not set up &quot;upstream&quot; configuration, even if the branch.autoSetupMerge configuration variable is true.</source>
          <target state="translated">branch.autoSetupMerge 구성 변수가 true 인 경우에도 &quot;업스트림&quot;구성을 설정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="040575d6c90a48f5c39a665aeb7044e9eb43b684" translate="yes" xml:space="preserve">
          <source>Do not show a diffstat as part of the rebase process.</source>
          <target state="translated">리베이스 프로세스의 일부로 diffstat를 표시하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6441f1c36e56fb2fa459a5f0796f9c305a9cf68e" translate="yes" xml:space="preserve">
          <source>Do not show any source or destination prefix.</source>
          <target state="translated">소스 또는 대상 접두사를 표시하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c24868a69fc39c6ac2b9ca770ce8aa6841828fe0" translate="yes" xml:space="preserve">
          <source>Do not show naming strings for each commit.</source>
          <target state="translated">각 커밋마다 이름 지정 문자열을 표시하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8fa5b27db8fcf759f01b0280edfd6b3431051bf3" translate="yes" xml:space="preserve">
          <source>Do not show notes. This negates the above &lt;code&gt;--notes&lt;/code&gt; option, by resetting the list of notes refs from which notes are shown. Options are parsed in the order given on the command line, so e.g. &quot;--notes --notes=foo --no-notes --notes=bar&quot; will only show notes from &quot;refs/notes/bar&quot;.</source>
          <target state="translated">메모를 표시하지 마십시오. 음표가 표시되는 음표 참조를 재설정 하여 위의- &lt;code&gt;--notes&lt;/code&gt; 옵션을 무시 합니다. 옵션은 명령 행에 주어진 순서대로 구문 분석되므로 &quot;--notes --notes = foo --no-notes --notes = bar&quot;는 &quot;refs / notes / bar&quot;의 메모 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9b02c841f1914bb7e6442db5b21cd8ed24132388" translate="yes" xml:space="preserve">
          <source>Do not show peeled tags or pseudorefs like &lt;code&gt;HEAD&lt;/code&gt; in the output.</source>
          <target state="translated">출력에 &lt;code&gt;HEAD&lt;/code&gt; 와 같은 벗겨진 태그 또는 유사 참조를 표시하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="2e0add30bcab4fc1d372892ee84a569922f89e58" translate="yes" xml:space="preserve">
          <source>Do not show the progress.</source>
          <target state="translated">진행 상황을 표시하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bb40d4a42e4bfb4ff33aaa6fa93d55da54d2c4f4" translate="yes" xml:space="preserve">
          <source>Do not strip/add &lt;code&gt;[PATCH]&lt;/code&gt; from the first line of the commit log message.</source>
          <target state="translated">커밋 로그 메시지의 첫 번째 줄에서 &lt;code&gt;[PATCH]&lt;/code&gt; 를 제거하거나 추가하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="aa99438dbaa0b24c2ee497186eaab642c50dd94c" translate="yes" xml:space="preserve">
          <source>Do not sync p4/master with Perforce following a submit. Implies git-p4.disableRebase.</source>
          <target state="translated">제출 후 p4 / master를 Perforce와 동기화하지 마십시오. git-p4.disableRebase를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7b33c8101974f45df18e3e02278464887692318a" translate="yes" xml:space="preserve">
          <source>Do not treat &lt;code&gt;---&lt;/code&gt; as the end of the commit message. Use this when you know your input contains just the commit message itself (and not an email or the output of &lt;code&gt;git format-patch&lt;/code&gt;).</source>
          <target state="translated">커밋 메시지의 끝으로 &lt;code&gt;---&lt;/code&gt; 를 취급하지 마십시오 . 입력에 커밋 메시지 자체가 포함되어 있고 전자 메일 또는 &lt;code&gt;git format-patch&lt;/code&gt; 의 출력이 아닌 경우이 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="be1e8c28e0eca20ad17d3a007d8e373df410066a" translate="yes" xml:space="preserve">
          <source>Do not treat root commits as boundaries in &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;. This option defaults to false.</source>
          <target state="translated">루트 커밋을 &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; 에서 경계로 취급하지 마십시오 . 이 옵션의 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="1ff1f1d3f9c5e718776c8b3b20fdd0d08c30cdae" translate="yes" xml:space="preserve">
          <source>Do not treat root commits as boundaries. This can also be controlled via the &lt;code&gt;blame.showRoot&lt;/code&gt; config option.</source>
          <target state="translated">루트 커밋을 경계로 취급하지 마십시오. 또한 &lt;code&gt;blame.showRoot&lt;/code&gt; 구성 옵션을 통해 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24a9efa9a70e1fda7e6a923e07fce62a5dfc6f39" translate="yes" xml:space="preserve">
          <source>Do not trust the line counts in the hunk headers, but infer them by inspecting the patch (e.g. after editing the patch without adjusting the hunk headers appropriately).</source>
          <target state="translated">Hunk 헤더의 줄 수를 신뢰하지 말고 패치를 검사하여 (예 : Hunk 헤더를 적절하게 조정하지 않고 패치를 편집 한 후) 줄 수를 추정하십시오.</target>
        </trans-unit>
        <trans-unit id="ab779b8d99fe56229fa093a46cdef1a09efa24ca" translate="yes" xml:space="preserve">
          <source>Do not try &amp;lt;directory&amp;gt;/.git/ if &amp;lt;directory&amp;gt; is no Git directory.</source>
          <target state="translated">&amp;lt;directory&amp;gt;가 Git 디렉토리가 아닌 경우 &amp;lt;directory&amp;gt; /. git /를 시도하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5c47444dc7f2fc014cd4e67acdf260f62a7c8e62" translate="yes" xml:space="preserve">
          <source>Do not try to update submodules. This option is only respected when passed before --refresh.</source>
          <target state="translated">서브 모듈을 업데이트하지 마십시오. 이 옵션은 --refresh 이전에 전달 된 경우에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2177408392188ae81b2d122883b73ab471a2d934" translate="yes" xml:space="preserve">
          <source>Do not update the server information with &lt;code&gt;git update-server-info&lt;/code&gt;. This option skips updating local catalog files needed to publish this repository (or a direct copy of it) over HTTP or FTP. See &lt;a href=&quot;git-update-server-info&quot;&gt;git-update-server-info[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;git update-server-info&lt;/code&gt; 로 서버 정보를 업데이트하지 마십시오 . 이 옵션은 HTTP 또는 FTP를 통해이 저장소 (또는 직접 사본)를 공개하는 데 필요한 로컬 카탈로그 파일 업데이트를 건너 뜁니다. &lt;a href=&quot;git-update-server-info&quot;&gt;git-update-server-info [1]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5053c19fad3601db22669a9dc4a1e312a5878c5e" translate="yes" xml:space="preserve">
          <source>Do not use any ref whose name matches a given shell pattern. The pattern can be one of branch name, tag name or fully qualified ref name. If given multiple times, a ref will be excluded when it matches any of the given patterns. When used together with --refs, a ref will be used as a match only when it matches at least one --refs pattern and does not match any --exclude patterns. Use &lt;code&gt;--no-exclude&lt;/code&gt; to clear the list of exclude patterns.</source>
          <target state="translated">주어진 쉘 패턴과 이름이 일치하는 심판은 사용하지 마십시오. 패턴은 브랜치 이름, 태그 이름 또는 정규화 된 참조 이름 중 하나 일 수 있습니다. 여러 번 주어진 경우 주어진 패턴 중 하나와 일치하면 심판이 제외됩니다. --refs와 함께 사용하면 하나 이상의 --refs 패턴과 일치하고 --exclude 패턴과 일치하지 않는 경우에만 ref가 일치로 사용됩니다. 제외 패턴 목록을 지우려면 &lt;code&gt;--no-exclude&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="267f50c7506b016b112f51819982f3c9ad863c01" translate="yes" xml:space="preserve">
          <source>Do not use branch names, but only tags to name the commits</source>
          <target state="translated">분기 이름을 사용하지 말고 커밋 이름을 지정하는 태그 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5e1b9e0ae819ac2e51b8b3ec6d4f3a636596bd47" translate="yes" xml:space="preserve">
          <source>Do not use local URLs here if you plan to publish your superproject!</source>
          <target state="translated">수퍼 프로젝트를 게시하려는 경우 여기에 로컬 URL을 사용하지 마십시오!</target>
        </trans-unit>
        <trans-unit id="2120668c1016ed8353ecc179a2be3de457f3b18c" translate="yes" xml:space="preserve">
          <source>Do not use replacement refs to replace Git objects. See &lt;a href=&quot;git-replace&quot;&gt;git-replace[1]&lt;/a&gt; for more information.</source>
          <target state="translated">대체 참조를 사용하여 Git 객체를 교체하지 마십시오. 자세한 내용은 &lt;a href=&quot;git-replace&quot;&gt;git-replace [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="46609390af561170d35a55596a89f9a47d125a47" translate="yes" xml:space="preserve">
          <source>Do not use the --amend option of &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; on a change you&amp;rsquo;ve already dcommitted. It is considered bad practice to --amend commits you&amp;rsquo;ve already pushed to a remote repository for other users, and dcommit with SVN is analogous to that.</source>
          <target state="translated">이미 &lt;a href=&quot;git-commit&quot;&gt;커밋&lt;/a&gt; 한 변경 에는 git-commit [1] 의 --amend 옵션을 사용하지 마십시오 . 이미 다른 사용자를 위해 원격 저장소로 푸시 한 커밋을 수정하는 것은 나쁜 습관으로 간주되며 SVN을 사용한 dcommit은 이와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="6b2f85cff30ddf16b20f53be5327aa0354418c7a" translate="yes" xml:space="preserve">
          <source>Do not verify the pack contents; only show the histogram of delta chain length. With &lt;code&gt;--verbose&lt;/code&gt;, list of objects is also shown.</source>
          <target state="translated">팩 내용물을 확인하지 마십시오. 델타 체인 길이의 히스토그램 만 표시합니다. &lt;code&gt;--verbose&lt;/code&gt; 를 사용하면 객체 목록도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a72712d97eed5eb258082e78ab4de395a4c06778" translate="yes" xml:space="preserve">
          <source>Do nothing; only show what would happen</source>
          <target state="translated">아무것도하지 마세요; 일어날 일만 보여줘</target>
        </trans-unit>
        <trans-unit id="c577d001dfd39377917177f9d18813c77808015f" translate="yes" xml:space="preserve">
          <source>Do some work in the newly created Git repository:</source>
          <target state="translated">새로 만든 Git 리포지토리에서 몇 가지 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d54d62a688502dd57d02a2d25bcfc45fa6646725" translate="yes" xml:space="preserve">
          <source>Do we want to maintain that ability or simply write to the existing Trace2 targets (and convert &amp;lt;key&amp;gt; to a &quot;category&quot;).</source>
          <target state="translated">이 기능을 유지하거나 단순히 기존 Trace2 대상에 쓰고 (&amp;lt;key&amp;gt;를 &quot;범주&quot;로 변환) 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="93e5f9e78ae780b1443364c8b7bf637aab6beb2e" translate="yes" xml:space="preserve">
          <source>Do your work in your repository on &lt;code&gt;master&lt;/code&gt; branch.</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; 브랜치 의 저장소에서 작업하십시오 .</target>
        </trans-unit>
        <trans-unit id="5732ac98ebf7d9e51cffa639f3f3c4cdaefb04a8" translate="yes" xml:space="preserve">
          <source>Does not have a default value; you must configure this variable to enable note rewriting.</source>
          <target state="translated">기본값이 없습니다. 노트 다시 쓰기를 사용하려면이 변수를 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a5f7374d914462e8df26d1af49c06790c2a1cc2" translate="yes" xml:space="preserve">
          <source>Does not have a default value; you must configure this variable to enable note rewriting. Set it to &lt;code&gt;refs/notes/commits&lt;/code&gt; to enable rewriting for the default commit notes.</source>
          <target state="translated">기본값이 없습니다. 노트 다시 쓰기를 사용하려면이 변수를 구성해야합니다. 기본 커밋 노트를 다시 &lt;code&gt;refs/notes/commits&lt;/code&gt; 수있게 하려면 refs / notes / commits 로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="42b7d5032e74e82b8de24d902e036f1902672dbe" translate="yes" xml:space="preserve">
          <source>Does not touch the index file or the working tree at all (but resets the head to &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;, just like all modes do). This leaves all your changed files &quot;Changes to be committed&quot;, as &lt;code&gt;git status&lt;/code&gt; would put it.</source>
          <target state="translated">인덱스 파일이나 작업 트리를 전혀 만지지 마십시오 (그러나 모든 모드와 마찬가지로 헤드를 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 으로 재설정하십시오 ). 이것은 &lt;code&gt;git status&lt;/code&gt; 에 의해 변경된 모든 파일을 &quot;Commit to commit&quot;으로 남겨둔다 .</target>
        </trans-unit>
        <trans-unit id="b8aff1882bc4744bec2ac3cf958c11aa9673615c" translate="yes" xml:space="preserve">
          <source>Does this seem a bit complicated? It &lt;strong&gt;should&lt;/strong&gt; be. There is no way that it would be correct to just &quot;fix&quot; it automatically. People need to know that their tags might have been changed.</source>
          <target state="translated">조금 복잡해 보입니까? 그것은 &lt;strong&gt;해야&lt;/strong&gt; 합니다. 자동으로 &quot;고정&quot;하는 것이 올바른 방법은 없습니다. 사람들은 태그가 변경되었을 수 있음을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="61f5489636e8756fab43669da94d9c6eb1552eb4" translate="yes" xml:space="preserve">
          <source>Doing a &lt;code&gt;git describe&lt;/code&gt; on a tag-name will just show the tag name:</source>
          <target state="translated">tag-name에 &lt;code&gt;git describe&lt;/code&gt; 를 수행하면 태그 이름 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4b69a1e19eb2053bb173df0509ff0e4b7b042821" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t actually add the file(s), just show if they exist and/or will be ignored.</source>
          <target state="translated">실제로 파일을 추가하지 말고 파일이 존재하는지 또는 무시되는지 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="f54d87f7c2ff7fc56cad12eba47750dc91bee0b4" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t actually remove any file(s). Instead, just show if they exist in the index and would otherwise be removed by the command.</source>
          <target state="translated">실제로 파일을 제거하지 마십시오. 대신 색인에 존재하고 명령에 의해 제거되는지 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="3c2e4a22e8795c4f8e08b8be88d75867a6768a7f" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t actually remove any objects, only show those that would have been removed.</source>
          <target state="translated">실제로 개체를 제거하지 말고 제거 된 개체 만 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="8a190a462c45d47d231a38f49fbd7f2f651bc199" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t actually remove anything, just show what would be done.</source>
          <target state="translated">실제로 아무것도 제거하지 말고 수행 할 작업을 보여주십시오.</target>
        </trans-unit>
        <trans-unit id="788dd7013c132044903c150a0852f5a8328a9d58" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t add the file(s), but only refresh their stat() information in the index.</source>
          <target state="translated">파일을 추가하지 말고 색인에서 stat () 정보 만 새로 고치십시오.</target>
        </trans-unit>
        <trans-unit id="f4886df5278511a526465d27599221df6718296c" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t allow recursing into subdirectories</source>
          <target state="translated">하위 디렉토리로의 재귀를 허용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="2b7948ae75b37ecb202b98940fbd260554ad9c60" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t apply changes to files matching the given path pattern. This can be useful when importing patchsets, where you want to exclude certain files or directories.</source>
          <target state="translated">주어진 경로 패턴과 일치하는 파일에는 변경 사항을 적용하지 마십시오. 특정 파일이나 디렉토리를 제외하려는 패치 세트를 가져올 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2f2b3b379c55090808ba7e10cb915259f5f77fb1" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t bother trying to optimize the frontend to stick to one branch at a time during an import. Although doing so might be slightly faster for fast-import, it tends to increase the complexity of the frontend code considerably.</source>
          <target state="translated">가져 오는 동안 한 번에 하나의 브랜치에 고정되도록 프론트 엔드를 최적화하지 않아도됩니다. 빠른 가져 오기의 경우 약간 더 빠를 수 있지만 프론트 엔드 코드의 복잡성이 상당히 증가하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fcb0638343c39672840bc9fb655ac9cf336ccdb" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t check for &lt;code&gt;gitcvs.enabled&lt;/code&gt; in config. You also have to specify a list of allowed directories (see below) if you want to use this option.</source>
          <target state="translated">config에서 &lt;code&gt;gitcvs.enabled&lt;/code&gt; 를 확인하지 마십시오 . 이 옵션을 사용하려면 허용 된 디렉토리 목록을 지정해야합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="f17e0ba24864a0b6291f2e5b252834a0764b0842" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t checkout new files, only refresh files already checked out.</source>
          <target state="translated">새 파일을 체크 아웃하지 말고 이미 체크 아웃 한 파일 만 새로 고치십시오.</target>
        </trans-unit>
        <trans-unit id="22dcca7d230068e332b541f07dc3e71c28dc5b04" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t clone any tags, and set &lt;code&gt;remote.&amp;lt;remote&amp;gt;.tagOpt=--no-tags&lt;/code&gt; in the config, ensuring that future &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git fetch&lt;/code&gt; operations won&amp;rsquo;t follow any tags. Subsequent explicit tag fetches will still work, (see &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;).</source>
          <target state="translated">태그를 복제하지 말고 구성에서 &lt;code&gt;remote.&amp;lt;remote&amp;gt;.tagOpt=--no-tags&lt;/code&gt; 를 설정하여 향후 &lt;code&gt;git pull&lt;/code&gt; 및 &lt;code&gt;git fetch&lt;/code&gt; 작업이 태그를 따르지 않도록하십시오. 후속 명시 적 태그 페치는 여전히 작동합니다 ( &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3928941c430ea9498986b54cb54f9b256c71e581" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t confuse that object with the file &lt;code&gt;hello&lt;/code&gt; itself. The object is literally just those specific &lt;strong&gt;contents&lt;/strong&gt; of the file, and however much you later change the contents in file &lt;code&gt;hello&lt;/code&gt;, the object we just looked at will never change. Objects are immutable.</source>
          <target state="translated">해당 오브젝트를 파일 &lt;code&gt;hello&lt;/code&gt; 자체 와 혼동하지 마십시오 . 객체는 문자 그대로 파일의 특정 &lt;strong&gt;내용&lt;/strong&gt; 이지만 나중에 &lt;code&gt;hello&lt;/code&gt; 파일의 내용을 많이 변경하면 방금 살펴본 객체가 절대 변경되지 않습니다. 객체는 불변입니다.</target>
        </trans-unit>
        <trans-unit id="cf554901f1ba37dc7b685eec286604a92a0846c0" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t look in the index when undertaking the checks. This can be used to debug why a path became tracked by e.g. &lt;code&gt;git add .&lt;/code&gt; and was not ignored by the rules as expected by the user or when developing patterns including negation to match a path previously added with &lt;code&gt;git add -f&lt;/code&gt;.</source>
          <target state="translated">점검을 수행 할 때 색인을 보지 마십시오. 이것은 &lt;code&gt;git add .&lt;/code&gt; 같이 경로가 추적 된 이유를 디버그하는 데 사용될 수 있습니다 . 사용자가 예상 한 규칙이나 &lt;code&gt;git add -f&lt;/code&gt; 로 이전에 추가 된 경로와 일치하는 부정을 포함한 패턴을 개발할 때 규칙에 의해 무시되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="5a869b3f77007c08fe64b3ee7ff33b9bfbbe7c94" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t match the pattern in binary files.</source>
          <target state="translated">이진 파일의 패턴과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a5ec41a36a96759ae5f2ddb0abb3aacee88e9b9" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t output anything, just set exit status. This is only valid with a single pathname.</source>
          <target state="translated">아무것도 출력하지 않고 종료 상태를 설정하십시오. 이것은 단일 경로 이름에서만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="c7bdd135c2e86877ecc2a31a6eaa651f0cae6dc5" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t print anything to standard output. This form is primarily meant to allow the caller to test the exit status to see if a range of objects is fully connected (or not). It is faster than redirecting stdout to &lt;code&gt;/dev/null&lt;/code&gt; as the output does not have to be formatted.</source>
          <target state="translated">표준 출력으로 아무 것도 인쇄하지 마십시오. 이 형식은 주로 발신자가 종료 상태를 테스트하여 다양한 객체가 완전히 연결되어 있는지 여부를 확인하기위한 것입니다. 출력 형식을 지정할 필요가 없으므로 stdout을 &lt;code&gt;/dev/null&lt;/code&gt; 로 리디렉션하는 것보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="0fe178924f571848754ae3ca5c4cf62bf5caeff8" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t prompt before each invocation of the merge resolution program. This is the default if the merge resolution program is explicitly specified with the &lt;code&gt;--tool&lt;/code&gt; option or with the &lt;code&gt;merge.tool&lt;/code&gt; configuration variable.</source>
          <target state="translated">병합 해결 프로그램을 호출 할 때마다 확인하지 마십시오. 병합 해결 프로그램이 &lt;code&gt;--tool&lt;/code&gt; 옵션 또는 &lt;code&gt;merge.tool&lt;/code&gt; 구성 변수를 사용하여 명시 적으로 지정된 경우 이것이 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="aa836ce110cb6ce4b0a545e26c40cb721f663696" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t require an exact match if given an SVN revision, instead find the commit corresponding to the state of the SVN repository (on the current branch) at the specified revision.</source>
          <target state="translated">SVN 개정판이 제공된 경우 정확히 일치하지 않아도되며 지정된 개정판에서 SVN 저장소 (현재 분기의) 상태에 해당하는 커밋을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="30faa3ecbc3ccb0ab260167231bedadc40f9ae9d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t require an exact match if given an SVN revision; if there is not an exact match return the closest match searching forward in the history.</source>
          <target state="translated">SVN 개정판이 제공된 경우 정확하게 일치하지 않아도됩니다. 정확히 일치하는 항목이 없으면 기록에서 가장 근접한 일치 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ef2daf7d2683c0bf520ff3f8d38713d17a81ee22" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t require objects present in packs from alternate object directories to be present in local packs.</source>
          <target state="translated">대체 오브젝트 디렉토리의 팩에 존재하는 오브젝트가 로컬 팩에 존재하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="e1e770659b3cd4fc8fd1b8c1f885e57fa2890f04" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t rescan the working directory for changes after the tool finishes execution.</source>
          <target state="translated">도구 실행이 완료된 후 작업 디렉토리에서 변경 사항을 다시 스캔하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1955458ea299c15696f62795bf10129efdff9000" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use the standard ignore rules (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;), but still use the ignore rules given with &lt;code&gt;-e&lt;/code&gt; options from the command line. This allows removing all untracked files, including build products. This can be used (possibly in conjunction with &lt;code&gt;git restore&lt;/code&gt; or &lt;code&gt;git reset&lt;/code&gt;) to create a pristine working directory to test a clean build.</source>
          <target state="translated">표준 무시 규칙을 사용하지 말고 ( &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt; 참조 ) 명령 행에서 &lt;code&gt;-e&lt;/code&gt; 옵션 과 함께 제공된 무시 규칙을 계속 사용하십시오 . 이를 통해 빌드 제품을 포함하여 추적되지 않은 모든 파일을 제거 할 수 있습니다. 이것은 &lt;code&gt;git restore&lt;/code&gt; 또는 &lt;code&gt;git reset&lt;/code&gt; 과 함께 사용 하여 깨끗한 빌드를 테스트하기 위해 깨끗한 작업 디렉토리를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95e3ebfd9dfe40579e0e7bb35d42c2f1d1029d68" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t worry about the fact that the file that the &lt;code&gt;HEAD&lt;/code&gt; link points to doesn&amp;rsquo;t even exist yet &amp;mdash; you haven&amp;rsquo;t created the commit that will start your &lt;code&gt;HEAD&lt;/code&gt; development branch yet.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 링크가 가리키는 파일 이 아직 존재하지 않는다는 사실에 대해 걱정하지 마십시오 . 아직 &lt;code&gt;HEAD&lt;/code&gt; 개발 브랜치를 시작할 커밋을 만들지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1da5527fefac2ac016e63872cd219c0c8262438e" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t write objects with broken content or links.</source>
          <target state="translated">내용이나 링크가 깨진 개체를 쓰지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e7a1a9f0e0a5a192e64b7762fcd9606f05d43ef7" translate="yes" xml:space="preserve">
          <source>Dotted Range Notations</source>
          <target state="translated">점선 범위 표기법</target>
        </trans-unit>
        <trans-unit id="fe1f0cdd2295f0fc3d04581839d09ed55a16a282" translate="yes" xml:space="preserve">
          <source>Download from a remote Git repository via HTTP</source>
          <target state="translated">HTTP를 통해 원격 Git 저장소에서 다운로드</target>
        </trans-unit>
        <trans-unit id="836b914c612e9d15306b7c7c51825eb694378b40" translate="yes" xml:space="preserve">
          <source>Download objects and refs from another repository</source>
          <target state="translated">다른 저장소에서 객체 및 참조 다운로드</target>
        </trans-unit>
        <trans-unit id="8d0359221c31b38a499fab5fd3539fb10094e3f5" translate="yes" xml:space="preserve">
          <source>Downloader from http and https URL first obtains the topmost commit object name from the remote site by looking at the specified refname under &lt;code&gt;repo.git/refs/&lt;/code&gt; directory, and then tries to obtain the commit object by downloading from &lt;code&gt;repo.git/objects/xx/xxx...&lt;/code&gt; using the object name of that commit object. Then it reads the commit object to find out its parent commits and the associate tree object; it repeats this process until it gets all the necessary objects. Because of this behavior, they are sometimes also called &lt;code&gt;commit walkers&lt;/code&gt;.</source>
          <target state="translated">http 및 https URL의 다운로더는 먼저 &lt;code&gt;repo.git/refs/&lt;/code&gt; 디렉토리 에서 지정된 refname을보고 원격 사이트에서 최상위 커미트 오브젝트 이름 을 확보 한 후 &lt;code&gt;repo.git/objects/xx/xxx...&lt;/code&gt; 에서 다운로드하여 커미트 오브젝트를 확보하려고 시도합니다. / xxx ... 해당 커밋 객체의 객체 이름을 사용합니다. 그런 다음 커밋 객체를 읽어 부모 커밋과 관련 트리 객체를 찾습니다. 필요한 모든 객체를 얻을 때까지이 프로세스를 반복합니다. 이 동작으로 인해 &lt;code&gt;commit walkers&lt;/code&gt; 라고도 합니다 .</target>
        </trans-unit>
        <trans-unit id="412ca0a4593b6bb25e0ce340f46f24955e9564f1" translate="yes" xml:space="preserve">
          <source>Downloads a remote Git repository via HTTP.</source>
          <target state="translated">HTTP를 통해 원격 Git 저장소를 다운로드합니다.</target>
        </trans-unit>
        <trans-unit id="d85415280c4796b4419737c81adcd5229edbb60b" translate="yes" xml:space="preserve">
          <source>Draw a text-based graphical representation of the commit history on the left hand side of the output. This may cause extra lines to be printed in between commits, in order for the graph history to be drawn properly. Cannot be combined with &lt;code&gt;--no-walk&lt;/code&gt;.</source>
          <target state="translated">출력의 왼쪽에 커밋 히스토리의 텍스트 기반 그래픽 표현을 그립니다. 이로 인해 그래프 히스토리가 올바르게 그려지기 위해 커밋 사이에 추가 라인이 인쇄 될 수 있습니다. &lt;code&gt;--no-walk&lt;/code&gt; 와 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b9a3e66d069ffbfcdae00ac848d80a3d7117cd5f" translate="yes" xml:space="preserve">
          <source>Driving a bisection automatically</source>
          <target state="translated">이분법 자동 운전</target>
        </trans-unit>
        <trans-unit id="8c3114460a846e0f3462ade2fcc59d06117961f0" translate="yes" xml:space="preserve">
          <source>Driving a bisection manually</source>
          <target state="translated">수동으로 이등분 운전</target>
        </trans-unit>
        <trans-unit id="cae458d58531d4d41393b21599b7e5c5946ef1f2" translate="yes" xml:space="preserve">
          <source>Dry run. Check the pack file without actually unpacking the objects.</source>
          <target state="translated">드라 이런. 실제로 객체의 포장을 풀지 않고 팩 파일을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5c890eaf0d21c06618fd87da2696a29e291c6564" translate="yes" xml:space="preserve">
          <source>Due to historical reasons a relative &lt;code&gt;filename&lt;/code&gt; is first searched relative to the current directory for &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;clone&lt;/code&gt; and relative to the root of the working tree for &lt;code&gt;fetch&lt;/code&gt;. If &lt;code&gt;filename&lt;/code&gt; is not found, it is searched like any other command in &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">역사적 이유로 상대 &lt;code&gt;filename&lt;/code&gt; 은 &lt;code&gt;init&lt;/code&gt; 및 &lt;code&gt;clone&lt;/code&gt; 에 대한 현재 디렉토리 와 &lt;code&gt;fetch&lt;/code&gt; 에 대한 작업 트리의 루트를 기준으로 먼저 검색 됩니다. 경우 &lt;code&gt;filename&lt;/code&gt; 발견되지 않는, 그것은 다른 어떤 명령과 같이 검색됩니다 &lt;code&gt;$PATH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ad95c4fe8f7afde6130611f6d6b430e519d5657" translate="yes" xml:space="preserve">
          <source>Due to limitations of the current implementation, some configuration variables do not take effect until after the initial fetch and checkout. Configuration variables known to not take effect are: &lt;code&gt;remote.&amp;lt;name&amp;gt;.mirror&lt;/code&gt; and &lt;code&gt;remote.&amp;lt;name&amp;gt;.tagOpt&lt;/code&gt;. Use the corresponding &lt;code&gt;--mirror&lt;/code&gt; and &lt;code&gt;--no-tags&lt;/code&gt; options instead.</source>
          <target state="translated">현재 구현의 한계로 인해 일부 구성 변수는 초기 페치 및 체크 아웃 이후까지 적용되지 않습니다. 적용되지 않는 것으로 알려진 구성 변수는 &lt;code&gt;remote.&amp;lt;name&amp;gt;.mirror&lt;/code&gt; 및 &lt;code&gt;remote.&amp;lt;name&amp;gt;.tagOpt&lt;/code&gt; 입니다. 해당하는 &lt;code&gt;--mirror&lt;/code&gt; 및 &lt;code&gt;--no-tags&lt;/code&gt; 옵션을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d45f204a58b5658a36a8173fede6b8a78f6ae4f4" translate="yes" xml:space="preserve">
          <source>Due to the immutable nature of Git objects, old objects can be archived into shared, read-only directories. This variable specifies a &quot;:&quot; separated (on Windows &quot;;&quot; separated) list of Git object directories which can be used to search for Git objects. New objects will not be written to these directories.</source>
          <target state="translated">Git 객체의 변경 불가능한 특성으로 인해 오래된 객체를 공유 된 읽기 전용 디렉토리에 보관할 수 있습니다. 이 변수는 Git 객체를 검색하는 데 사용할 수있는 Git 객체 디렉토리의 &quot;:&quot;(Windows에서 &quot;;&quot;로 분리) 목록을 지정합니다. 이 디렉토리에는 새로운 객체가 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0f5d7ad945110923c581691c469acfd9049cddb1" translate="yes" xml:space="preserve">
          <source>Due to the lack of accurate tree information (arising from constructing fake ancestors with the limited information available in patches), directory rename detection is disabled in the apply backend. Disabled directory rename detection means that if one side of history renames a directory and the other adds new files to the old directory, then the new files will be left behind in the old directory without any warning at the time of rebasing that you may want to move these files into the new directory.</source>
          <target state="translated">Due to the lack of accurate tree information (arising from constructing fake ancestors with the limited information available in patches), directory rename detection is disabled in the apply backend. Disabled directory rename detection means that if one side of history renames a directory and the other adds new files to the old directory, then the new files will be left behind in the old directory without any warning at the time of rebasing that you may want to move these files into the new directory.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
